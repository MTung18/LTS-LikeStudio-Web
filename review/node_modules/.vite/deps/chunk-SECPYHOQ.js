// node_modules/@bryntum/grid/grid.module.js
var productName = "grid";
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var BrowserHelper = class {
  static cacheFlags(platform = navigator.platform, userAgent = navigator.userAgent) {
    const me = this;
    me._isLinux = Boolean(platform.match(/Linux/));
    me._isMac = Boolean(platform.match(/Mac/));
    me._isWindows = Boolean(platform.match(/Win32/));
    me._isWebkit = Boolean(userAgent.match(/WebKit/) && !userAgent.match(/Edg/));
    me._firefoxVersion = me.getVersion(userAgent, /Firefox\/(\d+)\./);
    me._isFirefox = me._firefoxVersion > 0;
    me._chromeVersion = me.getVersion(userAgent, /Chrom(?:e|ium)\/(\d+)\./);
    me._isChrome = me._chromeVersion > 0;
    me._isSafari = Boolean(userAgent.match(/Safari/)) && !me._isChrome;
    me._isMobileSafari = Boolean(userAgent.match(/Mobile.*Safari/));
    me._safariVersion = me.getVersion(userAgent, /Version\/(.*).Safari/);
    me._isAndroid = Boolean(userAgent.match(/Android/g));
  }
  static get supportsOverflowClip() {
    if (this._supportsOverflowClip == null) {
      const div = document.createElement("div");
      div.style.overflow = "clip";
      div.style.display = "none";
      document.documentElement.appendChild(div);
      this._supportsOverflowClip = div.ownerDocument.defaultView.getComputedStyle(div).getPropertyValue("overflow") === "clip";
      div.remove();
    }
    return this._supportsOverflowClip;
  }
  static get supportsSticky() {
    return true;
  }
  static getVersion(userAgent, versionRe) {
    const match = userAgent.match(versionRe);
    return match ? parseFloat(match[1]) : 0;
  }
  static get isTouchDevice() {
    if (this._isTouchDevice === void 0) {
      this._isTouchDevice = globalThis.matchMedia("(pointer:coarse)").matches;
    }
    return this._isTouchDevice;
  }
  static get isHoverableDevice() {
    if (this._isHoverableDevice === void 0) {
      this._isHoverableDevice = globalThis.matchMedia("(any-hover: hover)").matches;
    }
    return this._isHoverableDevice;
  }
  static get isBrowserEnv() {
    return typeof window !== "undefined";
  }
  static get isMac() {
    return this._isMac;
  }
  static get isWindows() {
    return this._isWindows;
  }
  static get isLinux() {
    return this._isLinux;
  }
  static get isAndroid() {
    return this._isAndroid;
  }
  static get isWebkit() {
    return this._isWebkit;
  }
  static get isChrome() {
    return this._isChrome;
  }
  static get chromeVersion() {
    return this._chromeVersion;
  }
  static get isFirefox() {
    return this._isFirefox;
  }
  static get firefoxVersion() {
    return this._firefoxVersion;
  }
  static get isSafari() {
    return this._isSafari;
  }
  static get safariVersion() {
    return this._safariVersion;
  }
  static get isMobileSafari() {
    return this._isMobileSafari;
  }
  static get platform() {
    const me = this;
    return me._isLinux ? "linux" : me._isMac ? "mac" : me._isWindows ? "windows" : me._isAndroid ? "android" : me._isMobileSafari ? "ios" : null;
  }
  static get supportsPassive() {
    return true;
  }
  static get supportsRandomUUID() {
    if (this._supportsRandomUUID === void 0) {
      try {
        this._supportsRandomUUID = Boolean(globalThis.crypto.randomUUID().length > 0);
      } catch (e) {
        this._supportsRandomUUID = false;
      }
    }
    return this._supportsRandomUUID;
  }
  static get storageAvailable() {
    let storage, x;
    try {
      storage = localStorage;
      x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      return e instanceof DOMException && (e.code === 22 || e.code === 1014 || e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") && storage.length !== 0;
    }
  }
  static setLocalStorageItem(key, value) {
    this.storageAvailable && localStorage.setItem(key, value);
  }
  static getLocalStorageItem(key) {
    return this.storageAvailable && localStorage.getItem(key);
  }
  static removeLocalStorageItem(key) {
    this.storageAvailable && localStorage.removeItem(key);
  }
  static searchParam(paramName, defaultValue2 = null, search = document.location.search) {
    const re = new RegExp(`[?&]${paramName}=?([^&]*)`), match = search.match(re);
    return match && match[1] || defaultValue2;
  }
  static getCookie(name) {
    const nameEq = encodeURIComponent(name) + "=", cookieItems = document.cookie.split(";");
    for (let i = 0; i < cookieItems.length; i++) {
      let c = cookieItems[i];
      while (c.charAt(0) === " ") {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEq) === 0) {
        return decodeURIComponent(c.substring(nameEq.length, c.length));
      }
    }
    return "";
  }
  static download(filename, url) {
    const a = document.createElement("a");
    a.download = filename;
    a.href = url || filename;
    a.style.cssText = "display:none";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }
  static downloadBlob(blob, filename) {
    const url = globalThis.URL.createObjectURL(blob);
    this.download(filename, url);
    globalThis.URL.revokeObjectURL(url);
  }
  static get queryString() {
    var _Object$fromEntries;
    const params = new URL(globalThis.location.href).searchParams;
    return (_Object$fromEntries = Object.fromEntries) === null || _Object$fromEntries === void 0 ? void 0 : _Object$fromEntries.call(Object, params.entries());
  }
  static copyToClipboard(code) {
    let success2 = true;
    const textArea = document.createElement("textarea");
    textArea.value = code;
    textArea.style.height = textArea.style.width = 0;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand("copy");
    } catch (e) {
      success2 = false;
    }
    textArea.remove();
    return success2;
  }
  static isBryntumOnline(searchStrings) {
    var _searchStrings;
    searchStrings = Array.isArray(searchStrings) ? searchStrings : [searchStrings];
    return Boolean(/^(www\.)?bryntum\.com/.test(globalThis.location.host) || ((_searchStrings = searchStrings) === null || _searchStrings === void 0 ? void 0 : _searchStrings.some((str) => this.queryString[str] != null)));
  }
  static get isCSP() {
    const {
      bryntum,
      document: document2
    } = globalThis;
    if (bryntum.CSP == null) {
      bryntum.CSP = Boolean(document2.querySelector('meta[http-equiv="Content-Security-Policy"]'));
    }
    return bryntum.CSP;
  }
  static async setupClipboard() {
    if (!window.bryntum.clipboard) {
      window.bryntum.clipboard = {
        hasNativeAccess: true,
        async writeText(text, allowNative) {
          if (allowNative && this.hasNativeAccess) {
            try {
              await navigator.clipboard.writeText(text);
            } catch (e) {
              this.hasNativeAccess = false;
            }
          }
          this._content = text;
        },
        async readText(allowNative) {
          if (allowNative && this.hasNativeAccess) {
            try {
              return await navigator.clipboard.readText();
            } catch (e) {
              this.hasNativeAccess = false;
            }
          }
          return this._content;
        }
      };
    }
    return window.bryntum.clipboard;
  }
  static async writeToClipboard(text, allowNative = true) {
    const clipboard = await this.setupClipboard();
    return await clipboard.writeText(text, allowNative);
  }
  static async readFromClipboard(allowNative = true) {
    const clipboard = await this.setupClipboard();
    return await clipboard.readText(allowNative);
  }
};
_defineProperty(BrowserHelper, "supportsPointerEvents", Boolean(globalThis.PointerEvent || globalThis.MSPointerEvent));
_defineProperty(BrowserHelper, "supportsPointerEventConstructor", typeof PointerEvent !== "undefined");
if (BrowserHelper.isBrowserEnv) {
  BrowserHelper.cacheFlags();
}
BrowserHelper._$name = "BrowserHelper";
var charsToEncode;
var entitiesToDecode;
var htmlEncodeRe;
var htmlDecodeRe;
var camelLettersRe = /([a-z])([A-Z])/g;
var crlfRe = /[\n\r]/g;
var escapeRegExpRe = /[.*+?^${}()|[\]\\]/g;
var htmlRe$1 = /[&<]/;
var idRe = /(^[^a-z]+[^\w]+)/gi;
var whiteSpaceRe$1 = /\s+/;
var domIdRe = /^[^a-z]+|[^\w:.-]+/gi;
var htmlDecoder = (m, captured) => entitiesToDecode[captured.toLowerCase()] || String.fromCharCode(parseInt(captured.substr(2), 10));
var htmlEncoder = (m, captured) => charsToEncode[captured];
var hyphenateCamelLetters = (all, g1, g2) => {
  return `${g1}-${g2.toLowerCase()}`;
};
var separateCamelLetters = (all, g1, g2) => {
  return `${g1} ${g2.toLowerCase()}`;
};
var replaceNonIdChar = (c) => {
  if (c) {
    return `_x${[...c].map((ch) => ch.charCodeAt(0).toString(16)).join("")}`;
  }
  return "__blank__";
};
var hyphenateCache = {};
var separatedCache = {};
var StringHelper = class {
  static capitalize(string2) {
    return string2 && string2[0].toUpperCase() + string2.substr(1);
  }
  static uncapitalize(string2) {
    return string2 && string2[0].toLowerCase() + string2.substr(1);
  }
  static hyphenate(string2) {
    const cached = hyphenateCache[string2];
    if (cached) {
      return cached;
    }
    return hyphenateCache[string2] = string2.replace(camelLettersRe, hyphenateCamelLetters);
  }
  static separate(string2) {
    const cached = separatedCache[string2];
    if (cached) {
      return cached;
    }
    return separatedCache[string2] = this.capitalize(string2.replace(camelLettersRe, separateCamelLetters));
  }
  static createId(inString) {
    return String(inString).replace(idRe, replaceNonIdChar);
  }
  static makeValidDomId(id, replaceValue = "") {
    if (id == null) {
      return null;
    }
    return String(id).replace(domIdRe, replaceValue);
  }
  static escapeRegExp(string2, flags) {
    let ret = string2.replace(escapeRegExpRe, "\\$&");
    if (flags !== void 0) {
      ret = new RegExp(ret, flags);
    }
    return ret;
  }
  static decodeHtml(str) {
    return str && String(str).replace(htmlDecodeRe, htmlDecoder);
  }
  static encodeHtml(str = "") {
    return str && String(str).replace(htmlEncodeRe, htmlEncoder);
  }
  static encodeHtmlBR(str) {
    var _StringHelper$encodeH;
    return (_StringHelper$encodeH = StringHelper.encodeHtml(str)) === null || _StringHelper$encodeH === void 0 ? void 0 : _StringHelper$encodeH.replace(crlfRe, "<br>");
  }
  static isHtml(text) {
    return typeof text === "string" && htmlRe$1.test(text || "");
  }
  static initHtmlEntities(mappings) {
    mappings = mappings || {
      "&": "&amp;",
      ">": "&gt;",
      "<": "&lt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    const chars = Object.keys(mappings);
    charsToEncode = mappings;
    entitiesToDecode = chars.reduce((prev, val) => {
      prev[mappings[val]] = val;
      return prev;
    }, {});
    htmlEncodeRe = new RegExp(`([${chars.map((c) => "[-]".includes(c) ? "\\" + c : c).join("")}])`, "g");
    htmlDecodeRe = new RegExp(`(${Object.values(mappings).join("|")}|&#[0-9]+;)`, "ig");
  }
  static safeJsonParse(string2) {
    let parsed = null;
    try {
      parsed = JSON.parse(string2);
    } catch (e) {
    }
    return parsed;
  }
  static safeJsonStringify(object, replacer = null, space = null) {
    let result = null;
    try {
      result = JSON.stringify(object, replacer, space);
    } catch (e) {
    }
    return result;
  }
  static joinPaths(paths, pathSeparator = "/") {
    return paths.join(pathSeparator).replace(new RegExp("\\" + pathSeparator + "+", "g"), pathSeparator);
  }
  static split(str, delimiter = whiteSpaceRe$1) {
    let ret = str;
    if (typeof ret === "string") {
      ret = str.trim();
      ret = ret ? ret.split(delimiter) : [];
    }
    return ret;
  }
  static xss(strings, ...values) {
    const buf = [];
    let i = values.length;
    buf[i] = strings[i];
    while (i-- > 0) {
      buf[i] = strings[i] + StringHelper.encodeHtml(values[i]);
    }
    return buf.join("");
  }
  static xssBR(strings, ...values) {
    const buf = [];
    let i = values.length;
    buf[i] = strings[i];
    while (i-- > 0) {
      buf[i] = strings[i] + StringHelper.encodeHtmlBR(values[i]);
    }
    return buf.join("");
  }
  static toJavaScriptValue(value, options) {
    const type = Objects.typeOf(value);
    if (type === "boolean" || type === "string" || type === "number" || value === null) {
      return StringHelper.safeJsonStringify(value);
    }
    if (value === globalThis) {
      return "window";
    }
    if (type === "date") {
      return `new Date(${value.getFullYear()}, ${value.getMonth()}, ${value.getDate()}, ${value.getHours()}, ${value.getMinutes()}, ${value.getSeconds()}, ${value.getMilliseconds()})`;
    }
    if (type === "array") {
      return `[${value.map((v) => StringHelper.toJavaScriptValue(v, options))}]`;
    }
    if (type === "object" || type === "instance") {
      return this.toJavaScriptString(value, options);
    }
    if (type === "function") {
      let contents = value.toString();
      if (contents.match(/^async (\w+?)\(/)) {
        contents = contents.replace(/^async (\w+?)\(/, "async function(");
      } else if (!contents.startsWith("async(") && contents.match(/^(\w+?)\(/)) {
        contents = contents.replace(/^(\w+?)\(/, "function(");
      }
      return contents;
    }
    if (type === "class") {
      if (value.toJavaScriptValue) {
        return value.toJavaScriptValue(options);
      }
      return Object.prototype.hasOwnProperty.call(value, "$name") ? value.$name : value.name;
    }
  }
  static toJavaScriptString(obj, options = {}) {
    var _options$level;
    const level = (_options$level = options.level) !== null && _options$level !== void 0 ? _options$level : 0, intendSize = 2;
    return "{\n" + Object.keys(obj).map((key) => " ".repeat((level + 1) * intendSize) + (key.match(/[- *]/) ? `"${key}"` : key) + `: ${StringHelper.toJavaScriptValue(obj[key], _objectSpread2(_objectSpread2({}, options), {}, {
      level: level + 1
    }))}`).join(",\n") + "\n" + " ".repeat(level * intendSize) + "}";
  }
  static encodeAttributeSelector(attr, value) {
    return `[${attr}="${String(value).replace(/["\\]/g, "\\$&")}"]`;
  }
  static generateUUID() {
    var _globalThis$crypto;
    if (BrowserHelper.supportsRandomUUID) {
      return globalThis.crypto.randomUUID();
    }
    if ((_globalThis$crypto = globalThis.crypto) !== null && _globalThis$crypto !== void 0 && _globalThis$crypto.getRandomValues) {
      return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) => (c ^ globalThis.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
    }
    return `${Date.now()}-${++StringHelper.fakeNodeUUIDIndex}`;
  }
};
_defineProperty(StringHelper, "fakeNodeUUIDIndex", 0);
StringHelper.initHtmlEntities();
StringHelper._$name = "StringHelper";
var {
  hasOwnProperty: hasOwnProperty$6,
  toString: toString$3
} = Object.prototype;
var {
  isFrozen
} = Object;
var afterRe = /\s*<\s*/;
var beforeRe = /\s*>\s*/;
var blendOptions = {};
var typeCache = {};
var emptyObject$8 = Object.freeze({});
var Objects = class {
  static assign(dest, ...sources) {
    for (let source, key, i = 0; i < sources.length; i++) {
      source = sources[i];
      if (source) {
        for (key in source) {
          dest[key] = source[key];
        }
      }
    }
    return dest;
  }
  static assignIf(dest, ...sources) {
    for (let source, key, i = 0; i < sources.length; i++) {
      source = sources[i];
      if (source) {
        for (key in source) {
          if (!(key in dest) || dest[key] === void 0) {
            dest[key] = source[key];
          }
        }
      }
    }
    return dest;
  }
  static blend(dest, source, options) {
    options = options || blendOptions;
    dest = dest || {};
    const {
      clone = Objects.clone,
      merge = Objects.blend
    } = options;
    if (Array.isArray(source)) {
      if (source.length > 1) {
        source.forEach((s) => {
          dest = Objects.blend(dest, s, options);
        });
        return dest;
      }
      source = source[0];
    }
    if (source) {
      let destValue, key, value;
      for (key in source) {
        value = source[key];
        if (value && Objects.isObject(value)) {
          destValue = dest[key];
          options.key = key;
          if (destValue && Objects.isObject(destValue)) {
            if (isFrozen(destValue)) {
              dest[key] = destValue = clone(destValue, options);
            }
            value = merge(destValue, value, options);
          } else {
            value = isFrozen(value) ? value : clone(value, options);
          }
        }
        dest[key] = value;
      }
    }
    return dest;
  }
  static clone(value, handler) {
    let cloned = value, key;
    if (value && typeof value === "object") {
      const options = handler && typeof handler === "object" && handler;
      if (options) {
        handler = null;
      }
      if (Objects.isObject(value)) {
        if (value.skipClone) {
          cloned = value;
        } else {
          cloned = {};
          for (key in value) {
            cloned[key] = Objects.clone(value[key]);
          }
        }
      } else if (Array.isArray(value)) {
        cloned = [];
        for (key = value.length; key-- > 0; ) {
          cloned[key] = Objects.clone(value[key]);
        }
      } else if (Objects.isDate(value)) {
        cloned = new Date(value.getTime());
      } else if (handler) {
        cloned = handler(value);
      }
    }
    return cloned;
  }
  static createTruthyKeys(source) {
    const keys = StringHelper.split(source), result = keys && {};
    if (keys) {
      for (const key of keys) {
        if (key) {
          result[key] = true;
        }
      }
    }
    return result;
  }
  static getPath(object, path) {
    return path.split(".").reduce((result, key) => {
      return (result || emptyObject$8)[key];
    }, object);
  }
  static getPathDefault(object, path, defaultValue2) {
    const keys = Array.isArray(path) ? path : typeof path === "string" ? path.split(".") : [path], length = keys.length - 1;
    return keys.reduce((result, key, index) => {
      if (defaultValue2 && !(key in result)) {
        result[key] = index === length ? defaultValue2 : {};
      }
      return (result || emptyObject$8)[key];
    }, object);
  }
  static hasPath(object, path) {
    return path.split(".").every((key) => {
      if (key in object) {
        object = object[key];
        return true;
      }
      return false;
    });
  }
  static getTruthyKeys(source) {
    const keys = [];
    for (const key in source) {
      if (source[key]) {
        keys.push(key);
      }
    }
    return keys;
  }
  static getTruthyValues(source) {
    const values = [];
    for (const key in source) {
      if (source[key]) {
        values.push(source[key]);
      }
    }
    return values;
  }
  static isClass(object) {
    var _object$prototype;
    if (typeof object === "function" && ((_object$prototype = object.prototype) === null || _object$prototype === void 0 ? void 0 : _object$prototype.constructor) === object) {
      return true;
    }
    return false;
  }
  static isDate(object) {
    return Boolean(object === null || object === void 0 ? void 0 : object.getUTCDate) && Objects.typeOf(object) === "date";
  }
  static isPromise(object) {
    if (Promise && Promise.resolve) {
      return Promise.resolve(object) === object || typeof (object === null || object === void 0 ? void 0 : object.then) === "function";
    }
    throw new Error("Promise not supported in your environment");
  }
  static isEmpty(object) {
    if (object && typeof object === "object") {
      for (const p in object) {
        return false;
      }
    }
    return true;
  }
  static isObject(value) {
    const C = value === null || value === void 0 ? void 0 : value.constructor;
    return Boolean(C ? C === Object || C.getPrototypeOf && C.prototype && !Object.getPrototypeOf(C.prototype) : value && typeof value === "object");
  }
  static isInstantiated(object) {
    return object ? typeof object === "object" && !Objects.isObject(object) : false;
  }
  static merge(dest, ...sources) {
    return Objects.blend(dest, sources);
  }
  static mergeItems(dest, src, options) {
    options = options || blendOptions;
    let anchor, delta, index, indexMap, key, shuffle, srcVal;
    const {
      merge = Objects.blend
    } = options;
    dest = dest || {};
    if (Array.isArray(src)) {
      src.forEach((s) => {
        dest = Objects.mergeItems(dest, s, options);
      });
    } else if (src) {
      for (key in src) {
        srcVal = src[key];
        anchor = null;
        if (key.includes(">")) {
          [key, anchor] = key.split(beforeRe);
          delta = 0;
        } else if (key.includes("<")) {
          [anchor, key] = key.split(afterRe);
          delta = 1;
        }
        if (key in dest) {
          if (srcVal && dest[key] && merge) {
            options.key = key;
            srcVal = merge(dest[key], srcVal, options);
          }
          dest[key] = srcVal;
        } else if (!anchor) {
          var _indexMap;
          dest[key] = srcVal;
          (_indexMap = indexMap) === null || _indexMap === void 0 ? void 0 : _indexMap.set(key, indexMap.size);
        } else {
          if (!indexMap) {
            indexMap = /* @__PURE__ */ new Map();
            index = 0;
            for (const k in dest) {
              indexMap.set(k, index++);
            }
          }
          index = indexMap.get(anchor);
          dest[key] = srcVal;
          if (index == null && delta) {
            index = indexMap.size;
          } else {
            shuffle = shuffle || [];
            index = (index || 0) + delta;
            for (const item of indexMap) {
              const [k, v] = item;
              if (index <= v) {
                shuffle && (shuffle[indexMap.size - v - 1] = k);
                indexMap.set(k, v + 1);
              }
            }
            if (shuffle) {
              while (shuffle.length) {
                const k = shuffle.pop(), v = dest[k];
                delete dest[k];
                dest[k] = v;
              }
            }
          }
          indexMap.set(key, index);
        }
      }
    }
    return dest;
  }
  static setPath(object, path, value) {
    path.split(".").reduce((result, key, index, array) => {
      const isLast = index === array.length - 1;
      if (isLast) {
        return result[key] = value;
      } else if (!(result[key] instanceof Object)) {
        result[key] = {};
      }
      return result[key];
    }, object);
    return object;
  }
  static typeOf(value) {
    let trueType, type;
    if (value === null) {
      type = "null";
    } else if (value !== value) {
      type = "nan";
    } else {
      type = typeof value;
      if (type === "object") {
        if (value.isBase) {
          type = "instance";
        } else if (Array.isArray(value)) {
          type = "array";
        } else if (!(type = typeCache[trueType = toString$3.call(value)])) {
          typeCache[trueType] = type = trueType.slice(8, -1).toLowerCase();
        }
      } else if (type === "function" && value.isBase) {
        type = "class";
      }
    }
    return type;
  }
};
Object.defineProperty(Objects, "hasOwn", {
  value: Object.hasOwn || ((object, property) => hasOwnProperty$6.call(object, property))
});
Objects._$name = "Objects";
var VersionHelper = class {
  static setVersion(product, version) {
    product = product.toLowerCase();
    VH[product] = {
      version,
      isNewerThan(otherVersion) {
        return VersionHelper.semanticCompareVersion(otherVersion, version, "<");
      },
      isOlderThan(otherVersion) {
        return VersionHelper.semanticCompareVersion(otherVersion, version, ">");
      }
    };
    let bundleFor = "";
    if (typeof productName !== "undefined") {
      bundleFor = productName;
    }
    const globalKey = `${bundleFor}.${product}${version.replace(/\./g, "-")}`;
    if (BrowserHelper.isBrowserEnv && !globalThis.bryntum.silenceBundleException) {
      if (globalThis.bryntum[globalKey] === true) {
        if (this.isTestEnv) {
          globalThis.BUNDLE_EXCEPTION = true;
        } else {
          let errorProduct = bundleFor || product;
          if (errorProduct === "core") {
            errorProduct = "grid";
          }
          let capitalized = StringHelper.capitalize(errorProduct);
          if (errorProduct === "schedulerpro") {
            capitalized = "SchedulerPro";
          }
          throw new Error(`The Bryntum ${capitalized} bundle was loaded multiple times by the application.

Common reasons you are getting this error includes:

* Imports point to different types of the bundle (e.g. *.module.js and *.umd.js)
* Imports point to both sources and bundle
* Imports do not use the shortest relative path, JS treats them as different files
* Cache busters differ between imports, JS treats ${errorProduct}.module.js?1 and ${errorProduct}.module.js?2 as different files
* Imports missing file type, verify they all end in .js

See https://bryntum.com/products/${errorProduct}/docs/guide/${capitalized}/gettingstarted/es6bundle#troubleshooting for more information

`);
        }
      } else {
        globalThis.bryntum[globalKey] = true;
      }
    }
  }
  static getVersion(product) {
    product = product.toLowerCase();
    if (!VH[product]) {
      throw new Error("No version specified! Please check that you import VersionHelper correctly into the class from where you call `deprecate` function.");
    }
    return VH[product].version;
  }
  static semanticCompareVersion(version1, version2, comparison = "=") {
    version1 = version1 || "";
    version2 = version2 || "";
    const version1Arr = version1.split(/[-.]/), version2Arr = version2.split(/[-.]/), isLower = comparison.includes("<"), normalizeArr = (arr, maxLength) => {
      const states = ["rc", "beta", "alpha"], result = arr.map((v) => {
        if (states.includes(v)) {
          return -states.indexOf(v) - 2;
        }
        const res = Number.parseInt(v);
        return Number.isNaN(res) ? -states.length : res;
      });
      while (result.length < maxLength) {
        result.push(-1);
      }
      return result;
    }, compareArr = () => {
      const maxLength = Math.max(version1Arr.length, version2Arr.length), arr1 = normalizeArr(version1Arr, maxLength), arr2 = normalizeArr(version2Arr, maxLength);
      for (let i = 0; i < maxLength; i++) {
        if (arr1[i] !== arr2[i]) {
          return isLower ? arr1[i] < arr2[i] : arr1[i] > arr2[i];
        }
      }
      return true;
    };
    switch (comparison) {
      case "=":
        return version1 === version2;
      case "<=":
      case ">=":
        return version1 === version2 || compareArr();
      case "<":
      case ">":
        return version1 !== version2 && compareArr();
    }
    return false;
  }
  static checkVersion(product, version, operator) {
    return VersionHelper.semanticCompareVersion(VH.getVersion(product), version, operator);
  }
  static deprecate(product, invalidAsOfVersion, message) {
    const justWarn = VH.checkVersion(product, invalidAsOfVersion, "<");
    if (justWarn) {
      console.warn(`Deprecation warning: You are using a deprecated API which will change in v${invalidAsOfVersion}. ${message}`);
    } else {
      throw new Error(`Deprecated API use. ${message}`);
    }
  }
  static get isTestEnv() {
    var _globalThis$bryntum;
    const isTestEnv = Boolean((_globalThis$bryntum = globalThis.bryntum) === null || _globalThis$bryntum === void 0 ? void 0 : _globalThis$bryntum.isTestEnv);
    try {
      var _globalThis$parent, _globalThis$parent$br;
      return isTestEnv || Boolean((_globalThis$parent = globalThis.parent) === null || _globalThis$parent === void 0 ? void 0 : (_globalThis$parent$br = _globalThis$parent.bryntum) === null || _globalThis$parent$br === void 0 ? void 0 : _globalThis$parent$br.isTestEnv);
    } catch (e) {
      return isTestEnv;
    }
  }
  static get isDebug() {
    let result = false;
    return result;
  }
};
var VH = VersionHelper;
if (BrowserHelper.isBrowserEnv) {
  if (VH.isTestEnv) {
    BrowserHelper._isHoverableDevice = true;
  }
  globalThis.bryntum = Object.assign(globalThis.bryntum || {}, {
    getVersion: VH.getVersion.bind(VH),
    checkVersion: VH.checkVersion.bind(VH),
    deprecate: VH.deprecate.bind(VH),
    license: "3bdf5168-3655-11eb-b269-d094663d5c88"
  });
}
VersionHelper._$name = "VersionHelper";
var {
  defineProperty: defineProperty$7,
  getOwnPropertyDescriptor: getOwnPropertyDescriptor$1
} = Reflect;
var {
  hasOwnProperty: hasOwnProperty$5,
  toString: toString$2
} = Object.prototype;
var instancePropertiesSymbol$1 = Symbol("instanceProperties");
var configuringSymbol$1 = Symbol("configuring");
var lazyConfigValues = Symbol("lazyConfigValues");
var DATE_TYPE$1 = toString$2.call(new Date());
var whitespace = /\s+/;
var createClsProps = (result, cls) => {
  result[cls] = 1;
  return result;
};
var Config = class {
  static get(name, options) {
    const {
      cache
    } = this, baseCfg = cache[name] || (cache[name] = new Config(name));
    let cfg = baseCfg, key;
    if (options) {
      key = Config.makeCacheKey(name, options);
      if (!(cfg = key && cache[key])) {
        cfg = baseCfg.extend(options);
        if (key) {
          cache[key] = cfg;
        }
      }
    }
    return cfg;
  }
  constructor(name) {
    const me = this, cap = name[0].toUpperCase() + name.substr(1);
    me.base = me;
    me.name = name;
    me.field = "_" + name;
    me.capName = cap;
    me.changer = "change" + cap;
    me.initializing = "initializing" + cap;
    me.updater = "update" + cap;
  }
  get descriptor() {
    let descriptor = this._descriptor;
    if (!descriptor || !hasOwnProperty$5.call(this, "_descriptor")) {
      this._descriptor = descriptor = this.makeDescriptor();
    }
    return descriptor;
  }
  get initDescriptor() {
    let descriptor = this._initDescriptor;
    if (!descriptor || !hasOwnProperty$5.call(this, "_initDescriptor")) {
      this._initDescriptor = descriptor = this.makeInitter();
    }
    return descriptor;
  }
  equal(value1, value2) {
    return value1 === value2;
  }
  extend(options) {
    const cfg = Object.assign(Object.create(this), options), {
      equal: equal2,
      merge
    } = options, {
      equalityMethods
    } = Config;
    if (typeof equal2 === "string") {
      if (equal2.endsWith("[]")) {
        cfg.equal = Config.makeArrayEquals(equalityMethods[equal2.substr(0, equal2.length - 2)]);
      } else {
        cfg.equal = equalityMethods[equal2];
      }
    }
    if (typeof merge === "string") {
      cfg.merge = Config.mergeMethods[merge];
    }
    return cfg;
  }
  define(target) {
    const existing = getOwnPropertyDescriptor$1(target, this.name);
    let descriptor = this.descriptor;
    if (existing && existing.get) {
      descriptor = Object.assign({}, descriptor);
      descriptor.get = existing.get;
    }
    defineProperty$7(target, this.name, descriptor);
  }
  defineInitter(target, value) {
    const {
      name
    } = this, properties = target[instancePropertiesSymbol$1];
    let lazyValues, prop;
    if (!properties[name] && (prop = getOwnPropertyDescriptor$1(target, name)) && !("value" in prop)) {
      properties[name] = prop;
    }
    defineProperty$7(target, name, this.initDescriptor);
    if (this.lazy) {
      lazyValues = target[lazyConfigValues] || (target[lazyConfigValues] = /* @__PURE__ */ new Map());
      lazyValues.set(name, value);
    }
  }
  static makeArrayEquals(fn) {
    return (value1, value2) => {
      let i, equal2 = value1 && value2 && value1.length === (i = value2.length);
      if (equal2 && Array.isArray(value1) && Array.isArray(value2)) {
        if (fn) {
          while (equal2 && i-- > 0) {
            equal2 = fn(value1[i], value2[i]);
          }
        } else {
          while (equal2 && i-- > 0) {
            equal2 = value1[i] === value2[i];
          }
        }
      } else {
        equal2 = fn ? fn(value1, value2) : value1 === value2;
      }
      return equal2;
    };
  }
  static makeCacheKey(name, options) {
    const keys = Object.keys(options).sort();
    for (let key, type, value, i = keys.length; i-- > 0; ) {
      value = options[key = keys[i]];
      if (value == null && value === false) {
        keys.splice(i, 1);
      } else {
        type = typeof value;
        if (type === "function") {
          return null;
        }
        if (type === "string") {
          keys[i] = `${key}:"${value}"`;
        } else if (type === "number") {
          keys[i] = `${key}:${value}`;
        }
      }
    }
    return keys.length ? `${name}>${keys.join("|")}` : name;
  }
  makeDescriptor() {
    const config = this, {
      base,
      field,
      changer,
      updater,
      name
    } = config;
    if (base !== config && base.equal === config.equal) {
      return base.descriptor;
    }
    return {
      get() {
        var _this$configObserver;
        (_this$configObserver = this.configObserver) === null || _this$configObserver === void 0 ? void 0 : _this$configObserver.get(name, this);
        return this[field];
      },
      set(value) {
        const me = this;
        let was = me[field], applied, newValue;
        if (typeof value === "string") {
          let resolvedValue = value;
          if (value.startsWith("up.")) {
            var _me$owner;
            resolvedValue = (_me$owner = me.owner) === null || _me$owner === void 0 ? void 0 : _me$owner.resolveProperty(value.substr(3));
          } else if (value.startsWith("this.")) {
            resolvedValue = me.resolveProperty(value.substr(5));
          }
          if (resolvedValue !== void 0 && typeof resolvedValue !== "function") {
            value = resolvedValue;
          }
        }
        if (me[changer]) {
          applied = (newValue = me[changer](value, was)) === void 0;
          if (!applied) {
            value = newValue;
            was = me[field];
          }
        }
        if (!applied && !(config.equal === equal ? was === value : config.equal(was, value))) {
          var _me$updater;
          me[field] = value;
          applied = true;
          (_me$updater = me[updater]) === null || _me$updater === void 0 ? void 0 : _me$updater.call(me, value, was);
        }
        if (applied && !me.onConfigChange.$nullFn) {
          me.onConfigChange({
            name,
            value,
            was,
            config
          });
        }
      }
    };
  }
  makeInitter() {
    const config = this;
    if (config !== config.base) {
      if (config.lazy) {
        return config.makeLazyInitter();
      }
      return config.base.initDescriptor;
    }
    return config.makeBasicInitter();
  }
  makeBasicInitter() {
    const config = this, {
      initializing,
      name
    } = config;
    return {
      configurable: true,
      get() {
        const me = this;
        config.removeInitter(me);
        me[initializing] = true;
        me[name] = me[configuringSymbol$1][name];
        me[initializing] = false;
        me.configDone[name] = true;
        return me[name];
      },
      set(value) {
        config.removeInitter(this);
        this.configDone[name] = true;
        this[name] = value;
      }
    };
  }
  makeLazyInitter() {
    const config = this, {
      initializing,
      name
    } = config;
    return {
      configurable: true,
      get() {
        const me = this, value = me[lazyConfigValues].get(name);
        config.removeInitter(me);
        if (!me.isDestroying) {
          me[initializing] = true;
          me[name] = value;
          me[initializing] = false;
        }
        return me[name];
      },
      set(value) {
        config.removeInitter(this);
        this[name] = value;
      }
    };
  }
  removeInitter(instance) {
    const {
      name
    } = this, instanceProperty = instance[instancePropertiesSymbol$1][name], lazyValues = instance[lazyConfigValues];
    if (instanceProperty) {
      defineProperty$7(instance, name, instanceProperty);
    } else {
      delete instance[name];
    }
    if (lazyValues !== null && lazyValues !== void 0 && lazyValues.delete(name) && !lazyValues.size) {
      delete instance[lazyConfigValues];
    }
  }
  setDefault(cls, value) {
    defineProperty$7(cls.prototype, this.field, {
      configurable: true,
      writable: true,
      value
    });
  }
  merge(newValue, currentValue) {
    if (currentValue && newValue && Objects.isObject(newValue)) {
      if (currentValue.isBase) {
        return currentValue.setConfig(newValue);
      }
      if (Objects.isObject(currentValue)) {
        newValue = Objects.merge(Objects.clone(currentValue), newValue);
      }
    }
    return newValue;
  }
};
var {
  prototype
} = Config;
var {
  equal
} = prototype;
Config.symbols = {
  configuring: configuringSymbol$1,
  instanceProperties: instancePropertiesSymbol$1,
  lazyConfigs: lazyConfigValues
};
Config.cache = /* @__PURE__ */ Object.create(null);
Config.equalityMethods = {
  array: Config.makeArrayEquals(),
  date(value1, value2) {
    if (value1 === value2) {
      return true;
    }
    if (value1 && value2 && toString$2.call(value1) === DATE_TYPE$1 && toString$2.call(value2) === DATE_TYPE$1) {
      return value1.getTime() === value2.getTime();
    }
    return false;
  },
  strict: Config.equal = equal
};
Config.mergeMethods = {
  distinct(newValue, oldValue) {
    let ret = oldValue ? oldValue.slice() : [];
    if (newValue != null) {
      if (Objects.isObject(newValue)) {
        if (oldValue === void 0) {
          ret = newValue;
        } else {
          let key, index;
          for (key in newValue) {
            index = ret.indexOf(key);
            if (newValue[key]) {
              if (index < 0) {
                ret.push(key);
              }
            } else if (index > -1) {
              ret.splice(index, 1);
            }
          }
        }
      } else if (Array.isArray(newValue)) {
        newValue.forEach((v) => !ret.includes(v) && ret.push(v));
      } else if (!ret.includes(newValue)) {
        ret.push(newValue);
      }
    }
    return ret;
  },
  merge: Config.merge = prototype.merge,
  classList(newValue, oldValue) {
    if (typeof newValue === "string") {
      if (!newValue.length) {
        return oldValue;
      }
      newValue = newValue.split(whitespace);
    }
    if (Array.isArray(newValue)) {
      newValue = newValue.reduce(createClsProps, {});
    }
    return Config.merge(newValue, oldValue);
  },
  objects(newValue, oldValue) {
    return newValue === true ? oldValue || {} : Config.merge(newValue, oldValue);
  },
  replace(newValue) {
    return newValue;
  },
  items(newValue, oldValue, metaNew, metaCurrent) {
    if (metaCurrent) {
      return Objects.mergeItems(oldValue, newValue, {
        merge: (oldValue2, newValue2) => prototype.merge(newValue2, oldValue2)
      });
    }
    return prototype.merge(newValue, oldValue);
  }
};
Object.assign(prototype, {
  _descriptor: null,
  _initDescriptor: null,
  lazy: false,
  nullify: false,
  render: false
});
Config._$name = "Config";
var MetaClass = class {
  constructor(options) {
    options && Object.assign(this, options);
  }
  getInherited(name, create = true) {
    let ret = this[name];
    if (!(name in this)) {
      var _this$super;
      ret = (_this$super = this.super) === null || _this$super === void 0 ? void 0 : _this$super.getInherited(name, create);
      if (ret || create) {
        this[name] = ret = Object.create(ret || null);
      }
    }
    return ret;
  }
};
var {
  getPrototypeOf: getPrototypeOf$1
} = Object;
var {
  hasOwn: hasOwn$3
} = Objects;
var {
  defineProperty: defineProperty$6
} = Reflect;
var metaSymbol = Symbol("classMetaData");
var mixinTagSymbol = Symbol("mixinTag");
var originalConfigSymbol = Symbol("originalConfig");
var configuringSymbol = Config.symbols.configuring;
var instancePropertiesSymbol = Config.symbols.instanceProperties;
var lazyConfigsSymbol = Config.symbols.lazyConfigs;
var defaultConfigOptions = {
  merge: "replace",
  simple: true
};
var emptyFn$1 = () => {
};
var newMeta = (o) => new MetaClass(o);
var setupNames = {};
var emptyObject$7 = Object.freeze({});
var emptyArray$8 = Object.freeze([]);
var Base = class {
  static get isBase() {
    return true;
  }
  get isBase() {
    return true;
  }
  static get declarable() {
    return [
      "declarable",
      "configurable",
      "defaultConfig",
      "properties",
      "prototypeProperties"
    ];
  }
  constructor(...args) {
    const me = this, C = me.constructor;
    if (me.$meta.class !== C) {
      emptyFn$1(C.$meta);
    }
    me.construct(...args);
    me.afterConstruct();
    me.isConstructing = false;
  }
  static new(...configs) {
    configs = configs.filter((c) => c);
    return new this(configs.length > 1 ? this.mergeConfigs(...configs) : configs[0]);
  }
  construct(...args) {
    if (args[0] !== null) {
      this.configure(...args);
    }
    this.afterConfigure();
  }
  static destroy(...args) {
    const shredder = (object) => {
      if (object !== null && object !== void 0 && object.destroy) {
        object.destroy();
      } else if (Array.isArray(object)) {
        object.forEach(shredder);
      }
    };
    shredder(args);
  }
  destroy() {
    const me = this, {
      id
    } = me;
    me.isDestroying = true;
    me.destroy = emptyFn$1;
    me.doDestroy();
    Object.setPrototypeOf(me, null);
    for (const key in me) {
      if (key !== "destroy" && key !== "isDestroying") {
        delete me[key];
      }
    }
    delete me[originalConfigSymbol];
    me.isDestroyed = true;
    me.id = id;
  }
  _thisIsAUsedExpression(getter) {
  }
  static get $$name() {
    return hasOwn$3(this, "$name") && this.$name || hasOwn$3(this, "_$name") && this._$name || this.name;
  }
  get $$name() {
    return this.constructor.$$name;
  }
  startConfigure(config) {
  }
  finishConfigure(config) {
  }
  afterConfigure() {
  }
  afterConstruct() {
  }
  callback(fn, thisObject, args = emptyArray$8) {
    const {
      handler,
      thisObj
    } = this.resolveCallback(fn, thisObject === "this" ? this : thisObject) || emptyObject$7;
    return handler === null || handler === void 0 ? void 0 : handler.apply(thisObj, args);
  }
  resolveProperty(propertyPath) {
    let thisObj = this;
    while (thisObj) {
      if (Objects.hasPath(thisObj, propertyPath)) {
        return Objects.getPath(thisObj, propertyPath);
      }
      thisObj = thisObj.owner;
    }
    return void 0;
  }
  resolveCallback(handler, thisObj = this, enforceCallability = true) {
    var _handler;
    if ((_handler = handler) !== null && _handler !== void 0 && _handler.substring) {
      if (handler.endsWith("?")) {
        enforceCallability = false;
        handler = handler.substring(0, handler.length - 1);
      }
      if (handler.startsWith("up.")) {
        handler = handler.substring(3);
        for (thisObj = this.owner; thisObj && !thisObj[handler]; thisObj = thisObj.owner)
          ;
        if (!thisObj) {
          return;
        }
      } else if (handler.startsWith("this.")) {
        handler = handler.substring(5);
        thisObj = this;
      }
      if (!thisObj || !(thisObj instanceof Object)) {
        return;
      }
      handler = thisObj[handler];
    }
    if (typeof handler === "function") {
      return {
        handler,
        thisObj
      };
    }
    if (enforceCallability) {
      throw new Error(`No method named ${handler} on ${thisObj.$$name || "thisObj object"}`);
    }
  }
  bindCallback(inHandler, inThisObj = this) {
    if (inHandler) {
      const {
        handler,
        thisObj
      } = this.resolveCallback(inHandler, inThisObj);
      if (handler) {
        return handler.bind(thisObj);
      }
    }
  }
  delay(fn, delay, name = fn.name || fn) {
    fn = this.setTimeout ? fn : fn.bind(this);
    const invoker = this.setTimeout ? this : globalThis;
    return invoker[typeof delay === "number" ? "setTimeout" : "requestAnimationFrame"](fn, delay, name);
  }
  doDestroy() {
    const me = this, {
      nullify
    } = me.$meta;
    if (nullify) {
      for (let i = 0; i < nullify.length; ++i) {
        if (me[nullify[i].field] != null) {
          me[nullify[i].name] = null;
        }
      }
    }
  }
  destroyProperties(...properties) {
    const me = this;
    let key, propertyValue;
    for (key of properties) {
      if (key in me && (!me[configuringSymbol] || !me[configuringSymbol][key])) {
        var _propertyValue;
        propertyValue = me[key];
        if ((_propertyValue = propertyValue) !== null && _propertyValue !== void 0 && _propertyValue.destroy) {
          propertyValue.destroy();
        }
        delete me[key];
      }
    }
  }
  configure(config = {}) {
    const me = this, meta = me.$meta, {
      beforeConfigure
    } = config, configs = meta.configs, fullConfig = me.getDefaultConfiguration();
    let cfg, key, value;
    me.initialConfig = config;
    me.isConfiguring = true;
    Object.assign(me, me.getProperties());
    for (key in config) {
      value = config[key];
      cfg = configs[key];
      fullConfig[key] = cfg ? cfg.merge(value, fullConfig[key], null, meta) : value;
    }
    if (beforeConfigure) {
      delete fullConfig.beforeConfigure;
      beforeConfigure(me, fullConfig);
    }
    me.setConfig(me[originalConfigSymbol] = fullConfig, true);
    me.isConfiguring = false;
  }
  getConfig(name) {
    return this[name];
  }
  setConfig(config, isConstructing) {
    const me = this, wasConfiguring = me[configuringSymbol], configDone = wasConfiguring ? me.configDone : me.configDone = {}, configs = me.$meta.configs;
    let cfg, key;
    me[instancePropertiesSymbol] = {};
    me[configuringSymbol] = wasConfiguring ? Object.setPrototypeOf(Object.assign({}, config), wasConfiguring) : config;
    for (key in config) {
      if (config[key] != null || hasOwn$3(config, key)) {
        cfg = configs[key] || Config.get(key);
        cfg.defineInitter(me, config[key]);
        if (!isConstructing) {
          configDone[key] = false;
        }
      } else {
        configDone[key] = true;
      }
    }
    if (isConstructing) {
      me.startConfigure(config);
    }
    for (key in config) {
      var _configs$key;
      if (!configDone[key] && !((_configs$key = configs[key]) !== null && _configs$key !== void 0 && _configs$key.lazy)) {
        me[key] = config[key];
      }
    }
    if (wasConfiguring) {
      me[configuringSymbol] = wasConfiguring;
    } else {
      delete me[configuringSymbol];
    }
    if (isConstructing) {
      me.finishConfigure(config);
    }
    return me;
  }
  hasConfig(name) {
    var _me$lazyConfigsSymbol;
    const me = this, config = me[configuringSymbol];
    return Boolean(me["_" + name] != null || ((_me$lazyConfigsSymbol = me[lazyConfigsSymbol]) === null || _me$lazyConfigsSymbol === void 0 ? void 0 : _me$lazyConfigsSymbol.get(name)) != null || !me.configDone[name] && config && (config[name] != null || hasOwn$3(config, name)));
  }
  peekConfig(name) {
    const me = this, lazyConfig = me[lazyConfigsSymbol], config = me[configuringSymbol];
    if (lazyConfig !== null && lazyConfig !== void 0 && lazyConfig.has(name)) {
      return lazyConfig.get(name);
    }
    if (me.configDone[name]) {
      return me[name];
    }
    if ((config === null || config === void 0 ? void 0 : config[name]) != null || hasOwn$3(config, name)) {
      return config[name];
    }
  }
  triggerConfig(name) {
    const me = this, {
      configDone
    } = me, lazyConfig = me[lazyConfigsSymbol], config = me[configuringSymbol], triggered = lazyConfig !== null && lazyConfig !== void 0 && lazyConfig.has(name) || config && (config[name] != null || hasOwn$3(config, name)) ? !configDone[name] : null;
    if (triggered) {
      me.getConfig(name);
    }
    return triggered;
  }
  triggerConfigs(group) {
    const me = this, configs = me.$meta.configs, lazyConfigs = me[lazyConfigsSymbol], triggered = lazyConfigs ? [...lazyConfigs.keys()].filter((k) => configs[k].lazy === group) : emptyArray$8;
    for (const key of triggered) {
      me.triggerConfig(key);
    }
    return triggered.length ? triggered : null;
  }
  onConfigChange() {
  }
  get config() {
    const result = {}, myConfig = this[originalConfigSymbol];
    for (const key in myConfig) {
      result[key] = myConfig[key];
    }
    return result;
  }
  static processConfigValue(currentValue, options) {
    if (currentValue === globalThis) {
      return globalThis;
    } else if (Array.isArray(currentValue)) {
      return currentValue.map((v) => Base.processConfigValue(v, options));
    } else if (currentValue instanceof Base) {
      if (options.visited.has(currentValue)) {
        return;
      }
      return currentValue.getCurrentConfig(options);
    } else if (currentValue instanceof HTMLElement || currentValue instanceof DocumentFragment) {
      return null;
    } else if (Objects.isObject(currentValue)) {
      const result = {};
      for (const key in currentValue) {
        result[key] = Base.processConfigValue(currentValue[key], options);
      }
      return result;
    }
    return currentValue;
  }
  getConfigValue(name, options) {
    var _me$$meta$configs$nam;
    const me = this, lazyConfigs = me[lazyConfigsSymbol];
    if (!((_me$$meta$configs$nam = me.$meta.configs[name]) !== null && _me$$meta$configs$nam !== void 0 && _me$$meta$configs$nam.lazy)) {
      return Base.processConfigValue(me[name], options);
    }
    if (lazyConfigs !== null && lazyConfigs !== void 0 && lazyConfigs.has(name)) {
      return Base.processConfigValue(lazyConfigs.get(name), options);
    }
  }
  preProcessCurrentConfigs() {
  }
  getCurrentConfig(options = {}) {
    const me = this, configs = options.configs === "all" ? me.config : Objects.clone(me.initialConfig), visited = options.visited || (options.visited = /* @__PURE__ */ new Set()), depth = options.depth || (options.depth = 0), result = {};
    if (visited.has(me)) {
      return void 0;
    }
    visited.add(me);
    this.preProcessCurrentConfigs(configs);
    for (const name in configs) {
      const value = me.getConfigValue(name, _objectSpread2(_objectSpread2({}, options), {}, {
        depth: depth + 1
      }));
      if (value !== void 0) {
        result[name] = value;
      }
    }
    return result;
  }
  getConfigString(options = {}) {
    return StringHelper.toJavaScriptString(this.getCurrentConfig(options));
  }
  getTestCase(options = {}) {
    const Product = this.isGantt ? "Gantt" : this.isSchedulerPro ? "SchedulerPro" : this.isCalendar ? "Calendar" : this.isScheduler ? "Scheduler" : this.isGrid ? "Grid" : this.isTaskBoard ? "TaskBoard" : null;
    if (Product) {
      const product = Product.toLowerCase(), bundlePath = `../../build/${product}.module.js`;
      let preamble, postamble;
      if (options.import === "static") {
        preamble = `import * as module from "${bundlePath}";Object.assign(window, module);`;
        postamble = "";
      } else {
        preamble = `import("${bundlePath}").then(module => { Object.assign(window, module);
`;
        postamble = "});";
      }
      const version = VersionHelper.getVersion(product);
      if (version) {
        preamble += `
console.log('${Product} ${version}');
`;
      }
      return `${preamble}      
const ${product} = new ${Product}(${this.getConfigString(options)});
${postamble}`;
    }
  }
  downloadTestCase(options = {}) {
    options.output = "return";
    const app = this.getTestCase(options);
    BrowserHelper.download(`app.js`, "data:application/javascript;charset=utf-8," + escape(app));
  }
  static initClass() {
    return this.$meta.class;
  }
  static get $meta() {
    const me = this;
    let meta = me[metaSymbol];
    if (!hasOwn$3(me, metaSymbol)) {
      me[metaSymbol] = meta = newMeta();
      meta.class = me;
      me.setupClass(meta);
    }
    return meta;
  }
  static onClassMixedIn() {
  }
  static mergeConfigs(baseConfig, ...configs) {
    const classConfigs = this.$meta.configs, result = Objects.clone(baseConfig) || {};
    let config, i, key, value;
    for (i = 0; i < configs.length; ++i) {
      config = configs[i];
      if (config) {
        for (key in config) {
          value = config[key];
          if (classConfigs[key]) {
            value = classConfigs[key].merge(value, result[key]);
          } else if (result[key] && value) {
            value = Config.merge(value, result[key]);
          }
          result[key] = value;
        }
      }
    }
    return result;
  }
  static mixin(...mixins) {
    let C = this, i;
    for (i = 0; i < mixins.length; ++i) {
      const mixin = mixins[i], tag = mixin[mixinTagSymbol] || (mixin[mixinTagSymbol] = Symbol("mixinTag"));
      if (C[tag]) {
        continue;
      }
      C = mixin(C);
      C[tag] = true;
      if (hasOwn$3(C, "onClassMixedIn")) {
        C.onClassMixedIn();
      }
    }
    return C;
  }
  static setupClass(meta) {
    var _base$nullify;
    const cls = meta.class, base = getPrototypeOf$1(cls).$meta, name = cls.$$name, names = base.names, proto2 = cls.prototype;
    defineProperty$6(proto2, "$meta", {
      value: meta
    });
    Object.assign(meta, {
      super: base,
      config: Object.create(base.config),
      configs: Object.create(base.configs),
      declarables: base.declarables,
      forkConfigs: base.forkConfigs,
      hierarchy: Object.freeze([...base.hierarchy, cls]),
      names: names.includes(name) ? names : Object.freeze([...names, name]),
      properties: base.properties,
      nullify: (_base$nullify = base.nullify) === null || _base$nullify === void 0 ? void 0 : _base$nullify.slice()
    });
    if (names !== meta.names) {
      const isName = `is${name}`, defineIsProperty = (obj) => {
        if (!hasOwn$3(obj, isName)) {
          defineProperty$6(obj, isName, {
            get() {
              if (!hasOwn$3(typeof obj === "object" ? obj.constructor : obj, "$name")) {
                console.warn(`$name static property or getter required for class ${name} to provide class name for minified sources.` + (VersionHelper.isTestEnv ? "" : "\nhttps://bryntum.com/products/grid/docs/api/Core/widget/Widget#property-$name-static"));
              }
              return true;
            }
          });
        }
      };
      defineIsProperty(proto2);
      defineIsProperty(cls);
    }
    for (let decl, setupName, i = 0; i < meta.declarables.length; ++i) {
      decl = meta.declarables[i];
      if (hasOwn$3(cls, decl)) {
        setupName = setupNames[decl] || (setupNames[decl] = `setup${StringHelper.capitalize(decl)}`);
        cls[setupName](cls, meta);
      }
    }
  }
  static setupConfigs(meta, configs, simple) {
    const classConfigValues = meta.config, classConfigs = meta.configs, cls = meta.class, superMeta = meta.super;
    let {
      nullify
    } = meta, cfg, defaultValue2, options, setDefault, value, wasNullify;
    for (const name in configs) {
      value = configs[name];
      if (simple) {
        if (!(cfg = classConfigs[name])) {
          cfg = Config.get(name, defaultConfigOptions);
        } else {
          value = cfg.merge(value, classConfigValues[name], meta, superMeta);
        }
      } else {
        defaultValue2 = options = setDefault = void 0;
        if (value && typeof value === "object" && "$config" in value) {
          options = value.$config;
          if (options && !Objects.isObject(options)) {
            options = Objects.createTruthyKeys(options);
          }
          setDefault = "default" in value;
          defaultValue2 = setDefault ? value.default : defaultValue2;
          value = value.value;
        }
        if (!(cfg = classConfigs[name])) {
          cfg = Config.get(name, options);
          cfg.define(cls.prototype);
          setDefault = !(cfg.field in cls.prototype);
          wasNullify = false;
        } else {
          wasNullify = cfg.nullify;
          if (options) {
            cfg = cfg.extend(options);
          }
          value = cfg.merge(value, classConfigValues[name], meta, superMeta);
        }
        if (setDefault) {
          cfg.setDefault(cls, defaultValue2);
        }
        if (cfg.nullify && !wasNullify) {
          (nullify || (nullify = meta.nullify || (meta.nullify = []))).push(cfg);
        }
      }
      if (value && (Objects.isObject(value) || Array.isArray(value)) && !Object.isFrozen(value)) {
        meta.forkConfigs = true;
      }
      classConfigs[name] = cfg;
      classConfigValues[name] = value;
    }
  }
  static setupConfigurable(cls, meta) {
    cls.setupConfigs(meta, cls.configurable, false);
  }
  static setupDefaultConfig(cls, meta) {
    cls.setupConfigs(meta, cls.defaultConfig, true);
  }
  static setupDeclarable(cls, meta) {
    const declarable = cls.declarable;
    let all = meta.declarables, forked, i;
    for (i = 0; i < declarable.length; ++i) {
      if (!all.includes(declarable[i])) {
        if (!forked) {
          meta.declarables = forked = all = all.slice();
        }
        all.push(declarable[i]);
      }
    }
  }
  static setupProperties(cls, meta) {
    meta.properties = meta.super.properties.slice();
    meta.properties.push(cls);
    Object.freeze(meta.properties);
  }
  static setupPrototypeProperties(cls) {
    Object.assign(cls.prototype, cls.prototypeProperties);
  }
  getDefaultConfiguration() {
    return this.constructor.getDefaultConfiguration();
  }
  static getDefaultConfiguration() {
    const meta = this.$meta, config = meta.forkConfigs ? Base.fork(meta.config) : Object.create(meta.config);
    if (VersionHelper.isTestEnv && BrowserHelper.isBrowserEnv && config.testConfig && globalThis.__applyTestConfigs) {
      for (const o in config.testConfig) {
        config[o] = config.testConfig[o];
      }
    }
    return config;
  }
  static fork(obj) {
    let ret = obj, key, value;
    if (obj && Objects.isObject(obj) && !Object.isFrozen(obj)) {
      ret = Object.create(obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (Objects.isObject(value)) {
            ret[key] = Base.fork(value);
          } else if (Array.isArray(value)) {
            ret[key] = value.slice();
          }
        }
      }
    }
    return ret;
  }
  getProperties() {
    const hierarchy = this.$meta.properties, result = {};
    for (let i = 0; i < hierarchy.length; i++) {
      Object.assign(result, hierarchy[i].properties);
    }
    return result;
  }
  static get superclass() {
    return getPrototypeOf$1(this);
  }
  classHierarchy(topClass) {
    const hierarchy = this.$meta.hierarchy, index = topClass ? hierarchy.indexOf(topClass) : 0;
    return index > 0 ? hierarchy.slice(index) : hierarchy;
  }
  static isOfTypeName(type) {
    return this.$meta.names.includes(type);
  }
  detachListeners(name) {
    var _detachers;
    let detachers = this.$detachers;
    detachers = (_detachers = detachers) === null || _detachers === void 0 ? void 0 : _detachers[name];
    if (detachers) {
      while (detachers.length) {
        detachers.pop()();
      }
    }
  }
  trackDetacher(name, detacher2) {
    const detachers = this.$detachers || (this.$detachers = {}), bucket = detachers[name] || (detachers[name] = []);
    bucket.push(detacher2);
  }
  untrackDetachers(eventer) {
    const detachers = this.$detachers;
    if (detachers) {
      for (const name in detachers) {
        const bucket = detachers[name];
        for (let i = bucket.length; i-- > 0; ) {
          if (bucket[i].eventer === eventer) {
            bucket.splice(i, 1);
          }
        }
      }
    }
  }
};
var proto$1 = Base.prototype;
proto$1.onConfigChange.$nullFn = emptyFn$1.$nullFn = true;
Base[metaSymbol] = proto$1.$meta = newMeta({
  class: Base,
  config: Object.freeze({}),
  configs: /* @__PURE__ */ Object.create(null),
  declarables: Base.declarable,
  forkConfigs: false,
  hierarchy: Object.freeze([Base]),
  names: Object.freeze(["Base"]),
  nullify: null,
  properties: Object.freeze([]),
  super: null
});
Object.assign(proto$1, {
  $detachers: null,
  configObserver: null,
  isConstructing: true,
  isDestroyed: false,
  isDestroying: false
});
Base.emptyFn = emptyFn$1;
VersionHelper.setVersion("core", "5.3.0");
Base._$name = "Base";
var ArrayHelper = class {
  static clean(array) {
    return array.reduce((res, item) => {
      if (item !== null && item !== void 0 && !(Array.isArray(item) && item.length === 0) && item !== "")
        res.push(item);
      return res;
    }, []);
  }
  static from(iterable, filter, map) {
    const array = [];
    if (iterable) {
      for (const it of iterable) {
        if (!filter || filter(it)) {
          array.push(map ? map(it) : it);
        }
      }
    }
    return array;
  }
  static remove(array, ...items2) {
    let index, item, removed = false;
    for (let i = 0; i < items2.length; i++) {
      item = items2[i];
      if ((index = array.indexOf(item)) !== -1) {
        array.splice(index, 1);
        removed = true;
      }
    }
    return removed;
  }
  static findInsertionIndex(item, array, comparatorFn = this.lexicalCompare, index) {
    const len = array.length;
    let beforeCheck, afterCheck;
    if (index < len) {
      beforeCheck = index > 0 ? comparatorFn(array[index - 1], item) : 0;
      afterCheck = index < len - 1 ? comparatorFn(item, array[index]) : 0;
      if (beforeCheck < 1 && afterCheck < 1) {
        return index;
      }
    }
    return this.binarySearch(array, item, comparatorFn);
  }
  static findLast(array, fn, thisObj) {
    for (let {
      length
    } = array, i = length - 1; i >= 0; i--) {
      if (fn.call(thisObj, array[i], i, array)) {
        return array[i];
      }
    }
  }
  static binarySearch(array, item, begin = 0, end = array.length, compareFn = this.lexicalCompare) {
    const length = array.length;
    let middle, comparison;
    if (begin instanceof Function) {
      compareFn = begin;
      begin = 0;
    } else if (end instanceof Function) {
      compareFn = end;
      end = length;
    }
    --end;
    while (begin <= end) {
      middle = begin + end >> 1;
      comparison = compareFn(item, array[middle]);
      if (comparison >= 0) {
        begin = middle + 1;
      } else if (comparison < 0) {
        end = middle - 1;
      }
    }
    return begin;
  }
  magnitudeCompare(lhs, rhs) {
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }
  lexicalCompare(lhs, rhs) {
    lhs = String(lhs);
    rhs = String(rhs);
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }
  static fill(count, itemOrArray = {}, fn = null) {
    const result = [], items2 = Array.isArray(itemOrArray) ? itemOrArray : [itemOrArray];
    for (let i = 0; i < count; i++) {
      for (const item of items2) {
        const processedItem = Object.assign({}, item);
        if (fn) {
          fn(processedItem, i);
        }
        result.push(processedItem);
      }
    }
    return result;
  }
  static populate(count, fn, oneBased = false) {
    const items2 = [];
    for (let i = 0; i < count; i++) {
      items2.push(fn(i + (oneBased ? 1 : 0)));
    }
    return items2;
  }
  static include(array, ...items2) {
    for (const item of items2) {
      if (!array.includes(item)) {
        array.push(item);
      }
    }
  }
  static unique(array) {
    return [...new Set(array)];
  }
  static allowNegative(array) {
    return new Proxy(array, {
      get(target, name, receiver) {
        if (typeof name !== "string") {
          return Reflect.get(target, name, receiver);
        }
        const index = Number(name);
        if (Number.isNaN(index)) {
          return Reflect.get(target, name, receiver);
        }
        return target[index < 0 ? target.length + index : index];
      },
      set(target, name, value, receiver) {
        if (typeof name !== "string") {
          return Reflect.set(target, name, value, receiver);
        }
        const index = Number(name);
        if (Number.isNaN(index)) {
          return Reflect.set(target, name, value, receiver);
        }
        target[index < 0 ? target.length + index : index] = value;
        return true;
      }
    });
  }
  static delta(a, b, useRelativeNaming = false) {
    if (!b) {
      return useRelativeNaming ? {
        toAdd: a,
        toRemove: [],
        toKeep: []
      } : {
        onlyInA: a,
        onlyInB: [],
        inBoth: []
      };
    }
    const onlyInA = [], onlyInB = [], inBoth = /* @__PURE__ */ new Set(), bSet = new Set(b);
    for (let i = 0; i < a.length; i++) {
      const item = a[i];
      if (bSet.has(item)) {
        inBoth.add(item);
      } else {
        onlyInA.push(item);
      }
    }
    for (let i = 0; i < b.length; i++) {
      const item = b[i];
      if (!inBoth.has(item)) {
        onlyInB.push(item);
      }
    }
    if (useRelativeNaming) {
      return {
        toAdd: onlyInA,
        toRemove: onlyInB,
        toKeep: inBoth
      };
    }
    return {
      onlyInA,
      onlyInB,
      inBoth: [...inBoth]
    };
  }
  static asArray(arrayOrObject) {
    if (arrayOrObject == null) {
      return arrayOrObject;
    }
    if (arrayOrObject instanceof Set) {
      return Array.from(arrayOrObject);
    }
    return Array.isArray(arrayOrObject) ? arrayOrObject : [arrayOrObject];
  }
  static identity(x) {
    return x;
  }
  static keyBy(array, keyGetter, valueGetter = ArrayHelper.identity) {
    const getKey = typeof keyGetter === "string" ? (o) => o === null || o === void 0 ? void 0 : o[keyGetter] : keyGetter, getValue = typeof valueGetter === "string" ? (o) => o === null || o === void 0 ? void 0 : o[valueGetter] : valueGetter;
    return array.reduce((dict, next) => {
      dict[getKey(next)] = getValue(next);
      return dict;
    }, {});
  }
};
ArrayHelper._$name = "ArrayHelper";
var commaSepRe = /,\s*/;
var decompiledSym = Symbol("decompiled");
var fnRe1 = /^\s*(async\s+)?([a-z_]\w*)\s*=>([\s\S]+)$/i;
var fnRe2 = /^\s*(async\s*)?\s*\(((?:[a-z_]\w*(?:, [a-z_]\w*)*)?)\)\s+=>([\s\S]+)$/i;
var fnRe3 = /^(\s*async)?(?:\s*function)?(?:\s*([a-z_]\w*))?\s*\(((?:[a-z_]\w*(?:, [a-z_]\w*)*)?)\)([\s\S]+)$/i;
var {
  hasOwnProperty: hasOwnProperty$4
} = Object.prototype;
var FunctionHelper = class {
  static after(object, method, fn, thisObj, options) {
    const named = typeof fn === "string", withReturn = (options === null || options === void 0 ? void 0 : options.return) !== false, hook = (...args) => {
      const origResult = hook.$nextHook.call(object, ...args), hookResult = thisObj !== null && thisObj !== void 0 && thisObj.isDestroyed ? void 0 : withReturn ? named ? thisObj[fn](origResult, ...args) : fn.call(thisObj, origResult, ...args) : named ? thisObj[fn](...args) : fn.call(thisObj, ...args);
      return hookResult === void 0 ? origResult : hookResult;
    };
    return FunctionHelper.hookMethod(object, method, hook);
  }
  static before(object, method, fn, thisObj) {
    const named = typeof fn === "string", hook = (...args) => {
      const ret = thisObj !== null && thisObj !== void 0 && thisObj.isDestroyed ? 0 : named ? thisObj[fn](...args) : fn.call(thisObj, ...args);
      return ret === false ? ret : hook.$nextHook.call(object, ...args);
    };
    return FunctionHelper.hookMethod(object, method, hook);
  }
  static curry(func) {
    return function curried(...args) {
      if (args.length >= func.length) {
        return func.apply(this, args);
      } else {
        return function(...args2) {
          return curried.apply(this, args.concat(args2));
        };
      }
    };
  }
  static bindAll(obj) {
    for (const key in obj) {
      if (typeof obj[key] === "function") {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
  static createInterceptor(original, interceptor, thisObj) {
    return function(...args) {
      const theThis = thisObj || this;
      if (interceptor.call(theThis, ...args) !== false) {
        return original.call(theThis, ...args);
      }
      return false;
    };
  }
  static createSequence(original, sequence, thisObj) {
    return (...args) => {
      const origResult = original.call(thisObj, ...args), sequenceResult = sequence.call(thisObj, ...args);
      return sequenceResult === void 0 ? origResult : sequenceResult;
    };
  }
  static createThrottled(fn, buffer, thisObj, extraArgs, alt2) {
    let lastCallTime = -Number.MAX_VALUE, callArgs, timerId;
    const invoke = () => {
      timerId = 0;
      lastCallTime = performance.now();
      callArgs.push.apply(callArgs, extraArgs);
      fn.apply(thisObj, callArgs);
    }, result = function(...args) {
      const elapsed = performance.now() - lastCallTime;
      callArgs = args;
      if (elapsed >= buffer) {
        clearTimeout(timerId);
        invoke();
      } else {
        if (!timerId) {
          timerId = setTimeout(invoke, buffer - elapsed);
        }
        if (alt2) {
          callArgs.push.apply(callArgs, extraArgs);
          alt2.apply(thisObj, callArgs);
        }
      }
    };
    result.cancel = () => clearTimeout(timerId);
    return result;
  }
  static createBuffered(fn, buffer, thisObj, args) {
    let callArgs, timerId;
    const invoke = () => {
      timerId = 0;
      result.isPending = false;
      callArgs.push.apply(callArgs, args);
      fn.apply(thisObj, callArgs);
    }, result = function(...args2) {
      callArgs = args2;
      if (timerId) {
        clearTimeout(timerId);
      }
      result.isPending = true;
      timerId = setTimeout(invoke, buffer);
    };
    result.cancel = () => {
      result.isPending = false;
      clearTimeout(timerId);
    };
    return result;
  }
  static decompile(fn) {
    if (!(decompiledSym in fn)) {
      var _body, _body2;
      const code = fn.toString();
      let m = fnRe1.exec(code), args, body, name, decompiled, t;
      if (m) {
        args = [m[2]];
        body = m[3];
      } else if (m = fnRe2.exec(code)) {
        t = m[2].trim();
        args = t ? t.split(commaSepRe) : [];
        body = m[3];
      } else if (m = fnRe3.exec(code)) {
        name = m[2];
        t = m[3].trim();
        args = t ? t.split(commaSepRe) : [];
        body = m[4];
      }
      body = (_body = body) === null || _body === void 0 ? void 0 : _body.trim();
      fn[decompiledSym] = decompiled = m && {
        args,
        async: Boolean(m[1]),
        body: (_body2 = body) !== null && _body2 !== void 0 && _body2.startsWith("{") ? body.substring(1, body.length - 1).trim() : body
      };
      if (name) {
        decompiled.name = name;
      }
    }
    return fn[decompiledSym];
  }
  static hookMethod(object, method, hook) {
    hook.$nextHook = object[method];
    object[method] = hook;
    return () => {
      if (hasOwnProperty$4.call(object, method)) {
        let f = object[method], next;
        if (f === hook) {
          var _Object$getPrototypeO;
          if (((_Object$getPrototypeO = Object.getPrototypeOf(object)) === null || _Object$getPrototypeO === void 0 ? void 0 : _Object$getPrototypeO[method]) === hook.$nextHook) {
            delete object[method];
          } else {
            object[method] = hook.$nextHook;
          }
        } else {
          for (; next = (_f = f) === null || _f === void 0 ? void 0 : _f.$nextHook; f = next) {
            var _f;
            if (next === hook) {
              f.$nextHook = hook.$nextHook;
              break;
            }
          }
        }
      }
    };
  }
  static noThrow(object, method, handler) {
    const fn = object[method];
    object[method] = (...args) => {
      try {
        return fn.apply(object, args);
      } catch (e) {
        return handler === null || handler === void 0 ? void 0 : handler(e);
      }
    };
  }
  static returnTrue() {
    return true;
  }
  static animate(duration, fn, thisObj, easing = "linear") {
    let cancel = false;
    const result = new Promise((resolve) => {
      const start = performance.now(), iterate = () => {
        const progress = Math.min((performance.now() - start) / duration, 1), delayable = thisObj && thisObj.setTimeout ? thisObj : globalThis;
        if (!cancel) {
          if (fn.call(thisObj, this.easingFunctions[easing](progress)) === false) {
            resolve();
          }
        }
        if (cancel || progress === 1) {
          delayable.requestAnimationFrame(() => resolve());
        } else {
          delayable.requestAnimationFrame(iterate);
        }
      };
      iterate();
    });
    result.cancel = () => {
      cancel = true;
      return false;
    };
    return result;
  }
};
var half = 0.5;
var e1 = 1.70158;
var e2 = 7.5625;
var e3 = 1.525;
var e4 = 2 / 2.75;
var e5 = 2.25 / 2.75;
var e6 = 1 / 2.75;
var e7 = 1.5 / 2.75;
var e8 = 2.5 / 2.75;
var e9 = 2.625 / 2.75;
var e10 = 0.75;
var e11 = 0.9375;
var e12 = 0.984375;
var s1 = 1.70158;
var s2 = 1.70158;
FunctionHelper.easingFunctions = {
  linear: (t) => t,
  easeInQuad: (t) => Math.pow(t, 2),
  easeOutQuad: (t) => -(Math.pow(t - 1, 2) - 1),
  easeInOutQuad: (t) => (t /= half) < 1 ? half * Math.pow(t, 2) : -half * ((t -= 2) * t - 2),
  easeInCubic: (t) => Math.pow(t, 3),
  easeOutCubic: (t) => Math.pow(t - 1, 3) + 1,
  easeInOutCubic: (t) => (t /= half) < 1 ? half * Math.pow(t, 3) : half * (Math.pow(t - 2, 3) + 2),
  easeInQuart: (t) => Math.pow(t, 4),
  easeOutQuart: (t) => -(Math.pow(t - 1, 4) - 1),
  easeInOutQuart: (t) => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeInQuint: (t) => Math.pow(t, 5),
  easeOutQuint: (t) => Math.pow(t - 1, 5) + 1,
  easeInOutQuint: (t) => (t /= half) < 1 ? half * Math.pow(t, 5) : half * (Math.pow(t - 2, 5) + 2),
  easeInSine: (t) => -Math.cos(t * (Math.PI / 2)) + 1,
  easeOutSine: (t) => Math.sin(t * (Math.PI / 2)),
  easeInOutSine: (t) => -half * (Math.cos(Math.PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => t === 0 ? 0 : t === 1 ? 1 : (t /= half) < 1 ? half * Math.pow(2, 10 * (t - 1)) : half * (-Math.pow(2, -10 * --t) + 2),
  easeInCirc: (t) => -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => (t /= half) < 1 ? -half * (Math.sqrt(1 - t * t) - 1) : half * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeOutBounce: (t) => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  easeInBack: (t) => t * t * ((e1 + 1) * t - e1),
  easeOutBack: (t) => (t = t - 1) * t * ((e1 + 1) * t + e1) + 1,
  easeInOutBack: (t) => {
    let v1 = s1;
    return (t /= half) < 1 ? half * (t * t * (((v1 *= e3) + 1) * t - v1)) : half * ((t -= 2) * t * (((v1 *= e3) + 1) * t + v1) + 2);
  },
  elastic: (t) => -1 * Math.pow(4, -8 * t) * Math.sin((t * 6 - 1) * (2 * Math.PI) / 2) + 1,
  swingFromTo: (t) => {
    let v2 = s2;
    return (t /= half) < 1 ? half * (t * t * (((v2 *= e3) + 1) * t - v2)) : half * ((t -= 2) * t * (((v2 *= e3) + 1) * t + v2) + 2);
  },
  swingFrom: (t) => t * t * ((e1 + 1) * t - e1),
  swingTo: (t) => (t -= 1) * t * ((e1 + 1) * t + e1) + 1,
  bounce: (t) => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  bouncePast: (t) => t < e6 ? e2 * t * t : t < e4 ? 2 - (e2 * (t -= e7) * t + e10) : t < e8 ? 2 - (e2 * (t -= e5) * t + e11) : 2 - (e2 * (t -= e9) * t + e12),
  easeFromTo: (t) => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeFrom: (t) => Math.pow(t, 4),
  easeTo: (t) => Math.pow(t, 0.25)
};
FunctionHelper._$name = "FunctionHelper";
var {
  isArray: isArray$1
} = Array;
var {
  hasOwnProperty: hasOwnProperty$3
} = Object.prototype;
var specialProperties = {
  thisObj: 1,
  detachable: 1,
  once: 1,
  detacher: 1,
  prio: 1,
  args: 1,
  expires: 1,
  buffer: 1,
  throttle: 1,
  name: 1,
  $internal: 1
};
var priorityComparator = (a, b) => b.prio - a.prio;
var Events = (Target) => class Events2 extends (Target || Base) {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "eventsSuspended", null);
  }
  static get $name() {
    return "Events";
  }
  static get declarable() {
    return [
      "deprecatedEvents"
    ];
  }
  static setupDeprecatedEvents(cls, meta) {
    const all = meta.getInherited("deprecatedEvents"), add = cls.deprecatedEvents;
    for (const eventName in add) {
      all[eventName.toLowerCase()] = all[eventName] = add[eventName];
    }
  }
  static get configurable() {
    return {
      listeners: {
        value: null,
        $config: {
          merge(newValue, currentValue) {
            if (newValue !== null) {
              if (!newValue) {
                return currentValue;
              }
              if (currentValue) {
                newValue = newValue ? [newValue] : [];
                newValue.push[isArray$1(currentValue) ? "apply" : "call"](newValue, currentValue);
              }
            }
            return newValue;
          }
        }
      },
      internalListeners: null,
      bubbleEvents: null
    };
  }
  destroy() {
    this.trigger("beforeDestroy");
    super.destroy();
  }
  construct(config, ...args) {
    var _config;
    if (this.configuredListeners = (_config = config) === null || _config === void 0 ? void 0 : _config.listeners) {
      config = Objects.assign({}, config);
      delete config.listeners;
    }
    super.construct(config, ...args);
    this.processConfiguredListeners();
  }
  processConfiguredListeners() {
    if (this.configuredListeners) {
      const me = this, {
        isConfiguring
      } = me;
      me.isConfiguring = false;
      me.listeners = me.configuredListeners;
      me.configuredListeners = null;
      me.isConfiguring = isConfiguring;
    }
  }
  doDestroy() {
    this.trigger("destroy");
    this.removeAllListeners(false);
    super.doDestroy();
  }
  static setupClass(meta) {
    super.setupClass(meta);
    Events2.prototype.onListen.$nullFn = true;
    Events2.prototype.onUnlisten.$nullFn = true;
  }
  addListener(config, thisObj, oldThisObj) {
    if (isArray$1(config)) {
      for (let i = 0, {
        length
      } = config; i < length; i++) {
        this.addListener(config[i], thisObj);
      }
      return;
    }
    const me = this, deprecatedEvents = me.$meta.getInherited("deprecatedEvents");
    if (typeof config === "string") {
      return me.addListener({
        [config]: thisObj,
        detachable: thisObj.detachable !== false,
        thisObj: oldThisObj
      });
    } else {
      thisObj = config.thisObj = config.thisObj !== void 0 ? config.thisObj : thisObj;
      for (const key in config) {
        if (!specialProperties[key] && config[key] != null) {
          const eventName = key.toLowerCase(), deprecatedEvent = deprecatedEvents === null || deprecatedEvents === void 0 ? void 0 : deprecatedEvents[eventName], events = me.eventListeners || (me.eventListeners = {}), listenerSpec = config[key], expires = listenerSpec.expires || config.expires, listener = {
            fn: typeof listenerSpec === "object" ? listenerSpec.fn : listenerSpec,
            thisObj: listenerSpec.thisObj !== void 0 ? listenerSpec.thisObj : thisObj,
            args: listenerSpec.args || config.args,
            prio: listenerSpec.prio !== void 0 ? listenerSpec.prio : config.prio !== void 0 ? config.prio : 0,
            once: listenerSpec.once !== void 0 ? listenerSpec.once : config.once !== void 0 ? config.once : false,
            buffer: listenerSpec.buffer || config.buffer,
            throttle: listenerSpec.throttle || config.throttle,
            $internal: config.$internal,
            catchAll: key === "catchAll"
          };
          if (deprecatedEvent) {
            const {
              product,
              invalidAsOfVersion,
              message
            } = deprecatedEvent;
            VersionHelper.deprecate(product, invalidAsOfVersion, message);
          }
          if (expires) {
            const {
              alt: alt2
            } = expires, delay = alt2 ? expires.delay : expires, name2 = config.name || key, fn = () => {
              me.un(eventName, listener);
              if (alt2 && !listener.called) {
                me.callback(alt2, thisObj);
              }
            };
            if (me.isDelayable) {
              me.setTimeout({
                fn,
                name: name2,
                cancelOutstanding: true,
                delay
              });
            } else {
              globalThis.setTimeout(fn, delay);
            }
          }
          let listeners = events[eventName] || (events[eventName] = []);
          if (listeners.$firing) {
            events[eventName] = listeners = listeners.slice();
          }
          listeners.splice(ArrayHelper.findInsertionIndex(listener, listeners, priorityComparator, listeners.length), 0, listener);
          if (!me.onListen.$nullFn && listeners.length < 2) {
            me.onListen(eventName);
          }
        }
      }
      if (config.relayAll) {
        me.relayAll(config.relayAll);
      }
      if (thisObj && thisObj !== me) {
        me.attachAutoDetacher(config, thisObj);
      }
      const detachable = config.detachable !== false, name = config.name, destroy = config.expires || detachable || name ? () => {
        if (!me.isDestroyed) {
          me.removeListener(config, thisObj);
        }
      } : null;
      if (destroy) {
        var _thisObj;
        destroy.eventer = me;
        destroy.listenerName = name;
        if (name && (_thisObj = thisObj) !== null && _thisObj !== void 0 && _thisObj.trackDetacher) {
          thisObj.trackDetacher(name, destroy);
        }
        if (config.expires) {
          me.delay(destroy, isNaN(config.expires) ? config.expires.delay : config.expires, name);
        }
        if (detachable) {
          return destroy;
        }
      }
    }
  }
  on(config, thisObj, oldThisObj) {
    return this.addListener(config, thisObj, oldThisObj);
  }
  ion(config) {
    config.$internal = true;
    return this.on(config);
  }
  un(...args) {
    this.removeListener(...args);
  }
  updateInternalListeners(internalListeners, oldInternalListeners) {
    oldInternalListeners === null || oldInternalListeners === void 0 ? void 0 : oldInternalListeners.detach();
    if (internalListeners) {
      internalListeners.detach = this.ion(internalListeners);
    }
  }
  get listeners() {
    return this.eventListeners;
  }
  changeListeners(listeners) {
    if (this.isConfiguring) {
      this.getConfig("internalListeners");
      if (listeners) {
        this.on(listeners, this);
      }
    } else {
      if (Array.isArray(listeners)) {
        for (let i = 0, l = listeners[0], {
          length
        } = listeners; i < length; l = listeners[++i]) {
          if (!("thisObj" in l)) {
            listeners[i] = Objects.assign({
              thisObj: this
            }, l);
          }
        }
      } else if (listeners && !("thisObj" in listeners)) {
        listeners = Objects.assign({
          thisObj: this
        }, listeners);
      }
      return listeners;
    }
  }
  updateListeners(listeners, oldListeners) {
    oldListeners && this.un(oldListeners);
    listeners && this.on(listeners);
  }
  removeListener(config, thisObj = config.thisObj, oldThisObj) {
    const me = this;
    if (typeof config === "string") {
      return me.removeListener({
        [config]: thisObj
      }, oldThisObj);
    }
    Object.entries(config).forEach(([eventName, listenerToRemove]) => {
      if (!specialProperties[eventName] && listenerToRemove != null) {
        eventName = eventName.toLowerCase();
        const eventListeners = me.eventListeners, index = me.findListener(eventName, listenerToRemove, thisObj);
        if (index >= 0) {
          let listeners = eventListeners[eventName];
          if (listeners.length > 1) {
            if (listeners.$firing) {
              eventListeners[eventName] = listeners = listeners.slice();
            }
            listeners.splice(index, 1);
          } else {
            delete eventListeners[eventName];
            if (!me.onUnlisten.$nullFn) {
              me.onUnlisten(eventName);
            }
          }
        }
      }
    });
    if (config.thisObj && !config.thisObj.isDestroyed) {
      me.detachAutoDetacher(config);
    }
  }
  findListener(eventName, listenerToFind, defaultThisObj) {
    var _this$eventListeners;
    const eventListeners = (_this$eventListeners = this.eventListeners) === null || _this$eventListeners === void 0 ? void 0 : _this$eventListeners[eventName], fn = listenerToFind.fn || listenerToFind, thisObj = listenerToFind.thisObj || defaultThisObj;
    if (eventListeners) {
      for (let listenerEntry, i = 0, {
        length
      } = eventListeners; i < length; i++) {
        listenerEntry = eventListeners[i];
        if (listenerEntry.fn === fn && listenerEntry.thisObj === thisObj) {
          return i;
        }
      }
    }
    return -1;
  }
  hasListener(eventName) {
    var _this$eventListeners2;
    return Boolean((_this$eventListeners2 = this.eventListeners) === null || _this$eventListeners2 === void 0 ? void 0 : _this$eventListeners2[eventName === null || eventName === void 0 ? void 0 : eventName.toLowerCase()]);
  }
  relayAll(through, prefix, transformCase = true) {
    if (!this.relayAllTargets) {
      this.relayAllTargets = [];
    }
    const relayAllTargets = this.relayAllTargets;
    through.on({
      beforeDestroy: ({
        source
      }) => {
        if (source === through) {
          const configs = relayAllTargets.filter((r) => r.through === through);
          configs.forEach((config) => ArrayHelper.remove(relayAllTargets, config));
        }
      }
    });
    relayAllTargets.push({
      through,
      prefix,
      transformCase
    });
  }
  removeAllListeners(preserveInternal = true) {
    const listeners = this.eventListeners;
    let i, thisObj;
    for (const event in listeners) {
      const bucket = listeners[event];
      for (i = bucket.length; i-- > 0; ) {
        const cfg = bucket[i];
        if (!cfg.$internal || !preserveInternal) {
          var _thisObj2, _thisObj2$untrackDeta, _thisObj3;
          this.removeListener(event, cfg);
          thisObj = cfg.thisObj;
          (_thisObj2 = thisObj) === null || _thisObj2 === void 0 ? void 0 : (_thisObj2$untrackDeta = (_thisObj3 = _thisObj2).untrackDetachers) === null || _thisObj2$untrackDeta === void 0 ? void 0 : _thisObj2$untrackDeta.call(_thisObj3, this);
        }
      }
    }
  }
  relayEvents(source, eventNames, prefix = "") {
    const listenerConfig = {
      detachable: true,
      thisObj: this
    };
    eventNames.forEach((eventName) => {
      listenerConfig[eventName] = (event, ...params) => {
        return this.trigger(prefix + eventName, event, ...params);
      };
    });
    return source.on(listenerConfig);
  }
  onListen() {
  }
  onUnlisten() {
  }
  destructorInterceptor() {
    const {
      autoDetachers,
      target,
      oldDestructor
    } = this;
    for (let i = 0; i < autoDetachers.length; i++) {
      const {
        dispatcher,
        config
      } = autoDetachers[i];
      if (!dispatcher.isDestroyed) {
        dispatcher.removeListener(config, target);
      }
    }
    oldDestructor.call(target);
  }
  attachAutoDetacher(config, thisObj) {
    const target = config.thisObj || thisObj, destructorName = "doDestroy" in target ? "doDestroy" : "destroy";
    if (destructorName in target) {
      let {
        $autoDetachers
      } = target;
      if (!$autoDetachers) {
        target.$autoDetachers = $autoDetachers = [];
      }
      if (!target.$oldDestructor) {
        target.$oldDestructor = target[destructorName];
        target[destructorName] = this.destructorInterceptor.bind({
          autoDetachers: $autoDetachers,
          oldDestructor: target.$oldDestructor,
          target
        });
      }
      $autoDetachers.push({
        config,
        dispatcher: this
      });
    } else {
      target[destructorName] = () => {
        this.removeListener(config);
      };
    }
  }
  detachAutoDetacher(config) {
    const target = config.thisObj;
    if (target.$oldDestructor && !target.isDestroying) {
      ArrayHelper.remove(target.$autoDetachers, target.$autoDetachers.find((detacher2) => detacher2.config === config && detacher2.dispatcher === this));
      if (!target.$autoDetachers.length) {
        target["doDestroy" in target ? "doDestroy" : "destroy"] = target.$oldDestructor;
        target.$oldDestructor = null;
      }
    }
  }
  await(eventName, options = {
    checkLog: true,
    resetLog: true,
    args: null
  }) {
    const me = this;
    if (options === false) {
      options = {
        checkLog: false
      };
    }
    const {
      args
    } = options;
    return new Promise((resolve) => {
      var _me$_triggered;
      if (options.checkLog && (_me$_triggered = me._triggered) !== null && _me$_triggered !== void 0 && _me$_triggered[eventName]) {
        resolve();
        if (options.resetLog) {
          me.clearLog(eventName);
        }
      }
      if (args) {
        const detacher2 = me.on({
          [eventName]: (...params) => {
            const argsOk = Object.keys(args).every((key) => {
              return key in params[0] && params[0][key] === args[key];
            });
            if (argsOk) {
              resolve(...params);
              if (options.resetLog) {
                me.clearLog(eventName);
              }
              detacher2();
            }
          },
          prio: -1e4
        });
      } else {
        me.on({
          [eventName]: (...params) => {
            resolve(...params);
            if (options.resetLog) {
              me.clearLog(eventName);
            }
          },
          prio: -1e4,
          once: true
        });
      }
    });
  }
  clearLog(eventName) {
    if (this._triggered) {
      if (eventName) {
        delete this._triggered[eventName];
      } else {
        this._triggered = {};
      }
    }
  }
  trigger(eventName, param) {
    var _me$eventListeners, _me$eventListeners2, _me$bubbleEvents, _handlerPromises, _handlerPromises2;
    const me = this, name = eventName.toLowerCase(), {
      eventsSuspended,
      relayAllTargets,
      callOnFunctions
    } = me;
    let listeners = (_me$eventListeners = me.eventListeners) === null || _me$eventListeners === void 0 ? void 0 : _me$eventListeners[name], handlerPromises;
    if (!me._triggered) {
      me._triggered = {};
    }
    me._triggered[eventName] = true;
    if (eventsSuspended) {
      if (eventsSuspended.shouldQueue) {
        eventsSuspended.queue.push(arguments);
      }
      return true;
    }
    if ((_me$eventListeners2 = me.eventListeners) !== null && _me$eventListeners2 !== void 0 && _me$eventListeners2.catchall) {
      (listeners = listeners ? listeners.slice() : []).push(...me.eventListeners.catchall);
      listeners.sort(priorityComparator);
    }
    if (!listeners && !relayAllTargets && !callOnFunctions) {
      return true;
    }
    if (param) {
      if (!("source" in param)) {
        if (Object.isExtensible(param)) {
          param.source = me;
        } else {
          param = Object.setPrototypeOf({
            source: me
          }, param);
        }
      }
    } else {
      param = {
        source: me
      };
    }
    if (param.type !== name) {
      if (param.constructor !== Object) {
        Reflect.defineProperty(param, "type", {
          get: () => name
        });
      } else {
        param.type = name;
      }
    }
    if (!("bubbles" in param) && (_me$bubbleEvents = me.bubbleEvents) !== null && _me$bubbleEvents !== void 0 && _me$bubbleEvents[eventName]) {
      param.bubbles = me.bubbleEvents[eventName];
    }
    if (callOnFunctions) {
      const fnName = "on" + StringHelper.capitalize(eventName);
      if (fnName in me) {
        var _me$pluginFunctionCha;
        const result = me[fnName] ? me.callback(me[fnName], me, [param]) : true;
        let inhibit;
        if (Objects.isPromise(result)) {
          (handlerPromises || (handlerPromises = [])).push(result);
        } else {
          inhibit = result === false || inhibit;
        }
        if (!me.isDestroyed && hasOwnProperty$3.call(me, fnName) && !((_me$pluginFunctionCha = me.pluginFunctionChain) !== null && _me$pluginFunctionCha !== void 0 && _me$pluginFunctionCha[fnName])) {
          const myProto = Object.getPrototypeOf(me);
          if (fnName in myProto) {
            const result2 = myProto[fnName].call(me, param);
            if (Objects.isPromise(result2)) {
              (handlerPromises || (handlerPromises = [])).push(result2);
            } else {
              inhibit = result2 === false || inhibit;
            }
            if (me.isDestroyed) {
              return;
            }
          }
        }
        if (inhibit) {
          return false;
        }
      }
    }
    let ret;
    if (listeners) {
      let i = 0, internalAbort = false;
      listeners.$firing = true;
      for (i; i < listeners.length && !me.isDestroyed && !internalAbort; i++) {
        const listener = listeners[i];
        if (ret === false && !listener.$internal) {
          continue;
        }
        let handler, thisObj = listener.thisObj;
        if (!thisObj || !thisObj.isDestroyed) {
          listener.called = true;
          if (listener.once) {
            me.removeListener(name, listener);
          }
          if (typeof listener.fn === "string") {
            if (thisObj) {
              handler = thisObj[listener.fn];
            }
            if (!handler) {
              const result2 = me.resolveCallback(listener.fn);
              handler = result2.handler;
              thisObj = result2.thisObj;
            }
          } else {
            handler = listener.fn;
          }
          if (listener.buffer) {
            if (!listener.bufferFn) {
              const buffer = Number(listener.buffer);
              if (typeof buffer !== "number" || isNaN(buffer)) {
                throw new Error(`Incorrect type for buffer, got "${buffer}" (expected a Number)`);
              }
              listener.bufferFn = FunctionHelper.createBuffered(handler, buffer, thisObj, listener.args);
            }
            handler = listener.bufferFn;
          }
          if (listener.throttle) {
            const throttle = Number(listener.throttle);
            if (typeof throttle !== "number" || isNaN(throttle)) {
              throw new Error(`Incorrect type for throttle, got "${throttle}" (expected a Number)`);
            }
            if (!listener.throttledFn) {
              listener.throttledFn = FunctionHelper.createThrottled(handler, throttle, thisObj, listener.args);
            }
            handler = listener.throttledFn;
          }
          const result = handler.call(thisObj || me, ...listener.args || [], param);
          if (ret !== false) {
            ret = result;
          }
          if (listener.$internal && result === false) {
            internalAbort = true;
          }
          if (Objects.isPromise(result)) {
            result.$internal = listener.$internal;
            (handlerPromises || (handlerPromises = [])).push(result);
          }
        }
      }
      listeners.$firing = false;
      if (internalAbort) {
        return false;
      }
    }
    relayAllTargets === null || relayAllTargets === void 0 ? void 0 : relayAllTargets.forEach((config) => {
      let name2 = eventName;
      if (config.transformCase) {
        name2 = StringHelper.capitalize(name2);
      }
      if (config.prefix) {
        name2 = config.prefix + name2;
      }
      if (config.through.trigger(name2, param) === false) {
        return false;
      }
    });
    if (param.bubbles && me.owner && !me.owner.isDestroyed) {
      return me.owner.trigger(eventName, param);
    }
    handlerPromises = (_handlerPromises = handlerPromises) === null || _handlerPromises === void 0 ? void 0 : _handlerPromises.filter((p) => ret !== false || p.$internal);
    if ((_handlerPromises2 = handlerPromises) !== null && _handlerPromises2 !== void 0 && _handlerPromises2.length) {
      return new Promise((resolve) => {
        Promise.all(handlerPromises).then((promiseResults) => {
          const finalResult = !promiseResults.some((result) => result === false);
          resolve(finalResult);
        });
      });
    }
    return ret !== false;
  }
  suspendEvents(queue = false) {
    const eventsSuspended = this.eventsSuspended || (this.eventsSuspended = {
      shouldQueue: queue,
      queue: [],
      count: 0
    });
    eventsSuspended.count++;
  }
  resumeEvents() {
    const suspended = this.eventsSuspended;
    if (suspended) {
      if (--suspended.count === 0) {
        this.eventsSuspended = null;
        if (suspended.shouldQueue) {
          for (const queued of suspended.queue) {
            this.trigger(...queued);
          }
        }
      }
    }
    return !Boolean(this.eventsSuspended);
  }
};
var AsyncHelper = class {
  static animationFrame() {
    return new Promise((resolve) => {
      requestAnimationFrame(resolve);
    });
  }
  static sleep(millis) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, millis);
    });
  }
  static yield() {
    return Promise.resolve();
  }
};
AsyncHelper._$name = "AsyncHelper";
var paramValueRegExp = /^(\w+)=(.*)$/;
var parseParams = function(paramString) {
  const result = {}, params = paramString.split("&");
  for (const nameValuePair of params) {
    const [match, name, value] = paramValueRegExp.exec(nameValuePair), decodedName = decodeURIComponent(name), decodedValue = decodeURIComponent(value);
    if (match) {
      let paramValue = result[decodedName];
      if (paramValue) {
        if (!Array.isArray(paramValue)) {
          paramValue = result[decodedName] = [paramValue];
        }
        paramValue.push(decodedValue);
      } else {
        result[decodedName] = decodedValue;
      }
    }
  }
  return result;
};
var AjaxHelper = class {
  static get(url, options) {
    return this.fetch(url, options);
  }
  static post(url, payload, options = {}) {
    if (!(payload instanceof FormData) && !(typeof payload === "string")) {
      payload = JSON.stringify(payload);
      options.headers = options.headers || {};
      options.headers["Content-Type"] = options.headers["Content-Type"] || "application/json";
    }
    return this.fetch(url, Object.assign({
      method: "POST",
      body: payload
    }, options));
  }
  static fetch(url, options) {
    let controller;
    options = Objects.merge({}, AjaxHelper.DEFAULT_FETCH_OPTIONS, options);
    if (typeof AbortController !== "undefined") {
      controller = options.abortController = new AbortController();
      options.signal = controller.signal;
    }
    if (!("credentials" in options)) {
      options.credentials = "include";
    }
    if (options.queryParams) {
      const params = Object.entries(options.queryParams);
      if (params.length) {
        let paramsAdded = false;
        if (options.headers && options.addQueryParamsToBody === true) {
          const contentType = new Headers(options.headers).get("Content-Type");
          let bodyClass;
          switch (contentType) {
            case "application/x-www-form-urlencoded":
              bodyClass = URLSearchParams;
              break;
            case "multipart/form-data":
              bodyClass = FormData;
              break;
          }
          if (bodyClass) {
            const body = options.body || (options.body = new bodyClass());
            if (body instanceof bodyClass) {
              params.forEach(([key, value]) => body.set(key, value));
              paramsAdded = true;
            }
          }
        }
        if (!paramsAdded) {
          url += (url.includes("?") ? "&" : "?") + params.map(([param, value]) => `${param}=${encodeURIComponent(value)}`).join("&");
        }
      }
    }
    const promise = new Promise((resolve, reject) => {
      fetch(url, options).then((response) => {
        if (options.parseJson) {
          response.json().then((json) => {
            response.parsedJson = json;
            resolve(response);
          }).catch((error) => {
            response.parsedJson = null;
            response.error = error;
            reject(response);
          });
        } else {
          resolve(response);
        }
      }).catch((error) => {
        error.stack = promise.stack;
        reject(error);
      });
    });
    promise.stack = new Error().stack;
    promise.abort = function() {
      var _controller;
      (_controller = controller) === null || _controller === void 0 ? void 0 : _controller.abort();
    };
    return promise;
  }
  static mockUrl(url, response) {
    const me = this;
    (me.mockAjaxMap || (me.mockAjaxMap = {}))[url] = response;
    if (!AjaxHelper.originalFetch) {
      AjaxHelper.originalFetch = AjaxHelper.fetch;
      AjaxHelper.fetch = me.mockAjaxFetch.bind(me);
    }
  }
  static async mockAjaxFetch(url, options) {
    const urlAndParams = url.split("?");
    let result = this.mockAjaxMap[urlAndParams[0]], parsedJson = null;
    if (result) {
      if (typeof result === "function") {
        result = await result(urlAndParams[0], urlAndParams[1] && parseParams(urlAndParams[1]), options);
      }
      try {
        parsedJson = options.parseJson && JSON.parse(result.responseText);
      } catch (error) {
        parsedJson = null;
        result.error = error;
      }
      result = Object.assign({
        status: 200,
        ok: true,
        headers: new Headers(),
        statusText: "OK",
        url,
        parsedJson,
        text: () => new Promise((resolve) => {
          resolve(result.responseText);
        }),
        json: () => new Promise((resolve) => {
          resolve(parsedJson);
        })
      }, result);
      return new Promise(function(resolve, reject) {
        if (result.synchronous) {
          resolve(result);
        } else {
          setTimeout(function() {
            resolve(result);
          }, "delay" in result ? result.delay : 100);
        }
      });
    } else {
      return AjaxHelper.originalFetch(url, options);
    }
  }
};
_defineProperty(AjaxHelper, "DEFAULT_FETCH_OPTIONS", {});
AjaxHelper._$name = "AjaxHelper";
var LocaleHelper = class {
  static mergeLocales(...locales) {
    const result = {};
    locales.forEach((locale2) => {
      Object.keys(locale2).forEach((key) => {
        if (typeof locale2[key] === "object") {
          result[key] = _objectSpread2(_objectSpread2({}, result[key]), locale2[key]);
        } else {
          result[key] = locale2[key];
        }
      });
    });
    return result;
  }
  static trimLocale(locale2, toTrim) {
    const remove = (key, subKey) => {
      if (locale2[key]) {
        if (subKey) {
          if (locale2[key][subKey]) {
            delete locale2[key][subKey];
          }
        } else {
          delete locale2[key];
        }
      }
    };
    Object.keys(toTrim).forEach((key) => {
      if (Object.keys(toTrim[key]).length > 0) {
        Object.keys(toTrim[key]).forEach((subKey) => remove(key, subKey));
      } else {
        remove(key);
      }
    });
  }
  static normalizeLocale(nameOrConfig, config) {
    if (!nameOrConfig) {
      throw new Error(`"nameOrConfig" parameter can not be empty`);
    }
    if (typeof nameOrConfig === "string") {
      if (!config) {
        throw new Error(`"config" parameter can not be empty`);
      }
      if (config.locale) {
        config.name = nameOrConfig || config.name;
      } else {
        config.localeName = nameOrConfig;
      }
    } else {
      config = nameOrConfig;
    }
    let locale2 = {};
    if (config.name || config.locale) {
      locale2 = Object.assign({
        localeName: config.name
      }, config.locale);
      config.desc && (locale2.localeDesc = config.desc);
      config.code && (locale2.localeCode = config.code);
      config.path && (locale2.localePath = config.path);
    } else {
      if (!config.localeName) {
        throw new Error(`"config" parameter doesn't have "localeName" property`);
      }
      locale2 = Object.assign({}, config);
    }
    for (const key of ["name", "desc", "code", "path"]) {
      if (locale2[key]) {
        delete locale2[key];
      }
    }
    if (!locale2.localeName) {
      throw new Error(`Locale name can not be empty`);
    }
    return locale2;
  }
  static get locales() {
    return globalThis.bryntum.locales || {};
  }
  static set locales(locales) {
    globalThis.bryntum.locales = locales;
  }
  static get localeName() {
    return globalThis.bryntum.locale || "En";
  }
  static set localeName(localeName) {
    globalThis.bryntum.locale = localeName || LocaleHelper.localeName;
  }
  static get locale() {
    return LocaleHelper.localeName && this.locales[LocaleHelper.localeName] || this.locales.En || Object.values(this.locales)[0] || {
      localeName: "",
      localeDesc: "",
      localeCoode: ""
    };
  }
  static publishLocale(nameOrConfig, config) {
    const {
      locales
    } = globalThis.bryntum, locale2 = LocaleHelper.normalizeLocale(nameOrConfig, config), {
      localeName
    } = locale2;
    if (!locales[localeName] || config === true) {
      locales[localeName] = locale2;
    } else {
      locales[localeName] = this.mergeLocales(locales[localeName] || {}, locale2 || {});
    }
    return locales[localeName];
  }
};
_defineProperty(LocaleHelper, "skipLocaleIntegrityCheck", false);
globalThis.bryntum = globalThis.bryntum || {};
globalThis.bryntum.locales = globalThis.bryntum.locales || {};
LocaleHelper._$name = "LocaleHelper";
var LocaleManager = class extends Events(Base) {
  static get defaultConfig() {
    return {
      throwOnMissingLocale: VersionHelper.isTestEnv
    };
  }
  construct(...args) {
    const me = this;
    super.construct(...args);
    if (BrowserHelper.isBrowserEnv) {
      var _me$locale;
      const scriptTag = document.querySelector("script[data-default-locale]");
      if (scriptTag) {
        me.applyLocale(scriptTag.dataset.defaultLocale);
      } else if ((_me$locale = me.locale) !== null && _me$locale !== void 0 && _me$locale.localeName) {
        me.applyLocale(me.locale.localeName);
      }
    }
  }
  get locales() {
    return LocaleHelper.locales;
  }
  set locales(locales) {
    LocaleHelper.locales = locales;
  }
  set locale(nameOrConfig) {
    this.applyLocale(nameOrConfig);
  }
  get locale() {
    return LocaleHelper.locale;
  }
  registerLocale(nameOrConfig, config) {
    VersionHelper.deprecate("Core", "6.0.0", "LocaleManager.registerLocale deprecated, use LocaleHelper.publishLocale instead");
    LocaleHelper.publishLocale(nameOrConfig, config);
  }
  extendLocale(name, config) {
    VersionHelper.deprecate("Core", "6.0.0", "LocaleManager.extendLocale deprecated, use LocaleManager.applyLocale instead");
    const locale2 = LocaleHelper.publishLocale(name, config);
    return this.applyLocale(locale2, true);
  }
  applyLocale(nameOrConfig, config, ignoreError = false) {
    const me = this;
    let localeConfig;
    if (typeof nameOrConfig === "string") {
      if (typeof config !== "object") {
        localeConfig = me.locales[nameOrConfig];
        if (!localeConfig) {
          if (ignoreError) {
            return true;
          }
          throw new Error(`Locale "${nameOrConfig}" is not published. Publish with LocaleHelper.publishLocale() before applying.`);
        }
      } else {
        localeConfig = LocaleHelper.publishLocale(nameOrConfig, config);
      }
    } else {
      localeConfig = LocaleHelper.publishLocale(nameOrConfig);
    }
    if (me.locale.localeName && me.locale.localeName === localeConfig.localeName && config !== true) {
      return me.locale;
    }
    LocaleHelper.localeName = localeConfig.localeName;
    const triggerLocaleEvent = () => {
      me.trigger("locale", localeConfig);
    };
    if (localeConfig.localePath) {
      return new Promise((resolve, reject) => {
        me.loadLocale(localeConfig.localePath).then((response) => {
          response.text().then((text) => {
            const parseLocale = new Function(text);
            parseLocale();
            if (BrowserHelper.isBrowserEnv) {
              localeConfig = me.locales[localeConfig.localeName];
              if (localeConfig) {
                delete localeConfig.localePath;
              }
            }
            triggerLocaleEvent();
            resolve(localeConfig);
          });
        }).catch((response) => reject(response));
      });
    }
    triggerLocaleEvent();
    return localeConfig;
  }
  loadLocale(path) {
    return AjaxHelper.get(path);
  }
  set throwOnMissingLocale(value) {
    this._throwOnMissingLocale = value;
  }
  get throwOnMissingLocale() {
    return this._throwOnMissingLocale;
  }
};
var LocaleManagerSingleton = new LocaleManager();
var ObjectProto = Object.getPrototypeOf(Object);
var localeRe = /L{.*?}/g;
var capturelocaleRe = /L{(.*?)}/g;
var classMatchRe = /((.*?)\.)?(.+)/g;
var escape$1 = (txt) => txt.replace(/{(\d+)}/gm, "[[$1]]");
var unescape = (txt) => txt.replace(/\[\[(\d+)]]/gm, "{$1}");
var emptyObject$6 = Object.freeze(/* @__PURE__ */ Object.create(null));
var Localizable = (Target) => class Localizable2 extends (Target || Base) {
  static get $name() {
    return "Localizable";
  }
  static get configurable() {
    return {
      localeClass: null,
      localizable: null,
      localizableProperties: {
        value: [],
        $config: {
          merge: "distinct"
        }
      }
    };
  }
  static clsName(cls) {
    var _cls$prototype, _cls$prototype2;
    return typeof cls === "string" ? cls : cls === ObjectProto ? "Object" : cls.$$name || cls.name || ((_cls$prototype = cls.prototype) === null || _cls$prototype === void 0 ? void 0 : _cls$prototype.$$name) || ((_cls$prototype2 = cls.prototype) === null || _cls$prototype2 === void 0 ? void 0 : _cls$prototype2.name);
  }
  static parseLocaleString(text) {
    var _text;
    const matches = [];
    let m;
    if ((_text = text) !== null && _text !== void 0 && _text.includes("L{")) {
      text = escape$1(text);
      capturelocaleRe.lastIndex = 0;
      while ((m = capturelocaleRe.exec(text)) != null) {
        classMatchRe.lastIndex = 0;
        const classMatch = classMatchRe.exec(m[1]);
        matches.push({
          match: unescape(m[0]),
          localeKey: unescape(classMatch[3]),
          localeClass: classMatch[2]
        });
      }
    }
    return matches.length > 0 ? matches : [{
      match: text,
      localeKey: text,
      localeClass: void 0
    }];
  }
  construct(config = {}, ...args) {
    super.construct(config, ...args);
    LocaleManagerSingleton.ion({
      locale: "updateLocalization",
      thisObj: this
    });
    this.updateLocalization();
  }
  get localeClass() {
    return this._localeClass || null;
  }
  localizeProperty(property) {
    var _me$$meta$configs$pro, _me$fieldMap, _me$fieldMap$property;
    const me = this, currentValue = Objects.getPath(me, property), localeKey = ((_me$$meta$configs$pro = me.$meta.configs[property]) === null || _me$$meta$configs$pro === void 0 ? void 0 : _me$$meta$configs$pro.localeKey) || ((_me$fieldMap = me.fieldMap) === null || _me$fieldMap === void 0 ? void 0 : (_me$fieldMap$property = _me$fieldMap[property]) === null || _me$fieldMap$property === void 0 ? void 0 : _me$fieldMap$property.defaultValue);
    let localizedValue;
    if (localeKey) {
      localizedValue = Localizable2.localize(localeKey, me, me.localeClass || me);
      if (localizedValue && !(property in (me.initialConfig || emptyObject$6))) {
        Objects.setPath(me.isColumn ? me.data : me, property, localizedValue);
      }
    } else if (typeof currentValue === "string") {
      me.originalLocales = me.originalLocales || {};
      localizedValue = Objects.getPath(me.originalLocales, property);
      if (localizedValue === void 0) {
        Objects.setPath(me.originalLocales, property, currentValue);
        localizedValue = currentValue;
      }
      if (localizedValue) {
        Objects.setPath(me, property, localizedValue = me.optionalL(localizedValue, me));
      }
    }
    return localizedValue || currentValue;
  }
  updateLocalization() {
    if (this.localizable !== false) {
      var _this$localizableProp, _this$trigger;
      (_this$localizableProp = this.localizableProperties) === null || _this$localizableProp === void 0 ? void 0 : _this$localizableProp.forEach(this.localizeProperty, this);
      (_this$trigger = this.trigger) === null || _this$trigger === void 0 ? void 0 : _this$trigger.call(this, "localized");
    }
  }
  static getTranslation(text, templateData, localeCls) {
    const locale2 = LocaleManagerSingleton.locale;
    let result = null, clsName, cls;
    if (locale2) {
      for (const {
        match,
        localeKey,
        localeClass
      } of this.parseLocaleString(text)) {
        const translate = (clsName2) => {
          var _locale$clsName;
          const translation = (_locale$clsName = locale2[clsName2]) === null || _locale$clsName === void 0 ? void 0 : _locale$clsName[localeKey];
          if (translation) {
            if (typeof translation === "function") {
              result = templateData != null ? translation(templateData) : translation;
            } else if (typeof translation === "object" || text === match) {
              result = translation;
            } else {
              result = (result || text).replace(match, translation);
            }
            if (typeof translation === "string" && translation.includes("L{")) {
              result = this.getTranslation(translation, templateData, localeCls);
            }
          }
          return translation;
        };
        let success2 = false;
        for (cls = localeCls; cls && (clsName = Localizable2.clsName(cls)); cls = Object.getPrototypeOf(cls)) {
          if (success2 = translate(clsName)) {
            break;
          } else if (typeof cls === "string") {
            break;
          }
        }
        if (!success2 && localeClass) {
          translate(localeClass);
        }
      }
    }
    return result;
  }
  static localize(text, templateData = void 0, ...localeClasses) {
    var _localeClasses;
    if (((_localeClasses = localeClasses) === null || _localeClasses === void 0 ? void 0 : _localeClasses.length) === 0) {
      localeClasses = [this];
    }
    let translation = null;
    localeClasses.some((cls) => {
      translation = Localizable2.getTranslation(text, templateData, cls);
      return translation != null;
    });
    return translation;
  }
  static L(text, templateData = void 0, ...localeClasses) {
    var _localeClasses2;
    if (((_localeClasses2 = localeClasses) === null || _localeClasses2 === void 0 ? void 0 : _localeClasses2.length) === 0) {
      localeClasses = [this];
    }
    const translation = this.localize(text, templateData, ...localeClasses);
    if (translation == null && LocaleManagerSingleton.throwOnMissingLocale && text.includes("L{")) {
      throw new Error(`Localization is not found for '${text}' in '${localeClasses.map((cls) => Localizable2.clsName(cls)).join(", ")}'. ${LocaleManagerSingleton.locale.localeName ? `Locale : ${LocaleManagerSingleton.locale.localeName}` : ""}`);
    }
    return translation !== null && translation !== void 0 ? translation : text;
  }
  L(text, templateData) {
    const {
      localeClass,
      constructor
    } = this;
    if (localeClass && Localizable2.clsName(localeClass) !== Localizable2.clsName(constructor)) {
      return Localizable2.L(text, templateData, localeClass, constructor);
    } else {
      return Localizable2.L(text, templateData, constructor);
    }
  }
  static optionalL(text, templateData = void 0, ...localeClasses) {
    var _localeClasses3;
    const shouldThrow = LocaleManagerSingleton.throwOnMissingLocale;
    LocaleManagerSingleton.throwOnMissingLocale = shouldThrow && localeRe.test(text);
    if (((_localeClasses3 = localeClasses) === null || _localeClasses3 === void 0 ? void 0 : _localeClasses3.length) === 0) {
      localeClasses = [this];
    }
    const result = Localizable2.L(text, templateData, ...localeClasses);
    LocaleManagerSingleton.throwOnMissingLocale = shouldThrow;
    return result;
  }
  optionalL(text, templateData = this, preventThrow = false) {
    const shouldThrow = LocaleManagerSingleton.throwOnMissingLocale;
    LocaleManagerSingleton.throwOnMissingLocale = shouldThrow && localeRe.test(text) && !preventThrow;
    const result = this.L(text, templateData);
    LocaleManagerSingleton.throwOnMissingLocale = shouldThrow;
    return result;
  }
  get localeManager() {
    return LocaleManagerSingleton;
  }
  get localeHelper() {
    return LocaleHelper;
  }
};
var locale$2 = {
  localeName: "En",
  localeDesc: "English (US)",
  localeCode: "en-US",
  Object: {
    Yes: "Yes",
    No: "No",
    Cancel: "Cancel",
    Ok: "OK",
    Week: "Week"
  },
  Combo: {
    noResults: "No results",
    recordNotCommitted: "Record could not be added",
    addNewValue: (value) => `Add ${value}`
  },
  FilePicker: {
    file: "File"
  },
  Field: {
    badInput: "Invalid field value",
    patternMismatch: "Value should match a specific pattern",
    rangeOverflow: (value) => `Value must be less than or equal to ${value.max}`,
    rangeUnderflow: (value) => `Value must be greater than or equal to ${value.min}`,
    stepMismatch: "Value should fit the step",
    tooLong: "Value should be shorter",
    tooShort: "Value should be longer",
    typeMismatch: "Value is required to be in a special format",
    valueMissing: "This field is required",
    invalidValue: "Invalid field value",
    minimumValueViolation: "Minimum value violation",
    maximumValueViolation: "Maximum value violation",
    fieldRequired: "This field is required",
    validateFilter: "Value must be selected from the list"
  },
  DateField: {
    invalidDate: "Invalid date input"
  },
  DatePicker: {
    gotoPrevYear: "Go to previous year",
    gotoPrevMonth: "Go to previous month",
    gotoNextMonth: "Go to next month",
    gotoNextYear: "Go to next year"
  },
  NumberFormat: {
    locale: "en-US",
    currency: "USD"
  },
  DurationField: {
    invalidUnit: "Invalid unit"
  },
  TimeField: {
    invalidTime: "Invalid time input"
  },
  TimePicker: {
    hour: "Hour",
    minute: "Minute",
    second: "Second"
  },
  List: {
    loading: "Loading..."
  },
  GridBase: {
    loadMask: "Loading...",
    syncMask: "Saving changes, please wait..."
  },
  PagingToolbar: {
    firstPage: "Go to first page",
    prevPage: "Go to previous page",
    page: "Page",
    nextPage: "Go to next page",
    lastPage: "Go to last page",
    reload: "Reload current page",
    noRecords: "No records to display",
    pageCountTemplate: (data) => `of ${data.lastPage}`,
    summaryTemplate: (data) => `Displaying records ${data.start} - ${data.end} of ${data.allCount}`
  },
  PanelCollapser: {
    Collapse: "Collapse",
    Expand: "Expand"
  },
  Popup: {
    close: "Close"
  },
  UndoRedo: {
    Undo: "Undo",
    Redo: "Redo",
    UndoLastAction: "Undo last action",
    RedoLastAction: "Redo last undone action",
    NoActions: "No items in the undo queue"
  },
  FieldFilterPicker: {
    equals: "equals",
    doesNotEqual: "does not equal",
    isEmpty: "is empty",
    isNotEmpty: "is not empty",
    contains: "contains",
    doesNotContain: "does not contain",
    startsWith: "starts with",
    endsWith: "ends with",
    isOneOf: "is one of",
    isNotOneOf: "is not one of",
    isGreaterThan: "is greater than",
    isLessThan: "is less than",
    isGreaterThanOrEqualTo: "is greater than or equal to",
    isLessThanOrEqualTo: "is less than or equal to",
    isBetween: "is between",
    isNotBetween: "is not between",
    isBefore: "is before",
    isAfter: "is after",
    isToday: "is today",
    isTomorrow: "is tomorrow",
    isYesterday: "is yesterday",
    isThisWeek: "is this week",
    isNextWeek: "is next week",
    isLastWeek: "is last week",
    isThisMonth: "is this month",
    isNextMonth: "is next month",
    isLastMonth: "is last month",
    isThisYear: "is this year",
    isNextYear: "is next year",
    isLastYear: "is last year",
    isYearToDate: "is year to date",
    isTrue: "is true",
    isFalse: "is false",
    selectAProperty: "Select a property",
    selectAnOperator: "Select an operator",
    caseSensitive: "Case-sensitive",
    and: "and",
    dateFormat: "D/M/YY",
    selectOneOrMoreValues: "Select one or more values",
    enterAValue: "Enter a value",
    enterANumber: "Enter a number",
    selectADate: "Select a date"
  },
  FieldFilterPickerGroup: {
    addFilter: "Add filter"
  },
  DateHelper: {
    locale: "en-US",
    weekStartDay: 0,
    nonWorkingDays: {
      0: true,
      6: true
    },
    weekends: {
      0: true,
      6: true
    },
    unitNames: [{
      single: "millisecond",
      plural: "ms",
      abbrev: "ms"
    }, {
      single: "second",
      plural: "seconds",
      abbrev: "s"
    }, {
      single: "minute",
      plural: "minutes",
      abbrev: "min"
    }, {
      single: "hour",
      plural: "hours",
      abbrev: "h"
    }, {
      single: "day",
      plural: "days",
      abbrev: "d"
    }, {
      single: "week",
      plural: "weeks",
      abbrev: "w"
    }, {
      single: "month",
      plural: "months",
      abbrev: "mon"
    }, {
      single: "quarter",
      plural: "quarters",
      abbrev: "q"
    }, {
      single: "year",
      plural: "years",
      abbrev: "yr"
    }, {
      single: "decade",
      plural: "decades",
      abbrev: "dec"
    }],
    unitAbbreviations: [["mil"], ["s", "sec"], ["m", "min"], ["h", "hr"], ["d"], ["w", "wk"], ["mo", "mon", "mnt"], ["q", "quar", "qrt"], ["y", "yr"], ["dec"]],
    parsers: {
      L: "MM/DD/YYYY",
      LT: "HH:mm A",
      LTS: "HH:mm:ss A"
    },
    ordinalSuffix: (number) => {
      const hasSpecialCase = ["11", "12", "13"].find((n) => number.endsWith(n));
      let suffix = "th";
      if (!hasSpecialCase) {
        const lastDigit = number[number.length - 1];
        suffix = {
          1: "st",
          2: "nd",
          3: "rd"
        }[lastDigit] || "th";
      }
      return number + suffix;
    }
  }
};
LocaleHelper.publishLocale(locale$2);
var {
  toString: toString$1
} = Object.prototype;
var DATE_TYPE = toString$1.call(new Date());
var tempDate = new Date();
var MS_PER_HOUR = 1e3 * 60 * 60;
var defaultValue = (value, defValue) => isNaN(value) || value == null ? defValue : value;
var rangeFormatPartRe = /([ES]){([^}]+)}/g;
var enOrdinalSuffix = (number) => {
  const hasSpecialCase = ["11", "12", "13"].find((n) => number.endsWith(n));
  let suffix = "th";
  if (!hasSpecialCase) {
    const lastDigit = number[number.length - 1];
    suffix = {
      1: "st",
      2: "nd",
      3: "rd"
    }[lastDigit] || "th";
  }
  return number + suffix;
};
var useIntlFormat = (name, options, date) => {
  const formatter = intlFormatterCache[name] || (intlFormatterCache[name] = new Intl.DateTimeFormat(locale$1, options));
  return formatter.format(date);
};
var formatTime = (name, options, date, isShort = false) => {
  let strTime = useIntlFormat(name, options, date);
  if (/am|pm/i.test(strTime)) {
    strTime = strTime.replace(/^0/, "");
    if (isShort) {
      strTime = strTime.replace(/:00/, "");
    }
  }
  return strTime;
};
var getDayDiff = (end, start) => Math.floor((end.getTime() - start.getTime() - (end.getTimezoneOffset() - start.getTimezoneOffset()) * validConversions.minute.millisecond) / validConversions.day.millisecond) + 1;
var normalizeDay = (day2) => day2 >= 0 ? day2 : day2 + 7;
var msRegExp = /([^\w])(S+)/gm;
var msReplacer = (match, g1, g2) => g1 + "SSS";
var locale$1 = "en-US";
var ordinalSuffix = enOrdinalSuffix;
var formatCache = {};
var formatRedirects = {};
var intlFormatterCache = {};
var parserCache = {};
var redirectFormat = (format) => {
  const intlConfig = intlFormatConfigs[format];
  if (!intlConfig) {
    throw new Error("Only international formats should be used here");
  }
  if (formatRedirects[format] !== void 0) {
    return formatRedirects[format];
  }
  const intl = new Intl.DateTimeFormat(locale$1, intlConfig), fmt = intl.formatToParts(new Date(2001, 1, 2, 3, 4, 5, 6)).map((part) => {
    const type = part.type, intlCfg = intlConfig[type];
    if (type === "literal") {
      return part.value.replace(/,/g, "");
    } else if (type === "day") {
      return intlCfg === "numeric" ? "D" : "DD";
    } else if (type === "month") {
      return intlCfg === "short" ? "MMM" : intlCfg === "long" ? "MMMM" : intlCfg === "numeric" ? "M" : "MM";
    } else if (type === "year") {
      return intlCfg === "numeric" ? "YYYY" : "YY";
    }
  }).join("");
  return formatRedirects[format] = fmt;
};
var DEFAULT_YEAR = 2020;
var DEFAULT_MONTH = 0;
var DEFAULT_DAY = 1;
var intlFormatConfigs = {
  l: {
    year: "numeric",
    month: "numeric",
    day: "numeric"
  },
  ll: {
    year: "numeric",
    month: "short",
    day: "numeric"
  }
};
var formats = {
  M: (date) => date.getMonth() + 1,
  Mo: (date) => ordinalSuffix(formats.M(date).toString()),
  MM: (date) => (date.getMonth() + 1).toString().padStart(2, "0"),
  MMM: (date) => useIntlFormat("MMM", {
    month: "short"
  }, date),
  MMMM: (date) => useIntlFormat("MMMM", {
    month: "long"
  }, date),
  Q: (date) => Math.ceil((date.getMonth() + 1) / 3),
  Qo: (date) => ordinalSuffix(formats.Q(date).toString()),
  D: (date) => date.getDate(),
  Do: (date) => ordinalSuffix(formats.D(date).toString()),
  DD: (date) => date.getDate().toString().padStart(2, "0"),
  DDD: (date) => Math.ceil((new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0) - new Date(date.getFullYear(), 0, 0, 12, 0, 0)) / validConversions.day.millisecond),
  DDDo: (date) => ordinalSuffix(formats.DDD(date).toString()),
  DDDD: (date) => formats.DDD(date).toString().padStart(3, "0"),
  d: (date) => date.getDay(),
  do: (date) => ordinalSuffix(date.getDay().toString()),
  d1: (date) => useIntlFormat("d1", {
    weekday: "narrow"
  }, date).substr(0, 1),
  dd: (date) => formats.ddd(date).substring(0, 2),
  ddd: (date) => useIntlFormat("ddd", {
    weekday: "short"
  }, date),
  dddd: (date) => useIntlFormat("dddd", {
    weekday: "long"
  }, date),
  u: (date) => {
    const formatter = intlFormatterCache.u || (intlFormatterCache.u = new Intl.DateTimeFormat("en-GB", {
      timeZone: "UTC",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    })), parts = formatter.formatToParts(date);
    return `${parts[4].value}${parts[2].value}${parts[0].value}Z`;
  },
  uu: (date) => {
    const formatter = intlFormatterCache.uu || (intlFormatterCache.uu = new Intl.DateTimeFormat("en-GB", {
      timeZone: "UTC",
      hour12: false,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    })), parts = formatter.formatToParts(date);
    return `${parts[4].value}${parts[2].value}${parts[0].value}T${parts[6].value}${parts[8].value}${parts[10].value}Z`;
  },
  e: (date) => date.getDay(),
  E: (date) => date.getDay() + 1,
  W: (date) => DateHelper.getWeekNumber(date)[1],
  Wo: (date) => ordinalSuffix(formats.W(date).toString()),
  WW: (date) => formats.W(date).toString().padStart(2, "0"),
  Wp: (date) => `${DateHelper.localize("L{Week}")} ${formats.W(date)}`,
  WWp: (date) => `${DateHelper.localize("L{Week}")} ${formats.WW(date)}`,
  Wp0: (date) => `${DateHelper.localize("L{Week}")[0]}${formats.W(date)}`,
  WWp0: (date) => `${DateHelper.localize("L{Week}")[0]}${formats.WW(date)}`,
  Y: (date) => date.getFullYear(),
  YY: (date) => date.getFullYear() % 100,
  YYYY: (date) => date.getFullYear(),
  A: (date) => date.getHours() < 12 ? "AM" : "PM",
  a: (date) => date.getHours() < 12 ? "am" : "pm",
  H: (date) => date.getHours(),
  HH: (date) => date.getHours().toString().padStart(2, "0"),
  h: (date) => date.getHours() % 12 || 12,
  hh: (date) => formats.h(date).toString().padStart(2, "0"),
  k: (date) => date.getHours() || 24,
  kk: (date) => formats.k(date).toString().padStart(2, "0"),
  K: (date) => formatTime("K", {
    hour: "numeric"
  }, date),
  KK: (date) => formatTime("KK", {
    hour: "2-digit"
  }, date),
  m: (date) => date.getMinutes(),
  mm: (date) => formats.m(date).toString().padStart(2, "0"),
  s: (date) => date.getSeconds(),
  ss: (date) => formats.s(date).toString().padStart(2, "0"),
  S: (date) => Math.floor(date.getMilliseconds() / 100).toString(),
  SS: (date) => Math.floor(date.getMilliseconds() / 10).toString().padStart(2, "0"),
  SSS: (date) => date.getMilliseconds().toString().padStart(3, "0"),
  z: (date) => useIntlFormat("z", {
    timeZoneName: "short"
  }, date),
  zz: (date) => useIntlFormat("zz", {
    timeZoneName: "long"
  }, date),
  Z: (date) => DH$1.getGMTOffset(date),
  LT: (date) => formatTime("LT", {
    hour: "2-digit",
    minute: "2-digit"
  }, date),
  LST: (date) => formatTime("LST", {
    hour: "numeric",
    minute: "2-digit"
  }, date, true),
  LTS: (date) => formatTime("LTS", {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit"
  }, date),
  L: (date) => useIntlFormat("L", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit"
  }, date),
  l: (date) => useIntlFormat("l", intlFormatConfigs.l, date),
  LL: (date) => useIntlFormat("LL", {
    year: "numeric",
    month: "long",
    day: "numeric"
  }, date),
  ll: (date) => useIntlFormat("ll", intlFormatConfigs.ll, date),
  LLL: (date) => useIntlFormat("LLL", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit"
  }, date),
  lll: (date) => useIntlFormat("lll", {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit"
  }, date),
  LLLL: (date) => useIntlFormat("LLLL", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    weekday: "long"
  }, date),
  llll: (date) => useIntlFormat("llll", {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    weekday: "short"
  }, date)
};
var formatKeys = Object.keys(formats).sort((a, b) => b.length - a.length);
var formatRegexp = `^(?:${formatKeys.join("|")})`;
var emptyFn = () => ({});
var isNumber = (str) => numberRegex.test(str);
var parseMilliseconds = (str) => isNumber(str) && {
  milliseconds: parseInt(str.padEnd(3, "0").substring(0, 3))
};
var parsers = {
  YYYY: (str) => {
    const year = parseInt(str);
    return {
      year: year >= 1e3 && year <= 9999 ? year : NaN
    };
  },
  Y: (str) => ({
    year: parseInt(str)
  }),
  YY: (str) => {
    const year = parseInt(str);
    return {
      year: year + (year > 1968 ? 1900 : 2e3)
    };
  },
  M: (str) => ({
    month: parseInt(str) - 1
  }),
  MM: (str) => ({
    month: parseInt(str) - 1
  }),
  Mo: (str) => ({
    month: parseInt(str) - 1
  }),
  MMM: (str) => {
    const month2 = (str || "").toLowerCase();
    for (const [name, entry] of Object.entries(DateHelper._monthShortNamesIndex)) {
      if (month2.startsWith(name)) {
        return {
          month: entry.value
        };
      }
    }
  },
  MMMM: emptyFn,
  DD: (str) => ({
    date: parseInt(str)
  }),
  D: (str) => ({
    date: parseInt(str)
  }),
  Do: (str) => ({
    date: parseInt(str)
  }),
  DDD: emptyFn,
  DDDo: emptyFn,
  DDDD: emptyFn,
  d: emptyFn,
  do: emptyFn,
  d1: emptyFn,
  dd: emptyFn,
  ddd: emptyFn,
  dddd: emptyFn,
  Q: emptyFn,
  Qo: emptyFn,
  W: emptyFn,
  Wo: emptyFn,
  WW: emptyFn,
  e: emptyFn,
  E: emptyFn,
  HH: (str) => ({
    hours: parseInt(str)
  }),
  hh: (str) => ({
    hours: parseInt(str)
  }),
  mm: (str) => ({
    minutes: parseInt(str)
  }),
  H: (str) => ({
    hours: parseInt(str)
  }),
  m: (str) => ({
    minutes: parseInt(str)
  }),
  ss: (str) => ({
    seconds: parseInt(str)
  }),
  s: (str) => ({
    seconds: parseInt(str)
  }),
  S: parseMilliseconds,
  SS: parseMilliseconds,
  SSS: parseMilliseconds,
  A: (str) => ({
    amPm: str.toLowerCase()
  }),
  a: (str) => ({
    amPm: str.toLowerCase()
  }),
  L: "MM/DD/YYYY",
  LT: "HH:mm A",
  LTS: "HH:mm:ss A",
  l: {
    type: "dynamic",
    parser: () => redirectFormat("l")
  },
  ll: {
    type: "dynamic",
    parser: () => redirectFormat("ll")
  },
  Z: (str) => {
    if (!str || !timeZoneRegEx.test(str) && str !== "Z") {
      return null;
    }
    let timeZone = 0;
    if (str !== "Z") {
      const matches = timeZoneRegEx.exec(str);
      if (matches) {
        const sign = matches[1] === "+" ? 1 : -1, hours = parseInt(matches[2]) || 0, minutes = parseInt(matches[3]) || 0;
        timeZone = sign * (hours * 60 + minutes);
      } else {
        timeZone = -1 * new Date().getTimezoneOffset();
      }
    }
    return {
      timeZone
    };
  }
};
var parserKeys = Object.keys(parsers).sort((a, b) => b.length - a.length);
var parserRegexp = new RegExp(`(${parserKeys.join("|")})`);
var localeStrRegExp = new RegExp("^(LL|LLL|lll|LLLL|llll)$");
var validConversions = {
  decade: {
    decade: 1,
    year: 10,
    quarter: 40,
    month: 120,
    week: 520,
    day: 3652,
    hour: 24 * 3652,
    minute: 1440 * 3652,
    second: 86400 * 3652,
    millisecond: 864e5 * 3652
  },
  year: {
    decade: 0.1,
    year: 1,
    quarter: 4,
    month: 12,
    week: 52,
    day: 365,
    hour: 24 * 365,
    minute: 1440 * 365,
    second: 86400 * 365,
    millisecond: 864e5 * 365
  },
  quarter: {
    decade: 1 / 40,
    year: 1 / 4,
    quarter: 1,
    month: 3,
    week: 4,
    day: 91,
    hour: 24 * 91,
    minute: 1440 * 91,
    second: 86400 * 91,
    millisecond: 864e5 * 91
  },
  month: {
    decade: 1 / 120,
    year: 1 / 12,
    quarter: 1 / 3,
    month: 1,
    week: 4,
    day: -30,
    hour: -24 * 30,
    minute: -1440 * 30,
    second: -86400 * 30,
    millisecond: -864e5 * 30
  },
  week: {
    decade: -1 / 520,
    year: -1 / 52,
    quarter: -1 / 13,
    month: -1 / 4,
    day: 7,
    hour: 168,
    minute: 10080,
    second: 604800,
    millisecond: 6048e5
  },
  day: {
    decade: -1 / 3652,
    year: -1 / 365,
    quarter: -1 / 91,
    month: -1 / 30,
    week: 1 / 7,
    hour: 24,
    minute: 1440,
    second: 86400,
    millisecond: 864e5
  },
  hour: {
    decade: -1 / (3652 * 24),
    year: -1 / (365 * 24),
    quarter: -1 / (91 * 24),
    month: -1 / (30 * 24),
    week: 1 / 168,
    day: 1 / 24,
    minute: 60,
    second: 3600,
    millisecond: 36e5
  },
  minute: {
    decade: -1 / (3652 * 1440),
    year: -1 / (365 * 1440),
    quarter: -1 / (91 * 1440),
    month: -1 / (30 * 1440),
    week: 1 / 10080,
    day: 1 / 1440,
    hour: 1 / 60,
    second: 60,
    millisecond: 6e4
  },
  second: {
    decade: -1 / (3652 * 86400),
    year: -1 / (365 * 86400),
    quarter: -1 / (91 * 86400),
    month: -1 / (30 * 86400),
    week: 1 / 604800,
    day: 1 / 86400,
    hour: 1 / 3600,
    minute: 1 / 60,
    millisecond: 1e3
  },
  millisecond: {
    decade: -1 / (3652 * 864e5),
    year: -1 / (365 * 864e5),
    quarter: -1 / (91 * 864e5),
    month: -1 / (30 * 864e5),
    week: 1 / 6048e5,
    day: 1 / 864e5,
    hour: 1 / 36e5,
    minute: 1 / 6e4,
    second: 1 / 1e3
  }
};
var normalizedUnits = {
  ms: "millisecond",
  milliseconds: "millisecond",
  s: "second",
  seconds: "second",
  m: "minute",
  mi: "minute",
  min: "minute",
  minutes: "minute",
  h: "hour",
  hours: "hour",
  d: "day",
  days: "day",
  w: "week",
  weeks: "week",
  M: "month",
  mo: "month",
  mon: "month",
  months: "month",
  q: "quarter",
  quarters: "quarter",
  y: "year",
  years: "year",
  dec: "decade",
  decades: "decade"
};
var withDecimalsDurationRegex = /^\s*([-+]?\d+(?:[.,]\d*)?|[-+]?(?:[.,]\d+))\s*([^\s]+)?/i;
var noDecimalsDurationRegex = /^\s*([-+]?\d+)(?![.,])\s*([^\s]+)?/i;
var canonicalUnitNames = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year", "decade"];
var canonicalUnitAbbreviations = [["mil"], ["s", "sec"], ["m", "min"], ["h", "hr"], ["d"], ["w", "wk"], ["mo", "mon", "mnt"], ["q", "quar", "qrt"], ["y", "yr"], ["dec"]];
var deltaUnits = ["decade", "year", "month", "week", "day", "hour", "minute", "second", "millisecond"];
var dateProperties = ["milliseconds", "seconds", "minutes", "hours", "date", "month", "year"];
var parseNumber = (n) => {
  const result = parseFloat(n);
  return isNaN(result) ? null : result;
};
var numberRegex = /^[0-9]+$/;
var timeZoneRegEx = /([+-])(\d\d):*(\d\d)*$/;
var unitMagnitudes = {
  millisecond: 0,
  second: 1,
  minute: 2,
  hour: 3,
  day: 4,
  week: 5,
  month: 6,
  quarter: 7,
  year: 8,
  decade: 9
};
var snapFns = {
  round(number, step = 1) {
    return Math.round(number / step) * step;
  },
  floor(number, step = 1) {
    return Math.floor(number / step) * step;
  },
  ceil(number, step = 1) {
    return Math.ceil(number / step) * step;
  }
};
var keyCache = {};
var DateHelper = class extends Localizable() {
  static get $name() {
    return "DateHelper";
  }
  static set defaultFormat(format) {
    DH$1._defaultFormat = format;
  }
  static get defaultFormat() {
    return DH$1._defaultFormat || "YYYY-MM-DDTHH:mm:ssZ";
  }
  static set defaultParseFormat(parseFormat) {
    this._defaultParseFormat = parseFormat;
  }
  static get defaultParseFormat() {
    return this._defaultParseFormat || this._defaultFormat || "YYYY-MM-DDTHH:mm:ss.SSSZ";
  }
  static buildParser(format) {
    const parts = format.split(parserRegexp), parser = [];
    if (parts.length === 1 || localeStrRegExp.test(format)) {
      return [];
    } else {
      parts.reduce((prev, curr, index, array) => {
        if (index !== 0 || curr !== "") {
          if (parserRegexp.test(curr)) {
            const localeParsers = this.localize("L{parsers}") || {}, fn = localeParsers[curr] || parsers[curr];
            if (curr === "Z" && index < array.length - 2) {
              throw new Error(`Invalid format ${format} TimeZone (Z) must be last token`);
            }
            const parserObj = typeof fn === "function" || typeof fn === "string" ? fn : fn.parser();
            if (typeof parserObj === "string") {
              const nestedParsers = DH$1.buildParser(parserObj), lastItem = nestedParsers.pop();
              delete lastItem.last;
              parser.push(...nestedParsers);
              prev = lastItem;
            } else {
              prev.pattern = curr;
              prev.fn = parserObj;
            }
          } else {
            prev.splitter = curr;
            parser.push(prev);
            prev = {};
          }
        } else if (Object.prototype.hasOwnProperty.call(prev, "pattern")) {
          parser.push(prev);
        }
        return prev;
      }, {});
    }
    parser[parser.length - 1].last = true;
    return parser;
  }
  static makeKey(ms) {
    if (ms.length === 10) {
      return ms;
    }
    if (ms.getTime) {
      ms = ms.getTime();
    }
    const cached = keyCache[Math.trunc(ms / MS_PER_HOUR)];
    if (cached) {
      return cached;
    }
    tempDate.setTime(ms);
    const month2 = tempDate.getMonth() + 1, date = tempDate.getDate();
    return keyCache[Math.trunc(ms / MS_PER_HOUR)] = `${tempDate.getFullYear()}-${month2 < 10 ? "0" + month2 : month2}-${date < 10 ? "0" + date : date}`;
  }
  static parseKey(key) {
    return DH$1.parse(key, "YYYY-MM-DD");
  }
  static parse(dateString, format = DH$1.defaultParseFormat, strict = false) {
    if (dateString instanceof Date) {
      return dateString;
    }
    if (typeof dateString !== "string" || !dateString) {
      return null;
    }
    const config = {
      year: null,
      month: null,
      date: null,
      hours: null,
      minutes: null,
      seconds: null,
      milliseconds: null
    };
    format = format.replace(msRegExp, msReplacer);
    let parser = parserCache[format], result;
    if (!parser) {
      parser = parserCache[format] = DH$1.buildParser(format);
    }
    if (dateString.includes("\u202F")) {
      dateString = dateString.replace(/\s/g, " ");
    }
    parser.reduce((dateString2, parser2) => {
      if (parser2.last) {
        Object.assign(config, parser2.fn(dateString2));
      } else {
        let splitAt;
        if (parser2.splitter === "T" && dateString2.indexOf("T") === -1) {
          splitAt = dateString2.indexOf(" ");
        } else {
          splitAt = parser2.splitter !== "" ? dateString2.indexOf(parser2.splitter) : parser2.pattern && parser2.pattern.length || -1;
        }
        let part, rest;
        if (splitAt === -1 || parser2.pattern === "SSS" && dateString2.match(/^\d+Z$/)) {
          const chunks = dateString2.split(/([Z\-+])/);
          if (chunks.length === 1) {
            part = dateString2;
            rest = "";
          } else {
            part = chunks[0];
            rest = `${chunks[1]}${chunks[2]}`;
          }
        } else {
          part = dateString2.substring(0, splitAt) || dateString2;
          rest = dateString2.substring(splitAt + parser2.splitter.length);
        }
        if (parser2.fn) {
          const res = parser2.fn(part);
          if (res) {
            Object.assign(config, res);
          } else {
            rest = part + rest;
          }
        }
        return rest;
      }
    }, dateString);
    if (config.year && !config.date) {
      config.date = 1;
    }
    const date = DH$1.create(config, strict);
    if (date) {
      result = date;
    } else if (!strict) {
      result = new Date(dateString);
    }
    return result;
  }
  static create(definition, strict = false) {
    const def = _objectSpread2({}, definition);
    let invalid = isNaN(def.year), useUTC = false;
    if (!invalid) {
      let allNull = true;
      dateProperties.forEach((property) => {
        if (!(property in def) || isNaN(def[property])) {
          def[property] = 0;
        }
        allNull = allNull && def[property] === null;
      });
      invalid = allNull;
    }
    if (def.amPm === "am") {
      def.hours = def.hours % 12;
    } else if (def.amPm === "pm") {
      def.hours = def.hours % 12 + 12;
    }
    if ("timeZone" in def) {
      useUTC = true;
      def.minutes -= def.timeZone;
    }
    if (invalid) {
      return null;
    }
    if (strict && (def.year == null || def.month == null || def.date == null)) {
      return null;
    }
    const args = [defaultValue(def.year, DEFAULT_YEAR), defaultValue(def.month, DEFAULT_MONTH), defaultValue(def.date, DEFAULT_DAY), def.hours, def.minutes, def.seconds, def.milliseconds];
    return useUTC ? new Date(Date.UTC(...args)) : new Date(...args);
  }
  static toUTC(date) {
    return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()));
  }
  static format(date, format = DH$1.defaultFormat) {
    if (!date || isNaN(date)) {
      return null;
    }
    let formatter = formatCache[format], output = "";
    if (!formatter) {
      formatter = formatCache[format] = [];
      for (let i = 0; i < format.length; i++) {
        const formatMatch = format.slice(i).match(formatRegexp), predefined = formatMatch === null || formatMatch === void 0 ? void 0 : formatMatch[0];
        if (predefined) {
          const localeFormats = this.localize("L{formats}") || {}, fn = localeFormats[predefined] || formats[predefined];
          formatter.push(fn);
          i += predefined.length - 1;
        } else if (format[i] === "{") {
          const index = format.indexOf("}", i + 1);
          if (index === -1) {
            formatter.push(format.substr(i + 1));
            i = format.length;
          } else {
            formatter.push(format.substring(i + 1, index));
            i = index;
          }
        } else {
          formatter.push(format[i]);
        }
      }
    }
    formatter.forEach((step) => {
      if (typeof step === "string") {
        output += step;
      } else {
        output += step(date);
      }
    });
    return output;
  }
  static formatRange(dates, format) {
    return format.replace(rangeFormatPartRe, (s, which, fmt) => DateHelper.format(dates[which === "S" ? 0 : 1], fmt));
  }
  static asMilliseconds(amount, unit = null) {
    if (typeof amount === "string") {
      unit = amount;
      amount = 1;
    }
    return DH$1.as("millisecond", amount, unit);
  }
  static asMonths(time) {
    const monthLength = DH$1.as("ms", DH$1.daysInMonth(time), "day"), fraction = (time.valueOf() - DH$1.startOf(time, "month").valueOf()) / monthLength;
    return time.getYear() * 12 + time.getMonth() + fraction;
  }
  static monthsToDate(months) {
    const intMonths = Math.floor(months), fraction = months - intMonths, result = new Date(0, intMonths), msInMonth = DH$1.as("ms", DH$1.daysInMonth(result), "days");
    result.setTime(result.getTime() + fraction * msInMonth);
    return result;
  }
  static formatDelta(delta, options) {
    let abbrev, unitName;
    if (typeof options === "boolean") {
      abbrev = options;
    } else if (options) {
      abbrev = options.abbrev;
    }
    const deltaObj = this.getDelta(delta, options), result = [], sep = (options === null || options === void 0 ? void 0 : options.separator) || (abbrev ? "" : " ");
    for (unitName in deltaObj) {
      result.push(`${deltaObj[unitName]}${sep}${unitName}`);
    }
    return (options === null || options === void 0 ? void 0 : options.asString) === false ? result : result.join(", ");
  }
  static getDelta(delta, options) {
    let abbrev, d, done, precision, unitName, maxUnit, ignoreLocale;
    if (typeof options === "boolean") {
      abbrev = options;
    } else if (options) {
      abbrev = options.abbrev;
      precision = DH$1.normalizeUnit(options.precision);
      maxUnit = options.maxUnit;
      ignoreLocale = !abbrev && options.ignoreLocale;
    }
    const result = {}, getUnit = abbrev ? DH$1.getShortNameOfUnit : DH$1.getLocalizedNameOfUnit;
    const units = maxUnit ? deltaUnits.slice(deltaUnits.indexOf(maxUnit)) : deltaUnits;
    for (unitName of units) {
      d = DH$1.as(unitName, delta);
      done = precision === unitName;
      d = Math[done ? "round" : "floor"](d);
      if (d || done && !result.length) {
        result[ignoreLocale ? unitName : getUnit.call(DH$1, unitName, d !== 1)] = d;
        delta -= DH$1.as("ms", d, unitName);
      }
      if (done || !delta) {
        break;
      }
    }
    return result;
  }
  static as(toUnit, amount, fromUnit = "ms") {
    if (typeof amount === "string") {
      amount = DH$1.parseDuration(amount);
    }
    if (typeof amount === "object") {
      fromUnit = amount.unit;
      amount = amount.magnitude;
    }
    if (toUnit === fromUnit) {
      return amount;
    }
    toUnit = DH$1.normalizeUnit(toUnit);
    fromUnit = DH$1.normalizeUnit(fromUnit);
    if (toUnit === fromUnit) {
      return amount;
    } else if (unitMagnitudes[fromUnit] > unitMagnitudes[toUnit]) {
      return amount * Math.abs(validConversions[fromUnit][toUnit]);
    } else {
      return amount / Math.abs(validConversions[toUnit][fromUnit]);
    }
  }
  static formatContainsHourInfo(format) {
    const stripEscapeRe = /(\\.)/g, hourInfoRe = /([HhKkmSsAa]|LT|L{3,}|l{3,})/;
    return hourInfoRe.test(format.replace(stripEscapeRe, ""));
  }
  static is24HourFormat(format) {
    return DH$1.format(DH$1.getTime(13, 0, 0), format).includes("13");
  }
  static add(date, amount, unit = "ms", clone = true) {
    let d;
    if (typeof date === "string") {
      d = DH$1.parse(date);
    } else if (clone) {
      d = new Date(date.getTime());
    } else {
      d = date;
    }
    if (typeof amount === "string") {
      const duration = DateHelper.parseDuration(amount);
      amount = duration.magnitude;
      unit = duration.unit;
    } else if (amount && typeof amount === "object") {
      unit = amount.unit;
      amount = amount.magnitude;
    }
    if (!unit || amount === 0) {
      return d;
    }
    unit = DH$1.normalizeUnit(unit);
    switch (unit) {
      case "millisecond":
        d.setTime(d.getTime() + amount);
        break;
      case "second":
        d.setTime(d.getTime() + amount * 1e3);
        break;
      case "minute":
        d.setTime(d.getTime() + amount * 6e4);
        break;
      case "hour":
        d.setTime(d.getTime() + amount * 36e5);
        break;
      case "day":
        if (amount % 1 === 0) {
          d.setDate(d.getDate() + amount);
          if (d.getHours() === 23 && date.getHours() === 0) {
            d.setHours(d.getHours() + 1);
          }
        } else {
          d.setTime(d.getTime() + amount * 864e5);
        }
        break;
      case "week":
        d.setDate(d.getDate() + amount * 7);
        break;
      case "month": {
        let day2 = d.getDate();
        if (day2 > 28) {
          day2 = Math.min(day2, DH$1.getLastDateOfMonth(DH$1.add(DH$1.getFirstDateOfMonth(d), amount, "month")).getDate());
        }
        d.setDate(day2);
        d.setMonth(d.getMonth() + amount);
        break;
      }
      case "quarter":
        DH$1.add(d, amount * 3, "month", false);
        break;
      case "year":
        d.setFullYear(d.getFullYear() + amount);
        break;
      case "decade":
        d.setFullYear(d.getFullYear() + amount * 10);
        break;
    }
    return d;
  }
  static diff(start, end, unit = "ms", fractional = true) {
    unit = DH$1.normalizeUnit(unit);
    if (!start || !end)
      return 0;
    let amount;
    switch (unit) {
      case "year":
        amount = DH$1.diff(start, end, "month") / 12;
        break;
      case "quarter":
        amount = DH$1.diff(start, end, "month") / 3;
        break;
      case "month":
        amount = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
        break;
      case "week":
        amount = DH$1.diff(start, end, "day") / 7;
        break;
      case "day": {
        const dstDiff = start.getTimezoneOffset() - end.getTimezoneOffset();
        amount = (end - start + dstDiff * 60 * 1e3) / 864e5;
        break;
      }
      case "hour":
        amount = (end - start) / 36e5;
        break;
      case "minute":
        amount = (end - start) / 6e4;
        break;
      case "second":
        amount = (end - start) / 1e3;
        break;
      case "millisecond":
        amount = end - start;
        break;
    }
    return fractional ? amount : Math.round(amount);
  }
  static startOf(date, unit = "day", clone = true, weekStartDay = DH$1.weekStartDay) {
    if (!date) {
      return null;
    }
    unit = DH$1.normalizeUnit(unit);
    if (clone) {
      date = DH$1.clone(date);
    }
    switch (unit) {
      case "year":
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      case "quarter":
        date.setMonth((DH$1.get(date, "quarter") - 1) * 3, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      case "month":
        date.setDate(1);
        date.setHours(0, 0, 0, 0);
        return date;
      case "week": {
        const delta = date.getDay() - weekStartDay;
        date.setDate(date.getDate() - delta);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      case "day":
        date.setHours(0, 0, 0, 0);
        return date;
      case "hour":
        date.getMinutes() > 0 && date.setMinutes(0);
      case "minute":
        date.getSeconds() > 0 && date.setSeconds(0);
      case "second":
        date.getMilliseconds() > 0 && date.setMilliseconds(0);
      case "millisecond":
        return date;
    }
  }
  static endOf(date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
  }
  static clone(date) {
    return new Date(date.getTime());
  }
  static clearTime(date, clone = true) {
    if (!date) {
      return null;
    }
    if (clone) {
      date = new Date(date.getTime());
    }
    date.setHours(0, 0, 0, 0);
    return date;
  }
  static midnight(date, inclusive) {
    let ret = DH$1.clearTime(date);
    if (inclusive && ret < date) {
      ret = DH$1.add(ret, 1, "d");
    }
    return ret;
  }
  static getTimeOfDay(date, unit = "ms") {
    const t = date.getHours() * validConversions.hour.millisecond + date.getMinutes() * validConversions.minute.millisecond + date.getSeconds() * validConversions.second.millisecond + date.getMilliseconds();
    return unit === "ms" ? t : DH$1.as(unit, t, "ms");
  }
  static set(date, unit, amount) {
    if (!unit) {
      return date;
    }
    if (typeof unit === "string") {
      switch (DH$1.normalizeUnit(unit)) {
        case "millisecond":
          if (amount !== 0 || date.getMilliseconds() > 0) {
            date.setMilliseconds(amount);
          }
          break;
        case "second":
          if (amount !== 0 || date.getSeconds() > 0) {
            date.setSeconds(amount);
          }
          break;
        case "minute":
          if (amount !== 0 || date.getMinutes() > 0) {
            date.setMinutes(amount);
          }
          break;
        case "hour":
          date.setHours(amount);
          break;
        case "day":
        case "date":
          date.setDate(amount);
          break;
        case "week":
          throw new Error("week not implemented");
        case "month":
          date.setMonth(amount);
          break;
        case "quarter":
          date.setDate(1);
          date.setMonth((amount - 1) * 3);
          break;
        case "year":
          date.setFullYear(amount);
          break;
      }
    } else {
      Object.entries(unit).sort((a, b) => unitMagnitudes[a[0]] - unitMagnitudes[b[0]]).forEach(([unit2, amount2]) => {
        DH$1.set(date, unit2, amount2);
      });
    }
    return date;
  }
  static setDateToMidday(date, clone = true) {
    return DH$1.set(DH$1.clearTime(date, clone), "hour", 12);
  }
  static constrain(date, min2, max) {
    if (min2 != null) {
      date = DH$1.max(date, min2);
    }
    return max == null ? date : DH$1.min(date, max);
  }
  static getTime(hours, minutes = 0, seconds = 0, ms = 0) {
    if (hours instanceof Date) {
      ms = hours.getMilliseconds();
      seconds = hours.getSeconds();
      minutes = hours.getMinutes();
      hours = hours.getHours();
    }
    return new Date(DEFAULT_YEAR, DEFAULT_MONTH, DEFAULT_DAY, hours, minutes, seconds, ms);
  }
  static copyTimeValues(targetDate, sourceDate) {
    targetDate.setHours(sourceDate.getHours());
    targetDate.setMinutes(sourceDate.getMinutes());
    targetDate.setSeconds(sourceDate.getSeconds());
    targetDate.setMilliseconds(sourceDate.getMilliseconds());
    return targetDate;
  }
  static get isDSTEnabled() {
    const year = new Date().getFullYear(), jan = new Date(year, 0, 1), jul = new Date(year, 6, 1);
    return jan.getTimezoneOffset() !== jul.getTimezoneOffset();
  }
  static isDST(date) {
    const year = date.getFullYear(), jan = new Date(year, 0, 1), jul = new Date(year, 6, 1);
    return date.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
  }
  static isBefore(first, second) {
    return first < second;
  }
  static isAfter(first, second) {
    return first > second;
  }
  static isEqual(first, second, unit = null) {
    if (unit === null) {
      return first && second && first.getTime() === second.getTime();
    }
    return DH$1.startOf(first, unit) - DH$1.startOf(second, unit) === 0;
  }
  static compare(first, second, unit = null) {
    if (unit) {
      first = DH$1.startOf(first, unit);
      second = DH$1.startOf(second, unit);
    }
    if (first < second)
      return -1;
    if (first > second)
      return 1;
    return 0;
  }
  static clamp(date, min2, max) {
    if (!isNaN(date)) {
      if (min2 != null) {
        date = Math.max(date, min2);
      }
      if (max != null) {
        date = Math.min(date, max);
      }
      return new Date(date);
    }
  }
  static isSameDate(first, second) {
    return DH$1.compare(first, second, "d") === 0;
  }
  static isSameTime(first, second) {
    return first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes() && first.getSeconds() === second.getSeconds() && first.getMilliseconds() === second.getMilliseconds();
  }
  static isStartOf(date, unit) {
    return DH$1.isEqual(date, DH$1.startOf(date, unit));
  }
  static betweenLesser(date, start, end) {
    return start.getTime() <= date.getTime() && date.getTime() < end.getTime();
  }
  static betweenLesserEqual(date, start, end) {
    return start.getTime() <= date.getTime() && date.getTime() <= end.getTime();
  }
  static intersectSpans(date1Start, date1End, date2Start, date2End) {
    return DH$1.betweenLesser(date1Start, date2Start, date2End) || DH$1.betweenLesser(date2Start, date1Start, date1End);
  }
  static compareUnits(unit1, unit2) {
    return Math.sign(unitMagnitudes[DH$1.normalizeUnit(unit1)] - unitMagnitudes[DH$1.normalizeUnit(unit2)]);
  }
  static timeSpanContains(spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
    return otherSpanStart - spanStart >= 0 && spanEnd - otherSpanEnd >= 0;
  }
  static get weekStartDay() {
    if (DH$1._weekStartDay == null) {
      DH$1._weekStartDay = this.localize("L{weekStartDay}") || 0;
    }
    return DH$1._weekStartDay;
  }
  static get nonWorkingDays() {
    return _objectSpread2({}, this.localize("L{nonWorkingDays}"));
  }
  static get nonWorkingDaysAsArray() {
    return Object.keys(this.nonWorkingDays).map(Number);
  }
  static get weekends() {
    return _objectSpread2({}, this.localize("L{weekends}"));
  }
  static get(date, unit) {
    switch (DH$1.normalizeUnit(unit)) {
      case "millisecond":
        return date.getMilliseconds();
      case "second":
        return date.getSeconds();
      case "minute":
        return date.getMinutes();
      case "hour":
        return date.getHours();
      case "date":
      case "day":
        return date.getDate();
      case "week":
        return formats.W(date);
      case "month":
        return date.getMonth();
      case "quarter":
        return Math.floor(date.getMonth() / 3) + 1;
      case "year":
        return date.getFullYear();
    }
    return null;
  }
  static daysInYear(date) {
    const fullYear = date.getFullYear(), duration = new Date(fullYear + 1, 0, 1) - new Date(fullYear, 0, 1);
    return this.as("day", duration);
  }
  static daysInMonth(date) {
    return 32 - new Date(date.getFullYear(), date.getMonth(), 32).getDate();
  }
  static hoursInDay(date) {
    const fullYear = date.getFullYear(), month2 = date.getMonth(), day2 = date.getDate(), duration = new Date(fullYear, month2, day2 + 1) - new Date(fullYear, month2, day2);
    return this.as("hour", duration);
  }
  static getNormalizedUnitDuration(date, unit) {
    let result;
    switch (unit) {
      case "month":
        result = DH$1.asMilliseconds(DH$1.daysInMonth(date), "day");
        break;
      case "year":
        result = DH$1.asMilliseconds(DH$1.daysInYear(date), "day");
        break;
      case "day":
        result = DH$1.asMilliseconds(DH$1.hoursInDay(date), "hour");
        break;
      default:
        result = DH$1.asMilliseconds(unit);
    }
    return result;
  }
  static getFirstDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth(), 1);
  }
  static getLastDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth() + 1, 0);
  }
  static min(first, second) {
    return first.getTime() < second.getTime() ? first : second;
  }
  static max(first, second) {
    return first.getTime() > second.getTime() ? first : second;
  }
  static getNext(date, unit, increment = 1, weekStartDay = DH$1.weekStartDay) {
    if (unit === "week") {
      const dt = DH$1.clone(date), day2 = dt.getDay();
      DH$1.startOf(dt, "day", false);
      DH$1.add(dt, weekStartDay - day2 + 7 * (increment - (weekStartDay <= day2 ? 0 : 1)), "day", false);
      if (dt.getDay() !== weekStartDay) {
        DH$1.add(dt, 1, "hour");
      }
      return dt;
    }
    return DH$1.startOf(DH$1.add(date, increment, unit), unit, false);
  }
  static isValidDate(date) {
    return DH$1.isDate(date) && !isNaN(date);
  }
  static isDate(value) {
    return value && toString$1.call(value) === DATE_TYPE;
  }
  static getStartOfNextDay(date, clone = false, noNeedToClearTime = false) {
    let nextDay = DH$1.add(noNeedToClearTime ? date : DH$1.clearTime(date, clone), 1, "day");
    if (nextDay.getDate() === date.getDate()) {
      const offsetNextDay = DH$1.add(DH$1.clearTime(date, clone), 2, "day").getTimezoneOffset(), offsetDate = date.getTimezoneOffset();
      nextDay = DH$1.add(nextDay, offsetDate - offsetNextDay, "minute");
    }
    return nextDay;
  }
  static getEndOfPreviousDay(date, noNeedToClearTime = false) {
    const dateOnly = noNeedToClearTime ? date : DH$1.clearTime(date, true);
    if (dateOnly - date) {
      return dateOnly;
    } else {
      return DH$1.add(dateOnly, -1, "day");
    }
  }
  static getWeekDescription(startDate, endDate = startDate) {
    const monthDesc = startDate.getMonth() === endDate.getMonth() ? DateHelper.format(startDate, "MMMM") : `${DateHelper.format(startDate, "MMM")} - ${DateHelper.format(endDate, "MMM")}`, week = DateHelper.getWeekNumber(startDate);
    return `${week[1]}, ${monthDesc} ${week[0]}`;
  }
  static getWeekNumber(date, weekStartDay = DateHelper.weekStartDay) {
    const jan01 = new Date(date.getFullYear(), 0, 1), dec31 = new Date(date.getFullYear(), 11, 31), firstDay = normalizeDay(jan01.getDay() - weekStartDay), lastDay = normalizeDay(dec31.getDay() - weekStartDay), dayNumber = getDayDiff(date, jan01);
    let weekNumber;
    if (firstDay < 4) {
      weekNumber = Math.floor((dayNumber + firstDay - 1) / 7) + 1;
    } else {
      weekNumber = Math.floor((dayNumber + firstDay - 1) / 7);
    }
    if (weekNumber) {
      let year = date.getFullYear();
      if (weekNumber === 53 && lastDay < 3) {
        year++;
        weekNumber = 1;
      }
      return [year, weekNumber];
    }
    const lastWeekOfLastYear = DateHelper.getWeekNumber(new Date(date.getFullYear() - 1, 11, 31))[1];
    return [date.getFullYear() - 1, lastWeekOfLastYear];
  }
  static formatCount(count, unit) {
    unit = DH$1.normalizeUnit(unit);
    if (count !== 1)
      unit += "s";
    return count + " " + unit;
  }
  static getUnitToBaseUnitRatio(baseUnit, unit, acceptEstimate = false) {
    baseUnit = DH$1.normalizeUnit(baseUnit);
    unit = DH$1.normalizeUnit(unit);
    if (baseUnit === unit)
      return 1;
    if (validConversions[baseUnit] && validConversions[baseUnit][unit] && (acceptEstimate || validConversions[baseUnit][unit] > 0)) {
      return 1 / DH$1.as(unit, 1, baseUnit);
    }
    if (validConversions[unit] && validConversions[unit][baseUnit] && (acceptEstimate || validConversions[unit][baseUnit] > 0)) {
      return DH$1.as(baseUnit, 1, unit);
    }
    return -1;
  }
  static getShortNameOfUnit(unit) {
    unit = DH$1.parseTimeUnit(unit);
    return DH$1.unitLookup[unit].abbrev;
  }
  static getLocalizedNameOfUnit(unit, plural = false) {
    const capitalize = unit.charAt(0) === unit.charAt(0).toUpperCase();
    unit = DH$1.normalizeUnit(unit);
    unit = DH$1.parseTimeUnit(unit);
    unit = DH$1.unitLookup[unit][plural ? "plural" : "single"];
    if (capitalize) {
      unit = StringHelper.capitalize(unit);
    }
    return unit;
  }
  static normalizeUnit(unit) {
    if (!unit) {
      return null;
    }
    const unitLower = unit.toLowerCase();
    if (unitLower === "date") {
      return unitLower;
    }
    return canonicalUnitNames.includes(unitLower) ? unitLower : normalizedUnits[unit] || normalizedUnits[unitLower];
  }
  static getUnitByName(name) {
    return DH$1.normalizeUnit(name) || DH$1.normalizeUnit(DH$1.parseTimeUnit(name));
  }
  static getDurationInUnit(start, end, unit, doNotRound) {
    return DH$1.diff(start, end, unit, doNotRound);
  }
  static doesUnitsAlign(majorUnit, minorUnit) {
    return !(majorUnit !== minorUnit && minorUnit === "week");
  }
  static getSmallerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[DH$1.normalizeUnit(unit)] - 1] || null;
  }
  static getLargerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[DH$1.normalizeUnit(unit)] + 1] || null;
  }
  static round(time, increment, base, weekStartDay) {
    return DH$1.snap("round", time, increment, base, weekStartDay);
  }
  static floor(time, increment, base, weekStartDay) {
    return DH$1.snap("floor", time, increment, base, weekStartDay);
  }
  static ceil(time, increment, base, weekStartDay) {
    return DH$1.snap("ceil", time, increment, base, weekStartDay);
  }
  static snap(operation, time, increment, base, weekStartDay = DH$1.weekStartDay) {
    const snapFn = snapFns[operation];
    if (typeof increment === "string") {
      increment = DH$1.parseDuration(increment);
    }
    if (Objects.isObject(increment)) {
      const magnitude = increment.magnitude || increment.increment;
      switch (increment.unit) {
        case "week": {
          const weekDay = time.getDay();
          base = DH$1.add(DH$1.clearTime(time), weekDay >= weekStartDay ? weekStartDay - weekDay : -(weekDay - weekStartDay + 7), "day");
          return DH$1[operation](time, `${magnitude * 7} days`, base);
        }
        case "month": {
          time = DH$1.asMonths(time);
          let resultMonths;
          if (base) {
            base = DH$1.asMonths(base);
            resultMonths = time + snapFn(time - base, magnitude);
          } else {
            resultMonths = snapFn(time, magnitude);
          }
          return DH$1.monthsToDate(resultMonths);
        }
        case "quarter":
          return DH$1[operation](time, `${magnitude * 3} months`, base);
        case "year":
          return DH$1[operation](time, `${magnitude * 12} months`, base);
        case "decade":
          return DH$1[operation](time, `${magnitude * 10} years`, base);
      }
      increment = DH$1.as("ms", magnitude, increment.unit);
    }
    if (base) {
      const tzChange = DH$1.as("ms", base.getTimezoneOffset() - time.getTimezoneOffset(), "ms");
      return new Date(base.valueOf() + snapFn(DH$1.diff(base, time, "ms") + tzChange, increment));
    } else {
      const offset = time.getTimezoneOffset() * 60 * 1e3;
      return new Date(snapFn(time.valueOf() - offset, increment) + offset);
    }
  }
  static parseDuration(value, allowDecimals = true, defaultUnit) {
    var _match$;
    const durationRegEx = allowDecimals ? withDecimalsDurationRegex : noDecimalsDurationRegex, match = durationRegEx.exec(value);
    if (value == null || !match) {
      return null;
    }
    const magnitude = parseNumber((_match$ = match[1]) === null || _match$ === void 0 ? void 0 : _match$.replace(",", ".")), unit = DH$1.parseTimeUnit(match[2]) || defaultUnit;
    if (!unit) {
      return null;
    }
    return {
      magnitude,
      unit
    };
  }
  static parseTimeUnit(unitName) {
    const unitMatch = unitName == null ? null : DH$1.durationRegEx.exec(unitName.toLowerCase());
    if (!unitMatch) {
      return null;
    }
    for (let unitOrdinal = 0; unitOrdinal < canonicalUnitNames.length; unitOrdinal++) {
      if (unitMatch[unitOrdinal + 1]) {
        return canonicalUnitNames[unitOrdinal];
      }
    }
  }
  static getGMTOffset(date = new Date()) {
    if (!date) {
      return;
    }
    const offsetInMinutes = date.getTimezoneOffset();
    if (!offsetInMinutes)
      return "Z";
    return (offsetInMinutes > 0 ? "-" : "+") + Math.abs(Math.trunc(offsetInMinutes / 60)).toString().padStart(2, "0") + ":" + Math.abs(offsetInMinutes % 60).toString().padStart(2, "0");
  }
  static fillDayNames() {
    const tempDate2 = new Date("2000-01-01T12:00:00"), dayNames = DH$1._dayNames || [], dayShortNames = DH$1._dayShortNames || [];
    dayNames.length = 0;
    dayShortNames.length = 0;
    for (let day2 = 2; day2 < 9; day2++) {
      tempDate2.setDate(day2);
      dayNames.push(DH$1.format(tempDate2, "dddd"));
      dayShortNames.push(DH$1.format(tempDate2, "ddd"));
    }
    DH$1._dayNames = dayNames;
    DH$1._dayShortNames = dayShortNames;
  }
  static getDayNames() {
    return DH$1._dayNames;
  }
  static getDayName(day2) {
    return DH$1._dayNames[day2];
  }
  static getDayShortNames() {
    return DH$1._dayShortNames;
  }
  static getDayShortName(day2) {
    return DH$1._dayShortNames[day2];
  }
  static fillMonthNames() {
    const tempDate2 = new Date("2000-01-15T12:00:00"), monthNames = DH$1._monthNames || [], monthShortNames = DH$1._monthShortNames || [], monthNamesIndex = {}, monthShortNamesIndex = {};
    monthNames.length = 0;
    monthShortNames.length = 0;
    for (let month2 = 0; month2 < 12; month2++) {
      tempDate2.setMonth(month2);
      const monthName = DH$1.format(tempDate2, "MMMM");
      monthNames.push(monthName);
      const monthShortName = DH$1.format(tempDate2, "MMM");
      monthShortNames.push(monthShortName);
      monthNamesIndex[monthName.toLowerCase()] = {
        name: monthName,
        value: month2
      };
      monthShortNamesIndex[monthShortName.toLowerCase()] = {
        name: monthShortName,
        value: month2
      };
    }
    DH$1._monthNames = monthNames;
    DH$1._monthShortNames = monthShortNames;
    DH$1._monthNamesIndex = monthNamesIndex;
    DH$1._monthShortNamesIndex = monthShortNamesIndex;
  }
  static getMonthShortNames() {
    return DH$1._monthShortNames;
  }
  static getMonthShortName(month2) {
    return DH$1._monthShortNames[month2];
  }
  static getMonthNames() {
    return DH$1._monthNames;
  }
  static getMonthName(month2) {
    return DH$1._monthNames[month2];
  }
  static set locale(name) {
    locale$1 = name;
    intlFormatterCache = {};
    formatCache = {};
    formatRedirects = {};
  }
  static get locale() {
    return locale$1;
  }
  static setupDurationRegEx(unitNames = [], unitAbbreviations = []) {
    const me = this, unitLookup = {};
    let unitAbbrRegEx = "";
    for (let i = 0; i < unitAbbreviations.length; i++) {
      const abbreviations = unitAbbreviations[i], unitNamesCfg = unitNames[i];
      unitNamesCfg.canonicalUnitName = canonicalUnitNames[i];
      unitLookup[unitNamesCfg.single] = unitLookup[unitNamesCfg.single.toUpperCase()] = unitLookup[unitNamesCfg.canonicalUnitName] = unitLookup[unitNamesCfg.canonicalUnitName.toUpperCase()] = unitNamesCfg;
      unitAbbrRegEx += `${i ? "|" : ""}(`;
      for (let j = 0; j < abbreviations.length; j++) {
        unitAbbrRegEx += `${abbreviations[j]}|`;
      }
      locale$1 = me.localize("L{locale}") || "en-US";
      if (locale$1 !== "en-US") {
        const canonicalAbbreviations = canonicalUnitAbbreviations[i];
        for (let j = 0; j < canonicalAbbreviations.length; j++) {
          unitAbbrRegEx += `${canonicalAbbreviations[j]}|`;
        }
      }
      unitAbbrRegEx += `${unitNamesCfg.single}|${unitNamesCfg.plural}|${unitNamesCfg.canonicalUnitName}|${unitNamesCfg.canonicalUnitName}s)`;
    }
    me.unitLookup = unitLookup;
    me.durationRegEx = new RegExp(`^(?:${unitAbbrRegEx})$`);
  }
  static applyLocale() {
    const me = this, unitAbbreviations = me.localize("L{unitAbbreviations}") || [], unitNames = me.unitNames = me.localize("L{unitNames}");
    if (unitNames === "unitNames") {
      return;
    }
    locale$1 = me.localize("L{locale}") || "en-US";
    if (locale$1 === "en-US") {
      ordinalSuffix = enOrdinalSuffix;
    } else {
      ordinalSuffix = me.localize("L{ordinalSuffix}") || ordinalSuffix;
    }
    formatCache = {};
    formatRedirects = {};
    parserCache = {};
    intlFormatterCache = {};
    DH$1._weekStartDay = null;
    DH$1.setupDurationRegEx(unitNames, unitAbbreviations);
    DH$1.fillDayNames();
    DH$1.fillMonthNames();
  }
};
_defineProperty(DateHelper, "MS_PER_DAY", MS_PER_HOUR * 24);
var DH$1 = DateHelper;
DH$1.useIntlFormat = useIntlFormat;
LocaleManagerSingleton.ion({
  locale: "applyLocale",
  prio: 1e3,
  thisObj: DH$1
});
if (LocaleManagerSingleton.locale) {
  DH$1.applyLocale();
}
DateHelper._$name = "DateHelper";
var {
  hasOwn: hasOwn$2
} = Objects;
var toFixedFix = 1.005 .toFixed(2) === "1.01" ? null : function(number, fractionDigits) {
  const split = number.toString().split("."), newNumber = +(!split[1] ? split[0] : split.join(".") + "1");
  return number.toFixed.call(newNumber, fractionDigits);
};
var ObjectHelper = class extends Objects {
  static transformArrayToNamedObject(arrayOfItems, prop = "ref") {
    const namedItems = {};
    arrayOfItems.forEach((item, index) => {
      const key = item[prop] != null && item[prop].toString().length ? item[prop] : index;
      namedItems[key] = item;
    });
    return namedItems;
  }
  static transformNamedObjectToArray(namedItems, prop = "ref") {
    return Object.keys(namedItems).filter((key) => namedItems[key]).map((key) => {
      const item = namedItems[key];
      item[prop] = key;
      return item;
    });
  }
  static isEqual(a, b, useIsDeeply = false) {
    if (a === null && b !== null || a === void 0 && b !== void 0 || b === null && a !== null || b === void 0 && a !== void 0) {
      return false;
    }
    if (a == null && b == null) {
      return true;
    }
    if (a === b) {
      return true;
    }
    const typeA = typeof a, typeB = typeof b;
    if (typeA === typeB) {
      switch (typeA) {
        case "number":
        case "string":
        case "boolean":
          return a === b;
      }
      switch (true) {
        case (a instanceof Date && b instanceof Date):
          return a.getTime() === b.getTime();
        case (Array.isArray(a) && Array.isArray(b)):
          return a.length === b.length ? a.every((v, idx) => OH.isEqual(v, b[idx], useIsDeeply)) : false;
        case (typeA === "object" && a.constructor.prototype === b.constructor.prototype):
          return useIsDeeply ? OH.isDeeplyEqual(a, b, useIsDeeply) : JSON.stringify(a) === JSON.stringify(b);
      }
    }
    return String(a) === String(b);
  }
  static isDeeplyEqual(a, b, options = {}) {
    if (a === b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    const aKeys = OH.keys(a, options.ignore), bKeys = OH.keys(b, options.ignore);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (let i = 0; i < aKeys.length; i++) {
      const aKey = aKeys[i], bKey = bKeys[i];
      if (aKey !== bKey) {
        return false;
      }
      const aVal = a[aKey], bVal = b[bKey];
      if (options.shouldEvaluate) {
        if (options.shouldEvaluate(aKey, {
          value: aVal,
          object: a
        }, {
          value: bVal,
          object: b
        }) === false) {
          continue;
        }
      }
      if (options.evaluate) {
        const result = options.evaluate(aKey, {
          value: aVal,
          object: a
        }, {
          value: bVal,
          object: b
        });
        if (result === false) {
          return false;
        }
        if (result === true) {
          continue;
        }
      }
      if (!OH.isEqual(aVal, bVal, options)) {
        return false;
      }
    }
    return true;
  }
  static isPartial(a, b) {
    a = String(a).toLowerCase();
    b = String(b).toLowerCase();
    return a.indexOf(b) !== -1;
  }
  static isLessThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isBefore(a, b);
    }
    return a < b;
  }
  static isMoreThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isAfter(a, b);
    }
    return a > b;
  }
  static fork(obj) {
    let ret, key, value;
    if (obj && obj.constructor === Object) {
      ret = Object.setPrototypeOf({}, obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (value.constructor === Object) {
            ret[key] = OH.fork(value);
          } else if (value instanceof Array) {
            ret[key] = value.slice();
          }
        }
      }
    } else {
      ret = obj;
    }
    return ret;
  }
  static copyProperties(dest, source, props) {
    let prop, i;
    for (i = 0; i < props.length; i++) {
      prop = props[i];
      if (prop in source) {
        dest[prop] = source[prop];
      }
    }
    return dest;
  }
  static copyPropertiesIf(dest, source, props) {
    if (source) {
      for (const prop of props) {
        if (!(prop in dest)) {
          dest[prop] = source[prop];
        }
      }
    }
    return dest;
  }
  static entries(object, ignore) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore !== null && ignore !== void 0 && ignore[p])) {
          result.push([p, object[p]]);
        }
      }
    }
    return result;
  }
  static fromEntries(entries, object) {
    object = object || {};
    if (entries) {
      for (let i = 0; i < entries.length; ++i) {
        object[entries[i][0]] = entries[i][1];
      }
    }
    return object;
  }
  static keys(object, ignore, mapper) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      let index = 0;
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore !== null && ignore !== void 0 && ignore[p])) {
          result.push(mapper ? mapper(p, index) : p);
          ++index;
        }
      }
    }
    return result;
  }
  static values(object, ignore, mapper) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      let index = 0;
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore !== null && ignore !== void 0 && ignore[p])) {
          result.push(mapper ? mapper(object[p], index) : object[p]);
          ++index;
        }
      }
    }
    return result;
  }
  static pathExists(object, path) {
    const properties = path.split(".");
    return properties.every((property) => {
      if (!object || !(property in object)) {
        return false;
      }
      object = object[property];
      return true;
    });
  }
  static pathifyKeys(object) {
    const result = {};
    for (const key in object) {
      if (hasOwn$2(object, key)) {
        if (Array.isArray(object[key])) {
          result[key] = object[key].slice();
        } else if (object[key] instanceof Object) {
          const paths = this.pathifyKeys(object[key]);
          for (const path in paths) {
            result[`${key}.${path}`] = paths[path];
          }
        } else {
          result[key] = object[key];
        }
      }
    }
    return result;
  }
  static deletePath(object, path) {
    path.split(".").reduce((result, key, index, array) => {
      if (result == null) {
        return null;
      }
      if (hasOwn$2(result, key)) {
        if (index === array.length - 1) {
          delete result[key];
        } else {
          return result[key];
        }
      }
    }, object);
  }
  static coerce(from, to) {
    const fromType = Objects.typeOf(from), toType = Objects.typeOf(to), isString = typeof from === "string";
    if (fromType !== toType) {
      switch (toType) {
        case "string":
          return String(from);
        case "number":
          return Number(from);
        case "boolean":
          return isString && (!from || from === "false" || from === "0") ? false : Boolean(from);
        case "null":
          return isString && (!from || from === "null") ? null : false;
        case "undefined":
          return isString && (!from || from === "undefined") ? void 0 : false;
        case "date":
          return isString && isNaN(from) ? DateHelper.parse(from) : Date(Number(from));
      }
    }
    return from;
  }
  static wrapProperty(object, propertyName, newGetter, newSetter, deep = true) {
    const newProperty = {};
    let proto2 = Object.getPrototypeOf(object), existingProperty = Object.getOwnPropertyDescriptor(proto2, propertyName);
    while (!existingProperty && proto2 && deep) {
      proto2 = Object.getPrototypeOf(proto2);
      if (proto2) {
        existingProperty = Object.getOwnPropertyDescriptor(proto2, propertyName);
      }
    }
    if (existingProperty) {
      if (existingProperty.set) {
        newProperty.set = (v) => {
          existingProperty.set.call(object, v);
          newSetter && newSetter.call(object, existingProperty.get.call(object));
        };
      } else {
        newProperty.set = newSetter;
      }
      if (existingProperty.get) {
        newProperty.get = () => {
          let result = existingProperty.get.call(object);
          if (newGetter) {
            result = newGetter.call(object, result);
          }
          return result;
        };
      } else {
        newProperty.get = newGetter;
      }
    } else {
      newProperty.set = (v) => {
        object[`_${propertyName}`] = v;
        newSetter && newSetter.call(object, v);
      };
      newProperty.get = () => {
        let result = object[`_${propertyName}`];
        if (newGetter) {
          result = newGetter.call(object, result);
        }
        return result;
      };
    }
    Object.defineProperty(object, propertyName, newProperty);
  }
  static hookProperty(object, property, hook) {
    const desc = ObjectHelper.getPropertyDescriptor(hook.prototype, "value"), existingDesc = ObjectHelper.getPropertyDescriptor(object, property), fieldName = `_${property}`, base = class {
      get value() {
        return existingDesc ? existingDesc.get.call(this) : this[fieldName];
      }
      set value(v) {
        if (existingDesc) {
          existingDesc.set.call(this, v);
        } else {
          this[fieldName] = v;
        }
      }
    }, baseDesc = ObjectHelper.getPropertyDescriptor(base.prototype, "value");
    Object.setPrototypeOf(hook.prototype, base.prototype);
    Object.defineProperty(object, property, {
      configurable: true,
      get: desc.get || baseDesc.get,
      set: desc.set || baseDesc.set
    });
    return () => delete object[property];
  }
  static getPropertyDescriptor(object, propertyName) {
    let result = null;
    for (let o = object; o && !result && !hasOwn$2(o, "isBase"); o = Object.getPrototypeOf(o)) {
      result = Object.getOwnPropertyDescriptor(o, propertyName);
    }
    return result;
  }
  static cleanupProperties(object, keepNull = false) {
    Object.entries(object).forEach(([key, value]) => {
      if (keepNull) {
        value === void 0 && delete object[key];
      } else {
        value == null && delete object[key];
      }
    });
    return object;
  }
  static removeAllProperties(obj) {
    Object.keys(obj).forEach((key) => delete obj[key]);
    return obj;
  }
  static assertType(value, type, name) {
    const valueType = Objects.typeOf(value);
    if (value != null && valueType !== type) {
      throw new Error(`Incorrect type "${valueType}" for ${name}, expected "${type}"`);
    }
  }
  static assertObject(value, name) {
    OH.assertType(value, "object", name);
  }
  static assertInstance(value, name) {
    OH.assertType(value, "instance", name);
  }
  static assertClass(value, name) {
    OH.assertType(value, "class", name);
  }
  static assertFunction(value, name) {
    if (typeof value !== "function" || value.isBase || value.$$name) {
      throw new Error(`Incorrect type for ${name}, got "${value}" (expected a function)`);
    }
  }
  static assertNumber(value, name) {
    const asNumber = Number(value);
    if (typeof value !== "number" || isNaN(asNumber)) {
      throw new Error(`Incorrect type for ${name}, got "${value}" (expected a Number)`);
    }
  }
  static assertBoolean(value, name) {
    OH.assertType(value, "boolean", name);
  }
  static assertString(value, name) {
    OH.assertType(value, "string", name);
  }
  static assertArray(value, name) {
    OH.assertType(value, "array", name);
  }
  static toFixed(number, digits) {
    if (toFixedFix) {
      return toFixedFix(number, digits);
    }
    return number.toFixed(digits);
  }
  static roundTo(number, step = 1) {
    return Math.round(number / step) * step;
  }
  static round(number, digits) {
    if (digits == null) {
      return number;
    }
    const factor = 10 ** digits;
    return Math.round(number * factor) / factor;
  }
  static getMapPath(map, path, defaultValue2) {
    const keyPath = Array.isArray(path) ? path : typeof path === "string" ? path.split(".") : [path], simpleKey = keyPath.length === 1, topKey = keyPath[0], topValue = map.has(topKey) ? map.get(topKey) : map.set(topKey, simpleKey ? defaultValue2 : {}).get(topKey);
    if (simpleKey) {
      return topValue;
    }
    return OH.getPathDefault(topValue, keyPath.slice(1), defaultValue2);
  }
};
var OH = ObjectHelper;
ObjectHelper._$name = "ObjectHelper";
var allBorders = ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"];
var allMargins = ["margin-top", "margin-right", "margin-bottom", "margin-left"];
var allPaddings = ["padding-top", "padding-right", "padding-bottom", "padding-left"];
var borderNames = {
  t: "border-top-width",
  r: "border-right-width",
  b: "border-bottom-width",
  l: "border-left-width"
};
var paddingNames = {
  t: "padding-top",
  r: "padding-right",
  b: "padding-bottom",
  l: "padding-left"
};
var zeroBased = Object.freeze({
  x: 0,
  y: 0
});
var alignSpecRe$1 = /^([trblc])(\d*)-([trblc])(\d*)$/i;
var alignPointRe = /^([trblc])(\d*)$/i;
var edgeNames = ["top", "right", "bottom", "left"];
var edgeIndices = {
  t: 0,
  r: 1,
  b: 2,
  l: 3
};
var defaultAlignments = ["b-t", "l-r", "t-b", "r-l"];
var edgeAligments = {
  bt: 1,
  tb: 1,
  lr: 2,
  rl: 2
};
var zeroOffsets = Object.freeze([0, 0]);
var matchDimensions = ["width", "height"];
var parseEdges = (top, right = top, bottom = top, left = right) => {
  return Array.isArray(top) ? parseEdges.apply(null, top) : [top, right, bottom, left];
};
function parseAlign(alignSpec, rtl) {
  const parts = alignSpecRe$1.exec(alignSpec), myEdge = parts[1], targetEdge = parts[3], mO = parseInt(parts[2] || 50), tO = parseInt(parts[4] || 50), myOffset = rtl && !(edgeIndices[myEdge] & 1) ? 100 - mO : mO, targetOffset = rtl && !(edgeIndices[targetEdge] & 1) ? 100 - tO : tO, edgeAligned = edgeAligments[myEdge + targetEdge];
  return {
    myAlignmentPoint: myEdge + myOffset,
    myEdge,
    myOffset,
    targetAlignmentPoint: targetEdge + targetOffset,
    targetEdge,
    targetOffset,
    startZone: edgeIndices[targetEdge],
    edgeAligned
  };
}
function flipAlign(align) {
  return `${edgeNames[(edgeIndices[align.myEdge] + 2) % 4][0]}${align.myOffset}-${edgeNames[(edgeIndices[align.targetEdge] + 2) % 4][0]}${align.targetOffset}`;
}
function createOffsets(offset) {
  if (offset == null) {
    return zeroOffsets;
  } else if (typeof offset === "number") {
    return [offset, offset];
  }
  return offset;
}
var Rectangle = class {
  get isRectangle() {
    return true;
  }
  static from(element, relativeTo, ignorePageScroll) {
    var _element, _relativeTo;
    if (typeof element === "string") {
      element = document.querySelector(element);
    } else if (((_element = element) === null || _element === void 0 ? void 0 : _element.nodeType) === Node.DOCUMENT_FRAGMENT_NODE) {
      element = element.host || element.ownerDocument;
    }
    if (typeof relativeTo === "string") {
      relativeTo = document.querySelector(relativeTo);
    }
    if (element == null || element.isRectangle) {
      return element;
    }
    element = element.element || element;
    if (ignorePageScroll === void 0 && typeof relativeTo === "boolean") {
      ignorePageScroll = relativeTo;
      relativeTo = null;
    }
    if (!((_relativeTo = relativeTo) !== null && _relativeTo !== void 0 && _relativeTo.isRectangle)) {
      if (relativeTo) {
        let {
          scrollLeft,
          scrollTop
        } = relativeTo;
        if (BrowserHelper.isSafari && relativeTo === document.body) {
          scrollLeft = scrollTop = 0;
        }
        relativeTo = Rectangle.from(relativeTo).translate(-scrollLeft, -scrollTop);
      } else {
        relativeTo = zeroBased;
      }
    }
    const isViewport = element === document || element === globalThis, isSFViewport = element === document.body && document.body.offsetHeight === 0, sfElRect = isSFViewport && element.getBoundingClientRect(), viewRect = isSFViewport ? new Rectangle(sfElRect.left, sfElRect.top, sfElRect.width, document.body.parentElement.scrollHeight) : isViewport ? new Rectangle(0, 0, globalThis.innerWidth, globalThis.innerHeight) : element.getBoundingClientRect(), scrollOffset = ignorePageScroll || isViewport ? [0, 0] : [globalThis.pageXOffset, globalThis.pageYOffset];
    return new Rectangle(viewRect.left + scrollOffset[0] - relativeTo.x, viewRect.top + scrollOffset[1] - relativeTo.y, viewRect.width, viewRect.height);
  }
  static fromScreen(element, relativeTo) {
    return Rectangle.from(element, relativeTo, true);
  }
  static inner(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders);
      result.x += parseFloat(borders[borderNames.l]);
      result.y += parseFloat(borders[borderNames.t]);
      result.right -= parseFloat(borders[borderNames.r]);
      result.bottom -= parseFloat(borders[borderNames.b]);
    }
    return result;
  }
  static content(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders), padding = DomHelper.getStyleValue(element, allPaddings);
      result.x += parseFloat(borders[borderNames.l]) + parseFloat(padding[paddingNames.l]);
      result.y += parseFloat(borders[borderNames.t]) + parseFloat(padding[paddingNames.t]);
      result.right -= parseFloat(borders[borderNames.r]) + parseFloat(padding[paddingNames.r]);
      result.bottom -= parseFloat(borders[borderNames.b]) + parseFloat(padding[paddingNames.b]);
    }
    return result;
  }
  static client(element, relativeTo, ignorePageScroll = false) {
    const result = this.content(element, relativeTo, ignorePageScroll), scrollbarWidth = DomHelper.scrollBarWidth;
    let padding;
    if (scrollbarWidth) {
      if (element.scrollHeight > element.clientHeight && DomHelper.getStyleValue(element, "overflow-y") !== "hidden") {
        padding = parseFloat(DomHelper.getStyleValue(element, "padding-right"));
        result.right += padding - Math.max(padding, scrollbarWidth);
      }
      if (element.scrollWidth > element.clientWidth && DomHelper.getStyleValue(element, "overflow-x") !== "hidden") {
        padding = parseFloat(DomHelper.getStyleValue(element, "padding-bottom"));
        result.bottom += padding - Math.max(padding, scrollbarWidth);
      }
    }
    return result;
  }
  static outer(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    if (document.body.contains(element)) {
      const margin = DomHelper.getStyleValue(element, allMargins);
      result.x -= parseFloat(margin["margin-left"]);
      result.y -= parseFloat(margin["margin-top"]);
      result.right += parseFloat(margin["margin-right"]);
      result.bottom += parseFloat(margin["margin-bottom"]);
    }
    return result;
  }
  static union(...rectangles) {
    let {
      x,
      y,
      right,
      bottom
    } = rectangles[0], current;
    if (rectangles.length > 1) {
      for (let i = 1; i < rectangles.length; i++) {
        current = rectangles[i];
        if (current.x < x) {
          x = current.x;
        }
        if (current.y < y) {
          y = current.y;
        }
        if (current.right > right) {
          right = current.right;
        }
        if (current.bottom > bottom) {
          bottom = current.bottom;
        }
      }
    }
    return new Rectangle(x, y, right - x, bottom - y);
  }
  roundPx(devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const me = this;
    me._x = DomHelper.roundPx(me._x, devicePixelRatio);
    me._y = DomHelper.roundPx(me._y, devicePixelRatio);
    me._width = DomHelper.roundPx(me._width, devicePixelRatio);
    me._height = DomHelper.roundPx(me._height, devicePixelRatio);
    return me;
  }
  static get $$name() {
    return hasOwnProperty.call(this, "$name") && this.$name || hasOwnProperty.call(this, "_$name") && this._$name || this.name;
  }
  get $$name() {
    return this.constructor.$$name;
  }
  constructor(x, y, width, height) {
    ObjectHelper.assertNumber(x, "Rectangle.x");
    ObjectHelper.assertNumber(y, "Rectangle.y");
    ObjectHelper.assertNumber(width, "Rectangle.width");
    ObjectHelper.assertNumber(height, "Rectangle.height");
    const me = this;
    if (width < 0) {
      x += width;
      width = -width;
    }
    if (height < 0) {
      y += height;
      height = -height;
    }
    me._x = x;
    me._y = y;
    me._width = width;
    me._height = height;
  }
  clone() {
    const me = this, result = new Rectangle(me.x, me.y, me.width, me.height);
    result.isAlignRectangle = me.isAlignRectangle;
    result.minHeight = me.minHeight;
    result.minWidth = me.minWidth;
    return result;
  }
  contains(other) {
    const me = this;
    if (other.isRectangle) {
      return other._x >= me._x && other._y >= me._y && other.right <= me.right && other.bottom <= me.bottom;
    } else {
      return false;
    }
  }
  intersect(other, useBoolean = false, allowZeroDimensions = false) {
    const me = this, y = Math.max(me.y, other.y), r = Math.min(me.right, other.right), b = Math.min(me.bottom, other.bottom), x = Math.max(me.x, other.x), intersect = allowZeroDimensions ? b >= y && r >= x : b > y && r > x;
    if (intersect) {
      return useBoolean ? true : new Rectangle(x, y, r - x, b - y);
    } else {
      return false;
    }
  }
  equals(other, round2 = false) {
    const processor = round2 ? (x) => Math.round(x) : (x) => x;
    return other.isRectangle && processor(other.x) === processor(this.x) && processor(other.y) === processor(this.y) && processor(other.width) === processor(this.width) && processor(other.height) === processor(this.height);
  }
  translate(x, y) {
    this._x += x || 0;
    this._y += y || 0;
    return this;
  }
  moveTo(x, y) {
    if (x != null) {
      this._x = x;
    }
    if (y != null) {
      this._y = y;
    }
    return this;
  }
  getDelta(other) {
    return [other.x - this.x, other.y - this.y];
  }
  get center() {
    return new Rectangle.Point(this.x + this.width / 2, this.y + this.height / 2);
  }
  set x(x) {
    const xDelta = x - this._x;
    this._x = x;
    this._width -= xDelta;
  }
  get x() {
    return this._x;
  }
  get start() {
    return this.left;
  }
  set left(x) {
    this.x = x;
  }
  get left() {
    return this.x;
  }
  set top(y) {
    this.y = y;
  }
  get top() {
    return this.y;
  }
  set y(y) {
    const yDelta = y - this._y;
    this._y = y;
    this._height -= yDelta;
  }
  get y() {
    return this._y;
  }
  set width(width) {
    this._width = width;
  }
  get width() {
    return this._width;
  }
  set height(height) {
    this._height = height;
  }
  get height() {
    return this._height;
  }
  set right(right) {
    this._width = right - this._x;
  }
  get right() {
    return this._x + this._width;
  }
  get end() {
    return this.right;
  }
  set bottom(bottom) {
    this._height = bottom - this._y;
  }
  get bottom() {
    return this._y + this._height;
  }
  getStart(rtl, horizontal = true) {
    if (horizontal) {
      return rtl ? this.right : this.left;
    }
    return this.top;
  }
  getEnd(rtl, horizontal = true) {
    if (horizontal) {
      return rtl ? this.left : this.right;
    }
    return this.bottom;
  }
  get area() {
    return this.width * this.height;
  }
  set minWidth(minWidth) {
    const me = this;
    if (isNaN(minWidth)) {
      me._minWidth = null;
    } else {
      me._minWidth = Number(minWidth);
      if (!me.isAlignRectangle) {
        me.width = Math.max(me.width, me._minWidth);
      }
    }
  }
  get minWidth() {
    return this._minWidth;
  }
  set minHeight(minHeight) {
    const me = this;
    if (isNaN(minHeight)) {
      me._minHeight = null;
    } else {
      me._minHeight = Number(minHeight);
      if (!me.isAlignRectangle) {
        me.height = Math.max(me.height, me._minHeight);
      }
    }
  }
  get minHeight() {
    return this._minHeight;
  }
  adjust(x, y, width, height) {
    const me = this;
    me.x += x;
    me.y += y;
    me.width += width;
    me.height += height;
    return me;
  }
  inflate(top, right = top, bottom = top, left = right) {
    if (Array.isArray(top)) {
      [top, right, bottom, left] = parseEdges(top);
    }
    return this.adjust(-left, -top, right, bottom);
  }
  deflate(top, right = top, bottom = top, left = right) {
    if (Array.isArray(top)) {
      [top, right, bottom, left] = parseEdges(top);
    }
    return this.adjust(left, top, -right, -bottom);
  }
  constrainTo(constrainTo, strict) {
    const me = this, originalHeight = me.height, originalY = me.y, minWidth = me.minWidth || me.width, minHeight = me.minHeight || me.height;
    if (me.height >= constrainTo.height) {
      if (strict && minHeight > constrainTo.height) {
        return false;
      }
      me._y = constrainTo.y;
      me.height = constrainTo.height;
    }
    if (me.width >= constrainTo.width) {
      if (strict && minWidth > constrainTo.width) {
        me.y = originalY;
        me.height = originalHeight;
        return false;
      }
      me._x = constrainTo.x;
      me.width = constrainTo.width;
    }
    let overflow = me.bottom - constrainTo.bottom;
    if (overflow > 0) {
      me.translate(0, -overflow);
    }
    overflow = me.right - constrainTo.right;
    if (overflow > 0) {
      me.translate(-overflow);
    }
    overflow = constrainTo.y - me.y;
    if (overflow > 0) {
      me.translate(0, overflow);
    }
    overflow = constrainTo.x - me.x;
    if (overflow > 0) {
      me.translate(overflow);
    }
    return me;
  }
  alignTo(spec) {
    let result = this.clone(), {
      target,
      constrainTo,
      constrainPadding
    } = spec, calculatedAnchorPosition, zone, resultZone, constrainingToViewport;
    if (target && !target.isRectangle) {
      target = Rectangle.from(target.element ? target.element : target);
    }
    if (constrainTo) {
      if (!constrainTo.isRectangle) {
        constrainingToViewport = constrainTo === globalThis || constrainTo === document;
        const ignorePageScroll = "ignorePageScroll" in spec ? spec.ignorePageScroll : !constrainingToViewport;
        constrainTo = Rectangle.from(constrainTo.element ? constrainTo.element : constrainTo, null, ignorePageScroll);
      }
      if (constrainPadding) {
        constrainPadding = parseEdges(constrainPadding);
        constrainPadding[0] = Math.min(constrainPadding[0], target.top);
        constrainPadding[1] = Math.min(constrainPadding[1], constrainTo.right - target.right);
        constrainPadding[2] = Math.min(constrainPadding[0], constrainTo.bottom - target.bottom);
        constrainPadding[3] = Math.min(constrainPadding[0], target.left);
        constrainTo = constrainTo.deflate.apply(constrainTo.clone(), constrainPadding);
      }
    }
    const me = this, targetOffsets = createOffsets(spec.offset), {
      align,
      axisLock,
      anchorSize,
      anchorPosition,
      matchSize,
      position,
      rtl
    } = spec, alignSpec = parseAlign(align, rtl), targetConstrainRect = constrainTo && constrainTo.clone(), constraintZones = [], zoneOrder = [{
      zone: zone = alignSpec.startZone,
      align
    }], matchDimension = matchSize && matchDimensions[alignSpec.startZone & 1], originalSize = me[matchDimension];
    if (matchDimension && axisLock) {
      result[matchDimension] = target[matchDimension];
    } else if (!alignSpec.edgeAligned && matchSize) {
      result.width = target.width;
      result.height = target.height;
    }
    if (constrainTo) {
      result.constrainTo(constrainTo);
    }
    if (constrainTo && alignSpec.startZone != null) {
      if (axisLock) {
        zoneOrder.push({
          zone: zone = (zone + 2) % 4,
          align: flipAlign(alignSpec)
        });
        if (axisLock === "flexible") {
          zoneOrder.push({
            zone: zone = (alignSpec.startZone + 1) % 4,
            align: defaultAlignments[zone]
          });
          zoneOrder.push({
            zone: zone = (zone + 2) % 4,
            align: defaultAlignments[zone]
          });
        }
      } else {
        for (let i = 1; i < 4; i++) {
          zoneOrder.push({
            zone: zone = (zone + 1) % 4,
            align: defaultAlignments[zone]
          });
        }
      }
    }
    if (anchorPosition) {
      const pos = alignSpec.startZone & 1 ? "y" : "x";
      calculatedAnchorPosition = {
        [pos]: anchorPosition[pos],
        edge: edgeNames[(alignSpec.startZone + 2) % 4]
      };
    }
    if (targetConstrainRect && target) {
      targetConstrainRect.adjust(-target.width, -target.height, target.width, target.height);
      target.constrainTo(targetConstrainRect);
    }
    result.minWidth = me.minWidth;
    result.minHeight = me.minHeight;
    if (position) {
      result.moveTo(position.x, position.y);
      if (constrainTo) {
        result.constrainTo(constrainTo);
      }
    } else {
      const centerAligned = alignSpec.myEdge === "c" || alignSpec.targetEdge === "c", offsets = anchorSize && !centerAligned ? [anchorSize[1] + targetOffsets[0], anchorSize[1] + targetOffsets[1]] : targetOffsets, targetPoint = target.getAlignmentPoint(alignSpec.targetAlignmentPoint, offsets), myPoint = result.getAlignmentPoint(alignSpec.myAlignmentPoint);
      result.translate(targetPoint[0] - myPoint[0], targetPoint[1] - myPoint[1]);
      let overlap = result.intersect(target, true);
      if (overlap) {
        if (constrainTo) {
          result.constrainTo(constrainTo);
        }
        resultZone = alignSpec.startZone;
        result.translate(...offsets);
      } else if (constrainTo && !constrainTo.contains(result)) {
        const requestedResult = result.clone(), solutions = [];
        let zone2, largestZone;
        calculatedAnchorPosition = null;
        constraintZones[0] = zone2 = constrainTo.clone();
        zone2.bottom = target.y - offsets[1];
        constraintZones[1] = zone2 = constrainTo.clone();
        zone2.x = target.right + offsets[0];
        constraintZones[2] = zone2 = constrainTo.clone();
        zone2.y = target.bottom + offsets[1];
        constraintZones[3] = zone2 = constrainTo.clone();
        zone2.right = target.x - offsets[0];
        for (let i = 0; i < zoneOrder.length; i++) {
          if (matchDimension && i == 2) {
            result[matchDimension] = originalSize;
          }
          zone2 = constraintZones[resultZone = zoneOrder[i].zone];
          result = result.alignTo({
            target,
            offsets,
            align: zoneOrder[i].align
          });
          if (result.constrainTo(zone2, true)) {
            solutions.push({
              result,
              zone: resultZone
            });
            if (!largestZone || result.width < me.width || result.height < me.height) {
              result.align = zoneOrder[i].align;
              break;
            }
          }
          if (!largestZone || zone2.area > largestZone.area) {
            const r = result.clone();
            switch (resultZone) {
              case 0:
                r.moveTo(null, zone2.bottom - r.height);
                break;
              case 1:
                r.moveTo(zone2.left);
                break;
              case 2:
                r.moveTo(null, zone2.top);
                break;
              case 3:
                r.moveTo(zone2.right - r.width);
                break;
            }
            largestZone = {
              area: zone2.area,
              result: r,
              zone: resultZone
            };
          }
        }
        if (solutions.length) {
          if (solutions.length > 1 && !axisLock) {
            solutions.sort((s12, s22) => {
              const s1TranslationDistance = Math.sqrt((requestedResult.x - s12.result.x) ** 2 + (requestedResult.y - s12.result.y) ** 2), s2TranslationDistance = Math.sqrt((requestedResult.x - s22.result.x) ** 2 + (requestedResult.y - s22.result.y) ** 2);
              return s1TranslationDistance - s2TranslationDistance;
            });
          }
          result = solutions[0].result;
          resultZone = solutions[0].zone;
        } else {
          result = largestZone.result;
          resultZone = largestZone.zone;
          if (constrainingToViewport) {
            result.constrainTo(constrainTo);
          }
        }
      } else {
        resultZone = alignSpec.startZone;
      }
      result.zone = resultZone;
      result.overlap = overlap = result.intersect(target, true);
      if (anchorSize && !overlap) {
        if (!calculatedAnchorPosition) {
          const isLeftOrRight = resultZone & 1, start = isLeftOrRight ? "y" : "x", end = isLeftOrRight ? "bottom" : "right", startValue = Math.max(target[start], result[start]), endValue = Math.min(target[end], result[end]);
          let anchorStart = startValue + (endValue - startValue) / 2 - anchorSize[0] / 2;
          const anchorEnd = anchorStart + anchorSize[0];
          if (anchorEnd > result[end]) {
            anchorStart -= anchorEnd - result[end];
          }
          if (anchorStart < result[start]) {
            anchorStart += result[start] - anchorStart;
          }
          calculatedAnchorPosition = {
            [start]: anchorStart - result[start],
            edge: edgeNames[(resultZone + 2) % 4]
          };
        }
        result.anchor = calculatedAnchorPosition;
      }
    }
    return result;
  }
  getAlignmentPoint(alignmentPoint, margins = zeroOffsets) {
    const me = this, parts = alignPointRe.exec(alignmentPoint), edge = parts[1].toLowerCase(), edgeOffset = Math.min(Math.max(parseInt(parts[2] || 50), 0), 100) / 100;
    switch (edge) {
      case "t":
        return [me.x + me.width * edgeOffset, me.y - margins[1]];
      case "r":
        return [me.right + margins[0], me.y + me.height * edgeOffset];
      case "b":
        return [me.x + me.width * edgeOffset, me.bottom + margins[1]];
      case "l":
        return [me.x - margins[0], me.y + me.height * edgeOffset];
      case "c": {
        return [me.x + me.width / 2, me.y + me.height / 2];
      }
    }
  }
  highlight() {
    const me = this, highlightElement = DomHelper.createElement({
      parent: document.body,
      style: `position:absolute;z-index:9999999;pointer-events:none;
                            left:${me.x}px;top:${me.y}px;width:${me.width}px;height:${me.height}px`
    });
    return DomHelper.highlight(highlightElement).then(() => highlightElement.remove());
  }
  visualize(config, asDomConfig) {
    const me = this, domConfig = ObjectHelper.merge({
      style: _objectSpread2({
        left: `${me.x}px`,
        top: `${me.y}px`,
        width: `${me.width}px`,
        height: `${me.height}px`,
        pointerEvents: "none"
      }, config.class ? {} : {
        position: "absolute",
        "z-index": 9999999
      })
    }, config);
    return asDomConfig ? domConfig : DomHelper.createElement(domConfig);
  }
  toString(delimiter = ",") {
    return [`${this.top}px`, `${this.right}px`, `${this.bottom}px`, `${this.left}px`].join(delimiter);
  }
};
Rectangle._$name = "Rectangle";
var valueSymbol = Symbol("value");
var lengthSymbol = Symbol("length");
var DomClassList = class {
  static change(cls, add, remove, as = "string") {
    remove = DomClassList.normalize(remove, "object");
    const after = DomClassList.normalize(cls, "array").filter((c) => !remove[c]);
    if (add) {
      add = DomClassList.normalize(add, "array");
      for (let i = 0; i < add.length; ++i) {
        if (!after.includes(add[i])) {
          after.push(add[i]);
        }
      }
    }
    return DomClassList.normalize(after, as);
  }
  static from(classes, returnEmpty) {
    if (classes) {
      if (classes.isDomClassList) {
        var _returnEmpty;
        returnEmpty = (_returnEmpty = returnEmpty) !== null && _returnEmpty !== void 0 ? _returnEmpty : true;
      } else {
        var _returnEmpty2;
        returnEmpty = (_returnEmpty2 = returnEmpty) !== null && _returnEmpty2 !== void 0 ? _returnEmpty2 : Objects.isObject(classes) && !Objects.isEmpty(classes);
        classes = new DomClassList(classes);
      }
      if (!classes.value && !returnEmpty) {
        classes = null;
      }
    }
    return classes || (returnEmpty ? new DomClassList() : null);
  }
  static normalize(cls, as = "string") {
    cls = cls || "";
    const type = typeof cls, asArray = as === "array", asObject = as === "object", asString = !asArray && !asObject;
    let isString = type === "string", c, i, ret;
    if (type === "object") {
      var _cls;
      if (cls.nodeType === Element.ELEMENT_NODE && typeof cls.getAttribute === "function") {
        cls = cls.getAttribute("class") || "";
        isString = true;
      } else if ((_cls = cls) !== null && _cls !== void 0 && _cls.isDomClassList) {
        cls = cls.values;
      } else if (cls instanceof DOMTokenList) {
        cls = Array.from(cls);
      } else if (cls instanceof Map) {
        cls = Array.from(cls.keys()).filter((k) => cls.get(k));
      } else if (cls instanceof Set) {
        cls = Array.from(cls);
      } else if (!Array.isArray(cls)) {
        cls = Objects.getTruthyKeys(cls);
      }
    }
    if (isString) {
      cls = [...new Set(StringHelper.split(cls))];
    }
    for (i = cls.length; i-- > 0; ) {
      c = cls[i];
      if (!c.length) {
        cls.splice(i, 1);
      } else if (c.includes(" ")) {
        cls.splice(i, 1, ...StringHelper.split(c));
      }
    }
    if (asArray) {
      ret = cls;
    } else if (asString) {
      ret = cls.join(" ");
    } else {
      ret = /* @__PURE__ */ Object.create(null);
      for (i = 0; i < cls.length; ++i) {
        ret[cls[i]] = true;
      }
    }
    return ret;
  }
  constructor(...classes) {
    this.process(1, classes);
  }
  clear() {
    for (const key in this) {
      this[key] = false;
    }
    return this;
  }
  set(...classes) {
    return this.clear().process(1, classes);
  }
  get isDomClassList() {
    return true;
  }
  clone() {
    return new DomClassList(this);
  }
  contains(className) {
    if (typeof className === "string" && className) {
      return Boolean(this[className]);
    }
    return false;
  }
  toString() {
    return this.length ? `${this.value} ` : "";
  }
  toJSON() {
    return this.toString();
  }
  trim() {
    return this.value;
  }
  isEqual(other) {
    const otherClasses = DomClassList.normalize(other, "array"), len = otherClasses.length;
    if (this.length === len) {
      for (let i = 0; i < len; i++) {
        if (!this[otherClasses[i]]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  get value() {
    let value = this[valueSymbol], keys;
    if (value == null) {
      keys = Objects.getTruthyKeys(this);
      this[lengthSymbol] = keys.length;
      this[valueSymbol] = value = keys.join(" ");
    }
    return value;
  }
  set value(value) {
    const me = this, keys = Object.keys(me), len = keys.length;
    for (let i = 0; i < len; i++) {
      delete me[keys[i]];
    }
    if (value) {
      me.process(1, [value]);
    } else {
      delete me[valueSymbol];
    }
  }
  get values() {
    return Objects.getTruthyKeys(this);
  }
  get length() {
    return this.value ? this[lengthSymbol] : 0;
  }
  process(value, classes) {
    for (let cls, k, i = 0; i < classes.length; i++) {
      if (classes[i]) {
        cls = classes[i];
        if (cls.isDomClassList || Objects.isObject(cls)) {
          for (k in cls) {
            this[k] = value ? cls[k] : !cls[k];
          }
        } else {
          cls = DomClassList.normalize(classes[i], "array");
          for (k = 0; k < cls.length; ++k) {
            this[cls[k]] = value;
          }
        }
      }
    }
    delete this[valueSymbol];
    return this;
  }
  assign(classList) {
    for (const cls in classList) {
      if (!this[cls] !== !classList[cls]) {
        this[cls] = classList[cls];
        delete this[valueSymbol];
      }
    }
    return this;
  }
  assignTo(element) {
    const classList = element.nodeType === Element.ELEMENT_NODE ? element.classList : element, temp = DomClassList.from(classList);
    temp.add(this);
    classList.value = temp.value;
  }
  add(...classes) {
    return this.process(1, classes);
  }
  remove(...classes) {
    return this.process(0, classes);
  }
  toggle(className, flag = Boolean(!this[className])) {
    flag = Boolean(flag);
    if (Boolean(this[className]) !== flag) {
      this[className] = flag;
      delete this[valueSymbol];
      return true;
    }
  }
  split() {
    return Objects.getTruthyKeys(this);
  }
  forEach(fn) {
    return Objects.getTruthyKeys(this).forEach(fn);
  }
};
DomClassList.prototype[valueSymbol] = null;
DomClassList._$name = "DomClassList";
var Point = class extends Rectangle {
  static from(event) {
    const touchPoints = event.changedTouches;
    return new Point(touchPoints ? touchPoints[0].screenX : event.screenX, touchPoints ? touchPoints[0].screenY : event.pageY);
  }
  constructor(x, y) {
    super(x, y, 0, 0);
  }
  constrain(into) {
    this.x = Math.min(Math.max(this.x, into.x), into.right - 1);
    this.y = Math.min(Math.max(this.y, into.y), into.bottom - 1);
    return this;
  }
  toArray() {
    return [this.x, this.y];
  }
};
Object.getPrototypeOf(Point).Point = Point;
Point._$name = "Point";
var touchProperties = ["clientX", "clientY", "pageX", "pageY", "screenX", "screenY"];
var isOption = {
  element: 1,
  thisObj: 1,
  once: 1,
  delegate: 1,
  delay: 1,
  capture: 1,
  passive: 1,
  throttled: 1,
  autoDetach: 1,
  expires: 1,
  block: 1
};
var configurable = true;
var returnTrueProp = {
  configurable,
  value: true
};
var normalizedKeyNames = {
  Spacebar: "Space",
  Del: "Delete",
  Esc: "Escape",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown"
};
var ignoreModifierKeys = {
  Meta: 1,
  Control: 1,
  Alt: 1
};
var specialKeys = {
  Control: "ctrl",
  Alt: "alt",
  Shift: "shift"
};
var longpressMoveThreshold = 5;
var specialKeyRe = /^(ctrl|shift|alt|meta)$/;
var EventHelper = class {
  static normalizeEvent(event) {
    return ObjectHelper.copyPropertiesIf(event, event.changedTouches[0] || event.touches[0], touchProperties);
  }
  static getXY(event) {
    if (event.touches) {
      event = event.touches[0];
    }
    return [event.clientX, event.clientY];
  }
  static getDistanceBetween(event1, event2) {
    const xy1 = EH.getXY(event1), xy2 = EH.getXY(event2);
    return Math.sqrt(Math.pow(xy1[0] - xy2[0], 2) + Math.pow(xy1[1] - xy2[1], 2));
  }
  static getPagePoint(event) {
    return new Rectangle.Point(event.pageX, event.pageY);
  }
  static getClientPoint(event) {
    return new Rectangle.Point(event.clientX, event.clientY);
  }
  static addListener(element, eventName, handler, options) {
    if (element.nodeType) {
      if (typeof eventName === "string") {
        options = Object.assign({
          element,
          [eventName]: handler
        }, options);
      } else {
        options = Object.assign({
          element
        }, eventName);
      }
    } else {
      options = element;
    }
    return EH.on(options);
  }
  static on(options) {
    const element = options.element, thisObj = options.thisObj, handlerDetails = [];
    for (const eventName in options) {
      if (!isOption[eventName]) {
        let handlerSpec = options[eventName];
        if (typeof handlerSpec !== "object") {
          handlerSpec = {
            handler: handlerSpec
          };
        }
        const targetElement = handlerSpec.element || element;
        if (BrowserHelper.isTouchDevice && !BrowserHelper.isAndroid) {
          if (eventName === "contextmenu") {
            handlerDetails.push(EH.addElementListener(targetElement, "touchstart", {
              handler: EH.createContextMenuWrapper(handlerSpec.handler, handlerSpec.thisObj || thisObj)
            }, options));
          }
        }
        handlerDetails.push(EH.addElementListener(targetElement, eventName, handlerSpec, options));
      }
    }
    const detacher2 = () => {
      for (let handlerSpec, i = 0; i < handlerDetails.length; i++) {
        handlerSpec = handlerDetails[i];
        EH.removeEventListener(handlerSpec[0], handlerSpec[1], handlerSpec[2]);
      }
      handlerDetails.length = 0;
    };
    if (thisObj && options.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, detacher2, thisObj);
    }
    return detacher2;
  }
  static addElementListener(element, eventName, handlerSpec, defaults) {
    const handler = EH.createHandler(element, eventName, handlerSpec, defaults), {
      spec
    } = handler, expires = handlerSpec.expires || defaults.expires, options = spec.capture != null || spec.passive != null ? {
      capture: spec.capture,
      passive: spec.passive
    } : void 0;
    element.addEventListener(eventName, handler, options);
    if (expires) {
      const thisObj = handlerSpec.thisObj || defaults.thisObj, delayable = thisObj !== null && thisObj !== void 0 && thisObj.isDelayable ? thisObj : globalThis, {
        alt: alt2
      } = expires, delay = alt2 ? expires.delay : expires, {
        spec: spec2
      } = handler;
      spec2.expires = expires;
      spec2.timerId = delayable[typeof delay === "number" ? "setTimeout" : "requestAnimationFrame"](() => {
        spec2.timerId = null;
        EH.removeEventListener(element, eventName, handler);
        if (alt2 && !handler.called) {
          (typeof alt2 === "string" ? thisObj[alt2] : alt2).call(thisObj);
        }
      }, delay, `listener-timer-${performance.now()}`);
    }
    return [element, eventName, handler, options];
  }
  static getComposedPathTarget(event) {
    return event.composedPath()[0] || event.path[0];
  }
  static fixEvent(event) {
    var _target$getRootNode, _event$relatedTarget;
    if (event.fixed) {
      return event;
    }
    const {
      type,
      target
    } = event;
    if ((target !== null && target !== void 0 && target.shadowRoot || target !== null && target !== void 0 && (_target$getRootNode = target.getRootNode) !== null && _target$getRootNode !== void 0 && _target$getRootNode.call(target).host) && event.composedPath) {
      const targetElement = this.getComposedPathTarget(event), originalTarget = target;
      Object.defineProperty(event, "target", {
        value: targetElement,
        configurable
      });
      Object.defineProperty(event, "originalTarget", {
        value: originalTarget,
        configurable
      });
    }
    Object.defineProperty(event, "fixed", returnTrueProp);
    if (type.startsWith("key")) {
      const normalizedKeyName = normalizedKeyNames[event.key];
      if (normalizedKeyName) {
        Object.defineProperty(event, "key", {
          value: normalizedKeyName,
          configurable
        });
      }
      if (event.key === " " && !event.code) {
        Object.defineProperty(event, "code", {
          value: "Space",
          configurable
        });
      }
    }
    if (event.metaKey && !event.ctrlKey) {
      Object.defineProperty(event, "ctrlKey", returnTrueProp);
    }
    if (target && "offsetX" in event) {
      if (!Object.getOwnPropertyDescriptor(event, "borderOffsetX")) {
        Object.defineProperty(event, "borderOffsetX", {
          get: () => {
            return event.offsetX + (BrowserHelper.isSafari ? 0 : parseInt(target.ownerDocument.defaultView.getComputedStyle(target).getPropertyValue("border-left-width")));
          }
        });
      }
      if (!Object.getOwnPropertyDescriptor(event, "borderOffsetY")) {
        Object.defineProperty(event, "borderOffsetY", {
          get: () => {
            return event.offsetY + (BrowserHelper.isSafari ? 0 : parseInt(target.ownerDocument.defaultView.getComputedStyle(target).getPropertyValue("border-top-width")));
          }
        });
      }
    }
    if ((target === null || target === void 0 ? void 0 : target.nodeType) === Element.DOCUMENT_NODE && "clientX" in event) {
      const targetElement = DomHelper.elementFromPoint(event.clientX, event.clientY);
      Object.defineProperty(event, "target", {
        value: targetElement,
        configurable
      });
    }
    if ((target === null || target === void 0 ? void 0 : target.nodeType) === Element.TEXT_NODE) {
      const targetElement = event.target.parentElement;
      Object.defineProperty(event, "target", {
        value: targetElement,
        configurable
      });
    }
    if (((_event$relatedTarget = event.relatedTarget) === null || _event$relatedTarget === void 0 ? void 0 : _event$relatedTarget.nodeType) === Element.TEXT_NODE) {
      const relatedTargetElement = event.target.parentElement;
      Object.defineProperty(event, "relatedTarget", {
        value: relatedTargetElement,
        configurable
      });
    }
    if (type.startsWith("touch") && event.touches.length) {
      this.normalizeEvent(event);
    }
    return event;
  }
  static createHandler(element, eventName, handlerSpec, defaults) {
    const delay = handlerSpec.delay || defaults.delay, throttled = handlerSpec.throttled || defaults.throttled, block = handlerSpec.block || defaults.block, once = "once" in handlerSpec ? handlerSpec.once : defaults.once, capture = "capture" in handlerSpec ? handlerSpec.capture : defaults.capture, passive = "passive" in handlerSpec ? handlerSpec.passive : defaults.passive, delegate = "delegate" in handlerSpec ? handlerSpec.delegate : defaults.delegate, wrappedFn = handlerSpec.handler, expires = handlerSpec.expires, thisObj = handlerSpec.thisObj || defaults.thisObj, {
      rtlSource = thisObj
    } = thisObj || {};
    let handler = (event, ...args) => {
      if (EH.playingDemo && event.isTrusted) {
        return;
      }
      if (thisObj !== null && thisObj !== void 0 && thisObj.isDestroyed) {
        return;
      }
      event = EH.fixEvent(event, rtlSource === null || rtlSource === void 0 ? void 0 : rtlSource.rtl);
      handler.called = true;
      (typeof wrappedFn === "string" ? thisObj[wrappedFn] : wrappedFn).call(thisObj, event, ...args);
      delete event.target;
      delete event.relatedTarget;
      delete event.originalarget;
      delete event.key;
      delete event.code;
      delete event.ctrlKey;
      delete event.fixed;
    };
    if (block) {
      const wrappedFn2 = handler;
      let lastCallTime, lastTarget;
      handler = (e, ...args) => {
        const now2 = performance.now();
        if (!lastCallTime || e.target !== lastTarget || now2 - lastCallTime > block) {
          lastTarget = e.target;
          lastCallTime = now2;
          wrappedFn2(e, ...args);
        }
      };
    }
    if (delay != null) {
      const wrappedFn2 = handler, delayable = thisObj !== null && thisObj !== void 0 && thisObj.setTimeout ? thisObj : globalThis;
      handler = (...args) => {
        delayable.setTimeout(() => {
          wrappedFn2(...args);
        }, delay);
      };
    }
    if (throttled != null) {
      let alt2, buffer = throttled;
      if (throttled.buffer) {
        alt2 = (e) => {
          return throttled.alt.call(EH, EH.fixEvent(e, rtlSource === null || rtlSource === void 0 ? void 0 : rtlSource.rtl));
        };
        buffer = throttled.buffer;
      }
      if (thisObj !== null && thisObj !== void 0 && thisObj.isDelayable) {
        handler = thisObj.throttle(handler, {
          delay: buffer,
          throttled: alt2
        });
      } else {
        handler = FunctionHelper.createThrottled(handler, buffer, thisObj, null, alt2);
      }
    }
    if (once) {
      const wrappedFn2 = handler;
      handler = (...args) => {
        EH.removeEventListener(element, eventName, handler);
        wrappedFn2(...args);
      };
    }
    if (delegate) {
      const wrappedFn2 = handler;
      handler = (event, ...args) => {
        var _event$target$closest;
        event = EH.fixEvent(event, rtlSource === null || rtlSource === void 0 ? void 0 : rtlSource.rtl);
        const delegatedTarget = ((_event$target$closest = event.target.closest) === null || _event$target$closest === void 0 ? void 0 : _event$target$closest.call) && event.target.closest(delegate);
        if (!delegatedTarget) {
          return;
        }
        Object.defineProperty(event, "currentTarget", {
          get: () => delegatedTarget,
          configurable: true
        });
        wrappedFn2(event, ...args);
      };
    }
    if (handlerSpec.thisObj && handlerSpec.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, () => EH.removeEventListener(element, eventName, handler), thisObj);
    }
    handler.spec = {
      delay,
      throttled,
      block,
      once,
      thisObj,
      capture,
      expires,
      passive,
      delegate
    };
    return handler;
  }
  static removeEventListener(element, eventName, handler) {
    const {
      expires,
      timerId,
      thisObj,
      capture
    } = handler.spec;
    if (expires !== null && expires !== void 0 && expires.alt && timerId) {
      const delayable = thisObj !== null && thisObj !== void 0 && thisObj.isDelayable ? thisObj : globalThis;
      delayable[typeof expires.delay === "number" ? "clearTimeout" : "cancelAnimationFrame"](timerId);
    }
    element.removeEventListener(eventName, handler, capture);
  }
  static onTransitionEnd({
    element,
    animationName,
    property,
    handler,
    mode = animationName ? "animation" : "transition",
    duration = DomHelper[`get${mode === "transition" ? "Property" : ""}${StringHelper.capitalize(mode)}Duration`](element, property),
    thisObj = globalThis,
    args = [],
    timerSource,
    runOnDestroy
  }) {
    let timerId;
    timerSource = timerSource || (thisObj.isDelayable ? thisObj : globalThis);
    const callbackArgs = [element, property, ...args], doCallback = () => {
      detacher2();
      if (!thisObj.isDestroyed) {
        if (thisObj.callback) {
          thisObj.callback(handler, thisObj, callbackArgs);
        } else {
          handler.apply(thisObj, callbackArgs);
        }
      }
    }, detacher2 = EH.on({
      element,
      [`${mode}end`]({
        animationName: endedAnimation,
        propertyName,
        target
      }) {
        if (target === element) {
          if (propertyName === property || endedAnimation !== null && endedAnimation !== void 0 && endedAnimation.match(animationName)) {
            if (timerId) {
              timerSource.clearTimeout(timerId);
              timerId = null;
            }
            doCallback();
          }
        }
      }
    });
    if (duration != null) {
      timerId = timerSource.setTimeout(doCallback, duration + 50, "onTransitionEnd", runOnDestroy);
    }
    return detacher2;
  }
  static async waitForTransitionEnd(config) {
    return new Promise((resolve) => {
      config.handler = resolve;
      EventHelper.onTransitionEnd(config);
    });
  }
  static createContextMenuWrapper(handler, thisObj) {
    return (event) => {
      if (event.touches.length === 1) {
        if (event.target.closest("[data-feature]")) {
          return;
        }
        const tapholdStartTouch = event.touches[0], tapholdTimer = setTimeout(() => {
          touchMoveRemover();
          const contextmenuEvent = new MouseEvent("contextmenu", tapholdStartTouch);
          Object.defineProperty(contextmenuEvent, "target", {
            get() {
              return tapholdStartTouch.target;
            }
          });
          if (typeof handler === "string") {
            handler = thisObj[handler];
          }
          contextmenuEvent.browserEvent = event;
          handler.call(thisObj, contextmenuEvent);
          EH.contextMenuTouchId = tapholdStartTouch.identifier;
        }, EH.longPressTime), onMoveOrPointerUp = ({
          clientX,
          clientY,
          type
        }) => {
          let cancel = type === "touchend" || type === "pointerup";
          if (!cancel) {
            const deltaX = Math.abs(clientX - tapholdStartTouch.clientX), deltaY = Math.abs(clientY - tapholdStartTouch.clientY);
            cancel = deltaX >= longpressMoveThreshold || deltaY >= longpressMoveThreshold;
          }
          if (cancel) {
            EH.contextMenuTouchId = null;
            touchMoveRemover();
            clearTimeout(tapholdTimer);
          }
        }, touchMoveRemover = EH.on({
          element: document,
          touchmove: onMoveOrPointerUp,
          touchend: onMoveOrPointerUp,
          pointermove: onMoveOrPointerUp,
          pointerup: onMoveOrPointerUp,
          capture: true
        });
      }
    };
  }
  static createDblClickWrapper(element, handler, thisObj) {
    let startId, secondListenerDetacher, tapholdTimer;
    return () => {
      if (!secondListenerDetacher) {
        secondListenerDetacher = EH.on({
          element,
          touchstart: (secondStart) => {
            startId = secondStart.changedTouches[0].identifier;
            secondStart.preventDefault();
          },
          touchend: (secondClick) => {
            if (secondClick.changedTouches[0].identifier === startId) {
              secondClick.preventDefault();
              clearTimeout(tapholdTimer);
              startId = secondListenerDetacher = null;
              const targetRect = Rectangle.from(secondClick.changedTouches[0].target, null, true), offsetX = secondClick.changedTouches[0].pageX - targetRect.x, offsetY = secondClick.changedTouches[0].pageY - targetRect.y, dblclickEventConfig = Object.assign({
                browserEvent: secondClick
              }, secondClick), dblclickEvent = new MouseEvent("dblclick", dblclickEventConfig);
              Object.defineProperties(dblclickEvent, {
                target: {
                  value: secondClick.target
                },
                offsetX: {
                  value: offsetX
                },
                offsetY: {
                  value: offsetY
                }
              });
              if (typeof handler === "string") {
                handler = thisObj[handler];
              }
              handler.call(thisObj, dblclickEvent);
            }
          },
          once: true
        });
        tapholdTimer = setTimeout(() => {
          secondListenerDetacher();
          startId = secondListenerDetacher = null;
        }, EH.dblClickTime);
      }
    };
  }
  static toSpecialKey(value, defaultValue2 = "ctrlKey") {
    let result = false;
    if (value === true) {
      result = defaultValue2;
    } else if (typeof value === "string") {
      value = value.toLowerCase();
      if (value.match(specialKeyRe)) {
        result = `${value}Key`;
      }
    }
    return result;
  }
  static specialKeyFromEventKey(code) {
    return specialKeys[code] || "";
  }
};
_defineProperty(EventHelper, "eventNameMap", {
  mousedown: "MouseDown",
  mouseup: "MouseUp",
  click: "Click",
  dblclick: "DblClick",
  contextmenu: "ContextMenu",
  mouseover: "MouseOver",
  mouseout: "MouseOut",
  keyup: "KeyUp",
  keydown: "KeyDown",
  keypress: "KeyPress"
});
var EH = EventHelper;
EH.longPressTime = 500;
EH.dblClickTime = 300;
EH.globalListenerDetacher = EH.on({
  element: document,
  capture: true,
  passive: true,
  pointerdown({
    target
  }) {
    var _rootEl$classList;
    const rootEl = DomHelper.getRootElement(target);
    DomHelper.usingKeyboard = false;
    (_rootEl$classList = rootEl.classList) === null || _rootEl$classList === void 0 ? void 0 : _rootEl$classList.remove("b-using-keyboard");
    DomHelper.removeClsGlobally(rootEl, "b-using-keyboard");
  },
  keydown({
    target,
    key
  }) {
    if (!ignoreModifierKeys[key]) {
      DomHelper.usingKeyboard = true;
      const rootElement = DomHelper.getRootElement(target);
      if (rootElement.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        Array.from(rootElement.children).forEach((node) => {
          if (node.matches(".b-outer")) {
            node.classList.add("b-using-keyboard");
          }
        });
      } else {
        rootElement.classList.add("b-using-keyboard");
      }
    }
  }
});
if (BrowserHelper.isTouchDevice) {
  EH.on({
    element: document,
    touchmove: (event) => {
      if (event.target.closest(".b-dragging")) {
        event.preventDefault();
      }
    },
    passive: false,
    capture: true
  });
}
EventHelper._$name = "EventHelper";
var DEFAULT_FONT_SIZE = 14;
var t0t0 = {
  align: "t0-t0"
};
var ELEMENT_NODE = Node.ELEMENT_NODE;
var TEXT_NODE = Node.TEXT_NODE;
var {
  isObject: isObject$1
} = ObjectHelper;
var numberRe = /[+-]?\d*\.?\d+[eE]?-?\d*/g;
var numberReSrc = numberRe.source;
var translateMatrix2dRe = new RegExp(`matrix\\((?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(${numberReSrc}),\\s?(${numberReSrc})`);
var translateMatrix3dRe = new RegExp(`matrix3d\\((?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(-?\\d*),\\s?(-?\\d*)`);
var translateMatrixRe = new RegExp(`(?:${translateMatrix2dRe.source})|(?:${translateMatrix3dRe.source})`);
var pxTtranslateXRe = new RegExp(`translate(3d|X)?\\((${numberReSrc})px(?:,\\s?(${numberReSrc})px)?`);
var pxTtranslateYRe = new RegExp(`translate(3d|Y)?\\((${numberReSrc})px(?:,\\s?(${numberReSrc})px)?`);
var whiteSpaceRe = /\s+/;
var semicolonRe = /\s*;\s*/;
var colonRe = /\s*:\s*/;
var digitsRe$1 = /^-?((\d+(\.\d*)?)|(\.?\d+))$/;
var elementPropKey = "$bryntum";
var elementCreateExpandos = {
  elementData: "",
  for: "htmlFor",
  retainElement: ""
};
var elementCreateProperties = {
  tag: 1,
  html: 1,
  text: 1,
  children: 1,
  tooltip: 1,
  style: 1,
  dataset: 1,
  parent: 1,
  nextSibling: 1,
  ns: 1,
  reference: 1,
  class: 1,
  className: 1,
  unmatched: 1,
  onlyChildren: 1,
  listeners: 1,
  compareHtml: 1,
  syncOptions: 1,
  keepChildren: 1
};
var styleIgnoreProperties = {
  length: 1,
  parentRule: 1,
  style: 1
};
var nativeEditableTags = {
  INPUT: 1,
  TEXTAREA: 1
};
var nativeFocusableTags = {
  BUTTON: 1,
  IFRAME: 1,
  EMBED: 1,
  INPUT: 1,
  OBJECT: 1,
  SELECT: 1,
  TEXTAREA: 1,
  BODY: 1
};
var win = globalThis;
var doc = document;
var emptyObject$5 = Object.freeze({});
var arraySlice$1 = Array.prototype.slice;
var immediatePromise$5 = Promise.resolve();
var fontProps = ["font-size", "font-size-adjust", "font-style", "font-weight", "font-family", "font-kerning", "font-stretch", "line-height", "text-transform", "text-decoration", "letter-spacing", "word-break"];
var isHiddenWidget = (e) => e._hidden;
var parentNode = (el) => el.parentNode || el.host;
var mergeChildren = (dest, src, options) => {
  if (options.key === "children") {
    return ObjectHelper.mergeItems(dest, src, options);
  }
  return ObjectHelper.blend(dest, src, options);
};
var isVisible = (e) => {
  const style = e.ownerDocument.defaultView.getComputedStyle(e);
  return style.getPropertyValue("display") !== "none" && style.getPropertyValue("visibility") !== "hidden";
};
var getRootNode = doc.documentElement.getRootNode ? (el) => el.getRootNode() : (el) => {
  while (el.parentNode)
    el = el.parentNode;
  return el;
};
var isShadowRoot = (el) => el.host && el.host instanceof Element;
var hasLayout = (el) => el && (el === doc.body || Boolean(el.offsetParent) || (el.ownerDocument.defaultView && "offsetParent" in el && DomHelper.getStyleValue(el, "position") !== "fixed" ? el.offsetParent : hasLayout(el.parentNode)));
var isInDocument = (el) => el && (doc.body.contains(el) || (root = getRootNode(el)) && isShadowRoot(root) && isInDocument(root.host));
var elementOrConfigToElement = (elementOrConfig) => {
  if (elementOrConfig instanceof Node) {
    return elementOrConfig;
  }
  if (typeof elementOrConfig === "string") {
    return DH.createElementFromTemplate(elementOrConfig);
  }
  return DH.createElement(elementOrConfig);
};
var canonicalStyles = /* @__PURE__ */ Object.create(null);
var canonicalizeStyle = (name, hasUnit) => {
  const entry = canonicalStyles[name] || [StringHelper.hyphenate(name), hasUnit];
  if (!canonicalStyles[name]) {
    canonicalStyles[entry[0]] = canonicalStyles[name] = entry;
  }
  return entry;
};
var getOffsetParent = (node) => node.ownerSVGElement ? node.ownerSVGElement.parentNode : node.offsetParent;
var slideInAnimationName = /b-slide-in-from-\w+/;
["top", "right", "bottom", "left", "width", "height", "maxWidth", "maxHeight", "minWidth", "minHeight", "borderSpacing", "borderWidth", "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth", "marginTop", "marginRight", "marginBottom", "marginLeft", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "fontSize", "letterSpacing", "lineHeight", "outlineWidth", "textIndent", "wordSpacing"].forEach((name) => canonicalizeStyle(name, true));
var scrollBarWidth = null;
var idCounter = 0;
var themeInfo = null;
var root;
var templateElement;
var htmlParser;
var scrollBarMeasureElement;
var DomHelper = class {
  static async slideIn(element, direction = 1) {
    const cls = `b-slide-in-${direction > 0 ? "next" : "previous"}`, {
      classList
    } = element, {
      style
    } = element.parentNode, {
      overflow,
      overflowX,
      overflowY
    } = style;
    style.overflow = "hidden";
    classList.add(cls);
    await EventHelper.waitForTransitionEnd({
      element,
      animationName: slideInAnimationName
    });
    style.overflow = overflow;
    style.overflowX = overflowX;
    style.overflowY = overflowY;
    classList.remove(cls);
  }
  static isFocusable(element, skipAccessibilityCheck = false) {
    if (!skipAccessibilityCheck) {
      if (!DH.isVisible(element) || DH.Widget.fromElement(element, isHiddenWidget)) {
        return false;
      }
    }
    const nodeName = element.nodeName;
    return nativeFocusableTags[nodeName] || (nodeName === "A" || nodeName === "LINK") && !!element.href || element.getAttribute("tabIndex") != null || element.contentEditable === "true";
  }
  static isEditable(element) {
    return element.isContentEditable || nativeEditableTags[element.nodeName];
  }
  static isInView(target, whole = false, caller) {
    if (!hasLayout(target)) {
      return false;
    }
    const positioned = (caller === null || caller === void 0 ? void 0 : caller.positioned) && DomHelper.getStyleValue(caller.element, "position") !== "fixed", docRect = Rectangle.from(globalThis), method = whole ? "contains" : "intersect", cOp = positioned && caller.element.offsetParent, cOpR = positioned && Rectangle.from(cOp);
    docRect.height = doc.scrollingElement.scrollHeight;
    if (target === doc.body) {
      return docRect;
    }
    const result = this.getViewportIntersection(target, docRect, method);
    if (result && positioned) {
      result.translate(doc.scrollingElement.scrollLeft, doc.scrollingElement.scrollTop);
    }
    return positioned && result ? result.translate(-cOpR.x + cOp.scrollLeft, -cOpR.y + cOp.scrollTop) : result;
  }
  static getViewportIntersection(target, docRect, method) {
    const {
      parentNode: parentNode2
    } = target, {
      parentElement
    } = parentNode2.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? target.getRootNode().host : target, peStyle = parentElement.ownerDocument.defaultView.getComputedStyle(parentElement), parentScroll = peStyle.overflowX !== "visible" || peStyle.overflowY !== "visible", offsetParent = getOffsetParent(target);
    let result = Rectangle.from(target, null, true);
    for (let viewport = parentScroll ? target.parentNode : offsetParent; result && viewport !== doc.documentElement; viewport = viewport.parentNode) {
      if (viewport.nodeType === Node.DOCUMENT_FRAGMENT_NODE && viewport.host) {
        viewport = viewport.host.parentNode;
      }
      const isTop = viewport === doc.body, style = viewport.ownerDocument.defaultView.getComputedStyle(viewport), viewportRect = isTop ? docRect : Rectangle.inner(viewport, null, true);
      if (isTop || style.overflow !== "visible") {
        result = viewportRect[method](result, false, true);
      }
    }
    return result;
  }
  static isVisible(element) {
    const document2 = element.ownerDocument;
    for (; element; element = parentNode(element)) {
      if (element === document2) {
        return true;
      }
      if (element.nodeType === element.ELEMENT_NODE && !isVisible(element)) {
        return false;
      }
    }
    return false;
  }
  static isDOMEvent(event) {
    return event instanceof Event;
  }
  static merge(dest, ...sources) {
    return ObjectHelper.blend(dest, sources, {
      merge: mergeChildren
    });
  }
  static normalizeChildren(domConfig, namedChildren, ignoreRefs) {
    var _domConfig$syncOption;
    let children = domConfig === null || domConfig === void 0 ? void 0 : domConfig.children, child, i, name, kids, ref;
    if (domConfig !== null && domConfig !== void 0 && (_domConfig$syncOption = domConfig.syncOptions) !== null && _domConfig$syncOption !== void 0 && _domConfig$syncOption.ignoreRefs) {
      ignoreRefs = true;
    }
    if (children && !(domConfig instanceof Node)) {
      if (Array.isArray(children)) {
        for (i = 0; i < children.length; ++i) {
          DH.normalizeChildren(children[i], namedChildren, ignoreRefs);
        }
      } else {
        kids = children;
        domConfig.children = children = [];
        for (name in kids) {
          var _child;
          child = kids[name];
          if ((_child = child) !== null && _child !== void 0 && _child.isWidget) {
            child = child.element;
          }
          ref = !name.startsWith("$") && !DH.isElement(child);
          ref && (namedChildren === null || namedChildren === void 0 ? void 0 : namedChildren(name, !ignoreRefs));
          if (child) {
            if (!(child instanceof Node)) {
              if (child.reference === false) {
                delete child.reference;
              } else if (ref && typeof child !== "string") {
                child.reference = name;
              }
              DH.normalizeChildren(child, namedChildren, ignoreRefs);
            }
            children.push(child);
          }
        }
      }
    }
    return domConfig;
  }
  static roundPx(px, devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const multiplier = 1 / devicePixelRatio;
    return Math.round(px / multiplier) * multiplier;
  }
  static floorPx(px, devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const multiplier = 1 / devicePixelRatio;
    return Math.floor(px * multiplier) / multiplier;
  }
  static isCustomElement(element) {
    return Boolean(element === null || element === void 0 ? void 0 : element.shadowRoot);
  }
  static elementFromPoint(x, y) {
    let el = document.elementFromPoint(x, y);
    if (DH.isCustomElement(el)) {
      el = el.shadowRoot.elementFromPoint(x, y) || el;
    }
    return el;
  }
  static childFromPoint(el, x, y, parent = el) {
    const p = y == null ? x : new Rectangle(x, y, 0, 0);
    let result = null;
    Array.from(el.children).some((el2) => {
      if (Rectangle.from(el2, parent).contains(p)) {
        result = el2.children.length && DH.childFromPoint(el2, p, null, parent) || el2;
        return true;
      }
    });
    return result;
  }
  static unitize(name, value, defaultUnit = "px") {
    const [trueName, hasUnits] = canonicalizeStyle(name);
    if (value != null) {
      value = String(value);
      value = hasUnits && digitsRe$1.test(value) ? value + defaultUnit : value;
    }
    return [trueName, value];
  }
  static get activeElement() {
    let el = document.activeElement;
    while (el.shadowRoot) {
      el = el.shadowRoot.activeElement;
    }
    return el;
  }
  static getActiveElement(element) {
    var _element, _element2;
    if ((_element = element) !== null && _element !== void 0 && _element.isWidget) {
      element = element.element;
    }
    let el = (((_element2 = element) === null || _element2 === void 0 ? void 0 : _element2.getRootNode()) || document).activeElement;
    while ((_el = el) !== null && _el !== void 0 && _el.shadowRoot) {
      var _el;
      el = el.shadowRoot.activeElement;
    }
    return el;
  }
  static getRootElement(element) {
    var _element$getRootNode;
    const root2 = (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element), {
      nodeType
    } = root2;
    return nodeType === Node.DOCUMENT_NODE ? root2.body : nodeType === Node.DOCUMENT_FRAGMENT_NODE ? root2 : element.ownerDocument.contains(element) ? element.ownerDocument.body : null;
  }
  static getOutermostElement(element) {
    var _element$getRootNode2, _element3;
    const root2 = (_element$getRootNode2 = (_element3 = element).getRootNode) === null || _element$getRootNode2 === void 0 ? void 0 : _element$getRootNode2.call(_element3);
    if (root2 !== null && root2 !== void 0 && root2.body) {
      return root2 === null || root2 === void 0 ? void 0 : root2.body;
    }
    while (element.parentNode !== root2 && element.parentNode) {
      element = element.parentNode;
    }
    return element;
  }
  static isValidFloatRootParent(target) {
    return target === document.body || target.constructor.name === "ShadowRoot";
  }
  static getId(element) {
    return element.id || (element.id = "b-element-" + ++idCounter);
  }
  static getCommonAncestor(from, to) {
    if (from === to) {
      return from;
    }
    while (from && !((_from = (_from2 = from)[from.isWidget ? "owns" : "contains"]) !== null && _from !== void 0 && _from.call(_from2, to) || from === to)) {
      var _from, _from2;
      from = from.owner || from.parentNode;
    }
    return from;
  }
  static getElement(elementOrSelector) {
    if (elementOrSelector instanceof Element) {
      return elementOrSelector;
    }
    return doc.querySelector(elementOrSelector);
  }
  static setAttributes(elementOrSelector, attributes) {
    const element = DH.getElement(elementOrSelector);
    if (element && attributes) {
      for (const key in attributes) {
        if (attributes[key] == null) {
          element.removeAttribute(key);
        } else {
          element.setAttribute(key, attributes[key]);
        }
      }
    }
  }
  static setLength(element, style, value) {
    if (arguments.length === 1) {
      var _element4;
      value = typeof element === "number" ? `${element}px` : (_element4 = element) !== null && _element4 !== void 0 ? _element4 : "";
    } else {
      var _value;
      element = DH.getElement(element);
      value = element.style[style] = typeof value === "number" ? `${value}px` : (_value = value) !== null && _value !== void 0 ? _value : "";
    }
    return value;
  }
  static percentify(value, digits = 2) {
    const mult = Math.pow(10, digits);
    return value == null || value === "" || isNaN(value) ? "" : `${Math.round(value * mult) / mult}%`;
  }
  static getChild(element, selector) {
    return element.querySelector(":scope>" + selector);
  }
  static hasChild(element, selector) {
    return DH.getChild(element, selector) != null;
  }
  static children(element, selector) {
    if (selector[0] === ">" || selector.startsWith("# ")) {
      if (selector[0] === "#") {
        selector = selector.substr(2);
      }
      selector = ":scope " + selector;
    }
    return Array.from(element.querySelectorAll(selector));
  }
  static getChildElementCount(element) {
    return element.childElementCount;
  }
  static down(element, selector) {
    if (!element) {
      return null;
    }
    if (element.matches && element.matches(selector)) {
      return element;
    }
    selector = ":scope " + selector;
    return element.querySelector(selector);
  }
  static isDescendant(parentElement, childElement) {
    const parentRoot = DH.getRootElement(parentElement), childRoot = DH.getRootElement(childElement);
    if (childRoot && parentRoot !== childRoot && childRoot.host) {
      return DH.isDescendant(parentRoot, childRoot.host);
    }
    return parentElement.contains(childElement);
  }
  static getEventElement(event, elementName = "target") {
    return !event || DH.isElement(event) ? event : event[elementName];
  }
  static isElement(value) {
    return (value === null || value === void 0 ? void 0 : value.nodeType) === document.ELEMENT_NODE && DH.isNode(value);
  }
  static isReactElement(element) {
    return (element === null || element === void 0 ? void 0 : element.$$typeof) === Symbol.for("react.element");
  }
  static isNode(value) {
    return Boolean(value) && typeof value.nodeType === "number" && !isObject$1(value);
  }
  static forEachSelector(element, selector, fn) {
    if (typeof element === "string") {
      throw new Error("DomHelper.forEachSelector must provide a root element context (for shadow root scenario)");
    }
    DH.children(element, selector).forEach(fn);
  }
  static forEachChild(element, fn) {
    Array.from(element.children).forEach(fn);
  }
  static removeEachSelector(element, selector) {
    DH.forEachSelector(element, selector, (child) => child.remove());
  }
  static removeClsGlobally(element, ...classes) {
    classes.forEach((cls) => DH.forEachSelector(element, "." + cls, (child) => child.classList.remove(cls)));
  }
  static isOrphaned(element) {
    return !isInDocument(element);
  }
  static up(element, selector) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.up() deprecated, use native `element.closest()` instead");
    return element.closest(selector);
  }
  static getAncestor(element, possibleAncestorParents, outerElement = null) {
    let found = false, ancestor, parent = element;
    possibleAncestorParents = ArrayHelper.asArray(possibleAncestorParents);
    while (parent = parent.parentElement) {
      if (possibleAncestorParents.includes(parent)) {
        found = true;
        break;
      }
      if (outerElement && parent === outerElement)
        break;
      ancestor = parent;
    }
    if (!found)
      return null;
    return ancestor || element;
  }
  static getParents(element) {
    const parents = [];
    while (element.parentElement) {
      parents.push(element.parentElement);
      element = element.parentElement;
    }
    return parents;
  }
  static makeValidId(id, replaceValue = "") {
    return StringHelper.makeValidDomId(id, replaceValue);
  }
  static createElement(config = {}, options) {
    var _options, _options$callback, _config$dataset;
    let returnAll = options, element, i, ignoreChildRefs, ignoreRefOption, ignoreRefs, key, name, value, refOwner, refs, syncIdField;
    if (typeof returnAll === "boolean") {
      throw new Error("Clean up");
    } else if (options) {
      ignoreRefs = options.ignoreRefs;
      refOwner = options.refOwner;
      refs = options.refs;
      returnAll = options.returnAll;
      syncIdField = options.syncIdField;
      if (ignoreRefs) {
        ignoreChildRefs = true;
        ignoreRefs = ignoreRefs !== "children";
      }
    }
    if (typeof config.parent === "string") {
      config.parent = document.getElementById(config.parent);
    }
    const parent = config.parent || config.nextSibling && config.nextSibling.parentNode, {
      dataset,
      html,
      reference,
      syncOptions,
      text
    } = config;
    if (syncOptions) {
      syncIdField = syncOptions.syncIdField || syncIdField;
      ignoreRefOption = syncOptions.ignoreRefs;
      if (ignoreRefOption) {
        ignoreChildRefs = true;
        ignoreRefs = ignoreRefOption !== "children";
        options = _objectSpread2(_objectSpread2({}, options), {}, {
          ignoreRefs: true
        });
      }
    }
    if (ignoreRefs) {
      refOwner = null;
    }
    if (config.ns) {
      element = doc.createElementNS(config.ns, config.tag || "svg");
    } else {
      element = doc.createElement(config.tag || "div");
    }
    if (text != null) {
      DH.setInnerText(element, text);
    } else if (html != null) {
      if (html instanceof DocumentFragment) {
        element.appendChild(html);
      } else {
        element.innerHTML = html;
      }
    }
    if (config.tooltip) {
      DH.Widget.attachTooltip(element, config.tooltip);
    }
    if (config.style) {
      DH.applyStyle(element, config.style);
    }
    if (dataset) {
      for (name in dataset) {
        value = dataset[name];
        if (value != null) {
          element.dataset[name] = value;
        }
      }
    }
    if (parent) {
      this.addChild(parent, element, config.nextSibling);
    }
    if (refOwner) {
      element.$refOwnerId = refOwner.id;
    }
    if (reference && !ignoreRefs) {
      if (refOwner) {
        element.$reference = reference;
        refOwner.attachRef(reference, element, config);
      } else {
        if (!refs) {
          options = Object.assign({}, options);
          options.refs = refs = {};
        }
        refs[reference] = element;
        element.setAttribute("data-reference", reference);
      }
    }
    const className = config.className || config.class, keys = Object.keys(config);
    if (className) {
      element.setAttribute("class", DomClassList.normalize(className));
    }
    for (i = 0; i < keys.length; ++i) {
      name = keys[i];
      value = config[name];
      if ((key = elementCreateExpandos[name]) != null) {
        element[key || name] = value;
      } else if (!elementCreateProperties[name] && name && value != null) {
        element.setAttribute(name, value);
      }
    }
    if (!config["aria-hidden"] && !config.role && !config.tabIndex && !DomHelper.isFocusable(element, true) && !element.htmlFor) {
      element.setAttribute("role", "presentation");
    }
    (_options = options) === null || _options === void 0 ? void 0 : (_options$callback = _options.callback) === null || _options$callback === void 0 ? void 0 : _options$callback.call(_options, {
      action: "newElement",
      domConfig: config,
      targetElement: element,
      syncId: refOwner ? reference : options.syncIdField && ((_config$dataset = config.dataset) === null || _config$dataset === void 0 ? void 0 : _config$dataset[options.syncIdField])
    });
    if (returnAll === true) {
      options.returnAll = returnAll = [element];
    } else if (Array.isArray(returnAll)) {
      returnAll.push(element);
    }
    if (config.children) {
      if (syncIdField) {
        element.syncIdMap = {};
      }
      config.children.forEach((child) => {
        if (child) {
          if (typeof child === "string") {
            const textNode = document.createTextNode(child);
            if (refOwner) {
              textNode.$refOwnerId = refOwner.id;
            }
            element.appendChild(textNode);
          } else if (isNaN(child.nodeType)) {
            var _config$syncOptions$i, _config$syncOptions, _child$dataset;
            child.parent = element;
            if (!child.ns && config.ns) {
              child.ns = config.ns;
            }
            const childElement = DH.createElement(child, _objectSpread2(_objectSpread2({}, options), {}, {
              ignoreRefs: (_config$syncOptions$i = (_config$syncOptions = config.syncOptions) === null || _config$syncOptions === void 0 ? void 0 : _config$syncOptions.ignoreRef) !== null && _config$syncOptions$i !== void 0 ? _config$syncOptions$i : ignoreChildRefs
            })), syncId = (_child$dataset = child.dataset) === null || _child$dataset === void 0 ? void 0 : _child$dataset[syncIdField];
            if (syncId != null) {
              element.syncIdMap[syncId] = childElement;
            }
            delete child.parent;
          } else {
            element.appendChild(child);
          }
        }
      });
    }
    element.lastDomConfig = config;
    return refs || returnAll || element;
  }
  static createElementFromTemplate(template, options = emptyObject$5) {
    const {
      array,
      raw,
      fragment
    } = options;
    let result;
    if (DH.supportsTemplate) {
      (templateElement || (templateElement = doc.createElement("template"))).innerHTML = template;
      result = templateElement.content;
      if (fragment) {
        return result.cloneNode(true);
      }
    } else {
      result = (htmlParser || (htmlParser = new DOMParser())).parseFromString(template, "text/html").body;
      if (fragment) {
        const nodes = result.childNodes;
        result = document.createDocumentFragment();
        while (nodes.length) {
          result.appendChild(nodes[0]);
        }
        return result;
      }
    }
    if (raw) {
      result = result.childNodes;
    } else {
      result = result.children;
    }
    return result.length === 1 && !array ? result[0] : arraySlice$1.call(result);
  }
  static triggerMouseEvent(targetElement, type = "contextmenu") {
    const isInView = this.isInView(targetElement), targetRect = isInView || Rectangle.from(targetElement), targetPoint = targetRect.center, contextmenuEvent = new MouseEvent(type, {
      clientX: targetPoint.x,
      clientY: targetPoint.y,
      bubbles: true
    });
    targetElement.dispatchEvent(contextmenuEvent);
  }
  static insertFirst(into, element) {
    if (element && element.nodeType !== ELEMENT_NODE && element.tag) {
      element = DH.createElement(element);
    }
    return into.insertBefore(element, into.firstElementChild);
  }
  static insertBefore(into, element, beforeElement) {
    if (element && element.nodeType !== ELEMENT_NODE && element.tag) {
      element = DH.createElement(element);
    }
    return beforeElement ? into.insertBefore(element, beforeElement) : DH.insertFirst(into, element);
  }
  static insertAt(parentElement, newElement, index) {
    const siblings = Array.from(parentElement.children);
    if (index >= siblings.length) {
      return DH.append(parentElement, newElement);
    }
    const beforeElement = siblings[index];
    return DH.insertBefore(parentElement, newElement, beforeElement);
  }
  static append(parentElement, elementOrConfig) {
    if (elementOrConfig.forEach) {
      if (Array.isArray(elementOrConfig)) {
        elementOrConfig = elementOrConfig.map((elementOrConfig2) => elementOrConfigToElement(elementOrConfig2));
      }
      if (parentElement.append) {
        parentElement.append(...elementOrConfig);
      } else {
        const docFrag = document.createDocumentFragment();
        elementOrConfig.forEach(function(child) {
          docFrag.appendChild(child);
        });
        parentElement.appendChild(docFrag);
      }
      return elementOrConfig;
    } else {
      return parentElement.appendChild(elementOrConfigToElement(elementOrConfig));
    }
  }
  static getTranslateX(element) {
    const transformStyle = element.style.transform;
    let matches = pxTtranslateXRe.exec(transformStyle);
    if (matches) {
      return parseFloat(matches[2]);
    } else {
      matches = translateMatrixRe.exec(transformStyle) || translateMatrixRe.exec(DH.getStyleValue(element, "transform"));
      return matches ? parseFloat(matches[1] || matches[3]) : 0;
    }
  }
  static getTranslateY(element) {
    const transformStyle = element.style.transform;
    let matches = pxTtranslateYRe.exec(transformStyle);
    if (matches) {
      const y = parseFloat(matches[matches[1] === "Y" ? 2 : 3]);
      return isNaN(y) ? 0 : y;
    } else {
      matches = translateMatrixRe.exec(transformStyle) || translateMatrixRe.exec(DH.getStyleValue(element, "transform"));
      return matches ? parseFloat(matches[2] || matches[4]) : 0;
    }
  }
  static getTranslateXY(element) {
    return [DH.getTranslateX(element), DH.getTranslateY(element)];
  }
  static getOffsetX(element, container = null) {
    return container ? element.getBoundingClientRect().left - container.getBoundingClientRect().left : element.offsetLeft;
  }
  static getOffsetY(element, container = null) {
    return container ? element.getBoundingClientRect().top - container.getBoundingClientRect().top : element.offsetTop;
  }
  static getOffsetXY(element, container = null) {
    return [DH.getOffsetX(element, container), DH.getOffsetY(element, container)];
  }
  static focusWithoutScrolling(element) {
    function resetScroll(scrollHierarchy) {
      scrollHierarchy.forEach(({
        element: element2,
        scrollLeft,
        scrollTop
      }) => {
        if (element2.scrollLeft !== scrollLeft) {
          element2.scrollLeft = scrollLeft;
        }
        if (element2.scrollTop !== scrollTop) {
          element2.scrollTop = scrollTop;
        }
      });
    }
    const preventScrollSupported = !BrowserHelper.isSafari;
    if (preventScrollSupported) {
      element.focus({
        preventScroll: true
      });
    } else {
      const parents = DH.getParents(element), scrollHierarchy = parents.map((parent) => ({
        element: parent,
        scrollLeft: parent.scrollLeft,
        scrollTop: parent.scrollTop
      }));
      element.focus();
      setTimeout(() => resetScroll(scrollHierarchy), 0);
    }
  }
  static getPageX(element) {
    return element.getBoundingClientRect().left + win.pageXOffset;
  }
  static getPageY(element) {
    return element.getBoundingClientRect().top + win.pageYOffset;
  }
  static getExtremalSizePX(element, style) {
    const prop = StringHelper.hyphenate(style), measure = prop.split("-")[1];
    let value = DH.getStyleValue(element, prop);
    if (/%/.test(value)) {
      if (element.parentElement) {
        value = parseInt(DH.getStyleValue(element.parentElement, measure), 10);
      } else {
        value = NaN;
      }
    } else {
      value = parseInt(value, 10);
    }
    return value;
  }
  static setScale(element, scaleX, scaleY = scaleX) {
    const t = DH.getStyleValue(element, "transform").split(/,\s*/);
    if (t.length > 1) {
      if (t[0].startsWith("matrix3d")) {
        t[0] = `matrix3d(${scaleX}`;
        t[5] = scaleY;
      } else {
        t[0] = `matrix(${scaleX}`;
        t[3] = scaleY;
      }
      element.style.transform = t.join(",");
    } else {
      element.style.transform = `scale(${scaleX}, ${scaleY})`;
    }
  }
  static setTranslateX(element, x) {
    const t = DH.getStyleValue(element, "transform").split(/,\s*/);
    x = DH.roundPx(x);
    if (t.length > 1) {
      t[t[0].startsWith("matrix3d") ? 12 : 4] = x;
      element.style.transform = t.join(",");
    } else {
      element.style.transform = `translateX(${x}px)`;
    }
  }
  static setTranslateY(element, y) {
    const t = DH.getStyleValue(element, "transform").split(/,\s*/);
    y = DH.roundPx(y);
    if (t.length > 1) {
      t[t[0].startsWith("matrix3d") ? 13 : 5] = y;
      element.style.transform = t.join(",") + ")";
    } else {
      element.style.transform = `translateY(${y}px)`;
    }
  }
  static setTop(element, y) {
    DH.setLength(element, "top", y);
  }
  static setLeft(element, x) {
    DH.setLength(element, "left", x);
  }
  static setTopLeft(element, y, x) {
    DH.setLength(element, "top", y);
    DH.setLength(element, "left", x);
  }
  static setRect(element, {
    x,
    y,
    width,
    height
  }) {
    DH.setTopLeft(element, y, x);
    DH.setLength(element, "width", width);
    DH.setLength(element, "height", height);
  }
  static setTranslateXY(element, x, y) {
    if (x == null) {
      return DH.setTranslateY(element, y);
    }
    if (y == null) {
      return DH.setTranslateX(element, x);
    }
    x = DH.roundPx(x);
    y = DH.roundPx(y);
    const t = DH.getStyleValue(element, "transform").split(/,\s*/), is3d = t[0].startsWith("matrix3d");
    if (t.length > 1) {
      t[is3d ? 12 : 4] = x;
      t[is3d ? 13 : 5] = y;
      element.style.transform = t.join(",") + ")";
    } else {
      element.style.transform = `translate(${x}px, ${y}px)`;
    }
  }
  static addTranslateX(element, x) {
    DH.setTranslateX(element, DH.getTranslateX(element) + x);
  }
  static addTranslateY(element, y) {
    DH.setTranslateY(element, DH.getTranslateY(element) + y);
  }
  static addLeft(element, x) {
    DH.setLeft(element, DH.getOffsetX(element) + x);
  }
  static addTop(element, y) {
    DH.setTop(element, DH.getOffsetY(element) + y);
  }
  static alignTo(element, target, alignSpec = t0t0, round2) {
    target = target instanceof Rectangle ? target : Rectangle.from(target, true);
    const elXY = DH.getTranslateXY(element), elRect = Rectangle.from(element, true);
    if (round2) {
      elRect.roundPx();
      target.roundPx();
    }
    const targetRect = elRect.alignTo(Object.assign(alignSpec, {
      target
    }));
    DH.setTranslateXY(element, elXY[0] + targetRect.x - elRect.x, elXY[1] + targetRect.y - elRect.y);
  }
  static getStyleValue(element, propName, inline, pseudo) {
    const styles = inline ? element.style : element.ownerDocument.defaultView.getComputedStyle(element, pseudo);
    if (Array.isArray(propName)) {
      const result = {};
      for (const prop of propName) {
        result[prop] = styles.getPropertyValue(StringHelper.hyphenate(prop));
      }
      return result;
    }
    return styles.getPropertyValue(StringHelper.hyphenate(propName));
  }
  static getEdgeSize(element, edgeStyle, edges) {
    const suffix = edgeStyle === "border" ? "-width" : "", ret = {
      raw: {}
    };
    for (const edge of ["top", "right", "bottom", "left"]) {
      if (!edges || edges.includes(edge[0])) {
        ret[edge] = parseFloat(ret.raw[edge] = DH.getStyleValue(element, `${edgeStyle}-${edge}${suffix}`));
      }
    }
    ret.width = (ret.left || 0) + (ret.right || 0);
    ret.height = (ret.top || 0) + (ret.bottom || 0);
    return ret;
  }
  static parseStyle(style) {
    if (typeof style === "string") {
      const styles = style.split(semicolonRe);
      style = {};
      for (let i = 0, {
        length
      } = styles; i < length; i++) {
        const propVal = styles[i].split(colonRe);
        style[propVal[0]] = propVal[1];
      }
    }
    return style || {};
  }
  static applyStyle(element, style, overwrite = false) {
    if (typeof style === "string") {
      if (overwrite) {
        if (style.length || element.style.cssText.length) {
          element.style.cssText = style;
        }
      } else {
        element.style.cssText += style;
      }
    } else if (style) {
      if (overwrite) {
        element.style.cssText = "";
      }
      if (style.style && typeof style.style !== "string") {
        style = ObjectHelper.assign({}, style, style.style);
      }
      let key, value;
      for (key in style) {
        if (!styleIgnoreProperties[key]) {
          [key, value] = DH.unitize(key, style[key]);
          if (value == null) {
            element.style.removeProperty(key);
          } else {
            element.style.setProperty(key, value);
          }
        }
      }
      if (typeof style.style === "string") {
        element.style.cssText += style.style;
      }
    }
  }
  static getCSSText(style) {
    if (typeof style === "string") {
      return style;
    }
    let cssText = "";
    for (const key in style) {
      if (!styleIgnoreProperties[key]) {
        cssText += `${StringHelper.hyphenate(key)}:${style[key]};`;
      }
    }
    return cssText;
  }
  static addClasses(element, classes) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.addClasses should be replaced by native classList.add");
    element.classList.add(...classes);
  }
  static removeClasses(element, classes) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.removeClasses should be replaced by native classList.remove");
    element.classList.remove(...classes);
  }
  static toggleClasses(element, classes, force = null) {
    classes = ArrayHelper.asArray(classes);
    if (force === true) {
      element.classList.add(...classes);
    } else if (force === false) {
      element.classList.remove(...classes);
    } else {
      classes.forEach((cls) => element.classList.toggle(cls));
    }
  }
  static addTemporaryClass(element, cls, duration, delayable = globalThis) {
    if (duration > 0) {
      element.classList.add(cls);
      delayable.setTimeout({
        fn: (cls2) => element.classList.remove(cls2),
        delay: duration,
        name: cls,
        args: [cls],
        cancelOutstanding: true
      });
    }
  }
  static getPropertyTransitionDuration(element, property) {
    const style = globalThis.getComputedStyle(element), properties = style.transitionProperty.split(", "), durations = style.transitionDuration.split(", "), index = properties.indexOf(StringHelper.hyphenate(property));
    let result;
    if (index !== -1) {
      result = parseFloat(durations[index]) * 1e3;
    }
    return result;
  }
  static getAnimationDuration(element) {
    return parseFloat(DH.getStyleValue(element, "animation-duration")) * 1e3;
  }
  static highlight(element, delayable = globalThis) {
    if (element instanceof Rectangle) {
      return element.highlight();
    }
    return new Promise((resolve) => {
      delayable.setTimeout(() => {
        element.classList.add("b-fx-highlight");
        delayable.setTimeout(() => {
          element.classList.remove("b-fx-highlight");
          resolve();
        }, 1e3);
      }, 0);
    });
  }
  static get scrollBarWidth() {
    if (scrollBarWidth === null && doc.body) {
      const element = scrollBarMeasureElement || (scrollBarMeasureElement = DH.createElement({
        parent: doc.body,
        style: "position:absolute;top:-9999em;height:100px;overflow-y:scroll"
      }));
      if (element.parentNode !== doc.body) {
        doc.body.appendChild(element);
      }
      scrollBarWidth = element.offsetWidth;
    }
    return scrollBarWidth;
  }
  static get scrollBarPadElement() {
    return {
      className: "b-yscroll-pad",
      children: [{
        className: "b-yscroll-pad-sizer"
      }]
    };
  }
  static resetScrollBarWidth() {
    scrollBarWidth = null;
  }
  static measureText(text, sourceElement, useHTML = false, parentElement = void 0) {
    const offScreenDiv = DH.getMeasureElement(sourceElement, parentElement);
    offScreenDiv[useHTML ? "innerHTML" : "innerText"] = text;
    const result = offScreenDiv.clientWidth;
    offScreenDiv.className = "";
    return result;
  }
  static measureSize(size, sourceElement, round2 = true) {
    if (!size) {
      return 0;
    }
    if (typeof size === "number") {
      return size;
    }
    if (!size.length) {
      return 0;
    }
    if (/^\d+(px)?$/.test(size)) {
      return parseInt(size);
    }
    if (sourceElement) {
      const offScreenDiv = DH.getMeasureElement(sourceElement);
      offScreenDiv.innerHTML = "";
      offScreenDiv.style.width = DH.setLength(size);
      const result = round2 ? offScreenDiv.offsetWidth : offScreenDiv.getBoundingClientRect().width;
      offScreenDiv.style.width = offScreenDiv.className = "";
      return result;
    }
    if (/^\d+em$/.test(size)) {
      return parseInt(size) * DEFAULT_FONT_SIZE;
    }
    return isNaN(size) ? 0 : parseInt(size);
  }
  static getMeasureElement(sourceElement, parentElement = doc.body) {
    const sourceElementStyle = win.getComputedStyle(sourceElement), offScreenDiv = parentElement.offScreenDiv = parentElement.offScreenDiv || DH.createElement({
      parent: parentElement,
      style: "position:fixed;top:-10000px;left:-10000px;visibility:hidden;contain:strict",
      className: "b-measure-element",
      children: [{
        style: "white-space:nowrap;display:inline-block;will-change:contents;width:auto;contain:none"
      }]
    }, {
      returnAll: true
    })[1];
    fontProps.forEach((prop) => {
      if (offScreenDiv.style[prop] !== sourceElementStyle[prop]) {
        offScreenDiv.style[prop] = sourceElementStyle[prop];
      }
    });
    offScreenDiv.className = sourceElement.className;
    if (offScreenDiv.parentElement.parentElement !== parentElement) {
      parentElement.appendChild(offScreenDiv.parentElement);
    }
    return offScreenDiv;
  }
  static stripTags(htmlString) {
    const parser = DH.$domParser || (DH.$domParser = new DOMParser()), doc2 = parser.parseFromString(htmlString, "text/html");
    return doc2.body.textContent;
  }
  static sync(sourceElement, targetElement) {
    if (typeof sourceElement === "string") {
      if (sourceElement === "") {
        targetElement.innerHTML = "";
        return;
      } else {
        sourceElement = DH.createElementFromTemplate(sourceElement);
      }
    }
    DH.performSync(sourceElement, targetElement);
    return targetElement;
  }
  static performSync(sourceElement, targetElement) {
    if (sourceElement.outerHTML !== targetElement.outerHTML) {
      DH.syncAttributes(sourceElement, targetElement);
      DH.syncContent(sourceElement, targetElement);
      DH.syncChildren(sourceElement, targetElement);
      return true;
    }
    return false;
  }
  static getSyncAttributes(element) {
    const attributes = {}, names = [];
    for (let i = 0; i < element.attributes.length; i++) {
      const attr = element.attributes[i];
      if (attr.specified) {
        const name = attr.name.toLowerCase();
        attributes[name] = attr.value;
        names.push(name);
      }
    }
    return {
      attributes,
      names
    };
  }
  static syncAttributes(sourceElement, targetElement) {
    const {
      attributes: sourceAttributes,
      names: sourceNames
    } = DH.getSyncAttributes(sourceElement), {
      attributes: targetAttributes,
      names: targetNames
    } = DH.getSyncAttributes(targetElement), hasDataset = sourceNames.includes("dataset"), toAdd = sourceNames.filter((attr) => !targetNames.includes(attr)), toRemove = targetNames.filter((attr) => !sourceNames.includes(attr) && (!hasDataset || !attr.startsWith("data-"))), toSync = sourceNames.filter((attr) => targetNames.includes(attr));
    if (toAdd.length > 0) {
      for (let i = 0; i < toAdd.length; i++) {
        const attr = toAdd[i];
        if (attr === "style") {
          DH.applyStyle(targetElement, sourceAttributes.style, true);
        } else if (attr === "dataset") {
          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        } else {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }
    if (toRemove.length > 0) {
      for (let i = 0; i < toRemove.length; i++) {
        targetElement.removeAttribute(toRemove[i]);
      }
    }
    if (toSync.length > 0) {
      for (let i = 0; i < toSync.length; i++) {
        const attr = toSync[i];
        if (attr === "style") {
          DH.applyStyle(targetElement, sourceAttributes.style, true);
        } else if (attr === "dataset") {
          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        } else if (attr === "class" && (sourceAttributes.class.isDomClassList || typeof sourceAttributes.class === "object")) {
          let classList;
          if (sourceAttributes.class.isDomClassList) {
            classList = sourceAttributes.class;
          } else {
            classList = new DomClassList(sourceAttributes.class);
          }
          if (!classList.isEqual(targetAttributes.class)) {
            targetElement.setAttribute("class", classList);
          }
        } else if (targetAttributes[attr] !== sourceAttributes[attr]) {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }
  }
  static syncContent(sourceElement, targetElement) {
    if (DH.getChildElementCount(sourceElement) === 0) {
      targetElement.innerText = sourceElement.innerText;
    }
  }
  static setInnerText(targetElement, text) {
    const {
      firstChild
    } = targetElement;
    if ((firstChild === null || firstChild === void 0 ? void 0 : firstChild.nodeType) === Element.TEXT_NODE) {
      firstChild.data = text;
    } else {
      targetElement.textContent = text;
    }
  }
  static syncChildren(sourceElement, targetElement) {
    const me = this, sourceNodes = arraySlice$1.call(sourceElement.childNodes), targetNodes = arraySlice$1.call(targetElement.childNodes);
    while (sourceNodes.length) {
      const sourceNode = sourceNodes.shift(), targetNode = targetNodes.shift();
      if (sourceNode && sourceNode.nodeType !== TEXT_NODE && sourceNode.nodeType !== ELEMENT_NODE) {
        throw new Error(`Source node type ${sourceNode.nodeType} not supported by DomHelper.sync()`);
      }
      if (targetNode && targetNode.nodeType !== TEXT_NODE && targetNode.nodeType !== ELEMENT_NODE) {
        throw new Error(`Target node type ${targetNode.nodeType} not supported by DomHelper.sync()`);
      }
      if (!targetNode) {
        targetElement.appendChild(sourceNode);
      } else {
        if (sourceNode.nodeType === targetNode.nodeType) {
          if (sourceNode.nodeType === TEXT_NODE) {
            targetNode.data = sourceNode.data;
          } else {
            if (sourceNode.tagName === targetNode.tagName) {
              me.performSync(sourceNode, targetNode);
            } else {
              targetElement.insertBefore(sourceNode, targetNode);
              targetNode.remove();
            }
          }
        } else if (sourceNode.nodeType === TEXT_NODE && targetNode.nodeType === ELEMENT_NODE) {
          targetElement.innerText = sourceNode.data.trim();
        } else {
          const logElement = sourceNode.parentElement || sourceNode;
          throw new Error(`Currently no support for transforming nodeType.
${logElement.outerHTML}`);
        }
      }
    }
    targetNodes.forEach((targetNode) => {
      targetNode.remove();
    });
  }
  static syncClassList(element, newClasses) {
    const {
      classList
    } = element, isString = typeof newClasses === "string", newClsArray = isString ? newClasses.split(whiteSpaceRe) : DomClassList.normalize(newClasses, "array"), classCount = newClsArray.length;
    let changed = classList.length !== classCount, i;
    for (i = 0; !changed && i < classCount; i++) {
      changed = !classList.contains(newClsArray[i]);
    }
    if (changed) {
      element.className = isString ? newClasses : newClsArray.join(" ");
    }
    return changed;
  }
  static updateClassList(element, classes) {
    const {
      classList
    } = element;
    let cls, add, changed = false;
    for (cls in classes) {
      add = Boolean(classes[cls]);
      if (classList.contains(cls) !== add) {
        classList[add ? "add" : "remove"](cls);
        changed = true;
      }
    }
    return changed;
  }
  static setTheme(newThemeName, defaultTheme) {
    newThemeName = newThemeName.toLowerCase();
    const {
      head
    } = document, oldThemeName = DH.getThemeInfo(defaultTheme).name.toLowerCase();
    let oldThemeLinks = head.querySelectorAll("[data-bryntum-theme]:not([data-loading])"), loaded = 0;
    if (oldThemeName === newThemeName) {
      return immediatePromise$5;
    }
    DH.removeEachSelector(head, "#bryntum-theme[data-loading],link[data-bryntum-theme][data-loading]");
    const themeEvent = {
      theme: newThemeName,
      prev: oldThemeName
    };
    function replaceTheme(oldThemeLink, resolve, reject) {
      const newThemeLink = DomHelper.createElement({
        tag: "link",
        rel: "stylesheet",
        dataset: {
          loading: true,
          bryntumTheme: true
        },
        href: oldThemeLink.href.replace(oldThemeName, newThemeName),
        nextSibling: oldThemeLink
      });
      newThemeLink.addEventListener("load", () => {
        delete newThemeLink.dataset.loading;
        themeInfo = null;
        if (++loaded === oldThemeLinks.length) {
          oldThemeLinks.forEach((link) => link.remove());
          GlobalEvents$1.trigger("theme", themeEvent);
          resolve(themeEvent);
        }
      });
      newThemeLink.addEventListener("error", (e) => {
        delete newThemeLink.dataset.loading;
        reject(e);
      });
    }
    if (oldThemeLinks.length) {
      return new Promise((resolve, reject) => {
        oldThemeLinks.forEach((oldThemeLink, i) => {
          replaceTheme(oldThemeLink, resolve, reject, i === oldThemeLinks.length - 1);
        });
      });
    } else {
      const oldThemeLink = head.querySelector("#bryntum-theme:not([data-loading])") || head.querySelector(`[href*="${oldThemeName}.css"]:not([data-loading])`);
      if (!(oldThemeLink !== null && oldThemeLink !== void 0 && oldThemeLink.href.includes(`${oldThemeName}.css`))) {
        throw new Error(`Theme link for ${oldThemeName} not found`);
      }
      oldThemeLinks = [oldThemeLink];
      return new Promise((resolve, reject) => replaceTheme(oldThemeLink, resolve, reject));
    }
  }
  static get themeInfo() {
    return DomHelper.getThemeInfo();
  }
  static getThemeInfo(defaultTheme) {
    if (!themeInfo) {
      const testDiv = DH.createElement({
        parent: document.body,
        className: "b-theme-info"
      }), themeData = DH.getStyleValue(testDiv, "content", false, ":before");
      if (themeData) {
        try {
          themeInfo = JSON.parse(themeData.replace(/^["']|["']$|\\/g, ""));
        } catch (e) {
          themeInfo = null;
        }
      }
      themeInfo = themeInfo || (defaultTheme ? {
        name: defaultTheme
      } : null);
      testDiv.remove();
    }
    return themeInfo;
  }
  static async transition({
    element: outerElement,
    selector = "[data-dom-transition]",
    duration,
    action,
    thisObj = this,
    addTransition = {},
    removeTransition = {}
  }) {
    const scrollers = /* @__PURE__ */ new Set(), beforeElements = Array.from(outerElement.querySelectorAll(selector)), beforeMap = new Map(beforeElements.map((element) => {
      let depth = 0, parent = element.parentElement;
      while (parent && parent !== outerElement) {
        depth++;
        parent = parent.parentElement;
      }
      element.$depth = depth;
      if (element.scrollHeight > element.offsetHeight && getComputedStyle(element).overflow === "auto") {
        element.$scrollTop = element.scrollTop;
        scrollers.add(element);
      }
      const {
        parentElement
      } = element, globalBounds = Rectangle.from(element, outerElement), localBounds = Rectangle.from(element, parentElement), style = getComputedStyle(parentElement), borderLeftWidth = parseFloat(style.borderLeftWidth);
      if (borderLeftWidth) {
        globalBounds.left -= borderLeftWidth;
        localBounds.left -= borderLeftWidth;
      }
      return [element.id, {
        element,
        globalBounds,
        localBounds,
        depth,
        parentElement
      }];
    }));
    action.call(thisObj);
    const afterElements = Array.from(outerElement.querySelectorAll(selector)), afterMap = new Map(afterElements.map((element) => {
      const globalBounds = Rectangle.from(element, outerElement), localBounds = Rectangle.from(element, element.parentElement), style = globalThis.getComputedStyle(element.parentElement), borderLeftWidth = parseFloat(style.borderLeftWidth);
      if (borderLeftWidth) {
        globalBounds.left -= borderLeftWidth;
        localBounds.left -= borderLeftWidth;
      }
      return [element.id, {
        element,
        globalBounds,
        localBounds
      }];
    })), styleProps = ["position", "top", "left", "width", "height", "padding", "margin", "zIndex", "minWidth", "minHeight", "opacity", "overflow"];
    for (const [id, before] of beforeMap) {
      const after = afterMap.get(id);
      if (after) {
        const {
          element
        } = after, {
          style,
          parentElement
        } = element, zIndex = parseInt(DH.getStyleValue(element, "zIndex")), {
          globalBounds,
          localBounds,
          depth,
          parentElement: beforeParent
        } = before, parentChanged = beforeParent !== parentElement;
        ObjectHelper.copyProperties(element.$initial = {
          parentElement
        }, style, styleProps);
        let bounds;
        if (parentChanged) {
          after.bounds = after.globalBounds;
          bounds = globalBounds;
          outerElement.appendChild(element);
        } else {
          after.bounds = after.localBounds;
          bounds = localBounds;
          beforeParent.appendChild(element);
        }
        let overflow = "hidden";
        if (scrollers.has(element)) {
          element.$scrollPlaceholder = DH.createElement({
            parent: element,
            style: {
              height: element.scrollHeight
            }
          });
          overflow = "auto";
        }
        Object.assign(style, {
          position: "absolute",
          top: `${bounds.top}px`,
          left: `${bounds.left}px`,
          width: `${bounds.width}px`,
          height: `${bounds.height}px`,
          minWidth: 0,
          minHeight: 0,
          padding: 0,
          margin: 0,
          zIndex: depth + (zIndex || 0),
          overflow
        });
        after.processed = true;
      } else {
        const {
          element,
          localBounds: bounds,
          depth,
          parentElement
        } = before;
        element.$initial = {
          removed: true
        };
        Object.assign(element.style, {
          position: "absolute",
          top: `${bounds.top}px`,
          left: `${bounds.left}px`,
          width: `${bounds.width}px`,
          height: `${bounds.height}px`,
          minWidth: 0,
          minHeight: 0,
          padding: 0,
          margin: 0,
          zIndex: depth,
          overflow: "hidden"
        });
        parentElement.appendChild(element);
        afterMap.set(id, {
          element,
          bounds,
          removed: true,
          processed: true
        });
        afterElements.push(element);
      }
    }
    for (const [, after] of afterMap) {
      if (!after.processed) {
        const {
          element
        } = after, {
          style,
          parentElement
        } = element, bounds = after.bounds = after.localBounds;
        element.classList.add("b-dom-transition-adding");
        ObjectHelper.copyProperties(element.$initial = {
          parentElement
        }, style, styleProps);
        Object.assign(style, {
          position: "absolute",
          top: addTransition.top ? 0 : `${bounds.top}px`,
          left: addTransition.left ? 0 : `${bounds.left}px`,
          width: addTransition.width ? 0 : `${bounds.width}px`,
          height: addTransition.height ? 0 : `${bounds.height}px`,
          opacity: addTransition.opacity ? 0 : null,
          zIndex: parentElement.$depth + 1,
          overflow: "hidden"
        });
      }
    }
    for (const element of scrollers) {
      element.scrollTop = element.$scrollTop;
    }
    outerElement.classList.add("b-dom-transition");
    outerElement.firstElementChild.offsetWidth;
    for (const [, {
      element,
      bounds: afterBounds,
      removed
    }] of afterMap) {
      if (removed) {
        Object.assign(element.style, {
          top: removeTransition.top ? 0 : `${afterBounds.top}px`,
          left: removeTransition.left ? 0 : `${afterBounds.left}px`,
          width: removeTransition.width ? 0 : `${afterBounds.width}px`,
          height: removeTransition.height ? 0 : `${afterBounds.height}px`,
          opacity: removeTransition.opacity ? 0 : element.$initial.opacity
        });
      } else {
        Object.assign(element.style, {
          top: `${afterBounds.top}px`,
          left: `${afterBounds.left}px`,
          width: `${afterBounds.width}px`,
          height: `${afterBounds.height}px`,
          opacity: element.$initial.opacity
        });
      }
    }
    await AsyncHelper.sleep(duration);
    outerElement.classList.remove("b-dom-transition");
    for (const element of afterElements) {
      if (element.$initial) {
        if (element.$initial.removed) {
          element.remove();
        } else {
          ObjectHelper.copyProperties(element.style, element.$initial, styleProps);
          if (element.$scrollPlaceholder) {
            element.$scrollPlaceholder.remove();
            delete element.$scrollPlaceholder;
          }
          element.classList.remove("b-dom-transition-adding");
          element.$initial.parentElement.appendChild(element);
        }
      }
    }
    for (const element of scrollers) {
      element.scrollTop = element.$scrollTop;
      delete element.$scrollTop;
    }
  }
  static async loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.src = url;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  static isNamedColor(color) {
    return color && !/^(#|hsl|rgb|hwb)/.test(color);
  }
  static get NodeFilter() {
    return NodeFilter;
  }
  static addChild(parent, child, sibling) {
    parent.insertBefore(child, sibling);
  }
};
var DH = DomHelper;
var clearTouchTimer;
var clearTouchEvent = () => DH.isTouchEvent = false;
var setTouchEvent = () => {
  DH.isTouchEvent = true;
  clearTimeout(clearTouchTimer);
  clearTouchTimer = setTimeout(clearTouchEvent, 400);
};
doc.addEventListener("touchstart", setTouchEvent, true);
doc.addEventListener("touchend", setTouchEvent, true);
DH.canonicalStyles = canonicalStyles;
DH.supportsTemplate = "content" in doc.createElement("template");
DH.elementPropKey = elementPropKey;
DH.numberRe = numberRe;
if (!("children" in Node.prototype)) {
  const elementFilter = (node) => node.nodeType === node.ELEMENT_NODE;
  Object.defineProperty(Node.prototype, "children", {
    get: function() {
      return Array.prototype.filter.call(this.childNodes, elementFilter);
    }
  });
}
if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(s) {
    const matches = (this.document || this.ownerDocument).querySelectorAll(s);
    let i = matches.length;
    while (--i >= 0 && matches.item(i) !== this) {
    }
    return i > -1;
  };
}
if (win.Element && !Element.prototype.closest) {
  Node.prototype.closest = Element.prototype.closest = function(s) {
    let el = this;
    if (!doc.documentElement.contains(el))
      return null;
    do {
      if (el.matches(s))
        return el;
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === el.ELEMENT_NODE);
    return null;
  };
} else {
  Node.prototype.closest = function(selector) {
    var _this$parentNode;
    return (_this$parentNode = this.parentNode) === null || _this$parentNode === void 0 ? void 0 : _this$parentNode.closest(selector);
  };
}
(function(arr) {
  arr.forEach(function(item) {
    if (Object.prototype.hasOwnProperty.call(item, "remove")) {
      return;
    }
    Object.defineProperty(item, "remove", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function remove() {
        this.parentNode && this.parentNode.removeChild(this);
      }
    });
  });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);
globalThis.addEventListener("resize", () => scrollBarWidth = null);
DomHelper._$name = "DomHelper";
var isFloatingWidget = (w) => w.floating;
var GlobalEvents = new class extends Base.mixin(Events) {
  suspendFocusEvents() {
    focusEventsSuspended = true;
  }
  resumeFocusEvents() {
    focusEventsSuspended = false;
  }
  setupFocusListenersOnce(rootElement, EventHelper2) {
    if (rootElement && !GlobalEvents.observedElements.has(rootElement)) {
      GlobalEvents.setupFocusListeners(rootElement, EventHelper2);
      GlobalEvents.observedElements.add(rootElement);
    }
  }
  setupFocusListeners(element = document, EventHelper2, detach = false) {
    var _detacher;
    const listeners = {
      element,
      touchstart(touchstart) {
        if (!globaltouchStart && touchstart.changedTouches.length === 1) {
          globaltouchStart = touchstart.changedTouches[0];
        } else {
          globaltouchStart = null;
        }
      },
      touchend: {
        handler: (event) => {
          if (globaltouchStart) {
            if (globaltouchStart.identifier === EventHelper2.contextMenuTouchId) {
              event.stopImmediatePropagation();
              event.preventDefault();
            } else if (event.changedTouches.length === 1 && event.changedTouches[0].identifier === globaltouchStart.identifier) {
              GlobalEvents.trigger("globaltap", {
                event
              });
            }
            globaltouchStart = null;
          }
        },
        passive: false
      },
      mousedown: {
        handler: (event) => {
          lastInteractionType = "mouse";
          if (!globaltouchStart) {
            GlobalEvents.trigger("globaltap", {
              event
            });
          }
          currentMouseDown = event;
          const hasModifierKey = event.ctrlKey || event.altKey || event.shiftKey || event.metaKey;
          if (!currentKeyDown && hasModifierKey) {
            currentKeyDown = new KeyboardEvent("keydown", {
              key: event.ctrlKey ? "Control" : event.shiftKey ? "Shift" : event.altKey ? "Alt" : "Meta",
              ctrlKey: event.ctrlKey,
              altKey: event.altKey,
              shiftKey: event.shiftKey,
              metaKey: event.metaKey
            });
          } else if (currentKeyDown && !hasModifierKey) {
            currentKeyDown = null;
          }
        },
        passive: false
      },
      mouseup() {
        currentMouseDown = null;
      },
      keydown(ev) {
        lastInteractionType = "key";
        currentKeyDown = ev;
      },
      keypress() {
        lastInteractionType = "key";
      },
      keyup() {
        currentKeyDown = null;
      },
      focusin(focusin) {
        const {
          Widget: Widget2
        } = GlobalEvents;
        Widget2.resetFloatRootScroll();
        if (focusEventsSuspended) {
          return;
        }
        const fromElement = !focusin.relatedTarget ? null : focusin.relatedTarget instanceof HTMLElement ? focusin.relatedTarget : document.body, toElement = focusin.target || document.body, fromWidget = Widget2.fromElement(fromElement), toWidget = Widget2.fromElement(toElement), commonAncestor = DomHelper.getCommonAncestor(fromWidget, toWidget), backwards = !!(fromElement && toElement.compareDocumentPosition(fromElement) & 4), topVisibleModal = Widget2.query(isTopVisibleModal);
        let currentFocus = null;
        if (toElement && toElement !== document.body) {
          currentFocus = DomHelper.getActiveElement(toElement);
        } else {
          currentFocus = DomHelper.getActiveElement(document);
        }
        if (topVisibleModal && !topVisibleModal._isRevertingFocus) {
          if (!toWidget || !topVisibleModal.owns(toWidget) && !(topVisibleModal.element.compareDocumentPosition(toWidget.element) & 4 && toWidget.up(isFloatingWidget))) {
            return topVisibleModal.focus();
          }
        }
        let event = createWidgetEvent("focusout", fromElement, focusin.target, fromWidget, toWidget, backwards);
        for (let target = fromWidget, owner; target && target !== commonAncestor; target = owner) {
          owner = target.owner;
          if (!target.isDestroying && target.onFocusOut) {
            target.onFocusOut(event);
            if (focusin.target && currentFocus !== DomHelper.getActiveElement(focusin.target)) {
              return;
            }
          }
        }
        if (commonAncestor && focusin.target === commonAncestor.element) {
          if (!commonAncestor.isDestroying && DomHelper.getActiveElement(commonAncestor) === toElement && commonAncestor.focusElement && commonAncestor.focusElement !== commonAncestor.element) {
            if (!commonAncestor.element.contains(currentFocus) || commonAncestor.focusDescendant) {
              commonAncestor.setTimeout(() => {
                var _commonAncestor$focus;
                return (_commonAncestor$focus = commonAncestor.focus) === null || _commonAncestor$focus === void 0 ? void 0 : _commonAncestor$focus.call(commonAncestor);
              }, 0);
            }
          }
        } else {
          event = createWidgetEvent("focusin", toElement, fromElement, fromWidget, toWidget, backwards);
          for (let target = toWidget; target && target !== commonAncestor; target = target.owner) {
            if (!target.isDestroying) {
              var _target$onFocusIn, _target;
              (_target$onFocusIn = (_target = target).onFocusIn) === null || _target$onFocusIn === void 0 ? void 0 : _target$onFocusIn.call(_target, event);
            }
          }
        }
        const commonAncestorEl = DomHelper.getCommonAncestor((fromElement === null || fromElement === void 0 ? void 0 : fromElement.nodeType) === Element.ELEMENT_NODE ? fromElement : null, toElement) || toElement.parentNode;
        if (commonAncestorEl) {
          event = createWidgetEvent("focusmove", toElement, fromElement, fromWidget, toWidget, backwards, {
            bubbles: true
          });
          commonAncestorEl.dispatchEvent(event);
        }
      },
      focusout(focusout) {
        if (focusEventsSuspended) {
          return;
        }
        if (!focusout.relatedTarget || !GlobalEvents.Widget.fromElement(focusout.relatedTarget)) {
          const target = focusout.relatedTarget && focusout.relatedTarget instanceof HTMLElement ? focusout.relatedTarget : null;
          listeners.focusin({
            target,
            relatedTarget: focusout.target
          });
          currentKeyDown = currentMouseDown = null;
        }
      },
      blur: {
        element: window,
        handler(event) {
          if (event.target === window) {
            currentKeyDown = null;
            currentMouseDown = null;
          }
        }
      },
      capture: true,
      passive: true
    };
    detach && ((_detacher = detacher) === null || _detacher === void 0 ? void 0 : _detacher());
    detacher = this.detachEvents = EventHelper2.on(listeners);
  }
  get lastInteractionType() {
    return lastInteractionType;
  }
  get shiftKeyDown() {
    var _currentKeyDown;
    return (_currentKeyDown = currentKeyDown) === null || _currentKeyDown === void 0 ? void 0 : _currentKeyDown.shiftKey;
  }
  get ctrlKeyDown() {
    var _currentKeyDown2, _currentKeyDown3;
    return ((_currentKeyDown2 = currentKeyDown) === null || _currentKeyDown2 === void 0 ? void 0 : _currentKeyDown2.ctrlKey) || ((_currentKeyDown3 = currentKeyDown) === null || _currentKeyDown3 === void 0 ? void 0 : _currentKeyDown3.metaKey);
  }
  get altKeyDown() {
    var _currentKeyDown4;
    return (_currentKeyDown4 = currentKeyDown) === null || _currentKeyDown4 === void 0 ? void 0 : _currentKeyDown4.altKey;
  }
  isKeyDown(key) {
    var _currentKeyDown5;
    return !key ? Boolean(currentKeyDown) : ((_currentKeyDown5 = currentKeyDown) === null || _currentKeyDown5 === void 0 ? void 0 : _currentKeyDown5.key) === key || currentKeyDown[(key === null || key === void 0 ? void 0 : key.toLowerCase()) + "Key"] === true;
  }
  isMouseDown(button = 0) {
    var _currentMouseDown;
    return ((_currentMouseDown = currentMouseDown) === null || _currentMouseDown === void 0 ? void 0 : _currentMouseDown.button) === button;
  }
  get currentMouseDown() {
    return currentMouseDown;
  }
  get currentKeyDown() {
    return currentKeyDown;
  }
}();
var isTopVisibleModal = (w) => w.isVisible && w.isTopModal;
GlobalEvents.observedElements = /* @__PURE__ */ new Set();
var globaltouchStart;
var focusEventsSuspended = false;
var lastInteractionType;
var currentKeyDown;
var currentMouseDown;
var detacher;
function createWidgetEvent(eventName, target, relatedTarget, fromWidget, toWidget, backwards, options) {
  const result = new CustomEvent(eventName, options);
  Object.defineProperty(result, "_target", {
    get() {
      return target;
    }
  });
  Object.defineProperty(result, "relatedTarget", {
    get() {
      return relatedTarget;
    }
  });
  result.fromWidget = fromWidget;
  result.toWidget = toWidget;
  result.backwards = backwards;
  return result;
}
var GlobalEvents$1 = GlobalEvents;
function getDescriptor(me, fnName) {
  const property = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(me), fnName);
  return property && (property.get || property.set) ? property : null;
}
var InstancePlugin = class extends Base.mixin(Events, Localizable) {
  static get configurable() {
    return {
      clientListeners: null,
      disabled: false,
      client: null,
      keyMap: null
    };
  }
  updateClient(client) {
    if (!this.owner) {
      this.owner = client;
    }
  }
  updateKeyMap(keyMap) {
    const {
      client
    } = this;
    client.keyMap = client.mergeKeyMaps(client.keyMap, keyMap, StringHelper.uncapitalize(this.constructor.$name));
  }
  static initPlugins(plugInto, ...plugins) {
    const property = plugInto.plugins || (plugInto.plugins = {});
    for (const PluginClass of plugins) {
      property[PluginClass.$$name] = new PluginClass(plugInto);
    }
  }
  get enabled() {
    return !this.disabled;
  }
  getFocusRevertTarget() {
    var _this$client;
    return (_this$client = this.client) === null || _this$client === void 0 ? void 0 : _this$client.getFocusRevertTarget();
  }
  construct(...args) {
    const me = this;
    let [plugInto, config] = args, listeners;
    if (args.length === 1) {
      if (ObjectHelper.isObject(plugInto)) {
        config = plugInto;
        plugInto = config.client;
      }
    } else {
      config = ObjectHelper.assign({}, config);
      delete config.client;
    }
    me.client = plugInto;
    super.construct(config);
    me.applyPluginConfig(plugInto);
    listeners = me.clientListeners;
    if (listeners) {
      listeners = ObjectHelper.assign({}, listeners);
      listeners.thisObj = me;
      plugInto.ion(listeners);
    }
  }
  applyPluginConfig(plugInto) {
    const me = this, config = me.pluginConfig || me.constructor.pluginConfig;
    if (config) {
      const {
        assign: assign2,
        chain,
        after,
        before,
        override
      } = config;
      assign2 && me.applyAssign(plugInto, assign2);
      (chain || after) && me.applyChain(plugInto, chain || after);
      before && me.applyChain(plugInto, before, false);
      override && me.applyOverride(plugInto, override);
    }
  }
  applyAssign(plugInto, fnNames) {
    fnNames.forEach((fnName) => this.assign(plugInto, fnName));
  }
  applyChain(plugInto, functions, after = true) {
    if (Array.isArray(functions)) {
      for (const fnName of functions) {
        this.chain(plugInto, fnName, fnName, after);
      }
    } else {
      for (const intoName in functions) {
        this.chain(plugInto, intoName, functions[intoName], after);
      }
    }
  }
  applyOverride(plugInto, fnNames) {
    const me = this;
    if (!me.overridden) {
      me.overridden = {};
    }
    fnNames.forEach((fnName) => {
      if (!me[fnName]) {
        throw new Error(`Trying to chain fn ${plugInto.$$name}#${fnName}, but plugin fn ${me.$$name}#${fnName} does not exist`);
      }
      if (typeof plugInto[fnName] === "function") {
        me.overridden[fnName] = plugInto[fnName].bind(plugInto);
      }
      plugInto[fnName] = me[fnName].bind(me);
    });
  }
  assign(plugInto, fnName) {
    const me = this, property = getDescriptor(me, fnName);
    if (property) {
      Object.defineProperty(plugInto, fnName, {
        configurable: true,
        enumerable: true,
        get: property.get && property.get.bind(me),
        set: property.set && property.set.bind(me)
      });
    } else {
      plugInto[fnName] = me[fnName].bind(me);
    }
  }
  chain(plugInto, intoName, hookName, after = true) {
    let prio = 0;
    if (typeof intoName === "object") {
      intoName = intoName.fn;
    }
    if (typeof hookName === "object") {
      prio = hookName.prio || 0;
      hookName = hookName.fn;
    }
    const me = this, chains = plugInto.pluginFunctionChain || (plugInto.pluginFunctionChain = {}), hookFn = me[hookName] && me[hookName].bind(me), functionChainRunner = me.functionChainRunner;
    if (!hookFn) {
      throw new Error(`Trying to chain fn ${plugInto.$$name}#${hookName}, but plugin fn ${me.$$name}#${hookName} does not exist`);
    }
    if (!chains[intoName]) {
      let intoFn = plugInto[intoName];
      if (intoFn) {
        intoFn = intoFn.bind(plugInto);
        intoFn.$this = plugInto;
        intoFn.$prio = 0;
      }
      chains[intoName] = intoFn ? [intoFn] : [];
      plugInto[intoName] = (...params) => functionChainRunner(chains[intoName], params);
    }
    hookFn.$this = me;
    hookFn.$prio = prio;
    chains[intoName][after ? "push" : "unshift"](hookFn);
    chains[intoName].$sorted = false;
  }
  functionChainRunner(chain, params) {
    let fn, i, returnValue;
    if (!chain.$sorted) {
      chain.sort((a, b) => b.$prio - a.$prio);
      chain.$sorted = true;
    }
    for (i = 0; i < chain.length; i++) {
      fn = chain[i];
      if (!fn.$this.isDestroyed) {
        returnValue = fn(...params);
        if (returnValue === false) {
          break;
        }
      }
    }
    return returnValue;
  }
  doDisable(disable) {
    const me = this, {
      constructor
    } = me, cls = "featureClass" in constructor ? constructor.featureClass : `b-${constructor.$$name.toLowerCase()}`;
    if (cls) {
      var _me$client, _me$client$element;
      (_me$client = me.client) === null || _me$client === void 0 ? void 0 : (_me$client$element = _me$client.element) === null || _me$client$element === void 0 ? void 0 : _me$client$element.classList[disable ? "remove" : "add"](cls);
    }
    if (!me.isConfiguring) {
      if (disable) {
        me.trigger("disable");
      } else {
        me.trigger("enable");
      }
    }
  }
  updateDisabled(disabled) {
    this.doDisable(disabled);
  }
  throwOverrideIsMissing(data) {
    throw new Error(`Trying to override fn ${data.plugIntoName}#${data.fnName}, but plugin fn ${data.pluginName}#${data.fnName} does not exist`);
  }
  get rootElement() {
    return this.client.rootElement;
  }
};
_defineProperty(InstancePlugin, "$name", "InstancePlugin");
InstancePlugin._$name = "InstancePlugin";
var Pluggable = (Target) => class Pluggable extends (Target || Base) {
  static get $name() {
    return "Pluggable";
  }
  get plugins() {
    if (!this._plugins) {
      this._plugins = {};
    }
    return this._plugins;
  }
  set plugins(plugins) {
    if (plugins) {
      if (!Array.isArray(plugins))
        plugins = [plugins];
      InstancePlugin.initPlugins(this, ...plugins);
    }
    this.initPlugins();
  }
  initPlugins() {
  }
  addPlugins(...plugins) {
    InstancePlugin.initPlugins(this, ...plugins);
  }
  hasPlugin(pluginClassOrName) {
    return this.getPlugin(pluginClassOrName) != null;
  }
  getPlugin(pluginClassOrName) {
    var _this$plugins;
    if (typeof pluginClassOrName === "function") {
      pluginClassOrName = pluginClassOrName.$$name;
    }
    return (_this$plugins = this.plugins) === null || _this$plugins === void 0 ? void 0 : _this$plugins[pluginClassOrName];
  }
  get widgetClass() {
  }
};
var {
  defineProperty: defineProperty$5
} = Reflect;
var performance$1;
if (BrowserHelper.isBrowserEnv) {
  performance$1 = globalThis.performance;
} else {
  performance$1 = {
    now() {
      return new Date().getTime();
    }
  };
}
var globalDelays = null;
if (VersionHelper.isTestEnv) {
  const bryntum = globalThis.bryntum || (globalThis.bryntum = {});
  globalDelays = bryntum.globalDelays = {
    timeouts: /* @__PURE__ */ new Map(),
    intervals: /* @__PURE__ */ new Map(),
    animationFrames: /* @__PURE__ */ new Map(),
    idleCallbacks: /* @__PURE__ */ new Map(),
    isEmpty(includeIntervals = false) {
      return globalDelays.timeouts.size + globalDelays.animationFrames.size + globalDelays.idleCallbacks.size + (includeIntervals ? globalDelays.intervals.size : 0) === 0;
    },
    getFiltered({
      ignoreTimeouts = [],
      maxDelay = 5e3,
      includeIntervals = false
    }) {
      const result = [], scopes = ["timeouts", "animationFrames", "idleCallbacks"];
      if (includeIntervals) {
        scopes.push("intervals");
      }
      for (const scope of scopes) {
        const map = globalDelays[scope];
        for (const [, entry] of map.entries()) {
          if (!ignoreTimeouts.includes(entry.name) && (!Number.isInteger(entry.delay) || entry.delay < maxDelay)) {
            result.push(entry);
          }
        }
      }
      return result;
    }
  };
}
var makeInvoker = (me, fn, wrapFn, options) => {
  const named = typeof fn === "string", appendArgs = (options === null || options === void 0 ? void 0 : options.appendArgs) || [], invoker = () => {
    wrapFn.timerId = null;
    wrapFn.lastCallTime = performance$1.now();
    const args = wrapFn.args;
    wrapFn.args = null;
    if (named) {
      me[fn](...args, ...appendArgs);
    } else {
      fn.call(me, ...args, ...appendArgs);
    }
    wrapFn.called = true;
    ++wrapFn.calls;
  };
  if (options) {
    me = options.thisObj || me;
  }
  wrapFn.lastCallTime = -9e9;
  wrapFn.calls = 0;
  wrapFn.invoker = invoker;
  invoker.wrapFn = wrapFn;
  return invoker;
};
var decorateWrapFn = (me, wrapFn, cancelFn = "clearTimeout") => {
  wrapFn.cancel = () => {
    if (wrapFn.isPending) {
      me[cancelFn](wrapFn.timerId);
      wrapFn.args = wrapFn.timerId = null;
    }
  };
  wrapFn.flush = () => {
    if (wrapFn.isPending) {
      me[cancelFn](wrapFn.timerId);
      wrapFn.timerId = null;
      wrapFn.invoker();
    }
  };
  wrapFn.now = (...args) => {
    wrapFn.cancel();
    wrapFn.args = args;
    wrapFn.invoker();
  };
  wrapFn.resume = (all) => {
    const n = wrapFn.suspended;
    wrapFn.suspended = all || n < 1 ? 0 : n - 1;
  };
  wrapFn.suspend = () => {
    ++wrapFn.suspended;
  };
  wrapFn.immediate = false;
  wrapFn.suspended = 0;
  wrapFn.timerId = null;
  defineProperty$5(wrapFn, "isPending", {
    get() {
      return wrapFn.timerId !== null;
    }
  });
  return wrapFn;
};
var Delayable = (Target) => class Delayable extends (Target || Base) {
  static get $name() {
    return "Delayable";
  }
  static get declarable() {
    return [
      "delayable"
    ];
  }
  doDestroy() {
    const me = this;
    super.doDestroy();
    if (me.timeoutIds) {
      me.timeoutIds.forEach((fn, id) => {
        var _globalDelays;
        if (typeof fn === "function") {
          fn();
        }
        clearTimeout(id);
        (_globalDelays = globalDelays) === null || _globalDelays === void 0 ? void 0 : _globalDelays.timeouts.delete(id);
      });
      me.timeoutIds = null;
    }
    if (me.timeoutMap) {
      me.timeoutMap.forEach((name, id) => clearTimeout(id));
      me.timeoutMap = null;
    }
    if (me.intervalIds) {
      me.intervalIds.forEach((id) => {
        var _globalDelays2;
        clearInterval(id);
        (_globalDelays2 = globalDelays) === null || _globalDelays2 === void 0 ? void 0 : _globalDelays2.intervals.delete(id);
      });
      me.intervalIds = null;
    }
    if (me.animationFrameIds) {
      me.animationFrameIds.forEach((id) => {
        var _globalDelays3;
        cancelAnimationFrame(id);
        (_globalDelays3 = globalDelays) === null || _globalDelays3 === void 0 ? void 0 : _globalDelays3.animationFrames.delete(id);
      });
      me.animationFrameIds = null;
    }
    if (me.idleCallbackIds) {
      me.idleCallbackIds.forEach((id) => {
        var _globalDelays4;
        cancelIdleCallback(id);
        (_globalDelays4 = globalDelays) === null || _globalDelays4 === void 0 ? void 0 : _globalDelays4.idleCallbacks.delete(id);
      });
      me.idleCallbackIds = null;
    }
  }
  hasTimeout(name) {
    var _this$timeoutMap;
    return Boolean((_this$timeoutMap = this.timeoutMap) === null || _this$timeoutMap === void 0 ? void 0 : _this$timeoutMap.has(name));
  }
  setTimeout({
    fn,
    delay,
    name,
    runOnDestroy,
    cancelOutstanding,
    args
  }) {
    var _globalDelays6;
    if (arguments.length > 1 || typeof arguments[0] === "function") {
      [fn, delay, name, runOnDestroy] = arguments;
    }
    if (typeof fn === "string") {
      name = fn;
    } else if (!name) {
      name = fn.name || fn;
    }
    if (cancelOutstanding) {
      this.clearTimeout(name);
    }
    const me = this, timeoutIds = me.timeoutIds || (me.timeoutIds = /* @__PURE__ */ new Map()), timeoutMap = me.timeoutMap || (me.timeoutMap = /* @__PURE__ */ new Map()), timeoutId = setTimeout(() => {
      var _globalDelays5;
      if (typeof fn === "string") {
        fn = me[name];
      }
      timeoutIds === null || timeoutIds === void 0 ? void 0 : timeoutIds.delete(timeoutId);
      timeoutMap === null || timeoutMap === void 0 ? void 0 : timeoutMap.delete(name);
      (_globalDelays5 = globalDelays) === null || _globalDelays5 === void 0 ? void 0 : _globalDelays5.timeouts.delete(timeoutId);
      fn.apply(me, args);
    }, delay);
    timeoutIds.set(timeoutId, runOnDestroy ? fn : true);
    (_globalDelays6 = globalDelays) === null || _globalDelays6 === void 0 ? void 0 : _globalDelays6.timeouts.set(timeoutId, {
      fn,
      delay,
      name
    });
    if (name) {
      timeoutMap.set(name, timeoutId);
    }
    return timeoutId;
  }
  clearTimeout(idOrName) {
    var _this$timeoutIds, _globalDelays7;
    let id = idOrName;
    if (typeof id === "string") {
      if (this.timeoutMap) {
        id = this.timeoutMap.get(idOrName);
        this.timeoutMap.delete(idOrName);
      } else {
        return;
      }
    }
    clearTimeout(id);
    (_this$timeoutIds = this.timeoutIds) === null || _this$timeoutIds === void 0 ? void 0 : _this$timeoutIds.delete(id);
    (_globalDelays7 = globalDelays) === null || _globalDelays7 === void 0 ? void 0 : _globalDelays7.timeouts.delete(id);
  }
  clearInterval(id) {
    var _this$intervalIds, _globalDelays8;
    clearInterval(id);
    (_this$intervalIds = this.intervalIds) === null || _this$intervalIds === void 0 ? void 0 : _this$intervalIds.delete(id);
    (_globalDelays8 = globalDelays) === null || _globalDelays8 === void 0 ? void 0 : _globalDelays8.intervals.delete(id);
  }
  setInterval(fn, delay, name) {
    var _globalDelays9;
    const intervalId = setInterval(fn, delay);
    (this.intervalIds || (this.intervalIds = /* @__PURE__ */ new Set())).add(intervalId);
    (_globalDelays9 = globalDelays) === null || _globalDelays9 === void 0 ? void 0 : _globalDelays9.intervals.set(intervalId, {
      fn,
      delay,
      name
    });
    return intervalId;
  }
  requestAnimationFrame(fn, extraArgs = [], thisObj = this) {
    var _globalDelays11;
    const animationFrameIds = this.animationFrameIds || (this.animationFrameIds = /* @__PURE__ */ new Set()), frameId = requestAnimationFrame(() => {
      var _globalDelays10;
      (_globalDelays10 = globalDelays) === null || _globalDelays10 === void 0 ? void 0 : _globalDelays10.animationFrames.delete(frameId);
      animationFrameIds.delete(frameId) && fn.apply(thisObj, extraArgs);
    });
    animationFrameIds.add(frameId);
    (_globalDelays11 = globalDelays) === null || _globalDelays11 === void 0 ? void 0 : _globalDelays11.animationFrames.set(frameId, {
      fn,
      extraArgs,
      thisObj
    });
    return frameId;
  }
  requestIdleCallback(fn, extraArgs = [], thisObj = this) {
    var _globalDelays13;
    const idleCallbackIds = this.idleCallbackIds || (this.idleCallbackIds = /* @__PURE__ */ new Set()), frameId = requestIdleCallback(() => {
      var _globalDelays12;
      (_globalDelays12 = globalDelays) === null || _globalDelays12 === void 0 ? void 0 : _globalDelays12.idleCallbacks.delete(frameId);
      idleCallbackIds.delete(frameId) && fn.apply(thisObj, extraArgs);
    });
    idleCallbackIds.add(frameId);
    (_globalDelays13 = globalDelays) === null || _globalDelays13 === void 0 ? void 0 : _globalDelays13.idleCallbacks.set(frameId, {
      fn,
      extraArgs,
      thisObj
    });
    return frameId;
  }
  createOnFrame(fn, args = [], thisObj = this, cancelOutstanding) {
    let rafId;
    const result = (...callArgs) => {
      if (rafId != null && cancelOutstanding) {
        this.cancelAnimationFrame(rafId);
        rafId = null;
      }
      if (rafId == null) {
        rafId = this.requestAnimationFrame(() => {
          if (typeof fn === "string") {
            fn = thisObj[fn];
          }
          rafId = null;
          callArgs.push(...args);
          fn.apply(thisObj, callArgs);
        });
      }
    };
    result.cancel = () => this.cancelAnimationFrame(rafId);
    return result;
  }
  cancelAnimationFrame(handle) {
    var _this$animationFrameI, _globalDelays14;
    cancelAnimationFrame(handle);
    (_this$animationFrameI = this.animationFrameIds) === null || _this$animationFrameI === void 0 ? void 0 : _this$animationFrameI.delete(handle);
    (_globalDelays14 = globalDelays) === null || _globalDelays14 === void 0 ? void 0 : _globalDelays14.animationFrames.delete(handle);
  }
  cancelIdleCallback(handle) {
    var _this$idleCallbackIds, _globalDelays15;
    cancelIdleCallback(handle);
    (_this$idleCallbackIds = this.idleCallbackIds) === null || _this$idleCallbackIds === void 0 ? void 0 : _this$idleCallbackIds.delete(handle);
    (_globalDelays15 = globalDelays) === null || _globalDelays15 === void 0 ? void 0 : _globalDelays15.idleCallbacks.delete(handle);
  }
  async nextAnimationFrame() {
    return new Promise((resolve) => this.requestAnimationFrame(resolve));
  }
  buffer(fn, options) {
    let delay = options;
    if (options && typeof options !== "number") {
      delay = options.delay;
    } else {
      options = null;
    }
    const bufferWrapFn = (...params) => {
      if (bufferWrapFn.suspended) {
        return;
      }
      const {
        delay: delay2
      } = bufferWrapFn;
      bufferWrapFn.cancel();
      bufferWrapFn.called = false;
      bufferWrapFn.args = params;
      if (bufferWrapFn.immediate || !delay2) {
        invoker();
      } else {
        bufferWrapFn.timerId = this.setTimeout(invoker, delay2);
      }
    }, invoker = makeInvoker(this, fn, bufferWrapFn, options);
    bufferWrapFn.delay = delay;
    return decorateWrapFn(this, bufferWrapFn);
  }
  raf(fn, options) {
    let cancelOutstanding = options;
    if (options && typeof options !== "boolean") {
      cancelOutstanding = options.cancelOutstanding;
    } else {
      options = null;
    }
    const rafWrapFn = (...params) => {
      if (rafWrapFn.suspended) {
        return;
      }
      if (rafWrapFn.cancelOutstanding) {
        rafWrapFn.cancel();
      }
      rafWrapFn.called = false;
      rafWrapFn.args = params;
      if (rafWrapFn.immediate) {
        invoker();
      } else if (!rafWrapFn.isPending) {
        rafWrapFn.timerId = this.requestAnimationFrame(invoker);
      }
    }, invoker = makeInvoker(this, fn, rafWrapFn, options);
    rafWrapFn.cancelOutstanding = cancelOutstanding;
    return decorateWrapFn(this, rafWrapFn, "cancelAnimationFrame");
  }
  idle(fn, options) {
    let cancelOutstanding = options;
    if (options && typeof options !== "boolean") {
      cancelOutstanding = options.cancelOutstanding;
    } else {
      options = null;
    }
    const idleWrapFn = (...params) => {
      if (idleWrapFn.suspended) {
        return;
      }
      if (idleWrapFn.cancelOutstanding) {
        idleWrapFn.cancel();
      }
      idleWrapFn.called = false;
      idleWrapFn.args = params;
      if (idleWrapFn.immediate) {
        invoker();
      } else if (!idleWrapFn.isPending) {
        idleWrapFn.timerId = this.requestIdleCallback(invoker);
      }
    }, invoker = makeInvoker(this, fn, idleWrapFn, options);
    idleWrapFn.cancelOutstanding = cancelOutstanding;
    this.setTimeout(() => this.idleCallbackIds.delete(idleWrapFn.timerId) && idleWrapFn.now(), 100);
    return decorateWrapFn(this, idleWrapFn, "cancelIdleCallback");
  }
  throttle(fn, options) {
    let delay = options, throttled;
    if (options && typeof options !== "number") {
      delay = options.delay;
      throttled = options.throttled;
    } else {
      options = null;
    }
    const me = this, throttleWrapFn = (...args) => {
      if (throttleWrapFn.suspended) {
        return;
      }
      const {
        delay: delay2
      } = throttleWrapFn, elapsed = performance$1.now() - throttleWrapFn.lastCallTime;
      throttleWrapFn.args = args;
      if (throttleWrapFn.immediate || elapsed >= delay2) {
        me.clearTimeout(throttleWrapFn.timerId);
        invoker();
      } else {
        if (!throttleWrapFn.isPending) {
          throttleWrapFn.timerId = me.setTimeout(invoker, delay2 - elapsed);
          throttleWrapFn.called = false;
        }
        if (throttled) {
          throttled.wrapFn.args = args;
          throttled();
        }
      }
    }, invoker = makeInvoker(me, fn, throttleWrapFn, options);
    throttleWrapFn.delay = delay;
    if (throttled) {
      throttled = makeInvoker(me, throttled, () => {
      }, options);
    }
    return decorateWrapFn(me, throttleWrapFn);
  }
  static setupDelayable(cls) {
    cls.setupDelayableMethods(cls.delayable);
  }
  static setupDelayableMethods(delayable, cls = null) {
    const me = this, statics = delayable.static, target = cls || me.prototype;
    if (statics) {
      delete delayable.static;
    }
    for (const name in delayable) {
      let options = delayable[name];
      const implName = name + "Now", type = typeof options;
      if (!target[implName]) {
        target[implName] = target[name];
      }
      if (type === "number") {
        options = {
          type: "buffer",
          delay: options
        };
      } else if (type === "string") {
        options = {
          type: options
        };
      }
      defineProperty$5(target, name, {
        get() {
          const value = this[options.type]((...params) => {
            this[implName](...params);
          }, options);
          defineProperty$5(this, name, {
            value
          });
          return value;
        }
      });
    }
  }
  get widgetClass() {
  }
};
var StateStorage = class {
  get data() {
    return /* @__PURE__ */ Object.create(null);
  }
  get keys() {
    return [];
  }
  clear() {
  }
  getItem(key) {
    return null;
  }
  removeItem(key) {
  }
  setItem(key, value) {
  }
};
StateStorage._$name = "StateStorage";
var empty = () => /* @__PURE__ */ Object.create(null);
var getKeys = (prefix, pos = 0) => {
  const keys = [], count = localStorage.length;
  for (let key, i = 0; i < count; ++i) {
    key = localStorage.key(i);
    key.startsWith(prefix) && keys.push(key.slice(pos));
  }
  return keys;
};
var Local = class extends StateStorage {
  constructor(stateProvider) {
    super();
    this.prefix = stateProvider.prefix || "";
  }
  get isLocal() {
    return true;
  }
  get data() {
    const data = empty(), keys = this.keys;
    for (const key of keys) {
      data[key] = this.getItem(key);
    }
    return data;
  }
  get keys() {
    return getKeys(this.prefix, this.prefix.length);
  }
  clear() {
    const keys = getKeys(this.prefix);
    for (const key of keys) {
      localStorage.removeItem(key);
    }
  }
  getItem(key) {
    const value = localStorage.getItem(this.prefix + key);
    return value === null ? value : JSON.parse(value);
  }
  removeItem(key) {
    return localStorage.removeItem(this.prefix + key);
  }
  setItem(key, value) {
    return localStorage.setItem(this.prefix + key, JSON.stringify(value));
  }
};
var Memory = class extends StateStorage {
  constructor() {
    super();
    this.clear();
  }
  get isMemory() {
    return true;
  }
  get data() {
    return ObjectHelper.clone(this._data);
  }
  get keys() {
    return Object.keys(this._data);
  }
  clear() {
    this._data = empty();
  }
  getItem(key) {
    return key in this._data ? this._data[key] : null;
  }
  removeItem(key) {
    delete this._data[key];
  }
  setItem(key, value) {
    this._data[key] = value;
  }
};
var nullStorage = new StateStorage();
var storageTypes = {
  local: Local,
  memory: Memory
};
var StateProvider = class extends Base.mixin(Delayable, Events) {
  static get $name() {
    return "StateProvider";
  }
  static get configurable() {
    return {
      prefix: "bryntum-state:",
      storage: "local"
    };
  }
  static get delayable() {
    return {
      writeStatefuls: 50
    };
  }
  static get instance() {
    return this._instance;
  }
  static set instance(inst) {
    if (inst == null) {
      inst = nullProvider;
    } else {
      if (typeof inst === "string" || ObjectHelper.isClass(inst) || inst instanceof StateStorage) {
        inst = {
          storage: inst
        };
      }
      if (ObjectHelper.isObject(inst)) {
        inst = new StateProvider(inst);
      }
    }
    this._instance = inst;
  }
  static setup(inst) {
    this.instance = inst;
    return this.instance;
  }
  doDestroy() {
    self.writeStatefuls.flush();
    super.doDestroy();
  }
  get data() {
    return this.storage.data;
  }
  set data(data) {
    if (!data) {
      this.clear();
    } else {
      for (const key in data) {
        this.setValue(key, data[key]);
      }
    }
  }
  clear() {
    this.storage.clear();
    return this;
  }
  changeStorage(storage) {
    if (storage == null) {
      storage = nullStorage;
    } else {
      if (typeof storage === "string") {
        if (!storageTypes[storage]) {
          throw new Error(`Invalid storage type "${storage}" (expected one of: "${Object.keys(storageTypes).join('", "')}")`);
        }
        storage = storageTypes[storage];
      }
      if (ObjectHelper.isClass(storage)) {
        storage = new storage(this);
      }
    }
    return storage;
  }
  saveStateful(stateful, options) {
    (this.pendingSaves || (this.pendingSaves = [])).push([stateful, options]);
    this.writeStatefuls();
  }
  writeStatefuls() {
    const me = this, {
      pendingSaves
    } = me, n = pendingSaves === null || pendingSaves === void 0 ? void 0 : pendingSaves.length, stateIds = [], saved = [];
    me.pendingSaves = null;
    if (n) {
      for (let options, stateful, stateId, i = 0; i < n; ++i) {
        [stateful, options] = pendingSaves[i];
        if (!stateful.isDestroying && stateful.isSaveStatePending) {
          stateId = stateful.saveState(_objectSpread2(_objectSpread2({}, options), {}, {
            immediate: true
          }));
          if (stateId) {
            stateIds.push(stateId);
            saved.push(stateful);
          }
        }
      }
      if (stateIds.length) {
        me.trigger("save", {
          stateIds,
          saved
        });
      }
    }
  }
  getValue(key) {
    this.writeStatefuls.flush();
    return this.storage.getItem(key);
  }
  setValue(key, value) {
    const me = this, {
      storage
    } = me, was = me.getValue(key);
    if (value != null) {
      storage.setItem(key, value);
      me.trigger("set", {
        key,
        value,
        was
      });
    } else if (was !== null) {
      storage.removeItem(key);
      me.trigger("remove", {
        key,
        was
      });
    }
    return me;
  }
};
var nullProvider = new StateProvider({
  storage: nullStorage
});
StateProvider._instance = nullProvider;
StateProvider._$name = "StateProvider";
var primitiveRe = /boolean|number|string/;
var State = (Target) => {
  var _class;
  return _class = class State extends (Target || Base) {
    afterConstruct() {
      super.afterConstruct();
      this.loadState();
    }
    finalizeInit() {
      this.loadState();
      super.finalizeInit();
    }
    get isStateful() {
      return true;
    }
    get isStatefulActive() {
      return !this.statefulSuspended && !this.isResponsivePending && !this.isResponsiveUpdating;
    }
    get state() {
      return this._state = this.getState();
    }
    set state(state) {
      this._state = state;
      if (state) {
        this.applyState(state);
      }
    }
    updateStatefulEvents(events) {
      const me = this, listeners = {
        name: "statefulEvents",
        thisObj: me
      };
      me.detachListeners(listeners.name);
      if (events) {
        if (typeof events === "string") {
          events = StringHelper.split(events);
        } else if (!Array.isArray(events)) {
          events = ObjectHelper.getTruthyKeys(events);
        }
        if (events.length) {
          var _me$ion;
          for (const event of events) {
            listeners[event] = "onStatefulEvent";
          }
          (_me$ion = me.ion) === null || _me$ion === void 0 ? void 0 : _me$ion.call(me, listeners);
        }
      }
    }
    get statefulId() {
      const me = this, {
        responsiveState
      } = me;
      let statefulId = me.stateId;
      if (statefulId == null && me.hasGeneratedId === false && me.stateful !== false) {
        statefulId = me.id;
      }
      if (statefulId && responsiveState) {
        statefulId = `${statefulId}[${responsiveState}]`;
      }
      return statefulId;
    }
    get statefulness() {
      const {
        stateful
      } = this;
      return Array.isArray(stateful) ? ObjectHelper.createTruthyKeys(stateful) : stateful;
    }
    get stateProvider() {
      return this._stateProvider || StateProvider.instance;
    }
    applyState(state) {
      state = this.pruneState(state);
      if (state) {
        this.setConfig(state);
      }
    }
    getState() {
      const me = this, {
        statefulness
      } = me;
      let state = null, key, value;
      if (statefulness) {
        state = {};
        for (key in statefulness) {
          if (statefulness[key]) {
            var _value, _me$initialConfig;
            value = me[key];
            if ((_value = value) !== null && _value !== void 0 && _value.isStateful) {
              value = value.state;
            } else if (value === ((_me$initialConfig = me.initialConfig) === null || _me$initialConfig === void 0 ? void 0 : _me$initialConfig[key]) || !primitiveRe.test(typeof value)) {
              continue;
            }
            state[key] = value;
          }
        }
      }
      return state;
    }
    loadState(stateId, reload) {
      if (typeof stateId === "boolean") {
        reload = stateId;
        stateId = null;
      }
      const me = this, {
        statefulLoaded
      } = me;
      if (me.isStatefulActive && (reload || !statefulLoaded)) {
        const state = me.loadStatefulData(stateId || (stateId = me.statefulId));
        if (!statefulLoaded && stateId) {
          me.defaultState = me.state;
          me.statefulLoaded = true;
        }
        if (state) {
          me.state = state;
        }
      }
    }
    loadStatefulData(stateId) {
      var _this$stateProvider;
      stateId = this.isStatefulActive ? stateId || this.statefulId : null;
      return stateId && ((_this$stateProvider = this.stateProvider) === null || _this$stateProvider === void 0 ? void 0 : _this$stateProvider.getValue(stateId));
    }
    resetDefaultState() {
      if (this.defaultState) {
        this.state = this.defaultState;
      }
    }
    resumeStateful(full = false) {
      this.statefulSuspended = full ? 0 : Math.max(this.statefulSuspended - 1, 0);
    }
    saveState(options) {
      if (typeof options === "string") {
        options = {
          id: options
        };
      } else {
        options = options || {};
      }
      const me = this, {
        stateProvider
      } = me, statefulId = options.id || me.isStatefulActive && me.statefulId;
      if (statefulId && stateProvider) {
        if (options.immediate) {
          me.isSaveStatePending = false;
          stateProvider.setValue(statefulId, me.state);
        } else if (!me.isSaveStatePending) {
          me.isSaveStatePending = true;
          stateProvider.saveStateful(me, options);
        }
        return statefulId;
      }
    }
    suspendStateful() {
      ++this.statefulSuspended;
    }
    onConfigChange({
      name,
      value,
      was,
      config
    }) {
      super.onConfigChange({
        name,
        value,
        was,
        config
      });
      if (!this.isConstructing && this.isStatefulActive && this.statefulId) {
        const {
          stateful
        } = this;
        if (Array.isArray(stateful) ? stateful.includes(name) : stateful === null || stateful === void 0 ? void 0 : stateful[name]) {
          this.saveState();
        }
      }
    }
    onStatefulEvent() {
      if (!this.isConstructing) {
        this.saveState();
      }
    }
    pruneState(state) {
      const {
        statefulness
      } = this;
      if (statefulness) {
        const pruned = {};
        for (const key in state) {
          if (statefulness[key]) {
            pruned[key] = state[key];
          }
        }
        state = pruned;
      }
      return state;
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "$name", "State"), _defineProperty(_class, "configurable", {
    stateful: null,
    statefulEvents: {
      $config: {
        merge: "classList"
      },
      value: ["stateChange"]
    },
    stateId: null,
    stateProvider: null
  }), _defineProperty(_class, "prototypeProperties", {
    statefulLoaded: false,
    statefulSuspended: 0
  }), _class;
};
var idCounts$1 = ObjectHelper.getPathDefault(globalThis, "bryntum.idCounts", /* @__PURE__ */ Object.create(null));
var idTypes = {
  string: 1,
  number: 1
};
var Identifiable = (Target) => class Identifiable extends (Target || Base) {
  static get $name() {
    return "Identifiable";
  }
  static get declarable() {
    return ["identifiable"];
  }
  static get configurable() {
    return {
      id: ""
    };
  }
  static setupIdentifiable(cls, meta) {
    const {
      identifiable
    } = cls;
    identifiable.idMap = /* @__PURE__ */ Object.create(null);
    Reflect.defineProperty(cls, "identifiable", {
      get() {
        return identifiable;
      }
    });
  }
  doDestroy() {
    this.constructor.unregisterInstance(this);
    super.doDestroy();
  }
  changeId(id) {
    return (this.hasGeneratedId = !id) ? this.generateAutoId() : id;
  }
  updateId(id, oldId) {
    const me = this, C = me.constructor;
    oldId && C.unregisterInstance(me, oldId);
    if (!me.hasGeneratedId || C.identifiable.registerGeneratedId !== false) {
      C.registerInstance(me, id);
    }
  }
  generateAutoId() {
    return this.constructor.generateId(`b-${this.$$name.toLowerCase()}-`);
  }
  static get all() {
    return Object.values(this.identifiable.idMap);
  }
  static generateId(prefix = "generatedId") {
    return prefix + (idCounts$1[prefix] = (idCounts$1[prefix] || 0) + 1);
  }
  static registerInstance(instance, instanceId = instance.id) {
    const {
      idMap
    } = this.identifiable;
    if (instanceId in idMap && !this.disableThrow) {
      throw new Error("Id " + instanceId + " already in use");
    }
    idMap[instanceId] = instance;
  }
  static unregisterInstance(instance, id = instance.id) {
    const {
      idMap
    } = this.identifiable;
    if (idTypes[typeof instance]) {
      delete idMap[instance];
    } else if (idMap[id] === instance) {
      delete idMap[id];
    }
  }
  static getById(id) {
    const idMap = this.identifiable.idMap;
    if (idMap) {
      return idMap[id];
    }
  }
  static get registeredInstances() {
    const idMap = this.identifiable.idMap;
    return idMap ? Object.values(idMap) : [];
  }
};
var STM_PROP$1 = Symbol("STM_PROP");
var unrecordedFields = {
  parentIndex: 1
};
var ModelStm = (Target) => class ModelStm extends (Target || Base) {
  static get $name() {
    return "ModelStm";
  }
  static get defaultConfig() {
    return {
      stm: null
    };
  }
  joinStore(store) {
    if (!this.stm) {
      this.stm = store.stm;
    }
  }
  unjoinStore(store) {
    var _super$unjoinStore;
    if (this.stm === store.stm) {
      this.stm = null;
    }
    (_super$unjoinStore = super.unjoinStore) === null || _super$unjoinStore === void 0 ? void 0 : _super$unjoinStore.call(this, store);
  }
  get stm() {
    return this[STM_PROP$1];
  }
  set stm(stm) {
    this[STM_PROP$1] = stm;
  }
  beforeChronoFieldSet(fieldName, value) {
    const me = this, {
      stm
    } = me, result = [];
    if (!me.inSetting && stm !== null && stm !== void 0 && stm.enabled && !unrecordedFields[fieldName] && !me.constructor.nonPersistableFields[fieldName]) {
      if (me.getFieldDefinition(fieldName)) {
        const newDataCandidate = {
          [fieldName]: value
        }, oldDataCandidate = {
          [fieldName]: me[fieldName]
        };
        result.push([newDataCandidate, oldDataCandidate]);
      }
    }
    return result;
  }
  beforeSet(field, value, silent, fromRelationUpdate) {
    const {
      stm
    } = this;
    if (stm !== null && stm !== void 0 && stm.enabled && !unrecordedFields[field] && !this.constructor.nonPersistableFields[field]) {
      var _super$beforeSet;
      const preResult = ((_super$beforeSet = super.beforeSet) === null || _super$beforeSet === void 0 ? void 0 : _super$beforeSet.call(this, field, value, silent, fromRelationUpdate)) || [];
      let newDataCandidate, oldDataCandidate;
      if (typeof field == "object") {
        [newDataCandidate, oldDataCandidate] = Object.keys(field).reduce((data, fName) => {
          data[0][fName] = field[fName];
          data[1][fName] = this.get(fName);
          return data;
        }, [{}, {}]);
      } else {
        newDataCandidate = {
          [field]: value
        };
        oldDataCandidate = {
          [field]: this.get(field)
        };
      }
      preResult.push([newDataCandidate, oldDataCandidate]);
      return preResult;
    }
    return [];
  }
  afterChronoFieldSet(fieldName, value, beforeResult) {
    if (beforeResult !== null && beforeResult !== void 0 && beforeResult[0]) {
      this.afterSet(fieldName, value, false, false, beforeResult, beforeResult[0][0], true);
    }
  }
  shouldRecordFieldChange(fieldName, oldValue, newValue) {
    const store = this.firstStore;
    return !(this.constructor.nonPersistableFields[fieldName] || oldValue == null && newValue == null || oldValue === newValue || oldValue instanceof Date && newValue instanceof Date && oldValue.getTime() === newValue.getTime() || fieldName === "id" || fieldName === "parentId" && store && store.oldIdMap[oldValue] === store.getById(newValue));
  }
  afterSet(field, value, silent, fromRelationUpdate, beforeResult, wasSet, isChronoFieldSet) {
    const {
      stm
    } = this, nonPersistableFields = this.constructor.nonPersistableFields;
    if (stm !== null && stm !== void 0 && stm.isBase && stm.enabled && !unrecordedFields[field] && !nonPersistableFields[field]) {
      const preResult = beforeResult.pop();
      if (wasSet) {
        let shouldRecord;
        const [newDataCandidate, oldDataCandidate] = preResult, [newData, oldData] = Object.keys(wasSet).reduce((data, fieldName) => {
          const newValue = newDataCandidate[fieldName], oldValue = oldDataCandidate[fieldName];
          if (this.shouldRecordFieldChange(fieldName, oldValue, newValue)) {
            shouldRecord = true;
            data[0][fieldName] = newValue;
            data[1][fieldName] = oldValue;
          }
          return data;
        }, [{}, {}]);
        if (shouldRecord) {
          stm.onModelUpdate(this, newData, oldData, isChronoFieldSet);
        }
      }
    }
  }
  beforeInsertChild(childRecords) {
    var _super$beforeInsertCh;
    const preResult = ((_super$beforeInsertCh = super.beforeInsertChild) === null || _super$beforeInsertCh === void 0 ? void 0 : _super$beforeInsertCh.call(this, childRecords)) || [], {
      stm
    } = this;
    if (stm !== null && stm !== void 0 && stm.enabled) {
      preResult.push(childRecords.reduce((result, childRecord) => {
        if (childRecord.root === this.root) {
          result.set(childRecord, {
            parent: childRecord.parent,
            index: childRecord.parent ? childRecord.parentIndex : void 0
          });
        }
        return result;
      }, /* @__PURE__ */ new Map()));
    }
    return preResult;
  }
  afterInsertChild(index, childRecords, beforeResult, inserted) {
    var _super$afterInsertChi;
    const {
      stm
    } = this;
    if (stm !== null && stm !== void 0 && stm.enabled) {
      const context = beforeResult.pop();
      if (inserted) {
        stm.onModelInsertChild(this, index, inserted, context);
      }
    }
    (_super$afterInsertChi = super.afterInsertChild) === null || _super$afterInsertChi === void 0 ? void 0 : _super$afterInsertChi.call(this, index, childRecords, beforeResult, inserted);
  }
  beforeRemoveChild(childRecords, isMove) {
    const preResult = super.beforeRemoveChild ? super.beforeRemoveChild(childRecords, isMove) : [], {
      stm
    } = this;
    if (stm !== null && stm !== void 0 && stm.enabled && !isMove) {
      preResult.push(childRecords.reduce((result, childRecord) => {
        result.set(childRecord, childRecord.parentIndex);
        return result;
      }, /* @__PURE__ */ new Map()));
    }
    return preResult;
  }
  afterRemoveChild(childRecords, beforeResult, isMove) {
    var _super$afterRemoveChi;
    const {
      stm
    } = this;
    if (stm !== null && stm !== void 0 && stm.enabled && !isMove) {
      const context = beforeResult.pop();
      if (childRecords && childRecords.length) {
        stm.onModelRemoveChild(this, childRecords, context);
      }
    }
    (_super$afterRemoveChi = super.afterRemoveChild) === null || _super$afterRemoveChi === void 0 ? void 0 : _super$afterRemoveChi.call(this, childRecords, beforeResult, isMove);
  }
};
var defaultTraverseOptions$1 = {
  includeFilteredOutRecords: false
};
var fixTraverseOptions$1 = (options) => {
  options = options || false;
  if (typeof options === "boolean") {
    options = {
      includeFilteredOutRecords: options
    };
  }
  return options || defaultTraverseOptions$1;
};
var TreeNode = (Target) => class TreeNode extends (Target || Base) {
  static get $name() {
    return "TreeNode";
  }
  static set convertEmptyParentToLeaf(value) {
    if (value === true) {
      value = {
        onLoad: true,
        onRemove: true
      };
    } else if (value === false) {
      value = {
        onLoad: false,
        onRemove: false
      };
    }
    this._convertEmptyParentToLeaf = value;
  }
  static get convertEmptyParentToLeaf() {
    return this._convertEmptyParentToLeaf || {
      onLoad: false,
      onRemove: false
    };
  }
  ingestChildren(childRecord, stores = this.stores) {
    const {
      inProcessChildren,
      constructor: MyClass
    } = this, store = stores[0];
    if (childRecord === true) {
      if (inProcessChildren) {
        return true;
      }
      return [];
    }
    if (childRecord) {
      childRecord = ArrayHelper.asArray(childRecord);
      const len = childRecord.length, result = [];
      for (let i = 0, child; i < len; i++) {
        child = childRecord[i];
        child = child.isModel ? child : store ? store.createRecord(child, false, true) : new MyClass(child, null, null, true);
        child = store ? store.processRecord(child) : child;
        result.push(child);
      }
      if (this.children === true && store) {
        const sorter = store.createSorterFn(store.sorters);
        result.sort(sorter);
      }
      return result;
    }
  }
  processChildren(stores = this.stores) {
    const me = this, {
      meta
    } = me;
    me.inProcessChildren = true;
    const children = me.ingestChildren(me.data[me.constructor.childrenField], stores);
    if (children) {
      const {
        convertEmptyParentToLeaf
      } = me.constructor, shouldConvert = convertEmptyParentToLeaf === true || convertEmptyParentToLeaf.onLoad;
      if (shouldConvert ? children.length : Array.isArray(children)) {
        meta.isLeaf = false;
        if (me.children === true) {
          me.children = [];
        } else if (children.length === 0) {
          me.children = children;
          return;
        }
        me.appendChild(children);
      } else if (children === true) {
        meta.isLeaf = false;
        me.children = true;
      } else if (!me.isRoot) {
        meta.isLeaf = me.constructor.convertEmptyParentToLeaf.onLoad;
      }
    }
    me.inProcessChildren = false;
  }
  ancestorsExpanded(store = this.firstStore) {
    const {
      parent
    } = this;
    return !parent || parent.isExpanded(store) && parent.ancestorsExpanded(store);
  }
  isExpanded(store = this.firstStore) {
    const mapMeta = this.instanceMeta(store.id);
    if (!Object.prototype.hasOwnProperty.call(mapMeta, "collapsed")) {
      mapMeta.collapsed = !this.expanded;
    }
    return !mapMeta.collapsed;
  }
  get expanded() {
    return this.data.expanded;
  }
  get childLevel() {
    let node = this, ret = -1;
    while (node && !node.isRoot) {
      ++ret;
      node = node.parent;
    }
    return ret;
  }
  get isLeaf() {
    return this.meta.isLeaf !== false && !this.isRoot;
  }
  get isParent() {
    return !this.isLeaf;
  }
  get isLoaded() {
    return this.isParent && Array.isArray(this.children);
  }
  get descendantCount() {
    return this.getDescendantCount();
  }
  get visibleDescendantCount() {
    return this.getDescendantCount(true);
  }
  getDescendantCount(onlyVisible = false, store = this.firstStore) {
    const children = this.children;
    if (!children || !Array.isArray(children) || onlyVisible && !this.isExpanded(store)) {
      return 0;
    }
    return children.reduce((count, child) => count + child.getDescendantCount(onlyVisible), children.length);
  }
  get allChildren() {
    const children = this.children;
    if (!children)
      return [];
    return children.reduce((all, child) => {
      all.push(child);
      all.push.apply(all, child.allChildren);
      return all;
    }, []);
  }
  get firstChild() {
    const children = this.children;
    return (children === null || children === void 0 ? void 0 : children.length) && children[0] || null;
  }
  get lastChild() {
    const children = this.children;
    return (children === null || children === void 0 ? void 0 : children.length) && children[children.length - 1] || null;
  }
  get previousSiblingsTotalCount() {
    let task = this.previousSibling, count = this.parentIndex;
    while (task) {
      count += task.descendantCount;
      task = task.previousSibling;
    }
    return count;
  }
  get previousOrderedSibling() {
    var _this$parent;
    return (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.orderedChildren[this.orderedParentIndex - 1];
  }
  get nextOrderedSibling() {
    var _this$parent2;
    return (_this$parent2 = this.parent) === null || _this$parent2 === void 0 ? void 0 : _this$parent2.orderedChildren[this.orderedParentIndex + 1];
  }
  get root() {
    var _this$parent3;
    return ((_this$parent3 = this.parent) === null || _this$parent3 === void 0 ? void 0 : _this$parent3.root) || this;
  }
  get parentId() {
    return this.parent && !this.parent.isAutoRoot ? this.parent.id : null;
  }
  set parentId(parentId) {
    const me = this, {
      parent
    } = me, newParent = parentId === null ? me.firstStore.rootNode : me.firstStore.getById(parentId);
    if (!(newParent === parent || !parent && !newParent)) {
      if (me.isBatchUpdating) {
        me.meta.batchChanges.parentId = parentId;
      } else {
        if (newParent) {
          newParent.appendChild(me);
        } else {
          me.parent.removeChild(me);
        }
      }
    }
  }
  static set parentIdField(parentIdField) {
    this._parentIdField = parentIdField;
    Object.defineProperty(this.prototype, parentIdField, {
      set: function(parentId) {
        this.parentId = parentId;
      },
      get: function() {
        return this.parentId;
      }
    });
  }
  static get parentIdField() {
    return this._parentIdField || "parentId";
  }
  getChildren(options) {
    let result;
    if (options.includeFilteredOutRecords) {
      result = this.unfilteredChildren || this.children;
    } else if (options.useOrderedTree) {
      result = this.orderedChildren;
    } else {
      result = this.children;
    }
    return result;
  }
  traverse(fn, skipSelf, options) {
    options = fixTraverseOptions$1(options);
    const me = this, children = me.getChildren(options);
    if (!skipSelf) {
      fn.call(me, me);
    }
    for (let i = 0, l = children === null || children === void 0 ? void 0 : children.length; i < l; i++) {
      children[i].traverse(fn, false, options);
    }
  }
  traverseBefore(fn, skipSelf, options) {
    options = fixTraverseOptions$1(options);
    const me = this, children = me.getChildren(options);
    for (let i = 0, l = children === null || children === void 0 ? void 0 : children.length; i < l; i++) {
      children[i].traverse(fn, false, options);
    }
    if (!skipSelf) {
      fn.call(me, me);
    }
  }
  traverseWhile(fn, skipSelf, options) {
    options = fixTraverseOptions$1(options);
    const me = this;
    let goOn = skipSelf || fn.call(me, me) !== false;
    if (goOn) {
      const children = me.getChildren(options);
      if (children !== null && children !== void 0 && children.length) {
        goOn = children.every((child) => child.traverseWhile(fn, false, options));
      }
    }
    return goOn;
  }
  bubble(fn, skipSelf = false) {
    let me = this;
    if (!skipSelf) {
      fn.call(me, me);
    }
    while (me.parent) {
      me = me.parent;
      fn.call(me, me);
    }
  }
  bubbleWhile(fn, skipSelf = false) {
    let me = this, goOn = true;
    if (!skipSelf) {
      goOn = fn.call(me, me);
    }
    while (goOn && me.parent) {
      me = me.parent;
      goOn = fn.call(me, me);
    }
    return goOn;
  }
  contains(childOrId, skipSelf = false) {
    if (childOrId && typeof childOrId === "object") {
      childOrId = childOrId.id;
    }
    return !this.traverseWhile((node) => node.id != childOrId, skipSelf);
  }
  getTopParent(all) {
    let result;
    if (all) {
      result = [];
      this.bubbleWhile((t) => {
        result.push(t);
        return t.parent && !t.parent.isRoot;
      });
    } else {
      result = null;
      this.bubbleWhile((t) => {
        if (!t.parent) {
          result = t;
        }
        return t.parent && !t.parent.isRoot;
      });
    }
    return result;
  }
  appendChild(childRecord, silent = false) {
    return this.insertChild(childRecord, null, silent);
  }
  insertChild(childRecord, before = null, silent = false, options = {}) {
    var _ref, _before$parentIndex, _before, _me$children2, _me$beforeInsertChild, _me$afterInsertChild;
    const me = this, returnArray = Array.isArray(childRecord);
    childRecord = ArrayHelper.asArray(childRecord);
    if (typeof before === "number") {
      var _me$children$before, _me$children;
      before = (_me$children$before = (_me$children = me.children) === null || _me$children === void 0 ? void 0 : _me$children[before]) !== null && _me$children$before !== void 0 ? _me$children$before : null;
    }
    if (!silent && !me.stores.every((s) => s.trigger("beforeAdd", {
      records: childRecord,
      parent: me
    }) !== false)) {
      return null;
    }
    childRecord = me.ingestChildren(childRecord);
    const index = (_ref = (_before$parentIndex = (_before = before) === null || _before === void 0 ? void 0 : _before.parentIndex) !== null && _before$parentIndex !== void 0 ? _before$parentIndex : (_me$children2 = me.children) === null || _me$children2 === void 0 ? void 0 : _me$children2.length) !== null && _ref !== void 0 ? _ref : 0, preResult = (_me$beforeInsertChild = me.beforeInsertChild) === null || _me$beforeInsertChild === void 0 ? void 0 : _me$beforeInsertChild.call(me, childRecord), inserted = me.internalAppendInsert(childRecord, before, silent, options);
    if (inserted.length) {
      me.convertToParent(silent);
    }
    (_me$afterInsertChild = me.afterInsertChild) === null || _me$afterInsertChild === void 0 ? void 0 : _me$afterInsertChild.call(me, index, childRecord, preResult, inserted);
    return returnArray || !inserted ? inserted : inserted[0];
  }
  convertToParent(silent = false) {
    const me = this, wasLeaf = me.isLeaf;
    me.meta.isLeaf = false;
    if (!me.children) {
      me.children = [];
    }
    if (wasLeaf && !me.root.isLoading && !silent) {
      me.signalNodeChanged({
        isLeaf: {
          value: false,
          oldValue: true
        }
      });
    }
  }
  signalNodeChanged(changes) {
    this.stores.forEach((s) => {
      s.trigger("update", {
        record: this,
        records: [this],
        changes
      });
      s.trigger("change", {
        action: "update",
        record: this,
        records: [this],
        changes
      });
    });
  }
  tryInsertChild() {
    return this.insertChild(...arguments);
  }
  internalAppendInsert(recordsToInsert, beforeRecord, silent, options) {
    const me = this, {
      stores,
      root: root2
    } = me, {
      firstStore: rootStore
    } = root2, {
      parentIdField
    } = me.constructor, parentId = me.isAutoRoot ? null : me.id, oldParentIndices = [], isMove = {};
    let isNoop, start, i, newRecordsCloned;
    if (!root2.isLoading) {
      for (i = 0; i < recordsToInsert.length; i++) {
        const newRecord = recordsToInsert[i];
        isMove[newRecord.id] = newRecord.root === root2;
        oldParentIndices[i] = newRecord.parentIndex;
      }
    }
    if (beforeRecord && beforeRecord.parent !== me) {
      beforeRecord = null;
    }
    if (me.children) {
      const children = me.children, insertAt = beforeRecord ? beforeRecord.parentIndex : children.length;
      if (children[start = insertAt] === recordsToInsert[0] || children[start = insertAt - 1] === recordsToInsert[0]) {
        for (isNoop = true, i = 0; isNoop && i < recordsToInsert.length; i++) {
          if (recordsToInsert[i] !== children[start + i]) {
            isNoop = false;
          }
        }
      }
    }
    if (isNoop) {
      return recordsToInsert;
    }
    for (i = 0; i < recordsToInsert.length; i++) {
      const newRecord = recordsToInsert[i], oldParent = newRecord.parent;
      if (rootStore && !root2.isLoading) {
        newRecord.traverse((r) => {
          if (r.root === root2) {
            isMove[r.id] = true;
          }
        });
      }
      if ((oldParent === null || oldParent === void 0 ? void 0 : oldParent.removeChild(newRecord, isMove[newRecord.id], silent, _objectSpread2({
        isInserting: true
      }, options))) === false) {
        if (!newRecordsCloned) {
          recordsToInsert = recordsToInsert.slice();
          newRecordsCloned = true;
        }
        recordsToInsert.splice(i--, 1);
      } else {
        newRecord.parent = me;
        newRecord.data[parentIdField] = parentId;
        if (oldParent) {
          newRecord.meta.oldParentId = oldParent.id;
        }
      }
    }
    if (recordsToInsert.length) {
      if (!Array.isArray(me.children)) {
        me.children = [];
      }
      if (!Array.isArray(me.orderedChildren)) {
        me.orderedChildren = [];
      }
      const insertAt = me.addToChildren(beforeRecord, recordsToInsert, options);
      stores.forEach((store) => {
        if (!store.isChained) {
          recordsToInsert.forEach((record) => {
            record.joinStore(store);
          });
          store.onNodeAddChild(me, recordsToInsert, insertAt, isMove, silent);
          recordsToInsert.forEach((record, i2) => {
            if (record.meta.oldParentId != null && !(me.inProcessChildren || me.isLoading)) {
              const toSet = {
                [parentIdField]: parentId,
                [me.getDataSource("parentIndex")]: record.parentIndex
              }, wasSet = {}, {
                modified,
                oldParentId
              } = record.meta, oldParentIndex = oldParentIndices[i2];
              delete record.meta.oldParentId;
              if (me.id !== oldParentId) {
                wasSet[parentIdField] = {
                  value: parentId,
                  oldValue: oldParentId
                };
              }
              if (record.parentIndex !== oldParentIndex) {
                wasSet.parentIndex = {
                  value: record.parentIndex,
                  oldValue: oldParentIndex
                };
              }
              if (modified[parentIdField] === me.id) {
                Reflect.deleteProperty(modified, parentIdField);
              } else if (!(parentIdField in modified)) {
                modified[parentIdField] = oldParentId;
              }
              record.afterChange(toSet, wasSet);
            }
          });
        }
      });
    }
    return recordsToInsert;
  }
  removeChild(childRecords, isMove = false, silent = false, options = {}) {
    var _me$beforeRemoveChild, _me$afterRemoveChild;
    const me = this, allRemovedRecords = [], wasLeaf = me.isLeaf, {
      children,
      stores
    } = me;
    childRecords = ArrayHelper.asArray(childRecords);
    childRecords = childRecords.filter((r) => r.parent === me);
    if (!silent) {
      for (const store of stores) {
        if (!store.isChained && store.trigger("beforeRemove", {
          parent: me,
          records: childRecords,
          isMove
        }) === false) {
          return false;
        }
      }
    }
    const preResult = (_me$beforeRemoveChild = me.beforeRemoveChild) === null || _me$beforeRemoveChild === void 0 ? void 0 : _me$beforeRemoveChild.call(me, childRecords, isMove);
    for (const childRecord of childRecords) {
      const {
        parentIdField
      } = childRecord.constructor, {
        modified
      } = childRecord.meta, oldParentId = childRecord.parent ? childRecord.parent.id : null;
      if (!(parentIdField in modified) && !childRecord.isLinked) {
        modified[parentIdField] = oldParentId;
      }
      const index = me.removeFromChildren(childRecord, options);
      stores.forEach((store) => {
        if (!store.isChained) {
          const {
            isRemoving
          } = store;
          store.isRemoving = true;
          allRemovedRecords.push(...store.onNodeRemoveChild(me, [childRecord], index, {
            isMove,
            silent
          }));
          store.isRemoving = isRemoving;
        }
      });
      if (!isMove) {
        childRecord.parent = childRecord.parentIndex = childRecord.unfilteredIndex = childRecord.nextSibling = childRecord.previousSibling = null;
        childRecord.data[parentIdField] = null;
      }
    }
    if ((me.unfilteredChildren || children).length === 0 && me.constructor.convertEmptyParentToLeaf.onRemove && !me.isRoot) {
      me.meta.isLeaf = true;
    }
    if (me.isLeaf !== wasLeaf && !silent) {
      me.stores.forEach((s) => {
        const changes = {
          isLeaf: {
            value: true,
            oldValue: false
          }
        };
        s.trigger("update", {
          record: me,
          changes
        });
        s.trigger("change", {
          action: "update",
          record: me,
          changes
        });
      });
    }
    (_me$afterRemoveChild = me.afterRemoveChild) === null || _me$afterRemoveChild === void 0 ? void 0 : _me$afterRemoveChild.call(me, childRecords, preResult, isMove);
    return allRemovedRecords;
  }
  clearParentId() {
    const me = this;
    Reflect.deleteProperty(me.data, me.parentIdField);
    Reflect.deleteProperty(me.originalData, me.parentIdField);
    if (me.meta.modified) {
      Reflect.deleteProperty(me.meta.modified, me.parentIdField);
    }
  }
  replaceChildren(newChildren) {
    this.clearChildren();
    this.data[this.constructor.childrenField] = newChildren;
    this.processChildren();
    return this.children;
  }
  clearChildren(silent = false) {
    const me = this, {
      stores
    } = me, children = me.unfilteredChildren || me.children;
    me.children = [];
    me.orderedChildren = [];
    if (children && children !== true) {
      stores.forEach((store) => {
        if (!store.isChained) {
          store.onNodeRemoveChild(me, children, 0, {
            unfiltered: true,
            silent
          });
        }
      });
      if (me.unfilteredChildren) {
        me.unfilteredChildren = [];
      }
    }
  }
  clear() {
    var _me$children3;
    const me = this, {
      stores
    } = me, children = (_me$children3 = me.children) === null || _me$children3 === void 0 ? void 0 : _me$children3.slice();
    if (!me.isRoot || !children) {
      return;
    }
    for (const store of stores) {
      if (!store.isChained) {
        if (store.trigger("beforeRemove", {
          parent: me,
          records: children,
          isMove: false,
          removingAll: true
        }) === false) {
          return false;
        }
      }
    }
    me.children.length = 0;
    if (me.unfilteredChildren) {
      me.unfilteredChildren.length = 0;
    }
    stores.forEach((store) => {
      children.forEach((child) => {
        if (child.stores.includes(store)) {
          child.unjoinStore(store);
        }
        child.parent = child.parentIndex = child.nextSibling = child.previousSibling = null;
      });
      store.storage.suspendEvents();
      store.storage.clear();
      store.storage.resumeEvents();
      store.added.clear();
      store.modified.clear();
      store.trigger("removeAll");
      store.trigger("change", {
        action: "removeall"
      });
    });
  }
  updateChildrenIndices(children, indexName, silent = false) {
    let previousSibling = null;
    for (let i = 0; i < children.length; i++) {
      const child = children[i], oldValue = child[indexName];
      if (indexName === "parentIndex" || indexName === "orderedParentIndex") {
        if (oldValue === void 0 || silent) {
          child.setData(indexName, i);
        } else if (oldValue !== i) {
          child.set(indexName, i, true);
        }
      } else {
        child[indexName] = i;
      }
      if (indexName === "parentIndex") {
        child.previousSibling = previousSibling;
        if (previousSibling) {
          previousSibling.nextSibling = child;
        }
        if (i === children.length - 1) {
          child.nextSibling = null;
        }
        previousSibling = child;
      }
    }
  }
  addToChildren(beforeRecord, newRecords, options = {}) {
    var _options$orderedBefor;
    const me = this, configs = [[me.children, "parentIndex", beforeRecord], [me.unfilteredChildren, "unfilteredIndex", beforeRecord], [me.orderedChildren, "orderedParentIndex", (_options$orderedBefor = options === null || options === void 0 ? void 0 : options.orderedBeforeNode) !== null && _options$orderedBefor !== void 0 ? _options$orderedBefor : beforeRecord]];
    for (const config of configs) {
      const [children, indexName, beforeRecord2] = config;
      if (children) {
        var _options$indexName;
        const index = beforeRecord2 ? beforeRecord2[indexName] : children.length;
        config.push(index);
        children.splice(index, 0, ...newRecords);
        if (!(options !== null && options !== void 0 && (_options$indexName = options[indexName]) !== null && _options$indexName !== void 0 && _options$indexName.skip)) {
          me.updateChildrenIndices(children, indexName);
        }
      }
    }
    return configs[0][3];
  }
  removeFromChildren(childRecord, options) {
    const configs = [[this.children, "parentIndex"], [this.unfilteredChildren, "unfilteredIndex"], [this.orderedChildren, "orderedParentIndex"]];
    for (const config of configs) {
      const [children, indexName] = config;
      if (children) {
        const index = children.indexOf(childRecord);
        config.push(index);
        if (index > -1) {
          var _options$indexName2;
          children.splice(index, 1);
          if (!(options !== null && options !== void 0 && (_options$indexName2 = options[indexName]) !== null && _options$indexName2 !== void 0 && _options$indexName2.skip)) {
            this.updateChildrenIndices(children, indexName);
          }
        }
      }
    }
    return configs[0][2];
  }
  sortOrderedChildren(deep = true, usePreviousOrder = false) {
    const movedNodes = [];
    if (!this.isLeaf) {
      this.orderedChildren.sort((a, b) => {
        if (usePreviousOrder) {
          var _a$meta$modified$orde, _b$meta$modified$orde;
          const aPrevIndex = (_a$meta$modified$orde = a.meta.modified.orderedParentIndex) !== null && _a$meta$modified$orde !== void 0 ? _a$meta$modified$orde : a.orderedParentIndex, bPrevIndex = (_b$meta$modified$orde = b.meta.modified.orderedParentIndex) !== null && _b$meta$modified$orde !== void 0 ? _b$meta$modified$orde : b.orderedParentIndex, result = aPrevIndex - bPrevIndex;
          if (result !== 0) {
            movedNodes.push(a);
            movedNodes.push(b);
          }
          return result;
        } else {
          return a.orderedParentIndex - b.orderedParentIndex;
        }
      });
      if (deep) {
        this.orderedChildren.forEach((child) => {
          movedNodes.push(...child.sortOrderedChildren(deep, usePreviousOrder));
        });
      }
      this.updateChildrenIndices(this.orderedChildren, "orderedParentIndex", true);
    }
    return new Set(movedNodes);
  }
};
var propertyOverrides = {
  id: 1,
  stores: 1,
  parentIndex: 1,
  parent: 1,
  previousSibling: 1,
  nextSibling: 1,
  unfilteredIndex: 1
};
var proxyConfig = {
  get(target, prop) {
    if (prop === "proxyMeta") {
      return this.proxyMeta;
    }
    if (prop === "constructor") {
      return target.constructor;
    }
    if (prop === "setData") {
      return this.setDataOverride;
    }
    if (prop === "set") {
      return this.setOverride;
    }
    if (propertyOverrides[prop]) {
      return this.proxyMeta.data[prop];
    }
    return Reflect.get(target, prop, this.proxyRecord);
  },
  set(target, prop, value) {
    if (propertyOverrides[prop]) {
      this.proxyMeta.data[prop] = value;
    } else {
      target[prop] = value;
    }
    return true;
  },
  setDataOverride(toSet, value) {
    if (toSet === "parentIndex") {
      this.proxyMeta.data.parentIndex = value;
    } else {
      this.proxyMeta.originalRecord.setData(toSet, value);
    }
  },
  setOverride(field, value, ...args) {
    if (field === "parentIndex") {
      this.proxyMeta.data.parentIndex = value;
    } else {
      this.proxyMeta.originalRecord.set(field, value, ...args);
    }
  }
};
var ModelLink = (Target) => {
  var _class;
  return _class = class ModelLink extends (Target || Base) {
    link() {
      if (this.isLinked) {
        return this.$original.link();
      }
      const me = this, useConfig = _objectSpread2(_objectSpread2({}, proxyConfig), {}, {
        proxyMeta: {
          originalRecord: me,
          data: {
            id: `${me.id}_link_${StringHelper.generateUUID()}`,
            stores: []
          }
        }
      }), proxyRecord = new Proxy(me, useConfig);
      useConfig.proxyRecord = proxyRecord;
      (me.meta.linkedRecords || (me.meta.linkedRecords = [])).push(proxyRecord);
      return proxyRecord;
    }
    get isLinked() {
      var _this$proxyMeta;
      return Boolean((_this$proxyMeta = this.proxyMeta) === null || _this$proxyMeta === void 0 ? void 0 : _this$proxyMeta.originalRecord);
    }
    get hasLinks() {
      return Boolean(!this.proxyMeta && this.$links.length);
    }
    removeLink(link, records = null, silent = false) {
      if (link.hasLinks) {
        for (const linked of link.$links.slice()) {
          if (records) {
            ArrayHelper.include(records, linked);
          } else {
            linked.remove(silent);
          }
        }
      } else if (link.isLinked) {
        ArrayHelper.remove(link.$original.$links, link);
      }
    }
    beforeRemove(records) {
      this.removeLink(this, records);
    }
    removeChild(childRecords, isMove, silent, options) {
      if (!(options !== null && options !== void 0 && options.isInserting)) {
        childRecords = ArrayHelper.asArray(childRecords);
        for (const child of childRecords) {
          this.removeLink(child, null, silent);
        }
      }
      return super.removeChild(childRecords, isMove, silent, options);
    }
    get $originalId() {
      return this.$original.id;
    }
    get $links() {
      var _this$meta$linkedReco;
      return (_this$meta$linkedReco = this.meta.linkedRecords) !== null && _this$meta$linkedReco !== void 0 ? _this$meta$linkedReco : [];
    }
  }, _defineProperty(_class, "$name", "ModelLink"), _class;
};
var {
  defineProperty: defineProperty$4
} = Reflect;
var ownerSymbol = Symbol("owner");
var typeSplitRe = /[\s,]+/;
var Factoryable = (Target) => class Factoryable extends (Target || Base) {
  static get $name() {
    return "Factoryable";
  }
  static get declarable() {
    return [
      "factoryable",
      "alias",
      "type"
    ];
  }
  static register(type, cls, replace = globalThis.__BRYNTUM_EXAMPLE) {
    const {
      factoryable
    } = this.initClass(), {
      caseless,
      registry: registry2
    } = factoryable, types = StringHelper.split(type, typeSplitRe);
    for (let lower, name, i = 0; i < types.length; ++i) {
      name = types[i];
      lower = caseless ? name.toLowerCase() : name;
      if (!replace && lower in registry2) {
        throw new Error(`Type "${name}" already registered with ${factoryable.class.name} factory`);
      }
      registry2[name] = registry2[lower] = cls.initClass();
    }
  }
  static isA(instance, type) {
    return this.isType(instance, type, true);
  }
  static isType(instance, type, deep) {
    const {
      factoryable
    } = this, {
      caseless,
      registry: registry2
    } = factoryable, typeCls = registry2[caseless ? type.toLowerCase() : type];
    if (typeCls) {
      if (deep) {
        return instance instanceof typeCls;
      }
      return instance.constructor === typeCls;
    }
    return false;
  }
  static setupAlias(cls) {
    cls.register(cls.alias, cls);
  }
  static setupFactoryable(cls, meta) {
    const superClass = meta.super.class;
    let {
      factoryable
    } = cls;
    factoryable = _objectSpread2({
      caseless: true,
      defaultType: null,
      extends: superClass.factoryable ? [superClass] : null,
      typeKey: "type"
    }, factoryable);
    factoryable.class = cls;
    factoryable.registry = /* @__PURE__ */ Object.create(null);
    if (factoryable.extends && !Array.isArray(factoryable.extends)) {
      factoryable.extends = [factoryable.extends];
    }
    defineProperty$4(cls, "factoryable", {
      get() {
        return factoryable;
      }
    });
  }
  static setupType(cls, meta) {
    const {
      type
    } = cls;
    cls.register(type, cls, meta.replaceType);
    defineProperty$4(cls.prototype, "type", {
      value: type
    });
  }
  static create(config, options) {
    return this.reconfigure(null, config, options);
  }
  static reconfigure(existingInstance, config, options) {
    const me = this, {
      factoryable
    } = me, {
      typeKey
    } = factoryable;
    let defaultType = options, cleanup, defaults, mergeType, owner, prepared, setup, t, transform, type;
    if (options && !ObjectHelper.isClass(options)) {
      defaultType = null;
      t = typeof options;
      if (t === "function") {
        setup = options;
      } else if (t === "string") {
        defaultType = options;
      } else if (ObjectHelper.isObject(options)) {
        cleanup = options.cleanup;
        defaults = options.defaults;
        owner = options.owner;
        setup = options.setup;
        defaultType = options.type;
        transform = options.transform;
      } else {
        owner = options;
      }
    }
    if (transform) {
      config = typeof transform === "string" ? owner[transform](config) : transform(config);
    }
    type = config;
    if (typeof type === "string") {
      config = {};
    } else if (config) {
      if (config === true) {
        config = {};
      }
      if (!ObjectHelper.isObject(config)) {
        if (owner && config !== existingInstance && (existingInstance === null || existingInstance === void 0 ? void 0 : existingInstance[ownerSymbol]) === owner) {
          var _cleanup;
          typeof cleanup === "string" ? owner[cleanup](existingInstance) : (_cleanup = cleanup) === null || _cleanup === void 0 ? void 0 : _cleanup(existingInstance);
          existingInstance.destroy();
        }
        return config;
      }
      type = config[typeKey];
    }
    type = type && me.resolveType(type);
    if (existingInstance) {
      if (config && (!type || existingInstance.constructor === type)) {
        if (typeKey in config) {
          config = ObjectHelper.assign({}, config);
          delete config[typeKey];
        }
        existingInstance.setConfig(config);
        return existingInstance;
      }
      if (owner && existingInstance[ownerSymbol] === owner) {
        var _cleanup2;
        typeof cleanup === "string" ? owner[cleanup](existingInstance) : (_cleanup2 = cleanup) === null || _cleanup2 === void 0 ? void 0 : _cleanup2(existingInstance);
        existingInstance.destroy();
      }
    }
    if (config) {
      if (defaults) {
        if (!(mergeType = type)) {
          if (!(mergeType = defaults[typeKey] || defaultType || factoryable.defaultType)) {
            throw new Error(`No default mergeType defined for ${factoryable.class.name} factory`);
          }
          mergeType = me.resolveType(mergeType);
        }
        if (mergeType) {
          config = mergeType.mergeConfigs(defaults, config);
        }
      }
      if (setup) {
        prepared = typeof setup === "string" ? owner[setup](config, type, defaults) : setup(config, type, defaults);
        if (prepared === null) {
          return prepared;
        }
        config = prepared || config;
      }
      if (!type) {
        if (!(type = config[typeKey] || defaultType || factoryable.defaultType)) {
          throw new Error(`No default type defined for ${factoryable.class.name} factory`);
        }
        type = me.resolveType(type);
      }
      if (defaults && !mergeType) {
        config = type.mergeConfigs(defaults, config);
      }
      if (typeKey in config) {
        config = ObjectHelper.assign({}, config);
        delete config[typeKey];
      }
      config = new type(config);
      if (owner) {
        config[ownerSymbol] = owner;
      }
    }
    return config || null;
  }
  static resolveType(type, optional) {
    if (typeof type !== "string") {
      return type;
    }
    const {
      factoryable
    } = this, bases = factoryable.extends;
    let result = factoryable.registry[factoryable.caseless ? type.toLowerCase() : type], i;
    for (i = 0; !result && bases && i < bases.length; ++i) {
      result = bases[i].resolveType(type, true);
    }
    if (!result && !optional) {
      throw new Error(`Invalid type name "${type}" passed to ${factoryable.class.name} factory`);
    }
    return result;
  }
};
var {
  getOwnPropertyDescriptor
} = Reflect;
var DataField = class extends Base.mixin(Factoryable) {
  static get $name() {
    return "DataField";
  }
  static get type() {
    return "auto";
  }
  static get factoryable() {
    return {
      defaultType: "auto"
    };
  }
  static get prototypeProperties() {
    return {
      compare: null,
      compareItems: null,
      dataSource: null,
      alwaysWrite: false,
      nullable: true,
      nullText: null,
      nullValue: void 0,
      persist: true,
      readOnly: false,
      internal: false
    };
  }
  construct(config) {
    const me = this;
    if (config) {
      me.name = config.name;
      Object.assign(me, config);
    }
    if (me.compare) {
      me.compareItems = (itemA, itemB) => me.compare(itemA === null || itemA === void 0 ? void 0 : itemA[me.name], itemB === null || itemB === void 0 ? void 0 : itemB[me.name]);
    }
  }
  defineAccessor(target, force) {
    const {
      name,
      dataSource
    } = this;
    if (!force && name in target && target.$meta.hierarchy.some((current) => {
      var _getOwnPropertyDescri;
      return ((_getOwnPropertyDescri = getOwnPropertyDescriptor(current.prototype, name)) === null || _getOwnPropertyDescri === void 0 ? void 0 : _getOwnPropertyDescri.enumerable) === false;
    })) {
      return;
    }
    Reflect.defineProperty(target, name, {
      configurable: true,
      enumerable: true,
      get: this.complexMapping ? function() {
        return this.complexGet(name, dataSource);
      } : function() {
        if (this.batching && name in this.meta.batchChanges) {
          return this.meta.batchChanges[name];
        }
        return dataSource in this.data ? this.data[dataSource] : this.data[name];
      },
      set(value) {
        const field = this.$meta.fields.map[name];
        if (!(field && field.readOnly)) {
          this.set(name, value);
        }
      }
    });
  }
  isEqual(first, second) {
    return ObjectHelper.isEqual(first, second);
  }
  print(value) {
    return value == null ? this.nullText : this.printValue(value);
  }
  printValue(value) {
    return String(value);
  }
};
DataField._$name = "DataField";
var ArrayDataField = class extends DataField {
  static get $name() {
    return "ArrayDataField";
  }
  static get type() {
    return "array";
  }
  isEqual(a, b) {
    return a === b;
  }
};
ArrayDataField.initClass();
ArrayDataField._$name = "ArrayDataField";
var BooleanDataField = class extends DataField {
  static get $name() {
    return "BooleanDataField";
  }
  static get type() {
    return "boolean";
  }
  static get alias() {
    return "bool";
  }
  static get prototypeProperties() {
    return {
      nullValue: false
    };
  }
  isEqual(first, second) {
    if (first == null && second == null) {
      return true;
    }
    return super.isEqual(first, second);
  }
  convert(value) {
    var _value$toLowerCase;
    if (value == null) {
      return this.nullable ? value : this.nullValue;
    }
    if (((_value$toLowerCase = value.toLowerCase) === null || _value$toLowerCase === void 0 ? void 0 : _value$toLowerCase.call(value)) === "false") {
      return false;
    }
    return Boolean(value);
  }
};
BooleanDataField.initClass();
BooleanDataField._$name = "BooleanDataField";
var DateDataField = class extends DataField {
  static get $name() {
    return "DateDataField";
  }
  static get type() {
    return "date";
  }
  static get prototypeProperties() {
    return {
      format: null
    };
  }
  convert(value) {
    if (value == null) {
      if (!this.nullable) {
        value = this.nullValue;
      }
    } else if (value === "now") {
      value = new Date();
    } else if (!(value instanceof Date)) {
      value = DateHelper.parse(value, this.format || DateHelper.defaultParseFormat);
      if (!value || isNaN(value)) {
        value = void 0;
      }
    }
    return value;
  }
  serialize(value) {
    if (value instanceof Date) {
      value = DateHelper.format(value, this.format || DateHelper.defaultFormat);
    }
    return value;
  }
  printValue(value) {
    return DateHelper.format(value, this.format || DateHelper.defaultFormat);
  }
};
DateDataField.initClass();
DateDataField._$name = "DateDataField";
var StringDataField = class extends DataField {
  static get $name() {
    return "StringDataField";
  }
  static get type() {
    return "string";
  }
  static get prototypeProperties() {
    return {
      nullValue: ""
    };
  }
  convert(value) {
    return value == null ? this.nullable ? value : this.nullValue : String(value);
  }
};
StringDataField.initClass();
StringDataField._$name = "StringDataField";
var DurationUnitDataField = class extends StringDataField {
  static get $name() {
    return "DurationUnitDataField";
  }
  static get type() {
    return "durationunit";
  }
  isEqual(first, second) {
    return DateHelper.compareUnits(first, second) === 0;
  }
};
DurationUnitDataField.initClass();
DurationUnitDataField._$name = "DurationUnitDataField";
var IntegerDataField = class extends DataField {
  static get $name() {
    return "IntegerDataField";
  }
  static get type() {
    return "integer";
  }
  static get alias() {
    return "int";
  }
  static get prototypeProperties() {
    return {
      nullValue: 0,
      rounding: "round"
    };
  }
  convert(value) {
    return value == null ? this.nullable ? value : this.nullValue : Math[this.rounding](Number(value));
  }
};
IntegerDataField.initClass();
IntegerDataField._$name = "IntegerDataField";
var ModelDataField = class extends DataField {
  static get $name() {
    return "ModelDataField";
  }
  static get type() {
    return "model";
  }
  static get prototypeProperties() {
    return {
      complexMapping: true
    };
  }
  isEqual(first, second) {
    return first && second && second instanceof first.constructor && second.id == first.id;
  }
};
ModelDataField.initClass();
ModelDataField._$name = "ModelDataField";
var NumberDataField = class extends DataField {
  static get $name() {
    return "NumberDataField";
  }
  static get type() {
    return "number";
  }
  static get alias() {
    return "float";
  }
  static get prototypeProperties() {
    return {
      nullValue: 0,
      precision: null
    };
  }
  isEqual(first, second) {
    return isNaN(Number(first)) && isNaN(Number(second)) || super.isEqual(first, second);
  }
  convert(value) {
    if (value == null) {
      return this.nullable ? value : this.nullValue;
    }
    value = Number(value);
    if (isNaN(value)) {
      return;
    }
    let scale = this.precision;
    if (scale) {
      scale = 10 ** scale;
      value = Math.round(value * scale) / scale;
    } else if (scale === 0) {
      value = Math.round(value);
    }
    return value;
  }
};
NumberDataField.initClass();
NumberDataField._$name = "NumberDataField";
var ObjectDataField = class extends DataField {
  static get $name() {
    return "ObjectDataField";
  }
  static get type() {
    return "object";
  }
  static get prototypeProperties() {
    return {
      complexMapping: true
    };
  }
};
ObjectDataField.initClass();
ObjectDataField._$name = "ObjectDataField";
var StoreDataField = class extends DataField {
  init(data, record) {
    var _record;
    const me = this, storeName = `${me.name}Store`, config = {
      skipStack: true
    };
    if (me.modelClass) {
      config.modelClass = me.modelClass;
    }
    (_record = record[`init${StringHelper.capitalize(storeName)}`]) === null || _record === void 0 ? void 0 : _record.call(record, config);
    if (!config.storeClass && !me.storeClass) {
      throw new Error(`Field '${me.name}' with type 'store' must have a storeClass configured`);
    }
    const store = record.meta[storeName] = new (config.storeClass || me.storeClass)(config);
    if (me.complexMapping) {
      ObjectHelper.setPath(data, me.dataSource, store);
    } else {
      data[me.dataSource] = store;
    }
    store.verifyNoGeneratedIds = false;
    store.usesId = !store.count || !store.every((record2) => record2.hasGeneratedId);
    store.$currentValue = me.getValue(store);
    store.ion({
      change: ({
        action
      }) => {
        const value = me.getValue(store);
        if (!store.$isSettingStoreFieldData) {
          const oldPreserveCurrentDataset = store.$preserveCurrentDataset;
          store.$preserveCurrentDataset = me.subStore && (action === "update" || action === "remove" || action === "add");
          record.set(me.name, value);
          store.$preserveCurrentDataset = oldPreserveCurrentDataset;
        }
        store.$currentValue = value;
      }
    });
  }
  set(value, data, record) {
    var _record2, _record3;
    const me = this, storeName = `${me.name}Store`, {
      [storeName]: store
    } = record.meta;
    if (!store) {
      record.meta.initableValues.set(me, value);
      return false;
    }
    if (store.$isSettingStoreFieldData) {
      return;
    }
    store.$isSettingStoreFieldData = true;
    value = (_record2 = (_record3 = record[`process${StringHelper.capitalize(storeName)}Data`]) === null || _record3 === void 0 ? void 0 : _record3.call(record, value, record)) !== null && _record2 !== void 0 ? _record2 : value;
    if (!store.$preserveCurrentDataset) {
      store.data = value;
    }
    store.$isSettingStoreFieldData = false;
    store.usesId = !store.count || !store.every((record2) => record2.hasGeneratedId);
  }
  serialize(value, record) {
    return record.meta[`${this.name}Store`].$currentValue;
  }
  getValue(store) {
    return store.allRecords.map((r) => {
      const data = r.persistableData;
      if (!store.usesId) {
        delete data.id;
      }
      return data;
    });
  }
  isEqual(a, b) {
    var _a, _b;
    if ((_a = a) !== null && _a !== void 0 && _a.isStore) {
      a = a.$currentValue;
    }
    if ((_b = b) !== null && _b !== void 0 && _b.isStore) {
      b = b.$currentValue;
    }
    return ObjectHelper.isDeeplyEqual(a, b);
  }
};
_defineProperty(StoreDataField, "$name", "StoreDataField");
_defineProperty(StoreDataField, "type", "store");
StoreDataField.initClass();
StoreDataField._$name = "StoreDataField";
var {
  defineProperty: defineProperty$3
} = Reflect;
var {
  hasOwn: hasOwn$1
} = ObjectHelper;
var _undefined = void 0;
var internalProps = {
  children: 1,
  data: 1,
  meta: 1
};
var abbreviationFields = ["name", "title", "text", "label", "description"];
var fieldDataTypes = {
  boolean: 1,
  number: 1,
  date: 1,
  object: 1
};
var Model = class extends Base.mixin(ModelStm, TreeNode, ModelLink) {
  static get $name() {
    return "Model";
  }
  static get declarable() {
    return [
      "fields"
    ];
  }
  static get fields() {
    return [
      {
        name: "parentIndex",
        type: "number",
        persist: false,
        internal: true
      },
      {
        name: "orderedParentIndex",
        type: "number",
        persist: false,
        internal: true
      },
      {
        name: "readOnly",
        type: "boolean"
      }
    ];
  }
  static set idField(idField) {
    this._assignedIdField = true;
    this._idField = idField;
  }
  static get idField() {
    return this._idField;
  }
  static set childrenField(childrenField) {
    this._childrenField = childrenField;
  }
  static get childrenField() {
    if (!this._childrenField) {
      const dataField = this.fieldMap.children;
      this._childrenField = (dataField === null || dataField === void 0 ? void 0 : dataField.dataSource) || "children";
    }
    return this._childrenField;
  }
  get indexPath() {
    const indices = [];
    let node = this, depth = node.childLevel;
    for (node = this; node && !node.isRoot; node = node.parent) {
      indices[depth--] = node.parentIndex + 1;
    }
    return indices;
  }
  construct(data = {}, store = null, meta = null, skipExpose = false, forceUseRaw = false, rawData = false) {
    var _ArrayHelper$asArray, _me$meta$initableValu;
    const me = this, stores = (_ArrayHelper$asArray = ArrayHelper.asArray(store)) !== null && _ArrayHelper$asArray !== void 0 ? _ArrayHelper$asArray : [], {
      constructor,
      fieldMap
    } = me;
    let configs = null;
    store = stores[0];
    me.meta = _objectSpread2(_objectSpread2({
      modified: {}
    }, constructor.metaConfig), meta);
    if (constructor.applyConfigs) {
      for (const key in me.getDefaultConfiguration()) {
        if (!configs) {
          configs = {};
          if (!me.useRawData || !me.useRawData.enabled) {
            data = _objectSpread2({}, data);
          }
        }
        if (key in data) {
          if (data[key] !== void 0) {
            configs[key] = data[key];
          }
          delete data[key];
        }
      }
    }
    super.construct(configs);
    if (!skipExpose) {
      constructor.exposeProperties(data, rawData);
    }
    if (!hasOwn$1(constructor, "idFieldProcessed")) {
      let overriddenIdField = me.meta.idField;
      if (!overriddenIdField) {
        if (constructor._assignedIdField) {
          overriddenIdField = constructor.idField;
        } else if (store) {
          overriddenIdField = store.idField;
        }
      }
      if (overriddenIdField && overriddenIdField !== fieldMap.id.dataSource) {
        constructor.addField({
          name: "id",
          dataSource: overriddenIdField,
          internal: true
        });
      }
      constructor._idField = fieldMap.id.dataSource;
      constructor.idFieldProcessed = true;
    }
    me._internalId = Model._internalIdCounter++;
    me.stores = [];
    me.unjoinedStores = [];
    if (!me.originalData) {
      me.originalData = data;
    }
    me.data = constructor.processData(data, false, store, me, forceUseRaw);
    ((_me$meta$initableValu = me.meta.initableValues) === null || _me$meta$initableValu === void 0 ? void 0 : _me$meta$initableValu.size) && me.assignInitables();
    if (me.id == null) {
      me.setData("id", me.generateId(store));
    }
    if (me.data[constructor.childrenField]) {
      me.processChildren(stores);
    }
    me.generation = 0;
  }
  set isCreating(isCreating) {
    const me = this;
    if (Boolean(me.meta.isCreating) !== isCreating) {
      me.meta.isCreating = isCreating;
      me.stores.forEach((s) => {
        s.onIsCreatingToggle(me, isCreating);
      });
    }
  }
  get isCreating() {
    return Boolean(this.meta.isCreating);
  }
  equals(other) {
    if (other instanceof this.constructor) {
      for (let fields = this.$meta.fields.defs, i = 0, {
        length
      } = fields; i < length; i++) {
        const field = fields[i], {
          name
        } = field;
        if (name !== "id" && !field.isEqual(this[name], other[name])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  get subclass() {
    return new this.constructor(Object.setPrototypeOf({
      id: _undefined
    }, this.data), this.stores[0], null, true);
  }
  static processData(data, ignoreDefaults = false, store, record, forceUseRaw) {
    const {
      fieldMap,
      defaultValues
    } = this, {
      useRawData = {
        enabled: false
      }
    } = store || {}, processed = forceUseRaw || useRawData.enabled ? data : ObjectHelper.clone(data);
    let fieldName;
    ignoreDefaults = ignoreDefaults || useRawData.disableDefaultValue || forceUseRaw;
    if (!ignoreDefaults) {
      for (fieldName in defaultValues) {
        if (processed[fieldName] === _undefined) {
          let defaultValue2 = defaultValues[fieldName];
          if (Array.isArray(defaultValue2)) {
            defaultValue2 = defaultValue2.slice();
          }
          processed[fieldName] = defaultValue2;
        }
      }
    }
    if (!useRawData.disableTypeConversion && !forceUseRaw) {
      for (fieldName in fieldMap) {
        const field = fieldMap[fieldName], {
          name,
          dataSource
        } = field, hasSource = dataSource !== name, complex = field.complexMapping, sourceExists = hasSource && (complex ? ObjectHelper.pathExists(data, dataSource) : dataSource in data), useNameForValue = name in data && (!hasSource || !sourceExists), convert = !useRawData.disableTypeConversion && field.convert;
        if (useNameForValue || convert) {
          if (!ignoreDefaults || useNameForValue || sourceExists) {
            const value = useNameForValue ? processed[name] : complex ? ObjectHelper.getPath(processed, dataSource) : processed[dataSource], converted = convert ? field.convert(value, record) : value;
            if (complex) {
              ObjectHelper.setPath(processed, dataSource, converted);
            } else {
              processed[dataSource] = converted;
            }
            if (hasSource) {
              delete processed[name];
            }
          }
        }
      }
    }
    this.$meta.fields.initable.length && this.initInitables(record, processed);
    return processed;
  }
  static setupClass(meta) {
    super.setupClass(meta);
    if (!meta.fields) {
      this.setupFields(this, meta);
    }
  }
  static setupFields(cls, meta) {
    var _base$defs$slice, _base$exposed, _base$ordinals, _base$map, _base$sources;
    const classFields = hasOwn$1(cls, "fields") && cls.fields, base = meta.super.fields, fieldsInfo = meta.fields = {
      defs: (_base$defs$slice = base === null || base === void 0 ? void 0 : base.defs.slice()) !== null && _base$defs$slice !== void 0 ? _base$defs$slice : [],
      exposedData: false,
      defaults: base ? _objectSpread2({}, base.defaults) : {},
      exposed: Object.create((_base$exposed = base === null || base === void 0 ? void 0 : base.exposed) !== null && _base$exposed !== void 0 ? _base$exposed : null),
      ordinals: Object.create((_base$ordinals = base === null || base === void 0 ? void 0 : base.ordinals) !== null && _base$ordinals !== void 0 ? _base$ordinals : null),
      map: Object.create((_base$map = base === null || base === void 0 ? void 0 : base.map) !== null && _base$map !== void 0 ? _base$map : null),
      sources: Object.create((_base$sources = base === null || base === void 0 ? void 0 : base.sources) !== null && _base$sources !== void 0 ? _base$sources : null)
    };
    if (hasOwn$1(cls, "defaults")) {
      Object.assign(fieldsInfo.defaults, cls.defaults);
    }
    if (hasOwn$1(cls, "idField")) {
      cls.addField({
        name: "id",
        dataSource: cls.idField,
        internal: true
      });
      fieldsInfo.exposed[cls.idField] = true;
    }
    if (classFields !== null && classFields !== void 0 && classFields.length) {
      classFields.map(cls.addField, cls);
    }
    fieldsInfo.initable = fieldsInfo.defs.filter((field) => field.init);
    cls.exposeRelations();
  }
  static get defaultValues() {
    return this.$meta.fields.defaults;
  }
  static get allFields() {
    return this.$meta.fields.defs;
  }
  get allFields() {
    return this.$meta.fields.defs;
  }
  static get fieldMap() {
    return this.$meta.fields.map;
  }
  get fieldMap() {
    return this.$meta.fields.map;
  }
  static get fieldDataSourceMap() {
    return this.$meta.fields.sources;
  }
  static exposeProperties(data, raw = true) {
    const me = this, fieldsInfo = me.$meta.fields, fieldMapProperty = raw ? "exposed" : "map";
    if (data && me.autoExposeFields && !fieldsInfo.exposedData) {
      let dataProperty, fieldDef, type;
      for (dataProperty in data) {
        if (!fieldsInfo[fieldMapProperty][dataProperty] && dataProperty !== me.childrenField) {
          type = ObjectHelper.typeOf(data[dataProperty]);
          fieldDef = {
            name: dataProperty,
            dataSource: dataProperty,
            fromData: true
          };
          if (fieldDataTypes[type]) {
            fieldDef.type = type;
          }
          me.addField(fieldDef);
        }
      }
      fieldsInfo.exposedData = true;
    }
    me.exposeRelations();
  }
  static addField(fieldDef) {
    if (fieldDef == null) {
      return;
    }
    if (typeof fieldDef === "string") {
      fieldDef = {
        name: fieldDef
      };
    }
    const me = this.initClass(), fieldsInfo = me.$meta.fields, {
      ordinals
    } = fieldsInfo, propertiesExposed = fieldsInfo.exposed, {
      name
    } = fieldDef, existing = fieldsInfo.map[name], dataSource = fieldDef.dataSource || (fieldDef.dataSource = name);
    let field, key;
    if (!existing || fieldDef.type && fieldDef.type !== existing.type) {
      field = DataField.create(fieldDef);
      field.definedBy = existing ? existing.definedBy : me;
      field.ordinal = existing ? existing.ordinal : ordinals[name] = fieldsInfo.defs.length;
    } else {
      field = Object.create(existing);
      for (key in fieldDef) {
        if (key !== "type") {
          field[key] = fieldDef[key];
        }
      }
    }
    field.owner = me;
    fieldsInfo.defs[field.ordinal] = field;
    fieldsInfo.map[name] = field;
    if (!fieldsInfo.sources[dataSource]) {
      fieldsInfo.sources[dataSource] = field;
    }
    if (dataSource.includes(".")) {
      field.complexMapping = true;
    }
    if (field.complexMapping) {
      propertiesExposed[dataSource.split(".")[0]] = true;
    } else {
      propertiesExposed[dataSource] = true;
    }
    if ("defaultValue" in field) {
      fieldsInfo.defaults[dataSource] = field.defaultValue;
    }
    if (!internalProps[name]) {
      field.defineAccessor(me.prototype);
    }
    me._nonPersistableFields = null;
    me._alwaysWriteFields = null;
    return field;
  }
  static removeField(fieldName) {
    const me = this.initClass(), fieldsInfo = me.$meta.fields, definition = fieldsInfo.map[fieldName], {
      ordinals
    } = fieldsInfo, index = ordinals[fieldName];
    if (definition) {
      fieldsInfo.defs.splice(index, 1);
      delete ordinals[fieldName];
      delete fieldsInfo.defaults[fieldName];
      delete fieldsInfo.exposed[fieldName];
      delete fieldsInfo.map[fieldName];
      delete fieldsInfo.sources[definition.dataSource];
      for (const name in ordinals) {
        if (ordinals[name] > index) {
          --ordinals[name];
        }
      }
      delete me.prototype[fieldName];
    }
  }
  static exposeRelations() {
    const me = this;
    if (hasOwn$1(me, "exposedRelations")) {
      return;
    }
    if (me.relations) {
      me.exposedRelations = [];
      for (const relationName in me.relations) {
        const relation = me.relations[relationName];
        relation.relationName = relationName;
        me.exposedRelations.push(relation);
        if (!Reflect.ownKeys(me.prototype).includes(relationName)) {
          defineProperty$3(me.prototype, relationName, {
            enumerable: true,
            get: function() {
              return this.getForeign(relationName);
            },
            set: function(value) {
              this.setForeign(relationName, value, relation);
            }
          });
        }
      }
    }
  }
  static initInitables(record, processedData) {
    const laterValues = record.meta.initableValues = /* @__PURE__ */ new Map();
    for (const field of this.$meta.fields.initable) {
      const value = ObjectHelper.getPath(processedData, field.dataSource);
      value !== void 0 && laterValues.set(field, value);
      !field.lazy && field.init(processedData, record);
    }
  }
  assignInitables() {
    const {
      initableValues
    } = this.meta;
    for (const [field, value] of initableValues) {
      if (field.set(value, this.data, this) !== false) {
        initableValues.delete(field);
      }
    }
  }
  static get autoExposeFields() {
    return true;
  }
  get fields() {
    return this.$meta.fields.defs;
  }
  getFieldDefinition(fieldName) {
    return this.$meta.fields.map[fieldName];
  }
  getFieldDefinitionFromDataSource(dataSource) {
    return this.$meta.fields.sources[dataSource];
  }
  get fieldNames() {
    return Object.keys(this.data);
  }
  static getFieldDefinition(fieldName) {
    return this.$meta.fields.map[fieldName];
  }
  static getFieldDataSource(fieldName) {
    return this.getFieldDefinition(fieldName).dataSource;
  }
  getDataSource(fieldName) {
    const def = this.constructor.getFieldDefinition(fieldName);
    return (def === null || def === void 0 ? void 0 : def.dataSource) || (def === null || def === void 0 ? void 0 : def.name);
  }
  static processField(fieldName, value, record) {
    const field = this.fieldMap[fieldName];
    return field !== null && field !== void 0 && field.convert ? field.convert(value, record) : value;
  }
  initRelations() {
    const me = this, relations = me.constructor.exposedRelations;
    if (!relations) {
      return;
    }
    me.stores.forEach((store) => {
      var _store$modelRelations;
      if (!store.modelRelations) {
        store.initRelations();
      }
      const relatedRecords = [];
      (_store$modelRelations = store.modelRelations) === null || _store$modelRelations === void 0 ? void 0 : _store$modelRelations.forEach((config) => {
        relatedRecords.push({
          related: me.initRelation(config),
          config
        });
      });
      store.updateRecordRelationCache(me, relatedRecords);
    });
  }
  initRelation(config) {
    const me = this, foreignId = me.get(config.foreignKey), foreign = foreignId !== _undefined && typeof config.foreignStore !== "string" && config.foreignStore.getById(foreignId), relationCache = me.meta.relationCache || (me.meta.relationCache = {});
    relationCache[config.relationName] = foreign || (foreignId != null ? {
      id: foreignId,
      placeHolder: true
    } : null);
    return foreign;
  }
  removeRelation(config) {
    const {
      relationName,
      foreignKey,
      nullFieldOnRemove
    } = config;
    if (this.meta.relationCache[relationName]) {
      delete this.meta.relationCache[relationName];
      if (nullFieldOnRemove) {
        this.setData(foreignKey, null);
      }
    }
  }
  getForeign(name) {
    var _this$meta$relationCa;
    return (_this$meta$relationCa = this.meta.relationCache) === null || _this$meta$relationCa === void 0 ? void 0 : _this$meta$relationCa[name];
  }
  setForeign(name, value, config) {
    const id = Model.asId(value);
    return this.set(config.foreignKey, id);
  }
  getRelationConfig(name) {
    var _this$firstStore, _this$firstStore$mode;
    return (_this$firstStore = this.firstStore) === null || _this$firstStore === void 0 ? void 0 : (_this$firstStore$mode = _this$firstStore.modelRelations) === null || _this$firstStore$mode === void 0 ? void 0 : _this$firstStore$mode.find((r) => r.foreignKey === name);
  }
  flatGet(fieldName, dataSource) {
    if (this.batching && fieldName in this.meta.batchChanges) {
      return this.meta.batchChanges[fieldName];
    }
    return dataSource in this.data ? this.data[dataSource] : this.data[fieldName];
  }
  complexGet(fieldName, dataSource) {
    if (this.batching && fieldName in this.meta.batchChanges) {
      return this.meta.batchChanges[fieldName];
    }
    return ObjectHelper.getPath(this.data, dataSource);
  }
  get(fieldName) {
    if (!fieldName) {
      return;
    }
    const field = this.fieldMap[fieldName];
    if (!field && fieldName.includes(".")) {
      return this.complexGet(fieldName, fieldName);
    }
    if (field !== null && field !== void 0 && field.complexMapping) {
      return this.complexGet(fieldName, field.dataSource);
    }
    return this.flatGet(fieldName, (field === null || field === void 0 ? void 0 : field.dataSource) || fieldName);
  }
  setData(toSet, value) {
    const {
      data,
      fieldMap
    } = this;
    if (typeof toSet === "string") {
      var _field$dataSource;
      const field = fieldMap[toSet], dataSource = (_field$dataSource = field === null || field === void 0 ? void 0 : field.dataSource) !== null && _field$dataSource !== void 0 ? _field$dataSource : toSet;
      if (field !== null && field !== void 0 && field.set) {
        field.set(value, this.data, this);
      } else if (field !== null && field !== void 0 && field.complexMapping) {
        ObjectHelper.setPath(data, dataSource, value);
      } else {
        data[dataSource] = value;
      }
    } else {
      const keys = Object.keys(toSet);
      for (let i = 0; i < keys.length; i++) {
        var _field$dataSource2;
        const fieldName = keys[i], field = fieldMap[fieldName], dataSource = (_field$dataSource2 = field === null || field === void 0 ? void 0 : field.dataSource) !== null && _field$dataSource2 !== void 0 ? _field$dataSource2 : fieldName;
        if (field !== null && field !== void 0 && field.set) {
          field.set(value, this.data, this);
        } else if (dataSource) {
          if (field !== null && field !== void 0 && field.complexMapping) {
            ObjectHelper.setPath(data, dataSource, toSet[fieldName]);
          } else {
            data[dataSource] = toSet[fieldName];
          }
        }
      }
    }
  }
  getData(fieldName) {
    var _field$dataSource3;
    const field = this.fieldMap[fieldName], dataSource = (_field$dataSource3 = field === null || field === void 0 ? void 0 : field.dataSource) !== null && _field$dataSource3 !== void 0 ? _field$dataSource3 : fieldName;
    if (dataSource) {
      if (field !== null && field !== void 0 && field.complexMapping) {
        return ObjectHelper.getPath(this.data, dataSource);
      }
      return this.data[dataSource];
    }
  }
  syncId(value) {
    const oldValue = this.id;
    if (oldValue !== value) {
      this.setData("id", value);
      const data = {
        id: {
          value,
          oldValue
        }
      };
      this.afterChange(data, data);
    }
  }
  set(field, value, silent = false, fromRelationUpdate = false, skipAccessors = false, validOnly = false) {
    const me = this;
    if (me.isBatchUpdating) {
      me.inBatchSet(field, value, silent || me.$silenceBatch);
      return null;
    } else {
      var _me$beforeSet, _me$afterSet;
      const preResult = (_me$beforeSet = me.beforeSet) === null || _me$beforeSet === void 0 ? void 0 : _me$beforeSet.call(me, field, value, silent, fromRelationUpdate), wasSet = me.inSet(field, value, silent, fromRelationUpdate, skipAccessors, validOnly);
      (_me$afterSet = me.afterSet) === null || _me$afterSet === void 0 ? void 0 : _me$afterSet.call(me, field, value, silent, fromRelationUpdate, preResult, wasSet);
      return wasSet;
    }
  }
  fieldToKeys(field, value) {
    if (typeof field !== "string") {
      return ObjectHelper.assign({}, field);
    }
    return {
      [field]: value
    };
  }
  inBatchSet(field, value, silent) {
    const me = this, {
      meta,
      constructor,
      fieldMap
    } = me, wasSet = {};
    let cmp, changed = false;
    if (typeof field !== "string") {
      Object.keys(me.fieldToKeys(field, value)).forEach((key) => {
        cmp = fieldMap[key] || ObjectHelper;
        value = constructor.processField(key, field[key], me);
        if (!cmp.isEqual(meta.batchChanges[key], value)) {
          wasSet[key] = {
            value,
            oldValue: me.get(key)
          };
          meta.batchChanges[key] = value;
          changed = true;
        }
      });
    } else {
      cmp = fieldMap[field] || ObjectHelper;
      if (!cmp.isEqual(meta.batchChanges[field], value)) {
        wasSet[field] = {
          value,
          oldValue: me.get(field)
        };
        meta.batchChanges[field] = value;
        changed = true;
      }
    }
    if (changed) {
      me.generation++;
      if (!silent) {
        const event = {
          action: "update",
          record: me,
          records: [me],
          changes: wasSet
        };
        me.stores.forEach((store) => {
          store.trigger("batchedUpdate", _objectSpread2({}, event));
        });
        me.forEachLinked((store, record) => store.trigger("batchedUpdate", _objectSpread2(_objectSpread2({}, event), {}, {
          record,
          records: [record]
        })));
      }
    }
  }
  inSet(field, value, silent, fromRelationUpdate, skipAccessors = false, validOnly = false) {
    const me = this, {
      data,
      meta,
      fieldMap,
      constructor
    } = me, {
      prototype: myProto,
      childrenField
    } = constructor, wasSet = {}, toSet = me.fieldToKeys(field, value), keys = Object.keys(toSet);
    let changed = false;
    if (!silent && !me.triggerBeforeUpdate(toSet)) {
      return null;
    }
    me.inSetting = true;
    for (let i = 0; i < keys.length; i++) {
      var _field$dataSource4;
      const key = keys[i];
      if (key === childrenField) {
        continue;
      }
      const field2 = fieldMap[key], cmp = field2 || ObjectHelper, readOnly = field2 === null || field2 === void 0 ? void 0 : field2.readOnly, mapping = (_field$dataSource4 = field2 === null || field2 === void 0 ? void 0 : field2.dataSource) !== null && _field$dataSource4 !== void 0 ? _field$dataSource4 : key, useProp = !skipAccessors && !field2 && key in myProto, oldValue = useProp ? me[mapping] : field2 !== null && field2 !== void 0 && field2.complexMapping ? ObjectHelper.getPath(data, mapping) : data[mapping], value2 = constructor.processField(key, toSet[key], me), val = toSet[key] = {
        value: value2
      }, relation = me.getRelationConfig(key);
      if (!readOnly && !cmp.isEqual(oldValue, value2) && (!validOnly || value2 !== void 0)) {
        me.generation++;
        val.oldValue = oldValue;
        changed = true;
        if (cmp.isEqual(me.meta.modified[key], value2)) {
          Reflect.deleteProperty(meta.modified, key);
        } else if (!me.ignoreBag) {
          if (!(key in meta.modified)) {
            me.storeFieldChange(key, oldValue);
          }
          if (val.oldValue === _undefined) {
            Reflect.deleteProperty(val, "oldValue");
          }
        }
        wasSet[key] = val;
        me.applyValue(useProp, mapping, value2, skipAccessors, field2);
        if (relation && !fromRelationUpdate) {
          me.initRelation(relation);
          me.stores.forEach((store) => store.cacheRelatedRecord(me, value2, relation.relationName, val.oldValue));
        }
      }
    }
    if (changed) {
      me.afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    me.inSetting = false;
    return changed ? wasSet : null;
  }
  applyValue(useProp, key, value, skipAccessors, field) {
    var _field, _field3;
    const me = this;
    let complexMapping = (_field = field) === null || _field === void 0 ? void 0 : _field.complexMapping;
    if (key === me.constructor.parentIdField) {
      (me.firstStore.getById(value) || me.firstStore.rootNode).insertChild(me, null, false, {
        orderedParentIndex: {
          skip: true
        }
      });
      return;
    } else if (useProp) {
      var _field2;
      me[((_field2 = field) === null || _field2 === void 0 ? void 0 : _field2.name) || key] = value;
      return;
    }
    if ((_field3 = field) !== null && _field3 !== void 0 && _field3.set) {
      field.set(value, me.data, me);
      return;
    }
    if (!field && key.includes(".")) {
      var _field4, _field5;
      const nestedName = key.split(".")[0];
      field = me.constructor.fieldMap[nestedName];
      complexMapping = ((_field4 = field) === null || _field4 === void 0 ? void 0 : _field4.complexMapping) || ((_field5 = field) === null || _field5 === void 0 ? void 0 : _field5.type) === "object";
    }
    if (complexMapping) {
      ObjectHelper.setPath(me.data, key, value);
    } else {
      me.data[key] = value;
    }
  }
  afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {
    for (const store of this.stores) {
      store.onModelChange(this, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    this.forEachLinked((store, record) => store.onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors));
  }
  forEachLinked(fn) {
    for (const linked of this.$links) {
      for (const store of linked.stores) {
        fn(store, linked);
      }
    }
  }
  get isPersistable() {
    return !this.isBatchUpdating && !this.isCreating;
  }
  get isModified() {
    return Boolean(this.meta.modified && Object.keys(this.meta.modified).length > 0);
  }
  get hasPersistableChanges() {
    return this.isPersistable && !ObjectHelper.isEmpty(this.rawModificationData);
  }
  isFieldModified(fieldName) {
    return this.isModified && fieldName in this.meta.modified;
  }
  getFieldPersistentValue(nameOrField) {
    const field = typeof nameOrField === "string" ? this.getFieldDefinition(nameOrField) : nameOrField, name = (field === null || field === void 0 ? void 0 : field.name) || nameOrField;
    let result;
    if (!field || field.persist) {
      result = this[name];
      if (field !== null && field !== void 0 && field.serialize) {
        result = field.serialize(result, this);
      }
    }
    return result;
  }
  get modifications() {
    const data = this.rawModifications;
    if (data && Object.keys(data).length) {
      data[this.constructor.idField] = this.id;
    }
    return data;
  }
  get rawModifications() {
    const me = this, data = {};
    if (!me.isModified) {
      return null;
    }
    let keySet = false;
    Object.keys(me.meta.modified).forEach((key) => {
      const value = me.getFieldPersistentValue(key);
      if (value !== _undefined) {
        data[key] = value;
        keySet = true;
      }
    });
    return keySet ? data : null;
  }
  get modificationData() {
    const data = this.rawModificationData;
    if (data && Object.keys(data).length) {
      ObjectHelper.setPath(data, this.constructor.idField, this.id);
    }
    return data;
  }
  get rawModificationData() {
    const me = this, {
      fieldMap
    } = me.constructor, data = {};
    if (!me.isModified) {
      return null;
    }
    let keySet = false;
    Object.keys(me.meta.modified).forEach((fieldName) => {
      const field = fieldMap[fieldName];
      if (field !== null && field !== void 0 && field.persist) {
        const value = me.getFieldPersistentValue(fieldName);
        if (value !== _undefined) {
          ObjectHelper.setPath(data, field.dataSource, value);
          keySet = true;
        }
      }
    });
    return keySet ? data : null;
  }
  get modificationDataToWrite() {
    const alwaysWriteFields = this.constructor.alwaysWriteFields, recordData = this.modificationData;
    alwaysWriteFields.forEach((fieldName) => {
      recordData[this.getFieldDefinition(fieldName).dataSource] = this.getFieldPersistentValue(fieldName);
    });
    return recordData;
  }
  get persistableData() {
    const me = this, data = {};
    me.fields.forEach((field) => {
      const value = me.getFieldPersistentValue(field);
      if (value !== _undefined) {
        if (field !== null && field !== void 0 && field.complexMapping) {
          ObjectHelper.setPath(data, field.dataSource, value);
        } else {
          data[field.dataSource] = value;
        }
      }
    });
    return data;
  }
  get isCommitting() {
    return Boolean(this.meta.committing);
  }
  clearChanges(includeDescendants = true, removeFromStoreChanges = true, changes = null) {
    const me = this, {
      meta
    } = me;
    if (changes) {
      for (const key in changes) {
        delete meta.modified[key];
      }
    } else {
      meta.modified = {};
    }
    const noChanges = ObjectHelper.isEmpty(meta.modified);
    meta.committing = false;
    if (removeFromStoreChanges) {
      me.stores.forEach((store) => {
        noChanges && store.modified.remove(me);
        store.added.remove(me);
        if (includeDescendants) {
          const descendants = store.collectDescendants(me).all;
          store.added.remove(descendants);
          noChanges && store.modified.remove(descendants);
        }
      });
    }
  }
  storeFieldChange(key, oldValue) {
    this.meta.modified[key] = oldValue;
  }
  revertChanges(silent = false) {
    this.set(this.meta.modified, _undefined, silent);
  }
  applyChangeset(rawChanges, phantomIdField = "$PhantomId", remote = true) {
    const me = this, modelClass = me.constructor, {
      idField,
      fieldDataSourceMap
    } = modelClass, rawChangesSimplePaths = ObjectHelper.pathifyKeys(rawChanges), ownChangesSimplePaths = ObjectHelper.pathifyKeys(me.modificationData), changes = {}, idChanged = phantomIdField in rawChanges;
    for (const dataSource in rawChangesSimplePaths) {
      var _field$name;
      const field = fieldDataSourceMap[dataSource], propName = (_field$name = field === null || field === void 0 ? void 0 : field.name) !== null && _field$name !== void 0 ? _field$name : dataSource;
      if (remote || ((field === null || field === void 0 ? void 0 : field.name) === idField ? idChanged : rawChangesSimplePaths[dataSource] === ownChangesSimplePaths[dataSource])) {
        changes[propName] = rawChangesSimplePaths[dataSource];
      }
    }
    const wasSet = me.set(changes);
    me.clearChanges(false, true, remote ? null : changes);
    return wasSet ? Object.entries(wasSet).reduce((result, [field, change]) => {
      result[field] = change.value;
      return result;
    }, {}) : {};
  }
  get internalId() {
    return this._internalId;
  }
  get isPhantom() {
    return this.id === "" || this.id == null || this.hasGeneratedId;
  }
  get isModel() {
    return true;
  }
  get hasGeneratedId() {
    return typeof this.id === "string" && this.id.startsWith("_generated");
  }
  static generateId(text = this.$$name) {
    return `_generated${text}_${StringHelper.generateUUID()}`;
  }
  generateId() {
    return this.constructor.generateId();
  }
  static asId(model) {
    return model !== null && model !== void 0 && model.isModel ? model.id : ObjectHelper.isObject(model) ? model[this.fieldMap.id.dataSource] : model;
  }
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  toJSON() {
    const {
      children,
      unfilteredChildren
    } = this, jsonData = this.persistableData;
    if (unfilteredChildren || children) {
      jsonData[this.constructor.childrenField] = (unfilteredChildren || children).map((c) => c.toJSON());
    }
    return jsonData;
  }
  toString() {
    const me = this, nameField = abbreviationFields.find((field) => field in me.constructor.fieldMap), data = nameField ? {
      [me.constructor.idField]: me.id,
      [nameField]: me[nameField]
    } : me.data;
    return StringHelper.safeJsonStringify(data);
  }
  get isBatchUpdating() {
    return Boolean(this.batching);
  }
  hasBatchedChange(fieldName) {
    var _this$meta, _this$meta$batchChang;
    return (_this$meta = this.meta) === null || _this$meta === void 0 ? void 0 : (_this$meta$batchChang = _this$meta.batchChanges) === null || _this$meta$batchChang === void 0 ? void 0 : _this$meta$batchChang[fieldName];
  }
  beginBatch(silentUpdates = false) {
    const me = this;
    if (!me.batching) {
      me.batching = 0;
      me.meta.batchChanges = {};
    }
    if (silentUpdates) {
      me.$silenceBatch = (me.$silenceBatch || 0) + 1;
    }
    me.batching++;
  }
  endBatch(silent = false, skipAccessors = false) {
    const me = this, {
      parentIdField
    } = me.constructor;
    if (!me.batching) {
      return;
    }
    me.batching--;
    me.$silenceBatch && me.$silenceBatch--;
    if (me.batching > 0) {
      return;
    }
    if (!ObjectHelper.isEmpty(me.meta.batchChanges)) {
      const batchChanges = _objectSpread2({}, me.meta.batchChanges);
      me.meta.batchChanges = null;
      if (batchChanges[parentIdField]) {
        me.parentId = batchChanges[parentIdField];
        delete batchChanges[parentIdField];
      }
      me.set(batchChanges, _undefined, silent, false, skipAccessors);
    }
  }
  cancelBatch() {
    if (this.batching) {
      const me = this, {
        batchChanges
      } = me.meta, wasSet = {};
      me.batching = null;
      me.meta.batchChanges = null;
      me.generation++;
      if (!me.$silenceBatch) {
        Object.entries(batchChanges).forEach(([key, oldValue]) => {
          wasSet[key] = {
            oldValue,
            value: me[key]
          };
        });
        const event = {
          action: "update",
          record: me,
          records: [me],
          changes: wasSet
        };
        me.stores.forEach((store) => {
          store.trigger("batchedUpdate", _objectSpread2({}, event));
        });
        me.forEachLinked((store, record) => {
          store.trigger("batchedUpdate", _objectSpread2(_objectSpread2({}, event), {}, {
            record,
            records: [record]
          }));
        });
      }
      me.$silenceBatch && me.$silenceBatch--;
    }
  }
  triggerBeforeUpdate(changes) {
    var _this$stores;
    return !((_this$stores = this.stores) !== null && _this$stores !== void 0 && _this$stores.some((s) => s.trigger("beforeUpdate", {
      record: this,
      changes
    }) === false));
  }
  copy(newId = null, deep) {
    const me = this, data = ObjectHelper.clone(me.data), idField = me.constructor.idField, useDeep = ObjectHelper.isObject(deep) ? deep.deep : deep;
    let id;
    if (newId && typeof newId === "object") {
      id = newId[idField];
      Object.assign(data, newId);
    } else {
      id = newId;
    }
    if (useDeep && me.children) {
      data.children = me.children.map((child) => child.copy(void 0, deep));
    } else {
      delete data.children;
      delete data.expanded;
    }
    if (me.$meta.fields.initable.length > 0) {
      const json = me.toJSON();
      for (const field of me.$meta.fields.initable) {
        data[field.name] = json[field.name];
      }
    }
    if (newId !== false) {
      data[idField] = id || me.generateId(me.firstStore);
    }
    const copy = new me.constructor(data, null, null, false, true);
    copy.originalInternalId = me.internalId;
    return copy;
  }
  copyData(fromRecord) {
    const propertiesAndValues = {};
    fromRecord.allFields.forEach(({
      name: fieldName
    }) => {
      if (fieldName !== fromRecord.constructor.idField) {
        propertiesAndValues[fieldName] = fromRecord[fieldName];
      }
    });
    this.set(propertiesAndValues);
  }
  remove(silent = false) {
    const me = this, {
      parent
    } = this;
    if (parent) {
      parent.removeChild(me);
    } else if (me.stores.length && !me.isSpecialRow) {
      me.stores.forEach((s) => s.remove(me, silent, false, true));
    }
  }
  beforeRemove(stores, records) {
    return super.beforeRemove(stores, records);
  }
  get isValid() {
    return true;
  }
  get firstStore() {
    return this.stores.length > 0 && this.stores[0];
  }
  joinStore(store) {
    const me = this, {
      stores
    } = me;
    if (!stores.includes(store)) {
      const {
        unjoinedStores
      } = me;
      super.joinStore(store);
      store.register(me);
      stores.push(store);
      if (unjoinedStores.includes(store)) {
        unjoinedStores.splice(unjoinedStores.indexOf(store), 1);
      }
      me.isLoaded && me.children.forEach((child) => child.joinStore(store));
      me.initRelations();
      if (store.tree && !me.isRoot) {
        me.instanceMeta(store.id).collapsed = !me.expanded;
      }
    }
  }
  unjoinStore(store, isReplacing = false) {
    const me = this, {
      stores,
      unjoinedStores
    } = me;
    if (stores.includes(store)) {
      var _ref, _ref$forEach, _super$unjoinStore;
      if (!store.isDestroying) {
        store.unregister(me);
        unjoinedStores.push(store);
      }
      (_ref = me.unfilteredChildren || me.children) === null || _ref === void 0 ? void 0 : (_ref$forEach = _ref.forEach) === null || _ref$forEach === void 0 ? void 0 : _ref$forEach.call(_ref, (child) => child.unjoinStore(store, isReplacing));
      stores.splice(stores.indexOf(store), 1);
      (_super$unjoinStore = super.unjoinStore) === null || _super$unjoinStore === void 0 ? void 0 : _super$unjoinStore.call(this, store, isReplacing);
      store.uncacheRelatedRecord(me);
    }
  }
  isPartOfStore(store) {
    if (store) {
      return store.includes(this);
    }
    return this.stores.length > 0;
  }
  get isRemoved() {
    return !this.isPartOfStore();
  }
  instanceMeta(instanceOrId) {
    const {
      meta
    } = this, id = instanceOrId.id || instanceOrId;
    if (!meta.map) {
      meta.map = {};
    }
    return meta.map[id] || (meta.map[id] = {});
  }
  get isGroupHeader() {
    return "groupRowFor" in this.meta;
  }
  get isGroupFooter() {
    return "groupFooterFor" in this.meta;
  }
  get isSpecialRow() {
    var _this$meta2;
    return Boolean((_this$meta2 = this.meta) === null || _this$meta2 === void 0 ? void 0 : _this$meta2.specialRow);
  }
  get $original() {
    return this.isLinked ? this.proxyMeta.originalRecord : this;
  }
  static get nonPersistableFields() {
    const me = this;
    if (!me._nonPersistableFields) {
      me._nonPersistableFields = {};
      me.allFields.forEach((field) => {
        if (!field.persist || field.calculated) {
          me._nonPersistableFields[field.name] = 1;
        }
      });
    }
    return me._nonPersistableFields;
  }
  static get alwaysWriteFields() {
    const me = this;
    if (!me._alwaysWriteFields) {
      me._alwaysWriteFields = [];
      me.allFields.forEach((field) => {
        if (field.alwaysWrite) {
          me._alwaysWriteFields.push(field.name);
        }
      });
    }
    return me._alwaysWriteFields;
  }
  get domId() {
    return typeof this.id === "string" ? this.id.replace(/[ .]/g, "-") : this.id;
  }
  static toJavaScriptValue(options) {
    const {
      names
    } = this.$meta, className = names[names.length - 2], superName = names[names.length - 3];
    return `class ${className} extends ${superName} { static fields = ${StringHelper.toJavaScriptValue(this.fields, options)}; }`;
  }
  getCurrentConfig(options) {
    const {
      data,
      children
    } = this, {
      defaultValues,
      applyConfigs
    } = this.constructor, result = applyConfigs ? super.getCurrentConfig(options) : {};
    if (result) {
      for (const field of this.fields) {
        if (field.persist) {
          const value = ObjectHelper.getPath(data, field.dataSource);
          if (!field.isEqual(value, defaultValues[field.name])) {
            ObjectHelper.setPath(result, field.dataSource, Base.processConfigValue(value, options));
          }
        }
      }
      if (children) {
        if (Array.isArray(children)) {
          result.children = [];
          for (const child of children) {
            result.children.push(child.getCurrentConfig(options));
          }
        } else {
          result.children = children;
        }
      }
      if (this.hasGeneratedId) {
        delete result.id;
      }
      delete result.parentId;
      delete result.parentIndex;
    }
    return result;
  }
};
_defineProperty(Model, "relations", null);
Model._idField = "id";
Model._internalIdCounter = 1;
Model._assignedIdField = false;
Model.exposeProperties();
Model._$name = "Model";
var Duration = class {
  constructor(magnitude, unit) {
    if (typeof magnitude === "number" || magnitude === null) {
      this._magnitude = magnitude;
      this._unit = unit;
    } else {
      if (typeof magnitude === "string") {
        Object.assign(this, DateHelper.parseDuration(magnitude));
      }
      if (typeof magnitude === "object") {
        Object.assign(this, magnitude);
      }
    }
  }
  get magnitude() {
    return this._magnitude;
  }
  set magnitude(value) {
    this._magnitude = typeof value === "number" && value;
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = DateHelper.parseTimeUnit(value);
  }
  get isValid() {
    return this._magnitude != null && Boolean(DateHelper.normalizeUnit(this._unit));
  }
  get milliseconds() {
    return this.isValid ? Math.round(DateHelper.asMilliseconds(this._magnitude, this._unit)) : 0;
  }
  isEqual(value) {
    return Boolean(value) && this._magnitude != null && value._magnitude != null && this.milliseconds === value.milliseconds;
  }
  toString(useAbbreviation) {
    const me = this, abbreviationFn = useAbbreviation ? "getShortNameOfUnit" : "getLocalizedNameOfUnit";
    return me.isValid ? `${me._magnitude} ${DateHelper[abbreviationFn](me._unit, me._magnitude !== 1)}` : "";
  }
  toJSON() {
    return this.toString();
  }
  valueOf() {
    return this.milliseconds;
  }
};
Duration._$name = "Duration";
var nestedValueReducer = (object, path) => object === null || object === void 0 ? void 0 : object[path];
var relativeDateUnitRegExp = /^is(this|next|last)(week|month|year)$/i;
var relativeDateOperators = ["isToday", "isTomorrow", "isYesterday", "isThisWeek", "isNextWeek", "isLastWeek", "isThisMonth", "isNextMonth", "isLastMonth", "isThisYear", "isNextYear", "isLastYear", "isYearToDate"];
var CollectionFilter = class extends Base.mixin(Identifiable) {
  static get defaultConfig() {
    return {
      value: null,
      operator: null,
      filterBy: null,
      convert: null,
      caseSensitive: true,
      id: null,
      type: null,
      internal: null,
      disabled: false
    };
  }
  static get configurable() {
    return {
      property: null
    };
  }
  construct(config) {
    if (typeof config === "function") {
      config = {
        filterBy: config
      };
    }
    if (!config.type) {
      if (DateHelper.isDate(config.value) || Array.isArray(config.value) && config.value.every(DateHelper.isDate)) {
        config.type = "date";
      } else if (config.value instanceof Duration) {
        config.type = "duration";
      }
    } else {
      if (config.type === "date" && config.value != null && !Array.isArray(config.value)) {
        config.value = new Date(config.value);
      } else if (config.type === "duration" && config.value != null && !Array.isArray(config.value)) {
        config.value = new Duration(config.value);
      }
    }
    super.construct(config);
  }
  get id() {
    if (!this._id) {
      if (this.internal) {
        this._id = CollectionFilter.generateId(`b-internal-${this.property}-filter-`);
      } else {
        this._id = this.property || CollectionFilter.generateId("b-filter-");
      }
    }
    return this._id;
  }
  set id(id) {
    this._id = id;
  }
  onChange(propertyChanged) {
    var _me$owner;
    const me = this;
    if (!me.isConfiguring && (_me$owner = me.owner) !== null && _me$owner !== void 0 && _me$owner.onFilterChanged && !me.owner.isConfiguring) {
      me.owner.onFilterChanged(me, propertyChanged);
    }
  }
  get filterBy() {
    return this._filterBy || this.defaultFilterBy;
  }
  set filterBy(filterBy) {
    this._filterBy = filterBy;
  }
  defaultFilterBy(candidate) {
    const me = this;
    let candidateValue;
    if (me._propertyItems.length > 1) {
      candidateValue = me._propertyItems.reduce(nestedValueReducer, candidate);
    } else {
      candidateValue = candidate[me.property];
    }
    return me[me.operator](me.convert(candidateValue));
  }
  updateProperty(property) {
    this._propertyItems = property.split(".");
    this.onChange("property");
  }
  set value(value) {
    const me = this;
    me._value = value;
    if (Array.isArray(value) && ({
      date: 1,
      duration: 1
    }[me.type] || value.length > 0 && typeof value[0] === "string")) {
      me._filterValue = value.map((v) => me.convert(v));
    } else if (!me.caseSensitive && Array.isArray(value) && value.length > 0 && typeof value[0] === "string") {
      me._filterValue = value.map((s) => s === null || s === void 0 ? void 0 : s.toLowerCase());
    } else if (!me.caseSensitive && typeof value === "string") {
      me._filterValue = value.toLowerCase();
    } else {
      me._filterValue = me.convert(value);
    }
    me.onChange("value");
  }
  get value() {
    return this._value;
  }
  get filterValue() {
    return this._filterValue;
  }
  set operator(operator) {
    this._operator = operator;
    this.onChange("operator");
  }
  get operator() {
    const me = this;
    if (me._operator) {
      return me._operator;
    }
    if (Array.isArray(me.filterValue)) {
      return "isIncludedIn";
    }
    return typeof me.filterValue === "string" ? "*" : "=";
  }
  convert(value) {
    if (this.operator !== "sameTime" && !(typeof this.filterValue === "string" && value instanceof Date)) {
      var _value$valueOf, _value;
      if (this.operator === "sameDay") {
        value = DateHelper.clearTime(value);
      }
      value = (_value$valueOf = (_value = value) === null || _value === void 0 ? void 0 : _value.valueOf()) !== null && _value$valueOf !== void 0 ? _value$valueOf : value;
    }
    value = !this.caseSensitive && typeof value === "string" ? value.toLowerCase() : value;
    return value;
  }
  filter(candidate) {
    return this.filterBy(candidate);
  }
  startsWith(v) {
    return String(v).startsWith(this.filterValue);
  }
  endsWith(v) {
    return String(v).endsWith(this.filterValue);
  }
  isIncludedIn(v) {
    return this.filterValue.length === 0 || this.filterValue.includes(v);
  }
  isNotIncludedIn(v) {
    return !this.isIncludedIn(v);
  }
  includes(v) {
    return this.filterValue.length === 0 || String(v).includes(this.filterValue);
  }
  doesNotInclude(v) {
    return !this.includes(v);
  }
  sameTime(v) {
    return DateHelper.isSameTime(v, this.filterValue);
  }
  sameDay(v) {
    return v === this.filterValue;
  }
  "="(v) {
    return ObjectHelper.isEqual(v, this.filterValue);
  }
  "!="(v) {
    return !ObjectHelper.isEqual(v, this.filterValue);
  }
  ">"(v) {
    return ObjectHelper.isMoreThan(v, this.filterValue);
  }
  ">="(v) {
    return ObjectHelper.isMoreThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);
  }
  "<"(v) {
    return ObjectHelper.isLessThan(v, this.filterValue);
  }
  "<="(v) {
    return ObjectHelper.isLessThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);
  }
  "*"(v) {
    return ObjectHelper.isPartial(v, this.filterValue);
  }
  between(v) {
    const [start, end] = this._filterValue;
    return (ObjectHelper.isMoreThan(v, start) || ObjectHelper.isEqual(v, start)) && (ObjectHelper.isLessThan(v, end) || ObjectHelper.isEqual(v, end));
  }
  notBetween(v) {
    return !this.between(v);
  }
  empty(v) {
    return v === void 0 || v === null || String(v).length === 0;
  }
  notEmpty(v) {
    return !this.empty(v);
  }
  isToday(v) {
    return this.between(v);
  }
  isTomorrow(v) {
    return this.between(v);
  }
  isYesterday(v) {
    return this.between(v);
  }
  isThisWeek(v) {
    return this.between(v);
  }
  isNextWeek(v) {
    return this.between(v);
  }
  isLastWeek(v) {
    return this.between(v);
  }
  isThisMonth(v) {
    return this.between(v);
  }
  isNextMonth(v) {
    return this.between(v);
  }
  isLastMonth(v) {
    return this.between(v);
  }
  isThisYear(v) {
    return this.between(v);
  }
  isNextYear(v) {
    return this.between(v);
  }
  isLastYear(v) {
    return this.between(v);
  }
  isYearToDate(v) {
    return this.between(v);
  }
  isTrue(v) {
    return v === true;
  }
  isFalse(v) {
    return v === false;
  }
  setRelativeDateValues() {
    this._filterValue = CollectionFilter.getRelativeDateRange(this._operator).map((date) => date.valueOf());
  }
  static getRelativeDateRange(relativeExpr, now2 = new Date()) {
    let todayStart, tomorrowStart, parts, oneTimeUnit, unitStart, which, timeUnit;
    switch (relativeExpr) {
      case "isYearToDate":
        return [DateHelper.floor(now2, "1 year"), now2];
      case "isToday":
        todayStart = DateHelper.floor(now2, "1 day");
        return [todayStart, DateHelper.add(todayStart, 1, "day")];
      case "isYesterday":
        todayStart = DateHelper.floor(now2, "1 day");
        return [DateHelper.add(todayStart, -1, "day"), todayStart];
      case "isTomorrow":
        tomorrowStart = DateHelper.getStartOfNextDay(now2);
        return [tomorrowStart, DateHelper.add(tomorrowStart, 1, "day")];
      case "isThisWeek":
      case "isNextWeek":
      case "isLastWeek":
      case "isThisMonth":
      case "isNextMonth":
      case "isLastMonth":
      case "isThisYear":
      case "isNextYear":
      case "isLastYear":
        parts = relativeExpr.toLowerCase().match(relativeDateUnitRegExp);
        if (!parts) {
          throw new Error(`Unrecognized relative date expression: ${relativeExpr}`);
        }
        [, which, timeUnit] = parts;
        oneTimeUnit = `1 ${timeUnit}`;
        unitStart = DateHelper.floor(now2, oneTimeUnit);
        if (which === "next") {
          unitStart = DateHelper.add(unitStart, 1, timeUnit);
        } else if (which === "last") {
          unitStart = DateHelper.add(unitStart, -1, timeUnit);
        }
        return [unitStart, DateHelper.add(unitStart, 1, timeUnit)];
    }
  }
  static generateFiltersFunction(filters) {
    if (!filters || !filters.length && !filters.count) {
      return FunctionHelper.returnTrue;
    }
    for (const filter of filters) {
      if (filter.type === "date" && relativeDateOperators.includes(filter._operator)) {
        filter.setRelativeDateValues();
      }
    }
    return function(candidate) {
      let match = true;
      for (const filter of filters) {
        if (!filter.disabled) {
          match = filter.filter(candidate);
        }
        if (!match) {
          break;
        }
      }
      return match;
    };
  }
};
_defineProperty(CollectionFilter, "$name", "CollectionFilter");
CollectionFilter._$name = "CollectionFilter";
var idCounts = ObjectHelper.getPathDefault(globalThis, "bryntum.idCounts", /* @__PURE__ */ Object.create(null));
var IdHelper = class {
  static generateId(prefix = "generatedId") {
    return prefix + (idCounts[prefix] = (idCounts[prefix] || 0) + 1);
  }
};
IdHelper._$name = "IdHelper";
var CollectionSorter = class extends Base {
  static get defaultConfig() {
    return {
      property: null,
      direction: "ASC",
      sortFn: null,
      convert: null,
      id: null,
      useLocaleSort: null
    };
  }
  construct(config) {
    if (typeof config === "function") {
      config = {
        sortFn: config
      };
    }
    super.construct(config);
  }
  get id() {
    return this._id || (this._id = this.property || IdHelper.generateId("b-sorter"));
  }
  set id(id) {
    this._id = id;
  }
  set sortFn(sortFn) {
    this._sortFn = sortFn;
  }
  get sortFn() {
    if (this._sortFn) {
      return this._sortFn;
    }
    return this.defaultSortFn;
  }
  defaultSortFn(lhs, rhs) {
    const me = this, {
      convert,
      property,
      useLocaleSort
    } = me, multiplier = me.direction.toLowerCase() === "desc" ? -1 : 1;
    lhs = lhs[property];
    rhs = rhs[property];
    if (convert) {
      lhs = convert(lhs);
      rhs = convert(rhs);
    }
    if (useLocaleSort && lhs != null && rhs != null && typeof lhs === "string") {
      if (useLocaleSort === true) {
        return String(lhs).localeCompare(rhs);
      }
      if (typeof useLocaleSort === "string") {
        return String(lhs).localeCompare(rhs, useLocaleSort);
      }
      if (typeof useLocaleSort === "object") {
        return String(lhs).localeCompare(rhs, useLocaleSort.locale, useLocaleSort);
      }
    }
    return (lhs > rhs ? 1 : lhs < rhs ? -1 : 0) * multiplier;
  }
  static generateSortFunction(sorters, tieBreaker) {
    const items2 = sorters.isCollection ? sorters.values : sorters, n = items2.length;
    return (lhs, rhs) => {
      let comp, i;
      for (i = 0; i < n; ++i) {
        comp = items2[i].sortFn(lhs, rhs);
        if (comp) {
          return comp;
        }
      }
      return tieBreaker ? tieBreaker(lhs, rhs) : 0;
    };
  }
};
CollectionSorter._$name = "CollectionSorter";
var _Symbol$iterator;
var return0 = () => 0;
var reverseNumericSortFn = (a, b) => b - a;
var filteredIndicesProperty = Symbol("filteredIndicesProperty");
var emptyArray$7 = Object.freeze([]);
var sortEvent = Object.freeze({
  action: "sort",
  added: emptyArray$7,
  removed: emptyArray$7,
  replaced: emptyArray$7
});
var filterEvent = Object.freeze({
  action: "filter",
  added: emptyArray$7,
  removed: emptyArray$7,
  replaced: emptyArray$7
});
var keyTypes = {
  string: 1,
  number: 1
};
function addItemToIndex(item, index, key) {
  if (index.unique !== false) {
    index.set(key, item);
  } else {
    let set = index.get(key);
    if (!set) {
      set = /* @__PURE__ */ new Set();
      index.set(key, set);
    }
    set.add(item);
  }
}
function removeItemFromIndex(item, index, key) {
  if (index.unique !== false) {
    index.delete(key);
  } else if (index.has(key)) {
    index.get(key).delete(item);
    if (!index.get(key).size) {
      index.delete(key);
    }
  }
}
function doRebuildIndices(values, indices, keyProps, indexCount) {
  for (let i = 0; i < values.length; i++) {
    const item = values[i];
    for (let j = 0; j < indexCount; j++) {
      const keyProp = keyProps[j], key = item[keyProp], index = indices[keyProp];
      addItemToIndex(item, index, key);
    }
  }
}
_Symbol$iterator = Symbol.iterator;
var Collection = class extends Base.mixin(Events) {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "_sortFunction", null);
    _defineProperty(this, "_addedValues", null);
  }
  static get configurable() {
    return {
      idProperty: "id",
      extraKeys: null,
      autoFilter: true,
      autoSort: true,
      sorters: {
        $config: ["lazy"],
        value: []
      }
    };
  }
  get isCollection() {
    return true;
  }
  construct(config) {
    this.generation = 0;
    this._values = [];
    super.construct(config);
  }
  doDestroy() {
    var _me$_sorters;
    super.doDestroy();
    const me = this;
    me._values.length = 0;
    if (me.isFiltered) {
      me._filteredValues.length = 0;
      me.filters.destroy();
    }
    (_me$_sorters = me._sorters) === null || _me$_sorters === void 0 ? void 0 : _me$_sorters.destroy();
  }
  clear() {
    const me = this, removed = me._values.slice();
    if (me.totalCount) {
      me._values.length = 0;
      if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
      me._indicesInvalid = true;
      me.generation++;
      me.trigger("change", {
        action: "clear",
        removed
      });
    }
  }
  equals(other, map) {
    if (other.isCollection) {
      other = other.values;
    }
    if (other.length === this.count) {
      let {
        values
      } = this;
      if (map) {
        other = other.map(map);
        values = values.map(map);
      }
      return ArrayHelper.delta(other, values).inBoth.length === this.count;
    }
    return false;
  }
  replaceValues({
    values,
    filteredValues,
    silent = false,
    isNewDataset = false
  }) {
    const me = this;
    let replacedValues, replacedFilteredValues;
    if (me.isFiltered && !isNewDataset) {
      const filteredPassed = Boolean(filteredValues);
      if (!filteredPassed) {
        filteredValues = values.slice();
        values = null;
      } else if (values) {
        replacedValues = me._values;
        me._values = values.slice();
      }
      replacedFilteredValues = me._filteredValues;
      me._filteredValues = filteredValues.slice();
    } else {
      replacedValues = me._values;
      me._values = values.slice();
      filteredValues = null;
      if (me.isFiltered && isNewDataset && me.autoFilter) {
        me._filterFunction = null;
        me._filteredValues = me._values.filter(me.filterFunction);
      } else if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
    }
    me._indicesInvalid = true;
    me._addedValues = void 0;
    me.generation++;
    if (!silent) {
      me.trigger("change", {
        action: "replaceValues",
        replacedValues,
        replacedFilteredValues,
        values,
        filteredValues
      });
    }
  }
  set values(values) {
    this.invalidateIndices();
    this.splice(0, this._values.length, values);
  }
  get values() {
    return this.isFiltered ? this._filteredValues : this._values;
  }
  get filteredValues() {
    return this._filteredValues;
  }
  [_Symbol$iterator]() {
    return this.values[Symbol.iterator]();
  }
  forEach(fn, ignoreFilters = false) {
    (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).forEach(fn);
  }
  map(fn, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).map(fn);
  }
  find(fn, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).find(fn);
  }
  get first() {
    return this.values[0];
  }
  get last() {
    return this.values[this.count - 1];
  }
  get allValues() {
    return this._values;
  }
  get addedValues() {
    return this._addedValues;
  }
  match(other, allowRemove = true) {
    const me = this, {
      _values
    } = me, toRemove = [];
    me.forEach((item) => {
      const newInstance = other.get(item.id, true);
      if (newInstance) {
        const index = me.indexOf(item, true), oldInstance = _values[index];
        _values[index] = newInstance;
        me.removeFromIndices(oldInstance);
        me.addToIndices(newInstance);
      } else if (allowRemove) {
        toRemove.push(item);
      }
    });
    if (toRemove.length) {
      me.remove(toRemove);
    }
    if (me.isFiltered) {
      me._filteredValues = me._values.filter(me.filterFunction);
    }
    return toRemove;
  }
  add(...items2) {
    if (items2.length === 1) {
      this.splice(this._values.length, null, ...items2);
    } else {
      this.splice(this._values.length, null, items2);
    }
  }
  remove(...items2) {
    if (items2.length === 1) {
      this.splice(0, ...items2);
    } else {
      this.splice(0, items2);
    }
  }
  move(items2, beforeItem) {
    items2 = ArrayHelper.asArray(items2);
    while (items2.length && items2[0] === beforeItem) {
      items2.shift();
    }
    if (!items2.length) {
      return;
    }
    const me = this, {
      _values
    } = me, itemIndex = me.indexOf(items2[0], true);
    if (items2.length === 1 && _values[itemIndex + 1] === beforeItem) {
      return;
    }
    me.suspendEvents();
    me.remove(items2);
    me.resumeEvents();
    const beforeIndex = beforeItem ? me.indexOf(beforeItem, true) : _values.length;
    if (beforeIndex === -1) {
      throw new Error("Collection move beforeItem parameter must be present in Collection");
    }
    _values.splice(beforeIndex, 0, ...items2);
    me._indicesInvalid = 1;
    me.trigger("change", {
      action: "move",
      items: items2,
      from: itemIndex,
      to: beforeIndex
    });
    return beforeIndex;
  }
  splice(index = 0, toRemove, ...toAdd) {
    const me = this, idProperty = me.idProperty, values = me._values, newIds = {}, removed = [], replaced = [], oldCount = me.totalCount;
    let added, mutated;
    if (me.trigger("beforeSplice", {
      index,
      toRemove,
      toAdd
    }) === false) {
      return;
    }
    if (toAdd) {
      if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
        toAdd = toAdd[0];
      }
      if (oldCount && toAdd.length) {
        const idIndex = me.indices[idProperty];
        added = [];
        for (let i = 0; i < toAdd.length; i++) {
          const newItem = toAdd[i], id = newItem[idProperty], existingItem = idIndex.get(id), existingIndex = existingItem ? values.indexOf(existingItem) : -1;
          newIds[id] = true;
          if (existingIndex !== -1) {
            if (values[existingIndex] !== newItem) {
              replaced.push([values[existingIndex], newItem]);
              values[existingIndex] = newItem;
            }
          } else {
            added.push(newItem);
          }
        }
      } else {
        added = toAdd;
      }
    }
    if (toRemove) {
      if (typeof toRemove === "number") {
        toRemove = Math.min(toRemove, values.length - index);
        for (let removeIndex = index; toRemove; --toRemove) {
          const id = values[removeIndex][idProperty];
          if (newIds[id]) {
            index++;
            removeIndex++;
          } else {
            removed.push(values[removeIndex]);
            values.splice(removeIndex, 1);
            mutated = true;
          }
        }
      } else {
        let contiguous = added.length === 0, lastIdx;
        toRemove = ArrayHelper.asArray(toRemove);
        const removeIndices = toRemove.reduce((result, item) => {
          const isNumeric = typeof item === "number", idx = isNumeric ? item : me.indexOf(item, true);
          if (contiguous && (lastIdx != null && idx !== lastIdx + 1 || isNumeric)) {
            contiguous = false;
          }
          if (idx >= 0 && idx < oldCount) {
            result.push(idx);
          }
          lastIdx = idx;
          return result;
        }, []).sort(reverseNumericSortFn);
        if (contiguous) {
          if (removeIndices.length) {
            removed.push.apply(removed, toRemove);
            values.splice(removeIndices[removeIndices.length - 1], removeIndices.length);
            mutated = true;
          }
        } else {
          for (let i = 0; i < removeIndices.length; i++) {
            const removeIndex = removeIndices[i];
            if (removeIndex !== -1) {
              const id = values[removeIndex][idProperty];
              if (!newIds[id]) {
                removed.unshift(values[removeIndex]);
                values.splice(removeIndex, 1);
                mutated = true;
              }
            }
          }
        }
      }
      if (removed.length && !me._indicesInvalid) {
        removed.forEach(me.removeFromIndices, me);
      }
    }
    if (added.length) {
      values.splice(Math.min(index, values.length), 0, ...added);
      mutated = true;
      if (!me._indicesInvalid) {
        added.forEach(me.addToIndices, me);
      }
      if (!me._addedValues) {
        me._addedValues = /* @__PURE__ */ new Set();
      }
      for (const value of added) {
        me._addedValues.add(value);
      }
    }
    if (removed.length && me._addedValues) {
      for (const value of removed) {
        me._addedValues.delete(value);
      }
    }
    if (replaced.length && !me._indicesInvalid) {
      replaced.forEach((rep) => {
        me.removeFromIndices(rep[0]);
        me.addToIndices(rep[1]);
      });
    }
    if (mutated || replaced.length) {
      if (me.isSorted) {
        me.onSortersChanged();
      } else if (me.isFiltered) {
        if (me.autoFilter) {
          me.onFiltersChanged({
            action: "splice",
            oldCount: 1
          });
        } else {
          me._filteredValues.splice(Math.min(index, me._filteredValues.length), 0, ...added);
        }
      }
      me.generation++;
      me.trigger("change", {
        action: "splice",
        removed,
        added,
        replaced,
        oldCount
      });
    } else {
      me.trigger("noChange", {
        index,
        toRemove,
        toAdd
      });
    }
  }
  changeId(item, newId) {
    const me = this, {
      idProperty
    } = me, oldId = keyTypes[typeof item] ? item : item[idProperty], member = me.get(oldId);
    if (member) {
      const existingMember = me.get(newId);
      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }
      me.removeIndexEntry(item, idProperty, oldId);
      me.addIndexEntry(item, idProperty, newId);
      member[idProperty] = newId;
    }
  }
  get(id, ignoreFilters = false) {
    return this.getBy(this.idProperty, id, ignoreFilters);
  }
  getAt(index, ignoreFilters = false) {
    if (this.isFiltered && !ignoreFilters) {
      return this._filteredValues[index];
    } else {
      return this._values[index];
    }
  }
  getBy(propertyName, value, ignoreFilters = false) {
    return this.findItem(propertyName, value, this.isFiltered && ignoreFilters);
  }
  get count() {
    return this.values.length;
  }
  get totalCount() {
    return this._values.length;
  }
  updateIdProperty(idProperty) {
    this.addIndex({
      property: idProperty,
      unique: true
    });
  }
  changeSorters(sorters) {
    return new Collection({
      values: ArrayHelper.asArray(sorters),
      internalListeners: {
        change: "onSortersChanged",
        thisObj: this
      }
    });
  }
  addSorter(sorter) {
    const result = sorter instanceof CollectionSorter ? sorter : new CollectionSorter(sorter);
    this.sorters.add(result);
    return result;
  }
  get isSorted() {
    var _this$_sorters;
    return Boolean((_this$_sorters = this._sorters) === null || _this$_sorters === void 0 ? void 0 : _this$_sorters.count);
  }
  onSortersChanged() {
    const me = this;
    me._sortFunction = null;
    me._addedValues = null;
    me._values.sort(me.sortFunction);
    me.trigger("change", sortEvent);
  }
  get sortFunction() {
    if (!this._sortFunction) {
      if (this.isSorted) {
        this._sortFunction = CollectionSorter.generateSortFunction(this.sorters.values);
      } else {
        this._sortFunction = return0;
      }
    }
    return this._sortFunction;
  }
  get filters() {
    if (!this._filters) {
      this._filters = new Collection({
        internalListeners: {
          change: "onFiltersChanged",
          thisObj: this
        }
      });
    }
    return this._filters;
  }
  addFilter(filter) {
    const result = filter instanceof CollectionFilter ? filter : new CollectionFilter(filter);
    this.filters.add(result);
    return result;
  }
  removeFilter(filter) {
    const {
      filters
    } = this;
    if (!filter.isCollectionFilter) {
      filter = filters.get(filter);
    }
    filters.remove(filter);
  }
  clearFilters() {
    this.filters.clear();
  }
  get isFiltered() {
    return Boolean(this._filters && this._filters.count);
  }
  onFiltersChanged({
    action,
    removed: gone,
    oldCount
  }) {
    const me = this, oldDataset = oldCount || action === "clear" && gone.length ? me._filteredValues : me._values;
    me._filterFunction = null;
    me._filteredValues = me._values.filter(me.filterFunction);
    me._indicesInvalid = true;
    const {
      toAdd: added,
      toRemove: removed
    } = ArrayHelper.delta(me._filteredValues, oldDataset, true);
    me.trigger("change", _objectSpread2(_objectSpread2({}, filterEvent), {}, {
      added,
      removed
    }));
  }
  get filterFunction() {
    if (!this._filterFunction) {
      if (this.isFiltered) {
        this._filterFunction = CollectionFilter.generateFiltersFunction(this.filters.values);
      } else {
        this._filterFunction = FunctionHelper.returnTrue;
      }
    }
    return this._filterFunction;
  }
  changeExtraKeys(extraKeys) {
    const keys = ArrayHelper.asArray(extraKeys);
    return keys.map((config) => {
      if (typeof config === "string") {
        return {
          property: config,
          unique: true
        };
      }
      return config;
    });
  }
  updateExtraKeys(extraKeys) {
    for (let i = 0; i < extraKeys.length; i++) {
      this.addIndex(extraKeys[i]);
    }
  }
  addIndex(indexConfig) {
    const me = this;
    if (indexConfig) {
      (me._indices || (me._indices = {}))[indexConfig.property] = /* @__PURE__ */ new Map();
      Object.assign(me._indices[indexConfig.property], indexConfig);
      me.invalidateIndices();
      if (indexConfig.dependentOn) {
        me.hasCompositeIndex = true;
      }
    }
  }
  findIndex(propertyName, value, ignoreFilters = false) {
    const item = this.findItem(propertyName, value, ignoreFilters);
    if (!item) {
      return -1;
    }
    const values = this.isFiltered && !ignoreFilters ? this._filteredValues : this._values;
    return values.indexOf(item);
  }
  findItem(propertyName, value, ignoreFilters = false) {
    const me = this, {
      isFiltered
    } = me, index = isFiltered && !ignoreFilters ? me.indices[filteredIndicesProperty][propertyName] : me.indices[propertyName];
    if (index) {
      var _index$get;
      const item = (_index$get = index.get(value)) !== null && _index$get !== void 0 ? _index$get : typeof value === "string" && value.length && !isNaN(value) && index.get(Number(value)) || null;
      if (item != null) {
        return item;
      }
    } else {
      const values = isFiltered && !ignoreFilters ? me._filteredValues : me._values, count = values.length;
      for (let i = 0; i < count; i++) {
        const item = values[i];
        if (item[propertyName] == value) {
          return item;
        }
      }
    }
    return null;
  }
  removeIndex(propertyName) {
    delete this._indices[propertyName];
    this.hasCompositeIndex = Object.values(this.indices).some((index) => index.dependentOn);
  }
  indexOf(item, ignoreFilters = false) {
    return this.findIndex(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters);
  }
  includes(item, ignoreFilters = false) {
    if (Array.isArray(item)) {
      return item.some((item2) => this.includes(item2));
    }
    return Boolean(this.findItem(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters));
  }
  get indices() {
    if (this._indicesInvalid) {
      this.rebuildIndices();
    }
    return this._indices;
  }
  invalidateIndices() {
    this._indicesInvalid = true;
  }
  rebuildIndices() {
    const me = this, isFiltered = me.isFiltered, indices = me._indices || (me._indices = {}), keyProps = Object.keys(indices), indexCount = keyProps.length, values = me._values;
    let filteredIndices;
    if (isFiltered) {
      filteredIndices = indices[filteredIndicesProperty] = {};
    }
    for (let i = 0; i < indexCount; i++) {
      const index = indices[keyProps[i]];
      index.clear();
      if (isFiltered) {
        let filteredIndex = filteredIndices[keyProps[i]];
        if (filteredIndex) {
          filteredIndex.clear();
        } else {
          filteredIndex = filteredIndices[keyProps[i]] = /* @__PURE__ */ new Map();
          filteredIndex.unique = index.unique;
        }
      }
    }
    doRebuildIndices(values, indices, keyProps, indexCount);
    if (isFiltered) {
      doRebuildIndices(me._filteredValues, filteredIndices, keyProps, indexCount);
    }
    me._indicesInvalid = false;
  }
  getIndices(propertyName) {
    const indices = [this.indices[propertyName]];
    if (this.isFiltered) {
      indices.push(this.indices[filteredIndicesProperty][propertyName]);
    }
    return indices;
  }
  addToIndices(item) {
    Object.keys(this.indices).forEach((propertyName) => {
      this.addIndexEntry(item, propertyName, item[propertyName]);
    });
  }
  removeFromIndices(item) {
    Object.keys(this.indices).forEach((propertyName) => {
      this.removeIndexEntry(item, propertyName, item[propertyName]);
    });
  }
  removeIndexEntry(item, propertyName, oldValue) {
    this.getIndices(propertyName).forEach((index) => removeItemFromIndex(item, index, oldValue));
  }
  addIndexEntry(item, propertyName, value) {
    this.getIndices(propertyName).forEach((index) => addItemToIndex(item, index, value));
  }
  onItemMutation(item, wasSet) {
    const me = this;
    if (!me._indicesInvalid && Object.keys(me.indices).length > 1) {
      Object.keys(wasSet).forEach((propertyName) => {
        const indexConfig = me.indices[propertyName];
        if (indexConfig) {
          const {
            value,
            oldValue
          } = wasSet[propertyName];
          me.removeIndexEntry(item, propertyName, oldValue);
          me.addIndexEntry(item, propertyName, value);
        } else if (me.hasCompositeIndex) {
          const dependentIndex = Object.values(me.indices).find((index) => {
            var _index$dependentOn;
            return (_index$dependentOn = index.dependentOn) === null || _index$dependentOn === void 0 ? void 0 : _index$dependentOn[propertyName];
          });
          if (dependentIndex) {
            const keysAndOldValues = {};
            for (const o in dependentIndex.dependentOn) {
              var _wasSet$o;
              keysAndOldValues[o] = ((_wasSet$o = wasSet[o]) === null || _wasSet$o === void 0 ? void 0 : _wasSet$o.oldValue) || item[o];
            }
            const oldIndex = item.buildIndexKey(keysAndOldValues);
            me.removeIndexEntry(item, dependentIndex.property, oldIndex);
            me.addIndexEntry(item, dependentIndex.property, item[dependentIndex.property]);
          }
        }
      });
    }
  }
};
Collection._$name = "Collection";
var nonPrimitives = /* @__PURE__ */ new WeakMap();
var safeIndexKey = (value) => {
  if (value && typeof value === "object") {
    let substitute = nonPrimitives.get(value);
    if (substitute === void 0) {
      substitute = Symbol("bscik");
      nonPrimitives.set(value, substitute);
    }
    value = substitute;
  }
  return value;
};
var Bag = class {
  constructor(config) {
    const me = this;
    me.generation = 0;
    me.items = /* @__PURE__ */ new Set();
    me.idMap = {};
    me.idProperty = "id";
    if (config) {
      if (config.idProperty) {
        me.idProperty = config.idProperty;
      }
      if (config.values) {
        me.values = config.values;
      }
    }
  }
  get(key) {
    return this.idMap[safeIndexKey(key)];
  }
  get count() {
    return this.items.size;
  }
  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    const me = this, {
      items: items2,
      idMap,
      idProperty
    } = me, len = toAdd.length;
    for (let i = 0; i < len; i++) {
      const item = toAdd[i], key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), existingItem = idMap[key];
      if (existingItem == null) {
        idMap[key] = item;
        items2.add(item);
        me.generation++;
      } else if (existingItem !== item) {
        idMap[key] = item;
        items2.delete(existingItem);
        items2.add(item);
      }
    }
  }
  at(nth) {
    let item, ret;
    if (nth < 0) {
      nth += this.count;
    }
    for (item of this.items) {
      if (!nth--) {
        ret = item;
        break;
      }
    }
    return ret;
  }
  remove(toRemove) {
    toRemove = ArrayHelper.asArray(toRemove);
    const {
      items: items2,
      idMap,
      idProperty
    } = this, len = toRemove.length;
    for (let i = 0; i < len; i++) {
      const item = toRemove[i], key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), existingItem = idMap[key];
      if (existingItem != null) {
        items2.delete(existingItem);
        delete idMap[key];
        this.generation++;
      }
    }
  }
  clear() {
    this.items.clear();
    this.idMap = {};
    this.generation++;
  }
  countOf(fn) {
    let ret = 0, item;
    for (item of this.items) {
      if (fn(item)) {
        ++ret;
      }
    }
    return ret;
  }
  changeId(item, newId) {
    const me = this, {
      idMap,
      idProperty
    } = me, oldId = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), member = me.get(oldId);
    if (member) {
      const existingMember = me.get(newId);
      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }
      member[idProperty] = newId;
      delete idMap[oldId];
      idMap[newId] = member;
    }
  }
  filter(fn, thisObj) {
    const {
      items: items2
    } = this, result = [];
    let i = 0;
    items2.forEach((item) => {
      if (fn.call(thisObj, item, i++, items2)) {
        result.push(item);
      }
    });
    return result;
  }
  includes(item) {
    const key = keyTypes[typeof item] ? item : safeIndexKey(item[this.idProperty]);
    return Boolean(this.idMap[key]);
  }
  map(fn, thisObj) {
    const {
      items: items2
    } = this, result = new Array(items2.size);
    let i = 0;
    items2.forEach((item) => {
      result[i] = fn.call(thisObj, item, i++, items2);
    });
    return result;
  }
  forEach(fn, thisObj) {
    return this.items.forEach(fn, thisObj);
  }
  find(fn, nth = 0) {
    let item, ret;
    if (nth < 0) {
      nth += this.countOf(fn);
    }
    for (item of this.items) {
      if (fn(item) && !nth--) {
        ret = item;
        break;
      }
    }
    return ret;
  }
  [Symbol.iterator]() {
    return this.items[Symbol.iterator]();
  }
  indexOf(item, matchFn) {
    let index = -1, it;
    for (it of this.items) {
      if (!matchFn || matchFn(it)) {
        ++index;
        if (it === item) {
          return index;
        }
      }
    }
    return -1;
  }
  get values() {
    return [...this.items];
  }
  set values(values) {
    values = ArrayHelper.asArray(values);
    this.clear();
    this.add.apply(this, values);
    this.generation++;
  }
  sort(fn) {
    this.values = this.values.sort(fn);
  }
  some(fn, thisObj) {
    return this.values.some(fn, thisObj);
  }
};
Bag._$name = "Bag";
var StoreBag = class extends Bag {
  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    return super.add(...toAdd.filter((record) => record.isPersistable));
  }
};
StoreBag._$name = "StoreBag";
var StoreCRUD = (Target) => class StoreCRUD extends (Target || Base) {
  static get $name() {
    return "StoreCRUD";
  }
  static get defaultConfig() {
    return {
      autoCommit: false
    };
  }
  static get properties() {
    return {
      isRemoving: false,
      suspendCount: 0
    };
  }
  remove(records, silent = false) {
    const me = this, {
      storage
    } = me;
    records = ArrayHelper.asArray(records).reduce((result, r) => {
      r = me.getById(r);
      if (r) {
        result.push(r);
      }
      return result;
    }, []);
    if (records.length === 0) {
      return records;
    }
    me.isRemoving = true;
    if (me.isGrouped) {
      const oldCount = storage.count, recordsInCollapsedGroups = [], changedGroupParents = /* @__PURE__ */ new Set();
      for (const rec of records) {
        const {
          groupParent
        } = rec.instanceMeta(me);
        if (groupParent.meta.collapsed) {
          recordsInCollapsedGroups.push(rec);
        }
        ArrayHelper.remove(groupParent.groupChildren, rec);
        groupParent.meta.childCount--;
        changedGroupParents.add(groupParent);
      }
      for (const groupParent of changedGroupParents) {
        if (groupParent.groupChildren.length > 0) {
          me.onModelChange(groupParent, {}, {});
        }
      }
      if (recordsInCollapsedGroups.length) {
        storage.trigger("change", {
          action: "splice",
          removed: recordsInCollapsedGroups,
          added: [],
          replaced: [],
          oldCount
        });
      }
    } else if (me.tree) {
      const allRemovedRecords = [], removingMultiple = records.length > 1, firstRemoved = records[0], index = removingMultiple ? void 0 : storage.indexOf(firstRemoved), removeChildArgs = records.reduce((result, child) => {
        const {
          parent
        } = child;
        if (parent) {
          if (!result[parent.id]) {
            result[parent.id] = [parent, []];
          }
          result[parent.id][1].push(child);
        }
        return result;
      }, {});
      if (!silent && me.trigger("beforeRemove", {
        records,
        isMove: false,
        parent: removingMultiple ? void 0 : firstRemoved.parent
      }) === false) {
        me.isRemoving = false;
        return [];
      }
      for (const argBlock of Object.values(removeChildArgs)) {
        const parent = argBlock[0], children = argBlock[1];
        allRemovedRecords.push(...parent.removeChild(children, false, true));
      }
      if (!silent) {
        me.trigger("remove", {
          parent: removingMultiple ? void 0 : firstRemoved.parent,
          index,
          isChild: true,
          allRecords: allRemovedRecords,
          isMove: false,
          records
        });
        me.trigger("change", {
          action: "remove",
          records
        });
        me.isRemoving = false;
      }
      return records;
    }
    for (const record of records) {
      record.beforeRemove(records);
    }
    if (records.length === 0) {
      return records;
    }
    if (!silent && me.trigger("beforeRemove", {
      records
    }) === false) {
      me.isRemoving = false;
      return [];
    }
    if (silent) {
      me.suspendEvents();
    }
    storage.remove(records);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    me.isRemoving = false;
    return records;
  }
  clear(isLoading = false) {
    var _me$rootNode, _me$rootNode$unfilter;
    const me = this, {
      storage
    } = me;
    if (me.storage.totalCount || (_me$rootNode = me.rootNode) !== null && _me$rootNode !== void 0 && (_me$rootNode$unfilter = _me$rootNode.unfilteredChildren) !== null && _me$rootNode$unfilter !== void 0 && _me$rootNode$unfilter.length) {
      if (!isLoading && me.trigger("beforeRemove", {
        records: storage.allValues,
        removingAll: true
      }) === false) {
        return null;
      }
      if (me.rootNode) {
        if (!me.isChained) {
          me.rootNode.clearChildren(isLoading);
        }
      } else if (isLoading) {
        const allRecords = me.registeredRecords;
        for (let i = allRecords.length - 1, rec; i >= 0; i--) {
          rec = allRecords[i];
          if (rec && !rec.isDestroyed) {
            rec.unjoinStore(me);
          }
        }
      }
      if (isLoading) {
        me.removed.clear();
        storage.suspendEvents();
      }
      storage.clear();
      if (isLoading) {
        storage.resumeEvents();
      }
      me.added.clear();
      me.modified.clear();
    }
  }
  removeAll(silent = false) {
    const me = this, storage = me.storage;
    let result;
    me.isRemoving = true;
    if (silent) {
      storage.suspendEvents();
      const allRecords = me.registeredRecords;
      for (let i = allRecords.length - 1, rec; i >= 0; i--) {
        rec = allRecords[i];
        if (rec && !rec.isDestroyed && !rec.isRoot) {
          rec.unjoinStore(me);
        }
      }
    }
    if (me.tree) {
      result = me.rootNode.clear() !== false;
    } else {
      result = me.clear() !== null;
    }
    if (silent) {
      storage.resumeEvents();
    }
    me.isRemoving = false;
    return result;
  }
  add(records, silent = false, options = {}) {
    var _records2;
    const me = this, {
      storage
    } = me;
    records = ArrayHelper.asArray(records);
    if (!((_records2 = records) !== null && _records2 !== void 0 && _records2.length)) {
      return;
    }
    me.tree = me.tree || Boolean(me.autoTree && records[0].children);
    if (me.tree) {
      const parentIdMap = /* @__PURE__ */ new Map(), parentIndexField = me.modelClass.getFieldDataSource("parentIndex"), {
        parentIdField
      } = me.modelClass, added2 = [];
      records.forEach((node) => {
        const parentId = node[parentIdField];
        if (!parentIdMap.has(parentId)) {
          parentIdMap.set(parentId, {
            append: [],
            insert: []
          });
        }
        const entry = parentIdMap.get(parentId);
        if (!node.isModel && parentIndexField in node) {
          entry.insert.push(node);
        } else {
          entry.append.push(node);
        }
      });
      parentIdMap.forEach(({
        append,
        insert
      }, parentId) => {
        const parentNode2 = parentId == null ? me.rootNode : me.getById(parentId);
        if (!parentNode2) {
          throw new Error(`Parent node with id ${parentId} not found, cannot add children.`);
        }
        if (append.length) {
          added2.push(...parentNode2.appendChild(append, silent));
        }
        if (insert.length) {
          for (const toInsert of insert) {
            added2.push(parentNode2.insertChild(toInsert, toInsert[parentIndexField], silent, options));
          }
        }
      });
      if (me.reapplySortersOnAdd) {
        me.sort();
      }
      return added2;
    }
    if (!silent && me.trigger("beforeAdd", {
      records
    }) === false) {
      return null;
    }
    me.tree = me.tree || Boolean(me.autoTree && records[0].children);
    if (me.tree) {
      return me.rootNode.appendChild(records);
    }
    const added = me.processRecords(records);
    if (silent) {
      me.suspendEvents();
    }
    storage.add(added);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    return added;
  }
  processRecords(records, onRecordCreated) {
    return records.map((data) => {
      const record = this.processRecord(data.isModel ? data : this.createRecord(data));
      onRecordCreated === null || onRecordCreated === void 0 ? void 0 : onRecordCreated.call(this, record);
      return record;
    });
  }
  insert(index, records, silent = false) {
    const me = this, storage = me.storage, insertBefore = me.getAt(index), _records = storage.values, removeIndices = [];
    records = ArrayHelper.asArray(records);
    if (!silent && me.trigger("beforeAdd", {
      records
    }) === false) {
      return null;
    }
    let isNoop, start, i;
    if (_records[start = index] === records[0] || _records[start = index - 1] === records[0]) {
      for (isNoop = true, i = 0; isNoop && i < records.length; i++) {
        if (records[i] !== _records[start + i]) {
          isNoop = false;
        }
      }
    }
    if (isNoop) {
      return null;
    }
    const added = me.processRecords(records, (record) => {
      const removedAtIndex = storage.indexOf(record);
      if (record.children && record.children.length && me.autoTree) {
        me.tree = true;
      }
      if (removedAtIndex > -1) {
        if (removedAtIndex < index && insertBefore)
          index--;
        removeIndices.push(removedAtIndex);
      }
      record.meta.previousIndex = removedAtIndex;
    });
    if (me.tree) {
      var _root$children;
      const root2 = me.rootNode;
      return root2.insertChild(records, (_root$children = root2.children) === null || _root$children === void 0 ? void 0 : _root$children[index], silent);
    }
    me.suspendEvents();
    me.storage.remove(removeIndices);
    me.resumeEvents();
    if (silent) {
      me.suspendEvents();
    }
    storage.splice(index, 0, ...added);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    return added;
  }
  move(records, beforeRecord) {
    if (this.isTree) {
      beforeRecord.parent.insertChild(records, beforeRecord);
    } else {
      this.storage.move(records, beforeRecord);
    }
  }
  setMultiple(filterFn, field, value) {
    const me = this, records = [], changes = [];
    me.forEach((r) => {
      if (filterFn(r)) {
        changes.push(r.set(field, value, true));
        records.push(r);
      }
    });
    me.trigger("updateMultiple", {
      records,
      all: me.records.length === records.length
    });
    me.trigger("change", {
      action: "updatemultiple",
      records,
      all: me.records.length === records.length
    });
    if (me.reapplyFilterOnUpdate && me.isFiltered)
      me.filter();
  }
  setAll(field, value) {
    const me = this, changes = [];
    me.forEach((r) => {
      changes.push(r.set(field, value, true));
    });
    me.trigger("updateMultiple", {
      records: me.records,
      all: true
    });
    me.trigger("change", {
      action: "updatemultiple",
      records: me.records,
      all: true
    });
    if (me.reapplyFilterOnUpdate && me.isFiltered)
      me.filter();
  }
  acceptChanges() {
    const me = this;
    me.added.forEach((r) => r.clearChanges(true, false));
    me.modified.forEach((r) => r.clearChanges(true, false));
    me.added.clear();
    me.modified.clear();
    me.removed.clear();
  }
  commit(silent = false) {
    const {
      changes
    } = this;
    if (!silent && this.trigger("beforeCommit", {
      changes
    }) === false) {
      return false;
    }
    this.acceptChanges();
    if (!silent) {
      this.trigger("commit", {
        changes
      });
    }
    return changes;
  }
  revertChanges() {
    const me = this, {
      changes
    } = me;
    if (changes) {
      const event = {
        action: "clearchanges",
        changes
      };
      me.add(me.removed.values, true);
      me.remove(me.added.values, true);
      me.modified.forEach((r) => r.revertChanges(true));
      me.added.clear();
      me.modified.clear();
      me.removed.clear();
      me.trigger("change", event);
      me.trigger("refresh", event);
    }
  }
  get changes() {
    const me = this, modified = me.modified.values.filter((r) => r.rawModifications);
    return me.added.count || modified.length || me.removed.count ? {
      added: me.added.values.slice(),
      modified,
      removed: me.removed.values.slice()
    } : null;
  }
  get autoCommit() {
    return this._autoCommit;
  }
  set autoCommit(auto) {
    this._autoCommit = auto;
    if (auto && this.changes) {
      this.commit();
    }
  }
  suspendAutoCommit() {
    this.suspendCount++;
  }
  resumeAutoCommit(doCommit = true) {
    this.suspendCount--;
    if (this.autoCommit && doCommit) {
      this.doAutoCommit();
    }
  }
  doAutoCommit() {
    if (this.suspendCount <= 0) {
      this.commit();
    }
  }
};
var StoreChanges = (Target) => class StoreChanges extends (Target || Base) {
  static get $name() {
    return "StoreChanges";
  }
  static get configurable() {
    return {
      applyChangesetFilterSortTarget: "changes"
    };
  }
  applyChangesFromStore(otherStore) {
    const me = this, {
      changes
    } = otherStore;
    if (!changes) {
      return;
    }
    if (changes.added) {
      me.add(changes.added);
    }
    if (changes.removed) {
      me.remove(changes.removed.map((r) => r.id));
    }
    if (changes.modified) {
      changes.modified.forEach((record) => {
        const localRecord = me.getById(record.id);
        localRecord.set(record.modifications);
      });
    }
  }
  applyChangeset(changes, transformFn = null, phantomIdField = "$PhantomId", remote = true, logChanges = false) {
    var _transformFn, _ref;
    const me = this, {
      added,
      updated,
      modified,
      removed
    } = (_transformFn = transformFn === null || transformFn === void 0 ? void 0 : transformFn(changes, me)) !== null && _transformFn !== void 0 ? _transformFn : changes, altered = (_ref = updated !== null && updated !== void 0 ? updated : modified) !== null && _ref !== void 0 ? _ref : [], idDataSource = me.modelClass.getFieldDataSource("id"), log = logChanges ? /* @__PURE__ */ new Map() : null, allAdded = [], allAltered = [];
    let rootUpdated = false, modifiedParents = [];
    if ((added === null || added === void 0 ? void 0 : added.length) > 0) {
      var _me$add;
      const toUpdate = [], toAdd = [];
      for (const data of added) {
        var _data$phantomIdField;
        if (me.getById((_data$phantomIdField = data[phantomIdField]) !== null && _data$phantomIdField !== void 0 ? _data$phantomIdField : ObjectHelper.getPath(data, idDataSource))) {
          toUpdate.push(data);
        } else {
          toAdd.push(data);
        }
      }
      altered.unshift.apply(altered, toUpdate);
      const addedRecords = (_me$add = me.add(toAdd, false, {
        orderedParentIndex: {
          skip: true
        }
      })) !== null && _me$add !== void 0 ? _me$add : [];
      allAdded.push(...addedRecords);
      if (me.tree) {
        for (const record of addedRecords) {
          const {
            parent
          } = record;
          if (parent.isRoot) {
            rootUpdated = true;
            modifiedParents = [parent];
            break;
          }
          if (!parent.isRoot && modifiedParents.every((r) => !r.contains(parent))) {
            modifiedParents.push(parent);
          }
        }
      }
      for (const record of addedRecords) {
        log === null || log === void 0 ? void 0 : log.set(record.id, record.data);
        record.clearChanges();
      }
    }
    if ((altered === null || altered === void 0 ? void 0 : altered.length) > 0) {
      for (const data of altered) {
        const phantomId = data[phantomIdField], id = ObjectHelper.getPath(data, idDataSource), record = me.getById(phantomId !== null && phantomId !== void 0 ? phantomId : id);
        if (record) {
          const changes2 = record.applyChangeset(data, phantomIdField, remote);
          if (me.tree && !rootUpdated && modifiedParents.every((r) => !r.contains(record))) {
            if (record.parent.isRoot) {
              rootUpdated = true;
              modifiedParents = [record.parent];
            } else {
              modifiedParents.push(record.parent);
            }
          }
          log === null || log === void 0 ? void 0 : log.set(id, changes2);
          allAltered.push(record);
        }
      }
    }
    if ((removed === null || removed === void 0 ? void 0 : removed.length) > 0) {
      me.applyRemovals(removed);
    }
    me.afterChangesetApplied(modifiedParents);
    if (me.applyChangesetFilterSortTarget === "changes") {
      me.filterChangeset(allAdded, allAltered, me.isSorted ? me.createSorterFn(me.sorters) : void 0);
    }
    return log;
  }
  afterChangesetApplied(modifiedParents) {
    modifiedParents.forEach((parent) => {
      parent.traverse((record) => {
        record.sortOrderedChildren(false, false);
        if (record.children) {
          record.updateChildrenIndices(record.children, "parentIndex", true);
        }
        if (record.unfilteredChildren) {
          record.updateChildrenIndices(record.unfilteredChildren, "unfilteredIndex", true);
        }
      });
    });
  }
  applyRemovals(removals) {
    const me = this, {
      removed: removedStash
    } = me, idDataSource = me.modelClass.idField, toRemove = [];
    for (const removedEntry of removals) {
      const id = ObjectHelper.getPath(removedEntry, idDataSource);
      if (removedStash.includes(id)) {
        removedStash.remove(id);
      } else {
        toRemove.push(id);
      }
    }
    me.remove(toRemove);
    for (const record of toRemove) {
      removedStash.remove(record);
    }
  }
  filterChangeset(added, updated, storeSortFunction) {
    const me = this, {
      isFiltered,
      isGrouped,
      tree
    } = me, {
      allValues,
      addedValues,
      isSorted,
      filterFunction
    } = me.storage, sorter = storeSortFunction != null || isSorted ? storeSortFunction !== null && storeSortFunction !== void 0 ? storeSortFunction : me.storage.sortFunction : null;
    if (tree || !isFiltered) {
      return false;
    }
    let didChange = false, trigger = false, groupers;
    if (isGrouped) {
      groupers = me.groupers;
      me.clearGroupers(true);
    }
    const {
      filteredValues
    } = me.storage;
    if (sorter) {
      const sortedLength = addedValues ? filteredValues.findLastIndex((value) => !addedValues.has(value)) + 1 : filteredValues.length, sorted = filteredValues.slice(0, sortedLength), updatedMatches = new Set(updated.filter(filterFunction));
      for (const value of filteredValues) {
        if (updatedMatches.has(value)) {
          updatedMatches.delete(value);
        }
      }
      for (const newMatch of updatedMatches) {
        sorted.push(newMatch);
      }
      sorted.sort(sorter);
      filteredValues.splice(0, sortedLength, ...sorted);
      trigger = true;
    } else {
      const updatedMatches = new Set(updated.filter((item) => filterFunction(item) && !me.storage.includes(item)));
      let filteredIndex = 0, rawIndex = 0, allInserted = updatedMatches.size === 0;
      while (rawIndex < allValues.length && !allInserted) {
        const filteredValue = filteredValues[filteredIndex];
        let rawValue = allValues[rawIndex];
        while (filteredValue !== rawValue) {
          if (updatedMatches.has(rawValue)) {
            filteredValues.splice(filteredIndex, 0, rawValue);
            trigger = didChange = true;
            filteredIndex++;
            updatedMatches.delete(rawValue);
            allInserted = updatedMatches.size === 0;
          }
          rawValue = allValues[++rawIndex];
        }
        if (filteredIndex < filteredValues.length) {
          filteredIndex++;
        }
      }
    }
    const nonMatchingAdds = new Set(added.filter((value) => !filterFunction(value)));
    for (let filteredIndex = filteredValues.length - 1; filteredIndex >= 0; filteredIndex--) {
      const value = filteredValues[filteredIndex];
      if (nonMatchingAdds.has(value)) {
        filteredValues.splice(filteredIndex, 1);
        trigger = didChange = true;
        nonMatchingAdds.delete(value);
      }
    }
    if (groupers) {
      me.group(groupers[0], null, false, true, true);
      trigger = true;
    }
    if (trigger) {
      me._idMap = null;
      me.trigger("refresh");
    }
    return didChange;
  }
};
var StoreFilter = (Target) => class StoreFilter extends (Target || Base) {
  static get $name() {
    return "StoreFilter";
  }
  static get defaultConfig() {
    return {
      filters: null,
      reapplyFilterOnAdd: false,
      reapplyFilterOnUpdate: false
    };
  }
  set reapplyFilterOnAdd(enable) {
    this.storage.autoFilter = enable;
  }
  get reapplyFilterOnAdd() {
    return this.storage.autoFilter;
  }
  set filters(filters) {
    const me = this, collection = me.filters;
    collection.clear();
    me._filtersFunction = null;
    if (filters) {
      if (filters.constructor.name === "Object") {
        for (const f of Object.entries(filters)) {
          if (f[0] === "filterBy" && typeof f[1] === "function") {
            collection.add(new CollectionFilter({
              filterBy: f[1]
            }));
          } else {
            collection.add(new CollectionFilter(f[1].constructor.name === "Object" ? Object.assign({
              property: f[0]
            }, f[1]) : {
              property: f[0],
              value: f[1]
            }));
          }
        }
      } else if (Array.isArray(filters)) {
        collection.add(...filters.map((filterConfig) => {
          if (filterConfig instanceof CollectionFilter) {
            return filterConfig;
          }
          return new CollectionFilter(filterConfig);
        }));
      } else if (filters.isCollection) {
        collection.add(...filters.values);
      } else {
        collection.add(new CollectionFilter({
          filterBy: filters
        }));
      }
      collection.forEach((item) => item.owner = me);
    }
  }
  get filters() {
    return this._filters || (this._filters = new Collection({
      extraKeys: ["property"]
    }));
  }
  set filtersFunction(filtersFunction) {
    this._filtersFunction = filtersFunction;
  }
  get filtersFunction() {
    const me = this, {
      filters,
      isGrouped
    } = me;
    if (!me._filtersFunction) {
      if (filters.count) {
        const generatedFilterFunction = CollectionFilter.generateFiltersFunction(filters);
        me._filtersFunction = (candidate) => {
          if (isGrouped && candidate.isSpecialRow) {
            return candidate.groupChildren.some(generatedFilterFunction);
          } else {
            return generatedFilterFunction(candidate);
          }
        };
      } else {
        me._filtersFunction = FunctionHelper.returnTrue;
      }
    }
    return me._filtersFunction;
  }
  get isFiltered() {
    return this.filters.values.some((filter) => !filter.disabled);
  }
  traverseFilter(record) {
    const me = this, hitsCurrent = !record.isRoot && me.filtersFunction(record), children = record.unfilteredChildren || record.children;
    if (!children || !children.length) {
      return hitsCurrent;
    }
    if (!record.unfilteredChildren) {
      record.unfilteredChildren = record.children.slice();
    }
    record.children = record.unfilteredChildren.filter((r) => {
      return me.traverseFilter(r);
    });
    record.updateChildrenIndices(record.unfilteredChildren, "unfilteredIndex", true);
    record.updateChildrenIndices(record.children, "parentIndex", true);
    return hitsCurrent || Boolean(record.children.length);
  }
  traverseClearFilter(record) {
    const me = this;
    if (record.unfilteredChildren) {
      record.children = record.unfilteredChildren.slice();
      record.unfilteredChildren = null;
    }
    if (record.children) {
      record.children.forEach((r) => me.traverseClearFilter(r));
      record.updateChildrenIndices(record.children, "parentIndex", true);
    }
  }
  get latestFilterField() {
    return this.filters.last ? this.filters.last.property : null;
  }
  addFilter(filter, silent = false) {
    const me = this;
    filter = filter instanceof CollectionFilter ? filter : new CollectionFilter(filter);
    filter.owner = me;
    me.filters.add(filter);
    if (!silent) {
      if (me.remoteFilter) {
        return me.filter().then(() => filter);
      } else {
        me.filter();
      }
    }
    return filter;
  }
  filter(newFilters) {
    const me = this;
    let silent = false, internal;
    if (newFilters) {
      let fieldType = typeof newFilters;
      if (fieldType === "object") {
        if ("silent" in newFilters || "replace" in newFilters || newFilters.filters) {
          silent = newFilters.silent;
          if (newFilters.replace) {
            me.clearFilters(newFilters.filters.length === 0);
          }
          internal = newFilters.internal;
          newFilters = newFilters.filters;
          fieldType = typeof newFilters;
        }
      }
      if (newFilters) {
        const wasFiltered = me.isFiltered;
        me.isConfiguring = true;
        if (Array.isArray(newFilters)) {
          newFilters.forEach((f) => me.addFilter(f, true), me);
        } else if (fieldType === "function") {
          const filter = new CollectionFilter(newFilters);
          filter.internal = internal;
          me.addFilter(filter, true);
        } else if (fieldType === "string") {
          me.addFilter({
            property: newFilters,
            value: arguments[1]
          }, true);
        } else {
          me.addFilter(newFilters, true);
        }
        me.isConfiguring = false;
        if (!me.isFiltered && !wasFiltered) {
          return null;
        }
      }
    }
    me.filtersFunction = null;
    return me.performFilter(silent);
  }
  performFilter(silent) {
    const me = this, {
      storage,
      filters,
      rootNode
    } = me, oldCount = me.count;
    me.trigger("beforeFilter", {
      filters
    });
    let added, removed;
    if (me.tree) {
      const oldDataset = storage.values;
      if (me.isFiltered) {
        me.traverseFilter(rootNode);
      } else {
        me.traverseClearFilter(rootNode);
      }
      const newDataset = me.collectDescendants(rootNode).visible;
      storage.replaceValues({
        values: newDataset,
        silent: true
      });
      const delta = ArrayHelper.delta(newDataset, oldDataset, true);
      added = delta.toAdd;
      removed = delta.toRemove;
    } else {
      storage.ion({
        change({
          removed: r,
          added: a
        }) {
          removed = r;
          added = a;
        },
        once: true
      });
      if (me.isFiltered) {
        me.isGrouped && me.includeCollapsed();
        storage.addFilter({
          id: "primary-filter",
          filterBy: me.filtersFunction
        });
        me.isGrouped && me.excludeCollapsed();
      } else {
        storage.filters.clear();
      }
    }
    me.afterPerformFilter(silent || me.isRemoteDataLoading ? null : {
      action: "filter",
      filters,
      oldCount,
      added,
      removed,
      records: me.storage.values
    });
  }
  afterPerformFilter(event) {
    this.resetRelationCache();
    if (event) {
      this.triggerFilterEvent(event);
    }
  }
  get filtered() {
    return this.storage.isFiltered;
  }
  triggerFilterEvent(event) {
    this.trigger("filter", event);
    if (!this.remoteFilter) {
      this.trigger("refresh", event);
      this.trigger("change", event);
    }
  }
  filterBy(fn) {
    return this.filter(fn);
  }
  removeFilter(idOrInstance, silent = false) {
    const me = this, filter = idOrInstance instanceof CollectionFilter ? idOrInstance : me.filters.get(idOrInstance);
    if (filter) {
      me.filters.remove(filter);
      me._filtersFunction = null;
      if (!silent) {
        if (me.remoteFilter) {
          return me.filter().then(() => filter);
        } else {
          me.filter();
        }
      }
      return filter;
    }
  }
  clearFilters(apply = true) {
    this.filters.remove(this.filters.values.filter((f) => !f.internal));
    if (apply) {
      return this.filter();
    }
  }
  convertFilterToString(field) {
    const filter = this.filters.getBy("property", field);
    return filter && !filter.filterBy ? String(filter) : "";
  }
  doDestroy() {
    var _this$_filters;
    (_this$_filters = this._filters) === null || _this$_filters === void 0 ? void 0 : _this$_filters.destroy();
    super.doDestroy();
  }
};
var resortActions = {
  add: 1,
  replace: 1
};
var StoreGroup = (Target) => class StoreGroup extends (Target || Base) {
  static get $name() {
    return "StoreGroup";
  }
  static get defaultConfig() {
    return {
      groupers: null,
      useGroupFooters: false
    };
  }
  static get properties() {
    return {
      collapsedGroups: /* @__PURE__ */ new Set()
    };
  }
  construct(config) {
    super.construct(config);
    this.ion({
      change: "onDataChanged",
      thisObj: this
    });
  }
  get groupers() {
    return this._groupers;
  }
  set groupers(groupers) {
    this.setGroupers(groupers);
  }
  setGroupers(groupers, options) {
    const me = this, {
      storage
    } = me;
    let result;
    if (groupers !== null && groupers !== void 0 && groupers.length) {
      me._groupers = groupers;
    } else if (me.groupers) {
      delete me._groupers;
      me.includeCollapsed();
      storage.replaceValues({
        values: me.removeHeadersAndFooters(storage._values),
        filteredValues: storage.isFiltered ? me.removeHeadersAndFooters(storage._filteredValues) : null,
        silent: true
      });
      result = me.group(null, null, null, false, options === null || options === void 0 ? void 0 : options.silent);
    }
    me._idMap = null;
    return result;
  }
  get groupRecords() {
    const groupRecords = [];
    if (this.isGrouped) {
      for (const record of this) {
        if (record.isSpecialRow) {
          groupRecords.push(record);
        }
      }
    }
    return groupRecords;
  }
  includeCollapsed() {
    for (const groupId of this.collapsedGroups) {
      this.expand(this.getById(groupId), false);
    }
  }
  excludeCollapsed() {
    for (const groupId of this.collapsedGroups) {
      this.collapse(this.getById(groupId));
    }
  }
  onDataChange({
    source: storage,
    action,
    removed
  }) {
    var _super$onDataChange;
    const me = this, {
      groupers
    } = me;
    if (groupers) {
      if (groupers.length) {
        if (action === "splice" && removed !== null && removed !== void 0 && removed.length || action === "move") {
          storage.replaceValues({
            values: me.prepareGroupRecords(),
            silent: true
          });
        }
      } else {
        storage.replaceValues({
          values: me.removeHeadersAndFooters(storage.values),
          silent: true
        });
      }
    }
    (_super$onDataChange = super.onDataChange) === null || _super$onDataChange === void 0 ? void 0 : _super$onDataChange.call(this, ...arguments);
  }
  move(records, beforeRecord) {
    const me = this;
    if (me.isGrouped) {
      var _beforeRecord;
      if ((_beforeRecord = beforeRecord) !== null && _beforeRecord !== void 0 && _beforeRecord.isSpecialRow) {
        beforeRecord = me.getPrev(beforeRecord, false, false);
        if (!beforeRecord) {
          return;
        }
      }
      const groupField = me.groupers[0].field;
      let newGroupValue;
      if (beforeRecord) {
        newGroupValue = beforeRecord.isGroupHeader ? beforeRecord.meta.groupRowFor : beforeRecord[groupField];
      } else {
        newGroupValue = me.groupRecords[me.groupRecords.length - 1].meta.groupRowFor;
      }
      me.beginBatch();
      records.forEach((record) => record[groupField] = newGroupValue);
      me.endBatch();
    }
    super.move(...arguments);
  }
  collapse(groupRecord) {
    if (groupRecord && !groupRecord.meta.collapsed) {
      this.excludeGroupRecords(groupRecord);
      groupRecord.meta.collapsed = true;
      this.collapsedGroups.add(groupRecord.id);
      return true;
    }
    return false;
  }
  expand(groupRecord, updateMap = true) {
    if (groupRecord !== null && groupRecord !== void 0 && groupRecord.meta.collapsed) {
      this.includeGroupRecords(groupRecord);
      groupRecord.meta.collapsed = false;
      updateMap && this.collapsedGroups.delete(groupRecord.id);
      return true;
    }
    return false;
  }
  removeHeadersAndFooters(records) {
    return records.filter((r) => {
      if (r.isSpecialRow) {
        this.unregister(r);
        return false;
      } else {
        return true;
      }
    });
  }
  prepareGroupRecords(sorter) {
    var _me$storage$filteredV;
    const me = this, toCollapse = me.collapsedGroups, toExpand = [];
    let records = (_me$storage$filteredV = me.storage.filteredValues) !== null && _me$storage$filteredV !== void 0 ? _me$storage$filteredV : me.storage.values;
    for (const record of records) {
      if (record.isGroupHeader && (record.meta.collapsed || toCollapse.has(record.id))) {
        toCollapse.add(record.id);
        toExpand.push(record);
      }
    }
    for (const record of toExpand) {
      me.includeGroupRecords(record);
    }
    records = me.removeHeadersAndFooters(me.storage.values);
    if (sorter) {
      records = records.sort(sorter);
    }
    if (!me.isGrouped) {
      return records;
    }
    const groupedRecords = [], field = me.groupers[0].field;
    let curGroup = null, curGroupRecord = null, childCount = 0;
    function addFooter() {
      const val = curGroupRecord.meta.groupRowFor, id = `group-footer-${typeof val === "number" ? val : StringHelper.createId(val)}`, footer = me.getById(id) || new me.modelClass({
        id
      }, me, {
        specialRow: true,
        groupFooterFor: val,
        groupRecord: curGroupRecord
      });
      footer.stores = [me];
      me.register(footer);
      footer.groupChildren = curGroupRecord.groupChildren;
      if (!curGroupRecord.meta.collapsed) {
        groupedRecords.push(footer);
      }
      me.allRecords.push(footer);
      curGroupRecord.groupChildren.push(footer);
      childCount++;
      return footer;
    }
    records.forEach((record) => {
      var _record$groupChildren;
      const val = record[field] == void 0 ? "__novalue__" : record[field], id = `group-header-${typeof val === "number" ? val : StringHelper.createId(val)}`;
      if (((_record$groupChildren = record.groupChildren) === null || _record$groupChildren === void 0 ? void 0 : _record$groupChildren.length) === 0) {
        me.unregister(record);
        return;
      }
      if (!ObjectHelper.isEqual(val, curGroup)) {
        if (curGroupRecord) {
          if (me.useGroupFooters) {
            addFooter();
          }
          curGroupRecord.meta.childCount = childCount;
        }
        curGroupRecord = me.getById(id) || new me.modelClass({
          id
        }, me, {
          specialRow: true,
          groupRowFor: val,
          groupField: field
        });
        curGroupRecord.meta.collapsed = toCollapse.has(id);
        curGroupRecord.stores = [me];
        me.register(curGroupRecord);
        curGroupRecord.groupChildren = [];
        groupedRecords.push(curGroupRecord);
        me.allRecords.push(curGroupRecord);
        curGroup = val;
        childCount = 0;
      }
      record.instanceMeta(me.id).groupParent = curGroupRecord;
      if (!toCollapse.has(id)) {
        groupedRecords.push(record);
      }
      curGroupRecord.groupChildren.push(record);
      childCount++;
    });
    if (curGroupRecord) {
      if (me.useGroupFooters) {
        addFooter();
      }
      curGroupRecord.meta.childCount = childCount;
    }
    me._idMap = null;
    return groupedRecords;
  }
  get isGrouped() {
    var _this$groupers;
    return Boolean((_this$groupers = this.groupers) === null || _this$groupers === void 0 ? void 0 : _this$groupers.length);
  }
  group(field, ascending, add = false, performSort = true, silent = false) {
    const me = this;
    let newGrouper, fn;
    if (field && typeof field === "object") {
      ascending = field.ascending;
      fn = field.fn;
      field = field.field;
    }
    if (add) {
      me.groupers.push(newGrouper = {
        field,
        ascending,
        complexMapping: field.includes(".")
      });
    } else if (field) {
      if (ascending == null) {
        var _me$groupInfo, _me$groupInfo2;
        ascending = ((_me$groupInfo = me.groupInfo) === null || _me$groupInfo === void 0 ? void 0 : _me$groupInfo.field) === field && ((_me$groupInfo2 = me.groupInfo) === null || _me$groupInfo2 === void 0 ? void 0 : _me$groupInfo2.fn) === fn ? !me.groupInfo.ascending : true;
      }
      me.groupInfo = newGrouper = {
        field,
        ascending,
        fn,
        complexMapping: field.includes(".")
      };
      me.groupers = [me.groupInfo];
    }
    if (newGrouper) {
      const {
        prototype: prototype2
      } = me.modelClass;
      if (newGrouper.complexMapping && !Object.prototype.hasOwnProperty.call(prototype2, field)) {
        Object.defineProperty(prototype2, field, {
          get() {
            return ObjectHelper.getPath(this, field);
          }
        });
      }
    }
    if (performSort !== false) {
      if (me.remoteSort && !me.isRemoteDataLoading) {
        return me.sort(null, null, false, true).then(() => me.onAfterGrouping(silent));
      } else {
        me.sort(null, null, false, true);
      }
    }
    me.onAfterGrouping(silent);
  }
  onAfterGrouping(silent) {
    if (silent) {
      return;
    }
    const me = this;
    me.trigger("group", {
      isGrouped: me.isGrouped,
      groupers: me.groupers,
      records: me.storage.values
    });
    me.trigger("refresh", {
      action: "group",
      isGrouped: me.isGrouped,
      groupers: me.groupers,
      records: me.storage.values
    });
  }
  addGrouper(field, ascending = true) {
    return this.group(field, ascending, true);
  }
  removeGrouper(field) {
    const me = this, {
      groupers
    } = me, index = groupers.findIndex((grouper) => grouper.field === field);
    if (index > -1) {
      groupers.splice(index, 1);
      if (!groupers.length) {
        return me.clearGroupers();
      } else {
        return me.group();
      }
    }
  }
  clearGroupers(silent = false) {
    return this.setGroupers(null, {
      silent
    });
  }
  isRecordInGroup(record, groupValue) {
    var _this$groupers$;
    if (!this.isGrouped) {
      return null;
    }
    const groupField = (_this$groupers$ = this.groupers[0]) === null || _this$groupers$ === void 0 ? void 0 : _this$groupers$.field;
    return record[groupField] === groupValue && !record.isSpecialRow;
  }
  isInCollapsedGroup(record) {
    const parentGroupRec = record.instanceMeta(this).groupParent;
    return parentGroupRec === null || parentGroupRec === void 0 ? void 0 : parentGroupRec.meta.collapsed;
  }
  getGroupRecords(groupValue) {
    if (!this.isGrouped) {
      return null;
    }
    return this.storage.values.filter((record) => this.isRecordInGroup(record, groupValue));
  }
  getGroupTitles() {
    if (!this.isGrouped) {
      return null;
    }
    return this.getDistinctValues(this.groupers[0].field);
  }
  onDataChanged({
    changes,
    action
  }) {
    if (this.isGrouped && (!changes && resortActions[action] || changes && this.groupers.some((grouper) => grouper.field in changes))) {
      this.sort();
    }
  }
  internalIncludeExcludeGroupRecords(groupRecord, include) {
    const me = this, index = me.indexOf(groupRecord), {
      id: mapId,
      storage
    } = me, {
      meta,
      groupChildren
    } = groupRecord;
    if (index === -1 || meta.collapsed && !include || !meta.collapsed && include) {
      return;
    }
    groupChildren.forEach((child) => child.instanceMeta(mapId).hiddenByCollapse = !include);
    if (include) {
      const includeChildren = groupChildren.filter((r) => !me.isAvailable(r));
      storage.values.splice(index + 1, 0, ...includeChildren);
    } else {
      storage.values.splice(index + 1, groupChildren.length);
    }
    storage._indicesInvalid = true;
    me._idMap = null;
  }
  excludeGroupRecords(groupRecord) {
    this.internalIncludeExcludeGroupRecords(groupRecord, false);
  }
  includeGroupRecords(groupRecord) {
    this.internalIncludeExcludeGroupRecords(groupRecord, true);
  }
  collectGroupRecords(allRecords, includeHeaders = true) {
    const records = allRecords ? this.storage.allValues : this.storage.values;
    return records.reduce((records2, record) => {
      if (record.isSpecialRow) {
        if (includeHeaders && !record.isGroupFooter) {
          records2.push(record);
        }
        if (record.isGroupHeader) {
          records2.push.apply(records2, record.groupChildren);
        }
      }
      return records2;
    }, []);
  }
};
var StoreProxy = (Target) => class StoreProxy extends (Target || Base) {
  static get configurable() {
    return {
      objectify: null
    };
  }
  initProxy() {
    if (!globalThis.Proxy) {
      throw new Error("Proxy not supported");
    }
    const proxy = new Proxy(this, {
      get(target, property) {
        if (property in target) {
          return target[property];
        }
        if (property === "$store") {
          return target;
        }
        let record = target.getById(property);
        if (!record && !isNaN(parseInt(property))) {
          record = target.getAt(parseInt(property));
        }
        return record;
      },
      set(target, property, value) {
        if (property in target || target.isDestroying) {
          target[property] = value;
        } else {
          target.add(_objectSpread2({
            [target.modelClass.idField]: property
          }, value));
        }
        return true;
      },
      deleteProperty(target, property) {
        if (target.isDestroying) {
          delete target[property];
          return true;
        }
        return Boolean(target.remove(property).length);
      },
      has(target, property) {
        if (property in target) {
          return true;
        }
        if (property.startsWith("{") && property.endsWith("}")) {
          const data = StringHelper.safeJsonParse(property);
          property = data === null || data === void 0 ? void 0 : data.id;
        }
        return target.includes(property);
      }
    });
    return proxy;
  }
};
var StoreRelation = (Target) => {
  var _class;
  return _class = class StoreRelation extends (Target || Base) {
    initRelations(reset) {
      const me = this, relations = me.modelClass.exposedRelations;
      if (reset && me.modelRelations) {
        me.modelRelations.forEach((relation) => {
          var _relation$storeDetach;
          return (_relation$storeDetach = relation.storeDetacher) === null || _relation$storeDetach === void 0 ? void 0 : _relation$storeDetach.call(relation);
        });
      }
      if ((!me.modelRelations || me.modelRelations.length === 0 || reset) && relations) {
        me.modelRelations = [];
        relations === null || relations === void 0 ? void 0 : relations.forEach((modelRelationConfig) => {
          const config = _objectSpread2({}, modelRelationConfig), {
            foreignStore,
            relationName,
            relatedCollectionName
          } = config, relatedStore = typeof foreignStore === "string" ? me[foreignStore] : foreignStore;
          config.dependentStore = me;
          me.modelRelations.push(config);
          if (relatedStore) {
            config.foreignStoreProperty = config.foreignStore;
            config.foreignStore = relatedStore;
            const dependentStoreConfigs = relatedStore.dependentStoreConfigs;
            if (dependentStoreConfigs.has(me)) {
              const dependentConfigs = dependentStoreConfigs.get(me);
              if (reset) {
                const existingConfig = dependentConfigs.find((c) => c.relationName === relationName);
                if (existingConfig) {
                  ArrayHelper.remove(dependentConfigs, existingConfig);
                }
              }
              dependentConfigs.push(config);
            } else {
              dependentStoreConfigs.set(me, [config]);
            }
            if (relatedCollectionName) {
              relatedStore.initRelationCollection(config, me);
            }
            if (relatedStore.count > 0) {
              relatedStore.updateDependentStores("dataset", relatedStore.records);
            }
          }
        });
      }
    }
    initRelationCollection(config, collectionStore) {
      const me = this, name = config.relatedCollectionName, collectionStores = me.collectionStores || (me.collectionStores = {});
      collectionStores[name] = {
        store: collectionStore,
        config
      };
      if (!me[name + "Store"]) {
        me[name + "Store"] = collectionStore;
      }
      if (me.count > 0) {
        me.initModelRelationCollection(name, me.records);
      }
    }
    initModelRelationCollection(name, records) {
      const me = this;
      records.forEach((record) => {
        record.traverse((node) => {
          const useName = name in node ? `$related${StringHelper.capitalize(name)}` : name;
          Object.defineProperty(node, useName, {
            enumerable: true,
            configurable: true,
            get: function() {
              return me.getCollection(this, name);
            },
            set: function(value) {
              return me.setCollection(this, name, value);
            }
          });
        });
      });
    }
    resetRelationCache() {
      this.relationCache = {};
      this.forEach((record) => record.initRelations());
    }
    updateRecordRelationCache(record, relations) {
      relations === null || relations === void 0 ? void 0 : relations.forEach((relation) => {
        const {
          config
        } = relation, foreignId = relation.related ? relation.related.id : record.get(config.foreignKey);
        foreignId !== void 0 && this.cacheRelatedRecord(record, foreignId, config.relationName, foreignId);
      });
    }
    getRelationCollection(name, recordOrId) {
      const id = Model.asId(recordOrId);
      return this.relationCache[name] && this.relationCache[name][id] || [];
    }
    getCollection(record, name) {
      const {
        config,
        store
      } = this.collectionStores[name];
      return store.relationCache[config.relationName] && store.relationCache[config.relationName][record.id] || [];
    }
    setCollection(model, name, records) {
      const {
        config,
        store
      } = this.collectionStores[name], relationCache = store.relationCache[config.relationName] || (store.relationCache[config.relationName] = {}), old = (relationCache[model.id] || []).slice(), added = [], removed = [];
      store.suspendEvents();
      old.forEach((record) => {
        if (!records.includes(record)) {
          record[config.foreignKey] = null;
          store.remove(record);
          removed.push(record);
        }
      });
      records.forEach((record) => {
        if (record.isModel instanceof Model) {
          if (!record.stores.includes(store)) {
            store.add(record);
            added.push(record);
          }
        } else {
          [record] = store.add(record);
          added.push(record);
        }
        record[config.foreignKey] = model.id;
      });
      store.resumeEvents();
      if (removed.length) {
        store.trigger("remove", {
          records: removed
        });
        store.trigger("change", {
          action: "remove",
          records: removed
        });
      }
      if (added.length) {
        store.trigger("add", {
          records: added
        });
        store.trigger("change", {
          action: "add",
          records: added
        });
      }
    }
    cacheRelatedRecord(record, id, name, uncacheId = null) {
      const me = this, cache = me.relationCache[name] || (me.relationCache[name] = {});
      if (uncacheId !== null) {
        me.uncacheRelatedRecord(record, name, uncacheId);
      }
      if (id != null) {
        ArrayHelper.include(cache[id] || (cache[id] = []), record);
      }
    }
    uncacheRelatedRecord(record, name = null, id = null) {
      const me = this;
      function remove(relationName, relatedId) {
        const cache = me.relationCache[relationName], oldCache = cache === null || cache === void 0 ? void 0 : cache[relatedId];
        if (oldCache) {
          const uncacheIndex = oldCache.indexOf(record);
          uncacheIndex >= 0 && oldCache.splice(uncacheIndex, 1);
          if (oldCache.length === 0) {
            delete cache[relatedId];
          }
        }
      }
      if (id != null) {
        remove(name, id);
      } else {
        if (record.meta.relationCache) {
          Object.entries(record.meta.relationCache).forEach(([relationName, relatedRecord]) => remove(relationName, relatedRecord === null || relatedRecord === void 0 ? void 0 : relatedRecord.id));
        }
      }
    }
    updateDependentStores(action, records) {
      this.dependentStoreConfigs.forEach((configs) => {
        configs.forEach((config) => {
          const {
            dependentStore,
            relatedCollectionName,
            relationName,
            foreignKey
          } = config, cache = dependentStore.relationCache[relationName];
          if (action === "dataset") {
            relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);
            dependentStore.forEach((record) => {
              const foreign = record.initRelation(config);
              foreign && dependentStore.cacheRelatedRecord(record, foreign.id, relationName, foreign.id);
            });
            return;
          }
          if (action === "removeall") {
            dependentStore.forEach((record) => record.removeRelation(config));
            delete dependentStore.relationCache[relationName];
            return;
          }
          if (action === "add") {
            relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);
          }
          if (action === "add" || action === "remove") {
            records.forEach((record) => {
              const dependentRecords = cache === null || cache === void 0 ? void 0 : cache[record.id];
              switch (action) {
                case "remove":
                  if (dependentRecords) {
                    dependentRecords.forEach((dependentRecord) => dependentRecord.removeRelation(config));
                  }
                  break;
                case "add":
                  dependentStore.forEach((dependentRecord) => {
                    if (dependentRecord.get(foreignKey) == record.id) {
                      dependentRecord.initRelation(config);
                      dependentStore.cacheRelatedRecord(dependentRecord, record.id, relationName);
                    }
                  });
                  break;
              }
            });
          }
        });
      });
    }
    updateDependentRecordIds(oldValue, value) {
      var _this$dependentStoreC;
      (_this$dependentStoreC = this.dependentStoreConfigs) === null || _this$dependentStoreC === void 0 ? void 0 : _this$dependentStoreC.forEach((configs) => {
        configs.forEach((config) => {
          var _cache$oldValue;
          const {
            dependentStore,
            relationName,
            foreignKey
          } = config, cache = dependentStore.relationCache[relationName], localRecords = cache === null || cache === void 0 ? void 0 : (_cache$oldValue = cache[oldValue]) === null || _cache$oldValue === void 0 ? void 0 : _cache$oldValue.slice();
          localRecords === null || localRecords === void 0 ? void 0 : localRecords.forEach((localRecord) => {
            dependentStore.cacheRelatedRecord(localRecord, value, relationName, oldValue);
            localRecord.set(foreignKey, value, false, true);
          });
        });
      });
    }
  }, _defineProperty(_class, "$name", "StoreRelation"), _class;
};
var StoreSum = (Target) => class StoreSum extends (Target || Base) {
  static get $name() {
    return "StoreSum";
  }
  sum(field, records = this.storage.values) {
    if (!records)
      return 0;
    return records.reduce((sum, record) => {
      if (record.isSpecialRow)
        return sum;
      const v = Number(record[field]);
      return isNaN(v) ? sum : sum + v;
    }, 0);
  }
  min(field, records = this.storage.values) {
    if (!records || !records.length)
      return 0;
    return records.reduce((min2, record) => {
      var _record$field;
      const type = typeof ((_record$field = record[field]) === null || _record$field === void 0 ? void 0 : _record$field.valueOf());
      if (type === "number" && record[field] < min2)
        min2 = record[field];
      return min2;
    }, records[0][field]);
  }
  max(field, records = this.storage.values) {
    if (!records || !records.length)
      return 0;
    return records.reduce((max, record) => {
      var _record$field2;
      const type = typeof ((_record$field2 = record[field]) === null || _record$field2 === void 0 ? void 0 : _record$field2.valueOf());
      if (type === "number" && record[field] > max)
        max = record[field];
      return max;
    }, records[0][field]);
  }
  average(field, records = this.storage.values) {
    if (!records || !records.length)
      return 0;
    let count = 0;
    const sum = records.reduce((sum2, record) => {
      if (record.isSpecialRow)
        return sum2;
      const v = parseFloat(record[field]);
      if (!isNaN(v)) {
        count++;
        return sum2 + v;
      } else {
        return sum2;
      }
    }, 0);
    return count > 0 ? sum / count : 0;
  }
  groupSum(groupValue, field) {
    return this.sum(field, this.getGroupRecords(groupValue));
  }
};
var findInString = (value, text) => String(value).toLowerCase().includes(text);
var matchFns = {
  string: findInString,
  number: findInString,
  boolean: findInString,
  date: (value, text) => {
    if (value instanceof Date && text instanceof Date) {
      return value - text === 0;
    }
    return String(value.getMonth() + 1).includes(text) || String(value.getDate()).includes(text) || String(value.getFullYear()).includes(text);
  },
  object: (value, text) => value === text,
  undefined: (value, text) => value === text
};
var StoreSearch = (Target) => class StoreSearch extends (Target || Base) {
  static get $name() {
    return "StoreSearch";
  }
  search(text, fields = null, formatters, searchAllRecords) {
    const records = this.isTree && !searchAllRecords ? this.rootNode.allChildren : this.getAllDataRecords(searchAllRecords), len = records.length, found = [];
    if (text == null) {
      return [];
    }
    if (typeof text === "string") {
      text = text.toLowerCase();
    }
    let i, j, record, value, valueType, comparison;
    for (i = 0; i < len; i++) {
      record = records[i];
      j = 0;
      for (const key of fields || record.fieldNames) {
        var _comparison;
        value = record[key];
        valueType = value instanceof Date ? "date" : typeof value;
        const formatter = formatters === null || formatters === void 0 ? void 0 : formatters[j];
        if (formatter) {
          value = formatter(value);
          valueType = "string";
        }
        comparison = matchFns[valueType];
        if (value && (_comparison = comparison) !== null && _comparison !== void 0 && _comparison(value, text)) {
          found.push({
            index: i,
            data: record,
            field: key,
            id: record.id
          });
        }
        j++;
      }
    }
    return found;
  }
  findByField(field, value, distinct2 = false, searchAllRecords = false) {
    const records = this.getAllDataRecords(searchAllRecords), len = records.length, usedValues = /* @__PURE__ */ new Set(), found = [];
    let i, record, fieldValue;
    if (value != null) {
      value = String(value).toLowerCase();
    }
    for (i = 0; i < len; i++) {
      record = records[i];
      fieldValue = record[field];
      if (!distinct2 || !usedValues.has(fieldValue)) {
        const type = fieldValue instanceof Date ? "date" : typeof fieldValue, matchFn = matchFns[type];
        if (value == null && fieldValue === value || value && matchFn(fieldValue, value)) {
          found.push({
            id: record.id,
            index: i,
            data: record
          });
          if (distinct2) {
            usedValues.add(fieldValue);
          }
        }
      }
    }
    return found;
  }
  find(fn, searchAllRecords = false) {
    return this.getAllDataRecords(searchAllRecords).find(fn);
  }
  findRecord(fieldName, value, searchAllRecords = false) {
    const matchFn = (r) => ObjectHelper.isEqual(r[fieldName], value);
    if (this.isTree) {
      return this.query(matchFn, searchAllRecords)[0];
    }
    return this.getAllDataRecords(searchAllRecords).find(matchFn);
  }
  query(fn, searchAllRecords = false) {
    if (this.isTree) {
      const matches = [];
      this.traverse((node) => {
        if (fn(node)) {
          matches.push(node);
        }
      }, void 0, void 0, searchAllRecords);
      return matches;
    }
    return this.getAllDataRecords(searchAllRecords).filter(fn);
  }
  some(fn, searchAllRecords = false) {
    return this.getAllDataRecords(searchAllRecords).some(fn);
  }
};
var nestedRe = /\./;
var StoreSort = (Target) => class StoreSort extends (Target || Base) {
  static get $name() {
    return "StoreSort";
  }
  static get defaultConfig() {
    return {
      useLocaleSort: null
    };
  }
  static get configurable() {
    return {
      sorters: [],
      reapplySortersOnAdd: false
    };
  }
  get isSorted() {
    return Boolean(this.sorters.length) || this.isGrouped;
  }
  changeSorters(sorters) {
    return sorters.map((sorter) => this.normalizeSorterConfig(sorter, true));
  }
  updateReapplySortersOnAdd(enable) {
    this.storage.autoSort = enable;
  }
  sort(field, ascending, add = false, silent = false) {
    const me = this, records = me.allRecords, currentSorters = me.sorters ? me.sorters.slice() : [];
    let currentDir = null, curSort;
    if (field) {
      if (Array.isArray(field)) {
        me.sorters = field.map((sorter) => me.normalizeSorterConfig(sorter, typeof sorter === "string" ? true : ascending));
      } else {
        const sorter = me.normalizeSorterConfig(field, ascending);
        if (add) {
          curSort = me.getCurrentSorterByField(sorter.field);
          if (curSort) {
            currentDir = curSort.ascending;
            curSort.ascending = sorter.ascending;
          } else {
            me.sorters.push(sorter);
          }
        } else {
          me.sorters = [sorter];
        }
      }
    }
    if (!silent && me.trigger("beforeSort", {
      sorters: me.sorters,
      records,
      currentSorters
    }) === false) {
      me.sorters = currentSorters;
      if (currentDir !== null) {
        curSort.ascending = currentDir;
      }
      return null;
    }
    return me.performSort(silent);
  }
  normalizeSorterConfig(field, ascending) {
    const me = this, sorter = {
      ascending
    };
    if (typeof field === "object") {
      var _field$ascending;
      ObjectHelper.assign(sorter, field);
      if (field.fn) {
        delete sorter.fn;
        sorter.sortFn = field.fn;
      }
      sorter.ascending = (_field$ascending = field.ascending) !== null && _field$ascending !== void 0 ? _field$ascending : ascending;
    } else if (typeof field === "function") {
      sorter.sortFn = field;
    } else {
      sorter.field = field;
    }
    if (sorter.ascending == null) {
      const curSort = me.getCurrentSorterByField(sorter.field);
      sorter.ascending = curSort ? !curSort.ascending : true;
    }
    if (sorter.sortFn == null) {
      var _me$modelClass, _me$modelClass$$meta$;
      const compareItems = (_me$modelClass = me.modelClass) === null || _me$modelClass === void 0 ? void 0 : (_me$modelClass$$meta$ = _me$modelClass.$meta.fields.map[sorter.field]) === null || _me$modelClass$$meta$ === void 0 ? void 0 : _me$modelClass$$meta$.compareItems;
      if (compareItems) {
        sorter.sortFn = compareItems;
      }
    }
    return sorter;
  }
  getCurrentSorterByField(field) {
    return typeof field === "string" && this.sorters.find((s) => s.field === field) || null;
  }
  addSorter(field, ascending = true) {
    return this.sort(field, ascending, true);
  }
  removeSorter(field) {
    const sorterIndex = this.sorters.findIndex((sorter) => sorter.field === field || sorter.sortFn === field);
    if (sorterIndex > -1) {
      this.sorters.splice(sorterIndex, 1);
      return this.sort();
    }
  }
  clearSorters(silent = false) {
    if (this.sorters.length) {
      this.sorters.length = 0;
      return this.sort(void 0, void 0, void 0, silent);
    }
  }
  createSorterFn(sorters) {
    const storeLocaleSort = this.useLocaleSort;
    return (lhs, rhs) => {
      for (let i = 0; i < sorters.length; i++) {
        const sorter = sorters[i], {
          field,
          ascending = true,
          useLocaleSort = storeLocaleSort
        } = sorter, fn = sorter.fn || sorter.sortFn, direction = ascending ? 1 : -1;
        if (fn) {
          const val = fn.call(sorter, lhs, rhs);
          if (val !== null) {
            return val * direction;
          }
        }
        const nested = nestedRe.test(field), lhsValue = nested ? lhs.get(field) : lhs[field], rhsValue = nested ? rhs.get(field) : rhs[field];
        if (lhsValue === rhsValue) {
          continue;
        }
        if (lhsValue == null) {
          return -direction;
        }
        if (rhsValue == null) {
          return direction;
        }
        if (useLocaleSort && typeof lhsValue === "string") {
          if (useLocaleSort === true) {
            return String(lhsValue).localeCompare(rhsValue) * direction;
          }
          if (typeof useLocaleSort === "string") {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort) * direction;
          }
          if (typeof useLocaleSort === "object") {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort.locale, useLocaleSort) * direction;
          }
        }
        if (lhsValue > rhsValue) {
          return direction;
        }
        if (lhsValue < rhsValue) {
          return -direction;
        }
      }
      return 0;
    };
  }
  get sorterFn() {
    const me = this, {
      sorters
    } = me;
    return me.createSorterFn(me.remoteSort ? [{
      field: "_remoteSortIndex"
    }] : me.isGrouped ? me.groupers.concat(sorters) : sorters);
  }
  performSort(silent) {
    const me = this, {
      rootNode,
      storage,
      sorterFn: sorter
    } = me;
    if (me.tree) {
      !me.isChained && rootNode.traverse((node) => {
        if (node.isLoaded && node.isParent) {
          node.children.sort(sorter);
          node.updateChildrenIndices(node.children, "parentIndex", true);
        }
      });
      storage.replaceValues({
        values: me.collectDescendants(rootNode).visible,
        silent: true
      });
    } else if (me.isGrouped) {
      storage.replaceValues({
        values: me.prepareGroupRecords(sorter),
        silent: true
      });
    } else {
      storage.replaceValues({
        values: storage.values.sort(sorter),
        silent: true
      });
    }
    me.afterPerformSort(silent || me.isRemoteDataLoading);
  }
  afterPerformSort(silent) {
    if (silent) {
      return;
    }
    const me = this;
    me._idMap = null;
    const event = {
      action: "sort",
      sorters: me.sorters,
      records: me.allRecords
    };
    me.trigger("sort", event);
    me.trigger("refresh", event);
  }
};
var returnTrue = (rec) => true;
var StoreChained = (Target) => class StoreChained extends (Target || Base) {
  static get $name() {
    return "StoreChained";
  }
  static get defaultConfig() {
    return {
      chainedFilterFn: null,
      chainedFields: null,
      masterStore: null,
      doRelayToMaster: ["add", "remove", "insert"],
      dontRelayToMaster: [],
      keepUncommittedChanges: false,
      excludeCollapsedRecords: true
    };
  }
  static get properties() {
    return {
      chainedStores: null
    };
  }
  construct(config) {
    super.construct(config);
    const me = this, {
      masterStore
    } = me, sort = me.syncOrder ? "sort" : "";
    if (masterStore) {
      me.methodNamesToRelay.forEach((fnName) => me[fnName] = (...params) => me.relayToMaster(fnName, params));
      me.removeAll = (...params) => {
        masterStore.remove(me.getRange(), ...params);
      };
      masterStore.ion({
        changePreCommit: me.onMasterDataChangedPreCommit,
        change: me.onMasterDataChanged,
        [sort]: me.onMasterDataChanged,
        prio: 1,
        thisObj: me
      });
      if (!masterStore.chainedStores) {
        masterStore.chainedStores = [];
      }
      masterStore.chainedStores.push(me);
      me.fillFromMaster();
    }
  }
  get $master() {
    return this.masterStore || this;
  }
  get isChained() {
    return Boolean(this.masterStore);
  }
  set chainedFilterFn(chainedFilterFn) {
    this._chainedFilterFn = this.thisObj ? chainedFilterFn.bind(this.thisObj) : chainedFilterFn;
  }
  get chainedFilterFn() {
    return this._chainedFilterFn || returnTrue;
  }
  get methodNamesToRelay() {
    const doIsArray = Array.isArray(this.doRelayToMaster), dontIsArray = Array.isArray(this.dontRelayToMaster);
    return doIsArray && this.doRelayToMaster.filter((name) => !dontIsArray || !this.dontRelayToMaster.includes(name)) || [];
  }
  updateChainedStores() {
    if (this.chainedStores) {
      this.chainedStores.forEach((store) => store.fillFromMaster());
    }
  }
  fillFromMaster() {
    const me = this, {
      masterStore,
      isTree
    } = me, isRecordFilter = me.chainedFilterFn.length > 0 || me.chainedFilterFn.toString().length <= 10;
    let records;
    if (!me.isChained) {
      throw new Error("fillFromMaster only allowed on chained store");
    }
    if (me.keepUncommittedChanges) {
      if (isTree) {
        throw new Error("Cannot use keepUncommittedChanges on a chained tree store");
      }
      if (isRecordFilter) {
        records = masterStore.allRecords.filter((r) => !me.removed.includes(r) && !me.added.includes(r) && me.chainedFilterFn(r));
      } else {
        records = me.chainedFilterFn().filter((r) => !me.removed.includes(r) && !me.added.includes(r));
      }
      records = me.added.values.filter((r) => !me.removed.includes(r)).concat(records);
    } else {
      if (isRecordFilter) {
        records = masterStore.allRecords.filter(me.chainedFilterFn);
      } else {
        records = me.chainedFilterFn();
      }
      if (isTree) {
        me.idRegister = {};
        me.internalIdRegister = {};
        records.forEach((r) => {
          if (r.stores.includes(me)) {
            me.register(r);
          } else {
            r.joinStore(me);
          }
        });
        if (me.excludeCollapsedRecords) {
          const children = me.getChildren(me.rootNode);
          records = me.doIncludeExclude(children, true);
        }
      }
    }
    me.data = records;
  }
  commitToMaster() {
    const me = this, master = me.masterStore;
    if (!me.isChained) {
      throw new Error("commitToMaster only allowed on chained store");
    }
    master.beginBatch();
    master.remove(me.removed.values);
    master.add(me.added.values);
    master.endBatch();
    return me.commit();
  }
  relayToMaster(fnName, params) {
    return this.masterStore[fnName](...params);
  }
  onMasterDataChangedPreCommit(event) {
    this.onMasterDataChanged(event);
    this.$masterEventhandled = true;
  }
  onMasterDataChanged({
    action,
    changes,
    $handled,
    isMove
  }) {
    var _this$chainedFields;
    if (this.$masterEventhandled) {
      this.$masterEventhandled = false;
      return;
    }
    if (isMove && action === "remove") {
      return;
    }
    if (action !== "update" || (_this$chainedFields = this.chainedFields) !== null && _this$chainedFields !== void 0 && _this$chainedFields.some((field) => field in changes)) {
      this.fillFromMaster();
    }
  }
  makeChained(chainedFilterFn = returnTrue, chainedFields, config) {
    return new ((config === null || config === void 0 ? void 0 : config.storeClass) || this.constructor)(_objectSpread2(_objectSpread2({}, config || {}), {}, {
      tree: false,
      autoTree: false,
      masterStore: this.$master,
      modelClass: this.modelClass,
      syncDataOnLoad: false,
      chainedFilterFn,
      chainedFields
    }));
  }
  chain() {
    return this.makeChained(...arguments);
  }
  doDestroy() {
    var _this$chainedStores;
    (_this$chainedStores = this.chainedStores) === null || _this$chainedStores === void 0 ? void 0 : _this$chainedStores.forEach((chainedStore) => chainedStore.destroy());
    super.doDestroy();
  }
};
var StoreState = (Target) => class StoreState extends (Target || Base) {
  static get $name() {
    return "StoreState";
  }
  getState() {
    const {
      sorters,
      groupers,
      filters
    } = this, state = {};
    if (sorters !== null && sorters !== void 0 && sorters.length) {
      state.sorters = sorters.map((sorter) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(sorter));
        delete clone.fn;
        delete clone.sortFn;
        return clone;
      });
    }
    if (groupers !== null && groupers !== void 0 && groupers.length) {
      state.groupers = groupers.map((grouper) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(grouper));
        delete clone.fn;
        return clone;
      });
    }
    if (filters !== null && filters !== void 0 && filters.values.length) {
      state.filters = filters.values.map((filter) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(filter.config));
        clone.value = filter.value;
        if (clone.caseSensitive) {
          delete clone.caseSensitive;
        }
        return clone;
      });
    }
    return state;
  }
  applyState(state) {
    const me = this, {
      sorters = [],
      groupers = [],
      filters = []
    } = state, {
      sortParamName,
      filterParamName
    } = me;
    me.sorters = sorters.filter((sorter) => sorter.field || sorter.sortFn && !sortParamName);
    me.groupers = groupers.slice();
    me.sort();
    me.filters = filters.filter((filter) => filter.property || filter.filterBy && !filterParamName);
    me.filter();
  }
};
var zeroPad = (v) => String(v).padStart(6, "0");
var Wbs = class {
  constructor(value) {
    this.value = value;
    this._padded = null;
  }
  set value(value) {
    this._value = String(value !== null && value !== void 0 ? value : "");
  }
  get value() {
    return this._value;
  }
  static from(value) {
    return value == null ? value : value instanceof Wbs ? value : new Wbs(value);
  }
  static pad(value) {
    return value instanceof Wbs ? value.valueOf() : Wbs.split(value).map(zeroPad).join(".");
  }
  static split(value) {
    let i, ret;
    if (value || value === 0) {
      switch (typeof value) {
        case "object":
          value = String(value);
        case "string":
          ret = value.split(".");
          for (i = ret.length; i-- > 0; ) {
            ret[i] = parseInt(ret[i], 10);
          }
          break;
        case "number":
          ret = [value];
          break;
      }
    }
    return ret || [];
  }
  static compare(lhs, rhs) {
    if (lhs === rhs) {
      return 0;
    }
    if (!lhs || !rhs) {
      return lhs ? 1 : rhs ? -1 : 0;
    }
    lhs = Wbs.pad(lhs);
    rhs = Wbs.pad(rhs);
    return lhs < rhs ? -1 : rhs < lhs ? 1 : 0;
  }
  append(value) {
    const s = this.value;
    return Wbs.from(s ? `${s}.${value}` : value);
  }
  isEqual(value) {
    return !Wbs.compare(this, value);
  }
  match(pattern) {
    let ret = false;
    if (pattern) {
      const wbs = this.value, globLeft = pattern[0] === "*", globRight = pattern.endsWith("*"), n = pattern.length;
      if (globLeft === globRight) {
        ret = wbs.indexOf(globLeft ? pattern.substr(1, n - 2) : pattern) > -1;
      } else if (globLeft) {
        ret = wbs.endsWith(pattern.substr(1));
      } else {
        ret = wbs.startsWith(pattern.substr(0, n - 1));
      }
    }
    return ret;
  }
  toString() {
    return this.value;
  }
  toJSON() {
    return this.toString();
  }
  valueOf() {
    var _this$_padded;
    return (_this$_padded = this._padded) !== null && _this$_padded !== void 0 ? _this$_padded : this._padded = Wbs.pad(this.value);
  }
};
Wbs._$name = "Wbs";
var emptyArray$6 = Object.freeze([]);
var StoreTree = (Target) => {
  var _class;
  return _class = class StoreTree extends (Target || Base) {
    get isTree() {
      return this.tree || this.masterStore && this.masterStore.tree;
    }
    get leaves() {
      const me = this, result = [];
      if (me.isTree) {
        me.traverse((record) => {
          if (record.isLeaf) {
            result.push(record);
          }
        });
        return result;
      } else {
        me.allRecords.forEach((r) => {
          if (r.isLeaf) {
            result.push(r);
          }
          r.traverse((record) => {
            if (record.isLeaf) {
              result.push(record);
            }
          }, true);
        });
      }
      return result;
    }
    async loadChildren(parentRecord) {
    }
    onNodeAddChild(parent, children, index, isMove, silent = false) {
      const me = this, isRootLoad = parent === me.rootNode && parent.isLoading, {
        storage
      } = me, toAddToUI = [], toAdd = [], {
        previousSibling
      } = children[0];
      let storeInsertionPoint;
      me.collectDescendants(children, toAddToUI, toAdd, {
        inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me))
      });
      if (!isRootLoad && toAdd.length) {
        for (const record of toAdd) {
          if (!me.modified.includes(record) && !isMove[record.id]) {
            if (me.removed.includes(record)) {
              me.removed.remove(record);
            } else if (!record.isLinked) {
              me.added.add(record);
            }
          }
        }
      }
      if (isRootLoad && me.rootVisible) {
        toAddToUI.unshift(parent);
        toAdd.unshift(parent);
      }
      if (toAddToUI.length) {
        if (index === 0 || !previousSibling) {
          storeInsertionPoint = storage.indexOf(parent);
        } else {
          storeInsertionPoint = storage.indexOf(previousSibling) + previousSibling.getDescendantCount(true, me);
        }
        storage.suspendEvents();
        me.storage.splice(++storeInsertionPoint, 0, toAddToUI);
        storage.resumeEvents();
        me._idMap = null;
      }
      me.updateDependentStores("add", children);
      if (isRootLoad && toAddToUI.length) {
        var _me$afterLoadData;
        if (me.sorters.length) {
          me.sort(null, null, false, true);
        }
        (_me$afterLoadData = me.afterLoadData) === null || _me$afterLoadData === void 0 ? void 0 : _me$afterLoadData.call(me);
        if (!silent) {
          const event = {
            action: "dataset",
            data: me._data,
            records: toAddToUI
          };
          me.trigger("refresh", event);
          me.trigger("change", event);
        }
      } else if (!silent) {
        const event = {
          action: "add",
          parent,
          isChild: true,
          isMove,
          records: children,
          allRecords: toAdd,
          index: storeInsertionPoint
        };
        me.trigger("add", event);
        me.trigger("change", event);
        if (Object.values(isMove).some((wasMoved) => wasMoved)) {
          const event2 = {
            newParent: parent,
            records: children.filter((record) => isMove[record.id]),
            oldParents: children.map((child) => {
              const parent2 = me.getById(child.meta.oldParentId);
              return parent2 !== null && parent2 !== void 0 && parent2.isRoot ? null : parent2;
            })
          };
          me.trigger("move", event2);
        }
      }
    }
    onNodeRemoveChild(parent, children, index, flags = {
      isMove: false,
      silent: false,
      unfiltered: false
    }) {
      const me = this, {
        storage
      } = me, toRemoveFromUI = [], toRemove = [], {
        isMove,
        silent,
        unfiltered
      } = flags, removeUnfiltered = unfiltered && me.isFiltered, childrenToRemove = removeUnfiltered && parent.unfilteredChildren ? parent.unfilteredChildren : children;
      me.collectDescendants(childrenToRemove, toRemoveFromUI, toRemove, {
        inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me)),
        unfiltered: removeUnfiltered
      });
      if (!isMove) {
        for (const record of children) {
          record.unjoinStore(me);
        }
        for (const record of toRemove) {
          if (record.stores.includes(me)) {
            record.unjoinStore(me);
          }
          if (me.added.includes(record)) {
            me.added.remove(record);
          } else if (!record.isLinked) {
            me.removed.add(record);
          }
        }
        me.modified.remove(toRemove);
      }
      if (toRemoveFromUI.length) {
        index = storage.indexOf(toRemoveFromUI[0]);
        if (index > -1) {
          storage.suspendEvents();
          storage.splice(index, toRemoveFromUI.length);
          storage.resumeEvents();
          me._idMap = null;
        }
      } else {
        index = -1;
      }
      if (!silent && (me.fireRemoveEventForMoveAction || !isMove)) {
        const event = {
          action: "remove",
          parent,
          isChild: true,
          isMove,
          records: children,
          allRecords: toRemove,
          index
        };
        me.trigger("remove", event);
        me.trigger("change", event);
      }
      return toRemove;
    }
    collectDescendants(node, visible = [], all = [], flags) {
      const me = this, {
        inCollapsedBranch = false,
        unfiltered = false
      } = flags || 0, children = Array.isArray(node) ? node : me.getChildren(node, unfiltered);
      if (children) {
        for (let i = 0, len = children.length, child; i < len; i++) {
          child = children[i];
          if (!inCollapsedBranch) {
            visible.push(child);
          }
          all.push(child);
          me.collectDescendants(child, visible, all, {
            inCollapsedBranch: inCollapsedBranch || !child.isExpanded(me),
            unfiltered
          });
        }
      }
      return {
        visible,
        all
      };
    }
    getChildren(parent, unfiltered = false) {
      const me = this, children = (unfiltered || me.isChained) && parent.unfilteredChildren || parent.children;
      return !(children !== null && children !== void 0 && children.length) ? emptyArray$6 : me.isChained ? children.filter(me.chainedFilterFn).sort(me.sorterFn) : children;
    }
    internalToggleTreeSubRecords(parentRecord, include) {
      const me = this, {
        storage
      } = me, index = storage.indexOf(parentRecord), children = me.doIncludeExclude(me.getChildren(parentRecord), include);
      if (me.isFiltered && include && parentRecord.unfilteredChildren) {
        me.updateChildrenHiddenState(parentRecord);
      }
      if (children.length && index !== false) {
        storage.suspendEvents();
        if (include) {
          storage.splice(index + 1, 0, ...children);
          const event = {
            action: "add",
            isExpand: true,
            records: children,
            index: index + 1
          };
          me.trigger("add", event);
          me.trigger("change", event);
        } else {
          storage.splice(index + 1, children.length);
          const event = {
            action: "remove",
            isCollapse: true,
            records: children,
            index: index + 1
          };
          me.trigger("remove", event);
          me.trigger("change", event);
        }
        storage.resumeEvents();
        me._idMap = null;
      }
    }
    updateChildrenHiddenState(parentRecord) {
      var _parentRecord$unfilte;
      (_parentRecord$unfilte = parentRecord.unfilteredChildren) === null || _parentRecord$unfilte === void 0 ? void 0 : _parentRecord$unfilte.forEach((child) => {
        child.instanceMeta(this.id).hidden = false;
        if (!child.isLeaf) {
          this.updateChildrenHiddenState(child);
        }
      });
    }
    doIncludeExclude(children, include, result = []) {
      const me = this, childCount = (children === null || children === void 0 ? void 0 : children.length) || 0;
      for (let i = 0; i < childCount; i++) {
        const child = children[i];
        if (!me.isChained || me.chainedFilterFn(child)) {
          const mapMeta = child.instanceMeta(me.id);
          if (include || !mapMeta.hidden) {
            result.push(child);
          }
          mapMeta.hidden = !include;
          if (child.isExpanded(me)) {
            me.doIncludeExclude(me.getChildren(child), include, result);
          }
        }
      }
      return result;
    }
    async toggleCollapse(idOrRecord, collapse) {
      const me = this, record = me.getById(idOrRecord), meta = record.instanceMeta(me);
      if (collapse === void 0) {
        collapse = !meta.collapsed;
      }
      if (!meta.isLoadingChildren && !record.isLeaf && record.isExpanded(me) === collapse) {
        me.trigger("beforeToggleNode", {
          record,
          collapse
        });
        meta.collapsed = collapse;
        if (meta.collapsed) {
          me.onNodeCollapse(record);
          return true;
        } else {
          me.onNodeExpand(record);
          let success2 = true;
          if (!record.isLoaded) {
            meta.isLoadingChildren = true;
            try {
              await me.loadChildren(record);
            } catch (exception) {
              meta.collapsed = true;
              success2 = false;
              me.trigger("loadChildrenException", {
                record,
                exception
              });
            } finally {
              meta.isLoadingChildren = false;
            }
          }
          return success2;
        }
      }
    }
    onNodeCollapse(parentRecord) {
      if (parentRecord.ancestorsExpanded(this)) {
        return this.internalToggleTreeSubRecords(parentRecord, false);
      }
    }
    onNodeExpand(parentRecord) {
      if (parentRecord.ancestorsExpanded(this)) {
        return this.internalToggleTreeSubRecords(parentRecord, true);
      }
    }
    transformToTree(data) {
      const {
        parentIdField,
        idField,
        childrenField
      } = this.modelClass, parents = /* @__PURE__ */ new Map(), transformed = [];
      for (const node of data) {
        const parentId = node[parentIdField];
        if (parentId != null) {
          let parent = parents.get(parentId);
          if (parent === void 0) {
            var _data$find;
            parent = (_data$find = data.find((node2) => node2[idField] === parentId)) !== null && _data$find !== void 0 ? _data$find : null;
            parents.set(parentId, parent);
          }
          if (parent) {
            if (!parent[childrenField]) {
              parent[childrenField] = [];
            }
            parent[childrenField].push(node);
          }
        } else {
          transformed.push(node);
        }
      }
      return transformed;
    }
    treeify(fields, parentTransform, convertParents = false) {
      const {
        length
      } = fields, parents = [], newRoot = {};
      let i, lastParent;
      for (i = 0; i < length; i++) {
        if (!fields[i].call) {
          const field = fields[i];
          fields[i] = (n) => n[field];
        }
        parents[i] = /* @__PURE__ */ new Map();
      }
      this.rootNode.traverse((n) => {
        lastParent = null;
        if (n.isLeaf) {
          for (i = 0; i < length; i++) {
            var _lastParent;
            const lastParentPath = ((_lastParent = lastParent) === null || _lastParent === void 0 ? void 0 : _lastParent.path) || "", nodeMap = parents[i], key = fields[i](n), path = `${lastParentPath + key}/`, id = StringHelper.makeValidDomId(`generated_${path}`, "_"), parent = nodeMap.get(id) || nodeMap.set(id, {
              id,
              key,
              path,
              expanded: true,
              readOnly: true,
              children: [],
              generatedParent: true
            }).get(id);
            if (lastParent && !lastParent.children.includes(parent)) {
              lastParent.children.push(parent);
            }
            lastParent = parent;
          }
          lastParent.children.push(n);
        }
      }, true);
      parents.forEach((p) => p.forEach((p2, id, map) => {
        parentTransform === null || parentTransform === void 0 ? void 0 : parentTransform(p2);
        if (convertParents) {
          p2 = this.createRecord(p2);
          map.set(id, p2);
        }
      }));
      newRoot.children = [...parents[0].values()];
      const sort = (n) => {
        if (n.children) {
          n.children.sort((lhs, rhs) => {
            if (lhs.isLeaf) {
              let result;
              for (let i2 = 0; !result && i2 < length; i2++) {
                const lv = fields[i2](lhs), rv = fields[i2](rhs);
                result = lv < rv ? -1 : rv > lv ? 1 : 0;
              }
              return result;
            } else {
              if (typeof lhs.key === "string" || typeof rhs.key === "string") {
                return lhs.key.localeCompare(rhs.key, void 0, {
                  numeric: true
                });
              }
              return lhs.key < rhs.key ? -1 : lhs.key > rhs.key ? 1 : 0;
            }
          });
          n.children.forEach(sort);
        }
      };
      sort(newRoot);
      return newRoot;
    }
    treeifyFlatData(data) {
      const {
        childrenField,
        parentIdField
      } = this.modelClass;
      let hasParentId = false, shouldTransform = true;
      for (const node of data) {
        if (node.isModel || Array.isArray(node[childrenField])) {
          shouldTransform = false;
          break;
        }
        if (node[parentIdField] != null) {
          hasParentId = true;
        }
      }
      if (shouldTransform && hasParentId) {
        data = this.transformToTree(data);
      }
      return data;
    }
    async indent(nodes) {
      const me = this;
      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes = nodes.filter((node) => {
        let result = Boolean(node.previousSibling);
        while (result && !node.isRoot) {
          result = !nodes.includes(node.parent);
          node = node.parent;
        }
        return result;
      });
      if (nodes.length && me.trigger("beforeIndent", {
        records: nodes
      }) !== false) {
        nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));
        me.beginBatch();
        for (const node of nodes) {
          const newParent = node.previousSibling;
          newParent.appendChild(node);
          me.toggleCollapse(newParent, false);
        }
        me.endBatch();
        me.trigger("indent", {
          records: nodes
        });
        me.trigger("change", {
          action: "indent",
          records: nodes
        });
      }
    }
    async outdent(nodes) {
      const me = this;
      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes = nodes.filter((node) => {
        const {
          parent
        } = node;
        let result = parent && !parent.isRoot;
        while (result && !node.isRoot) {
          result = !nodes.includes(parent);
          node = node.parent;
        }
        return result;
      });
      if (nodes.length && me.trigger("beforeOutdent", {
        records: nodes
      }) !== false) {
        nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));
        me.beginBatch();
        for (const node of nodes) {
          const {
            parent
          } = node, newChildren = parent.children.slice(parent.children.indexOf(node) + 1);
          parent.parent.insertChild(node, parent.nextSibling);
          node.appendChild(newChildren);
          me.toggleCollapse(node, false);
        }
        me.endBatch();
        me.trigger("outdent", {
          records: nodes
        });
        me.trigger("change", {
          action: "outdent",
          records: nodes
        });
      }
    }
  }, _defineProperty(_class, "$name", "StoreTree"), _defineProperty(_class, "configurable", {
    transformFlatData: null,
    fireRemoveEventForMoveAction: VersionHelper.checkVersion("core", "6.0", "<")
  }), _class;
};
var WalkHelper = class {
  static preWalk(data, childrenFn, fn) {
    const walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack.pop();
      fn(node);
      children = childrenFn(node);
      if (children) {
        walkStack.push.apply(walkStack, children.slice().reverse());
      }
    }
  }
  static preWalkWithParent(data, childrenFn, fn) {
    const walkStack = [{
      node: data,
      parent: null
    }];
    while (walkStack.length) {
      const {
        parent,
        node
      } = walkStack.pop();
      fn(parent, node);
      const children = childrenFn(node);
      if (Array.isArray(children)) {
        walkStack.push(...children.slice().reverse().map((child) => ({
          node: child,
          parent: node
        })));
      }
    }
  }
  static preWalkUnordered(data, childrenFn, fn) {
    const walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      fn(node);
      children = childrenFn(node);
      if (children) {
        walkStack.splice(walkStack.length - 1, 1, ...children);
      } else {
        walkStack.length = walkStack.length - 1;
      }
    }
  }
  static postWalk(data, childrenFn, fn) {
    const visited = /* @__PURE__ */ new Map(), walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      if (visited.has(node)) {
        fn(node);
        walkStack.pop();
      } else {
        children = childrenFn(node);
        if (children) {
          walkStack.push(...children.slice().reverse());
        }
        visited.set(node, node);
      }
    }
  }
  static prePostWalk(data, childrenFn, inFn, outFn) {
    const visited = /* @__PURE__ */ new Map(), walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      if (visited.has(node)) {
        outFn(node);
        walkStack.pop();
      } else {
        inFn(node);
        children = childrenFn(node);
        if (children) {
          walkStack.push(...children.slice().reverse());
        }
        visited.set(node, node);
      }
    }
  }
};
WalkHelper._$name = "WalkHelper";
var StoreSync = (Target) => class StoreSync extends (Target || Base) {
  static get $name() {
    return "StoreSync";
  }
  static get configurable() {
    return {
      syncDataOnLoad: null
    };
  }
  syncDataset(data) {
    const me = this, {
      storage
    } = me;
    me.isSyncingDataOnLoad = true;
    const {
      toAdd,
      toRemove,
      toMove,
      updated,
      ids
    } = me.tree ? me.syncTreeDataset(data) : me.syncFlatDataset(data);
    let {
      threshold
    } = me.syncDataOnLoad, surpassed = false;
    if (threshold) {
      if (typeof threshold === "string") {
        threshold = parseInt(threshold, 10) / 100 * me.count;
      }
      surpassed = toAdd.length + toRemove.length + toMove.length + updated.length > threshold;
    }
    if (me.tree) {
      if (toAdd.length) {
        const added = me.add(toAdd, surpassed);
        added.forEach((node) => node.clearParentId());
      }
      if (toMove.length) {
        for (const {
          parent,
          node,
          index
        } of toMove) {
          const newParent = me.getById(parent.id);
          newParent.insertChild(node, index);
        }
      }
      me.remove(toRemove, surpassed);
    } else {
      if (surpassed) {
        me.suspendEvents();
      }
      me.remove(toRemove);
      me.add(toAdd);
      if (surpassed) {
        me.resumeEvents();
      }
    }
    if (threshold && !surpassed) {
      updated.forEach(({
        record,
        toSet,
        wasSet
      }) => me.onModelChange(record, toSet, wasSet));
    }
    me.acceptChanges();
    const event = {
      added: toAdd,
      removed: toRemove,
      updated,
      thresholdSurpassed: surpassed
    };
    if (me.isFiltered && !me.remoteFilter) {
      me.filter({
        silent: me.isRemoteDataLoading
      });
    }
    if (me.isGrouped) {
      me.group(null, null, false, true, me.isRemoteDataLoading);
    } else if (me.isSorted) {
      if (me.remoteSort) {
        storage.replaceValues({
          values: storage.values.sort(me.createSorterFn(me.sorters)),
          silent: true
        });
      } else {
        me.sort();
      }
    } else if (!me.tree) {
      if (storage.values.some((record, index) => record.id !== ids[index])) {
        storage.replaceValues({
          values: storage.values.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id)),
          silent: true
        });
        !surpassed && me.afterPerformSort();
      }
    } else {
      let unsorted = false, i = 0;
      WalkHelper.preWalk(me.rootNode, (n) => Array.isArray(n.children) && !unsorted ? n.children : null, (node) => {
        if (node.id !== ids[i++]) {
          unsorted = true;
        }
      });
      if (unsorted) {
        me.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id), void 0, void 0, true);
        me.clearSorters(true);
        !surpassed && me.afterPerformSort();
      }
    }
    if (surpassed) {
      me.trigger("refresh", {
        action: "batch",
        data,
        records: storage.values,
        syncInfo: event
      });
    }
    me.isSyncingDataOnLoad = false;
    me.trigger("loadSync", event);
  }
  syncFlatDataset(data) {
    if (!data) {
      return {
        toRemove: this.records
      };
    }
    const me = this, {
      idField,
      allFields
    } = me.modelClass, toRemove = [], toAdd = [], updated = [], usedIds = {}, ids = [];
    const {
      threshold,
      keepMissingValues
    } = me.syncDataOnLoad;
    let hitCount = 0;
    data.forEach((rawData) => {
      rawData = rawData.isModel ? rawData.data : rawData;
      const id = rawData[idField], record = me.getById(id);
      if (record) {
        if (keepMissingValues === false) {
          for (const field of allFields) {
            if (!(field.dataSource in rawData) && field.dataSource in record.data) {
              rawData[field.dataSource] = field.defaultValue;
            }
          }
        }
        const wasSet = record.set(rawData, null, Boolean(threshold));
        if (wasSet) {
          updated.push({
            record,
            wasSet,
            toSet: rawData
          });
        }
        hitCount++;
      } else {
        toAdd.push(me.processRecord(me.createRecord(rawData)));
      }
      usedIds[id] = 1;
      ids.push(id);
    });
    if (hitCount < me.allCount) {
      me.forEach((record) => {
        if (!usedIds[record.id]) {
          toRemove.push(record);
        }
      });
    }
    return {
      toAdd,
      toRemove,
      toMove: [],
      updated,
      ids
    };
  }
  syncTreeDataset(data) {
    if (!data) {
      return {
        toRemove: this.records
      };
    }
    const me = this, {
      idField,
      parentIdField,
      childrenField,
      allFields
    } = me.modelClass, {
      keepMissingValues
    } = me.syncDataOnLoad, toRemove = [], toAdd = [], toMove = [], updated = [], usedIds = {}, ids = [];
    if (me.transformFlatData) {
      data = me.treeifyFlatData(data);
    }
    const {
      threshold
    } = me.syncDataOnLoad;
    WalkHelper.preWalkWithParent({
      isRoot: true,
      id: me.rootNode.id,
      children: data
    }, (n) => n.children, (parent, rawData) => {
      if (parent) {
        const id = rawData[idField], node = me.getById(id);
        if (node) {
          let childrenUpdated;
          const oldChildrenValue = node.children;
          if (oldChildrenValue !== true && rawData[childrenField] === true) {
            node.clearChildren();
            node.data[childrenField] = node.children = true;
            delete rawData[childrenField];
            me.toggleCollapse(node, true);
            childrenUpdated = true;
          }
          if (node.parent.id !== parent[idField]) {
            toMove.push({
              node,
              parent,
              index: parent[childrenField].indexOf(rawData)
            });
          }
          if (keepMissingValues === false) {
            for (const field of allFields) {
              if (field.name !== "parentId" && !(field.dataSource in rawData) && field.dataSource in node.data) {
                rawData[field.dataSource] = field.defaultValue;
              }
            }
          }
          const wasSet = node.set(rawData, null, Boolean(threshold));
          if (wasSet) {
            updated.push({
              record: node,
              wasSet,
              toSet: rawData
            });
          } else if (childrenUpdated) {
            node.signalNodeChanged({
              [childrenField]: {
                value: true,
                oldValue: oldChildrenValue
              }
            });
          }
        } else {
          rawData[parentIdField] = parent[idField];
          toAdd.push(_objectSpread2(_objectSpread2({}, rawData), Array.isArray(rawData[childrenField]) ? {
            children: []
          } : void 0));
        }
        usedIds[id] = 1;
        ids.push(id);
      }
    });
    me.traverse((node) => {
      if (!usedIds[node.id]) {
        toRemove.push(node);
      }
    });
    return {
      toAdd,
      toRemove,
      toMove,
      updated,
      ids
    };
  }
};
var STM_PROP = Symbol("STM_PROP");
var StoreStm = (Target) => class StoreStm extends (Target || Base) {
  static get $name() {
    return "StoreStm";
  }
  static get defaultConfig() {
    return {
      stm: null,
      ignoreRemoteChangesInSTM: false
    };
  }
  get stm() {
    return this[STM_PROP];
  }
  set stm(stm) {
    const me = this;
    if (me.stm !== stm) {
      var _me$stm;
      if ((_me$stm = me.stm) !== null && _me$stm !== void 0 && _me$stm.hasStore(me)) {
        me.stm.removeStore(me);
      }
      me[STM_PROP] = stm;
      if (me.stm && !me.stm.hasStore(me)) {
        me.stm.addStore(me);
      }
    }
  }
  add(records, silent = false, options = {}) {
    let result;
    const {
      stm
    } = this;
    if (!this.tree && stm !== null && stm !== void 0 && stm.enabled) {
      var _result;
      result = super.add(records, silent);
      if ((_result = result) !== null && _result !== void 0 && _result.length) {
        stm.onStoreModelAdd(this, result, silent);
      }
    } else {
      result = super.add(records, silent, options);
    }
    return result;
  }
  insert(index, records, silent = false) {
    let result;
    const {
      stm
    } = this;
    if (!this.tree && stm !== null && stm !== void 0 && stm.enabled) {
      var _result2;
      const context = (Array.isArray(records) ? records : [records]).reduce((context2, r) => {
        const index2 = r instanceof Model ? this.indexOf(r) : void 0;
        if (index2 !== void 0 && index2 !== -1) {
          context2.set(r, index2);
        }
        return context2;
      }, /* @__PURE__ */ new Map());
      result = super.insert(index, records);
      if ((_result2 = result) !== null && _result2 !== void 0 && _result2.length) {
        index = this.indexOf(result[0]);
        stm.onStoreModelInsert(this, index, result, context, silent);
      }
    } else {
      result = super.insert(index, records, silent);
    }
    return result;
  }
  remove(recordsOrIds, silent = false, fromRemoveChild) {
    let result;
    const {
      stm
    } = this;
    if (!this.tree && stm !== null && stm !== void 0 && stm.enabled) {
      var _result3;
      const recordsOrIdsNormalized = (Array.isArray(recordsOrIds) ? recordsOrIds : [recordsOrIds]).map((r) => this.getById(r)).filter((r) => !!r);
      const context = recordsOrIdsNormalized.reduce((context2, r) => {
        const index = this.indexOf(r);
        if (index !== void 0 && index !== -1) {
          context2.set(r, index);
        }
        return context2;
      }, /* @__PURE__ */ new Map());
      result = super.remove(recordsOrIds, silent, fromRemoveChild);
      if ((_result3 = result) !== null && _result3 !== void 0 && _result3.length) {
        stm.onStoreModelRemove(this, result, context, silent);
      }
    } else {
      result = super.remove(recordsOrIds, silent, fromRemoveChild);
    }
    return result;
  }
  removeAll(silent) {
    const {
      stm
    } = this;
    let result;
    if (stm !== null && stm !== void 0 && stm.enabled) {
      const {
        tree,
        rootNode,
        allRecords
      } = this, wasNotEmpty = allRecords.length, records = tree ? rootNode.children.slice() : allRecords.slice();
      result = super.removeAll(silent);
      if (wasNotEmpty && this.count === 0) {
        stm.onStoreRemoveAll(this, records, silent);
      }
    } else {
      result = super.removeAll(silent);
    }
    return result;
  }
  beforeApplyChangeset() {
    const {
      stm,
      crudManager
    } = this;
    let shouldResume = false;
    if (!(crudManager !== null && crudManager !== void 0 && crudManager.applyingChangeset) && stm !== null && stm !== void 0 && stm.enabled) {
      shouldResume = true;
      if (stm.isRecording) {
        stm.stash();
      }
      if (this.ignoreRemoteChangesInSTM) {
        stm.disable();
      } else {
        stm.startTransaction();
      }
    }
    return shouldResume;
  }
  applyChangeset(changes, transformFn, phantomIdField, remote, logChanges) {
    const shouldResume = this.beforeApplyChangeset(), log = super.applyChangeset(changes, transformFn, phantomIdField, remote, logChanges);
    this.afterApplyChangeset(shouldResume);
    return log;
  }
  afterApplyChangeset(shouldResume) {
    if (shouldResume) {
      const {
        stm
      } = this;
      if (this.ignoreRemoteChangesInSTM) {
        stm.enable();
      } else {
        stm.stopTransaction();
      }
      stm.applyStash();
    }
  }
};
var dataAddRemoveActions = {
  splice: 1,
  clear: 1
};
var defaultTraverseOptions = {
  includeFilteredOutRecords: false,
  includeCollapsedGroupRecords: false
};
var fixTraverseOptions = (store, options) => {
  options = options || false;
  if (typeof options === "boolean") {
    options = {
      includeFilteredOutRecords: options,
      includeCollapsedGroupRecords: false
    };
  }
  return options || defaultTraverseOptions;
};
var Store = class extends Base.mixin(
  Delayable,
  Identifiable,
  Events,
  Pluggable,
  State,
  StoreFilter,
  StoreChanges,
  StoreCRUD,
  StoreRelation,
  StoreSum,
  StoreSearch,
  StoreSort,
  StoreGroup,
  StoreChained,
  StoreState,
  StoreTree,
  StoreStm,
  StoreSync,
  StoreProxy
) {
  static get $name() {
    return "Store";
  }
  static get properties() {
    return {
      relationCache: {},
      dependentStoreConfigs: /* @__PURE__ */ new Map()
    };
  }
  static get configurable() {
    return {
      id: true,
      modelClass: Model,
      verifyNoGeneratedIds: true
    };
  }
  static get defaultConfig() {
    return {
      fields: null,
      autoTree: true,
      data: null,
      tree: false,
      callOnFunctions: true,
      storage: null,
      useRawData: false,
      allowNoId: true,
      preventSubClassingModel: null
    };
  }
  static get identifiable() {
    return {
      registerGeneratedId: false
    };
  }
  constructor(...args) {
    super(...args);
    if (this.objectify) {
      return this.initProxy();
    }
  }
  construct(config = {}) {
    const me = this;
    Object.assign(me, {
      added: new StoreBag(),
      removed: new StoreBag(),
      modified: new StoreBag(),
      idRegister: {},
      internalIdRegister: {},
      oldIdMap: {}
    });
    if (config.storeId) {
      config = ObjectHelper.assign({
        id: config.storeId
      }, config);
    }
    super.construct(config);
    me.initRelations();
  }
  static from(config, defaults = {}, converterFn = null) {
    if (config && !config.isStore) {
      if (typeof config === "string") {
        config = Store.getStore(config);
      } else {
        if (Array.isArray(config)) {
          if (converterFn) {
            config = config.map((data) => data.isModel ? data : converterFn(data));
          }
          config = ObjectHelper.assign({}, defaults, {
            data: config
          });
        }
        config = new Store(config);
      }
    }
    return config;
  }
  doDestroy() {
    var _me$_storage, _me$stm, _me$stm$removeStore;
    const me = this, allRecords = me.registeredRecords;
    for (let i = allRecords.length - 1, rec; i >= 0; i--) {
      var _rec;
      rec = allRecords[i];
      if (!((_rec = rec) !== null && _rec !== void 0 && _rec.isDestroyed)) {
        rec.unjoinStore(me);
      }
    }
    (_me$_storage = me._storage) === null || _me$_storage === void 0 ? void 0 : _me$_storage.destroy();
    (_me$stm = me.stm) === null || _me$stm === void 0 ? void 0 : (_me$stm$removeStore = _me$stm.removeStore) === null || _me$stm$removeStore === void 0 ? void 0 : _me$stm$removeStore.call(_me$stm, me);
    if (!me.isChained) {
      var _me$rootNode;
      (_me$rootNode = me.rootNode) === null || _me$rootNode === void 0 ? void 0 : _me$rootNode.destroy();
    }
    super.doDestroy();
  }
  beginBatch() {
    this.suspendEvents();
  }
  endBatch() {
    if (this.resumeEvents()) {
      this.trigger("refresh", {
        action: "batch",
        data: this.storage.values,
        records: this.storage.values
      });
    }
  }
  set storage(storage) {
    const me = this;
    if (storage !== null && storage !== void 0 && storage.isCollection) {
      me._storage = storage;
    } else {
      me._storage = new Collection(storage);
    }
    me._storage.autoFilter = me.reapplyFilterOnAdd;
    me._storage.autoSort = me.reapplySortersOnAdd;
    for (const r of me._storage) {
      r.joinStore(me);
    }
    me._storage.ion({
      change: "onDataChange",
      thisObj: me
    });
  }
  get storage() {
    if (!this._storage) {
      this.storage = {};
    }
    return this._storage;
  }
  get allRecords() {
    const me = this;
    if (me.isTree) {
      const result = me.collectDescendants(me.rootNode, void 0, void 0, {
        unfiltered: true
      }).all;
      if (me.rootVisible) {
        result.unshift(me.rootNode);
      }
      return result;
    } else {
      return me.isGrouped ? me.collectGroupRecords() : me.storage.allValues;
    }
  }
  getAllDataRecords(searchAllRecords) {
    return this.isGrouped ? this.collectGroupRecords(searchAllRecords, false) : searchAllRecords ? this.storage.allValues : this.storage.values;
  }
  onIsCreatingToggle(record, isCreating) {
    const me = this, newlyPersistable = record.isPersistable && !isCreating;
    me.added[newlyPersistable ? "add" : "remove"](record);
    if (newlyPersistable) {
      me.trigger("addConfirmed", {
        record
      });
      if (me.autoCommit) {
        me.doAutoCommit();
      }
    }
  }
  joinRecordsToStore(records) {
    const {
      allCount
    } = this;
    for (let i = 0; i < records.length; i++) {
      const record = records[i];
      record.setData("parentIndex", allCount + i - records.length);
      record.joinStore(this);
    }
  }
  onDataChange({
    source: storage,
    action,
    added,
    removed,
    replaced,
    oldCount,
    items: items2,
    from,
    to
  }) {
    const me = this, isAddRemove = dataAddRemoveActions[action], addedCount = isAddRemove && (added === null || added === void 0 ? void 0 : added.length), removedCount = isAddRemove && (removed === null || removed === void 0 ? void 0 : removed.length);
    let filtersWereReapplied, sortersWereReapplied;
    me._idMap = null;
    if (addedCount) {
      me.joinRecordsToStore(added);
    }
    replaced === null || replaced === void 0 ? void 0 : replaced.forEach(([oldRecord, newRecord]) => {
      oldRecord.unjoinStore(me, true);
      newRecord.joinStore(me);
    });
    super.onDataChange(...arguments);
    if (!me.isTree) {
      if (addedCount) {
        for (const record of added) {
          if (me.removed.includes(record)) {
            me.removed.remove(record);
          } else if (!record.isLinked) {
            me.added.add(record);
          }
        }
        filtersWereReapplied = !me.remoteFilter && me.filtered && me.reapplyFilterOnAdd;
        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
        sortersWereReapplied = !me.remoteSort && me.isSorted && me.reapplySortersOnAdd;
        if (sortersWereReapplied) {
          me.sort(null, null, false, true);
        }
      }
      if (removedCount) {
        for (const record of removed) {
          record.cancelBatch();
          record.unjoinStore(me);
          if (me.added.includes(record)) {
            me.added.remove(record);
          } else if (!record._undoingInsertion && !record.isCreating && !record.isLinked) {
            me.removed.add(record);
          }
        }
        me.modified.remove(removed);
        filtersWereReapplied = !me.remoteFilter && me.filtered;
        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
      }
    }
    switch (action) {
      case "clear":
        me.relationCache = {};
        me.updateDependentStores("removeall");
        me.trigger("removeAll");
        me.trigger("change", {
          action: "removeall"
        });
        break;
      case "splice":
        if (addedCount) {
          me.updateDependentStores("add", added);
          const oldIndex = added.reduce((lowest, record) => {
            const {
              previousIndex
            } = record.meta;
            if (previousIndex > -1 && previousIndex < lowest)
              lowest = previousIndex;
            return lowest;
          }, added[0].meta.previousIndex), index = storage.indexOf(added[0], !storage.autoFilter), params = {
            records: added,
            index
          };
          if (oldIndex > -1) {
            params.oldIndex = oldIndex;
          }
          me.trigger("add", params);
          me.trigger("change", Object.assign({
            action: "add"
          }, params));
          if (filtersWereReapplied) {
            me.triggerFilterEvent({
              action: "filter",
              filters: me.filters,
              oldCount,
              records: me.storage.allValues
            });
          }
          if (sortersWereReapplied) {
            me.trigger("sort", {
              action: "sort",
              sorters: me.sorters,
              records: me.storage.allValues
            });
          }
        }
        if (removed.length) {
          me.updateDependentStores("remove", removed);
          me.trigger("remove", {
            records: removed
          });
          me.trigger("change", {
            action: "remove",
            records: removed
          });
        }
        if (replaced.length) {
          me.trigger("replace", {
            records: replaced,
            all: me.records.length === replaced.length
          });
          me.trigger("change", {
            action: "replace",
            replaced,
            all: me.records.length === replaced.length
          });
        }
        break;
      case "filter":
        if (me.isGrouped || me.isSorted) {
          me.performSort(true);
        }
        break;
      case "move": {
        const start = Math.min(from, to), end = Math.min(me.storage.allValues.length - 1, Math.max(from, to));
        for (let allRecords = me.storage.allValues, i = start; i <= end; i++) {
          allRecords[i].setData("parentIndex", i);
        }
        me.trigger("move", {
          record: items2[0],
          records: items2,
          from,
          to
        });
        if (me.isFiltered) {
          me.performFilter();
        }
        me.trigger("change", {
          action,
          record: items2[0],
          records: items2,
          from,
          to
        });
        break;
      }
    }
  }
  onDataReplaced(action, data) {
    var _me$afterLoadData;
    const me = this, {
      storage
    } = me, all = storage.allValues, sorted = Boolean(me.sorters.length > 0);
    for (let i = 0; i < all.length; i++) {
      all[i].joinStore(me);
    }
    const groupRecords = me.prepareGroupRecords();
    if (!me.remoteFilter && me.isFiltered) {
      me.filter({
        silent: true
      });
    }
    if (me.remoteSort) {
      if (me.isGrouped) {
        storage.replaceValues({
          values: groupRecords,
          silent: true
        });
      }
    } else {
      if (me.isGrouped) {
        me.group(null, null, false, !sorted, true);
      }
      if (sorted) {
        me.sort(null, null, false, true);
      }
    }
    if (!me.useRawData.disableDuplicateIdCheck) {
      const {
        idMap
      } = me;
      if (Object.keys(idMap).length < storage.values.length) {
        const collisions = [];
        storage.values.forEach((r) => idMap[r.id] ? delete idMap[r.id] : collisions.push(r));
        throw new Error(`Id collision on ${collisions.map((r) => r.id)}`);
      }
    }
    const event = {
      action,
      data,
      records: storage.values
    };
    me.updateDependentStores(action, event.records);
    (_me$afterLoadData = me.afterLoadData) === null || _me$afterLoadData === void 0 ? void 0 : _me$afterLoadData.call(me);
    if (!me.isRemoteDataLoading) {
      me.trigger("refresh", event);
    }
    me.trigger("change", event);
  }
  onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {
    const me = this, event = {
      record,
      records: [record],
      changes: wasSet,
      batch: record.batching != null,
      fromRelationUpdate
    }, committable = record.ignoreBag || record.isLinked ? false : me.updateModifiedBagForRecord(record);
    me.storage.onItemMutation(record, wasSet);
    if ("id" in wasSet) {
      const {
        oldValue,
        value
      } = toSet.id;
      me.updateDependentRecordIds(oldValue, value);
      me.onRecordIdChange({
        record,
        oldValue,
        value
      });
    }
    if (!silent) {
      if ("id" in wasSet) {
        const {
          oldValue,
          value
        } = toSet.id;
        me.trigger("idChange", {
          store: me,
          record,
          oldValue,
          value
        });
      }
      me.onUpdateRecord(record, wasSet);
      me.trigger("update", event);
      me.trigger("change", Object.assign({
        action: "update"
      }, event));
    }
    if (me.autoCommit && committable) {
      me.doAutoCommit();
    }
  }
  updateModifiedBagForRecord(record) {
    const me = this;
    let addedToBag = false;
    if (record.isModified) {
      if (!me.modified.includes(record) && !me.added.includes(record) && record.isPartOfStore(me) && !record.isAutoRoot) {
        if (record.isPhantom) {
          me.added.add(record);
        } else {
          me.modified.add(record);
        }
        addedToBag = true;
      }
    } else {
      me.modified.remove(record);
    }
    return addedToBag;
  }
  get idMap() {
    const me = this, needsRebuild = !me._idMap, idMap = me._idMap || (me._idMap = {});
    if (needsRebuild) {
      const processedRecords = me.storage.values;
      for (let record, index = 0, visibleIndex = 0; index < processedRecords.length; index++) {
        record = processedRecords[index];
        idMap[record.id] = {
          index,
          visibleIndex,
          record
        };
        if (!record.isSpecialRow) {
          visibleIndex++;
        }
      }
    }
    return idMap;
  }
  changeModelClass(ClassDef) {
    const {
      fields
    } = this;
    this.originalModelClass = ClassDef;
    let ClassDefEx = ClassDef;
    if (fields !== null && fields !== void 0 && fields.length) {
      ClassDefEx = class extends ClassDef {
        static get fields() {
          return fields;
        }
      };
    } else if (!this.preventSubClassingModel) {
      ClassDefEx = class extends ClassDef {
      };
    }
    ClassDefEx.initClass();
    return ClassDefEx;
  }
  set storeId(storeId) {
    this.id = storeId;
  }
  get storeId() {
    return this.id;
  }
  changeId(id, oldId) {
    return super.changeId(id !== true && id, oldId);
  }
  updateId(id, oldId) {
    const duplicate = Store.getById(id);
    duplicate && Store.unregisterInstance(duplicate);
    super.updateId(id, oldId);
  }
  generateAutoId() {
    return Store.generateId(`store-`);
  }
  get tree() {
    return this._tree;
  }
  set tree(tree) {
    this._tree = tree;
    if (tree && !this.rootNode) {
      this.rootNode = this.buildRootNode();
      this.rootNode.isAutoRoot = true;
    }
  }
  buildRootNode() {
    return {};
  }
  static getStore(id, storeClass) {
    if (id instanceof Store) {
      return id;
    }
    if (this.getById(id)) {
      return this.getById(id);
    }
    if (Array.isArray(id)) {
      let storeModel;
      const storeData = id.map((item) => {
        if (item instanceof Model) {
          storeModel = item.constructor;
        } else if (typeof item === "string") {
          item = {
            text: item
          };
        } else
          ;
        return item;
      });
      id = {
        autoCreated: true,
        data: storeData,
        modelClass: storeModel || class extends Model {
        },
        allowNoId: true
      };
      if (!storeClass) {
        storeClass = Store;
      }
    }
    if (storeClass) {
      return new storeClass(id);
    }
  }
  static get stores() {
    return Store.registeredInstances;
  }
  get rootNode() {
    return this.masterStore ? this.masterStore.rootNode : this._rootNode;
  }
  set rootNode(rootNode) {
    var _rootNode$children;
    const me = this, oldRoot = me._rootNode;
    if (rootNode === oldRoot) {
      return;
    }
    if (oldRoot) {
      me.clear(true);
    }
    if (rootNode instanceof Model) {
      rootNode.instanceMeta(me).collapsed = false;
      me._rootNode = rootNode;
    } else {
      me._rootNode = rootNode = new me.modelClass(Object.assign({
        expanded: true,
        [me.modelClass.idField]: `${me.id}-rootNode`
      }, rootNode), me, null, true);
    }
    me._tree = true;
    rootNode.isRoot = true;
    rootNode.joinStore(me);
    if ((_rootNode$children = rootNode.children) !== null && _rootNode$children !== void 0 && _rootNode$children.length || me.rootVisible) {
      rootNode.isLoading = true;
      me.onNodeAddChild(rootNode, rootNode.children || [], 0);
      rootNode.isLoading = false;
    }
    me.trigger("rootChange", {
      oldRoot,
      rootNode
    });
  }
  set data(data) {
    this.setStoreData(data);
  }
  setStoreData(data) {
    var _data, _data2;
    const me = this, {
      idField,
      childrenField
    } = me.modelClass;
    if (me.transformFlatData && ((_data = data) === null || _data === void 0 ? void 0 : _data.length) > 0 && !Object.isExtensible(data[0])) {
      me.useRawData = me.useRawData || {
        disableDuplicateIdCheck: false,
        disableDefaultValue: false,
        disableTypeConversion: false
      };
      data = ObjectHelper.clone(data);
    }
    me.getConfig("plugins");
    me.processConfiguredListeners();
    if (data && !Array.isArray(data)) {
      data = ObjectHelper.transformNamedObjectToArray(data, idField);
    }
    me.tree = !me.isChained && (me.tree || Boolean(me.autoTree && ((_data2 = data) === null || _data2 === void 0 ? void 0 : _data2.some((r) => r[childrenField]))));
    if (data && (me.remoteSort || me.remoteFilter)) {
      for (let i = 0; i < data.length; i++) {
        data[i]._remoteSortIndex = i;
      }
    }
    if (!me.syncDataOnLoad || !me._data) {
      me._data = data;
      if (me.tree) {
        if (me.transformFlatData) {
          data = me.treeifyFlatData(data);
        }
        const root2 = me.rootNode;
        root2.isLoading = true;
        me._data.forEach((record) => delete record.parentId);
        me.clear(true);
        root2.appendChild(data);
        me.updateDependentStores("dataset", [root2]);
        root2.isLoading = false;
        if (data.length === 0) {
          const event = {
            action: "dataset",
            data: [],
            records: []
          };
          me.trigger("refresh", event);
          me.trigger("change", event);
        } else if (me.isFiltered) {
          me.filter();
        }
      } else {
        me.loadData(data);
      }
      me.added.clear();
      me.removed.clear();
      me.modified.clear();
    } else {
      me.syncDataset(data);
    }
  }
  loadData(data, action = "dataset") {
    const me = this, {
      storage,
      allowNoId
    } = me, idField = me.modelClass.fieldMap.id.dataSource, creatingRecord = me.find((rec) => rec.isCreating);
    if (creatingRecord) {
      storage.values.splice(me.records.indexOf(creatingRecord), 1);
    }
    let warnGenerated = me.verifyNoGeneratedIds;
    me.removeHeadersAndFooters(me.storage.values);
    me._idMap = null;
    me.oldIdMap = {};
    if (data) {
      const isRaw = !(data[0] instanceof Model);
      if (isRaw) {
        me.modelClass.exposeProperties(data[0]);
        const count = data.length, records = new Array(count);
        for (let i = 0; i < count; i++) {
          var _recordData$idField, _recordData$idField$s, _recordData$idField2;
          const recordData = data[i];
          if (!allowNoId && recordData[idField] == null) {
            throw new Error(`Id required but not found on row ${i}`);
          }
          if (warnGenerated && (_recordData$idField = recordData[idField]) !== null && _recordData$idField !== void 0 && (_recordData$idField$s = (_recordData$idField2 = _recordData$idField).startsWith) !== null && _recordData$idField$s !== void 0 && _recordData$idField$s.call(_recordData$idField2, "_generated")) {
            console.warn(`Generated id found in data: ${recordData[idField]}. Generated ids are temporary and should be replaced with real ids by the backend`);
            warnGenerated = false;
          }
          records[i] = me.processRecord(me.createRecord(recordData, true), true);
          records[i].setData("parentIndex", i);
        }
        me.clear(true);
        storage.replaceValues({
          values: records,
          isNewDataset: true,
          silent: true
        });
      } else {
        me.clear(true);
        storage.replaceValues({
          values: data.slice(),
          isNewDataset: true,
          silent: true
        });
      }
      if (creatingRecord) {
        storage.values.push(creatingRecord);
      }
      me._data = data;
      me.onDataReplaced(action, data);
    } else {
      me.clear(true);
      me._data = null;
    }
    me.isSyncingDataOnLoad = false;
  }
  get data() {
    return this._data;
  }
  getRange(start, end, all = true) {
    return (all ? this.storage.allValues : this.storage.values).slice(start, end);
  }
  createRecord(data, skipExpose = false, rawData = false) {
    return new this.modelClass(data, this, null, skipExpose, false, rawData);
  }
  processRecord(record, isDataset = false) {
    return record;
  }
  refreshData() {
    this.filter();
    this.sort();
  }
  onRecordIdChange({
    record,
    oldValue,
    value
  }) {
    const me = this, idMap = me._idMap, {
      idRegister,
      oldIdMap
    } = me;
    me.storage._indicesInvalid = true;
    oldIdMap[oldValue] = record;
    if (idMap && !idMap[value]) {
      const entry = idMap[oldValue];
      delete idMap[oldValue];
      idMap[value] = entry;
    }
    me.added.changeId(oldValue, value);
    me.removed.changeId(oldValue, value);
    me.modified.changeId(oldValue, value);
    delete idRegister[oldValue];
    idRegister[value] = record;
    record.index = me.storage.indexOf(record);
  }
  onUpdateRecord(record, changes) {
    const me = this, {
      internalId
    } = changes, {
      internalIdRegister
    } = me;
    if (internalId) {
      this.storage._indicesInvalid = true;
      delete internalIdRegister[internalId.oldValue];
      internalIdRegister[internalId.value] = record;
    }
    if (me.reapplyFilterOnUpdate && me.isFiltered) {
      me.filter();
    }
  }
  get useRawData() {
    return this._useRawData;
  }
  set useRawData(options) {
    if (options === true) {
      this._useRawData = {
        enabled: true,
        disableDuplicateIdCheck: true,
        disableTypeConversion: true,
        disableDefaultValue: false
      };
    } else {
      this._useRawData = options ? Object.assign(options, {
        enabled: true
      }) : {
        enabled: false
      };
    }
  }
  getCount(countProcessed = true) {
    return countProcessed ? this.count : this.originalCount;
  }
  get originalCount() {
    var _this$groupRecords;
    return this.storage.totalCount - (((_this$groupRecords = this.groupRecords) === null || _this$groupRecords === void 0 ? void 0 : _this$groupRecords.length) || 0);
  }
  get count() {
    return this.storage.count;
  }
  get allCount() {
    return this.isTree ? this.rootNode.descendantCount : this.storage.totalCount;
  }
  get records() {
    return this.storage.values;
  }
  get first() {
    return this.storage.values[0];
  }
  get last() {
    return this.storage.values[this.storage.values.length - 1];
  }
  getAt(index, all = false) {
    return this.storage.getAt(index, all);
  }
  register(record) {
    const me = this;
    if (!me.useRawData.disableDuplicateIdCheck) {
      const existingRec = me.isTree && me.idRegister[record.id];
      if (existingRec && existingRec !== record) {
        throw new Error(`Id collision on ${record.id}`);
      }
    }
    me.idRegister[record.id] = record;
    me.internalIdRegister[record.internalId] = record;
  }
  unregister(record) {
    delete this.idRegister[record.id];
    delete this.internalIdRegister[record.internalId];
  }
  get registeredRecords() {
    return Object.values(this.idRegister);
  }
  getById(id) {
    if (id !== null && id !== void 0 && id.isModel) {
      const record = id;
      if (record.hasLinks && !this.storage.allValues.includes(record)) {
        return record.$links.find((r) => this.storage.allValues.includes(r));
      }
      return record;
    }
    return this.idRegister[id];
  }
  isAvailable(recordOrId) {
    const record = this.getById(recordOrId);
    return record && this.storage.includes(record) || false;
  }
  getByInternalId(internalId) {
    return this.internalIdRegister[internalId];
  }
  includes(recordOrId) {
    if (this.isTree) {
      return this.idRegister[Model.asId(recordOrId)] != null;
    }
    return this.indexOf(recordOrId) > -1;
  }
  indexOf(recordOrId, visibleRecords = false, allExceptFilteredOutRecords = false) {
    if (recordOrId !== null && recordOrId !== void 0 && recordOrId.isModel && !recordOrId.stores.includes(this.$store || this)) {
      const linkedRecord = recordOrId.$links.find((r) => this.storage.allValues.includes(r));
      if (linkedRecord) {
        return this.indexOf(linkedRecord, visibleRecords);
      }
      return -1;
    }
    if (this.isTree) {
      return (allExceptFilteredOutRecords ? this.rootNode.allChildren : this.storage.values).indexOf(this.getById(recordOrId));
    }
    const id = Model.asId(recordOrId);
    if (id == null) {
      return -1;
    }
    const found = this.idMap[id];
    return found ? found[visibleRecords ? "visibleIndex" : "index"] : -1;
  }
  allIndexOf(recordOrId) {
    if (this.isTree) {
      const record = this.getById(recordOrId);
      let result = -1;
      if (record) {
        record.bubble((n) => {
          if (n.parent) {
            result += n.parentIndex + 1;
          } else if (n === this.rootNode && this.rootVisible) {
            result += 1;
          }
        });
      }
      return result;
    } else {
      return this.storage.indexOf(recordOrId, true);
    }
  }
  getDistinctValues(field, searchAllRecords = false) {
    const me = this, values = [], keys = {};
    let value;
    me.forEach((r) => {
      if (!r.isSpecialRow && !r.isRoot) {
        value = r.get(field);
        const primitiveValue = value instanceof Date ? value.getTime() : value;
        if (!keys[primitiveValue]) {
          values.push(value);
          keys[primitiveValue] = 1;
        }
      }
    }, me, searchAllRecords);
    return values;
  }
  getValueCount(field, value) {
    let count = 0;
    this.forEach((r) => {
      if (ObjectHelper.isEqual(r.get(field), value))
        count++;
    });
    return count;
  }
  set json(json) {
    if (typeof json === "string") {
      json = StringHelper.safeJsonParse(json);
    }
    this.data = json;
  }
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  get formattedJSON() {
    return StringHelper.safeJsonStringify(this, null, 4);
  }
  toJSON() {
    return (this.isTree ? this.rootNode.unfilteredChildren || this.rootNode.children || [] : this.allRecords).map((record) => record.toJSON());
  }
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs(configs);
    delete configs.project;
  }
  getInlineData(options) {
    const data = [];
    if (this.tree) {
      var _this$rootNode$childr;
      (_this$rootNode$childr = this.rootNode.children) === null || _this$rootNode$childr === void 0 ? void 0 : _this$rootNode$childr.forEach((r) => data.push(r.getCurrentConfig(options)));
    } else {
      this.forEach((r) => data.push(r.getCurrentConfig(options)));
    }
    return data;
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options), {
      state
    } = this;
    if (result) {
      var _result$modelClass;
      if (result.data) {
        result.data = this.getInlineData(options);
      }
      delete result.project;
      delete result.stm;
      delete result.asyncEvents;
      if (((_result$modelClass = result.modelClass) === null || _result$modelClass === void 0 ? void 0 : _result$modelClass.$meta.hierarchy[result.modelClass.$meta.hierarchy.length - 2]) === this.constructor.defaultConfig.modelClass) {
        delete result.modelClass;
      }
      if (!this.tree) {
        delete result.tree;
      }
      if (state) {
        Object.assign(result, state);
      }
    }
    return result;
  }
  forEach(fn, thisObj = this, options) {
    const me = this, callback = (r, i) => {
      if (!r.isRoot && !r.isSpecialRow) {
        return fn.call(thisObj, r, i);
      }
    };
    options = fixTraverseOptions(me, options);
    if (me.isTree) {
      if (me.isChained) {
        options = _objectSpread2(_objectSpread2({}, options), {}, {
          sorterFn: me.sorterFn
        });
      }
      me.rootNode.traverseWhile(callback, false, options);
    } else {
      const records = options.includeFilteredOutRecords ? me.storage.allValues : me.storage.values;
      if (me.isGrouped && options.includeCollapsedGroupRecords) {
        for (let i = 0; i < records.length; i++) {
          const record = records[i];
          if (record.groupChildren && record.meta.collapsed === true) {
            for (let j = 0; j < record.groupChildren.length; j++) {
              const rec = record.groupChildren[j];
              if (callback(rec, j) === false) {
                return;
              }
            }
          } else if (callback(record, i) === false) {
            return;
          }
        }
      } else {
        for (let i = 0; i < records.length; i++) {
          if (callback(records[i], i) === false) {
            return;
          }
        }
      }
    }
  }
  map(fn, thisObj = this) {
    return this.storage.values.map(fn, thisObj);
  }
  every(fn, thisObj = this, ignoreFilters) {
    return this.storage[ignoreFilters ? "allValues" : "values"].every(fn, thisObj);
  }
  reduce(fn, initialValue = [], thisObj = this) {
    if (thisObj !== this) {
      fn = fn.bind(thisObj);
    }
    return this.storage.values.reduce(fn, initialValue, thisObj);
  }
  [Symbol.iterator]() {
    return this.storage.values[Symbol.iterator]();
  }
  traverse(fn, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {
    const me = this;
    options = fixTraverseOptions(me, options);
    if (me.isTree) {
      if (typeof topNode === "boolean") {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }
      if (me.isChained) {
        const passedFn = fn;
        fn = (node) => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }
      topNode.traverse(fn, skipTopNode, options);
    } else {
      me.forEach((rec) => rec.traverse(fn, false, options), me, options);
    }
  }
  traverseWhile(fn, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {
    const me = this;
    options = fixTraverseOptions(me, options);
    if (me.isTree) {
      if (typeof topNode === "boolean") {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }
      if (me.isChained) {
        const passedFn = fn;
        fn = (node) => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }
      topNode.traverseWhile(fn, skipTopNode, options);
    } else {
      for (const record of me.storage) {
        if (record.traverse(fn, false, options) === false) {
          break;
        }
      }
    }
  }
  getNext(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this, records = me.storage.values;
    let idx = me.indexOf(recordOrId);
    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }
    const record = records[idx + 1];
    if (skipSpecialRows && record && record.isSpecialRow) {
      return me.getNext(records[idx + 1], wrap, true);
    }
    return record;
  }
  getPrev(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this, records = me.storage.values;
    let idx = me.indexOf(recordOrId);
    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }
    const record = records[idx - 1];
    if (skipSpecialRows && record && record.isSpecialRow && idx > 0) {
      return me.getPrev(records[idx - 1], wrap, true);
    }
    return record;
  }
  getAdjacent(recordOrId, next = true, wrap = false, skipSpecialRows = false) {
    return next ? this.getNext(recordOrId, wrap, skipSpecialRows) : this.getPrev(recordOrId, wrap, skipSpecialRows);
  }
  getNextLeaf(recordOrId, wrap = false) {
    const me = this, records = me.leaves, record = me.getById(recordOrId);
    let idx = records.indexOf(record);
    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }
    return records[idx + 1];
  }
  getPrevLeaf(recordOrId, wrap = false) {
    const me = this, records = me.leaves, record = me.getById(recordOrId);
    let idx = records.indexOf(record);
    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }
    return records[idx - 1];
  }
  getAdjacentLeaf(recordOrId, next = true, wrap = false) {
    return next ? this.getNextLeaf(recordOrId, wrap) : this.getPrevLeaf(recordOrId, wrap);
  }
};
Store.initClass();
Store._$name = "Store";
var processParamEntry = (paramArray, entry) => {
  if (Array.isArray(entry[1])) {
    entry[1].forEach((value) => paramArray.push(encodeURIComponent(entry[0]) + "=" + encodeURIComponent(value)));
  } else {
    paramArray.push(encodeURIComponent(entry[0]) + "=" + encodeURIComponent(entry[1]));
  }
  return paramArray;
};
var immediatePromise$4 = Promise.resolve();
var prependZeros = (num) => {
  return String(num).padStart(2, "0");
};
var dateToString = (date) => {
  return `${date.getFullYear()}-${prependZeros(date.getMonth() + 1)}-${prependZeros(date.getDate())}T${prependZeros(date.getHours())}:${prependZeros(date.getMinutes())}:${prependZeros(date.getSeconds())}.${date.getMilliseconds()}`;
};
var AjaxStore = class extends Store {
  static get defaultConfig() {
    return {
      headers: null,
      fetchOptions: null,
      sendAsFormData: null,
      writeAllFields: null,
      parentIdParamName: "id",
      responseSuccessProperty: "success",
      responseDataProperty: "data",
      responseTotalProperty: "total",
      filterParamName: null,
      restfulFilter: false,
      sortParamName: null,
      pageParamName: null,
      pageStartParamName: null,
      pageSizeParamName: "pageSize",
      pageSize: 50,
      useRestfulMethods: null,
      httpMethods: {
        create: "POST",
        read: "GET",
        update: "PUT",
        delete: "DELETE"
      }
    };
  }
  static get configurable() {
    return {
      params: null
    };
  }
  afterConstruct(config) {
    super.afterConstruct(config);
    if (this.autoLoad) {
      this.load().catch(() => {
      });
    }
  }
  get isLoading() {
    return this._isLoading ? 2 : this.loadTriggerPromise ? 1 : false;
  }
  get isCommitting() {
    return Boolean(this.commitPromise);
  }
  set pageParamName(pageParamName) {
    if (this.tree) {
      throw new Error("Paging cannot be supported for tree stores");
    }
    if (this.pageStartParamName) {
      throw new Error("Configs pageStartParamName and pageParamName are mutually exclusive");
    }
    this._pageParamName = pageParamName;
  }
  get pageParamName() {
    return this._pageParamName;
  }
  set pageStartParamName(pageStartParamName) {
    if (this.tree) {
      throw new Error("Paging cannot be supported for tree stores");
    }
    if (this.pageParamName) {
      throw new Error("Configs pageParamName and pageStartParamName are mutually exclusive");
    }
    this._pageStartParamName = pageStartParamName;
  }
  get pageStartParamName() {
    return this._pageStartParamName;
  }
  get isPaged() {
    return this.pageParamName || this.pageStartParamName;
  }
  get allCount() {
    return "remoteTotal" in this ? this.remoteTotal : super.allCount;
  }
  get lastPage() {
    if (this.isPaged) {
      return Math.floor((this.allCount + this.pageSize - 1) / this.pageSize);
    }
  }
  buildQueryString(url, ...paramObjects) {
    const hasParamsInUrl = url.includes("?"), queryString = Object.entries(Object.assign({}, ...paramObjects)).reduce(processParamEntry, []).join("&");
    return queryString ? (hasParamsInUrl ? "&" : "?") + queryString : "";
  }
  async performSort(silent) {
    const me = this;
    if (me.remoteSort && !me.isRemoteDataLoading) {
      me.isRemoteDataLoading = true;
      const result = await me.internalLoad({}, "", (event) => {
        me.data = event.data;
        me.afterPerformSort(silent);
      });
      me.isRemoteDataLoading = false;
      return result;
    } else {
      super.performSort(silent);
    }
  }
  async performFilter(silent) {
    const me = this;
    if (me.remoteFilter) {
      var _me$loadingPromise;
      (_me$loadingPromise = me.loadingPromise) === null || _me$loadingPromise === void 0 ? void 0 : _me$loadingPromise.abort();
      me.isRemoteDataLoading = true;
      const oldCount = me.count, {
        filters
      } = me;
      me.currentPage = 1;
      const result = await me.internalLoad({}, "", (event) => {
        me.data = event.data;
        event = silent ? null : {
          action: "filter",
          filters,
          oldCount,
          records: me.storage.values
        };
        me.afterPerformFilter(event);
        me.trigger("refresh", event);
      });
      me.isRemoteDataLoading = false;
      return result;
    } else {
      super.performFilter(silent);
    }
  }
  encodeFilterParams(filters) {
    const result = [];
    for (const {
      property,
      operator,
      value,
      caseSensitive
    } of filters) {
      result.push({
        field: property,
        operator,
        value,
        caseSensitive
      });
    }
    return JSON.stringify(result, function(key, value) {
      return key === "" ? value : this[key] instanceof Date ? dateToString(this[key]) : value;
    });
  }
  encodeSorterParams(sorters) {
    return JSON.stringify(sorters.filter((sorter) => !sorter.sortFn).map((sorter) => sorter));
  }
  buildReadUrl() {
    const {
      readUrl
    } = this;
    if (this.restfulFilter && this.filters.count) {
      const url = readUrl.endsWith("/") ? readUrl : readUrl + "/";
      return url + this.filters.first.value;
    }
    return readUrl;
  }
  internalLoad(params, eventName, successFn, delay = 0) {
    params = ObjectHelper.assign({}, this.params, params);
    const me = this, url = me.buildReadUrl(), event = {
      action: "read" + eventName,
      params,
      url
    };
    if (!url) {
      throw new Error("No load url specified");
    }
    if (me.trigger("beforeLoad" + eventName, event) === false) {
      throw false;
    }
    me.loadArgs = [url, event, params, eventName, successFn];
    if (delay === false) {
      return new Promise((resolve, reject) => me.sendLoadRequest(resolve, reject));
    }
    return me.loadTriggerPromise || (me.loadTriggerPromise = new Promise((resolve, reject) => {
      me.setTimeout({
        delay,
        fn: "sendLoadRequest",
        args: [resolve, reject],
        cancelOutstanding: true
      });
    }));
  }
  async sendLoadRequest(resolve, reject) {
    const me = this, [url, event, params, eventName, successFn] = me.loadArgs;
    me.loadTriggerPromise = null;
    if (url) {
      me._isLoading = true;
      me.trigger(`load${eventName}Start`, event);
      me.trigger("beforeRequest", event);
      if (me.filterParamName && me.isFiltered) {
        params[me.filterParamName] = me.encodeFilterParams(me.filters.values);
      }
      if (me.remoteSort && me.isSorted) {
        params[me.sortParamName] = me.encodeSorterParams(me.groupers ? me.groupers.concat(me.sorters) : me.sorters);
      }
      if (me.isPaged) {
        if (!(me.pageParamName in params || me.pageStartParamName in params)) {
          const page = Math.min(me.currentPage || 1, me.allCount ? me.lastPage : Infinity);
          if (me.pageParamName) {
            params[me.pageParamName] = page;
          } else {
            params[me.pageStartParamName] = (page - 1) * me.pageSize;
          }
        }
        params[me.pageSizeParamName] = me.pageSize;
      }
      const options = {
        headers: me.headers,
        parseJson: true
      };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.read;
        if (event.body) {
          options.body = JSON.stringify(event.body);
        }
      }
      try {
        const promise = me.loadingPromise = AjaxHelper.get(event.url + me.buildQueryString(event.url, params), ObjectHelper.assign(options, me.fetchOptions)), response = await promise, data = response.parsedJson, isArray2 = Array.isArray(data), success2 = isArray2 || data && ObjectHelper.getPath(data, me.responseSuccessProperty) !== false, remoteTotal = isArray2 ? null : ObjectHelper.getPath(data, me.responseTotalProperty);
        if (me.isDestroyed) {
          return;
        }
        me.loadingPromise = null;
        me._isLoading = false;
        event.response = response;
        event.json = data;
        if (success2) {
          if (remoteTotal != null) {
            me.remoteTotal = parseInt(remoteTotal, 10);
          }
          if (me.isPaged) {
            if (me.remoteTotal >= 0) {
              const requestedPage = me.pageParamName ? params[me.pageParamName] : params[me.pageStartParamName] / me.pageSize + 1;
              me.currentPage = Math.min(requestedPage, me.lastPage);
            } else {
              throw new Error("A paged store must receive its responseTotalProperty in each data packet");
            }
          }
          event.data = isArray2 ? data : ObjectHelper.getPath(data, me.responseDataProperty);
          await successFn(event);
          !me.isDestroyed && me.trigger("load" + eventName, event);
          resolve(event);
        } else {
          Object.assign(event, {
            exception: true,
            exceptionType: "server",
            error: data === null || data === void 0 ? void 0 : data.error
          });
          !me.isDestroyed && me.trigger("exception", event);
          reject(event);
        }
        !me.isDestroyed && me.trigger("afterRequest", event);
      } catch (responseOrError) {
        me._isLoading = false;
        event.exception = true;
        if (responseOrError instanceof Response) {
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        !me.isDestroyed && me.trigger("exception", event);
        reject(event);
        !me.isDestroyed && me.trigger("afterRequest", event);
      }
    }
  }
  async load(params) {
    const me = this;
    if (me.isPaged) {
      return me.loadPage(me.currentPage || 1, params);
    } else {
      return me.internalLoad(params, "", (event) => {
        me.data = event.data;
      });
    }
  }
  async loadChildren(parentRecord) {
    return this.readUrl ? this.internalLoad({
      [this.parentIdParamName]: parentRecord.id
    }, "Children", (event) => {
      event.parentRecord = parentRecord;
      if (parentRecord.children.length) {
        parentRecord.clearChildren(true);
      }
      parentRecord.data[parentRecord.constructor.childrenField] = event.data;
      parentRecord.processChildren(parentRecord.stores);
    }, false) : this.immediatePromise;
  }
  async loadPage(page, params) {
    if (this.allCount) {
      page = Math.min(page, this.lastPage);
    }
    const me = this, pageParam = me.pageParamName ? {
      [me.pageParamName]: page
    } : {
      [me.pageStartParamName]: (page - 1) * me.pageSize
    };
    pageParam[me.pageSizeParamName] = me.pageSize;
    return me.internalLoad(ObjectHelper.assign(pageParam, params), "Page", (event) => {
      me.loadData(event.data, "pageLoad");
    });
  }
  async nextPage(params) {
    const me = this;
    return me.isPaged && me.currentPage !== me.lastPage ? me.loadPage(me.currentPage + 1, params) : immediatePromise$4;
  }
  async previousPage(params) {
    return this.isPaged && this.currentPage !== 1 ? this.loadPage(this.currentPage - 1, params) : immediatePromise$4;
  }
  async commit() {
    const me = this, {
      changes
    } = me, allPromises = [];
    if (me.commitPromise) {
      return false;
    }
    if (!changes) {
      if (me.modified.count) {
        me.modified.forEach((record) => record.clearChanges(true, false));
        me.modified.clear();
      }
      return immediatePromise$4;
    }
    if (me.trigger("beforeCommit", {
      changes
    }) !== false) {
      [...changes.added, ...changes.modified, ...changes.removed].forEach((record) => record.meta.committing = true);
      me.trigger("commitStart", {
        changes
      });
      const commitState = {
        action: "commit",
        exception: false,
        changes
      };
      let p = me.commitRemoved(commitState);
      if (p) {
        allPromises.push(p);
      }
      p = me.commitAdded(commitState);
      if (p) {
        allPromises.push(p);
      }
      p = me.commitModified(commitState);
      if (p) {
        allPromises.push(p);
      }
      if (!allPromises.length) {
        me.modified.forEach((r) => r.clearChanges(true, false));
        me.modified.clear();
        me.added.forEach((r) => r.clearChanges(true, false));
        me.added.clear();
        me.removed.clear();
        me.trigger("commit", {
          changes
        });
        return immediatePromise$4;
      }
      p = allPromises.length === 1 ? allPromises[0] : Promise.all(allPromises);
      return me.commitPromise = new Promise((resolve, reject) => {
        p.then(() => {
          me.commitPromise = null;
          if (commitState.exception) {
            me.trigger("exception", commitState);
            reject(commitState);
          } else {
            me.trigger("commit", {
              changes
            });
            resolve(commitState);
          }
        }).catch(() => {
          me.commitPromise = null;
          reject(commitState);
        });
      });
    }
  }
  doAutoCommit() {
    if (this.suspendCount <= 0) {
      this.commit().catch((commitState) => {
        const {
          response
        } = commitState;
        if (!(response && (response.ok && response.parsedJson || [500, 404].includes(response.status)))) {
          throw commitState;
        }
      });
    }
  }
  commitAdded(commitState) {
    const me = this, added = me.added, event = {
      action: "create",
      params: me.params
    };
    return added.count && me.createUrl ? new Promise((resolve) => {
      const toAdd = added.values.map((r) => r.persistableData);
      commitState.create = event;
      event.body = {
        data: toAdd
      };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("data", JSON.stringify(toAdd));
        dataToSend = formData;
      }
      const options = {
        headers: me.headers,
        parseJson: true
      }, url = me.createUrl + me.buildQueryString(me.createUrl, me.params);
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.create;
      }
      AjaxHelper.post(url, dataToSend, ObjectHelper.assign(options, me.fetchOptions)).then((response) => {
        const data = response.parsedJson, isArray2 = Array.isArray(data), success2 = isArray2 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success2) {
          me.processReturnedData(added.values, isArray2 ? data : ObjectHelper.getPath(data, me.responseDataProperty));
          added.clear();
          me.trigger("commitAdded");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          added.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          commitState.exceptionType = event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        added.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        me.trigger("exception", event);
        resolve(commitState);
        me.trigger("afterRequest", event);
      });
    }) : null;
  }
  commitModified(commitState) {
    const me = this, {
      modified
    } = me.changes, event = {
      action: "update",
      params: me.params
    }, result = modified.length && me.updateUrl ? new Promise((resolve) => {
      const modifications = modified.map((record) => {
        if (me.writeAllFields) {
          return record.persistableData;
        } else {
          return record.modificationDataToWrite;
        }
      }).filter((el) => !ObjectHelper.isEmpty(el));
      if (modifications.length === 0) {
        me.modified.clear();
        modified.forEach((r) => r.meta.committing = false);
        resolve();
        return;
      }
      commitState.update = event;
      event.body = {
        data: modifications
      };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("data", JSON.stringify(modifications));
        dataToSend = formData;
      }
      const options = {
        headers: me.headers,
        parseJson: true
      };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.update;
      }
      AjaxHelper.post(me.updateUrl + me.buildQueryString(me.updateUrl, me.params), dataToSend, ObjectHelper.assign(options, me.fetchOptions)).then((response) => {
        const data = response.parsedJson, isArray2 = Array.isArray(data), success2 = isArray2 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success2) {
          me.processReturnedData(modified, isArray2 ? data : ObjectHelper.getPath(data, me.responseDataProperty), true);
          me.modified.clear();
          me.trigger("commitModified");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          modified.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        modified.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        me.trigger("exception", event);
        resolve(commitState);
        me.trigger("afterRequest", event);
      });
    }) : null;
    if (!modified.length && me.modified.count) {
      me.modified.clear();
    }
    return result;
  }
  processReturnedData(localRecords, returnedData, isUpdating = false) {
    const me = this, Model2 = me.modelClass, idDataSource = Model2.fieldMap.id.dataSource;
    returnedData.forEach((recData, i) => {
      const record = localRecords[i];
      record.clearChanges(true, false);
      record.syncId(recData[idDataSource]);
      Object.assign(localRecords[i].data, Model2.processData(recData, isUpdating, me, record));
    });
  }
  commitRemoved(commitState) {
    const me = this, removed = me.removed, event = {
      action: "delete",
      params: me.params
    };
    return removed.count && me.deleteUrl ? new Promise((resolve) => {
      commitState.delete = event;
      event.body = {
        ids: removed.map((r) => r.id)
      };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("id", JSON.stringify(dataToSend.ids));
        dataToSend = formData;
      }
      const options = {
        headers: me.headers,
        parseJson: true
      };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.delete;
      }
      AjaxHelper.post(me.deleteUrl + me.buildQueryString(me.deleteUrl, me.params), dataToSend, ObjectHelper.assign(options, me.fetchOptions)).then((response) => {
        const data = response.parsedJson, isArray2 = Array.isArray(data), success2 = isArray2 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success2) {
          removed.forEach((record) => record.meta.committing = false);
          removed.clear();
          me.trigger("commitRemoved");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          removed.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        removed.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        me.trigger("exception", event);
        resolve(commitState);
        me.trigger("afterRequest", event);
      });
    }) : null;
  }
  get remoteFilter() {
    return Boolean(this.filterParamName || this.restfulFilter);
  }
  get remoteSort() {
    return Boolean(this.sortParamName);
  }
};
_defineProperty(AjaxStore, "$name", "AjaxStore");
AjaxStore._$name = "AjaxStore";
var DomDataStore = class {
  static get(element, key) {
    const result = element._domData || (element._domData = {});
    return key != null ? result[key] : result;
  }
  static remove(element, key) {
    const {
      _domData
    } = element, was = _domData === null || _domData === void 0 ? void 0 : _domData[key];
    _domData === null || _domData === void 0 ? true : delete _domData[key];
    return was;
  }
  static set(element, data, value) {
    if (arguments.length === 3) {
      (element._domData || (element._domData = {}))[data] = value;
    } else {
      element._domData = data;
    }
  }
  static assign(element, data) {
    Object.assign(element._domData || (element._domData = {}), data);
  }
};
DomDataStore._$name = "DomDataStore";
var throwAbstractMethodCall$1 = () => {
  throw new Error("Abstract method call!");
};
var ActionBase = class extends Base {
  get type() {
    return this.constructor.name;
  }
  undo() {
    throwAbstractMethodCall$1();
  }
  redo() {
    throwAbstractMethodCall$1();
  }
};
ActionBase._$name = "ActionBase";
var throwAbstractMethodCall = () => {
  throw new Error("Abstract method call!");
};
var throwInvalidMethodCall = () => {
  throw new Error("Method cannot be called at this state!");
};
var StateBase = class extends Base {
  canUndo(stm) {
    throwAbstractMethodCall();
  }
  canRedo(stm) {
    throwAbstractMethodCall();
  }
  onUndo(stm) {
    throwAbstractMethodCall();
  }
  onRedo(stm) {
    throwAbstractMethodCall();
  }
  onStartTransaction(stm) {
    throwAbstractMethodCall();
  }
  onStopTransaction(stm) {
    throwAbstractMethodCall();
  }
  onStopTransactionDelayed(stm) {
    throwAbstractMethodCall();
  }
  onRejectTransaction(stm) {
    throwAbstractMethodCall();
  }
  onEnable(stm) {
    throwAbstractMethodCall();
  }
  onDisable(stm) {
    throwAbstractMethodCall();
  }
  onAutoRecordOn(stm) {
    throwAbstractMethodCall();
  }
  onAutoRecordOff(stm) {
    throwAbstractMethodCall();
  }
  onResetQueue(stm) {
    throwAbstractMethodCall();
  }
  onModelUpdate(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelAdd(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelInsert(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelRemove(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelRemoveAll(stm) {
    throwAbstractMethodCall();
  }
  onModelInsertChild(stm) {
    throwAbstractMethodCall();
  }
  onModelRemoveChild(stm) {
    throwAbstractMethodCall();
  }
};
StateBase._$name = "StateBase";
var STATE_PROP = Symbol("STATE_PROP");
var STORES_PROP = Symbol("STORES_PROP");
var QUEUE_PROP = Symbol("QUEUE_PROP");
var POS_PROP = Symbol("POS_PROP");
var TRANSACTION_PROP = Symbol("TRANSACTION_PROP");
var TRANSACTION_TIMER_PROP = Symbol("TRANSACTION_TIMER_PROP");
var AUTO_RECORD_PROP = Symbol("AUTO_RECORD_PROP");
Object.freeze([STATE_PROP, STORES_PROP, QUEUE_PROP, POS_PROP, TRANSACTION_PROP, TRANSACTION_TIMER_PROP, AUTO_RECORD_PROP]);
var registry = /* @__PURE__ */ new Map();
var registerStmState = (name, state) => {
  registry.set(name, state);
};
var resolveStmState = (state) => {
  if (typeof state === "string") {
    state = registry.get(state);
  }
  return state;
};
var Registry = {
  registerStmState,
  resolveStmState
};
var resetQueue = (stm, options) => {
  const {
    undo,
    redo
  } = options;
  let newProps;
  if (undo && !redo) {
    newProps = {
      [QUEUE_PROP]: stm[QUEUE_PROP].slice(stm.position),
      [POS_PROP]: 0
    };
  } else if (redo && !undo) {
    newProps = {
      [QUEUE_PROP]: stm[QUEUE_PROP].slice(0, stm.position)
    };
  } else {
    newProps = {
      [QUEUE_PROP]: [],
      [POS_PROP]: 0
    };
  }
  return [newProps, () => {
    stm.notifyStoresAboutQueueReset(options);
  }];
};
var DisabledStateClass = class extends StateBase {
  canUndo() {
    return false;
  }
  canRedo() {
    return false;
  }
  onUndo() {
    throwInvalidMethodCall();
  }
  onRedo() {
    throwInvalidMethodCall();
  }
  onEnable(stm) {
    return stm.autoRecord ? "autoreadystate" : "readystate";
  }
  onDisable() {
    throwInvalidMethodCall();
  }
  onAutoRecordOn() {
    return {
      [AUTO_RECORD_PROP]: true
    };
  }
  onAutoRecordOff() {
    return {
      [AUTO_RECORD_PROP]: false
    };
  }
  onStartTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onRejectTransaction() {
    throwInvalidMethodCall();
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onModelUpdate() {
  }
  onModelInsertChild() {
  }
  onModelRemoveChild() {
  }
  onStoreModelAdd() {
  }
  onStoreModelInsert() {
  }
  onStoreModelRemove() {
  }
  onStoreRemoveAll() {
  }
};
var DisabledState = new DisabledStateClass();
Registry.registerStmState("disabledstate", DisabledState);
var ACTION_QUEUE_PROP = Symbol("ACTION_QUEUE_PROP");
var Transaction = class extends Base {
  get defaultConfig() {
    return {
      title: null
    };
  }
  construct(...args) {
    this[ACTION_QUEUE_PROP] = [];
    super.construct(...args);
  }
  get queue() {
    return this[ACTION_QUEUE_PROP].slice(0);
  }
  get length() {
    return this[ACTION_QUEUE_PROP].length;
  }
  addAction(action) {
    this[ACTION_QUEUE_PROP].push(action);
  }
  undo() {
    const queue = this[ACTION_QUEUE_PROP];
    for (let i = queue.length - 1; i >= 0; --i) {
      queue[i].undo();
    }
  }
  redo() {
    const queue = this[ACTION_QUEUE_PROP];
    for (let i = 0, len = queue.length; i < len; ++i) {
      queue[i].redo();
    }
  }
};
Transaction._$name = "Transaction";
var ReadyStateClass = class extends StateBase {
  canUndo(stm) {
    return 0 < stm.position && stm.position <= stm.length;
  }
  canRedo(stm) {
    return 0 <= stm.position && stm.position < stm.length;
  }
  onUndo(stm, steps) {
    let curPos = stm.position;
    const queue = stm[QUEUE_PROP], newPos = Math.max(0, curPos - steps), next = () => {
      stm.notifyStoresAboutStateRestoringStart();
      const undoneTransactions = [];
      while (curPos !== newPos) {
        const transaction = queue[--curPos];
        transaction.undo();
        undoneTransactions.push(transaction);
      }
      return [stm.autoRecord ? "autoreadystate" : "readystate", () => {
        stm.notifyStoresAboutStateRestoringStop({
          cause: "undo",
          transactions: undoneTransactions
        });
      }];
    };
    return [{
      [STATE_PROP]: "restoringstate",
      [POS_PROP]: newPos
    }, next];
  }
  onRedo(stm, steps) {
    let curPos = stm.position;
    const queue = stm[QUEUE_PROP], newPos = Math.min(queue.length, curPos + steps);
    const next = () => {
      stm.notifyStoresAboutStateRestoringStart();
      const redoneTransactions = [];
      do {
        const transaction = queue[curPos++];
        transaction.redo();
        redoneTransactions.push(transaction);
      } while (curPos !== newPos);
      return [stm.autoRecord ? "autoreadystate" : "readystate", () => {
        stm.notifyStoresAboutStateRestoringStop({
          cause: "redo",
          transactions: redoneTransactions
        });
      }];
    };
    return [{
      [STATE_PROP]: "restoringstate",
      [POS_PROP]: newPos
    }, next];
  }
  onEnable() {
    throwInvalidMethodCall();
  }
  onDisable() {
    return "disabledstate";
  }
  onAutoRecordOn() {
    return {
      [STATE_PROP]: "autoreadystate",
      [AUTO_RECORD_PROP]: true
    };
  }
  onAutoRecordOff() {
    throwInvalidMethodCall();
  }
  onStartTransaction(stm, title) {
    const transaction = new Transaction({
      title
    });
    return [{
      [STATE_PROP]: "recordingstate",
      [TRANSACTION_PROP]: transaction
    }, () => {
      stm.notifyStoresAboutStateRecordingStart(transaction);
    }];
  }
  onStopTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onRejectTransaction() {
    throwInvalidMethodCall();
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onModelUpdate() {
  }
  onModelInsertChild() {
  }
  onModelRemoveChild() {
  }
  onStoreModelAdd() {
  }
  onStoreModelInsert() {
  }
  onStoreModelRemove() {
  }
  onStoreRemoveAll() {
  }
};
var ReadyState = new ReadyStateClass();
Registry.registerStmState("readystate", ReadyState);
var RecordingStateClass = class extends StateBase {
  canUndo() {
    return false;
  }
  canRedo() {
    return false;
  }
  onEnable() {
  }
  onDisable(stm) {
    const transaction = stm[TRANSACTION_PROP];
    stm.notifyStoresAboutStateRecordingStop(transaction, {
      disabled: true
    });
    return {
      [STATE_PROP]: "disabledstate",
      [TRANSACTION_PROP]: null
    };
  }
  onAutoRecordOn(stm) {
    return [{
      [STATE_PROP]: "autorecordingstate",
      [AUTO_RECORD_PROP]: true
    }, () => {
      stm.stopTransactionDelayed();
    }];
  }
  onAutoRecordOff() {
    throwInvalidMethodCall();
  }
  onStartTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransaction(stm, title) {
    const transaction = stm[TRANSACTION_PROP], queue = stm[QUEUE_PROP];
    let position = stm[POS_PROP];
    if (transaction.length) {
      if (!transaction.title && !title && stm.getTransactionTitle) {
        transaction.title = stm.getTransactionTitle(transaction);
      } else if (title) {
        transaction.title = title;
      }
      queue[position] = transaction;
      queue.length = ++position;
    }
    return [{
      [STATE_PROP]: "readystate",
      [POS_PROP]: position,
      [TRANSACTION_PROP]: null
    }, () => {
      stm.notifyStoresAboutStateRecordingStop(transaction, {
        stop: true
      });
    }];
  }
  onRejectTransaction(stm) {
    const transaction = stm[TRANSACTION_PROP];
    return [{
      [STATE_PROP]: "restoringstate",
      [TRANSACTION_PROP]: null
    }, () => {
      if (transaction.length) {
        transaction.undo();
      }
      return ["readystate", () => {
        stm.notifyStoresAboutStateRecordingStop(transaction, {
          rejected: true
        });
      }];
    }];
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onModelUpdate(stm, model, newData, oldData, isInitialUserAction) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelUpdateAction(model, newData, oldData, isInitialUserAction));
  }
  onModelInsertChild(stm, parentModel, index, childModel, previousParent, previousIndex) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelInsertChildAction(parentModel, index, childModel, previousParent, previousIndex));
  }
  onModelRemoveChild(stm, parentModel, childModels, context) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelRemoveChildAction(parentModel, childModels, context));
  }
  onStoreModelAdd(stm, store, models, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelAddAction(store, models, silent));
  }
  onStoreModelInsert(stm, store, index, models, context, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelInsertAction(store, index, models, context, silent));
  }
  onStoreModelRemove(stm, store, models, context, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelRemoveAction(store, models, context, silent));
  }
  onStoreRemoveAll(stm, store, allRecords, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreRemoveAllAction(store, allRecords, silent));
  }
};
var RecordingState = new RecordingStateClass();
Registry.registerStmState("recordingstate", RecordingState);
var RestoringStateClass = class extends StateBase {
  static get $name() {
    return "RestoringStateClass";
  }
  canUndo() {
    return false;
  }
  canRedo() {
    return false;
  }
  onUndo() {
    throwInvalidMethodCall();
  }
  onRedo() {
    throwInvalidMethodCall();
  }
  onEnable() {
    throwInvalidMethodCall();
  }
  onDisable() {
    throwInvalidMethodCall();
  }
  onAutoRecordOn() {
    return {
      [AUTO_RECORD_PROP]: true
    };
  }
  onAutoRecordOff() {
    return {
      [AUTO_RECORD_PROP]: false
    };
  }
  onStartTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onRejectTransaction() {
    throwInvalidMethodCall();
  }
  onQueueReset() {
    throwInvalidMethodCall();
  }
  onModelUpdate() {
  }
  onModelInsertChild() {
  }
  onModelRemoveChild() {
  }
  onStoreModelAdd() {
  }
  onStoreModelInsert() {
  }
  onStoreModelRemove() {
  }
  onStoreRemoveAll() {
  }
};
var RestoringState = new RestoringStateClass();
Registry.registerStmState("restoringstate", RestoringState);
var AutoReadyStateClass = class extends ReadyStateClass {
  onAutoRecordOn() {
    throwInvalidMethodCall();
  }
  onAutoRecordOff() {
    return {
      [STATE_PROP]: "readystate",
      [AUTO_RECORD_PROP]: false
    };
  }
  onStartTransaction(stm, title) {
    const transaction = new Transaction({
      title
    });
    return [{
      [STATE_PROP]: "autorecordingstate",
      [TRANSACTION_PROP]: transaction
    }, () => {
      stm.notifyStoresAboutStateRecordingStart(transaction);
      stm.stopTransactionDelayed();
    }];
  }
  onModelUpdate(stm, model, newData, oldData) {
    stm.startTransaction();
    stm.onModelUpdate(model, newData, oldData);
  }
  onModelInsertChild(stm, parentModel, index, childModels, context) {
    stm.startTransaction();
    stm.onModelInsertChild(parentModel, index, childModels, context);
  }
  onModelRemoveChild(stm, parentModel, childModels, context) {
    stm.startTransaction();
    stm.onModelRemoveChild(parentModel, childModels, context);
  }
  onStoreModelAdd(stm, store, models, silent) {
    stm.startTransaction();
    stm.onStoreModelAdd(store, models, silent);
  }
  onStoreModelInsert(stm, store, index, models, context, silent) {
    stm.startTransaction();
    stm.onStoreModelInsert(store, index, models, context, silent);
  }
  onStoreModelRemove(stm, store, models, context, silent) {
    stm.startTransaction();
    stm.onStoreModelRemove(store, models, context, silent);
  }
  onStoreRemoveAll(stm, store, allRecords, silent) {
    stm.startTransaction();
    stm.onStoreRemoveAll(store, allRecords, silent);
  }
};
var AutoReadyState = new AutoReadyStateClass();
Registry.registerStmState("autoreadystate", AutoReadyState);
var AutoRecordingStateClass = class extends RecordingStateClass.mixin(Delayable) {
  onDisable(stm) {
    const transaction = stm[TRANSACTION_PROP], timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    stm.notifyStoresAboutStateRecordingStop(transaction, {
      disabled: true
    });
    return {
      [STATE_PROP]: "disabledstate",
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    };
  }
  onAutoRecordOn(stm) {
    throwInvalidMethodCall();
  }
  onAutoRecordOff(stm) {
    const timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    return {
      [STATE_PROP]: "recordingstate",
      [AUTO_RECORD_PROP]: false,
      [TRANSACTION_TIMER_PROP]: null
    };
  }
  onStopTransaction(stm, title) {
    const transaction = stm[TRANSACTION_PROP], timer = stm[TRANSACTION_TIMER_PROP], queue = stm[QUEUE_PROP];
    let position = stm[POS_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    if (transaction.length) {
      if (!transaction.title && !title && stm.getTransactionTitle) {
        transaction.title = stm.getTransactionTitle(transaction);
      } else if (title) {
        transaction.title = title;
      }
      queue[position] = transaction;
      queue.length = ++position;
    }
    return [{
      [STATE_PROP]: "autoreadystate",
      [POS_PROP]: position,
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    }, () => {
      stm.notifyStoresAboutStateRecordingStop(transaction, {
        stop: true
      });
    }];
  }
  onStopTransactionDelayed(stm) {
    let timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    timer = this.setTimeout(() => {
      stm.stopTransaction();
    }, stm.autoRecordTransactionStopTimeout);
    return {
      [STATE_PROP]: AutoRecordingState,
      [TRANSACTION_TIMER_PROP]: timer
    };
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onRejectTransaction(stm) {
    const transaction = stm[TRANSACTION_PROP], timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    return [{
      [STATE_PROP]: "restoringstate",
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    }, () => {
      if (transaction.length) {
        transaction.undo();
      }
      return ["autoreadystate", () => {
        stm.notifyStoresAboutStateRecordingStop(transaction, {
          rejected: true
        });
      }];
    }];
  }
  onModelUpdate(stm, ...rest) {
    super.onModelUpdate(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onModelInsertChild(stm, ...rest) {
    super.onModelInsertChild(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onModelRemoveChild(stm, ...rest) {
    super.onModelRemoveChild(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreModelAdd(stm, ...rest) {
    super.onStoreModelAdd(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreModelInsert(stm, ...rest) {
    super.onStoreModelInsert(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreModelRemove(stm, ...rest) {
    super.onStoreModelRemove(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreRemoveAll(stm, ...rest) {
    super.onStoreRemoveAll(stm, ...rest);
    stm.stopTransactionDelayed();
  }
};
var AutoRecordingState = new AutoRecordingStateClass();
Registry.registerStmState("autorecordingstate", AutoRecordingState);
var MODEL_PROP = Symbol("MODEL_PROP");
var NEW_DATA_PROP = Symbol("NEW_DATA_PROP");
var OLD_DATA_PROP = Symbol("OLD_DATA_PROP");
var UpdateAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      model: void 0,
      newData: void 0,
      oldData: void 0,
      isInitialUserAction: false
    };
  }
  get type() {
    return "UpdateAction";
  }
  get model() {
    return this[MODEL_PROP];
  }
  set model(value) {
    this[MODEL_PROP] = value;
  }
  get newData() {
    return this[NEW_DATA_PROP];
  }
  set newData(value) {
    this[NEW_DATA_PROP] = _objectSpread2({}, value);
  }
  get oldData() {
    return this[OLD_DATA_PROP];
  }
  set oldData(value) {
    this[OLD_DATA_PROP] = _objectSpread2({}, value);
  }
  undo() {
    const {
      model,
      oldData
    } = this;
    if (model.$) {
      Object.assign(model, oldData);
    }
    model.set(oldData, null, null, null, true);
  }
  redo() {
    const {
      model,
      newData
    } = this;
    if (model.$) {
      Object.assign(model, newData);
    }
    model.set(newData, null, null, null, true);
  }
};
UpdateAction._$name = "UpdateAction";
var PARENT_MODEL_PROP$1 = Symbol("PARENT_MODEL_PROP");
var CHILD_MODELS_PROP$1 = Symbol("CHILD_MODELS_PROP");
var INSERT_INDEX_PROP$1 = Symbol("INSERT_INDEX_PROP");
var CONTEXT_PROP$3 = Symbol("CONTEXT_PROP");
var InsertChildAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      parentModel: void 0,
      childModels: void 0,
      insertIndex: void 0,
      context: void 0
    };
  }
  get type() {
    return "InsertChildAction";
  }
  get parentModel() {
    return this[PARENT_MODEL_PROP$1];
  }
  set parentModel(model) {
    this[PARENT_MODEL_PROP$1] = model;
  }
  get childModels() {
    return this[CHILD_MODELS_PROP$1];
  }
  set childModels(models) {
    this[CHILD_MODELS_PROP$1] = models.slice(0);
  }
  get insertIndex() {
    return this[INSERT_INDEX_PROP$1];
  }
  set insertIndex(index) {
    this[INSERT_INDEX_PROP$1] = index;
  }
  get context() {
    return this[CONTEXT_PROP$3];
  }
  set context(ctx) {
    this[CONTEXT_PROP$3] = ctx;
  }
  undo() {
    const {
      parentModel,
      context,
      childModels
    } = this;
    childModels.sort((lhs, rhs) => {
      const {
        lhsParent,
        lhsIndex
      } = context.get(lhs) || {}, {
        rhsParent,
        rhsIndex
      } = context.get(rhs) || {};
      return lhsParent && lhsParent === rhsParent ? lhsIndex - rhsIndex : 0;
    });
    childModels.forEach((m) => {
      const {
        parent,
        index
      } = context.get(m) || {};
      if (parent) {
        if (parent === parentModel) {
          let adjustedIndex;
          adjustedIndex = index > m.parentIndex ? index + 1 : index;
          adjustedIndex = index === parent.children.length - 1 ? null : adjustedIndex;
          const insertBefore = parent.children[adjustedIndex];
          parent.insertChild(m, insertBefore);
        } else {
          parent.insertChild(m, parent.children[index]);
        }
      } else {
        parentModel.removeChild(m);
      }
    });
  }
  redo() {
    const {
      parentModel,
      insertIndex,
      childModels
    } = this, insertBefore = parentModel.children[insertIndex];
    parentModel.insertChild(childModels, insertBefore);
  }
};
InsertChildAction._$name = "InsertChildAction";
var PARENT_MODEL_PROP = Symbol("PARENT_MODEL_PROP");
var CHILD_MODELS_PROP = Symbol("CHILD_MODELS_PROP");
var CONTEXT_PROP$2 = Symbol("CONTEXT_PROP");
var RemoveChildAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      parentModel: void 0,
      childModels: void 0,
      context: void 0
    };
  }
  get type() {
    return "RemoveChildAction";
  }
  get parentModel() {
    return this[PARENT_MODEL_PROP];
  }
  set parentModel(model) {
    this[PARENT_MODEL_PROP] = model;
  }
  get childModels() {
    return this[CHILD_MODELS_PROP];
  }
  set childModels(models) {
    this[CHILD_MODELS_PROP] = models.slice(0);
  }
  get context() {
    return this[CONTEXT_PROP$2];
  }
  set context(ctx) {
    this[CONTEXT_PROP$2] = ctx;
  }
  undo() {
    const {
      parentModel,
      context,
      childModels
    } = this;
    childModels.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs), rhsIndex = context.get(rhs);
      return lhsIndex - rhsIndex;
    });
    childModels.forEach((m) => {
      parentModel.insertChild(m, context.get(m));
    });
  }
  redo() {
    this.parentModel.removeChild(this.childModels);
  }
};
RemoveChildAction._$name = "RemoveChildAction";
var STORE_PROP$3 = Symbol("STORE_PROP");
var MODEL_LIST_PROP$2 = Symbol("MODEL_LIST_PROP");
var AddAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      store: void 0,
      modelList: void 0,
      silent: false
    };
  }
  get type() {
    return "AddAction";
  }
  get store() {
    return this[STORE_PROP$3];
  }
  set store(store) {
    this[STORE_PROP$3] = store;
  }
  get modelList() {
    return this[MODEL_LIST_PROP$2];
  }
  set modelList(list) {
    this[MODEL_LIST_PROP$2] = list.slice(0);
  }
  undo() {
    this.store.remove(this.modelList, this.silent);
  }
  redo() {
    this.store.add(this.modelList, this.silent);
  }
};
AddAction._$name = "AddAction";
var STORE_PROP$2 = Symbol("STORE_PROP");
var MODEL_LIST_PROP$1 = Symbol("MODEL_LIST_PROP");
var INSERT_INDEX_PROP = Symbol("INSERT_INDEX_PROP");
var CONTEXT_PROP$1 = Symbol("CONTEXT_PROP");
var InsertAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      store: void 0,
      modelList: void 0,
      insertIndex: void 0,
      context: void 0,
      silent: false
    };
  }
  get type() {
    return "InsertAction";
  }
  get store() {
    return this[STORE_PROP$2];
  }
  set store(store) {
    this[STORE_PROP$2] = store;
  }
  get modelList() {
    return this[MODEL_LIST_PROP$1];
  }
  set modelList(list) {
    this[MODEL_LIST_PROP$1] = list.slice(0);
  }
  get insertIndex() {
    return this[INSERT_INDEX_PROP];
  }
  set insertIndex(index) {
    this[INSERT_INDEX_PROP] = index;
  }
  get context() {
    return this[CONTEXT_PROP$1];
  }
  set context(context) {
    this[CONTEXT_PROP$1] = context;
  }
  undo() {
    const {
      store,
      modelList,
      context,
      silent
    } = this;
    modelList.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs), rhsIndex = context.get(rhs);
      return lhsIndex !== void 0 && rhsIndex !== void 0 ? lhsIndex - rhsIndex : 0;
    });
    modelList.forEach((m) => {
      const index = context.get(m);
      m._undoingInsertion = true;
      if (index !== void 0) {
        store.insert(index, m, silent);
      } else {
        store.remove(m, silent);
      }
      m._undoingInsertion = false;
    });
  }
  redo() {
    const me = this;
    me.store.insert(me.insertIndex, me.modelList, me.silent);
  }
};
InsertAction._$name = "InsertAction";
var STORE_PROP$1 = Symbol("STORE_PROP");
var MODEL_LIST_PROP = Symbol("MODEL_LIST_PROP");
var CONTEXT_PROP = Symbol("CONTEXT_PROP");
var RemoveAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      store: void 0,
      modelList: void 0,
      context: void 0,
      silent: false
    };
  }
  get type() {
    return "RemoveAction";
  }
  get store() {
    return this[STORE_PROP$1];
  }
  set store(store) {
    this[STORE_PROP$1] = store;
  }
  get modelList() {
    return this[MODEL_LIST_PROP];
  }
  set modelList(list) {
    this[MODEL_LIST_PROP] = list.slice(0);
  }
  get context() {
    return this[CONTEXT_PROP];
  }
  set context(context) {
    this[CONTEXT_PROP] = context;
  }
  undo() {
    const {
      store,
      context,
      modelList,
      silent
    } = this;
    modelList.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs), rhsIndex = context.get(rhs);
      return lhsIndex - rhsIndex;
    });
    modelList.forEach((m) => {
      const index = context.get(m);
      store.insert(index, m, silent);
    });
  }
  redo() {
    this.store.remove(this.modelList, this.silent);
  }
};
RemoveAction._$name = "RemoveAction";
var STORE_PROP = Symbol("STORE_PROP");
var ALL_RECORDS_PROP = Symbol("ALL_RECORDS_PROP");
var RemoveAllAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      store: void 0,
      allRecords: void 0,
      silent: false
    };
  }
  get type() {
    return "RemoveAllAction";
  }
  get store() {
    return this[STORE_PROP];
  }
  set store(store) {
    this[STORE_PROP] = store;
  }
  get allRecords() {
    return this[ALL_RECORDS_PROP];
  }
  set allRecords(records) {
    this[ALL_RECORDS_PROP] = records.slice(0);
  }
  undo() {
    const {
      store,
      allRecords,
      silent
    } = this;
    store.add(allRecords, silent);
  }
  redo() {
    this.store.removeAll(this.silent);
  }
};
RemoveAllAction._$name = "RemoveAllAction";
var makeModelUpdateAction = (model, newData, oldData, isInitialUserAction) => {
  return new UpdateAction({
    model,
    newData,
    oldData,
    isInitialUserAction
  });
};
var makeModelInsertChildAction = (parentModel, insertIndex, childModels, context) => {
  return new InsertChildAction({
    parentModel,
    childModels,
    insertIndex,
    context
  });
};
var makeModelRemoveChildAction = (parentModel, childModels, context) => {
  return new RemoveChildAction({
    parentModel,
    childModels,
    context
  });
};
var makeStoreModelAddAction = (store, modelList, silent) => {
  return new AddAction({
    store,
    modelList,
    silent
  });
};
var makeStoreModelInsertAction = (store, insertIndex, modelList, context, silent) => {
  return new InsertAction({
    store,
    insertIndex,
    modelList,
    context,
    silent
  });
};
var makeStoreModelRemoveAction = (store, modelList, context, silent) => {
  return new RemoveAction({
    store,
    modelList,
    context,
    silent
  });
};
var makeStoreRemoveAllAction = (store, allRecords, silent) => {
  return new RemoveAllAction({
    store,
    allRecords,
    silent
  });
};
var stateTransition = (stm, event, ...args) => {
  const oldState = stm.state, newState = event.call(stm[STATE_PROP], stm, ...args);
  if (typeof newState === "string") {
    stm[STATE_PROP] = Registry.resolveStmState(newState);
  } else if (newState instanceof StateBase) {
    stm[STATE_PROP] = newState;
  } else if (Array.isArray(newState)) {
    const [state, next] = newState;
    if (typeof state === "string") {
      stm[STATE_PROP] = Registry.resolveStmState(state);
    } else if (state instanceof StateBase) {
      stm[STATE_PROP] = state;
    } else if (state && typeof state === "object") {
      stm = Object.assign(stm, state);
      stm[STATE_PROP] = Registry.resolveStmState(stm[STATE_PROP]);
    }
    if (typeof next === "function") {
      stateTransition(stm, next, ...args);
    }
  } else if (newState && typeof newState === "object") {
    stm = Object.assign(stm, newState);
    stm[STATE_PROP] = Registry.resolveStmState(stm[STATE_PROP]);
  }
  if (oldState !== ReadyState && oldState !== AutoReadyState && newState !== ReadyState && newState !== AutoReadyState) {
    stm.trigger("ready");
  }
};
var StateTrackingManager = class extends Events(Base) {
  static get defaultConfig() {
    return {
      disabled: true,
      autoRecord: false,
      autoRecordTransactionStopTimeout: 100,
      makeModelUpdateAction,
      makeModelInsertChildAction,
      makeModelRemoveChildAction,
      makeStoreModelAddAction,
      makeStoreModelInsertAction,
      makeStoreModelRemoveAction,
      makeStoreRemoveAllAction,
      getTransactionTitle: null
    };
  }
  construct(...args) {
    Object.assign(this, {
      [STATE_PROP]: ReadyState,
      [STORES_PROP]: [],
      [QUEUE_PROP]: [],
      [POS_PROP]: 0,
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null,
      [AUTO_RECORD_PROP]: false
    });
    super.construct(...args);
  }
  get state() {
    return this[STATE_PROP];
  }
  get position() {
    return this[POS_PROP];
  }
  get length() {
    return this[QUEUE_PROP].length;
  }
  get stores() {
    return Array.from(this[STORES_PROP]);
  }
  hasStore(store) {
    return this[STORES_PROP].includes(store);
  }
  addStore(store) {
    if (!this.hasStore(store)) {
      this[STORES_PROP].push(store);
      store.stm = this;
    }
  }
  removeStore(store) {
    if (this.hasStore(store)) {
      this[STORES_PROP] = this[STORES_PROP].filter((s) => s !== store);
      store.stm = null;
    }
  }
  forEachStore(fn) {
    this[STORES_PROP].forEach((s) => fn(s, s.id));
  }
  get disabled() {
    return this.state === DisabledState;
  }
  set disabled(val) {
    const me = this;
    if (me.disabled !== val) {
      if (val) {
        stateTransition(me, me.state.onDisable, me);
      } else {
        stateTransition(me, me.state.onEnable, me);
      }
      me.trigger("stmDisabled", {
        disabled: val
      });
      me.trigger("disabled", {
        disabled: val
      });
    }
  }
  get enabled() {
    return !this.disabled;
  }
  enable() {
    this.disabled = false;
  }
  disable() {
    this.disabled = true;
  }
  get isReady() {
    return this.state === ReadyState || this.state === AutoReadyState;
  }
  waitForReadiness() {
    return this.await("ready", false);
  }
  get isRecording() {
    return this.state === RecordingState || this.state === AutoRecordingState;
  }
  get autoRecord() {
    return this[AUTO_RECORD_PROP];
  }
  set autoRecord(value) {
    const me = this;
    if (me.autoRecord != value) {
      if (value) {
        stateTransition(me, me.state.onAutoRecordOn, me);
      } else {
        stateTransition(me, me.state.onAutoRecordOff, me);
      }
    }
  }
  startTransaction(title = null) {
    stateTransition(this, this.state.onStartTransaction, title);
  }
  stopTransaction(title = null) {
    stateTransition(this, this.state.onStopTransaction, title);
  }
  stopTransactionDelayed() {
    stateTransition(this, this.state.onStopTransactionDelayed);
  }
  rejectTransaction() {
    stateTransition(this, this.state.onRejectTransaction);
  }
  get transaction() {
    return this[TRANSACTION_PROP];
  }
  get queue() {
    return this[QUEUE_PROP].map((t) => t.title);
  }
  get isRestoring() {
    return this.state === RestoringState;
  }
  get canUndo() {
    return this.state.canUndo(this);
  }
  get canRedo() {
    return this.state.canRedo(this);
  }
  async undo(steps = 1) {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    stateTransition(this, this.state.onUndo, steps);
  }
  async undoAll() {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    this.undo(this.length);
  }
  async redo(steps = 1) {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    stateTransition(this, this.state.onRedo, steps);
  }
  async redoAll() {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    this.redo(this.length);
  }
  resetQueue(options = {
    undo: true,
    redo: true
  }) {
    stateTransition(this, this.state.onResetQueue, options);
  }
  resetUndoQueue() {
    this.resetQueue({
      undo: true
    });
  }
  resetRedoQueue() {
    this.resetQueue({
      redo: true
    });
  }
  notifyStoresAboutStateRecordingStart(transaction) {
    this.forEachStore((store) => {
      var _store$onStmRecording;
      return (_store$onStmRecording = store.onStmRecordingStart) === null || _store$onStmRecording === void 0 ? void 0 : _store$onStmRecording.call(store, this, transaction);
    });
    this.trigger("recordingStart", {
      stm: this,
      transaction
    });
  }
  notifyStoresAboutStateRecordingStop(transaction, reason) {
    this.forEachStore((store) => {
      var _store$onStmRecording2;
      return (_store$onStmRecording2 = store.onStmRecordingStop) === null || _store$onStmRecording2 === void 0 ? void 0 : _store$onStmRecording2.call(store, this, transaction, reason);
    });
    this.trigger("recordingStop", {
      stm: this,
      transaction,
      reason
    });
  }
  notifyStoresAboutStateRestoringStart() {
    this.forEachStore((store) => {
      var _store$onStmRestoring;
      return (_store$onStmRestoring = store.onStmRestoringStart) === null || _store$onStmRestoring === void 0 ? void 0 : _store$onStmRestoring.call(store, this);
    });
    this.trigger("restoringStart", {
      stm: this
    });
  }
  notifyStoresAboutStateRestoringStop({
    cause,
    transactions
  }) {
    this.forEachStore((store) => {
      var _store$onStmRestoring2;
      return (_store$onStmRestoring2 = store.onStmRestoringStop) === null || _store$onStmRestoring2 === void 0 ? void 0 : _store$onStmRestoring2.call(store, this);
    });
    this.trigger("restoringStop", {
      stm: this,
      cause,
      transactions
    });
  }
  notifyStoresAboutQueueReset(options) {
    this.forEachStore((store) => {
      var _store$onStmQueueRese;
      return (_store$onStmQueueRese = store.onStmQueueReset) === null || _store$onStmQueueRese === void 0 ? void 0 : _store$onStmQueueRese.call(store, this, options);
    });
    this.trigger("queueReset", {
      stm: this,
      options
    });
  }
  onModelUpdate(model, newData, oldData, isInitialUserAction) {
    stateTransition(this, this.state.onModelUpdate, model, newData, oldData, isInitialUserAction);
  }
  onModelInsertChild(parentModel, index, childModels, context) {
    stateTransition(this, this.state.onModelInsertChild, parentModel, index, childModels, context);
  }
  onModelRemoveChild(parentModel, childModels, context) {
    stateTransition(this, this.state.onModelRemoveChild, parentModel, childModels, context);
  }
  onStoreModelAdd(store, models, silent) {
    stateTransition(this, this.state.onStoreModelAdd, store, models, silent);
  }
  onStoreModelInsert(store, index, models, context, silent) {
    stateTransition(this, this.state.onStoreModelInsert, store, index, models, context, silent);
  }
  onStoreModelRemove(store, models, context, silent) {
    stateTransition(this, this.state.onStoreModelRemove, store, models, context, silent);
  }
  onStoreRemoveAll(store, allRecords, silent) {
    stateTransition(this, this.state.onStoreRemoveAll, store, allRecords, silent);
  }
  onUndoKeyPress(event) {
    const me = this;
    if (me.enabled) {
      if (event.shiftKey) {
        if (me.canRedo) {
          event.preventDefault();
          me.redo();
        }
      } else if (me.canUndo) {
        event.preventDefault();
        me.undo();
      }
    }
  }
  stash() {
    if (this.transaction) {
      this.stashedTransaction = this.transaction;
      this.rejectTransaction();
    }
  }
  applyStash() {
    if (this.stashedTransaction) {
      this.startTransaction(this.stashedTransaction.title);
      this.stashedTransaction.redo();
      delete this.stashedTransaction;
    }
  }
};
StateTrackingManager._$name = "StateTrackingManager";
var arraySlice = Array.prototype.slice;
var emptyArray$5 = Object.freeze([]);
var emptyObject$4 = Object.freeze({});
var htmlRe = /[&<]/;
var {
  getPrototypeOf
} = Object;
var {
  toString
} = Object.prototype;
var {
  isEqual,
  isObject
} = ObjectHelper;
var checkEqualityIgnore = {
  parent: 1,
  elementData: 1,
  ns: 1,
  syncOptions: 1
};
var makeCheckEqualityOptions = () => ({
  ignore: checkEqualityIgnore,
  refsFound: /* @__PURE__ */ new Set()
});
var isClass = {
  class: 1,
  className: 1,
  classname: 1
};
var simpleTypes = {
  bigint: 1,
  boolean: 1,
  function: 1,
  number: 1,
  string: 1,
  symbol: 1
};
var syncIgnoreAttributes = {
  tag: 1,
  html: 1,
  text: 1,
  children: 1,
  tooltip: 1,
  parent: 1,
  nextSibling: 1,
  ns: 1,
  reference: 1,
  elementData: 1,
  retainElement: 1,
  compareHtml: 1,
  syncOptions: 1,
  listeners: 1,
  isReleased: 1,
  null: 1,
  "": 1,
  keepChildren: 1
};
var addAndCacheCls = (cls, lastDomConfig) => {
  const propertyName = "className" in lastDomConfig ? "className" : "class", propertyValue = lastDomConfig[propertyName];
  if (propertyValue) {
    if (typeof propertyValue === "string") {
      const value = propertyValue.split(" ");
      if (!value.includes(cls)) {
        value.push(cls);
        lastDomConfig[propertyName] = value.join(" ");
      }
    } else if (Array.isArray(propertyValue)) {
      if (!propertyValue.includes(cls)) {
        propertyValue.push(cls);
      }
    } else if (propertyValue.isDomClassList) {
      propertyValue.add(cls);
    } else if (ObjectHelper.isObject(propertyValue)) {
      propertyValue[cls] = 1;
    }
  }
};
var removeAndUncacheCls = (cls, lastDomConfig) => {
  const propertyName = "className" in lastDomConfig ? "className" : "class", propertyValue = lastDomConfig[propertyName];
  if (propertyValue) {
    if (typeof propertyValue === "string") {
      const value = propertyValue.split(" ");
      if (value.includes(cls)) {
        value.splice(value.indexOf(cls), 1);
        lastDomConfig[propertyName] = value.join(" ");
      }
    } else if (Array.isArray(propertyValue)) {
      if (propertyValue.includes(cls)) {
        propertyValue.splice(propertyValue.indexOf(cls), 1);
      }
    } else if (propertyValue.isDomClassList) {
      propertyValue.remove(cls);
    } else if (ObjectHelper.isObject(propertyValue)) {
      delete propertyValue[cls];
    }
  }
};
var DomSync = class {
  static checkEquality(is, was, options, ignoreRefs) {
    if (is === was) {
      return true;
    }
    if (is == null) {
      return was == null;
    }
    if (!is || !was) {
      return false;
    }
    const typeA = typeof is, typeB = typeof was;
    if (typeA !== typeB || simpleTypes[typeA]) {
      return false;
    }
    let cache = options.equalityCache || (options.equalityCache = /* @__PURE__ */ new Map()), ignoreChildRefs = Boolean(ignoreRefs), equal2, i, ignore, ignoreRefOpt, key, syncOptions, val;
    cache = cache.get(is) || cache.set(is, /* @__PURE__ */ new Map()).get(is);
    equal2 = cache.get(was);
    if (equal2 === void 0) {
      equal2 = true;
      if (getPrototypeOf(is) !== getPrototypeOf(was) || is instanceof Node) {
        equal2 = false;
      } else if (Array.isArray(is)) {
        i = is.length;
        if (i !== was.length) {
          equal2 = false;
        } else {
          while (i-- > 0) {
            if (!DomSync.checkEquality(is[i], was[i], options, ignoreChildRefs)) {
              equal2 = false;
              break;
            }
          }
        }
      } else {
        var _syncOptions;
        syncOptions = is.syncOptions;
        ignoreRefOpt = (_syncOptions = syncOptions) === null || _syncOptions === void 0 ? void 0 : _syncOptions.ignoreRefs;
        if (ignoreRefOpt) {
          ignoreChildRefs = true;
          ignoreRefs = ignoreRefOpt !== "children";
        }
        ignore = options.ignore || emptyObject$4;
        for (key in was) {
          if (!ignore[key] && !(key in is) && !(ignoreRefs && key === "reference")) {
            equal2 = false;
            break;
          }
        }
        if (equal2) {
          if (toString.call(was) === "[object Date]") {
            equal2 = is.getTime() === was.getTime();
          } else {
            for (key in is) {
              if (!ignore[key] && !(ignoreRefs && key === "reference")) {
                if (!(key in was)) {
                  equal2 = false;
                  break;
                }
                val = is[key];
                if (!DomSync.checkEquality(val, was[key], options, ignoreChildRefs)) {
                  equal2 = false;
                  break;
                }
              }
            }
          }
        }
      }
      if (!ignoreRefs && isObject(is) && is.reference) {
        var _options$refsFound;
        (_options$refsFound = options.refsFound) === null || _options$refsFound === void 0 ? void 0 : _options$refsFound.add(is.reference);
      }
      cache.set(was, equal2);
    }
    return equal2;
  }
  static sync(options) {
    const optionsIn = options, {
      refOwner
    } = options, refsWas = refOwner === null || refOwner === void 0 ? void 0 : refOwner.byRef, checkEqualityOptions = makeCheckEqualityOptions();
    let affected = options.affected, i, ref, targetNode, lastDomConfig;
    if (typeof affected === "string") {
      affected = [affected];
    }
    options = _objectSpread2(_objectSpread2({}, options), {}, {
      checkEqualityOptions
    });
    if (refOwner) {
      refOwner.byRef = {};
      if (affected) {
        for (ref in refsWas) {
          if (!affected.includes(ref)) {
            refOwner.byRef[ref] = refsWas[ref];
          }
        }
      }
      options.refsWas = refsWas;
    }
    optionsIn.changed = DomSync.performSync(options, options.targetElement);
    if (refOwner) {
      if (!affected) {
        affected = Object.keys(refsWas);
      }
      for (i = 0; i < affected.length; ++i) {
        ref = affected[i];
        targetNode = refsWas[ref];
        if (checkEqualityOptions.refsFound.has(ref) || targetNode.retainElement) {
          refOwner.byRef[ref] = targetNode;
        } else {
          lastDomConfig = targetNode.lastDomConfig;
          targetNode.remove();
          refOwner.detachRef(ref, targetNode, lastDomConfig);
        }
      }
    }
    return options.targetElement;
  }
  static performSync(options, targetElement) {
    const {
      domConfig,
      callback
    } = options, {
      lastDomConfig
    } = targetElement, configIsEqual = options.configEquality || DomSync.checkEquality;
    if (!configIsEqual(domConfig, lastDomConfig, options.checkEqualityOptions, options.ignoreRefs)) {
      if (domConfig) {
        if (!domConfig.onlyChildren) {
          DomSync.syncAttributes(domConfig, targetElement, options);
          DomSync.syncContent(domConfig, targetElement);
        }
        if (!domConfig.keepChildren) {
          DomSync.syncChildren(options, targetElement);
        }
      } else {
        targetElement.innerHTML = null;
        targetElement.syncIdMap = null;
      }
      targetElement.lastDomConfig = !(domConfig !== null && domConfig !== void 0 && domConfig.onlyChildren && lastDomConfig) ? domConfig : _objectSpread2(_objectSpread2({}, lastDomConfig), {}, {
        children: domConfig.children
      });
      return true;
    } else {
      callback === null || callback === void 0 ? void 0 : callback({
        action: "none",
        domConfig,
        targetElement
      });
    }
    return false;
  }
  static syncDataset(domConfig, targetElement) {
    const {
      lastDomConfig
    } = targetElement, sameConfig = domConfig === lastDomConfig, source = Object.keys(domConfig.dataset), target = lastDomConfig && lastDomConfig.dataset && Object.keys(lastDomConfig.dataset), delta = ArrayHelper.delta(source, target);
    let attr, i, name, value;
    for (i = 0; i < delta.onlyInA.length; i++) {
      attr = delta.onlyInA[i];
      value = domConfig.dataset[attr];
      if (value != null) {
        targetElement.setAttribute(`data-${StringHelper.hyphenate(attr)}`, value);
      }
    }
    for (i = 0; i < delta.inBoth.length; i++) {
      attr = delta.inBoth[i];
      value = domConfig.dataset[attr];
      if (sameConfig || value != lastDomConfig.dataset[attr]) {
        name = `data-${StringHelper.hyphenate(attr)}`;
        if (value == null) {
          targetElement.removeAttribute(name);
        } else {
          targetElement.setAttribute(name, value);
        }
      }
    }
    for (i = 0; i < delta.onlyInB.length; i++) {
      targetElement.removeAttribute(`data-${StringHelper.hyphenate(delta.onlyInB[i])}`);
    }
  }
  static addCls(cls, targetElement) {
    const {
      lastDomConfig
    } = targetElement;
    cls = DomClassList.normalize(cls, "array");
    cls.forEach((cls2) => {
      targetElement.classList.add(cls2);
      addAndCacheCls(cls2, lastDomConfig);
    });
  }
  static removeCls(cls, targetElement) {
    const {
      lastDomConfig
    } = targetElement;
    cls = DomClassList.normalize(cls, "array");
    cls.forEach((cls2) => {
      targetElement.classList.remove(cls2);
      removeAndUncacheCls(cls2, lastDomConfig);
    });
  }
  static syncClassList(domConfig, targetElement, lastDomConfig) {
    let cls = domConfig.className || domConfig.class, changed = false, c, currentClasses, i, k, keep, last;
    if (lastDomConfig) {
      currentClasses = DomClassList.normalize(targetElement, "array");
      cls = DomClassList.normalize(cls, "object");
      last = DomClassList.normalize(lastDomConfig.className || lastDomConfig.class, "object");
      keep = [];
      for (i = 0, k = currentClasses.length; i < k; ++i) {
        c = currentClasses[i];
        if (cls[c] || !(c in last)) {
          last[c] = 1;
          keep.push(c);
        } else {
          changed = true;
        }
      }
      for (c in cls) {
        if (!last[c]) {
          keep.push(c);
          changed = true;
        }
      }
      if (!changed) {
        return;
      }
      cls = keep.join(" ");
    } else {
      cls = DomClassList.normalize(cls);
    }
    targetElement.setAttribute("class", cls);
  }
  static getSyncAttributes(domConfig) {
    const attributes = {}, names = [];
    if (domConfig) {
      Object.keys(domConfig).forEach((attr) => {
        if (!syncIgnoreAttributes[attr]) {
          const name = attr.toLowerCase();
          attributes[name] = domConfig[attr];
          names.push(name);
        }
      });
    }
    return {
      attributes,
      names
    };
  }
  static syncAttributes(domConfig, targetElement, options) {
    const {
      lastDomConfig
    } = targetElement, sameConfig = domConfig === lastDomConfig, sourceSyncAttrs = DomSync.getSyncAttributes(domConfig), {
      attributes: sourceAttributes,
      names: sourceNames
    } = sourceSyncAttrs, {
      attributes: targetAttributes,
      names: targetNames
    } = sameConfig ? sourceSyncAttrs : DomSync.getSyncAttributes(lastDomConfig), {
      onlyInA: toAdd,
      onlyInB: toRemove,
      inBoth: toSync
    } = sameConfig ? {
      onlyInA: emptyArray$5,
      onlyInB: emptyArray$5,
      inBoth: sourceNames
    } : ArrayHelper.delta(sourceNames, targetNames);
    let attr, i;
    for (i = 0; i < toAdd.length; i++) {
      attr = toAdd[i];
      const sourceAttr = sourceAttributes[attr];
      if (attr === "style" && sourceAttr != null) {
        DomHelper.applyStyle(targetElement, sourceAttr, true);
      } else if (attr === "dataset") {
        DomSync.syncDataset(domConfig, targetElement);
      } else if (isClass[attr]) {
        DomSync.syncClassList(domConfig, targetElement);
      } else if (sourceAttr != null) {
        targetElement.setAttribute(attr, sourceAttr);
      }
    }
    for (i = 0; i < toRemove.length; i++) {
      targetElement.removeAttribute(toRemove[i]);
    }
    for (i = 0; i < toSync.length; i++) {
      attr = toSync[i];
      const sourceAttr = sourceAttributes[attr], targetAttr = targetAttributes[attr];
      if (sourceAttr == null) {
        targetElement.removeAttribute(attr);
      } else if (attr === "style") {
        if (options.strict) {
          if (sameConfig) {
            DomSync.syncStyles(targetElement, sourceAttr);
          } else if (!isEqual(sourceAttr, targetAttr, true)) {
            DomSync.syncStyles(targetElement, sourceAttr, targetAttr);
          }
        } else if (sameConfig || !isEqual(sourceAttr, targetAttr, true)) {
          DomHelper.applyStyle(targetElement, sourceAttr, true);
        }
      } else if (attr === "dataset") {
        DomSync.syncDataset(domConfig, targetElement);
      } else if (isClass[attr]) {
        DomSync.syncClassList(domConfig, targetElement, options.strict && targetElement.lastDomConfig);
      } else if (sameConfig || sourceAttr !== targetAttr) {
        targetElement.setAttribute(attr, sourceAttr);
      }
    }
  }
  static syncStyles(targetElement, sourceAttr, targetAttr) {
    let styles, key, value;
    if (!targetAttr) {
      styles = sourceAttr;
    } else {
      styles = {};
      sourceAttr = DomHelper.parseStyle(sourceAttr);
      targetAttr = DomHelper.parseStyle(targetAttr);
      if (sourceAttr) {
        for (key in sourceAttr) {
          value = sourceAttr[key];
          if (targetAttr[key] !== value) {
            styles[key] = value;
          }
        }
      }
      for (key in targetAttr) {
        if (!(key in sourceAttr)) {
          styles[key] = "";
        }
      }
    }
    DomHelper.applyStyle(targetElement, styles);
  }
  static syncContent(domConfig, targetElement) {
    const {
      html,
      text
    } = domConfig, content = text !== null && text !== void 0 ? text : html;
    targetElement.didSetTextContent = false;
    if (domConfig.elementData) {
      targetElement.elementData = domConfig.elementData;
    }
    if (content instanceof DocumentFragment) {
      if (targetElement.childNodes.length === 1 && DomHelper.getChildElementCount(targetElement) === 0 && content.childNodes.length === 1 && DomHelper.getChildElementCount(content) === 0) {
        DomHelper.setInnerText(targetElement, content.firstChild.data);
      } else {
        targetElement.innerHTML = "";
        targetElement.appendChild(content);
      }
    } else if (html != null && htmlRe.test(html)) {
      targetElement.innerHTML = String(html);
    } else if (content != null) {
      var _lastDomConfig$childr;
      const {
        lastDomConfig
      } = targetElement;
      if (lastDomConfig !== null && lastDomConfig !== void 0 && (_lastDomConfig$childr = lastDomConfig.children) !== null && _lastDomConfig$childr !== void 0 && _lastDomConfig$childr.length || lastDomConfig !== null && lastDomConfig !== void 0 && lastDomConfig.html && htmlRe.test(targetElement.lastDomConfig.html)) {
        targetElement.innerHTML = content;
      } else {
        DomHelper.setInnerText(targetElement, String(content));
        targetElement.didSetTextContent = true;
      }
    }
  }
  static insertTextNode(text, targetElement, callback, refOwner, beforeElement = null) {
    const newNode = document.createTextNode(text);
    targetElement.insertBefore(newNode, beforeElement);
    if (refOwner) {
      newNode.$refOwnerId = refOwner.id;
    }
    callback === null || callback === void 0 ? void 0 : callback({
      action: "newNode",
      domConfig: text,
      targetElement: newNode
    });
  }
  static insertElement(domConfig, targetElement, targetNode, refOwner, syncIdMap, syncId, options) {
    var _options$callback;
    const newElement = options.ns ? document.createElementNS(options.ns, domConfig.tag || "svg") : document.createElement(domConfig.tag || "div");
    targetElement.insertBefore(newElement, targetNode);
    DomSync.performSync(options, newElement);
    if (syncId != null) {
      syncIdMap[syncId] = newElement;
    }
    if (!domConfig.role && !domConfig.tabIndex && !domConfig["aria-hidden"] && !DomHelper.isFocusable(newElement, true) && !newElement.htmlFor) {
      newElement.setAttribute("role", "presentation");
    }
    if (refOwner) {
      newElement.$refOwnerId = refOwner.id;
      if (syncId) {
        newElement.$reference = syncId;
        refOwner.attachRef(syncId, newElement, domConfig);
      }
    }
    (_options$callback = options.callback) === null || _options$callback === void 0 ? void 0 : _options$callback.call(options, {
      action: "newElement",
      domConfig,
      targetElement: newElement,
      syncId
    });
  }
  static syncChildren(options, targetElement) {
    var _domConfig$html, _syncOptions$ignoreRe;
    let {
      domConfig,
      syncIdField,
      callback,
      releaseThreshold,
      configEquality,
      ns: ns2,
      refOwner,
      refsWas,
      strict,
      checkEqualityOptions,
      ignoreRefs
    } = options, syncOptions = domConfig.syncOptions || {}, cleanupNodes = null, index, nextNode, syncId;
    if ((_domConfig$html = domConfig.html) !== null && _domConfig$html !== void 0 ? _domConfig$html : domConfig.text) {
      return;
    }
    ignoreRefs = Boolean((_syncOptions$ignoreRe = syncOptions.ignoreRefs) !== null && _syncOptions$ignoreRe !== void 0 ? _syncOptions$ignoreRe : ignoreRefs);
    if (ignoreRefs) {
      refOwner = refsWas = null;
    }
    if ("strict" in syncOptions) {
      strict = syncOptions.strict;
    }
    const newSyncIdMap = refOwner ? refOwner.byRef : {}, sourceConfigs = arraySlice.call(domConfig.children || []), targetNodes = arraySlice.call(targetElement.childNodes), syncIdMap = refsWas || targetElement.syncIdMap || {}, releasedIdMap = targetElement.releasedIdMap || {}, nextTarget = (remove) => {
      while (targetNodes.length && targetNodes[0].parentNode !== targetElement) {
        targetNodes.shift();
      }
      return (remove ? targetNodes.shift() : targetNodes[0]) || null;
    };
    syncIdField = syncOptions.syncIdField || syncIdField;
    strict = syncOptions.strict || strict;
    callback = syncOptions.callback || callback;
    configEquality = syncOptions.configEquality || configEquality;
    releaseThreshold = "releaseThreshold" in syncOptions ? syncOptions.releaseThreshold : releaseThreshold;
    if (syncIdField) {
      targetElement.syncIdMap = newSyncIdMap;
    }
    const syncChildOptions = {
      checkEqualityOptions: checkEqualityOptions || makeCheckEqualityOptions(),
      ignoreRefs,
      refOwner,
      refsWas,
      strict,
      syncIdField,
      releaseThreshold,
      callback,
      configEquality
    };
    while (sourceConfigs.length) {
      const sourceConfig = sourceConfigs.shift();
      syncId = null;
      if (!sourceConfig) {
        continue;
      }
      if (DomHelper.isReactElement(sourceConfig)) {
        callback({
          jsx: sourceConfig,
          targetElement
        });
        continue;
      }
      if (sourceConfig instanceof Node) {
        nextNode = nextTarget();
        if (sourceConfig !== nextNode) {
          targetElement.insertBefore(sourceConfig, nextNode);
        }
        index = targetNodes.indexOf(sourceConfig);
        if (index > -1) {
          targetNodes.splice(index, 1);
        }
        continue;
      }
      const isTextNode = typeof sourceConfig === "string";
      syncChildOptions.domConfig = sourceConfig;
      syncChildOptions.ns = sourceConfig.ns || ns2;
      if (!isTextNode) {
        if (refOwner) {
          syncId = sourceConfig.reference;
        } else if (syncIdField && sourceConfig.dataset) {
          syncId = sourceConfig.dataset[syncIdField];
        }
        if (syncId != null && !sourceConfig.unmatched) {
          const syncTargetElement = syncIdMap[syncId] || releasedIdMap[syncId];
          if (syncTargetElement) {
            const {
              lastDomConfig
            } = syncTargetElement;
            if (syncTargetElement.retainElement)
              ;
            else if (DomSync.performSync(syncChildOptions, syncTargetElement)) {
              var _callback;
              (_callback = callback) === null || _callback === void 0 ? void 0 : _callback({
                action: "reuseOwnElement",
                domConfig: sourceConfig,
                targetElement: syncTargetElement,
                lastDomConfig,
                syncId
              });
            }
            if (sourceConfig.retainElement) {
              syncTargetElement.retainElement = true;
            }
            newSyncIdMap[syncId] = syncTargetElement;
            ArrayHelper.remove(targetNodes, syncTargetElement);
            delete releasedIdMap[syncId];
            syncTargetElement.isReleased = false;
            nextNode = nextTarget();
            if (syncTargetElement.parentNode !== targetElement || strict && syncTargetElement.nextSibling !== nextNode) {
              targetElement.insertBefore(syncTargetElement, nextNode);
            }
          } else if (strict) {
            DomSync.insertElement(sourceConfig, targetElement, nextTarget(), refOwner, newSyncIdMap, syncId, syncChildOptions);
          } else {
            sourceConfigs.push(sourceConfig);
            sourceConfig.unmatched = true;
          }
          continue;
        }
        if (sourceConfig.unmatched) {
          delete sourceConfig.unmatched;
        }
      }
      let beforeNode = null, targetNode = null, cleanupNode;
      while (!targetNode && (cleanupNode = nextTarget(true))) {
        if (refOwner) {
          if (cleanupNode.$refOwnerId !== refOwner.id) {
            continue;
          }
          if (cleanupNode.$reference) {
            if (!strict) {
              continue;
            }
            beforeNode = cleanupNode;
            break;
          }
          targetNode = cleanupNode;
        } else if (!cleanupNode.retainElement) {
          targetNode = cleanupNode;
        }
        if (!targetNode) {
          (cleanupNodes || (cleanupNodes = [])).push(cleanupNode);
        }
      }
      if (beforeNode || !targetNode) {
        if (isTextNode) {
          DomSync.insertTextNode(sourceConfig, targetElement, callback, refOwner, beforeNode);
        } else {
          DomSync.insertElement(sourceConfig, targetElement, beforeNode, refOwner, newSyncIdMap, syncId, syncChildOptions);
        }
      } else {
        if (!isTextNode && targetNode.nodeType === Node.ELEMENT_NODE && (sourceConfig.tag || "div").toLowerCase() === targetNode.tagName.toLowerCase()) {
          var _lastDomConfig$datase, _callback2;
          const {
            lastDomConfig
          } = targetNode, result = DomSync.performSync(syncChildOptions, targetNode);
          if (syncIdField && (lastDomConfig === null || lastDomConfig === void 0 ? void 0 : (_lastDomConfig$datase = lastDomConfig.dataset) === null || _lastDomConfig$datase === void 0 ? void 0 : _lastDomConfig$datase[syncIdField]) != null) {
            const lastSyncId = lastDomConfig.dataset[syncIdField];
            delete releasedIdMap[lastSyncId];
            delete syncIdMap[lastSyncId];
          }
          if (syncId != null) {
            newSyncIdMap[syncId] = targetNode;
          }
          targetNode.isReleased = false;
          result && ((_callback2 = callback) === null || _callback2 === void 0 ? void 0 : _callback2({
            action: "reuseElement",
            domConfig: sourceConfig,
            targetElement: targetNode,
            lastDomConfig,
            syncId
          }));
        } else if (isTextNode && targetNode.nodeType === Node.TEXT_NODE) {
          targetNode.data = sourceConfig;
        } else {
          if (isTextNode) {
            DomSync.insertTextNode(sourceConfig, targetElement, callback, refOwner, targetNode);
          } else {
            DomSync.insertElement(sourceConfig, targetElement, targetNode, refOwner, newSyncIdMap, syncId, syncChildOptions);
          }
          targetNode.remove();
        }
      }
    }
    if (targetElement.didSetTextContent && targetNodes.length === 1 && targetNodes[0].nodeType === Node.TEXT_NODE) {
      return;
    }
    while (nextNode = nextTarget(true)) {
      if (!refOwner || nextNode.$refOwnerId === refOwner.id && !nextNode.$reference) {
        (cleanupNodes || (cleanupNodes = [])).push(nextNode);
      }
    }
    if (cleanupNodes) {
      DomSync.syncChildrenCleanup(targetElement, cleanupNodes, newSyncIdMap, callback, refOwner, releaseThreshold, syncIdField);
    }
  }
  static syncChildrenCleanup(targetElement, cleanupNodes, newSyncIdMap, callback, refOwner, releaseThreshold, syncIdField) {
    let releaseCount = 0, ref;
    for (const targetNode of cleanupNodes) {
      const {
        lastDomConfig
      } = targetNode;
      if (targetNode.nodeType === Element.TEXT_NODE) {
        targetNode.remove();
        continue;
      }
      if (!targetNode.retainElement) {
        if (!refOwner && syncIdField && (releaseThreshold == null || releaseCount < releaseThreshold)) {
          if (!targetNode.isReleased) {
            targetNode.className = "b-released";
            targetNode.isReleased = true;
            if (lastDomConfig !== null && lastDomConfig !== void 0 && lastDomConfig.dataset) {
              if (!targetElement.releasedIdMap) {
                targetElement.releasedIdMap = {};
              }
              targetElement.releasedIdMap[lastDomConfig.dataset[syncIdField]] = targetNode;
            }
            callback === null || callback === void 0 ? void 0 : callback({
              action: "releaseElement",
              domConfig: lastDomConfig,
              lastDomConfig,
              targetElement: targetNode
            });
            if (lastDomConfig) {
              lastDomConfig.isReleased = true;
              if (lastDomConfig.className) {
                lastDomConfig.className = "b-released";
              }
              if (lastDomConfig.class) {
                lastDomConfig.class = "b-released";
              }
              if (lastDomConfig.style) {
                lastDomConfig.style = null;
              }
            }
          }
          releaseCount++;
        } else {
          targetNode.remove();
          if (refOwner) {
            ref = targetNode.$reference;
            if (ref) {
              refOwner.detachRef(ref, targetNode, lastDomConfig);
            }
          }
          if (targetElement.releasedIdMap && syncIdField && lastDomConfig !== null && lastDomConfig !== void 0 && lastDomConfig.dataset) {
            delete targetElement.releasedIdMap[lastDomConfig.dataset[syncIdField]];
          }
          callback === null || callback === void 0 ? void 0 : callback({
            action: "removeElement",
            domConfig: targetNode.lastDomConfig,
            lastDomConfig: targetNode.lastDomConfig,
            targetElement: targetNode
          });
        }
      } else if (syncIdField) {
        if (lastDomConfig) {
          newSyncIdMap[targetNode.dataset[syncIdField]] = targetNode;
        }
      }
    }
  }
  static removeChild(parentElement, childElement) {
    if (parentElement.contains(childElement)) {
      const syncIdMap = parentElement.syncIdMap;
      if (syncIdMap) {
        const index = Object.values(syncIdMap).indexOf(childElement);
        if (index > -1) {
          delete syncIdMap[Object.keys(syncIdMap)[index]];
        }
      }
      parentElement.removeChild(childElement);
    }
  }
  static addChild(parentElement, childElement, syncId) {
    parentElement.appendChild(childElement);
    if (!parentElement.syncIdMap) {
      parentElement.syncIdMap = {};
    }
    parentElement.syncIdMap[syncId] = childElement;
  }
  static getChild(element, path) {
    const syncIds = String(path).split(".");
    for (const id of syncIds) {
      var _element, _element$syncIdMap;
      element = (_element = element) === null || _element === void 0 ? void 0 : (_element$syncIdMap = _element.syncIdMap) === null || _element$syncIdMap === void 0 ? void 0 : _element$syncIdMap[id];
      if (!element) {
        return null;
      }
    }
    return element;
  }
};
DomSync._$name = "DomSync";
var Fullscreen = class {
  static init() {
    const fnNames = ["fullscreenEnabled", "requestFullscreen", "exitFullscreen", "fullscreenElement"], prefixFn = (prefix) => fnNames.map((fn) => {
      let result = prefix + StringHelper.capitalize(fn);
      if (prefix === "moz") {
        result = result.replace("screen", "Screen");
        if ("mozCancelFullScreen" in document && fn === "exitFullscreen") {
          result = "mozCancelFullScreen";
        }
      }
      return result;
    });
    this.functions = "fullscreenEnabled" in document && fnNames || "webkitFullscreenEnabled" in document && prefixFn("webkit") || "mozFullScreenEnabled" in document && prefixFn("moz") || "msFullscreenEnabled" in document && prefixFn("ms") || [];
    const eventNames = ["fullscreenchange", "fullscreenerror"], msEventNames = ["MSFullscreenChange", "MSFullscreenError"], prefixEvt = (prefix) => eventNames.map((eventName) => prefix + StringHelper.capitalize(eventName));
    this.events = "fullscreenEnabled" in document && eventNames || "webkitFullscreenEnabled" in document && prefixEvt("webkit") || "mozFullscreenEnabled" in document && prefixEvt("moz") || "msFullscreenEnabled" in document && msEventNames || [];
  }
  static get enabled() {
    return Boolean(this.functions[0] && document[this.functions[0]]);
  }
  static async request(element) {
    return this.functions[1] && (element === null || element === void 0 ? void 0 : element[this.functions[1]]());
  }
  static async exit() {
    return this.functions[2] && document[this.functions[2]]();
  }
  static get isFullscreen() {
    return !!this.element;
  }
  static get element() {
    return this.functions[3] && document[this.functions[3]];
  }
  static onFullscreenChange(fn) {
    if (this.events[0]) {
      document.addEventListener(this.events[0], fn);
    }
  }
  static unFullscreenChange(fn) {
    if (this.events[0]) {
      document.removeEventListener(this.events[0], fn);
    }
  }
};
Fullscreen.init();
Fullscreen._$name = "Fullscreen";
var resizeFireTimer = null;
var resizedQueue = [];
var isAbsolutelyPositioned = (n) => {
  var _n$ownerDocument$defa;
  return n.nodeType === n.ELEMENT_NODE && ((_n$ownerDocument$defa = n.ownerDocument.defaultView) === null || _n$ownerDocument$defa === void 0 ? void 0 : _n$ownerDocument$defa.getComputedStyle(n).getPropertyValue("position")) === "absolute";
};
var ResizeMonitor = class {
  static addResizeListener(element, handler) {
    const me = this;
    if (element === document || element === globalThis) {
      element = document.body;
    }
    if (element.nodeType === element.DOCUMENT_FRAGMENT_NODE) {
      element = element.host;
    }
    if (!element.classList.contains("b-resize-monitored")) {
      element.classList.add("b-resize-monitored");
      element._bResizemonitor = {
        handlers: []
      };
    }
    if (element === document.body) {
      if (!me.hasWindowResizeListener) {
        globalThis.addEventListener("resize", me.onWindowResize);
        me.hasWindowResizeListener = true;
      }
    } else if (globalThis.ResizeObserver) {
      if (!me.resizeObserver) {
        me.resizeObserver = new ResizeObserver(me.onElementResize);
      }
      me.resizeObserver.observe(element);
    } else {
      element.classList.add("b-no-resizeobserver");
      const [monitors, expand, shrink] = DomHelper.createElement({
        parent: element,
        className: "b-resize-monitors",
        children: [{
          className: "b-resize-monitor-expand"
        }, {
          className: "b-resize-monitor-shrink"
        }]
      }, {
        returnAll: true
      });
      expand.scrollLeft = expand.scrollTop = shrink.scrollLeft = shrink.scrollTop = 1e6;
      expand.addEventListener("scroll", me.onSizeMonitorScroll, true);
      shrink.addEventListener("scroll", me.onSizeMonitorScroll, true);
      (handler.targetMutationMonitor = new MutationObserver((m) => {
        const addedNodes = [], removedNodes = [];
        for (const mr of m) {
          if (mr.type === "childList") {
            addedNodes.push.apply(addedNodes, mr.addedNodes);
            removedNodes.push.apply(removedNodes, mr.removedNodes);
          }
        }
        const changedNodes = [...addedNodes.filter((r) => !removedNodes.includes(r)), ...removedNodes.filter((r) => !addedNodes.includes(r))];
        if (changedNodes.length === 0) {
          return;
        }
        if (changedNodes.length > 0 && changedNodes.every(isAbsolutelyPositioned)) {
          return;
        }
        expand.dispatchEvent(new CustomEvent("scroll", {
          bubbles: false
        }));
      })).observe(element, {
        childList: true,
        subtree: true
      });
      handler.monitorElement = monitors;
    }
    element._bResizemonitor.handlers.push(handler);
  }
  static removeResizeListener(element, handler) {
    if (element) {
      if (element === document || element === globalThis) {
        element = document.body;
      }
      const resizeMonitor = element._bResizemonitor;
      let listenerCount = 0;
      if (resizeMonitor && resizeMonitor.handlers) {
        ArrayHelper.remove(resizeMonitor.handlers, handler);
        listenerCount = resizeMonitor.handlers.length;
      }
      if (!listenerCount) {
        element.classList.remove("b-resize-monitored");
        if (this.resizeObserver) {
          this.resizeObserver.unobserve(element);
        } else {
          if (handler.monitorElement) {
            handler.monitorElement.remove();
            handler.monitorElement = null;
          }
          if (handler.targetMutationMonitor) {
            handler.targetMutationMonitor.disconnect();
          }
        }
      }
    }
  }
  static onElementResize(entries) {
    for (const resizeObserverEntry of entries) {
      const resizedElement = resizeObserverEntry.target, resizeMonitor = resizedElement._bResizemonitor, newRect = resizeObserverEntry.contentRect || resizedElement.getBoundingClientRect();
      if (hasLayout(resizedElement)) {
        if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
          const oldRect = resizeMonitor.rectangle;
          resizeMonitor.rectangle = newRect;
          for (const resizeHandler of resizeMonitor.handlers) {
            resizeHandler(resizedElement, oldRect, newRect);
          }
        }
      }
    }
  }
  static onSizeMonitorScroll(e) {
    var _document$body;
    if ((_document$body = document.body) !== null && _document$body !== void 0 && _document$body.contains(e.target)) {
      e.stopImmediatePropagation();
      const monitorNode = e.target.parentNode, resizedElement = monitorNode.parentNode, resizeMonitor = resizedElement._bResizemonitor, newRect = resizedElement.getBoundingClientRect();
      if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
        resizedQueue.push([resizedElement, resizeMonitor.rectangle, newRect]);
        resizeMonitor.rectangle = newRect;
        if (!resizeFireTimer) {
          resizeFireTimer = requestAnimationFrame(ResizeMonitor.fireResizeEvents);
        }
      }
      monitorNode.firstChild.scrollLeft = monitorNode.firstChild.scrollTop = monitorNode.childNodes[1].scrollTop = monitorNode.childNodes[1].scrollLeft = 1e6;
    }
  }
  static onWindowResize(e) {
    const resizedElement = document.body, resizeMonitor = resizedElement._bResizemonitor, oldRect = resizeMonitor.rectangle;
    resizeMonitor.rectangle = document.documentElement.getBoundingClientRect();
    for (const resizeHandler of resizeMonitor.handlers) {
      resizeHandler(resizedElement, oldRect, resizeMonitor.rectangle);
    }
  }
  static fireResizeEvents() {
    for (const resizedEntry of resizedQueue) {
      for (const resizeHandler of resizedEntry[0]._bResizemonitor.handlers) {
        if (resizedEntry[0].offsetParent) {
          resizeHandler.apply(this, resizedEntry);
        }
      }
    }
    resizeFireTimer = null;
    resizedQueue.length = 0;
  }
  static removeGlobalListeners() {
    globalThis.removeEventListener("resize", this.onWindowResize);
  }
};
ResizeMonitor._$name = "ResizeMonitor";
var scrollLiterals = {
  auto: "auto",
  true: "auto",
  false: "hidden",
  "hidden-scroll": "auto",
  clip: BrowserHelper.supportsOverflowClip ? "clip" : "hidden"
};
var scrollerCls = "b-widget-scroller";
var defaultScrollOptions$2 = {
  block: "nearest"
};
var immediatePromise$3 = Promise.resolve();
var scrollPromise = (element) => new Promise((resolve) => EventHelper.on({
  element: element === document.documentElement ? window : element,
  scroll: resolve,
  once: true
}));
var xAxis$1 = {
  x: 1
};
var isScrollable = {
  auto: 1,
  scroll: 1
};
var isScrollableConfig = {
  true: 1,
  auto: 1
};
var allScroll = {
  overflowX: "auto",
  overflowY: "auto"
};
var normalizeEdgeOffset = (edgeOffset) => {
  let top, bottom, start, end;
  if (!edgeOffset) {
    top = bottom = start = end = 0;
  } else if (typeof edgeOffset === "number") {
    top = bottom = start = end = edgeOffset;
  } else {
    var _edgeOffset$top, _edgeOffset$bottom, _edgeOffset$start, _edgeOffset$end;
    top = (_edgeOffset$top = edgeOffset.top) !== null && _edgeOffset$top !== void 0 ? _edgeOffset$top : 0;
    bottom = (_edgeOffset$bottom = edgeOffset.bottom) !== null && _edgeOffset$bottom !== void 0 ? _edgeOffset$bottom : 0;
    start = (_edgeOffset$start = edgeOffset.start) !== null && _edgeOffset$start !== void 0 ? _edgeOffset$start : 0;
    end = (_edgeOffset$end = edgeOffset.end) !== null && _edgeOffset$end !== void 0 ? _edgeOffset$end : 0;
  }
  return {
    top,
    bottom,
    start,
    end
  };
};
var Scroller = class extends Delayable(Events(Base)) {
  static get configurable() {
    return {
      widget: null,
      element: {
        $config: {
          nullify: true
        },
        value: null
      },
      contentElement: {
        $config: {
          nullify: true
        },
        value: null
      },
      overflowX: null,
      overflowY: null,
      translate: null,
      x: 0,
      y: 0,
      rtlSource: null
    };
  }
  static get delayable() {
    return {
      onScrollEnd: {
        type: "buffer",
        delay: 100
      }
    };
  }
  get isRTL() {
    var _this$rtlSource;
    return Boolean((_this$rtlSource = this.rtlSource) === null || _this$rtlSource === void 0 ? void 0 : _this$rtlSource.rtl);
  }
  syncOverflowState() {
    const me = this, {
      element
    } = me, classList = new DomClassList(element.classList), x = me.hasOverflowX = element.scrollWidth > element.clientWidth, y = me.hasOverflowY = element.scrollHeight > element.clientHeight;
    classList.value = element.classList;
    const changed = classList.toggle("b-horizontal-overflow", x) || classList.toggle("b-vertical-overflow", y);
    if (changed) {
      DomHelper.syncClassList(element, classList);
      if (!me.isConfiguring) {
        me.trigger("overflowChange", {
          x,
          y
        });
      }
    }
  }
  hasOverflow(axis = "y") {
    const overflowSetting = this[`overflow${axis.toUpperCase()}`], otherAxis = this[`overflow${axis === "y" ? "x" : "y"}`];
    if (!DomHelper.scrollBarWidth || !isScrollableConfig[overflowSetting] || otherAxis === "hidden-scroll" || BrowserHelper.isFirefox) {
      const dimension = axis === "y" ? "Height" : "Width";
      return this[`scroll${dimension}`] > this[`client${dimension}`];
    } else {
      return this[`hasOverflow${axis.toUpperCase()}`];
    }
  }
  hasScrollbar(axis = "y") {
    const {
      element
    } = this;
    if (element && DomHelper.scrollBarWidth) {
      const vertical = axis === "y", dimension = vertical ? "Width" : "Height", clientSize = element[`client${dimension}`], borderSize = parseInt(DomHelper.getStyleValue(element, `border${vertical ? "Left" : "Top"}Width`)) + parseInt(DomHelper.getStyleValue(element, `border${vertical ? "Right" : "Bottom"}Width`)), difference = element[`offset${dimension}`] - borderSize - clientSize;
      return Math.abs(difference - DomHelper.scrollBarWidth) < 2;
    }
  }
  addPartner(otherScroller, axes = xAxis$1) {
    const me = this;
    if (typeof axes === "string") {
      axes = {
        [axes]: 1
      };
    }
    if (!me.partners) {
      me.partners = {};
    }
    me.partners[otherScroller.id] = {
      scroller: otherScroller,
      axes
    };
    if (axes.x) {
      otherScroller.x = me.x;
    }
    if (axes.y) {
      otherScroller.y = me.y;
    }
    if (!otherScroller.isPartneredWith(me)) {
      otherScroller.addPartner(me, axes);
    }
  }
  eachPartner(fn) {
    const {
      partners
    } = this;
    if (partners) {
      Object.values(partners).forEach(fn);
    }
  }
  removePartner(otherScroller) {
    if (this.isPartneredWith(otherScroller)) {
      delete this.partners[otherScroller.id];
      otherScroller.removePartner(this);
    }
  }
  isPartneredWith(otherScroller) {
    var _this$partners;
    return Boolean((_this$partners = this.partners) === null || _this$partners === void 0 ? void 0 : _this$partners[otherScroller.id]);
  }
  clearPartners() {
    if (this.partners) {
      Object.values(this.partners).forEach((otherScroller) => otherScroller.scroller.removePartner(this));
    }
  }
  async scrollIntoView(element, options = defaultScrollOptions$2) {
    const me = this, {
      isRectangle
    } = element, originalRect = isRectangle ? element : Rectangle.from(element), {
      xDelta,
      yDelta
    } = me.getDeltaTo(element, options), result = me.scrollBy(xDelta, yDelta, options);
    if (options.highlight || options.focus) {
      result.then(() => {
        if (isRectangle) {
          element = originalRect.translate(-xDelta, -yDelta);
        }
        if (options.highlight) {
          if (isNaN(options.highlight)) {
            (me.widget || me).callback(options.highlight, null, [element]);
          } else {
            DomHelper.highlight(element, me);
          }
        }
        if (options.focus) {
          DomHelper.focusWithoutScrolling(element);
        }
      });
    }
    return result;
  }
  static async scrollIntoView(element, options = defaultScrollOptions$2, rtl = false) {
    const target = Rectangle.from(element), animate = typeof options === "object" ? options.animate : options, scrollable = Scroller._globalScroller || (Scroller._globalScroller = new Scroller()), deltas = [];
    scrollable.rtlSource = {
      rtl
    };
    let totalX = 0, totalY = 0, result;
    for (let ancestor = element.parentNode; ancestor.nodeType === Node.ELEMENT_NODE; ancestor = ancestor.parentNode) {
      if (ancestor === document.body && ancestor !== document.scrollingElement) {
        continue;
      }
      const style = ancestor === document.scrollingElement ? allScroll : ancestor.ownerDocument.defaultView.getComputedStyle(ancestor);
      if (options.y !== false && isScrollable[style.overflowY] && ancestor.scrollHeight > ancestor.clientHeight || options.x !== false && isScrollable[style.overflowX] && ancestor.scrollWidth > ancestor.clientWidth) {
        scrollable.element = ancestor;
        scrollable.positionDirty = true;
        const {
          xDelta,
          yDelta
        } = scrollable.getDeltaTo(target, options);
        if (xDelta || yDelta) {
          deltas.push({
            element: ancestor,
            x: ancestor.scrollLeft,
            y: ancestor.scrollTop,
            xDelta,
            yDelta
          });
          target.translate(-xDelta, -yDelta);
          totalX += xDelta;
          totalY += yDelta;
        }
      }
    }
    if (deltas.length) {
      const absX = Math.abs(totalX), absY = Math.abs(totalY);
      let duration = animate && (typeof animate === "number" ? animate : typeof animate.duration === "number" ? animate.duration : 300);
      if (duration && (absX > 10 || absY > 10)) {
        if (Math.max(absX, absY) < 50) {
          duration = Math.min(duration, 500);
        }
        result = scrollable.scrollAnimation = FunctionHelper.animate(duration, (progress) => {
          const isEnd = progress === 1;
          for (const {
            element: element2,
            x,
            y,
            xDelta,
            yDelta
          } of deltas) {
            scrollable.element = element2;
            if (xDelta) {
              scrollable.x = Math[rtl ? "min" : "max"](x + (isEnd ? xDelta : Math.round(xDelta * progress)), 0);
            }
            if (yDelta) {
              scrollable.y = Math.max(y + (isEnd ? yDelta : Math.round(yDelta * progress)), 0);
            }
          }
        }, null, animate.easing);
        result.then(() => {
          scrollable.scrollAnimation = null;
        });
      } else {
        for (const {
          element: element2,
          xDelta,
          yDelta
        } of deltas) {
          element2.scrollTop += yDelta;
          element2.scrollLeft += xDelta;
        }
        result = scrollPromise(deltas[deltas.length - 1].element);
      }
    } else {
      result = immediatePromise$3;
    }
    if (options.highlight || options.focus) {
      result.then(() => {
        if (options.highlight) {
          if (isNaN(options.highlight)) {
            scrollable.callback(options.highlight, null, [element]);
          } else {
            DomHelper.highlight(element, scrollable);
          }
        }
        if (options.focus) {
          element.focus();
        }
      });
    }
    return result;
  }
  async scrollBy(xDelta = 0, yDelta = 0, options = defaultScrollOptions$2) {
    const me = this, animate = typeof options === "object" ? options.animate : options, absX = Math.abs(xDelta), absY = Math.abs(yDelta);
    if (me.scrollAnimation) {
      me.scrollAnimation.cancel();
      me.scrollAnimation = null;
    }
    if (xDelta || yDelta) {
      me.silent = options.silent;
    }
    let duration = animate && (typeof animate === "number" ? animate : typeof animate.duration === "number" ? animate.duration : 300);
    if (duration && (absX > 10 || absY > 10)) {
      const {
        x,
        y
      } = me;
      let lastX = x, lastY = y;
      if (Math.max(absX, absY) < 50) {
        duration = Math.min(duration, 500);
      }
      me.scrollAnimation = FunctionHelper.animate(duration, (progress) => {
        const isEnd = progress === 1;
        if (xDelta) {
          if (me.x !== lastX && !options.force) {
            var _me$scrollAnimation;
            return (_me$scrollAnimation = me.scrollAnimation) === null || _me$scrollAnimation === void 0 ? void 0 : _me$scrollAnimation.cancel();
          }
          me.x = Math.max(x + (isEnd ? xDelta : Math.round(xDelta * progress)), 0);
        }
        if (yDelta) {
          if (me.y !== lastY && !options.force) {
            var _me$scrollAnimation2;
            return (_me$scrollAnimation2 = me.scrollAnimation) === null || _me$scrollAnimation2 === void 0 ? void 0 : _me$scrollAnimation2.cancel();
          }
          me.y = Math.max(y + (isEnd ? yDelta : Math.round(yDelta * progress)), 0);
        }
        lastX = me.x;
        lastY = me.y;
      }, me, animate.easing);
      me.element.classList.add("b-scrolling");
      me.scrollAnimation.then(() => {
        if (!me.isDestroyed) {
          me.element.classList.remove("b-scrolling");
          me.scrollAnimation = null;
        }
      });
      return me.scrollAnimation;
    } else {
      if (xDelta | yDelta) {
        const xBefore = me.x, yBefore = me.y;
        me.x += xDelta;
        me.y += yDelta;
        if (me.x !== xBefore || me.y !== yBefore) {
          return scrollPromise(me.element);
        }
      }
      return immediatePromise$3;
    }
  }
  async scrollTo(toX, toY, options) {
    const {
      x,
      y
    } = this, xDelta = toX == null ? 0 : toX - x, yDelta = toY == null ? 0 : toY - y;
    return this.scrollBy(xDelta, yDelta, options);
  }
  doDestroy() {
    var _me$scrollAnimation3;
    const me = this;
    if (me._element) {
      var _me$wheelListenerRemo;
      me._element.removeEventListener("scroll", me.scrollHandler);
      (_me$wheelListenerRemo = me.wheelListenerRemover) === null || _me$wheelListenerRemo === void 0 ? void 0 : _me$wheelListenerRemo.call(me);
    }
    (_me$scrollAnimation3 = me.scrollAnimation) === null || _me$scrollAnimation3 === void 0 ? void 0 : _me$scrollAnimation3.cancel();
    Object.values(me.partners || {}).forEach(({
      scroller
    }) => scroller.removePartner(me));
    super.doDestroy();
  }
  onElMutation(mutations) {
    const me = this, [x, y] = DomHelper.getTranslateXY(me.element);
    if (me._x !== -x || me.y !== -y) {
      const scrollEvent = new CustomEvent("scroll", {
        bubbles: true
      });
      Object.defineProperty(scrollEvent, "target", {
        get: () => me.element
      });
      me.onScroll(scrollEvent);
    }
  }
  onElResize() {
    const me = this, {
      widget
    } = me;
    if (!(widget !== null && widget !== void 0 && widget.isAnimating)) {
      me.syncOverflowState();
    } else if (widget.findListener("animationend", "onElResize", me) === -1) {
      widget.ion({
        animationEnd: "onElResize",
        thisObj: me,
        once: true
      });
    }
  }
  onScroll(e) {
    const me = this, {
      _x,
      _y,
      element
    } = me;
    let vetoed = 0;
    if (me.overflowX === "clip" && element.scrollLeft !== _x) {
      element.scrollLeft = _x;
      ++vetoed;
    }
    if (me.overflowY === "clip" && element.scrollTop !== _y) {
      element.scrollTop = _y;
      ++vetoed;
    }
    if (vetoed === 2) {
      return;
    }
    if (!me.widget || !me.widget.isDestroyed) {
      me.positionDirty = true;
      if (!element.classList.contains("b-scrolling")) {
        element.classList.add("b-scrolling");
      }
      e.widget = me.widget;
      if (!me.silent) {
        me.trigger("scroll", e);
      }
      me.syncPartners();
      me.controllingPartner = null;
      me.onScrollEnd(e);
    }
  }
  syncPartners(force, propagate) {
    const me = this;
    if (me.partners) {
      Object.values(me.partners).forEach(({
        axes,
        scroller
      }) => {
        if (scroller !== me.controllingPartner || force) {
          if (scroller.sync(me, axes) && propagate) {
            scroller.syncPartners(force, propagate);
          }
        }
      });
    }
  }
  onScrollEnd(e) {
    const me = this;
    if (me.silent) {
      me.silent = false;
    }
    me.trigger("scrollEnd", e);
    me.controllingPartner = null;
    me.element.classList.remove("b-scrolling");
  }
  getDeltaTo(element, options) {
    const me = this;
    if (!me.viewport) {
      return {
        xDelta: 0,
        yDelta: 0
      };
    }
    const {
      x,
      y,
      scrollWidth,
      scrollHeight,
      isRTL
    } = me, elementRect = element instanceof Rectangle ? element : Rectangle.from(element), block = options.block || "nearest", scrollerRect = me.viewport, edgeOffset = normalizeEdgeOffset(options.edgeOffset), xOffset = scrollerRect.width >= elementRect.width + (edgeOffset.start + edgeOffset.end) ? edgeOffset : {
      start: 0,
      end: 0
    }, yOffset = scrollerRect.height >= elementRect.height + (edgeOffset.top + edgeOffset.bottom) ? edgeOffset : {
      top: 0,
      bottom: 0
    }, constrainTo = new Rectangle(isRTL ? scrollerRect.right - -x - scrollWidth : scrollerRect.x - x, scrollerRect.y - y, scrollWidth, scrollHeight), elRect = elementRect.clone().adjust(-xOffset.start, -yOffset.top, xOffset.end, yOffset.bottom).constrainTo(constrainTo), targetRect = elRect.clone(), xFactor = me.isRTL ? -1 : 1;
    let xDelta = 0, yDelta = 0;
    if (block === "start") {
      targetRect.moveTo(scrollerRect.x + (me.isRTL ? scrollerRect.width : 0), scrollerRect.y);
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    } else if (block === "end") {
      if (me.isRTL) {
        targetRect.moveTo(scrollerRect.left + (me.isRTL ? targetRect.width : 0), scrollerRect.y);
      } else {
        targetRect.translate(scrollerRect.right - targetRect.right, scrollerRect.bottom - targetRect.bottom);
      }
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    } else {
      if (block === "center") {
        const center = scrollerRect.center;
        targetRect.moveTo(center.x - targetRect.width / 2, center.y - targetRect.height / 2);
        xDelta = xDelta || elRect.x - targetRect.x;
        yDelta = yDelta || elRect.y - targetRect.y;
      } else {
        if (targetRect.width > scrollerRect.width) {
          xDelta = targetRect.x - scrollerRect.x;
        } else {
          if (targetRect.right > scrollerRect.right) {
            xDelta = targetRect.right - scrollerRect.right;
          } else if (targetRect.x < scrollerRect.x) {
            xDelta = targetRect.x - scrollerRect.x;
          }
        }
        if (targetRect.height > scrollerRect.height) {
          yDelta = targetRect.y - scrollerRect.y;
        } else {
          if (targetRect.bottom > scrollerRect.bottom) {
            yDelta = targetRect.bottom - scrollerRect.bottom;
          } else if (targetRect.y < scrollerRect.y) {
            yDelta = targetRect.y - scrollerRect.y;
          }
        }
      }
    }
    xDelta = xFactor * Math.round(xDelta);
    yDelta = Math.round(yDelta);
    return {
      xDelta: options.x === false ? 0 : Math.max(Math.min(xDelta, me.maxX - x), -x),
      yDelta: options.y === false ? 0 : Math.max(Math.min(yDelta, me.maxY - y), -y)
    };
  }
  get viewport() {
    return Rectangle.client(this.element);
  }
  updateWidget(widget) {
    this.rtlSource = this.owner = widget;
  }
  updateElement(element, oldElement) {
    const me = this;
    if (me === Scroller._globalScroller) {
      me._element = element;
      me.positionDirty = true;
      return;
    }
    const scrollHandler = me.scrollHandler || (me.scrollHandler = me.onScroll.bind(me)), resizeHandler = me.resizeHandler || (me.resizeHandler = me.onElResize.bind(me));
    if (oldElement) {
      if (me.translate) {
        var _me$mutationObserver;
        (_me$mutationObserver = me.mutationObserver) === null || _me$mutationObserver === void 0 ? void 0 : _me$mutationObserver.disconnect(oldElement);
      } else {
        oldElement.removeEventListener("scroll", scrollHandler);
        oldElement.classList.remove(scrollerCls);
        oldElement.style.overflowX = oldElement.style.overflowY = "";
      }
      ResizeMonitor.removeResizeListener(oldElement, resizeHandler);
    }
    if (element) {
      if (me.translate) {
        if (!me.mutationObserver) {
          me.mutationObserver = new MutationObserver(me.mutationHandler || (me.mutationHandler = me.onElMutation.bind(me)));
        }
        me._x = me._y = 0;
        if (document.contains(element)) {
          const [x, y] = DomHelper.getTranslateXY(element);
          me._x = -x;
          me._y = -y;
        }
        me.mutationObserver.observe(element, {
          attributes: true
        });
      } else {
        element.addEventListener("scroll", scrollHandler);
        element.classList.add(scrollerCls);
      }
      ResizeMonitor.addResizeListener(element, resizeHandler);
      if (!me.widget) {
        me.rtlSource = {
          get rtl() {
            return DomHelper.getStyleValue(element, "direction") === "rtl";
          }
        };
      }
      if (me.isRTL) {
        element.classList.add("b-rtl");
      }
      if (me.positionDirty) {
        me.updateOverflowX(me.overflowX);
        me.updateOverflowY(me.overflowY);
      }
      me.syncOverflowState();
      if (me.isConfiguring) {
        me._x && me.updateX(me._x);
        me._y && me.updateY(me._y);
      }
    }
    me.positionDirty = true;
  }
  get x() {
    const me = this, {
      element
    } = me;
    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        me._x = Math.abs(element.scrollLeft);
        me._y = element.scrollTop;
      }
      me.positionDirty = false;
    }
    return me._x;
  }
  get scrollLeft() {
    return this.element.scrollLeft;
  }
  changeX(x) {
    x = Math.max(x, 0);
    if (!this.isConfiguring || x) {
      return x;
    }
    this._x = x;
  }
  updateContentElement(contentElement) {
    if (contentElement) {
      contentElement = typeof contentElement === "string" ? this.element.querySelector(contentElement) : contentElement;
      ResizeMonitor.addResizeListener(contentElement, this.resizeHandler);
    }
  }
  updateX(x) {
    var _this$widget;
    const {
      element
    } = this;
    if (element && !((_this$widget = this.widget) !== null && _this$widget !== void 0 && _this$widget.isConfiguring)) {
      x = Math.round(x);
      this.trigger("scrollStart", {
        x
      });
      if (this.translate) {
        DomHelper.setTranslateX(element, -x);
      } else {
        element.scrollLeft = this.isRTL ? -x : x;
      }
    }
    this.positionDirty = true;
  }
  sync(controllingPartner, axes) {
    const me = this, {
      x,
      y
    } = axes;
    let result = false;
    if (x != null) {
      if (me.x !== controllingPartner.x) {
        me.controllingPartner = controllingPartner;
        me.x = controllingPartner.x;
        result = true;
      }
    }
    if (y != null) {
      if (me.y !== controllingPartner.y) {
        me.controllingPartner = controllingPartner;
        me.y = controllingPartner.y;
        result = true;
      }
    }
    return result;
  }
  get y() {
    const me = this, {
      element
    } = me;
    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        me._x = element.scrollLeft;
        me._y = element.scrollTop;
      }
      me.positionDirty = false;
    }
    return me._y;
  }
  changeY(y) {
    if (!this.isConfiguring || y) {
      return y;
    }
    this._y = y;
  }
  updateY(y) {
    const {
      element,
      widget
    } = this;
    if (element && !(widget !== null && widget !== void 0 && widget.isConfiguring)) {
      this.trigger("scrollStart", {
        y
      });
      if (this.translate) {
        DomHelper.setTranslateY(element, -y);
      } else {
        element.scrollTop = y;
      }
    }
    this.positionDirty = true;
  }
  get maxX() {
    return this.scrollWidth - this.clientWidth;
  }
  get maxY() {
    return this.scrollHeight - this.clientHeight;
  }
  get lastScrollLeft() {
    return (this.scrollWidth - this.clientWidth) * (this.isRTL ? -1 : 1);
  }
  updateOverflowX(overflowX, oldOverflowX) {
    const me = this, {
      element,
      translate
    } = me, {
      style,
      classList
    } = element;
    if (oldOverflowX === "hidden-scroll") {
      classList.remove("b-hide-scroll");
    }
    if (overflowX === "hidden-scroll" && !translate) {
      const otherAxisScrollable = isScrollable[style.overflowY];
      if (otherAxisScrollable) {
        overflowX = "hidden";
        me.enableWheel();
      } else {
        classList.add("b-hide-scroll");
      }
    }
    if (!translate) {
      style.overflowX = scrollLiterals[overflowX] || overflowX;
    }
    if (!me.isConfiguring) {
      me.positionDirty = true;
      me.syncOverflowState();
    }
  }
  updateOverflowY(overflowY, oldOverflowY) {
    const me = this, {
      element,
      translate
    } = me, {
      style,
      classList
    } = element;
    if (oldOverflowY === "hidden-scroll") {
      classList.remove("b-hide-scroll");
    }
    if (overflowY === "hidden-scroll" && !translate) {
      const otherAxisScrollable = isScrollable[style.overflowX];
      if (otherAxisScrollable) {
        overflowY = "hidden";
        me.enableWheel();
      } else {
        classList.add("b-hide-scroll");
      }
    }
    if (!translate) {
      style.overflowY = scrollLiterals[overflowY] || overflowY;
    }
    if (!me.isConfiguring) {
      me.positionDirty = true;
      me.syncOverflowState();
    }
  }
  enableWheel() {
    if (!this.wheelListenerRemover) {
      this.wheelListenerRemover = EventHelper.on({
        element: this.element,
        wheel: "onWheel",
        thisObj: this
      });
    }
  }
  onWheel(e) {
    if (Math.abs(e.deltaX) > Math.abs(e.deltaY) && this.overflowX === "hidden-scroll") {
      this.x += e.deltaX;
    } else if (this.overflowY === "hidden-scroll") {
      this.y += e.deltaY;
    }
  }
  get scrollWidth() {
    var _this$element$scrollW, _this$element;
    return (_this$element$scrollW = (_this$element = this.element) === null || _this$element === void 0 ? void 0 : _this$element.scrollWidth) !== null && _this$element$scrollW !== void 0 ? _this$element$scrollW : 0;
  }
  set scrollWidth(scrollWidth) {
    const me = this, {
      element,
      isRTL
    } = me;
    let stretcher = me.widthStretcher;
    if (stretcher && scrollWidth == null) {
      stretcher.remove();
      me.widthStretcher = null;
    } else if (scrollWidth) {
      scrollWidth = Math.abs(scrollWidth);
      if (!stretcher) {
        stretcher = me.widthStretcher = DomHelper.createElement({
          className: "b-scroller-stretcher b-horizontal-stretcher",
          retainElement: true
        });
      }
      stretcher.style.transform = `translateX(${(scrollWidth - 1) * (isRTL ? -1 : 1)}px)`;
      if (element && !element.contains(stretcher)) {
        element.insertBefore(stretcher, element.firstElementChild);
      }
    }
    if (me.propagate !== false) {
      me.eachPartner(({
        scroller
      }) => {
        scroller.propagate = false;
        scroller.scrollWidth = scrollWidth;
        delete scroller.propagate;
      });
    }
    me.positionDirty = true;
    me.syncOverflowState();
  }
  get scrollHeight() {
    var _this$element$scrollH, _this$element2;
    return (_this$element$scrollH = (_this$element2 = this.element) === null || _this$element2 === void 0 ? void 0 : _this$element2.scrollHeight) !== null && _this$element$scrollH !== void 0 ? _this$element$scrollH : 0;
  }
  set scrollHeight(scrollHeight) {
    const me = this, stretcher = me.stretcher || (me.stretcher = DomHelper.createElement({
      className: "b-scroller-stretcher"
    }));
    stretcher.style.transform = `translateY(${scrollHeight - 1}px)`;
    if (me.element && me.element.lastChild !== stretcher) {
      me.element.appendChild(stretcher);
    }
    me.positionDirty = true;
    me.syncOverflowState();
  }
  get clientWidth() {
    var _this$element3;
    return ((_this$element3 = this.element) === null || _this$element3 === void 0 ? void 0 : _this$element3.clientWidth) || 0;
  }
  get clientHeight() {
    var _this$element4;
    return ((_this$element4 = this.element) === null || _this$element4 === void 0 ? void 0 : _this$element4.clientHeight) || 0;
  }
  get id() {
    if (!this._id) {
      if (this.widget) {
        this._id = `${this.widget.id}-scroller`;
      } else {
        this._id = IdHelper.generateId("scroller-");
      }
    }
    return this._id;
  }
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs();
    delete configs.widget;
    delete configs.element;
  }
};
Scroller._$name = "Scroller";
var Promissory = class {
  constructor(fn) {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
    if (fn) {
      fn(this);
    }
  }
};
Promissory._$name = "Promissory";
var {
  defineProperty: defineProperty$2
} = Reflect;
var Renderable = class extends Base.mixin(Localizable, Events, Delayable, Identifiable) {
  static get configurable() {
    return {
      element: null
    };
  }
  static get delayable() {
    return {
      refreshDom: "raf"
    };
  }
  static get identifiable() {
    return {};
  }
  static get renderConfigs() {
    const me = this, meta = me.$meta;
    let renderConfigs = meta.renderConfigs, configs, name;
    if (renderConfigs === void 0) {
      renderConfigs = null;
      configs = meta.configs;
      for (name in configs) {
        if (configs[name].render) {
          (renderConfigs || (renderConfigs = /* @__PURE__ */ new Set())).add(name);
        }
      }
      meta.renderConfigs = me.prototype.$renderConfigs = renderConfigs;
    }
    return renderConfigs;
  }
  construct(...args) {
    this.$iid = ++Renderable.$idSeed;
    this.byRef = {};
    super.construct(...args);
    if (this.onDraw !== Renderable.prototype.onDraw) {
      this.initDrawable();
    }
  }
  startConfigure(config) {
    this.element = this.renderContext.renderDom();
    super.startConfigure(config);
  }
  get element() {
    this.refreshDom.flush();
    return this._element;
  }
  changeElement(element, oldElement) {
    const me = this;
    if (oldElement) {
      oldElement.remove();
    }
    if (element) {
      element.id = me.id;
      element = DomHelper.createElement(element, {
        refOwner: me
      });
    }
    return element;
  }
  updateId(id, oldId) {
    const me = this;
    if (oldId) {
      const element = me.element;
      element.id = id;
      me.fixRefOwnerId(element, id, oldId);
    }
  }
  get classes() {
    return this.element.classList;
  }
  fixRefOwnerId(el, id, oldId) {
    if (el.$refOwnerId === oldId) {
      el.$refOwnerId = id;
      const ref = el.$reference;
      if (ref) {
        el.id = `${id}-${ref}`;
      }
      for (const c of el.childNodes) {
        this.fixRefOwnerId(c, id, oldId);
      }
    }
  }
  onConfigChange({
    name
  }) {
    if (!this.isConfiguring && this.$renderConfigs.has(name)) {
      this.refreshDom();
    }
  }
  attachRef(name, el, domConfig) {
    const me = this, key = "_" + name, {
      listeners
    } = domConfig;
    if (!(key in me)) {
      defineProperty$2(me, name, {
        get() {
          me.refreshDom.flush();
          return me[key];
        },
        set(el2) {
          me[key] = el2;
        }
      });
    }
    el.id = `${me.id}-${name}`;
    me.byRef[name] = el;
    me[name] = el;
    if (listeners) {
      domConfig.listeners = {
        on: listeners,
        un: EventHelper.on(Object.assign({
          element: el,
          thisObj: me
        }, listeners))
      };
    }
  }
  detachRef(name, el, domConfig) {
    if (domConfig.listeners) {
      domConfig.listeners.un();
      domConfig.listeners = null;
    }
    this[name] = null;
    delete this.byRef[name];
  }
  renderDom() {
    return {};
  }
  get renderContext() {
    const me = this, meta = me.$meta, C = me.constructor;
    let renderConfigs = meta.renderConfigs || C.renderConfigs, context = me;
    if (!renderConfigs) {
      context = Object.create(me);
      renderConfigs = /* @__PURE__ */ new Set();
      for (const name in meta.configs) {
        defineProperty$2(context, name, {
          get() {
            renderConfigs.add(name);
            return me[name];
          }
        });
      }
      context.renderDom = () => {
        return me.renderDom.call(context);
      };
      me.$renderConfigs = renderConfigs;
    }
    defineProperty$2(me, "renderContext", {
      value: context
    });
    return context;
  }
  refreshDom() {
    DomSync.sync({
      targetElement: this.element,
      domConfig: this.renderContext.renderDom(),
      refOwner: this,
      strict: true
    });
  }
  onListen(eventName) {
    if (eventName === "draw") {
      this.initDrawable();
    }
  }
  initDrawable() {
    const me = this;
    if (!me.intersector) {
      let el = Object.values(me.byRef).find((el2) => el2.classList.contains("b-drawable"));
      if (!el) {
        el = me.element;
        el.classList.add("b-drawable");
      }
      me.intersector = new IntersectionObserver((entries) => {
        if (!me.isDestroyed) {
          entries.forEach((ent) => {
            if (ent.isIntersecting) {
              me.onDraw({
                count: ++me.drawCounter
              });
            }
          });
        }
      });
      me.intersector.observe(el);
    }
  }
  onDraw(ev) {
    this.trigger("draw", ev);
  }
};
Renderable.$idSeed = 0;
Object.assign(Renderable.prototype, {
  drawCounter: 0,
  hasGeneratedId: false,
  intersector: null
});
Renderable._$name = "Renderable";
var Mask = class extends Renderable {
  construct(config) {
    if (config) {
      let el = config.element, cfg;
      if (el) {
        VersionHelper.deprecate("Core", "4.0.0", 'Mask "element" config has been renamed to "target"');
        config = cfg = Object.assign({}, config);
        delete cfg.element;
        cfg.target = el;
      }
      el = config.target;
      if (typeof el === "string") {
        config = cfg = cfg || Object.assign({}, config);
        cfg.target = config.owner[el];
      }
    }
    super.construct(config);
    const me = this, {
      type
    } = me;
    if (!me.target) {
      me.target = document.body;
    }
    me.maskName = `mask${typeof type === "string" ? type.trim() : ""}-${Mask.counter++}`;
    me.show();
  }
  doDestroy() {
    const me = this, {
      element
    } = me;
    if (me.type === "trial") {
      return false;
    }
    if (element) {
      me.element = null;
      if (me.mode.endsWith("blur")) {
        DomHelper.forEachChild(element, (child) => {
          child.classList.remove(`b-masked-${me.mode}`);
        });
      }
      me.target.classList.remove("b-masked");
      me.target[me.maskName] = null;
      ArrayHelper.remove(Mask.masks, me);
    }
    super.doDestroy();
  }
  get maskElement() {
    return this.element;
  }
  set error(value) {
    this.setConfig(this.errorDefaults);
    this.text = value;
  }
  renderDom() {
    const me = this, {
      maxProgress
    } = me;
    return {
      class: {
        "b-mask": 1,
        "b-delayed-show": me.showDelay,
        "b-widget": 1,
        [`b-mask-${me.mode}`]: 1,
        "b-progress": maxProgress,
        "b-prevent-transitions": !me.useTransition
      },
      children: [{
        reference: "maskContent",
        class: "b-mask-content b-drawable",
        children: [maxProgress ? {
          reference: "progressElement",
          class: "b-mask-progress-bar",
          style: {
            width: `${Math.max(0, Math.min(100, Math.round(me.progress / maxProgress * 100)))}%`
          }
        } : null, {
          reference: "maskText",
          class: "b-mask-text",
          html: (me.icon ? `<i class="b-mask-icon ${me.icon}"></i>` : "") + me.text
        }]
      }]
    };
  }
  static mergeConfigs(...sources) {
    const ret = {};
    for (const src of sources) {
      if (typeof src === "string") {
        ret.text = src;
      } else {
        ObjectHelper.assign(ret, src);
      }
    }
    return ret;
  }
  static mask(text, target = document.body) {
    return Mask.new({
      target
    }, typeof text !== "string" ? _objectSpread2({}, text) : {
      text
    });
  }
  static unmask(element = document.body) {
    const masks = this.getElementMasks(element);
    if (masks.length > 0) {
      return masks[masks.length - 1].close();
    }
    return null;
  }
  static unmaskAll(element = document.body) {
    return this.getElementMasks(element).forEach((mask) => mask.close());
  }
  static getElementMasks(element) {
    return this.masks.filter((mask) => mask.target === element);
  }
  updateAutoClose(delay) {
    this.deferredClose.cancel();
    if (delay) {
      this.deferredClose.delay = delay;
      this.deferredClose();
    }
  }
  updateCover() {
    this.syncCover();
  }
  syncCover() {
    var _this$owner, _this$owner$syncMaskC;
    (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : (_this$owner$syncMaskC = _this$owner.syncMaskCover) === null || _this$owner$syncMaskC === void 0 ? void 0 : _this$owner$syncMaskC.call(_this$owner, this);
  }
  onOwnerResize() {
    this.syncCover();
  }
  updateOwner(owner) {
    this.detachListeners("cover");
    owner === null || owner === void 0 ? void 0 : owner.ion({
      name: "cover",
      recompose: "onOwnerResize",
      resize: "onOwnerResize",
      thisObj: this
    });
  }
  updateShowDelay(delay) {
    const {
      delayedShow
    } = this;
    delayedShow.delay = delay;
    if (!delay) {
      delayedShow.flush();
    }
  }
  deferredClose() {
    var _owner$onMaskAutoClos2;
    const {
      owner
    } = this;
    this.close().then(() => {
      var _owner$onMaskAutoClos;
      owner === null || owner === void 0 ? void 0 : (_owner$onMaskAutoClos = owner.onMaskAutoClose) === null || _owner$onMaskAutoClos === void 0 ? void 0 : _owner$onMaskAutoClos.call(owner, this);
    });
    owner === null || owner === void 0 ? void 0 : (_owner$onMaskAutoClos2 = owner.onMaskAutoClosing) === null || _owner$onMaskAutoClos2 === void 0 ? void 0 : _owner$onMaskAutoClos2.call(owner, this);
  }
  delayedShow() {
    this.classes.remove("b-delayed-show");
  }
  show() {
    const me = this, {
      element,
      target,
      hiding,
      maskName
    } = me;
    if (hiding) {
      hiding.resolve();
      me.hiding = null;
      me.clearTimeout("hide");
    }
    if (me.showDelay) {
      element.classList.add("b-delayed-show");
      me.delayedShow();
    }
    element.classList.add("b-visible");
    element.classList.remove("b-hidden");
    target.classList.add("b-masked");
    if (!target[maskName]) {
      target[maskName] = me;
      target.appendChild(element);
    }
    ArrayHelper.include(Mask.masks, me);
    me.shown = true;
    me.trigger("show");
    if (me.mode.endsWith("blur")) {
      DomHelper.forEachChild(target, (child) => {
        if (child !== element) {
          child.classList.add(`b-masked-${me.mode}`);
        }
      });
    }
  }
  hide() {
    const me = this, {
      target,
      element
    } = me;
    let {
      hiding
    } = me;
    if (!hiding) {
      if (!me.shown) {
        return Promise.resolve();
      }
      me.hiding = hiding = new Promissory();
      me.shown = false;
      element.classList.remove("b-visible");
      element.classList.add("b-hidden");
      target.classList.remove("b-masked");
      if (me.mode.endsWith("blur")) {
        DomHelper.forEachChild(target, (child) => {
          if (child !== element) {
            child.classList.remove(`b-masked-${me.mode}`);
          }
        });
      }
      hiding.promise = hiding.promise.then(() => {
        if (me.hiding === hiding) {
          me.hiding = null;
        }
      });
      me.setTimeout(() => hiding.resolve(), 500, "hide");
    }
    return hiding.promise;
  }
  async close() {
    await this.hide();
    this.destroy();
  }
};
_defineProperty(Mask, "$name", "Mask");
_defineProperty(Mask, "type", "mask");
_defineProperty(Mask, "configurable", {
  autoClose: null,
  cover: null,
  icon: "b-icon b-icon-spinner",
  errorDefaults: {
    icon: "b-icon b-icon-warning",
    autoClose: 3e3,
    showDelay: 0
  },
  maxProgress: null,
  mode: "dark",
  progress: null,
  owner: {
    $config: "nullify",
    value: null
  },
  target: null,
  text: null,
  type: null,
  showDelay: null,
  useTransition: false
});
_defineProperty(Mask, "delayable", {
  deferredClose: 0,
  delayedShow: 0,
  syncCover: {
    type: "throttle",
    delay: 100
  }
});
_defineProperty(Mask, "counter", 0);
_defineProperty(Mask, "masks", []);
Mask._$name = "Mask";
var KeyMap = (Target) => {
  var _class;
  return _class = class KeyMap extends (Target || Base) {
    get widgetClass() {
    }
    get keyMapElement() {
      return this.element;
    }
    get keyMapSubComponents() {
      return this.features;
    }
    performKeyMapAction(keyEvent) {
      const {
        keyMap
      } = this;
      let actionHandled = false;
      if (keyMap && !keyEvent.handled && keyEvent.key !== void 0) {
        const keyCombination = ObjectHelper.keys(keyMap).find((keyString) => {
          const keys = keyString.split("+"), requireAlt = keys.includes("Alt"), requireShift = keys.includes("Shift"), requireCtrl = keys.includes("Ctrl");
          let actualKey = keys[keys.length - 1].toLowerCase();
          if (actualKey === "space") {
            actualKey = " ";
          }
          return actualKey === keyEvent.key.toLowerCase() && (!keyEvent.altKey && !requireAlt || keyEvent.altKey && requireAlt) && (!keyEvent.ctrlKey && !requireCtrl || keyEvent.ctrlKey && requireCtrl) && (!keyEvent.shiftKey && !requireShift || keyEvent.shiftKey && requireShift);
        });
        if (keyMap[keyCombination]) {
          const actions = ArrayHelper.asArray(keyMap[keyCombination]);
          keyEvent.fromKeyMap = true;
          let preventDefault;
          for (let action of actions) {
            preventDefault = true;
            if (ObjectHelper.isObject(action)) {
              if (!action.handler) {
                continue;
              }
              if (action.preventDefault === false) {
                preventDefault = false;
              }
              action = action.handler;
            }
            if (typeof action === "string") {
              var _thisObj$isActionAvai;
              const {
                thisObj,
                handler
              } = this.resolveKeyMapAction(action);
              if (((_thisObj$isActionAvai = thisObj.isActionAvailable) === null || _thisObj$isActionAvai === void 0 ? void 0 : _thisObj$isActionAvai.call(thisObj, keyCombination, action, keyEvent)) !== false) {
                if (handler.call(thisObj, keyEvent) !== false) {
                  actionHandled = true;
                  break;
                }
              }
            } else if (action.call(this) !== false) {
              actionHandled = true;
              break;
            }
          }
          delete keyEvent.fromKeyMap;
          if (actionHandled) {
            if (preventDefault) {
              keyEvent.preventDefault();
            }
            keyEvent.handled = true;
          }
        }
      }
      return actionHandled;
    }
    resolveKeyMapAction(action) {
      const {
        keyMapSubComponents
      } = this;
      if (keyMapSubComponents && action.includes(".")) {
        const [component, actionName] = action.split(".");
        if (component && actionName) {
          return {
            thisObj: keyMapSubComponents[component],
            handler: keyMapSubComponents[component][actionName]
          };
        }
      }
      return {
        thisObj: this,
        handler: this[action]
      };
    }
    updateKeyMap(keyMap) {
      var _this$keyMapDetacher;
      (_this$keyMapDetacher = this.keyMapDetacher) === null || _this$keyMapDetacher === void 0 ? void 0 : _this$keyMapDetacher.call(this);
      if (!ObjectHelper.isEmpty(keyMap)) {
        this.keyMapDetacher = EventHelper.on({
          element: this.keyMapElement,
          keydown: "keyMapOnKeyDown",
          thisObj: this
        });
      }
    }
    keyMapOnKeyDown(event) {
      this.performKeyMapAction(event);
    }
    mergeKeyMaps(target, source, subPrefix = null) {
      const mergedKeyMap = {};
      if (target) {
        ObjectHelper.assign(mergedKeyMap, target);
      }
      for (const key in source) {
        if (!source[key]) {
          continue;
        }
        const existingActions = ArrayHelper.asArray(target === null || target === void 0 ? void 0 : target[key]), actions = [];
        if (existingActions !== null && existingActions !== void 0 && existingActions.length) {
          actions.push(...existingActions);
        }
        for (const action of ArrayHelper.asArray(source[key])) {
          if (ObjectHelper.isObject(action) && action.handler) {
            actions.push(ObjectHelper.assignIf({
              handler: (subPrefix ? subPrefix + "." : "") + action.handler
            }, action));
          } else {
            actions.push((subPrefix ? subPrefix + "." : "") + action);
          }
        }
        actions.sort((a, b) => {
          const weight = (a.weight || 0) - (b.weight || 0);
          if (weight === 0 && existingActions !== null && existingActions !== void 0 && existingActions.length) {
            return existingActions.indexOf(a) - existingActions.indexOf(b);
          }
          return weight;
        });
        mergedKeyMap[key] = actions;
      }
      return mergedKeyMap;
    }
  }, _defineProperty(_class, "$name", "KeyMap"), _defineProperty(_class, "configurable", {
    keyMap: {
      value: null,
      $config: {
        merge: "objects",
        nullify: true
      }
    }
  }), _class;
};
var RTL = (Target) => {
  var _class;
  return _class = class RTL extends (Target || Base) {
    get widgetClass() {
    }
    updateRtl(rtl) {
      const {
        element
      } = this;
      if (element) {
        element.classList.toggle("b-rtl", rtl === true);
        element.classList.toggle("b-ltr", rtl === false);
      }
    }
    startConfigure(config) {
      var _super$startConfigure;
      (_super$startConfigure = super.startConfigure) === null || _super$startConfigure === void 0 ? void 0 : _super$startConfigure.call(this, arguments);
      if (!config.floating && config.rtl == null) {
        var _me$parent;
        const me = this, el = config.rootElement || config.forElement || ((_me$parent = me.parent) === null || _me$parent === void 0 ? void 0 : _me$parent.contentElement) || (me.floating ? me.floatRoot : me.changeElementRef(me.getRenderContext(config)[0] || config.adopt || document.body)), owner = config.owner || config.parent || me.constructor.fromElement(el);
        if (owner) {
          config.rtl = owner[owner.isConfiguring ? "peekConfig" : "getConfig"]("rtl");
        } else {
          config.rtl = (el === null || el === void 0 ? void 0 : el.nodeType) === 1 && getComputedStyle(el).getPropertyValue("direction") === "rtl";
        }
        if (config.rtl) {
          me.configDone.rtl = false;
        }
      }
    }
    render(...args) {
      var _this$owner;
      super.render && super.render(...args);
      if (BrowserHelper.isChrome && BrowserHelper.chromeVersion < 87 || BrowserHelper.isFirefox && BrowserHelper.firefoxVersion < 66 || BrowserHelper.isSafari && BrowserHelper.safariVersion < 14.1) {
        this.element.classList.add("b-legacy-inset");
      }
      if (getComputedStyle(this.element).direction === "rtl" || (_this$owner = this.owner) !== null && _this$owner !== void 0 && _this$owner.rtl) {
        var _this$childItems;
        this.rtl = true;
        (_this$childItems = this.childItems) === null || _this$childItems === void 0 ? void 0 : _this$childItems.forEach((i) => i.rtl = true);
      }
    }
  }, _defineProperty(_class, "$name", "RTL"), _defineProperty(_class, "configurable", {
    rtl: null
  }), _class;
};
var assignValueDefaults = Object.freeze({
  highlight: false,
  onlyName: false
});
var floatRoots = [];
var highlightExternalChange = "highlightExternalChange";
var isTransparent = /transparent|rgba\(0,\s*0,\s*0,\s*0\)/;
var textInputTypes = {
  INPUT: 1,
  TEXTAREA: 1
};
var addElementListeners = (me, element, domConfig, refName) => {
  var _listeners;
  let listeners = (domConfig === null || domConfig === void 0 ? void 0 : domConfig.listeners) || (domConfig === null || domConfig === void 0 ? void 0 : domConfig.internalListeners);
  listeners = ((_listeners = listeners) === null || _listeners === void 0 ? void 0 : _listeners.ion) || listeners;
  if (listeners) {
    const un = EventHelper.on(ObjectHelper.assign({
      element,
      thisObj: me
    }, listeners));
    if (refName) {
      (me._refListeners || (me._refListeners = /* @__PURE__ */ Object.create(null)))[refName] = un;
    } else {
      domConfig.listeners = {
        on: listeners,
        un
      };
    }
  }
};
var mergeAnim = (value, was) => {
  return value && was && was[ObjectHelper.keys(value)[0]] ? Config.merge(value, was) : value;
};
var widgetTriggerPaint = (w) => {
  w.isVisible && w.triggerPaint();
};
var negationPseudo = /^:not\((.+)\)$/;
var nonFlowedPositions = /absolute|fixed/i;
var isScaled = (w) => w.scale != null;
var {
  hasOwnProperty: hasOwnProperty$2
} = Object.prototype;
var {
  defineProperty: defineProperty$1
} = Reflect;
var parseDuration = (d) => parseFloat(d) * (d.endsWith("ms") ? 1 : 1e3);
var alignedClass = ["b-aligned-above", "b-aligned-right", "b-aligned-below", "b-aligned-left"];
var returnFalseProp = {
  configurable: true,
  get() {
    return false;
  }
};
var localizeRE = /(?:L\{([^}.]+)\})/;
var localizeTooltip = (string2, part) => "L{Tooltip." + part + "}";
var alignSpecRe = /^([trblc])(\d*)-([trblc])(\d*)$/i;
var mergeAlign = (oldValue, newValue) => {
  if (alignSpecRe.test(oldValue)) {
    oldValue = {
      align: oldValue
    };
  }
  if (alignSpecRe.test(newValue)) {
    newValue = {
      align: newValue
    };
  }
  return Config.merge(oldValue, newValue);
};
var callbackRe = /^[\w.]+$/;
var Widget = class extends Base.mixin(Localizable, Events, Delayable, Identifiable, Factoryable, KeyMap, RTL) {
  static mergeCls(newValue, oldValue) {
    if (oldValue && newValue) {
      newValue = new DomClassList(oldValue).assign(typeof newValue === "string" ? new DomClassList(newValue) : newValue);
    } else if (newValue && !newValue.isDomClassList) {
      newValue = new DomClassList(newValue);
    }
    return newValue;
  }
  static get $name() {
    return "Widget";
  }
  static get type() {
    return "widget";
  }
  static get configurable() {
    return {
      element: true,
      callOnFunctions: true,
      id: "",
      html: null,
      content: null,
      cls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      ui: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      collapsify: null,
      contentElementCls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      defaultCls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      dock: null,
      forwardTwinEvents: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      parent: null,
      tab: null,
      elementAttributes: null,
      htmlCls: {
        $config: {
          merge: "classList"
        },
        value: {
          "b-html": 1
        }
      },
      style: null,
      disabled: null,
      readOnly: {
        value: null,
        default: false,
        $config: null
      },
      ignoreParentReadOnly: null,
      adopt: null,
      appendTo: null,
      insertBefore: null,
      insertFirst: null,
      dataset: null,
      tooltip: {
        $config: ["lazy", "nullify"],
        value: null
      },
      showTooltipWhenDisabled: true,
      preventTooltipOnTouch: null,
      monitorResize: {
        $config: ["lazy", "nullify"],
        value: null
      },
      masked: {
        $config: "nullify",
        value: null
      },
      maskDefaults: {
        target: "element"
      },
      cache: {},
      floating: null,
      positioned: null,
      draggable: null,
      align: {
        $config: {
          merge: mergeAlign
        },
        value: "t-b"
      },
      centered: null,
      constrainTo: void 0,
      anchor: null,
      owner: null,
      scrollAction: null,
      hideAnimation: {
        $config: {
          merge: mergeAnim
        },
        value: null
      },
      showAnimation: {
        $config: {
          merge: mergeAnim
        },
        value: null
      },
      x: null,
      y: null,
      scrollable: {
        $config: ["lazy", "nullify"],
        value: null
      },
      scrollerClass: Scroller,
      defaultBindProperty: "html",
      defaultAction: null,
      overflowable: {
        value: null,
        default: true,
        $config: null
      },
      width: null,
      height: null,
      maxHeight: null,
      maxWidth: null,
      minWidth: null,
      minHeight: null,
      scaleToFitWidth: null,
      allowGrowWidth: true,
      margin: null,
      flex: null,
      weight: null,
      alignSelf: null,
      ripple: null,
      title: null,
      localizableProperties: ["title", "ariaLabel", "ariaDescription"],
      requireSize: false,
      ref: null,
      hidden: null,
      textAlign: null,
      ignoreScrollDuration: 500,
      tag: "div",
      recomposeAsync: null,
      rootElement: null,
      htmlMutationObserver: {
        $config: ["lazy", "nullify"],
        value: {
          childList: true,
          subtree: true
        }
      },
      role: {
        $config: "lazy",
        value: "presentation"
      },
      ariaLabel: {
        $config: "lazy",
        value: null
      },
      ariaDescription: {
        $config: "lazy",
        value: null
      },
      ariaElement: "element",
      ariaHasPopup: null,
      realignTimeout: 300,
      testConfig: {
        ignoreScrollDuration: 100,
        realignTimeout: 50
      }
    };
  }
  static get prototypeProperties() {
    return {
      hasGeneratedId: false,
      innerItem: true
    };
  }
  static get declarable() {
    return [
      "renderConfigs"
    ];
  }
  static get delayable() {
    return {
      recompose: "raf",
      doHideOrRealign: "raf",
      onAlignConstraintChange: "raf"
    };
  }
  static get factoryable() {
    return {
      defaultType: "widget"
    };
  }
  static get identifiable() {
    return {};
  }
  static get all() {
    return super.all;
  }
  static get recomposeAsync() {
    return Widget._recomposeAsync;
  }
  static set recomposeAsync(value) {
    Widget._recomposeAsync = value;
    if (value != null) {
      const {
        all
      } = Widget;
      for (let i = 0; i < all.length; ++i) {
        if (all[i].isComposable) {
          all[i].recomposeAsync = value;
        }
      }
    }
  }
  isType(type, deep) {
    return Widget.isType(this, type, deep);
  }
  static setupRenderConfigs(cls, meta) {
    let {
      renderConfigs
    } = cls, i;
    if (renderConfigs) {
      const obj = meta.getInherited("renderConfigs", false) || /* @__PURE__ */ Object.create(null);
      if (Array.isArray(renderConfigs)) {
        for (i = 0; i < renderConfigs.length; ++i) {
          obj[renderConfigs[i]] = true;
        }
        renderConfigs = obj;
      } else {
        renderConfigs = Object.assign(obj, renderConfigs);
      }
    }
    meta.renderConfigs = renderConfigs;
  }
  construct(config = {}, ...args) {
    const me = this, {
      domSyncCallback
    } = me;
    me.configureAriaDescription = config.ariaDescription;
    me._isAnimatingCounter = 0;
    me.alignConstrained = 0;
    me.byRef = /* @__PURE__ */ Object.create(null);
    me.onTargetResize = me.onTargetResize.bind(me);
    me.onFullscreenChange = me.onFullscreenChange.bind(me);
    me.domSyncCallback = domSyncCallback.$nullFn ? null : domSyncCallback.bind(me);
    me._isUserAction = false;
    super.construct(config, ...args);
    const {
      recomposeAsync
    } = Widget;
    if (recomposeAsync != null && me.recomposeAsync == null) {
      me.recomposeAsync = recomposeAsync;
    }
    me.finalizeInit();
  }
  startConfigure(config) {
    super.startConfigure(config);
    const me = this, {
      adopt,
      element
    } = me;
    if (adopt) {
      me.adoptElement(element, adopt, config.id);
      me.updateElement(me._element, element);
    }
  }
  finalizeInit() {
    const me = this;
    if (me.insertBefore || me.appendTo || me.insertFirst || me.adopt) {
      me.render();
    }
  }
  doDestroy() {
    const me = this, {
      preExistingElements,
      element,
      _refListeners
    } = me;
    if (_refListeners) {
      Object.values(_refListeners, (un) => un());
      me._refListeners = null;
    }
    if (element) {
      var _Widget$Tooltip, _me$dragEventDetacher, _me$dragOverEventDeta;
      const sharedTooltip = !me._tooltip && me._rootElement && ((_Widget$Tooltip = Widget.Tooltip) === null || _Widget$Tooltip === void 0 ? void 0 : _Widget$Tooltip.getSharedTooltip(me._rootElement, true));
      if ((sharedTooltip === null || sharedTooltip === void 0 ? void 0 : sharedTooltip.owner) === me) {
        sharedTooltip.owner = null;
        sharedTooltip.hide();
      }
      me.onExitFullscreen();
      me.clearTimeout(me.scrollListenerTimeout);
      me.clearTimeout(me.resizeListenerTimeout);
      me.removeTransientListeners();
      if (me.floating || me.positioned) {
        me.hide(false);
      } else {
        me.revertFocus();
      }
      ResizeMonitor.removeResizeListener(element.parentElement, me.onParentElementResize);
      ResizeMonitor.removeResizeListener(element, me.onElementResize);
      if (me.adopt) {
        for (let nodes = Array.from(element.childNodes), i = 0, {
          length
        } = nodes; i < length; i++) {
          const el = nodes[i];
          if (!preExistingElements.includes(el) && el !== me.floatRoot) {
            el.remove();
          }
        }
        element.className = me.adoptedElementClassName;
        element.style.cssText = me.adoptedElementCssText;
      } else {
        element.remove();
      }
      (_me$dragEventDetacher = me.dragEventDetacher) === null || _me$dragEventDetacher === void 0 ? void 0 : _me$dragEventDetacher.call(me);
      (_me$dragOverEventDeta = me.dragOverEventDetacher) === null || _me$dragOverEventDeta === void 0 ? void 0 : _me$dragOverEventDeta.call(me);
      me.dragGhost.remove();
    }
    super.doDestroy();
  }
  get assignValueDefaults() {
    return assignValueDefaults;
  }
  get valueName() {
    return this.name || this.ref || this.id;
  }
  getValueName(onlyName) {
    onlyName = onlyName && typeof onlyName === "object" ? onlyName.onlyName : onlyName;
    return onlyName ? this.name : this.valueName;
  }
  assignFieldValue(values, key, value) {
    const me = this, valueBindProperty = me.defaultBindProperty;
    if (valueBindProperty in me) {
      me[valueBindProperty] = value;
    }
  }
  assignValue(values, options) {
    options = options || assignValueDefaults;
    const me = this, hec = me[highlightExternalChange], key = me.getValueName(options);
    if (key && (!values || key in values)) {
      if (options.highlight === false) {
        me[highlightExternalChange] = false;
      }
      me.assignFieldValue(values, key, values ? values[key] : null);
      me[highlightExternalChange] = hec;
    }
  }
  gatherValue(values) {
    const me = this, valueBindProperty = me.defaultBindProperty;
    if (me.constructor !== Widget && valueBindProperty in me) {
      values[me.name || me.ref || me.id] = me[valueBindProperty];
    }
  }
  gatherValues(values) {
    this.eachWidget((widget) => widget.gatherValue(values), false);
  }
  get forwardTwinEvents() {
    const value = this._forwardTwinEvents;
    return value && ObjectHelper.getTruthyKeys(value);
  }
  configureOverflowTwin(overrides) {
    var _me$forwardTwinEvents;
    const me = this;
    let config = ObjectHelper.clone(me.initialConfig);
    delete config.id;
    config.hidden = false;
    config.type = me.type;
    config._overflowTwinOrigin = me;
    config.disabled = me.disabled;
    if ("value" in me) {
      config.value = me.value;
    }
    (_me$forwardTwinEvents = me.forwardTwinEvents) === null || _me$forwardTwinEvents === void 0 ? void 0 : _me$forwardTwinEvents.forEach((ev) => {
      delete config[`on${StringHelper.capitalize(ev)}`];
    });
    if (overrides) {
      config = typeof overrides === "function" ? overrides(config) || config : ObjectHelper.assign(config, overrides);
    }
    return config;
  }
  createOverflowTwin(overrides) {
    var _me$forwardTwinEvents2;
    const me = this, config = me.configureOverflowTwin(overrides), overflowTwin = Widget.create(config);
    (_me$forwardTwinEvents2 = me.forwardTwinEvents) === null || _me$forwardTwinEvents2 === void 0 ? void 0 : _me$forwardTwinEvents2.forEach((ev) => {
      overflowTwin.ion({
        [ev]: (info) => {
          if (me.overflowTwin === info.source) {
            info = ObjectHelper.assign({}, info);
            delete info.source;
            me.trigger(info.type, info);
          }
        }
      });
    });
    return overflowTwin;
  }
  ensureOverflowTwin(overrides, onCreate) {
    let {
      overflowTwin
    } = this;
    if (!overflowTwin) {
      this.overflowTwin = overflowTwin = this.createOverflowTwin(overrides);
      onCreate === null || onCreate === void 0 ? void 0 : onCreate(overflowTwin);
    }
    return overflowTwin;
  }
  get isComposable() {
    return !this.compose.$nullFn;
  }
  adoptElement(element, adopt, id) {
    const me = this, adoptElement = typeof adopt === "string" ? document.getElementById(adopt) : adopt, previousHolder = Widget.fromElement(adoptElement);
    if (previousHolder && previousHolder.adopt && previousHolder !== me) {
      const previousHolderAdopt = typeof previousHolder.adopt === "string" ? document.getElementById(previousHolder.adopt) : previousHolder.adopt;
      if (previousHolderAdopt === adoptElement) {
        previousHolder.destroy();
      }
    }
    me.preExistingElements = Array.from(adoptElement.childNodes);
    me.adoptedElementClassName = adoptElement.className;
    me.adoptedElementCssText = adoptElement.style.cssText;
    if (adoptElement.id && !id) {
      me.id = element.id = adoptElement.id;
    }
    DomHelper.syncAttributes(element, adoptElement);
    for (let i = 0, {
      length
    } = element.childNodes; i < length; i++) {
      adoptElement.appendChild(element.childNodes[0]);
    }
    delete me._contentRange;
    me._element = adoptElement;
    const domConfig = element.lastDomConfig, listeners = domConfig === null || domConfig === void 0 ? void 0 : domConfig.listeners;
    if (listeners && me.isComposable) {
      var _listeners$un;
      (_listeners$un = listeners.un) === null || _listeners$un === void 0 ? void 0 : _listeners$un.call(listeners);
      addElementListeners(me, adoptElement, domConfig);
    }
    adoptElement.lastDomConfig = domConfig || adoptElement.lastDomConfig;
    adoptElement.$refOwnerId = me.id;
    if (!me.scaleToFitWidth) {
      me.getConfig("monitorResize");
    }
  }
  addRefAccessor(name, key) {
    const {
      prototype: prototype2
    } = this.constructor;
    defineProperty$1(prototype2, key, {
      writable: true,
      value: null
    });
    defineProperty$1(prototype2, name, {
      get() {
        this.recompose.flush();
        return this[key];
      },
      set(el) {
        this[key] = el;
      }
    });
  }
  attachRef(name, el, domConfig) {
    const me = this, key = "_" + name;
    el.dataset && (el.dataset.ownerCmp = me.id);
    if (me.isComposable) {
      if (!(key in me)) {
        me.addRefAccessor(name, key);
      }
      addElementListeners(me, el, domConfig, name);
    }
    me.byRef[name] = el;
    me[name] = el;
  }
  detachRef(name, el, domConfig) {
    const me = this, listeners = me._refListeners;
    if (listeners !== null && listeners !== void 0 && listeners[name]) {
      listeners[name]();
      delete listeners[name];
    }
    me[name] = null;
    delete me.byRef[name];
  }
  afterRecompose() {
  }
  compose() {
    return {
      class: DomClassList.normalize(this.widgetClassList, "object")
    };
  }
  doCompose() {
    const me = this, {
      $meta: meta
    } = me, classes = meta.hierarchy;
    let {
      composers
    } = meta, domConfig = null, c, key, firstTime, i, proto2, renderConfigs;
    me.recompose.suspend();
    if (!composers) {
      firstTime = true;
      meta.composers = composers = [];
      for (i = classes.indexOf(Widget); i < classes.length; ++i) {
        proto2 = classes[i].prototype;
        if (hasOwnProperty$2.call(proto2, "compose")) {
          composers.push(proto2);
        }
      }
      if (!(renderConfigs = meta.getInherited("renderConfigs", false))) {
        renderConfigs = /* @__PURE__ */ Object.create(null);
        me.configObserver = {
          get(name) {
            renderConfigs[name] = true;
          }
        };
      }
      meta.$renderConfigs = renderConfigs;
    }
    for (i = 0; i < composers.length; ++i) {
      c = composers[i].compose.call(me, domConfig);
      domConfig = domConfig ? DomHelper.merge(domConfig, c) : c;
    }
    if (hasOwnProperty$2.call(me, "compose") && (c = me.compose)) {
      c = c.call(me, domConfig);
      DomHelper.merge(domConfig, c);
    }
    firstTime && delete me.configObserver;
    return DomHelper.normalizeChildren(domConfig, (childName, hoist) => {
      if (hoist) {
        key = "_" + childName;
        if (!(key in me)) {
          me.addRefAccessor(childName, key);
        }
      }
    });
  }
  get element() {
    if (this.isComposable && !this.isDestroying) {
      this.recompose.flush();
    }
    return this._element;
  }
  domSyncCallback(info) {
  }
  changeElement(element) {
    const me = this, compose = me.isComposable;
    if (compose) {
      element = me.doCompose();
    }
    if (typeof element === "string") {
      element = DomHelper.createElementFromTemplate(element);
    } else if (ObjectHelper.isObject(element)) {
      element = DomHelper.createElement(element, {
        refOwner: me,
        callback: me.domSyncCallback
      });
      me.recompose.resume();
      compose && addElementListeners(me, element, element.lastDomConfig);
    } else if (DomHelper.isReactElement(me.peekConfig("html"))) {
      element = document.createElement("div");
    } else if (element.nodeType !== 1) {
      element = DomHelper.createElementFromTemplate(me.template(me));
    }
    element.id = me.id;
    if (me.elementAttributes) {
      DomHelper.setAttributes(element, me.elementAttributes);
    }
    return element;
  }
  updateElement(element) {
    const me = this, {
      className
    } = element, {
      contentElement,
      contentElementCls,
      isComposable
    } = me, hasChildContent = contentElement !== element, namedElements = !isComposable && element.querySelectorAll("[data-reference]"), classes = isComposable ? [] : me.widgetClassList;
    let uiClasses = (hasChildContent || !isComposable) && me.uiClasses;
    className && classes.unshift(className);
    me._hidden && classes.push("b-hidden");
    me._readOnly && classes.push("b-readonly");
    FunctionHelper.noThrow(element, "remove");
    if (uiClasses) {
      if (contentElementCls !== null && contentElementCls !== void 0 && contentElementCls.value) {
        uiClasses = uiClasses.slice();
        uiClasses.push(contentElementCls.value);
      }
      uiClasses = uiClasses.join(" ");
    } else {
      uiClasses = contentElementCls === null || contentElementCls === void 0 ? void 0 : contentElementCls.value;
    }
    if (uiClasses) {
      if (hasChildContent) {
        contentElement.className += " " + uiClasses;
      } else {
        classes.push(uiClasses);
      }
    }
    if (!me.parent) {
      const {
        defaultCls
      } = me, {
        outerCls
      } = Widget;
      classes.push(...defaultCls ? outerCls.filter((c) => !(c in defaultCls) || defaultCls[c]) : outerCls);
    }
    element.className = classes.join(" ");
    if (namedElements) {
      for (let el, i = 0; i < namedElements.length; ++i) {
        el = namedElements[i];
        me.attachRef(el.getAttribute("data-reference"), el);
        el.removeAttribute("data-reference");
      }
    }
    if (!me.adopt && !me.scaleToFitWidth) {
      me.getConfig("monitorResize");
    }
    me.getConfig("role");
    me.getConfig("ariaLabel");
    me.getConfig("ariaDescription");
    if (me._html) {
      me.getConfig("htmlMutationObserver");
    }
    me.trigger("elementCreated", {
      element
    });
  }
  updateAriaDescription(ariaDescription) {
    const {
      ariaElement
    } = this, descElId = `${this.id}-aria-desc-el`;
    if (ariaDescription) {
      const ariaDescEl = this._ariaDescEl || (this._ariaDescEl = DomHelper.createElement({
        className: "b-aria-desc-element",
        id: descElId,
        parent: ariaElement
      }));
      ariaDescEl.innerText = ariaDescription.match(localizeRE) ? this.L(ariaDescription, this) : ariaDescription;
      ariaElement.setAttribute("aria-describedBy", ariaDescEl.id);
    } else if (ariaElement.getAttribute("aria-describedby") === descElId) {
      ariaElement.removeAttribute("aria-describedBy");
    }
  }
  updateAriaLabel(ariaLabel) {
    DomHelper.setAttributes(this.ariaElement, {
      "aria-label": ariaLabel !== null && ariaLabel !== void 0 && ariaLabel.match(localizeRE) ? this.L(ariaLabel, this) : ariaLabel
    });
  }
  updateAriaHasPopup(ariaHasPopup) {
    DomHelper.setAttributes(this.ariaElement, {
      "aria-haspopup": ariaHasPopup
    });
  }
  updateRole(role) {
    if (role) {
      var _this$ariaElement;
      (_this$ariaElement = this.ariaElement) === null || _this$ariaElement === void 0 ? void 0 : _this$ariaElement.setAttribute("role", role);
    } else {
      var _this$ariaElement2;
      (_this$ariaElement2 = this.ariaElement) === null || _this$ariaElement2 === void 0 ? void 0 : _this$ariaElement2.removeAttribute("role");
    }
  }
  get ariaElement() {
    this.getConfig("element");
    const {
      _ariaElement
    } = this;
    return _ariaElement.nodeType === Node.ELEMENT_NODE ? _ariaElement : ObjectHelper.getPath(this, _ariaElement);
  }
  isCollapsified(collapsed, overlay) {
    const {
      collapsify
    } = this;
    let ret = !overlay;
    if (collapsify == null) {
      ret = overlay ? collapsed : !collapsed;
    } else if (collapsify === "overlay") {
      ret = overlay;
    }
    return Boolean(ret);
  }
  async recompose() {
    const me = this, options = {
      targetElement: me.element,
      domConfig: me.doCompose(),
      refOwner: me,
      callback: me.domSyncCallback,
      strict: true
    };
    if (me.transitionRecompose) {
      me.isTransitioningDom = true;
      await DomHelper.transition(ObjectHelper.assign({
        element: me.element,
        action() {
          DomSync.sync(options);
        }
      }, me.transitionRecompose));
      if (me.isDestroyed) {
        return;
      }
      me.isTransitioningDom = false;
      me.trigger("transitionedRecompose");
    } else {
      DomSync.sync(options);
    }
    if (options.changed) {
      me.afterRecompose();
      me.trigger("recompose");
    }
    me.recompose.resume();
  }
  changeElementRef(el) {
    if (typeof el === "string") {
      const id = el;
      if (!(el = document.getElementById(id))) {
        throw new Error(`No element found with id '${id}'`);
      }
    }
    return el;
  }
  changeAppendTo(appendTo) {
    return this.changeElementRef(appendTo);
  }
  updateAppendTo(appendTo) {
    if (!this.isConfiguring && appendTo) {
      this.render();
    }
  }
  changeInsertBefore(insertBefore) {
    return this.changeElementRef(insertBefore);
  }
  updateInsertBefore(insertBefore) {
    if (!this.isConfiguring && insertBefore) {
      this.render();
    }
  }
  changeInsertFirst(insertFirst) {
    return this.changeElementRef(insertFirst);
  }
  updateInsertFirst(insertFirst) {
    if (!this.isConfiguring && insertFirst) {
      this.render();
    }
  }
  getRenderContext(config = this, renderTo) {
    let parentElement = renderTo || config.appendTo, {
      insertFirst,
      insertBefore
    } = config;
    if (insertFirst) {
      parentElement = insertFirst;
      insertBefore = parentElement.firstChild;
    }
    if (insertBefore) {
      if (!parentElement) {
        parentElement = insertBefore.parentElement;
      }
    }
    return [parentElement, insertBefore || void 0];
  }
  render(renderTo, triggerPaint = true) {
    const me = this, {
      element
    } = me, [parentElement, insertBefore] = me.getRenderContext(me, renderTo);
    me.emptyCache();
    if (me.syncElement && me.currentElement) {
      DomHelper.sync(element, me.currentElement);
    } else {
      parentElement === null || parentElement === void 0 ? void 0 : parentElement.insertBefore(element, insertBefore);
      me.currentElement = element;
    }
    if (Widget.fromElement(element.parentElement)) {
      element.classList.remove(...Widget.outerCls);
    }
    super.render(parentElement, triggerPaint);
    me.rendered = true;
    me.getConfig("role");
    if (triggerPaint) {
      me.getConfig("contentRange");
      me.triggerPaint();
    }
    me.setupFocusListeners();
  }
  template({
    tag,
    html,
    htmlCls,
    name
  }) {
    var _html;
    const me = this;
    if (typeof html === "string" && callbackRe.test(html) && me.resolveCallback(html, me, false)) {
      html = me.callback(html, me, [me]);
    }
    const content = (_html = html) !== null && _html !== void 0 && _html.call ? html.call(me, me) : html;
    return `<${tag} class="${content ? htmlCls : ""}" ${name ? `data-name="${name}"` : ""}>${content || ""}</${tag}>`;
  }
  updateRecomposeAsync(async) {
    this.recompose.immediate = !async;
  }
  onConfigChange({
    name
  }) {
    var _this$$meta$$renderCo;
    if (this._element && !this.isDestroying && (_this$$meta$$renderCo = this.$meta.$renderConfigs) !== null && _this$$meta$$renderCo !== void 0 && _this$$meta$$renderCo[name]) {
      this.recompose();
    }
  }
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs(configs);
    delete configs.parent;
  }
  getConfigValue(name, options) {
    if (name === "style") {
      return this._style;
    }
    return super.getConfigValue(name, options);
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    if ((options === null || options === void 0 ? void 0 : options.depth) > 0) {
      result.type = this.type;
    }
    return result;
  }
  get dataset() {
    return this.element.dataset;
  }
  changeDataset(dataset) {
    Object.assign(this.dataset, dataset);
  }
  get dragGhost() {
    return this.constructor._dragGhost || (this.constructor._dragGhost = DomHelper.createElement({
      html: "\xA0",
      style: "position:absolute;top:-10000em;left:-10000em"
    }));
  }
  updateParent(parent) {
    const {
      _element: element
    } = this;
    if (element) {
      element.classList[parent ? "remove" : "add"](...Widget.outerCls);
    }
  }
  get constrainTo() {
    var _result;
    let result = this._constrainTo;
    result = result === void 0 ? globalThis : ((_result = result) === null || _result === void 0 ? void 0 : _result.nodeType) === Node.DOCUMENT_FRAGMENT_NODE ? result.host || result.ownerDocument : result;
    if (this.positioned) {
      const {
        offsetParent
      } = this.element;
      if (offsetParent && DomHelper.getStyleValue(offsetParent, "overflow") === "hidden") {
        result = Rectangle.from(offsetParent).moveTo(0, 0);
      } else if (result && !result.isRectangle) {
        const isViewport = result === document || result === globalThis;
        result = Rectangle.from(result, offsetParent);
        if (isViewport) {
          result.translate(globalThis.pageXOffset, globalThis.pageYOffset);
        }
      }
    }
    return result;
  }
  updateCentered(value) {
    const {
      element,
      _anchorElement
    } = this;
    if (value && !this.floating && !this.positioned) {
      throw new Error("`centered` is only relevant when a Widget is `floating` or `positioned`");
    }
    if (value) {
      element.classList.add("b-centered");
      element.style.transform = element.style.left = element.style.top = "";
      _anchorElement === null || _anchorElement === void 0 ? void 0 : _anchorElement.classList.add("b-hide-display");
      element.classList.remove("b-anchored");
    } else {
      element.classList.remove("b-centered");
    }
  }
  get contentElement() {
    return this.element;
  }
  get contentRange() {
    const me = this, {
      contentElement
    } = me, contentRange = me._contentRange || (me._contentRange = new Range());
    if (contentRange.collapsed) {
      contentRange.setStart(contentElement, me.contentRangeStartOffset || 0);
      contentRange.setEnd(contentElement, me.contentRangeEndOffset || contentElement.childNodes.length);
    }
    return contentRange;
  }
  fixRefOwnerId(el, id, oldId) {
    if (el.$refOwnerId === oldId) {
      el.$refOwnerId = id;
      for (let {
        childNodes
      } = el, i = childNodes.length; i-- > 0; ) {
        this.fixRefOwnerId(childNodes[i], id, oldId);
      }
    }
  }
  get placement() {
    const me = this, {
      element
    } = me;
    let adjRect, placement, rect;
    if (element !== null && element !== void 0 && element.offsetParent && !nonFlowedPositions.test(DomHelper.getStyleValue(element, "position"))) {
      const next = element.nextElementSibling, previous = element.previousElementSibling, last = !next && previous;
      placement = DomHelper.getStyleValue(element.parentElement, "flex-direction");
      if (placement) {
        placement = placement.startsWith("row") ? "h" : "v";
      } else {
        var _ref;
        adjRect = (_ref = next || previous) === null || _ref === void 0 ? void 0 : _ref.getBoundingClientRect();
        rect = adjRect && element.getBoundingClientRect();
        placement = adjRect && Math.abs(adjRect.top - rect.top) < Math.abs(adjRect.left - rect.left) ? "h" : "v";
      }
      placement += placement === "h" ? last ? "r" : "l" : last ? "b" : "t";
    }
    return placement;
  }
  updateId(id, oldId) {
    super.updateId(id, oldId);
    if (oldId) {
      const {
        byRef,
        element
      } = this;
      for (const ref in byRef) {
        byRef[ref].dataset && (byRef[ref].dataset.ownerCmp = id);
      }
      element.id = id;
      this.fixRefOwnerId(element, id, oldId);
    }
  }
  get style() {
    const {
      element
    } = this;
    return (element === null || element === void 0 ? void 0 : element.ownerDocument.defaultView.getComputedStyle(element)) || this._style;
  }
  updateStyle(style) {
    this.element && DomHelper.applyStyle(this.element, style);
  }
  updateTitle(title) {
    if (this.titleElement) {
      this.titleElement.innerHTML = title;
    }
  }
  beforeAlignTo(spec) {
  }
  alignTo(spec) {
    var _anchor;
    const me = this, {
      lastAlignSpec,
      element
    } = me, {
      offsetParent,
      style,
      classList
    } = element;
    if (lastAlignSpec) {
      lastAlignSpec.monitorIntersection && me.intersectionObserver.unobserve(lastAlignSpec.target);
      if (isFinite(lastAlignSpec.zone)) {
        element.classList.remove(alignedClass[lastAlignSpec.zone]);
      }
    }
    if (!spec) {
      me.removeTransientListeners();
      me.anchor = me.lastAlignSpec = null;
      return;
    }
    me.beforeAlignTo(spec);
    if (spec.nodeType === Element.ELEMENT_NODE || spec.isWidget || spec.$$name === "Point") {
      spec = {
        target: spec
      };
    }
    me.releaseSizeConstraints();
    const {
      scrollable,
      constrainTo
    } = me, positioned = me.positioned && DomHelper.getStyleValue(element, "position") !== "fixed", scale = me.scale || 1, passedTarget = spec.target, target = passedTarget && (passedTarget.isRectangle ? passedTarget : passedTarget.element || passedTarget), myPosition = Rectangle.from(element, positioned ? offsetParent : null, true), {
      width: startWidth,
      height: startHeight
    } = myPosition, aligningToElement = target && target.nodeType === Element.ELEMENT_NODE;
    spec = spec.realignTarget ? spec : ObjectHelper.assign({
      aligningToElement,
      constrainTo,
      align: "b-t",
      axisLock: me.axisLock,
      anchor: me.anchor
    }, me.align, spec);
    const minWidth = spec.minWidth || me.minWidth, minHeight = spec.minHeight || me.minHeight;
    myPosition.isAlignRectangle = true;
    minWidth && (myPosition.minWidth = minWidth * scale);
    minHeight && (myPosition.minHeight = minHeight * scale);
    me.lastAlignSpec = spec;
    if (aligningToElement) {
      me.lastAlignSpec.target = target;
    }
    if (aligningToElement && hasLayout(target instanceof SVGElement ? target.closest("svg") : target)) {
      spec = Object.setPrototypeOf({}, spec);
      spec.target = me.lastAlignSpec.targetRect = spec.realignTarget || (spec.allowTargetOut ? Rectangle.from(target, positioned ? offsetParent : null, !positioned) : DomHelper.isInView(target, false, me));
      if (!spec.target) {
        const result2 = me.hide();
        if (!me.isDestroyed) {
          me.lastAlignSpec.targetOutOfView = true;
        }
        return result2;
      }
      spec.target.height = Math.max(spec.target.height, 1);
      spec.target.width = Math.max(spec.target.width, 1);
      me.lastAlignSpec.anchoredTo = target;
    }
    if (spec.anchor) {
      spec.anchorSize = me.anchorSize;
      if (!element.contains(me.anchorPathElement)) {
        element.appendChild(me.anchorElement);
      }
    }
    me.isAligning = true;
    me.trigger("beforeAlign", spec);
    me.isAligning = false;
    spec.rtl = me.rtl;
    if (spec.align.includes("s") || spec.align.includes("e")) {
      if (me.rtl) {
        spec.align = spec.align.replace(/s/g, "r").replace(/e/g, "l");
      } else {
        spec.align = spec.align.replace(/s/g, "l").replace(/e/g, "r");
      }
    }
    const result = myPosition.alignTo(spec);
    let {
      align,
      anchor,
      x,
      y,
      width,
      height,
      overlap
    } = result;
    me.lastAlignSpec.zone = result.zone;
    if (height != startHeight) {
      if (!("configuredHeight" in me)) {
        me.configuredHeight = style.height;
      }
      me.height = height / scale;
      me.alignConstrained = me.alignConstrained | 1;
      if (scrollable) {
        scrollable.overflowY = true;
      }
    }
    if (width != startWidth) {
      if (!("configuredWidth" in me)) {
        me.configuredWidth = style.width;
      }
      me.width = width / scale;
      me.alignConstrained = me.alignConstrained | 2;
      if (scrollable) {
        scrollable.overflowX = scrollable.clientWidth > scrollable.scrollWidth;
      }
    }
    if (align && me.alignConstrained) {
      spec.align = align;
      const newResult = Rectangle.from(element, positioned ? offsetParent : null, true).alignTo(spec);
      anchor = newResult.anchor;
      x = newResult.x;
      y = newResult.y;
      width = newResult.width;
      height = newResult.height;
    }
    if (!me.centered) {
      me.setXY(x, y);
    }
    if (!result.overlap && isFinite(result.zone)) {
      classList.add(alignedClass[result.zone]);
    }
    if ((_anchor = anchor) !== null && _anchor !== void 0 && _anchor.edge) {
      var _colourSource;
      const {
        edge
      } = anchor, {
        anchorElement
      } = me, elRect = Rectangle.from(element), colorMatchPoint = [];
      if (edge === "top" || edge === "bottom") {
        colorMatchPoint[0] = anchor.x;
        colorMatchPoint[1] = edge === "top" ? 1 : elRect.height - 1;
      } else {
        colorMatchPoint[0] = edge === "left" ? 1 : elRect.width - 1;
        colorMatchPoint[1] = anchor.y;
      }
      let colourSource = DomHelper.childFromPoint(element, ...colorMatchPoint);
      if ((_colourSource = colourSource) !== null && _colourSource !== void 0 && _colourSource.matches(":hover,:focus") && element.compareDocumentPosition(colourSource) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
        colourSource = colourSource.parentNode;
      }
      if (colourSource && colourSource !== document) {
        let fillColour = DomHelper.getStyleValue(colourSource, "background-color");
        while (fillColour.match(isTransparent) && DomHelper.getStyleValue(colourSource, "position") !== "absolute") {
          colourSource = colourSource.parentNode;
          if (colourSource === document) {
            break;
          }
          fillColour = DomHelper.getStyleValue(colourSource, "background-color");
        }
        if (fillColour.match(isTransparent)) {
          me.anchorPathElement.setAttribute("fill", me.defaultAnchorBackgroundColor);
        } else {
          me.anchorPathElement.setAttribute("fill", fillColour);
        }
      }
      anchorElement.classList.remove("b-hide-display");
      anchorElement.style.transform = "";
      anchorElement.className = `b-anchor b-anchor-${edge}`;
      anchor.x && (anchor.x /= scale);
      anchor.y && (anchor.y /= scale);
      DomHelper.setTranslateXY(anchorElement, anchor.x, anchor.y);
      classList.add("b-anchored");
    } else if (me._anchorElement) {
      me.anchorElement.classList.add("b-hide-display");
      classList.remove("b-anchored");
    }
    if (!aligningToElement) {
      style.pointerEvents = "none";
      const el = DomHelper.elementFromPoint(x, y);
      if (!me.owns(el)) {
        me.lastAlignSpec.anchoredTo = el;
      }
      style.pointerEvents = "";
    }
    if ((me.scrollAction === "realign" && aligningToElement || me.scrollAction === "hide") && !me.documentScrollListener) {
      me.clearTimeout(me.scrollListenerTimeout);
      if (spec.monitorTargetMutation && !me.targetObserver) {
        const targetObserver = me.targetObserver || (me.targetObserver = new MutationObserver(me.onTargetParentMutation.bind(me)));
        targetObserver.observe(DomHelper.getRootElement(target), {
          childList: true,
          attributes: true,
          subtree: true
        });
      }
      me.scrollListenerTimeout = me.setTimeout(() => {
        var _target$getRootNode;
        const targetRoot = (_target$getRootNode = target.getRootNode) === null || _target$getRootNode === void 0 ? void 0 : _target$getRootNode.call(target);
        me.documentScrollListener = EventHelper.addListener(document, "scroll", "doHideOrRealign", {
          capture: true,
          thisObj: me
        });
        if (targetRoot !== null && targetRoot !== void 0 && targetRoot.mode) {
          me.targetRootScrollListener = EventHelper.addListener(targetRoot, "scroll", "doHideOrRealign", {
            capture: true,
            thisObj: me
          });
        }
      }, me.scrollAction === "hide" ? me.ignoreScrollDuration : 0);
    }
    if (aligningToElement) {
      if (spec.monitorResize && !me.targetResizeListener) {
        ResizeMonitor.addResizeListener(target, me.onTargetResize);
        me.targetResizeListener = true;
      }
      if (spec.monitorIntersection && !(overlap || target.contains(element) || target.ownerSVGElement)) {
        me.intersectionObserver.observe(target);
      }
    }
    if (!BrowserHelper.isAndroid) {
      if (!me.constrainListeners) {
        const el = constrainTo !== null && constrainTo !== void 0 && constrainTo.isRectangle ? globalThis : constrainTo;
        me.clearTimeout(me.resizeListenerTimeout);
        me.resizeListenerTimeout = me.setTimeout(() => {
          me.constrainListeners = true;
          ResizeMonitor.addResizeListener(el || globalThis, me.onAlignConstraintChange);
        }, me.ignoreScrollDuration);
      }
    }
  }
  onTargetParentMutation(mutationRecords) {
    const {
      element,
      lastAlignSpec
    } = this;
    if (lastAlignSpec !== null && lastAlignSpec !== void 0 && lastAlignSpec.aligningToElement) {
      if (!isInDocument(lastAlignSpec.target)) {
        this.hide();
      } else if (mutationRecords.some(({
        target
      }) => target.contains(lastAlignSpec.target) && !element.contains(target))) {
        this.realign();
      }
    }
  }
  get intersectionObserver() {
    return this._intersectionObserver || (this._intersectionObserver = new IntersectionObserver(this.onTargetIntersectionchange.bind(this), {
      root: BrowserHelper.isSafari ? this.rootElement : this.rootElement.ownerDocument
    }));
  }
  onTargetIntersectionchange(entries) {
    if (!this.isDestroyed) {
      const e = entries[entries.length - 1];
      if (!e.isIntersecting) {
        this.onAlignTargetOutOfView(e.target);
      }
    }
  }
  onTargetResize() {
    const {
      lastAlignSpec
    } = this;
    if (lastAlignSpec) {
      const {
        width: lastWidth,
        height: lastHeight
      } = lastAlignSpec.targetRect, {
        width,
        height
      } = lastAlignSpec.target.getBoundingClientRect();
      if (width !== lastWidth || height !== lastHeight) {
        this.onAlignConstraintChange(...arguments);
      }
    }
  }
  onAlignTargetOutOfView(target) {
    this.hide();
    this.lastAlignSpec && (this.lastAlignSpec.targetOutOfView = true);
  }
  onAlignConstraintChange(el, oldRect, {
    height
  }) {
    const {
      style
    } = this.contentElement, {
      overflowY
    } = style;
    this.setTimeout(this.realign, 50);
    if (oldRect && height > oldRect.height) {
      style.overflowY = "hidden";
      this.requestAnimationFrame(() => style.overflowY = overflowY);
    }
  }
  realign() {
    const me = this, {
      lastAlignSpec
    } = me;
    if ((me.floating || me.positioned) && lastAlignSpec && me.isVisible) {
      if (lastAlignSpec.aligningToElement) {
        const insideTarget = lastAlignSpec.target.contains(this.element), realignTarget = DomHelper.isInView(lastAlignSpec.target, false, me);
        if (!lastAlignSpec.allowTargetOut && (!hasLayout(lastAlignSpec.target) || !realignTarget)) {
          me.hide();
          if (!me.isDestroyed) {
            me.lastAlignSpec.targetOutOfView = true;
          }
          return;
        }
        lastAlignSpec.realignTarget = insideTarget ? null : realignTarget;
      }
      DomHelper.addTemporaryClass(me.element, "b-realigning", me.realignTimout, me);
      me.alignTo(lastAlignSpec);
    }
  }
  rectangle(which, relativeTo, ignorePageScroll) {
    return this.rectangleOf("element", which, relativeTo, ignorePageScroll);
  }
  rectangleOf(element, which, relativeTo, ignorePageScroll) {
    var _relativeTo;
    if (typeof which !== "string") {
      ignorePageScroll = relativeTo;
      relativeTo = which;
      which = "";
    } else if (which === "border") {
      which = "";
    }
    if (typeof relativeTo === "boolean") {
      ignorePageScroll = relativeTo;
      relativeTo = void 0;
    }
    if (element !== "element" && relativeTo === void 0) {
      relativeTo = this.element;
    }
    relativeTo = (_relativeTo = relativeTo) !== null && _relativeTo !== void 0 && _relativeTo.isWidget ? relativeTo.element : relativeTo;
    return Rectangle[which || "from"](this[element], relativeTo, ignorePageScroll);
  }
  releaseSizeConstraints() {
    const me = this, scroller = me.scrollable;
    if (me.alignConstrained & 1) {
      me.height = me.configuredHeight;
      if (scroller) {
        scroller.overflowY = scroller.config.overflowY;
      }
    }
    if (me.alignConstrained & 2) {
      me.width = me.configuredWidth;
      if (scroller) {
        scroller.overflowX = scroller.config.overflowX;
      }
    }
    me.alignConstrained = 0;
  }
  toFront() {
    const {
      element
    } = this, parent = this.floating ? this.floatRoot : this.positioned ? element === null || element === void 0 ? void 0 : element.parentNode : null;
    if (element !== null && element !== void 0 && element.nextSibling) {
      const r = this._toFrontRange || (this._toFrontRange = document.createRange());
      r.setStartBefore(element.nextSibling);
      r.setEndAfter(parent.lastElementChild);
      parent.insertBefore(r.extractContents(), element);
    }
  }
  updateRef(ref) {
    this.element.dataset.ref = ref;
  }
  get overflowElement() {
    return this.contentElement;
  }
  get maxHeightElement() {
    return this.element;
  }
  changeAlign(align) {
    return typeof align === "string" ? {
      align
    } : align;
  }
  changeScrollable(scrollable, oldScrollable) {
    if (typeof scrollable === "boolean") {
      scrollable = {
        overflowX: scrollable,
        overflowY: scrollable
      };
    }
    if (scrollable) {
      scrollable.element = this.overflowElement;
      scrollable.widget = this;
      if (!scrollable.isScroller) {
        scrollable = oldScrollable ? oldScrollable.setConfig(scrollable) : new this.scrollerClass(scrollable);
      }
      scrollable.syncOverflowState();
    } else {
      oldScrollable === null || oldScrollable === void 0 ? void 0 : oldScrollable.destroy();
    }
    return scrollable;
  }
  handleReactElement(html) {
    const parent = this.closest((cmp) => cmp.reactComponent);
    if (parent !== null && parent !== void 0 && parent.reactComponent) {
      parent.reactComponent.processWidgetContent({
        reactElement: html,
        widget: this,
        reactComponent: parent.reactComponent
      });
    }
  }
  get html() {
    if (this.initializingElement || !this.element) {
      return this.content || this._html;
    }
    return this.contentElement.innerHTML;
  }
  updateHtml(html) {
    const me = this, isClearing = html == null, {
      element,
      contentElement,
      htmlCls
    } = me;
    if (!element && DomHelper.isReactElement(html)) {
      me.whenVisible(() => me.handleReactElement(html));
      return;
    }
    if (element) {
      me.updatingHtml = true;
      const anchorEl = contentElement === element && me._anchorElement;
      if (htmlCls) {
        htmlCls.values.forEach((value) => element.classList[isClearing ? "remove" : "add"](value));
      }
      if (anchorEl) {
        element.removeChild(anchorEl);
      }
      if (html && typeof html === "object") {
        if (DomHelper.isReactElement(html)) {
          me.handleReactElement(html);
        } else {
          DomSync.sync({
            domConfig: _objectSpread2(_objectSpread2({}, html), {}, {
              onlyChildren: true
            }),
            targetElement: me.contentElement
          });
        }
      } else {
        me.contentElement.innerHTML = isClearing ? "" : html;
      }
      me.getConfig("htmlMutationObserver");
      if (anchorEl) {
        element.appendChild(anchorEl);
      }
      if (me.isComposable) {
        me.recompose();
      } else if (me.floating || me.positioned) {
        if (!me.isAligning) {
          me.realign();
        }
      }
    }
  }
  changeHtmlMutationObserver(htmlMutationObserver, was) {
    const me = this, {
      contentElement
    } = me;
    was === null || was === void 0 ? void 0 : was.disconnect(contentElement);
    if (htmlMutationObserver) {
      const result = new MutationObserver(() => {
        if (me.updatingHtml) {
          me.updatingHtml = false;
        } else {
          me._html = contentElement.innerHTML;
        }
      });
      result.observe(contentElement, htmlMutationObserver);
      return result;
    }
  }
  updateContent(html) {
    const me = this, isClearing = html == null, {
      element,
      htmlCls
    } = me;
    if (element) {
      const {
        contentRange
      } = me;
      if (htmlCls) {
        htmlCls.values.forEach((value) => element.classList[isClearing ? "remove" : "add"](value));
      }
      if (isInDocument(element)) {
        contentRange.deleteContents();
        if (!isClearing) {
          contentRange.insertNode(DomHelper.createElementFromTemplate(html, {
            fragment: true
          }));
        }
      } else {
        me.contentElement.innerHTML = html;
      }
      me.contentRangeStartOffset = contentRange.startOffset;
      me.contentRangeEndOffset = contentRange.endOffset;
      if ((me.floating || me.positioned) && !me.isAligning) {
        me.realign();
      }
    }
  }
  onThemeChange() {
    var _this$anchorElement;
    if ((_this$anchorElement = this.anchorElement) !== null && _this$anchorElement !== void 0 && _this$anchorElement.offsetParent) {
      this._anchorSize = null;
      this.realign();
    }
  }
  get anchorSize() {
    const me = this;
    let result = this._anchorSize;
    if (!result) {
      const borderWidth = parseFloat(DomHelper.getStyleValue(me.element, "border-top-width")), borderColour = DomHelper.getStyleValue(me.element, "border-top-color"), anchorElement = me.anchorElement, {
        className
      } = anchorElement, svgEl = anchorElement.firstElementChild, pathElement = me.anchorPathElement = svgEl.lastElementChild, hidden = me._hidden;
      anchorElement.className = "b-anchor b-anchor-top";
      let backgroundColour = DomHelper.getStyleValue(me.contentElement, "background-color");
      if (backgroundColour.match(isTransparent)) {
        backgroundColour = DomHelper.getStyleValue(me.element, "background-color");
      }
      me.defaultAnchorBackgroundColor = backgroundColour;
      result = anchorElement.getBoundingClientRect();
      const [width, height] = result = me._anchorSize = [result.width, result.height];
      anchorElement.className = className;
      svgEl.setAttribute("height", height + borderWidth);
      svgEl.setAttribute("width", width);
      pathElement.setAttribute("d", `M0,${height}L${width / 2},0.5L${width},${height}`);
      if (borderWidth) {
        pathElement.setAttribute("stroke-width", borderWidth);
        pathElement.setAttribute("stroke", borderColour);
      }
      result[1] -= borderWidth;
      if (hidden) {
        me.element.classList.add("b-hidden");
      }
      if (!me.themeChangeListener) {
        me.themeChangeListener = GlobalEvents$1.ion({
          theme: "onThemeChange",
          thisObj: me
        });
      }
      me.anchorPathElement.setAttribute("fill", me.defaultAnchorBackgroundColor);
    }
    return result;
  }
  get anchorElement() {
    const me = this;
    if (!me._anchorElement) {
      const useFilter = me.floating, filterId = `${me.id}-shadow-filter`;
      me._anchorElement = DomHelper.createElement({
        parent: me.element,
        className: "b-anchor b-anchor-top",
        children: [{
          tag: "svg",
          ns: "http://www.w3.org/2000/svg",
          version: "1.1",
          class: "b-pointer-el",
          children: [useFilter ? {
            tag: "defs",
            children: [{
              tag: "filter",
              id: filterId,
              children: [{
                tag: "feDropShadow",
                dx: 0,
                dy: -1,
                stdDeviation: 1,
                "flood-opacity": 0.2
              }]
            }]
          } : null, {
            tag: "path",
            [useFilter ? "filter" : ""]: `url(#${filterId})`
          }]
        }]
      });
    }
    return me._anchorElement;
  }
  updateAnchor(anchor) {
    if (this._anchorElement) {
      this._anchorElement.classList[anchor ? "remove" : "add"]("b-hide-display");
    }
  }
  updateDraggable(draggable) {
    const me = this, {
      element
    } = me;
    if (draggable) {
      me.dragEventDetacher = EventHelper.addListener({
        element,
        dragstart: "onWidgetDragStart",
        dragend: "onWidgetDragEnd",
        thisObj: me
      });
      me.dragDetacher = EventHelper.on({
        element,
        mousedown(event) {
          const {
            target
          } = event, closestWidget = Widget.fromElement(target);
          if (!event.target.closest(".b-field-inner") && closestWidget === this || this.strips && Object.values(this.strips).includes(closestWidget)) {
            element.setAttribute("draggable", "true");
          }
        },
        thisObj: me
      });
    } else {
      var _me$dragEventDetacher2, _me$dragOverEventDeta2, _me$dragDetacher;
      (_me$dragEventDetacher2 = me.dragEventDetacher) === null || _me$dragEventDetacher2 === void 0 ? void 0 : _me$dragEventDetacher2.call(me);
      (_me$dragOverEventDeta2 = me.dragOverEventDetacher) === null || _me$dragOverEventDeta2 === void 0 ? void 0 : _me$dragOverEventDeta2.call(me);
      (_me$dragDetacher = me.dragDetacher) === null || _me$dragDetacher === void 0 ? void 0 : _me$dragDetacher.call(me);
    }
  }
  onWidgetDragStart(e) {
    var _ref2;
    const me = this;
    if (!me.validateDragStartEvent(e)) {
      return;
    }
    const {
      element,
      align,
      constrainTo
    } = me, positioned = me.positioned && DomHelper.getStyleValue(element, "position") !== "fixed", parentElement = positioned ? element.parentElement : me.rootElement, myRect = Rectangle.from(element, positioned ? parentElement : null), dragStartX = e.clientX, dragStartY = e.clientY, scrollingPageElement = document.scrollingElement || document.body, [widgetX, widgetY] = positioned ? DomHelper.getOffsetXY(element, parentElement) : me.getXY(), constrainRect = (_ref2 = positioned ? Rectangle.content(parentElement).moveTo(0, 0) : constrainTo && (constrainTo !== null && constrainTo !== void 0 && constrainTo.isRectangle ? constrainTo : Rectangle.from(constrainTo))) === null || _ref2 === void 0 ? void 0 : _ref2.deflate(align.constrainPadding || 0), dragListeners = {
      element: parentElement,
      dragover: (event) => {
        element.classList.remove("b-centered");
        myRect.moveTo(widgetX + event.clientX - dragStartX - (positioned ? 0 : scrollingPageElement.scrollLeft), widgetY + event.clientY - dragStartY - (positioned ? 0 : scrollingPageElement.scrollTop));
        if (constrainRect) {
          myRect.constrainTo(constrainRect);
        }
        DomHelper.setTranslateXY(element, myRect.x, myRect.y);
      }
    };
    if (BrowserHelper.isTouchDevice) {
      dragListeners.touchmove = (e13) => e13.preventDefault();
    }
    me.floatRoot.appendChild(me.dragGhost);
    me.setDragImage(e);
    e.dataTransfer.effectAllowed = "none";
    me.dragOverEventDetacher = EventHelper.addListener(dragListeners);
    me.alignTo();
  }
  validateDragStartEvent(e) {
    const me = this, {
      element
    } = me, actualTarget = DomHelper.elementFromPoint(e.clientX, e.clientY), {
      handleSelector
    } = me.draggable;
    if (handleSelector) {
      var _negationPseudo$exec;
      const blacklist = (_negationPseudo$exec = negationPseudo.exec(handleSelector)) === null || _negationPseudo$exec === void 0 ? void 0 : _negationPseudo$exec[1];
      if (blacklist) {
        if (actualTarget.closest(`#${element.id} ${blacklist}`)) {
          e.preventDefault();
          return false;
        }
      } else if (!actualTarget.closest(`#${element.id} ${handleSelector}`)) {
        e.preventDefault();
        return false;
      }
    }
    return true;
  }
  setDragImage(e) {
    if (e.dataTransfer.setDragImage) {
      e.dataTransfer.setData("application/node type", "");
      e.dataTransfer.setDragImage(this.dragGhost, -9999, -9999);
    }
  }
  setStyle(name, value) {
    DomHelper.applyStyle(this.element, ObjectHelper.isObject(name) ? name : {
      [name]: value
    });
    return this;
  }
  onWidgetDragEnd() {
    this.dragGhost.remove();
    this.dragOverEventDetacher();
    this.element.removeAttribute("draggable");
  }
  changeFloating(value) {
    return Boolean(value);
  }
  changePositioned(value) {
    return Boolean(value);
  }
  updatePositioned(positioned) {
    this.element.classList[positioned ? "add" : "remove"]("b-positioned");
  }
  getXY() {
    return [DomHelper.getPageX(this.element), DomHelper.getPageY(this.element)];
  }
  setXY(x, y) {
    const me = this, {
      element
    } = me;
    if (me.floating || me.positioned) {
      if (x != null) {
        me._x = x;
      }
      if (y != null) {
        me._y = y;
      }
      if (DomHelper.getStyleValue(element, "position") === "fixed") {
        const r = element.getBoundingClientRect(), [cx, cy] = DomHelper.getTranslateXY(element), xDelta = x - r.x, yDelta = y - r.y;
        DomHelper.setTranslateXY(element, cx + xDelta, cy + yDelta);
      } else {
        DomHelper.setTranslateXY(element, me._x || 0, me._y || 0);
      }
      if (me.isConstructing) {
        me.centered = false;
      } else {
        element.classList.remove("b-centered");
      }
    }
  }
  get x() {
    return this.getXY()[0];
  }
  changeX(x) {
    this.setXY(x);
  }
  get y() {
    return this.getXY()[1];
  }
  changeY(y) {
    this.setXY(null, y);
  }
  get width() {
    const me = this, element = me.element;
    if (me.monitorResize) {
      if (me._width == null) {
        me._width = element.offsetWidth;
      }
      return me._width;
    }
    return element.offsetWidth;
  }
  changeWidth(width) {
    const me = this;
    DomHelper.setLength(me.element, "width", width);
    me._lastWidth = width;
    me._width = null;
    me._flex = null;
    me.element.style.flex = "";
  }
  clearWidthCache() {
    this._width = null;
  }
  get maxWidth() {
    return DomHelper.measureSize(this.element.style.maxWidth, this.element);
  }
  updateMaxWidth(maxWidth) {
    DomHelper.setLength(this.element, "maxWidth", maxWidth);
  }
  get minWidth() {
    return DomHelper.measureSize(this.element.style.minWidth, this.element);
  }
  updateMinWidth(minWidth) {
    DomHelper.setLength(this.element, "minWidth", minWidth);
  }
  updateFlex(flex) {
    this.getConfig("width");
    if (typeof flex === "number" || !isNaN(flex)) {
      flex = `${flex} ${flex}`;
    }
    this.element.style.flex = flex;
    this.element.style.width = "";
  }
  updateAlignSelf(alignSelf) {
    this.element.style.alignSelf = alignSelf;
  }
  updateMargin(margin) {
    this.element.style.margin = this.parseTRBL(margin).join(" ");
  }
  updateTextAlign(align, oldAlign) {
    oldAlign && this.element.classList.remove(`b-text-align-${oldAlign}`);
    this.element.classList.add(`b-text-align-${align}`);
  }
  updatePlaceholder(placeholder) {
    if (this.input) {
      if (placeholder == null) {
        this.input.removeAttribute("placeholder");
      } else {
        this.input.placeholder = placeholder;
      }
    }
  }
  get height() {
    const me = this, element = me.element;
    if (me.monitorResize) {
      if (me._height == null) {
        me._height = element.offsetHeight;
      }
      return me._height;
    }
    return element.offsetHeight;
  }
  changeHeight(height) {
    DomHelper.setLength(this.element, "height", height);
    this._lastHeight = height;
    this._height = null;
  }
  get maxHeight() {
    return DomHelper.measureSize(this.maxHeightElement.style.maxHeight, this.element);
  }
  updateMaxHeight(maxHeight) {
    DomHelper.setLength(this.maxHeightElement, "maxHeight", maxHeight);
  }
  get minHeight() {
    return DomHelper.measureSize(this.element.style.minHeight, this.element);
  }
  updateMinHeight(minHeight) {
    DomHelper.setLength(this.element, "minHeight", minHeight);
  }
  updateDisabled(disabled = false) {
    const {
      element,
      focusElement,
      ariaElement
    } = this;
    this.trigger("beforeUpdateDisabled", {
      disabled
    });
    if (disabled) {
      this.revertFocus();
      if (this._disabled !== disabled) {
        return;
      }
    }
    if (element) {
      element.classList[disabled ? "add" : "remove"]("b-disabled");
      if (focusElement) {
        focusElement.disabled = disabled;
      }
      if (ariaElement) {
        ariaElement.setAttribute("aria-disabled", disabled);
      }
    }
    this.onDisabled(disabled);
  }
  onDisabled(disabled) {
  }
  disable() {
    this.disabled = true;
  }
  enable() {
    this.disabled = false;
  }
  requestFullscreen() {
    const me = this, result = Fullscreen.request(me.floating ? me.floatRoot : me.element);
    Fullscreen.onFullscreenChange(me.onFullscreenChange);
    if (!me.floating) {
      me.floatRoot._oldParent = me.floatRoot.parentElement;
      me.element.appendChild(me.floatRoot);
    }
    me.element.classList.add("b-fullscreen");
    return result;
  }
  exitFullscreen() {
    return Fullscreen.exit();
  }
  onFullscreenChange() {
    if (!Fullscreen.isFullscreen) {
      this.onExitFullscreen();
    }
  }
  onExitFullscreen() {
    var _me$_rootElement;
    const me = this, floatRoot = (_me$_rootElement = me._rootElement) === null || _me$_rootElement === void 0 ? void 0 : _me$_rootElement.floatRoot;
    Fullscreen.unFullscreenChange(me.onFullscreenChange);
    me.element.classList.remove("b-fullscreen");
    if (me.element.contains(floatRoot) && floatRoot !== null && floatRoot !== void 0 && floatRoot._oldParent) {
      floatRoot._oldParent.appendChild(floatRoot);
      floatRoot._oldParent = null;
    }
  }
  get tooltip() {
    if (this._tooltip) {
      return this._tooltip;
    } else {
      var _Widget$Tooltip2;
      const tooltip = (_Widget$Tooltip2 = Widget.Tooltip) === null || _Widget$Tooltip2 === void 0 ? void 0 : _Widget$Tooltip2.getSharedTooltip(this.rootElement);
      if (tooltip && tooltip.activeTarget === this._element && tooltip.isVisible) {
        return tooltip;
      }
    }
  }
  changeTooltip(tooltip, oldTooltip) {
    const me = this, {
      element
    } = me;
    if (tooltip) {
      if (!(me.preventTooltipOnTouch && BrowserHelper.isTouchDevice)) {
        if (!tooltip.isTooltip && tooltip.constructor.name !== "Object") {
          tooltip = {
            html: typeof tooltip === "string" ? tooltip : me.placeholder,
            textContent: true
          };
        }
        if (!me.configureAriaDescription) {
          var _tooltip$html;
          me.ariaDescription = (_tooltip$html = tooltip.html) !== null && _tooltip$html !== void 0 && _tooltip$html.match(localizeRE) ? tooltip.html.replace(localizeRE, localizeTooltip) : tooltip.html;
        }
        if (oldTooltip !== null && oldTooltip !== void 0 && oldTooltip.isTooltip || tooltip.newInstance) {
          tooltip.type = "tooltip";
          if (!tooltip.forElement)
            tooltip.forElement = element;
          if (!("showOnHover" in tooltip) && !tooltip.forSelector)
            tooltip.showOnHover = true;
          if (!("autoClose" in tooltip))
            tooltip.autoClose = true;
          tooltip = Widget.reconfigure(oldTooltip, tooltip, me);
          me.detachListeners("tooltipValueListener");
          if (!me.configureAriaDescription) {
            tooltip.ion({
              name: "tooltipValueListener",
              innerHtmlUpdate: "onTooltipValueChange",
              thisObj: me
            });
          }
        } else {
          element.dataset.btip = true;
          me.tipConfig = tooltip;
          return;
        }
      }
    } else {
      if (oldTooltip) {
        if (tooltip == null && oldTooltip.isTooltip) {
          oldTooltip.destroy();
        } else {
          oldTooltip.html = null;
          return;
        }
      } else {
        delete element.dataset.btip;
      }
    }
    return tooltip;
  }
  onTooltipValueChange({
    value,
    source
  }) {
    this.ariaDescription = typeof value == "string" ? value : source.contentElement.innerText;
  }
  get tooltipText() {
    const tooltip = this._tooltip;
    if (tooltip) {
      return tooltip.isTooltip ? tooltip.contentElement.innerText : typeof tooltip === "string" ? tooltip : tooltip.html;
    } else if (this.tipConfig) {
      return this.tipConfig.html;
    }
  }
  get isVisible() {
    const me = this, {
      element
    } = me;
    let owner;
    return Boolean(element && !me._hidden && !me.isDestroying && isInDocument(element) && (!me.requireSize || hasLayout(element)) && (!(owner = me.containingWidget) || owner.isVisible));
  }
  whenVisible(callback, thisObj = this, args, id = callback) {
    const me = this;
    if (me.isVisible && me.isPainted) {
      me.callback(callback, thisObj, args);
    } else {
      (me.toCallWhenVisible || (me.toCallWhenVisible = /* @__PURE__ */ new Map())).set(id, {
        callback,
        thisObj,
        args
      });
    }
  }
  focus() {
    if (this.isFocusable) {
      DomHelper.focusWithoutScrolling(this.focusElement);
    }
  }
  get focusElement() {
  }
  get isFocusable() {
    const focusElement = !this.isDestroying && this.isVisible && !this.disabled && this.focusElement;
    return focusElement && (focusElement === document.body || focusElement.offsetParent);
  }
  async show({
    align,
    animate = true
  } = {}) {
    const me = this, {
      element,
      floating
    } = me, {
      style
    } = element, showAnimation = animate && me.showAnimation;
    let styleProp, animProps, trigger = !me.isVisible;
    if (trigger) {
      trigger = me.trigger("beforeShow");
      if (ObjectHelper.isPromise(trigger)) {
        trigger = await trigger;
      }
    }
    if (trigger !== false && (!me.internalBeforeShow || me.internalBeforeShow() !== false)) {
      return new Promise((resolve) => {
        me.cancelHideShowAnimation();
        me.updateCentered(me._centered);
        if (floating) {
          const floatRoot = me.floatRoot;
          if (!floatRoot.contains(element)) {
            if (me.rendered) {
              floatRoot.appendChild(me.element);
            } else {
              me.render(floatRoot, false);
            }
          }
          if (style.transform.includes("scale")) {
            me.scale = null;
            style.transform = style.transformOrigin = "";
          }
          const scaledAncestor = me.closest(isScaled);
          if (scaledAncestor) {
            const {
              scale
            } = scaledAncestor;
            me.scale = scale;
            style.transform = `scale(${scale})`;
            style.transformOrigin = `0 0`;
          }
        }
        me._hidden = false;
        element.classList.remove("b-hidden");
        if (floating && !isVisible(element)) {
          me.hide(false);
          resolve();
        }
        me.onConfigChange({
          name: "hidden",
          value: false,
          was: true,
          config: me.$meta.configs.hidden
        });
        if (showAnimation) {
          styleProp = Object.keys(showAnimation)[0];
          animProps = showAnimation[styleProp];
          const currentAnimation = me.currentAnimation = {
            showing: true,
            styleProp,
            resolve
          };
          me.isAnimating = true;
          me.currentAnimation.detacher = EventHelper.onTransitionEnd({
            element,
            property: styleProp,
            duration: parseDuration(animProps.duration) + 20,
            handler: () => me.afterHideShowAnimate(currentAnimation),
            thisObj: me
          });
          style[styleProp] = animProps.from;
          DomHelper.getStyleValue(element, styleProp);
          style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
          style[styleProp] = animProps.to;
        }
        me.afterShow(align, !showAnimation ? resolve : null);
      });
    } else {
      return Promise.resolve();
    }
  }
  async showBy(align, yCoord, options) {
    const me = this, isArray2 = Array.isArray(align);
    if (isArray2 || typeof align === "number") {
      const xy = isArray2 ? align : [align, yCoord];
      align = Object.assign({
        target: new Point(xy[0] + 1, xy[1] + 1),
        matchSize: false,
        align: "t0-b0"
      }, isArray2 ? yCoord : options);
    }
    me.requireSize = true;
    if (me.isVisible) {
      DomHelper.addTemporaryClass(me.element, "b-realigning", 300, me);
      me.alignTo(align);
    } else {
      return me.show({
        align
      });
    }
  }
  async showByPoint() {
    VersionHelper.deprecate("Core", "6.0.0", "Widget.showByPoint() replaced by Widget.showBy() with the same signature");
    return this.showBy(...arguments);
  }
  afterShow(align, resolveFn) {
    var _me$owner, _me$owner$onChildShow;
    const me = this;
    me.trigger("show");
    me._configuredAnchorState = me.anchor;
    (_me$owner = me.owner) === null || _me$owner === void 0 ? void 0 : (_me$owner$onChildShow = _me$owner.onChildShow) === null || _me$owner$onChildShow === void 0 ? void 0 : _me$owner$onChildShow.call(_me$owner, me);
    me.triggerPaint();
    if (me.floating || me.positioned) {
      if (align) {
        me.alignTo(align);
      } else if (me.centered) {
        me.alignTo({
          target: me.constrainTo,
          align: "c-c"
        });
      } else if (me.forElement) {
        me.alignTo(me.forElement);
      }
    }
    resolveFn === null || resolveFn === void 0 ? void 0 : resolveFn();
  }
  onChildHide(hidden) {
    if (hidden.floating) {
      this.ariaElement.removeAttribute("aria-owns");
    }
  }
  onChildShow(shown) {
    if (shown.floating) {
      this.ariaHasPopup = shown.role;
      this.ariaElement.setAttribute("aria-owns", shown.id);
    }
  }
  triggerPaint() {
    const me = this, {
      element,
      toCallWhenVisible
    } = me, firstPaint = !me.isPainted;
    if (me.isVisible) {
      if (firstPaint) {
        me.getConfig("scrollable");
        if (me.scaleToFitWidth && !me.monitorResize) {
          me.onParentElementResize = me.onParentElementResize.bind(me);
          ResizeMonitor.addResizeListener(element.parentElement, me.onParentElementResize);
          me.updateScale();
        }
        if (!me.hideBryntumDomMessage && (me.isTaskBoardBase || me.isGridBase || me.isCalendar)) {
          element.insertBefore(new Comment("POWERED BY BRYNTUM (https://bryntum.com)"), element.firstChild);
        }
      }
      me.eachWidget(widgetTriggerPaint, false);
      if (firstPaint) {
        me.rootElement = DomHelper.getRootElement(element);
        me.getConfig("tooltip");
        if (!Widget.Ripple && Widget.RippleClass) {
          Widget.Ripple = new Widget.RippleClass({
            rootElement: me.rootElement
          });
        }
      }
      me.isPainted = true;
      firstPaint && me.triggerConfigs("paint");
      me.trigger("paint", {
        firstPaint
      });
      if (toCallWhenVisible !== null && toCallWhenVisible !== void 0 && toCallWhenVisible.size) {
        for (const {
          callback,
          thisObj,
          args
        } of toCallWhenVisible.values()) {
          me.callback(callback, thisObj, args);
        }
        toCallWhenVisible.clear();
      }
      if (firstPaint) {
        if (me.monitorResize && !me.scaleToFitWidth) {
          ResizeMonitor.onElementResize([{
            target: element
          }]);
        }
      }
    }
  }
  cancelHideShowAnimation() {
    const me = this, {
      currentAnimation,
      element
    } = me;
    if (currentAnimation) {
      me.isAnimating = false;
      if (element.classList.contains("b-hiding")) {
        element.classList.remove("b-hiding");
        me._hidden = false;
      }
      currentAnimation.detacher();
      currentAnimation.resolve();
      element.style.transition = element.style[currentAnimation.styleProp] = "";
      me.currentAnimation = null;
      me.trigger(`${currentAnimation.showing ? "show" : "hide"}AnimationEnd`);
    }
  }
  afterHideShowAnimate(currentAnimation) {
    const me = this;
    if (currentAnimation === me.currentAnimation) {
      me.element.classList.remove("b-hiding");
      me.cancelHideShowAnimation();
      if (me._hidden) {
        me.afterHideAnimation();
      }
    }
  }
  suspendVisibility() {
    this._visibilitySuspended = (this._visibilitySuspended || 0) + 1;
    Object.defineProperty(this, "isVisible", returnFalseProp);
  }
  resumeVisibility(triggerPaint = true) {
    if (!--this._visibilitySuspended) {
      delete this.isVisible;
      if (triggerPaint) {
        this.triggerPaint();
      }
    }
  }
  hide(animate = true) {
    return new Promise((resolve) => {
      const me = this, {
        element,
        lastAlignSpec
      } = me, {
        style
      } = element, hideAnimation = animate && me.hideAnimation;
      me.clearTimeout(me.scrollListenerTimeout);
      me.clearTimeout(me.resizeListenerTimeout);
      if (!me._hidden && me.trigger("beforeHide", {
        animate
      }) !== false) {
        me._hidden = true;
        if (lastAlignSpec) {
          lastAlignSpec.targetOutOfView = null;
          if (lastAlignSpec.monitorIntersection) {
            me.intersectionObserver.takeRecords();
            me.intersectionObserver.unobserve(lastAlignSpec.target);
          }
        }
        me.onConfigChange({
          name: "hidden",
          value: true,
          was: false,
          config: me.$meta.configs.hidden
        });
        if (!element) {
          resolve();
          return;
        }
        if (element.contains(DomHelper.getActiveElement(element))) {
          me.revertFocus(true);
        }
        if (me.isDestroyed) {
          resolve();
          return;
        }
        me.cancelHideShowAnimation();
        if (hideAnimation) {
          const styleProp = Object.keys(hideAnimation)[0], animProps = hideAnimation[styleProp];
          if (Number(getComputedStyle(me.element)[styleProp]) !== animProps.to) {
            const currentAnimation = me.currentAnimation = {
              hiding: true,
              styleProp,
              resolve
            };
            element.classList.add("b-hiding");
            me.isAnimating = true;
            me.currentAnimation.detacher = EventHelper.onTransitionEnd({
              element,
              property: styleProp,
              duration: parseDuration(animProps.duration) + 20,
              handler: () => me.afterHideShowAnimate(currentAnimation),
              thisObj: me
            });
            style[styleProp] = animProps.from;
            DomHelper.getStyleValue(element, styleProp);
            style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
            style[styleProp] = animProps.to;
          } else {
            element.classList.add("b-hidden");
          }
        } else {
          element.classList.add("b-hidden");
        }
        me.afterHide(!hideAnimation && resolve, hideAnimation);
      }
    });
  }
  doHideOrRealign({
    target,
    isTrusted
  }) {
    const me = this, {
      lastAlignSpec,
      element
    } = me, anchoredTo = lastAlignSpec === null || lastAlignSpec === void 0 ? void 0 : lastAlignSpec.anchoredTo, lastTarget = lastAlignSpec === null || lastAlignSpec === void 0 ? void 0 : lastAlignSpec.target, position = lastAlignSpec === null || lastAlignSpec === void 0 ? void 0 : lastAlignSpec.position, activeEl = DomHelper.getActiveElement(me);
    if (!isTrusted || !hasLayout(element) || target && (element.contains(target) || target.nodeType === Element.DOCUMENT_NODE && element.contains(activeEl) && textInputTypes[activeEl] && globalThis.innerHeight < document.body.offsetHeight)) {
      return;
    }
    if (lastAlignSpec.aligningToElement) {
      const newTarget = DomHelper.isInView(lastTarget, false, me);
      if (newTarget && newTarget.equals(lastAlignSpec.targetRect)) {
        return;
      }
    }
    const xy = me.scrollAction === "hide" && me.getXY();
    me.realign();
    if (!me.isDestroyed && isVisible(element) && me.scrollAction === "hide") {
      const [newX, newY] = me.getXY(), moved = newX !== xy[0] || newY !== xy[1];
      if ((moved || (lastTarget === null || lastTarget === void 0 ? void 0 : lastTarget.$$name) === "Point" || position) && (!anchoredTo || !hasLayout(anchoredTo) || target && DomHelper.isDescendant(target, anchoredTo))) {
        me.hide();
      }
    }
  }
  afterHide(resolveFn = null, hideAnimation = this.hideAnimation) {
    var _me$owner2, _me$owner2$onChildHid;
    const me = this;
    me._anchor = me._configuredAnchorState;
    me.removeTransientListeners();
    if (!hideAnimation) {
      me.afterHideAnimation();
    }
    me.trigger("hide");
    (_me$owner2 = me.owner) === null || _me$owner2 === void 0 ? void 0 : (_me$owner2$onChildHid = _me$owner2.onChildHide) === null || _me$owner2$onChildHid === void 0 ? void 0 : _me$owner2$onChildHid.call(_me$owner2, me);
    resolveFn && resolveFn();
  }
  removeTransientListeners() {
    var _me$documentScrollLis, _me$targetRootScrollL;
    const me = this, {
      targetObserver,
      lastAlignSpec
    } = me;
    me.clearTimeout(me.resizeListenerTimeout);
    me.clearTimeout(me.scrollListenerTimeout);
    if (targetObserver) {
      targetObserver.disconnect();
      delete me.targetObserver;
    }
    me.documentScrollListener = (_me$documentScrollLis = me.documentScrollListener) === null || _me$documentScrollLis === void 0 ? void 0 : _me$documentScrollLis.call(me);
    me.targetRootScrollListener = (_me$targetRootScrollL = me.targetRootScrollListener) === null || _me$targetRootScrollL === void 0 ? void 0 : _me$targetRootScrollL.call(me);
    if (me.targetResizeListener) {
      ResizeMonitor.removeResizeListener(lastAlignSpec.target, me.onTargetResize);
      me.targetResizeListener = false;
    }
    if (me.constrainListeners) {
      var _lastAlignSpec$constr;
      const el = (_lastAlignSpec$constr = lastAlignSpec.constrainTo) !== null && _lastAlignSpec$constr !== void 0 && _lastAlignSpec$constr.isRectangle ? globalThis : lastAlignSpec.constrainTo;
      ResizeMonitor.removeResizeListener(el || globalThis, me.onAlignConstraintChange);
      me.constrainListeners = false;
    }
  }
  afterHideAnimation() {
    const me = this, {
      element
    } = me;
    if (me.floating && me.floatRoot.contains(element)) {
      element.remove();
    } else {
      element.classList.add("b-hidden");
    }
    if (me.defaultAnchorBackgroundColor) {
      me.anchorPathElement.setAttribute("fill", me.defaultAnchorBackgroundColor);
    }
  }
  changeHidden(value) {
    const me = this;
    let ret;
    if (me.isConfiguring) {
      ret = Boolean(value);
      me.element.classList[value ? "add" : "remove"]("b-hidden");
    } else {
      me.trigger("beforeChangeHidden", {
        hidden: value
      });
      if (value) {
        me.hide();
      } else {
        me.show();
      }
    }
    return ret;
  }
  get assignedId() {
    return this.hasGeneratedId ? null : this.id;
  }
  get owner() {
    return this.parent || this._owner || this.containingWidget;
  }
  get containingWidget() {
    let result = this.parent;
    if (!result) {
      var _this$forElement, _this$element;
      const owningEl = ((_this$forElement = this.forElement) === null || _this$forElement === void 0 ? void 0 : _this$forElement.nodeType) === Element.ELEMENT_NODE ? this.forElement : (_this$element = this.element) === null || _this$element === void 0 ? void 0 : _this$element.parentNode;
      result = (owningEl === null || owningEl === void 0 ? void 0 : owningEl.closest(".b-widget")) && Widget.fromElement(owningEl);
    }
    return result;
  }
  get previousSibling() {
    return this.getSibling(-1);
  }
  get nextSibling() {
    return this.getSibling(1);
  }
  getSibling(increment) {
    const me = this, {
      parent
    } = me, siblings = parent ? parent.childItems : Array.from(me.element.parentElement.querySelectorAll(".b-widget"));
    return parent ? siblings[siblings.indexOf(me) + increment] : Widget.fromElement(siblings[siblings.indexOf(me.element) + increment]);
  }
  up(selector, deep, limit) {
    var _owner$closest;
    const {
      owner
    } = this;
    return selector ? owner === null || owner === void 0 ? void 0 : (_owner$closest = owner.closest) === null || _owner$closest === void 0 ? void 0 : _owner$closest.call(owner, selector, deep, limit) : owner;
  }
  closest(selector, deep, limit) {
    const limitType = typeof limit, numericLimit = limitType === "number", selectorLimit = limitType === "string";
    for (let result = this, steps = 1; result; result = result.owner, steps++) {
      if (Widget.widgetMatches(result, selector, deep)) {
        return result;
      }
      if (numericLimit && steps >= limit) {
        return;
      } else if (selectorLimit && Widget.widgetMatches(result, limit, deep)) {
        return;
      } else if (result === limit) {
        return;
      }
    }
  }
  owns(target) {
    if (target) {
      if ("eventPhase" in target) {
        target = target.target;
      }
      if (target.nodeType === Element.ELEMENT_NODE) {
        if (this.element.contains(target)) {
          return true;
        }
        target = Widget.fromElement(target);
      }
      while (target) {
        if (target === this) {
          return true;
        }
        target = target.owner;
      }
    }
    return false;
  }
  eachAncestor(fn) {
    let ancestor = this.owner;
    while (ancestor) {
      if (fn(ancestor) === false) {
        return false;
      }
      ancestor = ancestor.owner;
    }
    return true;
  }
  changeMonitorResize(monitorResize, oldMonitorResize) {
    const result = this.scaleToFitWidth ? false : Boolean(monitorResize);
    if (result !== Boolean(oldMonitorResize)) {
      return result;
    }
  }
  updateMonitorResize(monitorResize) {
    const me = this;
    if (!hasOwnProperty$2.call(me, "onElementResize")) {
      me.onElementResize = me.onElementResize.bind(me);
    }
    ResizeMonitor[monitorResize ? "addResizeListener" : "removeResizeListener"](me.element, me.onElementResize);
  }
  changeReadOnly(readOnly) {
    readOnly = Boolean(readOnly);
    if (Boolean(this._readOnly) !== readOnly) {
      return readOnly;
    }
  }
  updateReadOnly(readOnly) {
    var _this$element2;
    (_this$element2 = this.element) === null || _this$element2 === void 0 ? void 0 : _this$element2.classList[readOnly ? "add" : "remove"]("b-readonly");
    if (!this.isConfiguring) {
      this.eachWidget((widget) => {
        if (widget.ignoreParentReadOnly) {
          return;
        }
        if (!("_originalReadOnly" in widget)) {
          widget._originalReadOnly = widget.config.readOnly || false;
        }
        widget.readOnly = readOnly || widget._originalReadOnly;
      }, false);
      this.trigger("readOnly", {
        readOnly
      });
    }
  }
  eachWidget(fn, deep = true) {
    const widgets = this.childItems, length = (widgets === null || widgets === void 0 ? void 0 : widgets.length) || 0, control = {};
    for (let i = 0; i < length; i++) {
      const widget = widgets[i];
      control.down = deep;
      if (fn(widget, control) === false) {
        return false;
      }
      if (control.down && widget.eachWidget) {
        if (widget.eachWidget(fn, deep) === false) {
          return false;
        }
      }
    }
    return true;
  }
  queryAll(filter) {
    const result = [];
    this.eachWidget((w) => {
      if (filter(w)) {
        result.push(w);
      }
    });
    return result;
  }
  query(filter) {
    let result = null;
    this.eachWidget((w) => {
      if (filter(w)) {
        result = w;
        return false;
      }
    });
    return result;
  }
  getWidgetByRef(ref) {
    var _this$widgetMap, _this$owner;
    if (ref instanceof Widget) {
      return ref;
    }
    return (this === null || this === void 0 ? void 0 : (_this$widgetMap = this.widgetMap) === null || _this$widgetMap === void 0 ? void 0 : _this$widgetMap[ref]) || (this === null || this === void 0 ? void 0 : (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.getWidgetByRef(ref));
  }
  onFocusIn(e) {
    const me = this, {
      element
    } = me;
    me.containsFocus = true;
    me.focusInEvent = e;
    element.classList.add("b-contains-focus");
    me.updateAriaLabel(me.localizeProperty("ariaLabel"));
    me.updateAriaDescription(me.localizeProperty("ariaDescription"));
    if (element.contains(e._target) && me.onInternalKeyDown && !me.keyDownListenerRemover) {
      me.keyDownListenerRemover = EventHelper.on({
        element,
        keydown: "onInternalKeyDown",
        thisObj: me
      });
    }
    me.trigger("focusin", e);
  }
  onFocusOut(e) {
    const me = this;
    if (me.keyDownListenerRemover) {
      me.keyDownListenerRemover();
      me.keyDownListenerRemover = null;
    }
    if (!me.isDestroyed) {
      if (!e.relatedTarget) {
        me.revertFocus(!me.isVisible);
      }
      me.containsFocus = false;
      me.element.classList.remove("b-contains-focus");
      me.updateAriaLabel(me.localizeProperty("ariaLabel"));
      me.updateAriaDescription(me.localizeProperty("ariaDescription"));
      me.trigger("focusout", e);
    }
  }
  captureFocus() {
    const me = this, activeElementWas = DomHelper.getActiveElement(me), restore = me.contains(activeElementWas) && me.captureFocusItem(activeElementWas);
    return (scrollIntoView, force) => {
      if (restore && !me.isDestroying) {
        const activeElementNow = DomHelper.getActiveElement(me);
        if (activeElementNow !== activeElementWas || force) {
          restore(scrollIntoView);
        }
      }
    };
  }
  captureFocusItem(activeElement) {
    return (scrollIntoView = true) => {
      if (this.contains(activeElement)) {
        scrollIntoView ? activeElement.focus() : DomHelper.focusWithoutScrolling(activeElement);
      }
    };
  }
  contains(elementOrWidget, strict) {
    const {
      element
    } = this;
    if (elementOrWidget && element) {
      if (elementOrWidget.isWidget) {
        elementOrWidget = elementOrWidget.element;
      }
      return element.contains(elementOrWidget) && (!strict || element !== elementOrWidget);
    }
  }
  revertFocus(force) {
    var _me$focusInEvent, _target;
    const me = this, activeElement = DomHelper.getActiveElement(me);
    let target = (_me$focusInEvent = me.focusInEvent) === null || _me$focusInEvent === void 0 ? void 0 : _me$focusInEvent.relatedTarget;
    if (force || me.containsFocus && ((_target = target) === null || _target === void 0 ? void 0 : _target.nodeType) === Element.ELEMENT_NODE && me.element.contains(activeElement)) {
      if (!target || !DomHelper.isFocusable(target)) {
        target = me.getFocusRevertTarget();
      }
      me._isRevertingFocus = true;
      if (target && DomHelper.isFocusable(target)) {
        target._isRevertingFocus = true;
        DomHelper.focusWithoutScrolling(target);
        target._isRevertingFocus = false;
      } else {
        activeElement === null || activeElement === void 0 ? void 0 : activeElement.blur();
      }
      me._isRevertingFocus = false;
    }
  }
  getFocusRevertTarget() {
    const me = this, {
      owner,
      focusInEvent
    } = me, searchDirection = focusInEvent ? focusInEvent.backwards ? 1 : -1 : -1;
    let target = focusInEvent && focusInEvent.relatedTarget;
    const toComponent = target && Widget.fromElement(target);
    if (owner && !owner.isDestroyed && (!target || !DomHelper.isFocusable(target) || toComponent && !toComponent.isFocusable)) {
      var _owner$getFocusRevert;
      target = null;
      if (owner.eachWidget) {
        const siblings = [];
        owner.eachWidget((w) => {
          if (w === me || w.isFocusable) {
            siblings.push(w);
          }
        }, false);
        if (siblings.length > 1) {
          const myIndex = siblings.indexOf(me);
          target = siblings[myIndex + searchDirection] || siblings[myIndex - searchDirection];
        }
      }
      if (!target && owner.isFocusable) {
        target = owner;
      }
      target = target ? target.focusElement : (_owner$getFocusRevert = owner.getFocusRevertTarget) === null || _owner$getFocusRevert === void 0 ? void 0 : _owner$getFocusRevert.call(owner);
    }
    return target;
  }
  getStaticWidgetClasses(topMostBase, suffix) {
    const classList = new DomClassList(), hierarchy = this.$meta.hierarchy;
    let cls, i, name, widgetClass, widgetClassProperty;
    for (i = hierarchy.indexOf(topMostBase); i < hierarchy.length; ++i) {
      var _widgetClassProperty;
      cls = hierarchy[i];
      widgetClassProperty = Reflect.getOwnPropertyDescriptor(cls.prototype, "widgetClass");
      if ((_widgetClassProperty = widgetClassProperty) !== null && _widgetClassProperty !== void 0 && _widgetClassProperty.get) {
        widgetClass = widgetClassProperty.get.call(this);
      } else {
        name = hasOwnProperty$2.call(cls, "$$name") || hasOwnProperty$2.call(cls, "$name") || hasOwnProperty$2.call(cls, "_$name") ? cls.$$name : cls.name;
        if (name.length < 3 || name.includes("$")) {
          console.warn(`Class "${name}" extending "${cls.$name}" should have "$name" static getter with no less than 3 chars.`);
        }
        widgetClass = `b-${name.toLowerCase()}`;
      }
      if (widgetClass) {
        classList.add(suffix ? widgetClass + suffix : widgetClass);
      }
    }
    return classList;
  }
  get rootUiClass() {
    return Widget;
  }
  get staticClassList() {
    const {
      $meta: meta
    } = this;
    let classList = meta.staticClassList;
    if (!classList) {
      meta.staticClassList = classList = this.getStaticWidgetClasses(Widget);
      BrowserHelper.isTouchDevice && classList.add("b-touch");
    }
    return classList;
  }
  get uiClasses() {
    this.getConfig("ui");
    return this._uiClasses;
  }
  get uiClassList() {
    this.getConfig("ui");
    return this._uiClassList;
  }
  get widgetClassList() {
    const me = this, {
      cls,
      defaultCls,
      uiClasses
    } = me;
    let {
      staticClassList
    } = me;
    if (defaultCls || cls) {
      staticClassList = staticClassList.clone();
      defaultCls && staticClassList.assign(defaultCls);
      cls && staticClassList.assign(cls);
    }
    const classList = staticClassList.values;
    uiClasses && classList.push(...uiClasses);
    me.floating && classList.push("b-floating");
    if (me.collapsify === "hide") {
      classList.push("b-collapsify-hide");
    }
    return classList;
  }
  changeCls(cls) {
    return DomClassList.from(cls);
  }
  changeContentElementCls(cls) {
    return DomClassList.from(cls);
  }
  changeHtmlCls(cls) {
    return DomClassList.from(cls);
  }
  changeDefaultCls(cls) {
    return DomClassList.from(cls, true);
  }
  changeUi(ui) {
    return DomClassList.from(ui);
  }
  updateUi(ui) {
    var _uiClassList;
    let uiClassList = null, cls, suffix;
    if (ui) {
      const staticClassList = this.getStaticWidgetClasses(this.rootUiClass);
      for (suffix in ui) {
        if (ui[suffix]) {
          for (cls in staticClassList) {
            if (staticClassList[cls]) {
              (uiClassList || (uiClassList = new DomClassList()))[`${cls}-ui-${suffix}`] = 1;
            }
          }
        }
      }
    }
    this._uiClasses = (_uiClassList = uiClassList) === null || _uiClassList === void 0 ? void 0 : _uiClassList.values;
    this._uiClassList = uiClassList;
  }
  fromCache(query, children = false, element = this.element) {
    if (!element)
      return null;
    const me = this;
    if (!me.cache[query]) {
      me.cache[query] = children ? DomHelper.children(element, query) : DomHelper.down(element, query);
    }
    return me.cache[query];
  }
  emptyCache() {
    this.cache = {};
  }
  changeMasked(mask, maskInstance) {
    var _this$masked;
    if (((_this$masked = this.masked) === null || _this$masked === void 0 ? void 0 : _this$masked.type) === "trial") {
      return;
    }
    if (mask === true || mask === "") {
      mask = "\xA0";
    }
    if (maskInstance && !maskInstance.isDestroyed) {
      if (typeof mask === "string") {
        maskInstance.text = mask;
        mask = maskInstance;
      } else if (mask) {
        maskInstance.setConfig(mask);
        mask = maskInstance;
      } else {
        maskInstance.destroy();
      }
    } else if (mask) {
      const Mask2 = Widget.resolveType("mask");
      mask = Mask2.mergeConfigs(this.maskDefaults, mask);
      mask.owner = this;
      mask = Mask2.mask(mask);
    }
    return mask || null;
  }
  onMaskAutoClose(mask) {
    if (mask.isDestroyed && mask === this.masked) {
      this.masked = null;
    }
  }
  mask(msg) {
    this.masked = msg;
    return this.masked;
  }
  unmask() {
    this.masked = null;
  }
  onInternalResize(element, width, height, oldWidth, oldHeight) {
    this._width = element.offsetWidth;
    this._height = element.offsetHeight;
  }
  onElementResize(resizedElement, lastRect) {
    const me = this, {
      element
    } = me, oldWidth = me._width, oldHeight = me._height, newWidth = element.offsetWidth, newHeight = element.offsetHeight;
    if (me.floating && lastRect) {
      me.onFloatingWidgetResize(...arguments);
    }
    if (!me.suspendResizeMonitor && (oldWidth !== newWidth || oldHeight !== newHeight)) {
      me.onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight);
      me.trigger("resize", {
        width: newWidth,
        height: newHeight,
        oldWidth,
        oldHeight
      });
    }
  }
  onFloatingWidgetResize(resizedElement, lastRect, myRect) {
    const me = this, {
      lastAlignSpec,
      constrainTo
    } = me;
    if (me.isVisible && lastAlignSpec && lastAlignSpec.target) {
      const heightChange = !lastRect || myRect.height !== lastRect.height, widthChange = !lastRect || myRect.width !== lastRect.width, failsConstraint = constrainTo && !Rectangle.from(constrainTo).contains(Rectangle.from(me.element, null, true));
      if (heightChange && lastAlignSpec.zone !== 2 || widthChange && lastAlignSpec.zone !== 1 || failsConstraint) {
        me.requestAnimationFrame(() => me.realign());
      }
    }
  }
  updateScale() {
    const me = this, element = me.element, parentElement = element.parentElement;
    if (!me.configuredWidth) {
      me.configuredWidth = me.width;
    }
    element.style.display = "none";
    const rect = Rectangle.client(parentElement), scale = rect.width / me.configuredWidth, adjustedScale = me.scale = me.allowGrowWidth ? Math.min(scale, 1) : scale;
    element.style.transform = `scale(${adjustedScale})`;
    element.style.transformOrigin = "top left";
    element.style.display = "";
    if (me.allowGrowWidth && scale > 1) {
      me.width = me.configuredWidth * scale;
    }
  }
  onParentElementResize(event) {
    this.updateScale();
  }
  parseTRBL(values, units = "px") {
    values = values || 0;
    if (typeof values === "number") {
      return [`${values}${units}`, `${values}${units}`, `${values}${units}`, `${values}${units}`];
    }
    const parts = values.split(" "), len = parts.length;
    if (len === 1) {
      parts[1] = parts[2] = parts[3] = parts[0];
    } else if (len === 2) {
      parts[2] = parts[0];
      parts[3] = parts[1];
    } else if (len === 3) {
      parts[3] = parts[1];
    }
    return [isFinite(parts[0]) ? `${parts[0]}${units}` : parts[0], isFinite(parts[1]) ? `${parts[1]}${units}` : parts[2], isFinite(parts[2]) ? `${parts[2]}${units}` : parts[3], isFinite(parts[3]) ? `${parts[3]}${units}` : parts[4]];
  }
  get documentRoot() {
    var _this$owner2;
    return ((_this$owner2 = this.owner) === null || _this$owner2 === void 0 ? void 0 : _this$owner2.documentRoot) || this.element.getRootNode();
  }
  get rootElement() {
    const me = this;
    if (!me._rootElement) {
      var _me$owner3;
      let root2 = ((_me$owner3 = me.owner) === null || _me$owner3 === void 0 ? void 0 : _me$owner3.rootElement) || DomHelper.getRootElement(me.forElement || (isInDocument(me.element) ? me.element : me.getRenderContext()[0] || me.element));
      if (!root2) {
        root2 = document.body;
      }
      me._rootElement = root2;
    }
    return me._rootElement;
  }
  get floatRoot() {
    var _me$owner4;
    const me = this, rootElement = me.rootElement || ((_me$owner4 = me.owner) === null || _me$owner4 === void 0 ? void 0 : _me$owner4.rootElement);
    let {
      floatRoot
    } = rootElement;
    if (!floatRoot) {
      var _DomHelper$getThemeIn;
      const {
        outerCls
      } = Widget, themeName = (_DomHelper$getThemeIn = DomHelper.getThemeInfo(null, rootElement)) === null || _DomHelper$getThemeIn === void 0 ? void 0 : _DomHelper$getThemeIn.name;
      if (!DomHelper.isValidFloatRootParent(rootElement)) {
        throw new Error("Attaching float root to wrong root");
      }
      if (themeName) {
        outerCls.push(`b-theme-${themeName.toLowerCase()}`);
      }
      floatRoot = rootElement.floatRoot = DomHelper.createElement({
        className: `b-float-root ${outerCls.join(" ")}`,
        parent: rootElement
      });
      floatRoots.push(floatRoot);
      if (BrowserHelper.isAndroid) {
        floatRoot.style.height = `${screen.height}px`;
        EventHelper.on({
          element: globalThis,
          orientationchange: () => floatRoot.style.height = `${screen.height}px`,
          thisObj: this
        });
      }
      if (!BrowserHelper.isHoverableDevice && globalThis.visualViewport) {
        EventHelper.on({
          element: globalThis.visualViewport,
          resize: ({
            target: viewport
          }) => floatRoot.style.height = `${viewport.height}px`,
          thisObj: this
        });
      }
      GlobalEvents$1.ion({
        theme: ({
          theme,
          prev
        }) => {
          floatRoot.classList.add(`b-theme-${theme.toLowerCase()}`);
          floatRoot.classList.remove(`b-theme-${prev.toLowerCase()}`);
        }
      });
    } else if (!rootElement.contains(floatRoot)) {
      rootElement.appendChild(floatRoot);
    }
    return floatRoot;
  }
  get floatRootMaxZIndex() {
    let max = 1;
    Array.from(this.floatRoot.children).forEach((child) => {
      const zIndex = parseInt(getComputedStyle(child).zIndex || 0, 10);
      if (zIndex > max) {
        max = zIndex;
      }
    });
    return max;
  }
  static resetFloatRootScroll() {
    floatRoots.forEach((floatRoot) => floatRoot.scrollTop = floatRoot.scrollLeft = 0);
  }
  static get floatRoots() {
    return floatRoots;
  }
  static removeFloatRoot(floatRoot) {
    floatRoots.splice(floatRoots.indexOf(floatRoot), 1);
  }
  static get outerCls() {
    const result = ["b-outer"], {
      platform
    } = BrowserHelper;
    if (platform) {
      result.push(`b-${platform}`);
    }
    if (BrowserHelper.isTouchDevice) {
      result.push("b-touch-events");
    }
    if (DomHelper.scrollBarWidth) {
      result.push("b-visible-scrollbar");
    } else {
      result.push("b-overlay-scrollbar");
    }
    if (BrowserHelper.isChrome) {
      result.push("b-chrome");
    } else if (BrowserHelper.isSafari) {
      result.push("b-safari");
    } else if (BrowserHelper.isFirefox) {
      result.push("b-firefox");
    }
    if (!globalThis.ResizeObserver) {
      result.push("b-no-resizeobserver");
    }
    return result;
  }
  get isAnimating() {
    return this._isAnimatingCounter > 0;
  }
  set isAnimating(value) {
    const me = this, {
      _isAnimatingCounter
    } = me;
    me._isAnimatingCounter = Math.max(0, _isAnimatingCounter + (value ? 1 : -1));
    if (_isAnimatingCounter === 0 && value) {
      me.element.classList.add("b-animating");
      me.trigger("animationStart");
    } else if (_isAnimatingCounter === 1 && !value) {
      me.element.classList.remove("b-animating");
      me.trigger("animationEnd");
    }
  }
  async waitForAnimations() {
    if (this.isAnimating) {
      await this.await("animationend", {
        checkLog: false
      });
    }
  }
  static query(selector, deep = false) {
    const {
      idMap
    } = Widget.identifiable;
    for (const id in idMap) {
      if (Widget.widgetMatches(idMap[id], selector, deep)) {
        return idMap[id];
      }
    }
    return null;
  }
  static queryAll(selector, deep = false) {
    const {
      idMap
    } = Widget.identifiable, result = [];
    for (const id in idMap) {
      if (Widget.widgetMatches(idMap[id], selector, deep)) {
        result.push(idMap[id]);
      }
    }
    return result;
  }
  static fromElement(element, type, limit) {
    const typeOfType = typeof type;
    if (element && !element.nodeType) {
      element = element.target;
    }
    if (typeOfType === "number" || type && type.nodeType === Element.ELEMENT_NODE) {
      limit = type;
      type = null;
    }
    let target = element, depth = 0, topmost, cmpId, cmp;
    if (typeof limit !== "number") {
      topmost = limit;
      limit = Number.MAX_VALUE;
    }
    if (typeOfType === "string") {
      type = type.toLowerCase();
    }
    while (target && target.nodeType === Element.ELEMENT_NODE && depth < limit && target !== topmost) {
      cmpId = target.dataset && target.dataset.ownerCmp || target.id;
      if (cmpId) {
        cmp = Widget.getById(cmpId);
        if (cmp) {
          if (type) {
            if (typeOfType === "function") {
              if (type(cmp)) {
                return cmp;
              }
            } else if (Widget.widgetMatches(cmp, type, true)) {
              return cmp;
            }
          } else {
            return cmp;
          }
        }
        depth++;
      }
      target = target.parentNode;
    }
    return null;
  }
  triggerFieldChange(params, trigger = true) {
    if (trigger) {
      this.trigger("change", params);
    }
    this.eachAncestor((ancestor) => {
      var _ancestor$onFieldChan, _ancestor$isolateFiel;
      (_ancestor$onFieldChan = ancestor.onFieldChange) === null || _ancestor$onFieldChan === void 0 ? void 0 : _ancestor$onFieldChan.call(ancestor, params);
      if ((_ancestor$isolateFiel = ancestor.isolateFieldChange) !== null && _ancestor$isolateFiel !== void 0 && _ancestor$isolateFiel.call(ancestor, this)) {
        return false;
      }
    });
  }
  isolateFieldChange(field) {
    return this.isolateFields;
  }
  setupFocusListeners() {
    GlobalEvents$1.setupFocusListenersOnce(this._rootElement, EventHelper);
  }
  static widgetMatches(candidate, selector, deep) {
    if (selector === "*") {
      return true;
    }
    if (typeof selector === "function") {
      return selector(candidate);
    }
    return Widget.isType(candidate, selector, deep);
  }
  static attachTooltip(element, configOrText) {
    if (typeof configOrText === "string")
      configOrText = {
        html: configOrText
      };
    Widget.create(Object.assign({
      forElement: element
    }, configOrText), "tooltip");
    return element;
  }
  changeDock(dock) {
    if (dock === "start") {
      return "left";
    }
    if (dock === "end") {
      return "right";
    }
    return dock;
  }
  updateRtl(rtl) {
    super.updateRtl(rtl);
    this.eachWidget((item) => {
      if (!("rtl" in item.initialConfig)) {
        item.rtl = rtl;
      }
    });
  }
};
var proto = Widget.prototype;
["compose", "domSyncCallback"].forEach((fn) => proto[fn].$nullFn = true);
Widget.initClass();
Widget.register("mask", Mask);
DomHelper.Widget = Widget;
GlobalEvents$1.Widget = Widget;
Mask.identifiable.idMap = Widget.identifiable.idMap;
Object.assign(globalThis.bryntum || (globalThis.bryntum = {}), {
  get: Widget.getById.bind(Widget),
  query: Widget.query,
  queryAll: Widget.queryAll,
  fromElement: Widget.fromElement
});
Widget._$name = "Widget";
var Layout = class extends Base.mixin(Events, Factoryable) {
  get contentElement() {
    var _this$owner;
    return (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.contentElement;
  }
  onChildAdd(item) {
  }
  onChildRemove(item) {
  }
  renderChildren() {
    const me = this, {
      owner,
      itemCls
    } = me, {
      contentElement,
      items: items2
    } = owner, ownerItemCls = owner.itemCls, itemCount = items2 === null || items2 === void 0 ? void 0 : items2.length;
    if (itemCount) {
      owner.textContent = false;
      for (let i = 0; i < itemCount; i++) {
        const item = items2[i], {
          element
        } = item, {
          classList
        } = element;
        element.dataset.itemIndex = i;
        if (classList.contains("b-outer")) {
          classList.remove(...Widget.outerCls);
        }
        if (itemCls) {
          classList.add(itemCls);
        }
        if (ownerItemCls) {
          classList.add(ownerItemCls);
        }
        item.render(contentElement, Boolean(owner.isPainted));
      }
    }
    me.syncPendingConfigs();
    me.syncChildCount();
  }
  removeChild(child) {
    const me = this, {
      element
    } = child, {
      owner,
      itemCls
    } = me, {
      contentElement
    } = owner, ownerItemCls = owner.itemCls;
    if (contentElement.contains(element)) {
      element.remove();
    }
    delete element.dataset.itemIndex;
    if (itemCls) {
      element.classList.remove(itemCls);
    }
    if (ownerItemCls) {
      element.classList.remove(ownerItemCls);
    }
    me.fixChildIndices();
    me.syncChildCount();
  }
  appendChild(child) {
    const {
      element
    } = child, {
      owner,
      itemCls
    } = this, {
      contentElement
    } = owner, ownerItemCls = owner.itemCls;
    element.dataset.itemIndex = owner.indexOfChild(child);
    owner.textContent = false;
    if (itemCls) {
      element.classList.add(itemCls);
    }
    if (ownerItemCls) {
      element.classList.add(ownerItemCls);
    }
    child.render(contentElement, Boolean(owner.isPainted));
    this.syncChildCount();
  }
  insertChild(toAdd, childIndex) {
    const me = this, {
      element
    } = toAdd, {
      owner,
      itemCls
    } = me, {
      contentElement
    } = owner, nextSibling = DomHelper.getChild(contentElement, `[data-item-index="${childIndex}"]`), ownerItemCls = owner.itemCls;
    owner.textContent = false;
    if (itemCls) {
      element.classList.add(itemCls);
    }
    if (ownerItemCls) {
      element.classList.add(ownerItemCls);
    }
    contentElement.insertBefore(element, nextSibling);
    toAdd.render(null, Boolean(owner.isPainted));
    me.fixChildIndices();
    me.syncChildCount();
  }
  fixChildIndices() {
    this.owner.items.forEach((child, index) => {
      child.element.dataset.itemIndex = index;
    });
  }
  syncChildCount() {
    var _owner$contentElement;
    const {
      owner
    } = this, {
      length
    } = owner.items;
    (_owner$contentElement = owner.contentElement) === null || _owner$contentElement === void 0 ? void 0 : _owner$contentElement.classList[length === 1 ? "add" : "remove"]("b-single-child");
  }
  syncConfigLater(config) {
    const pendingConfigs = this.pendingConfigs || (this.pendingConfigs = []);
    if (!pendingConfigs.includes(config)) {
      pendingConfigs.push(config);
    }
  }
  syncConfigStyle({
    name,
    style,
    classes,
    map
  }) {
    const me = this, baseCls = `b-box-${name}-`, {
      contentElement
    } = me, raw = me[name];
    let value = (map === null || map === void 0 ? void 0 : map[raw]) || raw;
    if (contentElement) {
      if (classes) {
        const {
          classList
        } = contentElement;
        classes.forEach((c) => {
          if (c !== value) {
            classList.remove(baseCls + c);
          }
        });
        if (classes.includes(value)) {
          classList.add(baseCls + value);
          value = "";
        }
      }
      contentElement.style[style] = value;
    } else {
      me.syncConfigLater(name);
    }
  }
  syncPendingConfigs() {
    const me = this, {
      pendingConfigs
    } = me;
    let name;
    if (pendingConfigs) {
      me.pendingConfigs = null;
      while (name = pendingConfigs.pop()) {
        me[me.$meta.configs[name].updater](me[name]);
      }
    }
  }
};
_defineProperty(Layout, "type", "default");
_defineProperty(Layout, "configurable", {
  owner: null,
  containerCls: "b-auto-container",
  itemCls: null
});
_defineProperty(Layout, "factoryable", {
  defaultType: "default"
});
Layout.initClass();
Layout._$name = "Layout";
var lastTouchTime = 0;
var hasRipple = (w) => w.ripple;
var Ripple = class extends Widget {
  static get defaultConfig() {
    return {
      old_element: {
        children: [{
          className: "b-ripple-inner",
          reference: "rippleElement"
        }]
      },
      element: {
        children: [{
          tag: "svg",
          class: "b-ripple-inner",
          reference: "rippleElement",
          ns: "http://www.w3.org/2000/svg",
          version: "1.1",
          viewBox: "0 0 100 100",
          children: [{
            reference: "circleElement",
            tag: "circle",
            cx: "0",
            cy: "0",
            r: 10
          }]
        }]
      },
      floating: true,
      hideAnimation: false,
      showAnimation: false,
      scrollAction: "realign",
      color: "rgba(0,0,0,.3)",
      startRadius: 10,
      radius: 100
    };
  }
  static get $name() {
    return "Ripple";
  }
  afterConstruct() {
    super.afterConstruct();
    EventHelper.on({
      element: this.rootElement,
      mousedown: "onRippleControllingEvent",
      thisObj: this,
      capture: true,
      once: true
    });
  }
  onRippleControllingEvent(event) {
    var _me$listenerDetacher;
    const me = this;
    me.show();
    const rippleAnimation = DomHelper.getStyleValue(me.circleElement, "animationName");
    me.hide();
    (_me$listenerDetacher = me.listenerDetacher) === null || _me$listenerDetacher === void 0 ? void 0 : _me$listenerDetacher.call(me);
    if (rippleAnimation && rippleAnimation !== "none") {
      me.listenerDetacher = EventHelper.on({
        mousedown: {
          element: me.rootElement,
          capture: true,
          handler: "onMousedown"
        },
        touchstart: {
          element: me.rootElement,
          capture: true,
          handler: "onTouchStart"
        },
        animationend: {
          element: me.circleElement,
          handler: "onAnimationEnd"
        },
        thisObj: me
      });
      if (event.type === "mousedown") {
        me.onMousedown(event);
        GlobalEvents$1.ion({
          theme: "onRippleControllingEvent",
          thisObj: this
        });
      }
    }
  }
  onTouchStart(event) {
    lastTouchTime = performance.now();
    this.handleTriggerEvent(event);
  }
  onMousedown(event) {
    if (performance.now() - lastTouchTime > 200) {
      this.handleTriggerEvent(event);
    }
  }
  handleTriggerEvent(event) {
    const targetWidget = Widget.fromElement(event.target, hasRipple);
    if (targetWidget) {
      const rippleCfg = targetWidget.ripple, target = rippleCfg.delegate ? event.target.closest(rippleCfg.delegate) : targetWidget.focusElement || targetWidget.element;
      if (target) {
        const ripple = ObjectHelper.assign({
          event,
          target,
          radius: this.radius
        }, rippleCfg);
        if (typeof ripple.clip === "string") {
          ripple.clip = targetWidget[ripple.clip] || event.target.closest(ripple.clip);
          if (!ripple.clip) {
            return;
          }
        }
        this.ripple(ripple);
      }
    }
  }
  ripple({
    event,
    point = EventHelper.getClientPoint(event),
    target = event.target,
    clip = target,
    radius = this.radius,
    color = this.color
  }) {
    this.clip = clip;
    clip = Rectangle.from(clip, null, true);
    const me = this, centreDelta = clip.getDelta(point), rippleStyle = me.rippleElement.style, circleElement = me.circleElement, borderRadius = DomHelper.getStyleValue(target, "border-radius");
    me.hide();
    rippleStyle.transform = `translateX(${centreDelta[0]}px) translateY(${centreDelta[1]}px)`;
    rippleStyle.height = rippleStyle.width = `${radius}px`;
    me.element.style.borderRadius = borderRadius;
    circleElement.setAttribute("r", radius);
    circleElement.setAttribute("fill", color);
    me.showBy({
      target: clip,
      align: "c-c",
      matchSize: true
    });
  }
  onAnimationEnd(event) {
    if (event.animationName === "b-ripple-expand") {
      this.hide();
    }
  }
};
Widget.RippleClass = Ripple;
Ripple._$name = "Ripple";
var emptyObject$3 = Object.freeze({});
var {
  isArray
} = Array;
var returnWeight = (i) => i.weight;
var sortByWeight = ({
  weight: a
}, {
  weight: b
}) => {
  if (typeof a === "string" || typeof b === "string") {
    return String(a).localeCompare(String(b));
  }
  return (a !== null && a !== void 0 ? a : Number.MAX_SAFE_INTEGER) - (b !== null && b !== void 0 ? b : Number.MAX_SAFE_INTEGER);
};
var isNotHidden = (w) => w && !w.hidden;
var stylesToCheck = ["display", "flex-direction"];
var boxLayouts = {
  default: 1,
  box: 1
};
var Container = class extends Widget {
  static get $name() {
    return "Container";
  }
  static get type() {
    return "container";
  }
  static get configurable() {
    return {
      items: null,
      lazyItems: {
        $config: ["lazy"],
        value: null
      },
      defaults: null,
      defaultType: "widget",
      layoutStyle: null,
      itemCls: null,
      layout: {
        type: "default"
      },
      namedItems: null,
      overflowable: {
        value: null,
        default: false,
        $config: null
      },
      textContent: true,
      record: null,
      autoUpdateRecord: null,
      autoUpdateFields: null,
      hideWhenEmpty: null,
      contentElMutationObserver: {
        $config: ["lazy", "nullify"],
        value: true
      },
      isolateFields: false,
      focusDescendant: false,
      defaultBindProperty: null,
      defaultFocus: null
    };
  }
  static get prototypeProperties() {
    return {
      flexRowCls: "b-flex-row",
      flexColCls: "b-flex-column",
      initialItems: true
    };
  }
  startConfigure(config) {
    const items2 = config.items || config.lazyItems;
    if (!(this.hasItems = Boolean(items2 && (isArray(items2) ? items2 : Object.keys(items2)).length))) {
      this.initialItems = false;
    }
    super.startConfigure(config);
  }
  get firstItem() {
    return this.getAt(0);
  }
  get lastItem() {
    return this.getAt(-1);
  }
  getAt(index) {
    return this.ensureItems().at(index);
  }
  remove(...toRemove) {
    let returnArray = true;
    if (toRemove.length === 1) {
      if (isArray(toRemove[0])) {
        toRemove = toRemove[0];
      } else {
        returnArray = false;
      }
    }
    const me = this, {
      _items
    } = me, result = [];
    for (let i = 0; i < toRemove.length; i++) {
      const childToRemove = toRemove[i];
      if (_items.includes(childToRemove)) {
        _items.remove(childToRemove);
        me.layout.removeChild(childToRemove);
        result.push(childToRemove);
        me.onChildRemove(childToRemove);
      }
    }
    return returnArray ? result : result[0];
  }
  removeAll() {
    return this.remove(this.items);
  }
  add(...toAdd) {
    const me = this, items2 = me.ensureItems(), result = [];
    let returnArray = true, childToAdd, i, index;
    if (toAdd.length === 1) {
      if (isArray(toAdd[0])) {
        toAdd = toAdd[0];
      } else {
        returnArray = false;
      }
    }
    for (i = 0; i < toAdd.length; i++) {
      var _childToAdd;
      childToAdd = toAdd[i];
      if (childToAdd.isWidget) {
        childToAdd.parent = me;
      } else {
        childToAdd = me.createWidget(childToAdd);
      }
      if (((_childToAdd = childToAdd) === null || _childToAdd === void 0 ? void 0 : _childToAdd.weight) != null) {
        index = ArrayHelper.findInsertionIndex(childToAdd, items2.values, sortByWeight);
        result.push(me.insert(childToAdd, index));
      } else if (childToAdd) {
        if (!items2.includes(childToAdd)) {
          items2.add(childToAdd);
          me.onChildAdd(childToAdd);
          me.layout.appendChild(childToAdd);
          result.push(childToAdd);
        }
      }
    }
    return returnArray ? result : result[0];
  }
  ensureItems() {
    const me = this;
    me.getConfig("items");
    me.getConfig("lazyItems");
    if (!me._items) {
      me.items = [];
    }
    return me._items;
  }
  insert(toAdd, index) {
    const me = this, items2 = me.ensureItems();
    if (toAdd instanceof Widget) {
      toAdd.parent = me;
    } else {
      toAdd = me.createWidget(toAdd);
    }
    if (items2.includes(index)) {
      index = me.indexOfChild(index);
    }
    index = Math.min(index, items2.count);
    const newValues = items2.values;
    newValues.splice(index, 0, toAdd);
    items2.values = newValues;
    me.onChildAdd(toAdd);
    me.layout.insertChild(toAdd, index);
    return toAdd;
  }
  indexOfChild(child) {
    return this.items.indexOf(child);
  }
  changeLazyItems(lazyItems) {
    this.items = lazyItems;
    this.layout.renderChildren();
  }
  changeItems(items2, oldItems) {
    const me = this, newItems = [], result = new Bag();
    if (isArray(items2)) {
      me.processItemsArray(items2, newItems);
    } else if (items2) {
      me.processItemsObject(items2, me.namedItems, newItems);
    }
    if (newItems.some(returnWeight)) {
      newItems.sort(sortByWeight);
    }
    result.add(newItems);
    if (oldItems) {
      oldItems.forEach((w) => {
        me.remove(w);
        if (!result.includes(w) && w._createdBy === me) {
          w.destroy();
        }
      });
    }
    return result;
  }
  afterConstruct() {
    const {
      rtl
    } = this, {
      classList
    } = this.contentElement;
    classList.toggle("b-rtl", rtl === true);
    classList.toggle("b-ltr", rtl === false);
  }
  updateRtl(rtl) {
    super.updateRtl(rtl);
    const {
      contentElement
    } = this;
    if (contentElement) {
      contentElement.classList.toggle("b-rtl", rtl === true);
      contentElement.classList.toggle("b-ltr", rtl === false);
    }
  }
  updateItems(items2, oldItems) {
    let index = 0;
    items2.forEach((item) => {
      this.onChildAdd(item);
      if (oldItems && !oldItems.temporary) {
        this.layout.insertChild(item, index);
      }
      ++index;
    });
    this.initialItems = false;
  }
  updateHideWhenEmpty() {
    this.syncChildCount(this.rendered);
  }
  get items() {
    const me = this;
    me.getConfig("lazyItems");
    if (!me._items) {
      if (me.initializingItems) {
        return [];
      }
      me._items = new Bag();
      me._items.temporary = true;
    }
    return me._items.values;
  }
  processItemsArray(items2, result) {
    const len = items2.length;
    let i, item;
    for (i = 0; i < len; i++) {
      item = items2[i];
      if (item instanceof Widget) {
        item.parent = this;
        item.element.classList.remove(...Widget.outerCls);
      } else {
        item = this.createWidget(item);
      }
      if (item) {
        if (item.ref || item.id) {
          this.addDescendant(item);
        }
        result.push(item);
      }
    }
  }
  processItemsObject(items2, namedItems, result) {
    let item, ref;
    for (ref in items2) {
      item = items2[ref];
      if (item) {
        if (namedItems && ref in namedItems) {
          item = typeof item === "object" ? ObjectHelper.merge(ObjectHelper.clone(namedItems[ref]), item) : namedItems[ref];
        }
        if (item) {
          if (item instanceof Widget) {
            item.parent = this;
          } else {
            if (item instanceof Object) {
              item.ref = ref;
            }
            item = this.createWidget(item);
          }
          if (item) {
            item.ref = ref;
            this.addDescendant(item);
            result.push(item);
          }
        }
      }
    }
  }
  onChildAdd(item) {
    if (item.innerItem && this.readOnly && !item.ignoreParentReadOnly) {
      item.readOnly = true;
    }
    this.onChildAddLayout(item);
    if (item.ref || item.id) {
      for (let current = this; current; current = current.parent) {
        current.addDescendant(item);
      }
    }
    this.syncChildCount(true);
  }
  onChildAddLayout(item) {
    if (item.innerItem) {
      this.layout.onChildAdd(item);
    }
  }
  onChildHide(hidden) {
    var _this$_items;
    super.onChildHide(hidden);
    if ((_this$_items = this._items) !== null && _this$_items !== void 0 && _this$_items.includes(hidden)) {
      this.syncChildCount(true);
    }
  }
  onChildShow(shown) {
    var _this$_items2;
    super.onChildShow(shown);
    if ((_this$_items2 = this._items) !== null && _this$_items2 !== void 0 && _this$_items2.includes(shown)) {
      this.syncChildCount(true);
    }
  }
  syncChildCount(enforceHideWhenEmpty) {
    if (!this.isConfiguring) {
      const me = this, {
        items: items2,
        hasItems
      } = me, visibleItems = items2.filter(isNotHidden), {
        length: visibleLength
      } = visibleItems;
      me.visibleChildCount = visibleLength;
      if (me.hideWhenEmpty && enforceHideWhenEmpty) {
        const shouldHide = Boolean(!visibleLength);
        if (Boolean(me._hidden) !== shouldHide) {
          me.hidden = shouldHide;
        }
      }
      items2.forEach((childItem) => childItem.element.classList.remove("b-last-visible-child", "b-first-visible-child"));
      if (visibleLength) {
        visibleItems[0].element.classList.add("b-first-visible-child");
        visibleItems[visibleLength - 1].element.classList.add("b-last-visible-child");
      }
      me.hasItems = Boolean(me.childItems.length);
      me.contentElement.classList[visibleLength ? "remove" : "add"]("b-no-visible-children");
      if (!me.isComposable) {
        me.updateTextContent(me._textContent);
      } else if (hasItems !== me.hasItems) {
        me.recompose();
      }
    }
  }
  syncFlexDirection() {
    const me = this, {
      contentElement,
      flexColCls,
      flexRowCls
    } = me, classList = new DomClassList(contentElement.className), styles = DomHelper.getStyleValue(contentElement, stylesToCheck);
    classList[flexRowCls] = classList[flexColCls] = 0;
    if (styles.display === "flex") {
      classList[styles["flex-direction"] === "row" ? flexRowCls : flexColCls] = 1;
    }
    DomHelper.syncClassList(contentElement, classList);
  }
  addDescendant(item) {
    const ref = item.ref || item.id, widgetMap = this._widgetMap || (this._widgetMap = {});
    if (!widgetMap[ref]) {
      widgetMap[ref] = item;
    }
  }
  onChildRemove(item) {
    const me = this, ref = item.ref || item.id;
    if (ref) {
      for (let current = me; current; current = current.parent) {
        if (current.widgetMap[ref] === item) {
          delete current.widgetMap[ref];
        }
      }
    }
    me.layout.onChildRemove(item);
    me.syncChildCount(true);
  }
  get widgetMap() {
    if (!this._widgetMap) {
      this._widgetMap = {};
    }
    if (!this.initializingItems) {
      this.getConfig("items");
    }
    return this._widgetMap;
  }
  changeRecord(record) {
    this._record = record == null ? emptyObject$3 : null;
    return record;
  }
  updateRecord(record) {
    var _me$recordUpdateDetac;
    const me = this;
    (_me$recordUpdateDetac = me.recordUpdateDetacher) === null || _me$recordUpdateDetac === void 0 ? void 0 : _me$recordUpdateDetac.call(me);
    me.trigger("beforeSetRecord", {
      record
    });
    me.setValues(record, {
      onlyName: true,
      highlight: Boolean(me.$highlight)
    });
    if (me.autoUpdateFields && record !== null && record !== void 0 && record.firstStore) {
      me.recordUpdateDetacher = record.firstStore.ion({
        update: me.onRecordUpdated,
        thisObj: me
      });
    }
  }
  setRecord(record, highlightChanges) {
    this.$highlight = highlightChanges;
    this.record = record;
    this.$highlight = false;
  }
  onRecordUpdated({
    record
  }) {
    if (record === this.record) {
      this.setValues(this.record, true, true);
    }
  }
  onFieldChange({
    source,
    userAction
  }) {
    if (this.autoUpdateRecord && userAction) {
      const {
        record
      } = this, {
        name,
        isValid = true,
        value
      } = source;
      if (record && name && isValid) {
        record[name] = value;
      }
    }
  }
  getValues(filterFn) {
    const values = {};
    this.eachWidget((widget, control) => {
      if (widget.isolateFields) {
        control.down = false;
      } else if ("name" in widget && (!filterFn || filterFn(widget))) {
        values[widget.name] = widget.value;
      }
    }, true);
    return values;
  }
  get hasNoChildren() {
    const me = this, {
      items: items2,
      lazyItems
    } = me.initialConfig, itemsArray = items2 && (isArray(items2) ? items2 : ObjectHelper.values(items2)), lazyItemsArray = lazyItems && (isArray(lazyItems) ? lazyItems : ObjectHelper.values(lazyItems)), whichItems = me.isConfiguring ? lazyItemsArray || itemsArray : me.items;
    return !(whichItems !== null && whichItems !== void 0 && whichItems.filter(isNotHidden).length);
  }
  afterRecompose() {
    super.afterRecompose();
    this.realign();
  }
  updateTextContent(textContent) {
    const me = this;
    if (!me.isComposable) {
      const needsClass = Boolean(textContent && me.hasNoChildren), {
        classList
      } = me.contentElement, changed = needsClass !== classList.contains("b-text-content");
      if (changed) {
        classList[needsClass ? "add" : "remove"]("b-text-content");
        if (me.rendered) {
          me.realign();
        }
      }
    }
  }
  updateLayoutStyle(layoutStyle) {
    DomHelper.applyStyle(this.contentElement, layoutStyle);
  }
  updateElement(element) {
    super.updateElement(...arguments);
    if (element) {
      const {
        classList
      } = this.contentElement, {
        containerCls
      } = this.layout;
      classList.add("b-content-element");
      if (containerCls) {
        classList.add(containerCls);
      }
    }
  }
  onPaint() {
    var _super$onPaint;
    (_super$onPaint = super.onPaint) === null || _super$onPaint === void 0 ? void 0 : _super$onPaint.call(this, ...arguments);
    this.getConfig("contentElMutationObserver");
  }
  changeContentElMutationObserver(contentElMutationObserver, oldContentElMutationObserver) {
    if (oldContentElMutationObserver) {
      oldContentElMutationObserver.takeRecords();
      oldContentElMutationObserver.disconnect();
    }
    if (contentElMutationObserver) {
      const me = this, {
        element,
        contentElement
      } = me;
      contentElMutationObserver = new MutationObserver((mutations) => me.onContentElMutation(mutations));
      contentElMutationObserver.observe(contentElement, {
        attributes: true
      });
      if (contentElement !== element) {
        contentElMutationObserver.observe(element, {
          attributes: true
        });
      }
      me.syncFlexDirection();
    }
    return contentElMutationObserver;
  }
  onContentElMutation() {
    if (boxLayouts[this.layout.type] && this.isVisible) {
      this.syncFlexDirection();
    }
  }
  changeLayout(config, existingLayout) {
    return Layout.reconfigure(existingLayout, config, {
      owner: this,
      defaults: {
        owner: this
      }
    });
  }
  get childItems() {
    return this.items;
  }
  getWidgetById(id) {
    return this.widgetMap[id];
  }
  processWidgetConfig(widget) {
  }
  setupWidgetConfig(widgetConfig, type) {
    const me = this;
    if (typeof widgetConfig === "string") {
      widgetConfig = {
        html: widgetConfig
      };
    } else if (widgetConfig.nodeType === Element.ELEMENT_NODE) {
      widgetConfig = {
        element: widgetConfig,
        id: widgetConfig.id
      };
    }
    if (typeof type === "string" || !type && (type = widgetConfig.type)) {
      type = Widget.resolveType(type, true);
    }
    widgetConfig = (type || Widget).mergeConfigs(me.defaults, widgetConfig, {
      parent: me
    });
    for (let ancestor = widgetConfig.parent; ancestor; ancestor = ancestor.parent) {
      if (ancestor.processWidgetConfig(widgetConfig) === false) {
        return null;
      }
    }
    if (me.trigger("beforeWidgetCreate", {
      widgetConfig
    }) === false) {
      return null;
    }
    return widgetConfig;
  }
  createWidget(widget) {
    const result = Widget.create(this.setupWidgetConfig(widget), this.defaultType);
    result && (result._createdBy = this);
    return result;
  }
  updateDefaults(defaults, oldDefaults) {
    if (!this.isConfiguring && defaults) {
      const entries = Object.entries(defaults);
      this.eachWidget((widget) => {
        entries.forEach(([prop, value]) => {
          if (!oldDefaults || widget[prop] === oldDefaults[prop]) {
            widget[prop] = value;
          }
        });
      }, false);
    }
  }
  render() {
    this.getConfig("lazyItems");
    this.layout.renderChildren();
    this.syncChildCount();
    super.render(...arguments);
  }
  get focusElement() {
    const firstFocusable = this.query(this.defaultFocus || ((w) => {
      var _w$ref;
      return w.isFocusable && w.ref !== "close" && !((_w$ref = w.ref) !== null && _w$ref !== void 0 && _w$ref.endsWith("collapse"));
    }));
    if (firstFocusable) {
      return firstFocusable.focusElement;
    }
    return super.focusElement;
  }
  doDestroy() {
    var _this$_items3;
    (_this$_items3 = this._items) === null || _this$_items3 === void 0 ? void 0 : _this$_items3.forEach((widget) => {
      var _widget$destroy;
      return (_widget$destroy = widget.destroy) === null || _widget$destroy === void 0 ? void 0 : _widget$destroy.call(widget);
    });
    this.layout.destroy();
    super.doDestroy();
  }
  get isValid() {
    let valid = true;
    this.eachWidget((widget) => {
      if (widget.isVisible && "isValid" in widget && !widget.isValid) {
        valid = false;
      }
    }, true);
    return valid;
  }
  get values() {
    const values = {};
    this.gatherValue(values);
    return values;
  }
  set values(values) {
    this.assignValue(values);
  }
  get isSettingValues() {
    return Boolean(this.assigningValues);
  }
  get assigningValues() {
    var _this$parent;
    return this._assigningValues || ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.assigningValues);
  }
  set assigningValues(v) {
    this._assigningValues = v;
  }
  assignValue(values, options) {
    super.assignValue(values, options);
    if (!this.isolateFields) {
      this.setValues(values, options);
    }
  }
  gatherValue(values) {
    super.gatherValue(values);
    if (!this.isolateFields) {
      this.gatherValues(values);
    }
  }
  setValues(values, options) {
    options = options || this.assignValueDefaults;
    this.assigningValues = options;
    this.eachWidget((widget) => widget.assignValue(values, options), false);
    this.assigningValues = false;
  }
};
Container.initClass();
Container._$name = "Container";
var {
  assign
} = ObjectHelper;
var now = () => performance.now();
var nostart = {
  start: false
};
var unitRe = /^[.\d]+([^\d].*)?$/;
var getTransitions = (element) => {
  const $bryntum = element.$bryntum || (element.$bryntum = {});
  return $bryntum.transitions || ($bryntum.transitions = /* @__PURE__ */ Object.create(null));
};
var milliseconds = (duration, unit) => {
  if (typeof duration === "string") {
    var _unitRe$exec;
    unit = (_unitRe$exec = unitRe.exec(duration)) === null || _unitRe$exec === void 0 ? void 0 : _unitRe$exec[1];
    duration = parseFloat(duration);
  }
  return duration && duration * (unit === "s" || !unit && duration < 10 ? 1e3 : 1);
};
var syncTransitions = (element) => {
  const all = ObjectHelper.values(getTransitions(element)).filter((a) => a.completed == null).map((a) => a.toString());
  element.style.transition = all.join(", ");
};
var Anim = (Target) => class Anim extends Target {
  static get prototypeProperties() {
    return {
      _delay: null,
      _duration: null,
      _retain: null,
      _timing: null,
      _unit: null,
      owner: null,
      reverting: null
    };
  }
  constructor(...args) {
    super(...args);
    this.id = ++idSeed$1;
  }
  start() {
    this.startTime = now();
  }
  get delay() {
    var _ref, _this$_delay, _this$owner;
    return milliseconds((_ref = (_this$_delay = this._delay) !== null && _this$_delay !== void 0 ? _this$_delay : (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.delay) !== null && _ref !== void 0 ? _ref : 0, this.unit);
  }
  set delay(v) {
    this._delay = v;
  }
  get duration() {
    var _this$_duration;
    const {
      owner,
      unit
    } = this;
    return milliseconds((_this$_duration = this._duration) !== null && _this$_duration !== void 0 ? _this$_duration : owner ? owner.duration : Animator.defaultDuration, unit);
  }
  set duration(v) {
    this._duration = v;
  }
  get elapsed() {
    return now() - this.startTime;
  }
  get remaining() {
    return this.duration - this.elapsed;
  }
  get retain() {
    var _this$_retain, _this$owner2;
    return (_this$_retain = this._retain) !== null && _this$_retain !== void 0 ? _this$_retain : (_this$owner2 = this.owner) === null || _this$owner2 === void 0 ? void 0 : _this$owner2.retain;
  }
  set retain(v) {
    this._retain = v;
  }
  get timing() {
    var _this$_timing, _this$owner3;
    return (_this$_timing = this._timing) !== null && _this$_timing !== void 0 ? _this$_timing : (_this$owner3 = this.owner) === null || _this$owner3 === void 0 ? void 0 : _this$owner3.timing;
  }
  set timing(v) {
    this._timing = v;
  }
  get unit() {
    var _this$_unit, _this$owner4;
    return (_this$_unit = this._unit) !== null && _this$_unit !== void 0 ? _this$_unit : (_this$owner4 = this.owner) === null || _this$owner4 === void 0 ? void 0 : _this$owner4.unit;
  }
  set unit(v) {
    this._unit = v;
  }
};
var idSeed$1 = 0;
var AnimatorTransition = class extends Base.mixin(Anim) {
  static get $name() {
    return "AnimatorTransition";
  }
  static get prototypeProperties() {
    return {
      element: null,
      property: null,
      from: null,
      to: null,
      completed: null,
      promissory: null,
      reverting: null
    };
  }
  afterConstruct() {
    super.afterConstruct();
    const me = this, {
      element,
      transitions
    } = me;
    let {
      property
    } = me;
    [property, me.to] = DomHelper.unitize(property, me.to);
    me.from = DomHelper.unitize(property, me.from)[1];
    me.promissory = new Promissory();
    me.property = property;
    const was = transitions[property];
    transitions[property] = me;
    let {
      from
    } = me;
    if (was) {
      me.from = was.to;
      from = null;
      was.destroy();
    }
    if (from === null) {
      from = me.getCurrentStyleValue();
      if (!was) {
        me.from = from;
      }
    }
    element.style[property] = from;
    me.getCurrentStyleValue();
  }
  doDestroy() {
    const me = this;
    me.finish(false);
    if (me.completed && !me.retain) {
      me.clearStyle();
    }
    super.doDestroy();
  }
  get promise() {
    var _this$promissory;
    return (_this$promissory = this.promissory) === null || _this$promissory === void 0 ? void 0 : _this$promissory.promise;
  }
  get transitions() {
    return getTransitions(this.element);
  }
  clearStyle() {
    this.setStyle("");
  }
  finish(complete) {
    const me = this, {
      transitions,
      promissory,
      property
    } = me;
    if (promissory) {
      me.completed = complete;
      me.promissory = null;
      promissory.resolve(complete);
      if (transitions[property] === me) {
        delete transitions[property];
        if (!complete) {
          syncTransitions(me.element);
          me.clearStyle();
        }
      } else {
        me.completed = false;
      }
    }
  }
  getCurrentStyleValue() {
    return DomHelper.getStyleValue(this.element, this.property);
  }
  revert() {
    const {
      duration,
      elapsed,
      element,
      from,
      property,
      _retain: retain,
      _timing: timing
    } = this;
    return new AnimatorTransition({
      element,
      property,
      retain,
      timing,
      duration: Math.round(Math.min(duration, elapsed)),
      reverting: this,
      to: from,
      unit: "ms"
    });
  }
  setStyle(value) {
    this.element.style[this.property] = value;
  }
  start() {
    const me = this, {
      delay,
      duration,
      element,
      property
    } = me;
    EventHelper.onTransitionEnd({
      element,
      property,
      duration: delay + duration + 20,
      thisObj: me.owner,
      handler: () => {
        var _me$finish;
        return (_me$finish = me.finish) === null || _me$finish === void 0 ? void 0 : _me$finish.call(me, true);
      }
    });
    super.start();
    me.setStyle(me.to);
  }
  toString() {
    const {
      delay,
      duration,
      property,
      timing
    } = this;
    return `${property} ${duration}ms ${timing || "ease-in-out"}${delay ? ` ${delay}ms` : ""}`;
  }
};
AnimatorTransition.initClass();
var Animator = class extends Base.mixin(Anim) {
  static get $name() {
    return "Animator";
  }
  static get prototypeProperties() {
    return {
      element: null,
      finalize: null,
      prefinalize: null,
      completed: null,
      items: null
    };
  }
  static register(name, fn) {
    if (ObjectHelper.isObject(name)) {
      ObjectHelper.entries(name).forEach((entry) => Animator.register(...entry));
      return;
    }
    Animator.fx[name] = fn;
    Animator[name] = (options) => {
      if (DomHelper.isElement(options)) {
        options = {
          element: options,
          [name]: {}
        };
      } else {
        options = {
          element: options.element,
          [name]: options
        };
        delete options[name].element;
      }
      return Animator.run(options);
    };
  }
  static run(options) {
    return new Animator(options).start();
  }
  constructor(options) {
    var _me$items;
    super(null);
    const me = this, items2 = [], properties = {};
    let anim, fx, key, t;
    if (Array.isArray(options)) {
      me.items = options;
    } else {
      for (key in options) {
        (Animator.specialPropsRe.test(key) ? me : properties)[key] = options[key];
      }
    }
    ObjectHelper.keys(properties).forEach((property) => {
      t = properties[property];
      if (t != null && t !== false && t === t) {
        if (!(fx = Animator.fx[property])) {
          t = assign(me.defaults, typeof t === "object" ? t : {
            to: t
          });
          t.owner = me;
          t.property = property;
          anim = new AnimatorTransition(t);
        } else {
          t = assign(me.defaults, fx(t, me, property));
          t.owner = me;
          anim = new Animator(t);
        }
        items2.push(anim);
      }
    });
    (_me$items = me.items) === null || _me$items === void 0 ? void 0 : _me$items.forEach((item) => {
      if (ObjectHelper.isInstantiated(item)) {
        item.owner = me;
      } else {
        item = assign(me.defaults, item);
        item.owner = me;
        item = new Animator(item);
      }
      items2.push(item);
    });
    me.items = items2;
    me.promise = (items2.length === 1 ? items2[0].promise : Promise.all(items2.map((it) => it.promise))).then((res) => {
      var _me$finish2;
      (_me$finish2 = me.finish) === null || _me$finish2 === void 0 ? void 0 : _me$finish2.call(me, res);
      return me.completed || false;
    });
  }
  doDestroy() {
    this.items.forEach((a) => a.destroy());
    super.doDestroy();
  }
  get defaults() {
    return {
      element: this.element
    };
  }
  get retain() {
    const {
      _retain,
      finalize,
      owner
    } = this;
    return _retain !== null && _retain !== void 0 ? _retain : finalize ? false : owner ? owner.retain : true;
  }
  set retain(v) {
    super.retain = v;
  }
  done() {
    return this.promise;
  }
  finish(complete) {
    var _me$prefinalize, _me$finalize;
    const me = this, {
      items: items2
    } = me;
    syncTransitions(me.element);
    me.completed = typeof complete === "boolean" ? complete : !complete.some((a) => !a);
    (_me$prefinalize = me.prefinalize) === null || _me$prefinalize === void 0 ? void 0 : _me$prefinalize.call(me, me.completed, me);
    while (items2.length) {
      items2.pop().destroy();
    }
    (_me$finalize = me.finalize) === null || _me$finalize === void 0 ? void 0 : _me$finalize.call(me, me.completed, me);
  }
  revert(options) {
    var _options$start;
    const me = this, {
      reverting
    } = me, start = !options || ((_options$start = options.start) !== null && _options$start !== void 0 ? _options$start : true);
    let anim = me.defaults;
    if (reverting) {
      if (reverting.finalize) {
        anim.finalize = reverting.finalize;
      }
      if (reverting.prefinalize) {
        anim.prefinalize = reverting.prefinalize;
      }
      anim.retain = reverting._retain;
    }
    anim = assign(anim, options, {
      items: me.items.map((it) => it.revert(nostart)),
      reverting: me
    });
    anim = new Animator(anim);
    start && anim.start();
    return anim;
  }
  start() {
    const {
      element,
      items: items2
    } = this;
    super.start();
    if (items2.length) {
      syncTransitions(element);
      items2.forEach((a) => a.start());
    }
    return this;
  }
};
Animator.initClass().Transition = AnimatorTransition;
Animator.specialPropsRe = new RegExp(`^(?:${Object.keys(Animator.prototypeProperties).concat(Object.keys(Animator.superclass.prototypeProperties)).map((s) => s[0] === "_" ? s.substr(1) : s).join("|")})$`);
Animator.defaultDuration = 200;
Animator.fx = {};
Animator.register({
  puff(anim) {
    if (anim === true) {
      anim = {};
    } else if (typeof anim !== "object") {
      anim = {
        transform: `scale(${anim})`
      };
    } else if (anim.scale) {
      anim = ObjectHelper.clone(anim);
      anim.transform = `scale(${anim.scale})`;
      delete anim.scale;
    }
    return assign({
      opacity: 0,
      transform: "scale(8)"
    }, anim);
  }
});
Animator._$name = "Animator";
var ClickRepeater = class extends Base.mixin(Delayable) {
  static get configurable() {
    return {
      element: null,
      delegate: null,
      delay: 500,
      startRate: 2,
      endRate: 20,
      accelerateDuration: 4e3,
      pressedCls: "b-pressed"
    };
  }
  doDestroy() {
    var _this$mousedownRemove;
    (_this$mousedownRemove = this.mousedownRemover) === null || _this$mousedownRemove === void 0 ? void 0 : _this$mousedownRemove.call(this);
    this.cancel();
    super.doDestroy();
  }
  cancel() {
    var _me$activeElement, _me$acceleration, _me$activeListenerRem;
    const me = this;
    (_me$activeElement = me.activeElement) === null || _me$activeElement === void 0 ? void 0 : _me$activeElement.classList.remove(me.pressedCls);
    me.activeElement = null;
    (_me$acceleration = me.acceleration) === null || _me$acceleration === void 0 ? void 0 : _me$acceleration.cancel();
    me.activeListenerRemover = (_me$activeListenerRem = me.activeListenerRemover) === null || _me$activeListenerRem === void 0 ? void 0 : _me$activeListenerRem.call(me);
    me.clearTimeout(me.autoRepeatTimer);
    me.clearTimeout(me.repeatTimer);
  }
  updateElement(element) {
    var _this$mousedownRemove2;
    (_this$mousedownRemove2 = this.mousedownRemover) === null || _this$mousedownRemove2 === void 0 ? void 0 : _this$mousedownRemove2.call(this);
    this.mousedownRemover = EventHelper.on({
      element,
      mousedown: "onMouseDown",
      thisObj: this
    });
  }
  onMouseDown(e) {
    const me = this, target = me.delegate ? e.target.closest(me.delegate) : me.element;
    me.cancel();
    if (target) {
      me.activeElement = target;
      me.triggerEvent = e;
      target.classList.add(me.pressedCls);
      me.activeListenerRemover = EventHelper.on({
        mouseup: {
          element: document,
          capture: true,
          handler: "onMouseUp"
        },
        mousemove: {
          element: target,
          handler: "onTargetMouseMove"
        },
        mouseleave: {
          element: target,
          handler: "onTargetMouseLeave"
        },
        mouseenter: {
          element: target,
          handler: "onTargetMouseEnter"
        },
        thisObj: me
      });
      me.autoRepeatTimer = me.setTimeout("startAutoRepeat", me.delay);
    }
  }
  onMouseUp() {
    this.cancel();
  }
  onTargetMouseLeave() {
    this.activeElement.classList.remove(this.pressedCls);
    this.clearTimeout(this.repeatTimer);
  }
  onTargetMouseEnter(e) {
    const me = this;
    if (!e.buttons) {
      me.cancel();
    } else {
      me.activeElement.classList.add(me.pressedCls);
      me.triggerEvent = e;
      me.fireClick();
    }
  }
  onTargetMouseMove(e) {
    this.triggerEvent = e;
  }
  startAutoRepeat() {
    const me = this;
    me.interval = me.startInterval = 1e3 / me.startRate;
    me.accelerationDelta = me.startInterval - 1e3 / me.endRate;
    me.fireClick();
    me.acceleration = FunctionHelper.animate(me.accelerateDuration, me.nextTick, me, "easeOutQuad");
  }
  nextTick(progress) {
    this.interval = this.startInterval - this.accelerationDelta * progress;
  }
  fireClick() {
    const me = this, clickEvent = new MouseEvent("click", me.triggerEvent);
    me.triggerEvent.target.dispatchEvent(clickEvent);
    me.repeatTimer = me.setTimeout(me.fireClick, me.interval);
  }
};
ClickRepeater._$name = "ClickRepeater";
var autoRotateRe = /^(?:undefined|null|LEFT|RIGHT)$/;
var inverted = {
  TOP: "BOTTOM",
  RIGHT: "LEFT",
  BOTTOM: "TOP",
  LEFT: "RIGHT"
};
var canonicalDock = (dock) => {
  const DOCK = dock === null || dock === void 0 ? void 0 : dock.toUpperCase();
  return [DOCK, DOCK === "LEFT" || DOCK === "RIGHT"];
};
var Rotatable = (Target) => class Rotatable extends (Target || Base) {
  static get $name() {
    return "Rotatable";
  }
  static get configurable() {
    return {
      rotate: null,
      invertRotate: null
    };
  }
  compose() {
    const {
      rotate
    } = this;
    return {
      class: {
        [`b-rotate-${(rotate || "").toLowerCase()}`]: rotate,
        "b-rotate-vertical": rotate
      }
    };
  }
  syncRotationToDock(dock) {
    if (autoRotateRe.test(String(this.rotate))) {
      const [DOCK, vertical] = canonicalDock(dock);
      this.rotate = vertical ? this.invertRotate ? inverted[DOCK] : DOCK : null;
    }
  }
  get widgetClass() {
    return null;
  }
};
var Tool = class extends Widget.mixin(Rotatable) {
  compose() {
    const {
      align,
      href
    } = this;
    return {
      tag: href != null ? "a" : "button",
      class: {
        [`b-align-${align || "end"}`]: 1,
        "b-icon": 1
      },
      listeners: {
        click: "onInternalClick"
      }
    };
  }
  get focusElement() {
    return this.element;
  }
  get panel() {
    var _this$parent, _this$element;
    if ((_this$parent = this.parent) !== null && _this$parent !== void 0 && _this$parent.isPanel && (_this$element = this.element) !== null && _this$element !== void 0 && _this$element.parentNode.matches(".b-panel-header")) {
      return this.parent;
    }
  }
  changeAlign(align) {
    return align;
  }
  onInternalClick(domEvent) {
    const me = this, {
      handler,
      panel
    } = me, bryntumEvent = {
      domEvent,
      tool: me
    };
    if (me.disabled) {
      return;
    }
    me.trigger("click", bryntumEvent);
    if (!me.isDestroyed) {
      me.trigger("action", bryntumEvent);
      if (!me.isDestroyed && (panel === null || panel === void 0 ? void 0 : panel.trigger("toolClick", bryntumEvent)) !== false) {
        handler && me.callback(handler, panel, [domEvent, panel, me]);
      }
    }
  }
  onInternalKeyDown(keyEvent) {
    const keyName = keyEvent.key.trim() || keyEvent.code;
    if (keyName === "Enter") {
      keyEvent.cancelBubble = true;
      keyEvent.stopPropagation();
    }
  }
  updateDisabled(disabled, was) {
    var _this$repeat;
    super.updateDisabled(disabled, was);
    disabled && ((_this$repeat = this.repeat) === null || _this$repeat === void 0 ? void 0 : _this$repeat.cancel());
  }
  changeRepeat(repeat, oldRepeat) {
    oldRepeat === null || oldRepeat === void 0 ? void 0 : oldRepeat.destroy();
    return repeat && ClickRepeater.new({
      element: this.element
    }, repeat);
  }
};
_defineProperty(Tool, "$name", "Tool");
_defineProperty(Tool, "type", "tool");
_defineProperty(Tool, "configurable", {
  align: {
    value: null,
    $config: {
      merge: "replace"
    }
  },
  href: null,
  repeat: null,
  defaultBindProperty: null
});
Tool.initClass();
Tool._$name = "Tool";
var rightRe = /right/i;
var autoAlign = (tool) => (tool.collapsed || tool.collapsing) && tool.owner.expandedHeaderDock === "top" && tool.owner.collapsible.direction.match(rightRe) ? "start" : "end";
var CollapseTool = class extends Tool {
  static get $name() {
    return "CollapseTool";
  }
  static get type() {
    return "collapsetool";
  }
  static get configurable() {
    return {
      autoAlign: true,
      collapsed: null,
      collapsing: null,
      collapsify: false,
      direction: "up",
      defaultBindProperty: null
    };
  }
  compose() {
    const {
      collapsed,
      direction
    } = this;
    return {
      class: {
        [`b-icon-collapse-${direction}`]: 1,
        "b-collapsed": collapsed
      }
    };
  }
  changeAutoAlign(v) {
    return v === true ? autoAlign : v;
  }
  syncAutoAlign() {
    const {
      autoAlign: autoAlign2
    } = this;
    if (autoAlign2) {
      this.align = autoAlign2(this);
    }
  }
  updateAutoAlign() {
    this.syncAutoAlign();
  }
  updateCollapsed() {
    this.syncAutoAlign();
  }
  updateCollapsing() {
    this.syncAutoAlign();
  }
  updateDirection() {
    this.syncAutoAlign();
  }
};
CollapseTool.initClass();
CollapseTool._$name = "CollapseTool";
var defaultedDirectionRe = /^(?:UP|DOWN|LEFT|RIGHT)$/;
var dockBeforeRe = /^(left|top)$/i;
var emptyArray$4 = [];
var emptySplit$1 = [emptyArray$4, emptyArray$4];
var headerDockRe = /^b-dock-(top|left|right|bottom)$/;
var revealerCls = "b-panel-collapse-revealer";
var sideDockRe = /^(?:left|right)$/i;
var unflexCls = "b-collapse-unflex";
var {
  round
} = Math;
var canonicalDirection = ["up", "down", "left", "right"].reduce((o, v) => {
  o[v.toUpperCase()] = o[v] = v;
  return o;
}, {});
var clipByDock = {
  top: ["top", "bottom"],
  right: ["right", "left"],
  bottom: ["bottom", "top"],
  left: ["left", "right"]
};
var collapseDirectionByPlacement = {
  hl: "LEFT",
  hr: "RIGHT",
  vb: "DOWN",
  vt: "UP"
};
var crossAxis = {
  h: "w",
  w: "h"
};
var dockByDirection = {
  up: "top",
  right: "right",
  down: "bottom",
  left: "left"
};
var dockIsHorz$1 = {
  top: false,
  right: true,
  bottom: false,
  left: true
};
var directionByDock = {
  top: "UP",
  right: "RIGHT",
  bottom: "DOWN",
  left: "LEFT"
};
var transverseTransform = {
  top: (rect) => `translate(0, -${round(rect.height || 0)}px)`,
  bottom: (rect) => `translate(0, ${round(rect.height || 0)}px)`,
  right: (rect) => `translate(${round(rect.width || 0)}px, 0)`,
  left: (rect) => `translate(-${round(rect.width || 0)}px, 0)`
};
var idSeed = 0;
var PanelCollapser = class extends Base.mixin(Factoryable) {
  static get $name() {
    return "PanelCollapser";
  }
  static get type() {
    return "inline";
  }
  static get configurable() {
    return {
      animation: {
        duration: 200
      },
      collapsed: {
        value: null,
        $config: null,
        default: false
      },
      direction: null,
      collapseTooltip: "L{Collapse}",
      expandTooltip: "L{Expand}",
      panel: {
        value: null,
        $config: "nullify"
      },
      supportAxis: null,
      tool: {
        type: "collapsetool",
        handler(ev) {
          var _this$collapsible;
          (_this$collapsible = this.collapsible) === null || _this$collapsible === void 0 ? void 0 : _this$collapsible.onCollapseClick(ev);
        }
      }
    };
  }
  static get factoryable() {
    return {
      defaultType: "inline"
    };
  }
  get collapsing() {
    return this.collapsingExpanding === "collapsing";
  }
  get collapsingExpanding() {
    var _this$currentOperatio;
    const state = (_this$currentOperatio = this.currentOperation) === null || _this$currentOperatio === void 0 ? void 0 : _this$currentOperatio.collapsing;
    return state == null ? null : state ? "collapsing" : "expanding";
  }
  get currentDock() {
    var _this$panel$header$do, _this$panel, _this$panel$header, _this$panel$header$do2;
    return (_this$panel$header$do = (_this$panel = this.panel) === null || _this$panel === void 0 ? void 0 : (_this$panel$header = _this$panel.header) === null || _this$panel$header === void 0 ? void 0 : (_this$panel$header$do2 = _this$panel$header.dock) === null || _this$panel$header$do2 === void 0 ? void 0 : _this$panel$header$do2.toLowerCase()) !== null && _this$panel$header$do !== void 0 ? _this$panel$header$do : "top";
  }
  get expanding() {
    return this.collapsingExpanding === "expanding";
  }
  get collapseTool() {
    var _this$panel2, _this$panel2$tools;
    return (_this$panel2 = this.panel) === null || _this$panel2 === void 0 ? void 0 : (_this$panel2$tools = _this$panel2.tools) === null || _this$panel2$tools === void 0 ? void 0 : _this$panel2$tools.collapse;
  }
  get collapseDim() {
    return sideDockRe.test(this.collapseDir) ? "width" : "height";
  }
  getCollapseDir(canonical) {
    let {
      direction,
      panel
    } = this;
    if (!direction || defaultedDirectionRe.test(direction)) {
      const placement = panel === null || panel === void 0 ? void 0 : panel.placement;
      if (placement) {
        direction = collapseDirectionByPlacement[placement];
      } else {
        var _panel$header;
        direction = directionByDock[(panel === null || panel === void 0 ? void 0 : (_panel$header = panel.header) === null || _panel$header === void 0 ? void 0 : _panel$header.dock) || "top"];
      }
    }
    return canonical ? canonicalDirection[direction] : direction;
  }
  get collapseDir() {
    return this.getCollapseDir(true);
  }
  get collapseDock() {
    return this.collapseInfo[0];
  }
  get collapseInfo() {
    const {
      panel
    } = this, headerDock2 = panel.hasHeader && panel.expandedHeaderDock;
    let dock = dockByDirection[this.collapseDir], transverse = false;
    if (headerDock2) {
      if (!(transverse = dockIsHorz$1[dock] !== dockIsHorz$1[headerDock2])) {
        dock = headerDock2;
      }
    }
    return [dock, transverse];
  }
  get toolsConfig() {
    const {
      direction,
      tool
    } = this;
    return tool && {
      collapse: ObjectHelper.assign({
        direction: direction.toLowerCase()
      }, tool)
    };
  }
  beforeCollapse(operation) {
    const {
      panel
    } = this, {
      element
    } = panel;
    if (element.contains(DomHelper.getActiveElement(element))) {
      panel.revertFocus(true);
    }
  }
  changeTool(tool) {
    const me = this, {
      panel
    } = me;
    if (me.isConfiguring || me.isDestroying || !panel || panel.isDestroying) {
      return tool;
    }
    panel.tools = {
      collapse: tool
    };
  }
  collapse(collapsed) {
    var _collapsed, _currentOperation, _currentOperation$ani, _currentOperation2, _currentOperation2$an;
    const me = this, {
      panel
    } = me, operation = {
      id: ++idSeed,
      completed: false,
      panel
    };
    let {
      currentOperation
    } = me;
    collapsed = (_collapsed = collapsed) !== null && _collapsed !== void 0 ? _collapsed : true;
    if (ObjectHelper.isObject(collapsed)) {
      operation.collapsed = true;
      ObjectHelper.assign(operation, collapsed);
      collapsed = operation.collapsed;
      delete operation.collapsed;
    }
    operation.collapsing = collapsed;
    operation.previous = (_currentOperation = currentOperation) !== null && _currentOperation !== void 0 ? _currentOperation : null;
    if (collapsed !== me.collapsed) {
      if (currentOperation) {
        if (currentOperation.collapsing !== collapsed) {
          operation.animation = currentOperation.animation.revert({
            finalize() {
              var _me$collapseFinalize;
              (_me$collapseFinalize = me.collapseFinalize) === null || _me$collapseFinalize === void 0 ? void 0 : _me$collapseFinalize.call(me, operation, true);
            }
          });
          operation.collapsing = collapsed;
          currentOperation = operation;
        }
      } else {
        operation.animation = ObjectHelper.clone(("animation" in operation ? operation : me).animation);
        if (me.beforeCollapse(operation) !== false) {
          if (operation.animation) {
            operation.animation.finalize = (complete) => {
              var _me$collapseFinalize2;
              return (_me$collapseFinalize2 = me.collapseFinalize) === null || _me$collapseFinalize2 === void 0 ? void 0 : _me$collapseFinalize2.call(me, operation, complete);
            };
          }
          panel.changingCollapse = true;
          me[collapsed ? "collapseBegin" : "expandBegin"](operation);
          if (operation.animation) {
            currentOperation = operation;
          } else {
            operation.completed = true;
            me[collapsed ? "collapseEnd" : "expandEnd"](operation);
          }
          panel.changingCollapse = false;
          if (!operation.animation) {
            me.onComplete(collapsed ? "collapse" : "expand");
          }
        }
      }
    } else if (currentOperation && currentOperation.collapsing !== collapsed) {
      me[collapsed ? "expandRevert" : "collapseRevert"](operation);
      operation.animation = currentOperation.animation.revert({
        finalize() {
          var _me$collapseFinalize3;
          (_me$collapseFinalize3 = me.collapseFinalize) === null || _me$collapseFinalize3 === void 0 ? void 0 : _me$collapseFinalize3.call(me, operation, false);
        }
      });
      currentOperation = operation;
    }
    me.currentOperation = currentOperation;
    return (_currentOperation$ani = (_currentOperation2 = currentOperation) === null || _currentOperation2 === void 0 ? void 0 : (_currentOperation2$an = _currentOperation2.animation) === null || _currentOperation2$an === void 0 ? void 0 : _currentOperation2$an.done()) !== null && _currentOperation$ani !== void 0 ? _currentOperation$ani : Promise.resolve(collapsed === me.collapsed);
  }
  collapseFinalize(operation, complete) {
    const me = this, {
      currentOperation,
      panel
    } = me, action = panel.collapsed ? "expand" : "collapse";
    if (currentOperation === operation) {
      me.currentOperation = null;
      operation.completed = complete;
      panel.changingCollapse = true;
      me[action + "End"](operation);
      panel.changingCollapse = false;
      complete && me.onComplete(action);
    }
  }
  applyHeaderDock(collapsed, flush = true) {
    const me = this, {
      currentDock,
      panel
    } = me, dock = collapsed ? me.collapseDock : panel.expandedHeaderDock;
    if (dock !== currentDock && panel.hasHeader) {
      panel.header = {
        dock
      };
      flush && panel.recompose.flush();
    }
  }
  composeHeader(header) {
    const {
      panel
    } = this, {
      class: cls
    } = header, dock = panel.expandedHeaderDock || Object.keys(cls).filter((k) => cls[k] && headerDockRe.test(k)).map((k) => headerDockRe.exec(k)[1][0]);
    cls[revealerCls] = 1;
    cls[`b-collapsible-${dock[0]}${this.collapseDir[0]}`] = 1;
    return header;
  }
  composeTitle(title) {
    title.class[revealerCls] = 1;
    return title;
  }
  collapseBegin(operation) {
    var _panel$headerElement;
    const me = this, {
      animation
    } = operation, {
      collapseDim,
      collapseTool,
      panel
    } = me, {
      element,
      placement
    } = panel, [collapseDock, transverse] = me.collapseInfo, collapseToolClasses = collapseTool === null || collapseTool === void 0 ? void 0 : collapseTool.element.classList, unflex = !placement || placement[0] === "h" && collapseDim === "width" || placement[0] === "v" && collapseDim === "height";
    me.configuredWidth = panel._lastWidth;
    me.configuredHeight = panel._lastHeight;
    me.transverseCollapse = transverse;
    me.applyHeaderDock(true);
    const panelRect = panel.rectangle(), bodyWrapRect = me.lockInnerSize().moveTo(0, 0), bodyWrapClipRect = bodyWrapRect.clone(), clipDir = clipByDock[collapseDock], headerRect = (_panel$headerElement = panel.headerElement) === null || _panel$headerElement === void 0 ? void 0 : _panel$headerElement.getBoundingClientRect(), collapsedSize = round((headerRect === null || headerRect === void 0 ? void 0 : headerRect[collapseDim]) || 0);
    element.classList.toggle(unflexCls, unflex);
    if (animation) {
      bodyWrapClipRect[clipDir[0]] = bodyWrapClipRect[clipDir[1]];
      element.classList.add("b-collapsing");
      collapseToolClasses === null || collapseToolClasses === void 0 ? void 0 : collapseToolClasses.add("b-collapsed", "b-collapsing");
      if (collapseTool) {
        collapseTool.collapsing = true;
      }
      if (collapseToolClasses) {
        collapseToolClasses.remove("b-collapsed");
        panel.rectangle();
        collapseToolClasses.remove("b-collapsing");
        collapseToolClasses.add("b-collapsed");
      }
      animation.element = element;
      animation.retain = true;
      animation[collapseDim] = {
        from: round(panelRect[collapseDim]),
        to: collapsedSize
      };
      animation.items = [{
        element: me.innerElement,
        retain: false,
        clip: {
          from: `rect(${bodyWrapRect})`,
          to: `rect(${bodyWrapClipRect})`
        }
      }];
      if (transverse) {
        animation.items.push({
          element: panel.headerElement,
          duration: animation.duration,
          retain: false,
          transform: {
            from: transverseTransform[collapseDock](headerRect),
            to: `translate(0, 0)`
          }
        });
      }
      operation.animation = Animator.run(animation);
    } else {
      element.style[collapseDim] = `${collapsedSize}px`;
      if (collapseTool) {
        collapseToolClasses.add("b-collapsing", "b-collapsed");
        collapseTool.rectangle();
        collapseToolClasses.remove("b-collapsing");
      }
    }
  }
  collapseEnd(operation) {
    const me = this, {
      collapseTool
    } = me;
    me.panel.element.classList.remove("b-collapsing");
    if (collapseTool) {
      collapseTool.collapsing = false;
    }
    if (operation.completed) {
      me.collapsed = true;
    } else {
      me.applyHeaderDock(false);
      me.restoreConfiguredSize();
      me.lockInnerSize(false);
    }
  }
  collapseRevert(operation) {
    var _this$collapseTool;
    (_this$collapseTool = this.collapseTool) === null || _this$collapseTool === void 0 ? void 0 : _this$collapseTool.element.classList.remove("b-collapsed");
  }
  expandBegin(operation) {
    const me = this, {
      animation
    } = operation, {
      collapseDim,
      collapseTool,
      panel
    } = me, [collapseDock, transverse] = me.collapseInfo, {
      element
    } = panel, elementClassList = element.classList, unflex = elementClassList.contains(unflexCls), fromRect = panel.rectangle();
    elementClassList.remove("b-collapsed", "b-collapsing");
    panel.element.style[collapseDim] = "";
    me.restoreConfiguredSize();
    me.lockInnerSize(false);
    const toRect = panel.rectangle(), bodyWrapRect = me.lockInnerSize().moveTo(0, 0), bodyWrapClipRect = bodyWrapRect.clone(), clipDir = clipByDock[me.collapseDock];
    collapseTool === null || collapseTool === void 0 ? void 0 : collapseTool.element.classList.remove("b-collapsed");
    if (animation) {
      bodyWrapClipRect[clipDir[0]] = bodyWrapClipRect[clipDir[1]];
      elementClassList.add("b-collapsed", "b-expanding");
      unflex && elementClassList.add(unflexCls);
      animation.element = element;
      animation[collapseDim] = {
        from: round(fromRect[collapseDim]),
        to: round(toRect[collapseDim])
      };
      animation.items = [{
        element: me.innerElement,
        retain: false,
        clip: {
          from: `rect(${bodyWrapClipRect})`,
          to: `rect(${bodyWrapRect})`
        }
      }];
      if (transverse) {
        animation.items.push({
          element: panel.headerElement,
          duration: animation.duration,
          retain: false,
          transform: {
            from: `translate(0, 0)`,
            to: transverseTransform[collapseDock](fromRect)
          }
        });
      }
      operation.animation = Animator.run(animation);
    }
  }
  expandEnd(operation) {
    const me = this;
    me.panel.element.classList.remove("b-expanding");
    if (operation.completed) {
      me.collapsed = false;
      me.applyHeaderDock(false);
      me.restoreConfiguredSize();
      me.lockInnerSize(false);
    }
  }
  expandRevert(operation) {
    var _this$collapseTool2;
    (_this$collapseTool2 = this.collapseTool) === null || _this$collapseTool2 === void 0 ? void 0 : _this$collapseTool2.element.classList.add("b-collapsed");
  }
  get innerElement() {
    return this.panel.collapseWrapElement || this.panel.bodyWrapElement;
  }
  get innerSizeElement() {
    return this.transverseCollapse ? this.panel.element : this.innerElement;
  }
  get supportAxis() {
    let {
      _supportAxis
    } = this;
    const fullSupport = _supportAxis === true;
    if (fullSupport || _supportAxis == null) {
      _supportAxis = this.collapseDim[0];
      if (fullSupport || DomHelper.getStyleValue(this.panel.element, "position") === "absolute") {
        _supportAxis += crossAxis[_supportAxis];
      }
    }
    return _supportAxis || "";
  }
  lockInnerSize(lock = true) {
    const me = this, {
      innerElement,
      panel
    } = me, supportAxis = lock ? me.supportAxis : "", panelEl = panel.element, headerEl = panel.headerElement, headerRect = lock && headerEl && Rectangle.from(headerEl, panelEl), innerRect = lock && Rectangle.from(me.innerSizeElement, panelEl), innerStyle = innerElement.style;
    if (headerEl) {
      headerEl.style.minWidth = supportAxis.includes("w") ? `${headerRect.width}px` : "";
      headerEl.style.minHeight = supportAxis.includes("h") ? `${headerRect.height}px` : "";
    }
    innerStyle.width = lock ? `${innerRect.width}px` : "";
    innerStyle.height = lock ? `${innerRect.height}px` : "";
    innerElement.classList[lock ? "add" : "remove"]("b-panel-collapse-size-locker");
    return innerRect;
  }
  onCollapseClick(e) {
    let collapsed = this.collapsing ? false : this.expanding ? true : !this.collapsed;
    if (e.altKey) {
      collapsed = {
        animation: null,
        collapsed
      };
    }
    this.collapse(collapsed);
  }
  onComplete(action) {
    var _this$panel3;
    (_this$panel3 = this.panel) === null || _this$panel3 === void 0 ? void 0 : _this$panel3.trigger(action);
  }
  onHeaderClick({
    event
  }) {
    if (event.button === 0 && this.panel.collapsed && event.target.classList.contains(revealerCls)) {
      this.onRevealerClick();
    }
  }
  onPanelConfigChange({
    name,
    value
  }) {
    const me = this, {
      panel
    } = me;
    if (name === "collapsed") {
      if (panel.isPainted) {
        me.collapsed = value;
      }
    } else if (name === "header" && !panel.changingCollapse) {
      me.syncDirection();
    }
  }
  onPanelPaint() {
    this.syncDirection();
    if (this.panel.collapsed && !this.collapsed) {
      this.collapse({
        animation: null,
        collapsed: true
      });
    }
  }
  onRevealerClick() {
    this.panel._collapse({
      collapsed: false
    });
  }
  restoreConfiguredSize(which) {
    var _which;
    const {
      configuredHeight,
      configuredWidth,
      panel
    } = this;
    which = (_which = which) !== null && _which !== void 0 ? _which : "wh";
    panel.element.classList.remove(unflexCls);
    if (configuredWidth != null && which.includes("w")) {
      panel.width = configuredWidth;
    }
    if (configuredHeight != null && which.includes("h")) {
      panel.height = configuredHeight;
    }
  }
  splitHeaderItems() {
    return emptySplit$1;
  }
  syncDirection() {
    const me = this, {
      direction
    } = me;
    if (!direction || defaultedDirectionRe.test(direction)) {
      me.direction = me.getCollapseDir();
    }
  }
  updateCollapsed(collapsed) {
    const {
      collapseTool,
      panel
    } = this;
    if (panel) {
      panel.collapsed = collapsed;
      panel.element.classList[collapsed ? "add" : "remove"]("b-collapsed");
    }
    if (collapseTool) {
      collapseTool.collapsed = collapsed;
    }
  }
  updateDirection(direction) {
    const {
      collapseTool,
      panel
    } = this;
    if (collapseTool) {
      collapseTool.direction = canonicalDirection[direction];
    }
    if (panel !== null && panel !== void 0 && panel.rendered) {
      panel.recompose();
    }
  }
  updatePanel(panel) {
    var _me$panelChangeDetach;
    const me = this;
    me.syncDirection();
    (_me$panelChangeDetach = me.panelChangeDetacher) === null || _me$panelChangeDetach === void 0 ? void 0 : _me$panelChangeDetach.call(me);
    me.panelChangeDetacher = panel && FunctionHelper.after(panel, "onConfigChange", "onPanelConfigChange", me, {
      return: false
    });
  }
  wrapCollapser(key, body) {
    var _panel$tools;
    const me = this, [collapseDock, transverse] = me.collapseInfo;
    if (!transverse) {
      return [key, body];
    }
    const {
      collapseDir,
      panel
    } = me, {
      expandedHeaderDock,
      header: panelHeader,
      uiClassList
    } = panel, recollapse = (_panel$tools = panel.tools) === null || _panel$tools === void 0 ? void 0 : _panel$tools.recollapse, [before, after] = me.splitHeaderItems({
      dock: collapseDock,
      as: "element"
    }), title = panel.hasHeader ? panel.title || (panelHeader === null || panelHeader === void 0 ? void 0 : panelHeader.title) || "\xA0" : null, headerElement = title && {
      tag: "header",
      class: new DomClassList(_objectSpread2(_objectSpread2({}, uiClassList), {}, {
        [`b-dock-${expandedHeaderDock}`]: 1,
        "b-panel-header": 1,
        "b-panel-collapser-header": 1
      }), panelHeader === null || panelHeader === void 0 ? void 0 : panelHeader.cls),
      children: [...before, {
        reference: "collapserTitleElement",
        html: title,
        class: _objectSpread2(_objectSpread2({}, uiClassList), {}, {
          [`b-align-${(panelHeader === null || panelHeader === void 0 ? void 0 : panelHeader.titleAlign) || "start"}`]: 1,
          "b-header-title": 1
        })
      }, ...after]
    };
    if (recollapse) {
      recollapse.direction = collapseDir;
    }
    return ["collapseWrapElement", {
      class: _objectSpread2(_objectSpread2({}, uiClassList), {}, {
        [`b-panel-collapser-header-${expandedHeaderDock}`]: 1,
        [`b-panel-collapser-${collapseDir}`]: 1,
        [`b-${dockIsHorz$1[expandedHeaderDock] ? "h" : "v"}box`]: 1,
        "b-panel-collapser": 1,
        "b-box-center": 1
      }),
      children: dockBeforeRe.test(expandedHeaderDock) ? {
        collapserHeaderElement: headerElement,
        [key]: body
      } : {
        [key]: body,
        collapserHeaderElement: headerElement
      }
    }];
  }
};
PanelCollapser.maps = {
  clipByDock,
  dockByDirection,
  dockIsHorz: dockIsHorz$1
};
PanelCollapser.initClass();
PanelCollapser._$name = "PanelCollapser";
var PENDING = Symbol("pendingCreate");
var DynamicObject = class extends Base {
  static get prototypeProperties() {
    return {
      cleanup: null,
      configName: null,
      created: null,
      factory: null,
      inferType: "name",
      owner: null,
      ownerName: null,
      proxyable: typeof Proxy !== "undefined",
      setup: null,
      transform: null
    };
  }
  static get properties() {
    return {
      defaults: {},
      instances: {},
      object: /* @__PURE__ */ Object.create({})
    };
  }
  get proxy() {
    const me = this;
    let proxy = null;
    if (me.proxyable) {
      proxy = new Proxy(me.instances, {
        get(o, name) {
          return me.get(name);
        },
        set(o, name, value) {
          me.set(name, value);
          return true;
        },
        deleteProperty(o, name) {
          me.set(name, null);
          return true;
        }
      });
    }
    Reflect.defineProperty(me, "proxy", {
      configurable: true,
      value: proxy
    });
    return proxy;
  }
  get target() {
    return this.proxy || this.object;
  }
  define(name, config) {
    const me = this, {
      transform
    } = me, transformed = transform ? transform(config, name) : config, instantiated = ObjectHelper.isInstantiated(transformed);
    me.instances[name] = PENDING;
    if (!instantiated) {
      me.setDefaults(name, transformed);
    }
    me.defineProp(name, true);
    if (instantiated) {
      me.set(name, transformed);
    }
  }
  defineProp(name, base) {
    const me = this, {
      object
    } = me;
    if (!me.proxy) {
      Reflect.defineProperty(base ? Object.getPrototypeOf(object) : object, name, {
        configurable: !base,
        enumerable: true,
        get() {
          return me.get(name);
        },
        set(value) {
          return me.set(name, value);
        }
      });
    }
  }
  flush() {
    const me = this;
    try {
      var _me$afterConfigureOwn;
      me.updating = true;
      for (const name in me.defaults) {
        me.get(name);
      }
      me.afterConfigureOwner = (_me$afterConfigureOwn = me.afterConfigureOwner) === null || _me$afterConfigureOwn === void 0 ? void 0 : _me$afterConfigureOwn.call(me);
    } finally {
      me.updating = false;
    }
  }
  get(name) {
    const {
      defaults,
      instances
    } = this;
    if (instances[name] === PENDING) {
      this.set(name, PENDING);
    }
    return instances[name] || defaults[name] && null;
  }
  set(name, value) {
    const me = this, {
      cleanup,
      configName,
      defaults,
      factory,
      instances,
      owner,
      setup,
      transform,
      updating
    } = me, inform = owner && configName && !updating, was = instances[name] === PENDING ? null : instances[name], instance = factory.reconfigure(was, value === PENDING ? {} : value || null, {
      cleanup: cleanup && ((instance2) => cleanup(instance2, name)),
      defaults: defaults[name] || me.setDefaults(name, {}),
      owner: me.owner,
      setup: setup && ((config, type, defaults2) => setup(config, name, type, defaults2)),
      transform: transform && ((config) => transform(config, name))
    });
    if (instance !== was) {
      const before = inform && _objectSpread2({}, instances);
      instances[name] = instance;
      if (instance) {
        var _me$created;
        me.defineProp(name);
        (_me$created = me.created) === null || _me$created === void 0 ? void 0 : _me$created.call(me, instance, name);
      } else {
        delete me.object[name];
        delete instances[name];
      }
      if (inform) {
        owner.onConfigChange({
          name: configName,
          config: owner.$meta.configs[configName],
          value: me.target,
          was: before
        });
      }
    }
  }
  setDefaults(name, config) {
    const {
      defaults,
      factory,
      inferType,
      instances,
      owner,
      ownerName
    } = this, {
      typeKey
    } = factory.factoryable;
    config = config === true ? {} : ObjectHelper.assign({}, config);
    if (inferType === "name" || inferType === true && !config[typeKey]) {
      config[typeKey] = name;
    }
    if (ownerName) {
      config[ownerName] = owner;
    }
    config.beforeConfigure = (instance) => {
      instances[name] = instance;
    };
    return defaults[name] = config;
  }
  update(members) {
    const me = this, {
      owner
    } = me;
    let name, config;
    try {
      me.updating = true;
      if (members) {
        for (name in members) {
          config = members[name];
          if (me.defaults[name]) {
            me.set(name, config);
          } else if (config) {
            me.define(name, config);
          }
        }
      } else {
        for (name in me.instances) {
          me.set(name, null);
        }
      }
    } finally {
      me.updating = false;
    }
    if (owner) {
      if (!owner.isConfiguring) {
        me.flush();
      } else if (!me.afterConfigureOwner) {
        me.afterConfigureOwner = FunctionHelper.before(owner, "afterConfigure", "flush", me);
      }
    }
  }
};
DynamicObject.initClass();
DynamicObject._$name = "DynamicObject";
var emptyArray$3 = [];
var emptyObject$2 = {};
var toolConfigs = {
  align: 1,
  weight: 1
};
var Toolable = (Target) => class Toolable extends (Target || Widget) {
  static get $name() {
    return "Toolable";
  }
  static get configurable() {
    return {
      tools: {
        value: null,
        $config: {
          nullify: true
        }
      },
      toolDefaults: {
        "*": {
          type: "tool",
          align: "end"
        }
      }
    };
  }
  byWeightSortFn(a, b) {
    return (a.weight || 0) - (b.weight || 0);
  }
  byWeightReverseSortFn(a, b) {
    return (b.weight || 0) - (a.weight || 0);
  }
  gatherTools({
    align,
    overlay,
    refs
  } = emptyObject$2) {
    const {
      collapsed,
      tools
    } = this;
    let ret = [], alignment, key, i, item, tool;
    for (key in tools) {
      var _ref, _tool$align$align, _tool, _tool$align, _tool2;
      tool = tools[key];
      alignment = (_ref = (_tool$align$align = (_tool = tool) === null || _tool === void 0 ? void 0 : (_tool$align = _tool.align) === null || _tool$align === void 0 ? void 0 : _tool$align.align) !== null && _tool$align$align !== void 0 ? _tool$align$align : (_tool2 = tool) === null || _tool2 === void 0 ? void 0 : _tool2.align) !== null && _ref !== void 0 ? _ref : "end";
      if (alignment === align && tool.isCollapsified(collapsed, overlay)) {
        ret.push(tool);
      }
    }
    ret.sort(this[align === "end" ? "byWeightReverseSortFn" : "byWeightSortFn"]);
    if (refs) {
      const asWidget = refs === "widget", asRefs = {};
      for (i = 0; i < ret.length; ++i) {
        item = ret[i];
        asRefs[item.ref] = asWidget ? item : item.element;
      }
      ret = asRefs;
    }
    return ret;
  }
  getEndTools({
    overlay,
    refs
  } = emptyObject$2) {
    return this.gatherTools({
      align: "end",
      overlay,
      refs
    });
  }
  getStartTools({
    overlay,
    refs
  } = emptyObject$2) {
    return this.gatherTools({
      align: "start",
      overlay,
      refs
    });
  }
  get childItems() {
    return [...this.getStartTools(), ...this._items || emptyArray$3, ...this.getEndTools()];
  }
  changeTools(tools, oldTools) {
    const me = this, manager = me.$tools || (me.$tools = new DynamicObject({
      configName: "tools",
      factory: Widget,
      inferType: false,
      owner: me,
      created(instance) {
        var _instance$syncRotatio, _me$header;
        instance.innerItem = false;
        (_instance$syncRotatio = instance.syncRotationToDock) === null || _instance$syncRotatio === void 0 ? void 0 : _instance$syncRotatio.call(instance, (_me$header = me.header) === null || _me$header === void 0 ? void 0 : _me$header.dock);
        FunctionHelper.after(instance, "onConfigChange", (ret, {
          name
        }) => {
          if (toolConfigs[name]) {
            me.onConfigChange({
              name: "tools",
              value: manager.target
            });
          }
        });
        me.onChildAdd(instance);
      },
      setup(config, name) {
        config = ObjectHelper.merge({}, me.toolDefaults["*"], me.toolDefaults[name], config);
        config.parent = me;
        config.ref = name;
        return config;
      }
    }));
    manager.update(tools);
    if (!oldTools) {
      return manager.target;
    }
  }
  get widgetClass() {
  }
};
var directionCls = ["b-hbox", "b-vbox"];
var syncAlign = {
  name: "align",
  style: "alignItems"
};
var syncContentAlign = {
  name: "contentAlign",
  style: "alignContent"
};
var syncDirection = {
  name: "direction",
  style: "flexDirection"
};
var syncJustify = {
  name: "justify",
  style: "justifyContent",
  classes: ["stretch"]
};
var syncWrap = {
  name: "wrap",
  style: "flexWrap",
  map: {
    false: "nowrap",
    true: "wrap",
    reverse: "wrap-reverse"
  }
};
var Box = class extends Layout {
  get vertical() {
    return this.horizontal === false;
  }
  set vertical(v) {
    return this.horizontal = !v;
  }
  updateAlign() {
    this.syncConfigStyle(syncAlign);
  }
  updateContentAlign() {
    this.syncConfigStyle(syncContentAlign);
  }
  updateDirection() {
    this.syncConfigStyle(syncDirection);
  }
  updateHorizontal() {
    var _me$contentElement;
    const me = this, classList = (_me$contentElement = me.contentElement) === null || _me$contentElement === void 0 ? void 0 : _me$contentElement.classList, vertical = Number(me.vertical);
    if (classList) {
      classList.remove(directionCls[1 - vertical]);
      classList.add(directionCls[vertical]);
    } else {
      me.syncConfigLater("horizontal");
    }
    me.syncDirection();
  }
  updateJustify() {
    this.syncConfigStyle(syncJustify);
  }
  updateReverse() {
    this.syncDirection();
  }
  updateWrap() {
    this.syncConfigStyle(syncWrap);
  }
  syncDirection() {
    const me = this, {
      reverse
    } = me;
    me.direction = reverse ? `${me.vertical ? "column" : "row"}${reverse ? "-reverse" : ""}` : null;
  }
};
_defineProperty(Box, "$name", "Box");
_defineProperty(Box, "type", "box");
_defineProperty(Box, "alias", "hbox");
_defineProperty(Box, "configurable", {
  itemCls: "b-box-item",
  align: null,
  contentAlign: null,
  direction: null,
  horizontal: true,
  justify: null,
  reverse: null,
  wrap: null
});
Box.initClass();
Box._$name = "Box";
var VBox = class extends Box {
};
_defineProperty(VBox, "$name", "VBox");
_defineProperty(VBox, "type", "vbox");
_defineProperty(VBox, "configurable", {
  horizontal: false
});
VBox.initClass();
VBox._$name = "VBox";
var Badge = (Target) => class Badge extends (Target || Base) {
  static get $name() {
    return "Badge";
  }
  static get configurable() {
    return {
      badge: null
    };
  }
  compose() {
    const {
      badge
    } = this;
    return {
      dataset: {
        badge
      },
      class: {
        "b-badge": badge != null && badge !== ""
      }
    };
  }
};
var bIcon$1 = /(?:^|\s)b-icon-/;
var bFa$1 = /(?:^|\s)b-fa-/;
var defaultToggleable = Symbol("defaultToggleable");
var fullConfigKeys = ["items", "type", "widgets", "html", "listeners"];
var menuListenersName = Symbol("defaultListener");
var Button = class extends Widget.mixin(Badge, Rotatable) {
  static get $name() {
    return "Button";
  }
  static get type() {
    return "button";
  }
  static get configurable() {
    return {
      icon: null,
      menuIcon: "b-icon-picker",
      pressedIcon: null,
      iconAlign: "start",
      text: {
        value: null,
        $config: null,
        default: ""
      },
      color: null,
      toggleable: defaultToggleable,
      pressed: false,
      toggleGroup: null,
      ripple: {
        radius: 75
      },
      forwardTwinEvents: ["action", "toggle"],
      localizableProperties: ["text"],
      menu: {
        $config: ["lazy", "nullify"],
        value: null
      },
      menuDefaults: {
        type: "menu",
        autoShow: false,
        autoClose: true,
        floating: true,
        scrollAction: "realign",
        align: "t0-b0"
      },
      href: null,
      target: null,
      defaultBindProperty: null
    };
  }
  updateElement(element, oldElement) {
    var _constructor$resolveT, _constructor$resolveT2, _constructor$configur;
    const me = this, {
      constructor
    } = me, result = super.updateElement(element, oldElement), menu = me.peekConfig("menu"), role = menu ? menu.isWidget ? menu.role : ((_constructor$resolveT = constructor.resolveType(menu.type)) === null || _constructor$resolveT === void 0 ? void 0 : (_constructor$resolveT2 = _constructor$resolveT.configurable) === null || _constructor$resolveT2 === void 0 ? void 0 : _constructor$resolveT2.role) || ((_constructor$configur = constructor.configurable.menuDefaults) === null || _constructor$configur === void 0 ? void 0 : _constructor$configur.type) || "menu" : false;
    me.ariaHasPopup = role;
    return result;
  }
  compose() {
    const {
      color,
      href,
      icon,
      iconAlign,
      pressed,
      pressedIcon,
      target,
      text,
      toggleable,
      toggleGroup,
      menuIcon
    } = this, hasMenu = this.hasConfig("menu"), iconCls = pressed && pressedIcon ? pressedIcon : icon;
    return {
      tag: href ? "a" : "button",
      href,
      target,
      class: {
        [`b-icon-align-${iconAlign}`]: icon,
        [color]: Boolean(color),
        "b-pressed": pressed && toggleable,
        "b-text": Boolean(text),
        "b-has-menu": hasMenu
      },
      "aria-pressed": pressed,
      dataset: {
        group: toggleGroup
      },
      listeners: {
        click: "onInternalClick",
        mousedown: "onInternalMousedown"
      },
      children: {
        iconElement: (icon || pressedIcon) && {
          "aria-hidden": true,
          tag: "i",
          class: _objectSpread2(_objectSpread2({}, DomClassList.normalize(iconCls, "object")), {}, {
            "b-icon": bIcon$1.test(iconCls),
            "b-fa": bFa$1.test(iconCls)
          })
        },
        label: text && {
          tag: "label",
          text
        },
        menuIconElement: hasMenu && menuIcon && {
          tag: "i",
          class: {
            "b-icon": bIcon$1.test(menuIcon),
            "b-fa": bFa$1.test(menuIcon),
            "b-button-menu-icon": 1,
            [menuIcon]: 1
          }
        }
      }
    };
  }
  configureOverflowTwin(overrides) {
    const me = this, config = super.configureOverflowTwin(overrides);
    if (!config.text) {
      config.text = me.tooltipText;
    }
    return config;
  }
  onHide() {
    var _this$_menu;
    (_this$_menu = this._menu) === null || _this$_menu === void 0 ? void 0 : _this$_menu.hide();
  }
  get childItems() {
    return this._menu && [this.menu];
  }
  onFocusOut(e) {
    var _this$menu;
    super.onFocusOut(e);
    (_this$menu = this.menu) === null || _this$menu === void 0 ? void 0 : _this$menu.hide();
  }
  get focusElement() {
    return this.element;
  }
  changeText(text) {
    return text == null ? "" : text;
  }
  changeToggleable(toggleable) {
    if (toggleable === defaultToggleable) {
      return this.toggleGroup || this.config.menu;
    }
    return toggleable;
  }
  changeMenu(menu, oldMenu) {
    const me = this, {
      element: forElement
    } = me;
    if (menu) {
      if (menu.isWidget) {
        menu.forElement = forElement;
        menu.owner = me;
        menu.constrainTo = me.rootElement;
      } else {
        if (typeof menu === "object" && !fullConfigKeys.some((key) => key in menu)) {
          menu = {
            lazyItems: menu
          };
        }
        menu = Widget.reconfigure(oldMenu, menu ? ObjectHelper.merge({
          owner: me,
          constrainTo: me.rootElement,
          forElement
        }, me.menuDefaults, menu) : null, me);
      }
      menu.align.constrainPadding = 10;
      me.detachListeners(menuListenersName);
      menu.ion({
        name: menuListenersName,
        beforeShow: "onMenuBeforeShow",
        hide: "onMenuHide",
        show: "onMenuShow",
        thisObj: this
      });
    } else {
      oldMenu === null || oldMenu === void 0 ? void 0 : oldMenu.destroy();
    }
    return menu;
  }
  onMenuBeforeShow({
    source
  }) {
    return this.trigger("beforeShowMenu", {
      menu: source
    });
  }
  onMenuShow() {
    this.ariaElement.setAttribute("aria-expanded", true);
  }
  onMenuHide() {
    this.ariaElement.setAttribute("aria-expanded", false);
    this.toggle(false);
  }
  updateMenu(menu) {
    this.toggleable = Boolean(menu);
  }
  updatePressed(pressed) {
    const me = this;
    if (!me.toggleable || me.isConfiguring) {
      return;
    }
    const {
      menu
    } = me;
    if (pressed) {
      DomHelper.forEachSelector(me.rootElement, `button[data-group=${me.toggleGroup}]`, (btnEl) => {
        if (btnEl !== me.element) {
          Widget.getById(btnEl.id).pressed = false;
        }
      });
    }
    if (menu) {
      var _menu$_minHeight, _menu$_minWidth;
      if (!menu.initialConfig.minWidth) {
        menu.minWidth = me.width;
      }
      menu.align.minHeight = (_menu$_minHeight = menu._minHeight) !== null && _menu$_minHeight !== void 0 ? _menu$_minHeight : 100;
      menu.align.minWidth = (_menu$_minWidth = menu._minWidth) !== null && _menu$_minWidth !== void 0 ? _menu$_minWidth : 100;
      menu[pressed ? "show" : "hide"]();
    }
    me.trigger("toggle", {
      pressed
    });
  }
  onInternalMousedown(event) {
    var _this$_menu2;
    if ((_this$_menu2 = this._menu) !== null && _this$_menu2 !== void 0 && _this$_menu2.containsFocus && this.pressed) {
      event.preventDefault();
    }
  }
  onInternalClick(event) {
    const me = this, bryntumEvent = {
      event
    };
    if (me.disabled) {
      return;
    }
    if (me.toggleable) {
      if (me.toggleGroup && me.pressed) {
        return;
      }
      me.toggle(!me.pressed);
      if (me.isDestroyed) {
        return;
      }
    }
    me.trigger("click", bryntumEvent);
    if (!me.isDestroyed) {
      me.trigger("action", bryntumEvent);
    }
    if (!me.href) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  toggle(pressed = !this.pressed) {
    if (this.trigger("beforeToggle", {
      pressed
    }) !== false) {
      this.pressed = pressed;
    }
  }
};
Button.initClass();
Button._$name = "Button";
var asElementRefs = {
  refs: "element"
};
var onCreateTwin = (overflowTwin) => overflowTwin.element.style.margin = "";
var isToolbar = (w) => w.isToolbar;
var itemScoreFn = (ent) => ent[0] + (ent[1].minifiable ? 0 : 9e9);
var twinOverrides = {
  hidden: false,
  width: ""
};
var twinOverridesHorz = _objectSpread2(_objectSpread2({}, twinOverrides), {}, {
  flex: ""
});
var _axisProps = [{
  box: "hbox",
  clientSizeProp: "clientWidth",
  edgeProp: "right",
  flexDir: "row",
  horizontal: true,
  max: "maxX",
  overflow: "overflowX",
  pos: "x",
  scrollSize: "scrollWidth",
  sizeProp: "width"
}, {
  box: "vbox",
  clientSizeProp: "clientHeight",
  edgeProp: "bottom",
  flexDir: "column",
  horizontal: false,
  max: "maxY",
  overflow: "overflowY",
  pos: "y",
  scrollSize: "scrollHeight",
  sizeProp: "height"
}];
var defaultRepeat = {
  delay: 0,
  startRate: 40,
  endRate: 200,
  accelerateDuration: 500
};
var nonSyncedConfigs = {
  menu: 1,
  pressed: 1
};
var Toolbar = class extends Container.mixin(Toolable) {
  static get $name() {
    return "Toolbar";
  }
  static get type() {
    return "toolbar";
  }
  static get delayable() {
    return {
      syncOverflowVisibility: {
        type: "raf",
        cancelOutstanding: true
      }
    };
  }
  static get configurable() {
    return {
      defaultType: "button",
      dock: "top",
      layout: {
        type: "box"
      },
      overflow: {
        $config: ["lazy", "nullify"],
        value: {
          type: "menu"
        }
      },
      toolDefaults: {
        overflowMenuButton: {
          type: "button",
          hidden: true,
          icon: "b-icon-menu",
          menuIcon: null,
          defaultCls: {
            "b-overflow-button": 1
          }
        },
        overflowScrollEnd: {
          handler: "up.onEndScrollClick",
          hidden: true,
          defaultCls: {
            "b-icon-angle-right": 1,
            "b-overflow-button": 1,
            "b-icon": 1
          }
        },
        overflowScrollStart: {
          align: "start",
          handler: "up.onStartScrollClick",
          hidden: true,
          defaultCls: {
            "b-icon-angle-left": 1,
            "b-overflow-button": 1,
            "b-icon": 1
          }
        }
      },
      widgetCls: null,
      ignoreParentReadOnly: true
    };
  }
  static get prototypeProperties() {
    return {
      flexRowCls: "b-hbox",
      flexColCls: "b-vbox"
    };
  }
  static getEvictionList(visibleItems) {
    const ret = visibleItems.filter((it) => it.overflowable !== "none");
    ret.forEach((it, n) => ret[n] = [n, it]);
    ret.sort((a, b) => itemScoreFn(b) - itemScoreFn(a));
    return ret;
  }
  compose() {
    const me = this, {
      axisProps,
      dock
    } = me, endToolElementRefs = me.getEndTools(asElementRefs), startToolElementRefs = me.getStartTools(asElementRefs);
    return {
      class: {
        [`b-dock-${dock}`]: 1,
        [`b-${dock}-toolbar`]: 1,
        [`b-${axisProps.box}`]: 1
      },
      children: _objectSpread2(_objectSpread2({}, startToolElementRefs), {}, {
        toolbarContent: {
          class: {
            "b-box-center": 1,
            "b-toolbar-content": 1
          }
        }
      }, endToolElementRefs)
    };
  }
  get axisProps() {
    return _axisProps[this.layout.horizontal ? 0 : 1];
  }
  get contentElement() {
    return this.toolbarContent;
  }
  get overflowMenuButton() {
    var _this$tools;
    return (_this$tools = this.tools) === null || _this$tools === void 0 ? void 0 : _this$tools.overflowMenuButton;
  }
  get overflowType() {
    const {
      overflow
    } = this;
    return typeof overflow === "string" ? overflow : overflow === null || overflow === void 0 ? void 0 : overflow.type;
  }
  onChildAdd(item) {
    var _item$syncRotationToD;
    super.onChildAdd(item);
    this.processAddedLeafItem(item);
    (_item$syncRotationToD = item.syncRotationToDock) === null || _item$syncRotationToD === void 0 ? void 0 : _item$syncRotationToD.call(item, this.dock);
  }
  onChildRemove(item) {
    super.onChildRemove(item);
    this.syncOverflowVisibility();
  }
  processAddedLeafItem(item) {
    FunctionHelper.after(item, "onConfigChange", this.onLeafItemConfigChange, item);
    if (item.isContainer) {
      item.eachWidget((w) => this.processAddedLeafItem(w));
    }
  }
  onPaint({
    firstPaint
  }) {
    var _super$onPaint;
    (_super$onPaint = super.onPaint) === null || _super$onPaint === void 0 ? void 0 : _super$onPaint.call(this, ...arguments);
    if (firstPaint) {
      this.getConfig("overflow");
    }
  }
  updateDock(dock) {
    const me = this, {
      layout
    } = me, {
      vertical
    } = layout;
    layout.vertical = canonicalDock(dock)[1];
    if (!me.initialItems) {
      if (vertical !== layout.vertical) {
        me.updateOverflow(me.overflow);
      }
      for (const item of me.childItems) {
        var _item$syncRotationToD2;
        (_item$syncRotationToD2 = item.syncRotationToDock) === null || _item$syncRotationToD2 === void 0 ? void 0 : _item$syncRotationToD2.call(item, dock);
      }
    }
  }
  updateOverflow(overflow, oldOverflow) {
    var _me$overflowMenuButto;
    const me = this, {
      axisProps,
      contentElement,
      overflowType
    } = me, {
      flexDir
    } = axisProps, overflowMenu = (_me$overflowMenuButto = me.overflowMenuButton) === null || _me$overflowMenuButto === void 0 ? void 0 : _me$overflowMenuButto._menu, overflowTools = {};
    if (overflowMenu) {
      if (overflow) {
        overflowMenu === null || overflowMenu === void 0 ? void 0 : overflowMenu.removeAll();
      } else {
        overflowMenu.eachWidget((overflowTwin) => {
          overflowTwin._overflowTwinOrigin.overflowTwin = null;
        });
      }
    }
    if (oldOverflow === "menu") {
      overflowTools.overflowMenuButton = null;
    } else if (oldOverflow === "scroll") {
      overflowTools.overflowScrollStart = overflowTools.overflowScrollEnd = null;
    }
    if (overflowType === "menu") {
      var _me$scrollable;
      (_me$scrollable = me.scrollable) === null || _me$scrollable === void 0 ? void 0 : _me$scrollable.destroy();
      contentElement.style.overflow = contentElement.style.overflowX = contentElement.style.overflowY = "";
      overflowTools.overflowMenuButton = {
        cls: {
          [`b-${flexDir}-menu`]: 1
        }
      };
    } else if (overflowType === "scroll") {
      const repeat = typeof overflow === "object" && (overflow === null || overflow === void 0 ? void 0 : overflow.repeat) || defaultRepeat;
      me.scrollable = {
        [axisProps.overflow]: "hidden-scroll",
        element: contentElement,
        internalListeners: {
          scroll: "onContentScroll",
          thisObj: me
        }
      };
      overflowTools.overflowScrollStart = {
        repeat,
        invertRotate: true,
        cls: {
          [`b-${flexDir}-start-scroller`]: 1
        }
      };
      overflowTools.overflowScrollEnd = {
        repeat,
        invertRotate: true,
        cls: {
          [`b-${flexDir}-end-scroller`]: 1
        }
      };
    }
    me.tools = overflowTools;
    if (overflowType) {
      contentElement.classList.add("b-overflow");
      me.monitorResize = true;
      me.syncOverflowVisibility();
    } else {
      contentElement.classList.remove("b-overflow");
      me.monitorResize = false;
    }
  }
  onContentScroll() {
    this.syncScrollerState();
  }
  onStartScrollClick() {
    this.scrollable[this.axisProps.pos] -= 2;
  }
  onEndScrollClick() {
    this.scrollable[this.axisProps.pos] += 2;
  }
  onInternalResize() {
    super.onInternalResize(...arguments);
    if (this.isPainted) {
      this.syncOverflowVisibility();
    }
  }
  syncOverflowVisibility() {
    const me = this, {
      overflowType,
      contentElement,
      isVisible: isVisible2
    } = me, {
      clientSizeProp,
      edgeProp,
      sizeProp
    } = me.axisProps, {
      overflowMenuButton,
      overflowScrollStart,
      overflowScrollEnd
    } = me.tools, rtl = me.rtl && me.layout.horizontal, menuOverflow = overflowType === "menu", getAvailSpace = () => Math.ceil(contentElement[clientSizeProp] + (!overflowScrollStart || overflowScrollStart.hidden ? 0 : overflowScrollStart.rectangle("outer")[sizeProp]) + (!overflowScrollEnd || overflowScrollEnd.hidden ? 0 : overflowScrollEnd.rectangle("outer")[sizeProp])), getContentSize = () => {
      if (visibleItems.length === 0) {
        return 0;
      }
      const rect = visibleItems[visibleItems.length - 1].rectangle(contentElement);
      return Math.floor(rtl ? contentElement[clientSizeProp] - rect.left : rect[edgeProp]);
    };
    let availableSpace, contentSize, eviction, evictionList, it, itemSize, minifiable, minifiables, minified, overflowable, overflowItems, visibleItems;
    if (!isVisible2 || !overflowType || me.items.length === 0) {
      return;
    }
    me.inSyncOverflowVisibility = true;
    overflowMenuButton === null || overflowMenuButton === void 0 ? void 0 : overflowMenuButton.hide();
    me.eachWidget((item, control) => {
      minifiable = item.minifiable;
      overflowable = item.overflowable;
      overflowable = minifiable ? overflowable || minifiable : overflowable;
      if (item.floating) {
        control.down = false;
      } else {
        control.down = !overflowable;
        if (item.innerItem) {
          if (item._toolbarOverflow) {
            item.hidden = item._toolbarOverflow = false;
          }
          if (item._toolbarMinified) {
            item.minified = item._toolbarMinified = false;
          }
          if (item.isVisible) {
            minifiable && (minifiables || (minifiables = [])).push(item);
            overflowable && (visibleItems || (visibleItems = [])).push(item);
          }
        }
      }
    });
    if (visibleItems) {
      availableSpace = getAvailSpace();
      contentSize = getContentSize();
    }
    if (visibleItems && contentSize > availableSpace) {
      if (menuOverflow) {
        while (contentSize > availableSpace && (it = (_minifiables = minifiables) === null || _minifiables === void 0 ? void 0 : _minifiables.pop())) {
          var _minifiables;
          itemSize = contentSize;
          it._toolbarMinified = true;
          it.minified = true;
          contentSize = getContentSize();
          itemSize -= contentSize;
          (minified || (minified = [])).push([it, itemSize]);
        }
        if (contentSize > availableSpace) {
          overflowMenuButton.show();
          availableSpace = getAvailSpace();
          evictionList = Toolbar.getEvictionList(visibleItems);
          for (eviction of evictionList) {
            if (contentSize > availableSpace) {
              it = eviction[1];
              it._toolbarOverflowWidth = it.width;
              it._toolbarOverflow = true;
              it.hidden = true;
              visibleItems.splice(visibleItems.indexOf(it), 1);
              (overflowItems || (overflowItems = [])).push(eviction);
              contentSize = getContentSize();
            }
          }
          if (overflowItems) {
            overflowItems.sort((a, b) => a[0] - b[0]).forEach((ent, n) => overflowItems[n] = ent[1]);
            while ((_minified = minified) !== null && _minified !== void 0 && _minified.length) {
              var _minified;
              [it, itemSize] = minified.pop();
              if (contentSize + itemSize <= availableSpace && !it._toolbarOverflow) {
                contentSize += itemSize;
                it.minified = it._toolbarMinified = false;
              }
            }
            me.syncOverflowMenuButton(overflowItems);
          } else {
            overflowMenuButton.hide();
          }
        }
      } else {
        overflowScrollEnd.show();
        overflowScrollStart.show();
        me.syncScrollerState();
      }
    } else if (!menuOverflow) {
      overflowScrollEnd === null || overflowScrollEnd === void 0 ? void 0 : overflowScrollEnd.hide();
      overflowScrollStart === null || overflowScrollStart === void 0 ? void 0 : overflowScrollStart.hide();
    }
    me.inSyncOverflowVisibility = false;
  }
  syncOverflowMenuButton(overflowItems) {
    var _overflowMenuButton$_;
    const me = this, {
      axisProps,
      overflowMenuButton
    } = me, menu = {
      cls: "b-toolbar-overflow-menu",
      minWidth: 280,
      items: [],
      align: {
        align: axisProps.horizontal ? "t100-b100" : "r100-l100",
        axisLock: "flexible"
      }
    };
    me.addToMenu(menu, overflowItems.filter((item) => me.overflowItemFilter(item)));
    if ((_overflowMenuButton$_ = overflowMenuButton._menu) !== null && _overflowMenuButton$_ !== void 0 && _overflowMenuButton$_.isMenu) {
      const existingMenu = overflowMenuButton.menu, {
        toAdd,
        toRemove
      } = ArrayHelper.delta(menu.items, existingMenu.items, 1);
      existingMenu.remove(toRemove);
      if (existingMenu.items.length) {
        for (let i = toAdd.length - 1; i >= 0; i--) {
          existingMenu.insert(toAdd[i], 0);
        }
      } else {
        existingMenu.add(toAdd);
      }
    } else {
      overflowMenuButton.menu = menu;
    }
  }
  syncScrollerState() {
    const me = this, {
      axisProps,
      scrollable
    } = me, {
      overflowScrollStart,
      overflowScrollEnd
    } = me.tools, scrollPos = scrollable[axisProps.pos], maxScrollPos = scrollable[axisProps.max];
    overflowScrollStart.disabled = !scrollPos;
    overflowScrollEnd.disabled = Math.abs(Math.ceil(scrollPos)) >= Math.abs(maxScrollPos);
  }
  overflowItemFilter(item) {
    const {
      filter
    } = this.overflow;
    return Boolean(filter ? filter.call(this, item) : DomHelper.getChildElementCount(item.element));
  }
  addToMenu(menu, overflowingItems) {
    const overrides = this.horizontal ? twinOverridesHorz : twinOverrides;
    for (const item of overflowingItems) {
      const overflowTwin = item.ensureOverflowTwin(overrides, onCreateTwin);
      menu.items.push(overflowTwin);
    }
  }
  onLeafItemConfigChange(origResult, {
    name,
    value
  }) {
    const item = this, toolbar = item.up(isToolbar), overflow = toolbar.hasConfig("overflow"), {
      overflowTwin
    } = item;
    if (!overflow || toolbar !== null && toolbar !== void 0 && toolbar.inSyncOverflowVisibility || name === "hidden" && value === item._toolbarOverflow) {
      return;
    }
    if (overflowTwin && !nonSyncedConfigs[name]) {
      overflowTwin[name] = value;
    }
    if (toolbar !== null && toolbar !== void 0 && toolbar.isPainted && item.ref !== "overflowMenuButton") {
      if (!(item.isTextField && name === "value" && (item.containsFocus || overflowTwin !== null && overflowTwin !== void 0 && overflowTwin.containsFocus))) {
        toolbar.syncOverflowVisibility();
      }
    }
  }
  createWidget(widget) {
    if (widget === "->") {
      widget = {
        type: "widget",
        cls: "b-toolbar-fill"
      };
    } else if (widget === "|") {
      widget = {
        type: "widget",
        cls: "b-toolbar-separator"
      };
    } else if (typeof widget === "string") {
      widget = {
        type: "widget",
        cls: "b-toolbar-text",
        html: widget
      };
    }
    const result = super.createWidget(widget);
    if (this.widgetCls) {
      result.element.classList.add(this.widgetCls);
    }
    return result;
  }
};
Toolbar.initClass();
Toolbar._$name = "Toolbar";
var acceptNode = (e) => !e.classList.contains("b-focus-trap") && DomHelper.isFocusable(e) ? DomHelper.NodeFilter.FILTER_ACCEPT : DomHelper.NodeFilter.FILTER_SKIP;
var emptyArray$2 = [];
var emptyObject$1 = {};
var emptySplit = [emptyArray$2, emptyArray$2];
var finishBodyWrap = (config, classes, final) => {
  const {
    vertical
  } = config;
  delete config.vertical;
  return _objectSpread2(_objectSpread2({}, config), {}, {
    class: _objectSpread2(_objectSpread2({}, classes), {}, {
      [`b-${vertical ? "v" : "h"}box`]: 1,
      "b-box-center": 1,
      "b-panel-bar-wrap": !final
    })
  });
};
var wrapBody = (inner, bodyWrapTag, vertical = false) => {
  const wrap = {
    vertical,
    children: inner ? [inner] : []
  };
  if (bodyWrapTag) {
    wrap.tag = bodyWrapTag;
  }
  return wrap;
};
var barConfigs = {
  dock: 1,
  hidden: 1,
  weight: 1
};
var dockDirection = {
  top: [true, true],
  bottom: [true, false],
  left: [false, true],
  right: [false, false]
};
var headerDock = {
  header: 1,
  "pre-header": 1
};
var Panel = class extends Container.mixin(State, Toolable) {
  static get $name() {
    return "Panel";
  }
  static get type() {
    return "panel";
  }
  static get configurable() {
    return {
      localizableProperties: ["title"],
      collapsed: {
        value: null,
        $config: null,
        default: false
      },
      collapsible: {
        value: null,
        $config: "nullify"
      },
      bodyCls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      bodyTag: null,
      bodyWrapTag: null,
      trapFocus: null,
      title: null,
      header: null,
      stateful: ["collapsed"],
      stripDefaults: {
        "*": {
          type: "toolbar",
          dock: "top"
        },
        bbar: {
          dock: "bottom",
          weight: -1e3
        },
        tbar: {
          weight: -1e3
        }
      },
      strips: {
        value: null,
        $config: "nullify"
      },
      toolDefaults: {
        close: {
          weight: -1e3
        },
        collapse: {
          weight: -990
        }
      },
      footer: null,
      revealed: null,
      tbar: null,
      bbar: null,
      role: "region"
    };
  }
  updateElement(element, oldElement) {
    const result = super.updateElement(element, oldElement);
    if (this.titleElement) {
      DomHelper.setAttributes(this.ariaElement, {
        "aria-describedby": this.titleElement.id
      });
    }
    return result;
  }
  compose() {
    const me = this, {
      collapsible,
      focusable,
      hasItems,
      revealed,
      tools
    } = me, header = me.composeHeader(), horz = (header === null || header === void 0 ? void 0 : header.class["b-dock-left"]) || (header === null || header === void 0 ? void 0 : header.class["b-dock-right"]);
    let body = me.composeBody(), key = "bodyWrapElement";
    if (collapsible) {
      [key, body] = collapsible.wrapCollapser(key, body);
    }
    return {
      tabIndex: hasItems && focusable !== false || focusable ? 0 : null,
      class: {
        [`b-panel-collapsible-${collapsible === null || collapsible === void 0 ? void 0 : collapsible.type}`]: collapsible,
        [`b-panel-collapse-${collapsible === null || collapsible === void 0 ? void 0 : collapsible.collapseDir}`]: collapsible,
        [`b-${horz ? "h" : "v"}box`]: 1,
        "b-panel-collapsible": collapsible,
        "b-panel-has-header": header,
        "b-panel-has-tools": tools ? 1 : 0,
        "b-panel-overlay-revealed": revealed
      },
      children: {
        topFocusTrap: {
          "aria-hidden": true,
          tabIndex: 0,
          class: {
            "b-focus-trap": 1
          }
        },
        headerElement: header,
        [key]: body,
        bottomFocusTrap: {
          "aria-hidden": true,
          tabIndex: 0,
          class: {
            "b-focus-trap": 1,
            "b-end-focus-trap": 1
          }
        }
      }
    };
  }
  composeBody() {
    const me = this, {
      bodyCls,
      bodyConfig,
      bodyWrapTag,
      footer,
      uiClassList
    } = me, strips = ObjectHelper.values(me.strips, (k, v) => !dockDirection[v === null || v === void 0 ? void 0 : v.dock]).sort(me.byWeightSortFn);
    let bar, before, dock, i, name, vertical, wrap;
    if (footer) {
      dock = footer.dock || "bottom";
      strips.unshift({
        dock,
        element: {
          tag: "footer",
          reference: "footerElement",
          html: typeof footer === "string" ? footer : footer.html,
          class: _objectSpread2(_objectSpread2({}, uiClassList), {}, {
            [`b-dock-${dock}`]: 1,
            [`${footer.cls || ""}`]: 1
          })
        }
      });
    }
    if (bodyCls) {
      if (!bodyConfig[name = "className"]) {
        name = "class";
      }
      bodyConfig[name] = new DomClassList(bodyConfig[name]).assign(bodyCls);
    }
    for (i = strips.length; i-- > 0; ) {
      bar = strips[i];
      [vertical, before] = dockDirection[bar.dock];
      if (!wrap) {
        wrap = wrapBody(bodyConfig, bodyWrapTag, vertical);
      } else if (wrap.vertical !== vertical) {
        wrap = wrapBody(finishBodyWrap(wrap, uiClassList), "", vertical);
      }
      wrap.children[before ? "unshift" : "push"](bar.element);
    }
    const body = finishBodyWrap(wrap || wrapBody(bodyConfig, bodyWrapTag), uiClassList, true);
    body.class["b-panel-body-wrap"] = 1;
    body.class[`b-${me.$$name.toLowerCase()}-body-wrap`] = 1;
    return body;
  }
  get hasHeader() {
    if (this.header === false) {
      return false;
    }
    const {
      header,
      title,
      tools,
      parent
    } = this, hasVisibleTools = this.maximizable || Object.values(tools || {}).some((tool) => !tool.hidden);
    return header || !(parent !== null && parent !== void 0 && parent.suppressChildHeaders) && (title || hasVisibleTools);
  }
  get rootUiClass() {
    return Panel;
  }
  composeHeader(force) {
    var _me$collapsible;
    const me = this;
    if (!me.hasHeader && !force) {
      return;
    }
    const header = me.header || {}, dock = header.dock || "top", [before, after] = me.splitHeaderItems({
      dock,
      as: "element"
    }), classes = me.$meta.hierarchy, title = me.composeTitle(header), cls = new DomClassList(_objectSpread2({
      [`b-dock-${dock}`]: 1
    }, me.uiClassList), header.cls);
    let i, name;
    for (i = classes.indexOf(Panel); i < classes.length; ++i) {
      name = classes[i].$$name;
      if (name !== "Grid") {
        cls[`b-${name.toLowerCase()}-header`] = 1;
      }
    }
    const headerConfig = {
      tag: "header",
      class: cls,
      children: [...before, title, ...after]
    };
    return ((_me$collapsible = me.collapsible) === null || _me$collapsible === void 0 ? void 0 : _me$collapsible.composeHeader(headerConfig)) || headerConfig;
  }
  composeTitle(header) {
    var _this$collapsible;
    const title = typeof header === "string" ? header : this.title || header.title, titleConfig = {
      reference: "titleElement",
      id: `${this.id}-panel-title`,
      html: title !== null && title !== void 0 ? title : "\xA0",
      class: _objectSpread2({
        [`b-align-${header.titleAlign || "start"}`]: 1,
        "b-header-title": 1
      }, this.uiClassList)
    };
    if (ObjectHelper.isObject(title)) {
      delete titleConfig.html;
      ObjectHelper.merge(titleConfig, title);
    }
    return ((_this$collapsible = this.collapsible) === null || _this$collapsible === void 0 ? void 0 : _this$collapsible.composeTitle(titleConfig)) || titleConfig;
  }
  updateTitle() {
  }
  afterRecompose() {
    var _me$_headerClickDetac;
    super.afterRecompose();
    const me = this, {
      headerElement
    } = me;
    (_me$_headerClickDetac = me._headerClickDetacher) === null || _me$_headerClickDetac === void 0 ? void 0 : _me$_headerClickDetac.call(me);
    me._headerClickDetacher = headerElement && EventHelper.on({
      element: headerElement,
      click: (ev) => {
        var _me$trigger;
        return (_me$trigger = me.trigger) === null || _me$trigger === void 0 ? void 0 : _me$trigger.call(me, "headerClick", {
          event: ev
        });
      }
    });
  }
  onHeaderClick(info) {
    var _this$collapsible2;
    (_this$collapsible2 = this.collapsible) === null || _this$collapsible2 === void 0 ? void 0 : _this$collapsible2.onHeaderClick(info);
  }
  onPaint() {
    var _this$collapsible3;
    super.onPaint(...arguments);
    (_this$collapsible3 = this.collapsible) === null || _this$collapsible3 === void 0 ? void 0 : _this$collapsible3.onPanelPaint(this);
  }
  splitHeaderItems({
    as,
    overlay,
    dock
  } = emptyObject$1) {
    const me = this, asElement = as === "element", {
      collapsed
    } = me, endTools = me.getEndTools({
      overlay
    }), startTools = me.getStartTools({
      overlay
    }), strips = ObjectHelper.values(me.strips, (k, v) => !headerDock[v === null || v === void 0 ? void 0 : v.dock] && v.isCollapsified(collapsed, overlay));
    let ret = emptySplit, after, before, i;
    if (strips.length + endTools.length + startTools.length) {
      ret = [
        before = [...startTools, ...strips.filter((e) => e.dock === "pre-header").sort(me.byWeightSortFn)],
        after = [...strips.filter((e) => e.dock === "header").sort(me.byWeightReverseSortFn), ...endTools]
      ];
      for (i = 0; i < before.length; ++i) {
        var _before$i$syncRotatio, _before$i;
        dock && ((_before$i$syncRotatio = (_before$i = before[i]).syncRotationToDock) === null || _before$i$syncRotatio === void 0 ? void 0 : _before$i$syncRotatio.call(_before$i, dock));
        if (asElement) {
          before[i] = before[i].element;
        }
      }
      for (i = 0; i < after.length; ++i) {
        var _after$i$syncRotation, _after$i;
        dock && ((_after$i$syncRotation = (_after$i = after[i]).syncRotationToDock) === null || _after$i$syncRotation === void 0 ? void 0 : _after$i$syncRotation.call(_after$i, dock));
        if (asElement) {
          after[i] = after[i].element;
        }
      }
    }
    return ret;
  }
  set bodyConfig(bodyConfig) {
    this._bodyConfig = bodyConfig;
  }
  get bodyConfig() {
    const me = this, {
      bodyTag
    } = me, result = ObjectHelper.merge({
      reference: "bodyElement",
      className: _objectSpread2(_objectSpread2({}, me.getStaticWidgetClasses(Panel, "-content")), {}, {
        "b-box-center": 1,
        "b-text-content": me.textContent && me.hasNoChildren
      })
    }, me._bodyConfig);
    if (bodyTag) {
      result.tag = bodyTag;
    }
    if (me.initializingElement || !me._element) {
      result.html = me.content || me._html;
    }
    return result;
  }
  changeBodyCls(cls) {
    return DomClassList.from(cls);
  }
  changeTbar(bar) {
    this.getConfig("strips");
    this.strips = {
      tbar: bar
    };
    return this.strips.tbar;
  }
  changeBbar(bar) {
    this.getConfig("strips");
    this.strips = {
      bbar: bar
    };
    return this.strips.bbar;
  }
  get childItems() {
    var _me$collapsible2;
    const me = this, strips = ObjectHelper.values(me.strips, (k, v) => !dockDirection[v === null || v === void 0 ? void 0 : v.dock]).sort(me.byWeightSortFn), [before, after] = me.splitHeaderItems(), [before2, after2] = ((_me$collapsible2 = me.collapsible) === null || _me$collapsible2 === void 0 ? void 0 : _me$collapsible2.splitHeaderItems()) || emptySplit;
    return [
      ...before,
      ...before2,
      ...after,
      ...after2,
      ...strips.filter((b) => dockDirection[b.dock][1]),
      ...me._items || emptyArray$2,
      ...strips.filter((b) => !dockDirection[b.dock][1]).reverse()
    ];
  }
  changeStrips(strips, oldStrips) {
    const me = this, manager = me.$strips || (me.$strips = new DynamicObject({
      configName: "strips",
      factory: Widget,
      inferType: false,
      owner: me,
      created(instance) {
        var _instance$layout;
        const {
          dock
        } = instance;
        if (!headerDock[dock] && !dockDirection[dock]) {
          throw new Error(`Invalid dock value "${dock}"; must be: top, left, right, bottom, header, or pre-header`);
        }
        FunctionHelper.after(instance, "onConfigChange", (ret, {
          name
        }) => {
          if (barConfigs[name]) {
            me.onConfigChange({
              name: "strips",
              value: manager.target
            });
          }
        });
        instance.innerItem = false;
        me.onChildAdd(instance);
        instance.parent = me;
        (_instance$layout = instance.layout) === null || _instance$layout === void 0 ? void 0 : _instance$layout.renderChildren();
        if (instance.hasItems) {
          me.hasItems = true;
        }
      },
      setup(config, name) {
        config = ObjectHelper.merge(ObjectHelper.clone(me.stripDefaults["*"]), me.stripDefaults[name], config);
        config.parent = me;
        config.ref = name;
        return config;
      },
      transform(config) {
        if (Array.isArray(config)) {
          config = {
            items: config
          };
        }
        return config || null;
      }
    }));
    manager.update(strips);
    if (!oldStrips) {
      return manager.target;
    }
  }
  get collapsing() {
    var _this$collapsible4;
    return (_this$collapsible4 = this.collapsible) === null || _this$collapsible4 === void 0 ? void 0 : _this$collapsible4.collapsing;
  }
  get collapsingExpanding() {
    var _this$collapsible5;
    return (_this$collapsible5 = this.collapsible) === null || _this$collapsible5 === void 0 ? void 0 : _this$collapsible5.collapsingExpanding;
  }
  get expanding() {
    var _this$collapsible6;
    return (_this$collapsible6 = this.collapsible) === null || _this$collapsible6 === void 0 ? void 0 : _this$collapsible6.expanding;
  }
  changeCollapsed(value) {
    const me = this, {
      collapsible
    } = me;
    me.recompose.flush();
    value = Boolean(value);
    if (!collapsible || me.changingCollapse || !me.isPainted) {
      return value;
    }
    collapsible === null || collapsible === void 0 ? void 0 : collapsible.collapse({
      animation: null,
      collapsed: value
    });
  }
  changeCollapsible(collapsible, was) {
    const me = this;
    me.getConfig("tools");
    if (collapsible) {
      if (collapsible === true) {
        collapsible = {};
      } else if (typeof collapsible === "string") {
        collapsible = {
          [dockDirection[collapsible] ? "direction" : "type"]: collapsible
        };
      }
    }
    return PanelCollapser.reconfigure(was, collapsible, {
      owner: me,
      defaults: {
        panel: me
      },
      cleanup() {
        if (me.collapsed) {
          was.collapse({
            animation: null,
            collapsed: false
          });
          me._collapsed = 1;
        }
      }
    });
  }
  updateCollapsible(collapsible) {
    const me = this, tools = collapsible === null || collapsible === void 0 ? void 0 : collapsible.toolsConfig;
    me.tools = {
      collapse: (tools === null || tools === void 0 ? void 0 : tools.collapse) || null,
      recollapse: (tools === null || tools === void 0 ? void 0 : tools.recollapse) || null
    };
    if (collapsible && me.isPainted && me.collapsed) {
      me._collapsed = 1;
    }
    if (me.collapsed === 1) {
      me.collapsed = true;
    }
  }
  _collapse(collapsed, options) {
    var _this$collapsible7;
    if (options !== true && options !== void 0) {
      if (options === false) {
        collapsed.collapsed = !collapsed.collapsed;
      } else if (typeof options === "number") {
        collapsed.animation = {
          duration: options
        };
      } else if (options === null) {
        collapsed.animation = options;
      } else if (options === true)
        ;
      else if ("animation" in options) {
        ObjectHelper.merge(collapsed, options);
      } else {
        collapsed.animation = options;
      }
    }
    return (_this$collapsible7 = this.collapsible) === null || _this$collapsible7 === void 0 ? void 0 : _this$collapsible7.collapse(collapsed);
  }
  collapse(options) {
    return this._collapse({
      collapsed: true
    }, options);
  }
  expand(options) {
    return this._collapse({
      collapsed: false
    }, options);
  }
  toggleCollapsed(options) {
    return this.collapsed ? this.expand(options) : this.collapse(options);
  }
  get expandedHeaderDock() {
    var _ref, _this$_expandedHeader, _this$initialConfig$h;
    return (_ref = (_this$_expandedHeader = this._expandedHeaderDock) !== null && _this$_expandedHeader !== void 0 ? _this$_expandedHeader : (_this$initialConfig$h = this.initialConfig.header) === null || _this$initialConfig$h === void 0 ? void 0 : _this$initialConfig$h.dock) !== null && _ref !== void 0 ? _ref : "top";
  }
  set expandedHeaderDock(v) {
    this._expandedHeaderDock = v === null || v === void 0 ? void 0 : v.toLowerCase();
  }
  updateHeader(header) {
    if (!this.changingCollapse) {
      this.expandedHeaderDock = header === null || header === void 0 ? void 0 : header.dock;
    }
  }
  updateTrapFocus(trapFocus) {
    var _me$focusTrapListener;
    const me = this;
    me.element.classList[trapFocus ? "add" : "remove"]("b-focus-trapped");
    me.focusTrapListener = (_me$focusTrapListener = me.focusTrapListener) === null || _me$focusTrapListener === void 0 ? void 0 : _me$focusTrapListener.call(me);
    if (trapFocus) {
      me.focusTrapListener = EventHelper.on({
        element: me.element,
        focusin: "onFocusTrapped",
        delegate: ".b-focus-trap",
        thisObj: me
      });
      if (!me.treeWalker) {
        me.treeWalker = this.setupTreeWalker(me.element, DomHelper.NodeFilter.SHOW_ELEMENT, acceptNode);
      }
    }
  }
  setupTreeWalker(root2, whatToShow, filter) {
    return document.createTreeWalker(root2, whatToShow, filter);
  }
  onFocusTrapped(e) {
    const me = this, treeWalker = me.treeWalker;
    if (e.target === me.bottomFocusTrap) {
      treeWalker.currentNode = me.topFocusTrap;
      treeWalker.nextNode();
    } else if (e.target === me.topFocusTrap) {
      treeWalker.currentNode = me.bottomFocusTrap;
      treeWalker.previousNode();
    } else {
      return;
    }
    me.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }
  get focusElement() {
    return this.hasItems && (super.focusElement || this.element);
  }
  get contentElement() {
    return this.element && this.bodyElement;
  }
  get widgetClassList() {
    const me = this, result = super.widgetClassList;
    if (me.hasHeader) {
      var _me$header;
      result.push("b-panel-has-header", `b-header-dock-${((_me$header = me.header) === null || _me$header === void 0 ? void 0 : _me$header.dock) || "top"}`);
    }
    if (me.tbar) {
      result.push("b-panel-has-top-toolbar");
    }
    if (me.bbar) {
      result.push("b-panel-has-bottom-toolbar");
    }
    return result;
  }
};
Panel.initClass();
Panel._$name = "Panel";
var Popup = class extends Panel {
  static get $name() {
    return "Popup";
  }
  static get type() {
    return "popup";
  }
  static get configurable() {
    return {
      autoShow: true,
      autoClose: true,
      showOnClick: false,
      forElement: null,
      monitorResize: true,
      floating: true,
      hidden: true,
      axisLock: true,
      hideAnimation: {
        opacity: {
          from: 1,
          to: 0,
          duration: ".3s",
          delay: "0s"
        }
      },
      showAnimation: {
        opacity: {
          from: 0,
          to: 1,
          duration: ".4s",
          delay: "0s"
        }
      },
      stripDefaults: {
        bbar: {
          layout: {
            justify: "flex-end"
          }
        }
      },
      testConfig: {
        hideAnimation: null,
        showAnimation: null
      },
      closeAction: "hide",
      trapFocus: true,
      focusOnToFront: true,
      closable: null,
      maximizable: null,
      modal: null,
      maximized: null,
      tools: {
        close: {
          cls: "b-popup-close",
          handler: "close",
          weight: -1e3,
          ariaLabel: "L{Popup.close}",
          hidden: true
        },
        maximize: {
          cls: "b-popup-expand",
          handler: "toggleMaximized",
          weight: -999,
          hidden: true
        }
      },
      highlightReturnedFocus: true,
      role: "dialog"
    };
  }
  finalizeInit() {
    const me = this, {
      forElement
    } = me;
    me.anchoredTo = forElement;
    me.initialAnchor = me.anchor;
    if (forElement && me.showOnClick) {
      if (!me.initialConfig.autoShow) {
        me.autoShow = false;
      }
      EventHelper.on({
        element: forElement,
        click: "onElementUserAction",
        thisObj: me
      });
    }
    super.finalizeInit();
    if (me.autoShow && (!forElement || DomHelper.isVisible(forElement))) {
      if (me.autoShow === true) {
        me.show();
      } else {
        me.setTimeout(() => me.show(), me.autoShow);
      }
    }
  }
  onPaint({
    firstPaint
  }) {
    var _super$onPaint;
    (_super$onPaint = super.onPaint) === null || _super$onPaint === void 0 ? void 0 : _super$onPaint.call(this, ...arguments);
    const me = this;
    if (firstPaint && me.headerElement) {
      EventHelper.on({
        element: me.headerElement,
        dblclick: me.onHeaderDblClick,
        thisObj: me
      });
    }
  }
  doDestroy() {
    this.syncModalMask();
    super.doDestroy();
  }
  compose() {
    const {
      hasNoChildren,
      textContent
    } = this;
    return {
      class: {
        "b-text-popup": Boolean(textContent && hasNoChildren)
      }
    };
  }
  close() {
    const me = this;
    if (!me._hidden && me.trigger("beforeClose") !== false || me._hidden && me.closeAction === "destroy") {
      me.modal && me.closeAction === "destroy" && me.revertFocus();
      me.unmask();
      if (me.containsFocus && me.highlightReturnedFocus) {
        me.setTimeout(() => me.element.classList.add("b-using-keyboard"), 0);
      }
      return me[me.closeAction]();
    }
  }
  toggleMaximized() {
    this.maximized = !this.maximized;
  }
  updateMaximized(value) {
    DomHelper.toggleClasses(this.element, ["b-maximized"], value);
  }
  onInternalKeyDown(event) {
    const me = this;
    if (event.key === "Escape") {
      event.stopImmediatePropagation();
      if (me.floating || me.positioned) {
        me.close(true);
      } else if (me.collapsible) {
        if (me.revealed) {
          me.collapsible.toggleReveal();
        } else {
          me.collapse();
        }
      }
    }
  }
  onDocumentMouseDown({
    event
  }) {
    const me = this, {
      owner
    } = me, {
      target
    } = event;
    if (event.type !== "touchend" && owner !== null && owner !== void 0 && owner.isButton && owner._menu === me && owner.element.contains(target)) {
      event.preventDefault();
      return false;
    }
    if (me.modal && target === Popup.modalMask) {
      event.preventDefault();
      if (me.modal.closeOnMaskTap) {
        me.close();
      } else if (!me.containsFocus) {
        me.focus();
      }
    } else if (!me.owns(target) && me.autoClose && !me.containsFocus) {
      me.close();
    }
  }
  get isTopModal() {
    return DomHelper.isVisible(Popup.modalMask) && this.element.previousElementSibling === Popup.modalMask;
  }
  onFocusIn(e) {
    const activeEl = DomHelper.getActiveElement(this);
    super.onFocusIn(e);
    if (DomHelper.getActiveElement(this) === activeEl && e.target === this.element) {
      this.focus();
    }
  }
  onFocusOut(e) {
    const usingVirtualKeyboard = globalThis.visualViewport && globalThis.visualViewport.height < document.documentElement.clientHeight - 1;
    if (!usingVirtualKeyboard && !this.modal && this.autoClose) {
      this.close();
    }
    super.onFocusOut(e);
  }
  onShow() {
    var _super$onShow;
    const me = this;
    if (me.autoClose) {
      me.addDocumentMouseDownListener();
    }
    if (me.focusOnToFront) {
      me.focus();
    }
    (_super$onShow = super.onShow) === null || _super$onShow === void 0 ? void 0 : _super$onShow.call(this);
    me.syncModalMask();
  }
  addDocumentMouseDownListener() {
    if (!this.mouseDownRemover) {
      this.mouseDownRemover = GlobalEvents$1.ion({
        globaltap: "onDocumentMouseDown",
        thisObj: this
      });
    }
  }
  updateModal(modal) {
    if (modal) {
      this.floating = true;
    }
  }
  syncModalMask() {
    const me = this, {
      modal,
      element
    } = me;
    element.setAttribute("aria-modal", Boolean(modal));
    if (modal && me.isVisible) {
      if (typeof me._x !== "number" && typeof me._y !== "number") {
        me.centered = true;
        me.anchor = false;
      }
      me.modalMask.classList.remove("b-hide-display");
      element.classList.add("b-modal");
    } else if (me.isPainted) {
      element.classList.remove("b-modal");
      const remainingModals = me.floatRoot.querySelectorAll(".b-modal"), topModal = remainingModals.length ? Popup.fromElement(remainingModals[remainingModals.length - 1], "popup") : null;
      if (topModal) {
        topModal.syncModalMask();
      } else {
        Popup.modalMask.classList.add("b-hide-display");
      }
    }
  }
  onHide() {
    var _me$mouseDownRemover, _super$onHide;
    const me = this;
    (_me$mouseDownRemover = me.mouseDownRemover) === null || _me$mouseDownRemover === void 0 ? void 0 : _me$mouseDownRemover.call(me);
    me.mouseDownRemover = null;
    (_super$onHide = super.onHide) === null || _super$onHide === void 0 ? void 0 : _super$onHide.call(this);
    me.syncModalMask();
  }
  onElementUserAction() {
    this.show();
  }
  onHeaderDblClick() {
    if (this.maximizable) {
      this.toggleMaximized();
    }
  }
  updateClosable(closable) {
    this.tools.close.hidden = !closable;
  }
  updateMaximizable(maximizable) {
    this.tools.maximize.hidden = !maximizable;
  }
  get modalMask() {
    const {
      modalMask
    } = Popup;
    if (modalMask.nextElementSibling !== this.element) {
      this.floatRoot.insertBefore(modalMask, this.element);
    }
    return modalMask;
  }
  static get modalMask() {
    if (!this._modalMask) {
      this._modalMask = DomHelper.createElement({
        className: "b-modal-mask b-hide-display"
      });
      EventHelper.on({
        element: this._modalMask,
        wheel: (e) => e.preventDefault()
      });
    }
    return this._modalMask;
  }
};
Popup.initClass();
Popup._$name = "Popup";
var bIcon = /^b-icon-/;
var bFa = /^b-fa-/;
var MenuItem = class extends Widget {
  static get $name() {
    return "MenuItem";
  }
  static get type() {
    return "menuitem";
  }
  static get configurable() {
    return {
      checked: null,
      separator: null,
      toggleGroup: null,
      menu: {
        value: null,
        $config: ["lazy", "nullify"]
      },
      icon: null,
      closeParent: null,
      href: null,
      target: null,
      localizableProperties: ["text"],
      role: "menuitem",
      closeMenuDelay: 200
    };
  }
  updateElement(element, oldElement) {
    const result = super.updateElement(element, oldElement);
    if (typeof this.checked === "boolean") {
      this.role = "menuitemcheckbox";
    }
    this.ariaHasPopup = this.hasMenu ? "menu" : false;
    return result;
  }
  compose() {
    var _me$cls;
    const me = this, {
      checked,
      href,
      hasMenu,
      separator,
      target,
      text,
      toggleGroup
    } = me, isCheckItem = typeof checked === "boolean", icon = me.icon || (isCheckItem ? "b-fw-icon" : ""), checkCls = `b-icon-${toggleGroup ? "radio-" : ""}`, hasCustomContent = typeof text === "object";
    return {
      tag: href ? "a" : "div",
      tabIndex: -1,
      href,
      target,
      class: {
        "b-has-submenu": hasMenu,
        "b-checked": checked,
        "b-separator": separator || ((_me$cls = me.cls) === null || _me$cls === void 0 ? void 0 : _me$cls["b-separator"])
      },
      dataset: {
        group: me.toggleGroup
      },
      [isCheckItem ? "aria-checked" : ""]: checked,
      [hasMenu ? "aria-expanded" : ""]: false,
      children: {
        iconElement: icon && {
          "aria-hidden": true,
          tag: "i",
          class: _objectSpread2({
            "b-fa": bFa.test(icon),
            "b-icon": bIcon.test(icon),
            "b-menuitem-icon": 1,
            [`${checkCls}checked`]: checked === true,
            [`${checkCls}unchecked`]: checked === false
          }, DomClassList.normalize(icon, "object"))
        },
        textElement: {
          tag: "span",
          html: hasCustomContent ? null : text,
          class: {
            "b-menu-text": 1,
            "b-menu-custom-content": hasCustomContent
          },
          children: hasCustomContent ? [text] : null
        },
        subMenuIcon: hasMenu && {
          "aria-hidden": true,
          tag: "i",
          class: {
            "b-fw-icon": 1,
            "b-icon-sub-menu": 1
          }
        }
      }
    };
  }
  doAction(event) {
    const item = this, menu = this.parent, itemEvent = {
      menu,
      item,
      element: item.element,
      bubbles: true
    };
    if (typeof item.checked === "boolean") {
      const newCheckedState = !item.checked;
      if (!item.toggleGroup || newCheckedState) {
        item.checked = !item.checked;
      }
    }
    item.trigger("beforeItem", itemEvent);
    item.trigger("item", itemEvent);
    if (item.closeParent && menu) {
      menu.rootMenu.close();
      if (event && !item.href) {
        event.preventDefault();
      }
    }
  }
  get focusElement() {
    return this.element;
  }
  get contentElement() {
    return this.textElement;
  }
  get isFocusable() {
    const {
      focusElement
    } = this;
    return focusElement && this.isVisible && (focusElement === document.body || focusElement.offsetParent);
  }
  get hasMenu() {
    return this.hasConfig("menu");
  }
  get childItems() {
    const {
      _menu
    } = this;
    return _menu ? [_menu] : [];
  }
  get text() {
    return this.html;
  }
  set text(text) {
    this.html = text;
  }
  onFocusIn(e) {
    super.onFocusIn(e);
    if (!this.disabled && this.menu) {
      this.delay("openMenu", 200);
    }
  }
  onFocusOut(e) {
    this.clearTimeout("openMenu");
    super.onFocusOut(e);
    if (this._menu) {
      this.menu.closeTimer = this.menu.setTimeout(() => this.closeMenu(), this.closeMenuDelay);
    }
  }
  openMenu(andFocus) {
    const {
      menu
    } = this;
    if (!this.disabled && menu) {
      menu.focusOnToFront = andFocus;
      menu.show();
    }
  }
  onChildShow(shown) {
    super.onChildShow(shown);
    this.ariaElement.setAttribute("aria-expanded", true);
  }
  closeMenu() {
    if (this._menu instanceof Widget) {
      this.menu.close();
    }
  }
  onChildHide(hidden) {
    super.onChildHide(hidden);
    this.ariaElement.setAttribute("aria-expanded", false);
  }
  changeToggleGroup(toggleGroup) {
    if (toggleGroup && typeof this.checked !== "boolean") {
      this.checked = false;
    }
    return toggleGroup;
  }
  changeChecked(checked, old) {
    if (this.isConfiguring || typeof old === "boolean") {
      return Boolean(checked);
    }
  }
  updateChecked(checked) {
    const me = this;
    if (!me.isConfiguring) {
      if (me.toggleGroup) {
        me.uncheckToggleGroupMembers();
      }
      me.element.setAttribute("aria-checked", checked);
      me.trigger("toggle", {
        menu: me.owner,
        item: me,
        element: me.element,
        bubbles: true,
        checked
      });
    }
  }
  getToggleGroupMembers() {
    const me = this, {
      checked,
      toggleGroup,
      element
    } = me, result = [];
    if (checked && toggleGroup) {
      DomHelper.forEachSelector(me.rootElement, `[data-group=${toggleGroup}]`, (otherElement) => {
        if (otherElement !== element) {
          const partnerCheckItem = Widget.fromElement(otherElement);
          partnerCheckItem && result.push(partnerCheckItem);
        }
      });
    }
    return result;
  }
  uncheckToggleGroupMembers() {
    if (this.checked && this.toggleGroup) {
      this.getToggleGroupMembers().forEach((widget) => widget.checked = false);
    }
  }
  get closeParent() {
    const result = typeof this.checked === "boolean" ? this._closeParent : this._closeParent !== false;
    return result && !this.hasMenu;
  }
  changeMenu(config, existingMenu) {
    const me = this, {
      constrainTo,
      scrollAction
    } = me.owner;
    if (config && typeof config === "object" && !("items" in config) && !("widgets" in config) && !("html" in config)) {
      config = {
        lazyItems: config
      };
    }
    return Menu.reconfigure(existingMenu, config, {
      owner: me,
      defaults: {
        type: "menu",
        align: "s0-e0",
        anchor: true,
        autoClose: true,
        autoShow: false,
        cls: "b-sub-menu",
        forElement: me.element,
        owner: me,
        ariaLabel: me.text,
        constrainTo,
        scrollAction
      }
    });
  }
};
MenuItem.initClass();
MenuItem._$name = "MenuItem";
var validKeys = {
  ArrowUp: 1,
  ArrowDown: 1,
  ArrowRight: 1,
  ArrowLeft: 1,
  Enter: 1,
  Escape: 1
};
var Menu = class extends Popup {
  static get $name() {
    return "Menu";
  }
  static get type() {
    return "menu";
  }
  static get configurable() {
    return {
      focusable: true,
      align: "t-b",
      scrollAction: "hide",
      focusOnHover: null,
      scrollable: false,
      defaultType: "menuitem",
      tools: {
        close: false
      },
      role: "menu",
      ariaElement: "bodyElement"
    };
  }
  construct(config) {
    if (Array.isArray(config)) {
      config = {
        lazyItems: config
      };
    }
    super.construct(config);
    EventHelper.on({
      element: this.element,
      click: "onMouseClick",
      mouseover: "onMouseOver",
      mouseenter: "onMouseEnter",
      mouseleave: "onMouseLeave",
      thisObj: this
    });
  }
  afterShow(resolveFn) {
    const {
      items: items2,
      element
    } = this, hasSubmenu = items2.some((item) => Boolean(item._menu));
    if (hasSubmenu) {
      element.classList.add("b-menu-with-submenu");
    }
    const hasIcon = items2.some((item) => item.icon);
    if (hasIcon) {
      element.classList.add("b-menu-with-icon");
    }
    super.afterShow(resolveFn);
  }
  createWidget(item) {
    if (typeof item === "string") {
      item = {
        text: item
      };
    }
    return super.createWidget(item);
  }
  get focusElement() {
    var _me$parentMenu;
    const me = this, fromParentMenu = (_me$parentMenu = me.parentMenu) === null || _me$parentMenu === void 0 ? void 0 : _me$parentMenu.element.contains(DomHelper.getActiveElement(me.parentMenu)), firstWidget = me.items[0];
    if (fromParentMenu || DomHelper.usingKeyboard || !(firstWidget instanceof MenuItem)) {
      return super.focusElement;
    }
    return me.element;
  }
  onDocumentMouseDown({
    event
  }) {
    if (!this.parentMenu || !this.parentMenu.owns(event.target)) {
      return super.onDocumentMouseDown(...arguments);
    }
  }
  hide(animate) {
    const me = this;
    super.hide(animate);
    if (!me.isVisible) {
      var _me$currentSubMenu, _me$currentSubMenu$hi;
      (_me$currentSubMenu = me.currentSubMenu) === null || _me$currentSubMenu === void 0 ? void 0 : (_me$currentSubMenu$hi = _me$currentSubMenu.hide) === null || _me$currentSubMenu$hi === void 0 ? void 0 : _me$currentSubMenu$hi.call(_me$currentSubMenu, animate);
      if (me.parentMenu) {
        me.parentMenu.currentSubMenu = null;
      }
    }
  }
  show() {
    super.show(...arguments);
    const {
      parentMenu
    } = this;
    if (this.isVisible && parentMenu) {
      parentMenu.currentSubMenu = this;
    }
  }
  onMouseClick(event) {
    const menuItem = event.target.closest(".b-menuitem");
    if (menuItem) {
      this.triggerElement(menuItem, event);
    }
  }
  onMouseOver(event) {
    if (this.focusOnHover !== false) {
      var _event$relatedTarget;
      const fromItemElement = (_event$relatedTarget = event.relatedTarget) === null || _event$relatedTarget === void 0 ? void 0 : _event$relatedTarget.closest(".b-widget"), toItemElement = event.target.closest(".b-widget"), overItem = Widget.fromElement(toItemElement);
      if (!DomHelper.isTouchEvent && toItemElement && toItemElement !== fromItemElement && overItem.parent === this) {
        this.setTimeout({
          fn: "handleMouseOver",
          delay: 30,
          args: [overItem],
          cancelOutstanding: true
        });
      }
    }
  }
  handleMouseOver(overItem) {
    overItem.focus();
  }
  onMouseEnter() {
    this.clearTimeout(this.closeTimer);
  }
  onMouseLeave(event) {
    const me = this, {
      relatedTarget
    } = event, leavingToChild = relatedTarget && me.owns(relatedTarget);
    let targetCmp = relatedTarget instanceof HTMLElement && Widget.fromElement(relatedTarget), shouldHideMenu = !leavingToChild;
    if (targetCmp) {
      while (targetCmp.ownerCmp) {
        targetCmp = targetCmp.ownerCmp;
      }
      shouldHideMenu &= !DomHelper.getAncestor(targetCmp.element, [event.target]);
    }
    if (!leavingToChild && shouldHideMenu) {
      if (me.currentSubMenu && !me.currentSubMenu.closeTimer) {
        me.currentSubMenu.hide();
      }
      if (me.element.contains(DomHelper.getActiveElement(me)) && DomHelper.getActiveElement(me).matches(".b-menuitem")) {
        me.focusElement.focus();
      }
    }
  }
  onInternalKeyDown(event) {
    const sourceWidget = Widget.fromElement(event), isFromWidget = sourceWidget && sourceWidget !== this && !(sourceWidget instanceof MenuItem);
    if (event.key === "Escape") {
      (isFromWidget ? this : this.rootMenu).close();
      return;
    }
    super.onInternalKeyDown(event);
    if (isFromWidget) {
      return;
    }
    if (validKeys[event.key]) {
      event.preventDefault();
    }
    const el = this.element, active = DomHelper.getActiveElement(el);
    this.navigateFrom(active !== el && el.contains(active) ? active : null, event.key, event);
  }
  navigateFrom(active, key, event) {
    const me = this, {
      treeWalker
    } = me, item = active && me.getItem(active), enterSubMenu = me.rtl ? "ArrowLeft" : "ArrowRight", exitSubMenu = me.rtl ? "ArrowRight" : "ArrowLeft";
    let toActivate;
    switch (key) {
      case "ArrowUp":
        treeWalker.currentNode = active || (active = me.bottomFocusTrap);
        treeWalker.previousNode();
        toActivate = treeWalker.currentNode;
        break;
      case "ArrowDown":
        treeWalker.currentNode = active || (active = me.topFocusTrap);
        treeWalker.nextNode();
        toActivate = treeWalker.currentNode;
        break;
      case " ":
        if (active && !active.classList.contains("b-disabled")) {
          if (item !== null && item !== void 0 && item.menu) {
            me.openSubMenu(active, item);
          } else {
            me.triggerElement(active, event);
          }
        }
        break;
      case enterSubMenu:
        if (active && item !== null && item !== void 0 && item.menu && !active.classList.contains("b-disabled")) {
          const openedMenu = me.openSubMenu(active, item);
          openedMenu === null || openedMenu === void 0 ? void 0 : openedMenu.focus();
        } else {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }
        break;
      case exitSubMenu:
        if (me.isSubMenu) {
          me.hide();
        } else if (!active) {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }
        break;
      case "Enter":
        if (active && !active.classList.contains("b-disabled")) {
          me.triggerElement(active, event);
        }
        break;
    }
    if (toActivate) {
      if (toActivate === me.element) {
        me.navigateFrom(me.bottomFocusTrap, "ArrowUp", event);
      } else if (toActivate === active) {
        me.navigateFrom(me.topFocusTrap, "ArrowDown", event);
      } else {
        toActivate.focus();
      }
    }
  }
  getItem(item) {
    if (item != null) {
      if (typeof item === "number") {
        return this.items[item];
      }
      if (item.nodeType === Element.ELEMENT_NODE) {
        return Widget.fromElement(item, "menuitem", this.contentElement);
      }
      return this.items.find((c) => c.id == item);
    }
  }
  triggerElement(menuItemElement, event) {
    const item = this.getItem(menuItemElement);
    if (item && !item.disabled) {
      item.doAction(event);
    }
  }
  get isSubMenu() {
    var _this$owner;
    return this === ((_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.menu);
  }
  openSubMenu(element, item) {
    const me = this, subMenu = item.menu;
    if (subMenu) {
      if (!subMenu.isVisible) {
        var _item$onBeforeSubMenu;
        const event = {
          item,
          element
        };
        if (me.trigger("beforeSubMenu", event) === false) {
          return;
        }
        if (((_item$onBeforeSubMenu = item.onBeforeSubMenu) === null || _item$onBeforeSubMenu === void 0 ? void 0 : _item$onBeforeSubMenu.call(item, event)) === false) {
          return;
        }
        subMenu.show();
      }
      return me.currentSubMenu = subMenu;
    }
  }
  set selectedElement(element) {
    const me = this, lastSelected = me._selectedElement;
    if (lastSelected) {
      const lastItem = me.getItem(lastSelected), lastItemMenu = lastItem === null || lastItem === void 0 ? void 0 : lastItem.menu;
      lastItemMenu === null || lastItemMenu === void 0 ? void 0 : lastItemMenu.hide();
      lastSelected.classList.remove("b-active");
    }
    me._selectedElement = element;
    if (element) {
      const doFocus = DomHelper.isFocusable(element);
      element.classList.add("b-active");
      me.scrollable.scrollIntoView(element, {
        animate: !doFocus,
        focus: doFocus
      });
    }
  }
  get selectedElement() {
    return this._selectedElement;
  }
  selectFirst() {
    const treeWalker = this.treeWalker;
    treeWalker.currentNode = this.topFocusTrap;
    treeWalker.nextNode();
    this.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }
  get parentMenu() {
    var _result$up;
    const result = this.owner;
    return result && (result.isMenu ? result : (_result$up = result.up) === null || _result$up === void 0 ? void 0 : _result$up.call(result, "menu"));
  }
  get rootMenu() {
    let menu = this;
    while (menu.parentMenu instanceof this.constructor) {
      menu = menu.parentMenu;
    }
    return menu;
  }
};
Menu.initClass();
Menu._$name = "Menu";
var contextMenuKeyEvent;
var ContextMenuBase = class extends InstancePlugin {
  static get $name() {
    return "ContextMenuBase";
  }
  static get configurable() {
    return {
      type: null,
      menu: {
        $config: ["lazy", "nullify"],
        value: {
          type: "menu",
          autoShow: false,
          closeAction: "hide",
          scrollAction: "hide",
          constrainTo: globalThis
        }
      },
      items: {},
      triggerEvent: false,
      keyMap: {
        " ": {
          handler: "showContextMenuByKey",
          weight: 100
        },
        "Ctrl+Space": "showContextMenuByKey"
      }
    };
  }
  static get pluginConfig() {
    return {
      assign: ["showContextMenu"],
      chain: ["onElementContextMenu", "onElementClick", "onElementDblClick"]
    };
  }
  construct(...args) {
    var _this$type;
    super.construct(...args);
    if (!((_this$type = this.type) !== null && _this$type !== void 0 && _this$type.length)) {
      throw new Error(`Config 'type' is required to be specified for context menu`);
    }
  }
  onElementContextMenu(event) {
    this.onElementEvent(event);
  }
  onElementClick(event) {
    this.onElementEvent(event);
  }
  onElementDblClick(event) {
    this.onElementEvent(event);
  }
  onElementEvent(event) {
    if (event.ctrlKey === true) {
      event.preventDefault();
      return;
    }
    if (!event.handled && this.triggerEvent === event.type) {
      const originalEvent = event;
      if (contextMenuKeyEvent) {
        const {
          target
        } = contextMenuKeyEvent;
        event = EventHelper.fixEvent(new MouseEvent(event.type, event));
        Object.defineProperty(event, "target", {
          get: () => target,
          configurable: true
        });
        event.preventDefault = function() {
          originalEvent.preventDefault();
          originalEvent.handled = true;
        };
      }
      this.internalShowContextMenu(event);
    }
  }
  showContextMenuByKey(event) {
    if (!DomHelper.isEditable(event.target)) {
      const target = this.getKeyboardContextMenuTarget(event.target);
      if (target) {
        contextMenuKeyEvent = event;
        DomHelper.triggerMouseEvent(target, this.triggerEvent);
        event.handled = true;
        event.preventDefault();
        event.stopImmediatePropagation();
        contextMenuKeyEvent = null;
        return true;
      }
    }
    return false;
  }
  getKeyboardContextMenuTarget(targetElement) {
    const targetRect = DomHelper.isInView(targetElement);
    return targetElement.children.length ? DomHelper.childFromPoint(targetElement, targetRect.width / 2, targetRect.height / 2) : targetElement;
  }
  internalShowContextMenu(domEvent) {
    const me = this;
    if (me.disabled) {
      return;
    }
    const data = me.getDataFromEvent(domEvent);
    if (!domEvent.handled && data && me.shouldShowMenu(data)) {
      if (domEvent.type === "contextmenu" && BrowserHelper.isSafari && domEvent.ctrlKey && !domEvent.metaKey) {
        EventHelper.on({
          element: domEvent.target,
          capture: true,
          once: true,
          thisObj: this,
          click(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        });
      }
      data.domEvent = domEvent;
      me.showContextMenu(data);
    }
  }
  getDataFromEvent(event) {
    return {
      event,
      targetElement: this.getTargetElementFromEvent(event)
    };
  }
  getTargetElementFromEvent(event) {
    return event.target;
  }
  showContextMenu(event, alignSpec) {
    var _me$_menu;
    const me = this, isDOMEvent = DomHelper.isDOMEvent(event), menuContext = isDOMEvent ? me.getDataFromEvent(event) : event, domEvent = isDOMEvent ? event : menuContext.domEvent;
    (_me$_menu = me._menu) === null || _me$_menu === void 0 ? void 0 : _me$_menu.hide();
    if (me.disabled) {
      return;
    }
    me.menuContext = menuContext;
    const {
      type,
      client,
      processItems
    } = me, elCenter = DomHelper.isInView(menuContext.targetElement).center;
    Objects.assign(menuContext, {
      feature: me,
      point: domEvent !== null && domEvent !== void 0 && domEvent.clientX ? [domEvent.clientX + 1, domEvent.clientY + 1] : [elCenter.x, elCenter.y],
      menu: me,
      items: {},
      selection: client.selectedRecords
    });
    me.callChainablePopulateMenuMethod(menuContext);
    Objects.merge(menuContext.items, me.baseItems);
    me.preventDefaultEvent(menuContext);
    if ((!processItems || me.callback(processItems, client, [menuContext]) !== false) && me.hasActiveMenuItems(menuContext)) {
      me.populateItemsWithData(menuContext);
      if (me.beforeContextMenuShow(menuContext) !== false) {
        const {
          menu
        } = me;
        if (client.trigger(`${type}MenuBeforeShow`, menuContext) !== false) {
          var _me$touchMoveDetacher;
          menu.items = menuContext.items;
          menu.showBy(alignSpec || menuContext.point);
          (_me$touchMoveDetacher = me.touchMoveDetacher) === null || _me$touchMoveDetacher === void 0 ? void 0 : _me$touchMoveDetacher.call(me);
          me.touchMoveDetacher = EventHelper.on({
            element: client.element,
            touchmove: () => menu.hide(),
            thisObj: menu,
            once: true
          });
          if (domEvent) {
            domEvent.preventDefault();
            domEvent.handled = true;
          }
        }
      }
    }
  }
  get baseItems() {
    if (!this._baseItems) {
      const me = this, {
        namedItems
      } = me, baseItems = me._baseItems = Objects.assign({}, me.items);
      for (const ref in baseItems) {
        const item = baseItems[ref];
        if (item) {
          if (namedItems && ref in namedItems) {
            baseItems[ref] = typeof item === "object" ? Objects.merge(Objects.clone(namedItems[ref]), item) : namedItems[ref];
          } else if (item === true) {
            delete baseItems[ref];
          }
        }
      }
    }
    return this._baseItems;
  }
  hideContextMenu(animate) {
    var _this$menu;
    (_this$menu = this.menu) === null || _this$menu === void 0 ? void 0 : _this$menu.hide(animate);
  }
  callChainablePopulateMenuMethod(eventParams) {
    var _this$client, _this$client2;
    (_this$client = (_this$client2 = this.client)[`populate${StringHelper.capitalize(this.type)}Menu`]) === null || _this$client === void 0 ? void 0 : _this$client.call(_this$client2, eventParams);
  }
  hasActiveMenuItems(eventParams) {
    return Object.values(eventParams.items).some((item) => item && !item.hidden);
  }
  shouldShowMenu() {
    return true;
  }
  beforeContextMenuShow(eventParams) {
  }
  populateItemsWithData(eventParams) {
  }
  preventDefaultEvent(eventParams) {
    var _eventParams$event;
    (_eventParams$event = eventParams.event) === null || _eventParams$event === void 0 ? void 0 : _eventParams$event.preventDefault();
  }
  changeTriggerEvent(triggerEvent) {
    return triggerEvent || this.client.contextMenuTriggerEvent;
  }
  changeMenu(menu, oldMenu) {
    const me = this, {
      client,
      type
    } = me;
    if (menu) {
      return Menu.reconfigure(oldMenu, menu ? Menu.mergeConfigs({
        owner: client,
        rootElement: client.rootElement,
        onItem(itemEvent) {
          client.trigger(`${type}MenuItem`, itemEvent);
        },
        onToggle(itemEvent) {
          client.trigger(`${type}MenuToggleItem`, itemEvent);
        },
        onDestroy() {
          me.menu = null;
        },
        onBeforeItem(itemEvent) {
          Object.assign(itemEvent, me.menuContext);
        },
        onShow({
          source: menu2
        }) {
          me.menuContext.menu = menu2;
          client.trigger(`${type}MenuShow`, me.menuContext);
        }
      }, menu) : null, me);
    } else if (oldMenu !== null && oldMenu !== void 0 && oldMenu.isWidget) {
      oldMenu.destroy();
    }
  }
};
ContextMenuBase._$name = "ContextMenuBase";
var CSSHelper = class {
  static insertRule(cssText, parentElement = document.head) {
    const styleSheet = this.getStyleSheet(parentElement), oldCount = styleSheet.cssRules.length;
    styleSheet.insertRule(cssText, 0);
    if (styleSheet.cssRules.length > oldCount) {
      return styleSheet.cssRules[0];
    }
  }
  static findRule(selector) {
    let result;
    const isFn = typeof selector === "function";
    Array.prototype.find.call(document.head.querySelectorAll("link[rel=stylesheet],style[type*=css]"), (element) => {
      result = Array.prototype.find.call(element.sheet.rules || element.sheet.cssRules, (r) => {
        return isFn ? selector(r) : r.selectorText === selector;
      });
      if (result) {
        return true;
      }
    });
    return result;
  }
  static getStyleSheet(parentElement = document.head) {
    if (!parentElement.$bryntumStylesheet) {
      parentElement.$bryntumStylesheet = DomHelper.createElement({
        tag: "style",
        id: "bryntum-private-styles",
        type: "text/css",
        parent: parentElement
      }).sheet;
    }
    return parentElement.$bryntumStylesheet;
  }
};
CSSHelper._$name = "CSSHelper";
var DragHelperContainer = (Target) => class DragHelperContainer extends (Target || Base) {
  static get $name() {
    return "DragHelperContainer";
  }
  initContainerDrag() {
    const me = this;
    if (!me.mode) {
      me.mode = "container";
    }
    if (me.mode === "container" && !me.containers) {
      throw new Error("Container drag mode must specify containers");
    }
  }
  grabContainerDrag(event) {
    const me = this;
    if (!me.ignoreSelector || !event.target.closest(me.ignoreSelector)) {
      const element = DomHelper.getAncestor(event.target, me.containers, me.outerElement);
      if (element) {
        const box = element.getBoundingClientRect();
        me.context = {
          element,
          valid: true,
          action: "container",
          offsetX: event.pageX - box.left,
          offsetY: event.pageY - box.top,
          originalPosition: {
            parent: element.parentElement,
            prev: element.previousElementSibling,
            next: element.nextElementSibling
          }
        };
      }
      return true;
    }
    return false;
  }
  startContainerDrag(event) {
    var _outerWidgetEl$parent;
    const me = this, {
      context,
      floatRootOwner
    } = me, {
      element: dragElement
    } = context, clonedNode = dragElement.cloneNode(true), box = dragElement.getBoundingClientRect(), outerWidgetEl = floatRootOwner === null || floatRootOwner === void 0 ? void 0 : floatRootOwner.element.closest(".b-outer");
    clonedNode.classList.add(me.dragProxyCls);
    clonedNode.classList.add(me.draggingCls);
    ((floatRootOwner === null || floatRootOwner === void 0 ? void 0 : floatRootOwner.floatRoot) || DomHelper.getRootElement(dragElement)).appendChild(clonedNode);
    context.dragProxy = clonedNode;
    clonedNode.style.width = box.width + "px";
    clonedNode.style.height = box.height + "px";
    DomHelper.setTranslateXY(context.dragProxy, box.left, box.top);
    context.dragging = dragElement;
    dragElement.classList.add(me.dropPlaceholderCls);
    if (outerWidgetEl !== null && outerWidgetEl !== void 0 && (_outerWidgetEl$parent = outerWidgetEl.parentElement) !== null && _outerWidgetEl$parent !== void 0 && _outerWidgetEl$parent.matches(".b-float-root")) {
      clonedNode.style.zIndex = floatRootOwner.floatRootMaxZIndex + 1;
    }
  }
  updateContainerDrag(event) {
    var _context$dragging;
    const me = this, {
      context
    } = me;
    if (!context.started || !context.targetElement) {
      return;
    }
    const containerElement = DomHelper.getAncestor(context.targetElement, me.containers, "b-gridbase"), willLoseFocus = (_context$dragging = context.dragging) === null || _context$dragging === void 0 ? void 0 : _context$dragging.contains(DomHelper.getActiveElement(context.dragging));
    if (containerElement && DomHelper.isDescendant(context.element, containerElement)) {
      return;
    }
    if (willLoseFocus) {
      GlobalEvents$1.suspendFocusEvents();
    }
    if (containerElement && context.valid) {
      me.moveNextTo(containerElement, event);
    } else {
      me.revertPosition();
    }
    if (willLoseFocus) {
      GlobalEvents$1.resumeFocusEvents();
    }
    event.preventDefault();
  }
  finishContainerDrag(event) {
    const me = this, {
      context
    } = me, {
      dragging,
      dragProxy,
      valid,
      draggedTo,
      insertBefore,
      originalPosition
    } = context;
    if (dragging) {
      context.valid = valid && draggedTo && (dragging !== insertBefore || originalPosition.parent !== draggedTo);
      context.finalize = (valid2 = context.valid) => {
        if (!valid2 && me.context) {
          me.revertPosition();
        }
        dragging.classList.remove(me.dropPlaceholderCls);
        dragProxy.remove();
        me.reset();
      };
      context.async = false;
      me.trigger("drop", {
        context,
        event
      });
      if (!context.async) {
        context.finalize();
      }
    }
  }
  abortContainerDrag(invalid = false, event = null, silent = false) {
    const me = this, {
      context
    } = me;
    if (context.dragging) {
      context.dragging.classList.remove(me.dropPlaceholderCls);
      context.dragProxy.remove();
      me.revertPosition();
    }
    if (!silent) {
      me.trigger(invalid ? "drop" : "abort", {
        context,
        event
      });
    }
    me.reset();
  }
  updateContainerProxy(event) {
    const me = this, {
      context
    } = me, proxy = context.dragProxy;
    let newX = event.pageX - context.offsetX, newY = event.pageY - context.offsetY;
    if (typeof me.minX === "number") {
      newX = Math.max(me.minX, newX);
    }
    if (typeof me.maxX === "number") {
      newX = Math.min(me.maxX - proxy.offsetWidth, newX);
    }
    if (typeof me.minY === "number") {
      newY = Math.max(me.minY, newY);
    }
    if (typeof me.maxY === "number") {
      newY = Math.min(me.maxY - proxy.offsetHeight, newY);
    }
    if (me.lockX) {
      DomHelper.setTranslateY(proxy, newY);
    } else if (me.lockY) {
      DomHelper.setTranslateX(proxy, newX);
    } else {
      DomHelper.setTranslateXY(proxy, newX, newY);
    }
    let targetElement;
    if (event.type === "touchmove") {
      const touch = event.changedTouches[0];
      targetElement = DomHelper.elementFromPoint(touch.clientX, touch.clientY);
    } else {
      targetElement = event.target;
    }
    context.targetElement = targetElement;
  }
  moveNextTo(targetElement, event) {
    const {
      context
    } = this, dragElement = context.dragging, parent = targetElement.parentElement;
    if (targetElement !== dragElement) {
      const centerX = Rectangle.from(targetElement).center.x;
      if (this.isRTL && event.pageX > centerX || !this.isRTL && event.pageX < centerX) {
        parent.insertBefore(dragElement, targetElement);
        context.insertBefore = targetElement;
      } else {
        if (targetElement.nextElementSibling) {
          if (targetElement.nextElementSibling !== dragElement) {
            context.insertBefore = targetElement.nextElementSibling;
            parent.insertBefore(dragElement, targetElement.nextElementSibling);
          } else if (!context.insertBefore && dragElement.parentElement.lastElementChild !== dragElement) {
            context.insertBefore = targetElement.nextElementSibling;
          }
        } else {
          parent.appendChild(dragElement);
          context.insertBefore = null;
        }
      }
      context.draggedTo = parent;
    }
  }
  revertPosition() {
    const {
      context
    } = this, {
      dragging
    } = context, {
      parent,
      next
    } = context.originalPosition;
    if (next) {
      const isNoop = next.previousSibling === dragging || !next && dragging === parent.lastChild;
      if (!isNoop) {
        parent.insertBefore(dragging, next);
      }
    } else {
      parent.appendChild(dragging);
    }
    context.draggedTo = null;
  }
};
var noScroll = {
  pageXOffset: 0,
  pageYOffset: 0
};
var DragHelperTranslate = (Target) => class DragHelperTranslate extends Delayable(Target || Base) {
  static get $name() {
    return "DragHelperTranslate";
  }
  static get configurable() {
    return {
      positioning: null,
      skipUpdatingElement: null
    };
  }
  initTranslateDrag() {
    const me = this;
    if (!me.isElementDraggable && me.targetSelector) {
      me.isElementDraggable = (element) => element.closest(me.targetSelector);
    }
  }
  grabTranslateDrag(event) {
    const element = this.getTarget(event);
    if (element) {
      this.context = {
        valid: true,
        element,
        startPageX: event.pageX,
        startPageY: event.pageY,
        startClientX: event.clientX,
        startClientY: event.clientY
      };
      return true;
    }
    return false;
  }
  getTarget(event) {
    return event.target.closest(this.targetSelector);
  }
  getX(element) {
    if (this.positioning === "absolute") {
      return parseFloat(element.style.left, 10);
    } else {
      return DomHelper.getTranslateX(element);
    }
  }
  getY(element) {
    if (this.positioning === "absolute") {
      return parseFloat(element.style.top, 10);
    } else {
      return DomHelper.getTranslateY(element);
    }
  }
  getXY(element) {
    if (this.positioning === "absolute") {
      return [element.offsetLeft, element.offsetTop];
    } else {
      return DomHelper.getTranslateXY(element);
    }
  }
  setXY(element, x, y) {
    if (this.skipUpdatingElement) {
      return;
    }
    if (this.positioning === "absolute") {
      element.style.left = x + "px";
      element.style.top = y + "px";
    } else {
      DomHelper.setTranslateXY(element, x, y);
    }
  }
  startTranslateDrag(event) {
    const me = this, {
      context,
      outerElement,
      proxySelector
    } = me, dragWithin = me.dragWithin = me.dragWithin || me.cloneTarget && document.body;
    let element = context.dragProxy || context.element;
    const grabbed = element, grabbedParent = element.parentElement;
    if (me.cloneTarget) {
      const elementToClone = proxySelector ? element.querySelector(proxySelector) : element, {
        width,
        height,
        x: proxyX,
        y: proxyY
      } = Rectangle.from(elementToClone, dragWithin);
      element = me.createProxy(element);
      let x = proxyX, y = proxyY;
      if (me.autoSizeClonedTarget) {
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;
      }
      element.classList.add(me.dragProxyCls, me.draggingCls);
      element.classList.remove("b-hover", "b-selected", "b-focused");
      dragWithin.appendChild(element);
      if (!me.autoSizeClonedTarget || proxySelector) {
        const proxyRect = element.getBoundingClientRect(), {
          x: dragWithinX,
          y: dragWithinY
        } = dragWithin.getBoundingClientRect(), localX = event.clientX - dragWithinX, localY = event.clientY - dragWithinY + (dragWithin !== document.body ? document.body.getBoundingClientRect().y : 0);
        x = localX - proxyRect.width / 2;
        y = localY - proxyRect.height / 2;
        context.startPageX = event.pageX;
        context.startPageY = event.pageY;
      }
      me.setXY(element, x, y);
      grabbed.classList.add("b-drag-original");
      if (me.hideOriginalElement) {
        grabbed.classList.add("b-hidden");
      }
    }
    element.classList.add(me.draggingCls);
    Object.assign(context, {
      element,
      grabbed,
      grabbedParent,
      grabbedNextSibling: element.nextElementSibling,
      elementStartX: me.getX(element),
      elementStartY: me.getY(element),
      elementX: DomHelper.getOffsetX(element, dragWithin || outerElement),
      elementY: DomHelper.getOffsetY(element, dragWithin || outerElement),
      scrollX: 0,
      scrollY: 0,
      scrollManagerElementContainsDragProxy: !me.cloneTarget || dragWithin === outerElement
    });
    if (dragWithin) {
      context.parentElement = element.parentElement;
      if (dragWithin !== element.parentElement) {
        dragWithin.appendChild(element);
      }
      me.updateTranslateProxy(event);
    }
  }
  onDragStarted() {
    var _relatedElements;
    const me = this, {
      context
    } = me;
    let {
      relatedElements
    } = context;
    if (me.unifiedProxy) {
      context.element.classList.add("b-drag-main", "b-drag-unified-proxy");
    }
    if (((_relatedElements = relatedElements) === null || _relatedElements === void 0 ? void 0 : _relatedElements.length) > 0) {
      context.relatedElStartPos = [];
      context.relatedElDragFromPos = [];
      const {
        proxySelector
      } = me;
      let [elementStartX, elementStartY] = [context.elementStartX, context.elementStartY];
      context.originalRelatedElements = relatedElements;
      relatedElements = context.relatedElements = relatedElements.map((relatedEl, i) => {
        const proxyTemplateElement = proxySelector ? relatedEl.querySelector(proxySelector) : relatedEl, {
          x,
          y,
          width,
          height
        } = Rectangle.from(proxyTemplateElement, me.dragWithin), relatedElementToDrag = me.cloneTarget ? me.createProxy(relatedEl) : relatedEl;
        relatedElementToDrag.classList.add(me.draggingCls);
        relatedElementToDrag.classList.remove("b-hover", "b-selected", "b-focused");
        if (me.cloneTarget) {
          me.setXY(relatedElementToDrag, x, y);
          me.dragWithin.appendChild(relatedElementToDrag);
          relatedElementToDrag.classList.add(me.dragProxyCls);
          if (me.autoSizeClonedTarget) {
            relatedElementToDrag.style.width = `${width}px`;
            relatedElementToDrag.style.height = `${height}px`;
          }
          if (me.hideOriginalElement) {
            relatedEl.classList.add("b-hidden");
          }
          relatedEl.classList.add("b-drag-original");
        }
        context.relatedElStartPos[i] = context.relatedElDragFromPos[i] = me.getXY(relatedElementToDrag);
        if (me.unifiedProxy) {
          relatedElementToDrag.classList.add("b-drag-unified-animation", "b-drag-unified-proxy");
          elementStartX += me.unifiedOffset;
          elementStartY += me.unifiedOffset;
          me.setXY(relatedElementToDrag, elementStartX, elementStartY);
          context.relatedElDragFromPos[i] = [elementStartX, elementStartY];
          relatedElementToDrag.style.zIndex = 100 - i;
        }
        return relatedElementToDrag;
      });
      if (me.unifiedProxy && relatedElements && relatedElements.length > 0) {
        EventHelper.onTransitionEnd({
          element: relatedElements[0],
          property: "transform",
          handler() {
            relatedElements.forEach((el) => el.classList.remove("b-drag-unified-animation"));
          },
          thisObj: me,
          once: true
        });
      }
    }
  }
  applyConstraints(element, x, y) {
    const me = this, {
      constrain,
      dragWithin
    } = me, {
      pageXOffset,
      pageYOffset
    } = dragWithin === document.body ? globalThis : noScroll;
    if (dragWithin && constrain) {
      if (x < 0) {
        x = 0;
      }
      if (x + element.offsetWidth > dragWithin.scrollWidth) {
        x = dragWithin.scrollWidth - element.offsetWidth;
      }
      if (y < 0) {
        y = 0;
      }
      if (y + element.offsetHeight > dragWithin.scrollHeight) {
        y = dragWithin.scrollHeight - element.offsetHeight;
      }
    }
    if (typeof me.minX === "number") {
      x = Math.max(me.minX + pageXOffset, x);
    }
    if (typeof me.maxX === "number") {
      x = Math.min(me.maxX + pageXOffset, x);
    }
    if (typeof me.minY === "number") {
      y = Math.max(me.minY + pageYOffset, y);
    }
    if (typeof me.maxY === "number") {
      y = Math.min(me.maxY + pageYOffset, y);
    }
    return {
      constrainedX: x,
      constrainedY: y
    };
  }
  updateTranslateProxy(event, scrollManagerConfig) {
    const me = this, {
      lockX,
      lockY,
      context
    } = me, element = context.dragProxy || context.element, {
      relatedElements,
      relatedElDragFromPos
    } = context;
    if (context.scrollManagerElementContainsDragProxy && scrollManagerConfig) {
      context.scrollX = scrollManagerConfig.getRelativeLeftScroll(element);
      context.scrollY = scrollManagerConfig.getRelativeTopScroll(element);
    }
    context.pageX = event.pageX;
    context.pageY = event.pageY;
    context.clientX = event.clientX;
    context.clientY = event.clientY;
    let newX = context.elementStartX + event.pageX - context.startPageX + context.scrollX, newY = context.elementStartY + event.pageY - context.startPageY + context.scrollY;
    if (me.snapCoordinates) {
      const snapped = me.snapCoordinates({
        element,
        newX,
        newY
      });
      newX = snapped.x;
      newY = snapped.y;
    }
    const {
      constrainedX,
      constrainedY
    } = me.applyConstraints(element, newX, newY);
    if (context.started || constrainedX !== newX || constrainedY !== newY) {
      me.setXY(element, lockX ? void 0 : constrainedX, lockY ? void 0 : constrainedY);
    }
    if (relatedElements) {
      const deltaX = lockX ? 0 : constrainedX - context.elementStartX, deltaY = lockY ? 0 : constrainedY - context.elementStartY;
      relatedElements.forEach((r, i) => {
        const [x, y] = relatedElDragFromPos[i];
        me.setXY(r, x + deltaX, y + deltaY);
      });
    }
    context.newX = constrainedX;
    context.newY = constrainedY;
  }
  async finishTranslateDrag(event) {
    const me = this, context = me.context, {
      target
    } = event, xChanged = !me.lockX && Math.round(context.newX) !== Math.round(context.elementStartX), yChanged = !me.lockY && Math.round(context.newY) !== Math.round(context.elementStartY), element = context.dragProxy || context.element, {
      relatedElements
    } = context;
    if (!me.ignoreSamePositionDrop || xChanged || yChanged) {
      if (context.valid === false) {
        await me.abortTranslateDrag(true, event);
      } else {
        const targetRect = !me.allowDropOutside && Rectangle.from(me.dragWithin || me.outerElement);
        if (targetRect && (typeof me.minX !== "number" && me.minX !== true && event.pageX < targetRect.left || typeof me.maxX !== "number" && me.maxX !== true && event.pageX > targetRect.right || typeof me.minY !== "number" && me.minY !== true && event.pageY < targetRect.top || typeof me.maxY !== "number" && me.maxY !== true && event.pageY > targetRect.bottom)) {
          context.valid = false;
          await me.abortTranslateDrag(true, event);
        } else {
          context.finalize = async (valid = context.valid) => {
            if (context.finalized) {
              console.warn("DragHelper: Finalizing already finalized drag");
              return;
            }
            context.finalized = true;
            if (!valid && me.context) {
              await me.abortTranslateDrag(true, null, true);
            }
            if (!me.isDestroyed) {
              me.trigger("dropFinalized", {
                context,
                event,
                target
              });
              me.reset();
            }
            if (!me.cloneTarget && element.parentElement !== context.grabbedParent) {
              [element, ...relatedElements || []].forEach((el) => el.style.transform = "");
            }
          };
          context.async = false;
          await me.trigger("drop", {
            context,
            event,
            target
          });
          if (!context.async) {
            await context.finalize();
          }
        }
      }
    } else {
      me.abortTranslateDrag(false, event);
    }
  }
  async abortTranslateDrag(invalid = false, event = null, silent = false) {
    var _me$scrollManager, _me$context;
    const me = this, {
      cloneTarget,
      context,
      proxySelector,
      dragWithin,
      draggingCls
    } = me, {
      relatedElements,
      relatedElStartPos,
      grabbed
    } = context, element = context.dragProxy || context.element;
    (_me$scrollManager = me.scrollManager) === null || _me$scrollManager === void 0 ? void 0 : _me$scrollManager.stopMonitoring();
    if (context.aborted) {
      console.warn("DragHelper: Aborting already aborted drag");
      return;
    }
    let {
      elementStartX,
      elementStartY
    } = context;
    if (element && context.started) {
      if (!cloneTarget && dragWithin && dragWithin !== context.grabbedParent) {
        context.grabbedParent.insertBefore(element, context.grabbedNextSibling);
      }
      if (cloneTarget) {
        if (proxySelector) {
          const animateTo = grabbed.querySelector(proxySelector) || grabbed, {
            x,
            y
          } = Rectangle.from(animateTo);
          elementStartX = x;
          elementStartY = y;
        }
      }
      element.classList.add("b-aborting");
      me.setXY(element, elementStartX, elementStartY);
      relatedElements === null || relatedElements === void 0 ? void 0 : relatedElements.forEach((element2, i) => {
        element2.classList.remove(draggingCls);
        element2.classList.add("b-aborting");
        me.setXY(element2, relatedElStartPos[i][0], relatedElStartPos[i][1]);
      });
      if (!silent) {
        me.trigger(invalid ? "drop" : "abort", {
          context,
          event
        });
      }
      if (!DomHelper.isOrphaned(element) && !me.isDestroying) {
        await EventHelper.waitForTransitionEnd({
          element,
          property: DomHelper.getPropertyTransitionDuration(element, "transform") ? "transform" : "all",
          thisObj: me,
          once: true,
          runOnDestroy: true
        });
      }
      if (!me.isDestroyed) {
        me.trigger("abortFinalized", {
          context,
          event
        });
      }
    }
    if ((_me$context = me.context) !== null && _me$context !== void 0 && _me$context.started) {
      me.reset();
    }
  }
  cleanUp() {
    const me = this, {
      context,
      cloneTarget,
      draggingCls,
      dragProxyCls
    } = me, element = context.dragProxy || context.element, {
      relatedElements,
      originalRelatedElements,
      grabbed
    } = context, removeClonedProxies = cloneTarget && (me.removeProxyAfterDrop || !context.valid), cssClassesToRemove = [draggingCls, "b-aborting", dragProxyCls, "b-drag-main", "b-drag-unified-proxy"];
    element.classList.remove(...cssClassesToRemove);
    if (removeClonedProxies) {
      element.remove();
    }
    relatedElements === null || relatedElements === void 0 ? void 0 : relatedElements.forEach((element2) => {
      if (removeClonedProxies) {
        element2.remove();
      } else {
        element2.classList.remove(...cssClassesToRemove);
      }
    });
    grabbed.classList.remove("b-drag-original", "b-hidden");
    originalRelatedElements === null || originalRelatedElements === void 0 ? void 0 : originalRelatedElements.forEach((element2) => element2.classList.remove("b-hidden", "b-drag-original"));
  }
};
var rootElementListeners = {
  move: "onMouseMove",
  up: "onMouseUp",
  docclick: "onDocumentClick",
  touchstart: "onTouchStart",
  touchmove: "onTouchMove",
  touchend: "onTouchEnd",
  keydown: "onKeyDown"
};
var DragHelper = class extends Base.mixin(Events, DragHelperContainer, DragHelperTranslate) {
  static get defaultConfig() {
    return {
      dragProxyCls: "b-drag-proxy",
      invalidCls: "b-drag-invalid",
      draggingCls: "b-dragging",
      dropPlaceholderCls: "b-drop-placeholder",
      dragThreshold: 5,
      outerElement: document.body,
      dragWithin: null,
      unifiedProxy: null,
      monitoringConfig: null,
      constrain: true,
      minX: null,
      maxX: null,
      minY: null,
      maxY: null,
      mode: "translateXY",
      isElementDraggable: null,
      targetSelector: null,
      dropTargetSelector: null,
      dropTargetCls: null,
      proxySelector: null,
      cloneTarget: false,
      autoSizeClonedTarget: true,
      hideOriginalElement: false,
      containers: null,
      ignoreSelector: null,
      startEvent: null,
      lockX: false,
      lockY: false,
      touchStartDelay: 300,
      scrollManager: null,
      snapCoordinates: null,
      unifiedOffset: 5,
      removeProxyAfterDrop: true,
      clickSwallowDuration: 50,
      ignoreSamePositionDrop: true,
      allowDropOutside: null,
      floatRootOwner: null,
      mouseMoveListenerElement: document,
      testConfig: {
        transitionDuration: 10,
        clickSwallowDuration: 50,
        touchStartDelay: 100
      },
      rtlSource: null,
      createProxy: null
    };
  }
  construct(config) {
    const me = this;
    super.construct(config);
    me.initListeners();
    if (me.isContainerDrag) {
      me.initContainerDrag();
    } else {
      me.initTranslateDrag();
    }
    me.onScrollManagerScrollCallback = me.onScrollManagerScrollCallback.bind(me);
  }
  doDestroy() {
    this.reset(true);
    super.doDestroy();
  }
  initListeners() {
    const me = this, {
      outerElement
    } = me, dragStartListeners = {
      element: outerElement,
      pointerdown: "onPointerDown",
      thisObj: me
    };
    me.mouseMoveListenerElement = me.getMouseMoveListenerTarget(outerElement);
    EventHelper.on(dragStartListeners);
  }
  getMouseMoveListenerTarget(element) {
    const root2 = element.getRootNode();
    let result = this.mouseMoveListenerElement;
    if (root2.nodeType === Node.DOCUMENT_FRAGMENT_NODE && root2.mode === "closed") {
      result = element.closest(".b-outer") || result;
    }
    return result;
  }
  get isRTL() {
    var _this$rtlSource;
    return Boolean((_this$rtlSource = this.rtlSource) === null || _this$rtlSource === void 0 ? void 0 : _this$rtlSource.rtl);
  }
  onPointerDown(event) {
    const me = this;
    if (event.button !== 0 || !DomHelper.isVisible(event.target) || me.context) {
      return;
    }
    if (me.isElementDraggable && !me.isElementDraggable(event.target, event)) {
      return;
    }
    me.startEvent = event;
    const handled = me.isContainerDrag ? me.grabContainerDrag(event) : me.grabTranslateDrag(event);
    if (handled) {
      me.blurDetacher = EventHelper.on({
        element: globalThis,
        blur: me.onWindowBlur,
        thisObj: me
      });
      const dragListeners = {
        element: me.mouseMoveListenerElement,
        thisObj: me,
        capture: true,
        keydown: rootElementListeners.keydown
      };
      if (event.pointerType === "touch") {
        me.touchStartTimer = me.setTimeout(() => me.touchStartTimer = null, me.touchStartDelay, "touchStartDelay");
        dragListeners.touchmove = {
          handler: rootElementListeners.touchmove,
          passive: false
        };
        dragListeners.touchend = dragListeners.pointerup = rootElementListeners.touchend;
      } else {
        dragListeners.pointermove = rootElementListeners.move;
        dragListeners.pointerup = rootElementListeners.up;
      }
      me.dragListenersDetacher = EventHelper.on(dragListeners);
      if (me.dragWithin && me.dragWithin !== me.outerElement && me.outerElement.contains(me.dragWithin)) {
        const box = Rectangle.from(me.dragWithin, me.outerElement);
        me.minY = box.top;
        me.maxY = box.bottom;
        me.minX = box.left;
        me.maxX = box.right;
      }
    }
  }
  internalMove(event) {
    var _event$target;
    if (event.scrollInitiated) {
      return;
    }
    const me = this, {
      context
    } = me, distance = EventHelper.getDistanceBetween(me.startEvent, event), abortTouchDrag = me.touchStartTimer && distance > me.dragThreshold;
    if (abortTouchDrag) {
      me.abort(true);
      return;
    }
    if (!me.touchStartTimer && context !== null && context !== void 0 && context.element && (context.started || distance >= me.dragThreshold) && ((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.nodeType) === Node.ELEMENT_NODE) {
      if (!context.started) {
        var _me$scrollManager, _me$onDragStarted;
        if (me.trigger("beforeDragStart", {
          context,
          event
        }) === false) {
          return me.abort();
        }
        if (me.isContainerDrag) {
          me.startContainerDrag(event);
        } else {
          me.startTranslateDrag(event);
        }
        context.started = true;
        (_me$scrollManager = me.scrollManager) === null || _me$scrollManager === void 0 ? void 0 : _me$scrollManager.startMonitoring(ObjectHelper.merge({
          scrollables: [{
            element: me.dragWithin || me.outerElement
          }],
          callback: me.onScrollManagerScrollCallback
        }, me.monitoringConfig));
        context.outermostEl = DomHelper.getOutermostElement(event.target);
        context.outermostEl.classList.add("b-draghelper-active");
        if (me.dropTargetSelector && me.dropTargetCls) {
          DomHelper.getRootElement(me.outerElement).querySelectorAll(me.dropTargetSelector).forEach((el) => el.classList.add(me.dropTargetCls));
        }
        me.trigger("dragStart", {
          context,
          event
        });
        (_me$onDragStarted = me.onDragStarted) === null || _me$onDragStarted === void 0 ? void 0 : _me$onDragStarted.call(me);
        me.trigger("afterDragStart", {
          context,
          event
        });
      }
      me.update(event);
      if (event.type === "touchmove") {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    }
  }
  onScrollManagerScrollCallback(config) {
    var _this$context;
    const {
      lastMouseMoveEvent
    } = this;
    if ((_this$context = this.context) !== null && _this$context !== void 0 && _this$context.element && lastMouseMoveEvent) {
      lastMouseMoveEvent.isScroll = true;
      this.update(lastMouseMoveEvent, config);
    }
  }
  onTouchMove(event) {
    this.internalMove(event);
  }
  onMouseMove(event) {
    this.internalMove(event);
  }
  update(event, scrollManagerConfig) {
    const me = this, {
      context
    } = me, scrollingPageElement = document.scrollingElement || document.body;
    let target = me.getMouseMoveEventTarget(event);
    if (event.type === "touchmove") {
      const touch = event.changedTouches[0];
      target = DomHelper.elementFromPoint(touch.clientX + scrollingPageElement.scrollLeft, touch.clientY + scrollingPageElement.scrollTop);
    }
    context.target = target;
    let internallyValid = me.allowDropOutside || !me.dragWithin || me.dragWithin.contains(event.target);
    if (internallyValid && me.dropTargetSelector) {
      var _target;
      internallyValid = internallyValid && Boolean((_target = target) === null || _target === void 0 ? void 0 : _target.closest(me.dropTargetSelector));
    }
    if (me.isContainerDrag) {
      me.updateContainerProxy(event, scrollManagerConfig);
    } else {
      me.updateTranslateProxy(event, scrollManagerConfig);
    }
    context.valid = internallyValid;
    me.trigger("drag", {
      context,
      event
    });
    if (me.isContainerDrag) {
      me.updateContainerDrag(event, scrollManagerConfig);
    }
    context.valid = context.valid && internallyValid;
    for (const element of me.draggedElements) {
      element.classList.toggle(me.invalidCls, !context.valid);
    }
    if (event) {
      me.lastMouseMoveEvent = event;
    }
  }
  get draggedElements() {
    var _context$relatedEleme;
    const {
      context
    } = this;
    return [context.dragProxy || context.element, ...(_context$relatedEleme = context.relatedElements) !== null && _context$relatedEleme !== void 0 ? _context$relatedEleme : []];
  }
  async abort(silent = false) {
    var _me$scrollManager2, _me$scrollManager2$st;
    const me = this, {
      context
    } = me;
    (_me$scrollManager2 = me.scrollManager) === null || _me$scrollManager2 === void 0 ? void 0 : (_me$scrollManager2$st = _me$scrollManager2.stopMonitoring) === null || _me$scrollManager2$st === void 0 ? void 0 : _me$scrollManager2$st.call(_me$scrollManager2);
    me.removeListeners();
    if (context !== null && context !== void 0 && context.started && !context.aborted) {
      context.element.getBoundingClientRect();
      context.valid = false;
      if (me.isContainerDrag) {
        me.abortContainerDrag(void 0, void 0, silent);
      } else {
        me.abortTranslateDrag(void 0, void 0, silent);
      }
      context.aborted = true;
    } else {
      me.reset(true);
    }
  }
  removeListeners() {
    var _this$dragListenersDe, _this$blurDetacher;
    (_this$dragListenersDe = this.dragListenersDetacher) === null || _this$dragListenersDe === void 0 ? void 0 : _this$dragListenersDe.call(this);
    (_this$blurDetacher = this.blurDetacher) === null || _this$blurDetacher === void 0 ? void 0 : _this$blurDetacher.call(this);
  }
  reset(silent) {
    const me = this, {
      context
    } = me;
    if (context !== null && context !== void 0 && context.started) {
      for (const element of me.draggedElements) {
        element.classList.remove(me.invalidCls);
      }
      context.outermostEl.classList.remove("b-draghelper-active");
      if (me.isContainerDrag) {
        context.dragProxy.remove();
      } else {
        me.cleanUp();
      }
      if (me.dropTargetSelector && me.dropTargetCls) {
        DomHelper.getRootElement(me.outerElement).querySelectorAll(me.dropTargetSelector).forEach((el) => el.classList.remove(me.dropTargetCls));
      }
    }
    me.removeListeners();
    if (!silent) {
      me.trigger("reset");
    }
    me.context = me.lastMouseMoveEvent = null;
  }
  onTouchEnd(event) {
    this.onMouseUp(event);
  }
  onDocumentClick(event) {
    event.stopPropagation();
  }
  onMouseUp(event) {
    const me = this, {
      context
    } = me;
    me.removeListeners();
    if (context) {
      var _me$scrollManager3;
      (_me$scrollManager3 = me.scrollManager) === null || _me$scrollManager3 === void 0 ? void 0 : _me$scrollManager3.stopMonitoring();
      if (context.started) {
        event.stopPropagation();
        context.finalizing = true;
        if (me.isContainerDrag) {
          me.finishContainerDrag(event);
        } else {
          me.finishTranslateDrag(event);
        }
        EventHelper.on({
          element: document,
          thisObj: me,
          click: rootElementListeners.docclick,
          capture: true,
          expires: me.clickSwallowDuration,
          once: true
        });
      } else {
        me.reset(true);
      }
    }
  }
  onKeyDown(event) {
    var _this$context2;
    if ((_this$context2 = this.context) !== null && _this$context2 !== void 0 && _this$context2.started && event.key === "Escape") {
      event.stopImmediatePropagation();
      this.abort();
    }
  }
  onWindowBlur() {
    if (this.context && !this.context.finalizing) {
      this.abort();
    }
  }
  createProxy(element) {
    if (this.proxySelector) {
      element = element.querySelector(this.proxySelector) || element;
    }
    const proxy = element.cloneNode(true);
    proxy.removeAttribute("id");
    return proxy;
  }
  get isContainerDrag() {
    return this.mode === "container";
  }
  async animateProxyTo(targetElement, alignSpec = {
    align: "c-c"
  }) {
    const {
      context,
      draggedElements
    } = this, {
      element
    } = context, targetRect = targetElement.isRectangle ? targetElement : Rectangle.from(targetElement);
    draggedElements.forEach((el) => {
      el.classList.add("b-drag-final-transition");
      DomHelper.alignTo(el, targetRect, alignSpec);
    });
    await EventHelper.waitForTransitionEnd({
      element,
      property: "all",
      thisObj: this,
      once: true
    });
    draggedElements.forEach((el) => el.classList.remove("b-drag-final-transition"));
  }
  get isDragging() {
    var _this$context3;
    return Boolean((_this$context3 = this.context) === null || _this$context3 === void 0 ? void 0 : _this$context3.started);
  }
  getMouseMoveEventTarget(event) {
    return !event.isScroll ? event.target : DomHelper.elementFromPoint(event.clientX, event.clientY);
  }
};
DragHelper._$name = "DragHelper";
var documentListeners = {
  down: "onMouseDown",
  move: "onMouseMove",
  up: "onMouseUp",
  docclick: "onDocumentClick",
  touchstart: {
    handler: "onTouchStart",
    passive: false
  },
  touchmove: "onTouchMove",
  touchend: "onTouchEnd",
  keydown: "onKeyDown"
};
var ResizeHelper = class extends Events(Base) {
  static get defaultConfig() {
    return {
      resizingCls: "b-resizing",
      dragThreshold: 5,
      handleSize: 10,
      dynamicHandleSize: null,
      reservedSpace: 10,
      touchHandleSize: 30,
      minWidth: 1,
      maxWidth: 0,
      minHeight: 1,
      maxHeight: 0,
      outerElement: document.body,
      scroller: null,
      allowResize: null,
      dragWithin: null,
      isElementResizable: null,
      targetSelector: null,
      leftHandle: true,
      rightHandle: true,
      topHandle: true,
      bottomHandle: true,
      handleSelector: null,
      handleContainerSelector: null,
      startEvent: null,
      grab: null,
      invalidCls: "b-resize-invalid",
      handleVisibilityThreshold: null,
      skipTranslate: false,
      direction: "horizontal",
      clickSwallowDuration: 50,
      rtlSource: null
    };
  }
  construct(config) {
    const me = this;
    super.construct(config);
    if (!me.handleSelector && !BrowserHelper.isHoverableDevice) {
      me.handleSize = me.touchHandleSize;
    }
    me.handleVisibilityThreshold = me.handleVisibilityThreshold || 2 * me.handleSize;
    me.initListeners();
    me.initResize();
  }
  doDestroy() {
    this.abort(true);
    super.doDestroy();
  }
  updateSkipUpdatingElement(skip) {
    if (skip) {
      this.skipTranslate = true;
    }
  }
  initResize() {
    const me = this;
    if (!me.isElementResizable && me.targetSelector) {
      me.isElementResizable = (element) => element.closest(me.targetSelector);
    }
    if (me.grab) {
      const {
        edge,
        element,
        event
      } = me.grab;
      me.startEvent = event;
      const cursorOffset = me.getCursorOffsetToElementEdge(event, element, edge);
      me.context = {
        element,
        edge,
        valid: true,
        async: false,
        elementStartX: DomHelper.getTranslateX(element) || element.offsetLeft,
        elementStartY: DomHelper.getTranslateY(element) || element.offsetTop,
        newX: DomHelper.getTranslateX(element) || element.offsetLeft,
        newY: DomHelper.getTranslateY(element) || element.offsetTop,
        elementWidth: element.offsetWidth,
        elementHeight: element.offsetHeight,
        cursorOffset,
        startX: event.clientX + cursorOffset.x + me.scrollLeft,
        startY: event.clientY + cursorOffset.y + me.scrollTop,
        finalize: () => {
          var _me$reset;
          return (_me$reset = me.reset) === null || _me$reset === void 0 ? void 0 : _me$reset.call(me);
        }
      };
      element.classList.add(me.resizingCls);
      me.internalStartResize(me.isTouch);
    }
  }
  initListeners() {
    const me = this, dragStartListeners = {
      element: me.outerElement,
      mousedown: documentListeners.down,
      touchstart: documentListeners.touchstart,
      thisObj: me
    };
    if (!me.handleSelector && BrowserHelper.isHoverableDevice) {
      dragStartListeners.mousemove = {
        handler: documentListeners.move,
        delegate: me.targetSelector
      };
      dragStartListeners.mouseleave = {
        handler: "onMouseLeaveTarget",
        delegate: me.targetSelector,
        capture: true
      };
    }
    EventHelper.on(dragStartListeners);
  }
  get isRTL() {
    var _this$rtlSource;
    return Boolean((_this$rtlSource = this.rtlSource) === null || _this$rtlSource === void 0 ? void 0 : _this$rtlSource.rtl);
  }
  get scrollLeft() {
    if (this.scroller) {
      return this.scroller.x;
    }
    return this.outerElement.scrollLeft;
  }
  get scrollTop() {
    if (this.scroller) {
      return this.scroller.y;
    }
    return this.outerElement.scrollTop;
  }
  internalStartResize(isTouch) {
    const dragListeners = {
      element: document,
      keydown: documentListeners.keydown,
      thisObj: this
    };
    if (isTouch) {
      dragListeners.touchmove = documentListeners.touchmove;
      dragListeners.touchend = dragListeners.pointerup = documentListeners.touchend;
    } else {
      dragListeners.mousemove = documentListeners.move;
      dragListeners.mouseup = documentListeners.up;
    }
    this.removeDragListeners = EventHelper.on(dragListeners);
  }
  removeDragListeners() {
  }
  reset() {
    var _this$removeDragListe;
    (_this$removeDragListe = this.removeDragListeners) === null || _this$removeDragListe === void 0 ? void 0 : _this$removeDragListe.call(this);
    this.context = null;
    this.trigger("reset");
  }
  canResize(element, event) {
    return !this.isElementResizable || this.isElementResizable(element, event);
  }
  onPointerDown(isTouch, event) {
    const me = this;
    me.startEvent = event;
    if (me.canResize(event.target, event) && me.grabResizeHandle(isTouch, event)) {
      event.stopImmediatePropagation();
      if (event.type === "touchstart") {
        event.preventDefault();
      }
      me.internalStartResize(isTouch);
    }
  }
  onTouchStart(event) {
    if (event.touches.length > 1) {
      return;
    }
    this.onPointerDown(true, event);
  }
  onMouseDown(event) {
    if (event.button !== 0) {
      return;
    }
    this.onPointerDown(false, event);
  }
  internalMove(isTouch, event) {
    const me = this, {
      context,
      direction
    } = me;
    if (context !== null && context !== void 0 && context.element && (context.started || EventHelper.getDistanceBetween(me.startEvent, event) >= me.dragThreshold)) {
      if (!context.started) {
        var _me$scrollManager;
        (_me$scrollManager = me.scrollManager) === null || _me$scrollManager === void 0 ? void 0 : _me$scrollManager.startMonitoring(ObjectHelper.merge({
          scrollables: [{
            element: me.dragWithin || me.outerElement,
            direction
          }],
          callback: (config) => {
            var _me$context;
            return ((_me$context = me.context) === null || _me$context === void 0 ? void 0 : _me$context.element) && me.lastMouseMoveEvent && me.update(me.lastMouseMoveEvent, config);
          }
        }, me.monitoringConfig));
        me.trigger("resizeStart", {
          context,
          event
        });
        context.started = true;
      }
      me.update(event);
    } else if (!isTouch && !me.handleSelector) {
      me.checkResizeHandles(event);
    }
  }
  onTouchMove(event) {
    this.internalMove(true, event);
  }
  onMouseMove(event) {
    this.internalMove(false, event);
  }
  onPointerUp(isTouch, event) {
    var _me$removeDragListene;
    const me = this, context = me.context;
    (_me$removeDragListene = me.removeDragListeners) === null || _me$removeDragListene === void 0 ? void 0 : _me$removeDragListene.call(me);
    if (context) {
      var _me$scrollManager2;
      (_me$scrollManager2 = me.scrollManager) === null || _me$scrollManager2 === void 0 ? void 0 : _me$scrollManager2.stopMonitoring();
      if (context.started) {
        EventHelper.on({
          element: document,
          thisObj: me,
          click: documentListeners.docclick,
          expires: me.clickSwallowDuration,
          capture: true,
          once: true
        });
      }
      me.finishResize(event);
    } else {
      var _me$reset2;
      (_me$reset2 = me.reset) === null || _me$reset2 === void 0 ? void 0 : _me$reset2.call(me);
    }
  }
  onTouchEnd(event) {
    this.onPointerUp(true, event);
  }
  onMouseUp(event) {
    this.onPointerUp(false, event);
  }
  onDocumentClick(event) {
    event.stopPropagation();
  }
  onKeyDown(event) {
    if (event.key === "Escape") {
      this.abort();
    }
  }
  update(event) {
    const me = this, context = me.context, parentRectangle = Rectangle.from(me.outerElement);
    context.currentX = Math.max(Math.min(event.clientX + context.cursorOffset.x, parentRectangle.right), parentRectangle.x) + me.scrollLeft;
    context.currentY = Math.max(Math.min(event.clientY + context.cursorOffset.y, parentRectangle.bottom), parentRectangle.y) + me.scrollTop;
    if (event) {
      if (me.updateResize(event)) {
        me.trigger("resizing", {
          context,
          event
        });
        context.element.classList.toggle(me.invalidCls, context.valid === false);
      }
      me.lastMouseMoveEvent = event;
    }
  }
  abort(silent = false) {
    var _me$scrollManager3, _me$scrollManager3$st;
    const me = this;
    (_me$scrollManager3 = me.scrollManager) === null || _me$scrollManager3 === void 0 ? void 0 : (_me$scrollManager3$st = _me$scrollManager3.stopMonitoring) === null || _me$scrollManager3$st === void 0 ? void 0 : _me$scrollManager3$st.call(_me$scrollManager3);
    if (me.context) {
      me.abortResize(null, silent);
    } else if (!me.isDestroyed) {
      me.reset();
    }
  }
  grabResizeHandle(isTouch, event) {
    const me = this;
    if (me.allowResize && !me.allowResize(event.target, event)) {
      return false;
    }
    const handleSelector = me.handleSelector, coordsFrom = event.type === "touchstart" ? event.changedTouches[0] : event, clientX = coordsFrom.clientX, clientY = coordsFrom.clientY, element = me.targetSelector ? event.target.closest(me.targetSelector) : event.target;
    if (element) {
      let edge;
      if (handleSelector) {
        if (event.target.matches(handleSelector)) {
          if (me.direction === "horizontal") {
            if (event.pageX < DomHelper.getPageX(element) + element.offsetWidth / 2) {
              edge = me.isRTL ? "right" : "left";
            } else {
              edge = me.isRTL ? "left" : "right";
            }
          } else {
            if (event.pageY < DomHelper.getPageY(element) + element.offsetHeight / 2) {
              edge = "top";
            } else {
              edge = "bottom";
            }
          }
        } else {
          return false;
        }
      } else {
        if (me.direction === "horizontal") {
          if (me.overLeftHandle(event, element)) {
            edge = me.isRTL ? "right" : "left";
          } else if (me.overRightHandle(event, element)) {
            edge = me.isRTL ? "left" : "right";
          }
        } else {
          if (me.overTopHandle(event, element)) {
            edge = "top";
          } else if (me.overBottomHandle(event, element)) {
            edge = "bottom";
          }
        }
        if (!edge) {
          me.context = null;
          return false;
        }
      }
      if (event.type === "touchstart") {
        event.preventDefault();
      }
      const cursorOffset = me.getCursorOffsetToElementEdge(coordsFrom, element, edge);
      if (me.trigger("beforeResizeStart", {
        element,
        event
      }) !== false) {
        me.context = {
          element,
          edge,
          isTouch,
          valid: true,
          async: false,
          direction: me.direction,
          elementStartX: DomHelper.getTranslateX(element) || element.offsetLeft,
          elementStartY: DomHelper.getTranslateY(element) || element.offsetTop,
          newX: DomHelper.getTranslateX(element) || element.offsetLeft,
          newY: DomHelper.getTranslateY(element) || element.offsetTop,
          elementWidth: element.offsetWidth,
          elementHeight: element.offsetHeight,
          cursorOffset,
          startX: clientX + cursorOffset.x + me.scrollLeft,
          startY: clientY + cursorOffset.y + me.scrollTop,
          finalize: () => {
            var _me$reset3;
            return (_me$reset3 = me.reset) === null || _me$reset3 === void 0 ? void 0 : _me$reset3.call(me);
          }
        };
        element.classList.add(me.resizingCls);
        return true;
      }
    }
    return false;
  }
  getCursorOffsetToElementEdge(event, element, edge) {
    const rectEl = Rectangle.from(element);
    let x = 0, y = 0;
    switch (edge) {
      case "left":
        x = rectEl.x - (this.isRTL ? rectEl.width : 0) - event.clientX;
        break;
      case "right":
        x = rectEl.x + (this.isRTL ? 0 : rectEl.width) - event.clientX;
        break;
      case "top":
        y = rectEl.y - event.clientY;
        break;
      case "bottom":
        y = rectEl.y + rectEl.height - event.clientY;
        break;
    }
    return {
      x,
      y
    };
  }
  checkResizeHandles(event) {
    const me = this, target = me.targetSelector ? event.target.closest(me.targetSelector) : event.target;
    if (target && (!me.allowResize || me.allowResize(event.target, event))) {
      me.currentElement = me.handleContainerSelector ? event.target.closest(me.handleContainerSelector) : event.target;
      if (me.currentElement) {
        let over;
        if (me.direction === "horizontal") {
          over = me.overLeftHandle(event, target) || me.overRightHandle(event, target);
        } else {
          over = me.overTopHandle(event, target) || me.overBottomHandle(event, target);
        }
        if (over) {
          me.highlightHandle();
        } else {
          me.unHighlightHandle();
        }
      }
    } else if (me.currentElement) {
      me.unHighlightHandle();
    }
  }
  onMouseLeaveTarget(event) {
    const me = this;
    me.currentElement = me.handleContainerSelector ? event.target.closest(me.handleContainerSelector) : event.target;
    if (me.currentElement) {
      me.unHighlightHandle();
    }
  }
  updateResize(event) {
    const me = this, {
      context,
      allowEdgeSwitch,
      skipTranslate,
      skipUpdatingElement
    } = me;
    let updated;
    if (allowEdgeSwitch) {
      if (me.direction === "horizontal") {
        context.edge = context.currentX > context.startX ? "right" : "left";
      } else {
        context.edge = context.currentY > context.startY ? "bottom" : "top";
      }
    }
    const {
      element,
      elementStartX,
      elementStartY,
      elementWidth,
      elementHeight,
      edge
    } = context, {
      style
    } = element, deltaX = context.currentX - context.startX, deltaY = context.currentY - context.startY, minWidth = DomHelper.getExtremalSizePX(element, "minWidth") || me.minWidth, maxWidth = DomHelper.getExtremalSizePX(element, "maxWidth") || me.maxWidth, minHeight = DomHelper.getExtremalSizePX(element, "minHeight") || me.minHeight, maxHeight = DomHelper.getExtremalSizePX(element, "maxHeight") || me.maxHeight, sign = edge === "right" && !me.isRTL || edge === "bottom" ? 1 : -1, newWidth = elementWidth + deltaX * sign, newHeight = elementHeight + deltaY * sign;
    let width = Math.max(minWidth, newWidth), height = Math.max(minHeight, newHeight);
    if (maxWidth > 0) {
      width = Math.min(width, maxWidth);
    }
    if (maxHeight > 0) {
      height = Math.min(height, maxHeight);
    }
    if (style.flex) {
      style.flex = "";
    }
    if (me.direction === "horizontal" && elementWidth !== width) {
      if (!skipUpdatingElement) {
        style.width = Math.abs(width) + "px";
      }
      context.newWidth = width;
      if (edge === "left" || width < 0) {
        const newX = Math.max(Math.min(elementStartX + elementWidth - me.minWidth, elementStartX + deltaX), 0);
        if (!skipTranslate) {
          DomHelper.setTranslateX(element, Math.round(newX));
        }
        context.newX = newX;
      } else if (edge === "right" && allowEdgeSwitch && !skipTranslate) {
        DomHelper.setTranslateX(element, elementStartX);
      }
      updated = true;
    } else if (me.direction === "vertical" && elementHeight !== newHeight) {
      if (!skipUpdatingElement) {
        style.height = Math.abs(height) + "px";
      }
      context.newHeight = height;
      if (edge === "top" || height < 0) {
        context.newY = Math.max(Math.min(elementStartY + elementHeight - me.minHeight, elementStartY + deltaY), 0);
        if (!skipTranslate) {
          DomHelper.setTranslateY(element, context.newY);
        }
      } else if (edge === "bottom" && allowEdgeSwitch && !skipTranslate) {
        DomHelper.setTranslateY(element, elementStartY);
      }
      updated = true;
    }
    return updated;
  }
  finishResize(event) {
    const me = this, context = me.context, eventObject = {
      context,
      event
    };
    context.element.classList.remove(me.resizingCls);
    if (context.started) {
      let changed = false;
      if (me.direction === "horizontal") {
        changed = context.newWidth && context.newWidth !== context.elementWidth;
      } else {
        changed = context.newHeight && context.newHeight !== context.elementHeight;
      }
      me.trigger(changed ? "resize" : "cancel", eventObject);
      if (!context.async) {
        context.finalize();
      }
    } else {
      var _me$reset4;
      (_me$reset4 = me.reset) === null || _me$reset4 === void 0 ? void 0 : _me$reset4.call(me);
    }
  }
  abortResize(event = null, silent = false) {
    const me = this, context = me.context;
    context.element.classList.remove(me.resizingCls);
    if (me.direction === "horizontal") {
      if (context.edge === "left" || context.allowEdgeSwitch && !context.skipTranslate) {
        DomHelper.setTranslateX(context.element, context.elementStartX);
      }
      context.element.style.width = context.elementWidth + "px";
    } else {
      DomHelper.setTranslateY(context.element, context.elementStartY);
      context.element.style.height = context.elementHeight + "px";
    }
    !silent && me.trigger("cancel", {
      context,
      event
    });
    if (!me.isDestroyed) {
      me.reset();
    }
  }
  highlightHandle() {
    const me = this, target = me.targetSelector ? me.currentElement.closest(me.targetSelector) : me.currentElement;
    me.currentElement.classList.add("b-resize-handle");
    target.classList.add("b-over-resize-handle");
  }
  unHighlightHandle() {
    const me = this, target = me.targetSelector ? me.currentElement.closest(me.targetSelector) : me.currentElement;
    target && target.classList.remove("b-over-resize-handle");
    me.currentElement.classList.remove("b-resize-handle");
    me.currentElement = null;
  }
  overAnyHandle(event, target) {
    return this.overStartHandle(event, target) || this.overEndHandle(event, target);
  }
  overStartHandle(event, target) {
    return this.direction === "horizontal" ? this.overLeftHandle(event, target) : this.overTopHandle(event, target);
  }
  overEndHandle(event, target) {
    return this.direction === "horizontal" ? this.overRightHandle(event, target) : this.overBottomHandle(event, target);
  }
  getDynamicHandleSize(opposite, offsetWidth) {
    const handleCount = opposite ? 2 : 1, {
      handleSize
    } = this;
    if (this.dynamicHandleSize && handleSize * handleCount > offsetWidth - this.reservedSpace) {
      return Math.max(Math.floor((offsetWidth - this.reservedSpace) / handleCount), 0);
    }
    return handleSize;
  }
  overLeftHandle(event, target) {
    const me = this, {
      offsetWidth
    } = target;
    if (me.leftHandle && me.canResize(target, event) && (offsetWidth >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const leftHandle = Rectangle.from(target);
      leftHandle.width = me.getDynamicHandleSize(me.rightHandle, offsetWidth);
      return leftHandle.width > 0 && leftHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
  overRightHandle(event, target) {
    const me = this, {
      offsetWidth
    } = target;
    if (me.rightHandle && me.canResize(target, event) && (offsetWidth >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const rightHandle = Rectangle.from(target);
      rightHandle.x = rightHandle.right - me.getDynamicHandleSize(me.leftHandle, offsetWidth);
      return rightHandle.width > 0 && rightHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
  overTopHandle(event, target) {
    const me = this, {
      offsetHeight
    } = target;
    if (me.topHandle && me.canResize(target, event) && (offsetHeight >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const topHandle = Rectangle.from(target);
      topHandle.height = me.getDynamicHandleSize(me.bottomHandle, offsetHeight);
      return topHandle.height > 0 && topHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
  overBottomHandle(event, target) {
    const me = this, {
      offsetHeight
    } = target;
    if (me.bottomHandle && me.canResize(target, event) && (offsetHeight >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const bottomHandle = Rectangle.from(target);
      bottomHandle.y = bottomHandle.bottom - me.getDynamicHandleSize(me.bottomHandle, offsetHeight);
      return bottomHandle.height > 0 && bottomHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
};
_defineProperty(ResizeHelper, "configurable", {
  skipUpdatingElement: null
});
ResizeHelper._$name = "ResizeHelper";
var tagSpaceRe = />[ \t\r\n]+</g;
var multiSpaceRe = /\s\s+/g;
var TemplateHelper = class {
  static tpl(strings, ...values) {
    let count = 0, output = values.map((val, i) => {
      let ret = strings[i];
      if (Array.isArray(val)) {
        ret += val.reduce((ack, item) => ack += (typeof item === "string" ? item.trim() : item) + "\n", "");
      } else {
        if (val === void 0) {
          val = "";
        }
        ret += typeof val === "string" ? val.trim() : val;
      }
      count++;
      return ret;
    }).join("");
    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }
    return output.replace(tagSpaceRe, "><").replace(multiSpaceRe, " ").trim();
  }
  static docsTpl(strings, ...values) {
    let count = 0, output = values.map((val, i) => {
      let ret = strings[i];
      if (Array.isArray(val)) {
        ret += val.reduce((ack, item) => ack += (typeof item === "string" ? item.trim() : item) + "\n", "");
      } else {
        if (val === void 0) {
          val = "";
        }
        ret += typeof val === "string" ? val.trim() : val;
      }
      count++;
      return ret;
    }).join("");
    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }
    return output.replace(tagSpaceRe, "><").trim();
  }
  static repeat(times) {
    return function(...args) {
      return TemplateHelper.tpl(...args).repeat(times);
    };
  }
  static loop(times) {
  }
};
TemplateHelper._$name = "TemplateHelper";
var TimeZoneOffsetInfo = class extends Array {
  constructor(timeZone, year) {
    super();
    this.timeZone = timeZone;
    this.year = year;
  }
};
var TimeZoneDate = class {
  constructor(asString, timeZone) {
    this.asString = asString;
    this.timeZone = timeZone;
    this.asArray = parseStringDate(asString);
  }
  get asLocalDate() {
    if (!this._asLocalDate) {
      this._asLocalDate = new Date(...this.asArray);
    }
    return this._asLocalDate;
  }
  get asTicksUtc() {
    if (!this._asTicksUtc) {
      this._asTicksUtc = new Date(Date.UTC(...this.asArray)).getTime();
    }
    return this._asTicksUtc;
  }
};
var toTimeZoneInternal = (date, timeZone) => {
  const tzDateString = date.toLocaleString("sv-SE", {
    timeZone
  });
  return new TimeZoneDate(tzDateString, timeZone);
};
var getOffsetUtc = (ticks, timeZone) => {
  const {
    asTicksUtc,
    asString
  } = toTimeZoneInternal(new Date(ticks), timeZone);
  return {
    offset: (ticks - asTicksUtc) / 6e4,
    tzTicksUtc: asTicksUtc,
    tzString: asString
  };
};
var parseStringDate = (stringDate) => {
  const parsed = stringDate.split(/[\s-:]/).map((i) => i * 1);
  parsed[1] -= 1;
  return parsed;
};
var min = -6e4;
var hour = 36e5;
var day = -864e5;
var month = 2592e6;
var findOffsetDates = (timeZone, year) => {
  const cached = offsetDateCache.get(timeZone, year);
  if (cached) {
    return cached;
  }
  const offsets = new TimeZoneOffsetInfo(timeZone, year), startUtcTicks = new Date(Date.UTC(year, 0, 1)).getTime();
  let ticks = startUtcTicks, incr = month, monthIndex = 0, previousOffset = [], currentOffset = null, tzTicksUtc, tzString, offset, done;
  while (!done) {
    ({
      offset,
      tzTicksUtc,
      tzString
    } = getOffsetUtc(ticks, timeZone));
    if (currentOffset == null) {
      currentOffset = offset;
      offsets.push({
        offset
      });
    } else if (incr > 0 && offset !== currentOffset) {
      incr = incr === month ? day : min;
    } else if (incr < 0 && offset === currentOffset) {
      if (incr === day) {
        incr = hour;
      } else {
        if (offsets.length === 1) {
          offsets.push(previousOffset);
          currentOffset = previousOffset.offset;
        } else {
          offsets[0].startTicks = previousOffset.startTicks;
          offsets[0].startDateString = previousOffset.startDateString;
          done = true;
        }
        incr = month;
      }
    }
    previousOffset = {
      offset,
      startDateString: tzString,
      startTicks: tzTicksUtc
    };
    if (incr === month) {
      ticks = startUtcTicks;
      ticks += monthIndex * month;
      monthIndex += 1;
    }
    ticks += incr;
    if (monthIndex > 11) {
      done = true;
    }
  }
  offsetDateCache.set(offsets);
  return offsets;
};
var offsetDateCache = {
  _cache: {},
  get(timeZone, year) {
    var _this$_cache$timeZone;
    return (_this$_cache$timeZone = this._cache[timeZone]) === null || _this$_cache$timeZone === void 0 ? void 0 : _this$_cache$timeZone[year];
  },
  set(offsetInfo) {
    const {
      timeZone
    } = offsetInfo, {
      _cache
    } = this;
    if (!_cache[timeZone]) {
      _cache[timeZone] = {};
    }
    _cache[timeZone][offsetInfo.year] = offsetInfo;
  }
};
var TimeZoneHelper = class {
  static get $name() {
    return "TimeZoneHelper";
  }
  static toTimeZone(date, timeZone) {
    if (typeof timeZone === "number") {
      return this.toUtcOffset(date, timeZone);
    }
    const tzDate = toTimeZoneInternal(date, timeZone);
    if (tzDate.asArray[3] !== tzDate.asLocalDate.getHours()) {
      console.error("Incorrect transformation due to local dst");
    }
    return tzDate.asLocalDate;
  }
  static fromTimeZone(date, timeZone) {
    if (typeof timeZone === "number") {
      return this.fromUtcOffset(date, timeZone);
    }
    const dateArr = this.dateAsArray(date), offsetDates = findOffsetDates(timeZone, date.getUTCFullYear());
    let useOffset = offsetDates[0].offset;
    if (offsetDates.length === 2) {
      const utcTicks = Date.UTC(...dateArr);
      if (utcTicks >= offsetDates[1].startTicks && utcTicks < offsetDates[0].startTicks) {
        useOffset = offsetDates[1].offset;
      }
    }
    dateArr[4] += useOffset;
    return new Date(Date.UTC(...dateArr));
  }
  static toUtcOffset(date, utcOffset) {
    const offset = date.getTimezoneOffset() + utcOffset;
    return new Date(date.getTime() + offset * 60 * 1e3);
  }
  static fromUtcOffset(date, utcOffset) {
    const offset = -date.getTimezoneOffset() - utcOffset;
    return new Date(date.getTime() + offset * 60 * 1e3);
  }
  static dateAsArray(date) {
    return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];
  }
};
TimeZoneHelper._$name = "TimeZoneHelper";
var Toast = class extends Widget {
  static get $name() {
    return "Toast";
  }
  static get type() {
    return "toast";
  }
  static get configurable() {
    return {
      testConfig: {
        destroyTimeout: 1,
        timeout: 100
      },
      floating: true,
      timeout: 2500,
      autoDestroy: null,
      destroyTimeout: 200,
      showProgress: true,
      color: null,
      bottomMargin: 20
    };
  }
  compose() {
    const {
      appendTo,
      color,
      html,
      showProgress,
      style,
      timeout
    } = this;
    return {
      parent: appendTo || this.floatRoot,
      class: _objectSpread2(_objectSpread2({}, DomClassList.normalize(color, "object")), {}, {
        "b-toast-hide": 1
      }),
      html,
      style,
      children: {
        progressElement: showProgress && {
          style: `animation-duration:${timeout / 1e3}s;`,
          class: {
            "b-toast-progress": 1
          }
        }
      },
      listeners: {
        click: "hide"
      }
    };
  }
  doDestroy() {
    this.untoast();
    super.doDestroy();
  }
  get nextBottom() {
    const {
      bottomMargin,
      element
    } = this;
    return parseInt(element.style.bottom, 10) + element.offsetHeight + bottomMargin;
  }
  async show() {
    await super.show(...arguments);
    const me = this, {
      element
    } = me, {
      toasts
    } = Toast;
    if (!toasts.includes(me)) {
      var _toasts$0$nextBottom, _toasts$;
      element.style.bottom = ((_toasts$0$nextBottom = (_toasts$ = toasts[0]) === null || _toasts$ === void 0 ? void 0 : _toasts$.nextBottom) !== null && _toasts$0$nextBottom !== void 0 ? _toasts$0$nextBottom : me.bottomMargin) + "px";
      toasts.unshift(me);
      element.getBoundingClientRect();
      element.classList.remove("b-toast-hide");
      if (me.timeout > 0) {
        me.hideTimeout = me.setTimeout("hide", me.timeout);
      }
    }
  }
  async hide() {
    const me = this;
    me.untoast();
    me.element.classList.add("b-toast-hide");
    if (me.autoDestroy && !me.destroyTimer) {
      me.destroyTimer = me.setTimeout("destroy", me.destroyTimeout);
    }
  }
  untoast() {
    const {
      toasts
    } = Toast;
    if (toasts.includes(this)) {
      toasts.splice(toasts.indexOf(this), 1);
    }
  }
  static hideAll() {
    Toast.toasts.slice().reverse().forEach((toast) => toast.hide());
  }
  static show(config) {
    const toast = Toast.new({
      autoDestroy: true,
      rootElement: document.body
    }, typeof config === "string" ? {
      html: config
    } : config);
    toast.show();
    return toast;
  }
};
Toast.toasts = [];
Toast.initClass();
Toast._$name = "Toast";
var WidgetHelper = class {
  static getById(id) {
    return Widget.getById(id);
  }
  static fromElement(element, type, limit) {
    return Widget.fromElement(element, type, limit);
  }
  static createWidget(config = {}) {
    return config.isWidget ? config : Widget.create(config);
  }
  static append(widget, config) {
    widget = Array.isArray(widget) && widget || [widget];
    if (config instanceof HTMLElement || typeof config === "string") {
      config = {
        appendTo: config
      };
    }
    if (config.insertFirst) {
      const target = typeof config.insertFirst === "string" ? document.getElementById(config.insertFirst) : config.insertFirst;
      if (target.firstChild) {
        config.insertBefore = target.firstChild;
      } else {
        config.appendTo = target;
      }
    }
    return widget.map((item) => Widget.create(ObjectHelper.assign({}, config || {}, item)));
  }
  static openPopup(element, config) {
    return Widget.create(ObjectHelper.assign({
      forElement: element
    }, typeof config === "string" ? {
      html: config
    } : config), "popup");
  }
  static showContextMenu(element, config) {
    const me = this;
    if (me.currentContextMenu) {
      me.currentContextMenu.destroy();
    }
    if (element instanceof HTMLElement) {
      config.forElement = element;
    } else if (Array.isArray(element)) {
      config.forElement = {
        target: new Point(...element)
      };
    } else if (element instanceof Point) {
      config.forElement = {
        target: element
      };
    }
    me.currentContextMenu = Widget.create(config, "menu");
    me.currentContextMenu.ion({
      destroy: () => {
        me.currentContextMenu = null;
      }
    });
    return me.currentContextMenu;
  }
  static attachTooltip(element, configOrText) {
    return Widget.attachTooltip(element, configOrText);
  }
  static hasTooltipAttached(element) {
    return Widget.resolveType("tooltip").hasTooltipAttached(element);
  }
  static destroyTooltipAttached(element) {
    return Widget.resolveType("tooltip").destroyTooltipAttached(element);
  }
  static mask(element, msg = "Loading") {
    if (element) {
      if (element instanceof HTMLElement) {
        element = {
          target: element,
          text: msg
        };
      }
      return Mask.mask(element, element.target);
    }
  }
  static unmask(element, close = true) {
    if (element.mask) {
      if (close) {
        element.mask.close();
      } else {
        element.mask.hide();
      }
    }
  }
  static toast(msg) {
    return Toast.show(msg);
  }
};
WidgetHelper._$name = "WidgetHelper";
var XMLHelper = class {
  static convertFromObject(obj, options = {}) {
    Objects.assignIf(options, {
      rootName: "root",
      elementName: "element",
      includeHeader: true,
      rootElementForArray: true
    });
    const {
      rootName,
      elementName,
      includeHeader,
      rootElementForArray
    } = options;
    let {
      xmlns
    } = options;
    xmlns = xmlns ? ` xmlns="${xmlns}"` : "";
    const header = includeHeader ? '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' : "";
    const converter = (o) => {
      const xmlItems = [];
      for (const key in o) {
        const item = o[key];
        if (Array.isArray(item)) {
          if (rootElementForArray) {
            xmlItems.push(`<${key}>`);
          }
          for (const subItem of item) {
            if (elementName.length) {
              xmlItems.push(`<${elementName}>`);
            } else {
              xmlItems.push(`<${key}>`);
            }
            xmlItems.push(converter(subItem));
            if (elementName.length) {
              xmlItems.push(`</${elementName}>`);
            } else {
              xmlItems.push(`</${key}>`);
            }
          }
          if (rootElementForArray) {
            xmlItems.push(`</${key}>`);
          }
        } else if (Objects.isObject(item)) {
          xmlItems.push(`<${key}>${converter(item)}</${key}>`);
        } else {
          if (item == null) {
            xmlItems.push(`<${key}/>`);
          } else {
            xmlItems.push(`<${key}>${StringHelper.encodeHtml(item)}</${key}>`);
          }
        }
      }
      return xmlItems.join("");
    };
    return `${header}<${rootName}${xmlns}>${converter(obj)}</${rootName}>`;
  }
};
XMLHelper._$name = "XMLHelper";
var RandomGenerator = class {
  constructor() {
    this.random100 = [46, 2, 36, 46, 54, 59, 18, 20, 71, 55, 88, 98, 13, 61, 61, 40, 2, 15, 3, 32, 51, 45, 64, 25, 81, 85, 54, 13, 57, 49, 64, 22, 81, 94, 0, 62, 17, 7, 11, 2, 33, 99, 85, 26, 83, 83, 96, 26, 20, 89, 91, 38, 26, 13, 11, 79, 32, 30, 5, 51, 70, 7, 5, 56, 58, 77, 37, 89, 40, 80, 78, 59, 26, 36, 8, 51, 60, 23, 86, 5, 11, 96, 64, 94, 87, 64, 4, 78, 17, 85, 35, 0, 90, 86, 23, 55, 53, 9, 35, 59, 29, 2, 64, 42, 8, 49, 43, 73, 6, 53, 38, 9, 39, 31, 32, 40, 49, 13, 78, 68, 20, 99, 24, 78, 35, 91, 73, 46, 67, 76, 89, 69, 30, 69, 25, 3, 4, 55, 1, 65, 66, 76, 83, 19, 67, 1, 95, 24, 54, 45, 56, 40, 67, 92, 72, 4, 69, 8, 47, 50, 27, 2, 38, 9, 14, 83, 12, 14, 62, 95, 22, 47, 35, 18, 38, 14, 86, 64, 68, 61, 52, 69, 39, 93, 20, 73, 32, 52, 74, 6, 56, 68, 99, 29, 24, 92, 40, 67, 6, 72, 31, 41, 91, 53, 80, 55, 33, 97, 97, 99, 18, 20, 5, 27, 82, 84, 61, 78, 27, 67, 7, 42, 75, 95, 91, 25, 63, 21, 70, 36, 46, 0, 1, 45, 84, 6, 86, 15, 10, 62, 96, 94, 10, 23, 93, 83, 94, 47, 5, 29, 29, 52, 51, 37, 77, 96, 43, 72, 43, 14, 54, 14, 72, 52, 4, 39, 15, 26, 68, 28, 25, 76, 60, 50, 22, 40, 72, 74, 68, 58, 8, 48, 40, 62, 52, 24, 9, 26, 47, 44, 49, 96, 7, 77, 90, 45, 76, 47, 5, 86, 1, 36, 18, 42, 19, 90, 34, 23, 70, 32, 69, 79, 0, 99, 57, 80, 72, 21, 19, 72, 85, 68, 4, 40, 86, 62, 0, 63, 4, 11, 69, 31, 78, 31, 21, 78, 29, 84, 13, 53, 57, 10, 26, 50, 24, 30, 90, 42, 51, 96, 93, 21, 99, 23, 81, 0, 89, 43, 86, 63, 93, 19, 54, 71, 92, 36, 4, 95, 37, 99, 60, 29, 23, 50, 68, 95, 57, 95, 77, 53, 99, 78, 75, 12, 92, 47, 23, 14, 0, 41, 98, 11, 34, 64, 26, 90, 50, 23, 38, 31, 74, 76, 16, 76, 66, 23, 22, 72, 48, 50, 20, 36, 37, 58, 5, 43, 49, 64, 81, 30, 8, 21, 98, 75, 60, 17, 50, 42, 27, 38, 90, 74, 45, 68, 67, 27, 31, 15, 58, 76, 41, 99, 23, 98, 53, 98, 56, 19, 79, 2, 4, 38, 96, 24, 65, 51, 43, 42, 41, 60, 46, 7, 90, 65, 3, 27, 63, 99, 51, 44, 86, 1, 54, 40, 15, 74, 3, 81, 51, 63, 87, 79, 84, 72, 22, 38, 96, 95, 33, 41, 21, 99, 21, 69, 7, 49, 40, 52, 41, 6, 91, 19, 76, 40, 54, 17, 33, 11, 11, 0, 1, 32, 94, 33, 13, 18, 45, 7, 85, 61, 42, 54, 45, 72, 78, 96, 17, 9, 80, 87, 41, 96, 66, 0, 8, 59, 18, 21, 2, 28, 64, 75, 97, 32, 80, 86, 97, 97, 55, 2, 73, 75, 11, 89, 67, 58, 70, 76, 12, 46, 64, 17, 22, 97, 25, 35, 93, 57, 82, 46, 57, 61, 31, 74, 27, 4, 32, 85, 53, 86, 53, 53, 42, 5, 28, 50, 65, 63, 70, 61, 73, 37, 13, 80, 7, 34, 22, 3, 26, 6, 62, 78, 12, 56, 87, 41, 58, 64, 31, 27, 45, 35, 18, 66, 62, 43, 89, 69, 94, 93, 33, 74, 2, 43, 85, 37, 82, 41, 74, 9, 15, 44, 33, 42, 65, 19, 1, 49, 78, 12, 29, 9, 78, 7, 55, 12, 45, 40, 33, 16, 86, 14, 52, 16, 73, 76, 0, 98, 75, 91, 78, 46, 99, 95, 90, 69, 78, 45, 62, 55, 37, 88, 49, 77, 27, 83, 38, 73, 39, 1, 75, 40, 65, 83, 54, 95, 7, 73, 4, 30, 26, 36, 89, 21, 5, 95, 11, 14, 87, 45, 36, 21, 77, 55, 5, 66, 51, 98, 48, 62, 74, 58, 23, 82, 30, 28, 19, 53, 89, 76, 98, 8, 34, 70, 28, 54, 16, 52, 35, 93, 54, 54, 72, 49, 18, 93, 72, 90, 71, 73, 15, 60, 38, 80, 76, 53, 70, 39, 69, 25, 5, 31, 61, 46, 6, 54, 34, 31, 52, 33, 36, 79, 76, 44, 29, 28, 38, 1, 66, 2, 90, 91, 1, 76, 78, 31, 55, 37, 71, 2, 3, 38, 85, 0, 95, 42, 2, 39, 57, 87, 61, 77, 98, 2, 24, 80, 48, 27, 47, 71, 15, 7, 49, 60, 86, 3, 2, 29, 38, 54, 36, 59, 83, 27, 47, 9, 36, 42, 8, 73, 85, 9, 16, 73, 60, 39, 12, 43, 25, 23, 29, 28, 47, 40, 77, 20, 89, 22, 30, 41, 59, 96, 19, 56, 20, 76, 73, 39, 46, 72, 40, 47, 37, 52, 29, 79, 37, 39, 50, 41, 87, 66, 17, 75, 31, 45, 26, 88, 70, 11, 90, 40, 74, 9, 32, 65, 72, 61, 6, 93, 54, 15, 84, 22, 99, 47, 10, 96, 4, 84, 19, 85, 73, 45, 25, 16, 8, 94, 99, 39, 28, 26, 68, 87, 48, 1, 65, 86, 46, 86, 7, 60, 82, 45, 75, 38, 56, 41, 35, 30, 86, 91, 97, 85, 45, 5, 14, 69, 85, 96, 37, 18, 26, 16, 38, 16, 1, 44, 94, 85, 58, 60, 20, 5, 47, 52, 41, 50, 71, 43, 42, 67, 64, 38, 65, 83, 99, 78, 96, 33, 20, 98, 24, 6, 2, 25, 16, 16, 44, 63, 24, 68, 56, 49, 91, 15, 59, 99, 27, 43, 34, 28, 36, 45, 1, 10, 19, 54, 26, 75, 17, 88, 96, 63, 24, 71, 93, 72, 97, 66, 87, 18, 86];
    this.randomCache = {};
    this.rndIndex = 0;
  }
  nextRandom(max) {
    const {
      randomCache
    } = this;
    let randomNumbers;
    if (randomCache[max]) {
      randomNumbers = randomCache[max];
    } else {
      randomNumbers = this.random100.filter((num) => num < max);
      randomCache[max] = randomNumbers;
    }
    return randomNumbers[this.rndIndex++ % randomNumbers.length];
  }
  reset() {
    this.rndIndex = 0;
  }
  fromArray(array) {
    return array[this.nextRandom(array.length)];
  }
  randomArray(array, maxLength) {
    const result = [], length = this.nextRandom(maxLength + 1), used = {};
    for (let i = 0, index = this.nextRandom(array.length); i < length; i++) {
      while (used[index]) {
        index = this.nextRandom(array.length);
      }
      used[index] = true;
      result.push(array[index]);
    }
    return result;
  }
};
RandomGenerator._$name = "RandomGenerator";
var lorem = ["Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.", "Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.", "Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.", "Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.", "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo.", "Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui atione voluptatem sequi nesciunt.", "Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem.", "Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur?", "Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"];
var DataGenerator = class {
  static reset() {
    this.rnd.reset();
    this.rndTime.reset();
    this.rndRating.reset();
  }
  static *generate(count, randomHeight = false, initialId = 1) {
    let addSkills, rowCallback;
    if (typeof count === "object") {
      var _count$initialId;
      randomHeight = count.randomHeight;
      initialId = (_count$initialId = count.initialId) !== null && _count$initialId !== void 0 ? _count$initialId : 1;
      addSkills = count.addSkills;
      rowCallback = count.rowCallback;
      count = count.count;
    }
    const me = this, {
      rnd,
      rndTime,
      rndRating,
      rndText,
      firstNames,
      surNames,
      teams,
      foods,
      colors,
      cities,
      skills
    } = me;
    for (let i = 0; i < count; i++) {
      var _rowCallback;
      const firstName = rnd.fromArray(firstNames), surName = rnd.fromArray(surNames), name = `${firstName} ${String.fromCharCode(65 + i % 25)} ${surName}`, startDay = rnd.nextRandom(60) + 1, start = new Date(2019, 0, startDay), finish = new Date(2019, 0, startDay + rnd.nextRandom(30) + 2), row = {
        id: initialId > -1 ? i + initialId : void 0,
        title: "Row " + i,
        name,
        firstName,
        surName,
        city: rnd.fromArray(cities),
        team: rnd.fromArray(cities) + " " + rnd.fromArray(teams),
        age: 10 + rnd.nextRandom(80),
        food: rnd.fromArray(foods),
        color: rnd.fromArray(colors),
        score: rnd.nextRandom(100) * 10,
        rank: rnd.nextRandom(100) + 1,
        start,
        finish,
        time: DateHelper.getTime(rndTime.nextRandom(24), rndTime.nextRandom(12) * 5),
        percent: rnd.nextRandom(100),
        done: rnd.nextRandom(100) < 50,
        rating: rndRating.nextRandom(5),
        relatedTo: Math.min(count - 1, i + initialId + rnd.nextRandom(10)),
        notes: lorem[rndText.nextRandom(7) + 1]
      };
      if (addSkills) {
        row.skills = rnd.randomArray(skills, 7);
      }
      const additionalData = (_rowCallback = rowCallback) === null || _rowCallback === void 0 ? void 0 : _rowCallback(row);
      additionalData && Object.assign(row, additionalData);
      if (randomHeight) {
        row.rowHeight = rnd.nextRandom(randomHeight === true ? 20 : randomHeight) * 5 + 20;
      }
      yield row;
    }
  }
  static generateData(count, randomHeight = false, initialId = 1, reset = true) {
    let args = count;
    if (typeof count !== "object") {
      args = {
        count,
        randomHeight,
        initialId,
        reset
      };
    }
    args.reset !== false && this.reset();
    if (DataGenerator.overrideRowCount) {
      args.count = DataGenerator.overrideRowCount;
    }
    const rows = [], generator = this.generate(args);
    for (let i = 0; i < args.count; i++) {
      rows.push(generator.next().value);
    }
    return rows;
  }
  static generateEvents({
    viewStartDate,
    viewEndDate,
    nbrResources = 50,
    nbrEvents = 5,
    dependencies,
    tickUnit = "days",
    minDuration = 2,
    maxDuration = 10
  }) {
    const resources = this.generateData(nbrResources), events = [];
    dependencies = [];
    for (let i = 0; i < nbrResources; i++) {
      for (let j = 0; j < nbrEvents; j++) {
        const visibleDuration = DateHelper.getDurationInUnit(viewStartDate, viewEndDate, tickUnit), startDate = DateHelper.add(viewStartDate, Math.round(Math.random() * 0.9 * visibleDuration), tickUnit), duration = Math.round(Math.random() * (maxDuration - minDuration)) + minDuration, endDate = DateHelper.add(startDate, duration, "days"), eventId = events.length + 1;
        events.push({
          id: eventId,
          name: this.tasks[(i + j) % (this.tasks.length - 1)],
          startDate,
          duration,
          endDate,
          resourceId: i
        });
        if (dependencies && i > 0) {
          dependencies.push({
            id: dependencies.length + 1,
            from: eventId - 1,
            to: eventId
          });
        }
      }
    }
    return {
      resources,
      events,
      dependencies
    };
  }
  static generateRow() {
    return DataGenerator.generateData(1, false, -1, false)[0];
  }
};
Object.assign(DataGenerator, {
  rnd: new RandomGenerator(),
  rndTime: new RandomGenerator(),
  rndRating: new RandomGenerator(),
  rndText: new RandomGenerator(),
  cities: ["Stockholm", "Barcelona", "Paris", "Dubai", "New York", "San Francisco", "Washington", "Moscow"],
  firstNames: ["Mike", "Linda", "Don", "Karen", "Doug", "Jenny", "Daniel", "Melissa", "John", "Jane", "Theo", "Lisa", "Adam", "Mary", "Barbara", "James", "David"],
  surNames: ["McGregor", "Ewans", "Scott", "Smith", "Johnson", "Adams", "Williams", "Brown", "Jones", "Miller", "Davis", "More", "Wilson", "Taylor", "Anderson", "Thomas", "Jackson"],
  teams: ["Lions", "Eagles", "Tigers", "Horses", "Dogs", "Cats", "Panthers", "Rats", "Ducks", "Cougars", "Hens", "Roosters"],
  foods: ["Pancake", "Burger", "Fish n chips", "Carbonara", "Taco", "Salad", "Bolognese", "Mac n cheese", "Waffles"],
  colors: ["Blue", "Green", "Red", "Yellow", "Pink", "Purple", "Orange", "Teal", "Black"],
  skills: ["JavaScript", "CSS", "TypeScript", "React", "Vue", "Angular", "Java", "PHP", "Python", "C#", "C++", "BASIC", "COBOL", "FORTRAN", "PASCAL", "SQL"],
  tasks: ["Meetings", "Documentation", "Email communication", "Project management", "Budgeting", "Marketing and advertising", "Customer service", "Research and analysis", "Data entry", "IT support", "Employee management", "Sales and business development", "Event planning", "Graphic design", "Writing and editing", "Presentation", "Travel arrangements and expense management", "Training and development", "Quality assurance", "Customer support", "Technical writing", "Social media management", "Translation", "Legal research", "Data analysis and visualization", "Video editing and production", "Network admin", "Content creation", "Market research", "Public relations", "Teaching and training", "Recruiting", "Product development"]
});
DataGenerator._$name = "DataGenerator";
var knownProps = ["action", "target", "to", "deltaX", "deltaY", "x", "y", "text"];
var DemoBot = class extends Events(Delayable()) {
  static get defaultConfig() {
    return {
      repeat: true,
      outerElement: document.body,
      callOnFunctions: true
    };
  }
  construct(config) {
    super.construct(config);
    const me = this;
    if (me.widget) {
      me.outerElement = me.widget.element;
      me.widget.playingDemo = true;
    }
    EventHelper.playingDemo = true;
    Object.assign(me, {
      prevTarget: null,
      currentStep: 0,
      mouse: DomHelper.createElement({
        parent: me.outerElement,
        tag: "div",
        className: "simulated-mouse"
      }),
      timeoutId: null,
      innerIntervalId: null,
      mouseOutElements: []
    });
    me.intervalId = me.setInterval(me.nextStep.bind(me), 1e3);
    me.outerElement.classList.add("b-playing-demo");
    me.outerElement.addEventListener("click", (event) => {
      if (event.isTrusted) {
        me.abort();
      }
    });
  }
  doDestroy() {
    this.abort();
  }
  abort(atEnd = false) {
    const me = this;
    me.mouse.style.top = "-100px";
    me.clearInterval(me.intervalId);
    me.timeoutId && me.clearTimeout(me.timeoutId);
    me.innerIntervalId && me.clearInterval(me.innerIntervalId);
    me.outerElement.classList.remove("b-playing-demo");
    if (me.widget) {
      me.widget.playingDemo = false;
    }
    EventHelper.playingDemo = false;
    me.trigger(atEnd ? "done" : "abort");
  }
  triggerEvent(element, type, data) {
    if (!element)
      return null;
    let event;
    if (type.startsWith("mouse")) {
      const box = this.mouse.getBoundingClientRect();
      event = new MouseEvent(type, Object.assign({
        view: globalThis,
        bubbles: true,
        cancelable: true,
        clientX: box.left,
        clientY: box.top
      }, data || {}));
    } else {
      event = document.createEvent("Event");
      event.initEvent(type, true, false);
    }
    element.dispatchEvent(event);
    return event;
  }
  handleMouseMove(step, target) {
    const me = this, mouse = me.mouse;
    mouse.classList.add("quick");
    if (me.mouseDown)
      mouse.classList.add("drag");
    const mouseBox = Rectangle.from(mouse, me.outerElement), x = mouseBox.x, y = mouseBox.y;
    let deltaX = 0, deltaY = 0;
    if (step.to) {
      if (typeof step.to === "string") {
        const toElement = me.outerElement.querySelector(step.to);
        if (toElement) {
          const rect = Rectangle.from(toElement, me.outerElement), toX = rect.x + rect.width / 2, toY = rect.y + rect.height / 2;
          deltaX = (toX - x) / 10;
          deltaY = (toY - y) / 10;
        }
      } else if (step.to.x) {
        deltaX = (step.to.x - x) / 10;
      } else {
        deltaX = step.to[0] / 10;
        deltaY = step.to[1] / 10;
      }
    } else if (step.deltaX) {
      deltaX = step.deltaX / 10;
    } else if (step.x) {
      deltaX = (step.x - x) / 10;
    }
    if (step.deltaY) {
      deltaY = step.deltaY / 10;
    }
    let i = 0;
    me.innerIntervalId = me.setInterval(() => {
      if (me.shouldPause) {
        return;
      }
      if (i++ === 9) {
        clearInterval(me.innerIntervalId);
        if (step.then) {
          step.then();
        }
      }
      const mouseX = x + deltaX * i, mouseY = y + deltaY * i;
      mouse.style.left = mouseX + "px";
      mouse.style.top = mouseY + "px";
      const mouseBounds = mouse.getBoundingClientRect(), clientX = mouseBounds.left, clientY = mouseBounds.top, eventTarget = DomHelper.elementFromPoint(clientX, clientY);
      if (eventTarget !== me.prevTarget) {
        if (me.prevTarget) {
          me.mouseOutElements.push(me.prevTarget);
          if (!DomHelper.isDescendant(me.mouseOutElements[0], eventTarget)) {
            me.mouseOutElements.forEach((element) => me.triggerEvent(element, "mouseout"));
            me.mouseOutElements.length = 0;
          }
        }
        me.prevTarget = eventTarget;
        me.triggerEvent(eventTarget, "mouseover");
      }
      me.triggerEvent(eventTarget, step.action, {
        clientX,
        clientY
      });
    }, 50);
  }
  getTarget(step) {
    const me = this, target = step.target;
    if (!target) {
      return me.prevTarget || me.outerElement;
    }
    if (typeof target === "function") {
      return target(step);
    }
    return document.querySelector(target);
  }
  normalizeStep(step) {
    if (step.action) {
      if (typeof step.action === "function") {
        return step.action(step);
      }
      return step;
    }
    if (typeof step === "function") {
      step();
      return step;
    }
    for (const prop in step) {
      if (Object.hasOwnProperty.call(step, prop) && !knownProps.includes(prop)) {
        step.action = prop.toLowerCase();
        step.to = step[prop];
      }
    }
    if (!step.target && (typeof step.to === "string" || typeof step.to === "function"))
      step.target = step.to;
    return step;
  }
  get isScrolling() {
    const me = this, box = me.outerElement.getBoundingClientRect(), scrolled = me.lastTop && box.top !== me.lastTop;
    me.lastTop = box.top;
    return scrolled;
  }
  get isInView() {
    const box = this.outerElement.getBoundingClientRect();
    return box.top < globalThis.innerHeight && box.bottom > 0;
  }
  get shouldPause() {
    return !this.isInView || this.isScrolling || document.hidden || !document.hasFocus();
  }
  nextStep() {
    const me = this;
    if (me.shouldPause) {
      return;
    }
    if (me.currentStep === me.steps.length) {
      if (me.repeat) {
        me.currentStep = 0;
      } else {
        return me.abort(true);
      }
    }
    if (me.currentStep === 0) {
      me.trigger("initialize");
    }
    const mouse = me.mouse, step = me.normalizeStep(me.steps[me.currentStep++]), target = me.getTarget(step), action = step.action;
    if (target && action) {
      mouse.className = "simulated-mouse";
      if (action === "mousemove") {
        me.handleMouseMove(step, target);
      } else {
        if (target !== me.prevTarget) {
          const rect = Rectangle.from(target, me.outerElement);
          mouse.style.left = rect.x + rect.width / 2 + "px";
          mouse.style.top = rect.y + rect.height / 2 + "px";
        }
        if (action === "mousedown") {
          me.mouseDown = true;
        }
        if (action === "mouseup") {
          me.mouseDown = false;
        }
        me.timeoutId = me.setTimeout(() => {
          me.prevTarget = target;
          mouse.classList.add(action);
          if (action === "type") {
            const field = Widget.fromElement(target), parts = step.text.split("|");
            field.value = parts[parts.length === 1 || field.value != parts[0] ? 0 : 1];
          } else {
            me.triggerEvent(target, action);
          }
        }, action === "type" ? 100 : 550);
      }
    }
  }
};
DemoBot._$name = "DemoBot";
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var cacheKey = null;
function setParser(me, parser) {
  Object.defineProperty(me, "parser", {
    value: parser
  });
  return parser;
}
var Default = class {
  constructor(formatter) {
    this.formatter = formatter;
  }
  format(value) {
    return this.formatter.defaultFormat(value);
  }
  parse(value, strict) {
    return this.formatter.defaultParse(value, strict);
  }
  resolvedOptions() {
    return null;
  }
};
var Formatter = class {
  static get(format) {
    if (format == null) {
      return this.NULL;
    }
    if (format instanceof this) {
      return format;
    }
    const key = typeof format === "string" ? format : JSON.stringify(format), cache = this.cache;
    let fmt = cache.get(key);
    if (!fmt) {
      cacheKey = key;
      fmt = new this(format);
      cache.set(key, fmt);
    }
    return fmt;
  }
  static get cache() {
    return hasOwnProperty$1.call(this, "_cache") && this._cache || (this._cache = /* @__PURE__ */ new Map());
  }
  static get NULL() {
    return hasOwnProperty$1.call(this, "_null") ? this._null : this._null = new this(null);
  }
  constructor(config) {
    const me = this;
    me.cacheKey = cacheKey;
    cacheKey = null;
    me.initialize();
    if (config === null) {
      me.formatter = new Default(me);
    } else {
      me.configure(config);
      for (const [key, value] of Object.entries(me.resolvedOptions())) {
        if (value != null && key in me.defaults) {
          me[key] = value;
        }
      }
    }
  }
  get parser() {
    return setParser(this, new this.constructor.Parser(this));
  }
  defaultFormat(value) {
    return value == null ? value : String(value);
  }
  defaultParse(value) {
    return value;
  }
  format(value) {
    return value == null ? value : this.formatter.format(value);
  }
  parse(value, strict) {
    return value == null ? value : this.parser.parse(value, strict);
  }
  parseStrict(value) {
    return this.parse(value, true);
  }
  resolvedOptions() {
    return this.formatter.resolvedOptions();
  }
};
Formatter._$name = "Formatter";
var Navigator = class extends Base.mixin(Events, Factoryable) {
  static get $name() {
    return "Navigator";
  }
  static get type() {
    return "navigator";
  }
  static get configurable() {
    return {
      ownerCmp: null,
      itemsTabbable: null,
      target: null,
      keyEventTarget: null,
      processEvent: null,
      itemSelector: null,
      activeItem: null,
      focusCls: "b-active",
      keys: null,
      allowCtrlKey: null,
      allowShiftKey: null,
      scrollDuration: 50,
      disabled: null,
      datasetIdProperty: "id",
      testConfig: {
        scrollDuration: 1
      }
    };
  }
  static get factoryable() {
    return {
      defaultType: "navigator"
    };
  }
  get activeItem() {
    const {
      _activeItem
    } = this;
    if (this.target.contains(_activeItem)) {
      return _activeItem;
    }
    this._activeItem = null;
  }
  updateOwnerCmp(ownerCmp) {
    if (!this.itemSelector) {
      this.itemSelector = `.${this.ownerCmp.itemCls}`;
    }
    DomHelper.setAttributes(this.keyEventTarget, {
      "aria-activedescendant": `${this.owner.id}-active-descendant`
    });
  }
  set navigationEvent(navigationEvent) {
    const {
      owner
    } = this;
    this._navigationEvent = owner.navigationEvent = navigationEvent;
    if (navigationEvent) {
      Promise.resolve(1).then(() => this.navigationEvent = null);
    }
  }
  get navigationEvent() {
    return this._navigationEvent;
  }
  static getComposedKeyName(keyEvent) {
    const keyName = (keyEvent.key || "").trim() || keyEvent.code;
    return `${keyEvent.ctrlKey ? "CTRL+" : ""}${keyEvent.shiftKey ? "SHIFT+" : ""}${keyEvent.altKey ? "ALT+" : ""}${keyName}`;
  }
  onKeyDown(keyEvent) {
    const me = this, {
      ownerCmp,
      itemSelector,
      activeItem,
      itemsTabbable
    } = me, {
      target
    } = keyEvent, firstItem = me.target.querySelector(itemSelector), keyName = (keyEvent.key || "").trim() || keyEvent.code, composedKeyName = me.constructor.getComposedKeyName(keyEvent), validTarget = target.matches(itemSelector) || target === me.keyEventTarget;
    if (!me.disabled && me.processEvent) {
      keyEvent = me.processEvent.call(ownerCmp, keyEvent);
    }
    if (keyEvent && !me.disabled && firstItem && me.target.offsetParent && validTarget) {
      if (!itemsTabbable) {
        if (me.inlineFlow == null) {
          const itemContainer = firstItem.parentNode, itemPositionStyle = DomHelper.getStyleValue(firstItem, "position"), itemDisplayStyle = DomHelper.getStyleValue(firstItem, "display"), itemFloatStyle = DomHelper.getStyleValue(firstItem, "float");
          me.inlineFlow = itemPositionStyle === "absolute" || itemDisplayStyle === "inline" || itemDisplayStyle === "inline-block" || itemFloatStyle === "left" || itemFloatStyle === "right" || DomHelper.getStyleValue(itemContainer, "display") === "flex" && DomHelper.getStyleValue(itemContainer, "flex-direction") === "row";
        }
        if (!me.prevKey) {
          if (me.inlineFlow) {
            me.prevKey = "ArrowLeft";
            me.nextKey = "ArrowRight";
          } else {
            me.prevKey = "ArrowUp";
            me.nextKey = "ArrowDown";
          }
        }
      }
      me.navigationEvent = keyEvent;
      if (activeItem) {
        switch (keyName) {
          case me.prevKey:
            if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
              return;
            }
            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }
            keyEvent.preventDefault();
            keyEvent.handled = true;
            me.navigatePrevious(keyEvent);
            break;
          case me.nextKey:
            if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
              return;
            }
            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }
            keyEvent.preventDefault();
            keyEvent.handled = true;
            me.navigateNext(keyEvent);
            break;
          default: {
            var _me$keys;
            const keyHandler = (_me$keys = me.keys) === null || _me$keys === void 0 ? void 0 : _me$keys[composedKeyName];
            if (keyHandler && !me.disabled) {
              if (me.callback(keyHandler, me.thisObj || ownerCmp, [keyEvent]) === false) {
                return;
              }
            } else if (ownerCmp.onInternalKeyDown) {
              ownerCmp.onInternalKeyDown(keyEvent);
            }
            if (DomHelper.getActiveElement(target) !== target) {
              keyEvent.preventDefault();
            }
            if (itemsTabbable) {
              return;
            }
          }
        }
      } else {
        if (itemsTabbable) {
          return;
        }
        if (keyName === me.nextKey || keyName === me.prevKey) {
          me.activeItem = me.getDefaultNavigationItem(keyEvent);
        }
      }
      if (me.activeItem !== activeItem) {
        me.triggerNavigate(keyEvent);
      }
    }
  }
  getDefaultNavigationItem(keyEvent) {
    const {
      target,
      itemSelector,
      prevKey,
      nextKey
    } = this;
    if (target.compareDocumentPosition(keyEvent.target) & 4 && keyEvent.key === prevKey) {
      return target.querySelector(`${itemSelector}:last-of-type`);
    }
    if (target.compareDocumentPosition(keyEvent.target) & 2 && keyEvent.key === nextKey) {
      return target.querySelector(`${itemSelector}`);
    }
  }
  navigatePrevious(keyEvent) {
    const me = this, previous = me.previous;
    keyEvent.preventDefault();
    if (previous) {
      me.ownerCmp.scrollable.scrollIntoView(previous, {
        animate: me.scrollDuration
      }).then(() => {
        me.activeItem = previous;
        me.triggerNavigate(keyEvent);
      });
    }
  }
  navigateNext(keyEvent) {
    const me = this, next = me.next;
    keyEvent.preventDefault();
    if (next) {
      me.ownerCmp.scrollable.scrollIntoView(next, {
        animate: me.scrollDuration
      }).then(() => {
        me.activeItem = next;
        me.triggerNavigate(keyEvent);
      });
    }
  }
  get owner() {
    return this.ownerCmp;
  }
  get previous() {
    return this.getAdjacent(-1);
  }
  get next() {
    return this.getAdjacent(1);
  }
  getAdjacent(direction = 1, from = this.activeItem) {
    const treeWalker = this.treeWalker;
    treeWalker.currentNode = from;
    treeWalker[direction < 0 ? "previousNode" : "nextNode"]();
    if (treeWalker.currentNode !== this.activeItem) {
      return treeWalker.currentNode;
    }
  }
  onTargetFocusIn(focusInEvent) {
    const me = this, {
      target,
      relatedTarget
    } = focusInEvent, {
      owner,
      itemsTabbable,
      skipScrollIntoView,
      previousActiveItem
    } = me;
    if (!target.matches(".b-focus-trap")) {
      if (target.matches(me.itemSelector)) {
        me.skipScrollIntoView = true;
        me.activeItem = target;
        me.skipScrollIntoView = skipScrollIntoView;
        if (me.activeItem && itemsTabbable) {
          me.triggerNavigate(focusInEvent);
        }
      } else if (target === me.target) {
        const fromWhere = relatedTarget ? target.compareDocumentPosition(relatedTarget) : 0;
        if (fromWhere & Node.DOCUMENT_POSITION_CONTAINED_BY) {
          var _owner$previousSiblin;
          (_owner$previousSiblin = owner.previousSibling) === null || _owner$previousSiblin === void 0 ? void 0 : _owner$previousSiblin.focus();
        } else {
          me.activeItem = previousActiveItem && me.target.contains(previousActiveItem) ? previousActiveItem : 0;
        }
      }
    }
  }
  onTargetFocusOut(focusOutEvent) {
    const me = this, {
      relatedTarget
    } = focusOutEvent;
    if (!(relatedTarget !== null && relatedTarget !== void 0 && relatedTarget.matches(".b-focus-trap"))) {
      if (!relatedTarget || !me.target.contains(relatedTarget) || !relatedTarget.matches(me.itemSelector)) {
        if (me.activeItem) {
          me.activeItem = null;
          if (me.itemsTabbable) {
            me.triggerNavigate(focusOutEvent);
          }
        }
      }
    }
  }
  onTargetMouseDown(mouseDownEvent) {
    const me = this, target = mouseDownEvent.target.closest(me.itemSelector);
    me.navigationEvent = mouseDownEvent;
    if (me.itemsTabbable) {
      if (target === me.activeItem) {
        me.triggerNavigate(mouseDownEvent);
      }
    } else if (me.ownerCmp.itemsFocusable === false) {
      me.onFocusGesture(mouseDownEvent);
    } else if (target) {
      mouseDownEvent.preventDefault();
      DomHelper.focusWithoutScrolling(target);
    }
  }
  onTargetClick(clickEvent) {
    var _me$navigationEvent;
    const me = this, {
      skipScrollIntoView
    } = me;
    if (me.skipNextClick || (_me$navigationEvent = me.navigationEvent) !== null && _me$navigationEvent !== void 0 && _me$navigationEvent.ignoreNavigation) {
      me.skipNextClick = false;
      return;
    }
    if (me.disabled) {
      return;
    }
    me.skipScrollIntoView = true;
    if (me.processEvent) {
      clickEvent = me.processEvent.call(me.ownerCmp, clickEvent);
    }
    if (clickEvent) {
      me.activeItem = clickEvent.target.closest(me.itemSelector);
      me.triggerNavigate(clickEvent);
    }
    me.skipScrollIntoView = skipScrollIntoView;
  }
  onFocusGesture(event) {
    if (event.target === this.ownerCmp.contentElement || event.target.closest(this.itemSelector) && this.ownerCmp.itemsFocusable === false) {
      event.preventDefault();
    }
  }
  acceptNode(node) {
    return node.offsetParent && node.matches && node.matches(this.itemSelector) ? DomHelper.NodeFilter.FILTER_ACCEPT : DomHelper.NodeFilter.FILTER_SKIP;
  }
  changeActiveItem(activeItem) {
    if (activeItem != null) {
      if (this.ownerCmp.getItem) {
        activeItem = this.ownerCmp.getItem(activeItem);
      }
    }
    return activeItem;
  }
  updateActiveItem(activeItem, oldActiveItem) {
    const me = this, {
      ownerCmp
    } = me, isActive = oldActiveItem && me.target.contains(oldActiveItem), needsFocus = activeItem && DomHelper.isFocusable(activeItem) && activeItem !== DomHelper.getActiveElement(activeItem);
    if (isActive) {
      me.previousActiveItem = oldActiveItem;
    }
    if (oldActiveItem) {
      oldActiveItem.classList.remove(me.focusCls);
      oldActiveItem.removeAttribute("id");
    }
    if (activeItem != null) {
      if (me.skipScrollIntoView) {
        if (needsFocus) {
          DomHelper.focusWithoutScrolling(activeItem);
        }
      } else {
        var _ownerCmp$scrollable;
        (_ownerCmp$scrollable = ownerCmp.scrollable) === null || _ownerCmp$scrollable === void 0 ? void 0 : _ownerCmp$scrollable.scrollIntoView(activeItem, {
          block: "nearest",
          focus: needsFocus,
          silent: me.scrollSilently
        });
      }
      if (activeItem === oldActiveItem && isActive) {
        return;
      }
      activeItem.classList.add(me.focusCls);
      activeItem.id = `${me.owner.id}-active-descendant`;
      me._activeItem = activeItem;
    } else {
      me._activeItem = null;
      if (oldActiveItem === DomHelper.getActiveElement(oldActiveItem)) {
        ownerCmp.revertFocus();
      }
    }
  }
  updateTarget(target, oldTarget) {
    const me = this, listeners = {
      element: target,
      thisObj: me,
      focusin: "onTargetFocusIn",
      focusout: "onTargetFocusOut",
      mousedown: {
        handler: "onTargetMouseDown",
        delegate: me.itemSelector
      }
    };
    if (!me.itemsTabbable && !me.itemsFocusable) {
      listeners.click = "onTargetClick";
    }
    if (!Object.prototype.hasOwnProperty.call(me, "acceptNode")) {
      me.acceptNode = me.acceptNode.bind(me);
      me.acceptNode.acceptNode = me.acceptNode;
    }
    EventHelper.on(listeners);
    me.treeWalker = me.setupTreeWalker(target, DomHelper.NodeFilter.SHOW_ELEMENT, me.acceptNode);
    if (!me.keyEventTarget) {
      me.keyEventTarget = target;
    }
    (me.targetMutationMonitor = new MutationObserver(me.onTargetChildListChange.bind(me))).observe(target, {
      childList: true,
      subtree: true
    });
  }
  setupTreeWalker(root2, whatToShow, filter) {
    return document.createTreeWalker(root2, whatToShow, filter);
  }
  onTargetChildListChange() {
    const me = this, {
      activeItem,
      datasetIdProperty
    } = me;
    if (activeItem) {
      if (me.target.contains(activeItem)) {
        if (!activeItem.classList.contains(me.focusCls)) {
          activeItem.classList.add(me.focusCls);
        }
      } else {
        var _me$target$querySelec;
        me.activeItem = me.target.querySelector(`${me.itemSelector}.${me.focusCls}[data-${StringHelper.hyphenate(datasetIdProperty)}="${activeItem.dataset[datasetIdProperty]}"]`) || ((_me$target$querySelec = me.target.querySelector(`${me.itemSelector}.${me.focusCls}`)) === null || _me$target$querySelec === void 0 ? void 0 : _me$target$querySelec[activeItem.dataset.index]) || null;
      }
    }
  }
  changeKeyEventTarget(keyEventTarget) {
    this._keyEventTarget = keyEventTarget;
    EventHelper.on({
      element: keyEventTarget,
      keydown: "onKeyDown",
      thisObj: this
    });
  }
  triggerNavigate(event, item = this.activeItem) {
    var _this$ownerCmp;
    const navEvent = {
      event,
      item,
      oldItem: this.previousActiveItem
    };
    this.trigger("navigate", navEvent);
    (_this$ownerCmp = this.ownerCmp) === null || _this$ownerCmp === void 0 ? void 0 : _this$ownerCmp.trigger("navigate", navEvent);
  }
};
Navigator._$name = "Navigator";
var escapeRegExp = StringHelper.escapeRegExp;
var digitsRe = /[\d+-]/g;
var newFormatter = (locale2, config) => new Intl.NumberFormat(locale2 || void 0, config);
var numFormatRe = /^(?:([$])\s*)?(?:(\d+)>)?\d+(,\d+)?(?:\.((\d*)(?:#*)|[*]))?(?:\s*([%])?)?$/;
var unicodeMinus = "\u2212";
var NumberParser = class {
  constructor(formatter) {
    const me = this, locale2 = formatter.locale, numFmt = newFormatter(locale2, {
      maximumFractionDigits: 3
    }), currency = formatter.is.currency ? me._decodeStyle(locale2, {
      style: "currency",
      currency: formatter.currency,
      currencyDisplay: formatter.currencyDisplay
    }) : null, percent = formatter.is.percent ? me._decodeStyle(locale2, {
      style: "percent"
    }) : null, decimal = numFmt.format(1.2).replace(digitsRe, "")[0], grouper = numFmt.format(1e9).replace(digitsRe, "")[0] || "";
    Object.assign(me, {
      currency,
      decimal,
      formatter,
      grouper,
      percent
    });
    me.decimal = decimal;
    me.decimalRe = escapeRegExp(decimal, "g");
    me.grouper = grouper;
    me.stripRe = new RegExp(`(?:\\s+|${escapeRegExp(grouper)})` + (currency ? `|(?:${escapeRegExp(currency.text)})` : "") + (percent ? `|(?:${escapeRegExp(percent.text)})` : ""), "g");
  }
  decimalPlaces(value) {
    value = value.replace(this.stripRe, "");
    const dot = value.indexOf(this.decimal) + 1;
    return dot && value.length - dot;
  }
  parse(value, strict) {
    if (typeof value === "string") {
      value = value.replace(this.stripRe, "").replace(this.decimalRe, ".").replace(unicodeMinus, "-");
      value = strict ? Number(value) : parseFloat(value);
      if (this.formatter.is.percent) {
        value /= 100;
      }
    }
    return value;
  }
  _decodeStyle(locale2, fmtDef) {
    const fmt = newFormatter(locale2, fmtDef), decFmt = newFormatter(locale2, Object.assign(fmt.resolvedOptions(), {
      style: "decimal"
    })), zero = fmt.format(0), zeroDec = decFmt.format(0);
    return {
      suffix: zero.startsWith(zeroDec),
      text: zero.replace(zeroDec, "").trim()
    };
  }
};
var NumberFormat = class extends Formatter {
  static get $name() {
    return "NumberFormat";
  }
  initialize() {
    this._as = {};
    this.is = {
      decimal: false,
      currency: false,
      percent: false,
      null: true,
      from: null
    };
  }
  get truncator() {
    const scale = this.maximumFractionDigits;
    return scale == null ? null : this.as({
      style: "decimal",
      maximumFractionDigits: Math.min(20, scale + 1)
    }, "truncator");
  }
  configure(options) {
    const me = this;
    if (typeof options !== "string") {
      Object.assign(me, options);
    } else {
      me.template = options;
    }
    const config = {}, loc = me.locale ? LocaleManagerSingleton.locales[me.locale] : LocaleManagerSingleton.locale, defaults = loc && loc.NumberFormat, template = me.template;
    if (defaults) {
      for (const key in defaults) {
        if (me[key] == null && typeof defaults[key] !== "function") {
          me[key] = defaults[key];
        }
      }
    }
    if (template) {
      const match = numFormatRe.exec(template), m2 = match[2], m4 = match[4];
      me.useGrouping = !!match[3];
      me.style = match[1] ? "currency" : match[6] ? "percent" : "decimal";
      if (m2) {
        me.integer = +m2;
      }
      if (m4 === "*") {
        me.fraction = [0, 20];
      } else if (m4 != null) {
        me.fraction = [match[5].length, m4.length];
      }
    }
    me._minMax("fraction", true, true);
    me._minMax("integer", true, false);
    me._minMax("significant", false, true);
    for (const key in me.defaults) {
      if (me[key] != null) {
        config[key] = me[key];
      }
    }
    me.is.from = me.from && me.from.is;
    me.is[me.style] = !(me.is.null = false);
    me.formatter = newFormatter(me.locale, config);
  }
  as(change, cacheAs = null) {
    const config = this.resolvedOptions() || {
      template: "9.*"
    }, cache = this._as;
    let ret = cacheAs && cache[cacheAs];
    if (!ret) {
      if (typeof change === "string") {
        config.style = change;
      } else {
        Object.assign(config, change);
      }
      config.from = this;
      ret = new NumberFormat(config);
    }
    if (cacheAs) {
      cache[cacheAs] = ret;
    }
    return ret;
  }
  defaultParse(value, strict) {
    return value == null ? value : strict ? Number(value) : parseFloat(value);
  }
  format(value) {
    if (typeof value === "string") {
      const v = Number(value);
      value = isNaN(v) ? this.parse(value) : v;
    }
    return super.format(value);
  }
  round(value) {
    return this.parse(this.format(value));
  }
  truncate(value) {
    const me = this, scale = me.maximumFractionDigits, {
      truncator
    } = me;
    let v = me.parse(value), dot;
    if (truncator) {
      v = truncator.format(v);
      dot = v.indexOf(truncator.parser.decimal);
      if (dot > -1 && v.length - dot - 1 > scale) {
        v = v.substr(0, dot + scale + 1);
      }
      v = truncator.parse(v);
    }
    return v;
  }
  resolvedOptions() {
    const options = super.resolvedOptions();
    for (const key in options) {
      if (options[key] === void 0) {
        options[key] = this[key];
      }
    }
    return options;
  }
  _minMax(name, setMin, setMax) {
    const me = this, value = me[name];
    if (value != null) {
      const capName = StringHelper.capitalize(name), max = `maximum${capName}Digits`, min2 = `minimum${capName}Digits`;
      if (typeof value === "number") {
        if (setMin) {
          me[min2] = value;
        }
        if (setMax) {
          me[max] = value;
        }
      } else {
        me[min2] = value[0];
        me[max] = value[1];
      }
    }
  }
};
NumberFormat.Parser = NumberParser;
Object.assign(NumberFormat.prototype, {
  defaults: {
    style: "decimal",
    currency: null,
    currencyDisplay: "symbol",
    locale: null,
    maximumFractionDigits: null,
    minimumFractionDigits: null,
    minimumIntegerDigits: null,
    maximumSignificantDigits: null,
    minimumSignificantDigits: null,
    useGrouping: true
  },
  fraction: null,
  from: null,
  integer: null,
  significant: null,
  template: null
});
Object.assign(NumberFormat.prototype, NumberFormat.prototype.defaults);
Formatter.number = (format, value) => NumberFormat.format(format, value);
NumberFormat._$name = "NumberFormat";
var WebSocketManager = class extends Events(Base) {
  construct(config = {}) {
    const me = this;
    super.construct(config);
    me.onWsOpen = me.onWsOpen.bind(me);
    me.onWsClose = me.onWsClose.bind(me);
    me.onWsMessage = me.onWsMessage.bind(me);
    me.onWsError = me.onWsError.bind(me);
    if (me.autoConnect && me.address) {
      me.open();
    }
  }
  doDestroy() {
    const me = this;
    if (me.connector) {
      me.detachSocketListeners(me.connector);
      me.connector.close();
      me.connector = null;
    }
    super.doDestroy();
  }
  get isConnecting() {
    var _this$connector;
    return ((_this$connector = this.connector) === null || _this$connector === void 0 ? void 0 : _this$connector.readyState) === this.constructor.webSocketImplementation.CONNECTING;
  }
  get isOpened() {
    var _this$connector2;
    return ((_this$connector2 = this.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.readyState) === this.constructor.webSocketImplementation.OPEN;
  }
  get isClosing() {
    var _this$connector3;
    return ((_this$connector3 = this.connector) === null || _this$connector3 === void 0 ? void 0 : _this$connector3.readyState) === this.constructor.webSocketImplementation.CLOSING;
  }
  get isClosed() {
    var _this$connector4;
    return ((_this$connector4 = this.connector) === null || _this$connector4 === void 0 ? void 0 : _this$connector4.readyState) === this.constructor.webSocketImplementation.CLOSED;
  }
  createWebSocketConnector() {
    const connector = this.connector = new this.constructor.webSocketImplementation(this.address);
    this.attachSocketListeners(connector);
  }
  destroyWebSocketConnector() {
    this.detachSocketListeners(this.connector);
    this.connector.close();
    this.connector = null;
  }
  attachSocketListeners(connector) {
    const me = this;
    connector.addEventListener("open", me.onWsOpen);
    connector.addEventListener("close", me.onWsClose);
    connector.addEventListener("message", me.onWsMessage);
    connector.addEventListener("error", me.onWsError);
  }
  detachSocketListeners(connector) {
    const me = this;
    connector.removeEventListener("open", me.onWsOpen);
    connector.removeEventListener("close", me.onWsClose);
    connector.removeEventListener("message", me.onWsMessage);
    connector.removeEventListener("error", me.onWsError);
  }
  async open() {
    const me = this;
    if (me._openPromise) {
      return me._openPromise;
    }
    if (!me.address) {
      console.warn("Server me.address cannot be empty");
      return;
    }
    if (me.isOpened) {
      return true;
    }
    me.createWebSocketConnector();
    let detacher2;
    me._openPromise = new Promise((resolve) => {
      detacher2 = me.ion({
        open() {
          resolve(true);
        },
        error() {
          resolve(false);
        }
      });
    }).then((value) => {
      detacher2();
      me._openPromise = null;
      if (!value) {
        me.destroyWebSocketConnector();
      }
      return value;
    }).catch(() => {
      me._openPromise = null;
      me.destroyWebSocketConnector();
    });
    return me._openPromise;
  }
  close() {
    if (this.connector) {
      this.destroyWebSocketConnector();
      this.trigger("close");
    }
  }
  send(command, data = {}) {
    var _this$connector5;
    (_this$connector5 = this.connector) === null || _this$connector5 === void 0 ? void 0 : _this$connector5.send(JSON.stringify(_objectSpread2({
      command
    }, data)));
  }
  onWsOpen(event) {
    this.trigger("open", {
      event
    });
  }
  onWsClose(event) {
    this.trigger("close", {
      event
    });
  }
  onWsMessage(message) {
    try {
      const data = JSON.parse(message.data);
      this.trigger("message", {
        data
      });
    } catch (error) {
      this.trigger("error", {
        error
      });
    }
  }
  onWsError(error) {
    this.trigger("error", {
      error
    });
  }
};
_defineProperty(WebSocketManager, "webSocketImplementation", typeof WebSocket === "undefined" ? null : WebSocket);
_defineProperty(WebSocketManager, "configurable", {
  address: "",
  userName: "User",
  autoConnect: true
});
WebSocketManager._$name = "WebSocketManager";
var Finalizable = (Target) => class Finalizable extends (Target || Base) {
  static get $name() {
    return "Finalizable";
  }
  construct(...args) {
    super.construct(...args);
    this.finalizer = null;
    this.finalizing = null;
    this.isFinalized = false;
    this.isFinalizing = false;
  }
  doFinalize() {
    this.destroy();
  }
  finalize() {
    const me = this;
    let ret = me.finalizing;
    if (!ret && !me.isFinalized) {
      me.isFinalizing = true;
      me.finalizing = ret = me._awaitFinalizer();
    }
    return ret;
  }
  async _awaitFinalizer() {
    const me = this;
    try {
      await me.finalizer;
    } finally {
      me.finalizing = null;
      me.isFinalized = true;
      me.doFinalize();
    }
  }
};
var ABORTED = Symbol("dragAbort");
var INIT = Symbol("dragInit");
var DRAGGING = Symbol("dragDrag");
var DROPPED = Symbol("dragDrop");
var lockDirections = {
  x: "horizontal",
  y: "vertical"
};
var DragContext = class extends Base.mixin(Finalizable, Delayable, Identifiable) {
  static get configurable() {
    return {
      itemElement: null,
      scrollManager: null,
      monitoringConfig: null,
      source: null,
      target: null,
      targetElement: null,
      threshold: 5,
      touchStartDelay: 300
    };
  }
  static get identifiable() {
    return {};
  }
  construct(...args) {
    super.construct(...args);
    const me = this, {
      event
    } = me;
    Object.assign(me, {
      altKey: null,
      cleaners: [],
      ctrlKey: null,
      data: /* @__PURE__ */ new Map(),
      element: event.target,
      endEvent: null,
      lastMoveEvent: null,
      metaKey: null,
      previousTarget: null,
      scrollerAction: null,
      shiftKey: null,
      state: INIT,
      startEvent: event,
      touchStartTimer: null,
      _valid: true
    });
    if ("touches" in event && me.touchStartDelay) {
      me.touchStartTimer = me.setTimeout(() => me.touchStartTimer = null, me.touchStartDelay, "touchStartDelay");
    }
    EventHelper.on({
      element: globalThis,
      blur: "onWindowBlur",
      thisObj: me
    });
  }
  doDestroy() {
    const me = this, {
      source,
      target
    } = me;
    me.cleanup();
    if ((target === null || target === void 0 ? void 0 : target.dropping) === me) {
      target.dropping = null;
    }
    if ((source === null || source === void 0 ? void 0 : source.dragging) === me) {
      source.dragging = null;
    }
    super.doDestroy();
  }
  onWindowBlur() {
    if (this.started) {
      this.abort();
    }
  }
  get aborted() {
    return this.state === ABORTED;
  }
  get completed() {
    return this.isDestroying || this.aborted || this.endEvent !== null;
  }
  get pending() {
    return this.state === INIT;
  }
  get started() {
    return this.state !== INIT && !this.aborted;
  }
  get valid() {
    return this.started && this.targetElement != null && this._valid;
  }
  set valid(v) {
    this._valid = v;
  }
  async get(name) {
    if (this.aborted) {
      throw new Error("Data is not available on aborted drag");
    }
    if (!this.completed) {
      throw new Error("Data is not available until drag completion");
    }
    if (Array.isArray(name)) {
      return Promise.all(name.map((s) => this.get(s)));
    }
    let value = this.data.get(name);
    if (typeof value === "function") {
      value = await value();
      this.data.set(name, value);
    }
    return value;
  }
  has(name) {
    return this.data.has(name);
  }
  peek(name) {
    if (this.aborted) {
      throw new Error("Data is not available on aborted drag");
    }
    if (Array.isArray(name)) {
      return name.map((s) => this.peek(s));
    }
    let value = this.data.get(name);
    if (typeof value === "function") {
      value = true;
    }
    return value;
  }
  set(name, value) {
    this.data.set(name, value);
  }
  changeTarget(target, was) {
    if (target !== was) {
      const me = this;
      me._target = target;
      me.previousTarget = was;
      if (was) {
        was.dropping = null;
      }
      if (target) {
        target.dropping = me;
        if (target.dropping !== me) {
          target = null;
          me.valid = false;
        }
      }
      me._target = was;
    }
    return target;
  }
  updateTarget(target, was) {
    const me = this;
    if (was) {
      me.source.dragLeaveTarget(me, was);
    }
    if (target) {
      me.valid = true;
      target.dragMove(me);
      me.source.dragEnterTarget(me);
    }
  }
  updateTargetElement(targetElement) {
    let droppable, droppables, droppableSelector, i, t;
    for (t = targetElement; t; t = t.parentElement) {
      droppables = DomDataStore.get(t, "droppables");
      if (droppables) {
        for (i = 0; i < droppables.length; ++i) {
          droppable = droppables[i];
          if (droppable.dropRootElement.contains(targetElement)) {
            droppableSelector = droppable.droppableSelector;
            if (!droppableSelector || targetElement.closest(`#${DomHelper.getId(droppable.dropRootElement)} ${droppableSelector}`)) {
              this.target = droppable;
              if (this.target === droppable) {
                return;
              }
            }
          }
        }
      }
    }
  }
  abort() {
    const me = this, {
      element,
      source
    } = me;
    element === null || element === void 0 ? void 0 : element.getBoundingClientRect();
    if (me.state !== DROPPED) {
      me.state = ABORTED;
      me.cleanup();
    }
    source === null || source === void 0 ? void 0 : source.endDrag(me);
  }
  begin() {
    const me = this, {
      source
    } = me, ret = source.beforeDrag(me);
    if (ret !== false) {
      source.dragging = me;
    }
    return ret;
  }
  cleanup() {
    let cleaner;
    while (cleaner = this.cleaners.pop()) {
      cleaner();
    }
  }
  end(event) {
    const me = this, {
      lastMoveEvent: lastEvent,
      target
    } = me, {
      dragSwallowClickTime
    } = me.source;
    me.event = me.endEvent = event;
    me.syncFlags();
    if (me.started) {
      if ((lastEvent === null || lastEvent === void 0 ? void 0 : lastEvent.clientX) !== event.clientX || (lastEvent === null || lastEvent === void 0 ? void 0 : lastEvent.clientY) !== event.clientY || (lastEvent === null || lastEvent === void 0 ? void 0 : lastEvent.target) !== event.target) {
        me.track();
      }
      if (dragSwallowClickTime) {
        EventHelper.on({
          element: document,
          capture: true,
          expires: dragSwallowClickTime,
          once: true,
          click(event2) {
            event2.stopPropagation();
          }
        });
      }
      me.state = DROPPED;
      if (target !== me.source) {
        target === null || target === void 0 ? void 0 : target.dragDrop(me);
      }
    }
  }
  fakeKey(event, down) {
    const me = this, {
      lastMoveEvent
    } = me;
    if (lastMoveEvent && me.element) {
      let changed;
      lastMoveEvent.isKey = true;
      if (event.key === "Alt") {
        if (me.altKey !== down) {
          me.altKey = down;
          changed = true;
        }
      } else if (event.key === "Control") {
        if (me.ctrlKey !== down) {
          me.ctrlKey = down;
          changed = true;
        }
      }
      if (changed) {
        me.event = lastMoveEvent;
        me.track();
      }
    }
  }
  keyDown(event) {
    if (!this.completed) {
      if (event.key === "Escape") {
        this.abort();
      } else if (this.isDragToggleKey(event.key)) {
        this.fakeKey(event, true);
      }
    }
  }
  keyUp(event) {
    if (!this.completed && this.isDragToggleKey(event.key)) {
      this.fakeKey(event, false);
    }
  }
  getDistance(event) {
    return EventHelper.getDistanceBetween(this.startEvent, event);
  }
  isDragToggleKey(key) {
    return key === "Control" || key === "Alt";
  }
  move(event) {
    const me = this, {
      target
    } = event, distance = me.getDistance(event), significant = distance >= me.threshold;
    me.syncFlags();
    if (me.touchStartTimer) {
      if (significant) {
        me.abort();
      }
      return;
    }
    if (target && target.nodeType === Node.ELEMENT_NODE) {
      if (significant && !me.started) {
        me.event = event;
        if (me.start() === false) {
          me.abort();
          return;
        }
      }
      if (me.started && !me.completed) {
        me.lastMoveEvent = me.event = event;
        if (event.type === "touchmove") {
          event.preventDefault();
          event.stopImmediatePropagation();
        }
        me.track();
      }
    }
  }
  start() {
    const me = this, {
      scrollManager,
      monitoringConfig,
      source
    } = me, {
      draggingBodyCls: activeCls,
      dragLock
    } = source, element = source.dragRootElement;
    me.state = DRAGGING;
    if (scrollManager) {
      const detacher2 = scrollManager.startMonitoring(Objects.merge({
        scrollables: [{
          element
        }],
        direction: lockDirections[dragLock] || dragLock || "both",
        callback(scrollerAction) {
          const {
            lastMoveEvent
          } = me;
          if (lastMoveEvent && me.element) {
            lastMoveEvent.isScroll = true;
            me.event = lastMoveEvent;
            me.scrollerAction = scrollerAction;
            me.track();
            me.scrollerAction = null;
          }
        }
      }, monitoringConfig));
      me.cleaners.push(detacher2);
    }
    const rootEl = source.dragRootElement.closest(".b-outer") || document.body;
    rootEl.classList.add(activeCls);
    me.cleaners.push(() => rootEl.classList.remove(activeCls));
    if (source.startDrag(me) === false) {
      me.cleanup();
      return false;
    }
  }
  syncFlags() {
    const me = this, {
      event
    } = me;
    me.altKey = event.altKey;
    me.ctrlKey = event.ctrlKey || event.metaKey;
    me.metaKey = event.metaKey;
    me.shiftKey = event.shiftKey;
  }
  track() {
    const me = this, {
      event,
      source,
      target
    } = me;
    let targetElement = event.target, touch;
    if (event.type === "touchmove") {
      touch = event.changedTouches[0];
      targetElement = DomHelper.elementFromPoint(touch.clientX, touch.clientY);
    }
    me.targetElement = targetElement;
    if (target === me.target) {
      target === null || target === void 0 ? void 0 : target.dragMove(me);
    }
    source.trackDrag(me);
  }
};
_defineProperty(DragContext, "$name", "DragContext");
DragContext.prototype.STATE = DragContext.STATE = Object.freeze({
  ABORTED,
  INIT,
  DRAGGING,
  DROPPED
});
DragContext._$name = "DragContext";
var DragProxy = class extends Base.mixin(Factoryable) {
  static get type() {
    return "default";
  }
  static get configurable() {
    return {
      dragging: null
    };
  }
  static get factoryable() {
    return {
      defaultType: DragProxy
    };
  }
  updateDragging(drag, was) {
    if (was) {
      this.close(was);
    }
    if (drag) {
      this.open(drag);
    }
  }
  close(drag) {
  }
  open(drag) {
  }
  dragStart(drag) {
    this.dragging = drag;
  }
  dragMove(drag) {
  }
  dragEnd(drag) {
    this.dragging = null;
  }
};
DragProxy.initClass();
DragProxy._$name = "DragProxy";
var Draggable = (Target) => class Draggable extends (Target || Base) {
  static get $name() {
    return "Draggable";
  }
  static get configurable() {
    return {
      dragging: {
        $config: "nullify",
        value: null
      },
      draggingClsSelector: null,
      dragDocumentListeners: {
        element: document,
        keydown: "onDragKeyDown",
        keyup: "onDragKeyUp",
        contextmenu: "onDragContextMenu",
        mousemove: "onDragPointerMove",
        mouseup: "onDragPointerUp",
        pointerup: "onDragPointerUp",
        touchend: "onDragPointerUp",
        touchmove: {
          handler: "onDragPointerMove",
          passive: false
        }
      },
      dragItemSelector: null,
      dragItemOverCls: null,
      dragLock: null,
      dragMinDistance: 1,
      dragProxy: {
        $config: ["lazy", "nullify"],
        value: null
      },
      dragRootElement: {
        $config: "nullify",
        value: null
      },
      dragSameTargetDrop: false,
      dragSelector: null,
      ignoreSelector: null,
      dragSwallowClickTime: 50,
      dragThreshold: 5,
      dragTouchStartDelay: 300,
      dropTargetSelector: null,
      overItem: null,
      testConfig: {
        dragSwallowClickTime: 50
      }
    };
  }
  static get properties() {
    return {
      draggingCls: "b-draggable-active",
      draggingBodyCls: "b-draghelper-active",
      draggingItemCls: "b-dragging-item",
      draggingStartedCls: "b-draggable-started",
      draggableCls: "b-draggable"
    };
  }
  beforeDrag(drag) {
    const {
      dragRootElement,
      dragSelector,
      ignoreSelector
    } = this, target = dragSelector && drag.element.closest(dragSelector);
    return !dragSelector || Boolean(target && target === dragRootElement || dragRootElement.contains(target) && (!ignoreSelector || !drag.element.matches(ignoreSelector)));
  }
  dragStart(drag) {
  }
  dragOver(drag) {
  }
  dragEnterTarget(drag) {
  }
  dragLeaveTarget(drag, oldTarget) {
  }
  dragDrop(drag) {
  }
  dragEnd(drag) {
  }
  get activeDrag() {
    const {
      dragging: drag
    } = this;
    return drag !== null && drag !== void 0 && drag.started && !drag.completed ? drag : null;
  }
  get dragEventer() {
    return this.trigger ? this : null;
  }
  get draggingClassElement() {
    const {
      draggingClsSelector,
      dragRootElement
    } = this;
    return draggingClsSelector ? dragRootElement === null || dragRootElement === void 0 ? void 0 : dragRootElement.closest(draggingClsSelector) : dragRootElement;
  }
  beginDrag(drag) {
    const {
      draggingCls,
      draggingClassElement
    } = this;
    if (draggingCls && draggingClassElement) {
      draggingClassElement.classList.add(draggingCls);
      drag.cleaners.push(() => draggingClassElement.classList.remove(draggingCls));
    }
  }
  async endDrag(drag) {
    const me = this, {
      dragEventer,
      dragProxy
    } = me;
    if (drag.valid) {
      await me.dragDrop(drag);
    }
    if (me.isDestroyed) {
      return;
    }
    if (drag.pending) {
      drag.destroy();
    } else {
      me.dragEnd(drag);
      dragProxy === null || dragProxy === void 0 ? void 0 : dragProxy.dragEnd(drag);
      dragEventer === null || dragEventer === void 0 ? void 0 : dragEventer.trigger(drag.valid ? "drop" : "dragCancel", {
        drag,
        event: drag.event
      });
      me.finalizeDrag(drag);
    }
  }
  async finalizeDrag(drag) {
    var _drag$finalize;
    await ((_drag$finalize = drag.finalize) === null || _drag$finalize === void 0 ? void 0 : _drag$finalize.call(drag));
  }
  moveDrag(drag) {
    if (this.dragOver(drag) !== false) {
      const {
        dragEventer,
        dragProxy
      } = this;
      dragProxy === null || dragProxy === void 0 ? void 0 : dragProxy.dragMove(drag);
      dragEventer === null || dragEventer === void 0 ? void 0 : dragEventer.trigger("drag", {
        drag,
        event: drag.event
      });
    }
  }
  setupDragContext(event) {
    const me = this, {
      dragItemSelector,
      id
    } = me, {
      target
    } = event;
    return {
      event,
      id: id ? `${id}-drag-${me._nextDragId = (me._nextDragId || 0) + 1}` : null,
      itemElement: dragItemSelector ? target.closest(dragItemSelector) : target,
      touchStartDelay: me.dragTouchStartDelay,
      source: me,
      threshold: me.dragThreshold
    };
  }
  startDrag(drag) {
    const {
      draggingStartedCls,
      draggingClassElement,
      draggingItemCls,
      dragEventer,
      dragProxy
    } = this, {
      itemElement
    } = drag;
    if ((dragEventer === null || dragEventer === void 0 ? void 0 : dragEventer.trigger("beforeDragStart", {
      drag,
      event: drag.event
    })) === false) {
      return false;
    }
    if (draggingStartedCls && draggingClassElement) {
      draggingClassElement.classList.add(draggingStartedCls);
      drag.cleaners.push(() => draggingClassElement.classList.remove(draggingStartedCls));
    }
    if (draggingItemCls && itemElement) {
      itemElement.classList.add(draggingItemCls);
      drag.cleaners.push(() => itemElement.classList.remove(draggingItemCls));
    }
    dragProxy === null || dragProxy === void 0 ? void 0 : dragProxy.dragStart(drag);
    const result = this.dragStart(drag);
    if (result !== false) {
      dragEventer === null || dragEventer === void 0 ? void 0 : dragEventer.trigger("dragStart", {
        drag,
        event: drag.event
      });
    }
    return result;
  }
  trackDrag(drag) {
    var _drag$targetElement;
    const {
      dropTargetSelector
    } = this;
    drag.valid = !(dropTargetSelector && !((_drag$targetElement = drag.targetElement) !== null && _drag$targetElement !== void 0 && _drag$targetElement.closest(dropTargetSelector)));
    this.moveDrag(drag);
  }
  configureListeners(drag) {
    const me = this, listeners = ObjectHelper.assign({
      thisObj: me
    }, me.dragDocumentListeners);
    if ("touches" in drag.startEvent) {
      delete listeners.mousemove;
      delete listeners.mouseup;
    } else {
      delete listeners.contextmenu;
      delete listeners.touchmove;
      delete listeners.touchend;
      delete listeners.pointerup;
    }
    return listeners;
  }
  updateDragging(drag, old) {
    const me = this;
    if (drag) {
      const listeners = me.configureListeners(drag);
      drag.cleaners.push(EventHelper.on(listeners));
      me.beginDrag(drag);
    } else if (old) {
      old.destroy();
    }
  }
  changeDragProxy(config, existing) {
    return DragProxy.reconfigure(existing, config, {
      owner: this,
      defaults: {
        owner: this
      }
    });
  }
  updateDragRootElement(rootEl, was) {
    var _me$_dragRootDetacher;
    const me = this, {
      draggableCls,
      dragItemSelector,
      onDragItemMouseMove
    } = me;
    was === null || was === void 0 ? void 0 : was.classList.remove(draggableCls);
    (_me$_dragRootDetacher = me._dragRootDetacher) === null || _me$_dragRootDetacher === void 0 ? void 0 : _me$_dragRootDetacher.call(me);
    if (rootEl) {
      const listeners = {
        thisObj: me,
        element: rootEl,
        mousedown: "onDragMouseDown",
        touchstart: "onDragTouchStart",
        pointerdown: (e) => {
          var _e$target$releasePoin, _e$target;
          return e.pointerId && ((_e$target$releasePoin = (_e$target = e.target).releasePointerCapture) === null || _e$target$releasePoin === void 0 ? void 0 : _e$target$releasePoin.call(_e$target, e.pointerId));
        }
      };
      if (onDragItemMouseMove) {
        listeners.mousemove = {
          delegate: dragItemSelector,
          handler: "onDragItemMouseMove"
        };
      }
      if (me.dragItemOverCls || onDragItemMouseMove || me.onDragItemMouseEnter || me.onDragItemMouseLeave) {
        Object.assign(listeners, {
          mouseover: {
            delegate: dragItemSelector,
            handler: "onDragItemMouseOver"
          },
          mouseout: {
            delegate: dragItemSelector,
            handler: "onDragItemMouseOut"
          }
        });
      }
      rootEl.classList.add(draggableCls);
      me._dragRootDetacher = EventHelper.on(listeners);
    }
  }
  onDragItemMouseOver(event) {
    this.overItem = event;
  }
  onDragItemMouseOut(event) {
    if (!this.dragging) {
      this.overItem = event;
    }
  }
  changeOverItem(event) {
    this.enterLeaveEvent = event;
    if (event.type === "mouseout") {
      var _event$relatedTarget;
      return ((_event$relatedTarget = event.relatedTarget) === null || _event$relatedTarget === void 0 ? void 0 : _event$relatedTarget.closest(this.dragItemSelector)) || null;
    } else {
      return event.target.closest(this.dragItemSelector);
    }
  }
  updateOverItem(overItem, oldOverItem) {
    const me = this, {
      dragItemOverCls
    } = me;
    if (oldOverItem) {
      var _me$onDragItemMouseLe;
      dragItemOverCls && oldOverItem.classList.remove(dragItemOverCls);
      (_me$onDragItemMouseLe = me.onDragItemMouseLeave) === null || _me$onDragItemMouseLe === void 0 ? void 0 : _me$onDragItemMouseLe.call(me, me.enterLeaveEvent, oldOverItem);
    }
    if (overItem) {
      var _me$onDragItemMouseEn;
      dragItemOverCls && overItem.classList.add(dragItemOverCls);
      (_me$onDragItemMouseEn = me.onDragItemMouseEnter) === null || _me$onDragItemMouseEn === void 0 ? void 0 : _me$onDragItemMouseEn.call(me, me.enterLeaveEvent, overItem);
    }
  }
  onDragContextMenu(event) {
    event.preventDefault();
  }
  onDragKeyDown(event) {
    this.dragging.keyDown(event);
  }
  onDragKeyUp(event) {
    this.dragging.keyUp(event);
  }
  onDragMouseDown(event) {
    if (event.button === 0) {
      this.onDragPointerDown(event);
    }
  }
  onDragPointerDown(event) {
    let {
      dragging: drag
    } = this;
    if (!drag) {
      drag = this.setupDragContext(event);
      if (drag) {
        drag = new DragContext(drag);
        if (drag.begin() === false) {
          drag.destroy();
        }
      }
    } else if (!drag.isFinalizing) {
      drag.abort();
    }
  }
  changeDragging(value, was) {
    was === null || was === void 0 ? void 0 : was.destroy();
    return value;
  }
  onDragPointerMove(event) {
    const {
      dragging: drag
    } = this;
    if (drag && !drag.completed) {
      drag === null || drag === void 0 ? void 0 : drag.move(event);
    }
  }
  onDragPointerUp(event) {
    const {
      dragging: drag
    } = this;
    if (drag && !drag.completed) {
      drag.end(event);
      this.endDrag(drag);
    }
  }
  onDragTouchStart(event) {
    if (event.touches.length === 1) {
      this.onDragPointerDown(event);
    }
  }
};
var Droppable = (Target) => class Droppable extends (Target || Base) {
  static get $name() {
    return "Droppable";
  }
  static get configurable() {
    return {
      droppableSelector: null,
      dropping: null,
      dropRootElement: {
        $config: "nullify",
        value: null
      }
    };
  }
  get dropEventer() {
    return this.trigger ? this : null;
  }
  get droppableCls() {
    return "b-droppable";
  }
  dragEnter(drag) {
    var _this$dropEventer;
    return (_this$dropEventer = this.dropEventer) === null || _this$dropEventer === void 0 ? void 0 : _this$dropEventer.trigger("dragEnter", {
      drag,
      event: drag.event
    });
  }
  dragMove(drag) {
    var _this$dropEventer2;
    return (_this$dropEventer2 = this.dropEventer) === null || _this$dropEventer2 === void 0 ? void 0 : _this$dropEventer2.trigger("dragMove", {
      drag,
      event: drag.event
    });
  }
  dragDrop(drag) {
    var _this$dropEventer3;
    return (_this$dropEventer3 = this.dropEventer) === null || _this$dropEventer3 === void 0 ? void 0 : _this$dropEventer3.trigger("drop", {
      drag,
      event: drag.event
    });
  }
  dragLeave(drag) {
    var _this$dropEventer4;
    return (_this$dropEventer4 = this.dropEventer) === null || _this$dropEventer4 === void 0 ? void 0 : _this$dropEventer4.trigger("dragLeave", {
      drag,
      event: drag.event
    });
  }
  changeDropping(dropping, was) {
    if (dropping !== was) {
      const me = this;
      if (was) {
        if (was.aborted || !was.completed) {
          me.dragLeave(was);
        }
      }
      if (dropping) {
        me._dropping = dropping;
        if (me.dragEnter(dropping) === false) {
          dropping = null;
        }
        me._dropping = was;
      }
    }
    return dropping;
  }
  updateDropRootElement(rootEl, was) {
    const me = this, {
      droppableCls
    } = me;
    let droppables, i, removeCls;
    if (was) {
      droppables = DomDataStore.get(was, "droppables");
      removeCls = true;
      if (Array.isArray(droppables) && (i = droppables.indexOf(me)) > -1) {
        if (droppables.length < 2) {
          DomDataStore.remove(was, "droppables");
        } else {
          droppables.splice(i, 1);
          droppables.forEach((d) => {
            if (droppableCls === d.droppableCls) {
              removeCls = false;
            }
          });
        }
      }
      removeCls && was.classList.remove(droppableCls);
    }
    if (rootEl) {
      droppables = DomDataStore.get(rootEl, "droppables");
      if (droppables) {
        droppables.push(me);
      } else {
        DomDataStore.set(rootEl, "droppables", [me]);
      }
      rootEl.classList.add(droppableCls);
    }
  }
};
var Featureable = (Target) => class Featureable extends (Target || Base) {
  static get $name() {
    return "Featureable";
  }
  static get configurable() {
    return {
      features: null
    };
  }
  static get declarable() {
    return [
      "featureable"
    ];
  }
  static setupFeatureable(cls) {
    const featureable = _objectSpread2({
      ownerName: "client"
    }, cls.featureable);
    featureable.factory.initClass();
    Reflect.defineProperty(cls, "featureable", {
      get() {
        return featureable;
      }
    });
  }
  doDestroy() {
    const features = this.features;
    super.doDestroy();
    for (const name in features) {
      var _feature$destroy;
      const feature = features[name];
      (_feature$destroy = feature.destroy) === null || _feature$destroy === void 0 ? void 0 : _feature$destroy.call(feature);
    }
  }
  hasFeature(name) {
    var _this$features;
    return Boolean((_this$features = this.features) === null || _this$features === void 0 ? void 0 : _this$features[name]);
  }
  changeFeatures(features, was) {
    if (this.isDestroying) {
      return;
    }
    const me = this, {
      featureable
    } = me.constructor, manager = me.$features || (me.$features = new DynamicObject({
      configName: "features",
      factory: featureable.factory,
      owner: me,
      ownerName: featureable.ownerName
    }));
    manager.update(features);
    if (!was) {
      return manager.target;
    }
  }
  get widgetClass() {
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options), {
      features
    } = result;
    if (features) {
      for (const featureName in features) {
        if (Object.keys(features[featureName]).length === 0) {
          features[featureName] = true;
        }
      }
    }
    return result;
  }
};
var EDGES = {
  e: "b-hover-edge",
  t: "b-hover-top",
  r: "b-hover-right",
  b: "b-hover-bottom",
  l: "b-hover-left"
};
var EDGE_CLASSES = {
  [EDGES.e]: 1,
  [EDGES.t]: 1,
  [EDGES.r]: 1,
  [EDGES.b]: 1,
  [EDGES.l]: 1
};
var ZONES = {
  t: [EDGES.e, EDGES.t],
  r: [EDGES.e, EDGES.r],
  b: [EDGES.e, EDGES.b],
  l: [EDGES.e, EDGES.l],
  tr: [EDGES.e, EDGES.t, EDGES.r],
  bl: [EDGES.e, EDGES.b, EDGES.l],
  tl: [EDGES.e, EDGES.t, EDGES.l],
  br: [EDGES.e, EDGES.b, EDGES.r]
};
var Hoverable = (Target) => class Hoverable extends Target.mixin(Delayable) {
  static get $name() {
    return "Hoverable";
  }
  static get configurable() {
    return {
      hoverCls: null,
      hoverAnimationCls: null,
      hoverRootCls: null,
      hoverRootActiveCls: null,
      hoverDelay: null,
      hoverElement: null,
      hoverIgnoreElement: null,
      hoverEdges: null,
      hoverEdgeSize: 10,
      hoverRootElement: {
        $config: "nullify",
        value: null
      },
      hoverSelector: null,
      hoverTarget: {
        $config: "nullify",
        value: null
      },
      hoverTrack: null,
      hoverZone: null
    };
  }
  static get delayable() {
    return {
      setHoverTarget: 0
    };
  }
  hoverEnter(leaving) {
  }
  hoverIgnore(element) {
    var _this$hoverIgnoreElem;
    return (_this$hoverIgnoreElem = this.hoverIgnoreElement) === null || _this$hoverIgnoreElem === void 0 ? void 0 : _this$hoverIgnoreElem.contains(element);
  }
  hoverLeave(leaving) {
  }
  hoverMove(event) {
  }
  onHoverMouseMove(event) {
    const me = this, {
      hoverEdges,
      hoverEdgeSize,
      hoverTarget
    } = me;
    if (hoverTarget) {
      if (hoverEdges) {
        const {
          top,
          left,
          width,
          height,
          right,
          bottom
        } = hoverTarget.getBoundingClientRect(), {
          clientX,
          clientY
        } = event, centerX = left + width / 2, centerY = top + height / 2, t = clientY < (hoverEdgeSize ? top + hoverEdgeSize : centerY), r = clientX >= (hoverEdgeSize ? right - hoverEdgeSize : centerX), b = clientY >= (hoverEdgeSize ? bottom - hoverEdgeSize : centerY), l = clientX < (hoverEdgeSize ? left + hoverEdgeSize : centerX), tb = t || b ? t ? "t" : "b" : "", rl = r || l ? r ? "r" : "l" : "";
        me.hoverZone = (hoverEdges.includes(tb) ? tb : "") + (hoverEdges.includes(rl) ? rl : "");
      }
      me.hoverEvent = event;
      me.hoverTrack && me.hoverMove(event);
    }
  }
  onHoverMouseOver(event) {
    this.hoverEvent = event;
    this.hoverElement = event.target;
  }
  onHoverMouseOut(event) {
    this.hoverEvent = event;
    this.hoverElement = event.relatedTarget;
  }
  updateHoverDelay(delay) {
    this.setHoverTarget.delay = delay;
  }
  changeHoverEdges(edges) {
    return edges === true ? "trbl" : (edges || "").replace("v", "tb").replace("h", "lr");
  }
  updateHoverEdges() {
    this.syncHoverListeners();
  }
  changeHoverElement(element) {
    if (!this.hoverIgnore(element)) {
      return element;
    }
  }
  updateHoverElement(hoverEl) {
    const {
      hoverSelector
    } = this;
    if (hoverSelector) {
      var _hoverEl;
      hoverEl = (_hoverEl = hoverEl) === null || _hoverEl === void 0 ? void 0 : _hoverEl.closest(hoverSelector);
    }
    this.setHoverTarget(hoverEl);
  }
  updateHoverRootElement(rootEl, was) {
    const {
      hoverRootCls
    } = this;
    if (hoverRootCls) {
      was === null || was === void 0 ? void 0 : was.classList.remove(hoverRootCls);
      rootEl === null || rootEl === void 0 ? void 0 : rootEl.classList.add(hoverRootCls);
    }
    this.syncHoverListeners();
  }
  changeHoverTarget(hoverEl, was) {
    if (was) {
      this.hoverZone = null;
    }
    return hoverEl;
  }
  updateHoverTarget(hoverEl, was) {
    const me = this, {
      hoverCls,
      hoverAnimationCls,
      hoverRootActiveCls,
      hoverRootElement
    } = me;
    if (hoverRootActiveCls) {
      hoverRootElement === null || hoverRootElement === void 0 ? void 0 : hoverRootElement.classList[hoverEl ? "add" : "remove"](hoverRootActiveCls);
    }
    if (was) {
      hoverCls && was.classList.remove(hoverCls);
      hoverAnimationCls && was.classList.remove(hoverAnimationCls);
      me.hoverLeave(was);
    }
    if (hoverEl) {
      hoverCls && hoverEl.classList.add(hoverCls);
      me.hoverEnter(was);
      if (me.hoverTrack) {
        me.hoverMove(me.hoverEvent);
      }
      if (hoverAnimationCls) {
        hoverEl.getBoundingClientRect();
        hoverEl.classList.add(hoverAnimationCls);
      }
    }
  }
  updateHoverTrack() {
    this.syncHoverListeners();
  }
  updateHoverZone(zone) {
    const {
      hoverAnimationCls,
      hoverTarget
    } = this;
    if (hoverTarget) {
      const {
        className
      } = hoverTarget, cls = DomClassList.change(className, zone ? ZONES[zone] : null, EDGE_CLASSES);
      if (className !== cls) {
        hoverTarget.className = cls;
        if (zone && hoverAnimationCls) {
          hoverTarget.classList.remove(hoverAnimationCls);
          hoverTarget.getBoundingClientRect();
          hoverTarget.classList.add(hoverAnimationCls);
        }
      }
    }
  }
  setHoverTarget(target) {
    this.hoverTarget = target;
  }
  syncHoverListeners() {
    var _me$_hoverRootDetache;
    const me = this, element = me.hoverRootElement, listeners = {
      element,
      thisObj: me,
      mouseover: "onHoverMouseOver",
      mouseout: "onHoverMouseOut"
    };
    if (me.hoverTrack || me.hoverEdges) {
      listeners.mousemove = "onHoverMouseMove";
    }
    (_me$_hoverRootDetache = me._hoverRootDetacher) === null || _me$_hoverRootDetache === void 0 ? void 0 : _me$_hoverRootDetache.call(me);
    me._hoverRootDetacher = element && EventHelper.on(listeners);
  }
};
var LoadMaskable = (Target) => class LoadMaskable extends Target {
  static get $name() {
    return "LoadMaskable";
  }
  static get configurable() {
    return {
      loadMaskDefaults: {
        useTransition: true,
        showDelay: 1e3
      },
      loadMaskError: {
        icon: "b-icon b-icon-warning",
        autoClose: 3e3,
        showDelay: 0
      },
      loadMask: {
        text: "L{GridBase.loadMask}"
      },
      syncMask: {
        text: "L{GridBase.syncMask}"
      },
      localizableProperties: ["loadMask.text", "syncMask.text"],
      testConfig: {
        loadMaskError: {
          icon: "b-icon b-icon-warning",
          autoClose: 500,
          showDelay: 0
        }
      }
    };
  }
  applyLoadMask() {
    const me = this, {
      loadMask
    } = me;
    if (loadMask) {
      me.masked = Mask.mergeConfigs(me.loadMaskDefaults, loadMask);
    }
    return me.masked;
  }
  applyMaskError(error) {
    const {
      loadMaskError,
      masked
    } = this;
    if (loadMaskError === false) {
      masked.hide();
    } else if (masked) {
      ObjectHelper.assign(masked.errorDefaults, loadMaskError);
      masked.error = error;
    }
    return masked;
  }
  get widgetClass() {
  }
};
var excludedPropNames = {
  constructor: 1,
  prototype: 1,
  name: 1,
  length: 1,
  arguments: 1,
  caller: 1,
  callee: 1,
  __proto__: 1
};
var Override = class {
  static apply(override) {
    if (!override.target)
      throw new Error("Override must specify what it overrides, using static getter target");
    if (!override.target.class)
      throw new Error("Override must specify which class it overrides, using target.class");
    if (!this.shouldApplyOverride(override))
      return false;
    const staticKeys = Object.getOwnPropertyNames(override), instanceKeys = Object.getOwnPropertyNames(override.prototype);
    staticKeys.splice(staticKeys.indexOf("target"), 1);
    this.internalOverrideAll(override.target.class, staticKeys, override);
    this.internalOverrideAll(override.target.class.prototype, instanceKeys, override.prototype);
    return true;
  }
  static internalOverrideAll(targetClass, properties, overrideDefinition) {
    Reflect.ownKeys(overrideDefinition).forEach((key) => {
      if (properties.includes(key) && !excludedPropNames[key]) {
        const desc = Object.getOwnPropertyDescriptor(overrideDefinition, key);
        let currentTargetClass = targetClass;
        let targetProperty = null;
        while (!targetProperty && currentTargetClass) {
          targetProperty = Object.getOwnPropertyDescriptor(currentTargetClass, key);
          if (!targetProperty) {
            currentTargetClass = Object.getPrototypeOf(currentTargetClass);
          }
        }
        if (targetProperty) {
          this.internalOverride(currentTargetClass, key, desc, targetProperty);
        }
      }
    });
  }
  static internalOverride(target, key, desc, targetDesc) {
    const overrides = target._overridden = target._overridden || {};
    overrides[key] = target[key];
    if (targetDesc.get) {
      Object.defineProperty(target, key, {
        enumerable: false,
        configurable: true,
        get: desc.get
      });
    } else {
      target[key] = desc.value;
    }
  }
  static shouldApplyOverride(override) {
    const config = override.target;
    if (!config.maxVersion && !config.minVersion)
      return true;
    if (!config.product)
      throw new Error("Override must specify product when using versioning");
    if (config.maxVersion && VersionHelper[config.product].isNewerThan(config.maxVersion)) {
      return false;
    }
    if (config.minVersion && VersionHelper[config.product].isOlderThan(config.minVersion)) {
      return false;
    }
    return true;
  }
};
Override._$name = "Override";
var {
  defineProperty
} = Object;
var {
  hasOwn
} = ObjectHelper;
var fencibleSymbol = Symbol("fencible");
var NONE = [];
var distinct = (array) => Array.from(new Set(array));
var parseNames = (names) => names ? distinct(StringHelper.split(names)) : NONE;
var fenceMethod = (target, name, options) => {
  if (options === true) {
    options = name;
  }
  if (!ObjectHelper.isObject(options)) {
    options = {
      all: options
    };
  }
  let any = parseNames(options.any);
  const all = parseNames(options.all), lock = options.lock ? parseNames(options.lock) : distinct(all.concat(any)), implName = name + "Impl", fence = function(...params) {
    const me = this, fences = hasOwn(me, fencibleSymbol) ? me[fencibleSymbol] : me[fencibleSymbol] = {}, isFree = (key) => !fences[key];
    if (all.every(isFree) && (!any || any.some(isFree))) {
      try {
        lock.forEach((key) => fences[key] = (fences[key] || 0) + 1);
        return me[implName](...params);
      } finally {
        lock.forEach((key) => --fences[key]);
      }
    }
  };
  any = any.length ? any : null;
  !target[implName] && defineProperty(target, implName, {
    configurable: true,
    value: target[name]
  });
  defineProperty(target, name, {
    configurable: true,
    value: fence
  });
};
var Fencible = (Target) => {
  var _class;
  return _class = class Fencible extends (Target || Base) {
    static setupFenced(cls) {
      let {
        fenced
      } = cls;
      const statics = fenced.static, pairs = [];
      if (statics) {
        fenced = _objectSpread2({}, fenced);
        delete fenced.static;
        pairs.push([statics, cls]);
      }
      pairs.push([fenced, cls.prototype]);
      for (const [methods, target] of pairs) {
        for (const methodName in methods) {
          fenceMethod(target, methodName, methods[methodName]);
        }
      }
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "$name", "Fencible"), _defineProperty(_class, "declarable", [
    "fenced"
  ]), _class;
};
var MILLIS_PER_MINUTE = 60 * 1e3;
var MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;
var MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;
var timeRe = /(\d+)?:?(\d*)/;
var DayTime = class {
  static format(timeOfDay) {
    const h = Math.floor(timeOfDay / MILLIS_PER_HOUR), m = Math.floor(timeOfDay / MILLIS_PER_MINUTE) % 60;
    return `${h}:${m < 10 ? "0" : ""}${m}`;
  }
  static parse(time) {
    const type = typeof time;
    if (type === "string") {
      const match = timeRe.exec(time);
      time = Number(match[1] || 0) * MILLIS_PER_HOUR + Number(match[2] || 0) * MILLIS_PER_MINUTE;
    } else if (type !== "number") {
      time = DateHelper.getTimeOfDay(time);
    } else if (time <= 24) {
      time *= MILLIS_PER_HOUR;
    }
    return Math.min(Math.max(Math.floor(time), 0), MILLIS_PER_DAY);
  }
  constructor(config) {
    let startShift = 0, startTime, endTime;
    if (config !== null && config !== void 0 && config.isDayView) {
      startShift = config.dayStartShift;
      startTime = config.dayStartTime;
      endTime = config.dayEndTime;
    } else if (typeof config === "number") {
      startShift = startTime = endTime = config;
    } else if (config) {
      startShift = config.startShift;
      startTime = config.timeStart;
      endTime = config.timeEnd;
    }
    this.startShift = startShift = DayTime.parse(startShift || 0);
    this.timeEnd = (endTime == null ? (startShift + MILLIS_PER_DAY) % MILLIS_PER_DAY : DayTime.parse(endTime)) || MILLIS_PER_DAY;
    this.timeStart = startTime == null ? startShift : DayTime.parse(startTime);
  }
  get startHour() {
    return Math.floor(this.timeStart / MILLIS_PER_HOUR);
  }
  get endHour() {
    return Math.floor(this.timeEnd / MILLIS_PER_HOUR);
  }
  get startTimeOffsetMs() {
    const {
      startShift,
      timeStart
    } = this;
    return timeStart < startShift ? MILLIS_PER_DAY - startShift + timeStart : timeStart - startShift;
  }
  get today() {
    return this.startOfDay(new Date());
  }
  ceil(date) {
    const ret = this.startOfDay(date);
    if (ret < date) {
      ret.setDate(ret.getDate() + 1);
    }
    return ret;
  }
  contains(date) {
    return !this.outside(date);
  }
  dateKey(date) {
    date = this.shiftDate(date, -1);
    return DateHelper.makeKey(date);
  }
  dayOfDate(date) {
    return this.shiftDate(DateHelper.clearTime(date));
  }
  dayOfWeek(date) {
    date = this.shiftDate(date, -1);
    return date.getDay();
  }
  delta(date, unit = "ms") {
    const {
      timeStart
    } = this, time = DayTime.parse(date), t = (this.startShift && time < timeStart ? time + MILLIS_PER_DAY : time) - timeStart;
    return unit === "ms" ? t : DateHelper.as(unit, t, "ms");
  }
  duration(unit = "ms") {
    const {
      timeStart,
      timeEnd
    } = this, millis = timeStart < timeEnd ? timeEnd - timeStart : MILLIS_PER_DAY - timeStart + timeEnd;
    return unit === "ms" ? millis : DateHelper.as(unit, millis, "ms");
  }
  equals(other) {
    return this.startShift === (other === null || other === void 0 ? void 0 : other.startShift) && this.timeStart === other.timeStart && this.timeEnd === other.timeEnd;
  }
  intersects(startDate, endDate) {
    const me = this, {
      timeStart,
      timeEnd
    } = me, [date0, date1] = me._dateRangeArgs(startDate, endDate), [start, end] = me.timeRange(date0, date1);
    if (timeStart < timeEnd) {
      if (start < end) {
        return start < timeEnd && timeStart <= end;
      }
      return start < timeEnd || timeStart <= end;
    }
    return !(start < end) || start < timeEnd || timeStart <= end;
  }
  isIntraDay(startDate, endDate) {
    const me = this, [date0, date1] = me._dateRangeArgs(startDate, endDate), dayStart = me.startOfDay(date0), diff = MILLIS_PER_DAY - DateHelper.diff(dayStart, date1, "ms");
    if (diff < 0) {
      return false;
    }
    return diff > 0 || dayStart < date0;
  }
  isInterDay(timeSpan) {
    return timeSpan.allDay || !this.isIntraDay(...arguments);
  }
  outside(date) {
    const {
      startShift,
      timeStart,
      timeEnd
    } = this, time = DayTime.parse(date);
    if (timeStart < timeEnd) {
      if (time < timeStart) {
        return time < startShift ? 1 : -1;
      }
      if (time < timeEnd) {
        return 0;
      }
      return time < startShift ? -1 : 1;
    }
    if (time < timeEnd || time >= timeStart) {
      return 0;
    }
    return time < startShift ? 1 : -1;
  }
  parseKey(key) {
    return this.dayOfDate(DateHelper.parseKey(key));
  }
  shiftDate(date, direction = 1) {
    const {
      startShift
    } = this, type = typeof date;
    date = type === "number" ? new Date(date) : type === "string" ? DateHelper.parse(date) : new Date(date.getTime());
    if (direction && startShift) {
      date.setMilliseconds(direction > 0 ? startShift : -startShift);
    }
    return date;
  }
  sortEvents(date, events) {
    const startOfDay = this.startOfDay(date);
    return events === null || events === void 0 ? void 0 : events.sort((event1, event2) => {
      event1 = event1.eventRecord || event1;
      event2 = event2.eventRecord || event2;
      let {
        startDate: start1
      } = event1, {
        startDate: start2
      } = event2;
      if (!start1) {
        return -1;
      }
      if (!start2) {
        return 1;
      }
      start1 = start1 < startOfDay ? startOfDay : start1;
      start2 = start2 < startOfDay ? startOfDay : start2;
      return start1 - start2 || event2.endDate - start2 - (event1.endDate - start1);
    });
  }
  startOfDay(date) {
    date = this.shiftDate(date, -1);
    date = DateHelper.clearTime(date);
    date = this.shiftDate(date);
    return date;
  }
  timeRange(startDate, endDate) {
    const [start, end] = this._dateRangeArgs(startDate, endDate);
    return [DateHelper.getTimeOfDay(start), DateHelper.getTimeOfDay(end)];
  }
  toString() {
    const {
      startShift,
      timeEnd,
      timeStart
    } = this, suffix = startShift ? `@${DayTime.format(startShift)}` : "", prefix = DayTime.format(timeStart);
    if (timeStart === timeEnd) {
      return startShift ? suffix : prefix;
    }
    return `${prefix}-${DayTime.format(timeEnd)}${suffix}`;
  }
  _dateRangeArgs(startDate, endDate) {
    return startDate.isModel ? [startDate.startDate, startDate.endingDate] : [startDate, endDate];
  }
};
DayTime.MIDNIGHT = new DayTime({
  startShift: 0,
  timeStart: 0,
  timeEnd: 24
});
DayTime.MILLIS_PER_MINUTE = MILLIS_PER_MINUTE;
DayTime.MILLIS_PER_HOUR = MILLIS_PER_HOUR;
DayTime.MILLIS_PER_DAY = MILLIS_PER_DAY;
DayTime._$name = "DayTime";
var Month = class extends Events(Base) {
  static get configurable() {
    return {
      date: {
        $config: {
          equal: "date"
        },
        value: DateHelper.clearTime(new Date())
      },
      month: null,
      year: null,
      weekStartDay: null,
      hideNonWorkingDays: null,
      nonWorkingDays: null,
      sixWeeks: null
    };
  }
  configure(config) {
    super.configure(config);
    this.updateDayNumbers();
    if (config.date) {
      this.date = config.date;
    }
    this.generation = 0;
  }
  changeDate(date) {
    if (this.isConfiguring) {
      return;
    }
    date = typeof date === "string" ? DateHelper.parse(date, "YYYY-MM-DD") : new Date(date);
    if (isNaN(date)) {
      throw new Error("Month date ingestion must be passed a Date, or a valid YYYY-MM-DD date string");
    }
    return date;
  }
  updateDate(newDate, oldDate) {
    const me = this, {
      dayColumnIndex,
      weekCount
    } = me, monthStart = DateHelper.getFirstDateOfMonth(newDate), monthEnd = DateHelper.getLastDateOfMonth(monthStart), startWeekDay = dayColumnIndex[monthStart.getDay()], endWeekDay = dayColumnIndex[monthEnd.getDay()], yearChanged = !oldDate || newDate.getFullYear() !== oldDate.getFullYear(), monthChanged = !oldDate || newDate.getMonth() !== oldDate.getMonth(), changes = me.eventListeners && (oldDate ? newDate.getDate() !== oldDate.getDate() | (me.getWeekId(newDate) !== me.getWeekId(oldDate)) << 1 | monthChanged << 2 | yearChanged << 3 : 15);
    me._year = newDate.getFullYear();
    me._month = newDate.getMonth();
    me.startDayOfMonth = 1 - startWeekDay;
    me.endDayOfMonth = monthEnd.getDate() + (6 - endWeekDay);
    if (me.sixWeeks) {
      me.endDayOfMonth += (6 - me.weekCount) * 7;
    }
    if (!me.weekBase || yearChanged) {
      me.calculateWeekBase();
    }
    if (monthChanged || yearChanged) {
      me.generation++;
    }
    if (changes) {
      const event = {
        newDate,
        oldDate,
        changes: {
          d: true,
          w: Boolean(changes & 2),
          m: Boolean(changes & 12),
          y: Boolean(changes & 8),
          r: me.weekCount !== weekCount
        }
      };
      me.trigger("dateChange", event);
      if (changes & 2) {
        me.trigger("weekChange", event);
      }
      if (changes & 12) {
        me.trigger("monthChange", event);
      }
      if (changes & 8) {
        me.trigger("yearChange", event);
      }
    }
  }
  calculateWeekBase() {
    const me = this, {
      dayColumnIndex
    } = me, jan1 = new Date(me.year, 0, 1), dec31 = new Date(me.year, 11, 31), january = me.month ? me.getOtherMonth(jan1) : me;
    if (me.dayColumnIndex[jan1.getDay()] > 3) {
      me.weekBase = january.startDate;
    } else {
      me.weekBase = new Date(me.year, 0, january.startDayOfMonth - 7);
    }
    const dec31Week = Math.floor(DateHelper.diff(me.weekBase, dec31, "day") / 7);
    me.has53weeks = dec31Week === 53 && dayColumnIndex[dec31.getDay()] > 2;
  }
  getWeekStart(week) {
    if (typeof week === "number") {
      return DateHelper.add(this.weekBase, Math.max(week, 1) * 7, "day");
    }
    const me = this, [year, weekOfYear] = week;
    if (year === me.year) {
      return me.getWeekStart(weekOfYear);
    }
    return me.getOtherMonth(new Date(year, 0, 1)).getWeekStart(weekOfYear);
  }
  getOtherMonth(date) {
    const me = this, result = me === otherMonth ? new Month(null) : otherMonth;
    result.configure({
      weekBase: null,
      weekStartDay: me.weekStartDay,
      nonWorkingDays: me.nonWorkingDays,
      hideNonWorkingDays: me.hideNonWorkingDays,
      sixWeeks: me.sixWeeks,
      date: new Date(date.getFullYear(), 0, 1)
    });
    result.date = date;
    result.updateDate(result.date, result.date);
    return result;
  }
  changeYear(year) {
    const newDate = new Date(this.date);
    newDate.setFullYear(year);
    this.date = newDate;
  }
  changeMonth(month2) {
    const newDate = new Date(this.date);
    newDate.setMonth(month2);
    this.date = newDate;
  }
  get weekStartDay() {
    return typeof this._weekStartDay === "number" ? this._weekStartDay : DateHelper.weekStartDay;
  }
  updateWeekStartDay() {
    const me = this;
    me.updateDayNumbers();
    if (!me.isConfiguring && me.date) {
      me.weekBase = null;
      me.updateDate(me.date, me.date);
    }
  }
  get nonWorkingDays() {
    return this._nonWorkingDays || DateHelper.nonWorkingDays;
  }
  changeNonWorkingDays(nonWorkingDays) {
    return ObjectHelper.assign({}, nonWorkingDays);
  }
  updateNonWorkingDays() {
    this.updateDayNumbers();
  }
  updateHideNonWorkingDays() {
    this.updateDayNumbers();
  }
  updateSixWeeks() {
    if (!this.isConfiguring) {
      this.updateDate(this.date, this.date);
    }
  }
  get dayCount() {
    return this.endDayOfMonth + 1 - this.startDayOfMonth;
  }
  get weekCount() {
    return this.dayCount / 7;
  }
  get startDate() {
    const me = this;
    if (me.year != null && me.month != null && me.startDayOfMonth != null) {
      return new Date(me.year, me.month, me.startDayOfMonth);
    }
  }
  get endDate() {
    const me = this;
    if (me.year != null && me.month != null && me.startDayOfMonth != null) {
      return new Date(me.year, me.month, me.endDayOfMonth);
    }
  }
  eachDay(fn) {
    for (let dayOfMonth = this.startDayOfMonth; dayOfMonth <= this.endDayOfMonth; dayOfMonth++) {
      fn(new Date(this.year, this.month, dayOfMonth));
    }
  }
  eachWeek(fn) {
    const me = this, {
      weekCount
    } = me;
    for (let dayOfMonth = me.startDayOfMonth, week = 0; week < weekCount; week++) {
      const weekDates = [], weekOfYear = me.getWeekNumber(new Date(me.year, me.month, dayOfMonth));
      for (let day2 = 0; day2 < 7; day2++, dayOfMonth++) {
        weekDates.push(new Date(me.year, me.month, dayOfMonth));
      }
      fn(weekOfYear, weekDates);
    }
  }
  getWeekNumber(date) {
    const me = this;
    date = DateHelper.clearTime(date);
    if (date.getFullYear() !== me.year) {
      return me.getOtherMonth(new Date(date.getFullYear(), 0, 1)).getWeekNumber(date);
    }
    let weekNo = Math.floor(DateHelper.diff(me.weekBase, date, "day") / 7), year = date.getFullYear();
    if (!weekNo) {
      return me.getOtherMonth(new Date(me.year - 1, 0, 1)).getWeekNumber(new Date(me.year, 0, 0));
    } else if (weekNo === 53 && !me.has53weeks) {
      weekNo = 1;
      year++;
    } else if (weekNo > 53) {
      weekNo = weekNo % 52;
    }
    return [year, weekNo];
  }
  getWeekId(date) {
    const week = this.getWeekNumber(date);
    return week[0] * 100 + week[1];
  }
  getCellData(date, ownerMonth, dayTime = DayTime.MIDNIGHT) {
    const me = this, day2 = date.getDay(), visibleColumnIndex = me.visibleDayColumnIndex[day2], isNonWorking = me.nonWorkingDays[day2], isHiddenDay = me.hideNonWorkingDays && isNonWorking;
    if (date < me.startDate || date > me.endDate) {
      me.month = date.getMonth();
    }
    return {
      day: day2,
      dayTime,
      visibleColumnIndex,
      isNonWorking,
      week: me.getOtherMonth(date).getWeekNumber(date),
      key: DateHelper.format(date, "YYYY-MM-DD"),
      columnIndex: me.dayColumnIndex[day2],
      date: new Date(date),
      dayEnd: dayTime.duration("s"),
      tomorrow: dayTime.dayOfDate(DateHelper.add(date, 1, "day")),
      isOtherMonth: Math.sign(date.getMonth() + date.getFullYear() * 12 - (ownerMonth.month + ownerMonth.year * 12)),
      visible: !isHiddenDay && date >= ownerMonth.startDate && date < DateHelper.add(ownerMonth.endDate, 1, "day"),
      isRowStart: visibleColumnIndex === 0,
      isRowEnd: visibleColumnIndex === me.visibleColumnCount - 1
    };
  }
  updateDayNumbers() {
    const me = this, {
      weekStartDay,
      nonWorkingDays,
      hideNonWorkingDays
    } = me, dayColumnIndex = me.dayColumnIndex = [], canonicalDayNumbers = me.canonicalDayNumbers = [], visibleDayColumnIndex = me.visibleDayColumnIndex = [];
    let visibleColumnIndex = 0;
    for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
      const canonicalDay = (weekStartDay + columnIndex) % 7;
      canonicalDayNumbers[columnIndex] = canonicalDay;
      dayColumnIndex[canonicalDay] = columnIndex;
      if (!hideNonWorkingDays || !nonWorkingDays[canonicalDay]) {
        visibleDayColumnIndex[canonicalDay] = visibleColumnIndex++;
      }
    }
    me.visibleColumnCount = visibleColumnIndex;
    me.weekLength = hideNonWorkingDays ? 7 - ObjectHelper.keys(nonWorkingDays).length : 7;
  }
};
_defineProperty(Month, "$name", "Month");
var otherMonth = new Month(null);
Month._$name = "Month";
var nextObjectIdentity = 0;
var objectIdentityMap = /* @__PURE__ */ new WeakMap();
var argsToCacheKey = (...args) => args.map((arg) => {
  let result;
  if (arg && typeof arg == "object" || typeof arg == "function") {
    result = objectIdentityMap.get(arg);
    if (result === void 0) {
      result = ++nextObjectIdentity;
      objectIdentityMap.set(arg, result);
    }
  } else {
    result = String(arg);
  }
  return result;
}).join("-");
var memo = (fn) => {
  const mlist = /* @__PURE__ */ new Map();
  return (...args) => {
    const mkey = argsToCacheKey(args);
    let result = mlist.get(mkey);
    if (result === void 0) {
      result = fn(...args);
      mlist.set(mkey, result);
    }
    return result;
  };
};
var memoCps = (fn) => {
  const table = /* @__PURE__ */ new Map(), entryContinuations = (entry) => entry[0], entryResults = (entry) => entry[1], pushContinuation = (entry, cont) => entryContinuations(entry).push(cont), pushResult = (entry, result) => entryResults(entry).push(result), isResultSubsumed = (entry, result) => entryResults(entry).some((r) => ObjectHelper.isEqual(r, result)), makeEntry = () => [[], []], isEmptyEntry = (entry) => !entryResults(entry).length && !entryContinuations(entry).length, tableRef = (str) => {
    let entry = table.get(str);
    if (entry === void 0) {
      entry = makeEntry();
      table.set(str, entry);
    }
    return entry;
  };
  return (str, cont) => {
    const entry = tableRef(str);
    if (isEmptyEntry(entry)) {
      pushContinuation(entry, cont);
      fn(str, (result) => {
        if (!isResultSubsumed(entry, result)) {
          pushResult(entry, result);
          entryContinuations(entry).forEach((cont2) => cont2(result));
        }
      });
    } else {
      pushContinuation(entry, cont);
      entryResults(entry).forEach((result) => cont(result));
    }
  };
};
var SUCCESS = Symbol("success");
var FAILURE = Symbol("failure");
var success = (val, rest) => [SUCCESS, val, rest];
var failure = (rest) => [FAILURE, rest];
var isSuccess = (result) => result.length && result[0] === SUCCESS;
var resolveParser = (p) => typeof p === "function" && !p.length ? p() : p;
var succeed = memo((val) => memoCps((str, cont) => cont(success(val, str))));
var string = memo((match) => memoCps((str, cont) => {
  const len = Math.min(match.length, str.length), head = str.substr(0, len), tail = str.substr(len);
  cont(head === match ? success(head, tail) : failure(tail));
}));
var bind = (p, fn) => (str, cont) => resolveParser(p)(str, (result) => {
  if (isSuccess(result)) {
    const [, val, rest] = result;
    fn(val)(rest, cont);
  } else {
    cont(result);
  }
});
var seq = memo((...parsers2) => {
  const seq2 = memo((a, b) => memoCps(bind(a, (x) => bind(b, (y) => succeed([].concat(x, y))))));
  return parsers2.reduce(seq2, succeed([]));
});
var alt = memo((...parsers2) => memoCps((str, cont) => parsers2.forEach((p) => resolveParser(p)(str, cont))));
var regexp = memo((pattern) => (str, cont) => {
  const rexp = new RegExp(`^${pattern}`), match = rexp.exec(str);
  if (match) {
    const head = match[0], tail = str.substr(head.length);
    cont(success(head, tail));
  } else {
    cont(failure(str));
  }
});
var red = memo((p, fn) => bind(p, (...val) => succeed(fn(...[].concat.apply([], val)))));
var runParser = (body, str) => {
  const results = [];
  body(str, (result) => {
    if (isSuccess(result)) {
      const [, , left] = result;
      if (left === "") {
        results.push(result);
      }
    }
  });
  return results;
};
var defineParser = (body) => (str, cont) => cont ? resolveParser(body)(str, cont) : runParser(resolveParser(body), str);
var Parser = {
  memo,
  memoCps,
  success,
  failure,
  isSuccess,
  resolveParser,
  succeed,
  string,
  bind,
  seq,
  alt,
  regexp,
  red,
  runParser,
  defineParser
};
var ScrollManager = class extends Delayable(Base) {
  static get configurable() {
    return {
      element: null,
      zoneWidth: 50,
      scrollSpeed: 5,
      direction: "both",
      startScrollDelay: 500,
      stopScrollWhenPointerOut: false,
      testConfig: {
        scrollSpeed: 2,
        startScrollDelay: 100
      },
      activeScroll: {
        $config: ["lazy"],
        value: {}
      },
      monitoring: {
        $config: ["lazy", "nullify"],
        value: true
      },
      owner: null
    };
  }
  changeMonitoring(value, was) {
    was === null || was === void 0 ? void 0 : was.clear();
    return /* @__PURE__ */ new Map();
  }
  doDestroy() {
    this.stopMonitoring();
    super.doDestroy();
  }
  get isScrolling() {
    return Object.keys(this.activeScroll).length !== 0;
  }
  get rtl() {
    var _this$owner;
    return (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.rtl;
  }
  startMonitoring(config = {}) {
    const me = this, {
      element,
      direction: defaultDirection
    } = me, {
      scrollables = [],
      direction = defaultDirection,
      callback
    } = config, attachedElements = [];
    if (!scrollables.length) {
      scrollables.push({
        element
      });
    }
    scrollables.forEach((scrollable) => {
      const target = scrollable.element;
      if (typeof target === "string") {
        DomHelper.forEachSelector(element, target, (element2) => {
          me.createMonitor(element2, scrollable.direction || direction, scrollable.callback || callback);
          attachedElements.push(element2);
        });
      } else {
        me.createMonitor(target, scrollable.direction || direction, scrollable.callback || callback);
        attachedElements.push(target);
      }
    });
    return function detacher2() {
      var _me$stopMonitoring;
      (_me$stopMonitoring = me.stopMonitoring) === null || _me$stopMonitoring === void 0 ? void 0 : _me$stopMonitoring.call(me, attachedElements);
    };
  }
  createMonitor(element, direction, callback) {
    const {
      monitoring
    } = this;
    if (!monitoring.has(element)) {
      monitoring.set(element, new ScrollManagerMonitor({
        scrollManager: this,
        element,
        direction,
        callback
      }));
    }
  }
  stopMonitoring(element) {
    const me = this, {
      monitoring
    } = me;
    element = ArrayHelper.asArray(element);
    if (monitoring) {
      if (!element) {
        monitoring.forEach((monitor) => me.stopMonitoring(monitor.element));
        return;
      }
      element.forEach((element2) => {
        const monitor = monitoring.get(element2);
        element2.classList.remove("b-scrolling");
        if (monitor) {
          monitor.destroy();
          monitoring.delete(element2);
        }
      });
    }
  }
  requestScroll(direction, monitor) {
    const {
      activeScroll
    } = this;
    if (direction in activeScroll && activeScroll[direction] !== monitor) {
      return false;
    } else {
      activeScroll[direction] = monitor;
      return true;
    }
  }
  releaseScroll(monitor) {
    const {
      activeScroll = {}
    } = this;
    Object.keys(activeScroll).forEach((key) => {
      if (activeScroll[key] === monitor) {
        delete activeScroll[key];
      }
    });
  }
  getRelativeScroll(element, direction = "left") {
    let result = 0;
    this.monitoring.forEach((monitor, monitoredElement) => {
      if (DomHelper.isDescendant(monitoredElement, element)) {
        result += direction === "left" ? monitor.scrollRelativeLeft : monitor.scrollRelativeTop;
      }
    });
    return result;
  }
};
var ScrollManagerMonitor = class extends Base {
  construct(config) {
    const me = this, {
      element
    } = config, startScrollLeft = element.scrollLeft, startScrollTop = element.scrollTop;
    Object.assign(config, {
      startScrollLeft,
      startScrollTop
    });
    super.construct(config);
    EventHelper.on({
      element,
      scroll: "onElementScroll",
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      capture: true,
      thisObj: me
    });
    EventHelper.on({
      element,
      pointerleave: "onPointerLeave",
      thisObj: me
    });
  }
  doDestroy() {
    this.stopScroll();
    super.doDestroy();
  }
  startScroll() {
    this.scrolling = true;
    this.performScroll();
  }
  stopScroll() {
    const me = this;
    me.scrolling = false;
    if (me.scrollRequested) {
      me.scrollManager.cancelAnimationFrame(me.frameId);
      me.scrollRequested = false;
    }
    me.scrollManager.clearTimeout(me.scrollTimeout);
    me.scrollManager.releaseScroll(me);
    me.scrollTimeout = null;
  }
  onPointerLeave() {
    this.scrollManager.stopScrollWhenPointerOut && this.stopScroll();
  }
  onMouseMove(event) {
    const me = this, {
      scrollManager
    } = me, box = me.element.getBoundingClientRect(), width = scrollManager.zoneWidth, speed = scrollManager.scrollSpeed;
    me.scrollDeltaX = me.scrollDeltaY = 0;
    if (me.direction !== "vertical") {
      const {
        scrollLeft,
        scrollWidth,
        clientWidth
      } = me.element;
      if (scrollManager.rtl) {
        if (event.clientX < box.left + width && scrollWidth + scrollLeft - clientWidth >= 1) {
          me.scrollDeltaX = -Math.round((width + (box.left - event.clientX)) / speed) - 1;
        } else if (event.clientX > box.right - width && scrollLeft < 0) {
          me.scrollDeltaX = Math.round((width - (box.right - event.clientX)) / speed) + 1;
        }
      } else {
        if (event.clientX > box.right - width && scrollWidth - scrollLeft - clientWidth >= 1) {
          me.scrollDeltaX = Math.round((width - (box.right - event.clientX)) / speed) + 1;
        } else if (event.clientX < box.left + width && scrollLeft > 0) {
          me.scrollDeltaX = -Math.round((width + (box.left - event.clientX)) / speed) - 1;
        }
      }
    }
    if (me.direction !== "horizontal") {
      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = me.element;
      if (event.clientY > box.bottom - width && scrollHeight - scrollTop - clientHeight >= 1) {
        me.scrollDeltaY = Math.round((width - (box.bottom - event.clientY)) / speed) + 1;
      } else if (event.clientY < box.top + width && scrollTop > 0) {
        me.scrollDeltaY = -Math.round((width + (box.top - event.clientY)) / speed) - 1;
      }
    }
    if (me.scrollDeltaX !== 0 && !scrollManager.requestScroll("horizontal", me)) {
      me.scrollDeltaX = 0;
    }
    if (me.scrollDeltaY !== 0 && !scrollManager.requestScroll("vertical", me)) {
      me.scrollDeltaY = 0;
    }
    if (me.scrollDeltaX === 0 && me.scrollDeltaY === 0) {
      me.stopScroll();
    } else if (!me.scrollTimeout) {
      me.scrollTimeout = scrollManager.setTimeout(() => me.startScroll(), scrollManager.startScrollDelay);
    }
  }
  performScroll() {
    const me = this, {
      element
    } = me;
    if (me.scrolling && !me.scrollRequested) {
      if (me.scrollDeltaX !== 0) {
        const oldScrollLeft = element.scrollLeft, newScrollLeft = Math.min(oldScrollLeft + me.scrollDeltaX, element.scrollWidth - element.clientWidth);
        if (newScrollLeft !== oldScrollLeft) {
          element.scrollLeft = newScrollLeft;
        }
      }
      if (me.scrollDeltaY !== 0) {
        const oldScrollTop = element.scrollTop, newScrollTop = Math.min(oldScrollTop + me.scrollDeltaY, element.scrollHeight - element.clientHeight);
        if (newScrollTop !== oldScrollTop) {
          element.scrollTop = newScrollTop;
        }
      }
      me.scrollRequested = true;
      me.frameId = me.scrollManager.requestAnimationFrame(() => {
        me.scrollRequested = false;
        me.performScroll(me);
      });
    }
  }
  onElementScroll() {
    var _this$config, _this$config$callback;
    (_this$config = this.config) === null || _this$config === void 0 ? void 0 : (_this$config$callback = _this$config.callback) === null || _this$config$callback === void 0 ? void 0 : _this$config$callback.call(this.thisObj || this.scrollManager, this);
  }
  get scrollLeft() {
    return this.element.scrollLeft;
  }
  get scrollTop() {
    return this.verticalElement ? this.verticalElement.scrollTop : this.element.scrollTop;
  }
  get scrollRelativeLeft() {
    return this.scrollLeft - this.startScrollLeft;
  }
  get scrollRelativeTop() {
    return this.scrollTop - this.startScrollTop;
  }
  getRelativeLeftScroll(element) {
    return this.scrollManager.getRelativeScroll(element, "left");
  }
  getRelativeTopScroll(element) {
    return this.scrollManager.getRelativeScroll(element, "top");
  }
};
ScrollManager._$name = "ScrollManager";
var realignTransitions = {
  left: true,
  right: true,
  top: true,
  bottom: true,
  transform: true
};
var isBoolean = {
  true: 1,
  false: 1
};
var immediatePromise$2 = Promise.resolve();
var Tooltip = class extends Popup {
  static get $name() {
    return "Tooltip";
  }
  static get type() {
    return "tooltip";
  }
  static get configurable() {
    return {
      mouseOffsetX: 15,
      mouseOffsetY: 15,
      html: {
        $config: {
          equals: () => false
        }
      },
      getHtml: null,
      forElement: null,
      trackMouse: null,
      updateContentOnMouseMove: false,
      forSelector: null,
      hideOnDelegateChange: null,
      anchorToTarget: true,
      showOnHover: false,
      hoverDelay: 500,
      autoShow: false,
      dismissDelay: 0,
      hideDelay: 500,
      loadingMsg: "Loading...",
      allowOver: null,
      anchor: true,
      align: {
        align: "b-t",
        minHeight: 300
      },
      axisLock: true,
      activeTarget: null,
      testConfig: {
        hideDelay: 100,
        hoverDelay: 100,
        showAnimation: null,
        hideAnimation: null
      }
    };
  }
  afterConfigure() {
    const me = this, {
      forSelector
    } = me;
    if (forSelector) {
      me.showOnHover = true;
      if (!me.forElement) {
        if (!me.anchorToTarget) {
          me.trackMouse = true;
        }
        me.forElement = me.rootElement.host || me.rootElement;
      }
    }
    super.afterConfigure();
    if (me.forElement && me.showOnHover) {
      me.pointerOverOutDetacher = EventHelper.on({
        element: me.forElement,
        pointerover: "internalOnPointerOver",
        pointerout: "internalOnPointerOut",
        thisObj: me
      });
    }
  }
  doDestroy() {
    var _this$pointerOverOutD;
    (_this$pointerOverOutD = this.pointerOverOutDetacher) === null || _this$pointerOverOutD === void 0 ? void 0 : _this$pointerOverOutD.call(this);
    super.doDestroy();
  }
  set focusOnToFront(focusOnToFront) {
    super.focusOnToFront = focusOnToFront;
  }
  get focusOnToFront() {
    return super.focusOnToFront && DomHelper.usingKeyboard;
  }
  get focusElement() {
    const result = super.focusElement;
    if (result !== this.element) {
      return result;
    }
  }
  get anchorToTarget() {
    return this._anchorToTarget && !this.trackMouse;
  }
  get anchor() {
    return super.anchor && !this.trackMouse;
  }
  set anchor(anchor) {
    super.anchor = anchor;
  }
  onDocumentMouseDown({
    event
  }) {
    const me = this, {
      triggeredByEvent
    } = me;
    if (triggeredByEvent && DomHelper.isTouchEvent) {
      if (event.pageX === triggeredByEvent.pageX && event.pageY === triggeredByEvent.pageY && me.activeTarget.contains(event.target) && performance.now() - triggeredByEvent.timeStamp < 500) {
        return;
      }
    }
    me.abortDelayedShow();
    super.onDocumentMouseDown({
      event
    });
  }
  internalOnPointerOver(event) {
    const me = this, {
      target,
      relatedTarget
    } = event, {
      forElement,
      forSelector,
      activeTarget
    } = me;
    let newTarget;
    if (me.disabled || me.owner && !me.owner.showTooltipWhenDisabled && me.owner.disabled) {
      return;
    }
    if (me.allowOver && me.element.contains(target)) {
      return;
    }
    if (forSelector) {
      newTarget = target.closest(forSelector);
      if (activeTarget !== null && activeTarget !== void 0 && activeTarget.contains(target) && activeTarget.contains(relatedTarget) && newTarget === activeTarget) {
        return;
      }
      if (newTarget && (relatedTarget === null || relatedTarget === void 0 ? void 0 : relatedTarget.closest(forSelector)) === newTarget) {
        return;
      }
    } else if (!forElement.contains(relatedTarget)) {
      newTarget = forElement;
    } else {
      return;
    }
    if (newTarget) {
      me.handleForElementOver(event, newTarget);
    } else if (activeTarget) {
      me.handleForElementOut();
    }
  }
  onTransitionEnd(event) {
    const me = this, {
      currentOverElement
    } = Tooltip;
    if (realignTransitions[event.propertyName]) {
      var _me$activeTarget;
      if (me.allowOver && me.element.contains(currentOverElement)) {
        return;
      }
      if ((_me$activeTarget = me.activeTarget) !== null && _me$activeTarget !== void 0 && _me$activeTarget.contains(currentOverElement) && !me.trackMouse) {
        me.realign();
      }
    }
  }
  async handleForElementOver(event, newTarget) {
    const me = this, {
      activeTarget,
      hideOnDelegateChange,
      anchorToTarget
    } = me, isNewTarget = newTarget !== activeTarget, needsHide = isNewTarget && hideOnDelegateChange;
    if (me.trigger("pointerOver", {
      event,
      target: newTarget
    }) === false) {
      me.internalOnPointerOut(event);
    } else {
      me.triggeredByEvent = event;
      if (me.hasTimeout("hide")) {
        me.abortDelayedHide();
        if (!isNewTarget) {
          return;
        }
      }
      if (!hideOnDelegateChange && me.element.classList.contains("b-hiding")) {
        me.cancelHideShowAnimation();
      }
      if (!me._hidden && needsHide) {
        me.hide(false);
      }
      me.activeTarget = newTarget;
      if (me.isVisible) {
        const result = me.updateContent();
        if (Objects.isPromise(result) && !me.loadingMsg) {
          await result;
        }
        if (me.trigger("beforeShow") === false) {
          return me.hide();
        }
        me.alignTo({
          [anchorToTarget ? "target" : "position"]: anchorToTarget ? newTarget : "mouse",
          overlap: !(anchorToTarget && me.anchor)
        });
        me.trigger("show");
        me.afterShowByTarget();
      } else {
        me.delayShow(newTarget);
      }
    }
  }
  async delayShow(target) {
    var _me$currentAnimation;
    const me = this;
    if ((_me$currentAnimation = me.currentAnimation) !== null && _me$currentAnimation !== void 0 && _me$currentAnimation.showing) {
      me.cancelHideShowAnimation();
    }
    if (!me.isVisible && !me.hasTimeout("show")) {
      if (!me.hoverDelay || me.forSelector && Date.now() - me.lastHidden < me.quickShowInterval) {
        const result = me.updateContent();
        if (Objects.isPromise(result) && !me.loadingMsg) {
          await result;
        }
        me.showByTarget(target);
      } else {
        me.addDocumentMouseDownListener();
        if (!me.listeningForMouseMove && !me.anchorToTarget) {
          me.mouseMoveRemover = EventHelper.on({
            element: me.rootElement,
            mousemove: "onMouseMove",
            thisObj: me
          });
        }
        me.setTimeout(async () => {
          if (!DomHelper.isOrphaned(target)) {
            const result = me.updateContent();
            if (Objects.isPromise(result) && !me.loadingMsg) {
              await result;
            }
            me.showByTarget(target);
          }
        }, !me.triggeredByEvent || me.triggeredByEvent.type === "pointerover" ? me.hoverDelay : 0, "show");
      }
    } else if (me.isVisible) {
      me.showByTarget(target);
    }
  }
  changeAllowOver(allowOver) {
    if (!this.inAfterShow) {
      this.configuredAllowOver = allowOver;
    }
    return allowOver;
  }
  updateAllowOver(allowOver) {
    const me = this, {
      element
    } = me;
    element.classList.toggle("b-allow-over", Boolean(allowOver));
    if (allowOver) {
      me.allowOverlisteners = EventHelper.on({
        element,
        mouseenter: "onOwnElementMouseEnter",
        mouseleave: "internalOnPointerOut",
        thisObj: me
      });
    } else {
      var _me$allowOverlistener;
      (_me$allowOverlistener = me.allowOverlisteners) === null || _me$allowOverlistener === void 0 ? void 0 : _me$allowOverlistener.call(me);
    }
  }
  updateContent() {
    const me = this;
    if (me.getHtml) {
      const result = me.callback(me.getHtml, me, [{
        tip: me,
        element: me.element,
        activeTarget: me.activeTarget,
        event: me.triggeredByEvent
      }]);
      me.html = result;
      return result;
    }
  }
  get hasContent() {
    return Boolean(DomHelper.isReactElement(this._html) || this._html !== "" && typeof this.html === "string" && this.html.length || this.items.length);
  }
  internalBeforeShow() {
    return (this.updateContentOnMouseMove || this.hasContent) && !this.disabled;
  }
  showAsyncMessage(message = this.optionalL(this.loadingMsg)) {
    if (message) {
      this.html = `
                <div class="b-tooltip-loading">
                    <i class="b-icon b-icon-spinner"></i>
                    ${message}
                </div>
            `;
    }
  }
  beforeAlignTo(spec) {
    super.beforeAlignTo(spec);
    const me = this;
    if (!me.anchorToTarget && spec.position === "mouse") {
      spec.position = new Point(me.triggeredByEvent.pageX - globalThis.pageXOffset + me.mouseOffsetX * (me.rtl ? -1 : 1), me.triggeredByEvent.pageY - globalThis.pageYOffset + me.mouseOffsetY);
    }
  }
  showByTarget(target) {
    var _me$mouseMoveRemover;
    const me = this, {
      anchorToTarget
    } = me;
    me.mouseMoveRemover = (_me$mouseMoveRemover = me.mouseMoveRemover) === null || _me$mouseMoveRemover === void 0 ? void 0 : _me$mouseMoveRemover.call(me);
    me.showBy({
      [anchorToTarget ? "target" : "position"]: anchorToTarget ? target : "mouse",
      overlap: !(anchorToTarget && me.anchor)
    });
  }
  afterShowByTarget() {
    const me = this, {
      dismissDelay
    } = me;
    me.abortDelayedShow();
    if (dismissDelay) {
      me.setTimeout("hide", dismissDelay);
    }
    me.toFront();
    if (!me.mouseMoveRemover && (me.trackMouse || me.updateContentOnMouseMove)) {
      me.mouseMoveRemover = EventHelper.on({
        element: me.rootElement,
        pointermove: "onMouseMove",
        thisObj: me
      });
    }
    me.inAfterShow = true;
    me.allowOver = me.allowOver || me.configuredAllowOver != false && me.childItems.some((w) => w.isVisible && !w.disabled && w.focusElement);
    me.inAfterShow = false;
  }
  updateActiveTarget(newTarget, lastTarget) {
    if (newTarget && !this.isConfiguring) {
      this.trigger("overTarget", {
        newTarget,
        lastTarget
      });
    }
  }
  internalOnPointerOut(event) {
    var _me$activeTarget2;
    const me = this, toElement = event.relatedTarget;
    if (me.allowOver && me.element.contains(toElement)) {
      return;
    }
    if (me.element.contains(event.target) && (_me$activeTarget2 = me.activeTarget) !== null && _me$activeTarget2 !== void 0 && _me$activeTarget2.contains(toElement)) {
      return;
    }
    if (me.activeTarget && !me.activeTarget.contains(toElement)) {
      me.handleForElementOut();
    }
  }
  handleForElementOut() {
    const me = this, {
      hideDelay
    } = me;
    if (me.trigger("pointerOut") === false) {
      me.activeTarget = null;
      return;
    }
    me.abortDelayedShow();
    if (me.isVisible && hideDelay !== false) {
      me.abortDelayedHide();
      if (hideDelay > 0) {
        me.setTimeout("hide", hideDelay);
      } else {
        me.hide();
      }
    }
  }
  show(spec) {
    const me = this;
    if (!spec && me.forElement && me.anchorToTarget && !me.forSelector) {
      me.showByTarget(me.forElement);
    } else {
      super.show(...arguments);
    }
    me.afterShowByTarget();
    if (me.forElement && !me.transitionEndDetacher && !me._hidden) {
      me.transitionEndDetacher = EventHelper.on({
        element: me.forElement,
        transitionend: "onTransitionEnd",
        thisObj: me
      });
    }
  }
  hide() {
    const me = this;
    me.abortDelayedShow();
    if (!me._hidden) {
      var _me$mouseMoveRemover2, _me$transitionEndDeta;
      me.abortDelayedHide();
      const result = super.hide(...arguments);
      me.lastHidden = Date.now();
      me.activeTarget = null;
      (_me$mouseMoveRemover2 = me.mouseMoveRemover) === null || _me$mouseMoveRemover2 === void 0 ? void 0 : _me$mouseMoveRemover2.call(me);
      me.mouseMoveRemover = null;
      (_me$transitionEndDeta = me.transitionEndDetacher) === null || _me$transitionEndDeta === void 0 ? void 0 : _me$transitionEndDeta.call(me);
      me.transitionEndDetacher = null;
      return result;
    } else {
      return immediatePromise$2;
    }
  }
  abortDelayedShow() {
    const me = this;
    if (me.hasTimeout("show")) {
      var _me$mouseDownRemover, _me$mouseMoveRemover3, _me$transitionEndDeta2;
      (_me$mouseDownRemover = me.mouseDownRemover) === null || _me$mouseDownRemover === void 0 ? void 0 : _me$mouseDownRemover.call(me);
      me.mouseDownRemover = null;
      me.clearTimeout("show");
      (_me$mouseMoveRemover3 = me.mouseMoveRemover) === null || _me$mouseMoveRemover3 === void 0 ? void 0 : _me$mouseMoveRemover3.call(me);
      me.mouseMoveRemover = null;
      (_me$transitionEndDeta2 = me.transitionEndDetacher) === null || _me$transitionEndDeta2 === void 0 ? void 0 : _me$transitionEndDeta2.call(me);
      me.transitionEndDetacher = null;
    }
  }
  abortDelayedHide() {
    this.clearTimeout("hide");
  }
  realign() {
    const me = this, spec = me.lastAlignSpec;
    if (!me.isConfiguring && !me.isVisible && spec !== null && spec !== void 0 && spec.targetOutOfView) {
      if (spec.allowTargetOut || DomHelper.isInView(spec.target, false, me)) {
        me.show();
        spec.targetOutOfView = false;
      }
    }
    super.realign();
  }
  alignTo(spec) {
    const me = this;
    if (!me.isVisible) {
      return;
    }
    if (spec && !(me.triggeredByEvent && me.element.contains(me.triggeredByEvent.target))) {
      if (spec.nodeType === Node.ELEMENT_NODE) {
        spec = {
          target: spec
        };
      }
    }
    super.alignTo(spec);
  }
  changeHtml(htmlOrPromise) {
    const me = this;
    if (Objects.isPromise(htmlOrPromise)) {
      me.showAsyncMessage();
      htmlOrPromise.target = me.activeTarget;
      htmlOrPromise.then((html) => {
        if (htmlOrPromise.target === me.activeTarget) {
          me.html = html;
        }
      });
      return;
    }
    if (typeof htmlOrPromise !== "object") {
      htmlOrPromise = htmlOrPromise != null ? me.optionalL(String(htmlOrPromise)) : "";
    }
    return htmlOrPromise;
  }
  updateHtml(value, was) {
    const me = this;
    let empty2 = value === "";
    if (!empty2) {
      super.updateHtml(value, was);
      if (me.hasContent) {
        if (me.isVisible) {
          me.realign();
        }
        if (!Objects.isPromise(value)) {
          me.trigger("innerHtmlUpdate", {
            value
          });
        }
      } else {
        empty2 = true;
      }
    }
    if (empty2) {
      me.hide();
    }
  }
  onMouseMove(event) {
    const me = this, {
      forElement,
      activeTarget
    } = me, isHiding = me.hasTimeout("hide"), target = event.target;
    me.triggeredByEvent = event;
    if (!me._hidden) {
      let hideVetoed;
      const isWithinTarget = activeTarget === null || activeTarget === void 0 ? void 0 : activeTarget.contains(target), isElementOut = !isWithinTarget && me.forSelector && activeTarget && !isHiding && target.nodeType === Node.ELEMENT_NODE && !target.matches(me.forSelector) && !(me.allowOver && me.element.contains(target)), containingElement = forElement !== null && forElement !== void 0 && forElement.document ? forElement.document.documentElement : forElement, forElementContainsTarget = containingElement && (containingElement.contains ? containingElement.contains(target) : containingElement.compareDocumentPosition(target) & 16);
      if (isElementOut) {
        hideVetoed = me.handleForElementOut();
      }
      if (hideVetoed || !isHiding || forElementContainsTarget) {
        if (me.dismissDelay && !isHiding) {
          me.setTimeout("hide", me.dismissDelay);
        }
        if (me.updateContentOnMouseMove && me.getHtml) {
          me.html = me.callback(me.getHtml, me, [{
            tip: me,
            element: me.element,
            forElement: activeTarget,
            event
          }]);
          if (!me.html) {
            me.hide();
            return;
          }
        }
        if (me.trackMouse) {
          me.alignTo({
            position: "mouse",
            ignorePageScroll: true
          });
        }
      }
    }
  }
  onOwnElementMouseEnter(event) {
    this.abortDelayedHide();
  }
  static getSharedTooltip(rootElement, skipCreating) {
    var _rootElement$bryntum, _rootElement$bryntum$;
    let sharedTooltip = (_rootElement$bryntum = rootElement.bryntum) === null || _rootElement$bryntum === void 0 ? void 0 : (_rootElement$bryntum$ = _rootElement$bryntum.tooltip) === null || _rootElement$bryntum$ === void 0 ? void 0 : _rootElement$bryntum$.get(Tooltip);
    if (!sharedTooltip && !skipCreating) {
      var _rootElement$bryntum2;
      if (!((_rootElement$bryntum2 = rootElement.bryntum) !== null && _rootElement$bryntum2 !== void 0 && _rootElement$bryntum2.tooltip)) {
        ObjectHelper.setPath(rootElement, "bryntum.tooltip", /* @__PURE__ */ new Map());
      }
      const map = rootElement.bryntum.tooltip;
      map.set(Tooltip, true);
      sharedTooltip = new Tooltip({
        forElement: rootElement,
        rootElement,
        forSelector: "[data-btip]",
        resetCfg: {},
        isShared: true,
        cls: "b-tooltip-shared",
        internalListeners: {
          pointerOver({
            source: me,
            target
          }) {
            for (const key in me.resetCfg) {
              if (key === "listeners") {
                me.un(me.resetCfg[key].set);
              } else if (key !== "html") {
                me[key] = me.resetCfg[key].was;
              }
            }
            me.resetCfg = {};
            const forComponent = Widget.getById(target.id), config = (forComponent === null || forComponent === void 0 ? void 0 : forComponent.tipConfig) || me.gatherDataConfigs(target.dataset);
            if (forComponent && forComponent.element !== target || !forComponent && target.matches(".b-widget") || forComponent !== null && forComponent !== void 0 && forComponent.disabled && !forComponent.showTooltipWhenDisabled) {
              return false;
            }
            me.owner = forComponent;
            for (const key in config) {
              me.resetCfg[key] = {
                set: config[key],
                was: me[key]
              };
              if (key === "listeners") {
                me.ion(config[key]);
              } else {
                me[key] = config[key];
              }
            }
          },
          hide({
            source: me
          }) {
            me.owner = null;
          }
        },
        gatherDataConfigs(dataset) {
          const me = this, config = {};
          for (const key in dataset) {
            if (key.startsWith("btip")) {
              if (key.length > 4) {
                const configProp = StringHelper.uncapitalize(key.substr(4));
                if (configProp in me.getDefaultConfiguration()) {
                  const value = dataset[key];
                  config[configProp] = isBoolean[value] ? value === "true" : isNaN(value) ? value : parseInt(value, 10);
                }
              } else {
                config.html = dataset[key];
              }
            }
          }
          return config;
        }
      });
      EventHelper.on({
        element: rootElement,
        mouseenter: (event) => Tooltip.currentOverElement = event.target,
        keydown: (event) => Tooltip.currentOverElement = event.target,
        capture: true,
        thisObj: sharedTooltip
      });
      map.set(Tooltip, sharedTooltip);
    }
    return sharedTooltip;
  }
  static encodeConfig(tooltip) {
    const dataset = {};
    if (typeof tooltip === "string") {
      dataset.btip = tooltip;
    } else {
      for (const config in tooltip) {
        dataset[`btip${config === "html" ? "" : StringHelper.capitalize(config)}`] = tooltip[config];
      }
    }
    return dataset;
  }
};
Tooltip.initClass();
Object.defineProperty(Widget, "tooltip", {
  get() {
    return Tooltip.getSharedTooltip(document.body);
  }
});
Widget.Tooltip = Tooltip;
Tooltip._$name = "Tooltip";
var DragTipProxy = class extends DragProxy {
  static get type() {
    return "tip";
  }
  static get configurable() {
    return {
      align: "t10-b50",
      offset: 20,
      tooltip: {
        $config: ["lazy", "nullify"],
        value: {
          type: "tooltip"
        }
      }
    };
  }
  open() {
    this.getConfig("tooltip");
  }
  close() {
    var _this$tooltip;
    (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.hide();
  }
  dragMove(drag) {
    const {
      offset,
      tooltip
    } = this, {
      event
    } = drag;
    if (tooltip) {
      if (!tooltip.isVisible) {
        tooltip.show();
      }
      tooltip.alignTo({
        align: this.align,
        target: new Rectangle(event.clientX - offset, event.clientY - offset, offset * 2, offset * 2)
      });
    }
  }
  changeTooltip(config, existing) {
    return Widget.reconfigure(existing, config, this);
  }
};
DragTipProxy.initClass();
DragTipProxy._$name = "DragTipProxy";
var Labelable = (Target) => class Labelable extends (Target || Base) {
  static get $name() {
    return "Labelable";
  }
  static get configurable() {
    return {
      label: null,
      labelPosition: "before",
      labelCls: null,
      labelWidth: {
        value: null,
        $config: {
          localeKey: "L{labelWidth}"
        }
      }
    };
  }
  get hasLabel() {
    return Boolean(this.label);
  }
  compose() {
    const {
      hasLabel,
      labelPosition
    } = this;
    return {
      class: {
        [`b-label-${labelPosition}`]: hasLabel,
        "b-has-label": hasLabel
      }
    };
  }
  changeLabel(label) {
    return label || "";
  }
  setupLabel(lbl) {
    return ObjectHelper.assign({
      tag: "label",
      for: `${this.id}-input`,
      class: `b-label b-align-${lbl.align || "start"}`
    }, lbl);
  }
  updateLabelWidth(newValue) {
    if (this.labelElement) {
      this.labelElement.style.flex = `0 0 ${DomHelper.setLength(newValue)}`;
      this.inputWrap.style.flexBasis = newValue == null ? "" : "auto";
    }
  }
  get widgetClass() {
  }
};
var FieldContainer = class extends Container {
  static get $name() {
    return "FieldContainer";
  }
  static get type() {
    return "fieldcontainer";
  }
  static get configurable() {
    return {
      animation: {
        duration: 300
      },
      collapsed: null,
      collapser: {
        value: null,
        $config: "nullify"
      },
      syncableConfigs: null,
      syncConfigTriggers: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      testConfig: {
        animation: {
          duration: 10
        }
      }
    };
  }
  static get delayable() {
    return {
      syncChildConfigs: "raf"
    };
  }
  get inline() {
    var _this$owner$inline;
    return (_this$owner$inline = this.owner.inline) !== null && _this$owner$inline !== void 0 ? _this$owner$inline : this.ensureItems().count === 1;
  }
  changeCollapsed(collapsed) {
    if (this.togglingCollapse) {
      this.togglingCollapse = false;
      return collapsed;
    }
    this.toggleCollapse(Boolean(collapsed));
  }
  updateCollapsed(collapsed) {
    var _this$collapser;
    this.collapser = (_this$collapser = this.collapser) === null || _this$collapser === void 0 ? void 0 : _this$collapser.destroy();
    this.setCollapsedCls(collapsed);
  }
  updateCollapser(collapser, was) {
    if (was && was.completed == null) {
      if (!was.reverting || !collapser) {
        was.destroy();
      }
    }
    this.setOwnerCls("b-collapsing", collapser);
  }
  get collapsing() {
    const {
      collapser
    } = this;
    return collapser != null && collapser.collapsed;
  }
  get collapsingExpanding() {
    return this.collapser != null;
  }
  get expanding() {
    const {
      collapser
    } = this;
    return collapser != null && !collapser.collapsed;
  }
  collapse(animation) {
    this.toggleCollapse(true, animation);
  }
  expand(animation) {
    this.toggleCollapse(false, animation);
  }
  setCollapsedCls(collapsed) {
    this.setOwnerCls("b-collapsed", collapsed);
  }
  setOwnerCls(cls, state) {
    var _this$owner, _this$owner$element;
    (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : (_this$owner$element = _this$owner.element) === null || _this$owner$element === void 0 ? void 0 : _this$owner$element.classList[state ? "add" : "remove"](cls);
  }
  syncChildConfigs() {
    const me = this, {
      owner,
      syncableConfigs
    } = me;
    if (syncableConfigs) {
      let destProp, val;
      for (destProp in syncableConfigs) {
        val = syncableConfigs[destProp](owner);
        me.eachWidget((item) => {
          item[destProp] = val;
        }, false);
      }
    }
    owner.afterSyncChildConfigs(me);
  }
  syncContainer() {
    const {
      inline,
      layout
    } = this;
    if (this.autoLayout) {
      layout.horizontal = inline;
      layout.justify = inline ? "center" : "stretch";
    }
  }
  toggleCollapse(collapsed, animation) {
    const me = this, {
      animation: collapseAnimation,
      collapser,
      inline
    } = me, {
      containerWrapElement
    } = me.owner, finalize = (complete) => {
      if (complete) {
        me.element.style.height = "";
        me.togglingCollapse = true;
        me.collapsed = collapsed;
        me.collapser = null;
      }
    };
    if (collapsed == null) {
      collapsed = !me.collapsed;
    }
    if (animation !== false && animation !== null) {
      if (!containerWrapElement || !me.isVisible) {
        animation = null;
      } else {
        if (animation === true) {
          animation = {};
        } else if (typeof animation === "number") {
          animation = {
            duration: animation
          };
        }
        animation = collapseAnimation || animation ? ObjectHelper.merge({}, collapseAnimation, animation) : null;
      }
    }
    if (!animation) {
      me.togglingCollapse = true;
      me.collapsed = collapsed;
    } else if (collapser && collapsed !== collapser.collapsed) {
      me.collapser = collapser.revert({
        finalize
      });
      me.collapser.collapsed = collapsed;
    } else if (!collapser && collapsed !== me.collapsed) {
      !collapsed && me.setCollapsedCls(false);
      const {
        element
      } = me, {
        height
      } = element.getBoundingClientRect(), expanded = inline ? 1 : height;
      !collapsed && me.setCollapsedCls(true);
      element.style.height = `${height}px`;
      me.collapser = Animator.run(ObjectHelper.merge({
        finalize,
        element: containerWrapElement,
        [inline ? "opacity" : "height"]: {
          from: collapsed ? expanded : 0,
          to: collapsed ? 0 : expanded
        }
      }, animation));
      me.collapser.collapsed = collapsed;
    }
  }
};
FieldContainer.initClass();
FieldContainer._$name = "FieldContainer";
var byWeight = (l, r) => (l.weight || 0) - (r.weight || 0);
var byWeightReverse = (l, r) => (r.weight || 0) - (l.weight || 0);
var emptyArray$1 = [];
var triggerConfigs = {
  align: true,
  weight: true
};
var Field = class extends Widget.mixin(Badge, Labelable) {
  static get $name() {
    return "Field";
  }
  static get type() {
    return "field";
  }
  static get configurable() {
    return {
      defaultBindProperty: "value",
      placeholder: null,
      value: "",
      name: null,
      labels: null,
      required: null,
      clearable: null,
      revertOnEscape: null,
      hint: null,
      hintHtml: null,
      inputWidth: null,
      keyStrokeChangeDelay: 0,
      readOnly: null,
      editable: true,
      defaultAction: "change",
      triggers: null,
      highlightExternalChange: true,
      localizableProperties: ["label", "title", "placeholder", "labelWidth"],
      autoSelect: false,
      autoComplete: "off",
      spellCheck: null,
      validateOnInput: true,
      inputAttributes: null,
      inputType: "text",
      inputAlign: null,
      attributes: {
        value: ["placeholder", "autoComplete", "spellCheck", "minLength", "maxLength", "pattern", "tabIndex", "min", "max"],
        $config: {
          merge: "distinct"
        }
      },
      nullValue: {
        $config: null,
        value: null,
        default: null
      },
      updatedClsDuration: 500,
      inputReadOnly: false,
      ariaElement: "input",
      container: {
        $config: "nullify",
        value: null
      },
      containerDefaults: {
        type: "fieldcontainer",
        syncableConfigs: {
          disabled: (field) => field.disabled
        },
        syncConfigTriggers: {
          disabled: 1
        }
      },
      containValues: null,
      inline: null,
      testConfig: {
        updatedClsDuration: 10
      },
      keyMap: {}
    };
  }
  static get delayable() {
    return {
      highlightChanged: "raf"
    };
  }
  doDestroy() {
    var _me$inputListenerRemo, _me$keyListenerRemove, _me$container;
    const me = this, {
      triggers
    } = me, errorTip = me.isPainted && Field.getSharedErrorTooltip(me.rootElement, true);
    (_me$inputListenerRemo = me.inputListenerRemover) === null || _me$inputListenerRemo === void 0 ? void 0 : _me$inputListenerRemo.call(me);
    (_me$keyListenerRemove = me.keyListenerRemover) === null || _me$keyListenerRemove === void 0 ? void 0 : _me$keyListenerRemove.call(me);
    (_me$container = me.container) === null || _me$container === void 0 ? void 0 : _me$container.destroy();
    super.doDestroy();
    if (triggers) {
      for (const t of Object.values(triggers)) {
        t.destroy();
      }
    }
    if ((errorTip === null || errorTip === void 0 ? void 0 : errorTip.field) === me) {
      errorTip.hide();
    }
  }
  get childItems() {
    const {
      container,
      triggers
    } = this, ret = triggers ? Object.values(triggers) : [];
    return container ? [...ret, ...container.childItems] : ret;
  }
  get invalidValueError() {
    return "L{invalidValue}";
  }
  get errorTip() {
    return this.constructor.getSharedErrorTooltip(this.rootElement);
  }
  static getSharedErrorTooltip(rootElement, doNotCreate) {
    var _rootElement$bryntum;
    let sharedErrorTooltip = (_rootElement$bryntum = rootElement.bryntum) === null || _rootElement$bryntum === void 0 ? void 0 : _rootElement$bryntum.errorTooltip;
    if (!sharedErrorTooltip && !doNotCreate) {
      rootElement.bryntum = rootElement.bryntum || {};
      sharedErrorTooltip = new Tooltip({
        cls: "b-field-error-tip",
        forSelector: ".b-field.b-invalid .b-field-inner",
        align: {
          align: "l-r",
          monitorTargetMutation: true
        },
        scrollAction: "realign",
        trapFocus: false,
        rootElement,
        onBeforeShow() {
          const tip = this, field = Widget.fromElement(tip.activeTarget);
          if (field) {
            const errors = field.getErrors();
            if (errors) {
              tip.html = errors.join("<br>");
              tip.field = field;
              return true;
            }
          }
          return false;
        }
      });
      rootElement.bryntum.errorTooltip = sharedErrorTooltip;
    }
    return sharedErrorTooltip;
  }
  static get errorTip() {
    return this.getSharedErrorTooltip(document.body);
  }
  construct(config) {
    super.construct(config);
    const me = this;
    if (me.keyStrokeChangeDelay) {
      me.changeOnKeyStroke = me.buffer(me.internalOnChange, me.keyStrokeChangeDelay);
    }
  }
  changeKeyMap(keyMap) {
    const me = this;
    let mergedKeyMap = {};
    if (keyMap) {
      if (!me._fieldKeyMap) {
        me._fieldKeyMap = keyMap;
        ObjectHelper.assign(mergedKeyMap, keyMap);
      } else {
        ObjectHelper.assign(mergedKeyMap, me._fieldKeyMap);
      }
    }
    for (const triggerName in me.triggers) {
      var _me$triggers$triggerN;
      if ((_me$triggers$triggerN = me.triggers[triggerName]) !== null && _me$triggers$triggerN !== void 0 && _me$triggers$triggerN.keyMap) {
        mergedKeyMap = me.mergeKeyMaps(mergedKeyMap, me.triggers[triggerName].keyMap, triggerName);
      }
    }
    return mergedKeyMap;
  }
  get keyMapSubComponents() {
    return this.triggers;
  }
  onFocusIn(e) {
    const me = this;
    me.valueOnFocus = ObjectHelper.clone(me.value);
    me.validOnFocus = !(me.errors && Object.keys(me.errors).length);
    super.onFocusIn(e);
    me.focusing = true;
    me.syncInvalid();
    me.focusing = false;
  }
  onFocusOut(e) {
    super.onFocusOut(e);
    this.syncRequired();
    this.onEditComplete();
  }
  onEditComplete() {
  }
  get rootUiClass() {
    return Field;
  }
  compose() {
    this.getConfig("clearable");
    const me = this, {
      container,
      innerElements,
      label,
      labels,
      labelCls,
      readOnly,
      triggers
    } = me, triggerInstances = ObjectHelper.values(triggers, (k, v) => !v), startTriggers = triggerInstances.filter((t) => t.align === "start").sort(byWeight), endTriggers = triggerInstances.filter((t) => t.align !== "start").sort(byWeightReverse), setupLabel = me.setupLabel.bind(me), innerChildren = [...startTriggers.map((t) => t.element), ...innerElements, ...endTriggers.map((t) => t.element)];
    return {
      class: {
        "b-has-start-trigger": startTriggers.length,
        "b-no-input": !innerElements.length,
        "b-readonly": readOnly,
        "b-field-container": Boolean(container),
        "b-field-container-inline": container === null || container === void 0 ? void 0 : container.inline
      },
      children: [...(labels || emptyArray$1).filter((t) => t && t.align !== "end").map(setupLabel), (label || null) && setupLabel({
        reference: "labelElement",
        class: `b-label b-align-start ${labelCls || ""}`,
        html: label
      }), innerChildren.length ? {
        class: "b-field-inner",
        reference: "inputWrap",
        children: innerChildren
      } : null, ...(labels || emptyArray$1).filter((t) => (t === null || t === void 0 ? void 0 : t.align) === "end").map(setupLabel), ...container ? [{
        reference: "containerWrapElement",
        children: [container.element],
        class: {
          "b-field-container-wrap": 1
        }
      }] : emptyArray$1]
    };
  }
  updateElement(element, was) {
    var _me$keyListenerRemove2;
    const me = this, value = me.initialConfig.value, {
      input
    } = me;
    super.updateElement(element, was);
    if (value != null) {
      me.value = value;
    }
    me.syncEmpty();
    me.updateInputReadOnly(me.inputReadOnly);
    me.syncInvalid();
    const keyEventElement = input || me.focusElement;
    (_me$keyListenerRemove2 = me.keyListenerRemover) === null || _me$keyListenerRemove2 === void 0 ? void 0 : _me$keyListenerRemove2.call(me);
    me.keyListenerRemover = keyEventElement && EventHelper.on({
      element: keyEventElement,
      thisObj: me,
      keydown: "internalOnKeyEvent",
      keypress: "internalOnKeyEvent",
      keyup: "internalOnKeyEvent"
    });
  }
  get innerElements() {
    return [this.inputElement];
  }
  get inputElement() {
    const {
      attributes,
      inputAttributes,
      id,
      inputCls,
      inputType,
      name
    } = this, domConfig = ObjectHelper.assign({
      reference: "input",
      tag: "input",
      type: inputType,
      name: name || id,
      id: `${id}-input`,
      retainElement: true
    }, inputAttributes);
    if (inputCls) {
      domConfig.class = inputCls;
    }
    for (let key, value, i = attributes.length; i-- > 0; ) {
      key = attributes[i];
      value = this[key];
      if (value != null) {
        domConfig[key] = value;
      }
    }
    return domConfig;
  }
  get caretPos() {
    return this.textSelection[0];
  }
  set caretPos(value) {
    this.textSelection = value;
  }
  get focusElement() {
    return this.input;
  }
  get textSelection() {
    const input = this.input;
    let ret;
    try {
      ret = [input.selectionStart, input.selectionEnd, input.selectionDirection];
    } catch (e) {
      var _input$value;
      ret = ((_input$value = input.value) === null || _input$value === void 0 ? void 0 : _input$value.length) || 0;
      ret = [ret, ret];
    }
    return ret;
  }
  set textSelection(value) {
    if (typeof value === "number") {
      this.select(value, value);
    } else {
      this.select(...value);
    }
  }
  get hasTextSelection() {
    const [selectionStart, selectionEnd] = this.textSelection;
    return selectionStart && selectionEnd - selectionStart > 0;
  }
  getAfterValue(text) {
    const [begin, end] = this.textSelection, value = this.input.value;
    return `${value.substr(0, begin)}${text}${value.substr(end || begin)}`;
  }
  select(start, end) {
    const input = this.focusElement;
    if (input.value.length) {
      if (arguments.length === 0) {
        this.selectAll();
        return;
      }
      if (!this.supportsTextSelection) {
        return;
      }
      input.setSelectionRange(start, end);
    }
  }
  moveCaretToEnd() {
    const input = this.input;
    if (input.createTextRange) {
      const range = input.createTextRange();
      range.collapse(false);
      range.select();
    } else if (this.supportsTextSelection) {
      this.select(input.value.length, input.value.length);
    }
  }
  selectAll() {
    this.focusElement.select();
  }
  syncEmpty() {
    var _this$triggers;
    const {
      isEmptyInput,
      isEmpty,
      element
    } = this, clear = (_this$triggers = this.triggers) === null || _this$triggers === void 0 ? void 0 : _this$triggers.clear, empty2 = isEmptyInput && isEmpty;
    if (element) {
      if (clear) {
        clear[empty2 ? "hide" : "show"]();
      }
      element.classList.toggle("b-empty", empty2);
    }
  }
  updateHint() {
    this.syncHint();
  }
  updateHintHtml() {
    this.syncHint();
  }
  syncHint() {
    const me = this, {
      input,
      hint,
      hintHtml
    } = me, parent = input === null || input === void 0 ? void 0 : input.parentElement;
    if (input) {
      let hintValue = hintHtml || hint;
      const hintElement = me.hintElement || hintValue && (me.hintElement = DomHelper.createElement({
        parent,
        className: "b-field-hint",
        nextSibling: input.nextSibling,
        children: [{
          className: "b-field-hint-content"
        }]
      }));
      if (hintElement) {
        if (typeof hintValue === "function") {
          hintValue = hintValue({
            source: me,
            value: me.value
          });
        }
        hintElement.firstChild[hintHtml ? "innerHTML" : "textContent"] = hintValue || "";
      }
      me.element.classList[hintValue ? "remove" : "add"]("b-field-no-hint");
    }
  }
  syncInvalid() {
    const me = this, {
      isPainted
    } = me;
    me.updatingInvalid = true;
    if (isPainted) {
      const {
        isValid,
        element,
        inputWrap
      } = me;
      element.classList[isValid ? "remove" : "add"]("b-invalid");
      if (isValid) {
        const errorTip = me.constructor.getSharedErrorTooltip(me.rootElement, true);
        if (errorTip !== null && errorTip !== void 0 && errorTip.isVisible && errorTip.field === me) {
          errorTip.hide();
        }
      } else {
        const errorTip = me.errorTip;
        if (errorTip && (me.containsFocus || me.isVisible && inputWrap.contains(Tooltip.currentOverElement))) {
          if (errorTip.activeTarget === inputWrap && errorTip.isVisible) {
            errorTip.onBeforeShow();
          } else {
            errorTip.activeTarget = inputWrap;
            errorTip.showBy(inputWrap);
          }
        }
      }
    }
    me.updatingInvalid = false;
  }
  updateEditable() {
    this.syncInputReadOnly();
  }
  syncInputReadOnly() {
    this.getConfig("readOnly");
    this.inputReadOnly = this._readOnly || this.editable === false;
  }
  updateInputReadOnly(readOnly) {
    const me = this, {
      input,
      inputListenerRemover
    } = me;
    if (input) {
      input.readOnly = readOnly ? "readOnly" : null;
      if (readOnly) {
        me.inputListenerRemover = inputListenerRemover === null || inputListenerRemover === void 0 ? void 0 : inputListenerRemover();
      } else if (!inputListenerRemover) {
        me.inputListenerRemover = EventHelper.on({
          element: input,
          thisObj: me,
          focus: "internalOnInputFocus",
          change: "internalOnChange",
          input: "internalOnInput"
        });
      }
    }
  }
  changeReadOnly(value) {
    return Boolean(value);
  }
  updateReadOnly(readOnly) {
    this.syncInputReadOnly();
  }
  updateClearable(clearable) {
    const me = this;
    me.getConfig("triggers");
    me.triggers = {
      clear: clearable && ObjectHelper.assign({
        cls: "b-icon-remove",
        weight: 1e3,
        key: "Shift+backspace",
        handler() {
          me._isUserAction = true;
          me.clear(...arguments);
          me._isUserAction = false;
        }
      }, clearable) || null
    };
  }
  changeTriggers(triggers, was) {
    const me = this, manager = me.$triggers || (me.$triggers = new DynamicObject({
      configName: "triggers",
      factory: Field.Trigger,
      inferType: false,
      owner: me,
      created(instance) {
        FunctionHelper.after(instance, "onConfigChange", (ret, {
          name
        }) => {
          if (triggerConfigs[name]) {
            me.onConfigChange({
              name: "triggers",
              value: manager.target
            });
          }
        });
      },
      setup(config, name) {
        config.reference = config.ref = name;
        config.parent = me;
      }
    }));
    if (me.stepTriggers === false && (triggers.back || triggers.forward)) {
      triggers = ObjectHelper.assign({}, triggers);
      delete triggers.back;
      delete triggers.forward;
    }
    manager.update(triggers);
    if (me.element) {
      me.keyMap = me.keyMap;
    }
    if (!was) {
      return manager.target;
    }
  }
  updateInputWidth(newValue) {
    this.input.style.width = DomHelper.setLength(newValue);
    this.element.classList.add("b-has-width");
  }
  updateInputAlign(newValue) {
    this.input.style.textAlign = newValue;
  }
  get isValid() {
    const me = this;
    if (!me.disabled) {
      me.syncRequired();
      if (me.errors && Object.keys(me.errors).length) {
        return false;
      }
      const validity = me.validity;
      if (validity) {
        return validity.valid;
      }
    }
    return true;
  }
  get isEmpty() {
    return this.value == null || this.value === "";
  }
  get isEmptyInput() {
    return !this.input || this.input.value == null || this.input.value === "";
  }
  get validity() {
    const input = this.input;
    return input === null || input === void 0 ? void 0 : input.validity;
  }
  changeValue(value, was) {
    if (value == null) {
      value = this.nullValue;
    }
    if (this.hasChanged(was, value)) {
      return value;
    }
    if (value === "") {
      this.syncRequired();
    }
    return was;
  }
  updateValue(value, oldValue) {
    const me = this;
    if (!me.isConfiguring) {
      me.syncRequired();
      if (!me.inputting) {
        me.triggerChange();
      }
    }
    if (!me.inputting) {
      me._lastValue = value;
    }
    me.syncInputFieldValue();
    if (me.overflowTwin && !me._overflowTwinSync) {
      me._overflowTwinSync = true;
      me.overflowTwin.value = value;
      me._overflowTwinSync = false;
    }
  }
  hasChanged(oldValue, newValue) {
    return newValue !== oldValue;
  }
  syncInputFieldValue(skipHighlight = false) {
    const me = this, {
      input,
      parent,
      inputValueAttr,
      inputValue
    } = me;
    if (input && !me.inputting && input[inputValueAttr] !== inputValue) {
      input[inputValueAttr] = inputValue;
      if (!me.isConfiguring && !me.containsFocus && me.highlightExternalChange) {
        input.classList.remove("b-field-updated");
        me.clearTimeout("removeUpdatedCls");
        if (parent) {
          const {
            assigningValues
          } = parent;
          if (assigningValues === true || (assigningValues === null || assigningValues === void 0 ? void 0 : assigningValues.highlight) === false) {
            skipHighlight = true;
          }
        }
        if (!skipHighlight) {
          me.highlightChanged();
        }
      }
    }
    me.syncEmpty();
    me.syncInvalid();
  }
  highlightChanged() {
    this.input.classList.add("b-field-updated");
    this.setTimeout("removeUpdatedCls", this.updatedClsDuration);
  }
  removeUpdatedCls() {
    this.input.classList.remove("b-field-updated");
  }
  get inputValue() {
    return this.value == null ? "" : this.value;
  }
  get inputValueAttr() {
    return "value";
  }
  get supportsTextSelection() {
    const input = this.focusElement;
    return input && (input.tagName.toLowerCase() === "textarea" || input.type && /text|search|password|tel|url/.test(input.type));
  }
  internalOnInputFocus() {
    if (this.autoSelect) {
      this.selectAll();
    }
  }
  internalOnChange(event) {
    const me = this;
    if (me.hasChanged(me._lastValue, me.value) && me.isValid) {
      me.triggerChange(event, true);
      me._lastValue = me.value;
    }
  }
  triggerChange(event, userAction = Boolean(this._isUserAction)) {
    const me = this, {
      value,
      _lastValue: oldValue,
      isValid: valid
    } = me;
    me.syncHint();
    me.triggerFieldChange({
      value,
      oldValue,
      event,
      userAction,
      valid
    });
    if (me.defaultAction === "change") {
      me.trigger("action", {
        value,
        oldValue,
        event,
        userAction,
        valid
      });
    }
  }
  fetchInputValue() {
    this.value = this.input[this.inputValueAttr];
  }
  internalOnInput(event) {
    var _me$changeOnKeyStroke;
    const me = this;
    if (!me.validateOnInput) {
      me.errorTip.hide();
    }
    me.inputting = true;
    me.fetchInputValue();
    me.inputting = false;
    me.trigger("input", {
      value: me.value,
      event
    });
    (_me$changeOnKeyStroke = me.changeOnKeyStroke) === null || _me$changeOnKeyStroke === void 0 ? void 0 : _me$changeOnKeyStroke.call(me, event);
  }
  get needsInputSync() {
    var _this$inputValue;
    return this.input[this.inputValueAttr] !== String((_this$inputValue = this.inputValue) !== null && _this$inputValue !== void 0 ? _this$inputValue : "");
  }
  internalOnKeyEvent(event) {
    const me = this, {
      value
    } = me;
    let stopEvent = false;
    if (event.type === "keydown") {
      if (event.key === "Escape" && !(me.readOnly || me.disabled)) {
        const wasValid = me.isValid, initialValue = "initialValue" in me ? me.initialValue : me.valueOnFocus, valueChanged = me.hasChanged(initialValue, value), {
          needsInputSync
        } = me;
        if (me.revertOnEscape && (!wasValid || valueChanged || needsInputSync)) {
          if (valueChanged) {
            me.value = initialValue;
          }
          if (needsInputSync) {
            me.syncInputFieldValue(true);
          }
          me.clearError();
          stopEvent = (valueChanged || needsInputSync) && me.isValid || wasValid !== me.validOnFocus;
        }
      }
    }
    if (!me.isDestroyed) {
      if (stopEvent) {
        event.stopImmediatePropagation();
      }
      me.trigger(event.type, {
        event
      });
    }
  }
  clear(event) {
    const me = this, {
      value
    } = me;
    if (value !== me.nullValue || me.input.value.length > 0) {
      me.value = me.nullValue;
      me.clearError();
      me.syncInvalid();
      me.trigger("clear", {
        event
      });
    }
  }
  onDisabled() {
    this.syncInvalid();
  }
  syncRequired() {
    var _me$parent;
    const me = this;
    if (!me.isConfiguring && !me.focusing && me.required && me.isEmpty && !((_me$parent = me.parent) !== null && _me$parent !== void 0 && _me$parent.isSettingValues)) {
      me.setError("L{fieldRequired}", me.updatingInvalid);
    } else {
      me.clearError("L{fieldRequired}", me.updatingInvalid);
    }
  }
  setError(error, silent, temporary) {
    const me = this;
    (me.errors || (me.errors = {}))[me.optionalL(error)] = 1;
    if (!silent) {
      me.syncInvalid();
    }
    if (temporary) {
      const clearError = () => {
        me.clearError(error);
        remover();
      }, remover = me.ion({
        keydown: clearError,
        focusOut: clearError
      });
    }
  }
  clearError(error, silent) {
    const me = this;
    if (me.errors) {
      if (error) {
        delete this.errors[this.optionalL(error)];
      } else {
        me.errors = {};
      }
    }
    if (!silent) {
      me.syncInvalid();
    }
  }
  getErrors() {
    const me = this;
    if (!me.isValid) {
      var _errors;
      const validity = me.validity, stateName = ObjectHelper.keys(validity).find((key) => key !== "valid" && key !== "customError" && validity[key]), errorKeys = me.errors && Object.keys(me.errors);
      let errors;
      if (errorKeys !== null && errorKeys !== void 0 && errorKeys.length) {
        errors = errorKeys;
      } else if (validity.customError) {
        errors = [me.input.validationMessage];
      } else if (stateName) {
        errors = [me.L(stateName, {
          min: me.min,
          max: me.max
        })];
      } else {
        errors = [me.L(me.invalidValueError)];
      }
      if (((_errors = errors) === null || _errors === void 0 ? void 0 : _errors.length) > 0) {
        return errors;
      }
    }
  }
  createOverflowTwin(overrides) {
    const me = this, overflowTwin = super.createOverflowTwin(overrides);
    overflowTwin.ion({
      change({
        value
      }) {
        me._overflowTwinSync = true;
        me.value = value;
        me._overflowTwinSync = false;
      }
    });
    return overflowTwin;
  }
  get containerCollapsed() {
    var _this$container;
    return (_this$container = this.container) === null || _this$container === void 0 ? void 0 : _this$container.collapsed;
  }
  set containerCollapsed(collapsed) {
    const {
      container
    } = this;
    if (container) {
      container.collapsed = collapsed;
    }
  }
  afterSyncChildConfigs(container) {
  }
  changeContainer(config, existing) {
    if (config && (Array.isArray(config) || !("type" in config || "items" in config))) {
      config = {
        items: config
      };
    }
    const me = this, defaults = config && ObjectHelper.merge({
      owner: me,
      layout: "box"
    }, me.containerDefaults), container = Widget.reconfigure(existing, config, {
      owner: me,
      defaults
    });
    if (container) {
      container.autoLayout = (defaults === null || defaults === void 0 ? void 0 : defaults.layout) === "box";
      if (container === existing) {
        container.syncContainer();
        return;
      }
    }
    return container;
  }
  onConfigChange(info) {
    var _this$container2, _this$container2$sync;
    super.onConfigChange(info);
    if ((_this$container2 = this.container) !== null && _this$container2 !== void 0 && (_this$container2$sync = _this$container2.syncConfigTriggers) !== null && _this$container2$sync !== void 0 && _this$container2$sync[info.name]) {
      this.container.syncChildConfigs();
    }
  }
  assignValue(values, options) {
    const me = this, {
      container,
      containValues
    } = me, valueName = me.getValueName(options), storedValue = values && valueName in values;
    if (container && containValues !== false) {
      if (values && containValues === "nested") {
        if (storedValue) {
          values = ObjectHelper.clone(values[valueName]);
          super.assignValue({
            [valueName]: values && !("value" in values) || values.value
          }, options);
          if (values) {
            delete values.value;
          }
          container.assignValue(values, options);
        }
      } else {
        super.assignValue(values, options);
        container.assignValue(values, options);
      }
    } else {
      super.assignValue(values, options);
    }
  }
  gatherValue(values) {
    super.gatherValue(values);
    this.gatherValues(values);
  }
  gatherValues(values, storedValue) {
    var _storedValue;
    const me = this, {
      container,
      containValues,
      valueName
    } = me, cvt = typeof containValues;
    storedValue = (_storedValue = storedValue) !== null && _storedValue !== void 0 ? _storedValue : valueName in values;
    if (container && containValues !== false) {
      if (containValues === "nested") {
        if (storedValue) {
          values[valueName] = _objectSpread2({
            value: values[valueName]
          }, container.values);
        }
      } else if (containValues === true || containValues == null && storedValue || cvt === "string" && me[containValues] || cvt === "function" && containValues(me)) {
        container.gatherValues(values);
      }
    }
  }
  updateContainer(container, was) {
    was && this.detachListeners(was.id);
    if (container) {
      if (!container.rendered) {
        container.render();
      }
      container.syncContainer();
      container.syncChildConfigs();
    }
  }
};
Field.Trigger = class FieldTrigger extends Widget {
  static get $name() {
    return "FieldTrigger";
  }
  static get factoryable() {
    return {
      defaultType: Field.Trigger,
      extends: null
    };
  }
  static get type() {
    return "trigger";
  }
  static get configurable() {
    return {
      align: null,
      weight: null,
      role: void 0
    };
  }
  get field() {
    return this.parent;
  }
  construct() {
    super.construct(...arguments);
    if (this.key) {
      this.keyMap = {
        [this.key]: "onClick"
      };
    }
  }
  compose() {
    return {
      "aria-hidden": true,
      class: {
        [`b-align-${this.align || "end"}`]: 1,
        "b-icon": 1
      },
      listeners: {
        click: "onClick",
        mousedown: "onMousedown"
      }
    };
  }
  changeAlign(align) {
    return align;
  }
  onClick(e) {
    const me = this, {
      field
    } = me;
    if (!(field.disabled || field.readOnly)) {
      if (e.key) {
        e.preventDefault();
      }
      if (field.trigger("trigger", {
        trigger: me
      }) !== false && me.handler) {
        field.callback(me.handler, field, [e, me]);
      }
    }
  }
  onMousedown(e) {
    const field = this.field, isKeyEvent = "key" in e;
    if (!isKeyEvent && DomHelper.isTouchEvent) {
      if (field.editable) {
        field.editable = false;
        field.setTimeout(() => field.editable = true, 500);
      }
    }
    e.preventDefault();
    if (DomHelper.getActiveElement(field.input) !== field.input) {
      field.focus();
    }
  }
};
Field.SpinTrigger = class SpinTrigger extends Field.Trigger {
  static get $name() {
    return "SpinTrigger";
  }
  static get type() {
    return "spintrigger";
  }
  static get configurable() {
    return {
      repeat: {
        $config: ["nullify"],
        value: true
      }
    };
  }
  compose() {
    return {
      children: {
        upButton: {
          class: {
            "b-icon": 1,
            "b-spin-up": 1
          }
        },
        downButton: {
          class: {
            "b-icon": 1,
            "b-spin-down": 1
          }
        }
      }
    };
  }
  updateRepeat(repeat) {
    var _this$clickRepeater;
    (_this$clickRepeater = this.clickRepeater) === null || _this$clickRepeater === void 0 ? void 0 : _this$clickRepeater.destroy();
    this.clickRepeater = repeat ? ClickRepeater.new({
      element: this.element
    }, repeat) : null;
  }
  onClick(e) {
    const me = this, {
      field
    } = me;
    if (!(field.disabled || field.readOnly)) {
      if (e.target === me.upButton) {
        field.doSpinUp(e.shiftKey);
      } else if (e.target === me.downButton) {
        field.doSpinDown(e.shiftKey);
      }
    }
  }
};
Field.Trigger.initClass();
Field.SpinTrigger.initClass();
Widget.register(Field.Trigger, "trigger");
Widget.register(Field.SpinTrigger, "spintrigger");
Field._$name = "Field";
var TextField = class extends Field {
  static get type() {
    return "textfield";
  }
  static get alias() {
    return "text";
  }
  static get configurable() {
    return {
      nullValue: ""
    };
  }
  static get $name() {
    return "TextField";
  }
  construct(config) {
    if ((config === null || config === void 0 ? void 0 : config.inputType) === "hidden") {
      config.hidden = true;
    }
    super.construct(...arguments);
  }
};
TextField.initClass();
TextField._$name = "TextField";
var PickerField = class extends TextField {
  static get $name() {
    return "PickerField";
  }
  static get type() {
    return "pickerfield";
  }
  static get configurable() {
    return {
      editable: true,
      pickerAlignElement: "inputWrap",
      value: null,
      triggers: {
        expand: {
          cls: "bars"
        }
      },
      autoClose: true,
      autoExpand: null,
      picker: {
        value: {
          floating: true
        },
        $config: ["lazy", "nullify"]
      },
      inputType: "text",
      monitorResize: true,
      nullValue: null
    };
  }
  doDestroy() {
    var _this$globalTapListen;
    (_this$globalTapListen = this.globalTapListener) === null || _this$globalTapListen === void 0 ? void 0 : _this$globalTapListen.call(this);
    super.doDestroy();
  }
  updateEditable(editable) {
    const me = this, {
      element,
      ariaElement
    } = me;
    super.updateEditable(...arguments);
    if (editable === false) {
      var _me$globalTapListener;
      ariaElement.removeAttribute("aria-autocomplete");
      (_me$globalTapListener = me.globalTapListener) === null || _me$globalTapListener === void 0 ? void 0 : _me$globalTapListener.call(me);
      element.classList.add("b-not-editable");
      EventHelper.on({
        element: me.nonEditableClickTarget,
        click: (e) => {
          const target = document.elementFromPoint(e.clientX, e.clientY);
          if (e.target === me.nonEditableClickTarget && target === me.nonEditableClickTarget) {
            me.onTriggerClick(e);
          }
        },
        thisObj: me
      });
    } else {
      ariaElement.setAttribute("aria-autocomplete", "list");
      me.globalTapListener = GlobalEvents$1.ion({
        globaltap: "showKeyboard",
        thisObj: me
      });
    }
  }
  get nonEditableClickTarget() {
    return this.input;
  }
  updateElement(element, oldElement) {
    var _this$constructor$res;
    const result = super.updateElement(element, oldElement), picker = this.peekConfig("picker"), role = picker ? picker.isWidget ? picker.role : (_this$constructor$res = this.constructor.resolveType(picker.type)) === null || _this$constructor$res === void 0 ? void 0 : _this$constructor$res.$meta.config.role : false;
    this.ariaHasPopup = role;
    return result;
  }
  changePicker(picker, oldPicker) {
    throw new Error("changePicker(oldPicker, newPicker) must be implemented in PickerField subclass implementations");
  }
  get childItems() {
    const result = super.childItems;
    if (this._picker) {
      result.push(this.picker);
    }
    return result;
  }
  onEditComplete() {
    super.onEditComplete();
    this.autoClosePicker();
  }
  onElementResize(resizedElement) {
    const me = this;
    if (me.pickerVisible) {
      me.picker.requestAnimationFrame(me.picker.realign, null, me.picker);
    }
    super.onElementResize(resizedElement);
  }
  internalOnKeyEvent(event) {
    const me = this;
    let callSuper = true;
    if (event.type === "keydown" && !me.disabled && !event.shiftKey && !event.ctrlKey) {
      if (me.pickerVisible) {
        const {
          picker
        } = me;
        if (event.key === "Escape") {
          event.preventDefault();
          event.stopImmediatePropagation();
          me.hidePicker();
          callSuper = false;
        } else if (picker.onInternalKeyDown) {
          picker.onInternalKeyDown(event);
        } else if (event.key === "ArrowDown") {
          if (picker.focusable) {
            picker.focus();
          }
        }
      } else if (event.key === "ArrowDown") {
        event.stopImmediatePropagation();
        event.preventDefault();
        me.onTriggerClick(event);
      }
    }
    if (callSuper) {
      super.internalOnKeyEvent(event);
    }
  }
  onFocusIn(e) {
    const me = this;
    super.onFocusIn(e);
    if (me.autoExpand) {
      me.minChars = 0;
      me.onTriggerClick(e);
      me.ignoreTriggerClick = true;
      me.setTimeout(() => me.ignoreTriggerClick = false, 100);
    }
  }
  onTriggerClick(event) {
    if (!this.disabled) {
      this.togglePicker("key" in event);
    }
  }
  showKeyboard({
    event
  }) {
    const input = this.input;
    if (DomHelper.isTouchEvent && DomHelper.getActiveElement(input) === input && event.target === input) {
      GlobalEvents$1.suspendFocusEvents();
      input.blur();
      input.focus();
      GlobalEvents$1.resumeFocusEvents();
    }
  }
  togglePicker(focus) {
    if (this.pickerVisible) {
      this.hidePicker();
    } else {
      this.showPicker(focus);
    }
  }
  showPicker(focus) {
    const me = this, {
      picker
    } = me;
    if (!me.pickerHideShowListenersAdded) {
      picker.ion({
        show: "onPickerShow",
        hide: "onPickerHide",
        thisObj: me
      });
      me.pickerHideShowListenersAdded = true;
    }
    DomHelper.setAttributes(me.ariaElement, {
      "aria-controls": picker.id,
      "aria-expanded": true
    });
    picker.autoClose = me.autoClose;
    picker.show();
    if (picker.isVisible) {
      if (focus) {
        me.focusPicker();
      }
    }
  }
  onPickerShow() {
    const me = this;
    me.pickerVisible = true;
    me.element.classList.add("b-open");
    me.trigger("togglePicker", {
      show: true
    });
    me.pickerTapOutRemover = GlobalEvents$1.ion({
      globaltap: "onPickerTapOut",
      thisObj: me
    });
    me.pickerKeyDownRemover = EventHelper.on({
      element: me.picker.element,
      keydown: "onPickerKeyDown",
      thisObj: me
    });
  }
  onPickerHide() {
    var _me$pickerTapOutRemov, _me$pickerKeyDownRemo;
    const me = this;
    me.ariaElement.setAttribute("aria-expanded", false);
    me.pickerVisible = false;
    me.element.classList.remove("b-open");
    me.trigger("togglePicker", {
      show: false
    });
    (_me$pickerTapOutRemov = me.pickerTapOutRemover) === null || _me$pickerTapOutRemov === void 0 ? void 0 : _me$pickerTapOutRemov.call(me);
    (_me$pickerKeyDownRemo = me.pickerKeyDownRemover) === null || _me$pickerKeyDownRemo === void 0 ? void 0 : _me$pickerKeyDownRemo.call(me);
  }
  onPickerTapOut({
    event
  }) {
    if (!this.containsFocus && !this.owns(event.target)) {
      this.autoClosePicker();
    }
  }
  onPickerKeyDown(event) {
    if (event.key === "Tab" && !this.picker.trapFocus) {
      const activeEl = DomHelper.getActiveElement(this.input), forwardedEvent = new KeyboardEvent("keydown", event);
      this.input.dispatchEvent(forwardedEvent);
      if (forwardedEvent.defaultPrevented) {
        event.preventDefault();
      }
      if (DomHelper.getActiveElement(this.input) === activeEl) {
        this.input.focus();
      } else {
        event.preventDefault();
      }
      if (!this.isDestroyed) {
        this.hidePicker();
      }
    }
  }
  autoClosePicker() {
    if (this.autoClose) {
      this.hidePicker();
    }
  }
  hidePicker() {
    if (this.pickerVisible) {
      this.picker.hide();
    }
  }
  focusPicker() {
  }
  focus() {
    const input = this.input;
    if (DomHelper.isTouchEvent && this.editable) {
      input.readOnly = true;
      this.setTimeout(() => input.readOnly = false, 500);
    }
    super.focus();
  }
};
PickerField._$name = "PickerField";
var itemRange = document.createRange();
var List = class extends Widget {
  static get $name() {
    return "List";
  }
  static get type() {
    return "list";
  }
  static get configurable() {
    return {
      itemCls: "b-list-item",
      selectedCls: "b-selected",
      selectIconCls: "b-icon-check",
      tag: "ul",
      items: null,
      displayField: "text",
      store: null,
      navigator: true,
      scrollable: {
        overflowX: false,
        overflowY: true
      },
      itemsFocusable: true,
      multiSelect: false,
      toggleAllIfCtrlPressed: false,
      selectAllItem: false,
      itemTpl(record) {
        let text = StringHelper.encodeHtml(record[this.displayField]);
        if (text == null || text === "") {
          text = "&nbsp;";
        }
        return text;
      },
      getItemStyle: null,
      getItemCls: null,
      groupHeaderTpl: (record, groupName) => {
        let name = StringHelper.encodeHtml(groupName);
        if (name == null || name === "") {
          name = "&nbsp;";
        }
        return name;
      },
      allowGroupSelect: true,
      selected: {
        $config: "nullify",
        value: {}
      },
      activateOnMouseover: null,
      role: "listbox",
      keyMap: {
        "Ctrl+a": "selectAll"
      }
    };
  }
  construct(config, ...args) {
    var _me$store;
    const me = this;
    if (Array.isArray(config)) {
      config = {
        items: config
      };
    }
    super.construct(config, ...args);
    const {
      element
    } = me, {
      classList
    } = element;
    if (me.multiSelect) {
      classList.add("b-multiselect");
    }
    if ((_me$store = me.store) !== null && _me$store !== void 0 && _me$store.count) {
      me.refresh();
    } else {
      classList.add("b-empty");
    }
    EventHelper.on({
      element,
      delegate: me.itemSelector,
      mouseover: "onMouseOver",
      click: "onClick",
      thisObj: me
    });
  }
  doDestroy() {
    var _this$navigator;
    this.detachListeners("store");
    (_this$navigator = this.navigator) === null || _this$navigator === void 0 ? void 0 : _this$navigator.destroy();
    super.doDestroy();
  }
  onFocusIn(e) {
    var _e$_target;
    this.restoreActiveItem((_e$_target = e._target) === null || _e$_target === void 0 ? void 0 : _e$_target.closest(this.itemSelector));
    super.onFocusIn(e);
  }
  contentTpl() {
    const me = this, allRecordsTpl = me.store.records.map((record, i) => me.itemWrapperTpl(record, i));
    if (me.multiSelect && me.selectAllItem !== false) {
      allRecordsTpl.unshift(me.selectAllItemTpl());
    }
    return TemplateHelper.tpl`${allRecordsTpl}`;
  }
  itemWrapperTpl(record, i) {
    const {
      selected,
      getItemStyle
    } = this, style = getItemStyle ? `style="${this.callback(getItemStyle, this, [record])}"` : "";
    return TemplateHelper.tpl`<li ${style} class="${this.getItemClasses(record, i)}" role="option" aria-selected="${selected.includes(record)}" data-index="${i}" data-id="${StringHelper.encodeHtml(record.id)}" ${this.itemsFocusable ? 'tabindex="-1"' : ""}>${this.itemContentTpl(record, i)}</li>`;
  }
  itemContentTpl(record, i) {
    if ("groupRowFor" in record.meta) {
      return this.groupHeaderTpl(record, StringHelper.capitalize(record.groupChildren[0][record.meta.groupField]));
    }
    return `${this.itemIconTpl(record, i)}${this.itemTpl(record, i)}`;
  }
  itemIconTpl(record, i) {
    return this.multiSelect ? `<i class="b-selected-icon b-icon ${this.selectIconCls}"></i>` : "";
  }
  selectAllItemTpl() {
    const selectedCls = this.allSelected ? "b-selected" : "";
    return `<li class="${this.itemCls} b-select-all-item ${selectedCls}" data-noselect data-select-all data-id="select-all">${this.itemIconTpl({})}<div>${this.optionalL("Select All")}</div></li>`;
  }
  getItemClasses(record) {
    var _me$_navigator;
    const me = this, {
      getItemCls
    } = me, activeItem = (_me$_navigator = me._navigator) === null || _me$_navigator === void 0 ? void 0 : _me$_navigator.activeItem, isActive = (activeItem === null || activeItem === void 0 ? void 0 : activeItem.dataset.id) == record.id, groupHeaderCls = "groupRowFor" in record.meta ? "b-list-item-group-header" : "", isSelected = me.selected.includes(record), itemCls = getItemCls ? this.callback(getItemCls, this, [record]) : "";
    return `${me.itemCls} ${record.cls || ""} ${itemCls} ${isSelected ? me.selectedCls : ""} ${isActive ? me.navigator.focusCls : ""} ${groupHeaderCls}`;
  }
  onBeforeStoreLoad() {
    this.mask(this.L("L{loading}"));
  }
  onAfterStoreRequest() {
    this.unmask();
  }
  onStoreChange({
    source: store,
    action,
    records,
    record,
    changes
  }) {
    const me = this, {
      selected
    } = me;
    switch (action) {
      case "dataset": {
        selected.match(store.storage, !me._externallyOwnedSelection);
        break;
      }
      case "remove":
        selected.remove(records);
        break;
      case "clear":
        me.deselectAll();
        break;
      case "update": {
        const {
          id
        } = changes;
        if (id) {
          DomHelper.setAttributes(me.contentElement.querySelector(StringHelper.encodeAttributeSelector(`data-id`, id.oldValue)), {
            "data-id": id.value
          });
        }
        me.refreshItem(record);
        return;
      }
    }
    me.refresh();
  }
  onStoreRefresh() {
    this.refresh();
  }
  refresh() {
    const me = this;
    if (me.isVisible) {
      var _me$navigator;
      const activeItem = (_me$navigator = me.navigator) === null || _me$navigator === void 0 ? void 0 : _me$navigator.activeItem;
      me.paintListener = null;
      const node = DomHelper.createElementFromTemplate(me.contentTpl(), {
        fragment: true
      });
      me.clearItems().insertNode(node);
      if (activeItem) {
        me.restoreActiveItem(activeItem);
      }
      me.refreshCount = (me.refreshCount || 0) + 1;
      me.element.classList[me.store.count > 0 ? "remove" : "add"]("b-empty");
      me.updateSelectAllState();
    } else if (!me.paintListener) {
      me.paintListener = me.ion({
        paint: "refresh",
        thisObj: me,
        once: true
      });
    }
  }
  clearItems() {
    const me = this, firstItem = me.contentElement.querySelector(me.itemSelector), lastChild = me.contentElement.lastChild;
    if (firstItem) {
      const items2 = me.contentElement.querySelectorAll(`${me.itemSelector}:not(.b-mask)`);
      itemRange.setStartBefore(firstItem);
      itemRange.setEndAfter(items2[items2.length - 1]);
      itemRange.deleteContents();
    } else {
      if (lastChild) {
        itemRange.setStartAfter(lastChild);
        itemRange.setEndAfter(lastChild);
      } else {
        itemRange.setStart(me.contentElement, 0);
        itemRange.setEnd(me.contentElement, 0);
      }
    }
    return itemRange;
  }
  refreshItem(...records) {
    for (const record of records) {
      const item = this.getItem(record);
      if (item) {
        const index = this.store.indexOf(record), newItem = DomHelper.createElementFromTemplate(this.itemWrapperTpl(record, index));
        DomHelper.sync(newItem, item);
      }
    }
  }
  getItem(recordOrId) {
    if (recordOrId != null) {
      var _recordOrId;
      if (typeof recordOrId === "number") {
        return this.contentElement.querySelector(`[data-index="${recordOrId < 0 ? this.store.count + recordOrId : recordOrId}"]`);
      } else if (recordOrId.nodeType === Element.ELEMENT_NODE) {
        recordOrId = recordOrId.dataset.id;
      }
      if (((_recordOrId = recordOrId) === null || _recordOrId === void 0 ? void 0 : _recordOrId.id) != null) {
        recordOrId = recordOrId.id;
      }
      return this.contentElement.querySelector(StringHelper.encodeAttributeSelector(`data-id`, recordOrId));
    }
  }
  getRecordFromElement(element) {
    if (element.target) {
      element = element.target;
    }
    element = element.closest(this.itemSelector);
    return this.store.getAt(parseInt(element.dataset.index));
  }
  updateItems(items2) {
    const me = this;
    if (me.store && me.store.autoCreated) {
      me.store.destroy();
    }
    me.store = Store.getStore(items2);
  }
  updateDisabled(disabled) {
    super.updateDisabled(...arguments);
    this.navigator && (this.navigator.disabled = disabled);
  }
  changeSelected(selected, oldSelected) {
    if (selected) {
      let initialSelection;
      if (selected.isCollection) {
        this._externallyOwnedSelection = true;
      } else {
        if (Array.isArray(selected)) {
          initialSelection = selected;
          selected = {};
        } else if (selected.values) {
          initialSelection = selected.values;
          selected = _objectSpread2(_objectSpread2({}, selected), {}, {
            values: []
          });
        }
        selected = new Collection(selected);
      }
      selected.ion({
        change: "onSelectionChange",
        thisObj: this
      });
      this.initialSelection = initialSelection;
    } else {
      oldSelected === null || oldSelected === void 0 ? void 0 : oldSelected.destroy();
    }
    return selected;
  }
  get itemSelector() {
    return `.${this.itemCls}`;
  }
  get selected() {
    return this._selected;
  }
  get store() {
    this.getConfig("items");
    return this._store;
  }
  changeStore(store) {
    const me = this;
    if (!(store instanceof Store)) {
      if (Array.isArray(store)) {
        store = {
          data: store
        };
      }
      store = new Store(store);
    }
    me.detachListeners("store");
    if (store) {
      const storeListeners = {
        name: "store",
        change: "onStoreChange",
        refresh: "onStoreRefresh",
        thisObj: me
      };
      if (store.readUrl) {
        storeListeners.beforeLoad = "onBeforeStoreLoad";
        storeListeners.afterRequest = "onAfterStoreRequest";
      }
      if (store.isGrouped) {
        me.element.classList.add("b-grouped");
        storeListeners.groupchange = "onStoreRefresh";
      }
      store.ion(storeListeners);
    }
    return store;
  }
  updateStore(store) {
    const {
      initialSelection
    } = this;
    if (initialSelection !== null && initialSelection !== void 0 && initialSelection.length) {
      if (store.count) {
        this.select(initialSelection);
      } else {
        store.ion({
          refresh: () => this.select(initialSelection),
          once: true
        });
      }
    }
    this.refresh();
  }
  changeNavigator(navigator2, oldNavigator) {
    const me = this, {
      element
    } = me;
    if (element) {
      var _navigator;
      navigator2 = Navigator.reconfigure(oldNavigator, navigator2 ? Navigator.mergeConfigs({
        ownerCmp: me,
        disabled: me.disabled,
        target: element,
        keyEventTarget: element
      }, navigator2) : null, me);
      if (((_navigator = navigator2) === null || _navigator === void 0 ? void 0 : _navigator.keyEventTarget) === element && !me.itemsTabbable) {
        element.tabIndex = 0;
      }
    }
    return navigator2;
  }
  get minAlignHeight() {
    const lastItem = this.element.lastElementChild, minHeight = this.minHeight;
    if (minHeight != null) {
      return lastItem ? Math.min(lastItem.offsetTop + lastItem.offsetHeight, minHeight) : 0;
    }
  }
  alignTo(...args) {
    super.minHeight = this.minAlignHeight;
    super.alignTo(...args);
  }
  hide(...args) {
    this.navigator && (this.navigator.activeItem = null);
    return super.hide(...args);
  }
  show() {
    const {
      refreshCount
    } = this, {
      previousActiveItem
    } = this.navigator;
    super.minHeight = this._minHeight;
    const retVal = super.show(...arguments);
    if (this.refreshCount === refreshCount) {
      this.restoreActiveItem(previousActiveItem, true);
    }
    return retVal;
  }
  restoreActiveItem(activeItem = this.navigator.previousActiveItem, block = "nearest") {
    const me = this, {
      navigator: navigator2,
      lastAlignSpec
    } = me;
    if (activeItem != null) {
      if (typeof block !== "string") {
        const alignZone = lastAlignSpec ? lastAlignSpec.zone : 1;
        block = alignZone & 1 ? "nearest" : alignZone ? "start" : "end";
      }
      activeItem = me.getItem(activeItem);
      if (activeItem && !me.disabled) {
        me.scrollable.scrollIntoView(activeItem, {
          block
        });
        navigator2.activeItem = activeItem;
      }
    }
  }
  onMouseOver(event) {
    const me = this, itemElement = event.currentTarget;
    if (!DomHelper.isTouchEvent && itemElement && me.navigator && me.activateOnMouseover) {
      me.setTimeout({
        fn: "handleMouseOver",
        delay: 30,
        args: [itemElement],
        cancelOutstanding: true
      });
    }
  }
  handleMouseOver(itemElement) {
    this.navigator.activeItem = itemElement;
  }
  onClick(event) {
    const itemElement = event.target.closest(this.itemSelector);
    if (itemElement) {
      this.onItemClick(itemElement, event);
    }
  }
  onInternalKeyDown(event) {
    const me = this, active = me.navigator.activeItem;
    if (me.disabled) {
      return;
    }
    switch (event.key) {
      case " ":
        if (event.target.nodeName.toUpperCase() === "INPUT" && !event.target.readOnly) {
          break;
        }
      case "Enter":
        if (active) {
          this.onItemClick(active, event);
          event.stopImmediatePropagation();
          event.preventDefault();
        }
    }
  }
  onItemClick(item, event) {
    const me = this, index = parseInt(item.dataset.index);
    let record = me.store.getAt(index);
    if (me.disabled || me.trigger("beforeItem", {
      item,
      record,
      index,
      event,
      userAction: true
    }) === false) {
      return;
    }
    me._isUserAction = true;
    if (me.allowGroupSelect || record && !record.isSpecialRow) {
      if (!item.contains(event.target.closest("[data-noselect]"))) {
        const selected = me.selected;
        let isSelected = selected.includes(record);
        if (me.multiSelect) {
          if (me.toggleAllIfCtrlPressed && event.ctrlKey) {
            record = me.store.records;
          } else if (me.allowGroupSelect && record.isSpecialRow) {
            isSelected = !record.groupChildren.some((rec) => !selected.includes(rec));
            record = record.groupChildren;
          }
          selected[isSelected ? "remove" : "add"](record);
        } else {
          selected.splice(0, selected.count, record);
        }
      } else if (item.contains(event.target.closest("[data-select-all]"))) {
        me.onSelectAllClick(item, event);
      }
    }
    me.lastClicked = record;
    me.trigger("item", {
      item,
      record,
      index,
      event,
      userAction: true
    });
    me._isUserAction = false;
  }
  onSelectionChange({
    action,
    removed,
    added,
    replaced
  }) {
    const me = this, {
      selectedCls,
      unselectedCls
    } = me;
    let record, item;
    if (action === "clear") {
      for (item of me.element.querySelectorAll(`.${selectedCls}`)) {
        item.classList.remove(selectedCls);
        item.setAttribute("aria-selected", false);
        unselectedCls && item.classList.remove(unselectedCls);
      }
    } else if (action !== "replaceValues") {
      for (record of removed) {
        item = me.getItem(record);
        if (item) {
          item.classList.remove(selectedCls);
          item.setAttribute("aria-selected", false);
        }
      }
      for (record of added) {
        item = me.getItem(record);
        if (item) {
          item.classList.add(selectedCls);
          item.setAttribute("aria-selected", true);
        }
      }
    }
    me.selectAllItem && me.updateSelectAllState();
  }
  onSelectAllClick(item) {
    const checked = item.classList.contains(this.selectedCls);
    if (checked) {
      this.deselectAll();
    } else {
      this.selectAll();
    }
  }
  updateSelectAllState() {
    var _this$element$querySe;
    (_this$element$querySe = this.element.querySelector(".b-select-all-item")) === null || _this$element$querySe === void 0 ? void 0 : _this$element$querySe.classList.toggle(this.selectedCls, this.allSelected);
  }
  get allSelected() {
    const {
      selected,
      store
    } = this;
    return selected.count && (store.isFiltered ? store.records.every((r) => selected.includes(r)) : store.count === selected.count);
  }
  selectAll(keyEvent) {
    const me = this;
    if (me.multiSelect || !keyEvent) {
      me.selected.add(me.store.records);
      if (keyEvent && !me.navigator.activeItem) {
        me.navigator.activeItem = me.getItem(-1);
      }
    }
  }
  deselectAll() {
    this.selected.clear();
  }
  select(toSelect) {
    const {
      store
    } = this, {
      modelClass
    } = store;
    toSelect = ArrayHelper.asArray(toSelect).reduce((v, c) => {
      c = store.getById(modelClass.asId(c));
      if (c) {
        v.push(c);
      }
      return v;
    }, []);
    this.selected.add(toSelect);
  }
  deselect(toDeselect) {
    const {
      modelClass
    } = this.store;
    toDeselect = ArrayHelper.asArray(toDeselect).reduce((v, c) => {
      c = this.selected.get(modelClass.asId(c));
      if (c) {
        v.push(c);
      }
      return v;
    }, []);
    this.selected.remove(toDeselect);
  }
};
List.initClass();
List.prototype.navigatorClass = Navigator;
List._$name = "List";
var ChipView = class extends List {
  static get $name() {
    return "ChipView";
  }
  static get type() {
    return "chipview";
  }
  static get configurable() {
    return {
      itemCls: "b-chip",
      multiSelect: false,
      closable: true,
      iconTpl: null,
      closeHandler: null
    };
  }
  itemContentTpl(record, i) {
    const me = this;
    return TemplateHelper.tpl`${me.iconTpl ? this.iconTpl(record) : ""}
            ${me.itemTpl(record, i)}
            ${me.closable ? '<div class="b-icon b-close-icon b-icon-clear" data-noselect></div>' : ""}`;
  }
  onInternalKeyDown(event) {
    const me = this;
    if (me.closable && me.selected.count && (event.key === "Delete" || event.key === "Backspace")) {
      me.callback(me.closeHandler, me.owner, [me.selected.values, {
        isKeyEvent: true
      }]);
    } else {
      super.onInternalKeyDown(event);
    }
  }
  updateClosable(closable) {
    this.element.classList[closable ? "add" : "remove"]("b-chips-closable");
    this.navigator && (this.navigator.disabled = !closable);
    if (!this.isConfiguring) {
      this.refresh();
    }
  }
  onClick(event) {
    const me = this, item = event.target.closest(`.${me.itemCls}`);
    if (me.closable && event.target.classList.contains("b-close-icon")) {
      const record = me.store.getAt(parseInt(item.dataset.index));
      me.callback(me.closeHandler, me.owner, [[record]]);
    } else {
      super.onClick(event);
    }
  }
};
ChipView.initClass();
ChipView._$name = "ChipView";
var errorFieldRequired = "L{Field.fieldRequired}";
var errorValidateFilter = "L{Field.validateFilter}";
var errorRecordNotCommitted = "L{Combo.recordNotCommitted}";
var Combo = class extends PickerField {
  static get $name() {
    return "Combo";
  }
  static get type() {
    return "combo";
  }
  static get alias() {
    return "combobox,dropdown";
  }
  static get configurable() {
    return {
      primaryFilter: {},
      picker: {
        type: "list",
        floating: true,
        scrollAction: "realign",
        itemsFocusable: false,
        activateOnMouseover: true,
        align: {
          align: "t0-b0",
          axisLock: true
        },
        maxHeight: 324,
        scrollable: {
          overflowY: true
        },
        autoShow: false,
        focusOnHover: false
      },
      multiSelect: null,
      items: null,
      store: null,
      valueField: void 0,
      displayField: "text",
      pickerWidth: null,
      minChars: null,
      selected: null,
      listItemTpl: null,
      displayValueRenderer: null,
      listCls: null,
      triggers: {
        expand: {
          cls: "b-icon-picker",
          handler: "onTriggerClick"
        }
      },
      filterParamName: null,
      encodeFilterParams: (filters) => filters.map((f) => f.value),
      filterOnEnter: false,
      hideTrigger: null,
      overlayAnchor: null,
      keyStrokeFilterDelay: null,
      defaultAction: "select",
      triggerAction: "all",
      filterOperator: "startsWith",
      caseSensitive: false,
      hidePickerOnSelect: null,
      chipView: {
        $config: ["lazy", "nullify"],
        value: {
          type: "combochipview"
        }
      },
      chipStore: {
        $config: ["lazy", "nullify"],
        value: {}
      },
      filterSelected: null,
      emptyText: null,
      value: null,
      valueCollection: {
        $config: ["nullify", "lazy"],
        value: {}
      },
      validateFilter: true,
      clearTextOnPickerHide: true,
      destroyStore: false,
      multiValueSeparator: ",",
      createOnUnmatched: null,
      role: "combobox",
      inlinePicker: null,
      testConfig: {
        keyStrokeFilterDelay: 0
      },
      localizeDisplayFields: false,
      buildItems: null
    };
  }
  static get queryLast() {
    return "last";
  }
  construct(config) {
    super.construct(...arguments);
    if (!this.store) {
      this.items = [];
    }
    if (this.filterOnEnter) {
      this.hideTrigger = true;
    }
  }
  startConfigure(config) {
    this.usingRecordAsValue = config.valueField === null;
    super.startConfigure(...arguments);
  }
  afterConfigure() {
    super.afterConfigure();
    const me = this;
    if (!ObjectHelper.hasOwn(me, "_value")) {
      me._value = me.valueField === me.displayField ? "" : null;
      me._lastValue = me._lastValue || me._value;
    }
  }
  get childItems() {
    const {
      _chipView,
      _picker
    } = this, result = super.childItems;
    if (_chipView) {
      result.push(_chipView);
    }
    if (_picker) {
      result.push(_picker);
    }
    return result;
  }
  get innerElements() {
    var _this$_chipView;
    const chipViewElement = (_this$_chipView = this._chipView) === null || _this$_chipView === void 0 ? void 0 : _this$_chipView.element, {
      input,
      inputElement
    } = this;
    if (chipViewElement) {
      DomSync.sync({
        targetElement: input,
        domConfig: inputElement
      });
    }
    return [chipViewElement || inputElement];
  }
  updateInlinePicker(inlinePicker) {
    if (inlinePicker) {
      this.element.classList.add("b-inline-picker");
      this.getConfig("picker");
      this.triggers.expand = null;
      this.pickerVisible = true;
    }
  }
  hidePicker() {
    if (!this.inlinePicker) {
      return super.hidePicker(...arguments);
    }
  }
  changeChipStore(chipStore) {
    if (chipStore && !(chipStore instanceof Store)) {
      chipStore = new Store(Store.mergeConfigs({
        storage: this.valueCollection
      }, chipStore));
    }
    return chipStore;
  }
  updateChipStore(store, was) {
    was === null || was === void 0 ? void 0 : was.destroy();
  }
  changeChipView(chipView, oldChipView) {
    const me = this;
    me.element.classList[chipView ? "add" : "remove"]("b-uses-chipview");
    if (chipView) {
      const {
        input
      } = me;
      if (!me.chipStore) {
        me.chipStore = {};
      }
      return ComboChipView.reconfigure(oldChipView, chipView, {
        defaults: {
          parent: me,
          insertBefore: input,
          store: me.chipStore,
          closable: !me.readOnly,
          navigator: {
            type: "combochipnavigator",
            keyEventTarget: input
          }
        }
      });
    }
    oldChipView === null || oldChipView === void 0 ? void 0 : oldChipView.destroy();
  }
  updateChipView(chipView) {
    var _me$_chipViewEventDet;
    const me = this;
    me._chipViewEventDetacher = (_me$_chipViewEventDet = me._chipViewEventDetacher) === null || _me$_chipViewEventDet === void 0 ? void 0 : _me$_chipViewEventDet.call(me);
    me.chipStore = chipView === null || chipView === void 0 ? void 0 : chipView.store;
    if (chipView) {
      chipView.element.appendChild(me.input);
      me._chipViewEventDetacher = EventHelper.on({
        element: chipView.element,
        mousedown: "onChipViewMousedown",
        thisObj: me
      });
    }
  }
  updateMultiSelect(multiSelect, oldMultiSelect) {
    const me = this, {
      input,
      element
    } = me, fixValue = !me.isConfiguring;
    let {
      value
    } = me;
    element.classList[multiSelect ? "add" : "remove"]("b-multiselect");
    if (multiSelect) {
      const {
        chipView
      } = me, {
        parentNode: parentNode2
      } = input, chipViewEl = chipView === null || chipView === void 0 ? void 0 : chipView.element;
      if (chipViewEl && chipViewEl !== parentNode2) {
        parentNode2.insertBefore(chipViewEl, input);
        chipViewEl.appendChild(input);
        me.chipView.refresh();
      }
      input.value = "";
      if (fixValue) {
        value = ArrayHelper.asArray(value);
      }
    } else {
      const chipView = me._chipView, {
        parentNode: parentNode2
      } = input, chipViewEl = chipView === null || chipView === void 0 ? void 0 : chipView.element;
      if (chipViewEl === parentNode2) {
        chipViewEl.parentNode.insertBefore(input, chipViewEl);
        chipViewEl.remove();
        element.classList.remove("b-uses-chipview");
      }
      if (fixValue && typeof value !== "string") {
        var _value;
        value = (_value = value) !== null && _value !== void 0 && _value.length ? value[0] : null;
      }
    }
    if (fixValue) {
      me.value = value;
    }
  }
  onChipViewMousedown(mousedownEvent) {
    mousedownEvent.preventDefault();
    if (!this.containsFocus) {
      this.focus();
    }
  }
  onChipClose(records, options = {}) {
    if (options.isKeyEvent && this.input.value === "" || !options.isKeyEvent) {
      this._isUserAction = true;
      this.valueCollection.remove(records);
      this._isUserAction = false;
    }
  }
  updateFilterParamName(filterParamName) {
    if (this.hideTrigger !== false) {
      this.hideTrigger = Boolean(filterParamName);
    }
  }
  updateHideTrigger(hideTrigger) {
    this.element.classList[hideTrigger ? "add" : "remove"]("b-hide-trigger");
  }
  updateKeyStrokeFilterDelay(delay) {
    this.filterOnInput.delay = delay;
  }
  updateReadOnly(readOnly) {
    super.updateReadOnly(...arguments);
    this._chipView && (this._chipView.closable = !readOnly);
  }
  updateDisabled(disabled) {
    super.updateDisabled(...arguments);
    this._chipView && (this._chipView.closable = !disabled);
  }
  updateFilterOperator(filterOperator) {
    if (this.primaryFilter) {
      this.primaryFilter.operator = filterOperator;
    }
  }
  get minChars() {
    const minChars = this._minChars;
    if (minChars != null) {
      return minChars;
    }
    return this.remoteFilter ? 4 : 1;
  }
  get validateFilter() {
    return this._validateFilter && !this.createOnUnmatched;
  }
  get items() {
    return this.store.allRecords;
  }
  updateBuildItems(fn) {
    if (fn) {
      this.items = fn.call(this);
    }
  }
  changeItems(items2) {
    var _items;
    const me = this;
    if (items2 == null) {
      if (me.store && !me.store.isItemStore) {
        return;
      }
      items2 = [];
    }
    if (me.buildItems && !((_items = items2) !== null && _items !== void 0 && _items.length)) {
      items2 = me.buildItems();
    }
    if (items2 instanceof Store) {
      me.store = items2;
      return;
    }
    const displayField = me.displayField;
    let itemModel, valueField = me.valueField, storeData;
    if (Array.isArray(items2)) {
      storeData = items2.map((item) => {
        let result = item;
        if (item instanceof Model) {
          itemModel = item.constructor;
          if (!valueField) {
            me.valueField = valueField = itemModel.idField;
          }
        } else {
          if (typeof item === "string" || typeof item === "number") {
            if (!valueField) {
              me.valueField = valueField = me.displayField;
            }
            result = {
              [valueField]: item,
              [displayField]: item
            };
          } else {
            if (!valueField) {
              me.valueField = valueField = "value";
            }
            if (Array.isArray(item)) {
              result = {
                [valueField]: item[0],
                [displayField]: item[1]
              };
            }
          }
        }
        if (item.selected) {
          me.value = result;
        }
        return result;
      });
    } else {
      if (!valueField) {
        me.valueField = valueField = "value";
      }
      storeData = [];
      Object.entries(items2).forEach(([key, value]) => {
        storeData.push({
          [valueField]: key,
          [displayField]: value
        });
      });
    }
    if (me.store) {
      me.store.data = storeData;
    } else {
      const valueFieldDefinition = valueField === displayField ? {
        name: "value",
        dataSource: displayField
      } : valueField;
      me.store = new Store({
        isItemStore: true,
        data: storeData,
        idField: valueField,
        verifyNoGeneratedIds: false,
        modelClass: itemModel || class extends Model {
          static get idField() {
            return me.valueField;
          }
          static set idField(idField) {
            super.idField = idField;
          }
          static get fields() {
            return [valueFieldDefinition, displayField];
          }
        }
      });
    }
  }
  get value() {
    const me = this, {
      valueCollection,
      valueField
    } = me;
    if (valueField == null) {
      return me.multiSelect ? valueCollection.values.slice() : valueCollection.first;
    }
    let value;
    if (me.multiSelect) {
      value = valueCollection.count ? valueCollection.map((r) => r[valueField]) : me._lastValue || [];
    } else {
      value = valueCollection.count ? valueCollection.first[valueField] : me._lastValue;
    }
    return value;
  }
  set value(value) {
    super.value = value;
  }
  get needsInputSync() {
    return this.usesChipView ? false : !this.editable;
  }
  changeValue(value, oldValue) {
    var _me$hidePickerOnSelec;
    const me = this;
    if (value === oldValue) {
      me.syncInputFieldValue(true);
      return;
    }
    if (!me.multiSelect && Array.isArray(value) && value.length > 1) {
      throw new Error("Multiple values cannot be set to a non-multiSelect Combo");
    }
    me.triggerConfig("items");
    if (!me.inputting) {
      var _me$_chipView;
      (_me$_chipView = me._chipView) === null || _me$_chipView === void 0 ? void 0 : _me$_chipView.selected.clear();
    }
    if (!me.store) {
      me.items = [];
    }
    const {
      valueField,
      displayField,
      store,
      valueCollection,
      _picker
    } = me, {
      storage
    } = store, hidePicker = (_me$hidePickerOnSelec = me.hidePickerOnSelect) !== null && _me$hidePickerOnSelec !== void 0 ? _me$hidePickerOnSelec : !me.multiSelect, isUserAction = me._isUserAction || (_picker === null || _picker === void 0 ? void 0 : _picker._isUserAction) || hidePicker && me.pickerVisible || false;
    if (!me.remoteFilter && store.isAjaxStore && !store.count) {
      store.ion({
        load: () => me.value = value,
        once: true,
        thisObj: me
      });
      me._lastValue = value;
      return;
    }
    if (me.remoteFilter) {
      if (value != null) {
        if (ObjectHelper.isObject(value) || value.isModel) {
          me.store.data = [value];
          me.valueCollection.splice(0, me.valueCollection.count, me.store.first);
        } else {
          const wasConfiguring = me.isConfiguring;
          me.primaryFilter.setConfig({
            value,
            disabled: false
          });
          store.performFilter(true).then(() => {
            if (me.isDestroyed) {
              return;
            }
            const {
              isConfiguring
            } = me;
            me.isConfiguring = wasConfiguring;
            valueCollection.splice(0, valueCollection.count, store.allRecords);
            me.isConfiguring = isConfiguring;
          });
        }
        return;
      }
    } else if (store.filtered) {
      me.primaryFilter.disabled = true;
      store.filter();
    }
    let record;
    if (value != null) {
      const arrayPassed = Array.isArray(value), values = arrayPassed ? value.slice() : [value];
      for (let i = 0, len = values.length; i < len; i++) {
        let currentValue = values[i];
        if (currentValue instanceof Model) {
          if (!storage.includes(currentValue, true)) {
            store.add(currentValue);
          }
        } else {
          const isObject2 = ObjectHelper.isObject(currentValue);
          if (isObject2) {
            currentValue = currentValue[store.modelClass.fieldMap[valueField].dataSource];
          }
          record = storage.getBy(displayField, currentValue) || storage.getBy(valueField, currentValue) || valueCollection.getBy(displayField, currentValue) || valueCollection.getBy(valueField, currentValue);
          if (record instanceof Set) {
            record = [...record][0];
          }
          if (record) {
            if (isObject2) {
              record.set(values[i]);
            }
            values[i] = record;
          } else {
            values.splice(i, 1);
            len--;
            i--;
          }
        }
      }
      const noMatches = !values.length;
      const vcGen = valueCollection.generation;
      valueCollection.splice(0, valueCollection.count, values);
      if (noMatches) {
        me._value = arrayPassed && value.length === 0 ? null : value;
        me._lastValue = me._value;
      }
      if (noMatches || valueCollection.generation === vcGen) {
        me.syncInputFieldValue();
      }
      me.syncEmpty();
      if (noMatches && !me.isConfiguring) {
        me.triggerFieldChange({
          value,
          oldValue,
          userAction: isUserAction,
          valid: me.isValid
        });
      }
    } else {
      if (valueCollection.count) {
        valueCollection.clear();
      } else {
        const oldValue2 = me._value;
        me._value = null;
        me.syncInputFieldValue();
        me.syncEmpty();
        if (!me.isConfiguring) {
          me.triggerFieldChange({
            value,
            oldValue: oldValue2,
            userAction: isUserAction,
            valid: me.isValid
          });
        }
      }
    }
    me._lastValue = me._value;
  }
  hasChanged(oldValue, newValue) {
    if (this.multiSelect) {
      return !ObjectHelper.isEqual(oldValue, newValue);
    }
    return super.hasChanged(...arguments);
  }
  onComboStoreChange({
    action
  }) {
    if (action !== "filter") {
      this.syncInputFieldValue(true);
    }
  }
  syncInputFieldValue(skipHighlight) {
    if (this.usesChipView) {
      var _this$chipView;
      (_this$chipView = this.chipView) === null || _this$chipView === void 0 ? void 0 : _this$chipView.refresh();
    } else {
      super.syncInputFieldValue(skipHighlight);
    }
  }
  get usesChipView() {
    return Boolean(this.multiSelect && this._chipView);
  }
  get isEmpty() {
    return this.valueCollection.count === 0;
  }
  get inputValue() {
    const me = this;
    let result = me.selected ? me.selected[me.displayField] : me.value;
    if (me.displayValueRenderer) {
      result = me.callback(me.displayValueRenderer, me, [me.selected, me]);
    }
    return result == null ? "" : result;
  }
  get nonEditableClickTarget() {
    var _this$chipView2;
    return this.multiSelect && ((_this$chipView2 = this.chipView) === null || _this$chipView2 === void 0 ? void 0 : _this$chipView2.element) || super.nonEditableClickTarget;
  }
  changeValueCollection(valueCollection, oldValueCollection) {
    oldValueCollection === null || oldValueCollection === void 0 ? void 0 : oldValueCollection.destroy();
    if (valueCollection) {
      if (!valueCollection.isCollection) {
        valueCollection = new Collection({
          internalListeners: {
            noChange: "onValueCollectionNoChange",
            change: "onValueCollectionChange",
            prio: -1e3,
            thisObj: this
          }
        });
      }
      return valueCollection;
    }
  }
  changePrimaryFilter(primaryFilter) {
    if (primaryFilter.isCollectionFilter) {
      primaryFilter.setConfig({
        disabled: true,
        property: this.displayField,
        operator: this.filterOperator,
        caseSensitive: this.caseSensitive
      });
    } else {
      if (typeof primaryFilter === "function") {
        primaryFilter = {
          filterBy: primaryFilter
        };
      }
      primaryFilter = new CollectionFilter(_objectSpread2({
        "id": "primary",
        disabled: true,
        property: this.displayField,
        operator: this.filterOperator,
        caseSensitive: this.caseSensitive
      }, primaryFilter));
    }
    return primaryFilter;
  }
  changeStore(store) {
    const me = this, storeFilters = [], {
      valueCollection,
      keyStrokeFilterDelay,
      filterParamName
    } = me;
    if (Array.isArray(store)) {
      me.items = store;
      return;
    }
    let remoteFilter;
    if (store) {
      if (store.isStore) {
        const sharedFilter = store.filters.get("primary");
        if (me.remoteFilter) {
          store.filterParamName = filterParamName;
        }
        remoteFilter = store.remoteFilter || store.restfulFilter;
        if (sharedFilter) {
          me.primaryFilter = sharedFilter;
        } else {
          storeFilters.push(me.primaryFilter);
        }
      } else {
        if (typeof store === "string") {
          store = Store.getStore(store);
        } else {
          store = new (store.readUrl ? AjaxStore : Store)(store);
          me.destroyStore = true;
        }
        remoteFilter = me.remoteFilter || store.restfulFilter;
        if (remoteFilter && filterParamName) {
          store.filterParamName = filterParamName;
          if (me.encodeFilterParams) {
            store.encodeFilterParams = me.encodeFilterParams;
          }
        }
        storeFilters.push(me.primaryFilter);
      }
      if (!me.valueField && !me.usingRecordAsValue) {
        me.valueField = store.modelClass.idField;
      }
      if (me.filterSelected) {
        const selectedItemsFilter = (r) => !me.containsFocus || !valueCollection.includes(r);
        if (remoteFilter) {
          store.storage.autoFilter = true;
          store.storage.addFilter({
            id: `${me.id}-selected-filter`,
            filterBy: selectedItemsFilter
          });
        } else {
          storeFilters.push(selectedItemsFilter);
          store.reapplyFilterOnAdd = true;
        }
      }
      valueCollection.addIndex({
        property: me.displayField,
        unique: false
      });
      valueCollection.addIndex({
        property: me.valueField,
        unique: true
      });
      storeFilters.forEach((f) => store.addFilter(f, true));
      if (remoteFilter) {
        me.keyStrokeFilterDelay = Math.max(300, keyStrokeFilterDelay || 0);
      } else {
        me.keyStrokeFilterDelay = keyStrokeFilterDelay !== null && keyStrokeFilterDelay !== void 0 ? keyStrokeFilterDelay : 10;
      }
    }
    return store;
  }
  updateStore(store, oldStore) {
    const me = this, {
      _picker
    } = me;
    let storeListeners;
    if (me.destroyStore && oldStore) {
      oldStore.destroy();
    }
    if (_picker) {
      _picker.store = store;
    }
    store.storage.addIndex({
      property: me.displayField,
      unique: false
    });
    store.storage.addIndex({
      property: me.valueField,
      unique: true
    });
    storeListeners = {
      filter: "onStoreFilter"
    };
    if (me.displayValueRenderer) {
      (storeListeners || (storeListeners = {})).change = "onComboStoreChange";
    }
    me.detachListeners("store");
    (store === null || store === void 0 ? void 0 : store.storage) && me.valueCollection.match(store.storage);
    me.syncInputFieldValue();
    if (storeListeners) {
      storeListeners.name = "store";
      storeListeners.thisObj = me;
      store.ion(storeListeners);
    }
  }
  get remoteFilter() {
    var _this$_store;
    return Boolean(this.filterParamName || ((_this$_store = this._store) === null || _this$_store === void 0 ? void 0 : _this$_store.restfulFilter));
  }
  get record() {
    return this.selected;
  }
  get records() {
    return this.valueCollection.values.slice();
  }
  get selected() {
    const {
      store
    } = this;
    return this.multiSelect ? this.valueCollection.values.slice().sort((l, r) => store.indexOf(l) - store.indexOf(r))[0] : this.valueCollection.first;
  }
  onEditComplete() {
    const me = this, selectionCount = me.valueCollection.count;
    super.onEditComplete();
    if (selectionCount) {
      me.clearError(errorValidateFilter);
      me.syncInputFieldValue();
    }
    if (me.required && !selectionCount) {
      me.setError(errorFieldRequired);
    }
  }
  onTriggerClick(event) {
    const me = this, activatePicker = "key" in event;
    if (me.ignoreTriggerClick || me.remoteFilter && me.filterOnEnter) {
      return;
    }
    if (me.pickerVisible) {
      me.hidePicker();
    } else if (!me.readOnly && !me.disabled) {
      var _me$triggerAction;
      switch ((_me$triggerAction = me.triggerAction) === null || _me$triggerAction === void 0 ? void 0 : _me$triggerAction.toLowerCase()) {
        case "all":
          me.doFilter(null, activatePicker);
          break;
        case "last":
          me.doFilter(me.lastQuery, activatePicker);
          break;
        default:
          me.doFilter(me.input.value, activatePicker);
      }
    }
  }
  internalOnInput(event) {
    const me = this;
    me.syncEmpty();
    me.syncInputWidth();
    me.filterOnInput(event);
    me.trigger("input", {
      value: me.input.value,
      event
    });
  }
  filterOnInput(event) {
    const me = this, value = event.target.value, inputLen = value.length;
    me.inputting = true;
    if (me.inlinePicker || inputLen >= me.minChars && (!me.filterOnEnter || event.key === "Enter")) {
      me.doFilter(value);
    } else {
      if (me.validateFilter && !me.remoteFilter) {
        me[inputLen ? "setError" : "clearError"](errorValidateFilter);
      }
      me.hidePicker();
    }
    me.inputting = false;
  }
  syncInputWidth() {
    const me = this;
    if (me.usesChipView) {
      const input = me.input, inputPadding = me._inputPadding || (me._inputPadding = DomHelper.getEdgeSize(input, "padding", "lr")), value = input.value || "", width = DomHelper.measureText(value + "W", input, false, me.element) + inputPadding.width;
      input.style.flex = `1 1 ${Math.ceil(width)}px`;
    }
  }
  doFilter(queryString, activatePicker) {
    var _me$filterPromise;
    const me = this, {
      store,
      picker
    } = me, disableFilter = queryString == null || queryString === "";
    me.lastQuery = queryString;
    me.primaryFilter.setConfig({
      value: queryString,
      disabled: disableFilter
    });
    if (me.remoteFilter) {
      store.clear(true);
    }
    const onAfterFilter = () => {
      const {
        navigator: navigator2,
        isVisible: isVisible2
      } = picker;
      if (store.count) {
        if (!disableFilter && navigator2) {
          navigator2.activeItem = 0;
        }
      } else if (!me.remoteFilter && !disableFilter) {
        if (navigator2) {
          navigator2.activeItem = null;
        }
        if (me.validateFilter) {
          me.setError(errorValidateFilter);
        }
      }
      isVisible2 && picker.realign();
    };
    (_me$filterPromise = me.filterPromise = store.filter()) === null || _me$filterPromise === void 0 ? void 0 : _me$filterPromise.then(() => {
      me.filterPromise = null;
      onAfterFilter();
    });
    if (!me.inlinePicker) {
      if (picker !== null && picker !== void 0 && picker.isVisible) {
        if (picker.lastAlignSpec.zone === 0) {
          picker.realign();
        }
      } else {
        me.showPicker(activatePicker);
      }
    }
    if (!me.filterPromise) {
      onAfterFilter();
    }
  }
  onStoreFilter({
    source: store
  }) {
    const me = this, picker = me._picker, dataset = picker === null || picker === void 0 ? void 0 : picker.element.dataset, {
      count
    } = store;
    if (me.remoteFilter) {
      if (count) {
        if (picker) {
          picker.navigator.activeItem = 0;
        }
      } else {
        if (me.validateFilter) {
          me.setError(errorValidateFilter);
        }
      }
      if (me.filterSelected && me.valueCollection.count) {
        store.storage.onFiltersChanged({
          action: "splice",
          oldCount: 1
        });
        if (picker) {
          picker.refresh();
        }
      }
    }
    if (dataset) {
      if (me.createOnUnmatched && !count) {
        dataset.addNewValue = me.L("L{addNewValue}")(me.primaryFilter.value);
      } else {
        dataset === null || dataset === void 0 ? true : delete dataset.addNewValue;
      }
    }
  }
  onValueCollectionChange({
    source: valueCollection
  }) {
    var _me$hidePickerOnSelec2;
    const me = this, {
      multiSelect,
      _picker
    } = me, hidePicker = (_me$hidePickerOnSelec2 = me.hidePickerOnSelect) !== null && _me$hidePickerOnSelec2 !== void 0 ? _me$hidePickerOnSelec2 : !multiSelect, record = multiSelect ? valueCollection.values.slice() : valueCollection.first, records = valueCollection.values.slice(), isUserAction = me._isUserAction || (_picker === null || _picker === void 0 ? void 0 : _picker._isUserAction) || hidePicker && me.pickerVisible || false, oldValue = me._value;
    if (hidePicker) {
      me.hidePicker();
    }
    if (!valueCollection.count && me.required) {
      me.setError(errorFieldRequired);
    } else {
      me.clearError(errorFieldRequired);
      me.clearError(errorValidateFilter);
    }
    if (me.validateFilter && record) {
      me.clearError(errorValidateFilter);
    }
    if (me.filterSelected) {
      if (me.remoteFilter) {
        me.store.storage.onFiltersChanged({
          action: "splice",
          oldCount: 1
        });
        if (me._picker) {
          me._picker.refresh();
        }
      } else {
        me.store.filter();
      }
    }
    me._value = null;
    me._lastValue = null;
    const value = me.cacheCurrentValue(me.value);
    me.syncInputFieldValue();
    me.syncEmpty();
    if (!me.isConfiguring) {
      me.triggerFieldChange({
        value,
        oldValue,
        userAction: isUserAction,
        valid: me.isValid
      });
      me.trigger("select", {
        record,
        records,
        userAction: isUserAction
      });
      if (me.defaultAction === "select") {
        me.trigger("action", {
          value,
          record,
          records,
          userAction: isUserAction
        });
      }
    }
  }
  cacheCurrentValue(v) {
    return this._value = v;
  }
  onValueCollectionNoChange({
    toAdd
  }) {
    if (!this.inlinePicker && !this.multiSelect && toAdd.length && this.pickerVisible) {
      this.picker.hide();
    }
  }
  showPicker() {
    const me = this, {
      picker
    } = me;
    if (me.readOnly || me.inlinePicker) {
      return;
    }
    picker.multiSelect = me.multiSelect;
    super.showPicker(...arguments);
    if (me.overlayAnchor && !picker.align.offset) {
      picker.align.offset = -picker.anchorSize[1];
      picker.realign();
    }
    if (picker.restoreActiveItem) {
      if (me.multiSelect) {
        var _picker$navigator;
        picker.restoreActiveItem(((_picker$navigator = picker.navigator) === null || _picker$navigator === void 0 ? void 0 : _picker$navigator.previousActiveItem) || me.selected || 0, true);
      } else {
        picker.restoreActiveItem(me.selected || 0, true);
      }
    }
    me.input.focus();
  }
  changePicker(picker, oldPicker) {
    var _picker2;
    const me = this, pickerWidth = me.pickerWidth || ((_picker2 = picker) === null || _picker2 === void 0 ? void 0 : _picker2.width), config = List.mergeConfigs({
      owner: me,
      store: me.store,
      selected: me.valueCollection,
      multiSelect: me.multiSelect,
      cls: me.listCls,
      displayField: me.displayField,
      forElement: me[me.pickerAlignElement],
      align: {
        matchSize: pickerWidth == null,
        anchor: me.overlayAnchor,
        target: me[me.pickerAlignElement],
        minHeight: me.inlinePicker ? null : Math.min(3, me.store.count) * 40
      },
      [me.listItemTpl ? "itemTpl" : void 0]: me.listItemTpl,
      width: pickerWidth,
      navigator: {
        keyEventTarget: me.input
      }
    }, picker);
    if (me.inlinePicker) {
      Object.assign(config, {
        floating: false,
        align: null,
        activateOnMouseover: false,
        maxHeight: null,
        appendTo: me.element
      });
    }
    picker = List.reconfigure(oldPicker, picker ? config : null, me);
    if (picker) {
      picker.element.classList.add("b-combo-picker");
      picker.element.dataset.emptyText = me.emptyText ? me.L(me.emptyText) : me.L("L{noResults}");
      picker.ion({
        navigate: "onPickerNavigate",
        thisObj: me
      });
    }
    return picker;
  }
  onPickerNavigate({
    event
  }) {
    if (event.target.matches("[data-add-new-value]")) {
      this.addNewRecord(this.primaryFilter.value);
    }
  }
  onPickerHide() {
    const me = this;
    super.onPickerHide();
    if (me.multiSelect && me.clearTextOnPickerHide) {
      me.input.value = "";
    }
  }
  async internalOnKeyEvent(keyEvent) {
    const me = this, value = me.input[me.inputValueAttr], inputLen = value.length, {
      key
    } = keyEvent, {
      store,
      _picker: picker,
      multiSelect
    } = me;
    if (keyEvent.type === "keydown" && picker !== null && picker !== void 0 && picker.isVisible && picker.navigator) {
      const {
        activeItem
      } = picker.navigator;
      if (activeItem && multiSelect && key === me.multiValueSeparator) {
        me.input.value = "";
        me.primaryFilter.setConfig({
          value: "",
          disabled: true
        });
        store.filter();
        picker.onItemClick(activeItem, keyEvent);
        picker.hide();
        keyEvent.preventDefault();
        return;
      }
      if (!activeItem && me.createOnUnmatched && (multiSelect && key === me.multiValueSeparator || key === "Enter")) {
        keyEvent.preventDefault();
        await me.addNewRecord(value);
        return;
      }
    }
    super.internalOnKeyEvent(...arguments);
    if (keyEvent.type === "keydown" && key === "Enter" && me.filterOnEnter && inputLen >= me.minChars) {
      keyEvent.stopPropagation();
      me.filterOnInput.now(keyEvent);
    }
  }
  async addNewRecord(value) {
    const me = this, {
      store,
      _picker: picker,
      valueCollection,
      multiSelect,
      primaryFilter
    } = me, remoteAutoCommit = store.remoteFilter && store.autoCommit;
    if (me.filterPromise) {
      await me.filterPromise;
    }
    if (!remoteAutoCommit) {
      primaryFilter.setConfig({
        value: "",
        disabled: true
      });
      store.filter();
    }
    const [newRecord] = store.add(me.callback(me.createOnUnmatched, me, [value, me]));
    if (store.isCommitting) {
      let error;
      try {
        await store.commitPromise;
      } catch (exception) {
        var _exception$response, _exception$response$p;
        error = (_exception$response = exception.response) === null || _exception$response === void 0 ? void 0 : (_exception$response$p = _exception$response.parsedJson) === null || _exception$response$p === void 0 ? void 0 : _exception$response$p.error;
      }
      if (newRecord.isPhantom) {
        me.clearError();
        me.setError(error || errorRecordNotCommitted, false, true);
        store.remove(newRecord);
        store.removed.remove(newRecord);
      }
    }
    if (remoteAutoCommit) {
      primaryFilter.setConfig({
        value: "",
        disabled: true
      });
      store.filter();
    }
    me.input.value = "";
    if (store.includes(newRecord)) {
      valueCollection.splice(multiSelect ? valueCollection.count : 0, multiSelect ? 0 : valueCollection.count, newRecord);
    }
    picker === null || picker === void 0 ? void 0 : picker.hide();
  }
  changeCreateOnUnmatched(createOnUnmatched) {
    if (createOnUnmatched === true) {
      createOnUnmatched = this.defaultRecordCreater;
    }
    return createOnUnmatched;
  }
  defaultRecordCreater(value) {
    return this.store.createRecord({
      [this.displayField]: value
    });
  }
  updateLocalization() {
    super.updateLocalization();
    const me = this, {
      displayField
    } = me;
    let {
      localizedDisplayFieldsMap
    } = me;
    if (me.localizeDisplayFields === true) {
      if (!localizedDisplayFieldsMap) {
        me.localizedDisplayFieldsMap = localizedDisplayFieldsMap = /* @__PURE__ */ new Map();
      }
      if (!me.store && me.buildItems) {
        me.items = me.buildItems();
      }
      for (const item of me.items) {
        if (item.id) {
          var _item$displayField;
          let localeString = localizedDisplayFieldsMap.get(item.id);
          if (!localeString && (_item$displayField = item[displayField]) !== null && _item$displayField !== void 0 && _item$displayField.startsWith("L{")) {
            localeString = item[displayField];
            localizedDisplayFieldsMap.set(item.id, localeString);
          }
          if (localeString) {
            item[displayField] = me.L(localeString);
          }
        }
      }
      me.syncInputFieldValue();
    }
  }
};
_defineProperty(Combo, "delayable", {
  filterOnInput: 0
});
var ComboChipView = class extends ChipView {
  static get $name() {
    return "ComboChipView";
  }
  static get type() {
    return "combochipview";
  }
  static get defaultConfig() {
    return {
      closeHandler: "up.onChipClose",
      itemsFocusable: false,
      multiSelect: true,
      itemTpl(record) {
        return StringHelper.encodeHtml(record[this.owner.displayField]);
      },
      scrollable: {
        overflowY: "auto"
      }
    };
  }
};
var ComboChipNavigator = class extends Navigator {
  static get $name() {
    return "ComboChipNavigator";
  }
  static get type() {
    return "combochipnavigator";
  }
  static get configurable() {
    return {
      allowShiftKey: true
    };
  }
  onTargetClick(clickEvent) {
    const me = this, item = clickEvent.target.closest(me.itemSelector);
    if (item && !clickEvent.target.classList.contains("b-close-icon")) {
      if (!clickEvent.shiftKey && !item.contains(clickEvent.target.closest("[data-noselect]"))) {
        me.ownerCmp.selected.clear();
      }
      me.inClickHandler = true;
      me.activeItem = item;
      me.inClickHandler = false;
    }
  }
  onKeyDown(keyEvent) {
    if (keyEvent.key !== "Enter") {
      super.onKeyDown(keyEvent);
    }
  }
  updateActiveItem(activeItem, oldActiveItem) {
    const chipView = this.ownerCmp;
    super.updateActiveItem(activeItem, oldActiveItem);
    if (activeItem && !this.inClickHandler) {
      chipView.selected.add(chipView.getRecordFromElement(activeItem));
    }
  }
  navigatePrevious(keyEvent) {
    const chipView = this.ownerCmp;
    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }
    if (this.previous) {
      super.navigatePrevious(keyEvent);
    } else {
      this.activeItem = null;
    }
  }
  navigateNext(keyEvent) {
    const chipView = this.ownerCmp;
    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }
    if (this.next) {
      super.navigateNext(keyEvent);
    } else {
      this.activeItem = null;
    }
  }
};
Combo.initClass();
ComboChipView.initClass();
ComboChipNavigator.initClass();
Combo._$name = "Combo";
var UndoRedoBase = class extends Container {
  static get $name() {
    return "UndoRedoBase";
  }
  static get type() {
    return "undoredobase";
  }
  static get configurable() {
    return {
      project: null,
      stm: null,
      text: null,
      color: null,
      showZeroActionBadge: null,
      cls: "b-undo-controls b-toolbar",
      layoutStyle: {
        alignItems: "stretch",
        flexFlow: "row nowrap",
        overflow: "visible"
      },
      items: {
        undoBtn: {
          type: "button",
          icon: "b-icon-undo",
          tooltip: "L{UndoRedo.UndoLastAction}",
          onAction: "up.onUndo"
        },
        transactionsCombo: {
          type: "combo",
          valueField: "idx",
          editable: false,
          store: {},
          emptyText: "L{UndoRedo.NoActions}",
          onAction: "up.onTransactionSelected",
          displayValueRenderer: "up.transactionsDisplayValueRenderer"
        },
        redoBtn: {
          type: "button",
          icon: "b-icon-redo",
          tooltip: "L{UndoRedo.RedoLastAction}",
          onAction: "up.onRedo"
        }
      }
    };
  }
  afterConstruct() {
    this.updateUndoRedoControls();
  }
  updateStm(stm) {
    this.detachListeners("undoredo");
    stm === null || stm === void 0 ? void 0 : stm.ion({
      name: "undoredo",
      recordingstop: "updateUndoRedoControls",
      restoringstop: "updateUndoRedoControls",
      queueReset: "updateUndoRedoControls",
      disabled: "updateUndoRedoControls",
      thisObj: this
    });
  }
  changeItems(items2) {
    const {
      undoBtn,
      redoBtn
    } = items2;
    if (this.color) {
      undoBtn && (undoBtn.color = this.color);
      redoBtn && (redoBtn.color = this.color);
    }
    if (this.text) {
      undoBtn && (undoBtn.text = "L{UndoRedo.Undo}");
      redoBtn && (redoBtn.text = "L{UndoRedo.Redo}");
    }
    return super.changeItems(items2);
  }
  updateProject(project) {
    this.stm = project.stm;
  }
  fillUndoRedoCombo() {
    const {
      transactionsCombo
    } = this.widgetMap;
    transactionsCombo && (transactionsCombo.items = this.stm.queue.map((title, idx) => [idx, title || `Transaction ${idx}`]));
  }
  updateUndoRedoControls() {
    const {
      stm,
      showZeroActionBadge
    } = this, {
      undoBtn,
      redoBtn
    } = this.widgetMap;
    undoBtn.badge = stm.position || (showZeroActionBadge ? "0" : "");
    redoBtn.badge = stm.length - stm.position || (showZeroActionBadge ? "0" : "");
    undoBtn.disabled = !stm.canUndo;
    redoBtn.disabled = !stm.canRedo;
    this.fillUndoRedoCombo();
  }
  transactionsDisplayValueRenderer(record, combo) {
    var _this$stm;
    const stmPos = ((_this$stm = this.stm) === null || _this$stm === void 0 ? void 0 : _this$stm.position) || 0;
    return `${stmPos} undo actions / ${combo.store.count - stmPos} redo actions`;
  }
  onUndo() {
    this.stm.canUndo && this.stm.undo();
  }
  onRedo() {
    this.stm.canRedo && this.stm.redo();
  }
  onTransactionSelected(combo) {
    const stm = this.stm, value = combo.value;
    if (value >= 0) {
      if (stm.canUndo && value < stm.position) {
        stm.undo(stm.position - value);
      } else if (stm.canRedo && value >= stm.position) {
        stm.redo(value - stm.position + 1);
      }
    }
  }
};
UndoRedoBase._$name = "UndoRedoBase";
var BooleanCombo = class extends Combo {
  static get $name() {
    return "BooleanCombo";
  }
  static get type() {
    return "booleancombo";
  }
  static get configurable() {
    return {
      positiveValue: true,
      positiveText: null,
      negativeValue: false,
      negativeText: null,
      store: {
        value: [],
        $config: "lazy"
      },
      value: false
    };
  }
  changeStore(store, oldStore) {
    const me = this;
    return super.changeStore(new Store({
      data: [{
        id: me.positiveValue,
        text: me.positiveText || me.L("L{Object.Yes}")
      }, {
        id: me.negativeValue,
        text: me.negativeText || me.L("L{Object.No}")
      }]
    }), oldStore);
  }
};
BooleanCombo.initClass();
BooleanCombo._$name = "BooleanCombo";
var ButtonGroup = class extends Container.mixin(Rotatable) {
  onChildAdd(item) {
    super.onChildAdd(item);
    item.ion({
      click: "resetValueCache",
      toggle: "onItemToggle",
      thisObj: this,
      prio: 1e4
    });
  }
  onChildRemove(item) {
    item.un({
      toggle: "resetValueCache",
      click: "resetValueCache",
      thisObj: this
    });
    super.onChildRemove(item);
  }
  onItemToggle(event) {
    const me = this;
    me.resetValueCache();
    if (!me.isSettingValue && (!me.toggleGroup || event.pressed)) {
      me.triggerFieldChange({
        value: me.value,
        userAction: true,
        event
      });
    }
  }
  resetValueCache() {
    this._value = null;
  }
  createWidget(widget) {
    const me = this, type = me.constructor.resolveType(widget.type || "button");
    if (type.isButton) {
      if (me.color && !widget.color) {
        widget.color = me.color;
      }
      if (me.toggleGroup && !widget.toggleGroup) {
        if (typeof me.toggleGroup === "boolean") {
          me.toggleGroup = ButtonGroup.generateId("toggleGroup");
        }
        widget.toggleGroup = me.toggleGroup;
      }
    }
    if (me.columns) {
      widget.width = `${100 / me.columns}%`;
    }
    widget = super.createWidget(widget);
    me.relayEvents(widget, ["click", "action", "toggle"]);
    return widget;
  }
  updateRotate(rotate) {
    this.eachWidget((btn) => {
      if (btn.rotate !== false) {
        btn.rotate = rotate;
      }
    });
  }
  get value() {
    if (!this._value) {
      const values = [];
      this.items.forEach((w) => {
        if (w.pressed && w.value !== void 0) {
          values.push(w.value);
        }
      });
      this._value = values.join(this.valueSeparator);
    }
    return this._value;
  }
  set value(value) {
    const me = this, oldValue = me.value;
    if (!Array.isArray(value)) {
      if (value === void 0 || value === null) {
        value = [];
      } else if (typeof value == "string") {
        value = value.split(me.valueSeparator);
      } else {
        value = [value];
      }
    }
    me._value = value.join(me.valueSeparator);
    me.isSettingValue = true;
    me.items.forEach((w) => {
      if (w.value !== void 0) {
        w.pressed = value.includes(w.value);
      }
    });
    me.isSettingValue = false;
    if (!me.isConfiguring && oldValue !== me.value) {
      me.triggerFieldChange({
        value: me.value,
        userAction: false
      });
    }
  }
  updateDisabled(disabled) {
    this.items.forEach((button) => button.disabled = disabled || !button.ignoreParentReadOnly && this.readOnly);
  }
  updateReadOnly(readOnly) {
    super.updateReadOnly(readOnly);
    this.updateDisabled(this.disabled);
  }
  get widgetClassList() {
    const classList = super.widgetClassList;
    this.columns && classList.push("b-columned");
    return classList;
  }
};
_defineProperty(ButtonGroup, "$name", "ButtonGroup");
_defineProperty(ButtonGroup, "type", "buttongroup");
_defineProperty(ButtonGroup, "configurable", {
  defaultType: "button",
  cls: null,
  items: null,
  color: null,
  toggleGroup: null,
  valueSeparator: ",",
  columns: null,
  hideWhenEmpty: true,
  defaultBindProperty: "value"
});
ButtonGroup.initClass();
ButtonGroup._$name = "ButtonGroup";
var CalendarPanel = class extends Panel {
  static get $name() {
    return "CalendarPanel";
  }
  static get type() {
    return "calendarpanel";
  }
  static get configurable() {
    return {
      textContent: false,
      date: {
        $config: {
          equal: "date"
        },
        value: null
      },
      month: {},
      year: null,
      weekStartDay: null,
      sixWeeks: true,
      showWeekNumber: null,
      showWeekColumn: null,
      disabledDates: null,
      headerRenderer: null,
      weekRenderer: null,
      cellRenderer: null,
      disableWeekends: null,
      hideNonWorkingDays: null,
      hideNonWorkingDaysCls: "b-hide-nonworking-days",
      nonWorkingDays: null,
      tip: null,
      dayCellCls: "b-calendar-cell",
      dayHeaderCls: "b-calendar-day-header",
      disabledCls: "b-disabled-date",
      otherMonthCls: "b-other-month",
      weekendCls: "b-weekend",
      todayCls: "b-today",
      nonWorkingDayCls: "b-nonworking-day",
      dayNameFormat: "ddd",
      minRowHeight: {
        $config: ["lazy"],
        value: null
      },
      minColumnWidth: {
        $config: ["lazy"],
        value: null
      },
      disableOtherMonthCells: null,
      disableOtherMonthCellsCls: "b-disable-othermonth-cells",
      hideOtherMonthCells: null,
      hideOtherMonthCellsCls: "b-hide-othermonth-cells",
      animateTimeShift: true
    };
  }
  construct(config) {
    super.construct(config);
    if (!this.refreshCount) {
      this.refresh();
    }
  }
  onPaint({
    firstPaint
  }) {
    var _super$onPaint;
    (_super$onPaint = super.onPaint) === null || _super$onPaint === void 0 ? void 0 : _super$onPaint.call(this, ...arguments);
    if (firstPaint) {
      if (!this.refreshCount) {
        this.refresh();
      }
      this.getConfig("minColumnWidth");
      this.getConfig("minRowHeight");
    }
  }
  get overflowElement() {
    return this.weeksElement;
  }
  doDestroy() {
    var _this$tip;
    (_this$tip = this.tip) === null || _this$tip === void 0 ? void 0 : _this$tip.destroy();
    super.doDestroy();
  }
  changeMinRowHeight(minRowHeight) {
    const minValue = parseInt(DomHelper.getStyleValue(this.element, "--min-row-height"), 10) || 75;
    return isNaN(minRowHeight) ? minRowHeight : Math.max(parseInt(minRowHeight) || 0, minValue);
  }
  updateMinRowHeight(minRowHeight) {
    this.weekElements.forEach((w) => DomHelper.setLength(w, "minHeight", minRowHeight));
    this.scrollable = {
      overflowY: minRowHeight ? "auto" : false
    };
  }
  changeMinColumnWidth(minColumnWidth) {
    const minValue = parseInt(DomHelper.getStyleValue(this.element, "--min-column-width"), 10) || 75;
    return minColumnWidth == null ? minColumnWidth : Math.max(parseInt(minColumnWidth) || 0, minValue);
  }
  updateMinColumnWidth(minColumnWidth) {
    const me = this;
    me.weekdayCells.forEach((c) => DomHelper.setLength(c, "minWidth", minColumnWidth));
    me.cellElements.forEach((c) => c.matches(`.${me.dayCellCls}`) && DomHelper.setLength(c, "minWidth", minColumnWidth));
    me.scrollable = {
      overflowX: minColumnWidth ? "auto" : false
    };
    me.overflowElement.classList[minColumnWidth ? "add" : "remove"]("b-min-columnwidth");
  }
  getDateFromDomEvent(domEvent) {
    const element = (domEvent.nodeType === Element.ELEMENT_NODE ? domEvent : domEvent.target).closest(`#${this.id} [data-date]`);
    if (element) {
      return DateHelper.parseKey(element.dataset.date);
    }
  }
  changeTip(tip, existingTip) {
    const me = this;
    return Tooltip.reconfigure(existingTip, tip, {
      owner: me,
      defaults: {
        type: "tooltip",
        owner: me,
        id: `${me.id}-cell-tip`,
        forElement: me.bodyElement,
        forSelector: `.${me.dayCellCls}`
      }
    });
  }
  updateTip(tip) {
    this.detachListeners("tip");
    tip === null || tip === void 0 ? void 0 : tip.ion({
      pointerOver: "onTipOverCell",
      name: "tip",
      thisObj: this
    });
  }
  updateElement(element, was) {
    const me = this;
    super.updateElement(element, was);
    me.updateHideNonWorkingDays(me.hideNonWorkingDays);
    me.weekdayCells = Array.from(element.querySelectorAll(".b-calendar-day-header"));
    me.weekElements = Array.from(element.querySelectorAll(".b-calendar-week"));
    me.weekDayElements = Array.from(element.querySelectorAll(".b-calendar-days"));
    me.cellElements = [];
    for (let i = 0, {
      length
    } = me.weekDayElements; i < length; i++) {
      me.cellElements.push(me.weekDayElements[i].previousSibling, ...me.weekDayElements[i].children);
    }
  }
  changeDate(date) {
    date = typeof date === "string" ? DateHelper.parse(date) : new Date(date);
    if (isNaN(date)) {
      throw new Error("CalendarPanel date ingestion must be passed a Date, or a YYYY-MM-DD date string");
    }
    return DateHelper.clearTime(date);
  }
  updateDate(value) {
    this.month.date = value;
  }
  updateDayNameFormat() {
    const d = new Date("2000-06-04T12:00:00");
    this.shortDayNames = [];
    for (let date = 4; date < 11; date++) {
      d.setDate(date);
      this.shortDayNames.push(DateHelper.format(d, this.dayNameFormat));
    }
  }
  get weekStartDay() {
    return typeof this._weekStartDay === "number" ? this._weekStartDay : DateHelper.weekStartDay;
  }
  updateWeekStartDay(weekStartDay) {
    const me = this;
    if (me._month) {
      me.month.weekStartDay = weekStartDay;
      me.dayNames = [];
      for (let i = 0; i < 7; i++) {
        me.dayNames[i] = me.shortDayNames[me.canonicalDayNumbers[i]];
      }
      if (me.refreshCount) {
        me.refresh();
      }
    }
  }
  updateHideNonWorkingDays(hideNonWorkingDays) {
    var _this$scrollable;
    this.contentElement.classList.toggle(this.hideNonWorkingDaysCls, Boolean(hideNonWorkingDays));
    (_this$scrollable = this.scrollable) === null || _this$scrollable === void 0 ? void 0 : _this$scrollable.syncOverflowState();
    if (this._month) {
      this.month.hideNonWorkingDays = hideNonWorkingDays;
    }
    if (!this.isConfiguring) {
      this.refresh();
    }
  }
  updateHideOtherMonthCells(hideOtherMonthCells) {
    var _this$scrollable2;
    this.element.classList.toggle(this.hideOtherMonthCellsCls, Boolean(hideOtherMonthCells));
    (_this$scrollable2 = this.scrollable) === null || _this$scrollable2 === void 0 ? void 0 : _this$scrollable2.syncOverflowState();
  }
  updateDisableOtherMonthCells(disableOtherMonthCells) {
    var _this$scrollable3;
    this.element.classList.toggle(this.disableOtherMonthCellsCls, Boolean(disableOtherMonthCells));
    (_this$scrollable3 = this.scrollable) === null || _this$scrollable3 === void 0 ? void 0 : _this$scrollable3.syncOverflowState();
  }
  get nonWorkingDays() {
    return this._nonWorkingDays || this._localeNonWorkingDays || (this._localeNonWorkingDays = DateHelper.nonWorkingDays);
  }
  get weekends() {
    return this._localeWeekends || (this._localeWeekends = DateHelper.weekends);
  }
  changeNonWorkingDays(nonWorkingDays) {
    return ObjectHelper.assign({}, nonWorkingDays);
  }
  updateNonWorkingDays(nonWorkingDays) {
    if (this._month) {
      var _this$scrollable4;
      this.month.nonWorkingDays = nonWorkingDays;
      this.refresh();
      (_this$scrollable4 = this.scrollable) === null || _this$scrollable4 === void 0 ? void 0 : _this$scrollable4.syncOverflowState();
    }
  }
  get visibleDayColumnIndex() {
    return this.month.visibleDayColumnIndex;
  }
  get dayColumnIndex() {
    return this.month.dayColumnIndex;
  }
  get canonicalDayNumbers() {
    return this.month.canonicalDayNumbers;
  }
  get visibleColumnCount() {
    return this.month.visibleColumnCount;
  }
  get weekLength() {
    return this.month.weekLength;
  }
  get startDate() {
    return this.month.startDate;
  }
  get duration() {
    return DateHelper.diff(this.month.startDate, this.month.endDate, "day") + 1;
  }
  get endDate() {
    const {
      endDate
    } = this.month;
    if (endDate) {
      return DateHelper.add(endDate, 1, "day");
    }
  }
  changeMonth(month2, currentMonth) {
    const me = this;
    if (!(month2 instanceof Month)) {
      if (typeof month2 === "number") {
        if (currentMonth) {
          currentMonth.month = month2;
          return;
        }
        const date = me.date || DateHelper.clearTime(new Date());
        date.setMonth(month2);
        month2 = {
          date
        };
      }
      month2 = Month.new({
        weekStartDay: me.weekStartDay,
        nonWorkingDays: me.nonWorkingDays,
        hideNonWorkingDays: me.hideNonWorkingDays,
        sixWeeks: me.sixWeeks
      }, month2);
    }
    month2.ion({
      dateChange: "onMonthDateChange",
      thisObj: me
    });
    return month2;
  }
  onMonthDateChange({
    source: month2,
    newDate,
    oldDate,
    changes
  }) {
    const me = this;
    me.year = month2.year;
    if (!me.isConfiguring) {
      if (!me.getCell(newDate) || changes.m || changes.y) {
        me.refresh();
        if (me.animateTimeShift && me.isVisible) {
          DomHelper.slideIn(me.contentElement, newDate > oldDate ? 1 : -1);
        }
      }
      me.trigger("dateChange", {
        changes,
        value: newDate,
        oldValue: oldDate
      });
    }
  }
  updateYear(year) {
    this.month.year = year;
  }
  updateShowWeekNumber(showWeekNumber) {
    this.updateShowWeekColumn(showWeekNumber);
  }
  updateShowWeekColumn(showWeekColumn) {
    const me = this;
    me.element.classList[showWeekColumn ? "add" : "remove"]("b-show-week-column");
    if (me.floating) {
      if (!me.isAligning) {
        me.realign();
      }
    }
  }
  updateSixWeeks(sixWeeks) {
    if (this.month) {
      this.month.sixWeeks = sixWeeks;
      this.refresh();
    }
  }
  refresh() {
    this.doRefresh();
  }
  doRefresh() {
    var _me$project;
    this.getConfig("element");
    const me = this, timeZone = me.timeZone != null ? me.timeZone : (_me$project = me.project) === null || _me$project === void 0 ? void 0 : _me$project.timeZone, today = timeZone != null ? TimeZoneHelper.toTimeZone(new Date(), timeZone) : new Date(), {
      weekElements,
      weekDayElements,
      date,
      month: month2,
      dayCellCls,
      dayHeaderCls,
      disabledCls,
      otherMonthCls,
      weekendCls,
      todayCls,
      nonWorkingDayCls,
      nonWorkingDays,
      canonicalDayNumbers,
      sixWeeks
    } = me;
    today.setHours(0, 0, 0, 0);
    if (!date) {
      me.date = today;
      return;
    }
    me.trigger("beforeRefresh");
    me.getConfig("dayNameFormat");
    for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
      const cell = me.weekdayCells[columnIndex], cellDay = me.canonicalDayNumbers[columnIndex], cellClassList = {
        [dayHeaderCls]: 1,
        [weekendCls]: DateHelper.weekends[cellDay],
        [nonWorkingDayCls]: nonWorkingDays[cellDay]
      };
      if (me.headerRenderer) {
        cell.innerHTML = "";
        me.callback(me.headerRenderer, me, [cell, columnIndex, cellDay]);
      } else {
        DomHelper.setInnerText(cell, me.shortDayNames[cellDay]);
      }
      DomHelper.syncClassList(cell, cellClassList);
      cell.dataset.columnIndex = columnIndex;
      cell.dataset.cellDay = cellDay;
    }
    let rowIndex = 0, cellIndex = 0, lastWorkingColumn = 6;
    for (let columnIndex = 6; columnIndex >= 0; columnIndex--) {
      if (!nonWorkingDays[canonicalDayNumbers[columnIndex]]) {
        lastWorkingColumn = columnIndex;
        break;
      }
    }
    weekElements[4].classList.toggle("b-hide-display", month2.weekCount < 5 && !sixWeeks);
    weekElements[5].classList.toggle("b-hide-display", month2.weekCount < 6 && !sixWeeks);
    month2.eachWeek((week, dates) => {
      const weekDayElement = weekDayElements[rowIndex], weekCells = [weekDayElement.previousSibling, ...weekDayElement.children];
      weekElements[rowIndex].dataset.week = `${week[0]},${week[1]}`;
      if (me.weekRenderer) {
        me.callback(me.weekRenderer, me, [weekCells[0], week]);
      } else {
        weekCells[0].innerText = week[1];
      }
      for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
        const date2 = dates[columnIndex], day2 = date2.getDay(), isNonWorking = nonWorkingDays[day2], cell = weekCells[columnIndex + 1], cellClassList = {
          [dayCellCls]: 1,
          [disabledCls]: me.isDisabledDate(date2),
          [otherMonthCls]: date2.getMonth() !== month2.month,
          [weekendCls]: DateHelper.weekends[day2],
          [todayCls]: date2.getTime() === today.getTime(),
          [nonWorkingDayCls]: isNonWorking,
          "b-last-working-day": columnIndex === lastWorkingColumn,
          "b-first-visible-cell": !(date2 - (me.firstVisibleDate || -1)),
          "b-last-visible-cell": !(date2 - (me.lastVisibleDate || -1)),
          [`b-day-of-week-${day2}`]: 1
        };
        DomHelper.syncClassList(cell, cellClassList);
        cell.dataset.date = DateHelper.makeKey(date2);
        cell.dataset.cellIndex = cellIndex;
        cell.dataset.columnIndex = columnIndex;
        if (cell.lastDomConfig) {
          delete cell.lastDomConfig.class;
          delete cell.lastDomConfig.className;
        }
        if (me.cellRenderer) {
          me.callback(me.cellRenderer, me, [{
            cell,
            date: date2,
            day: day2,
            row: weekElements[rowIndex],
            rowIndex,
            cellIndex,
            columnIndex,
            visibleColumnIndex: me.visibleDayColumnIndex[day2],
            week
          }]);
        } else {
          cell.innerHTML = date2.getDate();
        }
        cellIndex++;
      }
      rowIndex++;
    });
    me.visibleWeekCount = rowIndex;
    if (me.floating) {
      if (!me.isAligning) {
        me.realign();
      }
    }
    me.refreshCount = (me.refreshCount || 0) + 1;
    me.trigger("refresh");
  }
  isDisabledDate(date) {
    const day2 = date.getDay(), {
      disabledDates,
      nonWorkingDays
    } = this;
    if (this.disableWeekends && nonWorkingDays[day2]) {
      return true;
    }
    if (disabledDates) {
      if (Array.isArray(disabledDates)) {
        date = DateHelper.clearTime(date, true);
        return disabledDates.some((d) => !(DateHelper.clearTime(d, true) - date));
      } else {
        return this.callback(this.disabledDates, this, [date]);
      }
    }
  }
  get bodyConfig() {
    const result = super.bodyConfig, weeksContainerChildren = [];
    result.children = [{
      tag: "div",
      className: "b-calendar-row b-calendar-weekdays",
      reference: "weekdaysHeader",
      children: [{
        class: "b-week-number-cell"
      }, ...ArrayHelper.fill(7, {
        class: this.dayHeaderCls
      }), DomHelper.scrollBarPadElement]
    }, {
      className: "b-weeks-container notranslate",
      reference: "weeksElement",
      children: weeksContainerChildren
    }];
    for (let i = 0; i < 6; i++) {
      const weekRow = {
        className: "b-calendar-row b-calendar-week",
        dataset: {
          rowIndex: i
        },
        children: [{
          className: "b-week-number-cell"
        }, {
          className: "b-calendar-days",
          children: [{}, {}, {}, {}, {}, {}, {}],
          syncOptions: {
            ignoreRefs: true,
            strict: false
          }
        }]
      };
      weeksContainerChildren.push(weekRow);
    }
    return result;
  }
  get firstVisibleDate() {
    if (this.hideOtherMonthCells) {
      const {
        year,
        month: month2
      } = this.month;
      return new Date(year, month2, 1);
    }
    for (const me = this, date = me.month.startDate; ; date.setDate(date.getDate() + 1)) {
      if (!me.hideNonWorkingDays || !me.nonWorkingDays[date.getDay()]) {
        return date;
      }
    }
  }
  get lastVisibleDate() {
    const lastDate = DateHelper.add(this.endDate, -1, "d");
    if (this.hideOtherMonthCells) {
      return lastDate;
    }
    for (const me = this, date = lastDate; ; date.setDate(date.getDate() - 1)) {
      if (!me.hideNonWorkingDays || !me.nonWorkingDays[date.getDay()]) {
        return date;
      }
    }
  }
  getCell(date, strict) {
    if (!(typeof date === "string")) {
      date = DateHelper.makeKey(date);
    }
    const cell = this.weeksElement.querySelector(`[data-date="${date}"]`);
    if (cell && (!strict || !cell.classList.contains(this.otherMonthCls))) {
      return cell;
    }
  }
  onTipOverCell({
    source: tip,
    target
  }) {
    tip.date = DateHelper.parseKey(target.dataset.date);
  }
  updateLocalization() {
    this._localeNonWorkingDays = this._localeWeekends = null;
    this.updateDayNameFormat();
    this.updateWeekStartDay(this.weekStartDay);
    super.updateLocalization();
  }
};
CalendarPanel.initClass();
CalendarPanel._$name = "CalendarPanel";
var whenNotChecked = (field) => !field.value;
var Checkbox = class extends Field {
  static get $name() {
    return "Checkbox";
  }
  static get type() {
    return "checkbox";
  }
  static get alias() {
    return "check";
  }
  static get configurable() {
    return {
      inputType: "checkbox",
      autoCollapse: null,
      containerDefaults: {
        syncableConfigs: {
          disabled: (field) => field.disabled || !field.value
        },
        syncConfigTriggers: {
          autoCollapse: 1,
          value: 1
        }
      },
      text: "",
      checkedValue: true,
      uncheckedValue: false,
      color: null,
      value: "",
      toggleGroup: null,
      localizableProperties: ["label", "text"]
    };
  }
  construct(config) {
    if ("checked" in config) {
      config = ObjectHelper.assign({}, config);
      config.value = config.checked;
      delete config.checked;
    }
    super.construct(config);
    this.syncHasText();
  }
  get textLabelCls() {
    return "b-checkbox-label";
  }
  get innerElements() {
    return [this.inputElement, {
      tag: "label",
      class: this.textLabelCls,
      for: `${this.id}-input`,
      reference: "textLabel",
      html: this.text || ""
    }];
  }
  get inputElement() {
    const config = super.inputElement;
    if (this.toggleGroup) {
      config.dataset = {
        group: this.toggleGroup
      };
    }
    config.listeners = {
      click: "internalOnClick",
      change: "internalOnChange",
      input: "internalOnInput"
    };
    return config;
  }
  get checked() {
    return this.value;
  }
  set checked(value) {
    this.value = value;
  }
  syncHasText() {
    this.element.classList[this.text ? "add" : "remove"]("b-text");
  }
  updateText(value) {
    if (this.textLabel) {
      this.syncHasText();
      this.textLabel.innerHTML = value;
    }
  }
  afterSyncChildConfigs(container) {
    super.afterSyncChildConfigs(container);
    let {
      autoCollapse
    } = this;
    if (autoCollapse) {
      autoCollapse = autoCollapse === true ? whenNotChecked : autoCollapse;
      container.collapsed = autoCollapse(this);
    }
  }
  assignFieldValue(values, key, value) {
    this.value = value === this.checkedValue || (value === this.uncheckedValue ? false : null);
  }
  fetchInputValue() {
    if (!this.readOnly) {
      this.value = this.input.checked;
    }
  }
  gatherValue(values) {
    var _values$valueName;
    const me = this, value = me.value ? me.checkedValue : me.uncheckedValue, storedValue = value !== void 0, {
      valueName
    } = me;
    if (storedValue) {
      values[valueName] = value;
    }
    me.gatherValues(values, storedValue);
    if (value === true && ((_values$valueName = values[valueName]) === null || _values$valueName === void 0 ? void 0 : _values$valueName.value) === value) {
      delete values[valueName].value;
    }
  }
  changeValue(value) {
    return value === "false" ? false : Boolean(value);
  }
  updateValue(value) {
    var _me$container;
    const me = this, changed = me.input.checked !== value;
    me.input.checked = value;
    (_me$container = me.container) === null || _me$container === void 0 ? void 0 : _me$container.syncChildConfigs();
    if (changed && !me.inputting && !me.isConfiguring) {
      me.uncheckToggleGroupMembers();
      me.triggerChange(false);
    }
  }
  get inputValueAttr() {
    return "checked";
  }
  updateColor(value, was) {
    const classes = this.element.classList;
    if (was) {
      classes.remove(was);
    }
    if (value) {
      classes.add(value);
    }
  }
  getToggleGroupMembers() {
    const me = this, {
      checked,
      toggleGroup,
      input: checkedElement,
      type
    } = me, result = [];
    if (checked && toggleGroup) {
      DomHelper.forEachSelector(me.rootElement, `input[type=${type}][data-group=${toggleGroup}]`, (inputEl) => {
        if (inputEl !== checkedElement) {
          const partnerCheckbox = Widget.fromElement(inputEl);
          partnerCheckbox && result.push(partnerCheckbox);
        }
      });
    }
    return result;
  }
  uncheckToggleGroupMembers() {
    if (this.checked && this.toggleGroup) {
      this.getToggleGroupMembers().forEach((widget) => widget.checked = false);
    }
  }
  check() {
    this.checked = true;
  }
  uncheck() {
    this.checked = false;
  }
  toggle() {
    this.checked = !this.checked;
  }
  internalOnClick(event) {
    if (this.readOnly) {
      event.preventDefault();
      return false;
    }
    return this.trigger("click", {
      event
    });
  }
  internalOnChange(event) {
    const me = this;
    if (me.readOnly && me.value !== me.input.checked) {
      me.input.checked = me.value;
      return;
    }
    me.value = me.input.checked;
    if (!me.inputting) {
      me.inputting = true;
      me.triggerChange(true);
      me.inputting = false;
    }
  }
  updateInputReadOnly(readOnly) {
  }
  triggerChange(userAction) {
    const me = this, {
      checked
    } = me.input;
    const eventObject = {
      checked,
      value: checked,
      userAction,
      valid: true
    }, prevented = !checked && userAction && me.toggleGroup && me.getToggleGroupMembers().filter((widget) => widget.isVisible && !widget.disabled).length || me.trigger("beforeChange", eventObject) === false;
    if (prevented) {
      me.input.checked = me._value = !checked;
    } else {
      me.triggerFieldChange(eventObject, false);
      if (userAction) {
        me.uncheckToggleGroupMembers();
      }
      me.trigger("action", eventObject);
      me.trigger("change", eventObject);
      return true;
    }
  }
};
Checkbox.initClass();
Checkbox._$name = "Checkbox";
var YearPicker = class extends Panel {
  construct(config) {
    super.construct(_objectSpread2({
      year: new Date().getFullYear()
    }, config));
    EventHelper.on({
      element: this.contentElement,
      click: "onYearClick",
      delegate: ".b-yearpicker-year",
      thisObj: this
    });
  }
  get focusElement() {
    return this.getYearButton(this.year) || this.getYearButton(this.startYear);
  }
  getYearButton(y) {
    return this.contentElement.querySelector(`.b-yearpicker-year[data-year="${y}"]`);
  }
  get value() {
    return this.year;
  }
  set value(year) {
    this.year = year;
  }
  onYearClick({
    target
  }) {
    const clickedYear = Math.min(Math.max(parseInt(target.innerText), this.minYear || 1), this.maxYear || 9999);
    if (this.year === clickedYear) {
      this.trigger("select", {
        oldValue: clickedYear,
        value: clickedYear
      });
    } else {
      this.year = clickedYear;
    }
  }
  handleTitleClick(e) {
    this.trigger("titleClick", e);
  }
  previous() {
    this.startYear = this.startYear - this.yearButtonCount;
  }
  next() {
    this.startYear = this.endYear + 1;
  }
  ingestYear(year) {
    if (!isNaN(year)) {
      return ObjectHelper.isDate(year) ? year.getFullYear() : year;
    }
  }
  changeYear(year) {
    if (year = this.ingestYear(year)) {
      return Math.min(Math.max(year, this.minYear || 1), this.maxYear || 9999);
    }
  }
  updateYear(year, oldValue) {
    const me = this;
    if (!me.startYear || year > me.endYear) {
      me.startYear = year;
    } else if (year < me.startYear) {
      me.startYear = year - (me.yearButtonCount - 1);
    }
    if (!me.isConfiguring) {
      me.trigger("select", {
        oldValue,
        value: year
      });
    }
  }
  get endYear() {
    return this.startYear + this.yearButtonCount - 1;
  }
  changeStartYear(startYear) {
    if (startYear = this.ingestYear(startYear)) {
      startYear = this.minYear ? Math.max(startYear, this.minYear) : startYear;
      return this.maxYear ? Math.min(startYear, this.maxYear - (this.yearButtonCount - 1)) : startYear;
    }
  }
  async updateStartYear(startYear, oldStartYear) {
    if (this.isVisible) {
      DomHelper.slideIn(this.contentElement, Math.sign(startYear - oldStartYear));
    }
  }
  composeBody() {
    this.getConfig("year");
    const {
      startYear
    } = this, result = super.composeBody(), children = result.children[this.tbar ? 1 : 0].children = [];
    this.widgetMap.title.text = `${`000${startYear}`.slice(-4)} - ${`000${this.endYear}`.slice(-4)}`;
    for (let i = 0, y = startYear; i < this.yearButtonCount; i++, y++) {
      children.push({
        tag: "button",
        dataset: {
          year: y
        },
        class: {
          "b-yearpicker-year": 1,
          "b-selected": y === this.year
        },
        text: `000${y}`.slice(-4)
      });
    }
    return result;
  }
};
_defineProperty(YearPicker, "$name", "YearPicker");
_defineProperty(YearPicker, "type", "yearpicker");
_defineProperty(YearPicker, "configurable", {
  textContent: false,
  tbar: {
    overflow: null,
    items: {
      previous: {
        type: "tool",
        cls: "b-icon b-icon-previous",
        onAction: "up.previous",
        weight: 100
      },
      title: {
        type: "button",
        cls: "b-yearpicker-title",
        weight: 200,
        onAction: "up.handleTitleClick"
      },
      next: {
        type: "tool",
        cls: "b-icon b-icon-next",
        onAction: "up.next",
        weight: 300
      }
    }
  },
  itemCls: "b-year-container",
  yearButtonCount: 12,
  year: null,
  minYear: null,
  maxYear: null,
  startYear: null
});
YearPicker.initClass();
YearPicker._$name = "YearPicker";
var DisplayField = class extends TextField {
  static get $name() {
    return "DisplayField";
  }
  static get type() {
    return "displayfield";
  }
  static get alias() {
    return "display";
  }
  static get configurable() {
    return {
      readOnly: true,
      editable: false,
      cls: "b-display-field",
      template: null,
      ariaElement: "displayElement"
    };
  }
  get focusElement() {
  }
  changeReadOnly() {
    return true;
  }
  changeEditable() {
    return false;
  }
  get inputElement() {
    return {
      tag: "span",
      id: `${this.id}-input`,
      reference: "displayElement",
      html: this.template ? this.template(this.value) : StringHelper.encodeHtml(this.value)
    };
  }
};
DisplayField.initClass();
DisplayField._$name = "DisplayField";
var generateMonthNames = () => DateHelper.getMonthNames().map((m, i) => [i, m]);
var dateSort = (lhs, rhs) => lhs.valueOf() - rhs.valueOf();
var emptyArray = Object.freeze([]);
var ReadOnlyCombo = class extends Combo {
  static get $name() {
    return "ReadOnlyCombo";
  }
  static get type() {
    return "readonlycombo";
  }
  static get configurable() {
    return {
      editable: false,
      inputAttributes: {
        tag: "div",
        tabIndex: -1
      },
      inputValueAttr: "innerHTML",
      highlightExternalChange: false,
      monitorResize: false,
      triggers: {
        expand: false
      },
      picker: {
        align: {
          align: "t-b",
          axisLock: true,
          matchSize: false
        },
        cls: "b-readonly-combo-list",
        scrollable: {
          overflowX: false
        }
      }
    };
  }
};
ReadOnlyCombo.initClass();
var DatePicker = class extends CalendarPanel {
  static get $name() {
    return "DatePicker";
  }
  static get type() {
    return "datepicker";
  }
  static get delayable() {
    return {
      refresh: "raf"
    };
  }
  static get configurable() {
    return {
      activeDate: {
        value: new Date(),
        $config: {
          equal: "date"
        }
      },
      focusable: true,
      textContent: false,
      tbar: {
        overflow: null,
        items: {
          prevYear: {
            cls: "b-icon b-icon-first",
            onAction: "up.gotoPrevYear",
            tooltip: "L{DatePicker.gotoPrevYear}"
          },
          prevMonth: {
            cls: "b-icon b-icon-previous",
            onAction: "up.gotoPrevMonth",
            tooltip: "L{DatePicker.gotoPrevMonth}"
          },
          fields: {
            type: "container",
            cls: "b-datepicker-title",
            items: {
              monthField: {
                type: "readonlycombo",
                cls: "b-datepicker-monthfield",
                items: generateMonthNames(),
                internalListeners: {
                  select: "up.onMonthPicked"
                }
              },
              yearButton: {
                type: "button",
                cls: "b-datepicker-yearbutton",
                internalListeners: {
                  click: "up.onYearPickerRequested"
                }
              }
            }
          },
          nextMonth: {
            cls: "b-icon b-icon-next",
            onAction: "up.gotoNextMonth",
            tooltip: "L{DatePicker.gotoNextMonth}"
          },
          nextYear: {
            cls: "b-icon b-icon-last",
            onAction: "up.gotoNextYear",
            tooltip: "L{DatePicker.gotoNextYear}"
          }
        }
      },
      yearPicker: {
        value: {
          type: "YearPicker",
          yearButtonCount: 16,
          trapFocus: true,
          positioned: true,
          hidden: true,
          internalListeners: {
            titleClick: "up.onYearPickerTitleClick",
            select: "up.onYearPicked"
          }
        },
        $config: "lazy"
      },
      date: null,
      minDate: {
        value: null,
        $config: {
          equal: "date"
        }
      },
      maxDate: {
        value: null,
        $config: {
          equal: "date"
        }
      },
      focusDisabledDates: null,
      multiSelect: false,
      selection: {
        $config: {
          equal: (v1, v2) => v1 && v1.equals(v2)
        },
        value: null
      },
      editMonth: true,
      dayNameFormat: "dd",
      trapFocus: true,
      role: "grid",
      focusDescendant: true,
      alwaysRefreshOnMonthChange: null
    };
  }
  static get prototypeProperties() {
    return {
      outOfRangeCls: "b-out-of-range",
      activeCls: "b-active-date",
      selectedCls: "b-selected-date"
    };
  }
  construct(config) {
    const me = this;
    super.construct(config);
    me.externalCellRenderer = me.cellRenderer;
    me.cellRenderer = me.internalCellRenderer;
    me.element.setAttribute("aria-activedescendant", `${me.id}-active-day`);
    me.weeksElement.setAttribute("role", "grid");
    me.weekElements.forEach((w) => w.setAttribute("role", "row"));
    me.element.setAttribute("ariaLabelledBy", me.widgetMap.fields.id);
    EventHelper.on({
      element: me.weeksElement,
      click: {
        handler: "onCellClick",
        delegate: `.${me.dayCellCls}:not(.${me.disabledCls}):not(.${me.outOfRangeCls})`
      },
      mousedown: {
        handler: "onCellMousedown",
        delegate: `.${me.dayCellCls}`
      },
      thisObj: me
    });
    me.widgetMap.monthField.readOnly = me.widgetMap.yearButton.disabled = !me.editMonth;
    me.refresh.flush();
  }
  afterHide() {
    var _this$_yearPicker;
    (_this$_yearPicker = this._yearPicker) === null || _this$_yearPicker === void 0 ? void 0 : _this$_yearPicker.hide();
    super.afterHide(...arguments);
  }
  doDestroy() {
    var _this$yearButton, _this$monthField;
    (_this$yearButton = this.yearButton) === null || _this$yearButton === void 0 ? void 0 : _this$yearButton.destroy();
    (_this$monthField = this.monthField) === null || _this$monthField === void 0 ? void 0 : _this$monthField.destroy();
    super.doDestroy();
  }
  get focusElement() {
    return this.weeksElement.querySelector(`.${this.dayCellCls}[tabIndex="0"]`);
  }
  doRefresh() {
    const me = this, oldActiveCell = me.focusElement, activeDate = DateHelper.betweenLesser(me.activeDate, me.month.startDate, me.month.endDate) ? me.activeDate : me._activeDate = me.date;
    super.doRefresh(...arguments);
    const dateOfOldActiveCell = DateHelper.parseKey(oldActiveCell === null || oldActiveCell === void 0 ? void 0 : oldActiveCell.dataset.date);
    if (activeDate - dateOfOldActiveCell) {
      me.syncActiveDate(activeDate, dateOfOldActiveCell);
    }
  }
  internalCellRenderer({
    cell,
    date
  }) {
    const me = this, {
      activeCls,
      selectedCls,
      externalCellRenderer
    } = me, isSelected = me.isSelectedDate(date), cellClassList = {
      [activeCls]: activeCls && me.isActiveDate(date),
      [selectedCls]: isSelected,
      [me.outOfRangeCls]: me.minDate && date < me.minDate || me.maxDate && date > me.maxDate
    };
    if (isSelected) {
      if (me.multiSelect) {
        const isStart = !me.isSelectedDate(DateHelper.add(date, -1, "d")), isEnd = !me.isSelectedDate(DateHelper.add(date, 1, "d"));
        cellClassList["b-range-start"] = isStart;
        cellClassList["b-range-end"] = isEnd;
        cellClassList["b-in-range"] = !isStart && !isEnd;
      }
    }
    DomHelper.updateClassList(cell, cellClassList);
    cell.innerHTML = `<div class="b-datepicker-cell-inner">${date.getDate()}</div>`;
    cell.setAttribute("role", "gridcell");
    cell.setAttribute("aria-label", DateHelper.format(date, "MMMM D, YYYY"));
    if (me.isActiveDate(date)) {
      cell.id = `${me.id}-active-day`;
    } else {
      cell.removeAttribute("id");
    }
    if (externalCellRenderer) {
      arguments[0].cell = cell.firstChild;
      me.callback(externalCellRenderer, this, arguments);
    }
  }
  onCellMousedown(event) {
    const cell = event.target.closest("[data-date]");
    event.preventDefault();
    cell.focus();
    this.activeDate = DateHelper.parseKey(cell.dataset.date);
  }
  onCellClick(event) {
    const cell = event.target.closest("[data-date]");
    this.onUIDateSelect(DateHelper.parseKey(cell.dataset.date), event);
  }
  onMonthDateChange({
    newDate,
    changes
  }) {
    this.getConfig("tbar");
    super.onMonthDateChange(...arguments);
    if (changes.m || changes.y) {
      this.widgetMap.monthField.value = newDate.getMonth();
      this.widgetMap.yearButton.text = newDate.getFullYear();
    }
  }
  onUIDateSelect(date, event) {
    const me = this, {
      lastClickedDate,
      multiSelect
    } = me;
    me.lastClickedDate = date;
    if (!me.isDisabledDate(date)) {
      me.activatingEvent = event;
      if (multiSelect) {
        me.handleMultiSelect(lastClickedDate, date, event);
      } else {
        me.selection = date;
        if (me.floating) {
          me.hide();
        }
      }
      me.activatingEvent = null;
    }
  }
  handleMultiSelect(lastClickedDate, date, event) {
    const me = this, {
      multiSelect,
      _selection
    } = me, selection = _selection.dates, singleRange = multiSelect === "range", {
      size,
      generation
    } = _selection, rangeEnds = size && {
      [DateHelper.makeKey(DateHelper.add(selection[0], -1, "d"))]: 1,
      [DateHelper.makeKey(selection[0])]: 1,
      [DateHelper.makeKey(selection[selection.length - 1])]: 1,
      [DateHelper.makeKey(DateHelper.add(selection[selection.length - 1], 1, "d"))]: 1
    }, isSelected = _selection.has(date), toggleFn = isSelected ? "delete" : "add";
    const clickedRangeEnd = singleRange && (rangeEnds === null || rangeEnds === void 0 ? void 0 : rangeEnds[DateHelper.makeKey(date)]);
    if (event.ctrlKey) {
      if (multiSelect === true || !size || clickedRangeEnd) {
        _selection[toggleFn](date);
        if (singleRange && !_selection.has(me.rangeStartDate)) {
          me.rangeStartDate.setDate(me.rangeStartDate.getDate() + (date < selection[1] ? 1 : -1));
        }
      }
    } else if (event.shiftKey && size) {
      const [start, end] = [new Date(singleRange ? me.rangeStartDate || (me.rangeStartDate = selection[0]) : lastClickedDate), date].sort(dateSort);
      if (singleRange) {
        _selection.clear();
      }
      for (const d = start; d <= end; d.setDate(d.getDate() + 1)) {
        _selection.add(d);
      }
    } else if (!(_selection.has(date) && _selection.size === 1)) {
      _selection.clear();
      _selection.add(date);
    }
    const newSize = _selection.size;
    if (newSize === 1) {
      me.rangeStartDate = date;
    } else if (!newSize) {
      me.rangeStartDate = null;
    }
    if (_selection.generation !== generation) {
      me.updateSelection(_selection);
    }
  }
  changeSelection(selection) {
    const me = this;
    let result, rangeStartDate;
    if (selection) {
      if (!selection.forEach) {
        selection = [selection];
      }
      selection.forEach((d, i) => selection[i] = me.changeDate(d));
      rangeStartDate = selection[0];
      selection.sort(dateSort);
      if (me.multiSelect === "range" && selection.length === 2) {
        result = new DateSet();
        for (const d = new Date(selection[0]); d <= selection[1]; d.setDate(d.getDate() + 1)) {
          result.add(d);
        }
      } else {
        rangeStartDate = selection[0];
        result = new DateSet(selection);
      }
    } else {
      result = new DateSet();
    }
    if (rangeStartDate) {
      me.activeDate = me.rangeStartDate = DateHelper.clearTime(rangeStartDate);
    }
    return result;
  }
  updateSelection(dateSet) {
    const me = this, {
      dates
    } = dateSet, selection = me.multiSelect === "range" ? [dates[0], dates[dates.length - 1]] : dates;
    dates.length && (me.date = dates[0]);
    if (!me.isConfiguring) {
      me.refresh.now();
      me.trigger("selectionChange", {
        selection,
        userAction: Boolean(me.activatingEvent)
      });
    }
  }
  get selection() {
    const {
      _selection
    } = this, dates = _selection ? _selection.dates : emptyArray;
    return this.multiSelect === "range" && dates.length ? [dates[0], dates[dates.length - 1]] : dates;
  }
  onInternalKeyDown(keyEvent) {
    const me = this, keyName = keyEvent.key.trim() || keyEvent.code, activeDate = me.activeDate;
    let newDate = new Date(activeDate);
    if (keyName === "Escape" && me.floating) {
      return me.hide();
    }
    if (activeDate && me.weeksElement.contains(keyEvent.target)) {
      do {
        switch (keyName) {
          case "ArrowLeft":
            keyEvent.preventDefault();
            if (keyEvent.ctrlKey) {
              newDate = me.gotoPrevMonth();
            } else {
              newDate.setDate(newDate.getDate() - 1);
            }
            break;
          case "ArrowUp":
            keyEvent.preventDefault();
            newDate.setDate(newDate.getDate() - 7);
            break;
          case "ArrowRight":
            keyEvent.preventDefault();
            if (keyEvent.ctrlKey) {
              newDate = me.gotoNextMonth();
            } else {
              newDate.setDate(newDate.getDate() + 1);
            }
            break;
          case "ArrowDown":
            keyEvent.preventDefault();
            newDate.setDate(newDate.getDate() + 7);
            break;
          case "Enter":
            return me.onUIDateSelect(activeDate, keyEvent);
        }
      } while (me.isDisabledDate(newDate) && !me.focusDisabledDates);
      if (me.minDate && newDate < me.minDate) {
        return;
      }
      if (me.maxDate && newDate > me.maxDate) {
        return;
      }
      me.activeDate = newDate;
    }
  }
  changeMinDate(minDate) {
    return minDate && CalendarPanel.prototype.changeDate.apply(this, arguments);
  }
  updateMinDate(minDate) {
    this._yearpicker && (this._yearpicker.minYear = minDate === null || minDate === void 0 ? void 0 : minDate.getFullYear());
    this.refresh();
  }
  changeMaxDate(minDate) {
    return minDate && CalendarPanel.prototype.changeDate.apply(this, arguments);
  }
  updateMaxDate(maxDate) {
    this._yearpicker && (this._yearpicker.maxYear = maxDate === null || maxDate === void 0 ? void 0 : maxDate.getFullYear());
    this.refresh();
  }
  changeDate(date) {
    return DateHelper.clamp(super.changeDate(date), this.minDate, this.maxDate);
  }
  updateDate(date) {
    const me = this;
    me.isConfiguring && !me.initializingActiveDate && (me.selection = date);
    if (!me.month.date || date.getMonth() === me.month.month || !me.getCell(date) || me.alwaysRefreshOnMonthChange || me.isNavigating) {
      super.updateDate(date);
    }
  }
  changeActiveDate(activeDate, oldActiveDate) {
    if (this.trigger("beforeActiveDateChange", {
      activeDate,
      oldActiveDate
    }) === false) {
      return;
    }
    activeDate = activeDate ? this.changeDate(activeDate) : this.date || (this.date = DateHelper.clearTime(new Date()));
    if (isNaN(activeDate)) {
      throw new Error("DatePicker date ingestion must be passed a Date, or a YYYY-MM-DD date string");
    }
    return DateHelper.clamp(activeDate, this.minDate, this.maxDate);
  }
  updateActiveDate(activeDate, wasActiveDate) {
    const me = this, {
      isConfiguring
    } = me;
    if (isConfiguring || !me.getCell(activeDate)) {
      me.initializingActiveDate = isConfiguring;
      me.date = activeDate;
      me.initializingActiveDate = false;
    }
    if (!isConfiguring && !me.refresh.isPending) {
      me.syncActiveDate(activeDate, wasActiveDate);
    }
  }
  syncActiveDate(activeDate, wasActiveDate) {
    const me = this, {
      activeCls
    } = me, activeCell = me.getCell(activeDate), wasActiveCell = wasActiveDate && me.getCell(wasActiveDate), activeElement = DomHelper.getActiveElement(me.element);
    activeCell.setAttribute("tabIndex", 0);
    activeCls && activeCell.classList.add(activeCls);
    activeCell.id = `${me.id}-active-day`;
    if (me.weeksElement.contains(activeElement)) {
      activeCell.focus();
    }
    if (wasActiveCell && wasActiveCell !== activeCell) {
      wasActiveCell.removeAttribute("tabIndex");
      activeCls && wasActiveCell.classList.remove(activeCls);
      wasActiveCell.removeAttribute("id");
    }
  }
  set value(value) {
    const me = this;
    if (value) {
      value = me.changeDate(value, me.value);
      if (value !== void 0) {
        me.selection = value;
      }
    } else {
      me.date = new Date();
      me.selection = null;
    }
  }
  get value() {
    return this.selection[this.selection.length - 1];
  }
  gotoPrevYear() {
    return this.goto(-1, "year");
  }
  gotoPrevMonth() {
    return this.goto(-1, "month");
  }
  gotoNextMonth() {
    return this.goto(1, "month");
  }
  gotoNextYear() {
    return this.goto(1, "year");
  }
  goto(direction, unit) {
    const me = this, {
      activeDate
    } = me, activeCell = activeDate && me.getCell(activeDate);
    let newDate;
    if (unit === "month" && activeCell && (activeDate === null || activeDate === void 0 ? void 0 : activeDate.getMonth()) === me.month.month + direction) {
      newDate = activeDate;
    } else {
      newDate = DateHelper.add(activeCell ? activeDate : me.date, direction, unit);
    }
    const firstDateOfNewMonth = new Date(newDate);
    firstDateOfNewMonth.setDate(1);
    const lastDateOfNewMonth = DateHelper.add(DateHelper.add(firstDateOfNewMonth, 1, "month"), -1, "day");
    if (me.minDate && direction < 0 && lastDateOfNewMonth < me.minDate || me.maxDate && direction > 0 && firstDateOfNewMonth > me.maxDate) {
      return;
    }
    me.isNavigating = true;
    const result = me.date = newDate;
    if (activeCell) {
      me.activeDate = newDate;
    }
    me.isNavigating = false;
    return result;
  }
  isActiveDate(date) {
    return !(date - this.activeDate);
  }
  isSelectedDate(date) {
    var _this$_selection;
    return (_this$_selection = this._selection) === null || _this$_selection === void 0 ? void 0 : _this$_selection.has(date);
  }
  onMonthPicked({
    record,
    userAction
  }) {
    if (userAction) {
      var _this$focusElement;
      this.activeDate = DateHelper.add(this.activeDate, record.value - this.activeDate.getMonth(), "month");
      (_this$focusElement = this.focusElement) === null || _this$focusElement === void 0 ? void 0 : _this$focusElement.focus();
    }
  }
  onYearPickerRequested() {
    const {
      yearPicker
    } = this;
    if (yearPicker.isVisible) {
      yearPicker.hide();
    } else {
      yearPicker.year = yearPicker.startYear = this.activeDate.getFullYear();
      yearPicker.show();
      yearPicker.focus();
    }
  }
  onYearPickerTitleClick() {
    this.yearPicker.hide();
  }
  onYearPicked({
    value,
    source
  }) {
    const newDate = new Date(this.activeDate);
    newDate.setFullYear(value);
    this.activeDate = newDate;
    this.focusElement && DomHelper.focusWithoutScrolling(this.focusElement);
    source.hide();
  }
  changeYearPicker(yearPicker, oldYearPicker) {
    var _this$minDate, _this$maxDate;
    return YearPicker.reconfigure(oldYearPicker, yearPicker ? YearPicker.mergeConfigs({
      owner: this,
      appendTo: this.element,
      minYear: (_this$minDate = this.minDate) === null || _this$minDate === void 0 ? void 0 : _this$minDate.getFullYear(),
      maxYear: (_this$maxDate = this.maxDate) === null || _this$maxDate === void 0 ? void 0 : _this$maxDate.getFullYear()
    }, yearPicker) : null, this);
  }
  get childItems() {
    const {
      _yearPicker
    } = this, result = super.childItems;
    if (_yearPicker) {
      result.push(_yearPicker);
    }
    return result;
  }
  updateLocalization() {
    const {
      monthField
    } = this.widgetMap, newData = generateMonthNames();
    if (!this.isConfiguring && !newData.every((d, i) => d[1] === monthField.store.getAt(i).text)) {
      newData[monthField.value].selected = true;
      monthField.items = newData;
    }
    super.updateLocalization();
  }
};
var DateSet = class extends Set {
  add(d) {
    d = DateHelper.makeKey(d);
    if (!this.has(d)) {
      this.generation = (this.generation || 0) + 1;
    }
    return super.add(d);
  }
  delete(d) {
    d = DateHelper.makeKey(d);
    if (this.has(d)) {
      this.generation++;
    }
    return super.delete(d);
  }
  has(d) {
    return super.has(DateHelper.makeKey(d));
  }
  clear() {
    if (this.size) {
      this.generation++;
    }
    return super.clear();
  }
  equals(other) {
    Array.isArray(other) && (other = new DateSet(other));
    return other.size === this.size && [...this].every((s) => other.has(s));
  }
  get dates() {
    return [...this].sort().map((k) => DateHelper.parseKey(k));
  }
};
DatePicker.initClass();
DatePicker._$name = "DatePicker";
var DateField = class extends PickerField {
  static get $name() {
    return "DateField";
  }
  static get type() {
    return "datefield";
  }
  static get alias() {
    return "date";
  }
  static get configurable() {
    return {
      format: "L",
      strictParsing: false,
      fallbackFormat: "YYYY-MM-DD",
      timeFormat: "HH:mm:ss:SSS",
      keepTime: false,
      pickerFormat: null,
      validateDateOnly: null,
      triggers: {
        expand: {
          cls: "b-icon-calendar",
          handler: "onTriggerClick",
          weight: 200
        },
        back: {
          cls: "b-icon b-icon-angle-left b-step-trigger",
          key: "Shift+ArrowDown",
          handler: "onBackClick",
          align: "start",
          weight: 100
        },
        forward: {
          cls: "b-icon b-icon-angle-right b-step-trigger",
          key: "Shift+ArrowUp",
          handler: "onForwardClick",
          align: "end",
          weight: 100
        }
      },
      calendarContainerCls: "",
      min: null,
      max: null,
      step: false,
      stepTriggers: null,
      weekStartDay: null,
      picker: {
        type: "datepicker",
        role: "dialog",
        floating: true,
        scrollAction: "realign",
        align: {
          align: "t0-b0",
          axisLock: true
        }
      },
      value: null
    };
  }
  changePicker(picker, oldPicker) {
    const me = this, defaults = {
      owner: me,
      forElement: me[me.pickerAlignElement],
      minDate: me.min,
      maxDate: me.max,
      weekStartDay: me._weekStartDay,
      align: {
        anchor: me.overlayAnchor,
        target: me[me.pickerAlignElement]
      },
      onSelectionChange: ({
        selection,
        source: picker2
      }) => {
        if (picker2.isVisible) {
          me._isUserAction = me._isPickerInput = true;
          me.value = selection[0];
          me._isPickerInput = me._isUserAction = false;
          picker2.hide();
        }
      }
    };
    if (me.calendarContainerCls) {
      defaults.cls = me.calendarContainerCls;
    }
    if (me.value) {
      defaults.value = me.value;
    } else {
      defaults.activeDate = new Date();
    }
    const result = DatePicker.reconfigure(oldPicker, picker, {
      owner: me,
      defaults
    });
    result === null || result === void 0 ? void 0 : result.refresh.flush();
    return result;
  }
  get backShiftDate() {
    return DateHelper.add(this.value, -1 * this._step.magnitude, this._step.unit);
  }
  onBackClick() {
    const me = this, {
      min: min2
    } = me;
    if (!me.readOnly && me.value) {
      const newValue = me.backShiftDate;
      if (!min2 || min2.getTime() <= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  get forwardShiftDate() {
    return DateHelper.add(this.value, this._step.magnitude, this._step.unit);
  }
  onForwardClick() {
    const me = this, {
      max
    } = me;
    if (!me.readOnly && me.value) {
      const newValue = me.forwardShiftDate;
      if (!max || max.getTime() >= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  showPicker(focusPicker) {
    if (this.readOnly) {
      return;
    }
    const me = this, {
      _picker
    } = me;
    if (_picker) {
      const pickerConfig = {
        minDate: me.min,
        maxDate: me.max
      };
      if (me.value) {
        pickerConfig.value = me.value;
      } else {
        pickerConfig.activeDate = new Date();
      }
      _picker.setConfig(pickerConfig);
    }
    super.showPicker(focusPicker);
  }
  focusPicker() {
    this.picker.focus();
  }
  get isValid() {
    const me = this;
    me.clearError("L{Field.minimumValueViolation}", true);
    me.clearError("L{Field.maximumValueViolation}", true);
    let value = me.value;
    if (value) {
      const {
        min: min2,
        max,
        validateDateOnly
      } = me;
      if (validateDateOnly) {
        value = DateHelper.clearTime(value, false);
      }
      if (min2 && value < min2) {
        me.setError("L{Field.minimumValueViolation}", true);
        return false;
      }
      if (max && value > max) {
        me.setError("L{Field.maximumValueViolation}", true);
        return false;
      }
    }
    return super.isValid;
  }
  transformDateValue(value) {
    const me = this;
    if (value != null) {
      if (!DateHelper.isDate(value)) {
        if (typeof value === "string") {
          value = DateHelper.parse(value, me.format, me.strictParsing) || DateHelper.parse(value, me.fallbackFormat, me.strictParsing);
        } else {
          value = new Date(value);
        }
      }
      if (DateHelper.isValidDate(value)) {
        if ((!me.min || value - me.min > -DateHelper.MS_PER_DAY) && (!me.max || value <= me.max)) {
          return me.transformTimeValue(value);
        }
        return value;
      }
    }
    return null;
  }
  transformTimeValue(value) {
    const me = this, {
      keepTime
    } = me;
    value = DateHelper.clone(value);
    if (!keepTime) {
      DateHelper.clearTime(value, false);
    } else if (keepTime !== "entered") {
      const timeValue = DateHelper.parse(keepTime, me.timeFormat);
      if (DateHelper.isValidDate(timeValue)) {
        DateHelper.copyTimeValues(value, timeValue);
      } else if (DateHelper.isValidDate(me.value)) {
        DateHelper.copyTimeValues(value, me.value);
      }
    } else if (me._isPickerInput && DateHelper.isValidDate(me.value)) {
      DateHelper.copyTimeValues(value, me.value);
    }
    return value;
  }
  changeMin(value) {
    return this.transformDateValue(value);
  }
  updateMin(min2) {
    const {
      input,
      _picker
    } = this;
    if (input) {
      if (min2 == null) {
        input.removeAttribute("min");
      } else {
        input.min = min2;
      }
    }
    if (_picker) {
      _picker.minDate = min2;
    }
    this.syncInvalid();
  }
  changeMax(value) {
    return this.transformDateValue(value);
  }
  updateMax(max) {
    const {
      input,
      _picker
    } = this;
    if (input) {
      if (max == null) {
        input.removeAttribute("max");
      } else {
        input.max = max;
      }
    }
    if (_picker) {
      _picker.maxDate = max;
    }
    this.syncInvalid();
  }
  get weekStartDay() {
    return typeof this._weekStartDay === "number" ? this._weekStartDay : DateHelper.weekStartDay;
  }
  updateWeekStartDay(weekStartDay) {
    if (this._picker) {
      this._picker.weekStartDay = weekStartDay;
    }
  }
  changeValue(value, oldValue) {
    const me = this, newValue = me.transformDateValue(value);
    if (value && !newValue) {
      me.setError("L{invalidDate}");
      return;
    }
    me.clearError("L{invalidDate}");
    if (me.hasChanged(oldValue, newValue)) {
      return super.changeValue(newValue, oldValue);
    }
    if (!me.inputting) {
      me.syncInputFieldValue();
    }
  }
  updateValue(value, oldValue) {
    const picker = this._picker;
    if (picker && !this.inputting) {
      picker.value = value;
    }
    super.updateValue(value, oldValue);
  }
  changeStep(value, was) {
    const type = typeof value;
    if (!value) {
      return null;
    }
    if (type === "number") {
      value = {
        magnitude: Math.abs(value),
        unit: was ? was.unit : "day"
      };
    } else if (type === "string") {
      value = DateHelper.parseDuration(value);
    }
    if (value && value.unit && value.magnitude) {
      if (value.magnitude < 0) {
        value = {
          magnitude: -value.magnitude,
          unit: value.unit
        };
      }
      return value;
    }
  }
  updateStep(value) {
    this.element.classList[value ? "remove" : "add"]("b-no-steppers");
    this.syncInvalid();
  }
  hasChanged(oldValue, newValue) {
    if (oldValue !== null && oldValue !== void 0 && oldValue.getTime && newValue !== null && newValue !== void 0 && newValue.getTime && this.keepTime !== "entered") {
      return !DateHelper.isEqual(DateHelper.clearTime(oldValue), DateHelper.clearTime(newValue));
    }
    return super.hasChanged(oldValue && oldValue.getTime(), newValue && newValue.getTime());
  }
  get inputValue() {
    const date = this.value;
    return date ? DateHelper.format(date, this.format) : "";
  }
  updateFormat() {
    if (!this.isConfiguring) {
      this.syncInputFieldValue(true);
    }
  }
  updateLocalization() {
    super.updateLocalization();
    this.syncInputFieldValue(true);
  }
  internalOnKeyEvent(event) {
    super.internalOnKeyEvent(event);
    if (event.key === "Enter" && this.isValid) {
      this.picker.hide();
    }
  }
};
DateField.initClass();
DateField._$name = "DateField";
var NumberField = class extends Field {
  static get $name() {
    return "NumberField";
  }
  static get type() {
    return "numberfield";
  }
  static get alias() {
    return "number";
  }
  static get configurable() {
    return {
      min: null,
      max: null,
      step: 1,
      largeStep: 0,
      value: null,
      format: "",
      decimalPrecision: null,
      leadingZeroes: null,
      triggers: {
        spin: {
          type: "spintrigger"
        }
      },
      changeOnSpin: true,
      inputType: null
    };
  }
  construct(config) {
    super.construct(config);
    const me = this;
    me.input.addEventListener("dblclick", () => {
      me.select();
    });
    if (typeof me.changeOnSpin === "number") {
      me.bufferedSpinChange = me.buffer(me.triggerChange, me.changeOnSpin);
    }
  }
  acceptValue(value, rawValue) {
    let accept = !isNaN(value);
    if (accept && !this.hasTextSelection) {
      accept = false;
      const raw = this.input.value, current = parseFloat(raw);
      if (raw !== rawValue) {
        accept = !this.acceptValue(current, raw);
      }
    }
    return accept;
  }
  okMax(value) {
    return isNaN(this.max) || value <= this.max;
  }
  okMin(value) {
    return isNaN(this.min) || value >= this.min;
  }
  internalOnKeyEvent(e) {
    if (e.type === "keydown") {
      const me = this, key = e.key;
      let block;
      if (key === "ArrowUp") {
        me.doSpinUp(e.shiftKey);
        block = true;
      } else if (key === "ArrowDown") {
        me.doSpinDown(e.shiftKey);
        block = true;
      } else if (!e.altKey && !e.ctrlKey && key && key.length === 1) {
        const after = me.getAfterValue(key), afterValue = me.formatter.parseStrict(after), accepted = afterValue === me.value || after === "-" && (isNaN(me.min) || me.min < 0);
        block = !accepted && !me.acceptValue(afterValue, after);
      }
      if (key === "Enter" && me._changedBySilentSpin) {
        me.triggerChange(e, true);
        me._changedBySilentSpin = false;
      }
      if (block) {
        e.preventDefault();
      }
    }
    super.internalOnKeyEvent(e);
  }
  doSpinUp(largeStep = false) {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.value || 0) + (largeStep ? me.largeStep : me.step);
    if (!me.okMin(newValue)) {
      newValue = me.min;
    }
    if (me.okMax(newValue)) {
      me.applySpinChange(newValue);
    }
  }
  doSpinDown(largeStep = false) {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.value || 0) - (largeStep ? me.largeStep : me.step);
    if (!me.okMax(newValue)) {
      newValue = me.max;
    }
    if (me.okMin(newValue)) {
      me.applySpinChange(newValue);
    }
  }
  applySpinChange(newValue) {
    const me = this;
    me._isUserAction = true;
    if (me.changeOnSpin !== true) {
      me._changedBySilentSpin = true;
      me.silenceChange = true;
      me.bufferedSpinChange && me.bufferedSpinChange(null, true);
    }
    me.value = newValue;
    me._isUserAction = false;
    me.silenceChange = false;
  }
  triggerChange() {
    if (!this.silenceChange) {
      super.triggerChange(...arguments);
    }
  }
  onFocusOut(e) {
    var _me$triggers, _me$triggers$spin, _me$triggers$spin$cli;
    super.onFocusOut(...arguments);
    const me = this, {
      input
    } = me, raw = input.value, value = me.formatter.truncate(raw), formatted = isNaN(value) ? raw : me.formatValue(value);
    (_me$triggers = me.triggers) === null || _me$triggers === void 0 ? void 0 : (_me$triggers$spin = _me$triggers.spin) === null || _me$triggers$spin === void 0 ? void 0 : (_me$triggers$spin$cli = _me$triggers$spin.clickRepeater) === null || _me$triggers$spin$cli === void 0 ? void 0 : _me$triggers$spin$cli.cancel();
    if (raw !== formatted) {
      input.value = formatted;
    }
    if (me._changedBySilentSpin) {
      me.triggerChange(e, true);
      me._changedBySilentSpin = false;
    }
  }
  internalOnInput(event) {
    const me = this, {
      formatter,
      input
    } = me, {
      parser
    } = formatter, raw = input.value, decimals = parser.decimalPlaces(raw);
    if (formatter.truncator && decimals) {
      let value = raw;
      const trunc = formatter.truncate(raw);
      if (!isNaN(trunc)) {
        value = me.formatValue(trunc);
        if (parser.decimalPlaces(value) < decimals) {
          const pos = raw.length - me.caretPos;
          input.value = value;
          me.caretPos = value.length - pos;
        }
      }
    }
    super.internalOnInput(event);
  }
  formatValue(value) {
    return this.formatter.format(value);
  }
  changeFormat(format) {
    const me = this;
    if (format === "") {
      const {
        leadingZeroes,
        decimalPrecision
      } = me;
      format = leadingZeroes ? `${leadingZeroes}>9` : null;
      if (decimalPrecision != null) {
        format = `${format || ""}9.${"#".repeat(decimalPrecision)}`;
      } else if (format) {
        format += ".*";
      }
    }
    return format;
  }
  get formatter() {
    const me = this, format = me.format;
    let formatter = me._formatter;
    if (!formatter || me._lastFormat !== format) {
      formatter = NumberFormat.get(me._lastFormat = format);
      me._formatter = formatter;
    }
    return formatter;
  }
  updateStep(step) {
    this.element.classList[step ? "remove" : "add"]("b-hide-spinner");
    this._step = step;
  }
  changeLargeStep(largeStep) {
    return largeStep || this.step * 10;
  }
  get validity() {
    const value = this.value, validity = {};
    if (value != null) {
      validity.rangeUnderflow = !this.okMin(value);
      validity.rangeOverflow = !this.okMax(value);
    }
    validity.valid = !validity.rangeUnderflow && !validity.rangeOverflow;
    return validity;
  }
  changeValue(value, was) {
    const me = this;
    if (value || value === 0) {
      let valueIsNaN;
      if (typeof value !== "number") {
        value = typeof value === "string" ? me.formatter.parse(value) : Number(value);
        valueIsNaN = isNaN(value);
        if (valueIsNaN) {
          value = "";
        }
      }
      if (!valueIsNaN && me.format) {
        value = me.formatter.round(value);
      }
    } else {
      value = void 0;
    }
    return super.changeValue(value, was);
  }
  get inputValue() {
    let value = this.value;
    if (value != null && this.format) {
      value = this.formatValue(value);
    }
    return value;
  }
};
NumberField.initClass();
NumberField._$name = "NumberField";
var TimePicker = class extends Container {
  static get $name() {
    return "TimePicker";
  }
  static get type() {
    return "timepicker";
  }
  construct(config) {
    super.construct(config);
    this.refresh();
  }
  updateSeconds(seconds) {
    this.widgetMap.second[seconds ? "show" : "hide"]();
  }
  onFieldChange() {
    if (!this.isConfiguring && !this.isRefreshing) {
      this.value = this.pickerToTime();
    }
  }
  onAmPmButtonClick({
    source
  }) {
    this._pm = source.ref === "pmButton";
    if (this._value) {
      this.value = this.pickerToTime();
    }
  }
  onInternalKeyDown(keyEvent) {
    var _super$onInternalKeyD;
    const me = this;
    switch (keyEvent.key) {
      case "Escape":
        me.triggerTimeChange(me._initialValue);
        me.hide();
        keyEvent.preventDefault();
        return;
      case "Enter":
        me.value = me.pickerToTime();
        me.hide();
        keyEvent.preventDefault();
        return;
    }
    (_super$onInternalKeyD = super.onInternalKeyDown) === null || _super$onInternalKeyD === void 0 ? void 0 : _super$onInternalKeyD.call(this, keyEvent);
  }
  pickerToTime() {
    const me = this, pm = me._pm, {
      hour: hour2,
      minute,
      second
    } = me.widgetMap;
    hour2.format = me._is24Hour ? "2>9" : null;
    let hours = hour2.value, newValue = new Date(me.value);
    if (!me._is24Hour) {
      if (pm && hours < 12)
        hours = hours + 12;
      if (!pm && hours === 12)
        hours = 0;
    }
    newValue.setHours(hours);
    newValue.setMinutes(minute.value);
    if (me.seconds) {
      newValue.setSeconds(second.value);
    }
    if (me._min) {
      newValue = DateHelper.max(me._min, newValue);
    }
    if (me._max) {
      newValue = DateHelper.min(me._max, newValue);
    }
    return newValue;
  }
  triggerTimeChange(time) {
    this.trigger("timeChange", {
      time
    });
  }
  updateInitialValue(initialValue) {
    this.value = initialValue;
  }
  changeValue(value) {
    var _value;
    if (value) {
      value = typeof value === "string" ? DateHelper.parse(value, this.format) : value;
    }
    if (!this.isVisible) {
      this._initialValue = value;
    }
    return (_value = value) !== null && _value !== void 0 ? _value : DateHelper.getTime(0);
  }
  updateValue(value) {
    if (this.isVisible) {
      this.triggerTimeChange(value);
    }
    this.refresh();
  }
  updateFormat(format) {
    this._is24Hour = DateHelper.is24HourFormat(format);
    this.refresh();
  }
  changeMin(min2) {
    return typeof min2 === "string" ? DateHelper.parse(min2, this.format) : min2;
  }
  changeMax(max) {
    return typeof max === "string" ? DateHelper.parse(max, this.format) : max;
  }
  refresh() {
    const me = this;
    if (!me.isConfiguring && me.value) {
      me.isRefreshing = true;
      const {
        hour: hour2,
        minute,
        second,
        amButton,
        pmButton
      } = me.widgetMap, time = me.value, is24 = me._is24Hour, hours = time.getHours(), pm = me._pm = hours >= 12;
      me.element.classList[is24 ? "add" : "remove"]("b-24h");
      hour2.min = is24 ? 0 : 1;
      hour2.max = is24 ? 23 : 12;
      hour2.value = is24 ? hours : hours % 12 || 12;
      minute.value = time.getMinutes();
      second.value = time.getSeconds();
      amButton.pressed = !pm;
      pmButton.pressed = pm;
      amButton.hidden = pmButton.hidden = is24;
      me.isRefreshing = false;
    }
  }
};
_defineProperty(TimePicker, "configurable", {
  floating: true,
  items: {
    hour: {
      label: "L{TimePicker.hour}",
      type: "number",
      min: 0,
      max: 23,
      highlightExternalChange: false,
      format: "2>9"
    },
    minute: {
      label: "L{TimePicker.minute}",
      type: "number",
      min: 0,
      max: 59,
      highlightExternalChange: false,
      format: "2>9"
    },
    second: {
      hidden: true,
      label: "L{TimePicker.second}",
      type: "number",
      min: 0,
      max: 59,
      highlightExternalChange: false,
      format: "2>9"
    },
    amButton: {
      type: "button",
      text: "AM",
      toggleGroup: "am-pm",
      cls: "b-blue",
      onClick: "up.onAmPmButtonClick"
    },
    pmButton: {
      type: "button",
      text: "PM",
      toggleGroup: "am-pm",
      cls: "b-blue",
      onClick: "up.onAmPmButtonClick"
    }
  },
  autoShow: false,
  trapFocus: true,
  seconds: null,
  value: {
    $config: {
      equal: "date"
    },
    value: null
  },
  format: null,
  max: null,
  min: null,
  initialValue: null
});
TimePicker.initClass();
TimePicker._$name = "TimePicker";
var TimeField = class extends PickerField {
  static get $name() {
    return "TimeField";
  }
  static get type() {
    return "timefield";
  }
  static get alias() {
    return "time";
  }
  static get configurable() {
    return {
      picker: {
        type: "timepicker",
        align: {
          align: "t0-b0",
          axisLock: true
        }
      },
      format: "LT",
      triggers: {
        expand: {
          align: "end",
          handler: "onTriggerClick",
          compose: () => ({
            children: [{
              class: {
                "b-icon-clock-live": 1
              }
            }]
          })
        },
        back: {
          align: "start",
          cls: "b-icon b-icon-angle-left b-step-trigger",
          key: "Shift+ArrowDown",
          handler: "onBackClick"
        },
        forward: {
          align: "end",
          cls: "b-icon b-icon-angle-right b-step-trigger",
          key: "Shift+ArrowUp",
          handler: "onForwardClick"
        }
      },
      min: null,
      max: null,
      step: "5m",
      stepTriggers: null,
      value: null,
      keepDate: false
    };
  }
  changePicker(picker, oldPicker) {
    const me = this;
    return TimePicker.reconfigure(oldPicker, picker, {
      owner: me,
      defaults: {
        value: me.value,
        forElement: me[me.pickerAlignElement],
        owner: me,
        align: {
          anchor: me.overlayAnchor,
          target: me[me.pickerAlignElement]
        },
        onTimeChange({
          time
        }) {
          me._isUserAction = true;
          me.value = time;
          me._isUserAction = false;
        }
      }
    });
  }
  onBackClick() {
    const me = this, {
      min: min2
    } = me;
    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, -1 * me.step.magnitude, me.step.unit);
      if (!min2 || min2.getTime() <= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  onForwardClick() {
    const me = this, {
      max
    } = me;
    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, me.step.magnitude, me.step.unit);
      if (!max || max.getTime() >= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  get isValid() {
    const me = this;
    me.clearError("L{Field.minimumValueViolation}", true);
    me.clearError("L{Field.maximumValueViolation}", true);
    let value = me.value;
    if (value) {
      value = value.getTime();
      if (me._min && me._min.getTime() > value) {
        me.setError("L{Field.minimumValueViolation}", true);
        return false;
      }
      if (me._max && me._max.getTime() < value) {
        me.setError("L{Field.maximumValueViolation}", true);
        return false;
      }
    }
    return super.isValid;
  }
  hasChanged(oldValue, newValue) {
    if (oldValue !== null && oldValue !== void 0 && oldValue.getTime && newValue !== null && newValue !== void 0 && newValue.getTime) {
      return oldValue.getHours() !== newValue.getHours() || oldValue.getMinutes() !== newValue.getMinutes() || oldValue.getSeconds() !== newValue.getSeconds() || oldValue.getMilliseconds() !== newValue.getMilliseconds();
    }
    return super.hasChanged(oldValue, newValue);
  }
  showPicker() {
    const me = this, {
      picker,
      value
    } = me;
    if (me.readOnly) {
      return;
    }
    picker.value = value;
    picker.format = me.format;
    picker.maxTime = me.max;
    picker.minTime = me.min;
    if (!value) {
      me.value = picker.value;
    }
    super.showPicker(true);
  }
  onPickerShow() {
    var _this$pickerKeyDownRe;
    super.onPickerShow();
    this.pickerKeyDownRemover = (_this$pickerKeyDownRe = this.pickerKeyDownRemover) === null || _this$pickerKeyDownRe === void 0 ? void 0 : _this$pickerKeyDownRe.call(this);
  }
  focusPicker() {
    this.picker.focus();
  }
  transformTimeValue(value) {
    if (value != null) {
      if (typeof value === "string") {
        value = DateHelper.parse(value, this.format);
        if (this.keepDate) {
          value = DateHelper.copyTimeValues(new Date(this.value), value);
        }
      } else {
        value = new Date(value);
      }
      if (DateHelper.isValidDate(value)) {
        if (!this.keepDate) {
          return DateHelper.getTime(value);
        } else {
          return value;
        }
      }
    }
    return null;
  }
  changeMin(value) {
    return this.transformTimeValue(value);
  }
  updateMin(value) {
    const {
      input
    } = this;
    if (input) {
      if (value == null) {
        input.removeAttribute("min");
      } else {
        input.min = value;
      }
    }
    this.syncInvalid();
  }
  changeMax(value) {
    return this.transformTimeValue(value);
  }
  updateMax(value) {
    const {
      input
    } = this;
    if (input) {
      if (value == null) {
        input.removeAttribute("max");
      } else {
        input.max = value;
      }
    }
    this.syncInvalid();
  }
  changeValue(value, was) {
    const me = this, newValue = me.transformTimeValue(value);
    if (value && !newValue || me.isRequired && value === "") {
      me.setError("L{invalidTime}");
      return;
    }
    me.clearError("L{invalidTime}");
    if (me.hasChanged(was, newValue)) {
      return super.changeValue(newValue, was);
    }
    if (!me.inputting) {
      me.syncInputFieldValue(true);
    }
  }
  updateValue(value, was) {
    const {
      expand
    } = this.triggers;
    if (expand && value) {
      expand.element.firstElementChild.style.animationDelay = -((value.getHours() * 60 + value.getMinutes()) / 10) + "s";
    }
    super.updateValue(value, was);
  }
  changeStep(value, was) {
    var _value, _value2;
    const type = typeof value;
    if (!value) {
      return null;
    }
    if (type === "number") {
      value = {
        magnitude: Math.abs(value),
        unit: was ? was.unit : "hour"
      };
    } else if (type === "string") {
      value = DateHelper.parseDuration(value);
    }
    if ((_value = value) !== null && _value !== void 0 && _value.unit && (_value2 = value) !== null && _value2 !== void 0 && _value2.magnitude) {
      if (value.magnitude < 0) {
        value = {
          magnitude: -value.magnitude,
          unit: value.unit
        };
      }
      return value;
    }
  }
  updateStep(value) {
    this.element.classList[value ? "remove" : "add"]("b-no-steppers");
    this.syncInvalid();
  }
  updateFormat() {
    this.syncInputFieldValue(true);
  }
  get inputValue() {
    return DateHelper.format(this.value, this.format);
  }
  updateLocalization() {
    super.updateLocalization();
    this.syncInputFieldValue(true);
  }
};
TimeField.initClass();
TimeField._$name = "TimeField";
var DateTimeField = class extends Field {
  doDestroy() {
    this.dateField.destroy();
    this.timeField.destroy();
    super.doDestroy();
  }
  get focusElement() {
    return this.dateField.input;
  }
  get innerElements() {
    return [this.dateField.element, this.timeField.element];
  }
  internalOnKeyEvent() {
  }
  updateRevertOnEscape(revertOnEscape) {
    this.timeField.revertOnEscape = revertOnEscape;
    this.dateField.revertOnEscape = revertOnEscape;
  }
  changeTimeField(config) {
    const me = this, result = TimeField.new({
      revertOnEscape: me.revertOnEscape,
      syncInvalid(...args) {
        const updatingInvalid = me.updatingInvalid;
        TimeField.prototype.syncInvalid.apply(this, args);
        me.timeField && !updatingInvalid && me.syncInvalid();
      }
    }, config);
    EventHelper.on({
      element: result.element,
      keydown: "onTimeFieldKeyDown",
      thisObj: me
    });
    if (me.readOnly) {
      result.readOnly = true;
    }
    return result;
  }
  updateTimeField(timeField) {
    const me = this;
    timeField.ion({
      change({
        userAction,
        value
      }) {
        if (userAction && !me.$settingValue) {
          const dateAndTime = me.dateField.value;
          me._isUserAction = true;
          me.value = dateAndTime ? DateHelper.copyTimeValues(dateAndTime, value) : null;
          me._isUserAction = false;
        }
      },
      thisObj: me
    });
  }
  changeDateField(config) {
    const me = this, type = (config === null || config === void 0 ? void 0 : config.type) || "datefield", cls = Widget.resolveType(config.type || "datefield"), result = Widget.create(ObjectHelper.assign({
      type,
      revertOnEscape: me.revertOnEscape,
      syncInvalid(...args) {
        const updatingInvalid = me.updatingInvalid;
        cls.prototype.syncInvalid.apply(this, args);
        me.dateField && !updatingInvalid && me.syncInvalid();
      }
    }, config));
    EventHelper.on({
      element: result.element,
      keydown: "onDateFieldKeyDown",
      thisObj: me
    });
    if (me.readOnly) {
      result.readOnly = true;
    }
    result.ion({
      keydown: ({
        event
      }) => {
        var _this$timeField;
        if (event.key === "Tab" && !event.shiftKey && (_this$timeField = this.timeField) !== null && _this$timeField !== void 0 && _this$timeField.isVisible) {
          event.stopPropagation();
          event.cancelBubble = true;
        }
      }
    });
    return result;
  }
  get childItems() {
    return [this.dateField, this.timeField];
  }
  updateDateField(dateField) {
    const me = this;
    dateField.ion({
      change({
        userAction,
        value
      }) {
        if (userAction && !me.$isInternalChange) {
          me._isUserAction = true;
          if (!me.timeField.value) {
            me.timeField.value = value;
          } else if (value) {
            DateHelper.copyTimeValues(value, me.timeField.value);
          }
          me.value = value;
          me._isUserAction = false;
        }
      },
      thisObj: me
    });
  }
  updateWeekStartDay(weekStartDay) {
    if (this.dateField) {
      this.dateField.weekStartDay = weekStartDay;
    }
  }
  changeWeekStartDay(value) {
    var _this$dateField$weekS, _this$dateField;
    return typeof value === "number" ? value : (_this$dateField$weekS = (_this$dateField = this.dateField) === null || _this$dateField === void 0 ? void 0 : _this$dateField.weekStartDay) !== null && _this$dateField$weekS !== void 0 ? _this$dateField$weekS : DateHelper.weekStartDay;
  }
  syncInputFieldValue(skipHighlight = this.isConfiguring) {
    super.syncInputFieldValue(true);
    const me = this, {
      dateField,
      timeField
    } = me, highlightDate = dateField.highlightExternalChange, highlightTime = timeField.highlightExternalChange;
    if (!skipHighlight && !me.highlightExternalChange) {
      skipHighlight = true;
    }
    me.$isInternalChange = true;
    dateField.highlightExternalChange = false;
    dateField.value = null;
    dateField.highlightExternalChange = highlightDate;
    if (skipHighlight) {
      timeField.highlightExternalChange = dateField.highlightExternalChange = false;
    }
    timeField.value = dateField.value = me.inputValue;
    dateField.highlightExternalChange = highlightDate;
    timeField.highlightExternalChange = highlightTime;
    me.$isInternalChange = false;
    me.syncInvalid();
  }
  onTimeFieldKeyDown(e) {
    const me = this;
    if (e.key === "Enter" || e.key === "Tab") {
      const dateAndTime = me.dateField.value;
      me._isUserAction = true;
      me.value = dateAndTime ? DateHelper.copyTimeValues(dateAndTime, me.timeField.value) : null;
      me._isUserAction = false;
    }
  }
  onDateFieldKeyDown(e) {
    const me = this;
    if (e.key === "Tab" && !e.shiftKey) {
      e.stopPropagation();
      e.preventDefault();
      me.timeField.focus();
    } else if (e.key === "Enter") {
      me.value = me.dateField.value;
    }
  }
  updateRequired(required, was) {
    this.timeField.required = this.dateField.required = required;
  }
  updateReadOnly(readOnly, was) {
    super.updateReadOnly(readOnly, was);
    if (!this.isConfiguring) {
      this.timeField.readOnly = this.dateField.readOnly = readOnly;
    }
  }
  onDisabled(value) {
    this.timeField.disabled = this.dateField.disabled = value;
  }
  focus() {
    this.dateField.focus();
  }
  hasChanged(oldValue, newValue) {
    return !DateHelper.isEqual(oldValue, newValue);
  }
  get isValid() {
    return this.timeField.isValid && this.dateField.isValid;
  }
  setError(error, silent) {
    [this.dateField, this.timeField].forEach((f) => f.setError(error, silent));
  }
  getErrors() {
    const errors = [...this.dateField.getErrors() || [], ...this.timeField.getErrors() || []];
    return errors.length ? errors : null;
  }
  clearError(error, silent) {
    [this.dateField, this.timeField].forEach((f) => f.clearError(error, silent));
  }
  updateInvalid() {
    this.updatingInvalid = true;
    [this.dateField, this.timeField].forEach((f) => f.updateInvalid());
    this.updatingInvalid = false;
  }
};
_defineProperty(DateTimeField, "configurable", {
  timeField: {},
  dateField: {
    keepTime: true,
    step: "1 d"
  },
  weekStartDay: null,
  inputTemplate: () => "",
  ariaElement: "element"
});
_defineProperty(DateTimeField, "$name", "DateTimeField");
_defineProperty(DateTimeField, "type", "datetimefield");
_defineProperty(DateTimeField, "alias", "datetime");
DateTimeField.initClass();
DateTimeField._$name = "DateTimeField";
var DurationField = class extends TextField {
  static get $name() {
    return "DurationField";
  }
  static get type() {
    return "durationfield";
  }
  static get alias() {
    return "duration";
  }
  static get defaultConfig() {
    return {
      value: null,
      step: 1,
      unit: null,
      defaultUnit: "day",
      magnitude: null,
      useAbbreviation: false,
      allowNegative: false,
      decimalPrecision: null,
      triggers: {
        spin: {
          type: "spintrigger"
        }
      },
      nullValue: null
    };
  }
  static get configurable() {
    return {
      min: null,
      max: null,
      allowedUnits: null
    };
  }
  changeMin(value) {
    return typeof value === "string" ? new Duration(value) : value;
  }
  changeMax(value) {
    return typeof value === "string" ? new Duration(value) : value;
  }
  changeAllowedUnits(units) {
    if (typeof units === "string") {
      units = units.split(",");
    }
    return units;
  }
  updateAllowedUnits(units) {
    this.allowedUnitsRe = new RegExp(`(${units.join("|")})`, "i");
  }
  get inputValue() {
    return this.value == null ? "" : this.calcValue(true).toString(this.useAbbreviation);
  }
  set unit(unit) {
    this._unit = unit;
    this.value = this.calcValue();
  }
  get unit() {
    return this._unit;
  }
  get unitWithDefault() {
    return this._unit || DurationField.defaultConfig.defaultUnit;
  }
  set magnitude(magnitude) {
    this.clearError("L{invalidUnit}");
    this._magnitude = magnitude;
    super.value = this.calcValue();
  }
  get magnitude() {
    return this._magnitude;
  }
  roundMagnitude(value) {
    return value && this.decimalPrecision != null ? ObjectHelper.round(value, this.decimalPrecision) : value;
  }
  get allowDecimals() {
    return this.decimalPrecision !== 0;
  }
  get isValid() {
    const me = this, isEmpty = me.value == null || me.value && me.value.magnitude == null;
    return super.isValid && (isEmpty && !me.required || !isEmpty && (me.allowNegative || me.value.magnitude >= 0));
  }
  internalOnChange(event) {
    const me = this, value = me.value, oldVal = me._lastValue;
    if (me.hasChanged(oldVal, value)) {
      me._lastValue = value;
      me.triggerFieldChange({
        value,
        event,
        userAction: true,
        valid: me.isValid
      });
    }
  }
  onFocusOut(e) {
    var _this$triggers, _this$triggers$spin, _this$triggers$spin$c;
    this.syncInputFieldValue(true);
    (_this$triggers = this.triggers) === null || _this$triggers === void 0 ? void 0 : (_this$triggers$spin = _this$triggers.spin) === null || _this$triggers$spin === void 0 ? void 0 : (_this$triggers$spin$c = _this$triggers$spin.clickRepeater) === null || _this$triggers$spin$c === void 0 ? void 0 : _this$triggers$spin$c.cancel();
    return super.onFocusOut(e);
  }
  set value(value) {
    const me = this;
    let newMagnitude, newUnit;
    this.clearError("L{invalidUnit}");
    if (typeof value === "number") {
      newMagnitude = value;
      newUnit = me._unit;
    } else if (typeof value === "string") {
      if (/^\s*$/.test(value)) {
        newMagnitude = null;
      } else {
        const parsedDuration = DateHelper.parseDuration(value, me.allowDecimals, me.unitWithDefault);
        if (parsedDuration) {
          if (!me.allowedUnitsRe || me.allowedUnitsRe.test(parsedDuration.unit)) {
            newUnit = parsedDuration.unit;
            newMagnitude = parsedDuration.magnitude;
          } else {
            me.setError("L{invalidUnit}");
          }
        }
      }
    } else {
      if (value && "unit" in value && "magnitude" in value) {
        newUnit = value.unit;
        newMagnitude = value.magnitude;
      } else {
        newUnit = null;
        newMagnitude = null;
      }
    }
    if (me._magnitude !== newMagnitude || me._unit != newUnit) {
      me._magnitude = newMagnitude;
      if (newUnit) {
        me._unit = newUnit;
      }
      super.value = me.calcValue();
    }
  }
  okMax(value) {
    if (typeof value === "number") {
      value = new Duration({
        unit: this.unitWithDefault,
        magnitude: value
      });
    }
    return this.max == null || value <= this.max;
  }
  okMin(value) {
    if (typeof value === "number") {
      value = new Duration({
        unit: this.unitWithDefault,
        magnitude: value
      });
    }
    return this.min == null || value >= this.min;
  }
  get validity() {
    const value = this.value, validity = {};
    if (value != null) {
      validity.rangeUnderflow = !this.okMin(value);
      validity.rangeOverflow = !this.okMax(value);
    }
    validity.valid = !validity.rangeUnderflow && !validity.rangeOverflow;
    return validity;
  }
  get value() {
    return super.value;
  }
  calcValue(round2 = false) {
    const me = this;
    if ((!me._unit || me._magnitude == null) && me.clearable) {
      return null;
    } else {
      return new Duration(round2 ? this.roundMagnitude(me._magnitude) : this._magnitude, me.unitWithDefault);
    }
  }
  hasChanged(oldValue, newValue) {
    return newValue && !oldValue || !newValue && oldValue || newValue && oldValue && !oldValue.isEqual(newValue);
  }
  get milliseconds() {
    return this.value ? this.value.milliseconds : 0;
  }
  onInternalKeyDown(keyEvent) {
    if (keyEvent.key === "ArrowUp") {
      this.doSpinUp();
    } else if (keyEvent.key === "ArrowDown") {
      this.doSpinDown();
    }
  }
  doSpinUp() {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.magnitude || 0) + me.step;
    me._isUserAction = true;
    if (!me.okMin(newValue)) {
      newValue = me.min;
    }
    if (me.okMax(newValue)) {
      me.value = newValue;
    }
    me._isUserAction = false;
  }
  doSpinDown() {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.magnitude || 0) - me.step;
    if (!me.okMax(newValue)) {
      newValue = me.max;
    }
    if (me.okMin(newValue) && (me.allowNegative || (me.magnitude || 0) > 0)) {
      me._isUserAction = true;
      me.value = newValue;
      me._isUserAction = false;
    }
  }
};
DurationField.initClass();
DurationField._$name = "DurationField";
var Fit = class extends Layout {
};
_defineProperty(Fit, "$name", "Fit");
_defineProperty(Fit, "type", "fit");
_defineProperty(Fit, "configurable", {
  containerCls: "b-fit-container",
  itemCls: "b-fit-item"
});
Fit.initClass();
Fit._$name = "Fit";
var Editor = class extends Container {
  afterConfigure() {
    const me = this;
    super.afterConfigure();
    me.onTargetSizeChange = me.onTargetSizeChange.bind(me);
    EventHelper.on({
      element: me.element,
      keydown: "onKeyDown",
      contextmenu: "stopMouseEvents",
      mousedown: "stopMouseEvents",
      mouseover: "stopMouseEvents",
      mouseout: "stopMouseEvents",
      mouseup: "stopMouseEvents",
      click: "stopMouseEvents",
      dblclick: "stopMouseEvents",
      thisObj: me
    });
    me.ion({
      beforeHide: "beforeEditorHide",
      hide: "afterEditorHide",
      thisObj: me
    });
    LocaleManagerSingleton.ion({
      locale: "onLocaleChange",
      thisObj: me
    });
  }
  onLocaleChange() {
    const {
      inputField
    } = this;
    if (inputField && !inputField.isDestroyed) {
      if (inputField.syncInputFieldValue) {
        inputField.syncInputFieldValue(true);
      }
    }
  }
  render(renderTo) {
    const oldParent = this.element.parentNode, [parentElement] = this.getRenderContext(this, renderTo);
    parentElement.classList.add("b-editing");
    super.render(...arguments);
    if (oldParent !== null && oldParent !== void 0 && oldParent.classList && parentElement !== oldParent) {
      oldParent.classList.remove("b-editing");
    }
  }
  async startEdit(editObject) {
    const me = this;
    editObject = ObjectHelper.assignIf(editObject, {
      align: me.align,
      hideTarget: me.hideTarget,
      matchSize: me.matchSize,
      matchFont: me.matchFont,
      fitTargetContent: me.fitTargetContent,
      focus: true
    });
    if (me.trigger("beforeStart", editObject) !== false) {
      var _inputField$clearErro, _inputField$focus, _inputField$value$;
      const {
        target,
        hideTarget,
        matchSize,
        matchFont,
        fitTargetContent,
        record,
        field = me.inputField.name,
        focus
      } = editObject, {
        inputField
      } = me, {
        input
      } = inputField, targetFontSize = DomHelper.getStyleValue(target, "font-size"), targetFontFamily = DomHelper.getStyleValue(target, "font-family");
      let {
        value,
        align
      } = editObject;
      if (record && field) {
        me.record = record;
        me.dataField = field;
        if (value === void 0) {
          value = record[field];
        }
      }
      if (matchSize) {
        if (target instanceof HTMLElement) {
          me.updateSize(target, matchSize);
        }
        if (target instanceof HTMLElement) {
          ResizeMonitor.addResizeListener(target, me.onTargetSizeChange);
        }
      }
      if (input) {
        if (matchFont) {
          input.style.fontSize = targetFontSize;
          input.style.fontFamily = targetFontFamily;
        } else {
          input.style.fontSize = input.style.fontFamily = "";
        }
      }
      me.assigningValues = true;
      (_inputField$clearErro = inputField.clearError) === null || _inputField$clearErro === void 0 ? void 0 : _inputField$clearErro.call(inputField);
      inputField.value = value;
      me.assigningValues = false;
      if (typeof align === "string") {
        align = {
          align
        };
      }
      await me.showBy(_objectSpread2({
        target,
        allowTargetOut: true
      }, align));
      if (fitTargetContent) {
        const overflow = input.scrollWidth - input.clientWidth;
        if (overflow > 0) {
          me.width += overflow + DomHelper.scrollBarWidth;
        }
      }
      focus && ((_inputField$focus = inputField.focus) === null || _inputField$focus === void 0 ? void 0 : _inputField$focus.call(inputField));
      if (target.nodeType === Element.ELEMENT_NODE) {
        if (hideTarget) {
          target.classList.add("b-hide-visibility");
        }
      }
      me.editing = true;
      me.trigger("start", {
        value: inputField.value
      });
      if (Array.isArray(inputField.value) && inputField.editingRecords && (_inputField$value$ = inputField.value[0]) !== null && _inputField$value$ !== void 0 && _inputField$value$.isModel) {
        me.oldValue = inputField.value.map((record2) => record2.copy(record2.id));
      } else {
        me.oldValue = inputField.value;
        if (Array.isArray(me.oldValue)) {
          me.oldValue = me.oldValue.slice();
        }
      }
      inputField.initialValue = me.oldValue;
      return true;
    }
    return false;
  }
  refreshEdit() {
    if (this.isVisible) {
      const {
        record,
        dataField,
        inputField
      } = this;
      if (record && dataField) {
        const value = record[dataField];
        if (!ObjectHelper.isEqual(inputField.value, value)) {
          inputField.value = value;
        }
      }
    }
  }
  finishEdit() {
    const {
      target,
      aligningToElement
    } = this.lastAlignSpec;
    if (aligningToElement) {
      target.classList.remove("b-editing");
      target.classList.remove("b-hide-visibility");
    }
    this.editing = false;
    this.trigger("finishEdit");
  }
  onKeyDown(event) {
    var _me$trigger;
    const me = this;
    switch (event.key) {
      case me.completeKey:
        me.completeEdit(null, event);
        event.stopImmediatePropagation();
        break;
      case me.cancelKey:
        me.cancelEdit(event);
        event.stopImmediatePropagation();
        break;
    }
    (_me$trigger = me.trigger) === null || _me$trigger === void 0 ? void 0 : _me$trigger.call(me, "keydown", {
      event
    });
  }
  stopMouseEvents(e) {
    if (!this.allowMouseEvents) {
      e.stopPropagation();
    }
  }
  onFocusOut(event) {
    super.onFocusOut(event);
    const me = this;
    if (!me.isFinishing && me.editing) {
      switch (me.blurAction) {
        case "cancel":
          me.cancelEdit(event);
          break;
        case "complete":
          me.completeEdit(null, event);
      }
    }
  }
  async completeEdit(finalize, triggeredByEvent) {
    const me = this, {
      inputField,
      oldValue,
      record
    } = me, invalidAction = inputField.invalidAction || (inputField.allowInvalid === false ? "block" : me.invalidAction), {
      value
    } = inputField;
    if (!me.isVisible) {
      return;
    }
    if (!inputField.isValid && invalidAction !== "allow") {
      if (invalidAction === "block") {
        var _inputField$focus2;
        (_inputField$focus2 = inputField.focus) === null || _inputField$focus2 === void 0 ? void 0 : _inputField$focus2.call(inputField);
        return false;
      } else if (invalidAction === "revert") {
        me.cancelEdit(triggeredByEvent);
        return true;
      }
    } else if (ObjectHelper.isEqual(value, oldValue)) {
      me.cancelEdit(triggeredByEvent);
      return true;
    } else {
      const context = {
        inputField,
        record,
        value,
        oldValue
      };
      if (me.trigger("beforeComplete", context) === false) {
        var _inputField$focus3;
        (_inputField$focus3 = inputField.focus) === null || _inputField$focus3 === void 0 ? void 0 : _inputField$focus3.call(inputField);
      } else {
        if (!finalize) {
          var _context$editorContex;
          finalize = context.finalize || ((_context$editorContex = context.editorContext) === null || _context$editorContex === void 0 ? void 0 : _context$editorContex.finalize);
        }
        if (finalize) {
          let result = await finalize(context);
          if (result === true) {
            me.onEditComplete();
          } else {
            if (inputField.setError) {
              const error = result || inputField.invalidValueError, clearError = () => {
                listeners();
                inputField.clearError(error);
              }, listeners = inputField.ion({
                change: clearError,
                input: clearError
              });
              inputField.setError(error);
            }
            if (invalidAction === "block") {
              var _inputField$focus4;
              (_inputField$focus4 = inputField.focus) === null || _inputField$focus4 === void 0 ? void 0 : _inputField$focus4.call(inputField);
            } else if (invalidAction === "revert") {
              inputField.value = oldValue;
              result = true;
            }
            result = false;
          }
          return result;
        } else {
          me.onEditComplete();
          return true;
        }
      }
    }
    return false;
  }
  cancelEdit(triggeredByEvent) {
    const me = this, {
      inputField,
      oldValue
    } = me, {
      value
    } = inputField;
    if (me.editing && !me.isFinishing && me.trigger("beforeCancel", {
      value,
      oldValue,
      event: triggeredByEvent
    }) !== false) {
      me.isFinishing = true;
      me.hide();
      me.trigger("cancel", {
        value,
        oldValue,
        event: triggeredByEvent
      });
      me.finishEdit();
      me.isFinishing = false;
    }
  }
  onEditComplete() {
    const me = this, {
      record,
      dataField,
      inputField,
      oldValue
    } = me, {
      value
    } = inputField;
    if (!me.isFinishing) {
      me.isFinishing = true;
      me.hide();
      if (record) {
        const setterName = `set${StringHelper.capitalize(dataField)}`;
        if (record[setterName]) {
          record[setterName](value);
        } else if (dataField.includes(".")) {
          record.set(dataField, value);
        } else {
          record[dataField] = value;
        }
      }
      me.trigger("complete", {
        value,
        oldValue
      });
      me.finishEdit();
      me.isFinishing = false;
    }
  }
  doDestroy() {
    if (this.createdInputField) {
      this.inputField.destroy();
    }
    super.doDestroy();
  }
  set owner(owner) {
    this._owner = owner;
  }
  get owner() {
    return this._owner || Widget.fromElement(this.element.parentNode);
  }
  changeInputField(inputField, oldInputField) {
    const me = this;
    if (oldInputField) {
      oldInputField.destroy();
    }
    if (typeof inputField === "string") {
      inputField = {
        type: inputField
      };
    }
    if (!(inputField instanceof Widget)) {
      inputField = Widget.create(inputField);
      me.createdInputField = true;
    }
    if (me.completeOnChange) {
      inputField.ion({
        change: "onInputFieldChange",
        thisObj: me
      });
    }
    inputField.parent = me;
    return inputField;
  }
  updateInputField(inputField) {
    this.removeAll();
    this.add(inputField);
  }
  get inputField() {
    return this.items[0];
  }
  onInputFieldChange() {
    if (this.containsFocus) {
      this.completeEdit();
    }
  }
  onTargetSizeChange(resizedElement, oldRect, newRect) {
    if (oldRect && newRect) {
      this.updateSize(resizedElement);
    }
  }
  updateSize(targetEl, matchSize = this.lastMatchSize) {
    const me = this, rect = Rectangle.inner(targetEl);
    me.width = matchSize.width === false ? "auto" : rect.width - me.align.offset[0];
    me.height = matchSize.height === false ? "auto" : rect.height;
    me.lastMatchSize = matchSize;
  }
  beforeEditorHide() {
    if (this.editing && !this.isFinishing) {
      this.cancelEdit();
      return false;
    }
  }
  afterEditorHide() {
    if (this.positioned) {
      this.element.remove();
    }
    ResizeMonitor.removeResizeListener(this.lastAlignSpec.target, this.onTargetSizeChange);
  }
};
_defineProperty(Editor, "$name", "Editor");
_defineProperty(Editor, "type", "editor");
_defineProperty(Editor, "configurable", {
  positioned: true,
  hidden: true,
  layout: "fit",
  align: {
    align: "t0-t0",
    offset: [0, 0]
  },
  hideTarget: false,
  matchSize: true,
  matchFont: true,
  fitTargetContent: false,
  inputField: "textfield",
  blurAction: "complete",
  completeKey: "Enter",
  cancelKey: "Escape",
  invalidAction: "block",
  completeOnChange: null,
  isolateFields: true
});
Editor.initClass();
Editor._$name = "Editor";
var SUPPORTED_FIELD_DATA_TYPES = ["number", "boolean", "string", "date", "duration"];
var isSupportedDurationField = (field) => {
  var _field$column;
  return ((_field$column = field.column) === null || _field$column === void 0 ? void 0 : _field$column.type) === "duration";
};
var EMPTY_STRING = "";
var FieldFilterPicker = class extends Container {
  static get $name() {
    return "FieldFilterPicker";
  }
  static get type() {
    return "fieldfilterpicker";
  }
  static get defaultValueFieldPlaceholders() {
    return {
      string: "L{enterAValue}",
      number: "L{enterANumber}",
      date: "L{selectADate}",
      list: "L{selectOneOrMoreValues}",
      duration: "L{enterAValue}"
    };
  }
  afterConstruct() {
    const me = this;
    if (!me._fields) {
      throw new Error(`${FieldFilterPicker.name} requires 'fields' to be configured.`);
    }
    if (!me._filter) {
      throw new Error(`${FieldFilterPicker.name} requires 'filter' to be configured.`);
    }
    super.afterConstruct();
    const {
      widgetMap: {
        propertyPicker,
        operatorPicker,
        caseSensitive
      }
    } = me;
    propertyPicker.ion({
      select: "onPropertySelect",
      thisObj: me
    });
    operatorPicker.ion({
      select: "onOperatorSelect",
      thisObj: me
    });
    caseSensitive.ion({
      change: "onCaseSensitiveChange",
      thisObj: me
    });
    me.propertyFieldConfig && propertyPicker.setConfig(me.propertyFieldConfig);
    me.operatorFieldConfig && operatorPicker.setConfig(me.operatorFieldConfig);
    propertyPicker.cls = me.allPropertyPickerClasses;
    operatorPicker.cls = me.allOperatorPickerClasses;
    me.populateUIFromFilter();
  }
  changeDateFormat(dateFormat) {
    return this.L(dateFormat);
  }
  get allChildInputs() {
    const {
      propertyPicker,
      operatorPicker,
      caseSensitive
    } = this.widgetMap;
    return [propertyPicker, operatorPicker, ...this.valueFields, caseSensitive];
  }
  updateDisabled(newDisabled) {
    this.allChildInputs.forEach((field) => field.disabled = newDisabled);
  }
  updateReadOnly(newReadOnly) {
    const {
      propertyPicker,
      operatorPicker
    } = this.widgetMap;
    this.allChildInputs.forEach((field) => field.readOnly = newReadOnly);
    propertyPicker.readOnly = propertyPicker.readOnly || newReadOnly;
    operatorPicker.readOnly = operatorPicker.readOnly || newReadOnly;
  }
  updatePropertyLocked(newPropertyLocked) {
    this.widgetMap.propertyPicker.readOnly = newPropertyLocked || this.readOnly;
    this.widgetMap.propertyPicker.cls = this.allPropertyPickerClasses;
  }
  updateOperatorLocked(newOperatorLocked) {
    this.widgetMap.operatorPicker.readOnly = newOperatorLocked || this.readOnly;
    this.widgetMap.operatorPicker.cls = this.allOperatorPickerClasses;
  }
  changeOperators(newOperators) {
    const operators = newOperators !== null && newOperators !== void 0 ? newOperators : FieldFilterPicker.defaultOperators;
    return Object.keys(operators).reduce((outOperators, dataType) => _objectSpread2(_objectSpread2({}, outOperators), {}, {
      [dataType]: operators[dataType].map((op) => _objectSpread2(_objectSpread2({}, op), {}, {
        text: this.L(op.text)
      }))
    }), {});
  }
  changeFields(newFields) {
    let fields = newFields;
    if (Array.isArray(newFields)) {
      VersionHelper.deprecate("Core", "6.0.0", "FieldOption[] deprecated, use Object<String, FieldOption> keyed by field name instead");
      fields = ArrayHelper.keyBy(fields, "name");
    }
    return fields;
  }
  get isMultiSelectValueField() {
    var _this$_filter;
    return ["isIncludedIn", "isNotIncludedIn"].includes((_this$_filter = this._filter) === null || _this$_filter === void 0 ? void 0 : _this$_filter.operator);
  }
  get allPropertyPickerClasses() {
    var _this$propertyFieldCo;
    return new DomClassList(`b-${FieldFilterPicker.type}-property`, (_this$propertyFieldCo = this.propertyFieldConfig) === null || _this$propertyFieldCo === void 0 ? void 0 : _this$propertyFieldCo.cls, {
      [`b-${FieldFilterPicker.type}-combo-locked`]: this.propertyLocked
    });
  }
  get allOperatorPickerClasses() {
    var _this$operatorFieldCo;
    return new DomClassList(`b-${FieldFilterPicker.type}-operator`, (_this$operatorFieldCo = this.operatorFieldConfig) === null || _this$operatorFieldCo === void 0 ? void 0 : _this$operatorFieldCo.cls, {
      [`b-${FieldFilterPicker.type}-combo-locked`]: this.operatorLocked
    });
  }
  getValueFieldConfigs() {
    const me = this, {
      valueFieldCls,
      fieldType,
      _filter: {
        operator
      },
      onValueChange,
      filterValues,
      isMultiSelectValueField,
      operatorArgCount,
      getValueFieldConfig
    } = me, valueFieldPlaceholders = ObjectHelper.merge({}, FieldFilterPicker.defaultValueFieldPlaceholders, me.valueFieldPlaceholders);
    if (!fieldType || !operator || operatorArgCount === 0) {
      return [];
    }
    let valueFieldCfg = {
      type: "textfield",
      listeners: {
        change: onValueChange,
        input: onValueChange,
        thisObj: me
      },
      cls: valueFieldCls,
      dataset: {
        type: fieldType
      },
      placeholder: me.L(valueFieldPlaceholders[isMultiSelectValueField ? "list" : fieldType])
    };
    if (isMultiSelectValueField) {
      valueFieldCfg = _objectSpread2(_objectSpread2({}, valueFieldCfg), {}, {
        type: "combo",
        multiSelect: true,
        createOnUnmatched: true,
        items: this.getUniqueDataValues(filterValues),
        value: filterValues !== null && filterValues !== void 0 ? filterValues : []
      });
    } else if (["number", "date", "boolean"].includes(fieldType)) {
      valueFieldCfg.type = `${fieldType}field`;
    } else if (fieldType === "duration") {
      valueFieldCfg.type = "durationfield";
    }
    if (getValueFieldConfig) {
      valueFieldCfg = me.callback(getValueFieldConfig, me, [me.filter, valueFieldCfg]);
    }
    if (isMultiSelectValueField) {
      return [valueFieldCfg];
    }
    return ArrayHelper.populate(operatorArgCount, (index) => [{
      type: "widget",
      tag: "div",
      cls: `b-${FieldFilterPicker.type}-value-separator`,
      content: me.L("L{FieldFilterPicker.and}")
    }, _objectSpread2(_objectSpread2({}, valueFieldCfg), {}, {
      value: filterValues[index]
    })]).flat().slice(1);
  }
  getUniqueDataValues(extraValuesToInclude = []) {
    var _me$_filter;
    const me = this, {
      fieldType
    } = me;
    if (!me.store || !((_me$_filter = me._filter) !== null && _me$_filter !== void 0 && _me$_filter.property)) {
      return [];
    }
    const {
      relatedDisplayField
    } = me.selectedField;
    let values, sortedValues;
    if (me.fieldIsRelation) {
      const {
        foreignStore
      } = me.currentPropertyRelationConfig;
      if (relatedDisplayField) {
        values = foreignStore.allRecords.reduce((options, record) => {
          if (record.id != null) {
            options.push({
              text: record[relatedDisplayField],
              value: record.id
            });
          }
          return options;
        }, []);
        sortedValues = values.sort((a, b) => me.sortStrings(a.text, b.text));
      } else {
        values = foreignStore.allRecords.map((record) => record.id);
      }
    } else {
      values = me.store.allRecords.map((record) => record[me._filter.property]);
    }
    if (!sortedValues) {
      values.push(...extraValuesToInclude);
      const uniqueValues = ArrayHelper.unique(values.reduce((primitiveValues, value) => {
        if (value != null && String(value).trim() !== "") {
          if (fieldType === "date") {
            primitiveValues.push(value.valueOf());
          } else if (fieldType === "duration") {
            primitiveValues.push(value.toString());
          } else {
            primitiveValues.push(value);
          }
        }
        return primitiveValues;
      }, []));
      if (fieldType === "string") {
        sortedValues = uniqueValues.sort(me.sortStrings);
      } else if (fieldType === "duration") {
        sortedValues = uniqueValues.map((durationStr) => new Duration(durationStr)).filter((duration) => duration.isValid).sort(me.sortDurations);
      } else {
        sortedValues = uniqueValues.sort(me.sortNumerics);
      }
      if (fieldType === "date") {
        sortedValues = sortedValues.map((timestamp) => {
          const date = new Date(timestamp);
          return {
            text: DateHelper.format(date, me.dateFormat),
            value: timestamp
          };
        });
      } else if (fieldType === "duration") {
        sortedValues = sortedValues.map((duration) => duration.toString());
      }
    }
    return sortedValues;
  }
  sortStrings(a, b) {
    return (a !== null && a !== void 0 ? a : EMPTY_STRING).localeCompare(b !== null && b !== void 0 ? b : EMPTY_STRING);
  }
  sortNumerics(a, b) {
    return a - b;
  }
  sortDurations(a, b) {
    return a.valueOf() - b.valueOf();
  }
  get fieldType() {
    var _this$selectedField;
    return (_this$selectedField = this.selectedField) === null || _this$selectedField === void 0 ? void 0 : _this$selectedField.type;
  }
  get selectedField() {
    var _this$fields, _this$_filter2;
    return (_this$fields = this.fields) === null || _this$fields === void 0 ? void 0 : _this$fields[(_this$_filter2 = this._filter) === null || _this$_filter2 === void 0 ? void 0 : _this$_filter2.property];
  }
  get propertyOptions() {
    var _this$fields2;
    return Object.entries((_this$fields2 = this.fields) !== null && _this$fields2 !== void 0 ? _this$fields2 : {}).filter(([, fieldDef]) => SUPPORTED_FIELD_DATA_TYPES.includes(fieldDef.type) || isSupportedDurationField(fieldDef)).map(([fieldName, {
      title
    }]) => ({
      value: fieldName,
      text: title !== null && title !== void 0 ? title : fieldName
    })).sort((a, b) => a.text.localeCompare(b.text));
  }
  get operatorOptions() {
    return this.operators[this.fieldIsRelation ? "relation" : this.fieldType];
  }
  get fieldIsRelation() {
    return Boolean(this.currentPropertyRelationConfig);
  }
  get currentPropertyRelationConfig() {
    var _this$store, _this$store$modelRela;
    return (_this$store = this.store) === null || _this$store === void 0 ? void 0 : (_this$store$modelRela = _this$store.modelRelations) === null || _this$store$modelRela === void 0 ? void 0 : _this$store$modelRela.find(({
      foreignKey
    }) => {
      var _this$_filter3;
      return foreignKey === ((_this$_filter3 = this._filter) === null || _this$_filter3 === void 0 ? void 0 : _this$_filter3.property);
    });
  }
  updateOperators() {
    delete this._operatorArgCountLookup;
  }
  get operatorArgCountLookup() {
    return this._operatorArgCountLookup || (this._operatorArgCountLookup = FieldFilterPicker.buildOperatorArgCountLookup(this.operators));
  }
  updateFilter() {
    if (this._filter) {
      this.onFilterChange();
    }
  }
  updateStore(newStore) {
    var _this$_store;
    (_this$_store = this._store) === null || _this$_store === void 0 ? void 0 : _this$_store.un(this);
    newStore === null || newStore === void 0 ? void 0 : newStore.ion({
      refresh: "onStoreRefresh",
      thisObj: this
    });
  }
  onStoreRefresh({
    action
  }) {
    if (this.isMultiSelectValueField && ["dataset", "create", "update", "delete"].includes(action)) {
      this.valueFields[0].items = this.getUniqueDataValues(this.filterValues);
    }
  }
  refreshValueFields() {
    const me = this, {
      valueFieldRow
    } = me.widgetMap;
    valueFieldRow.removeAll();
    valueFieldRow.add(me.getValueFieldConfigs());
    delete me._valueFields;
    me.refreshCaseSensitive();
  }
  refreshCaseSensitive() {
    var _me$_filter2, _me$_filter3;
    const me = this, {
      fieldType,
      operatorArgCount,
      isMultiSelectValueField
    } = me, operator = (_me$_filter2 = me._filter) === null || _me$_filter2 === void 0 ? void 0 : _me$_filter2.operator, {
      caseSensitive
    } = me.widgetMap;
    caseSensitive.hidden = fieldType !== "string" || !operator || isMultiSelectValueField || operatorArgCount === 0;
    caseSensitive.checked = ((_me$_filter3 = me._filter) === null || _me$_filter3 === void 0 ? void 0 : _me$_filter3.caseSensitive) !== false;
  }
  onPropertySelect(event) {
    var _event$record;
    const me = this, {
      _filter
    } = me;
    _filter.property = ((_event$record = event.record) === null || _event$record === void 0 ? void 0 : _event$record.data.value) || null;
    if (me.fieldType !== me._fieldType) {
      _filter.operator = null;
      _filter.value = null;
    }
    me._fieldType = _filter.type = me.fieldType;
    me.refreshOperatorPicker();
    me.refreshValueFields();
    me.triggerChange();
  }
  onCaseSensitiveChange({
    checked
  }) {
    this._filter.caseSensitive = checked;
    this.triggerChange();
  }
  onOperatorSelect(event) {
    var _event$record2;
    const me = this, wasMultiSelectValueField = me.isMultiSelectValueField;
    const prevArgCount = this.operatorArgCount;
    me._filter.operator = ((_event$record2 = event.record) === null || _event$record2 === void 0 ? void 0 : _event$record2.data.value) || null;
    if (me.operatorArgCount !== prevArgCount) {
      me._filter.value = null;
    }
    if (me.isMultiSelectValueField && !wasMultiSelectValueField) {
      me._filter.value = [];
    }
    me.refreshValueFields();
    me.triggerChange();
  }
  triggerChange() {
    const {
      filter,
      isValid
    } = this;
    this.trigger("change", {
      filter,
      isValid
    });
  }
  onValueChange() {
    const me = this, {
      isMultiSelectValueField,
      fieldType,
      _filter
    } = me, values = this.valueFields.map((field) => field.value);
    if (isMultiSelectValueField && fieldType === "date") {
      _filter.value = values[0].map((timestamp) => new Date(timestamp));
    } else if (isMultiSelectValueField && fieldType === "duration") {
      _filter.value = values[0].map((durationStr) => new Duration(durationStr));
    } else {
      if (fieldType === "date" && _filter.operator === "between" && DateHelper.isValidDate(values[1])) {
        values[1].setHours(23, 59, 59, 999);
      }
      _filter.value = values.length === 1 ? values[0] : values;
    }
    me.triggerChange();
  }
  refreshOperatorPicker() {
    const {
      operatorPicker
    } = this.widgetMap, {
      _filter: {
        operator,
        property
      },
      operatorOptions
    } = this;
    operatorPicker.items = operatorOptions;
    operatorPicker.value = operator;
    operatorPicker.hidden = property === null;
  }
  populateUIFromFilter(forceRefreshValueFields = false) {
    const me = this, {
      filterValues,
      widgetMap: {
        propertyPicker,
        operatorPicker
      },
      _filter: {
        property,
        operator,
        disabled
      },
      propertyOptions,
      operatorOptions,
      isMultiSelectValueField
    } = me;
    propertyPicker.items = propertyOptions;
    operatorPicker.items = operatorOptions;
    operatorPicker.hidden = property === null;
    let refreshValueFields = forceRefreshValueFields;
    if (propertyPicker.value !== property) {
      propertyPicker.value = property;
      me.refreshOperatorPicker();
      refreshValueFields = true;
    }
    if (operatorPicker.value !== operator) {
      if (operator === null) {
        operatorPicker.clear();
      } else {
        operatorPicker.value = operator;
      }
      refreshValueFields = true;
    }
    if (refreshValueFields) {
      me.refreshValueFields();
    }
    me.refreshCaseSensitive();
    me.valueFields.forEach((valueField, fieldIndex) => {
      if (isMultiSelectValueField && (valueField.value.length > 0 || filterValues.length > 0)) {
        if (me.fieldType === "date") {
          valueField.value = filterValues.map((date) => date === null || date === void 0 ? void 0 : date.valueOf());
        } else if (me.fieldType === "duration") {
          valueField.value = filterValues.map((duration) => duration === null || duration === void 0 ? void 0 : duration.toString());
        } else {
          valueField.value = filterValues;
        }
      } else if (fieldIndex >= filterValues.length) {
        valueField.clear();
      } else {
        valueField.value = filterValues[fieldIndex];
      }
    });
    me.allChildInputs.forEach((widget) => widget.disabled = me.disabled || disabled);
  }
  get valueFields() {
    return this._valueFields || (this._valueFields = this.widgetMap.valueFieldRow.queryAll((w) => ["textfield", "datefield", "numberfield", "durationfield", "combo"].includes(w.type)));
  }
  get filterValues() {
    var _this$_filter4;
    if (((_this$_filter4 = this._filter) === null || _this$_filter4 === void 0 ? void 0 : _this$_filter4.value) == null) {
      return [];
    }
    return ArrayHelper.asArray(this._filter.value);
  }
  onFilterChange() {
    const me = this, newFieldType = me.fieldType, forceRefreshValueFields = newFieldType !== me._fieldType;
    me._fieldType = me._filter.type = newFieldType;
    me.populateUIFromFilter(forceRefreshValueFields);
  }
  get operatorArgCount() {
    const {
      fieldType,
      filter: {
        operator
      },
      operatorArgCountLookup
    } = this;
    return fieldType && operator ? operatorArgCountLookup[fieldType][operator] : 1;
  }
  get isValid() {
    const me = this, {
      filter,
      fieldType,
      filterValues,
      isMultiSelectValueField,
      operatorArgCount
    } = me, {
      operator
    } = filter, missingValue = operatorArgCount > 0 && (filter === null || filter === void 0 ? void 0 : filter.value) == null;
    return fieldType && operator && !missingValue && (isMultiSelectValueField && filterValues.length > 0 || filterValues.length === operatorArgCount) && filterValues.every((value) => value != null && (fieldType !== "duration" || value.isValid));
  }
};
_defineProperty(FieldFilterPicker, "operators", {
  empty: {
    value: "empty",
    text: "L{isEmpty}",
    argCount: 0
  },
  notEmpty: {
    value: "notEmpty",
    text: "L{isNotEmpty}",
    argCount: 0
  },
  "=": {
    value: "=",
    text: "L{equals}"
  },
  "!=": {
    value: "!=",
    text: "L{doesNotEqual}"
  },
  ">": {
    value: ">",
    text: "L{isGreaterThan}"
  },
  "<": {
    value: "<",
    text: "L{isLessThan}"
  },
  ">=": {
    value: ">=",
    text: "L{isGreaterThanOrEqualTo}"
  },
  "<=": {
    value: "<=",
    text: "L{isLessThanOrEqualTo}"
  },
  between: {
    value: "between",
    text: "L{isBetween}",
    argCount: 2
  },
  notBetween: {
    value: "notBetween",
    text: "L{isNotBetween}",
    argCount: 2
  },
  isIncludedIn: {
    value: "isIncludedIn",
    text: "L{isOneOf}"
  },
  isNotIncludedIn: {
    value: "isNotIncludedIn",
    text: "L{isNotOneOf}"
  }
});
_defineProperty(FieldFilterPicker, "defaultOperators", {
  string: [
    FieldFilterPicker.operators.empty,
    FieldFilterPicker.operators.notEmpty,
    FieldFilterPicker.operators["="],
    FieldFilterPicker.operators["!="],
    {
      value: "includes",
      text: "L{contains}"
    },
    {
      value: "doesNotInclude",
      text: "L{doesNotContain}"
    },
    {
      value: "startsWith",
      text: "L{startsWith}"
    },
    {
      value: "endsWith",
      text: "L{endsWith}"
    },
    FieldFilterPicker.operators.isIncludedIn,
    FieldFilterPicker.operators.isNotIncludedIn
  ],
  number: [FieldFilterPicker.operators.empty, FieldFilterPicker.operators.notEmpty, FieldFilterPicker.operators["="], FieldFilterPicker.operators["!="], FieldFilterPicker.operators[">"], FieldFilterPicker.operators["<"], FieldFilterPicker.operators[">="], FieldFilterPicker.operators["<="], FieldFilterPicker.operators.between, FieldFilterPicker.operators.notBetween, FieldFilterPicker.operators.isIncludedIn, FieldFilterPicker.operators.isNotIncludedIn],
  date: [FieldFilterPicker.operators.empty, FieldFilterPicker.operators.notEmpty, FieldFilterPicker.operators["="], FieldFilterPicker.operators["!="], {
    value: "<",
    text: "L{isBefore}"
  }, {
    value: ">",
    text: "L{isAfter}"
  }, FieldFilterPicker.operators.between, {
    value: "isToday",
    text: "L{isToday}",
    argCount: 0
  }, {
    value: "isTomorrow",
    text: "L{isTomorrow}",
    argCount: 0
  }, {
    value: "isYesterday",
    text: "L{isYesterday}",
    argCount: 0
  }, {
    value: "isThisWeek",
    text: "L{isThisWeek}",
    argCount: 0
  }, {
    value: "isNextWeek",
    text: "L{isNextWeek}",
    argCount: 0
  }, {
    value: "isLastWeek",
    text: "L{isLastWeek}",
    argCount: 0
  }, {
    value: "isThisMonth",
    text: "L{isThisMonth}",
    argCount: 0
  }, {
    value: "isNextMonth",
    text: "L{isNextMonth}",
    argCount: 0
  }, {
    value: "isLastMonth",
    text: "L{isLastMonth}",
    argCount: 0
  }, {
    value: "isThisYear",
    text: "L{isThisYear}",
    argCount: 0
  }, {
    value: "isNextYear",
    text: "L{isNextYear}",
    argCount: 0
  }, {
    value: "isLastYear",
    text: "L{isLastYear}",
    argCount: 0
  }, {
    value: "isYearToDate",
    text: "L{isYearToDate}",
    argCount: 0
  }, FieldFilterPicker.operators.isIncludedIn, FieldFilterPicker.operators.isNotIncludedIn],
  boolean: [{
    value: "isTrue",
    text: "L{isTrue}",
    argCount: 0
  }, {
    value: "isFalse",
    text: "L{isFalse}",
    argCount: 0
  }],
  duration: [FieldFilterPicker.operators.empty, FieldFilterPicker.operators.notEmpty, FieldFilterPicker.operators["="], FieldFilterPicker.operators["!="], FieldFilterPicker.operators[">"], FieldFilterPicker.operators["<"], FieldFilterPicker.operators[">="], FieldFilterPicker.operators["<="], FieldFilterPicker.operators.between, FieldFilterPicker.operators.notBetween, FieldFilterPicker.operators.isIncludedIn, FieldFilterPicker.operators.isNotIncludedIn],
  relation: [FieldFilterPicker.operators.isIncludedIn, FieldFilterPicker.operators.isNotIncludedIn]
});
_defineProperty(FieldFilterPicker, "configurable", {
  fields: null,
  disabled: false,
  readOnly: false,
  layout: "vbox",
  propertyLocked: false,
  operatorLocked: false,
  filter: null,
  propertyFieldConfig: null,
  operatorFieldConfig: null,
  valueFieldCls: null,
  items: {
    propertyAndOperator: {
      type: "container",
      layout: "box",
      items: {
        propertyPicker: {
          type: "combo",
          items: {},
          cls: `b-${FieldFilterPicker.type}-property`,
          placeholder: "L{FieldFilterPicker.selectAProperty}"
        },
        operatorPicker: {
          type: "combo",
          items: {},
          cls: `b-${FieldFilterPicker.type}-operator`,
          placeholder: "L{FieldFilterPicker.selectAnOperator}"
        }
      }
    },
    valueFieldRow: {
      type: "container",
      cls: `b-${FieldFilterPicker.type}-values`,
      items: {}
    },
    caseSensitive: {
      type: "checkbox",
      text: "L{FieldFilterPicker.caseSensitive}",
      cls: `b-${FieldFilterPicker.type}-case-sensitive`
    }
  },
  operators: FieldFilterPicker.defaultOperators,
  dateFormat: "L{FieldFilterPicker.dateFormat}",
  store: null,
  valueFieldPlaceholders: null,
  getValueFieldConfig: null
});
_defineProperty(FieldFilterPicker, "buildOperatorArgCountLookup", (operators) => ArrayHelper.keyBy(Object.entries(operators), ([fieldType]) => fieldType, ([, operators2]) => ArrayHelper.keyBy(operators2, ({
  value
}) => value, ({
  argCount
}) => argCount === void 0 ? 1 : argCount)));
FieldFilterPicker.initClass();
FieldFilterPicker._$name = "FieldFilterPicker";
var Label = class extends Widget {
  compose() {
    const {
      text,
      html
    } = this;
    return {
      tag: "label",
      text,
      html
    };
  }
};
_defineProperty(Label, "$name", "Label");
_defineProperty(Label, "type", "label");
_defineProperty(Label, "configurable", {
  text: null,
  localizableProperties: ["text"]
});
Label.initClass();
Label._$name = "Label";
var FieldFilterPickerGroup = class extends Container {
  static get $name() {
    return "FieldFilterPickerGroup";
  }
  static get type() {
    return "fieldfilterpickergroup";
  }
  afterConstruct() {
    const me = this;
    me.validateConfig();
    const {
      addFilterButton
    } = me.widgetMap;
    addFilterButton.ion({
      click: "addFilter",
      thisObj: me
    });
    addFilterButton.text = me.L(addFilterButton.text);
    me.store && me.updateStore(me.store);
    super.afterConstruct();
  }
  changeDateFormat(dateFormat) {
    return this.L(dateFormat);
  }
  validateConfig() {
    if (!this.fields && !this.store) {
      throw new Error(`FieldFilterPickerGroup requires either a 'fields' or 'store' config property.`);
    }
  }
  get someFiltersNotShown() {
    return this.store && this.store.filters.count > this.filters.length;
  }
  updateFields(newFields) {
    this.widgetMap.pickers.childItems.forEach((picker) => picker.fields = newFields);
  }
  updateFilters(newFilters, oldFilters) {
    const me = this;
    if (oldFilters) {
      oldFilters.filter((filter) => !newFilters.find((newFilter) => newFilter.id === filter.id)).forEach((filter) => {
        var _me$store;
        return (_me$store = me.store) === null || _me$store === void 0 ? void 0 : _me$store.removeFilter(filter.id);
      });
    }
    newFilters.forEach((filter) => filter.id = filter.id || me.nextFilterId);
    me.widgetMap.pickers.items = (newFilters === null || newFilters === void 0 ? void 0 : newFilters.map((filter) => me.getPickerRowConfig(filter))) || [];
  }
  changeFilters(newFilters) {
    const {
      canManageFilter
    } = this;
    return newFilters && canManageFilter ? newFilters.filter((filter) => this.callback(canManageFilter, this, [filter])) : newFilters;
  }
  updateStore(newStore) {
    const me = this;
    me.detachListeners("store");
    if (newStore) {
      me.widgetMap.pickers.childItems.forEach(({
        widgetMap: {
          filterPicker: {
            filter,
            isValid
          }
        }
      }) => {
        newStore.removeFilter(filter.id, true);
        if (isValid) {
          newStore.addFilter(filter, true);
        }
      });
      newStore.filter();
      me.appendFiltersFromStore();
      newStore.ion({
        name: "store",
        filter: "onStoreFilter",
        thisObj: me
      });
    }
    me.widgetMap.pickers.childItems.forEach((picker) => picker.store = newStore);
  }
  updateShowAddFilterButton(newShow) {
    this.widgetMap.addFilterButton.hidden = !newShow;
  }
  updateAddFilterButtonText(newText) {
    this.widgetMap.addFilterButton.text = newText !== null && newText !== void 0 ? newText : FieldFilterPickerGroup.addFilterButtonDefaultText;
  }
  appendFiltersFromStore() {
    const me = this;
    me.store.filters.forEach((filter) => {
      var _me$filters;
      const canManage = me.canManage(filter), {
        property,
        operator,
        value,
        id,
        disabled = false,
        caseSensitive
      } = filter;
      if (canManage && property && operator && !((_me$filters = me.filters) !== null && _me$filters !== void 0 && _me$filters.find((filter2) => filter2.id === id))) {
        me.appendFilter({
          id,
          property,
          operator,
          value,
          disabled,
          caseSensitive
        });
      }
    });
  }
  canManage(filter) {
    const me = this;
    return !me.canManageFilter || me.callback(me.canManageFilter, me, [filter]) === true;
  }
  getFilterPickerConfig(filter) {
    const me = this, {
      fields,
      store,
      disabled,
      readOnly,
      valueFieldCls,
      operators,
      limitToProperty,
      dateFormat,
      getFieldFilterPickerConfig
    } = me;
    return _objectSpread2({
      type: me.constructor.childPickerType,
      fields: fields !== null && fields !== void 0 ? fields : me.getFieldsFromStore(store),
      filter,
      store,
      disabled,
      readOnly,
      propertyLocked: Boolean(limitToProperty),
      valueFieldCls,
      operators,
      dateFormat,
      internalListeners: {
        change: "onFilterPickerChange",
        thisObj: me
      },
      flex: 1
    }, getFieldFilterPickerConfig ? me.callback(getFieldFilterPickerConfig, me, [filter]) : void 0);
  }
  getFieldsFromStore(store) {
    var _store$fields$map, _store$fields;
    return Object.fromEntries((_store$fields$map = (_store$fields = store.fields) === null || _store$fields === void 0 ? void 0 : _store$fields.map(({
      name,
      type
    }) => [name, {
      type
    }])) !== null && _store$fields$map !== void 0 ? _store$fields$map : []);
  }
  getPickerRowConfig(filter) {
    const me = this, {
      disabled,
      readOnly,
      canDeleteFilter
    } = me;
    return {
      type: "container",
      layout: "box",
      layoutStyle: {
        alignItems: "start"
      },
      cls: `b-${FieldFilterPickerGroup.type}-row`,
      dataset: {
        separatorText: me.L("L{FieldFilterPicker.and}")
      },
      items: {
        activeCheckbox: {
          type: "checkbox",
          disabled,
          readOnly,
          checked: !Boolean(filter.disabled),
          listeners: {
            change: "onFilterActiveChange",
            thisObj: me
          },
          cls: `b-${FieldFilterPickerGroup.type}-filter-active`
        },
        filterPicker: me.getFilterPickerConfig(filter),
        removeButton: {
          type: "button",
          ref: "removeButton",
          disabled,
          readOnly,
          hidden: canDeleteFilter && me.callback(canDeleteFilter, me, [filter]) === false,
          cls: `b-transparent b-${FieldFilterPickerGroup.type}-remove`,
          icon: "b-fa-trash",
          internalListeners: {
            click: "removeFilter",
            thisObj: me
          }
        }
      }
    };
  }
  get allInputs() {
    const childInputTypes = [this.constructor.childPickerType, "button", "checkbox"];
    return this.queryAll((w) => childInputTypes.includes(w.type));
  }
  updateDisabled(newDisabled) {
    this.allInputs.forEach((input) => input.disabled = newDisabled);
  }
  updateReadOnly(newReadOnly) {
    this.allInputs.forEach((input) => input.readOnly = newReadOnly);
  }
  onFilterActiveChange({
    source,
    checked
  }) {
    const me = this, filterIndex = me.getFilterIndex(source), filter = me.filters[filterIndex], filterPicker = me.getFilterPicker(filterIndex);
    filter.disabled = !checked;
    filterPicker.onFilterChange();
    if (me.store && filterPicker.isValid) {
      me.store.addFilter(filter, true);
    }
    me.updateStoreFilter();
    me.triggerChange();
  }
  onFilterPickerChange({
    source,
    filter,
    isValid
  }) {
    const me = this, {
      store
    } = me, filterIndex = me.getFilterIndex(source);
    if (store) {
      store.removeFilter(filter.id, true);
      if (isValid) {
        store.addFilter(filter, true);
      }
      me.updateStoreFilter();
    }
    Object.assign(me.filters[filterIndex], filter);
    me.triggerChange();
  }
  getFilterIndex(eventSource) {
    return this.widgetMap.pickers.childItems.indexOf(eventSource.containingWidget);
  }
  getPickerRow(index) {
    return this.widgetMap.pickers.childItems[index];
  }
  getFilterPicker(filterIndex) {
    return this.getPickerRow(filterIndex).widgetMap.filterPicker;
  }
  get nextFilterId() {
    this._nextId = (this._nextId || 0) + 1;
    return `${this.id}-filter-${this._nextId}`;
  }
  removeFilter({
    source
  }) {
    const me = this, filterIndex = me.getFilterIndex(source), filter = me.filters[filterIndex], pickerRow = me.getPickerRow(filterIndex), newFocusWidget = me.query((w) => w.isFocusable && w.type !== "container" && !pickerRow.contains(w));
    if (newFocusWidget) {
      newFocusWidget.focus();
    }
    me.removeFilterAt(filterIndex);
    if (me.store) {
      me.store.removeFilter(filter.id, true);
      me.updateStoreFilter();
    }
    me.trigger("remove", {
      filter
    });
    me.triggerChange();
  }
  addFilter({
    property = null,
    operator = null,
    value = null
  } = {}) {
    const me = this, {
      filters
    } = me, newFilter = {
      property: me.limitToProperty || property,
      operator,
      value,
      disabled: false,
      id: me.nextFilterId,
      caseSensitive: false
    };
    me.appendFilter(newFilter);
    if (me.getFilterPicker(filters.length - 1).isValid) {
      var _me$store2;
      (_me$store2 = me.store) === null || _me$store2 === void 0 ? void 0 : _me$store2.addFilter(newFilter, true);
      me.store && me.updateStoreFilter();
    }
    me.trigger("add", {
      filter: newFilter
    });
    me.triggerChange();
  }
  appendFilter(filter) {
    const me = this;
    if (!me.limitToProperty || filter.property === me.limitToProperty) {
      me.filters.push(filter);
      me.widgetMap.pickers.add(me.getPickerRowConfig(filter, me.filters.length - 1));
    }
  }
  onStoreFilter(event) {
    const me = this;
    if (me._isUpdatingStore) {
      return;
    }
    const {
      filters
    } = event, storeFiltersById = filters.values.reduce((byId, filter) => _objectSpread2(_objectSpread2({}, byId), {}, {
      [filter.id]: filter
    }), {});
    for (let filterIndex = me.filters.length - 1; filterIndex >= 0; filterIndex--) {
      const filter = me.filters[filterIndex], storeFilter = storeFiltersById[filter.id], filterRow = me.getPickerRow(filterIndex);
      if (filterRow) {
        const {
          filterPicker,
          activeCheckbox
        } = filterRow.widgetMap;
        if (!storeFilter && filterPicker.isValid) {
          me.removeFilterAt(filterIndex);
        } else if (storeFilter !== void 0) {
          const {
            operator,
            value,
            property,
            disabled,
            caseSensitive
          } = storeFilter;
          if (filter !== storeFilter) {
            Object.assign(filter, {
              operator,
              value,
              property,
              disabled,
              caseSensitive
            });
          }
          filterPicker.filter = filter;
          filterPicker.onFilterChange();
          activeCheckbox.checked = !disabled;
        }
      }
    }
    me.appendFiltersFromStore();
    me.triggerChange();
  }
  removeFilterAt(filterIndex) {
    const {
      widgetMap: {
        pickers
      },
      filters
    } = this;
    pickers.remove(pickers.childItems[filterIndex]);
    filters.splice(filterIndex, 1);
    this.triggerChange();
  }
  updateStoreFilter() {
    this._isUpdatingStore = true;
    this.store.filter();
    this._isUpdatingStore = false;
  }
  get value() {
    return this.filters;
  }
  triggerChange() {
    this.trigger("change", {
      filters: this.value
    });
  }
  activateAll() {
    this.setAllActiveStatus(true);
  }
  deactivateAll() {
    this.setAllActiveStatus(false);
  }
  setAllActiveStatus(newActive) {
    const me = this, {
      _filters,
      store
    } = me;
    _filters.forEach((filter, filterIndex) => {
      if (newActive === filter.disabled) {
        const {
          filterPicker,
          activeCheckbox
        } = me.getPickerRow(filterIndex).widgetMap;
        filter.disabled = !newActive;
        filterPicker.onFilterChange();
        activeCheckbox.checked = newActive;
        if (newActive && store && filterPicker.isValid) {
          store.addFilter(filter, true);
        }
      }
    });
    me.updateStoreFilter();
  }
};
_defineProperty(FieldFilterPickerGroup, "addFilterButtonDefaultText", "L{FieldFilterPickerGroup.addFilter}");
_defineProperty(FieldFilterPickerGroup, "configurable", {
  filters: [],
  fields: null,
  disabled: false,
  readOnly: false,
  layout: "vbox",
  store: null,
  limitToProperty: null,
  valueFieldCls: null,
  showAddFilterButton: true,
  canDeleteFilter: null,
  getFieldFilterPickerConfig: null,
  canManageFilter: null,
  addFilterButtonText: null,
  items: {
    pickers: {
      type: "container",
      layout: "vbox",
      scrollable: true,
      items: {}
    },
    addFilterButton: {
      type: "button",
      text: FieldFilterPickerGroup.addFilterButtonDefaultText,
      cls: `b-${FieldFilterPickerGroup.type}-add-button`,
      hidden: true
    }
  },
  operators: null,
  dateFormat: "L{FieldFilterPicker.dateFormat}"
});
_defineProperty(FieldFilterPickerGroup, "childPickerType", "fieldfilterpicker");
FieldFilterPickerGroup.initClass();
FieldFilterPickerGroup._$name = "FieldFilterPickerGroup";
var FieldSet = class extends Panel.mixin(Labelable) {
  static get $name() {
    return "FieldSet";
  }
  static get type() {
    return "fieldset";
  }
  static get configurable() {
    return {
      bodyTag: "fieldset",
      focusable: false,
      inline: null,
      inlineInternal: null,
      layout: {
        type: "box",
        horizontal: false
      }
    };
  }
  static get prototypeProperties() {
    return {
      flexRowCls: "b-hbox",
      flexColCls: "b-vbox"
    };
  }
  get bodyConfig() {
    const result = super.bodyConfig, {
      className
    } = result, {
      inlineInternal: inline,
      hasLabel,
      title
    } = this;
    delete result.html;
    className["b-inline"] = inline;
    className["b-fieldset-has-label"] = hasLabel;
    if (title) {
      result.children = {
        legendElement: {
          tag: "legend",
          text: title,
          class: {
            "b-fieldset-legend": 1
          }
        }
      };
    }
    return result;
  }
  compose() {
    const {
      inlineInternal: inline,
      label,
      labelCls,
      labelWidth
    } = this;
    return {
      class: {
        "b-field": label,
        "b-vbox": !inline
      },
      children: {
        "labelElement > headerElement": (label || null) && {
          tag: "label",
          html: label,
          class: {
            "b-label": 1,
            "b-align-start": 1,
            [labelCls]: labelCls
          },
          style: {
            width: DomHelper.unitize("width", labelWidth)[1]
          }
        }
      }
    };
  }
  syncInlineInternal() {
    var _this$inline;
    this.inlineInternal = (_this$inline = this.inline) !== null && _this$inline !== void 0 ? _this$inline : this.label != null && this.labelPosition === "before";
  }
  updateDisabled(value, was) {
    super.updateDisabled(value, was);
    this.eachWidget((item) => {
      item.disabled = value;
    }, false);
  }
  updateInline() {
    this.syncInlineInternal();
  }
  updateInlineInternal(inline) {
    this.layout.horizontal = inline;
  }
  updateLabel() {
    this.syncInlineInternal();
  }
  updateLabelPosition() {
    this.syncInlineInternal();
  }
};
FieldSet.initClass();
FieldSet._$name = "FieldSet";
var FileField = class extends Field {
  static get $name() {
    return "FileField";
  }
  static get type() {
    return "filefield";
  }
  static get configurable() {
    return {
      multiple: null,
      accept: null,
      inputType: "file",
      attributes: ["multiple", "accept"]
    };
  }
  get files() {
    return this.input.files;
  }
  pickFile() {
    this.input.click();
  }
  get multiple() {
    return this._multiple ? "" : null;
  }
  clear() {
    this.input.value = null;
  }
  triggerChange(event) {
    this.triggerFieldChange({
      event,
      value: this.input.value,
      oldValue: this._lastValue,
      userAction: true,
      valid: true
    });
  }
};
FileField.initClass();
FileField._$name = "FileField";
var FilePicker = class extends Container {
  static get $name() {
    return "FilePicker";
  }
  static get type() {
    return "filepicker";
  }
  static get defaultConfig() {
    return {
      defaultBindProperty: "value",
      buttonConfig: null,
      fileFieldConfig: null
    };
  }
  construct(config = {}) {
    const me = this;
    config.items = [Object.assign({
      type: "button",
      ref: "fileButton",
      text: "L{FilePicker.file}",
      localeClass: this
    }, config.buttonConfig), Object.assign({
      type: "filefield",
      ref: "fileField",
      style: "display: none"
    }, config.fileFieldConfig)].concat(config.items || []);
    super.construct(config);
    me.button.ion({
      click: me.onButtonClick,
      thisObj: me
    });
    me.fileField.ion({
      change: me.onFileFieldChange,
      thisObj: me
    });
    me._thisIsAUsedExpression(me.fileTip);
  }
  get button() {
    return this.widgetMap.fileButton;
  }
  get fileField() {
    return this.widgetMap.fileField;
  }
  get files() {
    return this.fileField.files;
  }
  get fileTip() {
    const me = this;
    return me._fileTip || (me._fileTip = new Tooltip({
      cls: "b-file-tip",
      forElement: me.button.element,
      showOnHover: true,
      align: "b-t",
      scrollAction: "realign",
      internalListeners: {
        beforeshow() {
          const tip = this, files = me.files;
          if (files && files.length) {
            tip.html = `${Array.from(files).map((file) => file.name).join("<br>")}`;
            return true;
          }
          return false;
        }
      }
    }));
  }
  clear() {
    const me = this;
    me.fileField.clear();
    me.button.badge = "";
    me.trigger("clear");
  }
  onButtonClick({
    event
  }) {
    const me = this;
    me.fileField.pickFile();
    event.preventDefault();
  }
  onFileFieldChange({
    valid
  }) {
    const me = this;
    me.button.badge = me.files.length || "";
    me.triggerFieldChange({
      files: me.files,
      valid
    });
  }
};
FilePicker.initClass();
FilePicker._$name = "FilePicker";
var FilterField = class extends TextField {
  static get $name() {
    return "FilterField";
  }
  static get type() {
    return "filterfield";
  }
  static get configurable() {
    return {
      field: null,
      store: null,
      filterFunction: null,
      clearable: true,
      keyStrokeChangeDelay: 100,
      onChange({
        value
      }) {
        const {
          store,
          field,
          filterFunction
        } = this;
        if (store) {
          const filterId = `${field || this.id}-Filter`;
          if (value.length === 0) {
            store.removeFilter(filterId);
          } else {
            let filterBy;
            if (filterFunction) {
              filterBy = (record) => filterFunction(record, value);
            } else {
              value = value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
              filterBy = (record) => record.get(field).match(new RegExp(value, "i"));
            }
            store.filter({
              id: filterId,
              filterBy
            });
          }
        }
      }
    };
  }
  updateValue(value, old) {
    super.updateValue(value, old);
    if (value && this.isConfiguring) {
      this.onChange({
        value
      });
    }
  }
};
FilterField.initClass();
FilterField._$name = "FilterField";
var items = [{
  ref: "cancelButton",
  cls: "b-messagedialog-cancelbutton b-gray",
  text: "L{Object.Cancel}",
  onClick: "up.onCancelClick"
}, {
  ref: "okButton",
  cls: "b-messagedialog-okbutton b-raised b-blue",
  text: "L{Object.Ok}",
  onClick: "up.onOkClick"
}];
if (BrowserHelper.isWindows) {
  items.reverse();
}
var MessageDialogConstructor = class extends Popup {
  static get $name() {
    return "MessageDialog";
  }
  static get type() {
    return "messagedialog";
  }
  static get configurable() {
    return {
      centered: true,
      modal: true,
      hidden: true,
      autoShow: false,
      closeAction: "hide",
      title: "\xA0",
      lazyItems: {
        $config: ["lazy"],
        value: [{
          cls: "b-messagedialog-message",
          ref: "message"
        }, {
          type: "textfield",
          cls: "b-messagedialog-input",
          ref: "input"
        }]
      },
      showClass: null,
      bbar: {
        overflow: null,
        items
      }
    };
  }
  construct() {
    this.okButton = this.yesButton = 1;
    this.cancelButton = 3;
    super.construct(...arguments);
  }
  destroy() {
  }
  async confirm() {
    return this.showDialog("confirm", ...arguments);
  }
  async alert() {
    return this.showDialog("alert", ...arguments);
  }
  async prompt({
    textField
  }) {
    const field = this.widgetMap.input;
    Widget.reconfigure(field, textField);
    field.value = "";
    return this.showDialog("prompt", ...arguments);
  }
  showDialog(mode, {
    message = "",
    title = "\xA0",
    cancelButton,
    okButton,
    rootElement = document.body
  }) {
    const me = this;
    me.rootElement = rootElement;
    me.getConfig("lazyItems");
    me.title = me.optionalL(title);
    me.widgetMap.message.html = me.optionalL(message);
    me.showClass = `b-messagedialog-${mode}`;
    if (okButton) {
      okButton = typeof okButton === "string" ? {
        text: okButton
      } : okButton;
    }
    if (cancelButton) {
      cancelButton = typeof cancelButton === "string" ? {
        text: cancelButton
      } : cancelButton;
    }
    okButton = Object.assign({}, me.widgetMap.okButton.initialConfig, okButton);
    cancelButton = Object.assign({}, me.widgetMap.cancelButton.initialConfig, cancelButton);
    okButton.text = me.optionalL(okButton.text);
    cancelButton.text = me.optionalL(cancelButton.text);
    Widget.reconfigure(me.widgetMap.okButton, okButton);
    Widget.reconfigure(me.widgetMap.cancelButton, cancelButton);
    me.show();
    return me.promise = new Promise((resolve) => {
      me.resolve = resolve;
    });
  }
  show() {
    const activeElement = DomHelper.getActiveElement(this.element);
    this.owner = this.element.contains(activeElement) ? null : MessageDialogConstructor.fromElement(document.activeElement);
    return super.show(...arguments);
  }
  updateShowClass(showClass, oldShowClass) {
    const {
      classList
    } = this.element;
    if (oldShowClass) {
      classList.remove(oldShowClass);
    }
    if (showClass) {
      classList.add(showClass);
    }
  }
  doResolve(value) {
    const me = this, {
      resolve
    } = me;
    if (resolve) {
      const isPrompt = me.showClass === "b-messagedialog-prompt";
      if (isPrompt && value === me.okButton && !me.widgetMap.input.isValid) {
        return;
      }
      me.resolve = me.reject = me.promise = null;
      resolve(isPrompt ? {
        button: value,
        text: me.widgetMap.input.value
      } : value);
      me.hide();
    }
  }
  onInternalKeyDown(event) {
    if (event.key === "Escape") {
      event.stopImmediatePropagation();
      this.onCancelClick();
    }
    if (event.key === "Enter") {
      event.stopImmediatePropagation();
      event.preventDefault();
      this.onOkClick();
    }
    super.onInternalKeyDown(event);
  }
  onOkClick() {
    this.doResolve(MessageDialog.okButton);
  }
  onCancelClick() {
    this.doResolve(MessageDialog.cancelButton);
  }
};
MessageDialogConstructor.initClass();
var MessageDialog = new Proxy({}, {
  get(target, prop) {
    const instance = target.instance || (target.instance = new MessageDialogConstructor({
      rootElement: document.body
    })), result = instance[prop];
    return typeof result === "function" ? result.bind(instance) : result;
  }
});
var PagingToolbar = class extends Toolbar {
  static get $name() {
    return "PagingToolbar";
  }
  static get type() {
    return "pagingtoolbar";
  }
  static get defaultConfig() {
    return {
      store: null,
      defaults: {
        localeClass: this
      },
      items: {
        firstPageButton: {
          onClick: "up.onFirstPageClick",
          icon: "b-icon-first",
          weight: 100,
          tooltip: "L{PagingToolbar.firstPage}"
        },
        previousPageButton: {
          onClick: "up.onPreviousPageClick",
          icon: "b-icon-previous",
          weight: 110,
          tooltip: "L{PagingToolbar.prevPage}"
        },
        pageNumber: {
          type: "numberfield",
          label: "L{page}",
          min: 1,
          max: 1,
          triggers: null,
          onChange: "up.onPageNumberChange",
          highlightExternalChange: false,
          weight: 120
        },
        pageCount: {
          type: "widget",
          cls: "b-pagecount b-toolbar-text",
          weight: 130
        },
        nextPageButton: {
          onClick: "up.onNextPageClick",
          icon: "b-icon-next",
          weight: 140,
          tooltip: "L{PagingToolbar.nextPage}"
        },
        lastPageButton: {
          onClick: "up.onLastPageClick",
          icon: "b-icon-last",
          weight: 150,
          tooltip: "L{PagingToolbar.lastPage}"
        },
        separator: {
          type: "widget",
          cls: "b-toolbar-separator",
          weight: 151
        },
        reloadButton: {
          onClick: "up.onReloadClick",
          icon: "b-icon-reload",
          weight: 160,
          tooltip: "L{PagingToolbar.reload}"
        },
        spacer: {
          type: "widget",
          cls: "b-toolbar-fill",
          weight: 161
        },
        dataSummary: {
          type: "widget",
          cls: "b-toolbar-text",
          weight: 170
        }
      }
    };
  }
  set parent(parent) {
    super.parent = parent;
    if (!this.store) {
      this.store = parent.store;
    }
  }
  get parent() {
    return super.parent;
  }
  set store(store) {
    const me = this;
    me.detachListeners("store");
    me._store = store;
    if (store) {
      store.ion({
        name: "store",
        beforerequest: "onStoreBeforeRequest",
        afterrequest: "onStoreChange",
        change: "onStoreChange",
        thisObj: me
      });
      if (store.isLoading) {
        me.onStoreBeforeRequest();
      }
    }
  }
  get store() {
    return this._store;
  }
  onStoreBeforeRequest() {
    this.eachWidget((w) => w.disable());
  }
  updateLocalization() {
    this.updateSummary();
    super.updateLocalization();
  }
  updateSummary() {
    const me = this, {
      pageCount,
      dataSummary
    } = me.widgetMap;
    let count = 0, lastPage = 0, start = 0, end = 0, allCount = 0;
    if (me.store) {
      const {
        store
      } = me, {
        pageSize,
        currentPage
      } = store;
      count = store.count;
      lastPage = store.lastPage;
      allCount = store.allCount;
      start = Math.max(0, (currentPage - 1) * pageSize + 1);
      end = Math.min(allCount, start + pageSize - 1);
    }
    pageCount.html = me.L("L{pageCountTemplate}")({
      lastPage
    });
    dataSummary.html = count ? me.L("L{summaryTemplate}")({
      start,
      end,
      allCount
    }) : me.L("L{noRecords}");
  }
  onStoreChange() {
    const me = this, {
      widgetMap,
      store
    } = me, {
      count,
      lastPage,
      currentPage
    } = store, {
      pageNumber,
      pageCount,
      firstPageButton,
      previousPageButton,
      nextPageButton,
      lastPageButton,
      dataSummary
    } = widgetMap;
    me.eachWidget((w) => w.enable());
    pageNumber.value = currentPage;
    pageNumber.max = lastPage;
    dataSummary.disabled = pageNumber.disabled = pageCount.disabled = !count;
    firstPageButton.disabled = previousPageButton.disabled = currentPage <= 1 || !count;
    nextPageButton.disabled = lastPageButton.disabled = currentPage >= lastPage || !count;
    me.updateSummary();
  }
  onPageNumberChange({
    value
  }) {
    if (this.store.currentPage !== value) {
      this.store.loadPage(value);
    }
  }
  onFirstPageClick() {
    this.store.loadPage(1);
  }
  onPreviousPageClick() {
    this.store.previousPage();
  }
  onNextPageClick() {
    this.store.nextPage();
  }
  onLastPageClick() {
    this.store.loadPage(this.store.lastPage);
  }
  onReloadClick() {
    this.store.loadPage(this.store.currentPage);
  }
};
PagingToolbar.initClass();
PagingToolbar._$name = "PagingToolbar";
var {
  dockIsHorz
} = PanelCollapser.maps;
var collapseExposeEdge = {
  top: 0,
  down: 0,
  left: 1,
  bottom: 2,
  up: 2,
  right: 3
};
var emptyObject = {};
var translateByDir = {
  up: {
    from: `translate(0,0)`,
    to: "translate(0,-100%)"
  },
  down: {
    from: `translate(0,0)`,
    to: "translate(0,100%)"
  },
  left: {
    from: `translate(0,0)`,
    to: "translate(-100%,0)"
  },
  right: {
    from: `translate(0,0)`,
    to: "translate(100%,0)"
  }
};
var PanelCollapserOverlay = class extends PanelCollapser.mixin(Delayable) {
  static get $name() {
    return "PanelCollapserOverlay";
  }
  static get type() {
    return "overlay";
  }
  static get configurable() {
    return {
      autoCloseDelay: 1e3,
      autoClose: true,
      revealing: {
        value: null,
        $config: null,
        default: false
      },
      recollapseTool: {
        type: "collapsetool",
        cls: "b-recollapse",
        collapsify: "overlay",
        handler() {
          var _this$collapsible;
          (_this$collapsible = this.collapsible) === null || _this$collapsible === void 0 ? void 0 : _this$collapsible.toggleReveal();
        }
      }
    };
  }
  static get delayable() {
    return {
      doAutoClose: 0
    };
  }
  doAutoClose() {
    this.toggleReveal(false);
  }
  updateAutoCloseDelay(delay) {
    const {
      doAutoClose
    } = this;
    if (!(doAutoClose.suspended = delay == null || delay < 0)) {
      doAutoClose.delay = delay;
      doAutoClose.immediate = !delay;
    }
  }
  changeRecollapseTool(tool) {
    const me = this, {
      panel
    } = me;
    if (me.isConfiguring || me.isDestroying || !panel || panel.isDestroying) {
      return tool;
    }
    panel.tools = {
      recollapse: tool
    };
  }
  beforeCollapse(operation) {
    if (super.beforeCollapse(operation) === false) {
      return false;
    }
    if (this.panel.revealed) {
      operation.animation = null;
    }
  }
  applyHeaderDock(collapsed, flush = true) {
    var _this$panel;
    (_this$panel = this.panel) === null || _this$panel === void 0 ? void 0 : _this$panel.recompose();
    super.applyHeaderDock(collapsed, flush);
  }
  collapseBegin(operation) {
    const me = this, {
      collapseDir,
      innerElement
    } = me, {
      animation
    } = operation, {
      collapseTool,
      panel
    } = me;
    me.configuredWidth = panel._lastWidth;
    me.configuredHeight = panel._lastHeight;
    me.applyHeaderDock(true);
    me.lockInnerSize();
    collapseTool === null || collapseTool === void 0 ? void 0 : collapseTool.element.classList.add("b-collapsed");
    if (animation) {
      panel.element.classList.add("b-collapsing");
      animation.element = innerElement;
      animation.transform = translateByDir[collapseDir];
      operation.animation = Animator.run(animation);
    }
  }
  onComplete(action) {
    var _me$autoCloseLeaveDet, _me$autoCloseClickDet;
    super.onComplete(action);
    const me = this, {
      panel
    } = me, {
      element
    } = panel;
    me.autoCloseLeaveDetacher = (_me$autoCloseLeaveDet = me.autoCloseLeaveDetacher) === null || _me$autoCloseLeaveDet === void 0 ? void 0 : _me$autoCloseLeaveDet.call(me);
    me.autoCloseClickDetacher = (_me$autoCloseClickDet = me.autoCloseClickDetacher) === null || _me$autoCloseClickDet === void 0 ? void 0 : _me$autoCloseClickDet.call(me);
    me.doAutoClose.cancel();
    if (action === "reveal" && me.autoClose) {
      if (panel.containsFocus) {
        me.autoCloseLeaveDetacher = EventHelper.on({
          element,
          mouseenter: (ev) => {
            me.doAutoClose.cancel();
          },
          mouseleave: (ev) => {
            me.doAutoClose();
          }
        });
      }
      me.autoCloseClickDetacher = EventHelper.on({
        element: document.body,
        thisObj: panel,
        mousedown: (ev) => {
          if (ev.target !== element && !element.contains(ev.target) && me.autoCloseDelay != null) {
            var _panel$focusInEvent;
            const el = panel.containsFocus && ((_panel$focusInEvent = panel.focusInEvent) === null || _panel$focusInEvent === void 0 ? void 0 : _panel$focusInEvent.relatedTarget) || DomHelper.getActiveElement(element);
            if (!(el !== null && el !== void 0 && el.contains(ev.target))) {
              me.doAutoClose.now();
            }
          }
        }
      });
    }
  }
  expandBegin(operation) {
    const me = this, {
      animation
    } = operation, {
      collapseDir,
      collapseTool,
      innerElement,
      panel
    } = me, {
      element
    } = panel;
    element.classList.remove("b-collapsed", "b-collapsing");
    me.restoreConfiguredSize();
    me.lockInnerSize(false);
    me.lockInnerSize();
    collapseTool === null || collapseTool === void 0 ? void 0 : collapseTool.element.classList.remove("b-collapsed");
    if (animation) {
      element.classList.add("b-collapsed", "b-expanding");
      animation.element = innerElement;
      animation.transform = {
        from: translateByDir[collapseDir].to,
        to: translateByDir[collapseDir].from
      };
      operation.animation = Animator.run(animation);
    }
  }
  expandEnd(operation) {
    super.expandEnd(operation);
    const {
      panel
    } = this;
    if (operation.completed) {
      panel.revealed = false;
    }
    panel.element.classList.remove("b-expanding");
  }
  expandRevert(operation) {
    super.expandRevert(operation);
    this.panel.element.classList.add("b-expanding");
  }
  get innerElement() {
    return this.panel.overlayElement;
  }
  get innerSizeElement() {
    return this.panel.element;
  }
  get toolsConfig() {
    const me = this, {
      direction
    } = me, config = super.toolsConfig, tool = me.recollapseTool;
    if (tool) {
      return _objectSpread2(_objectSpread2({}, config), {}, {
        recollapse: tool && ObjectHelper.assign({
          direction: direction.toLowerCase()
        }, tool)
      });
    }
    return config;
  }
  lockInnerSize(lock = true) {
    const me = this, {
      panel
    } = me, panelRect = lock && panel.rectangle(), inset = lock ? [0, 0, 0, 0] : "", innerRect = super.lockInnerSize(lock);
    if (lock) {
      inset[collapseExposeEdge[me.collapseDir]] = `-${panelRect[me.collapseDim] + 10}px`;
    }
    panel.element.style.clipPath = lock ? `inset(${inset.join(" ")})` : "";
    return innerRect;
  }
  onOverlayTransitionDone(ev) {
    const me = this, {
      panel
    } = me;
    if (ev.srcElement === panel.overlayElement && me.revealing) {
      me.revealing = false;
      me.onComplete(panel.revealed ? "reveal" : "unreveal");
    }
  }
  onRevealerClick() {
    this.toggleReveal();
  }
  splitHeaderItems({
    as,
    dock
  } = emptyObject) {
    var _this$panel2;
    return (_this$panel2 = this.panel) === null || _this$panel2 === void 0 ? void 0 : _this$panel2.splitHeaderItems({
      as,
      dock,
      overlay: true
    });
  }
  toggleReveal(state) {
    const {
      panel
    } = this, {
      element
    } = panel;
    if (panel.collapsed) {
      if (state == null) {
        state = !panel.revealed;
      }
      if (panel.revealed !== state && panel.trigger("beforeToggleReveal", {
        reveal: state
      }) !== false) {
        if (!state && element.contains(DomHelper.getActiveElement(element))) {
          panel.revertFocus(true);
        }
        this.revealing = true;
        panel.revealed = state;
      }
    }
  }
  updateRevealing(value) {
    const me = this, horzDirRe = /left|right/i, {
      panel
    } = me, dim = horzDirRe.test(me.collapseDir) ? "height" : "width";
    if (panel) {
      me.innerElement.style[dim] = "0px";
      me.innerElement.style[`min-${dim}`] = "100%";
      panel.element.classList[value ? "add" : "remove"]("b-panel-overlay-revealing");
    }
  }
  wrapCollapser(key, body) {
    var _panel$tools;
    const me = this, {
      collapseDir,
      panel
    } = me, {
      expandedHeaderDock,
      header,
      uiClassList
    } = panel, recollapse = (_panel$tools = panel.tools) === null || _panel$tools === void 0 ? void 0 : _panel$tools.recollapse, [before, after] = me.splitHeaderItems({
      dock: me.collapseDock,
      as: "element"
    }), horz = dockIsHorz[expandedHeaderDock], title = panel.hasHeader ? panel.title || (header === null || header === void 0 ? void 0 : header.title) || "\xA0" : null;
    if (recollapse) {
      recollapse.direction = collapseDir;
    }
    return ["overlayElement", {
      class: _objectSpread2(_objectSpread2({}, uiClassList), {}, {
        [`b-panel-overlay-header-${expandedHeaderDock}`]: 1,
        [`b-panel-overlay-${collapseDir}`]: 1,
        [`b-${horz ? "h" : "v"}box`]: 1,
        "b-panel-overlay": 1,
        "b-box-center": 1
      }),
      listeners: {
        transitionend: (ev) => me.onOverlayTransitionDone(ev)
      },
      children: {
        overlayHeaderElement: title && {
          tag: "header",
          class: new DomClassList(_objectSpread2(_objectSpread2({}, uiClassList), {}, {
            [`b-dock-${expandedHeaderDock}`]: 1,
            "b-panel-header": 1,
            "b-panel-overlay-header": 1
          }), header === null || header === void 0 ? void 0 : header.cls),
          children: [...before, {
            reference: "overlayTitleElement",
            html: title,
            class: _objectSpread2(_objectSpread2({}, uiClassList), {}, {
              [`b-align-${(header === null || header === void 0 ? void 0 : header.titleAlign) || "start"}`]: 1,
              "b-header-title": 1
            })
          }, ...after]
        },
        [key]: body
      }
    }];
  }
};
PanelCollapserOverlay.initClass();
PanelCollapserOverlay._$name = "PanelCollapserOverlay";
var PasswordField = class extends Field {
  static get type() {
    return "passwordfield";
  }
  static get alias() {
    return "password";
  }
  static get $name() {
    return "PasswordField";
  }
  construct(config = {}) {
    config.inputType = "password";
    super.construct(...arguments);
    this.element.classList.add("b-textfield");
  }
};
PasswordField.initClass();
PasswordField._$name = "PasswordField";
var Radio = class extends Checkbox {
  static get $name() {
    return "Radio";
  }
  static get type() {
    return "radio";
  }
  static get alias() {
    return "radiobutton";
  }
  static get configurable() {
    return {
      inputType: "radio",
      clearable: null,
      uncheckedValue: void 0
    };
  }
  get textLabelCls() {
    return super.textLabelCls + " b-radio-label";
  }
  internalOnClick(info) {
    if (super.internalOnClick(info) !== false) {
      if (this.checked && this.clearable) {
        this.checked = false;
      }
    }
  }
  updateName(name) {
    this.toggleGroup = name;
  }
  updateClearable() {
  }
};
Radio.initClass();
Radio._$name = "Radio";
var RadioGroup = class extends FieldSet {
  static get $name() {
    return "RadioGroup";
  }
  static get type() {
    return "radiogroup";
  }
  static get configurable() {
    return {
      defaultType: "radio",
      clearable: null,
      name: null,
      options: {
        value: null,
        $config: {
          merge: "items"
        }
      },
      defaultBindProperty: "value"
    };
  }
  get existingOptions() {
    const {
      name
    } = this;
    return this.ensureItems().filter((c) => c.name === name);
  }
  get refPrefix() {
    return `${this.name || this.ref || this.id}_`;
  }
  get selected() {
    return this.existingOptions.filter((c) => c.input.checked)[0] || null;
  }
  get value() {
    const {
      selected
    } = this;
    return selected ? selected.checkedValue : null;
  }
  set value(v) {
    this.existingOptions.forEach((c) => {
      c.isConfiguring = this.isConfiguring;
      c.checked = c.checkedValue === v;
      c.isConfiguring = false;
    });
  }
  ensureItems() {
    this.getConfig("options");
    return super.ensureItems();
  }
  changeOptions(options, was) {
    if (!(options && was && ObjectHelper.isDeeplyEqual(was, options))) {
      return options;
    }
  }
  convertOption(key, option, existing) {
    const me = this, {
      name
    } = me, ret = {
      name,
      type: "radio",
      value: key === me.value,
      ref: `${me.refPrefix}${key}`,
      checkedValue: key
    };
    if (typeof option === "string") {
      ret.text = option;
    } else {
      ObjectHelper.assign(ret, option);
    }
    return existing ? Widget.reconfigure(existing, ret) : ret;
  }
  isOurRadio(item) {
    return item.isRadio && item.name === this.name;
  }
  isolateFieldChange(field) {
    return this.isOurRadio(field);
  }
  onChildAdd(item) {
    super.onChildAdd(item);
    if (this.isOurRadio(item)) {
      item.ion({
        name: item.id,
        beforeChange: "onRadioItemBeforeChange",
        change: "onRadioItemChange",
        click: "onRadioClick",
        thisObj: this
      });
    }
  }
  onChildRemove(item) {
    if (this.isOurRadio(item)) {
      this.detachListeners(item.id);
    }
    super.onChildRemove(item);
  }
  onRadioClick(ev) {
    const {
      source
    } = ev;
    if (source.checked && this.clearable && source.clearable == null) {
      source.checked = false;
    }
  }
  onRadioItemBeforeChange(ev) {
    if (ev.checked) {
      const me = this, {
        lastValue
      } = me;
      if (!me.reverting && me.trigger("beforeChange", me.wrapRadioEvent(ev)) === false) {
        if (lastValue != null && lastValue !== me.value) {
          me.reverting = true;
          ev.source.uncheckToggleGroupMembers();
          me.value = lastValue;
          me.lastValue = lastValue;
          me.reverting = false;
          return false;
        }
      }
    }
  }
  onRadioItemChange(ev) {
    const me = this;
    if (ev.checked && !me.reverting) {
      me.triggerFieldChange(me.wrapRadioEvent(ev));
      me.lastValue = me.value;
    }
  }
  wrapRadioEvent(ev) {
    return {
      from: ev,
      item: ev.source,
      userAction: ev.userAction,
      lastValue: this.lastValue,
      value: this.value
    };
  }
  updateOptions() {
    const me = this, {
      options,
      refPrefix
    } = me, existingOptions = me.existingOptions.reduce((m, c) => {
      m[c.ref.substring(refPrefix.length)] = c;
      return m;
    }, {});
    let index = 0, key, option;
    if (options) {
      for (key in options) {
        option = me.convertOption(key, options[key], existingOptions[key]);
        delete existingOptions[key];
        me.insert(option, index++);
      }
    }
    const existing = Object.values(existingOptions);
    if (existing !== null && existing !== void 0 && existing.length) {
      me.remove(existing);
      existing.forEach((c) => c.destroy());
    }
  }
};
RadioGroup.initClass();
RadioGroup._$name = "RadioGroup";
var arrowKeys = {
  ArrowUp: 1,
  ArrowDown: 1,
  ArrowLeft: 1,
  ArrowRight: 1
};
var Slider = class extends Widget {
  static get $name() {
    return "Slider";
  }
  static get type() {
    return "slider";
  }
  static get configurable() {
    return {
      text: null,
      showValue: true,
      showTooltip: false,
      min: 0,
      max: 100,
      step: 1,
      value: 50,
      unit: null,
      thumbSize: 20,
      tooltip: {
        $config: ["lazy", "nullify"],
        value: {
          type: "tooltip",
          align: "b-t",
          anchor: false,
          axisLock: true
        }
      },
      localizableProperties: ["text"],
      triggerChangeOnInput: null,
      defaultBindProperty: "value"
    };
  }
  compose() {
    const {
      id,
      min: min2,
      max,
      showValue,
      step,
      text,
      value,
      unit = "",
      disabled
    } = this, inputId = `${id}-input`, hasText = Boolean(text || showValue);
    return {
      class: {
        "b-has-label": hasText,
        "b-text": hasText,
        "b-disabled": disabled
      },
      children: {
        input: {
          tag: "input",
          type: "range",
          id: inputId,
          reference: "input",
          disabled,
          min: min2,
          max,
          step,
          value,
          listeners: {
            input: "onInternalInput",
            change: "onInternalChange",
            mouseover: "onInternalMouseOver",
            mouseout: "onInternalMouseOut"
          }
        },
        label: {
          tag: "label",
          for: inputId,
          html: showValue ? text ? `${text} (${value}${unit})` : value + unit : text
        }
      }
    };
  }
  get focusElement() {
    return this.input;
  }
  get percentProgress() {
    return (this.value - this.min) / (this.max - this.min) * 100;
  }
  onInternalKeyDown(e) {
    if (!this.readOnly && arrowKeys[e.key]) {
      e.stopImmediatePropagation();
    }
  }
  onInternalChange() {
    this.updateUI();
    this.triggerChange(true);
    this.trigger("action", {
      value: this.value
    });
  }
  onInternalInput() {
    const me = this;
    if (me.readOnly) {
      me.input.value = me.value;
      return;
    }
    me.value = parseInt(me.input.value, 10);
    me.trigger("input", {
      value: me.value
    });
    if (me.triggerChangeOnInput) {
      me.triggerChange(me);
    }
  }
  onInternalMouseOver() {
    var _me$tooltip;
    const me = this, thumbPosition = me.rtl ? 100 - me.percentProgress : me.percentProgress;
    (_me$tooltip = me.tooltip) === null || _me$tooltip === void 0 ? void 0 : _me$tooltip.showBy({
      target: Rectangle.from(me.input).inflate(me.thumbSize / 2, -me.thumbSize / 2),
      align: `b-t${Math.round(thumbPosition)}`
    });
  }
  onInternalMouseOut() {
    var _this$tooltip;
    (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.hide();
  }
  triggerChange(userAction) {
    this.triggerFieldChange({
      value: this.value,
      valid: true,
      userAction
    });
  }
  updateMax(max) {
    const me = this;
    if (me.input && me._value > max) {
      me.value = max;
      me.trigger("input", {
        value: me.value
      });
    }
  }
  updateMin(min2) {
    const me = this;
    if (me.input && me._value < min2) {
      me.value = min2;
      me.trigger("input", {
        value: me.value
      });
    }
  }
  changeTooltip(config, existingTooltip) {
    var _this$unit;
    if (config) {
      config.owner = this;
    }
    return this.showTooltip ? Tooltip.reconfigure(existingTooltip, config, {
      owner: this,
      defaults: {
        forElement: this.input,
        html: String(this.value) + ((_this$unit = this.unit) !== null && _this$unit !== void 0 ? _this$unit : "")
      }
    }) : null;
  }
  changeValue(value) {
    const me = this, {
      min: min2,
      step
    } = me;
    value = Math.min(Math.max(value, min2), me.max);
    if (value > min2) {
      return min2 + ObjectHelper.roundTo(value - min2, step);
    }
    return ObjectHelper.roundTo(value, step);
  }
  updateValue(value) {
    const me = this, {
      input,
      _tooltip
    } = me;
    if (_tooltip) {
      var _me$unit;
      _tooltip.html = me.value + ((_me$unit = me.unit) !== null && _me$unit !== void 0 ? _me$unit : "");
    }
    if (input && input.value !== String(value)) {
      input.value = value;
      me.triggerChange(false);
    }
    me.updateUI();
  }
  updateUI() {
    var _me$_tooltip, _me$_tooltip2;
    const me = this;
    ((_me$_tooltip = me._tooltip) === null || _me$_tooltip === void 0 ? void 0 : _me$_tooltip.isVisible) && ((_me$_tooltip2 = me._tooltip) === null || _me$_tooltip2 === void 0 ? void 0 : _me$_tooltip2.alignTo({
      target: Rectangle.from(me.input).inflate(me.thumbSize / 2, -me.thumbSize / 2),
      align: `b-t${Math.round(me.percentProgress)}`
    }));
  }
};
Slider.initClass();
Slider._$name = "Slider";
var SlideToggle = class extends Checkbox {
  static get $name() {
    return "SlideToggle";
  }
  static get type() {
    return "slidetoggle";
  }
  static get properties() {
    return {
      toggledCls: "b-slidetoggle-checked"
    };
  }
  construct(config) {
    if (config !== null && config !== void 0 && config.checked) {
      config.cls = (config.cls || "") + " " + this.constructor.properties.toggledCls;
    }
    super.construct(config);
  }
  get innerElements() {
    const innerEls = super.innerElements;
    innerEls.splice(1, 0, this.toggleElement);
    if (this.text) {
      innerEls[innerEls.length - 1].class = "b-slidetoggle-label";
    } else {
      innerEls.pop();
    }
    return innerEls;
  }
  get toggleElement() {
    return {
      class: "b-slidetoggle-toggle",
      reference: "slideToggle",
      children: [{
        class: "b-slidetoggle-thumb",
        reference: "slideThumb"
      }]
    };
  }
  internalOnChange() {
    super.internalOnChange();
    this.element.classList[this.value ? "add" : "remove"](this.toggledCls);
  }
};
SlideToggle.initClass();
SlideToggle._$name = "SlideToggle";
var classesHV = ["b-horizontal", "b-vertical"];
var hasFlex = (el) => DomHelper.getStyleValue(el.parentElement, "display") === "flex" && (parseInt(DomHelper.getStyleValue(el, "flex-basis"), 10) || parseInt(DomHelper.getStyleValue(el, "flex-grow"), 10));
var verticality = {
  horizontal: false,
  vertical: true
};
var Splitter = class extends Widget {
  static get $name() {
    return "Splitter";
  }
  static get type() {
    return "splitter";
  }
  static get configurable() {
    return {
      orientation: "auto",
      vertical: null,
      containerElement: {
        $config: "nullify",
        value: null
      },
      nextNeighbor: {
        $config: "nullify",
        value: null
      },
      previousNeighbor: {
        $config: "nullify",
        value: null
      }
    };
  }
  static get delayable() {
    return {
      syncState: "raf"
    };
  }
  doDestroy() {
    var _this$mouseDetacher;
    (_this$mouseDetacher = this.mouseDetacher) === null || _this$mouseDetacher === void 0 ? void 0 : _this$mouseDetacher.call(this);
    super.doDestroy();
  }
  compose() {
    return {
      class: {
        "b-splitter": 1
      },
      listeners: _objectSpread2({
        pointerdown: "onMouseDown",
        mouseenter: "syncState"
      }, !BrowserHelper.supportsPointerEvents && {
        mousedown: "onMouseDown",
        touchstart: "onMouseDown"
      })
    };
  }
  get currentOrientation() {
    return this.vertical ? "vertical" : "horizontal";
  }
  get nextWidget() {
    return Widget.fromElement(this.element.nextElementSibling, 1);
  }
  get previousWidget() {
    return Widget.fromElement(this.element.previousElementSibling, 1);
  }
  updateContainerElement(containerElement) {
    var _me$stateDetector;
    const me = this;
    me.stateDetector = (_me$stateDetector = me.stateDetector) === null || _me$stateDetector === void 0 ? void 0 : _me$stateDetector.disconnect();
    if (containerElement) {
      me.stateDetector = new MutationObserver(() => me.syncState());
      me.stateDetector.observe(containerElement, {
        attributes: true,
        childList: true
      });
    }
  }
  updateNextNeighbor(next) {
    this.watchNeighbor(next, "next");
  }
  updatePreviousNeighbor(previous) {
    this.watchNeighbor(previous, "previous");
  }
  watchNeighbor(neighbor, name) {
    this.detachListeners(name);
    neighbor === null || neighbor === void 0 ? void 0 : neighbor.ion({
      name,
      thisObj: this,
      collapse: "syncState",
      expand: "syncState",
      hide: "syncState",
      show: "syncState"
    });
  }
  updateOrientation() {
    this.syncState.now();
  }
  updateVertical(vertical) {
    var _this$element;
    const classList = (_this$element = this.element) === null || _this$element === void 0 ? void 0 : _this$element.classList;
    classList === null || classList === void 0 ? void 0 : classList.add(classesHV[vertical ? 1 : 0]);
    classList === null || classList === void 0 ? void 0 : classList.remove(classesHV[vertical ? 0 : 1]);
  }
  syncState() {
    var _verticality$me$orien;
    const me = this, {
      element,
      nextWidget,
      previousWidget
    } = me;
    let vertical = (_verticality$me$orien = verticality[me.orientation]) !== null && _verticality$me$orien !== void 0 ? _verticality$me$orien : null;
    me.nextNeighbor = nextWidget;
    me.previousNeighbor = previousWidget;
    me.disabled = nextWidget && (nextWidget.collapsible && nextWidget.collapsed || nextWidget.hidden) || previousWidget && (previousWidget.collapsible && previousWidget.collapsed || previousWidget.hidden);
    if (vertical !== null && nextWidget && previousWidget) {
      me.containerElement = null;
    } else {
      me.containerElement = element.parentElement;
      if (me.rendered && element.offsetParent) {
        const flexDirection = DomHelper.getStyleValue(element.parentElement, "flex-direction");
        if (flexDirection) {
          vertical = !flexDirection.startsWith("column");
        } else {
          const previous = element.previousElementSibling, next = element.nextElementSibling;
          if (!previous || !next) {
            return;
          }
          const prevRect = previous.getBoundingClientRect(), nextRect = next.getBoundingClientRect(), topMost = prevRect.top < nextRect.top ? prevRect : nextRect, bottomMost = topMost === nextRect ? prevRect : nextRect;
          vertical = topMost.top === bottomMost.top;
        }
      }
    }
    me.vertical = vertical;
  }
  onMouseDown(event) {
    var _me$mouseDetacher;
    event.preventDefault();
    if (event.touches) {
      event = event.touches[0];
    }
    const me = this, {
      element
    } = me, prev = element.previousElementSibling, next = element.nextElementSibling, prevHasFlex = hasFlex(prev), nextHasFlex = hasFlex(next), flexed = [];
    (_me$mouseDetacher = me.mouseDetacher) === null || _me$mouseDetacher === void 0 ? void 0 : _me$mouseDetacher.call(me);
    for (const child of element.parentElement.children) {
      if (hasFlex(child) && child !== element) {
        flexed.push({
          element: child,
          width: child.offsetWidth,
          height: child.offsetHeight
        });
      }
    }
    me.context = {
      startX: event.pageX,
      startY: event.pageY,
      prevWidth: prev.offsetWidth,
      prevHeight: prev.offsetHeight,
      nextWidth: next.offsetWidth,
      nextHeight: next.offsetHeight,
      prevHasFlex,
      nextHasFlex,
      flexed,
      prev,
      next
    };
    const events = {
      element: document,
      pointermove: "onMouseMove",
      pointerup: "onMouseUp",
      thisObj: me
    };
    if (!BrowserHelper.supportsPointerEvents) {
      events.mousemove = events.touchmove = "onMouseMove";
      events.mouseup = events.touchend = "onMouseUp";
    }
    element.classList.add("b-moving");
    me.mouseDetacher = EventHelper.on(events);
  }
  onMouseMove(event) {
    const me = this, {
      context,
      nextWidget,
      previousWidget
    } = me, prevStyle = context.prev.style, nextStyle = context.next.style, deltaX = (event.pageX - context.startX) * (me.rtl ? -1 : 1), deltaY = event.pageY - context.startY;
    event.preventDefault();
    Object.assign(context, {
      deltaX,
      deltaY
    });
    if (!context.started) {
      context.started = true;
      me.trigger("dragStart", {
        context,
        event
      });
      context.flexed.forEach((flexed) => {
        flexed.element.style.flexGrow = me.vertical ? flexed.width : flexed.height;
        flexed.element.style.flexBasis = "0";
      });
    }
    if (me.vertical) {
      const newPrevWidth = context.prevWidth + deltaX, newNextWidth = context.nextWidth - deltaX;
      if (context.prevHasFlex) {
        prevStyle.flexGrow = newPrevWidth;
      } else if (previousWidget) {
        previousWidget.width = newPrevWidth;
      } else {
        prevStyle.width = `${newPrevWidth}px`;
      }
      if (context.nextHasFlex) {
        nextStyle.flexGrow = newNextWidth;
      } else if (nextWidget) {
        nextWidget.width = newNextWidth;
      } else {
        nextStyle.width = `${newNextWidth}px`;
      }
    } else {
      const newPrevHeight = context.prevHeight + deltaY, newNextHeight = context.nextHeight - deltaY;
      if (context.prevHasFlex) {
        prevStyle.flexGrow = newPrevHeight;
      } else if (previousWidget) {
        previousWidget.height = newPrevHeight;
      } else {
        prevStyle.height = `${newPrevHeight}px`;
      }
      if (context.nextHasFlex) {
        nextStyle.flexGrow = newNextHeight;
      } else if (nextWidget) {
        nextWidget.height = newNextHeight;
      } else {
        nextStyle.height = `${newNextHeight}px`;
      }
    }
    me.trigger("drag", {
      context,
      event
    });
  }
  onMouseUp(event) {
    var _me$mouseDetacher2;
    const me = this;
    (_me$mouseDetacher2 = me.mouseDetacher) === null || _me$mouseDetacher2 === void 0 ? void 0 : _me$mouseDetacher2.call(me);
    me.mouseDetacher = null;
    me.element.classList.remove("b-moving");
    if (me.context.started) {
      me.trigger("drop", {
        context: me.context,
        event
      });
    }
    me.context = null;
  }
  render() {
    super.render(...arguments);
    this.syncState.now();
    if (this.vertical === null) {
      this.syncState();
    }
  }
};
Splitter.initClass();
Splitter._$name = "Splitter";
var Tab = class extends Button {
  static get $name() {
    return "Tab";
  }
  static get type() {
    return "tab";
  }
  static get configurable() {
    return {
      active: null,
      index: null,
      isFirst: null,
      isLast: null,
      item: {
        value: null,
        $config: "nullify"
      },
      itemCls: null,
      tabPanel: null,
      titleProperty: "text",
      titleSource: "title",
      role: "tab"
    };
  }
  compose() {
    const {
      active,
      cls,
      index,
      isFirst,
      isLast
    } = this, setSize = this.owner.visibleChildCount;
    return {
      tabindex: 0,
      "aria-selected": active,
      "aria-setsize": setSize,
      "aria-posinset": index + 1,
      class: _objectSpread2({
        "b-tabpanel-tab": 1,
        "b-active": active,
        "b-tab-first": isFirst,
        "b-tab-last": isLast
      }, cls),
      dataset: {
        index
      }
    };
  }
  updateIndex(index) {
    this.isFirst = !index;
  }
  updateItem(item, was) {
    var _me$itemChangeDetache, _me$itemHideDetacher;
    const me = this;
    if ((was === null || was === void 0 ? void 0 : was.tab) === me) {
      was.tab = null;
    }
    if (item) {
      item.tab = me;
      me[me.titleProperty] = item[me.titleSource];
      me.itemCls = item.cls;
      me.ariaElement.setAttribute("aria-controls", item.id);
      item.role = "tabpanel";
    }
    (_me$itemChangeDetache = me.itemChangeDetacher) === null || _me$itemChangeDetache === void 0 ? void 0 : _me$itemChangeDetache.call(me);
    me.itemChangeDetacher = item && FunctionHelper.after(item, "onConfigChange", "onItemConfigChange", me, {
      return: false
    });
    (_me$itemHideDetacher = me.itemHideDetacher) === null || _me$itemHideDetacher === void 0 ? void 0 : _me$itemHideDetacher.call(me);
    me.itemHideDetacher = item === null || item === void 0 ? void 0 : item.ion({
      beforeChangeHidden: "onItemBeforeChangeHidden",
      beforeHide: "onItemBeforeHide",
      beforeUpdateDisabled: "onItemBeforeUpdateDisabled",
      thisObj: me,
      prio: 1e3
    });
    me.syncMinMax();
  }
  updateItemCls(cls, was) {
    const {
      element
    } = this, classList = element && DomClassList.from(element === null || element === void 0 ? void 0 : element.classList, true);
    if (element) {
      classList.remove(was).add(cls);
      element.className = classList.value;
    }
  }
  updateRotate(rotate, was) {
    if (!rotate !== !was) {
      this.syncMinMax();
    }
  }
  syncMinMax() {
    const me = this, {
      rotate,
      tabPanel
    } = me;
    let {
      _minWidth: minWidth,
      _minHeight: minHeight,
      _maxWidth: maxWidth,
      _maxHeight: maxHeight
    } = me;
    if (tabPanel) {
      const {
        tabMinWidth,
        tabMaxWidth
      } = tabPanel;
      if (tabMinWidth != null) {
        if (rotate) {
          if (minWidth === tabMinWidth) {
            minWidth = null;
          }
          minHeight = tabMinWidth;
        } else {
          if (minHeight === tabMinWidth) {
            minHeight = null;
          }
          minWidth = tabMinWidth;
        }
      }
      if (tabMaxWidth != null) {
        if (rotate) {
          if (maxWidth === tabMaxWidth) {
            maxWidth = null;
          }
          maxHeight = tabMaxWidth;
        } else {
          if (maxHeight === tabMaxWidth) {
            maxHeight = null;
          }
          maxWidth = tabMaxWidth;
        }
      }
      me.minWidth = minWidth;
      me.minHeight = minHeight;
      me.maxWidth = maxWidth;
      me.maxHeight = maxHeight;
    }
  }
  onItemBeforeChangeHidden({
    source: hidingChild,
    hidden
  }) {
    if (!hidingChild.$isDeactivating && !hidingChild.$isActivating) {
      const {
        tabPanel
      } = this;
      this.hidden = hidden;
      if (hidden && hidingChild === tabPanel.activeItem) {
        tabPanel.activateAvailableTab(hidingChild);
      }
    }
  }
  onItemBeforeHide() {
    if (!this.item.$isDeactivating) {
      this.hide();
    }
  }
  onItemBeforeUpdateDisabled({
    source: disablingChild,
    disabled
  }) {
    const {
      tabPanel
    } = this;
    this.disabled = disabled;
    if (disablingChild === tabPanel.activeItem) {
      tabPanel.activateAvailableTab(disablingChild);
    }
  }
  onItemConfigChange({
    name,
    value
  }) {
    if (name === this.titleSource) {
      this[this.titleProperty] = value;
    }
  }
};
Tab.initClass();
Tab._$name = "Tab";
var isTab = (t) => t.isTab;
var TabBar = class extends Toolbar {
  static get $name() {
    return "TabBar";
  }
  static get type() {
    return "tabbar";
  }
  static get configurable() {
    return {
      defaultType: "tab",
      overflow: "scroll",
      role: "tablist",
      ignoreParentReadOnly: true
    };
  }
  get firstTab() {
    return this.tabAt(0);
  }
  get lastTab() {
    return this.tabAt(-1);
  }
  get tabCount() {
    return this._items.countOf(isTab);
  }
  get tabs() {
    return ArrayHelper.from(this._items, isTab);
  }
  compose() {
    return {
      children: {
        toolbarContent: {
          class: {
            "b-tabpanel-tabs": 1
          }
        }
      }
    };
  }
  indexOfTab(tab) {
    return this._items.indexOf(tab, isTab);
  }
  onChildAdd(child) {
    super.onChildAdd(child);
    if (child.index == null) {
      this.syncTabs();
    }
  }
  onChildRemove(child) {
    super.onChildRemove(child);
    this.syncTabs();
  }
  onFocusIn() {
    const {
      activeIndex
    } = this.owner;
    if (!isNaN(activeIndex)) {
      this.tabs[activeIndex].focus();
    }
  }
  syncTabs() {
    const {
      tabs
    } = this;
    for (let i = 0, n = tabs.length; i < n; ++i) {
      tabs[i].index = i;
      tabs[i].isFirst = !i;
      tabs[i].isLast = i === n - 1;
    }
  }
  tabAt(index) {
    return this._items.find(isTab, index) || null;
  }
};
TabBar.initClass();
TabBar._$name = "TabBar";
var animationClasses = ["b-slide-out-left", "b-slide-out-right", "b-slide-in-left", "b-slide-in-right"];
var Card = class extends Layout {
  onChildAdd(item) {
    super.onChildAdd(item);
    const me = this, {
      activeItem,
      owner
    } = me, activeIndex = owner.activeIndex != null ? owner.activeIndex : me.activeIndex || 0, itemIndex = owner.items.indexOf(item), isActive = activeItem != null ? item === activeItem : itemIndex === activeIndex;
    item.ion({
      beforeHide: "onBeforeChildHide",
      beforeShow: "onBeforeChildShow",
      thisObj: me
    });
    if (isActive) {
      me._activeIndex = itemIndex;
      me._activeItem = item;
      item.show();
    } else {
      item.$isDeactivating = true;
      item.hide();
      item.$isDeactivating = false;
    }
  }
  onChildRemove(item) {
    super.onChildRemove(item);
    const me = this;
    if (me._activeItem === item) {
      me.activateSiblingOf(item);
    }
    me._activeIndex = me.owner.items.indexOf(me._activeItem);
    item.un({
      beforeHide: "onBeforeChildHide",
      beforeShow: "onBeforeChildShow",
      thisObj: me
    });
  }
  onBeforeChildShow({
    source: showingChild
  }) {
    if (!this.owner.isConfiguring && !showingChild.$isActivating) {
      this.activeItem = showingChild;
      return false;
    }
  }
  onBeforeChildHide({
    source: hidingChild
  }) {
    if (!this.owner.isConfiguring && !hidingChild.$isDeactivating) {
      this.activateSiblingOf(hidingChild);
      return false;
    }
  }
  activateSiblingOf(item) {
    const {
      owner
    } = this, items2 = owner.items.slice(), removeAt = items2.indexOf(item);
    items2.splice(removeAt, 1);
    this.activeIndex = Math.min(removeAt, items2.length - 1);
  }
  setActiveItem(activeIndex, prevActiveIndex = this.activeIndex, options) {
    const me = this, {
      owner
    } = me, {
      items: items2
    } = owner, widgetPassed = activeIndex instanceof Widget, prevActiveItem = items2[prevActiveIndex], newActiveItem = owner.items[activeIndex = widgetPassed ? items2.indexOf(activeIndex) : parseInt(activeIndex, 10)], animation = (options === null || options === void 0 ? void 0 : options.animation) !== false, chatty = !(options !== null && options !== void 0 && options.silent), event = {
      prevActiveIndex,
      prevActiveItem
    };
    if (newActiveItem && !newActiveItem.$isActivating && newActiveItem !== prevActiveItem) {
      var _owner$onBeginActiveI;
      const prevItemElement = prevActiveItem && prevActiveItem.element, newActiveElement = newActiveItem && newActiveItem.element;
      if (me.animateDetacher) {
        const activeCardChange = me.animateDetacher.event;
        if (activeCardChange.activeItem === newActiveItem) {
          return activeCardChange.promise;
        }
        me.animateDetacher();
        activeCardChange.prevActiveItem.element.classList.remove(...animationClasses);
        activeCardChange.activeItem.element.classList.remove(...animationClasses);
        me.animateDetacher = null;
      }
      event.activeIndex = activeIndex;
      event.activeItem = newActiveItem;
      if (chatty && owner.trigger("beforeActiveItemChange", event) === false) {
        return null;
      }
      const reset = me._activeIndex !== event.activeIndex;
      if (reset) {
        me._activeIndex = event.activeIndex;
      }
      chatty && ((_owner$onBeginActiveI = owner.onBeginActiveItemChange) === null || _owner$onBeginActiveI === void 0 ? void 0 : _owner$onBeginActiveI.call(owner, event));
      if (reset) {
        me._activeIndex = event.prevActiveIndex;
      }
      if (animation && prevItemElement && owner.isVisible && me.animateCardChange) {
        event.promise = me.cardChangeAnimation = new Promise((resolve, reject) => {
          const wasMonitoringSize = prevActiveItem.monitorResize;
          prevActiveItem.monitorResize = false;
          me.contentElement.style.overflowX = "hidden";
          prevActiveItem._hidden = true;
          newActiveItem.$isActivating = true;
          newActiveItem.show();
          newActiveItem.$isActivating = false;
          prevItemElement.classList.add(activeIndex > prevActiveIndex ? "b-slide-out-left" : "b-slide-out-right");
          newActiveElement.classList.add(activeIndex < prevActiveIndex ? "b-slide-in-left" : "b-slide-in-right");
          owner.isAnimating = true;
          me.animateDetacher = EventHelper.onTransitionEnd({
            mode: "animation",
            element: newActiveElement,
            thisObj: prevActiveItem,
            handler() {
              owner.isAnimating = me.cardChangeAnimation = false;
              if (!me.animateDetacher) {
                me.setActiveItem(activeIndex, prevActiveIndex, options);
                return;
              }
              me.animateDetacher = null;
              newActiveElement.classList.remove(...animationClasses);
              if (prevItemElement) {
                prevItemElement.classList.remove(...animationClasses);
                prevActiveItem.$isDeactivating = true;
                prevActiveItem._hidden = false;
                prevActiveItem.hide();
                prevActiveItem.monitorResize = wasMonitoringSize;
                prevActiveItem.$isDeactivating = false;
              }
              me.contentElement.style.overflowX = "";
              me.onActiveItemChange(event, resolve, !chatty);
            }
          });
          me.animateDetacher.reject = reject;
          me.animateDetacher.event = event;
        });
      } else {
        newActiveItem.$isActivating = true;
        newActiveItem.show();
        newActiveItem.focus();
        newActiveItem.$isActivating = false;
        if (prevActiveItem) {
          prevActiveItem.$isDeactivating = true;
          prevActiveItem.hide();
          prevActiveItem.$isDeactivating = false;
        }
        me.onActiveItemChange(event, null, !chatty);
      }
    }
    return event;
  }
  onActiveItemChange(event, resolve, silent) {
    const me = this;
    me._activeItem = event.activeItem;
    me._activeIndex = event.activeIndex;
    !silent && me.owner.trigger("activeItemChange", event);
    event.activeItem.focus();
    resolve === null || resolve === void 0 ? void 0 : resolve(event);
  }
  renderChildren() {
    const {
      owner
    } = this;
    owner.contentElement.classList.toggle(this.hideChildHeaderCls, owner.suppressChildHeaders);
    super.renderChildren();
  }
  changeActiveIndex(activeIndex) {
    const {
      owner
    } = this;
    return owner.isConfiguring && !owner._items ? activeIndex : Math.min(activeIndex, owner.items.length - 1);
  }
  updateActiveIndex(activeIndex, oldActiveIndex) {
    if (!this.owner.isConfiguring) {
      this.setActiveItem(activeIndex, oldActiveIndex);
    }
  }
  updateActiveItem(activeItem) {
    if (!this.owner.isConfiguring) {
      this.setActiveItem(activeItem, this.activeIndex);
    }
  }
  get isChangingCard() {
    return Boolean(this.animateDetacher);
  }
};
_defineProperty(Card, "$name", "Card");
_defineProperty(Card, "type", "card");
_defineProperty(Card, "configurable", {
  containerCls: "b-card-container",
  itemCls: "b-card-item",
  hideChildHeaderCls: "b-hide-child-headers",
  animateCardChange: true,
  activeItem: null,
  activeIndex: null
});
Card.initClass();
Card._$name = "Card";
var TabPanel = class extends Panel {
  static get $name() {
    return "TabPanel";
  }
  static get type() {
    return "tabpanel";
  }
  static get alias() {
    return "tabs";
  }
  static get configurable() {
    return {
      activeTab: 0,
      animateTabChange: true,
      autoHeight: false,
      defaultType: "container",
      focusable: false,
      itemCls: "b-tabpanel-item",
      layout: {
        type: "card"
      },
      suppressChildHeaders: true,
      tabBar: {
        type: "tabbar",
        weight: -2e3
      },
      tabMinWidth: null,
      tabMaxWidth: null
    };
  }
  get activeIndex() {
    return this.layout.activeIndex;
  }
  get activeItem() {
    return this.layout.activeItem;
  }
  get activeTabItemIndex() {
    var _tabBar$tabs$activeTa;
    const {
      activeTab,
      items: items2,
      tabBar
    } = this;
    return items2.indexOf((_tabBar$tabs$activeTa = tabBar.tabs[activeTab]) === null || _tabBar$tabs$activeTa === void 0 ? void 0 : _tabBar$tabs$activeTa.item);
  }
  get bodyConfig() {
    return ObjectHelper.merge({
      className: {
        "b-tabpanel-body": 1
      }
    }, super.bodyConfig);
  }
  get focusElement() {
    var _activeTab$tab;
    const activeTab = this.items[this.activeTab || 0];
    return (activeTab === null || activeTab === void 0 ? void 0 : activeTab.focusElement) || (activeTab === null || activeTab === void 0 ? void 0 : (_activeTab$tab = activeTab.tab) === null || _activeTab$tab === void 0 ? void 0 : _activeTab$tab.focusElement);
  }
  get tabPanelBody() {
    return this.bodyElement;
  }
  finalizeInit() {
    super.finalizeInit();
    const me = this, {
      activeTab,
      layout
    } = me, {
      activeIndex
    } = layout, {
      tabs
    } = me.tabBar, activeTabItemIndex = activeTab >= 0 && activeTab < tabs.length && me.items.indexOf(tabs[activeTab].item);
    if (tabs.length > 0 && (activeTabItemIndex === false || activeTabItemIndex < 0)) {
      throw new Error(`Invalid activeTab ${activeTab} (${tabs.length} tabs)`);
    }
    if (activeTabItemIndex !== activeIndex) {
      layout.setActiveItem(activeTabItemIndex, activeIndex, {
        animation: false,
        silent: true
      });
    }
    layout.animateCardChange = me.animateTabChange;
  }
  onChildAdd(child) {
    super.onChildAdd(child);
    if (!this.initialItems) {
      const me = this, {
        tabBar
      } = me, config = me.makeTabConfig(child), firstTab = config && (tabBar === null || tabBar === void 0 ? void 0 : tabBar.firstTab), tabBarItems = firstTab && tabBar._items, tabItems = firstTab && ArrayHelper.from(me._items, (it) => it.tab || it === child), index = firstTab ? tabItems.indexOf(child) + tabBarItems.indexOf(firstTab) : 0;
      if (config && tabBar) {
        if (firstTab && child.weight == null && index < tabBarItems.count - 1) {
          tabBar.insert(config, index);
        } else {
          tabBar.add(config);
        }
      }
    }
  }
  onChildRemove(child) {
    const {
      tab
    } = child, {
      items: items2
    } = this;
    if (tab) {
      this.tabBar.remove(tab);
      tab.destroy();
    }
    if (child === this.activeItem) {
      this._activeTab = null;
      if (items2.length) {
        this.activeTab = items2[Math.min(this.activeIndex, items2.length - 1)];
      }
    }
    super.onChildRemove(child);
  }
  isDisabledOrHiddenTab(tabIndex) {
    const {
      tabs
    } = this.tabBar, tab = tabs === null || tabs === void 0 ? void 0 : tabs[tabIndex];
    return tab && (tab.disabled || tab.hidden);
  }
  findAvailableTab(item, delta = 1) {
    const {
      tabs
    } = this.tabBar, tabCount = tabs.length, itemIndex = Math.max(0, tabs.indexOf(item.tab));
    if (itemIndex) {
      delta = -delta;
    }
    let activeTab;
    for (let n = 1; n <= tabCount; ++n) {
      activeTab = (itemIndex + (delta < 0 ? tabCount : 0) + n * delta) % tabCount;
      if (!this.isDisabledOrHiddenTab(activeTab)) {
        break;
      }
    }
    return activeTab;
  }
  activateAvailableTab(item, delta = 1) {
    this.activeTab = this.findAvailableTab(item, delta);
  }
  changeActiveTab(activeTab, oldActiveTab) {
    const me = this, {
      tabBar,
      layout
    } = me, {
      tabCount
    } = tabBar;
    if (activeTab.isWidget || ObjectHelper.isObject(activeTab)) {
      if (me.items.indexOf(activeTab) === -1) {
        activeTab = me.add(activeTab);
      }
      activeTab = tabBar.indexOfTab(activeTab.tab);
    } else {
      activeTab = parseInt(activeTab, 10);
    }
    if (!me.initialItems && tabCount > 0 && (activeTab < -1 || activeTab >= tabCount)) {
      throw new Error(`Invalid activeTab ${activeTab} (${tabCount} tabs)`);
    }
    if (me.isDisabledOrHiddenTab(activeTab)) {
      activeTab = me.findAvailableTab(activeTab);
    }
    if (layout.animateCardChange && layout.cardChangeAnimation) {
      layout.cardChangeAnimation.then((cardChange) => {
        if ((cardChange === null || cardChange === void 0 ? void 0 : cardChange.activeIndex) !== activeTab) {
          me._activeTab = activeTab;
          me.updateActiveTab(activeTab, oldActiveTab);
        }
      });
    } else {
      return activeTab;
    }
  }
  async updateActiveTab() {
    if (!this.initialItems) {
      const {
        activeTabItemIndex,
        layout
      } = this;
      if (activeTabItemIndex > -1) {
        var _layout$setActiveItem;
        if (layout.animateCardChange) {
          await this.tabSelectionPromise;
        }
        this.tabSelectionPromise = (_layout$setActiveItem = layout.setActiveItem(this.items[activeTabItemIndex])) === null || _layout$setActiveItem === void 0 ? void 0 : _layout$setActiveItem.promise;
      }
    }
  }
  changeTabBar(bar) {
    this.getConfig("strips");
    this.strips = {
      tabBar: bar
    };
    return this.strips.tabBar;
  }
  makeTabConfig(item) {
    const {
      tab
    } = item, config = {
      item,
      type: "tab",
      tabPanel: this,
      disabled: Boolean(item.disabled),
      hidden: item.initialConfig.hidden,
      weight: item.weight || 0,
      internalListeners: {
        click: "onTabClick",
        thisObj: this
      },
      localizableProperties: {
        text: false
      }
    };
    if (tab === false) {
      return null;
    }
    return ObjectHelper.isObject(tab) ? Tab.mergeConfigs(config, tab) : config;
  }
  updateItems(items2, was) {
    const me = this, {
      activeTab,
      initialItems
    } = me;
    let index = 0, tabs;
    super.updateItems(items2, was);
    if (initialItems) {
      tabs = Array.from(items2, (it) => me.makeTabConfig(it)).filter((it) => {
        if (it) {
          it.index = index++;
          return true;
        }
      });
      if (index) {
        tabs[0].isFirst = true;
        tabs[index - 1].isLast = true;
        tabs[activeTab].active = true;
        me.tabBar.add(tabs);
        me.activeTab = activeTab;
      }
    }
  }
  updateTabMinWidth(tabMinWidth) {
    var _this$tabBar;
    (_this$tabBar = this.tabBar) === null || _this$tabBar === void 0 ? void 0 : _this$tabBar.items.forEach((tab) => {
      if (tab.isTab) {
        tab.minWidth = tabMinWidth;
      }
    });
  }
  updateTabMaxWidth(tabMaxWidth) {
    var _this$tabBar2;
    (_this$tabBar2 = this.tabBar) === null || _this$tabBar2 === void 0 ? void 0 : _this$tabBar2.items.forEach((tab) => {
      if (tab.isTab) {
        tab.maxWidth = tabMaxWidth;
      }
    });
  }
  updateAutoHeight(autoHeight) {
    this.detachListeners("themeAutoHeight");
    autoHeight && GlobalEvents$1.ion({
      name: "themeAutoHeight",
      theme: "internalOnThemeChange",
      thisObj: this
    });
    this.$measureHeight = autoHeight;
  }
  applyAutoHeight() {
    const me = this, {
      layout,
      activeTab,
      element
    } = me, {
      animateCardChange
    } = layout;
    layout.animateCardChange = false;
    me.height = null;
    me.height = Math.max(...me.items.map((tab) => {
      me.activeTab = tab;
      return element.clientHeight;
    })) + 1;
    me.activeTab = activeTab;
    layout.animateCardChange = animateCardChange;
    me.$measureHeight = false;
  }
  internalOnThemeChange() {
    if (this.isVisible) {
      this.applyAutoHeight();
    } else {
      this.$measureHeight = true;
    }
  }
  onBeginActiveItemChange(activeItemChangeEvent) {
    const tabs = this.tabBar.tabs, {
      activeItem,
      prevActiveItem
    } = activeItemChangeEvent;
    this.activeTab = tabs.indexOf(activeItem === null || activeItem === void 0 ? void 0 : activeItem.tab);
    if (prevActiveItem !== null && prevActiveItem !== void 0 && prevActiveItem.tab) {
      prevActiveItem.tab.active = false;
    }
    if (activeItem !== null && activeItem !== void 0 && activeItem.tab) {
      activeItem.tab.active = true;
      activeItem.tab.show();
    }
  }
  onBeforeActiveItemChange(activeItemChangeEvent) {
    return this.trigger("beforeTabChange", activeItemChangeEvent);
  }
  onActiveItemChange(activeItemChangeEvent) {
    this.trigger("tabChange", activeItemChangeEvent);
  }
  onTabClick(event) {
    this.activeTab = event.source.item;
  }
  onPaint() {
    super.onPaint(...arguments);
    if (this.$measureHeight) {
      this.applyAutoHeight();
    }
  }
};
TabPanel.initClass();
TabPanel._$name = "TabPanel";
var TextAreaField = class extends Field {
  static get $name() {
    return "TextAreaField";
  }
  static get type() {
    return "textareafield";
  }
  static get alias() {
    return "textarea";
  }
  static get configurable() {
    return {
      resize: "none",
      inputAttributes: {
        tag: "textarea"
      }
    };
  }
  updateResize(resize) {
    this.input.style.resize = resize;
  }
};
TextAreaField.initClass();
TextAreaField._$name = "TextAreaField";
var TextAreaPickerField = class extends PickerField {
  static get $name() {
    return "TextAreaPickerField";
  }
  static get type() {
    return "textareapickerfield";
  }
  static get configurable() {
    return {
      picker: {
        type: "widget",
        tag: "textarea",
        cls: "b-textareapickerfield-picker",
        scrollAction: "realign",
        align: {
          align: "t-b",
          axisLock: true
        },
        autoShow: false
      },
      triggers: {
        expand: {
          cls: "b-icon-picker",
          handler: "onTriggerClick"
        }
      },
      resize: "none",
      inputType: null
    };
  }
  startConfigure(config) {
    if (typeof config.inline === "boolean") {
      VersionHelper.deprecate("Core", "6.0.0", "TextAreaPickerField.inline config is no longer supported");
    }
    super.startConfigure(config);
  }
  get inputElement() {
    const result = super.inputElement;
    result.readOnly = "readonly";
    result.reference = "displayElement";
    this.ariaElement = "displayElement";
    return result;
  }
  get focusElement() {
    var _this$_picker;
    return (_this$_picker = this._picker) !== null && _this$_picker !== void 0 && _this$_picker.isVisible ? this.input : this.displayElement;
  }
  get needsInputSync() {
    var _this$inputValue;
    return this.displayElement[this.inputValueAttr] !== String((_this$inputValue = this.inputValue) !== null && _this$inputValue !== void 0 ? _this$inputValue : "");
  }
  showPicker() {
    const me = this, {
      picker
    } = me;
    if (!me.inline) {
      picker.width = me.pickerWidth || me[me.pickerAlignElement].offsetWidth;
      super.showPicker(true);
    }
  }
  focusPicker() {
    this.input.focus();
  }
  onPickerKeyDown(keyEvent) {
    const me = this, realInput = me.input;
    switch (keyEvent.key.trim() || keyEvent.code) {
      case "Escape":
        me.picker.hide();
        return;
      case "Enter":
        if (keyEvent.ctrlKey) {
          me.syncInputFieldValue();
          me.picker.hide();
        }
        break;
    }
    me.input = me.displayElement;
    const result = super.onPickerKeyDown(keyEvent);
    me.input = realInput;
    return result;
  }
  syncInputFieldValue(skipHighlight) {
    if (this.displayElement) {
      this.displayElement.value = this.inputValue;
    }
    super.syncInputFieldValue(skipHighlight);
  }
  changeValue(value) {
    return value == null ? "" : value;
  }
  changePicker(picker, oldPicker) {
    var _picker, _me$value;
    const me = this, pickerWidth = me.pickerWidth || ((_picker = picker) === null || _picker === void 0 ? void 0 : _picker.width);
    picker = TextAreaPickerField.reconfigure(oldPicker, picker ? Objects.merge({
      owner: me,
      forElement: me[me.pickerAlignElement],
      align: {
        matchSize: pickerWidth == null,
        anchor: me.overlayAnchor,
        target: me[me.pickerAlignElement]
      },
      id: me.id + "-input",
      style: {
        resize: me.resize
      },
      html: (_me$value = me.value) !== null && _me$value !== void 0 ? _me$value : ""
    }, picker) : null, me);
    if (picker) {
      const input = me.input = picker.element;
      me.inputListenerRemover = EventHelper.on({
        element: input,
        thisObj: me,
        focus: "internalOnInputFocus",
        change: "internalOnChange",
        input: "internalOnInput",
        keydown: "internalOnKeyEvent",
        keypress: "internalOnKeyEvent",
        keyup: "internalOnKeyEvent"
      });
    }
    return picker;
  }
};
TextAreaPickerField.initClass();
TextAreaPickerField._$name = "TextAreaPickerField";
var Minifiable = (Target) => {
  var _class;
  return _class = class Minifiable extends (Target || Base) {
    compose() {
      const {
        minified
      } = this;
      return {
        class: {
          "b-minified": minified
        }
      };
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "$name", "Minifiable"), _defineProperty(_class, "configurable", {
    minifiable: true,
    minified: null
  }), _class;
};
var EMPTY = [];
var isStateName = (name) => name[0] !== "*";
var pop = (object, key) => {
  const ret = object[key] || null;
  delete object[key];
  return ret;
};
var responsiveRootFn = (widget) => widget.responsiveRoot;
var scoring = {
  number: (threshold) => ({
    width
  }) => width <= threshold && threshold
};
var splitConfigs = (configs) => {
  delete configs.once;
  return {
    callback: pop(configs, "callback"),
    configs,
    when: pop(configs, "when")
  };
};
var splitMergedConfigs = (cls, ...parts) => {
  const once = parts.flatMap((p) => (p === null || p === void 0 ? void 0 : p.once) || EMPTY), configs = cls.mergeConfigs(...parts), ret = splitConfigs(configs);
  ret.once = once.length ? splitConfigs(cls.mergeConfigs(...once)) : null;
  return ret;
};
var wrapWidget = (widget, handler) => {
  let triggers, desc = Proxy.revocable(widget, {
    get(o, name) {
      if (triggers) {
        triggers[name] = true;
      }
      return widget[name];
    }
  }), detacher2 = FunctionHelper.after(widget, "onConfigChange", (ignore, {
    name
  }) => {
    var _triggers;
    if ((_triggers = triggers) !== null && _triggers !== void 0 && _triggers[name]) {
      handler();
    }
  }), resizer = widget.ion({
    resize: () => {
      handler();
    }
  });
  widget.monitorResize = true;
  return {
    widget,
    get object() {
      var _desc;
      return (_desc = desc) === null || _desc === void 0 ? void 0 : _desc.proxy;
    },
    destroy() {
      if (desc) {
        desc.revoke();
        detacher2();
        resizer();
        desc = detacher2 = resizer = null;
      }
    },
    reset() {
      triggers = /* @__PURE__ */ Object.create(null);
    }
  };
};
var Responsive = (Target) => {
  var _class;
  return _class = class Responsive extends (Target || Base).mixin(Delayable, Fencible) {
    get isResponsivePending() {
      return this.responsiveUpdateCount === 0 && this.hasConfig("responsive");
    }
    get isResponsiveUpdating() {
      var _this$responsiveWidge;
      return this._responsiveUpdating || ((_this$responsiveWidge = this.responsiveWidget) === null || _this$responsiveWidge === void 0 ? void 0 : _this$responsiveWidge._responsiveUpdating);
    }
    updateResponsive(responsive) {
      const me = this, cls = me.constructor, {
        responsiveDefaults
      } = me, stateNames = Array.from(new Set(ObjectHelper.keys(responsive).concat(ObjectHelper.keys(responsiveDefaults)))).filter(isStateName);
      let states = null, hasWhen, name, state, when;
      if (responsive) {
        states = {
          "*": splitMergedConfigs(cls, responsiveDefaults["*"], responsive["*"])
        };
        for (name of stateNames) {
          state = responsive[name];
          if (state !== null && state !== false) {
            var _scoring$when;
            hasWhen = hasWhen || state && "when" in state;
            states[name] = splitMergedConfigs(cls, responsiveDefaults["*"], responsiveDefaults[name], responsive["*"], state);
            when = states[name].when;
            states[name].when = ((_scoring$when = scoring[typeof when]) === null || _scoring$when === void 0 ? void 0 : _scoring$when.call(scoring, when)) || when;
          }
        }
      }
      me.$responsiveStates = states;
      me.$responsiveWhen = hasWhen;
      me.syncResponsiveWidget();
    }
    updateResponsiveState(state, oldState) {
      var _me$element;
      const me = this, {
        $responsiveStates: states
      } = me, initial = ++me.responsiveStateChanges === 1, classList = (_me$element = me.element) === null || _me$element === void 0 ? void 0 : _me$element.classList, defaults = states["*"], def = states[state] || defaults, once = initial && (def.once || defaults.once), isStateful = initial && me.isStateful, target = me.responsiveWidget;
      let config = def.configs, otherConfigs = once === null || once === void 0 ? void 0 : once.configs;
      if (otherConfigs) {
        config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;
      }
      oldState && (classList === null || classList === void 0 ? void 0 : classList.remove(`b-responsive-${oldState.toLowerCase()}`));
      state && (classList === null || classList === void 0 ? void 0 : classList.add(`b-responsive-${state.toLowerCase()}`));
      if (isStateful) {
        otherConfigs = me.loadStatefulData();
        if (otherConfigs) {
          config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;
        }
        me.suspendStateful();
      }
      me._responsiveUpdating = true;
      try {
        var _me$trigger, _def$callback, _once$callback, _me$trigger2;
        (_me$trigger = me.trigger) === null || _me$trigger === void 0 ? void 0 : _me$trigger.call(me, "beforeResponsiveStateChange", {
          state,
          oldState,
          target
        });
        config && me.setConfig(config);
        (_def$callback = def.callback) === null || _def$callback === void 0 ? void 0 : _def$callback.call(def, {
          source: me,
          state,
          oldState,
          target,
          initial
        });
        once === null || once === void 0 ? void 0 : (_once$callback = once.callback) === null || _once$callback === void 0 ? void 0 : _once$callback.call(once, {
          source: me,
          state,
          oldState,
          target,
          initial
        });
        (_me$trigger2 = me.trigger) === null || _me$trigger2 === void 0 ? void 0 : _me$trigger2.call(me, "responsiveStateChange", {
          state,
          oldState,
          target
        });
      } finally {
        me._responsiveUpdating = false;
        isStateful && me.resumeStateful();
      }
    }
    get responsiveTarget() {
      return this.responsiveWidget || this._responsiveTarget;
    }
    updateResponsiveTarget() {
      this.syncResponsiveWidget();
    }
    updateResponsiveWidget(target) {
      var _me$$responsiveWrappe;
      const me = this, responsiveUpdate = target && me.responsiveUpdate;
      (_me$$responsiveWrappe = me.$responsiveWrapper) === null || _me$$responsiveWrappe === void 0 ? void 0 : _me$$responsiveWrappe.destroy();
      me.$responsiveWrapper = target && wrapWidget(target, responsiveUpdate);
      responsiveUpdate === null || responsiveUpdate === void 0 ? void 0 : responsiveUpdate.now();
    }
    responsiveUpdate() {
      const me = this, {
        $responsiveStates: states,
        $responsiveWrapper: wrapper
      } = me, responsiveTarget = wrapper === null || wrapper === void 0 ? void 0 : wrapper.widget;
      if (states && wrapper) {
        let best = null, bestScore = 0, fromWhen = states, score, state;
        if (responsiveTarget && responsiveTarget !== me && !me.$responsiveWhen) {
          responsiveTarget.getConfig("responsive");
          fromWhen = responsiveTarget.$responsiveStates || fromWhen;
        }
        wrapper.reset();
        for (state in states) {
          if (state !== "*") {
            score = fromWhen[state].when(wrapper.object, BrowserHelper);
            if (score != null && score !== false && (!best || score < bestScore)) {
              best = state;
              bestScore = score;
            }
          }
        }
        ++me.responsiveUpdateCount;
        me.responsiveState = best;
      }
    }
    syncResponsiveWidget() {
      const me = this;
      let widget = null, responsiveTarget;
      if (!me.isDestroying && me.responsive) {
        responsiveTarget = me.responsiveTarget;
        if (!(widget = responsiveTarget)) {
          var _me$up;
          widget = !me.responsiveRoot && ((_me$up = me.up) === null || _me$up === void 0 ? void 0 : _me$up.call(me, responsiveRootFn)) || me;
        } else if (typeof responsiveTarget === "string") {
          widget = responsiveTarget === "@" ? me : responsiveTarget[0] === "@" ? me[responsiveTarget.substring(1)] : me.up(responsiveTarget);
          if (!widget) {
            throw new Error(`No match for responsiveTarget="${responsiveTarget}"`);
          }
        }
        if (!widget.isWidget) {
          throw new Error(`${widget.constructor.$$name} is not a widget and cannot be a responsiveTarget`);
        }
      }
      me.responsiveWidget = widget;
      return widget;
    }
    changeBreakpoints(breakpoints) {
      ObjectHelper.assertObject(breakpoints, "breakpoints");
      if (breakpoints !== null && breakpoints !== void 0 && breakpoints.width) {
        Object.keys(breakpoints.width).forEach((key) => {
          breakpoints.width[key].maxWidth = key;
        });
      }
      if (breakpoints !== null && breakpoints !== void 0 && breakpoints.height) {
        Object.keys(breakpoints.height).forEach((key) => {
          breakpoints.height[key].maxHeight = key;
        });
      }
      return breakpoints;
    }
    updateBreakpoints(breakpoints) {
      if (breakpoints) {
        this.monitorResize = true;
      }
    }
    getBreakpoint(levels, dimension) {
      const ascendingLevels = Object.keys(levels).map((l) => parseInt(l)).sort(), breakpoint = ascendingLevels.find((bp) => dimension <= bp);
      return levels[breakpoint !== null && breakpoint !== void 0 ? breakpoint : levels["*"] && "*"];
    }
    activateBreakpoint(orientation, breakpoint) {
      const me = this, prevBreakpoint = me[`current${orientation}Breakpoint`];
      if (breakpoint !== prevBreakpoint) {
        var _breakpoint$callback, _me$recompose;
        me[`current${orientation}Breakpoint`] = breakpoint;
        me.setConfig(breakpoint.configs);
        prevBreakpoint && me.element.classList.remove(`b-breakpoint-${prevBreakpoint.name.toLowerCase()}`);
        me.element.classList.add(`b-breakpoint-${breakpoint.name.toLowerCase()}`);
        me.trigger(`responsive${orientation}Change`, {
          breakpoint,
          prevBreakpoint
        });
        (_breakpoint$callback = breakpoint.callback) === null || _breakpoint$callback === void 0 ? void 0 : _breakpoint$callback.call(breakpoint, {
          source: me,
          breakpoint,
          prevBreakpoint
        });
        (_me$recompose = me.recompose) === null || _me$recompose === void 0 ? void 0 : _me$recompose.call(me);
      }
    }
    applyResponsiveBreakpoints(width, height) {
      var _me$breakpoints;
      const me = this, {
        width: widths,
        height: heights
      } = (_me$breakpoints = me.breakpoints) !== null && _me$breakpoints !== void 0 ? _me$breakpoints : {};
      if (widths) {
        const breakpoint = me.getBreakpoint(widths, width);
        me.activateBreakpoint("Width", breakpoint);
      }
      if (heights) {
        const breakpoint = me.getBreakpoint(heights, height);
        me.activateBreakpoint("Height", breakpoint);
      }
    }
    onInternalResize(element, width, height, oldWidth, oldHeight) {
      super.onInternalResize(element, width, height, oldWidth, oldHeight);
      this.applyResponsiveBreakpoints(width, height);
    }
  }, _defineProperty(_class, "$name", "Responsive"), _defineProperty(_class, "configurable", {
    responsive: {
      $config: {
        lazy: "paint"
      },
      value: null
    },
    responsiveDefaults: {
      small: {
        when: 400
      },
      medium: {
        when: 800
      },
      large: {
        when: () => Infinity
      },
      "*": {}
    },
    responsiveRoot: null,
    responsiveState: null,
    responsiveTarget: {
      value: null,
      $config: {
        lazy: "paint"
      }
    },
    responsiveWidget: {
      value: null,
      $config: {
        nullify: true
      }
    },
    breakpoints: null
  }), _defineProperty(_class, "delayable", {
    responsiveUpdate: "raf"
  }), _defineProperty(_class, "fenced", {
    syncResponsiveWidget: true
  }), _defineProperty(_class, "prototypeProperties", {
    responsiveStateChanges: 0,
    responsiveUpdateCount: 0
  }), _class;
};
var Styleable = (Target) => {
  var _class;
  return _class = class Styleable extends (Target || Base) {
    changeCssVarPrefix(prefix) {
      ObjectHelper.assertString(prefix, "prefix");
      if (prefix && !prefix.endsWith("-")) {
        prefix = prefix + "-";
      }
      return prefix || "";
    }
    changeCss(css) {
      ObjectHelper.assertObject(css, "css");
      const me = this;
      if (!globalThis.Proxy) {
        throw new Error("Proxy not supported");
      }
      const proxy = new Proxy({}, {
        get(target, property) {
          var _styles$getPropertyVa;
          const styles = getComputedStyle(me.element || document.documentElement);
          return (_styles$getPropertyVa = styles.getPropertyValue(`--${me.cssVarPrefix}${StringHelper.hyphenate(property)}`)) === null || _styles$getPropertyVa === void 0 ? void 0 : _styles$getPropertyVa.trim();
        },
        set(target, property, value) {
          const element = me.element || document.documentElement;
          element.style.setProperty(`--${me.cssVarPrefix}${StringHelper.hyphenate(property)}`, value);
          return true;
        }
      });
      if (css) {
        if (me._element) {
          ObjectHelper.assign(proxy, css);
        } else {
          me.$initialCSS = css;
        }
      }
      return proxy;
    }
    updateElement(element, ...args) {
      super.updateElement(element, ...args);
      if (this.$initialCSS) {
        ObjectHelper.assign(this.css, this.$initialCSS);
      }
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "$name", "Styleable"), _defineProperty(_class, "configurable", {
    cssVarPrefix: "",
    css: {}
  }), _class;
};
var ns$1 = "http://www.w3.org/2000/svg";
var typePrio = {
  bar: 1,
  outline: 2,
  text: 3
};
var byDatasetOrder = (l, r) => parseInt(l.dataset.order, 10) - parseInt(r.dataset.order, 10);
var getField = (s) => s.field;
var returnFalse = () => false;
var Histogram = class extends Widget {
  static get type() {
    return "histogram";
  }
  static get $name() {
    return "Histogram";
  }
  static get defaultConfig() {
    return {
      data: null,
      values: null,
      series: null,
      topValue: null,
      element: {
        children: [{
          ns: ns$1,
          tag: "svg",
          reference: "svgElement",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "none",
          children: [{
            ns: ns$1,
            tag: "g",
            reference: "scaledSvgGroup"
          }, {
            ns: ns$1,
            tag: "g",
            reference: "unscaledSvgGroup"
          }]
        }]
      },
      omitZeroHeightBars: null,
      monitorResize: true,
      getRectClass: null,
      getBarTip: null,
      getBarText: null,
      getBarTextRenderData: null,
      getBarTextTip: null
    };
  }
  construct(config) {
    super.construct(config);
    this.scheduleRefresh = this.createOnFrame(this.refresh, [], this, true);
    this.refresh();
  }
  set tip(tip) {
    var _me$tip;
    const me = this;
    (_me$tip = me.tip) === null || _me$tip === void 0 ? void 0 : _me$tip.destroy();
    if (tip) {
      me._tip = Tooltip.new({
        owner: me,
        forElement: me.svgElement,
        forSelector: "rect",
        internalListeners: {
          beforeShow: "up.onBeforeTipShow"
        }
      }, tip);
    } else {
      me._tip = null;
    }
  }
  onElementResize() {
    super.onElementResize(...arguments);
    const svgRect = this.svgElement.getBoundingClientRect();
    this.scaledSvgGroup.setAttribute("transform", `scale(${svgRect.width} ${svgRect.height})`);
  }
  onBeforeTipShow({
    source: tip
  }) {
    const index = parseInt(tip.activeTarget.dataset.index);
    tip.html = tip.contentTemplate({
      histogram: this,
      index
    });
  }
  set series(value) {
    const me = this, series = me._series = {};
    for (const id in value) {
      if (value[id] !== false) {
        const data = series[id] = Object.assign({}, value[id]);
        if (!data.type && value[id].type) {
          data.type = value[id].type;
        }
        if (!data.field && value[id].field) {
          data.field = value[id].field;
        }
        if (!("order" in series)) {
          data.order = typePrio[data.type];
        }
        data.id = id;
      }
    }
    me.scheduleRefresh();
  }
  get series() {
    return this._series;
  }
  set data(data) {
    const me = this;
    me._data = data;
    if (!me.topValue) {
      const fields = Object.values(me.series).map(getField);
      for (let i = 0, {
        length
      } = data; i < length; i++) {
        for (let j = 0, {
          length: length2
        } = fields; j < length2; j++) {
          me.topValue = Math.max(me.topValue || 0, data[i][fields[j]]);
        }
      }
    }
    me.scheduleRefresh();
  }
  get data() {
    return this._data;
  }
  set topValue(value) {
    this._topValue = value;
    this.scheduleRefresh();
  }
  get topValue() {
    return this._topValue;
  }
  scheduleRefresh() {
  }
  refresh() {
    const me = this, {
      series,
      _tip
    } = me, histogramElements = [];
    for (const id in series) {
      const data = series[id], elConfig = me[`draw${StringHelper.capitalize(data.type)}`](data);
      if (Array.isArray(elConfig)) {
        histogramElements.push.apply(histogramElements, elConfig);
      } else {
        histogramElements.push(elConfig);
      }
    }
    histogramElements.sort(byDatasetOrder);
    DomSync.syncChildren({
      domConfig: {
        children: histogramElements
      },
      configEquality: returnFalse
    }, me.scaledSvgGroup);
    DomSync.syncChildren({
      domConfig: {
        children: me.drawText()
      }
    }, me.unscaledSvgGroup);
    if (_tip && _tip.isVisible) {
      me.onBeforeTipShow({
        source: _tip
      });
    }
  }
  drawBar(series) {
    const me = this, {
      topValue,
      data,
      omitZeroHeightBars,
      barStyle
    } = me, {
      field,
      order
    } = series, defaultWidth = 1 / data.length, children = [];
    let width;
    for (let index = 0, x = 0, {
      length
    } = data; index < length; index++, x += width) {
      const datum = data[index], value = datum[field], height = datum.height || (value > topValue ? topValue : value) / topValue, y = 1 - height, rectConfig = datum.rectConfig = {
        ns: ns$1,
        tag: "rect",
        dataset: {}
      }, barTip = me.callback("getBarTip", me, [series, rectConfig, datum, index]);
      width = datum.width || defaultWidth;
      if (barStyle) {
        rectConfig.style = barStyle;
      } else {
        delete rectConfig.style;
      }
      Object.assign(rectConfig.dataset, {
        index,
        order
      });
      Object.assign(rectConfig, {
        x,
        y,
        width,
        height,
        class: me.callback("getRectClass", me, [series, rectConfig, datum, index])
      });
      if (barTip) {
        rectConfig.dataset.btip = barTip;
      } else {
        delete rectConfig.dataset.btip;
      }
      if (height || !omitZeroHeightBars) {
        children.push(rectConfig);
      }
    }
    return children;
  }
  drawOutline(series) {
    const me = this, {
      topValue,
      data
    } = me, {
      field,
      order
    } = series, defaultWidth = 1 / data.length, coords = ["M 0,1"], result = series.outlineElement || (series.outlineElement = {
      ns: ns$1,
      tag: "path",
      dataset: {
        order
      }
    });
    let barWidth, command1 = "M", command2 = "L";
    for (let i = 0, x = 0, {
      length
    } = data; i < length; i++) {
      const barHeight = 1 - data[i][field] / topValue;
      barWidth = data[i].width || defaultWidth;
      coords.push(`${command1} ${x},${barHeight} ${command2} ${x += barWidth},${barHeight}`);
      command1 = command2 = "";
    }
    result.d = coords.join(" ");
    return result;
  }
  drawText() {
    const me = this, {
      data
    } = me, defaultWidth = 1 / data.length, defaultY = "100%", unscaledSvgGroups = [];
    for (let index = 0, width, x = 0, {
      length
    } = data; index < length; index++, x += width) {
      width = data[index].width || defaultWidth;
      const barText = me.callback("getBarText", me, [data[index], index]);
      if (barText) {
        const renderData = me.callback("getBarTextRenderData", me, [{
          ns: ns$1,
          tag: "text",
          className: "b-bar-legend",
          html: barText,
          x: `${(x + width / 2) * 100}%`,
          y: data[index].y !== void 0 ? data[index].y : defaultY,
          dataset: {
            index
          }
        }, data[index], index]);
        const barTip = me.callback("getBarTextTip", me, [renderData, data[index], index]);
        if (barTip) {
          renderData.dataset.btip = barTip;
        } else {
          delete renderData.dataset.btip;
        }
        unscaledSvgGroups.push(renderData);
      }
    }
    return unscaledSvgGroups;
  }
  getBarText(datum, index) {
    return "";
  }
  getBarTextRenderData(renderData, datum, index) {
    return renderData;
  }
  getBarTip(series, rectConfig, datum, index) {
  }
  getBarTextTip(renderData, datum, index) {
  }
  getRectClass(series, rectConfig, datum, index) {
    return "";
  }
};
Histogram.initClass();
Histogram._$name = "Histogram";
var ns = "http://www.w3.org/2000/svg";
var Scale = class extends Widget {
  static get type() {
    return "scale";
  }
  static get $name() {
    return "Scale";
  }
  static get configurable() {
    return {
      scalePoints: null,
      scaleMaxPadding: 0.1,
      horizontal: false,
      align: {
        value: false,
        $config: {
          merge: "replace"
        }
      },
      element: {
        children: [{
          ns,
          tag: "svg",
          reference: "svgElement",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "none",
          children: [{
            ns,
            tag: "g",
            reference: "scaledSvgGroup",
            children: [{
              ns,
              tag: "path",
              reference: "pathElement"
            }]
          }, {
            ns,
            tag: "g",
            reference: "unscaledSvgGroup"
          }]
        }]
      },
      monitorResize: true
    };
  }
  construct(config) {
    super.construct(config);
    this.scheduleRefresh = this.createOnFrame(this.refresh, [], this, true);
    this.refresh();
  }
  changeAlign(align) {
    if (!align) {
      align = this.horizontal ? "bottom" : "right";
    }
    return align;
  }
  updateAlign(align, oldAlign) {
    this.element.classList.remove(`b-align-${oldAlign}`);
    this.element.classList.add(`b-align-${align}`);
  }
  updateHorizontal(horizontal, oldHorizontal) {
    this.element.classList.remove(`b-scale-${oldHorizontal ? "horizontal" : "vertical"}`);
    this.element.classList.add(`b-scale-${horizontal ? "horizontal" : "vertical"}`);
  }
  onElementResize() {
    super.onElementResize(...arguments);
    this.scheduleRefresh();
  }
  scheduleRefresh() {
  }
  refresh() {
    const me = this, {
      horizontal,
      width,
      height,
      align,
      scalePoints,
      scaleMaxPadding
    } = me, scaleMax = scalePoints[scalePoints.length - 1].value, path = [], labels = [];
    const posFactor = 1 / (scaleMax + scaleMaxPadding * scaleMax);
    me.scaledSvgGroup.setAttribute("transform", `scale(${horizontal ? width : 1} ${horizontal ? 1 : height})`);
    for (const point of scalePoints) {
      const isLabelStep = Boolean(point.text), pos = posFactor * point.value;
      if (isLabelStep) {
        const label = {
          ns,
          tag: "text",
          className: "b-scale-tick-label",
          html: point.text,
          dataset: {
            tick: point.value
          }
        };
        if (horizontal) {
          label.x = `${pos * 100}%`;
          label.y = align === "top" ? "1.6em" : height - 12;
        } else {
          label.x = align === "left" ? "12" : `${width - 12}`;
          label.y = `${(1 - pos) * 100}%`;
        }
        labels.push(label);
      }
      if (horizontal) {
        if (align === "top") {
          path.push(`M${pos},0 L${pos},${isLabelStep ? 10 : 5}`);
        } else {
          path.push(`M${pos},${height} L${pos},${height - (isLabelStep ? 10 : 5)}`);
        }
      } else {
        if (align === "left") {
          path.push(`M0,${1 - pos} L${isLabelStep ? 10 : 5},${1 - pos}`);
        } else {
          path.push(`M${width},${1 - pos} L${width - (isLabelStep ? 10 : 5)},${1 - pos}`);
        }
      }
    }
    me.pathElement.setAttribute("d", path.join(""));
    DomSync.syncChildren({
      domConfig: {
        children: labels
      }
    }, me.unscaledSvgGroup);
  }
};
Scale.initClass();
Scale._$name = "Scale";
var AvatarRendering = class extends Base {
  static get $name() {
    return "AvatarRendering";
  }
  static get configurable() {
    return {
      element: null,
      colorPrefix: "b-sch-",
      tooltip: null,
      size: null
    };
  }
  doDestroy() {
    var _this$tooltip;
    (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.destroy();
    super.doDestroy();
  }
  updateElement(element) {
    EventHelper.on({
      element,
      delegate: ".b-resource-image",
      error: "onImageErrorEvent",
      thisObj: this,
      capture: true
    });
  }
  changeTooltip(config) {
    return Tooltip.new({
      forElement: this.element,
      forSelector: ".b-resource-avatar",
      cls: "b-resource-avatar-tooltip"
    }, config);
  }
  static get failedUrls() {
    if (!this._failedUrls) {
      this._failedUrls = /* @__PURE__ */ new Set();
    }
    return this._failedUrls;
  }
  getResourceAvatar({
    initials,
    color,
    iconCls,
    imageUrl,
    defaultImageUrl,
    dataset = {},
    resourceRecord,
    alt: alt2 = StringHelper.encodeHtml(resourceRecord === null || resourceRecord === void 0 ? void 0 : resourceRecord.name)
  }) {
    return this.getImageConfig(initials, color, imageUrl, defaultImageUrl, dataset, alt2) || this.getIconConfig(iconCls, dataset) || this.getResourceInitialsConfig(initials, color, dataset);
  }
  getImageConfig(initials, color, imageUrl, defaultImageUrl, dataset, alt2) {
    const {
      size
    } = this;
    imageUrl = AvatarRendering.failedUrls.has(imageUrl) ? defaultImageUrl : imageUrl || defaultImageUrl;
    if (imageUrl) {
      return _objectSpread2(_objectSpread2({
        tag: "img",
        draggable: "false",
        loading: "lazy",
        class: {
          "b-resource-avatar": 1,
          "b-resource-image": 1
        }
      }, size ? {
        style: {
          height: size + "px",
          width: size + "px"
        }
      } : void 0), {}, {
        alt: alt2,
        elementData: {
          defaultImageUrl,
          imageUrl,
          initials,
          color,
          dataset
        },
        src: imageUrl,
        dataset
      });
    }
  }
  getIconConfig(iconCls, dataset) {
    if (iconCls) {
      return iconCls && {
        tag: "i",
        class: {
          "b-resource-avatar": 1,
          "b-resource-icon": 1,
          [iconCls]: 1
        },
        dataset
      };
    }
  }
  getResourceInitialsConfig(initials, color, dataset) {
    const {
      size
    } = this, namedColor = DomHelper.isNamedColor(color) && color, hexColor = !namedColor && color;
    return {
      tag: "div",
      class: {
        "b-resource-avatar": 1,
        "b-resource-initials": 1,
        [`${this.colorPrefix}${namedColor}`]: namedColor
      },
      style: _objectSpread2({
        backgroundColor: hexColor || null
      }, size ? {
        height: size + "px",
        width: size + "px"
      } : void 0),
      children: [initials],
      dataset
    };
  }
  onImageErrorEvent({
    target
  }) {
    if (!target.matches(".b-resource-avatar")) {
      return;
    }
    const {
      defaultImageUrl,
      initials,
      color,
      imageUrl,
      dataset
    } = target.elementData;
    if (defaultImageUrl && !target.src.endsWith(defaultImageUrl.replace(/^[./]*/gm, ""))) {
      target.src = defaultImageUrl;
    } else {
      const initialsEl = DomHelper.createElement(this.getResourceInitialsConfig(initials, color, dataset));
      initialsEl.elementData = target.elementData;
      target.parentElement.replaceChild(initialsEl, target);
    }
    AvatarRendering.failedUrls.add(imageUrl);
  }
};
AvatarRendering._$name = "AvatarRendering";
if (window && !window.bryntum) {
  window.bryntum = {};
}
var Location = class {
  constructor(location) {
    if (location) {
      if (location.isLocation) {
        return location;
      }
      if (location.nodeType === Node.ELEMENT_NODE) {
        const grid = Widget.fromElement(location, "gridbase"), cell = grid && location.closest(grid.focusableSelector);
        if (cell) {
          const {
            dataset
          } = cell.parentNode;
          this.init({
            grid,
            rowIndex: grid.store.includes(dataset.id) ? grid.store.indexOf(dataset.id) : dataset.index || -1,
            columnId: cell.dataset.columnId
          });
          this.initialTarget = location;
        }
      } else {
        this.init(location);
      }
    }
  }
  init(config) {
    var _me$record;
    const me = this;
    const grid = me.grid = config.grid, {
      store,
      columns
    } = grid, {
      visibleColumns
    } = columns;
    if (config.target) {
      me.actionTargets = [me._target = config.target];
    }
    if (config.record) {
      me._id = config.record.id;
    } else if ("id" in config) {
      me._id = config.id;
      if (config.id == null) {
        me._rowIndex = -1;
      }
    } else {
      var _store$getAt;
      const rowIndex = !isNaN(config.row) ? config.row : !isNaN(config.rowIndex) ? config.rowIndex : NaN;
      me._rowIndex = Math.max(Math.min(Number(rowIndex), store.count - 1), grid.hideHeaders ? 0 : -1);
      me._id = (_store$getAt = store.getAt(me._rowIndex)) === null || _store$getAt === void 0 ? void 0 : _store$getAt.id;
    }
    if (!("_rowIndex" in me)) {
      me._rowIndex = store.indexOf(me.id);
    }
    me.isSpecialRow = (_me$record = me.record) === null || _me$record === void 0 ? void 0 : _me$record.isSpecialRow;
    if ("columnId" in config) {
      me._column = columns.getById(config.columnId);
    } else if ("field" in config) {
      me._column = columns.get(config.field);
    } else {
      const columnIndex = !isNaN(config.column) ? config.column : !isNaN(config.columnIndex) ? config.columnIndex : NaN;
      if (!isNaN(columnIndex)) {
        me._columnIndex = Math.min(Number(columnIndex), visibleColumns.length - 1);
        me._column = visibleColumns[me._columnIndex];
      } else {
        me._column = "column" in config ? isNaN(config.column) ? config.column : visibleColumns[config.column] : visibleColumns[0];
      }
    }
    if (!("_columnIndex" in me)) {
      me._columnIndex = visibleColumns.indexOf(me._column);
    }
  }
  get isLocation() {
    return true;
  }
  equals(other, shallow = false) {
    const me = this;
    return (other === null || other === void 0 ? void 0 : other.isLocation) && other.grid === me.grid && (shallow ? me.id === other.id && me._column === other._column : other.record === me.record && other.column === me.column && other.target === me.target);
  }
  get rowIndex() {
    const {
      _id
    } = this, {
      store
    } = this.grid;
    return store.includes(_id) ? store.indexOf(_id) : Math.min(this._rowIndex, store.count - 1);
  }
  get visibleRowIndex() {
    const {
      rowManager
    } = this.grid, {
      rowIndex
    } = this;
    return rowIndex === -1 ? rowIndex : Math.max(Math.min(rowIndex, rowManager.lastFullyVisibleTow.dataIndex), rowManager.firstFullyVisibleTow.dataIndex);
  }
  get isSelectable() {
    return this.grid.store.includes(this._id) && !this.isSpecialRow;
  }
  get record() {
    if (this._rowIndex > -1) {
      const {
        store
      } = this.grid;
      if (!store.includes(this._id)) {
        return store.getAt(this._rowIndex);
      }
      return store.getById(this._id);
    }
  }
  get id() {
    return this._id;
  }
  get column() {
    const {
      visibleColumns
    } = this.grid.columns;
    if (!(visibleColumns !== null && visibleColumns !== void 0 && visibleColumns.includes(this._column))) {
      return visibleColumns === null || visibleColumns === void 0 ? void 0 : visibleColumns[this.columnIndex];
    }
    return this._column;
  }
  get columnId() {
    var _this$column;
    return (_this$column = this.column) === null || _this$column === void 0 ? void 0 : _this$column.id;
  }
  get columnIndex() {
    var _this$grid$columns$vi;
    return Math.min(this._columnIndex, ((_this$grid$columns$vi = this.grid.columns.visibleColumns) === null || _this$grid$columns$vi === void 0 ? void 0 : _this$grid$columns$vi.length) - 1);
  }
  move(where) {
    const me = this, {
      record,
      column,
      grid
    } = me, {
      store
    } = grid, columns = grid.columns.visibleColumns, result = new Location();
    let rowIndex = store.includes(record) ? store.indexOf(record) : me.rowIndex, columnIndex = columns.includes(column) ? columns.indexOf(column) : me.columnIndex;
    const rowMin = grid.hideHeaders ? 0 : -1, rowMax = store.count - 1, colMax = columns.length - 1, atFirstRow = rowIndex === rowMin, atLastRow = rowIndex === rowMax, atFirstColumn = columnIndex === 0, atLastColumn = columnIndex === colMax;
    switch (where) {
      case Location.PREV_CELL:
        if (atFirstColumn) {
          if (!atFirstRow) {
            columnIndex = colMax;
            rowIndex--;
          }
        } else {
          columnIndex--;
        }
        break;
      case Location.NEXT_CELL:
        if (atLastColumn) {
          if (!atLastRow) {
            columnIndex = 0;
            rowIndex++;
          }
        } else {
          columnIndex++;
        }
        break;
      case Location.UP:
        if (!atFirstRow) {
          rowIndex--;
        }
        break;
      case Location.DOWN:
        if (!atLastRow) {
          if (rowIndex === -1) {
            rowIndex = grid.rowManager.firstFullyVisibleRow.dataIndex;
          } else {
            rowIndex++;
          }
        }
        break;
      case Location.FIRST_COLUMN:
        columnIndex = 0;
        break;
      case Location.LAST_COLUMN:
        columnIndex = colMax;
        break;
      case Location.FIRST_CELL:
        rowIndex = rowMin;
        columnIndex = 0;
        break;
      case Location.LAST_CELL:
        rowIndex = rowMax;
        columnIndex = colMax;
        break;
      case Location.PREV_PAGE:
        rowIndex = Math.max(rowMin, rowIndex - Math.floor(grid.scrollable.clientHeight / grid.rowHeight));
        break;
      case Location.NEXT_PAGE:
        rowIndex = Math.min(rowMax, rowIndex + Math.floor(grid.scrollable.clientHeight / grid.rowHeight));
        break;
    }
    result.init({
      grid,
      rowIndex,
      columnIndex
    });
    return result;
  }
  get cell() {
    const me = this, {
      grid,
      id,
      _cell
    } = me;
    if (_cell) {
      return _cell;
    }
    if (id == null) {
      var _grid$columns$getById;
      return (_grid$columns$getById = grid.columns.getById(me.columnId)) === null || _grid$columns$getById === void 0 ? void 0 : _grid$columns$getById.element;
    } else {
      const {
        row
      } = me;
      if (row) {
        var _grid$columns$getAt;
        return row.getCell(me.columnId) || row.getCell((_grid$columns$getAt = grid.columns.getAt(me.columnIndex)) === null || _grid$columns$getAt === void 0 ? void 0 : _grid$columns$getAt.id);
      }
    }
  }
  get row() {
    return this.grid.getRowById(this.id) || this.grid.getRow(this.rowIndex);
  }
  get target() {
    const {
      cell,
      _target
    } = this, {
      focusableFinder
    } = this.grid;
    if (cell) {
      if (_target) {
        return _target;
      }
      focusableFinder.currentNode = this.grid.focusableFinderCell = cell;
      return focusableFinder.nextNode() || cell;
    }
  }
  get isActionable() {
    const {
      cell,
      _target
    } = this, containsFocus = (cell === null || cell === void 0 ? void 0 : cell.compareDocumentPosition(DomHelper.getActiveElement(cell))) & Node.DOCUMENT_POSITION_CONTAINED_BY;
    return Boolean(containsFocus || _target && _target !== this.cell);
  }
  get isColumnHeader() {
    return this.cell && this.rowIndex === -1;
  }
  get isCell() {
    return this.cell && this.record;
  }
};
Location.UP = 1;
Location.NEXT_CELL = 2;
Location.DOWN = 3;
Location.PREV_CELL = 4;
Location.FIRST_COLUMN = 5;
Location.LAST_COLUMN = 6;
Location.FIRST_CELL = 7;
Location.LAST_CELL = 8;
Location.PREV_PAGE = 9;
Location.NEXT_PAGE = 10;
Location._$name = "Location";
var validWidth = (value) => typeof value === "number" || (value === null || value === void 0 ? void 0 : value.endsWith("px"));
var Column = class extends Model.mixin(Events, Localizable) {
  static get $name() {
    return "Column";
  }
  static get type() {
    return "column";
  }
  static get fields() {
    return [
      "type",
      "text",
      "field",
      "renderer",
      "width",
      "flex",
      "autoWidth",
      "autoHeight",
      {
        name: "fitMode",
        defaultValue: "exact"
      },
      {
        name: "editor",
        defaultValue: {}
      },
      "cellEditor",
      "finalizeCellEdit",
      {
        name: "revertOnEscape",
        defaultValue: true
      },
      {
        name: "invalidAction",
        defaultValue: "block"
      },
      {
        name: "sortable",
        defaultValue: true,
        convert(value, column) {
          if (!value) {
            return false;
          }
          if (value === true) {
            return true;
          }
          const sorter = {};
          if (typeof value === "function") {
            sorter.originalSortFn = value;
            sorter.sortFn = value.bind(column);
          } else if (typeof value === "object") {
            Object.assign(sorter, value);
            if (sorter.fn) {
              sorter.sortFn = sorter.fn;
              delete sorter.fn;
            }
          }
          return sorter;
        }
      },
      {
        name: "searchable",
        defaultValue: true
      },
      {
        name: "collapsible",
        defaultValue: false
      },
      {
        name: "collapsed",
        defaultValue: false
      },
      {
        name: "collapseMode"
      },
      {
        name: "filterable",
        defaultValue: true,
        convert(value) {
          if (!value) {
            return false;
          }
          if (value === true) {
            return true;
          }
          const filter = {
            columnOwned: true
          };
          if (typeof value === "function") {
            filter.filterFn = value;
          } else if (typeof value === "object") {
            Object.assign(filter, value);
          }
          return filter;
        }
      },
      {
        name: "sealed"
      },
      {
        name: "hideable",
        defaultValue: true
      },
      {
        name: "draggable",
        defaultValue: true
      },
      {
        name: "groupable",
        defaultValue: true
      },
      {
        name: "resizable",
        defaultValue: true
      },
      "groupRenderer",
      "headerRenderer",
      "tooltip",
      "tooltipRenderer",
      "cellCls",
      "cls",
      "icon",
      "align",
      {
        name: "minWidth",
        defaultValue: 60
      },
      "maxWidth",
      {
        name: "hidden",
        defaultValue: false
      },
      {
        name: "locked"
      },
      {
        name: "region"
      },
      {
        name: "mergeCells",
        type: "boolean"
      },
      {
        name: "mergeable",
        type: "boolean",
        defaultValue: true
      },
      "mergedRenderer",
      {
        name: "showColumnPicker",
        defaultValue: true
      },
      {
        name: "enableHeaderContextMenu",
        defaultValue: true
      },
      {
        name: "enableCellContextMenu",
        defaultValue: true
      },
      "headerMenuItems",
      "cellMenuItems",
      "sum",
      "summaries",
      "summaryRenderer",
      "responsiveLevels",
      "tags",
      "touchConfig",
      "tree",
      "filterType",
      {
        name: "htmlEncode",
        defaultValue: true
      },
      {
        name: "htmlEncodeHeaderText",
        defaultValue: true
      },
      {
        name: "autoSyncHtml",
        defaultValue: false
      },
      {
        name: "alwaysClearCell",
        defaultValue: false
      },
      {
        name: "headerWidgets"
      },
      {
        name: "instantUpdate",
        defaultValue: false
      },
      {
        name: "repaintOnResize",
        defaultValue: false
      },
      "editTargetSelector",
      {
        name: "exportable",
        defaultValue: true
      },
      {
        name: "exportedType"
      },
      {
        name: "ariaLabel",
        defaultValue: "L{Column.columnLabel}"
      },
      {
        name: "cellAriaLabel",
        defaultValue: "L{cellLabel}"
      }
    ];
  }
  static get autoExposeFields() {
    return false;
  }
  construct(data, store) {
    var _me$field;
    const me = this;
    me.masterStore = store;
    if (store) {
      me._grid = Array.isArray(store) ? store[0].grid : store.grid;
    }
    me.localizableProperties = Config.mergeMethods.distinct(data.localizableProperties, ["text", "ariaLabel", "cellAriaLabel"]);
    if (data.localeClass) {
      me.localeClass = data.localeClass;
    }
    super.construct(...arguments);
    if (me.isLeaf && !("field" in me.data)) {
      me.field = "_" + (me.type || "") + ++Column.emptyCount;
      me.noFieldSpecified = true;
    }
    me.hasComplexMapping = (_me$field = me.field) === null || _me$field === void 0 ? void 0 : _me$field.includes(".");
    if (!me.width && !me.flex && !me.children) {
      me.set({
        width: Column.defaultWidth,
        flex: null
      }, null, true);
    }
    me.headerWidgets && me.initHeaderWidgets(me.headerWidgets);
    if (me.isParent) {
      me.meta.visibleChildren = /* @__PURE__ */ new Set();
      if (me.collapsible) {
        me.collapsible = true;
      }
    }
  }
  get isCollapsible() {
    var _this$children;
    return ((_this$children = this.children) === null || _this$children === void 0 ? void 0 : _this$children.length) > 1 && this.collapsible;
  }
  get collapsed() {
    return this.get("collapsed");
  }
  set collapsed(collapsed) {
    this.set("collapsed", collapsed, true);
    this.onCollapseChange(!collapsed);
    this.trigger("toggleCollapse", {
      collapsed
    });
  }
  onCellFocus(location) {
    this.location = location;
    this.updateHeaderAriaLabel(this.localizeProperty("ariaLabel"));
    if (location.rowIndex !== -1) {
      this.updateCellAriaLabel(this.localizeProperty("cellAriaLabel"));
    }
  }
  updateHeaderAriaLabel(headerAriaLabel) {
    DomHelper.setAttributes(this.element, {
      "aria-label": headerAriaLabel
    });
  }
  updateCellAriaLabel(cellAriaLabel) {
    var _this$location, _this$location2;
    if (!((_this$location = this.location) !== null && _this$location !== void 0 && _this$location.isSpecialRow) && (_this$location2 = this.location) !== null && _this$location2 !== void 0 && _this$location2.cell) {
      var _cellAriaLabel;
      if (!((_cellAriaLabel = cellAriaLabel) !== null && _cellAriaLabel !== void 0 && _cellAriaLabel.length)) {
        cellAriaLabel = this.location.column.text;
      }
      DomHelper.setAttributes(this.location.cell, {
        "aria-label": cellAriaLabel
      });
    }
  }
  doDestroy() {
    var _this$data, _this$data$editor, _this$data$editor$des;
    (_this$data = this.data) === null || _this$data === void 0 ? void 0 : (_this$data$editor = _this$data.editor) === null || _this$data$editor === void 0 ? void 0 : (_this$data$editor$des = _this$data$editor.destroy) === null || _this$data$editor$des === void 0 ? void 0 : _this$data$editor$des.call(_this$data$editor);
    this.destroyHeaderWidgets();
    super.doDestroy();
  }
  set headerWidgets(widgets) {
    this.initHeaderWidgets(widgets);
    this.set("headerWidgets", widgets);
  }
  get headerWidgets() {
    return this.get("headerWidgets");
  }
  initHeaderWidgets(widgets) {
    this.destroyHeaderWidgets();
    const headerWidgetMap = this.headerWidgetMap = {};
    for (const config of widgets) {
      const widget = Widget.create(_objectSpread2({
        owner: this
      }, config));
      headerWidgetMap[widget.ref || widget.id] = widget;
    }
  }
  destroyHeaderWidgets() {
    for (const widget of Object.values(this.headerWidgetMap || {})) {
      var _widget$destroy;
      (_widget$destroy = widget.destroy) === null || _widget$destroy === void 0 ? void 0 : _widget$destroy.call(widget);
    }
  }
  static generateAutoCls() {
    let columnAutoCls = "";
    for (let c = this; c !== Column; c = c.superclass) {
      c.type && (columnAutoCls += `b-${c.type.toLowerCase()}-cell `);
    }
    (Column.autoClsMap || (Column.autoClsMap = /* @__PURE__ */ new Map())).set(this, columnAutoCls);
    return columnAutoCls;
  }
  getCellClass(cellContext) {
    var _Column$autoClsMap, _record$fieldMap$colu;
    const {
      record,
      column
    } = cellContext, {
      cellCls,
      internalCellCls,
      grid,
      constructor,
      align
    } = column, autoCls = ((_Column$autoClsMap = Column.autoClsMap) === null || _Column$autoClsMap === void 0 ? void 0 : _Column$autoClsMap.get(constructor)) || constructor.generateAutoCls(), isEditing = cellContext.cell.classList.contains("b-editing"), result = {
      [grid.cellCls]: grid.cellCls,
      [autoCls]: autoCls,
      [cellCls]: cellCls,
      [internalCellCls]: internalCellCls,
      "b-cell-dirty": record.isFieldModified(column.field) && (column.compositeField || ((_record$fieldMap$colu = record.fieldMap[column.field]) === null || _record$fieldMap$colu === void 0 ? void 0 : _record$fieldMap$colu.persist) !== false),
      [`b-grid-cell-align-${align}`]: align,
      "b-selected": grid.selectionMode.cell && grid.isCellSelected(cellContext),
      "b-focused": grid.isFocused(cellContext),
      "b-auto-height": column.autoHeight,
      "b-editing": isEditing
    };
    if (record.isSpecialRow && result["b-checkbox-selection"]) {
      result["b-checkbox-selection"] = false;
    }
    return result;
  }
  get locked() {
    return this.data.region === "locked";
  }
  set locked(locked) {
    this.region = locked ? "locked" : "normal";
  }
  get region() {
    if (!this.parent.isRoot) {
      return this.parent.region;
    }
    return this.get("region");
  }
  set region(region) {
    this.set("region", region);
  }
  get sortable() {
    return this.isLeaf && this.data.sortable;
  }
  set sortable(sortable) {
    this.set("sortable", sortable);
  }
  get groupable() {
    return this.isLeaf && this.data.groupable;
  }
  set groupable(groupable) {
    this.set("groupable", groupable);
  }
  get editor() {
    const me = this;
    let {
      editor
    } = me.data;
    if (editor && !editor.isWidget) {
      const result = me.grid.processCellEditor({
        editor,
        field: me.field
      });
      if (result) {
        editor = me.data.editor = result.editor;
      } else {
        if (typeof editor === "string") {
          editor = {
            type: editor
          };
        }
        editor = me.data.editor = Widget.create(ObjectHelper.merge(me.defaultEditor, {
          owner: me.grid,
          label: StringHelper.encodeHtml(me.text)
        }, editor));
      }
    }
    return editor;
  }
  set editor(editor) {
    this.data.editor = editor;
  }
  get defaultEditor() {
    return {
      type: "textfield",
      name: this.field
    };
  }
  getFilterableValue(record) {
    return this.getRawValue(record);
  }
  get owner() {
    return this._owner || this.subGrid;
  }
  set owner(owner) {
    this._owner = owner;
  }
  get grid() {
    var _this$parent;
    return this._grid || ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.grid);
  }
  set subGrid(subGrid) {
    this._subGrid = subGrid;
  }
  get subGrid() {
    var _this$grid;
    return this._subGrid || ((_this$grid = this.grid) === null || _this$grid === void 0 ? void 0 : _this$grid.getSubGridFromColumn(this));
  }
  get subGridElement() {
    return this.subGrid.element;
  }
  get element() {
    return this.grid.getHeaderElement(this);
  }
  get nextVisibleSibling() {
    const region = this.region;
    let next = this.nextSibling;
    while (next && (next.hidden || next.region !== region)) {
      next = next.nextSibling;
    }
    return next;
  }
  get isLastInSubGrid() {
    return !this.nextVisibleSibling && (this.parent.isRoot || this.parent.isLastInSubGrid);
  }
  get textWrapper() {
    return DomHelper.getChild(this.element, ".b-grid-header-text");
  }
  get textElement() {
    return DomHelper.down(this.element, ".b-grid-header-text-content");
  }
  get contentElement() {
    return DomHelper.down(this.element, ".b-grid-header-children");
  }
  get isSorted() {
    return this.grid.store.sorters.some((s) => s.field === this.field);
  }
  get isFocusable() {
    return this.isLeaf;
  }
  static get text() {
    return this.$meta.fields.defaults.text;
  }
  get headerText() {
    return this.htmlEncodeHeaderText ? StringHelper.encodeHtml(this.text) : this.text;
  }
  get isVisible() {
    return !this.hidden && (!this.parent || this.parent.isVisible);
  }
  hide(silent = false, hidingParent = false) {
    const me = this, {
      parent
    } = me;
    if (!me.hidden) {
      me.hidden = true;
      if (parent && !parent.isRoot && !parent.isTogglingAll) {
        const anyVisible = parent.children.some((child) => child.hidden !== true);
        if (!anyVisible && !parent.hidden) {
          silent = true;
          parent.hide();
        }
      }
      if (me.isParent) {
        me.children.forEach((child) => child.hide(true, true));
      } else if (!parent.isRoot) {
        parent.meta.visibleChildren[hidingParent ? "add" : "delete"](me);
      }
      if (!silent) {
        me.stores.forEach((store) => store.trigger("columnHide", {
          column: me
        }));
      }
    }
  }
  show(silent = false) {
    const me = this, {
      parent
    } = me;
    if (me.hidden) {
      me.hidden = false;
      if (parent !== null && parent !== void 0 && parent.hidden) {
        parent.show();
      }
      if (me.isParent) {
        var _me$meta$visibleChild;
        (_me$meta$visibleChild = me.meta.visibleChildren) === null || _me$meta$visibleChild === void 0 ? void 0 : _me$meta$visibleChild.forEach((child) => child.show(true));
      }
      if (!silent) {
        me.stores.forEach((store) => store.trigger("columnShow", {
          column: me
        }));
      }
    }
  }
  toggle(forceVisible) {
    if (this.hidden && forceVisible === void 0 || forceVisible === true) {
      return this.show();
    }
    if (!this.hidden && forceVisible === void 0 || forceVisible === false) {
      return this.hide();
    }
  }
  toggleChildren(columns = this.children, force = void 0) {
    var _me$grid$columns, _me$grid$columns2;
    const me = this;
    (_me$grid$columns = me.grid.columns) === null || _me$grid$columns === void 0 ? void 0 : _me$grid$columns.beginBatch();
    me.isTogglingAll = true;
    columns.forEach((childColumn) => childColumn.toggle(force));
    me.isTogglingAll = false;
    (_me$grid$columns2 = me.grid.columns) === null || _me$grid$columns2 === void 0 ? void 0 : _me$grid$columns2.endBatch();
  }
  onCollapseChange(force = void 0) {
    const me = this;
    if (me.collapseMode === "toggleAll") {
      me.toggleChildren();
    } else {
      var _me$grid$columns3, _me$grid$columns4;
      const {
        firstChild
      } = me;
      if (firstChild.flex != null && me.collapsed) {
        firstChild.oldFlex = firstChild.flex;
        firstChild.width = firstChild.element.offsetWidth;
      } else if (!me.collapsed && firstChild.oldFlex) {
        firstChild.flex = firstChild.oldFlex;
        firstChild.oldFlex = null;
      }
      (_me$grid$columns3 = me.grid.columns) === null || _me$grid$columns3 === void 0 ? void 0 : _me$grid$columns3.beginBatch();
      me.isTogglingAll = true;
      me.children.slice(1).forEach((childColumn) => childColumn.toggle(force));
      me.isTogglingAll = false;
      (_me$grid$columns4 = me.grid.columns) === null || _me$grid$columns4 === void 0 ? void 0 : _me$grid$columns4.endBatch();
    }
  }
  set collapsible(collapsible) {
    const me = this;
    me.set("collapsible", collapsible);
    if (me.isParent) {
      const {
        headerWidgets = []
      } = me;
      if (collapsible) {
        headerWidgets.push({
          type: "button",
          ref: "collapseExpand",
          toggleable: true,
          pressed: me.collapsed,
          icon: `b-icon-collapse-${me.grid.rtl ? "right" : "left"}`,
          pressedIcon: `b-icon-collapse-${me.grid.rtl ? "left" : "right"}`,
          cls: "b-grid-header-collapse-button b-transparent",
          onToggle: ({
            pressed
          }) => me.collapsed = pressed
        });
      } else {
        const index = headerWidgets.findIndex((w) => w.ref === "collapseExpand");
        index > -1 && headerWidgets.splice(index, 1);
      }
      me.headerWidgets = headerWidgets;
      if (me.collapsed) {
        me.onCollapseChange(false);
      }
    }
  }
  get collapsible() {
    return this.get("collapsible");
  }
  generateId() {
    if (!Column.generatedIdIndex) {
      Column.generatedIdIndex = 0;
    }
    return (this.field ? this.field.replace(/\./g, "-") : "col") + ++Column.generatedIdIndex;
  }
  get allIndex() {
    return this.masterStore.indexOf(this);
  }
  measureSize(value) {
    var _this$subGrid;
    return DomHelper.measureSize(value, (_this$subGrid = this.subGrid) === null || _this$subGrid === void 0 ? void 0 : _this$subGrid.element);
  }
  get calcMinWidth() {
    const {
      width,
      minWidth
    } = this.data;
    if (validWidth(width) && validWidth(minWidth)) {
      return Math.max(parseInt(width) || 0, parseInt(minWidth) || 0);
    } else {
      return width;
    }
  }
  get width() {
    return this.data.width;
  }
  set width(width) {
    const data = {
      width
    };
    if (width && "flex" in this.data) {
      data.flex = null;
    }
    this.set(data);
  }
  set flex(flex) {
    const data = {
      flex
    };
    if (flex && "width" in this.data) {
      data.width = null;
    }
    this.set(data);
  }
  get flex() {
    return this.data.flex;
  }
  calculateMinWidth() {
    const me = this, width = me.measureSize(me.width), minWidth = me.measureSize(me.minWidth);
    let minChildWidth = 0;
    if (me.children) {
      minChildWidth = me.children.reduce((result, column) => {
        return result + column.calculateMinWidth();
      }, 0);
    }
    return Math.max(width, minWidth, minChildWidth);
  }
  resizeToFitContent(widthMin, widthMax, batch = false) {
    const me = this, {
      grid,
      element,
      fitMode
    } = me, {
      rowManager,
      store
    } = grid, {
      count
    } = store;
    if (count <= 0 || me.fitMode === "none" || !me.fitMode) {
      return;
    }
    const [row] = rowManager.rows, {
      rowElement,
      cellElement
    } = grid.beginGridMeasuring(), cellContext = new Location({
      grid,
      column: me,
      id: null
    });
    let maxWidth = 0, start, end, i, record, value, length, longest = {
      length: 0,
      record: null
    };
    cellElement._domData = {
      columnId: me.id,
      row,
      rowElement
    };
    cellContext._cell = cellElement;
    cellContext.updatingSingleRow = true;
    cellContext.isMeasuring = true;
    cellElement.innerHTML = "";
    if (grid.resizeToFitIncludesHeader) {
      if (!grid.$headerPadding) {
        const style = globalThis.getComputedStyle(element);
        grid.$headerPadding = parseInt(style.paddingLeft);
      }
      const headerText = element.querySelector(".b-grid-header-text-content");
      headerText.style.cssText = "flex: none; width: auto";
      maxWidth = headerText.offsetWidth + grid.$headerPadding * 2 + 2;
      headerText.style.cssText = "";
    }
    if (count > 1e3) {
      start = Math.max(Math.min(rowManager.topIndex + Math.round(rowManager.rowCount / 2) - 500, count - 1e3), 0);
      end = start + 1e3;
    } else {
      start = 0;
      end = count;
    }
    for (i = start; i < end; i++) {
      record = store.getAt(i);
      value = me.getRawValue(record);
      if (fitMode === "value") {
        length = String(value).length;
      } else {
        cellContext._record = longest.record;
        cellContext._id = record.id;
        cellContext._rowIndex = i;
        row.renderCell(cellContext);
        if (fitMode === "textContent") {
          length = cellElement.textContent.length;
        } else {
          const width = cellElement.offsetWidth;
          if (width > maxWidth) {
            maxWidth = width;
          }
        }
      }
      if (length > longest.length) {
        longest = {
          record,
          length,
          rowIndex: i
        };
      }
    }
    if (longest.length > 0 && (fitMode === "value" || fitMode === "textContent")) {
      cellContext._record = longest.record;
      cellContext._id = longest.record.id;
      cellContext._rowIndex = longest.rowIndex;
      row.renderCell(cellContext);
      maxWidth = Math.max(maxWidth, cellElement.offsetWidth);
    }
    if (Array.isArray(widthMin)) {
      [widthMin, widthMax] = widthMin;
    }
    maxWidth = Math.max(maxWidth, widthMin || 0);
    maxWidth = Math.min(maxWidth, widthMax || 1e6);
    if (!batch) {
      grid.endGridMeasuring();
    }
    me.width = me.maxWidth ? maxWidth = Math.min(maxWidth, me.maxWidth) : maxWidth;
    return maxWidth;
  }
  getState() {
    const me = this, state = {
      id: me.id,
      hidden: me.hidden,
      region: me.region,
      locked: me.locked
    };
    if (!me.children) {
      state[me.flex ? "flex" : "width"] = me.flex || me.width;
    }
    if (me.isCollapsible) {
      state.collapsed = me.collapsed;
    }
    return state;
  }
  applyState(state) {
    const me = this;
    me.beginBatch();
    if ("locked" in state) {
      me.locked = state.locked;
    }
    if ("width" in state) {
      me.width = state.width;
    }
    if ("flex" in state) {
      me.flex = state.flex;
    }
    if ("width" in state && me.flex) {
      me.flex = void 0;
    } else if ("flex" in state && me.width) {
      me.width = void 0;
    }
    if ("region" in state) {
      me.region = state.region;
    }
    me.endBatch();
    if ("hidden" in state) {
      me.toggle(state.hidden !== true);
    }
    if ("collapsed" in state) {
      me.collapsed = state.collapsed;
    }
  }
  remove() {
    const {
      subGrid,
      grid
    } = this, focusedCell = subGrid && (grid === null || grid === void 0 ? void 0 : grid.focusedCell);
    if ((focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.columnId) === this.id) {
      if (grid.owns(DomHelper.getActiveElement(grid))) {
        grid.navigateRight();
      } else {
        grid._focusedCell = new Location({
          grid,
          rowIndex: focusedCell.rowIndex,
          column: subGrid.columns.getAdjacentVisibleLeafColumn(this.id, true, true)
        });
      }
    }
    super.remove();
  }
  getRawValue(record) {
    if (this.hasComplexMapping) {
      return ObjectHelper.getPath(record, this.field);
    }
    return record[this.field];
  }
  refreshCell(record) {
    this.grid.rowManager.refreshCell(record, this.id);
  }
  clearCell(cellElement) {
    cellElement.innerHTML = "";
    delete cellElement._content;
  }
  canEdit(record) {
    if (record.isEditable) {
      const isEditable = record.isEditable(this.field);
      if (isEditable !== void 0) {
        return isEditable;
      }
    }
    return true;
  }
  insertChild(childColumn, before = null, silent = false) {
    childColumn = Array.isArray(childColumn) ? childColumn : [childColumn];
    childColumn.forEach((col) => {
      const {
        parent
      } = col;
      if (parent !== null && parent !== void 0 && parent.collapsed && col === parent.firstChild && parent.children.length > 1 && parent.children.filter((child) => !child.hidden).length === 1) {
        col.nextSibling.hidden = false;
      }
    });
    return this.sealed && !this.inProcessChildren ? null : super.insertChild(...arguments);
  }
  canFillValue() {
    return true;
  }
  getCurrentConfig(options) {
    var _this$sortable;
    const result = super.getCurrentConfig(options);
    if ((_this$sortable = this.sortable) !== null && _this$sortable !== void 0 && _this$sortable.originalSortFn) {
      result.sortable = this.sortable.originalSortFn;
    }
    if (result.renderer === this.internalRenderer) {
      delete result.renderer;
    }
    if (result.headerRenderer === this.internalHeaderRenderer) {
      delete result.headerRenderer;
    }
    delete result.ariaLabel;
    delete result.cellAriaLabel;
    return result;
  }
};
Column.emptyCount = 0;
Column.defaultWidth = 100;
Column.exposeProperties();
Column._$name = "Column";
var columnDefinitions = {
  boolean: {
    type: "check"
  },
  date: {
    type: "date"
  },
  integer: {
    type: "number",
    format: {
      maximumFractionDigits: 0
    }
  },
  number: {
    type: "number"
  }
};
var lockedColumnSorters = [{
  field: "region"
}];
var ColumnStore = class extends Localizable(Store) {
  static get defaultConfig() {
    return {
      modelClass: Column,
      tree: true,
      autoAddField: false,
      sorters: lockedColumnSorters
    };
  }
  construct(config) {
    const me = this;
    if (config.grid) {
      config.grid._columnStore = me;
      me.id = `${config.grid.id}-columns`;
      config.grid.ion({
        subGridCollapse: "clearSubGridCaches",
        subGridExpand: "clearSubGridCaches",
        thisObj: me
      });
    }
    super.construct(config);
    me.ion({
      change: me.onStoreChange,
      sort: () => me.updateChainedStores(),
      thisObj: me,
      prio: 1
    });
  }
  get modelClass() {
    return this._modelClass;
  }
  set modelClass(ClassDef) {
    this._modelClass = ClassDef;
  }
  doDestroy() {
    const allColumns = [];
    if (!this.isChained) {
      this.traverse((column) => allColumns.push(column));
    }
    super.doDestroy();
    if (!this.isChained) {
      allColumns.forEach((column) => column.destroy());
    }
  }
  getById(id) {
    return super.getById(id) || this.idRegister[id];
  }
  forEach(fn, thisObj = this) {
    this.traverseWhile((n, i) => fn.call(thisObj, n, i), true);
  }
  get totalFixedWidth() {
    let result = 0;
    for (const col of this) {
      if (!col.hidden) {
        if (col.children) {
          col.children.forEach((childCol) => result += this.calculateFixedWidth(childCol));
        } else {
          result += this.calculateFixedWidth(col);
        }
      }
    }
    return result;
  }
  get hasFlex() {
    return this.visibleColumns.some((column) => column.flex);
  }
  calculateFixedWidth(column) {
    if (column.flex) {
      return column.measureSize(Column.defaultWidth);
    } else {
      return Math.max(column.measureSize(column.width), column.measureSize(column.minWidth));
    }
  }
  get topColumns() {
    return this.isChained ? this.masterStore.rootNode.children.filter(this.chainedFilterFn) : this.rootNode.children;
  }
  get visibleColumns() {
    const me = this;
    if (!me._visibleColumns) {
      me._visibleColumns = me.leaves.filter((column) => column.isVisible && (!column.subGrid || !column.subGrid.collapsed));
    }
    return me._visibleColumns;
  }
  onStoreChange({
    action,
    changes
  }) {
    if (action === "update" && !("hidden" in changes)) {
      return;
    }
    this.clearCaches();
  }
  clearSubGridCaches({
    subGrid
  }) {
    subGrid.columns.clearCaches();
    this.clearCaches();
  }
  clearCaches() {
    var _this$masterStore;
    this._visibleColumns = null;
    (_this$masterStore = this.masterStore) === null || _this$masterStore === void 0 ? void 0 : _this$masterStore.clearCaches();
  }
  onMasterDataChanged(event) {
    super.onMasterDataChanged(event);
    if (event.action !== "update" || "hidden" in event.changes) {
      this.clearCaches();
    }
  }
  getAdjacentVisibleLeafColumn(columnOrId, next = true, wrap = false) {
    const columns = this.visibleColumns, column = columnOrId instanceof Column ? columnOrId : this.getById(columnOrId);
    let idx = columns.indexOf(column) + (next ? 1 : -1);
    if (!columns[idx]) {
      if (wrap) {
        idx = next ? 0 : columns.length - 1;
      } else {
        return null;
      }
    }
    return columns[idx];
  }
  get bottomColumns() {
    return this.leaves;
  }
  get(field) {
    return this.findRecord("field", field, true);
  }
  createRecord(data) {
    var _store$modelClass, _store$modelClass$fie;
    const {
      grid = {}
    } = this, {
      store
    } = grid, dataField = store === null || store === void 0 ? void 0 : (_store$modelClass = store.modelClass) === null || _store$modelClass === void 0 ? void 0 : (_store$modelClass$fie = _store$modelClass.fieldMap) === null || _store$modelClass$fie === void 0 ? void 0 : _store$modelClass$fie[data.field];
    let columnClass = this.modelClass;
    if (dataField !== null && dataField !== void 0 && dataField.column) {
      data = Objects.merge({}, dataField.column, data);
    }
    if (data.type) {
      columnClass = ColumnStore.getColumnClass(data.type);
      if (!columnClass) {
        throw new Error(`Column type '${data.type}' not registered`);
      }
    }
    if (data.locked) {
      data.region = "locked";
      delete data.locked;
    }
    const column = new columnClass(data, this);
    if (!column.data.region) {
      column.data.region = grid.defaultRegion || "normal";
    }
    if (this.autoAddField && !column.noFieldSpecified && store && !dataField) {
      let fieldDefinition = column.field;
      if (column.constructor.fieldType) {
        fieldDefinition = {
          name: column.field,
          type: column.constructor.fieldType
        };
      }
      store.modelClass.addField(fieldDefinition);
    }
    return column;
  }
  indexOf(recordOrId) {
    if (recordOrId == null) {
      return -1;
    }
    const index = super.indexOf(recordOrId);
    if (index > -1)
      return index;
    return this.records.findIndex((r) => r.field === recordOrId);
  }
  get usesAutoHeight() {
    return this.find((column) => column.autoHeight);
  }
  get usesFlexAutoHeight() {
    return this.find((column) => column.autoHeight && column.flex != null);
  }
  static registerColumnType(columnClass, simpleRenderer = false) {
    columnClass.simpleRenderer = simpleRenderer;
    (ColumnStore.columnTypes || (ColumnStore.columnTypes = {}))[columnClass.type] = columnClass;
  }
  static getColumnClass(type) {
    return ColumnStore.columnTypes && ColumnStore.columnTypes[type];
  }
  generateColumnForField(dataField, defaults) {
    if (typeof dataField === "string" && this.grid) {
      var _this$grid$store;
      dataField = (_this$grid$store = this.grid.store) === null || _this$grid$store === void 0 ? void 0 : _this$grid$store.modelClass.fieldMap[dataField];
    }
    let column = dataField.column || columnDefinitions[dataField.type] || {};
    if (typeof column === "string") {
      column = {
        type: column
      };
    }
    column = Object.assign({
      text: dataField.text || StringHelper.separate(dataField.name),
      field: dataField.name
    }, defaults, column);
    if (dataField.precision != null) {
      column.format.maximumFractionDigits = dataField.precision;
    }
    if (dataField.columnType) {
      column.type = dataField.columnType;
    }
    return this.createRecord(column);
  }
};
var columnResizeEvent = (handler, thisObj) => ({
  update: ({
    store,
    record,
    changes
  }) => {
    let result = true;
    if ("width" in changes || "minWidth" in changes || "maxWidth" in changes || "flex" in changes) {
      result = handler.call(thisObj, {
        store,
        record,
        changes
      });
    }
    return result;
  }
});
ColumnStore.registerColumnType(Column, true);
ColumnStore._$name = "ColumnStore";
var ActionColumn = class extends Column {
  get groupHeaderReserved() {
    return true;
  }
  construct(config, store) {
    const me = this;
    super.construct(...arguments);
    if (!config.width && !config.flex) {
      me.grid.ion({
        paint: "updateAutoWidth",
        thisObj: me
      });
    }
    if (me.disableIfGridReadOnly) {
      me.grid.element.classList.add("b-actioncolumn-readonly");
    }
    me.externalRenderer = me.renderer;
    me.renderer = me.internalRenderer;
  }
  internalRenderer({
    grid,
    column,
    record,
    callExternalRenderer = true
  }) {
    var _column$actions;
    const inGroupTitle = record && "groupRowFor" in record.meta, {
      subGrid
    } = column;
    if (callExternalRenderer) {
      var _this$externalRendere;
      (_this$externalRendere = this.externalRenderer) === null || _this$externalRendere === void 0 ? void 0 : _this$externalRendere.call(this, ...arguments);
    }
    return {
      className: {
        "b-action-ct": 1
      },
      children: (_column$actions = column.actions) === null || _column$actions === void 0 ? void 0 : _column$actions.map((actionConfig, index) => {
        var _tooltip$startsWith;
        if ("visible" in actionConfig) {
          if (typeof actionConfig.visible === "function" && actionConfig.visible({
            record
          }) === false) {
            return "";
          }
          if (actionConfig.visible === false) {
            return "";
          }
        }
        if (inGroupTitle && !actionConfig.showForGroup || !inGroupTitle && actionConfig.showForGroup) {
          return "";
        }
        const {
          tooltip,
          renderer
        } = actionConfig, btip = typeof tooltip === "function" || tooltip !== null && tooltip !== void 0 && (_tooltip$startsWith = tooltip.startsWith) !== null && _tooltip$startsWith !== void 0 && _tooltip$startsWith.call(tooltip, "up.") ? subGrid.callback(tooltip, subGrid, [{
          record
        }]) : tooltip || "";
        if (renderer) {
          const customRendererData = subGrid.callback(renderer, subGrid, [{
            index,
            record,
            column,
            tooltip: btip,
            action: actionConfig
          }]);
          if (typeof customRendererData === "string") {
            return {
              tag: "span",
              dataset: _objectSpread2(_objectSpread2({}, Tooltip.encodeConfig(btip)), {}, {
                index
              }),
              html: customRendererData
            };
          } else {
            customRendererData.dataset = customRendererData.dataset || {};
            customRendererData.dataset.index = index;
            return customRendererData;
          }
        } else {
          return {
            tag: "button",
            dataset: _objectSpread2(_objectSpread2({}, Tooltip.encodeConfig(btip)), {}, {
              index
            }),
            "aria-label": btip,
            className: {
              "b-tool": 1,
              "b-action-item": 1,
              [actionConfig.cls]: actionConfig.cls
            }
          };
        }
      })
    };
  }
  onCellClick({
    grid,
    column,
    record,
    target
  }) {
    var _column$actions2;
    if (column !== this || !target.classList.contains("b-action-item")) {
      return;
    }
    let actionIndex = target.dataset.index;
    if (!actionIndex) {
      actionIndex = target.parentElement.dataset && target.parentElement.dataset.index;
    }
    const action = (_column$actions2 = column.actions) === null || _column$actions2 === void 0 ? void 0 : _column$actions2[actionIndex], actionHandler = action && action.onClick;
    if (actionHandler) {
      this.callback(actionHandler, column, [{
        record,
        action,
        target
      }]);
    }
  }
  updateAutoWidth() {
    const me = this, groupActions = [], {
      actions: oldActions
    } = me;
    if (!me.element) {
      return;
    }
    const actions = me.actions = [];
    oldActions === null || oldActions === void 0 ? void 0 : oldActions.forEach((actionOriginal) => {
      const action = _objectSpread2({}, actionOriginal);
      delete action.visible;
      if (action.showForGroup) {
        delete action.showForGroup;
        groupActions.push(action);
      } else {
        actions.push(action);
      }
    });
    if (groupActions.length > actions.length) {
      me._actions = groupActions;
    }
    const actionsHtml = DomHelper.createElement(me.internalRenderer({
      column: me,
      callExternalRenderer: false
    })).outerHTML;
    me.width = DomHelper.measureText(actionsHtml, me.element, true, me.element.parentElement);
    me.actions = oldActions;
  }
};
_defineProperty(ActionColumn, "type", "action");
_defineProperty(ActionColumn, "fields", [
  {
    name: "actions",
    type: "array"
  },
  {
    name: "disableIfGridReadOnly",
    defaultValue: false
  }
]);
_defineProperty(ActionColumn, "defaults", {
  filterable: false,
  groupable: false,
  sortable: false,
  editor: false,
  searchable: false,
  htmlEncode: false,
  resizable: false,
  minWidth: 30
});
ColumnStore.registerColumnType(ActionColumn);
ActionColumn.exposeProperties();
ActionColumn._$name = "ActionColumn";
var NumberColumn = class extends Column {
  static get defaults() {
    return {
      filterType: "number",
      format: ""
    };
  }
  get defaultEditor() {
    const {
      format,
      name,
      max,
      min: min2,
      step,
      largeStep,
      align
    } = this;
    return ObjectHelper.cleanupProperties({
      type: "numberfield",
      format,
      name,
      max,
      min: min2,
      step,
      largeStep,
      textAlign: align
    });
  }
  get formatter() {
    const me = this, {
      format
    } = me;
    let formatter = me._formatter;
    if (!formatter || me._lastFormat !== format) {
      me._formatter = formatter = NumberFormat.get(me._lastFormat = format);
    }
    return formatter;
  }
  formatValue(value) {
    var _value;
    if (value != null) {
      value = this.formatter.format(value);
      if (this.unit) {
        value = `${value}${this.unit}`;
      }
    }
    return (_value = value) !== null && _value !== void 0 ? _value : "";
  }
  defaultRenderer({
    value
  }) {
    return this.formatValue(value);
  }
};
_defineProperty(NumberColumn, "type", "number");
_defineProperty(NumberColumn, "fieldType", "number");
_defineProperty(NumberColumn, "fields", [
  "format",
  "min",
  "max",
  "step",
  "largeStep",
  "unit"
]);
ColumnStore.registerColumnType(NumberColumn, true);
NumberColumn.exposeProperties();
NumberColumn._$name = "NumberColumn";
var AggregateColumn = class extends NumberColumn {
  static get defaults() {
    return {
      function: "sum",
      includeParentInChangeSet: false
    };
  }
  construct(data, columnStore) {
    this.configuredAlign = "align" in data;
    this.configuredEditor = "editor" in data;
    super.construct(...arguments);
    const {
      grid
    } = columnStore;
    if (this.function === "sum") {
      this.function = "sumChildren";
    }
    if (grid) {
      this.store = grid.store;
    }
  }
  set store(store) {
    const me = this, storeListeners = {
      update: "onRecordUpdate",
      thisObj: me,
      prio: 1e3
    }, oldStore = me._store;
    if (store !== oldStore) {
      if (oldStore) {
        oldStore.un(storeListeners);
      }
      me._store = store;
      const {
        modelClass
      } = store, field = modelClass.fieldMap[me.field];
      if (field && field.type === "number") {
        if (!me.configuredAlign) {
          me.align = "end";
        }
        if (!me.configuredEditor) {
          me.editor = "number";
        }
      }
      store.ion(storeListeners);
    }
  }
  canEdit(record) {
    return record.isLeaf;
  }
  get store() {
    return this._store;
  }
  sumChildren(...args) {
    let result = 0;
    for (let i = 0, {
      length
    } = args; i < length; i++) {
      result += parseFloat(args[i] || 0, 10);
    }
    return result;
  }
  avg(...args) {
    let result = 0;
    const {
      length
    } = args;
    for (let i = 0; i < length; i++) {
      result += parseFloat(args[i] || 0, 10);
    }
    return result / length;
  }
  onRecordUpdate({
    record,
    changes
  }) {
    const me = this, {
      rowManager
    } = me.grid;
    if (me.field in changes) {
      if (record.isLeaf) {
        record.bubble((rec) => {
          const row = rowManager.getRowFor(rec);
          if (row) {
            const cellElement = row.getCell(me.field);
            if (cellElement) {
              row.renderCell(cellElement);
            }
          }
        }, true);
      }
    }
  }
  getRawValue(record) {
    var _record$children;
    let value = 0;
    if ((_record$children = record.children) !== null && _record$children !== void 0 && _record$children.length) {
      const me = this, fn = me.function, isMathFn = typeof fn === "string" && typeof Math[fn] === "function", {
        handler,
        thisObj
      } = isMathFn ? {
        handler: Math[fn],
        thisObj: Math
      } : me.resolveCallback(fn);
      value = handler.apply(thisObj, record.children.map((r) => me.getRawValue(r)));
      if (me.includeParentInChangeSet) {
        record.set(me.field, value, true);
      } else {
        record.setData(me.field, value);
      }
    } else {
      value = record[this.field];
    }
    return value;
  }
  canFillValue() {
    return false;
  }
};
_defineProperty(AggregateColumn, "type", "aggregate");
_defineProperty(AggregateColumn, "fields", ["function", "includeParentInChangeSet"]);
ColumnStore.registerColumnType(AggregateColumn, true);
AggregateColumn.exposeProperties();
AggregateColumn._$name = "AggregateColumn";
var WidgetColumn = class extends Column {
  static get defaults() {
    return {
      filterable: false,
      sortable: false,
      editor: false,
      searchable: false,
      fitMode: false,
      alwaysClearCell: false
    };
  }
  construct(config, store) {
    const me = this;
    me.widgetMap = {};
    super.construct(...arguments);
    me.externalRenderer = me.renderer;
    me.renderer = me.internalRenderer;
  }
  doDestroy() {
    for (const widget of Object.values(this.widgetMap)) {
      widget.destroy && widget.destroy();
    }
    super.doDestroy();
  }
  updateReadOnly(readOnly) {
    for (const widget of Object.values(this.widgetMap)) {
      if (!widget.cellInfo.record.readOnly) {
        widget.readOnly = readOnly;
      }
    }
  }
  internalRenderer(renderData) {
    var _this$externalRendere;
    const me = this, {
      cellElement,
      column,
      record,
      isExport
    } = renderData, {
      widgets
    } = column;
    if (!isExport && widgets) {
      if (!cellElement.widgets) {
        me.clearCell(cellElement);
      }
      cellElement.widgets = renderData.widgets = widgets.map((widgetCfg, i) => {
        var _me$onBeforeWidgetSet, _me$onAfterWidgetSetV;
        let widget, widgetNextSibling;
        if (cellElement.widgets) {
          widget = cellElement.widgets[i];
          widgetNextSibling = widget.element.nextElementSibling;
          if (widgetCfg.recreate && widget) {
            delete me.widgetMap[widget.id];
            widget.destroy();
            cellElement.widgets[i] = null;
          }
        }
        if (!widget) {
          me.onBeforeWidgetCreate(widgetCfg, renderData);
          widgetCfg.recomposeAsync = false;
          widget = WidgetHelper.append(widgetCfg, widgetNextSibling ? {
            insertBefore: widgetNextSibling
          } : cellElement)[0];
          me.widgetMap[widget.id] = widget;
          me.onAfterWidgetCreate(widget, renderData);
          if (widget.name) {
            widget.ion({
              change: ({
                value
              }) => {
                widget.cellInfo.record[widget.name] = value;
              }
            });
          }
        }
        widget.cellInfo = {
          record,
          column
        };
        if (me.grid && !me.meta.isSelectionColumn) {
          widget.readOnly = me.grid.readOnly || record.readOnly;
        }
        if (((_me$onBeforeWidgetSet = me.onBeforeWidgetSetValue) === null || _me$onBeforeWidgetSet === void 0 ? void 0 : _me$onBeforeWidgetSet.call(me, widget, renderData)) !== false) {
          const valueProperty = widgetCfg.valueProperty || "value" in widget && "value" || widget.defaultBindProperty;
          if (valueProperty) {
            const value = widget.name ? record[widget.name] : renderData.value;
            widget[valueProperty] = value;
          }
        }
        (_me$onAfterWidgetSetV = me.onAfterWidgetSetValue) === null || _me$onAfterWidgetSetV === void 0 ? void 0 : _me$onAfterWidgetSetV.call(me, widget, renderData);
        return widget;
      });
    }
    if (isExport) {
      return null;
    }
    return (_this$externalRendere = this.externalRenderer) === null || _this$externalRendere === void 0 ? void 0 : _this$externalRendere.call(this, renderData);
  }
  onBeforeWidgetCreate(widgetCfg, renderData) {
  }
  onAfterWidgetCreate(widget, renderData) {
  }
  clearCell(cellElement) {
    if (cellElement.widgets) {
      cellElement.widgets.forEach((widget) => {
        delete this.widgetMap[widget.id];
        widget.destroy();
      });
      cellElement.widgets = null;
    }
    super.clearCell(cellElement);
  }
  resizeToFitContent() {
  }
};
_defineProperty(WidgetColumn, "type", "widget");
_defineProperty(WidgetColumn, "fields", [
  "widgets"
]);
ColumnStore.registerColumnType(WidgetColumn);
WidgetColumn.exposeProperties();
WidgetColumn._$name = "WidgetColumn";
var CheckColumn = class extends WidgetColumn {
  construct(config, store) {
    super.construct(...arguments);
    const me = this;
    Object.assign(me, {
      externalHeaderRenderer: me.headerRenderer,
      externalOnBeforeWidgetSetValue: me.onBeforeWidgetSetValue,
      externalOnAfterWidgetSetValue: me.onAfterWidgetSetValue,
      onBeforeWidgetSetValue: me.internalOnBeforeWidgetSetValue,
      onAfterWidgetSetValue: me.internalOnAfterWidgetSetValue,
      headerRenderer: me.internalHeaderRenderer
    });
    if (!me.meta.isSelectionColumn) {
      var _me$grid;
      const modelClass = (_me$grid = me.grid) === null || _me$grid === void 0 ? void 0 : _me$grid.store.modelClass;
      if (!me.field) {
        console.warn("CheckColumn MUST be configured with a field, otherwise the checked state will not be persistent. Widgets are recycled and reused");
      } else if (modelClass && !modelClass.fieldMap[me.field] && !me.constructor.suppressNoModelFieldWarning) {
        console.warn(me.$$name + " is configured with a field, but this is not part of your Model `fields` collection.");
        modelClass.addField({
          name: me.field,
          type: "boolean"
        });
      }
    }
  }
  doDestroy() {
    var _this$headerCheckbox;
    (_this$headerCheckbox = this.headerCheckbox) === null || _this$headerCheckbox === void 0 ? void 0 : _this$headerCheckbox.destroy();
    super.doDestroy();
  }
  internalHeaderRenderer({
    headerElement,
    column
  }) {
    let returnValue;
    headerElement.classList.add("b-check-header");
    if (column.showCheckAll) {
      headerElement.classList.add("b-check-header-with-checkbox");
      if (column.headerCheckbox) {
        headerElement.appendChild(column.headerCheckbox.element);
      } else {
        column.headerCheckbox = new Checkbox({
          appendTo: headerElement,
          owner: this.grid,
          ariaLabel: "L{Checkbox.toggleSelection}",
          internalListeners: {
            change: "onCheckAllChange",
            thisObj: column
          }
        });
      }
    } else {
      returnValue = column.headerText;
    }
    returnValue = column.externalHeaderRenderer ? column.externalHeaderRenderer.call(this, ...arguments) : returnValue;
    return column.showCheckAll ? void 0 : returnValue;
  }
  updateCheckAllState(value) {
    if (this.headerCheckbox) {
      this.suspendEvents();
      this.headerCheckbox.checked = value;
      this.resumeEvents();
    }
  }
  onCheckAllChange({
    checked
  }) {
    const me = this;
    if (me.field) {
      const {
        store
      } = me.grid;
      store.beginBatch();
      store.forEach((record) => me.updateRecord(record, me.field, checked));
      store.endBatch();
    }
    me.trigger("toggleAll", {
      checked
    });
  }
  internalRenderer({
    value,
    isExport,
    record,
    cellElement
  }) {
    if (isExport) {
      return value == null ? "" : value;
    }
    const result = super.internalRenderer(...arguments);
    if (record.readOnly && !this.meta.isSelectionColumn) {
      cellElement.widgets[0].readOnly = true;
    }
    return result;
  }
  onBeforeWidgetCreate(widgetCfg, event) {
    widgetCfg.cls = this.checkCls;
  }
  onAfterWidgetCreate(widget, event) {
    event.cellElement.widget = widget;
    widget.ion({
      beforeChange: "onBeforeCheckboxChange",
      change: "onCheckboxChange",
      thisObj: this
    });
  }
  internalOnBeforeWidgetSetValue(widget) {
    var _this$externalOnBefor;
    widget.record = widget.cellInfo.record;
    this.isInitialSet = true;
    (_this$externalOnBefor = this.externalOnBeforeWidgetSetValue) === null || _this$externalOnBefor === void 0 ? void 0 : _this$externalOnBefor.call(this, ...arguments);
  }
  internalOnAfterWidgetSetValue(widget) {
    var _this$externalOnAfter;
    this.isInitialSet = false;
    (_this$externalOnAfter = this.externalOnAfterWidgetSetValue) === null || _this$externalOnAfter === void 0 ? void 0 : _this$externalOnAfter.call(this, ...arguments);
  }
  onBeforeCheckboxChange({
    source,
    checked,
    userAction
  }) {
    const me = this, {
      grid
    } = me, {
      record
    } = source.cellInfo;
    if (userAction && me.field && (!grid.features.cellEdit || grid.features.cellEdit.disabled) || me.meta.isSelectionColumn && !grid.isSelectable(record) && checked) {
      return false;
    }
    if (!me.isInitialSet) {
      return me.trigger("beforeToggle", {
        record,
        checked
      });
    }
  }
  onCheckboxChange({
    source,
    checked
  }) {
    if (!this.isInitialSet) {
      const me = this, {
        record
      } = source.cellInfo, {
        field
      } = me;
      if (field) {
        me.updateRecord(record, field, checked);
        if (checked) {
          me.updateCheckAllState(me.grid.store.every((r) => r[field], null, true));
        } else {
          me.updateCheckAllState(false);
        }
      }
      me.trigger("toggle", {
        record,
        checked
      });
    }
  }
  updateRecord(record, field, checked) {
    const setterName = `set${StringHelper.capitalize(field)}`;
    if (record[setterName]) {
      record[setterName](checked);
    } else {
      record.set(field, checked);
    }
  }
  onCellKeyDown({
    event,
    cellElement
  }) {
    if (event.key === " ") {
      const checkbox = cellElement.widget;
      checkbox === null || checkbox === void 0 ? void 0 : checkbox.toggle();
      event.preventDefault();
      event.handled = true;
    }
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    delete result.onBeforeWidgetSetValue;
    delete result.onAfterWidgetSetValue;
    if (this.externalOnBeforeWidgetSetValue) {
      result.onBeforeWidgetSetValue = this.externalOnBeforeWidgetSetValue;
    }
    if (this.externalOnAfterWidgetSetValue) {
      result.onAfterWidgetSetValue = this.externalOnAfterWidgetSetValue;
    }
    return result;
  }
};
_defineProperty(CheckColumn, "$name", "CheckColumn");
_defineProperty(CheckColumn, "type", "check");
_defineProperty(CheckColumn, "fields", ["checkCls", "showCheckAll", "onAfterWidgetSetValue", "onBeforeWidgetSetValue", "callOnFunctions", "onBeforeToggle", "onToggle", "onToggleAll"]);
_defineProperty(CheckColumn, "defaults", {
  align: "center",
  checkCls: null,
  showCheckAll: false,
  sortable: true,
  filterable: true,
  widgets: [{
    type: "checkbox",
    valueProperty: "checked"
  }]
});
ColumnStore.registerColumnType(CheckColumn, true);
CheckColumn._$name = "CheckColumn";
var DateColumn = class extends Column {
  static get defaults() {
    return {
      format: "L",
      step: 1,
      minWidth: 85,
      filterType: "date"
    };
  }
  defaultRenderer({
    value
  }) {
    return value ? this.formatValue(value) : "";
  }
  groupRenderer({
    cellElement,
    groupRowFor
  }) {
    cellElement.innerHTML = this.formatValue(groupRowFor);
  }
  formatValue(value) {
    if (typeof value === "string") {
      value = DateHelper.parse(value, this.format || void 0);
    }
    return DateHelper.format(value, this.format || void 0);
  }
  set format(value) {
    const {
      editor
    } = this.data;
    this.set("format", value);
    if (editor) {
      editor.format = value;
    }
  }
  get format() {
    return this.get("format");
  }
  get defaultEditor() {
    const me = this, {
      min: min2,
      max,
      step,
      format
    } = me;
    return {
      name: me.field,
      type: "date",
      calendarContainerCls: "b-grid-cell-editor-related",
      weekStartDay: me.grid.weekStartDay,
      format,
      max,
      min: min2,
      step
    };
  }
};
_defineProperty(DateColumn, "$name", "DateColumn");
_defineProperty(DateColumn, "type", "date");
_defineProperty(DateColumn, "fieldType", "date");
_defineProperty(DateColumn, "fields", ["format", "pickerFormat", "step", "min", "max"]);
ColumnStore.registerColumnType(DateColumn, true);
DateColumn.exposeProperties();
DateColumn._$name = "DateColumn";
var PercentColumn = class extends NumberColumn {
  static get defaults() {
    return {
      min: 0,
      max: 100,
      showValue: false,
      lowThreshold: 20,
      htmlEncode: false,
      searchable: false,
      summaryRenderer: (sum) => `${sum}%`,
      fitMode: false
    };
  }
  constructor(config, store) {
    super(...arguments);
    this.internalCellCls = "b-percent-bar-cell";
  }
  defaultRenderer({
    value
  }) {
    value = value || 0;
    return {
      className: "b-percent-bar-outer",
      role: "progressbar",
      "aria-Valuemin": 0,
      "aria-Valuemax": 100,
      "aria-Valuenow": value,
      tabIndex: 0,
      children: [{
        tag: "div",
        className: {
          "b-percent-bar": 1,
          "b-zero": value === 0,
          "b-low": value < this.lowThreshold
        },
        style: {
          width: value + "%"
        },
        children: [this.showValue ? {
          tag: "span",
          text: value + "%"
        } : void 0]
      }]
    };
  }
  resizeToFitContent() {
  }
};
_defineProperty(PercentColumn, "type", "percent");
_defineProperty(PercentColumn, "fieldType", "number");
_defineProperty(PercentColumn, "fields", ["showValue", "lowThreshold"]);
PercentColumn.sum = "average";
ColumnStore.registerColumnType(PercentColumn, true);
PercentColumn._$name = "PercentColumn";
var RatingColumn = class extends NumberColumn {
  static get defaults() {
    return {
      min: 0,
      max: 5,
      emptyIcon: "b-icon b-icon-star",
      filledIcon: "b-icon b-icon-star",
      editable: true,
      filterType: "number",
      searchable: false,
      width: "11.2em",
      htmlEncode: false,
      minWidth: "11.2em",
      editor: false,
      fitMode: "value"
    };
  }
  renderer({
    value
  }) {
    return {
      className: {
        "b-rating-cell-inner": 1,
        "b-not-editable": !this.editable
      },
      children: ArrayHelper.populate(this.max, (i) => {
        const filled = i < value;
        return {
          tag: "i",
          className: {
            "b-rating-icon": true,
            "b-filled": filled,
            "b-empty": !filled,
            [filled ? this.filledIcon : this.emptyIcon]: true
          }
        };
      })
    };
  }
  onCellClick({
    grid,
    column,
    record,
    target,
    event
  }) {
    if (target.classList.contains("b-rating-icon") && !grid.readOnly && column.editable) {
      let starIndex = [].indexOf.call(target.parentNode.childNodes, target);
      if (target.classList.contains("b-filled") && (event.metaKey || event.shiftKey)) {
        starIndex = starIndex - 1;
      }
      if (record.get(column.field) === 1 && starIndex === 0) {
        starIndex = -1;
      }
      record.set(column.field, starIndex + 1);
    }
  }
};
_defineProperty(RatingColumn, "$name", "RatingColumn");
_defineProperty(RatingColumn, "type", "rating");
_defineProperty(RatingColumn, "fieldType", "number");
_defineProperty(RatingColumn, "fields", ["emptyIcon", "filledIcon", "editable"]);
ColumnStore.registerColumnType(RatingColumn, true);
RatingColumn.exposeProperties();
RatingColumn._$name = "RatingColumn";
var RowNumberColumn = class extends Column {
  static get defaults() {
    return {
      groupable: false,
      sortable: false,
      filterable: false,
      searchable: false,
      resizable: false,
      draggable: false,
      minWidth: 50,
      width: 50,
      align: "center",
      text: "#",
      editor: false
    };
  }
  construct(config) {
    super.construct(...arguments);
    const me = this, {
      grid
    } = me;
    me.internalCellCls = "b-row-number-cell";
    me.externalHeaderRenderer = me.headerRenderer;
    me.headerRenderer = me.internalHeaderRenderer;
    if (grid) {
      grid.ion({
        bindStore: "bindStore",
        thisObj: me
      });
      me.bindStore({
        store: grid.store,
        initial: true
      });
      if (grid.store.count && !grid.rendered) {
        grid.ion({
          paint: "resizeToFitContent",
          thisObj: me,
          once: true
        });
      }
    }
  }
  get groupHeaderReserved() {
    return true;
  }
  bindStore({
    store,
    initial
  }) {
    const me = this;
    me.detachListeners("grid");
    store.ion({
      name: "grid",
      [`change${me.grid.asyncEventSuffix}`]: "onStoreChange",
      thisObj: me
    });
    if (!initial) {
      me.resizeToFitContent();
    }
  }
  onStoreChange({
    action
  }) {
    if (action === "dataset" || action === "add" || action === "remove" || action === "removeall") {
      this.resizeToFitContent();
    }
  }
  renderer({
    record,
    grid
  }) {
    return record.isSpecialRow ? "" : grid.store.indexOf(record, true) + 1;
  }
  resizeToFitContent() {
    const {
      grid
    } = this, {
      store
    } = grid, {
      count
    } = store;
    if (count && !this.hidden) {
      const cellElement = grid.element.querySelector(`.b-grid-cell[data-column-id="${this.id}"]`);
      if (cellElement) {
        const cellPadding = parseInt(DomHelper.getStyleValue(cellElement, "padding-left")), maxWidth = DomHelper.measureText(count, cellElement);
        this.width = Math.max(this.minWidth, maxWidth + 2 * cellPadding);
      }
    }
  }
  set flex(f) {
  }
  internalHeaderRenderer({
    headerElement,
    column
  }) {
    var _column$externalHeade;
    headerElement.classList.add("b-rownumber-header");
    return ((_column$externalHeade = column.externalHeaderRenderer) === null || _column$externalHeade === void 0 ? void 0 : _column$externalHeade.call(this, ...arguments)) || column.headerText;
  }
};
_defineProperty(RowNumberColumn, "$name", "RowNumberColumn");
_defineProperty(RowNumberColumn, "type", "rownumber");
ColumnStore.registerColumnType(RowNumberColumn, true);
RowNumberColumn._$name = "RowNumberColumn";
var TemplateColumn = class extends Column {
  static get defaults() {
    return {
      htmlEncode: false
    };
  }
  constructor(config, store) {
    super(...arguments);
    const me = this;
    if (!me.template) {
      throw new Error("TemplateColumn needs a template");
    }
    if (typeof me.template !== "function") {
      throw new Error("TemplateColumn.template must be a function");
    }
  }
  renderer(renderData) {
    if (!renderData.record.isSpecialRow) {
      return this.template({
        value: renderData.value,
        record: renderData.record,
        field: renderData.column.field
      });
    }
  }
};
_defineProperty(TemplateColumn, "type", "template");
_defineProperty(TemplateColumn, "fields", [
  "template"
]);
ColumnStore.registerColumnType(TemplateColumn, true);
TemplateColumn.exposeProperties();
TemplateColumn._$name = "TemplateColumn";
var TimeColumn = class extends Column {
  static get defaults() {
    return {
      format: "LT",
      minWidth: 140,
      filterType: "time"
    };
  }
  defaultRenderer({
    value
  }) {
    return value ? this.formatValue(value) : "";
  }
  groupRenderer({
    cellElement,
    groupRowFor
  }) {
    cellElement.innerHTML = this.formatValue(groupRowFor);
  }
  formatValue(value) {
    if (typeof value === "string") {
      value = DateHelper.parse(value, this.format);
    }
    return DateHelper.format(value, this.format);
  }
  set format(value) {
    const {
      editor
    } = this;
    this.set("format", value);
    if (editor) {
      editor.format = value;
    }
  }
  get format() {
    return this.get("format");
  }
  get defaultEditor() {
    return {
      name: this.field,
      type: "time",
      format: this.format
    };
  }
};
_defineProperty(TimeColumn, "type", "time");
_defineProperty(TimeColumn, "fieldType", "date");
_defineProperty(TimeColumn, "fields", ["format"]);
ColumnStore.registerColumnType(TimeColumn, true);
TimeColumn.exposeProperties();
TimeColumn._$name = "TimeColumn";
var currentParentHasIcon = false;
var TreeColumn = class extends Column {
  static get defaults() {
    return {
      tree: true,
      hideable: false,
      minWidth: 150
    };
  }
  static get fields() {
    return [
      {
        name: "expandIconCls",
        defaultValue: "b-icon b-icon-tree-expand"
      },
      {
        name: "collapseIconCls",
        defaultValue: "b-icon b-icon-tree-collapse"
      },
      {
        name: "collapsedFolderIconCls"
      },
      {
        name: "expandedFolderIconCls"
      },
      {
        name: "indentSize",
        defaultValue: 1.7
      },
      {
        name: "leafIconCls",
        defaultValue: "b-icon b-icon-tree-leaf"
      },
      {
        name: "editTargetSelector",
        defaultValue: ".b-tree-cell-value"
      },
      "renderer"
    ];
  }
  constructor(config, store) {
    super(...arguments);
    const me = this;
    me.shouldHtmlEncode = me.htmlEncode;
    me.setData("htmlEncode", false);
    if (me.renderer) {
      me.originalRenderer = me.renderer;
    }
    me.renderer = me.treeRenderer.bind(me);
  }
  treeRenderer(renderData) {
    const me = this, {
      grid,
      column,
      cellElement,
      row,
      record,
      isExport
    } = renderData, gridMeta = record.instanceMeta(grid.store), isCollapsed = !record.isLeaf && gridMeta.collapsed, innerConfig = {
      className: "b-tree-cell-value"
    }, children = [innerConfig], result = {
      className: "b-tree-cell-inner",
      tag: record.href ? "a" : "div",
      href: record.href,
      target: record.target,
      children
    }, rowClasses = {
      "b-tree-parent-row": 0,
      "b-tree-collapsed": 0,
      "b-tree-expanded": 0,
      "b-loading-children": 0
    };
    let outputIsObject, iconCls, {
      value
    } = renderData;
    if (me.originalRenderer) {
      var _grid$hasFrameworkRen;
      const rendererHtml = me.originalRenderer(renderData), hasFrameworkRenderer = (_grid$hasFrameworkRen = grid.hasFrameworkRenderer) === null || _grid$hasFrameworkRen === void 0 ? void 0 : _grid$hasFrameworkRen.call(grid, {
        cellContent: rendererHtml,
        column
      });
      outputIsObject = typeof rendererHtml === "object" && !hasFrameworkRenderer;
      value = hasFrameworkRenderer ? "" : rendererHtml === false ? cellElement.innerHTML : rendererHtml;
      renderData.rendererHtml = rendererHtml;
    }
    if (!outputIsObject) {
      var _value;
      value = String((_value = value) !== null && _value !== void 0 ? _value : "");
    }
    if (isExport) {
      return value;
    }
    if (!record.isLeaf) {
      var _record$children;
      const isCollapsed2 = !record.isExpanded(grid.store), expanderIconCls = isCollapsed2 ? me.expandIconCls : me.collapseIconCls, folderIconCls = isCollapsed2 ? me.collapsedFolderIconCls : me.expandedFolderIconCls;
      rowClasses["b-tree-parent-row"] = 1;
      rowClasses["b-tree-collapsed"] = isCollapsed2;
      rowClasses["b-tree-expanded"] = !isCollapsed2;
      rowClasses["b-loading-children"] = gridMeta.isLoadingChildren;
      cellElement.classList.add("b-tree-parent-cell");
      children.unshift({
        tag: "i",
        className: {
          "b-tree-expander": 1,
          [expanderIconCls]: 1,
          "b-empty-parent": !gridMeta.isLoadingChildren && record.children !== true && !((_record$children = record.children) !== null && _record$children !== void 0 && _record$children.length)
        }
      });
      currentParentHasIcon = iconCls = renderData.iconCls || record.iconCls || folderIconCls;
    } else {
      cellElement.classList.add("b-tree-leaf-cell");
      iconCls = renderData.iconCls || record.iconCls || me.leafIconCls;
    }
    if (iconCls) {
      children.splice(children.length - 1, 0, {
        tag: "i",
        className: {
          "b-tree-icon": 1,
          [iconCls]: 1
        }
      });
    }
    if (row.isRow) {
      row.assignCls(rowClasses);
      if (!record.isLeaf) {
        row.setAttribute("aria-expanded", !isCollapsed);
        if (isCollapsed) {
          row.removeAttribute("aria-owns");
        } else {
          for (const region in grid.subGrids) {
            var _record$children2, _record$children3;
            const el = row.elements[region];
            DomHelper.setAttributes(el, {
              "aria-owns": (_record$children2 = record.children) !== null && _record$children2 !== void 0 && _record$children2.length ? (_record$children3 = record.children) === null || _record$children3 === void 0 ? void 0 : _record$children3.map((r) => `${grid.id}-${region}-${r.id}`).join(" ") : null
            });
          }
        }
      }
    }
    if (outputIsObject || me.shouldHtmlEncode || !value.includes("<")) {
      if (outputIsObject) {
        Object.assign(innerConfig, value);
      }
      innerConfig.children = innerConfig.children || [];
      innerConfig.children.unshift(outputIsObject ? null : value);
    } else {
      innerConfig.html = value;
    }
    const padding = record.childLevel * me.indentSize + (record.isLeaf ? currentParentHasIcon ? 2 : iconCls ? 0.5 : 0.4 : 0);
    result.style = `padding-inline-start:${padding}em`;
    return result;
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    result.renderer = this.originalRenderer;
    return result;
  }
};
_defineProperty(TreeColumn, "$name", "TreeColumn");
_defineProperty(TreeColumn, "type", "tree");
ColumnStore.registerColumnType(TreeColumn, true);
TreeColumn.exposeProperties();
TreeColumn._$name = "TreeColumn";
var GridRowModel = class extends Model {
  static get fields() {
    return [
      {
        name: "iconCls",
        internal: true
      },
      {
        name: "expanded",
        internal: true
      },
      {
        name: "cls",
        internal: true
      },
      {
        name: "rowHeight",
        internal: true
      },
      {
        name: "href",
        internal: true
      },
      {
        name: "target",
        internal: true
      }
    ];
  }
};
GridRowModel.exposeProperties();
GridRowModel._$name = "GridRowModel";
var consumerToFeatureMap = /* @__PURE__ */ new Map();
var consumerToDefaultFeatureMap = /* @__PURE__ */ new Map();
var DEFAULT_FOR_TYPE = "Grid";
var remapToBase = {
  Grid: "GridBase",
  Scheduler: "SchedulerBase",
  SchedulerPro: "SchedulerProBase",
  Gantt: "GanttBase"
};
var classNameFix = /\$\d+$/;
var GridFeatureManager = class {
  static registerFeature(featureClass, onByDefault = false, forType = null, as = null) {
    as = StringHelper.uncapitalize(as || Object.prototype.hasOwnProperty.call(featureClass, "$name") && featureClass.$$name || featureClass.name);
    as = as.replace(classNameFix, "");
    if (!Array.isArray(forType)) {
      forType = [forType || DEFAULT_FOR_TYPE];
    }
    forType.forEach((forType2) => {
      const type = remapToBase[forType2] || forType2, consumerFeaturesMap = consumerToFeatureMap.get(type) || /* @__PURE__ */ new Map(), consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type) || /* @__PURE__ */ new Map();
      consumerFeaturesMap.set(as, featureClass);
      consumerDefaultFeaturesMap.set(featureClass, onByDefault);
      consumerToFeatureMap.set(type, consumerFeaturesMap);
      consumerToDefaultFeatureMap.set(type, consumerDefaultFeaturesMap);
    });
  }
  static getTypeNameFeatures(forType = DEFAULT_FOR_TYPE) {
    const type = remapToBase[forType] || forType, consumerFeaturesMap = consumerToFeatureMap.get(type), features = {};
    if (consumerFeaturesMap) {
      consumerFeaturesMap.forEach((featureClass, as) => features[as] = featureClass);
    }
    return features;
  }
  static getTypeNameDefaultFeatures(forType = DEFAULT_FOR_TYPE) {
    const type = remapToBase[forType] || forType, consumerFeaturesMap = consumerToFeatureMap.get(type), consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type);
    const features = {};
    if (consumerFeaturesMap && consumerDefaultFeaturesMap) {
      consumerFeaturesMap.forEach((featureClass, as) => {
        if (consumerDefaultFeaturesMap.get(featureClass)) {
          features[as] = featureClass;
        }
      });
    }
    return features;
  }
  static getInstanceFeatures(instance) {
    return instance.$meta.names.reduce((features, typeName) => Object.assign(features, this.getTypeNameFeatures(typeName)), {});
  }
  static getInstanceDefaultFeatures(instance) {
    return instance.$meta.names.reduce((features, typeName) => Object.entries(this.getTypeNameFeatures(typeName)).reduce((features2, [as, featureClass]) => {
      if (this.isDefaultFeatureForTypeName(featureClass, typeName)) {
        features2[as] = featureClass;
      } else {
        delete features2[as];
      }
      return features2;
    }, features), {});
  }
  static isDefaultFeatureForTypeName(featureClass, forType = DEFAULT_FOR_TYPE) {
    const type = remapToBase[forType] || forType, consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type);
    return consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.get(featureClass) || false;
  }
  static isDefaultFeatureForInstance(featureClass, instance) {
    const typeChain = instance.$meta.names.slice().reverse();
    let result = null;
    for (let i = 0, len = typeChain.length; i < len && result === null; ++i) {
      const consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(typeChain[i]);
      if (consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.has(featureClass)) {
        result = consumerDefaultFeaturesMap.get(featureClass);
      }
    }
    return result || false;
  }
  static reset() {
    consumerToFeatureMap.clear();
    consumerToDefaultFeatureMap.clear();
  }
};
var CellCopyPaste = class extends InstancePlugin {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "entityName", "cell");
  }
  afterConstruct() {
    super.afterConstruct();
    this.afterSelectionModeChange();
  }
  afterSelectionModeChange() {
    const me = this;
    if (!me.client.selectionMode.cell) {
      me.disabled = true;
    } else if (me._disabledBySelectionMode) {
      me.disabled = false;
      delete me._disabledBySelectionMode;
    }
  }
  get copyOnly() {
    var _this$client$features;
    return this._copyOnly || !((_this$client$features = this.client.features.cellEdit) !== null && _this$client$features !== void 0 && _this$client$features.enabled);
  }
  get canCopy() {
    return !this.disabled && !this.client.selectedRecords.length && this.client.selectedCells.length;
  }
  get canCutPaste() {
    var _this$client$features2;
    return this.canCopy && !this.copyOnly && !((_this$client$features2 = this.client.features.cellEdit) !== null && _this$client$features2 !== void 0 && _this$client$features2.isEditing) && !this.client.readOnly;
  }
  isActionAvailable(key, action) {
    return this.canCopy && (action === "copy" || this.canCutPaste);
  }
  async sendToClipboard(cells) {
    const me = this;
    let lastRowIndex = 0, lastColIndex = 0, stringData = "";
    cells.sort((c1, c2) => c1.rowIndex === c2.rowIndex ? c1.columnIndex - c2.columnIndex : c1.rowIndex - c2.rowIndex);
    for (const cell of cells) {
      var _column$toClipboardSt, _cellValue;
      const {
        record,
        column,
        rowIndex,
        columnIndex
      } = cell;
      if (rowIndex > lastRowIndex) {
        if (stringData.length > 0) {
          stringData += "\n".repeat(rowIndex - lastRowIndex);
        }
        lastRowIndex = rowIndex;
        lastColIndex = columnIndex;
      } else if (columnIndex > lastColIndex) {
        if (stringData.length > 0) {
          stringData += "	".repeat(columnIndex - lastColIndex);
        }
        lastColIndex = columnIndex;
      }
      let cellValue = (_column$toClipboardSt = column.toClipboardString) === null || _column$toClipboardSt === void 0 ? void 0 : _column$toClipboardSt.call(column, cell);
      if (cellValue === void 0) {
        var _record$get;
        cellValue = (_record$get = record.get(column.field)) === null || _record$get === void 0 ? void 0 : _record$get.toString();
      }
      if (me.toCopyString) {
        cellValue = me.toCopyString({
          currentValue: cellValue,
          column,
          record
        });
      }
      cellValue = (_cellValue = cellValue) === null || _cellValue === void 0 ? void 0 : _cellValue.replace(/[\n\t]/, " ");
      stringData += cellValue || me.emptyValueChar;
    }
    await BrowserHelper.writeToClipboard(stringData, this.useNativeClipboard);
    return stringData;
  }
  async cut() {
    await this.copy(true);
  }
  async copy(cut) {
    const me = this, {
      client,
      entityName
    } = me, isCut = typeof cut === "boolean" ? cut : false, cells = isCut ? client.selectedCells.filter((r) => {
      var _r$record;
      return !((_r$record = r.record) !== null && _r$record !== void 0 && _r$record.readOnly);
    }) : client.selectedCells;
    if (cells) {
      if ((isCut ? !me.canCutPaste : !me.canCopy) || client.trigger("beforeCopy", {
        cells,
        isCut,
        entityName
      }) === false) {
        return;
      }
      const copiedDataString = await me.sendToClipboard(cells);
      if (isCut === true) {
        for (const cell of cells) {
          if (!cell.column.readOnly) {
            cell.record.set(cell.column.field, null);
          }
        }
      }
      client.trigger("copy", {
        cells,
        copiedDataString,
        isCut,
        entityName
      });
    }
  }
  async paste() {
    const me = this, {
      client,
      entityName
    } = me, clipboardData = await BrowserHelper.readFromClipboard(me.useNativeClipboard), targetCell = client.selectedCells[0];
    if (!me.canCutPaste || !(clipboardData !== null && clipboardData !== void 0 && clipboardData.length) || !targetCell || client.trigger("beforePaste", {
      clipboardData,
      targetCell,
      entityName
    }) === false) {
      return;
    }
    const modifiedRecords = /* @__PURE__ */ new Set(), rows = me.stringAs2dArray(clipboardData), targetCells = [], {
      _shiftSelectRange
    } = client;
    if (!(rows !== null && rows !== void 0 && rows.length)) {
      return;
    }
    if (_shiftSelectRange !== null && _shiftSelectRange !== void 0 && _shiftSelectRange.some((cell) => cell.equals(targetCell))) {
      const cellRows = me.cellSelectorsAs2dArray(_shiftSelectRange);
      if ((cellRows === null || cellRows === void 0 ? void 0 : cellRows.length) % rows.length === 0 && cellRows.columnCount % rows.columnCount === 0) {
        for (let curI = 0; curI < cellRows.length; curI += rows.length) {
          for (let curX = 0; curX < cellRows.columnCount; curX += rows.columnCount) {
            targetCells.push(cellRows[curI][curX]);
          }
        }
      }
    }
    if (!targetCells.length) {
      targetCells.push(targetCell);
    }
    for (const targetCell2 of targetCells) {
      for (let rI = 0; rI < rows.length; rI++) {
        const row = rows[rI], targetRecord = client.store.getAt(targetCell2.rowIndex + rI);
        if (targetRecord && !targetRecord.readOnly) {
          for (let cI = 0; cI < row.length; cI++) {
            const targetColumn = client.columns.getAt(targetCell2.columnIndex + cI), targetField = targetColumn === null || targetColumn === void 0 ? void 0 : targetColumn.field;
            let value = row[cI];
            if (targetField && value && !targetColumn.readOnly) {
              if (value === me.emptyValueChar) {
                value = null;
              }
              if (targetColumn.fromClipboardString) {
                value = targetColumn.fromClipboardString({
                  string: value,
                  record: targetRecord
                });
              }
              if (me.toPasteValue) {
                value = me.toPasteValue({
                  currentValue: value,
                  record: targetRecord,
                  column: targetColumn,
                  field: targetField
                });
              }
              targetRecord.set(targetField, value, false, false, false, true);
              modifiedRecords.add(targetRecord);
            }
          }
        }
      }
    }
    client.trigger("paste", {
      clipboardData,
      targetCell,
      modifiedRecords: [...modifiedRecords],
      entityName
    });
  }
  cellSelectorsAs2dArray(locations) {
    const rows = [];
    let rId = null, columns;
    for (const location of locations) {
      if (location.id !== rId) {
        rId = location.id;
        columns = [];
        rows.push(columns);
      }
      columns.push(location);
    }
    rows.columnCount = rows[0].length;
    if (rows.some((row) => row.length !== rows.columnCount)) {
      return false;
    }
    return rows;
  }
  stringAs2dArray(string2) {
    const rows = [], stringRows = string2.split(/\r\n|(?!\r\n)[\n-\r\x85\u2028\u2029]/);
    for (const row of stringRows) {
      const columns = row.split("	");
      if (rows.columnCount && columns.length !== rows.columnCount) {
        return false;
      }
      rows.columnCount = columns.length;
      rows.push(columns);
    }
    return rows;
  }
  populateCellMenu({
    record,
    items: items2
  }) {
    const me = this;
    if (me.canCopy) {
      items2.cutCell = {
        text: me.cutText,
        localeClass: me,
        icon: "b-icon b-icon-cut",
        weight: 115,
        disabled: record.readOnly || !me.canCutPaste,
        onItem: () => me.cut()
      };
      items2.pasteCell = {
        text: me.pasteText,
        localeClass: me,
        icon: "b-icon b-icon-paste",
        weight: 120,
        disabled: record.readOnly || !me.canCutPaste,
        onItem: () => me.paste()
      };
      items2.copyCell = {
        text: me.copyText,
        localeClass: me,
        cls: "b-separator",
        icon: "b-icon b-icon-copy",
        weight: 110,
        onItem: () => me.copy()
      };
    }
  }
};
_defineProperty(CellCopyPaste, "$name", "CellCopyPaste");
_defineProperty(CellCopyPaste, "pluginConfig", {
  chain: ["populateCellMenu", "afterSelectionModeChange"]
});
_defineProperty(CellCopyPaste, "configurable", {
  copyOnly: null,
  emptyValueChar: " ",
  keyMap: {
    "Ctrl+C": "copy",
    "Ctrl+X": "cut",
    "Ctrl+V": "paste"
  },
  useNativeClipboard: !VersionHelper.isTestEnv,
  toCopyString: null,
  toPasteValue: null,
  copyText: "L{copy}",
  cutText: "L{cut}",
  pasteText: "L{paste}"
});
CellCopyPaste._$name = "CellCopyPaste";
GridFeatureManager.registerFeature(CellCopyPaste);
var editingActions = {
  finishAndEditNextRow: 1,
  finishAndEditPrevRow: 1,
  finishEditing: 1,
  cancelEditing: 1,
  finishAndEditNextCell: 1,
  finishAndEditPrevCell: 1
};
var CellEdit = class extends Delayable(InstancePlugin) {
  static get defaultConfig() {
    return {
      autoSelect: true,
      blurAction: "complete",
      continueEditingOnCellClick: true,
      addNewAtEnd: null,
      autoEdit: null,
      editNextOnEnterPress: true,
      editorClass: Editor,
      triggerEvent: "celldblclick",
      touchEditDelay: 300,
      focusCellAnimationDuration: false,
      multiEdit: true,
      keyMap: {
        Enter: ["startEditing", "finishAndEditNextRow"],
        "Ctrl+Enter": ["finishAllSelected", "finishEditing"],
        "Shift+Enter": "finishAndEditPrevRow",
        "Alt+Enter": "finishEditing",
        F2: ["startEditing", "finishEditing"],
        Escape: "cancelEditing",
        Tab: "finishAndEditNextCell",
        "Shift+Tab": "finishAndEditPrevCell"
      }
    };
  }
  static get pluginConfig() {
    return {
      assign: ["startEditing", "finishEditing", "cancelEditing"],
      before: ["onElementKeyDown", "onElementPointerUp"],
      chain: ["onElementClick", "bindStore"]
    };
  }
  construct(grid, config) {
    super.construct(grid, config);
    const me = this, gridListeners = {
      renderRows: "onGridRefreshed",
      cellClick: "onCellClick",
      thisObj: me
    };
    me.grid = grid;
    if (me.triggerEvent !== "cellclick") {
      gridListeners[me.triggerEvent] = "onTriggerEditEvent";
    }
    if (me.autoEdit && !("editNextOnEnterPress" in config)) {
      me.editNextOnEnterPress = false;
    }
    grid.ion(gridListeners);
    grid.rowManager.ion({
      changeTotalHeight: "onGridRefreshed",
      thisObj: me
    });
    me.bindStore(grid.store);
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      update: "onStoreUpdate",
      beforeSort: "onStoreBeforeSort",
      thisObj: this
    });
  }
  async confirm(options) {
    let result = true;
    if (this.editorContext) {
      MessageDialog.owner = this.editorContext.editor.inputField;
      options.rootElement = this.grid.rootElement;
      result = await MessageDialog.confirm(options);
      MessageDialog.owner = null;
    }
    return result === MessageDialog.yesButton;
  }
  doDestroy() {
    this.grid.columns.allRecords.forEach((column) => {
      var _column$_cellEditor;
      (_column$_cellEditor = column._cellEditor) === null || _column$_cellEditor === void 0 ? void 0 : _column$_cellEditor.destroy();
    });
    super.doDestroy();
  }
  doDisable(disable) {
    if (disable && !this.isConfiguring) {
      this.cancelEditing(true);
    }
    super.doDisable(disable);
  }
  set disabled(disabled) {
    super.disabled = disabled;
  }
  get disabled() {
    const {
      grid
    } = this;
    return Boolean(super.disabled || grid.disabled || grid.readOnly);
  }
  get isEditing() {
    return Boolean(this.editorContext);
  }
  get activeRecord() {
    var _this$editorContext;
    return ((_this$editorContext = this.editorContext) === null || _this$editorContext === void 0 ? void 0 : _this$editorContext.record) || null;
  }
  getEditorForCell({
    id,
    cell,
    column,
    columnId,
    editor
  }) {
    var _cellEditor;
    const me = this, {
      grid,
      editorClass
    } = me;
    let cellEditor = column.cellEditor, leftOffset = 0;
    if (column.editTargetSelector) {
      const editorTarget = cell.querySelector(column.editTargetSelector);
      leftOffset = editorTarget.offsetLeft;
    }
    editor.autoSelect = me.autoSelect;
    if (!((_cellEditor = cellEditor) !== null && _cellEditor !== void 0 && _cellEditor.isEditor)) {
      cellEditor = column.data.cellEditor = editorClass.create(editorClass.mergeConfigs({
        type: editorClass.type,
        constrainTo: null,
        cls: "b-cell-editor",
        inputField: editor,
        blurAction: "none",
        invalidAction: column.invalidAction,
        completeKey: false,
        cancelKey: false,
        owner: grid,
        align: {
          align: "t0-t0",
          offset: [leftOffset, 0]
        },
        internalListeners: me.getEditorListeners(),
        onInternalKeyDown: me.onEditorKeydown.bind(me),
        allowMouseEvents: editor.allowMouseEvents
      }, cellEditor));
    }
    cellEditor.minHeight = grid.rowHeight;
    if (cellEditor.inputField !== editor) {
      cellEditor.remove(cellEditor.items[0]);
      cellEditor.add(editor);
    }
    cellEditor.align.offset[0] = leftOffset;
    if (column.instantUpdate && !editor.cellEditValueSetter) {
      ObjectHelper.wrapProperty(editor, "value", null, (value) => {
        const {
          editorContext
        } = me, inputField = editorContext === null || editorContext === void 0 ? void 0 : editorContext.editor.inputField;
        if (editorContext !== null && editorContext !== void 0 && editorContext.editor.isValid && !ObjectHelper.isEqual(editorContext.record[editorContext.column.field], value) && (!(inputField !== null && inputField !== void 0 && inputField.isDateField) || inputField._isPickerInput)) {
          editorContext.record[editorContext.column.field] = value;
        }
      });
      editor.cellEditValueSetter = true;
    }
    Object.assign(cellEditor.element.dataset, {
      rowId: id,
      columnId,
      field: column.field
    });
    cellEditor.inputField.revertOnEscape = column.revertOnEscape;
    return me.editor = cellEditor;
  }
  getEditorListeners() {
    return {
      focusOut: "onEditorFocusOut",
      focusIn: "onEditorFocusIn",
      start: "onEditorStart",
      beforeComplete: "onEditorBeforeComplete",
      complete: "onEditorComplete",
      beforeCancel: "onEditorBeforeCancel",
      cancel: "onEditorCancel",
      beforeHide: "onBeforeEditorHide",
      finishEdit: "onEditorFinishEdit",
      thisObj: this
    };
  }
  onEditorStart({
    source: editor
  }) {
    const me = this, editorContext = me.editorContext = editor.cellEditorContext;
    if (editorContext) {
      var _me$removeEditingList;
      const {
        grid
      } = me;
      if (me.triggerEvent !== "cellclick") {
        me.detachListeners("cellClickWhileEditing");
        grid.ion({
          name: "cellClickWhileEditing",
          cellclick: "onCellClickWhileEditing",
          thisObj: me
        });
      }
      (_me$removeEditingList = me.removeEditingListeners) === null || _me$removeEditingList === void 0 ? void 0 : _me$removeEditingList.call(me);
      me.removeEditingListeners = GlobalEvents$1.addListener({
        globaltap: "onTapOut",
        thisObj: me
      });
      grid.trigger("startCellEdit", {
        grid,
        editorContext
      });
    }
  }
  onEditorBeforeComplete(context) {
    const {
      grid
    } = this, editor = context.source, editorContext = editor.cellEditorContext;
    context.grid = grid;
    context.editorContext = editorContext;
    return grid.trigger("beforeFinishCellEdit", context);
  }
  onEditorComplete({
    source: editor
  }) {
    const {
      grid
    } = this, editorContext = editor.cellEditorContext;
    editorContext.value = editor.inputField.value;
    grid.trigger("finishCellEdit", {
      grid,
      editorContext
    });
  }
  onEditorBeforeCancel() {
    const {
      editorContext
    } = this;
    return this.grid.trigger("beforeCancelCellEdit", {
      editorContext
    });
  }
  onEditorCancel({
    event
  }) {
    const {
      editorContext,
      muteEvents,
      grid
    } = this;
    if (!muteEvents) {
      grid.trigger("cancelCellEdit", {
        grid,
        editorContext,
        event
      });
    }
  }
  onBeforeEditorHide({
    source
  }) {
    const me = this, {
      row,
      cell
    } = source.cellEditorContext;
    cell === null || cell === void 0 ? void 0 : cell.classList.remove("b-editing");
    row === null || row === void 0 ? void 0 : row.removeCls("b-editing");
    me.detachListeners("cellClickWhileEditing");
    me.removeEditingListeners();
  }
  onEditorFinishEdit({
    source
  }) {
    source.cellEditorContext = this.editorContext = null;
  }
  getAdjacentEditableCell(cellInfo, isForward) {
    const {
      grid
    } = this, {
      store,
      columns
    } = grid, {
      visibleColumns
    } = columns;
    let rowId = cellInfo.id, column = columns.getAdjacentVisibleLeafColumn(cellInfo.columnId, isForward);
    while (rowId) {
      if (column) {
        if (column.editor && column.canEdit(store.getById(rowId))) {
          return {
            id: rowId,
            columnId: column.id
          };
        }
        column = columns.getAdjacentVisibleLeafColumn(column, isForward);
      } else {
        const record = store.getAdjacent(cellInfo.id, isForward, false, true);
        rowId = record === null || record === void 0 ? void 0 : record.id;
        if (record) {
          column = isForward ? visibleColumns[0] : visibleColumns[visibleColumns.length - 1];
        }
      }
    }
    return null;
  }
  doAddNewAtEnd() {
    const newRecordConfig = typeof this.addNewAtEnd === "object" ? ObjectHelper.clone(this.addNewAtEnd) : {}, {
      grid
    } = this, record = grid.store.add(newRecordConfig)[0];
    if (!grid.rowManager.getRowFor(record)) {
      grid.rowManager.displayRecordAtBottom();
    }
    return record;
  }
  getEditingContext(cellContext) {
    cellContext = this.grid.normalizeCellContext(cellContext);
    const {
      column,
      record
    } = cellContext;
    if (column !== null && column !== void 0 && column.isVisible && column.editor && record && !record.isSpecialRow && !record.readOnly && column.canEdit(record)) {
      const value = record ? column.getRawValue(record) : record;
      Object.assign(cellContext, {
        value: value === void 0 ? null : value,
        editor: column.editor
      });
      return cellContext;
    } else {
      return false;
    }
  }
  async startEditing(cellContext = {}) {
    const me = this;
    if (!me.disabled) {
      var _cellContext, _grid$focusedCell, _me$onCellEditStart;
      const {
        grid
      } = me;
      if ((_cellContext = cellContext) !== null && _cellContext !== void 0 && _cellContext.fromKeyMap) {
        cellContext = me.grid.focusedCell;
      }
      if (ObjectHelper.isEmpty(cellContext)) {
        cellContext.id = grid.firstVisibleRow.id;
      }
      if (grid.store.isTree && grid.features.tree) {
        var _cellContext$record;
        const record2 = cellContext.id ? grid.store.getById(cellContext.id) : (_cellContext$record = cellContext.record) !== null && _cellContext$record !== void 0 ? _cellContext$record : grid.store.getAt(cellContext.row);
        if (record2) {
          await grid.expandTo(record2);
        } else {
          return false;
        }
      }
      const editorContext = me.getEditingContext(cellContext);
      if (!editorContext) {
        return false;
      }
      if (me.editorContext) {
        me.cancelEditing();
      }
      if (!((_grid$focusedCell = grid.focusedCell) !== null && _grid$focusedCell !== void 0 && _grid$focusedCell.equals(editorContext))) {
        grid.focusCell(editorContext);
      }
      if (grid.trigger("beforeCellEditStart", {
        grid,
        editorContext
      }) === false) {
        return false;
      }
      const editor = editorContext.editor = me.getEditorForCell(editorContext), {
        row,
        cell,
        record
      } = editorContext;
      editor.inputField.highlightExternalChange = false;
      editor.cellEditorContext = editorContext;
      editor.render(cell);
      cell.classList.add("b-editing");
      row.addCls("b-editing");
      if (!await editor.startEdit({
        target: cell,
        field: editor.inputField.name || editorContext.column.field,
        value: editorContext.value,
        record
      })) {
        cell.classList.remove("b-editing");
        row.removeCls("b-editing");
      }
      (_me$onCellEditStart = me.onCellEditStart) === null || _me$onCellEditStart === void 0 ? void 0 : _me$onCellEditStart.call(me);
      return true;
    }
    return false;
  }
  cancelEditing(silent = false, triggeredByEvent) {
    var _me$afterCellEdit;
    const me = this, {
      editorContext,
      editor
    } = me;
    if (silent.fromKeyMap) {
      triggeredByEvent = silent;
      silent = false;
    }
    if (editorContext) {
      me.muteEvents = silent;
      editor.cancelEdit(triggeredByEvent);
      me.muteEvents = false;
    }
    me.finishEditingPromise = false;
    (_me$afterCellEdit = me.afterCellEdit) === null || _me$afterCellEdit === void 0 ? void 0 : _me$afterCellEdit.call(me);
  }
  async finishEditing() {
    const me = this, {
      editorContext,
      grid
    } = me;
    let result = false;
    if (me.finishEditingPromise) {
      return me.finishEditingPromise;
    }
    if (editorContext) {
      var _me$afterCellEdit2;
      const {
        column
      } = editorContext;
      me.finishEditingPromise = editorContext.editor.completeEdit(column.bindCallback(column.finalizeCellEdit));
      result = await me.finishEditingPromise;
      await grid.waitForAnimations();
      me.finishEditingPromise = null;
      (_me$afterCellEdit2 = me.afterCellEdit) === null || _me$afterCellEdit2 === void 0 ? void 0 : _me$afterCellEdit2.call(me);
    }
    return result;
  }
  async onCellClickWhileEditing({
    event,
    cellSelector
  }) {
    const me = this;
    if (DomHelper.isTouchEvent) {
      await me.finishEditing();
      return;
    }
    if (me.finishEditingPromise) {
      return;
    }
    if (me.editorContext && !me.editorContext.editor.owns(event.target)) {
      if (me.getEditingContext(cellSelector)) {
        if (await me.finishEditing()) {
          if (me.continueEditingOnCellClick) {
            await me.startEditing(cellSelector);
          }
        } else {
          me.grid.focusCell(me.editorContext);
          me.editor.inputField.focus();
        }
      } else {
        await me.finishEditing();
      }
    }
  }
  async onCellClick({
    source: grid,
    cellSelector,
    target,
    event,
    column
  }) {
    if (column.onCellClick) {
      return;
    }
    const me = this, {
      focusedCell
    } = me.client;
    if (target.closest(".b-tree-expander")) {
      return false;
    } else if (DomHelper.isTouchEvent && me._lastCellClicked === (focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.cell) && event.timeStamp - me.touchEditDelay > me._lastCellClickedTime) {
      await me.startEditing(cellSelector);
    } else if (this.triggerEvent === "cellclick") {
      await me.onTriggerEditEvent({
        cellSelector,
        target
      });
    }
    me._lastCellClicked = focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.cell;
    me._lastCellClickedTime = event.timeStamp;
  }
  onElementPointerUp(event) {
    if (event.target.closest(".b-tree-expander")) {
      this.cancelEditing(void 0, event);
    }
  }
  async onTriggerEditEvent({
    cellSelector,
    target,
    event
  }) {
    var _client$features$cell;
    const {
      editorContext,
      client
    } = this;
    if (target.closest(".b-tree-expander") || DomHelper.isTouchEvent && event.type === "dblclick") {
      return;
    }
    if (event && ((_client$features$cell = client.features.cellMenu) === null || _client$features$cell === void 0 ? void 0 : _client$features$cell.triggerEvent) === event.type) {
      return;
    }
    if (editorContext) {
      if (editorContext.equals(this.grid.normalizeCellContext(cellSelector)) || !await this.finishEditing()) {
        return;
      }
    }
    await this.startEditing(cellSelector);
  }
  onStoreUpdate({
    changes,
    record
  }) {
    const {
      editorContext
    } = this;
    if (editorContext !== null && editorContext !== void 0 && editorContext.editor.isVisible) {
      if (record === editorContext.record && editorContext.editor.dataField in changes) {
        editorContext.editor.refreshEdit();
      }
    }
  }
  onStoreBeforeSort() {
    var _this$editorContext2;
    const editor = (_this$editorContext2 = this.editorContext) === null || _this$editorContext2 === void 0 ? void 0 : _this$editorContext2.editor;
    if (this.isEditing && !(editor !== null && editor !== void 0 && editor.isFinishing) && !editor.isValid) {
      this.cancelEditing();
    }
  }
  onGridRefreshed() {
    const me = this, {
      grid,
      editorContext
    } = me;
    if (editorContext && grid.isVisible && grid.focusedCell) {
      const cell = grid.getCell(grid.focusedCell), {
        editor
      } = editorContext;
      if (cell && DomHelper.isInView(cell) && !editor.isFinishing) {
        editorContext._cell = cell;
        GlobalEvents$1.suspendFocusEvents();
        editor.render(cell);
        editor.showBy(cell);
        editor.focus();
        GlobalEvents$1.resumeFocusEvents();
      } else {
        me.cancelEditing();
      }
    }
  }
  get gridSelection() {
    return [...this.grid.selectedRecords, ...this.grid.selectedCells];
  }
  isActionAvailable(keyCombination, action, event) {
    const me = this;
    action = action.replace("cellEdit.", "");
    if (!me.disabled && !event.target.closest(".b-grid-header")) {
      if (me.isEditing) {
        if (action === "finishAllSelected") {
          return me.multiEdit && me.gridSelection.length > 1;
        } else if (editingActions[action]) {
          return true;
        }
      } else if (action === "startEditing") {
        return me.grid.focusedCell.cell === event.target;
      }
    }
    return false;
  }
  async finishAllSelected() {
    const me = this, {
      dataField,
      record
    } = me.editor;
    if (await me.finishEditing() && !me.isDestroyed) {
      for (const selected of me.gridSelection) {
        if (selected.isModel) {
          if (selected !== record) {
            selected[dataField] = record[dataField];
          }
        } else {
          selected.record.set(selected.column.field, record[dataField]);
        }
      }
    }
  }
  async finishAndEditNextRow(event, previous = false) {
    const me = this, {
      grid
    } = me, {
      record
    } = me.editorContext;
    let nextCell;
    if (await me.finishEditing()) {
      if (me.isDestroyed) {
        return;
      }
      if (!me.isEditing) {
        if (previous) {
          nextCell = grid.internalNextPrevRow(false, true, event, false);
        } else {
          if (me.addNewAtEnd && record === grid.store.last) {
            await me.doAddNewAtEnd();
          }
          if (!me.isDestroyed) {
            nextCell = grid.internalNextPrevRow(true, true, event);
          }
        }
        if (nextCell && me.editNextOnEnterPress && !grid.touch) {
          me.startEditing(nextCell);
        }
      }
    }
  }
  finishAndEditPrevRow(event) {
    this.finishAndEditNextRow(event, true);
  }
  async finishAndEditNextCell(event, previous = false) {
    const me = this, {
      focusedCell
    } = me.grid;
    if (focusedCell) {
      let cellInfo = me.getAdjacentEditableCell(focusedCell, !previous);
      if (!cellInfo && !previous && me.addNewAtEnd) {
        const currentEditableFinalizationResult = await me.finishEditing();
        if (currentEditableFinalizationResult === true) {
          await this.doAddNewAtEnd();
          cellInfo = !me.isDestroyed && me.getAdjacentEditableCell(focusedCell, !previous);
        }
      }
      if (cellInfo) {
        let finalizationResult = true;
        if (me.isEditing) {
          finalizationResult = await me.finishEditing();
        }
        if (!me.isDestroyed && finalizationResult) {
          me.grid.focusCell(cellInfo, {
            animate: me.focusCellAnimationDuration
          });
          if (!await me.startEditing(cellInfo)) {
            await me.finishAndEditNextCell(event, previous);
          }
        }
      }
    }
  }
  finishAndEditPrevCell(event) {
    this.finishAndEditNextCell(event, true);
  }
  async onElementKeyDown(event) {
    const me = this, {
      grid
    } = me, {
      focusedCell
    } = grid, {
      key
    } = event;
    if (event.handled || !me.autoEdit || me.isEditing || !focusedCell || focusedCell.isActionable || event.ctrlKey) {
      return;
    }
    if (key.length <= 1 && await me.startEditing(focusedCell)) {
      const {
        inputField
      } = me.editor, {
        input
      } = inputField;
      if (input) {
        inputField.internalOnKeyEvent(event);
        if (!event.defaultPrevented) {
          input.value = key;
          inputField.internalOnInput(event);
        }
      }
      event.preventDefault();
    } else if (event.key === "Delete" || event.key === "Backspace") {
      const {
        gridSelection
      } = me;
      if (me.multiEdit && gridSelection.length > 1) {
        for (const selected of gridSelection) {
          if (selected.isModel) {
            grid.visibleColumns.forEach((col) => {
              selected.set(col.field, null);
            });
          } else {
            selected.record.set(selected.column.field, null);
          }
        }
      } else {
        focusedCell.record.set(focusedCell.column.field, null);
      }
    }
  }
  onEditorKeydown(event) {
    if (event.key.startsWith("Arrow")) {
      event.handled = true;
      event.stopPropagation();
      return false;
    }
  }
  async onEditorFocusOut(event) {
    const me = this, {
      grid,
      editor,
      editorContext
    } = me, toCell = new Location(event.relatedTarget), isEditableCellClick = toCell.grid === grid && me.getEditingContext(toCell);
    if (editorContext && !editor.isFinishing && editor.owns(event._target)) {
      if (me.blurAction === "cancel") {
        me.cancelEditing(void 0, event);
      } else if (!me.finishEditingPromise && (me.triggerEvent === "cellclick" || me.triggerEvent !== "cellclick" && !isEditableCellClick)) {
        await me.finishEditing();
      }
    }
  }
  onEditorFocusIn(event) {
    const widget = event.toWidget;
    if (widget === this.editor.inputField) {
      if (this.autoSelect && widget.selectAll && !widget.readOnly && !widget.disabled) {
        widget.selectAll();
      }
    }
  }
  async onTapOut({
    event
  }) {
    const me = this;
    if (!me.grid.bodyContainer.contains(event.target) || event.button) {
      if (!me.editor.owns(event.target)) {
        me.editingStoppedByTapOutside = true;
        if (me.blurAction === "cancel") {
          me.cancelEditing(void 0, event);
        } else {
          await me.finishEditing();
        }
        delete me.editingStoppedByTapOutside;
      }
    }
  }
  async onElementClick(event) {
    if (event.target.classList.contains("b-grid-body-container") && this.editorContext) {
      await this.finishEditing();
    }
  }
};
_defineProperty(CellEdit, "$name", "CellEdit");
CellEdit._$name = "CellEdit";
GridFeatureManager.registerFeature(CellEdit, true);
var CellMenu = class extends ContextMenuBase {
  static get $name() {
    return "CellMenu";
  }
  static get defaultConfig() {
    return {
      processItems: null,
      items: null,
      type: "cell"
    };
  }
  static get pluginConfig() {
    const config = super.pluginConfig;
    config.chain.push("populateCellMenu");
    return config;
  }
  showContextMenu(eventParams) {
    const me = this, {
      cellSelector,
      event
    } = eventParams;
    me.client.focusCell(cellSelector, {
      doSelect: !me.client.isSelected(cellSelector),
      event
    });
    super.showContextMenu(eventParams);
  }
  shouldShowMenu({
    column
  }) {
    return column && column.enableCellContextMenu !== false;
  }
  getDataFromEvent(event) {
    const cellData = this.client.getCellDataFromEvent(event);
    if (cellData) {
      return ObjectHelper.assign(super.getDataFromEvent(event), cellData);
    }
  }
  beforeContextMenuShow({
    record,
    items: items2,
    column
  }) {
    if (column.cellMenuItems === false) {
      return false;
    }
    if (!record || record.isSpecialRow) {
      items2.removeRow = false;
    }
  }
  populateCellMenu({
    items: items2,
    column,
    record
  }) {
    const {
      client
    } = this;
    if (column !== null && column !== void 0 && column.cellMenuItems) {
      ObjectHelper.merge(items2, column.cellMenuItems);
    }
    if (!client.readOnly) {
      items2.removeRow = {
        text: "L{removeRow}",
        localeClass: this,
        icon: "b-fw-icon b-icon-trash",
        cls: "b-separator",
        weight: 100,
        disabled: record.readOnly,
        onItem: () => client.store.remove(client.selectedRecords.filter((r) => !r.readOnly))
      };
    }
  }
  get showMenu() {
    return true;
  }
};
CellMenu.featureClass = "";
CellMenu._$name = "CellMenu";
GridFeatureManager.registerFeature(CellMenu, true, ["Grid", "Scheduler"]);
GridFeatureManager.registerFeature(CellMenu, false, ["Gantt"]);
var CellTooltip = class extends InstancePlugin {
  construct(grid, config) {
    super.construct(grid, this.processConfig(config));
  }
  initTip() {
    const me = this;
    me.tip = Tooltip.new({
      forElement: me.client.element,
      forSelector: ".b-grid-row:not(.b-group-row) .b-grid-cell, .b-grid-merged-cells",
      hoverDelay: 1e3,
      trackMouse: false,
      cls: "b-celltooltip-tip",
      getHtml: me.getTooltipContent.bind(me),
      internalListeners: {
        pointerOver: "onPointerOver",
        thisObj: me
      },
      listeners: me.configuredListeners
    }, me.initialConfig);
    me.relayEvents(me.tip, ["beforeShow", "show"]);
  }
  onPointerOver({
    target
  }) {
    const column = this.client.getColumnFromElement(target);
    return column.tooltipRenderer !== false && Boolean(column.tooltipRenderer || this.tooltipRenderer);
  }
  processConfig(config) {
    if (typeof config === "function") {
      return {
        tooltipRenderer: config
      };
    }
    return config;
  }
  setConfig(config) {
    super.setConfig(this.processConfig(config));
  }
  doDestroy() {
    this.tip && this.tip.destroy();
    super.doDestroy();
  }
  doDisable(disable) {
    if (!disable) {
      this.initTip();
    } else if (this.tip) {
      this.tip.destroy();
      this.tip = null;
    }
    super.doDisable(disable);
  }
  getTooltipContent({
    tip,
    activeTarget: cellElement,
    event
  }) {
    const me = this, record = me.client.getRecordFromElement(cellElement), column = me.client.getColumnFromElement(cellElement), arg = {
      cellElement,
      record,
      column,
      event,
      tip,
      cellTooltip: me
    };
    let result;
    if (!me.forSelector && record === me.lastRecord && record.generation === me.lastRecordGeneration && column === me.lastColumn) {
      return me.tip._html;
    }
    me.lastRecord = record;
    me.lastRecordGeneration = record.generation;
    me.lastColumn = column;
    if (column.tooltipRenderer) {
      result = column.tooltipRenderer(arg);
    } else if (me.tooltipRenderer && column.tooltipRenderer !== false) {
      result = me.tooltipRenderer(arg);
    }
    if (Objects.isPromise(result)) {
      me.lastRecord = me.lastRecordGeneration = me.lastColumn = null;
    }
    return result;
  }
};
_defineProperty(CellTooltip, "$name", "CellTooltip");
_defineProperty(CellTooltip, "configurable", {
  tooltipRenderer: null
});
CellTooltip._$name = "CellTooltip";
GridFeatureManager.registerFeature(CellTooltip);
var storeListenerName$1 = "store";
var ColumnAutoWidth = class extends Delayable(InstancePlugin) {
  static get $name() {
    return "ColumnAutoWidth";
  }
  static get configurable() {
    return {
      default: null,
      delay: 0
    };
  }
  static get pluginConfig() {
    return {
      after: {
        bindStore: "bindStore",
        unbindStore: "unbindStore",
        renderRows: "syncAutoWidthColumns",
        onInternalResize: "onInternalResize"
      },
      assign: ["columnAutoWidthPending", "syncAutoWidthColumns"]
    };
  }
  construct(config) {
    super.construct(config);
    const {
      store
    } = this.client;
    store && this.bindStore(store);
  }
  doDestroy() {
    this.unbindStore();
    super.doDestroy();
  }
  bindStore(store) {
    this.lastSync = null;
    store.ion({
      name: storeListenerName$1,
      [`change${this.client.asyncEventSuffix}`]: "onStoreChange",
      thisObj: this
    });
  }
  unbindStore() {
    this.detachListeners(storeListenerName$1);
  }
  get columnAutoWidthPending() {
    return this.lastSync === null || this.hasTimeout("syncAutoWidthColumns");
  }
  onStoreChange({
    action
  }) {
    if (action !== "move") {
      const me = this, {
        cellEdit
      } = me.client.features;
      ++me.storeGeneration;
      if (cellEdit !== null && cellEdit !== void 0 && cellEdit.isEditing && !cellEdit.editingStoppedByTapOutside) {
        me.syncAutoWidthColumns();
      } else if (!me.hasTimeout("syncAutoWidthColumns")) {
        me.setTimeout("syncAutoWidthColumns", me.delay);
      }
    }
  }
  onInternalResize(element, newWidth, newHeight, oldWidth) {
    if (oldWidth === 0) {
      this.lastSync = null;
      this.syncAutoWidthColumns();
    }
  }
  syncAutoWidthColumns() {
    const me = this, grid = me.client, storeGeneration = me.storeGeneration;
    if (me.lastSync !== storeGeneration) {
      me.lastSync = storeGeneration;
      let autoWidth, resizingColumns;
      for (const column of grid.columns.visibleColumns) {
        autoWidth = column.autoWidth;
        if (autoWidth) {
          if (autoWidth === true) {
            autoWidth = me.default;
          }
          grid.resizingColumns = resizingColumns = true;
          column.resizeToFitContent(autoWidth);
        }
      }
      if (resizingColumns) {
        grid.resizingColumns = false;
        grid.afterColumnsResized();
      }
    }
    if (me.hasTimeout("syncAutoWidthColumns")) {
      me.clearTimeout("syncAutoWidthColumns");
    }
  }
};
ColumnAutoWidth.prototype.storeGeneration = 0;
ColumnAutoWidth._$name = "ColumnAutoWidth";
GridFeatureManager.registerFeature(ColumnAutoWidth, true);
var ColumnDragToolbar = class extends Delayable(InstancePlugin) {
  static get $name() {
    return "ColumnDragToolbar";
  }
  static get pluginConfig() {
    return {
      after: ["render"]
    };
  }
  construct(grid, config) {
    var _grid$features$column;
    (_grid$features$column = grid.features.columnReorder) === null || _grid$features$column === void 0 ? void 0 : _grid$features$column.ion({
      beforeDestroy: "onColumnReorderBeforeDestroy",
      thisObj: this
    });
    this.grid = grid;
    super.construct(grid, config);
  }
  doDestroy() {
    const me = this;
    if (me.grid.features.columnReorder && !me.grid.features.columnReorder.isDestroyed) {
      me.detachFromColumnReorder();
    }
    me.element && me.element.remove();
    me.element = null;
    super.doDestroy();
  }
  doDisable(disable) {
    if (this.initialized) {
      if (disable) {
        this.detachFromColumnReorder();
      } else {
        this.init();
      }
    }
    super.doDisable(disable);
  }
  init() {
    const me = this, grid = me.grid;
    if (!grid.features.columnReorder) {
      return;
    }
    me.reorderDetacher = grid.features.columnReorder.ion({
      gridheaderdragstart({
        context
      }) {
        const column = grid.columns.getById(context.element.dataset.columnId);
        me.showToolbar(column);
      },
      gridheaderdrag: ({
        context
      }) => me.onDrag(context),
      gridheaderabort: () => {
        me.hideToolbar();
      },
      gridheaderdrop: ({
        context
      }) => {
        if (context.valid) {
          me.hideToolbar();
        } else {
          me.onDrop(context);
        }
      },
      thisObj: me
    });
    me.initialized = true;
  }
  onColumnReorderBeforeDestroy() {
    this.detachFromColumnReorder();
  }
  detachFromColumnReorder() {
    const me = this;
    me.grid.features.columnReorder.un("beforedestroy", me.onColumnReorderBeforeDestroy, me);
    me.reorderDetacher && me.reorderDetacher();
    me.reorderDetacher = null;
  }
  render() {
    if (!this.initialized) {
      this.init();
    }
  }
  showToolbar(column) {
    const me = this, buttons = me.grid.getColumnDragToolbarItems(column, []), groups = [];
    me.clearTimeout(me.buttonHideTimer);
    buttons.forEach((button) => {
      button.text = button.localeClass.L(button.text);
      let group = groups.find((group2) => group2.text === button.group);
      if (!group) {
        group = {
          text: button.localeClass.L(button.group),
          buttons: []
        };
        groups.push(group);
      }
      group.buttons.push(button);
    });
    me.element = DomHelper.append(me.grid.element, me.template(groups));
    me.groups = groups;
    me.buttons = buttons;
    me.column = column;
  }
  async hideToolbar() {
    const me = this, element = me.element;
    if (element) {
      element.classList.add("b-remove");
      await EventHelper.waitForTransitionEnd({
        element,
        mode: "animation",
        thisObj: me.client
      });
      element.remove();
      me.element = null;
    }
  }
  onDrag(info) {
    var _info$targetElement;
    const me = this;
    if (info.dragProxy.getBoundingClientRect().top - me.grid.element.getBoundingClientRect().top > 100) {
      me.element.classList.add("b-closer");
    } else {
      me.element.classList.remove("b-closer");
    }
    if (me.hoveringButton) {
      me.hoveringButton.classList.remove("b-hover");
      me.hoveringButton = null;
    }
    if ((_info$targetElement = info.targetElement) !== null && _info$targetElement !== void 0 && _info$targetElement.closest(".b-columndragtoolbar")) {
      me.element.classList.add("b-hover");
      const button = info.targetElement.closest(".b-columndragtoolbar  .b-target-button:not([data-disabled=true])");
      if (button) {
        button.classList.add("b-hover");
        me.hoveringButton = button;
      }
    } else {
      me.element.classList.remove("b-hover");
    }
  }
  onDrop(info) {
    const me = this;
    if (info.targetElement && info.targetElement.matches(".b-columndragtoolbar .b-target-button:not([data-disabled=true])")) {
      const buttonEl = info.targetElement, button = me.buttons.find((button2) => button2.ref === buttonEl.dataset.ref);
      if (button) {
        buttonEl.classList.add("b-activate");
        me.buttonHideTimer = me.setTimeout(() => {
          me.hideToolbar();
          button.onDrop({
            column: me.column
          });
        }, 100);
      }
    } else {
      me.hideToolbar();
    }
  }
  template(groups) {
    return TemplateHelper.tpl`
            <div class="b-columndragtoolbar">     
            <div class="b-title"></div>          
            ${groups.map((group) => TemplateHelper.tpl`
                <div class="b-group">
                    <div class="b-buttons">
                    ${group.buttons.map((btn) => TemplateHelper.tpl`
                        <div class="b-target-button" data-ref="${btn.ref}" data-disabled="${btn.disabled}">
                            <i class="${btn.icon}"></i>
                            ${btn.text}
                        </div>
                    `)}
                    </div>
                    <div class="b-title">${group.text}</div>
                </div>
            `)}
            </div>`;
  }
};
ColumnDragToolbar.featureClass = "b-hascolumndragtoolbar";
ColumnDragToolbar._$name = "ColumnDragToolbar";
GridFeatureManager.registerFeature(ColumnDragToolbar, BrowserHelper.isTouchDevice);
var ColumnPicker = class extends InstancePlugin {
  static get pluginConfig() {
    return {
      chain: ["populateHeaderMenu", "getColumnDragToolbarItems"]
    };
  }
  get grid() {
    return this.client;
  }
  getColumnPickerItems(columnStore) {
    const me = this, {
      createColumnsFromModel
    } = me;
    let result;
    if (me.groupByRegion) {
      result = me.grid.regions.map((region) => {
        const columns = me.grid.getSubGrid(region).columns.topColumns;
        return {
          text: StringHelper.capitalize(region),
          menu: me.buildColumnMenu(columns),
          disabled: columns.length === 0,
          region
        };
      });
      if (createColumnsFromModel) {
        result.push({
          text: me.L("L{newColumns}"),
          menu: me.createAutoColumnItems()
        });
      }
    } else if (me.groupByTag) {
      const tags = {};
      columnStore.topColumns.forEach((column) => {
        column.tags && Array.isArray(column.tags) && column.hideable !== false && column.tags.forEach((tag) => {
          if (!tags[tag]) {
            tags[tag] = 1;
          }
        });
      });
      result = Object.keys(tags).sort().map((tag) => ({
        text: StringHelper.capitalize(tag),
        menu: me.buildColumnMenu(me.getColumnsForTag(tag)),
        tag,
        onBeforeSubMenu: ({
          item,
          itemEl
        }) => {
          me.refreshTagMenu(item, itemEl);
        }
      }));
      if (createColumnsFromModel) {
        result.push({
          text: me.L("L{newColumns}"),
          menu: me.createAutoColumnItems()
        });
      }
    } else {
      result = me.buildColumnMenu(columnStore.topColumns);
      if (createColumnsFromModel) {
        result.items.push(...ObjectHelper.transformNamedObjectToArray(me.createAutoColumnItems()));
      }
    }
    return result;
  }
  createAutoColumnItems() {
    const me = this, {
      grid
    } = me, {
      columns,
      store
    } = grid, {
      modelClass
    } = store, {
      allFields
    } = modelClass, result = {};
    for (let i = 0, {
      length
    } = allFields; i < length; i++) {
      const field = allFields[i], fieldName = field.name;
      if (!columns.get(fieldName)) {
        if (!field.internal) {
          result[fieldName] = {
            text: field.text || StringHelper.separate(field.name),
            checked: false,
            onToggle: (event) => {
              const column = columns.get(fieldName);
              if (column) {
                column[event.checked ? "show" : "hide"]();
              } else {
                columns.add(columns.generateColumnForField(field, {
                  region: me.forColumn.region
                }));
              }
              event.bubbles = false;
            }
          };
        }
      }
    }
    return result;
  }
  getColumnsForTag(tag) {
    return this.grid.columns.records.filter((column) => column.tags && Array.isArray(column.tags) && column.tags.includes(tag) && column.hideable !== false);
  }
  refreshTagMenu(item, itemEl) {
    const columns = this.getColumnsForTag(item.tag);
    columns.forEach((column) => {
      const subItem = item.items.find((subItem2) => subItem2.column === column);
      if (subItem)
        subItem.checked = column.hidden !== true;
    });
  }
  buildColumnMenu(columns) {
    let currentRegion = columns.length > 0 && columns[0].region;
    const {
      grid
    } = this, items2 = columns.reduce((items3, column) => {
      const visibleInRegion = grid.columns.visibleColumns.filter((col) => col.region === column.region);
      if (column.hideable !== false) {
        const itemConfig = {
          grid,
          column,
          text: column.headerText,
          checked: column.hidden !== true,
          disabled: column.hidden !== true && visibleInRegion.length === 1,
          cls: column.region !== currentRegion ? "b-separator" : ""
        };
        currentRegion = column.region;
        if (column.children && !column.isCollapsible) {
          itemConfig.menu = this.buildColumnMenu(column.children);
        }
        items3.push(itemConfig);
      }
      return items3;
    }, []);
    return {
      cls: this.menuCls,
      items: items2
    };
  }
  populateHeaderMenu({
    column,
    items: items2
  }) {
    const me = this, {
      columns
    } = me.grid;
    me.forColumn = column;
    if (column.showColumnPicker !== false && columns.some((col) => col.hideable)) {
      items2.columnPicker = {
        text: "L{columnsMenu}",
        localeClass: me,
        icon: "b-fw-icon b-icon-columns",
        cls: "b-separator",
        weight: 200,
        menu: me.getColumnPickerItems(columns),
        onToggle: me.onColumnToggle,
        disabled: me.disabled
      };
    }
    if (column.hideable !== false && !column.parent.isCollapsible) {
      const visibleInRegion = columns.visibleColumns.filter((col) => col.region === column.region);
      items2.hideColumn = {
        text: "L{hideColumn}",
        localeClass: me,
        icon: "b-fw-icon b-icon-hide-column",
        weight: 210,
        disabled: visibleInRegion.length === 1 || me.disabled,
        onItem: () => column.hide()
      };
    }
  }
  onColumnToggle({
    menu,
    item,
    checked
  }) {
    if (Boolean(item.column.hidden) !== !checked) {
      var _features$headerMenu, _item$menu;
      item.column[checked ? "show" : "hide"]();
      const {
        grid,
        column
      } = item, {
        columns,
        features
      } = grid, siblingItems = menu.items, visibleInRegion = columns.visibleColumns.filter((col) => col.region === item.column.region), hideItem = ((_features$headerMenu = features.headerMenu) === null || _features$headerMenu === void 0 ? void 0 : _features$headerMenu.enabled) && features.headerMenu.menu.widgetMap.hideColumn;
      if (visibleInRegion.length === 1) {
        const lastVisibleItem = siblingItems.find((menuItem) => menuItem.column === visibleInRegion[0]);
        if (lastVisibleItem) {
          lastVisibleItem.disabled = true;
        }
        if (hideItem && column.region === item.column.region) {
          hideItem.disabled = true;
        }
      } else {
        visibleInRegion.forEach((col) => {
          const siblingItem = siblingItems.find((sibling) => sibling.column === col);
          if (siblingItem) {
            siblingItem.disabled = false;
          }
        });
        if (hideItem && column.region === item.column.region) {
          hideItem.disabled = false;
        }
      }
      (_item$menu = item.menu) === null || _item$menu === void 0 ? void 0 : _item$menu.eachWidget((subItem) => {
        subItem.checked = checked;
      });
      const parentItem = menu.owner;
      if (parentItem && parentItem.column === column.parent) {
        parentItem.checked = siblingItems.some((subItem) => subItem.checked === true);
      }
    }
  }
  getColumnDragToolbarItems(column, items2) {
    const visibleInRegion = this.grid.columns.visibleColumns.filter((col) => col.region === column.region);
    if (column.hideable !== false && visibleInRegion.length > 1) {
      items2.push({
        text: "L{hideColumnShort}",
        ref: "hideColumn",
        group: "L{column}",
        localeClass: this,
        icon: "b-fw-icon b-icon-hide-column",
        weight: 101,
        onDrop: ({
          column: column2
        }) => column2.hide()
      });
    }
    return items2;
  }
};
_defineProperty(ColumnPicker, "$name", "ColumnPicker");
_defineProperty(ColumnPicker, "configurable", {
  groupByRegion: false,
  groupByTag: false,
  createColumnsFromModel: false,
  menuCls: "b-column-picker-menu b-sub-menu"
});
ColumnPicker._$name = "ColumnPicker";
GridFeatureManager.registerFeature(ColumnPicker, true);
var ColumnRename = class extends InstancePlugin {
  doDestroy() {
    var _this$editor;
    (_this$editor = this.editor) === null || _this$editor === void 0 ? void 0 : _this$editor.destroy();
    super.doDestroy();
  }
  static get pluginConfig() {
    return {
      after: ["populateHeaderMenu"]
    };
  }
  populateHeaderMenu({
    items: items2,
    column
  }) {
    items2.rename = {
      weight: 215,
      icon: "b-fw-icon b-icon-edit",
      text: this.L("L{rename}"),
      disabled: column.readOnly,
      onItem: () => this.startEdit(column)
    };
  }
  startEdit(column) {
    if (column instanceof Event) {
      var _this$client$getHeade;
      column = (_this$client$getHeade = this.client.getHeaderDataFromEvent(column)) === null || _this$client$getHeade === void 0 ? void 0 : _this$client$getHeade.column;
    }
    if (column) {
      if (column.readOnly) {
        return false;
      }
      const {
        textWrapper
      } = column;
      let {
        editor
      } = this;
      if (!editor) {
        this.editor = editor = new Editor({
          owner: this.client,
          align: {
            align: "t0-t0"
          }
        });
      }
      editor.render(textWrapper);
      editor.startEdit({
        target: textWrapper,
        record: column,
        field: "text"
      });
    }
  }
};
_defineProperty(ColumnRename, "$name", "ColumnRename");
_defineProperty(ColumnRename, "configurable", {
  keyMap: {
    F2: "startEdit"
  }
});
ColumnRename._$name = "ColumnRename";
GridFeatureManager.registerFeature(ColumnRename, false);
var ColumnReorder = class extends Delayable(InstancePlugin) {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ignoreSelectors", [".b-grid-header-resize-handle", ".b-field"]);
  }
  doDestroy() {
    var _this$dragHelper, _this$dragHelper2;
    (_this$dragHelper = this.dragHelper) === null || _this$dragHelper === void 0 ? void 0 : _this$dragHelper.scrollManager.destroy();
    (_this$dragHelper2 = this.dragHelper) === null || _this$dragHelper2 === void 0 ? void 0 : _this$dragHelper2.destroy();
    super.doDestroy();
  }
  get grid() {
    return this.client;
  }
  init() {
    const me = this, {
      grid
    } = me, gridEl = grid.element, containers = DomHelper.children(gridEl, ".b-grid-headers");
    containers.push(...DomHelper.children(gridEl, ".b-grid-header-children"));
    if (me.dragHelper) {
      me.dragHelper.containers = containers;
    } else {
      me.dragHelper = new DragHelper({
        name: "columnReorder",
        mode: "container",
        dragThreshold: 10,
        targetSelector: ".b-grid-header",
        floatRootOwner: grid,
        rtlSource: grid,
        outerElement: grid.headerContainer,
        monitoringConfig: {
          scrollables: [{
            element: ".b-grid-headers"
          }]
        },
        scrollManager: ScrollManager.new({
          direction: "horizontal",
          element: grid.headerContainer
        }),
        containers,
        isElementDraggable(element) {
          const abort = Boolean(element.closest(me.ignoreSelectors.join(",")));
          if (abort || me.disabled) {
            return false;
          }
          const columnEl = element.closest(this.targetSelector), column = columnEl && grid.columns.getById(columnEl.dataset.columnId), isLast = (column === null || column === void 0 ? void 0 : column.childLevel) === 0 && grid.subGrids[column.region].columns.count === 1;
          return Boolean(column) && column.draggable !== false && !isLast;
        },
        ignoreSelector: ".b-filter-icon,.b-grid-header-resize-handle",
        internalListeners: {
          beforeDragStart: me.onBeforeDragStart,
          dragstart: me.onDragStart,
          drag: me.onDrag,
          drop: me.onDrop,
          thisObj: me
        }
      });
      me.relayEvents(me.dragHelper, ["dragStart", "drag", "drop", "abort"], "gridHeader");
    }
  }
  static get pluginConfig() {
    return {
      after: ["onPaint", "renderContents"]
    };
  }
  onDrag({
    context,
    event
  }) {
    const me = this, targetHeader = Widget.fromElement(event.target, "gridheader");
    if (targetHeader !== null && targetHeader !== void 0 && targetHeader.subGrid.sealedColumns) {
      context.valid = false;
      return;
    }
    if (!me.grid.features.columnDragToolbar) {
      context.valid = Boolean(event.target.closest(".b-grid-headers"));
    }
  }
  onBeforeDragStart({
    context,
    event
  }) {
    const {
      element
    } = context, column = context.column = this.client.columns.getById(element.dataset.columnId);
    return this.client.trigger("beforeColumnDragStart", {
      column,
      event
    });
  }
  onDragStart({
    context,
    event
  }) {
    const me = this, {
      grid
    } = me, {
      column
    } = context;
    if (!grid.features.columnDragToolbar) {
      const headerContainerBox = grid.element.querySelector(".b-grid-header-container").getBoundingClientRect();
      me.dragHelper.minY = headerContainerBox.top;
      me.dragHelper.maxY = headerContainerBox.bottom;
    }
    grid.headerContainer.classList.add("b-dragging-header");
    context.dragProxy.style.fontSize = DomHelper.getStyleValue(context.element, "fontSize");
    grid.trigger("columnDragStart", {
      column,
      event
    });
  }
  onDrop({
    context,
    event
  }) {
    if (!context.valid) {
      return this.onInvalidDrop({
        context
      });
    }
    const me = this, {
      grid
    } = me, element = context.dragging, onHeader = context.target.closest(".b-grid-header"), droppedInRegion = context.draggedTo.dataset.region, onColumn = onHeader ? grid.columns.get(onHeader.dataset.column) : grid.subGrids[droppedInRegion].columns.last, toRegion = droppedInRegion || onColumn.region, sibling = context.insertBefore, column = grid.columns.getById(element.dataset.columnId), oldParent = column.parent, insertBefore = sibling ? grid.columns.getById(sibling.dataset.columnId) : grid.subGrids[toRegion].columns.last.nextSibling;
    let newParent;
    if (insertBefore) {
      newParent = insertBefore.parent;
    } else {
      const groupNode = onHeader === null || onHeader === void 0 ? void 0 : onHeader.parentElement.closest(".b-grid-header");
      if (groupNode) {
        newParent = grid.columns.getById(groupNode.dataset.columnId);
      } else {
        newParent = grid.columns.rootNode;
      }
    }
    grid.headerContainer.classList.remove("b-dragging-header");
    element.remove();
    let vetoed = toRegion === column.region && oldParent === newParent && (onColumn === column.previousSibling || insertBefore === column.nextSibling);
    vetoed = vetoed || grid.trigger("beforeColumnDropFinalize", {
      column,
      newParent,
      insertBefore,
      event
    }) === false;
    if (!vetoed) {
      vetoed = !newParent.insertChild(column, insertBefore);
    }
    context.valid = !vetoed;
    if (!vetoed) {
      column.region = toRegion;
      if (oldParent.children.length === 0) {
        oldParent.parent.removeChild(oldParent);
      }
    }
    grid.trigger("columnDrop", {
      column,
      newParent,
      insertBefore,
      valid: context.valid,
      event
    });
  }
  onInvalidDrop() {
    this.grid.headerContainer.classList.remove("b-dragging-header");
  }
  renderContents() {
    this.init();
  }
  onPaint() {
    this.init();
  }
};
_defineProperty(ColumnReorder, "$name", "ColumnReorder");
ColumnReorder.featureClass = "b-column-reorder";
ColumnReorder._$name = "ColumnReorder";
GridFeatureManager.registerFeature(ColumnReorder, true);
var ColumnResize = class extends InstancePlugin {
  static get $name() {
    return "ColumnResize";
  }
  static get configurable() {
    return {
      liveResize: "auto"
    };
  }
  construct(grid, config) {
    const me = this;
    me.grid = grid;
    super.construct(grid, config);
    me.resizer = new ResizeHelper({
      name: "columnResize",
      targetSelector: ".b-grid-header",
      handleSelector: ".b-grid-header-resize-handle",
      outerElement: grid.element,
      rtlSource: grid,
      internalListeners: {
        beforeresizestart: me.onBeforeResizeStart,
        resizestart: me.onResizeStart,
        resizing: me.onResizing,
        resize: me.onResize,
        cancel: me.onCancel,
        thisObj: me
      }
    });
  }
  doDestroy() {
    var _this$resizer;
    (_this$resizer = this.resizer) === null || _this$resizer === void 0 ? void 0 : _this$resizer.destroy();
    super.doDestroy();
  }
  changeLiveResize(liveResize) {
    if (liveResize === "auto") {
      return !BrowserHelper.isMobileSafari;
    }
    return liveResize;
  }
  onBeforeResizeStart() {
    return !this.disabled;
  }
  onResizeStart({
    context
  }) {
    const {
      grid,
      resizer
    } = this, column = context.column = grid.columns.getById(context.element.dataset.columnId);
    resizer.minWidth = column.minWidth;
    grid.element.classList.add("b-column-resizing");
  }
  onResizing({
    context
  }) {
    if (context.valid && this.liveResize) {
      this.grid.resizingColumns = true;
      context.column.width = context.newWidth;
    }
  }
  onResize({
    context
  }) {
    const {
      grid
    } = this, {
      column
    } = context;
    grid.element.classList.remove("b-column-resizing");
    if (context.valid) {
      if (this.liveResize) {
        grid.resizingColumns = false;
        grid.afterColumnsResized(column);
      } else {
        column.width = context.newWidth;
      }
    }
  }
  onCancel({
    context
  }) {
    const {
      grid
    } = this;
    grid.element.classList.remove("b-column-resizing");
    context.column.width = context.elementWidth;
    grid.resizingColumns = false;
  }
};
ColumnResize._$name = "ColumnResize";
GridFeatureManager.registerFeature(ColumnResize, true);
var FillHandle = class extends InstancePlugin.mixin(Delayable) {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "delayable", {
      handleSelection: "raf"
    });
  }
  afterConstruct() {
    super.afterConstruct();
    if (!this.client.selectionMode.cell) {
      this.disabled = true;
    }
    this._fillListeners = {};
  }
  onContentChange() {
    this.handleSelection();
  }
  afterColumnsChange() {
    this.handleSelection();
  }
  fixElementHeights() {
    this.handleSelection();
  }
  getCellDataFromEvent(event, includeSingleAxisMatch) {
    if (includeSingleAxisMatch) {
      includeSingleAxisMatch = !event.target.classList.contains("b-fill-handle");
    }
    return this.overridden.getCellDataFromEvent(event, includeSingleAxisMatch);
  }
  findPatternsIn2dRange(range, horizontal, negative) {
    const values = {};
    for (const cell of range) {
      const id = horizontal ? cell.id : cell.columnId;
      let value = cell.record[cell.column.field];
      if (value && typeof value === "string" && !isNaN(value)) {
        value = parseFloat(value);
      }
      if (!values[id]) {
        values[id] = [];
      }
      values[id].push(value);
    }
    for (const rowOrCol in values) {
      values[rowOrCol].pattern = this.findPatternsIn1dRange(values[rowOrCol], negative);
    }
    return values;
  }
  findPatternsIn1dRange(range, negative) {
    const lastValue = range[negative ? 0 : range.length - 1], pattern = {
      next: () => lastValue,
      lastValue
    };
    if (range.every((val) => typeof val === "number") || range.every((val) => val instanceof Date)) {
      const diffs = range.map((val, ix) => val - range[ix - 1]);
      diffs.shift();
      if (new Set(diffs).size === 1) {
        pattern.increaseBy = diffs[0] * (negative ? -1 : 1);
        pattern.next = () => {
          if (pattern.lastValue instanceof Date) {
            pattern.lastValue = new Date(pattern.lastValue.getTime() + pattern.increaseBy);
          } else {
            pattern.lastValue += pattern.increaseBy;
          }
          return pattern.lastValue;
        };
      }
    } else if (range.length > 1) {
      pattern.stringPattern = [...range];
      pattern.next = () => {
        if (pattern.currentIndex === void 0) {
          pattern.currentIndex = 0;
        } else {
          pattern.currentIndex += 1;
          if (pattern.currentIndex >= pattern.stringPattern.length) {
            pattern.currentIndex = 0;
          }
        }
        return pattern.stringPattern[pattern.currentIndex];
      };
    }
    return pattern;
  }
  afterSelectionChange() {
    const me = this;
    if (GlobalEvents$1.isMouseDown()) {
      me.client.delayUntilMouseUp(() => me.handleSelection(true));
      me.removeElements();
    } else {
      me.handleSelection(true);
    }
  }
  handleSelection() {
    if (!this._isExtending) {
      const range = this.rangeSelection;
      if (range) {
        this.drawFillHandleAndBorder(range[0], range[range.length - 1]);
      } else {
        this.removeElements();
      }
    }
  }
  onMouseDown(event) {
    this._fillListeners.mouseMoveOrUp = EventHelper.on({
      element: globalThis,
      mouseover: "onMouseOver",
      mouseup: "onMouseUp",
      thisObj: this
    });
    event.stopImmediatePropagation();
    event.handled = true;
  }
  onMouseUp() {
    const me = this, {
      client,
      currentRange,
      _isCropping
    } = me, range = me.rangeSelection, selectionChange = range && currentRange && client.internalSelectRange(currentRange.from, currentRange.to), selectedCells = (selectionChange === null || selectionChange === void 0 ? void 0 : selectionChange.selectedCells) || [], extensionCells = _isCropping ? me.croppingCells : selectedCells.filter((cell) => !range.some((sel) => sel.equals(cell, true)));
    delete me._isCropping;
    if (me._isExtending) {
      client.disableScrollingCloseToEdges(client.items);
      delete me._isExtending;
    }
    if (!(extensionCells !== null && extensionCells !== void 0 && extensionCells.length)) {
      me.handleSelection();
      return;
    }
    client.suspendRefresh();
    if (_isCropping) {
      extensionCells.forEach((cell) => cell.record.set(cell.column.field, null, false, false, false, true));
    } else {
      const [firstCell] = extensionCells, horizontal = range.some((sel) => sel.record === firstCell.record), negative = horizontal ? firstCell.columnIndex < range[0].columnIndex : firstCell.rowIndex < range[0].rowIndex, patterns = me.findPatternsIn2dRange(range, horizontal, negative), changeMap = /* @__PURE__ */ new Map();
      if (negative) {
        extensionCells.reverse();
      }
      for (const cell of extensionCells) {
        const {
          column,
          record
        } = cell;
        if (column.canFillValue({
          range,
          record,
          cell
        })) {
          var _me$calculateFillValu, _column$calculateFill;
          let value = (_me$calculateFillValu = me.calculateFillValue) === null || _me$calculateFillValu === void 0 ? void 0 : _me$calculateFillValu.call(me, {
            range,
            column,
            record,
            cell
          }), changed = changeMap.get(record);
          if (!changed) {
            changed = {};
            changeMap.set(record, changed);
          }
          if (value === void 0) {
            const pattern = patterns[horizontal ? cell.id : cell.columnId].pattern;
            value = pattern.next();
          }
          changed[column.field] = ((_column$calculateFill = column.calculateFillValue) === null || _column$calculateFill === void 0 ? void 0 : _column$calculateFill.call(column, {
            value,
            record,
            range
          })) || value;
        }
      }
      for (const [record, changes] of changeMap) {
        record.set(changes, null, null, null, null, true);
      }
    }
    client.resumeRefresh(true);
    client.performSelection(selectionChange);
    delete me.currentRange;
    me.handleSelection();
  }
  onMouseOver(event) {
    var _cellSelector, _cellSelector$_column;
    const me = this, {
      client,
      rangeSelection
    } = me, first = rangeSelection[0], last = rangeSelection[rangeSelection.length - 1], cellData = client.getCellDataFromEvent(event, true);
    let cellSelector = cellData && client.normalizeCellContext(cellData.cellSelector);
    if (((_cellSelector = cellSelector) === null || _cellSelector === void 0 ? void 0 : (_cellSelector$_column = _cellSelector._column) === null || _cellSelector$_column === void 0 ? void 0 : _cellSelector$_column.region) === first._column.region) {
      const equalOrSmaller = rangeSelection.some((cs) => cs.equals(cellSelector, true));
      let negative;
      if (!me._isExtending) {
        client.enableScrollingCloseToEdges(client.items);
      }
      if (equalOrSmaller) {
        me._isCropping = me.allowCropping && (cellSelector.rowIndex < last.rowIndex || cellSelector.columnIndex < last.columnIndex);
      } else {
        if (cellSelector.rowIndex >= first.rowIndex && cellSelector.rowIndex <= last.rowIndex) {
          negative = first.columnIndex > cellSelector.columnIndex;
          cellSelector = new Location({
            grid: client,
            record: negative ? first.record : last.record,
            column: cellSelector.column
          });
        } else {
          negative = first.rowIndex > cellSelector.rowIndex;
          cellSelector = new Location({
            grid: client,
            record: cellSelector.record,
            column: negative ? first.column : last.column
          });
        }
      }
      const from = negative ? cellSelector : first, to = negative || equalOrSmaller && !me._isCropping ? last : cellSelector;
      me.currentRange = {
        from,
        to
      };
      me._isExtending = true;
      me.drawFillHandleAndBorder(from, to, true);
    }
  }
  drawFillHandleAndBorder(from, to, keepListeners = false) {
    var _me$rangeSelection;
    const me = this, {
      client,
      currentRange,
      _fillListeners
    } = me, regionEl = client.subGrids[from.column.region].element, {
      x
    } = Rectangle.from(from.cell || from.column.element, regionEl), {
      right
    } = Rectangle.from(to.cell || to.column.element, regionEl), {
      y
    } = client.getRecordCoords(from.record, true), bottom = client.getRecordCoords(to.record, true).bottom - 1;
    let {
      borderElement,
      handleElement
    } = me;
    me.removeElements(keepListeners);
    if (!borderElement) {
      me.borderElement = borderElement = DomHelper.createElement({
        className: "b-fill-selection-border"
      });
      me.handleElement = handleElement = DomHelper.createElement({
        className: "b-fill-handle"
      });
    }
    DomHelper.setRect(borderElement, {
      y,
      x,
      width: right - x,
      height: bottom - y
    });
    regionEl.appendChild(borderElement);
    DomHelper.setTopLeft(handleElement, bottom, right >= regionEl.scrollWidth ? x : right);
    regionEl.appendChild(handleElement);
    me.toggleCroppingCls(false);
    delete me.croppingCells;
    if (me._isCropping && (_me$rangeSelection = me.rangeSelection) !== null && _me$rangeSelection !== void 0 && _me$rangeSelection.length) {
      const newCells = client.getRange(currentRange.from, currentRange.to);
      me.croppingCells = me.rangeSelection.filter((sel) => !newCells.some((cell) => cell.equals(sel, true)));
      me.toggleCroppingCls();
    }
    if (!_fillListeners.handleClick) {
      _fillListeners.handleClick = EventHelper.on({
        element: globalThis,
        delegate: ".b-fill-handle",
        mousedown: "onMouseDown",
        thisObj: me
      });
    }
    me.hasFillElements = true;
  }
  toggleCroppingCls(add = true) {
    var _this$croppingCells;
    (_this$croppingCells = this.croppingCells) === null || _this$croppingCells === void 0 ? void 0 : _this$croppingCells.forEach((sel) => {
      var _this$client$getCell;
      return (_this$client$getCell = this.client.getCell(sel)) === null || _this$client$getCell === void 0 ? void 0 : _this$client$getCell.classList.toggle("b-indicate-crop", add);
    });
  }
  removeElements(keepListeners = false) {
    var _me$handleElement, _me$borderElement;
    const me = this;
    (_me$handleElement = me.handleElement) === null || _me$handleElement === void 0 ? void 0 : _me$handleElement.remove();
    (_me$borderElement = me.borderElement) === null || _me$borderElement === void 0 ? void 0 : _me$borderElement.remove();
    if (!keepListeners) {
      me.removeListeners();
    }
    me.hasFillElements = false;
  }
  removeListeners() {
    const me = this;
    for (const listener in me._fillListeners) {
      me._fillListeners[listener]();
    }
    me._fillListeners = {};
  }
  get rangeSelection() {
    var _client$_shiftSelectR;
    const {
      client
    } = this, {
      selectedCells
    } = client, range = (_client$_shiftSelectR = client._shiftSelectRange) !== null && _client$_shiftSelectR !== void 0 ? _client$_shiftSelectR : selectedCells.length === 1 && selectedCells;
    if (!client.selectedRecords.length && range !== null && range !== void 0 && range.length && range.length === selectedCells.length && range.every((c1) => selectedCells.some((c2) => c1.equals(c2, true)) && c1._column.parent && c1._column.region === range[0]._column.region && client.store.isAvailable(c1.id))) {
      return range;
    }
    return null;
  }
};
_defineProperty(FillHandle, "$name", "FillHandle");
_defineProperty(FillHandle, "configurable", {
  calculateFillValue: null,
  allowCropping: false
});
_defineProperty(FillHandle, "pluginConfig", {
  chain: ["afterSelectionChange", "onContentChange", "afterColumnsChange", "fixElementHeights"],
  override: ["getCellDataFromEvent"]
});
FillHandle._$name = "FillHandle";
GridFeatureManager.registerFeature(FillHandle);
var GridFieldFilterPicker = class extends FieldFilterPicker {
  static get $name() {
    return "GridFieldFilterPicker";
  }
  static get type() {
    return "gridfieldfilterpicker";
  }
  afterConstruct() {
    var _me$fields;
    const me = this;
    if (!me.grid) {
      throw new Error(`${me.constructor.$name} requires 'grid' to be configured.`);
    }
    me.fields = (_me$fields = me.fields) !== null && _me$fields !== void 0 ? _me$fields : {};
    super.afterConstruct();
  }
  updateGrid(newGrid) {
    var _newGrid$store;
    if (!((_newGrid$store = newGrid.store) !== null && _newGrid$store !== void 0 && _newGrid$store.modelClass)) {
      throw new Error(`Grid does not have a store with a modelClass defined.`);
    }
    if (!newGrid.columns) {
      throw new Error(`Grid does not have a column store.`);
    }
  }
  static getModelClassFields(modelClass) {
    const ownFieldNames = new Set(modelClass.fields.map(({
      name
    }) => name));
    return (modelClass === null || modelClass === void 0 ? void 0 : modelClass.allFields.filter((field) => !field.internal && (SUPPORTED_FIELD_DATA_TYPES.includes(field.type) || isSupportedDurationField(field)) && (field.definedBy !== Model || ownFieldNames.has(field.name)))) || [];
  }
  static getColumnFields(columnStore, modelClass, allowedFieldNames) {
    var _columnStore$records$;
    const modelFields = ArrayHelper.keyBy(GridFieldFilterPicker.getModelClassFields(modelClass), "name"), allowedNameSet = allowedFieldNames && new Set(allowedFieldNames);
    return Object.fromEntries((_columnStore$records$ = columnStore === null || columnStore === void 0 ? void 0 : columnStore.records.filter(({
      field
    }) => field && modelFields[field] && (!allowedNameSet || allowedNameSet.has(field))).map(({
      field,
      text
    }) => [field, {
      title: text || field,
      type: isSupportedDurationField(modelFields[field]) ? "duration" : modelFields[field].type
    }])) !== null && _columnStore$records$ !== void 0 ? _columnStore$records$ : []);
  }
  changeFields(newFields) {
    var _this$grid$store;
    let localFields = newFields;
    if (Array.isArray(newFields)) {
      VersionHelper.deprecate("Core", "6.0.0", "FieldOption[] deprecated, use Object<String, FieldOption[]> keyed by field name instead");
      localFields = ArrayHelper.keyBy(localFields, "name");
    }
    return ObjectHelper.merge({}, GridFieldFilterPicker.getColumnFields(this.grid.columns, (_this$grid$store = this.grid.store) === null || _this$grid$store === void 0 ? void 0 : _this$grid$store.modelClass, this.allowedFieldNames), localFields);
  }
};
_defineProperty(GridFieldFilterPicker, "configurable", {
  grid: null,
  allowedFieldNames: null
});
GridFieldFilterPicker.initClass();
GridFieldFilterPicker._$name = "GridFieldFilterPicker";
var GridFieldFilterPickerGroup = class extends FieldFilterPickerGroup {
  static get $name() {
    return "GridFieldFilterPickerGroup";
  }
  static get type() {
    return "gridfieldfilterpickergroup";
  }
  validateConfig() {
    if (!this.grid) {
      throw new Error(`${this.constructor.$name} requires the 'grid' config property.`);
    }
  }
  getFilterPickerConfig(filter) {
    const {
      grid,
      allowedFieldNames
    } = this;
    return _objectSpread2(_objectSpread2({}, super.getFilterPickerConfig(filter)), {}, {
      grid,
      allowedFieldNames
    });
  }
  updateGrid(newGrid) {
    this.store = this.grid.store;
  }
  canManage(filter) {
    const me = this;
    return super.canManage(filter) && (!me.allowedFieldNames || me.allowedFieldNames.includes(filter.property));
  }
};
_defineProperty(GridFieldFilterPickerGroup, "configurable", {
  grid: null,
  allowedFieldNames: null
});
_defineProperty(GridFieldFilterPickerGroup, "childPickerType", "gridfieldfilterpicker");
GridFieldFilterPickerGroup.initClass();
GridFieldFilterPickerGroup._$name = "GridFieldFilterPickerGroup";
var fieldTypeMap = {
  date: "date",
  int: "number",
  integer: "number",
  number: "number",
  string: "text",
  duration: "duration"
};
var Filter = class extends InstancePlugin {
  static get $name() {
    return "Filter";
  }
  static get configurable() {
    return {
      prioritizeColumns: false,
      keyMap: {
        f: "showFilterEditorByKey"
      },
      isMulti: false
    };
  }
  construct(grid, config) {
    if (grid.features.filterBar) {
      throw new Error("Grid.feature.Filter feature may not be used together with Grid.feature.FilterBar. These features are mutually exclusive.");
    }
    const me = this;
    me.grid = grid;
    me.closeFilterEditor = me.closeFilterEditor.bind(me);
    super.construct(grid, config);
    me.bindStore(grid.store);
    if (config && typeof config === "object") {
      const clone = ObjectHelper.clone(config);
      delete clone.prioritizeColumns;
      delete clone.isMulti;
      delete clone.dateFormat;
      if (!ObjectHelper.isEmpty(clone)) {
        grid.store.filter(clone, null, grid.isConfiguring);
      }
    }
  }
  doDestroy() {
    var _this$filterTip, _this$filterEditorPop;
    (_this$filterTip = this.filterTip) === null || _this$filterTip === void 0 ? void 0 : _this$filterTip.destroy();
    (_this$filterEditorPop = this.filterEditorPopup) === null || _this$filterEditorPop === void 0 ? void 0 : _this$filterEditorPop.destroy();
    super.doDestroy();
  }
  get store() {
    return this.grid.store;
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      beforeFilter: "onStoreBeforeFilter",
      filter: "onStoreFilter",
      thisObj: this
    });
  }
  static get pluginConfig() {
    return {
      chain: ["renderHeader", "populateCellMenu", "populateHeaderMenu", "onElementClick", "bindStore"]
    };
  }
  refreshHeaders(reRenderRows) {
    const me = this, grid = me.grid, element = grid.headerContainer;
    if (element) {
      DomHelper.children(element, ".b-filter-icon.b-latest").forEach((iconElement) => iconElement.classList.remove("b-latest"));
      if (!me.filterTip) {
        me.filterTip = new Tooltip({
          forElement: element,
          forSelector: ".b-filter-icon",
          getHtml({
            activeTarget
          }) {
            return activeTarget.dataset.filterText;
          }
        });
      }
      if (!grid.store.isFiltered) {
        me.filterTip.hide();
      }
      grid.columns.visibleColumns.forEach((column) => {
        if (column.filterable !== false) {
          const columnFilters = me.store.filters.allValues.filter(({
            property,
            disabled,
            internal
          }) => property === column.field && !disabled && !internal), isColumnFiltered = columnFilters.length > 0, headerEl = column.element;
          if (headerEl) {
            const textEl = column.textWrapper;
            let filterIconEl = textEl === null || textEl === void 0 ? void 0 : textEl.querySelector(".b-filter-icon"), filterText;
            if (isColumnFiltered) {
              const bullet = "&#x2022 ";
              filterText = `${me.L("L{filter}")}: ` + (columnFilters.length > 1 ? "<br/><br/>" : "") + columnFilters.map((columnFilter) => {
                var _columnFilter$value, _me$store, _me$store$modelRelati;
                let value = (_columnFilter$value = columnFilter.value) !== null && _columnFilter$value !== void 0 ? _columnFilter$value : "";
                const isArray2 = Array.isArray(value), relation = (_me$store = me.store) === null || _me$store === void 0 ? void 0 : (_me$store$modelRelati = _me$store.modelRelations) === null || _me$store$modelRelati === void 0 ? void 0 : _me$store$modelRelati.find(({
                  foreignKey
                }) => foreignKey === columnFilter.property);
                if (columnFilter.displayValue) {
                  value = columnFilter.displayValue;
                } else {
                  if (me.isMulti && relation) {
                    var _me$isMulti$fields;
                    const {
                      relatedDisplayField
                    } = (_me$isMulti$fields = me.isMulti.fields) === null || _me$isMulti$fields === void 0 ? void 0 : _me$isMulti$fields[columnFilter.property];
                    if (relatedDisplayField) {
                      const getDisplayValue = (foreignId) => {
                        var _relation$foreignStor;
                        return (_relation$foreignStor = relation.foreignStore.getById(foreignId)) === null || _relation$foreignStor === void 0 ? void 0 : _relation$foreignStor[relatedDisplayField];
                      };
                      if (isArray2) {
                        value = value[relatedDisplayField].sort((a, b) => (a !== null && a !== void 0 ? a : "").localeCompare(b !== null && b !== void 0 ? b : ""));
                      } else {
                        value = getDisplayValue(value);
                      }
                    }
                  } else if (column.formatValue && value) {
                    value = isArray2 ? value.map((val) => column.formatValue(val)) : column.formatValue(value);
                  }
                  if (isArray2) {
                    value = `[ ${value.join(", ")} ]`;
                  }
                }
                return (columnFilters.length > 1 ? bullet : "") + (typeof columnFilter === "string" ? columnFilter : `${columnFilter.operator} ${value}`);
              }).join("<br/><br/>");
            } else {
              filterText = me.L("L{applyFilter}");
            }
            if (!filterIconEl) {
              filterIconEl = DomHelper.createElement({
                parent: textEl,
                tag: "div",
                className: "b-filter-icon",
                dataset: {
                  filterText
                }
              });
            } else {
              filterIconEl.dataset.filterText = filterText;
            }
            if (column.field === me.store.latestFilterField)
              filterIconEl.classList.add("b-latest");
            headerEl.classList.add("b-filterable");
            headerEl.classList.toggle("b-filter", isColumnFiltered);
          }
          column.meta.isFiltered = isColumnFiltered;
        }
      });
      if (reRenderRows) {
        grid.refreshRows();
      }
    }
  }
  applyFilter(column, config) {
    const {
      store
    } = this, {
      filterFn
    } = column.filterable;
    column.$filter = store.addFilter(_objectSpread2(_objectSpread2(_objectSpread2({}, column.filterable), config), {}, {
      property: column.field,
      [filterFn ? "filterBy" : "_"]: function(record) {
        return filterFn({
          value: this.value,
          record,
          operator: this.operator,
          property: this.property,
          column
        });
      }
    }), true);
    store.filter();
  }
  removeFilter(column) {
    if (this.isMulti) {
      for (const filter of this.getCurrentMultiFilters(column)) {
        this.store.removeFilter(filter);
      }
    } else {
      this.store.removeFilter(column.field);
    }
  }
  disableFilter(column) {
    for (const filter of this.getCurrentMultiFilters(column)) {
      filter.disabled = true;
      this.store.filter(filter);
    }
    this.store.filter();
  }
  getCurrentMultiFilters(column) {
    return this.store.filters.values.filter((filter) => filter.property === column.field);
  }
  getPopupDateItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {
    const me = this, onClose = changeCallback;
    function onClear() {
      me.removeFilter(column);
    }
    function onKeydown({
      event
    }) {
      if (event.key === "Enter") {
        changeCallback();
      }
    }
    function onChange({
      source,
      value
    }) {
      if (value == null) {
        onClear();
      } else {
        me.clearSiblingsFields(source);
        me.applyFilter(column, {
          operator: source.operator,
          value,
          displayValue: source._value,
          type: "date"
        });
      }
    }
    return [ObjectHelper.assign({
      type: "date",
      ref: "on",
      placeholder: "L{on}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
      value: (filter === null || filter === void 0 ? void 0 : filter.operator) === "sameDay" ? filter.value : initialValue,
      operator: "sameDay",
      onKeydown,
      onChange,
      onClose,
      onClear
    }, filterField), ObjectHelper.assign({
      type: "date",
      ref: "before",
      placeholder: "L{before}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-before"></i>',
      value: (filter === null || filter === void 0 ? void 0 : filter.operator) === "<" ? filter.value : null,
      operator: "<",
      onKeydown,
      onChange,
      onClose,
      onClear
    }, filterField), ObjectHelper.assign({
      type: "date",
      ref: "after",
      cls: "b-last-row",
      placeholder: "L{after}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-after"></i>',
      value: (filter === null || filter === void 0 ? void 0 : filter.operator) === ">" ? filter.value : null,
      operator: ">",
      onKeydown,
      onChange,
      onClose,
      onClear
    }, filterField)];
  }
  getPopupNumberItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {
    const me = this, onEsc = changeCallback;
    function onClear() {
      me.removeFilter(column);
    }
    function onKeydown({
      event
    }) {
      if (event.key === "Enter") {
        changeCallback();
      }
    }
    function onChange({
      source,
      value
    }) {
      if (value == null) {
        onClear();
      } else {
        me.clearSiblingsFields(source);
        me.applyFilter(column, {
          operator: source.operator,
          value
        });
      }
    }
    return [ObjectHelper.assign({
      type: "number",
      placeholder: "L{Filter.equals}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
      value: (filter === null || filter === void 0 ? void 0 : filter.operator) === "=" ? filter.value : initialValue,
      operator: "=",
      onKeydown,
      onChange,
      onEsc,
      onClear
    }, filterField), ObjectHelper.assign({
      type: "number",
      placeholder: "L{lessThan}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-less"></i>',
      value: (filter === null || filter === void 0 ? void 0 : filter.operator) === "<" ? filter.value : null,
      operator: "<",
      onKeydown,
      onChange,
      onEsc,
      onClear
    }, filterField), ObjectHelper.assign({
      type: "number",
      cls: "b-last-row",
      placeholder: "L{moreThan}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-more"></i>',
      value: (filter === null || filter === void 0 ? void 0 : filter.operator) === ">" ? filter.value : null,
      operator: ">",
      onKeydown,
      onChange,
      onEsc,
      onClear
    }, filterField)];
  }
  clearSiblingsFields(sourceField) {
    var _this$filterEditorPop2;
    (_this$filterEditorPop2 = this.filterEditorPopup) === null || _this$filterEditorPop2 === void 0 ? void 0 : _this$filterEditorPop2.items.forEach((field) => {
      field !== sourceField && (field === null || field === void 0 ? void 0 : field.clear());
    });
  }
  getPopupDurationItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {
    const me = this, onEsc = changeCallback, onClear = () => me.removeFilter(column);
    me.removeFilter(column);
    function onChange({
      source,
      value
    }) {
      me.clearSiblingsFields(source);
      me.applyFilter(column, {
        operator: source.operator,
        value
      });
    }
    return [ObjectHelper.assign({
      type: "duration",
      placeholder: "L{Filter.equals}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
      value: (filter === null || filter === void 0 ? void 0 : filter.operator) === "=" ? filter.value : initialValue,
      operator: "=",
      onChange,
      onEsc,
      onClear
    }, filterField), ObjectHelper.assign({
      type: "duration",
      placeholder: "L{lessThan}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-less"></i>',
      value: (filter === null || filter === void 0 ? void 0 : filter.operator) === "<" ? filter.value : null,
      operator: "<",
      onChange,
      onEsc,
      onClear
    }, filterField), ObjectHelper.assign({
      type: "duration",
      cls: "b-last-row",
      placeholder: "L{moreThan}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-more"></i>',
      value: (filter === null || filter === void 0 ? void 0 : filter.operator) === ">" ? filter.value : null,
      operator: ">",
      onChange,
      onEsc,
      onClear
    }, filterField)];
  }
  getPopupStringItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {
    const me = this;
    return [ObjectHelper.assign({
      type: fieldType,
      cls: "b-last-row",
      placeholder: "L{filter}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
      value: filter ? filter.value || filter : initialValue,
      operator: "*",
      onChange({
        source,
        value
      }) {
        if (value === "") {
          closeCallback();
        } else {
          me.applyFilter(column, {
            operator: source.operator,
            value,
            displayValue: source.displayField && source.records ? source.records.map((rec) => rec[source.displayField]).join(", ") : void 0
          });
          if (!source.multiSelect) {
            changeCallback();
          }
        }
      },
      onClose: changeCallback,
      onClear: closeCallback
    }, filterField)];
  }
  getPopupItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {
    const me = this;
    if (me.isMulti) {
      return me.getMultiFilterPopupItems(...arguments);
    }
    switch (fieldType) {
      case "date":
        return me.getPopupDateItems(...arguments);
      case "number":
        return me.getPopupNumberItems(...arguments);
      case "duration":
        return me.getPopupDurationItems(...arguments);
      default:
        return me.getPopupStringItems(...arguments);
    }
  }
  getMultiFilterPopupItems(column) {
    var _grid$store;
    const {
      grid,
      isMulti
    } = this, existingFilter = (_grid$store = grid.store) === null || _grid$store === void 0 ? void 0 : _grid$store.filters.find((filter) => filter.property === column.field);
    return [_objectSpread2(_objectSpread2({}, typeof isMulti === "object" ? isMulti : void 0), {}, {
      type: "gridfieldfilterpickergroup",
      ref: "pickerGroup",
      limitToProperty: column.field,
      grid,
      filters: existingFilter ? [] : [{
        property: column.field
      }],
      propertyFieldCls: "b-transparent property-field",
      operatorFieldCls: "b-transparent operator-field",
      valueFieldCls: "b-transparent value-field",
      width: "400px"
    })];
  }
  showFilterEditor(column, value) {
    column = this.grid.columns.getById(column);
    const me = this, {
      store,
      isMulti
    } = me, headerEl = column.element, filter = store.filters.getBy("property", column.field), fieldType = me.getFilterType(column);
    if (column.filterable === false) {
      return;
    }
    me.closeFilterEditor();
    const items2 = me.getPopupItems(
      column,
      fieldType,
      filter !== null && filter !== void 0 && filter.internal ? null : filter,
      value,
      store,
      me.closeFilterEditor,
      () => {
        me.removeFilter(column);
        me.closeFilterEditor();
      },
      column.filterable.filterField,
      isMulti
    );
    items2.forEach((item) => item.placeholder = item.placeholder ? this.L(item.placeholder) : item.placeholder);
    me.filterEditorPopup = WidgetHelper.openPopup(headerEl, {
      owner: me.grid,
      cls: "b-filter-popup",
      scrollAction: "realign",
      layout: {
        type: "vbox",
        align: "stretch"
      },
      items: items2
    });
  }
  closeFilterEditor() {
    var _this$filterEditorPop3;
    (_this$filterEditorPop3 = this.filterEditorPopup) === null || _this$filterEditorPop3 === void 0 ? void 0 : _this$filterEditorPop3.setTimeout(this.filterEditorPopup.destroy);
    this.filterEditorPopup = null;
  }
  getFilterType(column) {
    const fieldName = column.field, field = this.client.store.modelClass.getFieldDefinition(fieldName), type = column.filterType;
    return type ? fieldTypeMap[type] : fieldTypeMap[column.type] || field && fieldTypeMap[field.type] || "text";
  }
  populateCellMenuWithDateItems({
    column,
    record,
    items: items2
  }) {
    const property = column.field, type = this.getFilterType(column);
    if (type === "date") {
      const me = this, value = record[property], filter = (operator) => {
        me.applyFilter(column, {
          operator,
          value,
          displayValue: column.formatValue ? column.formatValue(value) : value,
          type: "date"
        });
      };
      items2.filterDateEquals = {
        text: "L{on}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-equal",
        cls: "b-separator",
        weight: 300,
        disabled: me.disabled,
        onItem: () => filter("=")
      };
      items2.filterDateBefore = {
        text: "L{before}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-before",
        weight: 310,
        disabled: me.disabled,
        onItem: () => filter("<")
      };
      items2.filterDateAfter = {
        text: "L{after}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-after",
        weight: 320,
        disabled: me.disabled,
        onItem: () => filter(">")
      };
    }
  }
  populateCellMenuWithNumberItems({
    column,
    record,
    items: items2
  }) {
    const property = column.field, type = this.getFilterType(column);
    if (type === "number") {
      const me = this, value = record[property], filter = (operator) => {
        me.applyFilter(column, {
          operator,
          value
        });
      };
      items2.filterNumberEquals = {
        text: "L{equals}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-equal",
        cls: "b-separator",
        weight: 300,
        disabled: me.disabled,
        onItem: () => filter("=")
      };
      items2.filterNumberLess = {
        text: "L{lessThan}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-less",
        weight: 310,
        disabled: me.disabled,
        onItem: () => filter("<")
      };
      items2.filterNumberMore = {
        text: "L{moreThan}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-more",
        weight: 320,
        disabled: me.disabled,
        onItem: () => filter(">")
      };
    }
  }
  populateCellMenuWithDurationItems({
    column,
    record,
    items: items2
  }) {
    const property = column.field, type = this.getFilterType(column);
    if (type === "duration") {
      const me = this, value = record[property], filter = (operator) => {
        me.applyFilter(column, {
          operator,
          value
        });
      };
      items2.filterDurationEquals = {
        text: "L{equals}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-equal",
        cls: "b-separator",
        weight: 300,
        disabled: me.disabled,
        onItem: () => filter("=")
      };
      items2.filterDurationLess = {
        text: "L{lessThan}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-less",
        weight: 310,
        disabled: me.disabled,
        onItem: () => filter("<")
      };
      items2.filterDurationMore = {
        text: "L{moreThan}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-more",
        weight: 320,
        disabled: me.disabled,
        onItem: () => filter(">")
      };
    }
  }
  populateCellMenuWithStringItems({
    column,
    record,
    items: items2
  }) {
    const type = this.getFilterType(column);
    if (!/(date|number|duration)/.test(type)) {
      var _column$filterable$fi, _column$filterable$fi2;
      const me = this, value = column.getFilterableValue(record), operator = (_column$filterable$fi = (_column$filterable$fi2 = column.filterable.filterField) === null || _column$filterable$fi2 === void 0 ? void 0 : _column$filterable$fi2.operator) !== null && _column$filterable$fi !== void 0 ? _column$filterable$fi : "*";
      items2.filterStringEquals = {
        text: "L{equals}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-equal",
        cls: "b-separator",
        weight: 300,
        disabled: me.disabled,
        onItem: () => me.applyFilter(column, {
          value,
          operator
        })
      };
    }
  }
  populateCellMenu({
    column,
    record,
    items: items2
  }) {
    const me = this;
    if (column.filterable !== false && !record.isSpecialRow) {
      me.populateCellMenuWithDateItems(...arguments);
      me.populateCellMenuWithNumberItems(...arguments);
      me.populateCellMenuWithDurationItems(...arguments);
      me.populateCellMenuWithStringItems(...arguments);
      if (column.meta.isFiltered) {
        items2.filterRemove = {
          text: "L{removeFilter}",
          localeClass: me,
          icon: "b-fw-icon b-icon-remove",
          cls: "b-separator",
          weight: 400,
          disabled: me.disabled || me.isMulti && !me.columnHasRemovableFilters(column),
          onItem: () => me.removeFilter(column)
        };
      }
      if (me.isMulti) {
        items2.filterDisable = {
          text: "L{disableFilter}",
          localeClass: me,
          icon: "b-fw-icon b-icon-filter-disable",
          cls: "b-separator",
          weight: 400,
          disabled: me.disabled || !me.columnHasEnabledFilters(column),
          onItem: () => me.disableFilter(column)
        };
      }
    }
  }
  columnHasRemovableFilters(column) {
    const me = this;
    return Boolean(me.getCurrentMultiFilters(column).find((filter) => !me.canDeleteFilter || me.callback(me.canDeleteFilter, me, [filter]) !== false));
  }
  columnHasEnabledFilters(column) {
    return Boolean(this.getCurrentMultiFilters(column).find((filter) => !filter.disabled));
  }
  populateHeaderMenu({
    column,
    items: items2
  }) {
    const me = this;
    if (column.meta.isFiltered) {
      items2.editFilter = {
        text: "L{editFilter}",
        localeClass: me,
        weight: 100,
        icon: "b-fw-icon b-icon-filter",
        cls: "b-separator",
        disabled: me.disabled,
        onItem: () => me.showFilterEditor(column)
      };
      items2.removeFilter = {
        text: "L{removeFilter}",
        localeClass: me,
        weight: 110,
        icon: "b-fw-icon b-icon-remove",
        disabled: me.disabled || me.isMulti && !me.columnHasRemovableFilters(column),
        onItem: () => me.removeFilter(column)
      };
      if (me.isMulti) {
        items2.disableFilter = {
          text: "L{disableFilter}",
          localeClass: me,
          icon: "b-fw-icon b-icon-filter-disable",
          weight: 115,
          disabled: me.disabled || !me.columnHasEnabledFilters(column),
          onItem: () => me.disableFilter(column)
        };
      }
    } else if (column.filterable !== false) {
      items2.filter = {
        text: "L{filter}",
        localeClass: me,
        weight: 100,
        icon: "b-fw-icon b-icon-filter",
        cls: "b-separator",
        disabled: me.disabled,
        onItem: () => me.showFilterEditor(column)
      };
    }
  }
  onStoreBeforeFilter({
    filters
  }) {
    const {
      columns
    } = this.client;
    for (let i = 0; i < filters.count; i++) {
      const filter = filters.getAt(i);
      if (!filter.internal) {
        var _column$filterable;
        const column = (filter.columnOwned || this.prioritizeColumns) && columns.find((col) => col.filterable !== false && col.field === filter.property);
        if (column !== null && column !== void 0 && (_column$filterable = column.filterable) !== null && _column$filterable !== void 0 && _column$filterable.filterFn) {
          if (!column.$filter) {
            column.$filter = new CollectionFilter({
              columnOwned: true,
              property: filter.property,
              operator: filter.operator,
              value: filter.value,
              filterBy(record) {
                return column.filterable.filterFn({
                  value: this.value,
                  record,
                  operator: this.operator,
                  property: this.property,
                  column
                });
              }
            });
          }
          column.$filter.value = filter.value;
          column.$filter.displayValue = filter.displayValue;
          column.$filter.operator = filter.operator;
          filters.splice(i, 1, column.$filter);
        }
      }
    }
  }
  onStoreFilter() {
    this.refreshHeaders(false);
  }
  renderHeader() {
    this.refreshHeaders(false);
  }
  onElementClick({
    target
  }) {
    if (this.filterEditorPopup) {
      this.closeFilterEditor();
    }
    if (target.classList.contains("b-filter-icon")) {
      const headerEl = target.closest(".b-grid-header");
      this.showFilterEditor(headerEl.dataset.columnId);
      return false;
    }
  }
  showFilterEditorByKey({
    target
  }) {
    const headerEl = target.matches(".b-grid-header") && target;
    if (headerEl) {
      this.showFilterEditor(headerEl.dataset.columnId);
    }
    return Boolean(headerEl);
  }
  isActionAvailable(key, action, event) {
    const headerElement = event.target.closest(".b-grid-header"), column = headerElement && this.client.columns.find((col) => col.id === headerElement.dataset.columnId);
    return Boolean(column === null || column === void 0 ? void 0 : column.filterable);
  }
};
Filter._$name = "Filter";
GridFeatureManager.registerFeature(Filter);
var complexOperators = {
  "*": null,
  isIncludedIn: null,
  startsWith: null,
  endsWidth: null
};
var FilterBar = class extends InstancePlugin {
  static get $name() {
    return "FilterBar";
  }
  static get configurable() {
    return {
      prioritizeColumns: false,
      keyStrokeFilterDelay: 300,
      compactMode: false,
      clearStoreFiltersOnHide: true,
      keyMap: {
        ArrowUp: {
          handler: "disableGridNavigation",
          preventDefault: false
        },
        ArrowRight: {
          handler: "disableGridNavigation",
          preventDefault: false
        },
        ArrowDown: {
          handler: "disableGridNavigation",
          preventDefault: false
        },
        ArrowLeft: {
          handler: "disableGridNavigation",
          preventDefault: false
        },
        Enter: {
          handler: "disableGridNavigation",
          preventDefault: false
        }
      }
    };
  }
  static get pluginConfig() {
    return {
      before: ["renderContents"],
      chain: ["afterColumnsChange", "renderHeader", "populateHeaderMenu", "bindStore"]
    };
  }
  static get properties() {
    return {
      filterFieldCls: "b-filter-bar-field",
      filterFieldInputCls: "b-filter-bar-field-input",
      filterableColumnCls: "b-filter-bar-enabled",
      filterFieldInputSelector: ".b-filter-bar-field-input",
      filterableColumnSelector: ".b-filter-bar-enabled",
      filterParseRegExp: /^\s*([<>=*])?(.*)$/,
      storeTrackingSuspended: 0
    };
  }
  construct(grid, config) {
    if (grid.features.filter) {
      throw new Error("Grid.feature.FilterBar feature may not be used together with Grid.feature.Filter, These features are mutually exclusive.");
    }
    const me = this;
    me.grid = grid;
    me.onColumnFilterFieldChange = me.onColumnFilterFieldChange.bind(me);
    super.construct(grid, Array.isArray(config) ? {
      filter: config
    } : config);
    me.bindStore(grid.store);
    if (me.filter) {
      grid.store.filter(me.filter);
    }
    me.gridDetacher = grid.ion({
      beforeElementClick: "onBeforeElementClick",
      thisObj: me
    });
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      beforeFilter: "onStoreBeforeFilter",
      filter: "onStoreFilter",
      thisObj: this
    });
  }
  doDestroy() {
    var _this$gridDetacher;
    this.destroyFilterBar();
    (_this$gridDetacher = this.gridDetacher) === null || _this$gridDetacher === void 0 ? void 0 : _this$gridDetacher.call(this);
    super.doDestroy();
  }
  doDisable(disable) {
    const {
      columns
    } = this.grid;
    columns === null || columns === void 0 ? void 0 : columns.forEach((column) => {
      const widget = this.getColumnFilterField(column);
      if (widget) {
        widget.disabled = disable;
      }
    });
    super.doDisable(disable);
  }
  updateCompactMode(value) {
    this.client.headerContainer.classList[value ? "add" : "remove"]("b-filter-bar-compact");
    for (const prop in this._columnFilters) {
      const field = this._columnFilters[prop];
      field.placeholder = value ? field.column.headerText : null;
    }
  }
  destroyFilterBar() {
    var _this$grid$columns;
    (_this$grid$columns = this.grid.columns) === null || _this$grid$columns === void 0 ? void 0 : _this$grid$columns.forEach(this.destroyColumnFilterField, this);
  }
  hideFilterBar() {
    var _me$grid$columns;
    const me = this;
    me.clearStoreFiltersOnHide && me.suspendStoreTracking();
    (_me$grid$columns = me.grid.columns) === null || _me$grid$columns === void 0 ? void 0 : _me$grid$columns.forEach((col) => me.hideColumnFilterField(col, true));
    me.grid.store.filter();
    me.clearStoreFiltersOnHide && me.resumeStoreTracking();
    me.hidden = true;
  }
  showFilterBar() {
    this.suspendStoreTracking();
    this.renderFilterBar();
    this.resumeStoreTracking();
    this.hidden = false;
  }
  toggleFilterBar() {
    if (this.hidden) {
      this.showFilterBar();
    } else {
      this.hideFilterBar();
    }
  }
  renderFilterBar() {
    if (this.grid.hideHeaders) {
      return;
    }
    this.grid.columns.visibleColumns.forEach((column) => this.renderColumnFilterField(column));
    this.rendered = true;
  }
  renderColumnFilterField(column) {
    const me = this, {
      grid
    } = me, filterable = me.getColumnFilterable(column);
    if (filterable && column.isVisible) {
      const headerEl = column.element, filter = grid.store.filters.get(column.id) || grid.store.filters.getBy("property", column.field);
      let widget = me.getColumnFilterField(column);
      if (!widget) {
        const type = `${column.filterType || "text"}field`, {
          filterField
        } = filterable, externalCls = filterField === null || filterField === void 0 ? void 0 : filterField.cls;
        if (externalCls) {
          delete filterable.filterField.cls;
        }
        widget = WidgetHelper.append(ObjectHelper.assign({
          type,
          cls: {
            [me.filterFieldCls]: 1,
            [externalCls]: externalCls
          },
          dataset: {
            column: column.field
          },
          column,
          owner: grid,
          clearable: true,
          name: column.field,
          value: filter && !filter._filterBy && !filter.internal ? me.buildFilterValue(filter) : "",
          inputCls: me.filterFieldInputCls,
          keyStrokeChangeDelay: me.keyStrokeFilterDelay,
          onChange: me.onColumnFilterFieldChange,
          onClear: me.onColumnFilterFieldChange,
          disabled: me.disabled,
          placeholder: me.compactMode ? column.headerText : null,
          format: column.format
        }, filterField), headerEl)[0];
        if (!(filterField !== null && filterField !== void 0 && filterField.hasOwnProperty("min"))) {
          Object.defineProperty(widget, "min", {
            get: () => {
              var _column$editor;
              return (_column$editor = column.editor) === null || _column$editor === void 0 ? void 0 : _column$editor.min;
            },
            set: () => null
          });
        }
        if (!(filterField !== null && filterField !== void 0 && filterField.hasOwnProperty("max"))) {
          Object.defineProperty(widget, "max", {
            get: () => {
              var _column$editor2;
              return (_column$editor2 = column.editor) === null || _column$editor2 === void 0 ? void 0 : _column$editor2.max;
            },
            set: () => null
          });
        }
        if (!(filterField !== null && filterField !== void 0 && filterField.hasOwnProperty("strictParsing"))) {
          Object.defineProperty(widget, "strictParsing", {
            get: () => {
              var _column$editor3;
              return (_column$editor3 = column.editor) === null || _column$editor3 === void 0 ? void 0 : _column$editor3.strictParsing;
            },
            set: () => null
          });
        }
        widget.element.retainElement = true;
        me.setColumnFilterField(column, widget);
        const hasFilterFieldStoreData = (filterField === null || filterField === void 0 ? void 0 : filterField.store) && (filterField.store.readUrl || filterField.store.data || filterField.store.isChained);
        if (widget.isCombo && !hasFilterFieldStoreData && widget.store.count === 0) {
          const configuredValue = widget.value, refreshData = () => {
            if (!(widget.store.readUrl || widget.store.isChained)) {
              widget.store.data = grid.store.getDistinctValues(column.field, true).map((value) => grid.store.modelClass.new({
                id: value,
                [column.field]: value
              }));
            }
          };
          widget.value = null;
          if (!widget.store.isSorted) {
            widget.store.sort({
              field: column.field,
              ascending: true
            });
          }
          widget.picker.ion({
            beforeShow: refreshData
          });
          refreshData();
          widget.value = configuredValue;
        }
        if (!me.filter && widget.value && grid.store.autoLoad !== false) {
          me.onColumnFilterFieldChange({
            source: widget,
            value: widget.value
          });
        }
      } else {
        me.onColumnFilterFieldChange({
          source: widget,
          value: widget.value
        });
        widget.render(headerEl);
        widget.show();
      }
      headerEl.classList.add(me.filterableColumnCls);
    }
  }
  updateColumnFilterFields() {
    const me = this, {
      columns,
      store
    } = me.grid;
    let field, filter;
    me._updatingFields = true;
    for (const column of columns.visibleColumns) {
      field = me.getColumnFilterField(column);
      if (field) {
        filter = store.filters.get(column.id) || store.filters.getBy("property", column.field);
        if (filter && !filter.internal) {
          if (!filter._filterBy) {
            field.value = me.buildFilterValue(filter);
          } else {
            field.value = filter.value;
          }
        } else {
          field.value = "";
        }
      }
    }
    me._updatingFields = false;
  }
  getColumnFilterable(column) {
    if (!column.isRoot && column.filterable !== false && column.field && column.isLeaf) {
      if (typeof column.filterable === "function") {
        column.filterable = {
          filterFn: column.filterable
        };
      }
      return column.filterable;
    }
  }
  destroyColumnFilterField(column) {
    const widget = this.getColumnFilterField(column);
    if (widget) {
      this.hideColumnFilterField(column, true);
      widget.destroy();
      this.setColumnFilterField(column, void 0);
    }
  }
  hideColumnFilterField(column, silent) {
    const me = this, {
      store
    } = me.grid, columnEl = column.element, widget = me.getColumnFilterField(column);
    if (widget) {
      if (!me.isDestroying) {
        widget.hide();
      }
      const {
        $filter
      } = column;
      if (!store.isDestroyed && me.clearStoreFiltersOnHide && $filter) {
        store.removeFilter($filter, silent);
      }
      columnEl === null || columnEl === void 0 ? void 0 : columnEl.classList.remove(me.filterableColumnCls);
    }
  }
  getColumnFilterField(column) {
    var _this$_columnFilters;
    return (_this$_columnFilters = this._columnFilters) === null || _this$_columnFilters === void 0 ? void 0 : _this$_columnFilters[column.id];
  }
  setColumnFilterField(column, widget) {
    this._columnFilters = this._columnFilters || {};
    this._columnFilters[column.data.id] = widget;
  }
  parseFilterValue(column, value, field) {
    var _column$filterable;
    if (Array.isArray(value)) {
      return {
        value
      };
    }
    if (ObjectHelper.isDate(value)) {
      return {
        operator: field.isDateField ? "sameDay" : field.isTimeField ? "sameTime" : "=",
        value
      };
    }
    const match = String(value).match(this.filterParseRegExp);
    return {
      operator: match[1] || ((_column$filterable = column.filterable) === null || _column$filterable === void 0 ? void 0 : _column$filterable.operator) || "*",
      value: match[2]
    };
  }
  buildFilterValue({
    operator,
    value
  }) {
    return value instanceof Date || Array.isArray(value) ? value : (operator in complexOperators ? "" : operator) + value;
  }
  onStoreBeforeFilter({
    filters
  }) {
    const {
      columns
    } = this.client;
    for (let i = 0; i < filters.count; i++) {
      var _column$filterable2;
      const filter = filters.getAt(i), column = (filter.columnOwned || this.prioritizeColumns) && columns.find((col) => col.filterable !== false && col.field === filter.property);
      if (column !== null && column !== void 0 && (_column$filterable2 = column.filterable) !== null && _column$filterable2 !== void 0 && _column$filterable2.filterFn) {
        if (!column.$filter) {
          column.$filter = new CollectionFilter({
            columnOwned: true,
            property: filter.property,
            id: column.id,
            filterBy(record) {
              return column.filterable.filterFn({
                value: this.value,
                record,
                property: this.property,
                column
              });
            }
          });
        }
        column.$filter.value = filter.value;
        filters.splice(i, 1, column.$filter);
      }
    }
  }
  onStoreFilter() {
    if (!this.storeTrackingSuspended && this.rendered) {
      this.updateColumnFilterFields();
    }
  }
  afterColumnsChange({
    changes,
    column
  }) {
    if (!this.hidden && changes !== null && changes !== void 0 && changes.hidden) {
      const hidden = changes.hidden.value;
      if (hidden) {
        this.destroyColumnFilterField(column);
      } else {
        this.renderColumnFilterField(column);
      }
    }
  }
  suspendStoreTracking() {
    this.storeTrackingSuspended++;
  }
  resumeStoreTracking() {
    this.storeTrackingSuspended--;
  }
  renderHeader() {
    if (!this.hidden) {
      this.renderFilterBar();
    }
  }
  renderContents() {
    if (this._columnFilters) {
      for (const field of Object.values(this._columnFilters)) {
        field === null || field === void 0 ? void 0 : field.element.remove();
      }
    }
  }
  disableGridNavigation(event) {
    if (event.target.matches(this.filterFieldInputSelector)) {
      return true;
    }
    return false;
  }
  onBeforeElementClick({
    event
  }) {
    if (event.target.closest(`.${this.filterFieldCls}`)) {
      return false;
    }
  }
  onColumnFilterFieldChange({
    source: field,
    value
  }) {
    const me = this, {
      column
    } = field, {
      filterFn
    } = column.filterable, {
      store
    } = me.grid, filter = column.$filter || store.filters.find((f) => (f.id === column.id || f.property === column.field) && !f.internal);
    if (me._updatingFields) {
      return;
    }
    const isClearingFilter = value == null || value === "" || Array.isArray(value) && value.length === 0;
    store.removeFilter(filter, true);
    column.$filter = null;
    if (isClearingFilter) {
      if (!filter) {
        return;
      }
    } else {
      var _column$filterable3, _column$filterable4;
      column.$filter = store.addFilter(_objectSpread2(_objectSpread2({
        property: field.name
      }, me.parseFilterValue(column, value, field)), {}, {
        [typeof ((_column$filterable3 = column.filterable) === null || _column$filterable3 === void 0 ? void 0 : _column$filterable3.caseSensitive) === "boolean" ? "caseSensitive" : void 0]: (_column$filterable4 = column.filterable) === null || _column$filterable4 === void 0 ? void 0 : _column$filterable4.caseSensitive,
        [filterFn ? "filterBy" : "_"]: function(record) {
          return filterFn({
            value: this.value,
            record,
            operator: this.operator,
            property: this.property,
            column
          });
        }
      }), true);
    }
    store.filter();
  }
  populateHeaderMenu({
    items: items2
  }) {
    items2.toggleFilterBar = {
      text: this.hidden ? "L{enableFilterBar}" : "L{disableFilterBar}",
      localeClass: this,
      weight: 120,
      icon: "b-fw-icon b-icon-filter",
      cls: "b-separator",
      onItem: () => this.toggleFilterBar()
    };
  }
};
FilterBar.featureClass = "b-filter-bar";
FilterBar._$name = "FilterBar";
GridFeatureManager.registerFeature(FilterBar);
var Group = class extends InstancePlugin {
  static get $name() {
    return "Group";
  }
  static get configurable() {
    return {
      field: null,
      groupSortFn: null,
      renderer: null,
      keyMap: {
        " ": "toggleGroup"
      }
    };
  }
  construct(grid, config) {
    const me = this;
    if (grid.features.tree) {
      return;
    }
    me._thisIsAUsedExpression(grid.features.groupSummary);
    config = me.processConfig(config);
    me.grid = grid;
    super.construct(grid, config);
    me.bindStore(grid.store);
    grid.rowManager.ion({
      beforeRenderRow: "onBeforeRenderRow",
      renderCell: "renderCell",
      prio: 1100,
      thisObj: me
    });
  }
  processConfig(config) {
    if (typeof config === "string") {
      return {
        field: config,
        ascending: null
      };
    }
    return config;
  }
  setConfig(config) {
    if (config === null) {
      this.store.clearGroupers();
    } else {
      super.setConfig(this.processConfig(config));
    }
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      group: "onStoreGroup",
      change: "onStoreChange",
      thisObj: this
    });
  }
  updateRenderer(renderer) {
    this.groupRenderer = renderer;
  }
  updateField(field) {
    this.store.group({
      field,
      ascending: this.ascending,
      fn: this.groupSortFn
    });
  }
  updateGroupSortFn(fn) {
    if (!this.isConfiguring) {
      this.store.group({
        field: this.field,
        ascending: this.ascending,
        fn
      });
    }
  }
  doDestroy() {
    super.doDestroy();
  }
  doDisable(disable) {
    const {
      store
    } = this;
    if (disable && store.isGrouped) {
      const {
        sorters
      } = store;
      sorters.unshift(...store.groupers);
      store.clearGroupers();
      store.sort(sorters);
    }
    super.doDisable(disable);
  }
  get store() {
    return this.grid.store;
  }
  static get pluginConfig() {
    return {
      assign: ["collapseAll", "expandAll"],
      chain: ["renderHeader", "populateHeaderMenu", "getColumnDragToolbarItems", "onElementTouchStart", "onElementClick", "bindStore"]
    };
  }
  toggleCollapse(recordOrId, collapse) {
    this.internalToggleCollapse(recordOrId, collapse);
  }
  internalToggleCollapse(recordOrId, collapse, skipRender = false) {
    const me = this, {
      store,
      grid
    } = me, groupRecord = store.getById(recordOrId);
    if (!groupRecord.isGroupHeader) {
      return;
    }
    collapse = collapse === void 0 ? !groupRecord.meta.collapsed : collapse;
    if (grid.trigger("beforeToggleGroup", {
      groupRecord,
      collapse
    }) === false) {
      return;
    }
    if (collapse) {
      store.collapse(groupRecord);
    } else {
      store.expand(groupRecord);
    }
    if (!skipRender) {
      if (grid.rowManager.rowCount > grid.store.count) {
        grid.rowManager.renderFromRow();
      } else {
        grid.rowManager.renderFromRecord(groupRecord);
      }
    }
    grid.trigger("toggleGroup", {
      groupRecord,
      collapse
    });
    grid.afterToggleGroup();
  }
  collapseAll() {
    const me = this;
    if (me.store.isGrouped && !me.disabled) {
      me.store.groupRecords.forEach((r) => me.internalToggleCollapse(r, true, true));
      me.grid.refreshRows(true);
    }
  }
  expandAll() {
    const me = this;
    if (me.store.isGrouped && !me.disabled) {
      me.store.groupRecords.forEach((r) => me.internalToggleCollapse(r, false, true));
      me.grid.refreshRows();
    }
  }
  onBeforeRenderRow({
    row
  }) {
    const oldRecord = row.grid.store.getById(row.id);
    row.forceInnerHTML = row.forceInnerHTML || (oldRecord === null || oldRecord === void 0 ? void 0 : oldRecord.isGroupHeader);
  }
  renderCell(renderData) {
    const me = this, {
      cellElement,
      row,
      column
    } = renderData, {
      meta
    } = renderData.record, rowClasses = {
      "b-group-row": 0,
      "b-grid-group-collapsed": 0
    };
    if (!me.disabled && me.store.isGrouped && "groupRowFor" in meta) {
      if (column.type === "action") {
        return;
      }
      column.clearCell(cellElement);
      rowClasses["b-grid-group-collapsed"] = meta.collapsed;
      rowClasses["b-group-row"] = 1;
      if (column === me.groupHeaderColumn) {
        cellElement.classList.add("b-group-title");
        cellElement.$groupHeader = true;
      }
      me.buildGroupHeader(renderData);
    } else if (cellElement.$groupHeader) {
      cellElement.classList.remove("b-group-title");
      cellElement.$groupHeader = false;
    }
    row.assignCls(rowClasses);
  }
  buildGroupHeader(renderData) {
    const me = this, {
      record,
      cellElement,
      column,
      persist
    } = renderData, {
      grid
    } = me, meta = record.meta, {
      groupRowFor
    } = meta, {
      groupSummary
    } = grid.features, count = meta.childCount - (groupSummary && groupSummary.target !== "header" ? 1 : 0);
    let html = null, applyDefault = true;
    if (persist || column) {
      const groupColumn = grid.columns.get(meta.groupField), isGroupHeaderColumn = renderData.isFirstColumn = column === me.groupHeaderColumn;
      if (groupColumn !== null && groupColumn !== void 0 && groupColumn.groupRenderer) {
        if (isGroupHeaderColumn) {
          html = groupColumn.groupRenderer(_objectSpread2(_objectSpread2({}, renderData), {}, {
            groupRowFor,
            groupRecords: record.groupChildren,
            groupColumn,
            count
          }));
          applyDefault = false;
        }
      } else if (me.groupRenderer) {
        html = me.groupRenderer(_objectSpread2(_objectSpread2({}, renderData), {}, {
          groupRowFor,
          groupRecords: record.groupChildren,
          groupColumn,
          count,
          isFirstColumn: isGroupHeaderColumn
        }));
      }
      if (isGroupHeaderColumn && html == null && applyDefault && DomHelper.getChildElementCount(cellElement) === 0) {
        html = StringHelper.encodeHtml(`${groupRowFor === "__novalue__" ? "" : groupRowFor} (${count})`);
      }
    } else if (me.groupRenderer) {
      html = me.groupRenderer(renderData);
    }
    if (typeof html === "string") {
      cellElement.innerHTML = html;
    } else if (typeof html === "object") {
      DomSync.sync({
        targetElement: cellElement,
        domConfig: {
          onlyChildren: true,
          children: ArrayHelper.asArray(html)
        }
      });
    }
    if (DomHelper.getChildElementCount(cellElement) > 0) {
      cellElement._hasHtml = true;
    }
    return cellElement.innerHTML;
  }
  get groupHeaderColumn() {
    return this.grid.columns.visibleColumns.find((column) => !column.groupHeaderReserved);
  }
  renderHeader(headerContainerElement) {
    const {
      store,
      grid
    } = this;
    if (store.isGrouped) {
      for (const groupInfo of store.groupers) {
        const column = grid.columns.get(groupInfo.field), header = column && grid.getHeaderElement(column.id);
        header === null || header === void 0 ? void 0 : header.classList.add("b-group", groupInfo.ascending ? "b-asc" : "b-desc");
      }
    }
  }
  populateHeaderMenu({
    column,
    items: items2
  }) {
    const me = this;
    if (column.groupable !== false) {
      items2.groupAsc = {
        text: "L{groupAscending}",
        localeClass: me,
        icon: "b-fw-icon b-icon-group-asc",
        cls: "b-separator",
        weight: 400,
        disabled: me.disabled,
        onItem: () => me.store.group(column.field, true)
      };
      items2.groupDesc = {
        text: "L{groupDescending}",
        localeClass: me,
        icon: "b-fw-icon b-icon-group-desc",
        weight: 410,
        disabled: me.disabled,
        onItem: () => me.store.group(column.field, false)
      };
    }
    if (me.store.isGrouped) {
      items2.groupRemove = {
        text: "L{stopGrouping}",
        localeClass: me,
        icon: "b-fw-icon b-icon-clear",
        cls: column.groupable ? "" : "b-separator",
        weight: 420,
        disabled: me.disabled,
        onItem: () => me.store.clearGroupers()
      };
    }
  }
  getColumnDragToolbarItems(column, items2) {
    var _store$groupers;
    const me = this, {
      store,
      disabled
    } = me;
    items2.push({
      text: "L{groupAscendingShort}",
      group: "L{group}",
      localeClass: me,
      icon: "b-icon b-icon-group-asc",
      ref: "groupAsc",
      cls: "b-separator",
      weight: 110,
      disabled,
      onDrop: ({
        column: column2
      }) => store.group(column2.field, true)
    });
    items2.push({
      text: "L{groupDescendingShort}",
      group: "L{group}",
      localeClass: me,
      icon: "b-icon b-icon-group-desc",
      ref: "groupDesc",
      weight: 110,
      disabled,
      onDrop: ({
        column: column2
      }) => store.group(column2.field, false)
    });
    const grouped = ((_store$groupers = store.groupers) === null || _store$groupers === void 0 ? void 0 : _store$groupers.some((col) => col.field === column.field)) && !disabled;
    items2.push({
      text: "L{stopGroupingShort}",
      group: "L{group}",
      localeClass: me,
      icon: "b-icon b-icon-clear",
      ref: "groupRemove",
      disabled: !grouped,
      weight: 110,
      onDrop: ({
        column: column2
      }) => store.removeGrouper(column2.field)
    });
    return items2;
  }
  onStoreGroup({
    groupers
  }) {
    const {
      grid
    } = this, {
      element
    } = grid, curGroupHeaders = element && DomHelper.children(element, ".b-grid-header.b-group");
    if (element) {
      for (const header of curGroupHeaders) {
        header.classList.remove("b-group", "b-asc", "b-desc");
      }
      if (groupers) {
        for (const groupInfo of groupers) {
          const header = grid.getHeaderElementByField(groupInfo.field);
          if (header) {
            header.classList.add("b-group", groupInfo.ascending ? "b-asc" : "b-desc");
          }
        }
      }
    }
  }
  onStoreChange({
    action,
    records
  }) {
    const {
      client
    } = this, {
      rowManager,
      store
    } = client;
    if (store.isGrouped && action === "move") {
      const {
        field
      } = store.groupers[0], fromRow = Math.min(...records.reduce((result, record) => {
        result.push(store.indexOf(record.instanceMeta(store).groupParent));
        if (field in record.meta.modified) {
          const oldGroup = store.groupRecords.find((r) => r.meta.groupRowFor === record.meta.modified[field]);
          if (oldGroup) {
            result.push(store.indexOf(oldGroup));
          }
        }
        return result;
      }, []));
      rowManager.renderFromRow(rowManager.getRow(fromRow));
    }
  }
  onElementTouchStart(event) {
    const me = this, {
      target
    } = event, header = target.closest(".b-grid-header"), column = header && me.grid.getColumnFromElement(header);
    if (event.touches.length > 1 && column && column.groupable !== false && !me.disabled) {
      me.store.group(column.field);
    }
  }
  onElementClick(event) {
    const me = this, {
      store
    } = me, {
      target
    } = event, row = target.closest(".b-group-row"), header = target.closest(".b-grid-header"), field = header === null || header === void 0 ? void 0 : header.dataset.column;
    if (target.classList.contains("b-resizer") || me.disabled || target.classList.contains("b-action-item") || event.handled) {
      return;
    }
    if (header && field) {
      var _store$groupers2;
      const columnGrouper = (_store$groupers2 = store.groupers) === null || _store$groupers2 === void 0 ? void 0 : _store$groupers2.find((g) => g.field === field);
      if (columnGrouper && !event.shiftKey) {
        store.group(field, !columnGrouper.ascending);
        return false;
      } else if (event.shiftKey) {
        const column = me.grid.columns.get(field);
        if (column.groupable !== false) {
          if (event.altKey) {
            store.removeGrouper(field);
          } else {
            store.group(field);
          }
        }
      }
    }
    if (row) {
      me.internalToggleCollapse(DomDataStore.get(row).id);
      return false;
    }
  }
  toggleGroup(event) {
    var _focusedCell$record;
    const {
      grid
    } = this, {
      focusedCell
    } = grid;
    if (!this.disabled && !focusedCell.isActionable && (_focusedCell$record = focusedCell.record) !== null && _focusedCell$record !== void 0 && _focusedCell$record.isGroupHeader) {
      this.internalToggleCollapse(focusedCell.id);
      return true;
    }
    return false;
  }
};
Group._$name = "Group";
GridFeatureManager.registerFeature(Group, true, ["Grid", "Scheduler"]);
GridFeatureManager.registerFeature(Group, false, ["TreeGrid"]);
var SummaryFormatter = (Target) => class SummaryFormatter extends (Target || Base) {
  static get $name() {
    return "SummaryFormatter";
  }
  generateHtml(column, records, cls, groupRecord, groupField, groupValue) {
    const store = this.store, summaries = column.summaries || (column.sum ? [{
      sum: column.sum,
      renderer: column.summaryRenderer
    }] : []);
    let html = `<table class="${cls}">`;
    summaries.forEach((config) => {
      let type = config.sum, sum = null;
      if (type === true)
        type = "sum";
      switch (type) {
        case "sum":
        case "add":
          sum = store.sum(column.field, records);
          break;
        case "max":
          sum = store.max(column.field, records);
          break;
        case "min":
          sum = store.min(column.field, records);
          break;
        case "average":
        case "avg":
          sum = store.average(column.field, records);
          break;
        case "count":
          sum = records.length;
          break;
        case "countNotEmpty":
          sum = records.reduce((sum2, record) => {
            const value = record[column.field];
            return sum2 + (value != null ? 1 : 0);
          }, 0);
          break;
      }
      if (typeof type === "function") {
        sum = records.reduce(type, "seed" in config ? config.seed : 0);
      }
      if (sum !== null) {
        const valueCls = "b-grid-summary-value", labelHtml = config.label ? `<td class="b-grid-summary-label">${config.label}</td>` : "";
        let valueHtml = config.renderer ? config.renderer({
          config,
          sum
        }) : sum, summaryHtml;
        if (valueHtml == null) {
          valueHtml = "";
        }
        if (!String(valueHtml).includes("<td>")) {
          summaryHtml = labelHtml ? `${labelHtml}<td class="${valueCls}">${valueHtml}</td>` : `<td colspan="2" class="${valueCls}">${valueHtml}</td>`;
        } else {
          summaryHtml = valueHtml;
        }
        html += `<tr>${summaryHtml}</tr>`;
      }
    });
    return html + "</table>";
  }
};
var GroupSummary = class extends SummaryFormatter(InstancePlugin) {
  static get $name() {
    return "GroupSummary";
  }
  static get configurable() {
    return {
      collapseToHeader: null,
      target: "footer"
    };
  }
  construct(grid, config) {
    this.grid = grid;
    super.construct(grid, config);
    if (!grid.features.group) {
      throw new Error("Requires Group feature to work, please enable");
    }
    this.bindStore(grid.store);
    grid.rowManager.ion({
      beforeRenderRow: "onBeforeRenderRow",
      renderCell: "renderCell",
      prio: 1e3,
      thisObj: this
    });
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      update: "onStoreUpdate",
      prio: 1,
      thisObj: this
    });
  }
  get store() {
    return this.grid.store;
  }
  doDisable(disable) {
    this.updateTarget(this.target);
    super.doDisable(disable);
  }
  changeTarget(target) {
    ObjectHelper.assertString(target, "target");
    return target;
  }
  updateTarget(target) {
    this.store.useGroupFooters = !this.disabled && target === "footer";
    if (!this.isConfiguring) {
      this.store.group();
    }
  }
  changeCollapseToHeader(collapseToHeader) {
    ObjectHelper.assertBoolean(collapseToHeader, "collapseToHeader");
    return collapseToHeader;
  }
  updateCollapseToHeader() {
    if (!this.isConfiguring) {
      this.store.group();
    }
  }
  static get pluginConfig() {
    return {
      chain: ["bindStore"]
    };
  }
  onBeforeRenderRow({
    row,
    record
  }) {
    if (row.isGroupFooter && !("groupFooterFor" in record.meta)) {
      row.isGroupFooter = false;
      row.forceInnerHTML = true;
    } else if (row.isGroupHeader && !record.meta.collapsed) {
      row.eachElement(this.removeSummaryElements);
    }
  }
  removeSummaryElements(rowEl) {
  }
  renderCell({
    column,
    cellElement,
    row,
    record,
    size,
    isFirstColumn
  }) {
    const me = this, {
      meta
    } = record, {
      rowHeight
    } = me.grid, isGroupHeader = "groupRowFor" in meta, isGroupFooter = "groupFooterFor" in meta, targetsHeader = me.target === "header", rowClasses = {
      "b-group-footer": 0,
      "b-header-summary": 0
    }, isSummaryTarget = isGroupHeader && (targetsHeader || me.collapseToHeader && meta.collapsed) && !isFirstColumn || isGroupFooter && !targetsHeader;
    if (isGroupHeader || isGroupFooter) {
      size.height = rowHeight;
    }
    if (me.store.isGrouped && isSummaryTarget && !me.disabled) {
      column.clearCell(cellElement);
      const groupRecord = isGroupHeader ? record : meta.groupRecord;
      row.isGroupFooter = isGroupFooter;
      row.isGroupHeader = isGroupHeader;
      if (isGroupFooter) {
        rowClasses["b-group-footer"] = 1;
      } else {
        rowClasses["b-header-summary"] = 1;
      }
      const heightSetting = me.updateSummaryHtml(cellElement, column, groupRecord), count = typeof heightSetting === "number" ? heightSetting : heightSetting.count;
      if (count > 1) {
        size.height += meta.collapsed && !targetsHeader ? 0 : count * rowHeight * 0.1;
      }
      if (heightSetting.height) {
        size.height += heightSetting.height;
      }
    }
    row.assignCls(rowClasses);
  }
  updateSummaryHtml(cellElement, column, groupRecord) {
    const records = groupRecord.groupChildren.slice();
    if (records[records.length - 1].isGroupFooter) {
      records.pop();
    }
    const html = this.generateHtml(column, records, "b-grid-group-summary", groupRecord, groupRecord.meta.groupField, groupRecord.meta.groupRowFor);
    if (!cellElement.children.length) {
      cellElement.innerHTML = html;
    } else {
      DomHelper.sync(html, cellElement.firstElementChild);
    }
    return column.summaries ? column.summaries.length : column.sum ? 1 : 0;
  }
  onStoreUpdate({
    source: store,
    changes
  }) {
    if (!this.disabled && store.isGrouped) {
      if (changes && store.groupers.find((grouper) => grouper.field in changes)) {
        return;
      }
      const shouldUpdate = Object.keys(changes).some((field) => {
        const colField = this.grid.columns.get(field);
        return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));
      });
      if (shouldUpdate) {
        this.grid.forceFullRefresh = true;
      }
    }
  }
  refresh() {
    this.grid.columns.visibleColumns.forEach((column) => {
      if (this.hasSummary(column)) {
        this.grid.refreshColumn(column);
      }
    });
  }
  hasSummary(column) {
    return column.sum || column.summaries;
  }
};
GroupSummary.featureClass = "b-group-summary";
GroupSummary._$name = "GroupSummary";
GridFeatureManager.registerFeature(GroupSummary);
var HeaderMenu = class extends ContextMenuBase {
  static get $name() {
    return "HeaderMenu";
  }
  static get configurable() {
    return {
      type: "header",
      items: null,
      moveColumns: null
    };
  }
  static get defaultConfig() {
    return {
      processItems: null
    };
  }
  static get pluginConfig() {
    const config = super.pluginConfig;
    config.chain.push("populateHeaderMenu");
    return config;
  }
  shouldShowMenu(eventParams) {
    const {
      column
    } = eventParams;
    return column && column.enableHeaderContextMenu !== false && column !== this.client.timeAxisColumn;
  }
  getDataFromEvent(event) {
    return ObjectHelper.assign(super.getDataFromEvent(event), this.client.getHeaderDataFromEvent(event));
  }
  populateHeaderMenu({
    items: items2,
    column
  }) {
    const me = this;
    if (column) {
      if (column.headerMenuItems) {
        ObjectHelper.merge(items2, column.headerMenuItems);
      }
      if (column.isCollapsible) {
        const {
          collapsed
        } = column, icon = collapsed ? me.client.rtl ? "left" : "right" : me.client.rtl ? "right" : "left";
        items2.toggleCollapse = {
          weight: 215,
          icon: `b-fw-icon b-icon-collapse-${icon}`,
          text: me.L(collapsed ? "L{expandColumn}" : "L{collapseColumn}"),
          onItem: () => column.collapsed = !collapsed
        };
      }
      if (me.moveColumns) {
        const columnToMoveBefore = me.getColumnToMoveBefore(column), columnToMoveAfter = me.getColumnToMoveAfter(column);
        if (columnToMoveBefore) {
          items2.movePrev = {
            weight: 220,
            icon: "b-fw-icon b-icon-column-move-left",
            text: me.L("L{moveBefore}", StringHelper.encodeHtml(columnToMoveBefore.text)),
            onItem: () => {
              const {
                parent: oldParent
              } = column;
              if (columnToMoveBefore.parent.insertChild(column, columnToMoveBefore)) {
                var _oldParent$children;
                column.region = columnToMoveBefore.region;
                if (!((_oldParent$children = oldParent.children) !== null && _oldParent$children !== void 0 && _oldParent$children.length)) {
                  oldParent.remove();
                }
              }
            }
          };
        }
        if (columnToMoveAfter) {
          items2.moveNext = {
            weight: 230,
            icon: "b-fw-icon b-icon-column-move-right",
            text: me.L("L{moveAfter}", StringHelper.encodeHtml(columnToMoveAfter.text)),
            onItem: () => {
              const {
                parent: oldParent
              } = column;
              if (columnToMoveAfter.parent.insertChild(column, columnToMoveAfter.nextSibling)) {
                var _oldParent$children2;
                column.region = columnToMoveAfter.region;
                if (!((_oldParent$children2 = oldParent.children) !== null && _oldParent$children2 !== void 0 && _oldParent$children2.length)) {
                  oldParent.remove();
                }
              }
            }
          };
        }
      }
    }
    return items2;
  }
  getColumnToMoveBefore(column) {
    const {
      previousSibling,
      parent
    } = column;
    if (previousSibling) {
      return previousSibling.children && !column.children ? previousSibling.children[previousSibling.children.length - 1] : previousSibling;
    }
    if (!parent.isRoot) {
      return parent;
    }
  }
  getColumnToMoveAfter(column) {
    const {
      nextSibling,
      parent
    } = column;
    if (nextSibling) {
      return nextSibling;
    }
    if (!parent.isRoot) {
      return parent;
    }
  }
};
HeaderMenu.featureClass = "";
HeaderMenu._$name = "HeaderMenu";
GridFeatureManager.registerFeature(HeaderMenu, true);
var camelCase = {
  mousedown: "mouseDown",
  mousemove: "mouseMove",
  mouseup: "mouseUp",
  touchdown: "touchDown",
  touchmove: "touchMove",
  touchup: "touchUp",
  mouseover: "mouseOver",
  mouseout: "mouseOut",
  dblclick: "dblClick",
  keydown: "keyDown",
  keypress: "keyPress",
  keyup: "keyUp",
  contextmenu: "contextMenu"
};
var MergeCells = class extends InstancePlugin {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "mergedRanges", []);
    _defineProperty(this, "mergedMap", {});
  }
  static get pluginConfig() {
    return {
      chain: [
        "beforeRenderCell",
        "afterRenderRow",
        "bindStore",
        "afterColumnsChange",
        "afterRemove",
        "afterToggleGroup",
        "afterToggleSubGrid",
        "handleEvent",
        "populateHeaderMenu",
        "afterSelectionChange"
      ],
      before: ["onInternalResize"],
      override: ["getColumnFromElement", "getRecordFromElement"]
    };
  }
  afterConstruct() {
    const me = this, {
      client
    } = me;
    client.eachSubGrid((subGrid) => me.setupSubGrid(subGrid));
    client.rowManager.ion({
      renderDone: "onRenderDone",
      thisObj: me
    });
    me.bindStore(client.store);
  }
  setupSubGrid(subGrid) {
    subGrid.$mergedCellsElement = DomHelper.createElement({
      parent: subGrid.element,
      className: {
        "b-grid-merged-cells-container": 1
      }
    });
  }
  doDisable(disable) {
    if (!this.isConfiguring) {
      this.isDisabling = true;
      this.reset();
      this.isDisabling = false;
    }
    super.doDisable(disable);
  }
  updatePassthrough(use) {
    this.client.element.classList.toggle("b-mergecells-passthrough", use);
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      change: "onStoreChange",
      refresh: {
        prio: 1,
        fn: "onStoreRefresh"
      },
      thisObj: this
    });
  }
  onInternalResize() {
    this.refreshBounds();
  }
  beforeRenderCell(renderData) {
    const {
      column,
      record,
      cellElement
    } = renderData, subGrid = this.client.subGrids[column.region];
    if (!this.disabled && column.mergeCells && column.isSorted && !record.isSpecialRow && !subGrid.collapsed) {
      const mergedRange = this.getMergeRange(record, column);
      if (mergedRange !== null && mergedRange !== void 0 && mergedRange.use) {
        cellElement.classList.add("b-merged-cell");
        cellElement.innerHTML = "";
        renderData.cellElement = mergedRange.cellElement;
      }
    }
  }
  afterRenderRow({
    row,
    oldId,
    oldHeight
  }) {
    if (oldId === row.id && oldHeight !== row.height) {
      this.heightChanged = true;
    }
  }
  afterColumnsChange({
    action,
    changes,
    column
  }) {
    if (this.disabled) {
      return;
    }
    if (action === "update" && changes.mergeCells && !column.mergeCells) {
      for (const range of this.mergedRanges.slice()) {
        if (range.column === column) {
          this.removeRange(range);
        }
      }
      this.syncDom();
      return;
    }
    this.refreshBounds();
  }
  afterRemove() {
    !this.disabled && this.reset();
  }
  afterToggleGroup() {
    !this.disabled && this.reset();
  }
  afterToggleSubGrid() {
    !this.disabled && this.reset();
  }
  afterSelectionChange() {
    if (!this.passthrough) {
      const {
        client
      } = this, indices = client.selectedRecords.map((r) => client.store.indexOf(r));
      let changed = false;
      for (const range of this.mergedRanges) {
        let allSelected = true;
        for (let i = range.fromIndex; i <= range.toIndex && allSelected; i++) {
          allSelected = indices.includes(i);
        }
        if (range.isSelected !== allSelected) {
          range.isSelected = allSelected;
          changed = true;
        }
      }
      changed && this.syncDom();
    }
  }
  getRecordFromElement(element) {
    var _element$elementData;
    if ((_element$elementData = element.elementData) !== null && _element$elementData !== void 0 && _element$elementData.range) {
      return this.client.store.getAt(element.elementData.range.fromIndex);
    }
    return this.overridden.getRecordFromElement(element);
  }
  getColumnFromElement(element) {
    var _element$elementData2;
    if ((_element$elementData2 = element.elementData) !== null && _element$elementData2 !== void 0 && _element$elementData2.range) {
      return element.elementData.range.column;
    }
    return this.overridden.getColumnFromElement(element);
  }
  populateHeaderMenu({
    column,
    items: items2
  }) {
    if (column.mergeable !== false) {
      items2.mergeCells = {
        text: "L{MergeCells.mergeCells}",
        icon: `b-fw-icon ${column.mergeCells ? "b-icon-checked" : "b-icon-unchecked"}`,
        tooltip: "L{MergeCells.menuTooltip}",
        cls: "b-separator",
        weight: 500,
        disabled: this.disabled,
        onItem: () => column.mergeCells = !column.mergeCells
      };
    }
  }
  async handleEvent(event) {
    if (!this.passthrough) {
      const mergedCellsElement = event.target.closest(".b-grid-merged-cells");
      if (mergedCellsElement) {
        var _camelCase$event$type;
        const {
          client
        } = this, {
          range
        } = mergedCellsElement.elementData, {
          cellEdit
        } = client.features, {
          column
        } = range, type = StringHelper.capitalize((_camelCase$event$type = camelCase[event.type]) !== null && _camelCase$event$type !== void 0 ? _camelCase$event$type : event.type), eventData = {
          grid: client,
          records: [],
          column,
          cellElement: mergedCellsElement.firstElementChild,
          target: event.target,
          event
        };
        for (let i = range.fromIndex; i <= range.toIndex; i++) {
          eventData.records.push(client.store.getAt(i));
        }
        client.trigger(`mergedCell${type}`, eventData);
        if ((cellEdit === null || cellEdit === void 0 ? void 0 : cellEdit.triggerEvent.toLowerCase()) === `cell${type}`.toLowerCase()) {
          const row = client.rowManager.getRowAt(event.clientY);
          await cellEdit.startEditing({
            id: row.id,
            columnId: column.id
          });
        } else if (event.type === "click") {
          this.onRangeClick({
            range
          });
        }
      }
    }
  }
  onRangeClick({
    range
  }) {
    const records = [];
    for (let i = range.fromIndex; i <= range.toIndex; i++) {
      records.push(this.client.store.getAt(i));
    }
    this.client.selectedRecords = records;
  }
  onStoreChange() {
    !this.disabled && this.reset();
  }
  onStoreRefresh({
    action
  }) {
    if (action !== "filter" && action !== "dataset") {
      !this.disabled && this.reset(false);
    }
  }
  createRangeElement(range) {
    var _parent$syncIdMap$syn, _parent$syncIdMap, _parent$releasedIdMap;
    const parent = this.client.getSubGridFromColumn(range.column).$mergedCellsElement, syncId = `${range.fromIndex}-@-${range.column.id}`;
    let element = (_parent$syncIdMap$syn = (_parent$syncIdMap = parent.syncIdMap) === null || _parent$syncIdMap === void 0 ? void 0 : _parent$syncIdMap[syncId]) !== null && _parent$syncIdMap$syn !== void 0 ? _parent$syncIdMap$syn : (_parent$releasedIdMap = parent.releasedIdMap) === null || _parent$releasedIdMap === void 0 ? void 0 : _parent$releasedIdMap[syncId];
    if (parent.releasedIdMap) {
      delete parent.releasedIdMap[syncId];
    }
    if (!element) {
      element = DomHelper.createElement(this.createRangeDomConfig(range));
    }
    DomSync.addChild(parent, element, syncId);
    range.element = element;
    range.cellElement = element.firstElementChild;
    return element;
  }
  createRangeDomConfig(range) {
    var _column$mergedRendere;
    const {
      column,
      fromIndex,
      toIndex,
      top,
      left,
      width,
      height
    } = range, {
      type
    } = column, record = this.client.store.getAt(fromIndex), domConfig = {
      className: {
        "b-grid-merged-cells": 1,
        "b-selected": range.isSelected
      },
      elementData: {
        range
      },
      style: {
        top,
        left,
        height,
        width
      },
      dataset: {
        syncId: `${fromIndex}-@-${column.id}`,
        fromIndex,
        toIndex,
        column: column.field,
        columnId: column.id
      },
      children: [
        {
          className: new DomClassList(this.client.cellCls).assign({
            [`b-${type === null || type === void 0 ? void 0 : type.toLowerCase()}-cell`]: type,
            [column.cellCls]: column.cellCls,
            [column.internalCellCls]: column.internalCellCls
          }).assign(column.autoCls),
          keepChildren: true,
          elementData: {
            range
          },
          dataset: {
            column: column.field,
            columnId: column.id
          },
          style: {
            height: this.client.rowManager.rowHeight
          }
        }
      ]
    };
    (_column$mergedRendere = column.mergedRenderer) === null || _column$mergedRendere === void 0 ? void 0 : _column$mergedRendere.call(column, {
      domConfig,
      value: column.getRawValue(record),
      record,
      column,
      fromIndex,
      toIndex
    });
    return domConfig;
  }
  buildMergedCellsConfig(fromIndex, toIndex, rows) {
    var _fromIndex, _rowManager$topRow, _toIndex, _rowManager$bottomRow;
    const me = this, {
      client
    } = me, {
      rowManager
    } = client;
    fromIndex = (_fromIndex = fromIndex) !== null && _fromIndex !== void 0 ? _fromIndex : (_rowManager$topRow = rowManager.topRow) === null || _rowManager$topRow === void 0 ? void 0 : _rowManager$topRow.dataIndex;
    toIndex = (_toIndex = toIndex) !== null && _toIndex !== void 0 ? _toIndex : (_rowManager$bottomRow = rowManager.bottomRow) === null || _rowManager$bottomRow === void 0 ? void 0 : _rowManager$bottomRow.dataIndex;
    const domConfigMap = client.regions.reduce((map, region) => {
      map[region] = {
        className: {
          "b-grid-merged-cells-container": 1
        },
        children: []
      };
      return map;
    }, {});
    for (const range of me.mergedRanges) {
      if (range.use && range.fromIndex <= toIndex && range.toIndex >= fromIndex) {
        me.updateRange(range, me.heightChanged, rows);
        domConfigMap[range.column.region].children.push(me.createRangeDomConfig(range));
      }
    }
    return domConfigMap;
  }
  syncDom(force = false) {
    const me = this, {
      client
    } = me, {
      rowManager
    } = client;
    if (!force && !rowManager.topRow || me.disabled && !me.isDisabling) {
      return;
    }
    const domConfigMap = this.buildMergedCellsConfig();
    client.eachSubGrid((subGrid) => {
      DomSync.sync({
        targetElement: subGrid.$mergedCellsElement,
        syncIdField: "syncId",
        domConfig: domConfigMap[subGrid.region]
      });
    });
    me.heightChanged = false;
  }
  onRenderDone() {
    this.syncDom();
  }
  removeRange(range) {
    ArrayHelper.remove(this.mergedRanges, range);
    for (let index = range.fromIndex; index <= range.toIndex; index++) {
      delete this.mergedMap[`${index}-@-${range.column.id}`];
    }
  }
  reset(redraw = true) {
    const me = this, columns = me.client.columns.visibleColumns.filter((c) => c.mergeCells && c.isSorted, true), hadRanges = me.mergedRanges.length;
    me.mergedRanges = [];
    me.mergedMap = {};
    if (redraw && !me.client.refreshSuspended) {
      for (const row of me.client.rowManager.rows) {
        for (const column of columns) {
          row.renderCell(row.getCell(column.id));
        }
      }
      me.syncDom(hadRanges && !me.client.rowManager.rowCount);
    }
  }
  refreshBounds() {
    const {
      mergedRanges
    } = this, boundsMap = /* @__PURE__ */ new Map();
    for (const range of mergedRanges.slice()) {
      const {
        column
      } = range, {
        element
      } = column;
      if (element) {
        let bounds = boundsMap.get(column);
        if (!bounds) {
          boundsMap.set(column, bounds = Rectangle.from(element, element.parentElement));
        }
        range.left = bounds.left;
        range.width = bounds.width;
      } else {
        this.removeRange(range);
      }
    }
    this.syncDom();
  }
  updateRange(range, force, rows = null) {
    const {
      store,
      rowManager
    } = this.client, {
      topRendered,
      bottomRendered
    } = range, {
      rowOffsetHeight
    } = rowManager;
    let {
      fromIndex,
      toIndex
    } = range, topRow, bottomRow;
    force = rows ? rows.length > 0 : force;
    if (!force && topRendered && bottomRendered) {
      return;
    }
    if (!topRendered || force) {
      if (rows) {
        const index = rows.findIndex((row) => row.dataIndex >= fromIndex);
        topRow = rows[index];
        fromIndex = topRow.dataIndex;
      } else {
        do {
          topRow = rowManager.getRowById(store.getAt(fromIndex));
        } while (!topRow && fromIndex++ < toIndex);
      }
      range.topRendered = fromIndex === range.fromIndex;
      const rowsAbove = fromIndex - range.fromIndex;
      range.top = topRow.top - rowsAbove * (rows ? topRow.offsetHeight : rowOffsetHeight);
    }
    if (!bottomRendered || force) {
      if (rows) {
        const index = rows.findIndex((row) => row.dataIndex === toIndex);
        bottomRow = rows[index === -1 ? rows.length - 1 : index];
        fromIndex = bottomRow.dataIndex;
      } else {
        do {
          bottomRow = rowManager.getRowById(store.getAt(toIndex));
        } while (!bottomRow && toIndex-- > fromIndex);
      }
      range.bottomRendered = toIndex === range.toIndex;
      const rowsBelow = range.toIndex - toIndex;
      range.bottom = bottomRow.bottom + rowsBelow * (rows ? bottomRow.offsetHeight : rowOffsetHeight);
    }
    range.height = range.bottom - range.top;
  }
  getMergeRange(record, column) {
    if (record.isSpecialRow) {
      return;
    }
    const me = this, {
      mergedMap
    } = me, {
      store
    } = me.client, columnId = column.id, index = store.indexOf(record), key = `${index}-@-${columnId}`;
    let range = mergedMap[key];
    if (!range) {
      const value = column.getRawValue(record);
      range = mergedMap[key] = {
        column
      };
      me.mergedRanges.push(range);
      let earlierRecord, earlierValue, earlierIndex = index;
      do {
        earlierRecord = store.getAt(--earlierIndex);
        earlierValue = earlierRecord && column.getRawValue(earlierRecord);
        if (earlierValue === value) {
          mergedMap[`${earlierIndex}-@-${columnId}`] = range;
        }
      } while (earlierRecord && earlierValue === value);
      let laterRecord, laterValue, laterIndex = index;
      do {
        laterRecord = store.getAt(++laterIndex);
        laterValue = laterRecord && column.getRawValue(laterRecord);
        if (laterValue === value) {
          mergedMap[`${laterIndex}-@-${columnId}`] = range;
        }
      } while (laterRecord && laterValue === value);
      range.fromIndex = earlierIndex + 1;
      range.toIndex = laterIndex - 1;
      if (range.toIndex - range.fromIndex > 0) {
        const headerBounds = Rectangle.from(column.element, column.element.parentElement);
        range.left = headerBounds.left;
        range.width = headerBounds.width;
        range.use = true;
      }
    }
    if (!range.element && range.use) {
      me.createRangeElement(range);
    }
    return range;
  }
};
_defineProperty(MergeCells, "$name", "MergeCells");
_defineProperty(MergeCells, "configurable", {
  passthrough: true
});
MergeCells._$name = "MergeCells";
GridFeatureManager.registerFeature(MergeCells);
var QuickFind = class extends InstancePlugin {
  static get $name() {
    return "QuickFind";
  }
  static get pluginConfig() {
    return {
      chain: ["onElementKeyPress", "onCellNavigate"]
    };
  }
  static get properties() {
    return {
      hitCls: "b-quick-hit",
      hitCellCls: "b-quick-hit-cell",
      hitCellBadgeCls: "b-quick-hit-cell-badge",
      hitTextCls: "b-quick-hit-text"
    };
  }
  construct(grid, config) {
    super.construct(grid, config);
    Object.assign(this, {
      grid,
      treeWalker: grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)
    });
  }
  isActionAvailable() {
    const {
      focusedCell
    } = this.grid;
    return !this.disabled && (focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.record) && !focusedCell.isActionable && this.find.length > 0;
  }
  doDisable(disable) {
    if (disable) {
      this.clear();
    }
    super.doDisable(disable);
  }
  get store() {
    return this.grid.store;
  }
  showQuickFind() {
    const me = this, header = me.grid.getHeaderElement(me.columnId);
    if (header) {
      if (!me.headerField) {
        const [element, field, badge] = DomHelper.createElement({
          tag: "div",
          className: "b-quick-hit-header",
          children: [{
            tag: "div",
            className: "b-quick-hit-field"
          }, {
            tag: "div",
            className: "b-quick-hit-badge"
          }]
        }, {
          returnAll: true
        });
        if (me.mode === "header") {
          header.appendChild(element);
        } else {
          element.className += " b-quick-hit-mode-grid";
          me.grid.element.appendChild(element);
        }
        me.headerField = {
          header: element,
          field,
          badge,
          colHeader: header
        };
      }
      me.headerField.field.innerHTML = me.find;
      me.headerField.badge.innerHTML = me.found.length;
      header.classList.add("b-quick-find-header");
      if (!me.renderListenerInitialized) {
        me.grid.rowManager.ion({
          rendercell: me.renderCell,
          thisObj: me
        });
        me.renderListenerInitialized = true;
      }
    }
  }
  hideQuickFind() {
    const me = this, {
      grid,
      headerField
    } = me;
    for (const hit of me.prevFound || me.found) {
      const row = grid.getRowById(hit.id);
      if (row) {
        row.forceInnerHTML = true;
        const cellElement = row.getCell(me.columnId);
        cellElement._content = null;
        row.renderCell(cellElement);
        row.forceInnerHTML = false;
      }
    }
    if (headerField) {
      headerField.header.parentNode.removeChild(headerField.header);
      headerField.colHeader.classList.remove("b-quick-find-header");
      me.headerField = null;
    }
    if (me.renderListenerInitialized) {
      grid.rowManager.un({
        rendercell: me.renderCell
      }, me);
      me.renderListenerInitialized = false;
    }
    grid.trigger("hideQuickFind");
  }
  search(find, columnFieldOrId = this.columnId) {
    const me = this, {
      grid
    } = me, column = grid.columns.getById(columnFieldOrId) || grid.columns.get(columnFieldOrId), found = me.store.findByField(column.field, find, column.mergeCells && column.isSorted);
    let i = 1;
    Object.assign(me, {
      foundMap: {},
      prevFound: me.found,
      found,
      find,
      columnId: column.id,
      findRe: new RegExp(`(\\s+)?(${StringHelper.escapeRegExp(String(find))})(\\s+)?`, "ig")
    });
    if (find) {
      me.showQuickFind();
    } else {
      me.hideQuickFind();
    }
    for (const cellElement of DomHelper.children(grid.element, `.${me.hitCls}`)) {
      cellElement.classList.remove(me.hitCls, me.hitCellCls);
      if (cellElement._originalContent) {
        cellElement.innerHTML = cellElement._originalContent;
        cellElement._originalContent = null;
      }
    }
    if (!found) {
      return;
    }
    if (found.length > 0) {
      me.gotoClosestHit(grid.focusedCell, found);
    }
    for (const hit of found) {
      me.foundMap[hit.id] = i++;
      const row = grid.getRowById(hit.data.id);
      row === null || row === void 0 ? void 0 : row.renderCell(row.getCell(column.id));
      if (i > 1e3) {
        break;
      }
    }
    grid.trigger("quickFind", {
      find,
      found
    });
  }
  clear() {
    var _this$found;
    if (this.find || (_this$found = this.found) !== null && _this$found !== void 0 && _this$found.length) {
      this.search("");
    }
  }
  get foundCount() {
    var _this$found$length, _this$found2;
    return (_this$found$length = (_this$found2 = this.found) === null || _this$found2 === void 0 ? void 0 : _this$found2.length) !== null && _this$found$length !== void 0 ? _this$found$length : 0;
  }
  gotoHit(index) {
    const nextHit = this.found[index];
    if (nextHit) {
      this.grid.focusCell({
        columnId: this.columnId,
        id: nextHit.id
      }, {
        doSelect: true
      });
    }
    return !!nextHit;
  }
  gotoClosestHit(focusedCell, found) {
    const focusedIndex = focusedCell ? this.grid.store.indexOf(focusedCell.id) : 0, foundSorted = found.slice().sort((a, b) => Math.abs(a.index - focusedIndex) - Math.abs(b.index - focusedIndex));
    this.gotoHit(found.indexOf(foundSorted[0]));
  }
  gotoFirstHit() {
    this.gotoHit(0);
  }
  gotoLastHit() {
    this.gotoHit(this.found.length - 1);
  }
  gotoNextHit() {
    var _grid$_focusedCell$id, _grid$_focusedCell, _grid$lastFocusedCell;
    const me = this, {
      grid
    } = me, currentId = (_grid$_focusedCell$id = (_grid$_focusedCell = grid._focusedCell) === null || _grid$_focusedCell === void 0 ? void 0 : _grid$_focusedCell.id) !== null && _grid$_focusedCell$id !== void 0 ? _grid$_focusedCell$id : (_grid$lastFocusedCell = grid.lastFocusedCell) === null || _grid$lastFocusedCell === void 0 ? void 0 : _grid$lastFocusedCell.id, currentIndex = grid.store.indexOf(currentId) || 0, nextHit = me.found.find((hit) => hit.index > currentIndex);
    if (nextHit) {
      grid.focusCell({
        columnId: me.columnId,
        id: nextHit.id
      }, {
        doSelect: true
      });
    } else {
      me.gotoFirstHit();
    }
  }
  gotoPrevHit() {
    var _grid$_focusedCell$id2, _grid$_focusedCell2, _grid$lastFocusedCell2;
    const me = this, {
      grid,
      found
    } = me, currentId = (_grid$_focusedCell$id2 = (_grid$_focusedCell2 = grid._focusedCell) === null || _grid$_focusedCell2 === void 0 ? void 0 : _grid$_focusedCell2.id) !== null && _grid$_focusedCell$id2 !== void 0 ? _grid$_focusedCell$id2 : (_grid$lastFocusedCell2 = grid.lastFocusedCell) === null || _grid$lastFocusedCell2 === void 0 ? void 0 : _grid$lastFocusedCell2.id, currentIndex = grid.store.indexOf(currentId) || 0;
    let prevHit;
    if (!found.length) {
      return;
    }
    for (let i = found.length - 1; i--; i >= 0) {
      if (found[i].index < currentIndex) {
        prevHit = found[i];
        break;
      }
    }
    if (prevHit) {
      grid.focusCell({
        columnId: me.columnId,
        id: prevHit.id
      }, {
        doSelect: true
      });
    } else {
      me.gotoLastHit();
    }
  }
  renderCell({
    cellElement,
    column,
    record
  }) {
    var _me$foundMap;
    const me = this, {
      classList
    } = cellElement, {
      treeWalker,
      findRe,
      hitTextCls
    } = me, hitIndex = me.columnId === column.id && ((_me$foundMap = me.foundMap) === null || _me$foundMap === void 0 ? void 0 : _me$foundMap[record.id]);
    if (hitIndex) {
      classList.add(me.hitCls);
      cellElement.isQuickHit = true;
      cellElement._originalContent = cellElement.innerHTML;
      const inner = treeWalker.currentNode = DomHelper.down(cellElement, ".b-grid-cell-value,.b-tree-cell-value") || cellElement;
      for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode); ) {
        const nodeToReplace = textNode, textContent = textNode.nodeValue, newText = ["<span>"];
        textNode = treeWalker.nextNode();
        let offset = findRe.lastIndex;
        for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {
          const preamble = textContent.substring(offset, match.index), spaceBefore = match[1] ? "\xA0" : "", v = match[2], spaceAfter = match[3] ? "\xA0" : "";
          newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class="${hitTextCls}">${v}</span>${spaceAfter}`);
          offset = findRe.lastIndex;
        }
        newText.push(StringHelper.encodeHtml(textContent.substring(offset)), "</span>");
        nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(""), {
          fragment: true
        }), nodeToReplace);
        nodeToReplace.remove();
      }
      DomHelper.createElement({
        parent: cellElement,
        className: me.hitCellBadgeCls,
        text: hitIndex
      });
    }
  }
  onBackspace(event) {
    const me = this;
    if (me.find) {
      me.find = me.find.substr(0, me.find.length - 1);
      me.search(me.find);
      return true;
    }
    return false;
  }
  clearSearch() {
    if (this.find) {
      this.find = "";
      this.search(this.find);
      return true;
    }
    return false;
  }
  showFilterEditor() {
    const me = this, {
      filter
    } = me.client.features;
    if (filter && me.columnId && me.foundCount) {
      me.clear();
      filter.showFilterEditor(me.client.columns.getById(me.columnId), me.find);
    }
  }
  onElementKeyPress(event) {
    var _event$key;
    const me = this, {
      grid
    } = me, {
      focusedCell
    } = grid;
    if (!event.handled && !me.disabled && focusedCell !== null && focusedCell !== void 0 && focusedCell.record && !focusedCell.isActionable && ((_event$key = event.key) === null || _event$key === void 0 ? void 0 : _event$key.length) === 1) {
      const column = grid.columns.getById(grid._focusedCell.columnId);
      if (column && column.searchable !== false) {
        me.columnId = grid._focusedCell.columnId;
        me.find += event.key;
        me.search(me.find);
      }
    }
  }
  onCellNavigate(grid, fromCellSelector, toCellSelector) {
    const me = this;
    if (me.find && (!toCellSelector || toCellSelector.columnId !== me.columnId)) {
      me.clear();
    }
  }
};
_defineProperty(QuickFind, "configurable", {
  mode: "header",
  find: "",
  keyMap: {
    F3: "gotoNextHit",
    "Shift+F3": "gotoPrevHit",
    "Ctrl+g": "gotoNextHit",
    "Ctrl+Shift+g": "gotoPrevHit",
    "Ctrl+Shift+f": "showFilterEditor",
    Escape: "clearSearch",
    Backspace: "onBackspace"
  }
});
QuickFind._$name = "QuickFind";
GridFeatureManager.registerFeature(QuickFind);
var RegionResize = class extends InstancePlugin {
  static get pluginConfig() {
    return {
      chain: ["onElementPointerDown", "onElementDblClick", "onElementTouchMove", "onSubGridCollapse", "onSubGridExpand", "render"]
    };
  }
  onElementDblClick(event) {
    const me = this, {
      client
    } = me, splitterEl = event.target.closest(".b-grid-splitter-collapsed");
    if (splitterEl && !me.expanding) {
      me.expanding = true;
      let region = splitterEl.dataset.region, subGrid = client.getSubGrid(region);
      if (!subGrid.collapsed) {
        region = client.getLastRegions()[1];
        subGrid = client.getSubGrid(region);
      }
      subGrid.expand().then(() => me.expanding = false);
    }
  }
  startMove(splitterElement, clientX) {
    const me = this, {
      client
    } = me, region = splitterElement.dataset.region, gridEl = client.element, nextRegion = client.regions[client.regions.indexOf(region) + 1], nextSubGrid = client.getSubGrid(nextRegion), splitterSubGrid = client.getSubGrid(region);
    let subGrid = splitterSubGrid, flip = 1;
    if (subGrid.flex != null) {
      if (nextSubGrid.flex == null) {
        subGrid = nextSubGrid;
        flip = -1;
      }
    }
    if (client.rtl) {
      flip *= -1;
    }
    if (splitterElement.classList.contains("b-grid-splitter-collapsed")) {
      return;
    }
    const availableWidth = subGrid.element.offsetWidth + nextSubGrid.element.offsetWidth;
    me.dragContext = {
      element: splitterElement,
      headerEl: subGrid.header.element,
      subGridEl: subGrid.element,
      subGrid,
      splitterSubGrid,
      originalWidth: subGrid.element.offsetWidth,
      originalX: clientX,
      minWidth: subGrid.minWidth || 0,
      maxWidth: Math.min(availableWidth, subGrid.maxWidth || availableWidth),
      flip
    };
    gridEl.classList.add("b-moving-splitter");
    splitterSubGrid.toggleSplitterCls("b-moving");
    me.pointerDetacher = EventHelper.on({
      element: document,
      pointermove: "onPointerMove",
      pointerup: "onPointerUp",
      thisObj: me
    });
  }
  endMove() {
    const me = this, {
      dragContext
    } = me;
    if (dragContext) {
      me.pointerDetacher();
      me.client.element.classList.remove("b-moving-splitter");
      dragContext.splitterSubGrid.toggleSplitterCls("b-moving", false);
      me.dragContext = null;
    }
  }
  onCollapseClick(subGrid, splitterEl) {
    const me = this, {
      client
    } = me, region = splitterEl.dataset.region, regions = client.getLastRegions();
    if (regions[0] === region) {
      const lastSubGrid = client.getSubGrid(regions[1]);
      if (lastSubGrid.collapsed) {
        lastSubGrid.expand();
        return;
      }
    }
    subGrid.collapse();
  }
  onExpandClick(subGrid, splitterEl) {
    const me = this, {
      client
    } = me, region = splitterEl.dataset.region, regions = client.getLastRegions();
    if (regions[0] === region) {
      if (!subGrid.collapsed) {
        const lastSubGrid = client.getSubGrid(regions[1]);
        lastSubGrid.collapse();
        return;
      }
    }
    subGrid.expand();
  }
  updateMove(newClientX) {
    const {
      dragContext
    } = this;
    if (dragContext) {
      const difX = newClientX - dragContext.originalX, newWidth = Math.max(Math.min(dragContext.maxWidth, dragContext.originalWidth + difX * dragContext.flip), 0);
      dragContext.subGrid.width = Math.max(newWidth, dragContext.minWidth);
    }
  }
  onElementPointerDown(event) {
    const me = this, {
      target
    } = event, splitter = event.button === 0 && target.closest(":not(.b-row-reordering):not(.b-dragging-event):not(.b-dragging-task):not(.b-dragging-header):not(.b-dragselecting) .b-grid-splitter"), subGrid = splitter && me.client.getSubGrid(splitter.dataset.region);
    let toggle;
    if (splitter) {
      if (target.closest(".b-grid-splitter-button-collapse")) {
        me.onCollapseClick(subGrid, splitter);
      } else if (target.closest(".b-grid-splitter-button-expand")) {
        me.onExpandClick(subGrid, splitter);
      } else {
        me.startMove(splitter, event.clientX);
        toggle = splitter;
      }
    }
    if (event.pointerType === "touch") {
      me.toggleTouchSplitter(toggle);
    }
  }
  onPointerMove(event) {
    if (this.dragContext) {
      this.updateMove(event.clientX);
      event.preventDefault();
    }
  }
  onElementTouchMove(event) {
    if (this.dragContext) {
      event.preventDefault();
    }
  }
  onPointerUp(event) {
    if (this.dragContext) {
      this.endMove();
      event.preventDefault();
    }
  }
  onSubGridCollapse({
    subGrid
  }) {
    const splitterEl = this.client.resolveSplitter(subGrid), regions = this.client.getLastRegions();
    if (regions[1] === subGrid.region) {
      splitterEl.classList.add("b-grid-splitter-allow-collapse");
    }
  }
  onSubGridExpand({
    subGrid
  }) {
    const splitterEl = this.client.resolveSplitter(subGrid);
    splitterEl.classList.remove("b-grid-splitter-allow-collapse");
  }
  toggleTouchSplitter(splitterElement) {
    const me = this, {
      touchedSplitter
    } = me;
    if (splitterElement && touchedSplitter && splitterElement.dataset.region !== touchedSplitter.dataset.region) {
      me.toggleTouchSplitter();
    }
    const splitterSubGrid = me.client.getSubGrid(splitterElement ? splitterElement.dataset.region : touchedSplitter === null || touchedSplitter === void 0 ? void 0 : touchedSplitter.dataset.region);
    if (splitterSubGrid) {
      splitterSubGrid.toggleSplitterCls("b-touching", Boolean(splitterElement));
      if (splitterElement) {
        splitterSubGrid.startSplitterButtonSyncing();
      } else {
        splitterSubGrid.stopSplitterButtonSyncing();
      }
    }
    me.touchedSplitter = splitterElement;
  }
  render() {
    const {
      regions,
      subGrids
    } = this.client;
    if (regions.length > 2) {
      subGrids[regions[0]].splitterElement.classList.add("b-left-only");
      subGrids[regions[1]].splitterElement.classList.add("b-right-only");
    }
  }
};
_defineProperty(RegionResize, "$name", "RegionResize");
RegionResize.featureClass = "b-split";
RegionResize._$name = "RegionResize";
GridFeatureManager.registerFeature(RegionResize);
var RowCopyPaste = class extends InstancePlugin {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "entityName", "row");
  }
  construct(grid, config) {
    super.construct(grid, config);
    grid.rowManager.ion({
      beforeRenderRow: "onBeforeRenderRow",
      thisObj: this
    });
    this.grid = grid;
  }
  onBeforeRenderRow({
    row,
    record
  }) {
    row.cls["b-cut-row"] = this._isCut && this.clipboardRecords.includes(record);
  }
  isActionAvailable(key, action, event) {
    var _grid$selectedRecords;
    const {
      grid
    } = this, {
      cellEdit
    } = grid.features, {
      target
    } = event;
    return !this.disabled && globalThis.getSelection().toString().length === 0 && (!cellEdit || !cellEdit.isEditing) && ((_grid$selectedRecords = grid.selectedRecords) === null || _grid$selectedRecords === void 0 ? void 0 : _grid$selectedRecords.length) > 0 && (!target || Boolean(target.closest(".b-gridbase:not(.b-schedulerbase) .b-grid-subgrid,.b-grid-subgrid:not(.b-timeaxissubgrid)")));
  }
  copy() {
    this.copyRows();
  }
  cut() {
    this.copyRows(true);
  }
  paste(referenceRecord) {
    this.pasteRows(referenceRecord !== null && referenceRecord !== void 0 && referenceRecord.isModel ? referenceRecord : null);
  }
  copyRows(isCut = false) {
    const me = this, {
      client,
      entityName
    } = me, records = me.selectedRecords.filter((r) => !r.readOnly || !isCut);
    if (!records.length || client.readOnly || client.trigger("beforeCopy", {
      records,
      isCut,
      entityName
    }) === false) {
      return;
    }
    me._isCut = isCut;
    me.clipboardRecords.forEach((rec) => {
      var _client$rowManager$ge;
      return (_client$rowManager$ge = client.rowManager.getRowById(rec)) === null || _client$rowManager$ge === void 0 ? void 0 : _client$rowManager$ge.removeCls("b-cut-row");
    });
    me.clipboardRecords = records.slice();
    client.store.forEach((rec) => {
      rec.meta.isCut = me._isCut && me.clipboardRecords.includes(rec);
    });
    records.forEach((record) => this.onRowCutOrCopy(record, isCut));
    client.trigger("copy", {
      records,
      isCut,
      entityName
    });
  }
  onRowCutOrCopy(record, isCut) {
    var _this$client$rowManag;
    (_this$client$rowManag = this.client.rowManager.getRowById(record)) === null || _this$client$rowManag === void 0 ? void 0 : _this$client$rowManag.toggleCls("b-cut-row", isCut);
  }
  pasteRows(record) {
    var _client$getRowFor, _client$getRowFor$cel;
    const me = this, records = me.clipboardRecords, {
      client,
      entityName
    } = me, {
      store
    } = client, referenceRecord = record || client.selectedRecord;
    if (client.readOnly || client.isTreeGrouped || !records.length || store.tree && me._isCut && records.some((rec) => rec.contains(referenceRecord, true)) || client.trigger("beforePaste", {
      records,
      referenceRecord,
      isCut: me._isCut,
      entityName
    }) === false) {
      return [];
    }
    me.sortByIndex(records);
    const idMap = {}, recordsToProcess = me.extractParents(records, idMap);
    me.insertCopiedRecords(recordsToProcess, referenceRecord);
    if (me._isCut) {
      me.clearClipboard();
    } else {
      client.selectedRecords = recordsToProcess;
    }
    client.trigger("paste", {
      records: recordsToProcess,
      originalRecords: records,
      isCut: me._isCut,
      referenceRecord,
      entityName
    });
    (_client$getRowFor = client.getRowFor(recordsToProcess[recordsToProcess.length - 1])) === null || _client$getRowFor === void 0 ? void 0 : (_client$getRowFor$cel = _client$getRowFor.cells) === null || _client$getRowFor$cel === void 0 ? void 0 : _client$getRowFor$cel[0].focus();
    return recordsToProcess;
  }
  clearClipboard() {
    if (this._isCut) {
      this.clipboardRecords.forEach((rec) => {
        var _this$client$rowManag2;
        return (_this$client$rowManag2 = this.client.rowManager.getRowById(rec)) === null || _this$client$rowManag2 === void 0 ? void 0 : _this$client$rowManag2.removeCls("b-cut-row");
      });
    }
    this._isCut = false;
    this.clipboardRecords = [];
  }
  generateNewName(record) {
    const originalName = record[this.nameField];
    let counter = 2;
    while (this.client.store.findRecord(this.nameField, `${originalName} - ${counter}`)) {
      counter++;
    }
    return `${originalName} - ${counter}`;
  }
  insertCopiedRecords(toInsert, recordReference) {
    const {
      store
    } = this.client, insertAt = store.indexOf(recordReference) + 1;
    if (store.tree) {
      return recordReference.parent.insertChild(toInsert, recordReference.nextSibling, false, {
        orderedBeforeNode: recordReference.nextOrderedSibling
      });
    } else if (this._isCut) {
      store.move(toInsert, store.getAt(insertAt));
    } else {
      return store.insert(insertAt, toInsert);
    }
  }
  get selectedRecords() {
    const records = [...this.client.selectedRecords];
    this.client.selectedCells.forEach((cell) => {
      if (!records.includes(cell.record)) {
        records.push(cell.record);
      }
    });
    return records;
  }
  getMenuItemText(action) {
    var _me$client$features$c;
    const me = this;
    let text = me[action + "RecordText"];
    if (((_me$client$features$c = me.client.features.cellCopyPaste) === null || _me$client$features$c === void 0 ? void 0 : _me$client$features$c.enabled) === true && me.client.selectedCells.length) {
      text += ` (${me.selectedRecords.length > 1 ? me.rowSpecifierTextPlural : me.rowSpecifierText})`;
    }
    return text;
  }
  populateCellMenu({
    record,
    items: items2
  }) {
    const me = this, {
      client
    } = me;
    if (!client.readOnly && !client.isTreeGrouped && (record === null || record === void 0 ? void 0 : record.isSpecialRow) === false && me.selectedRecords.length) {
      items2.cut = {
        text: me.getMenuItemText("cut"),
        localeClass: me,
        icon: "b-icon b-icon-cut",
        weight: 135,
        disabled: record.readOnly,
        onItem: () => me.cut()
      };
      items2.copy = {
        text: me.getMenuItemText("copy"),
        localeClass: me,
        cls: "b-separator",
        icon: "b-icon b-icon-copy",
        weight: 120,
        onItem: () => me.copy()
      };
      items2.paste = {
        text: me.getMenuItemText("paste"),
        localeClass: me,
        icon: "b-icon b-icon-paste",
        weight: 140,
        disabled: !me.clipboardRecords.length,
        onItem: () => me.paste(record)
      };
    }
  }
  sortByIndex(array) {
    const {
      store
    } = this.client;
    return array.sort((rec1, rec2) => {
      const idx1 = rec1.indexPath, idx2 = rec2.indexPath;
      if (!array.includes(rec1.parent) && !array.includes(rec2.parent)) {
        return store.indexOf(rec1) - store.indexOf(rec2);
      }
      if (idx1.length === idx2.length) {
        for (let i = 0; i < idx1.length; i++) {
          if (idx1[i] < idx2[i]) {
            return -1;
          }
          if (idx1[i] > idx2[i]) {
            return 1;
          }
        }
        return 0;
      } else {
        return idx1.length - idx2.length;
      }
    });
  }
  extractParents(taskRecords, idMap) {
    const me = this, {
      client,
      _isCut: isCut
    } = me;
    if (client.store.tree) {
      taskRecords.forEach((node) => {
        node.traverse((n) => {
          const parents = n.getTopParent(true);
          if (!taskRecords.includes(n) && (!isCut || !taskRecords.some((rec) => parents.includes(rec)))) {
            taskRecords.push(n);
          }
        });
      });
    }
    const result = taskRecords.reduce((parents, node) => {
      let copy;
      const parentId = node.parentId || node.meta.modified;
      if (isCut) {
        copy = node;
        copy.meta.isCut = false;
      } else {
        copy = node.copy();
        copy[me.nameField] = me.generateNewName(copy);
        if (node.expanded) {
          copy.data.expanded = node.expanded;
        }
      }
      idMap[node.id] = copy;
      if (node.parent === client.store.rootNode) {
        parents.push(copy);
      } else if (parentId in idMap) {
        idMap[parentId].appendChild(copy);
      } else {
        parents.push(copy);
      }
      return parents;
    }, []);
    result.forEach((parent) => {
      parent.sortOrderedChildren(true, true);
    });
    return result;
  }
};
_defineProperty(RowCopyPaste, "$name", "RowCopyPaste");
_defineProperty(RowCopyPaste, "type", "rowCopyPaste");
_defineProperty(RowCopyPaste, "pluginConfig", {
  assign: ["copyRows", "pasteRows"],
  chain: ["populateCellMenu"]
});
_defineProperty(RowCopyPaste, "properties", {
  clipboardRecords: []
});
_defineProperty(RowCopyPaste, "configurable", {
  nameField: "name",
  keyMap: {
    "Ctrl+C": "copy",
    "Ctrl+X": "cut",
    "Ctrl+V": "paste"
  },
  copyRecordText: "L{copyRecord}",
  cutRecordText: "L{cutRecord}",
  pasteRecordText: "L{pasteRecord}",
  rowSpecifierText: "L{row}",
  rowSpecifierTextPlural: "L{rows}",
  localizableProperties: ["copyRecordText", "cutRecordText", "pasteRecordText", "rowSpecifierText", "rowSpecifierTextPlural"]
});
RowCopyPaste.featureClass = "b-row-copypaste";
RowCopyPaste._$name = "RowCopyPaste";
GridFeatureManager.registerFeature(RowCopyPaste, true, "Grid");
GridFeatureManager.registerFeature(RowCopyPaste, false, "Gantt");
GridFeatureManager.registerFeature(RowCopyPaste, false, "SchedulerPro");
GridFeatureManager.registerFeature(RowCopyPaste, false, "ResourceHistogram");
var storeRemoveActions = {
  remove: 1,
  filter: 1,
  dataset: 1,
  replace: 1
};
var RowExpander = class extends InstancePlugin {
  static get properties() {
    return {
      expanderBodyClass: "b-rowexpander-body",
      expandedRowClass: "b-rowexpander-row-expanded",
      recordStateMap: /* @__PURE__ */ new Map(),
      collapsingRecords: /* @__PURE__ */ new Set()
    };
  }
  static get pluginConfig() {
    return {
      chain: ["afterColumnsChange", "beforeRenderRow", "processRowHeight", "bindStore"],
      override: ["onGridBodyFocusIn"]
    };
  }
  afterConstruct() {
    const me = this, {
      client
    } = me;
    if (!me.renderer) {
      console.warn("RowExpander requires implementing the renderer function.");
      return;
    }
    if (client.isGanttBase && client.fixedRowHeight !== false) {
      console.warn("When using RowExpander on a Gantt, the Gantt`s fixedRowHeight config must be set to false.");
    }
    me.bindStore(client.store);
    if (me.triggerEvent) {
      client.ion({
        [me.triggerEvent]: "onTriggerEvent",
        thisObj: me
      });
    }
    me.addColumn();
  }
  bindStore(store) {
    const me = this;
    me.recordStateMap.clear();
    me.collapsingRecords.clear();
    me.detachListeners("clientStoreChange");
    store.ion({
      name: "clientStoreChange",
      change: me.onStoreChange,
      thisObj: me
    });
  }
  doDisable(disable) {
    const {
      client
    } = this;
    if (disable) {
      this.recordStateMap.clear();
      this.collapsingRecords.clear();
    }
    if (!client.isConfiguring) {
      client.rowManager.renderFromRow();
    }
    super.doDisable(disable);
  }
  changeLoadingIndicatorText(text) {
    return text ? this.L(text) : text;
  }
  onGridBodyFocusIn(event) {
    var _this$client$lastMous, _this$client$lastMous2;
    if (!((_this$client$lastMous = this.client.lastMousedownEvent) !== null && _this$client$lastMous !== void 0 && (_this$client$lastMous2 = _this$client$lastMous.target) !== null && _this$client$lastMous2 !== void 0 && _this$client$lastMous2.closest(".b-rowexpander-body"))) {
      this.overridden.onGridBodyFocusIn(event);
    }
  }
  get isAnimating() {
    return this.client.isAnimating;
  }
  set isAnimating(value) {
    const {
      client
    } = this, wasAnimating = client.isAnimating;
    client.isAnimating = value;
    if (client.isAnimating !== wasAnimating) {
      client.element.classList.toggle("b-rowexpander-animating");
    }
  }
  afterColumnsChange() {
    this.addColumn();
  }
  changeColumn(config) {
    if (config == null) {
      return config;
    }
    return _objectSpread2(_objectSpread2({
      type: "action",
      actions: [{
        cls: "b-icon b-icon-collapse-down",
        tooltip: ({
          record
        }) => this.L(this.recordStateMap.has(record) ? "L{RowExpander.collapse}" : "L{RowExpander.expand}"),
        onClick: ({
          record
        }) => this.toggleExpand(record)
      }],
      width: 40,
      hideable: false,
      align: "center",
      region: this.client.regions[0]
    }, config), {}, {
      field: "expanderActionColumn"
    });
  }
  addColumn() {
    const me = this, {
      column
    } = me, {
      columns
    } = me.client;
    if (!me._isAddingExpanderColumn && column && (!me._expander || !columns.includes(me._expander))) {
      me._isAddingExpanderColumn = true;
      if (me.columnPosition === "last") {
        [me._expander] = columns.add(column);
      } else {
        [me._expander] = columns.insert(0, column);
      }
      me._isAddingExpanderColumn = false;
    }
  }
  onTriggerEvent({
    target
  }) {
    if (this.disabled || target !== null && target !== void 0 && target.closest(".b-action-cell") || !target.closest(".b-grid-cell")) {
      return;
    }
    this.toggleExpand(this.client.getRecordFromElement(target));
  }
  toggleExpand(record) {
    if (record) {
      if (this.recordStateMap.has(record)) {
        this.collapse(record);
      } else {
        this.expand(record);
      }
    }
  }
  onStoreChange({
    action,
    source,
    records
  }) {
    const me = this, {
      recordStateMap,
      collapsingRecords
    } = me;
    if (me.disabled) {
      return;
    }
    if (action === "removeAll") {
      recordStateMap.clear();
      collapsingRecords.clear();
    } else if (storeRemoveActions[action]) {
      for (const [record] of recordStateMap) {
        if (!source.includes(record)) {
          recordStateMap.delete(record);
          collapsingRecords.delete(record);
        }
      }
    } else if (me.refreshOnRecordChange && records !== null && records !== void 0 && records.length) {
      if (action === "update") {
        const recordState = recordStateMap.get(records[0]);
        if (recordState !== null && recordState !== void 0 && recordState.isCreated) {
          recordState.isCreated = false;
          me.client.rowManager.renderFromRecord(records[0]);
        }
      } else if (action === "updatemultiple") {
        let topRecordIndex, topRecord;
        for (const rec of records) {
          const recordState = recordStateMap.get(rec);
          if (recordState !== null && recordState !== void 0 && recordState.isCreated) {
            recordState.isCreated = false;
            const index = source.records.indexOf(rec);
            if (!topRecord || topRecordIndex > index) {
              topRecordIndex = index;
              topRecord = rec;
            }
          }
        }
        if (topRecord) {
          me.client.rowManager.renderFromRecord(topRecord);
        }
      }
    }
  }
  processRowHeight(record, height) {
    var _recordState$expander;
    const recordState = this.recordStateMap.get(record);
    if (recordState) {
      if (!recordState.isCreated && recordState.isRenderingAsync) {
        return this.loadingIndicatorHeight + height;
      }
      if (!recordState.expanderBodyHeight) {
        for (const region of this.client.regions) {
          const height2 = recordState.expandElements[region].offsetHeight;
          if (height2 > recordState.expanderBodyHeight) {
            recordState.expanderBodyHeight = height2;
          }
        }
      }
    }
    return ((_recordState$expander = recordState === null || recordState === void 0 ? void 0 : recordState.expanderBodyHeight) !== null && _recordState$expander !== void 0 ? _recordState$expander : 0) + height;
  }
  beforeRenderRow({
    row,
    record
  }) {
    const me = this, {
      regions
    } = me.client, {
      expandedRowClass
    } = me;
    row.cls.toggle("b-rowexpander-disabled", me.disabled);
    if (row.cls[expandedRowClass]) {
      if (me.enableAnimations && me.isAnimating && me.collapsingRecords.has(record)) {
        me.waitForTransition(row, () => {
          if (me.collapsingRecords.has(record)) {
            me.removeExpander(row);
          }
        });
      } else {
        me.removeExpander(row);
      }
    } else {
      me.collapsingRecords.delete(record);
    }
    const recordState = me.recordStateMap.get(record);
    if (!me.disabled && recordState) {
      if (!recordState.isCreated) {
        me.renderExpander(record, row, recordState);
      }
      row.cls.add(expandedRowClass);
      for (const region of regions) {
        const rowElement = row.getElement(region);
        if (recordState.isCreated) {
          rowElement.appendChild(recordState.expandElements[region]);
        } else {
          me.renderLoadingIndicator(rowElement, recordState);
        }
        me.lockCellHeight(rowElement, recordState.cellHeight, false);
      }
      if (me._shouldScrollIntoView) {
        me._shouldScrollIntoView = false;
        if (!DomHelper.isInView(recordState.expandElements[regions[0]], true)) {
          me.client.rowManager.ion({
            once: true,
            thisObj: me,
            renderDone: () => me.scrollRowIntoView(row, record)
          });
        }
      }
    }
  }
  scrollRowIntoView(row, record) {
    if (this.isAnimating) {
      this.waitForTransition(row, () => this.client.scrollRowIntoView(record));
    } else {
      this.client.scrollRowIntoView(record);
    }
  }
  waitForTransition(row, fn) {
    EventHelper.onTransitionEnd({
      element: row.element,
      property: "height",
      handler: fn,
      thisObj: this
    });
  }
  removeExpander(row) {
    row.cls.remove(this.expandedRowClass);
    for (const region of this.client.regions) {
      const rowElement = row.getElement(region);
      rowElement.classList.remove(this.expandedRowClass);
      DomHelper.removeEachSelector(rowElement, "." + this.expanderBodyClass);
      this.lockCellHeight(rowElement, null, false);
    }
  }
  renderLoadingIndicator(rowElement, recordState) {
    DomHelper.createElement({
      parent: rowElement,
      className: this.expanderBodyClass + " b-rowexpander-loading",
      style: {
        top: recordState.cellHeight,
        height: this.loadingIndicatorHeight
      },
      children: [{
        tag: "i",
        className: "b-icon b-icon-spinner"
      }, this.loadingIndicatorText]
    });
  }
  renderExpander(record, row, recordState) {
    var _row$cells$;
    const me = this, cellHeight = (_row$cells$ = row.cells[0]) === null || _row$cells$ === void 0 ? void 0 : _row$cells$.offsetHeight, expandElements = {}, renderings = [], continueRendering = (content, expanderElement, region) => {
      if (content != null) {
        if (typeof content === "string") {
          expanderElement.innerHTML = content;
        } else {
          content = DomHelper.createElement(content);
          expanderElement.appendChild(content);
        }
      }
      expandElements[region] = expanderElement;
    };
    if (recordState.isRenderingAsync) {
      return;
    }
    Object.assign(recordState, {
      cellHeight,
      expandElements,
      expanderBodyHeight: 0
    });
    for (const region of me.client.regions) {
      const rowElement = row.getElement(region);
      row.addCls(me.expandedRowClass);
      const expanderElement = DomHelper.createElement({
        parent: rowElement,
        className: me.expanderBodyClass,
        style: {
          top: cellHeight + "px"
        }
      });
      const renderResponse = me.renderer({
        record,
        expanderElement,
        rowElement,
        region
      });
      if (Objects.isPromise(renderResponse)) {
        renderings.push(renderResponse.then((content) => continueRendering(content, expanderElement, region)));
      } else {
        continueRendering(renderResponse, expanderElement, region);
      }
    }
    if (renderings.length) {
      recordState.isRenderingAsync = true;
      Promise.all(renderings).then(() => {
        var _me$renderRowsWithAni;
        recordState.isCreated = true;
        (_me$renderRowsWithAni = me.renderRowsWithAnimation) === null || _me$renderRowsWithAni === void 0 ? void 0 : _me$renderRowsWithAni.call(me, record);
        recordState.isRenderingAsync = false;
      });
    } else {
      recordState.isCreated = true;
    }
  }
  renderRowsWithAnimation(record) {
    const me = this;
    if (me.enableAnimations) {
      const row = me.client.rowManager.getRowById(record);
      if (row) {
        me.isAnimating = true;
        if (me.collapsingRecords.has(record)) {
          row.addCls("b-row-is-collapsing");
        }
        me.waitForTransition(row, () => {
          me.isAnimating = false;
          if (!row.isDestroyed) {
            var _row$removeCls;
            (_row$removeCls = row.removeCls) === null || _row$removeCls === void 0 ? void 0 : _row$removeCls.call(row, "b-row-is-collapsing");
          }
        });
      }
    }
    me.client.rowManager.renderFromRecord(record);
  }
  lockCellHeight(rowElement, cellHeight, unlock) {
    for (let a = 0; a < rowElement.children.length; a++) {
      const child = rowElement.children[a];
      if (!child.classList.contains(this.expanderBodyClass)) {
        child.style.height = unlock ? "" : cellHeight + "px";
      }
    }
  }
  async expand(record) {
    const me = this;
    if (me.disabled) {
      return;
    }
    if (await me.trigger("beforeExpand", {
      record
    }) === false) {
      return;
    }
    me.recordStateMap.set(record, {
      isCreated: false
    });
    me.collapsingRecords.delete(record);
    me._shouldScrollIntoView = true;
    me.renderRowsWithAnimation(record);
  }
  async collapse(record) {
    const me = this;
    if (me.disabled) {
      return;
    }
    if (await me.trigger("beforeCollapse", {
      record
    }) === false) {
      return;
    }
    me.recordStateMap.delete(record);
    me.collapsingRecords.add(record);
    me.renderRowsWithAnimation(record);
  }
};
_defineProperty(RowExpander, "$name", "RowExpander");
_defineProperty(RowExpander, "configurable", {
  renderer: null,
  triggerEvent: null,
  column: {},
  columnPosition: "first",
  refreshOnRecordChange: false,
  loadingIndicatorHeight: 100,
  loadingIndicatorText: "L{loading}",
  enableAnimations: true
});
RowExpander._$name = "RowExpander";
GridFeatureManager.registerFeature(RowExpander);
var RowReorder = class extends Delayable(InstancePlugin) {
  construct(grid, config) {
    this.grid = grid;
    super.construct(...arguments);
  }
  doDestroy() {
    var _this$dragHelper;
    (_this$dragHelper = this.dragHelper) === null || _this$dragHelper === void 0 ? void 0 : _this$dragHelper.destroy();
    super.doDestroy();
  }
  init() {
    const me = this, {
      grid
    } = me;
    me.dragHelper = DragHelper.new({
      name: "rowReorder",
      cloneTarget: true,
      dragThreshold: 10,
      proxyTopOffset: 10,
      targetSelector: ".b-grid-row",
      lockX: true,
      dragWithin: grid.bodyContainer,
      allowDropOutside: true,
      scrollManager: grid.scrollManager,
      outerElement: me.targetSubGridElement,
      touchStartDelay: me.touchStartDelay,
      isElementDraggable: me.isElementDraggable.bind(me),
      monitoringConfig: {
        scrollables: [{
          element: grid.scrollable.element,
          direction: "vertical"
        }]
      },
      setXY(element, x, y) {
        const {
          context
        } = this;
        if (!context.started) {
          const elementRect = Rectangle.from(context.element, this.dragWithin), pointerDownOffset = context.startPageY - window.pageYOffset - context.element.getBoundingClientRect().top;
          y = elementRect.top + pointerDownOffset + this.proxyTopOffset;
        }
        DomHelper.setTranslateXY(element, x, y);
      },
      ignoreSamePositionDrop: false,
      createProxy(element) {
        const clone = element.cloneNode(true), container = document.createElement("div");
        container.classList.add("b-row-reorder-proxy");
        clone.removeAttribute("id");
        clone.style.transform = "";
        container.appendChild(clone);
        if (grid.selectedRecords.length > 1) {
          const clone2 = clone.cloneNode(true);
          clone2.classList.add("b-row-dragging-multiple");
          container.appendChild(clone2);
        }
        DomHelper.removeClsGlobally(container, "b-selected", "b-hover", "b-focused");
        return container;
      },
      internalListeners: {
        beforedragstart: "onBeforeDragStart",
        dragstart: "onDragStart",
        drag: "onDrag",
        drop: "onDrop",
        reset: "onReset",
        prio: 1e4,
        thisObj: me
      }
    }, me.dragHelperConfig);
    me.relayEvents(me.dragHelper, ["beforeDragStart", "dragStart", "drag", "abort"], "gridRow");
    me.dropIndicator = DomHelper.createElement({
      className: "b-row-drop-indicator"
    });
    me.dropOverTargetCls = ["b-row-reordering-target", "b-hover"];
  }
  get targetSubGridElement() {
    const targetSubGrid = this.grid.regions[0];
    return this.grid.subGrids[targetSubGrid].element;
  }
  isElementDraggable(el, event) {
    if (!el.closest(".b-grid-cell .b-widget")) {
      if (this.gripOnly) {
        const firstCell = el.closest(".b-grid-cell:first-child");
        if (firstCell) {
          const gripperStyle = getComputedStyle(firstCell, ":before"), offsetX = this.grid.rtl ? firstCell.getBoundingClientRect().width - event.borderOffsetX : event.borderOffsetX;
          return DomHelper.roundPx(offsetX) <= DomHelper.roundPx(parseFloat(gripperStyle.width));
        }
      } else {
        return true;
      }
    }
  }
  onBeforeDragStart({
    event,
    source,
    context
  }) {
    const me = this, {
      grid
    } = me, subGridEl = me.targetSubGridElement;
    if (me.disabled || grid.readOnly || grid.isTreeGrouped || !subGridEl.contains(context.element)) {
      return false;
    }
    const startRecord = context.startRecord = grid.getRecordFromElement(context.element);
    if (startRecord.readOnly || startRecord.isSpecialRow) {
      return false;
    }
    context.originalRowTop = grid.rowManager.getRowFor(startRecord).top;
    if (!grid.selectionMode.checkboxOnly) {
      if (source.startEvent.pointerType === "touch") {
        if (!grid.isSelected(startRecord)) {
          grid.selectRow({
            record: startRecord,
            addToSelection: false
          });
        }
      } else if (!grid.isSelected(startRecord) && !event.shiftKey && !event.ctrlKey) {
        grid.selectRow({
          record: startRecord
        });
      }
    }
    const selectedRecords = grid.selectedRecords.filter((r) => !r.readOnly);
    context.records = [startRecord];
    if (selectedRecords.includes(startRecord)) {
      context.records.push(...selectedRecords.filter((r) => r !== startRecord));
      context.records.sort((r1, r2) => grid.store.indexOf(r1) - grid.store.indexOf(r2));
    }
    return true;
  }
  onDragStart({
    context
  }) {
    var _cellMenu$hideContext, _headerMenu$hideConte;
    const me = this, {
      grid
    } = me, {
      cellEdit,
      cellMenu,
      headerMenu
    } = grid.features;
    if (cellEdit) {
      me.cellEditDisabledState = cellEdit.disabled;
      cellEdit.disabled = true;
    }
    cellMenu === null || cellMenu === void 0 ? void 0 : (_cellMenu$hideContext = cellMenu.hideContextMenu) === null || _cellMenu$hideContext === void 0 ? void 0 : _cellMenu$hideContext.call(cellMenu, false);
    headerMenu === null || headerMenu === void 0 ? void 0 : (_headerMenu$hideConte = headerMenu.hideContextMenu) === null || _headerMenu$hideConte === void 0 ? void 0 : _headerMenu$hideConte.call(headerMenu, false);
    grid.element.classList.add("b-row-reordering");
    const focusedCell = context.element.querySelector(".b-focused");
    focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.classList.remove("b-focused");
    context.element.firstElementChild.classList.remove("b-selected", "b-hover");
    grid.bodyContainer.appendChild(me.dropIndicator);
  }
  onDrag({
    context,
    event
  }) {
    const me = this, {
      grid
    } = me, {
      store,
      rowManager
    } = grid, {
      clientY
    } = event;
    let valid = true, row = rowManager.getRowAt(clientY), overRecord, dataIndex, after, over, insertBefore;
    if (row) {
      const rowTop = row.top + grid._bodyRectangle.y - grid.scrollable.y, quarter = row.height / 4, topQuarter = rowTop + quarter, middleY = rowTop + row.height / 2, bottomQuarter = rowTop + quarter * 3;
      dataIndex = row.dataIndex;
      overRecord = store.getAt(dataIndex);
      if (store.tree) {
        over = (overRecord.isParent || me.dropOnLeaf) && clientY > topQuarter && clientY < bottomQuarter;
      } else if (store.isGrouped) {
        over = overRecord.isGroupHeader && overRecord.meta.collapsed;
      }
      after = !over && event.clientY >= middleY;
    } else {
      if (event.pageY < grid._bodyRectangle.y) {
        dataIndex = 0;
        overRecord = store.first;
        after = false;
      } else {
        dataIndex = store.count - 1;
        overRecord = store.last;
        after = true;
      }
      row = grid.rowManager.getRow(dataIndex);
    }
    if (overRecord === me.overRecord && me.after === after && me.over === over) {
      context.valid = me.reorderValid;
      return;
    }
    if (me.overRecord !== overRecord) {
      var _rowManager$getRowByI;
      (_rowManager$getRowByI = rowManager.getRowById(me.overRecord)) === null || _rowManager$getRowByI === void 0 ? void 0 : _rowManager$getRowByI.removeCls(me.dropOverTargetCls);
    }
    me.overRecord = overRecord;
    me.after = after;
    me.over = over;
    if (overRecord === context.startRecord || !after && !over && dataIndex === 0 && store.isGrouped || after && overRecord.isGroupHeader && overRecord.meta.collapsed && store.indexOf(overRecord) === store.count - 1) {
      valid = false;
    }
    if (store.tree) {
      insertBefore = after ? overRecord.nextSibling : overRecord;
      if (context.records.some((rec) => rec.contains(overRecord))) {
        valid = false;
      }
      context.parent = valid && over ? overRecord : overRecord.parent;
      me.clearTimeout(me.hoverTimer);
      if (overRecord && overRecord.isParent && !overRecord.isExpanded(store)) {
        me.hoverTimer = me.setTimeout(() => grid.expand(overRecord), me.hoverExpandTimeout);
      }
    } else {
      insertBefore = after ? store.getAt(dataIndex + 1) : overRecord;
    }
    row.toggleCls(me.dropOverTargetCls, valid && over);
    if (!over && dataIndex === store.indexOf(context.startRecord) + (after ? -1 : 1) && context.parent && context.startRecord.parent === context.parent) {
      valid = false;
    }
    row && DomHelper.setTranslateY(me.dropIndicator, Math.max(row.top + (after ? row.element.getBoundingClientRect().height : 0), 1));
    me.dropIndicator.style.visibility = over ? "hidden" : "visible";
    me.dropIndicator.classList.toggle("b-drag-invalid", !valid);
    context.insertBefore = insertBefore;
    context.valid = me.reorderValid = valid;
  }
  async onDrop(event) {
    const me = this, {
      context
    } = event;
    context.valid = context.valid && me.reorderValid;
    if (context.valid) {
      context.async = true;
      if (me.client.store.tree) {
        context.oldPositionContext = context.records.map((record) => {
          var _record$parent;
          return {
            record,
            parentId: (_record$parent = record.parent) === null || _record$parent === void 0 ? void 0 : _record$parent.id,
            parentIndex: record.parentIndex
          };
        });
      }
      const result = await me.trigger("gridRowBeforeDropFinalize", event);
      if (result === false) {
        context.valid = false;
      }
      await me.dragHelper.animateProxyTo(me.dropIndicator, {
        align: "l0-l0"
      });
      await me.finalizeReorder(context);
    }
    me.clearTimeout(me.hoverTimer);
    me.overRecord = me.after = me.over = null;
    me.trigger("gridRowDrop", event);
  }
  async finalizeReorder(context) {
    const me = this, {
      grid
    } = me, {
      store,
      focusedCell
    } = grid;
    let {
      records
    } = context;
    context.valid = context.valid && !records.some((rec) => !store.includes(rec));
    if (context.valid) {
      let result;
      if (store.tree) {
        var _context$parent$child, _context$parent$child2;
        records = records.filter((record) => !record.parent || record.bubbleWhile((parent) => !records.includes(parent), true));
        result = await context.parent.tryInsertChild(records, me.over ? (_context$parent$child = context.parent.children) === null || _context$parent$child === void 0 ? void 0 : _context$parent$child[0] : context.insertBefore);
        grid.rowManager.forEach((r) => r.removeCls(me.dropOverTargetCls));
        if (!context.parent.isExpanded() && (_context$parent$child2 = context.parent.children) !== null && _context$parent$child2 !== void 0 && _context$parent$child2.length) {
          grid.expand(context.parent);
        }
        context.valid = result !== false;
      } else if (store.isGrouped && me.over) {
        store.move(records, store.getAt(store.indexOf(context.insertBefore) + 1));
      } else {
        store.move(records, context.insertBefore);
      }
      if ((focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell._rowIndex) >= 0) {
        grid._focusedCell = null;
        grid.focusCell({
          grid,
          record: focusedCell.record,
          columnId: focusedCell.columnId
        });
      }
      store.clearSorters();
    }
    context.finalize(context.valid);
    grid.element.classList.remove("b-row-reordering");
  }
  onReset() {
    const me = this, {
      grid
    } = me, cellEdit = grid.features.cellEdit;
    grid.element.classList.remove("b-row-reordering");
    if (cellEdit) {
      cellEdit.disabled = me.cellEditDisabledState;
    }
    me.dropIndicator.remove();
    DomHelper.removeClsGlobally(grid.element, ...me.dropOverTargetCls);
  }
  onPaint({
    firstPaint
  }) {
    if (firstPaint) {
      this.init();
    }
  }
  updateShowGrip(show) {
    this.grid.element.classList.toggle("b-row-reorder-with-grip", show);
  }
};
_defineProperty(RowReorder, "$name", "RowReorder");
_defineProperty(RowReorder, "configurable", {
  showGrip: null,
  gripOnly: null,
  hoverExpandTimeout: 1e3,
  touchStartDelay: 300,
  dropOnLeaf: false,
  dragHelperConfig: null
});
_defineProperty(RowReorder, "pluginConfig", {
  after: ["onPaint"]
});
RowReorder.featureClass = "";
RowReorder._$name = "RowReorder";
GridFeatureManager.registerFeature(RowReorder, false);
GridFeatureManager.registerFeature(RowReorder, true, "Gantt");
var Search = class extends Delayable(InstancePlugin) {
  static get $name() {
    return "Search";
  }
  static get configurable() {
    return {
      limit: 1e3,
      showHitIndex: true,
      keyMap: {
        F3: "gotoNextHit",
        "Ctrl+g": "gotoNextHit",
        "Shift+F3": "gotoPrevHit",
        "Ctrl+Shift+g": "gotoPrevHit"
      }
    };
  }
  static get properties() {
    return {
      hitCls: "b-search-hit",
      hitCellCls: "b-search-hit-cell",
      hitCellBadgeCls: "b-search-hit-cell-badge",
      hitTextCls: "b-search-hit-text"
    };
  }
  construct(grid, config) {
    const me = this;
    super.construct(grid, config);
    Object.assign(me, {
      grid,
      text: "",
      hitEls: [],
      treeWalker: grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)
    });
    grid.ion({
      expandNode: "onTreeNodeExpand",
      thisObj: me
    });
  }
  isActionAvailable() {
    return Boolean(this.text);
  }
  onTreeNodeExpand() {
    if (this.text) {
      this.requestAnimationFrame(this.search, [this.text, false, true]);
    }
  }
  doDestroy() {
    this.clear(true);
    super.doDestroy();
  }
  doDisable(disable) {
    if (disable) {
      this.clear();
    }
    super.doDisable(disable);
  }
  get store() {
    return this.grid.store;
  }
  static get pluginConfig() {
    return {
      chain: ["populateCellMenu"]
    };
  }
  async search(text, gotoHit = true, reapply = false, fields) {
    const me = this;
    if (!text) {
      return me.clear();
    }
    if (!reapply && text === me.text || me.disabled) {
      return;
    }
    const {
      grid,
      store
    } = me, columns = grid.columns.visibleColumns.filter((col) => col.searchable !== false), formatters = [];
    fields = fields || columns.map((col) => {
      var _col$formatValue;
      formatters.push((_col$formatValue = col.formatValue) === null || _col$formatValue === void 0 ? void 0 : _col$formatValue.bind(col));
      return col.field;
    });
    const found = store.search(text, fields, formatters);
    if (store.isTree && found.length) {
      await grid.expandTo(found.map((hit) => hit.id));
    }
    for (const column of columns) {
      if (column.mergeCells && column.isSorted) {
        let prevValue = null, belongsTo = null;
        for (const hit of found) {
          if (hit.field === column.field) {
            const value = hit.data[hit.field];
            if (value === prevValue) {
              hit.belongsTo = belongsTo;
            }
            prevValue = value;
            belongsTo = `${hit.field}-${hit.id}`;
          }
        }
      }
    }
    let i = 1;
    Object.assign(me, {
      foundMap: {},
      prevFound: me.found,
      found,
      text,
      findRe: new RegExp(`(\\s+)?(${StringHelper.escapeRegExp(String(text))})(\\s+)?`, "ig")
    });
    me.clearHits();
    if (!found) {
      return;
    }
    for (const hit of found) {
      me.foundMap[`${hit.field}-${hit.id}`] = hit.belongsTo ? me.foundMap[hit.belongsTo] : i++;
      if (i > me.limit) {
        break;
      }
    }
    if (!me.listenersInitialized) {
      grid.rowManager.ion({
        name: "renderCell",
        renderCell: "renderCell",
        thisObj: me
      });
      store.ion({
        name: "storeRefresh",
        [`refresh${grid.asyncEventSuffix}`]: "onStoreRefresh",
        thisObj: me
      });
      me.listenersInitialized = true;
    }
    grid.refreshRows();
    grid.trigger("search", {
      grid,
      find: text,
      found
    });
    if (gotoHit && !me.isHitFocused) {
      me.gotoNextHit(true);
    }
    return found;
  }
  clearHits() {
    for (const cellElement of DomHelper.children(this.grid.element, "." + this.hitCls)) {
      cellElement.classList.remove(this.hitCls, this.hitCellCls);
      const row = DomDataStore.get(cellElement).row;
      if (row) {
        row.forceInnerHTML = true;
        row.renderCell(cellElement);
        row.forceInnerHTML = false;
      }
    }
  }
  clear(silent = false) {
    const me = this, {
      grid
    } = me;
    if (me.foundMap) {
      delete me.foundMap;
    }
    me.text = null;
    me.clearHits();
    if (me.listenersInitialized) {
      this.detachListeners("renderCell");
      this.detachListeners("storeRefresh");
      me.listenersInitialized = false;
    }
    if (!silent) {
      grid.trigger("clearSearch", {
        grid
      });
    }
  }
  get foundCount() {
    var _this$found$length, _this$found;
    return (_this$found$length = (_this$found = this.found) === null || _this$found === void 0 ? void 0 : _this$found.length) !== null && _this$found$length !== void 0 ? _this$found$length : 0;
  }
  get isHitFocused() {
    var _focusedCell$cell;
    const me = this, {
      grid
    } = me, {
      focusedCell
    } = grid;
    if (focusedCell !== null && focusedCell !== void 0 && (_focusedCell$cell = focusedCell.cell) !== null && _focusedCell$cell !== void 0 && _focusedCell$cell.contains(DomHelper.getActiveElement(grid.element))) {
      const {
        rowIndex,
        column
      } = focusedCell;
      return rowIndex !== -1 && me.found.some((hit) => hit.index === rowIndex && column && hit.field === column.field);
    }
  }
  gotoNextHit(fromStart = false) {
    var _me$found;
    const me = this;
    if (!((_me$found = me.found) !== null && _me$found !== void 0 && _me$found.length))
      return;
    const {
      grid,
      store
    } = me, fromCell = grid.focusedCell || grid.lastFocusedCell, currentIndex = fromCell && fromStart !== true ? store.indexOf(fromCell.record, void 0, true) : -1, nextHit = me.found.findIndex((hit) => hit.index > currentIndex);
    if (nextHit !== -1) {
      me.gotoHit(nextHit);
    }
  }
  gotoPrevHit() {
    var _me$found2;
    const me = this, {
      store
    } = me;
    if (!((_me$found2 = me.found) !== null && _me$found2 !== void 0 && _me$found2.length))
      return;
    const {
      grid,
      found
    } = me, fromCell = grid.focusedCell || grid.lastFocusedCell, currentIndex = fromCell ? store.indexOf(fromCell.record, void 0, true) : 0;
    for (let i = found.length - 1; i--; i >= 0) {
      const hit = found[i];
      if (hit.index < currentIndex) {
        me.gotoHit(i);
        break;
      }
    }
  }
  gotoHit(index) {
    const {
      grid
    } = this, nextHit = this.found[index];
    if (nextHit) {
      grid.focusCell({
        field: nextHit.field,
        id: nextHit.id
      });
    }
    return Boolean(nextHit);
  }
  gotoFirstHit() {
    this.gotoHit(0);
  }
  gotoLastHit() {
    this.gotoHit(this.found.length - 1);
  }
  renderCell({
    cellElement,
    column,
    record,
    value
  }) {
    var _me$foundMap;
    const me = this, {
      treeWalker,
      findRe,
      hitTextCls,
      showHitIndex
    } = me, hitIndex = (_me$foundMap = me.foundMap) === null || _me$foundMap === void 0 ? void 0 : _me$foundMap[column.field + "-" + record.id];
    if (hitIndex) {
      var _cellElement$querySel;
      cellElement.classList.add(me.hitCls);
      showHitIndex && ((_cellElement$querySel = cellElement.querySelector(`.${me.hitCellBadgeCls}`)) === null || _cellElement$querySel === void 0 ? void 0 : _cellElement$querySel.remove());
      const inner = DomHelper.down(cellElement, ".b-grid-cell-value,.b-tree-cell-value") || cellElement;
      if (String(value).toLowerCase() === String(me.text).toLowerCase()) {
        inner.innerHTML = `<span class="${me.hitTextCls}">${inner.innerHTML}</span>${showHitIndex ? `<div class="${me.hitCellBadgeCls}">${hitIndex}</div>` : ""}`;
      } else {
        treeWalker.currentNode = inner;
        for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode); ) {
          const nodeToReplace = textNode, textContent = textNode.nodeValue, newText = ["<span>"];
          textNode = treeWalker.nextNode();
          let offset = findRe.lastIndex;
          for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {
            const preamble = textContent.substring(offset, match.index), spaceBefore = match[1] ? "\xA0" : "", v = match[2], spaceAfter = match[3] ? "\xA0" : "";
            newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class="${hitTextCls}">${v}</span>${spaceAfter}`);
            offset = findRe.lastIndex;
          }
          newText.push(StringHelper.encodeHtml(textContent.substring(offset)), "<span>");
          nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(""), {
            fragment: true
          }), nodeToReplace);
          nodeToReplace.remove();
        }
        if (showHitIndex) {
          DomHelper.createElement({
            parent: cellElement,
            className: me.hitCellBadgeCls,
            text: hitIndex
          });
        }
      }
      me.hitEls.push(cellElement);
    }
  }
  populateCellMenu({
    column,
    record,
    items: items2,
    cellElement
  }) {
    const me = this;
    if (column.searchable) {
      items2.search = {
        text: "L{searchForValue}",
        localeClass: me,
        icon: "b-fw-icon b-icon-search",
        cls: "b-separator",
        weight: 200,
        disabled: me.disabled,
        onItem: () => {
          let sel = globalThis.getSelection().toString();
          if (!sel) {
            sel = cellElement.innerText;
          }
          me.search(sel);
        }
      };
    }
  }
  onStoreRefresh() {
    this.search(this.text, false, true);
  }
};
Search.featureClass = "b-search";
Search._$name = "Search";
GridFeatureManager.registerFeature(Search);
var Sort = class extends InstancePlugin {
  static get $name() {
    return "Sort";
  }
  static get configurable() {
    return {
      multiSort: true,
      prioritizeColumns: false
    };
  }
  static get properties() {
    return {
      ignoreRe: new RegExp([
        "b-grid-header-resize-handle",
        "b-filter-icon"
      ].join("|")),
      sortableCls: "b-sortable",
      sortedCls: "b-sort",
      sortedAscCls: "b-asc",
      sortedDescCls: "b-desc"
    };
  }
  construct(grid, config) {
    config = this.processConfig(config);
    this.grid = grid;
    this.bindStore(this.store);
    super.construct(grid, config);
  }
  processConfig(config) {
    if (typeof config === "string" || Array.isArray(config)) {
      return {
        field: config,
        ascending: null
      };
    }
    return config;
  }
  setConfig(config) {
    super.setConfig(this.processConfig(config));
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      beforeSort: "onStoreBeforeSort",
      sort: "syncHeaderSortState",
      thisObj: this
    });
  }
  set field(field) {
    const column = this.grid.columns.get(field);
    if (column && typeof column.sortable === "object") {
      column.sortable.field = column.sortable.property || field;
      field = column.sortable;
    }
    this.store.sort(field, this.ascending);
  }
  get store() {
    return this.grid[this.grid.sortFeatureStore];
  }
  static get pluginConfig() {
    return {
      chain: ["onElementClick", "populateHeaderMenu", "getColumnDragToolbarItems", "renderHeader", "onPaint", "bindStore"]
    };
  }
  syncHeaderSortState() {
    const me = this, {
      grid
    } = me;
    if (!grid.hideHeaders && grid.isPainted) {
      const storeSorters = me.store.sorters, sorterCount = storeSorters.length, classList = new DomClassList();
      let sorter;
      for (const leafColumn of grid.columns.visibleColumns) {
        var _leafColumn$textWrapp;
        const leafHeader = leafColumn.element, dataset = (_leafColumn$textWrapp = leafColumn.textWrapper) === null || _leafColumn$textWrapp === void 0 ? void 0 : _leafColumn$textWrapp.dataset;
        let sortDirection = "none";
        (dataset === null || dataset === void 0 ? void 0 : dataset.sortIndex) && delete dataset.sortIndex;
        classList.value = leafHeader.classList;
        if (leafColumn.sortable !== false) {
          classList.add(me.sortableCls);
          sorter = storeSorters.find((sort) => sort.field === leafColumn.field || sort.sortFn && sort.sortFn === leafColumn.sortable.sortFn);
          if (sorter) {
            if (sorterCount > 1 && dataset) {
              dataset.sortIndex = storeSorters.indexOf(sorter) + 1;
            }
            classList.add(me.sortedCls);
            if (sorter.ascending) {
              classList.add(me.sortedAscCls);
              classList.remove(me.sortedDescCls);
              sortDirection = "ascending";
            } else {
              classList.add(me.sortedDescCls);
              classList.remove(me.sortedAscCls);
              sortDirection = "descending";
            }
          } else {
            classList.remove(me.sortedCls);
            if (!classList["b-group"]) {
              classList.remove(me.sortedAscCls);
              classList.remove(me.sortedDescCls);
            }
          }
        } else {
          classList.remove(me.sortableCls);
        }
        DomHelper.syncClassList(leafHeader, classList);
        DomHelper.setAttributes(leafHeader, {
          "aria-sort": sortDirection
        });
      }
    }
  }
  populateHeaderMenu({
    column,
    items: items2
  }) {
    const me = this, {
      store
    } = me, sortBy = _objectSpread2(_objectSpread2({}, column.sortable), {}, {
      field: column.field,
      columnOwned: true
    });
    if (column.sortable !== false) {
      items2.sortAsc = {
        text: "L{sortAscending}",
        localeClass: me,
        icon: "b-fw-icon b-icon-sort-asc",
        cls: "b-separator",
        weight: 300,
        disabled: me.disabled,
        onItem: () => store.sort(sortBy, true)
      };
      items2.sortDesc = {
        text: "L{sortDescending}",
        localeClass: me,
        icon: "b-fw-icon b-icon-sort-desc",
        weight: 310,
        disabled: me.disabled,
        onItem: () => store.sort(sortBy, false)
      };
      if (me.multiSort && me.grid.columns.records.some((col) => col.sortable)) {
        const sorter = store.sorters.find((s) => s.field === column.field || column.sortable.sortFn && column.sortable.sortFn === s.sortFn);
        items2.multiSort = {
          text: "L{multiSort}",
          localeClass: me,
          icon: "b-fw-icon b-icon-sort",
          weight: 320,
          disabled: me.disabled,
          menu: {
            addSortAsc: {
              text: sorter ? "L{toggleSortAscending}" : "L{addSortAscending}",
              localeClass: me,
              icon: "b-fw-icon b-icon-sort-asc",
              disabled: sorter && (sorter === null || sorter === void 0 ? void 0 : sorter.ascending),
              weight: 330,
              onItem: () => store.addSorter(sortBy, true)
            },
            addSortDesc: {
              text: sorter ? "L{toggleSortDescending}" : "L{addSortDescending}",
              localeClass: me,
              icon: "b-fw-icon b-icon-sort-desc",
              disabled: sorter && !sorter.ascending,
              weight: 340,
              onItem: () => store.addSorter(sortBy, false)
            },
            removeSorter: {
              text: "L{removeSorter}",
              localeClass: me,
              icon: "b-fw-icon b-icon-remove",
              weight: 350,
              disabled: !sorter,
              onItem: () => {
                store.removeSorter(sortBy.field);
              }
            }
          }
        };
      }
    }
  }
  getColumnDragToolbarItems(column, items2) {
    const me = this, {
      store,
      disabled
    } = me;
    if (column.sortable !== false) {
      const sorter = store.sorters.find((s) => s.field === column.field);
      items2.push({
        text: "L{sortAscendingShort}",
        group: "L{sort}",
        localeClass: me,
        icon: "b-icon b-icon-sort-asc",
        ref: "sortAsc",
        cls: "b-separator",
        weight: 105,
        disabled,
        onDrop: ({
          column: column2
        }) => store.sort(column2.field, true)
      }, {
        text: "L{sortDescendingShort}",
        group: "L{sort}",
        localeClass: me,
        icon: "b-icon b-icon-sort-desc",
        ref: "sortDesc",
        weight: 105,
        disabled,
        onDrop: ({
          column: column2
        }) => store.sort(column2.field, false)
      }, {
        text: "L{addSortAscendingShort}",
        group: "L{multiSort}",
        localeClass: me,
        icon: "b-icon b-icon-sort-asc",
        ref: "multisortAddAsc",
        disabled: disabled || sorter && sorter.ascending,
        weight: 105,
        onDrop: ({
          column: column2
        }) => store.addSorter(column2.field, true)
      }, {
        text: "L{addSortDescendingShort}",
        group: "L{multiSort}",
        localeClass: me,
        icon: "b-icon b-icon-sort-desc",
        ref: "multisortAddDesc",
        disabled: disabled || sorter && !sorter.ascending,
        weight: 105,
        onDrop: ({
          column: column2
        }) => store.addSorter(column2.field, false)
      }, {
        text: "L{removeSorterShort}",
        group: "L{multiSort}",
        localeClass: me,
        icon: "b-icon b-icon-remove",
        ref: "multisortRemove",
        weight: 105,
        disabled: disabled || !sorter,
        onDrop: ({
          column: column2
        }) => store.removeSorter(column2.field)
      });
    }
    return items2;
  }
  onStoreBeforeSort({
    sorters
  }) {
    const {
      columns
    } = this.client;
    for (let i = 0; i < sorters.length; i++) {
      var _column$sortable;
      const sorter = sorters[i], column = (sorter.columnOwned || this.prioritizeColumns) && columns.get(sorter.field);
      if (column !== null && column !== void 0 && (_column$sortable = column.sortable) !== null && _column$sortable !== void 0 && _column$sortable.sortFn) {
        sorters[i] = _objectSpread2(_objectSpread2(_objectSpread2({}, sorter), column.sortable), {}, {
          columnOwned: true
        });
      }
    }
  }
  onElementClick(event) {
    const me = this, {
      store
    } = me, {
      target
    } = event, header = target.closest(".b-grid-header.b-sortable"), field = header === null || header === void 0 ? void 0 : header.dataset.column;
    if (me.ignoreRe.test(target.className) || me.disabled || event.handled) {
      return;
    }
    if (header && field) {
      const column = me.grid.columns.getById(header.dataset.columnId), columnGrouper = store.isGrouped && store.groupers.find((g) => g.field === field);
      if (columnGrouper && !event.shiftKey) {
        return;
      }
      if (column.sortable && !event.shiftKey) {
        if (event.ctrlKey && event.altKey) {
          store.removeSorter(column.field);
        } else {
          const sortBy = {
            columnOwned: true,
            field: column.field
          };
          if (typeof column.sortable === "object") {
            ObjectHelper.assign(sortBy, column.sortable);
          }
          store.sort(sortBy, null, event.ctrlKey);
        }
      }
    }
  }
  renderHeader() {
    this.syncHeaderSortState();
  }
  onPaint() {
    this.syncHeaderSortState();
  }
};
Sort.featureClass = "b-sort";
Sort._$name = "Sort";
GridFeatureManager.registerFeature(Sort, true);
var StickyCells = class extends InstancePlugin {
  static get $name() {
    return "StickyCells";
  }
  static get defaultConfig() {
    return {
      contentSelector: null,
      currentTopRowCls: "b-sticky-cells-current-top-row"
    };
  }
  static get pluginConfig() {
    return {
      before: ["renderRows"]
    };
  }
  construct(grid, config) {
    super.construct(grid, config);
    grid.ion({
      scroll: "onGridScroll",
      thisObj: this
    });
    Object.assign(this, DomHelper.createElement({
      reference: "element",
      parent: grid.element,
      className: "b-grid-sticky-row",
      children: [{
        reference: "contentElement",
        className: "b-grid-cell"
      }]
    }));
    this.removeClasses = {
      "b-focused": false,
      "b-hover": false,
      "b-selected": false,
      [this.currentTopRowCls]: false
    };
  }
  renderRows() {
    this.element.classList.add("b-hide-visibility");
  }
  onGridScroll() {
    const me = this, {
      client: grid,
      element,
      contentElement
    } = me, gridViewport = Rectangle.client(grid.bodyContainer).roundPx(), currentTopRow = grid.rowManager.getRowAt(gridViewport.y), topRowChanged = currentTopRow !== me.currentTopRow;
    if (currentTopRow) {
      if (topRowChanged) {
        if (me.currentTopRow) {
          me.currentTopRow.removeCls(me.currentTopRowCls);
          me.currentTopRow.removeCls("b-not-enough-height");
        }
        me.currentTopRow = currentTopRow;
        currentTopRow.addCls(me.currentTopRowCls);
        contentElement.innerHTML = "";
        contentElement.appendChild(me.updateStickyContent());
      }
      const notEnoughHeight = me.currentTopRow.bottom - me.client.scrollable.y <= me.stickyContentHeight;
      me.element.classList[notEnoughHeight ? "add" : "remove"]("b-hide-visibility");
      me.currentTopRow[notEnoughHeight ? "addCls" : "removeCls"]("b-not-enough-height");
      gridViewport.y += me.stickyContentTop;
      DomHelper.alignTo(element, me.stickyEls[0], {
        align: "t0-t0",
        constrainTo: gridViewport
      }, true);
    }
    me.lastProcessedTopRow = currentTopRow;
  }
  updateStickyContent() {
    const me = this, {
      currentTopRow,
      removeClasses
    } = me, rowClasses = {
      "b-grid-sticky-row": 1
    }, cellClasses = {}, stickyContent = me.stickyContent || (me.stickyContent = document.createDocumentFragment()), stickyEls = me.stickyEls || (me.stickyEls = []);
    stickyEls.forEach((e) => {
      e.classList.remove("b-sticky-content-el");
    });
    stickyEls.length = 0;
    currentTopRow.eachElement((rowEl) => {
      stickyEls.push(...rowEl.querySelectorAll(me.contentSelector));
    });
    while (stickyContent.firstChild) {
      stickyContent.remove(stickyContent.firstChild);
    }
    me.stickyContentHeight = 0;
    me.stickyContentTop = 0;
    stickyEls.map((e) => {
      e.closest(".b-grid-cell").classList.forEach((cls) => cellClasses[cls] = 1);
      e.closest(".b-grid-row").classList.forEach((cls) => rowClasses[cls] = 1);
      Object.assign(cellClasses, removeClasses);
      Object.assign(rowClasses, removeClasses);
      const eTop = e.offsetTop;
      me.stickyContentTop = Math.max(me.stickyContentTop, eTop);
      e.style.alignSelf = "flex-end";
      me.stickyContentHeight = Math.max(me.stickyContentHeight, me.currentTopRow.height - e.offsetTop + eTop);
      e.style.alignSelf = "";
      const result = e.cloneNode(true);
      e.classList.add("b-sticky-content-el");
      stickyContent.appendChild(result);
      return result;
    });
    cellClasses["b-focused"] = false;
    DomHelper.syncClassList(me.contentElement, cellClasses);
    DomHelper.syncClassList(me.element, rowClasses);
    return stickyContent;
  }
};
StickyCells._$name = "StickyCells";
GridFeatureManager.registerFeature(StickyCells, false);
var Stripe = class extends InstancePlugin {
  static get $name() {
    return "Stripe";
  }
  construct(grid, config) {
    super.construct(grid, config);
    grid.ion({
      renderrow: "onRenderRow",
      thisObj: this
    });
  }
  doDisable(disable) {
    if (!this.isConfiguring) {
      this.client.refreshRows();
    }
    super.doDisable(disable);
  }
  onRenderRow({
    row
  }) {
    const {
      disabled
    } = this, even = row.dataIndex % 2 === 0;
    row.assignCls({
      "b-even": !disabled && even,
      "b-odd": !disabled && !even
    });
  }
};
Stripe._$name = "Stripe";
GridFeatureManager.registerFeature(Stripe);
var Summary = class extends SummaryFormatter(InstancePlugin) {
  static get configurable() {
    return {
      selectedOnly: null,
      hideFooters: false
    };
  }
  static get pluginConfig() {
    return {
      chain: ["renderRows", "bindStore"]
    };
  }
  static get $name() {
    return "Summary";
  }
  construct(grid, config) {
    this.grid = grid;
    super.construct(grid, config);
    this.bindStore(grid.store);
    grid.hideFooters = this.hideFooters;
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      change: "onStoreChange",
      thisObj: this
    });
  }
  get store() {
    return this.grid.store;
  }
  doDestroy() {
    super.doDestroy();
  }
  doDisable(disable) {
    super.doDisable(disable);
    const {
      client
    } = this;
    if (disable) {
      client.element.classList.add("b-summary-disabled");
    } else {
      this.updateSummaries();
      client.element.classList.remove("b-summary-disabled");
      client.eachSubGrid((subGrid) => subGrid.scrollable.syncPartners());
    }
  }
  renderRows() {
    this.updateSummaries();
  }
  updateSummaries() {
    const me = this, {
      grid,
      store
    } = me, cells = DomHelper.children(grid.element, ".b-grid-footer"), selectedOnly = me.selectedOnly && grid.selectedRecords.length > 0, records = (store.isFiltered ? store.storage.values : store.allRecords).filter((r) => !r.isSpecialRow && (!selectedOnly || grid.isSelected(r)));
    grid.columns.forEach((column) => {
      var _column$summaries;
      (_column$summaries = column.summaries) === null || _column$summaries === void 0 ? void 0 : _column$summaries.forEach((config) => {
        if ("seed" in config) {
          if (!("initialSeed" in config)) {
            config.initialSeed = config.seed;
          }
          if (["number", "string", "date"].includes(typeof config.initialSeed)) {
            config.seed = config.initialSeed;
          } else {
            config.seed = Object.assign({}, config.initialSeed);
          }
        }
      });
    });
    cells.forEach((cellElement) => {
      if (!cellElement.dataset.column) {
        return;
      }
      const column = grid.columns.get(cellElement.dataset.column), html = me.generateHtml(column, records, "b-grid-footer-summary");
      if (column.summaries ? column.summaries.length : column.sum ? 1 : 0) {
        if (!cellElement.children.length) {
          cellElement.innerHTML = html;
        } else {
          DomHelper.sync(html, cellElement.firstElementChild);
        }
      }
    });
  }
  onStoreChange({
    action,
    changes
  }) {
    let shouldUpdate = true;
    if (this.disabled) {
      return;
    }
    if (action === "update") {
      shouldUpdate = Object.keys(changes).some((field) => {
        const colField = this.grid.columns.get(field);
        return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));
      });
    }
    if (shouldUpdate) {
      this.updateSummaries();
    }
  }
  updateSelectedOnly(value) {
    const me = this;
    me.detachListeners("selectionChange");
    if (value) {
      me.grid.ion({
        name: "selectionChange",
        selectionChange: me.refresh,
        thisObj: me
      });
    }
    me.refresh();
  }
  refresh() {
    this.updateSummaries();
  }
};
Summary.featureClass = "b-summary";
Summary._$name = "Summary";
GridFeatureManager.registerFeature(Summary);
var immediatePromise$1 = Promise.resolve();
var Tree = class extends InstancePlugin.mixin(Delayable) {
  static get pluginConfig() {
    return {
      assign: ["collapseAll", "expandAll", "collapse", "expand", "expandTo", "toggleCollapse"],
      chain: ["onElementPointerUp", "onElementClick", "bindStore"]
    };
  }
  construct(client, config) {
    super.construct(client, config);
    if (!this.treeColumn) {
      console.info("To use the tree feature, one column should be configured with `type: 'tree'`");
    }
    client.store && this.bindStore(client.store);
  }
  doDisable(disable) {
    if (disable) {
      throw new Error("Tree feature cannot be disabled");
    }
  }
  get store() {
    return this.client.store;
  }
  get treeColumn() {
    const me = this, {
      columns
    } = me.client;
    if (!me._treeColumn || !columns.includes(me._treeColumn)) {
      me._treeColumn = columns.find((column) => column.isTreeColumn);
    }
    return me._treeColumn;
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      beforeLoadChildren: "onBeforeLoadChildren",
      loadChildren: "onLoadChildren",
      loadChildrenException: "onLoadChildrenException",
      beforeToggleNode: "onBeforeToggleNode",
      thisObj: this
    });
  }
  async toggleCollapse(idOrRecord, collapse, skipRefresh = false) {
    if (idOrRecord == null) {
      throw new Error("Tree#toggleCollapse must be passed a record");
    }
    const me = this, {
      store,
      client
    } = me, {
      rowManager
    } = client, record = store.getById(idOrRecord), meta = record.instanceMeta(store);
    if (await store.toggleCollapse(record, collapse)) {
      const row = rowManager.getRowFor(record);
      if (row && record.ancestorsExpanded()) {
        const cellElement = me.treeColumn && !me.treeColumn.subGrid.collapsed && row.getCell(me.treeColumn.id);
        cellElement && row.renderCell(cellElement);
      }
      if (!me.isTogglingNode) {
        client.element.classList.add("b-toggling-node");
        me.isTogglingNode = true;
        me.requestAnimationFrame(() => {
          client.element.classList.remove("b-toggling-node");
          me.isTogglingNode = false;
        });
      }
      client.trigger(meta.collapsed ? "collapseNode" : "expandNode", {
        record
      });
      client.trigger("toggleNode", {
        record,
        collapse: meta.collapsed
      });
    }
  }
  async collapse(idOrRecord) {
    return this.toggleCollapse(idOrRecord, true);
  }
  async expand(idOrRecord) {
    return this.toggleCollapse(idOrRecord, false);
  }
  onBeforeToggleNode({
    record,
    collapse
  }) {
    this.client.trigger("beforeToggleNode", {
      record,
      collapse
    });
  }
  onBeforeLoadChildren({
    source: store,
    params
  }) {
    const parent = store.getById(params[store.modelClass.idField]), row = this.client.rowManager.getRowFor(parent);
    row === null || row === void 0 ? void 0 : row.addCls("b-loading-children");
  }
  onLoadChildren({
    source: store,
    params
  }) {
    const parent = store.getById(params[store.modelClass.idField]), row = this.client.rowManager.getRowFor(parent);
    row === null || row === void 0 ? void 0 : row.removeCls("b-loading-children");
  }
  onLoadChildrenException({
    record
  }) {
    const row = this.client.rowManager.getRowFor(record);
    row === null || row === void 0 ? void 0 : row.removeCls("b-loading-children");
  }
  async expandOrCollapseAll(collapse = true, topNode = this.store.rootNode) {
    const {
      client,
      store
    } = this, promises = [], childRecords = [];
    client.trigger("beforeToggleAllNodes", {
      collapse
    });
    store.suspendEvents();
    store.traverse((record) => {
      const gridMeta = record.instanceMeta(store);
      if (!record.isLeaf) {
        if (collapse && !gridMeta.collapsed) {
          this.toggleCollapse(record, true, true);
          childRecords.push(...record.children);
        } else if (!collapse && gridMeta.collapsed) {
          if (Array.isArray(record.children)) {
            childRecords.push(...record.children);
          }
          promises.push(this.toggleCollapse(record, false, true));
        }
      }
    }, topNode, topNode === store.rootNode);
    store.resumeEvents();
    return (collapse ? immediatePromise$1 : Promise.all(promises)).then(() => {
      client.refreshRows(collapse);
      if (childRecords.length) {
        if (collapse) {
          store.trigger("remove", {
            records: childRecords,
            isCollapse: true,
            isCollapseAll: true
          });
        } else {
          store.trigger("add", {
            records: childRecords,
            isExpand: true,
            isExpandAll: true
          });
        }
      }
      client.trigger("toggleAllNodes", {
        collapse
      });
    });
  }
  async collapseAll() {
    return this.expandOrCollapseAll(true);
  }
  async expandAll() {
    return this.expandOrCollapseAll(false);
  }
  async expandTo(idOrRecord, scrollIntoView = true) {
    const me = this, {
      store,
      client
    } = me;
    if (Array.isArray(idOrRecord)) {
      if (idOrRecord.length > 0) {
        client.suspendRefresh();
        for (let i = idOrRecord.length - 1; i >= 0; i--) {
          var _me$expandTo;
          const record2 = store.getById(idOrRecord[i]);
          if (i === 0) {
            var _client$resumeRefresh;
            (_client$resumeRefresh = client.resumeRefresh) === null || _client$resumeRefresh === void 0 ? void 0 : _client$resumeRefresh.call(client);
            client.rowManager.refresh();
          }
          await ((_me$expandTo = me.expandTo) === null || _me$expandTo === void 0 ? void 0 : _me$expandTo.call(me, record2, i === 0));
        }
      }
      return;
    }
    const record = store.getById(idOrRecord);
    if (record.instanceMeta(me.store).hiddenByCollapse === false) {
      return;
    }
    if (!record.ancestorsExpanded()) {
      var _client$refreshRows;
      const parents = [];
      for (let parent = record.parent; parent && !parent.isRoot; parent = parent.parent) {
        if (!parent.isExpanded(store)) {
          parents.unshift(parent);
        }
      }
      for (const parent of parents) {
        if (!me.isDestroyed) {
          await me.toggleCollapse(parent, false, true);
        }
      }
      (_client$refreshRows = client.refreshRows) === null || _client$refreshRows === void 0 ? void 0 : _client$refreshRows.call(client);
    }
    if (!me.isDestroyed && scrollIntoView) {
      await client.scrollRowIntoView(record);
    }
  }
  onElementPointerUp(event) {
    const me = this, target = event.target, cellData = me.client.getCellDataFromEvent(event), clickedExpander = target.closest(".b-tree-expander");
    if (clickedExpander || me.expandOnCellClick && cellData !== null && cellData !== void 0 && cellData.record.isParent) {
      me.toggleCollapse(cellData.record);
    }
  }
  onElementClick(event) {
    if (event.target.closest(".b-tree-expander")) {
      event.preventDefault();
    }
  }
  toggleCollapseByKey() {
    const {
      focusedCell
    } = this.client;
    if ((focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.rowIndex) > -1 && !focusedCell.isActionable) {
      this.toggleCollapse(focusedCell.id);
      return true;
    }
    return false;
  }
  expandIfSingleColumn() {
    if (this.client.columns.count === 1) {
      return this.expandByKey();
    }
    return false;
  }
  expandByKey() {
    const me = this, {
      client
    } = me, {
      focusedCell
    } = client, record = focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.record;
    if (focusedCell !== null && focusedCell !== void 0 && focusedCell.column.tree && record.isParent && record.instanceMeta(client.store).collapsed) {
      me.expand(record);
      return true;
    }
    return false;
  }
  collapseIfSingleColumn() {
    if (this.client.columns.count === 1) {
      return this.collapseByKey();
    }
    return false;
  }
  collapseByKey() {
    const me = this, {
      client
    } = me, {
      focusedCell
    } = client, record = focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.record;
    if (focusedCell !== null && focusedCell !== void 0 && focusedCell.column.tree) {
      if (record.isParent && !record.instanceMeta(client.store).collapsed) {
        me.collapse(record);
        return true;
      }
      if (record.parent && !record.parent.isRoot) {
        client.deselectAll();
        client.focusCell({
          record: record.parent,
          column: focusedCell.column
        });
        return true;
      }
    }
    return false;
  }
};
_defineProperty(Tree, "$name", "Tree");
_defineProperty(Tree, "configurable", {
  expandOnCellClick: false,
  keyMap: {
    " ": "toggleCollapseByKey",
    ArrowRight: "expandIfSingleColumn",
    "Shift+ArrowRight": "expandByKey",
    ArrowLeft: "collapseIfSingleColumn",
    "Shift+ArrowLeft": "collapseByKey"
  }
});
Tree.featureClass = "b-tree";
Tree._$name = "Tree";
GridFeatureManager.registerFeature(Tree, false, "Grid");
GridFeatureManager.registerFeature(Tree, true, "TreeGrid");
var TreeGroup = class extends InstancePlugin {
  construct(grid, config) {
    super.construct(grid, config);
    if (!grid.hasFeature("tree")) {
      throw new Error("The TreeGroup feature requires the Tree feature to be enabled");
    }
  }
  processParentData(parentData) {
    if (this.parentCls) {
      parentData.cls = this.parentCls;
    }
  }
  processTransformedData(transformedData) {
  }
  async waitForReadiness() {
    if (this.originalStore.isLoading) {
      await this.originalStore.await("load", false);
      if (this.isDestroyed) {
        return;
      }
    }
    const {
      crudManager
    } = this.client;
    if (crudManager) {
      if (crudManager.isLoadingOrSyncing) {
        await crudManager.await("requestDone");
        if (this.isDestroyed) {
          return;
        }
      }
      await this.client.project.commitAsync();
    }
  }
  async applyLevels(levels) {
    const me = this, {
      client
    } = me, treeColumn = client.columns.find((col) => col instanceof TreeColumn);
    let {
      store
    } = client, result = null;
    me._levels = levels;
    me.isApplying++;
    client.suspendRefresh();
    if (levels && !me.originalStore) {
      me.originalStore = store;
      store = new store.constructor({
        tree: true,
        modelClass: store.modelClass
      });
      client.store = store;
    }
    await me.waitForReadiness();
    if (me.isDestroyed) {
      return;
    }
    if (levels) {
      store.data = me.originalStore.allRecords.flatMap((record) => record.isLeaf ? [record.link()] : []);
      result = store.treeify(levels, (parentData) => {
        ObjectHelper.setPath(parentData, store.modelClass.getFieldDataSource(treeColumn.field), parentData.key);
        me.processParentData(parentData);
      });
      me.processTransformedData(result);
      store.data = result.children;
    } else {
      client.store = me.originalStore;
      me.originalStore = null;
    }
    me.isApplying--;
    client.resumeRefresh();
    client.rowManager.reinitialize();
    return result;
  }
  updateLevels(levels) {
    if (levels || !this.isConfiguring) {
      this.applyLevels(levels);
    }
  }
  async group(levels) {
    ObjectHelper.assertArray(levels, "group()");
    await this.applyLevels(levels);
  }
  async clearGroups() {
    if (this.isGrouped) {
      await this.applyLevels(null);
    }
  }
  get isGrouped() {
    return Boolean(this._levels);
  }
};
_defineProperty(TreeGroup, "$name", "TreeGroup");
_defineProperty(TreeGroup, "configurable", {
  levels: null,
  parentCls: "b-generated-parent"
});
_defineProperty(TreeGroup, "pluginConfig", {
  assign: ["group", "clearGroups"]
});
_defineProperty(TreeGroup, "properties", {
  isApplying: 0,
  originalStore: null
});
TreeGroup._$name = "TreeGroup";
GridFeatureManager.registerFeature(TreeGroup);
var RowsRange = {
  all: "all",
  visible: "visible"
};
var PaperFormat = {
  A6: {
    width: 4.11,
    height: 5.81
  },
  A5: {
    width: 5.81,
    height: 8.25
  },
  A4: {
    width: 8.25,
    height: 11.69
  },
  A3: {
    width: 11.69,
    height: 16.49
  },
  Legal: {
    width: 8.5,
    height: 14
  },
  Letter: {
    width: 8.5,
    height: 11
  }
};
var Orientation = {
  portrait: "portrait",
  landscape: "landscape"
};
var FileFormat = {
  pdf: "pdf",
  png: "png"
};
var FileMIMEType = {
  pdf: "application/pdf",
  png: "image/png"
};
var ExportRowsCombo = class extends Combo {
  static get $name() {
    return "ExportRowsCombo";
  }
  static get type() {
    return "exportrowscombo";
  }
  static get defaultConfig() {
    return {
      editable: false
    };
  }
  buildItems() {
    const me = this;
    return [{
      id: RowsRange.all,
      text: me.L("L{all}")
    }, {
      id: RowsRange.visible,
      text: me.L("L{visible}")
    }];
  }
};
ExportRowsCombo.initClass();
ExportRowsCombo._$name = "ExportRowsCombo";
var ExportOrientationCombo = class extends Combo {
  static get $name() {
    return "ExportOrientationCombo";
  }
  static get type() {
    return "exportorientationcombo";
  }
  static get defaultConfig() {
    return {
      editable: false
    };
  }
  buildItems() {
    const me = this;
    return [{
      id: Orientation.portrait,
      text: me.L("L{portrait}")
    }, {
      id: Orientation.landscape,
      text: me.L("L{landscape}")
    }];
  }
};
ExportOrientationCombo.initClass();
ExportOrientationCombo._$name = "ExportOrientationCombo";
function buildComboItems(obj, fn = (x) => x) {
  return Object.keys(obj).map((key) => ({
    id: key,
    text: fn(key)
  }));
}
var ExportDialog = class extends Popup {
  static get $name() {
    return "ExportDialog";
  }
  static get type() {
    return "exportdialog";
  }
  static get configurable() {
    return {
      autoShow: false,
      autoClose: false,
      closable: true,
      centered: true,
      client: null,
      autoSelectVisibleColumns: true,
      hidePNGMultipageOption: true,
      title: "L{exportSettings}",
      maxHeight: "80%",
      scrollable: {
        overflowY: true
      },
      defaults: {
        localeClass: this
      },
      items: {
        columnsField: {
          type: "combo",
          label: "L{ExportDialog.columns}",
          store: {},
          valueField: "id",
          displayField: "text",
          multiSelect: true,
          weight: 100,
          maxHeight: 100
        },
        rowsRangeField: {
          type: "exportrowscombo",
          label: "L{ExportDialog.rows}",
          value: "all",
          weight: 200
        },
        exporterTypeField: {
          type: "combo",
          label: "L{ExportDialog.exporterType}",
          editable: false,
          value: "singlepage",
          displayField: "text",
          buildItems() {
            const dialog = this.parent;
            return dialog.exporters.map((exporter) => ({
              id: exporter.type,
              text: dialog.optionalL(exporter.title, this)
            }));
          },
          onChange({
            value
          }) {
            this.owner.widgetMap.alignRowsField.hidden = value === "singlepage";
            this.owner.widgetMap.repeatHeaderField.hidden = value !== "multipagevertical";
          },
          weight: 300
        },
        alignRowsField: {
          type: "checkbox",
          label: "L{ExportDialog.alignRows}",
          checked: false,
          hidden: true,
          weight: 400
        },
        repeatHeaderField: {
          type: "checkbox",
          label: "L{ExportDialog.repeatHeader}",
          localeClass: this,
          hidden: true,
          weight: 500
        },
        fileFormatField: {
          type: "combo",
          label: "L{ExportDialog.fileFormat}",
          localeClass: this,
          editable: false,
          value: "pdf",
          items: [],
          onChange({
            value,
            oldValue
          }) {
            const dialog = this.parent;
            if (dialog.hidePNGMultipageOption) {
              const exporterField = dialog.widgetMap.exporterTypeField, exporter = exporterField.store.find((r) => r.id === "singlepage");
              if (value === FileFormat.png && exporter) {
                this._previousDisabled = exporterField.disabled;
                exporterField.disabled = true;
                this._previousValue = exporterField.value;
                exporterField.value = "singlepage";
              } else if (oldValue === FileFormat.png && this._previousValue) {
                exporterField.disabled = this._previousDisabled;
                exporterField.value = this._previousValue;
              }
            }
          },
          weight: 600
        },
        paperFormatField: {
          type: "combo",
          label: "L{ExportDialog.paperFormat}",
          editable: false,
          value: "A4",
          items: [],
          weight: 700
        },
        orientationField: {
          type: "exportorientationcombo",
          label: "L{ExportDialog.orientation}",
          value: "portrait",
          weight: 800
        }
      },
      bbar: {
        defaults: {
          localeClass: this
        },
        items: {
          exportButton: {
            color: "b-green",
            text: "L{ExportDialog.export}",
            weight: 100,
            onClick: "up.onExportClick"
          },
          cancelButton: {
            color: "b-gray",
            text: "L{ExportDialog.cancel}",
            weight: 200,
            onClick: "up.onCancelClick"
          }
        }
      }
    };
  }
  construct(config = {}) {
    const me = this, {
      client
    } = config;
    if (!client) {
      throw new Error("`client` config is required");
    }
    me.columnsStore = client.columns.chain((column) => column.isLeaf && column.exportable, null, {
      excludeCollapsedRecords: false
    });
    me.applyInitialValues(config);
    super.construct(config);
    LocaleManagerSingleton.ion({
      locale: "onLocaleChange",
      prio: -1,
      thisObj: me
    });
  }
  applyInitialValues(config) {
    const me = this, items2 = config.items = config.items || {};
    config.width = config.width || me.L("L{width}");
    config.defaults = config.defaults || {};
    config.defaults.labelWidth = config.defaults.labelWidth || me.L("L{ExportDialog.labelWidth}");
    items2.columnsField = items2.columnsField || {};
    items2.fileFormatField = items2.fileFormatField || {};
    items2.paperFormatField = items2.paperFormatField || {};
    items2.fileFormatField.items = buildComboItems(FileFormat, (value) => value.toUpperCase());
    items2.paperFormatField.items = buildComboItems(PaperFormat);
    items2.columnsField.store = me.columnsStore;
  }
  onBeforeShow() {
    var _super$onBeforeShow;
    const {
      columnsField,
      alignRowsField,
      exporterTypeField,
      repeatHeaderField
    } = this.widgetMap;
    if (this.autoSelectVisibleColumns) {
      columnsField.value = this.columnsStore.query((c) => !c.hidden);
    }
    alignRowsField.hidden = exporterTypeField.value === "singlepage";
    repeatHeaderField.hidden = exporterTypeField.value !== "multipagevertical";
    (_super$onBeforeShow = super.onBeforeShow) === null || _super$onBeforeShow === void 0 ? void 0 : _super$onBeforeShow.call(this, ...arguments);
  }
  onLocaleChange() {
    const labelWidth = this.L("L{labelWidth}");
    this.width = this.L("L{width}");
    this.eachWidget((widget) => {
      if (widget instanceof Field) {
        widget.labelWidth = labelWidth;
      }
    });
  }
  onExportClick() {
    const values = this.values;
    this.trigger("export", {
      values
    });
  }
  onCancelClick() {
    this.trigger("cancel");
    this.hide();
  }
  get values() {
    const fieldRe = /field/i, result = {};
    this.eachWidget((widget) => {
      if (fieldRe.test(widget.ref)) {
        result[widget.ref.replace(fieldRe, "")] = widget instanceof Checkbox ? widget.checked : widget.value;
      }
    });
    return result;
  }
};
ExportDialog.initClass();
ExportDialog._$name = "ExportDialog";
var cellContentRange = document.createRange();
var Row = class extends Base {
  static get configurable() {
    return {
      cls: {
        $config: {
          equal: (c1, c2) => (c1 === null || c1 === void 0 ? void 0 : c1.isDomClassList) && (c2 === null || c2 === void 0 ? void 0 : c2.isDomClassList) && c1.isEqual(c2)
        }
      }
    };
  }
  construct(config) {
    Object.assign(this, {
      _elements: {},
      _elementsArray: [],
      _cells: {},
      _allCells: [],
      _regions: [],
      lastHeight: 0,
      lastTop: -1,
      _dataIndex: 0,
      _top: 0,
      _height: 0,
      _id: null,
      forceInnerHTML: false,
      isGroupFooter: false,
      cellContext: new Location({
        grid: config.grid,
        id: null,
        columnIndex: 0
      })
    });
    super.construct(config);
    if (this.grid.positionMode === "position") {
      this.translateElements = this.positionElements;
    }
  }
  doDestroy() {
    const me = this;
    if (!me.rowManager.isDestroying) {
      me.removeElements();
      if (me.rowManager.idMap[me.id] === me) {
        delete me.rowManager.idMap[me.id];
      }
    }
    super.doDestroy();
  }
  get index() {
    return this._index;
  }
  set index(index) {
    this._index = index;
  }
  get dataIndex() {
    return this._dataIndex;
  }
  set dataIndex(dataIndex) {
    if (this._dataIndex !== dataIndex) {
      this._dataIndex = dataIndex;
      this.eachElement((element) => {
        element.dataset.index = dataIndex;
        element.ariaRowIndex = this.grid.hideHeaders ? dataIndex + 1 : dataIndex + 2;
      });
    }
  }
  get id() {
    return this._id;
  }
  set id(id) {
    const me = this, idObj = {
      id
    }, idMap = me.rowManager.idMap;
    if (me._id !== id || idMap[id] !== me) {
      if (idMap[me._id] === me)
        delete idMap[me._id];
      idMap[id] = me;
      me._id = id;
      me.eachElement((element) => {
        DomDataStore.assign(element, idObj);
        element.dataset.id = id;
      });
      me.eachCell((cell) => DomDataStore.assign(cell, idObj));
    }
  }
  addElement(region, element) {
    const me = this;
    let cellElement = element.firstElementChild;
    me._elements[region] = element;
    me._elementsArray.push(element);
    me._regions.push(region);
    DomDataStore.assign(element, {
      index: me.index
    });
    me._cells[region] = [];
    while (cellElement) {
      me._cells[region].push(cellElement);
      me._allCells.push(cellElement);
      DomDataStore.set(cellElement, {
        column: cellElement.dataset.column,
        columnId: cellElement.dataset.columnId,
        rowElement: cellElement.parentNode,
        row: me
      });
      cellElement = cellElement.nextElementSibling;
    }
    element.dataset.index = me.index;
    element.ariaRowIndex = me.grid.hideHeaders ? me.index + 1 : me.index + 2;
  }
  getElement(region) {
    return this._elements[region];
  }
  getRectangle(region) {
    return Rectangle.from(this.getElement(region));
  }
  eachElement(fn) {
    this._elementsArray.forEach(fn);
  }
  eachCell(fn) {
    this._allCells.forEach(fn);
  }
  get elements() {
    return this._elements;
  }
  get element() {
    const region = Object.keys(this._elements)[0];
    return this._elements[region];
  }
  get cells() {
    return this._allCells;
  }
  getCells(region) {
    return this._cells[region];
  }
  getCell(columnId) {
    return this._allCells.find((cell) => {
      const cellData = DomDataStore.get(cell);
      return cellData.columnId == columnId || cellData.column == columnId;
    });
  }
  removeElements(onlyRelease = false) {
    const me = this;
    me.rowManager.trigger("removeRow", {
      row: me
    });
    if (!onlyRelease) {
      me.eachElement((element) => element.remove());
    }
    me._elements = {};
    me._cells = {};
    me._elementsArray.length = me._regions.length = me._allCells.length = me.lastHeight = me.height = 0;
    me.lastTop = -1;
  }
  get height() {
    return this._height;
  }
  set height(height) {
    this._height = height;
  }
  get offsetHeight() {
    return this.height + this.grid._rowBorderHeight;
  }
  updateElementsHeight(isExport) {
    const me = this;
    if (!isExport) {
      me.rowManager.storeKnownHeight(me.id, me.height);
    }
    if (me.lastHeight !== me.height) {
      this.eachElement((element) => element.style.height = `${me.offsetHeight}px`);
      me.lastHeight = me.height;
    }
  }
  addCls(classes) {
    this.updateCls(this.cls.add(classes));
  }
  removeCls(classes) {
    this.updateCls(this.cls.remove(classes));
  }
  toggleCls(classes, add) {
    this.updateCls(this.cls[add ? "add" : "remove"](classes));
  }
  assignCls(classes) {
    this.updateCls(this.cls.assign(classes));
  }
  changeCls(cls) {
    return cls !== null && cls !== void 0 && cls.isDomClassList ? cls : new DomClassList(cls);
  }
  updateCls(cls) {
    this.eachElement((element) => DomHelper.syncClassList(element, cls));
  }
  setAttribute(attribute, value) {
    this.eachElement((element) => element.setAttribute(attribute, value));
  }
  removeAttribute(attribute) {
    this.eachElement((element) => element.removeAttribute(attribute));
  }
  get isFirst() {
    return this.dataIndex === 0;
  }
  get top() {
    return this._top;
  }
  get bottom() {
    return this._top + this._height + this.grid._rowBorderHeight;
  }
  setTop(top, silent) {
    if (this._top !== top) {
      this._top = top;
      this.translateElements(silent);
    }
  }
  setBottom(bottom, silent) {
    this.setTop(bottom - this.offsetHeight, silent);
  }
  translate(top, silent = false) {
    this.setTop(top, silent);
    return top + this.offsetHeight;
  }
  translateElements(silent) {
    const me = this, {
      top,
      _elementsArray
    } = me;
    if (me.lastTop !== top) {
      for (let i = 0, {
        length
      } = _elementsArray; i < length; i++) {
        _elementsArray[i].style.transform = `translate(0,${top}px)`;
      }
      !silent && me.rowManager.trigger("translateRow", {
        row: me
      });
      me.lastTop = top;
    }
  }
  positionElements(silent) {
    const me = this, {
      top,
      _elementsArray
    } = me;
    if (me.lastTop !== top) {
      for (let i = 0, {
        length
      } = _elementsArray; i < length; i++) {
        _elementsArray[i].style.top = `${top}px`;
      }
      !silent && me.rowManager.trigger("translateRow", {
        row: me
      });
      me.lastTop = top;
    }
  }
  offset(offsetTop) {
    let newTop = this._top + offsetTop;
    if (newTop < 0) {
      offsetTop -= newTop;
      newTop = 0;
    }
    this.setTop(newTop);
    return offsetTop;
  }
  render(recordIndex, record, updatingSingleRow = true, batch = false, isExport = false) {
    var _record, _record2, _maxRequestedHeight, _grid$processRowHeigh;
    const me = this, {
      cellContext,
      cls,
      elements,
      cells,
      grid,
      rowManager,
      height: oldHeight,
      _id: oldId
    } = me, rowElData = DomDataStore.get(me._elementsArray[0]), rowHeight = rowManager._rowHeight, {
      store
    } = grid, {
      isTree
    } = store;
    let i = 0, size;
    if (!record && record !== false) {
      record = grid.store.getById(rowElData.id);
      recordIndex = grid.store.indexOf(record);
    }
    if (!record) {
      return;
    }
    const rCls = (_record = record) === null || _record === void 0 ? void 0 : _record.cls, recordCls = rCls ? rCls.isDomClassList ? rCls : new DomClassList(rCls) : null;
    cls.assign({
      "b-grid-row-updating": updatingSingleRow && grid.transitionDuration && !isExport,
      "b-selected": grid.isSelected((_record2 = record) === null || _record2 === void 0 ? void 0 : _record2.id),
      "b-readonly": record.readOnly,
      "b-linked": record.isLinked,
      "b-original": record.hasLinks
    });
    if (me.lastRecordCls) {
      cls.remove(me.lastRecordCls);
    }
    if (recordCls) {
      cls.add(recordCls);
      me.lastRecordCls = Object.assign({}, recordCls);
    } else {
      me.lastRecordCls = null;
    }
    rowManager.trigger("beforeRenderRow", {
      row: me,
      record,
      recordIndex,
      oldId
    });
    grid.beforeRenderRow({
      row: me,
      record,
      recordIndex,
      oldId
    });
    me.updateCls(cls);
    if (updatingSingleRow && grid.transitionDuration && !isExport) {
      grid.setTimeout(() => {
        if (!me.isDestroyed) {
          cls.remove("b-grid-row-updating");
          me.updateCls(cls);
        }
      }, grid.transitionDuration);
    }
    me.id = record.id;
    me.dataIndex = recordIndex;
    const height = !grid.fixedRowHeight && grid.getRowHeight(record) || rowHeight;
    let maxRequestedHeight = me.maxRequestedHeight = null;
    if (isTree) {
      for (const region in elements) {
        const el = elements[region];
        el.id = `${grid.id}-${region}-${me.id}`;
        DomHelper.setAttributes(el, {
          "aria-level": record.childLevel + 1,
          "aria-setsize": record.parent.children.length,
          "aria-posinset": record.parentIndex + 1
        });
        if (record.isExpanded(store)) {
          var _record$children, _record$children2;
          DomHelper.setAttributes(el, {
            "aria-expanded": true,
            "aria-owns": (_record$children = record.children) !== null && _record$children !== void 0 && _record$children.length ? (_record$children2 = record.children) === null || _record$children2 === void 0 ? void 0 : _record$children2.map((r) => `${grid.id}-${region}-${r.id}`).join(" ") : null
          });
        } else {
          if (record.isLeaf) {
            el.removeAttribute("aria-expanded");
          } else {
            el.setAttribute("aria-expanded", false);
          }
          el.removeAttribute("aria-owns");
        }
      }
    }
    cellContext._record = record;
    cellContext._id = record.id;
    cellContext._rowIndex = recordIndex;
    for (i = 0; i < cells.length; i++) {
      cellContext._columnId = cells[i].dataset.columnId;
      cellContext._column = grid.columns.getById(cellContext._columnId);
      cellContext._columnIndex = i;
      cellContext._cell = cells[i];
      cellContext.height = height;
      cellContext.maxRequestedHeight = maxRequestedHeight;
      cellContext.updatingSingleRow = updatingSingleRow;
      size = me.renderCell(cellContext);
      if (!rowManager.fixedRowHeight) {
        if (size.height != null) {
          maxRequestedHeight = Math.max(maxRequestedHeight, size.height);
          if (!size.transient) {
            me.maxRequestedHeight = maxRequestedHeight;
          }
        }
      }
    }
    const useHeight = (_maxRequestedHeight = maxRequestedHeight) !== null && _maxRequestedHeight !== void 0 ? _maxRequestedHeight : height;
    me.height = (_grid$processRowHeigh = grid.processRowHeight(record, useHeight)) !== null && _grid$processRowHeigh !== void 0 ? _grid$processRowHeigh : useHeight;
    me.updateElementsHeight(isExport);
    if (updatingSingleRow && !isExport) {
      if (oldHeight !== me.height) {
        rowManager.translateFromRow(me, batch);
      }
      rowManager.trigger("updateRow", {
        row: me,
        record,
        recordIndex,
        oldId
      });
      rowManager.trigger("renderDone");
    }
    grid.afterRenderRow({
      row: me,
      record,
      recordIndex,
      oldId,
      oldHeight,
      isExport
    });
    rowManager.trigger("renderRow", {
      row: me,
      record,
      recordIndex,
      oldId,
      isExport
    });
    if (oldHeight && me.height !== oldHeight) {
      rowManager.trigger("rowRowHeight", {
        row: me,
        record,
        height: me.height,
        oldHeight
      });
    }
    me.forceInnerHTML = false;
  }
  renderCell(cellContext) {
    var _grid$features, _grid$hasFrameworkRen;
    if (!cellContext.isLocation) {
      cellContext = new Location(cellContext);
    }
    let {
      cell: cellElement,
      record
    } = cellContext;
    const me = this, {
      grid,
      column,
      height,
      maxRequestedHeight,
      updatingSingleRow = true,
      isMeasuring = false
    } = cellContext, cellEdit = (_grid$features = grid.features) === null || _grid$features === void 0 ? void 0 : _grid$features.cellEdit, cellElementData = DomDataStore.get(cellElement), rowElement = cellElementData.rowElement, rowElementData = DomDataStore.get(rowElement);
    if (!record) {
      record = cellContext.record = grid.store.getById(rowElementData.id);
      if (!record) {
        return;
      }
    }
    let cellContent = column.getRawValue(record);
    const dataField = record.fieldMap[column.field], size = {
      configuredHeight: height,
      height: null,
      maxRequestedHeight
    }, cellCls = column.getCellClass(cellContext), rendererData = {
      cellElement,
      dataField,
      rowElement,
      value: cellContent,
      record,
      column,
      size,
      grid,
      row: cellElementData.row,
      updatingSingleRow,
      isMeasuring
    }, useRenderer = column.renderer || column.defaultRenderer;
    grid.beforeRenderCell(rendererData);
    if (rendererData.cellElement !== cellElement) {
      cellElement = rendererData.cellElement;
    }
    DomHelper.syncClassList(cellElement, cellCls);
    let shouldSetContent = true;
    if (useRenderer) {
      cellContent = useRenderer.call(column, rendererData);
      if (cellContent === void 0 && column.alwaysClearCell === false) {
        shouldSetContent = false;
      }
    } else if (dataField) {
      cellContent = dataField.print(cellContent);
    }
    const hasFrameworkRenderer = (_grid$hasFrameworkRen = grid.hasFrameworkRenderer) === null || _grid$hasFrameworkRen === void 0 ? void 0 : _grid$hasFrameworkRen.call(grid, {
      cellContent,
      column
    });
    if (hasFrameworkRenderer && record.isSpecialRow) {
      cellContent = "";
    }
    const frameworkPerformsFullRendering = hasFrameworkRenderer && !column.data.tree && !record.isSpecialRow;
    if (shouldSetContent && !frameworkPerformsFullRendering) {
      var _cellEdit$editorConte;
      let renderTarget = cellElement;
      if (cellEdit !== null && cellEdit !== void 0 && (_cellEdit$editorConte = cellEdit.editorContext) !== null && _cellEdit$editorConte !== void 0 && _cellEdit$editorConte.equals(cellContext) && !cellEdit.editor.isFinishing) {
        renderTarget = me.moveContentFromCell(cellElement, cellEdit.editor.element);
      }
      const hasObjectContent = cellContent != null && typeof cellContent === "object", hasStringContent = typeof cellContent === "string", text = hasObjectContent || cellContent == null ? "" : String(cellContent);
      if (me.forceInnerHTML) {
        renderTarget.innerHTML = "";
        delete renderTarget._content;
        cellElement.lastDomConfig = null;
      }
      if (!hasObjectContent && column.htmlEncode && !column.disableHtmlEncode) {
        if (cellElement._hasHtml) {
          renderTarget.innerText = text;
          cellElement._hasHtml = false;
        } else {
          DomHelper.setInnerText(renderTarget, text);
        }
      } else {
        if (column.autoSyncHtml && (!hasStringContent || DomHelper.getChildElementCount(renderTarget))) {
          if (hasStringContent) {
            DomHelper.sync(text, renderTarget.firstElementChild);
          } else if (hasObjectContent) {
            DomSync.sync({
              domConfig: cellContent,
              targetElement: renderTarget
            });
          }
        } else if (hasObjectContent) {
          DomSync.sync({
            targetElement: renderTarget,
            domConfig: {
              onlyChildren: true,
              children: ArrayHelper.asArray(cellContent)
            }
          });
        } else if (renderTarget._content !== text) {
          renderTarget.innerHTML = renderTarget._content = text;
        }
      }
      if (renderTarget !== cellElement) {
        const {
          firstChild
        } = cellElement;
        for (const node of renderTarget.childNodes) {
          cellElement.insertBefore(node, firstChild);
        }
      }
    }
    if (!record.isSpecialRow) {
      var _grid$processCellCont;
      (_grid$processCellCont = grid.processCellContent) === null || _grid$processCellCont === void 0 ? void 0 : _grid$processCellCont.call(grid, {
        cellElementData,
        rendererData,
        rendererHtml: rendererData.rendererHtml || cellContent
      });
    }
    if (column.autoHeight && size.height == null) {
      cellElement.classList.add("b-measuring-auto-height");
      size.height = Math.max(cellElement.offsetHeight, grid.rowHeight);
      cellElement.classList.remove("b-measuring-auto-height");
    }
    if (!isMeasuring) {
      me.rowManager.trigger("renderCell", rendererData);
    }
    return size;
  }
  moveContentFromCell(cellElement, editorElement) {
    cellContentRange.setStart(cellElement, 0);
    cellContentRange.setEndBefore(editorElement);
    const renderTarget = document.createElement("div");
    renderTarget.appendChild(cellContentRange.extractContents());
    return renderTarget;
  }
};
_defineProperty(Row, "$name", "Row");
Row.initClass();
Row._$name = "Row";
var Exporter = class extends Delayable(Events(Localizable(Base))) {
  static get defaultConfig() {
    return {
      translateURLsToAbsolute: true,
      keepPathName: true,
      filterStyles: (styles) => styles
    };
  }
  pageTpl(data) {
    const {
      title,
      header,
      footer,
      styles,
      htmlClasses,
      bodyStyle,
      bodyClasses = [],
      paperHeight,
      paperWidth,
      html
    } = data;
    bodyClasses.push(`b-${this.constructor.type}`);
    if (DomHelper.scrollBarWidth) {
      bodyClasses.push("b-visible-scrollbar");
    } else {
      bodyClasses.push("b-overlay-scrollbar");
    }
    if (BrowserHelper.isChrome) {
      bodyClasses.push("b-chrome");
    } else if (BrowserHelper.isSafari) {
      bodyClasses.push("b-safari");
    } else if (BrowserHelper.isFirefox) {
      bodyClasses.push("b-firefox");
    }
    return TemplateHelper.tpl`
            <!DOCTYPE html>
            <html class="${htmlClasses}" style="width: ${paperWidth}in; height: ${paperHeight}in;">
                <head>
                    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
                    <title>${title}</title>
                    ${styles.join("")}
                </head>
                <body class="b-export ${bodyClasses.join(" ")}" style="width: ${paperWidth}in; height: ${paperHeight}in; ${bodyStyle}">
                    <div class="b-export-content">
                        ${header && `<div class="b-export-header" style="width: 100%">${header}</div>`}
                        <div class="b-export-body"><div class="b-export-viewport">${html}</div></div>
                        ${footer && `<div class="b-export-footer" style="width: 100%">${footer}</div>`}
                    </div>
                </body>
            </html>`;
  }
  get stylesheets() {
    const me = this;
    if (me._stylesheets) {
      return me._stylesheets;
    }
    const translate = me.translateURLsToAbsolute, origin = globalThis.origin, styleSheetNodes = Array.from(document.querySelectorAll('link[rel="stylesheet"], style')), styles = [];
    styleSheetNodes.forEach((node) => {
      node = node.cloneNode(true);
      if (translate && node.href) {
        let result;
        if (translate === true) {
          result = node.href;
        } else if (this.keepPathName) {
          result = node.href.replace(origin, translate);
        } else {
          result = new URL(node.getAttribute("href"), translate);
        }
        node.setAttribute("href", result);
      }
      let styleText = node.outerHTML;
      if (translate && /style/i.test(node.tagName)) {
        const converter = me.getStyleTagURLConverter(translate);
        styleText = styleText.replace(/url\(['"]?(.+?)['"]?\)/g, converter);
      }
      styles.push(styleText);
    });
    styles.push(`<style>
                body, html {
                    overflow: auto;
                }
                body {
                    position: relative;
                    margin: 0;
                }
            </style>`);
    return me._stylesheets = me.filterStyles(styles);
  }
  set stylesheets(value) {
    this._stylesheets = value ? this.filterStyles(value) : value;
  }
  getStyleTagURLConverter(translate) {
    return function(match, url) {
      let result;
      try {
        let base;
        if (/^#/.test(url)) {
          result = match;
        } else {
          if (translate === true) {
            base = globalThis.location.href;
          } else if (this.keepPathName) {
            base = globalThis.location.href.replace(globalThis.location.origin, translate);
          } else {
            base = translate;
          }
          result = `url('${new URL(url, base).href}')`;
        }
      } catch (e) {
        result = match;
      }
      return result;
    }.bind(this);
  }
  saveState({
    client
  }) {
    this.state = client.state;
  }
  async restoreState({
    client
  }) {
    const promises = [], detachers = /* @__PURE__ */ new Set();
    detachers.add(client.scrollable.ion({
      scroll() {
        promises.push(client.scrollable.await("scrollEnd"));
      }
    }));
    client.eachSubGrid(({
      header,
      scrollable
    }) => {
      detachers.add(scrollable.ion({
        scroll() {
          promises.push(scrollable.await("scrollEnd"));
        }
      }));
      detachers.add(header.scrollable.ion({
        scroll() {
          promises.push(header.scrollable.await("scrollEnd"));
        }
      }));
    });
    client.state = this.state;
    await Promise.all(promises);
    detachers.forEach((fn) => fn());
  }
  beforeExport() {
    this.element = document.createElement("div");
  }
  cloneElement(element, target = this.element, clear = true) {
    if (clear) {
      target.innerHTML = "";
    }
    target.appendChild(element.cloneNode(true));
    DomHelper.removeEachSelector(target, ".b-grid-row,.b-grid-merged-cells-container");
    const maskEl = target.querySelector(".b-gridbase > .b-mask");
    if (maskEl) {
      maskEl.remove();
    }
  }
  createPlaceholder(el, clear = true, config = {}) {
    if (clear) {
      el.innerHTML = "";
    }
    return DomHelper.createElement(Object.assign({
      parent: el,
      id: IdHelper.generateId("export")
    }, config));
  }
  prepareElement({
    client
  }) {
    const {
      tbar,
      bbar
    } = client;
    if (tbar) {
      this.element.querySelector(`#${tbar.id}`).remove();
    }
    if (bbar) {
      this.element.querySelector(`#${bbar.id}`).remove();
    }
  }
  measureElement(html = "") {
    if (html instanceof HTMLElement) {
      html = html.outerHTML;
    }
    const target = DomHelper.createElement({
      parent: document.body,
      style: {
        visibility: "hidden",
        position: "absolute"
      },
      html: `<div style="height: 1px"></div>${html}<div style="height: 1px"></div>`
    });
    const result = target.offsetHeight - 2;
    target.remove();
    return result;
  }
  prepareHTML(html) {
    if (html instanceof HTMLElement) {
      html = html.outerHTML;
    }
    const target = DomHelper.createElement({
      parent: document.body,
      style: {
        visibility: "hidden",
        position: "absolute"
      },
      html
    });
    const elements = target.querySelectorAll("img");
    for (let i = 0, l = elements.length; i < l; i++) {
      elements[i].setAttribute("src", elements[i].src);
    }
    const result = target.innerHTML;
    target.remove();
    return result;
  }
  getVirtualScrollerHeight(client) {
    let result = 0;
    client.eachSubGrid((subGrid) => {
      if (subGrid.overflowingHorizontally) {
        result = DomHelper.scrollBarWidth;
      }
    });
    return result === 0 ? result : result + 1;
  }
  inchToPx(value) {
    return value * 96;
  }
  getScaleValue(base, value) {
    return Math.floor(base * 1e4 / value) / 1e4;
  }
  getVisibleRowsCount(client) {
    const rowManager = client.rowManager, firstVisibleIndex = rowManager.rows.indexOf(rowManager.firstVisibleRow), lastVisibleIndex = rowManager.rows.indexOf(rowManager.lastVisibleRow);
    let result;
    if (firstVisibleIndex !== -1) {
      if (lastVisibleIndex === -1) {
        result = client.store.count - firstVisibleIndex;
      } else {
        result = lastVisibleIndex - firstVisibleIndex + 1;
      }
    } else {
      result = client.store.count;
    }
    return result;
  }
  async export(config) {
    const me = this;
    let pages;
    me.beforeExport();
    me.saveState(config);
    await me.prepareComponent(config);
    try {
      pages = await me.getPages(config);
    } finally {
      await me.restoreComponent(config);
      me.stylesheets = null;
      await new Promise((resolve) => me.requestAnimationFrame(resolve));
      await me.restoreState(config);
    }
    return pages;
  }
  async getPages(config) {
    const generator = this.pagesExtractor(config), pages = [];
    let step;
    while ((step = await generator.next()) && !step.done) {
      pages.push(step.value);
    }
    return pages;
  }
  adjustRowBuffer(client) {
    const {
      contentHeight
    } = this.exportMeta, {
      rowManager
    } = client;
    this.oldRowManagerConfig = {
      prependRowBuffer: rowManager.prependRowBuffer,
      appendRowBuffer: rowManager.appendRowBuffer
    };
    const adjustedRowBuffer = Math.ceil(contentHeight / rowManager.rowOffsetHeight);
    rowManager.prependRowBuffer = adjustedRowBuffer;
    rowManager.appendRowBuffer = adjustedRowBuffer;
    client.renderRows();
    client.rowManager.jumpToPosition(client.scrollable.y);
  }
  restoreRowBuffer(client) {
    client.rowManager.prependRowBuffer = this.oldRowManagerConfig.prependRowBuffer;
    client.rowManager.appendRowBuffer = this.oldRowManagerConfig.appendRowBuffer;
  }
  async prepareComponent(config) {
    const me = this, {
      client,
      columns,
      rowsRange,
      keepRegionSizes,
      enableDirectRendering
    } = config, {
      rowManager
    } = client, exportMeta = me.exportMeta = {
      enableDirectRendering,
      totalWidth: 0,
      totalHeight: 0 - (enableDirectRendering ? 0 : me.getVirtualScrollerHeight(client)),
      subGrids: {}
    };
    client.columns.forEach((column) => {
      if (columns.includes(column.id)) {
        column.show();
      } else {
        column.hide();
      }
    });
    await new Promise((resolve) => client.requestAnimationFrame(resolve));
    if (client.rowManager.rowCount > 0) {
      if (rowsRange === RowsRange.all) {
        exportMeta.firstVisibleDataIndex = rowManager.rows[0].dataIndex;
      } else {
        exportMeta.firstVisibleDataIndex = rowManager.firstVisibleRow.dataIndex;
        config.alignRows = true;
      }
      if (!enableDirectRendering) {
        await client.scrollRowIntoView(client.store.getAt(exportMeta.firstVisibleDataIndex), {
          block: "start"
        });
      }
    }
    const {
      element
    } = me;
    me.cloneElement(client.element);
    me.prepareElement(config);
    let fakeRow;
    if (enableDirectRendering) {
      exportMeta.fakeRow = fakeRow = new Row({
        cls: client.rowCls,
        rowManager: client.rowManager,
        grid: client,
        index: -10,
        dataIndex: -10
      });
    }
    client.eachSubGrid((subGrid) => {
      var _subGrid$splitterElem, _subGrid$header, _subGrid$footer;
      if (fakeRow) {
        subGrid.onAddRow({
          rows: [fakeRow],
          isExport: true
        });
        fakeRow.element.dataset.ownerCmp = client.id;
      }
      const placeHolder = me.createPlaceholder(element.querySelector(`[id="${subGrid.id}"]`), false);
      let width;
      if (keepRegionSizes !== null && keepRegionSizes !== void 0 && keepRegionSizes[subGrid.region]) {
        width = subGrid.element.offsetWidth;
      } else {
        width = subGrid.columns.visibleColumns.reduce((result, column) => {
          if (typeof column.width === "number") {
            result += column.width;
          } else {
            result += (client.hideHeaders ? client.rowManager.rows[0].getCell(column.id) : column.element).offsetWidth;
          }
          return result;
        }, 0);
      }
      exportMeta.totalWidth += width;
      const splitterWidth = ((_subGrid$splitterElem = subGrid.splitterElement) === null || _subGrid$splitterElem === void 0 ? void 0 : _subGrid$splitterElem.offsetWidth) || 0;
      exportMeta.totalWidth += splitterWidth;
      exportMeta.subGrids[subGrid.region] = {
        id: subGrid.id,
        headerId: ((_subGrid$header = subGrid.header) === null || _subGrid$header === void 0 ? void 0 : _subGrid$header.id) || null,
        footerId: ((_subGrid$footer = subGrid.footer) === null || _subGrid$footer === void 0 ? void 0 : _subGrid$footer.id) || null,
        rows: [],
        splitterWidth,
        placeHolder,
        width
      };
    });
  }
  prepareExportElement() {
    const me = this, {
      element,
      exportMeta
    } = me;
    Object.values(exportMeta.subGrids).forEach(({
      width,
      id,
      headerId,
      footerId
    }) => {
      [id, headerId, footerId].forEach((id2) => {
        if (id2) {
          const childElement = element.querySelector(`[id="${id2}"]`);
          if (childElement) {
            childElement.style.width = `${width}px`;
            childElement.style.flex = "";
          }
        }
      });
    });
    return element.innerHTML;
  }
  async restoreComponent(config) {
    if (this.exportMeta.fakeRow) {
      this.exportMeta.fakeRow.destroy();
      delete this.exportMeta.fakeRow;
    }
  }
  async scrollRowIntoView(client, index) {
    await client.scrollRowIntoView(client.store.getAt(index), {
      block: "start"
    });
    await new Promise((resolve) => this.requestAnimationFrame(resolve));
  }
  collectRow(row) {
    const subGrids = this.exportMeta.subGrids, re = /data-owner-cmp=".+?"/;
    Object.entries(row.elements).forEach(([key, value]) => {
      subGrids[key].rows.push([
        value.outerHTML.replace(re, ""),
        row.top,
        row.offsetHeight,
        /* @__PURE__ */ new Map()
      ]);
    });
  }
  renderMergedCells(config, fromIndex, toIndex, rows) {
    const me = this, {
      client
    } = config, {
      subGrids
    } = me.exportMeta, domConfigMap = client.features.mergeCells.buildMergedCellsConfig(fromIndex, toIndex, rows);
    for (const subGridName in subGrids) {
      const subGrid = subGrids[subGridName], target = document.createElement("div");
      DomSync.sync({
        targetElement: target,
        domConfig: {
          children: domConfigMap[subGridName].children
        }
      });
      if (target.childNodes.length) {
        target.childNodes.forEach((child) => {
          const {
            syncId
          } = child.dataset, range = client.features.mergeCells.mergedRanges.find((range2) => {
            var _range$cellElement;
            return ((_range$cellElement = range2.cellElement) === null || _range$cellElement === void 0 ? void 0 : _range$cellElement.parentNode.dataset.syncId) === syncId;
          });
          if (range) {
            child.innerHTML = range.cellElement.outerHTML;
          }
        });
        subGrid.mergedCellsHtml = [target.innerHTML];
      }
    }
  }
};
Exporter.prototype.pagesExtractor = async function* pagesExtractor() {
  throw new Error("Implement this method in a subclass");
};
Exporter._$name = "Exporter";
var MultiPageExporter = class extends Exporter {
  static get $name() {
    return "MultiPageExporter";
  }
  static get type() {
    return "multipage";
  }
  static get title() {
    return this.L("L{multipage}");
  }
  static get exportingPageText() {
    return "L{exportingPage}";
  }
  async stateNextPage({
    client,
    rowsRange,
    enableDirectRendering
  }) {
    const {
      exportMeta
    } = this;
    ++exportMeta.currentPage;
    ++exportMeta.verticalPosition;
    delete exportMeta.lastExportedRowBottom;
    if (exportMeta.verticalPosition >= exportMeta.verticalPages) {
      Object.assign(exportMeta, {
        verticalPosition: 0,
        horizontalPosition: exportMeta.horizontalPosition + 1,
        currentPageTopMargin: 0,
        lastTop: 0,
        lastRowIndex: rowsRange === RowsRange.visible ? client.rowManager.firstVisibleRow.dataIndex : 0
      });
      delete exportMeta.lastRowDataIndex;
      if (!enableDirectRendering) {
        await this.scrollRowIntoView(client, exportMeta.firstVisibleDataIndex, {
          block: "start"
        });
      }
    }
  }
  async prepareComponent(config) {
    await super.prepareComponent(config);
    const me = this, {
      exportMeta
    } = me, {
      client,
      headerTpl,
      footerTpl,
      alignRows,
      rowsRange,
      enableDirectRendering
    } = config, paperFormat = PaperFormat[config.paperFormat], isPortrait = config.orientation === Orientation.portrait, paperWidth = isPortrait ? paperFormat.width : paperFormat.height, paperHeight = isPortrait ? paperFormat.height : paperFormat.width, pageWidth = me.inchToPx(paperWidth), pageHeight = me.inchToPx(paperHeight), onlyVisibleRows = rowsRange === RowsRange.visible, horizontalPages = Math.ceil(exportMeta.totalWidth / pageWidth);
    let contentHeight = pageHeight;
    if (headerTpl) {
      contentHeight -= me.measureElement(headerTpl({
        totalWidth: exportMeta.totalWidth,
        totalPages: -1,
        currentPage: -1
      }));
    }
    if (footerTpl) {
      contentHeight -= me.measureElement(footerTpl({
        totalWidth: exportMeta.totalWidth,
        totalPages: -1,
        currentPage: -1
      }));
    }
    let totalHeight, verticalPages, totalRows = client.store.count;
    if (onlyVisibleRows) {
      totalRows = me.getVisibleRowsCount(client);
      totalHeight = exportMeta.totalHeight + client.headerHeight + client.footerHeight + client.bodyHeight;
    } else {
      totalHeight = exportMeta.totalHeight + client.headerHeight + client.footerHeight + client.scrollable.scrollHeight;
    }
    if (alignRows && !onlyVisibleRows) {
      const rowHeight = client.rowManager.rowOffsetHeight, rowsOnFirstPage = Math.floor((contentHeight - client.headerHeight) / rowHeight), rowsPerPage = Math.floor(contentHeight / rowHeight), remainingRows = totalRows - rowsOnFirstPage;
      verticalPages = 1 + Math.ceil(remainingRows / rowsPerPage);
    } else {
      verticalPages = Math.ceil(totalHeight / contentHeight);
    }
    Object.assign(exportMeta, {
      paperWidth,
      paperHeight,
      pageWidth,
      pageHeight,
      horizontalPages,
      verticalPages,
      totalHeight,
      contentHeight,
      totalRows,
      totalPages: horizontalPages * verticalPages,
      currentPage: 0,
      verticalPosition: 0,
      horizontalPosition: 0,
      currentPageTopMargin: 0,
      lastTop: 0,
      lastRowIndex: onlyVisibleRows ? client.rowManager.firstVisibleRow.dataIndex : 0
    });
    if (!enableDirectRendering) {
      this.adjustRowBuffer(client);
    }
  }
  async restoreComponent(config) {
    await super.restoreComponent(config);
    if (!config.enableDirectRendering) {
      this.restoreRowBuffer(config.client);
    }
  }
  async collectRows(config) {
    const me = this, {
      exportMeta
    } = me, {
      client,
      alignRows,
      rowsRange
    } = config, {
      subGrids,
      currentPageTopMargin,
      verticalPosition,
      contentHeight,
      totalRows,
      lastRowDataIndex
    } = exportMeta, {
      rowManager
    } = client, {
      rows
    } = rowManager, onlyVisible = rowsRange === RowsRange.visible, hasMergeCells = client.hasActiveFeature("mergeCells");
    let remainingHeight, index;
    if (onlyVisible && lastRowDataIndex != null) {
      if (lastRowDataIndex === rows[rows.length - 1].dataIndex) {
        index = rows.length - 1;
      } else {
        index = rows.findIndex((r) => r.dataIndex === lastRowDataIndex);
      }
    } else {
      index = onlyVisible ? rows.findIndex((r) => r.bottom > Math.ceil(client.scrollable.y)) : rows.findIndex((r) => r.bottom + currentPageTopMargin + client.headerHeight > 0);
    }
    const firstRowIndex = index, overflowingHeight = onlyVisible || verticalPosition === 0 ? 0 : rows[index].top + currentPageTopMargin + client.headerHeight;
    remainingHeight = contentHeight - overflowingHeight;
    if (verticalPosition === 0) {
      remainingHeight -= client.headerHeight;
    }
    let lastDataIndex, offset = 0;
    while (remainingHeight > 0) {
      const row = rows[index];
      if (alignRows && remainingHeight < row.offsetHeight) {
        offset = -remainingHeight;
        remainingHeight = 0;
        me.exportMeta.lastExportedRowBottom = rows[index - 1].bottom;
      } else {
        me.collectRow(row);
        remainingHeight -= row.offsetHeight;
        lastDataIndex = row.dataIndex;
        if (++index === rows.length && remainingHeight > 0) {
          remainingHeight = 0;
        } else if (onlyVisible && index - firstRowIndex === totalRows) {
          remainingHeight = 0;
        }
      }
    }
    if (hasMergeCells) {
      for (const subGridName in subGrids) {
        const subGrid = subGrids[subGridName], mergedCells = client.subGrids[subGridName].element.querySelectorAll(`.b-grid-merged-cells`);
        subGrid.mergedCellsHtml = [];
        for (const mergedCell of mergedCells) {
          subGrid.mergedCellsHtml.push(mergedCell.outerHTML);
        }
      }
    }
    const lastRow = rows[index - 1];
    if (lastRow) {
      exportMeta.exactGridHeight = lastRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;
      exportMeta.lastRowDataIndex = lastRow.dataIndex + 1;
    }
    await me.onRowsCollected(rows.slice(firstRowIndex, index), config);
    if (onlyVisible) {
      exportMeta.exactGridHeight -= exportMeta.scrollableTopMargin = client.scrollable.y;
    } else {
      const detacher2 = rowManager.ion({
        offsetRows: ({
          offset: value
        }) => offset += value
      });
      await me.scrollRowIntoView(client, lastDataIndex + 1);
      detacher2();
    }
    return offset;
  }
  async renderRows(config) {
    const me = this, {
      exportMeta
    } = me, {
      client,
      alignRows,
      rowsRange
    } = config, {
      currentPageTopMargin,
      verticalPosition,
      contentHeight,
      totalRows,
      lastRowIndex,
      fakeRow
    } = exportMeta, {
      store
    } = client, hasMergeCells = client.hasActiveFeature("mergeCells"), onlyVisibleRows = rowsRange === RowsRange.visible;
    let index = lastRowIndex, {
      lastTop
    } = exportMeta, remainingHeight;
    const firstRowIndex = index, overflowingHeight = onlyVisibleRows || verticalPosition === 0 ? 0 : lastTop + currentPageTopMargin + client.headerHeight, rows = [];
    remainingHeight = contentHeight - overflowingHeight;
    if (verticalPosition === 0) {
      remainingHeight -= client.headerHeight;
    }
    let lastDataIndex, previousTop, offset = 0;
    while (remainingHeight > 0) {
      fakeRow.render(index, store.getAt(index), true, false, true);
      if (alignRows && remainingHeight < fakeRow.offsetHeight) {
        offset = -remainingHeight;
        remainingHeight = 0;
        me.exportMeta.lastExportedRowBottom = lastTop;
      } else {
        previousTop = lastTop;
        lastDataIndex = index;
        lastTop = fakeRow.translate(lastTop);
        remainingHeight -= fakeRow.offsetHeight;
        me.collectRow(fakeRow);
        rows.push({
          top: fakeRow.top,
          bottom: fakeRow.bottom,
          offsetHeight: fakeRow.offsetHeight,
          dataIndex: fakeRow.dataIndex
        });
        if (++index === store.count && remainingHeight > 0) {
          remainingHeight = 0;
        } else if (onlyVisibleRows && index - firstRowIndex === totalRows) {
          remainingHeight = 0;
        }
      }
    }
    if (hasMergeCells) {
      me.renderMergedCells(config, firstRowIndex, index, rows);
    }
    exportMeta.lastRowIndex = alignRows ? index : lastDataIndex;
    exportMeta.lastTop = alignRows ? lastTop : previousTop;
    if (fakeRow) {
      exportMeta.exactGridHeight = fakeRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;
    }
    await me.onRowsCollected(rows, config);
    return offset;
  }
  async buildPage(config) {
    const me = this, {
      exportMeta
    } = me, {
      client,
      headerTpl,
      footerTpl,
      enableDirectRendering
    } = config, {
      totalWidth,
      totalPages,
      currentPage,
      subGrids
    } = exportMeta;
    Object.values(subGrids).forEach((subGrid) => subGrid.rows = []);
    if (config.rowsRange === RowsRange.all) {
      exportMeta.totalHeight = client.height - client.bodyHeight + client.scrollable.scrollHeight - me.getVirtualScrollerHeight(client);
    }
    let header, footer;
    if (headerTpl) {
      header = me.prepareHTML(headerTpl({
        totalWidth,
        totalPages,
        currentPage
      }));
    }
    if (footerTpl) {
      footer = me.prepareHTML(footerTpl({
        totalWidth,
        totalPages,
        currentPage
      }));
    }
    let offset;
    if (enableDirectRendering) {
      offset = await me.renderRows(config);
    } else {
      offset = await me.collectRows(config);
    }
    const html = me.buildPageHtml(config);
    return {
      html,
      header,
      footer,
      offset
    };
  }
  async onRowsCollected() {
  }
  buildPageHtml() {
    const me = this, {
      subGrids
    } = me.exportMeta;
    let html = me.prepareExportElement();
    Object.values(subGrids).forEach(({
      placeHolder,
      rows,
      mergedCellsHtml
    }) => {
      const placeHolderText = placeHolder.outerHTML;
      let contentHtml = rows.reduce((result, row) => {
        result += row[0];
        return result;
      }, "");
      if (mergedCellsHtml !== null && mergedCellsHtml !== void 0 && mergedCellsHtml.length) {
        contentHtml += `<div class="b-grid-merged-cells-container">${mergedCellsHtml.join("")}</div>`;
      }
      html = html.replace(placeHolderText, contentHtml);
    });
    return html;
  }
  prepareExportElement() {
    const me = this, {
      element,
      exportMeta
    } = me;
    if (exportMeta.scrollableTopMargin) {
      element.querySelector(".b-grid-vertical-scroller").style.marginTop = `-${exportMeta.scrollableTopMargin}px`;
    }
    return super.prepareExportElement();
  }
};
MultiPageExporter.prototype.pagesExtractor = async function* pagesExtractor2(config) {
  const me = this, {
    exportMeta,
    stylesheets
  } = me, {
    totalWidth,
    totalPages,
    paperWidth,
    paperHeight,
    contentHeight
  } = exportMeta;
  let currentPage;
  while ((currentPage = exportMeta.currentPage) < totalPages) {
    me.trigger("exportStep", {
      text: me.L(MultiPageExporter.exportingPageText, {
        currentPage,
        totalPages
      }),
      progress: Math.round((currentPage + 1) / totalPages * 90)
    });
    const {
      html,
      header,
      footer,
      offset
    } = await me.buildPage(config);
    const styles = [...stylesheets, `
                <style>
                    #${config.client.id} {
                        height: ${exportMeta.exactGridHeight}px !important;
                        width: ${totalWidth}px !important;
                    }
                    .b-export-body .b-export-viewport {
                        margin-inline-start : ${-paperWidth * exportMeta.horizontalPosition}in;
                        margin-top  : ${exportMeta.currentPageTopMargin}px;
                    }
                </style>
            `];
    exportMeta.currentPageTopMargin -= contentHeight + offset;
    await me.stateNextPage(config);
    yield {
      html: me.pageTpl({
        html,
        header,
        footer,
        styles,
        paperWidth,
        paperHeight
      })
    };
  }
};
MultiPageExporter._$name = "MultiPageExporter";
var MultiPageVerticalExporter = class extends Exporter {
  static get $name() {
    return "MultiPageVerticalExporter";
  }
  static get type() {
    return "multipagevertical";
  }
  static get title() {
    return this.L("L{multipagevertical}");
  }
  static get exportingPageText() {
    return "L{exportingPage}";
  }
  async stateNextPage({
    client
  }) {
    const {
      exportMeta
    } = this, {
      totalRows,
      processedRows,
      totalPages
    } = exportMeta;
    ++exportMeta.currentPage;
    ++exportMeta.verticalPosition;
    if (exportMeta.currentPage === totalPages && processedRows.size !== totalRows) {
      ++exportMeta.totalPages;
      ++exportMeta.verticalPages;
    }
  }
  estimateTotalPages(config) {
    const me = this, {
      exportMeta
    } = me, {
      client,
      headerTpl,
      footerTpl,
      alignRows,
      rowsRange,
      repeatHeader,
      enableDirectRendering
    } = config, {
      pageWidth,
      pageHeight,
      totalWidth
    } = exportMeta, scale = me.getScaleValue(pageWidth, totalWidth);
    let totalHeight = 0 - me.getVirtualScrollerHeight(client) + client.height - client.bodyElement.offsetHeight + client.scrollable.scrollHeight, contentHeight = pageHeight / scale, totalRows = client.store.count, initialScroll = 0, rowsHeight = totalHeight, verticalPages;
    if (headerTpl) {
      contentHeight -= me.measureElement(headerTpl({
        totalWidth,
        totalPages: -1,
        currentPage: -1
      }));
    }
    if (footerTpl) {
      contentHeight -= me.measureElement(footerTpl({
        totalWidth,
        totalPages: -1,
        currentPage: -1
      }));
    }
    if (repeatHeader) {
      contentHeight -= client.headerHeight + client.footerHeight;
      totalHeight -= client.headerHeight + client.footerHeight;
    }
    if (rowsRange === RowsRange.visible) {
      const rowManager = client.rowManager, firstRow = rowManager.firstVisibleRow, lastRow = rowManager.lastVisibleRow;
      if (!enableDirectRendering) {
        initialScroll = firstRow.top;
      }
      totalRows = me.getVisibleRowsCount(client);
      if (enableDirectRendering) {
        totalHeight = client.headerHeight + client.footerHeight + lastRow.bottom - firstRow.top;
        rowsHeight = lastRow.bottom - firstRow.top;
      } else {
        rowsHeight = totalHeight = totalHeight - client.scrollable.scrollHeight + lastRow.bottom - firstRow.top;
      }
      exportMeta.lastRowIndex = firstRow.dataIndex;
      exportMeta.finishRowIndex = lastRow.dataIndex;
    } else {
      exportMeta.finishRowIndex = client.store.count - 1;
    }
    if (alignRows && !repeatHeader && rowsRange !== RowsRange.visible) {
      const rowHeight = client.rowManager.rowOffsetHeight, rowsOnFirstPage = Math.floor((contentHeight - client.headerHeight) / rowHeight), rowsPerPage = Math.floor(contentHeight / rowHeight), remainingRows = totalRows - rowsOnFirstPage;
      verticalPages = 1 + Math.ceil(remainingRows / rowsPerPage);
    } else {
      verticalPages = Math.ceil(rowsHeight / contentHeight);
    }
    Object.assign(exportMeta, {
      scale,
      contentHeight,
      totalRows,
      totalHeight,
      verticalPages,
      initialScroll,
      horizontalPages: 1,
      totalPages: verticalPages
    });
  }
  async prepareComponent(config) {
    await super.prepareComponent(config);
    const me = this, {
      exportMeta
    } = me, {
      client
    } = config, paperFormat = PaperFormat[config.paperFormat], isPortrait = config.orientation === Orientation.portrait, paperWidth = isPortrait ? paperFormat.width : paperFormat.height, paperHeight = isPortrait ? paperFormat.height : paperFormat.width, pageWidth = me.inchToPx(paperWidth), pageHeight = me.inchToPx(paperHeight), horizontalPages = 1;
    Object.assign(exportMeta, {
      paperWidth,
      paperHeight,
      pageWidth,
      pageHeight,
      horizontalPages,
      currentPage: 0,
      verticalPosition: 0,
      horizontalPosition: 0,
      currentPageTopMargin: 0,
      lastTop: 0,
      lastRowIndex: 0,
      processedRows: /* @__PURE__ */ new Set()
    });
    me.estimateTotalPages(config);
    if (!config.enableDirectRendering) {
      me.adjustRowBuffer(client);
    }
  }
  async restoreComponent(config) {
    await super.restoreComponent(config);
    if (!config.enableDirectRendering) {
      this.restoreRowBuffer(config.client);
    }
  }
  async collectRows(config) {
    const me = this, {
      exportMeta
    } = me, {
      client,
      alignRows,
      repeatHeader
    } = config, {
      subGrids,
      currentPageTopMargin,
      verticalPosition,
      totalRows,
      contentHeight
    } = exportMeta, clientHeaderHeight = repeatHeader ? 0 : client.headerHeight, {
      rowManager
    } = client, {
      rows
    } = rowManager, onlyVisibleRows = config.rowsRange === RowsRange.visible, hasMergeCells = client.hasActiveFeature("mergeCells");
    let index = onlyVisibleRows ? rows.findIndex((r) => r.bottom > client.scrollable.y) : rows.findIndex((r) => r.bottom + currentPageTopMargin + clientHeaderHeight > 0), remainingHeight;
    const firstRowIndex = index, overflowingHeight = verticalPosition === 0 ? 0 : rows[index].top + currentPageTopMargin + clientHeaderHeight;
    remainingHeight = contentHeight - overflowingHeight;
    if (verticalPosition === 0) {
      remainingHeight -= clientHeaderHeight;
    }
    let lastDataIndex, offset = 0;
    while (remainingHeight > 0) {
      const row = rows[index];
      if (alignRows && remainingHeight < row.offsetHeight) {
        offset = -remainingHeight;
        remainingHeight = 0;
      } else {
        me.collectRow(row);
        remainingHeight -= row.offsetHeight;
        if (remainingHeight > 0) {
          exportMeta.processedRows.add(row.dataIndex);
        }
        lastDataIndex = row.dataIndex;
        if (++index === rows.length && remainingHeight > 0) {
          remainingHeight = 0;
        } else if (onlyVisibleRows && index - firstRowIndex === totalRows) {
          remainingHeight = 0;
        }
      }
    }
    if (hasMergeCells) {
      for (const subGridName in subGrids) {
        const subGrid = subGrids[subGridName], mergedCells = client.subGrids[subGridName].element.querySelectorAll(`.b-grid-merged-cells`);
        subGrid.mergedCellsHtml = [];
        for (const mergedCell of mergedCells) {
          subGrid.mergedCellsHtml.push(mergedCell.outerHTML);
        }
      }
    }
    const lastRow = rows[index - 1];
    if (lastRow) {
      exportMeta.exactGridHeight = lastRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;
    }
    await me.onRowsCollected(rows.slice(firstRowIndex, index), config);
    if (onlyVisibleRows) {
      exportMeta.scrollableTopMargin = client.scrollable.y;
    } else {
      const detacher2 = rowManager.ion({
        offsetRows: ({
          offset: value
        }) => offset += value
      });
      await me.scrollRowIntoView(client, lastDataIndex + 1);
      detacher2();
    }
    return offset;
  }
  async renderRows(config) {
    const me = this, {
      exportMeta
    } = me, {
      client,
      alignRows,
      repeatHeader
    } = config, {
      currentPageTopMargin,
      verticalPosition,
      totalRows,
      contentHeight,
      lastRowIndex,
      finishRowIndex,
      fakeRow
    } = exportMeta, clientHeaderHeight = repeatHeader ? 0 : client.headerHeight, {
      store
    } = client, hasMergeCells = client.hasActiveFeature("mergeCells"), onlyVisibleRows = config.rowsRange === RowsRange.visible;
    let index = lastRowIndex, {
      lastTop
    } = exportMeta, remainingHeight;
    const firstRowIndex = index, overflowingHeight = verticalPosition === 0 ? 0 : lastTop + currentPageTopMargin + clientHeaderHeight, rows = [];
    remainingHeight = contentHeight - overflowingHeight;
    if (verticalPosition === 0) {
      remainingHeight -= clientHeaderHeight;
    }
    let lastDataIndex, nextPageTop, offset = 0;
    while (remainingHeight > 0) {
      fakeRow.render(index, store.getAt(index), true, false, true);
      if (alignRows && remainingHeight < fakeRow.offsetHeight) {
        offset = -remainingHeight;
        remainingHeight = 0;
      } else {
        nextPageTop = lastTop;
        lastDataIndex = index;
        lastTop = fakeRow.translate(lastTop);
        remainingHeight -= fakeRow.offsetHeight;
        me.collectRow(fakeRow);
        rows.push({
          top: fakeRow.top,
          bottom: fakeRow.bottom,
          offsetHeight: fakeRow.offsetHeight,
          dataIndex: fakeRow.dataIndex
        });
        if (remainingHeight > 0) {
          exportMeta.processedRows.add(index);
        }
        if (index === finishRowIndex) {
          remainingHeight = 0;
        } else if (++index - firstRowIndex === totalRows && onlyVisibleRows) {
          remainingHeight = 0;
        }
      }
    }
    if (hasMergeCells) {
      me.renderMergedCells(config, firstRowIndex, index, rows);
    }
    exportMeta.lastRowIndex = lastDataIndex;
    exportMeta.lastTop = nextPageTop;
    if (fakeRow) {
      exportMeta.exactGridHeight = fakeRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;
    }
    await me.onRowsCollected(rows, config);
    return offset;
  }
  async buildPage(config) {
    const me = this, {
      exportMeta
    } = me, {
      client,
      headerTpl,
      footerTpl,
      enableDirectRendering
    } = config, {
      totalWidth,
      totalPages,
      currentPage,
      subGrids
    } = exportMeta;
    Object.values(subGrids).forEach((subGrid) => subGrid.rows = []);
    if (config.rowsRange === RowsRange.all) {
      exportMeta.totalHeight = client.headerHeight + client.footerHeight + client.scrollable.scrollHeight;
      if (!enableDirectRendering) {
        exportMeta.totalHeight -= me.getVirtualScrollerHeight(client);
      }
    }
    let header, footer, offset;
    if (headerTpl) {
      header = me.prepareHTML(headerTpl({
        totalWidth,
        totalPages,
        currentPage
      }));
    }
    if (footerTpl) {
      footer = me.prepareHTML(footerTpl({
        totalWidth,
        totalPages,
        currentPage
      }));
    }
    if (enableDirectRendering) {
      offset = await me.renderRows(config);
    } else {
      offset = await me.collectRows(config);
    }
    const html = me.buildPageHtml(config);
    return {
      html,
      header,
      footer,
      offset
    };
  }
  async onRowsCollected() {
  }
  buildPageHtml() {
    const me = this, {
      subGrids
    } = me.exportMeta;
    let html = me.prepareExportElement();
    Object.values(subGrids).forEach(({
      placeHolder,
      rows,
      mergedCellsHtml
    }) => {
      const placeHolderText = placeHolder.outerHTML;
      let contentHtml = rows.reduce((result, row) => {
        result += row[0];
        return result;
      }, "");
      if (mergedCellsHtml !== null && mergedCellsHtml !== void 0 && mergedCellsHtml.length) {
        contentHtml += `<div class="b-grid-merged-cells-container">${mergedCellsHtml.join("")}</div>`;
      }
      html = html.replace(placeHolderText, contentHtml);
    });
    return html;
  }
};
MultiPageVerticalExporter.prototype.pagesExtractor = async function* pagesExtractor3(config) {
  const me = this, {
    exportMeta,
    stylesheets
  } = me, {
    totalWidth,
    paperWidth,
    paperHeight,
    contentHeight,
    scale,
    initialScroll
  } = exportMeta;
  let {
    totalPages
  } = exportMeta, currentPage;
  while ((currentPage = exportMeta.currentPage) < totalPages) {
    me.trigger("exportStep", {
      text: me.L(MultiPageVerticalExporter.exportingPageText, {
        currentPage,
        totalPages
      }),
      progress: Math.round((currentPage + 1) / totalPages * 90)
    });
    const {
      html,
      header,
      footer,
      offset
    } = await me.buildPage(config);
    const styles = [...stylesheets, `
                <style>
                    #${config.client.id} {
                        width: ${totalWidth}px !important;
                    }
                    .b-export .b-export-content {
                        transform: scale(${scale});
                        transform-origin: top left;
                        height: auto;
                    }
                </style>
            `];
    if (config.repeatHeader) {
      const gridHeight = exportMeta.exactGridHeight ? `${exportMeta.exactGridHeight + exportMeta.currentPageTopMargin}px` : "100%";
      styles.push(`
                <style>
                    #${config.client.id} {
                        height: ${gridHeight} !important;
                    }
                    .b-export .b-export-content {
                        height: ${100 / scale}%;
                    }
                    .b-export-body {
                        height: 100%;
                        display: flex;
                    }
                    .b-export-viewport {
                        height: 100%;
                    }
                    .b-grid-vertical-scroller {
                        margin-top: ${exportMeta.currentPageTopMargin - initialScroll}px;
                    }
                </style>
                `);
    } else {
      const gridHeight = exportMeta.exactGridHeight || contentHeight - exportMeta.currentPageTopMargin;
      styles.push(`
                <style>
                    #${config.client.id} {
                        height: ${gridHeight}px !important;
                    }
                    .b-export-body {
                        overflow: hidden;
                    }
                    .b-export .b-export-content {
                        height: ${100 / scale}%;
                    }
                    .b-export-body .b-export-viewport {
                        margin-top: ${exportMeta.currentPageTopMargin}px;
                    }
                    .b-grid-vertical-scroller {
                        margin-top: -${initialScroll}px;
                    }
                </style>
                `);
    }
    exportMeta.currentPageTopMargin -= contentHeight + offset;
    await me.stateNextPage(config);
    ({
      totalPages
    } = exportMeta);
    yield {
      html: me.pageTpl({
        html,
        header,
        footer,
        styles,
        paperWidth,
        paperHeight
      })
    };
  }
};
MultiPageVerticalExporter._$name = "MultiPageVerticalExporter";
var SinglePageExporter = class extends Exporter {
  static get $name() {
    return "SinglePageExporter";
  }
  static get type() {
    return "singlepage";
  }
  static get title() {
    return this.localize("L{singlepage}");
  }
  static get defaultConfig() {
    return {
      centerContentHorizontally: false
    };
  }
  async prepareComponent(config) {
    await super.prepareComponent(config);
    Object.assign(this.exportMeta, {
      verticalPages: 1,
      horizontalPages: 1,
      totalPages: 1,
      currentPage: 0,
      verticalPosition: 0,
      horizontalPosition: 0
    });
  }
  async onRowsCollected() {
  }
  positionRows(rows, config) {
    if (config.enableDirectRendering) {
      return rows.map((r) => r[0]);
    } else {
      let currentTop = 0;
      return rows.map(([html, , height]) => {
        const result = html.replace(/translate\(\d+px, \d+px\)/, `translate(0px, ${currentTop}px)`);
        currentTop += height;
        return result;
      });
    }
  }
  async collectRows(config) {
    const me = this, {
      client
    } = config, {
      rowManager,
      store
    } = client, hasMergeCells = client.hasActiveFeature("mergeCells"), {
      subGrids
    } = me.exportMeta, totalRows = config.rowsRange === RowsRange.visible && store.count ? me.getVisibleRowsCount(client) : store.count;
    let {
      totalHeight
    } = me.exportMeta, processedRows = 0, lastDataIndex = -1;
    if (rowManager.rows.length > 0) {
      if (config.rowsRange === RowsRange.visible) {
        lastDataIndex = rowManager.firstVisibleRow.dataIndex - 1;
      }
      if (hasMergeCells) {
        for (const subGrid of Object.values(subGrids)) {
          subGrid.mergedCellsHtml = [];
        }
      }
      while (processedRows < totalRows) {
        const rows = rowManager.rows, lastRow = rows[rows.length - 1], lastProcessedRowIndex = processedRows;
        rows.forEach((row) => {
          if (row.dataIndex > lastDataIndex && processedRows < totalRows) {
            ++processedRows;
            totalHeight += row.offsetHeight;
            me.collectRow(row);
          }
        });
        if (hasMergeCells) {
          for (const subGridName in subGrids) {
            const subGrid = subGrids[subGridName], mergedCells = client.subGrids[subGridName].element.querySelectorAll(`.b-grid-merged-cells`);
            for (const mergedCell of mergedCells) {
              subGrid.mergedCellsHtml.push(mergedCell.outerHTML);
            }
          }
        }
        const firstNewRowIndex = rows.findIndex((r) => r.dataIndex === lastDataIndex + 1), lastNewRowIndex = firstNewRowIndex + (processedRows - lastProcessedRowIndex);
        await me.onRowsCollected(rows.slice(firstNewRowIndex, lastNewRowIndex), config);
        if (processedRows < totalRows) {
          lastDataIndex = lastRow.dataIndex;
          await me.scrollRowIntoView(client, lastDataIndex + 1);
        }
      }
    }
    return totalHeight;
  }
  async renderRows(config) {
    const me = this, {
      client,
      rowsRange
    } = config, {
      rowManager,
      store
    } = client, hasMergeCells = client.hasActiveFeature("mergeCells"), onlyVisibleRows = rowsRange === RowsRange.visible;
    let {
      totalHeight
    } = me.exportMeta;
    if (store.count) {
      const {
        fakeRow
      } = me.exportMeta, {
        firstVisibleRow
      } = rowManager, fromIndex = onlyVisibleRows ? firstVisibleRow.dataIndex : 0, toIndex = onlyVisibleRows ? rowManager.lastVisibleRow.dataIndex : store.count - 1, rows = [];
      let top = 0;
      if (fakeRow.cells.length) {
        for (let i = fromIndex; i <= toIndex; i++) {
          fakeRow.render(i, store.getAt(i), true, false, true);
          top = fakeRow.translate(top);
          me.collectRow(fakeRow);
          rows.push({
            top: fakeRow.top,
            bottom: fakeRow.bottom,
            offsetHeight: fakeRow.offsetHeight,
            dataIndex: fakeRow.dataIndex
          });
        }
        await me.onRowsCollected(rows, config);
      }
      totalHeight += top;
      if (hasMergeCells) {
        me.renderMergedCells(config, fromIndex, toIndex, rows);
      }
    }
    return totalHeight;
  }
  buildPageHtml(config) {
    const me = this, {
      subGrids
    } = me.exportMeta;
    let html = me.prepareExportElement();
    Object.values(subGrids).forEach(({
      placeHolder,
      rows,
      mergedCellsHtml
    }) => {
      const placeHolderText = placeHolder.outerHTML;
      let contentHtml = me.positionRows(rows, config).join("");
      if (mergedCellsHtml !== null && mergedCellsHtml !== void 0 && mergedCellsHtml.length) {
        contentHtml += `<div class="b-grid-merged-cells-container">${mergedCellsHtml.join("")}</div>`;
      }
      html = html.replace(placeHolderText, contentHtml);
    });
    return html;
  }
};
SinglePageExporter.prototype.pagesExtractor = async function* pagesExtractor4(config) {
  const me = this, {
    client
  } = config, {
    totalWidth
  } = me.exportMeta, styles = me.stylesheets, portrait = config.orientation === Orientation.portrait, paperFormat = PaperFormat[config.paperFormat], paperWidth = portrait ? paperFormat.width : paperFormat.height, paperHeight = portrait ? paperFormat.height : paperFormat.width;
  let totalHeight, header, footer;
  if (config.enableDirectRendering) {
    totalHeight = await me.renderRows(config);
    totalHeight += client.headerHeight + client.footerHeight;
  } else {
    totalHeight = await me.collectRows(config);
    totalHeight += client.height - client.bodyHeight;
  }
  const html = me.buildPageHtml(config);
  const totalClientHeight = totalHeight;
  if (config.headerTpl) {
    header = me.prepareHTML(config.headerTpl({
      totalWidth
    }));
    const height = me.measureElement(header);
    totalHeight += height;
  }
  if (config.footerTpl) {
    footer = me.prepareHTML(config.footerTpl({
      totalWidth
    }));
    const height = me.measureElement(footer);
    totalHeight += height;
  }
  const widthScale = Math.min(1, me.getScaleValue(me.inchToPx(paperWidth), totalWidth)), heightScale = Math.min(1, me.getScaleValue(me.inchToPx(paperHeight), totalHeight)), scale = Math.min(widthScale, heightScale);
  styles.push(`<style>
                #${client.id} {
                    height: ${totalClientHeight}px !important;
                    width: ${totalWidth}px !important;
                }
                .b-export-content {
                    ${me.centerContentHorizontally ? "left: 50%;" : ""}
                    transform: scale(${scale}) ${me.centerContentHorizontally ? "translateX(-50%)" : ""};
                    transform-origin: top left;
                    height: ${scale === 1 ? "inherit" : "auto !important"};
                }
            </style>`);
  if (BrowserHelper.isIE11) {
    styles.push(`<style>
                .b-export-body {
                   min-height: ${totalClientHeight}px !important;
                }
         </style>`);
  }
  yield {
    html: me.pageTpl({
      html,
      header,
      footer,
      styles,
      paperWidth,
      paperHeight
    })
  };
};
SinglePageExporter._$name = "SinglePageExporter";
var PdfExport = class extends InstancePlugin {
  static get $name() {
    return "PdfExport";
  }
  static get configurable() {
    return {
      dialogClass: ExportDialog,
      exportServer: void 0,
      exportDialog: {
        value: true,
        $config: ["lazy"]
      },
      fileName: null,
      fileFormat: "pdf",
      clientURL: null,
      paperFormat: "A4",
      orientation: "portrait",
      rowsRange: "all",
      alignRows: false,
      repeatHeader: false,
      keepRegionSizes: null,
      pagesPerRequest: 0,
      exporterConfig: null,
      exporterType: "singlepage",
      exporters: [SinglePageExporter, MultiPageExporter, MultiPageVerticalExporter],
      translateURLsToAbsolute: true,
      keepPathName: true,
      openAfterExport: true,
      sendAsBinary: false,
      openInNewTab: false,
      headerTpl: null,
      footerTpl: null,
      fetchOptions: null,
      exportMask: "L{Generating pages}",
      exportProgressMask: "L{Waiting for response from server}",
      showErrorToast: true,
      localizableProperties: ["exportMask", "exportProgressMask"],
      filterStyles: (styles) => styles,
      enableDirectRendering: true
    };
  }
  updateEnableDirectRendering(value) {
    if (!value) {
      VersionHelper.deprecate("Grid", "6.0.0", "Indirect rendering is deprecated");
    }
  }
  doDestroy() {
    var _this$exportDialog;
    (_this$exportDialog = this.exportDialog) === null || _this$exportDialog === void 0 ? void 0 : _this$exportDialog.destroy();
    this.exportersMap.forEach((exporter) => exporter.destroy());
    super.doDestroy();
  }
  get currentExportPromise() {
    return this._currentExportPromise;
  }
  set currentExportPromise(value) {
    this._currentExportPromise = value;
  }
  get exportersMap() {
    return this._exportersMap || (this._exportersMap = /* @__PURE__ */ new Map());
  }
  getExporter(config = {}) {
    const me = this, {
      exportersMap
    } = me, {
      type
    } = config;
    let exporter;
    if (exportersMap.has(type)) {
      exporter = exportersMap.get(type);
      Object.assign(exporter, config);
    } else {
      const exporterClass = this.exporters.find((cls) => cls.type === type);
      if (!exporterClass) {
        throw new Error(`Exporter type ${type} is not found. Make sure you've configured it`);
      }
      config = ObjectHelper.clone(config);
      delete config.type;
      exporter = new exporterClass(config);
      exporter.relayAll(me);
      exportersMap.set(type, exporter);
    }
    return exporter;
  }
  buildRequest(pages, config) {
    return {
      html: JSON.stringify(pages),
      fileFormat: config.fileFormat,
      format: config.paperFormat,
      orientation: config.orientation
    };
  }
  buildExportConfig(config = {}) {
    const me = this, {
      client,
      exportServer,
      clientURL,
      fileFormat,
      fileName,
      paperFormat,
      rowsRange,
      alignRows,
      repeatHeader,
      keepRegionSizes,
      orientation,
      translateURLsToAbsolute,
      keepPathName,
      sendAsBinary,
      headerTpl,
      footerTpl,
      filterStyles,
      enableDirectRendering
    } = me;
    if (!config.columns) {
      config.columns = client.columns.visibleColumns.filter((column) => column.exportable).map((column) => column.id);
    }
    const result = ObjectHelper.assign({
      client,
      exportServer,
      clientURL,
      fileFormat,
      paperFormat,
      rowsRange,
      alignRows,
      repeatHeader,
      keepRegionSizes,
      orientation,
      translateURLsToAbsolute,
      keepPathName,
      sendAsBinary,
      headerTpl,
      footerTpl,
      enableDirectRendering,
      exporterType: me.exporterType,
      fileName: fileName || client.$$name
    }, config);
    result.columns = config.columns.slice();
    if (result.exporterType !== "multipagevertical") {
      result.repeatHeader = false;
    }
    if (!("alignRows" in config) && config.repeatHeader) {
      result.alignRows = true;
    }
    if (!("keepRegionSizes" in config) && !result.keepRegionSizes) {
      const collapsed = [], keepRegionSizes2 = {};
      client.eachSubGrid((s) => s.collapsed && collapsed.push(s.region));
      if (collapsed.length) {
        client.eachSubGrid((s) => {
          if (!collapsed.includes(s.region)) {
            keepRegionSizes2[s.region] = true;
          }
        });
        result.keepRegionSizes = keepRegionSizes2;
      }
    }
    result.exporterConfig = ObjectHelper.assign({
      type: result.exporterType,
      translateURLsToAbsolute: result.translateURLsToAbsolute,
      keepPathName: result.keepPathName,
      filterStyles
    }, result.exporterConfig || {});
    delete result.exporterType;
    delete result.translateURLsToAbsolute;
    delete result.keepPathName;
    return result;
  }
  async export(config = {}) {
    const me = this, {
      client,
      pagesPerRequest
    } = me;
    config = me.buildExportConfig(config);
    let result;
    if (client.trigger("beforePdfExport", {
      config
    }) !== false) {
      client.isExporting = true;
      client.mask(me.exportMask);
      try {
        const exporter = me.getExporter(config.exporterConfig);
        if (pagesPerRequest === 0) {
          var _me$exportDialog;
          const pages = await exporter.export(config);
          if (me.isDestroying) {
            return;
          }
          (_me$exportDialog = me.exportDialog) === null || _me$exportDialog === void 0 ? void 0 : _me$exportDialog.close();
          client.unmask();
          me.trigger("exportStep", {
            progress: 90,
            text: me.exportProgressMask,
            contentGenerated: true
          });
          const responsePromise = me.receiveExportContent(pages, config);
          me.toast = me.showLoadingToast(responsePromise);
          const response = await responsePromise;
          result = {
            response
          };
          await me.processExportContent(response, config);
        }
      } catch (error) {
        if (error instanceof Response) {
          result = {
            response: error
          };
        } else {
          result = {
            error
          };
        }
        throw error;
      } finally {
        if (me.toast && !me.toast.isDestroying) {
          me.toast.hide();
        }
        if (!me.isDestroying) {
          var _me$exportDialog2;
          (_me$exportDialog2 = me.exportDialog) === null || _me$exportDialog2 === void 0 ? void 0 : _me$exportDialog2.close();
          client.unmask();
          if (me.showErrorToast) {
            if (result.error) {
              if (result.error.name !== "AbortError") {
                Toast.show({
                  html: me.L("L{Export failed}"),
                  rootElement: me.rootElement
                });
              }
            } else if (!result.response.ok) {
              Toast.show({
                html: me.L("L{Server error}"),
                rootElement: me.rootElement
              });
            }
          }
          client.trigger("pdfExport", result);
          client.isExporting = false;
        }
      }
    }
    return result;
  }
  receiveExportContent(pages, config) {
    return AjaxHelper.fetch(config.exportServer, Object.assign({
      method: "POST",
      credentials: "omit",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        html: pages,
        orientation: config.orientation,
        format: config.paperFormat,
        fileFormat: config.fileFormat,
        fileName: config.fileName,
        clientURL: config.clientURL,
        sendAsBinary: config.sendAsBinary
      })
    }, this.fetchOptions));
  }
  async processExportContent(response, config) {
    const me = this;
    if (response.ok && me.openAfterExport) {
      response = response.clone();
      const contentType = response.headers.get("content-type");
      if (contentType.match(/application\/octet-stream/)) {
        const MIMEType = FileMIMEType[config.fileFormat], objectURL = await me.responseBlobToObjectURL(response, MIMEType), link = me.getDownloadLink(config.fileName, objectURL);
        link.click();
      } else if (contentType.match(/application\/json/)) {
        const responseJSON = await response.json();
        if (responseJSON.success) {
          const link = me.getDownloadLink(config.fileName, responseJSON.url);
          link.click();
        } else {
          Toast.show({
            html: responseJSON.msg,
            rootElement: this.rootElement
          });
        }
      }
    }
  }
  async responseBlobToObjectURL(response, mimeType) {
    const blob = await response.blob();
    return URL.createObjectURL(blob.slice(0, blob.size, mimeType));
  }
  getDownloadLink(name, href) {
    const link = document.createElement("a");
    link.download = name;
    link.href = href;
    if (this.openInNewTab) {
      link.target = "_blank";
    }
    return link;
  }
  get defaultExportDialogConfig() {
    return ObjectHelper.copyProperties({}, this, ["client", "exporters", "exporterType", "orientation", "fileFormat", "paperFormat", "alignRows", "rowsRange", "repeatHeader"]);
  }
  changeExportDialog(exportDialog, oldExportDialog) {
    const me = this;
    oldExportDialog === null || oldExportDialog === void 0 ? void 0 : oldExportDialog.destroy();
    if (exportDialog) {
      const config = me.dialogClass.mergeConfigs({
        rootElement: me.rootElement,
        client: me.client,
        items: {
          rowsRangeField: {
            value: me.rowsRange
          },
          exporterTypeField: {
            value: me.exporterType
          },
          orientationField: {
            value: me.orientation
          },
          paperFormatField: {
            value: me.paperFormat
          },
          repeatHeaderField: {
            value: me.repeatHeader
          },
          fileFormatField: {
            value: me.fileFormat
          },
          alignRowsField: {
            checked: me.alignRows
          }
        }
      }, me.defaultExportDialogConfig, exportDialog);
      exportDialog = me.dialogClass.new(config);
      exportDialog.ion({
        export: me.onExportButtonClick,
        thisObj: me
      });
    }
    return exportDialog;
  }
  async showExportDialog() {
    return this.exportDialog.show();
  }
  onExportButtonClick({
    values
  }) {
    const me = this, dialogMask = me.exportDialog.mask({
      progress: 0,
      maxProgress: 100,
      text: me.exportMask
    });
    const detacher2 = me.ion({
      exportstep({
        progress,
        text,
        contentGenerated
      }) {
        if (contentGenerated) {
          me.exportDialog.unmask();
          detacher2();
        } else {
          dialogMask.progress = progress;
          if (text != null) {
            dialogMask.text = text;
          }
        }
      }
    });
    me.currentExportPromise = me.export(values);
    me.currentExportPromise.catch(() => {
    }).finally(() => {
      var _me$exportDialog3;
      detacher2();
      (_me$exportDialog3 = me.exportDialog) === null || _me$exportDialog3 === void 0 ? void 0 : _me$exportDialog3.unmask();
      me.currentExportPromise = null;
    });
  }
  showLoadingToast(exportPromise) {
    const toast = Toast.show({
      timeout: 0,
      showProgress: false,
      rootElement: this.rootElement,
      html: `
    <span class="b-mask-icon b-icon b-icon-spinner"></span>
    <span>${this.L("L{Waiting for response from server}")}</span>
    <button class="b-button">${this.L("L{Click to abort}")}</button>`
    });
    EventHelper.on({
      element: toast.element,
      click() {
        var _exportPromise$abort;
        (_exportPromise$abort = exportPromise.abort) === null || _exportPromise$abort === void 0 ? void 0 : _exportPromise$abort.call(exportPromise);
      }
    });
    return toast;
  }
};
PdfExport._$name = "PdfExport";
GridFeatureManager.registerFeature(PdfExport, false, "Grid");
var TableExporter = class extends Base {
  static get defaultConfig() {
    return {
      target: null,
      defaultColumnWidth: 100,
      exportDateAsInstance: true,
      showGroupHeader: true,
      columns: null,
      indent: true,
      indentationSymbol: "\xA0\xA0\xA0\xA0"
    };
  }
  export(config = {}) {
    const me = this;
    config = ObjectHelper.assign({}, me.config, config);
    me.normalizeColumns(config);
    return me.generateExportData(config);
  }
  generateExportData(config) {
    const me = this, columns = me.generateColumns(config), rows = me.generateRows(config);
    return {
      rows,
      columns
    };
  }
  normalizeColumns(config) {
    const columns = config.columns || this.target.columns.visibleColumns.filter((rec) => rec.exportable !== false);
    config.columns = columns.map((col) => {
      if (typeof col === "string") {
        return this.target.columns.find((column) => column.field === col) || {
          field: col
        };
      } else {
        return col;
      }
    });
  }
  generateColumns(config) {
    return config.columns.map((col) => this.processColumn(col, config));
  }
  generateRows(config) {
    const {
      columns,
      rows
    } = config;
    if (columns.length === 0 || (rows === null || rows === void 0 ? void 0 : rows.length) === 0) {
      return [];
    }
    const me = this, {
      target
    } = me;
    return (rows || target.store).map((record) => me.processRecord(record, columns, config)).filter((cells) => cells === null || cells === void 0 ? void 0 : cells.length);
  }
  getColumnType(column, store = this.target.store) {
    let result = column.exportedType || "object";
    if (column.exportedType === void 0) {
      if (column.field) {
        const fieldDefinition = store.modelClass.getFieldDefinition(column.field);
        if (fieldDefinition && fieldDefinition.type !== "auto") {
          result = fieldDefinition.type;
        }
      }
    }
    return result;
  }
  processColumn(column, config) {
    const me = this, {
      target
    } = me, {
      defaultColumnWidth
    } = config;
    let {
      field,
      text: value,
      width,
      minWidth
    } = column;
    if (!(field in target.store.modelClass.fieldMap)) {
      field = "";
    }
    if (!value || !width) {
      const gridColumn = target.columns.find((col) => col.field === field);
      if (!value) {
        value = gridColumn && gridColumn.text || field;
      }
      if (width == null) {
        width = gridColumn && gridColumn.width || defaultColumnWidth;
      }
    }
    width = Math.max(width || defaultColumnWidth, minWidth || defaultColumnWidth);
    return {
      field,
      value,
      width,
      type: me.getColumnType(column)
    };
  }
  processRecord(record, columns, config) {
    const {
      target
    } = this, {
      showGroupHeader,
      indent,
      indentationSymbol
    } = config;
    let cells;
    if (!record) {
      cells = columns.map(() => "");
    } else if (record.isSpecialRow) {
      if (showGroupHeader && record.meta.groupRowFor) {
        cells = columns.map((column) => {
          return target.features.group.buildGroupHeader({
            cellElement: DomHelper.createElement(),
            grid: target,
            record,
            column
          });
        });
      }
    } else {
      cells = columns.map((column) => {
        var _column$field;
        let value = (_column$field = column.field) !== null && _column$field !== void 0 && _column$field.includes(".") ? record.get(column.field) : record[column.field];
        const useRenderer = column.renderer || column.defaultRenderer;
        if (useRenderer && !(value && column.isDateColumn && config.exportDateAsInstance)) {
          value = useRenderer.call(column, {
            value,
            record,
            column,
            grid: target,
            isExport: true
          });
        }
        if (indent && column.tree) {
          value = `${indentationSymbol.repeat(record.childLevel)}${value}`;
        }
        return value;
      });
    }
    return cells;
  }
};
TableExporter._$name = "TableExporter";
var BooleanUnicodeSymbol = class {
  constructor(value) {
    this._value = value;
  }
  get value() {
    return this._value;
  }
  toString() {
    return Boolean(this.value) ? "\u2713" : "";
  }
};
BooleanUnicodeSymbol._$name = "BooleanUnicodeSymbol";
var ExcelExporter = class extends InstancePlugin {
  static get $name() {
    return "ExcelExporter";
  }
  static get defaultConfig() {
    return {
      filename: null,
      dateFormat: "YYYY-MM-DD",
      exporterClass: TableExporter,
      exporterConfig: null,
      zipcelx: null,
      convertEmptyValueToEmptyString: true
    };
  }
  processValue(value) {
    if (value === void 0 || value === null || Number.isNaN(value) || typeof value === "function" || typeof value === "object" && String(value) === "[object Object]") {
      return "";
    } else {
      return value;
    }
  }
  generateExportData(config) {
    const me = this, {
      rows,
      columns
    } = me.exporter.export(config.exporterConfig);
    return {
      rows: rows.map((row) => {
        return row.map((value, index) => {
          var _columns$index;
          if (value instanceof Date) {
            value = DateHelper.format(value, config.dateFormat);
          } else if (typeof value === "boolean") {
            value = new BooleanUnicodeSymbol(value);
          }
          if (me.convertEmptyValueToEmptyString) {
            value = me.processValue(value);
          }
          const type = ((_columns$index = columns[index]) === null || _columns$index === void 0 ? void 0 : _columns$index.type) === "number" ? "number" : "string";
          return {
            value,
            type
          };
        });
      }),
      columns: columns.map((col) => {
        let {
          field,
          value,
          width,
          type
        } = col;
        type = "string";
        return {
          field,
          value,
          width,
          type
        };
      })
    };
  }
  export(config = {}) {
    const me = this, zipcelx2 = me.zipcelx || globalThis.zipcelx;
    if (!zipcelx2) {
      throw new Error('ExcelExporter: "zipcelx" library is required');
    }
    if (me.disabled) {
      return;
    }
    config = ObjectHelper.assign({}, me.config, config);
    if (!config.filename) {
      config.filename = me.client.$$name;
    }
    const {
      filename
    } = config, {
      rows,
      columns
    } = me.generateExportData(config);
    return zipcelx2({
      filename,
      sheet: {
        data: [columns].concat(rows),
        cols: columns
      }
    });
  }
  construct(grid, config) {
    super.construct(grid, config);
    if (!this.zipcelx) {
      if (typeof zipcelx !== "undefined") {
        this.zipcelx = globalThis.zipcelx;
      }
    }
  }
  get exporter() {
    const me = this;
    return me._exporter || (me._exporter = me.exporterClass.new({
      target: me.client
    }, me.exporterConfig));
  }
};
ExcelExporter._$name = "ExcelExporter";
GridFeatureManager.registerFeature(ExcelExporter, false, "Grid");
var Bar = class extends Widget {
  static get $name() {
    return "Bar";
  }
  static get type() {
    return "gridbar";
  }
  static get defaultConfig() {
    return {
      htmlCls: "",
      scrollable: {
        overflowX: "hidden-scroll"
      }
    };
  }
  get columns() {
    return this._columns || this.subGrid.columns;
  }
  set columns(columns) {
    this._columns = columns;
  }
  fixCellWidths() {
    const me = this, {
      hasFlex: hasFlex2
    } = me.columns;
    let flexBasis;
    me.columns.traverse((column) => {
      const cellEl = me.getBarCellElement(column.id), domWidth = DomHelper.setLength(column.width), domMinWidth = DomHelper.setLength(column.minWidth), domMaxWidth = DomHelper.setLength(column.maxWidth);
      if (cellEl) {
        flexBasis = domWidth;
        cellEl.style.maxWidth = domMaxWidth;
        if (column.isParent && column.width == null && column.flex == null) {
          const flex = column.children.reduce((result, child) => result += !child.hidden && child.flex || 0, 0);
          cellEl.style.flex = flex > 0 ? `${flex} 0 auto` : "";
          cellEl.style.minWidth = null;
          if (flex > 0) {
            column.traverse((col) => col.data.minWidth = null);
          }
        } else {
          if (parseInt(column.minWidth) >= 0) {
            cellEl.style.minWidth = domMinWidth;
          }
          cellEl.style.flex = cellEl.style.flexBasis = cellEl.style.width = "";
          if (column.flex) {
            if (!isNaN(parseInt(column.flex)) && column.children) {
              cellEl.style.flex = `${column.flex} 0 auto`;
            } else {
              cellEl.style.flex = column.flex;
            }
          } else if (parseInt(column.width) >= 0) {
            const parent = column.parent;
            if (me.isHeader && !parent.isRoot && !parent.width) {
              cellEl.style.width = domWidth;
            } else {
              cellEl.style.flexBasis = flexBasis;
            }
          }
        }
        if (column.height >= 0) {
          cellEl.style.height = DomHelper.setLength(column.height);
        }
      }
    });
    me.scrollable.element.classList.toggle("b-has-flex", hasFlex2);
  }
  getLrPadding(cellEl) {
    if (!this.cellLrPadding) {
      const s = cellEl.ownerDocument.defaultView.getComputedStyle(cellEl);
      this.cellLrPadding = parseInt(s.getPropertyValue("padding-left")) + parseInt(s.getPropertyValue("padding-right")) + parseInt(s.getPropertyValue("border-left-width")) + parseInt(s.getPropertyValue("border-right-width"));
    }
    return this.cellLrPadding;
  }
  getBarCellElement(columnId) {
    return this.element.querySelector(`[data-column-id="${columnId}"]`);
  }
};
Bar.initClass();
Bar._$name = "Bar";
var Footer = class extends Bar {
  static get $name() {
    return "Footer";
  }
  static get type() {
    return "gridfooter";
  }
  get subGrid() {
    return this._subGrid;
  }
  set subGrid(subGrid) {
    this._subGrid = this.owner = subGrid;
  }
  refreshContent() {
    this.element.firstElementChild.innerHTML = this.contentTemplate();
    this.fixFooterWidths();
  }
  onPaint({
    firstPaint
  }) {
    if (firstPaint) {
      this.refreshContent();
    }
  }
  template() {
    const region = this.subGrid.region;
    return TemplateHelper.tpl`
            <div class="b-grid-footer-scroller b-grid-footer-scroller-${region}" role="presentation">
                <div data-reference="footersElement" class="b-grid-footers b-grid-footers-${region}" data-region="${region}" role="presentation"></div>
            </div>
        `;
  }
  get overflowElement() {
    return this.footersElement;
  }
  getFooter(columnId) {
    return this.getBarCellElement(columnId);
  }
  contentTemplate() {
    const me = this;
    return me.columns.visibleColumns.map((column) => {
      return TemplateHelper.tpl`
                <div
                    class="b-grid-footer ${column.align ? `b-grid-footer-align-${column.align}` : ""} ${column.cls || ""}"
                    data-column="${column.field || ""}" data-column-id="${column.id}" data-all-index="${column.allIndex}"
                    role="presentation">
                    ${column.footerText || ""}
                </div>`;
    }).join("");
  }
  fixFooterWidths() {
    this.fixCellWidths();
  }
};
Footer.initClass();
Footer._$name = "Footer";
var RowManager = class extends InstancePlugin {
  static get pluginConfig() {
    return {
      chain: ["destroy"],
      assign: ["rowHeight", "topRow", "bottomRow", "firstVisibleRow", "lastVisibleRow", "firstFullyVisibleRow", "lastFullyVisibleRow", "getRowById", "getRecordCoords", "getRow", "getRowFor", "getRowFromElement"]
    };
  }
  static get defaultConfig() {
    return {
      prependRowBuffer: 5,
      appendRowBuffer: 5,
      rowHeight: null,
      fixedRowHeight: null,
      autoHeight: false
    };
  }
  static get properties() {
    return {
      idMap: {},
      topIndex: 0,
      lastScrollTop: 0,
      _rows: [],
      heightMap: /* @__PURE__ */ new Map(),
      totalKnownHeight: 0,
      _totalHeight: 0,
      averageRowHeight: 0,
      scrollTargetRecordId: null,
      refreshDetails: {
        topRowIndex: 0,
        topRowTop: 0
      }
    };
  }
  construct(config) {
    config.grid._rowManager = this;
    super.construct(config.grid, config);
  }
  doDestroy() {
    this._rows.forEach((row) => row.destroy());
    super.doDestroy();
  }
  initWithHeight(height, isRendering = false) {
    const me = this;
    if (me.autoHeight) {
      height = me.store.allCount * me.preciseRowOffsetHeight;
    }
    me.viewHeight = height;
    me.calculateRowCount(isRendering);
    return height;
  }
  reinitialize(returnToTop = false) {
    const me = this;
    me.calculateRowCount(false, true, true);
    if (me.topIndex + me.rowCount - 1 > me.store.count) {
      returnToTop = true;
    }
    const top = me.topRow && !returnToTop ? me.topRow.top : 0;
    me.scrollTargetRecordId = null;
    if (returnToTop) {
      me.topIndex = me.lastScrollTop = 0;
    }
    const {
      topRow
    } = me;
    if (topRow) {
      topRow.dataIndex = me.topIndex;
      topRow.setTop(top, true);
    }
    me.estimateTotalHeight();
    me.renderFromRow(topRow);
  }
  matchRowCount(skipRender = false) {
    const me = this, {
      rows,
      grid
    } = me, numRows = rows.length, delta = numRows - me.rowCount;
    if (delta) {
      if (delta < 0) {
        const newRows = [];
        for (let index = numRows, dataIndex = numRows ? rows[numRows - 1].dataIndex + 1 : 0; index < me.rowCount; index++, dataIndex++) {
          newRows.push(new Row({
            cls: grid.rowCls,
            rowManager: me,
            grid,
            index,
            dataIndex
          }));
        }
        rows.push.apply(rows, newRows);
        me.trigger("addRows", {
          rows: newRows
        });
        if (!skipRender) {
          me.renderFromRow(rows[Math.max(0, numRows - 1)]);
        }
      } else {
        var _focusedCell$cell;
        const {
          focusedCell
        } = grid, rowActive = (focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.id) != null && (focusedCell === null || focusedCell === void 0 ? void 0 : (_focusedCell$cell = focusedCell.cell) === null || _focusedCell$cell === void 0 ? void 0 : _focusedCell$cell.contains(DomHelper.getActiveElement(grid))), removedRows = rows.splice(numRows - delta, delta);
        if (rowActive) {
          var _me$getRowFor;
          if (delta === numRows) {
            grid.onFocusedRowDerender();
          } else if (((_me$getRowFor = me.getRowFor(focusedCell._record)) === null || _me$getRowFor === void 0 ? void 0 : _me$getRowFor.index) >= rows.length) {
            rows[rows.length - 1].cells[focusedCell.columnIndex].focus();
          }
        }
        me.trigger("removeRows", {
          rows: removedRows
        });
        removedRows.forEach((row) => row.destroy());
      }
    }
  }
  calculateRowCount(skipMatchRowCount = false, allowRowCountShrink = true, skipRender = false) {
    var _me$grid$columns;
    const me = this, {
      store
    } = me, visibleRowCount = Math.ceil(me.viewHeight / me.minRowOffsetHeight), maxRenderRowCount = visibleRowCount + me.prependRowBuffer + me.appendRowBuffer;
    if (!((_me$grid$columns = me.grid.columns) !== null && _me$grid$columns !== void 0 && _me$grid$columns.count) || isNaN(visibleRowCount)) {
      me.rowCount = 0;
      return 0;
    }
    if (maxRenderRowCount < me.rowCount && !allowRowCountShrink) {
      return me.rowCount;
    }
    me.visibleRowCount = visibleRowCount;
    me.rowCount = Math.min(store.count, maxRenderRowCount);
    if (!skipMatchRowCount) {
      if (me.rows && me.rowCount !== me.rows.length) {
        var _me$bottomRow;
        me.matchRowCount(skipRender);
        if (((_me$bottomRow = me.bottomRow) === null || _me$bottomRow === void 0 ? void 0 : _me$bottomRow.dataIndex) >= store.count && me.topRow.dataIndex !== 0) {
          const indexDelta = me.bottomRow.dataIndex - store.count + 1;
          for (const row of me.rows) {
            row.dataIndex -= indexDelta;
          }
          me.topIndex -= indexDelta;
        }
      } else if (!me.rowCount) {
        me.trigger("changeTotalHeight", {
          totalHeight: me.totalHeight
        });
      }
      me.grid.toggleEmptyText();
    }
    return me.rowCount;
  }
  removeAllRows() {
    const me = this, {
      topRow
    } = me, result = topRow ? me.refreshDetails = {
      topRowIndex: topRow.dataIndex,
      topRowTop: topRow.top
    } : me.refreshDetails, removedRows = me.rows.slice();
    me.trigger("removeRows", {
      rows: removedRows
    });
    me.rows.forEach((row) => row.destroy());
    me.rows.length = 0;
    me.idMap = {};
    return result;
  }
  setPosition(refreshDetails) {
    const {
      topRow
    } = this, {
      topRowIndex,
      topRowTop
    } = refreshDetails;
    topRow.setTop(topRowTop);
    topRow.dataIndex = topRowIndex;
  }
  get store() {
    return this.client.store;
  }
  get rows() {
    return this._rows;
  }
  getRow(index) {
    if (this.rowCount) {
      return this.rows[index - this.topIndex];
    }
  }
  getRowById(recordOrId) {
    if (recordOrId && recordOrId.isModel) {
      recordOrId = recordOrId.id;
    }
    return this.idMap[recordOrId];
  }
  getRowFromElement(element) {
    element = element.closest(".b-grid-row");
    return element && this.getRow(element.dataset.index);
  }
  getRowAt(y, local = false) {
    if (!local) {
      y -= Rectangle.from(this.grid.bodyContainer, null, true).roundPx(1).top;
      y += this.grid.scrollable.y;
    }
    y = DomHelper.roundPx(y);
    return this.rows.find((r) => y >= r.top && y < r.bottom);
  }
  getRowFor(recordOrId) {
    if (recordOrId instanceof HTMLElement) {
      return this.getRowFromElement(recordOrId);
    }
    return this.getRowById(recordOrId);
  }
  getNextRow(indexOrRow) {
    const index = typeof indexOrRow === "number" ? indexOrRow : indexOrRow.index;
    return this.getRow((index + 1) % this.rowCount);
  }
  get topRow() {
    return this.rows[0];
  }
  get bottomRow() {
    const rowCount = Math.min(this.rowCount, this.store.count);
    return this.rows[rowCount - 1];
  }
  get firstVisibleRow() {
    return this.rows.find((r) => r.bottom > Math.ceil(this.grid.scrollable.y));
  }
  get firstFullyVisibleRow() {
    return this.rows.find((r) => r.top >= Math.ceil(this.grid.scrollable.y));
  }
  get lastVisibleRow() {
    const {
      grid
    } = this;
    return ArrayHelper.findLast(this.rows, (r) => r.top < grid.scrollable.y + grid.bodyHeight);
  }
  get lastFullyVisibleRow() {
    const {
      grid
    } = this;
    return ArrayHelper.findLast(this.rows, (r) => r.bottom < grid.scrollable.y + grid.bodyHeight);
  }
  offsetRows(offset) {
    if (offset !== 0) {
      const {
        rows
      } = this, {
        length
      } = rows;
      for (let i = 0; i < length; i++) {
        rows[i].offset(offset);
      }
    }
    this.trigger("offsetRows", {
      offset
    });
  }
  get prependBufferHeight() {
    return this.prependRowBuffer * this.rowOffsetHeight;
  }
  get appendBufferHeight() {
    return this.appendRowBuffer * this.rowOffsetHeight;
  }
  get rowHeight() {
    return this._rowHeight;
  }
  set rowHeight(height) {
    const me = this, {
      grid,
      fixedRowHeight
    } = me, oldHeight = me.rowHeight;
    if (oldHeight === height) {
      return;
    }
    ObjectHelper.assertNumber(height, "rowHeight");
    if (height < 10) {
      height = 10;
    }
    me.trigger("beforeRowHeight", {
      height
    });
    me.minRowHeight = me._rowHeight = height;
    if (fixedRowHeight) {
      me.averageRowHeight = height;
    }
    if (me.rows.length) {
      const oldY = grid.scrollable.y, topRow = me.getRowAt(oldY, true), edgeOffset = topRow ? topRow.top - oldY : 0;
      let average, oldAverage;
      if (fixedRowHeight) {
        average = height;
        oldAverage = oldHeight;
      } else {
        oldAverage = average = me.averageRowHeight;
        me.clearKnownHeights();
        average *= height / oldHeight;
      }
      me.calculateRowCount(false, true, true);
      me.topRow.setTop(me.topRow.dataIndex * (average + grid._rowBorderHeight), true);
      me.refresh();
      const newY = oldY * (average / oldAverage);
      if (newY !== oldY) {
        grid.scrollRowIntoView(topRow.id, {
          block: "start",
          edgeOffset
        });
      }
    }
    me.trigger("rowHeight", {
      height,
      oldHeight
    });
  }
  get rowOffsetHeight() {
    return Math.floor(this.preciseRowOffsetHeight);
  }
  get preciseRowOffsetHeight() {
    return (this.averageRowHeight || this._rowHeight) + this.grid._rowBorderHeight;
  }
  get minRowOffsetHeight() {
    return (this.minRowHeight || this._rowHeight) + this.grid._rowBorderHeight;
  }
  get allHeightsKnown() {
    return this.fixedRowHeight || this.heightMap.size >= this.store.count;
  }
  storeKnownHeight(id, height) {
    const me = this, {
      heightMap
    } = me;
    if (!me.fixedRowHeight) {
      if (heightMap.has(id)) {
        me.totalKnownHeight -= heightMap.get(id);
      }
      heightMap.set(id, height);
      me.totalKnownHeight += height;
      if (height < me.minRowHeight) {
        me.minRowHeight = height;
      }
      me.averageRowHeight = me.totalKnownHeight / heightMap.size;
    }
  }
  getOffsetHeight(record) {
    const me = this;
    return (record && me.heightMap.get(record.id) || record && me.grid.getRowHeight(record) || me.averageRowHeight || me.rowHeight) + me.grid._rowBorderHeight;
  }
  invalidateKnownHeight(records) {
    const me = this;
    if (!me.fixedRowHeight) {
      const {
        heightMap
      } = me;
      records = ArrayHelper.asArray(records);
      records.forEach((record) => {
        if (record) {
          if (heightMap.has(record.id)) {
            me.totalKnownHeight -= heightMap.get(record.id);
            heightMap.delete(record.id);
          }
        }
      });
      me.averageRowHeight = me.totalKnownHeight / heightMap.size;
    }
  }
  clearKnownHeights() {
    this.heightMap.clear();
    this.averageRowHeight = this.totalKnownHeight = 0;
  }
  calculateTop(index) {
    if (this.fixedRowHeight) {
      return index * this.rowOffsetHeight;
    }
    const {
      store
    } = this;
    let top = 0;
    for (let i = 0; i < index; i++) {
      const record = store.getAt(i);
      top += this.getOffsetHeight(record);
    }
    return Math.floor(top);
  }
  getRecordCoords(recordOrId, local = false, roughly = false) {
    const me = this, row = me.getRowById(recordOrId);
    let scrollingViewport = me.client._bodyRectangle;
    if (!local) {
      scrollingViewport = me.client.refreshBodyRectangle();
    }
    if (row) {
      return new Rectangle(scrollingViewport.x, local ? Math.round(row.top) : Math.round(row.top + scrollingViewport.y - me.client.scrollable.y), scrollingViewport.width, row.offsetHeight);
    }
    return me.getRecordCoordsByIndex(me.store.indexOf(recordOrId), local, roughly);
  }
  getRecordCoordsByIndex(recordIndex, local = false, roughly = false) {
    const me = this, {
      topRow,
      bottomRow
    } = me, scrollingViewport = me.client._bodyRectangle, {
      id
    } = me.store.getAt(recordIndex), height = me.preciseRowOffsetHeight, currentTopIndex = topRow.dataIndex, currentBottomIndex = bottomRow.dataIndex, calculateFrom = recordIndex > currentBottomIndex ? {
      index: recordIndex - currentBottomIndex - 1,
      y: bottomRow.bottom,
      from: "bottomRow"
    } : recordIndex > currentTopIndex / 2 ? {
      index: recordIndex - currentTopIndex,
      y: topRow.top,
      from: "topRow"
    } : {
      index: recordIndex,
      y: 0,
      from: "top"
    }, top = me.allHeightsKnown && !roughly ? me.calculateTop(recordIndex) : Math.floor(calculateFrom.y + calculateFrom.index * height), result = new Rectangle(
      scrollingViewport.x,
      local ? top : top + scrollingViewport.y - me.client.scrollable.y,
      scrollingViewport.width,
      Math.floor(me.heightMap.get(id) || height)
    );
    result.virtual = true;
    result.block = result.bottom < scrollingViewport.y ? "start" : result.y > scrollingViewport.bottom ? "end" : "nearest";
    return result;
  }
  get totalHeight() {
    return this._totalHeight;
  }
  forEach(fn) {
    this.rows.forEach(fn);
  }
  [Symbol.iterator]() {
    return this.rows[Symbol.iterator]();
  }
  refreshCell(record, columnId) {
    const cellContext = new Location({
      grid: this.grid,
      record,
      columnId
    });
    return Boolean(cellContext.cell && cellContext.row.renderCell(cellContext));
  }
  returnToTop() {
    const me = this;
    me.topIndex = 0;
    me.lastScrollTop = 0;
    if (me.topRow) {
      me.topRow.dataIndex = 0;
      me.topRow.setTop(0, true);
    }
    me.refresh();
    me.grid.scrollable.y = 0;
  }
  renderFromRecord(record) {
    const row = this.getRowById(record.id);
    if (row) {
      this.renderFromRow(row);
    }
  }
  renderFromRow(fromRow = null) {
    const me = this, {
      rows,
      store
    } = me, storeCount = store.count;
    if (me.calculateRowCount(false, storeCount < rows.length, true) === 0) {
      me.estimateTotalHeight(true);
      return;
    }
    const fromRowIndex = fromRow ? rows.indexOf(fromRow) : 0;
    let dataIndex = fromRow ? fromRow.dataIndex : rows[0].dataIndex;
    const recordsAfter = storeCount - dataIndex - 1, toRowIndex = Math.min(rows.length - 1, fromRowIndex + recordsAfter);
    let leftOverCount = rows.length - toRowIndex - 1, top = fromRowIndex > 0 ? rows[fromRowIndex - 1].bottom : rows[fromRowIndex].top, row;
    for (let i = fromRowIndex; i <= toRowIndex; i++) {
      row = rows[i];
      row.dataIndex = dataIndex;
      row.setTop(top, true);
      row.render(dataIndex, store.getAt(dataIndex++), false);
      top += row.offsetHeight;
    }
    while (leftOverCount-- > 0) {
      me.displayRecordAtTop();
    }
    if (me.bottomRow.bottom < me.viewHeight) {
      me.calculateRowCount();
    }
    me.estimateTotalHeight(true);
    me.trigger("renderDone");
  }
  renderRows(rows) {
    let oldHeight, heightChanged = false;
    rows = Array.from(rows);
    rows.sort((a, b) => a.dataIndex - b.dataIndex);
    for (const row of rows) {
      oldHeight = row.height;
      row.render(null, null, false);
      heightChanged |= row.height !== oldHeight;
    }
    if (heightChanged) {
      this.translateFromRow(rows[0]);
    }
    this.trigger("renderDone");
  }
  translateFromRow(fromRow, batch = false) {
    const me = this;
    let top = fromRow.bottom, row, index;
    for (index = fromRow.dataIndex + 1, row = me.getRow(index); row; row = me.getRow(++index)) {
      top = row.translate(top);
    }
    if (!batch) {
      me.estimateTotalHeight(true);
    }
  }
  refresh() {
    const me = this, {
      topRow
    } = me;
    if (!topRow || me.grid.refreshSuspended) {
      return;
    }
    me.idMap = {};
    me.renderFromRow(topRow);
    me.trigger("refresh");
  }
  jumpToPosition(newScrollTop, forceRecordIndex) {
    const me = this, {
      store,
      heightMap
    } = me, storeCount = store.count;
    if (me.allHeightsKnown && !me.fixedRowHeight) {
      const top = newScrollTop - me.prependBufferHeight, border = me.grid._rowBorderHeight;
      let accumulated = 0, targetIndex = 0;
      while (accumulated < top) {
        const record = store.getAt(targetIndex);
        accumulated += heightMap.get(record.id) + border;
        targetIndex++;
      }
      const startIndex = Math.max(Math.min(targetIndex, storeCount - me.rowCount), 0);
      me.lastScrollTop = newScrollTop;
      me.topRow.dataIndex = me.topIndex = startIndex;
      me.topRow.setTop(me.calculateTop(startIndex), false);
      me.refresh();
    } else {
      const rowHeight = me.preciseRowOffsetHeight, targetIndex = forceRecordIndex == null ? Math.floor(newScrollTop / rowHeight) - me.prependRowBuffer : forceRecordIndex - Math.floor(me.rowCount / 2), startIndex = Math.max(Math.min(targetIndex, storeCount - me.rowCount), 0), viewportTop = me.client.scrollable.y, viewportBottom = Math.min(me.client._bodyRectangle.height + viewportTop + me.appendBufferHeight, me.totalHeight);
      me.lastScrollTop = newScrollTop;
      me.topRow.dataIndex = me.topIndex = startIndex;
      me.topRow.setTop(Math.floor(startIndex * rowHeight), false);
      me.refresh();
      if (me.bottomRow.bottom < viewportBottom) {
        me.calculateRowCount(false, false, false);
        while (me.bottomRow.bottom < viewportBottom && me._rows[me.prependRowBuffer].top < viewportTop && me.bottomRow.dataIndex < storeCount - 1) {
          me.displayRecordAtBottom();
        }
      }
      me.estimateTotalHeight();
    }
    if (forceRecordIndex != null) {
      const {
        scrollable
      } = me.grid, targetRow = me.getRow(forceRecordIndex), rowCenter = targetRow && Rectangle.from(targetRow._elementsArray[0]).center.y, viewportCenter = scrollable.viewport.center.y;
      if (targetRow) {
        scrollable.y = newScrollTop = Math.floor(scrollable.y + (rowCenter - viewportCenter));
      }
    }
    return newScrollTop;
  }
  warpIfNeeded(newScrollTop) {
    const me = this, result = {
      newScrollTop,
      deltaTop: newScrollTop - me.lastScrollTop
    };
    if (Math.abs(result.deltaTop) > me.rowCount * me.rowOffsetHeight * 3) {
      let index;
      if (me.scrollTargetRecordId) {
        index = me.store.indexOf(me.scrollTargetRecordId);
      }
      me.grid.onFocusedRowDerender();
      result.newScrollTop = me.jumpToPosition(newScrollTop, index);
      result.deltaTop = 0;
    }
    return result;
  }
  updateRenderedRows(newScrollTop, force, ignoreError = false) {
    const me = this, clientRect = me.client._bodyRectangle;
    if (me.rowCount === 0) {
      return 0;
    }
    let result = me.totalHeight;
    if (force || Math.abs(newScrollTop - me.lastScrollTop) >= me.rowOffsetHeight || me.topRow.top > newScrollTop || me.bottomRow.bottom < newScrollTop + clientRect.height) {
      const posInfo = me.warpIfNeeded(newScrollTop);
      me.scrollTargetRecordId = null;
      me.lastScrollTop = posInfo.newScrollTop;
      if (posInfo.deltaTop > 0) {
        me.fillBelow(posInfo.newScrollTop);
      } else if (posInfo.deltaTop < 0) {
        me.fillAbove(posInfo.newScrollTop);
      }
      if (!me.fixedRowHeight && !ignoreError) {
        me.correctError(posInfo, clientRect, newScrollTop);
      }
      result = me.estimateTotalHeight();
    }
    return result;
  }
  correctError(posInfo, clientRect, newScrollTop) {
    const me = this;
    let error = 0;
    if (me.allHeightsKnown) {
      error = me.topRow.top - me.calculateTop(me.topRow.dataIndex);
    } else {
      if (posInfo.deltaTop < 0 && newScrollTop < clientRect.height * 2 || posInfo.deltaTop > 0 && newScrollTop > me.totalHeight - clientRect.height * 2 - 3) {
        error = me.topRow.top - me.calculateTop(me.topRow.dataIndex);
      }
    }
    if (error) {
      me.offsetRows(-error);
      me.grid.scrollable.y = me.lastScrollTop = me.grid.scrollable.y - error;
    }
  }
  fillAbove(newTop) {
    const me = this, fillHeight = newTop - me.topRow.top - me.prependBufferHeight;
    let accumulatedHeight = 0;
    while (accumulatedHeight > fillHeight && me.topIndex > 0) {
      accumulatedHeight -= me.displayRecordAtTop();
    }
    me.trigger("renderDone");
  }
  fillBelow(newTop) {
    const me = this, fillHeight = newTop - me.topRow.top - me.prependBufferHeight, recordCount = me.store.count, rowCount = me.rowCount;
    let accumulatedHeight = 0;
    while (accumulatedHeight < fillHeight && me.topIndex + rowCount < recordCount && me.topRow.top + me.topRow.offsetHeight < newTop) {
      accumulatedHeight += me.displayRecordAtBottom();
    }
    me.trigger("renderDone");
  }
  estimateTotalHeight(immediate = false) {
    const me = this;
    if (me.grid.renderingRows) {
      return;
    }
    const recordCount = me.store.count, unknownCount = recordCount - me.heightMap.size, {
      bottomRow
    } = me;
    let estimate;
    if (me.fixedRowHeight) {
      estimate = recordCount * me.rowOffsetHeight;
    } else {
      estimate = me.totalKnownHeight + me.heightMap.size * me.grid._rowBorderHeight + unknownCount * me.preciseRowOffsetHeight;
      if (bottomRow && unknownCount) {
        const bottom = bottomRow.bottom;
        if (bottom > estimate || me.topIndex + me.rowCount >= recordCount && estimate > bottom && bottom > 0) {
          estimate = bottom;
          if (bottomRow.dataIndex < recordCount - 1) {
            estimate += (recordCount - 1 - bottomRow.dataIndex) * me.preciseRowOffsetHeight;
          }
        }
      }
      estimate = Math.floor(estimate);
    }
    if (estimate !== me.totalHeight) {
      if (me.trigger("changeTotalHeight", {
        totalHeight: estimate,
        immediate
      }) !== false) {
        me._totalHeight = estimate;
      }
    }
    return estimate;
  }
  displayRecordAtTop() {
    var _grid$focusedCell;
    const me = this, {
      grid
    } = me, recordIndex = me.topIndex - 1, record = me.store.getAt(recordIndex), bottomRow = me.bottomRow, bottomRowTop = bottomRow.top;
    me.trigger("beforeTranslateRow", {
      row: bottomRow,
      newRecord: record
    });
    if (bottomRow.dataIndex === ((_grid$focusedCell = grid.focusedCell) === null || _grid$focusedCell === void 0 ? void 0 : _grid$focusedCell.rowIndex)) {
      grid.onFocusedRowDerender();
    }
    bottomRow._top = me.topRow.top - me.getOffsetHeight(record);
    bottomRow.estimatedTop = !me.fixedRowHeight;
    bottomRow.render(recordIndex, record, false);
    bottomRow._top = bottomRowTop;
    bottomRow.setBottom(me.topRow.top);
    bottomRow.estimatedTop = false;
    me.topIndex--;
    me._rows.unshift(me._rows.pop());
    return bottomRow.offsetHeight;
  }
  displayRecordAtBottom() {
    var _grid$focusedCell2;
    const me = this, {
      grid
    } = me, recordIndex = me.topIndex + me.rowCount, record = me.store.getAt(recordIndex), topRow = me.topRow;
    me.trigger("beforeTranslateRow", {
      row: topRow,
      newRecord: record
    });
    if (topRow.dataIndex === ((_grid$focusedCell2 = grid.focusedCell) === null || _grid$focusedCell2 === void 0 ? void 0 : _grid$focusedCell2.rowIndex)) {
      grid.onFocusedRowDerender();
    }
    topRow.dataIndex = recordIndex;
    topRow.setTop(me.bottomRow.bottom);
    topRow.render(recordIndex, record, false);
    me.topIndex++;
    me._rows.push(me._rows.shift());
    return topRow.offsetHeight;
  }
};
RowManager.featureClass = "";
RowManager._$name = "RowManager";
var xAxis = {
  x: 1
};
var GridScroller = class extends Scroller {
  addScroller(scroller) {
    (this.xScrollers || (this.xScrollers = [])).push(scroller);
  }
  addPartner(otherScroller, axes = xAxis) {
    if (typeof axes === "string") {
      axes = {
        [axes]: 1
      };
    }
    if (axes.x) {
      otherScroller.owner.initScroll();
      this.xScrollers.forEach((scroller, i) => scroller.addPartner(otherScroller.xScrollers[i], "x"));
    }
    if (axes.y) {
      super.addPartner(otherScroller, "y");
    }
  }
  removePartner(otherScroller) {
    this.xScrollers.forEach((scroller, i) => {
      if (!scroller.isDestroyed) {
        scroller.removePartner(otherScroller.xScrollers[i]);
      }
    });
    super.removePartner(otherScroller);
  }
  updateOverflowX(overflowX) {
    var _this$xScrollers;
    const hideScroll = overflowX === false;
    (_this$xScrollers = this.xScrollers) === null || _this$xScrollers === void 0 ? void 0 : _this$xScrollers.forEach((s) => s.overflowX = hideScroll ? "hidden" : "hidden-scroll");
    this.widget.virtualScrollers.classList.toggle("b-hide-display", hideScroll);
  }
  scrollIntoView(element, options) {
    if (element.nodeType === Element.ELEMENT_NODE && this.element.contains(element)) {
      for (const subGridScroller of this.xScrollers) {
        if (subGridScroller.element.contains(element)) {
          return subGridScroller.scrollIntoView(element, options);
        }
      }
    } else {
      return super.scrollIntoView(element, options);
    }
  }
  hasOverflow(axis = "y") {
    return axis === "y" ? this.scrollHeight > this.clientHeight : false;
  }
  set x(x) {
    if (this.xScrollers) {
      this.xScrollers[0].x = x;
    }
  }
  get x() {
    return this.xScrollers ? this.xScrollers[0].x : 0;
  }
};
GridScroller._$name = "GridScroller";
var Header = class extends Bar {
  static get $name() {
    return "Header";
  }
  static get type() {
    return "gridheader";
  }
  get subGrid() {
    return this._subGrid;
  }
  set subGrid(subGrid) {
    this._subGrid = this.owner = subGrid;
  }
  get region() {
    var _this$subGrid;
    return (_this$subGrid = this.subGrid) === null || _this$subGrid === void 0 ? void 0 : _this$subGrid.region;
  }
  changeElement(element, was) {
    const {
      region
    } = this;
    this.getConfig("columns");
    return super.changeElement({
      className: {
        "b-grid-header-scroller": 1,
        [`b-grid-header-scroller-${region}`]: region
      },
      children: [{
        reference: "headersElement",
        className: {
          "b-grid-headers": 1,
          [`b-grid-headers-${region}`]: region
        },
        dataset: {
          region,
          reference: "headersElement",
          maxDepth: this.maxDepth
        }
      }]
    }, was);
  }
  get overflowElement() {
    return this.headersElement;
  }
  getColumnConfig(column) {
    const {
      id,
      align,
      resizable,
      isLeaf,
      isParent,
      isLastInSubGrid,
      cls,
      childLevel,
      field,
      tooltip,
      children,
      isFocusable,
      grid
    } = column, focusedCell = grid === null || grid === void 0 ? void 0 : grid.focusedCell, isFocused = (focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.rowIndex) === -1 && (focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.column) === column;
    if (column.isVisible) {
      return {
        className: {
          "b-grid-header": 1,
          "b-grid-header-parent": isParent,
          [`b-level-${childLevel}`]: 1,
          [`b-depth-${column.meta.depth}`]: 1,
          [`b-grid-header-align-${align}`]: align,
          "b-grid-header-resizable": resizable && isLeaf,
          [cls]: cls,
          "b-collapsible": column.collapsible,
          "b-last-parent": isParent && isLastInSubGrid,
          "b-last-leaf": isLeaf && isLastInSubGrid
        },
        role: isFocusable ? "columnheader" : "presentation",
        "aria-sort": "none",
        "aria-label": column.ariaLabel,
        [isFocusable ? "tabIndex" : ""]: isFocused ? 0 : -1,
        dataset: _objectSpread2(_objectSpread2({}, Tooltip.encodeConfig(tooltip)), {}, {
          columnId: id,
          [field ? "column" : ""]: field
        }),
        children: [{
          className: "b-grid-header-text",
          children: [{
            [grid && isFocusable ? "id" : ""]: `${grid === null || grid === void 0 ? void 0 : grid.id}-column-${column.id}`,
            className: "b-grid-header-text-content"
          }]
        }, children ? {
          className: "b-grid-header-children",
          children: children.map((child) => this.getColumnConfig(child))
        } : null, {
          className: "b-grid-header-resize-handle"
        }]
      };
    }
  }
  calculateMinWidthForSafari() {
    let minWidth = 0;
    this.columns.visibleColumns.forEach((column) => {
      minWidth += column.calculateMinWidth();
    });
    return minWidth;
  }
  fixHeaderWidths() {
    this.fixCellWidths();
  }
  refreshHeaders() {
    const me = this;
    me.columns.traverse((column) => {
      const headerElement = me.getBarCellElement(column.id);
      if (headerElement) {
        let html = column.headerText;
        if (column.headerRenderer) {
          html = column.headerRenderer.call(column.thisObj || me, {
            column,
            headerElement
          });
        }
        if (column.headerWidgetMap) {
          Object.values(column.headerWidgetMap).forEach((widget) => {
            widget.render(column.textWrapper);
          });
        }
        if (column.icon) {
          html = `<i class="${StringHelper.encodeHtml(column.icon)}"></i>` + (html || "");
        }
        const innerEl = headerElement.querySelector(".b-grid-header-text-content");
        if (innerEl) {
          innerEl.innerHTML = html || "";
        }
      }
    });
    me.fixHeaderWidths();
  }
  get columns() {
    const me = this, result = super.columns;
    if (!me.columnsDetacher) {
      me.columnsDetacher = result.ion({
        change() {
          me.initDepths();
        },
        thisObj: me
      });
      me.initDepths();
    }
    return result;
  }
  set columns(columns) {
    super.columns = columns;
  }
  initDepths(columns = this.columns.topColumns, parent = null) {
    const me = this;
    let maxDepth = 0;
    if (parent !== null && parent !== void 0 && parent.meta) {
      parent.meta.depth++;
    }
    for (const column of columns) {
      const {
        meta
      } = column;
      meta.depth = 0;
      if (column.children) {
        me.initDepths(column.children.filter(me.columns.chainedFilterFn), column);
        if (meta.depth && parent) {
          parent.meta.depth += meta.depth;
        }
      }
      if (meta.depth > maxDepth) {
        maxDepth = meta.depth;
      }
    }
    if (!parent) {
      me.maxDepth = maxDepth;
    }
    return maxDepth;
  }
  getHeader(columnId) {
    return this.getBarCellElement(columnId);
  }
  get contentElement() {
    return this.element.firstElementChild;
  }
  refreshContent() {
    const me = this;
    DomSync.sync({
      domConfig: {
        children: me.columns.topColumns.map((col) => me.getColumnConfig(col)),
        onlyChildren: true,
        strict: true,
        syncIdField: "columnId",
        releaseThreshold: 0
      },
      targetElement: me.contentElement
    });
    me.refreshHeaders();
  }
  onPaint({
    firstPaint
  }) {
    if (firstPaint) {
      this.refreshContent();
    }
  }
};
Header.initClass();
Header._$name = "Header";
var gridBodyElementEventHandlers = {
  touchstart: "onElementTouchStart",
  touchmove: "onElementTouchMove",
  touchend: "onElementTouchEnd",
  mouseover: "onElementMouseOver",
  mouseout: "onElementMouseOut",
  mousedown: "onElementMouseDown",
  mousemove: "onElementMouseMove",
  mouseup: "onElementMouseUp",
  click: "onHandleElementClick",
  dblclick: "onElementDblClick",
  keyup: "onElementKeyUp",
  keypress: "onElementKeyPress",
  contextmenu: "onElementContextMenu",
  pointerdown: "onElementPointerDown",
  pointerup: "onElementPointerUp"
};
var eventProps = ["pageX", "pageY", "clientX", "clientY", "screenX", "screenY"];
function toggleHover(element, add = true) {
  element === null || element === void 0 ? void 0 : element.classList.toggle("b-hover", add);
}
function setCellHover(columnId, row, add = true) {
  row && columnId && toggleHover(row.getCell(columnId), add);
}
var GridElementEvents = (Target) => class GridElementEvents extends (Target || Base) {
  static get $name() {
    return "GridElementEvents";
  }
  static get configurable() {
    return {
      longPressTime: 400,
      enableUndoRedoKeys: true,
      keyMap: {
        "Ctrl+z": "undoRedoKeyPress",
        "Ctrl+Shift+z": "undoRedoKeyPress",
        " ": {
          handler: "clickCellByKey",
          weight: 1e3
        }
      }
    };
  }
  initInternalEvents() {
    const handledEvents = Object.keys(gridBodyElementEventHandlers), len = handledEvents.length, listeners = {
      element: this.bodyElement,
      thisObj: this
    };
    for (let i = 0; i < len; i++) {
      const eventName = handledEvents[i];
      listeners[eventName] = {
        handler: "handleEvent"
      };
      if (eventName.startsWith("touch")) {
        listeners[eventName].passive = false;
      }
    }
    EventHelper.on(listeners);
    EventHelper.on({
      focusin: "onGridBodyFocusIn",
      element: this.bodyElement,
      thisObj: this,
      capture: true
    });
  }
  getCellDataFromEvent(event, includeSingleAxisMatch = false) {
    const me = this, {
      columns
    } = me, {
      target
    } = event;
    let cellElement = target.closest(".b-grid-cell");
    if (!cellElement && includeSingleAxisMatch && !target.classList.contains("b-grid-row") && !target.classList.contains("b-grid-subgrid")) {
      const {
        top,
        left,
        right,
        bottom
      } = me.bodyContainer.getBoundingClientRect();
      let match, {
        x,
        y
      } = event;
      if (x >= left && x <= right) {
        y = match = Math.ceil(me[`${y < top ? "first" : "last"}FullyVisibleRow`].element.getBoundingClientRect().y);
      } else if (y >= top && y <= bottom) {
        x = match = Math.ceil(columns.visibleColumns[x < left ? 0 : columns.visibleColumns.length - 1].element.getBoundingClientRect().x);
      }
      if (match !== void 0) {
        var _document$elementFrom;
        cellElement = (_document$elementFrom = document.elementFromPoint(x, y)) === null || _document$elementFrom === void 0 ? void 0 : _document$elementFrom.closest(".b-grid-cell");
      }
    }
    if (cellElement) {
      const cellData = DomDataStore.get(cellElement), {
        id,
        columnId
      } = cellData, record = me.store.getById(id), column = columns.getById(columnId);
      return record ? {
        cellElement,
        cellData,
        columnId,
        id,
        record,
        column,
        cellSelector: {
          id,
          columnId
        }
      } : null;
    }
  }
  getHeaderDataFromEvent(event) {
    const headerElement = event.target.closest(".b-grid-header");
    if (headerElement) {
      const headerData = ObjectHelper.assign({}, headerElement.dataset), {
        columnId
      } = headerData, column = this.columns.getById(columnId);
      return column ? {
        headerElement,
        headerData,
        columnId,
        column
      } : null;
    }
  }
  handleEvent(event) {
    if (!this.disabled && gridBodyElementEventHandlers[event.type]) {
      this[gridBodyElementEventHandlers[event.type]](event);
    }
  }
  onElementTouchStart(event) {
    const me = this, cellData = me.getCellDataFromEvent(event);
    DomHelper.isTouchEvent = true;
    if (event.touches.length === 1) {
      me.longPressTimeout = me.setTimeout(() => {
        me.onElementLongPress(event);
        event.preventDefault();
        me.longPressPerformed = true;
      }, me.longPressTime);
    }
    if (cellData && !event.defaultPrevented) {
      me.onFocusGesture(event);
    }
  }
  onElementTouchMove(event) {
    const me = this, {
      lastTouchTarget
    } = me, touch = event.changedTouches[0], {
      pageX,
      pageY
    } = touch, touchTarget = document.elementFromPoint(pageX, pageY);
    if (me.longPressTimeout) {
      me.clearTimeout(me.longPressTimeout);
      me.longPressTimeout = null;
    }
    if (touchTarget !== lastTouchTarget) {
      if (lastTouchTarget) {
        const mouseoutEvent = new MouseEvent("mouseout", ObjectHelper.copyProperties({
          relatedTarget: touchTarget,
          pointerType: "touch",
          bubbles: true
        }, touch, eventProps));
        mouseoutEvent.preventDefault = () => event.preventDefault();
        lastTouchTarget === null || lastTouchTarget === void 0 ? void 0 : lastTouchTarget.dispatchEvent(mouseoutEvent);
      }
      if (touchTarget) {
        const mouseoverEvent = new MouseEvent("mouseover", ObjectHelper.copyProperties({
          relatedTarget: lastTouchTarget,
          pointerType: "touch",
          bubbles: true
        }, touch, eventProps));
        mouseoverEvent.preventDefault = () => event.preventDefault();
        touchTarget === null || touchTarget === void 0 ? void 0 : touchTarget.dispatchEvent(mouseoverEvent);
      }
    }
    me.lastTouchTarget = touchTarget;
  }
  onElementTouchEnd(event) {
    const me = this;
    if (me.longPressPerformed) {
      if (event.cancelable) {
        event.preventDefault();
      }
      me.longPressPerformed = false;
    }
    if (me.longPressTimeout) {
      me.clearTimeout(me.longPressTimeout);
      me.longPressTimeout = null;
    }
  }
  onElementLongPress(event) {
  }
  triggerCellMouseEvent(name, event, cellData = this.getCellDataFromEvent(event)) {
    const me = this;
    if (cellData) {
      const column = me.columns.getById(cellData.columnId), eventData = {
        grid: me,
        record: cellData.record,
        column,
        cellSelector: cellData.cellSelector,
        cellElement: cellData.cellElement,
        target: event.target,
        event
      };
      me.trigger("cell" + StringHelper.capitalize(name), eventData);
      if (name === "click") {
        var _column$onCellClick;
        (_column$onCellClick = column.onCellClick) === null || _column$onCellClick === void 0 ? void 0 : _column$onCellClick.call(column, eventData);
      }
    }
  }
  onElementMouseDown(event) {
    const me = this, cellData = me.getCellDataFromEvent(event);
    me.skipFocusSelection = true;
    if (me.isScrollbarOrRowBorderOrSplitterClick(event)) {
      event.preventDefault();
    } else {
      me.triggerCellMouseEvent("mousedown", event, cellData);
      if (cellData && !event.defaultPrevented) {
        me.onFocusGesture(event);
      }
    }
  }
  isScrollbarOrRowBorderOrSplitterClick({
    target,
    x,
    y
  }) {
    if (target.closest(".b-grid-splitter") || target.matches(".b-grid-row, .b-virtual-width")) {
      return true;
    }
    if (target.matches(".b-vertical-overflow")) {
      const rect = target.getBoundingClientRect();
      return x > rect.right - DomHelper.scrollBarWidth;
    } else if (target.matches(".b-horizontal-overflow")) {
      const rect = target.getBoundingClientRect();
      return y > rect.bottom - DomHelper.scrollBarWidth - 1;
    }
  }
  onElementMouseMove(event) {
    this.mouseMoveEvent = event;
  }
  onElementMouseUp(event) {
  }
  onElementPointerDown(event) {
  }
  onElementPointerUp(event) {
  }
  onHandleElementClick(event) {
    if (this.trigger("beforeElementClick", {
      event
    }) !== false) {
      this.onElementClick(event);
    }
  }
  onElementClick(event) {
    const me = this, cellData = me.getCellDataFromEvent(event);
    if (cellData) {
      me.triggerCellMouseEvent("click", event, cellData);
    }
  }
  onFocusGesture(event) {
    const me = this, isContextMenu = event.button === 2, isTreeExpander = !isContextMenu && event.target.matches(".b-icon-tree-expand, .b-icon-tree-collapse"), isUnfocusedRightClick = !document.hasFocus() && BrowserHelper.isMac && isContextMenu;
    if (isTreeExpander || isUnfocusedRightClick) {
      event.preventDefault();
    } else {
      var _me$focusedCell;
      me.navigationEvent = event;
      if (isContextMenu || (_me$focusedCell = me.focusedCell) !== null && _me$focusedCell !== void 0 && _me$focusedCell.equals(new Location(event.target))) {
        me.focusCell(new Location(event.target));
      }
    }
  }
  onElementDblClick(event) {
    const {
      target
    } = event;
    this.triggerCellMouseEvent("dblClick", event);
    if (target.classList.contains("b-grid-header-resize-handle")) {
      const header = target.closest(".b-grid-header"), column = this.columns.getById(header.dataset.columnId);
      column.resizeToFitContent();
    }
  }
  onElementMouseOver(event) {
    if (!this.scrolling) {
      const shouldHover = typeof event.buttons !== "number" || event.buttons === 0, cellElement = event.target.closest(".b-grid-cell");
      if (shouldHover && !cellElement && event.target.classList.contains("b-grid-row")) {
        this.setHovered(document.elementFromPoint(event.x, event.y - 2).closest(".b-grid-cell"));
      }
      if (cellElement) {
        if (shouldHover) {
          this.setHovered(cellElement);
        }
        this.triggerCellMouseEvent("mouseOver", event);
      }
      this.trigger("mouseOver", {
        event
      });
    }
  }
  onElementMouseOut(event) {
    this.setHovered(null);
    if (!this.scrolling) {
      const cellElement = event.target.closest(".b-grid-cell");
      if (cellElement) {
        this.triggerCellMouseEvent("mouseOut", event);
      }
      this.trigger("mouseOut", {
        event
      });
    }
  }
  setHovered(cellElement) {
    var _me$columns$find, _me$checkboxSelection;
    const me = this, {
      selectionMode
    } = me, rowNumberColumnId = selectionMode.rowNumber && ((_me$columns$find = me.columns.find((c) => c.type == "rownumber")) === null || _me$columns$find === void 0 ? void 0 : _me$columns$find.id), checkboxSelectionColumnId = selectionMode.checkbox && ((_me$checkboxSelection = me.checkboxSelectionColumn) === null || _me$checkboxSelection === void 0 ? void 0 : _me$checkboxSelection.id);
    if (me._hoveredCell) {
      toggleHover(me._hoveredCell, false);
      const prevSelector = DomDataStore.get(me._hoveredCell), {
        row: prevRow
      } = prevSelector;
      if (prevRow && !prevRow.isDestroyed) {
        setCellHover(rowNumberColumnId, prevRow, false);
        setCellHover(checkboxSelectionColumnId, prevRow, false);
      }
      if (prevSelector !== null && prevSelector !== void 0 && prevSelector.columnId) {
        var _me$columns$getById;
        toggleHover((_me$columns$getById = me.columns.getById(prevSelector.columnId)) === null || _me$columns$getById === void 0 ? void 0 : _me$columns$getById.element, false);
      }
      me._hoveredCell = null;
    }
    if (me._hoveredRow && !me._hoveredRow.isDestroyed) {
      me._hoveredRow.removeCls("b-hover");
    }
    me._hoveredRow = null;
    if (cellElement && !me.scrolling) {
      const selector = DomDataStore.get(cellElement), {
        row
      } = selector;
      if (row) {
        if (selectionMode.cell && selector.columnId !== rowNumberColumnId && selector.columnId !== checkboxSelectionColumnId) {
          var _me$columns$getById2;
          toggleHover(cellElement);
          me._hoveredCell = cellElement;
          setCellHover(checkboxSelectionColumnId, row);
          setCellHover(rowNumberColumnId, row);
          toggleHover((_me$columns$getById2 = me.columns.getById(selector.columnId)) === null || _me$columns$getById2 === void 0 ? void 0 : _me$columns$getById2.element);
        } else {
          me._hoveredRow = row;
          row.addCls("b-hover");
        }
      }
    }
  }
  keyMapOnKeyDown(event) {
    this.onElementKeyDown(event);
    super.keyMapOnKeyDown(event);
  }
  onElementKeyDown(event) {
    if (event.handled) {
      return;
    }
    const me = this, focusedCell = me.focusedCell;
    if (focusedCell !== null && focusedCell !== void 0 && focusedCell.isCell && !focusedCell.isActionable) {
      var _me$columns$getById$o, _me$columns$getById3;
      const cellElement = focusedCell.cell;
      (_me$columns$getById$o = (_me$columns$getById3 = me.columns.getById(cellElement.dataset.columnId)).onCellKeyDown) === null || _me$columns$getById$o === void 0 ? void 0 : _me$columns$getById$o.call(_me$columns$getById3, {
        event,
        cellElement
      });
    }
  }
  undoRedoKeyPress(event) {
    var _this$features$cellEd;
    const {
      stm
    } = this.store;
    if (stm && this.enableUndoRedoKeys && !((_this$features$cellEd = this.features.cellEdit) !== null && _this$features$cellEd !== void 0 && _this$features$cellEd.isEditing)) {
      stm.onUndoKeyPress(event);
      return true;
    }
    return false;
  }
  clickCellByKey(event) {
    const me = this, focusedCell = me.focusedCell, cellElement = focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.cell, column = me.columns.getById(cellElement.dataset.columnId);
    if (focusedCell !== null && focusedCell !== void 0 && focusedCell.isCell && !focusedCell.isActionable) {
      if (column.onCellClick) {
        column.onCellClick({
          grid: me,
          column,
          record: me.store.getById(focusedCell.id),
          cellElement,
          target: event.target,
          event
        });
        return true;
      }
    }
    return false;
  }
  onElementKeyPress(event) {
  }
  onElementKeyUp(event) {
  }
  onElementContextMenu(event) {
    const me = this, cellData = me.getCellDataFromEvent(event);
    if (cellData) {
      me.triggerCellMouseEvent("contextMenu", event, cellData);
      if (DomHelper.isTouchEvent) {
        me.onFocusGesture(event);
      }
    }
  }
  onInternalResize(element, width, height, oldWidth, oldHeight) {
    const me = this;
    if (me._devicePixelRatio && me._devicePixelRatio !== globalThis.devicePixelRatio) {
      DomHelper.resetScrollBarWidth();
    }
    me._devicePixelRatio = globalThis.devicePixelRatio;
    me._bodyRectangle = Rectangle.client(me.bodyContainer);
    super.onInternalResize(...arguments);
    if (height !== oldHeight) {
      me._bodyHeight = me.bodyContainer.offsetHeight;
      if (me.isPainted) {
        me.rowManager.initWithHeight(me._bodyHeight);
      }
    }
    me.refreshVirtualScrollbars();
    if (width !== oldWidth) {
      me.setTimeout(() => {
        if (!me.isDestroyed) {
          me.updateResponsive(width, oldWidth);
        }
      }, 0);
    }
  }
  get widgetClass() {
  }
};
var validConfigTypes = {
  string: 1,
  object: 1,
  function: 1
};
var GridFeatures = (Target) => class GridFeatures extends (Target || Base) {
  static get $name() {
    return "GridFeatures";
  }
  set features(features) {
    const me = this, defaultFeatures = GridFeatureManager.getInstanceDefaultFeatures(this);
    features = me._features = ObjectHelper.assign({}, features);
    if (defaultFeatures) {
      Object.keys(defaultFeatures).forEach((feature) => {
        if (!(feature in features)) {
          features[feature] = true;
        }
      });
    }
    const registeredInstanceFeatures = GridFeatureManager.getInstanceFeatures(this);
    for (const featureName of Object.keys(features)) {
      const config = features[featureName];
      if (config) {
        const throwIfError = !globalThis.__bryntum_code_editor_changed;
        if (StringHelper.uncapitalize(featureName) !== featureName) {
          const errorMessage = `Invalid feature name '${featureName}', must start with a lowercase letter`;
          if (throwIfError) {
            throw new Error(errorMessage);
          }
          console.error(errorMessage);
          me._errorDuringConfiguration = errorMessage;
        }
        const featureClass = registeredInstanceFeatures[featureName];
        if (!featureClass) {
          const errorMessage = `Feature '${featureName}' not available, make sure you have imported it`;
          if (throwIfError) {
            throw new Error(errorMessage);
          }
          console.error(errorMessage);
          me._errorDuringConfiguration = errorMessage;
          return;
        }
        Reflect.defineProperty(features, featureName, me.createFeatureInitializer(features, featureName, featureClass, config));
      }
    }
  }
  get features() {
    return this._features;
  }
  createFeatureInitializer(features, featureName, featureClass, config) {
    const constructorArgs = [this], construct = featureClass.prototype.construct;
    if (config === true) {
      config = {};
    }
    if (validConfigTypes[typeof config]) {
      constructorArgs[1] = config;
    }
    return {
      configurable: true,
      get() {
        delete features[featureName];
        featureClass.prototype.construct = function(...args) {
          features[featureName] = this;
          construct.apply(this, args);
          featureClass.prototype.construct = construct;
        };
        return new featureClass(...constructorArgs);
      }
    };
  }
  hasFeature(name) {
    const {
      features
    } = this;
    if (features) {
      const featureProp = Object.getOwnPropertyDescriptor(this.features, name);
      if (featureProp) {
        return Boolean(featureProp.value || featureProp.get);
      }
    }
    return false;
  }
  hasActiveFeature(name) {
    var _this$features, _this$features2;
    return Boolean(((_this$features = this.features) === null || _this$features === void 0 ? void 0 : _this$features[name]) && !((_this$features2 = this.features) !== null && _this$features2 !== void 0 && _this$features2[name].disabled));
  }
  getConfigValue(name, options) {
    if (name === "features") {
      const result = {};
      for (const feature in this.features) {
        var _this$features$featur, _this$features$featur2, _this$features$featur3;
        const featureConfig = (_this$features$featur = this.features[feature]) === null || _this$features$featur === void 0 ? void 0 : (_this$features$featur2 = (_this$features$featur3 = _this$features$featur).getCurrentConfig) === null || _this$features$featur2 === void 0 ? void 0 : _this$features$featur2.call(_this$features$featur3, options);
        if (featureConfig) {
          if (ObjectHelper.isEmpty(featureConfig)) {
            if (!GridFeatureManager.isDefaultFeatureForInstance(this.features[feature].constructor, this)) {
              result[feature] = true;
            }
          } else {
            result[feature] = featureConfig;
          }
        } else {
          result[feature] = false;
        }
      }
      return result;
    }
    return super.getConfigValue(name, options);
  }
  get widgetClass() {
  }
};
var defaultFocusOptions = Object.freeze({});
var disableScrolling = Object.freeze({
  x: false,
  y: false
});
var containedFocusable = function(e) {
  if (!this.focusableFinderCell.contains(e)) {
    return DomHelper.NodeFilter.FILTER_REJECT;
  }
  if (DomHelper.isFocusable(e) && !e.disabled) {
    return DomHelper.NodeFilter.FILTER_ACCEPT;
  }
  return DomHelper.NodeFilter.FILTER_SKIP;
};
var GridNavigation = (Target) => {
  var _class;
  return _class = class GridNavigation extends (Target || Base) {
    static get $name() {
      return "GridNavigation";
    }
    onStoreRecordIdChange(event) {
      var _super$onStoreRecordI;
      (_super$onStoreRecordI = super.onStoreRecordIdChange) === null || _super$onStoreRecordI === void 0 ? void 0 : _super$onStoreRecordI.call(this, event);
      const {
        focusedCell
      } = this, {
        oldValue,
        value
      } = event;
      if (focusedCell && focusedCell.id === oldValue) {
        focusedCell._id = value;
      }
    }
    onFocusedRowDerender() {
      const me = this, {
        focusedCell
      } = me;
      if ((focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.id) != null && focusedCell.cell) {
        const isActive = focusedCell.cell.contains(DomHelper.getActiveElement(me));
        if (me.hideHeaders) {
          if (isActive) {
            me.revertFocus();
          }
        } else {
          const headerContext = me.normalizeCellContext({
            rowIndex: -1,
            columnIndex: isActive ? focusedCell.columnIndex : 0
          });
          if (isActive) {
            me.focusCell(headerContext);
          } else {
            headerContext.cell.tabIndex = 0;
          }
        }
        focusedCell.cell.tabIndex = -1;
      }
    }
    navigateFirstCell() {
      this.focusCell(Location.FIRST_CELL);
    }
    navigateFirstColumn() {
      this.focusCell(Location.FIRST_COLUMN);
    }
    navigateLastCell() {
      this.focusCell(Location.LAST_CELL);
    }
    navigateLastColumn() {
      this.focusCell(Location.LAST_COLUMN);
    }
    navigatePrevPage() {
      this.focusCell(Location.PREV_PAGE);
    }
    navigateNextPage() {
      this.focusCell(Location.NEXT_PAGE);
    }
    activateHeader(keyEvent) {
      if (keyEvent.target.classList.contains("b-grid-header") && this.focusedCell.isColumnHeader) {
        var _column$onKeyDown;
        const {
          column
        } = this.focusedCell;
        (_column$onKeyDown = column.onKeyDown) === null || _column$onKeyDown === void 0 ? void 0 : _column$onKeyDown.call(column, keyEvent);
        this.getHeaderElement(column.id).click();
      }
      return false;
    }
    onEscape(keyEvent) {
      const {
        focusedCell
      } = this;
      if (!keyEvent.target.closest(".b-dragging") && focusedCell !== null && focusedCell !== void 0 && focusedCell.isActionable) {
        keyEvent.stopImmediatePropagation();
        this._focusedCell = null;
        this.focusCell({
          rowIndex: focusedCell.rowIndex,
          column: focusedCell.column
        }, {
          disableActionable: true
        });
      }
    }
    onTab(keyEvent) {
      const {
        target
      } = keyEvent, {
        focusedCell,
        bodyElement
      } = this, {
        isActionable,
        actionTargets
      } = focusedCell, isEditable = isActionable && DomHelper.isEditable(target) && !target.readOnly;
      if (isEditable && target === actionTargets[actionTargets.length - 1]) {
        keyEvent.preventDefault();
        this.navigateRight(keyEvent);
      } else if (!isActionable || target === actionTargets[actionTargets.length - 1]) {
        bodyElement.style.display = "none";
        this.requestAnimationFrame(() => bodyElement.style.display = "");
        return false;
      }
    }
    onShiftTab(keyEvent) {
      const me = this, {
        target
      } = keyEvent, {
        focusedCell,
        bodyElement
      } = me, {
        cell,
        isActionable,
        actionTargets
      } = focusedCell, isEditable = isActionable && DomHelper.isEditable(target) && !target.readOnly, onFirstCell = focusedCell.columnIndex === 0 && focusedCell.rowIndex === (me.hideHeaders ? 0 : -1);
      if (!onFirstCell && isEditable && target === actionTargets[0]) {
        keyEvent.preventDefault();
        me.navigateLeft(keyEvent);
      } else if (!isActionable || target === actionTargets[0]) {
        const f = !onFirstCell && !me.hideHeaders && me.focusCell({
          rowIndex: -1,
          column: 0
        }, {
          disableActionable: true
        });
        if (f) {
          f.cell.tabIndex = -1;
          cell.tabIndex = 0;
          me._focusedCell = focusedCell;
        } else {
          bodyElement.style.display = "none";
          me.requestAnimationFrame(() => bodyElement.style.display = "");
        }
        return false;
      }
    }
    onSpace(keyEvent) {
      if (!this.focusedCell.isActionable) {
        keyEvent.preventDefault();
      }
      return false;
    }
    get focusedCell() {
      return this._focusedCell;
    }
    get isActionableLocation() {
      var _this$_focusedCell;
      return (_this$_focusedCell = this._focusedCell) === null || _this$_focusedCell === void 0 ? void 0 : _this$_focusedCell.isActionable;
    }
    set focusedCell(cellSelector) {
      this.focusCell(cellSelector);
    }
    get focusedRecord() {
      var _this$_focusedCell2;
      return (_this$_focusedCell2 = this._focusedCell) === null || _this$_focusedCell2 === void 0 ? void 0 : _this$_focusedCell2.record;
    }
    get cellCSSSelector() {
      const cell = this._focusedCell;
      return cell ? `[data-index=${cell.rowIndex}] [data-column-id=${cell.columnId}]` : "";
    }
    afterHide() {
      super.afterHide(...arguments);
      this.lastFocusedCell = null;
    }
    isFocused(cellSelector) {
      var _this$_focusedCell3;
      return Boolean((_this$_focusedCell3 = this._focusedCell) === null || _this$_focusedCell3 === void 0 ? void 0 : _this$_focusedCell3.equals(this.normalizeCellContext(cellSelector)));
    }
    get focusElement() {
      if (!this.isDestroying) {
        let focusCell;
        if (this.store.count && this._focusedCell) {
          focusCell = this._focusedCell.target;
        } else {
          var _this$_focusedCell4;
          focusCell = this.normalizeCellContext({
            rowIndex: -1,
            columnIndex: ((_this$_focusedCell4 = this._focusedCell) === null || _this$_focusedCell4 === void 0 ? void 0 : _this$_focusedCell4.columnIndex) || 0
          }).target;
        }
        const superFocusEl = super.focusElement;
        if (superFocusEl && (!focusCell || focusCell.compareDocumentPosition(superFocusEl) === Node.DOCUMENT_POSITION_PRECEDING)) {
          return superFocusEl;
        }
        return focusCell;
      }
    }
    onPaint({
      firstPaint
    }) {
      var _super$onPaint;
      const me = this;
      (_super$onPaint = super.onPaint) === null || _super$onPaint === void 0 ? void 0 : _super$onPaint.call(this, ...arguments);
      const defaultFocus = this.normalizeCellContext({
        rowIndex: me.hideHeaders ? 0 : -1,
        column: me.hideHeaders ? 0 : me.columns.find((col) => !col.hidden && col.isFocusable)
      });
      if (defaultFocus.cell) {
        me._focusedCell = defaultFocus;
        const {
          target
        } = defaultFocus;
        if (target === defaultFocus.cell) {
          defaultFocus.cell.tabIndex = 0;
        }
      }
    }
    onGridBodyFocusIn(focusEvent) {
      const me = this, {
        bodyElement
      } = me, lastFocusedCell = me.focusedCell, lastTarget = (lastFocusedCell === null || lastFocusedCell === void 0 ? void 0 : lastFocusedCell.initialTarget) || (lastFocusedCell === null || lastFocusedCell === void 0 ? void 0 : lastFocusedCell.target), {
        target,
        relatedTarget
      } = focusEvent, targetCell = target.closest(me.focusableSelector);
      if (targetCell && (!GlobalEvents$1.currentMouseDown || GlobalEvents$1.isMouseDown(0) || GlobalEvents$1.isMouseDown(2))) {
        var _me$onCellNavigate;
        const cellSelector = new Location(target), {
          cell
        } = cellSelector, lastCell = lastFocusedCell === null || lastFocusedCell === void 0 ? void 0 : lastFocusedCell.cell, actionTargets = cellSelector.actionTargets = me.findFocusables(targetCell), doSelect = (!me._fromFocusCell || me.selectOnFocus) && (target === cell || me._selectActionCell) && !(target !== null && target !== void 0 && target._isRevertingFocus);
        if (!me.store.getById(targetCell.parentNode.dataset.id) && cell !== targetCell) {
          cell.focus({
            preventScroll: true
          });
          return;
        }
        if (target.matches(me.focusableSelector)) {
          if (me.disableActionable) {
            cellSelector._target = cell;
          } else if (actionTargets.length) {
            var _GlobalEvents$current;
            me._selectActionCell = ((_GlobalEvents$current = GlobalEvents$1.currentMouseDown) === null || _GlobalEvents$current === void 0 ? void 0 : _GlobalEvents$current.target) === target;
            actionTargets[0].focus();
            delete me._selectActionCell;
            return;
          }
        } else {
          var _GlobalEvents$current2;
          if (lastFocusedCell !== null && lastFocusedCell !== void 0 && lastFocusedCell.target && relatedTarget && (!GlobalEvents$1.isMouseDown() || !bodyElement.contains((_GlobalEvents$current2 = GlobalEvents$1.currentMouseDown) === null || _GlobalEvents$current2 === void 0 ? void 0 : _GlobalEvents$current2.target)) && !bodyElement.contains(relatedTarget) && !cellSelector.equals(lastFocusedCell)) {
            lastTarget.focus();
            return;
          }
          cellSelector._target = target;
        }
        if (lastCell) {
          lastCell.classList.remove("b-focused");
          lastCell.tabIndex = -1;
        }
        if (cell) {
          cell.classList.add("b-focused");
          cellSelector.column.onCellFocus(cellSelector);
          if (cell === target) {
            cell.tabIndex = 0;
          }
          if (cell.contains(focusEvent.relatedTarget)) {
            if (lastTarget === target) {
              return;
            }
          }
        }
        me._focusedCell = cellSelector;
        (_me$onCellNavigate = me.onCellNavigate) === null || _me$onCellNavigate === void 0 ? void 0 : _me$onCellNavigate.call(me, me, lastFocusedCell, cellSelector, doSelect);
        me.trigger("navigate", {
          lastFocusedCell,
          focusedCell: cellSelector,
          event: focusEvent
        });
      } else {
        lastTarget === null || lastTarget === void 0 ? void 0 : lastTarget.focus();
      }
    }
    findFocusables(cell) {
      const {
        focusableFinder
      } = this, result = [];
      focusableFinder.currentNode = this.focusableFinderCell = cell;
      for (let focusable = focusableFinder.nextNode(); focusable; focusable = focusableFinder.nextNode()) {
        result.push(focusable);
      }
      return result;
    }
    get focusableFinder() {
      const me = this;
      if (!me._focusableFinder) {
        me._focusableFinder = me.setupTreeWalker(me.bodyElement, DomHelper.NodeFilter.SHOW_ELEMENT, {
          acceptNode: containedFocusable.bind(me)
        });
      }
      return me._focusableFinder;
    }
    restoreActiveItem(item = this._focusedCell) {
      if (this.rowManager.count) {
        if (!isNaN(item)) {
          item = this.store.getAt(item);
        } else if (!item.isModel) {
          item = this.store.getById(item);
        }
        return this.focusCell(item);
      }
    }
    focusCell(cellSelector, options = defaultFocusOptions) {
      var _cellSelector, _cellSelector2;
      const me = this, {
        _focusedCell
      } = me, {
        scroll,
        disableActionable
      } = options;
      if (((_cellSelector = cellSelector) === null || _cellSelector === void 0 ? void 0 : _cellSelector.rowIndex) === -1 && me.hideHeaders) {
        me.revertFocus();
        return;
      }
      cellSelector = typeof cellSelector === "number" && _focusedCell !== null && _focusedCell !== void 0 && _focusedCell.isLocation ? _focusedCell.move(cellSelector) : me.normalizeCellContext(cellSelector);
      const doSelect = "doSelect" in options ? options.doSelect : !cellSelector.isActionable || cellSelector.initialTarget === cellSelector.cell;
      if (cellSelector.equals(_focusedCell)) {
        var _me$onCellNavigate2;
        (_me$onCellNavigate2 = me.onCellNavigate) === null || _me$onCellNavigate2 === void 0 ? void 0 : _me$onCellNavigate2.call(me, me, _focusedCell, cellSelector, doSelect);
        return _focusedCell;
      }
      const subGrid = me.getSubGridFromColumn(cellSelector.columnId), {
        cell
      } = cellSelector, testCell = cell || me.getCell({
        rowIndex: me.rowManager.topIndex,
        columnId: cellSelector.columnId
      }), subGridRect = Rectangle.from(subGrid.element), bodyRect = Rectangle.from(me.bodyElement), cellRect = Rectangle.from(testCell).moveTo(null, subGridRect.y);
      if (scroll === false || cellSelector.rowIndex === -1) {
        options = Object.assign({}, options, disableScrolling);
      } else {
        options = Object.assign({}, options, scroll);
        if (cellRect.width > subGridRect.width || cellRect.height > bodyRect.height) {
          options.x = options.y = false;
        } else {
          options.column = cellSelector.columnId;
        }
        me.scrollRowIntoView(cellSelector.id, options);
      }
      if (me._hoveredRow || me._hoveredCell) {
        me.setHovered();
      }
      me.disableActionable = disableActionable;
      me.selectOnFocus = doSelect;
      me._fromFocusCell = true;
      (_cellSelector2 = cellSelector[disableActionable ? "cell" : "target"]) === null || _cellSelector2 === void 0 ? void 0 : _cellSelector2.focus();
      me.disableActionable = me.selectOnFocus = false;
      delete me._fromFocusCell;
      return cellSelector;
    }
    blurCell(cellSelector) {
      const me = this, cell = me.getCell(cellSelector);
      if (cell) {
        cell.classList.remove("b-focused");
      }
    }
    clearFocus(fullClear) {
      const me = this;
      if (me._focusedCell) {
        me.lastFocusedCell = fullClear ? null : me._focusedCell;
        me.blurCell(me._focusedCell);
        me._focusedCell = null;
      }
    }
    internalNextPrevCell(next = true) {
      const me = this, cellSelector = me._focusedCell;
      if (cellSelector) {
        return me.focusCell({
          id: cellSelector.id,
          columnId: me.columns.getAdjacentVisibleLeafColumn(cellSelector.columnId, next, true).id
        });
      }
      return null;
    }
    navigateRight() {
      var _arguments$;
      if ((_arguments$ = arguments[0]) !== null && _arguments$ !== void 0 && _arguments$.fromKeyMap) {
        return this.focusCell(this.rtl ? Location.PREV_CELL : Location.NEXT_CELL);
      }
      if (arguments[0]) {
        VersionHelper.deprecate("Grid", "6.0.0", "Event argument removed, unused param");
      }
      return this.internalNextPrevCell(!this.rtl);
    }
    navigateLeft() {
      var _arguments$2;
      if ((_arguments$2 = arguments[0]) !== null && _arguments$2 !== void 0 && _arguments$2.fromKeyMap) {
        return this.focusCell(this.rtl ? Location.NEXT_CELL : Location.PREV_CELL);
      }
      if (arguments[0]) {
        VersionHelper.deprecate("Grid", "6.0.0", "Event argument removed, unused param");
      }
      return this.internalNextPrevCell(Boolean(this.rtl));
    }
    internalNextPrevRow(next, skipSpecialRows = true, moveToHeader = true) {
      const me = this, cell = me._focusedCell;
      if (!cell)
        return false;
      const record = me.store[`get${next ? "Next" : "Prev"}`](cell.id, false, skipSpecialRows);
      if (record) {
        return me.focusCell({
          id: record.id,
          columnId: cell.columnId,
          scroll: {
            x: false
          }
        });
      } else if (!next && moveToHeader && !cell.isColumnHeader) {
        this.clearFocus();
        return this.getHeaderElement(cell.columnId).focus();
      }
    }
    navigateDown() {
      var _arguments$3;
      if ((_arguments$3 = arguments[0]) !== null && _arguments$3 !== void 0 && _arguments$3.fromKeyMap) {
        return this.focusCell(Location.DOWN);
      }
      if (arguments[0]) {
        VersionHelper.deprecate("Grid", "6.0.0", "Event argument removed, unused param");
      }
      return this.internalNextPrevRow(true, false);
    }
    navigateUp() {
      var _arguments$4;
      if ((_arguments$4 = arguments[0]) !== null && _arguments$4 !== void 0 && _arguments$4.fromKeyMap) {
        return this.focusCell(Location.UP);
      }
      if (arguments[0]) {
        VersionHelper.deprecate("Grid", "6.0.0", "Event argument removed, unused param");
      }
      return this.internalNextPrevRow(false, false);
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "configurable", {
    focusable: false,
    focusableSelector: ".b-grid-cell,.b-grid-header.b-depth-0",
    keyMap: {
      ArrowUp: {
        handler: "navigateUp",
        weight: 10
      },
      ArrowRight: {
        handler: "navigateRight",
        weight: 10
      },
      ArrowDown: {
        handler: "navigateDown",
        weight: 10
      },
      ArrowLeft: {
        handler: "navigateLeft",
        weight: 10
      },
      "Ctrl+Home": "navigateFirstCell",
      Home: "navigateFirstColumn",
      "Ctrl+End": "navigateLastCell",
      End: "navigateLastColumn",
      PageUp: "navigatePrevPage",
      PageDown: "navigateNextPage",
      Enter: "activateHeader",
      Escape: {
        handler: "onEscape",
        weight: 10
      },
      "Shift+Tab": {
        handler: "onShiftTab",
        preventDefault: false
      },
      Tab: {
        handler: "onTab",
        preventDefault: false
      },
      " ": {
        handler: "onSpace",
        preventDefault: false
      }
    }
  }), _class;
};
var GridResponsive = (Target) => class GridResponsive extends (Target || Base) {
  static get $name() {
    return "GridResponsive";
  }
  static get defaultConfig() {
    return {
      responsiveLevels: Object.freeze({
        small: 400,
        medium: 600,
        large: "*"
      })
    };
  }
  getClosestBiggerLevel(width) {
    const me = this, levels = Object.keys(ObjectHelper.assign({}, me.responsiveLevels));
    let useLevel = null, minDelta = 99995, biggestLevel = null;
    levels.forEach((level) => {
      let levelSize = me.responsiveLevels[level];
      if (!["number", "string"].includes(typeof levelSize)) {
        levelSize = levelSize.levelWidth;
      }
      if (levelSize === "*") {
        biggestLevel = level;
      } else if (width < levelSize) {
        const delta = levelSize - width;
        if (delta < minDelta) {
          minDelta = delta;
          useLevel = level;
        }
      }
    });
    return useLevel || biggestLevel;
  }
  get responsiveLevel() {
    return this.getClosestBiggerLevel(this.width);
  }
  updateResponsive(width, oldWidth) {
    const me = this, oldLevel = me.getClosestBiggerLevel(oldWidth), level = me.getClosestBiggerLevel(width);
    if (oldWidth === 0 || oldLevel !== level) {
      const levelConfig = me.responsiveLevels[level];
      if (!["number", "string"].includes(typeof levelConfig)) {
        me.applyState(levelConfig);
      }
      me.columns.forEach((column) => {
        const levels = column.responsiveLevels;
        if (levels) {
          if (levels[level]) {
            column.applyState(levels[level]);
          } else if (levels["*"]) {
            column.applyState(levels["*"]);
          }
        }
      });
      me.element.classList.remove("b-responsive-" + oldLevel);
      me.element.classList.add("b-responsive-" + level);
      me.trigger("responsive", {
        level,
        width,
        oldLevel,
        oldWidth
      });
    }
  }
  get widgetClass() {
  }
};
var validIdTypes = {
  string: 1,
  number: 1
};
var isDataLoadAction = {
  dataset: 1,
  batch: 1
};
var GridSelection = (Target) => {
  var _class;
  return _class = class GridSelection extends (Target || Base) {
    static get $name() {
      return "GridSelection";
    }
    construct(config) {
      this._selectedCells = [];
      super.construct(config);
      if (config !== null && config !== void 0 && config.selectedRecords) {
        this.selectedRecords = config.selectedRecords;
      }
    }
    getDefaultGridSelection(clas) {
      if (clas.$name === "GridSelection") {
        return clas.configurable.selectionMode;
      } else if (clas.superclass) {
        return this.getDefaultGridSelection(clas.superclass);
      }
    }
    changeSelectionMode(mode) {
      const me = this;
      if (me.selectionMode) {
        ObjectHelper.assign(me.selectionMode, mode);
        return me.selectionMode;
      }
      me.$defaultGridSelection = me.getDefaultGridSelection(me.constructor);
      return new Proxy(mode, {
        set(obj, prop, value) {
          const old = ObjectHelper.assign({}, obj);
          obj[prop] = value;
          me.updateSelectionMode(obj, old);
          return true;
        }
      });
    }
    updateSelectionMode(mode, oldMode = this.$defaultGridSelection) {
      const me = this, {
        columns,
        checkboxSelectionColumn
      } = me, changed = {}, {
        rowReorder
      } = me.features;
      for (const property in mode) {
        if (mode[property] != oldMode[property]) {
          changed[property] = mode[property];
        }
      }
      if (mode.rowCheckboxSelection && !mode.checkboxOnly) {
        mode.checkboxOnly = true;
        delete mode.rowCheckboxSelection;
      }
      if (changed.column) {
        mode.cell = true;
        mode.multiSelect = true;
      }
      if (changed.cell) {
        mode.checkboxOnly = false;
      }
      if (changed.cell === false) {
        mode.column = false;
      }
      if (changed.checkboxOnly) {
        if (!mode.checkbox) {
          mode.checkbox = true;
        }
        mode.cell = false;
      }
      if (changed.checkbox === false) {
        changed.checkboxOnly = false;
        changed.showCheckAll = false;
      }
      if (changed.showCheckAll) {
        mode.checkbox = true;
        mode.multiSelect = true;
      }
      if (changed.includeChildren || changed.includeParents) {
        mode.multiSelect = true;
      }
      if (changed.multiSelect === false) {
        mode.column = mode.showCheckAll = mode.dragSelect = mode.includeChildren = mode.includeParents = false;
      }
      if (changed.dragSelect) {
        if (rowReorder !== null && rowReorder !== void 0 && rowReorder.enabled && rowReorder.gripOnly !== true) {
          rowReorder.showGrip = rowReorder.gripOnly = true;
        }
        mode.multiSelect = true;
        me._selectionListenersDetachers = {};
      }
      if (changed.dragSelect === false && me._selectionListenersDetachers) {
        var _me$_selectionListene, _me$_selectionListene2;
        (_me$_selectionListene = (_me$_selectionListene2 = me._selectionListenersDetachers).selectiondrag) === null || _me$_selectionListene === void 0 ? void 0 : _me$_selectionListene.call(_me$_selectionListene2);
        delete me._selectionListenersDetachers.selectiondrag;
      }
      if (oldMode && (changed.cell !== void 0 || changed.deselectFilteredOutRecords !== void 0 || changed.multiSelect !== void 0)) {
        me.deselectAll();
      }
      if (changed.rowNumber) {
        if (!columns.findRecord("type", "rownumber")) {
          columns.insert(0, _objectSpread2(_objectSpread2({}, typeof mode.rowNumber == "object" ? mode.rowNumber : {}), {}, {
            type: "rownumber"
          }));
          me._selectionAddedRowNumberColumn = true;
        }
      } else if (changed.rowNumber === false && me._selectionAddedRowNumberColumn) {
        columns.remove(columns.findRecord("type", "rownumber"));
        delete me._selectionAddedRowNumberColumn;
      }
      if (mode.checkbox !== (oldMode === null || oldMode === void 0 ? void 0 : oldMode.checkbox) || mode.checkbox && mode.showCheckAll !== (oldMode === null || oldMode === void 0 ? void 0 : oldMode.showCheckAll)) {
        if (oldMode) {
          me.deselectAll();
        }
        if (me.isConfiguring) {
          me.shouldInitCheckboxSelection = true;
        } else {
          me.initCheckboxSelection();
        }
      }
      if (oldMode && mode.checkbox && oldMode.checkbox && mode.checkboxIndex !== oldMode.checkboxIndex && checkboxSelectionColumn) {
        checkboxSelectionColumn.parent.insertChild(checkboxSelectionColumn, columns.getAt(me.checkboxSelectionColumnInsertIndex));
      }
      me.trigger("selectionModeChange", ObjectHelper.clone(mode));
      me.afterSelectionModeChange(mode);
    }
    afterConfigure() {
      if (this.shouldInitCheckboxSelection) {
        this.shouldInitCheckboxSelection = false;
        this.initCheckboxSelection();
      }
      super.afterConfigure();
    }
    initCheckboxSelection() {
      const me = this, {
        selectionMode,
        columns,
        checkboxSelectionColumn
      } = me, {
        checkbox
      } = selectionMode;
      if (checkboxSelectionColumn) {
        me.checkboxSelectionColumn = null;
        columns.remove(checkboxSelectionColumn);
      }
      if (checkbox) {
        var _me$items, _me$items$;
        const checkColumnClass = ColumnStore.getColumnClass("check"), config = checkbox === true ? null : checkbox;
        if (!checkColumnClass) {
          throw new Error("CheckColumn must be imported for checkbox selection mode to work");
        }
        const col = me.checkboxSelectionColumn = new checkColumnClass(ObjectHelper.assign({
          id: `${me.id}-selection-column`,
          width: "4em",
          minWidth: "4em",
          field: null,
          sortable: false,
          filterable: false,
          cellCls: "b-checkbox-selection",
          region: (_me$items = me.items) === null || _me$items === void 0 ? void 0 : (_me$items$ = _me$items[0]) === null || _me$items$ === void 0 ? void 0 : _me$items$.region,
          showCheckAll: selectionMode.showCheckAll,
          draggable: false,
          resizable: false,
          widgets: [{
            type: "checkbox",
            valueProperty: "checked",
            ariaLabel: "L{Checkbox.toggleRowSelect}"
          }]
        }, config), columns, {
          isSelectionColumn: true
        });
        col.meta.depth = 0;
        col._grid = me;
        const checkboxRenderer = col.renderer;
        col.renderer = (renderData) => {
          renderData.value = me.isSelected(renderData.record);
          checkboxRenderer.call(col, renderData);
        };
        col.ion({
          toggle: "onCheckChange",
          toggleAll: "onCheckAllChange",
          thisObj: me
        });
        columns.insert(me.checkboxSelectionColumnInsertIndex, col);
      }
    }
    get checkboxSelectionColumnInsertIndex() {
      const {
        columns
      } = this;
      let {
        checkboxIndex
      } = this.selectionMode;
      if (!checkboxIndex) {
        checkboxIndex = columns.indexOf(columns.findRecord("type", "rownumber")) + 1;
      } else if (typeof checkboxIndex === "string") {
        checkboxIndex = columns.indexOf(columns.getById(checkboxIndex));
      }
      return checkboxIndex;
    }
    afterSelectionChange() {
    }
    afterSelectionModeChange() {
    }
    changeSelectedRecordCollection(collection) {
      return collection instanceof Collection ? collection : new Collection(collection);
    }
    updateSelectedRecordCollection(collection) {
      collection.ion({
        change: "onSelectedRecordCollectionChange",
        thisObj: this
      });
    }
    onSelectedRecordCollectionChange({
      added = [],
      removed
    }) {
      if (!this.selectedRecordCollection._fromSelection) {
        added = added.filter((row) => this.isSelectable(row));
        this.performSelection({
          selectedCells: [],
          deselectedCells: [],
          selectedRecords: added,
          deselectedRecords: removed
        });
      }
    }
    changeSelectedRecordCollectionSilent(fn) {
      this.selectedRecordCollection._fromSelection = true;
      const result = fn(this.selectedRecordCollection);
      delete this.selectedRecordCollection._fromSelection;
      return result;
    }
    bindStore(store) {
      var _super$bindStore;
      this.detachListeners("selectionStoreFilter");
      store.ion({
        name: "selectionStoreFilter",
        filter: "onStoreFilter",
        thisObj: this
      });
      (_super$bindStore = super.bindStore) === null || _super$bindStore === void 0 ? void 0 : _super$bindStore.call(this, store);
    }
    unbindStore(oldStore) {
      this.detachListeners("selectionStoreFilter");
      super.unbindStore(oldStore);
    }
    onStoreFilter({
      source
    }) {
      const me = this, deselect = [];
      for (const selectedRecord of me.selectedRecords) {
        if (!source.includes(selectedRecord)) {
          deselect.push(selectedRecord);
        }
      }
      const selectionChange = me.prepareSelection(me.selectionMode.deselectFilteredOutRecords ? deselect : []);
      if (me.isCellSelectionMode) {
        const {
          deselectedCells
        } = me.prepareSelection(me.getSelectedCellsForRecords(deselect));
        if (deselectedCells !== null && deselectedCells !== void 0 && deselectedCells.length) {
          selectionChange.deselectedCells = (selectionChange.deselectedCells || []).concat(deselectedCells);
        }
      }
      if (selectionChange.deselectedCells.length || selectionChange.deselectedRecords.length) {
        me.performSelection(selectionChange, false);
        me.updateCheckboxHeader();
      }
    }
    onStoreRecordIdChange({
      record,
      oldValue
    }) {
      var _super$onStoreRecordI;
      (_super$onStoreRecordI = super.onStoreRecordIdChange) === null || _super$onStoreRecordI === void 0 ? void 0 : _super$onStoreRecordI.call(this, ...arguments);
      const item = this.selectedRecordCollection.get(oldValue);
      if (item === record) {
        this.selectedRecordCollection.rebuildIndices();
      }
    }
    onStoreRemove(event) {
      var _super$onStoreRemove;
      (_super$onStoreRemove = super.onStoreRemove) === null || _super$onStoreRemove === void 0 ? void 0 : _super$onStoreRemove.call(this, event);
      if (!event.isCollapse) {
        const me = this, deselectedRecords = event.records.filter((rec) => this.isSelected(rec));
        if (deselectedRecords.length) {
          const selectionChange = me.prepareSelection(deselectedRecords);
          if (me.isCellSelectionMode) {
            const {
              deselectedCells
            } = me.prepareSelection(me.getSelectedCellsForRecords(deselectedRecords));
            if (deselectedCells !== null && deselectedCells !== void 0 && deselectedCells.length) {
              selectionChange.deselectedCells = (selectionChange.deselectedCells || []).concat(deselectedCells);
            }
          }
          me.performSelection(selectionChange);
        }
      }
    }
    onStoreDataChange({
      action,
      source: store
    }) {
      var _super$onStoreDataCha;
      const me = this, {
        selectionMode
      } = me;
      let selectionChange;
      (_super$onStoreDataCha = super.onStoreDataChange) === null || _super$onStoreDataCha === void 0 ? void 0 : _super$onStoreDataCha.call(this, ...arguments);
      if (action === "pageLoad") {
        if (!selectionMode.preserveSelectionOnPageChange) {
          selectionChange = me.prepareSelection(null, null, true);
        }
        me.updateCheckboxHeader();
      } else if (isDataLoadAction[action]) {
        const deselect = [];
        if (selectionMode.preserveSelectionOnDatasetChange === false) {
          selectionChange = me.prepareSelection(null, null, true);
        } else {
          deselect.push(...me.changeSelectedRecordCollectionSilent((c) => c.match(store.storage)));
          for (const selectedCell of me._selectedCells) {
            if (!store.getById(selectedCell.id)) {
              deselect.push(selectedCell);
            }
          }
          selectionChange = me.prepareSelection(deselect);
        }
      }
      if (selectionChange) {
        me.performSelection(selectionChange, false);
        me.updateCheckboxHeader();
      }
    }
    onStoreRemoveAll() {
      var _super$onStoreRemoveA;
      (_super$onStoreRemoveA = super.onStoreRemoveAll) === null || _super$onStoreRemoveA === void 0 ? void 0 : _super$onStoreRemoveA.call(this);
      this.performSelection(this.prepareSelection(null, null, true), false);
    }
    onCheckChange({
      checked,
      record
    }) {
      const me = this, deselectAll = !me.selectionMode.multiSelect && checked, deselect = !deselectAll && !checked ? [record] : null, select = checked ? [record] : null;
      if (checked && !GlobalEvents$1.shiftKeyDown) {
        me._lastSelectionChecked = record;
      }
      if (checked && me._lastSelectionChecked && GlobalEvents$1.shiftKeyDown) {
        me.performSelection(me.internalSelectRange(me._lastSelectionChecked, record, true));
      } else {
        me.performSelection(me.prepareSelection(deselect, select, deselectAll, true));
      }
    }
    updateCheckboxHeader() {
      const {
        selectionMode,
        checkboxSelectionColumn,
        store
      } = this;
      if (selectionMode.checkbox && selectionMode.showCheckAll && checkboxSelectionColumn !== null && checkboxSelectionColumn !== void 0 && checkboxSelectionColumn.headerCheckbox) {
        const allSelected = store.count && !store.some((record) => !this.isSelected(record));
        if (checkboxSelectionColumn.headerCheckbox.checked !== allSelected) {
          checkboxSelectionColumn.suspendEvents();
          checkboxSelectionColumn.headerCheckbox.checked = allSelected;
          checkboxSelectionColumn.resumeEvents();
        }
      }
    }
    onCheckAllChange({
      checked
    }) {
      this[checked ? "selectAll" : "deselectAll"](this.store.isPaged && this.selectionMode.preserveSelectionOnPageChange);
    }
    onSelectionDrag(event) {
      const me = this, {
        _selectionStartCell
      } = me;
      if (!GlobalEvents$1.isMouseDown()) {
        me.onSelectionEnd();
      }
      if (!_selectionStartCell) {
        return;
      }
      const {
        items: items2,
        _lastSelectionDragRegion
      } = me, cellData = me.getCellDataFromEvent(event, true), region = cellData === null || cellData === void 0 ? void 0 : cellData.column.region, cellSelector = (cellData === null || cellData === void 0 ? void 0 : cellData.cellSelector) && me.normalizeCellContext(cellData.cellSelector);
      if (cellSelector && !cellSelector.equals(me._lastSelectionDragCell, true)) {
        if (!me._isSelectionDragging) {
          me.enableScrollingCloseToEdges(items2);
        }
        if (me._clearSelectionOnSelectionDrag && !_selectionStartCell.equals(cellSelector, true)) {
          me.deselectAll();
          delete me._clearSelectionOnSelectionDrag;
        }
        if (_lastSelectionDragRegion && region !== _lastSelectionDragRegion) {
          var _me$scrollManager$_ac, _me$scrollManager$_ac2;
          const leavingSubGrid = me.subGrids[_lastSelectionDragRegion], enteringSubGrid = me.subGrids[region], leavingScrollable = leavingSubGrid.scrollable, enteringScrollable = enteringSubGrid.scrollable, goingForward = items2.indexOf(leavingSubGrid) - items2.indexOf(enteringSubGrid) < 0;
          enteringScrollable.x = goingForward ? 0 : enteringScrollable.maxX;
          if (goingForward ? leavingScrollable.x < leavingScrollable.maxX - 1 : leavingScrollable.x > 1) {
            return;
          }
          (_me$scrollManager$_ac = me.scrollManager._activeScroll) === null || _me$scrollManager$_ac === void 0 ? void 0 : (_me$scrollManager$_ac2 = _me$scrollManager$_ac.horizontal) === null || _me$scrollManager$_ac2 === void 0 ? void 0 : _me$scrollManager$_ac2.stopScroll();
        }
        me._lastSelectionDragRegion = region;
        me._lastSelectionDragCell = cellSelector;
        me._isSelectionDragging = true;
        const selectionChange = me._lastSelectionDragChange = me.internalSelectRange(_selectionStartCell, cellSelector, me.isRowNumberSelecting(cellSelector) || me.isRowNumberSelecting(_selectionStartCell));
        selectionChange.deselectedCells = selectionChange.deselectedCells.filter((cell) => !me.isCellSelected(cell));
        selectionChange.deselectedRecords = selectionChange.deselectedRecords.filter((record) => !me.isSelected(record));
        me.refreshGridSelectionUI(selectionChange);
        me.trigger("dragSelecting", selectionChange);
      }
    }
    onSelectionEnd() {
      var _me$_selectionListene3, _me$_selectionListene4;
      const me = this, lastChange = me._lastSelectionDragChange;
      if (me._isSelectionDragging && !me._selectionStartCell.equals(me._lastSelectionDragCell, true) && lastChange) {
        me.performSelection(lastChange, false);
      }
      me.disableScrollingCloseToEdges(me.items);
      me._isSelectionDragging = false;
      me._lastSelectionDragChange = null;
      me._lastSelectionDragCell = null;
      (_me$_selectionListene3 = (_me$_selectionListene4 = me._selectionListenersDetachers).selectiondrag) === null || _me$_selectionListene3 === void 0 ? void 0 : _me$_selectionListene3.call(_me$_selectionListene4);
      delete me._selectionListenersDetachers.selectiondrag;
    }
    onHandleElementClick(event) {
      const me = this;
      if (me.selectionMode.rowNumber && event.target.closest(".b-rownumber-header")) {
        event.handled = true;
        if (me.store.count && me.store.some((record) => !me.isSelected(record))) {
          me.selectAll();
        } else {
          me.deselectAll();
        }
      } else if (me.selectionMode.column && event.target.closest(".b-grid-header")) {
        event.handled = true;
        me.selectColumn(event, event.ctrlKey);
      }
      super.onHandleElementClick(event);
    }
    selectColumn(event, addToSelection = false) {
      const me = this, {
        store
      } = me, {
        columnId
      } = me.getHeaderDataFromEvent(event);
      me._shiftSelectRange = null;
      if (!event.shiftKey) {
        me._shiftSelectColumn = columnId;
      }
      const fromColumnId = event.shiftKey && me._shiftSelectColumn || columnId, selectionChange = me.internalSelectRange(me.normalizeCellContext({
        id: store.first.id,
        columnId: fromColumnId
      }), me.normalizeCellContext({
        id: store.last.id,
        columnId
      }));
      if (addToSelection && !selectionChange.selectedCells.some((sc) => !me.isCellSelected(sc))) {
        selectionChange.deselectedCells = selectionChange.selectedCells;
        selectionChange.selectedCells = [];
      }
      if (!addToSelection) {
        selectionChange.deselectedCells = me._selectedCells;
      }
      me.cleanSelectionChange(selectionChange);
      me.performSelection(selectionChange);
    }
    isSelected(cellSelectorOrId) {
      var _cellSelectorOrId;
      if ((_cellSelectorOrId = cellSelectorOrId) !== null && _cellSelectorOrId !== void 0 && _cellSelectorOrId.id) {
        cellSelectorOrId = cellSelectorOrId.id;
      }
      if (validIdTypes[typeof cellSelectorOrId]) {
        return Boolean(this.selectedRecordCollection.get(cellSelectorOrId));
      }
      return false;
    }
    isCellSelected(cellSelector, includeRow) {
      cellSelector = this.normalizeCellContext(cellSelector);
      return this.isCellSelectionMode && this._selectedCells.some((cell) => cellSelector.equals(cell, true)) || includeRow && this.isSelected(cellSelector);
    }
    isSelectable(recordCellOrId) {
      return this.normalizeCellContext({
        id: recordCellOrId.id || recordCellOrId
      }).isSelectable;
    }
    get selectedRecord() {
      return this.selectedRecords[this.selectedRecords.length - 1] || null;
    }
    set selectedRecord(record) {
      this.selectRow({
        record
      });
    }
    get selectedRecords() {
      return this.selectedRecordCollection.values;
    }
    set selectedRecords(selectedRecords) {
      this.selectRows(selectedRecords);
    }
    spliceSelectedRecords(index, toRemove, toAdd) {
      const me = this;
      if (typeof toRemove == "number") {
        const select = [...me.selectedRecords];
        select.splice(index, toRemove, ...ArrayHelper.asArray(toAdd));
        me.performSelection(me.prepareSelection(null, select, true, true));
      } else {
        me.performSelection(me.prepareSelection(toRemove, toAdd, false, true));
      }
    }
    selectRow(options) {
      if (typeof options === "number" || options.isModel || !("record" in options)) {
        options = {
          records: [options]
        };
      }
      ObjectHelper.assignIf(options, {
        scrollIntoView: true
      });
      this.selectRows(options);
    }
    selectRows(options) {
      if (!options || Array.isArray(options) || options.isModel || typeof options === "number" || !("records" in options) && !("record" in options)) {
        options = {
          records: ArrayHelper.asArray(options) || []
        };
      }
      const me = this, {
        store
      } = me, toSelect = [], {
        records = options.record ? [options.record] : [],
        column = me.columns.visibleColumns[0],
        scrollIntoView,
        addToSelection = arguments[1]
      } = options;
      for (let record of records) {
        record = store.getById(record);
        if (record) {
          toSelect.push(record);
        }
      }
      if (!addToSelection) {
        me._shiftSelectRange = null;
      }
      me.performSelection(me.prepareSelection(null, toSelect, !addToSelection, true));
      if (toSelect.length && scrollIntoView) {
        me.scrollRowIntoView(toSelect[0].id, {
          column
        });
      }
    }
    selectAll(silent = false) {
      const {
        store
      } = this, records = (store.isGrouped ? store.allRecords : store.records).filter((r) => !r.isSpecialRow);
      this.performSelection(this.prepareSelection(null, records, false, true), true, silent);
    }
    deselectAll(removeCurrentRecordsOnly = false, silent = false) {
      const {
        store
      } = this, records = removeCurrentRecordsOnly ? (store.isGrouped ? store.allRecords : store.records).filter((r) => !r.isSpecialRow) : null;
      this.performSelection(this.prepareSelection(records, null, !removeCurrentRecordsOnly), true, silent);
    }
    deselectRow(record) {
      this.deselectRows(record);
    }
    deselectRows(recordsOrIds) {
      const {
        store
      } = this, records = ArrayHelper.asArray(recordsOrIds).map((recordOrId) => store.getById(recordOrId)).filter((rec) => rec);
      this.performSelection(this.prepareSelection(records));
    }
    selectRange(fromId, toId, addToSelection = false) {
      const me = this, {
        store
      } = me, selection = me.internalSelectRange(store.getById(fromId), store.getById(toId), true);
      me._shiftSelectRange = null;
      me.performSelection(selection);
    }
    get selectedCell() {
      return this._selectedCells[this._selectedCells.length - 1];
    }
    set selectedCell(cellSelector) {
      this.selectCells([cellSelector]);
    }
    get selectedCells() {
      return [...this._selectedCells];
    }
    set selectedCells(cellSelectors) {
      this.selectCells(cellSelectors);
    }
    get selectedCellCSSSelector() {
      const cell = this.selectedCell, row = cell && this.getRowById(cell.id);
      if (!cell || !row)
        return "";
      return `[data-index=${row.dataIndex}] [data-column-id=${cell.columnId}]`;
    }
    selectCell(options) {
      var _this$selectCells;
      if ("id" in options) {
        options = {
          cell: options
        };
        options = Object.assign({
          scrollIntoView: arguments[1],
          addToSelection: arguments[2],
          silent: arguments[3]
        }, options);
      }
      return (_this$selectCells = this.selectCells(options)) === null || _this$selectCells === void 0 ? void 0 : _this$selectCells[0];
    }
    selectCells(options) {
      if (Array.isArray(options)) {
        options = {
          cells: options
        };
      }
      const me = this, {
        cells = options.cell ? [options.cell] : [],
        scrollIntoView = true,
        addToSelection = false,
        silent = false
      } = options, selectionChange = me.prepareSelection(null, cells, !addToSelection);
      if (!addToSelection) {
        me._shiftSelectRange = null;
      }
      me.performSelection(selectionChange, true, silent);
      if (scrollIntoView) {
        me.scrollRowIntoView(cells[0].id, {
          column: cells[0].columnId
        });
      }
      return me.isCellSelectionMode ? selectionChange.selectedCells : selectionChange.selectedRecords;
    }
    deselectCell(cellSelector) {
      var _this$deselectCells;
      return (_this$deselectCells = this.deselectCells([cellSelector])) === null || _this$deselectCells === void 0 ? void 0 : _this$deselectCells[0];
    }
    deselectCells(cellSelectors) {
      const selectionChange = this.prepareSelection(cellSelectors);
      this.performSelection(selectionChange);
      return this.isCellSelectionMode ? selectionChange.deselectedCells : selectionChange.deselectedRecords;
    }
    toggleSelection(keyEvent) {
      const me = this, {
        _focusedCell,
        selectionMode
      } = me, isRowNumber = me.isRowNumberSelecting(_focusedCell), isSelected = me.isCellSelected(_focusedCell, true);
      if (selectionMode.selectOnKeyboardNavigation === true || _focusedCell.isActionable) {
        return false;
      }
      me.performSelection(me.prepareSelection(isSelected ? _focusedCell : null, isSelected ? null : _focusedCell, !selectionMode.multiSelect, isRowNumber));
      keyEvent.preventDefault();
    }
    selectCellRange(from, to) {
      this.performSelection(this.internalSelectRange(from, to));
    }
    getSelection() {
      if (this.isRowSelectionMode) {
        return this.selectedRecords;
      } else {
        return this.selectedCells;
      }
    }
    cleanSelectionChange(selectionChange) {
      const {
        deselectedRecords,
        selectedRecords,
        deselectedCells,
        selectedCells
      } = selectionChange;
      if (deselectedRecords !== null && deselectedRecords !== void 0 && deselectedRecords.length && selectedRecords !== null && selectedRecords !== void 0 && selectedRecords.length) {
        selectionChange.deselectedRecords = deselectedRecords.filter((dr) => !selectedRecords.some((sr) => dr === sr));
      }
      if (deselectedCells !== null && deselectedCells !== void 0 && deselectedCells.length && selectedCells !== null && selectedCells !== void 0 && selectedCells.length) {
        selectionChange.deselectedCells = deselectedCells.filter((dc) => !selectedCells.some((sc) => dc.equals(sc, true)));
      }
      return selectionChange;
    }
    getSelectedCellsForRecords(records) {
      return this._selectedCells.filter((cell) => cell.id && records.some((record) => record.id === cell.id));
    }
    delayUntilMouseUp(fn) {
      const detacher2 = EventHelper.on({
        element: globalThis,
        blur: (ev) => fn(ev, detacher2),
        mouseup: (ev) => fn(ev, detacher2),
        thisObj: this,
        once: true
      });
    }
    get isRowSelectionMode() {
      return !this.isCellSelectionMode;
    }
    get isCellSelectionMode() {
      return this.selectionMode.cell === true;
    }
    isRowNumberSelecting(...selectors) {
      return this.selectionMode.rowNumber && !selectors.some((cs) => cs.column.type !== "rownumber");
    }
    extendSelectionLeft() {
      this.extendSelection("Left");
    }
    extendSelectionRight() {
      this.extendSelection("Right");
    }
    extendSelectionUp() {
      this.extendSelection("Up");
    }
    extendSelectionDown() {
      this.extendSelection("Down");
    }
    extendSelection(dir) {
      this._isKeyboardRangeSelecting = true;
      this["navigate" + dir]();
      this._isKeyboardRangeSelecting = false;
    }
    onCellNavigate(me, fromCellSelector, toCellSelector, doSelect) {
      var _toCellSelector$recor;
      const {
        selectionMode,
        _selectionListenersDetachers
      } = me, {
        rowReorder
      } = me.features, {
        multiSelect,
        deselectOnClick,
        dragSelect
      } = selectionMode, {
        ctrlKeyDown,
        shiftKeyDown
      } = GlobalEvents$1, isMouseLeft = GlobalEvents$1.isMouseDown(), isMouseRight = GlobalEvents$1.isMouseDown(2), currentEvent = GlobalEvents$1.currentMouseDown || GlobalEvents$1.currentKeyDown, currentTarget = currentEvent === null || currentEvent === void 0 ? void 0 : currentEvent.target;
      toCellSelector = me.normalizeCellContext(toCellSelector);
      if (!doSelect || toCellSelector.rowIndex === -1 || (_toCellSelector$recor = toCellSelector.record) !== null && _toCellSelector$recor !== void 0 && _toCellSelector$recor.isGroupHeader || currentEvent !== null && currentEvent !== void 0 && currentEvent.fromKeyMap && !selectionMode.selectOnKeyboardNavigation || me.columns.getById(toCellSelector.columnId) === me.checkboxSelectionColumn || selectionMode.checkboxOnly || currentTarget && rowReorder !== null && rowReorder !== void 0 && rowReorder.gripOnly && rowReorder.isElementDraggable(currentTarget, currentEvent) || (currentEvent === null || currentEvent === void 0 ? void 0 : currentEvent.handled) === true) {
        return;
      }
      if (!shiftKeyDown) {
        me._isAddingToSelection = ctrlKeyDown && multiSelect;
        me._selectionStartCell = toCellSelector;
      }
      if (multiSelect && dragSelect && isMouseLeft && !_selectionListenersDetachers.selectiondrag) {
        _selectionListenersDetachers.selectiondrag = EventHelper.on({
          name: "selectiondrag",
          element: globalThis,
          blur: "onSelectionEnd",
          mouseup: "onSelectionEnd",
          mousemove: "onSelectionDrag",
          thisObj: me
        });
      }
      const startCell = me._selectionStartCell, adding = me._isAddingToSelection;
      if ((shiftKeyDown && isMouseLeft || me._isKeyboardRangeSelecting) && startCell && multiSelect) {
        me.performSelection(me.internalSelectRange(startCell, toCellSelector, me.isRowNumberSelecting(startCell, toCellSelector)));
      } else {
        let delay = false, continueSelecting = true, deselect;
        if (me.isCellSelected(toCellSelector, true)) {
          if (isMouseRight) {
            return;
          }
          if (adding || deselectOnClick) {
            deselect = deselectOnClick ? null : [toCellSelector];
            continueSelecting = false;
          } else if (me.selectedRecords.length + (me.isCellSelectionMode ? me._selectedCells.length : 0) <= 1) {
            return;
          }
          delay = deselectOnClick || multiSelect;
        }
        if (!deselect && !adding) {
          deselect = null;
          if (dragSelect && delay && _selectionListenersDetachers.selectiondrag) {
            me._clearSelectionOnSelectionDrag = true;
          }
        }
        const finishSelection = (mouseUpEvent, detacher2) => {
          var _mouseUpEvent$target;
          detacher2 === null || detacher2 === void 0 ? void 0 : detacher2();
          if ((mouseUpEvent === null || mouseUpEvent === void 0 ? void 0 : (_mouseUpEvent$target = mouseUpEvent.target) === null || _mouseUpEvent$target === void 0 ? void 0 : _mouseUpEvent$target.nodeType) === Node.ELEMENT_NODE) {
            const mouseUpSelector = new Location(mouseUpEvent.target);
            if (mouseUpSelector !== null && mouseUpSelector !== void 0 && mouseUpSelector.grid && !mouseUpSelector.equals(toCellSelector, true)) {
              return;
            }
          }
          if (!shiftKeyDown) {
            me._shiftSelectRange = null;
          }
          me.performSelection(me.prepareSelection(deselect, continueSelecting && [toCellSelector], deselect === null, continueSelecting && me.isRowNumberSelecting(toCellSelector)));
        };
        if (delay) {
          me.delayUntilMouseUp(finishSelection);
        } else {
          finishSelection();
        }
      }
    }
    prepareSelection(cellSelectorsToDeselect, cellSelectorsToSelect, deselectAll = false, forceRecordSelection = false) {
      const me = this, isDragging = me._isSelectionDragging, {
        includeParents
      } = me.selectionMode, selectedRecords = [], selectedCells = [];
      let deselectedCells = [], deselectedRecords = [];
      if (deselectAll) {
        deselectedCells = me._selectedCells;
        deselectedRecords = me.selectedRecords;
      } else if (cellSelectorsToDeselect) {
        for (const selector of ArrayHelper.asArray(cellSelectorsToDeselect)) {
          const cellSelector = me.normalizeCellContext(selector), record = (cellSelector === null || cellSelector === void 0 ? void 0 : cellSelector.record) || (selector.isModel ? selector : me.store.getById(cellSelector.id));
          if (!cellSelector.isSpecialRow) {
            deselectedCells.push(cellSelector);
            if (record && !deselectedRecords.some((r) => r.id === record.id)) {
              var _record$allChildren;
              if (isDragging || me.isSelected(record)) {
                deselectedRecords.push(record);
              }
              if (me.selectionMode.includeChildren && me.selectionMode.multiSelect && !record.isLeaf && (_record$allChildren = record.allChildren) !== null && _record$allChildren !== void 0 && _record$allChildren.length) {
                for (const child of record.allChildren) {
                  if (!deselectedRecords.some((r) => r.id === child.id) && (isDragging || me.isSelected(child))) {
                    deselectedRecords.push(child);
                  }
                }
              }
            }
          }
        }
      }
      if (cellSelectorsToSelect) {
        for (const selector of ArrayHelper.asArray(cellSelectorsToSelect)) {
          const cellSelector = me.normalizeCellContext(selector), record = (cellSelector === null || cellSelector === void 0 ? void 0 : cellSelector.record) || (selector.isModel ? selector : me.store.getById(cellSelector.id));
          if (record && !cellSelector.isSpecialRow) {
            if (me.isCellSelectionMode && !forceRecordSelection) {
              selectedCells.push(cellSelector);
            }
            if ((me.isRowSelectionMode || forceRecordSelection) && !selectedRecords.some((r) => r.id === record.id)) {
              var _record$allChildren2;
              selectedRecords.push(record);
              if (me.selectionMode.includeChildren && me.selectionMode.multiSelect && !record.isLeaf && (_record$allChildren2 = record.allChildren) !== null && _record$allChildren2 !== void 0 && _record$allChildren2.length) {
                for (const child of record.allChildren) {
                  if (!selectedRecords.some((r) => r.id === child.id)) {
                    selectedRecords.push(child);
                  }
                }
              }
            }
          }
        }
      }
      if (includeParents && (deselectedRecords.length || selectedRecords.length)) {
        const allChanges = [...deselectedRecords, ...selectedRecords], lowestLevelParents = ArrayHelper.unique(allChanges.filter((rec) => rec.parent && !rec.allChildren.some((child) => allChanges.includes(child))).map((rec) => rec.parent));
        lowestLevelParents.forEach((parent) => me.toggleParentSelection(parent, selectedRecords, deselectedRecords));
      }
      return me.cleanSelectionChange({
        selectedCells,
        selectedRecords,
        deselectedCells,
        deselectedRecords,
        deselectAll,
        action: selectedRecords !== null && selectedRecords !== void 0 && selectedRecords.length || selectedCells !== null && selectedCells !== void 0 && selectedCells.length ? "select" : "deselect"
      });
    }
    toggleParentSelection(parent, toSelect, toDeselect) {
      if (!parent || parent.isRoot) {
        return;
      }
      const isSelected = this.isSelected(parent), inToSelect = toSelect.includes(parent), inToDeselect = toDeselect.includes(parent), childIsSelected = (child) => this.isSelected(child) && !toDeselect.includes(child) || toSelect.includes(child);
      if (this.selectionMode.includeParents === "some") {
        if (parent.allChildren.some(childIsSelected)) {
          if ((!isSelected || inToDeselect) && !inToSelect) {
            toSelect.push(parent);
          }
        } else if (isSelected && !inToDeselect) {
          toDeselect.push(parent);
        }
      } else {
        if (isSelected) {
          if (!inToDeselect && !inToSelect && parent.allChildren.some((child) => toDeselect.includes(child))) {
            toDeselect.push(parent);
          }
        } else if (!inToSelect) {
          if (parent.allChildren.every(childIsSelected)) {
            toSelect.push(parent);
          }
        }
      }
      if (parent.parent) {
        this.toggleParentSelection(parent.parent, toSelect, toDeselect);
      }
    }
    internalSelectRange(fromSelector, toSelector, forceRecordSelection = false) {
      const me = this, selectRecords = me.isRowSelectionMode || forceRecordSelection, selectionChange = me.prepareSelection(me._shiftSelectRange, me.getRange(fromSelector, toSelector, selectRecords), false, forceRecordSelection);
      me._shiftSelectRange = selectionChange[`selected${selectRecords ? "Records" : "Cells"}`];
      return selectionChange;
    }
    getRange(fromSelector, toSelector, selectRecords = false) {
      const me = this, {
        store
      } = me, fromCell = me.normalizeCellContext(fromSelector), toCell = me.normalizeCellContext(toSelector), startRowIndex = Math.min(fromCell.rowIndex, toCell.rowIndex), endRowIndex = Math.max(fromCell.rowIndex, toCell.rowIndex), toSelect = [], startColIndex = Math.min(fromCell.columnIndex, toCell.columnIndex), endColIndex = Math.max(fromCell.columnIndex, toCell.columnIndex);
      if (startRowIndex === -1 || endRowIndex === -1) {
        throw new Error("Record not found in selectRange");
      }
      if (selectRecords) {
        const range = store.getRange(startRowIndex, endRowIndex + 1, false);
        if (toCell.rowIndex < fromCell.rowIndex) {
          range.reverse();
        }
        toSelect.push(...range);
      } else {
        for (let rIx = startRowIndex; rIx <= endRowIndex; rIx++) {
          for (let cIx = startColIndex; cIx <= endColIndex; cIx++) {
            toSelect.push({
              rowIndex: rIx,
              columnIndex: cIx
            });
          }
        }
      }
      return toSelect.map((s) => me.normalizeCellContext(s));
    }
    performSelection(selectionChange, updateUI = true, silent = false) {
      const me = this, {
        selectedRecords,
        selectedCells,
        deselectedRecords,
        deselectedCells,
        action
      } = selectionChange, rowMode = me.isRowSelectionMode;
      if (me.trigger("beforeSelectionChange", {
        mode: rowMode ? "row" : "cell",
        action,
        selected: (rowMode ? selectedRecords : selectedCells) || [],
        deselected: (rowMode ? deselectedRecords : deselectedCells) || [],
        selection: (rowMode ? me.selectedRecords : me.selectedCells) || []
      }) === false) {
        return;
      }
      if (me._selectedCells === deselectedCells) {
        me._selectedCells = [];
      } else {
        const keepCells = [];
        for (const selectedCell of me._selectedCells) {
          if (!deselectedCells.some((cellSelector) => selectedCell.equals(cellSelector, true))) {
            keepCells.push(selectedCell);
          }
        }
        me._selectedCells = keepCells;
      }
      selectionChange.deselectedRecords = [...selectionChange.deselectedRecords];
      if (deselectedRecords === me.selectedRecords) {
        me.changeSelectedRecordCollectionSilent((c) => c.clear());
      } else {
        const keepRecords = [];
        for (const selectedRecord of me.selectedRecords) {
          if (!deselectedRecords.some((record) => selectedRecord.id === record.id)) {
            keepRecords.push(selectedRecord);
          }
        }
        me.changeSelectedRecordCollectionSilent((c) => c.values = keepRecords);
      }
      if (selectedCells.length) {
        for (const selectedCell of selectedCells) {
          if (!me._selectedCells.some((cellSelector) => cellSelector.equals(selectedCell, true))) {
            me._selectedCells.push(selectedCell);
          }
        }
      }
      if (selectedRecords.length) {
        me.changeSelectedRecordCollectionSilent((c) => c.add(...selectedRecords));
      }
      if (updateUI) {
        me.refreshGridSelectionUI(selectionChange);
      }
      me.afterSelectionChange(selectionChange);
      if (!silent) {
        me.triggerSelectionChangeEvent(selectionChange);
      }
    }
    refreshGridSelectionUI({
      selectedRecords,
      selectedCells,
      deselectedRecords,
      deselectedCells
    }) {
      const me = this, {
        checkboxSelectionColumn
      } = me;
      checkboxSelectionColumn === null || checkboxSelectionColumn === void 0 ? void 0 : checkboxSelectionColumn.suspendEvents();
      me.updateGridSelectionRecords(selectedRecords, true);
      me.updateGridSelectionRecords(deselectedRecords, false);
      me.updateCheckboxHeader();
      checkboxSelectionColumn === null || checkboxSelectionColumn === void 0 ? void 0 : checkboxSelectionColumn.resumeEvents();
      if (me.isCellSelectionMode) {
        me.updateGridSelectionCells(selectedCells, true);
        if (me.selectionMode.column) {
          me.updateGridSelectionColumns(selectedCells);
        }
      }
      me.updateGridSelectionCells(deselectedCells, false);
    }
    updateGridSelectionRecords(records, selected) {
      const {
        checkboxSelectionColumn
      } = this;
      if (records !== null && records !== void 0 && records.length) {
        for (let i = 0; i < records.length; i++) {
          const row = this.getRowFor(records[i]);
          if (row) {
            row.toggleCls("b-selected", selected);
            row.setAttribute("aria-selected", selected);
            if (checkboxSelectionColumn && !checkboxSelectionColumn.hidden && !records[i].isSpecialRow) {
              row.getCell(checkboxSelectionColumn.id).widget.checked = selected;
            }
          }
        }
      }
    }
    updateGridSelectionCells(cells, selected) {
      if (cells !== null && cells !== void 0 && cells.length) {
        for (let i = 0; i < cells.length; i++) {
          const cell = this.getCell(cells[i]);
          if (cell) {
            cell.setAttribute("aria-selected", selected);
            cell.classList.toggle("b-selected", selected);
          }
        }
      }
    }
    updateGridSelectionColumns(selectedCells) {
      const {
        count
      } = this.store;
      for (const column of this.columns.visibleColumns) {
        var _column$element;
        (_column$element = column.element) === null || _column$element === void 0 ? void 0 : _column$element.classList.toggle("b-selected", (selectedCells === null || selectedCells === void 0 ? void 0 : selectedCells.filter((s) => s.columnId === column.id).length) === count);
      }
    }
    triggerSelectionChangeEvent(selectionChange) {
      const rowMode = this.isRowSelectionMode;
      this.trigger("selectionChange", {
        mode: rowMode ? "row" : "cell",
        action: selectionChange.action,
        selected: (rowMode ? selectionChange.selectedRecords : selectionChange.selectedCells) || [],
        deselected: (rowMode ? selectionChange.deselectedRecords : selectionChange.deselectedCells) || [],
        selection: (rowMode ? this.selectedRecords : this.selectedCells) || []
      });
    }
    doDestroy() {
      var _this$selectedRecordC;
      (_this$selectedRecordC = this.selectedRecordCollection) === null || _this$selectedRecordC === void 0 ? void 0 : _this$selectedRecordC.destroy();
      this._selectedCells.length = 0;
      for (const detacher2 in this._selectionListenersDetachers) {
        this._selectionListenersDetachers[detacher2]();
      }
      super.doDestroy();
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "configurable", {
    selectionMode: {
      cell: false,
      multiSelect: true,
      checkboxOnly: false,
      checkbox: false,
      checkboxPosition: null,
      showCheckAll: false,
      deselectFilteredOutRecords: false,
      includeChildren: false,
      includeParents: false,
      preserveSelectionOnPageChange: false,
      preserveSelectionOnDatasetChange: true,
      deselectOnClick: false,
      dragSelect: false,
      selectOnKeyboardNavigation: true,
      column: false,
      rowNumber: false
    },
    keyMap: {
      "Shift+ArrowUp": "extendSelectionUp",
      "Shift+ArrowDown": "extendSelectionDown",
      "Shift+ArrowLeft": "extendSelectionLeft",
      "Shift+ArrowRight": "extendSelectionRight",
      " ": {
        handler: "toggleSelection",
        weight: 10
      }
    },
    selectedRecordCollection: {}
  }), _class;
};
var suspendStoreEvents = (subGrid) => subGrid.columns.suspendEvents();
var resumeStoreEvents = (subGrid) => subGrid.columns.resumeEvents();
var fillSubGridColumns = (subGrid) => {
  subGrid.columns.clearCaches();
  subGrid.columns.fillFromMaster();
};
var compareStateSortIndex = (a, b) => a.stateSortIndex - b.stateSortIndex;
var GridState = (Target) => class GridState extends (Target || Base) {
  static get $name() {
    return "GridState";
  }
  static get configurable() {
    return {
      statefulEvents: ["subGridCollapse", "subGridExpand", "horizontalScroll", "stateChange"]
    };
  }
  updateStore(store, was) {
    var _super$updateStore;
    (_super$updateStore = super.updateStore) === null || _super$updateStore === void 0 ? void 0 : _super$updateStore.call(this, store, was);
    this.detachListeners("stateStoreListeners");
    store === null || store === void 0 ? void 0 : store.ion({
      name: "stateStoreListeners",
      filter: "triggerUpdate",
      group: "triggerUpdate",
      sort: "triggerUpdate",
      thisObj: this
    });
  }
  updateColumns(columns, was) {
    var _super$updateColumns;
    (_super$updateColumns = super.updateColumns) === null || _super$updateColumns === void 0 ? void 0 : _super$updateColumns.call(this, columns, was);
    this.detachListeners("stateColumnListeners");
    columns.ion({
      name: "stateColumnListeners",
      change: "triggerUpdate",
      thisObj: this
    });
  }
  updateRowManager(manager, was) {
    var _super$updateRowManag;
    (_super$updateRowManag = super.updateRowManager) === null || _super$updateRowManag === void 0 ? void 0 : _super$updateRowManag.call(this, manager, was);
    this.detachListeners("stateRowManagerListeners");
    manager.ion({
      name: "stateRowManagerListeners",
      rowHeight: "triggerUpdate",
      thisObj: this
    });
  }
  triggerUpdate() {
    this.trigger("stateChange");
  }
  finalizeInit() {
    super.finalizeInit();
    this.ion({
      selectionChange: "triggerUpdate",
      thisObj: this
    });
  }
  getState() {
    const me = this, style = me.element.style.cssText, state = {
      rowHeight: me.rowHeight
    };
    if (style) {
      state.style = style;
    }
    if (me.selectedCell) {
      const {
        id,
        columnId
      } = me.selectedCell;
      state.selectedCell = {
        id,
        columnId
      };
    }
    state.selectedRecords = me.selectedRecords.map((entry) => entry.id);
    state.columns = me.columns.allRecords.map((column) => column.getState());
    state.store = me.store.state;
    state.scroll = me.storeScroll();
    state.subGrids = {};
    me.eachSubGrid((subGrid) => {
      var _subGrid$collapsed;
      const config = state.subGrids[subGrid.region] = state.subGrids[subGrid.region] || {};
      if (subGrid.isPainted) {
        if (subGrid.flex == null) {
          config.width = subGrid.width;
        }
      } else {
        if (subGrid.config.width != null) {
          config.width = subGrid.config.width;
        } else {
          config.flex = subGrid.config.flex;
        }
      }
      config.collapsed = (_subGrid$collapsed = subGrid.collapsed) !== null && _subGrid$collapsed !== void 0 ? _subGrid$collapsed : false;
      if (config.collapsed) {
        config._beforeCollapseState = subGrid._beforeCollapseState;
      }
    });
    return state;
  }
  applyState(state) {
    const me = this;
    me.suspendRefresh();
    if ("columns" in state) {
      let columnsChanged = false, needSort = false;
      me.columns.suspendEvents();
      me.eachSubGrid(suspendStoreEvents);
      state.columns.forEach((columnState, index) => {
        const column = me.columns.getById(columnState.id);
        if (column) {
          const columnGeneration = column.generation;
          column.applyState(columnState);
          columnsChanged = columnsChanged || column.generation !== columnGeneration;
          column.stateSortIndex = index;
          if (column.allIndex !== index) {
            needSort = columnsChanged = true;
          }
        }
      });
      if (columnsChanged) {
        me.eachSubGrid(fillSubGridColumns);
      }
      if (needSort) {
        me.eachSubGrid((subGrid) => {
          subGrid.columns.records.sort(compareStateSortIndex);
          subGrid.columns.allRecords.sort(compareStateSortIndex);
        });
        me.columns.sort({
          fn: compareStateSortIndex,
          ascending: true
        });
      }
      if (me.isPainted && columnsChanged) {
        me.renderContents();
      }
      me.columns.resumeEvents();
      me.eachSubGrid(resumeStoreEvents);
    }
    if ("subGrids" in state) {
      me.eachSubGrid((subGrid) => {
        if (subGrid.region in state.subGrids) {
          const subGridState = state.subGrids[subGrid.region];
          if ("width" in subGridState) {
            subGrid.width = subGridState.width;
          } else if ("flex" in subGridState) {
            subGrid.flex = subGridState.flex;
          }
          if ("collapsed" in subGridState) {
            subGrid.collapsed = subGridState.collapsed;
            subGrid._beforeCollapseState = subGridState._beforeCollapseState;
          }
        }
        subGrid.clearWidthCache();
      });
    }
    if ("rowHeight" in state) {
      me.rowHeight = state.rowHeight;
    }
    if ("style" in state) {
      me.style = state.style;
    }
    if ("selectedCell" in state) {
      me.selectedCell = state.selectedCell;
    }
    if ("store" in state) {
      me.store.state = state.store;
    }
    if ("selectedRecords" in state) {
      me.selectedRecords = state.selectedRecords;
    }
    me.resumeRefresh(true);
    me.eachSubGrid((s) => s.refreshFakeScroll());
    if ("scroll" in state) {
      me.restoreScroll(state.scroll);
      if (state.scroll.scrollTop) {
        me.element.querySelectorAll(".b-resize-monitored").forEach((element) => {
          const widget = WidgetHelper.fromElement(element);
          if (widget) {
            widget.onElementResize(element);
          }
        });
      }
    }
  }
  get widgetClass() {
  }
};
var immediatePromise = Promise.resolve();
var defaultScrollOptions$1 = {
  block: "nearest"
};
var SubGridScroller = class extends Scroller {
  static get configurable() {
    return {
      propagate: false,
      overflowX: "hidden-scroll"
    };
  }
  scrollIntoView(element, options = defaultScrollOptions$1) {
    const me = this, {
      xDelta,
      yDelta
    } = me.getDeltaTo(element, options), result = xDelta || yDelta ? me.scrollBy(xDelta, yDelta, options) : immediatePromise;
    if (options.highlight || options.focus) {
      result.then(() => {
        if (options.highlight) {
          if (element instanceof Rectangle) {
            element.translate(-xDelta, -yDelta).highlight();
          } else {
            DomHelper.highlight(element);
          }
        }
        options.focus && element.focus && element.focus();
      });
    }
    return result;
  }
  scrollBy(xDelta, yDelta, options) {
    const yPromise = yDelta && this.yScroller.scrollBy(0, yDelta, options), xPromise = xDelta && super.scrollBy(xDelta, 0, options);
    if (xPromise && xPromise.cancel && yPromise && yPromise.cancel) {
      const cancelX = xPromise.cancel, cancelY = yPromise.cancel;
      xPromise.cancel = yPromise.cancel = () => {
        cancelX();
        cancelY();
      };
      return Promise.all([xPromise, yPromise]);
    }
    return xPromise || yPromise || immediatePromise;
  }
  scrollTo(toX, toY, options) {
    const yPromise = toY != null && this.yScroller.scrollTo(null, toY, options), xPromise = toX != null && super.scrollTo(toX, null, options);
    if (!(options && options.animate)) {
      this.syncPartners();
    }
    if (xPromise && xPromise.cancel && yPromise && yPromise.cancel) {
      const cancelX = xPromise.cancel, cancelY = yPromise.cancel;
      xPromise.cancel = yPromise.cancel = () => {
        cancelX();
        cancelY();
      };
      return Promise.all([xPromise, yPromise]);
    }
    return xPromise || yPromise || immediatePromise;
  }
  get viewport() {
    const elementBounds = Rectangle.from(this.element), viewport = elementBounds.intersect(Rectangle.from(this.yScroller.element));
    return viewport || new Rectangle(elementBounds.x, elementBounds.y, elementBounds.width, 0);
  }
  set y(y) {
    if (this.yScroller) {
      this.yScroller.y = y;
    }
  }
  get y() {
    return this.yScroller ? this.yScroller.y : 0;
  }
  get maxY() {
    return this.yScroller ? this.yScroller.maxY : 0;
  }
  get scrollHeight() {
    return this.yScroller ? this.yScroller.scrollHeight : 0;
  }
  get clientHeight() {
    return this.yScroller ? this.yScroller.clientHeight : 0;
  }
};
SubGridScroller._$name = "SubGridScroller";
var sumWidths = (t, e) => t + e.getBoundingClientRect().width;
var SubGrid = class extends Widget {
  static get $name() {
    return "SubGrid";
  }
  static get type() {
    return "subgrid";
  }
  static get defaultConfig() {
    return {
      insertRowsBefore: null,
      appendTo: null,
      monitorResize: true,
      headerClass: null,
      footerClass: null,
      weight: null,
      collapsed: null,
      scrollable: {
        overflowX: "hidden-scroll"
      },
      scrollerClass: SubGridScroller,
      hasCalculatedWidth: null,
      sealedColumns: null
    };
  }
  static get configurable() {
    return {
      element: true,
      header: {},
      footer: {},
      virtualScrollerElement: true,
      splitterElement: true,
      headerSplitter: true,
      scrollerSplitter: true,
      footerSplitter: true,
      resizable: null,
      role: "presentation"
    };
  }
  construct(config) {
    const me = this;
    super.construct(config);
    this.rowManager.ion({
      addRows: "onAddRow",
      thisObj: this
    });
    if (BrowserHelper.isFirefox) {
      const {
        element
      } = me, verticalScroller = me.grid.scrollable;
      let lastScrollTop = 0;
      element.addEventListener("wheel", ({
        ctrlKey,
        deltaY,
        deltaX
      }) => {
        const isVerticalScroll = Math.abs(deltaY) > Math.abs(deltaX);
        if (!ctrlKey && isVerticalScroll && !me.scrollEndDetacher && verticalScroller.y !== lastScrollTop) {
          element.style.pointerEvents = "none";
          lastScrollTop = verticalScroller.y;
          me.scrollEndDetacher = verticalScroller.ion({
            scrollEnd: async () => {
              lastScrollTop = verticalScroller.y;
              element.style.pointerEvents = "";
              me.scrollEndDetacher = null;
            },
            once: true
          });
        }
      });
    }
  }
  doDestroy() {
    var _me$fakeScroller;
    const me = this;
    me.header.destroy();
    me.footer.destroy();
    (_me$fakeScroller = me.fakeScroller) === null || _me$fakeScroller === void 0 ? void 0 : _me$fakeScroller.destroy();
    me.virtualScrollerElement.remove();
    me.splitterElements.forEach((element) => element.remove());
    super.doDestroy();
  }
  get barConfig() {
    const me = this, {
      width,
      flex
    } = me.element.style, config = {
      subGrid: me,
      parent: me,
      maxWidth: me.maxWidth || void 0,
      minWidth: me.minWidth || void 0
    };
    if (flex) {
      config.flex = flex;
    } else if (width) {
      config.width = width;
    }
    return config;
  }
  changeHeader(header) {
    return new this.headerClass(ObjectHelper.assign({
      id: this.id + "-header"
    }, this.barConfig, header));
  }
  changeFooter(footer) {
    return new this.footerClass(ObjectHelper.assign({
      id: this.id + "-footer"
    }, this.barConfig, footer));
  }
  get splitterElements() {
    return [this.splitterElement, this.headerSplitter, this.scrollerSplitter, this.footerSplitter];
  }
  toggleSplitterCls(cls, add = true) {
    this.splitterElements.forEach((el) => el === null || el === void 0 ? void 0 : el.classList[add ? "add" : "remove"](cls));
  }
  hideSplitter() {
    this.splitterElements.forEach((el) => el.classList.add("b-hide-display"));
    this.$showingSplitter = false;
  }
  showSplitter() {
    this.splitterElements.forEach((el) => el.classList.remove("b-hide-display"));
    this.$showingSplitter = true;
  }
  changeElement(element, was) {
    const {
      region
    } = this;
    return super.changeElement({
      "aria-label": region,
      className: {
        "b-grid-subgrid": 1,
        [`b-grid-subgrid-${region}`]: region,
        "b-grid-subgrid-collapsed": this.collapsed
      },
      dataset: {
        region
      }
    }, was);
  }
  get rowElementConfig() {
    const {
      grid
    } = this;
    return {
      role: "row",
      className: grid.rowCls,
      children: this.columns.visibleColumns.map((column, columnIndex) => ({
        role: "gridcell",
        "aria-colindex": columnIndex + 1,
        tabIndex: grid.cellTabIndex,
        className: "b-grid-cell",
        dataset: {
          column: column.field || "",
          columnId: column.id
        }
      }))
    };
  }
  changeVirtualScrollerElement() {
    const references = DomHelper.createElement({
      role: "presentation",
      reference: "virtualScrollerElement",
      className: "b-virtual-scroller",
      tabIndex: -1,
      dataset: {
        region: this.region
      },
      children: [{
        reference: "virtualScrollerWidth",
        className: "b-virtual-width"
      }]
    });
    this.virtualScrollerWidth = references.virtualScrollerWidth;
    return references.virtualScrollerElement;
  }
  changeSplitterElement() {
    const references = DomHelper.createElement({
      reference: "splitterElement",
      className: {
        "b-grid-splitter": 1,
        "b-grid-splitter-collapsed": this.collapsed,
        "b-hide-display": 1
      },
      dataset: {
        region: this.region
      },
      children: [BrowserHelper.isTouchDevice ? {
        className: "b-splitter-touch-area"
      } : null, {
        className: "b-grid-splitter-inner b-grid-splitter-main",
        children: [{
          className: "b-grid-splitter-buttons",
          reference: "splitterButtons",
          children: [{
            className: "b-grid-splitter-button-collapse",
            children: [BrowserHelper.isTouchDevice ? {
              className: "b-splitter-button-touch-area"
            } : null, {
              tag: "svg",
              ns: "http://www.w3.org/2000/svg",
              version: "1.1",
              className: "b-grid-splitter-button-icon b-gridregion-collapse-arrow",
              viewBox: "0 0 256 512",
              children: [{
                tag: "path",
                d: "M192 448c-8.188 0-16.38-3.125-22.62-9.375l-160-160c-12.5-12.5-12.5-32.75 0-45.25l160-160c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25L77.25 256l137.4 137.4c12.5 12.5 12.5 32.75 0 45.25C208.4 444.9 200.2 448 192 448z"
              }]
            }]
          }, {
            className: "b-grid-splitter-button-expand",
            children: [BrowserHelper.isTouchDevice ? {
              className: "b-splitter-button-touch-area"
            } : null, {
              tag: "svg",
              ns: "http://www.w3.org/2000/svg",
              version: "1.1",
              className: "b-grid-splitter-button-icon b-gridregion-expand-arrow",
              viewBox: "0 0 256 512",
              children: [{
                tag: "path",
                d: "M64 448c-8.188 0-16.38-3.125-22.62-9.375c-12.5-12.5-12.5-32.75 0-45.25L178.8 256L41.38 118.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0l160 160c12.5 12.5 12.5 32.75 0 45.25l-160 160C80.38 444.9 72.19 448 64 448z"
              }]
            }]
          }]
        }]
      }]
    });
    this.splitterButtons = references.splitterButtons;
    return references.splitterElement;
  }
  get splitterConfig() {
    return {
      className: this.splitterElement.className.trim(),
      children: [BrowserHelper.isTouchDevice ? {
        className: "b-splitter-touch-area"
      } : null, {
        className: "b-grid-splitter-inner"
      }],
      dataset: {
        region: this.region
      }
    };
  }
  changeHeaderSplitter() {
    return DomHelper.createElement(this.splitterConfig);
  }
  changeScrollerSplitter() {
    return DomHelper.createElement(this.splitterConfig);
  }
  changeFooterSplitter() {
    return DomHelper.createElement(this.splitterConfig);
  }
  render(...args) {
    const me = this;
    super.render(...args);
    if (me.grid) {
      me.updateHasFlex();
      me.element.parentNode.insertBefore(me.splitterElement, me.element.nextElementSibling);
      me.splitterElements.forEach((element) => EventHelper.on({
        element,
        mouseenter: "onSplitterMouseEnter",
        mouseleave: "onSplitterMouseLeave",
        thisObj: me
      }));
      me._collapsed && me.collapse();
    }
  }
  refreshHeader() {
    this.header.refreshContent();
  }
  refreshFooter() {
    var _this$footer;
    (_this$footer = this.footer) === null || _this$footer === void 0 ? void 0 : _this$footer.refreshContent();
  }
  eachWidget(fn, deep = true) {
    const me = this, widgets = [me.header, me.footer];
    for (let i = 0; i < widgets.length; i++) {
      const widget = widgets[i];
      if (fn(widget) === false) {
        return;
      }
      if (deep && widget.eachWidget) {
        widget.eachWidget(fn, deep);
      }
    }
  }
  fixCellWidths(rowElement) {
    const {
      visibleColumns
    } = this.columns;
    let cell = rowElement.firstElementChild, i = 0;
    while (cell) {
      const column = visibleColumns[i], {
        element
      } = column;
      if (column.minWidth) {
        cell.style.minWidth = DomHelper.setLength(column.minWidth);
      }
      if (column.maxWidth) {
        cell.style.maxWidth = DomHelper.setLength(column.maxWidth);
      }
      if (column.flex) {
        if (column.childLevel && element) {
          cell.style.flex = `0 0 ${element.getBoundingClientRect().width}px`;
          cell.style.width = "";
        } else {
          cell.style.flex = column.flex;
          cell.style.width = "";
        }
      } else if (column.width) {
        cell.style.width = DomHelper.setLength(column.width);
      } else {
        cell.style.flex = cell.style.width = cell.style.minWidth = "";
      }
      cell = cell.nextElementSibling;
      i++;
    }
  }
  get totalFixedWidth() {
    return this.columns.totalFixedWidth;
  }
  fixWidths() {
    const me = this, {
      element,
      header,
      footer
    } = me;
    if (!me.collapsed) {
      if (me.flex) {
        header.flex = me.flex;
        if (footer) {
          footer.flex = me.flex;
        }
        element.style.flex = me.flex;
      } else {
        if (me.hasCalculatedWidth && !me.columns.some((col) => !col.hidden && col.flex) && me.totalFixedWidth !== me.width) {
          me.width = me.totalFixedWidth;
          me.hasCalculatedWidth = true;
          return;
        }
        let totalWidth = me.width;
        if (!totalWidth && me.hasCalculatedWidth) {
          totalWidth = 0;
          for (const col of me.columns) {
            if (!col.flex && !col.hidden)
              totalWidth += col.width;
          }
        }
        element.style.width = `${totalWidth}px`;
        header.width = totalWidth;
        if (footer) {
          footer.width = totalWidth;
        }
      }
      me.syncScrollingPartners(false);
    }
  }
  fixRowWidthsInSafariEdge() {
    if (BrowserHelper.isSafari) {
      const me = this, {
        region,
        header
      } = me, minWidth = header.calculateMinWidthForSafari();
      me.rowManager.forEach((row) => {
        const element = row.getElement(region);
        if (element) {
          element.style.width = `${minWidth}px`;
        }
      });
      header.headersElement.style.width = `${minWidth}px`;
    }
  }
  set width(width) {
    const me = this;
    me.hasCalculatedWidth = false;
    super.width = width;
    me.header.width = width;
    me.footer.width = width;
    if (me.isPainted) {
      me.onElementResize();
    }
  }
  get width() {
    return super.width;
  }
  set flex(flex) {
    const me = this;
    me.hasCalculatedWidth = false;
    me.header.flex = flex;
    me.footer.flex = flex;
    super.flex = flex;
    if (me.isPainted) {
      me.onElementResize();
    }
  }
  get flex() {
    return super.flex;
  }
  onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {
    const me = this, {
      grid
    } = me;
    super.onInternalResize(...arguments);
    if (grid !== null && grid !== void 0 && grid.isPainted) {
      me.syncSplitterButtonPosition();
      if (newWidth !== oldWidth) {
        grid.trigger("horizontalScroll", {
          grid,
          subGrid: me,
          scrollLeft: me.scrollable.element.scrollLeft,
          scrollX: me.scrollable.x
        });
        me.fakeScroller && me.refreshFakeScroll();
        grid.syncFlexedSubCols();
        me.fixRowWidthsInSafariEdge();
      }
      if (newHeight !== oldHeight) {
        grid.onHeightChange();
      }
      me.trigger("afterInternalResize", me);
    }
  }
  syncParallelSplitters(collapsed) {
    const me = this, {
      grid
    } = me;
    if (me.splitterElement && me.$showingSplitter) {
      me.toggleSplitterCls("b-grid-splitter-collapsed", collapsed);
    } else {
      const prevGrid = grid.getSubGrid(grid.getPreviousRegion(me.region));
      if (prevGrid && prevGrid.splitterElement) {
        prevGrid.syncParallelSplitters(collapsed);
      }
    }
  }
  onSplitterMouseEnter() {
    const me = this, {
      nextSibling
    } = me;
    if (!me.collapsed && (!nextSibling || !nextSibling.collapsed)) {
      me.toggleSplitterCls("b-hover");
    }
    me.startSplitterButtonSyncing();
  }
  onSplitterMouseLeave() {
    const me = this, {
      nextSibling
    } = me;
    me.toggleSplitterCls("b-hover", false);
    if (!me.collapsed && (!nextSibling || !nextSibling.collapsed)) {
      me.stopSplitterButtonSyncing();
    }
  }
  startSplitterButtonSyncing() {
    const me = this;
    if (me.splitterElement) {
      me.syncSplitterButtonPosition();
      if (!me.splitterSyncScrollListener) {
        me.splitterSyncScrollListener = me.grid.scrollable.ion({
          scroll: "syncSplitterButtonPosition",
          thisObj: me
        });
      }
    }
  }
  stopSplitterButtonSyncing() {
    if (this.splitterSyncScrollListener) {
      this.splitterSyncScrollListener();
      this.splitterSyncScrollListener = null;
    }
  }
  syncSplitterButtonPosition() {
    const {
      grid
    } = this;
    this.splitterButtons.style.top = `${grid.scrollable.y + (grid.bodyHeight - (this.headerSplitter ? grid.headerHeight : 0)) / 2}px`;
  }
  get viewRectangle() {
    const {
      scrollable
    } = this;
    return new Rectangle(scrollable.x, scrollable.y, this.width || 0, this.rowManager.viewHeight);
  }
  updateHasFlex() {
    this.scrollable.element.classList.toggle("b-has-flex", this.columns.hasFlex);
  }
  updateResizable(resizable) {
    this.splitterElements.forEach((splitter) => DomHelper.toggleClasses(splitter, ["b-disabled"], !resizable));
  }
  resizeColumnsToFitContent() {
    this.grid.beginGridMeasuring();
    this.columns.visibleColumns.forEach((column) => {
      column.resizeToFitContent(null, null, true);
    });
    this.grid.endGridMeasuring();
  }
  get overflowingHorizontally() {
    return !this.collapsed && this.scrollable.hasOverflow("x");
  }
  get overflowingVertically() {
    return false;
  }
  refreshFakeScroll() {
    const me = this, {
      element,
      virtualScrollerElement,
      virtualScrollerWidth,
      header,
      footer,
      scrollable
    } = me, totalFixedWidth = [...header.contentElement.children].reduce(sumWidths, 0);
    scrollable.scrollWidth = totalFixedWidth;
    virtualScrollerElement.style.width = element.style.width;
    virtualScrollerElement.style.flex = element.style.flex;
    virtualScrollerElement.style.minWidth = element.style.minWidth;
    virtualScrollerElement.style.maxWidth = element.style.maxWidth;
    header.scrollable.syncOverflowState();
    footer.scrollable.syncOverflowState();
    if (!me.collapsed) {
      if (me.overflowingHorizontally) {
        virtualScrollerWidth.style.width = `${scrollable.scrollWidth || 0}px`;
        me.grid.virtualScrollers.classList.remove("b-hide-display");
      } else {
        virtualScrollerWidth.style.width = 0;
      }
    }
  }
  initScroll() {
    const me = this, {
      scrollable,
      virtualScrollerElement
    } = me;
    me.syncPartnersOnFrame = me.createOnFrame(me.syncScrollingPartners);
    if (BrowserHelper.isFirefox) {
      scrollable.element.addEventListener("wheel", (event) => {
        if (event.deltaX) {
          scrollable.x += event.deltaX;
          event.preventDefault();
        }
      });
    }
    scrollable.yScroller = me.grid.scrollable;
    scrollable.yScroller.addScroller(scrollable);
    me.fakeScroller = new Scroller({
      element: virtualScrollerElement,
      overflowX: true,
      widget: me
    });
    scrollable.ion({
      scroll: "onSubGridScroll",
      scrollend: "onSubGridScrollEnd",
      thisObj: me
    });
    scrollable.addPartner(me.fakeScroller, "x");
    scrollable.addPartner(me.header.scrollable, "x");
    scrollable.addPartner(me.footer.scrollable, "x");
    me.refreshFakeScroll();
  }
  onSubGridScrollEnd() {
    const me = this;
    if (!me.forceScrollUpdate) {
      me.syncScrollingPartners();
    }
    me.scrolling = false;
    if (!DomHelper.scrollBarWidth) {
      me.grid.virtualScrollers.classList.remove("b-scrolling");
      me.hideOverlayScroller();
    }
  }
  onSubGridScroll() {
    if (this.forceScrollUpdate) {
      this.syncScrollingPartners();
      this.forceScrollUpdate = false;
    } else {
      this.syncPartnersOnFrame();
    }
  }
  showOverlayScroller() {
    this.hideOverlayScroller.cancel();
    this.virtualScrollerElement.classList.add("b-show-virtual-scroller");
  }
  hideOverlayScroller() {
    this.virtualScrollerElement.classList.remove("b-show-virtual-scroller");
  }
  set scrolling(scrolling) {
    this._scrolling = scrolling;
  }
  get scrolling() {
    return this._scrolling;
  }
  syncScrollingPartners(addCls = true) {
    const subGrid = this, {
      grid
    } = subGrid;
    if (!subGrid.scrolling && addCls) {
      subGrid.scrolling = true;
      if (!DomHelper.scrollBarWidth) {
        grid.virtualScrollers.classList.add("b-scrolling");
        subGrid.showOverlayScroller();
      }
    }
    grid.trigger("horizontalScroll", {
      subGrid,
      grid,
      scrollLeft: subGrid.scrollable.element.scrollLeft,
      scrollX: subGrid.scrollable.x
    });
  }
  scrollColumnIntoView(column, options) {
    const {
      columns,
      header
    } = this, scroller = header.scrollable;
    column = column instanceof Column ? column : columns.get(column) || columns.getById(column) || columns.getAt(column);
    if (column) {
      const columnHeaderElement = header.getHeader(column.id);
      if (columnHeaderElement) {
        return scroller.scrollIntoView(Rectangle.from(columnHeaderElement, null, true), options);
      }
    }
  }
  onAddRow({
    rows,
    isExport
  }) {
    const me = this, config = me.rowElementConfig, frag = document.createDocumentFragment();
    rows.forEach((row) => {
      const rowElement = DomHelper.createElement(config);
      frag.appendChild(rowElement);
      row.addElement(me.region, rowElement);
      me.fixCellWidths(rowElement);
    });
    if (!isExport) {
      me.fixRowWidthsInSafariEdge();
      me.element.insertBefore(frag, me.insertRowsBefore);
    }
  }
  get rowElements() {
    return this.fromCache(".b-grid-row", true);
  }
  clearRows() {
    this.emptyCache();
    const all = this.element.querySelectorAll(".b-grid-row"), range = document.createRange();
    if (all.length) {
      range.setStartBefore(all[0]);
      range.setEndAfter(all[all.length - 1]);
      range.deleteContents();
    }
  }
  addNewRowElement() {
    const rowElement = DomHelper.append(this.element, this.rowElementConfig);
    this.fixCellWidths(rowElement);
    return rowElement;
  }
  get store() {
    return this.grid.store;
  }
  get rowManager() {
    var _this$grid;
    return (_this$grid = this.grid) === null || _this$grid === void 0 ? void 0 : _this$grid.rowManager;
  }
  toggleTransitionClasses(doRemove = false) {
    const me = this, grid = me.grid, nextRegion = grid.getSubGrid(grid.getNextRegion(me.region)), splitter = grid.resolveSplitter(nextRegion);
    nextRegion.element.classList[doRemove ? "remove" : "add"]("b-grid-subgrid-animate-collapse");
    nextRegion.header.element.classList[doRemove ? "remove" : "add"]("b-grid-subgrid-animate-collapse");
    me.element.classList[doRemove ? "remove" : "add"]("b-grid-subgrid-animate-collapse");
    me.header.element.classList[doRemove ? "remove" : "add"]("b-grid-subgrid-animate-collapse");
    splitter.classList[doRemove ? "remove" : "add"]("b-grid-splitter-animate");
  }
  get collapsed() {
    return this._collapsed;
  }
  set collapsed(collapsed) {
    if (this.isConfiguring) {
      this._collapsed = collapsed;
    } else {
      if (collapsed) {
        this.collapse();
      } else {
        this.expand();
      }
    }
  }
  async collapse() {
    const me = this, {
      grid,
      element
    } = me, nextRegion = grid.getSubGrid(grid.getNextRegion(me.region)), splitterOwner = me.splitterElement ? me : me.previousSibling;
    let {
      _beforeCollapseState
    } = me, expandedRegions = 0;
    if (grid.rendered && me._collapsed === true) {
      return;
    }
    grid.eachSubGrid((subGrid) => {
      subGrid !== me && !subGrid._collapsed && ++expandedRegions;
    });
    if (expandedRegions === 0) {
      await nextRegion.expand();
    }
    return new Promise((resolve) => {
      if (!_beforeCollapseState) {
        _beforeCollapseState = me._beforeCollapseState = {};
        let widthChanged = false;
        if (me.width) {
          widthChanged = true;
          me.ion({
            afterinternalresize: () => {
              resolve(me);
            },
            thisObj: me,
            once: true
          });
        }
        _beforeCollapseState.width = me.width;
        _beforeCollapseState.elementWidth = element.style.width;
        if (nextRegion.element.style.flex === "") {
          _beforeCollapseState.nextRegionWidth = nextRegion.width;
          nextRegion.width = "";
          nextRegion.flex = "1";
        }
        if (element.style.flex !== "") {
          _beforeCollapseState.flex = element.style.flex;
          me.header.element.style.flex = element.style.flex = "";
        }
        element.classList.add("b-grid-subgrid-collapsed");
        me.virtualScrollerElement.classList.add("b-collapsed");
        me.header.element.classList.add("b-collapsed");
        me.footer.element.classList.add("b-collapsed");
        me._collapsed = true;
        me.width = "";
        if (!widthChanged) {
          me.syncParallelSplitters(true);
          resolve(false);
        }
      } else {
        resolve();
      }
    }).then((value) => {
      if (!me.isDestroyed) {
        if (value !== false) {
          var _splitterOwner$startS;
          grid.refreshVirtualScrollbars();
          me.syncParallelSplitters(true);
          (_splitterOwner$startS = splitterOwner.startSplitterButtonSyncing) === null || _splitterOwner$startS === void 0 ? void 0 : _splitterOwner$startS.call(splitterOwner);
        }
        grid.trigger("subGridCollapse", {
          subGrid: me
        });
        grid.afterToggleSubGrid({
          subGrid: me,
          collapsed: true
        });
      }
    });
  }
  async expand() {
    const me = this, {
      grid,
      _beforeCollapseState
    } = me, nextRegion = grid.getSubGrid(grid.getNextRegion(me.region)), splitterOwner = me.splitterElement ? me : me.previousSibling;
    if (grid.rendered && me._collapsed !== true) {
      return;
    }
    return new Promise((resolve) => {
      if (_beforeCollapseState != null) {
        let widthChanged = false;
        if (me.width !== _beforeCollapseState.elementWidth) {
          widthChanged = true;
          me.ion({
            afterinternalresize() {
              me.setTimeout(() => resolve(me), 10);
            },
            thisObj: me,
            once: true
          });
        }
        if (_beforeCollapseState.nextRegionWidth) {
          nextRegion.width = _beforeCollapseState.nextRegionWidth;
          nextRegion.flex = null;
        }
        me.element.classList.remove("b-grid-subgrid-collapsed");
        me._collapsed = false;
        me.virtualScrollerElement.classList.remove("b-collapsed");
        me.header.element.classList.remove("b-collapsed");
        me.footer.element.classList.remove("b-collapsed");
        if (_beforeCollapseState.flex) {
          me.width = _beforeCollapseState.width;
          me.header.flex = me.flex = _beforeCollapseState.flex;
          me.footer.flex = _beforeCollapseState.flex;
          me._width = null;
        } else {
          me.width = _beforeCollapseState.elementWidth;
        }
        me.element.classList.remove("b-grid-subgrid-collapsed");
        me._collapsed = false;
        if (!widthChanged) {
          resolve(false);
        } else {
          splitterOwner.stopSplitterButtonSyncing();
          me.syncParallelSplitters(false);
        }
        delete me._beforeCollapseState;
      } else {
        resolve();
      }
    }).then((value) => {
      if (value !== false && !me.isDestroyed) {
        grid.trigger("subGridExpand", {
          subGrid: me
        });
        grid.afterToggleSubGrid({
          subGrid: me,
          collapsed: false
        });
      }
    });
  }
};
_defineProperty(SubGrid, "delayable", {
  hideOverlayScroller: 1e3
});
SubGrid.initClass();
SubGrid._$name = "SubGrid";
var GridSubGrids = (Target) => class GridSubGrids extends (Target || Base) {
  static get $name() {
    return "GridSubGrids";
  }
  static get properties() {
    return {
      subGrids: {}
    };
  }
  changeSubGridConfigs(configs) {
    const me = this, usedRegions = /* @__PURE__ */ new Set();
    for (const column of me.columns) {
      const {
        region
      } = column;
      if (region) {
        if (!configs[region]) {
          configs[region] = {};
        }
        usedRegions.add(region);
      }
    }
    if (configs.normal && ObjectHelper.isEmpty(configs.normal)) {
      configs.normal = GridBase.defaultConfig.subGridConfigs.normal;
    }
    for (const region of usedRegions) {
      me.createSubGrid(region, configs[region]);
    }
    me.items = me.subGrids;
    return configs;
  }
  createSubGrid(region, config = null) {
    const me = this, subGridColumns = me.columns.makeChained((column) => column.region === region, ["region"]), subGridConfig = ObjectHelper.assign({
      type: "subgrid",
      id: `${me.id}-${region}Subgrid`,
      parent: me,
      grid: me,
      region,
      headerClass: me.headerClass,
      footerClass: me.footerClass,
      columns: subGridColumns,
      weight: region
    }, config || me.subGridConfigs[region]);
    let hasCalculatedWidth = false;
    if (!subGridConfig.flex && !subGridConfig.width) {
      subGridConfig.width = subGridColumns.totalFixedWidth;
      hasCalculatedWidth = true;
    }
    const subGrid = me.subGrids[region] = SubGrid.create(subGridConfig);
    subGrid.hasCalculatedWidth = hasCalculatedWidth;
    if (region === me.regions[0]) {
      subGrid.isFirstRegion = true;
    }
    return subGrid;
  }
  onChildAdd(subGrid) {
    if (subGrid.isSubGrid) {
      const me = this, {
        items: items2,
        headerContainer,
        virtualScrollers,
        footerContainer
      } = me, index = items2.indexOf(subGrid) * 2;
      if (!me.hideHeaders) {
        DomHelper.insertAt(headerContainer, subGrid.headerSplitter, index);
        DomHelper.insertAt(headerContainer, subGrid.header.element, index);
      }
      DomHelper.insertAt(virtualScrollers, subGrid.scrollerSplitter, index);
      DomHelper.insertAt(virtualScrollers, subGrid.virtualScrollerElement, index);
      DomHelper.insertAt(footerContainer, subGrid.footerSplitter, index);
      DomHelper.insertAt(footerContainer, subGrid.footer.element, index);
      items2.forEach((subGrid2, i) => {
        if (i < items2.length - 1) {
          subGrid2.showSplitter();
        }
      });
      if (index === 0 && me.emptyTextEl) {
        subGrid.element.appendChild(me.emptyTextEl);
      }
    }
    return super.onChildAdd(subGrid);
  }
  onChildRemove(subGrid) {
    super.onChildRemove(subGrid);
    if (subGrid.isSubGrid) {
      const {
        items: items2
      } = this;
      delete this.subGrids[subGrid.region];
      ArrayHelper.remove(this.regions, subGrid.region);
      subGrid.destroy();
      if (items2.length) {
        items2[items2.length - 1].hideSplitter();
      }
    }
  }
  doDestroy() {
    this.eachSubGrid((subGrid) => subGrid.destroy());
    super.doDestroy();
  }
  eachSubGrid(fn, thisObj = null) {
    this.items.forEach((subGrid, i) => {
      subGrid.isSubGrid && fn.call(thisObj || subGrid, subGrid, i++);
    });
  }
  callEachSubGrid(fnName, ...params) {
    let returnValue = null;
    this.items.forEach((subGrid, i) => {
      if (subGrid.isSubGrid && subGrid[fnName]) {
        const partialReturnValue = subGrid[fnName](...params);
        if (i === 0)
          returnValue = partialReturnValue;
      }
    });
    return returnValue;
  }
  get regions() {
    return this.items.map((item) => item.region);
  }
  getLastRegions() {
    const result = this.regions.slice(-2);
    return result.length === 2 ? result : [result[0], result[0]];
  }
  getNextRegion(region) {
    const regions = this.regions;
    return regions[regions.indexOf(region) + 1] || regions[regions.length - 2];
  }
  getPreviousRegion(region) {
    return this.regions[this.regions.indexOf(region) - 1];
  }
  getSubGrid(region) {
    return this.subGrids[region];
  }
  getSubGridFromColumn(column) {
    column = column instanceof Column ? column : this.columns.getById(column) || this.columns.get(column);
    return this.getSubGrid(column.region);
  }
  resolveSplitter(subGrid) {
    const regions = this.getLastRegions();
    let region = subGrid instanceof SubGrid ? subGrid.region : subGrid;
    if (regions[1] === region) {
      region = regions[0];
    }
    return this.subGrids[region].splitterElement;
  }
  get widgetClass() {
  }
};
var emptyString = new String();
var locale = {
  localeName: "En",
  localeDesc: "English (US)",
  localeCode: "en-US",
  ColumnPicker: {
    column: "Column",
    columnsMenu: "Columns",
    hideColumn: "Hide column",
    hideColumnShort: "Hide",
    newColumns: "New columns"
  },
  Filter: {
    applyFilter: "Apply filter",
    filter: "Filter",
    editFilter: "Edit filter",
    on: "On",
    before: "Before",
    after: "After",
    equals: "Equals",
    lessThan: "Less than",
    moreThan: "More than",
    removeFilter: "Remove filter",
    disableFilter: "Disable filter"
  },
  FilterBar: {
    enableFilterBar: "Show filter bar",
    disableFilterBar: "Hide filter bar"
  },
  Group: {
    group: "Group",
    groupAscending: "Group ascending",
    groupDescending: "Group descending",
    groupAscendingShort: "Ascending",
    groupDescendingShort: "Descending",
    stopGrouping: "Stop grouping",
    stopGroupingShort: "Stop"
  },
  HeaderMenu: {
    moveBefore: (text) => `Move before "${text}"`,
    moveAfter: (text) => `Move after "${text}"`,
    collapseColumn: "Collapse column",
    expandColumn: "Expand column"
  },
  ColumnRename: {
    rename: "Rename"
  },
  MergeCells: {
    mergeCells: "Merge cells",
    menuTooltip: "Merge cells with same value when sorted by this column"
  },
  Search: {
    searchForValue: "Search for value"
  },
  Sort: {
    sort: "Sort",
    sortAscending: "Sort ascending",
    sortDescending: "Sort descending",
    multiSort: "Multi sort",
    removeSorter: "Remove sorter",
    addSortAscending: "Add ascending sorter",
    addSortDescending: "Add descending sorter",
    toggleSortAscending: "Change to ascending",
    toggleSortDescending: "Change to descending",
    sortAscendingShort: "Ascending",
    sortDescendingShort: "Descending",
    removeSorterShort: "Remove",
    addSortAscendingShort: "+ Ascending",
    addSortDescendingShort: "+ Descending"
  },
  Column: {
    columnLabel: (column) => `${column.text ? `${column.text} column. ` : ""}SPACE for context menu${column.sortable ? ", ENTER to sort" : ""}`,
    cellLabel: emptyString
  },
  Checkbox: {
    toggleRowSelect: "Toggle row selection",
    toggleSelection: "Toggle selection of entire dataset"
  },
  RatingColumn: {
    cellLabel: (column) => {
      var _column$location;
      return `${column.text ? column.text : ""} ${(_column$location = column.location) !== null && _column$location !== void 0 && _column$location.record ? `rating : ${column.location.record[column.field] || 0}` : ""}`;
    }
  },
  GridBase: {
    loadFailedMessage: "Data loading failed!",
    syncFailedMessage: "Data synchronization failed!",
    unspecifiedFailure: "Unspecified failure",
    networkFailure: "Network error",
    parseFailure: "Failed to parse server response",
    serverResponse: "Server response:",
    noRows: "No records to display",
    moveColumnLeft: "Move to left section",
    moveColumnRight: "Move to right section",
    moveColumnTo: (region) => `Move column to ${region}`
  },
  CellMenu: {
    removeRow: "Delete"
  },
  RowCopyPaste: {
    copyRecord: "Copy",
    cutRecord: "Cut",
    pasteRecord: "Paste",
    rows: "rows",
    row: "row"
  },
  CellCopyPaste: {
    copy: "Copy",
    cut: "Cut",
    paste: "Paste"
  },
  PdfExport: {
    "Waiting for response from server": "Waiting for response from server...",
    "Export failed": "Export failed",
    "Server error": "Server error",
    "Generating pages": "Generating pages...",
    "Click to abort": "Cancel"
  },
  ExportDialog: {
    width: "40em",
    labelWidth: "12em",
    exportSettings: "Export settings",
    export: "Export",
    exporterType: "Control pagination",
    cancel: "Cancel",
    fileFormat: "File format",
    rows: "Rows",
    alignRows: "Align rows",
    columns: "Columns",
    paperFormat: "Paper format",
    orientation: "Orientation",
    repeatHeader: "Repeat header"
  },
  ExportRowsCombo: {
    all: "All rows",
    visible: "Visible rows"
  },
  ExportOrientationCombo: {
    portrait: "Portrait",
    landscape: "Landscape"
  },
  SinglePageExporter: {
    singlepage: "Single page"
  },
  MultiPageExporter: {
    multipage: "Multiple pages",
    exportingPage: ({
      currentPage,
      totalPages
    }) => `Exporting page ${currentPage}/${totalPages}`
  },
  MultiPageVerticalExporter: {
    multipagevertical: "Multiple pages (vertical)",
    exportingPage: ({
      currentPage,
      totalPages
    }) => `Exporting page ${currentPage}/${totalPages}`
  },
  RowExpander: {
    loading: "Loading",
    expand: "Expand",
    collapse: "Collapse"
  }
};
LocaleHelper.publishLocale(locale);
var resolvedPromise = new Promise((resolve) => resolve());
var storeListenerName = "GridBase:store";
var defaultScrollOptions = {
  block: "nearest",
  inline: "nearest"
};
var datasetReplaceActions = {
  dataset: 1,
  pageLoad: 1,
  filter: 1
};
var GridBase = class extends Panel.mixin(Pluggable, State, GridElementEvents, GridFeatures, GridNavigation, GridResponsive, GridSelection, GridState, GridSubGrids, LoadMaskable) {
  static get $name() {
    return "GridBase";
  }
  static get type() {
    return "gridbase";
  }
  static get delayable() {
    return {
      onGridVerticalScroll: {
        type: "raf"
      },
      bufferedAfterColumnsResized: 250,
      bufferedElementResize: 250
    };
  }
  static get configurable() {
    return {
      autoHeight: null,
      enableSticky: null,
      enableTextSelection: null,
      fillLastColumn: true,
      positionMode: "translate",
      showDirty: null,
      subGridConfigs: {
        normal: {
          flex: 1
        }
      },
      store: {
        value: {},
        $config: "nullify"
      },
      rowManager: {
        value: {},
        $config: ["nullify", "lazy"]
      },
      scrollManager: {
        value: {},
        $config: ["nullify", "lazy"]
      },
      columns: {
        value: [],
        $config: "nullify"
      },
      minHeight: "10em",
      hideFooters: true,
      contentElMutationObserver: false,
      trapFocus: false,
      ariaElement: "bodyElement",
      cellTabIndex: -1,
      rowCls: {
        value: "b-grid-row",
        $config: {
          merge: this.mergeCls
        }
      },
      cellCls: {
        value: "b-grid-cell",
        $config: {
          merge: this.mergeCls
        }
      },
      emptyText: "L{noRows}",
      sortFeatureStore: "store"
    };
  }
  static get defaultConfig() {
    return {
      rowHeight: null,
      fixedRowHeight: null,
      defaultRowHeight: 45,
      fullRowRefresh: true,
      hideHeaders: null,
      preserveScrollOnDatasetChange: null,
      preserveFocusOnDatasetChange: true,
      data: null,
      defaultRegion: "normal",
      destroyStore: null,
      maskDefaults: {
        cover: "body",
        target: "element"
      },
      columnLines: true,
      resizeToFitIncludesHeader: true,
      animateRemovingRows: true,
      disableGridRowModelWarning: null,
      headerClass: Header,
      footerClass: Footer,
      testPerformance: false,
      rowScrollMode: "move",
      monitorResize: true,
      features: true,
      scrollable: {
        overflowY: true
      },
      scrollerClass: GridScroller,
      refreshSuspended: 0,
      transitionDuration: 500,
      contextMenuTriggerEvent: "contextmenu",
      localizableProperties: ["emptyText"],
      asyncEventSuffix: "",
      testConfig: {
        transitionDuration: 50
      }
    };
  }
  static get properties() {
    return {
      _selectedRecords: [],
      _verticalScrollHeight: 0,
      virtualScrollHeight: 0,
      _scrollTop: null
    };
  }
  finishConfigure(config) {
    const me = this, {
      initScroll
    } = me;
    me.initScroll = () => !me.scrollInitialized && initScroll.call(me);
    super.finishConfigure(config);
    LocaleManagerSingleton.ion({
      locale: "onBeforeLocaleChange",
      prio: 1,
      thisObj: me
    });
    LocaleManagerSingleton.ion({
      locale: "onLocaleChange",
      prio: -1,
      thisObj: me
    });
    GlobalEvents$1.ion({
      theme: "onThemeChange",
      thisObj: me
    });
    me.ion({
      subGridExpand: "onSubGridExpand",
      prio: -1,
      thisObj: me
    });
    me.bufferedFixElementHeights = me.buffer("fixElementHeights", 350, me);
    me.setGridClassList(me.element.classList);
  }
  onSubGridExpand() {
    this.renderContents();
  }
  onBeforeLocaleChange() {
    this._suspendRenderContentsOnColumnsChanged = true;
  }
  onLocaleChange() {
    this._suspendRenderContentsOnColumnsChanged = false;
    if (this.isPainted) {
      this.renderContents();
    }
  }
  finalizeInit() {
    super.finalizeInit();
    if (this.store.isLoading) {
      this.onStoreBeforeRequest();
    }
  }
  changeScrollManager(scrollManager, oldScrollManager) {
    oldScrollManager === null || oldScrollManager === void 0 ? void 0 : oldScrollManager.destroy();
    if (scrollManager) {
      return ScrollManager.new({
        element: this.element,
        owner: this
      }, scrollManager);
    } else {
      return null;
    }
  }
  doDestroy() {
    var _me$scrollManager;
    const me = this;
    me.detachListeners(storeListenerName);
    (_me$scrollManager = me.scrollManager) === null || _me$scrollManager === void 0 ? void 0 : _me$scrollManager.destroy();
    for (const feature of Object.values(me.features)) {
      var _feature$destroy;
      (_feature$destroy = feature.destroy) === null || _feature$destroy === void 0 ? void 0 : _feature$destroy.call(feature);
    }
    me._focusedCell = null;
    me.columns.destroy();
    super.doDestroy();
  }
  setGridClassList(classList) {
    const me = this;
    Object.values(me.features).forEach((feature) => {
      if (feature.disabled) {
        return;
      }
      let featureClass;
      if (Object.prototype.hasOwnProperty.call(feature.constructor, "featureClass")) {
        featureClass = feature.constructor.featureClass;
      } else {
        featureClass = `b-${feature instanceof Base ? feature.$$name : feature.constructor.name}`;
      }
      if (featureClass) {
        classList.add(featureClass.toLowerCase());
      }
    });
  }
  compose() {
    const {
      autoHeight,
      enableSticky,
      enableTextSelection,
      fillLastColumn,
      positionMode,
      showDirty
    } = this;
    return {
      class: {
        [`b-grid-${positionMode}`]: 1,
        "b-enable-sticky": enableSticky,
        "b-grid-notextselection": !enableTextSelection,
        "b-autoheight": autoHeight,
        "b-fill-last-column": fillLastColumn,
        "b-show-dirty": showDirty
      }
    };
  }
  get cellCls() {
    const {
      _cellCls
    } = this;
    return _cellCls.value || _cellCls;
  }
  get bodyConfig() {
    const {
      autoHeight,
      hideFooters,
      hideHeaders
    } = this;
    return {
      reference: "bodyElement",
      className: {
        "b-autoheight": autoHeight,
        "b-grid-panel-body": 1
      },
      [this.hasHeader ? "ariaLabelledBy" : ""]: `${this.id}-panel-title`,
      children: {
        headerContainer: {
          tag: "header",
          role: "row",
          "aria-rowindex": 1,
          className: {
            "b-grid-header-container": 1,
            "b-hidden": hideHeaders
          }
        },
        bodyContainer: {
          className: "b-grid-body-container",
          tabIndex: -1,
          role: "presentation",
          children: {
            verticalScroller: {
              className: "b-grid-vertical-scroller"
            }
          }
        },
        virtualScrollers: {
          className: "b-virtual-scrollers b-hide-display",
          style: BrowserHelper.isFirefox && DomHelper.scrollBarWidth ? {
            height: `${DomHelper.scrollBarWidth}px`
          } : void 0
        },
        footerContainer: {
          tag: "footer",
          className: {
            "b-grid-footer-container": 1,
            "b-hidden": hideFooters
          }
        }
      }
    };
  }
  get contentElement() {
    return this.verticalScroller;
  }
  get overflowElement() {
    return this.bodyContainer;
  }
  updateHideFooters(hide) {
    var _this$footerContainer;
    (_this$footerContainer = this.footerContainer) === null || _this$footerContainer === void 0 ? void 0 : _this$footerContainer.classList[hide ? "add" : "remove"]("b-hidden");
  }
  changeColumns(columns, currentStore) {
    const me = this;
    if (!columns && currentStore) {
      if (me.isDestroying) {
        currentStore.owner === me && currentStore.destroy();
      } else {
        currentStore.removeAll();
      }
      return currentStore;
    }
    if (columns.isStore) {
      (currentStore === null || currentStore === void 0 ? void 0 : currentStore.owner) === me && currentStore.destroy();
      columns.grid = me;
      return columns;
    }
    if (Array.isArray(columns)) {
      if (currentStore) {
        me._suspendRenderContentsOnColumnsChanged = true;
        const columnsToDestroy = currentStore.allRecords.filter((column) => !columns.includes(column) && column !== me.checkboxSelectionColumn);
        currentStore.remove(currentStore.allRecords, true);
        columnsToDestroy.forEach((column) => {
          var _column$destroy;
          return (_column$destroy = column.destroy) === null || _column$destroy === void 0 ? void 0 : _column$destroy.call(column);
        });
        currentStore.data = columns;
        me._suspendRenderContentsOnColumnsChanged = false;
        return currentStore;
      }
      columns = {
        data: columns
      };
    }
    if (currentStore) {
      throw new Error("Replacing ColumnStore is not supported");
    }
    return ColumnStore.new({
      grid: me,
      owner: me
    }, columns);
  }
  updateColumns(columns, was) {
    var _super$updateColumns, _me$bodyElement;
    const me = this;
    (_super$updateColumns = super.updateColumns) === null || _super$updateColumns === void 0 ? void 0 : _super$updateColumns.call(this, columns, was);
    columns.ion({
      refresh: me.onColumnsChanged,
      change: me.onColumnsChanged,
      sort: me.onColumnsChanged,
      thisObj: me
    });
    columns.ion(columnResizeEvent(me.onColumnsResized, me));
    if (BrowserHelper.isTouchDevice) {
      me.touch = true;
      columns.forEach((column) => {
        const {
          touchConfig
        } = column;
        if (touchConfig) {
          column.applyState(touchConfig);
        }
      });
    }
    (_me$bodyElement = me.bodyElement) === null || _me$bodyElement === void 0 ? void 0 : _me$bodyElement.setAttribute("aria-colcount", columns.visibleColumns.length);
  }
  onColumnsChanged({
    type,
    action,
    changes,
    record: column,
    records: addedColumns,
    isMove
  }) {
    const isSingleFieldChange = changes && Object.keys(changes).length === 1;
    if (type === "refresh" && action !== "batch" || action === "update" && isSingleFieldChange && "parentIndex" in changes) {
      return;
    }
    const me = this, {
      columns,
      checkboxSelectionColumn
    } = me;
    if (!me.isPainted || isMove && action === "remove") {
      return;
    }
    if (action === "add") {
      for (const column2 of addedColumns) {
        const {
          region
        } = column2;
        if (!me.subGrids[region]) {
          me.add(me.createSubGrid(region, me.subGridConfigs[region]));
        }
      }
    }
    if (action === "update") {
      if ("width" in changes || "minWidth" in changes || "maxWidth" in changes || "flex" in changes) {
        const region = column.region;
        columns.visibleColumns.forEach((col) => {
          if (col.region === region && col.repaintOnResize) {
            me.refreshColumn(col);
          }
        });
        me.afterColumnsChange({
          action,
          changes,
          column
        });
        return;
      }
      if ("text" in changes && isSingleFieldChange) {
        column.subGrid.refreshHeader();
        return;
      }
      if ("hidden" in changes) {
        const subGrid = me.getSubGridFromColumn(column.id);
        subGrid.header.fixHeaderWidths();
        subGrid.footer.fixFooterWidths();
        subGrid.updateHasFlex();
      }
    }
    if (action === "dataset" || action === "batch" || action === "update" && "region" in changes) {
      const regions = columns.getDistinctValues("region"), {
        toRemove,
        toAdd
      } = ArrayHelper.delta(regions, me.regions, true);
      me.remove(toRemove.map((region) => me.getSubGrid(region)));
      me.add(toAdd.map((region) => me.createSubGrid(region)));
    }
    if (checkboxSelectionColumn && !columns.includes(checkboxSelectionColumn)) {
      const insertIndex = columns.indexOf(columns.findRecord("type", "rownumber")) + 1;
      columns.insert(insertIndex, checkboxSelectionColumn, true);
    }
    if (!me._suspendRenderContentsOnColumnsChanged) {
      me.renderContents();
    }
    me.syncFlexedSubCols();
    me.bodyElement.setAttribute("aria-colcount", columns.visibleColumns.length);
    me.afterColumnsChange({
      action,
      changes,
      column
    });
  }
  onColumnsResized({
    changes,
    record: column
  }) {
    const me = this;
    if (me.isConfiguring) {
      return;
    }
    const domWidth = DomHelper.setLength(column.width), domMinWidth = DomHelper.setLength(column.minWidth), domMaxWidth = DomHelper.setLength(column.maxWidth), subGrid = me.getSubGridFromColumn(column.id);
    subGrid.header.fixHeaderWidths();
    subGrid.footer.fixFooterWidths();
    subGrid.updateHasFlex();
    if (!(column.flex && column.childLevel)) {
      if (!me.cellEls || column !== me.lastColumnResized) {
        me.cellEls = DomHelper.children(me.element, `.b-grid-cell[data-column-id="${column.id}"]`);
        me.lastColumnResized = column;
      }
      for (const cell of me.cellEls) {
        if ("width" in changes) {
          cell.style.width = domWidth;
        }
        if ("minWidth" in changes) {
          cell.style.minWidth = domMinWidth;
        }
        if ("maxWidth" in changes) {
          cell.style.maxWidth = domMaxWidth;
        }
        if ("flex" in changes) {
          var _column$flex;
          cell.style.flex = (_column$flex = column.flex) !== null && _column$flex !== void 0 ? _column$flex : null;
        }
      }
    }
    if (!me.resizingColumns) {
      me.afterColumnsResized(column);
    }
    me.syncFlexedSubCols();
  }
  afterColumnsResized(column) {
    const me = this;
    me.eachSubGrid((subGrid) => {
      if (!subGrid.collapsed && (!column || column.region === subGrid.region)) {
        subGrid.fixWidths();
        subGrid.fixRowWidthsInSafariEdge();
      }
    });
    me.lastColumnResized = me.cellEls = null;
    me.bufferedAfterColumnsResized(column);
    me.onHeightChange();
  }
  syncFlexedSubCols() {
    const flexedSubCols = this.columns.query((c) => c.flex && c.childLevel && c.element);
    if (flexedSubCols) {
      for (const column of flexedSubCols) {
        const width = column.element.getBoundingClientRect().width, cellEls = DomHelper.children(this.element, `.b-grid-cell[data-column-id="${column.id}"]`);
        for (const cell of cellEls) {
          cell.style.flex = `0 0 ${width}px`;
        }
      }
    }
  }
  bufferedAfterColumnsResized(column) {
    if (this.columns.usesAutoHeight) {
      this.refreshRows();
    }
    this.refreshVirtualScrollbars();
    this.eachSubGrid((subGrid) => {
      if (!subGrid.collapsed && (!column || column.region === subGrid.region)) {
        subGrid.refreshFakeScroll();
      }
    });
  }
  bufferedElementResize() {
    this.refreshRows();
  }
  onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {
    if (DomHelper.scrollBarWidth && newWidth < oldWidth) {
      this.eachSubGrid((subGrid) => {
        if (subGrid.flex) {
          subGrid.onElementResize(subGrid.element);
        }
      });
    }
    super.onInternalResize(...arguments);
    if (this.isPainted && newWidth !== oldWidth && this.columns.usesFlexAutoHeight) {
      this.bufferedElementResize();
    }
  }
  changeRowManager(rowManager, oldRowManager) {
    const me = this;
    if (!me._isRowMeasured) {
      me.measureRowHeight();
    }
    oldRowManager === null || oldRowManager === void 0 ? void 0 : oldRowManager.destroy();
    if (rowManager) {
      const result = RowManager.new({
        grid: me,
        rowHeight: me.rowHeight,
        rowScrollMode: me.rowScrollMode || "move",
        autoHeight: me.autoHeight,
        fixedRowHeight: me.fixedRowHeight,
        internalListeners: {
          changeTotalHeight: "onRowManagerChangeTotalHeight",
          requestScrollChange: "onRowManagerRequestScrollChange",
          thisObj: me
        }
      }, rowManager);
      me.relayEvents(result, ["beforeRenderRow", "renderRow"]);
      me._rowManager = null;
      return result;
    }
  }
  getRowHeight(record) {
    return record.rowHeight;
  }
  processRowHeight(record, height) {
  }
  bindStore(store) {
    const suffix = this.asyncEventSuffix;
    store.ion({
      name: storeListenerName,
      [`refresh${suffix}`]: "onStoreDataChange",
      [`add${suffix}`]: "onStoreAdd",
      [`remove${suffix}`]: "onStoreRemove",
      [`replace${suffix}`]: "onStoreReplace",
      [`removeAll${suffix}`]: "onStoreRemoveAll",
      [`move${suffix}`]: store.tree ? null : "onFlatStoreMove",
      change: "relayStoreDataChange",
      idChange: "onStoreRecordIdChange",
      update: "onStoreUpdateRecord",
      beforeRequest: "onStoreBeforeRequest",
      afterRequest: "onStoreAfterRequest",
      exception: "onStoreException",
      commit: "onStoreCommit",
      thisObj: this
    });
    super.bindStore(store);
  }
  unbindStore(oldStore) {
    this.detachListeners(storeListenerName);
    if (this.destroyStore) {
      oldStore.destroy();
    }
  }
  changeStore(store) {
    if (store == null) {
      return null;
    }
    if (typeof store === "string") {
      store = Store.getStore(store);
    }
    if (!store.isStore) {
      var _this$initialConfig$f;
      store = ObjectHelper.assign({
        data: this.data,
        tree: Boolean((_this$initialConfig$f = this.initialConfig.features) === null || _this$initialConfig$f === void 0 ? void 0 : _this$initialConfig$f.tree)
      }, store);
      if (!store.data) {
        delete store.data;
      }
      if (!store.modelClass) {
        store.modelClass = GridRowModel;
      }
      store = new (store.readUrl ? AjaxStore : Store)(store);
    }
    return store;
  }
  updateStore(store, was) {
    var _super$updateStore;
    const me = this;
    (_super$updateStore = super.updateStore) === null || _super$updateStore === void 0 ? void 0 : _super$updateStore.call(this, store, was);
    if (was) {
      me.unbindStore(was);
    }
    if (store) {
      if (was) {
        me.deselectAll();
      }
      me.bindStore(store);
    }
    me.trigger("bindStore", {
      store,
      oldStore: was
    });
    if (!me.isDestroying && me.isPainted && !me.refreshSuspended) {
      var _me$_rowManager;
      (_me$_rowManager = me._rowManager) === null || _me$_rowManager === void 0 ? void 0 : _me$_rowManager.reinitialize();
    }
  }
  onStoreUpdateRecord({
    source: store,
    record,
    changes
  }) {
    const me = this;
    if (me.refreshSuspended) {
      return;
    }
    if (me.forceFullRefresh) {
      me.rowManager.refresh();
      me.forceFullRefresh = false;
    } else {
      let row;
      if (record.isFieldModified("id")) {
        row = me.getRowFor(record.meta.modified.id);
      }
      row = row || me.getRowFor(record);
      if (!row) {
        return;
      }
      if (me.fullRowRefresh || record.isSpecialRow) {
        const index = store.indexOf(record);
        if (index !== -1) {
          row.render(index, record);
        }
      } else {
        me.columns.visibleColumns.forEach((column) => {
          const field = column.field, isSafe = column.constructor.simpleRenderer && !Object.prototype.hasOwnProperty.call(column.data, "renderer");
          if (!isSafe || changes[field]) {
            const cellElement = row.getCell(field);
            if (cellElement) {
              row.renderCell(cellElement);
            }
          }
        });
      }
    }
  }
  refreshFromRowOnStoreAdd(row, context) {
    const me = this, {
      rowManager
    } = me;
    rowManager.renderFromRow(row);
    rowManager.trigger("changeTotalHeight", {
      totalHeight: rowManager.totalHeight
    });
    if (me.store.count === 1) {
      me.callEachSubGrid("refreshFakeScroll");
    }
  }
  onMaskAutoClose(mask) {
    super.onMaskAutoClose(mask);
    this.toggleEmptyText();
  }
  onStoreAdd({
    source: store,
    records,
    index,
    oldIndex,
    isChild,
    oldParent,
    parent,
    isMove,
    isExpandAll
  }) {
    if (!this.isPainted || isExpandAll || this.refreshSuspended) {
      return;
    }
    const hasExpandedOldParent = isMove && records.some((record) => {
      if (isMove[record.id]) {
        const oldParent2 = store.getById(record.meta.modified.parentId);
        return (oldParent2 === null || oldParent2 === void 0 ? void 0 : oldParent2.isExpanded(store)) && (oldParent2 === null || oldParent2 === void 0 ? void 0 : oldParent2.ancestorsExpanded(store));
      }
    });
    if (isChild && !records[0].ancestorsExpanded(store) && !hasExpandedOldParent) {
      if (!parent.isLeaf) {
        const parentRow = this.rowManager.getRowById(parent);
        if (parentRow) {
          this.rowManager.renderRows([parentRow]);
        }
      }
      return;
    }
    this.rowManager.calculateRowCount(false, true, true);
    if (store.isFiltered) {
      index = store.indexOf(records[0]);
    }
    const me = this, {
      rowManager
    } = me, {
      topIndex,
      rows,
      rowCount
    } = rowManager, bottomIndex = rowManager.topIndex + rowManager.rowCount - 1, dataStart = index, dataEnd = index + records.length - 1, atEnd = bottomIndex >= store.count - records.length - 1;
    if (oldParent || oldIndex > -1 || isChild && isMove) {
      rowManager.refresh();
    } else if (dataStart >= topIndex && dataStart < topIndex + rowCount) {
      me.refreshFromRowOnStoreAdd(rows[dataStart - topIndex], ...arguments);
    } else if (dataEnd >= topIndex && dataEnd < topIndex + rowCount) {
      rowManager.refresh();
    } else {
      if (atEnd && index > bottomIndex) {
        rowManager.fillBelow(me._scrollTop || 0);
      }
      rowManager.estimateTotalHeight(true);
    }
  }
  onStoreException({
    action,
    type,
    response,
    exceptionType,
    error
  }) {
    var _response$parsedJson;
    const me = this;
    let message;
    switch (type) {
      case "server":
        message = response.message || me.L("L{unspecifiedFailure}");
        break;
      case "exception":
        message = exceptionType === "network" ? me.L("L{networkFailure}") : (error === null || error === void 0 ? void 0 : error.message) || (response === null || response === void 0 ? void 0 : (_response$parsedJson = response.parsedJson) === null || _response$parsedJson === void 0 ? void 0 : _response$parsedJson.message) || me.L("L{parseFailure}");
        break;
    }
    me.applyMaskError(`<div class="b-grid-load-failure">
                <div class="b-grid-load-fail">${me.L(action === "read" ? "L{loadFailedMessage}" : "L{syncFailedMessage}")}</div>
                ${response !== null && response !== void 0 && response.url ? `<div class="b-grid-load-fail">${response.url}</div>` : ""}
                <div class="b-grid-load-fail">${me.L("L{serverResponse}")}</div>
                <div class="b-grid-load-fail">${message}</div>
            </div>`);
  }
  onStoreDataChange({
    action,
    changes,
    source: store,
    syncInfo
  }) {
    var _super$onStoreDataCha, _syncInfo$removed;
    if (this.refreshSuspended || !this.rowManager) {
      return;
    }
    const me = this, isGroupFieldChange = store.isGrouped && changes && store.groupers.some((grouper) => grouper.field in changes);
    (_super$onStoreDataCha = super.onStoreDataChange) === null || _super$onStoreDataCha === void 0 ? void 0 : _super$onStoreDataCha.call(this, ...arguments);
    if (action === "batch" && syncInfo !== null && syncInfo !== void 0 && (_syncInfo$removed = syncInfo.removed) !== null && _syncInfo$removed !== void 0 && _syncInfo$removed.length) {
      me.rowManager.renderFromRow(me.topRow);
    } else {
      if (action === "dataset") {
        me.rowManager.clearKnownHeights();
      }
      if (me.isPainted && !isGroupFieldChange) {
        me.renderRows(Boolean(!(action in datasetReplaceActions) || me.preserveScrollOnDatasetChange));
      }
    }
    me.toggleEmptyText();
  }
  onStoreRecordIdChange() {
    super.onStoreRecordIdChange && super.onStoreRecordIdChange(...arguments);
  }
  onStoreBeforeRequest() {
    this.applyLoadMask();
  }
  onStoreAfterRequest(event) {
    if (this.loadMask && !event.exception) {
      this.masked = null;
      this.toggleEmptyText();
    }
  }
  needsFullRefreshOnStoreRemove({
    isCollapse
  }) {
    const features = this._features;
    return (features === null || features === void 0 ? void 0 : features.group) && !features.group.disabled || (features === null || features === void 0 ? void 0 : features.groupSummary) && !features.groupSummary.disabled || this.store.tree && !isCollapse && this.store.modelClass.convertEmptyParentToLeaf;
  }
  onStoreRemove({
    records,
    isCollapse,
    isChild,
    isMove,
    isCollapseAll
  }) {
    if (!this.isPainted || isMove || isCollapseAll) {
      return;
    }
    super.onStoreRemove && super.onStoreRemove(...arguments);
    const me = this, {
      rowManager
    } = me;
    rowManager.invalidateKnownHeight(records);
    if (me.animateRemovingRows && !isCollapse && !isChild) {
      const rowsToRemove = records.reduce((result, record) => {
        const row = rowManager.getRowById(record.id);
        row && result.push(row);
        return result;
      }, []);
      if (rowsToRemove.length) {
        const topRow = rowsToRemove[0];
        me.isAnimating = true;
        EventHelper.onTransitionEnd({
          element: topRow._elementsArray[0],
          property: "left",
          duration: me.transitionDuration,
          thisObj: me,
          handler: () => {
            me.isAnimating = false;
            rowsToRemove.forEach((row) => !row.isDestroyed && row.removeCls("b-removing"));
            rowManager.refresh();
            me.trigger("rowRemove");
            me.afterRemove(arguments[0]);
          }
        });
        rowsToRemove.forEach((row) => row.addCls("b-removing"));
        return;
      }
    }
    if (me.needsFullRefreshOnStoreRemove(...arguments)) {
      rowManager.refresh();
      me.afterRemove(arguments[0]);
    } else {
      const oldTopIndex = rowManager.topIndex;
      rowManager.calculateRowCount(false, true, true);
      if (rowManager.topIndex !== oldTopIndex) {
        rowManager.renderFromRow(rowManager.topRow);
      } else {
        const {
          rows
        } = rowManager, topRowIndex = records.reduce((result, record) => {
          const row = rowManager.getRowById(record.id);
          if (row) {
            result = Math.min(result, rows.indexOf(row));
          }
          return result;
        }, rows.length);
        if (rows[topRowIndex]) {
          !me.refreshSuspended && rowManager.renderFromRow(rows[topRowIndex]);
        } else {
          rowManager.trigger("changeTotalHeight", {
            totalHeight: rowManager.totalHeight
          });
        }
      }
      me.trigger("rowRemove", {
        isCollapse
      });
      me.afterRemove(arguments[0]);
    }
  }
  onFlatStoreMove({
    from,
    to
  }) {
    const {
      rowManager
    } = this, {
      topIndex,
      rowCount
    } = rowManager, [dataStart, dataEnd] = [from, to].sort((a, b) => a - b);
    if (dataStart >= topIndex && dataStart < topIndex + rowCount) {
      rowManager.renderFromRow(rowManager.rows[dataStart - topIndex]);
    } else if (dataEnd >= topIndex && dataEnd < topIndex + rowCount) {
      rowManager.refresh();
    }
  }
  onStoreReplace({
    records,
    all
  }) {
    const {
      rowManager
    } = this;
    if (all) {
      rowManager.clearKnownHeights();
      rowManager.refresh();
    } else {
      const rows = records.reduce((rows2, [, record]) => {
        const row = this.getRowFor(record);
        if (row) {
          rows2.push(row);
        }
        return rows2;
      }, []);
      rowManager.invalidateKnownHeight(records);
      rowManager.renderRows(rows);
    }
  }
  relayStoreDataChange(event) {
    this.ariaElement.setAttribute("aria-rowcount", this.store.count + 1);
    if (!this.project) {
      return this.trigger("dataChange", _objectSpread2(_objectSpread2({}, event), {}, {
        store: event.source,
        source: this
      }));
    }
  }
  onStoreRemoveAll() {
    super.onStoreRemoveAll && super.onStoreRemoveAll(...arguments);
    if (this.isPainted) {
      this.rowManager.clearKnownHeights();
      this.renderRows(false);
      this.toggleEmptyText();
    }
  }
  onStoreCommit({
    changes
  }) {
    if (this.showDirty && changes.modified.length) {
      const rows = [];
      changes.modified.forEach((record) => {
        const row = this.rowManager.getRowFor(record);
        row && rows.push(row);
      });
      this.rowManager.renderRows(rows);
    }
  }
  get data() {
    if (this._store) {
      return this._store.records;
    } else {
      return this._data;
    }
  }
  set data(data) {
    if (this._store) {
      this._store.data = data;
    } else {
      this._data = data;
    }
  }
  populateHeaderMenu({
    column,
    items: items2
  }) {
    const me = this, {
      subGrids,
      regions
    } = me, {
      parent
    } = column;
    let first = true;
    Object.entries(subGrids).forEach(([region, subGrid]) => {
      if (subGrid.sealedColumns) {
        return;
      }
      if (column.draggable && region !== column.region && (!parent && subGrids[column.region].columns.count > 1 || parent && parent.children.length > 1)) {
        const preceding = subGrid.element.compareDocumentPosition(subGrids[column.region].element) === document.DOCUMENT_POSITION_PRECEDING, moveRight = me.rtl ? !preceding : preceding, text = regions.length > 2 ? me.L("L{moveColumnTo}", me.optionalL(region)) : me.L(moveRight ? "L{moveColumnRight}" : "L{moveColumnLeft}");
        items2[`${region}Region`] = {
          targetSubGrid: region,
          text,
          icon: "b-fw-icon b-icon-column-move-" + (moveRight ? "right" : "left"),
          separator: first,
          onItem: ({
            item
          }) => {
            column.traverse((col) => col.region = region);
            me.columns.insert(me.columns.indexOf(subGrids[item.targetSubGrid].columns.last) + 1, column);
            me.scrollColumnIntoView(column);
          }
        };
        first = false;
      }
    });
  }
  populateCellMenu({
    record,
    items: items2
  }) {
  }
  getColumnDragToolbarItems(column, items2) {
    return items2;
  }
  normalizeCellContext(cellContext) {
    const grid = this, {
      columns
    } = grid;
    if (cellContext.isLocation) {
      return cellContext;
    }
    if (cellContext.isModel) {
      return new Location({
        grid,
        id: cellContext.id,
        columnId: columns.visibleColumns[0].id
      });
    }
    return new Location(ObjectHelper.assign({
      grid
    }, cellContext));
  }
  getCell(cellContext) {
    const {
      store,
      columns
    } = this, {
      visibleColumns
    } = this.columns, rowIndex = !isNaN(cellContext.row) ? cellContext.row : !isNaN(cellContext.rowIndex) ? cellContext.rowIndex : store.indexOf(cellContext.record || cellContext.id), columnIndex = !isNaN(cellContext.column) ? cellContext.column : !isNaN(cellContext.columnIndex) ? cellContext.columnIndex : visibleColumns.indexOf(cellContext.column || columns.getById(cellContext.columnId) || columns.get(cellContext.field) || visibleColumns[0]);
    return rowIndex > -1 && rowIndex < store.count && columnIndex > -1 && columnIndex < visibleColumns.length && this.normalizeCellContext(cellContext).cell || null;
  }
  getHeaderElement(columnId) {
    if (columnId.isModel) {
      columnId = columnId.id;
    }
    return this.fromCache(`.b-grid-header[data-column-id="${columnId}"]`);
  }
  getHeaderElementByField(field) {
    const column = this.columns.get(field);
    return column ? this.getHeaderElement(column) : null;
  }
  get bodyHeight() {
    return this._bodyHeight;
  }
  get headerHeight() {
    const me = this;
    if (me.isPainted && !me._headerHeight) {
      me._headerHeight = me.headerContainer.offsetHeight;
    }
    return me._headerHeight;
  }
  get footerHeight() {
    const me = this;
    if (me.isPainted && !me._footerHeight) {
      me._footerHeight = me.footerContainer.offsetHeight;
    }
    return me._footerHeight;
  }
  get isTreeGrouped() {
    var _this$features$treeGr;
    return Boolean((_this$features$treeGr = this.features.treeGroup) === null || _this$features$treeGr === void 0 ? void 0 : _this$features$treeGr.isGrouped);
  }
  getRecordFromElement(element) {
    const el = element.closest(".b-grid-row");
    if (!el)
      return null;
    return this.store.getAt(el.dataset.index);
  }
  getColumnFromElement(element) {
    const cell = element.closest(".b-grid-cell, .b-grid-header");
    if (!cell)
      return null;
    if (cell.matches(".b-grid-header")) {
      return this.columns.getById(cell.dataset.columnId);
    }
    const cellData = DomDataStore.get(cell);
    return this.columns.getById(cellData.columnId);
  }
  updateAutoHeight(autoHeight) {
    ObjectHelper.assertBoolean(autoHeight, "autoHeight");
  }
  get columnLines() {
    return this._columnLines;
  }
  set columnLines(columnLines) {
    ObjectHelper.assertBoolean(columnLines, "columnLines");
    DomHelper.toggleClasses(this.element, "b-no-column-lines", !columnLines);
    this._columnLines = columnLines;
  }
  get keyMapElement() {
    return this.bodyElement;
  }
  fixSizes() {
    this.callEachSubGrid("fixWidths");
    const colHeaders = this.headerContainer.querySelectorAll(".b-grid-header.b-depth-0");
    for (let i = 0, {
      length
    } = colHeaders; i < length; i++) {
      colHeaders[i].setAttribute("aria-colindex", i + 1);
    }
  }
  onRowManagerChangeTotalHeight({
    totalHeight,
    immediate
  }) {
    return this.refreshTotalHeight(totalHeight, immediate);
  }
  refreshTotalHeight(height = this.rowManager.totalHeight, immediate = false) {
    const me = this;
    if (me.renderingRows || !me.isVisible) {
      return false;
    }
    const scroller = me.scrollable, delta = Math.abs(me.virtualScrollHeight - height), clientHeight = me._bodyRectangle.height, newMaxY = height - clientHeight;
    if (delta) {
      const isCritical = newMaxY - me._scrollTop < clientHeight * 2 || me._verticalScrollHeight && me._verticalScrollHeight - clientHeight < me._scrollTop;
      scroller.scrollHeight = me.virtualScrollHeight = height;
      if (me.isPainted && (me.scrolling && !isCritical || delta < 100) && !immediate) {
        me.bufferedFixElementHeights();
      } else {
        me.virtualScrollHeightDirty && me.virtualScrollHeightDirty();
        me.bufferedFixElementHeights.cancel();
        me.fixElementHeights();
      }
    }
  }
  fixElementHeights() {
    const me = this, height = me.virtualScrollHeight, heightInPx = `${height}px`;
    me._verticalScrollHeight = height;
    me.verticalScroller.style.height = heightInPx;
    me.virtualScrollHeightDirty = false;
    if (me.autoHeight) {
      me.bodyContainer.style.height = heightInPx;
      me._bodyHeight = height;
      me.refreshBodyRectangle();
    }
    me.refreshVirtualScrollbars();
  }
  refreshBodyRectangle() {
    return this._bodyRectangle = Rectangle.client(this.bodyContainer);
  }
  set scrolling(scrolling) {
    this._scrolling = scrolling;
  }
  get scrolling() {
    return this._scrolling;
  }
  enableScrollingCloseToEdges(subGrids) {
    this.scrollManager.startMonitoring({
      scrollables: [{
        element: this.scrollable.element,
        direction: "vertical"
      }, ...ArrayHelper.asArray(subGrids || []).map((subGrid) => ({
        element: (typeof subGrid === "string" ? this.subGrids[subGrid] : subGrid).scrollable.element
      }))],
      direction: "horizontal"
    });
  }
  disableScrollingCloseToEdges(subGrids) {
    this.scrollManager.stopMonitoring([this.scrollable.element, ...ArrayHelper.asArray(subGrids || []).map((subGrid) => (typeof subGrid === "string" ? this.subGrids[subGrid] : subGrid).element)]);
  }
  onRowManagerRequestScrollChange({
    bottom
  }) {
    this.scrollable.y = bottom - this.bodyHeight;
  }
  initScroll() {
    const me = this, {
      scrollable
    } = me;
    if (!me.scrollInitialized) {
      me.scrollInitialized = true;
      scrollable.contentElement = me.contentElement;
      scrollable.ion({
        scroll: "onGridVerticalScroll",
        scrollend: "onGridVerticalScrollEnd",
        thisObj: me
      });
      me.callEachSubGrid("initScroll");
      if (BrowserHelper.isMobileSafari) {
        scrollable.element.style.transform = "translate3d(0, 0, 0)";
      }
    }
  }
  onGridVerticalScroll({
    source: scrollable
  }) {
    const me = this, {
      y: scrollTop
    } = scrollable;
    if (scrollTop !== me._scrollTop) {
      me._scrollTop = scrollTop;
      if (!me.scrolling) {
        me.scrolling = true;
        me.eachSubGrid((s) => s.suspendResizeMonitor = true);
      }
      me.rowManager.updateRenderedRows(scrollTop);
      me.afterScroll({
        scrollTop
      });
      me.trigger("scroll", {
        scrollTop
      });
    }
  }
  onGridVerticalScrollEnd() {
    this.scrolling = false;
    this.eachSubGrid((s) => s.suspendResizeMonitor = false);
  }
  async scrollRowIntoView(recordOrId, options = defaultScrollOptions) {
    const me = this, blockPosition = options.block || "nearest", {
      rowManager
    } = me, record = me.store.getById(recordOrId);
    if (record) {
      let scrollPromise2;
      if (me.store.indexOf(record) === -1) {
        return resolvedPromise;
      }
      let scroller = me.scrollable, recordRect = me.getRecordCoords(record);
      const scrollerRect = Rectangle.from(scroller.element);
      if (recordRect.virtual) {
        const virtualBlock = recordRect.block, innerOptions = blockPosition !== "nearest" ? options : {
          block: virtualBlock
        };
        scrollPromise2 = scroller.scrollIntoView(recordRect, {
          block: "center"
        });
        rowManager.scrollTargetRecordId = record;
        rowManager.updateRenderedRows(scroller.y, true);
        recordRect = me.getRecordCoords(record);
        rowManager.lastScrollTop = scroller.y;
        if (recordRect.virtual) {
          return resolvedPromise;
        }
        if (options.animate) {
          scroller.suspendEvents();
          if (blockPosition === "end" || blockPosition === "nearest" && virtualBlock === "end") {
            scroller.y -= scrollerRect.bottom - recordRect.bottom;
          } else if (blockPosition === "start" || blockPosition === "nearest" && virtualBlock === "start") {
            scroller.y += recordRect.y - scrollerRect.y;
          }
          rowManager.updateRenderedRows(scroller.y, false, true);
          if (virtualBlock === "end") {
            scroller.y -= rowManager.appendRowBuffer * rowManager.rowHeight - 1;
          } else {
            scroller.y += rowManager.prependRowBuffer * rowManager.rowHeight - 1;
          }
          scroller.scrollIntoView(me.getRecordCoords(record), Object.assign({}, options, innerOptions));
          scroller.resumeEvents();
        } else {
          var _me$scrollRowIntoView;
          if (!options.recursive) {
            await scrollPromise2;
          }
          await ((_me$scrollRowIntoView = me.scrollRowIntoView) === null || _me$scrollRowIntoView === void 0 ? void 0 : _me$scrollRowIntoView.call(me, record, Object.assign({
            recursive: true
          }, options, innerOptions)));
        }
      } else {
        let {
          column
        } = options;
        if (column) {
          if (!column.isModel) {
            column = me.columns.getById(column) || me.columns.get(column);
          }
          if (column) {
            scroller = me.getSubGridFromColumn(column).scrollable;
            const cellRect = Rectangle.from(rowManager.getRowFor(record).getCell(column.id));
            recordRect.x = cellRect.x;
            recordRect.width = cellRect.width;
          }
        } else {
          options.x = false;
        }
        return scroller.scrollIntoView(recordRect, options);
      }
    }
  }
  scrollColumnIntoView(column, options) {
    column = column instanceof Column ? column : this.columns.get(column) || this.columns.getById(column) || this.columns.getAt(column);
    return this.getSubGridFromColumn(column).scrollColumnIntoView(column, options);
  }
  scrollCellIntoView(cellContext, options) {
    return this.scrollRowIntoView(cellContext.id, Object.assign({
      column: cellContext.columnId
    }, typeof options === "boolean" ? {
      animate: options
    } : options));
  }
  scrollToBottom(options) {
    return this.scrollRowIntoView(this.store.last, options);
  }
  scrollToTop(options) {
    return this.scrollable.scrollBy(0, -this.scrollable.y, options);
  }
  storeScroll() {
    const me = this, state = me.storedScrollState = {
      scrollTop: me.scrollable.y,
      scrollLeft: {}
    };
    me.eachSubGrid((subGrid) => {
      state.scrollLeft[subGrid.region] = subGrid.scrollable.x;
    });
    return state;
  }
  restoreScroll(state = this.storedScrollState) {
    const me = this;
    me.eachSubGrid((subGrid) => {
      const x = state.scrollLeft[subGrid.region];
      if (x != null) {
        var _subGrid$fakeScroller;
        subGrid.scrollable.updateX(x);
        subGrid.header.scrollable.updateX(x);
        subGrid.footer.scrollable.updateX(x);
        (_subGrid$fakeScroller = subGrid.fakeScroller) === null || _subGrid$fakeScroller === void 0 ? void 0 : _subGrid$fakeScroller.updateX(x);
      }
    });
    me.scrollable.updateY(state.scrollTop);
  }
  beginGridMeasuring() {
    const me = this;
    if (!me.$measureCellElements) {
      me.$measureCellElements = DomHelper.createElement({
        className: "b-grid-subgrid " + (!me._isRowMeasured && me.hasFeature("stripe") ? "b-stripe" : ""),
        reference: "subGridElement",
        style: {
          position: "absolute",
          top: "-10000px",
          left: "-100000px",
          visibility: "hidden",
          contain: "strict"
        },
        children: [{
          className: "b-grid-row",
          reference: "rowElement",
          children: [{
            className: "b-grid-cell",
            reference: "cellElement",
            style: {
              width: "auto",
              contain: BrowserHelper.isFirefox ? "layout paint" : "layout style paint"
            }
          }]
        }]
      });
    }
    me.getConfig("element");
    me.verticalScroller.appendChild(me.$measureCellElements.subGridElement);
    if (!me.rendered) {
      const targetEl = me.appendTo || me.insertBefore || document.body, rootElement = DomHelper.getRootElement(typeof targetEl === "string" ? document.getElementById(targetEl) : targetEl);
      if (!me.adopt || !rootElement.contains(me.element)) {
        rootElement.appendChild(me.element);
        me.$removeAfterMeasuring = true;
      }
    }
    return me.$measureCellElements;
  }
  endGridMeasuring() {
    if (this.$removeAfterMeasuring) {
      this.element.remove();
      this.$removeAfterMeasuring = false;
    }
    this.$measureCellElements.subGridElement.remove();
  }
  measureRowHeight() {
    const me = this, {
      rowElement
    } = me.beginGridMeasuring(), styles = DomHelper.getStyleValue(rowElement, ["height", "border-top-width", "border-bottom-width"]), styleHeight = parseInt(styles.height), multiplier = BrowserHelper.isFirefox ? globalThis.devicePixelRatio / Math.max(Math.trunc(globalThis.devicePixelRatio), 1) : 1, borderTop = styles["border-top-width"] ? Math.round(multiplier * parseFloat(styles["border-top-width"])) : 0, borderBottom = styles["border-bottom-width"] ? Math.round(multiplier * parseFloat(styles["border-bottom-width"])) : 0;
    if (me.rowHeight == null || me.rowHeight === me._rowHeightFromStyle) {
      me.rowHeight = !isNaN(styleHeight) && styleHeight ? styleHeight : me.defaultRowHeight;
      me._rowHeightFromStyle = me.rowHeight;
    }
    me._rowBorderHeight = borderTop + borderBottom;
    me._isRowMeasured = true;
    me.endGridMeasuring();
  }
  onThemeChange({
    theme
  }) {
    this.whenVisible("measureRowHeight");
    this.trigger("theme", {
      theme
    });
  }
  refreshRows(returnToTop = false) {
    const {
      element,
      rowManager
    } = this;
    element.classList.add("b-notransition");
    if (returnToTop) {
      rowManager.returnToTop();
    } else {
      rowManager.refresh();
    }
    element.classList.remove("b-notransition");
  }
  refreshColumn(column) {
    if (column.isVisible) {
      if (column.isLeaf) {
        this.rowManager.forEach((row) => row.renderCell(row.getCell(column.id)));
      } else {
        column.children.forEach((child) => this.refreshColumn(child));
      }
    }
  }
  refreshVirtualScrollbars() {
    const me = this, {
      headerContainer,
      footerContainer,
      virtualScrollers,
      scrollable,
      hasVerticalOverflow
    } = me, {
      classList
    } = virtualScrollers, hadHorizontalOverflow = !classList.contains("b-hide-display"), hasHorizontalOverflow = Object.values(me.subGrids).some((subGrid) => subGrid.overflowingHorizontally), horizontalOverflowChanged = hasHorizontalOverflow !== hadHorizontalOverflow;
    if (horizontalOverflowChanged) {
      virtualScrollers.classList.toggle("b-hide-display", !hasHorizontalOverflow);
    }
    if (DomHelper.scrollBarWidth) {
      const needsPadding = hasVerticalOverflow || scrollable.overflowY === "scroll";
      headerContainer.classList.toggle("b-show-yscroll-padding", needsPadding);
      footerContainer.classList.toggle("b-show-yscroll-padding", needsPadding);
      virtualScrollers.classList.toggle("b-show-yscroll-padding", needsPadding);
      if (horizontalOverflowChanged) {
        if (hasHorizontalOverflow) {
          me.callEachSubGrid("refreshFakeScroll");
        }
        me.onHeightChange();
      }
    }
  }
  get hasVerticalOverflow() {
    return this.scrollable.hasOverflow("y");
  }
  get contentHeight() {
    const rowManager = this.rowManager;
    return Math.max(rowManager.totalHeight, rowManager.bottomRow ? rowManager.bottomRow.bottom : 0);
  }
  onContentChange() {
    const me = this, rowManager = me.rowManager;
    if (me.isVisible) {
      rowManager.estimateTotalHeight();
      me.paintListener = null;
      me.refreshTotalHeight(me.contentHeight);
      me.callEachSubGrid("refreshFakeScroll");
      me.onHeightChange();
    } else if (!me.paintListener) {
      me.paintListener = me.ion({
        paint: "onContentChange",
        once: true,
        thisObj: me
      });
    }
  }
  triggerPaint() {
    if (!this.isPainted) {
      this.refreshBodyRectangle();
    }
    super.triggerPaint();
  }
  onHeightChange() {
    const me = this;
    me.refreshBodyRectangle();
    me._bodyHeight = me.autoHeight ? me.contentHeight : me.bodyContainer.offsetHeight;
  }
  suspendRefresh() {
    this.refreshSuspended++;
  }
  resumeRefresh(trigger) {
    if (this.refreshSuspended && !--this.refreshSuspended) {
      if (trigger) {
        this.refreshRows();
      }
      this.trigger("resumeRefresh", {
        trigger
      });
    }
  }
  renderRows(keepScroll = true) {
    const me = this, scrollState = keepScroll && me.storeScroll();
    if (me.refreshSuspended) {
      return;
    }
    me.trigger("beforeRenderRows");
    me.renderingRows = true;
    me.element.classList.add("b-grid-refreshing");
    if (!keepScroll) {
      me.scrollable.y = me._scrollTop = 0;
    }
    me.rowManager.reinitialize(!keepScroll);
    me.trigger("renderRows");
    me.renderingRows = false;
    me.onContentChange();
    if (keepScroll) {
      me.restoreScroll(scrollState);
    }
    me.element.classList.remove("b-grid-refreshing");
  }
  renderContents() {
    const me = this, {
      element,
      headerContainer,
      footerContainer,
      rowManager
    } = me;
    me.emptyCache();
    if (me.isPainted) {
      me._headerHeight = null;
      me.callEachSubGrid("refreshHeader", headerContainer);
      me.callEachSubGrid("refreshFooter", footerContainer);
      me.renderHeader(headerContainer, element);
      me.renderFooter(footerContainer, element);
      me.fixSizes();
      const refreshContext = rowManager.removeAllRows();
      rowManager.calculateRowCount(false, true, true);
      if (rowManager.rowCount) {
        rowManager.setPosition(refreshContext);
        me.renderRows();
      }
    }
  }
  onPaintOverride() {
  }
  onPaint({
    firstPaint
  }) {
    var _super$onPaint;
    const me = this;
    me.ariaElement.setAttribute("aria-rowcount", me.store.count + 1);
    (_super$onPaint = super.onPaint) === null || _super$onPaint === void 0 ? void 0 : _super$onPaint.call(this, ...arguments);
    if (me.onPaintOverride() || !firstPaint) {
      return;
    }
    const {
      rowManager,
      store,
      element,
      headerContainer,
      bodyContainer,
      footerContainer
    } = me, scrollPad = DomHelper.scrollBarPadElement;
    let columnsChanged, maxDepth = 0;
    me.role = store !== null && store !== void 0 && store.isTree ? "treegrid" : "grid";
    me.columns.ion({
      change: () => columnsChanged = true,
      once: true
    });
    me.updateResponsive(me.width, 0);
    if (columnsChanged) {
      me.callEachSubGrid("refreshHeader", headerContainer);
      me.callEachSubGrid("refreshFooter", footerContainer);
    }
    me.renderHeader(headerContainer, element);
    me.renderFooter(footerContainer, element);
    DomHelper.append(headerContainer, scrollPad);
    DomHelper.append(footerContainer, scrollPad);
    DomHelper.append(me.virtualScrollers, scrollPad);
    me.refreshBodyRectangle();
    const bodyOffsetHeight = me.bodyContainer.offsetHeight;
    if (me.autoHeight) {
      me._bodyHeight = rowManager.initWithHeight(element.offsetHeight - headerContainer.offsetHeight - footerContainer.offsetHeight, true);
      bodyContainer.style.height = me.bodyHeight + "px";
    } else {
      me._bodyHeight = bodyOffsetHeight;
      rowManager.initWithHeight(me._bodyHeight, true);
    }
    me.eachSubGrid((subGrid) => {
      if (subGrid.header.maxDepth > maxDepth) {
        maxDepth = subGrid.header.maxDepth;
      }
    });
    headerContainer.dataset.maxDepth = maxDepth;
    me.fixSizes();
    if (store.count || !store.isLoading) {
      me.renderRows();
    }
    if (me.columns.usesAutoHeight) {
      const {
        fonts
      } = document;
      if ((fonts === null || fonts === void 0 ? void 0 : fonts.status) !== "loaded") {
        fonts.ready.then(() => !me.isDestroyed && me.refreshRows());
      }
    }
    me.initScroll();
    me.initInternalEvents();
  }
  render() {
    const me = this;
    me.requireSize = Boolean(me.owner);
    super.render(...arguments);
    if (!me.autoHeight) {
      if (me.headerContainer.offsetHeight && !me.bodyContainer.offsetHeight) {
        console.warn("Grid element not sized correctly, please check your CSS styles and review how you size the widget");
      }
      if (!("minHeight" in me.initialConfig) && !("height" in me.initialConfig) && parseInt(globalThis.getComputedStyle(me.element).minHeight) === me.height) {
        console.warn(`The ${me.$$name} is sized by its predefined minHeight, likely this is not intended. Please check your CSS and review how you size the widget, or assign a fixed height in the config. For more information, see the "Basics/Sizing the component" guide in docs.`);
      }
    }
  }
  renderHeader(headerContainer, element) {
  }
  renderFooter(footerContainer, element) {
  }
  beforeRenderCell() {
  }
  beforeRenderRow() {
  }
  afterRenderRow() {
  }
  afterScroll() {
  }
  processCellEditor(editorConfig) {
  }
  afterColumnsChange() {
  }
  afterRemove(removeEvent) {
  }
  afterToggleGroup() {
  }
  afterToggleSubGrid() {
  }
  syncMaskCover(mask = this.masked) {
    if (mask) {
      const bodyRect = mask.cover === "body" && this.rectangleOf("bodyContainer"), scrollerRect = bodyRect && this.rectangleOf("virtualScrollers"), {
        style
      } = mask.element;
      style.marginTop = bodyRect ? `${bodyRect.y}px` : "";
      style.height = bodyRect ? `${bodyRect.height + ((scrollerRect === null || scrollerRect === void 0 ? void 0 : scrollerRect.height) || 0)}px` : "";
    }
  }
  maskBody(loadMask) {
    let ret;
    if (this.bodyContainer) {
      this.masked = Mask.mergeConfigs(this.loadMaskDefaults, loadMask);
      ret = this.masked;
    }
    return ret;
  }
  unmaskBody() {
    this.masked = null;
  }
  updateEmptyText(emptyText) {
    var _this$emptyTextEl, _this$firstItem;
    (_this$emptyTextEl = this.emptyTextEl) === null || _this$emptyTextEl === void 0 ? void 0 : _this$emptyTextEl.remove();
    this.emptyTextEl = DomHelper.createElement({
      parent: (_this$firstItem = this.firstItem) === null || _this$firstItem === void 0 ? void 0 : _this$firstItem.element,
      className: "b-empty-text",
      [emptyText !== null && emptyText !== void 0 && emptyText.includes("<") ? "html" : "text"]: emptyText
    });
  }
  toggleEmptyText() {
    const {
      bodyContainer,
      store
    } = this;
    bodyContainer === null || bodyContainer === void 0 ? void 0 : bodyContainer.classList.toggle("b-grid-empty", !(store.count > 0 || store.isLoading || store.isCommitting));
  }
  updateReadOnly(readOnly, old) {
    super.updateReadOnly(readOnly, old);
    if (!this.isConfiguring) {
      for (const column of this.columns.bottomColumns) {
        var _column$updateReadOnl;
        (_column$updateReadOnl = column.updateReadOnly) === null || _column$updateReadOnl === void 0 ? void 0 : _column$updateReadOnl.call(column, readOnly);
      }
    }
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options), {
      store
    } = this, data = store.getInlineData(options), storeState = store.getCurrentConfig(options) || result.store;
    if (data.length) {
      result.data = data;
    }
    if (storeState && store.originalModelClass === GridRowModel) {
      delete storeState.modelClass;
    }
    if (!ObjectHelper.isEmpty(storeState)) {
      result.store = storeState;
    }
    if (result.store) {
      delete result.store.data;
    }
    return result;
  }
};
GridBase.initClass();
VersionHelper.setVersion("grid", "5.3.0");
GridBase._$name = "GridBase";
var Grid = class extends GridBase {
  static get $name() {
    return "Grid";
  }
  static get type() {
    return "grid";
  }
};
Grid.initClass();
Grid._$name = "Grid";
var TreeGrid = class extends Grid {
  static get $name() {
    return "TreeGrid";
  }
  static get type() {
    return "treegrid";
  }
  static get configurable() {
    return {
      store: {
        tree: true
      }
    };
  }
  updateStore(store, was) {
    if (store && !store.tree) {
      throw new Error("TreeGrid requires a Store configured with tree : true");
    }
    super.updateStore(store, was);
  }
};
TreeGrid.initClass();
TreeGrid._$name = "TreeGrid";
var TreeCombo = class extends Combo {
  configure(config) {
    super.configure(config);
    const me = this;
    me.ion({
      change() {
        me.picker.selectedRecords = me.value;
      }
    });
  }
  changePicker(picker, oldPicker) {
    const me = this;
    return super.changePicker(ObjectHelper.assign({}, picker, {
      type: "treegrid",
      minWidth: "35em",
      readOnly: me.readOnly,
      disableGridRowModelWarning: true,
      selectedRecords: me.value.map((val) => me.store.getById(val)),
      selectionMode: {
        row: true,
        multiSelect: me.multiSelect,
        rowCheckboxSelection: true
      },
      internalListeners: {
        selectionChange({
          selection
        }) {
          me.value = selection;
        }
      }
    }), oldPicker);
  }
};
_defineProperty(TreeCombo, "$name", "TreeCombo");
_defineProperty(TreeCombo, "type", "treecombo");
_defineProperty(TreeCombo, "configurable", {
  multiSelect: true,
  chipView: {
    itemTpl(record) {
      return StringHelper.xss`${record.name}`;
    },
    scrollable: {
      overflowX: "hidden-scroll"
    }
  }
});
TreeCombo.initClass();
TreeCombo._$name = "TreeCombo";

export {
  BrowserHelper,
  StringHelper,
  Objects,
  VersionHelper,
  Config,
  Base,
  ArrayHelper,
  FunctionHelper,
  Events,
  AsyncHelper,
  AjaxHelper,
  LocaleHelper,
  LocaleManagerSingleton,
  Localizable,
  unitMagnitudes,
  DateHelper,
  ObjectHelper,
  Rectangle,
  DomClassList,
  Point,
  EventHelper,
  DomHelper,
  GlobalEvents$1,
  InstancePlugin,
  Pluggable,
  Delayable,
  StateStorage,
  StateProvider,
  State,
  Identifiable,
  ModelStm,
  TreeNode,
  ModelLink,
  Factoryable,
  DataField,
  ArrayDataField,
  BooleanDataField,
  DateDataField,
  StringDataField,
  IntegerDataField,
  ModelDataField,
  NumberDataField,
  ObjectDataField,
  StoreDataField,
  Model,
  Duration,
  CollectionFilter,
  IdHelper,
  CollectionSorter,
  Collection,
  Bag,
  StoreCRUD,
  StoreChanges,
  StoreFilter,
  StoreGroup,
  StoreProxy,
  StoreRelation,
  StoreSum,
  StoreSearch,
  StoreSort,
  StoreChained,
  StoreState,
  Wbs,
  StoreTree,
  WalkHelper,
  StoreSync,
  StoreStm,
  Store,
  AjaxStore,
  DomDataStore,
  ActionBase,
  StateBase,
  Transaction,
  UpdateAction,
  StateTrackingManager,
  DomSync,
  Fullscreen,
  ResizeMonitor,
  Scroller,
  Promissory,
  Renderable,
  Mask,
  KeyMap,
  RTL,
  Widget,
  Layout,
  Ripple,
  Container,
  Animator,
  ClickRepeater,
  Rotatable,
  Tool,
  CollapseTool,
  PanelCollapser,
  DynamicObject,
  Toolable,
  Badge,
  Button,
  Toolbar,
  Panel,
  Popup,
  MenuItem,
  Menu,
  ContextMenuBase,
  CSSHelper,
  DragHelper,
  ResizeHelper,
  TemplateHelper,
  TimeZoneHelper,
  Toast,
  WidgetHelper,
  XMLHelper,
  RandomGenerator,
  DataGenerator,
  DemoBot,
  Formatter,
  Navigator,
  NumberFormat,
  WebSocketManager,
  Finalizable,
  DragContext,
  DragProxy,
  Draggable,
  Droppable,
  Featureable,
  Hoverable,
  LoadMaskable,
  Override,
  Fencible,
  DayTime,
  Month,
  Parser,
  ScrollManager,
  Tooltip,
  DragTipProxy,
  Labelable,
  FieldContainer,
  Field,
  TextField,
  PickerField,
  List,
  ChipView,
  Combo,
  UndoRedoBase,
  BooleanCombo,
  ButtonGroup,
  CalendarPanel,
  Checkbox,
  YearPicker,
  DisplayField,
  DatePicker,
  DateField,
  NumberField,
  TimePicker,
  TimeField,
  DateTimeField,
  DurationField,
  Editor,
  FieldFilterPicker,
  Label,
  FieldFilterPickerGroup,
  FieldSet,
  FileField,
  FilePicker,
  FilterField,
  MessageDialog,
  PagingToolbar,
  PanelCollapserOverlay,
  PasswordField,
  Radio,
  RadioGroup,
  Slider,
  SlideToggle,
  Splitter,
  Tab,
  TabBar,
  TabPanel,
  TextAreaField,
  TextAreaPickerField,
  Minifiable,
  Responsive,
  Styleable,
  Histogram,
  Scale,
  AvatarRendering,
  Location,
  Column,
  ColumnStore,
  ActionColumn,
  NumberColumn,
  AggregateColumn,
  WidgetColumn,
  CheckColumn,
  DateColumn,
  PercentColumn,
  RatingColumn,
  RowNumberColumn,
  TemplateColumn,
  TimeColumn,
  TreeColumn,
  GridRowModel,
  GridFeatureManager,
  CellCopyPaste,
  CellEdit,
  CellMenu,
  CellTooltip,
  ColumnAutoWidth,
  ColumnDragToolbar,
  ColumnPicker,
  ColumnRename,
  ColumnReorder,
  ColumnResize,
  FillHandle,
  GridFieldFilterPicker,
  GridFieldFilterPickerGroup,
  Filter,
  FilterBar,
  Group,
  GroupSummary,
  HeaderMenu,
  MergeCells,
  QuickFind,
  RegionResize,
  RowCopyPaste,
  RowExpander,
  RowReorder,
  Search,
  Sort,
  StickyCells,
  Stripe,
  Summary,
  Tree,
  TreeGroup,
  RowsRange,
  PaperFormat,
  Orientation,
  FileFormat,
  ExportRowsCombo,
  ExportOrientationCombo,
  ExportDialog,
  Row,
  Exporter,
  MultiPageExporter,
  MultiPageVerticalExporter,
  SinglePageExporter,
  PdfExport,
  TableExporter,
  ExcelExporter,
  Bar,
  Footer,
  RowManager,
  Header,
  GridElementEvents,
  GridFeatures,
  GridResponsive,
  GridSelection,
  GridState,
  SubGrid,
  GridSubGrids,
  GridBase,
  Grid,
  TreeGrid,
  TreeCombo
};
/*!
 *
 * Bryntum Grid 5.3.0
 *
 * Copyright(c) 2023 Bryntum AB
 * https://bryntum.com/contact
 * https://bryntum.com/license
 *
 */
//# sourceMappingURL=chunk-SECPYHOQ.js.map
