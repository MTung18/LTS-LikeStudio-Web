import {
  require_vue
} from "./chunk-W3TL672D.js";
import {
  bootstrap_esm_exports,
  init_bootstrap_esm
} from "./chunk-FP7A37RA.js";
import {
  esm_exports,
  init_esm
} from "./chunk-6PFUNP2T.js";
import "./chunk-EBQ43PD5.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-S5KM4IGW.js";

// node_modules/vue-router/dist/vue-router.cjs
var require_vue_router = __commonJS({
  "node_modules/vue-router/dist/vue-router.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var devtoolsApi = (init_esm(), __toCommonJS(esm_exports));
    var isBrowser = typeof window !== "undefined";
    function isESModule(obj) {
      return obj.__esModule || obj[Symbol.toStringTag] === "Module";
    }
    var assign = Object.assign;
    function applyToParams(fn, params) {
      const newParams = {};
      for (const key in params) {
        const value = params[key];
        newParams[key] = isArray2(value) ? value.map(fn) : fn(value);
      }
      return newParams;
    }
    var noop = () => {
    };
    var isArray2 = Array.isArray;
    function warn(msg) {
      const args = Array.from(arguments).slice(1);
      console.warn.apply(console, ["[Vue Router warn]: " + msg].concat(args));
    }
    var TRAILING_SLASH_RE = /\/$/;
    var removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
    function parseURL(parseQuery2, location2, currentLocation = "/") {
      let path, query = {}, searchString = "", hash = "";
      const hashPos = location2.indexOf("#");
      let searchPos = location2.indexOf("?");
      if (hashPos < searchPos && hashPos >= 0) {
        searchPos = -1;
      }
      if (searchPos > -1) {
        path = location2.slice(0, searchPos);
        searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
        query = parseQuery2(searchString);
      }
      if (hashPos > -1) {
        path = path || location2.slice(0, hashPos);
        hash = location2.slice(hashPos, location2.length);
      }
      path = resolveRelativePath(path != null ? path : location2, currentLocation);
      return {
        fullPath: path + (searchString && "?") + searchString + hash,
        path,
        query,
        hash
      };
    }
    function stringifyURL(stringifyQuery2, location2) {
      const query = location2.query ? stringifyQuery2(location2.query) : "";
      return location2.path + (query && "?") + query + (location2.hash || "");
    }
    function stripBase(pathname, base) {
      if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
        return pathname;
      return pathname.slice(base.length) || "/";
    }
    function isSameRouteLocation(stringifyQuery2, a, b) {
      const aLastIndex = a.matched.length - 1;
      const bLastIndex = b.matched.length - 1;
      return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
    }
    function isSameRouteRecord(a, b) {
      return (a.aliasOf || a) === (b.aliasOf || b);
    }
    function isSameRouteLocationParams(a, b) {
      if (Object.keys(a).length !== Object.keys(b).length)
        return false;
      for (const key in a) {
        if (!isSameRouteLocationParamsValue(a[key], b[key]))
          return false;
      }
      return true;
    }
    function isSameRouteLocationParamsValue(a, b) {
      return isArray2(a) ? isEquivalentArray(a, b) : isArray2(b) ? isEquivalentArray(b, a) : a === b;
    }
    function isEquivalentArray(a, b) {
      return isArray2(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;
    }
    function resolveRelativePath(to, from) {
      if (to.startsWith("/"))
        return to;
      if (!from.startsWith("/")) {
        warn(`Cannot resolve a relative location without an absolute path. Trying to resolve "${to}" from "${from}". It should look like "/${from}".`);
        return to;
      }
      if (!to)
        return from;
      const fromSegments = from.split("/");
      const toSegments = to.split("/");
      let position = fromSegments.length - 1;
      let toPosition;
      let segment;
      for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
        segment = toSegments[toPosition];
        if (segment === ".")
          continue;
        if (segment === "..") {
          if (position > 1)
            position--;
        } else
          break;
      }
      return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
    }
    var NavigationType;
    (function(NavigationType2) {
      NavigationType2["pop"] = "pop";
      NavigationType2["push"] = "push";
    })(NavigationType || (NavigationType = {}));
    var NavigationDirection;
    (function(NavigationDirection2) {
      NavigationDirection2["back"] = "back";
      NavigationDirection2["forward"] = "forward";
      NavigationDirection2["unknown"] = "";
    })(NavigationDirection || (NavigationDirection = {}));
    var START = "";
    function normalizeBase(base) {
      if (!base) {
        if (isBrowser) {
          const baseEl = document.querySelector("base");
          base = baseEl && baseEl.getAttribute("href") || "/";
          base = base.replace(/^\w+:\/\/[^\/]+/, "");
        } else {
          base = "/";
        }
      }
      if (base[0] !== "/" && base[0] !== "#")
        base = "/" + base;
      return removeTrailingSlash(base);
    }
    var BEFORE_HASH_RE = /^[^#]+#/;
    function createHref(base, location2) {
      return base.replace(BEFORE_HASH_RE, "#") + location2;
    }
    function getElementPosition(el, offset) {
      const docRect = document.documentElement.getBoundingClientRect();
      const elRect = el.getBoundingClientRect();
      return {
        behavior: offset.behavior,
        left: elRect.left - docRect.left - (offset.left || 0),
        top: elRect.top - docRect.top - (offset.top || 0)
      };
    }
    var computeScrollPosition = () => ({
      left: window.pageXOffset,
      top: window.pageYOffset
    });
    function scrollToPosition(position) {
      let scrollToOptions;
      if ("el" in position) {
        const positionEl = position.el;
        const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
        if (typeof position.el === "string") {
          if (!isIdSelector || !document.getElementById(position.el.slice(1))) {
            try {
              const foundEl = document.querySelector(position.el);
              if (isIdSelector && foundEl) {
                warn(`The selector "${position.el}" should be passed as "el: document.querySelector('${position.el}')" because it starts with "#".`);
                return;
              }
            } catch (err) {
              warn(`The selector "${position.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);
              return;
            }
          }
        }
        const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
        if (!el) {
          warn(`Couldn't find element using selector "${position.el}" returned by scrollBehavior.`);
          return;
        }
        scrollToOptions = getElementPosition(el, position);
      } else {
        scrollToOptions = position;
      }
      if ("scrollBehavior" in document.documentElement.style)
        window.scrollTo(scrollToOptions);
      else {
        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
      }
    }
    function getScrollKey(path, delta) {
      const position = history.state ? history.state.position - delta : -1;
      return position + path;
    }
    var scrollPositions = /* @__PURE__ */ new Map();
    function saveScrollPosition(key, scrollPosition) {
      scrollPositions.set(key, scrollPosition);
    }
    function getSavedScrollPosition(key) {
      const scroll = scrollPositions.get(key);
      scrollPositions.delete(key);
      return scroll;
    }
    var createBaseLocation = () => location.protocol + "//" + location.host;
    function createCurrentLocation(base, location2) {
      const { pathname, search, hash } = location2;
      const hashPos = base.indexOf("#");
      if (hashPos > -1) {
        let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
        let pathFromHash = hash.slice(slicePos);
        if (pathFromHash[0] !== "/")
          pathFromHash = "/" + pathFromHash;
        return stripBase(pathFromHash, "");
      }
      const path = stripBase(pathname, base);
      return path + search + hash;
    }
    function useHistoryListeners(base, historyState, currentLocation, replace) {
      let listeners = [];
      let teardowns = [];
      let pauseState = null;
      const popStateHandler = ({ state }) => {
        const to = createCurrentLocation(base, location);
        const from = currentLocation.value;
        const fromState = historyState.value;
        let delta = 0;
        if (state) {
          currentLocation.value = to;
          historyState.value = state;
          if (pauseState && pauseState === from) {
            pauseState = null;
            return;
          }
          delta = fromState ? state.position - fromState.position : 0;
        } else {
          replace(to);
        }
        listeners.forEach((listener) => {
          listener(currentLocation.value, from, {
            delta,
            type: NavigationType.pop,
            direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
          });
        });
      };
      function pauseListeners() {
        pauseState = currentLocation.value;
      }
      function listen(callback) {
        listeners.push(callback);
        const teardown = () => {
          const index = listeners.indexOf(callback);
          if (index > -1)
            listeners.splice(index, 1);
        };
        teardowns.push(teardown);
        return teardown;
      }
      function beforeUnloadListener() {
        const { history: history2 } = window;
        if (!history2.state)
          return;
        history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
      }
      function destroy() {
        for (const teardown of teardowns)
          teardown();
        teardowns = [];
        window.removeEventListener("popstate", popStateHandler);
        window.removeEventListener("beforeunload", beforeUnloadListener);
      }
      window.addEventListener("popstate", popStateHandler);
      window.addEventListener("beforeunload", beforeUnloadListener);
      return {
        pauseListeners,
        listen,
        destroy
      };
    }
    function buildState(back, current, forward, replaced = false, computeScroll = false) {
      return {
        back,
        current,
        forward,
        replaced,
        position: window.history.length,
        scroll: computeScroll ? computeScrollPosition() : null
      };
    }
    function useHistoryStateNavigation(base) {
      const { history: history2, location: location2 } = window;
      const currentLocation = {
        value: createCurrentLocation(base, location2)
      };
      const historyState = { value: history2.state };
      if (!historyState.value) {
        changeLocation(currentLocation.value, {
          back: null,
          current: currentLocation.value,
          forward: null,
          position: history2.length - 1,
          replaced: true,
          scroll: null
        }, true);
      }
      function changeLocation(to, state, replace2) {
        const hashIndex = base.indexOf("#");
        const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
        try {
          history2[replace2 ? "replaceState" : "pushState"](state, "", url);
          historyState.value = state;
        } catch (err) {
          {
            warn("Error with push/replace State", err);
          }
          location2[replace2 ? "replace" : "assign"](url);
        }
      }
      function replace(to, data) {
        const state = assign({}, history2.state, buildState(
          historyState.value.back,
          to,
          historyState.value.forward,
          true
        ), data, { position: historyState.value.position });
        changeLocation(to, state, true);
        currentLocation.value = to;
      }
      function push(to, data) {
        const currentState = assign(
          {},
          historyState.value,
          history2.state,
          {
            forward: to,
            scroll: computeScrollPosition()
          }
        );
        if (!history2.state) {
          warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:

history.replaceState(history.state, '', url)

You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);
        }
        changeLocation(currentState.current, currentState, true);
        const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
        changeLocation(to, state, false);
        currentLocation.value = to;
      }
      return {
        location: currentLocation,
        state: historyState,
        push,
        replace
      };
    }
    function createWebHistory(base) {
      base = normalizeBase(base);
      const historyNavigation = useHistoryStateNavigation(base);
      const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
      function go(delta, triggerListeners = true) {
        if (!triggerListeners)
          historyListeners.pauseListeners();
        history.go(delta);
      }
      const routerHistory = assign({
        location: "",
        base,
        go,
        createHref: createHref.bind(null, base)
      }, historyNavigation, historyListeners);
      Object.defineProperty(routerHistory, "location", {
        enumerable: true,
        get: () => historyNavigation.location.value
      });
      Object.defineProperty(routerHistory, "state", {
        enumerable: true,
        get: () => historyNavigation.state.value
      });
      return routerHistory;
    }
    function createMemoryHistory(base = "") {
      let listeners = [];
      let queue = [START];
      let position = 0;
      base = normalizeBase(base);
      function setLocation(location2) {
        position++;
        if (position === queue.length) {
          queue.push(location2);
        } else {
          queue.splice(position);
          queue.push(location2);
        }
      }
      function triggerListeners(to, from, { direction, delta }) {
        const info = {
          direction,
          delta,
          type: NavigationType.pop
        };
        for (const callback of listeners) {
          callback(to, from, info);
        }
      }
      const routerHistory = {
        location: START,
        state: {},
        base,
        createHref: createHref.bind(null, base),
        replace(to) {
          queue.splice(position--, 1);
          setLocation(to);
        },
        push(to, data) {
          setLocation(to);
        },
        listen(callback) {
          listeners.push(callback);
          return () => {
            const index = listeners.indexOf(callback);
            if (index > -1)
              listeners.splice(index, 1);
          };
        },
        destroy() {
          listeners = [];
          queue = [START];
          position = 0;
        },
        go(delta, shouldTrigger = true) {
          const from = this.location;
          const direction = delta < 0 ? NavigationDirection.back : NavigationDirection.forward;
          position = Math.max(0, Math.min(position + delta, queue.length - 1));
          if (shouldTrigger) {
            triggerListeners(this.location, from, {
              direction,
              delta
            });
          }
        }
      };
      Object.defineProperty(routerHistory, "location", {
        enumerable: true,
        get: () => queue[position]
      });
      return routerHistory;
    }
    function createWebHashHistory(base) {
      base = location.host ? base || location.pathname + location.search : "";
      if (!base.includes("#"))
        base += "#";
      if (!base.endsWith("#/") && !base.endsWith("#")) {
        warn(`A hash base must end with a "#":
"${base}" should be "${base.replace(/#.*$/, "#")}".`);
      }
      return createWebHistory(base);
    }
    function isRouteLocation(route) {
      return typeof route === "string" || route && typeof route === "object";
    }
    function isRouteName(name) {
      return typeof name === "string" || typeof name === "symbol";
    }
    var START_LOCATION_NORMALIZED = {
      path: "/",
      name: void 0,
      params: {},
      query: {},
      hash: "",
      fullPath: "/",
      matched: [],
      meta: {},
      redirectedFrom: void 0
    };
    var NavigationFailureSymbol = Symbol("navigation failure");
    exports.NavigationFailureType = void 0;
    (function(NavigationFailureType) {
      NavigationFailureType[NavigationFailureType["aborted"] = 4] = "aborted";
      NavigationFailureType[NavigationFailureType["cancelled"] = 8] = "cancelled";
      NavigationFailureType[NavigationFailureType["duplicated"] = 16] = "duplicated";
    })(exports.NavigationFailureType || (exports.NavigationFailureType = {}));
    var ErrorTypeMessages = {
      [1]({ location: location2, currentLocation }) {
        return `No match for
 ${JSON.stringify(location2)}${currentLocation ? "\nwhile being at\n" + JSON.stringify(currentLocation) : ""}`;
      },
      [2]({ from, to }) {
        return `Redirected from "${from.fullPath}" to "${stringifyRoute(to)}" via a navigation guard.`;
      },
      [4]({ from, to }) {
        return `Navigation aborted from "${from.fullPath}" to "${to.fullPath}" via a navigation guard.`;
      },
      [8]({ from, to }) {
        return `Navigation cancelled from "${from.fullPath}" to "${to.fullPath}" with a new navigation.`;
      },
      [16]({ from, to }) {
        return `Avoided redundant navigation to current location: "${from.fullPath}".`;
      }
    };
    function createRouterError(type, params) {
      {
        return assign(new Error(ErrorTypeMessages[type](params)), {
          type,
          [NavigationFailureSymbol]: true
        }, params);
      }
    }
    function isNavigationFailure(error, type) {
      return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
    }
    var propertiesToLog = ["params", "query", "hash"];
    function stringifyRoute(to) {
      if (typeof to === "string")
        return to;
      if ("path" in to)
        return to.path;
      const location2 = {};
      for (const key of propertiesToLog) {
        if (key in to)
          location2[key] = to[key];
      }
      return JSON.stringify(location2, null, 2);
    }
    var BASE_PARAM_PATTERN = "[^/]+?";
    var BASE_PATH_PARSER_OPTIONS = {
      sensitive: false,
      strict: false,
      start: true,
      end: true
    };
    var REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
    function tokensToParser(segments, extraOptions) {
      const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
      const score = [];
      let pattern = options.start ? "^" : "";
      const keys2 = [];
      for (const segment of segments) {
        const segmentScores = segment.length ? [] : [90];
        if (options.strict && !segment.length)
          pattern += "/";
        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
          const token = segment[tokenIndex];
          let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
          if (token.type === 0) {
            if (!tokenIndex)
              pattern += "/";
            pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
            subSegmentScore += 40;
          } else if (token.type === 1) {
            const { value, repeatable, optional, regexp } = token;
            keys2.push({
              name: value,
              repeatable,
              optional
            });
            const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
            if (re2 !== BASE_PARAM_PATTERN) {
              subSegmentScore += 10;
              try {
                new RegExp(`(${re2})`);
              } catch (err) {
                throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
              }
            }
            let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
            if (!tokenIndex)
              subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
            if (optional)
              subPattern += "?";
            pattern += subPattern;
            subSegmentScore += 20;
            if (optional)
              subSegmentScore += -8;
            if (repeatable)
              subSegmentScore += -20;
            if (re2 === ".*")
              subSegmentScore += -50;
          }
          segmentScores.push(subSegmentScore);
        }
        score.push(segmentScores);
      }
      if (options.strict && options.end) {
        const i = score.length - 1;
        score[i][score[i].length - 1] += 0.7000000000000001;
      }
      if (!options.strict)
        pattern += "/?";
      if (options.end)
        pattern += "$";
      else if (options.strict)
        pattern += "(?:/|$)";
      const re = new RegExp(pattern, options.sensitive ? "" : "i");
      function parse(path) {
        const match = path.match(re);
        const params = {};
        if (!match)
          return null;
        for (let i = 1; i < match.length; i++) {
          const value = match[i] || "";
          const key = keys2[i - 1];
          params[key.name] = value && key.repeatable ? value.split("/") : value;
        }
        return params;
      }
      function stringify(params) {
        let path = "";
        let avoidDuplicatedSlash = false;
        for (const segment of segments) {
          if (!avoidDuplicatedSlash || !path.endsWith("/"))
            path += "/";
          avoidDuplicatedSlash = false;
          for (const token of segment) {
            if (token.type === 0) {
              path += token.value;
            } else if (token.type === 1) {
              const { value, repeatable, optional } = token;
              const param = value in params ? params[value] : "";
              if (isArray2(param) && !repeatable) {
                throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
              }
              const text = isArray2(param) ? param.join("/") : param;
              if (!text) {
                if (optional) {
                  if (segment.length < 2) {
                    if (path.endsWith("/"))
                      path = path.slice(0, -1);
                    else
                      avoidDuplicatedSlash = true;
                  }
                } else
                  throw new Error(`Missing required param "${value}"`);
              }
              path += text;
            }
          }
        }
        return path || "/";
      }
      return {
        re,
        score,
        keys: keys2,
        parse,
        stringify
      };
    }
    function compareScoreArray(a, b) {
      let i = 0;
      while (i < a.length && i < b.length) {
        const diff = b[i] - a[i];
        if (diff)
          return diff;
        i++;
      }
      if (a.length < b.length) {
        return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
      } else if (a.length > b.length) {
        return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
      }
      return 0;
    }
    function comparePathParserScore(a, b) {
      let i = 0;
      const aScore = a.score;
      const bScore = b.score;
      while (i < aScore.length && i < bScore.length) {
        const comp = compareScoreArray(aScore[i], bScore[i]);
        if (comp)
          return comp;
        i++;
      }
      if (Math.abs(bScore.length - aScore.length) === 1) {
        if (isLastScoreNegative(aScore))
          return 1;
        if (isLastScoreNegative(bScore))
          return -1;
      }
      return bScore.length - aScore.length;
    }
    function isLastScoreNegative(score) {
      const last = score[score.length - 1];
      return score.length > 0 && last[last.length - 1] < 0;
    }
    var ROOT_TOKEN = {
      type: 0,
      value: ""
    };
    var VALID_PARAM_RE = /[a-zA-Z0-9_]/;
    function tokenizePath(path) {
      if (!path)
        return [[]];
      if (path === "/")
        return [[ROOT_TOKEN]];
      if (!path.startsWith("/")) {
        throw new Error(
          `Route paths should start with a "/": "${path}" should be "/${path}".`
        );
      }
      function crash(message) {
        throw new Error(`ERR (${state})/"${buffer}": ${message}`);
      }
      let state = 0;
      let previousState = state;
      const tokens = [];
      let segment;
      function finalizeSegment() {
        if (segment)
          tokens.push(segment);
        segment = [];
      }
      let i = 0;
      let char;
      let buffer = "";
      let customRe = "";
      function consumeBuffer() {
        if (!buffer)
          return;
        if (state === 0) {
          segment.push({
            type: 0,
            value: buffer
          });
        } else if (state === 1 || state === 2 || state === 3) {
          if (segment.length > 1 && (char === "*" || char === "+"))
            crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
          segment.push({
            type: 1,
            value: buffer,
            regexp: customRe,
            repeatable: char === "*" || char === "+",
            optional: char === "*" || char === "?"
          });
        } else {
          crash("Invalid state to consume buffer");
        }
        buffer = "";
      }
      function addCharToBuffer() {
        buffer += char;
      }
      while (i < path.length) {
        char = path[i++];
        if (char === "\\" && state !== 2) {
          previousState = state;
          state = 4;
          continue;
        }
        switch (state) {
          case 0:
            if (char === "/") {
              if (buffer) {
                consumeBuffer();
              }
              finalizeSegment();
            } else if (char === ":") {
              consumeBuffer();
              state = 1;
            } else {
              addCharToBuffer();
            }
            break;
          case 4:
            addCharToBuffer();
            state = previousState;
            break;
          case 1:
            if (char === "(") {
              state = 2;
            } else if (VALID_PARAM_RE.test(char)) {
              addCharToBuffer();
            } else {
              consumeBuffer();
              state = 0;
              if (char !== "*" && char !== "?" && char !== "+")
                i--;
            }
            break;
          case 2:
            if (char === ")") {
              if (customRe[customRe.length - 1] == "\\")
                customRe = customRe.slice(0, -1) + char;
              else
                state = 3;
            } else {
              customRe += char;
            }
            break;
          case 3:
            consumeBuffer();
            state = 0;
            if (char !== "*" && char !== "?" && char !== "+")
              i--;
            customRe = "";
            break;
          default:
            crash("Unknown state");
            break;
        }
      }
      if (state === 2)
        crash(`Unfinished custom RegExp for param "${buffer}"`);
      consumeBuffer();
      finalizeSegment();
      return tokens;
    }
    function createRouteRecordMatcher(record, parent, options) {
      const parser = tokensToParser(tokenizePath(record.path), options);
      {
        const existingKeys = /* @__PURE__ */ new Set();
        for (const key of parser.keys) {
          if (existingKeys.has(key.name))
            warn(`Found duplicated params with name "${key.name}" for path "${record.path}". Only the last one will be available on "$route.params".`);
          existingKeys.add(key.name);
        }
      }
      const matcher = assign(parser, {
        record,
        parent,
        children: [],
        alias: []
      });
      if (parent) {
        if (!matcher.record.aliasOf === !parent.record.aliasOf)
          parent.children.push(matcher);
      }
      return matcher;
    }
    function createRouterMatcher(routes, globalOptions) {
      const matchers = [];
      const matcherMap = /* @__PURE__ */ new Map();
      globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
      function getRecordMatcher(name) {
        return matcherMap.get(name);
      }
      function addRoute(record, parent, originalRecord) {
        const isRootAdd = !originalRecord;
        const mainNormalizedRecord = normalizeRouteRecord(record);
        {
          checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent);
        }
        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
        const options = mergeOptions(globalOptions, record);
        const normalizedRecords = [
          mainNormalizedRecord
        ];
        if ("alias" in record) {
          const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
          for (const alias of aliases) {
            normalizedRecords.push(assign({}, mainNormalizedRecord, {
              components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
              path: alias,
              aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
            }));
          }
        }
        let matcher;
        let originalMatcher;
        for (const normalizedRecord of normalizedRecords) {
          const { path } = normalizedRecord;
          if (parent && path[0] !== "/") {
            const parentPath = parent.record.path;
            const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
            normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
          }
          if (normalizedRecord.path === "*") {
            throw new Error('Catch all routes ("*") must now be defined using a param with a custom regexp.\nSee more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');
          }
          matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
          if (parent && path[0] === "/")
            checkMissingParamsInAbsolutePath(matcher, parent);
          if (originalRecord) {
            originalRecord.alias.push(matcher);
            {
              checkSameParams(originalRecord, matcher);
            }
          } else {
            originalMatcher = originalMatcher || matcher;
            if (originalMatcher !== matcher)
              originalMatcher.alias.push(matcher);
            if (isRootAdd && record.name && !isAliasRecord(matcher))
              removeRoute(record.name);
          }
          if (mainNormalizedRecord.children) {
            const children = mainNormalizedRecord.children;
            for (let i = 0; i < children.length; i++) {
              addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
            }
          }
          originalRecord = originalRecord || matcher;
          if (matcher.record.components && Object.keys(matcher.record.components).length || matcher.record.name || matcher.record.redirect) {
            insertMatcher(matcher);
          }
        }
        return originalMatcher ? () => {
          removeRoute(originalMatcher);
        } : noop;
      }
      function removeRoute(matcherRef) {
        if (isRouteName(matcherRef)) {
          const matcher = matcherMap.get(matcherRef);
          if (matcher) {
            matcherMap.delete(matcherRef);
            matchers.splice(matchers.indexOf(matcher), 1);
            matcher.children.forEach(removeRoute);
            matcher.alias.forEach(removeRoute);
          }
        } else {
          const index = matchers.indexOf(matcherRef);
          if (index > -1) {
            matchers.splice(index, 1);
            if (matcherRef.record.name)
              matcherMap.delete(matcherRef.record.name);
            matcherRef.children.forEach(removeRoute);
            matcherRef.alias.forEach(removeRoute);
          }
        }
      }
      function getRoutes() {
        return matchers;
      }
      function insertMatcher(matcher) {
        let i = 0;
        while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0 && (matcher.record.path !== matchers[i].record.path || !isRecordChildOf(matcher, matchers[i])))
          i++;
        matchers.splice(i, 0, matcher);
        if (matcher.record.name && !isAliasRecord(matcher))
          matcherMap.set(matcher.record.name, matcher);
      }
      function resolve(location2, currentLocation) {
        let matcher;
        let params = {};
        let path;
        let name;
        if ("name" in location2 && location2.name) {
          matcher = matcherMap.get(location2.name);
          if (!matcher)
            throw createRouterError(1, {
              location: location2
            });
          {
            const invalidParams = Object.keys(location2.params || {}).filter((paramName) => !matcher.keys.find((k) => k.name === paramName));
            if (invalidParams.length) {
              warn(`Discarded invalid param(s) "${invalidParams.join('", "')}" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`);
            }
          }
          name = matcher.record.name;
          params = assign(
            paramsFromLocation(
              currentLocation.params,
              matcher.keys.filter((k) => !k.optional).map((k) => k.name)
            ),
            location2.params && paramsFromLocation(location2.params, matcher.keys.map((k) => k.name))
          );
          path = matcher.stringify(params);
        } else if ("path" in location2) {
          path = location2.path;
          if (!path.startsWith("/")) {
            warn(`The Matcher cannot resolve relative paths but received "${path}". Unless you directly called \`matcher.resolve("${path}")\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`);
          }
          matcher = matchers.find((m) => m.re.test(path));
          if (matcher) {
            params = matcher.parse(path);
            name = matcher.record.name;
          }
        } else {
          matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
          if (!matcher)
            throw createRouterError(1, {
              location: location2,
              currentLocation
            });
          name = matcher.record.name;
          params = assign({}, currentLocation.params, location2.params);
          path = matcher.stringify(params);
        }
        const matched = [];
        let parentMatcher = matcher;
        while (parentMatcher) {
          matched.unshift(parentMatcher.record);
          parentMatcher = parentMatcher.parent;
        }
        return {
          name,
          path,
          params,
          matched,
          meta: mergeMetaFields(matched)
        };
      }
      routes.forEach((route) => addRoute(route));
      return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };
    }
    function paramsFromLocation(params, keys2) {
      const newParams = {};
      for (const key of keys2) {
        if (key in params)
          newParams[key] = params[key];
      }
      return newParams;
    }
    function normalizeRouteRecord(record) {
      return {
        path: record.path,
        redirect: record.redirect,
        name: record.name,
        meta: record.meta || {},
        aliasOf: void 0,
        beforeEnter: record.beforeEnter,
        props: normalizeRecordProps(record),
        children: record.children || [],
        instances: {},
        leaveGuards: /* @__PURE__ */ new Set(),
        updateGuards: /* @__PURE__ */ new Set(),
        enterCallbacks: {},
        components: "components" in record ? record.components || null : record.component && { default: record.component }
      };
    }
    function normalizeRecordProps(record) {
      const propsObject = {};
      const props = record.props || false;
      if ("component" in record) {
        propsObject.default = props;
      } else {
        for (const name in record.components)
          propsObject[name] = typeof props === "boolean" ? props : props[name];
      }
      return propsObject;
    }
    function isAliasRecord(record) {
      while (record) {
        if (record.record.aliasOf)
          return true;
        record = record.parent;
      }
      return false;
    }
    function mergeMetaFields(matched) {
      return matched.reduce((meta, record) => assign(meta, record.meta), {});
    }
    function mergeOptions(defaults, partialOptions) {
      const options = {};
      for (const key in defaults) {
        options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
      }
      return options;
    }
    function isSameParam(a, b) {
      return a.name === b.name && a.optional === b.optional && a.repeatable === b.repeatable;
    }
    function checkSameParams(a, b) {
      for (const key of a.keys) {
        if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))
          return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" must have the exact same param named "${key.name}"`);
      }
      for (const key of b.keys) {
        if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))
          return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" must have the exact same param named "${key.name}"`);
      }
    }
    function checkChildMissingNameWithEmptyPath(mainNormalizedRecord, parent) {
      if (parent && parent.record.name && !mainNormalizedRecord.name && !mainNormalizedRecord.path) {
        warn(`The route named "${String(parent.record.name)}" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`);
      }
    }
    function checkMissingParamsInAbsolutePath(record, parent) {
      for (const key of parent.keys) {
        if (!record.keys.find(isSameParam.bind(null, key)))
          return warn(`Absolute path "${record.record.path}" must have the exact same param named "${key.name}" as its parent "${parent.record.path}".`);
      }
    }
    function isRecordChildOf(record, parent) {
      return parent.children.some((child) => child === record || isRecordChildOf(record, child));
    }
    var HASH_RE = /#/g;
    var AMPERSAND_RE = /&/g;
    var SLASH_RE = /\//g;
    var EQUAL_RE = /=/g;
    var IM_RE = /\?/g;
    var PLUS_RE = /\+/g;
    var ENC_BRACKET_OPEN_RE = /%5B/g;
    var ENC_BRACKET_CLOSE_RE = /%5D/g;
    var ENC_CARET_RE = /%5E/g;
    var ENC_BACKTICK_RE = /%60/g;
    var ENC_CURLY_OPEN_RE = /%7B/g;
    var ENC_PIPE_RE = /%7C/g;
    var ENC_CURLY_CLOSE_RE = /%7D/g;
    var ENC_SPACE_RE = /%20/g;
    function commonEncode(text) {
      return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
    }
    function encodeHash(text) {
      return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
    }
    function encodeQueryValue(text) {
      return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
    }
    function encodeQueryKey(text) {
      return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
    }
    function encodePath(text) {
      return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
    }
    function encodeParam(text) {
      return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
    }
    function decode(text) {
      try {
        return decodeURIComponent("" + text);
      } catch (err) {
        warn(`Error decoding "${text}". Using original value`);
      }
      return "" + text;
    }
    function parseQuery(search) {
      const query = {};
      if (search === "" || search === "?")
        return query;
      const hasLeadingIM = search[0] === "?";
      const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
      for (let i = 0; i < searchParams.length; ++i) {
        const searchParam = searchParams[i].replace(PLUS_RE, " ");
        const eqPos = searchParam.indexOf("=");
        const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
        const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
        if (key in query) {
          let currentValue = query[key];
          if (!isArray2(currentValue)) {
            currentValue = query[key] = [currentValue];
          }
          currentValue.push(value);
        } else {
          query[key] = value;
        }
      }
      return query;
    }
    function stringifyQuery(query) {
      let search = "";
      for (let key in query) {
        const value = query[key];
        key = encodeQueryKey(key);
        if (value == null) {
          if (value !== void 0) {
            search += (search.length ? "&" : "") + key;
          }
          continue;
        }
        const values = isArray2(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
        values.forEach((value2) => {
          if (value2 !== void 0) {
            search += (search.length ? "&" : "") + key;
            if (value2 != null)
              search += "=" + value2;
          }
        });
      }
      return search;
    }
    function normalizeQuery(query) {
      const normalizedQuery = {};
      for (const key in query) {
        const value = query[key];
        if (value !== void 0) {
          normalizedQuery[key] = isArray2(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
        }
      }
      return normalizedQuery;
    }
    var matchedRouteKey = Symbol("router view location matched");
    var viewDepthKey = Symbol("router view depth");
    var routerKey = Symbol("router");
    var routeLocationKey = Symbol("route location");
    var routerViewLocationKey = Symbol("router view location");
    function useCallbacks() {
      let handlers = [];
      function add(handler) {
        handlers.push(handler);
        return () => {
          const i = handlers.indexOf(handler);
          if (i > -1)
            handlers.splice(i, 1);
        };
      }
      function reset() {
        handlers = [];
      }
      return {
        add,
        list: () => handlers,
        reset
      };
    }
    function registerGuard(record, name, guard) {
      const removeFromList = () => {
        record[name].delete(guard);
      };
      vue.onUnmounted(removeFromList);
      vue.onDeactivated(removeFromList);
      vue.onActivated(() => {
        record[name].add(guard);
      });
      record[name].add(guard);
    }
    function onBeforeRouteLeave(leaveGuard) {
      if (!vue.getCurrentInstance()) {
        warn("getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function");
        return;
      }
      const activeRecord = vue.inject(
        matchedRouteKey,
        {}
      ).value;
      if (!activeRecord) {
        warn("No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?");
        return;
      }
      registerGuard(activeRecord, "leaveGuards", leaveGuard);
    }
    function onBeforeRouteUpdate(updateGuard) {
      if (!vue.getCurrentInstance()) {
        warn("getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function");
        return;
      }
      const activeRecord = vue.inject(
        matchedRouteKey,
        {}
      ).value;
      if (!activeRecord) {
        warn("No active route record was found when calling `onBeforeRouteUpdate()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?");
        return;
      }
      registerGuard(activeRecord, "updateGuards", updateGuard);
    }
    function guardToPromiseFn(guard, to, from, record, name) {
      const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
      return () => new Promise((resolve, reject) => {
        const next = (valid) => {
          if (valid === false) {
            reject(createRouterError(4, {
              from,
              to
            }));
          } else if (valid instanceof Error) {
            reject(valid);
          } else if (isRouteLocation(valid)) {
            reject(createRouterError(2, {
              from: to,
              to: valid
            }));
          } else {
            if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
              enterCallbackArray.push(valid);
            }
            resolve();
          }
        };
        const guardReturn = guard.call(record && record.instances[name], to, from, canOnlyBeCalledOnce(next, to, from));
        let guardCall = Promise.resolve(guardReturn);
        if (guard.length < 3)
          guardCall = guardCall.then(next);
        if (guard.length > 2) {
          const message = `The "next" callback was never called inside of ${guard.name ? '"' + guard.name + '"' : ""}:
${guard.toString()}
. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
          if (typeof guardReturn === "object" && "then" in guardReturn) {
            guardCall = guardCall.then((resolvedValue) => {
              if (!next._called) {
                warn(message);
                return Promise.reject(new Error("Invalid navigation guard"));
              }
              return resolvedValue;
            });
          } else if (guardReturn !== void 0) {
            if (!next._called) {
              warn(message);
              reject(new Error("Invalid navigation guard"));
              return;
            }
          }
        }
        guardCall.catch((err) => reject(err));
      });
    }
    function canOnlyBeCalledOnce(next, to, from) {
      let called = 0;
      return function() {
        if (called++ === 1)
          warn(`The "next" callback was called more than once in one navigation guard when going from "${from.fullPath}" to "${to.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`);
        next._called = true;
        if (called === 1)
          next.apply(null, arguments);
      };
    }
    function extractComponentsGuards(matched, guardType, to, from) {
      const guards = [];
      for (const record of matched) {
        if (!record.components && !record.children.length) {
          warn(`Record with path "${record.path}" is either missing a "component(s)" or "children" property.`);
        }
        for (const name in record.components) {
          let rawComponent = record.components[name];
          {
            if (!rawComponent || typeof rawComponent !== "object" && typeof rawComponent !== "function") {
              warn(`Component "${name}" in record with path "${record.path}" is not a valid component. Received "${String(rawComponent)}".`);
              throw new Error("Invalid route component");
            } else if ("then" in rawComponent) {
              warn(`Component "${name}" in record with path "${record.path}" is a Promise instead of a function that returns a Promise. Did you write "import('./MyPage.vue')" instead of "() => import('./MyPage.vue')" ? This will break in production if not fixed.`);
              const promise = rawComponent;
              rawComponent = () => promise;
            } else if (rawComponent.__asyncLoader && !rawComponent.__warnedDefineAsync) {
              rawComponent.__warnedDefineAsync = true;
              warn(`Component "${name}" in record with path "${record.path}" is defined using "defineAsyncComponent()". Write "() => import('./MyPage.vue')" instead of "defineAsyncComponent(() => import('./MyPage.vue'))".`);
            }
          }
          if (guardType !== "beforeRouteEnter" && !record.instances[name])
            continue;
          if (isRouteComponent(rawComponent)) {
            const options = rawComponent.__vccOpts || rawComponent;
            const guard = options[guardType];
            guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
          } else {
            let componentPromise = rawComponent();
            if (!("catch" in componentPromise)) {
              warn(`Component "${name}" in record with path "${record.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`);
              componentPromise = Promise.resolve(componentPromise);
            }
            guards.push(() => componentPromise.then((resolved) => {
              if (!resolved)
                return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
              const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
              record.components[name] = resolvedComponent;
              const options = resolvedComponent.__vccOpts || resolvedComponent;
              const guard = options[guardType];
              return guard && guardToPromiseFn(guard, to, from, record, name)();
            }));
          }
        }
      }
      return guards;
    }
    function isRouteComponent(component) {
      return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
    }
    function loadRouteLocation(route) {
      return route.matched.every((record) => record.redirect) ? Promise.reject(new Error("Cannot load a route that redirects.")) : Promise.all(route.matched.map((record) => record.components && Promise.all(Object.keys(record.components).reduce((promises, name) => {
        const rawComponent = record.components[name];
        if (typeof rawComponent === "function" && !("displayName" in rawComponent)) {
          promises.push(rawComponent().then((resolved) => {
            if (!resolved)
              return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}". Ensure you passed a function that returns a promise.`));
            const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
            record.components[name] = resolvedComponent;
            return;
          }));
        }
        return promises;
      }, [])))).then(() => route);
    }
    function useLink(props) {
      const router = vue.inject(routerKey);
      const currentRoute = vue.inject(routeLocationKey);
      const route = vue.computed(() => router.resolve(vue.unref(props.to)));
      const activeRecordIndex = vue.computed(() => {
        const { matched } = route.value;
        const { length } = matched;
        const routeMatched = matched[length - 1];
        const currentMatched = currentRoute.matched;
        if (!routeMatched || !currentMatched.length)
          return -1;
        const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
        if (index > -1)
          return index;
        const parentRecordPath = getOriginalPath(matched[length - 2]);
        return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index;
      });
      const isActive = vue.computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
      const isExactActive = vue.computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
      function navigate(e = {}) {
        if (guardEvent(e)) {
          return router[vue.unref(props.replace) ? "replace" : "push"](
            vue.unref(props.to)
          ).catch(noop);
        }
        return Promise.resolve();
      }
      if (isBrowser) {
        const instance = vue.getCurrentInstance();
        if (instance) {
          const linkContextDevtools = {
            route: route.value,
            isActive: isActive.value,
            isExactActive: isExactActive.value
          };
          instance.__vrl_devtools = instance.__vrl_devtools || [];
          instance.__vrl_devtools.push(linkContextDevtools);
          vue.watchEffect(() => {
            linkContextDevtools.route = route.value;
            linkContextDevtools.isActive = isActive.value;
            linkContextDevtools.isExactActive = isExactActive.value;
          }, { flush: "post" });
        }
      }
      return {
        route,
        href: vue.computed(() => route.value.href),
        isActive,
        isExactActive,
        navigate
      };
    }
    var RouterLinkImpl = vue.defineComponent({
      name: "RouterLink",
      compatConfig: { MODE: 3 },
      props: {
        to: {
          type: [String, Object],
          required: true
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
          type: String,
          default: "page"
        }
      },
      useLink,
      setup(props, { slots }) {
        const link = vue.reactive(useLink(props));
        const { options } = vue.inject(routerKey);
        const elClass = vue.computed(() => ({
          [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
          [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
        }));
        return () => {
          const children = slots.default && slots.default(link);
          return props.custom ? children : vue.h("a", {
            "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
            href: link.href,
            onClick: link.navigate,
            class: elClass.value
          }, children);
        };
      }
    });
    var RouterLink = RouterLinkImpl;
    function guardEvent(e) {
      if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
        return;
      if (e.defaultPrevented)
        return;
      if (e.button !== void 0 && e.button !== 0)
        return;
      if (e.currentTarget && e.currentTarget.getAttribute) {
        const target = e.currentTarget.getAttribute("target");
        if (/\b_blank\b/i.test(target))
          return;
      }
      if (e.preventDefault)
        e.preventDefault();
      return true;
    }
    function includesParams(outer, inner) {
      for (const key in inner) {
        const innerValue = inner[key];
        const outerValue = outer[key];
        if (typeof innerValue === "string") {
          if (innerValue !== outerValue)
            return false;
        } else {
          if (!isArray2(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))
            return false;
        }
      }
      return true;
    }
    function getOriginalPath(record) {
      return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
    }
    var getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
    var RouterViewImpl = vue.defineComponent({
      name: "RouterView",
      inheritAttrs: false,
      props: {
        name: {
          type: String,
          default: "default"
        },
        route: Object
      },
      compatConfig: { MODE: 3 },
      setup(props, { attrs, slots }) {
        warnDeprecatedUsage();
        const injectedRoute = vue.inject(routerViewLocationKey);
        const routeToDisplay = vue.computed(() => props.route || injectedRoute.value);
        const injectedDepth = vue.inject(viewDepthKey, 0);
        const depth = vue.computed(() => {
          let initialDepth = vue.unref(injectedDepth);
          const { matched } = routeToDisplay.value;
          let matchedRoute;
          while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
            initialDepth++;
          }
          return initialDepth;
        });
        const matchedRouteRef = vue.computed(() => routeToDisplay.value.matched[depth.value]);
        vue.provide(viewDepthKey, vue.computed(() => depth.value + 1));
        vue.provide(matchedRouteKey, matchedRouteRef);
        vue.provide(routerViewLocationKey, routeToDisplay);
        const viewRef = vue.ref();
        vue.watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
          if (to) {
            to.instances[name] = instance;
            if (from && from !== to && instance && instance === oldInstance) {
              if (!to.leaveGuards.size) {
                to.leaveGuards = from.leaveGuards;
              }
              if (!to.updateGuards.size) {
                to.updateGuards = from.updateGuards;
              }
            }
          }
          if (instance && to && (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
            (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
          }
        }, { flush: "post" });
        return () => {
          const route = routeToDisplay.value;
          const currentName = props.name;
          const matchedRoute = matchedRouteRef.value;
          const ViewComponent = matchedRoute && matchedRoute.components[currentName];
          if (!ViewComponent) {
            return normalizeSlot(slots.default, { Component: ViewComponent, route });
          }
          const routePropsOption = matchedRoute.props[currentName];
          const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
          const onVnodeUnmounted = (vnode) => {
            if (vnode.component.isUnmounted) {
              matchedRoute.instances[currentName] = null;
            }
          };
          const component = vue.h(ViewComponent, assign({}, routeProps, attrs, {
            onVnodeUnmounted,
            ref: viewRef
          }));
          if (isBrowser && component.ref) {
            const info = {
              depth: depth.value,
              name: matchedRoute.name,
              path: matchedRoute.path,
              meta: matchedRoute.meta
            };
            const internalInstances = isArray2(component.ref) ? component.ref.map((r) => r.i) : [component.ref.i];
            internalInstances.forEach((instance) => {
              instance.__vrv_devtools = info;
            });
          }
          return normalizeSlot(slots.default, { Component: component, route }) || component;
        };
      }
    });
    function normalizeSlot(slot, data) {
      if (!slot)
        return null;
      const slotContent = slot(data);
      return slotContent.length === 1 ? slotContent[0] : slotContent;
    }
    var RouterView = RouterViewImpl;
    function warnDeprecatedUsage() {
      const instance = vue.getCurrentInstance();
      const parentName = instance.parent && instance.parent.type.name;
      if (parentName && (parentName === "KeepAlive" || parentName.includes("Transition"))) {
        const comp = parentName === "KeepAlive" ? "keep-alive" : "transition";
        warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <${comp}>
    <component :is="Component" />
  </${comp}>
</router-view>`);
      }
    }
    function formatRouteLocation(routeLocation, tooltip) {
      const copy = assign({}, routeLocation, {
        matched: routeLocation.matched.map((matched) => omit(matched, ["instances", "children", "aliasOf"]))
      });
      return {
        _custom: {
          type: null,
          readOnly: true,
          display: routeLocation.fullPath,
          tooltip,
          value: copy
        }
      };
    }
    function formatDisplay(display) {
      return {
        _custom: {
          display
        }
      };
    }
    var routerId = 0;
    function addDevtools(app, router, matcher) {
      if (router.__hasDevtools)
        return;
      router.__hasDevtools = true;
      const id = routerId++;
      devtoolsApi.setupDevtoolsPlugin({
        id: "org.vuejs.router" + (id ? "." + id : ""),
        label: "Vue Router",
        packageName: "vue-router",
        homepage: "https://router.vuejs.org",
        logo: "https://router.vuejs.org/logo.png",
        componentStateTypes: ["Routing"],
        app
      }, (api) => {
        if (typeof api.now !== "function") {
          console.warn("[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
        }
        api.on.inspectComponent((payload, ctx) => {
          if (payload.instanceData) {
            payload.instanceData.state.push({
              type: "Routing",
              key: "$route",
              editable: false,
              value: formatRouteLocation(router.currentRoute.value, "Current Route")
            });
          }
        });
        api.on.visitComponentTree(({ treeNode: node, componentInstance }) => {
          if (componentInstance.__vrv_devtools) {
            const info = componentInstance.__vrv_devtools;
            node.tags.push({
              label: (info.name ? `${info.name.toString()}: ` : "") + info.path,
              textColor: 0,
              tooltip: "This component is rendered by &lt;router-view&gt;",
              backgroundColor: PINK_500
            });
          }
          if (isArray2(componentInstance.__vrl_devtools)) {
            componentInstance.__devtoolsApi = api;
            componentInstance.__vrl_devtools.forEach((devtoolsData) => {
              let backgroundColor = ORANGE_400;
              let tooltip = "";
              if (devtoolsData.isExactActive) {
                backgroundColor = LIME_500;
                tooltip = "This is exactly active";
              } else if (devtoolsData.isActive) {
                backgroundColor = BLUE_600;
                tooltip = "This link is active";
              }
              node.tags.push({
                label: devtoolsData.route.path,
                textColor: 0,
                tooltip,
                backgroundColor
              });
            });
          }
        });
        vue.watch(router.currentRoute, () => {
          refreshRoutesView();
          api.notifyComponentUpdate();
          api.sendInspectorTree(routerInspectorId);
          api.sendInspectorState(routerInspectorId);
        });
        const navigationsLayerId = "router:navigations:" + id;
        api.addTimelineLayer({
          id: navigationsLayerId,
          label: `Router${id ? " " + id : ""} Navigations`,
          color: 4237508
        });
        router.onError((error, to) => {
          api.addTimelineEvent({
            layerId: navigationsLayerId,
            event: {
              title: "Error during Navigation",
              subtitle: to.fullPath,
              logType: "error",
              time: api.now(),
              data: { error },
              groupId: to.meta.__navigationId
            }
          });
        });
        let navigationId = 0;
        router.beforeEach((to, from) => {
          const data = {
            guard: formatDisplay("beforeEach"),
            from: formatRouteLocation(from, "Current Location during this navigation"),
            to: formatRouteLocation(to, "Target location")
          };
          Object.defineProperty(to.meta, "__navigationId", {
            value: navigationId++
          });
          api.addTimelineEvent({
            layerId: navigationsLayerId,
            event: {
              time: api.now(),
              title: "Start of navigation",
              subtitle: to.fullPath,
              data,
              groupId: to.meta.__navigationId
            }
          });
        });
        router.afterEach((to, from, failure) => {
          const data = {
            guard: formatDisplay("afterEach")
          };
          if (failure) {
            data.failure = {
              _custom: {
                type: Error,
                readOnly: true,
                display: failure ? failure.message : "",
                tooltip: "Navigation Failure",
                value: failure
              }
            };
            data.status = formatDisplay("\u274C");
          } else {
            data.status = formatDisplay("\u2705");
          }
          data.from = formatRouteLocation(from, "Current Location during this navigation");
          data.to = formatRouteLocation(to, "Target location");
          api.addTimelineEvent({
            layerId: navigationsLayerId,
            event: {
              title: "End of navigation",
              subtitle: to.fullPath,
              time: api.now(),
              data,
              logType: failure ? "warning" : "default",
              groupId: to.meta.__navigationId
            }
          });
        });
        const routerInspectorId = "router-inspector:" + id;
        api.addInspector({
          id: routerInspectorId,
          label: "Routes" + (id ? " " + id : ""),
          icon: "book",
          treeFilterPlaceholder: "Search routes"
        });
        function refreshRoutesView() {
          if (!activeRoutesPayload)
            return;
          const payload = activeRoutesPayload;
          let routes = matcher.getRoutes().filter((route) => !route.parent);
          routes.forEach(resetMatchStateOnRouteRecord);
          if (payload.filter) {
            routes = routes.filter((route) => isRouteMatching(route, payload.filter.toLowerCase()));
          }
          routes.forEach((route) => markRouteRecordActive(route, router.currentRoute.value));
          payload.rootNodes = routes.map(formatRouteRecordForInspector);
        }
        let activeRoutesPayload;
        api.on.getInspectorTree((payload) => {
          activeRoutesPayload = payload;
          if (payload.app === app && payload.inspectorId === routerInspectorId) {
            refreshRoutesView();
          }
        });
        api.on.getInspectorState((payload) => {
          if (payload.app === app && payload.inspectorId === routerInspectorId) {
            const routes = matcher.getRoutes();
            const route = routes.find((route2) => route2.record.__vd_id === payload.nodeId);
            if (route) {
              payload.state = {
                options: formatRouteRecordMatcherForStateInspector(route)
              };
            }
          }
        });
        api.sendInspectorTree(routerInspectorId);
        api.sendInspectorState(routerInspectorId);
      });
    }
    function modifierForKey(key) {
      if (key.optional) {
        return key.repeatable ? "*" : "?";
      } else {
        return key.repeatable ? "+" : "";
      }
    }
    function formatRouteRecordMatcherForStateInspector(route) {
      const { record } = route;
      const fields = [
        { editable: false, key: "path", value: record.path }
      ];
      if (record.name != null) {
        fields.push({
          editable: false,
          key: "name",
          value: record.name
        });
      }
      fields.push({ editable: false, key: "regexp", value: route.re });
      if (route.keys.length) {
        fields.push({
          editable: false,
          key: "keys",
          value: {
            _custom: {
              type: null,
              readOnly: true,
              display: route.keys.map((key) => `${key.name}${modifierForKey(key)}`).join(" "),
              tooltip: "Param keys",
              value: route.keys
            }
          }
        });
      }
      if (record.redirect != null) {
        fields.push({
          editable: false,
          key: "redirect",
          value: record.redirect
        });
      }
      if (route.alias.length) {
        fields.push({
          editable: false,
          key: "aliases",
          value: route.alias.map((alias) => alias.record.path)
        });
      }
      if (Object.keys(route.record.meta).length) {
        fields.push({
          editable: false,
          key: "meta",
          value: route.record.meta
        });
      }
      fields.push({
        key: "score",
        editable: false,
        value: {
          _custom: {
            type: null,
            readOnly: true,
            display: route.score.map((score) => score.join(", ")).join(" | "),
            tooltip: "Score used to sort routes",
            value: route.score
          }
        }
      });
      return fields;
    }
    var PINK_500 = 15485081;
    var BLUE_600 = 2450411;
    var LIME_500 = 8702998;
    var CYAN_400 = 2282478;
    var ORANGE_400 = 16486972;
    var DARK = 6710886;
    function formatRouteRecordForInspector(route) {
      const tags = [];
      const { record } = route;
      if (record.name != null) {
        tags.push({
          label: String(record.name),
          textColor: 0,
          backgroundColor: CYAN_400
        });
      }
      if (record.aliasOf) {
        tags.push({
          label: "alias",
          textColor: 0,
          backgroundColor: ORANGE_400
        });
      }
      if (route.__vd_match) {
        tags.push({
          label: "matches",
          textColor: 0,
          backgroundColor: PINK_500
        });
      }
      if (route.__vd_exactActive) {
        tags.push({
          label: "exact",
          textColor: 0,
          backgroundColor: LIME_500
        });
      }
      if (route.__vd_active) {
        tags.push({
          label: "active",
          textColor: 0,
          backgroundColor: BLUE_600
        });
      }
      if (record.redirect) {
        tags.push({
          label: typeof record.redirect === "string" ? `redirect: ${record.redirect}` : "redirects",
          textColor: 16777215,
          backgroundColor: DARK
        });
      }
      let id = record.__vd_id;
      if (id == null) {
        id = String(routeRecordId++);
        record.__vd_id = id;
      }
      return {
        id,
        label: record.path,
        tags,
        children: route.children.map(formatRouteRecordForInspector)
      };
    }
    var routeRecordId = 0;
    var EXTRACT_REGEXP_RE = /^\/(.*)\/([a-z]*)$/;
    function markRouteRecordActive(route, currentRoute) {
      const isExactActive = currentRoute.matched.length && isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);
      route.__vd_exactActive = route.__vd_active = isExactActive;
      if (!isExactActive) {
        route.__vd_active = currentRoute.matched.some((match) => isSameRouteRecord(match, route.record));
      }
      route.children.forEach((childRoute) => markRouteRecordActive(childRoute, currentRoute));
    }
    function resetMatchStateOnRouteRecord(route) {
      route.__vd_match = false;
      route.children.forEach(resetMatchStateOnRouteRecord);
    }
    function isRouteMatching(route, filter) {
      const found = String(route.re).match(EXTRACT_REGEXP_RE);
      route.__vd_match = false;
      if (!found || found.length < 3) {
        return false;
      }
      const nonEndingRE = new RegExp(found[1].replace(/\$$/, ""), found[2]);
      if (nonEndingRE.test(filter)) {
        route.children.forEach((child) => isRouteMatching(child, filter));
        if (route.record.path !== "/" || filter === "/") {
          route.__vd_match = route.re.test(filter);
          return true;
        }
        return false;
      }
      const path = route.record.path.toLowerCase();
      const decodedPath = decode(path);
      if (!filter.startsWith("/") && (decodedPath.includes(filter) || path.includes(filter)))
        return true;
      if (decodedPath.startsWith(filter) || path.startsWith(filter))
        return true;
      if (route.record.name && String(route.record.name).includes(filter))
        return true;
      return route.children.some((child) => isRouteMatching(child, filter));
    }
    function omit(obj, keys2) {
      const ret = {};
      for (const key in obj) {
        if (!keys2.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
    function createRouter(options) {
      const matcher = createRouterMatcher(options.routes, options);
      const parseQuery$1 = options.parseQuery || parseQuery;
      const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
      const routerHistory = options.history;
      if (!routerHistory)
        throw new Error('Provide the "history" option when calling "createRouter()": https://next.router.vuejs.org/api/#history.');
      const beforeGuards = useCallbacks();
      const beforeResolveGuards = useCallbacks();
      const afterGuards = useCallbacks();
      const currentRoute = vue.shallowRef(START_LOCATION_NORMALIZED);
      let pendingLocation = START_LOCATION_NORMALIZED;
      if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
        history.scrollRestoration = "manual";
      }
      const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
      const encodeParams = applyToParams.bind(null, encodeParam);
      const decodeParams = applyToParams.bind(null, decode);
      function addRoute(parentOrRoute, route) {
        let parent;
        let record;
        if (isRouteName(parentOrRoute)) {
          parent = matcher.getRecordMatcher(parentOrRoute);
          record = route;
        } else {
          record = parentOrRoute;
        }
        return matcher.addRoute(record, parent);
      }
      function removeRoute(name) {
        const recordMatcher = matcher.getRecordMatcher(name);
        if (recordMatcher) {
          matcher.removeRoute(recordMatcher);
        } else {
          warn(`Cannot remove non-existent route "${String(name)}"`);
        }
      }
      function getRoutes() {
        return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
      }
      function hasRoute(name) {
        return !!matcher.getRecordMatcher(name);
      }
      function resolve(rawLocation, currentLocation) {
        currentLocation = assign({}, currentLocation || currentRoute.value);
        if (typeof rawLocation === "string") {
          const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
          const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
          const href2 = routerHistory.createHref(locationNormalized.fullPath);
          {
            if (href2.startsWith("//"))
              warn(`Location "${rawLocation}" resolved to "${href2}". A resolved location cannot start with multiple slashes.`);
            else if (!matchedRoute2.matched.length) {
              warn(`No match found for location with path "${rawLocation}"`);
            }
          }
          return assign(locationNormalized, matchedRoute2, {
            params: decodeParams(matchedRoute2.params),
            hash: decode(locationNormalized.hash),
            redirectedFrom: void 0,
            href: href2
          });
        }
        let matcherLocation;
        if ("path" in rawLocation) {
          if ("params" in rawLocation && !("name" in rawLocation) && Object.keys(rawLocation.params).length) {
            warn(`Path "${rawLocation.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`);
          }
          matcherLocation = assign({}, rawLocation, {
            path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
          });
        } else {
          const targetParams = assign({}, rawLocation.params);
          for (const key in targetParams) {
            if (targetParams[key] == null) {
              delete targetParams[key];
            }
          }
          matcherLocation = assign({}, rawLocation, {
            params: encodeParams(rawLocation.params)
          });
          currentLocation.params = encodeParams(currentLocation.params);
        }
        const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
        const hash = rawLocation.hash || "";
        if (hash && !hash.startsWith("#")) {
          warn(`A \`hash\` should always start with the character "#". Replace "${hash}" with "#${hash}".`);
        }
        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
          hash: encodeHash(hash),
          path: matchedRoute.path
        }));
        const href = routerHistory.createHref(fullPath);
        {
          if (href.startsWith("//")) {
            warn(`Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`);
          } else if (!matchedRoute.matched.length) {
            warn(`No match found for location with path "${"path" in rawLocation ? rawLocation.path : rawLocation}"`);
          }
        }
        return assign({
          fullPath,
          hash,
          query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
        }, matchedRoute, {
          redirectedFrom: void 0,
          href
        });
      }
      function locationAsObject(to) {
        return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
      }
      function checkCanceledNavigation(to, from) {
        if (pendingLocation !== to) {
          return createRouterError(8, {
            from,
            to
          });
        }
      }
      function push(to) {
        return pushWithRedirect(to);
      }
      function replace(to) {
        return push(assign(locationAsObject(to), { replace: true }));
      }
      function handleRedirectRecord(to) {
        const lastMatched = to.matched[to.matched.length - 1];
        if (lastMatched && lastMatched.redirect) {
          const { redirect } = lastMatched;
          let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
          if (typeof newTargetLocation === "string") {
            newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
            newTargetLocation.params = {};
          }
          if (!("path" in newTargetLocation) && !("name" in newTargetLocation)) {
            warn(`Invalid redirect found:
${JSON.stringify(newTargetLocation, null, 2)}
 when navigating to "${to.fullPath}". A redirect must contain a name or path. This will break in production.`);
            throw new Error("Invalid redirect");
          }
          return assign({
            query: to.query,
            hash: to.hash,
            params: "path" in newTargetLocation ? {} : to.params
          }, newTargetLocation);
        }
      }
      function pushWithRedirect(to, redirectedFrom) {
        const targetLocation = pendingLocation = resolve(to);
        const from = currentRoute.value;
        const data = to.state;
        const force = to.force;
        const replace2 = to.replace === true;
        const shouldRedirect = handleRedirectRecord(targetLocation);
        if (shouldRedirect)
          return pushWithRedirect(
            assign(locationAsObject(shouldRedirect), {
              state: typeof shouldRedirect === "object" ? assign({}, data, shouldRedirect.state) : data,
              force,
              replace: replace2
            }),
            redirectedFrom || targetLocation
          );
        const toLocation = targetLocation;
        toLocation.redirectedFrom = redirectedFrom;
        let failure;
        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
          failure = createRouterError(16, { to: toLocation, from });
          handleScroll(
            from,
            from,
            true,
            false
          );
        }
        return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? isNavigationFailure(error, 2) ? error : markAsReady(error) : triggerError(error, toLocation, from)).then((failure2) => {
          if (failure2) {
            if (isNavigationFailure(failure2, 2)) {
              if (isSameRouteLocation(stringifyQuery$1, resolve(failure2.to), toLocation) && redirectedFrom && (redirectedFrom._count = redirectedFrom._count ? redirectedFrom._count + 1 : 1) > 10) {
                warn(`Detected an infinite redirection in a navigation guard when going from "${from.fullPath}" to "${toLocation.fullPath}". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);
                return Promise.reject(new Error("Infinite redirect in navigation guard"));
              }
              return pushWithRedirect(
                assign({
                  replace: replace2
                }, locationAsObject(failure2.to), {
                  state: typeof failure2.to === "object" ? assign({}, data, failure2.to.state) : data,
                  force
                }),
                redirectedFrom || toLocation
              );
            }
          } else {
            failure2 = finalizeNavigation(toLocation, from, true, replace2, data);
          }
          triggerAfterEach(toLocation, from, failure2);
          return failure2;
        });
      }
      function checkCanceledNavigationAndReject(to, from) {
        const error = checkCanceledNavigation(to, from);
        return error ? Promise.reject(error) : Promise.resolve();
      }
      function navigate(to, from) {
        let guards;
        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
        guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
        for (const record of leavingRecords) {
          record.leaveGuards.forEach((guard) => {
            guards.push(guardToPromiseFn(guard, to, from));
          });
        }
        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards).then(() => {
          guards = [];
          for (const guard of beforeGuards.list()) {
            guards.push(guardToPromiseFn(guard, to, from));
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
          for (const record of updatingRecords) {
            record.updateGuards.forEach((guard) => {
              guards.push(guardToPromiseFn(guard, to, from));
            });
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = [];
          for (const record of to.matched) {
            if (record.beforeEnter && !from.matched.includes(record)) {
              if (isArray2(record.beforeEnter)) {
                for (const beforeEnter of record.beforeEnter)
                  guards.push(guardToPromiseFn(beforeEnter, to, from));
              } else {
                guards.push(guardToPromiseFn(record.beforeEnter, to, from));
              }
            }
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          to.matched.forEach((record) => record.enterCallbacks = {});
          guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from);
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = [];
          for (const guard of beforeResolveGuards.list()) {
            guards.push(guardToPromiseFn(guard, to, from));
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));
      }
      function triggerAfterEach(to, from, failure) {
        for (const guard of afterGuards.list())
          guard(to, from, failure);
      }
      function finalizeNavigation(toLocation, from, isPush, replace2, data) {
        const error = checkCanceledNavigation(toLocation, from);
        if (error)
          return error;
        const isFirstNavigation = from === START_LOCATION_NORMALIZED;
        const state = !isBrowser ? {} : history.state;
        if (isPush) {
          if (replace2 || isFirstNavigation)
            routerHistory.replace(toLocation.fullPath, assign({
              scroll: isFirstNavigation && state && state.scroll
            }, data));
          else
            routerHistory.push(toLocation.fullPath, data);
        }
        currentRoute.value = toLocation;
        handleScroll(toLocation, from, isPush, isFirstNavigation);
        markAsReady();
      }
      let removeHistoryListener;
      function setupListeners() {
        if (removeHistoryListener)
          return;
        removeHistoryListener = routerHistory.listen((to, _from, info) => {
          if (!router.listening)
            return;
          const toLocation = resolve(to);
          const shouldRedirect = handleRedirectRecord(toLocation);
          if (shouldRedirect) {
            pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
            return;
          }
          pendingLocation = toLocation;
          const from = currentRoute.value;
          if (isBrowser) {
            saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
          }
          navigate(toLocation, from).catch((error) => {
            if (isNavigationFailure(error, 4 | 8)) {
              return error;
            }
            if (isNavigationFailure(error, 2)) {
              pushWithRedirect(
                error.to,
                toLocation
              ).then((failure) => {
                if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
                  routerHistory.go(-1, false);
                }
              }).catch(noop);
              return Promise.reject();
            }
            if (info.delta) {
              routerHistory.go(-info.delta, false);
            }
            return triggerError(error, toLocation, from);
          }).then((failure) => {
            failure = failure || finalizeNavigation(
              toLocation,
              from,
              false
            );
            if (failure) {
              if (info.delta && !isNavigationFailure(failure, 8)) {
                routerHistory.go(-info.delta, false);
              } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
                routerHistory.go(-1, false);
              }
            }
            triggerAfterEach(toLocation, from, failure);
          }).catch(noop);
        });
      }
      let readyHandlers = useCallbacks();
      let errorHandlers = useCallbacks();
      let ready;
      function triggerError(error, to, from) {
        markAsReady(error);
        const list = errorHandlers.list();
        if (list.length) {
          list.forEach((handler) => handler(error, to, from));
        } else {
          {
            warn("uncaught error during route navigation:");
          }
          console.error(error);
        }
        return Promise.reject(error);
      }
      function isReady() {
        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
          return Promise.resolve();
        return new Promise((resolve2, reject) => {
          readyHandlers.add([resolve2, reject]);
        });
      }
      function markAsReady(err) {
        if (!ready) {
          ready = !err;
          setupListeners();
          readyHandlers.list().forEach(([resolve2, reject]) => err ? reject(err) : resolve2());
          readyHandlers.reset();
        }
        return err;
      }
      function handleScroll(to, from, isPush, isFirstNavigation) {
        const { scrollBehavior } = options;
        if (!isBrowser || !scrollBehavior)
          return Promise.resolve();
        const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
        return vue.nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
      }
      const go = (delta) => routerHistory.go(delta);
      let started;
      const installedApps = /* @__PURE__ */ new Set();
      const router = {
        currentRoute,
        listening: true,
        addRoute,
        removeRoute,
        hasRoute,
        getRoutes,
        resolve,
        options,
        push,
        replace,
        go,
        back: () => go(-1),
        forward: () => go(1),
        beforeEach: beforeGuards.add,
        beforeResolve: beforeResolveGuards.add,
        afterEach: afterGuards.add,
        onError: errorHandlers.add,
        isReady,
        install(app) {
          const router2 = this;
          app.component("RouterLink", RouterLink);
          app.component("RouterView", RouterView);
          app.config.globalProperties.$router = router2;
          Object.defineProperty(app.config.globalProperties, "$route", {
            enumerable: true,
            get: () => vue.unref(currentRoute)
          });
          if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
            started = true;
            push(routerHistory.location).catch((err) => {
              warn("Unexpected error when starting the router:", err);
            });
          }
          const reactiveRoute = {};
          for (const key in START_LOCATION_NORMALIZED) {
            reactiveRoute[key] = vue.computed(() => currentRoute.value[key]);
          }
          app.provide(routerKey, router2);
          app.provide(routeLocationKey, vue.reactive(reactiveRoute));
          app.provide(routerViewLocationKey, currentRoute);
          const unmountApp = app.unmount;
          installedApps.add(app);
          app.unmount = function() {
            installedApps.delete(app);
            if (installedApps.size < 1) {
              pendingLocation = START_LOCATION_NORMALIZED;
              removeHistoryListener && removeHistoryListener();
              removeHistoryListener = null;
              currentRoute.value = START_LOCATION_NORMALIZED;
              started = false;
              ready = false;
            }
            unmountApp();
          };
          if (isBrowser) {
            addDevtools(app, router2, matcher);
          }
        }
      };
      return router;
    }
    function runGuardQueue(guards) {
      return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
    }
    function extractChangingRecords(to, from) {
      const leavingRecords = [];
      const updatingRecords = [];
      const enteringRecords = [];
      const len = Math.max(from.matched.length, to.matched.length);
      for (let i = 0; i < len; i++) {
        const recordFrom = from.matched[i];
        if (recordFrom) {
          if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
            updatingRecords.push(recordFrom);
          else
            leavingRecords.push(recordFrom);
        }
        const recordTo = to.matched[i];
        if (recordTo) {
          if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
            enteringRecords.push(recordTo);
          }
        }
      }
      return [leavingRecords, updatingRecords, enteringRecords];
    }
    function useRouter() {
      return vue.inject(routerKey);
    }
    function useRoute() {
      return vue.inject(routeLocationKey);
    }
    exports.RouterLink = RouterLink;
    exports.RouterView = RouterView;
    exports.START_LOCATION = START_LOCATION_NORMALIZED;
    exports.createMemoryHistory = createMemoryHistory;
    exports.createRouter = createRouter;
    exports.createRouterMatcher = createRouterMatcher;
    exports.createWebHashHistory = createWebHashHistory;
    exports.createWebHistory = createWebHistory;
    exports.isNavigationFailure = isNavigationFailure;
    exports.loadRouteLocation = loadRouteLocation;
    exports.matchedRouteKey = matchedRouteKey;
    exports.onBeforeRouteLeave = onBeforeRouteLeave;
    exports.onBeforeRouteUpdate = onBeforeRouteUpdate;
    exports.parseQuery = parseQuery;
    exports.routeLocationKey = routeLocationKey;
    exports.routerKey = routerKey;
    exports.routerViewLocationKey = routerViewLocationKey;
    exports.stringifyQuery = stringifyQuery;
    exports.useLink = useLink;
    exports.useRoute = useRoute;
    exports.useRouter = useRouter;
    exports.viewDepthKey = viewDepthKey;
  }
});

// node_modules/vue-router/index.js
var require_vue_router2 = __commonJS({
  "node_modules/vue-router/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_vue_router();
    }
  }
});

// node_modules/@fsllc/fs-bootstrap/dist/fs-bootstrap.umd.js
var require_fs_bootstrap_umd = __commonJS({
  "node_modules/@fsllc/fs-bootstrap/dist/fs-bootstrap.umd.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory((init_bootstrap_esm(), __toCommonJS(bootstrap_esm_exports)), require_vue(), require_vue_router2());
      else if (typeof define === "function" && define.amd)
        define(["bootstrap", "vue", "vue-router"], factory);
      else if (typeof exports === "object")
        exports["fs-bootstrap"] = factory((init_bootstrap_esm(), __toCommonJS(bootstrap_esm_exports)), require_vue(), require_vue_router2());
      else
        root["fs-bootstrap"] = factory(root["bootstrap"], root["vue"], root["vue-router"]);
    })(typeof self !== "undefined" ? self : exports, function(__WEBPACK_EXTERNAL_MODULE__988__, __WEBPACK_EXTERNAL_MODULE__748__, __WEBPACK_EXTERNAL_MODULE__8557__) {
      return function() {
        var __webpack_modules__ = {
          9662: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var isCallable = __webpack_require__2(614);
            var tryToString = __webpack_require__2(6330);
            var $TypeError = TypeError;
            module2.exports = function(argument) {
              if (isCallable(argument))
                return argument;
              throw $TypeError(tryToString(argument) + " is not a function");
            };
          },
          9670: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var isObject2 = __webpack_require__2(111);
            var $String = String;
            var $TypeError = TypeError;
            module2.exports = function(argument) {
              if (isObject2(argument))
                return argument;
              throw $TypeError($String(argument) + " is not an object");
            };
          },
          1318: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var toIndexedObject = __webpack_require__2(5656);
            var toAbsoluteIndex = __webpack_require__2(1400);
            var lengthOfArrayLike = __webpack_require__2(6244);
            var createMethod = function(IS_INCLUDES) {
              return function($this, el, fromIndex) {
                var O = toIndexedObject($this);
                var length = lengthOfArrayLike(O);
                var index = toAbsoluteIndex(fromIndex, length);
                var value;
                if (IS_INCLUDES && el != el)
                  while (length > index) {
                    value = O[index++];
                    if (value != value)
                      return true;
                  }
                else
                  for (; length > index; index++) {
                    if ((IS_INCLUDES || index in O) && O[index] === el)
                      return IS_INCLUDES || index || 0;
                  }
                return !IS_INCLUDES && -1;
              };
            };
            module2.exports = {
              includes: createMethod(true),
              indexOf: createMethod(false)
            };
          },
          3658: function(module2, __unused_webpack_exports, __webpack_require__2) {
            "use strict";
            var DESCRIPTORS = __webpack_require__2(9781);
            var isArray2 = __webpack_require__2(3157);
            var $TypeError = TypeError;
            var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function() {
              if (this !== void 0)
                return true;
              try {
                Object.defineProperty([], "length", { writable: false }).length = 1;
              } catch (error) {
                return error instanceof TypeError;
              }
            }();
            module2.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {
              if (isArray2(O) && !getOwnPropertyDescriptor(O, "length").writable) {
                throw $TypeError("Cannot set read only .length");
              }
              return O.length = length;
            } : function(O, length) {
              return O.length = length;
            };
          },
          4326: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            var toString = uncurryThis({}.toString);
            var stringSlice = uncurryThis("".slice);
            module2.exports = function(it) {
              return stringSlice(toString(it), 8, -1);
            };
          },
          9920: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var hasOwn = __webpack_require__2(2597);
            var ownKeys = __webpack_require__2(3887);
            var getOwnPropertyDescriptorModule = __webpack_require__2(1236);
            var definePropertyModule = __webpack_require__2(3070);
            module2.exports = function(target, source, exceptions) {
              var keys2 = ownKeys(source);
              var defineProperty = definePropertyModule.f;
              var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
              for (var i = 0; i < keys2.length; i++) {
                var key = keys2[i];
                if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
                  defineProperty(target, key, getOwnPropertyDescriptor(source, key));
                }
              }
            };
          },
          8880: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var DESCRIPTORS = __webpack_require__2(9781);
            var definePropertyModule = __webpack_require__2(3070);
            var createPropertyDescriptor = __webpack_require__2(9114);
            module2.exports = DESCRIPTORS ? function(object, key, value) {
              return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
            } : function(object, key, value) {
              object[key] = value;
              return object;
            };
          },
          9114: function(module2) {
            module2.exports = function(bitmap, value) {
              return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value
              };
            };
          },
          8052: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var isCallable = __webpack_require__2(614);
            var definePropertyModule = __webpack_require__2(3070);
            var makeBuiltIn = __webpack_require__2(6339);
            var defineGlobalProperty = __webpack_require__2(3072);
            module2.exports = function(O, key, value, options) {
              if (!options)
                options = {};
              var simple = options.enumerable;
              var name = options.name !== void 0 ? options.name : key;
              if (isCallable(value))
                makeBuiltIn(value, name, options);
              if (options.global) {
                if (simple)
                  O[key] = value;
                else
                  defineGlobalProperty(key, value);
              } else {
                try {
                  if (!options.unsafe)
                    delete O[key];
                  else if (O[key])
                    simple = true;
                } catch (error) {
                }
                if (simple)
                  O[key] = value;
                else
                  definePropertyModule.f(O, key, {
                    value,
                    enumerable: false,
                    configurable: !options.nonConfigurable,
                    writable: !options.nonWritable
                  });
              }
              return O;
            };
          },
          3072: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var defineProperty = Object.defineProperty;
            module2.exports = function(key, value) {
              try {
                defineProperty(global, key, { value, configurable: true, writable: true });
              } catch (error) {
                global[key] = value;
              }
              return value;
            };
          },
          9781: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var fails = __webpack_require__2(7293);
            module2.exports = !fails(function() {
              return Object.defineProperty({}, 1, { get: function() {
                return 7;
              } })[1] != 7;
            });
          },
          4154: function(module2) {
            var documentAll = typeof document == "object" && document.all;
            var IS_HTMLDDA = typeof documentAll == "undefined" && documentAll !== void 0;
            module2.exports = {
              all: documentAll,
              IS_HTMLDDA
            };
          },
          317: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var isObject2 = __webpack_require__2(111);
            var document2 = global.document;
            var EXISTS = isObject2(document2) && isObject2(document2.createElement);
            module2.exports = function(it) {
              return EXISTS ? document2.createElement(it) : {};
            };
          },
          7207: function(module2) {
            var $TypeError = TypeError;
            var MAX_SAFE_INTEGER = 9007199254740991;
            module2.exports = function(it) {
              if (it > MAX_SAFE_INTEGER)
                throw $TypeError("Maximum allowed index exceeded");
              return it;
            };
          },
          8113: function(module2) {
            module2.exports = typeof navigator != "undefined" && String(navigator.userAgent) || "";
          },
          7392: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var userAgent = __webpack_require__2(8113);
            var process2 = global.process;
            var Deno = global.Deno;
            var versions = process2 && process2.versions || Deno && Deno.version;
            var v8 = versions && versions.v8;
            var match, version;
            if (v8) {
              match = v8.split(".");
              version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
            }
            if (!version && userAgent) {
              match = userAgent.match(/Edge\/(\d+)/);
              if (!match || match[1] >= 74) {
                match = userAgent.match(/Chrome\/(\d+)/);
                if (match)
                  version = +match[1];
              }
            }
            module2.exports = version;
          },
          3281: function(module2) {
            module2.exports = [
              "constructor",
              "hasOwnProperty",
              "isPrototypeOf",
              "propertyIsEnumerable",
              "toLocaleString",
              "toString",
              "valueOf"
            ];
          },
          2109: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var getOwnPropertyDescriptor = __webpack_require__2(1236).f;
            var createNonEnumerableProperty = __webpack_require__2(8880);
            var defineBuiltIn = __webpack_require__2(8052);
            var defineGlobalProperty = __webpack_require__2(3072);
            var copyConstructorProperties = __webpack_require__2(9920);
            var isForced = __webpack_require__2(4705);
            module2.exports = function(options, source) {
              var TARGET = options.target;
              var GLOBAL = options.global;
              var STATIC = options.stat;
              var FORCED, target, key, targetProperty, sourceProperty, descriptor;
              if (GLOBAL) {
                target = global;
              } else if (STATIC) {
                target = global[TARGET] || defineGlobalProperty(TARGET, {});
              } else {
                target = (global[TARGET] || {}).prototype;
              }
              if (target)
                for (key in source) {
                  sourceProperty = source[key];
                  if (options.dontCallGetSet) {
                    descriptor = getOwnPropertyDescriptor(target, key);
                    targetProperty = descriptor && descriptor.value;
                  } else
                    targetProperty = target[key];
                  FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
                  if (!FORCED && targetProperty !== void 0) {
                    if (typeof sourceProperty == typeof targetProperty)
                      continue;
                    copyConstructorProperties(sourceProperty, targetProperty);
                  }
                  if (options.sham || targetProperty && targetProperty.sham) {
                    createNonEnumerableProperty(sourceProperty, "sham", true);
                  }
                  defineBuiltIn(target, key, sourceProperty, options);
                }
            };
          },
          7293: function(module2) {
            module2.exports = function(exec) {
              try {
                return !!exec();
              } catch (error) {
                return true;
              }
            };
          },
          4374: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var fails = __webpack_require__2(7293);
            module2.exports = !fails(function() {
              var test = function() {
              }.bind();
              return typeof test != "function" || test.hasOwnProperty("prototype");
            });
          },
          6916: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var NATIVE_BIND = __webpack_require__2(4374);
            var call = Function.prototype.call;
            module2.exports = NATIVE_BIND ? call.bind(call) : function() {
              return call.apply(call, arguments);
            };
          },
          6530: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var DESCRIPTORS = __webpack_require__2(9781);
            var hasOwn = __webpack_require__2(2597);
            var FunctionPrototype = Function.prototype;
            var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
            var EXISTS = hasOwn(FunctionPrototype, "name");
            var PROPER = EXISTS && function something() {
            }.name === "something";
            var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
            module2.exports = {
              EXISTS,
              PROPER,
              CONFIGURABLE
            };
          },
          1702: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var NATIVE_BIND = __webpack_require__2(4374);
            var FunctionPrototype = Function.prototype;
            var call = FunctionPrototype.call;
            var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
            module2.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
              return function() {
                return call.apply(fn, arguments);
              };
            };
          },
          5005: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var isCallable = __webpack_require__2(614);
            var aFunction = function(argument) {
              return isCallable(argument) ? argument : void 0;
            };
            module2.exports = function(namespace, method) {
              return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
            };
          },
          8173: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var aCallable = __webpack_require__2(9662);
            var isNullOrUndefined = __webpack_require__2(8554);
            module2.exports = function(V, P) {
              var func = V[P];
              return isNullOrUndefined(func) ? void 0 : aCallable(func);
            };
          },
          7854: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var check = function(it) {
              return it && it.Math == Math && it;
            };
            module2.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof __webpack_require__2.g == "object" && __webpack_require__2.g) || function() {
              return this;
            }() || Function("return this")();
          },
          2597: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            var toObject = __webpack_require__2(7908);
            var hasOwnProperty = uncurryThis({}.hasOwnProperty);
            module2.exports = Object.hasOwn || function hasOwn(it, key) {
              return hasOwnProperty(toObject(it), key);
            };
          },
          3501: function(module2) {
            module2.exports = {};
          },
          4664: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var DESCRIPTORS = __webpack_require__2(9781);
            var fails = __webpack_require__2(7293);
            var createElement = __webpack_require__2(317);
            module2.exports = !DESCRIPTORS && !fails(function() {
              return Object.defineProperty(createElement("div"), "a", {
                get: function() {
                  return 7;
                }
              }).a != 7;
            });
          },
          8361: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            var fails = __webpack_require__2(7293);
            var classof = __webpack_require__2(4326);
            var $Object = Object;
            var split = uncurryThis("".split);
            module2.exports = fails(function() {
              return !$Object("z").propertyIsEnumerable(0);
            }) ? function(it) {
              return classof(it) == "String" ? split(it, "") : $Object(it);
            } : $Object;
          },
          2788: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            var isCallable = __webpack_require__2(614);
            var store = __webpack_require__2(5465);
            var functionToString = uncurryThis(Function.toString);
            if (!isCallable(store.inspectSource)) {
              store.inspectSource = function(it) {
                return functionToString(it);
              };
            }
            module2.exports = store.inspectSource;
          },
          9909: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var NATIVE_WEAK_MAP = __webpack_require__2(4811);
            var global = __webpack_require__2(7854);
            var isObject2 = __webpack_require__2(111);
            var createNonEnumerableProperty = __webpack_require__2(8880);
            var hasOwn = __webpack_require__2(2597);
            var shared = __webpack_require__2(5465);
            var sharedKey = __webpack_require__2(6200);
            var hiddenKeys = __webpack_require__2(3501);
            var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
            var TypeError2 = global.TypeError;
            var WeakMap = global.WeakMap;
            var set, get, has;
            var enforce = function(it) {
              return has(it) ? get(it) : set(it, {});
            };
            var getterFor = function(TYPE) {
              return function(it) {
                var state;
                if (!isObject2(it) || (state = get(it)).type !== TYPE) {
                  throw TypeError2("Incompatible receiver, " + TYPE + " required");
                }
                return state;
              };
            };
            if (NATIVE_WEAK_MAP || shared.state) {
              var store = shared.state || (shared.state = new WeakMap());
              store.get = store.get;
              store.has = store.has;
              store.set = store.set;
              set = function(it, metadata) {
                if (store.has(it))
                  throw TypeError2(OBJECT_ALREADY_INITIALIZED);
                metadata.facade = it;
                store.set(it, metadata);
                return metadata;
              };
              get = function(it) {
                return store.get(it) || {};
              };
              has = function(it) {
                return store.has(it);
              };
            } else {
              var STATE = sharedKey("state");
              hiddenKeys[STATE] = true;
              set = function(it, metadata) {
                if (hasOwn(it, STATE))
                  throw TypeError2(OBJECT_ALREADY_INITIALIZED);
                metadata.facade = it;
                createNonEnumerableProperty(it, STATE, metadata);
                return metadata;
              };
              get = function(it) {
                return hasOwn(it, STATE) ? it[STATE] : {};
              };
              has = function(it) {
                return hasOwn(it, STATE);
              };
            }
            module2.exports = {
              set,
              get,
              has,
              enforce,
              getterFor
            };
          },
          3157: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var classof = __webpack_require__2(4326);
            module2.exports = Array.isArray || function isArray2(argument) {
              return classof(argument) == "Array";
            };
          },
          614: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var $documentAll = __webpack_require__2(4154);
            var documentAll = $documentAll.all;
            module2.exports = $documentAll.IS_HTMLDDA ? function(argument) {
              return typeof argument == "function" || argument === documentAll;
            } : function(argument) {
              return typeof argument == "function";
            };
          },
          4705: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var fails = __webpack_require__2(7293);
            var isCallable = __webpack_require__2(614);
            var replacement = /#|\.prototype\./;
            var isForced = function(feature, detection) {
              var value = data[normalize(feature)];
              return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
            };
            var normalize = isForced.normalize = function(string) {
              return String(string).replace(replacement, ".").toLowerCase();
            };
            var data = isForced.data = {};
            var NATIVE = isForced.NATIVE = "N";
            var POLYFILL = isForced.POLYFILL = "P";
            module2.exports = isForced;
          },
          8554: function(module2) {
            module2.exports = function(it) {
              return it === null || it === void 0;
            };
          },
          111: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var isCallable = __webpack_require__2(614);
            var $documentAll = __webpack_require__2(4154);
            var documentAll = $documentAll.all;
            module2.exports = $documentAll.IS_HTMLDDA ? function(it) {
              return typeof it == "object" ? it !== null : isCallable(it) || it === documentAll;
            } : function(it) {
              return typeof it == "object" ? it !== null : isCallable(it);
            };
          },
          1913: function(module2) {
            module2.exports = false;
          },
          2190: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var getBuiltIn = __webpack_require__2(5005);
            var isCallable = __webpack_require__2(614);
            var isPrototypeOf = __webpack_require__2(7976);
            var USE_SYMBOL_AS_UID = __webpack_require__2(3307);
            var $Object = Object;
            module2.exports = USE_SYMBOL_AS_UID ? function(it) {
              return typeof it == "symbol";
            } : function(it) {
              var $Symbol = getBuiltIn("Symbol");
              return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
            };
          },
          6244: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var toLength = __webpack_require__2(7466);
            module2.exports = function(obj) {
              return toLength(obj.length);
            };
          },
          6339: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            var fails = __webpack_require__2(7293);
            var isCallable = __webpack_require__2(614);
            var hasOwn = __webpack_require__2(2597);
            var DESCRIPTORS = __webpack_require__2(9781);
            var CONFIGURABLE_FUNCTION_NAME = __webpack_require__2(6530).CONFIGURABLE;
            var inspectSource = __webpack_require__2(2788);
            var InternalStateModule = __webpack_require__2(9909);
            var enforceInternalState = InternalStateModule.enforce;
            var getInternalState = InternalStateModule.get;
            var $String = String;
            var defineProperty = Object.defineProperty;
            var stringSlice = uncurryThis("".slice);
            var replace = uncurryThis("".replace);
            var join = uncurryThis([].join);
            var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
              return defineProperty(function() {
              }, "length", { value: 8 }).length !== 8;
            });
            var TEMPLATE = String(String).split("String");
            var makeBuiltIn = module2.exports = function(value, name, options) {
              if (stringSlice($String(name), 0, 7) === "Symbol(") {
                name = "[" + replace($String(name), /^Symbol\(([^)]*)\)/, "$1") + "]";
              }
              if (options && options.getter)
                name = "get " + name;
              if (options && options.setter)
                name = "set " + name;
              if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
                if (DESCRIPTORS)
                  defineProperty(value, "name", { value: name, configurable: true });
                else
                  value.name = name;
              }
              if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
                defineProperty(value, "length", { value: options.arity });
              }
              try {
                if (options && hasOwn(options, "constructor") && options.constructor) {
                  if (DESCRIPTORS)
                    defineProperty(value, "prototype", { writable: false });
                } else if (value.prototype)
                  value.prototype = void 0;
              } catch (error) {
              }
              var state = enforceInternalState(value);
              if (!hasOwn(state, "source")) {
                state.source = join(TEMPLATE, typeof name == "string" ? name : "");
              }
              return value;
            };
            Function.prototype.toString = makeBuiltIn(function toString() {
              return isCallable(this) && getInternalState(this).source || inspectSource(this);
            }, "toString");
          },
          4758: function(module2) {
            var ceil = Math.ceil;
            var floor = Math.floor;
            module2.exports = Math.trunc || function trunc(x) {
              var n = +x;
              return (n > 0 ? floor : ceil)(n);
            };
          },
          3070: function(__unused_webpack_module, exports2, __webpack_require__2) {
            var DESCRIPTORS = __webpack_require__2(9781);
            var IE8_DOM_DEFINE = __webpack_require__2(4664);
            var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__2(3353);
            var anObject = __webpack_require__2(9670);
            var toPropertyKey = __webpack_require__2(4948);
            var $TypeError = TypeError;
            var $defineProperty = Object.defineProperty;
            var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            var ENUMERABLE = "enumerable";
            var CONFIGURABLE = "configurable";
            var WRITABLE = "writable";
            exports2.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPropertyKey(P);
              anObject(Attributes);
              if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
                var current = $getOwnPropertyDescriptor(O, P);
                if (current && current[WRITABLE]) {
                  O[P] = Attributes.value;
                  Attributes = {
                    configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                    enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                    writable: false
                  };
                }
              }
              return $defineProperty(O, P, Attributes);
            } : $defineProperty : function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPropertyKey(P);
              anObject(Attributes);
              if (IE8_DOM_DEFINE)
                try {
                  return $defineProperty(O, P, Attributes);
                } catch (error) {
                }
              if ("get" in Attributes || "set" in Attributes)
                throw $TypeError("Accessors not supported");
              if ("value" in Attributes)
                O[P] = Attributes.value;
              return O;
            };
          },
          1236: function(__unused_webpack_module, exports2, __webpack_require__2) {
            var DESCRIPTORS = __webpack_require__2(9781);
            var call = __webpack_require__2(6916);
            var propertyIsEnumerableModule = __webpack_require__2(5296);
            var createPropertyDescriptor = __webpack_require__2(9114);
            var toIndexedObject = __webpack_require__2(5656);
            var toPropertyKey = __webpack_require__2(4948);
            var hasOwn = __webpack_require__2(2597);
            var IE8_DOM_DEFINE = __webpack_require__2(4664);
            var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
              O = toIndexedObject(O);
              P = toPropertyKey(P);
              if (IE8_DOM_DEFINE)
                try {
                  return $getOwnPropertyDescriptor(O, P);
                } catch (error) {
                }
              if (hasOwn(O, P))
                return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
            };
          },
          8006: function(__unused_webpack_module, exports2, __webpack_require__2) {
            var internalObjectKeys = __webpack_require__2(6324);
            var enumBugKeys = __webpack_require__2(3281);
            var hiddenKeys = enumBugKeys.concat("length", "prototype");
            exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
              return internalObjectKeys(O, hiddenKeys);
            };
          },
          5181: function(__unused_webpack_module, exports2) {
            exports2.f = Object.getOwnPropertySymbols;
          },
          7976: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            module2.exports = uncurryThis({}.isPrototypeOf);
          },
          6324: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            var hasOwn = __webpack_require__2(2597);
            var toIndexedObject = __webpack_require__2(5656);
            var indexOf = __webpack_require__2(1318).indexOf;
            var hiddenKeys = __webpack_require__2(3501);
            var push = uncurryThis([].push);
            module2.exports = function(object, names) {
              var O = toIndexedObject(object);
              var i = 0;
              var result = [];
              var key;
              for (key in O)
                !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
              while (names.length > i)
                if (hasOwn(O, key = names[i++])) {
                  ~indexOf(result, key) || push(result, key);
                }
              return result;
            };
          },
          5296: function(__unused_webpack_module, exports2) {
            "use strict";
            var $propertyIsEnumerable = {}.propertyIsEnumerable;
            var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
            exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
              var descriptor = getOwnPropertyDescriptor(this, V);
              return !!descriptor && descriptor.enumerable;
            } : $propertyIsEnumerable;
          },
          2140: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var call = __webpack_require__2(6916);
            var isCallable = __webpack_require__2(614);
            var isObject2 = __webpack_require__2(111);
            var $TypeError = TypeError;
            module2.exports = function(input, pref) {
              var fn, val;
              if (pref === "string" && isCallable(fn = input.toString) && !isObject2(val = call(fn, input)))
                return val;
              if (isCallable(fn = input.valueOf) && !isObject2(val = call(fn, input)))
                return val;
              if (pref !== "string" && isCallable(fn = input.toString) && !isObject2(val = call(fn, input)))
                return val;
              throw $TypeError("Can't convert object to primitive value");
            };
          },
          3887: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var getBuiltIn = __webpack_require__2(5005);
            var uncurryThis = __webpack_require__2(1702);
            var getOwnPropertyNamesModule = __webpack_require__2(8006);
            var getOwnPropertySymbolsModule = __webpack_require__2(5181);
            var anObject = __webpack_require__2(9670);
            var concat = uncurryThis([].concat);
            module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
              var keys2 = getOwnPropertyNamesModule.f(anObject(it));
              var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
              return getOwnPropertySymbols ? concat(keys2, getOwnPropertySymbols(it)) : keys2;
            };
          },
          4488: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var isNullOrUndefined = __webpack_require__2(8554);
            var $TypeError = TypeError;
            module2.exports = function(it) {
              if (isNullOrUndefined(it))
                throw $TypeError("Can't call method on " + it);
              return it;
            };
          },
          6200: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var shared = __webpack_require__2(2309);
            var uid = __webpack_require__2(9711);
            var keys2 = shared("keys");
            module2.exports = function(key) {
              return keys2[key] || (keys2[key] = uid(key));
            };
          },
          5465: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var defineGlobalProperty = __webpack_require__2(3072);
            var SHARED = "__core-js_shared__";
            var store = global[SHARED] || defineGlobalProperty(SHARED, {});
            module2.exports = store;
          },
          2309: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var IS_PURE = __webpack_require__2(1913);
            var store = __webpack_require__2(5465);
            (module2.exports = function(key, value) {
              return store[key] || (store[key] = value !== void 0 ? value : {});
            })("versions", []).push({
              version: "3.27.2",
              mode: IS_PURE ? "pure" : "global",
              copyright: "\xA9 2014-2023 Denis Pushkarev (zloirock.ru)",
              license: "https://github.com/zloirock/core-js/blob/v3.27.2/LICENSE",
              source: "https://github.com/zloirock/core-js"
            });
          },
          6293: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var V8_VERSION = __webpack_require__2(7392);
            var fails = __webpack_require__2(7293);
            module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
              var symbol = Symbol();
              return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
            });
          },
          1400: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var toIntegerOrInfinity = __webpack_require__2(9303);
            var max = Math.max;
            var min = Math.min;
            module2.exports = function(index, length) {
              var integer = toIntegerOrInfinity(index);
              return integer < 0 ? max(integer + length, 0) : min(integer, length);
            };
          },
          5656: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var IndexedObject = __webpack_require__2(8361);
            var requireObjectCoercible = __webpack_require__2(4488);
            module2.exports = function(it) {
              return IndexedObject(requireObjectCoercible(it));
            };
          },
          9303: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var trunc = __webpack_require__2(4758);
            module2.exports = function(argument) {
              var number = +argument;
              return number !== number || number === 0 ? 0 : trunc(number);
            };
          },
          7466: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var toIntegerOrInfinity = __webpack_require__2(9303);
            var min = Math.min;
            module2.exports = function(argument) {
              return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
            };
          },
          7908: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var requireObjectCoercible = __webpack_require__2(4488);
            var $Object = Object;
            module2.exports = function(argument) {
              return $Object(requireObjectCoercible(argument));
            };
          },
          7593: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var call = __webpack_require__2(6916);
            var isObject2 = __webpack_require__2(111);
            var isSymbol = __webpack_require__2(2190);
            var getMethod = __webpack_require__2(8173);
            var ordinaryToPrimitive = __webpack_require__2(2140);
            var wellKnownSymbol = __webpack_require__2(5112);
            var $TypeError = TypeError;
            var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
            module2.exports = function(input, pref) {
              if (!isObject2(input) || isSymbol(input))
                return input;
              var exoticToPrim = getMethod(input, TO_PRIMITIVE);
              var result;
              if (exoticToPrim) {
                if (pref === void 0)
                  pref = "default";
                result = call(exoticToPrim, input, pref);
                if (!isObject2(result) || isSymbol(result))
                  return result;
                throw $TypeError("Can't convert object to primitive value");
              }
              if (pref === void 0)
                pref = "number";
              return ordinaryToPrimitive(input, pref);
            };
          },
          4948: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var toPrimitive = __webpack_require__2(7593);
            var isSymbol = __webpack_require__2(2190);
            module2.exports = function(argument) {
              var key = toPrimitive(argument, "string");
              return isSymbol(key) ? key : key + "";
            };
          },
          6330: function(module2) {
            var $String = String;
            module2.exports = function(argument) {
              try {
                return $String(argument);
              } catch (error) {
                return "Object";
              }
            };
          },
          9711: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var uncurryThis = __webpack_require__2(1702);
            var id = 0;
            var postfix = Math.random();
            var toString = uncurryThis(1 .toString);
            module2.exports = function(key) {
              return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
            };
          },
          3307: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var NATIVE_SYMBOL = __webpack_require__2(6293);
            module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
          },
          3353: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var DESCRIPTORS = __webpack_require__2(9781);
            var fails = __webpack_require__2(7293);
            module2.exports = DESCRIPTORS && fails(function() {
              return Object.defineProperty(function() {
              }, "prototype", {
                value: 42,
                writable: false
              }).prototype != 42;
            });
          },
          4811: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var isCallable = __webpack_require__2(614);
            var WeakMap = global.WeakMap;
            module2.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));
          },
          5112: function(module2, __unused_webpack_exports, __webpack_require__2) {
            var global = __webpack_require__2(7854);
            var shared = __webpack_require__2(2309);
            var hasOwn = __webpack_require__2(2597);
            var uid = __webpack_require__2(9711);
            var NATIVE_SYMBOL = __webpack_require__2(6293);
            var USE_SYMBOL_AS_UID = __webpack_require__2(3307);
            var Symbol2 = global.Symbol;
            var WellKnownSymbolsStore = shared("wks");
            var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
            module2.exports = function(name) {
              if (!hasOwn(WellKnownSymbolsStore, name)) {
                WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
              }
              return WellKnownSymbolsStore[name];
            };
          },
          7658: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
            "use strict";
            var $ = __webpack_require__2(2109);
            var toObject = __webpack_require__2(7908);
            var lengthOfArrayLike = __webpack_require__2(6244);
            var setArrayLength = __webpack_require__2(3658);
            var doesNotExceedSafeInteger = __webpack_require__2(7207);
            var fails = __webpack_require__2(7293);
            var INCORRECT_TO_LENGTH = fails(function() {
              return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
            });
            var properErrorOnNonWritableLength = function() {
              try {
                Object.defineProperty([], "length", { writable: false }).push();
              } catch (error) {
                return error instanceof TypeError;
              }
            };
            var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();
            $({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
              push: function push(item) {
                var O = toObject(this);
                var len = lengthOfArrayLike(O);
                var argCount = arguments.length;
                doesNotExceedSafeInteger(len + argCount);
                for (var i = 0; i < argCount; i++) {
                  O[len] = arguments[i];
                  len++;
                }
                setArrayLength(O, len);
                return len;
              }
            });
          },
          2562: function(module2) {
            function debounce(func, wait, immediate) {
              var timeout, args, context, timestamp, result;
              if (null == wait)
                wait = 100;
              function later() {
                var last = Date.now() - timestamp;
                if (last < wait && last >= 0) {
                  timeout = setTimeout(later, wait - last);
                } else {
                  timeout = null;
                  if (!immediate) {
                    result = func.apply(context, args);
                    context = args = null;
                  }
                }
              }
              ;
              var debounced = function() {
                context = this;
                args = arguments;
                timestamp = Date.now();
                var callNow = immediate && !timeout;
                if (!timeout)
                  timeout = setTimeout(later, wait);
                if (callNow) {
                  result = func.apply(context, args);
                  context = args = null;
                }
                return result;
              };
              debounced.clear = function() {
                if (timeout) {
                  clearTimeout(timeout);
                  timeout = null;
                }
              };
              debounced.flush = function() {
                if (timeout) {
                  result = func.apply(context, args);
                  context = args = null;
                  clearTimeout(timeout);
                  timeout = null;
                }
              };
              return debounced;
            }
            ;
            debounce.debounce = debounce;
            module2.exports = debounce;
          },
          7066: function(__unused_webpack_module, exports2) {
            "use strict";
            var __webpack_unused_export__;
            __webpack_unused_export__ = {
              value: true
            };
            exports2.Z = (sfc, props) => {
              const target = sfc.__vccOpts || sfc;
              for (const [key, val] of props) {
                target[key] = val;
              }
              return target;
            };
          },
          988: function(module2) {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__988__;
          },
          748: function(module2) {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__748__;
          },
          8557: function(module2) {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__8557__;
          }
        };
        var __webpack_module_cache__ = {};
        function __webpack_require__(moduleId) {
          var cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          var module2 = __webpack_module_cache__[moduleId] = {
            exports: {}
          };
          __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
          return module2.exports;
        }
        !function() {
          __webpack_require__.d = function(exports2, definition) {
            for (var key in definition) {
              if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
              }
            }
          };
        }();
        !function() {
          __webpack_require__.g = function() {
            if (typeof globalThis === "object")
              return globalThis;
            try {
              return this || new Function("return this")();
            } catch (e) {
              if (typeof window === "object")
                return window;
            }
          }();
        }();
        !function() {
          __webpack_require__.o = function(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          };
        }();
        !function() {
          __webpack_require__.r = function(exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
        }();
        !function() {
          __webpack_require__.p = "";
        }();
        var __webpack_exports__ = {};
        !function() {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          __webpack_require__.d(__webpack_exports__, {
            "FsAccordion": function() {
              return fsAccordion;
            },
            "FsAccordionItem": function() {
              return fsAccordionItem;
            },
            "FsAlert": function() {
              return fsAlert;
            },
            "FsAspect": function() {
              return fsAspect;
            },
            "FsBadge": function() {
              return fsBadge;
            },
            "FsBootstrap": function() {
              return FsBootstrap;
            },
            "FsButton": function() {
              return fsButton;
            },
            "FsButtonGroup": function() {
              return fsButtonGroup;
            },
            "FsCard": function() {
              return fsCard;
            },
            "FsCardBody": function() {
              return fsCardBody;
            },
            "FsCardFooter": function() {
              return fsCardFooter;
            },
            "FsCardGroup": function() {
              return fsCardGroup;
            },
            "FsCardHeader": function() {
              return fsCardHeader;
            },
            "FsCardImg": function() {
              return fsCardImg;
            },
            "FsCardSubTitle": function() {
              return fsCardSubTitle;
            },
            "FsCardText": function() {
              return fsCardText;
            },
            "FsCardTitle": function() {
              return fsCardTitle;
            },
            "FsCol": function() {
              return fsCol;
            },
            "FsCollapse": function() {
              return fsCollapse;
            },
            "FsContainer": function() {
              return fsContainer;
            },
            "FsDropdown": function() {
              return fsDropdown;
            },
            "FsDropdownDivider": function() {
              return fsDropdownDivider;
            },
            "FsDropdownForm": function() {
              return fsDropdownForm;
            },
            "FsDropdownGroup": function() {
              return fsDropdownGroup;
            },
            "FsDropdownHeader": function() {
              return fsDropdownHeader;
            },
            "FsDropdownItem": function() {
              return fsDropdownItem;
            },
            "FsDropdownItemButton": function() {
              return fsDropdownItemButton;
            },
            "FsDropdownText": function() {
              return fsDropdownText;
            },
            "FsFormCheckbox": function() {
              return fsFormCheckbox;
            },
            "FsFormCheckboxGroup": function() {
              return fsFormCheckboxGroup;
            },
            "FsFormFile": function() {
              return fsFormFile;
            },
            "FsFormGroup": function() {
              return fsFormGroup;
            },
            "FsFormInput": function() {
              return fsFormInput;
            },
            "FsFormRadio": function() {
              return fsFormRadio;
            },
            "FsFormRadioGroup": function() {
              return fsFormRadioGroup;
            },
            "FsFormSelect": function() {
              return fsFormSelect;
            },
            "FsFormSelectOption": function() {
              return fsFormSelectOption;
            },
            "FsFormSelectOptionGroup": function() {
              return fsFormSelectOptionGroup;
            },
            "FsFormTextarea": function() {
              return fsFormTextarea;
            },
            "FsImg": function() {
              return fsImg;
            },
            "FsInputGroup": function() {
              return fsInputGroup;
            },
            "FsInputGroupText": function() {
              return fsInputGroupText;
            },
            "FsLink": function() {
              return fsLink;
            },
            "FsListGroup": function() {
              return fsListGroup;
            },
            "FsListGroupItem": function() {
              return fsListGroupItem;
            },
            "FsModal": function() {
              return fsModal;
            },
            "FsNav": function() {
              return fsNav;
            },
            "FsNavForm": function() {
              return fsNavForm;
            },
            "FsNavItem": function() {
              return fsNavItem;
            },
            "FsNavItemDropdown": function() {
              return fsNavItemDropdown;
            },
            "FsNavText": function() {
              return fsNavText;
            },
            "FsNavbar": function() {
              return fsNavbar;
            },
            "FsNavbarBrand": function() {
              return fsNavbarBrand;
            },
            "FsNavbarNav": function() {
              return fsNavbarNav;
            },
            "FsNavbarToggle": function() {
              return fsNavbarToggle;
            },
            "FsOverlay": function() {
              return fsOverlay;
            },
            "FsPagination": function() {
              return fsPagination;
            },
            "FsPopover": function() {
              return fsPopover;
            },
            "FsProgress": function() {
              return fsProgress;
            },
            "FsProgressBar": function() {
              return fsProgressBar;
            },
            "FsRouterLink": function() {
              return fsRouterLink;
            },
            "FsRow": function() {
              return fsRow;
            },
            "FsSidebar": function() {
              return fsSidebar;
            },
            "FsSpinner": function() {
              return fsSpinner;
            },
            "FsTab": function() {
              return fsTab;
            },
            "FsTable": function() {
              return fsTable;
            },
            "FsTableSimple": function() {
              return fsTableSimple;
            },
            "FsTabs": function() {
              return fsTabs;
            },
            "FsTbody": function() {
              return fsTbody;
            },
            "FsTd": function() {
              return fsTd;
            },
            "FsTfoot": function() {
              return fsTfoot;
            },
            "FsTh": function() {
              return fsTh;
            },
            "FsThead": function() {
              return fsThead;
            },
            "FsTooltip": function() {
              return fsTooltip;
            },
            "FsTr": function() {
              return fsTr;
            },
            "ROOT_EVENT_ACTION_HIDE_MODAL": function() {
              return ROOT_EVENT_ACTION_HIDE_MODAL;
            },
            "ROOT_EVENT_ACTION_SHOW_MODAL": function() {
              return ROOT_EVENT_ACTION_SHOW_MODAL;
            },
            "ROOT_EVENT_MODAL_HIDDEN": function() {
              return ROOT_EVENT_MODAL_HIDDEN;
            },
            "ROOT_EVENT_MODAL_HIDE": function() {
              return ROOT_EVENT_MODAL_HIDE;
            },
            "ROOT_EVENT_MODAL_SHOW": function() {
              return ROOT_EVENT_MODAL_SHOW;
            },
            "ROOT_EVENT_MODAL_SHOWN": function() {
              return ROOT_EVENT_MODAL_SHOWN;
            }
          });
          ;
          if (typeof window !== "undefined") {
            var currentScript = window.document.currentScript;
            if (false) {
              var getCurrentScript;
            }
            var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
            if (src) {
              __webpack_require__.p = src[1];
            }
          }
          var setPublicPath = null;
          var external_vue_router_ = __webpack_require__(8557);
          var external_vue_ = __webpack_require__(748);
          ;
          var useAlignment = (align) => (0, external_vue_.computed)(() => {
            if (!align.value)
              return "";
            return `justify-content-${align.value}`;
          });
          ;
          function _typeof(obj) {
            "@babel/helpers - typeof";
            return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
              return typeof obj2;
            } : function(obj2) {
              return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            }, _typeof(obj);
          }
          ;
          function _toPrimitive(input, hint) {
            if (_typeof(input) !== "object" || input === null)
              return input;
            var prim = input[Symbol.toPrimitive];
            if (prim !== void 0) {
              var res = prim.call(input, hint || "default");
              if (_typeof(res) !== "object")
                return res;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (hint === "string" ? String : Number)(input);
          }
          ;
          function _toPropertyKey(arg) {
            var key = _toPrimitive(arg, "string");
            return _typeof(key) === "symbol" ? key : String(key);
          }
          ;
          function _defineProperty(obj, key, value) {
            key = _toPropertyKey(key);
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          ;
          const object_assign = (...args) => Object.assign({
            ...args
          });
          const create = (proto, optionalProps) => {
            Object.create(proto, optionalProps);
          };
          const defineProperties = (obj, props) => Object.defineProperties(obj, props);
          const defineProperty = (obj, prop, descriptor) => Object.defineProperty(obj, prop, descriptor);
          const freeze = (obj) => Object.freeze(obj);
          const getOwnPropertyNames = (obj) => Object.getOwnPropertyNames(obj);
          const getOwnPropertyDescriptor = (obj, prop) => Object.getOwnPropertyDescriptor(obj, prop);
          const getOwnPropertySymbols = (obj) => Object.getOwnPropertySymbols(obj);
          const getPrototypeOf = (obj) => Object.getPrototypeOf(obj);
          const is = (value1, value2) => Object.is(value1, value2);
          const isFrozen = (obj) => Object.isFrozen(obj);
          const object_keys = (obj) => Object.keys(obj);
          const object_hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
          const object_toString = (obj) => Object.prototype.toString.call(obj);
          const clone = (obj) => ({
            ...obj
          });
          const pick = (obj, props) => object_keys(obj).filter((key) => props.indexOf(key) !== -1).reduce((result, key) => ({
            ...result,
            [key]: obj[key]
          }), {});
          const omit = (obj, props) => object_keys(obj).filter((key) => props.indexOf(key) === -1).reduce((result, key) => ({
            ...result,
            [key]: obj[key]
          }), {});
          const mergeDeep = (target, source) => {
            if (isObject(target) && isObject(source)) {
              object_keys(source).forEach((key) => {
                if (isObject(source[key])) {
                  if (!target[key] || !isObject(target[key])) {
                    target[key] = source[key];
                  }
                  mergeDeep(target[key], source[key]);
                } else {
                  object_assign(target, {
                    [key]: source[key]
                  });
                }
              });
            }
            return target;
          };
          const sortKeys = (obj) => object_keys(obj).sort().reduce((result, key) => ({
            ...result,
            [key]: obj[key]
          }), {});
          const readonlyDescriptor = () => ({
            enumerable: true,
            configurable: false,
            writable: false
          });
          ;
          class BvEvent {
            constructor(eventType, eventInit = {}) {
              _defineProperty(this, "cancelable", true);
              _defineProperty(this, "componentId", null);
              _defineProperty(this, "defaultPrevented", false);
              _defineProperty(this, "nativeEvent", null);
              _defineProperty(this, "preventDefault", void 0);
              _defineProperty(this, "relatedTarget", null);
              _defineProperty(this, "target", null);
              _defineProperty(this, "eventType", "");
              _defineProperty(this, "vueTarget", null);
              if (!eventType) {
                throw new TypeError(`Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`);
              }
              Object.assign(this, BvEvent.Defaults, this.constructor.Defaults, eventInit, {
                eventType
              });
              Object.defineProperties(this, {
                type: readonlyDescriptor(),
                cancelable: readonlyDescriptor(),
                nativeEvent: readonlyDescriptor(),
                target: readonlyDescriptor(),
                relatedTarget: readonlyDescriptor(),
                vueTarget: readonlyDescriptor(),
                componentId: readonlyDescriptor()
              });
              let defaultPrevented = false;
              this.preventDefault = function preventDefault() {
                if (this.cancelable) {
                  defaultPrevented = true;
                }
              };
              Object.defineProperty(this, "defaultPrevented", {
                enumerable: true,
                get() {
                  return defaultPrevented;
                }
              });
            }
            static get Defaults() {
              return {
                eventType: "",
                cancelable: true,
                nativeEvent: null,
                target: null,
                relatedTarget: null,
                vueTarget: null,
                componentId: null
              };
            }
          }
          ;
          const isBooleanish = (input) => typeof input === "boolean" || input === "" || input === "true" || input === "false";
          const resolveBooleanish = (input) => typeof input === "boolean" ? input : input === "" ? true : input === "true" ? true : false;
          ;
          const toType = (value) => typeof value;
          const inspect_isArray = (value) => Array.isArray(value);
          const inspect_isString = (value) => toType(value) === "string";
          const inspect_isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
          const inspect_isObject = (obj) => obj !== null && typeof obj === "object";
          const isDate = (value) => value instanceof Date;
          const isUndefined = (value) => value === void 0;
          const isNull = (value) => value === null;
          const inspect_isUndefinedOrNull = (value) => isUndefined(value) || isNull(value);
          const isFunction = (value) => toType(value) === "function";
          const isBoolean = (value) => toType(value) === "boolean";
          const isNumber = (value) => toType(value) === "number";
          const isNumeric = (value) => RX_NUMBER.test(String(value));
          ;
          const RX_ARRAY_NOTATION = /\[(\d+)]/g;
          const RX_FIRST_START_SPACE_WORD = /(\s|^)(\w)/;
          const RX_GLOBAL_START_SPACE_WORD = /(\s|^)(\w)/g;
          const RX_FIRST_LOWER = /\b([a-z])/g;
          const regex_RX_FSV_PREFIX = /^(Fs?)/;
          const RX_HYPHEN = /\B(\-*)/g;
          const regex_RX_HYPHENATE = /\B([A-Z])/g;
          const RX_HASH = /^#/;
          const RX_HASH_ID = /^#[A-Za-z]+[\w\-:.]*$/;
          const RX_HREF = /^.*(#[^#]+)$/;
          const RX_LOWER_UPPER = /([a-z])([A-Z])/g;
          const RX_START_SPACE_WORD = /(\s|^)(\w)/g;
          const RX_SPACE_SPLIT = /\s+/;
          const RX_UNDERSCORE = /_/g;
          const regex_RX_NUMBER = /^[0-9]*\.?[0-9]+$/;
          ;
          const stringUtils_toString = (val, spaces = 2) => inspect_isUndefinedOrNull(val) ? "" : inspect_isArray(val) || inspect_isPlainObject(val) && val.toString === Object.prototype.toString ? JSON.stringify(val, null, spaces) : String(val);
          const startCase = (str) => str.replace(RX_UNDERSCORE, " ").replace(RX_LOWER_UPPER, (str2, $1, $2) => `${$1} ${$2}`).replace(RX_GLOBAL_START_SPACE_WORD, (str2, $1, $2) => $1 + $2.toUpperCase());
          const upperFirst = (str) => {
            str = isString(str) ? str.trim() : String(str);
            return str.charAt(0).toUpperCase() + str.slice(1);
          };
          ;
          const _isObject = (item) => item && typeof item === "object" && item.constructor === Object;
          const mergeDeep_mergeDeep = (target, source, extendArray = true) => {
            const output = target instanceof Date && typeof target.getMonth === "function" ? new Date(target) : Object.assign({}, target);
            if (_isObject(target) && _isObject(source)) {
              Object.keys(source).forEach((key) => {
                if (_isObject(source[key])) {
                  if (!(key in target))
                    Object.assign(output, {
                      [key]: source[key]
                    });
                  else
                    output[key] = mergeDeep_mergeDeep(target[key], source[key], extendArray);
                } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
                  Object.assign(output, {
                    [key]: !extendArray ? source[key] : target[key].concat(source[key].filter((item) => !target[key].includes(item)))
                  });
                } else {
                  Object.assign(output, {
                    [key]: source[key]
                  });
                }
              });
            }
            return output;
          };
          var utils_mergeDeep = mergeDeep_mergeDeep;
          ;
          var getId = (suffix = "") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${suffix}__`;
          ;
          var resolveAriaInvalid = (ariaInvalid, state) => ariaInvalid === true || ariaInvalid === "true" || ariaInvalid === "" ? "true" : ariaInvalid === "grammar" || ariaInvalid === "spelling" ? ariaInvalid : state === false ? "true" : ariaInvalid === false || ariaInvalid === "false" ? "false" : void 0;
          ;
          const HAS_WINDOW_SUPPORT = typeof window !== "undefined";
          const HAS_DOCUMENT_SUPPORT = typeof document !== "undefined";
          const HAS_NAVIGATOR_SUPPORT = typeof navigator !== "undefined";
          const HAS_PROMISE_SUPPORT = typeof Promise !== "undefined";
          const IS_BROWSER = HAS_WINDOW_SUPPORT && HAS_DOCUMENT_SUPPORT && HAS_NAVIGATOR_SUPPORT;
          const WINDOW = HAS_WINDOW_SUPPORT ? window : {};
          const env_DOCUMENT = HAS_DOCUMENT_SUPPORT ? document : {};
          const HAS_PASSIVE_EVENT_SUPPORT = (() => {
            let passiveEventSupported = false;
            if (IS_BROWSER) {
              try {
                const options = {
                  get passive() {
                    return passiveEventSupported = true;
                  }
                };
                if (HAS_WINDOW_SUPPORT) {
                }
                WINDOW.addEventListener("test", options, options);
                WINDOW.removeEventListener("test", options, options);
              } catch {
                passiveEventSupported = false;
              }
            }
            return passiveEventSupported;
          })();
          ;
          const EVENT_NAME_ACTIVATE_TAB = "activate-tab";
          const EVENT_NAME_BLUR = "blur";
          const EVENT_NAME_CANCEL = "cancel";
          const EVENT_NAME_CHANGE = "change";
          const EVENT_NAME_CHANGED = "changed";
          const EVENT_NAME_CLICK = "click";
          const EVENT_NAME_CLOSE = "close";
          const EVENT_NAME_CONTEXT = "context";
          const EVENT_NAME_CONTEXT_CHANGED = "context-changed";
          const EVENT_NAME_DESTROYED = "destroyed";
          const EVENT_NAME_DISABLE = "disable";
          const EVENT_NAME_DISABLED = "disabled";
          const EVENT_NAME_DISMISSED = "dismissed";
          const EVENT_NAME_DISMISS_COUNT_DOWN = "dismiss-count-down";
          const EVENT_NAME_ENABLE = "enable";
          const EVENT_NAME_ENABLED = "enabled";
          const EVENT_NAME_FILTERED = "filtered";
          const EVENT_NAME_FIRST = "first";
          const EVENT_NAME_FOCUS = "focus";
          const EVENT_NAME_FOCUSIN = "focusin";
          const EVENT_NAME_FOCUSOUT = "focusout";
          const EVENT_NAME_HEAD_CLICKED = "head-clicked";
          const EVENT_NAME_HIDDEN = "hidden";
          const EVENT_NAME_HIDE = "hide";
          const EVENT_NAME_IMG_ERROR = "img-error";
          const EVENT_NAME_INPUT = "input";
          const EVENT_NAME_LAST = "last";
          const EVENT_NAME_MOUSEENTER = "mouseenter";
          const EVENT_NAME_MOUSELEAVE = "mouseleave";
          const EVENT_NAME_NEXT = "next";
          const EVENT_NAME_OK = "ok";
          const EVENT_NAME_OPEN = "open";
          const EVENT_NAME_PAGE_CLICK = "page-click";
          const EVENT_NAME_PAUSED = "paused";
          const EVENT_NAME_PREV = "prev";
          const EVENT_NAME_REFRESH = "refresh";
          const EVENT_NAME_REFRESHED = "refreshed";
          const EVENT_NAME_REMOVE = "remove";
          const EVENT_NAME_ROW_CLICKED = "row-clicked";
          const EVENT_NAME_ROW_CONTEXTMENU = "row-contextmenu";
          const EVENT_NAME_ROW_DBLCLICKED = "row-dblclicked";
          const EVENT_NAME_ROW_HOVERED = "row-hovered";
          const EVENT_NAME_ROW_MIDDLE_CLICKED = "row-middle-clicked";
          const EVENT_NAME_ROW_SELECTED = "row-selected";
          const EVENT_NAME_ROW_UNHOVERED = "row-unhovered";
          const EVENT_NAME_SELECTED = "selected";
          const EVENT_NAME_SHOW = "show";
          const EVENT_NAME_SHOWN = "shown";
          const EVENT_NAME_SLIDING_END = "sliding-end";
          const EVENT_NAME_SLIDING_START = "sliding-start";
          const EVENT_NAME_SORT_CHANGED = "sort-changed";
          const EVENT_NAME_TAG_STATE = "tag-state";
          const EVENT_NAME_TOGGLE = "toggle";
          const EVENT_NAME_UNPAUSED = "unpaused";
          const EVENT_NAME_UPDATE = "update";
          const HOOK_EVENT_NAME_BEFORE_DESTROY = "hook:beforeDestroy";
          const HOOK_EVENT_NAME_DESTROYED = "hook:destroyed";
          const MODEL_EVENT_NAME_PREFIX = "update:";
          const events_ROOT_EVENT_NAME_PREFIX = "fsv";
          const events_ROOT_EVENT_NAME_SEPARATOR = "::";
          const ROOT_EVENT_ACTION_SHOW_MODAL = "fsv::show::fs-modal";
          const ROOT_EVENT_ACTION_HIDE_MODAL = "fsv::hide::fs-modal";
          const ROOT_EVENT_MODAL_SHOW = "fsv::fs-modal::show";
          const ROOT_EVENT_MODAL_SHOWN = "fsv::fs-modal::shown";
          const ROOT_EVENT_MODAL_HIDE = "fsv::fs-modal::hide";
          const ROOT_EVENT_MODAL_HIDDEN = "fsv::fs-modal::hidden";
          const EVENT_OPTIONS_PASSIVE = {
            passive: true
          };
          const EVENT_OPTIONS_NO_CAPTURE = {
            passive: true,
            capture: false
          };
          ;
          const parseEventOptions = (options) => {
            if (HAS_PASSIVE_EVENT_SUPPORT) {
              return inspect_isObject(options) ? options : {
                capture: !!options || false
              };
            } else {
              return !!(inspect_isObject(options) ? options.capture : options);
            }
          };
          const eventOn = (el, eventName, handler, options) => {
            if (el && el.addEventListener) {
              el.addEventListener(eventName, handler, parseEventOptions(options));
            }
          };
          const eventOff = (el, eventName, handler, options) => {
            if (el && el.removeEventListener) {
              el.removeEventListener(eventName, handler, parseEventOptions(options));
            }
          };
          const eventOnOff = (on, el, eventName, handler, options) => {
            const method = on ? eventOn : eventOff;
            method(el, eventName, handler, options);
          };
          const getRootEventName = (name, eventName) => [ROOT_EVENT_NAME_PREFIX, getBaseEventName(name), eventName].join(ROOT_EVENT_NAME_SEPARATOR);
          const getBaseEventName = (value) => kebabCase(value.replace(RX_FSV_PREFIX, ""));
          const getRootActionEventName = (name, actionName) => [ROOT_EVENT_NAME_PREFIX, actionName, getBaseEventName(name)].join(ROOT_EVENT_NAME_SEPARATOR);
          ;
          const env_HAS_WINDOW_SUPPORT = typeof window !== "undefined";
          const env_HAS_DOCUMENT_SUPPORT = typeof document !== "undefined";
          const env_HAS_NAVIGATOR_SUPPORT = typeof navigator !== "undefined";
          const env_IS_BROWSER = env_HAS_WINDOW_SUPPORT && env_HAS_DOCUMENT_SUPPORT && env_HAS_NAVIGATOR_SUPPORT;
          ;
          const safeTypes_WINDOW = env_HAS_WINDOW_SUPPORT ? window : {};
          const safeTypes_DOCUMENT = env_HAS_DOCUMENT_SUPPORT ? document : {};
          const safeTypes_Element = env_HAS_WINDOW_SUPPORT ? window.Element : class Element extends Object {
          };
          const safeTypes_HTMLElement = env_HAS_WINDOW_SUPPORT ? window.HTMLElement : class HTMLElement extends safeTypes_Element {
          };
          const safeTypes_SVGElement = env_HAS_WINDOW_SUPPORT ? window.SVGElement : class SVGElement extends safeTypes_Element {
          };
          const File = env_HAS_WINDOW_SUPPORT ? window.File : class File extends Object {
          };
          ;
          const isElement = (el) => !!(el && el.nodeType === Node.ELEMENT_NODE);
          const getBCR = (el) => isElement(el) ? el.getBoundingClientRect() : null;
          const getActiveElement = (excludes = []) => {
            const {
              activeElement
            } = document;
            return activeElement && !excludes.some((el) => el === activeElement) ? activeElement : null;
          };
          const isActiveElement = (el) => isElement(el) && el === getActiveElement();
          const attemptFocus = (el, options = {}) => {
            try {
              el.focus(options);
            } catch (e) {
              console.error(e);
            }
            return isActiveElement(el);
          };
          const attemptBlur = (el) => {
            try {
              el.blur();
            } catch (e) {
              console.error(e);
            }
            return !isActiveElement(el);
          };
          const getStyle = (el, prop) => prop && isElement(el) ? el.getAttribute(prop) || null : null;
          const contains = (parent, child) => parent.contains(child);
          const isVisible = (el) => {
            if (getStyle(el, "display") === "none") {
              return false;
            }
            const bcr = getBCR(el);
            return !!(bcr && bcr.height > 0 && bcr.width > 0);
          };
          const isEmptySlot = (slot, data) => !slot || slot(data).filter((vnode) => vnode.type !== Comment).length < 1;
          const offset = (el) => {
            const _offset = {
              top: 0,
              left: 0
            };
            if (!isElement(el) || el.getClientRects().length === 0) {
              return _offset;
            }
            const bcr = getBCR(el);
            if (bcr) {
              const win = el.ownerDocument.defaultView;
              _offset.top = bcr.top + ((win == null ? void 0 : win.pageYOffset) || 0);
              _offset.left = bcr.left + ((win == null ? void 0 : win.pageXOffset) || 0);
            }
            return _offset;
          };
          const dom_select = (selector, root) => (isElement(root) ? root : DOCUMENT).querySelector(selector) || null;
          const selectAll = (selector, root) => Array.from([(isElement(root) ? root : DOCUMENT).querySelectorAll(selector)]);
          const getAttr = (el, attr) => attr && isElement(el) ? el.getAttribute(attr) : null;
          const setAttr = (el, attr, value) => {
            if (attr && isElement(el)) {
              el.setAttribute(attr, value);
            }
          };
          const removeAttr = (el, attr) => {
            if (attr && isElement(el)) {
              el.removeAttribute(attr);
            }
          };
          const isTag = (tag, name) => stringUtils_toString(tag).toLowerCase() === stringUtils_toString(name).toLowerCase();
          const requestAF = env_HAS_WINDOW_SUPPORT ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || ((cb) => setTimeout(cb, 16)) : (cb) => setTimeout(cb, 0);
          ;
          ;
          var useBooleanish = (el) => (0, external_vue_.computed)(() => resolveBooleanish(el.value));
          var es_array_push = __webpack_require__(7658);
          ;
          function useRootWhisperer() {
            let root = null;
            let registrar = {};
            function rootSet(proxyRoot) {
              root = proxyRoot;
            }
            ;
            function removeListeners() {
              keys(registrar || {}).forEach((event) => {
                registrar[event].forEach((callback) => {
                  listenOffRoot(event, callback);
                });
              });
              registrar = null;
            }
            ;
            function registerRootListener(event, callback) {
              if (registrar) {
                registrar[event] = registrar[event] || [];
                if (!arrayIncludes(registrar[event], callback)) {
                  registrar[event].push(callback);
                }
              }
            }
            ;
            function unregisterRootListener(event, callback) {
              if (registrar && registrar[event]) {
                registrar[event] = registrar[event].filter((cb) => cb !== callback);
              }
            }
            ;
            function listenOnRoot(event, callback) {
              if (root) {
                root.$on(event, callback);
                registerRootListener(event, callback);
              }
            }
            ;
            function listenOnRootOnce(event, callback, ...args) {
              if (root) {
                const _callback = (event2, callback2) => {
                  unregisterRootListener(event2, callback2);
                  callback2(...args);
                };
                root.$once(event, _callback);
                registerRootListener(event, _callback);
              }
            }
            ;
            function listenOffRoot(event, callback) {
              unregisterRootListener(event, callback);
              if (root) {
                root.$off(event, callback);
              }
            }
            ;
            function emitOnRoot(event, ...args) {
              if (root) {
                root.$emit(event, ...args);
              }
            }
            ;
            return {
              listenOnRoot,
              emitOnRoot,
              rootSet,
              registerRootListener,
              removeListeners
            };
          }
          ;
          function useEventListener(target, event, handler) {
            if ((0, external_vue_.isRef)(target)) {
              (0, external_vue_.watch)(target, (value, oldValue) => {
                oldValue == null ? void 0 : oldValue.removeEventListener(event, handler);
                value == null ? void 0 : value.addEventListener(event, handler);
              });
            } else {
              (0, external_vue_.onMounted)(() => {
                target.addEventListener(event, handler);
              });
            }
            (0, external_vue_.onBeforeUnmount)(() => {
              var _a;
              (_a = (0, external_vue_.unref)(target)) == null ? void 0 : _a.removeEventListener(event, handler);
            });
          }
          ;
          var useId = (id, suffix) => (0, external_vue_.computed)(() => (id == null ? void 0 : id.value) || getId(suffix));
          ;
          const COMMON_INPUT_PROPS = {
            ariaInvalid: {
              type: [Boolean, String],
              default: void 0
            },
            autocomplete: {
              type: String,
              required: false
            },
            autofocus: {
              type: Boolean,
              default: false
            },
            disabled: {
              type: Boolean,
              default: false
            },
            form: {
              type: String,
              required: false
            },
            formatter: {
              type: Function,
              required: false
            },
            id: {
              type: String,
              required: false
            },
            lazy: {
              type: Boolean,
              default: false
            },
            lazyFormatter: {
              type: Boolean,
              default: false
            },
            list: {
              type: String,
              required: false
            },
            modelValue: {
              type: [String, Number],
              default: ""
            },
            name: {
              type: String,
              required: false
            },
            number: {
              type: Boolean,
              default: false
            },
            placeholder: {
              type: String,
              required: false
            },
            plaintext: {
              type: Boolean,
              default: false
            },
            readonly: {
              type: Boolean,
              default: false
            },
            required: {
              type: Boolean,
              default: false
            },
            size: {
              type: String,
              required: false
            },
            state: {
              type: Boolean,
              default: null
            },
            trim: {
              type: Boolean,
              default: false
            }
          };
          var useFormInput = (props, emit) => {
            const input = (0, external_vue_.ref)();
            let inputValue = null;
            let neverFormatted = true;
            const computedId = useId((0, external_vue_.toRef)(props, "id"), "input");
            const _formatValue = (value, evt, force = false) => {
              value = String(value);
              if (typeof props.formatter === "function" && (!props.lazyFormatter || force)) {
                neverFormatted = false;
                return props.formatter(value, evt);
              }
              return value;
            };
            const _getModelValue = (value) => {
              if (props.trim)
                return value.trim();
              if (props.type === "number" && !isNaN(value))
                return Number.parseFloat(value);
              return value;
            };
            const handleAutofocus = () => {
              (0, external_vue_.nextTick)(() => {
                var _a;
                if (props.autofocus)
                  (_a = input.value) == null ? void 0 : _a.focus();
              });
            };
            (0, external_vue_.onMounted)(handleAutofocus);
            (0, external_vue_.onMounted)(() => {
              if (input.value) {
                input.value.value = props.modelValue;
              }
            });
            (0, external_vue_.onActivated)(handleAutofocus);
            const computedAriaInvalid = (0, external_vue_.computed)(() => {
              var _a;
              return resolveAriaInvalid(props.ariaInvalid, (_a = props.state) != null ? _a : void 0);
            });
            const onInput = (evt) => {
              const {
                value
              } = evt.target;
              const formattedValue = _formatValue(value, evt);
              if (formattedValue === false || evt.defaultPrevented) {
                evt.preventDefault();
                return;
              }
              if (props.lazy)
                return;
              const nextModel = _getModelValue(formattedValue);
              if (props.modelValue !== nextModel) {
                inputValue = value;
                emit("update:modelValue", nextModel);
              }
              emit("input", formattedValue);
            };
            const onChange = (evt) => {
              const {
                value
              } = evt.target;
              const formattedValue = _formatValue(value, evt);
              if (formattedValue === false || evt.defaultPrevented) {
                evt.preventDefault();
                return;
              }
              if (props.lazy) {
                inputValue = value;
                emit("update:modelValue", formattedValue);
              }
              emit("change", formattedValue);
            };
            const onBlur = (evt) => {
              emit("blur", evt);
              if (!props.lazy && !props.lazyFormatter)
                return;
              const {
                value
              } = evt.target;
              const formattedValue = _formatValue(value, evt, true);
              inputValue = value;
              emit("update:modelValue", formattedValue);
            };
            const focus = () => {
              var _a;
              if (!props.disabled)
                (_a = input.value) == null ? void 0 : _a.focus();
            };
            const blur = () => {
              var _a;
              if (!props.disabled) {
                (_a = input.value) == null ? void 0 : _a.blur();
              }
            };
            (0, external_vue_.watch)(() => props.modelValue, (newValue) => {
              if (!input.value)
                return;
              input.value.value = inputValue && neverFormatted ? inputValue : newValue;
              if (props.type === "number") {
                const val = input.value.value;
                input.value.value = "";
                input.value.value = val;
              }
              inputValue = null;
              neverFormatted = true;
            });
            return {
              input,
              computedId,
              computedAriaInvalid,
              onInput,
              onChange,
              onBlur,
              focus,
              blur
            };
          };
          ;
          const _getNested = (obj, path) => {
            if (!obj)
              return obj;
            if (path in obj)
              return obj[path];
            const paths = path.split(".");
            return _getNested(obj[paths[0]], paths.splice(1).join("."));
          };
          const _normalizeOption = (option, key = null, componentName, props) => {
            if (Object.prototype.toString.call(option) === "[object Object]") {
              const value = _getNested(option, props.valueField);
              const text = _getNested(option, props.textField);
              const html = _getNested(option, props.htmlField);
              const disabled = _getNested(option, props.disabledField);
              const options = option[props.optionsField] || null;
              if (options !== null) {
                return {
                  label: String(_getNested(option, props.labelField) || text),
                  options: normalizeOptions(options, componentName, props)
                };
              }
              return {
                value: typeof value === "undefined" ? key || text : value,
                text: String(typeof text === "undefined" ? key : text),
                html,
                disabled: Boolean(disabled)
              };
            }
            return {
              value: key || option,
              text: String(option),
              disabled: false
            };
          };
          const normalizeOptions = (options, componentName, props) => {
            if (Array.isArray(options)) {
              return options.map((option) => _normalizeOption(option, null, componentName, props));
            } else if (Object.prototype.toString.call(options) === "[object Object]") {
              console.warn(`[BootstrapVue warn]: ${componentName} - Setting prop "options" to an object is deprecated. Use the array format instead.`);
              return Object.keys(options).map((key) => {
                const el = options[key];
                switch (typeof el) {
                  case "object":
                    return _normalizeOption(el.text, String(el.value), componentName, props);
                  default:
                    return _normalizeOption(el, String(key), componentName, props);
                }
              });
            }
            return [];
          };
          ;
          var useDetectOutsideClick = (component, callback) => {
            if (!component)
              return;
            const listener = (event) => {
              if (event.target !== component.value && event.composedPath().includes(component.value)) {
                return;
              }
              if (typeof callback === "function") {
                callback();
              }
            };
            onMounted(() => {
              window.addEventListener("click", listener);
            });
            onBeforeUnmount(() => {
              window.removeEventListener("click", listener);
            });
            return {
              listener
            };
          };
          ;
          const directiveBus = (0, external_vue_.ref)(/* @__PURE__ */ new Map());
          function useDirectiveBus() {
            function emitToComponentById2(id, ...args) {
              directiveBus.value.set(id, args);
            }
            function removeComponentFromBusById2(id) {
              directiveBus.value.delete(id);
            }
            return {
              directiveBus,
              emitToComponentById: emitToComponentById2,
              removeComponentFromBusById: removeComponentFromBusById2
            };
          }
          ;
          const getClasses = (items) => (0, external_vue_.computed)(() => ({
            "form-check": !items.plain && !items.button,
            "form-check-inline": items.inline && !items.button,
            "form-switch": items.switch,
            [`form-control-${items.size}`]: items.size && items.size !== "md",
            [`btn-${items.buttonVariant}`]: items.button,
            [`btn-${items.size}`]: items.button && items.size && items.size !== "md",
            "btn": items.button
          }));
          const getInputClasses = (items) => (0, external_vue_.computed)(() => ({
            "form-check-input": !items.plain && !items.button,
            "is-valid": items.state === true,
            "is-invalid": items.state === false,
            "btn-check": items.button
          }));
          const getLabelClasses = (items) => (0, external_vue_.computed)(() => ({
            "form-check-label": !items.plain && !items.button
          }));
          const getGroupAttr = (items) => (0, external_vue_.computed)(() => {
            var _a;
            return {
              "aria-invalid": resolveAriaInvalid(items.ariaInvalid, items.state),
              "aria-required": ((_a = items.required) == null ? void 0 : _a.toString()) === "true" ? "true" : null
            };
          });
          const getGroupClasses = (items) => (0, external_vue_.computed)(() => ({
            "was-validated": items.validated,
            "btn-group-toggle": items.buttons,
            "btn-group": items.buttons && !items.stacked,
            "btn-group-vertical": items.stacked,
            [`btn-group-${items.size}`]: items.size
          }));
          const slotsToElements = (slots, nodeType, disabled) => slots.reduce((acc, slot) => slot.type.toString() === "Symbol(Fragment)" ? acc.concat(slot.children) : acc.concat([slot]), []).filter((e) => (e.type.__name || e.type.name) === nodeType).map((e) => {
            const txtChild = (e.children.default ? e.children.default() : []).find((e2) => e2.type.toString() === "Symbol(Text)");
            return {
              props: {
                disabled,
                ...e.props
              },
              text: txtChild ? txtChild.children : ""
            };
          });
          const optionToElement = (option, props) => {
            if (typeof option === "string") {
              return {
                props: {
                  value: option,
                  disabled: props.disabled
                },
                text: option
              };
            }
            return {
              props: {
                value: option[props.valueField],
                disabled: props.disabled || option[props.disabledField],
                ...option.props
              },
              text: option[props.textField],
              html: option[props.htmlField]
            };
          };
          const bindGroupProps = (el, idx, props, computedName, computedId) => ({
            ...el,
            props: {
              "button-variant": props.buttonVariant,
              "form": props.form,
              "name": computedName.value,
              "id": `${computedId.value}_option_${idx}`,
              "button": props.buttons,
              "state": props.state,
              "plain": props.plain,
              "size": props.size,
              "inline": !props.stacked,
              "required": props.required,
              ...el.props
            }
          });
          ;
          ;
          var fsAccordionvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsAccordion",
            props: {
              flush: {
                default: false
              },
              tag: {
                default: "div"
              },
              id: null
            },
            setup(__props) {
              const props = __props;
              const flushBoolean = useBooleanish((0, external_vue_.toRef)(props, "flush"));
              const accordionId = useId((0, external_vue_.toRef)(props, "id"));
              const computedClasses = (0, external_vue_.computed)(() => ({
                "accordion-flush": flushBoolean.value
              }));
              (0, external_vue_.provide)("accordionId", accordionId);
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(__props.tag), {
                  class: (0, external_vue_.normalizeClass)(["accordion", (0, external_vue_.unref)(computedClasses)]),
                  id: (0, external_vue_.unref)(accordionId)
                }, {
                  default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
                  _: 3
                }, 8, ["class", "id"]);
              };
            }
          });
          ;
          ;
          const __exports__ = fsAccordionvue_type_script_setup_true_lang_ts;
          var fsAccordion = __exports__;
          ;
          const _hoisted_1 = ["data-bs-target", "aria-expanded", "aria-controls"];
          var fsAccordionItemvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsAccordionItem",
            props: {
              expanded: {
                type: Boolean,
                default: false
              },
              tag: {
                default: "div"
              },
              headerTag: {
                default: "div"
              },
              header: null,
              id: null,
              collapseTag: {
                default: "div"
              },
              bodyTag: {
                default: "div"
              }
            },
            setup(__props) {
              const props = __props;
              const accordionId = (0, external_vue_.inject)("accordionId");
              const computedId = useId((0, external_vue_.toRef)(props, "id"), "collapse");
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(__props.tag), {
                  class: "accordion-item",
                  id: ""
                }, {
                  default: (0, external_vue_.withCtx)(() => [((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(__props.headerTag), {
                    class: "accordion-header",
                    id: "headingOne"
                  }, {
                    default: (0, external_vue_.withCtx)(() => [(0, external_vue_.createElementVNode)("button", {
                      class: (0, external_vue_.normalizeClass)(["accordion-button", {
                        "collapsed": !__props.expanded
                      }]),
                      type: "button",
                      "data-bs-toggle": "collapse",
                      "data-bs-target": `#${(0, external_vue_.unref)(computedId)}`,
                      "aria-expanded": __props.expanded,
                      "aria-controls": (0, external_vue_.unref)(computedId)
                    }, [(0, external_vue_.renderSlot)(_ctx.$slots, "header", {}, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(__props.header), 1)])], 10, _hoisted_1)]),
                    _: 3
                  })), ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(__props.collapseTag), {
                    id: (0, external_vue_.unref)(computedId),
                    class: (0, external_vue_.normalizeClass)(["accordion-collapse collapse", {
                      "show": __props.expanded
                    }]),
                    "aria-labelledby": "headingOne",
                    "data-bs-parent": `#${(0, external_vue_.unref)(accordionId)}`
                  }, {
                    default: (0, external_vue_.withCtx)(() => [((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(__props.bodyTag), {
                      class: "accordion-body"
                    }, {
                      default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
                      _: 3
                    }))]),
                    _: 3
                  }, 8, ["id", "class", "data-bs-parent"]))]),
                  _: 3
                });
              };
            }
          });
          ;
          ;
          const fsAccordionItem_exports_ = fsAccordionItemvue_type_script_setup_true_lang_ts;
          var fsAccordionItem = fsAccordionItem_exports_;
          ;
          const fsAlertvue_type_template_id_57193a5a_ts_true_hoisted_1 = ["aria-label", "dismiss-label", "dismissible"];
          function render(_ctx, _cache, $props, $setup, $data, $options) {
            return _ctx.isAlertVisible ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
              key: 0,
              ref: "element",
              class: (0, external_vue_.normalizeClass)(["alert", _ctx.computedClasses]),
              role: "alert"
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default"), _ctx.dismissible ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("button", {
              key: 0,
              type: "button",
              class: "btn-close",
              "data-bs-dismiss": "alert",
              "aria-label": _ctx.dismissLabel,
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.dismissClicked && _ctx.dismissClicked(...args)),
              "dismiss-label": _ctx.dismissLabel,
              dismissible: _ctx.dismissible
            }, null, 8, fsAlertvue_type_template_id_57193a5a_ts_true_hoisted_1)) : (0, external_vue_.createCommentVNode)("", true)], 2)) : (0, external_vue_.createCommentVNode)("", true);
          }
          ;
          ;
          var fsAlertvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsAlert",
            model: {
              prop: "show",
              event: "change"
            },
            props: {
              dismissLabel: {
                type: String,
                default: "Close"
              },
              dismissible: {
                type: Boolean,
                default: false
              },
              fade: {
                type: Boolean,
                default: false
              },
              show: {
                type: [Boolean, Number, String],
                default: false
              },
              modelValue: {
                type: [Boolean, Number, String],
                default: false
              },
              variant: {
                type: String,
                default: "info"
              }
            },
            emits: ["update:modelValue", "dismissed", "dismiss-count-down"],
            setup(props, context) {
              const attrs = (0, external_vue_.useAttrs)();
              let countDownTimeout;
              const countDown = (0, external_vue_.ref)(0);
              const computedValue = (0, external_vue_.computed)(() => {
                return props.modelValue.toString();
              });
              const computedClasses = (0, external_vue_.computed)(() => {
                return {
                  [`alert-${props.variant}`]: props.variant,
                  [`show`]: props.modelValue,
                  [`alert-dismissible`]: props.dismissible,
                  [`fade`]: props.modelValue
                };
              });
              const isAlertVisible = (0, external_vue_.computed)(() => {
                return props.modelValue || props.show;
              });
              (0, external_vue_.onBeforeUnmount)(() => {
                clearCountDownInterval();
              });
              (0, external_vue_.watch)(countDown, (newValue) => {
                clearCountDownInterval();
                context.emit("dismiss-count-down", newValue);
                if (newValue === 0 && props.modelValue > 0) {
                  context.emit("dismissed");
                }
                if (props.modelValue !== newValue) {
                  context.emit("update:modelValue", newValue);
                }
                if (newValue > 0) {
                  decrement();
                }
              });
              (0, external_vue_.watch)(() => props.show, () => {
                setCountDown();
              });
              (0, external_vue_.watch)(() => props.modelValue, () => {
                setCountDown();
              });
              function decrement() {
                countDownTimeout = setTimeout(() => {
                  countDown.value--;
                }, 1e3);
              }
              function dismissClicked() {
                if (typeof props.modelValue === "boolean") {
                  context.emit("update:modelValue", false);
                } else {
                  context.emit("update:modelValue", 0);
                }
                context.emit("dismissed");
              }
              function clearCountDownInterval() {
                if (countDownTimeout === void 0) {
                  return;
                }
                clearTimeout(countDownTimeout);
                countDownTimeout = void 0;
              }
              function toInteger(value, defaultValue = NaN) {
                return Number.isInteger(value) ? value : defaultValue;
              }
              function setCountDown() {
                if (typeof props.modelValue === "boolean") {
                  countDown.value = props.show;
                  return;
                }
                if (typeof props.modelValue === "number") {
                  const numberValue = toInteger(props.modelValue, 0);
                  countDown.value = numberValue > 0 ? numberValue : 0;
                  return;
                }
                if (typeof props.modelValue === "string") {
                  const numberValue = toInteger(Number(props.modelValue), 0);
                  return;
                }
              }
              setCountDown();
              return {
                isAlertVisible,
                computedClasses,
                dismissClicked,
                computedValue
              };
            }
          });
          ;
          var exportHelper = __webpack_require__(7066);
          ;
          ;
          const fsAlert_exports_ = (0, exportHelper.Z)(fsAlertvue_type_script_lang_ts, [["render", render]]);
          var fsAlert = fsAlert_exports_;
          ;
          const fsAspectvue_type_template_id_619b033c_ts_true_hoisted_1 = {
            class: "b-aspect-content flex-grow-1 w-100 mw-100",
            style: {
              "marginLeft": "-100%"
            }
          };
          function fsAspectvue_type_template_id_619b033c_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag), {
              class: "b-aspect d-flex"
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.createElementVNode)("div", {
                class: "b-aspect-sizer flex-grow-1",
                style: (0, external_vue_.normalizeStyle)(_ctx.computedStyles)
              }, null, 4), (0, external_vue_.createElementVNode)("div", fsAspectvue_type_template_id_619b033c_ts_true_hoisted_1, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")])]),
              _: 3
            });
          }
          ;
          ;
          var fsAspectvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsAspect",
            props: {
              aspect: {
                type: [Number, String],
                default: "1:1"
              },
              tag: {
                type: String,
                default: "div"
              }
            },
            setup(props) {
              const padding = (0, external_vue_.computed)(() => {
                const RX_ASPECT = /^\d+(\.\d*)?[/:]\d+(\.\d*)?$/;
                const RX_ASPECT_SEPARATOR = /[/:]/;
                const aspect = props.aspect.toString();
                let ratio = 1;
                if (RX_ASPECT.test(aspect)) {
                  const [width, height] = aspect.split(RX_ASPECT_SEPARATOR).map((v) => parseFloat(v) || 1);
                  ratio = width / height;
                } else {
                  ratio = parseFloat(aspect) || 1;
                }
                return `${100 / Math.abs(ratio)}%`;
              });
              const computedStyles = (0, external_vue_.computed)(() => {
                return {
                  paddingBottom: padding.value,
                  height: 0
                };
              });
              return {
                computedStyles
              };
            }
          });
          ;
          ;
          ;
          const fsAspect_exports_ = (0, exportHelper.Z)(fsAspectvue_type_script_lang_ts, [["render", fsAspectvue_type_template_id_619b033c_ts_true_render]]);
          var fsAspect = fsAspect_exports_;
          ;
          function fsBadgevue_type_template_id_1c763ed4_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _component_fs_router_link = (0, external_vue_.resolveComponent)("fs-router-link");
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(_component_fs_router_link, (0, external_vue_.mergeProps)({
              class: ["badge", _ctx.computedClass]
            }, _ctx.$props), {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 16, ["class"]);
          }
          ;
          ;
          function fsRouterLinkvue_type_template_id_661dc6e3_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.calculatedIs), (0, external_vue_.mergeProps)({
              tag: _ctx.tag,
              href: _ctx.href,
              to: _ctx.to,
              replace: _ctx.calculatedReplace
            }, (0, external_vue_.toHandlers)(_ctx.$attrs)), {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 16, ["tag", "href", "to", "replace"]);
          }
          ;
          ;
          var fsRouterLinkvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsRouterLink",
            props: {
              active: {
                type: Boolean,
                default: false
              },
              append: {
                type: Boolean,
                default: false
              },
              block: {
                type: Boolean,
                default: false
              },
              disabled: {
                type: Boolean,
                default: false
              },
              exact: {
                type: Boolean,
                default: false
              },
              exactPath: {
                type: Boolean,
                default: false
              },
              href: {
                type: String,
                default: null
              },
              noPrefetch: {
                type: Boolean,
                default: false
              },
              pill: {
                type: Boolean,
                default: false
              },
              prefetch: {
                type: Boolean,
                default: null
              },
              pressed: {
                type: Boolean,
                default: null
              },
              squared: {
                type: Boolean,
                default: false
              },
              tag: {
                type: String
              },
              to: {
                type: [Object, String]
              },
              replace: {
                type: Boolean,
                default: false
              }
            },
            emits: [],
            setup(props) {
              const calculatedIs = (0, external_vue_.computed)(() => {
                if (props.to) {
                  return "router-link";
                } else if (props.href) {
                  return "a";
                } else if (props.tag) {
                  return props.tag;
                } else {
                  return "a";
                }
              });
              const calculatedReplace = (0, external_vue_.computed)(() => {
                if (props.to) {
                  return props.replace;
                } else {
                  return null;
                }
              });
              return {
                calculatedIs,
                calculatedReplace
              };
            }
          });
          ;
          ;
          ;
          const fsRouterLink_exports_ = (0, exportHelper.Z)(fsRouterLinkvue_type_script_lang_ts, [["render", fsRouterLinkvue_type_template_id_661dc6e3_ts_true_render]]);
          var fsRouterLink = fsRouterLink_exports_;
          ;
          var fsBadgevue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsBadge",
            props: {
              active: {
                type: Boolean,
                default: false
              },
              activeClass: {
                type: String
              },
              append: {
                type: Boolean,
                default: false
              },
              disabled: {
                type: Boolean,
                default: false
              },
              exact: {
                type: Boolean,
                default: false
              },
              exactActiveClass: {
                type: String
              },
              exactPath: {
                type: Boolean,
                default: false
              },
              exactPathActiveClass: {
                type: String
              },
              href: {
                type: String
              },
              noPrefetch: {
                type: Boolean,
                default: false
              },
              pill: {
                type: Boolean,
                default: false
              },
              prefetch: {
                type: Boolean,
                default: null
              },
              rel: {
                type: String,
                default: null
              },
              replace: {
                type: Boolean,
                default: false
              },
              routerComponentName: {
                type: String
              },
              tag: {
                type: String,
                default: "span"
              },
              target: {
                type: String,
                default: "_self"
              },
              to: {
                type: [Object, String]
              },
              variant: {
                type: String,
                default: "secondary"
              }
            },
            components: {
              FsRouterLink: fsRouterLink
            },
            setup(props) {
              const computedClass = (0, external_vue_.computed)(() => {
                return {
                  [`disabled`]: props.disabled,
                  [`rounded-pill`]: props.pill,
                  [`text-bg-${props.variant}`]: props.variant
                };
              });
              return {
                computedClass
              };
            }
          });
          ;
          ;
          ;
          const fsBadge_exports_ = (0, exportHelper.Z)(fsBadgevue_type_script_lang_ts, [["render", fsBadgevue_type_template_id_1c763ed4_ts_true_render]]);
          var fsBadge = fsBadge_exports_;
          ;
          function fsButtonvue_type_template_id_0898b14e_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _component_fs_router_link = (0, external_vue_.resolveComponent)("fs-router-link");
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(_component_fs_router_link, {
              class: (0, external_vue_.normalizeClass)(["btn", _ctx.computedClass]),
              onClick: _ctx.clicked,
              onBlur: _ctx.blur,
              onContextmenu: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("contextmenu", $event)),
              active: _ctx.active,
              "active-class": _ctx.activeClass,
              append: _ctx.append,
              block: _ctx.block,
              disabled: _ctx.disabled,
              exact: _ctx.exact,
              "exact-active-class": _ctx.exactActiveClass,
              "exact-path": _ctx.exactPath,
              "exact-path-active-class": _ctx.exactPathActiveClass,
              href: _ctx.configuredHref,
              "no-prefetch": _ctx.noPrefetch,
              pill: _ctx.pill,
              prefetch: _ctx.prefetch,
              pressed: _ctx.pressed,
              rel: _ctx.rel,
              replace: _ctx.replace,
              "router-component-name": _ctx.routerComponentName,
              size: _ctx.size,
              squared: _ctx.squared,
              tag: _ctx.tag,
              target: _ctx.target,
              to: _ctx.to,
              type: _ctx.type,
              variant: "btn-" + _ctx.variant,
              "aria-pressed": _ctx.pressed
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 8, ["class", "onClick", "onBlur", "active", "active-class", "append", "block", "disabled", "exact", "exact-active-class", "exact-path", "exact-path-active-class", "href", "no-prefetch", "pill", "prefetch", "pressed", "rel", "replace", "router-component-name", "size", "squared", "tag", "target", "to", "type", "variant", "aria-pressed"]);
          }
          ;
          ;
          var configureHref = (to, href, append, instance) => (0, external_vue_.computed)(() => {
            if (to) {
              const resolved = instance.proxy.$router.resolve(to);
              return resolved.href;
            } else if (href) {
              return append ? `${instance.proxy.$route.path}/${href}` : `${href}`;
            } else {
              return void 0;
            }
          });
          ;
          var fsButtonvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsButton",
            props: {
              active: {
                type: Boolean,
                default: false
              },
              activeClass: {
                type: String,
                default: "active"
              },
              append: {
                type: Boolean,
                default: false
              },
              block: {
                type: Boolean,
                default: false
              },
              disabled: {
                type: Boolean,
                default: false
              },
              exact: {
                type: Boolean,
                default: false
              },
              exactActiveClass: {
                type: String
              },
              exactPath: {
                type: Boolean,
                default: false
              },
              exactPathActiveClass: {
                type: String
              },
              href: {
                type: String
              },
              noPrefetch: {
                type: Boolean,
                default: false
              },
              pill: {
                type: Boolean,
                default: false
              },
              prefetch: {
                type: Boolean,
                default: null
              },
              pressed: {
                type: Boolean,
                default: null
              },
              rel: {
                type: String,
                default: null
              },
              replace: {
                type: Boolean,
                default: false
              },
              routerComponentName: {
                type: String
              },
              size: {
                type: String
              },
              squared: {
                type: Boolean,
                default: false
              },
              tag: {
                type: String,
                default: "button"
              },
              target: {
                type: String,
                default: "_self"
              },
              to: {
                type: [Object, String]
              },
              type: {
                type: String,
                default: "button"
              },
              variant: {
                type: String,
                default: "secondary"
              }
            },
            components: {
              FsRouterLink: fsRouterLink
            },
            emits: ["click", "blur", "update:pressed", "contextmenu"],
            setup(props, {
              emit
            }) {
              const instance = (0, external_vue_.getCurrentInstance)();
              const computedClass = (0, external_vue_.computed)(() => {
                return {
                  [`${props.activeClass}`]: props.active || props.pressed,
                  [`btn-block`]: props.block,
                  [`disabled`]: props.disabled,
                  [`rounded-pill`]: props.pill,
                  [`btn-${props.size}`]: props.size,
                  [`rounded-0`]: props.squared,
                  [`btn-${props.variant}`]: props.variant
                };
              });
              const isToggle = (0, external_vue_.computed)(() => {
                return props.pressed !== null;
              });
              function blur(e) {
                emit("blur", e);
              }
              function clicked(e) {
                if (props.disabled) {
                  e.preventDefault();
                  e.stopPropagation();
                  return;
                }
                emit("click", e);
                if (isToggle) {
                  emit("update:pressed", !props.pressed);
                }
              }
              const configuredHref = configureHref(props.to, props.href, props.append, instance);
              return {
                clicked,
                blur,
                configuredHref,
                computedClass
              };
            }
          });
          ;
          ;
          ;
          const fsButton_exports_ = (0, exportHelper.Z)(fsButtonvue_type_script_lang_ts, [["render", fsButtonvue_type_template_id_0898b14e_ts_true_render]]);
          var fsButton = fsButton_exports_;
          ;
          function fsButtonGroupvue_type_template_id_aa344c1a_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag), {
              role: _ctx.ariaRole,
              class: (0, external_vue_.normalizeClass)(_ctx.computedClass)
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 8, ["role", "class"]);
          }
          ;
          ;
          var fsButtonGroupvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsButtonGroup",
            props: {
              ariaRole: {
                type: String,
                default: "group"
              },
              size: {
                type: String
              },
              tag: {
                type: String,
                default: "div"
              },
              vertical: {
                type: Boolean,
                default: false
              }
            },
            emits: [],
            setup(props) {
              const computedClass = (0, external_vue_.computed)(() => {
                return {
                  ["btn-group"]: !props.vertical,
                  [`btn-group-${props.size}`]: props.size,
                  [`btn-group-vertical`]: props.vertical
                };
              });
              return {
                computedClass
              };
            }
          });
          ;
          ;
          ;
          const fsButtonGroup_exports_ = (0, exportHelper.Z)(fsButtonGroupvue_type_script_lang_ts, [["render", fsButtonGroupvue_type_template_id_aa344c1a_ts_true_render]]);
          var fsButtonGroup = fsButtonGroup_exports_;
          ;
          const fsCardvue_type_template_id_735b5698_ts_true_hoisted_1 = ["alt", "src", "height", "width"];
          const _hoisted_2 = ["innerHTML"];
          const _hoisted_3 = ["innerHTML"];
          const _hoisted_4 = ["alt", "src", "height", "width"];
          function fsCardvue_type_template_id_735b5698_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag), {
              class: (0, external_vue_.normalizeClass)(["card", _ctx.finalClass]),
              onClick: _ctx.clicked
            }, {
              default: (0, external_vue_.withCtx)(() => [_ctx.imgSrc && !_ctx.imgBottom ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("img", {
                key: 0,
                alt: _ctx.imgAlt,
                src: _ctx.imgSrc,
                height: _ctx.imgHeight,
                width: _ctx.imgWidth,
                class: (0, external_vue_.normalizeClass)(_ctx.finalImgClass)
              }, null, 10, fsCardvue_type_template_id_735b5698_ts_true_hoisted_1)) : (0, external_vue_.createCommentVNode)("", true), _ctx.header || _ctx.headerHtml || _ctx.hasHeader ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.headerTag), {
                key: 1,
                class: (0, external_vue_.normalizeClass)(["card-header", [_ctx.headerClass, _ctx.finalHeaderClass]])
              }, {
                default: (0, external_vue_.withCtx)(() => [!!_ctx.headerHtml ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                  key: 0,
                  innerHTML: _ctx.headerHtml
                }, null, 8, _hoisted_2)) : (0, external_vue_.renderSlot)(_ctx.$slots, "header", {
                  key: 1
                }, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.header), 1)])]),
                _: 3
              }, 8, ["class"])) : (0, external_vue_.createCommentVNode)("", true), !_ctx.noBody ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.bodyTag), {
                key: 2,
                class: (0, external_vue_.normalizeClass)(["card-body", [_ctx.bodyClass, _ctx.finalBodyClass]])
              }, {
                default: (0, external_vue_.withCtx)(() => [_ctx.title && !_ctx.noBody ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.titleTag), {
                  key: 0,
                  class: "card-title"
                }, {
                  default: (0, external_vue_.withCtx)(() => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.title), 1)]),
                  _: 1
                })) : (0, external_vue_.createCommentVNode)("", true), _ctx.subTitle && !_ctx.noBody ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.subTitleTag), {
                  key: 1,
                  class: (0, external_vue_.normalizeClass)(["card-subtitle mb-2", _ctx.finalSubTitleClass])
                }, {
                  default: (0, external_vue_.withCtx)(() => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.subTitle), 1)]),
                  _: 1
                }, 8, ["class"])) : (0, external_vue_.createCommentVNode)("", true), (0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
                _: 3
              }, 8, ["class"])) : (0, external_vue_.createCommentVNode)("", true), _ctx.noBody ? (0, external_vue_.renderSlot)(_ctx.$slots, "default", {
                key: 3
              }) : (0, external_vue_.createCommentVNode)("", true), _ctx.footer || _ctx.footerHtml || _ctx.hasFooter ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.footerTag), {
                key: 4,
                class: (0, external_vue_.normalizeClass)(["card-footer", [_ctx.footerClass, _ctx.finalFooterClass]])
              }, {
                default: (0, external_vue_.withCtx)(() => [!!_ctx.footerHtml ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                  key: 0,
                  innerHTML: _ctx.footerHtml
                }, null, 8, _hoisted_3)) : (0, external_vue_.renderSlot)(_ctx.$slots, "footer", {
                  key: 1
                }, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.footer), 1)])]),
                _: 3
              }, 8, ["class"])) : (0, external_vue_.createCommentVNode)("", true), _ctx.imgSrc && _ctx.imgBottom ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("img", {
                key: 5,
                class: (0, external_vue_.normalizeClass)(_ctx.finalImgClass),
                alt: _ctx.imgAlt,
                src: _ctx.imgSrc,
                height: _ctx.imgHeight,
                width: _ctx.imgWidth
              }, null, 10, _hoisted_4)) : (0, external_vue_.createCommentVNode)("", true)]),
              _: 3
            }, 8, ["class", "onClick"]);
          }
          ;
          ;
          var fsCardvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsCard",
            props: {
              align: {
                type: String
              },
              bgVariant: {
                type: String
              },
              bodyBgVariant: {
                type: String
              },
              bodyBorderVariant: {
                type: String
              },
              bodyClass: {
                type: [Array, Object, String]
              },
              bodyTag: {
                type: String,
                default: "div"
              },
              bodyTextVariant: {
                type: String
              },
              borderVariant: {
                type: String
              },
              footer: {
                type: String
              },
              footerBgVariant: {
                type: String
              },
              footerBorderVariant: {
                type: String
              },
              footerClass: {
                type: [Array, Object, String]
              },
              footerHtml: {
                type: String
              },
              footerTag: {
                type: String,
                default: "div"
              },
              footerTextVariant: {
                type: String
              },
              header: {
                type: String
              },
              headerBgVariant: {
                type: String
              },
              headerBorderVariant: {
                type: String
              },
              headerClass: {
                type: [Array, Object, String]
              },
              headerHtml: {
                type: String
              },
              headerTag: {
                type: String,
                default: "div"
              },
              headerTextVariant: {
                type: String
              },
              imgAlt: {
                type: String
              },
              imgBottom: {
                type: Boolean,
                default: false
              },
              imgEnd: {
                type: Boolean,
                default: false
              },
              imgHeight: {
                type: Number
              },
              imgLeft: {
                type: Boolean,
                default: false
              },
              imgRight: {
                type: Boolean,
                default: false
              },
              imgSrc: {
                type: String
              },
              imgStart: {
                type: Boolean,
                default: false
              },
              imgTop: {
                type: Boolean,
                default: false
              },
              imgWidth: {
                type: Number
              },
              noBody: {
                type: Boolean,
                default: false
              },
              overlay: {
                type: Boolean,
                default: false
              },
              subTitle: {
                type: String
              },
              subTitleTag: {
                type: String,
                default: "h6"
              },
              subTitleTextVariant: {
                type: String,
                default: "muted"
              },
              tag: {
                type: String,
                default: "div"
              },
              textVariant: {
                type: String
              },
              title: {
                type: String
              },
              titleTag: {
                type: String,
                default: "h4"
              }
            },
            emits: ["click"],
            setup(props, {
              slots,
              emit
            }) {
              const hasFooter = (0, external_vue_.ref)(false);
              const hasHeader = (0, external_vue_.ref)(false);
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  ["text-" + props.align]: props.align,
                  ["bg-" + props.bgVariant]: props.bgVariant,
                  ["text-" + props.textVariant]: props.textVariant,
                  ["border-" + props.borderVariant]: props.borderVariant,
                  "flex-row-reverse": props.imgEnd || props.imgRight,
                  "flex-row": props.imgLeft || props.imgStart
                };
              });
              const finalBodyClass = (0, external_vue_.computed)(() => {
                return {
                  ["bg-" + props.bodyBgVariant]: props.bodyBgVariant,
                  ["border-" + props.bodyBorderVariant]: props.bodyBorderVariant,
                  ["text-" + props.bodyTextVariant]: props.bodyTextVariant,
                  "card-img-overlay": props.overlay
                };
              });
              const finalFooterClass = (0, external_vue_.computed)(() => {
                return {
                  ["bg-" + props.footerBgVariant]: props.footerBgVariant,
                  ["border-" + props.footerBorderVariant]: props.footerBorderVariant,
                  ["text-" + props.footerTextVariant]: props.footerTextVariant
                };
              });
              const finalHeaderClass = (0, external_vue_.computed)(() => {
                return {
                  ["bg-" + props.headerBgVariant]: props.headerBgVariant,
                  ["border-" + props.headerBorderVariant]: props.headerBorderVariant,
                  ["text-" + props.headerTextVariant]: props.headerTextVariant
                };
              });
              const finalImgClass = (0, external_vue_.computed)(() => {
                return {
                  "card-img": !props.imgEnd && !props.imgRight && !props.imgStart && !props.imgLeft && !props.imgTop,
                  "card-img-bottom": props.imgBottom,
                  "card-img-right": props.imgEnd || props.imgRight,
                  "card-img-left": props.imgLeft || props.imgStart,
                  "card-img-top": props.imgTop
                };
              });
              const finalSubTitleClass = (0, external_vue_.computed)(() => {
                return {
                  ["text-" + props.subTitleTextVariant]: props.subTitleTextVariant
                };
              });
              if (slots.footer && slots.footer().length) {
                hasFooter.value = true;
              }
              if (slots.header && slots.header().length) {
                hasHeader.value = true;
              }
              function clicked(...args) {
                emit("click", args);
              }
              return {
                finalClass,
                finalBodyClass,
                finalFooterClass,
                finalHeaderClass,
                finalImgClass,
                finalSubTitleClass,
                hasHeader,
                hasFooter,
                clicked
              };
            }
          });
          ;
          ;
          ;
          const fsCard_exports_ = (0, exportHelper.Z)(fsCardvue_type_script_lang_ts, [["render", fsCardvue_type_template_id_735b5698_ts_true_render]]);
          var fsCard = fsCard_exports_;
          ;
          function fsCardBodyvue_type_template_id_ac6f501a_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _component_fs_card_title = (0, external_vue_.resolveComponent)("fs-card-title");
            const _component_fs_card_sub_title = (0, external_vue_.resolveComponent)("fs-card-sub-title");
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.bodyTag), {
              class: (0, external_vue_.normalizeClass)(["card-body", _ctx.finalClass])
            }, {
              default: (0, external_vue_.withCtx)(() => [_ctx.title ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(_component_fs_card_title, {
                key: 0,
                "title-tag": _ctx.titleTag,
                title: _ctx.title
              }, null, 8, ["title-tag", "title"])) : (0, external_vue_.createCommentVNode)("", true), _ctx.subTitle ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(_component_fs_card_sub_title, {
                key: 1,
                "sub-title-tag": _ctx.subTitleTag,
                "sub-title": _ctx.subTitle,
                "sub-title-text-variant": _ctx.subTitleTextVariant
              }, null, 8, ["sub-title-tag", "sub-title", "sub-title-text-variant"])) : (0, external_vue_.createCommentVNode)("", true), (0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 8, ["class"]);
          }
          ;
          ;
          function fsCardTitlevue_type_template_id_a1a42786_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.titleTag), {
              class: "card-title"
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default", {}, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.title), 1)])]),
              _: 3
            });
          }
          ;
          ;
          var fsCardTitlevue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsCardTitle",
            props: {
              title: {
                type: String
              },
              titleTag: {
                type: String,
                default: "h4"
              }
            }
          });
          ;
          ;
          ;
          const fsCardTitle_exports_ = (0, exportHelper.Z)(fsCardTitlevue_type_script_lang_ts, [["render", fsCardTitlevue_type_template_id_a1a42786_ts_true_render]]);
          var fsCardTitle = fsCardTitle_exports_;
          ;
          function fsCardSubTitlevue_type_template_id_04c1d1dc_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.subTitleTag), {
              class: (0, external_vue_.normalizeClass)(["card-subtitle mb-2", _ctx.finalClass])
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default", {}, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.subTitle), 1)])]),
              _: 3
            }, 8, ["class"]);
          }
          ;
          ;
          var fsCardSubTitlevue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsCardSubTitle",
            props: {
              subTitle: {
                type: String
              },
              subTitleTag: {
                type: String,
                default: "h6"
              },
              subTitleTextVariant: {
                type: String,
                default: "muted"
              }
            },
            setup(props) {
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  ["text-" + props.subTitleTextVariant]: props.subTitleTextVariant
                };
              });
              return {
                finalClass
              };
            }
          });
          ;
          ;
          ;
          const fsCardSubTitle_exports_ = (0, exportHelper.Z)(fsCardSubTitlevue_type_script_lang_ts, [["render", fsCardSubTitlevue_type_template_id_04c1d1dc_ts_true_render]]);
          var fsCardSubTitle = fsCardSubTitle_exports_;
          ;
          var fsCardBodyvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsCardBody",
            props: {
              bodyBgVariant: {
                type: String
              },
              bodyBorderVariant: {
                type: String
              },
              bodyClass: {
                type: [Array, Object, String]
              },
              bodyTag: {
                type: String,
                default: "div"
              },
              bodyTextVariant: {
                type: String
              },
              overlay: {
                type: Boolean,
                default: false
              },
              subTitle: {
                type: String
              },
              subTitleTag: {
                type: String,
                default: "h6"
              },
              subTitleTextVariant: {
                type: String,
                default: "muted"
              },
              title: {
                type: String
              },
              titleTag: {
                type: String,
                default: "h4"
              }
            },
            components: {
              FsCardTitle: fsCardTitle,
              FsCardSubTitle: fsCardSubTitle
            },
            setup(props) {
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  ["text-" + props.bodyTextVariant]: props.bodyTextVariant,
                  ["bg-" + props.bodyBgVariant]: props.bodyBgVariant
                };
              });
              return {
                finalClass
              };
            }
          });
          ;
          ;
          ;
          const fsCardBody_exports_ = (0, exportHelper.Z)(fsCardBodyvue_type_script_lang_ts, [["render", fsCardBodyvue_type_template_id_ac6f501a_ts_true_render]]);
          var fsCardBody = fsCardBody_exports_;
          ;
          const fsCardFootervue_type_template_id_52380b81_ts_true_hoisted_1 = ["innerHTML"];
          function fsCardFootervue_type_template_id_52380b81_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.footerTag), {
              class: (0, external_vue_.normalizeClass)(["card-footer", [_ctx.footerClass, _ctx.finalClass]])
            }, {
              default: (0, external_vue_.withCtx)(() => [!!_ctx.footerHtml ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                key: 0,
                innerHTML: _ctx.footerHtml
              }, null, 8, fsCardFootervue_type_template_id_52380b81_ts_true_hoisted_1)) : (0, external_vue_.renderSlot)(_ctx.$slots, "default", {
                key: 1
              }, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.footer), 1)])]),
              _: 3
            }, 8, ["class"]);
          }
          ;
          ;
          var fsCardFootervue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsCardFooter",
            props: {
              footer: {
                type: String
              },
              footerBgVariant: {
                type: String
              },
              footerBorderVariant: {
                type: String
              },
              footerClass: {
                type: [Array, Object, String]
              },
              footerHtml: {
                type: String
              },
              footerTag: {
                type: String,
                default: "div"
              },
              footerTextVariant: {
                type: String
              }
            },
            setup(props) {
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  ["text-" + props.footerTextVariant]: props.footerTextVariant,
                  ["bg-" + props.footerBgVariant]: props.footerBgVariant,
                  ["border-" + props.footerBorderVariant]: props.footerBorderVariant
                };
              });
              return {
                finalClass
              };
            }
          });
          ;
          ;
          ;
          const fsCardFooter_exports_ = (0, exportHelper.Z)(fsCardFootervue_type_script_lang_ts, [["render", fsCardFootervue_type_template_id_52380b81_ts_true_render]]);
          var fsCardFooter = fsCardFooter_exports_;
          ;
          function fsCardGroupvue_type_template_id_73eb26af_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag), {
              class: (0, external_vue_.normalizeClass)(_ctx.finalClass)
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 8, ["class"]);
          }
          ;
          ;
          var fsCardGroupvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsCardGroup",
            props: {
              columns: {
                type: Boolean,
                default: false
              },
              deck: {
                type: Boolean,
                default: false
              },
              tag: {
                type: String,
                default: "div"
              }
            },
            setup(props) {
              const finalClass = (0, external_vue_.computed)(() => {
                return props.deck ? "card-deck" : props.columns ? "card-columns" : "card-group";
              });
              return {
                finalClass
              };
            }
          });
          ;
          ;
          ;
          const fsCardGroup_exports_ = (0, exportHelper.Z)(fsCardGroupvue_type_script_lang_ts, [["render", fsCardGroupvue_type_template_id_73eb26af_ts_true_render]]);
          var fsCardGroup = fsCardGroup_exports_;
          ;
          const fsCardHeadervue_type_template_id_4b9ee9d9_ts_true_hoisted_1 = ["innerHTML"];
          function fsCardHeadervue_type_template_id_4b9ee9d9_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.headerTag), {
              class: (0, external_vue_.normalizeClass)(["card-header", [_ctx.headerClass, _ctx.finalClass]]),
              onClick: _ctx.clicked
            }, {
              default: (0, external_vue_.withCtx)(() => [!!_ctx.headerHtml ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                key: 0,
                innerHTML: _ctx.headerHtml
              }, null, 8, fsCardHeadervue_type_template_id_4b9ee9d9_ts_true_hoisted_1)) : (0, external_vue_.renderSlot)(_ctx.$slots, "default", {
                key: 1
              }, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.header), 1)])]),
              _: 3
            }, 8, ["class", "onClick"]);
          }
          ;
          ;
          var fsCardHeadervue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsCardHeader",
            props: {
              header: {
                type: String
              },
              headerBgVariant: {
                type: String
              },
              headerBorderVariant: {
                type: String
              },
              headerClass: {
                type: [Array, Object, String]
              },
              headerHtml: {
                type: String
              },
              headerTag: {
                type: String,
                default: "div"
              },
              headerTextVariant: {
                type: String
              }
            },
            emits: ["click"],
            setup(props, {
              emit
            }) {
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  ["text-" + props.headerTextVariant]: props.headerTextVariant,
                  ["bg-" + props.headerBgVariant]: props.headerBgVariant,
                  ["border-" + props.headerBorderVariant]: props.headerBorderVariant
                };
              });
              function clicked(...args) {
                emit("click", args);
              }
              return {
                finalClass,
                clicked
              };
            }
          });
          ;
          ;
          ;
          const fsCardHeader_exports_ = (0, exportHelper.Z)(fsCardHeadervue_type_script_lang_ts, [["render", fsCardHeadervue_type_template_id_4b9ee9d9_ts_true_render]]);
          var fsCardHeader = fsCardHeader_exports_;
          ;
          const fsCardImgvue_type_template_id_0f5543b4_ts_true_hoisted_1 = ["src", "alt", "width", "height"];
          function fsCardImgvue_type_template_id_0f5543b4_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("img", {
              class: (0, external_vue_.normalizeClass)(_ctx.finalClass),
              src: _ctx.src,
              alt: _ctx.alt,
              width: _ctx.getWidth,
              height: _ctx.getHeight
            }, null, 10, fsCardImgvue_type_template_id_0f5543b4_ts_true_hoisted_1);
          }
          ;
          ;
          var fsCardImgvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsCardImg",
            props: {
              alt: {
                type: String
              },
              bottom: {
                type: Boolean,
                default: false
              },
              end: {
                type: Boolean,
                default: false
              },
              height: {
                type: [Number, String]
              },
              left: {
                type: Boolean,
                default: false
              },
              right: {
                type: Boolean,
                default: false
              },
              src: {
                type: String
              },
              start: {
                type: Boolean,
                default: false
              },
              top: {
                type: Boolean,
                default: false
              },
              width: {
                type: [Number, String]
              }
            },
            setup(props) {
              const getWidth = (0, external_vue_.computed)(() => {
                return (typeof props.width === "number" ? props.width : parseInt(props.width, 10)) || void 0;
              });
              const getHeight = (0, external_vue_.computed)(() => {
                return (typeof props.height === "number" ? props.height : parseInt(props.height, 10)) || void 0;
              });
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  "float-left": props.left,
                  "float-right": props.right,
                  "card-img-top": props.top,
                  "card-img-right": props.right || props.end,
                  "card-img-bottom": props.bottom,
                  "card-img-left": props.left || props.start,
                  "card-img": !props.top && !props.right && !props.end && !props.bottom && !props.left && !props.start
                };
              });
              return {
                finalClass,
                getWidth,
                getHeight
              };
            }
          });
          ;
          ;
          ;
          const fsCardImg_exports_ = (0, exportHelper.Z)(fsCardImgvue_type_script_lang_ts, [["render", fsCardImgvue_type_template_id_0f5543b4_ts_true_render]]);
          var fsCardImg = fsCardImg_exports_;
          ;
          function fsCardTextvue_type_template_id_7bfb383a_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.textTag), {
              class: "card-text"
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            });
          }
          ;
          ;
          var fsCardTextvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsCardText",
            props: {
              textTag: {
                type: String,
                default: "p"
              }
            }
          });
          ;
          ;
          ;
          const fsCardText_exports_ = (0, exportHelper.Z)(fsCardTextvue_type_script_lang_ts, [["render", fsCardTextvue_type_template_id_7bfb383a_ts_true_render]]);
          var fsCardText = fsCardText_exports_;
          ;
          function fsColvue_type_template_id_29c53652_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag), {
              class: (0, external_vue_.normalizeClass)(_ctx.computedClasses)
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 8, ["class"]);
          }
          ;
          ;
          var fsColvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsCol",
            props: {
              alignSelf: {
                type: String,
                default: null
              },
              col: {
                type: Boolean,
                default: false
              },
              cols: {
                type: [Number, String]
              },
              lg: {
                type: [Boolean, Number, String]
              },
              md: {
                type: [Boolean, Number, String]
              },
              offset: {
                type: [Number, String]
              },
              offsetLg: {
                type: [Number, String]
              },
              offsetMd: {
                type: [Number, String]
              },
              offsetSm: {
                type: [Number, String]
              },
              offsetXl: {
                type: [Number, String]
              },
              order: {
                type: [Number, String]
              },
              orderLg: {
                type: [Number, String]
              },
              orderMd: {
                type: [Number, String]
              },
              orderSm: {
                type: [Number, String]
              },
              orderXl: {
                type: [Number, String]
              },
              sm: {
                type: [Boolean, Number, String]
              },
              tag: {
                type: String,
                default: "div"
              },
              xl: {
                type: [Boolean, Number, String]
              }
            },
            emits: [],
            setup(props) {
              const hasColBreakpoint = (0, external_vue_.computed)(() => {
                return !!(props.cols || props.sm || props.md || props.lg || props.lg);
              });
              const computedClasses = (0, external_vue_.computed)(() => {
                return {
                  "col": !hasColBreakpoint.value || props.col,
                  [`col-${props.cols}`]: !!props.cols && typeof props.cols !== "boolean",
                  [`col-sm-${props.sm}`]: !!props.sm && typeof props.sm !== "boolean",
                  [`col-md-${props.md}`]: !!props.md && typeof props.md !== "boolean",
                  [`col-lg-${props.lg}`]: !!props.lg && typeof props.lg !== "boolean",
                  [`col-xl-${props.xl}`]: !!props.xl && typeof props.xl !== "boolean",
                  "col-sm": !!props.sm && typeof props.sm === "boolean",
                  "col-md": !!props.md && typeof props.md === "boolean",
                  "col-lg": !!props.lg && typeof props.lg === "boolean",
                  "col-xl": !!props.xl && typeof props.xl === "boolean",
                  [`offset-${props.offset}`]: !!props.offset,
                  [`offset-sm-${props.offsetSm}`]: !!props.offsetSm,
                  [`offset-md-${props.offsetMd}`]: !!props.offsetMd,
                  [`offset-lg-${props.offsetLg}`]: !!props.offsetLg,
                  [`offset-xl-${props.offsetXl}`]: !!props.offsetXl,
                  [`order-${props.order}`]: !!props.order,
                  [`order-sm-${props.orderSm}`]: !!props.orderSm,
                  [`order-md-${props.orderMd}`]: !!props.orderMd,
                  [`order-lg-${props.orderLg}`]: !!props.orderLg,
                  [`order-xl-${props.orderXl}`]: !!props.orderXl,
                  [`align-self-${props.alignSelf}`]: !!props.alignSelf
                };
              });
              return {
                computedClasses
              };
            }
          });
          ;
          ;
          ;
          const fsCol_exports_ = (0, exportHelper.Z)(fsColvue_type_script_lang_ts, [["render", fsColvue_type_template_id_29c53652_ts_true_render]]);
          var fsCol = fsCol_exports_;
          var external_bootstrap_ = __webpack_require__(988);
          ;
          var fsCollapsevue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsCollapse",
            props: {
              accordion: null,
              id: null,
              modelValue: {
                default: false
              },
              tag: {
                default: "div"
              },
              toggle: {
                default: false
              },
              visible: {
                default: false
              },
              isNav: {
                default: false
              }
            },
            emits: ["update:modelValue", "show", "shown", "hide", "hidden"],
            setup(__props, {
              emit
            }) {
              const props = __props;
              const modelValueBoolean = useBooleanish((0, external_vue_.toRef)(props, "modelValue"));
              const toggleBoolean = useBooleanish((0, external_vue_.toRef)(props, "toggle"));
              const visibleBoolean = useBooleanish((0, external_vue_.toRef)(props, "visible"));
              const isNavBoolean = useBooleanish((0, external_vue_.toRef)(props, "isNav"));
              const computedId = useId((0, external_vue_.toRef)(props, "id"), "collapse");
              const element = (0, external_vue_.ref)();
              const instance = (0, external_vue_.ref)();
              const computedClasses = (0, external_vue_.computed)(() => ({
                "show": modelValueBoolean.value,
                "navbar-collapse": isNavBoolean.value
              }));
              const close = () => emit("update:modelValue", false);
              useEventListener(element, "show.bs.collapse", () => {
                emit("show");
                emit("update:modelValue", true);
              });
              useEventListener(element, "hide.bs.collapse", () => {
                emit("hide");
                emit("update:modelValue", false);
              });
              useEventListener(element, "shown.bs.collapse", () => emit("shown"));
              useEventListener(element, "hidden.bs.collapse", () => emit("hidden"));
              (0, external_vue_.onMounted)(() => {
                var _a;
                instance.value = new external_bootstrap_.Collapse(element.value, {
                  parent: props.accordion ? `#${props.accordion}` : void 0,
                  toggle: toggleBoolean.value
                });
                if (visibleBoolean.value || modelValueBoolean.value) {
                  emit("update:modelValue", true);
                  (_a = instance.value) == null ? void 0 : _a.show();
                }
              });
              (0, external_vue_.watch)(modelValueBoolean, (value) => {
                var _a, _b;
                value ? (_a = instance.value) == null ? void 0 : _a.show() : (_b = instance.value) == null ? void 0 : _b.hide();
              });
              (0, external_vue_.watch)(visibleBoolean, (value) => {
                var _a, _b;
                if (value) {
                  emit("update:modelValue", !!value);
                  (_a = instance.value) == null ? void 0 : _a.show();
                } else {
                  emit("update:modelValue", !!value);
                  (_b = instance.value) == null ? void 0 : _b.hide();
                }
              });
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(__props.tag), {
                  id: (0, external_vue_.unref)(computedId),
                  ref_key: "element",
                  ref: element,
                  class: (0, external_vue_.normalizeClass)(["collapse", (0, external_vue_.unref)(computedClasses)]),
                  "data-bs-parent": __props.accordion || null,
                  "is-nav": (0, external_vue_.unref)(isNavBoolean)
                }, {
                  default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default", {
                    visible: (0, external_vue_.unref)(modelValueBoolean),
                    close
                  })]),
                  _: 3
                }, 8, ["id", "class", "data-bs-parent", "is-nav"]);
              };
            }
          });
          ;
          ;
          const fsCollapse_exports_ = fsCollapsevue_type_script_setup_true_lang_ts;
          var fsCollapse = fsCollapse_exports_;
          ;
          function fsContainervue_type_template_id_65ab5e51_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag), {
              class: (0, external_vue_.normalizeClass)(_ctx.fluid ? "container-fluid" : "container")
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 8, ["class"]);
          }
          ;
          ;
          var fsContainervue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsContainer",
            props: {
              fluid: {
                type: Boolean,
                default: false
              },
              tag: {
                type: String,
                default: "div"
              },
              propA: Number,
              propB: {
                type: String,
                default: "default value"
              },
              propC: {
                type: [String, Boolean]
              }
            },
            emits: []
          });
          ;
          ;
          ;
          const fsContainer_exports_ = (0, exportHelper.Z)(fsContainervue_type_script_lang_ts, [["render", fsContainervue_type_template_id_65ab5e51_ts_true_render]]);
          var fsContainer = fsContainer_exports_;
          ;
          const fsDropdownvue_type_script_setup_true_lang_ts_hoisted_1 = {
            class: "visually-hidden"
          };
          const fsDropdownvue_type_script_setup_true_lang_ts_hoisted_2 = ["aria-labelledby", "role"];
          var fsDropdownvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsDropdown",
            props: {
              id: null,
              menuClass: null,
              size: null,
              splitClass: null,
              splitVariant: null,
              text: null,
              toggleClass: null,
              autoClose: {
                type: [Boolean, String],
                default: true
              },
              block: {
                default: false
              },
              boundary: {
                default: "clippingParents"
              },
              dark: {
                default: false
              },
              disabled: {
                default: false
              },
              isNav: {
                default: false
              },
              dropup: {
                default: false
              },
              dropright: {
                default: false
              },
              dropleft: {
                default: false
              },
              noFlip: {
                default: false
              },
              offset: {
                default: 0
              },
              popperOpts: {
                default: () => ({})
              },
              left: {
                default: false
              },
              right: {
                default: false
              },
              role: {
                default: "menu"
              },
              split: {
                default: false
              },
              splitButtonType: {
                default: "button"
              },
              splitHref: {
                default: void 0
              },
              noCaret: {
                default: false
              },
              toggleText: {
                default: "Toggle dropdown"
              },
              variant: {
                default: "secondary"
              },
              wrapperTag: {
                default: "div"
              },
              toggleTag: {
                default: "fs-button"
              }
            },
            emits: ["show", "shown", "hide", "hidden", "click", "toggle"],
            setup(__props, {
              expose,
              emit
            }) {
              const props = __props;
              const blockBoolean = useBooleanish((0, external_vue_.toRef)(props, "block"));
              const darkBoolean = useBooleanish((0, external_vue_.toRef)(props, "dark"));
              const disabledBoolean = useBooleanish((0, external_vue_.toRef)(props, "disabled"));
              const dropupBoolean = useBooleanish((0, external_vue_.toRef)(props, "dropup"));
              const droprightBoolean = useBooleanish((0, external_vue_.toRef)(props, "dropright"));
              const isNavBoolean = useBooleanish((0, external_vue_.toRef)(props, "isNav"));
              const dropleftBoolean = useBooleanish((0, external_vue_.toRef)(props, "dropleft"));
              const leftBoolean = useBooleanish((0, external_vue_.toRef)(props, "left"));
              const rightBoolean = useBooleanish((0, external_vue_.toRef)(props, "right"));
              const splitBoolean = useBooleanish((0, external_vue_.toRef)(props, "split"));
              const noCaretBoolean = useBooleanish((0, external_vue_.toRef)(props, "noCaret"));
              const parent = (0, external_vue_.ref)();
              const dropdown = (0, external_vue_.ref)();
              const instance = (0, external_vue_.ref)();
              const computedId = useId((0, external_vue_.toRef)(props, "id"), "dropdown");
              useEventListener(parent, "show.bs.dropdown", () => emit("show"));
              useEventListener(parent, "shown.bs.dropdown", () => emit("shown"));
              useEventListener(parent, "hide.bs.dropdown", () => emit("hide"));
              useEventListener(parent, "hidden.bs.dropdown", () => emit("hidden"));
              const onSplitClick = (event) => {
                if (splitBoolean.value) {
                  emit("click", event);
                }
              };
              const classes = (0, external_vue_.computed)(() => ({
                "btn-group dropstart": dropleftBoolean.value,
                "btn-group dropend": droprightBoolean.value,
                "dropup": dropupBoolean.value,
                "d-flex": blockBoolean.value && splitBoolean.value,
                "d-grid": blockBoolean.value && !splitBoolean.value,
                "dropdown": !dropleftBoolean.value && !droprightBoolean.value && !dropupBoolean.value && !splitBoolean.value && !blockBoolean.value
              }));
              const buttonClasses = (0, external_vue_.computed)(() => ({
                "nav-link": isNavBoolean.value,
                "dropdown-toggle": !splitBoolean.value,
                "dropdown-toggle-no-caret": noCaretBoolean.value && !splitBoolean.value,
                "w-100": splitBoolean.value && blockBoolean.value,
                [`${props.toggleClass}`]: props.toggleClass && !splitBoolean.value
              }));
              const dropdownMenuClasses = (0, external_vue_.computed)(() => ({
                "dropdown-menu-dark": darkBoolean.value,
                "dropdown-menu-end": rightBoolean.value
              }));
              const buttonAttr = (0, external_vue_.computed)(() => ({
                "data-bs-toggle": splitBoolean.value ? void 0 : "dropdown",
                "aria-expanded": splitBoolean.value ? void 0 : "false",
                "ref": splitBoolean.value ? void 0 : dropdown,
                "href": splitBoolean.value ? props.splitHref : void 0
              }));
              const splitAttr = (0, external_vue_.computed)(() => ({
                ref: splitBoolean.value ? dropdown : void 0
              }));
              const hide = () => {
                var _a;
                (_a = instance.value) == null ? void 0 : _a.hide();
              };
              (0, external_vue_.onMounted)(() => {
                var _a;
                instance.value = new external_bootstrap_.Dropdown(((_a = dropdown.value) == null ? void 0 : _a.$el) || dropdown.value, {
                  autoClose: props.autoClose,
                  boundary: props.boundary,
                  offset: props.offset ? props.offset.toString() : "",
                  reference: props.offset || splitBoolean.value ? "parent" : "toggle",
                  popperConfig: (defaultConfig) => {
                    const dropDownConfig = {
                      placement: "bottom-start",
                      modifiers: !props.noFlip ? [] : [{
                        name: "flip",
                        options: {
                          fallbackPlacements: []
                        }
                      }]
                    };
                    if (dropupBoolean.value) {
                      dropDownConfig.placement = rightBoolean.value ? "top-end" : "top-start";
                    } else if (droprightBoolean.value) {
                      dropDownConfig.placement = "right-start";
                    } else if (dropleftBoolean.value) {
                      dropDownConfig.placement = "left-start";
                    } else if (rightBoolean.value) {
                      dropDownConfig.placement = "bottom-end";
                    }
                    return utils_mergeDeep(defaultConfig, utils_mergeDeep(dropDownConfig, props.popperOpts));
                  }
                });
              });
              expose({
                hide
              });
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(__props.wrapperTag), {
                  ref_key: "parent",
                  ref: parent,
                  class: (0, external_vue_.normalizeClass)([(0, external_vue_.unref)(classes), "btn-group"])
                }, {
                  default: (0, external_vue_.withCtx)(() => [((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(__props.toggleTag), (0, external_vue_.mergeProps)({
                    id: (0, external_vue_.unref)(computedId),
                    variant: __props.splitVariant || __props.variant,
                    size: __props.size,
                    class: [(0, external_vue_.unref)(buttonClasses), (0, external_vue_.unref)(splitBoolean) ? __props.splitClass : __props.toggleClass],
                    disabled: (0, external_vue_.unref)(disabledBoolean) || null,
                    type: __props.splitButtonType
                  }, (0, external_vue_.unref)(buttonAttr), {
                    onClick: onSplitClick
                  }), {
                    default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "button-content", {}, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(__props.text), 1)])]),
                    _: 3
                  }, 16, ["id", "variant", "size", "class", "disabled", "type"])), (0, external_vue_.unref)(splitBoolean) ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(fsButton, (0, external_vue_.mergeProps)({
                    key: 0,
                    variant: __props.variant,
                    size: __props.size,
                    disabled: (0, external_vue_.unref)(disabledBoolean) || null
                  }, (0, external_vue_.unref)(splitAttr), {
                    class: [__props.toggleClass, "dropdown-toggle-split dropdown-toggle"],
                    "data-bs-toggle": "dropdown",
                    "aria-expanded": "false",
                    onClick: _cache[0] || (_cache[0] = ($event) => emit("toggle"))
                  }), {
                    default: (0, external_vue_.withCtx)(() => [(0, external_vue_.createElementVNode)("span", fsDropdownvue_type_script_setup_true_lang_ts_hoisted_1, [(0, external_vue_.renderSlot)(_ctx.$slots, "toggle-text", {}, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(__props.toggleText), 1)])])]),
                    _: 3
                  }, 16, ["variant", "size", "disabled", "class"])) : (0, external_vue_.createCommentVNode)("", true), (0, external_vue_.createElementVNode)("ul", {
                    class: (0, external_vue_.normalizeClass)(["dropdown-menu", [__props.menuClass, (0, external_vue_.unref)(dropdownMenuClasses)]]),
                    "aria-labelledby": (0, external_vue_.unref)(computedId),
                    role: __props.role
                  }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")], 10, fsDropdownvue_type_script_setup_true_lang_ts_hoisted_2)]),
                  _: 3
                }, 8, ["class"]);
              };
            }
          });
          ;
          ;
          const fsDropdown_exports_ = fsDropdownvue_type_script_setup_true_lang_ts;
          var fsDropdown = fsDropdown_exports_;
          ;
          function fsDropdownDividervue_type_template_id_170cfddf_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag));
          }
          ;
          ;
          var fsDropdownDividervue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsDropdownDivider",
            props: {
              tag: {
                type: String,
                default: "hr"
              }
            }
          });
          ;
          ;
          ;
          const fsDropdownDivider_exports_ = (0, exportHelper.Z)(fsDropdownDividervue_type_script_lang_ts, [["render", fsDropdownDividervue_type_template_id_170cfddf_ts_true_render]]);
          var fsDropdownDivider = fsDropdownDivider_exports_;
          ;
          const fsDropdownFormvue_type_template_id_56aa076d_ts_true_hoisted_1 = ["disabled", "id", "inline", "novalidate", "validated"];
          function fsDropdownFormvue_type_template_id_56aa076d_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("form", {
              class: (0, external_vue_.normalizeClass)(["fs-dropdown-form", [_ctx.formClass, _ctx.finalClass]]),
              disabled: _ctx.disabled || null,
              id: _ctx.id,
              inline: _ctx.inline || null,
              novalidate: _ctx.novalidate || null,
              validated: _ctx.validated || null
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")], 10, fsDropdownFormvue_type_template_id_56aa076d_ts_true_hoisted_1);
          }
          ;
          ;
          var fsDropdownFormvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsDropdownForm",
            props: {
              disabled: {
                type: Boolean,
                default: false
              },
              formClass: {
                type: [Array, Object, String]
              },
              id: {
                type: String
              },
              inline: {
                type: Boolean,
                default: false
              },
              novalidate: {
                type: Boolean,
                default: false
              },
              validated: {
                type: Boolean,
                default: false
              }
            },
            emits: [],
            setup(props) {
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  "form-inline": props.inline
                };
              });
              return {
                finalClass
              };
            }
          });
          ;
          ;
          ;
          const fsDropdownForm_exports_ = (0, exportHelper.Z)(fsDropdownFormvue_type_script_lang_ts, [["render", fsDropdownFormvue_type_template_id_56aa076d_ts_true_render]]);
          var fsDropdownForm = fsDropdownForm_exports_;
          ;
          const fsDropdownGroupvue_type_template_id_14efc976_ts_true_hoisted_1 = ["id", "aria-describedby", "header", "header-variant"];
          function fsDropdownGroupvue_type_template_id_14efc976_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
              role: "group",
              id: _ctx.id,
              "aria-describedby": _ctx.headerId,
              header: _ctx.header,
              "header-variant": _ctx.headerVariant
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "header", {}, () => [((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.headerTag), {
              id: _ctx.headerId,
              class: (0, external_vue_.normalizeClass)(["dropdown-header", [_ctx.headerClasses, _ctx.finalHeaderClass]])
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.header), 1)]),
              _: 1
            }, 8, ["id", "class"]))]), (0, external_vue_.renderSlot)(_ctx.$slots, "default")], 8, fsDropdownGroupvue_type_template_id_14efc976_ts_true_hoisted_1);
          }
          ;
          ;
          var fsDropdownGroupvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsDropdownGroup",
            props: {
              ariaDescribedby: {
                type: String
              },
              header: {
                type: String
              },
              headerClasses: {
                type: [Array, Object, String]
              },
              headerTag: {
                type: String,
                default: "header"
              },
              headerVariant: {
                type: String
              },
              id: {
                type: String
              }
            },
            emits: [],
            setup(props) {
              const headerId = (0, external_vue_.computed)(() => {
                return props.id ? [props.id, "group_dd_header"].join("_") : void 0;
              });
              const headerRoll = (0, external_vue_.computed)(() => {
                return props.headerTag === "header" ? void 0 : "heading";
              });
              const finalHeaderClass = (0, external_vue_.computed)(() => {
                return {
                  [`text-${props.headerVariant}`]: props.headerVariant
                };
              });
              return {
                headerId,
                headerRoll,
                finalHeaderClass
              };
            }
          });
          ;
          ;
          ;
          const fsDropdownGroup_exports_ = (0, exportHelper.Z)(fsDropdownGroupvue_type_script_lang_ts, [["render", fsDropdownGroupvue_type_template_id_14efc976_ts_true_render]]);
          var fsDropdownGroup = fsDropdownGroup_exports_;
          ;
          function fsDropdownHeadervue_type_template_id_01b41122_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag), {
              class: (0, external_vue_.normalizeClass)(["dropdown-header", _ctx.finalClass])
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 8, ["class"]);
          }
          ;
          ;
          var fsDropdownHeadervue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsDropdownHeader",
            props: {
              id: {
                type: String
              },
              tag: {
                type: String,
                default: "header"
              },
              variant: {
                type: String
              }
            },
            emits: [],
            setup(props) {
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  [`text-${props.variant}`]: props.variant
                };
              });
              return {
                finalClass
              };
            }
          });
          ;
          ;
          ;
          const fsDropdownHeader_exports_ = (0, exportHelper.Z)(fsDropdownHeadervue_type_script_lang_ts, [["render", fsDropdownHeadervue_type_template_id_01b41122_ts_true_render]]);
          var fsDropdownHeader = fsDropdownHeader_exports_;
          ;
          const fsDropdownItemvue_type_template_id_198407d7_ts_true_hoisted_1 = {
            role: "presentation"
          };
          function fsDropdownItemvue_type_template_id_198407d7_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("li", fsDropdownItemvue_type_template_id_198407d7_ts_true_hoisted_1, [((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag), {
              class: (0, external_vue_.normalizeClass)(["dropdown-item", [_ctx.finalClass]]),
              to: _ctx.to,
              href: _ctx.configuredHref,
              onClick: _ctx.clicked
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 8, ["class", "to", "href", "onClick"]))]);
          }
          ;
          ;
          var fsDropdownItemvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsDropdownItem",
            props: {
              active: {
                type: Boolean,
                default: false
              },
              activeClass: {
                type: String
              },
              append: {
                type: Boolean,
                default: false
              },
              disabled: {
                type: Boolean,
                default: false
              },
              exact: {
                type: Boolean,
                default: false
              },
              exactActiveClass: {
                type: String
              },
              href: {
                type: String
              },
              linkClass: {
                type: [Array, Object, String]
              },
              id: {
                type: String,
                required: false
              },
              noPrefetch: {
                type: Boolean,
                default: false
              },
              prefetch: {
                type: Boolean,
                default: null
              },
              rel: {
                type: String,
                default: null
              },
              replace: {
                type: Boolean,
                default: false
              },
              routerComponentName: {
                type: String
              },
              target: {
                type: String,
                default: "_self"
              },
              to: {
                type: [Object, String]
              },
              variant: {
                type: String
              }
            },
            components: {
              fsRouterLink
            },
            emits: ["click"],
            setup(props, {
              attrs,
              emit
            }) {
              const instance = (0, external_vue_.getCurrentInstance)();
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  active: props.active,
                  disabled: props.disabled,
                  [`text-${props.variant}`]: props.variant,
                  [`${props.linkClass}`]: props.linkClass
                };
              });
              const finalAttrs = (0, external_vue_.computed)(() => {
                return {
                  "aria-current": props.active ? "true" : null,
                  "href": tag.value === "a" ? configuredHref.value : null,
                  "rel": props.rel,
                  "target": props.target
                };
              });
              function clicked(e) {
                emit("click", e);
              }
              const tag = (0, external_vue_.computed)(() => props.href ? "a" : props.to ? "fs-router-link" : "a");
              const configuredHref = configureHref(props.to, props.href, props.append, instance);
              return {
                clicked,
                finalClass,
                configuredHref,
                finalAttrs,
                tag,
                configureHref
              };
            }
          });
          ;
          ;
          ;
          const fsDropdownItem_exports_ = (0, exportHelper.Z)(fsDropdownItemvue_type_script_lang_ts, [["render", fsDropdownItemvue_type_template_id_198407d7_ts_true_render]]);
          var fsDropdownItem = fsDropdownItem_exports_;
          ;
          function fsDropdownItemButtonvue_type_template_id_61d83b04_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("button", {
              class: (0, external_vue_.normalizeClass)(["dropdown-item", _ctx.finalClass]),
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.clicked && _ctx.clicked(...args))
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")], 2);
          }
          ;
          ;
          var fsDropdownItemButtonvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsDropdownItemButton",
            props: {
              active: {
                type: Boolean,
                default: false
              },
              activeClass: {
                type: String,
                default: "active"
              },
              buttonClass: {
                type: [Array, Object, String]
              },
              disabled: {
                type: Boolean,
                default: false
              },
              variant: {
                type: String
              }
            },
            emits: ["click"],
            setup(props, {
              emit
            }) {
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  [`${props.activeClass}`]: props.active,
                  disabled: props.disabled,
                  [`text-${props.variant}`]: props.variant
                };
              });
              const finalAttrs = (0, external_vue_.computed)(() => {
                return {
                  role: "menuitem",
                  type: "button",
                  disabled: props.disabled
                };
              });
              function clicked(e) {
                if (props.disabled) {
                  e.preventDefault();
                  e.stopPropagation();
                  return;
                }
                emit("click", e);
              }
              return {
                finalClass,
                finalAttrs,
                clicked
              };
            }
          });
          ;
          ;
          ;
          const fsDropdownItemButton_exports_ = (0, exportHelper.Z)(fsDropdownItemButtonvue_type_script_lang_ts, [["render", fsDropdownItemButtonvue_type_template_id_61d83b04_ts_true_render]]);
          var fsDropdownItemButton = fsDropdownItemButton_exports_;
          ;
          function fsDropdownTextvue_type_template_id_fcb4c2ce_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag), (0, external_vue_.mergeProps)({
              class: ["px-4 py-1", [_ctx.textClass, _ctx.finalClass]],
              variant: _ctx.variant
            }, _ctx.$props), {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 16, ["class", "variant"]);
          }
          ;
          ;
          var fsDropdownTextvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsDropdownText",
            props: {
              tag: {
                type: String,
                default: "p"
              },
              textClass: {
                type: [Array, Object, String]
              },
              variant: {
                type: String
              }
            },
            setup(props) {
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  [`text-${props.variant}`]: props.variant
                };
              });
              return {
                finalClass
              };
            }
          });
          ;
          ;
          ;
          const fsDropdownText_exports_ = (0, exportHelper.Z)(fsDropdownTextvue_type_script_lang_ts, [["render", fsDropdownTextvue_type_template_id_fcb4c2ce_ts_true_render]]);
          var fsDropdownText = fsDropdownText_exports_;
          ;
          const fsFormCheckboxvue_type_template_id_0fb8b98a_ts_true_hoisted_1 = ["id", "aria-required", "value", "role", "disabled"];
          const fsFormCheckboxvue_type_template_id_0fb8b98a_ts_true_hoisted_2 = ["for"];
          function fsFormCheckboxvue_type_template_id_0fb8b98a_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
              class: (0, external_vue_.normalizeClass)(_ctx.wrapperClasses)
            }, [(0, external_vue_.withDirectives)((0, external_vue_.createElementVNode)("input", (0, external_vue_.mergeProps)({
              id: _ctx.computedId,
              ref: "input"
            }, _ctx.$attrs, {
              class: _ctx.inputClasses,
              type: "checkbox",
              "aria-required": _ctx.name && _ctx.required ? "true" : null,
              onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
              onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
              onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onClicked && _ctx.onClicked(...args)),
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.localValue = $event),
              value: _ctx.value,
              role: _ctx.computeRole,
              disabled: _ctx.disabled
            }), null, 16, fsFormCheckboxvue_type_template_id_0fb8b98a_ts_true_hoisted_1), [[external_vue_.vModelCheckbox, _ctx.localValue]]), _ctx.hasDefault || !_ctx.plain ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("label", {
              key: 0,
              for: _ctx.computedId,
              class: (0, external_vue_.normalizeClass)(_ctx.labelClasses)
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")], 10, fsFormCheckboxvue_type_template_id_0fb8b98a_ts_true_hoisted_2)) : (0, external_vue_.createCommentVNode)("", true)], 2);
          }
          ;
          ;
          function generateId(id, suffix) {
            if (!suffix) {
              suffix = "";
            }
            return id || `FSID-${Math.random().toString().slice(2, 8)}-FS-${suffix}`;
          }
          var utils_generateId = generateId;
          ;
          const compareArrays = (a, b) => {
            if (a.length !== b.length) {
              return false;
            }
            let equal = true;
            for (let i = 0; equal && i < a.length; i++) {
              equal = looseEqual(a[i], b[i]);
            }
            return equal;
          };
          const looseEqual = (a, b) => {
            if (a === b) {
              return true;
            }
            let aValidType = isDate(a);
            let fsvalidType = isDate(b);
            if (aValidType || fsvalidType) {
              return aValidType && fsvalidType ? a.getTime() === b.getTime() : false;
            }
            aValidType = inspect_isArray(a);
            fsvalidType = inspect_isArray(b);
            if (aValidType || fsvalidType) {
              return aValidType && fsvalidType ? compareArrays(a, b) : false;
            }
            aValidType = inspect_isObject(a);
            fsvalidType = inspect_isObject(b);
            if (aValidType || fsvalidType) {
              if (!aValidType || !fsvalidType) {
                return false;
              }
              const aKeysCount = object_keys(a).length;
              const bKeysCount = object_keys(b).length;
              if (aKeysCount !== bKeysCount) {
                return false;
              }
              for (const key in a) {
                const aHasKey = object_hasOwnProperty(a, key);
                const bHasKey = object_hasOwnProperty(b, key);
                if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
                  return false;
                }
              }
            }
            return String(a) === String(b);
          };
          ;
          var fsFormCheckboxvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsFormCheckbox",
            model: {
              prop: "checked",
              event: "change"
            },
            props: {
              ariaLabel: {
                type: String
              },
              ariaLabelledby: {
                type: String
              },
              autofocus: {
                type: Boolean,
                default: false
              },
              button: {
                type: Boolean,
                default: false
              },
              buttonVariant: {
                type: String,
                default: "secondary"
              },
              checked: {
                default: null
              },
              disabled: {
                type: Boolean,
                default: false
              },
              form: {
                type: String
              },
              id: {
                type: String
              },
              indeterminate: {
                type: Boolean,
                default: false
              },
              inline: {
                type: Boolean,
                default: false
              },
              name: {
                type: String
              },
              plain: {
                type: Boolean,
                default: false
              },
              required: {
                type: Boolean,
                default: false
              },
              size: {
                type: String
              },
              state: {
                type: Boolean,
                default: null
              },
              switch: {
                type: Boolean,
                default: false
              },
              uncheckedValue: {
                default: false
              },
              value: {
                default: true
              },
              modelValue: void 0
            },
            emits: ["change", "blur", "focus", "input", "update:modelValue", "click", "update:indeterminate"],
            setup(props, {
              emit,
              slots
            }) {
              const computedId = (0, external_vue_.ref)("");
              const isFocused = (0, external_vue_.ref)(false);
              const hasDefault = (0, external_vue_.ref)(false);
              const input = (0, external_vue_.ref)();
              (0, external_vue_.onBeforeMount)(() => {
                var _a;
                computedId.value = utils_generateId((_a = props.id) == null ? void 0 : _a.toString(), "form-check");
              });
              (0, external_vue_.onMounted)(() => {
                if (props.indeterminate) {
                  setIndeterminate(props.indeterminate);
                }
              });
              function onClicked(event) {
                emit("click", event);
              }
              function onBlur(event) {
                isFocused.value = false;
                emit("blur", event);
              }
              function onFocus(event) {
                isFocused.value = true;
                emit("focus", event);
              }
              const computeRole = (0, external_vue_.computed)(() => {
                return props.switch ? "switch" : null;
              });
              const localValue = (0, external_vue_.computed)({
                get: () => {
                  if (props.uncheckedValue) {
                    if (!Array.isArray(props.modelValue)) {
                      return props.modelValue === props.value;
                    }
                    return props.modelValue.indexOf(props.value) > -1;
                  }
                  return props.modelValue;
                },
                set: (newValue) => {
                  let emitValue = newValue;
                  if (!Array.isArray(props.modelValue)) {
                    emitValue = newValue ? props.value : props.uncheckedValue;
                  } else {
                    if (props.uncheckedValue) {
                      emitValue = props.modelValue;
                      if (newValue) {
                        if (emitValue.indexOf(props.uncheckedValue) > -1)
                          emitValue.splice(emitValue.indexOf(props.uncheckedValue), 1);
                        emitValue.push(props.value);
                      } else {
                        if (emitValue.indexOf(props.value) > -1)
                          emitValue.splice(emitValue.indexOf(props.value), 1);
                        emitValue.push(props.uncheckedValue);
                      }
                    }
                  }
                  emit("update:modelValue", emitValue);
                  emit("input", emitValue);
                  emit("change", emitValue);
                  emit("update:indeterminate", false);
                }
              });
              const wrapperClasses = (0, external_vue_.computed)(() => {
                return {
                  "form-check": !props.button,
                  "btn-group-toggle d-inline-block": props.button,
                  "form-check-inline": props.inline,
                  "form-switch": props.switch,
                  [`form-control-${props.size}`]: props.size
                };
              });
              const inputClasses = (0, external_vue_.computed)(() => {
                return {
                  "form-check-input": true,
                  "is-valid": props.state === true,
                  "is-invalid": props.state === false,
                  "btn-check": props.button
                };
              });
              const labelClasses = (0, external_vue_.computed)(() => {
                return {
                  "form-check-label": true,
                  "btn": props.button,
                  [`btn-${props.buttonVariant}`]: props.button,
                  [`btn-${props.size}`]: props.button && props.size
                };
              });
              if (slots.default && slots.default().length) {
                hasDefault.value = true;
              }
              (0, external_vue_.watch)(() => props.indeterminate, (newValue, oldValue) => {
                if (!looseEqual(newValue, oldValue)) {
                  setIndeterminate(newValue);
                }
              });
              function setIndeterminate(state) {
                if (Array.isArray(props.modelValue)) {
                  state = false;
                }
                if (input == null ? void 0 : input.value) {
                  input.value.indeterminate = state;
                }
              }
              return {
                computedId,
                isFocused,
                localValue,
                onBlur,
                onFocus,
                onClicked,
                wrapperClasses,
                inputClasses,
                labelClasses,
                hasDefault,
                computeRole,
                input
              };
            }
          });
          ;
          ;
          ;
          const fsFormCheckbox_exports_ = (0, exportHelper.Z)(fsFormCheckboxvue_type_script_lang_ts, [["render", fsFormCheckboxvue_type_template_id_0fb8b98a_ts_true_render]]);
          var fsFormCheckbox = fsFormCheckbox_exports_;
          ;
          const fsFormCheckboxGroupvue_type_script_setup_true_lang_ts_hoisted_1 = ["id"];
          const fsFormCheckboxGroupvue_type_script_setup_true_lang_ts_hoisted_2 = ["innerHTML"];
          const fsFormCheckboxGroupvue_type_script_setup_true_lang_ts_hoisted_3 = ["textContent"];
          var fsFormCheckboxGroupvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsFormCheckboxGroup",
            props: {
              id: null,
              form: null,
              modelValue: {
                default: () => []
              },
              ariaInvalid: {
                default: void 0
              },
              autofocus: {
                default: false
              },
              buttonVariant: {
                default: "secondary"
              },
              buttons: {
                default: false
              },
              checkboxClass: null,
              disabled: {
                default: false
              },
              disabledField: {
                default: "disabled"
              },
              htmlField: {
                default: "html"
              },
              name: null,
              options: {
                default: () => []
              },
              plain: {
                default: false
              },
              required: {
                default: false
              },
              size: null,
              stacked: {
                default: false
              },
              state: {
                default: void 0
              },
              switches: {
                default: false
              },
              textField: {
                default: "text"
              },
              validated: {
                default: false
              },
              valueField: {
                default: "value"
              }
            },
            emits: ["input", "update:modelValue", "change"],
            setup(__props, {
              emit
            }) {
              const props = __props;
              const autofocusBoolean = useBooleanish((0, external_vue_.toRef)(props, "autofocus"));
              const buttonsBoolean = useBooleanish((0, external_vue_.toRef)(props, "buttons"));
              const disabledBoolean = useBooleanish((0, external_vue_.toRef)(props, "disabled"));
              const plainBoolean = useBooleanish((0, external_vue_.toRef)(props, "plain"));
              const requiredBoolean = useBooleanish((0, external_vue_.toRef)(props, "required"));
              const stackedBoolean = useBooleanish((0, external_vue_.toRef)(props, "stacked"));
              const stateBoolean = useBooleanish((0, external_vue_.toRef)(props, "state"));
              const switchesBoolean = useBooleanish((0, external_vue_.toRef)(props, "switches"));
              const validatedBoolean = useBooleanish((0, external_vue_.toRef)(props, "validated"));
              const slots = (0, external_vue_.useSlots)();
              const slotsName = "FsFormCheckbox";
              const computedId = useId((0, external_vue_.toRef)(props, "id"), "checkbox");
              const computedName = useId((0, external_vue_.toRef)(props, "name"), "checkbox");
              const localValue = (0, external_vue_.computed)({
                get: () => props.modelValue,
                set: (newValue) => {
                  if (JSON.stringify(newValue) === JSON.stringify(props.modelValue))
                    return;
                  let sortByOptions;
                  if (props.options.length > 0) {
                    sortByOptions = props.options.filter((el) => newValue.map((it) => JSON.stringify(it)).includes(JSON.stringify(typeof el === "string" ? el : el[props.valueField]))).map((el) => typeof el === "string" ? el : el[props.valueField]);
                  } else {
                    sortByOptions = newValue.map((el) => typeof el === "string" ? el : el[props.valueField]);
                  }
                  emit("input", sortByOptions);
                  emit("update:modelValue", sortByOptions);
                  emit("change", sortByOptions);
                }
              });
              const checkboxList = (0, external_vue_.computed)(() => (slots.first ? slotsToElements(slots.first(), slotsName, disabledBoolean.value) : []).concat(props.options.map((e) => optionToElement(e, props))).concat(slots.default ? slotsToElements(slots.default(), slotsName, disabledBoolean.value) : []).map((e, idx) => bindGroupProps(e, idx, props, computedName, computedId)).map((e) => ({
                ...e,
                props: {
                  switch: switchesBoolean.value,
                  ...e.props
                }
              })));
              const classesObject = (0, external_vue_.reactive)({
                required: (0, external_vue_.toRef)(requiredBoolean, "value"),
                ariaInvalid: (0, external_vue_.toRef)(props, "ariaInvalid"),
                state: (0, external_vue_.toRef)(stateBoolean, "value"),
                validated: (0, external_vue_.toRef)(validatedBoolean, "value"),
                buttons: (0, external_vue_.toRef)(buttonsBoolean, "value"),
                stacked: (0, external_vue_.toRef)(stackedBoolean, "value"),
                size: (0, external_vue_.toRef)(props, "size")
              });
              const attrs = getGroupAttr(classesObject);
              const classes = getGroupClasses(classesObject);
              return (_ctx, _cache) => {
                const _component_fs_form_checkbox = (0, external_vue_.resolveComponent)("fs-form-checkbox");
                return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", (0, external_vue_.mergeProps)((0, external_vue_.unref)(attrs), {
                  id: (0, external_vue_.unref)(computedId),
                  role: "group",
                  class: [(0, external_vue_.unref)(classes), "bv-no-focus-ring"],
                  tabindex: "-1"
                }), [((0, external_vue_.openBlock)(true), (0, external_vue_.createElementBlock)(external_vue_.Fragment, null, (0, external_vue_.renderList)((0, external_vue_.unref)(checkboxList), (item, key) => {
                  return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(_component_fs_form_checkbox, (0, external_vue_.mergeProps)({
                    key,
                    modelValue: (0, external_vue_.unref)(localValue),
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => (0, external_vue_.isRef)(localValue) ? localValue.value = $event : null)
                  }, item.props, {
                    class: __props.checkboxClass
                  }), {
                    default: (0, external_vue_.withCtx)(() => [item.html ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("span", {
                      key: 0,
                      innerHTML: item.html
                    }, null, 8, fsFormCheckboxGroupvue_type_script_setup_true_lang_ts_hoisted_2)) : ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("span", {
                      key: 1,
                      textContent: (0, external_vue_.toDisplayString)(item.text)
                    }, null, 8, fsFormCheckboxGroupvue_type_script_setup_true_lang_ts_hoisted_3))]),
                    _: 2
                  }, 1040, ["modelValue", "class"]);
                }), 128))], 16, fsFormCheckboxGroupvue_type_script_setup_true_lang_ts_hoisted_1);
              };
            }
          });
          ;
          ;
          const fsFormCheckboxGroup_exports_ = fsFormCheckboxGroupvue_type_script_setup_true_lang_ts;
          var fsFormCheckboxGroup = fsFormCheckboxGroup_exports_;
          ;
          const fsFormFilevue_type_template_id_5453490e_ts_true_hoisted_1 = ["id"];
          const fsFormFilevue_type_template_id_5453490e_ts_true_hoisted_2 = ["for"];
          const fsFormFilevue_type_template_id_5453490e_ts_true_hoisted_3 = {
            class: "d-block form-file-text",
            style: {
              "pointer-events": "none"
            }
          };
          function fsFormFilevue_type_template_id_5453490e_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
              onDrop: _cache[5] || (_cache[5] = (0, external_vue_.withModifiers)(() => {
              }, ["prevent"]))
            }, [(0, external_vue_.createElementVNode)("div", {
              class: (0, external_vue_.normalizeClass)(_ctx.divComputedClass),
              onDragenter: _cache[1] || (_cache[1] = (...args) => _ctx.onDragenter && _ctx.onDragenter(...args)),
              onDragleave: _cache[2] || (_cache[2] = (...args) => _ctx.onDragleave && _ctx.onDragleave(...args)),
              onDrop: _cache[3] || (_cache[3] = (...args) => _ctx.onFileDrop && _ctx.onFileDrop(...args)),
              onDragover: _cache[4] || (_cache[4] = (0, external_vue_.withModifiers)(() => {
              }, ["prevent"]))
            }, [(0, external_vue_.createElementVNode)("input", (0, external_vue_.mergeProps)({
              type: "file",
              class: _ctx.inputComputedClass,
              id: _ctx.internalId,
              style: {
                "z-index": "-5"
              },
              onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onChange && _ctx.onChange(...args))
            }, _ctx.$attrs), null, 16, fsFormFilevue_type_template_id_5453490e_ts_true_hoisted_1), (0, external_vue_.createElementVNode)("label", {
              "data-browse": "Browse",
              class: (0, external_vue_.normalizeClass)(_ctx.labelComputedClass),
              for: _ctx.internalId
            }, [(0, external_vue_.createElementVNode)("span", fsFormFilevue_type_template_id_5453490e_ts_true_hoisted_3, (0, external_vue_.toDisplayString)(_ctx.placeholderText), 1)], 10, fsFormFilevue_type_template_id_5453490e_ts_true_hoisted_2)], 34), (0, external_vue_.renderSlot)(_ctx.$slots, "default")], 32);
          }
          ;
          ;
          var fsFormFilevue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsFormFile",
            model: {
              prop: "data",
              event: "change"
            },
            props: {
              accept: {
                type: String,
                default: ""
              },
              autofocus: {
                type: Boolean,
                default: false
              },
              browseText: {
                type: String,
                default: "Browse"
              },
              capture: {
                type: Boolean,
                default: false
              },
              directory: {
                type: Boolean,
                default: false
              },
              disabled: {
                type: Boolean,
                default: false
              },
              dropPlaceholder: {
                type: String,
                default: "Drop files here"
              },
              fileNameFormatter: {
                type: Function
              },
              form: {
                type: String
              },
              id: {
                type: String
              },
              multiple: {
                type: Boolean,
                default: false
              },
              name: {
                type: String
              },
              noDrop: {
                type: Boolean,
                default: false
              },
              noDropPlaceholder: {
                type: String,
                default: "Not allowed"
              },
              noTraverse: {
                type: Boolean,
                default: false
              },
              placeholder: {
                type: String,
                default: "No file chosen"
              },
              plain: {
                type: Boolean,
                default: false
              },
              required: {
                type: Boolean,
                default: false
              },
              size: {
                type: String
              },
              state: {
                type: Boolean,
                default: null
              },
              modelValue: {
                type: [Array, Object]
              }
            },
            emits: ["update:modelValue"],
            setup(props, context) {
              const placeholderText = (0, external_vue_.ref)("");
              const placeholderTextAux = (0, external_vue_.ref)("");
              const internalId = (0, external_vue_.ref)("");
              let dragCounter = 0;
              (0, external_vue_.onBeforeMount)(() => {
                if (!props.id) {
                  internalId.value = generateQuickId();
                } else {
                  internalId.value = `${props.id}__${generateQuickId()}`;
                }
                placeholderText.value = props.placeholder.toString();
              });
              const divComputedClass = (0, external_vue_.computed)(() => {
                return {
                  ["custom-file b-form-file"]: true,
                  [`fs-custom-control-${props.size}`]: props.size
                };
              });
              const inputComputedClass = (0, external_vue_.computed)(() => {
                return {
                  ["form-control"]: props.plain,
                  ["d-none"]: !props.plain
                };
              });
              const labelComputedClass = (0, external_vue_.computed)(() => {
                return {
                  ["d-none"]: props.plain,
                  ["form-control"]: !props.plain
                };
              });
              (0, external_vue_.watch)(() => props.modelValue, (newValue) => {
                if (newValue) {
                  if (props.multiple || newValue.length) {
                    let text = "";
                    for (let i = 0; i < newValue.length; i++) {
                      text += `${newValue[i].name}; `;
                    }
                    placeholderText.value = text;
                  } else {
                    placeholderText.value = newValue.name;
                  }
                } else {
                  placeholderText.value = props.placeholder.toString();
                }
              }, {
                deep: true
              });
              function onChange(event) {
                const files = event.target.files || event.dataTransfer.files;
                context.emit("update:modelValue", props.multiple ? files : files[0]);
              }
              function onFileDrop(event) {
                if (props.noDrop) {
                  dragCounter = 0;
                  placeholderText.value = placeholderTextAux.value;
                  return false;
                }
                onChange(event);
              }
              function onDragenter(event) {
                dragCounter++;
                event.preventDefault();
                event.stopImmediatePropagation();
                if (dragCounter === 1) {
                  placeholderTextAux.value = placeholderText.value;
                }
                if (props.noDrop && props.noDrop === true) {
                  placeholderText.value = props.noDropPlaceholder.toString();
                } else {
                  placeholderText.value = props.dropPlaceholder.toString();
                }
              }
              function onDragleave(event) {
                dragCounter--;
                event.preventDefault();
                event.stopImmediatePropagation();
                if (dragCounter === 0) {
                  placeholderText.value = placeholderTextAux.value;
                }
              }
              function generateQuickId() {
                return "xxxxxxxx".replace(/[xy]/g, function(c) {
                  const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
                  return v.toString(16);
                });
              }
              return {
                placeholderText,
                placeholderTextAux,
                internalId,
                divComputedClass,
                inputComputedClass,
                labelComputedClass,
                onChange,
                onFileDrop,
                onDragenter,
                onDragleave
              };
            }
          });
          ;
          ;
          ;
          const fsFormFile_exports_ = (0, exportHelper.Z)(fsFormFilevue_type_script_lang_ts, [["render", fsFormFilevue_type_template_id_5453490e_ts_true_render]]);
          var fsFormFile = fsFormFile_exports_;
          ;
          const fsFormGroupvue_type_template_id_f5aa17e8_ts_true_hoisted_1 = ["id"];
          const fsFormGroupvue_type_template_id_f5aa17e8_ts_true_hoisted_2 = ["aria-live", "id"];
          const fsFormGroupvue_type_template_id_f5aa17e8_ts_true_hoisted_3 = ["aria-live", "id"];
          const fsFormGroupvue_type_template_id_f5aa17e8_ts_true_hoisted_4 = ["id"];
          function fsFormGroupvue_type_template_id_f5aa17e8_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
              class: (0, external_vue_.normalizeClass)(["form-group", _ctx.wrapperClasses])
            }, [_ctx.label || _ctx.$slots.label ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("label", {
              key: 0,
              class: (0, external_vue_.normalizeClass)(_ctx.labelClasses),
              id: `${_ctx.id}__FS_label`
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "label", {}, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.label), 1)])], 10, fsFormGroupvue_type_template_id_f5aa17e8_ts_true_hoisted_1)) : (0, external_vue_.createCommentVNode)("", true), (0, external_vue_.createElementVNode)("div", {
              class: (0, external_vue_.normalizeClass)(_ctx.contentClasses)
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default"), !!_ctx.validFeedback ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
              key: 0,
              "aria-live": _ctx.feedbackAriaLive,
              id: `${_ctx.id}__FS_feedback_valid`,
              class: (0, external_vue_.normalizeClass)(["valid-feedback", {
                "d-block": _ctx.state
              }])
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "valid-feedback", {}, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.validFeedback), 1)])], 10, fsFormGroupvue_type_template_id_f5aa17e8_ts_true_hoisted_2)) : (0, external_vue_.createCommentVNode)("", true), !!_ctx.invalidFeedback ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
              key: 1,
              "aria-live": _ctx.feedbackAriaLive,
              id: `${_ctx.id}__FS_feedback_invalid`,
              class: (0, external_vue_.normalizeClass)(["invalid-feedback", {
                "d-block": !_ctx.state
              }])
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "invalid-feedback", {}, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.invalidFeedback), 1)])], 10, fsFormGroupvue_type_template_id_f5aa17e8_ts_true_hoisted_3)) : (0, external_vue_.createCommentVNode)("", true), (0, external_vue_.createElementVNode)("small", {
              tabindex: "-1",
              id: `${_ctx.id}__FS_description`,
              class: "form-text text-muted"
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "description", {}, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.description), 1)])], 8, fsFormGroupvue_type_template_id_f5aa17e8_ts_true_hoisted_4)], 2)], 2);
          }
          ;
          ;
          var fsFormGroupvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsFormGroup",
            props: {
              contentCols: {
                type: [Boolean, Number, String]
              },
              contentColsLg: {
                type: [Boolean, Number, String]
              },
              contentColsMd: {
                type: [Boolean, Number, String]
              },
              contentColsSm: {
                type: [Boolean, Number, String]
              },
              contentColsXl: {
                type: [Boolean, Number, String]
              },
              description: {
                type: String
              },
              disabled: {
                type: Boolean,
                default: false
              },
              feedbackAriaLive: {
                type: [String],
                default: "assertive"
              },
              id: {
                type: String
              },
              invalidFeedback: {
                type: String
              },
              label: {
                type: String
              },
              labelAlign: {
                type: String
              },
              labelAlignLg: {
                type: String
              },
              labelAlignMd: {
                type: String
              },
              labelAlignSm: {
                type: String
              },
              labelAlignXl: {
                type: String
              },
              labelClass: {
                type: [Array, Object, String]
              },
              labelCols: {
                type: [Boolean, Number, String]
              },
              labelColsLg: {
                type: [Boolean, Number, String]
              },
              labelColsMd: {
                type: [Boolean, Number, String]
              },
              labelColsSm: {
                type: [Boolean, Number, String]
              },
              labelColsXl: {
                type: [Boolean, Number, String]
              },
              labelFor: {
                type: String
              },
              labelSize: {
                type: String
              },
              labelSrOnly: {
                type: Boolean,
                default: false
              },
              state: {
                type: Boolean,
                default: null
              },
              tooltip: {
                type: Boolean,
                default: false
              },
              validFeedback: {
                type: String
              },
              validated: {
                type: Boolean,
                default: false
              }
            },
            emits: [],
            setup(props) {
              const hasLabelColumn = (0, external_vue_.computed)(() => {
                return !!(props.labelCols || props.labelColsSm || props.labelColsMd || props.labelColsLg || props.labelColsXl);
              });
              const hasContentColumn = (0, external_vue_.computed)(() => {
                return !!(props.contentCols || props.contentColsSm || props.contentColsMd || props.contentColsLg || props.contentColsXl);
              });
              const wrapperClasses = (0, external_vue_.computed)(() => {
                return {
                  "row": hasLabelColumn.value || hasContentColumn.value,
                  "is-invalid": props.state === false,
                  "is-valid": props.state
                };
              });
              const labelClasses = (0, external_vue_.computed)(() => {
                return {
                  [`${props.labelClass}`]: !!props.labelClass,
                  [`text-${props.labelAlign}`]: !!props.labelAlign,
                  [`text-sm${props.labelAlign}`]: !!props.labelAlignSm,
                  [`text-md${props.labelAlign}`]: !!props.labelAlignMd,
                  [`text-lg${props.labelAlign}`]: !!props.labelAlignLg,
                  [`text-Xl${props.labelAlign}`]: !!props.labelAlignXl,
                  "col-form-label": hasLabelColumn.value || hasContentColumn.value,
                  "col": !hasLabelColumn.value && hasContentColumn.value,
                  [`col-${props.labelCols}`]: !!props.labelCols && typeof props.labelCols !== "boolean",
                  [`col-sm-${props.labelColsSm}`]: !!props.labelColsSm && typeof props.labelColsSm !== "boolean",
                  [`col-md-${props.labelColsMd}`]: !!props.labelColsMd && typeof props.labelColsMd !== "boolean",
                  [`col-lg-${props.labelColsLg}`]: !!props.labelColsLg && typeof props.labelColsLg !== "boolean",
                  [`col-xl-${props.labelColsXl}`]: !!props.labelColsXl && typeof props.labelColsXl !== "boolean",
                  "col-sm": !!props.labelColsSm && typeof props.labelColsSm === "boolean",
                  "col-md": !!props.labelColsMd && typeof props.labelColsMd === "boolean",
                  "col-lg": !!props.labelColsLg && typeof props.labelColsLg === "boolean",
                  "col-xl": !!props.labelColsXl && typeof props.labelColsXl === "boolean"
                };
              });
              const contentClasses = (0, external_vue_.computed)(() => {
                return {
                  "col-form-content": hasLabelColumn.value || hasContentColumn.value,
                  "col": hasLabelColumn.value && !hasContentColumn.value,
                  [`col-${props.contentCols}`]: !!props.contentCols && typeof props.contentCols !== "boolean",
                  [`col-sm-${props.contentColsSm}`]: !!props.contentColsSm && typeof props.contentColsSm !== "boolean",
                  [`col-md-${props.contentColsMd}`]: !!props.contentColsMd && typeof props.contentColsMd !== "boolean",
                  [`col-lg-${props.contentColsLg}`]: !!props.contentColsLg && typeof props.contentColsLg !== "boolean",
                  [`col-xl-${props.contentColsXl}`]: !!props.contentColsXl && typeof props.contentColsXl !== "boolean",
                  "col-sm": !!props.contentColsSm && typeof props.contentColsSm === "boolean",
                  "col-md": !!props.contentColsMd && typeof props.contentColsMd === "boolean",
                  "col-lg": !!props.contentColsLg && typeof props.contentColsLg === "boolean",
                  "col-xl": !!props.contentColsXl && typeof props.contentColsXl === "boolean"
                };
              });
              const feedbackClasses = (0, external_vue_.computed)(() => {
                return {
                  "invalid-feedback": !props.state,
                  "valid-feedback": props.state
                };
              });
              return {
                wrapperClasses,
                labelClasses,
                contentClasses,
                feedbackClasses
              };
            }
          });
          ;
          ;
          ;
          const fsFormGroup_exports_ = (0, exportHelper.Z)(fsFormGroupvue_type_script_lang_ts, [["render", fsFormGroupvue_type_template_id_f5aa17e8_ts_true_render]]);
          var fsFormGroup = fsFormGroup_exports_;
          ;
          const fsFormInputvue_type_template_id_99846fe6_ts_true_hoisted_1 = ["id", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"];
          function fsFormInputvue_type_template_id_99846fe6_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("input", {
              id: _ctx.computedId,
              ref: "input",
              class: (0, external_vue_.normalizeClass)(_ctx.computedClasses),
              name: _ctx.name || void 0,
              form: _ctx.form || void 0,
              type: _ctx.localType,
              disabled: _ctx.disabled,
              placeholder: _ctx.placeholder,
              required: _ctx.required || void 0,
              autocomplete: _ctx.autocomplete || void 0,
              readonly: _ctx.readonly || _ctx.plaintext,
              min: _ctx.min,
              max: _ctx.max,
              step: _ctx.step,
              list: _ctx.type !== "password" ? _ctx.list : void 0,
              "aria-required": _ctx.required ? "true" : void 0,
              "aria-invalid": _ctx.computedAriaInvalid,
              onInput: _cache[0] || (_cache[0] = ($event) => _ctx.onInput($event)),
              onChange: _cache[1] || (_cache[1] = ($event) => _ctx.onChange($event)),
              onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.onInputBlur($event)),
              onFocus: _cache[3] || (_cache[3] = ($event) => _ctx.onInputFocus($event)),
              onMouseenter: _cache[4] || (_cache[4] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
              onMouseleave: _cache[5] || (_cache[5] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
            }, null, 42, fsFormInputvue_type_template_id_99846fe6_ts_true_hoisted_1);
          }
          ;
          ;
          const allowedTypes = ["text", "number", "email", "password", "search", "url", "tel", "date", "time", "range", "color"];
          var fsFormInputvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            props: {
              ...COMMON_INPUT_PROPS,
              max: {
                type: [String, Number],
                required: false
              },
              min: {
                type: [String, Number],
                required: false
              },
              step: {
                type: [String, Number],
                required: false
              },
              type: {
                type: String,
                default: "text",
                validator: (value) => allowedTypes.includes(value)
              }
            },
            emits: ["update:modelValue", "change", "blur", "input"],
            setup(props, {
              emit
            }) {
              const {
                input,
                computedId,
                computedAriaInvalid,
                onInput,
                onChange,
                onBlur,
                focus,
                blur
              } = useFormInput(props, emit);
              const isHighlighted = (0, external_vue_.ref)(false);
              const dateType = (0, external_vue_.ref)("date");
              (0, external_vue_.onMounted)(() => {
                (0, external_vue_.nextTick)(() => {
                  var _a;
                  if (props.type === "date" && !((_a = input == null ? void 0 : input.value) == null ? void 0 : _a.value)) {
                    dateType.value = "text";
                  }
                });
              });
              const computedClasses = (0, external_vue_.computed)(() => {
                const isRange = props.type === "range";
                const isColor = props.type === "color";
                return {
                  "form-control-highlighted": isHighlighted.value,
                  "form-range": isRange,
                  "form-control": isColor || !props.plaintext && !isRange,
                  "form-control-color": isColor,
                  "form-control-plaintext": props.plaintext && !isRange && !isColor,
                  [`form-control-${props.size}`]: !!props.size,
                  "is-valid": props.state === true,
                  "is-invalid": props.state === false
                };
              });
              const localType = (0, external_vue_.computed)(() => {
                if (props.type === "date") {
                  return dateType.value;
                }
                return allowedTypes.includes(props.type) ? props.type : "text";
              });
              const highlight = () => {
                if (isHighlighted.value === true)
                  return;
                isHighlighted.value = true;
                setTimeout(() => {
                  isHighlighted.value = false;
                }, 2e3);
              };
              function onInputFocus(e) {
                dateType.value = "date";
              }
              function onInputBlur(e) {
                if (!input.value.value) {
                  dateType.value = "text";
                }
                onBlur(e);
              }
              function onMouseEnter() {
                if (props.type === "date") {
                  dateType.value = "date";
                }
              }
              function onMouseLeave() {
                const el = document.activeElement;
                if (props.type === "date" && !input.value.value && el !== input.value) {
                  dateType.value = "text";
                }
              }
              return {
                computedClasses,
                localType,
                input,
                computedId,
                computedAriaInvalid,
                onInput,
                onChange,
                onBlur,
                focus,
                blur,
                highlight,
                onInputFocus,
                onInputBlur,
                onMouseEnter,
                onMouseLeave,
                dateType
              };
            }
          });
          ;
          ;
          ;
          const fsFormInput_exports_ = (0, exportHelper.Z)(fsFormInputvue_type_script_lang_ts, [["render", fsFormInputvue_type_template_id_99846fe6_ts_true_render]]);
          var fsFormInput = fsFormInput_exports_;
          ;
          const fsFormRadiovue_type_script_setup_true_lang_ts_hoisted_1 = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"];
          const fsFormRadiovue_type_script_setup_true_lang_ts_hoisted_2 = ["for"];
          const __default__ = {
            name: "fsFormRadio"
          };
          var fsFormRadiovue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            ...__default__,
            props: {
              ariaLabel: null,
              ariaLabelledBy: null,
              form: null,
              id: null,
              name: null,
              size: null,
              autofocus: {
                default: false
              },
              modelValue: {
                type: [Boolean, String, Array, Object, Number],
                default: void 0
              },
              plain: {
                default: false
              },
              button: {
                default: false
              },
              switch: {
                default: false
              },
              disabled: {
                default: false
              },
              buttonVariant: {
                default: "secondary"
              },
              inline: {
                default: false
              },
              required: {
                default: false
              },
              state: {
                type: Boolean,
                default: void 0
              },
              value: {
                type: [String, Boolean, Object, Number],
                default: true
              }
            },
            emits: ["input", "change", "update:modelValue"],
            setup(__props, {
              emit
            }) {
              const props = __props;
              const autofocusBoolean = useBooleanish((0, external_vue_.toRef)(props, "autofocus"));
              const plainBoolean = useBooleanish((0, external_vue_.toRef)(props, "plain"));
              const buttonBoolean = useBooleanish((0, external_vue_.toRef)(props, "button"));
              const switchBoolean = useBooleanish((0, external_vue_.toRef)(props, "switch"));
              const disabledBoolean = useBooleanish((0, external_vue_.toRef)(props, "disabled"));
              const inlineBoolean = useBooleanish((0, external_vue_.toRef)(props, "inline"));
              const requiredBoolean = useBooleanish((0, external_vue_.toRef)(props, "required"));
              const computedId = useId((0, external_vue_.toRef)(props, "id"), "form-check");
              const input = (0, external_vue_.ref)(null);
              const isFocused = (0, external_vue_.ref)(false);
              const localValue = (0, external_vue_.computed)({
                get: () => Array.isArray(props.modelValue) ? props.modelValue[0] : props.modelValue,
                set: (newValue) => {
                  const value = newValue !== null && newValue !== void 0 ? props.value : false;
                  const emitValue = Array.isArray(props.modelValue) ? [value] : value;
                  emit("input", emitValue);
                  emit("change", emitValue);
                  emit("update:modelValue", emitValue);
                }
              });
              const isChecked = (0, external_vue_.computed)(() => {
                if (Array.isArray(props.modelValue)) {
                  return (props.modelValue || []).find((e) => e === props.value);
                }
                return JSON.stringify(props.modelValue) === JSON.stringify(props.value);
              });
              const classesObject = (0, external_vue_.reactive)({
                plain: (0, external_vue_.toRef)(plainBoolean, "value"),
                button: (0, external_vue_.toRef)(buttonBoolean, "value"),
                inline: (0, external_vue_.toRef)(inlineBoolean, "value"),
                switch: (0, external_vue_.toRef)(switchBoolean, "value"),
                size: (0, external_vue_.toRef)(props, "size"),
                buttonVariant: (0, external_vue_.toRef)(props, "buttonVariant"),
                state: (0, external_vue_.toRef)(props, "state")
              });
              const classes = getClasses(classesObject);
              const inputClasses = getInputClasses(classesObject);
              const labelClasses = getLabelClasses(classesObject);
              (0, external_vue_.onMounted)(() => {
                if (autofocusBoolean.value) {
                  input.value.focus();
                }
              });
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(!(0, external_vue_.unref)(buttonBoolean) ? "div" : "label"), {
                  class: (0, external_vue_.normalizeClass)([(0, external_vue_.unref)(classes), , {
                    active: (0, external_vue_.unref)(isChecked),
                    focus: isFocused.value
                  }])
                }, {
                  default: (0, external_vue_.withCtx)(() => [(0, external_vue_.withDirectives)((0, external_vue_.createElementVNode)("input", (0, external_vue_.mergeProps)({
                    id: (0, external_vue_.unref)(computedId)
                  }, _ctx.$attrs, {
                    ref_key: "input",
                    ref: input,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => (0, external_vue_.isRef)(localValue) ? localValue.value = $event : null),
                    class: (0, external_vue_.unref)(inputClasses),
                    type: "radio",
                    disabled: (0, external_vue_.unref)(disabledBoolean),
                    required: !!__props.name && !!(0, external_vue_.unref)(requiredBoolean),
                    name: __props.name,
                    form: __props.form,
                    "aria-label": __props.ariaLabel,
                    "aria-labelledby": __props.ariaLabelledBy,
                    value: __props.value,
                    "aria-required": __props.name && (0, external_vue_.unref)(requiredBoolean) ? true : void 0,
                    onFocus: _cache[1] || (_cache[1] = ($event) => isFocused.value = true),
                    onBlur: _cache[2] || (_cache[2] = ($event) => isFocused.value = false)
                  }), null, 16, fsFormRadiovue_type_script_setup_true_lang_ts_hoisted_1), [[external_vue_.vModelRadio, (0, external_vue_.unref)(localValue)]]), (0, external_vue_.unref)(buttonBoolean) ? (0, external_vue_.renderSlot)(_ctx.$slots, "default", {
                    key: 0
                  }) : _ctx.$slots.default || !(0, external_vue_.unref)(plainBoolean) ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("label", {
                    key: 1,
                    for: (0, external_vue_.unref)(computedId),
                    class: (0, external_vue_.normalizeClass)([(0, external_vue_.unref)(labelClasses), {
                      active: (0, external_vue_.unref)(isChecked),
                      focus: isFocused.value
                    }])
                  }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")], 10, fsFormRadiovue_type_script_setup_true_lang_ts_hoisted_2)) : (0, external_vue_.createCommentVNode)("", true)]),
                  _: 3
                }, 8, ["class"]);
              };
            }
          });
          ;
          ;
          const fsFormRadio_exports_ = fsFormRadiovue_type_script_setup_true_lang_ts;
          var fsFormRadio = fsFormRadio_exports_;
          ;
          const fsFormRadioGroupvue_type_script_setup_true_lang_ts_hoisted_1 = ["id"];
          const fsFormRadioGroupvue_type_script_setup_true_lang_ts_hoisted_2 = ["innerHTML"];
          const fsFormRadioGroupvue_type_script_setup_true_lang_ts_hoisted_3 = ["textContent"];
          const fsFormRadioGroupvue_type_script_setup_true_lang_ts_default_ = {
            name: "fsFormRadioGroup"
          };
          var fsFormRadioGroupvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            ...fsFormRadioGroupvue_type_script_setup_true_lang_ts_default_,
            props: {
              size: null,
              form: null,
              id: null,
              name: null,
              modelValue: {
                type: [String, Boolean, Array, Object, Number],
                default: ""
              },
              ariaInvalid: {
                default: void 0
              },
              autofocus: {
                default: false
              },
              buttonVariant: {
                default: "secondary"
              },
              buttons: {
                default: false
              },
              disabled: {
                default: false
              },
              disabledField: {
                default: "disabled"
              },
              htmlField: {
                default: "html"
              },
              options: {
                default: () => []
              },
              plain: {
                default: false
              },
              required: {
                default: false
              },
              stacked: {
                default: false
              },
              state: {
                default: void 0
              },
              textField: {
                default: "text"
              },
              validated: {
                default: false
              },
              valueField: {
                default: "value"
              }
            },
            emits: ["input", "update:modelValue", "change"],
            setup(__props, {
              emit
            }) {
              const props = __props;
              const autofocusBoolean = useBooleanish((0, external_vue_.toRef)(props, "autofocus"));
              const buttonsBoolean = useBooleanish((0, external_vue_.toRef)(props, "buttons"));
              const disabledBoolean = useBooleanish((0, external_vue_.toRef)(props, "disabled"));
              const plainBoolean = useBooleanish((0, external_vue_.toRef)(props, "plain"));
              const requiredBoolean = useBooleanish((0, external_vue_.toRef)(props, "required"));
              const stackedBoolean = useBooleanish((0, external_vue_.toRef)(props, "stacked"));
              const stateBoolean = useBooleanish((0, external_vue_.toRef)(props, "state"));
              const validatedBoolean = useBooleanish((0, external_vue_.toRef)(props, "validated"));
              const slots = (0, external_vue_.useSlots)();
              const slotsName = "FsFormRadio";
              const computedId = useId((0, external_vue_.toRef)(props, "id"), "radio");
              const computedName = useId((0, external_vue_.toRef)(props, "name"), "checkbox");
              const localValue = (0, external_vue_.computed)({
                get: () => props.modelValue,
                set: (newValue) => {
                  emit("input", newValue);
                  emit("update:modelValue", newValue);
                  emit("change", newValue);
                }
              });
              const checkboxList = (0, external_vue_.computed)(() => (slots.first ? slotsToElements(slots.first(), slotsName, disabledBoolean.value) : []).concat(props.options.map((e) => optionToElement(e, props))).concat(slots.default ? slotsToElements(slots.default(), slotsName, disabledBoolean.value) : []).map((e, idx) => bindGroupProps(e, idx, props, computedName, computedId)).map((e) => ({
                ...e
              })));
              const classesObject = (0, external_vue_.reactive)({
                required: (0, external_vue_.toRef)(requiredBoolean, "value"),
                ariaInvalid: (0, external_vue_.toRef)(props, "ariaInvalid"),
                state: (0, external_vue_.toRef)(stateBoolean, "value"),
                validated: (0, external_vue_.toRef)(validatedBoolean, "value"),
                buttons: (0, external_vue_.toRef)(buttonsBoolean, "value"),
                stacked: (0, external_vue_.toRef)(stackedBoolean, "value"),
                size: (0, external_vue_.toRef)(props, "size")
              });
              const attrs = getGroupAttr(classesObject);
              const classes = getGroupClasses(classesObject);
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", (0, external_vue_.mergeProps)((0, external_vue_.unref)(attrs), {
                  id: (0, external_vue_.unref)(computedId),
                  role: "radiogroup",
                  class: [(0, external_vue_.unref)(classes), "bv-no-focus-ring"],
                  tabindex: "-1"
                }), [((0, external_vue_.openBlock)(true), (0, external_vue_.createElementBlock)(external_vue_.Fragment, null, (0, external_vue_.renderList)((0, external_vue_.unref)(checkboxList), (item, key) => {
                  return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(fsFormRadio, (0, external_vue_.mergeProps)({
                    key,
                    modelValue: (0, external_vue_.unref)(localValue),
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => (0, external_vue_.isRef)(localValue) ? localValue.value = $event : null)
                  }, item.props), {
                    default: (0, external_vue_.withCtx)(() => [item.html ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("span", {
                      key: 0,
                      innerHTML: item.html
                    }, null, 8, fsFormRadioGroupvue_type_script_setup_true_lang_ts_hoisted_2)) : ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("span", {
                      key: 1,
                      textContent: (0, external_vue_.toDisplayString)(item.text)
                    }, null, 8, fsFormRadioGroupvue_type_script_setup_true_lang_ts_hoisted_3))]),
                    _: 2
                  }, 1040, ["modelValue"]);
                }), 128))], 16, fsFormRadioGroupvue_type_script_setup_true_lang_ts_hoisted_1);
              };
            }
          });
          ;
          ;
          const fsFormRadioGroup_exports_ = fsFormRadioGroupvue_type_script_setup_true_lang_ts;
          var fsFormRadioGroup = fsFormRadioGroup_exports_;
          ;
          const fsFormSelectOptionvue_type_template_id_7c5eb2c4_ts_true_hoisted_1 = ["value", "disabled"];
          function fsFormSelectOptionvue_type_template_id_7c5eb2c4_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("option", {
              value: _ctx.value,
              disabled: _ctx.disabled
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")], 8, fsFormSelectOptionvue_type_template_id_7c5eb2c4_ts_true_hoisted_1);
          }
          ;
          ;
          var fsFormSelectOptionvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsFormSelectOption",
            props: {
              value: {
                default: ""
              },
              disabled: {
                type: Boolean,
                default: false
              }
            }
          });
          ;
          ;
          ;
          const fsFormSelectOption_exports_ = (0, exportHelper.Z)(fsFormSelectOptionvue_type_script_lang_ts, [["render", fsFormSelectOptionvue_type_template_id_7c5eb2c4_ts_true_render]]);
          var fsFormSelectOption = fsFormSelectOption_exports_;
          ;
          const fsFormSelectOptionGroupvue_type_template_id_62cf39ae_ts_true_hoisted_1 = ["label"];
          function fsFormSelectOptionGroupvue_type_template_id_62cf39ae_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _component_fs_form_select_option = (0, external_vue_.resolveComponent)("fs-form-select-option");
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("optgroup", {
              label: _ctx.label
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "first"), ((0, external_vue_.openBlock)(true), (0, external_vue_.createElementBlock)(external_vue_.Fragment, null, (0, external_vue_.renderList)(_ctx.formOptions, (option, index) => {
              return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(_component_fs_form_select_option, (0, external_vue_.mergeProps)({
                key: `option_${index}`,
                value: option.value,
                disabled: option.disabled
              }, _ctx.$attrs, {
                innerHTML: option.html || option.text
              }), null, 16, ["value", "disabled", "innerHTML"]);
            }), 128)), (0, external_vue_.renderSlot)(_ctx.$slots, "default")], 8, fsFormSelectOptionGroupvue_type_template_id_62cf39ae_ts_true_hoisted_1);
          }
          ;
          ;
          const fsFormSelectHelper_getNested = (obj, path) => {
            if (!obj)
              return obj;
            if (path in obj)
              return obj[path];
            const paths = path.split(".");
            return fsFormSelectHelper_getNested(obj[paths[0]], paths.splice(1).join("."));
          };
          const fsFormSelectHelper_normalizeOption = (option, key = null, componentName, props) => {
            if (Object.prototype.toString.call(option) === "[object Object]") {
              const value = fsFormSelectHelper_getNested(option, props.valueField);
              const text = fsFormSelectHelper_getNested(option, props.textField);
              const html = fsFormSelectHelper_getNested(option, props.htmlField);
              const disabled = fsFormSelectHelper_getNested(option, props.disabledField);
              const options = option[props.optionsField] || null;
              if (options !== null) {
                return {
                  label: String(fsFormSelectHelper_getNested(option, props.labelField) || text),
                  options: fsFormSelectHelper_normalizeOptions(options, componentName, props)
                };
              }
              return {
                value: typeof value === "undefined" ? key || text : value,
                text: String(typeof text === "undefined" ? key : text),
                html,
                disabled: Boolean(disabled)
              };
            }
            return {
              value: key || option,
              text: String(option),
              disabled: false
            };
          };
          const fsFormSelectHelper_normalizeOptions = (options, componentName, props) => {
            if (Array.isArray(options)) {
              return options.map((option) => fsFormSelectHelper_normalizeOption(option, null, componentName, props));
            } else if (Object.prototype.toString.call(options) === "[object Object]") {
              console.warn(`[fsVue warn]: ${componentName} - Setting prop "options" to an object is deprecated. Use the array format instead.`);
              return Object.keys(options).map((key) => {
                const el = options[key];
                switch (typeof el) {
                  case "object":
                    return fsFormSelectHelper_normalizeOption(el.text, String(el.value), componentName, props);
                  default:
                    return fsFormSelectHelper_normalizeOption(el, String(key), componentName, props);
                }
              });
            }
            return [];
          };
          ;
          var fsFormSelect_fsFormSelectOption = (0, external_vue_.defineComponent)({
            name: "FsFormSelectOption",
            props: {
              value: {
                default: ""
              },
              disabled: {
                type: Boolean,
                default: false
              }
            }
          });
          ;
          var fsFormSelectOptionGroupvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsFormSelectOptionGroup",
            props: {
              label: {
                type: String,
                required: true
              },
              disabledField: {
                type: String,
                default: "disabled"
              },
              htmlField: {
                type: String,
                default: "html"
              },
              options: {
                type: [Array, Object],
                default: () => []
              },
              textField: {
                type: String,
                default: "text"
              },
              valueField: {
                type: String,
                default: "value"
              }
            },
            emits: [],
            setup(props) {
              const formOptions = (0, external_vue_.computed)(() => {
                return fsFormSelectHelper_normalizeOptions(props.options, "fsFormSelectOptionGroup", props);
              });
              return {
                formOptions
              };
            },
            components: {
              FsFormSelectOption: fsFormSelect_fsFormSelectOption
            }
          });
          ;
          ;
          ;
          const fsFormSelectOptionGroup_exports_ = (0, exportHelper.Z)(fsFormSelectOptionGroupvue_type_script_lang_ts, [["render", fsFormSelectOptionGroupvue_type_template_id_62cf39ae_ts_true_render]]);
          var fsFormSelectOptionGroup = fsFormSelectOptionGroup_exports_;
          ;
          const fsFormSelectvue_type_script_setup_true_lang_ts_hoisted_1 = ["id", "name", "form", "multiple", "size", "disabled", "required"];
          var fsFormSelectvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsFormSelect",
            props: {
              autofocus: {
                default: false
              },
              disabled: {
                default: false
              },
              disabledField: {
                default: "disabled"
              },
              form: null,
              htmlField: {
                default: "html"
              },
              id: null,
              labelField: {
                default: "label"
              },
              multiple: {
                default: false
              },
              name: null,
              options: {
                default: () => []
              },
              optionsField: {
                default: "options"
              },
              plain: {
                default: false
              },
              required: {
                default: false
              },
              selectSize: {
                default: 0
              },
              size: null,
              state: {
                default: void 0
              },
              textField: {
                default: "text"
              },
              valueField: {
                default: "value"
              },
              modelValue: {
                default: ""
              }
            },
            emits: ["input", "update:modelValue", "change"],
            setup(__props, {
              expose,
              emit
            }) {
              const props = __props;
              const autofocusBoolean = useBooleanish((0, external_vue_.toRef)(props, "autofocus"));
              const disabledBoolean = useBooleanish((0, external_vue_.toRef)(props, "disabled"));
              const multipleBoolean = useBooleanish((0, external_vue_.toRef)(props, "multiple"));
              const plainBoolean = useBooleanish((0, external_vue_.toRef)(props, "plain"));
              const requiredBoolean = useBooleanish((0, external_vue_.toRef)(props, "required"));
              const stateBoolean = useBooleanish((0, external_vue_.toRef)(props, "state"));
              const input = (0, external_vue_.ref)();
              const computedId = useId((0, external_vue_.toRef)(props, "id"), "input");
              const handleAutofocus = () => {
                (0, external_vue_.nextTick)(() => {
                  var _a;
                  if (autofocusBoolean.value)
                    (_a = input.value) == null ? void 0 : _a.focus();
                });
              };
              (0, external_vue_.onMounted)(handleAutofocus);
              (0, external_vue_.onActivated)(handleAutofocus);
              const classes = (0, external_vue_.computed)(() => ({
                "form-control": plainBoolean.value,
                [`form-control-${props.size}`]: props.size && plainBoolean.value,
                "form-select": !plainBoolean.value,
                [`form-select-${props.size}`]: props.size && !plainBoolean.value
              }));
              const computedSelectSize = (0, external_vue_.computed)(() => {
                if (props.selectSize || plainBoolean.value) {
                  return props.selectSize;
                }
                return void 0;
              });
              const formOptions = (0, external_vue_.computed)(() => normalizeOptions(props.options, "FsFormSelect", props));
              const localValue = (0, external_vue_.computed)({
                get() {
                  return props.modelValue;
                },
                set(newValue) {
                  emit("change", newValue);
                  emit("update:modelValue", newValue);
                  emit("input", newValue);
                }
              });
              const focus = () => {
                var _a;
                if (!disabledBoolean.value)
                  (_a = input.value) == null ? void 0 : _a.focus();
              };
              const blur = () => {
                var _a;
                if (!disabledBoolean.value) {
                  (_a = input.value) == null ? void 0 : _a.blur();
                }
              };
              expose({
                blur,
                focus
              });
              return (_ctx, _cache) => {
                return (0, external_vue_.withDirectives)(((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("select", {
                  id: (0, external_vue_.unref)(computedId),
                  ref_key: "input",
                  ref: input,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => (0, external_vue_.isRef)(localValue) ? localValue.value = $event : null),
                  class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(classes)),
                  name: __props.name,
                  form: __props.form || void 0,
                  multiple: (0, external_vue_.unref)(multipleBoolean) || void 0,
                  size: (0, external_vue_.unref)(computedSelectSize),
                  disabled: (0, external_vue_.unref)(disabledBoolean),
                  required: (0, external_vue_.unref)(requiredBoolean)
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "first"), ((0, external_vue_.openBlock)(true), (0, external_vue_.createElementBlock)(external_vue_.Fragment, null, (0, external_vue_.renderList)((0, external_vue_.unref)(formOptions), (option, index) => {
                  return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)(external_vue_.Fragment, null, [Array.isArray(option.options) ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(fsFormSelectOptionGroup, {
                    key: `option_${index}`,
                    label: option.label,
                    options: option.options
                  }, null, 8, ["label", "options"])) : ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(fsFormSelectOption, {
                    key: `option2_${index}`,
                    value: option.value,
                    disabled: option.disabled,
                    innerHTML: option.html || option.text
                  }, null, 8, ["value", "disabled", "innerHTML"]))], 64);
                }), 256)), (0, external_vue_.renderSlot)(_ctx.$slots, "default")], 10, fsFormSelectvue_type_script_setup_true_lang_ts_hoisted_1)), [[external_vue_.vModelSelect, (0, external_vue_.unref)(localValue)]]);
              };
            }
          });
          ;
          ;
          const fsFormSelect_exports_ = fsFormSelectvue_type_script_setup_true_lang_ts;
          var fsFormSelect = fsFormSelect_exports_;
          ;
          const fsFormTextareavue_type_template_id_25025cce_ts_true_hoisted_1 = ["id", "name", "form", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"];
          function fsFormTextareavue_type_template_id_25025cce_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("textarea", (0, external_vue_.mergeProps)({
              id: _ctx.computedId,
              ref: "input",
              class: _ctx.computedClasses,
              name: _ctx.name || void 0,
              form: _ctx.form || void 0,
              disabled: _ctx.disabled,
              placeholder: _ctx.placeholder,
              required: _ctx.required,
              autocomplete: _ctx.autocomplete || void 0,
              readonly: _ctx.readonly || _ctx.plaintext,
              "aria-required": _ctx.required ? true : void 0,
              "aria-invalid": _ctx.computedAriaInvalid,
              rows: _ctx.rows,
              style: _ctx.computedStyles,
              wrap: _ctx.wrap || void 0
            }, _ctx.$attrs, {
              onInput: _cache[0] || (_cache[0] = ($event) => _ctx.onInput($event)),
              onChange: _cache[1] || (_cache[1] = ($event) => _ctx.onChange($event)),
              onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.onBlur($event))
            }), null, 16, fsFormTextareavue_type_template_id_25025cce_ts_true_hoisted_1);
          }
          ;
          ;
          var fsFormTextareavue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            props: {
              ...COMMON_INPUT_PROPS,
              noResize: {
                type: [Boolean, String],
                default: false
              },
              rows: {
                type: [String, Number],
                required: false,
                default: 2
              },
              wrap: {
                type: String,
                default: "soft"
              }
            },
            emits: ["update:modelValue", "change", "blur", "input"],
            setup(props, {
              emit
            }) {
              const {
                input,
                computedId,
                computedAriaInvalid,
                onInput,
                onChange,
                onBlur,
                focus,
                blur
              } = useFormInput(props, emit);
              const noResizeBoolean = useBooleanish((0, external_vue_.toRef)(props, "noResize"));
              const computedClasses = (0, external_vue_.computed)(() => ({
                "form-control": !props.plaintext,
                "form-control-plaintext": props.plaintext,
                [`form-control-${props.size}`]: !!props.size,
                "is-valid": props.state === true,
                "is-invalid": props.state === false
              }));
              const computedStyles = (0, external_vue_.computed)(() => ({
                resize: noResizeBoolean.value ? "none" : void 0
              }));
              return {
                input,
                computedId,
                computedAriaInvalid,
                onInput,
                onChange,
                onBlur,
                focus,
                blur,
                computedClasses,
                computedStyles
              };
            }
          });
          ;
          ;
          ;
          const fsFormTextarea_exports_ = (0, exportHelper.Z)(fsFormTextareavue_type_script_lang_ts, [["render", fsFormTextareavue_type_template_id_25025cce_ts_true_render]]);
          var fsFormTextarea = fsFormTextarea_exports_;
          ;
          var fsImgvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsImg",
            props: {
              alt: null,
              blank: {
                default: false
              },
              blankColor: {
                default: "transparent"
              },
              block: {
                default: false
              },
              center: {
                default: false
              },
              fluid: {
                default: false
              },
              lazy: {
                default: false
              },
              fluidGrow: {
                default: false
              },
              height: null,
              left: {
                default: false
              },
              start: {
                default: false
              },
              right: {
                default: false
              },
              end: {
                default: false
              },
              rounded: {
                type: [Boolean, String],
                default: false
              },
              sizes: null,
              src: null,
              srcset: null,
              thumbnail: {
                default: false
              },
              width: null
            },
            emits: ["load"],
            setup(__props, {
              emit
            }) {
              const props = __props;
              const BLANK_TEMPLATE = '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>';
              const lazyBoolean = useBooleanish((0, external_vue_.toRef)(props, "lazy"));
              const blankBoolean = useBooleanish((0, external_vue_.toRef)(props, "blank"));
              const blockBoolean = useBooleanish((0, external_vue_.toRef)(props, "block"));
              const centerBoolean = useBooleanish((0, external_vue_.toRef)(props, "center"));
              const fluidBoolean = useBooleanish((0, external_vue_.toRef)(props, "fluid"));
              const fluidGrowBoolean = useBooleanish((0, external_vue_.toRef)(props, "fluidGrow"));
              const leftBoolean = useBooleanish((0, external_vue_.toRef)(props, "left"));
              const startBoolean = useBooleanish((0, external_vue_.toRef)(props, "start"));
              const rightBoolean = useBooleanish((0, external_vue_.toRef)(props, "right"));
              const endBoolean = useBooleanish((0, external_vue_.toRef)(props, "end"));
              const thumbnailBoolean = useBooleanish((0, external_vue_.toRef)(props, "thumbnail"));
              const computedSrcset = (0, external_vue_.computed)(() => typeof props.srcset === "string" ? props.srcset.split(",").filter((x) => x).join(",") : Array.isArray(props.srcset) ? props.srcset.filter((x) => x).join(",") : void 0);
              const computedSizes = (0, external_vue_.computed)(() => typeof props.sizes === "string" ? props.sizes.split(",").filter((x) => x).join(",") : Array.isArray(props.sizes) ? props.sizes.filter((x) => x).join(",") : void 0);
              const computedDimentions = (0, external_vue_.computed)(() => {
                const parser = (str) => str === void 0 ? void 0 : typeof str === "number" ? str : Number.parseInt(str, 10) || void 0;
                const width = parser(props.width);
                const height = parser(props.height);
                if (blankBoolean.value) {
                  if (width !== void 0 && height === void 0) {
                    return {
                      height: width,
                      width
                    };
                  }
                  if (width === void 0 && height !== void 0) {
                    return {
                      height,
                      width: height
                    };
                  }
                  if (width === void 0 && height === void 0) {
                    return {
                      height: 1,
                      width: 1
                    };
                  }
                }
                return {
                  width,
                  height
                };
              });
              const computedBlankImgSrc = (0, external_vue_.computed)(() => makeBlankImgSrc(computedDimentions.value.width, computedDimentions.value.height, props.blankColor));
              const computedAttrs = (0, external_vue_.computed)(() => ({
                src: !blankBoolean.value ? props.src : computedBlankImgSrc.value,
                alt: props.alt,
                width: computedDimentions.value.width || void 0,
                height: computedDimentions.value.height || void 0,
                srcset: !blankBoolean.value ? computedSrcset.value : void 0,
                sizes: !blankBoolean.value ? computedSizes.value : void 0,
                loading: lazyBoolean.value ? "lazy" : "eager"
              }));
              const alignment = (0, external_vue_.computed)(() => leftBoolean.value || startBoolean.value ? "float-start" : rightBoolean.value || endBoolean.value ? "float-end" : centerBoolean.value ? "mx-auto" : void 0);
              const computedClasses = (0, external_vue_.computed)(() => ({
                "img-thumbnail": thumbnailBoolean.value,
                "img-fluid": fluidBoolean.value || fluidGrowBoolean.value,
                "w-100": fluidGrowBoolean.value,
                "rounded": props.rounded === "" || props.rounded === true,
                [`rounded-${props.rounded}`]: typeof props.rounded === "string" && props.rounded !== "",
                [`${alignment.value}`]: alignment.value !== void 0,
                "d-block": blockBoolean.value || centerBoolean.value
              }));
              const makeBlankImgSrc = (width, height, color) => {
                const src2 = encodeURIComponent(BLANK_TEMPLATE.replace("%{w}", String(width)).replace("%{h}", String(height)).replace("%{f}", color));
                return `data:image/svg+xml;charset=UTF-8,${src2}`;
              };
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("img", (0, external_vue_.mergeProps)({
                  class: (0, external_vue_.unref)(computedClasses)
                }, (0, external_vue_.unref)(computedAttrs), {
                  onLoad: _cache[0] || (_cache[0] = ($event) => emit("load", $event))
                }), null, 16);
              };
            }
          });
          ;
          ;
          const fsImg_exports_ = fsImgvue_type_script_setup_true_lang_ts;
          var fsImg = fsImg_exports_;
          ;
          const fsInputGroupvue_type_template_id_c7e7853c_ts_true_hoisted_1 = ["innerHTML"];
          const fsInputGroupvue_type_template_id_c7e7853c_ts_true_hoisted_2 = {
            key: 1
          };
          const fsInputGroupvue_type_template_id_c7e7853c_ts_true_hoisted_3 = ["innerHTML"];
          const fsInputGroupvue_type_template_id_c7e7853c_ts_true_hoisted_4 = {
            key: 1
          };
          function fsInputGroupvue_type_template_id_c7e7853c_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _component_fs_input_group_text = (0, external_vue_.resolveComponent)("fs-input-group-text");
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag), {
              class: (0, external_vue_.normalizeClass)(["input-group", _ctx.computedClass]),
              role: "group"
            }, {
              default: (0, external_vue_.withCtx)(() => [_ctx.hasPrepend ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(_component_fs_input_group_text, {
                key: 0
              }, {
                default: (0, external_vue_.withCtx)(() => [_ctx.showPrependHtml ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("span", {
                  key: 0,
                  innerHTML: _ctx.prependHtml
                }, null, 8, fsInputGroupvue_type_template_id_c7e7853c_ts_true_hoisted_1)) : ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("span", fsInputGroupvue_type_template_id_c7e7853c_ts_true_hoisted_2, (0, external_vue_.toDisplayString)(_ctx.prepend), 1))]),
                _: 1
              })) : _ctx.hasPrependSlot ? (0, external_vue_.renderSlot)(_ctx.$slots, "prepend", {
                key: 1
              }) : (0, external_vue_.createCommentVNode)("", true), (0, external_vue_.renderSlot)(_ctx.$slots, "default"), _ctx.hasAppend ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(_component_fs_input_group_text, {
                key: 2
              }, {
                default: (0, external_vue_.withCtx)(() => [_ctx.showAppendHtml ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("span", {
                  key: 0,
                  innerHTML: _ctx.appendHtml
                }, null, 8, fsInputGroupvue_type_template_id_c7e7853c_ts_true_hoisted_3)) : ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("span", fsInputGroupvue_type_template_id_c7e7853c_ts_true_hoisted_4, (0, external_vue_.toDisplayString)(_ctx.append), 1))]),
                _: 1
              })) : _ctx.hasAppendSlot ? (0, external_vue_.renderSlot)(_ctx.$slots, "append", {
                key: 3
              }) : (0, external_vue_.createCommentVNode)("", true)]),
              _: 3
            }, 8, ["class"]);
          }
          ;
          ;
          function fsInputGroupTextvue_type_template_id_c9b5894c_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag), {
              class: "input-group-text"
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            });
          }
          ;
          ;
          var fsInputGroupTextvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsInputGroupText",
            props: {
              tag: {
                type: String,
                default: "div"
              }
            },
            emits: []
          });
          ;
          ;
          ;
          const fsInputGroupText_exports_ = (0, exportHelper.Z)(fsInputGroupTextvue_type_script_lang_ts, [["render", fsInputGroupTextvue_type_template_id_c9b5894c_ts_true_render]]);
          var fsInputGroupText = fsInputGroupText_exports_;
          ;
          var fsInputGroupvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsInputGroup",
            props: {
              append: {
                type: String
              },
              appendHtml: {
                type: String
              },
              id: {
                type: String
              },
              prepend: {
                type: String
              },
              prependHtml: {
                type: String
              },
              size: {
                type: String
              },
              tag: {
                type: String,
                default: "div"
              }
            },
            components: {
              fsInputGroupText
            },
            emits: [],
            setup(props, {
              slots
            }) {
              const computedClass = (0, external_vue_.computed)(() => {
                return {
                  "input-group-sm": props.size === "sm",
                  "input-group-lg": props.size === "lg"
                };
              });
              const hasAppend = (0, external_vue_.computed)(() => {
                return !!(props.append || props.appendHtml);
              });
              const hasPrepend = (0, external_vue_.computed)(() => {
                return !!(props.prepend || props.prependHtml);
              });
              const showAppendHtml = (0, external_vue_.computed)(() => {
                return !!props.appendHtml;
              });
              const showPrependHtml = (0, external_vue_.computed)(() => {
                return !!props.prependHtml;
              });
              const hasAppendSlot = (0, external_vue_.computed)(() => {
                return !!slots.append;
              });
              const hasPrependSlot = (0, external_vue_.computed)(() => {
                return !!slots.prepend;
              });
              return {
                computedClass,
                hasAppend,
                hasPrepend,
                showAppendHtml,
                showPrependHtml,
                hasAppendSlot,
                hasPrependSlot
              };
            }
          });
          ;
          ;
          ;
          const fsInputGroup_exports_ = (0, exportHelper.Z)(fsInputGroupvue_type_script_lang_ts, [["render", fsInputGroupvue_type_template_id_c7e7853c_ts_true_render]]);
          var fsInputGroup = fsInputGroup_exports_;
          ;
          function fsLinkvue_type_template_id_38eb7dfe_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _component_fs_router_link = (0, external_vue_.resolveComponent)("fs-router-link");
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(_component_fs_router_link, {
              class: (0, external_vue_.normalizeClass)(_ctx.computedClass),
              onClick: _ctx.clicked,
              to: _ctx.to,
              href: _ctx.configuredHref,
              target: _ctx.target
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 8, ["class", "onClick", "to", "href", "target"]);
          }
          ;
          ;
          var fsLinkvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsLink",
            props: {
              active: {
                type: Boolean,
                default: false
              },
              activeClass: {
                type: String
              },
              append: {
                type: Boolean,
                default: false
              },
              disabled: {
                type: Boolean,
                default: false
              },
              event: {
                type: [Array, String]
              },
              exact: {
                type: Boolean,
                default: false
              },
              exactActiveClass: {
                type: String
              },
              exactPath: {
                type: Boolean,
                default: false
              },
              exactPathActiveClass: {
                type: String
              },
              href: {
                type: String,
                default: "#"
              },
              noPrefetch: {
                type: Boolean,
                default: false
              },
              prefetch: {
                type: Boolean,
                default: null
              },
              rel: {
                type: String,
                default: null
              },
              replace: {
                type: Boolean,
                default: false
              },
              routerComponentName: {
                type: String
              },
              routerTag: {
                type: String
              },
              target: {
                type: String,
                default: "_self"
              },
              to: {
                type: [Object, String]
              }
            },
            components: {
              FsRouterLink: fsRouterLink
            },
            emits: ["click"],
            setup(props, {
              emit
            }) {
              const instance = (0, external_vue_.getCurrentInstance)();
              const computedClass = (0, external_vue_.computed)(() => {
                return {
                  [`${props.activeClass}`]: props.active,
                  [`disabled`]: props.disabled
                };
              });
              function clicked(e) {
                if (props.disabled) {
                  preventDefaultOnClick(e);
                  return;
                } else if (instance.proxy.$router && props.href === "#") {
                  preventDefaultOnClick(e);
                }
                emit("click", e);
              }
              function preventDefaultOnClick(e) {
                e.preventDefault();
                e.stopPropagation();
              }
              const configuredHref = configureHref(props.to, props.href, props.append, instance);
              return {
                computedClass,
                configuredHref,
                clicked
              };
            }
          });
          ;
          ;
          ;
          const fsLink_exports_ = (0, exportHelper.Z)(fsLinkvue_type_script_lang_ts, [["render", fsLinkvue_type_template_id_38eb7dfe_ts_true_render]]);
          var fsLink = fsLink_exports_;
          ;
          function fsListGroupvue_type_template_id_7d992572_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.calculatedIs), {
              class: (0, external_vue_.normalizeClass)(["list-group", _ctx.computedClass])
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 8, ["class"]);
          }
          ;
          ;
          var fsListGroupvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsListGroup",
            props: {
              flush: {
                type: Boolean,
                default: false
              },
              horizontal: {
                type: [Boolean, String],
                default: false
              },
              tag: {
                type: String,
                default: "div"
              }
            },
            emits: [],
            setup(props) {
              const calculatedIs = (0, external_vue_.computed)(() => {
                return props.tag;
              });
              const computedClass = (0, external_vue_.computed)(() => {
                return {
                  [`list-group-horizontal-${props.horizontal}`]: typeof props.horizontal === "string",
                  ["list-group-horizontal"]: props.horizontal === true,
                  ["list-group-flush"]: props.flush
                };
              });
              return {
                calculatedIs,
                computedClass
              };
            }
          });
          ;
          ;
          ;
          const fsListGroup_exports_ = (0, exportHelper.Z)(fsListGroupvue_type_script_lang_ts, [["render", fsListGroupvue_type_template_id_7d992572_ts_true_render]]);
          var fsListGroup = fsListGroup_exports_;
          ;
          function fsListGroupItemvue_type_template_id_55e8076a_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _component_fs_router_link = (0, external_vue_.resolveComponent)("fs-router-link");
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(_component_fs_router_link, {
              class: (0, external_vue_.normalizeClass)(["list-group-item", _ctx.computedClass]),
              tag: _ctx.computedTag
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 8, ["class", "tag"]);
          }
          ;
          ;
          var fsListGroupItemvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsListGroupItem",
            props: {
              action: {
                type: Boolean,
                default: false
              },
              active: {
                type: Boolean,
                default: false
              },
              activeClass: {
                type: String
              },
              append: {
                type: Boolean,
                default: false
              },
              button: {
                type: Boolean,
                default: false
              },
              disabled: {
                type: Boolean,
                default: false
              },
              exact: {
                type: Boolean,
                default: false
              },
              exactActiveClass: {
                type: String
              },
              exactPath: {
                type: Boolean,
                default: false
              },
              exactPathActiveClass: {
                type: String
              },
              href: {
                type: String
              },
              noPrefetch: {
                type: Boolean,
                default: false
              },
              prefetch: {
                type: Boolean,
                default: null
              },
              rel: {
                type: String,
                default: null
              },
              replace: {
                type: Boolean,
                default: false
              },
              routerComponentName: {
                type: String
              },
              tag: {
                type: String,
                default: "div"
              },
              target: {
                type: String,
                default: "_self"
              },
              to: {
                type: [Object, String]
              },
              variant: {
                type: String
              }
            },
            components: {
              FsRouterLink: fsRouterLink
            },
            emits: [],
            setup(props) {
              const computedClass = (0, external_vue_.computed)(() => {
                return {
                  [`list-group-item-${props.variant}`]: props.variant,
                  ["list-group-item-action"]: props.action || props.button || props.href || props.to,
                  ["active"]: props.active,
                  [`disabled`]: props.disabled
                };
              });
              const computedTag = (0, external_vue_.computed)(() => {
                if (props.button) {
                  return "button";
                } else if (props.href || props.to) {
                  return "a";
                } else {
                  return props.tag;
                }
              });
              return {
                computedClass,
                computedTag
              };
            }
          });
          ;
          ;
          ;
          const fsListGroupItem_exports_ = (0, exportHelper.Z)(fsListGroupItemvue_type_script_lang_ts, [["render", fsListGroupItemvue_type_template_id_55e8076a_ts_true_render]]);
          var fsListGroupItem = fsListGroupItem_exports_;
          ;
          const fsModalvue_type_script_setup_true_lang_ts_hoisted_1 = ["id"];
          const fsModalvue_type_script_setup_true_lang_ts_hoisted_2 = ["data-bs-theme"];
          const fsModalvue_type_script_setup_true_lang_ts_hoisted_3 = ["aria-label", "white"];
          const fsModalvue_type_script_setup_true_lang_ts_default_ = {
            inheritAttrs: false
          };
          var fsModalvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            ...fsModalvue_type_script_setup_true_lang_ts_default_,
            __name: "fsModal",
            props: {
              bodyBgVariant: null,
              bodyClass: null,
              bodyTextVariant: null,
              busy: {
                default: false
              },
              lazy: {
                default: false
              },
              buttonSize: {
                default: "md"
              },
              cancelDisabled: {
                default: false
              },
              cancelTitle: {
                default: "Cancel"
              },
              cancelVariant: {
                default: "secondary"
              },
              centered: {
                default: false
              },
              contentClass: null,
              dialogClass: null,
              footerBgVariant: null,
              footerBorderVariant: null,
              footerClass: null,
              footerTextVariant: null,
              fullscreen: {
                type: [Boolean, String],
                default: false
              },
              headerBgVariant: null,
              headerBorderVariant: null,
              headerClass: null,
              headerCloseLabel: {
                default: "Close"
              },
              headerCloseWhite: {
                default: false
              },
              headerTextVariant: null,
              hideBackdrop: {
                default: false
              },
              hideFooter: {
                default: false
              },
              hideHeader: {
                default: false
              },
              hideHeaderClose: {
                default: false
              },
              id: null,
              modalClass: null,
              modelValue: {
                default: false
              },
              noCloseOnBackdrop: {
                default: false
              },
              noCloseOnEsc: {
                default: false
              },
              noFade: {
                default: false
              },
              noFocus: {
                default: false
              },
              okDisabled: {
                default: false
              },
              okOnly: {
                default: false
              },
              okTitle: {
                default: "Ok"
              },
              okVariant: {
                default: "primary"
              },
              scrollable: {
                default: false
              },
              show: {
                default: false
              },
              size: null,
              title: null,
              titleClass: null,
              titleSrOnly: {
                default: false
              },
              titleTag: {
                default: "h5"
              }
            },
            emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "ok", "cancel", "close"],
            setup(__props, {
              emit
            }) {
              const props = __props;
              const busyBoolean = useBooleanish((0, external_vue_.toRef)(props, "busy"));
              const lazyBoolean = useBooleanish((0, external_vue_.toRef)(props, "lazy"));
              const cancelDisabledBoolean = useBooleanish((0, external_vue_.toRef)(props, "cancelDisabled"));
              const centeredBoolean = useBooleanish((0, external_vue_.toRef)(props, "centered"));
              const headerCloseWhiteBoolean = useBooleanish((0, external_vue_.toRef)(props, "headerCloseWhite"));
              const hideBackdropBoolean = useBooleanish((0, external_vue_.toRef)(props, "hideBackdrop"));
              const hideFooterBoolean = useBooleanish((0, external_vue_.toRef)(props, "hideFooter"));
              const hideHeaderBoolean = useBooleanish((0, external_vue_.toRef)(props, "hideHeader"));
              const hideHeaderCloseBoolean = useBooleanish((0, external_vue_.toRef)(props, "hideHeaderClose"));
              const modelValueBoolean = useBooleanish((0, external_vue_.toRef)(props, "modelValue"));
              const noCloseOnBackdropBoolean = useBooleanish((0, external_vue_.toRef)(props, "noCloseOnBackdrop"));
              const noCloseOnEscBoolean = useBooleanish((0, external_vue_.toRef)(props, "noCloseOnEsc"));
              const noFadeBoolean = useBooleanish((0, external_vue_.toRef)(props, "noFade"));
              const noFocusBoolean = useBooleanish((0, external_vue_.toRef)(props, "noFocus"));
              const okDisabledBoolean = useBooleanish((0, external_vue_.toRef)(props, "okDisabled"));
              const okOnlyBoolean = useBooleanish((0, external_vue_.toRef)(props, "okOnly"));
              const scrollableBoolean = useBooleanish((0, external_vue_.toRef)(props, "scrollable"));
              const showBoolean = useBooleanish((0, external_vue_.toRef)(props, "show"));
              const titleSrOnlyBoolean = useBooleanish((0, external_vue_.toRef)(props, "titleSrOnly"));
              const lazyLoadCompleted = (0, external_vue_.ref)(false);
              const computedId = useId((0, external_vue_.toRef)(props, "id"), "modal");
              const element = (0, external_vue_.ref)();
              const instance = (0, external_vue_.ref)();
              const modalClasses = (0, external_vue_.computed)(() => [{
                fade: !noFadeBoolean.value,
                show: showBoolean.value
              }, props.modalClass]);
              const modalDialogClasses = (0, external_vue_.computed)(() => [{
                "modal-fullscreen": props.fullscreen === true,
                [`modal-fullscreen-${props.fullscreen}-down`]: typeof props.fullscreen === "string",
                [`modal-${props.size}`]: props.size !== void 0,
                "modal-dialog-centered": centeredBoolean.value,
                "modal-dialog-scrollable": scrollableBoolean.value
              }, props.dialogClass]);
              const computedBodyClasses = (0, external_vue_.computed)(() => [{
                [`bg-${props.bodyBgVariant}`]: props.bodyBgVariant,
                [`text-${props.bodyTextVariant}`]: props.bodyTextVariant
              }, props.bodyClass]);
              const computedHeaderClasses = (0, external_vue_.computed)(() => [{
                [`bg-${props.headerBgVariant}`]: props.headerBgVariant,
                [`border-${props.headerBorderVariant}`]: props.headerBorderVariant,
                [`text-${props.headerTextVariant}`]: props.headerTextVariant
              }, props.headerClass]);
              const computedCloseClass = (0, external_vue_.computed)(() => [{
                [`text-${props.headerTextVariant}`]: props.headerTextVariant
              }]);
              const computedFooterClasses = (0, external_vue_.computed)(() => [{
                [`bg-${props.footerBgVariant}`]: props.footerBgVariant,
                [`border-${props.footerBorderVariant}`]: props.footerBorderVariant,
                [`text-${props.footerTextVariant}`]: props.footerTextVariant
              }, props.footerClass]);
              const computedTitleClasses = (0, external_vue_.computed)(() => [{
                ["visually-hidden"]: titleSrOnlyBoolean.value
              }, props.titleClass]);
              const computedHeaderTheme = (0, external_vue_.computed)(() => {
                return props.headerTextVariant === "light" ? "dark" : "";
              });
              const disableCancel = (0, external_vue_.computed)(() => cancelDisabledBoolean.value || busyBoolean.value);
              const disableOk = (0, external_vue_.computed)(() => okDisabledBoolean.value || busyBoolean.value);
              useEventListener(element, "shown.bs.modal", (e) => modalShowed(e));
              useEventListener(element, "hidden.bs.modal", (e) => modalHided(e));
              useEventListener(element, "show.bs.modal", (e) => modalShow(e));
              useEventListener(element, "hide.bs.modal", (e) => modalHide(e));
              const modalShowed = (e) => {
                emit("shown", e);
                if (lazyBoolean.value === true)
                  lazyLoadCompleted.value = true;
                if (modelValueBoolean.value === false)
                  emit("update:modelValue", true);
                e.target.focus();
              };
              const modalHided = (e) => {
                emit("hidden", e);
                if (lazyBoolean.value === true)
                  lazyLoadCompleted.value = false;
                if (modelValueBoolean.value === true)
                  emit("update:modelValue", false);
                const parentModal = document.querySelector(".modal");
                if (parentModal) {
                  ;
                  parentModal.focus();
                }
              };
              const modalShow = (e) => {
                emit("show", e);
              };
              const modalHide = (e) => {
                emit("hide", e);
              };
              const show = () => {
                if (modelValueBoolean.value)
                  emit("update:modelValue", true);
                getInstance().show();
              };
              const hide = () => {
                if (modelValueBoolean.value)
                  emit("update:modelValue", false);
                getInstance().hide();
              };
              const getInstance = () => {
                if (instance.value !== void 0)
                  return instance.value;
                instance.value = new external_bootstrap_.Modal(element.value, {
                  backdrop: false,
                  keyboard: !noCloseOnEscBoolean.value,
                  focus: !noFocusBoolean.value
                });
                return instance.value;
              };
              const cancelClicked = (e) => {
                emit("cancel", e);
                hide();
              };
              const closeClicked = (e) => {
                emit("close", e);
                hide();
              };
              const okClicked = (e) => {
                emit("ok", e);
                hide();
              };
              (0, external_vue_.onMounted)(() => {
                if (modelValueBoolean.value) {
                  getInstance().show();
                }
              });
              (0, external_vue_.onBeforeUnmount)(() => {
                var _a;
                (_a = instance.value) == null ? void 0 : _a.hide();
                instance.value = void 0;
              });
              (0, external_vue_.watch)(() => props.noCloseOnBackdrop, (newValue) => {
                ;
                getInstance()._config.backdrop = props.hideBackdrop ? false : newValue ? "static" : !props.hideBackdrop;
              });
              (0, external_vue_.watch)(() => props.noCloseOnEsc, (newValue) => {
                ;
                getInstance()._config.keyboard = !newValue;
              });
              (0, external_vue_.watch)(() => modelValueBoolean.value, (value) => {
                (0, external_vue_.nextTick)(() => {
                  if (value) {
                    show();
                  } else {
                    hide();
                  }
                });
              });
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(external_vue_.Teleport, {
                  to: "body"
                }, [(0, external_vue_.createElementVNode)("div", {
                  id: (0, external_vue_.unref)(computedId),
                  ref_key: "element",
                  ref: element,
                  class: (0, external_vue_.normalizeClass)(["modal", (0, external_vue_.unref)(modalClasses)]),
                  tabindex: "-1"
                }, [(0, external_vue_.createElementVNode)("div", {
                  class: (0, external_vue_.normalizeClass)(["modal-dialog", (0, external_vue_.unref)(modalDialogClasses)])
                }, [!(0, external_vue_.unref)(lazyBoolean) || (0, external_vue_.unref)(lazyBoolean) && lazyLoadCompleted.value || (0, external_vue_.unref)(lazyBoolean) && (0, external_vue_.unref)(modelValueBoolean) === true ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                  key: 0,
                  class: (0, external_vue_.normalizeClass)(["modal-content", __props.contentClass])
                }, [!(0, external_vue_.unref)(hideHeaderBoolean) ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                  key: 0,
                  class: (0, external_vue_.normalizeClass)(["modal-header", (0, external_vue_.unref)(computedHeaderClasses)]),
                  "data-bs-theme": (0, external_vue_.unref)(computedHeaderTheme)
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "modal-header", {
                  ok: okClicked,
                  cancel: cancelClicked,
                  hide,
                  close: closeClicked
                }, () => [((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(__props.titleTag), {
                  class: (0, external_vue_.normalizeClass)(["modal-title", (0, external_vue_.unref)(computedTitleClasses)])
                }, {
                  default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "modal-title", {
                    ok: okClicked,
                    cancel: cancelClicked,
                    hide,
                    close: closeClicked
                  }, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(__props.title), 1)])]),
                  _: 3
                }, 8, ["class"])), !(0, external_vue_.unref)(hideHeaderCloseBoolean) ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)(external_vue_.Fragment, {
                  key: 0
                }, [_ctx.$slots["modal-header-close"] ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("button", {
                  key: 0,
                  type: "button",
                  "data-bs-dismiss": "modal",
                  onClick: _cache[0] || (_cache[0] = ($event) => [hide(), emit("cancel", $event)]),
                  class: (0, external_vue_.normalizeClass)(["close", (0, external_vue_.unref)(computedCloseClass)])
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "modal-header-close")], 2)) : ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("button", {
                  key: 1,
                  type: "button",
                  class: (0, external_vue_.normalizeClass)([(0, external_vue_.unref)(computedCloseClass), "btn-close"]),
                  "aria-label": __props.headerCloseLabel,
                  "data-bs-dismiss": "modal",
                  white: (0, external_vue_.unref)(headerCloseWhiteBoolean) || null,
                  onClick: _cache[1] || (_cache[1] = ($event) => [hide(), emit("cancel", $event)])
                }, null, 10, fsModalvue_type_script_setup_true_lang_ts_hoisted_3))], 64)) : (0, external_vue_.createCommentVNode)("", true)])], 10, fsModalvue_type_script_setup_true_lang_ts_hoisted_2)) : (0, external_vue_.createCommentVNode)("", true), (0, external_vue_.createElementVNode)("div", {
                  class: (0, external_vue_.normalizeClass)(["modal-body", (0, external_vue_.unref)(computedBodyClasses)])
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default", {
                  ok: okClicked,
                  cancel: cancelClicked,
                  hide,
                  close: closeClicked
                })], 2), !(0, external_vue_.unref)(hideFooterBoolean) ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                  key: 1,
                  class: (0, external_vue_.normalizeClass)(["modal-footer", (0, external_vue_.unref)(computedFooterClasses)])
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "modal-footer", {
                  ok: okClicked,
                  cancel: cancelClicked,
                  hide,
                  close: closeClicked
                }, () => [!(0, external_vue_.unref)(okOnlyBoolean) ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(fsButton, {
                  key: 0,
                  type: "button",
                  class: "btn",
                  disabled: (0, external_vue_.unref)(disableCancel),
                  size: __props.buttonSize,
                  variant: __props.cancelVariant,
                  onClick: _cache[2] || (_cache[2] = ($event) => [hide(), emit("cancel", $event)])
                }, {
                  default: (0, external_vue_.withCtx)(() => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(__props.cancelTitle), 1)]),
                  _: 1
                }, 8, ["disabled", "size", "variant"])) : (0, external_vue_.createCommentVNode)("", true), (0, external_vue_.createVNode)(fsButton, {
                  type: "button",
                  class: "btn",
                  disabled: (0, external_vue_.unref)(disableOk),
                  size: __props.buttonSize,
                  variant: __props.okVariant,
                  onClick: _cache[3] || (_cache[3] = ($event) => [hide(), emit("ok", $event)])
                }, {
                  default: (0, external_vue_.withCtx)(() => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(__props.okTitle), 1)]),
                  _: 1
                }, 8, ["disabled", "size", "variant"])])], 2)) : (0, external_vue_.createCommentVNode)("", true)], 2)) : (0, external_vue_.createCommentVNode)("", true)], 2), (0, external_vue_.unref)(hideBackdropBoolean) === false ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                  key: 0,
                  class: "modal-backdrop fade show",
                  onClick: _cache[4] || (_cache[4] = (0, external_vue_.withModifiers)(($event) => (0, external_vue_.unref)(noCloseOnBackdropBoolean) === false && hide(), ["prevent"]))
                })) : (0, external_vue_.createCommentVNode)("", true)], 10, fsModalvue_type_script_setup_true_lang_ts_hoisted_1)]);
              };
            }
          });
          ;
          ;
          const fsModal_exports_ = fsModalvue_type_script_setup_true_lang_ts;
          var fsModal = fsModal_exports_;
          ;
          function fsNavvue_type_template_id_08d54a8c_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("ul", {
              class: (0, external_vue_.normalizeClass)(["nav", _ctx.finalClass])
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")], 2);
          }
          ;
          ;
          var fsNavvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsNav",
            props: {
              align: {
                type: String
              },
              cardHeader: {
                type: Boolean,
                default: false
              },
              fill: {
                type: Boolean,
                default: false
              },
              justified: {
                type: Boolean,
                default: false
              },
              pills: {
                type: Boolean,
                default: false
              },
              small: {
                type: Boolean,
                default: false
              },
              tabs: {
                type: Boolean,
                default: false
              },
              tag: {
                type: String,
                default: "ul"
              },
              vertical: {
                type: Boolean,
                default: false
              }
            },
            setup(props) {
              function computeJustifyContent(value) {
                value = value === "left" ? "start" : value === "right" ? "end" : value;
                return `justify-content-${value}`;
              }
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  "nav-tabs": props.tabs,
                  "nav-pills": props.pills && !props.tabs,
                  "card-header-tabs": !props.vertical && props.cardHeader && props.tabs,
                  "card-header-pills": !props.vertical && props.cardHeader && props.pills && !props.tabs,
                  "flex-column": props.vertical,
                  "nav-fill": !props.vertical && props.fill,
                  "nav-justified": !props.vertical && props.justified,
                  [computeJustifyContent(props.align)]: !props.vertical && props.align,
                  small: props.small
                };
              });
              return {
                finalClass
              };
            }
          });
          ;
          ;
          ;
          const fsNav_exports_ = (0, exportHelper.Z)(fsNavvue_type_script_lang_ts, [["render", fsNavvue_type_template_id_08d54a8c_ts_true_render]]);
          var fsNav = fsNav_exports_;
          ;
          const fsNavItemvue_type_template_id_12390ed4_ts_true_hoisted_1 = {
            class: "nav-item"
          };
          function fsNavItemvue_type_template_id_12390ed4_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _component_fs_router_link = (0, external_vue_.resolveComponent)("fs-router-link");
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("li", fsNavItemvue_type_template_id_12390ed4_ts_true_hoisted_1, [(0, external_vue_.createVNode)(_component_fs_router_link, (0, external_vue_.mergeProps)(_ctx.$props, {
              href: _ctx.configuredHref,
              to: _ctx.to,
              tag: "a",
              class: ["nav-link", _ctx.finalClass],
              "aria-disabled": _ctx.disabled | null,
              onClick: _ctx.clicked
            }), {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 16, ["href", "to", "class", "aria-disabled", "onClick"])]);
          }
          ;
          ;
          var fsNavItemvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsNavItem",
            props: {
              active: {
                type: Boolean,
                default: false
              },
              activeClass: {
                type: String,
                default: "active"
              },
              append: {
                type: Boolean,
                default: false
              },
              disabled: {
                type: Boolean,
                default: false
              },
              exact: {
                type: Boolean,
                default: false
              },
              exactActiveClass: {
                type: String
              },
              exactPath: {
                type: Boolean,
                default: false
              },
              exactPathActiveClass: {
                type: String
              },
              href: {
                type: String,
                default: "#"
              },
              linkAttrs: {
                type: Object,
                default: () => ({})
              },
              linkClasses: {
                type: [Array, Object, String]
              },
              noPrefetch: {
                type: Boolean,
                default: false
              },
              prefetch: {
                type: Boolean,
                default: null
              },
              rel: {
                type: String,
                default: null
              },
              replace: {
                type: Boolean,
                default: false
              },
              routerComponentName: {
                type: String
              },
              target: {
                type: String,
                default: "_self"
              },
              to: {
                type: [Object, String]
              }
            },
            components: {
              FsRouterLink: fsRouterLink
            },
            emits: ["click"],
            setup(props, {
              emit
            }) {
              const instance = (0, external_vue_.getCurrentInstance)();
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  [`${props.activeClass} router-link-active`]: props.active,
                  [`${props.linkClasses}`]: props.linkClasses,
                  "disabled": props.disabled
                };
              });
              function clicked(e) {
                if (props.disabled) {
                  preventDefaultOnClick(e);
                  return;
                } else if (instance.proxy.$router && props.href === "#") {
                  preventDefaultOnClick(e);
                }
                emit("click", e);
              }
              function preventDefaultOnClick(e) {
                e.preventDefault();
                e.stopPropagation();
              }
              const configuredHref = configureHref(props.to, props.href, props.append, instance);
              return {
                finalClass,
                configuredHref,
                clicked
              };
            }
          });
          ;
          ;
          ;
          const fsNavItem_exports_ = (0, exportHelper.Z)(fsNavItemvue_type_script_lang_ts, [["render", fsNavItemvue_type_template_id_12390ed4_ts_true_render]]);
          var fsNavItem = fsNavItem_exports_;
          ;
          const fsNavFormvue_type_template_id_bbcd2018_ts_true_hoisted_1 = {
            class: "nav-item d-flex align-items-center flex-row"
          };
          const fsNavFormvue_type_template_id_bbcd2018_ts_true_hoisted_2 = ["id", "novalidate", "validated"];
          function fsNavFormvue_type_template_id_bbcd2018_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("li", fsNavFormvue_type_template_id_bbcd2018_ts_true_hoisted_1, [(0, external_vue_.createElementVNode)("form", {
              class: (0, external_vue_.normalizeClass)(["d-flex align-items-center flex-row", _ctx.formClass]),
              id: _ctx.id,
              novalidate: _ctx.novalidate,
              validated: _ctx.validated
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")], 10, fsNavFormvue_type_template_id_bbcd2018_ts_true_hoisted_2)]);
          }
          ;
          ;
          var fsNavFormvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsNavForm",
            props: {
              formClass: {
                type: [Array, Object, String]
              },
              id: {
                type: String
              },
              novalidate: {
                type: Boolean,
                default: false
              },
              validated: {
                type: Boolean,
                default: false
              }
            },
            emits: []
          });
          ;
          ;
          ;
          const fsNavForm_exports_ = (0, exportHelper.Z)(fsNavFormvue_type_script_lang_ts, [["render", fsNavFormvue_type_template_id_bbcd2018_ts_true_render]]);
          var fsNavForm = fsNavForm_exports_;
          ;
          const fsNavItemDropdownvue_type_script_setup_true_lang_ts_hoisted_1 = {
            class: "nav-item dropdown"
          };
          var fsNavItemDropdownvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsNavItemDropdown",
            props: {
              id: null,
              text: null,
              toggleClass: null,
              size: null,
              offset: null,
              autoClose: {
                type: [Boolean, String],
                default: true
              },
              dark: {
                type: Boolean,
                default: false
              },
              dropleft: {
                type: Boolean,
                default: false
              },
              dropright: {
                type: Boolean,
                default: false
              },
              dropup: {
                type: Boolean,
                default: false
              },
              right: {
                type: Boolean,
                default: false
              },
              left: {
                type: [Boolean, String],
                default: false
              },
              split: {
                type: Boolean,
                default: false
              },
              splitVariant: null,
              noCaret: {
                type: Boolean,
                default: false
              },
              variant: {
                default: "link"
              },
              block: {
                type: Boolean,
                default: false
              },
              boundary: {
                default: "clippingParents"
              },
              disabled: {
                type: Boolean,
                default: false
              },
              menuClass: {
                default: void 0
              },
              noFlip: {
                type: Boolean,
                default: false
              },
              role: {
                default: "menu"
              },
              splitButtonType: {
                default: "button"
              },
              splitClass: {
                default: void 0
              },
              splitHref: {
                default: void 0
              },
              toggleTag: {
                default: "fs-button"
              },
              toggleText: {
                default: "Toggle dropdown"
              },
              wrapperTag: {
                default: "div"
              }
            },
            setup(__props) {
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("li", fsNavItemDropdownvue_type_script_setup_true_lang_ts_hoisted_1, [(0, external_vue_.createVNode)(fsDropdown, (0, external_vue_.mergeProps)(_ctx.$props, {
                  "is-nav": ""
                }), (0, external_vue_.createSlots)({
                  _: 2
                }, [(0, external_vue_.renderList)(_ctx.$slots, (_, slot) => {
                  return {
                    name: slot,
                    fn: (0, external_vue_.withCtx)((scope) => [(0, external_vue_.renderSlot)(_ctx.$slots, slot, (0, external_vue_.normalizeProps)((0, external_vue_.guardReactiveProps)(scope || {})))])
                  };
                })]), 1040)]);
              };
            }
          });
          ;
          ;
          const fsNavItemDropdown_exports_ = fsNavItemDropdownvue_type_script_setup_true_lang_ts;
          var fsNavItemDropdown = fsNavItemDropdown_exports_;
          ;
          const fsNavTextvue_type_template_id_12575e82_ts_true_hoisted_1 = {
            class: "navbar-text"
          };
          function fsNavTextvue_type_template_id_12575e82_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("li", fsNavTextvue_type_template_id_12575e82_ts_true_hoisted_1, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]);
          }
          ;
          ;
          var fsNavTextvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsNavText"
          });
          ;
          ;
          ;
          const fsNavText_exports_ = (0, exportHelper.Z)(fsNavTextvue_type_script_lang_ts, [["render", fsNavTextvue_type_template_id_12575e82_ts_true_render]]);
          var fsNavText = fsNavText_exports_;
          ;
          function fsNavbarvue_type_template_id_4598fc43_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag), {
              class: (0, external_vue_.normalizeClass)(["navbar", _ctx.finalClass])
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 8, ["class"]);
          }
          ;
          ;
          var fsNavbarvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsNavbar",
            props: {
              fixed: {
                type: String
              },
              print: {
                type: Boolean,
                default: false
              },
              sticky: {
                type: Boolean,
                default: false
              },
              tag: {
                type: String,
                default: "nav"
              },
              toggleable: {
                type: [Boolean, String],
                default: false
              },
              type: {
                type: String,
                default: "light"
              },
              variant: {
                type: String
              }
            },
            emits: [],
            setup(props) {
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  [`navbar-${props.type}`]: props.type,
                  [`bg-${props.variant}`]: props.variant,
                  [`bg-${props.variant}`]: props.variant,
                  [`fixed-${props.fixed}`]: props.fixed,
                  [`navbar-expand-${props.toggleable}`]: props.toggleable && typeof props.toggleable !== "boolean",
                  "navbar-expand": !props.toggleable
                };
              });
              return {
                finalClass
              };
            }
          });
          ;
          ;
          ;
          const fsNavbar_exports_ = (0, exportHelper.Z)(fsNavbarvue_type_script_lang_ts, [["render", fsNavbarvue_type_template_id_4598fc43_ts_true_render]]);
          var fsNavbar = fsNavbar_exports_;
          ;
          function fsNavbarBrandvue_type_template_id_404e7ff4_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _component_fs_link = (0, external_vue_.resolveComponent)("fs-link");
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(_component_fs_link, (0, external_vue_.mergeProps)({
              class: "navbar-brand"
            }, _ctx.$props, {
              "router-tag": _ctx.tag
            }), {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 16, ["router-tag"]);
          }
          ;
          ;
          var fsNavbarBrandvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsNavbarBrand",
            props: {
              active: {
                type: Boolean,
                default: false
              },
              activeClass: {
                type: String
              },
              append: {
                type: Boolean,
                default: false
              },
              disabled: {
                type: Boolean,
                default: false
              },
              exact: {
                type: Boolean,
                default: false
              },
              exactActiveClass: {
                type: String
              },
              exactPath: {
                type: Boolean,
                default: false
              },
              exactPathActiveClass: {
                type: String
              },
              href: {
                type: String
              },
              noPrefetch: {
                type: Boolean,
                default: false
              },
              prefetch: {
                type: Boolean,
                default: null
              },
              rel: {
                type: String,
                default: null
              },
              replace: {
                type: Boolean,
                default: false
              },
              routerComponentName: {
                type: String
              },
              tag: {
                type: String,
                default: "div"
              },
              target: {
                type: String,
                default: "_self"
              },
              to: {
                type: [Object, String]
              }
            },
            components: {
              FsLink: fsLink
            }
          });
          ;
          ;
          ;
          const fsNavbarBrand_exports_ = (0, exportHelper.Z)(fsNavbarBrandvue_type_script_lang_ts, [["render", fsNavbarBrandvue_type_template_id_404e7ff4_ts_true_render]]);
          var fsNavbarBrand = fsNavbarBrand_exports_;
          ;
          const fsNavbarNavvue_type_template_id_379feb76_ts_true_hoisted_1 = {
            class: "navbar-nav"
          };
          function fsNavbarNavvue_type_template_id_379feb76_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("ul", fsNavbarNavvue_type_template_id_379feb76_ts_true_hoisted_1, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]);
          }
          ;
          ;
          var fsNavbarNavvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsNavbarNav",
            props: {
              align: {
                type: String
              },
              fill: {
                type: Boolean,
                default: false
              },
              justified: {
                type: Boolean,
                default: false
              },
              small: {
                type: Boolean,
                default: false
              },
              tag: {
                type: String,
                default: "ul"
              }
            },
            components: {
              FsNav: fsNav
            },
            emits: []
          });
          ;
          ;
          ;
          const fsNavbarNav_exports_ = (0, exportHelper.Z)(fsNavbarNavvue_type_script_lang_ts, [["render", fsNavbarNavvue_type_template_id_379feb76_ts_true_render]]);
          var fsNavbarNav = fsNavbarNav_exports_;
          ;
          const fsNavbarTogglevue_type_template_id_3a1589e2_ts_true_hoisted_1 = ["data-bs-target", "aria-controls", "aria-label"];
          const fsNavbarTogglevue_type_template_id_3a1589e2_ts_true_hoisted_2 = (0, external_vue_.createElementVNode)("span", {
            class: "navbar-toggler-icon"
          }, null, -1);
          function fsNavbarTogglevue_type_template_id_3a1589e2_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("button", {
              class: "navbar-toggler",
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.clicked && _ctx.clicked(...args)),
              "data-bs-toggle": "collapse",
              "data-bs-target": `#${_ctx.target}`,
              "aria-controls": _ctx.target,
              "aria-expanded": "false",
              "aria-label": _ctx.label
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default", {}, () => [fsNavbarTogglevue_type_template_id_3a1589e2_ts_true_hoisted_2])], 8, fsNavbarTogglevue_type_template_id_3a1589e2_ts_true_hoisted_1);
          }
          ;
          ;
          var fsNavbarTogglevue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsNavbarToggle",
            props: {
              disabled: {
                type: Boolean,
                default: false
              },
              label: {
                type: String,
                default: "Toggle navigation"
              },
              target: {
                type: String
              }
            },
            components: {
              FsNav: fsNav
            },
            emits: ["click"],
            setup(props, {
              emit
            }) {
              function clicked(e) {
                if (props.disabled) {
                  e.preventDefault();
                  e.stopPropagation();
                  return;
                }
                emit("click", e);
              }
              return {
                clicked
              };
            }
          });
          ;
          ;
          ;
          const fsNavbarToggle_exports_ = (0, exportHelper.Z)(fsNavbarTogglevue_type_script_lang_ts, [["render", fsNavbarTogglevue_type_template_id_3a1589e2_ts_true_render]]);
          var fsNavbarToggle = fsNavbarToggle_exports_;
          ;
          function fsOverlayvue_type_template_id_8af5ccd2_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _component_fs_spinner = (0, external_vue_.resolveComponent)("fs-spinner");
            return !_ctx.noWrap ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.wrapTag), {
              key: 0,
              class: "b-overlay-wrap position-relative",
              "aria-busy": _ctx.show ? "true" : void 0
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default"), _ctx.show ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.overlayTag), {
                key: 0,
                class: (0, external_vue_.normalizeClass)(_ctx.computedOverlayClass),
                style: (0, external_vue_.normalizeStyle)(_ctx.computedOverlayStyles),
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event)),
                onAfterEnter: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("shown")),
                onAfterLeave: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("hidden"))
              }, {
                default: (0, external_vue_.withCtx)(() => [(0, external_vue_.createElementVNode)("div", {
                  class: (0, external_vue_.normalizeClass)(_ctx.computedBackgroundClass),
                  style: (0, external_vue_.normalizeStyle)(_ctx.computedBackgroundStyles)
                }, null, 6), (0, external_vue_.createElementVNode)("div", {
                  class: "position-absolute",
                  style: (0, external_vue_.normalizeStyle)(_ctx.computedContentStyles)
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "overlay", (0, external_vue_.normalizeProps)((0, external_vue_.guardReactiveProps)(_ctx.computedSlotScope)), () => [(0, external_vue_.createVNode)(_component_fs_spinner, {
                  type: _ctx.spinnerType,
                  variant: _ctx.spinnerVariant,
                  small: _ctx.spinnerSmall
                }, null, 8, ["type", "variant", "small"])])], 4)]),
                _: 3
              }, 40, ["class", "style"])) : (0, external_vue_.createCommentVNode)("", true)]),
              _: 3
            }, 8, ["aria-busy"])) : _ctx.show ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.overlayTag), {
              key: 1,
              class: (0, external_vue_.normalizeClass)(_ctx.computedOverlayClass),
              style: (0, external_vue_.normalizeStyle)(_ctx.computedOverlayStyles),
              onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click", $event)),
              onAfterEnter: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("shown")),
              onAfterLeave: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("hidden"))
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.createElementVNode)("div", {
                class: (0, external_vue_.normalizeClass)(_ctx.computedBackgroundClass),
                style: (0, external_vue_.normalizeStyle)(_ctx.computedBackgroundStyles)
              }, null, 6), (0, external_vue_.createElementVNode)("div", {
                class: "position-absolute",
                style: (0, external_vue_.normalizeStyle)(_ctx.computedContentStyles)
              }, [(0, external_vue_.renderSlot)(_ctx.$slots, "overlay", (0, external_vue_.normalizeProps)((0, external_vue_.guardReactiveProps)(_ctx.computedSlotScope)), () => [(0, external_vue_.createVNode)(_component_fs_spinner, {
                type: _ctx.spinnerType,
                variant: _ctx.spinnerVariant,
                small: _ctx.spinnerSmall
              }, null, 8, ["type", "variant", "small"])])], 4)]),
              _: 3
            }, 40, ["class", "style"])) : (0, external_vue_.createCommentVNode)("", true);
          }
          ;
          ;
          const fsSpinnervue_type_template_id_47fb05cc_ts_true_hoisted_1 = {
            key: 0,
            class: "visually-hidden-focusable"
          };
          function fsSpinnervue_type_template_id_47fb05cc_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag), {
              class: (0, external_vue_.normalizeClass)(_ctx.computedClass),
              role: _ctx.label ? _ctx.role || "status" : null,
              "aria-hidden": _ctx.label ? null : "true"
            }, {
              default: (0, external_vue_.withCtx)(() => [_ctx.label ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("span", fsSpinnervue_type_template_id_47fb05cc_ts_true_hoisted_1, [(0, external_vue_.renderSlot)(_ctx.$slots, "label", {}, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.label), 1)])])) : (0, external_vue_.createCommentVNode)("", true)]),
              _: 3
            }, 8, ["class", "role", "aria-hidden"]);
          }
          ;
          ;
          var fsSpinnervue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsSpinner",
            props: {
              label: {
                type: String
              },
              role: {
                type: String,
                default: "status"
              },
              small: {
                type: Boolean,
                default: false
              },
              tag: {
                type: String,
                default: "span"
              },
              type: {
                type: String,
                default: "border"
              },
              variant: {
                type: String
              }
            },
            setup(props) {
              const computedClass = (0, external_vue_.computed)(() => {
                return {
                  [`spinner-${props.type}`]: props.type,
                  [`spinner-${props.type}-sm`]: props.small,
                  [`text-${props.variant}`]: props.variant
                };
              });
              return {
                computedClass
              };
            }
          });
          ;
          ;
          ;
          const fsSpinner_exports_ = (0, exportHelper.Z)(fsSpinnervue_type_script_lang_ts, [["render", fsSpinnervue_type_template_id_47fb05cc_ts_true_render]]);
          var fsSpinner = fsSpinner_exports_;
          ;
          var fsOverlayvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsOverlay",
            props: {
              bgColor: {
                type: String
              },
              blur: {
                type: String,
                default: "2px"
              },
              fixed: {
                type: Boolean,
                default: false
              },
              noCenter: {
                type: Boolean,
                default: false
              },
              noFade: {
                type: Boolean,
                default: false
              },
              noWrap: {
                type: Boolean,
                default: false
              },
              opacity: {
                type: [Number, String],
                default: 0.85
              },
              overlayTag: {
                type: String,
                default: "div"
              },
              rounded: {
                type: [Boolean, String],
                default: false
              },
              show: {
                type: Boolean,
                default: false
              },
              spinnerSmall: {
                type: Boolean,
                default: false
              },
              spinnerType: {
                type: String,
                default: "border"
              },
              spinnerVariant: {
                type: String
              },
              variant: {
                type: String,
                default: "light"
              },
              wrapTag: {
                type: String,
                default: "div"
              },
              zIndex: {
                type: [Number, String],
                default: 10
              }
            },
            components: {
              FsSpinner: fsSpinner
            },
            setup(props) {
              const positionCover = {
                top: 0,
                left: 0,
                bottom: 0,
                right: 0
              };
              const computedOverlayClass = (0, external_vue_.computed)(() => {
                return {
                  [`b-overlay`]: true,
                  [`position-absolute`]: !props.noWrap || props.noWrap && !props.fixed,
                  [`position-fixed`]: props.noWrap && props.fixed
                };
              });
              const computedOverlayStyles = (0, external_vue_.computed)(() => {
                return {
                  ...positionCover,
                  zIndex: props.zIndex || 10
                };
              });
              const computedRounded = (0, external_vue_.computed)(() => {
                return props.rounded === true || props.rounded === "" ? "rounded" : !props.rounded ? "" : `rounded-${props.rounded}`;
              });
              const computedBackgroundClass = (0, external_vue_.computed)(() => {
                return {
                  [`position-absolute`]: true,
                  [computedRounded.value]: props.rounded,
                  [`bg-${props.variant}`]: props.variant && !props.bgColor
                };
              });
              const computedBackgroundStyles = (0, external_vue_.computed)(() => {
                return {
                  ...positionCover,
                  opacity: props.opacity,
                  backgroundColor: props.bgColor || null,
                  backdropFilter: props.blur ? `blur(${props.blur})` : null
                };
              });
              const computedContentStyles = (0, external_vue_.computed)(() => {
                return props.noCenter ? {
                  ...positionCover
                } : {
                  top: "50%",
                  left: "50%",
                  transform: "translateX(-50%) translateY(-50%)"
                };
              });
              const computedSlotScope = (0, external_vue_.computed)(() => {
                return {
                  spinnerType: props.spinnerType || null,
                  spinnerVariant: props.spinnerVariant || null,
                  spinnerSmall: props.spinnerSmall
                };
              });
              return {
                computedOverlayClass,
                computedOverlayStyles,
                computedRounded,
                computedBackgroundClass,
                computedBackgroundStyles,
                computedContentStyles,
                computedSlotScope
              };
            }
          });
          ;
          ;
          ;
          const fsOverlay_exports_ = (0, exportHelper.Z)(fsOverlayvue_type_script_lang_ts, [["render", fsOverlayvue_type_template_id_8af5ccd2_ts_true_render]]);
          var fsOverlay = fsOverlay_exports_;
          ;
          const fsPaginationvue_type_template_id_20a563ee_ts_true_hoisted_1 = ["aria-label"];
          const fsPaginationvue_type_template_id_20a563ee_ts_true_hoisted_2 = ["aria-controls"];
          const fsPaginationvue_type_template_id_20a563ee_ts_true_hoisted_3 = {
            key: 0,
            class: "page-link"
          };
          const fsPaginationvue_type_template_id_20a563ee_ts_true_hoisted_4 = {
            key: 1,
            class: "page-link"
          };
          const _hoisted_5 = ["id"];
          const _hoisted_6 = {
            key: 0,
            class: "page-link"
          };
          const _hoisted_7 = {
            key: 1,
            class: "page-link"
          };
          const _hoisted_8 = ["aria-controls"];
          function fsPaginationvue_type_template_id_20a563ee_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("nav", {
              "aria-label": _ctx.ariaLabel
            }, [(0, external_vue_.createElementVNode)("ul", {
              ref: "element",
              role: "menubar",
              class: (0, external_vue_.normalizeClass)(["pagination b-pagination", _ctx.finalClass])
            }, [!_ctx.firstNumber && !_ctx.hideGotoEndButtons ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("li", {
              key: 0,
              class: (0, external_vue_.normalizeClass)(_ctx.finalGoToFirstClass),
              role: "presentation"
            }, [((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.disabled ? "span" : "button"), {
              "aria-label": "labelFirstPage",
              role: "menuitem",
              "aria-controls": _ctx.ariaControls,
              type: _ctx.disabled ? null : "button",
              class: (0, external_vue_.normalizeClass)(["page-link", _ctx.finalListItemBtnClass]),
              onClick: _ctx.onFirstText
            }, {
              default: (0, external_vue_.withCtx)(() => [!_ctx.$slots["first-text"] ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)(external_vue_.Fragment, {
                key: 0
              }, [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.firstText), 1)], 64)) : (0, external_vue_.renderSlot)(_ctx.$slots, "first-text", {
                key: 1
              })]),
              _: 3
            }, 8, ["aria-controls", "type", "class", "onClick"]))], 2)) : (0, external_vue_.createCommentVNode)("", true), (0, external_vue_.createElementVNode)("li", {
              class: (0, external_vue_.normalizeClass)(_ctx.finalGoToPrevClass),
              role: "presentation"
            }, [(0, external_vue_.createElementVNode)("button", {
              role: "menuitem",
              "aria-label": "labelPreviousPage",
              "aria-controls": _ctx.ariaControls,
              type: "button",
              class: (0, external_vue_.normalizeClass)(["page-link", _ctx.finalListItemBtnClass]),
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onPrevText && _ctx.onPrevText(...args))
            }, [!_ctx.$slots["prev-text"] ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)(external_vue_.Fragment, {
              key: 0
            }, [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.prevText), 1)], 64)) : (0, external_vue_.renderSlot)(_ctx.$slots, "prev-text", {
              key: 1
            })], 10, fsPaginationvue_type_template_id_20a563ee_ts_true_hoisted_2)], 2), !_ctx.hideEllipsis && _ctx.showFirstEllipsis ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("li", {
              key: 1,
              class: (0, external_vue_.normalizeClass)([_ctx.finalEllipsisClass, "dots"]),
              role: "separator"
            }, [!_ctx.$slots["ellipsis-text"] ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("span", fsPaginationvue_type_template_id_20a563ee_ts_true_hoisted_3, (0, external_vue_.toDisplayString)(_ctx.ellipsisText), 1)) : ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("span", fsPaginationvue_type_template_id_20a563ee_ts_true_hoisted_4, [(0, external_vue_.renderSlot)(_ctx.$slots, "ellipsis-text")]))], 2)) : (0, external_vue_.createCommentVNode)("", true), ((0, external_vue_.openBlock)(true), (0, external_vue_.createElementBlock)(external_vue_.Fragment, null, (0, external_vue_.renderList)(_ctx.getPages, (page) => {
              return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("li", {
                key: page.id,
                role: "presentation",
                class: (0, external_vue_.normalizeClass)(page.class),
                id: "fun" + page.number
              }, [((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.disabled ? "span" : "button"), {
                role: "menuitemradio",
                type: _ctx.disabled ? null : "button",
                "aria-controls": _ctx.ariaControls,
                "aria-label": _ctx.labelPage ? _ctx.labelPage + " " + page.number : "Go to page " + page.number,
                "aria-checked": "false",
                "aria-posinset": "2",
                "aria-setsize": "3",
                tabindex: "-1",
                class: (0, external_vue_.normalizeClass)(["page-link", _ctx.finalListItemBtnClass]),
                onClick: ($event) => _ctx.buttonClick(page, $event)
              }, {
                default: (0, external_vue_.withCtx)(() => [!_ctx.$slots.page ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)(external_vue_.Fragment, {
                  key: 0
                }, [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(page.number), 1)], 64)) : (0, external_vue_.renderSlot)(_ctx.$slots, "page", {
                  key: 1,
                  page: page.number
                })]),
                _: 2
              }, 1032, ["type", "aria-controls", "aria-label", "class", "onClick"]))], 10, _hoisted_5);
            }), 128)), !_ctx.hideEllipsis && _ctx.showLastEllipsis ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("li", {
              key: 2,
              class: (0, external_vue_.normalizeClass)([_ctx.finalEllipsisClass, "dots"]),
              role: "separator"
            }, [!_ctx.$slots["ellipsis-text"] ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("span", _hoisted_6, (0, external_vue_.toDisplayString)(_ctx.ellipsisText), 1)) : ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("span", _hoisted_7, [(0, external_vue_.renderSlot)(_ctx.$slots, "ellipsis-text")]))], 2)) : (0, external_vue_.createCommentVNode)("", true), (0, external_vue_.createElementVNode)("li", {
              class: (0, external_vue_.normalizeClass)(_ctx.finalGoToNextClass),
              role: "presentation"
            }, [(0, external_vue_.createElementVNode)("button", {
              role: "menuitem",
              "aria-label": "labelNextPage",
              "aria-controls": _ctx.ariaControls,
              type: "button",
              class: (0, external_vue_.normalizeClass)(["page-link", _ctx.finalBtnClass]),
              onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onNextText && _ctx.onNextText(...args))
            }, [!_ctx.$slots["next-text"] ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)(external_vue_.Fragment, {
              key: 0
            }, [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.nextText), 1)], 64)) : (0, external_vue_.renderSlot)(_ctx.$slots, "next-text", {
              key: 1
            })], 10, _hoisted_8)], 2), !_ctx.hideGotoEndButtons && !_ctx.lastNumber ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("li", {
              key: 3,
              class: (0, external_vue_.normalizeClass)(_ctx.finalLastClass),
              role: "presentation"
            }, [((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.disabled ? "span" : "button"), {
              role: "menuitem",
              type: _ctx.disabled ? null : "button",
              "aria-label": "labelLastPage",
              "aria-controls": _ctx.ariaControls,
              class: (0, external_vue_.normalizeClass)(["page-link", _ctx.finalBtnClass]),
              onClick: _ctx.onLastText
            }, {
              default: (0, external_vue_.withCtx)(() => [!_ctx.$slots["last-text"] ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)(external_vue_.Fragment, {
                key: 0
              }, [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.lastText), 1)], 64)) : (0, external_vue_.renderSlot)(_ctx.$slots, "last-text", {
                key: 1
              })]),
              _: 3
            }, 8, ["type", "aria-controls", "class", "onClick"]))], 2)) : (0, external_vue_.createCommentVNode)("", true)], 2)], 8, fsPaginationvue_type_template_id_20a563ee_ts_true_hoisted_1);
          }
          ;
          ;
          var fsPaginationvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsPagination",
            props: {
              align: {
                type: String,
                default: "left"
              },
              ariaControls: {
                type: String
              },
              ariaLabel: {
                type: String,
                default: "Pagination"
              },
              disabled: {
                type: Boolean,
                default: false
              },
              ellipsisClass: {
                type: [Array, Object, String]
              },
              ellipsisText: {
                type: String,
                default: "\u2026"
              },
              firstClass: {
                type: [Array, Object, String]
              },
              firstNumber: {
                type: Boolean,
                default: false
              },
              firstText: {
                type: String,
                default: "\xAB"
              },
              hideEllipsis: {
                type: Boolean,
                default: false
              },
              hideGotoEndButtons: {
                type: Boolean,
                default: false
              },
              labelFirstPage: {
                type: String,
                default: "Go to first page"
              },
              labelLastPage: {
                type: String,
                default: "Go to last page"
              },
              labelNextPage: {
                type: String,
                default: "Go to next page"
              },
              labelPage: {
                type: [Function, String],
                default: "Go to page"
              },
              labelPrevPage: {
                type: String,
                default: "Go to previous page"
              },
              lastClass: {
                type: [Array, Object, String]
              },
              lastNumber: {
                type: Boolean,
                default: false
              },
              lastText: {
                type: String,
                default: "\xBB"
              },
              limit: {
                type: [Number, String],
                default: 5
              },
              nextClass: {
                type: [Array, Object, String]
              },
              nextText: {
                type: String,
                default: "\u203A"
              },
              pageClass: {
                type: [Array, Object, String]
              },
              perPage: {
                type: [Number, String],
                default: 20
              },
              pills: {
                type: Boolean,
                default: false
              },
              prevClass: {
                type: [Array, Object, String]
              },
              prevText: {
                type: String,
                default: "\u2039"
              },
              size: {
                type: String
              },
              totalRows: {
                type: [Number, String],
                default: 0
              },
              modelValue: {
                type: [Boolean, Number, String],
                default: null
              }
            },
            emits: ["update:modelValue", "change", "page-click"],
            setup(props, {
              emit
            }) {
              const element = (0, external_vue_.ref)(null);
              const currentPage = (0, external_vue_.ref)(null);
              const ELLIPSIS_THRESHOLD = 3;
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  "justify-content-start": props.align === "start" || props.align === "left",
                  "justify-content-end": props.align === "end" || props.align === "right",
                  "justify-content-center": props.align === "center",
                  "text-center": props.align === "fill",
                  "b-pagination-pills": props.pills,
                  [`pagination-${props.size}`]: props.size
                };
              });
              const finalBtnClass = (0, external_vue_.computed)(() => {
                return {
                  "flex-fill": props.align === "fill"
                };
              });
              const finalEllipsisClass = (0, external_vue_.computed)(() => {
                return {
                  "page-item": true,
                  "flex-fill d-flex": props.align === "fill",
                  "disabled": props.disabled,
                  [`${props.ellipsisClass}`]: props.ellipsisClass
                };
              });
              const finalGoToFirstClass = (0, external_vue_.computed)(() => {
                return {
                  "page-item": true,
                  "flex-fill d-flex": props.align === "fill",
                  "disabled": props.disabled,
                  [`${props.firstClass}`]: props.firstClass
                };
              });
              const finalListItemClass = (0, external_vue_.computed)(() => {
                return {
                  "page-item": true,
                  "flex-fill d-flex": props.align === "fill",
                  "disabled": props.disabled
                };
              });
              const finalGoToNextClass = (0, external_vue_.computed)(() => {
                return {
                  "page-item": true,
                  "flex-fill d-flex": props.align === "fill",
                  "disabled": props.disabled,
                  [`${props.nextClass}`]: props.nextClass
                };
              });
              const finalGoToPrevClass = (0, external_vue_.computed)(() => {
                return {
                  "page-item": true,
                  "flex-fill d-flex": props.align === "fill",
                  "disabled": props.disabled,
                  [`${props.prevClass}`]: props.prevClass
                };
              });
              const finalLastClass = (0, external_vue_.computed)(() => {
                return {
                  "page-item": true,
                  "flex-fill d-flex": props.align === "fill",
                  "disabled": props.disabled,
                  [`${props.lastClass}`]: props.lastClass
                };
              });
              const finalListItemBtnClass = (0, external_vue_.computed)(() => {
                return {
                  "flex-grow-1": props.align === "fill"
                };
              });
              const numberOfPages = (0, external_vue_.computed)(() => {
                const totRows = Number(props.totalRows);
                const pPage = Number(props.perPage);
                const numPages = Math.ceil(totRows / pPage);
                return numPages;
              });
              const pages = (0, external_vue_.computed)(() => {
                const result = [];
                for (let i = 0; i < numberOfLinks.value; i++) {
                  result.push({
                    number: startNumber.value + i
                  });
                }
                return result;
              });
              const getPages = (0, external_vue_.computed)(() => {
                let pagesToDisplay = [];
                const pageNumbers = pages.value.map((p) => p.number);
                for (let i = 1; i <= numberOfLinks.value; i++) {
                  const pageItem = "page-item ";
                  const active = pageNumbers[i - 1] === props.modelValue ? "active " : "";
                  const alignment = props.align === "fill" ? "flex-fill d-flex" : "";
                  const disabled = props.disabled ? "disabled" : "";
                  const liPageClass = props.pageClass ? [`${props.pageClass}`] : "";
                  const finalString = pageItem + active + alignment + disabled + liPageClass;
                  const offset2 = showFirstEllipsis.value && props.firstNumber && pageNumbers[0] !== 1 ? 1 : 0;
                  pagesToDisplay.push({
                    id: i + offset2,
                    number: pageNumbers[i - 1],
                    isSelected: pageNumbers[i - 1] === props.modelValue ? true : false,
                    class: finalString
                  });
                }
                return pagesToDisplay;
              });
              const numberOfLinks = (0, external_vue_.computed)(() => {
                let propLimit = props.limit;
                if (numberOfPages.value <= props.limit) {
                  propLimit = numberOfPages.value;
                } else if (props.modelValue < Number(props.limit) - 1 && props.limit > ELLIPSIS_THRESHOLD) {
                  if (!props.hideEllipsis || props.lastNumber) {
                    propLimit = Number(props.limit) - (props.firstNumber ? 0 : 1);
                  }
                  propLimit = Math.min(Number(propLimit), Number(props.limit));
                } else if (numberOfPages.value - Number(props.modelValue) + 2 < props.limit && props.limit > ELLIPSIS_THRESHOLD) {
                  if (!props.hideEllipsis || props.firstNumber) {
                    propLimit = Number(props.limit) - (props.lastNumber ? 0 : 1);
                  }
                } else {
                  if (props.limit > ELLIPSIS_THRESHOLD) {
                    propLimit = Number(props.limit) - (props.hideEllipsis ? 0 : 2);
                  }
                }
                return Number(propLimit);
              });
              const startNumber = (0, external_vue_.computed)(() => {
                let startingNumber = 1;
                const pagesLeft = numberOfPages.value - Number(props.modelValue);
                if (pagesLeft + 2 < props.limit && props.limit > ELLIPSIS_THRESHOLD) {
                  startingNumber = numberOfPages.value - numberOfLinks.value + 1;
                } else {
                  startingNumber = Number(props.modelValue) - Math.floor(numberOfLinks.value / 2);
                }
                if (startingNumber < 1) {
                  startingNumber = 1;
                } else if (startingNumber > numberOfPages.value - numberOfLinks.value) {
                  startingNumber = numberOfPages.value - numberOfLinks.value + 1;
                }
                if (props.limit <= ELLIPSIS_THRESHOLD) {
                  if (props.lastNumber && numberOfPages.value === startingNumber + numberOfLinks.value - 1) {
                    startingNumber = Math.max(startingNumber - 1, 1);
                  }
                }
                return startingNumber;
              });
              const showFirstEllipsis = (0, external_vue_.computed)(() => {
                const pagesLeft = numberOfPages.value - Number(props.modelValue);
                let showDots = false;
                if (pagesLeft + 2 < props.limit && props.limit > ELLIPSIS_THRESHOLD) {
                  if (props.limit > ELLIPSIS_THRESHOLD) {
                    showDots = true;
                  }
                } else {
                  if (props.limit > ELLIPSIS_THRESHOLD) {
                    showDots = !!(!props.hideEllipsis || props.firstNumber);
                  }
                }
                if (startNumber.value <= 1) {
                  showDots = false;
                }
                if (showDots && props.firstNumber && startNumber.value < 4) {
                  showDots = false;
                }
                return showDots;
              });
              const showLastEllipsis = (0, external_vue_.computed)(() => {
                const paginationEnd = numberOfPages.value - numberOfLinks.value;
                let showDots = false;
                if (props.modelValue < Number(props.limit) - 1 && props.limit > ELLIPSIS_THRESHOLD) {
                  if (!props.hideEllipsis || props.lastNumber) {
                    showDots = true;
                  }
                } else {
                  if (props.limit > ELLIPSIS_THRESHOLD) {
                    showDots = !!(!props.hideEllipsis || props.lastNumber);
                  }
                }
                if (startNumber.value > paginationEnd) {
                  showDots = false;
                }
                const lastPageNumber = startNumber.value + numberOfLinks.value - 1;
                if (showDots && props.lastNumber && lastPageNumber > numberOfPages.value - 3) {
                  showDots = false;
                }
                return showDots;
              });
              (0, external_vue_.watch)(() => props.modelValue, (newValue) => {
                if (newValue !== currentPage.value) {
                  currentPage.value = newValue;
                  emit("change", currentPage.value);
                }
              });
              (0, external_vue_.onBeforeUnmount)(() => {
                window.removeEventListener("keydown", onKeypress);
              });
              function onFirstText() {
                emit("update:modelValue", 1);
                currentPage.value = 1;
              }
              ;
              function onPrevText() {
                if (currentPage.value > 1) {
                  currentPage.value = currentPage.value - 1;
                  emit("update:modelValue", currentPage.value);
                }
              }
              ;
              function onNextText() {
                if (currentPage.value < numberOfPages.value) {
                  currentPage.value = currentPage.value + 1;
                  emit("update:modelValue", currentPage.value);
                }
              }
              ;
              function onLastText() {
                currentPage.value = numberOfPages.value;
                emit("update:modelValue", currentPage.value);
              }
              ;
              function buttonClick(page, e) {
                emit("update:modelValue", page.number);
                emit("page-click", e, page.number);
                setTimeout(attemptFocus2, 100);
              }
              ;
              function attemptFocus2() {
                const btn = element.value.querySelector(".active").firstChild;
                btn.focus();
              }
              ;
              function onKeypress(event) {
                let focusedElement = document.activeElement;
                if (focusedElement.className.includes("page-link")) {
                  if (event.key !== "Tab") {
                    event.preventDefault();
                  }
                  switch (event.key) {
                    case "ArrowRight":
                    case "ArrowDown": {
                      if (focusedElement.parentElement.parentElement.lastChild !== focusedElement.parentElement) {
                        var next = focusedElement.parentElement.nextSibling;
                        if (next.childNodes.length !== 0 && next.className.includes("dots")) {
                          focusedElement = focusedElement.parentElement.nextSibling.nextSibling.firstChild;
                        } else {
                          focusedElement = focusedElement.parentElement.nextElementSibling.firstChild;
                        }
                        if (focusedElement) {
                          focusedElement.focus();
                        }
                      }
                      break;
                    }
                    case "ArrowUp":
                    case "ArrowLeft": {
                      if (focusedElement.parentElement.parentElement.firstChild !== focusedElement.parentElement) {
                        var prev = focusedElement.parentElement.previousSibling;
                        if (prev.childNodes.length !== 0 && prev.className.includes("dots")) {
                          focusedElement = focusedElement.parentElement.previousSibling.previousSibling.firstChild;
                        } else {
                          focusedElement = focusedElement.parentElement.previousElementSibling.firstChild;
                        }
                        if (focusedElement) {
                          focusedElement.focus();
                        }
                      }
                      break;
                    }
                    case " ":
                    case "Enter": {
                      focusedElement.click();
                      break;
                    }
                  }
                }
              }
              ;
              window.addEventListener("keydown", onKeypress);
              currentPage.value = Number(props.modelValue);
              return {
                element,
                finalClass,
                finalBtnClass,
                finalEllipsisClass,
                finalGoToFirstClass,
                finalListItemClass,
                finalGoToNextClass,
                finalGoToPrevClass,
                finalLastClass,
                finalListItemBtnClass,
                getPages,
                showFirstEllipsis,
                showLastEllipsis,
                onFirstText,
                onPrevText,
                onNextText,
                onLastText,
                buttonClick
              };
            }
          });
          ;
          ;
          ;
          const fsPagination_exports_ = (0, exportHelper.Z)(fsPaginationvue_type_script_lang_ts, [["render", fsPaginationvue_type_template_id_20a563ee_ts_true_render]]);
          var fsPagination = fsPagination_exports_;
          ;
          const fsPopovervue_type_template_id_cdccb86a_ts_true_hoisted_1 = ["id"];
          const fsPopovervue_type_template_id_cdccb86a_ts_true_hoisted_2 = {
            ref: "titleRef"
          };
          const fsPopovervue_type_template_id_cdccb86a_ts_true_hoisted_3 = {
            ref: "contentRef"
          };
          function fsPopovervue_type_template_id_cdccb86a_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return !_ctx.disabledBoolean ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
              key: 0,
              id: _ctx.id,
              ref: "element",
              class: (0, external_vue_.normalizeClass)(["popover b-popover", _ctx.classes]),
              role: "tooltip",
              tabindex: "-1"
            }, [(0, external_vue_.createElementVNode)("div", fsPopovervue_type_template_id_cdccb86a_ts_true_hoisted_2, [(0, external_vue_.renderSlot)(_ctx.$slots, "title", {}, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.title), 1)])], 512), (0, external_vue_.createElementVNode)("div", fsPopovervue_type_template_id_cdccb86a_ts_true_hoisted_3, [(0, external_vue_.renderSlot)(_ctx.$slots, "default", {}, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.content), 1)])], 512)], 10, fsPopovervue_type_template_id_cdccb86a_ts_true_hoisted_1)) : (0, external_vue_.createCommentVNode)("", true);
          }
          ;
          ;
          var fsPopovervue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            props: {
              container: {
                type: [String, Object],
                default: "body"
              },
              content: {
                type: String
              },
              id: {
                type: String
              },
              customClass: {
                type: String,
                default: ""
              },
              noninteractive: {
                type: [Boolean, String],
                default: false
              },
              placement: {
                type: String,
                default: "right"
              },
              target: {
                type: [String, Object],
                default: void 0
              },
              title: {
                type: String
              },
              delay: {
                type: [Number, Object],
                default: 0
              },
              triggers: {
                type: String,
                default: "click"
              },
              show: {
                type: [Boolean, String],
                default: false
              },
              variant: {
                type: String,
                default: void 0
              },
              html: {
                type: [Boolean, String],
                default: true
              },
              sanitize: {
                type: [Boolean, String],
                default: false
              },
              offset: {
                type: String,
                default: "0"
              },
              disabled: {
                type: [Boolean, String],
                default: false
              }
            },
            emits: ["show", "shown", "hide", "hidden", "inserted"],
            setup(props, {
              emit,
              slots
            }) {
              const showBoolean = useBooleanish((0, external_vue_.toRef)(props, "show"));
              const disabledBoolean = useBooleanish((0, external_vue_.toRef)(props, "disabled"));
              const htmlBoolean = useBooleanish((0, external_vue_.toRef)(props, "html"));
              const sanitizeBoolean = useBooleanish((0, external_vue_.toRef)(props, "sanitize"));
              const element = (0, external_vue_.ref)();
              const target = (0, external_vue_.ref)();
              const instance = (0, external_vue_.ref)();
              const titleRef = (0, external_vue_.ref)();
              const contentRef = (0, external_vue_.ref)();
              const classes = (0, external_vue_.computed)(() => ({
                [`b-popover-${props.variant}`]: props.variant !== void 0
              }));
              const cleanElementProp = (target2) => {
                if (typeof target2 === "string") {
                  return target2;
                } else if (target2 instanceof HTMLElement)
                  return target2;
                else if (typeof target2 !== "undefined")
                  return target2.$el;
                return void 0;
              };
              const getElement = (element2) => {
                if (!element2)
                  return void 0;
                if (typeof element2 === "string") {
                  const idElement = document.getElementById(element2);
                  return idElement ? idElement : void 0;
                }
                return element2;
              };
              const generatePopoverInstance = (targetValue) => {
                target.value = getElement(cleanElementProp(targetValue));
                if (!target.value)
                  return;
                instance.value = new external_bootstrap_.Popover(target.value, {
                  customClass: props.customClass,
                  container: cleanElementProp(props.container),
                  trigger: props.triggers,
                  placement: props.placement,
                  title: props.title || slots.title ? titleRef.value : "",
                  content: contentRef.value || null,
                  html: htmlBoolean.value,
                  delay: props.delay,
                  sanitize: sanitizeBoolean.value,
                  offset: props.offset
                });
              };
              (0, external_vue_.onMounted)(() => {
                var _a, _b, _c;
                (0, external_vue_.nextTick)(() => {
                  generatePopoverInstance(props.target);
                });
                (_b = (_a = element.value) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.removeChild(element.value);
                if (showBoolean.value) {
                  (_c = instance.value) == null ? void 0 : _c.show();
                }
              });
              (0, external_vue_.onBeforeUnmount)(() => {
                var _a;
                (_a = instance.value) == null ? void 0 : _a.dispose();
              });
              (0, external_vue_.watch)(() => props.target, (newValue) => {
                var _a;
                (_a = instance.value) == null ? void 0 : _a.dispose();
                generatePopoverInstance(newValue);
              });
              (0, external_vue_.watch)(() => showBoolean.value, (show, oldVal) => {
                var _a, _b;
                if (show !== oldVal) {
                  if (show) {
                    (_a = instance.value) == null ? void 0 : _a.show();
                  } else {
                    (_b = instance.value) == null ? void 0 : _b.hide();
                  }
                }
              });
              useEventListener(target, "show.bs.popover", () => emit("show"));
              useEventListener(target, "shown.bs.popover", () => emit("shown"));
              useEventListener(target, "hide.bs.popover", () => emit("hide"));
              useEventListener(target, "hidden.bs.popover", () => emit("hidden"));
              useEventListener(target, "inserted.bs.popover", () => emit("inserted"));
              return {
                element,
                titleRef,
                contentRef,
                classes,
                disabledBoolean
              };
            }
          });
          ;
          ;
          ;
          const fsPopover_exports_ = (0, exportHelper.Z)(fsPopovervue_type_script_lang_ts, [["render", fsPopovervue_type_template_id_cdccb86a_ts_true_render]]);
          var fsPopover = fsPopover_exports_;
          var debounce = __webpack_require__(2562);
          ;
          function useClickAway(target, handler) {
            const event = "pointerdown";
            if (typeof window === "undefined" || !window) {
              return;
            }
            const listener = (event2) => {
              const el = (0, external_vue_.unref)(target);
              if (!el) {
                return;
              }
              if (el === event2.target || event2.composedPath().includes(el)) {
                return;
              }
              handler(event2);
            };
            return useEventListener(window, event, listener);
          }
          ;
          function useContent(slots, popperNode, content) {
            let observer = null;
            const hasContent = (0, external_vue_.ref)(false);
            (0, external_vue_.onMounted)(() => {
              if (slots.content !== void 0 || content.value) {
                hasContent.value = true;
              }
              observer = new MutationObserver(checkContent);
              observer.observe(popperNode.value, {
                childList: true,
                subtree: true
              });
            });
            (0, external_vue_.onBeforeUnmount)(() => observer.disconnect());
            (0, external_vue_.watch)(content, (content2) => {
              if (content2) {
                hasContent.value = true;
              } else {
                hasContent.value = false;
              }
            });
            const checkContent = () => {
              if (slots.content) {
                hasContent.value = true;
              } else {
                hasContent.value = false;
              }
            };
            return {
              hasContent
            };
          }
          ;
          function getWindow(node) {
            if (node == null) {
              return window;
            }
            if (node.toString() !== "[object Window]") {
              var ownerDocument = node.ownerDocument;
              return ownerDocument ? ownerDocument.defaultView || window : window;
            }
            return node;
          }
          ;
          function instanceOf_isElement(node) {
            var OwnElement = getWindow(node).Element;
            return node instanceof OwnElement || node instanceof Element;
          }
          function isHTMLElement(node) {
            var OwnElement = getWindow(node).HTMLElement;
            return node instanceof OwnElement || node instanceof HTMLElement;
          }
          function isShadowRoot(node) {
            if (typeof ShadowRoot === "undefined") {
              return false;
            }
            var OwnElement = getWindow(node).ShadowRoot;
            return node instanceof OwnElement || node instanceof ShadowRoot;
          }
          ;
          var math_max = Math.max;
          var math_min = Math.min;
          var round = Math.round;
          ;
          function getUAString() {
            var uaData = navigator.userAgentData;
            if (uaData != null && uaData.brands) {
              return uaData.brands.map(function(item) {
                return item.brand + "/" + item.version;
              }).join(" ");
            }
            return navigator.userAgent;
          }
          ;
          function isLayoutViewport() {
            return !/^((?!chrome|android).)*safari/i.test(getUAString());
          }
          ;
          function getBoundingClientRect(element, includeScale, isFixedStrategy) {
            if (includeScale === void 0) {
              includeScale = false;
            }
            if (isFixedStrategy === void 0) {
              isFixedStrategy = false;
            }
            var clientRect = element.getBoundingClientRect();
            var scaleX = 1;
            var scaleY = 1;
            if (includeScale && isHTMLElement(element)) {
              scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
              scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
            }
            var _ref = instanceOf_isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
            var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
            var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
            var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
            var width = clientRect.width / scaleX;
            var height = clientRect.height / scaleY;
            return {
              width,
              height,
              top: y,
              right: x + width,
              bottom: y + height,
              left: x,
              x,
              y
            };
          }
          ;
          function getWindowScroll(node) {
            var win = getWindow(node);
            var scrollLeft = win.pageXOffset;
            var scrollTop = win.pageYOffset;
            return {
              scrollLeft,
              scrollTop
            };
          }
          ;
          function getHTMLElementScroll(element) {
            return {
              scrollLeft: element.scrollLeft,
              scrollTop: element.scrollTop
            };
          }
          ;
          function getNodeScroll(node) {
            if (node === getWindow(node) || !isHTMLElement(node)) {
              return getWindowScroll(node);
            } else {
              return getHTMLElementScroll(node);
            }
          }
          ;
          function getNodeName(element) {
            return element ? (element.nodeName || "").toLowerCase() : null;
          }
          ;
          function getDocumentElement(element) {
            return ((instanceOf_isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
          }
          ;
          function getWindowScrollBarX(element) {
            return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
          }
          ;
          function getComputedStyle(element) {
            return getWindow(element).getComputedStyle(element);
          }
          ;
          function isScrollParent(element) {
            var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
            return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
          }
          ;
          function isElementScaled(element) {
            var rect = element.getBoundingClientRect();
            var scaleX = round(rect.width) / element.offsetWidth || 1;
            var scaleY = round(rect.height) / element.offsetHeight || 1;
            return scaleX !== 1 || scaleY !== 1;
          }
          function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
            if (isFixed === void 0) {
              isFixed = false;
            }
            var isOffsetParentAnElement = isHTMLElement(offsetParent);
            var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
            var documentElement = getDocumentElement(offsetParent);
            var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
            var scroll = {
              scrollLeft: 0,
              scrollTop: 0
            };
            var offsets = {
              x: 0,
              y: 0
            };
            if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
              if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
                scroll = getNodeScroll(offsetParent);
              }
              if (isHTMLElement(offsetParent)) {
                offsets = getBoundingClientRect(offsetParent, true);
                offsets.x += offsetParent.clientLeft;
                offsets.y += offsetParent.clientTop;
              } else if (documentElement) {
                offsets.x = getWindowScrollBarX(documentElement);
              }
            }
            return {
              x: rect.left + scroll.scrollLeft - offsets.x,
              y: rect.top + scroll.scrollTop - offsets.y,
              width: rect.width,
              height: rect.height
            };
          }
          ;
          function getLayoutRect(element) {
            var clientRect = getBoundingClientRect(element);
            var width = element.offsetWidth;
            var height = element.offsetHeight;
            if (Math.abs(clientRect.width - width) <= 1) {
              width = clientRect.width;
            }
            if (Math.abs(clientRect.height - height) <= 1) {
              height = clientRect.height;
            }
            return {
              x: element.offsetLeft,
              y: element.offsetTop,
              width,
              height
            };
          }
          ;
          function getParentNode(element) {
            if (getNodeName(element) === "html") {
              return element;
            }
            return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
          }
          ;
          function getScrollParent(node) {
            if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
              return node.ownerDocument.body;
            }
            if (isHTMLElement(node) && isScrollParent(node)) {
              return node;
            }
            return getScrollParent(getParentNode(node));
          }
          ;
          function listScrollParents(element, list) {
            var _element$ownerDocumen;
            if (list === void 0) {
              list = [];
            }
            var scrollParent = getScrollParent(element);
            var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
            var win = getWindow(scrollParent);
            var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
            var updatedList = list.concat(target);
            return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
          }
          ;
          function isTableElement(element) {
            return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
          }
          ;
          function getTrueOffsetParent(element) {
            if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
              return null;
            }
            return element.offsetParent;
          }
          function getContainingBlock(element) {
            var isFirefox = /firefox/i.test(getUAString());
            var isIE = /Trident/i.test(getUAString());
            if (isIE && isHTMLElement(element)) {
              var elementCss = getComputedStyle(element);
              if (elementCss.position === "fixed") {
                return null;
              }
            }
            var currentNode = getParentNode(element);
            if (isShadowRoot(currentNode)) {
              currentNode = currentNode.host;
            }
            while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
              var css = getComputedStyle(currentNode);
              if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
                return currentNode;
              } else {
                currentNode = currentNode.parentNode;
              }
            }
            return null;
          }
          function getOffsetParent(element) {
            var window2 = getWindow(element);
            var offsetParent = getTrueOffsetParent(element);
            while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
              offsetParent = getTrueOffsetParent(offsetParent);
            }
            if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
              return window2;
            }
            return offsetParent || getContainingBlock(element) || window2;
          }
          ;
          var enums_top = "top";
          var bottom = "bottom";
          var right = "right";
          var left = "left";
          var auto = "auto";
          var basePlacements = [enums_top, bottom, right, left];
          var start = "start";
          var end = "end";
          var clippingParents = "clippingParents";
          var viewport = "viewport";
          var popper = "popper";
          var reference = "reference";
          var variationPlacements = basePlacements.reduce(function(acc, placement) {
            return acc.concat([placement + "-" + start, placement + "-" + end]);
          }, []);
          var enums_placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
            return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
          }, []);
          var beforeRead = "beforeRead";
          var read = "read";
          var afterRead = "afterRead";
          var beforeMain = "beforeMain";
          var main = "main";
          var afterMain = "afterMain";
          var beforeWrite = "beforeWrite";
          var write = "write";
          var afterWrite = "afterWrite";
          var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
          ;
          function order(modifiers) {
            var map = /* @__PURE__ */ new Map();
            var visited = /* @__PURE__ */ new Set();
            var result = [];
            modifiers.forEach(function(modifier) {
              map.set(modifier.name, modifier);
            });
            function sort(modifier) {
              visited.add(modifier.name);
              var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
              requires.forEach(function(dep) {
                if (!visited.has(dep)) {
                  var depModifier = map.get(dep);
                  if (depModifier) {
                    sort(depModifier);
                  }
                }
              });
              result.push(modifier);
            }
            modifiers.forEach(function(modifier) {
              if (!visited.has(modifier.name)) {
                sort(modifier);
              }
            });
            return result;
          }
          function orderModifiers(modifiers) {
            var orderedModifiers = order(modifiers);
            return modifierPhases.reduce(function(acc, phase) {
              return acc.concat(orderedModifiers.filter(function(modifier) {
                return modifier.phase === phase;
              }));
            }, []);
          }
          ;
          function debounce_debounce(fn) {
            var pending;
            return function() {
              if (!pending) {
                pending = new Promise(function(resolve) {
                  Promise.resolve().then(function() {
                    pending = void 0;
                    resolve(fn());
                  });
                });
              }
              return pending;
            };
          }
          ;
          function mergeByName(modifiers) {
            var merged = modifiers.reduce(function(merged2, current) {
              var existing = merged2[current.name];
              merged2[current.name] = existing ? Object.assign({}, existing, current, {
                options: Object.assign({}, existing.options, current.options),
                data: Object.assign({}, existing.data, current.data)
              }) : current;
              return merged2;
            }, {});
            return Object.keys(merged).map(function(key) {
              return merged[key];
            });
          }
          ;
          var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
          var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
          var DEFAULT_OPTIONS = {
            placement: "bottom",
            modifiers: [],
            strategy: "absolute"
          };
          function areValidElements() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return !args.some(function(element) {
              return !(element && typeof element.getBoundingClientRect === "function");
            });
          }
          function popperGenerator(generatorOptions) {
            if (generatorOptions === void 0) {
              generatorOptions = {};
            }
            var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
            return function createPopper2(reference2, popper2, options) {
              if (options === void 0) {
                options = defaultOptions;
              }
              var state = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
                modifiersData: {},
                elements: {
                  reference: reference2,
                  popper: popper2
                },
                attributes: {},
                styles: {}
              };
              var effectCleanupFns = [];
              var isDestroyed = false;
              var instance = {
                state,
                setOptions: function setOptions(setOptionsAction) {
                  var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
                  cleanupModifierEffects();
                  state.options = Object.assign({}, defaultOptions, state.options, options2);
                  state.scrollParents = {
                    reference: instanceOf_isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
                    popper: listScrollParents(popper2)
                  };
                  var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
                  state.orderedModifiers = orderedModifiers.filter(function(m) {
                    return m.enabled;
                  });
                  if (false) {
                    var _getComputedStyle, marginTop, marginRight, marginBottom, marginLeft, flipModifier, modifiers;
                  }
                  runModifierEffects();
                  return instance.update();
                },
                forceUpdate: function forceUpdate() {
                  if (isDestroyed) {
                    return;
                  }
                  var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
                  if (!areValidElements(reference3, popper3)) {
                    if (false) {
                    }
                    return;
                  }
                  state.rects = {
                    reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
                    popper: getLayoutRect(popper3)
                  };
                  state.reset = false;
                  state.placement = state.options.placement;
                  state.orderedModifiers.forEach(function(modifier) {
                    return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                  });
                  var __debug_loops__ = 0;
                  for (var index = 0; index < state.orderedModifiers.length; index++) {
                    if (false) {
                    }
                    if (state.reset === true) {
                      state.reset = false;
                      index = -1;
                      continue;
                    }
                    var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                    if (typeof fn === "function") {
                      state = fn({
                        state,
                        options: _options,
                        name,
                        instance
                      }) || state;
                    }
                  }
                },
                update: debounce_debounce(function() {
                  return new Promise(function(resolve) {
                    instance.forceUpdate();
                    resolve(state);
                  });
                }),
                destroy: function destroy() {
                  cleanupModifierEffects();
                  isDestroyed = true;
                }
              };
              if (!areValidElements(reference2, popper2)) {
                if (false) {
                }
                return instance;
              }
              instance.setOptions(options).then(function(state2) {
                if (!isDestroyed && options.onFirstUpdate) {
                  options.onFirstUpdate(state2);
                }
              });
              function runModifierEffects() {
                state.orderedModifiers.forEach(function(_ref3) {
                  var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
                  if (typeof effect2 === "function") {
                    var cleanupFn = effect2({
                      state,
                      name,
                      instance,
                      options: options2
                    });
                    var noopFn = function noopFn2() {
                    };
                    effectCleanupFns.push(cleanupFn || noopFn);
                  }
                });
              }
              function cleanupModifierEffects() {
                effectCleanupFns.forEach(function(fn) {
                  return fn();
                });
                effectCleanupFns = [];
              }
              return instance;
            };
          }
          var createPopper = null;
          ;
          var passive = {
            passive: true
          };
          function effect(_ref) {
            var state = _ref.state, instance = _ref.instance, options = _ref.options;
            var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
            var window2 = getWindow(state.elements.popper);
            var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
            if (scroll) {
              scrollParents.forEach(function(scrollParent) {
                scrollParent.addEventListener("scroll", instance.update, passive);
              });
            }
            if (resize) {
              window2.addEventListener("resize", instance.update, passive);
            }
            return function() {
              if (scroll) {
                scrollParents.forEach(function(scrollParent) {
                  scrollParent.removeEventListener("scroll", instance.update, passive);
                });
              }
              if (resize) {
                window2.removeEventListener("resize", instance.update, passive);
              }
            };
          }
          var eventListeners = {
            name: "eventListeners",
            enabled: true,
            phase: "write",
            fn: function fn() {
            },
            effect,
            data: {}
          };
          ;
          function getBasePlacement(placement) {
            return placement.split("-")[0];
          }
          ;
          function getVariation(placement) {
            return placement.split("-")[1];
          }
          ;
          function getMainAxisFromPlacement(placement) {
            return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
          }
          ;
          function computeOffsets(_ref) {
            var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
            var basePlacement = placement ? getBasePlacement(placement) : null;
            var variation = placement ? getVariation(placement) : null;
            var commonX = reference2.x + reference2.width / 2 - element.width / 2;
            var commonY = reference2.y + reference2.height / 2 - element.height / 2;
            var offsets;
            switch (basePlacement) {
              case enums_top:
                offsets = {
                  x: commonX,
                  y: reference2.y - element.height
                };
                break;
              case bottom:
                offsets = {
                  x: commonX,
                  y: reference2.y + reference2.height
                };
                break;
              case right:
                offsets = {
                  x: reference2.x + reference2.width,
                  y: commonY
                };
                break;
              case left:
                offsets = {
                  x: reference2.x - element.width,
                  y: commonY
                };
                break;
              default:
                offsets = {
                  x: reference2.x,
                  y: reference2.y
                };
            }
            var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
            if (mainAxis != null) {
              var len = mainAxis === "y" ? "height" : "width";
              switch (variation) {
                case start:
                  offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
                  break;
                case end:
                  offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
                  break;
                default:
              }
            }
            return offsets;
          }
          ;
          function popperOffsets(_ref) {
            var state = _ref.state, name = _ref.name;
            state.modifiersData[name] = computeOffsets({
              reference: state.rects.reference,
              element: state.rects.popper,
              strategy: "absolute",
              placement: state.placement
            });
          }
          var modifiers_popperOffsets = {
            name: "popperOffsets",
            enabled: true,
            phase: "read",
            fn: popperOffsets,
            data: {}
          };
          ;
          var unsetSides = {
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto"
          };
          function roundOffsetsByDPR(_ref) {
            var x = _ref.x, y = _ref.y;
            var win = window;
            var dpr = win.devicePixelRatio || 1;
            return {
              x: round(x * dpr) / dpr || 0,
              y: round(y * dpr) / dpr || 0
            };
          }
          function mapToStyles(_ref2) {
            var _Object$assign2;
            var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
            var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
            var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
              x,
              y
            }) : {
              x,
              y
            };
            x = _ref3.x;
            y = _ref3.y;
            var hasX = offsets.hasOwnProperty("x");
            var hasY = offsets.hasOwnProperty("y");
            var sideX = left;
            var sideY = enums_top;
            var win = window;
            if (adaptive) {
              var offsetParent = getOffsetParent(popper2);
              var heightProp = "clientHeight";
              var widthProp = "clientWidth";
              if (offsetParent === getWindow(popper2)) {
                offsetParent = getDocumentElement(popper2);
                if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
                  heightProp = "scrollHeight";
                  widthProp = "scrollWidth";
                }
              }
              offsetParent = offsetParent;
              if (placement === enums_top || (placement === left || placement === right) && variation === end) {
                sideY = bottom;
                var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
                y -= offsetY - popperRect.height;
                y *= gpuAcceleration ? 1 : -1;
              }
              if (placement === left || (placement === enums_top || placement === bottom) && variation === end) {
                sideX = right;
                var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
                x -= offsetX - popperRect.width;
                x *= gpuAcceleration ? 1 : -1;
              }
            }
            var commonStyles = Object.assign({
              position
            }, adaptive && unsetSides);
            var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
              x,
              y
            }) : {
              x,
              y
            };
            x = _ref4.x;
            y = _ref4.y;
            if (gpuAcceleration) {
              var _Object$assign;
              return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
            }
            return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
          }
          function computeStyles(_ref5) {
            var state = _ref5.state, options = _ref5.options;
            var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
            if (false) {
              var transitionProperty;
            }
            var commonStyles = {
              placement: getBasePlacement(state.placement),
              variation: getVariation(state.placement),
              popper: state.elements.popper,
              popperRect: state.rects.popper,
              gpuAcceleration,
              isFixed: state.options.strategy === "fixed"
            };
            if (state.modifiersData.popperOffsets != null) {
              state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
                offsets: state.modifiersData.popperOffsets,
                position: state.options.strategy,
                adaptive,
                roundOffsets
              })));
            }
            if (state.modifiersData.arrow != null) {
              state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
                offsets: state.modifiersData.arrow,
                position: "absolute",
                adaptive: false,
                roundOffsets
              })));
            }
            state.attributes.popper = Object.assign({}, state.attributes.popper, {
              "data-popper-placement": state.placement
            });
          }
          var modifiers_computeStyles = {
            name: "computeStyles",
            enabled: true,
            phase: "beforeWrite",
            fn: computeStyles,
            data: {}
          };
          ;
          function applyStyles(_ref) {
            var state = _ref.state;
            Object.keys(state.elements).forEach(function(name) {
              var style = state.styles[name] || {};
              var attributes = state.attributes[name] || {};
              var element = state.elements[name];
              if (!isHTMLElement(element) || !getNodeName(element)) {
                return;
              }
              Object.assign(element.style, style);
              Object.keys(attributes).forEach(function(name2) {
                var value = attributes[name2];
                if (value === false) {
                  element.removeAttribute(name2);
                } else {
                  element.setAttribute(name2, value === true ? "" : value);
                }
              });
            });
          }
          function applyStyles_effect(_ref2) {
            var state = _ref2.state;
            var initialStyles = {
              popper: {
                position: state.options.strategy,
                left: "0",
                top: "0",
                margin: "0"
              },
              arrow: {
                position: "absolute"
              },
              reference: {}
            };
            Object.assign(state.elements.popper.style, initialStyles.popper);
            state.styles = initialStyles;
            if (state.elements.arrow) {
              Object.assign(state.elements.arrow.style, initialStyles.arrow);
            }
            return function() {
              Object.keys(state.elements).forEach(function(name) {
                var element = state.elements[name];
                var attributes = state.attributes[name] || {};
                var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
                var style = styleProperties.reduce(function(style2, property) {
                  style2[property] = "";
                  return style2;
                }, {});
                if (!isHTMLElement(element) || !getNodeName(element)) {
                  return;
                }
                Object.assign(element.style, style);
                Object.keys(attributes).forEach(function(attribute) {
                  element.removeAttribute(attribute);
                });
              });
            };
          }
          var modifiers_applyStyles = {
            name: "applyStyles",
            enabled: true,
            phase: "write",
            fn: applyStyles,
            effect: applyStyles_effect,
            requires: ["computeStyles"]
          };
          ;
          var defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles];
          var popper_lite_createPopper = popperGenerator({
            defaultModifiers
          });
          ;
          function getAltAxis(axis) {
            return axis === "x" ? "y" : "x";
          }
          ;
          function within(min, value, max) {
            return math_max(min, math_min(value, max));
          }
          function withinMaxClamp(min, value, max) {
            var v = within(min, value, max);
            return v > max ? max : v;
          }
          ;
          function getViewportRect(element, strategy) {
            var win = getWindow(element);
            var html = getDocumentElement(element);
            var visualViewport = win.visualViewport;
            var width = html.clientWidth;
            var height = html.clientHeight;
            var x = 0;
            var y = 0;
            if (visualViewport) {
              width = visualViewport.width;
              height = visualViewport.height;
              var layoutViewport = isLayoutViewport();
              if (layoutViewport || !layoutViewport && strategy === "fixed") {
                x = visualViewport.offsetLeft;
                y = visualViewport.offsetTop;
              }
            }
            return {
              width,
              height,
              x: x + getWindowScrollBarX(element),
              y
            };
          }
          ;
          function getDocumentRect(element) {
            var _element$ownerDocumen;
            var html = getDocumentElement(element);
            var winScroll = getWindowScroll(element);
            var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
            var width = math_max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
            var height = math_max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
            var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
            var y = -winScroll.scrollTop;
            if (getComputedStyle(body || html).direction === "rtl") {
              x += math_max(html.clientWidth, body ? body.clientWidth : 0) - width;
            }
            return {
              width,
              height,
              x,
              y
            };
          }
          ;
          function contains_contains(parent, child) {
            var rootNode = child.getRootNode && child.getRootNode();
            if (parent.contains(child)) {
              return true;
            } else if (rootNode && isShadowRoot(rootNode)) {
              var next = child;
              do {
                if (next && parent.isSameNode(next)) {
                  return true;
                }
                next = next.parentNode || next.host;
              } while (next);
            }
            return false;
          }
          ;
          function rectToClientRect(rect) {
            return Object.assign({}, rect, {
              left: rect.x,
              top: rect.y,
              right: rect.x + rect.width,
              bottom: rect.y + rect.height
            });
          }
          ;
          function getInnerBoundingClientRect(element, strategy) {
            var rect = getBoundingClientRect(element, false, strategy === "fixed");
            rect.top = rect.top + element.clientTop;
            rect.left = rect.left + element.clientLeft;
            rect.bottom = rect.top + element.clientHeight;
            rect.right = rect.left + element.clientWidth;
            rect.width = element.clientWidth;
            rect.height = element.clientHeight;
            rect.x = rect.left;
            rect.y = rect.top;
            return rect;
          }
          function getClientRectFromMixedType(element, clippingParent, strategy) {
            return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : instanceOf_isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
          }
          function getClippingParents(element) {
            var clippingParents2 = listScrollParents(getParentNode(element));
            var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
            var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
            if (!instanceOf_isElement(clipperElement)) {
              return [];
            }
            return clippingParents2.filter(function(clippingParent) {
              return instanceOf_isElement(clippingParent) && contains_contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
            });
          }
          function getClippingRect(element, boundary, rootBoundary, strategy) {
            var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
            var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
            var firstClippingParent = clippingParents2[0];
            var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
              var rect = getClientRectFromMixedType(element, clippingParent, strategy);
              accRect.top = math_max(rect.top, accRect.top);
              accRect.right = math_min(rect.right, accRect.right);
              accRect.bottom = math_min(rect.bottom, accRect.bottom);
              accRect.left = math_max(rect.left, accRect.left);
              return accRect;
            }, getClientRectFromMixedType(element, firstClippingParent, strategy));
            clippingRect.width = clippingRect.right - clippingRect.left;
            clippingRect.height = clippingRect.bottom - clippingRect.top;
            clippingRect.x = clippingRect.left;
            clippingRect.y = clippingRect.top;
            return clippingRect;
          }
          ;
          function getFreshSideObject() {
            return {
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
            };
          }
          ;
          function mergePaddingObject(paddingObject) {
            return Object.assign({}, getFreshSideObject(), paddingObject);
          }
          ;
          function expandToHashMap(value, keys2) {
            return keys2.reduce(function(hashMap, key) {
              hashMap[key] = value;
              return hashMap;
            }, {});
          }
          ;
          function detectOverflow(state, options) {
            if (options === void 0) {
              options = {};
            }
            var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
            var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
            var altContext = elementContext === popper ? reference : popper;
            var popperRect = state.rects.popper;
            var element = state.elements[altBoundary ? altContext : elementContext];
            var clippingClientRect = getClippingRect(instanceOf_isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
            var referenceClientRect = getBoundingClientRect(state.elements.reference);
            var popperOffsets2 = computeOffsets({
              reference: referenceClientRect,
              element: popperRect,
              strategy: "absolute",
              placement
            });
            var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
            var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
            var overflowOffsets = {
              top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
              bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
              left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
              right: elementClientRect.right - clippingClientRect.right + paddingObject.right
            };
            var offsetData = state.modifiersData.offset;
            if (elementContext === popper && offsetData) {
              var offset2 = offsetData[placement];
              Object.keys(overflowOffsets).forEach(function(key) {
                var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
                var axis = [enums_top, bottom].indexOf(key) >= 0 ? "y" : "x";
                overflowOffsets[key] += offset2[axis] * multiply;
              });
            }
            return overflowOffsets;
          }
          ;
          function preventOverflow(_ref) {
            var state = _ref.state, options = _ref.options, name = _ref.name;
            var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
            var overflow = detectOverflow(state, {
              boundary,
              rootBoundary,
              padding,
              altBoundary
            });
            var basePlacement = getBasePlacement(state.placement);
            var variation = getVariation(state.placement);
            var isBasePlacement = !variation;
            var mainAxis = getMainAxisFromPlacement(basePlacement);
            var altAxis = getAltAxis(mainAxis);
            var popperOffsets2 = state.modifiersData.popperOffsets;
            var referenceRect = state.rects.reference;
            var popperRect = state.rects.popper;
            var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
              placement: state.placement
            })) : tetherOffset;
            var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
              mainAxis: tetherOffsetValue,
              altAxis: tetherOffsetValue
            } : Object.assign({
              mainAxis: 0,
              altAxis: 0
            }, tetherOffsetValue);
            var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
            var data = {
              x: 0,
              y: 0
            };
            if (!popperOffsets2) {
              return;
            }
            if (checkMainAxis) {
              var _offsetModifierState$;
              var mainSide = mainAxis === "y" ? enums_top : left;
              var altSide = mainAxis === "y" ? bottom : right;
              var len = mainAxis === "y" ? "height" : "width";
              var offset2 = popperOffsets2[mainAxis];
              var min = offset2 + overflow[mainSide];
              var max = offset2 - overflow[altSide];
              var additive = tether ? -popperRect[len] / 2 : 0;
              var minLen = variation === start ? referenceRect[len] : popperRect[len];
              var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
              var arrowElement = state.elements.arrow;
              var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
                width: 0,
                height: 0
              };
              var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
              var arrowPaddingMin = arrowPaddingObject[mainSide];
              var arrowPaddingMax = arrowPaddingObject[altSide];
              var arrowLen = within(0, referenceRect[len], arrowRect[len]);
              var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
              var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
              var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
              var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
              var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
              var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
              var tetherMax = offset2 + maxOffset - offsetModifierValue;
              var preventedOffset = within(tether ? math_min(min, tetherMin) : min, offset2, tether ? math_max(max, tetherMax) : max);
              popperOffsets2[mainAxis] = preventedOffset;
              data[mainAxis] = preventedOffset - offset2;
            }
            if (checkAltAxis) {
              var _offsetModifierState$2;
              var _mainSide = mainAxis === "x" ? enums_top : left;
              var _altSide = mainAxis === "x" ? bottom : right;
              var _offset = popperOffsets2[altAxis];
              var _len = altAxis === "y" ? "height" : "width";
              var _min = _offset + overflow[_mainSide];
              var _max = _offset - overflow[_altSide];
              var isOriginSide = [enums_top, left].indexOf(basePlacement) !== -1;
              var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
              var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
              var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
              var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
              popperOffsets2[altAxis] = _preventedOffset;
              data[altAxis] = _preventedOffset - _offset;
            }
            state.modifiersData[name] = data;
          }
          var modifiers_preventOverflow = {
            name: "preventOverflow",
            enabled: true,
            phase: "main",
            fn: preventOverflow,
            requiresIfExists: ["offset"]
          };
          ;
          var hash = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
          };
          function getOppositePlacement(placement) {
            return placement.replace(/left|right|bottom|top/g, function(matched) {
              return hash[matched];
            });
          }
          ;
          var getOppositeVariationPlacement_hash = {
            start: "end",
            end: "start"
          };
          function getOppositeVariationPlacement(placement) {
            return placement.replace(/start|end/g, function(matched) {
              return getOppositeVariationPlacement_hash[matched];
            });
          }
          ;
          function computeAutoPlacement(state, options) {
            if (options === void 0) {
              options = {};
            }
            var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? enums_placements : _options$allowedAutoP;
            var variation = getVariation(placement);
            var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
              return getVariation(placement2) === variation;
            }) : basePlacements;
            var allowedPlacements = placements.filter(function(placement2) {
              return allowedAutoPlacements.indexOf(placement2) >= 0;
            });
            if (allowedPlacements.length === 0) {
              allowedPlacements = placements;
              if (false) {
              }
            }
            var overflows = allowedPlacements.reduce(function(acc, placement2) {
              acc[placement2] = detectOverflow(state, {
                placement: placement2,
                boundary,
                rootBoundary,
                padding
              })[getBasePlacement(placement2)];
              return acc;
            }, {});
            return Object.keys(overflows).sort(function(a, b) {
              return overflows[a] - overflows[b];
            });
          }
          ;
          function getExpandedFallbackPlacements(placement) {
            if (getBasePlacement(placement) === auto) {
              return [];
            }
            var oppositePlacement = getOppositePlacement(placement);
            return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
          }
          function flip(_ref) {
            var state = _ref.state, options = _ref.options, name = _ref.name;
            if (state.modifiersData[name]._skip) {
              return;
            }
            var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
            var preferredPlacement = state.options.placement;
            var basePlacement = getBasePlacement(preferredPlacement);
            var isBasePlacement = basePlacement === preferredPlacement;
            var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
            var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
              return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
                placement: placement2,
                boundary,
                rootBoundary,
                padding,
                flipVariations,
                allowedAutoPlacements
              }) : placement2);
            }, []);
            var referenceRect = state.rects.reference;
            var popperRect = state.rects.popper;
            var checksMap = /* @__PURE__ */ new Map();
            var makeFallbackChecks = true;
            var firstFittingPlacement = placements[0];
            for (var i = 0; i < placements.length; i++) {
              var placement = placements[i];
              var _basePlacement = getBasePlacement(placement);
              var isStartVariation = getVariation(placement) === start;
              var isVertical = [enums_top, bottom].indexOf(_basePlacement) >= 0;
              var len = isVertical ? "width" : "height";
              var overflow = detectOverflow(state, {
                placement,
                boundary,
                rootBoundary,
                altBoundary,
                padding
              });
              var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : enums_top;
              if (referenceRect[len] > popperRect[len]) {
                mainVariationSide = getOppositePlacement(mainVariationSide);
              }
              var altVariationSide = getOppositePlacement(mainVariationSide);
              var checks = [];
              if (checkMainAxis) {
                checks.push(overflow[_basePlacement] <= 0);
              }
              if (checkAltAxis) {
                checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
              }
              if (checks.every(function(check) {
                return check;
              })) {
                firstFittingPlacement = placement;
                makeFallbackChecks = false;
                break;
              }
              checksMap.set(placement, checks);
            }
            if (makeFallbackChecks) {
              var numberOfChecks = flipVariations ? 3 : 1;
              var _loop = function _loop2(_i2) {
                var fittingPlacement = placements.find(function(placement2) {
                  var checks2 = checksMap.get(placement2);
                  if (checks2) {
                    return checks2.slice(0, _i2).every(function(check) {
                      return check;
                    });
                  }
                });
                if (fittingPlacement) {
                  firstFittingPlacement = fittingPlacement;
                  return "break";
                }
              };
              for (var _i = numberOfChecks; _i > 0; _i--) {
                var _ret = _loop(_i);
                if (_ret === "break")
                  break;
              }
            }
            if (state.placement !== firstFittingPlacement) {
              state.modifiersData[name]._skip = true;
              state.placement = firstFittingPlacement;
              state.reset = true;
            }
          }
          var modifiers_flip = {
            name: "flip",
            enabled: true,
            phase: "main",
            fn: flip,
            requiresIfExists: ["offset"],
            data: {
              _skip: false
            }
          };
          ;
          function distanceAndSkiddingToXY(placement, rects, offset2) {
            var basePlacement = getBasePlacement(placement);
            var invertDistance = [left, enums_top].indexOf(basePlacement) >= 0 ? -1 : 1;
            var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
              placement
            })) : offset2, skidding = _ref[0], distance = _ref[1];
            skidding = skidding || 0;
            distance = (distance || 0) * invertDistance;
            return [left, right].indexOf(basePlacement) >= 0 ? {
              x: distance,
              y: skidding
            } : {
              x: skidding,
              y: distance
            };
          }
          function offset_offset(_ref2) {
            var state = _ref2.state, options = _ref2.options, name = _ref2.name;
            var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
            var data = enums_placements.reduce(function(acc, placement) {
              acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
              return acc;
            }, {});
            var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
            if (state.modifiersData.popperOffsets != null) {
              state.modifiersData.popperOffsets.x += x;
              state.modifiersData.popperOffsets.y += y;
            }
            state.modifiersData[name] = data;
          }
          var modifiers_offset = {
            name: "offset",
            enabled: true,
            phase: "main",
            requires: ["popperOffsets"],
            fn: offset_offset
          };
          ;
          var toPaddingObject = function toPaddingObject2(padding, state) {
            padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
              placement: state.placement
            })) : padding;
            return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
          };
          function arrow(_ref) {
            var _state$modifiersData$;
            var state = _ref.state, name = _ref.name, options = _ref.options;
            var arrowElement = state.elements.arrow;
            var popperOffsets2 = state.modifiersData.popperOffsets;
            var basePlacement = getBasePlacement(state.placement);
            var axis = getMainAxisFromPlacement(basePlacement);
            var isVertical = [left, right].indexOf(basePlacement) >= 0;
            var len = isVertical ? "height" : "width";
            if (!arrowElement || !popperOffsets2) {
              return;
            }
            var paddingObject = toPaddingObject(options.padding, state);
            var arrowRect = getLayoutRect(arrowElement);
            var minProp = axis === "y" ? enums_top : left;
            var maxProp = axis === "y" ? bottom : right;
            var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
            var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
            var arrowOffsetParent = getOffsetParent(arrowElement);
            var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
            var centerToReference = endDiff / 2 - startDiff / 2;
            var min = paddingObject[minProp];
            var max = clientSize - arrowRect[len] - paddingObject[maxProp];
            var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
            var offset2 = within(min, center, max);
            var axisProp = axis;
            state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
          }
          function arrow_effect(_ref2) {
            var state = _ref2.state, options = _ref2.options;
            var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
            if (arrowElement == null) {
              return;
            }
            if (typeof arrowElement === "string") {
              arrowElement = state.elements.popper.querySelector(arrowElement);
              if (!arrowElement) {
                return;
              }
            }
            if (false) {
            }
            if (!contains_contains(state.elements.popper, arrowElement)) {
              if (false) {
              }
              return;
            }
            state.elements.arrow = arrowElement;
          }
          var modifiers_arrow = {
            name: "arrow",
            enabled: true,
            phase: "main",
            fn: arrow,
            effect: arrow_effect,
            requires: ["popperOffsets"],
            requiresIfExists: ["preventOverflow"]
          };
          ;
          const toInt = (x) => parseInt(x, 10);
          function usePopper({
            arrowPadding,
            emit,
            locked,
            offsetDistance,
            offsetSkid,
            placement,
            popperNode,
            triggerNode
          }) {
            const state = (0, external_vue_.reactive)({
              isOpen: false,
              popperInstance: null
            });
            const setPopperEventListeners = (enabled) => {
              var _a;
              (_a = state.popperInstance) == null ? void 0 : _a.setOptions((options) => ({
                ...options,
                modifiers: [...options.modifiers, {
                  name: "eventListeners",
                  enabled
                }]
              }));
            };
            const enablePopperEventListeners = () => setPopperEventListeners(true);
            const disablePopperEventListeners = () => setPopperEventListeners(false);
            const close = () => {
              if (!state.isOpen) {
                return;
              }
              state.isOpen = false;
              emit("close:popper");
            };
            const open = () => {
              if (state.isOpen) {
                return;
              }
              state.isOpen = true;
              emit("open:popper");
            };
            (0, external_vue_.watch)([() => state.isOpen, placement], async ([isOpen]) => {
              if (isOpen) {
                await initializePopper();
                enablePopperEventListeners();
              } else {
                disablePopperEventListeners();
              }
            }, {
              deep: true
            });
            const initializePopper = async () => {
              await (0, external_vue_.nextTick)();
              state.popperInstance = popper_lite_createPopper(triggerNode.value, popperNode.value, {
                placement: placement.value,
                modifiers: [modifiers_preventOverflow, modifiers_flip, {
                  name: "flip",
                  enabled: !locked.value
                }, modifiers_arrow, {
                  name: "arrow",
                  options: {
                    padding: toInt(arrowPadding.value)
                  }
                }, modifiers_offset, {
                  name: "offset",
                  options: {
                    offset: [toInt(offsetSkid.value), toInt(offsetDistance.value)]
                  }
                }]
              });
              state.popperInstance.update();
            };
            (0, external_vue_.onBeforeUnmount)(() => {
              var _a;
              (_a = state.popperInstance) == null ? void 0 : _a.destroy();
            });
            return {
              ...(0, external_vue_.toRefs)(state),
              open,
              close
            };
          }
          ;
          ;
          const _withScopeId = (n) => (_pushScopeId("data-v-1f05f900"), n = n(), _popScopeId(), n);
          const fsPoppervue_type_script_lang_ts_setup_true_hoisted_1 = ["onKeyup"];
          var fsPoppervue_type_script_lang_ts_setup_true = (0, external_vue_.defineComponent)({
            __name: "fsPopper",
            props: {
              placement: {
                type: String,
                default: "bottom",
                validator: function(value) {
                  return ["auto", "auto-start", "auto-end", "top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "right", "right-start", "right-end", "left", "left-start", "left-end"].includes(value);
                }
              },
              disableClickAway: {
                type: Boolean,
                default: false
              },
              offsetSkid: {
                type: String,
                default: "0"
              },
              offsetDistance: {
                type: String,
                default: "12"
              },
              hover: {
                type: Boolean,
                default: false
              },
              show: {
                type: Boolean,
                default: null
              },
              disabled: {
                type: Boolean,
                default: false
              },
              openDelay: {
                type: [Number, String],
                default: 0
              },
              closeDelay: {
                type: [Number, String],
                default: 0
              },
              zIndex: {
                type: [Number, String],
                default: 9999
              },
              noArrow: {
                type: Boolean,
                default: false
              },
              arrowPadding: {
                type: String,
                default: "0"
              },
              interactive: {
                type: Boolean,
                default: true
              },
              locked: {
                type: Boolean,
                default: false
              },
              content: {
                type: String,
                default: null
              },
              title: {
                type: String,
                default: null
              },
              tooltip: {
                type: Boolean,
                default: false
              },
              variant: {
                type: String,
                default: null
              },
              shadow: {
                type: Boolean,
                default: false
              },
              bodyClass: {
                type: [Array, Object, String]
              },
              wrapperClass: {
                type: [Array, Object, String]
              },
              popperClass: {
                type: [Array, Object, String]
              },
              titleClass: {
                type: [Array, Object, String]
              }
            },
            emits: ["open:popper", "close:popper"],
            setup(__props, {
              emit
            }) {
              const props = __props;
              const slots = (0, external_vue_.useSlots)();
              const popperContainerNode = (0, external_vue_.ref)(null);
              const popperNode = (0, external_vue_.ref)(null);
              const triggerNode = (0, external_vue_.ref)(null);
              const modifiedIsOpen = (0, external_vue_.ref)(false);
              (0, external_vue_.onMounted)(() => {
                const children = slots.default();
                if (children && children.length > 1) {
                  return console.error(`[Popper]: The <Popper> component expects only one child element at its root. You passed ${children.length} child nodes.`);
                }
              });
              const {
                arrowPadding,
                closeDelay,
                content,
                disableClickAway,
                disabled,
                interactive,
                locked,
                offsetDistance,
                offsetSkid,
                openDelay,
                placement,
                show,
                tooltip,
                variant,
                shadow,
                title,
                bodyClass,
                wrapperClass,
                popperClass,
                titleClass
              } = (0, external_vue_.toRefs)(props);
              const {
                isOpen,
                open,
                close
              } = usePopper({
                arrowPadding,
                emit,
                locked,
                offsetDistance,
                offsetSkid,
                placement,
                popperNode,
                triggerNode
              });
              const {
                hasContent
              } = useContent(slots, popperNode, content);
              const manualMode = (0, external_vue_.computed)(() => show.value !== null);
              const invalid = (0, external_vue_.computed)(() => disabled.value || !hasContent.value);
              const shouldShowPopper = (0, external_vue_.computed)(() => isOpen.value && !invalid.value);
              const enableClickAway = (0, external_vue_.computed)(() => !disableClickAway.value && !manualMode.value);
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  "popper": true,
                  "fs-tooltip": tooltip.value,
                  [`text-bg-${variant.value}`]: variant.value,
                  "shadow": shadow.value
                };
              });
              const hasTitleSlot = (0, external_vue_.computed)(() => !!slots.title);
              const interactiveStyle = (0, external_vue_.computed)(() => interactive.value ? `border: ${offsetDistance.value}px solid transparent; margin: -${offsetDistance.value}px;` : null);
              const openPopperDebounce = (0, debounce.debounce)(open, openDelay.value);
              const closePopperDebounce = (0, debounce.debounce)(close, closeDelay.value);
              const openPopper = async () => {
                if (invalid.value || manualMode.value) {
                  return;
                }
                closePopperDebounce.clear();
                openPopperDebounce();
              };
              const closePopper = async () => {
                if (manualMode.value) {
                  return;
                }
                openPopperDebounce.clear();
                closePopperDebounce();
              };
              const togglePopper = () => {
                isOpen.value ? closePopper() : openPopper();
              };
              (0, external_vue_.watch)([hasContent, disabled], ([hasContent2, disabled2]) => {
                if (isOpen.value && (!hasContent2 || disabled2)) {
                  close();
                }
              }, {
                deep: true
              });
              (0, external_vue_.watch)(isOpen, (isOpen2) => {
                if (isOpen2) {
                  modifiedIsOpen.value = true;
                } else {
                  (0, debounce.debounce)(() => {
                    modifiedIsOpen.value = false;
                  }, 200);
                }
              });
              (0, external_vue_.watchEffect)(() => {
                if (manualMode.value) {
                  show.value ? openPopperDebounce() : closePopperDebounce();
                }
              });
              (0, external_vue_.watchEffect)(() => {
                if (enableClickAway.value) {
                  useClickAway(popperContainerNode, closePopper);
                }
              });
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                  onMouseleave: _cache[4] || (_cache[4] = ($event) => __props.hover && closePopper()),
                  ref_key: "popperContainerNode",
                  ref: popperContainerNode
                }, [(0, external_vue_.createElementVNode)("div", {
                  ref_key: "triggerNode",
                  ref: triggerNode,
                  onMouseover: _cache[0] || (_cache[0] = ($event) => __props.hover && openPopper()),
                  onClick: togglePopper,
                  onFocus: openPopper,
                  class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(wrapperClass)),
                  onKeyup: (0, external_vue_.withKeys)(closePopper, ["esc"])
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")], 42, fsPoppervue_type_script_lang_ts_setup_true_hoisted_1), ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(external_vue_.Teleport, {
                  to: "body"
                }, [(0, external_vue_.createVNode)(external_vue_.Transition, {
                  name: "fade"
                }, {
                  default: (0, external_vue_.withCtx)(() => [(0, external_vue_.withDirectives)((0, external_vue_.createElementVNode)("div", {
                    onClick: _cache[1] || (_cache[1] = ($event) => !(0, external_vue_.unref)(interactive) && closePopper()),
                    onMouseover: _cache[2] || (_cache[2] = ($event) => __props.hover && !(0, external_vue_.unref)(tooltip) && openPopper()),
                    onMouseleave: _cache[3] || (_cache[3] = ($event) => __props.hover && closePopper()),
                    class: (0, external_vue_.normalizeClass)([(0, external_vue_.unref)(finalClass), (0, external_vue_.unref)(popperClass)]),
                    ref_key: "popperNode",
                    ref: popperNode
                  }, [!__props.noArrow ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                    key: 0,
                    class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(tooltip) ? "fs-tooltip-arrow" : "popper-arrow"),
                    "data-popper-arrow": ""
                  }, null, 2)) : (0, external_vue_.createCommentVNode)("", true), !(0, external_vue_.unref)(tooltip) && ((0, external_vue_.unref)(hasTitleSlot) || (0, external_vue_.unref)(title)) ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("h3", {
                    key: 1,
                    class: (0, external_vue_.normalizeClass)(["popper-header", (0, external_vue_.unref)(titleClass)])
                  }, [(0, external_vue_.renderSlot)(_ctx.$slots, "title", {}, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)((0, external_vue_.unref)(title)), 1)])], 2)) : (0, external_vue_.createCommentVNode)("", true), (0, external_vue_.createElementVNode)("div", {
                    class: (0, external_vue_.normalizeClass)([(0, external_vue_.unref)(tooltip) ? "fs-tooltip-inner" : "popper-body", (0, external_vue_.unref)(bodyClass)])
                  }, [(0, external_vue_.renderSlot)(_ctx.$slots, "content", {
                    close: (0, external_vue_.unref)(close),
                    isOpen: modifiedIsOpen.value
                  }, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)((0, external_vue_.unref)(content)), 1)])], 2)], 34), [[external_vue_.vShow, (0, external_vue_.unref)(shouldShowPopper)]])]),
                  _: 3
                })]))], 544);
              };
            }
          });
          ;
          ;
          ;
          ;
          ;
          const fsPopper_exports_ = (0, exportHelper.Z)(fsPoppervue_type_script_lang_ts_setup_true, [["__scopeId", "data-v-1f05f900"]]);
          var fsPopper = fsPopper_exports_;
          ;
          function fsProgressvue_type_template_id_29ed0c2a_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            const _component_fs_progress_bar = (0, external_vue_.resolveComponent)("fs-progress-bar");
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
              class: "progress",
              style: (0, external_vue_.normalizeStyle)(_ctx.height)
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default", {}, () => [(0, external_vue_.createVNode)(_component_fs_progress_bar, (0, external_vue_.mergeProps)(_ctx.$attrs, {
              value: _ctx.value,
              animated: _ctx.animated,
              striped: _ctx.striped,
              variant: _ctx.variant,
              max: _ctx.max,
              precision: _ctx.precision,
              showProgress: _ctx.showProgress,
              showValue: _ctx.showValue
            }), null, 16, ["value", "animated", "striped", "variant", "max", "precision", "showProgress", "showValue"])])], 4);
          }
          ;
          ;
          const fsProgressBarvue_type_template_id_9aa7820c_ts_true_hoisted_1 = ["aria-valuemax", "aria-valuenow"];
          const fsProgressBarvue_type_template_id_9aa7820c_ts_true_hoisted_2 = ["innerHTML"];
          function fsProgressBarvue_type_template_id_9aa7820c_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
              class: (0, external_vue_.normalizeClass)(_ctx.computedClass),
              style: (0, external_vue_.normalizeStyle)(_ctx.computedStyles),
              role: "progressbar",
              "aria-valuemin": 0,
              "aria-valuemax": _ctx.computedMax || null,
              "aria-valuenow": _ctx.computedValueShow || null
            }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default", {}, () => [_ctx.labelHtml ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("span", {
              key: 0,
              innerHTML: _ctx.labelHtml
            }, null, 8, fsProgressBarvue_type_template_id_9aa7820c_ts_true_hoisted_2)) : ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)(external_vue_.Fragment, {
              key: 1
            }, [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.computedLabel), 1)], 64))])], 14, fsProgressBarvue_type_template_id_9aa7820c_ts_true_hoisted_1);
          }
          ;
          ;
          var fsProgressBarvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsProgressBar",
            props: {
              animated: {
                type: Boolean,
                default: null
              },
              label: {
                type: String
              },
              labelHtml: {
                type: String
              },
              max: {
                type: [Number, String],
                default: null
              },
              precision: {
                type: [Number, String],
                default: null
              },
              showProgress: {
                type: Boolean,
                default: null
              },
              showValue: {
                type: Boolean,
                default: null
              },
              striped: {
                type: Boolean,
                default: null
              },
              value: {
                type: [Number, String],
                default: 0
              },
              variant: {
                type: String
              }
            },
            setup(props) {
              const parent = (0, external_vue_.inject)("currentFsProgress");
              const computedClass = (0, external_vue_.computed)(() => {
                return {
                  [`progress-bar`]: true,
                  [`bg-${computedVariant.value}`]: computedVariant.value,
                  [`progress-bar-striped`]: computedStriped.value || computedAnimated.value,
                  [`progress-bar-animated`]: computedAnimated.value
                };
              });
              const computedStyles = (0, external_vue_.computed)(() => {
                return {
                  width: 100 * (computedValue.value / computedMax.value) + "%"
                };
              });
              function toFloat(value) {
                const float = parseFloat(value);
                return isNaN(float) ? 0 : float;
              }
              ;
              function toInteger(value) {
                const integer = parseInt(value, 10);
                return isNaN(integer) ? 0 : integer;
              }
              ;
              const computedVariant = (0, external_vue_.computed)(() => {
                var _a;
                return props.variant || ((_a = parent.value) == null ? void 0 : _a.variant);
              });
              const computedStriped = (0, external_vue_.computed)(() => {
                var _a;
                return props.striped || ((_a = parent.value) == null ? void 0 : _a.striped);
              });
              const computedAnimated = (0, external_vue_.computed)(() => {
                var _a;
                return props.animated || ((_a = parent.value) == null ? void 0 : _a.animated);
              });
              const computedValue = (0, external_vue_.computed)(() => {
                return toFloat(props.value);
              });
              const computedMax = (0, external_vue_.computed)(() => {
                var _a;
                const max = toFloat(props.max) || toFloat((_a = parent.value) == null ? void 0 : _a.max);
                return max > 0 ? max : 100;
              });
              const computedPrecision = (0, external_vue_.computed)(() => {
                var _a;
                const precision = toInteger(props.precision) || toInteger((_a = parent.value) == null ? void 0 : _a.precision);
                return precision > 0 ? precision : 0;
              });
              const computedProgress = (0, external_vue_.computed)(() => {
                const power = Math.pow(10, computedPrecision.value);
                return (100 * power * computedValue.value / (computedMax.value * power)).toFixed(computedPrecision.value);
              });
              const computedValueShow = (0, external_vue_.computed)(() => {
                return computedValue.value.toFixed(computedPrecision.value);
              });
              const computedLabel = (0, external_vue_.computed)(() => {
                var _a, _b;
                if (props.label) {
                  return props.label;
                }
                if (props.showProgress || ((_a = parent.value) == null ? void 0 : _a.showProgress)) {
                  return computedProgress.value;
                }
                if (props.showValue || ((_b = parent.value) == null ? void 0 : _b.showValue)) {
                  return computedValue.value.toFixed(computedPrecision.value);
                }
                return "";
              });
              return {
                computedMax,
                computedValueShow,
                computedLabel,
                computedClass,
                computedStyles
              };
            }
          });
          ;
          ;
          ;
          const fsProgressBar_exports_ = (0, exportHelper.Z)(fsProgressBarvue_type_script_lang_ts, [["render", fsProgressBarvue_type_template_id_9aa7820c_ts_true_render]]);
          var fsProgressBar = fsProgressBar_exports_;
          ;
          var fsProgressvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsProgress",
            props: {
              animated: {
                type: Boolean,
                default: false
              },
              height: {
                type: String
              },
              max: {
                type: [Number, String],
                default: 100
              },
              precision: {
                type: [Number, String],
                default: 0
              },
              showProgress: {
                type: Boolean,
                default: false
              },
              showValue: {
                type: Boolean,
                default: false
              },
              striped: {
                type: Boolean,
                default: false
              },
              value: {
                type: [Number, String],
                default: 0
              },
              variant: {
                type: String
              }
            },
            components: {
              FsProgressBar: fsProgressBar
            },
            setup(props) {
              (0, external_vue_.provide)("currentFsProgress", (0, external_vue_.ref)(props));
            }
          });
          ;
          ;
          ;
          const fsProgress_exports_ = (0, exportHelper.Z)(fsProgressvue_type_script_lang_ts, [["render", fsProgressvue_type_template_id_29ed0c2a_ts_true_render]]);
          var fsProgress = fsProgress_exports_;
          ;
          function fsRowvue_type_template_id_7c0b4870_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag), {
              class: (0, external_vue_.normalizeClass)(["row", _ctx.computedClasses])
            }, {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "default")]),
              _: 3
            }, 8, ["class"]);
          }
          ;
          ;
          var fsRowvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsRow",
            props: {
              alignContent: {
                type: String,
                default: null
              },
              alignH: {
                type: String,
                default: null
              },
              alignV: {
                type: String,
                default: null
              },
              cols: {
                type: [Number, String]
              },
              colsLg: {
                type: [Number, String]
              },
              colsMd: {
                type: [Number, String]
              },
              colsSm: {
                type: [Number, String]
              },
              colsXl: {
                type: [Number, String]
              },
              noGutters: {
                type: Boolean,
                default: false
              },
              tag: {
                type: String,
                default: "div"
              }
            },
            emits: [],
            setup(props) {
              const computedClasses = (0, external_vue_.computed)(() => {
                return {
                  [`row-cols-${props.cols}`]: !!props.cols,
                  [`row-cols-sm-${props.colsSm}`]: !!props.colsSm,
                  [`row-cols-md-${props.colsMd}`]: !!props.colsMd,
                  [`row-cols-lg-${props.colsLg}`]: !!props.colsLg,
                  [`row-cols-xl-${props.colsXl}`]: !!props.colsXl,
                  [`align-content-${props.alignContent}`]: !!props.alignContent,
                  [`justify-content-${props.alignH}`]: !!props.alignH,
                  [`align-items-${props.alignV}`]: !!props.alignV,
                  "g-0": !!props.noGutters
                };
              });
              return {
                computedClasses
              };
            }
          });
          ;
          ;
          ;
          const fsRow_exports_ = (0, exportHelper.Z)(fsRowvue_type_script_lang_ts, [["render", fsRowvue_type_template_id_7c0b4870_ts_true_render]]);
          var fsRow = fsRow_exports_;
          ;
          const fsSidebarvue_type_template_id_686c5166_ts_true_hoisted_1 = ["id"];
          const fsSidebarvue_type_template_id_686c5166_ts_true_hoisted_2 = ["id"];
          const fsSidebarvue_type_template_id_686c5166_ts_true_hoisted_3 = ["aria-label"];
          function fsSidebarvue_type_template_id_686c5166_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
              class: "fs-sidebar-outer",
              style: (0, external_vue_.normalizeStyle)(_ctx.outerStyle),
              tabindex: "-1"
            }, [(0, external_vue_.createVNode)(external_vue_.Transition, (0, external_vue_.normalizeProps)((0, external_vue_.guardReactiveProps)(_ctx.transitionProps)), {
              default: (0, external_vue_.withCtx)(() => [(0, external_vue_.withDirectives)(((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.tag), {
                class: (0, external_vue_.normalizeClass)(["fs-sidebar", [_ctx.sidebarClass, _ctx.finalClass]]),
                role: "dialog",
                "aria-label": _ctx.ariaLabel,
                "aria-labelledby": _ctx.sidebarId,
                "aria-model": _ctx.backdrop || void 0,
                tabindex: "-1",
                id: _ctx.sidebarId,
                style: (0, external_vue_.normalizeStyle)(_ctx.getWidth),
                ref: "element"
              }, {
                default: (0, external_vue_.withCtx)(() => [!_ctx.noHeader && !_ctx.$slots.header ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.headerTag), {
                  key: 0,
                  class: (0, external_vue_.normalizeClass)(["fs-sidebar-header", _ctx.headerClass])
                }, {
                  default: (0, external_vue_.withCtx)(() => [_ctx.$slots.title ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("strong", {
                    key: 0,
                    id: _ctx.sidebarTitleId
                  }, [(0, external_vue_.renderSlot)(_ctx.$slots, "title", {
                    hide: _ctx.hide
                  })], 8, fsSidebarvue_type_template_id_686c5166_ts_true_hoisted_1)) : ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("strong", {
                    key: 1,
                    id: _ctx.sidebarTitleId
                  }, (0, external_vue_.toDisplayString)(_ctx.title), 9, fsSidebarvue_type_template_id_686c5166_ts_true_hoisted_2)), !_ctx.noHeaderClose && !_ctx.$slots.header ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("button", {
                    key: 2,
                    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.close && _ctx.close(...args)),
                    "aria-label": _ctx.closeLabel,
                    type: "button",
                    class: "btn-close ms-auto"
                  }, null, 8, fsSidebarvue_type_template_id_686c5166_ts_true_hoisted_3)) : (0, external_vue_.createCommentVNode)("", true), !_ctx.noHeaderClose && _ctx.$slots["header-close"] ? (0, external_vue_.renderSlot)(_ctx.$slots, "header-close", {
                    key: 3
                  }) : (0, external_vue_.createCommentVNode)("", true)]),
                  _: 3
                }, 8, ["class"])) : (0, external_vue_.createCommentVNode)("", true), !_ctx.noHeader && _ctx.$slots.header ? (0, external_vue_.renderSlot)(_ctx.$slots, "header", {
                  key: 1
                }) : (0, external_vue_.createCommentVNode)("", true), !_ctx.lazy || _ctx.lazy && _ctx.localVisible ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                  key: 2,
                  class: (0, external_vue_.normalizeClass)(["fs-sidebar-body", _ctx.bodyClass])
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default", {
                  hide: _ctx.hide
                })], 2)) : (0, external_vue_.createCommentVNode)("", true), _ctx.$slots.footer ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(_ctx.footerTag), {
                  key: 3,
                  class: (0, external_vue_.normalizeClass)(["fs-sidebar-footer", _ctx.footerClass])
                }, {
                  default: (0, external_vue_.withCtx)(() => [(0, external_vue_.renderSlot)(_ctx.$slots, "footer", {
                    hide: _ctx.hide
                  })]),
                  _: 3
                }, 8, ["class"])) : (0, external_vue_.createCommentVNode)("", true)]),
                _: 3
              }, 8, ["class", "aria-label", "aria-labelledby", "aria-model", "id", "style"])), [[external_vue_.vShow, _ctx.localVisible]])]),
              _: 3
            }, 16), ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)(external_vue_.Teleport, {
              to: "body"
            }, [(0, external_vue_.createVNode)(external_vue_.Transition, (0, external_vue_.normalizeProps)((0, external_vue_.guardReactiveProps)(_ctx.backdropProps)), {
              default: (0, external_vue_.withCtx)(() => [_ctx.backdrop && _ctx.localVisible ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                key: 0,
                class: (0, external_vue_.normalizeClass)(["offcanvas-backdrop", _ctx.finalBackdropClass]),
                onClick: _cache[1] || (_cache[1] = (...args) => _ctx.backdropClose && _ctx.backdropClose(...args)),
                style: {
                  "backdropVariant ? '{opacity": ".1",
                  "}'": "''"
                }
              }, null, 2)) : (0, external_vue_.createCommentVNode)("", true)]),
              _: 1
            }, 16)]))], 4);
          }
          ;
          ;
          var fsSidebarvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsSidebar",
            props: {
              ariaLabel: {
                type: String
              },
              ariaLabelledby: {
                type: String
              },
              backdrop: {
                type: Boolean,
                default: false
              },
              backdropVariant: {
                type: String
              },
              bgVariant: {
                type: String,
                default: "light"
              },
              bodyClass: {
                type: [Array, Object, String]
              },
              closeLabel: {
                type: String
              },
              footerClass: {
                type: [Array, Object, String]
              },
              footerTag: {
                type: String,
                default: "footer"
              },
              headerClass: {
                type: [Array, Object, String]
              },
              headerTag: {
                type: String,
                default: "header"
              },
              id: {
                type: String
              },
              lazy: {
                type: Boolean,
                default: false
              },
              modelValue: {
                type: Boolean,
                default: false
              },
              noCloseOnBackdrop: {
                type: Boolean,
                default: false
              },
              noCloseOnEsc: {
                type: Boolean,
                default: false
              },
              noCloseOnRouteChange: {
                type: Boolean,
                default: false
              },
              noEnforceFocus: {
                type: Boolean,
                default: false
              },
              noHeader: {
                type: Boolean,
                default: false
              },
              noHeaderClose: {
                type: Boolean,
                default: false
              },
              noSlide: {
                type: Boolean,
                default: false
              },
              right: {
                type: Boolean,
                default: false
              },
              shadow: {
                type: [Boolean, String],
                default: false
              },
              sidebarClass: {
                type: [Array, Object, String]
              },
              tag: {
                type: String,
                default: "div"
              },
              textVariant: {
                type: String,
                default: "dark"
              },
              title: {
                type: String
              },
              visible: {
                type: Boolean,
                default: false
              },
              width: {
                type: String
              },
              zIndex: {
                type: [Number, String]
              }
            },
            emits: ["shown", "hidden", "change", "update:modelValue", "update:visible"],
            setup(props, {
              emit
            }) {
              const element = (0, external_vue_.ref)(null);
              const localVisible = (0, external_vue_.ref)(false);
              const {
                directiveBus: directiveBus2
              } = useDirectiveBus();
              const route = (0, external_vue_router_.useRoute)();
              const getValue = (0, external_vue_.computed)(() => {
                return props.visible;
              });
              const getWidth = (0, external_vue_.computed)(() => {
                return props.width ? {
                  width: props.width
                } : "";
              });
              const transitionProps = (0, external_vue_.computed)(() => {
                return props.noSlide ? {
                  css: true
                } : {
                  css: true,
                  enterClass: "",
                  enterActiveClass: "slide",
                  enterToClass: "show",
                  leaveClass: "show",
                  leaveActiveClass: "slide",
                  leaveToClass: ""
                };
              });
              const backdropProps = (0, external_vue_.computed)(() => {
                return {
                  css: true,
                  enterClass: "",
                  enterActiveClass: "fade",
                  enterToClass: "show",
                  leaveClass: "show",
                  leaveActiveClass: "fade",
                  leaveToClass: ""
                };
              });
              const sidebarId = (0, external_vue_.computed)(() => {
                return props.id ? props.id : utils_generateId();
              });
              const sidebarTitleId = (0, external_vue_.computed)(() => {
                return props.id + "__title_";
              });
              const outerStyle = (0, external_vue_.computed)(() => {
                return props.zIndex ? {
                  zIndex: props.zIndex
                } : "";
              });
              const finalClass = (0, external_vue_.computed)(() => {
                return {
                  "fs-sidebar-right": props.right,
                  ["bg-" + props.bgVariant]: props.bgVariant,
                  ["text-" + props.textVariant]: props.textVariant,
                  "shadow": props.shadow === true,
                  ["shadow-" + props.shadow]: props.shadow && props.shadow !== true
                };
              });
              const finalBackdropClass = (0, external_vue_.computed)(() => {
                return {
                  "bg-opacity-50": props.backdropVariant,
                  ["bg-" + props.backdropVariant]: props.backdropVariant
                };
              });
              (0, external_vue_.onMounted)(() => {
                window.addEventListener("keydown", onKeydown);
              });
              (0, external_vue_.onBeforeUnmount)(() => {
                window.removeEventListener("keydown", onKeydown);
              });
              (0, external_vue_.watch)(() => directiveBus2.value.get(`${sidebarId.value}`), (val) => {
                if (val) {
                  toggle();
                }
              }, {
                deep: true
              });
              (0, external_vue_.watch)(() => route == null ? void 0 : route.fullPath, (newValue, oldValue) => {
                if (!props.noCloseOnRouteChange && newValue !== oldValue) {
                  updateVisible(false);
                }
              });
              (0, external_vue_.watch)(() => props.modelValue, (visible) => {
                if (visible) {
                  emit("shown", visible);
                } else {
                  emit("hidden", visible);
                }
                emit("change", visible);
                localVisible.value = visible;
                if (!props.noEnforceFocus && visible) {
                  const sidebar = element.value;
                  if (sidebar) {
                    (0, external_vue_.nextTick)(() => {
                      sidebar.focus();
                    });
                  }
                }
              }, {
                immediate: true
              });
              (0, external_vue_.watch)(() => props.visible, (visible) => {
                if (visible) {
                  emit("shown", visible);
                } else {
                  emit("hidden", visible);
                }
                emit("change", visible);
                localVisible.value = visible;
                if (!props.noEnforceFocus && visible) {
                  const sidebar = element.value;
                  if (sidebar) {
                    (0, external_vue_.nextTick)(() => {
                      sidebar.focus();
                    });
                  }
                }
              }, {
                immediate: true
              });
              function close() {
                updateVisible(false);
              }
              function backdropClose() {
                if (!props.noCloseOnBackdrop) {
                  updateVisible(false);
                }
              }
              function hide() {
                updateVisible(false);
              }
              function onKeydown(event) {
                if (event.key === "Escape" && !props.noCloseOnEsc) {
                  updateVisible(false);
                }
              }
              function updateVisible(value) {
                localVisible.value = value;
                emit("update:modelValue", value);
                emit("change", value);
                if (!value && props.visible) {
                  emit("update:visible", value);
                }
              }
              function toggle() {
                updateVisible(!localVisible.value);
              }
              return {
                element,
                getWidth,
                getValue,
                transitionProps,
                backdropProps,
                sidebarId,
                sidebarTitleId,
                outerStyle,
                finalClass,
                finalBackdropClass,
                localVisible,
                close,
                backdropClose,
                hide,
                toggle
              };
            }
          });
          ;
          ;
          ;
          const fsSidebar_exports_ = (0, exportHelper.Z)(fsSidebarvue_type_script_lang_ts, [["render", fsSidebarvue_type_template_id_686c5166_ts_true_render]]);
          var fsSidebar = fsSidebar_exports_;
          ;
          const string_kebabCase = (str) => {
            return str.replace(RX_HYPHENATE, "-$1").toLowerCase();
          };
          const spaceCase = (str) => {
            return str.replace(RX_UNDERSCORE, " ").replace(RX_FIRST_LOWER, (w) => w.charAt(0).toUpperCase() + w.slice(1));
          };
          const string_toString = (val, spaces = 2) => {
            return isUndefinedOrNull(val) ? "" : isArray(val) || isPlainObject(val) && val.toString === Object.prototype.toString ? JSON.stringify(val, null, spaces) : String(val);
          };
          const trim = (str) => string_toString(str).trim();
          ;
          const useTableItemHelper = () => {
            const internalItems = (0, external_vue_.ref)([]);
            const normaliseFields = (origFields, items) => {
              let fields = [];
              let calculatedFields = {};
              const instance = (0, external_vue_.getCurrentInstance)();
              if (!(origFields == null ? void 0 : origFields.length) && (items == null ? void 0 : items.length)) {
                Object.keys(items[0]).forEach((k) => fields.push({
                  key: k,
                  label: startCase(k)
                }));
                return fields;
              }
              if (Array.isArray(origFields)) {
                origFields.forEach((f) => {
                  if (typeof f === "string") {
                    fields.push({
                      key: f,
                      label: startCase(f)
                    });
                  } else if (inspect_isObject(f) && f.key && inspect_isString(f.key)) {
                    fields.push({
                      ...f
                    });
                  }
                });
                calculatedFields = fields.reduce((obj, f) => {
                  obj[f.key] = clone(f);
                  if (f.formatter) {
                    let formatter = f.formatter;
                    if (inspect_isString(formatter) && isFunction(instance.proxy.$parent[formatter])) {
                      formatter = instance.proxy.$parent[formatter];
                    } else if (!isFunction(formatter)) {
                      formatter = void 0;
                    }
                    obj[f.key].formatter = formatter;
                  }
                  return obj;
                }, {});
              }
              ;
              return calculatedFields;
            };
            const mapItems = (fields, items, props, flags, localSortBy, localSortDesc) => {
              if ("isFilterableTable" in flags && flags.isFilterableTable.value === true && props.filter) {
                items = filterItems(items, fields, props.filter, props.filterIncludedFields);
              }
              if ("isSortable" in flags && flags.isSortable.value === true) {
                items = sortItems(fields, items, {
                  key: props.sortBy ? props.sortBy : localSortBy,
                  desc: props.sortBy ? flags.sortDescBoolean.value : localSortDesc
                }, props.sortCompare);
              }
              return items;
            };
            const realVal = (ob) => {
              if (ob === null) {
                return " ";
              } else if (typeof ob === "number") {
                return ob.toString();
              } else if (typeof ob === "object") {
                return JSON.stringify(ob);
              } else {
                return ob;
              }
            };
            const sortItems = (fields, items, sort, sorter) => {
              if (!sort || !sort.key)
                return items;
              const sortKey = sort.key;
              return items.sort((a, b) => {
                let result = null;
                if (sorter !== void 0) {
                  result = sorter(a, b, sort.key, sort.desc);
                }
                if (result) {
                  return result;
                }
                if (sortKey.includes(".")) {
                  const sortKeys2 = sortKey.split(".");
                  const aHigher2 = realVal(a[sortKeys2[0]][sortKeys2[1]]).localeCompare(realVal(b[sortKeys2[0]][sortKeys2[1]]), "en", {
                    numeric: true
                  });
                  if (aHigher2 === 1) {
                    return sort.desc ? -1 : 1;
                  }
                  const bHigher2 = realVal(b[sortKeys2[0]][sortKeys2[1]]).localeCompare(realVal(a[sortKeys2[0]][sortKeys2[1]]), "en", {
                    numeric: true
                  });
                  if (bHigher2 === 1) {
                    return sort.desc ? 1 : -1;
                  }
                  return 0;
                }
                ;
                const aHigher = realVal(a[sortKey]).localeCompare(realVal(b[sortKey]), "en", {
                  numeric: true
                });
                if (aHigher === 1) {
                  return sort.desc ? -1 : 1;
                }
                const bHigher = realVal(b[sortKey]).localeCompare(realVal(a[sortKey]), "en", {
                  numeric: true
                });
                if (bHigher === 1) {
                  return sort.desc ? 1 : -1;
                }
                return 0;
              });
            };
            const filterItems = (items, fields, filter, filterIncludedFields) => {
              return items.filter((item) => {
                let filteredItems = Object.entries(item).filter((item2) => {
                  let [key, val] = item2;
                  if (!val || key[0] === "_") {
                    return false;
                  }
                  const field = fields.find((field2) => field2.key === key);
                  if (field == null ? void 0 : field.formatter) {
                    val = field.formatter(val, key, item2);
                  }
                  const itemValue = typeof val === "object" ? JSON.stringify(Object.values(val)) : typeof val === "string" ? val : val.toString();
                  if (filterIncludedFields) {
                    if (filterIncludedFields.includes(key)) {
                      return itemValue.toLowerCase().includes(filter.toLowerCase());
                    }
                  } else {
                    return itemValue.toLowerCase().includes(filter.toLowerCase());
                  }
                });
                return filteredItems.length > 0;
              });
            };
            return {
              normaliseFields,
              mapItems
            };
          };
          var composables_useTableItemHelper = useTableItemHelper;
          ;
          const fsTablevue_type_script_setup_true_lang_ts_hoisted_1 = ["title", "abbr", "aria-sort", "onClick"];
          const fsTablevue_type_script_setup_true_lang_ts_hoisted_2 = {
            key: 0
          };
          const fsTablevue_type_script_setup_true_lang_ts_hoisted_3 = {
            colspan: "6"
          };
          const fsTablevue_type_script_setup_true_lang_ts_hoisted_4 = {
            role: "alert",
            "aria-live": "polite"
          };
          const fsTablevue_type_script_setup_true_lang_ts_hoisted_5 = {
            key: 1
          };
          const fsTablevue_type_script_setup_true_lang_ts_hoisted_6 = ["onClick", "onDblclick", "onMouseup", "onMouseenter", "onMouseleave"];
          const fsTablevue_type_script_setup_true_lang_ts_hoisted_7 = ["colspan"];
          const fsTablevue_type_script_setup_true_lang_ts_hoisted_8 = {
            key: 2
          };
          const _hoisted_9 = {
            className: "b-table-busy-slot"
          };
          const _hoisted_10 = ["colspan"];
          const _hoisted_11 = ["title", "abbr"];
          const _hoisted_12 = {
            key: 5
          };
          var fsTablevue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsTable",
            props: {
              busy: {
                default: false
              },
              caption: {
                default: ""
              },
              light: {
                default: false
              },
              fields: {
                default: () => []
              },
              items: {
                default: () => []
              },
              emptyFilteredText: null,
              align: {
                default: null
              },
              bordered: {
                default: false
              },
              borderless: {
                default: false
              },
              borderVariant: {
                default: null
              },
              captionTop: {
                default: false
              },
              dark: {
                default: false
              },
              fixed: {
                default: false
              },
              footClone: {
                default: false
              },
              footVariant: {
                default: null
              },
              headVariant: {
                default: null
              },
              hover: {
                default: false
              },
              outlined: {
                default: false
              },
              noBorderCollapse: {
                default: false
              },
              noSelectOnClick: {
                default: false
              },
              responsive: {
                type: [Boolean, String],
                default: false
              },
              selectable: {
                default: false
              },
              selectMode: {
                default: ""
              },
              selectedVariant: {
                default: null
              },
              showEmpty: {
                default: false
              },
              sortCompare: null,
              sortDesc: {
                default: false
              },
              sortBy: null,
              small: {
                default: false
              },
              striped: {
                default: false
              },
              stacked: null,
              stickyHeader: {
                default: false
              },
              tableVariant: {
                default: null
              },
              tbodyTrClass: {
                type: [String, Function],
                default: ""
              },
              theadTrClass: {
                type: [String, Function],
                default: ""
              },
              tfootTrClass: {
                type: [String, Function],
                default: ""
              },
              theadClass: {
                type: [String, Function],
                default: ""
              },
              tfootClass: {
                type: [String, Function],
                default: ""
              },
              emptyText: {
                default: "There are no records to show"
              },
              filter: null,
              filterIncludedFields: null,
              perPage: null,
              currentPage: null
            },
            emits: ["headClicked", "row-clicked", "row-middle-clicked", "rowDblClicked", "rowHovered", "rowUnhovered", "row-selected", "update:sortBy", "update:sortDesc", "sort-changed", "filtered"],
            setup(__props, {
              expose,
              emit
            }) {
              const props = __props;
              const {
                normaliseFields,
                mapItems
              } = composables_useTableItemHelper();
              const slots = (0, external_vue_.useSlots)();
              const captionTopBoolean = useBooleanish((0, external_vue_.toRef)(props, "captionTop"));
              const busyBoolean = useBooleanish((0, external_vue_.toRef)(props, "busy"));
              const borderlessBoolean = useBooleanish((0, external_vue_.toRef)(props, "borderless"));
              const borderedBoolean = useBooleanish((0, external_vue_.toRef)(props, "bordered"));
              const darkBoolean = useBooleanish((0, external_vue_.toRef)(props, "dark"));
              const lightBoolean = useBooleanish((0, external_vue_.toRef)(props, "light"));
              const fixedBoolean = useBooleanish((0, external_vue_.toRef)(props, "fixed"));
              const footCloneBoolean = useBooleanish((0, external_vue_.toRef)(props, "footClone"));
              const hoverBoolean = useBooleanish((0, external_vue_.toRef)(props, "hover"));
              const noBorderCollapseBoolean = useBooleanish((0, external_vue_.toRef)(props, "noBorderCollapse"));
              const noSelectOnClickBoolean = useBooleanish((0, external_vue_.toRef)(props, "noSelectOnClick"));
              const outlinedBoolean = useBooleanish((0, external_vue_.toRef)(props, "outlined"));
              const showEmptyBoolean = useBooleanish((0, external_vue_.toRef)(props, "showEmpty"));
              const selectableBoolean = useBooleanish((0, external_vue_.toRef)(props, "selectable"));
              const smallBoolean = useBooleanish((0, external_vue_.toRef)(props, "small"));
              const stickyHeaderBoolean = useBooleanish((0, external_vue_.toRef)(props, "stickyHeader"));
              const stripedBoolean = useBooleanish((0, external_vue_.toRef)(props, "striped"));
              const sortDescBoolean = useBooleanish((0, external_vue_.toRef)(props, "sortDesc"));
              const selected = (0, external_vue_.ref)([]);
              const detailsShown = (0, external_vue_.ref)([]);
              const localSortBy = (0, external_vue_.ref)(props.sortBy);
              const localSortDesc = (0, external_vue_.ref)(false);
              const localItems = (0, external_vue_.ref)([]);
              const classes = (0, external_vue_.computed)(() => ["table fs-table", {
                [`align-${props.align}`]: props.align,
                [`table-${props.tableVariant}`]: props.tableVariant,
                "table-striped": stripedBoolean.value,
                "table-hover": hoverBoolean.value,
                "table-dark": darkBoolean.value || props.tableVariant === "dark",
                "table-light": lightBoolean.value || props.tableVariant === "light",
                "table-bordered": borderedBoolean.value,
                [`border-${props.borderVariant}`]: props.borderVariant,
                "table-borderless": borderlessBoolean.value,
                "border": outlinedBoolean.value,
                "table-sm": smallBoolean.value,
                "fs-table-caption-top": captionTopBoolean.value,
                "fs-table-fixed": fixedBoolean.value,
                "fs-table-no-border-collapse": noBorderCollapseBoolean.value
              }]);
              const theadClasses = (0, external_vue_.computed)(() => [{
                [`${props.theadClass}`]: true,
                "thead-dark": props.headVariant === "dark",
                "thead-light": props.headVariant === "light"
              }]);
              const tfootClasses = (0, external_vue_.computed)(() => [{
                [`${props.tfootClass}`]: true,
                "thead-dark": props.footVariant === "dark" || props.footClone && props.footVariant === null && props.headVariant === "dark",
                "thead-light": props.footVariant === "light" || props.footClone && props.footVariant === null && props.headVariant === "light"
              }]);
              const computedFields = (0, external_vue_.computed)(() => {
                return normaliseFields(props.fields, props.items);
              });
              const computedItems = (0, external_vue_.computed)(() => {
                const sortByLocal = localSortBy.value;
                const sortDescLocal = localSortDesc.value;
                localItems.value = mapItems(props.fields, props.items, props, {
                  isSortable,
                  isFilterableTable,
                  sortDescBoolean
                }, props.sortBy ? props.sortBy : sortByLocal, sortDescLocal);
                if (props.perPage !== void 0) {
                  const startIndex = (props.currentPage - 1) * props.perPage;
                  const endIndex = startIndex + props.perPage > localItems.value.length ? localItems.value.length : startIndex + props.perPage;
                  return localItems.value.slice(startIndex, endIndex);
                }
                return localItems.value;
              });
              const isFilterableTable = (0, external_vue_.computed)(() => props.filter !== void 0 && props.filter !== "");
              const isSortable = (0, external_vue_.computed)(() => props.fields.filter((field) => typeof field === "string" ? false : field.sortable).length > 0);
              const outerDivClasses = (0, external_vue_.computed)(() => [{
                "table-responsive": typeof props.responsive === "boolean" && props.responsive,
                [`table-responsive-${props.responsive}`]: typeof props.responsive === "string",
                "fs-table-sticky-header": stickyHeaderBoolean.value
              }]);
              const calculateTbodyTrRowClasses = (0, external_vue_.computed)(() => (tr, type) => {
                const variant = tr._rowVariant ? `table-${tr._rowVariant}` : "";
                const tbodyTrClass = calculateTbodyTrClass(props.tbodyTrClass, tr, type);
                const trClass = calculateTrClass(tr);
                return [variant, tbodyTrClass, trClass];
              });
              const computedFieldsTotal = (0, external_vue_.computed)(() => Object.keys(computedFields.value).length + (selectableBoolean.value ? 1 : 0));
              const ariaSort = (0, external_vue_.computed)(() => (field) => {
                if (!field.sortable || props.filterIncludedFields && !props.filterIncludedFields.includes(field.key)) {
                  return "";
                } else if (!props.sortBy) {
                  if (field.key !== localSortBy.value) {
                    return "none";
                  } else {
                    return localSortDesc.value ? "descending" : "ascending";
                  }
                } else {
                  if (field.key !== props.sortBy) {
                    return "none";
                  } else {
                    return localSortDesc.value ? "descending" : "ascending";
                  }
                }
              });
              (0, external_vue_.watch)(() => localItems.value, (newValue, oldValue) => {
                if (newValue !== oldValue && (isFilterableTable == null ? void 0 : isFilterableTable.value)) {
                  if (newValue.length !== oldValue.length) {
                    emit("filtered", localItems.value);
                  }
                }
              }, {
                deep: true
              });
              const computeLabel = (field) => {
                return field.label === "" ? field.label : field.label || spaceCase(field.key);
              };
              const calculateField = (field, tr) => {
                return field.formatter ? field.formatter(tr[field.key], field.key, tr) : calculateValue(tr, field.key);
              };
              const calculateTbodyTrClass = (tbodyTrClass, tr, type) => {
                if (isFunction(tbodyTrClass)) {
                  return tbodyTrClass(tr, type);
                } else if (inspect_isString(tbodyTrClass)) {
                  return tbodyTrClass;
                }
                return "";
              };
              const calculateValue = (tr, key) => {
                if (key.includes(".")) {
                  const keys2 = key.split(".", 2);
                  return tr[keys2[0]][keys2[1]];
                }
                return tr[key];
              };
              const calculateTrClass = (tr) => {
                if (selected.value.includes(tr)) {
                  if (!props.selectedVariant) {
                    return "b-table-row-selected table-active";
                  }
                  return "b-table-row-selected table-" + props.selectedVariant;
                }
              };
              const toggleRowDetails = (tr) => {
                if (detailsShown.value.includes(tr) || tr._showDetails) {
                  detailsShown.value = detailsShown.value.filter((i) => {
                    return i !== tr;
                  });
                  tr._showDetails = false;
                } else {
                  detailsShown.value.push(tr);
                  tr._showDetails = true;
                }
              };
              function rowClicked(tr, index, event) {
                emit("row-clicked", tr, index, event);
                if (!noSelectOnClickBoolean.value && selectableBoolean.value) {
                  if (props.selectMode === "multi" || props.selectMode === "") {
                    if (selected.value.includes(tr)) {
                      selected.value = selected.value.filter((row) => row !== tr);
                    } else {
                      selected.value.push(tr);
                    }
                    emit("row-selected", selected.value);
                  } else if (props.selectMode === "single") {
                    const isSelected = selected.value.includes(tr);
                    clearSelected();
                    if (!isSelected) {
                      selected.value.push(tr);
                      emit("row-selected", selected.value);
                    }
                  } else if (props.selectMode === "range") {
                    if (event.ctrlKey) {
                      if (selected.value.includes(tr)) {
                        selected.value = selected.value.filter((row) => row !== tr);
                      } else {
                        selected.value.push(tr);
                      }
                    } else if (event.shiftKey) {
                      const lastSelectedItem = Array.from(selected.value).pop();
                      const lastSelectedIndex = props.items.findIndex((i) => i === lastSelectedItem);
                      const selectStartIndex = Math.min(lastSelectedIndex, index);
                      const selectEndIndex = Math.max(lastSelectedIndex, index);
                      props.items.slice(selectStartIndex, selectEndIndex + 1).forEach((item) => {
                        if (!selected.value.includes(item)) {
                          selected.value.push(item);
                          emit("row-selected", selected.value);
                        }
                      });
                    } else {
                      clearSelected();
                      selected.value.push(tr);
                    }
                    emit("row-selected", selected.value);
                  }
                }
              }
              function onRowMiddleClick(tr, index, event) {
                emit("row-middle-clicked", tr, index, event);
              }
              const onRowDblClick = (row, index, e) => emit("rowDblClicked", row, index, e);
              const onRowMouseEnter = (row, index, e) => emit("rowHovered", row, index, e);
              const onRowMouseLeave = (row, index, e) => emit("rowUnhovered", row, index, e);
              function unselectRow(index) {
                if (props.items[index]) {
                  selected.value = selected.value.filter((row) => row !== props.items[index]);
                  emit("row-selected", selected.value);
                }
              }
              function selectRow(index) {
                if (!selected.value.includes(props.items[index])) {
                  if (props.selectMode === "single") {
                    clearSelected();
                  }
                  selected.value.push(props.items[index]);
                  emit("row-selected", selected.value);
                }
              }
              function selectAllRows() {
                if (props.selectMode === "single") {
                  clearSelected();
                  selected.value.push(props.items[0]);
                } else {
                  selected.value = props.items;
                }
                emit("row-selected", selected.value);
              }
              function clearSelected() {
                selected.value = [];
                emit("row-selected", selected.value);
              }
              function refresh() {
                clearSelected();
              }
              const computeSlot = (fieldKey) => {
                return !!slots[fieldKey];
              };
              const headerClicked = (field, event, isFooter = false) => {
                const fieldKey = typeof field === "string" ? field : field.key;
                emit("headClicked", fieldKey, field, event, isFooter);
                handleFieldSorting(field);
              };
              const handleFieldSorting = (field) => {
                if (!isSortable.value)
                  return;
                const fieldKey = typeof field === "string" ? field : field.key;
                const fieldSortable = typeof field === "string" ? false : field.sortable;
                if (isSortable.value === true && fieldSortable === true) {
                  const sortDesc = !localSortDesc.value;
                  if (fieldKey !== props.sortBy) {
                    emit("update:sortBy", fieldKey);
                    if (fieldKey.includes(".")) {
                      const keys2 = fieldKey.split(".");
                      if (localItems.value.every((item) => !item[keys2[0]][keys2[1]])) {
                        return;
                      }
                    } else {
                      if (localItems.value.every((item) => !item[fieldKey])) {
                        return;
                      }
                    }
                    if (!props.sortBy) {
                      localSortDesc.value = localSortBy.value === fieldKey ? !localSortDesc.value : false;
                      localSortBy.value = fieldKey;
                    }
                  }
                  emit("update:sortDesc", sortDesc);
                  emit("sort-changed", fieldKey, sortDesc);
                }
              };
              expose({
                unselectRow,
                selectRow,
                selectAllRows,
                clearSelected,
                refresh
              });
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                  class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(outerDivClasses))
                }, [(0, external_vue_.createElementVNode)("table", (0, external_vue_.mergeProps)({
                  class: (0, external_vue_.unref)(classes)
                }, _ctx.$attrs), [(0, external_vue_.createElementVNode)("thead", {
                  class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(theadClasses))
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "thead-top"), (0, external_vue_.createElementVNode)("tr", {
                  class: (0, external_vue_.normalizeClass)(__props.theadTrClass)
                }, [((0, external_vue_.openBlock)(true), (0, external_vue_.createElementBlock)(external_vue_.Fragment, null, (0, external_vue_.renderList)((0, external_vue_.unref)(computedFields), (field) => {
                  return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("th", (0, external_vue_.mergeProps)({
                    key: field.key,
                    scope: "col",
                    class: [field.class, field.thClass, field.variant ? `table-${field.variant}` : ""],
                    title: field.headerTitle,
                    abbr: field.headerAbbr,
                    style: field.thStyle
                  }, field.thAttr, {
                    "aria-sort": (0, external_vue_.unref)(ariaSort)(field),
                    onClick: ($event) => headerClicked(field, $event)
                  }), [computeSlot(`head(${field.key})`) || computeSlot("head()") ? (0, external_vue_.renderSlot)(_ctx.$slots, computeSlot(`head(${field.key})`) ? "head(" + field.key + ")" : "head()", {
                    key: 0,
                    label: field.label,
                    column: field.key,
                    field: {
                      key: field.key,
                      label: computeLabel(field)
                    },
                    isFoot: false
                  }) : ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)(external_vue_.Fragment, {
                    key: 1
                  }, [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(computeLabel(field)), 1)], 64))], 16, fsTablevue_type_script_setup_true_lang_ts_hoisted_1);
                }), 128))], 2)], 2), !__props.busy && (0, external_vue_.unref)(showEmptyBoolean) && (!(0, external_vue_.unref)(computedItems) || (0, external_vue_.unref)(computedItems).length === 0) ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("tbody", fsTablevue_type_script_setup_true_lang_ts_hoisted_2, [(0, external_vue_.createElementVNode)("tr", {
                  class: (0, external_vue_.normalizeClass)(["empty-row", __props.tbodyTrClass])
                }, [(0, external_vue_.createElementVNode)("td", fsTablevue_type_script_setup_true_lang_ts_hoisted_3, [(0, external_vue_.createElementVNode)("div", fsTablevue_type_script_setup_true_lang_ts_hoisted_4, [(0, external_vue_.renderSlot)(_ctx.$slots, "empty", {}, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(__props.emptyText), 1)])])])], 2)])) : !__props.busy ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("tbody", fsTablevue_type_script_setup_true_lang_ts_hoisted_5, [((0, external_vue_.openBlock)(true), (0, external_vue_.createElementBlock)(external_vue_.Fragment, null, (0, external_vue_.renderList)((0, external_vue_.unref)(computedItems), (tr, index) => {
                  return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)(external_vue_.Fragment, null, [(0, external_vue_.createElementVNode)("tr", {
                    onClick: ($event) => rowClicked(tr, index, $event),
                    onDblclick: ($event) => onRowDblClick(tr, index, $event),
                    onMouseup: (0, external_vue_.withModifiers)(($event) => onRowMiddleClick(tr, index, $event), ["middle"]),
                    onMouseenter: ($event) => onRowMouseEnter(tr, index, $event),
                    onMouseleave: ($event) => onRowMouseLeave(tr, index, $event),
                    class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(calculateTbodyTrRowClasses)(tr, "row"))
                  }, [((0, external_vue_.openBlock)(true), (0, external_vue_.createElementBlock)(external_vue_.Fragment, null, (0, external_vue_.renderList)((0, external_vue_.unref)(computedFields), (field) => {
                    return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("td", (0, external_vue_.mergeProps)({
                      key: field.key
                    }, field.tdAttr, {
                      class: [field.class, field.tdClass, field.variant ? `table-${field.variant}` : "", (tr == null ? void 0 : tr._cellVariants) && (tr == null ? void 0 : tr._cellVariants[field.key]) ? `table-${tr == null ? void 0 : tr._cellVariants[field.key]}` : "", ,]
                    }), [computeSlot(`cell(${field.key})`) || computeSlot("cell()") ? (0, external_vue_.renderSlot)(_ctx.$slots, computeSlot(`cell(${field.key})`) ? "cell(" + field.key + ")" : "cell()", {
                      key: 0,
                      value: calculateField(field, tr),
                      index,
                      item: tr,
                      items: (0, external_vue_.unref)(computedItems),
                      rowSelected: selected.value.includes(tr),
                      detailsShowing: tr == null ? void 0 : tr._showDetails,
                      toggleDetails: (item) => toggleRowDetails(tr)
                    }) : ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)(external_vue_.Fragment, {
                      key: 1
                    }, [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(calculateField(field, tr)), 1)], 64))], 16);
                  }), 128))], 42, fsTablevue_type_script_setup_true_lang_ts_hoisted_6), ((tr == null ? void 0 : tr._showDetails) === true || detailsShown.value.includes(tr)) && computeSlot("row-details") ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("tr", {
                    key: 0,
                    class: (0, external_vue_.normalizeClass)(calculateTbodyTrClass(__props.tbodyTrClass, tr, "row-details"))
                  }, [(0, external_vue_.createElementVNode)("td", {
                    colspan: (0, external_vue_.unref)(computedFieldsTotal)
                  }, [(0, external_vue_.renderSlot)(_ctx.$slots, "row-details", {
                    item: tr,
                    toggleDetails: () => toggleRowDetails(tr)
                  })], 8, fsTablevue_type_script_setup_true_lang_ts_hoisted_7)], 2)) : (0, external_vue_.createCommentVNode)("", true)], 64);
                }), 256))])) : ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("tbody", fsTablevue_type_script_setup_true_lang_ts_hoisted_8, [(0, external_vue_.createElementVNode)("tr", _hoisted_9, [(0, external_vue_.createElementVNode)("td", {
                  colspan: (0, external_vue_.unref)(computedFields).length
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "table-busy")], 8, _hoisted_10)])])), computeSlot("custom-foot") ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("tfoot", {
                  key: 3,
                  class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(tfootClasses))
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "custom-foot", {
                  items: (0, external_vue_.unref)(computedItems),
                  fields: __props.fields
                })], 2)) : (0, external_vue_.createCommentVNode)("", true), (0, external_vue_.unref)(footCloneBoolean) ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("tfoot", {
                  key: 4,
                  class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(tfootClasses))
                }, [(0, external_vue_.createElementVNode)("tr", {
                  class: (0, external_vue_.normalizeClass)(__props.tfootTrClass)
                }, [((0, external_vue_.openBlock)(true), (0, external_vue_.createElementBlock)(external_vue_.Fragment, null, (0, external_vue_.renderList)((0, external_vue_.unref)(computedFields), (field) => {
                  return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("th", (0, external_vue_.mergeProps)({
                    key: field.key,
                    scope: "col",
                    class: [field.class, field.thClass, field.variant ? `table-${field.variant}` : ""],
                    title: field.headerTitle,
                    abbr: field.headerAbbr,
                    style: field.thStyle
                  }, field.thAttr), [computeSlot(`head(${field.key})`) || computeSlot("head()") ? (0, external_vue_.renderSlot)(_ctx.$slots, computeSlot(`head(${field.key})`) ? "head(" + field.key + ")" : "head()", {
                    key: 0,
                    label: field.label,
                    column: field.key,
                    field: {
                      key: field.key,
                      label: computeLabel(field)
                    },
                    isFoot: true
                  }) : ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)(external_vue_.Fragment, {
                    key: 1
                  }, [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(computeLabel(field)), 1)], 64))], 16, _hoisted_11);
                }), 128))], 2)], 2)) : (0, external_vue_.createCommentVNode)("", true), computeSlot("table-caption") ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("caption", _hoisted_12, [(0, external_vue_.renderSlot)(_ctx.$slots, "table-caption", {}, () => [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(__props.caption), 1)])])) : (0, external_vue_.createCommentVNode)("", true)], 16)], 2);
              };
            }
          });
          ;
          ;
          const fsTable_exports_ = fsTablevue_type_script_setup_true_lang_ts;
          var fsTable = fsTable_exports_;
          ;
          const fsThvue_type_script_setup_true_lang_ts_hoisted_1 = ["scope", "colspan", "rowspan", "data-label"];
          const fsThvue_type_script_setup_true_lang_ts_hoisted_2 = {
            key: 0
          };
          var fsThvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsTh",
            props: {
              colspan: null,
              rowspan: null,
              stackedHeading: null,
              stickyColumn: {
                default: false
              },
              variant: null
            },
            setup(__props) {
              const props = __props;
              const stickyColumnBoolean = useBooleanish((0, external_vue_.toRef)(props, "stickyColumn"));
              const computedClasses = (0, external_vue_.computed)(() => ({
                [`table-${props.variant}`]: props.variant !== void 0,
                "b-table-sticky-column": stickyColumnBoolean.value,
                "table-b-table-default": stickyColumnBoolean.value && props.variant === void 0
              }));
              const scope = (0, external_vue_.computed)(() => props.colspan ? "colspan" : props.rowspan ? "rowspan" : "col");
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("th", {
                  role: "columnheader",
                  scope: (0, external_vue_.unref)(scope),
                  class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(computedClasses)),
                  colspan: __props.colspan,
                  rowspan: __props.rowspan,
                  "data-label": __props.stackedHeading
                }, [__props.stackedHeading !== void 0 ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", fsThvue_type_script_setup_true_lang_ts_hoisted_2, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")])) : (0, external_vue_.renderSlot)(_ctx.$slots, "default", {
                  key: 1
                })], 10, fsThvue_type_script_setup_true_lang_ts_hoisted_1);
              };
            }
          });
          ;
          ;
          const fsTh_exports_ = fsThvue_type_script_setup_true_lang_ts;
          var fsTh = fsTh_exports_;
          ;
          var fsTheadvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsThead",
            props: {
              variant: null
            },
            setup(__props) {
              const props = __props;
              const computedClasses = (0, external_vue_.computed)(() => ({
                [`table-${props.variant}`]: props.variant !== void 0
              }));
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("thead", {
                  role: "rowgroup",
                  class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(computedClasses))
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")], 2);
              };
            }
          });
          ;
          ;
          const fsThead_exports_ = fsTheadvue_type_script_setup_true_lang_ts;
          var fsThead = fsThead_exports_;
          ;
          var fsTrvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsTr",
            props: {
              variant: null
            },
            emits: ["click"],
            setup(__props, {
              emit
            }) {
              const props = __props;
              const selected = (0, external_vue_.ref)([]);
              const computedClasses = (0, external_vue_.computed)(() => ({
                [`table-${props.variant}`]: props.variant !== void 0
              }));
              function clicked(...args) {
                emit("click", args);
              }
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("tr", {
                  role: "row",
                  class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(computedClasses)),
                  onClick: clicked
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")], 2);
              };
            }
          });
          ;
          ;
          const fsTr_exports_ = fsTrvue_type_script_setup_true_lang_ts;
          var fsTr = fsTr_exports_;
          ;
          var fsTableSimplevue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsTableSimple",
            props: {
              bordered: {
                default: false
              },
              borderless: {
                default: false
              },
              borderVariant: null,
              captionTop: {
                default: false
              },
              dark: {
                default: false
              },
              hover: {
                default: false
              },
              responsive: {
                type: [Boolean, String],
                default: false
              },
              stacked: {
                type: [Boolean, String],
                default: false
              },
              striped: {
                default: false
              },
              small: {
                default: false
              },
              tableClass: null,
              tableVariant: null,
              stickyHeader: {
                default: false
              }
            },
            setup(__props) {
              const props = __props;
              const captionTopBoolean = useBooleanish((0, external_vue_.toRef)(props, "captionTop"));
              const borderlessBoolean = useBooleanish((0, external_vue_.toRef)(props, "borderless"));
              const borderedBoolean = useBooleanish((0, external_vue_.toRef)(props, "bordered"));
              const darkBoolean = useBooleanish((0, external_vue_.toRef)(props, "dark"));
              const hoverBoolean = useBooleanish((0, external_vue_.toRef)(props, "hover"));
              const smallBoolean = useBooleanish((0, external_vue_.toRef)(props, "small"));
              const stripedBoolean = useBooleanish((0, external_vue_.toRef)(props, "striped"));
              const stickyHeaderBoolean = useBooleanish((0, external_vue_.toRef)(props, "stickyHeader"));
              const computedClasses = (0, external_vue_.computed)(() => ["table", "b-table", {
                "table-bordered": borderedBoolean.value,
                "table-borderless": borderlessBoolean.value,
                [`border-${props.borderVariant}`]: props.borderVariant !== void 0,
                "caption-top": captionTopBoolean.value,
                "table-dark": darkBoolean.value,
                "table-hover": hoverBoolean.value,
                "b-table-stacked": typeof props.stacked === "boolean" && props.stacked,
                [`b-table-stacked-${props.stacked}`]: typeof props.stacked === "string",
                "table-striped": stripedBoolean.value,
                "table-sm": smallBoolean.value,
                [`table-${props.tableVariant}`]: props.tableVariant !== void 0
              }, props.tableClass]);
              const responsiveClasses = (0, external_vue_.computed)(() => [{
                "table-responsive": props.responsive === true,
                [`table-responsive-${props.responsive}`]: typeof props.responsive === "string",
                "b-table-sticky-header": stickyHeaderBoolean.value
              }]);
              return (_ctx, _cache) => {
                return !__props.responsive ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("table", {
                  key: 0,
                  role: "table",
                  class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(computedClasses))
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")], 2)) : ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                  key: 1,
                  class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(responsiveClasses))
                }, [(0, external_vue_.createElementVNode)("table", {
                  role: "table",
                  class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(computedClasses))
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")], 2)], 2));
              };
            }
          });
          ;
          ;
          const fsTableSimple_exports_ = fsTableSimplevue_type_script_setup_true_lang_ts;
          var fsTableSimple = fsTableSimple_exports_;
          ;
          const fsTdvue_type_script_setup_true_lang_ts_hoisted_1 = ["scope", "colspan", "rowspan", "data-label"];
          const fsTdvue_type_script_setup_true_lang_ts_hoisted_2 = {
            key: 0
          };
          var fsTdvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsTd",
            props: {
              colspan: null,
              rowspan: null,
              stackedHeading: null,
              stickyColumn: {
                default: false
              },
              variant: null
            },
            setup(__props) {
              const props = __props;
              const stickyColumnBoolean = useBooleanish((0, external_vue_.toRef)(props, "stickyColumn"));
              const computedClasses = (0, external_vue_.computed)(() => ({
                [`table-${props.variant}`]: props.variant !== void 0,
                "b-table-sticky-column": stickyColumnBoolean.value,
                "table-b-table-default": stickyColumnBoolean.value && props.variant === void 0
              }));
              const scope = (0, external_vue_.computed)(() => props.colspan ? "colspan" : props.rowspan ? "rowspan" : "col");
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("td", {
                  role: "cell",
                  scope: (0, external_vue_.unref)(scope),
                  class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(computedClasses)),
                  colspan: __props.colspan,
                  rowspan: __props.rowspan,
                  "data-label": __props.stackedHeading
                }, [__props.stackedHeading ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", fsTdvue_type_script_setup_true_lang_ts_hoisted_2, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")])) : (0, external_vue_.renderSlot)(_ctx.$slots, "default", {
                  key: 1
                })], 10, fsTdvue_type_script_setup_true_lang_ts_hoisted_1);
              };
            }
          });
          ;
          ;
          const fsTd_exports_ = fsTdvue_type_script_setup_true_lang_ts;
          var fsTd = fsTd_exports_;
          ;
          var fsTbodyvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsTbody",
            props: {
              variant: null
            },
            setup(__props) {
              const props = __props;
              const computedClasses = (0, external_vue_.computed)(() => ({
                [`thead-${props.variant}`]: props.variant !== void 0
              }));
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("tbody", {
                  role: "rowgroup",
                  class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(computedClasses))
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")], 2);
              };
            }
          });
          ;
          ;
          const fsTbody_exports_ = fsTbodyvue_type_script_setup_true_lang_ts;
          var fsTbody = fsTbody_exports_;
          ;
          var fsTfootvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsTfoot",
            props: {
              variant: null
            },
            setup(__props) {
              const props = __props;
              const computedClasses = (0, external_vue_.computed)(() => ({
                [`table-${props.variant}`]: props.variant !== void 0
              }));
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("tfoot", {
                  role: "rowgroup",
                  class: (0, external_vue_.normalizeClass)((0, external_vue_.unref)(computedClasses))
                }, [(0, external_vue_.renderSlot)(_ctx.$slots, "default")], 2);
              };
            }
          });
          ;
          ;
          const fsTfoot_exports_ = fsTfootvue_type_script_setup_true_lang_ts;
          var fsTfoot = fsTfoot_exports_;
          ;
          const tabInjectionKey = Symbol();
          ;
          var fsTabvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            __name: "fsTab",
            props: {
              id: null,
              title: null,
              active: {
                default: false
              },
              buttonId: {
                default: void 0
              },
              disabled: {
                default: false
              },
              lazy: {
                default: void 0
              },
              lazyOnce: {
                default: void 0
              },
              noBody: {
                type: [Boolean, String],
                default: false
              },
              tag: {
                default: "div"
              },
              titleItemClass: null,
              titleLinkAttributes: {
                default: void 0
              },
              titleLinkClass: null
            },
            setup(__props) {
              const props = __props;
              const parentData = (0, external_vue_.inject)(tabInjectionKey);
              const activeBoolean = useBooleanish((0, external_vue_.toRef)(props, "active"));
              const disabledBoolean = useBooleanish((0, external_vue_.toRef)(props, "disabled"));
              const lazyBoolean = useBooleanish((0, external_vue_.toRef)(props, props.lazyOnce !== void 0 ? "lazyOnce" : "lazy"));
              const lazyRenderCompleted = (0, external_vue_.ref)(false);
              const computedLazy = (0, external_vue_.computed)(() => !!((parentData == null ? void 0 : parentData.lazy) || lazyBoolean.value));
              const computedLazyOnce = (0, external_vue_.computed)(() => props.lazyOnce !== void 0);
              const computedActive = (0, external_vue_.computed)(() => activeBoolean.value && !disabledBoolean.value);
              const showSlot = (0, external_vue_.computed)(() => {
                const hasLazyRenderedOnce = computedLazy.value && computedLazyOnce.value && lazyRenderCompleted.value;
                return computedActive.value || !computedLazy.value || hasLazyRenderedOnce;
              });
              const computedClasses = (0, external_vue_.computed)(() => ({
                "active": activeBoolean.value,
                "show": activeBoolean.value,
                "card-body": (parentData == null ? void 0 : parentData.card) && props.noBody === false
              }));
              (0, external_vue_.watch)(() => showSlot.value, (shown) => {
                if (shown && !lazyRenderCompleted.value)
                  lazyRenderCompleted.value = true;
              });
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(__props.tag), {
                  id: __props.id,
                  class: (0, external_vue_.normalizeClass)(["tab-pane", (0, external_vue_.unref)(computedClasses)]),
                  role: "tabpanel",
                  "aria-labelledby": "profile-tab"
                }, {
                  default: (0, external_vue_.withCtx)(() => [(0, external_vue_.unref)(showSlot) ? (0, external_vue_.renderSlot)(_ctx.$slots, "default", {
                    key: 0
                  }) : (0, external_vue_.createCommentVNode)("", true)]),
                  _: 3
                }, 8, ["id", "class"]);
              };
            }
          });
          ;
          ;
          const fsTab_exports_ = fsTabvue_type_script_setup_true_lang_ts;
          var fsTab = fsTab_exports_;
          ;
          const fsTabsvue_type_script_setup_true_lang_ts_hoisted_1 = ["id", "data-bs-target", "aria-controls", "aria-selected", "onClick"];
          const fsTabsvue_type_script_setup_true_lang_ts_default_ = {
            name: "FsTabs"
          };
          var fsTabsvue_type_script_setup_true_lang_ts = (0, external_vue_.defineComponent)({
            ...fsTabsvue_type_script_setup_true_lang_ts_default_,
            props: {
              activeNavItemClass: null,
              activeTabClass: null,
              align: null,
              card: {
                default: false
              },
              contentClass: null,
              end: {
                default: false
              },
              fill: {
                default: false
              },
              id: null,
              justified: {
                default: false
              },
              lazy: {
                default: false
              },
              navClass: null,
              navWrapperClass: null,
              noFade: {
                default: false
              },
              noNavStyle: {
                default: false
              },
              pills: {
                default: false
              },
              small: {
                default: false
              },
              tag: {
                default: "div"
              },
              vertical: {
                default: false
              },
              modelValue: {
                default: -1
              }
            },
            emits: ["update:modelValue", "activate-tab", "click"],
            setup(__props, {
              expose,
              emit
            }) {
              const props = __props;
              const injectionKey = Symbol();
              const cardBoolean = useBooleanish((0, external_vue_.toRef)(props, "card"));
              const endBoolean = useBooleanish((0, external_vue_.toRef)(props, "end"));
              const fillBoolean = useBooleanish((0, external_vue_.toRef)(props, "fill"));
              const justifiedBoolean = useBooleanish((0, external_vue_.toRef)(props, "justified"));
              const lazyBoolean = useBooleanish((0, external_vue_.toRef)(props, "lazy"));
              const noFadeBoolean = useBooleanish((0, external_vue_.toRef)(props, "noFade"));
              const noNavStyleBoolean = useBooleanish((0, external_vue_.toRef)(props, "noNavStyle"));
              const pillsBoolean = useBooleanish((0, external_vue_.toRef)(props, "pills"));
              const smallBoolean = useBooleanish((0, external_vue_.toRef)(props, "small"));
              const verticalBoolean = useBooleanish((0, external_vue_.toRef)(props, "vertical"));
              const slots = (0, external_vue_.useSlots)();
              const _tabIndex = (0, external_vue_.ref)(props.modelValue);
              const _currentTabButton = (0, external_vue_.ref)("");
              const tabIndex = (0, external_vue_.computed)({
                get: () => _tabIndex.value,
                set: (value) => {
                  _tabIndex.value = value;
                  if (tabs.value.length > 0 && value >= 0 && value < tabs.value.length) {
                    _currentTabButton.value = tabs.value[value].buttonId;
                  } else {
                    _currentTabButton.value = "";
                  }
                  emit("update:modelValue", value);
                }
              });
              const tabs = (0, external_vue_.computed)(() => {
                let tabs2 = [];
                if (slots.default) {
                  tabs2 = getTabs(slots).map((tab, idx) => {
                    if (!tab.props)
                      tab.props = {};
                    const buttonId = tab.props["button-id"] || getId("tab");
                    const contentId = tab.props.id || getId();
                    const active = tabIndex.value > -1 ? idx === tabIndex.value : tab.props.active === "";
                    const titleItemClass = tab.props["title-item-class"];
                    const titleLinkAttributes = tab.props["title-link-attributes"];
                    return {
                      buttonId,
                      contentId,
                      active,
                      disabled: tab.props.disabled === "" || tab.props.disabled === true,
                      navItemClasses: [{
                        active,
                        disabled: tab.props.disabled === "" || tab.props.disabled === true
                      }, active && props.activeNavItemClass ? props.activeNavItemClass : null, tab.props["title-link-class"]],
                      tabClasses: [{
                        fade: !noFadeBoolean.value
                      }, active && props.activeTabClass ? props.activeTabClass : null],
                      target: `#${contentId}`,
                      title: tab.props.title,
                      titleItemClass,
                      titleLinkAttributes,
                      onClick: tab.props.onClick,
                      tab,
                      tabComponent: () => getTabs(slots)[idx]
                    };
                  });
                }
                return tabs2;
              });
              const showEmpty = (0, external_vue_.computed)(() => !((tabs == null ? void 0 : tabs.value) && tabs.value.length > 0));
              const computedClasses = (0, external_vue_.computed)(() => ({
                "row g-0": verticalBoolean.value
              }));
              const alignment = useAlignment((0, external_vue_.toRef)(props, "align"));
              const navTabsClasses = (0, external_vue_.computed)(() => ({
                "nav-pills": pillsBoolean.value,
                "flex-column border-bottom-0": verticalBoolean.value && !endBoolean.value,
                "flex-column border-top-0": verticalBoolean.value && endBoolean.value,
                [alignment.value]: props.align !== void 0,
                "nav-fill": fillBoolean.value,
                "card-header-tabs": cardBoolean.value && !pillsBoolean.value,
                "nav-justified": justifiedBoolean.value,
                "nav-tabs": !noNavStyleBoolean.value && !pillsBoolean.value,
                "small": smallBoolean.value
              }));
              const activateTab = (index) => {
                let result = false;
                if (index !== void 0) {
                  if (index > -1 && index < tabs.value.length && !tabs.value[index].disabled && (tabIndex.value < 0 || tabs.value[index].buttonId !== _currentTabButton.value)) {
                    const tabEvent = new BvEvent("activate-tab", {
                      cancelable: true,
                      vueTarget: this
                    });
                    emit("activate-tab", index, tabIndex.value, tabEvent);
                    if (!tabEvent.defaultPrevented) {
                      tabIndex.value = index;
                      result = true;
                    }
                  }
                }
                if (!result && props.modelValue !== tabIndex.value) {
                  emit("update:modelValue", tabIndex.value);
                }
                return result;
              };
              const handleClick = (event, index) => {
                var _a;
                activateTab(index);
                if (index >= 0 && !tabs.value[index].disabled && ((_a = tabs.value[index]) == null ? void 0 : _a.onClick) && typeof tabs.value[index].onClick === "function") {
                  tabs.value[index].onClick(event);
                }
              };
              const getTabs = (slots2) => {
                if (!slots2 || !slots2.default)
                  return [];
                return slots2.default().reduce((arr, slot) => {
                  if (typeof slot.type === "symbol") {
                    arr = arr.concat(slot.children);
                  } else {
                    arr.push(slot);
                  }
                  return arr;
                }, []).filter((child) => {
                  var _a;
                  return ((_a = child.type) == null ? void 0 : _a.__name) === "fsTab";
                });
              };
              activateTab(_tabIndex.value);
              (0, external_vue_.watch)(() => props.modelValue, (newValue, oldValue) => {
                if (newValue === oldValue)
                  return;
                newValue = Math.max(newValue, -1);
                oldValue = Math.max(oldValue, -1);
                if (tabs.value.length <= 0) {
                  tabIndex.value = -1;
                  return;
                }
                const goForward = newValue > oldValue;
                let index = newValue;
                const maxIdx = tabs.value.length - 1;
                while (index >= 0 && index <= maxIdx && tabs.value[index].disabled) {
                  index += goForward ? 1 : -1;
                }
                if (index < 0) {
                  activateTab(0);
                  return;
                }
                if (index >= tabs.value.length) {
                  activateTab(tabs.value.length - 1);
                  return;
                }
                activateTab(index);
              });
              (0, external_vue_.watch)(() => tabs.value, () => {
                let activeTabIndex = tabs.value.map((tab) => tab.active && !tab.disabled).lastIndexOf(true);
                if (activeTabIndex < 0) {
                  if (tabIndex.value >= tabs.value.length) {
                    activeTabIndex = tabs.value.map((tab) => !tab.disabled).lastIndexOf(true);
                  } else {
                    if (tabs.value[tabIndex.value] && !tabs.value[tabIndex.value].disabled)
                      activeTabIndex = tabIndex.value;
                  }
                }
                if (activeTabIndex < 0) {
                  activeTabIndex = tabs.value.map((tab) => !tab.disabled).indexOf(true);
                }
                tabs.value.forEach((tab, idx) => tab.active = idx === activeTabIndex);
                activateTab(activeTabIndex);
              });
              (0, external_vue_.onMounted)(() => {
                if (tabIndex.value < 0 && tabs.value.length > 0 && !tabs.value.some((tab) => tab.active)) {
                  const firstTab = tabs.value.map((t) => !t.disabled).indexOf(true);
                  activateTab(firstTab >= 0 ? firstTab : -1);
                }
              });
              (0, external_vue_.provide)(tabInjectionKey, {
                lazy: lazyBoolean.value,
                card: cardBoolean.value
              });
              expose({
                injectionKey
              });
              return (_ctx, _cache) => {
                return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(__props.tag), {
                  id: __props.id,
                  class: (0, external_vue_.normalizeClass)(["tabs", (0, external_vue_.unref)(computedClasses)])
                }, {
                  default: (0, external_vue_.withCtx)(() => [(0, external_vue_.unref)(endBoolean) ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                    key: 0,
                    class: (0, external_vue_.normalizeClass)(["tab-content", [__props.contentClass, {
                      "col g-0": (0, external_vue_.unref)(verticalBoolean)
                    }]])
                  }, [((0, external_vue_.openBlock)(true), (0, external_vue_.createElementBlock)(external_vue_.Fragment, null, (0, external_vue_.renderList)((0, external_vue_.unref)(tabs), ({
                    tabComponent,
                    contentId,
                    tabClasses,
                    active
                  }, i) => {
                    return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(tabComponent()), {
                      id: contentId,
                      key: i,
                      class: (0, external_vue_.normalizeClass)(tabClasses),
                      active
                    }, null, 8, ["id", "class", "active"]);
                  }), 128)), (0, external_vue_.unref)(showEmpty) ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                    key: "bv-empty-tab",
                    class: (0, external_vue_.normalizeClass)(["tab-pane active", {
                      "card-body": (0, external_vue_.unref)(cardBoolean)
                    }])
                  }, [(0, external_vue_.renderSlot)(_ctx.$slots, "empty")], 2)) : (0, external_vue_.createCommentVNode)("", true)], 2)) : (0, external_vue_.createCommentVNode)("", true), (0, external_vue_.createElementVNode)("div", {
                    class: (0, external_vue_.normalizeClass)([__props.navWrapperClass, {
                      "card-header": (0, external_vue_.unref)(cardBoolean) && !(0, external_vue_.unref)(endBoolean) && !(0, external_vue_.unref)(verticalBoolean),
                      "card-footer": (0, external_vue_.unref)(cardBoolean) && (0, external_vue_.unref)(endBoolean) && !(0, external_vue_.unref)(verticalBoolean),
                      "col-auto": (0, external_vue_.unref)(verticalBoolean)
                    }])
                  }, [(0, external_vue_.createElementVNode)("ul", {
                    class: (0, external_vue_.normalizeClass)(["nav", [(0, external_vue_.unref)(navTabsClasses), __props.navClass, {
                      "card-header": (0, external_vue_.unref)(cardBoolean) && !(0, external_vue_.unref)(endBoolean) && (0, external_vue_.unref)(verticalBoolean),
                      "card-footer": (0, external_vue_.unref)(cardBoolean) && (0, external_vue_.unref)(endBoolean) && (0, external_vue_.unref)(verticalBoolean)
                    }]]),
                    role: "tablist"
                  }, [(0, external_vue_.renderSlot)(_ctx.$slots, "tabs-start"), ((0, external_vue_.openBlock)(true), (0, external_vue_.createElementBlock)(external_vue_.Fragment, null, (0, external_vue_.renderList)((0, external_vue_.unref)(tabs), ({
                    tab,
                    buttonId,
                    contentId,
                    navItemClasses,
                    active,
                    target
                  }, idx) => {
                    return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("li", {
                      key: idx,
                      class: (0, external_vue_.normalizeClass)(["nav-item", tab.props["title-item-class"]])
                    }, [(0, external_vue_.createElementVNode)("button", (0, external_vue_.mergeProps)({
                      id: buttonId,
                      class: ["nav-link w-100", navItemClasses],
                      "data-bs-toggle": "tab",
                      "data-bs-target": target || null,
                      role: "tab",
                      "aria-controls": contentId || null,
                      "aria-selected": active || null
                    }, tab.props["title-link-attributes"], {
                      onClick: (0, external_vue_.withModifiers)((e) => handleClick(e, idx), ["stop", "prevent"])
                    }), [tab.children && tab.children.title ? ((0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(tab.children.title), {
                      key: 0
                    })) : ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)(external_vue_.Fragment, {
                      key: 1
                    }, [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(tab.props.title), 1)], 64))], 16, fsTabsvue_type_script_setup_true_lang_ts_hoisted_1)], 2);
                  }), 128)), (0, external_vue_.renderSlot)(_ctx.$slots, "tabs-end")], 2)], 2), !(0, external_vue_.unref)(endBoolean) ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                    key: 1,
                    class: (0, external_vue_.normalizeClass)(["tab-content", [__props.contentClass, {
                      "col g-0": (0, external_vue_.unref)(verticalBoolean)
                    }]])
                  }, [((0, external_vue_.openBlock)(true), (0, external_vue_.createElementBlock)(external_vue_.Fragment, null, (0, external_vue_.renderList)((0, external_vue_.unref)(tabs), ({
                    tabComponent,
                    contentId,
                    tabClasses,
                    active
                  }, i) => {
                    return (0, external_vue_.openBlock)(), (0, external_vue_.createBlock)((0, external_vue_.resolveDynamicComponent)(tabComponent()), {
                      id: contentId,
                      key: i,
                      class: (0, external_vue_.normalizeClass)(tabClasses),
                      active
                    }, null, 8, ["id", "class", "active"]);
                  }), 128)), (0, external_vue_.unref)(showEmpty) ? ((0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", {
                    key: "bv-empty-tab",
                    class: (0, external_vue_.normalizeClass)(["tab-pane active", {
                      "card-body": (0, external_vue_.unref)(cardBoolean)
                    }])
                  }, [(0, external_vue_.renderSlot)(_ctx.$slots, "empty")], 2)) : (0, external_vue_.createCommentVNode)("", true)], 2)) : (0, external_vue_.createCommentVNode)("", true)]),
                  _: 3
                }, 8, ["id", "class"]);
              };
            }
          });
          ;
          ;
          const fsTabs_exports_ = fsTabsvue_type_script_setup_true_lang_ts;
          var fsTabs = fsTabs_exports_;
          ;
          const fsTooltipvue_type_template_id_30e091c7_ts_true_hoisted_1 = {
            role: "tooltip",
            tabindex: "-1",
            ref: "elementRef"
          };
          const fsTooltipvue_type_template_id_30e091c7_ts_true_hoisted_2 = (0, external_vue_.createElementVNode)("div", {
            class: "arrow"
          }, null, -1);
          const fsTooltipvue_type_template_id_30e091c7_ts_true_hoisted_3 = {
            class: "tooltip-inner",
            ref: "titleRef"
          };
          function fsTooltipvue_type_template_id_30e091c7_ts_true_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_vue_.openBlock)(), (0, external_vue_.createElementBlock)("div", fsTooltipvue_type_template_id_30e091c7_ts_true_hoisted_1, [fsTooltipvue_type_template_id_30e091c7_ts_true_hoisted_2, (0, external_vue_.createElementVNode)("div", fsTooltipvue_type_template_id_30e091c7_ts_true_hoisted_3, [(0, external_vue_.createTextVNode)((0, external_vue_.toDisplayString)(_ctx.title) + " ", 1), (0, external_vue_.renderSlot)(_ctx.$slots, "default")], 512)], 512);
          }
          ;
          ;
          var fsTooltipvue_type_script_lang_ts = (0, external_vue_.defineComponent)({
            name: "FsTooltip",
            props: {
              boundary: {
                type: [HTMLElement, Object, String],
                default: "scrollParent"
              },
              boundaryPadding: {
                type: [Number, String],
                default: 50
              },
              container: {
                type: [HTMLElement, Object, String]
              },
              customClass: {
                type: String
              },
              delay: {
                type: [Number, Object, String],
                default: 50
              },
              disabled: {
                type: Boolean,
                default: false
              },
              fallbackPlacement: {
                type: [Array, String],
                default: "flip"
              },
              id: {
                type: String
              },
              noFade: {
                type: Boolean,
                default: false
              },
              noninteractive: {
                type: Boolean,
                default: false
              },
              offset: {
                type: [Number, String],
                default: 0
              },
              placement: {
                type: String,
                default: "top"
              },
              show: {
                type: Boolean,
                default: false
              },
              target: {
                type: [HTMLElement, SVGElement, Function, Object, String]
              },
              title: {
                type: String
              },
              triggers: {
                type: [Array, String],
                default: "hover focus"
              },
              variant: {
                type: String
              }
            },
            emits: ["show", "shown", "hide", "hidden", "inserted"],
            setup(props, {
              emit
            }) {
              const targetElement = (0, external_vue_.ref)();
              const tooltipInstance = (0, external_vue_.ref)();
              const elementRef = (0, external_vue_.ref)();
              const titleRef = (0, external_vue_.ref)();
              const getTargetElement = () => {
                if (typeof props.target === "string") {
                  return document.getElementById(props.target.replace(/^#/, "")) || null;
                }
                if (props.target instanceof HTMLElement) {
                  return props.target;
                }
                if (typeof props.target === "function") {
                  let result = props.target();
                  if (result && result.$el instanceof HTMLElement) {
                    return result.$el;
                  }
                }
                if (typeof props.target !== "undefined") {
                  return props.target.$el;
                }
                return null;
              };
              const generateTooltipInstance = () => {
                var _a, _b, _c, _d, _e;
                targetElement.value = getTargetElement();
                if (!targetElement) {
                  return;
                }
                const options = {
                  container: props.container ? props.container : false,
                  delay: props.delay,
                  html: true,
                  placement: props.placement,
                  title: props.title ? props.title : titleRef.value,
                  trigger: props.triggers,
                  offset: props.offset.toString(),
                  fallbackPlacement: props.fallbackPlacement,
                  boundary: props.boundary
                };
                tooltipInstance.value = new external_bootstrap_.Tooltip(targetElement.value, options);
                (_a = targetElement.value) == null ? void 0 : _a.addEventListener("show.bs.tooltip", (e) => emit("show", e));
                (_b = targetElement.value) == null ? void 0 : _b.addEventListener("shown.bs.tooltip", (e) => emit("shown", e));
                (_c = targetElement.value) == null ? void 0 : _c.addEventListener("hide.bs.tooltip", (e) => emit("hide", e));
                (_d = targetElement.value) == null ? void 0 : _d.addEventListener("hidden.bs.tooltip", (e) => emit("hidden", e));
                (_e = targetElement.value) == null ? void 0 : _e.addEventListener("inserted.bs.tooltip", (e) => emit("inserted", e));
              };
              (0, external_vue_.watch)(() => props.target, () => {
                var _a;
                (_a = tooltipInstance.value) == null ? void 0 : _a.tooltip("dispose");
                generateTooltipInstance();
              });
              (0, external_vue_.onMounted)(() => {
                (0, external_vue_.nextTick)(() => {
                  var _a, _b;
                  (_b = (_a = elementRef.value) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.removeChild(elementRef.value);
                  setTimeout(() => {
                    generateTooltipInstance();
                  }, 50);
                });
              });
              (0, external_vue_.onBeforeUnmount)(() => {
                var _a, _b, _c, _d, _e, _f;
                (_a = tooltipInstance.value) == null ? void 0 : _a.dispose();
                (_b = targetElement.value) == null ? void 0 : _b.removeEventListener("show.bs.tooltip", (e) => emit("show", e));
                (_c = targetElement.value) == null ? void 0 : _c.removeEventListener("shown.bs.tooltip", (e) => emit("shown", e));
                (_d = targetElement.value) == null ? void 0 : _d.removeEventListener("hide.bs.tooltip", (e) => emit("hide", e));
                (_e = targetElement.value) == null ? void 0 : _e.removeEventListener("hidden.bs.tooltip", (e) => emit("hidden", e));
                (_f = targetElement.value) == null ? void 0 : _f.removeEventListener("inserted.bs.tooltip", (e) => emit("inserted", e));
              });
              return {
                elementRef,
                titleRef
              };
            }
          });
          ;
          ;
          ;
          const fsTooltip_exports_ = (0, exportHelper.Z)(fsTooltipvue_type_script_lang_ts, [["render", fsTooltipvue_type_template_id_30e091c7_ts_true_render]]);
          var fsTooltip = fsTooltip_exports_;
          ;
          var FsModal = {
            mounted(el, binding) {
              let target = binding.value;
              if (Object.keys(binding.modifiers).length > 0) {
                ;
                [target] = Object.keys(binding.modifiers);
              }
              el.setAttribute("data-bs-toggle", "modal");
              el.setAttribute("data-bs-target", `#${target}`);
            }
          };
          ;
          const FsPopover = {
            mounted(el, binding) {
              let placement = "right";
              const trigger = [];
              if (binding.modifiers.left) {
                placement = "left";
              } else if (binding.modifiers.right) {
                placement = "right";
              } else if (binding.modifiers.bottom) {
                placement = "bottom";
              } else if (binding.modifiers.top) {
                placement = "top";
              }
              if (binding.modifiers.manual) {
                trigger.push("manual");
              } else {
                if (binding.modifiers.click) {
                  trigger.push("click");
                }
                if (binding.modifiers.hover) {
                  trigger.push("hover");
                }
                if (binding.modifiers.focus) {
                  trigger.push("focus");
                }
              }
              el.setAttribute("data-bs-toggle", "popover");
              new external_bootstrap_.Popover(el, {
                trigger: trigger.length === 0 ? "click" : trigger.join(" "),
                placement,
                content: binding.value
              });
            },
            unmounted(el) {
              const instance = external_bootstrap_.Popover.getInstance(el);
              instance == null ? void 0 : instance.dispose();
            }
          };
          var directives_FsPopover = FsPopover;
          ;
          const resolveTrigger = (modifiers, value) => {
            if (value == null ? void 0 : value.trigger) {
              return value.trigger;
            }
            if (modifiers.manual) {
              return "manual";
            }
            const trigger = [];
            if (modifiers.click) {
              trigger.push("click");
            }
            if (modifiers.hover) {
              trigger.push("hover");
            }
            if (modifiers.focus) {
              trigger.push("focus");
            }
            if (trigger.length > 0) {
              return trigger.join(" ");
            }
            return "hover focus";
          };
          const resolvePlacement = (modifiers, value) => {
            if (value == null ? void 0 : value.placement) {
              return value.placement;
            }
            if (modifiers.left) {
              return "left";
            }
            if (modifiers.right) {
              return "right";
            }
            if (modifiers.bottom) {
              return "bottom";
            }
            return "top";
          };
          const resolveDelay = (values) => {
            if (values == null ? void 0 : values.delay) {
              return values.delay;
            }
            return 0;
          };
          const resolveTitle = (values) => typeof values === "object" ? values == null ? void 0 : values.title : values;
          const BTooltip = {
            beforeMount(el, binding) {
              el.setAttribute("data-bs-toggle", "tooltip");
              const isHtml = /<("[^"]*"|'[^']*'|[^'">])*>/.test(el.title);
              const trigger = resolveTrigger(binding.modifiers, binding.value);
              const placement = resolvePlacement(binding.modifiers, binding.value);
              const delay = resolveDelay(binding.value);
              const title = el.getAttribute("title");
              new external_bootstrap_.Tooltip(el, {
                trigger,
                placement,
                delay,
                html: isHtml
              });
              if (title) {
                el.setAttribute("data-bs-original-title", title);
              }
            },
            updated(el, binding) {
              const title = el.getAttribute("title");
              const originalTitle = el.getAttribute("data-bs-original-title");
              const instance = external_bootstrap_.Tooltip.getInstance(el);
              el.removeAttribute("title");
              if (title && title !== originalTitle) {
                instance == null ? void 0 : instance.setContent({
                  ".tooltip-inner": title
                });
                el.setAttribute("data-bs-original-title", title);
              }
            },
            unmounted(el) {
              const instance = external_bootstrap_.Tooltip.getInstance(el);
              instance == null ? void 0 : instance.dispose();
            }
          };
          var FsTooltip = BTooltip;
          ;
          const FSV_TOGGLE_CLICK_HANDLER = "__FSV_toggle_CLICK__";
          const {
            emitToComponentById,
            removeComponentFromBusById
          } = useDirectiveBus();
          const resolveToggleType = (el) => {
            if (el.classList.contains("offcanvas")) {
              return "offcanvas";
            }
            if (el.classList.contains("collapse")) {
              return "collapse";
            }
            console.warn("Couldn't resolve toggle type");
          };
          const getTargets = (binding, el) => {
            const {
              modifiers,
              arg,
              value
            } = binding;
            const targets = Object.keys(modifiers || {});
            const localValue = typeof value === "string" ? value.split(RX_SPACE_SPLIT) : value;
            if (isTag(el.tagName, "a")) {
              const href = getAttr(el, "href") || "";
              if (RX_HASH_ID.test(href)) {
                targets.push(href.replace(RX_HASH, ""));
              }
            }
            Array.prototype.concat.apply([], [arg, localValue]).forEach((t) => typeof t === "string" && targets.push(t));
            return targets.filter((t, index, arr) => t && arr.indexOf(t) === index);
          };
          const removeClickListener = (el) => {
            const handler = el[FSV_TOGGLE_CLICK_HANDLER];
            if (handler) {
              eventOff(el, "click", handler, null);
            }
            el[FSV_TOGGLE_CLICK_HANDLER] = null;
          };
          const addClickListener = (el, target) => {
            removeClickListener(el);
            const handler = (event) => {
              emitToComponentById(target.id, true);
            };
            el[FSV_TOGGLE_CLICK_HANDLER] = handler;
            eventOn(el, "click", handler, null);
          };
          const FsToggle = {
            mounted(el, binding) {
              const targetIds = getTargets(binding, el);
              const targetAttrs = [];
              let targetAttr = "data-bs-target";
              if (el.tagName === "a") {
                targetAttr = "href";
              }
              for (let index = 0; index < targetIds.length; index++) {
                const targetId = targetIds[index];
                const target = document.getElementById(targetId);
                if (target) {
                  let type = resolveToggleType(target);
                  if (type) {
                    el.setAttribute("data-bs-toggle", type);
                    targetAttrs.push(`#${targetId}`);
                  }
                  if (target.classList.contains("fs-sidebar")) {
                    addClickListener(el, target);
                  }
                }
              }
              if (targetAttrs.length > 0) {
                el.setAttribute(targetAttr, targetAttrs.join(","));
              }
            },
            beforeUnmount(el, binding, vnode) {
              removeClickListener(el);
              const targetIds = getTargets(binding, el);
              for (let index = 0; index < targetIds.length; index++) {
                const targetId = targetIds[index];
                const target = document.getElementById(targetId);
                if (target == null ? void 0 : target.classList.contains("fs-sidebar")) {
                  removeComponentFromBusById(targetId);
                }
              }
            }
          };
          var directives_FsToggle = FsToggle;
          ;
          function FsBootstrapPluginFunction(Vue, options) {
            Vue.directive("FsModal", FsModal);
            Vue.directive("FsPopover", directives_FsPopover);
            Vue.directive("FsTooltip", FsTooltip);
            Vue.directive("FsToggle", directives_FsToggle);
            Vue.component("FsAccordion", fsAccordion);
            Vue.component("FsAccordionItem", fsAccordionItem);
            Vue.component("FsAlert", fsAlert);
            Vue.component("FsAspect", fsAspect);
            Vue.component("FsBadge", fsBadge);
            Vue.component("FsButton", fsButton);
            Vue.component("FsButtonGroup", fsButtonGroup);
            Vue.component("FsCard", fsCard);
            Vue.component("FsCardBody", fsCardBody);
            Vue.component("FsCardFooter", fsCardFooter);
            Vue.component("FsCardGroup", fsCardGroup);
            Vue.component("FsCardHeader", fsCardHeader);
            Vue.component("FsCardImg", fsCardImg);
            Vue.component("FsCardSubTitle", fsCardSubTitle);
            Vue.component("FsCardText", fsCardText);
            Vue.component("FsCardTitle", fsCardTitle);
            Vue.component("FsCol", fsCol);
            Vue.component("FsCollapse", fsCollapse);
            Vue.component("FsContainer", fsContainer);
            Vue.component("FsDropdown", fsDropdown);
            Vue.component("FsDropdownDivider", fsDropdownDivider);
            Vue.component("FsDropdownForm", fsDropdownForm);
            Vue.component("FsDropdownGroup", fsDropdownGroup);
            Vue.component("FsDropdownHeader", fsDropdownHeader);
            Vue.component("FsDropdownItem", fsDropdownItem);
            Vue.component("FsDropdownItemButton", fsDropdownItemButton);
            Vue.component("FsDropdownText", fsDropdownText);
            Vue.component("FsFormCheckbox", fsFormCheckbox);
            Vue.component("FsFormCheckboxGroup", fsFormCheckboxGroup);
            Vue.component("FsFormFile", fsFormFile);
            Vue.component("FsFormGroup", fsFormGroup);
            Vue.component("FsFormInput", fsFormInput);
            Vue.component("FsFormRadio", fsFormRadio);
            Vue.component("FsFormRadioGroup", fsFormRadioGroup);
            Vue.component("FsFormSelect", fsFormSelect);
            Vue.component("FsFormSelectOption", fsFormSelectOption);
            Vue.component("FsFormSelectOptionGroup", fsFormSelectOptionGroup);
            Vue.component("FsFormTextarea", fsFormTextarea);
            Vue.component("FsImg", fsImg);
            Vue.component("FsInputGroup", fsInputGroup);
            Vue.component("FsInputGroupText", fsInputGroupText);
            Vue.component("FsLink", fsLink);
            Vue.component("FsListGroup", fsListGroup);
            Vue.component("FsListGroupItem", fsListGroupItem);
            Vue.component("FsModal", fsModal);
            Vue.component("FsNav", fsNav);
            Vue.component("FsNavItem", fsNavItem);
            Vue.component("FsNavForm", fsNavForm);
            Vue.component("FsNavItemDropdown", fsNavItemDropdown);
            Vue.component("FsNavText", fsNavText);
            Vue.component("FsNavbar", fsNavbar);
            Vue.component("FsNavbarBrand", fsNavbarBrand);
            Vue.component("FsNavbarNav", fsNavbarNav);
            Vue.component("FsNavbarToggle", fsNavbarToggle);
            Vue.component("FsOverlay", fsOverlay);
            Vue.component("FsPagination", fsPagination);
            Vue.component("FsPopover", fsPopover);
            Vue.component("FsPopper", fsPopper);
            Vue.component("FsProgress", fsProgress);
            Vue.component("FsProgressBar", fsProgressBar);
            Vue.component("FsRouterLink", fsRouterLink);
            Vue.component("FsRow", fsRow);
            Vue.component("FsSidebar", fsSidebar);
            Vue.component("FsSpinner", fsSpinner);
            Vue.component("FsTable", fsTable);
            Vue.component("FsTableSimple", fsTableSimple);
            Vue.component("FsTh", fsTh);
            Vue.component("FsTr", fsTr);
            Vue.component("FsTd", fsTd);
            Vue.component("FsThead", fsThead);
            Vue.component("FsTbody", fsTbody);
            Vue.component("FsTfoot", fsTfoot);
            Vue.component("FsTab", fsTab);
            Vue.component("FsTabs", fsTabs);
            Vue.component("FsTooltip", fsTooltip);
          }
          const FsBootstrapPlugin = {
            install: FsBootstrapPluginFunction
          };
          var FsBootstrap = FsBootstrapPlugin;
          ;
          ;
          ;
        }();
        return __webpack_exports__;
      }();
    });
  }
});

// dep:@fsllc_fs-bootstrap
var fsllc_fs_bootstrap_default = require_fs_bootstrap_umd();
export {
  fsllc_fs_bootstrap_default as default
};
/*!
  * vue-router v4.1.6
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
//# sourceMappingURL=@fsllc_fs-bootstrap.js.map
