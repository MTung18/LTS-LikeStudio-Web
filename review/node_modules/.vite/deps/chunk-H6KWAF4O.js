// node_modules/@bryntum/calendar/calendar.module.js
var productName = "calendar";
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var BrowserHelper = class {
  static cacheFlags(platform = navigator.platform, userAgent = navigator.userAgent) {
    const me = this;
    me._isLinux = Boolean(platform.match(/Linux/));
    me._isMac = Boolean(platform.match(/Mac/));
    me._isWindows = Boolean(platform.match(/Win32/));
    me._isWebkit = Boolean(userAgent.match(/WebKit/) && !userAgent.match(/Edg/));
    me._firefoxVersion = me.getVersion(userAgent, /Firefox\/(\d+)\./);
    me._isFirefox = me._firefoxVersion > 0;
    me._chromeVersion = me.getVersion(userAgent, /Chrom(?:e|ium)\/(\d+)\./);
    me._isChrome = me._chromeVersion > 0;
    me._isSafari = Boolean(userAgent.match(/Safari/)) && !me._isChrome;
    me._isMobileSafari = Boolean(userAgent.match(/Mobile.*Safari/));
    me._safariVersion = me.getVersion(userAgent, /Version\/(.*).Safari/);
    me._isAndroid = Boolean(userAgent.match(/Android/g));
  }
  static get supportsOverflowClip() {
    if (this._supportsOverflowClip == null) {
      const div = document.createElement("div");
      div.style.overflow = "clip";
      div.style.display = "none";
      document.documentElement.appendChild(div);
      this._supportsOverflowClip = div.ownerDocument.defaultView.getComputedStyle(div).getPropertyValue("overflow") === "clip";
      div.remove();
    }
    return this._supportsOverflowClip;
  }
  static get supportsSticky() {
    return true;
  }
  static getVersion(userAgent, versionRe) {
    const match = userAgent.match(versionRe);
    return match ? parseFloat(match[1]) : 0;
  }
  static get isTouchDevice() {
    if (this._isTouchDevice === void 0) {
      this._isTouchDevice = globalThis.matchMedia("(pointer:coarse)").matches;
    }
    return this._isTouchDevice;
  }
  static get isHoverableDevice() {
    if (this._isHoverableDevice === void 0) {
      this._isHoverableDevice = globalThis.matchMedia("(any-hover: hover)").matches;
    }
    return this._isHoverableDevice;
  }
  static get isBrowserEnv() {
    return typeof window !== "undefined";
  }
  static get isMac() {
    return this._isMac;
  }
  static get isWindows() {
    return this._isWindows;
  }
  static get isLinux() {
    return this._isLinux;
  }
  static get isAndroid() {
    return this._isAndroid;
  }
  static get isWebkit() {
    return this._isWebkit;
  }
  static get isChrome() {
    return this._isChrome;
  }
  static get chromeVersion() {
    return this._chromeVersion;
  }
  static get isFirefox() {
    return this._isFirefox;
  }
  static get firefoxVersion() {
    return this._firefoxVersion;
  }
  static get isSafari() {
    return this._isSafari;
  }
  static get safariVersion() {
    return this._safariVersion;
  }
  static get isMobileSafari() {
    return this._isMobileSafari;
  }
  static get platform() {
    const me = this;
    return me._isLinux ? "linux" : me._isMac ? "mac" : me._isWindows ? "windows" : me._isAndroid ? "android" : me._isMobileSafari ? "ios" : null;
  }
  static get supportsPassive() {
    return true;
  }
  static get supportsRandomUUID() {
    if (this._supportsRandomUUID === void 0) {
      try {
        this._supportsRandomUUID = Boolean(globalThis.crypto.randomUUID().length > 0);
      } catch (e) {
        this._supportsRandomUUID = false;
      }
    }
    return this._supportsRandomUUID;
  }
  static get storageAvailable() {
    let storage, x;
    try {
      storage = localStorage;
      x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      return e instanceof DOMException && (e.code === 22 || e.code === 1014 || e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") && storage.length !== 0;
    }
  }
  static setLocalStorageItem(key, value) {
    this.storageAvailable && localStorage.setItem(key, value);
  }
  static getLocalStorageItem(key) {
    return this.storageAvailable && localStorage.getItem(key);
  }
  static removeLocalStorageItem(key) {
    this.storageAvailable && localStorage.removeItem(key);
  }
  static searchParam(paramName, defaultValue2 = null, search = document.location.search) {
    const re = new RegExp(`[?&]${paramName}=?([^&]*)`), match = search.match(re);
    return match && match[1] || defaultValue2;
  }
  static getCookie(name) {
    const nameEq = encodeURIComponent(name) + "=", cookieItems = document.cookie.split(";");
    for (let i = 0; i < cookieItems.length; i++) {
      let c = cookieItems[i];
      while (c.charAt(0) === " ") {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEq) === 0) {
        return decodeURIComponent(c.substring(nameEq.length, c.length));
      }
    }
    return "";
  }
  static download(filename, url) {
    const a = document.createElement("a");
    a.download = filename;
    a.href = url || filename;
    a.style.cssText = "display:none";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }
  static downloadBlob(blob, filename) {
    const url = globalThis.URL.createObjectURL(blob);
    this.download(filename, url);
    globalThis.URL.revokeObjectURL(url);
  }
  static get queryString() {
    var _Object$fromEntries;
    const params = new URL(globalThis.location.href).searchParams;
    return (_Object$fromEntries = Object.fromEntries) === null || _Object$fromEntries === void 0 ? void 0 : _Object$fromEntries.call(Object, params.entries());
  }
  static copyToClipboard(code) {
    let success2 = true;
    const textArea = document.createElement("textarea");
    textArea.value = code;
    textArea.style.height = textArea.style.width = 0;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand("copy");
    } catch (e) {
      success2 = false;
    }
    textArea.remove();
    return success2;
  }
  static isBryntumOnline(searchStrings) {
    var _searchStrings;
    searchStrings = Array.isArray(searchStrings) ? searchStrings : [searchStrings];
    return Boolean(/^(www\.)?bryntum\.com/.test(globalThis.location.host) || ((_searchStrings = searchStrings) === null || _searchStrings === void 0 ? void 0 : _searchStrings.some((str) => this.queryString[str] != null)));
  }
  static get isCSP() {
    const {
      bryntum: bryntum2,
      document: document2
    } = globalThis;
    if (bryntum2.CSP == null) {
      bryntum2.CSP = Boolean(document2.querySelector('meta[http-equiv="Content-Security-Policy"]'));
    }
    return bryntum2.CSP;
  }
  static async setupClipboard() {
    if (!window.bryntum.clipboard) {
      window.bryntum.clipboard = {
        hasNativeAccess: true,
        async writeText(text, allowNative) {
          if (allowNative && this.hasNativeAccess) {
            try {
              await navigator.clipboard.writeText(text);
            } catch (e) {
              this.hasNativeAccess = false;
            }
          }
          this._content = text;
        },
        async readText(allowNative) {
          if (allowNative && this.hasNativeAccess) {
            try {
              return await navigator.clipboard.readText();
            } catch (e) {
              this.hasNativeAccess = false;
            }
          }
          return this._content;
        }
      };
    }
    return window.bryntum.clipboard;
  }
  static async writeToClipboard(text, allowNative = true) {
    const clipboard = await this.setupClipboard();
    return await clipboard.writeText(text, allowNative);
  }
  static async readFromClipboard(allowNative = true) {
    const clipboard = await this.setupClipboard();
    return await clipboard.readText(allowNative);
  }
};
_defineProperty(BrowserHelper, "supportsPointerEvents", Boolean(globalThis.PointerEvent || globalThis.MSPointerEvent));
_defineProperty(BrowserHelper, "supportsPointerEventConstructor", typeof PointerEvent !== "undefined");
if (BrowserHelper.isBrowserEnv) {
  BrowserHelper.cacheFlags();
}
BrowserHelper._$name = "BrowserHelper";
var charsToEncode;
var entitiesToDecode;
var htmlEncodeRe;
var htmlDecodeRe;
var camelLettersRe = /([a-z])([A-Z])/g;
var crlfRe = /[\n\r]/g;
var escapeRegExpRe = /[.*+?^${}()|[\]\\]/g;
var htmlRe$1 = /[&<]/;
var idRe = /(^[^a-z]+[^\w]+)/gi;
var whiteSpaceRe$1 = /\s+/;
var domIdRe = /^[^a-z]+|[^\w:.-]+/gi;
var htmlDecoder = (m, captured) => entitiesToDecode[captured.toLowerCase()] || String.fromCharCode(parseInt(captured.substr(2), 10));
var htmlEncoder = (m, captured) => charsToEncode[captured];
var hyphenateCamelLetters = (all, g1, g2) => {
  return `${g1}-${g2.toLowerCase()}`;
};
var separateCamelLetters = (all, g1, g2) => {
  return `${g1} ${g2.toLowerCase()}`;
};
var replaceNonIdChar = (c) => {
  if (c) {
    return `_x${[...c].map((ch) => ch.charCodeAt(0).toString(16)).join("")}`;
  }
  return "__blank__";
};
var hyphenateCache = {};
var separatedCache = {};
var StringHelper = class {
  static capitalize(string2) {
    return string2 && string2[0].toUpperCase() + string2.substr(1);
  }
  static uncapitalize(string2) {
    return string2 && string2[0].toLowerCase() + string2.substr(1);
  }
  static hyphenate(string2) {
    const cached = hyphenateCache[string2];
    if (cached) {
      return cached;
    }
    return hyphenateCache[string2] = string2.replace(camelLettersRe, hyphenateCamelLetters);
  }
  static separate(string2) {
    const cached = separatedCache[string2];
    if (cached) {
      return cached;
    }
    return separatedCache[string2] = this.capitalize(string2.replace(camelLettersRe, separateCamelLetters));
  }
  static createId(inString) {
    return String(inString).replace(idRe, replaceNonIdChar);
  }
  static makeValidDomId(id, replaceValue = "") {
    if (id == null) {
      return null;
    }
    return String(id).replace(domIdRe, replaceValue);
  }
  static escapeRegExp(string2, flags) {
    let ret = string2.replace(escapeRegExpRe, "\\$&");
    if (flags !== void 0) {
      ret = new RegExp(ret, flags);
    }
    return ret;
  }
  static decodeHtml(str) {
    return str && String(str).replace(htmlDecodeRe, htmlDecoder);
  }
  static encodeHtml(str = "") {
    return str && String(str).replace(htmlEncodeRe, htmlEncoder);
  }
  static encodeHtmlBR(str) {
    var _StringHelper$encodeH;
    return (_StringHelper$encodeH = StringHelper.encodeHtml(str)) === null || _StringHelper$encodeH === void 0 ? void 0 : _StringHelper$encodeH.replace(crlfRe, "<br>");
  }
  static isHtml(text) {
    return typeof text === "string" && htmlRe$1.test(text || "");
  }
  static initHtmlEntities(mappings) {
    mappings = mappings || {
      "&": "&amp;",
      ">": "&gt;",
      "<": "&lt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    const chars = Object.keys(mappings);
    charsToEncode = mappings;
    entitiesToDecode = chars.reduce((prev, val) => {
      prev[mappings[val]] = val;
      return prev;
    }, {});
    htmlEncodeRe = new RegExp(`([${chars.map((c) => "[-]".includes(c) ? "\\" + c : c).join("")}])`, "g");
    htmlDecodeRe = new RegExp(`(${Object.values(mappings).join("|")}|&#[0-9]+;)`, "ig");
  }
  static safeJsonParse(string2) {
    let parsed = null;
    try {
      parsed = JSON.parse(string2);
    } catch (e) {
    }
    return parsed;
  }
  static safeJsonStringify(object, replacer = null, space = null) {
    let result = null;
    try {
      result = JSON.stringify(object, replacer, space);
    } catch (e) {
    }
    return result;
  }
  static joinPaths(paths, pathSeparator = "/") {
    return paths.join(pathSeparator).replace(new RegExp("\\" + pathSeparator + "+", "g"), pathSeparator);
  }
  static split(str, delimiter = whiteSpaceRe$1) {
    let ret = str;
    if (typeof ret === "string") {
      ret = str.trim();
      ret = ret ? ret.split(delimiter) : [];
    }
    return ret;
  }
  static xss(strings, ...values) {
    const buf = [];
    let i = values.length;
    buf[i] = strings[i];
    while (i-- > 0) {
      buf[i] = strings[i] + StringHelper.encodeHtml(values[i]);
    }
    return buf.join("");
  }
  static xssBR(strings, ...values) {
    const buf = [];
    let i = values.length;
    buf[i] = strings[i];
    while (i-- > 0) {
      buf[i] = strings[i] + StringHelper.encodeHtmlBR(values[i]);
    }
    return buf.join("");
  }
  static toJavaScriptValue(value, options) {
    const type = Objects.typeOf(value);
    if (type === "boolean" || type === "string" || type === "number" || value === null) {
      return StringHelper.safeJsonStringify(value);
    }
    if (value === globalThis) {
      return "window";
    }
    if (type === "date") {
      return `new Date(${value.getFullYear()}, ${value.getMonth()}, ${value.getDate()}, ${value.getHours()}, ${value.getMinutes()}, ${value.getSeconds()}, ${value.getMilliseconds()})`;
    }
    if (type === "array") {
      return `[${value.map((v) => StringHelper.toJavaScriptValue(v, options))}]`;
    }
    if (type === "object" || type === "instance") {
      return this.toJavaScriptString(value, options);
    }
    if (type === "function") {
      let contents = value.toString();
      if (contents.match(/^async (\w+?)\(/)) {
        contents = contents.replace(/^async (\w+?)\(/, "async function(");
      } else if (!contents.startsWith("async(") && contents.match(/^(\w+?)\(/)) {
        contents = contents.replace(/^(\w+?)\(/, "function(");
      }
      return contents;
    }
    if (type === "class") {
      if (value.toJavaScriptValue) {
        return value.toJavaScriptValue(options);
      }
      return Object.prototype.hasOwnProperty.call(value, "$name") ? value.$name : value.name;
    }
  }
  static toJavaScriptString(obj, options = {}) {
    var _options$level;
    const level = (_options$level = options.level) !== null && _options$level !== void 0 ? _options$level : 0, intendSize = 2;
    return "{\n" + Object.keys(obj).map((key) => " ".repeat((level + 1) * intendSize) + (key.match(/[- *]/) ? `"${key}"` : key) + `: ${StringHelper.toJavaScriptValue(obj[key], _objectSpread2(_objectSpread2({}, options), {}, {
      level: level + 1
    }))}`).join(",\n") + "\n" + " ".repeat(level * intendSize) + "}";
  }
  static encodeAttributeSelector(attr, value) {
    return `[${attr}="${String(value).replace(/["\\]/g, "\\$&")}"]`;
  }
  static generateUUID() {
    var _globalThis$crypto;
    if (BrowserHelper.supportsRandomUUID) {
      return globalThis.crypto.randomUUID();
    }
    if ((_globalThis$crypto = globalThis.crypto) !== null && _globalThis$crypto !== void 0 && _globalThis$crypto.getRandomValues) {
      return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) => (c ^ globalThis.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
    }
    return `${Date.now()}-${++StringHelper.fakeNodeUUIDIndex}`;
  }
};
_defineProperty(StringHelper, "fakeNodeUUIDIndex", 0);
StringHelper.initHtmlEntities();
StringHelper._$name = "StringHelper";
var {
  hasOwnProperty: hasOwnProperty$6,
  toString: toString$3
} = Object.prototype;
var {
  isFrozen
} = Object;
var afterRe = /\s*<\s*/;
var beforeRe = /\s*>\s*/;
var blendOptions = {};
var typeCache = {};
var emptyObject$e = Object.freeze({});
var Objects = class {
  static assign(dest, ...sources) {
    for (let source, key, i = 0; i < sources.length; i++) {
      source = sources[i];
      if (source) {
        for (key in source) {
          dest[key] = source[key];
        }
      }
    }
    return dest;
  }
  static assignIf(dest, ...sources) {
    for (let source, key, i = 0; i < sources.length; i++) {
      source = sources[i];
      if (source) {
        for (key in source) {
          if (!(key in dest) || dest[key] === void 0) {
            dest[key] = source[key];
          }
        }
      }
    }
    return dest;
  }
  static blend(dest, source, options) {
    options = options || blendOptions;
    dest = dest || {};
    const {
      clone = Objects.clone,
      merge = Objects.blend
    } = options;
    if (Array.isArray(source)) {
      if (source.length > 1) {
        source.forEach((s) => {
          dest = Objects.blend(dest, s, options);
        });
        return dest;
      }
      source = source[0];
    }
    if (source) {
      let destValue, key, value;
      for (key in source) {
        value = source[key];
        if (value && Objects.isObject(value)) {
          destValue = dest[key];
          options.key = key;
          if (destValue && Objects.isObject(destValue)) {
            if (isFrozen(destValue)) {
              dest[key] = destValue = clone(destValue, options);
            }
            value = merge(destValue, value, options);
          } else {
            value = isFrozen(value) ? value : clone(value, options);
          }
        }
        dest[key] = value;
      }
    }
    return dest;
  }
  static clone(value, handler) {
    let cloned = value, key;
    if (value && typeof value === "object") {
      const options = handler && typeof handler === "object" && handler;
      if (options) {
        handler = null;
      }
      if (Objects.isObject(value)) {
        if (value.skipClone) {
          cloned = value;
        } else {
          cloned = {};
          for (key in value) {
            cloned[key] = Objects.clone(value[key]);
          }
        }
      } else if (Array.isArray(value)) {
        cloned = [];
        for (key = value.length; key-- > 0; ) {
          cloned[key] = Objects.clone(value[key]);
        }
      } else if (Objects.isDate(value)) {
        cloned = new Date(value.getTime());
      } else if (handler) {
        cloned = handler(value);
      }
    }
    return cloned;
  }
  static createTruthyKeys(source) {
    const keys = StringHelper.split(source), result = keys && {};
    if (keys) {
      for (const key of keys) {
        if (key) {
          result[key] = true;
        }
      }
    }
    return result;
  }
  static getPath(object, path) {
    return path.split(".").reduce((result, key) => {
      return (result || emptyObject$e)[key];
    }, object);
  }
  static getPathDefault(object, path, defaultValue2) {
    const keys = Array.isArray(path) ? path : typeof path === "string" ? path.split(".") : [path], length = keys.length - 1;
    return keys.reduce((result, key, index) => {
      if (defaultValue2 && !(key in result)) {
        result[key] = index === length ? defaultValue2 : {};
      }
      return (result || emptyObject$e)[key];
    }, object);
  }
  static hasPath(object, path) {
    return path.split(".").every((key) => {
      if (key in object) {
        object = object[key];
        return true;
      }
      return false;
    });
  }
  static getTruthyKeys(source) {
    const keys = [];
    for (const key in source) {
      if (source[key]) {
        keys.push(key);
      }
    }
    return keys;
  }
  static getTruthyValues(source) {
    const values = [];
    for (const key in source) {
      if (source[key]) {
        values.push(source[key]);
      }
    }
    return values;
  }
  static isClass(object) {
    var _object$prototype;
    if (typeof object === "function" && ((_object$prototype = object.prototype) === null || _object$prototype === void 0 ? void 0 : _object$prototype.constructor) === object) {
      return true;
    }
    return false;
  }
  static isDate(object) {
    return Boolean(object === null || object === void 0 ? void 0 : object.getUTCDate) && Objects.typeOf(object) === "date";
  }
  static isPromise(object) {
    if (Promise && Promise.resolve) {
      return Promise.resolve(object) === object || typeof (object === null || object === void 0 ? void 0 : object.then) === "function";
    }
    throw new Error("Promise not supported in your environment");
  }
  static isEmpty(object) {
    if (object && typeof object === "object") {
      for (const p in object) {
        return false;
      }
    }
    return true;
  }
  static isObject(value) {
    const C = value === null || value === void 0 ? void 0 : value.constructor;
    return Boolean(C ? C === Object || C.getPrototypeOf && C.prototype && !Object.getPrototypeOf(C.prototype) : value && typeof value === "object");
  }
  static isInstantiated(object) {
    return object ? typeof object === "object" && !Objects.isObject(object) : false;
  }
  static merge(dest, ...sources) {
    return Objects.blend(dest, sources);
  }
  static mergeItems(dest, src, options) {
    options = options || blendOptions;
    let anchor, delta, index, indexMap, key, shuffle, srcVal;
    const {
      merge = Objects.blend
    } = options;
    dest = dest || {};
    if (Array.isArray(src)) {
      src.forEach((s) => {
        dest = Objects.mergeItems(dest, s, options);
      });
    } else if (src) {
      for (key in src) {
        srcVal = src[key];
        anchor = null;
        if (key.includes(">")) {
          [key, anchor] = key.split(beforeRe);
          delta = 0;
        } else if (key.includes("<")) {
          [anchor, key] = key.split(afterRe);
          delta = 1;
        }
        if (key in dest) {
          if (srcVal && dest[key] && merge) {
            options.key = key;
            srcVal = merge(dest[key], srcVal, options);
          }
          dest[key] = srcVal;
        } else if (!anchor) {
          var _indexMap;
          dest[key] = srcVal;
          (_indexMap = indexMap) === null || _indexMap === void 0 ? void 0 : _indexMap.set(key, indexMap.size);
        } else {
          if (!indexMap) {
            indexMap = /* @__PURE__ */ new Map();
            index = 0;
            for (const k in dest) {
              indexMap.set(k, index++);
            }
          }
          index = indexMap.get(anchor);
          dest[key] = srcVal;
          if (index == null && delta) {
            index = indexMap.size;
          } else {
            shuffle = shuffle || [];
            index = (index || 0) + delta;
            for (const item of indexMap) {
              const [k, v] = item;
              if (index <= v) {
                shuffle && (shuffle[indexMap.size - v - 1] = k);
                indexMap.set(k, v + 1);
              }
            }
            if (shuffle) {
              while (shuffle.length) {
                const k = shuffle.pop(), v = dest[k];
                delete dest[k];
                dest[k] = v;
              }
            }
          }
          indexMap.set(key, index);
        }
      }
    }
    return dest;
  }
  static setPath(object, path, value) {
    path.split(".").reduce((result, key, index, array) => {
      const isLast = index === array.length - 1;
      if (isLast) {
        return result[key] = value;
      } else if (!(result[key] instanceof Object)) {
        result[key] = {};
      }
      return result[key];
    }, object);
    return object;
  }
  static typeOf(value) {
    let trueType, type;
    if (value === null) {
      type = "null";
    } else if (value !== value) {
      type = "nan";
    } else {
      type = typeof value;
      if (type === "object") {
        if (value.isBase) {
          type = "instance";
        } else if (Array.isArray(value)) {
          type = "array";
        } else if (!(type = typeCache[trueType = toString$3.call(value)])) {
          typeCache[trueType] = type = trueType.slice(8, -1).toLowerCase();
        }
      } else if (type === "function" && value.isBase) {
        type = "class";
      }
    }
    return type;
  }
};
Object.defineProperty(Objects, "hasOwn", {
  value: Object.hasOwn || ((object, property) => hasOwnProperty$6.call(object, property))
});
Objects._$name = "Objects";
var VersionHelper = class {
  static setVersion(product, version) {
    product = product.toLowerCase();
    VH[product] = {
      version,
      isNewerThan(otherVersion) {
        return VersionHelper.semanticCompareVersion(otherVersion, version, "<");
      },
      isOlderThan(otherVersion) {
        return VersionHelper.semanticCompareVersion(otherVersion, version, ">");
      }
    };
    let bundleFor = "";
    if (typeof productName !== "undefined") {
      bundleFor = productName;
    }
    const globalKey = `${bundleFor}.${product}${version.replace(/\./g, "-")}`;
    if (BrowserHelper.isBrowserEnv && !globalThis.bryntum.silenceBundleException) {
      if (globalThis.bryntum[globalKey] === true) {
        if (this.isTestEnv) {
          globalThis.BUNDLE_EXCEPTION = true;
        } else {
          let errorProduct = bundleFor || product;
          if (errorProduct === "core") {
            errorProduct = "grid";
          }
          let capitalized = StringHelper.capitalize(errorProduct);
          if (errorProduct === "schedulerpro") {
            capitalized = "SchedulerPro";
          }
          throw new Error(`The Bryntum ${capitalized} bundle was loaded multiple times by the application.

Common reasons you are getting this error includes:

* Imports point to different types of the bundle (e.g. *.module.js and *.umd.js)
* Imports point to both sources and bundle
* Imports do not use the shortest relative path, JS treats them as different files
* Cache busters differ between imports, JS treats ${errorProduct}.module.js?1 and ${errorProduct}.module.js?2 as different files
* Imports missing file type, verify they all end in .js

See https://bryntum.com/products/${errorProduct}/docs/guide/${capitalized}/gettingstarted/es6bundle#troubleshooting for more information

`);
        }
      } else {
        globalThis.bryntum[globalKey] = true;
      }
    }
  }
  static getVersion(product) {
    product = product.toLowerCase();
    if (!VH[product]) {
      throw new Error("No version specified! Please check that you import VersionHelper correctly into the class from where you call `deprecate` function.");
    }
    return VH[product].version;
  }
  static semanticCompareVersion(version1, version2, comparison = "=") {
    version1 = version1 || "";
    version2 = version2 || "";
    const version1Arr = version1.split(/[-.]/), version2Arr = version2.split(/[-.]/), isLower = comparison.includes("<"), normalizeArr = (arr, maxLength) => {
      const states = ["rc", "beta", "alpha"], result = arr.map((v) => {
        if (states.includes(v)) {
          return -states.indexOf(v) - 2;
        }
        const res = Number.parseInt(v);
        return Number.isNaN(res) ? -states.length : res;
      });
      while (result.length < maxLength) {
        result.push(-1);
      }
      return result;
    }, compareArr = () => {
      const maxLength = Math.max(version1Arr.length, version2Arr.length), arr1 = normalizeArr(version1Arr, maxLength), arr2 = normalizeArr(version2Arr, maxLength);
      for (let i = 0; i < maxLength; i++) {
        if (arr1[i] !== arr2[i]) {
          return isLower ? arr1[i] < arr2[i] : arr1[i] > arr2[i];
        }
      }
      return true;
    };
    switch (comparison) {
      case "=":
        return version1 === version2;
      case "<=":
      case ">=":
        return version1 === version2 || compareArr();
      case "<":
      case ">":
        return version1 !== version2 && compareArr();
    }
    return false;
  }
  static checkVersion(product, version, operator) {
    return VersionHelper.semanticCompareVersion(VH.getVersion(product), version, operator);
  }
  static deprecate(product, invalidAsOfVersion, message) {
    const justWarn = VH.checkVersion(product, invalidAsOfVersion, "<");
    if (justWarn) {
      console.warn(`Deprecation warning: You are using a deprecated API which will change in v${invalidAsOfVersion}. ${message}`);
    } else {
      throw new Error(`Deprecated API use. ${message}`);
    }
  }
  static get isTestEnv() {
    var _globalThis$bryntum;
    const isTestEnv = Boolean((_globalThis$bryntum = globalThis.bryntum) === null || _globalThis$bryntum === void 0 ? void 0 : _globalThis$bryntum.isTestEnv);
    try {
      var _globalThis$parent, _globalThis$parent$br;
      return isTestEnv || Boolean((_globalThis$parent = globalThis.parent) === null || _globalThis$parent === void 0 ? void 0 : (_globalThis$parent$br = _globalThis$parent.bryntum) === null || _globalThis$parent$br === void 0 ? void 0 : _globalThis$parent$br.isTestEnv);
    } catch (e) {
      return isTestEnv;
    }
  }
  static get isDebug() {
    let result = false;
    return result;
  }
};
var VH = VersionHelper;
if (BrowserHelper.isBrowserEnv) {
  if (VH.isTestEnv) {
    BrowserHelper._isHoverableDevice = true;
  }
  globalThis.bryntum = Object.assign(globalThis.bryntum || {}, {
    getVersion: VH.getVersion.bind(VH),
    checkVersion: VH.checkVersion.bind(VH),
    deprecate: VH.deprecate.bind(VH),
    license: "4d9731b5-52a4-11ec-a6ac-d094663d5c88"
  });
}
VersionHelper._$name = "VersionHelper";
var {
  defineProperty: defineProperty$7,
  getOwnPropertyDescriptor: getOwnPropertyDescriptor$1
} = Reflect;
var {
  hasOwnProperty: hasOwnProperty$5,
  toString: toString$2
} = Object.prototype;
var instancePropertiesSymbol$1 = Symbol("instanceProperties");
var configuringSymbol$1 = Symbol("configuring");
var lazyConfigValues = Symbol("lazyConfigValues");
var DATE_TYPE$1 = toString$2.call(new Date());
var whitespace = /\s+/;
var createClsProps = (result, cls) => {
  result[cls] = 1;
  return result;
};
var Config = class {
  static get(name, options) {
    const {
      cache
    } = this, baseCfg = cache[name] || (cache[name] = new Config(name));
    let cfg = baseCfg, key;
    if (options) {
      key = Config.makeCacheKey(name, options);
      if (!(cfg = key && cache[key])) {
        cfg = baseCfg.extend(options);
        if (key) {
          cache[key] = cfg;
        }
      }
    }
    return cfg;
  }
  constructor(name) {
    const me = this, cap = name[0].toUpperCase() + name.substr(1);
    me.base = me;
    me.name = name;
    me.field = "_" + name;
    me.capName = cap;
    me.changer = "change" + cap;
    me.initializing = "initializing" + cap;
    me.updater = "update" + cap;
  }
  get descriptor() {
    let descriptor = this._descriptor;
    if (!descriptor || !hasOwnProperty$5.call(this, "_descriptor")) {
      this._descriptor = descriptor = this.makeDescriptor();
    }
    return descriptor;
  }
  get initDescriptor() {
    let descriptor = this._initDescriptor;
    if (!descriptor || !hasOwnProperty$5.call(this, "_initDescriptor")) {
      this._initDescriptor = descriptor = this.makeInitter();
    }
    return descriptor;
  }
  equal(value1, value2) {
    return value1 === value2;
  }
  extend(options) {
    const cfg = Object.assign(Object.create(this), options), {
      equal: equal2,
      merge
    } = options, {
      equalityMethods
    } = Config;
    if (typeof equal2 === "string") {
      if (equal2.endsWith("[]")) {
        cfg.equal = Config.makeArrayEquals(equalityMethods[equal2.substr(0, equal2.length - 2)]);
      } else {
        cfg.equal = equalityMethods[equal2];
      }
    }
    if (typeof merge === "string") {
      cfg.merge = Config.mergeMethods[merge];
    }
    return cfg;
  }
  define(target) {
    const existing = getOwnPropertyDescriptor$1(target, this.name);
    let descriptor = this.descriptor;
    if (existing && existing.get) {
      descriptor = Object.assign({}, descriptor);
      descriptor.get = existing.get;
    }
    defineProperty$7(target, this.name, descriptor);
  }
  defineInitter(target, value) {
    const {
      name
    } = this, properties = target[instancePropertiesSymbol$1];
    let lazyValues, prop;
    if (!properties[name] && (prop = getOwnPropertyDescriptor$1(target, name)) && !("value" in prop)) {
      properties[name] = prop;
    }
    defineProperty$7(target, name, this.initDescriptor);
    if (this.lazy) {
      lazyValues = target[lazyConfigValues] || (target[lazyConfigValues] = /* @__PURE__ */ new Map());
      lazyValues.set(name, value);
    }
  }
  static makeArrayEquals(fn2) {
    return (value1, value2) => {
      let i, equal2 = value1 && value2 && value1.length === (i = value2.length);
      if (equal2 && Array.isArray(value1) && Array.isArray(value2)) {
        if (fn2) {
          while (equal2 && i-- > 0) {
            equal2 = fn2(value1[i], value2[i]);
          }
        } else {
          while (equal2 && i-- > 0) {
            equal2 = value1[i] === value2[i];
          }
        }
      } else {
        equal2 = fn2 ? fn2(value1, value2) : value1 === value2;
      }
      return equal2;
    };
  }
  static makeCacheKey(name, options) {
    const keys = Object.keys(options).sort();
    for (let key, type, value, i = keys.length; i-- > 0; ) {
      value = options[key = keys[i]];
      if (value == null && value === false) {
        keys.splice(i, 1);
      } else {
        type = typeof value;
        if (type === "function") {
          return null;
        }
        if (type === "string") {
          keys[i] = `${key}:"${value}"`;
        } else if (type === "number") {
          keys[i] = `${key}:${value}`;
        }
      }
    }
    return keys.length ? `${name}>${keys.join("|")}` : name;
  }
  makeDescriptor() {
    const config = this, {
      base,
      field,
      changer,
      updater,
      name
    } = config;
    if (base !== config && base.equal === config.equal) {
      return base.descriptor;
    }
    return {
      get() {
        var _this$configObserver;
        (_this$configObserver = this.configObserver) === null || _this$configObserver === void 0 ? void 0 : _this$configObserver.get(name, this);
        return this[field];
      },
      set(value) {
        const me = this;
        let was = me[field], applied, newValue;
        if (typeof value === "string") {
          let resolvedValue = value;
          if (value.startsWith("up.")) {
            var _me$owner;
            resolvedValue = (_me$owner = me.owner) === null || _me$owner === void 0 ? void 0 : _me$owner.resolveProperty(value.substr(3));
          } else if (value.startsWith("this.")) {
            resolvedValue = me.resolveProperty(value.substr(5));
          }
          if (resolvedValue !== void 0 && typeof resolvedValue !== "function") {
            value = resolvedValue;
          }
        }
        if (me[changer]) {
          applied = (newValue = me[changer](value, was)) === void 0;
          if (!applied) {
            value = newValue;
            was = me[field];
          }
        }
        if (!applied && !(config.equal === equal ? was === value : config.equal(was, value))) {
          var _me$updater;
          me[field] = value;
          applied = true;
          (_me$updater = me[updater]) === null || _me$updater === void 0 ? void 0 : _me$updater.call(me, value, was);
        }
        if (applied && !me.onConfigChange.$nullFn) {
          me.onConfigChange({
            name,
            value,
            was,
            config
          });
        }
      }
    };
  }
  makeInitter() {
    const config = this;
    if (config !== config.base) {
      if (config.lazy) {
        return config.makeLazyInitter();
      }
      return config.base.initDescriptor;
    }
    return config.makeBasicInitter();
  }
  makeBasicInitter() {
    const config = this, {
      initializing,
      name
    } = config;
    return {
      configurable: true,
      get() {
        const me = this;
        config.removeInitter(me);
        me[initializing] = true;
        me[name] = me[configuringSymbol$1][name];
        me[initializing] = false;
        me.configDone[name] = true;
        return me[name];
      },
      set(value) {
        config.removeInitter(this);
        this.configDone[name] = true;
        this[name] = value;
      }
    };
  }
  makeLazyInitter() {
    const config = this, {
      initializing,
      name
    } = config;
    return {
      configurable: true,
      get() {
        const me = this, value = me[lazyConfigValues].get(name);
        config.removeInitter(me);
        if (!me.isDestroying) {
          me[initializing] = true;
          me[name] = value;
          me[initializing] = false;
        }
        return me[name];
      },
      set(value) {
        config.removeInitter(this);
        this[name] = value;
      }
    };
  }
  removeInitter(instance) {
    const {
      name
    } = this, instanceProperty = instance[instancePropertiesSymbol$1][name], lazyValues = instance[lazyConfigValues];
    if (instanceProperty) {
      defineProperty$7(instance, name, instanceProperty);
    } else {
      delete instance[name];
    }
    if (lazyValues !== null && lazyValues !== void 0 && lazyValues.delete(name) && !lazyValues.size) {
      delete instance[lazyConfigValues];
    }
  }
  setDefault(cls, value) {
    defineProperty$7(cls.prototype, this.field, {
      configurable: true,
      writable: true,
      value
    });
  }
  merge(newValue, currentValue) {
    if (currentValue && newValue && Objects.isObject(newValue)) {
      if (currentValue.isBase) {
        return currentValue.setConfig(newValue);
      }
      if (Objects.isObject(currentValue)) {
        newValue = Objects.merge(Objects.clone(currentValue), newValue);
      }
    }
    return newValue;
  }
};
var {
  prototype
} = Config;
var {
  equal
} = prototype;
Config.symbols = {
  configuring: configuringSymbol$1,
  instanceProperties: instancePropertiesSymbol$1,
  lazyConfigs: lazyConfigValues
};
Config.cache = /* @__PURE__ */ Object.create(null);
Config.equalityMethods = {
  array: Config.makeArrayEquals(),
  date(value1, value2) {
    if (value1 === value2) {
      return true;
    }
    if (value1 && value2 && toString$2.call(value1) === DATE_TYPE$1 && toString$2.call(value2) === DATE_TYPE$1) {
      return value1.getTime() === value2.getTime();
    }
    return false;
  },
  strict: Config.equal = equal
};
Config.mergeMethods = {
  distinct(newValue, oldValue) {
    let ret = oldValue ? oldValue.slice() : [];
    if (newValue != null) {
      if (Objects.isObject(newValue)) {
        if (oldValue === void 0) {
          ret = newValue;
        } else {
          let key, index;
          for (key in newValue) {
            index = ret.indexOf(key);
            if (newValue[key]) {
              if (index < 0) {
                ret.push(key);
              }
            } else if (index > -1) {
              ret.splice(index, 1);
            }
          }
        }
      } else if (Array.isArray(newValue)) {
        newValue.forEach((v) => !ret.includes(v) && ret.push(v));
      } else if (!ret.includes(newValue)) {
        ret.push(newValue);
      }
    }
    return ret;
  },
  merge: Config.merge = prototype.merge,
  classList(newValue, oldValue) {
    if (typeof newValue === "string") {
      if (!newValue.length) {
        return oldValue;
      }
      newValue = newValue.split(whitespace);
    }
    if (Array.isArray(newValue)) {
      newValue = newValue.reduce(createClsProps, {});
    }
    return Config.merge(newValue, oldValue);
  },
  objects(newValue, oldValue) {
    return newValue === true ? oldValue || {} : Config.merge(newValue, oldValue);
  },
  replace(newValue) {
    return newValue;
  },
  items(newValue, oldValue, metaNew, metaCurrent) {
    if (metaCurrent) {
      return Objects.mergeItems(oldValue, newValue, {
        merge: (oldValue2, newValue2) => prototype.merge(newValue2, oldValue2)
      });
    }
    return prototype.merge(newValue, oldValue);
  }
};
Object.assign(prototype, {
  _descriptor: null,
  _initDescriptor: null,
  lazy: false,
  nullify: false,
  render: false
});
Config._$name = "Config";
var MetaClass = class {
  constructor(options) {
    options && Object.assign(this, options);
  }
  getInherited(name, create = true) {
    let ret = this[name];
    if (!(name in this)) {
      var _this$super;
      ret = (_this$super = this.super) === null || _this$super === void 0 ? void 0 : _this$super.getInherited(name, create);
      if (ret || create) {
        this[name] = ret = Object.create(ret || null);
      }
    }
    return ret;
  }
};
var {
  getPrototypeOf: getPrototypeOf$1
} = Object;
var {
  hasOwn: hasOwn$3
} = Objects;
var {
  defineProperty: defineProperty$6
} = Reflect;
var metaSymbol = Symbol("classMetaData");
var mixinTagSymbol = Symbol("mixinTag");
var originalConfigSymbol = Symbol("originalConfig");
var configuringSymbol = Config.symbols.configuring;
var instancePropertiesSymbol = Config.symbols.instanceProperties;
var lazyConfigsSymbol = Config.symbols.lazyConfigs;
var defaultConfigOptions = {
  merge: "replace",
  simple: true
};
var emptyFn$2 = () => {
};
var newMeta = (o) => new MetaClass(o);
var setupNames = {};
var emptyObject$d = Object.freeze({});
var emptyArray$c = Object.freeze([]);
var Base$1 = class {
  static get isBase() {
    return true;
  }
  get isBase() {
    return true;
  }
  static get declarable() {
    return [
      "declarable",
      "configurable",
      "defaultConfig",
      "properties",
      "prototypeProperties"
    ];
  }
  constructor(...args) {
    const me = this, C = me.constructor;
    if (me.$meta.class !== C) {
      emptyFn$2(C.$meta);
    }
    me.construct(...args);
    me.afterConstruct();
    me.isConstructing = false;
  }
  static new(...configs) {
    configs = configs.filter((c) => c);
    return new this(configs.length > 1 ? this.mergeConfigs(...configs) : configs[0]);
  }
  construct(...args) {
    if (args[0] !== null) {
      this.configure(...args);
    }
    this.afterConfigure();
  }
  static destroy(...args) {
    const shredder = (object) => {
      if (object !== null && object !== void 0 && object.destroy) {
        object.destroy();
      } else if (Array.isArray(object)) {
        object.forEach(shredder);
      }
    };
    shredder(args);
  }
  destroy() {
    const me = this, {
      id
    } = me;
    me.isDestroying = true;
    me.destroy = emptyFn$2;
    me.doDestroy();
    Object.setPrototypeOf(me, null);
    for (const key in me) {
      if (key !== "destroy" && key !== "isDestroying") {
        delete me[key];
      }
    }
    delete me[originalConfigSymbol];
    me.isDestroyed = true;
    me.id = id;
  }
  _thisIsAUsedExpression(getter) {
  }
  static get $$name() {
    return hasOwn$3(this, "$name") && this.$name || hasOwn$3(this, "_$name") && this._$name || this.name;
  }
  get $$name() {
    return this.constructor.$$name;
  }
  startConfigure(config) {
  }
  finishConfigure(config) {
  }
  afterConfigure() {
  }
  afterConstruct() {
  }
  callback(fn2, thisObject, args = emptyArray$c) {
    const {
      handler,
      thisObj
    } = this.resolveCallback(fn2, thisObject === "this" ? this : thisObject) || emptyObject$d;
    return handler === null || handler === void 0 ? void 0 : handler.apply(thisObj, args);
  }
  resolveProperty(propertyPath) {
    let thisObj = this;
    while (thisObj) {
      if (Objects.hasPath(thisObj, propertyPath)) {
        return Objects.getPath(thisObj, propertyPath);
      }
      thisObj = thisObj.owner;
    }
    return void 0;
  }
  resolveCallback(handler, thisObj = this, enforceCallability = true) {
    var _handler;
    if ((_handler = handler) !== null && _handler !== void 0 && _handler.substring) {
      if (handler.endsWith("?")) {
        enforceCallability = false;
        handler = handler.substring(0, handler.length - 1);
      }
      if (handler.startsWith("up.")) {
        handler = handler.substring(3);
        for (thisObj = this.owner; thisObj && !thisObj[handler]; thisObj = thisObj.owner)
          ;
        if (!thisObj) {
          return;
        }
      } else if (handler.startsWith("this.")) {
        handler = handler.substring(5);
        thisObj = this;
      }
      if (!thisObj || !(thisObj instanceof Object)) {
        return;
      }
      handler = thisObj[handler];
    }
    if (typeof handler === "function") {
      return {
        handler,
        thisObj
      };
    }
    if (enforceCallability) {
      throw new Error(`No method named ${handler} on ${thisObj.$$name || "thisObj object"}`);
    }
  }
  bindCallback(inHandler, inThisObj = this) {
    if (inHandler) {
      const {
        handler,
        thisObj
      } = this.resolveCallback(inHandler, inThisObj);
      if (handler) {
        return handler.bind(thisObj);
      }
    }
  }
  delay(fn2, delay2, name = fn2.name || fn2) {
    fn2 = this.setTimeout ? fn2 : fn2.bind(this);
    const invoker = this.setTimeout ? this : globalThis;
    return invoker[typeof delay2 === "number" ? "setTimeout" : "requestAnimationFrame"](fn2, delay2, name);
  }
  doDestroy() {
    const me = this, {
      nullify
    } = me.$meta;
    if (nullify) {
      for (let i = 0; i < nullify.length; ++i) {
        if (me[nullify[i].field] != null) {
          me[nullify[i].name] = null;
        }
      }
    }
  }
  destroyProperties(...properties) {
    const me = this;
    let key, propertyValue;
    for (key of properties) {
      if (key in me && (!me[configuringSymbol] || !me[configuringSymbol][key])) {
        var _propertyValue;
        propertyValue = me[key];
        if ((_propertyValue = propertyValue) !== null && _propertyValue !== void 0 && _propertyValue.destroy) {
          propertyValue.destroy();
        }
        delete me[key];
      }
    }
  }
  configure(config = {}) {
    const me = this, meta = me.$meta, {
      beforeConfigure
    } = config, configs = meta.configs, fullConfig = me.getDefaultConfiguration();
    let cfg, key, value;
    me.initialConfig = config;
    me.isConfiguring = true;
    Object.assign(me, me.getProperties());
    for (key in config) {
      value = config[key];
      cfg = configs[key];
      fullConfig[key] = cfg ? cfg.merge(value, fullConfig[key], null, meta) : value;
    }
    if (beforeConfigure) {
      delete fullConfig.beforeConfigure;
      beforeConfigure(me, fullConfig);
    }
    me.setConfig(me[originalConfigSymbol] = fullConfig, true);
    me.isConfiguring = false;
  }
  getConfig(name) {
    return this[name];
  }
  setConfig(config, isConstructing) {
    const me = this, wasConfiguring = me[configuringSymbol], configDone = wasConfiguring ? me.configDone : me.configDone = {}, configs = me.$meta.configs;
    let cfg, key;
    me[instancePropertiesSymbol] = {};
    me[configuringSymbol] = wasConfiguring ? Object.setPrototypeOf(Object.assign({}, config), wasConfiguring) : config;
    for (key in config) {
      if (config[key] != null || hasOwn$3(config, key)) {
        cfg = configs[key] || Config.get(key);
        cfg.defineInitter(me, config[key]);
        if (!isConstructing) {
          configDone[key] = false;
        }
      } else {
        configDone[key] = true;
      }
    }
    if (isConstructing) {
      me.startConfigure(config);
    }
    for (key in config) {
      var _configs$key;
      if (!configDone[key] && !((_configs$key = configs[key]) !== null && _configs$key !== void 0 && _configs$key.lazy)) {
        me[key] = config[key];
      }
    }
    if (wasConfiguring) {
      me[configuringSymbol] = wasConfiguring;
    } else {
      delete me[configuringSymbol];
    }
    if (isConstructing) {
      me.finishConfigure(config);
    }
    return me;
  }
  hasConfig(name) {
    var _me$lazyConfigsSymbol;
    const me = this, config = me[configuringSymbol];
    return Boolean(me["_" + name] != null || ((_me$lazyConfigsSymbol = me[lazyConfigsSymbol]) === null || _me$lazyConfigsSymbol === void 0 ? void 0 : _me$lazyConfigsSymbol.get(name)) != null || !me.configDone[name] && config && (config[name] != null || hasOwn$3(config, name)));
  }
  peekConfig(name) {
    const me = this, lazyConfig = me[lazyConfigsSymbol], config = me[configuringSymbol];
    if (lazyConfig !== null && lazyConfig !== void 0 && lazyConfig.has(name)) {
      return lazyConfig.get(name);
    }
    if (me.configDone[name]) {
      return me[name];
    }
    if ((config === null || config === void 0 ? void 0 : config[name]) != null || hasOwn$3(config, name)) {
      return config[name];
    }
  }
  triggerConfig(name) {
    const me = this, {
      configDone
    } = me, lazyConfig = me[lazyConfigsSymbol], config = me[configuringSymbol], triggered = lazyConfig !== null && lazyConfig !== void 0 && lazyConfig.has(name) || config && (config[name] != null || hasOwn$3(config, name)) ? !configDone[name] : null;
    if (triggered) {
      me.getConfig(name);
    }
    return triggered;
  }
  triggerConfigs(group) {
    const me = this, configs = me.$meta.configs, lazyConfigs = me[lazyConfigsSymbol], triggered = lazyConfigs ? [...lazyConfigs.keys()].filter((k) => configs[k].lazy === group) : emptyArray$c;
    for (const key of triggered) {
      me.triggerConfig(key);
    }
    return triggered.length ? triggered : null;
  }
  onConfigChange() {
  }
  get config() {
    const result = {}, myConfig = this[originalConfigSymbol];
    for (const key in myConfig) {
      result[key] = myConfig[key];
    }
    return result;
  }
  static processConfigValue(currentValue, options) {
    if (currentValue === globalThis) {
      return globalThis;
    } else if (Array.isArray(currentValue)) {
      return currentValue.map((v) => Base$1.processConfigValue(v, options));
    } else if (currentValue instanceof Base$1) {
      if (options.visited.has(currentValue)) {
        return;
      }
      return currentValue.getCurrentConfig(options);
    } else if (currentValue instanceof HTMLElement || currentValue instanceof DocumentFragment) {
      return null;
    } else if (Objects.isObject(currentValue)) {
      const result = {};
      for (const key in currentValue) {
        result[key] = Base$1.processConfigValue(currentValue[key], options);
      }
      return result;
    }
    return currentValue;
  }
  getConfigValue(name, options) {
    var _me$$meta$configs$nam;
    const me = this, lazyConfigs = me[lazyConfigsSymbol];
    if (!((_me$$meta$configs$nam = me.$meta.configs[name]) !== null && _me$$meta$configs$nam !== void 0 && _me$$meta$configs$nam.lazy)) {
      return Base$1.processConfigValue(me[name], options);
    }
    if (lazyConfigs !== null && lazyConfigs !== void 0 && lazyConfigs.has(name)) {
      return Base$1.processConfigValue(lazyConfigs.get(name), options);
    }
  }
  preProcessCurrentConfigs() {
  }
  getCurrentConfig(options = {}) {
    const me = this, configs = options.configs === "all" ? me.config : Objects.clone(me.initialConfig), visited = options.visited || (options.visited = /* @__PURE__ */ new Set()), depth = options.depth || (options.depth = 0), result = {};
    if (visited.has(me)) {
      return void 0;
    }
    visited.add(me);
    this.preProcessCurrentConfigs(configs);
    for (const name in configs) {
      const value = me.getConfigValue(name, _objectSpread2(_objectSpread2({}, options), {}, {
        depth: depth + 1
      }));
      if (value !== void 0) {
        result[name] = value;
      }
    }
    return result;
  }
  getConfigString(options = {}) {
    return StringHelper.toJavaScriptString(this.getCurrentConfig(options));
  }
  getTestCase(options = {}) {
    const Product = this.isGantt ? "Gantt" : this.isSchedulerPro ? "SchedulerPro" : this.isCalendar ? "Calendar" : this.isScheduler ? "Scheduler" : this.isGrid ? "Grid" : this.isTaskBoard ? "TaskBoard" : null;
    if (Product) {
      const product = Product.toLowerCase(), bundlePath = `../../build/${product}.module.js`;
      let preamble, postamble;
      if (options.import === "static") {
        preamble = `import * as module from "${bundlePath}";Object.assign(window, module);`;
        postamble = "";
      } else {
        preamble = `import("${bundlePath}").then(module => { Object.assign(window, module);
`;
        postamble = "});";
      }
      const version = VersionHelper.getVersion(product);
      if (version) {
        preamble += `
console.log('${Product} ${version}');
`;
      }
      return `${preamble}      
const ${product} = new ${Product}(${this.getConfigString(options)});
${postamble}`;
    }
  }
  downloadTestCase(options = {}) {
    options.output = "return";
    const app = this.getTestCase(options);
    BrowserHelper.download(`app.js`, "data:application/javascript;charset=utf-8," + escape(app));
  }
  static initClass() {
    return this.$meta.class;
  }
  static get $meta() {
    const me = this;
    let meta = me[metaSymbol];
    if (!hasOwn$3(me, metaSymbol)) {
      me[metaSymbol] = meta = newMeta();
      meta.class = me;
      me.setupClass(meta);
    }
    return meta;
  }
  static onClassMixedIn() {
  }
  static mergeConfigs(baseConfig, ...configs) {
    const classConfigs = this.$meta.configs, result = Objects.clone(baseConfig) || {};
    let config, i, key, value;
    for (i = 0; i < configs.length; ++i) {
      config = configs[i];
      if (config) {
        for (key in config) {
          value = config[key];
          if (classConfigs[key]) {
            value = classConfigs[key].merge(value, result[key]);
          } else if (result[key] && value) {
            value = Config.merge(value, result[key]);
          }
          result[key] = value;
        }
      }
    }
    return result;
  }
  static mixin(...mixins) {
    let C = this, i;
    for (i = 0; i < mixins.length; ++i) {
      const mixin2 = mixins[i], tag = mixin2[mixinTagSymbol] || (mixin2[mixinTagSymbol] = Symbol("mixinTag"));
      if (C[tag]) {
        continue;
      }
      C = mixin2(C);
      C[tag] = true;
      if (hasOwn$3(C, "onClassMixedIn")) {
        C.onClassMixedIn();
      }
    }
    return C;
  }
  static setupClass(meta) {
    var _base$nullify;
    const cls = meta.class, base = getPrototypeOf$1(cls).$meta, name = cls.$$name, names = base.names, proto2 = cls.prototype;
    defineProperty$6(proto2, "$meta", {
      value: meta
    });
    Object.assign(meta, {
      super: base,
      config: Object.create(base.config),
      configs: Object.create(base.configs),
      declarables: base.declarables,
      forkConfigs: base.forkConfigs,
      hierarchy: Object.freeze([...base.hierarchy, cls]),
      names: names.includes(name) ? names : Object.freeze([...names, name]),
      properties: base.properties,
      nullify: (_base$nullify = base.nullify) === null || _base$nullify === void 0 ? void 0 : _base$nullify.slice()
    });
    if (names !== meta.names) {
      const isName = `is${name}`, defineIsProperty = (obj) => {
        if (!hasOwn$3(obj, isName)) {
          defineProperty$6(obj, isName, {
            get() {
              if (!hasOwn$3(typeof obj === "object" ? obj.constructor : obj, "$name")) {
                console.warn(`$name static property or getter required for class ${name} to provide class name for minified sources.` + (VersionHelper.isTestEnv ? "" : "\nhttps://bryntum.com/products/grid/docs/api/Core/widget/Widget#property-$name-static"));
              }
              return true;
            }
          });
        }
      };
      defineIsProperty(proto2);
      defineIsProperty(cls);
    }
    for (let decl, setupName, i = 0; i < meta.declarables.length; ++i) {
      decl = meta.declarables[i];
      if (hasOwn$3(cls, decl)) {
        setupName = setupNames[decl] || (setupNames[decl] = `setup${StringHelper.capitalize(decl)}`);
        cls[setupName](cls, meta);
      }
    }
  }
  static setupConfigs(meta, configs, simple) {
    const classConfigValues = meta.config, classConfigs = meta.configs, cls = meta.class, superMeta = meta.super;
    let {
      nullify
    } = meta, cfg, defaultValue2, options, setDefault, value, wasNullify;
    for (const name in configs) {
      value = configs[name];
      if (simple) {
        if (!(cfg = classConfigs[name])) {
          cfg = Config.get(name, defaultConfigOptions);
        } else {
          value = cfg.merge(value, classConfigValues[name], meta, superMeta);
        }
      } else {
        defaultValue2 = options = setDefault = void 0;
        if (value && typeof value === "object" && "$config" in value) {
          options = value.$config;
          if (options && !Objects.isObject(options)) {
            options = Objects.createTruthyKeys(options);
          }
          setDefault = "default" in value;
          defaultValue2 = setDefault ? value.default : defaultValue2;
          value = value.value;
        }
        if (!(cfg = classConfigs[name])) {
          cfg = Config.get(name, options);
          cfg.define(cls.prototype);
          setDefault = !(cfg.field in cls.prototype);
          wasNullify = false;
        } else {
          wasNullify = cfg.nullify;
          if (options) {
            cfg = cfg.extend(options);
          }
          value = cfg.merge(value, classConfigValues[name], meta, superMeta);
        }
        if (setDefault) {
          cfg.setDefault(cls, defaultValue2);
        }
        if (cfg.nullify && !wasNullify) {
          (nullify || (nullify = meta.nullify || (meta.nullify = []))).push(cfg);
        }
      }
      if (value && (Objects.isObject(value) || Array.isArray(value)) && !Object.isFrozen(value)) {
        meta.forkConfigs = true;
      }
      classConfigs[name] = cfg;
      classConfigValues[name] = value;
    }
  }
  static setupConfigurable(cls, meta) {
    cls.setupConfigs(meta, cls.configurable, false);
  }
  static setupDefaultConfig(cls, meta) {
    cls.setupConfigs(meta, cls.defaultConfig, true);
  }
  static setupDeclarable(cls, meta) {
    const declarable = cls.declarable;
    let all = meta.declarables, forked, i;
    for (i = 0; i < declarable.length; ++i) {
      if (!all.includes(declarable[i])) {
        if (!forked) {
          meta.declarables = forked = all = all.slice();
        }
        all.push(declarable[i]);
      }
    }
  }
  static setupProperties(cls, meta) {
    meta.properties = meta.super.properties.slice();
    meta.properties.push(cls);
    Object.freeze(meta.properties);
  }
  static setupPrototypeProperties(cls) {
    Object.assign(cls.prototype, cls.prototypeProperties);
  }
  getDefaultConfiguration() {
    return this.constructor.getDefaultConfiguration();
  }
  static getDefaultConfiguration() {
    const meta = this.$meta, config = meta.forkConfigs ? Base$1.fork(meta.config) : Object.create(meta.config);
    if (VersionHelper.isTestEnv && BrowserHelper.isBrowserEnv && config.testConfig && globalThis.__applyTestConfigs) {
      for (const o in config.testConfig) {
        config[o] = config.testConfig[o];
      }
    }
    return config;
  }
  static fork(obj) {
    let ret = obj, key, value;
    if (obj && Objects.isObject(obj) && !Object.isFrozen(obj)) {
      ret = Object.create(obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (Objects.isObject(value)) {
            ret[key] = Base$1.fork(value);
          } else if (Array.isArray(value)) {
            ret[key] = value.slice();
          }
        }
      }
    }
    return ret;
  }
  getProperties() {
    const hierarchy = this.$meta.properties, result = {};
    for (let i = 0; i < hierarchy.length; i++) {
      Object.assign(result, hierarchy[i].properties);
    }
    return result;
  }
  static get superclass() {
    return getPrototypeOf$1(this);
  }
  classHierarchy(topClass) {
    const hierarchy = this.$meta.hierarchy, index = topClass ? hierarchy.indexOf(topClass) : 0;
    return index > 0 ? hierarchy.slice(index) : hierarchy;
  }
  static isOfTypeName(type) {
    return this.$meta.names.includes(type);
  }
  detachListeners(name) {
    var _detachers;
    let detachers = this.$detachers;
    detachers = (_detachers = detachers) === null || _detachers === void 0 ? void 0 : _detachers[name];
    if (detachers) {
      while (detachers.length) {
        detachers.pop()();
      }
    }
  }
  trackDetacher(name, detacher2) {
    const detachers = this.$detachers || (this.$detachers = {}), bucket = detachers[name] || (detachers[name] = []);
    bucket.push(detacher2);
  }
  untrackDetachers(eventer) {
    const detachers = this.$detachers;
    if (detachers) {
      for (const name in detachers) {
        const bucket = detachers[name];
        for (let i = bucket.length; i-- > 0; ) {
          if (bucket[i].eventer === eventer) {
            bucket.splice(i, 1);
          }
        }
      }
    }
  }
};
var proto$2 = Base$1.prototype;
proto$2.onConfigChange.$nullFn = emptyFn$2.$nullFn = true;
Base$1[metaSymbol] = proto$2.$meta = newMeta({
  class: Base$1,
  config: Object.freeze({}),
  configs: /* @__PURE__ */ Object.create(null),
  declarables: Base$1.declarable,
  forkConfigs: false,
  hierarchy: Object.freeze([Base$1]),
  names: Object.freeze(["Base"]),
  nullify: null,
  properties: Object.freeze([]),
  super: null
});
Object.assign(proto$2, {
  $detachers: null,
  configObserver: null,
  isConstructing: true,
  isDestroyed: false,
  isDestroying: false
});
Base$1.emptyFn = emptyFn$2;
VersionHelper.setVersion("core", "5.3.0");
Base$1._$name = "Base";
var ArrayHelper = class {
  static clean(array) {
    return array.reduce((res, item) => {
      if (item !== null && item !== void 0 && !(Array.isArray(item) && item.length === 0) && item !== "")
        res.push(item);
      return res;
    }, []);
  }
  static from(iterable, filter2, map2) {
    const array = [];
    if (iterable) {
      for (const it of iterable) {
        if (!filter2 || filter2(it)) {
          array.push(map2 ? map2(it) : it);
        }
      }
    }
    return array;
  }
  static remove(array, ...items2) {
    let index, item, removed = false;
    for (let i = 0; i < items2.length; i++) {
      item = items2[i];
      if ((index = array.indexOf(item)) !== -1) {
        array.splice(index, 1);
        removed = true;
      }
    }
    return removed;
  }
  static findInsertionIndex(item, array, comparatorFn = this.lexicalCompare, index) {
    const len = array.length;
    let beforeCheck, afterCheck;
    if (index < len) {
      beforeCheck = index > 0 ? comparatorFn(array[index - 1], item) : 0;
      afterCheck = index < len - 1 ? comparatorFn(item, array[index]) : 0;
      if (beforeCheck < 1 && afterCheck < 1) {
        return index;
      }
    }
    return this.binarySearch(array, item, comparatorFn);
  }
  static findLast(array, fn2, thisObj) {
    for (let {
      length
    } = array, i = length - 1; i >= 0; i--) {
      if (fn2.call(thisObj, array[i], i, array)) {
        return array[i];
      }
    }
  }
  static binarySearch(array, item, begin = 0, end = array.length, compareFn = this.lexicalCompare) {
    const length = array.length;
    let middle, comparison;
    if (begin instanceof Function) {
      compareFn = begin;
      begin = 0;
    } else if (end instanceof Function) {
      compareFn = end;
      end = length;
    }
    --end;
    while (begin <= end) {
      middle = begin + end >> 1;
      comparison = compareFn(item, array[middle]);
      if (comparison >= 0) {
        begin = middle + 1;
      } else if (comparison < 0) {
        end = middle - 1;
      }
    }
    return begin;
  }
  magnitudeCompare(lhs, rhs) {
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }
  lexicalCompare(lhs, rhs) {
    lhs = String(lhs);
    rhs = String(rhs);
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }
  static fill(count, itemOrArray = {}, fn2 = null) {
    const result = [], items2 = Array.isArray(itemOrArray) ? itemOrArray : [itemOrArray];
    for (let i = 0; i < count; i++) {
      for (const item of items2) {
        const processedItem = Object.assign({}, item);
        if (fn2) {
          fn2(processedItem, i);
        }
        result.push(processedItem);
      }
    }
    return result;
  }
  static populate(count, fn2, oneBased = false) {
    const items2 = [];
    for (let i = 0; i < count; i++) {
      items2.push(fn2(i + (oneBased ? 1 : 0)));
    }
    return items2;
  }
  static include(array, ...items2) {
    for (const item of items2) {
      if (!array.includes(item)) {
        array.push(item);
      }
    }
  }
  static unique(array) {
    return [...new Set(array)];
  }
  static allowNegative(array) {
    return new Proxy(array, {
      get(target, name, receiver) {
        if (typeof name !== "string") {
          return Reflect.get(target, name, receiver);
        }
        const index = Number(name);
        if (Number.isNaN(index)) {
          return Reflect.get(target, name, receiver);
        }
        return target[index < 0 ? target.length + index : index];
      },
      set(target, name, value, receiver) {
        if (typeof name !== "string") {
          return Reflect.set(target, name, value, receiver);
        }
        const index = Number(name);
        if (Number.isNaN(index)) {
          return Reflect.set(target, name, value, receiver);
        }
        target[index < 0 ? target.length + index : index] = value;
        return true;
      }
    });
  }
  static delta(a, b, useRelativeNaming = false) {
    if (!b) {
      return useRelativeNaming ? {
        toAdd: a,
        toRemove: [],
        toKeep: []
      } : {
        onlyInA: a,
        onlyInB: [],
        inBoth: []
      };
    }
    const onlyInA = [], onlyInB = [], inBoth = /* @__PURE__ */ new Set(), bSet = new Set(b);
    for (let i = 0; i < a.length; i++) {
      const item = a[i];
      if (bSet.has(item)) {
        inBoth.add(item);
      } else {
        onlyInA.push(item);
      }
    }
    for (let i = 0; i < b.length; i++) {
      const item = b[i];
      if (!inBoth.has(item)) {
        onlyInB.push(item);
      }
    }
    if (useRelativeNaming) {
      return {
        toAdd: onlyInA,
        toRemove: onlyInB,
        toKeep: inBoth
      };
    }
    return {
      onlyInA,
      onlyInB,
      inBoth: [...inBoth]
    };
  }
  static asArray(arrayOrObject) {
    if (arrayOrObject == null) {
      return arrayOrObject;
    }
    if (arrayOrObject instanceof Set) {
      return Array.from(arrayOrObject);
    }
    return Array.isArray(arrayOrObject) ? arrayOrObject : [arrayOrObject];
  }
  static identity(x) {
    return x;
  }
  static keyBy(array, keyGetter, valueGetter = ArrayHelper.identity) {
    const getKey = typeof keyGetter === "string" ? (o) => o === null || o === void 0 ? void 0 : o[keyGetter] : keyGetter, getValue = typeof valueGetter === "string" ? (o) => o === null || o === void 0 ? void 0 : o[valueGetter] : valueGetter;
    return array.reduce((dict, next) => {
      dict[getKey(next)] = getValue(next);
      return dict;
    }, {});
  }
};
ArrayHelper._$name = "ArrayHelper";
var commaSepRe = /,\s*/;
var decompiledSym = Symbol("decompiled");
var fnRe1 = /^\s*(async\s+)?([a-z_]\w*)\s*=>([\s\S]+)$/i;
var fnRe2 = /^\s*(async\s*)?\s*\(((?:[a-z_]\w*(?:, [a-z_]\w*)*)?)\)\s+=>([\s\S]+)$/i;
var fnRe3 = /^(\s*async)?(?:\s*function)?(?:\s*([a-z_]\w*))?\s*\(((?:[a-z_]\w*(?:, [a-z_]\w*)*)?)\)([\s\S]+)$/i;
var {
  hasOwnProperty: hasOwnProperty$4
} = Object.prototype;
var FunctionHelper = class {
  static after(object, method, fn2, thisObj, options) {
    const named = typeof fn2 === "string", withReturn = (options === null || options === void 0 ? void 0 : options.return) !== false, hook = (...args) => {
      const origResult = hook.$nextHook.call(object, ...args), hookResult = thisObj !== null && thisObj !== void 0 && thisObj.isDestroyed ? void 0 : withReturn ? named ? thisObj[fn2](origResult, ...args) : fn2.call(thisObj, origResult, ...args) : named ? thisObj[fn2](...args) : fn2.call(thisObj, ...args);
      return hookResult === void 0 ? origResult : hookResult;
    };
    return FunctionHelper.hookMethod(object, method, hook);
  }
  static before(object, method, fn2, thisObj) {
    const named = typeof fn2 === "string", hook = (...args) => {
      const ret = thisObj !== null && thisObj !== void 0 && thisObj.isDestroyed ? 0 : named ? thisObj[fn2](...args) : fn2.call(thisObj, ...args);
      return ret === false ? ret : hook.$nextHook.call(object, ...args);
    };
    return FunctionHelper.hookMethod(object, method, hook);
  }
  static curry(func) {
    return function curried(...args) {
      if (args.length >= func.length) {
        return func.apply(this, args);
      } else {
        return function(...args2) {
          return curried.apply(this, args.concat(args2));
        };
      }
    };
  }
  static bindAll(obj) {
    for (const key in obj) {
      if (typeof obj[key] === "function") {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
  static createInterceptor(original, interceptor, thisObj) {
    return function(...args) {
      const theThis = thisObj || this;
      if (interceptor.call(theThis, ...args) !== false) {
        return original.call(theThis, ...args);
      }
      return false;
    };
  }
  static createSequence(original, sequence, thisObj) {
    return (...args) => {
      const origResult = original.call(thisObj, ...args), sequenceResult = sequence.call(thisObj, ...args);
      return sequenceResult === void 0 ? origResult : sequenceResult;
    };
  }
  static createThrottled(fn2, buffer, thisObj, extraArgs, alt2) {
    let lastCallTime = -Number.MAX_VALUE, callArgs, timerId;
    const invoke = () => {
      timerId = 0;
      lastCallTime = performance.now();
      callArgs.push.apply(callArgs, extraArgs);
      fn2.apply(thisObj, callArgs);
    }, result = function(...args) {
      const elapsed = performance.now() - lastCallTime;
      callArgs = args;
      if (elapsed >= buffer) {
        clearTimeout(timerId);
        invoke();
      } else {
        if (!timerId) {
          timerId = setTimeout(invoke, buffer - elapsed);
        }
        if (alt2) {
          callArgs.push.apply(callArgs, extraArgs);
          alt2.apply(thisObj, callArgs);
        }
      }
    };
    result.cancel = () => clearTimeout(timerId);
    return result;
  }
  static createBuffered(fn2, buffer, thisObj, args) {
    let callArgs, timerId;
    const invoke = () => {
      timerId = 0;
      result.isPending = false;
      callArgs.push.apply(callArgs, args);
      fn2.apply(thisObj, callArgs);
    }, result = function(...args2) {
      callArgs = args2;
      if (timerId) {
        clearTimeout(timerId);
      }
      result.isPending = true;
      timerId = setTimeout(invoke, buffer);
    };
    result.cancel = () => {
      result.isPending = false;
      clearTimeout(timerId);
    };
    return result;
  }
  static decompile(fn2) {
    if (!(decompiledSym in fn2)) {
      var _body, _body2;
      const code = fn2.toString();
      let m = fnRe1.exec(code), args, body, name, decompiled, t;
      if (m) {
        args = [m[2]];
        body = m[3];
      } else if (m = fnRe2.exec(code)) {
        t = m[2].trim();
        args = t ? t.split(commaSepRe) : [];
        body = m[3];
      } else if (m = fnRe3.exec(code)) {
        name = m[2];
        t = m[3].trim();
        args = t ? t.split(commaSepRe) : [];
        body = m[4];
      }
      body = (_body = body) === null || _body === void 0 ? void 0 : _body.trim();
      fn2[decompiledSym] = decompiled = m && {
        args,
        async: Boolean(m[1]),
        body: (_body2 = body) !== null && _body2 !== void 0 && _body2.startsWith("{") ? body.substring(1, body.length - 1).trim() : body
      };
      if (name) {
        decompiled.name = name;
      }
    }
    return fn2[decompiledSym];
  }
  static hookMethod(object, method, hook) {
    hook.$nextHook = object[method];
    object[method] = hook;
    return () => {
      if (hasOwnProperty$4.call(object, method)) {
        let f = object[method], next;
        if (f === hook) {
          var _Object$getPrototypeO;
          if (((_Object$getPrototypeO = Object.getPrototypeOf(object)) === null || _Object$getPrototypeO === void 0 ? void 0 : _Object$getPrototypeO[method]) === hook.$nextHook) {
            delete object[method];
          } else {
            object[method] = hook.$nextHook;
          }
        } else {
          for (; next = (_f = f) === null || _f === void 0 ? void 0 : _f.$nextHook; f = next) {
            var _f;
            if (next === hook) {
              f.$nextHook = hook.$nextHook;
              break;
            }
          }
        }
      }
    };
  }
  static noThrow(object, method, handler) {
    const fn2 = object[method];
    object[method] = (...args) => {
      try {
        return fn2.apply(object, args);
      } catch (e) {
        return handler === null || handler === void 0 ? void 0 : handler(e);
      }
    };
  }
  static returnTrue() {
    return true;
  }
  static animate(duration, fn2, thisObj, easing = "linear") {
    let cancel = false;
    const result = new Promise((resolve) => {
      const start = performance.now(), iterate = () => {
        const progress = Math.min((performance.now() - start) / duration, 1), delayable = thisObj && thisObj.setTimeout ? thisObj : globalThis;
        if (!cancel) {
          if (fn2.call(thisObj, this.easingFunctions[easing](progress)) === false) {
            resolve();
          }
        }
        if (cancel || progress === 1) {
          delayable.requestAnimationFrame(() => resolve());
        } else {
          delayable.requestAnimationFrame(iterate);
        }
      };
      iterate();
    });
    result.cancel = () => {
      cancel = true;
      return false;
    };
    return result;
  }
};
var half = 0.5;
var e1 = 1.70158;
var e2 = 7.5625;
var e3 = 1.525;
var e4 = 2 / 2.75;
var e5 = 2.25 / 2.75;
var e6 = 1 / 2.75;
var e7 = 1.5 / 2.75;
var e8 = 2.5 / 2.75;
var e9 = 2.625 / 2.75;
var e10 = 0.75;
var e11 = 0.9375;
var e12 = 0.984375;
var s1 = 1.70158;
var s2 = 1.70158;
FunctionHelper.easingFunctions = {
  linear: (t) => t,
  easeInQuad: (t) => Math.pow(t, 2),
  easeOutQuad: (t) => -(Math.pow(t - 1, 2) - 1),
  easeInOutQuad: (t) => (t /= half) < 1 ? half * Math.pow(t, 2) : -half * ((t -= 2) * t - 2),
  easeInCubic: (t) => Math.pow(t, 3),
  easeOutCubic: (t) => Math.pow(t - 1, 3) + 1,
  easeInOutCubic: (t) => (t /= half) < 1 ? half * Math.pow(t, 3) : half * (Math.pow(t - 2, 3) + 2),
  easeInQuart: (t) => Math.pow(t, 4),
  easeOutQuart: (t) => -(Math.pow(t - 1, 4) - 1),
  easeInOutQuart: (t) => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeInQuint: (t) => Math.pow(t, 5),
  easeOutQuint: (t) => Math.pow(t - 1, 5) + 1,
  easeInOutQuint: (t) => (t /= half) < 1 ? half * Math.pow(t, 5) : half * (Math.pow(t - 2, 5) + 2),
  easeInSine: (t) => -Math.cos(t * (Math.PI / 2)) + 1,
  easeOutSine: (t) => Math.sin(t * (Math.PI / 2)),
  easeInOutSine: (t) => -half * (Math.cos(Math.PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => t === 0 ? 0 : t === 1 ? 1 : (t /= half) < 1 ? half * Math.pow(2, 10 * (t - 1)) : half * (-Math.pow(2, -10 * --t) + 2),
  easeInCirc: (t) => -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => (t /= half) < 1 ? -half * (Math.sqrt(1 - t * t) - 1) : half * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeOutBounce: (t) => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  easeInBack: (t) => t * t * ((e1 + 1) * t - e1),
  easeOutBack: (t) => (t = t - 1) * t * ((e1 + 1) * t + e1) + 1,
  easeInOutBack: (t) => {
    let v1 = s1;
    return (t /= half) < 1 ? half * (t * t * (((v1 *= e3) + 1) * t - v1)) : half * ((t -= 2) * t * (((v1 *= e3) + 1) * t + v1) + 2);
  },
  elastic: (t) => -1 * Math.pow(4, -8 * t) * Math.sin((t * 6 - 1) * (2 * Math.PI) / 2) + 1,
  swingFromTo: (t) => {
    let v2 = s2;
    return (t /= half) < 1 ? half * (t * t * (((v2 *= e3) + 1) * t - v2)) : half * ((t -= 2) * t * (((v2 *= e3) + 1) * t + v2) + 2);
  },
  swingFrom: (t) => t * t * ((e1 + 1) * t - e1),
  swingTo: (t) => (t -= 1) * t * ((e1 + 1) * t + e1) + 1,
  bounce: (t) => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  bouncePast: (t) => t < e6 ? e2 * t * t : t < e4 ? 2 - (e2 * (t -= e7) * t + e10) : t < e8 ? 2 - (e2 * (t -= e5) * t + e11) : 2 - (e2 * (t -= e9) * t + e12),
  easeFromTo: (t) => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeFrom: (t) => Math.pow(t, 4),
  easeTo: (t) => Math.pow(t, 0.25)
};
FunctionHelper._$name = "FunctionHelper";
var {
  isArray: isArray$1
} = Array;
var {
  hasOwnProperty: hasOwnProperty$3
} = Object.prototype;
var specialProperties = {
  thisObj: 1,
  detachable: 1,
  once: 1,
  detacher: 1,
  prio: 1,
  args: 1,
  expires: 1,
  buffer: 1,
  throttle: 1,
  name: 1,
  $internal: 1
};
var priorityComparator = (a, b) => b.prio - a.prio;
var Events = (Target) => class Events2 extends (Target || Base$1) {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "eventsSuspended", null);
  }
  static get $name() {
    return "Events";
  }
  static get declarable() {
    return [
      "deprecatedEvents"
    ];
  }
  static setupDeprecatedEvents(cls, meta) {
    const all = meta.getInherited("deprecatedEvents"), add = cls.deprecatedEvents;
    for (const eventName in add) {
      all[eventName.toLowerCase()] = all[eventName] = add[eventName];
    }
  }
  static get configurable() {
    return {
      listeners: {
        value: null,
        $config: {
          merge(newValue, currentValue) {
            if (newValue !== null) {
              if (!newValue) {
                return currentValue;
              }
              if (currentValue) {
                newValue = newValue ? [newValue] : [];
                newValue.push[isArray$1(currentValue) ? "apply" : "call"](newValue, currentValue);
              }
            }
            return newValue;
          }
        }
      },
      internalListeners: null,
      bubbleEvents: null
    };
  }
  destroy() {
    this.trigger("beforeDestroy");
    super.destroy();
  }
  construct(config, ...args) {
    var _config;
    if (this.configuredListeners = (_config = config) === null || _config === void 0 ? void 0 : _config.listeners) {
      config = Objects.assign({}, config);
      delete config.listeners;
    }
    super.construct(config, ...args);
    this.processConfiguredListeners();
  }
  processConfiguredListeners() {
    if (this.configuredListeners) {
      const me = this, {
        isConfiguring
      } = me;
      me.isConfiguring = false;
      me.listeners = me.configuredListeners;
      me.configuredListeners = null;
      me.isConfiguring = isConfiguring;
    }
  }
  doDestroy() {
    this.trigger("destroy");
    this.removeAllListeners(false);
    super.doDestroy();
  }
  static setupClass(meta) {
    super.setupClass(meta);
    Events2.prototype.onListen.$nullFn = true;
    Events2.prototype.onUnlisten.$nullFn = true;
  }
  addListener(config, thisObj, oldThisObj) {
    if (isArray$1(config)) {
      for (let i = 0, {
        length
      } = config; i < length; i++) {
        this.addListener(config[i], thisObj);
      }
      return;
    }
    const me = this, deprecatedEvents = me.$meta.getInherited("deprecatedEvents");
    if (typeof config === "string") {
      return me.addListener({
        [config]: thisObj,
        detachable: thisObj.detachable !== false,
        thisObj: oldThisObj
      });
    } else {
      thisObj = config.thisObj = config.thisObj !== void 0 ? config.thisObj : thisObj;
      for (const key in config) {
        if (!specialProperties[key] && config[key] != null) {
          const eventName = key.toLowerCase(), deprecatedEvent = deprecatedEvents === null || deprecatedEvents === void 0 ? void 0 : deprecatedEvents[eventName], events = me.eventListeners || (me.eventListeners = {}), listenerSpec = config[key], expires = listenerSpec.expires || config.expires, listener = {
            fn: typeof listenerSpec === "object" ? listenerSpec.fn : listenerSpec,
            thisObj: listenerSpec.thisObj !== void 0 ? listenerSpec.thisObj : thisObj,
            args: listenerSpec.args || config.args,
            prio: listenerSpec.prio !== void 0 ? listenerSpec.prio : config.prio !== void 0 ? config.prio : 0,
            once: listenerSpec.once !== void 0 ? listenerSpec.once : config.once !== void 0 ? config.once : false,
            buffer: listenerSpec.buffer || config.buffer,
            throttle: listenerSpec.throttle || config.throttle,
            $internal: config.$internal,
            catchAll: key === "catchAll"
          };
          if (deprecatedEvent) {
            const {
              product,
              invalidAsOfVersion,
              message
            } = deprecatedEvent;
            VersionHelper.deprecate(product, invalidAsOfVersion, message);
          }
          if (expires) {
            const {
              alt: alt2
            } = expires, delay2 = alt2 ? expires.delay : expires, name2 = config.name || key, fn2 = () => {
              me.un(eventName, listener);
              if (alt2 && !listener.called) {
                me.callback(alt2, thisObj);
              }
            };
            if (me.isDelayable) {
              me.setTimeout({
                fn: fn2,
                name: name2,
                cancelOutstanding: true,
                delay: delay2
              });
            } else {
              globalThis.setTimeout(fn2, delay2);
            }
          }
          let listeners = events[eventName] || (events[eventName] = []);
          if (listeners.$firing) {
            events[eventName] = listeners = listeners.slice();
          }
          listeners.splice(ArrayHelper.findInsertionIndex(listener, listeners, priorityComparator, listeners.length), 0, listener);
          if (!me.onListen.$nullFn && listeners.length < 2) {
            me.onListen(eventName);
          }
        }
      }
      if (config.relayAll) {
        me.relayAll(config.relayAll);
      }
      if (thisObj && thisObj !== me) {
        me.attachAutoDetacher(config, thisObj);
      }
      const detachable = config.detachable !== false, name = config.name, destroy = config.expires || detachable || name ? () => {
        if (!me.isDestroyed) {
          me.removeListener(config, thisObj);
        }
      } : null;
      if (destroy) {
        var _thisObj;
        destroy.eventer = me;
        destroy.listenerName = name;
        if (name && (_thisObj = thisObj) !== null && _thisObj !== void 0 && _thisObj.trackDetacher) {
          thisObj.trackDetacher(name, destroy);
        }
        if (config.expires) {
          me.delay(destroy, isNaN(config.expires) ? config.expires.delay : config.expires, name);
        }
        if (detachable) {
          return destroy;
        }
      }
    }
  }
  on(config, thisObj, oldThisObj) {
    return this.addListener(config, thisObj, oldThisObj);
  }
  ion(config) {
    config.$internal = true;
    return this.on(config);
  }
  un(...args) {
    this.removeListener(...args);
  }
  updateInternalListeners(internalListeners, oldInternalListeners) {
    oldInternalListeners === null || oldInternalListeners === void 0 ? void 0 : oldInternalListeners.detach();
    if (internalListeners) {
      internalListeners.detach = this.ion(internalListeners);
    }
  }
  get listeners() {
    return this.eventListeners;
  }
  changeListeners(listeners) {
    if (this.isConfiguring) {
      this.getConfig("internalListeners");
      if (listeners) {
        this.on(listeners, this);
      }
    } else {
      if (Array.isArray(listeners)) {
        for (let i = 0, l = listeners[0], {
          length
        } = listeners; i < length; l = listeners[++i]) {
          if (!("thisObj" in l)) {
            listeners[i] = Objects.assign({
              thisObj: this
            }, l);
          }
        }
      } else if (listeners && !("thisObj" in listeners)) {
        listeners = Objects.assign({
          thisObj: this
        }, listeners);
      }
      return listeners;
    }
  }
  updateListeners(listeners, oldListeners) {
    oldListeners && this.un(oldListeners);
    listeners && this.on(listeners);
  }
  removeListener(config, thisObj = config.thisObj, oldThisObj) {
    const me = this;
    if (typeof config === "string") {
      return me.removeListener({
        [config]: thisObj
      }, oldThisObj);
    }
    Object.entries(config).forEach(([eventName, listenerToRemove]) => {
      if (!specialProperties[eventName] && listenerToRemove != null) {
        eventName = eventName.toLowerCase();
        const eventListeners = me.eventListeners, index = me.findListener(eventName, listenerToRemove, thisObj);
        if (index >= 0) {
          let listeners = eventListeners[eventName];
          if (listeners.length > 1) {
            if (listeners.$firing) {
              eventListeners[eventName] = listeners = listeners.slice();
            }
            listeners.splice(index, 1);
          } else {
            delete eventListeners[eventName];
            if (!me.onUnlisten.$nullFn) {
              me.onUnlisten(eventName);
            }
          }
        }
      }
    });
    if (config.thisObj && !config.thisObj.isDestroyed) {
      me.detachAutoDetacher(config);
    }
  }
  findListener(eventName, listenerToFind, defaultThisObj) {
    var _this$eventListeners;
    const eventListeners = (_this$eventListeners = this.eventListeners) === null || _this$eventListeners === void 0 ? void 0 : _this$eventListeners[eventName], fn2 = listenerToFind.fn || listenerToFind, thisObj = listenerToFind.thisObj || defaultThisObj;
    if (eventListeners) {
      for (let listenerEntry, i = 0, {
        length
      } = eventListeners; i < length; i++) {
        listenerEntry = eventListeners[i];
        if (listenerEntry.fn === fn2 && listenerEntry.thisObj === thisObj) {
          return i;
        }
      }
    }
    return -1;
  }
  hasListener(eventName) {
    var _this$eventListeners2;
    return Boolean((_this$eventListeners2 = this.eventListeners) === null || _this$eventListeners2 === void 0 ? void 0 : _this$eventListeners2[eventName === null || eventName === void 0 ? void 0 : eventName.toLowerCase()]);
  }
  relayAll(through, prefix, transformCase = true) {
    if (!this.relayAllTargets) {
      this.relayAllTargets = [];
    }
    const relayAllTargets = this.relayAllTargets;
    through.on({
      beforeDestroy: ({
        source
      }) => {
        if (source === through) {
          const configs = relayAllTargets.filter((r) => r.through === through);
          configs.forEach((config) => ArrayHelper.remove(relayAllTargets, config));
        }
      }
    });
    relayAllTargets.push({
      through,
      prefix,
      transformCase
    });
  }
  removeAllListeners(preserveInternal = true) {
    const listeners = this.eventListeners;
    let i, thisObj;
    for (const event in listeners) {
      const bucket = listeners[event];
      for (i = bucket.length; i-- > 0; ) {
        const cfg = bucket[i];
        if (!cfg.$internal || !preserveInternal) {
          var _thisObj2, _thisObj2$untrackDeta, _thisObj3;
          this.removeListener(event, cfg);
          thisObj = cfg.thisObj;
          (_thisObj2 = thisObj) === null || _thisObj2 === void 0 ? void 0 : (_thisObj2$untrackDeta = (_thisObj3 = _thisObj2).untrackDetachers) === null || _thisObj2$untrackDeta === void 0 ? void 0 : _thisObj2$untrackDeta.call(_thisObj3, this);
        }
      }
    }
  }
  relayEvents(source, eventNames, prefix = "") {
    const listenerConfig = {
      detachable: true,
      thisObj: this
    };
    eventNames.forEach((eventName) => {
      listenerConfig[eventName] = (event, ...params) => {
        return this.trigger(prefix + eventName, event, ...params);
      };
    });
    return source.on(listenerConfig);
  }
  onListen() {
  }
  onUnlisten() {
  }
  destructorInterceptor() {
    const {
      autoDetachers,
      target,
      oldDestructor
    } = this;
    for (let i = 0; i < autoDetachers.length; i++) {
      const {
        dispatcher,
        config
      } = autoDetachers[i];
      if (!dispatcher.isDestroyed) {
        dispatcher.removeListener(config, target);
      }
    }
    oldDestructor.call(target);
  }
  attachAutoDetacher(config, thisObj) {
    const target = config.thisObj || thisObj, destructorName = "doDestroy" in target ? "doDestroy" : "destroy";
    if (destructorName in target) {
      let {
        $autoDetachers
      } = target;
      if (!$autoDetachers) {
        target.$autoDetachers = $autoDetachers = [];
      }
      if (!target.$oldDestructor) {
        target.$oldDestructor = target[destructorName];
        target[destructorName] = this.destructorInterceptor.bind({
          autoDetachers: $autoDetachers,
          oldDestructor: target.$oldDestructor,
          target
        });
      }
      $autoDetachers.push({
        config,
        dispatcher: this
      });
    } else {
      target[destructorName] = () => {
        this.removeListener(config);
      };
    }
  }
  detachAutoDetacher(config) {
    const target = config.thisObj;
    if (target.$oldDestructor && !target.isDestroying) {
      ArrayHelper.remove(target.$autoDetachers, target.$autoDetachers.find((detacher2) => detacher2.config === config && detacher2.dispatcher === this));
      if (!target.$autoDetachers.length) {
        target["doDestroy" in target ? "doDestroy" : "destroy"] = target.$oldDestructor;
        target.$oldDestructor = null;
      }
    }
  }
  await(eventName, options = {
    checkLog: true,
    resetLog: true,
    args: null
  }) {
    const me = this;
    if (options === false) {
      options = {
        checkLog: false
      };
    }
    const {
      args
    } = options;
    return new Promise((resolve) => {
      var _me$_triggered;
      if (options.checkLog && (_me$_triggered = me._triggered) !== null && _me$_triggered !== void 0 && _me$_triggered[eventName]) {
        resolve();
        if (options.resetLog) {
          me.clearLog(eventName);
        }
      }
      if (args) {
        const detacher2 = me.on({
          [eventName]: (...params) => {
            const argsOk = Object.keys(args).every((key) => {
              return key in params[0] && params[0][key] === args[key];
            });
            if (argsOk) {
              resolve(...params);
              if (options.resetLog) {
                me.clearLog(eventName);
              }
              detacher2();
            }
          },
          prio: -1e4
        });
      } else {
        me.on({
          [eventName]: (...params) => {
            resolve(...params);
            if (options.resetLog) {
              me.clearLog(eventName);
            }
          },
          prio: -1e4,
          once: true
        });
      }
    });
  }
  clearLog(eventName) {
    if (this._triggered) {
      if (eventName) {
        delete this._triggered[eventName];
      } else {
        this._triggered = {};
      }
    }
  }
  trigger(eventName, param) {
    var _me$eventListeners, _me$eventListeners2, _me$bubbleEvents, _handlerPromises, _handlerPromises2;
    const me = this, name = eventName.toLowerCase(), {
      eventsSuspended,
      relayAllTargets,
      callOnFunctions
    } = me;
    let listeners = (_me$eventListeners = me.eventListeners) === null || _me$eventListeners === void 0 ? void 0 : _me$eventListeners[name], handlerPromises;
    if (!me._triggered) {
      me._triggered = {};
    }
    me._triggered[eventName] = true;
    if (eventsSuspended) {
      if (eventsSuspended.shouldQueue) {
        eventsSuspended.queue.push(arguments);
      }
      return true;
    }
    if ((_me$eventListeners2 = me.eventListeners) !== null && _me$eventListeners2 !== void 0 && _me$eventListeners2.catchall) {
      (listeners = listeners ? listeners.slice() : []).push(...me.eventListeners.catchall);
      listeners.sort(priorityComparator);
    }
    if (!listeners && !relayAllTargets && !callOnFunctions) {
      return true;
    }
    if (param) {
      if (!("source" in param)) {
        if (Object.isExtensible(param)) {
          param.source = me;
        } else {
          param = Object.setPrototypeOf({
            source: me
          }, param);
        }
      }
    } else {
      param = {
        source: me
      };
    }
    if (param.type !== name) {
      if (param.constructor !== Object) {
        Reflect.defineProperty(param, "type", {
          get: () => name
        });
      } else {
        param.type = name;
      }
    }
    if (!("bubbles" in param) && (_me$bubbleEvents = me.bubbleEvents) !== null && _me$bubbleEvents !== void 0 && _me$bubbleEvents[eventName]) {
      param.bubbles = me.bubbleEvents[eventName];
    }
    if (callOnFunctions) {
      const fnName = "on" + StringHelper.capitalize(eventName);
      if (fnName in me) {
        var _me$pluginFunctionCha;
        const result = me[fnName] ? me.callback(me[fnName], me, [param]) : true;
        let inhibit;
        if (Objects.isPromise(result)) {
          (handlerPromises || (handlerPromises = [])).push(result);
        } else {
          inhibit = result === false || inhibit;
        }
        if (!me.isDestroyed && hasOwnProperty$3.call(me, fnName) && !((_me$pluginFunctionCha = me.pluginFunctionChain) !== null && _me$pluginFunctionCha !== void 0 && _me$pluginFunctionCha[fnName])) {
          const myProto = Object.getPrototypeOf(me);
          if (fnName in myProto) {
            const result2 = myProto[fnName].call(me, param);
            if (Objects.isPromise(result2)) {
              (handlerPromises || (handlerPromises = [])).push(result2);
            } else {
              inhibit = result2 === false || inhibit;
            }
            if (me.isDestroyed) {
              return;
            }
          }
        }
        if (inhibit) {
          return false;
        }
      }
    }
    let ret;
    if (listeners) {
      let i = 0, internalAbort = false;
      listeners.$firing = true;
      for (i; i < listeners.length && !me.isDestroyed && !internalAbort; i++) {
        const listener = listeners[i];
        if (ret === false && !listener.$internal) {
          continue;
        }
        let handler, thisObj = listener.thisObj;
        if (!thisObj || !thisObj.isDestroyed) {
          listener.called = true;
          if (listener.once) {
            me.removeListener(name, listener);
          }
          if (typeof listener.fn === "string") {
            if (thisObj) {
              handler = thisObj[listener.fn];
            }
            if (!handler) {
              const result2 = me.resolveCallback(listener.fn);
              handler = result2.handler;
              thisObj = result2.thisObj;
            }
          } else {
            handler = listener.fn;
          }
          if (listener.buffer) {
            if (!listener.bufferFn) {
              const buffer = Number(listener.buffer);
              if (typeof buffer !== "number" || isNaN(buffer)) {
                throw new Error(`Incorrect type for buffer, got "${buffer}" (expected a Number)`);
              }
              listener.bufferFn = FunctionHelper.createBuffered(handler, buffer, thisObj, listener.args);
            }
            handler = listener.bufferFn;
          }
          if (listener.throttle) {
            const throttle = Number(listener.throttle);
            if (typeof throttle !== "number" || isNaN(throttle)) {
              throw new Error(`Incorrect type for throttle, got "${throttle}" (expected a Number)`);
            }
            if (!listener.throttledFn) {
              listener.throttledFn = FunctionHelper.createThrottled(handler, throttle, thisObj, listener.args);
            }
            handler = listener.throttledFn;
          }
          const result = handler.call(thisObj || me, ...listener.args || [], param);
          if (ret !== false) {
            ret = result;
          }
          if (listener.$internal && result === false) {
            internalAbort = true;
          }
          if (Objects.isPromise(result)) {
            result.$internal = listener.$internal;
            (handlerPromises || (handlerPromises = [])).push(result);
          }
        }
      }
      listeners.$firing = false;
      if (internalAbort) {
        return false;
      }
    }
    relayAllTargets === null || relayAllTargets === void 0 ? void 0 : relayAllTargets.forEach((config) => {
      let name2 = eventName;
      if (config.transformCase) {
        name2 = StringHelper.capitalize(name2);
      }
      if (config.prefix) {
        name2 = config.prefix + name2;
      }
      if (config.through.trigger(name2, param) === false) {
        return false;
      }
    });
    if (param.bubbles && me.owner && !me.owner.isDestroyed) {
      return me.owner.trigger(eventName, param);
    }
    handlerPromises = (_handlerPromises = handlerPromises) === null || _handlerPromises === void 0 ? void 0 : _handlerPromises.filter((p) => ret !== false || p.$internal);
    if ((_handlerPromises2 = handlerPromises) !== null && _handlerPromises2 !== void 0 && _handlerPromises2.length) {
      return new Promise((resolve) => {
        Promise.all(handlerPromises).then((promiseResults) => {
          const finalResult = !promiseResults.some((result) => result === false);
          resolve(finalResult);
        });
      });
    }
    return ret !== false;
  }
  suspendEvents(queue = false) {
    const eventsSuspended = this.eventsSuspended || (this.eventsSuspended = {
      shouldQueue: queue,
      queue: [],
      count: 0
    });
    eventsSuspended.count++;
  }
  resumeEvents() {
    const suspended = this.eventsSuspended;
    if (suspended) {
      if (--suspended.count === 0) {
        this.eventsSuspended = null;
        if (suspended.shouldQueue) {
          for (const queued of suspended.queue) {
            this.trigger(...queued);
          }
        }
      }
    }
    return !Boolean(this.eventsSuspended);
  }
};
var AsyncHelper = class {
  static animationFrame() {
    return new Promise((resolve) => {
      requestAnimationFrame(resolve);
    });
  }
  static sleep(millis) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, millis);
    });
  }
  static yield() {
    return Promise.resolve();
  }
};
AsyncHelper._$name = "AsyncHelper";
var paramValueRegExp = /^(\w+)=(.*)$/;
var parseParams = function(paramString) {
  const result = {}, params = paramString.split("&");
  for (const nameValuePair of params) {
    const [match, name, value] = paramValueRegExp.exec(nameValuePair), decodedName = decodeURIComponent(name), decodedValue = decodeURIComponent(value);
    if (match) {
      let paramValue = result[decodedName];
      if (paramValue) {
        if (!Array.isArray(paramValue)) {
          paramValue = result[decodedName] = [paramValue];
        }
        paramValue.push(decodedValue);
      } else {
        result[decodedName] = decodedValue;
      }
    }
  }
  return result;
};
var AjaxHelper = class {
  static get(url, options) {
    return this.fetch(url, options);
  }
  static post(url, payload, options = {}) {
    if (!(payload instanceof FormData) && !(typeof payload === "string")) {
      payload = JSON.stringify(payload);
      options.headers = options.headers || {};
      options.headers["Content-Type"] = options.headers["Content-Type"] || "application/json";
    }
    return this.fetch(url, Object.assign({
      method: "POST",
      body: payload
    }, options));
  }
  static fetch(url, options) {
    let controller;
    options = Objects.merge({}, AjaxHelper.DEFAULT_FETCH_OPTIONS, options);
    if (typeof AbortController !== "undefined") {
      controller = options.abortController = new AbortController();
      options.signal = controller.signal;
    }
    if (!("credentials" in options)) {
      options.credentials = "include";
    }
    if (options.queryParams) {
      const params = Object.entries(options.queryParams);
      if (params.length) {
        let paramsAdded = false;
        if (options.headers && options.addQueryParamsToBody === true) {
          const contentType = new Headers(options.headers).get("Content-Type");
          let bodyClass;
          switch (contentType) {
            case "application/x-www-form-urlencoded":
              bodyClass = URLSearchParams;
              break;
            case "multipart/form-data":
              bodyClass = FormData;
              break;
          }
          if (bodyClass) {
            const body = options.body || (options.body = new bodyClass());
            if (body instanceof bodyClass) {
              params.forEach(([key, value]) => body.set(key, value));
              paramsAdded = true;
            }
          }
        }
        if (!paramsAdded) {
          url += (url.includes("?") ? "&" : "?") + params.map(([param, value]) => `${param}=${encodeURIComponent(value)}`).join("&");
        }
      }
    }
    const promise = new Promise((resolve, reject) => {
      fetch(url, options).then((response) => {
        if (options.parseJson) {
          response.json().then((json) => {
            response.parsedJson = json;
            resolve(response);
          }).catch((error) => {
            response.parsedJson = null;
            response.error = error;
            reject(response);
          });
        } else {
          resolve(response);
        }
      }).catch((error) => {
        error.stack = promise.stack;
        reject(error);
      });
    });
    promise.stack = new Error().stack;
    promise.abort = function() {
      var _controller;
      (_controller = controller) === null || _controller === void 0 ? void 0 : _controller.abort();
    };
    return promise;
  }
  static mockUrl(url, response) {
    const me = this;
    (me.mockAjaxMap || (me.mockAjaxMap = {}))[url] = response;
    if (!AjaxHelper.originalFetch) {
      AjaxHelper.originalFetch = AjaxHelper.fetch;
      AjaxHelper.fetch = me.mockAjaxFetch.bind(me);
    }
  }
  static async mockAjaxFetch(url, options) {
    const urlAndParams = url.split("?");
    let result = this.mockAjaxMap[urlAndParams[0]], parsedJson = null;
    if (result) {
      if (typeof result === "function") {
        result = await result(urlAndParams[0], urlAndParams[1] && parseParams(urlAndParams[1]), options);
      }
      try {
        parsedJson = options.parseJson && JSON.parse(result.responseText);
      } catch (error) {
        parsedJson = null;
        result.error = error;
      }
      result = Object.assign({
        status: 200,
        ok: true,
        headers: new Headers(),
        statusText: "OK",
        url,
        parsedJson,
        text: () => new Promise((resolve) => {
          resolve(result.responseText);
        }),
        json: () => new Promise((resolve) => {
          resolve(parsedJson);
        })
      }, result);
      return new Promise(function(resolve, reject) {
        if (result.synchronous) {
          resolve(result);
        } else {
          setTimeout(function() {
            resolve(result);
          }, "delay" in result ? result.delay : 100);
        }
      });
    } else {
      return AjaxHelper.originalFetch(url, options);
    }
  }
};
_defineProperty(AjaxHelper, "DEFAULT_FETCH_OPTIONS", {});
AjaxHelper._$name = "AjaxHelper";
var LocaleHelper = class {
  static mergeLocales(...locales) {
    const result = {};
    locales.forEach((locale2) => {
      Object.keys(locale2).forEach((key) => {
        if (typeof locale2[key] === "object") {
          result[key] = _objectSpread2(_objectSpread2({}, result[key]), locale2[key]);
        } else {
          result[key] = locale2[key];
        }
      });
    });
    return result;
  }
  static trimLocale(locale2, toTrim) {
    const remove = (key, subKey) => {
      if (locale2[key]) {
        if (subKey) {
          if (locale2[key][subKey]) {
            delete locale2[key][subKey];
          }
        } else {
          delete locale2[key];
        }
      }
    };
    Object.keys(toTrim).forEach((key) => {
      if (Object.keys(toTrim[key]).length > 0) {
        Object.keys(toTrim[key]).forEach((subKey) => remove(key, subKey));
      } else {
        remove(key);
      }
    });
  }
  static normalizeLocale(nameOrConfig, config) {
    if (!nameOrConfig) {
      throw new Error(`"nameOrConfig" parameter can not be empty`);
    }
    if (typeof nameOrConfig === "string") {
      if (!config) {
        throw new Error(`"config" parameter can not be empty`);
      }
      if (config.locale) {
        config.name = nameOrConfig || config.name;
      } else {
        config.localeName = nameOrConfig;
      }
    } else {
      config = nameOrConfig;
    }
    let locale2 = {};
    if (config.name || config.locale) {
      locale2 = Object.assign({
        localeName: config.name
      }, config.locale);
      config.desc && (locale2.localeDesc = config.desc);
      config.code && (locale2.localeCode = config.code);
      config.path && (locale2.localePath = config.path);
    } else {
      if (!config.localeName) {
        throw new Error(`"config" parameter doesn't have "localeName" property`);
      }
      locale2 = Object.assign({}, config);
    }
    for (const key of ["name", "desc", "code", "path"]) {
      if (locale2[key]) {
        delete locale2[key];
      }
    }
    if (!locale2.localeName) {
      throw new Error(`Locale name can not be empty`);
    }
    return locale2;
  }
  static get locales() {
    return globalThis.bryntum.locales || {};
  }
  static set locales(locales) {
    globalThis.bryntum.locales = locales;
  }
  static get localeName() {
    return globalThis.bryntum.locale || "En";
  }
  static set localeName(localeName) {
    globalThis.bryntum.locale = localeName || LocaleHelper.localeName;
  }
  static get locale() {
    return LocaleHelper.localeName && this.locales[LocaleHelper.localeName] || this.locales.En || Object.values(this.locales)[0] || {
      localeName: "",
      localeDesc: "",
      localeCoode: ""
    };
  }
  static publishLocale(nameOrConfig, config) {
    const {
      locales
    } = globalThis.bryntum, locale2 = LocaleHelper.normalizeLocale(nameOrConfig, config), {
      localeName
    } = locale2;
    if (!locales[localeName] || config === true) {
      locales[localeName] = locale2;
    } else {
      locales[localeName] = this.mergeLocales(locales[localeName] || {}, locale2 || {});
    }
    return locales[localeName];
  }
};
_defineProperty(LocaleHelper, "skipLocaleIntegrityCheck", false);
globalThis.bryntum = globalThis.bryntum || {};
globalThis.bryntum.locales = globalThis.bryntum.locales || {};
LocaleHelper._$name = "LocaleHelper";
var LocaleManager = class extends Events(Base$1) {
  static get defaultConfig() {
    return {
      throwOnMissingLocale: VersionHelper.isTestEnv
    };
  }
  construct(...args) {
    const me = this;
    super.construct(...args);
    if (BrowserHelper.isBrowserEnv) {
      var _me$locale;
      const scriptTag = document.querySelector("script[data-default-locale]");
      if (scriptTag) {
        me.applyLocale(scriptTag.dataset.defaultLocale);
      } else if ((_me$locale = me.locale) !== null && _me$locale !== void 0 && _me$locale.localeName) {
        me.applyLocale(me.locale.localeName);
      }
    }
  }
  get locales() {
    return LocaleHelper.locales;
  }
  set locales(locales) {
    LocaleHelper.locales = locales;
  }
  set locale(nameOrConfig) {
    this.applyLocale(nameOrConfig);
  }
  get locale() {
    return LocaleHelper.locale;
  }
  registerLocale(nameOrConfig, config) {
    VersionHelper.deprecate("Core", "6.0.0", "LocaleManager.registerLocale deprecated, use LocaleHelper.publishLocale instead");
    LocaleHelper.publishLocale(nameOrConfig, config);
  }
  extendLocale(name, config) {
    VersionHelper.deprecate("Core", "6.0.0", "LocaleManager.extendLocale deprecated, use LocaleManager.applyLocale instead");
    const locale2 = LocaleHelper.publishLocale(name, config);
    return this.applyLocale(locale2, true);
  }
  applyLocale(nameOrConfig, config, ignoreError = false) {
    const me = this;
    let localeConfig;
    if (typeof nameOrConfig === "string") {
      if (typeof config !== "object") {
        localeConfig = me.locales[nameOrConfig];
        if (!localeConfig) {
          if (ignoreError) {
            return true;
          }
          throw new Error(`Locale "${nameOrConfig}" is not published. Publish with LocaleHelper.publishLocale() before applying.`);
        }
      } else {
        localeConfig = LocaleHelper.publishLocale(nameOrConfig, config);
      }
    } else {
      localeConfig = LocaleHelper.publishLocale(nameOrConfig);
    }
    if (me.locale.localeName && me.locale.localeName === localeConfig.localeName && config !== true) {
      return me.locale;
    }
    LocaleHelper.localeName = localeConfig.localeName;
    const triggerLocaleEvent = () => {
      me.trigger("locale", localeConfig);
    };
    if (localeConfig.localePath) {
      return new Promise((resolve, reject) => {
        me.loadLocale(localeConfig.localePath).then((response) => {
          response.text().then((text) => {
            const parseLocale = new Function(text);
            parseLocale();
            if (BrowserHelper.isBrowserEnv) {
              localeConfig = me.locales[localeConfig.localeName];
              if (localeConfig) {
                delete localeConfig.localePath;
              }
            }
            triggerLocaleEvent();
            resolve(localeConfig);
          });
        }).catch((response) => reject(response));
      });
    }
    triggerLocaleEvent();
    return localeConfig;
  }
  loadLocale(path) {
    return AjaxHelper.get(path);
  }
  set throwOnMissingLocale(value) {
    this._throwOnMissingLocale = value;
  }
  get throwOnMissingLocale() {
    return this._throwOnMissingLocale;
  }
};
var LocaleManagerSingleton = new LocaleManager();
var ObjectProto = Object.getPrototypeOf(Object);
var localeRe = /L{.*?}/g;
var capturelocaleRe = /L{(.*?)}/g;
var classMatchRe = /((.*?)\.)?(.+)/g;
var escape$1 = (txt) => txt.replace(/{(\d+)}/gm, "[[$1]]");
var unescape = (txt) => txt.replace(/\[\[(\d+)]]/gm, "{$1}");
var emptyObject$c = Object.freeze(/* @__PURE__ */ Object.create(null));
var Localizable = (Target) => class Localizable2 extends (Target || Base$1) {
  static get $name() {
    return "Localizable";
  }
  static get configurable() {
    return {
      localeClass: null,
      localizable: null,
      localizableProperties: {
        value: [],
        $config: {
          merge: "distinct"
        }
      }
    };
  }
  static clsName(cls) {
    var _cls$prototype, _cls$prototype2;
    return typeof cls === "string" ? cls : cls === ObjectProto ? "Object" : cls.$$name || cls.name || ((_cls$prototype = cls.prototype) === null || _cls$prototype === void 0 ? void 0 : _cls$prototype.$$name) || ((_cls$prototype2 = cls.prototype) === null || _cls$prototype2 === void 0 ? void 0 : _cls$prototype2.name);
  }
  static parseLocaleString(text) {
    var _text;
    const matches = [];
    let m;
    if ((_text = text) !== null && _text !== void 0 && _text.includes("L{")) {
      text = escape$1(text);
      capturelocaleRe.lastIndex = 0;
      while ((m = capturelocaleRe.exec(text)) != null) {
        classMatchRe.lastIndex = 0;
        const classMatch = classMatchRe.exec(m[1]);
        matches.push({
          match: unescape(m[0]),
          localeKey: unescape(classMatch[3]),
          localeClass: classMatch[2]
        });
      }
    }
    return matches.length > 0 ? matches : [{
      match: text,
      localeKey: text,
      localeClass: void 0
    }];
  }
  construct(config = {}, ...args) {
    super.construct(config, ...args);
    LocaleManagerSingleton.ion({
      locale: "updateLocalization",
      thisObj: this
    });
    this.updateLocalization();
  }
  get localeClass() {
    return this._localeClass || null;
  }
  localizeProperty(property) {
    var _me$$meta$configs$pro, _me$fieldMap, _me$fieldMap$property;
    const me = this, currentValue = Objects.getPath(me, property), localeKey = ((_me$$meta$configs$pro = me.$meta.configs[property]) === null || _me$$meta$configs$pro === void 0 ? void 0 : _me$$meta$configs$pro.localeKey) || ((_me$fieldMap = me.fieldMap) === null || _me$fieldMap === void 0 ? void 0 : (_me$fieldMap$property = _me$fieldMap[property]) === null || _me$fieldMap$property === void 0 ? void 0 : _me$fieldMap$property.defaultValue);
    let localizedValue;
    if (localeKey) {
      localizedValue = Localizable2.localize(localeKey, me, me.localeClass || me);
      if (localizedValue && !(property in (me.initialConfig || emptyObject$c))) {
        Objects.setPath(me.isColumn ? me.data : me, property, localizedValue);
      }
    } else if (typeof currentValue === "string") {
      me.originalLocales = me.originalLocales || {};
      localizedValue = Objects.getPath(me.originalLocales, property);
      if (localizedValue === void 0) {
        Objects.setPath(me.originalLocales, property, currentValue);
        localizedValue = currentValue;
      }
      if (localizedValue) {
        Objects.setPath(me, property, localizedValue = me.optionalL(localizedValue, me));
      }
    }
    return localizedValue || currentValue;
  }
  updateLocalization() {
    if (this.localizable !== false) {
      var _this$localizableProp, _this$trigger;
      (_this$localizableProp = this.localizableProperties) === null || _this$localizableProp === void 0 ? void 0 : _this$localizableProp.forEach(this.localizeProperty, this);
      (_this$trigger = this.trigger) === null || _this$trigger === void 0 ? void 0 : _this$trigger.call(this, "localized");
    }
  }
  static getTranslation(text, templateData, localeCls) {
    const locale2 = LocaleManagerSingleton.locale;
    let result = null, clsName, cls;
    if (locale2) {
      for (const {
        match,
        localeKey,
        localeClass
      } of this.parseLocaleString(text)) {
        const translate = (clsName2) => {
          var _locale$clsName;
          const translation = (_locale$clsName = locale2[clsName2]) === null || _locale$clsName === void 0 ? void 0 : _locale$clsName[localeKey];
          if (translation) {
            if (typeof translation === "function") {
              result = templateData != null ? translation(templateData) : translation;
            } else if (typeof translation === "object" || text === match) {
              result = translation;
            } else {
              result = (result || text).replace(match, translation);
            }
            if (typeof translation === "string" && translation.includes("L{")) {
              result = this.getTranslation(translation, templateData, localeCls);
            }
          }
          return translation;
        };
        let success2 = false;
        for (cls = localeCls; cls && (clsName = Localizable2.clsName(cls)); cls = Object.getPrototypeOf(cls)) {
          if (success2 = translate(clsName)) {
            break;
          } else if (typeof cls === "string") {
            break;
          }
        }
        if (!success2 && localeClass) {
          translate(localeClass);
        }
      }
    }
    return result;
  }
  static localize(text, templateData = void 0, ...localeClasses) {
    var _localeClasses;
    if (((_localeClasses = localeClasses) === null || _localeClasses === void 0 ? void 0 : _localeClasses.length) === 0) {
      localeClasses = [this];
    }
    let translation = null;
    localeClasses.some((cls) => {
      translation = Localizable2.getTranslation(text, templateData, cls);
      return translation != null;
    });
    return translation;
  }
  static L(text, templateData = void 0, ...localeClasses) {
    var _localeClasses2;
    if (((_localeClasses2 = localeClasses) === null || _localeClasses2 === void 0 ? void 0 : _localeClasses2.length) === 0) {
      localeClasses = [this];
    }
    const translation = this.localize(text, templateData, ...localeClasses);
    if (translation == null && LocaleManagerSingleton.throwOnMissingLocale && text.includes("L{")) {
      throw new Error(`Localization is not found for '${text}' in '${localeClasses.map((cls) => Localizable2.clsName(cls)).join(", ")}'. ${LocaleManagerSingleton.locale.localeName ? `Locale : ${LocaleManagerSingleton.locale.localeName}` : ""}`);
    }
    return translation !== null && translation !== void 0 ? translation : text;
  }
  L(text, templateData) {
    const {
      localeClass,
      constructor
    } = this;
    if (localeClass && Localizable2.clsName(localeClass) !== Localizable2.clsName(constructor)) {
      return Localizable2.L(text, templateData, localeClass, constructor);
    } else {
      return Localizable2.L(text, templateData, constructor);
    }
  }
  static optionalL(text, templateData = void 0, ...localeClasses) {
    var _localeClasses3;
    const shouldThrow = LocaleManagerSingleton.throwOnMissingLocale;
    LocaleManagerSingleton.throwOnMissingLocale = shouldThrow && localeRe.test(text);
    if (((_localeClasses3 = localeClasses) === null || _localeClasses3 === void 0 ? void 0 : _localeClasses3.length) === 0) {
      localeClasses = [this];
    }
    const result = Localizable2.L(text, templateData, ...localeClasses);
    LocaleManagerSingleton.throwOnMissingLocale = shouldThrow;
    return result;
  }
  optionalL(text, templateData = this, preventThrow = false) {
    const shouldThrow = LocaleManagerSingleton.throwOnMissingLocale;
    LocaleManagerSingleton.throwOnMissingLocale = shouldThrow && localeRe.test(text) && !preventThrow;
    const result = this.L(text, templateData);
    LocaleManagerSingleton.throwOnMissingLocale = shouldThrow;
    return result;
  }
  get localeManager() {
    return LocaleManagerSingleton;
  }
  get localeHelper() {
    return LocaleHelper;
  }
};
var locale$4 = {
  localeName: "En",
  localeDesc: "English (US)",
  localeCode: "en-US",
  Object: {
    Yes: "Yes",
    No: "No",
    Cancel: "Cancel",
    Ok: "OK",
    Week: "Week"
  },
  Combo: {
    noResults: "No results",
    recordNotCommitted: "Record could not be added",
    addNewValue: (value) => `Add ${value}`
  },
  FilePicker: {
    file: "File"
  },
  Field: {
    badInput: "Invalid field value",
    patternMismatch: "Value should match a specific pattern",
    rangeOverflow: (value) => `Value must be less than or equal to ${value.max}`,
    rangeUnderflow: (value) => `Value must be greater than or equal to ${value.min}`,
    stepMismatch: "Value should fit the step",
    tooLong: "Value should be shorter",
    tooShort: "Value should be longer",
    typeMismatch: "Value is required to be in a special format",
    valueMissing: "This field is required",
    invalidValue: "Invalid field value",
    minimumValueViolation: "Minimum value violation",
    maximumValueViolation: "Maximum value violation",
    fieldRequired: "This field is required",
    validateFilter: "Value must be selected from the list"
  },
  DateField: {
    invalidDate: "Invalid date input"
  },
  DatePicker: {
    gotoPrevYear: "Go to previous year",
    gotoPrevMonth: "Go to previous month",
    gotoNextMonth: "Go to next month",
    gotoNextYear: "Go to next year"
  },
  NumberFormat: {
    locale: "en-US",
    currency: "USD"
  },
  DurationField: {
    invalidUnit: "Invalid unit"
  },
  TimeField: {
    invalidTime: "Invalid time input"
  },
  TimePicker: {
    hour: "Hour",
    minute: "Minute",
    second: "Second"
  },
  List: {
    loading: "Loading..."
  },
  GridBase: {
    loadMask: "Loading...",
    syncMask: "Saving changes, please wait..."
  },
  PagingToolbar: {
    firstPage: "Go to first page",
    prevPage: "Go to previous page",
    page: "Page",
    nextPage: "Go to next page",
    lastPage: "Go to last page",
    reload: "Reload current page",
    noRecords: "No records to display",
    pageCountTemplate: (data) => `of ${data.lastPage}`,
    summaryTemplate: (data) => `Displaying records ${data.start} - ${data.end} of ${data.allCount}`
  },
  PanelCollapser: {
    Collapse: "Collapse",
    Expand: "Expand"
  },
  Popup: {
    close: "Close"
  },
  UndoRedo: {
    Undo: "Undo",
    Redo: "Redo",
    UndoLastAction: "Undo last action",
    RedoLastAction: "Redo last undone action",
    NoActions: "No items in the undo queue"
  },
  FieldFilterPicker: {
    equals: "equals",
    doesNotEqual: "does not equal",
    isEmpty: "is empty",
    isNotEmpty: "is not empty",
    contains: "contains",
    doesNotContain: "does not contain",
    startsWith: "starts with",
    endsWith: "ends with",
    isOneOf: "is one of",
    isNotOneOf: "is not one of",
    isGreaterThan: "is greater than",
    isLessThan: "is less than",
    isGreaterThanOrEqualTo: "is greater than or equal to",
    isLessThanOrEqualTo: "is less than or equal to",
    isBetween: "is between",
    isNotBetween: "is not between",
    isBefore: "is before",
    isAfter: "is after",
    isToday: "is today",
    isTomorrow: "is tomorrow",
    isYesterday: "is yesterday",
    isThisWeek: "is this week",
    isNextWeek: "is next week",
    isLastWeek: "is last week",
    isThisMonth: "is this month",
    isNextMonth: "is next month",
    isLastMonth: "is last month",
    isThisYear: "is this year",
    isNextYear: "is next year",
    isLastYear: "is last year",
    isYearToDate: "is year to date",
    isTrue: "is true",
    isFalse: "is false",
    selectAProperty: "Select a property",
    selectAnOperator: "Select an operator",
    caseSensitive: "Case-sensitive",
    and: "and",
    dateFormat: "D/M/YY",
    selectOneOrMoreValues: "Select one or more values",
    enterAValue: "Enter a value",
    enterANumber: "Enter a number",
    selectADate: "Select a date"
  },
  FieldFilterPickerGroup: {
    addFilter: "Add filter"
  },
  DateHelper: {
    locale: "en-US",
    weekStartDay: 0,
    nonWorkingDays: {
      0: true,
      6: true
    },
    weekends: {
      0: true,
      6: true
    },
    unitNames: [{
      single: "millisecond",
      plural: "ms",
      abbrev: "ms"
    }, {
      single: "second",
      plural: "seconds",
      abbrev: "s"
    }, {
      single: "minute",
      plural: "minutes",
      abbrev: "min"
    }, {
      single: "hour",
      plural: "hours",
      abbrev: "h"
    }, {
      single: "day",
      plural: "days",
      abbrev: "d"
    }, {
      single: "week",
      plural: "weeks",
      abbrev: "w"
    }, {
      single: "month",
      plural: "months",
      abbrev: "mon"
    }, {
      single: "quarter",
      plural: "quarters",
      abbrev: "q"
    }, {
      single: "year",
      plural: "years",
      abbrev: "yr"
    }, {
      single: "decade",
      plural: "decades",
      abbrev: "dec"
    }],
    unitAbbreviations: [["mil"], ["s", "sec"], ["m", "min"], ["h", "hr"], ["d"], ["w", "wk"], ["mo", "mon", "mnt"], ["q", "quar", "qrt"], ["y", "yr"], ["dec"]],
    parsers: {
      L: "MM/DD/YYYY",
      LT: "HH:mm A",
      LTS: "HH:mm:ss A"
    },
    ordinalSuffix: (number) => {
      const hasSpecialCase = ["11", "12", "13"].find((n) => number.endsWith(n));
      let suffix = "th";
      if (!hasSpecialCase) {
        const lastDigit = number[number.length - 1];
        suffix = {
          1: "st",
          2: "nd",
          3: "rd"
        }[lastDigit] || "th";
      }
      return number + suffix;
    }
  }
};
LocaleHelper.publishLocale(locale$4);
var {
  toString: toString$1
} = Object.prototype;
var DATE_TYPE = toString$1.call(new Date());
var tempDate$1 = new Date();
var MS_PER_HOUR = 1e3 * 60 * 60;
var defaultValue = (value, defValue) => isNaN(value) || value == null ? defValue : value;
var rangeFormatPartRe = /([ES]){([^}]+)}/g;
var enOrdinalSuffix = (number) => {
  const hasSpecialCase = ["11", "12", "13"].find((n) => number.endsWith(n));
  let suffix = "th";
  if (!hasSpecialCase) {
    const lastDigit = number[number.length - 1];
    suffix = {
      1: "st",
      2: "nd",
      3: "rd"
    }[lastDigit] || "th";
  }
  return number + suffix;
};
var useIntlFormat = (name, options, date2) => {
  const formatter = intlFormatterCache[name] || (intlFormatterCache[name] = new Intl.DateTimeFormat(locale$3, options));
  return formatter.format(date2);
};
var formatTime = (name, options, date2, isShort = false) => {
  let strTime = useIntlFormat(name, options, date2);
  if (/am|pm/i.test(strTime)) {
    strTime = strTime.replace(/^0/, "");
    if (isShort) {
      strTime = strTime.replace(/:00/, "");
    }
  }
  return strTime;
};
var getDayDiff = (end, start) => Math.floor((end.getTime() - start.getTime() - (end.getTimezoneOffset() - start.getTimezoneOffset()) * validConversions.minute.millisecond) / validConversions.day.millisecond) + 1;
var normalizeDay = (day2) => day2 >= 0 ? day2 : day2 + 7;
var msRegExp = /([^\w])(S+)/gm;
var msReplacer = (match, g1, g2) => g1 + "SSS";
var locale$3 = "en-US";
var ordinalSuffix = enOrdinalSuffix;
var formatCache = {};
var formatRedirects = {};
var intlFormatterCache = {};
var parserCache = {};
var redirectFormat = (format2) => {
  const intlConfig = intlFormatConfigs[format2];
  if (!intlConfig) {
    throw new Error("Only international formats should be used here");
  }
  if (formatRedirects[format2] !== void 0) {
    return formatRedirects[format2];
  }
  const intl = new Intl.DateTimeFormat(locale$3, intlConfig), fmt = intl.formatToParts(new Date(2001, 1, 2, 3, 4, 5, 6)).map((part) => {
    const type = part.type, intlCfg = intlConfig[type];
    if (type === "literal") {
      return part.value.replace(/,/g, "");
    } else if (type === "day") {
      return intlCfg === "numeric" ? "D" : "DD";
    } else if (type === "month") {
      return intlCfg === "short" ? "MMM" : intlCfg === "long" ? "MMMM" : intlCfg === "numeric" ? "M" : "MM";
    } else if (type === "year") {
      return intlCfg === "numeric" ? "YYYY" : "YY";
    }
  }).join("");
  return formatRedirects[format2] = fmt;
};
var DEFAULT_YEAR = 2020;
var DEFAULT_MONTH = 0;
var DEFAULT_DAY = 1;
var intlFormatConfigs = {
  l: {
    year: "numeric",
    month: "numeric",
    day: "numeric"
  },
  ll: {
    year: "numeric",
    month: "short",
    day: "numeric"
  }
};
var formats = {
  M: (date2) => date2.getMonth() + 1,
  Mo: (date2) => ordinalSuffix(formats.M(date2).toString()),
  MM: (date2) => (date2.getMonth() + 1).toString().padStart(2, "0"),
  MMM: (date2) => useIntlFormat("MMM", {
    month: "short"
  }, date2),
  MMMM: (date2) => useIntlFormat("MMMM", {
    month: "long"
  }, date2),
  Q: (date2) => Math.ceil((date2.getMonth() + 1) / 3),
  Qo: (date2) => ordinalSuffix(formats.Q(date2).toString()),
  D: (date2) => date2.getDate(),
  Do: (date2) => ordinalSuffix(formats.D(date2).toString()),
  DD: (date2) => date2.getDate().toString().padStart(2, "0"),
  DDD: (date2) => Math.ceil((new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), 12, 0, 0) - new Date(date2.getFullYear(), 0, 0, 12, 0, 0)) / validConversions.day.millisecond),
  DDDo: (date2) => ordinalSuffix(formats.DDD(date2).toString()),
  DDDD: (date2) => formats.DDD(date2).toString().padStart(3, "0"),
  d: (date2) => date2.getDay(),
  do: (date2) => ordinalSuffix(date2.getDay().toString()),
  d1: (date2) => useIntlFormat("d1", {
    weekday: "narrow"
  }, date2).substr(0, 1),
  dd: (date2) => formats.ddd(date2).substring(0, 2),
  ddd: (date2) => useIntlFormat("ddd", {
    weekday: "short"
  }, date2),
  dddd: (date2) => useIntlFormat("dddd", {
    weekday: "long"
  }, date2),
  u: (date2) => {
    const formatter = intlFormatterCache.u || (intlFormatterCache.u = new Intl.DateTimeFormat("en-GB", {
      timeZone: "UTC",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    })), parts = formatter.formatToParts(date2);
    return `${parts[4].value}${parts[2].value}${parts[0].value}Z`;
  },
  uu: (date2) => {
    const formatter = intlFormatterCache.uu || (intlFormatterCache.uu = new Intl.DateTimeFormat("en-GB", {
      timeZone: "UTC",
      hour12: false,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    })), parts = formatter.formatToParts(date2);
    return `${parts[4].value}${parts[2].value}${parts[0].value}T${parts[6].value}${parts[8].value}${parts[10].value}Z`;
  },
  e: (date2) => date2.getDay(),
  E: (date2) => date2.getDay() + 1,
  W: (date2) => DateHelper.getWeekNumber(date2)[1],
  Wo: (date2) => ordinalSuffix(formats.W(date2).toString()),
  WW: (date2) => formats.W(date2).toString().padStart(2, "0"),
  Wp: (date2) => `${DateHelper.localize("L{Week}")} ${formats.W(date2)}`,
  WWp: (date2) => `${DateHelper.localize("L{Week}")} ${formats.WW(date2)}`,
  Wp0: (date2) => `${DateHelper.localize("L{Week}")[0]}${formats.W(date2)}`,
  WWp0: (date2) => `${DateHelper.localize("L{Week}")[0]}${formats.WW(date2)}`,
  Y: (date2) => date2.getFullYear(),
  YY: (date2) => date2.getFullYear() % 100,
  YYYY: (date2) => date2.getFullYear(),
  A: (date2) => date2.getHours() < 12 ? "AM" : "PM",
  a: (date2) => date2.getHours() < 12 ? "am" : "pm",
  H: (date2) => date2.getHours(),
  HH: (date2) => date2.getHours().toString().padStart(2, "0"),
  h: (date2) => date2.getHours() % 12 || 12,
  hh: (date2) => formats.h(date2).toString().padStart(2, "0"),
  k: (date2) => date2.getHours() || 24,
  kk: (date2) => formats.k(date2).toString().padStart(2, "0"),
  K: (date2) => formatTime("K", {
    hour: "numeric"
  }, date2),
  KK: (date2) => formatTime("KK", {
    hour: "2-digit"
  }, date2),
  m: (date2) => date2.getMinutes(),
  mm: (date2) => formats.m(date2).toString().padStart(2, "0"),
  s: (date2) => date2.getSeconds(),
  ss: (date2) => formats.s(date2).toString().padStart(2, "0"),
  S: (date2) => Math.floor(date2.getMilliseconds() / 100).toString(),
  SS: (date2) => Math.floor(date2.getMilliseconds() / 10).toString().padStart(2, "0"),
  SSS: (date2) => date2.getMilliseconds().toString().padStart(3, "0"),
  z: (date2) => useIntlFormat("z", {
    timeZoneName: "short"
  }, date2),
  zz: (date2) => useIntlFormat("zz", {
    timeZoneName: "long"
  }, date2),
  Z: (date2) => DH$2.getGMTOffset(date2),
  LT: (date2) => formatTime("LT", {
    hour: "2-digit",
    minute: "2-digit"
  }, date2),
  LST: (date2) => formatTime("LST", {
    hour: "numeric",
    minute: "2-digit"
  }, date2, true),
  LTS: (date2) => formatTime("LTS", {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit"
  }, date2),
  L: (date2) => useIntlFormat("L", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit"
  }, date2),
  l: (date2) => useIntlFormat("l", intlFormatConfigs.l, date2),
  LL: (date2) => useIntlFormat("LL", {
    year: "numeric",
    month: "long",
    day: "numeric"
  }, date2),
  ll: (date2) => useIntlFormat("ll", intlFormatConfigs.ll, date2),
  LLL: (date2) => useIntlFormat("LLL", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit"
  }, date2),
  lll: (date2) => useIntlFormat("lll", {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit"
  }, date2),
  LLLL: (date2) => useIntlFormat("LLLL", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    weekday: "long"
  }, date2),
  llll: (date2) => useIntlFormat("llll", {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    weekday: "short"
  }, date2)
};
var formatKeys = Object.keys(formats).sort((a, b) => b.length - a.length);
var formatRegexp = `^(?:${formatKeys.join("|")})`;
var emptyFn$1 = () => ({});
var isNumber = (str) => numberRegex.test(str);
var parseMilliseconds = (str) => isNumber(str) && {
  milliseconds: parseInt(str.padEnd(3, "0").substring(0, 3))
};
var parsers = {
  YYYY: (str) => {
    const year = parseInt(str);
    return {
      year: year >= 1e3 && year <= 9999 ? year : NaN
    };
  },
  Y: (str) => ({
    year: parseInt(str)
  }),
  YY: (str) => {
    const year = parseInt(str);
    return {
      year: year + (year > 1968 ? 1900 : 2e3)
    };
  },
  M: (str) => ({
    month: parseInt(str) - 1
  }),
  MM: (str) => ({
    month: parseInt(str) - 1
  }),
  Mo: (str) => ({
    month: parseInt(str) - 1
  }),
  MMM: (str) => {
    const month2 = (str || "").toLowerCase();
    for (const [name, entry] of Object.entries(DateHelper._monthShortNamesIndex)) {
      if (month2.startsWith(name)) {
        return {
          month: entry.value
        };
      }
    }
  },
  MMMM: emptyFn$1,
  DD: (str) => ({
    date: parseInt(str)
  }),
  D: (str) => ({
    date: parseInt(str)
  }),
  Do: (str) => ({
    date: parseInt(str)
  }),
  DDD: emptyFn$1,
  DDDo: emptyFn$1,
  DDDD: emptyFn$1,
  d: emptyFn$1,
  do: emptyFn$1,
  d1: emptyFn$1,
  dd: emptyFn$1,
  ddd: emptyFn$1,
  dddd: emptyFn$1,
  Q: emptyFn$1,
  Qo: emptyFn$1,
  W: emptyFn$1,
  Wo: emptyFn$1,
  WW: emptyFn$1,
  e: emptyFn$1,
  E: emptyFn$1,
  HH: (str) => ({
    hours: parseInt(str)
  }),
  hh: (str) => ({
    hours: parseInt(str)
  }),
  mm: (str) => ({
    minutes: parseInt(str)
  }),
  H: (str) => ({
    hours: parseInt(str)
  }),
  m: (str) => ({
    minutes: parseInt(str)
  }),
  ss: (str) => ({
    seconds: parseInt(str)
  }),
  s: (str) => ({
    seconds: parseInt(str)
  }),
  S: parseMilliseconds,
  SS: parseMilliseconds,
  SSS: parseMilliseconds,
  A: (str) => ({
    amPm: str.toLowerCase()
  }),
  a: (str) => ({
    amPm: str.toLowerCase()
  }),
  L: "MM/DD/YYYY",
  LT: "HH:mm A",
  LTS: "HH:mm:ss A",
  l: {
    type: "dynamic",
    parser: () => redirectFormat("l")
  },
  ll: {
    type: "dynamic",
    parser: () => redirectFormat("ll")
  },
  Z: (str) => {
    if (!str || !timeZoneRegEx.test(str) && str !== "Z") {
      return null;
    }
    let timeZone = 0;
    if (str !== "Z") {
      const matches = timeZoneRegEx.exec(str);
      if (matches) {
        const sign = matches[1] === "+" ? 1 : -1, hours = parseInt(matches[2]) || 0, minutes = parseInt(matches[3]) || 0;
        timeZone = sign * (hours * 60 + minutes);
      } else {
        timeZone = -1 * new Date().getTimezoneOffset();
      }
    }
    return {
      timeZone
    };
  }
};
var parserKeys = Object.keys(parsers).sort((a, b) => b.length - a.length);
var parserRegexp = new RegExp(`(${parserKeys.join("|")})`);
var localeStrRegExp = new RegExp("^(LL|LLL|lll|LLLL|llll)$");
var validConversions = {
  decade: {
    decade: 1,
    year: 10,
    quarter: 40,
    month: 120,
    week: 520,
    day: 3652,
    hour: 24 * 3652,
    minute: 1440 * 3652,
    second: 86400 * 3652,
    millisecond: 864e5 * 3652
  },
  year: {
    decade: 0.1,
    year: 1,
    quarter: 4,
    month: 12,
    week: 52,
    day: 365,
    hour: 24 * 365,
    minute: 1440 * 365,
    second: 86400 * 365,
    millisecond: 864e5 * 365
  },
  quarter: {
    decade: 1 / 40,
    year: 1 / 4,
    quarter: 1,
    month: 3,
    week: 4,
    day: 91,
    hour: 24 * 91,
    minute: 1440 * 91,
    second: 86400 * 91,
    millisecond: 864e5 * 91
  },
  month: {
    decade: 1 / 120,
    year: 1 / 12,
    quarter: 1 / 3,
    month: 1,
    week: 4,
    day: -30,
    hour: -24 * 30,
    minute: -1440 * 30,
    second: -86400 * 30,
    millisecond: -864e5 * 30
  },
  week: {
    decade: -1 / 520,
    year: -1 / 52,
    quarter: -1 / 13,
    month: -1 / 4,
    day: 7,
    hour: 168,
    minute: 10080,
    second: 604800,
    millisecond: 6048e5
  },
  day: {
    decade: -1 / 3652,
    year: -1 / 365,
    quarter: -1 / 91,
    month: -1 / 30,
    week: 1 / 7,
    hour: 24,
    minute: 1440,
    second: 86400,
    millisecond: 864e5
  },
  hour: {
    decade: -1 / (3652 * 24),
    year: -1 / (365 * 24),
    quarter: -1 / (91 * 24),
    month: -1 / (30 * 24),
    week: 1 / 168,
    day: 1 / 24,
    minute: 60,
    second: 3600,
    millisecond: 36e5
  },
  minute: {
    decade: -1 / (3652 * 1440),
    year: -1 / (365 * 1440),
    quarter: -1 / (91 * 1440),
    month: -1 / (30 * 1440),
    week: 1 / 10080,
    day: 1 / 1440,
    hour: 1 / 60,
    second: 60,
    millisecond: 6e4
  },
  second: {
    decade: -1 / (3652 * 86400),
    year: -1 / (365 * 86400),
    quarter: -1 / (91 * 86400),
    month: -1 / (30 * 86400),
    week: 1 / 604800,
    day: 1 / 86400,
    hour: 1 / 3600,
    minute: 1 / 60,
    millisecond: 1e3
  },
  millisecond: {
    decade: -1 / (3652 * 864e5),
    year: -1 / (365 * 864e5),
    quarter: -1 / (91 * 864e5),
    month: -1 / (30 * 864e5),
    week: 1 / 6048e5,
    day: 1 / 864e5,
    hour: 1 / 36e5,
    minute: 1 / 6e4,
    second: 1 / 1e3
  }
};
var normalizedUnits = {
  ms: "millisecond",
  milliseconds: "millisecond",
  s: "second",
  seconds: "second",
  m: "minute",
  mi: "minute",
  min: "minute",
  minutes: "minute",
  h: "hour",
  hours: "hour",
  d: "day",
  days: "day",
  w: "week",
  weeks: "week",
  M: "month",
  mo: "month",
  mon: "month",
  months: "month",
  q: "quarter",
  quarters: "quarter",
  y: "year",
  years: "year",
  dec: "decade",
  decades: "decade"
};
var withDecimalsDurationRegex = /^\s*([-+]?\d+(?:[.,]\d*)?|[-+]?(?:[.,]\d+))\s*([^\s]+)?/i;
var noDecimalsDurationRegex = /^\s*([-+]?\d+)(?![.,])\s*([^\s]+)?/i;
var canonicalUnitNames = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year", "decade"];
var canonicalUnitAbbreviations = [["mil"], ["s", "sec"], ["m", "min"], ["h", "hr"], ["d"], ["w", "wk"], ["mo", "mon", "mnt"], ["q", "quar", "qrt"], ["y", "yr"], ["dec"]];
var deltaUnits = ["decade", "year", "month", "week", "day", "hour", "minute", "second", "millisecond"];
var dateProperties = ["milliseconds", "seconds", "minutes", "hours", "date", "month", "year"];
var parseNumber = (n) => {
  const result = parseFloat(n);
  return isNaN(result) ? null : result;
};
var numberRegex = /^[0-9]+$/;
var timeZoneRegEx = /([+-])(\d\d):*(\d\d)*$/;
var unitMagnitudes = {
  millisecond: 0,
  second: 1,
  minute: 2,
  hour: 3,
  day: 4,
  week: 5,
  month: 6,
  quarter: 7,
  year: 8,
  decade: 9
};
var snapFns = {
  round(number, step = 1) {
    return Math.round(number / step) * step;
  },
  floor(number, step = 1) {
    return Math.floor(number / step) * step;
  },
  ceil(number, step = 1) {
    return Math.ceil(number / step) * step;
  }
};
var keyCache = {};
var DateHelper = class extends Localizable() {
  static get $name() {
    return "DateHelper";
  }
  static set defaultFormat(format2) {
    DH$2._defaultFormat = format2;
  }
  static get defaultFormat() {
    return DH$2._defaultFormat || "YYYY-MM-DDTHH:mm:ssZ";
  }
  static set defaultParseFormat(parseFormat) {
    this._defaultParseFormat = parseFormat;
  }
  static get defaultParseFormat() {
    return this._defaultParseFormat || this._defaultFormat || "YYYY-MM-DDTHH:mm:ss.SSSZ";
  }
  static buildParser(format2) {
    const parts = format2.split(parserRegexp), parser = [];
    if (parts.length === 1 || localeStrRegExp.test(format2)) {
      return [];
    } else {
      parts.reduce((prev, curr, index, array) => {
        if (index !== 0 || curr !== "") {
          if (parserRegexp.test(curr)) {
            const localeParsers = this.localize("L{parsers}") || {}, fn2 = localeParsers[curr] || parsers[curr];
            if (curr === "Z" && index < array.length - 2) {
              throw new Error(`Invalid format ${format2} TimeZone (Z) must be last token`);
            }
            const parserObj = typeof fn2 === "function" || typeof fn2 === "string" ? fn2 : fn2.parser();
            if (typeof parserObj === "string") {
              const nestedParsers = DH$2.buildParser(parserObj), lastItem = nestedParsers.pop();
              delete lastItem.last;
              parser.push(...nestedParsers);
              prev = lastItem;
            } else {
              prev.pattern = curr;
              prev.fn = parserObj;
            }
          } else {
            prev.splitter = curr;
            parser.push(prev);
            prev = {};
          }
        } else if (Object.prototype.hasOwnProperty.call(prev, "pattern")) {
          parser.push(prev);
        }
        return prev;
      }, {});
    }
    parser[parser.length - 1].last = true;
    return parser;
  }
  static makeKey(ms) {
    if (ms.length === 10) {
      return ms;
    }
    if (ms.getTime) {
      ms = ms.getTime();
    }
    const cached = keyCache[Math.trunc(ms / MS_PER_HOUR)];
    if (cached) {
      return cached;
    }
    tempDate$1.setTime(ms);
    const month2 = tempDate$1.getMonth() + 1, date2 = tempDate$1.getDate();
    return keyCache[Math.trunc(ms / MS_PER_HOUR)] = `${tempDate$1.getFullYear()}-${month2 < 10 ? "0" + month2 : month2}-${date2 < 10 ? "0" + date2 : date2}`;
  }
  static parseKey(key) {
    return DH$2.parse(key, "YYYY-MM-DD");
  }
  static parse(dateString, format2 = DH$2.defaultParseFormat, strict = false) {
    if (dateString instanceof Date) {
      return dateString;
    }
    if (typeof dateString !== "string" || !dateString) {
      return null;
    }
    const config = {
      year: null,
      month: null,
      date: null,
      hours: null,
      minutes: null,
      seconds: null,
      milliseconds: null
    };
    format2 = format2.replace(msRegExp, msReplacer);
    let parser = parserCache[format2], result;
    if (!parser) {
      parser = parserCache[format2] = DH$2.buildParser(format2);
    }
    if (dateString.includes("\u202F")) {
      dateString = dateString.replace(/\s/g, " ");
    }
    parser.reduce((dateString2, parser2) => {
      if (parser2.last) {
        Object.assign(config, parser2.fn(dateString2));
      } else {
        let splitAt;
        if (parser2.splitter === "T" && dateString2.indexOf("T") === -1) {
          splitAt = dateString2.indexOf(" ");
        } else {
          splitAt = parser2.splitter !== "" ? dateString2.indexOf(parser2.splitter) : parser2.pattern && parser2.pattern.length || -1;
        }
        let part, rest;
        if (splitAt === -1 || parser2.pattern === "SSS" && dateString2.match(/^\d+Z$/)) {
          const chunks = dateString2.split(/([Z\-+])/);
          if (chunks.length === 1) {
            part = dateString2;
            rest = "";
          } else {
            part = chunks[0];
            rest = `${chunks[1]}${chunks[2]}`;
          }
        } else {
          part = dateString2.substring(0, splitAt) || dateString2;
          rest = dateString2.substring(splitAt + parser2.splitter.length);
        }
        if (parser2.fn) {
          const res = parser2.fn(part);
          if (res) {
            Object.assign(config, res);
          } else {
            rest = part + rest;
          }
        }
        return rest;
      }
    }, dateString);
    if (config.year && !config.date) {
      config.date = 1;
    }
    const date2 = DH$2.create(config, strict);
    if (date2) {
      result = date2;
    } else if (!strict) {
      result = new Date(dateString);
    }
    return result;
  }
  static create(definition, strict = false) {
    const def = _objectSpread2({}, definition);
    let invalid = isNaN(def.year), useUTC = false;
    if (!invalid) {
      let allNull = true;
      dateProperties.forEach((property) => {
        if (!(property in def) || isNaN(def[property])) {
          def[property] = 0;
        }
        allNull = allNull && def[property] === null;
      });
      invalid = allNull;
    }
    if (def.amPm === "am") {
      def.hours = def.hours % 12;
    } else if (def.amPm === "pm") {
      def.hours = def.hours % 12 + 12;
    }
    if ("timeZone" in def) {
      useUTC = true;
      def.minutes -= def.timeZone;
    }
    if (invalid) {
      return null;
    }
    if (strict && (def.year == null || def.month == null || def.date == null)) {
      return null;
    }
    const args = [defaultValue(def.year, DEFAULT_YEAR), defaultValue(def.month, DEFAULT_MONTH), defaultValue(def.date, DEFAULT_DAY), def.hours, def.minutes, def.seconds, def.milliseconds];
    return useUTC ? new Date(Date.UTC(...args)) : new Date(...args);
  }
  static toUTC(date2) {
    return new Date(Date.UTC(date2.getUTCFullYear(), date2.getUTCMonth(), date2.getUTCDate(), date2.getUTCHours(), date2.getUTCMinutes(), date2.getUTCSeconds(), date2.getUTCMilliseconds()));
  }
  static format(date2, format2 = DH$2.defaultFormat) {
    if (!date2 || isNaN(date2)) {
      return null;
    }
    let formatter = formatCache[format2], output = "";
    if (!formatter) {
      formatter = formatCache[format2] = [];
      for (let i = 0; i < format2.length; i++) {
        const formatMatch = format2.slice(i).match(formatRegexp), predefined = formatMatch === null || formatMatch === void 0 ? void 0 : formatMatch[0];
        if (predefined) {
          const localeFormats = this.localize("L{formats}") || {}, fn2 = localeFormats[predefined] || formats[predefined];
          formatter.push(fn2);
          i += predefined.length - 1;
        } else if (format2[i] === "{") {
          const index = format2.indexOf("}", i + 1);
          if (index === -1) {
            formatter.push(format2.substr(i + 1));
            i = format2.length;
          } else {
            formatter.push(format2.substring(i + 1, index));
            i = index;
          }
        } else {
          formatter.push(format2[i]);
        }
      }
    }
    formatter.forEach((step) => {
      if (typeof step === "string") {
        output += step;
      } else {
        output += step(date2);
      }
    });
    return output;
  }
  static formatRange(dates, format2) {
    return format2.replace(rangeFormatPartRe, (s, which, fmt) => DateHelper.format(dates[which === "S" ? 0 : 1], fmt));
  }
  static asMilliseconds(amount, unit = null) {
    if (typeof amount === "string") {
      unit = amount;
      amount = 1;
    }
    return DH$2.as("millisecond", amount, unit);
  }
  static asMonths(time) {
    const monthLength = DH$2.as("ms", DH$2.daysInMonth(time), "day"), fraction = (time.valueOf() - DH$2.startOf(time, "month").valueOf()) / monthLength;
    return time.getYear() * 12 + time.getMonth() + fraction;
  }
  static monthsToDate(months) {
    const intMonths = Math.floor(months), fraction = months - intMonths, result = new Date(0, intMonths), msInMonth = DH$2.as("ms", DH$2.daysInMonth(result), "days");
    result.setTime(result.getTime() + fraction * msInMonth);
    return result;
  }
  static formatDelta(delta, options) {
    let abbrev, unitName;
    if (typeof options === "boolean") {
      abbrev = options;
    } else if (options) {
      abbrev = options.abbrev;
    }
    const deltaObj = this.getDelta(delta, options), result = [], sep = (options === null || options === void 0 ? void 0 : options.separator) || (abbrev ? "" : " ");
    for (unitName in deltaObj) {
      result.push(`${deltaObj[unitName]}${sep}${unitName}`);
    }
    return (options === null || options === void 0 ? void 0 : options.asString) === false ? result : result.join(", ");
  }
  static getDelta(delta, options) {
    let abbrev, d, done, precision, unitName, maxUnit, ignoreLocale;
    if (typeof options === "boolean") {
      abbrev = options;
    } else if (options) {
      abbrev = options.abbrev;
      precision = DH$2.normalizeUnit(options.precision);
      maxUnit = options.maxUnit;
      ignoreLocale = !abbrev && options.ignoreLocale;
    }
    const result = {}, getUnit = abbrev ? DH$2.getShortNameOfUnit : DH$2.getLocalizedNameOfUnit;
    const units = maxUnit ? deltaUnits.slice(deltaUnits.indexOf(maxUnit)) : deltaUnits;
    for (unitName of units) {
      d = DH$2.as(unitName, delta);
      done = precision === unitName;
      d = Math[done ? "round" : "floor"](d);
      if (d || done && !result.length) {
        result[ignoreLocale ? unitName : getUnit.call(DH$2, unitName, d !== 1)] = d;
        delta -= DH$2.as("ms", d, unitName);
      }
      if (done || !delta) {
        break;
      }
    }
    return result;
  }
  static as(toUnit, amount, fromUnit = "ms") {
    if (typeof amount === "string") {
      amount = DH$2.parseDuration(amount);
    }
    if (typeof amount === "object") {
      fromUnit = amount.unit;
      amount = amount.magnitude;
    }
    if (toUnit === fromUnit) {
      return amount;
    }
    toUnit = DH$2.normalizeUnit(toUnit);
    fromUnit = DH$2.normalizeUnit(fromUnit);
    if (toUnit === fromUnit) {
      return amount;
    } else if (unitMagnitudes[fromUnit] > unitMagnitudes[toUnit]) {
      return amount * Math.abs(validConversions[fromUnit][toUnit]);
    } else {
      return amount / Math.abs(validConversions[toUnit][fromUnit]);
    }
  }
  static formatContainsHourInfo(format2) {
    const stripEscapeRe = /(\\.)/g, hourInfoRe = /([HhKkmSsAa]|LT|L{3,}|l{3,})/;
    return hourInfoRe.test(format2.replace(stripEscapeRe, ""));
  }
  static is24HourFormat(format2) {
    return DH$2.format(DH$2.getTime(13, 0, 0), format2).includes("13");
  }
  static add(date2, amount, unit = "ms", clone = true) {
    let d;
    if (typeof date2 === "string") {
      d = DH$2.parse(date2);
    } else if (clone) {
      d = new Date(date2.getTime());
    } else {
      d = date2;
    }
    if (typeof amount === "string") {
      const duration = DateHelper.parseDuration(amount);
      amount = duration.magnitude;
      unit = duration.unit;
    } else if (amount && typeof amount === "object") {
      unit = amount.unit;
      amount = amount.magnitude;
    }
    if (!unit || amount === 0) {
      return d;
    }
    unit = DH$2.normalizeUnit(unit);
    switch (unit) {
      case "millisecond":
        d.setTime(d.getTime() + amount);
        break;
      case "second":
        d.setTime(d.getTime() + amount * 1e3);
        break;
      case "minute":
        d.setTime(d.getTime() + amount * 6e4);
        break;
      case "hour":
        d.setTime(d.getTime() + amount * 36e5);
        break;
      case "day":
        if (amount % 1 === 0) {
          d.setDate(d.getDate() + amount);
          if (d.getHours() === 23 && date2.getHours() === 0) {
            d.setHours(d.getHours() + 1);
          }
        } else {
          d.setTime(d.getTime() + amount * 864e5);
        }
        break;
      case "week":
        d.setDate(d.getDate() + amount * 7);
        break;
      case "month": {
        let day2 = d.getDate();
        if (day2 > 28) {
          day2 = Math.min(day2, DH$2.getLastDateOfMonth(DH$2.add(DH$2.getFirstDateOfMonth(d), amount, "month")).getDate());
        }
        d.setDate(day2);
        d.setMonth(d.getMonth() + amount);
        break;
      }
      case "quarter":
        DH$2.add(d, amount * 3, "month", false);
        break;
      case "year":
        d.setFullYear(d.getFullYear() + amount);
        break;
      case "decade":
        d.setFullYear(d.getFullYear() + amount * 10);
        break;
    }
    return d;
  }
  static diff(start, end, unit = "ms", fractional = true) {
    unit = DH$2.normalizeUnit(unit);
    if (!start || !end)
      return 0;
    let amount;
    switch (unit) {
      case "year":
        amount = DH$2.diff(start, end, "month") / 12;
        break;
      case "quarter":
        amount = DH$2.diff(start, end, "month") / 3;
        break;
      case "month":
        amount = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
        break;
      case "week":
        amount = DH$2.diff(start, end, "day") / 7;
        break;
      case "day": {
        const dstDiff = start.getTimezoneOffset() - end.getTimezoneOffset();
        amount = (end - start + dstDiff * 60 * 1e3) / 864e5;
        break;
      }
      case "hour":
        amount = (end - start) / 36e5;
        break;
      case "minute":
        amount = (end - start) / 6e4;
        break;
      case "second":
        amount = (end - start) / 1e3;
        break;
      case "millisecond":
        amount = end - start;
        break;
    }
    return fractional ? amount : Math.round(amount);
  }
  static startOf(date2, unit = "day", clone = true, weekStartDay = DH$2.weekStartDay) {
    if (!date2) {
      return null;
    }
    unit = DH$2.normalizeUnit(unit);
    if (clone) {
      date2 = DH$2.clone(date2);
    }
    switch (unit) {
      case "year":
        date2.setMonth(0, 1);
        date2.setHours(0, 0, 0, 0);
        return date2;
      case "quarter":
        date2.setMonth((DH$2.get(date2, "quarter") - 1) * 3, 1);
        date2.setHours(0, 0, 0, 0);
        return date2;
      case "month":
        date2.setDate(1);
        date2.setHours(0, 0, 0, 0);
        return date2;
      case "week": {
        const delta = date2.getDay() - weekStartDay;
        date2.setDate(date2.getDate() - delta);
        date2.setHours(0, 0, 0, 0);
        return date2;
      }
      case "day":
        date2.setHours(0, 0, 0, 0);
        return date2;
      case "hour":
        date2.getMinutes() > 0 && date2.setMinutes(0);
      case "minute":
        date2.getSeconds() > 0 && date2.setSeconds(0);
      case "second":
        date2.getMilliseconds() > 0 && date2.setMilliseconds(0);
      case "millisecond":
        return date2;
    }
  }
  static endOf(date2) {
    return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate() + 1);
  }
  static clone(date2) {
    return new Date(date2.getTime());
  }
  static clearTime(date2, clone = true) {
    if (!date2) {
      return null;
    }
    if (clone) {
      date2 = new Date(date2.getTime());
    }
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
  static midnight(date2, inclusive) {
    let ret = DH$2.clearTime(date2);
    if (inclusive && ret < date2) {
      ret = DH$2.add(ret, 1, "d");
    }
    return ret;
  }
  static getTimeOfDay(date2, unit = "ms") {
    const t = date2.getHours() * validConversions.hour.millisecond + date2.getMinutes() * validConversions.minute.millisecond + date2.getSeconds() * validConversions.second.millisecond + date2.getMilliseconds();
    return unit === "ms" ? t : DH$2.as(unit, t, "ms");
  }
  static set(date2, unit, amount) {
    if (!unit) {
      return date2;
    }
    if (typeof unit === "string") {
      switch (DH$2.normalizeUnit(unit)) {
        case "millisecond":
          if (amount !== 0 || date2.getMilliseconds() > 0) {
            date2.setMilliseconds(amount);
          }
          break;
        case "second":
          if (amount !== 0 || date2.getSeconds() > 0) {
            date2.setSeconds(amount);
          }
          break;
        case "minute":
          if (amount !== 0 || date2.getMinutes() > 0) {
            date2.setMinutes(amount);
          }
          break;
        case "hour":
          date2.setHours(amount);
          break;
        case "day":
        case "date":
          date2.setDate(amount);
          break;
        case "week":
          throw new Error("week not implemented");
        case "month":
          date2.setMonth(amount);
          break;
        case "quarter":
          date2.setDate(1);
          date2.setMonth((amount - 1) * 3);
          break;
        case "year":
          date2.setFullYear(amount);
          break;
      }
    } else {
      Object.entries(unit).sort((a, b) => unitMagnitudes[a[0]] - unitMagnitudes[b[0]]).forEach(([unit2, amount2]) => {
        DH$2.set(date2, unit2, amount2);
      });
    }
    return date2;
  }
  static setDateToMidday(date2, clone = true) {
    return DH$2.set(DH$2.clearTime(date2, clone), "hour", 12);
  }
  static constrain(date2, min2, max) {
    if (min2 != null) {
      date2 = DH$2.max(date2, min2);
    }
    return max == null ? date2 : DH$2.min(date2, max);
  }
  static getTime(hours, minutes = 0, seconds = 0, ms = 0) {
    if (hours instanceof Date) {
      ms = hours.getMilliseconds();
      seconds = hours.getSeconds();
      minutes = hours.getMinutes();
      hours = hours.getHours();
    }
    return new Date(DEFAULT_YEAR, DEFAULT_MONTH, DEFAULT_DAY, hours, minutes, seconds, ms);
  }
  static copyTimeValues(targetDate, sourceDate) {
    targetDate.setHours(sourceDate.getHours());
    targetDate.setMinutes(sourceDate.getMinutes());
    targetDate.setSeconds(sourceDate.getSeconds());
    targetDate.setMilliseconds(sourceDate.getMilliseconds());
    return targetDate;
  }
  static get isDSTEnabled() {
    const year = new Date().getFullYear(), jan = new Date(year, 0, 1), jul = new Date(year, 6, 1);
    return jan.getTimezoneOffset() !== jul.getTimezoneOffset();
  }
  static isDST(date2) {
    const year = date2.getFullYear(), jan = new Date(year, 0, 1), jul = new Date(year, 6, 1);
    return date2.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
  }
  static isBefore(first, second) {
    return first < second;
  }
  static isAfter(first, second) {
    return first > second;
  }
  static isEqual(first, second, unit = null) {
    if (unit === null) {
      return first && second && first.getTime() === second.getTime();
    }
    return DH$2.startOf(first, unit) - DH$2.startOf(second, unit) === 0;
  }
  static compare(first, second, unit = null) {
    if (unit) {
      first = DH$2.startOf(first, unit);
      second = DH$2.startOf(second, unit);
    }
    if (first < second)
      return -1;
    if (first > second)
      return 1;
    return 0;
  }
  static clamp(date2, min2, max) {
    if (!isNaN(date2)) {
      if (min2 != null) {
        date2 = Math.max(date2, min2);
      }
      if (max != null) {
        date2 = Math.min(date2, max);
      }
      return new Date(date2);
    }
  }
  static isSameDate(first, second) {
    return DH$2.compare(first, second, "d") === 0;
  }
  static isSameTime(first, second) {
    return first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes() && first.getSeconds() === second.getSeconds() && first.getMilliseconds() === second.getMilliseconds();
  }
  static isStartOf(date2, unit) {
    return DH$2.isEqual(date2, DH$2.startOf(date2, unit));
  }
  static betweenLesser(date2, start, end) {
    return start.getTime() <= date2.getTime() && date2.getTime() < end.getTime();
  }
  static betweenLesserEqual(date2, start, end) {
    return start.getTime() <= date2.getTime() && date2.getTime() <= end.getTime();
  }
  static intersectSpans(date1Start, date1End, date2Start, date2End) {
    return DH$2.betweenLesser(date1Start, date2Start, date2End) || DH$2.betweenLesser(date2Start, date1Start, date1End);
  }
  static compareUnits(unit1, unit2) {
    return Math.sign(unitMagnitudes[DH$2.normalizeUnit(unit1)] - unitMagnitudes[DH$2.normalizeUnit(unit2)]);
  }
  static timeSpanContains(spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
    return otherSpanStart - spanStart >= 0 && spanEnd - otherSpanEnd >= 0;
  }
  static get weekStartDay() {
    if (DH$2._weekStartDay == null) {
      DH$2._weekStartDay = this.localize("L{weekStartDay}") || 0;
    }
    return DH$2._weekStartDay;
  }
  static get nonWorkingDays() {
    return _objectSpread2({}, this.localize("L{nonWorkingDays}"));
  }
  static get nonWorkingDaysAsArray() {
    return Object.keys(this.nonWorkingDays).map(Number);
  }
  static get weekends() {
    return _objectSpread2({}, this.localize("L{weekends}"));
  }
  static get(date2, unit) {
    switch (DH$2.normalizeUnit(unit)) {
      case "millisecond":
        return date2.getMilliseconds();
      case "second":
        return date2.getSeconds();
      case "minute":
        return date2.getMinutes();
      case "hour":
        return date2.getHours();
      case "date":
      case "day":
        return date2.getDate();
      case "week":
        return formats.W(date2);
      case "month":
        return date2.getMonth();
      case "quarter":
        return Math.floor(date2.getMonth() / 3) + 1;
      case "year":
        return date2.getFullYear();
    }
    return null;
  }
  static daysInYear(date2) {
    const fullYear = date2.getFullYear(), duration = new Date(fullYear + 1, 0, 1) - new Date(fullYear, 0, 1);
    return this.as("day", duration);
  }
  static daysInMonth(date2) {
    return 32 - new Date(date2.getFullYear(), date2.getMonth(), 32).getDate();
  }
  static hoursInDay(date2) {
    const fullYear = date2.getFullYear(), month2 = date2.getMonth(), day2 = date2.getDate(), duration = new Date(fullYear, month2, day2 + 1) - new Date(fullYear, month2, day2);
    return this.as("hour", duration);
  }
  static getNormalizedUnitDuration(date2, unit) {
    let result;
    switch (unit) {
      case "month":
        result = DH$2.asMilliseconds(DH$2.daysInMonth(date2), "day");
        break;
      case "year":
        result = DH$2.asMilliseconds(DH$2.daysInYear(date2), "day");
        break;
      case "day":
        result = DH$2.asMilliseconds(DH$2.hoursInDay(date2), "hour");
        break;
      default:
        result = DH$2.asMilliseconds(unit);
    }
    return result;
  }
  static getFirstDateOfMonth(date2) {
    return new Date(date2.getFullYear(), date2.getMonth(), 1);
  }
  static getLastDateOfMonth(date2) {
    return new Date(date2.getFullYear(), date2.getMonth() + 1, 0);
  }
  static min(first, second) {
    return first.getTime() < second.getTime() ? first : second;
  }
  static max(first, second) {
    return first.getTime() > second.getTime() ? first : second;
  }
  static getNext(date2, unit, increment = 1, weekStartDay = DH$2.weekStartDay) {
    if (unit === "week") {
      const dt = DH$2.clone(date2), day2 = dt.getDay();
      DH$2.startOf(dt, "day", false);
      DH$2.add(dt, weekStartDay - day2 + 7 * (increment - (weekStartDay <= day2 ? 0 : 1)), "day", false);
      if (dt.getDay() !== weekStartDay) {
        DH$2.add(dt, 1, "hour");
      }
      return dt;
    }
    return DH$2.startOf(DH$2.add(date2, increment, unit), unit, false);
  }
  static isValidDate(date2) {
    return DH$2.isDate(date2) && !isNaN(date2);
  }
  static isDate(value) {
    return value && toString$1.call(value) === DATE_TYPE;
  }
  static getStartOfNextDay(date2, clone = false, noNeedToClearTime = false) {
    let nextDay = DH$2.add(noNeedToClearTime ? date2 : DH$2.clearTime(date2, clone), 1, "day");
    if (nextDay.getDate() === date2.getDate()) {
      const offsetNextDay = DH$2.add(DH$2.clearTime(date2, clone), 2, "day").getTimezoneOffset(), offsetDate = date2.getTimezoneOffset();
      nextDay = DH$2.add(nextDay, offsetDate - offsetNextDay, "minute");
    }
    return nextDay;
  }
  static getEndOfPreviousDay(date2, noNeedToClearTime = false) {
    const dateOnly = noNeedToClearTime ? date2 : DH$2.clearTime(date2, true);
    if (dateOnly - date2) {
      return dateOnly;
    } else {
      return DH$2.add(dateOnly, -1, "day");
    }
  }
  static getWeekDescription(startDate, endDate = startDate) {
    const monthDesc = startDate.getMonth() === endDate.getMonth() ? DateHelper.format(startDate, "MMMM") : `${DateHelper.format(startDate, "MMM")} - ${DateHelper.format(endDate, "MMM")}`, week = DateHelper.getWeekNumber(startDate);
    return `${week[1]}, ${monthDesc} ${week[0]}`;
  }
  static getWeekNumber(date2, weekStartDay = DateHelper.weekStartDay) {
    const jan01 = new Date(date2.getFullYear(), 0, 1), dec31 = new Date(date2.getFullYear(), 11, 31), firstDay = normalizeDay(jan01.getDay() - weekStartDay), lastDay = normalizeDay(dec31.getDay() - weekStartDay), dayNumber = getDayDiff(date2, jan01);
    let weekNumber;
    if (firstDay < 4) {
      weekNumber = Math.floor((dayNumber + firstDay - 1) / 7) + 1;
    } else {
      weekNumber = Math.floor((dayNumber + firstDay - 1) / 7);
    }
    if (weekNumber) {
      let year = date2.getFullYear();
      if (weekNumber === 53 && lastDay < 3) {
        year++;
        weekNumber = 1;
      }
      return [year, weekNumber];
    }
    const lastWeekOfLastYear = DateHelper.getWeekNumber(new Date(date2.getFullYear() - 1, 11, 31))[1];
    return [date2.getFullYear() - 1, lastWeekOfLastYear];
  }
  static formatCount(count, unit) {
    unit = DH$2.normalizeUnit(unit);
    if (count !== 1)
      unit += "s";
    return count + " " + unit;
  }
  static getUnitToBaseUnitRatio(baseUnit, unit, acceptEstimate = false) {
    baseUnit = DH$2.normalizeUnit(baseUnit);
    unit = DH$2.normalizeUnit(unit);
    if (baseUnit === unit)
      return 1;
    if (validConversions[baseUnit] && validConversions[baseUnit][unit] && (acceptEstimate || validConversions[baseUnit][unit] > 0)) {
      return 1 / DH$2.as(unit, 1, baseUnit);
    }
    if (validConversions[unit] && validConversions[unit][baseUnit] && (acceptEstimate || validConversions[unit][baseUnit] > 0)) {
      return DH$2.as(baseUnit, 1, unit);
    }
    return -1;
  }
  static getShortNameOfUnit(unit) {
    unit = DH$2.parseTimeUnit(unit);
    return DH$2.unitLookup[unit].abbrev;
  }
  static getLocalizedNameOfUnit(unit, plural = false) {
    const capitalize = unit.charAt(0) === unit.charAt(0).toUpperCase();
    unit = DH$2.normalizeUnit(unit);
    unit = DH$2.parseTimeUnit(unit);
    unit = DH$2.unitLookup[unit][plural ? "plural" : "single"];
    if (capitalize) {
      unit = StringHelper.capitalize(unit);
    }
    return unit;
  }
  static normalizeUnit(unit) {
    if (!unit) {
      return null;
    }
    const unitLower = unit.toLowerCase();
    if (unitLower === "date") {
      return unitLower;
    }
    return canonicalUnitNames.includes(unitLower) ? unitLower : normalizedUnits[unit] || normalizedUnits[unitLower];
  }
  static getUnitByName(name) {
    return DH$2.normalizeUnit(name) || DH$2.normalizeUnit(DH$2.parseTimeUnit(name));
  }
  static getDurationInUnit(start, end, unit, doNotRound) {
    return DH$2.diff(start, end, unit, doNotRound);
  }
  static doesUnitsAlign(majorUnit, minorUnit) {
    return !(majorUnit !== minorUnit && minorUnit === "week");
  }
  static getSmallerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[DH$2.normalizeUnit(unit)] - 1] || null;
  }
  static getLargerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[DH$2.normalizeUnit(unit)] + 1] || null;
  }
  static round(time, increment, base, weekStartDay) {
    return DH$2.snap("round", time, increment, base, weekStartDay);
  }
  static floor(time, increment, base, weekStartDay) {
    return DH$2.snap("floor", time, increment, base, weekStartDay);
  }
  static ceil(time, increment, base, weekStartDay) {
    return DH$2.snap("ceil", time, increment, base, weekStartDay);
  }
  static snap(operation, time, increment, base, weekStartDay = DH$2.weekStartDay) {
    const snapFn = snapFns[operation];
    if (typeof increment === "string") {
      increment = DH$2.parseDuration(increment);
    }
    if (Objects.isObject(increment)) {
      const magnitude = increment.magnitude || increment.increment;
      switch (increment.unit) {
        case "week": {
          const weekDay = time.getDay();
          base = DH$2.add(DH$2.clearTime(time), weekDay >= weekStartDay ? weekStartDay - weekDay : -(weekDay - weekStartDay + 7), "day");
          return DH$2[operation](time, `${magnitude * 7} days`, base);
        }
        case "month": {
          time = DH$2.asMonths(time);
          let resultMonths;
          if (base) {
            base = DH$2.asMonths(base);
            resultMonths = time + snapFn(time - base, magnitude);
          } else {
            resultMonths = snapFn(time, magnitude);
          }
          return DH$2.monthsToDate(resultMonths);
        }
        case "quarter":
          return DH$2[operation](time, `${magnitude * 3} months`, base);
        case "year":
          return DH$2[operation](time, `${magnitude * 12} months`, base);
        case "decade":
          return DH$2[operation](time, `${magnitude * 10} years`, base);
      }
      increment = DH$2.as("ms", magnitude, increment.unit);
    }
    if (base) {
      const tzChange = DH$2.as("ms", base.getTimezoneOffset() - time.getTimezoneOffset(), "ms");
      return new Date(base.valueOf() + snapFn(DH$2.diff(base, time, "ms") + tzChange, increment));
    } else {
      const offset = time.getTimezoneOffset() * 60 * 1e3;
      return new Date(snapFn(time.valueOf() - offset, increment) + offset);
    }
  }
  static parseDuration(value, allowDecimals = true, defaultUnit) {
    var _match$;
    const durationRegEx = allowDecimals ? withDecimalsDurationRegex : noDecimalsDurationRegex, match = durationRegEx.exec(value);
    if (value == null || !match) {
      return null;
    }
    const magnitude = parseNumber((_match$ = match[1]) === null || _match$ === void 0 ? void 0 : _match$.replace(",", ".")), unit = DH$2.parseTimeUnit(match[2]) || defaultUnit;
    if (!unit) {
      return null;
    }
    return {
      magnitude,
      unit
    };
  }
  static parseTimeUnit(unitName) {
    const unitMatch = unitName == null ? null : DH$2.durationRegEx.exec(unitName.toLowerCase());
    if (!unitMatch) {
      return null;
    }
    for (let unitOrdinal = 0; unitOrdinal < canonicalUnitNames.length; unitOrdinal++) {
      if (unitMatch[unitOrdinal + 1]) {
        return canonicalUnitNames[unitOrdinal];
      }
    }
  }
  static getGMTOffset(date2 = new Date()) {
    if (!date2) {
      return;
    }
    const offsetInMinutes = date2.getTimezoneOffset();
    if (!offsetInMinutes)
      return "Z";
    return (offsetInMinutes > 0 ? "-" : "+") + Math.abs(Math.trunc(offsetInMinutes / 60)).toString().padStart(2, "0") + ":" + Math.abs(offsetInMinutes % 60).toString().padStart(2, "0");
  }
  static fillDayNames() {
    const tempDate2 = new Date("2000-01-01T12:00:00"), dayNames = DH$2._dayNames || [], dayShortNames = DH$2._dayShortNames || [];
    dayNames.length = 0;
    dayShortNames.length = 0;
    for (let day2 = 2; day2 < 9; day2++) {
      tempDate2.setDate(day2);
      dayNames.push(DH$2.format(tempDate2, "dddd"));
      dayShortNames.push(DH$2.format(tempDate2, "ddd"));
    }
    DH$2._dayNames = dayNames;
    DH$2._dayShortNames = dayShortNames;
  }
  static getDayNames() {
    return DH$2._dayNames;
  }
  static getDayName(day2) {
    return DH$2._dayNames[day2];
  }
  static getDayShortNames() {
    return DH$2._dayShortNames;
  }
  static getDayShortName(day2) {
    return DH$2._dayShortNames[day2];
  }
  static fillMonthNames() {
    const tempDate2 = new Date("2000-01-15T12:00:00"), monthNames = DH$2._monthNames || [], monthShortNames = DH$2._monthShortNames || [], monthNamesIndex = {}, monthShortNamesIndex = {};
    monthNames.length = 0;
    monthShortNames.length = 0;
    for (let month2 = 0; month2 < 12; month2++) {
      tempDate2.setMonth(month2);
      const monthName = DH$2.format(tempDate2, "MMMM");
      monthNames.push(monthName);
      const monthShortName = DH$2.format(tempDate2, "MMM");
      monthShortNames.push(monthShortName);
      monthNamesIndex[monthName.toLowerCase()] = {
        name: monthName,
        value: month2
      };
      monthShortNamesIndex[monthShortName.toLowerCase()] = {
        name: monthShortName,
        value: month2
      };
    }
    DH$2._monthNames = monthNames;
    DH$2._monthShortNames = monthShortNames;
    DH$2._monthNamesIndex = monthNamesIndex;
    DH$2._monthShortNamesIndex = monthShortNamesIndex;
  }
  static getMonthShortNames() {
    return DH$2._monthShortNames;
  }
  static getMonthShortName(month2) {
    return DH$2._monthShortNames[month2];
  }
  static getMonthNames() {
    return DH$2._monthNames;
  }
  static getMonthName(month2) {
    return DH$2._monthNames[month2];
  }
  static set locale(name) {
    locale$3 = name;
    intlFormatterCache = {};
    formatCache = {};
    formatRedirects = {};
  }
  static get locale() {
    return locale$3;
  }
  static setupDurationRegEx(unitNames = [], unitAbbreviations = []) {
    const me = this, unitLookup = {};
    let unitAbbrRegEx = "";
    for (let i = 0; i < unitAbbreviations.length; i++) {
      const abbreviations = unitAbbreviations[i], unitNamesCfg = unitNames[i];
      unitNamesCfg.canonicalUnitName = canonicalUnitNames[i];
      unitLookup[unitNamesCfg.single] = unitLookup[unitNamesCfg.single.toUpperCase()] = unitLookup[unitNamesCfg.canonicalUnitName] = unitLookup[unitNamesCfg.canonicalUnitName.toUpperCase()] = unitNamesCfg;
      unitAbbrRegEx += `${i ? "|" : ""}(`;
      for (let j = 0; j < abbreviations.length; j++) {
        unitAbbrRegEx += `${abbreviations[j]}|`;
      }
      locale$3 = me.localize("L{locale}") || "en-US";
      if (locale$3 !== "en-US") {
        const canonicalAbbreviations = canonicalUnitAbbreviations[i];
        for (let j = 0; j < canonicalAbbreviations.length; j++) {
          unitAbbrRegEx += `${canonicalAbbreviations[j]}|`;
        }
      }
      unitAbbrRegEx += `${unitNamesCfg.single}|${unitNamesCfg.plural}|${unitNamesCfg.canonicalUnitName}|${unitNamesCfg.canonicalUnitName}s)`;
    }
    me.unitLookup = unitLookup;
    me.durationRegEx = new RegExp(`^(?:${unitAbbrRegEx})$`);
  }
  static applyLocale() {
    const me = this, unitAbbreviations = me.localize("L{unitAbbreviations}") || [], unitNames = me.unitNames = me.localize("L{unitNames}");
    if (unitNames === "unitNames") {
      return;
    }
    locale$3 = me.localize("L{locale}") || "en-US";
    if (locale$3 === "en-US") {
      ordinalSuffix = enOrdinalSuffix;
    } else {
      ordinalSuffix = me.localize("L{ordinalSuffix}") || ordinalSuffix;
    }
    formatCache = {};
    formatRedirects = {};
    parserCache = {};
    intlFormatterCache = {};
    DH$2._weekStartDay = null;
    DH$2.setupDurationRegEx(unitNames, unitAbbreviations);
    DH$2.fillDayNames();
    DH$2.fillMonthNames();
  }
};
_defineProperty(DateHelper, "MS_PER_DAY", MS_PER_HOUR * 24);
var DH$2 = DateHelper;
DH$2.useIntlFormat = useIntlFormat;
LocaleManagerSingleton.ion({
  locale: "applyLocale",
  prio: 1e3,
  thisObj: DH$2
});
if (LocaleManagerSingleton.locale) {
  DH$2.applyLocale();
}
DateHelper._$name = "DateHelper";
var {
  hasOwn: hasOwn$2
} = Objects;
var toFixedFix = 1.005 .toFixed(2) === "1.01" ? null : function(number, fractionDigits) {
  const split2 = number.toString().split("."), newNumber = +(!split2[1] ? split2[0] : split2.join(".") + "1");
  return number.toFixed.call(newNumber, fractionDigits);
};
var ObjectHelper = class extends Objects {
  static transformArrayToNamedObject(arrayOfItems, prop = "ref") {
    const namedItems = {};
    arrayOfItems.forEach((item, index) => {
      const key = item[prop] != null && item[prop].toString().length ? item[prop] : index;
      namedItems[key] = item;
    });
    return namedItems;
  }
  static transformNamedObjectToArray(namedItems, prop = "ref") {
    return Object.keys(namedItems).filter((key) => namedItems[key]).map((key) => {
      const item = namedItems[key];
      item[prop] = key;
      return item;
    });
  }
  static isEqual(a, b, useIsDeeply = false) {
    if (a === null && b !== null || a === void 0 && b !== void 0 || b === null && a !== null || b === void 0 && a !== void 0) {
      return false;
    }
    if (a == null && b == null) {
      return true;
    }
    if (a === b) {
      return true;
    }
    const typeA = typeof a, typeB = typeof b;
    if (typeA === typeB) {
      switch (typeA) {
        case "number":
        case "string":
        case "boolean":
          return a === b;
      }
      switch (true) {
        case (a instanceof Date && b instanceof Date):
          return a.getTime() === b.getTime();
        case (Array.isArray(a) && Array.isArray(b)):
          return a.length === b.length ? a.every((v, idx) => OH.isEqual(v, b[idx], useIsDeeply)) : false;
        case (typeA === "object" && a.constructor.prototype === b.constructor.prototype):
          return useIsDeeply ? OH.isDeeplyEqual(a, b, useIsDeeply) : JSON.stringify(a) === JSON.stringify(b);
      }
    }
    return String(a) === String(b);
  }
  static isDeeplyEqual(a, b, options = {}) {
    if (a === b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    const aKeys = OH.keys(a, options.ignore), bKeys = OH.keys(b, options.ignore);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (let i = 0; i < aKeys.length; i++) {
      const aKey = aKeys[i], bKey = bKeys[i];
      if (aKey !== bKey) {
        return false;
      }
      const aVal = a[aKey], bVal = b[bKey];
      if (options.shouldEvaluate) {
        if (options.shouldEvaluate(aKey, {
          value: aVal,
          object: a
        }, {
          value: bVal,
          object: b
        }) === false) {
          continue;
        }
      }
      if (options.evaluate) {
        const result = options.evaluate(aKey, {
          value: aVal,
          object: a
        }, {
          value: bVal,
          object: b
        });
        if (result === false) {
          return false;
        }
        if (result === true) {
          continue;
        }
      }
      if (!OH.isEqual(aVal, bVal, options)) {
        return false;
      }
    }
    return true;
  }
  static isPartial(a, b) {
    a = String(a).toLowerCase();
    b = String(b).toLowerCase();
    return a.indexOf(b) !== -1;
  }
  static isLessThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isBefore(a, b);
    }
    return a < b;
  }
  static isMoreThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isAfter(a, b);
    }
    return a > b;
  }
  static fork(obj) {
    let ret, key, value;
    if (obj && obj.constructor === Object) {
      ret = Object.setPrototypeOf({}, obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (value.constructor === Object) {
            ret[key] = OH.fork(value);
          } else if (value instanceof Array) {
            ret[key] = value.slice();
          }
        }
      }
    } else {
      ret = obj;
    }
    return ret;
  }
  static copyProperties(dest, source, props) {
    let prop, i;
    for (i = 0; i < props.length; i++) {
      prop = props[i];
      if (prop in source) {
        dest[prop] = source[prop];
      }
    }
    return dest;
  }
  static copyPropertiesIf(dest, source, props) {
    if (source) {
      for (const prop of props) {
        if (!(prop in dest)) {
          dest[prop] = source[prop];
        }
      }
    }
    return dest;
  }
  static entries(object, ignore) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore !== null && ignore !== void 0 && ignore[p])) {
          result.push([p, object[p]]);
        }
      }
    }
    return result;
  }
  static fromEntries(entries, object) {
    object = object || {};
    if (entries) {
      for (let i = 0; i < entries.length; ++i) {
        object[entries[i][0]] = entries[i][1];
      }
    }
    return object;
  }
  static keys(object, ignore, mapper) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      let index = 0;
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore !== null && ignore !== void 0 && ignore[p])) {
          result.push(mapper ? mapper(p, index) : p);
          ++index;
        }
      }
    }
    return result;
  }
  static values(object, ignore, mapper) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      let index = 0;
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore !== null && ignore !== void 0 && ignore[p])) {
          result.push(mapper ? mapper(object[p], index) : object[p]);
          ++index;
        }
      }
    }
    return result;
  }
  static pathExists(object, path) {
    const properties = path.split(".");
    return properties.every((property) => {
      if (!object || !(property in object)) {
        return false;
      }
      object = object[property];
      return true;
    });
  }
  static pathifyKeys(object) {
    const result = {};
    for (const key in object) {
      if (hasOwn$2(object, key)) {
        if (Array.isArray(object[key])) {
          result[key] = object[key].slice();
        } else if (object[key] instanceof Object) {
          const paths = this.pathifyKeys(object[key]);
          for (const path in paths) {
            result[`${key}.${path}`] = paths[path];
          }
        } else {
          result[key] = object[key];
        }
      }
    }
    return result;
  }
  static deletePath(object, path) {
    path.split(".").reduce((result, key, index, array) => {
      if (result == null) {
        return null;
      }
      if (hasOwn$2(result, key)) {
        if (index === array.length - 1) {
          delete result[key];
        } else {
          return result[key];
        }
      }
    }, object);
  }
  static coerce(from, to) {
    const fromType = Objects.typeOf(from), toType = Objects.typeOf(to), isString = typeof from === "string";
    if (fromType !== toType) {
      switch (toType) {
        case "string":
          return String(from);
        case "number":
          return Number(from);
        case "boolean":
          return isString && (!from || from === "false" || from === "0") ? false : Boolean(from);
        case "null":
          return isString && (!from || from === "null") ? null : false;
        case "undefined":
          return isString && (!from || from === "undefined") ? void 0 : false;
        case "date":
          return isString && isNaN(from) ? DateHelper.parse(from) : Date(Number(from));
      }
    }
    return from;
  }
  static wrapProperty(object, propertyName, newGetter, newSetter, deep = true) {
    const newProperty = {};
    let proto2 = Object.getPrototypeOf(object), existingProperty = Object.getOwnPropertyDescriptor(proto2, propertyName);
    while (!existingProperty && proto2 && deep) {
      proto2 = Object.getPrototypeOf(proto2);
      if (proto2) {
        existingProperty = Object.getOwnPropertyDescriptor(proto2, propertyName);
      }
    }
    if (existingProperty) {
      if (existingProperty.set) {
        newProperty.set = (v) => {
          existingProperty.set.call(object, v);
          newSetter && newSetter.call(object, existingProperty.get.call(object));
        };
      } else {
        newProperty.set = newSetter;
      }
      if (existingProperty.get) {
        newProperty.get = () => {
          let result = existingProperty.get.call(object);
          if (newGetter) {
            result = newGetter.call(object, result);
          }
          return result;
        };
      } else {
        newProperty.get = newGetter;
      }
    } else {
      newProperty.set = (v) => {
        object[`_${propertyName}`] = v;
        newSetter && newSetter.call(object, v);
      };
      newProperty.get = () => {
        let result = object[`_${propertyName}`];
        if (newGetter) {
          result = newGetter.call(object, result);
        }
        return result;
      };
    }
    Object.defineProperty(object, propertyName, newProperty);
  }
  static hookProperty(object, property, hook) {
    const desc = ObjectHelper.getPropertyDescriptor(hook.prototype, "value"), existingDesc = ObjectHelper.getPropertyDescriptor(object, property), fieldName = `_${property}`, base = class {
      get value() {
        return existingDesc ? existingDesc.get.call(this) : this[fieldName];
      }
      set value(v) {
        if (existingDesc) {
          existingDesc.set.call(this, v);
        } else {
          this[fieldName] = v;
        }
      }
    }, baseDesc = ObjectHelper.getPropertyDescriptor(base.prototype, "value");
    Object.setPrototypeOf(hook.prototype, base.prototype);
    Object.defineProperty(object, property, {
      configurable: true,
      get: desc.get || baseDesc.get,
      set: desc.set || baseDesc.set
    });
    return () => delete object[property];
  }
  static getPropertyDescriptor(object, propertyName) {
    let result = null;
    for (let o = object; o && !result && !hasOwn$2(o, "isBase"); o = Object.getPrototypeOf(o)) {
      result = Object.getOwnPropertyDescriptor(o, propertyName);
    }
    return result;
  }
  static cleanupProperties(object, keepNull = false) {
    Object.entries(object).forEach(([key, value]) => {
      if (keepNull) {
        value === void 0 && delete object[key];
      } else {
        value == null && delete object[key];
      }
    });
    return object;
  }
  static removeAllProperties(obj) {
    Object.keys(obj).forEach((key) => delete obj[key]);
    return obj;
  }
  static assertType(value, type, name) {
    const valueType = Objects.typeOf(value);
    if (value != null && valueType !== type) {
      throw new Error(`Incorrect type "${valueType}" for ${name}, expected "${type}"`);
    }
  }
  static assertObject(value, name) {
    OH.assertType(value, "object", name);
  }
  static assertInstance(value, name) {
    OH.assertType(value, "instance", name);
  }
  static assertClass(value, name) {
    OH.assertType(value, "class", name);
  }
  static assertFunction(value, name) {
    if (typeof value !== "function" || value.isBase || value.$$name) {
      throw new Error(`Incorrect type for ${name}, got "${value}" (expected a function)`);
    }
  }
  static assertNumber(value, name) {
    const asNumber = Number(value);
    if (typeof value !== "number" || isNaN(asNumber)) {
      throw new Error(`Incorrect type for ${name}, got "${value}" (expected a Number)`);
    }
  }
  static assertBoolean(value, name) {
    OH.assertType(value, "boolean", name);
  }
  static assertString(value, name) {
    OH.assertType(value, "string", name);
  }
  static assertArray(value, name) {
    OH.assertType(value, "array", name);
  }
  static toFixed(number, digits) {
    if (toFixedFix) {
      return toFixedFix(number, digits);
    }
    return number.toFixed(digits);
  }
  static roundTo(number, step = 1) {
    return Math.round(number / step) * step;
  }
  static round(number, digits) {
    if (digits == null) {
      return number;
    }
    const factor = 10 ** digits;
    return Math.round(number * factor) / factor;
  }
  static getMapPath(map2, path, defaultValue2) {
    const keyPath = Array.isArray(path) ? path : typeof path === "string" ? path.split(".") : [path], simpleKey = keyPath.length === 1, topKey = keyPath[0], topValue = map2.has(topKey) ? map2.get(topKey) : map2.set(topKey, simpleKey ? defaultValue2 : {}).get(topKey);
    if (simpleKey) {
      return topValue;
    }
    return OH.getPathDefault(topValue, keyPath.slice(1), defaultValue2);
  }
};
var OH = ObjectHelper;
ObjectHelper._$name = "ObjectHelper";
var allBorders = ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"];
var allMargins = ["margin-top", "margin-right", "margin-bottom", "margin-left"];
var allPaddings = ["padding-top", "padding-right", "padding-bottom", "padding-left"];
var borderNames = {
  t: "border-top-width",
  r: "border-right-width",
  b: "border-bottom-width",
  l: "border-left-width"
};
var paddingNames = {
  t: "padding-top",
  r: "padding-right",
  b: "padding-bottom",
  l: "padding-left"
};
var zeroBased = Object.freeze({
  x: 0,
  y: 0
});
var alignSpecRe$1 = /^([trblc])(\d*)-([trblc])(\d*)$/i;
var alignPointRe = /^([trblc])(\d*)$/i;
var edgeNames = ["top", "right", "bottom", "left"];
var edgeIndices = {
  t: 0,
  r: 1,
  b: 2,
  l: 3
};
var defaultAlignments = ["b-t", "l-r", "t-b", "r-l"];
var edgeAligments = {
  bt: 1,
  tb: 1,
  lr: 2,
  rl: 2
};
var zeroOffsets = Object.freeze([0, 0]);
var matchDimensions = ["width", "height"];
var parseEdges = (top, right = top, bottom = top, left = right) => {
  return Array.isArray(top) ? parseEdges.apply(null, top) : [top, right, bottom, left];
};
function parseAlign(alignSpec, rtl) {
  const parts = alignSpecRe$1.exec(alignSpec), myEdge = parts[1], targetEdge = parts[3], mO = parseInt(parts[2] || 50), tO = parseInt(parts[4] || 50), myOffset = rtl && !(edgeIndices[myEdge] & 1) ? 100 - mO : mO, targetOffset = rtl && !(edgeIndices[targetEdge] & 1) ? 100 - tO : tO, edgeAligned = edgeAligments[myEdge + targetEdge];
  return {
    myAlignmentPoint: myEdge + myOffset,
    myEdge,
    myOffset,
    targetAlignmentPoint: targetEdge + targetOffset,
    targetEdge,
    targetOffset,
    startZone: edgeIndices[targetEdge],
    edgeAligned
  };
}
function flipAlign(align) {
  return `${edgeNames[(edgeIndices[align.myEdge] + 2) % 4][0]}${align.myOffset}-${edgeNames[(edgeIndices[align.targetEdge] + 2) % 4][0]}${align.targetOffset}`;
}
function createOffsets(offset) {
  if (offset == null) {
    return zeroOffsets;
  } else if (typeof offset === "number") {
    return [offset, offset];
  }
  return offset;
}
var Rectangle = class {
  get isRectangle() {
    return true;
  }
  static from(element, relativeTo, ignorePageScroll) {
    var _element, _relativeTo;
    if (typeof element === "string") {
      element = document.querySelector(element);
    } else if (((_element = element) === null || _element === void 0 ? void 0 : _element.nodeType) === Node.DOCUMENT_FRAGMENT_NODE) {
      element = element.host || element.ownerDocument;
    }
    if (typeof relativeTo === "string") {
      relativeTo = document.querySelector(relativeTo);
    }
    if (element == null || element.isRectangle) {
      return element;
    }
    element = element.element || element;
    if (ignorePageScroll === void 0 && typeof relativeTo === "boolean") {
      ignorePageScroll = relativeTo;
      relativeTo = null;
    }
    if (!((_relativeTo = relativeTo) !== null && _relativeTo !== void 0 && _relativeTo.isRectangle)) {
      if (relativeTo) {
        let {
          scrollLeft,
          scrollTop
        } = relativeTo;
        if (BrowserHelper.isSafari && relativeTo === document.body) {
          scrollLeft = scrollTop = 0;
        }
        relativeTo = Rectangle.from(relativeTo).translate(-scrollLeft, -scrollTop);
      } else {
        relativeTo = zeroBased;
      }
    }
    const isViewport = element === document || element === globalThis, isSFViewport = element === document.body && document.body.offsetHeight === 0, sfElRect = isSFViewport && element.getBoundingClientRect(), viewRect = isSFViewport ? new Rectangle(sfElRect.left, sfElRect.top, sfElRect.width, document.body.parentElement.scrollHeight) : isViewport ? new Rectangle(0, 0, globalThis.innerWidth, globalThis.innerHeight) : element.getBoundingClientRect(), scrollOffset = ignorePageScroll || isViewport ? [0, 0] : [globalThis.pageXOffset, globalThis.pageYOffset];
    return new Rectangle(viewRect.left + scrollOffset[0] - relativeTo.x, viewRect.top + scrollOffset[1] - relativeTo.y, viewRect.width, viewRect.height);
  }
  static fromScreen(element, relativeTo) {
    return Rectangle.from(element, relativeTo, true);
  }
  static inner(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders);
      result.x += parseFloat(borders[borderNames.l]);
      result.y += parseFloat(borders[borderNames.t]);
      result.right -= parseFloat(borders[borderNames.r]);
      result.bottom -= parseFloat(borders[borderNames.b]);
    }
    return result;
  }
  static content(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders), padding = DomHelper.getStyleValue(element, allPaddings);
      result.x += parseFloat(borders[borderNames.l]) + parseFloat(padding[paddingNames.l]);
      result.y += parseFloat(borders[borderNames.t]) + parseFloat(padding[paddingNames.t]);
      result.right -= parseFloat(borders[borderNames.r]) + parseFloat(padding[paddingNames.r]);
      result.bottom -= parseFloat(borders[borderNames.b]) + parseFloat(padding[paddingNames.b]);
    }
    return result;
  }
  static client(element, relativeTo, ignorePageScroll = false) {
    const result = this.content(element, relativeTo, ignorePageScroll), scrollbarWidth = DomHelper.scrollBarWidth;
    let padding;
    if (scrollbarWidth) {
      if (element.scrollHeight > element.clientHeight && DomHelper.getStyleValue(element, "overflow-y") !== "hidden") {
        padding = parseFloat(DomHelper.getStyleValue(element, "padding-right"));
        result.right += padding - Math.max(padding, scrollbarWidth);
      }
      if (element.scrollWidth > element.clientWidth && DomHelper.getStyleValue(element, "overflow-x") !== "hidden") {
        padding = parseFloat(DomHelper.getStyleValue(element, "padding-bottom"));
        result.bottom += padding - Math.max(padding, scrollbarWidth);
      }
    }
    return result;
  }
  static outer(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    if (document.body.contains(element)) {
      const margin = DomHelper.getStyleValue(element, allMargins);
      result.x -= parseFloat(margin["margin-left"]);
      result.y -= parseFloat(margin["margin-top"]);
      result.right += parseFloat(margin["margin-right"]);
      result.bottom += parseFloat(margin["margin-bottom"]);
    }
    return result;
  }
  static union(...rectangles) {
    let {
      x,
      y,
      right,
      bottom
    } = rectangles[0], current;
    if (rectangles.length > 1) {
      for (let i = 1; i < rectangles.length; i++) {
        current = rectangles[i];
        if (current.x < x) {
          x = current.x;
        }
        if (current.y < y) {
          y = current.y;
        }
        if (current.right > right) {
          right = current.right;
        }
        if (current.bottom > bottom) {
          bottom = current.bottom;
        }
      }
    }
    return new Rectangle(x, y, right - x, bottom - y);
  }
  roundPx(devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const me = this;
    me._x = DomHelper.roundPx(me._x, devicePixelRatio);
    me._y = DomHelper.roundPx(me._y, devicePixelRatio);
    me._width = DomHelper.roundPx(me._width, devicePixelRatio);
    me._height = DomHelper.roundPx(me._height, devicePixelRatio);
    return me;
  }
  static get $$name() {
    return hasOwnProperty.call(this, "$name") && this.$name || hasOwnProperty.call(this, "_$name") && this._$name || this.name;
  }
  get $$name() {
    return this.constructor.$$name;
  }
  constructor(x, y, width, height) {
    ObjectHelper.assertNumber(x, "Rectangle.x");
    ObjectHelper.assertNumber(y, "Rectangle.y");
    ObjectHelper.assertNumber(width, "Rectangle.width");
    ObjectHelper.assertNumber(height, "Rectangle.height");
    const me = this;
    if (width < 0) {
      x += width;
      width = -width;
    }
    if (height < 0) {
      y += height;
      height = -height;
    }
    me._x = x;
    me._y = y;
    me._width = width;
    me._height = height;
  }
  clone() {
    const me = this, result = new Rectangle(me.x, me.y, me.width, me.height);
    result.isAlignRectangle = me.isAlignRectangle;
    result.minHeight = me.minHeight;
    result.minWidth = me.minWidth;
    return result;
  }
  contains(other) {
    const me = this;
    if (other.isRectangle) {
      return other._x >= me._x && other._y >= me._y && other.right <= me.right && other.bottom <= me.bottom;
    } else {
      return false;
    }
  }
  intersect(other, useBoolean = false, allowZeroDimensions = false) {
    const me = this, y = Math.max(me.y, other.y), r = Math.min(me.right, other.right), b = Math.min(me.bottom, other.bottom), x = Math.max(me.x, other.x), intersect = allowZeroDimensions ? b >= y && r >= x : b > y && r > x;
    if (intersect) {
      return useBoolean ? true : new Rectangle(x, y, r - x, b - y);
    } else {
      return false;
    }
  }
  equals(other, round2 = false) {
    const processor = round2 ? (x) => Math.round(x) : (x) => x;
    return other.isRectangle && processor(other.x) === processor(this.x) && processor(other.y) === processor(this.y) && processor(other.width) === processor(this.width) && processor(other.height) === processor(this.height);
  }
  translate(x, y) {
    this._x += x || 0;
    this._y += y || 0;
    return this;
  }
  moveTo(x, y) {
    if (x != null) {
      this._x = x;
    }
    if (y != null) {
      this._y = y;
    }
    return this;
  }
  getDelta(other) {
    return [other.x - this.x, other.y - this.y];
  }
  get center() {
    return new Rectangle.Point(this.x + this.width / 2, this.y + this.height / 2);
  }
  set x(x) {
    const xDelta = x - this._x;
    this._x = x;
    this._width -= xDelta;
  }
  get x() {
    return this._x;
  }
  get start() {
    return this.left;
  }
  set left(x) {
    this.x = x;
  }
  get left() {
    return this.x;
  }
  set top(y) {
    this.y = y;
  }
  get top() {
    return this.y;
  }
  set y(y) {
    const yDelta = y - this._y;
    this._y = y;
    this._height -= yDelta;
  }
  get y() {
    return this._y;
  }
  set width(width) {
    this._width = width;
  }
  get width() {
    return this._width;
  }
  set height(height) {
    this._height = height;
  }
  get height() {
    return this._height;
  }
  set right(right) {
    this._width = right - this._x;
  }
  get right() {
    return this._x + this._width;
  }
  get end() {
    return this.right;
  }
  set bottom(bottom) {
    this._height = bottom - this._y;
  }
  get bottom() {
    return this._y + this._height;
  }
  getStart(rtl, horizontal = true) {
    if (horizontal) {
      return rtl ? this.right : this.left;
    }
    return this.top;
  }
  getEnd(rtl, horizontal = true) {
    if (horizontal) {
      return rtl ? this.left : this.right;
    }
    return this.bottom;
  }
  get area() {
    return this.width * this.height;
  }
  set minWidth(minWidth) {
    const me = this;
    if (isNaN(minWidth)) {
      me._minWidth = null;
    } else {
      me._minWidth = Number(minWidth);
      if (!me.isAlignRectangle) {
        me.width = Math.max(me.width, me._minWidth);
      }
    }
  }
  get minWidth() {
    return this._minWidth;
  }
  set minHeight(minHeight) {
    const me = this;
    if (isNaN(minHeight)) {
      me._minHeight = null;
    } else {
      me._minHeight = Number(minHeight);
      if (!me.isAlignRectangle) {
        me.height = Math.max(me.height, me._minHeight);
      }
    }
  }
  get minHeight() {
    return this._minHeight;
  }
  adjust(x, y, width, height) {
    const me = this;
    me.x += x;
    me.y += y;
    me.width += width;
    me.height += height;
    return me;
  }
  inflate(top, right = top, bottom = top, left = right) {
    if (Array.isArray(top)) {
      [top, right, bottom, left] = parseEdges(top);
    }
    return this.adjust(-left, -top, right, bottom);
  }
  deflate(top, right = top, bottom = top, left = right) {
    if (Array.isArray(top)) {
      [top, right, bottom, left] = parseEdges(top);
    }
    return this.adjust(left, top, -right, -bottom);
  }
  constrainTo(constrainTo, strict) {
    const me = this, originalHeight = me.height, originalY = me.y, minWidth = me.minWidth || me.width, minHeight = me.minHeight || me.height;
    if (me.height >= constrainTo.height) {
      if (strict && minHeight > constrainTo.height) {
        return false;
      }
      me._y = constrainTo.y;
      me.height = constrainTo.height;
    }
    if (me.width >= constrainTo.width) {
      if (strict && minWidth > constrainTo.width) {
        me.y = originalY;
        me.height = originalHeight;
        return false;
      }
      me._x = constrainTo.x;
      me.width = constrainTo.width;
    }
    let overflow = me.bottom - constrainTo.bottom;
    if (overflow > 0) {
      me.translate(0, -overflow);
    }
    overflow = me.right - constrainTo.right;
    if (overflow > 0) {
      me.translate(-overflow);
    }
    overflow = constrainTo.y - me.y;
    if (overflow > 0) {
      me.translate(0, overflow);
    }
    overflow = constrainTo.x - me.x;
    if (overflow > 0) {
      me.translate(overflow);
    }
    return me;
  }
  alignTo(spec) {
    let result = this.clone(), {
      target,
      constrainTo,
      constrainPadding
    } = spec, calculatedAnchorPosition, zone, resultZone, constrainingToViewport;
    if (target && !target.isRectangle) {
      target = Rectangle.from(target.element ? target.element : target);
    }
    if (constrainTo) {
      if (!constrainTo.isRectangle) {
        constrainingToViewport = constrainTo === globalThis || constrainTo === document;
        const ignorePageScroll = "ignorePageScroll" in spec ? spec.ignorePageScroll : !constrainingToViewport;
        constrainTo = Rectangle.from(constrainTo.element ? constrainTo.element : constrainTo, null, ignorePageScroll);
      }
      if (constrainPadding) {
        constrainPadding = parseEdges(constrainPadding);
        constrainPadding[0] = Math.min(constrainPadding[0], target.top);
        constrainPadding[1] = Math.min(constrainPadding[1], constrainTo.right - target.right);
        constrainPadding[2] = Math.min(constrainPadding[0], constrainTo.bottom - target.bottom);
        constrainPadding[3] = Math.min(constrainPadding[0], target.left);
        constrainTo = constrainTo.deflate.apply(constrainTo.clone(), constrainPadding);
      }
    }
    const me = this, targetOffsets = createOffsets(spec.offset), {
      align,
      axisLock,
      anchorSize,
      anchorPosition,
      matchSize,
      position,
      rtl
    } = spec, alignSpec = parseAlign(align, rtl), targetConstrainRect = constrainTo && constrainTo.clone(), constraintZones = [], zoneOrder = [{
      zone: zone = alignSpec.startZone,
      align
    }], matchDimension = matchSize && matchDimensions[alignSpec.startZone & 1], originalSize = me[matchDimension];
    if (matchDimension && axisLock) {
      result[matchDimension] = target[matchDimension];
    } else if (!alignSpec.edgeAligned && matchSize) {
      result.width = target.width;
      result.height = target.height;
    }
    if (constrainTo) {
      result.constrainTo(constrainTo);
    }
    if (constrainTo && alignSpec.startZone != null) {
      if (axisLock) {
        zoneOrder.push({
          zone: zone = (zone + 2) % 4,
          align: flipAlign(alignSpec)
        });
        if (axisLock === "flexible") {
          zoneOrder.push({
            zone: zone = (alignSpec.startZone + 1) % 4,
            align: defaultAlignments[zone]
          });
          zoneOrder.push({
            zone: zone = (zone + 2) % 4,
            align: defaultAlignments[zone]
          });
        }
      } else {
        for (let i = 1; i < 4; i++) {
          zoneOrder.push({
            zone: zone = (zone + 1) % 4,
            align: defaultAlignments[zone]
          });
        }
      }
    }
    if (anchorPosition) {
      const pos = alignSpec.startZone & 1 ? "y" : "x";
      calculatedAnchorPosition = {
        [pos]: anchorPosition[pos],
        edge: edgeNames[(alignSpec.startZone + 2) % 4]
      };
    }
    if (targetConstrainRect && target) {
      targetConstrainRect.adjust(-target.width, -target.height, target.width, target.height);
      target.constrainTo(targetConstrainRect);
    }
    result.minWidth = me.minWidth;
    result.minHeight = me.minHeight;
    if (position) {
      result.moveTo(position.x, position.y);
      if (constrainTo) {
        result.constrainTo(constrainTo);
      }
    } else {
      const centerAligned = alignSpec.myEdge === "c" || alignSpec.targetEdge === "c", offsets = anchorSize && !centerAligned ? [anchorSize[1] + targetOffsets[0], anchorSize[1] + targetOffsets[1]] : targetOffsets, targetPoint = target.getAlignmentPoint(alignSpec.targetAlignmentPoint, offsets), myPoint = result.getAlignmentPoint(alignSpec.myAlignmentPoint);
      result.translate(targetPoint[0] - myPoint[0], targetPoint[1] - myPoint[1]);
      let overlap = result.intersect(target, true);
      if (overlap) {
        if (constrainTo) {
          result.constrainTo(constrainTo);
        }
        resultZone = alignSpec.startZone;
        result.translate(...offsets);
      } else if (constrainTo && !constrainTo.contains(result)) {
        const requestedResult = result.clone(), solutions = [];
        let zone2, largestZone;
        calculatedAnchorPosition = null;
        constraintZones[0] = zone2 = constrainTo.clone();
        zone2.bottom = target.y - offsets[1];
        constraintZones[1] = zone2 = constrainTo.clone();
        zone2.x = target.right + offsets[0];
        constraintZones[2] = zone2 = constrainTo.clone();
        zone2.y = target.bottom + offsets[1];
        constraintZones[3] = zone2 = constrainTo.clone();
        zone2.right = target.x - offsets[0];
        for (let i = 0; i < zoneOrder.length; i++) {
          if (matchDimension && i == 2) {
            result[matchDimension] = originalSize;
          }
          zone2 = constraintZones[resultZone = zoneOrder[i].zone];
          result = result.alignTo({
            target,
            offsets,
            align: zoneOrder[i].align
          });
          if (result.constrainTo(zone2, true)) {
            solutions.push({
              result,
              zone: resultZone
            });
            if (!largestZone || result.width < me.width || result.height < me.height) {
              result.align = zoneOrder[i].align;
              break;
            }
          }
          if (!largestZone || zone2.area > largestZone.area) {
            const r = result.clone();
            switch (resultZone) {
              case 0:
                r.moveTo(null, zone2.bottom - r.height);
                break;
              case 1:
                r.moveTo(zone2.left);
                break;
              case 2:
                r.moveTo(null, zone2.top);
                break;
              case 3:
                r.moveTo(zone2.right - r.width);
                break;
            }
            largestZone = {
              area: zone2.area,
              result: r,
              zone: resultZone
            };
          }
        }
        if (solutions.length) {
          if (solutions.length > 1 && !axisLock) {
            solutions.sort((s12, s22) => {
              const s1TranslationDistance = Math.sqrt((requestedResult.x - s12.result.x) ** 2 + (requestedResult.y - s12.result.y) ** 2), s2TranslationDistance = Math.sqrt((requestedResult.x - s22.result.x) ** 2 + (requestedResult.y - s22.result.y) ** 2);
              return s1TranslationDistance - s2TranslationDistance;
            });
          }
          result = solutions[0].result;
          resultZone = solutions[0].zone;
        } else {
          result = largestZone.result;
          resultZone = largestZone.zone;
          if (constrainingToViewport) {
            result.constrainTo(constrainTo);
          }
        }
      } else {
        resultZone = alignSpec.startZone;
      }
      result.zone = resultZone;
      result.overlap = overlap = result.intersect(target, true);
      if (anchorSize && !overlap) {
        if (!calculatedAnchorPosition) {
          const isLeftOrRight = resultZone & 1, start = isLeftOrRight ? "y" : "x", end = isLeftOrRight ? "bottom" : "right", startValue = Math.max(target[start], result[start]), endValue = Math.min(target[end], result[end]);
          let anchorStart = startValue + (endValue - startValue) / 2 - anchorSize[0] / 2;
          const anchorEnd = anchorStart + anchorSize[0];
          if (anchorEnd > result[end]) {
            anchorStart -= anchorEnd - result[end];
          }
          if (anchorStart < result[start]) {
            anchorStart += result[start] - anchorStart;
          }
          calculatedAnchorPosition = {
            [start]: anchorStart - result[start],
            edge: edgeNames[(resultZone + 2) % 4]
          };
        }
        result.anchor = calculatedAnchorPosition;
      }
    }
    return result;
  }
  getAlignmentPoint(alignmentPoint, margins = zeroOffsets) {
    const me = this, parts = alignPointRe.exec(alignmentPoint), edge = parts[1].toLowerCase(), edgeOffset = Math.min(Math.max(parseInt(parts[2] || 50), 0), 100) / 100;
    switch (edge) {
      case "t":
        return [me.x + me.width * edgeOffset, me.y - margins[1]];
      case "r":
        return [me.right + margins[0], me.y + me.height * edgeOffset];
      case "b":
        return [me.x + me.width * edgeOffset, me.bottom + margins[1]];
      case "l":
        return [me.x - margins[0], me.y + me.height * edgeOffset];
      case "c": {
        return [me.x + me.width / 2, me.y + me.height / 2];
      }
    }
  }
  highlight() {
    const me = this, highlightElement = DomHelper.createElement({
      parent: document.body,
      style: `position:absolute;z-index:9999999;pointer-events:none;
                            left:${me.x}px;top:${me.y}px;width:${me.width}px;height:${me.height}px`
    });
    return DomHelper.highlight(highlightElement).then(() => highlightElement.remove());
  }
  visualize(config, asDomConfig) {
    const me = this, domConfig = ObjectHelper.merge({
      style: _objectSpread2({
        left: `${me.x}px`,
        top: `${me.y}px`,
        width: `${me.width}px`,
        height: `${me.height}px`,
        pointerEvents: "none"
      }, config.class ? {} : {
        position: "absolute",
        "z-index": 9999999
      })
    }, config);
    return asDomConfig ? domConfig : DomHelper.createElement(domConfig);
  }
  toString(delimiter = ",") {
    return [`${this.top}px`, `${this.right}px`, `${this.bottom}px`, `${this.left}px`].join(delimiter);
  }
};
Rectangle._$name = "Rectangle";
var valueSymbol = Symbol("value");
var lengthSymbol = Symbol("length");
var DomClassList = class {
  static change(cls, add, remove, as = "string") {
    remove = DomClassList.normalize(remove, "object");
    const after = DomClassList.normalize(cls, "array").filter((c) => !remove[c]);
    if (add) {
      add = DomClassList.normalize(add, "array");
      for (let i = 0; i < add.length; ++i) {
        if (!after.includes(add[i])) {
          after.push(add[i]);
        }
      }
    }
    return DomClassList.normalize(after, as);
  }
  static from(classes, returnEmpty) {
    if (classes) {
      if (classes.isDomClassList) {
        var _returnEmpty;
        returnEmpty = (_returnEmpty = returnEmpty) !== null && _returnEmpty !== void 0 ? _returnEmpty : true;
      } else {
        var _returnEmpty2;
        returnEmpty = (_returnEmpty2 = returnEmpty) !== null && _returnEmpty2 !== void 0 ? _returnEmpty2 : Objects.isObject(classes) && !Objects.isEmpty(classes);
        classes = new DomClassList(classes);
      }
      if (!classes.value && !returnEmpty) {
        classes = null;
      }
    }
    return classes || (returnEmpty ? new DomClassList() : null);
  }
  static normalize(cls, as = "string") {
    cls = cls || "";
    const type = typeof cls, asArray = as === "array", asObject = as === "object", asString = !asArray && !asObject;
    let isString = type === "string", c, i, ret;
    if (type === "object") {
      var _cls;
      if (cls.nodeType === Element.ELEMENT_NODE && typeof cls.getAttribute === "function") {
        cls = cls.getAttribute("class") || "";
        isString = true;
      } else if ((_cls = cls) !== null && _cls !== void 0 && _cls.isDomClassList) {
        cls = cls.values;
      } else if (cls instanceof DOMTokenList) {
        cls = Array.from(cls);
      } else if (cls instanceof Map) {
        cls = Array.from(cls.keys()).filter((k) => cls.get(k));
      } else if (cls instanceof Set) {
        cls = Array.from(cls);
      } else if (!Array.isArray(cls)) {
        cls = Objects.getTruthyKeys(cls);
      }
    }
    if (isString) {
      cls = [...new Set(StringHelper.split(cls))];
    }
    for (i = cls.length; i-- > 0; ) {
      c = cls[i];
      if (!c.length) {
        cls.splice(i, 1);
      } else if (c.includes(" ")) {
        cls.splice(i, 1, ...StringHelper.split(c));
      }
    }
    if (asArray) {
      ret = cls;
    } else if (asString) {
      ret = cls.join(" ");
    } else {
      ret = /* @__PURE__ */ Object.create(null);
      for (i = 0; i < cls.length; ++i) {
        ret[cls[i]] = true;
      }
    }
    return ret;
  }
  constructor(...classes) {
    this.process(1, classes);
  }
  clear() {
    for (const key in this) {
      this[key] = false;
    }
    return this;
  }
  set(...classes) {
    return this.clear().process(1, classes);
  }
  get isDomClassList() {
    return true;
  }
  clone() {
    return new DomClassList(this);
  }
  contains(className) {
    if (typeof className === "string" && className) {
      return Boolean(this[className]);
    }
    return false;
  }
  toString() {
    return this.length ? `${this.value} ` : "";
  }
  toJSON() {
    return this.toString();
  }
  trim() {
    return this.value;
  }
  isEqual(other) {
    const otherClasses = DomClassList.normalize(other, "array"), len = otherClasses.length;
    if (this.length === len) {
      for (let i = 0; i < len; i++) {
        if (!this[otherClasses[i]]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  get value() {
    let value = this[valueSymbol], keys;
    if (value == null) {
      keys = Objects.getTruthyKeys(this);
      this[lengthSymbol] = keys.length;
      this[valueSymbol] = value = keys.join(" ");
    }
    return value;
  }
  set value(value) {
    const me = this, keys = Object.keys(me), len = keys.length;
    for (let i = 0; i < len; i++) {
      delete me[keys[i]];
    }
    if (value) {
      me.process(1, [value]);
    } else {
      delete me[valueSymbol];
    }
  }
  get values() {
    return Objects.getTruthyKeys(this);
  }
  get length() {
    return this.value ? this[lengthSymbol] : 0;
  }
  process(value, classes) {
    for (let cls, k, i = 0; i < classes.length; i++) {
      if (classes[i]) {
        cls = classes[i];
        if (cls.isDomClassList || Objects.isObject(cls)) {
          for (k in cls) {
            this[k] = value ? cls[k] : !cls[k];
          }
        } else {
          cls = DomClassList.normalize(classes[i], "array");
          for (k = 0; k < cls.length; ++k) {
            this[cls[k]] = value;
          }
        }
      }
    }
    delete this[valueSymbol];
    return this;
  }
  assign(classList) {
    for (const cls in classList) {
      if (!this[cls] !== !classList[cls]) {
        this[cls] = classList[cls];
        delete this[valueSymbol];
      }
    }
    return this;
  }
  assignTo(element) {
    const classList = element.nodeType === Element.ELEMENT_NODE ? element.classList : element, temp = DomClassList.from(classList);
    temp.add(this);
    classList.value = temp.value;
  }
  add(...classes) {
    return this.process(1, classes);
  }
  remove(...classes) {
    return this.process(0, classes);
  }
  toggle(className, flag = Boolean(!this[className])) {
    flag = Boolean(flag);
    if (Boolean(this[className]) !== flag) {
      this[className] = flag;
      delete this[valueSymbol];
      return true;
    }
  }
  split() {
    return Objects.getTruthyKeys(this);
  }
  forEach(fn2) {
    return Objects.getTruthyKeys(this).forEach(fn2);
  }
};
DomClassList.prototype[valueSymbol] = null;
DomClassList._$name = "DomClassList";
var Point = class extends Rectangle {
  static from(event) {
    const touchPoints = event.changedTouches;
    return new Point(touchPoints ? touchPoints[0].screenX : event.screenX, touchPoints ? touchPoints[0].screenY : event.pageY);
  }
  constructor(x, y) {
    super(x, y, 0, 0);
  }
  constrain(into) {
    this.x = Math.min(Math.max(this.x, into.x), into.right - 1);
    this.y = Math.min(Math.max(this.y, into.y), into.bottom - 1);
    return this;
  }
  toArray() {
    return [this.x, this.y];
  }
};
Object.getPrototypeOf(Point).Point = Point;
Point._$name = "Point";
var touchProperties = ["clientX", "clientY", "pageX", "pageY", "screenX", "screenY"];
var isOption = {
  element: 1,
  thisObj: 1,
  once: 1,
  delegate: 1,
  delay: 1,
  capture: 1,
  passive: 1,
  throttled: 1,
  autoDetach: 1,
  expires: 1,
  block: 1
};
var configurable = true;
var returnTrueProp = {
  configurable,
  value: true
};
var normalizedKeyNames = {
  Spacebar: "Space",
  Del: "Delete",
  Esc: "Escape",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown"
};
var ignoreModifierKeys = {
  Meta: 1,
  Control: 1,
  Alt: 1
};
var specialKeys = {
  Control: "ctrl",
  Alt: "alt",
  Shift: "shift"
};
var longpressMoveThreshold = 5;
var specialKeyRe = /^(ctrl|shift|alt|meta)$/;
var EventHelper = class {
  static normalizeEvent(event) {
    return ObjectHelper.copyPropertiesIf(event, event.changedTouches[0] || event.touches[0], touchProperties);
  }
  static getXY(event) {
    if (event.touches) {
      event = event.touches[0];
    }
    return [event.clientX, event.clientY];
  }
  static getDistanceBetween(event1, event2) {
    const xy1 = EH.getXY(event1), xy2 = EH.getXY(event2);
    return Math.sqrt(Math.pow(xy1[0] - xy2[0], 2) + Math.pow(xy1[1] - xy2[1], 2));
  }
  static getPagePoint(event) {
    return new Rectangle.Point(event.pageX, event.pageY);
  }
  static getClientPoint(event) {
    return new Rectangle.Point(event.clientX, event.clientY);
  }
  static addListener(element, eventName, handler, options) {
    if (element.nodeType) {
      if (typeof eventName === "string") {
        options = Object.assign({
          element,
          [eventName]: handler
        }, options);
      } else {
        options = Object.assign({
          element
        }, eventName);
      }
    } else {
      options = element;
    }
    return EH.on(options);
  }
  static on(options) {
    const element = options.element, thisObj = options.thisObj, handlerDetails = [];
    for (const eventName in options) {
      if (!isOption[eventName]) {
        let handlerSpec = options[eventName];
        if (typeof handlerSpec !== "object") {
          handlerSpec = {
            handler: handlerSpec
          };
        }
        const targetElement = handlerSpec.element || element;
        if (BrowserHelper.isTouchDevice && !BrowserHelper.isAndroid) {
          if (eventName === "contextmenu") {
            handlerDetails.push(EH.addElementListener(targetElement, "touchstart", {
              handler: EH.createContextMenuWrapper(handlerSpec.handler, handlerSpec.thisObj || thisObj)
            }, options));
          }
        }
        handlerDetails.push(EH.addElementListener(targetElement, eventName, handlerSpec, options));
      }
    }
    const detacher2 = () => {
      for (let handlerSpec, i = 0; i < handlerDetails.length; i++) {
        handlerSpec = handlerDetails[i];
        EH.removeEventListener(handlerSpec[0], handlerSpec[1], handlerSpec[2]);
      }
      handlerDetails.length = 0;
    };
    if (thisObj && options.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, detacher2, thisObj);
    }
    return detacher2;
  }
  static addElementListener(element, eventName, handlerSpec, defaults) {
    const handler = EH.createHandler(element, eventName, handlerSpec, defaults), {
      spec
    } = handler, expires = handlerSpec.expires || defaults.expires, options = spec.capture != null || spec.passive != null ? {
      capture: spec.capture,
      passive: spec.passive
    } : void 0;
    element.addEventListener(eventName, handler, options);
    if (expires) {
      const thisObj = handlerSpec.thisObj || defaults.thisObj, delayable = thisObj !== null && thisObj !== void 0 && thisObj.isDelayable ? thisObj : globalThis, {
        alt: alt2
      } = expires, delay2 = alt2 ? expires.delay : expires, {
        spec: spec2
      } = handler;
      spec2.expires = expires;
      spec2.timerId = delayable[typeof delay2 === "number" ? "setTimeout" : "requestAnimationFrame"](() => {
        spec2.timerId = null;
        EH.removeEventListener(element, eventName, handler);
        if (alt2 && !handler.called) {
          (typeof alt2 === "string" ? thisObj[alt2] : alt2).call(thisObj);
        }
      }, delay2, `listener-timer-${performance.now()}`);
    }
    return [element, eventName, handler, options];
  }
  static getComposedPathTarget(event) {
    return event.composedPath()[0] || event.path[0];
  }
  static fixEvent(event) {
    var _target$getRootNode, _event$relatedTarget;
    if (event.fixed) {
      return event;
    }
    const {
      type,
      target
    } = event;
    if ((target !== null && target !== void 0 && target.shadowRoot || target !== null && target !== void 0 && (_target$getRootNode = target.getRootNode) !== null && _target$getRootNode !== void 0 && _target$getRootNode.call(target).host) && event.composedPath) {
      const targetElement = this.getComposedPathTarget(event), originalTarget = target;
      Object.defineProperty(event, "target", {
        value: targetElement,
        configurable
      });
      Object.defineProperty(event, "originalTarget", {
        value: originalTarget,
        configurable
      });
    }
    Object.defineProperty(event, "fixed", returnTrueProp);
    if (type.startsWith("key")) {
      const normalizedKeyName = normalizedKeyNames[event.key];
      if (normalizedKeyName) {
        Object.defineProperty(event, "key", {
          value: normalizedKeyName,
          configurable
        });
      }
      if (event.key === " " && !event.code) {
        Object.defineProperty(event, "code", {
          value: "Space",
          configurable
        });
      }
    }
    if (event.metaKey && !event.ctrlKey) {
      Object.defineProperty(event, "ctrlKey", returnTrueProp);
    }
    if (target && "offsetX" in event) {
      if (!Object.getOwnPropertyDescriptor(event, "borderOffsetX")) {
        Object.defineProperty(event, "borderOffsetX", {
          get: () => {
            return event.offsetX + (BrowserHelper.isSafari ? 0 : parseInt(target.ownerDocument.defaultView.getComputedStyle(target).getPropertyValue("border-left-width")));
          }
        });
      }
      if (!Object.getOwnPropertyDescriptor(event, "borderOffsetY")) {
        Object.defineProperty(event, "borderOffsetY", {
          get: () => {
            return event.offsetY + (BrowserHelper.isSafari ? 0 : parseInt(target.ownerDocument.defaultView.getComputedStyle(target).getPropertyValue("border-top-width")));
          }
        });
      }
    }
    if ((target === null || target === void 0 ? void 0 : target.nodeType) === Element.DOCUMENT_NODE && "clientX" in event) {
      const targetElement = DomHelper.elementFromPoint(event.clientX, event.clientY);
      Object.defineProperty(event, "target", {
        value: targetElement,
        configurable
      });
    }
    if ((target === null || target === void 0 ? void 0 : target.nodeType) === Element.TEXT_NODE) {
      const targetElement = event.target.parentElement;
      Object.defineProperty(event, "target", {
        value: targetElement,
        configurable
      });
    }
    if (((_event$relatedTarget = event.relatedTarget) === null || _event$relatedTarget === void 0 ? void 0 : _event$relatedTarget.nodeType) === Element.TEXT_NODE) {
      const relatedTargetElement = event.target.parentElement;
      Object.defineProperty(event, "relatedTarget", {
        value: relatedTargetElement,
        configurable
      });
    }
    if (type.startsWith("touch") && event.touches.length) {
      this.normalizeEvent(event);
    }
    return event;
  }
  static createHandler(element, eventName, handlerSpec, defaults) {
    const delay2 = handlerSpec.delay || defaults.delay, throttled = handlerSpec.throttled || defaults.throttled, block = handlerSpec.block || defaults.block, once = "once" in handlerSpec ? handlerSpec.once : defaults.once, capture = "capture" in handlerSpec ? handlerSpec.capture : defaults.capture, passive = "passive" in handlerSpec ? handlerSpec.passive : defaults.passive, delegate = "delegate" in handlerSpec ? handlerSpec.delegate : defaults.delegate, wrappedFn = handlerSpec.handler, expires = handlerSpec.expires, thisObj = handlerSpec.thisObj || defaults.thisObj, {
      rtlSource = thisObj
    } = thisObj || {};
    let handler = (event, ...args) => {
      if (EH.playingDemo && event.isTrusted) {
        return;
      }
      if (thisObj !== null && thisObj !== void 0 && thisObj.isDestroyed) {
        return;
      }
      event = EH.fixEvent(event, rtlSource === null || rtlSource === void 0 ? void 0 : rtlSource.rtl);
      handler.called = true;
      (typeof wrappedFn === "string" ? thisObj[wrappedFn] : wrappedFn).call(thisObj, event, ...args);
      delete event.target;
      delete event.relatedTarget;
      delete event.originalarget;
      delete event.key;
      delete event.code;
      delete event.ctrlKey;
      delete event.fixed;
    };
    if (block) {
      const wrappedFn2 = handler;
      let lastCallTime, lastTarget;
      handler = (e, ...args) => {
        const now2 = performance.now();
        if (!lastCallTime || e.target !== lastTarget || now2 - lastCallTime > block) {
          lastTarget = e.target;
          lastCallTime = now2;
          wrappedFn2(e, ...args);
        }
      };
    }
    if (delay2 != null) {
      const wrappedFn2 = handler, delayable = thisObj !== null && thisObj !== void 0 && thisObj.setTimeout ? thisObj : globalThis;
      handler = (...args) => {
        delayable.setTimeout(() => {
          wrappedFn2(...args);
        }, delay2);
      };
    }
    if (throttled != null) {
      let alt2, buffer = throttled;
      if (throttled.buffer) {
        alt2 = (e) => {
          return throttled.alt.call(EH, EH.fixEvent(e, rtlSource === null || rtlSource === void 0 ? void 0 : rtlSource.rtl));
        };
        buffer = throttled.buffer;
      }
      if (thisObj !== null && thisObj !== void 0 && thisObj.isDelayable) {
        handler = thisObj.throttle(handler, {
          delay: buffer,
          throttled: alt2
        });
      } else {
        handler = FunctionHelper.createThrottled(handler, buffer, thisObj, null, alt2);
      }
    }
    if (once) {
      const wrappedFn2 = handler;
      handler = (...args) => {
        EH.removeEventListener(element, eventName, handler);
        wrappedFn2(...args);
      };
    }
    if (delegate) {
      const wrappedFn2 = handler;
      handler = (event, ...args) => {
        var _event$target$closest;
        event = EH.fixEvent(event, rtlSource === null || rtlSource === void 0 ? void 0 : rtlSource.rtl);
        const delegatedTarget = ((_event$target$closest = event.target.closest) === null || _event$target$closest === void 0 ? void 0 : _event$target$closest.call) && event.target.closest(delegate);
        if (!delegatedTarget) {
          return;
        }
        Object.defineProperty(event, "currentTarget", {
          get: () => delegatedTarget,
          configurable: true
        });
        wrappedFn2(event, ...args);
      };
    }
    if (handlerSpec.thisObj && handlerSpec.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, () => EH.removeEventListener(element, eventName, handler), thisObj);
    }
    handler.spec = {
      delay: delay2,
      throttled,
      block,
      once,
      thisObj,
      capture,
      expires,
      passive,
      delegate
    };
    return handler;
  }
  static removeEventListener(element, eventName, handler) {
    const {
      expires,
      timerId,
      thisObj,
      capture
    } = handler.spec;
    if (expires !== null && expires !== void 0 && expires.alt && timerId) {
      const delayable = thisObj !== null && thisObj !== void 0 && thisObj.isDelayable ? thisObj : globalThis;
      delayable[typeof expires.delay === "number" ? "clearTimeout" : "cancelAnimationFrame"](timerId);
    }
    element.removeEventListener(eventName, handler, capture);
  }
  static onTransitionEnd({
    element,
    animationName,
    property,
    handler,
    mode = animationName ? "animation" : "transition",
    duration = DomHelper[`get${mode === "transition" ? "Property" : ""}${StringHelper.capitalize(mode)}Duration`](element, property),
    thisObj = globalThis,
    args = [],
    timerSource,
    runOnDestroy
  }) {
    let timerId;
    timerSource = timerSource || (thisObj.isDelayable ? thisObj : globalThis);
    const callbackArgs = [element, property, ...args], doCallback = () => {
      detacher2();
      if (!thisObj.isDestroyed) {
        if (thisObj.callback) {
          thisObj.callback(handler, thisObj, callbackArgs);
        } else {
          handler.apply(thisObj, callbackArgs);
        }
      }
    }, detacher2 = EH.on({
      element,
      [`${mode}end`]({
        animationName: endedAnimation,
        propertyName,
        target
      }) {
        if (target === element) {
          if (propertyName === property || endedAnimation !== null && endedAnimation !== void 0 && endedAnimation.match(animationName)) {
            if (timerId) {
              timerSource.clearTimeout(timerId);
              timerId = null;
            }
            doCallback();
          }
        }
      }
    });
    if (duration != null) {
      timerId = timerSource.setTimeout(doCallback, duration + 50, "onTransitionEnd", runOnDestroy);
    }
    return detacher2;
  }
  static async waitForTransitionEnd(config) {
    return new Promise((resolve) => {
      config.handler = resolve;
      EventHelper.onTransitionEnd(config);
    });
  }
  static createContextMenuWrapper(handler, thisObj) {
    return (event) => {
      if (event.touches.length === 1) {
        if (event.target.closest("[data-feature]")) {
          return;
        }
        const tapholdStartTouch = event.touches[0], tapholdTimer = setTimeout(() => {
          touchMoveRemover();
          const contextmenuEvent = new MouseEvent("contextmenu", tapholdStartTouch);
          Object.defineProperty(contextmenuEvent, "target", {
            get() {
              return tapholdStartTouch.target;
            }
          });
          if (typeof handler === "string") {
            handler = thisObj[handler];
          }
          contextmenuEvent.browserEvent = event;
          handler.call(thisObj, contextmenuEvent);
          EH.contextMenuTouchId = tapholdStartTouch.identifier;
        }, EH.longPressTime), onMoveOrPointerUp = ({
          clientX,
          clientY,
          type
        }) => {
          let cancel = type === "touchend" || type === "pointerup";
          if (!cancel) {
            const deltaX = Math.abs(clientX - tapholdStartTouch.clientX), deltaY = Math.abs(clientY - tapholdStartTouch.clientY);
            cancel = deltaX >= longpressMoveThreshold || deltaY >= longpressMoveThreshold;
          }
          if (cancel) {
            EH.contextMenuTouchId = null;
            touchMoveRemover();
            clearTimeout(tapholdTimer);
          }
        }, touchMoveRemover = EH.on({
          element: document,
          touchmove: onMoveOrPointerUp,
          touchend: onMoveOrPointerUp,
          pointermove: onMoveOrPointerUp,
          pointerup: onMoveOrPointerUp,
          capture: true
        });
      }
    };
  }
  static createDblClickWrapper(element, handler, thisObj) {
    let startId, secondListenerDetacher, tapholdTimer;
    return () => {
      if (!secondListenerDetacher) {
        secondListenerDetacher = EH.on({
          element,
          touchstart: (secondStart) => {
            startId = secondStart.changedTouches[0].identifier;
            secondStart.preventDefault();
          },
          touchend: (secondClick) => {
            if (secondClick.changedTouches[0].identifier === startId) {
              secondClick.preventDefault();
              clearTimeout(tapholdTimer);
              startId = secondListenerDetacher = null;
              const targetRect = Rectangle.from(secondClick.changedTouches[0].target, null, true), offsetX = secondClick.changedTouches[0].pageX - targetRect.x, offsetY = secondClick.changedTouches[0].pageY - targetRect.y, dblclickEventConfig = Object.assign({
                browserEvent: secondClick
              }, secondClick), dblclickEvent = new MouseEvent("dblclick", dblclickEventConfig);
              Object.defineProperties(dblclickEvent, {
                target: {
                  value: secondClick.target
                },
                offsetX: {
                  value: offsetX
                },
                offsetY: {
                  value: offsetY
                }
              });
              if (typeof handler === "string") {
                handler = thisObj[handler];
              }
              handler.call(thisObj, dblclickEvent);
            }
          },
          once: true
        });
        tapholdTimer = setTimeout(() => {
          secondListenerDetacher();
          startId = secondListenerDetacher = null;
        }, EH.dblClickTime);
      }
    };
  }
  static toSpecialKey(value, defaultValue2 = "ctrlKey") {
    let result = false;
    if (value === true) {
      result = defaultValue2;
    } else if (typeof value === "string") {
      value = value.toLowerCase();
      if (value.match(specialKeyRe)) {
        result = `${value}Key`;
      }
    }
    return result;
  }
  static specialKeyFromEventKey(code) {
    return specialKeys[code] || "";
  }
};
_defineProperty(EventHelper, "eventNameMap", {
  mousedown: "MouseDown",
  mouseup: "MouseUp",
  click: "Click",
  dblclick: "DblClick",
  contextmenu: "ContextMenu",
  mouseover: "MouseOver",
  mouseout: "MouseOut",
  keyup: "KeyUp",
  keydown: "KeyDown",
  keypress: "KeyPress"
});
var EH = EventHelper;
EH.longPressTime = 500;
EH.dblClickTime = 300;
EH.globalListenerDetacher = EH.on({
  element: document,
  capture: true,
  passive: true,
  pointerdown({
    target
  }) {
    var _rootEl$classList;
    const rootEl = DomHelper.getRootElement(target);
    DomHelper.usingKeyboard = false;
    (_rootEl$classList = rootEl.classList) === null || _rootEl$classList === void 0 ? void 0 : _rootEl$classList.remove("b-using-keyboard");
    DomHelper.removeClsGlobally(rootEl, "b-using-keyboard");
  },
  keydown({
    target,
    key
  }) {
    if (!ignoreModifierKeys[key]) {
      DomHelper.usingKeyboard = true;
      const rootElement = DomHelper.getRootElement(target);
      if (rootElement.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        Array.from(rootElement.children).forEach((node) => {
          if (node.matches(".b-outer")) {
            node.classList.add("b-using-keyboard");
          }
        });
      } else {
        rootElement.classList.add("b-using-keyboard");
      }
    }
  }
});
if (BrowserHelper.isTouchDevice) {
  EH.on({
    element: document,
    touchmove: (event) => {
      if (event.target.closest(".b-dragging")) {
        event.preventDefault();
      }
    },
    passive: false,
    capture: true
  });
}
EventHelper._$name = "EventHelper";
var DEFAULT_FONT_SIZE = 14;
var t0t0 = {
  align: "t0-t0"
};
var ELEMENT_NODE = Node.ELEMENT_NODE;
var TEXT_NODE = Node.TEXT_NODE;
var {
  isObject: isObject$1
} = ObjectHelper;
var numberRe = /[+-]?\d*\.?\d+[eE]?-?\d*/g;
var numberReSrc = numberRe.source;
var translateMatrix2dRe = new RegExp(`matrix\\((?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(${numberReSrc}),\\s?(${numberReSrc})`);
var translateMatrix3dRe = new RegExp(`matrix3d\\((?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(-?\\d*),\\s?(-?\\d*)`);
var translateMatrixRe = new RegExp(`(?:${translateMatrix2dRe.source})|(?:${translateMatrix3dRe.source})`);
var pxTtranslateXRe = new RegExp(`translate(3d|X)?\\((${numberReSrc})px(?:,\\s?(${numberReSrc})px)?`);
var pxTtranslateYRe = new RegExp(`translate(3d|Y)?\\((${numberReSrc})px(?:,\\s?(${numberReSrc})px)?`);
var whiteSpaceRe = /\s+/;
var semicolonRe = /\s*;\s*/;
var colonRe = /\s*:\s*/;
var digitsRe$1 = /^-?((\d+(\.\d*)?)|(\.?\d+))$/;
var elementPropKey = "$bryntum";
var elementCreateExpandos = {
  elementData: "",
  for: "htmlFor",
  retainElement: ""
};
var elementCreateProperties = {
  tag: 1,
  html: 1,
  text: 1,
  children: 1,
  tooltip: 1,
  style: 1,
  dataset: 1,
  parent: 1,
  nextSibling: 1,
  ns: 1,
  reference: 1,
  class: 1,
  className: 1,
  unmatched: 1,
  onlyChildren: 1,
  listeners: 1,
  compareHtml: 1,
  syncOptions: 1,
  keepChildren: 1
};
var styleIgnoreProperties = {
  length: 1,
  parentRule: 1,
  style: 1
};
var nativeEditableTags = {
  INPUT: 1,
  TEXTAREA: 1
};
var nativeFocusableTags = {
  BUTTON: 1,
  IFRAME: 1,
  EMBED: 1,
  INPUT: 1,
  OBJECT: 1,
  SELECT: 1,
  TEXTAREA: 1,
  BODY: 1
};
var win = globalThis;
var doc = document;
var emptyObject$b = Object.freeze({});
var arraySlice$1 = Array.prototype.slice;
var immediatePromise$7 = Promise.resolve();
var fontProps = ["font-size", "font-size-adjust", "font-style", "font-weight", "font-family", "font-kerning", "font-stretch", "line-height", "text-transform", "text-decoration", "letter-spacing", "word-break"];
var isHiddenWidget = (e) => e._hidden;
var parentNode = (el) => el.parentNode || el.host;
var mergeChildren = (dest, src, options) => {
  if (options.key === "children") {
    return ObjectHelper.mergeItems(dest, src, options);
  }
  return ObjectHelper.blend(dest, src, options);
};
var isVisible = (e) => {
  const style = e.ownerDocument.defaultView.getComputedStyle(e);
  return style.getPropertyValue("display") !== "none" && style.getPropertyValue("visibility") !== "hidden";
};
var getRootNode = doc.documentElement.getRootNode ? (el) => el.getRootNode() : (el) => {
  while (el.parentNode)
    el = el.parentNode;
  return el;
};
var isShadowRoot = (el) => el.host && el.host instanceof Element;
var hasLayout = (el) => el && (el === doc.body || Boolean(el.offsetParent) || (el.ownerDocument.defaultView && "offsetParent" in el && DomHelper.getStyleValue(el, "position") !== "fixed" ? el.offsetParent : hasLayout(el.parentNode)));
var isInDocument = (el) => el && (doc.body.contains(el) || (root = getRootNode(el)) && isShadowRoot(root) && isInDocument(root.host));
var elementOrConfigToElement = (elementOrConfig) => {
  if (elementOrConfig instanceof Node) {
    return elementOrConfig;
  }
  if (typeof elementOrConfig === "string") {
    return DH$1.createElementFromTemplate(elementOrConfig);
  }
  return DH$1.createElement(elementOrConfig);
};
var canonicalStyles = /* @__PURE__ */ Object.create(null);
var canonicalizeStyle = (name, hasUnit) => {
  const entry = canonicalStyles[name] || [StringHelper.hyphenate(name), hasUnit];
  if (!canonicalStyles[name]) {
    canonicalStyles[entry[0]] = canonicalStyles[name] = entry;
  }
  return entry;
};
var getOffsetParent = (node) => node.ownerSVGElement ? node.ownerSVGElement.parentNode : node.offsetParent;
var slideInAnimationName = /b-slide-in-from-\w+/;
["top", "right", "bottom", "left", "width", "height", "maxWidth", "maxHeight", "minWidth", "minHeight", "borderSpacing", "borderWidth", "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth", "marginTop", "marginRight", "marginBottom", "marginLeft", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "fontSize", "letterSpacing", "lineHeight", "outlineWidth", "textIndent", "wordSpacing"].forEach((name) => canonicalizeStyle(name, true));
var scrollBarWidth = null;
var idCounter = 0;
var themeInfo = null;
var root;
var templateElement;
var htmlParser;
var scrollBarMeasureElement;
var DomHelper = class {
  static async slideIn(element, direction = 1) {
    const cls = `b-slide-in-${direction > 0 ? "next" : "previous"}`, {
      classList
    } = element, {
      style
    } = element.parentNode, {
      overflow,
      overflowX,
      overflowY
    } = style;
    style.overflow = "hidden";
    classList.add(cls);
    await EventHelper.waitForTransitionEnd({
      element,
      animationName: slideInAnimationName
    });
    style.overflow = overflow;
    style.overflowX = overflowX;
    style.overflowY = overflowY;
    classList.remove(cls);
  }
  static isFocusable(element, skipAccessibilityCheck = false) {
    if (!skipAccessibilityCheck) {
      if (!DH$1.isVisible(element) || DH$1.Widget.fromElement(element, isHiddenWidget)) {
        return false;
      }
    }
    const nodeName = element.nodeName;
    return nativeFocusableTags[nodeName] || (nodeName === "A" || nodeName === "LINK") && !!element.href || element.getAttribute("tabIndex") != null || element.contentEditable === "true";
  }
  static isEditable(element) {
    return element.isContentEditable || nativeEditableTags[element.nodeName];
  }
  static isInView(target, whole = false, caller) {
    if (!hasLayout(target)) {
      return false;
    }
    const positioned = (caller === null || caller === void 0 ? void 0 : caller.positioned) && DomHelper.getStyleValue(caller.element, "position") !== "fixed", docRect = Rectangle.from(globalThis), method = whole ? "contains" : "intersect", cOp = positioned && caller.element.offsetParent, cOpR = positioned && Rectangle.from(cOp);
    docRect.height = doc.scrollingElement.scrollHeight;
    if (target === doc.body) {
      return docRect;
    }
    const result = this.getViewportIntersection(target, docRect, method);
    if (result && positioned) {
      result.translate(doc.scrollingElement.scrollLeft, doc.scrollingElement.scrollTop);
    }
    return positioned && result ? result.translate(-cOpR.x + cOp.scrollLeft, -cOpR.y + cOp.scrollTop) : result;
  }
  static getViewportIntersection(target, docRect, method) {
    const {
      parentNode: parentNode2
    } = target, {
      parentElement
    } = parentNode2.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? target.getRootNode().host : target, peStyle = parentElement.ownerDocument.defaultView.getComputedStyle(parentElement), parentScroll = peStyle.overflowX !== "visible" || peStyle.overflowY !== "visible", offsetParent = getOffsetParent(target);
    let result = Rectangle.from(target, null, true);
    for (let viewport = parentScroll ? target.parentNode : offsetParent; result && viewport !== doc.documentElement; viewport = viewport.parentNode) {
      if (viewport.nodeType === Node.DOCUMENT_FRAGMENT_NODE && viewport.host) {
        viewport = viewport.host.parentNode;
      }
      const isTop = viewport === doc.body, style = viewport.ownerDocument.defaultView.getComputedStyle(viewport), viewportRect = isTop ? docRect : Rectangle.inner(viewport, null, true);
      if (isTop || style.overflow !== "visible") {
        result = viewportRect[method](result, false, true);
      }
    }
    return result;
  }
  static isVisible(element) {
    const document2 = element.ownerDocument;
    for (; element; element = parentNode(element)) {
      if (element === document2) {
        return true;
      }
      if (element.nodeType === element.ELEMENT_NODE && !isVisible(element)) {
        return false;
      }
    }
    return false;
  }
  static isDOMEvent(event) {
    return event instanceof Event;
  }
  static merge(dest, ...sources) {
    return ObjectHelper.blend(dest, sources, {
      merge: mergeChildren
    });
  }
  static normalizeChildren(domConfig, namedChildren, ignoreRefs) {
    var _domConfig$syncOption;
    let children = domConfig === null || domConfig === void 0 ? void 0 : domConfig.children, child, i, name, kids, ref;
    if (domConfig !== null && domConfig !== void 0 && (_domConfig$syncOption = domConfig.syncOptions) !== null && _domConfig$syncOption !== void 0 && _domConfig$syncOption.ignoreRefs) {
      ignoreRefs = true;
    }
    if (children && !(domConfig instanceof Node)) {
      if (Array.isArray(children)) {
        for (i = 0; i < children.length; ++i) {
          DH$1.normalizeChildren(children[i], namedChildren, ignoreRefs);
        }
      } else {
        kids = children;
        domConfig.children = children = [];
        for (name in kids) {
          var _child;
          child = kids[name];
          if ((_child = child) !== null && _child !== void 0 && _child.isWidget) {
            child = child.element;
          }
          ref = !name.startsWith("$") && !DH$1.isElement(child);
          ref && (namedChildren === null || namedChildren === void 0 ? void 0 : namedChildren(name, !ignoreRefs));
          if (child) {
            if (!(child instanceof Node)) {
              if (child.reference === false) {
                delete child.reference;
              } else if (ref && typeof child !== "string") {
                child.reference = name;
              }
              DH$1.normalizeChildren(child, namedChildren, ignoreRefs);
            }
            children.push(child);
          }
        }
      }
    }
    return domConfig;
  }
  static roundPx(px, devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const multiplier = 1 / devicePixelRatio;
    return Math.round(px / multiplier) * multiplier;
  }
  static floorPx(px, devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const multiplier = 1 / devicePixelRatio;
    return Math.floor(px * multiplier) / multiplier;
  }
  static isCustomElement(element) {
    return Boolean(element === null || element === void 0 ? void 0 : element.shadowRoot);
  }
  static elementFromPoint(x, y) {
    let el = document.elementFromPoint(x, y);
    if (DH$1.isCustomElement(el)) {
      el = el.shadowRoot.elementFromPoint(x, y) || el;
    }
    return el;
  }
  static childFromPoint(el, x, y, parent = el) {
    const p = y == null ? x : new Rectangle(x, y, 0, 0);
    let result = null;
    Array.from(el.children).some((el2) => {
      if (Rectangle.from(el2, parent).contains(p)) {
        result = el2.children.length && DH$1.childFromPoint(el2, p, null, parent) || el2;
        return true;
      }
    });
    return result;
  }
  static unitize(name, value, defaultUnit = "px") {
    const [trueName, hasUnits] = canonicalizeStyle(name);
    if (value != null) {
      value = String(value);
      value = hasUnits && digitsRe$1.test(value) ? value + defaultUnit : value;
    }
    return [trueName, value];
  }
  static get activeElement() {
    let el = document.activeElement;
    while (el.shadowRoot) {
      el = el.shadowRoot.activeElement;
    }
    return el;
  }
  static getActiveElement(element) {
    var _element, _element2;
    if ((_element = element) !== null && _element !== void 0 && _element.isWidget) {
      element = element.element;
    }
    let el = (((_element2 = element) === null || _element2 === void 0 ? void 0 : _element2.getRootNode()) || document).activeElement;
    while ((_el = el) !== null && _el !== void 0 && _el.shadowRoot) {
      var _el;
      el = el.shadowRoot.activeElement;
    }
    return el;
  }
  static getRootElement(element) {
    var _element$getRootNode;
    const root2 = (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element), {
      nodeType
    } = root2;
    return nodeType === Node.DOCUMENT_NODE ? root2.body : nodeType === Node.DOCUMENT_FRAGMENT_NODE ? root2 : element.ownerDocument.contains(element) ? element.ownerDocument.body : null;
  }
  static getOutermostElement(element) {
    var _element$getRootNode2, _element3;
    const root2 = (_element$getRootNode2 = (_element3 = element).getRootNode) === null || _element$getRootNode2 === void 0 ? void 0 : _element$getRootNode2.call(_element3);
    if (root2 !== null && root2 !== void 0 && root2.body) {
      return root2 === null || root2 === void 0 ? void 0 : root2.body;
    }
    while (element.parentNode !== root2 && element.parentNode) {
      element = element.parentNode;
    }
    return element;
  }
  static isValidFloatRootParent(target) {
    return target === document.body || target.constructor.name === "ShadowRoot";
  }
  static getId(element) {
    return element.id || (element.id = "b-element-" + ++idCounter);
  }
  static getCommonAncestor(from, to) {
    if (from === to) {
      return from;
    }
    while (from && !((_from = (_from2 = from)[from.isWidget ? "owns" : "contains"]) !== null && _from !== void 0 && _from.call(_from2, to) || from === to)) {
      var _from, _from2;
      from = from.owner || from.parentNode;
    }
    return from;
  }
  static getElement(elementOrSelector) {
    if (elementOrSelector instanceof Element) {
      return elementOrSelector;
    }
    return doc.querySelector(elementOrSelector);
  }
  static setAttributes(elementOrSelector, attributes) {
    const element = DH$1.getElement(elementOrSelector);
    if (element && attributes) {
      for (const key in attributes) {
        if (attributes[key] == null) {
          element.removeAttribute(key);
        } else {
          element.setAttribute(key, attributes[key]);
        }
      }
    }
  }
  static setLength(element, style, value) {
    if (arguments.length === 1) {
      var _element4;
      value = typeof element === "number" ? `${element}px` : (_element4 = element) !== null && _element4 !== void 0 ? _element4 : "";
    } else {
      var _value;
      element = DH$1.getElement(element);
      value = element.style[style] = typeof value === "number" ? `${value}px` : (_value = value) !== null && _value !== void 0 ? _value : "";
    }
    return value;
  }
  static percentify(value, digits = 2) {
    const mult = Math.pow(10, digits);
    return value == null || value === "" || isNaN(value) ? "" : `${Math.round(value * mult) / mult}%`;
  }
  static getChild(element, selector) {
    return element.querySelector(":scope>" + selector);
  }
  static hasChild(element, selector) {
    return DH$1.getChild(element, selector) != null;
  }
  static children(element, selector) {
    if (selector[0] === ">" || selector.startsWith("# ")) {
      if (selector[0] === "#") {
        selector = selector.substr(2);
      }
      selector = ":scope " + selector;
    }
    return Array.from(element.querySelectorAll(selector));
  }
  static getChildElementCount(element) {
    return element.childElementCount;
  }
  static down(element, selector) {
    if (!element) {
      return null;
    }
    if (element.matches && element.matches(selector)) {
      return element;
    }
    selector = ":scope " + selector;
    return element.querySelector(selector);
  }
  static isDescendant(parentElement, childElement) {
    const parentRoot = DH$1.getRootElement(parentElement), childRoot = DH$1.getRootElement(childElement);
    if (childRoot && parentRoot !== childRoot && childRoot.host) {
      return DH$1.isDescendant(parentRoot, childRoot.host);
    }
    return parentElement.contains(childElement);
  }
  static getEventElement(event, elementName = "target") {
    return !event || DH$1.isElement(event) ? event : event[elementName];
  }
  static isElement(value) {
    return (value === null || value === void 0 ? void 0 : value.nodeType) === document.ELEMENT_NODE && DH$1.isNode(value);
  }
  static isReactElement(element) {
    return (element === null || element === void 0 ? void 0 : element.$$typeof) === Symbol.for("react.element");
  }
  static isNode(value) {
    return Boolean(value) && typeof value.nodeType === "number" && !isObject$1(value);
  }
  static forEachSelector(element, selector, fn2) {
    if (typeof element === "string") {
      throw new Error("DomHelper.forEachSelector must provide a root element context (for shadow root scenario)");
    }
    DH$1.children(element, selector).forEach(fn2);
  }
  static forEachChild(element, fn2) {
    Array.from(element.children).forEach(fn2);
  }
  static removeEachSelector(element, selector) {
    DH$1.forEachSelector(element, selector, (child) => child.remove());
  }
  static removeClsGlobally(element, ...classes) {
    classes.forEach((cls) => DH$1.forEachSelector(element, "." + cls, (child) => child.classList.remove(cls)));
  }
  static isOrphaned(element) {
    return !isInDocument(element);
  }
  static up(element, selector) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.up() deprecated, use native `element.closest()` instead");
    return element.closest(selector);
  }
  static getAncestor(element, possibleAncestorParents, outerElement = null) {
    let found = false, ancestor, parent = element;
    possibleAncestorParents = ArrayHelper.asArray(possibleAncestorParents);
    while (parent = parent.parentElement) {
      if (possibleAncestorParents.includes(parent)) {
        found = true;
        break;
      }
      if (outerElement && parent === outerElement)
        break;
      ancestor = parent;
    }
    if (!found)
      return null;
    return ancestor || element;
  }
  static getParents(element) {
    const parents = [];
    while (element.parentElement) {
      parents.push(element.parentElement);
      element = element.parentElement;
    }
    return parents;
  }
  static makeValidId(id, replaceValue = "") {
    return StringHelper.makeValidDomId(id, replaceValue);
  }
  static createElement(config = {}, options) {
    var _options, _options$callback, _config$dataset;
    let returnAll = options, element, i, ignoreChildRefs, ignoreRefOption, ignoreRefs, key, name, value, refOwner, refs, syncIdField;
    if (typeof returnAll === "boolean") {
      throw new Error("Clean up");
    } else if (options) {
      ignoreRefs = options.ignoreRefs;
      refOwner = options.refOwner;
      refs = options.refs;
      returnAll = options.returnAll;
      syncIdField = options.syncIdField;
      if (ignoreRefs) {
        ignoreChildRefs = true;
        ignoreRefs = ignoreRefs !== "children";
      }
    }
    if (typeof config.parent === "string") {
      config.parent = document.getElementById(config.parent);
    }
    const parent = config.parent || config.nextSibling && config.nextSibling.parentNode, {
      dataset,
      html,
      reference,
      syncOptions,
      text
    } = config;
    if (syncOptions) {
      syncIdField = syncOptions.syncIdField || syncIdField;
      ignoreRefOption = syncOptions.ignoreRefs;
      if (ignoreRefOption) {
        ignoreChildRefs = true;
        ignoreRefs = ignoreRefOption !== "children";
        options = _objectSpread2(_objectSpread2({}, options), {}, {
          ignoreRefs: true
        });
      }
    }
    if (ignoreRefs) {
      refOwner = null;
    }
    if (config.ns) {
      element = doc.createElementNS(config.ns, config.tag || "svg");
    } else {
      element = doc.createElement(config.tag || "div");
    }
    if (text != null) {
      DH$1.setInnerText(element, text);
    } else if (html != null) {
      if (html instanceof DocumentFragment) {
        element.appendChild(html);
      } else {
        element.innerHTML = html;
      }
    }
    if (config.tooltip) {
      DH$1.Widget.attachTooltip(element, config.tooltip);
    }
    if (config.style) {
      DH$1.applyStyle(element, config.style);
    }
    if (dataset) {
      for (name in dataset) {
        value = dataset[name];
        if (value != null) {
          element.dataset[name] = value;
        }
      }
    }
    if (parent) {
      this.addChild(parent, element, config.nextSibling);
    }
    if (refOwner) {
      element.$refOwnerId = refOwner.id;
    }
    if (reference && !ignoreRefs) {
      if (refOwner) {
        element.$reference = reference;
        refOwner.attachRef(reference, element, config);
      } else {
        if (!refs) {
          options = Object.assign({}, options);
          options.refs = refs = {};
        }
        refs[reference] = element;
        element.setAttribute("data-reference", reference);
      }
    }
    const className = config.className || config.class, keys = Object.keys(config);
    if (className) {
      element.setAttribute("class", DomClassList.normalize(className));
    }
    for (i = 0; i < keys.length; ++i) {
      name = keys[i];
      value = config[name];
      if ((key = elementCreateExpandos[name]) != null) {
        element[key || name] = value;
      } else if (!elementCreateProperties[name] && name && value != null) {
        element.setAttribute(name, value);
      }
    }
    if (!config["aria-hidden"] && !config.role && !config.tabIndex && !DomHelper.isFocusable(element, true) && !element.htmlFor) {
      element.setAttribute("role", "presentation");
    }
    (_options = options) === null || _options === void 0 ? void 0 : (_options$callback = _options.callback) === null || _options$callback === void 0 ? void 0 : _options$callback.call(_options, {
      action: "newElement",
      domConfig: config,
      targetElement: element,
      syncId: refOwner ? reference : options.syncIdField && ((_config$dataset = config.dataset) === null || _config$dataset === void 0 ? void 0 : _config$dataset[options.syncIdField])
    });
    if (returnAll === true) {
      options.returnAll = returnAll = [element];
    } else if (Array.isArray(returnAll)) {
      returnAll.push(element);
    }
    if (config.children) {
      if (syncIdField) {
        element.syncIdMap = {};
      }
      config.children.forEach((child) => {
        if (child) {
          if (typeof child === "string") {
            const textNode = document.createTextNode(child);
            if (refOwner) {
              textNode.$refOwnerId = refOwner.id;
            }
            element.appendChild(textNode);
          } else if (isNaN(child.nodeType)) {
            var _config$syncOptions$i, _config$syncOptions, _child$dataset;
            child.parent = element;
            if (!child.ns && config.ns) {
              child.ns = config.ns;
            }
            const childElement = DH$1.createElement(child, _objectSpread2(_objectSpread2({}, options), {}, {
              ignoreRefs: (_config$syncOptions$i = (_config$syncOptions = config.syncOptions) === null || _config$syncOptions === void 0 ? void 0 : _config$syncOptions.ignoreRef) !== null && _config$syncOptions$i !== void 0 ? _config$syncOptions$i : ignoreChildRefs
            })), syncId = (_child$dataset = child.dataset) === null || _child$dataset === void 0 ? void 0 : _child$dataset[syncIdField];
            if (syncId != null) {
              element.syncIdMap[syncId] = childElement;
            }
            delete child.parent;
          } else {
            element.appendChild(child);
          }
        }
      });
    }
    element.lastDomConfig = config;
    return refs || returnAll || element;
  }
  static createElementFromTemplate(template, options = emptyObject$b) {
    const {
      array,
      raw,
      fragment
    } = options;
    let result;
    if (DH$1.supportsTemplate) {
      (templateElement || (templateElement = doc.createElement("template"))).innerHTML = template;
      result = templateElement.content;
      if (fragment) {
        return result.cloneNode(true);
      }
    } else {
      result = (htmlParser || (htmlParser = new DOMParser())).parseFromString(template, "text/html").body;
      if (fragment) {
        const nodes = result.childNodes;
        result = document.createDocumentFragment();
        while (nodes.length) {
          result.appendChild(nodes[0]);
        }
        return result;
      }
    }
    if (raw) {
      result = result.childNodes;
    } else {
      result = result.children;
    }
    return result.length === 1 && !array ? result[0] : arraySlice$1.call(result);
  }
  static triggerMouseEvent(targetElement, type = "contextmenu") {
    const isInView = this.isInView(targetElement), targetRect = isInView || Rectangle.from(targetElement), targetPoint = targetRect.center, contextmenuEvent = new MouseEvent(type, {
      clientX: targetPoint.x,
      clientY: targetPoint.y,
      bubbles: true
    });
    targetElement.dispatchEvent(contextmenuEvent);
  }
  static insertFirst(into, element) {
    if (element && element.nodeType !== ELEMENT_NODE && element.tag) {
      element = DH$1.createElement(element);
    }
    return into.insertBefore(element, into.firstElementChild);
  }
  static insertBefore(into, element, beforeElement) {
    if (element && element.nodeType !== ELEMENT_NODE && element.tag) {
      element = DH$1.createElement(element);
    }
    return beforeElement ? into.insertBefore(element, beforeElement) : DH$1.insertFirst(into, element);
  }
  static insertAt(parentElement, newElement, index) {
    const siblings = Array.from(parentElement.children);
    if (index >= siblings.length) {
      return DH$1.append(parentElement, newElement);
    }
    const beforeElement = siblings[index];
    return DH$1.insertBefore(parentElement, newElement, beforeElement);
  }
  static append(parentElement, elementOrConfig) {
    if (elementOrConfig.forEach) {
      if (Array.isArray(elementOrConfig)) {
        elementOrConfig = elementOrConfig.map((elementOrConfig2) => elementOrConfigToElement(elementOrConfig2));
      }
      if (parentElement.append) {
        parentElement.append(...elementOrConfig);
      } else {
        const docFrag = document.createDocumentFragment();
        elementOrConfig.forEach(function(child) {
          docFrag.appendChild(child);
        });
        parentElement.appendChild(docFrag);
      }
      return elementOrConfig;
    } else {
      return parentElement.appendChild(elementOrConfigToElement(elementOrConfig));
    }
  }
  static getTranslateX(element) {
    const transformStyle = element.style.transform;
    let matches = pxTtranslateXRe.exec(transformStyle);
    if (matches) {
      return parseFloat(matches[2]);
    } else {
      matches = translateMatrixRe.exec(transformStyle) || translateMatrixRe.exec(DH$1.getStyleValue(element, "transform"));
      return matches ? parseFloat(matches[1] || matches[3]) : 0;
    }
  }
  static getTranslateY(element) {
    const transformStyle = element.style.transform;
    let matches = pxTtranslateYRe.exec(transformStyle);
    if (matches) {
      const y = parseFloat(matches[matches[1] === "Y" ? 2 : 3]);
      return isNaN(y) ? 0 : y;
    } else {
      matches = translateMatrixRe.exec(transformStyle) || translateMatrixRe.exec(DH$1.getStyleValue(element, "transform"));
      return matches ? parseFloat(matches[2] || matches[4]) : 0;
    }
  }
  static getTranslateXY(element) {
    return [DH$1.getTranslateX(element), DH$1.getTranslateY(element)];
  }
  static getOffsetX(element, container = null) {
    return container ? element.getBoundingClientRect().left - container.getBoundingClientRect().left : element.offsetLeft;
  }
  static getOffsetY(element, container = null) {
    return container ? element.getBoundingClientRect().top - container.getBoundingClientRect().top : element.offsetTop;
  }
  static getOffsetXY(element, container = null) {
    return [DH$1.getOffsetX(element, container), DH$1.getOffsetY(element, container)];
  }
  static focusWithoutScrolling(element) {
    function resetScroll(scrollHierarchy) {
      scrollHierarchy.forEach(({
        element: element2,
        scrollLeft,
        scrollTop
      }) => {
        if (element2.scrollLeft !== scrollLeft) {
          element2.scrollLeft = scrollLeft;
        }
        if (element2.scrollTop !== scrollTop) {
          element2.scrollTop = scrollTop;
        }
      });
    }
    const preventScrollSupported = !BrowserHelper.isSafari;
    if (preventScrollSupported) {
      element.focus({
        preventScroll: true
      });
    } else {
      const parents = DH$1.getParents(element), scrollHierarchy = parents.map((parent) => ({
        element: parent,
        scrollLeft: parent.scrollLeft,
        scrollTop: parent.scrollTop
      }));
      element.focus();
      setTimeout(() => resetScroll(scrollHierarchy), 0);
    }
  }
  static getPageX(element) {
    return element.getBoundingClientRect().left + win.pageXOffset;
  }
  static getPageY(element) {
    return element.getBoundingClientRect().top + win.pageYOffset;
  }
  static getExtremalSizePX(element, style) {
    const prop = StringHelper.hyphenate(style), measure = prop.split("-")[1];
    let value = DH$1.getStyleValue(element, prop);
    if (/%/.test(value)) {
      if (element.parentElement) {
        value = parseInt(DH$1.getStyleValue(element.parentElement, measure), 10);
      } else {
        value = NaN;
      }
    } else {
      value = parseInt(value, 10);
    }
    return value;
  }
  static setScale(element, scaleX, scaleY = scaleX) {
    const t = DH$1.getStyleValue(element, "transform").split(/,\s*/);
    if (t.length > 1) {
      if (t[0].startsWith("matrix3d")) {
        t[0] = `matrix3d(${scaleX}`;
        t[5] = scaleY;
      } else {
        t[0] = `matrix(${scaleX}`;
        t[3] = scaleY;
      }
      element.style.transform = t.join(",");
    } else {
      element.style.transform = `scale(${scaleX}, ${scaleY})`;
    }
  }
  static setTranslateX(element, x) {
    const t = DH$1.getStyleValue(element, "transform").split(/,\s*/);
    x = DH$1.roundPx(x);
    if (t.length > 1) {
      t[t[0].startsWith("matrix3d") ? 12 : 4] = x;
      element.style.transform = t.join(",");
    } else {
      element.style.transform = `translateX(${x}px)`;
    }
  }
  static setTranslateY(element, y) {
    const t = DH$1.getStyleValue(element, "transform").split(/,\s*/);
    y = DH$1.roundPx(y);
    if (t.length > 1) {
      t[t[0].startsWith("matrix3d") ? 13 : 5] = y;
      element.style.transform = t.join(",") + ")";
    } else {
      element.style.transform = `translateY(${y}px)`;
    }
  }
  static setTop(element, y) {
    DH$1.setLength(element, "top", y);
  }
  static setLeft(element, x) {
    DH$1.setLength(element, "left", x);
  }
  static setTopLeft(element, y, x) {
    DH$1.setLength(element, "top", y);
    DH$1.setLength(element, "left", x);
  }
  static setRect(element, {
    x,
    y,
    width,
    height
  }) {
    DH$1.setTopLeft(element, y, x);
    DH$1.setLength(element, "width", width);
    DH$1.setLength(element, "height", height);
  }
  static setTranslateXY(element, x, y) {
    if (x == null) {
      return DH$1.setTranslateY(element, y);
    }
    if (y == null) {
      return DH$1.setTranslateX(element, x);
    }
    x = DH$1.roundPx(x);
    y = DH$1.roundPx(y);
    const t = DH$1.getStyleValue(element, "transform").split(/,\s*/), is3d = t[0].startsWith("matrix3d");
    if (t.length > 1) {
      t[is3d ? 12 : 4] = x;
      t[is3d ? 13 : 5] = y;
      element.style.transform = t.join(",") + ")";
    } else {
      element.style.transform = `translate(${x}px, ${y}px)`;
    }
  }
  static addTranslateX(element, x) {
    DH$1.setTranslateX(element, DH$1.getTranslateX(element) + x);
  }
  static addTranslateY(element, y) {
    DH$1.setTranslateY(element, DH$1.getTranslateY(element) + y);
  }
  static addLeft(element, x) {
    DH$1.setLeft(element, DH$1.getOffsetX(element) + x);
  }
  static addTop(element, y) {
    DH$1.setTop(element, DH$1.getOffsetY(element) + y);
  }
  static alignTo(element, target, alignSpec = t0t0, round2) {
    target = target instanceof Rectangle ? target : Rectangle.from(target, true);
    const elXY = DH$1.getTranslateXY(element), elRect = Rectangle.from(element, true);
    if (round2) {
      elRect.roundPx();
      target.roundPx();
    }
    const targetRect = elRect.alignTo(Object.assign(alignSpec, {
      target
    }));
    DH$1.setTranslateXY(element, elXY[0] + targetRect.x - elRect.x, elXY[1] + targetRect.y - elRect.y);
  }
  static getStyleValue(element, propName, inline, pseudo) {
    const styles = inline ? element.style : element.ownerDocument.defaultView.getComputedStyle(element, pseudo);
    if (Array.isArray(propName)) {
      const result = {};
      for (const prop of propName) {
        result[prop] = styles.getPropertyValue(StringHelper.hyphenate(prop));
      }
      return result;
    }
    return styles.getPropertyValue(StringHelper.hyphenate(propName));
  }
  static getEdgeSize(element, edgeStyle, edges) {
    const suffix = edgeStyle === "border" ? "-width" : "", ret = {
      raw: {}
    };
    for (const edge of ["top", "right", "bottom", "left"]) {
      if (!edges || edges.includes(edge[0])) {
        ret[edge] = parseFloat(ret.raw[edge] = DH$1.getStyleValue(element, `${edgeStyle}-${edge}${suffix}`));
      }
    }
    ret.width = (ret.left || 0) + (ret.right || 0);
    ret.height = (ret.top || 0) + (ret.bottom || 0);
    return ret;
  }
  static parseStyle(style) {
    if (typeof style === "string") {
      const styles = style.split(semicolonRe);
      style = {};
      for (let i = 0, {
        length
      } = styles; i < length; i++) {
        const propVal = styles[i].split(colonRe);
        style[propVal[0]] = propVal[1];
      }
    }
    return style || {};
  }
  static applyStyle(element, style, overwrite = false) {
    if (typeof style === "string") {
      if (overwrite) {
        if (style.length || element.style.cssText.length) {
          element.style.cssText = style;
        }
      } else {
        element.style.cssText += style;
      }
    } else if (style) {
      if (overwrite) {
        element.style.cssText = "";
      }
      if (style.style && typeof style.style !== "string") {
        style = ObjectHelper.assign({}, style, style.style);
      }
      let key, value;
      for (key in style) {
        if (!styleIgnoreProperties[key]) {
          [key, value] = DH$1.unitize(key, style[key]);
          if (value == null) {
            element.style.removeProperty(key);
          } else {
            element.style.setProperty(key, value);
          }
        }
      }
      if (typeof style.style === "string") {
        element.style.cssText += style.style;
      }
    }
  }
  static getCSSText(style) {
    if (typeof style === "string") {
      return style;
    }
    let cssText = "";
    for (const key in style) {
      if (!styleIgnoreProperties[key]) {
        cssText += `${StringHelper.hyphenate(key)}:${style[key]};`;
      }
    }
    return cssText;
  }
  static addClasses(element, classes) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.addClasses should be replaced by native classList.add");
    element.classList.add(...classes);
  }
  static removeClasses(element, classes) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.removeClasses should be replaced by native classList.remove");
    element.classList.remove(...classes);
  }
  static toggleClasses(element, classes, force = null) {
    classes = ArrayHelper.asArray(classes);
    if (force === true) {
      element.classList.add(...classes);
    } else if (force === false) {
      element.classList.remove(...classes);
    } else {
      classes.forEach((cls) => element.classList.toggle(cls));
    }
  }
  static addTemporaryClass(element, cls, duration, delayable = globalThis) {
    if (duration > 0) {
      element.classList.add(cls);
      delayable.setTimeout({
        fn: (cls2) => element.classList.remove(cls2),
        delay: duration,
        name: cls,
        args: [cls],
        cancelOutstanding: true
      });
    }
  }
  static getPropertyTransitionDuration(element, property) {
    const style = globalThis.getComputedStyle(element), properties = style.transitionProperty.split(", "), durations = style.transitionDuration.split(", "), index = properties.indexOf(StringHelper.hyphenate(property));
    let result;
    if (index !== -1) {
      result = parseFloat(durations[index]) * 1e3;
    }
    return result;
  }
  static getAnimationDuration(element) {
    return parseFloat(DH$1.getStyleValue(element, "animation-duration")) * 1e3;
  }
  static highlight(element, delayable = globalThis) {
    if (element instanceof Rectangle) {
      return element.highlight();
    }
    return new Promise((resolve) => {
      delayable.setTimeout(() => {
        element.classList.add("b-fx-highlight");
        delayable.setTimeout(() => {
          element.classList.remove("b-fx-highlight");
          resolve();
        }, 1e3);
      }, 0);
    });
  }
  static get scrollBarWidth() {
    if (scrollBarWidth === null && doc.body) {
      const element = scrollBarMeasureElement || (scrollBarMeasureElement = DH$1.createElement({
        parent: doc.body,
        style: "position:absolute;top:-9999em;height:100px;overflow-y:scroll"
      }));
      if (element.parentNode !== doc.body) {
        doc.body.appendChild(element);
      }
      scrollBarWidth = element.offsetWidth;
    }
    return scrollBarWidth;
  }
  static get scrollBarPadElement() {
    return {
      className: "b-yscroll-pad",
      children: [{
        className: "b-yscroll-pad-sizer"
      }]
    };
  }
  static resetScrollBarWidth() {
    scrollBarWidth = null;
  }
  static measureText(text, sourceElement, useHTML = false, parentElement = void 0) {
    const offScreenDiv = DH$1.getMeasureElement(sourceElement, parentElement);
    offScreenDiv[useHTML ? "innerHTML" : "innerText"] = text;
    const result = offScreenDiv.clientWidth;
    offScreenDiv.className = "";
    return result;
  }
  static measureSize(size, sourceElement, round2 = true) {
    if (!size) {
      return 0;
    }
    if (typeof size === "number") {
      return size;
    }
    if (!size.length) {
      return 0;
    }
    if (/^\d+(px)?$/.test(size)) {
      return parseInt(size);
    }
    if (sourceElement) {
      const offScreenDiv = DH$1.getMeasureElement(sourceElement);
      offScreenDiv.innerHTML = "";
      offScreenDiv.style.width = DH$1.setLength(size);
      const result = round2 ? offScreenDiv.offsetWidth : offScreenDiv.getBoundingClientRect().width;
      offScreenDiv.style.width = offScreenDiv.className = "";
      return result;
    }
    if (/^\d+em$/.test(size)) {
      return parseInt(size) * DEFAULT_FONT_SIZE;
    }
    return isNaN(size) ? 0 : parseInt(size);
  }
  static getMeasureElement(sourceElement, parentElement = doc.body) {
    const sourceElementStyle = win.getComputedStyle(sourceElement), offScreenDiv = parentElement.offScreenDiv = parentElement.offScreenDiv || DH$1.createElement({
      parent: parentElement,
      style: "position:fixed;top:-10000px;left:-10000px;visibility:hidden;contain:strict",
      className: "b-measure-element",
      children: [{
        style: "white-space:nowrap;display:inline-block;will-change:contents;width:auto;contain:none"
      }]
    }, {
      returnAll: true
    })[1];
    fontProps.forEach((prop) => {
      if (offScreenDiv.style[prop] !== sourceElementStyle[prop]) {
        offScreenDiv.style[prop] = sourceElementStyle[prop];
      }
    });
    offScreenDiv.className = sourceElement.className;
    if (offScreenDiv.parentElement.parentElement !== parentElement) {
      parentElement.appendChild(offScreenDiv.parentElement);
    }
    return offScreenDiv;
  }
  static stripTags(htmlString) {
    const parser = DH$1.$domParser || (DH$1.$domParser = new DOMParser()), doc2 = parser.parseFromString(htmlString, "text/html");
    return doc2.body.textContent;
  }
  static sync(sourceElement, targetElement) {
    if (typeof sourceElement === "string") {
      if (sourceElement === "") {
        targetElement.innerHTML = "";
        return;
      } else {
        sourceElement = DH$1.createElementFromTemplate(sourceElement);
      }
    }
    DH$1.performSync(sourceElement, targetElement);
    return targetElement;
  }
  static performSync(sourceElement, targetElement) {
    if (sourceElement.outerHTML !== targetElement.outerHTML) {
      DH$1.syncAttributes(sourceElement, targetElement);
      DH$1.syncContent(sourceElement, targetElement);
      DH$1.syncChildren(sourceElement, targetElement);
      return true;
    }
    return false;
  }
  static getSyncAttributes(element) {
    const attributes = {}, names = [];
    for (let i = 0; i < element.attributes.length; i++) {
      const attr = element.attributes[i];
      if (attr.specified) {
        const name = attr.name.toLowerCase();
        attributes[name] = attr.value;
        names.push(name);
      }
    }
    return {
      attributes,
      names
    };
  }
  static syncAttributes(sourceElement, targetElement) {
    const {
      attributes: sourceAttributes,
      names: sourceNames
    } = DH$1.getSyncAttributes(sourceElement), {
      attributes: targetAttributes,
      names: targetNames
    } = DH$1.getSyncAttributes(targetElement), hasDataset = sourceNames.includes("dataset"), toAdd = sourceNames.filter((attr) => !targetNames.includes(attr)), toRemove = targetNames.filter((attr) => !sourceNames.includes(attr) && (!hasDataset || !attr.startsWith("data-"))), toSync = sourceNames.filter((attr) => targetNames.includes(attr));
    if (toAdd.length > 0) {
      for (let i = 0; i < toAdd.length; i++) {
        const attr = toAdd[i];
        if (attr === "style") {
          DH$1.applyStyle(targetElement, sourceAttributes.style, true);
        } else if (attr === "dataset") {
          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        } else {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }
    if (toRemove.length > 0) {
      for (let i = 0; i < toRemove.length; i++) {
        targetElement.removeAttribute(toRemove[i]);
      }
    }
    if (toSync.length > 0) {
      for (let i = 0; i < toSync.length; i++) {
        const attr = toSync[i];
        if (attr === "style") {
          DH$1.applyStyle(targetElement, sourceAttributes.style, true);
        } else if (attr === "dataset") {
          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        } else if (attr === "class" && (sourceAttributes.class.isDomClassList || typeof sourceAttributes.class === "object")) {
          let classList;
          if (sourceAttributes.class.isDomClassList) {
            classList = sourceAttributes.class;
          } else {
            classList = new DomClassList(sourceAttributes.class);
          }
          if (!classList.isEqual(targetAttributes.class)) {
            targetElement.setAttribute("class", classList);
          }
        } else if (targetAttributes[attr] !== sourceAttributes[attr]) {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }
  }
  static syncContent(sourceElement, targetElement) {
    if (DH$1.getChildElementCount(sourceElement) === 0) {
      targetElement.innerText = sourceElement.innerText;
    }
  }
  static setInnerText(targetElement, text) {
    const {
      firstChild
    } = targetElement;
    if ((firstChild === null || firstChild === void 0 ? void 0 : firstChild.nodeType) === Element.TEXT_NODE) {
      firstChild.data = text;
    } else {
      targetElement.textContent = text;
    }
  }
  static syncChildren(sourceElement, targetElement) {
    const me = this, sourceNodes = arraySlice$1.call(sourceElement.childNodes), targetNodes = arraySlice$1.call(targetElement.childNodes);
    while (sourceNodes.length) {
      const sourceNode = sourceNodes.shift(), targetNode = targetNodes.shift();
      if (sourceNode && sourceNode.nodeType !== TEXT_NODE && sourceNode.nodeType !== ELEMENT_NODE) {
        throw new Error(`Source node type ${sourceNode.nodeType} not supported by DomHelper.sync()`);
      }
      if (targetNode && targetNode.nodeType !== TEXT_NODE && targetNode.nodeType !== ELEMENT_NODE) {
        throw new Error(`Target node type ${targetNode.nodeType} not supported by DomHelper.sync()`);
      }
      if (!targetNode) {
        targetElement.appendChild(sourceNode);
      } else {
        if (sourceNode.nodeType === targetNode.nodeType) {
          if (sourceNode.nodeType === TEXT_NODE) {
            targetNode.data = sourceNode.data;
          } else {
            if (sourceNode.tagName === targetNode.tagName) {
              me.performSync(sourceNode, targetNode);
            } else {
              targetElement.insertBefore(sourceNode, targetNode);
              targetNode.remove();
            }
          }
        } else if (sourceNode.nodeType === TEXT_NODE && targetNode.nodeType === ELEMENT_NODE) {
          targetElement.innerText = sourceNode.data.trim();
        } else {
          const logElement = sourceNode.parentElement || sourceNode;
          throw new Error(`Currently no support for transforming nodeType.
${logElement.outerHTML}`);
        }
      }
    }
    targetNodes.forEach((targetNode) => {
      targetNode.remove();
    });
  }
  static syncClassList(element, newClasses) {
    const {
      classList
    } = element, isString = typeof newClasses === "string", newClsArray = isString ? newClasses.split(whiteSpaceRe) : DomClassList.normalize(newClasses, "array"), classCount = newClsArray.length;
    let changed = classList.length !== classCount, i;
    for (i = 0; !changed && i < classCount; i++) {
      changed = !classList.contains(newClsArray[i]);
    }
    if (changed) {
      element.className = isString ? newClasses : newClsArray.join(" ");
    }
    return changed;
  }
  static updateClassList(element, classes) {
    const {
      classList
    } = element;
    let cls, add, changed = false;
    for (cls in classes) {
      add = Boolean(classes[cls]);
      if (classList.contains(cls) !== add) {
        classList[add ? "add" : "remove"](cls);
        changed = true;
      }
    }
    return changed;
  }
  static setTheme(newThemeName, defaultTheme) {
    newThemeName = newThemeName.toLowerCase();
    const {
      head
    } = document, oldThemeName = DH$1.getThemeInfo(defaultTheme).name.toLowerCase();
    let oldThemeLinks = head.querySelectorAll("[data-bryntum-theme]:not([data-loading])"), loaded = 0;
    if (oldThemeName === newThemeName) {
      return immediatePromise$7;
    }
    DH$1.removeEachSelector(head, "#bryntum-theme[data-loading],link[data-bryntum-theme][data-loading]");
    const themeEvent = {
      theme: newThemeName,
      prev: oldThemeName
    };
    function replaceTheme(oldThemeLink, resolve, reject) {
      const newThemeLink = DomHelper.createElement({
        tag: "link",
        rel: "stylesheet",
        dataset: {
          loading: true,
          bryntumTheme: true
        },
        href: oldThemeLink.href.replace(oldThemeName, newThemeName),
        nextSibling: oldThemeLink
      });
      newThemeLink.addEventListener("load", () => {
        delete newThemeLink.dataset.loading;
        themeInfo = null;
        if (++loaded === oldThemeLinks.length) {
          oldThemeLinks.forEach((link) => link.remove());
          GlobalEvents$1.trigger("theme", themeEvent);
          resolve(themeEvent);
        }
      });
      newThemeLink.addEventListener("error", (e) => {
        delete newThemeLink.dataset.loading;
        reject(e);
      });
    }
    if (oldThemeLinks.length) {
      return new Promise((resolve, reject) => {
        oldThemeLinks.forEach((oldThemeLink, i) => {
          replaceTheme(oldThemeLink, resolve, reject, i === oldThemeLinks.length - 1);
        });
      });
    } else {
      const oldThemeLink = head.querySelector("#bryntum-theme:not([data-loading])") || head.querySelector(`[href*="${oldThemeName}.css"]:not([data-loading])`);
      if (!(oldThemeLink !== null && oldThemeLink !== void 0 && oldThemeLink.href.includes(`${oldThemeName}.css`))) {
        throw new Error(`Theme link for ${oldThemeName} not found`);
      }
      oldThemeLinks = [oldThemeLink];
      return new Promise((resolve, reject) => replaceTheme(oldThemeLink, resolve, reject));
    }
  }
  static get themeInfo() {
    return DomHelper.getThemeInfo();
  }
  static getThemeInfo(defaultTheme) {
    if (!themeInfo) {
      const testDiv = DH$1.createElement({
        parent: document.body,
        className: "b-theme-info"
      }), themeData = DH$1.getStyleValue(testDiv, "content", false, ":before");
      if (themeData) {
        try {
          themeInfo = JSON.parse(themeData.replace(/^["']|["']$|\\/g, ""));
        } catch (e) {
          themeInfo = null;
        }
      }
      themeInfo = themeInfo || (defaultTheme ? {
        name: defaultTheme
      } : null);
      testDiv.remove();
    }
    return themeInfo;
  }
  static async transition({
    element: outerElement,
    selector = "[data-dom-transition]",
    duration,
    action,
    thisObj = this,
    addTransition = {},
    removeTransition = {}
  }) {
    const scrollers = /* @__PURE__ */ new Set(), beforeElements = Array.from(outerElement.querySelectorAll(selector)), beforeMap = new Map(beforeElements.map((element) => {
      let depth = 0, parent = element.parentElement;
      while (parent && parent !== outerElement) {
        depth++;
        parent = parent.parentElement;
      }
      element.$depth = depth;
      if (element.scrollHeight > element.offsetHeight && getComputedStyle(element).overflow === "auto") {
        element.$scrollTop = element.scrollTop;
        scrollers.add(element);
      }
      const {
        parentElement
      } = element, globalBounds = Rectangle.from(element, outerElement), localBounds = Rectangle.from(element, parentElement), style = getComputedStyle(parentElement), borderLeftWidth = parseFloat(style.borderLeftWidth);
      if (borderLeftWidth) {
        globalBounds.left -= borderLeftWidth;
        localBounds.left -= borderLeftWidth;
      }
      return [element.id, {
        element,
        globalBounds,
        localBounds,
        depth,
        parentElement
      }];
    }));
    action.call(thisObj);
    const afterElements = Array.from(outerElement.querySelectorAll(selector)), afterMap = new Map(afterElements.map((element) => {
      const globalBounds = Rectangle.from(element, outerElement), localBounds = Rectangle.from(element, element.parentElement), style = globalThis.getComputedStyle(element.parentElement), borderLeftWidth = parseFloat(style.borderLeftWidth);
      if (borderLeftWidth) {
        globalBounds.left -= borderLeftWidth;
        localBounds.left -= borderLeftWidth;
      }
      return [element.id, {
        element,
        globalBounds,
        localBounds
      }];
    })), styleProps = ["position", "top", "left", "width", "height", "padding", "margin", "zIndex", "minWidth", "minHeight", "opacity", "overflow"];
    for (const [id, before] of beforeMap) {
      const after = afterMap.get(id);
      if (after) {
        const {
          element
        } = after, {
          style,
          parentElement
        } = element, zIndex = parseInt(DH$1.getStyleValue(element, "zIndex")), {
          globalBounds,
          localBounds,
          depth,
          parentElement: beforeParent
        } = before, parentChanged = beforeParent !== parentElement;
        ObjectHelper.copyProperties(element.$initial = {
          parentElement
        }, style, styleProps);
        let bounds;
        if (parentChanged) {
          after.bounds = after.globalBounds;
          bounds = globalBounds;
          outerElement.appendChild(element);
        } else {
          after.bounds = after.localBounds;
          bounds = localBounds;
          beforeParent.appendChild(element);
        }
        let overflow = "hidden";
        if (scrollers.has(element)) {
          element.$scrollPlaceholder = DH$1.createElement({
            parent: element,
            style: {
              height: element.scrollHeight
            }
          });
          overflow = "auto";
        }
        Object.assign(style, {
          position: "absolute",
          top: `${bounds.top}px`,
          left: `${bounds.left}px`,
          width: `${bounds.width}px`,
          height: `${bounds.height}px`,
          minWidth: 0,
          minHeight: 0,
          padding: 0,
          margin: 0,
          zIndex: depth + (zIndex || 0),
          overflow
        });
        after.processed = true;
      } else {
        const {
          element,
          localBounds: bounds,
          depth,
          parentElement
        } = before;
        element.$initial = {
          removed: true
        };
        Object.assign(element.style, {
          position: "absolute",
          top: `${bounds.top}px`,
          left: `${bounds.left}px`,
          width: `${bounds.width}px`,
          height: `${bounds.height}px`,
          minWidth: 0,
          minHeight: 0,
          padding: 0,
          margin: 0,
          zIndex: depth,
          overflow: "hidden"
        });
        parentElement.appendChild(element);
        afterMap.set(id, {
          element,
          bounds,
          removed: true,
          processed: true
        });
        afterElements.push(element);
      }
    }
    for (const [, after] of afterMap) {
      if (!after.processed) {
        const {
          element
        } = after, {
          style,
          parentElement
        } = element, bounds = after.bounds = after.localBounds;
        element.classList.add("b-dom-transition-adding");
        ObjectHelper.copyProperties(element.$initial = {
          parentElement
        }, style, styleProps);
        Object.assign(style, {
          position: "absolute",
          top: addTransition.top ? 0 : `${bounds.top}px`,
          left: addTransition.left ? 0 : `${bounds.left}px`,
          width: addTransition.width ? 0 : `${bounds.width}px`,
          height: addTransition.height ? 0 : `${bounds.height}px`,
          opacity: addTransition.opacity ? 0 : null,
          zIndex: parentElement.$depth + 1,
          overflow: "hidden"
        });
      }
    }
    for (const element of scrollers) {
      element.scrollTop = element.$scrollTop;
    }
    outerElement.classList.add("b-dom-transition");
    outerElement.firstElementChild.offsetWidth;
    for (const [, {
      element,
      bounds: afterBounds,
      removed
    }] of afterMap) {
      if (removed) {
        Object.assign(element.style, {
          top: removeTransition.top ? 0 : `${afterBounds.top}px`,
          left: removeTransition.left ? 0 : `${afterBounds.left}px`,
          width: removeTransition.width ? 0 : `${afterBounds.width}px`,
          height: removeTransition.height ? 0 : `${afterBounds.height}px`,
          opacity: removeTransition.opacity ? 0 : element.$initial.opacity
        });
      } else {
        Object.assign(element.style, {
          top: `${afterBounds.top}px`,
          left: `${afterBounds.left}px`,
          width: `${afterBounds.width}px`,
          height: `${afterBounds.height}px`,
          opacity: element.$initial.opacity
        });
      }
    }
    await AsyncHelper.sleep(duration);
    outerElement.classList.remove("b-dom-transition");
    for (const element of afterElements) {
      if (element.$initial) {
        if (element.$initial.removed) {
          element.remove();
        } else {
          ObjectHelper.copyProperties(element.style, element.$initial, styleProps);
          if (element.$scrollPlaceholder) {
            element.$scrollPlaceholder.remove();
            delete element.$scrollPlaceholder;
          }
          element.classList.remove("b-dom-transition-adding");
          element.$initial.parentElement.appendChild(element);
        }
      }
    }
    for (const element of scrollers) {
      element.scrollTop = element.$scrollTop;
      delete element.$scrollTop;
    }
  }
  static async loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.src = url;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  static isNamedColor(color) {
    return color && !/^(#|hsl|rgb|hwb)/.test(color);
  }
  static get NodeFilter() {
    return NodeFilter;
  }
  static addChild(parent, child, sibling) {
    parent.insertBefore(child, sibling);
  }
};
var DH$1 = DomHelper;
var clearTouchTimer;
var clearTouchEvent = () => DH$1.isTouchEvent = false;
var setTouchEvent = () => {
  DH$1.isTouchEvent = true;
  clearTimeout(clearTouchTimer);
  clearTouchTimer = setTimeout(clearTouchEvent, 400);
};
doc.addEventListener("touchstart", setTouchEvent, true);
doc.addEventListener("touchend", setTouchEvent, true);
DH$1.canonicalStyles = canonicalStyles;
DH$1.supportsTemplate = "content" in doc.createElement("template");
DH$1.elementPropKey = elementPropKey;
DH$1.numberRe = numberRe;
if (!("children" in Node.prototype)) {
  const elementFilter = (node) => node.nodeType === node.ELEMENT_NODE;
  Object.defineProperty(Node.prototype, "children", {
    get: function() {
      return Array.prototype.filter.call(this.childNodes, elementFilter);
    }
  });
}
if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(s) {
    const matches = (this.document || this.ownerDocument).querySelectorAll(s);
    let i = matches.length;
    while (--i >= 0 && matches.item(i) !== this) {
    }
    return i > -1;
  };
}
if (win.Element && !Element.prototype.closest) {
  Node.prototype.closest = Element.prototype.closest = function(s) {
    let el = this;
    if (!doc.documentElement.contains(el))
      return null;
    do {
      if (el.matches(s))
        return el;
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === el.ELEMENT_NODE);
    return null;
  };
} else {
  Node.prototype.closest = function(selector) {
    var _this$parentNode;
    return (_this$parentNode = this.parentNode) === null || _this$parentNode === void 0 ? void 0 : _this$parentNode.closest(selector);
  };
}
(function(arr) {
  arr.forEach(function(item) {
    if (Object.prototype.hasOwnProperty.call(item, "remove")) {
      return;
    }
    Object.defineProperty(item, "remove", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function remove() {
        this.parentNode && this.parentNode.removeChild(this);
      }
    });
  });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);
globalThis.addEventListener("resize", () => scrollBarWidth = null);
DomHelper._$name = "DomHelper";
var isFloatingWidget = (w) => w.floating;
var GlobalEvents = new class extends Base$1.mixin(Events) {
  suspendFocusEvents() {
    focusEventsSuspended = true;
  }
  resumeFocusEvents() {
    focusEventsSuspended = false;
  }
  setupFocusListenersOnce(rootElement, EventHelper2) {
    if (rootElement && !GlobalEvents.observedElements.has(rootElement)) {
      GlobalEvents.setupFocusListeners(rootElement, EventHelper2);
      GlobalEvents.observedElements.add(rootElement);
    }
  }
  setupFocusListeners(element = document, EventHelper2, detach = false) {
    var _detacher;
    const listeners = {
      element,
      touchstart(touchstart) {
        if (!globaltouchStart && touchstart.changedTouches.length === 1) {
          globaltouchStart = touchstart.changedTouches[0];
        } else {
          globaltouchStart = null;
        }
      },
      touchend: {
        handler: (event) => {
          if (globaltouchStart) {
            if (globaltouchStart.identifier === EventHelper2.contextMenuTouchId) {
              event.stopImmediatePropagation();
              event.preventDefault();
            } else if (event.changedTouches.length === 1 && event.changedTouches[0].identifier === globaltouchStart.identifier) {
              GlobalEvents.trigger("globaltap", {
                event
              });
            }
            globaltouchStart = null;
          }
        },
        passive: false
      },
      mousedown: {
        handler: (event) => {
          lastInteractionType = "mouse";
          if (!globaltouchStart) {
            GlobalEvents.trigger("globaltap", {
              event
            });
          }
          currentMouseDown = event;
          const hasModifierKey = event.ctrlKey || event.altKey || event.shiftKey || event.metaKey;
          if (!currentKeyDown && hasModifierKey) {
            currentKeyDown = new KeyboardEvent("keydown", {
              key: event.ctrlKey ? "Control" : event.shiftKey ? "Shift" : event.altKey ? "Alt" : "Meta",
              ctrlKey: event.ctrlKey,
              altKey: event.altKey,
              shiftKey: event.shiftKey,
              metaKey: event.metaKey
            });
          } else if (currentKeyDown && !hasModifierKey) {
            currentKeyDown = null;
          }
        },
        passive: false
      },
      mouseup() {
        currentMouseDown = null;
      },
      keydown(ev) {
        lastInteractionType = "key";
        currentKeyDown = ev;
      },
      keypress() {
        lastInteractionType = "key";
      },
      keyup() {
        currentKeyDown = null;
      },
      focusin(focusin) {
        const {
          Widget: Widget2
        } = GlobalEvents;
        Widget2.resetFloatRootScroll();
        if (focusEventsSuspended) {
          return;
        }
        const fromElement = !focusin.relatedTarget ? null : focusin.relatedTarget instanceof HTMLElement ? focusin.relatedTarget : document.body, toElement = focusin.target || document.body, fromWidget = Widget2.fromElement(fromElement), toWidget = Widget2.fromElement(toElement), commonAncestor = DomHelper.getCommonAncestor(fromWidget, toWidget), backwards = !!(fromElement && toElement.compareDocumentPosition(fromElement) & 4), topVisibleModal = Widget2.query(isTopVisibleModal);
        let currentFocus = null;
        if (toElement && toElement !== document.body) {
          currentFocus = DomHelper.getActiveElement(toElement);
        } else {
          currentFocus = DomHelper.getActiveElement(document);
        }
        if (topVisibleModal && !topVisibleModal._isRevertingFocus) {
          if (!toWidget || !topVisibleModal.owns(toWidget) && !(topVisibleModal.element.compareDocumentPosition(toWidget.element) & 4 && toWidget.up(isFloatingWidget))) {
            return topVisibleModal.focus();
          }
        }
        let event = createWidgetEvent("focusout", fromElement, focusin.target, fromWidget, toWidget, backwards);
        for (let target = fromWidget, owner; target && target !== commonAncestor; target = owner) {
          owner = target.owner;
          if (!target.isDestroying && target.onFocusOut) {
            target.onFocusOut(event);
            if (focusin.target && currentFocus !== DomHelper.getActiveElement(focusin.target)) {
              return;
            }
          }
        }
        if (commonAncestor && focusin.target === commonAncestor.element) {
          if (!commonAncestor.isDestroying && DomHelper.getActiveElement(commonAncestor) === toElement && commonAncestor.focusElement && commonAncestor.focusElement !== commonAncestor.element) {
            if (!commonAncestor.element.contains(currentFocus) || commonAncestor.focusDescendant) {
              commonAncestor.setTimeout(() => {
                var _commonAncestor$focus;
                return (_commonAncestor$focus = commonAncestor.focus) === null || _commonAncestor$focus === void 0 ? void 0 : _commonAncestor$focus.call(commonAncestor);
              }, 0);
            }
          }
        } else {
          event = createWidgetEvent("focusin", toElement, fromElement, fromWidget, toWidget, backwards);
          for (let target = toWidget; target && target !== commonAncestor; target = target.owner) {
            if (!target.isDestroying) {
              var _target$onFocusIn, _target;
              (_target$onFocusIn = (_target = target).onFocusIn) === null || _target$onFocusIn === void 0 ? void 0 : _target$onFocusIn.call(_target, event);
            }
          }
        }
        const commonAncestorEl = DomHelper.getCommonAncestor((fromElement === null || fromElement === void 0 ? void 0 : fromElement.nodeType) === Element.ELEMENT_NODE ? fromElement : null, toElement) || toElement.parentNode;
        if (commonAncestorEl) {
          event = createWidgetEvent("focusmove", toElement, fromElement, fromWidget, toWidget, backwards, {
            bubbles: true
          });
          commonAncestorEl.dispatchEvent(event);
        }
      },
      focusout(focusout) {
        if (focusEventsSuspended) {
          return;
        }
        if (!focusout.relatedTarget || !GlobalEvents.Widget.fromElement(focusout.relatedTarget)) {
          const target = focusout.relatedTarget && focusout.relatedTarget instanceof HTMLElement ? focusout.relatedTarget : null;
          listeners.focusin({
            target,
            relatedTarget: focusout.target
          });
          currentKeyDown = currentMouseDown = null;
        }
      },
      blur: {
        element: window,
        handler(event) {
          if (event.target === window) {
            currentKeyDown = null;
            currentMouseDown = null;
          }
        }
      },
      capture: true,
      passive: true
    };
    detach && ((_detacher = detacher) === null || _detacher === void 0 ? void 0 : _detacher());
    detacher = this.detachEvents = EventHelper2.on(listeners);
  }
  get lastInteractionType() {
    return lastInteractionType;
  }
  get shiftKeyDown() {
    var _currentKeyDown;
    return (_currentKeyDown = currentKeyDown) === null || _currentKeyDown === void 0 ? void 0 : _currentKeyDown.shiftKey;
  }
  get ctrlKeyDown() {
    var _currentKeyDown2, _currentKeyDown3;
    return ((_currentKeyDown2 = currentKeyDown) === null || _currentKeyDown2 === void 0 ? void 0 : _currentKeyDown2.ctrlKey) || ((_currentKeyDown3 = currentKeyDown) === null || _currentKeyDown3 === void 0 ? void 0 : _currentKeyDown3.metaKey);
  }
  get altKeyDown() {
    var _currentKeyDown4;
    return (_currentKeyDown4 = currentKeyDown) === null || _currentKeyDown4 === void 0 ? void 0 : _currentKeyDown4.altKey;
  }
  isKeyDown(key) {
    var _currentKeyDown5;
    return !key ? Boolean(currentKeyDown) : ((_currentKeyDown5 = currentKeyDown) === null || _currentKeyDown5 === void 0 ? void 0 : _currentKeyDown5.key) === key || currentKeyDown[(key === null || key === void 0 ? void 0 : key.toLowerCase()) + "Key"] === true;
  }
  isMouseDown(button = 0) {
    var _currentMouseDown;
    return ((_currentMouseDown = currentMouseDown) === null || _currentMouseDown === void 0 ? void 0 : _currentMouseDown.button) === button;
  }
  get currentMouseDown() {
    return currentMouseDown;
  }
  get currentKeyDown() {
    return currentKeyDown;
  }
}();
var isTopVisibleModal = (w) => w.isVisible && w.isTopModal;
GlobalEvents.observedElements = /* @__PURE__ */ new Set();
var globaltouchStart;
var focusEventsSuspended = false;
var lastInteractionType;
var currentKeyDown;
var currentMouseDown;
var detacher;
function createWidgetEvent(eventName, target, relatedTarget, fromWidget, toWidget, backwards, options) {
  const result = new CustomEvent(eventName, options);
  Object.defineProperty(result, "_target", {
    get() {
      return target;
    }
  });
  Object.defineProperty(result, "relatedTarget", {
    get() {
      return relatedTarget;
    }
  });
  result.fromWidget = fromWidget;
  result.toWidget = toWidget;
  result.backwards = backwards;
  return result;
}
var GlobalEvents$1 = GlobalEvents;
function getDescriptor(me, fnName) {
  const property = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(me), fnName);
  return property && (property.get || property.set) ? property : null;
}
var InstancePlugin = class extends Base$1.mixin(Events, Localizable) {
  static get configurable() {
    return {
      clientListeners: null,
      disabled: false,
      client: null,
      keyMap: null
    };
  }
  updateClient(client) {
    if (!this.owner) {
      this.owner = client;
    }
  }
  updateKeyMap(keyMap) {
    const {
      client
    } = this;
    client.keyMap = client.mergeKeyMaps(client.keyMap, keyMap, StringHelper.uncapitalize(this.constructor.$name));
  }
  static initPlugins(plugInto, ...plugins) {
    const property = plugInto.plugins || (plugInto.plugins = {});
    for (const PluginClass of plugins) {
      property[PluginClass.$$name] = new PluginClass(plugInto);
    }
  }
  get enabled() {
    return !this.disabled;
  }
  getFocusRevertTarget() {
    var _this$client;
    return (_this$client = this.client) === null || _this$client === void 0 ? void 0 : _this$client.getFocusRevertTarget();
  }
  construct(...args) {
    const me = this;
    let [plugInto, config] = args, listeners;
    if (args.length === 1) {
      if (ObjectHelper.isObject(plugInto)) {
        config = plugInto;
        plugInto = config.client;
      }
    } else {
      config = ObjectHelper.assign({}, config);
      delete config.client;
    }
    me.client = plugInto;
    super.construct(config);
    me.applyPluginConfig(plugInto);
    listeners = me.clientListeners;
    if (listeners) {
      listeners = ObjectHelper.assign({}, listeners);
      listeners.thisObj = me;
      plugInto.ion(listeners);
    }
  }
  applyPluginConfig(plugInto) {
    const me = this, config = me.pluginConfig || me.constructor.pluginConfig;
    if (config) {
      const {
        assign: assign2,
        chain,
        after,
        before,
        override
      } = config;
      assign2 && me.applyAssign(plugInto, assign2);
      (chain || after) && me.applyChain(plugInto, chain || after);
      before && me.applyChain(plugInto, before, false);
      override && me.applyOverride(plugInto, override);
    }
  }
  applyAssign(plugInto, fnNames) {
    fnNames.forEach((fnName) => this.assign(plugInto, fnName));
  }
  applyChain(plugInto, functions, after = true) {
    if (Array.isArray(functions)) {
      for (const fnName of functions) {
        this.chain(plugInto, fnName, fnName, after);
      }
    } else {
      for (const intoName in functions) {
        this.chain(plugInto, intoName, functions[intoName], after);
      }
    }
  }
  applyOverride(plugInto, fnNames) {
    const me = this;
    if (!me.overridden) {
      me.overridden = {};
    }
    fnNames.forEach((fnName) => {
      if (!me[fnName]) {
        throw new Error(`Trying to chain fn ${plugInto.$$name}#${fnName}, but plugin fn ${me.$$name}#${fnName} does not exist`);
      }
      if (typeof plugInto[fnName] === "function") {
        me.overridden[fnName] = plugInto[fnName].bind(plugInto);
      }
      plugInto[fnName] = me[fnName].bind(me);
    });
  }
  assign(plugInto, fnName) {
    const me = this, property = getDescriptor(me, fnName);
    if (property) {
      Object.defineProperty(plugInto, fnName, {
        configurable: true,
        enumerable: true,
        get: property.get && property.get.bind(me),
        set: property.set && property.set.bind(me)
      });
    } else {
      plugInto[fnName] = me[fnName].bind(me);
    }
  }
  chain(plugInto, intoName, hookName, after = true) {
    let prio = 0;
    if (typeof intoName === "object") {
      intoName = intoName.fn;
    }
    if (typeof hookName === "object") {
      prio = hookName.prio || 0;
      hookName = hookName.fn;
    }
    const me = this, chains = plugInto.pluginFunctionChain || (plugInto.pluginFunctionChain = {}), hookFn = me[hookName] && me[hookName].bind(me), functionChainRunner = me.functionChainRunner;
    if (!hookFn) {
      throw new Error(`Trying to chain fn ${plugInto.$$name}#${hookName}, but plugin fn ${me.$$name}#${hookName} does not exist`);
    }
    if (!chains[intoName]) {
      let intoFn = plugInto[intoName];
      if (intoFn) {
        intoFn = intoFn.bind(plugInto);
        intoFn.$this = plugInto;
        intoFn.$prio = 0;
      }
      chains[intoName] = intoFn ? [intoFn] : [];
      plugInto[intoName] = (...params) => functionChainRunner(chains[intoName], params);
    }
    hookFn.$this = me;
    hookFn.$prio = prio;
    chains[intoName][after ? "push" : "unshift"](hookFn);
    chains[intoName].$sorted = false;
  }
  functionChainRunner(chain, params) {
    let fn2, i, returnValue;
    if (!chain.$sorted) {
      chain.sort((a, b) => b.$prio - a.$prio);
      chain.$sorted = true;
    }
    for (i = 0; i < chain.length; i++) {
      fn2 = chain[i];
      if (!fn2.$this.isDestroyed) {
        returnValue = fn2(...params);
        if (returnValue === false) {
          break;
        }
      }
    }
    return returnValue;
  }
  doDisable(disable) {
    const me = this, {
      constructor
    } = me, cls = "featureClass" in constructor ? constructor.featureClass : `b-${constructor.$$name.toLowerCase()}`;
    if (cls) {
      var _me$client, _me$client$element;
      (_me$client = me.client) === null || _me$client === void 0 ? void 0 : (_me$client$element = _me$client.element) === null || _me$client$element === void 0 ? void 0 : _me$client$element.classList[disable ? "remove" : "add"](cls);
    }
    if (!me.isConfiguring) {
      if (disable) {
        me.trigger("disable");
      } else {
        me.trigger("enable");
      }
    }
  }
  updateDisabled(disabled) {
    this.doDisable(disabled);
  }
  throwOverrideIsMissing(data) {
    throw new Error(`Trying to override fn ${data.plugIntoName}#${data.fnName}, but plugin fn ${data.pluginName}#${data.fnName} does not exist`);
  }
  get rootElement() {
    return this.client.rootElement;
  }
};
_defineProperty(InstancePlugin, "$name", "InstancePlugin");
InstancePlugin._$name = "InstancePlugin";
var Pluggable = (Target) => class Pluggable extends (Target || Base$1) {
  static get $name() {
    return "Pluggable";
  }
  get plugins() {
    if (!this._plugins) {
      this._plugins = {};
    }
    return this._plugins;
  }
  set plugins(plugins) {
    if (plugins) {
      if (!Array.isArray(plugins))
        plugins = [plugins];
      InstancePlugin.initPlugins(this, ...plugins);
    }
    this.initPlugins();
  }
  initPlugins() {
  }
  addPlugins(...plugins) {
    InstancePlugin.initPlugins(this, ...plugins);
  }
  hasPlugin(pluginClassOrName) {
    return this.getPlugin(pluginClassOrName) != null;
  }
  getPlugin(pluginClassOrName) {
    var _this$plugins;
    if (typeof pluginClassOrName === "function") {
      pluginClassOrName = pluginClassOrName.$$name;
    }
    return (_this$plugins = this.plugins) === null || _this$plugins === void 0 ? void 0 : _this$plugins[pluginClassOrName];
  }
  get widgetClass() {
  }
};
var {
  defineProperty: defineProperty$5
} = Reflect;
var performance$1;
if (BrowserHelper.isBrowserEnv) {
  performance$1 = globalThis.performance;
} else {
  performance$1 = {
    now() {
      return new Date().getTime();
    }
  };
}
var globalDelays = null;
if (VersionHelper.isTestEnv) {
  const bryntum2 = globalThis.bryntum || (globalThis.bryntum = {});
  globalDelays = bryntum2.globalDelays = {
    timeouts: /* @__PURE__ */ new Map(),
    intervals: /* @__PURE__ */ new Map(),
    animationFrames: /* @__PURE__ */ new Map(),
    idleCallbacks: /* @__PURE__ */ new Map(),
    isEmpty(includeIntervals = false) {
      return globalDelays.timeouts.size + globalDelays.animationFrames.size + globalDelays.idleCallbacks.size + (includeIntervals ? globalDelays.intervals.size : 0) === 0;
    },
    getFiltered({
      ignoreTimeouts = [],
      maxDelay = 5e3,
      includeIntervals = false
    }) {
      const result = [], scopes = ["timeouts", "animationFrames", "idleCallbacks"];
      if (includeIntervals) {
        scopes.push("intervals");
      }
      for (const scope of scopes) {
        const map2 = globalDelays[scope];
        for (const [, entry] of map2.entries()) {
          if (!ignoreTimeouts.includes(entry.name) && (!Number.isInteger(entry.delay) || entry.delay < maxDelay)) {
            result.push(entry);
          }
        }
      }
      return result;
    }
  };
}
var makeInvoker = (me, fn2, wrapFn, options) => {
  const named = typeof fn2 === "string", appendArgs = (options === null || options === void 0 ? void 0 : options.appendArgs) || [], invoker = () => {
    wrapFn.timerId = null;
    wrapFn.lastCallTime = performance$1.now();
    const args = wrapFn.args;
    wrapFn.args = null;
    if (named) {
      me[fn2](...args, ...appendArgs);
    } else {
      fn2.call(me, ...args, ...appendArgs);
    }
    wrapFn.called = true;
    ++wrapFn.calls;
  };
  if (options) {
    me = options.thisObj || me;
  }
  wrapFn.lastCallTime = -9e9;
  wrapFn.calls = 0;
  wrapFn.invoker = invoker;
  invoker.wrapFn = wrapFn;
  return invoker;
};
var decorateWrapFn = (me, wrapFn, cancelFn = "clearTimeout") => {
  wrapFn.cancel = () => {
    if (wrapFn.isPending) {
      me[cancelFn](wrapFn.timerId);
      wrapFn.args = wrapFn.timerId = null;
    }
  };
  wrapFn.flush = () => {
    if (wrapFn.isPending) {
      me[cancelFn](wrapFn.timerId);
      wrapFn.timerId = null;
      wrapFn.invoker();
    }
  };
  wrapFn.now = (...args) => {
    wrapFn.cancel();
    wrapFn.args = args;
    wrapFn.invoker();
  };
  wrapFn.resume = (all) => {
    const n = wrapFn.suspended;
    wrapFn.suspended = all || n < 1 ? 0 : n - 1;
  };
  wrapFn.suspend = () => {
    ++wrapFn.suspended;
  };
  wrapFn.immediate = false;
  wrapFn.suspended = 0;
  wrapFn.timerId = null;
  defineProperty$5(wrapFn, "isPending", {
    get() {
      return wrapFn.timerId !== null;
    }
  });
  return wrapFn;
};
var Delayable = (Target) => class Delayable extends (Target || Base$1) {
  static get $name() {
    return "Delayable";
  }
  static get declarable() {
    return [
      "delayable"
    ];
  }
  doDestroy() {
    const me = this;
    super.doDestroy();
    if (me.timeoutIds) {
      me.timeoutIds.forEach((fn2, id) => {
        var _globalDelays;
        if (typeof fn2 === "function") {
          fn2();
        }
        clearTimeout(id);
        (_globalDelays = globalDelays) === null || _globalDelays === void 0 ? void 0 : _globalDelays.timeouts.delete(id);
      });
      me.timeoutIds = null;
    }
    if (me.timeoutMap) {
      me.timeoutMap.forEach((name, id) => clearTimeout(id));
      me.timeoutMap = null;
    }
    if (me.intervalIds) {
      me.intervalIds.forEach((id) => {
        var _globalDelays2;
        clearInterval(id);
        (_globalDelays2 = globalDelays) === null || _globalDelays2 === void 0 ? void 0 : _globalDelays2.intervals.delete(id);
      });
      me.intervalIds = null;
    }
    if (me.animationFrameIds) {
      me.animationFrameIds.forEach((id) => {
        var _globalDelays3;
        cancelAnimationFrame(id);
        (_globalDelays3 = globalDelays) === null || _globalDelays3 === void 0 ? void 0 : _globalDelays3.animationFrames.delete(id);
      });
      me.animationFrameIds = null;
    }
    if (me.idleCallbackIds) {
      me.idleCallbackIds.forEach((id) => {
        var _globalDelays4;
        cancelIdleCallback(id);
        (_globalDelays4 = globalDelays) === null || _globalDelays4 === void 0 ? void 0 : _globalDelays4.idleCallbacks.delete(id);
      });
      me.idleCallbackIds = null;
    }
  }
  hasTimeout(name) {
    var _this$timeoutMap;
    return Boolean((_this$timeoutMap = this.timeoutMap) === null || _this$timeoutMap === void 0 ? void 0 : _this$timeoutMap.has(name));
  }
  setTimeout({
    fn: fn2,
    delay: delay2,
    name,
    runOnDestroy,
    cancelOutstanding,
    args
  }) {
    var _globalDelays6;
    if (arguments.length > 1 || typeof arguments[0] === "function") {
      [fn2, delay2, name, runOnDestroy] = arguments;
    }
    if (typeof fn2 === "string") {
      name = fn2;
    } else if (!name) {
      name = fn2.name || fn2;
    }
    if (cancelOutstanding) {
      this.clearTimeout(name);
    }
    const me = this, timeoutIds = me.timeoutIds || (me.timeoutIds = /* @__PURE__ */ new Map()), timeoutMap = me.timeoutMap || (me.timeoutMap = /* @__PURE__ */ new Map()), timeoutId = setTimeout(() => {
      var _globalDelays5;
      if (typeof fn2 === "string") {
        fn2 = me[name];
      }
      timeoutIds === null || timeoutIds === void 0 ? void 0 : timeoutIds.delete(timeoutId);
      timeoutMap === null || timeoutMap === void 0 ? void 0 : timeoutMap.delete(name);
      (_globalDelays5 = globalDelays) === null || _globalDelays5 === void 0 ? void 0 : _globalDelays5.timeouts.delete(timeoutId);
      fn2.apply(me, args);
    }, delay2);
    timeoutIds.set(timeoutId, runOnDestroy ? fn2 : true);
    (_globalDelays6 = globalDelays) === null || _globalDelays6 === void 0 ? void 0 : _globalDelays6.timeouts.set(timeoutId, {
      fn: fn2,
      delay: delay2,
      name
    });
    if (name) {
      timeoutMap.set(name, timeoutId);
    }
    return timeoutId;
  }
  clearTimeout(idOrName) {
    var _this$timeoutIds, _globalDelays7;
    let id = idOrName;
    if (typeof id === "string") {
      if (this.timeoutMap) {
        id = this.timeoutMap.get(idOrName);
        this.timeoutMap.delete(idOrName);
      } else {
        return;
      }
    }
    clearTimeout(id);
    (_this$timeoutIds = this.timeoutIds) === null || _this$timeoutIds === void 0 ? void 0 : _this$timeoutIds.delete(id);
    (_globalDelays7 = globalDelays) === null || _globalDelays7 === void 0 ? void 0 : _globalDelays7.timeouts.delete(id);
  }
  clearInterval(id) {
    var _this$intervalIds, _globalDelays8;
    clearInterval(id);
    (_this$intervalIds = this.intervalIds) === null || _this$intervalIds === void 0 ? void 0 : _this$intervalIds.delete(id);
    (_globalDelays8 = globalDelays) === null || _globalDelays8 === void 0 ? void 0 : _globalDelays8.intervals.delete(id);
  }
  setInterval(fn2, delay2, name) {
    var _globalDelays9;
    const intervalId = setInterval(fn2, delay2);
    (this.intervalIds || (this.intervalIds = /* @__PURE__ */ new Set())).add(intervalId);
    (_globalDelays9 = globalDelays) === null || _globalDelays9 === void 0 ? void 0 : _globalDelays9.intervals.set(intervalId, {
      fn: fn2,
      delay: delay2,
      name
    });
    return intervalId;
  }
  requestAnimationFrame(fn2, extraArgs = [], thisObj = this) {
    var _globalDelays11;
    const animationFrameIds = this.animationFrameIds || (this.animationFrameIds = /* @__PURE__ */ new Set()), frameId = requestAnimationFrame(() => {
      var _globalDelays10;
      (_globalDelays10 = globalDelays) === null || _globalDelays10 === void 0 ? void 0 : _globalDelays10.animationFrames.delete(frameId);
      animationFrameIds.delete(frameId) && fn2.apply(thisObj, extraArgs);
    });
    animationFrameIds.add(frameId);
    (_globalDelays11 = globalDelays) === null || _globalDelays11 === void 0 ? void 0 : _globalDelays11.animationFrames.set(frameId, {
      fn: fn2,
      extraArgs,
      thisObj
    });
    return frameId;
  }
  requestIdleCallback(fn2, extraArgs = [], thisObj = this) {
    var _globalDelays13;
    const idleCallbackIds = this.idleCallbackIds || (this.idleCallbackIds = /* @__PURE__ */ new Set()), frameId = requestIdleCallback(() => {
      var _globalDelays12;
      (_globalDelays12 = globalDelays) === null || _globalDelays12 === void 0 ? void 0 : _globalDelays12.idleCallbacks.delete(frameId);
      idleCallbackIds.delete(frameId) && fn2.apply(thisObj, extraArgs);
    });
    idleCallbackIds.add(frameId);
    (_globalDelays13 = globalDelays) === null || _globalDelays13 === void 0 ? void 0 : _globalDelays13.idleCallbacks.set(frameId, {
      fn: fn2,
      extraArgs,
      thisObj
    });
    return frameId;
  }
  createOnFrame(fn2, args = [], thisObj = this, cancelOutstanding) {
    let rafId;
    const result = (...callArgs) => {
      if (rafId != null && cancelOutstanding) {
        this.cancelAnimationFrame(rafId);
        rafId = null;
      }
      if (rafId == null) {
        rafId = this.requestAnimationFrame(() => {
          if (typeof fn2 === "string") {
            fn2 = thisObj[fn2];
          }
          rafId = null;
          callArgs.push(...args);
          fn2.apply(thisObj, callArgs);
        });
      }
    };
    result.cancel = () => this.cancelAnimationFrame(rafId);
    return result;
  }
  cancelAnimationFrame(handle) {
    var _this$animationFrameI, _globalDelays14;
    cancelAnimationFrame(handle);
    (_this$animationFrameI = this.animationFrameIds) === null || _this$animationFrameI === void 0 ? void 0 : _this$animationFrameI.delete(handle);
    (_globalDelays14 = globalDelays) === null || _globalDelays14 === void 0 ? void 0 : _globalDelays14.animationFrames.delete(handle);
  }
  cancelIdleCallback(handle) {
    var _this$idleCallbackIds, _globalDelays15;
    cancelIdleCallback(handle);
    (_this$idleCallbackIds = this.idleCallbackIds) === null || _this$idleCallbackIds === void 0 ? void 0 : _this$idleCallbackIds.delete(handle);
    (_globalDelays15 = globalDelays) === null || _globalDelays15 === void 0 ? void 0 : _globalDelays15.idleCallbacks.delete(handle);
  }
  async nextAnimationFrame() {
    return new Promise((resolve) => this.requestAnimationFrame(resolve));
  }
  buffer(fn2, options) {
    let delay2 = options;
    if (options && typeof options !== "number") {
      delay2 = options.delay;
    } else {
      options = null;
    }
    const bufferWrapFn = (...params) => {
      if (bufferWrapFn.suspended) {
        return;
      }
      const {
        delay: delay3
      } = bufferWrapFn;
      bufferWrapFn.cancel();
      bufferWrapFn.called = false;
      bufferWrapFn.args = params;
      if (bufferWrapFn.immediate || !delay3) {
        invoker();
      } else {
        bufferWrapFn.timerId = this.setTimeout(invoker, delay3);
      }
    }, invoker = makeInvoker(this, fn2, bufferWrapFn, options);
    bufferWrapFn.delay = delay2;
    return decorateWrapFn(this, bufferWrapFn);
  }
  raf(fn2, options) {
    let cancelOutstanding = options;
    if (options && typeof options !== "boolean") {
      cancelOutstanding = options.cancelOutstanding;
    } else {
      options = null;
    }
    const rafWrapFn = (...params) => {
      if (rafWrapFn.suspended) {
        return;
      }
      if (rafWrapFn.cancelOutstanding) {
        rafWrapFn.cancel();
      }
      rafWrapFn.called = false;
      rafWrapFn.args = params;
      if (rafWrapFn.immediate) {
        invoker();
      } else if (!rafWrapFn.isPending) {
        rafWrapFn.timerId = this.requestAnimationFrame(invoker);
      }
    }, invoker = makeInvoker(this, fn2, rafWrapFn, options);
    rafWrapFn.cancelOutstanding = cancelOutstanding;
    return decorateWrapFn(this, rafWrapFn, "cancelAnimationFrame");
  }
  idle(fn2, options) {
    let cancelOutstanding = options;
    if (options && typeof options !== "boolean") {
      cancelOutstanding = options.cancelOutstanding;
    } else {
      options = null;
    }
    const idleWrapFn = (...params) => {
      if (idleWrapFn.suspended) {
        return;
      }
      if (idleWrapFn.cancelOutstanding) {
        idleWrapFn.cancel();
      }
      idleWrapFn.called = false;
      idleWrapFn.args = params;
      if (idleWrapFn.immediate) {
        invoker();
      } else if (!idleWrapFn.isPending) {
        idleWrapFn.timerId = this.requestIdleCallback(invoker);
      }
    }, invoker = makeInvoker(this, fn2, idleWrapFn, options);
    idleWrapFn.cancelOutstanding = cancelOutstanding;
    this.setTimeout(() => this.idleCallbackIds.delete(idleWrapFn.timerId) && idleWrapFn.now(), 100);
    return decorateWrapFn(this, idleWrapFn, "cancelIdleCallback");
  }
  throttle(fn2, options) {
    let delay2 = options, throttled;
    if (options && typeof options !== "number") {
      delay2 = options.delay;
      throttled = options.throttled;
    } else {
      options = null;
    }
    const me = this, throttleWrapFn = (...args) => {
      if (throttleWrapFn.suspended) {
        return;
      }
      const {
        delay: delay3
      } = throttleWrapFn, elapsed = performance$1.now() - throttleWrapFn.lastCallTime;
      throttleWrapFn.args = args;
      if (throttleWrapFn.immediate || elapsed >= delay3) {
        me.clearTimeout(throttleWrapFn.timerId);
        invoker();
      } else {
        if (!throttleWrapFn.isPending) {
          throttleWrapFn.timerId = me.setTimeout(invoker, delay3 - elapsed);
          throttleWrapFn.called = false;
        }
        if (throttled) {
          throttled.wrapFn.args = args;
          throttled();
        }
      }
    }, invoker = makeInvoker(me, fn2, throttleWrapFn, options);
    throttleWrapFn.delay = delay2;
    if (throttled) {
      throttled = makeInvoker(me, throttled, () => {
      }, options);
    }
    return decorateWrapFn(me, throttleWrapFn);
  }
  static setupDelayable(cls) {
    cls.setupDelayableMethods(cls.delayable);
  }
  static setupDelayableMethods(delayable, cls = null) {
    const me = this, statics = delayable.static, target = cls || me.prototype;
    if (statics) {
      delete delayable.static;
    }
    for (const name in delayable) {
      let options = delayable[name];
      const implName = name + "Now", type = typeof options;
      if (!target[implName]) {
        target[implName] = target[name];
      }
      if (type === "number") {
        options = {
          type: "buffer",
          delay: options
        };
      } else if (type === "string") {
        options = {
          type: options
        };
      }
      defineProperty$5(target, name, {
        get() {
          const value = this[options.type]((...params) => {
            this[implName](...params);
          }, options);
          defineProperty$5(this, name, {
            value
          });
          return value;
        }
      });
    }
  }
  get widgetClass() {
  }
};
var StateStorage = class {
  get data() {
    return /* @__PURE__ */ Object.create(null);
  }
  get keys() {
    return [];
  }
  clear() {
  }
  getItem(key) {
    return null;
  }
  removeItem(key) {
  }
  setItem(key, value) {
  }
};
StateStorage._$name = "StateStorage";
var empty = () => /* @__PURE__ */ Object.create(null);
var getKeys = (prefix, pos = 0) => {
  const keys = [], count = localStorage.length;
  for (let key, i = 0; i < count; ++i) {
    key = localStorage.key(i);
    key.startsWith(prefix) && keys.push(key.slice(pos));
  }
  return keys;
};
var Local = class extends StateStorage {
  constructor(stateProvider) {
    super();
    this.prefix = stateProvider.prefix || "";
  }
  get isLocal() {
    return true;
  }
  get data() {
    const data = empty(), keys = this.keys;
    for (const key of keys) {
      data[key] = this.getItem(key);
    }
    return data;
  }
  get keys() {
    return getKeys(this.prefix, this.prefix.length);
  }
  clear() {
    const keys = getKeys(this.prefix);
    for (const key of keys) {
      localStorage.removeItem(key);
    }
  }
  getItem(key) {
    const value = localStorage.getItem(this.prefix + key);
    return value === null ? value : JSON.parse(value);
  }
  removeItem(key) {
    return localStorage.removeItem(this.prefix + key);
  }
  setItem(key, value) {
    return localStorage.setItem(this.prefix + key, JSON.stringify(value));
  }
};
var Memory = class extends StateStorage {
  constructor() {
    super();
    this.clear();
  }
  get isMemory() {
    return true;
  }
  get data() {
    return ObjectHelper.clone(this._data);
  }
  get keys() {
    return Object.keys(this._data);
  }
  clear() {
    this._data = empty();
  }
  getItem(key) {
    return key in this._data ? this._data[key] : null;
  }
  removeItem(key) {
    delete this._data[key];
  }
  setItem(key, value) {
    this._data[key] = value;
  }
};
var nullStorage = new StateStorage();
var storageTypes = {
  local: Local,
  memory: Memory
};
var StateProvider = class extends Base$1.mixin(Delayable, Events) {
  static get $name() {
    return "StateProvider";
  }
  static get configurable() {
    return {
      prefix: "bryntum-state:",
      storage: "local"
    };
  }
  static get delayable() {
    return {
      writeStatefuls: 50
    };
  }
  static get instance() {
    return this._instance;
  }
  static set instance(inst) {
    if (inst == null) {
      inst = nullProvider;
    } else {
      if (typeof inst === "string" || ObjectHelper.isClass(inst) || inst instanceof StateStorage) {
        inst = {
          storage: inst
        };
      }
      if (ObjectHelper.isObject(inst)) {
        inst = new StateProvider(inst);
      }
    }
    this._instance = inst;
  }
  static setup(inst) {
    this.instance = inst;
    return this.instance;
  }
  doDestroy() {
    self.writeStatefuls.flush();
    super.doDestroy();
  }
  get data() {
    return this.storage.data;
  }
  set data(data) {
    if (!data) {
      this.clear();
    } else {
      for (const key in data) {
        this.setValue(key, data[key]);
      }
    }
  }
  clear() {
    this.storage.clear();
    return this;
  }
  changeStorage(storage) {
    if (storage == null) {
      storage = nullStorage;
    } else {
      if (typeof storage === "string") {
        if (!storageTypes[storage]) {
          throw new Error(`Invalid storage type "${storage}" (expected one of: "${Object.keys(storageTypes).join('", "')}")`);
        }
        storage = storageTypes[storage];
      }
      if (ObjectHelper.isClass(storage)) {
        storage = new storage(this);
      }
    }
    return storage;
  }
  saveStateful(stateful, options) {
    (this.pendingSaves || (this.pendingSaves = [])).push([stateful, options]);
    this.writeStatefuls();
  }
  writeStatefuls() {
    const me = this, {
      pendingSaves
    } = me, n = pendingSaves === null || pendingSaves === void 0 ? void 0 : pendingSaves.length, stateIds = [], saved = [];
    me.pendingSaves = null;
    if (n) {
      for (let options, stateful, stateId, i = 0; i < n; ++i) {
        [stateful, options] = pendingSaves[i];
        if (!stateful.isDestroying && stateful.isSaveStatePending) {
          stateId = stateful.saveState(_objectSpread2(_objectSpread2({}, options), {}, {
            immediate: true
          }));
          if (stateId) {
            stateIds.push(stateId);
            saved.push(stateful);
          }
        }
      }
      if (stateIds.length) {
        me.trigger("save", {
          stateIds,
          saved
        });
      }
    }
  }
  getValue(key) {
    this.writeStatefuls.flush();
    return this.storage.getItem(key);
  }
  setValue(key, value) {
    const me = this, {
      storage
    } = me, was = me.getValue(key);
    if (value != null) {
      storage.setItem(key, value);
      me.trigger("set", {
        key,
        value,
        was
      });
    } else if (was !== null) {
      storage.removeItem(key);
      me.trigger("remove", {
        key,
        was
      });
    }
    return me;
  }
};
var nullProvider = new StateProvider({
  storage: nullStorage
});
StateProvider._instance = nullProvider;
StateProvider._$name = "StateProvider";
var primitiveRe = /boolean|number|string/;
var State = (Target) => {
  var _class;
  return _class = class State extends (Target || Base$1) {
    afterConstruct() {
      super.afterConstruct();
      this.loadState();
    }
    finalizeInit() {
      this.loadState();
      super.finalizeInit();
    }
    get isStateful() {
      return true;
    }
    get isStatefulActive() {
      return !this.statefulSuspended && !this.isResponsivePending && !this.isResponsiveUpdating;
    }
    get state() {
      return this._state = this.getState();
    }
    set state(state) {
      this._state = state;
      if (state) {
        this.applyState(state);
      }
    }
    updateStatefulEvents(events) {
      const me = this, listeners = {
        name: "statefulEvents",
        thisObj: me
      };
      me.detachListeners(listeners.name);
      if (events) {
        if (typeof events === "string") {
          events = StringHelper.split(events);
        } else if (!Array.isArray(events)) {
          events = ObjectHelper.getTruthyKeys(events);
        }
        if (events.length) {
          var _me$ion;
          for (const event of events) {
            listeners[event] = "onStatefulEvent";
          }
          (_me$ion = me.ion) === null || _me$ion === void 0 ? void 0 : _me$ion.call(me, listeners);
        }
      }
    }
    get statefulId() {
      const me = this, {
        responsiveState
      } = me;
      let statefulId = me.stateId;
      if (statefulId == null && me.hasGeneratedId === false && me.stateful !== false) {
        statefulId = me.id;
      }
      if (statefulId && responsiveState) {
        statefulId = `${statefulId}[${responsiveState}]`;
      }
      return statefulId;
    }
    get statefulness() {
      const {
        stateful
      } = this;
      return Array.isArray(stateful) ? ObjectHelper.createTruthyKeys(stateful) : stateful;
    }
    get stateProvider() {
      return this._stateProvider || StateProvider.instance;
    }
    applyState(state) {
      state = this.pruneState(state);
      if (state) {
        this.setConfig(state);
      }
    }
    getState() {
      const me = this, {
        statefulness
      } = me;
      let state = null, key, value;
      if (statefulness) {
        state = {};
        for (key in statefulness) {
          if (statefulness[key]) {
            var _value, _me$initialConfig;
            value = me[key];
            if ((_value = value) !== null && _value !== void 0 && _value.isStateful) {
              value = value.state;
            } else if (value === ((_me$initialConfig = me.initialConfig) === null || _me$initialConfig === void 0 ? void 0 : _me$initialConfig[key]) || !primitiveRe.test(typeof value)) {
              continue;
            }
            state[key] = value;
          }
        }
      }
      return state;
    }
    loadState(stateId, reload) {
      if (typeof stateId === "boolean") {
        reload = stateId;
        stateId = null;
      }
      const me = this, {
        statefulLoaded
      } = me;
      if (me.isStatefulActive && (reload || !statefulLoaded)) {
        const state = me.loadStatefulData(stateId || (stateId = me.statefulId));
        if (!statefulLoaded && stateId) {
          me.defaultState = me.state;
          me.statefulLoaded = true;
        }
        if (state) {
          me.state = state;
        }
      }
    }
    loadStatefulData(stateId) {
      var _this$stateProvider;
      stateId = this.isStatefulActive ? stateId || this.statefulId : null;
      return stateId && ((_this$stateProvider = this.stateProvider) === null || _this$stateProvider === void 0 ? void 0 : _this$stateProvider.getValue(stateId));
    }
    resetDefaultState() {
      if (this.defaultState) {
        this.state = this.defaultState;
      }
    }
    resumeStateful(full = false) {
      this.statefulSuspended = full ? 0 : Math.max(this.statefulSuspended - 1, 0);
    }
    saveState(options) {
      if (typeof options === "string") {
        options = {
          id: options
        };
      } else {
        options = options || {};
      }
      const me = this, {
        stateProvider
      } = me, statefulId = options.id || me.isStatefulActive && me.statefulId;
      if (statefulId && stateProvider) {
        if (options.immediate) {
          me.isSaveStatePending = false;
          stateProvider.setValue(statefulId, me.state);
        } else if (!me.isSaveStatePending) {
          me.isSaveStatePending = true;
          stateProvider.saveStateful(me, options);
        }
        return statefulId;
      }
    }
    suspendStateful() {
      ++this.statefulSuspended;
    }
    onConfigChange({
      name,
      value,
      was,
      config
    }) {
      super.onConfigChange({
        name,
        value,
        was,
        config
      });
      if (!this.isConstructing && this.isStatefulActive && this.statefulId) {
        const {
          stateful
        } = this;
        if (Array.isArray(stateful) ? stateful.includes(name) : stateful === null || stateful === void 0 ? void 0 : stateful[name]) {
          this.saveState();
        }
      }
    }
    onStatefulEvent() {
      if (!this.isConstructing) {
        this.saveState();
      }
    }
    pruneState(state) {
      const {
        statefulness
      } = this;
      if (statefulness) {
        const pruned = {};
        for (const key in state) {
          if (statefulness[key]) {
            pruned[key] = state[key];
          }
        }
        state = pruned;
      }
      return state;
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "$name", "State"), _defineProperty(_class, "configurable", {
    stateful: null,
    statefulEvents: {
      $config: {
        merge: "classList"
      },
      value: ["stateChange"]
    },
    stateId: null,
    stateProvider: null
  }), _defineProperty(_class, "prototypeProperties", {
    statefulLoaded: false,
    statefulSuspended: 0
  }), _class;
};
var idCounts$1 = ObjectHelper.getPathDefault(globalThis, "bryntum.idCounts", /* @__PURE__ */ Object.create(null));
var idTypes = {
  string: 1,
  number: 1
};
var Identifiable = (Target) => class Identifiable extends (Target || Base$1) {
  static get $name() {
    return "Identifiable";
  }
  static get declarable() {
    return ["identifiable"];
  }
  static get configurable() {
    return {
      id: ""
    };
  }
  static setupIdentifiable(cls, meta) {
    const {
      identifiable
    } = cls;
    identifiable.idMap = /* @__PURE__ */ Object.create(null);
    Reflect.defineProperty(cls, "identifiable", {
      get() {
        return identifiable;
      }
    });
  }
  doDestroy() {
    this.constructor.unregisterInstance(this);
    super.doDestroy();
  }
  changeId(id) {
    return (this.hasGeneratedId = !id) ? this.generateAutoId() : id;
  }
  updateId(id, oldId) {
    const me = this, C = me.constructor;
    oldId && C.unregisterInstance(me, oldId);
    if (!me.hasGeneratedId || C.identifiable.registerGeneratedId !== false) {
      C.registerInstance(me, id);
    }
  }
  generateAutoId() {
    return this.constructor.generateId(`b-${this.$$name.toLowerCase()}-`);
  }
  static get all() {
    return Object.values(this.identifiable.idMap);
  }
  static generateId(prefix = "generatedId") {
    return prefix + (idCounts$1[prefix] = (idCounts$1[prefix] || 0) + 1);
  }
  static registerInstance(instance, instanceId = instance.id) {
    const {
      idMap
    } = this.identifiable;
    if (instanceId in idMap && !this.disableThrow) {
      throw new Error("Id " + instanceId + " already in use");
    }
    idMap[instanceId] = instance;
  }
  static unregisterInstance(instance, id = instance.id) {
    const {
      idMap
    } = this.identifiable;
    if (idTypes[typeof instance]) {
      delete idMap[instance];
    } else if (idMap[id] === instance) {
      delete idMap[id];
    }
  }
  static getById(id) {
    const idMap = this.identifiable.idMap;
    if (idMap) {
      return idMap[id];
    }
  }
  static get registeredInstances() {
    const idMap = this.identifiable.idMap;
    return idMap ? Object.values(idMap) : [];
  }
};
var STM_PROP$1 = Symbol("STM_PROP");
var unrecordedFields = {
  parentIndex: 1
};
var ModelStm = (Target) => class ModelStm extends (Target || Base$1) {
  static get $name() {
    return "ModelStm";
  }
  static get defaultConfig() {
    return {
      stm: null
    };
  }
  joinStore(store) {
    if (!this.stm) {
      this.stm = store.stm;
    }
  }
  unjoinStore(store) {
    var _super$unjoinStore;
    if (this.stm === store.stm) {
      this.stm = null;
    }
    (_super$unjoinStore = super.unjoinStore) === null || _super$unjoinStore === void 0 ? void 0 : _super$unjoinStore.call(this, store);
  }
  get stm() {
    return this[STM_PROP$1];
  }
  set stm(stm) {
    this[STM_PROP$1] = stm;
  }
  beforeChronoFieldSet(fieldName, value) {
    const me = this, {
      stm
    } = me, result = [];
    if (!me.inSetting && stm !== null && stm !== void 0 && stm.enabled && !unrecordedFields[fieldName] && !me.constructor.nonPersistableFields[fieldName]) {
      if (me.getFieldDefinition(fieldName)) {
        const newDataCandidate = {
          [fieldName]: value
        }, oldDataCandidate = {
          [fieldName]: me[fieldName]
        };
        result.push([newDataCandidate, oldDataCandidate]);
      }
    }
    return result;
  }
  beforeSet(field, value, silent, fromRelationUpdate) {
    const {
      stm
    } = this;
    if (stm !== null && stm !== void 0 && stm.enabled && !unrecordedFields[field] && !this.constructor.nonPersistableFields[field]) {
      var _super$beforeSet;
      const preResult = ((_super$beforeSet = super.beforeSet) === null || _super$beforeSet === void 0 ? void 0 : _super$beforeSet.call(this, field, value, silent, fromRelationUpdate)) || [];
      let newDataCandidate, oldDataCandidate;
      if (typeof field == "object") {
        [newDataCandidate, oldDataCandidate] = Object.keys(field).reduce((data, fName) => {
          data[0][fName] = field[fName];
          data[1][fName] = this.get(fName);
          return data;
        }, [{}, {}]);
      } else {
        newDataCandidate = {
          [field]: value
        };
        oldDataCandidate = {
          [field]: this.get(field)
        };
      }
      preResult.push([newDataCandidate, oldDataCandidate]);
      return preResult;
    }
    return [];
  }
  afterChronoFieldSet(fieldName, value, beforeResult) {
    if (beforeResult !== null && beforeResult !== void 0 && beforeResult[0]) {
      this.afterSet(fieldName, value, false, false, beforeResult, beforeResult[0][0], true);
    }
  }
  shouldRecordFieldChange(fieldName, oldValue, newValue) {
    const store = this.firstStore;
    return !(this.constructor.nonPersistableFields[fieldName] || oldValue == null && newValue == null || oldValue === newValue || oldValue instanceof Date && newValue instanceof Date && oldValue.getTime() === newValue.getTime() || fieldName === "id" || fieldName === "parentId" && store && store.oldIdMap[oldValue] === store.getById(newValue));
  }
  afterSet(field, value, silent, fromRelationUpdate, beforeResult, wasSet, isChronoFieldSet) {
    const {
      stm
    } = this, nonPersistableFields = this.constructor.nonPersistableFields;
    if (stm !== null && stm !== void 0 && stm.isBase && stm.enabled && !unrecordedFields[field] && !nonPersistableFields[field]) {
      const preResult = beforeResult.pop();
      if (wasSet) {
        let shouldRecord;
        const [newDataCandidate, oldDataCandidate] = preResult, [newData, oldData] = Object.keys(wasSet).reduce((data, fieldName) => {
          const newValue = newDataCandidate[fieldName], oldValue = oldDataCandidate[fieldName];
          if (this.shouldRecordFieldChange(fieldName, oldValue, newValue)) {
            shouldRecord = true;
            data[0][fieldName] = newValue;
            data[1][fieldName] = oldValue;
          }
          return data;
        }, [{}, {}]);
        if (shouldRecord) {
          stm.onModelUpdate(this, newData, oldData, isChronoFieldSet);
        }
      }
    }
  }
  beforeInsertChild(childRecords) {
    var _super$beforeInsertCh;
    const preResult = ((_super$beforeInsertCh = super.beforeInsertChild) === null || _super$beforeInsertCh === void 0 ? void 0 : _super$beforeInsertCh.call(this, childRecords)) || [], {
      stm
    } = this;
    if (stm !== null && stm !== void 0 && stm.enabled) {
      preResult.push(childRecords.reduce((result, childRecord) => {
        if (childRecord.root === this.root) {
          result.set(childRecord, {
            parent: childRecord.parent,
            index: childRecord.parent ? childRecord.parentIndex : void 0
          });
        }
        return result;
      }, /* @__PURE__ */ new Map()));
    }
    return preResult;
  }
  afterInsertChild(index, childRecords, beforeResult, inserted) {
    var _super$afterInsertChi;
    const {
      stm
    } = this;
    if (stm !== null && stm !== void 0 && stm.enabled) {
      const context = beforeResult.pop();
      if (inserted) {
        stm.onModelInsertChild(this, index, inserted, context);
      }
    }
    (_super$afterInsertChi = super.afterInsertChild) === null || _super$afterInsertChi === void 0 ? void 0 : _super$afterInsertChi.call(this, index, childRecords, beforeResult, inserted);
  }
  beforeRemoveChild(childRecords, isMove) {
    const preResult = super.beforeRemoveChild ? super.beforeRemoveChild(childRecords, isMove) : [], {
      stm
    } = this;
    if (stm !== null && stm !== void 0 && stm.enabled && !isMove) {
      preResult.push(childRecords.reduce((result, childRecord) => {
        result.set(childRecord, childRecord.parentIndex);
        return result;
      }, /* @__PURE__ */ new Map()));
    }
    return preResult;
  }
  afterRemoveChild(childRecords, beforeResult, isMove) {
    var _super$afterRemoveChi;
    const {
      stm
    } = this;
    if (stm !== null && stm !== void 0 && stm.enabled && !isMove) {
      const context = beforeResult.pop();
      if (childRecords && childRecords.length) {
        stm.onModelRemoveChild(this, childRecords, context);
      }
    }
    (_super$afterRemoveChi = super.afterRemoveChild) === null || _super$afterRemoveChi === void 0 ? void 0 : _super$afterRemoveChi.call(this, childRecords, beforeResult, isMove);
  }
};
var defaultTraverseOptions$1 = {
  includeFilteredOutRecords: false
};
var fixTraverseOptions$1 = (options) => {
  options = options || false;
  if (typeof options === "boolean") {
    options = {
      includeFilteredOutRecords: options
    };
  }
  return options || defaultTraverseOptions$1;
};
var TreeNode = (Target) => class TreeNode extends (Target || Base$1) {
  static get $name() {
    return "TreeNode";
  }
  static set convertEmptyParentToLeaf(value) {
    if (value === true) {
      value = {
        onLoad: true,
        onRemove: true
      };
    } else if (value === false) {
      value = {
        onLoad: false,
        onRemove: false
      };
    }
    this._convertEmptyParentToLeaf = value;
  }
  static get convertEmptyParentToLeaf() {
    return this._convertEmptyParentToLeaf || {
      onLoad: false,
      onRemove: false
    };
  }
  ingestChildren(childRecord, stores2 = this.stores) {
    const {
      inProcessChildren,
      constructor: MyClass
    } = this, store = stores2[0];
    if (childRecord === true) {
      if (inProcessChildren) {
        return true;
      }
      return [];
    }
    if (childRecord) {
      childRecord = ArrayHelper.asArray(childRecord);
      const len = childRecord.length, result = [];
      for (let i = 0, child; i < len; i++) {
        child = childRecord[i];
        child = child.isModel ? child : store ? store.createRecord(child, false, true) : new MyClass(child, null, null, true);
        child = store ? store.processRecord(child) : child;
        result.push(child);
      }
      if (this.children === true && store) {
        const sorter = store.createSorterFn(store.sorters);
        result.sort(sorter);
      }
      return result;
    }
  }
  processChildren(stores2 = this.stores) {
    const me = this, {
      meta
    } = me;
    me.inProcessChildren = true;
    const children = me.ingestChildren(me.data[me.constructor.childrenField], stores2);
    if (children) {
      const {
        convertEmptyParentToLeaf
      } = me.constructor, shouldConvert = convertEmptyParentToLeaf === true || convertEmptyParentToLeaf.onLoad;
      if (shouldConvert ? children.length : Array.isArray(children)) {
        meta.isLeaf = false;
        if (me.children === true) {
          me.children = [];
        } else if (children.length === 0) {
          me.children = children;
          return;
        }
        me.appendChild(children);
      } else if (children === true) {
        meta.isLeaf = false;
        me.children = true;
      } else if (!me.isRoot) {
        meta.isLeaf = me.constructor.convertEmptyParentToLeaf.onLoad;
      }
    }
    me.inProcessChildren = false;
  }
  ancestorsExpanded(store = this.firstStore) {
    const {
      parent
    } = this;
    return !parent || parent.isExpanded(store) && parent.ancestorsExpanded(store);
  }
  isExpanded(store = this.firstStore) {
    const mapMeta = this.instanceMeta(store.id);
    if (!Object.prototype.hasOwnProperty.call(mapMeta, "collapsed")) {
      mapMeta.collapsed = !this.expanded;
    }
    return !mapMeta.collapsed;
  }
  get expanded() {
    return this.data.expanded;
  }
  get childLevel() {
    let node = this, ret = -1;
    while (node && !node.isRoot) {
      ++ret;
      node = node.parent;
    }
    return ret;
  }
  get isLeaf() {
    return this.meta.isLeaf !== false && !this.isRoot;
  }
  get isParent() {
    return !this.isLeaf;
  }
  get isLoaded() {
    return this.isParent && Array.isArray(this.children);
  }
  get descendantCount() {
    return this.getDescendantCount();
  }
  get visibleDescendantCount() {
    return this.getDescendantCount(true);
  }
  getDescendantCount(onlyVisible = false, store = this.firstStore) {
    const children = this.children;
    if (!children || !Array.isArray(children) || onlyVisible && !this.isExpanded(store)) {
      return 0;
    }
    return children.reduce((count, child) => count + child.getDescendantCount(onlyVisible), children.length);
  }
  get allChildren() {
    const children = this.children;
    if (!children)
      return [];
    return children.reduce((all, child) => {
      all.push(child);
      all.push.apply(all, child.allChildren);
      return all;
    }, []);
  }
  get firstChild() {
    const children = this.children;
    return (children === null || children === void 0 ? void 0 : children.length) && children[0] || null;
  }
  get lastChild() {
    const children = this.children;
    return (children === null || children === void 0 ? void 0 : children.length) && children[children.length - 1] || null;
  }
  get previousSiblingsTotalCount() {
    let task = this.previousSibling, count = this.parentIndex;
    while (task) {
      count += task.descendantCount;
      task = task.previousSibling;
    }
    return count;
  }
  get previousOrderedSibling() {
    var _this$parent;
    return (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.orderedChildren[this.orderedParentIndex - 1];
  }
  get nextOrderedSibling() {
    var _this$parent2;
    return (_this$parent2 = this.parent) === null || _this$parent2 === void 0 ? void 0 : _this$parent2.orderedChildren[this.orderedParentIndex + 1];
  }
  get root() {
    var _this$parent3;
    return ((_this$parent3 = this.parent) === null || _this$parent3 === void 0 ? void 0 : _this$parent3.root) || this;
  }
  get parentId() {
    return this.parent && !this.parent.isAutoRoot ? this.parent.id : null;
  }
  set parentId(parentId) {
    const me = this, {
      parent
    } = me, newParent = parentId === null ? me.firstStore.rootNode : me.firstStore.getById(parentId);
    if (!(newParent === parent || !parent && !newParent)) {
      if (me.isBatchUpdating) {
        me.meta.batchChanges.parentId = parentId;
      } else {
        if (newParent) {
          newParent.appendChild(me);
        } else {
          me.parent.removeChild(me);
        }
      }
    }
  }
  static set parentIdField(parentIdField) {
    this._parentIdField = parentIdField;
    Object.defineProperty(this.prototype, parentIdField, {
      set: function(parentId) {
        this.parentId = parentId;
      },
      get: function() {
        return this.parentId;
      }
    });
  }
  static get parentIdField() {
    return this._parentIdField || "parentId";
  }
  getChildren(options) {
    let result;
    if (options.includeFilteredOutRecords) {
      result = this.unfilteredChildren || this.children;
    } else if (options.useOrderedTree) {
      result = this.orderedChildren;
    } else {
      result = this.children;
    }
    return result;
  }
  traverse(fn2, skipSelf, options) {
    options = fixTraverseOptions$1(options);
    const me = this, children = me.getChildren(options);
    if (!skipSelf) {
      fn2.call(me, me);
    }
    for (let i = 0, l = children === null || children === void 0 ? void 0 : children.length; i < l; i++) {
      children[i].traverse(fn2, false, options);
    }
  }
  traverseBefore(fn2, skipSelf, options) {
    options = fixTraverseOptions$1(options);
    const me = this, children = me.getChildren(options);
    for (let i = 0, l = children === null || children === void 0 ? void 0 : children.length; i < l; i++) {
      children[i].traverse(fn2, false, options);
    }
    if (!skipSelf) {
      fn2.call(me, me);
    }
  }
  traverseWhile(fn2, skipSelf, options) {
    options = fixTraverseOptions$1(options);
    const me = this;
    let goOn = skipSelf || fn2.call(me, me) !== false;
    if (goOn) {
      const children = me.getChildren(options);
      if (children !== null && children !== void 0 && children.length) {
        goOn = children.every((child) => child.traverseWhile(fn2, false, options));
      }
    }
    return goOn;
  }
  bubble(fn2, skipSelf = false) {
    let me = this;
    if (!skipSelf) {
      fn2.call(me, me);
    }
    while (me.parent) {
      me = me.parent;
      fn2.call(me, me);
    }
  }
  bubbleWhile(fn2, skipSelf = false) {
    let me = this, goOn = true;
    if (!skipSelf) {
      goOn = fn2.call(me, me);
    }
    while (goOn && me.parent) {
      me = me.parent;
      goOn = fn2.call(me, me);
    }
    return goOn;
  }
  contains(childOrId, skipSelf = false) {
    if (childOrId && typeof childOrId === "object") {
      childOrId = childOrId.id;
    }
    return !this.traverseWhile((node) => node.id != childOrId, skipSelf);
  }
  getTopParent(all) {
    let result;
    if (all) {
      result = [];
      this.bubbleWhile((t) => {
        result.push(t);
        return t.parent && !t.parent.isRoot;
      });
    } else {
      result = null;
      this.bubbleWhile((t) => {
        if (!t.parent) {
          result = t;
        }
        return t.parent && !t.parent.isRoot;
      });
    }
    return result;
  }
  appendChild(childRecord, silent = false) {
    return this.insertChild(childRecord, null, silent);
  }
  insertChild(childRecord, before = null, silent = false, options = {}) {
    var _ref, _before$parentIndex, _before, _me$children2, _me$beforeInsertChild, _me$afterInsertChild;
    const me = this, returnArray = Array.isArray(childRecord);
    childRecord = ArrayHelper.asArray(childRecord);
    if (typeof before === "number") {
      var _me$children$before, _me$children;
      before = (_me$children$before = (_me$children = me.children) === null || _me$children === void 0 ? void 0 : _me$children[before]) !== null && _me$children$before !== void 0 ? _me$children$before : null;
    }
    if (!silent && !me.stores.every((s) => s.trigger("beforeAdd", {
      records: childRecord,
      parent: me
    }) !== false)) {
      return null;
    }
    childRecord = me.ingestChildren(childRecord);
    const index = (_ref = (_before$parentIndex = (_before = before) === null || _before === void 0 ? void 0 : _before.parentIndex) !== null && _before$parentIndex !== void 0 ? _before$parentIndex : (_me$children2 = me.children) === null || _me$children2 === void 0 ? void 0 : _me$children2.length) !== null && _ref !== void 0 ? _ref : 0, preResult = (_me$beforeInsertChild = me.beforeInsertChild) === null || _me$beforeInsertChild === void 0 ? void 0 : _me$beforeInsertChild.call(me, childRecord), inserted = me.internalAppendInsert(childRecord, before, silent, options);
    if (inserted.length) {
      me.convertToParent(silent);
    }
    (_me$afterInsertChild = me.afterInsertChild) === null || _me$afterInsertChild === void 0 ? void 0 : _me$afterInsertChild.call(me, index, childRecord, preResult, inserted);
    return returnArray || !inserted ? inserted : inserted[0];
  }
  convertToParent(silent = false) {
    const me = this, wasLeaf = me.isLeaf;
    me.meta.isLeaf = false;
    if (!me.children) {
      me.children = [];
    }
    if (wasLeaf && !me.root.isLoading && !silent) {
      me.signalNodeChanged({
        isLeaf: {
          value: false,
          oldValue: true
        }
      });
    }
  }
  signalNodeChanged(changes) {
    this.stores.forEach((s) => {
      s.trigger("update", {
        record: this,
        records: [this],
        changes
      });
      s.trigger("change", {
        action: "update",
        record: this,
        records: [this],
        changes
      });
    });
  }
  tryInsertChild() {
    return this.insertChild(...arguments);
  }
  internalAppendInsert(recordsToInsert, beforeRecord, silent, options) {
    const me = this, {
      stores: stores2,
      root: root2
    } = me, {
      firstStore: rootStore
    } = root2, {
      parentIdField
    } = me.constructor, parentId = me.isAutoRoot ? null : me.id, oldParentIndices = [], isMove = {};
    let isNoop, start, i, newRecordsCloned;
    if (!root2.isLoading) {
      for (i = 0; i < recordsToInsert.length; i++) {
        const newRecord = recordsToInsert[i];
        isMove[newRecord.id] = newRecord.root === root2;
        oldParentIndices[i] = newRecord.parentIndex;
      }
    }
    if (beforeRecord && beforeRecord.parent !== me) {
      beforeRecord = null;
    }
    if (me.children) {
      const children = me.children, insertAt = beforeRecord ? beforeRecord.parentIndex : children.length;
      if (children[start = insertAt] === recordsToInsert[0] || children[start = insertAt - 1] === recordsToInsert[0]) {
        for (isNoop = true, i = 0; isNoop && i < recordsToInsert.length; i++) {
          if (recordsToInsert[i] !== children[start + i]) {
            isNoop = false;
          }
        }
      }
    }
    if (isNoop) {
      return recordsToInsert;
    }
    for (i = 0; i < recordsToInsert.length; i++) {
      const newRecord = recordsToInsert[i], oldParent = newRecord.parent;
      if (rootStore && !root2.isLoading) {
        newRecord.traverse((r) => {
          if (r.root === root2) {
            isMove[r.id] = true;
          }
        });
      }
      if ((oldParent === null || oldParent === void 0 ? void 0 : oldParent.removeChild(newRecord, isMove[newRecord.id], silent, _objectSpread2({
        isInserting: true
      }, options))) === false) {
        if (!newRecordsCloned) {
          recordsToInsert = recordsToInsert.slice();
          newRecordsCloned = true;
        }
        recordsToInsert.splice(i--, 1);
      } else {
        newRecord.parent = me;
        newRecord.data[parentIdField] = parentId;
        if (oldParent) {
          newRecord.meta.oldParentId = oldParent.id;
        }
      }
    }
    if (recordsToInsert.length) {
      if (!Array.isArray(me.children)) {
        me.children = [];
      }
      if (!Array.isArray(me.orderedChildren)) {
        me.orderedChildren = [];
      }
      const insertAt = me.addToChildren(beforeRecord, recordsToInsert, options);
      stores2.forEach((store) => {
        if (!store.isChained) {
          recordsToInsert.forEach((record) => {
            record.joinStore(store);
          });
          store.onNodeAddChild(me, recordsToInsert, insertAt, isMove, silent);
          recordsToInsert.forEach((record, i2) => {
            if (record.meta.oldParentId != null && !(me.inProcessChildren || me.isLoading)) {
              const toSet = {
                [parentIdField]: parentId,
                [me.getDataSource("parentIndex")]: record.parentIndex
              }, wasSet = {}, {
                modified,
                oldParentId
              } = record.meta, oldParentIndex = oldParentIndices[i2];
              delete record.meta.oldParentId;
              if (me.id !== oldParentId) {
                wasSet[parentIdField] = {
                  value: parentId,
                  oldValue: oldParentId
                };
              }
              if (record.parentIndex !== oldParentIndex) {
                wasSet.parentIndex = {
                  value: record.parentIndex,
                  oldValue: oldParentIndex
                };
              }
              if (modified[parentIdField] === me.id) {
                Reflect.deleteProperty(modified, parentIdField);
              } else if (!(parentIdField in modified)) {
                modified[parentIdField] = oldParentId;
              }
              record.afterChange(toSet, wasSet);
            }
          });
        }
      });
    }
    return recordsToInsert;
  }
  removeChild(childRecords, isMove = false, silent = false, options = {}) {
    var _me$beforeRemoveChild, _me$afterRemoveChild;
    const me = this, allRemovedRecords = [], wasLeaf = me.isLeaf, {
      children,
      stores: stores2
    } = me;
    childRecords = ArrayHelper.asArray(childRecords);
    childRecords = childRecords.filter((r) => r.parent === me);
    if (!silent) {
      for (const store of stores2) {
        if (!store.isChained && store.trigger("beforeRemove", {
          parent: me,
          records: childRecords,
          isMove
        }) === false) {
          return false;
        }
      }
    }
    const preResult = (_me$beforeRemoveChild = me.beforeRemoveChild) === null || _me$beforeRemoveChild === void 0 ? void 0 : _me$beforeRemoveChild.call(me, childRecords, isMove);
    for (const childRecord of childRecords) {
      const {
        parentIdField
      } = childRecord.constructor, {
        modified
      } = childRecord.meta, oldParentId = childRecord.parent ? childRecord.parent.id : null;
      if (!(parentIdField in modified) && !childRecord.isLinked) {
        modified[parentIdField] = oldParentId;
      }
      const index = me.removeFromChildren(childRecord, options);
      stores2.forEach((store) => {
        if (!store.isChained) {
          const {
            isRemoving
          } = store;
          store.isRemoving = true;
          allRemovedRecords.push(...store.onNodeRemoveChild(me, [childRecord], index, {
            isMove,
            silent
          }));
          store.isRemoving = isRemoving;
        }
      });
      if (!isMove) {
        childRecord.parent = childRecord.parentIndex = childRecord.unfilteredIndex = childRecord.nextSibling = childRecord.previousSibling = null;
        childRecord.data[parentIdField] = null;
      }
    }
    if ((me.unfilteredChildren || children).length === 0 && me.constructor.convertEmptyParentToLeaf.onRemove && !me.isRoot) {
      me.meta.isLeaf = true;
    }
    if (me.isLeaf !== wasLeaf && !silent) {
      me.stores.forEach((s) => {
        const changes = {
          isLeaf: {
            value: true,
            oldValue: false
          }
        };
        s.trigger("update", {
          record: me,
          changes
        });
        s.trigger("change", {
          action: "update",
          record: me,
          changes
        });
      });
    }
    (_me$afterRemoveChild = me.afterRemoveChild) === null || _me$afterRemoveChild === void 0 ? void 0 : _me$afterRemoveChild.call(me, childRecords, preResult, isMove);
    return allRemovedRecords;
  }
  clearParentId() {
    const me = this;
    Reflect.deleteProperty(me.data, me.parentIdField);
    Reflect.deleteProperty(me.originalData, me.parentIdField);
    if (me.meta.modified) {
      Reflect.deleteProperty(me.meta.modified, me.parentIdField);
    }
  }
  replaceChildren(newChildren) {
    this.clearChildren();
    this.data[this.constructor.childrenField] = newChildren;
    this.processChildren();
    return this.children;
  }
  clearChildren(silent = false) {
    const me = this, {
      stores: stores2
    } = me, children = me.unfilteredChildren || me.children;
    me.children = [];
    me.orderedChildren = [];
    if (children && children !== true) {
      stores2.forEach((store) => {
        if (!store.isChained) {
          store.onNodeRemoveChild(me, children, 0, {
            unfiltered: true,
            silent
          });
        }
      });
      if (me.unfilteredChildren) {
        me.unfilteredChildren = [];
      }
    }
  }
  clear() {
    var _me$children3;
    const me = this, {
      stores: stores2
    } = me, children = (_me$children3 = me.children) === null || _me$children3 === void 0 ? void 0 : _me$children3.slice();
    if (!me.isRoot || !children) {
      return;
    }
    for (const store of stores2) {
      if (!store.isChained) {
        if (store.trigger("beforeRemove", {
          parent: me,
          records: children,
          isMove: false,
          removingAll: true
        }) === false) {
          return false;
        }
      }
    }
    me.children.length = 0;
    if (me.unfilteredChildren) {
      me.unfilteredChildren.length = 0;
    }
    stores2.forEach((store) => {
      children.forEach((child) => {
        if (child.stores.includes(store)) {
          child.unjoinStore(store);
        }
        child.parent = child.parentIndex = child.nextSibling = child.previousSibling = null;
      });
      store.storage.suspendEvents();
      store.storage.clear();
      store.storage.resumeEvents();
      store.added.clear();
      store.modified.clear();
      store.trigger("removeAll");
      store.trigger("change", {
        action: "removeall"
      });
    });
  }
  updateChildrenIndices(children, indexName, silent = false) {
    let previousSibling = null;
    for (let i = 0; i < children.length; i++) {
      const child = children[i], oldValue = child[indexName];
      if (indexName === "parentIndex" || indexName === "orderedParentIndex") {
        if (oldValue === void 0 || silent) {
          child.setData(indexName, i);
        } else if (oldValue !== i) {
          child.set(indexName, i, true);
        }
      } else {
        child[indexName] = i;
      }
      if (indexName === "parentIndex") {
        child.previousSibling = previousSibling;
        if (previousSibling) {
          previousSibling.nextSibling = child;
        }
        if (i === children.length - 1) {
          child.nextSibling = null;
        }
        previousSibling = child;
      }
    }
  }
  addToChildren(beforeRecord, newRecords, options = {}) {
    var _options$orderedBefor;
    const me = this, configs = [[me.children, "parentIndex", beforeRecord], [me.unfilteredChildren, "unfilteredIndex", beforeRecord], [me.orderedChildren, "orderedParentIndex", (_options$orderedBefor = options === null || options === void 0 ? void 0 : options.orderedBeforeNode) !== null && _options$orderedBefor !== void 0 ? _options$orderedBefor : beforeRecord]];
    for (const config of configs) {
      const [children, indexName, beforeRecord2] = config;
      if (children) {
        var _options$indexName;
        const index = beforeRecord2 ? beforeRecord2[indexName] : children.length;
        config.push(index);
        children.splice(index, 0, ...newRecords);
        if (!(options !== null && options !== void 0 && (_options$indexName = options[indexName]) !== null && _options$indexName !== void 0 && _options$indexName.skip)) {
          me.updateChildrenIndices(children, indexName);
        }
      }
    }
    return configs[0][3];
  }
  removeFromChildren(childRecord, options) {
    const configs = [[this.children, "parentIndex"], [this.unfilteredChildren, "unfilteredIndex"], [this.orderedChildren, "orderedParentIndex"]];
    for (const config of configs) {
      const [children, indexName] = config;
      if (children) {
        const index = children.indexOf(childRecord);
        config.push(index);
        if (index > -1) {
          var _options$indexName2;
          children.splice(index, 1);
          if (!(options !== null && options !== void 0 && (_options$indexName2 = options[indexName]) !== null && _options$indexName2 !== void 0 && _options$indexName2.skip)) {
            this.updateChildrenIndices(children, indexName);
          }
        }
      }
    }
    return configs[0][2];
  }
  sortOrderedChildren(deep = true, usePreviousOrder = false) {
    const movedNodes = [];
    if (!this.isLeaf) {
      this.orderedChildren.sort((a, b) => {
        if (usePreviousOrder) {
          var _a$meta$modified$orde, _b$meta$modified$orde;
          const aPrevIndex = (_a$meta$modified$orde = a.meta.modified.orderedParentIndex) !== null && _a$meta$modified$orde !== void 0 ? _a$meta$modified$orde : a.orderedParentIndex, bPrevIndex = (_b$meta$modified$orde = b.meta.modified.orderedParentIndex) !== null && _b$meta$modified$orde !== void 0 ? _b$meta$modified$orde : b.orderedParentIndex, result = aPrevIndex - bPrevIndex;
          if (result !== 0) {
            movedNodes.push(a);
            movedNodes.push(b);
          }
          return result;
        } else {
          return a.orderedParentIndex - b.orderedParentIndex;
        }
      });
      if (deep) {
        this.orderedChildren.forEach((child) => {
          movedNodes.push(...child.sortOrderedChildren(deep, usePreviousOrder));
        });
      }
      this.updateChildrenIndices(this.orderedChildren, "orderedParentIndex", true);
    }
    return new Set(movedNodes);
  }
};
var propertyOverrides = {
  id: 1,
  stores: 1,
  parentIndex: 1,
  parent: 1,
  previousSibling: 1,
  nextSibling: 1,
  unfilteredIndex: 1
};
var proxyConfig = {
  get(target, prop) {
    if (prop === "proxyMeta") {
      return this.proxyMeta;
    }
    if (prop === "constructor") {
      return target.constructor;
    }
    if (prop === "setData") {
      return this.setDataOverride;
    }
    if (prop === "set") {
      return this.setOverride;
    }
    if (propertyOverrides[prop]) {
      return this.proxyMeta.data[prop];
    }
    return Reflect.get(target, prop, this.proxyRecord);
  },
  set(target, prop, value) {
    if (propertyOverrides[prop]) {
      this.proxyMeta.data[prop] = value;
    } else {
      target[prop] = value;
    }
    return true;
  },
  setDataOverride(toSet, value) {
    if (toSet === "parentIndex") {
      this.proxyMeta.data.parentIndex = value;
    } else {
      this.proxyMeta.originalRecord.setData(toSet, value);
    }
  },
  setOverride(field, value, ...args) {
    if (field === "parentIndex") {
      this.proxyMeta.data.parentIndex = value;
    } else {
      this.proxyMeta.originalRecord.set(field, value, ...args);
    }
  }
};
var ModelLink = (Target) => {
  var _class;
  return _class = class ModelLink extends (Target || Base$1) {
    link() {
      if (this.isLinked) {
        return this.$original.link();
      }
      const me = this, useConfig = _objectSpread2(_objectSpread2({}, proxyConfig), {}, {
        proxyMeta: {
          originalRecord: me,
          data: {
            id: `${me.id}_link_${StringHelper.generateUUID()}`,
            stores: []
          }
        }
      }), proxyRecord = new Proxy(me, useConfig);
      useConfig.proxyRecord = proxyRecord;
      (me.meta.linkedRecords || (me.meta.linkedRecords = [])).push(proxyRecord);
      return proxyRecord;
    }
    get isLinked() {
      var _this$proxyMeta;
      return Boolean((_this$proxyMeta = this.proxyMeta) === null || _this$proxyMeta === void 0 ? void 0 : _this$proxyMeta.originalRecord);
    }
    get hasLinks() {
      return Boolean(!this.proxyMeta && this.$links.length);
    }
    removeLink(link, records = null, silent = false) {
      if (link.hasLinks) {
        for (const linked of link.$links.slice()) {
          if (records) {
            ArrayHelper.include(records, linked);
          } else {
            linked.remove(silent);
          }
        }
      } else if (link.isLinked) {
        ArrayHelper.remove(link.$original.$links, link);
      }
    }
    beforeRemove(records) {
      this.removeLink(this, records);
    }
    removeChild(childRecords, isMove, silent, options) {
      if (!(options !== null && options !== void 0 && options.isInserting)) {
        childRecords = ArrayHelper.asArray(childRecords);
        for (const child of childRecords) {
          this.removeLink(child, null, silent);
        }
      }
      return super.removeChild(childRecords, isMove, silent, options);
    }
    get $originalId() {
      return this.$original.id;
    }
    get $links() {
      var _this$meta$linkedReco;
      return (_this$meta$linkedReco = this.meta.linkedRecords) !== null && _this$meta$linkedReco !== void 0 ? _this$meta$linkedReco : [];
    }
  }, _defineProperty(_class, "$name", "ModelLink"), _class;
};
var {
  defineProperty: defineProperty$4
} = Reflect;
var ownerSymbol = Symbol("owner");
var typeSplitRe = /[\s,]+/;
var Factoryable = (Target) => class Factoryable extends (Target || Base$1) {
  static get $name() {
    return "Factoryable";
  }
  static get declarable() {
    return [
      "factoryable",
      "alias",
      "type"
    ];
  }
  static register(type, cls, replace = globalThis.__BRYNTUM_EXAMPLE) {
    const {
      factoryable
    } = this.initClass(), {
      caseless,
      registry: registry2
    } = factoryable, types = StringHelper.split(type, typeSplitRe);
    for (let lower, name, i = 0; i < types.length; ++i) {
      name = types[i];
      lower = caseless ? name.toLowerCase() : name;
      if (!replace && lower in registry2) {
        throw new Error(`Type "${name}" already registered with ${factoryable.class.name} factory`);
      }
      registry2[name] = registry2[lower] = cls.initClass();
    }
  }
  static isA(instance, type) {
    return this.isType(instance, type, true);
  }
  static isType(instance, type, deep) {
    const {
      factoryable
    } = this, {
      caseless,
      registry: registry2
    } = factoryable, typeCls = registry2[caseless ? type.toLowerCase() : type];
    if (typeCls) {
      if (deep) {
        return instance instanceof typeCls;
      }
      return instance.constructor === typeCls;
    }
    return false;
  }
  static setupAlias(cls) {
    cls.register(cls.alias, cls);
  }
  static setupFactoryable(cls, meta) {
    const superClass = meta.super.class;
    let {
      factoryable
    } = cls;
    factoryable = _objectSpread2({
      caseless: true,
      defaultType: null,
      extends: superClass.factoryable ? [superClass] : null,
      typeKey: "type"
    }, factoryable);
    factoryable.class = cls;
    factoryable.registry = /* @__PURE__ */ Object.create(null);
    if (factoryable.extends && !Array.isArray(factoryable.extends)) {
      factoryable.extends = [factoryable.extends];
    }
    defineProperty$4(cls, "factoryable", {
      get() {
        return factoryable;
      }
    });
  }
  static setupType(cls, meta) {
    const {
      type
    } = cls;
    cls.register(type, cls, meta.replaceType);
    defineProperty$4(cls.prototype, "type", {
      value: type
    });
  }
  static create(config, options) {
    return this.reconfigure(null, config, options);
  }
  static reconfigure(existingInstance, config, options) {
    const me = this, {
      factoryable
    } = me, {
      typeKey
    } = factoryable;
    let defaultType = options, cleanup, defaults, mergeType, owner, prepared, setup, t, transform, type;
    if (options && !ObjectHelper.isClass(options)) {
      defaultType = null;
      t = typeof options;
      if (t === "function") {
        setup = options;
      } else if (t === "string") {
        defaultType = options;
      } else if (ObjectHelper.isObject(options)) {
        cleanup = options.cleanup;
        defaults = options.defaults;
        owner = options.owner;
        setup = options.setup;
        defaultType = options.type;
        transform = options.transform;
      } else {
        owner = options;
      }
    }
    if (transform) {
      config = typeof transform === "string" ? owner[transform](config) : transform(config);
    }
    type = config;
    if (typeof type === "string") {
      config = {};
    } else if (config) {
      if (config === true) {
        config = {};
      }
      if (!ObjectHelper.isObject(config)) {
        if (owner && config !== existingInstance && (existingInstance === null || existingInstance === void 0 ? void 0 : existingInstance[ownerSymbol]) === owner) {
          var _cleanup;
          typeof cleanup === "string" ? owner[cleanup](existingInstance) : (_cleanup = cleanup) === null || _cleanup === void 0 ? void 0 : _cleanup(existingInstance);
          existingInstance.destroy();
        }
        return config;
      }
      type = config[typeKey];
    }
    type = type && me.resolveType(type);
    if (existingInstance) {
      if (config && (!type || existingInstance.constructor === type)) {
        if (typeKey in config) {
          config = ObjectHelper.assign({}, config);
          delete config[typeKey];
        }
        existingInstance.setConfig(config);
        return existingInstance;
      }
      if (owner && existingInstance[ownerSymbol] === owner) {
        var _cleanup2;
        typeof cleanup === "string" ? owner[cleanup](existingInstance) : (_cleanup2 = cleanup) === null || _cleanup2 === void 0 ? void 0 : _cleanup2(existingInstance);
        existingInstance.destroy();
      }
    }
    if (config) {
      if (defaults) {
        if (!(mergeType = type)) {
          if (!(mergeType = defaults[typeKey] || defaultType || factoryable.defaultType)) {
            throw new Error(`No default mergeType defined for ${factoryable.class.name} factory`);
          }
          mergeType = me.resolveType(mergeType);
        }
        if (mergeType) {
          config = mergeType.mergeConfigs(defaults, config);
        }
      }
      if (setup) {
        prepared = typeof setup === "string" ? owner[setup](config, type, defaults) : setup(config, type, defaults);
        if (prepared === null) {
          return prepared;
        }
        config = prepared || config;
      }
      if (!type) {
        if (!(type = config[typeKey] || defaultType || factoryable.defaultType)) {
          throw new Error(`No default type defined for ${factoryable.class.name} factory`);
        }
        type = me.resolveType(type);
      }
      if (defaults && !mergeType) {
        config = type.mergeConfigs(defaults, config);
      }
      if (typeKey in config) {
        config = ObjectHelper.assign({}, config);
        delete config[typeKey];
      }
      config = new type(config);
      if (owner) {
        config[ownerSymbol] = owner;
      }
    }
    return config || null;
  }
  static resolveType(type, optional) {
    if (typeof type !== "string") {
      return type;
    }
    const {
      factoryable
    } = this, bases = factoryable.extends;
    let result = factoryable.registry[factoryable.caseless ? type.toLowerCase() : type], i;
    for (i = 0; !result && bases && i < bases.length; ++i) {
      result = bases[i].resolveType(type, true);
    }
    if (!result && !optional) {
      throw new Error(`Invalid type name "${type}" passed to ${factoryable.class.name} factory`);
    }
    return result;
  }
};
var {
  getOwnPropertyDescriptor
} = Reflect;
var DataField = class extends Base$1.mixin(Factoryable) {
  static get $name() {
    return "DataField";
  }
  static get type() {
    return "auto";
  }
  static get factoryable() {
    return {
      defaultType: "auto"
    };
  }
  static get prototypeProperties() {
    return {
      compare: null,
      compareItems: null,
      dataSource: null,
      alwaysWrite: false,
      nullable: true,
      nullText: null,
      nullValue: void 0,
      persist: true,
      readOnly: false,
      internal: false
    };
  }
  construct(config) {
    const me = this;
    if (config) {
      me.name = config.name;
      Object.assign(me, config);
    }
    if (me.compare) {
      me.compareItems = (itemA, itemB) => me.compare(itemA === null || itemA === void 0 ? void 0 : itemA[me.name], itemB === null || itemB === void 0 ? void 0 : itemB[me.name]);
    }
  }
  defineAccessor(target, force) {
    const {
      name,
      dataSource
    } = this;
    if (!force && name in target && target.$meta.hierarchy.some((current) => {
      var _getOwnPropertyDescri;
      return ((_getOwnPropertyDescri = getOwnPropertyDescriptor(current.prototype, name)) === null || _getOwnPropertyDescri === void 0 ? void 0 : _getOwnPropertyDescri.enumerable) === false;
    })) {
      return;
    }
    Reflect.defineProperty(target, name, {
      configurable: true,
      enumerable: true,
      get: this.complexMapping ? function() {
        return this.complexGet(name, dataSource);
      } : function() {
        if (this.batching && name in this.meta.batchChanges) {
          return this.meta.batchChanges[name];
        }
        return dataSource in this.data ? this.data[dataSource] : this.data[name];
      },
      set(value) {
        const field = this.$meta.fields.map[name];
        if (!(field && field.readOnly)) {
          this.set(name, value);
        }
      }
    });
  }
  isEqual(first, second) {
    return ObjectHelper.isEqual(first, second);
  }
  print(value) {
    return value == null ? this.nullText : this.printValue(value);
  }
  printValue(value) {
    return String(value);
  }
};
DataField._$name = "DataField";
var ArrayDataField = class extends DataField {
  static get $name() {
    return "ArrayDataField";
  }
  static get type() {
    return "array";
  }
  isEqual(a, b) {
    return a === b;
  }
};
ArrayDataField.initClass();
ArrayDataField._$name = "ArrayDataField";
var BooleanDataField = class extends DataField {
  static get $name() {
    return "BooleanDataField";
  }
  static get type() {
    return "boolean";
  }
  static get alias() {
    return "bool";
  }
  static get prototypeProperties() {
    return {
      nullValue: false
    };
  }
  isEqual(first, second) {
    if (first == null && second == null) {
      return true;
    }
    return super.isEqual(first, second);
  }
  convert(value) {
    var _value$toLowerCase;
    if (value == null) {
      return this.nullable ? value : this.nullValue;
    }
    if (((_value$toLowerCase = value.toLowerCase) === null || _value$toLowerCase === void 0 ? void 0 : _value$toLowerCase.call(value)) === "false") {
      return false;
    }
    return Boolean(value);
  }
};
BooleanDataField.initClass();
BooleanDataField._$name = "BooleanDataField";
var DateDataField = class extends DataField {
  static get $name() {
    return "DateDataField";
  }
  static get type() {
    return "date";
  }
  static get prototypeProperties() {
    return {
      format: null
    };
  }
  convert(value) {
    if (value == null) {
      if (!this.nullable) {
        value = this.nullValue;
      }
    } else if (value === "now") {
      value = new Date();
    } else if (!(value instanceof Date)) {
      value = DateHelper.parse(value, this.format || DateHelper.defaultParseFormat);
      if (!value || isNaN(value)) {
        value = void 0;
      }
    }
    return value;
  }
  serialize(value) {
    if (value instanceof Date) {
      value = DateHelper.format(value, this.format || DateHelper.defaultFormat);
    }
    return value;
  }
  printValue(value) {
    return DateHelper.format(value, this.format || DateHelper.defaultFormat);
  }
};
DateDataField.initClass();
DateDataField._$name = "DateDataField";
var StringDataField = class extends DataField {
  static get $name() {
    return "StringDataField";
  }
  static get type() {
    return "string";
  }
  static get prototypeProperties() {
    return {
      nullValue: ""
    };
  }
  convert(value) {
    return value == null ? this.nullable ? value : this.nullValue : String(value);
  }
};
StringDataField.initClass();
StringDataField._$name = "StringDataField";
var DurationUnitDataField = class extends StringDataField {
  static get $name() {
    return "DurationUnitDataField";
  }
  static get type() {
    return "durationunit";
  }
  isEqual(first, second) {
    return DateHelper.compareUnits(first, second) === 0;
  }
};
DurationUnitDataField.initClass();
DurationUnitDataField._$name = "DurationUnitDataField";
var IntegerDataField = class extends DataField {
  static get $name() {
    return "IntegerDataField";
  }
  static get type() {
    return "integer";
  }
  static get alias() {
    return "int";
  }
  static get prototypeProperties() {
    return {
      nullValue: 0,
      rounding: "round"
    };
  }
  convert(value) {
    return value == null ? this.nullable ? value : this.nullValue : Math[this.rounding](Number(value));
  }
};
IntegerDataField.initClass();
IntegerDataField._$name = "IntegerDataField";
var ModelDataField = class extends DataField {
  static get $name() {
    return "ModelDataField";
  }
  static get type() {
    return "model";
  }
  static get prototypeProperties() {
    return {
      complexMapping: true
    };
  }
  isEqual(first, second) {
    return first && second && second instanceof first.constructor && second.id == first.id;
  }
};
ModelDataField.initClass();
ModelDataField._$name = "ModelDataField";
var NumberDataField = class extends DataField {
  static get $name() {
    return "NumberDataField";
  }
  static get type() {
    return "number";
  }
  static get alias() {
    return "float";
  }
  static get prototypeProperties() {
    return {
      nullValue: 0,
      precision: null
    };
  }
  isEqual(first, second) {
    return isNaN(Number(first)) && isNaN(Number(second)) || super.isEqual(first, second);
  }
  convert(value) {
    if (value == null) {
      return this.nullable ? value : this.nullValue;
    }
    value = Number(value);
    if (isNaN(value)) {
      return;
    }
    let scale = this.precision;
    if (scale) {
      scale = 10 ** scale;
      value = Math.round(value * scale) / scale;
    } else if (scale === 0) {
      value = Math.round(value);
    }
    return value;
  }
};
NumberDataField.initClass();
NumberDataField._$name = "NumberDataField";
var ObjectDataField = class extends DataField {
  static get $name() {
    return "ObjectDataField";
  }
  static get type() {
    return "object";
  }
  static get prototypeProperties() {
    return {
      complexMapping: true
    };
  }
};
ObjectDataField.initClass();
ObjectDataField._$name = "ObjectDataField";
var StoreDataField = class extends DataField {
  init(data, record) {
    var _record;
    const me = this, storeName = `${me.name}Store`, config = {
      skipStack: true
    };
    if (me.modelClass) {
      config.modelClass = me.modelClass;
    }
    (_record = record[`init${StringHelper.capitalize(storeName)}`]) === null || _record === void 0 ? void 0 : _record.call(record, config);
    if (!config.storeClass && !me.storeClass) {
      throw new Error(`Field '${me.name}' with type 'store' must have a storeClass configured`);
    }
    const store = record.meta[storeName] = new (config.storeClass || me.storeClass)(config);
    if (me.complexMapping) {
      ObjectHelper.setPath(data, me.dataSource, store);
    } else {
      data[me.dataSource] = store;
    }
    store.verifyNoGeneratedIds = false;
    store.usesId = !store.count || !store.every((record2) => record2.hasGeneratedId);
    store.$currentValue = me.getValue(store);
    store.ion({
      change: ({
        action
      }) => {
        const value = me.getValue(store);
        if (!store.$isSettingStoreFieldData) {
          const oldPreserveCurrentDataset = store.$preserveCurrentDataset;
          store.$preserveCurrentDataset = me.subStore && (action === "update" || action === "remove" || action === "add");
          record.set(me.name, value);
          store.$preserveCurrentDataset = oldPreserveCurrentDataset;
        }
        store.$currentValue = value;
      }
    });
  }
  set(value, data, record) {
    var _record2, _record3;
    const me = this, storeName = `${me.name}Store`, {
      [storeName]: store
    } = record.meta;
    if (!store) {
      record.meta.initableValues.set(me, value);
      return false;
    }
    if (store.$isSettingStoreFieldData) {
      return;
    }
    store.$isSettingStoreFieldData = true;
    value = (_record2 = (_record3 = record[`process${StringHelper.capitalize(storeName)}Data`]) === null || _record3 === void 0 ? void 0 : _record3.call(record, value, record)) !== null && _record2 !== void 0 ? _record2 : value;
    if (!store.$preserveCurrentDataset) {
      store.data = value;
    }
    store.$isSettingStoreFieldData = false;
    store.usesId = !store.count || !store.every((record2) => record2.hasGeneratedId);
  }
  serialize(value, record) {
    return record.meta[`${this.name}Store`].$currentValue;
  }
  getValue(store) {
    return store.allRecords.map((r) => {
      const data = r.persistableData;
      if (!store.usesId) {
        delete data.id;
      }
      return data;
    });
  }
  isEqual(a, b) {
    var _a, _b;
    if ((_a = a) !== null && _a !== void 0 && _a.isStore) {
      a = a.$currentValue;
    }
    if ((_b = b) !== null && _b !== void 0 && _b.isStore) {
      b = b.$currentValue;
    }
    return ObjectHelper.isDeeplyEqual(a, b);
  }
};
_defineProperty(StoreDataField, "$name", "StoreDataField");
_defineProperty(StoreDataField, "type", "store");
StoreDataField.initClass();
StoreDataField._$name = "StoreDataField";
var {
  defineProperty: defineProperty$3
} = Reflect;
var {
  hasOwn: hasOwn$1
} = ObjectHelper;
var _undefined = void 0;
var internalProps = {
  children: 1,
  data: 1,
  meta: 1
};
var abbreviationFields = ["name", "title", "text", "label", "description"];
var fieldDataTypes = {
  boolean: 1,
  number: 1,
  date: 1,
  object: 1
};
var Model = class extends Base$1.mixin(ModelStm, TreeNode, ModelLink) {
  static get $name() {
    return "Model";
  }
  static get declarable() {
    return [
      "fields"
    ];
  }
  static get fields() {
    return [
      {
        name: "parentIndex",
        type: "number",
        persist: false,
        internal: true
      },
      {
        name: "orderedParentIndex",
        type: "number",
        persist: false,
        internal: true
      },
      {
        name: "readOnly",
        type: "boolean"
      }
    ];
  }
  static set idField(idField) {
    this._assignedIdField = true;
    this._idField = idField;
  }
  static get idField() {
    return this._idField;
  }
  static set childrenField(childrenField) {
    this._childrenField = childrenField;
  }
  static get childrenField() {
    if (!this._childrenField) {
      const dataField = this.fieldMap.children;
      this._childrenField = (dataField === null || dataField === void 0 ? void 0 : dataField.dataSource) || "children";
    }
    return this._childrenField;
  }
  get indexPath() {
    const indices = [];
    let node = this, depth = node.childLevel;
    for (node = this; node && !node.isRoot; node = node.parent) {
      indices[depth--] = node.parentIndex + 1;
    }
    return indices;
  }
  construct(data = {}, store = null, meta = null, skipExpose = false, forceUseRaw = false, rawData = false) {
    var _ArrayHelper$asArray, _me$meta$initableValu;
    const me = this, stores2 = (_ArrayHelper$asArray = ArrayHelper.asArray(store)) !== null && _ArrayHelper$asArray !== void 0 ? _ArrayHelper$asArray : [], {
      constructor,
      fieldMap
    } = me;
    let configs = null;
    store = stores2[0];
    me.meta = _objectSpread2(_objectSpread2({
      modified: {}
    }, constructor.metaConfig), meta);
    if (constructor.applyConfigs) {
      for (const key in me.getDefaultConfiguration()) {
        if (!configs) {
          configs = {};
          if (!me.useRawData || !me.useRawData.enabled) {
            data = _objectSpread2({}, data);
          }
        }
        if (key in data) {
          if (data[key] !== void 0) {
            configs[key] = data[key];
          }
          delete data[key];
        }
      }
    }
    super.construct(configs);
    if (!skipExpose) {
      constructor.exposeProperties(data, rawData);
    }
    if (!hasOwn$1(constructor, "idFieldProcessed")) {
      let overriddenIdField = me.meta.idField;
      if (!overriddenIdField) {
        if (constructor._assignedIdField) {
          overriddenIdField = constructor.idField;
        } else if (store) {
          overriddenIdField = store.idField;
        }
      }
      if (overriddenIdField && overriddenIdField !== fieldMap.id.dataSource) {
        constructor.addField({
          name: "id",
          dataSource: overriddenIdField,
          internal: true
        });
      }
      constructor._idField = fieldMap.id.dataSource;
      constructor.idFieldProcessed = true;
    }
    me._internalId = Model._internalIdCounter++;
    me.stores = [];
    me.unjoinedStores = [];
    if (!me.originalData) {
      me.originalData = data;
    }
    me.data = constructor.processData(data, false, store, me, forceUseRaw);
    ((_me$meta$initableValu = me.meta.initableValues) === null || _me$meta$initableValu === void 0 ? void 0 : _me$meta$initableValu.size) && me.assignInitables();
    if (me.id == null) {
      me.setData("id", me.generateId(store));
    }
    if (me.data[constructor.childrenField]) {
      me.processChildren(stores2);
    }
    me.generation = 0;
  }
  set isCreating(isCreating) {
    const me = this;
    if (Boolean(me.meta.isCreating) !== isCreating) {
      me.meta.isCreating = isCreating;
      me.stores.forEach((s) => {
        s.onIsCreatingToggle(me, isCreating);
      });
    }
  }
  get isCreating() {
    return Boolean(this.meta.isCreating);
  }
  equals(other) {
    if (other instanceof this.constructor) {
      for (let fields = this.$meta.fields.defs, i = 0, {
        length
      } = fields; i < length; i++) {
        const field = fields[i], {
          name
        } = field;
        if (name !== "id" && !field.isEqual(this[name], other[name])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  get subclass() {
    return new this.constructor(Object.setPrototypeOf({
      id: _undefined
    }, this.data), this.stores[0], null, true);
  }
  static processData(data, ignoreDefaults = false, store, record, forceUseRaw) {
    const {
      fieldMap,
      defaultValues
    } = this, {
      useRawData = {
        enabled: false
      }
    } = store || {}, processed = forceUseRaw || useRawData.enabled ? data : ObjectHelper.clone(data);
    let fieldName;
    ignoreDefaults = ignoreDefaults || useRawData.disableDefaultValue || forceUseRaw;
    if (!ignoreDefaults) {
      for (fieldName in defaultValues) {
        if (processed[fieldName] === _undefined) {
          let defaultValue2 = defaultValues[fieldName];
          if (Array.isArray(defaultValue2)) {
            defaultValue2 = defaultValue2.slice();
          }
          processed[fieldName] = defaultValue2;
        }
      }
    }
    if (!useRawData.disableTypeConversion && !forceUseRaw) {
      for (fieldName in fieldMap) {
        const field = fieldMap[fieldName], {
          name,
          dataSource
        } = field, hasSource = dataSource !== name, complex = field.complexMapping, sourceExists = hasSource && (complex ? ObjectHelper.pathExists(data, dataSource) : dataSource in data), useNameForValue = name in data && (!hasSource || !sourceExists), convert = !useRawData.disableTypeConversion && field.convert;
        if (useNameForValue || convert) {
          if (!ignoreDefaults || useNameForValue || sourceExists) {
            const value = useNameForValue ? processed[name] : complex ? ObjectHelper.getPath(processed, dataSource) : processed[dataSource], converted = convert ? field.convert(value, record) : value;
            if (complex) {
              ObjectHelper.setPath(processed, dataSource, converted);
            } else {
              processed[dataSource] = converted;
            }
            if (hasSource) {
              delete processed[name];
            }
          }
        }
      }
    }
    this.$meta.fields.initable.length && this.initInitables(record, processed);
    return processed;
  }
  static setupClass(meta) {
    super.setupClass(meta);
    if (!meta.fields) {
      this.setupFields(this, meta);
    }
  }
  static setupFields(cls, meta) {
    var _base$defs$slice, _base$exposed, _base$ordinals, _base$map, _base$sources;
    const classFields = hasOwn$1(cls, "fields") && cls.fields, base = meta.super.fields, fieldsInfo = meta.fields = {
      defs: (_base$defs$slice = base === null || base === void 0 ? void 0 : base.defs.slice()) !== null && _base$defs$slice !== void 0 ? _base$defs$slice : [],
      exposedData: false,
      defaults: base ? _objectSpread2({}, base.defaults) : {},
      exposed: Object.create((_base$exposed = base === null || base === void 0 ? void 0 : base.exposed) !== null && _base$exposed !== void 0 ? _base$exposed : null),
      ordinals: Object.create((_base$ordinals = base === null || base === void 0 ? void 0 : base.ordinals) !== null && _base$ordinals !== void 0 ? _base$ordinals : null),
      map: Object.create((_base$map = base === null || base === void 0 ? void 0 : base.map) !== null && _base$map !== void 0 ? _base$map : null),
      sources: Object.create((_base$sources = base === null || base === void 0 ? void 0 : base.sources) !== null && _base$sources !== void 0 ? _base$sources : null)
    };
    if (hasOwn$1(cls, "defaults")) {
      Object.assign(fieldsInfo.defaults, cls.defaults);
    }
    if (hasOwn$1(cls, "idField")) {
      cls.addField({
        name: "id",
        dataSource: cls.idField,
        internal: true
      });
      fieldsInfo.exposed[cls.idField] = true;
    }
    if (classFields !== null && classFields !== void 0 && classFields.length) {
      classFields.map(cls.addField, cls);
    }
    fieldsInfo.initable = fieldsInfo.defs.filter((field) => field.init);
    cls.exposeRelations();
  }
  static get defaultValues() {
    return this.$meta.fields.defaults;
  }
  static get allFields() {
    return this.$meta.fields.defs;
  }
  get allFields() {
    return this.$meta.fields.defs;
  }
  static get fieldMap() {
    return this.$meta.fields.map;
  }
  get fieldMap() {
    return this.$meta.fields.map;
  }
  static get fieldDataSourceMap() {
    return this.$meta.fields.sources;
  }
  static exposeProperties(data, raw = true) {
    const me = this, fieldsInfo = me.$meta.fields, fieldMapProperty = raw ? "exposed" : "map";
    if (data && me.autoExposeFields && !fieldsInfo.exposedData) {
      let dataProperty, fieldDef, type;
      for (dataProperty in data) {
        if (!fieldsInfo[fieldMapProperty][dataProperty] && dataProperty !== me.childrenField) {
          type = ObjectHelper.typeOf(data[dataProperty]);
          fieldDef = {
            name: dataProperty,
            dataSource: dataProperty,
            fromData: true
          };
          if (fieldDataTypes[type]) {
            fieldDef.type = type;
          }
          me.addField(fieldDef);
        }
      }
      fieldsInfo.exposedData = true;
    }
    me.exposeRelations();
  }
  static addField(fieldDef) {
    if (fieldDef == null) {
      return;
    }
    if (typeof fieldDef === "string") {
      fieldDef = {
        name: fieldDef
      };
    }
    const me = this.initClass(), fieldsInfo = me.$meta.fields, {
      ordinals
    } = fieldsInfo, propertiesExposed = fieldsInfo.exposed, {
      name
    } = fieldDef, existing = fieldsInfo.map[name], dataSource = fieldDef.dataSource || (fieldDef.dataSource = name);
    let field, key;
    if (!existing || fieldDef.type && fieldDef.type !== existing.type) {
      field = DataField.create(fieldDef);
      field.definedBy = existing ? existing.definedBy : me;
      field.ordinal = existing ? existing.ordinal : ordinals[name] = fieldsInfo.defs.length;
    } else {
      field = Object.create(existing);
      for (key in fieldDef) {
        if (key !== "type") {
          field[key] = fieldDef[key];
        }
      }
    }
    field.owner = me;
    fieldsInfo.defs[field.ordinal] = field;
    fieldsInfo.map[name] = field;
    if (!fieldsInfo.sources[dataSource]) {
      fieldsInfo.sources[dataSource] = field;
    }
    if (dataSource.includes(".")) {
      field.complexMapping = true;
    }
    if (field.complexMapping) {
      propertiesExposed[dataSource.split(".")[0]] = true;
    } else {
      propertiesExposed[dataSource] = true;
    }
    if ("defaultValue" in field) {
      fieldsInfo.defaults[dataSource] = field.defaultValue;
    }
    if (!internalProps[name]) {
      field.defineAccessor(me.prototype);
    }
    me._nonPersistableFields = null;
    me._alwaysWriteFields = null;
    return field;
  }
  static removeField(fieldName) {
    const me = this.initClass(), fieldsInfo = me.$meta.fields, definition = fieldsInfo.map[fieldName], {
      ordinals
    } = fieldsInfo, index = ordinals[fieldName];
    if (definition) {
      fieldsInfo.defs.splice(index, 1);
      delete ordinals[fieldName];
      delete fieldsInfo.defaults[fieldName];
      delete fieldsInfo.exposed[fieldName];
      delete fieldsInfo.map[fieldName];
      delete fieldsInfo.sources[definition.dataSource];
      for (const name in ordinals) {
        if (ordinals[name] > index) {
          --ordinals[name];
        }
      }
      delete me.prototype[fieldName];
    }
  }
  static exposeRelations() {
    const me = this;
    if (hasOwn$1(me, "exposedRelations")) {
      return;
    }
    if (me.relations) {
      me.exposedRelations = [];
      for (const relationName in me.relations) {
        const relation = me.relations[relationName];
        relation.relationName = relationName;
        me.exposedRelations.push(relation);
        if (!Reflect.ownKeys(me.prototype).includes(relationName)) {
          defineProperty$3(me.prototype, relationName, {
            enumerable: true,
            get: function() {
              return this.getForeign(relationName);
            },
            set: function(value) {
              this.setForeign(relationName, value, relation);
            }
          });
        }
      }
    }
  }
  static initInitables(record, processedData) {
    const laterValues = record.meta.initableValues = /* @__PURE__ */ new Map();
    for (const field of this.$meta.fields.initable) {
      const value = ObjectHelper.getPath(processedData, field.dataSource);
      value !== void 0 && laterValues.set(field, value);
      !field.lazy && field.init(processedData, record);
    }
  }
  assignInitables() {
    const {
      initableValues
    } = this.meta;
    for (const [field, value] of initableValues) {
      if (field.set(value, this.data, this) !== false) {
        initableValues.delete(field);
      }
    }
  }
  static get autoExposeFields() {
    return true;
  }
  get fields() {
    return this.$meta.fields.defs;
  }
  getFieldDefinition(fieldName) {
    return this.$meta.fields.map[fieldName];
  }
  getFieldDefinitionFromDataSource(dataSource) {
    return this.$meta.fields.sources[dataSource];
  }
  get fieldNames() {
    return Object.keys(this.data);
  }
  static getFieldDefinition(fieldName) {
    return this.$meta.fields.map[fieldName];
  }
  static getFieldDataSource(fieldName) {
    return this.getFieldDefinition(fieldName).dataSource;
  }
  getDataSource(fieldName) {
    const def = this.constructor.getFieldDefinition(fieldName);
    return (def === null || def === void 0 ? void 0 : def.dataSource) || (def === null || def === void 0 ? void 0 : def.name);
  }
  static processField(fieldName, value, record) {
    const field = this.fieldMap[fieldName];
    return field !== null && field !== void 0 && field.convert ? field.convert(value, record) : value;
  }
  initRelations() {
    const me = this, relations = me.constructor.exposedRelations;
    if (!relations) {
      return;
    }
    me.stores.forEach((store) => {
      var _store$modelRelations;
      if (!store.modelRelations) {
        store.initRelations();
      }
      const relatedRecords = [];
      (_store$modelRelations = store.modelRelations) === null || _store$modelRelations === void 0 ? void 0 : _store$modelRelations.forEach((config) => {
        relatedRecords.push({
          related: me.initRelation(config),
          config
        });
      });
      store.updateRecordRelationCache(me, relatedRecords);
    });
  }
  initRelation(config) {
    const me = this, foreignId = me.get(config.foreignKey), foreign = foreignId !== _undefined && typeof config.foreignStore !== "string" && config.foreignStore.getById(foreignId), relationCache = me.meta.relationCache || (me.meta.relationCache = {});
    relationCache[config.relationName] = foreign || (foreignId != null ? {
      id: foreignId,
      placeHolder: true
    } : null);
    return foreign;
  }
  removeRelation(config) {
    const {
      relationName,
      foreignKey,
      nullFieldOnRemove
    } = config;
    if (this.meta.relationCache[relationName]) {
      delete this.meta.relationCache[relationName];
      if (nullFieldOnRemove) {
        this.setData(foreignKey, null);
      }
    }
  }
  getForeign(name) {
    var _this$meta$relationCa;
    return (_this$meta$relationCa = this.meta.relationCache) === null || _this$meta$relationCa === void 0 ? void 0 : _this$meta$relationCa[name];
  }
  setForeign(name, value, config) {
    const id = Model.asId(value);
    return this.set(config.foreignKey, id);
  }
  getRelationConfig(name) {
    var _this$firstStore, _this$firstStore$mode;
    return (_this$firstStore = this.firstStore) === null || _this$firstStore === void 0 ? void 0 : (_this$firstStore$mode = _this$firstStore.modelRelations) === null || _this$firstStore$mode === void 0 ? void 0 : _this$firstStore$mode.find((r) => r.foreignKey === name);
  }
  flatGet(fieldName, dataSource) {
    if (this.batching && fieldName in this.meta.batchChanges) {
      return this.meta.batchChanges[fieldName];
    }
    return dataSource in this.data ? this.data[dataSource] : this.data[fieldName];
  }
  complexGet(fieldName, dataSource) {
    if (this.batching && fieldName in this.meta.batchChanges) {
      return this.meta.batchChanges[fieldName];
    }
    return ObjectHelper.getPath(this.data, dataSource);
  }
  get(fieldName) {
    if (!fieldName) {
      return;
    }
    const field = this.fieldMap[fieldName];
    if (!field && fieldName.includes(".")) {
      return this.complexGet(fieldName, fieldName);
    }
    if (field !== null && field !== void 0 && field.complexMapping) {
      return this.complexGet(fieldName, field.dataSource);
    }
    return this.flatGet(fieldName, (field === null || field === void 0 ? void 0 : field.dataSource) || fieldName);
  }
  setData(toSet, value) {
    const {
      data,
      fieldMap
    } = this;
    if (typeof toSet === "string") {
      var _field$dataSource;
      const field = fieldMap[toSet], dataSource = (_field$dataSource = field === null || field === void 0 ? void 0 : field.dataSource) !== null && _field$dataSource !== void 0 ? _field$dataSource : toSet;
      if (field !== null && field !== void 0 && field.set) {
        field.set(value, this.data, this);
      } else if (field !== null && field !== void 0 && field.complexMapping) {
        ObjectHelper.setPath(data, dataSource, value);
      } else {
        data[dataSource] = value;
      }
    } else {
      const keys = Object.keys(toSet);
      for (let i = 0; i < keys.length; i++) {
        var _field$dataSource2;
        const fieldName = keys[i], field = fieldMap[fieldName], dataSource = (_field$dataSource2 = field === null || field === void 0 ? void 0 : field.dataSource) !== null && _field$dataSource2 !== void 0 ? _field$dataSource2 : fieldName;
        if (field !== null && field !== void 0 && field.set) {
          field.set(value, this.data, this);
        } else if (dataSource) {
          if (field !== null && field !== void 0 && field.complexMapping) {
            ObjectHelper.setPath(data, dataSource, toSet[fieldName]);
          } else {
            data[dataSource] = toSet[fieldName];
          }
        }
      }
    }
  }
  getData(fieldName) {
    var _field$dataSource3;
    const field = this.fieldMap[fieldName], dataSource = (_field$dataSource3 = field === null || field === void 0 ? void 0 : field.dataSource) !== null && _field$dataSource3 !== void 0 ? _field$dataSource3 : fieldName;
    if (dataSource) {
      if (field !== null && field !== void 0 && field.complexMapping) {
        return ObjectHelper.getPath(this.data, dataSource);
      }
      return this.data[dataSource];
    }
  }
  syncId(value) {
    const oldValue = this.id;
    if (oldValue !== value) {
      this.setData("id", value);
      const data = {
        id: {
          value,
          oldValue
        }
      };
      this.afterChange(data, data);
    }
  }
  set(field, value, silent = false, fromRelationUpdate = false, skipAccessors = false, validOnly = false) {
    const me = this;
    if (me.isBatchUpdating) {
      me.inBatchSet(field, value, silent || me.$silenceBatch);
      return null;
    } else {
      var _me$beforeSet, _me$afterSet;
      const preResult = (_me$beforeSet = me.beforeSet) === null || _me$beforeSet === void 0 ? void 0 : _me$beforeSet.call(me, field, value, silent, fromRelationUpdate), wasSet = me.inSet(field, value, silent, fromRelationUpdate, skipAccessors, validOnly);
      (_me$afterSet = me.afterSet) === null || _me$afterSet === void 0 ? void 0 : _me$afterSet.call(me, field, value, silent, fromRelationUpdate, preResult, wasSet);
      return wasSet;
    }
  }
  fieldToKeys(field, value) {
    if (typeof field !== "string") {
      return ObjectHelper.assign({}, field);
    }
    return {
      [field]: value
    };
  }
  inBatchSet(field, value, silent) {
    const me = this, {
      meta,
      constructor,
      fieldMap
    } = me, wasSet = {};
    let cmp, changed = false;
    if (typeof field !== "string") {
      Object.keys(me.fieldToKeys(field, value)).forEach((key) => {
        cmp = fieldMap[key] || ObjectHelper;
        value = constructor.processField(key, field[key], me);
        if (!cmp.isEqual(meta.batchChanges[key], value)) {
          wasSet[key] = {
            value,
            oldValue: me.get(key)
          };
          meta.batchChanges[key] = value;
          changed = true;
        }
      });
    } else {
      cmp = fieldMap[field] || ObjectHelper;
      if (!cmp.isEqual(meta.batchChanges[field], value)) {
        wasSet[field] = {
          value,
          oldValue: me.get(field)
        };
        meta.batchChanges[field] = value;
        changed = true;
      }
    }
    if (changed) {
      me.generation++;
      if (!silent) {
        const event = {
          action: "update",
          record: me,
          records: [me],
          changes: wasSet
        };
        me.stores.forEach((store) => {
          store.trigger("batchedUpdate", _objectSpread2({}, event));
        });
        me.forEachLinked((store, record) => store.trigger("batchedUpdate", _objectSpread2(_objectSpread2({}, event), {}, {
          record,
          records: [record]
        })));
      }
    }
  }
  inSet(field, value, silent, fromRelationUpdate, skipAccessors = false, validOnly = false) {
    const me = this, {
      data,
      meta,
      fieldMap,
      constructor
    } = me, {
      prototype: myProto,
      childrenField
    } = constructor, wasSet = {}, toSet = me.fieldToKeys(field, value), keys = Object.keys(toSet);
    let changed = false;
    if (!silent && !me.triggerBeforeUpdate(toSet)) {
      return null;
    }
    me.inSetting = true;
    for (let i = 0; i < keys.length; i++) {
      var _field$dataSource4;
      const key = keys[i];
      if (key === childrenField) {
        continue;
      }
      const field2 = fieldMap[key], cmp = field2 || ObjectHelper, readOnly = field2 === null || field2 === void 0 ? void 0 : field2.readOnly, mapping = (_field$dataSource4 = field2 === null || field2 === void 0 ? void 0 : field2.dataSource) !== null && _field$dataSource4 !== void 0 ? _field$dataSource4 : key, useProp = !skipAccessors && !field2 && key in myProto, oldValue = useProp ? me[mapping] : field2 !== null && field2 !== void 0 && field2.complexMapping ? ObjectHelper.getPath(data, mapping) : data[mapping], value2 = constructor.processField(key, toSet[key], me), val = toSet[key] = {
        value: value2
      }, relation = me.getRelationConfig(key);
      if (!readOnly && !cmp.isEqual(oldValue, value2) && (!validOnly || value2 !== void 0)) {
        me.generation++;
        val.oldValue = oldValue;
        changed = true;
        if (cmp.isEqual(me.meta.modified[key], value2)) {
          Reflect.deleteProperty(meta.modified, key);
        } else if (!me.ignoreBag) {
          if (!(key in meta.modified)) {
            me.storeFieldChange(key, oldValue);
          }
          if (val.oldValue === _undefined) {
            Reflect.deleteProperty(val, "oldValue");
          }
        }
        wasSet[key] = val;
        me.applyValue(useProp, mapping, value2, skipAccessors, field2);
        if (relation && !fromRelationUpdate) {
          me.initRelation(relation);
          me.stores.forEach((store) => store.cacheRelatedRecord(me, value2, relation.relationName, val.oldValue));
        }
      }
    }
    if (changed) {
      me.afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    me.inSetting = false;
    return changed ? wasSet : null;
  }
  applyValue(useProp, key, value, skipAccessors, field) {
    var _field, _field3;
    const me = this;
    let complexMapping = (_field = field) === null || _field === void 0 ? void 0 : _field.complexMapping;
    if (key === me.constructor.parentIdField) {
      (me.firstStore.getById(value) || me.firstStore.rootNode).insertChild(me, null, false, {
        orderedParentIndex: {
          skip: true
        }
      });
      return;
    } else if (useProp) {
      var _field2;
      me[((_field2 = field) === null || _field2 === void 0 ? void 0 : _field2.name) || key] = value;
      return;
    }
    if ((_field3 = field) !== null && _field3 !== void 0 && _field3.set) {
      field.set(value, me.data, me);
      return;
    }
    if (!field && key.includes(".")) {
      var _field4, _field5;
      const nestedName = key.split(".")[0];
      field = me.constructor.fieldMap[nestedName];
      complexMapping = ((_field4 = field) === null || _field4 === void 0 ? void 0 : _field4.complexMapping) || ((_field5 = field) === null || _field5 === void 0 ? void 0 : _field5.type) === "object";
    }
    if (complexMapping) {
      ObjectHelper.setPath(me.data, key, value);
    } else {
      me.data[key] = value;
    }
  }
  afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {
    for (const store of this.stores) {
      store.onModelChange(this, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    this.forEachLinked((store, record) => store.onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors));
  }
  forEachLinked(fn2) {
    for (const linked of this.$links) {
      for (const store of linked.stores) {
        fn2(store, linked);
      }
    }
  }
  get isPersistable() {
    return !this.isBatchUpdating && !this.isCreating;
  }
  get isModified() {
    return Boolean(this.meta.modified && Object.keys(this.meta.modified).length > 0);
  }
  get hasPersistableChanges() {
    return this.isPersistable && !ObjectHelper.isEmpty(this.rawModificationData);
  }
  isFieldModified(fieldName) {
    return this.isModified && fieldName in this.meta.modified;
  }
  getFieldPersistentValue(nameOrField) {
    const field = typeof nameOrField === "string" ? this.getFieldDefinition(nameOrField) : nameOrField, name = (field === null || field === void 0 ? void 0 : field.name) || nameOrField;
    let result;
    if (!field || field.persist) {
      result = this[name];
      if (field !== null && field !== void 0 && field.serialize) {
        result = field.serialize(result, this);
      }
    }
    return result;
  }
  get modifications() {
    const data = this.rawModifications;
    if (data && Object.keys(data).length) {
      data[this.constructor.idField] = this.id;
    }
    return data;
  }
  get rawModifications() {
    const me = this, data = {};
    if (!me.isModified) {
      return null;
    }
    let keySet = false;
    Object.keys(me.meta.modified).forEach((key) => {
      const value = me.getFieldPersistentValue(key);
      if (value !== _undefined) {
        data[key] = value;
        keySet = true;
      }
    });
    return keySet ? data : null;
  }
  get modificationData() {
    const data = this.rawModificationData;
    if (data && Object.keys(data).length) {
      ObjectHelper.setPath(data, this.constructor.idField, this.id);
    }
    return data;
  }
  get rawModificationData() {
    const me = this, {
      fieldMap
    } = me.constructor, data = {};
    if (!me.isModified) {
      return null;
    }
    let keySet = false;
    Object.keys(me.meta.modified).forEach((fieldName) => {
      const field = fieldMap[fieldName];
      if (field !== null && field !== void 0 && field.persist) {
        const value = me.getFieldPersistentValue(fieldName);
        if (value !== _undefined) {
          ObjectHelper.setPath(data, field.dataSource, value);
          keySet = true;
        }
      }
    });
    return keySet ? data : null;
  }
  get modificationDataToWrite() {
    const alwaysWriteFields = this.constructor.alwaysWriteFields, recordData = this.modificationData;
    alwaysWriteFields.forEach((fieldName) => {
      recordData[this.getFieldDefinition(fieldName).dataSource] = this.getFieldPersistentValue(fieldName);
    });
    return recordData;
  }
  get persistableData() {
    const me = this, data = {};
    me.fields.forEach((field) => {
      const value = me.getFieldPersistentValue(field);
      if (value !== _undefined) {
        if (field !== null && field !== void 0 && field.complexMapping) {
          ObjectHelper.setPath(data, field.dataSource, value);
        } else {
          data[field.dataSource] = value;
        }
      }
    });
    return data;
  }
  get isCommitting() {
    return Boolean(this.meta.committing);
  }
  clearChanges(includeDescendants = true, removeFromStoreChanges = true, changes = null) {
    const me = this, {
      meta
    } = me;
    if (changes) {
      for (const key in changes) {
        delete meta.modified[key];
      }
    } else {
      meta.modified = {};
    }
    const noChanges = ObjectHelper.isEmpty(meta.modified);
    meta.committing = false;
    if (removeFromStoreChanges) {
      me.stores.forEach((store) => {
        noChanges && store.modified.remove(me);
        store.added.remove(me);
        if (includeDescendants) {
          const descendants = store.collectDescendants(me).all;
          store.added.remove(descendants);
          noChanges && store.modified.remove(descendants);
        }
      });
    }
  }
  storeFieldChange(key, oldValue) {
    this.meta.modified[key] = oldValue;
  }
  revertChanges(silent = false) {
    this.set(this.meta.modified, _undefined, silent);
  }
  applyChangeset(rawChanges, phantomIdField = "$PhantomId", remote = true) {
    const me = this, modelClass = me.constructor, {
      idField,
      fieldDataSourceMap
    } = modelClass, rawChangesSimplePaths = ObjectHelper.pathifyKeys(rawChanges), ownChangesSimplePaths = ObjectHelper.pathifyKeys(me.modificationData), changes = {}, idChanged = phantomIdField in rawChanges;
    for (const dataSource in rawChangesSimplePaths) {
      var _field$name;
      const field = fieldDataSourceMap[dataSource], propName = (_field$name = field === null || field === void 0 ? void 0 : field.name) !== null && _field$name !== void 0 ? _field$name : dataSource;
      if (remote || ((field === null || field === void 0 ? void 0 : field.name) === idField ? idChanged : rawChangesSimplePaths[dataSource] === ownChangesSimplePaths[dataSource])) {
        changes[propName] = rawChangesSimplePaths[dataSource];
      }
    }
    const wasSet = me.set(changes);
    me.clearChanges(false, true, remote ? null : changes);
    return wasSet ? Object.entries(wasSet).reduce((result, [field, change]) => {
      result[field] = change.value;
      return result;
    }, {}) : {};
  }
  get internalId() {
    return this._internalId;
  }
  get isPhantom() {
    return this.id === "" || this.id == null || this.hasGeneratedId;
  }
  get isModel() {
    return true;
  }
  get hasGeneratedId() {
    return typeof this.id === "string" && this.id.startsWith("_generated");
  }
  static generateId(text = this.$$name) {
    return `_generated${text}_${StringHelper.generateUUID()}`;
  }
  generateId() {
    return this.constructor.generateId();
  }
  static asId(model) {
    return model !== null && model !== void 0 && model.isModel ? model.id : ObjectHelper.isObject(model) ? model[this.fieldMap.id.dataSource] : model;
  }
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  toJSON() {
    const {
      children,
      unfilteredChildren
    } = this, jsonData = this.persistableData;
    if (unfilteredChildren || children) {
      jsonData[this.constructor.childrenField] = (unfilteredChildren || children).map((c) => c.toJSON());
    }
    return jsonData;
  }
  toString() {
    const me = this, nameField = abbreviationFields.find((field) => field in me.constructor.fieldMap), data = nameField ? {
      [me.constructor.idField]: me.id,
      [nameField]: me[nameField]
    } : me.data;
    return StringHelper.safeJsonStringify(data);
  }
  get isBatchUpdating() {
    return Boolean(this.batching);
  }
  hasBatchedChange(fieldName) {
    var _this$meta, _this$meta$batchChang;
    return (_this$meta = this.meta) === null || _this$meta === void 0 ? void 0 : (_this$meta$batchChang = _this$meta.batchChanges) === null || _this$meta$batchChang === void 0 ? void 0 : _this$meta$batchChang[fieldName];
  }
  beginBatch(silentUpdates = false) {
    const me = this;
    if (!me.batching) {
      me.batching = 0;
      me.meta.batchChanges = {};
    }
    if (silentUpdates) {
      me.$silenceBatch = (me.$silenceBatch || 0) + 1;
    }
    me.batching++;
  }
  endBatch(silent = false, skipAccessors = false) {
    const me = this, {
      parentIdField
    } = me.constructor;
    if (!me.batching) {
      return;
    }
    me.batching--;
    me.$silenceBatch && me.$silenceBatch--;
    if (me.batching > 0) {
      return;
    }
    if (!ObjectHelper.isEmpty(me.meta.batchChanges)) {
      const batchChanges = _objectSpread2({}, me.meta.batchChanges);
      me.meta.batchChanges = null;
      if (batchChanges[parentIdField]) {
        me.parentId = batchChanges[parentIdField];
        delete batchChanges[parentIdField];
      }
      me.set(batchChanges, _undefined, silent, false, skipAccessors);
    }
  }
  cancelBatch() {
    if (this.batching) {
      const me = this, {
        batchChanges
      } = me.meta, wasSet = {};
      me.batching = null;
      me.meta.batchChanges = null;
      me.generation++;
      if (!me.$silenceBatch) {
        Object.entries(batchChanges).forEach(([key, oldValue]) => {
          wasSet[key] = {
            oldValue,
            value: me[key]
          };
        });
        const event = {
          action: "update",
          record: me,
          records: [me],
          changes: wasSet
        };
        me.stores.forEach((store) => {
          store.trigger("batchedUpdate", _objectSpread2({}, event));
        });
        me.forEachLinked((store, record) => {
          store.trigger("batchedUpdate", _objectSpread2(_objectSpread2({}, event), {}, {
            record,
            records: [record]
          }));
        });
      }
      me.$silenceBatch && me.$silenceBatch--;
    }
  }
  triggerBeforeUpdate(changes) {
    var _this$stores;
    return !((_this$stores = this.stores) !== null && _this$stores !== void 0 && _this$stores.some((s) => s.trigger("beforeUpdate", {
      record: this,
      changes
    }) === false));
  }
  copy(newId = null, deep) {
    const me = this, data = ObjectHelper.clone(me.data), idField = me.constructor.idField, useDeep = ObjectHelper.isObject(deep) ? deep.deep : deep;
    let id;
    if (newId && typeof newId === "object") {
      id = newId[idField];
      Object.assign(data, newId);
    } else {
      id = newId;
    }
    if (useDeep && me.children) {
      data.children = me.children.map((child) => child.copy(void 0, deep));
    } else {
      delete data.children;
      delete data.expanded;
    }
    if (me.$meta.fields.initable.length > 0) {
      const json = me.toJSON();
      for (const field of me.$meta.fields.initable) {
        data[field.name] = json[field.name];
      }
    }
    if (newId !== false) {
      data[idField] = id || me.generateId(me.firstStore);
    }
    const copy = new me.constructor(data, null, null, false, true);
    copy.originalInternalId = me.internalId;
    return copy;
  }
  copyData(fromRecord) {
    const propertiesAndValues = {};
    fromRecord.allFields.forEach(({
      name: fieldName
    }) => {
      if (fieldName !== fromRecord.constructor.idField) {
        propertiesAndValues[fieldName] = fromRecord[fieldName];
      }
    });
    this.set(propertiesAndValues);
  }
  remove(silent = false) {
    const me = this, {
      parent
    } = this;
    if (parent) {
      parent.removeChild(me);
    } else if (me.stores.length && !me.isSpecialRow) {
      me.stores.forEach((s) => s.remove(me, silent, false, true));
    }
  }
  beforeRemove(stores2, records) {
    return super.beforeRemove(stores2, records);
  }
  get isValid() {
    return true;
  }
  get firstStore() {
    return this.stores.length > 0 && this.stores[0];
  }
  joinStore(store) {
    const me = this, {
      stores: stores2
    } = me;
    if (!stores2.includes(store)) {
      const {
        unjoinedStores
      } = me;
      super.joinStore(store);
      store.register(me);
      stores2.push(store);
      if (unjoinedStores.includes(store)) {
        unjoinedStores.splice(unjoinedStores.indexOf(store), 1);
      }
      me.isLoaded && me.children.forEach((child) => child.joinStore(store));
      me.initRelations();
      if (store.tree && !me.isRoot) {
        me.instanceMeta(store.id).collapsed = !me.expanded;
      }
    }
  }
  unjoinStore(store, isReplacing = false) {
    const me = this, {
      stores: stores2,
      unjoinedStores
    } = me;
    if (stores2.includes(store)) {
      var _ref, _ref$forEach, _super$unjoinStore;
      if (!store.isDestroying) {
        store.unregister(me);
        unjoinedStores.push(store);
      }
      (_ref = me.unfilteredChildren || me.children) === null || _ref === void 0 ? void 0 : (_ref$forEach = _ref.forEach) === null || _ref$forEach === void 0 ? void 0 : _ref$forEach.call(_ref, (child) => child.unjoinStore(store, isReplacing));
      stores2.splice(stores2.indexOf(store), 1);
      (_super$unjoinStore = super.unjoinStore) === null || _super$unjoinStore === void 0 ? void 0 : _super$unjoinStore.call(this, store, isReplacing);
      store.uncacheRelatedRecord(me);
    }
  }
  isPartOfStore(store) {
    if (store) {
      return store.includes(this);
    }
    return this.stores.length > 0;
  }
  get isRemoved() {
    return !this.isPartOfStore();
  }
  instanceMeta(instanceOrId) {
    const {
      meta
    } = this, id = instanceOrId.id || instanceOrId;
    if (!meta.map) {
      meta.map = {};
    }
    return meta.map[id] || (meta.map[id] = {});
  }
  get isGroupHeader() {
    return "groupRowFor" in this.meta;
  }
  get isGroupFooter() {
    return "groupFooterFor" in this.meta;
  }
  get isSpecialRow() {
    var _this$meta2;
    return Boolean((_this$meta2 = this.meta) === null || _this$meta2 === void 0 ? void 0 : _this$meta2.specialRow);
  }
  get $original() {
    return this.isLinked ? this.proxyMeta.originalRecord : this;
  }
  static get nonPersistableFields() {
    const me = this;
    if (!me._nonPersistableFields) {
      me._nonPersistableFields = {};
      me.allFields.forEach((field) => {
        if (!field.persist || field.calculated) {
          me._nonPersistableFields[field.name] = 1;
        }
      });
    }
    return me._nonPersistableFields;
  }
  static get alwaysWriteFields() {
    const me = this;
    if (!me._alwaysWriteFields) {
      me._alwaysWriteFields = [];
      me.allFields.forEach((field) => {
        if (field.alwaysWrite) {
          me._alwaysWriteFields.push(field.name);
        }
      });
    }
    return me._alwaysWriteFields;
  }
  get domId() {
    return typeof this.id === "string" ? this.id.replace(/[ .]/g, "-") : this.id;
  }
  static toJavaScriptValue(options) {
    const {
      names
    } = this.$meta, className = names[names.length - 2], superName = names[names.length - 3];
    return `class ${className} extends ${superName} { static fields = ${StringHelper.toJavaScriptValue(this.fields, options)}; }`;
  }
  getCurrentConfig(options) {
    const {
      data,
      children
    } = this, {
      defaultValues,
      applyConfigs
    } = this.constructor, result = applyConfigs ? super.getCurrentConfig(options) : {};
    if (result) {
      for (const field of this.fields) {
        if (field.persist) {
          const value = ObjectHelper.getPath(data, field.dataSource);
          if (!field.isEqual(value, defaultValues[field.name])) {
            ObjectHelper.setPath(result, field.dataSource, Base$1.processConfigValue(value, options));
          }
        }
      }
      if (children) {
        if (Array.isArray(children)) {
          result.children = [];
          for (const child of children) {
            result.children.push(child.getCurrentConfig(options));
          }
        } else {
          result.children = children;
        }
      }
      if (this.hasGeneratedId) {
        delete result.id;
      }
      delete result.parentId;
      delete result.parentIndex;
    }
    return result;
  }
};
_defineProperty(Model, "relations", null);
Model._idField = "id";
Model._internalIdCounter = 1;
Model._assignedIdField = false;
Model.exposeProperties();
Model._$name = "Model";
var Duration = class {
  constructor(magnitude, unit) {
    if (typeof magnitude === "number" || magnitude === null) {
      this._magnitude = magnitude;
      this._unit = unit;
    } else {
      if (typeof magnitude === "string") {
        Object.assign(this, DateHelper.parseDuration(magnitude));
      }
      if (typeof magnitude === "object") {
        Object.assign(this, magnitude);
      }
    }
  }
  get magnitude() {
    return this._magnitude;
  }
  set magnitude(value) {
    this._magnitude = typeof value === "number" && value;
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = DateHelper.parseTimeUnit(value);
  }
  get isValid() {
    return this._magnitude != null && Boolean(DateHelper.normalizeUnit(this._unit));
  }
  get milliseconds() {
    return this.isValid ? Math.round(DateHelper.asMilliseconds(this._magnitude, this._unit)) : 0;
  }
  isEqual(value) {
    return Boolean(value) && this._magnitude != null && value._magnitude != null && this.milliseconds === value.milliseconds;
  }
  toString(useAbbreviation) {
    const me = this, abbreviationFn = useAbbreviation ? "getShortNameOfUnit" : "getLocalizedNameOfUnit";
    return me.isValid ? `${me._magnitude} ${DateHelper[abbreviationFn](me._unit, me._magnitude !== 1)}` : "";
  }
  toJSON() {
    return this.toString();
  }
  valueOf() {
    return this.milliseconds;
  }
};
Duration._$name = "Duration";
var nestedValueReducer = (object, path) => object === null || object === void 0 ? void 0 : object[path];
var relativeDateUnitRegExp = /^is(this|next|last)(week|month|year)$/i;
var relativeDateOperators = ["isToday", "isTomorrow", "isYesterday", "isThisWeek", "isNextWeek", "isLastWeek", "isThisMonth", "isNextMonth", "isLastMonth", "isThisYear", "isNextYear", "isLastYear", "isYearToDate"];
var CollectionFilter = class extends Base$1.mixin(Identifiable) {
  static get defaultConfig() {
    return {
      value: null,
      operator: null,
      filterBy: null,
      convert: null,
      caseSensitive: true,
      id: null,
      type: null,
      internal: null,
      disabled: false
    };
  }
  static get configurable() {
    return {
      property: null
    };
  }
  construct(config) {
    if (typeof config === "function") {
      config = {
        filterBy: config
      };
    }
    if (!config.type) {
      if (DateHelper.isDate(config.value) || Array.isArray(config.value) && config.value.every(DateHelper.isDate)) {
        config.type = "date";
      } else if (config.value instanceof Duration) {
        config.type = "duration";
      }
    } else {
      if (config.type === "date" && config.value != null && !Array.isArray(config.value)) {
        config.value = new Date(config.value);
      } else if (config.type === "duration" && config.value != null && !Array.isArray(config.value)) {
        config.value = new Duration(config.value);
      }
    }
    super.construct(config);
  }
  get id() {
    if (!this._id) {
      if (this.internal) {
        this._id = CollectionFilter.generateId(`b-internal-${this.property}-filter-`);
      } else {
        this._id = this.property || CollectionFilter.generateId("b-filter-");
      }
    }
    return this._id;
  }
  set id(id) {
    this._id = id;
  }
  onChange(propertyChanged) {
    var _me$owner;
    const me = this;
    if (!me.isConfiguring && (_me$owner = me.owner) !== null && _me$owner !== void 0 && _me$owner.onFilterChanged && !me.owner.isConfiguring) {
      me.owner.onFilterChanged(me, propertyChanged);
    }
  }
  get filterBy() {
    return this._filterBy || this.defaultFilterBy;
  }
  set filterBy(filterBy) {
    this._filterBy = filterBy;
  }
  defaultFilterBy(candidate) {
    const me = this;
    let candidateValue;
    if (me._propertyItems.length > 1) {
      candidateValue = me._propertyItems.reduce(nestedValueReducer, candidate);
    } else {
      candidateValue = candidate[me.property];
    }
    return me[me.operator](me.convert(candidateValue));
  }
  updateProperty(property) {
    this._propertyItems = property.split(".");
    this.onChange("property");
  }
  set value(value) {
    const me = this;
    me._value = value;
    if (Array.isArray(value) && ({
      date: 1,
      duration: 1
    }[me.type] || value.length > 0 && typeof value[0] === "string")) {
      me._filterValue = value.map((v) => me.convert(v));
    } else if (!me.caseSensitive && Array.isArray(value) && value.length > 0 && typeof value[0] === "string") {
      me._filterValue = value.map((s) => s === null || s === void 0 ? void 0 : s.toLowerCase());
    } else if (!me.caseSensitive && typeof value === "string") {
      me._filterValue = value.toLowerCase();
    } else {
      me._filterValue = me.convert(value);
    }
    me.onChange("value");
  }
  get value() {
    return this._value;
  }
  get filterValue() {
    return this._filterValue;
  }
  set operator(operator) {
    this._operator = operator;
    this.onChange("operator");
  }
  get operator() {
    const me = this;
    if (me._operator) {
      return me._operator;
    }
    if (Array.isArray(me.filterValue)) {
      return "isIncludedIn";
    }
    return typeof me.filterValue === "string" ? "*" : "=";
  }
  convert(value) {
    if (this.operator !== "sameTime" && !(typeof this.filterValue === "string" && value instanceof Date)) {
      var _value$valueOf, _value;
      if (this.operator === "sameDay") {
        value = DateHelper.clearTime(value);
      }
      value = (_value$valueOf = (_value = value) === null || _value === void 0 ? void 0 : _value.valueOf()) !== null && _value$valueOf !== void 0 ? _value$valueOf : value;
    }
    value = !this.caseSensitive && typeof value === "string" ? value.toLowerCase() : value;
    return value;
  }
  filter(candidate) {
    return this.filterBy(candidate);
  }
  startsWith(v) {
    return String(v).startsWith(this.filterValue);
  }
  endsWith(v) {
    return String(v).endsWith(this.filterValue);
  }
  isIncludedIn(v) {
    return this.filterValue.length === 0 || this.filterValue.includes(v);
  }
  isNotIncludedIn(v) {
    return !this.isIncludedIn(v);
  }
  includes(v) {
    return this.filterValue.length === 0 || String(v).includes(this.filterValue);
  }
  doesNotInclude(v) {
    return !this.includes(v);
  }
  sameTime(v) {
    return DateHelper.isSameTime(v, this.filterValue);
  }
  sameDay(v) {
    return v === this.filterValue;
  }
  "="(v) {
    return ObjectHelper.isEqual(v, this.filterValue);
  }
  "!="(v) {
    return !ObjectHelper.isEqual(v, this.filterValue);
  }
  ">"(v) {
    return ObjectHelper.isMoreThan(v, this.filterValue);
  }
  ">="(v) {
    return ObjectHelper.isMoreThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);
  }
  "<"(v) {
    return ObjectHelper.isLessThan(v, this.filterValue);
  }
  "<="(v) {
    return ObjectHelper.isLessThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);
  }
  "*"(v) {
    return ObjectHelper.isPartial(v, this.filterValue);
  }
  between(v) {
    const [start, end] = this._filterValue;
    return (ObjectHelper.isMoreThan(v, start) || ObjectHelper.isEqual(v, start)) && (ObjectHelper.isLessThan(v, end) || ObjectHelper.isEqual(v, end));
  }
  notBetween(v) {
    return !this.between(v);
  }
  empty(v) {
    return v === void 0 || v === null || String(v).length === 0;
  }
  notEmpty(v) {
    return !this.empty(v);
  }
  isToday(v) {
    return this.between(v);
  }
  isTomorrow(v) {
    return this.between(v);
  }
  isYesterday(v) {
    return this.between(v);
  }
  isThisWeek(v) {
    return this.between(v);
  }
  isNextWeek(v) {
    return this.between(v);
  }
  isLastWeek(v) {
    return this.between(v);
  }
  isThisMonth(v) {
    return this.between(v);
  }
  isNextMonth(v) {
    return this.between(v);
  }
  isLastMonth(v) {
    return this.between(v);
  }
  isThisYear(v) {
    return this.between(v);
  }
  isNextYear(v) {
    return this.between(v);
  }
  isLastYear(v) {
    return this.between(v);
  }
  isYearToDate(v) {
    return this.between(v);
  }
  isTrue(v) {
    return v === true;
  }
  isFalse(v) {
    return v === false;
  }
  setRelativeDateValues() {
    this._filterValue = CollectionFilter.getRelativeDateRange(this._operator).map((date2) => date2.valueOf());
  }
  static getRelativeDateRange(relativeExpr, now2 = new Date()) {
    let todayStart, tomorrowStart, parts, oneTimeUnit, unitStart, which, timeUnit;
    switch (relativeExpr) {
      case "isYearToDate":
        return [DateHelper.floor(now2, "1 year"), now2];
      case "isToday":
        todayStart = DateHelper.floor(now2, "1 day");
        return [todayStart, DateHelper.add(todayStart, 1, "day")];
      case "isYesterday":
        todayStart = DateHelper.floor(now2, "1 day");
        return [DateHelper.add(todayStart, -1, "day"), todayStart];
      case "isTomorrow":
        tomorrowStart = DateHelper.getStartOfNextDay(now2);
        return [tomorrowStart, DateHelper.add(tomorrowStart, 1, "day")];
      case "isThisWeek":
      case "isNextWeek":
      case "isLastWeek":
      case "isThisMonth":
      case "isNextMonth":
      case "isLastMonth":
      case "isThisYear":
      case "isNextYear":
      case "isLastYear":
        parts = relativeExpr.toLowerCase().match(relativeDateUnitRegExp);
        if (!parts) {
          throw new Error(`Unrecognized relative date expression: ${relativeExpr}`);
        }
        [, which, timeUnit] = parts;
        oneTimeUnit = `1 ${timeUnit}`;
        unitStart = DateHelper.floor(now2, oneTimeUnit);
        if (which === "next") {
          unitStart = DateHelper.add(unitStart, 1, timeUnit);
        } else if (which === "last") {
          unitStart = DateHelper.add(unitStart, -1, timeUnit);
        }
        return [unitStart, DateHelper.add(unitStart, 1, timeUnit)];
    }
  }
  static generateFiltersFunction(filters) {
    if (!filters || !filters.length && !filters.count) {
      return FunctionHelper.returnTrue;
    }
    for (const filter2 of filters) {
      if (filter2.type === "date" && relativeDateOperators.includes(filter2._operator)) {
        filter2.setRelativeDateValues();
      }
    }
    return function(candidate) {
      let match = true;
      for (const filter2 of filters) {
        if (!filter2.disabled) {
          match = filter2.filter(candidate);
        }
        if (!match) {
          break;
        }
      }
      return match;
    };
  }
};
_defineProperty(CollectionFilter, "$name", "CollectionFilter");
CollectionFilter._$name = "CollectionFilter";
var idCounts = ObjectHelper.getPathDefault(globalThis, "bryntum.idCounts", /* @__PURE__ */ Object.create(null));
var IdHelper = class {
  static generateId(prefix = "generatedId") {
    return prefix + (idCounts[prefix] = (idCounts[prefix] || 0) + 1);
  }
};
IdHelper._$name = "IdHelper";
var CollectionSorter = class extends Base$1 {
  static get defaultConfig() {
    return {
      property: null,
      direction: "ASC",
      sortFn: null,
      convert: null,
      id: null,
      useLocaleSort: null
    };
  }
  construct(config) {
    if (typeof config === "function") {
      config = {
        sortFn: config
      };
    }
    super.construct(config);
  }
  get id() {
    return this._id || (this._id = this.property || IdHelper.generateId("b-sorter"));
  }
  set id(id) {
    this._id = id;
  }
  set sortFn(sortFn) {
    this._sortFn = sortFn;
  }
  get sortFn() {
    if (this._sortFn) {
      return this._sortFn;
    }
    return this.defaultSortFn;
  }
  defaultSortFn(lhs, rhs) {
    const me = this, {
      convert,
      property,
      useLocaleSort
    } = me, multiplier = me.direction.toLowerCase() === "desc" ? -1 : 1;
    lhs = lhs[property];
    rhs = rhs[property];
    if (convert) {
      lhs = convert(lhs);
      rhs = convert(rhs);
    }
    if (useLocaleSort && lhs != null && rhs != null && typeof lhs === "string") {
      if (useLocaleSort === true) {
        return String(lhs).localeCompare(rhs);
      }
      if (typeof useLocaleSort === "string") {
        return String(lhs).localeCompare(rhs, useLocaleSort);
      }
      if (typeof useLocaleSort === "object") {
        return String(lhs).localeCompare(rhs, useLocaleSort.locale, useLocaleSort);
      }
    }
    return (lhs > rhs ? 1 : lhs < rhs ? -1 : 0) * multiplier;
  }
  static generateSortFunction(sorters, tieBreaker) {
    const items2 = sorters.isCollection ? sorters.values : sorters, n = items2.length;
    return (lhs, rhs) => {
      let comp, i;
      for (i = 0; i < n; ++i) {
        comp = items2[i].sortFn(lhs, rhs);
        if (comp) {
          return comp;
        }
      }
      return tieBreaker ? tieBreaker(lhs, rhs) : 0;
    };
  }
};
CollectionSorter._$name = "CollectionSorter";
var _Symbol$iterator;
var return0 = () => 0;
var reverseNumericSortFn = (a, b) => b - a;
var filteredIndicesProperty = Symbol("filteredIndicesProperty");
var emptyArray$b = Object.freeze([]);
var sortEvent = Object.freeze({
  action: "sort",
  added: emptyArray$b,
  removed: emptyArray$b,
  replaced: emptyArray$b
});
var filterEvent = Object.freeze({
  action: "filter",
  added: emptyArray$b,
  removed: emptyArray$b,
  replaced: emptyArray$b
});
var keyTypes = {
  string: 1,
  number: 1
};
function addItemToIndex(item, index, key) {
  if (index.unique !== false) {
    index.set(key, item);
  } else {
    let set = index.get(key);
    if (!set) {
      set = /* @__PURE__ */ new Set();
      index.set(key, set);
    }
    set.add(item);
  }
}
function removeItemFromIndex(item, index, key) {
  if (index.unique !== false) {
    index.delete(key);
  } else if (index.has(key)) {
    index.get(key).delete(item);
    if (!index.get(key).size) {
      index.delete(key);
    }
  }
}
function doRebuildIndices(values, indices, keyProps, indexCount) {
  for (let i = 0; i < values.length; i++) {
    const item = values[i];
    for (let j = 0; j < indexCount; j++) {
      const keyProp = keyProps[j], key = item[keyProp], index = indices[keyProp];
      addItemToIndex(item, index, key);
    }
  }
}
_Symbol$iterator = Symbol.iterator;
var Collection = class extends Base$1.mixin(Events) {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "_sortFunction", null);
    _defineProperty(this, "_addedValues", null);
  }
  static get configurable() {
    return {
      idProperty: "id",
      extraKeys: null,
      autoFilter: true,
      autoSort: true,
      sorters: {
        $config: ["lazy"],
        value: []
      }
    };
  }
  get isCollection() {
    return true;
  }
  construct(config) {
    this.generation = 0;
    this._values = [];
    super.construct(config);
  }
  doDestroy() {
    var _me$_sorters;
    super.doDestroy();
    const me = this;
    me._values.length = 0;
    if (me.isFiltered) {
      me._filteredValues.length = 0;
      me.filters.destroy();
    }
    (_me$_sorters = me._sorters) === null || _me$_sorters === void 0 ? void 0 : _me$_sorters.destroy();
  }
  clear() {
    const me = this, removed = me._values.slice();
    if (me.totalCount) {
      me._values.length = 0;
      if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
      me._indicesInvalid = true;
      me.generation++;
      me.trigger("change", {
        action: "clear",
        removed
      });
    }
  }
  equals(other, map2) {
    if (other.isCollection) {
      other = other.values;
    }
    if (other.length === this.count) {
      let {
        values
      } = this;
      if (map2) {
        other = other.map(map2);
        values = values.map(map2);
      }
      return ArrayHelper.delta(other, values).inBoth.length === this.count;
    }
    return false;
  }
  replaceValues({
    values,
    filteredValues,
    silent = false,
    isNewDataset = false
  }) {
    const me = this;
    let replacedValues, replacedFilteredValues;
    if (me.isFiltered && !isNewDataset) {
      const filteredPassed = Boolean(filteredValues);
      if (!filteredPassed) {
        filteredValues = values.slice();
        values = null;
      } else if (values) {
        replacedValues = me._values;
        me._values = values.slice();
      }
      replacedFilteredValues = me._filteredValues;
      me._filteredValues = filteredValues.slice();
    } else {
      replacedValues = me._values;
      me._values = values.slice();
      filteredValues = null;
      if (me.isFiltered && isNewDataset && me.autoFilter) {
        me._filterFunction = null;
        me._filteredValues = me._values.filter(me.filterFunction);
      } else if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
    }
    me._indicesInvalid = true;
    me._addedValues = void 0;
    me.generation++;
    if (!silent) {
      me.trigger("change", {
        action: "replaceValues",
        replacedValues,
        replacedFilteredValues,
        values,
        filteredValues
      });
    }
  }
  set values(values) {
    this.invalidateIndices();
    this.splice(0, this._values.length, values);
  }
  get values() {
    return this.isFiltered ? this._filteredValues : this._values;
  }
  get filteredValues() {
    return this._filteredValues;
  }
  [_Symbol$iterator]() {
    return this.values[Symbol.iterator]();
  }
  forEach(fn2, ignoreFilters = false) {
    (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).forEach(fn2);
  }
  map(fn2, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).map(fn2);
  }
  find(fn2, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).find(fn2);
  }
  get first() {
    return this.values[0];
  }
  get last() {
    return this.values[this.count - 1];
  }
  get allValues() {
    return this._values;
  }
  get addedValues() {
    return this._addedValues;
  }
  match(other, allowRemove = true) {
    const me = this, {
      _values
    } = me, toRemove = [];
    me.forEach((item) => {
      const newInstance = other.get(item.id, true);
      if (newInstance) {
        const index = me.indexOf(item, true), oldInstance = _values[index];
        _values[index] = newInstance;
        me.removeFromIndices(oldInstance);
        me.addToIndices(newInstance);
      } else if (allowRemove) {
        toRemove.push(item);
      }
    });
    if (toRemove.length) {
      me.remove(toRemove);
    }
    if (me.isFiltered) {
      me._filteredValues = me._values.filter(me.filterFunction);
    }
    return toRemove;
  }
  add(...items2) {
    if (items2.length === 1) {
      this.splice(this._values.length, null, ...items2);
    } else {
      this.splice(this._values.length, null, items2);
    }
  }
  remove(...items2) {
    if (items2.length === 1) {
      this.splice(0, ...items2);
    } else {
      this.splice(0, items2);
    }
  }
  move(items2, beforeItem) {
    items2 = ArrayHelper.asArray(items2);
    while (items2.length && items2[0] === beforeItem) {
      items2.shift();
    }
    if (!items2.length) {
      return;
    }
    const me = this, {
      _values
    } = me, itemIndex = me.indexOf(items2[0], true);
    if (items2.length === 1 && _values[itemIndex + 1] === beforeItem) {
      return;
    }
    me.suspendEvents();
    me.remove(items2);
    me.resumeEvents();
    const beforeIndex = beforeItem ? me.indexOf(beforeItem, true) : _values.length;
    if (beforeIndex === -1) {
      throw new Error("Collection move beforeItem parameter must be present in Collection");
    }
    _values.splice(beforeIndex, 0, ...items2);
    me._indicesInvalid = 1;
    me.trigger("change", {
      action: "move",
      items: items2,
      from: itemIndex,
      to: beforeIndex
    });
    return beforeIndex;
  }
  splice(index = 0, toRemove, ...toAdd) {
    const me = this, idProperty = me.idProperty, values = me._values, newIds = {}, removed = [], replaced = [], oldCount = me.totalCount;
    let added, mutated;
    if (me.trigger("beforeSplice", {
      index,
      toRemove,
      toAdd
    }) === false) {
      return;
    }
    if (toAdd) {
      if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
        toAdd = toAdd[0];
      }
      if (oldCount && toAdd.length) {
        const idIndex = me.indices[idProperty];
        added = [];
        for (let i = 0; i < toAdd.length; i++) {
          const newItem = toAdd[i], id = newItem[idProperty], existingItem = idIndex.get(id), existingIndex = existingItem ? values.indexOf(existingItem) : -1;
          newIds[id] = true;
          if (existingIndex !== -1) {
            if (values[existingIndex] !== newItem) {
              replaced.push([values[existingIndex], newItem]);
              values[existingIndex] = newItem;
            }
          } else {
            added.push(newItem);
          }
        }
      } else {
        added = toAdd;
      }
    }
    if (toRemove) {
      if (typeof toRemove === "number") {
        toRemove = Math.min(toRemove, values.length - index);
        for (let removeIndex = index; toRemove; --toRemove) {
          const id = values[removeIndex][idProperty];
          if (newIds[id]) {
            index++;
            removeIndex++;
          } else {
            removed.push(values[removeIndex]);
            values.splice(removeIndex, 1);
            mutated = true;
          }
        }
      } else {
        let contiguous = added.length === 0, lastIdx;
        toRemove = ArrayHelper.asArray(toRemove);
        const removeIndices = toRemove.reduce((result, item) => {
          const isNumeric = typeof item === "number", idx = isNumeric ? item : me.indexOf(item, true);
          if (contiguous && (lastIdx != null && idx !== lastIdx + 1 || isNumeric)) {
            contiguous = false;
          }
          if (idx >= 0 && idx < oldCount) {
            result.push(idx);
          }
          lastIdx = idx;
          return result;
        }, []).sort(reverseNumericSortFn);
        if (contiguous) {
          if (removeIndices.length) {
            removed.push.apply(removed, toRemove);
            values.splice(removeIndices[removeIndices.length - 1], removeIndices.length);
            mutated = true;
          }
        } else {
          for (let i = 0; i < removeIndices.length; i++) {
            const removeIndex = removeIndices[i];
            if (removeIndex !== -1) {
              const id = values[removeIndex][idProperty];
              if (!newIds[id]) {
                removed.unshift(values[removeIndex]);
                values.splice(removeIndex, 1);
                mutated = true;
              }
            }
          }
        }
      }
      if (removed.length && !me._indicesInvalid) {
        removed.forEach(me.removeFromIndices, me);
      }
    }
    if (added.length) {
      values.splice(Math.min(index, values.length), 0, ...added);
      mutated = true;
      if (!me._indicesInvalid) {
        added.forEach(me.addToIndices, me);
      }
      if (!me._addedValues) {
        me._addedValues = /* @__PURE__ */ new Set();
      }
      for (const value of added) {
        me._addedValues.add(value);
      }
    }
    if (removed.length && me._addedValues) {
      for (const value of removed) {
        me._addedValues.delete(value);
      }
    }
    if (replaced.length && !me._indicesInvalid) {
      replaced.forEach((rep) => {
        me.removeFromIndices(rep[0]);
        me.addToIndices(rep[1]);
      });
    }
    if (mutated || replaced.length) {
      if (me.isSorted) {
        me.onSortersChanged();
      } else if (me.isFiltered) {
        if (me.autoFilter) {
          me.onFiltersChanged({
            action: "splice",
            oldCount: 1
          });
        } else {
          me._filteredValues.splice(Math.min(index, me._filteredValues.length), 0, ...added);
        }
      }
      me.generation++;
      me.trigger("change", {
        action: "splice",
        removed,
        added,
        replaced,
        oldCount
      });
    } else {
      me.trigger("noChange", {
        index,
        toRemove,
        toAdd
      });
    }
  }
  changeId(item, newId) {
    const me = this, {
      idProperty
    } = me, oldId = keyTypes[typeof item] ? item : item[idProperty], member = me.get(oldId);
    if (member) {
      const existingMember = me.get(newId);
      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }
      me.removeIndexEntry(item, idProperty, oldId);
      me.addIndexEntry(item, idProperty, newId);
      member[idProperty] = newId;
    }
  }
  get(id, ignoreFilters = false) {
    return this.getBy(this.idProperty, id, ignoreFilters);
  }
  getAt(index, ignoreFilters = false) {
    if (this.isFiltered && !ignoreFilters) {
      return this._filteredValues[index];
    } else {
      return this._values[index];
    }
  }
  getBy(propertyName, value, ignoreFilters = false) {
    return this.findItem(propertyName, value, this.isFiltered && ignoreFilters);
  }
  get count() {
    return this.values.length;
  }
  get totalCount() {
    return this._values.length;
  }
  updateIdProperty(idProperty) {
    this.addIndex({
      property: idProperty,
      unique: true
    });
  }
  changeSorters(sorters) {
    return new Collection({
      values: ArrayHelper.asArray(sorters),
      internalListeners: {
        change: "onSortersChanged",
        thisObj: this
      }
    });
  }
  addSorter(sorter) {
    const result = sorter instanceof CollectionSorter ? sorter : new CollectionSorter(sorter);
    this.sorters.add(result);
    return result;
  }
  get isSorted() {
    var _this$_sorters;
    return Boolean((_this$_sorters = this._sorters) === null || _this$_sorters === void 0 ? void 0 : _this$_sorters.count);
  }
  onSortersChanged() {
    const me = this;
    me._sortFunction = null;
    me._addedValues = null;
    me._values.sort(me.sortFunction);
    me.trigger("change", sortEvent);
  }
  get sortFunction() {
    if (!this._sortFunction) {
      if (this.isSorted) {
        this._sortFunction = CollectionSorter.generateSortFunction(this.sorters.values);
      } else {
        this._sortFunction = return0;
      }
    }
    return this._sortFunction;
  }
  get filters() {
    if (!this._filters) {
      this._filters = new Collection({
        internalListeners: {
          change: "onFiltersChanged",
          thisObj: this
        }
      });
    }
    return this._filters;
  }
  addFilter(filter2) {
    const result = filter2 instanceof CollectionFilter ? filter2 : new CollectionFilter(filter2);
    this.filters.add(result);
    return result;
  }
  removeFilter(filter2) {
    const {
      filters
    } = this;
    if (!filter2.isCollectionFilter) {
      filter2 = filters.get(filter2);
    }
    filters.remove(filter2);
  }
  clearFilters() {
    this.filters.clear();
  }
  get isFiltered() {
    return Boolean(this._filters && this._filters.count);
  }
  onFiltersChanged({
    action,
    removed: gone,
    oldCount
  }) {
    const me = this, oldDataset = oldCount || action === "clear" && gone.length ? me._filteredValues : me._values;
    me._filterFunction = null;
    me._filteredValues = me._values.filter(me.filterFunction);
    me._indicesInvalid = true;
    const {
      toAdd: added,
      toRemove: removed
    } = ArrayHelper.delta(me._filteredValues, oldDataset, true);
    me.trigger("change", _objectSpread2(_objectSpread2({}, filterEvent), {}, {
      added,
      removed
    }));
  }
  get filterFunction() {
    if (!this._filterFunction) {
      if (this.isFiltered) {
        this._filterFunction = CollectionFilter.generateFiltersFunction(this.filters.values);
      } else {
        this._filterFunction = FunctionHelper.returnTrue;
      }
    }
    return this._filterFunction;
  }
  changeExtraKeys(extraKeys) {
    const keys = ArrayHelper.asArray(extraKeys);
    return keys.map((config) => {
      if (typeof config === "string") {
        return {
          property: config,
          unique: true
        };
      }
      return config;
    });
  }
  updateExtraKeys(extraKeys) {
    for (let i = 0; i < extraKeys.length; i++) {
      this.addIndex(extraKeys[i]);
    }
  }
  addIndex(indexConfig) {
    const me = this;
    if (indexConfig) {
      (me._indices || (me._indices = {}))[indexConfig.property] = /* @__PURE__ */ new Map();
      Object.assign(me._indices[indexConfig.property], indexConfig);
      me.invalidateIndices();
      if (indexConfig.dependentOn) {
        me.hasCompositeIndex = true;
      }
    }
  }
  findIndex(propertyName, value, ignoreFilters = false) {
    const item = this.findItem(propertyName, value, ignoreFilters);
    if (!item) {
      return -1;
    }
    const values = this.isFiltered && !ignoreFilters ? this._filteredValues : this._values;
    return values.indexOf(item);
  }
  findItem(propertyName, value, ignoreFilters = false) {
    const me = this, {
      isFiltered
    } = me, index = isFiltered && !ignoreFilters ? me.indices[filteredIndicesProperty][propertyName] : me.indices[propertyName];
    if (index) {
      var _index$get;
      const item = (_index$get = index.get(value)) !== null && _index$get !== void 0 ? _index$get : typeof value === "string" && value.length && !isNaN(value) && index.get(Number(value)) || null;
      if (item != null) {
        return item;
      }
    } else {
      const values = isFiltered && !ignoreFilters ? me._filteredValues : me._values, count = values.length;
      for (let i = 0; i < count; i++) {
        const item = values[i];
        if (item[propertyName] == value) {
          return item;
        }
      }
    }
    return null;
  }
  removeIndex(propertyName) {
    delete this._indices[propertyName];
    this.hasCompositeIndex = Object.values(this.indices).some((index) => index.dependentOn);
  }
  indexOf(item, ignoreFilters = false) {
    return this.findIndex(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters);
  }
  includes(item, ignoreFilters = false) {
    if (Array.isArray(item)) {
      return item.some((item2) => this.includes(item2));
    }
    return Boolean(this.findItem(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters));
  }
  get indices() {
    if (this._indicesInvalid) {
      this.rebuildIndices();
    }
    return this._indices;
  }
  invalidateIndices() {
    this._indicesInvalid = true;
  }
  rebuildIndices() {
    const me = this, isFiltered = me.isFiltered, indices = me._indices || (me._indices = {}), keyProps = Object.keys(indices), indexCount = keyProps.length, values = me._values;
    let filteredIndices;
    if (isFiltered) {
      filteredIndices = indices[filteredIndicesProperty] = {};
    }
    for (let i = 0; i < indexCount; i++) {
      const index = indices[keyProps[i]];
      index.clear();
      if (isFiltered) {
        let filteredIndex = filteredIndices[keyProps[i]];
        if (filteredIndex) {
          filteredIndex.clear();
        } else {
          filteredIndex = filteredIndices[keyProps[i]] = /* @__PURE__ */ new Map();
          filteredIndex.unique = index.unique;
        }
      }
    }
    doRebuildIndices(values, indices, keyProps, indexCount);
    if (isFiltered) {
      doRebuildIndices(me._filteredValues, filteredIndices, keyProps, indexCount);
    }
    me._indicesInvalid = false;
  }
  getIndices(propertyName) {
    const indices = [this.indices[propertyName]];
    if (this.isFiltered) {
      indices.push(this.indices[filteredIndicesProperty][propertyName]);
    }
    return indices;
  }
  addToIndices(item) {
    Object.keys(this.indices).forEach((propertyName) => {
      this.addIndexEntry(item, propertyName, item[propertyName]);
    });
  }
  removeFromIndices(item) {
    Object.keys(this.indices).forEach((propertyName) => {
      this.removeIndexEntry(item, propertyName, item[propertyName]);
    });
  }
  removeIndexEntry(item, propertyName, oldValue) {
    this.getIndices(propertyName).forEach((index) => removeItemFromIndex(item, index, oldValue));
  }
  addIndexEntry(item, propertyName, value) {
    this.getIndices(propertyName).forEach((index) => addItemToIndex(item, index, value));
  }
  onItemMutation(item, wasSet) {
    const me = this;
    if (!me._indicesInvalid && Object.keys(me.indices).length > 1) {
      Object.keys(wasSet).forEach((propertyName) => {
        const indexConfig = me.indices[propertyName];
        if (indexConfig) {
          const {
            value,
            oldValue
          } = wasSet[propertyName];
          me.removeIndexEntry(item, propertyName, oldValue);
          me.addIndexEntry(item, propertyName, value);
        } else if (me.hasCompositeIndex) {
          const dependentIndex = Object.values(me.indices).find((index) => {
            var _index$dependentOn;
            return (_index$dependentOn = index.dependentOn) === null || _index$dependentOn === void 0 ? void 0 : _index$dependentOn[propertyName];
          });
          if (dependentIndex) {
            const keysAndOldValues = {};
            for (const o in dependentIndex.dependentOn) {
              var _wasSet$o;
              keysAndOldValues[o] = ((_wasSet$o = wasSet[o]) === null || _wasSet$o === void 0 ? void 0 : _wasSet$o.oldValue) || item[o];
            }
            const oldIndex = item.buildIndexKey(keysAndOldValues);
            me.removeIndexEntry(item, dependentIndex.property, oldIndex);
            me.addIndexEntry(item, dependentIndex.property, item[dependentIndex.property]);
          }
        }
      });
    }
  }
};
Collection._$name = "Collection";
var nonPrimitives = /* @__PURE__ */ new WeakMap();
var safeIndexKey = (value) => {
  if (value && typeof value === "object") {
    let substitute = nonPrimitives.get(value);
    if (substitute === void 0) {
      substitute = Symbol("bscik");
      nonPrimitives.set(value, substitute);
    }
    value = substitute;
  }
  return value;
};
var Bag = class {
  constructor(config) {
    const me = this;
    me.generation = 0;
    me.items = /* @__PURE__ */ new Set();
    me.idMap = {};
    me.idProperty = "id";
    if (config) {
      if (config.idProperty) {
        me.idProperty = config.idProperty;
      }
      if (config.values) {
        me.values = config.values;
      }
    }
  }
  get(key) {
    return this.idMap[safeIndexKey(key)];
  }
  get count() {
    return this.items.size;
  }
  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    const me = this, {
      items: items2,
      idMap,
      idProperty
    } = me, len = toAdd.length;
    for (let i = 0; i < len; i++) {
      const item = toAdd[i], key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), existingItem = idMap[key];
      if (existingItem == null) {
        idMap[key] = item;
        items2.add(item);
        me.generation++;
      } else if (existingItem !== item) {
        idMap[key] = item;
        items2.delete(existingItem);
        items2.add(item);
      }
    }
  }
  at(nth) {
    let item, ret;
    if (nth < 0) {
      nth += this.count;
    }
    for (item of this.items) {
      if (!nth--) {
        ret = item;
        break;
      }
    }
    return ret;
  }
  remove(toRemove) {
    toRemove = ArrayHelper.asArray(toRemove);
    const {
      items: items2,
      idMap,
      idProperty
    } = this, len = toRemove.length;
    for (let i = 0; i < len; i++) {
      const item = toRemove[i], key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), existingItem = idMap[key];
      if (existingItem != null) {
        items2.delete(existingItem);
        delete idMap[key];
        this.generation++;
      }
    }
  }
  clear() {
    this.items.clear();
    this.idMap = {};
    this.generation++;
  }
  countOf(fn2) {
    let ret = 0, item;
    for (item of this.items) {
      if (fn2(item)) {
        ++ret;
      }
    }
    return ret;
  }
  changeId(item, newId) {
    const me = this, {
      idMap,
      idProperty
    } = me, oldId = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), member = me.get(oldId);
    if (member) {
      const existingMember = me.get(newId);
      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }
      member[idProperty] = newId;
      delete idMap[oldId];
      idMap[newId] = member;
    }
  }
  filter(fn2, thisObj) {
    const {
      items: items2
    } = this, result = [];
    let i = 0;
    items2.forEach((item) => {
      if (fn2.call(thisObj, item, i++, items2)) {
        result.push(item);
      }
    });
    return result;
  }
  includes(item) {
    const key = keyTypes[typeof item] ? item : safeIndexKey(item[this.idProperty]);
    return Boolean(this.idMap[key]);
  }
  map(fn2, thisObj) {
    const {
      items: items2
    } = this, result = new Array(items2.size);
    let i = 0;
    items2.forEach((item) => {
      result[i] = fn2.call(thisObj, item, i++, items2);
    });
    return result;
  }
  forEach(fn2, thisObj) {
    return this.items.forEach(fn2, thisObj);
  }
  find(fn2, nth = 0) {
    let item, ret;
    if (nth < 0) {
      nth += this.countOf(fn2);
    }
    for (item of this.items) {
      if (fn2(item) && !nth--) {
        ret = item;
        break;
      }
    }
    return ret;
  }
  [Symbol.iterator]() {
    return this.items[Symbol.iterator]();
  }
  indexOf(item, matchFn) {
    let index = -1, it;
    for (it of this.items) {
      if (!matchFn || matchFn(it)) {
        ++index;
        if (it === item) {
          return index;
        }
      }
    }
    return -1;
  }
  get values() {
    return [...this.items];
  }
  set values(values) {
    values = ArrayHelper.asArray(values);
    this.clear();
    this.add.apply(this, values);
    this.generation++;
  }
  sort(fn2) {
    this.values = this.values.sort(fn2);
  }
  some(fn2, thisObj) {
    return this.values.some(fn2, thisObj);
  }
};
Bag._$name = "Bag";
var StoreBag = class extends Bag {
  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    return super.add(...toAdd.filter((record) => record.isPersistable));
  }
};
StoreBag._$name = "StoreBag";
var StoreCRUD = (Target) => class StoreCRUD extends (Target || Base$1) {
  static get $name() {
    return "StoreCRUD";
  }
  static get defaultConfig() {
    return {
      autoCommit: false
    };
  }
  static get properties() {
    return {
      isRemoving: false,
      suspendCount: 0
    };
  }
  remove(records, silent = false) {
    const me = this, {
      storage
    } = me;
    records = ArrayHelper.asArray(records).reduce((result, r) => {
      r = me.getById(r);
      if (r) {
        result.push(r);
      }
      return result;
    }, []);
    if (records.length === 0) {
      return records;
    }
    me.isRemoving = true;
    if (me.isGrouped) {
      const oldCount = storage.count, recordsInCollapsedGroups = [], changedGroupParents = /* @__PURE__ */ new Set();
      for (const rec of records) {
        const {
          groupParent
        } = rec.instanceMeta(me);
        if (groupParent.meta.collapsed) {
          recordsInCollapsedGroups.push(rec);
        }
        ArrayHelper.remove(groupParent.groupChildren, rec);
        groupParent.meta.childCount--;
        changedGroupParents.add(groupParent);
      }
      for (const groupParent of changedGroupParents) {
        if (groupParent.groupChildren.length > 0) {
          me.onModelChange(groupParent, {}, {});
        }
      }
      if (recordsInCollapsedGroups.length) {
        storage.trigger("change", {
          action: "splice",
          removed: recordsInCollapsedGroups,
          added: [],
          replaced: [],
          oldCount
        });
      }
    } else if (me.tree) {
      const allRemovedRecords = [], removingMultiple = records.length > 1, firstRemoved = records[0], index = removingMultiple ? void 0 : storage.indexOf(firstRemoved), removeChildArgs = records.reduce((result, child) => {
        const {
          parent
        } = child;
        if (parent) {
          if (!result[parent.id]) {
            result[parent.id] = [parent, []];
          }
          result[parent.id][1].push(child);
        }
        return result;
      }, {});
      if (!silent && me.trigger("beforeRemove", {
        records,
        isMove: false,
        parent: removingMultiple ? void 0 : firstRemoved.parent
      }) === false) {
        me.isRemoving = false;
        return [];
      }
      for (const argBlock of Object.values(removeChildArgs)) {
        const parent = argBlock[0], children = argBlock[1];
        allRemovedRecords.push(...parent.removeChild(children, false, true));
      }
      if (!silent) {
        me.trigger("remove", {
          parent: removingMultiple ? void 0 : firstRemoved.parent,
          index,
          isChild: true,
          allRecords: allRemovedRecords,
          isMove: false,
          records
        });
        me.trigger("change", {
          action: "remove",
          records
        });
        me.isRemoving = false;
      }
      return records;
    }
    for (const record of records) {
      record.beforeRemove(records);
    }
    if (records.length === 0) {
      return records;
    }
    if (!silent && me.trigger("beforeRemove", {
      records
    }) === false) {
      me.isRemoving = false;
      return [];
    }
    if (silent) {
      me.suspendEvents();
    }
    storage.remove(records);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    me.isRemoving = false;
    return records;
  }
  clear(isLoading = false) {
    var _me$rootNode, _me$rootNode$unfilter;
    const me = this, {
      storage
    } = me;
    if (me.storage.totalCount || (_me$rootNode = me.rootNode) !== null && _me$rootNode !== void 0 && (_me$rootNode$unfilter = _me$rootNode.unfilteredChildren) !== null && _me$rootNode$unfilter !== void 0 && _me$rootNode$unfilter.length) {
      if (!isLoading && me.trigger("beforeRemove", {
        records: storage.allValues,
        removingAll: true
      }) === false) {
        return null;
      }
      if (me.rootNode) {
        if (!me.isChained) {
          me.rootNode.clearChildren(isLoading);
        }
      } else if (isLoading) {
        const allRecords = me.registeredRecords;
        for (let i = allRecords.length - 1, rec; i >= 0; i--) {
          rec = allRecords[i];
          if (rec && !rec.isDestroyed) {
            rec.unjoinStore(me);
          }
        }
      }
      if (isLoading) {
        me.removed.clear();
        storage.suspendEvents();
      }
      storage.clear();
      if (isLoading) {
        storage.resumeEvents();
      }
      me.added.clear();
      me.modified.clear();
    }
  }
  removeAll(silent = false) {
    const me = this, storage = me.storage;
    let result;
    me.isRemoving = true;
    if (silent) {
      storage.suspendEvents();
      const allRecords = me.registeredRecords;
      for (let i = allRecords.length - 1, rec; i >= 0; i--) {
        rec = allRecords[i];
        if (rec && !rec.isDestroyed && !rec.isRoot) {
          rec.unjoinStore(me);
        }
      }
    }
    if (me.tree) {
      result = me.rootNode.clear() !== false;
    } else {
      result = me.clear() !== null;
    }
    if (silent) {
      storage.resumeEvents();
    }
    me.isRemoving = false;
    return result;
  }
  add(records, silent = false, options = {}) {
    var _records2;
    const me = this, {
      storage
    } = me;
    records = ArrayHelper.asArray(records);
    if (!((_records2 = records) !== null && _records2 !== void 0 && _records2.length)) {
      return;
    }
    me.tree = me.tree || Boolean(me.autoTree && records[0].children);
    if (me.tree) {
      const parentIdMap = /* @__PURE__ */ new Map(), parentIndexField = me.modelClass.getFieldDataSource("parentIndex"), {
        parentIdField
      } = me.modelClass, added2 = [];
      records.forEach((node) => {
        const parentId = node[parentIdField];
        if (!parentIdMap.has(parentId)) {
          parentIdMap.set(parentId, {
            append: [],
            insert: []
          });
        }
        const entry = parentIdMap.get(parentId);
        if (!node.isModel && parentIndexField in node) {
          entry.insert.push(node);
        } else {
          entry.append.push(node);
        }
      });
      parentIdMap.forEach(({
        append,
        insert
      }, parentId) => {
        const parentNode2 = parentId == null ? me.rootNode : me.getById(parentId);
        if (!parentNode2) {
          throw new Error(`Parent node with id ${parentId} not found, cannot add children.`);
        }
        if (append.length) {
          added2.push(...parentNode2.appendChild(append, silent));
        }
        if (insert.length) {
          for (const toInsert of insert) {
            added2.push(parentNode2.insertChild(toInsert, toInsert[parentIndexField], silent, options));
          }
        }
      });
      if (me.reapplySortersOnAdd) {
        me.sort();
      }
      return added2;
    }
    if (!silent && me.trigger("beforeAdd", {
      records
    }) === false) {
      return null;
    }
    me.tree = me.tree || Boolean(me.autoTree && records[0].children);
    if (me.tree) {
      return me.rootNode.appendChild(records);
    }
    const added = me.processRecords(records);
    if (silent) {
      me.suspendEvents();
    }
    storage.add(added);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    return added;
  }
  processRecords(records, onRecordCreated) {
    return records.map((data) => {
      const record = this.processRecord(data.isModel ? data : this.createRecord(data));
      onRecordCreated === null || onRecordCreated === void 0 ? void 0 : onRecordCreated.call(this, record);
      return record;
    });
  }
  insert(index, records, silent = false) {
    const me = this, storage = me.storage, insertBefore = me.getAt(index), _records = storage.values, removeIndices = [];
    records = ArrayHelper.asArray(records);
    if (!silent && me.trigger("beforeAdd", {
      records
    }) === false) {
      return null;
    }
    let isNoop, start, i;
    if (_records[start = index] === records[0] || _records[start = index - 1] === records[0]) {
      for (isNoop = true, i = 0; isNoop && i < records.length; i++) {
        if (records[i] !== _records[start + i]) {
          isNoop = false;
        }
      }
    }
    if (isNoop) {
      return null;
    }
    const added = me.processRecords(records, (record) => {
      const removedAtIndex = storage.indexOf(record);
      if (record.children && record.children.length && me.autoTree) {
        me.tree = true;
      }
      if (removedAtIndex > -1) {
        if (removedAtIndex < index && insertBefore)
          index--;
        removeIndices.push(removedAtIndex);
      }
      record.meta.previousIndex = removedAtIndex;
    });
    if (me.tree) {
      var _root$children;
      const root2 = me.rootNode;
      return root2.insertChild(records, (_root$children = root2.children) === null || _root$children === void 0 ? void 0 : _root$children[index], silent);
    }
    me.suspendEvents();
    me.storage.remove(removeIndices);
    me.resumeEvents();
    if (silent) {
      me.suspendEvents();
    }
    storage.splice(index, 0, ...added);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    return added;
  }
  move(records, beforeRecord) {
    if (this.isTree) {
      beforeRecord.parent.insertChild(records, beforeRecord);
    } else {
      this.storage.move(records, beforeRecord);
    }
  }
  setMultiple(filterFn, field, value) {
    const me = this, records = [], changes = [];
    me.forEach((r) => {
      if (filterFn(r)) {
        changes.push(r.set(field, value, true));
        records.push(r);
      }
    });
    me.trigger("updateMultiple", {
      records,
      all: me.records.length === records.length
    });
    me.trigger("change", {
      action: "updatemultiple",
      records,
      all: me.records.length === records.length
    });
    if (me.reapplyFilterOnUpdate && me.isFiltered)
      me.filter();
  }
  setAll(field, value) {
    const me = this, changes = [];
    me.forEach((r) => {
      changes.push(r.set(field, value, true));
    });
    me.trigger("updateMultiple", {
      records: me.records,
      all: true
    });
    me.trigger("change", {
      action: "updatemultiple",
      records: me.records,
      all: true
    });
    if (me.reapplyFilterOnUpdate && me.isFiltered)
      me.filter();
  }
  acceptChanges() {
    const me = this;
    me.added.forEach((r) => r.clearChanges(true, false));
    me.modified.forEach((r) => r.clearChanges(true, false));
    me.added.clear();
    me.modified.clear();
    me.removed.clear();
  }
  commit(silent = false) {
    const {
      changes
    } = this;
    if (!silent && this.trigger("beforeCommit", {
      changes
    }) === false) {
      return false;
    }
    this.acceptChanges();
    if (!silent) {
      this.trigger("commit", {
        changes
      });
    }
    return changes;
  }
  revertChanges() {
    const me = this, {
      changes
    } = me;
    if (changes) {
      const event = {
        action: "clearchanges",
        changes
      };
      me.add(me.removed.values, true);
      me.remove(me.added.values, true);
      me.modified.forEach((r) => r.revertChanges(true));
      me.added.clear();
      me.modified.clear();
      me.removed.clear();
      me.trigger("change", event);
      me.trigger("refresh", event);
    }
  }
  get changes() {
    const me = this, modified = me.modified.values.filter((r) => r.rawModifications);
    return me.added.count || modified.length || me.removed.count ? {
      added: me.added.values.slice(),
      modified,
      removed: me.removed.values.slice()
    } : null;
  }
  get autoCommit() {
    return this._autoCommit;
  }
  set autoCommit(auto) {
    this._autoCommit = auto;
    if (auto && this.changes) {
      this.commit();
    }
  }
  suspendAutoCommit() {
    this.suspendCount++;
  }
  resumeAutoCommit(doCommit = true) {
    this.suspendCount--;
    if (this.autoCommit && doCommit) {
      this.doAutoCommit();
    }
  }
  doAutoCommit() {
    if (this.suspendCount <= 0) {
      this.commit();
    }
  }
};
var StoreChanges = (Target) => class StoreChanges extends (Target || Base$1) {
  static get $name() {
    return "StoreChanges";
  }
  static get configurable() {
    return {
      applyChangesetFilterSortTarget: "changes"
    };
  }
  applyChangesFromStore(otherStore) {
    const me = this, {
      changes
    } = otherStore;
    if (!changes) {
      return;
    }
    if (changes.added) {
      me.add(changes.added);
    }
    if (changes.removed) {
      me.remove(changes.removed.map((r) => r.id));
    }
    if (changes.modified) {
      changes.modified.forEach((record) => {
        const localRecord = me.getById(record.id);
        localRecord.set(record.modifications);
      });
    }
  }
  applyChangeset(changes, transformFn = null, phantomIdField = "$PhantomId", remote = true, logChanges = false) {
    var _transformFn, _ref;
    const me = this, {
      added,
      updated,
      modified,
      removed
    } = (_transformFn = transformFn === null || transformFn === void 0 ? void 0 : transformFn(changes, me)) !== null && _transformFn !== void 0 ? _transformFn : changes, altered = (_ref = updated !== null && updated !== void 0 ? updated : modified) !== null && _ref !== void 0 ? _ref : [], idDataSource = me.modelClass.getFieldDataSource("id"), log = logChanges ? /* @__PURE__ */ new Map() : null, allAdded = [], allAltered = [];
    let rootUpdated = false, modifiedParents = [];
    if ((added === null || added === void 0 ? void 0 : added.length) > 0) {
      var _me$add;
      const toUpdate = [], toAdd = [];
      for (const data of added) {
        var _data$phantomIdField;
        if (me.getById((_data$phantomIdField = data[phantomIdField]) !== null && _data$phantomIdField !== void 0 ? _data$phantomIdField : ObjectHelper.getPath(data, idDataSource))) {
          toUpdate.push(data);
        } else {
          toAdd.push(data);
        }
      }
      altered.unshift.apply(altered, toUpdate);
      const addedRecords = (_me$add = me.add(toAdd, false, {
        orderedParentIndex: {
          skip: true
        }
      })) !== null && _me$add !== void 0 ? _me$add : [];
      allAdded.push(...addedRecords);
      if (me.tree) {
        for (const record of addedRecords) {
          const {
            parent
          } = record;
          if (parent.isRoot) {
            rootUpdated = true;
            modifiedParents = [parent];
            break;
          }
          if (!parent.isRoot && modifiedParents.every((r) => !r.contains(parent))) {
            modifiedParents.push(parent);
          }
        }
      }
      for (const record of addedRecords) {
        log === null || log === void 0 ? void 0 : log.set(record.id, record.data);
        record.clearChanges();
      }
    }
    if ((altered === null || altered === void 0 ? void 0 : altered.length) > 0) {
      for (const data of altered) {
        const phantomId = data[phantomIdField], id = ObjectHelper.getPath(data, idDataSource), record = me.getById(phantomId !== null && phantomId !== void 0 ? phantomId : id);
        if (record) {
          const changes2 = record.applyChangeset(data, phantomIdField, remote);
          if (me.tree && !rootUpdated && modifiedParents.every((r) => !r.contains(record))) {
            if (record.parent.isRoot) {
              rootUpdated = true;
              modifiedParents = [record.parent];
            } else {
              modifiedParents.push(record.parent);
            }
          }
          log === null || log === void 0 ? void 0 : log.set(id, changes2);
          allAltered.push(record);
        }
      }
    }
    if ((removed === null || removed === void 0 ? void 0 : removed.length) > 0) {
      me.applyRemovals(removed);
    }
    me.afterChangesetApplied(modifiedParents);
    if (me.applyChangesetFilterSortTarget === "changes") {
      me.filterChangeset(allAdded, allAltered, me.isSorted ? me.createSorterFn(me.sorters) : void 0);
    }
    return log;
  }
  afterChangesetApplied(modifiedParents) {
    modifiedParents.forEach((parent) => {
      parent.traverse((record) => {
        record.sortOrderedChildren(false, false);
        if (record.children) {
          record.updateChildrenIndices(record.children, "parentIndex", true);
        }
        if (record.unfilteredChildren) {
          record.updateChildrenIndices(record.unfilteredChildren, "unfilteredIndex", true);
        }
      });
    });
  }
  applyRemovals(removals) {
    const me = this, {
      removed: removedStash
    } = me, idDataSource = me.modelClass.idField, toRemove = [];
    for (const removedEntry of removals) {
      const id = ObjectHelper.getPath(removedEntry, idDataSource);
      if (removedStash.includes(id)) {
        removedStash.remove(id);
      } else {
        toRemove.push(id);
      }
    }
    me.remove(toRemove);
    for (const record of toRemove) {
      removedStash.remove(record);
    }
  }
  filterChangeset(added, updated, storeSortFunction) {
    const me = this, {
      isFiltered,
      isGrouped,
      tree
    } = me, {
      allValues,
      addedValues,
      isSorted,
      filterFunction
    } = me.storage, sorter = storeSortFunction != null || isSorted ? storeSortFunction !== null && storeSortFunction !== void 0 ? storeSortFunction : me.storage.sortFunction : null;
    if (tree || !isFiltered) {
      return false;
    }
    let didChange = false, trigger = false, groupers;
    if (isGrouped) {
      groupers = me.groupers;
      me.clearGroupers(true);
    }
    const {
      filteredValues
    } = me.storage;
    if (sorter) {
      const sortedLength = addedValues ? filteredValues.findLastIndex((value) => !addedValues.has(value)) + 1 : filteredValues.length, sorted = filteredValues.slice(0, sortedLength), updatedMatches = new Set(updated.filter(filterFunction));
      for (const value of filteredValues) {
        if (updatedMatches.has(value)) {
          updatedMatches.delete(value);
        }
      }
      for (const newMatch of updatedMatches) {
        sorted.push(newMatch);
      }
      sorted.sort(sorter);
      filteredValues.splice(0, sortedLength, ...sorted);
      trigger = true;
    } else {
      const updatedMatches = new Set(updated.filter((item) => filterFunction(item) && !me.storage.includes(item)));
      let filteredIndex = 0, rawIndex = 0, allInserted = updatedMatches.size === 0;
      while (rawIndex < allValues.length && !allInserted) {
        const filteredValue = filteredValues[filteredIndex];
        let rawValue = allValues[rawIndex];
        while (filteredValue !== rawValue) {
          if (updatedMatches.has(rawValue)) {
            filteredValues.splice(filteredIndex, 0, rawValue);
            trigger = didChange = true;
            filteredIndex++;
            updatedMatches.delete(rawValue);
            allInserted = updatedMatches.size === 0;
          }
          rawValue = allValues[++rawIndex];
        }
        if (filteredIndex < filteredValues.length) {
          filteredIndex++;
        }
      }
    }
    const nonMatchingAdds = new Set(added.filter((value) => !filterFunction(value)));
    for (let filteredIndex = filteredValues.length - 1; filteredIndex >= 0; filteredIndex--) {
      const value = filteredValues[filteredIndex];
      if (nonMatchingAdds.has(value)) {
        filteredValues.splice(filteredIndex, 1);
        trigger = didChange = true;
        nonMatchingAdds.delete(value);
      }
    }
    if (groupers) {
      me.group(groupers[0], null, false, true, true);
      trigger = true;
    }
    if (trigger) {
      me._idMap = null;
      me.trigger("refresh");
    }
    return didChange;
  }
};
var StoreFilter = (Target) => class StoreFilter extends (Target || Base$1) {
  static get $name() {
    return "StoreFilter";
  }
  static get defaultConfig() {
    return {
      filters: null,
      reapplyFilterOnAdd: false,
      reapplyFilterOnUpdate: false
    };
  }
  set reapplyFilterOnAdd(enable) {
    this.storage.autoFilter = enable;
  }
  get reapplyFilterOnAdd() {
    return this.storage.autoFilter;
  }
  set filters(filters) {
    const me = this, collection = me.filters;
    collection.clear();
    me._filtersFunction = null;
    if (filters) {
      if (filters.constructor.name === "Object") {
        for (const f of Object.entries(filters)) {
          if (f[0] === "filterBy" && typeof f[1] === "function") {
            collection.add(new CollectionFilter({
              filterBy: f[1]
            }));
          } else {
            collection.add(new CollectionFilter(f[1].constructor.name === "Object" ? Object.assign({
              property: f[0]
            }, f[1]) : {
              property: f[0],
              value: f[1]
            }));
          }
        }
      } else if (Array.isArray(filters)) {
        collection.add(...filters.map((filterConfig) => {
          if (filterConfig instanceof CollectionFilter) {
            return filterConfig;
          }
          return new CollectionFilter(filterConfig);
        }));
      } else if (filters.isCollection) {
        collection.add(...filters.values);
      } else {
        collection.add(new CollectionFilter({
          filterBy: filters
        }));
      }
      collection.forEach((item) => item.owner = me);
    }
  }
  get filters() {
    return this._filters || (this._filters = new Collection({
      extraKeys: ["property"]
    }));
  }
  set filtersFunction(filtersFunction) {
    this._filtersFunction = filtersFunction;
  }
  get filtersFunction() {
    const me = this, {
      filters,
      isGrouped
    } = me;
    if (!me._filtersFunction) {
      if (filters.count) {
        const generatedFilterFunction = CollectionFilter.generateFiltersFunction(filters);
        me._filtersFunction = (candidate) => {
          if (isGrouped && candidate.isSpecialRow) {
            return candidate.groupChildren.some(generatedFilterFunction);
          } else {
            return generatedFilterFunction(candidate);
          }
        };
      } else {
        me._filtersFunction = FunctionHelper.returnTrue;
      }
    }
    return me._filtersFunction;
  }
  get isFiltered() {
    return this.filters.values.some((filter2) => !filter2.disabled);
  }
  traverseFilter(record) {
    const me = this, hitsCurrent = !record.isRoot && me.filtersFunction(record), children = record.unfilteredChildren || record.children;
    if (!children || !children.length) {
      return hitsCurrent;
    }
    if (!record.unfilteredChildren) {
      record.unfilteredChildren = record.children.slice();
    }
    record.children = record.unfilteredChildren.filter((r) => {
      return me.traverseFilter(r);
    });
    record.updateChildrenIndices(record.unfilteredChildren, "unfilteredIndex", true);
    record.updateChildrenIndices(record.children, "parentIndex", true);
    return hitsCurrent || Boolean(record.children.length);
  }
  traverseClearFilter(record) {
    const me = this;
    if (record.unfilteredChildren) {
      record.children = record.unfilteredChildren.slice();
      record.unfilteredChildren = null;
    }
    if (record.children) {
      record.children.forEach((r) => me.traverseClearFilter(r));
      record.updateChildrenIndices(record.children, "parentIndex", true);
    }
  }
  get latestFilterField() {
    return this.filters.last ? this.filters.last.property : null;
  }
  addFilter(filter2, silent = false) {
    const me = this;
    filter2 = filter2 instanceof CollectionFilter ? filter2 : new CollectionFilter(filter2);
    filter2.owner = me;
    me.filters.add(filter2);
    if (!silent) {
      if (me.remoteFilter) {
        return me.filter().then(() => filter2);
      } else {
        me.filter();
      }
    }
    return filter2;
  }
  filter(newFilters) {
    const me = this;
    let silent = false, internal;
    if (newFilters) {
      let fieldType = typeof newFilters;
      if (fieldType === "object") {
        if ("silent" in newFilters || "replace" in newFilters || newFilters.filters) {
          silent = newFilters.silent;
          if (newFilters.replace) {
            me.clearFilters(newFilters.filters.length === 0);
          }
          internal = newFilters.internal;
          newFilters = newFilters.filters;
          fieldType = typeof newFilters;
        }
      }
      if (newFilters) {
        const wasFiltered = me.isFiltered;
        me.isConfiguring = true;
        if (Array.isArray(newFilters)) {
          newFilters.forEach((f) => me.addFilter(f, true), me);
        } else if (fieldType === "function") {
          const filter2 = new CollectionFilter(newFilters);
          filter2.internal = internal;
          me.addFilter(filter2, true);
        } else if (fieldType === "string") {
          me.addFilter({
            property: newFilters,
            value: arguments[1]
          }, true);
        } else {
          me.addFilter(newFilters, true);
        }
        me.isConfiguring = false;
        if (!me.isFiltered && !wasFiltered) {
          return null;
        }
      }
    }
    me.filtersFunction = null;
    return me.performFilter(silent);
  }
  performFilter(silent) {
    const me = this, {
      storage,
      filters,
      rootNode
    } = me, oldCount = me.count;
    me.trigger("beforeFilter", {
      filters
    });
    let added, removed;
    if (me.tree) {
      const oldDataset = storage.values;
      if (me.isFiltered) {
        me.traverseFilter(rootNode);
      } else {
        me.traverseClearFilter(rootNode);
      }
      const newDataset = me.collectDescendants(rootNode).visible;
      storage.replaceValues({
        values: newDataset,
        silent: true
      });
      const delta = ArrayHelper.delta(newDataset, oldDataset, true);
      added = delta.toAdd;
      removed = delta.toRemove;
    } else {
      storage.ion({
        change({
          removed: r,
          added: a
        }) {
          removed = r;
          added = a;
        },
        once: true
      });
      if (me.isFiltered) {
        me.isGrouped && me.includeCollapsed();
        storage.addFilter({
          id: "primary-filter",
          filterBy: me.filtersFunction
        });
        me.isGrouped && me.excludeCollapsed();
      } else {
        storage.filters.clear();
      }
    }
    me.afterPerformFilter(silent || me.isRemoteDataLoading ? null : {
      action: "filter",
      filters,
      oldCount,
      added,
      removed,
      records: me.storage.values
    });
  }
  afterPerformFilter(event) {
    this.resetRelationCache();
    if (event) {
      this.triggerFilterEvent(event);
    }
  }
  get filtered() {
    return this.storage.isFiltered;
  }
  triggerFilterEvent(event) {
    this.trigger("filter", event);
    if (!this.remoteFilter) {
      this.trigger("refresh", event);
      this.trigger("change", event);
    }
  }
  filterBy(fn2) {
    return this.filter(fn2);
  }
  removeFilter(idOrInstance, silent = false) {
    const me = this, filter2 = idOrInstance instanceof CollectionFilter ? idOrInstance : me.filters.get(idOrInstance);
    if (filter2) {
      me.filters.remove(filter2);
      me._filtersFunction = null;
      if (!silent) {
        if (me.remoteFilter) {
          return me.filter().then(() => filter2);
        } else {
          me.filter();
        }
      }
      return filter2;
    }
  }
  clearFilters(apply = true) {
    this.filters.remove(this.filters.values.filter((f) => !f.internal));
    if (apply) {
      return this.filter();
    }
  }
  convertFilterToString(field) {
    const filter2 = this.filters.getBy("property", field);
    return filter2 && !filter2.filterBy ? String(filter2) : "";
  }
  doDestroy() {
    var _this$_filters;
    (_this$_filters = this._filters) === null || _this$_filters === void 0 ? void 0 : _this$_filters.destroy();
    super.doDestroy();
  }
};
var resortActions = {
  add: 1,
  replace: 1
};
var StoreGroup = (Target) => class StoreGroup extends (Target || Base$1) {
  static get $name() {
    return "StoreGroup";
  }
  static get defaultConfig() {
    return {
      groupers: null,
      useGroupFooters: false
    };
  }
  static get properties() {
    return {
      collapsedGroups: /* @__PURE__ */ new Set()
    };
  }
  construct(config) {
    super.construct(config);
    this.ion({
      change: "onDataChanged",
      thisObj: this
    });
  }
  get groupers() {
    return this._groupers;
  }
  set groupers(groupers) {
    this.setGroupers(groupers);
  }
  setGroupers(groupers, options) {
    const me = this, {
      storage
    } = me;
    let result;
    if (groupers !== null && groupers !== void 0 && groupers.length) {
      me._groupers = groupers;
    } else if (me.groupers) {
      delete me._groupers;
      me.includeCollapsed();
      storage.replaceValues({
        values: me.removeHeadersAndFooters(storage._values),
        filteredValues: storage.isFiltered ? me.removeHeadersAndFooters(storage._filteredValues) : null,
        silent: true
      });
      result = me.group(null, null, null, false, options === null || options === void 0 ? void 0 : options.silent);
    }
    me._idMap = null;
    return result;
  }
  get groupRecords() {
    const groupRecords = [];
    if (this.isGrouped) {
      for (const record of this) {
        if (record.isSpecialRow) {
          groupRecords.push(record);
        }
      }
    }
    return groupRecords;
  }
  includeCollapsed() {
    for (const groupId of this.collapsedGroups) {
      this.expand(this.getById(groupId), false);
    }
  }
  excludeCollapsed() {
    for (const groupId of this.collapsedGroups) {
      this.collapse(this.getById(groupId));
    }
  }
  onDataChange({
    source: storage,
    action,
    removed
  }) {
    var _super$onDataChange;
    const me = this, {
      groupers
    } = me;
    if (groupers) {
      if (groupers.length) {
        if (action === "splice" && removed !== null && removed !== void 0 && removed.length || action === "move") {
          storage.replaceValues({
            values: me.prepareGroupRecords(),
            silent: true
          });
        }
      } else {
        storage.replaceValues({
          values: me.removeHeadersAndFooters(storage.values),
          silent: true
        });
      }
    }
    (_super$onDataChange = super.onDataChange) === null || _super$onDataChange === void 0 ? void 0 : _super$onDataChange.call(this, ...arguments);
  }
  move(records, beforeRecord) {
    const me = this;
    if (me.isGrouped) {
      var _beforeRecord;
      if ((_beforeRecord = beforeRecord) !== null && _beforeRecord !== void 0 && _beforeRecord.isSpecialRow) {
        beforeRecord = me.getPrev(beforeRecord, false, false);
        if (!beforeRecord) {
          return;
        }
      }
      const groupField = me.groupers[0].field;
      let newGroupValue;
      if (beforeRecord) {
        newGroupValue = beforeRecord.isGroupHeader ? beforeRecord.meta.groupRowFor : beforeRecord[groupField];
      } else {
        newGroupValue = me.groupRecords[me.groupRecords.length - 1].meta.groupRowFor;
      }
      me.beginBatch();
      records.forEach((record) => record[groupField] = newGroupValue);
      me.endBatch();
    }
    super.move(...arguments);
  }
  collapse(groupRecord) {
    if (groupRecord && !groupRecord.meta.collapsed) {
      this.excludeGroupRecords(groupRecord);
      groupRecord.meta.collapsed = true;
      this.collapsedGroups.add(groupRecord.id);
      return true;
    }
    return false;
  }
  expand(groupRecord, updateMap = true) {
    if (groupRecord !== null && groupRecord !== void 0 && groupRecord.meta.collapsed) {
      this.includeGroupRecords(groupRecord);
      groupRecord.meta.collapsed = false;
      updateMap && this.collapsedGroups.delete(groupRecord.id);
      return true;
    }
    return false;
  }
  removeHeadersAndFooters(records) {
    return records.filter((r) => {
      if (r.isSpecialRow) {
        this.unregister(r);
        return false;
      } else {
        return true;
      }
    });
  }
  prepareGroupRecords(sorter) {
    var _me$storage$filteredV;
    const me = this, toCollapse = me.collapsedGroups, toExpand = [];
    let records = (_me$storage$filteredV = me.storage.filteredValues) !== null && _me$storage$filteredV !== void 0 ? _me$storage$filteredV : me.storage.values;
    for (const record of records) {
      if (record.isGroupHeader && (record.meta.collapsed || toCollapse.has(record.id))) {
        toCollapse.add(record.id);
        toExpand.push(record);
      }
    }
    for (const record of toExpand) {
      me.includeGroupRecords(record);
    }
    records = me.removeHeadersAndFooters(me.storage.values);
    if (sorter) {
      records = records.sort(sorter);
    }
    if (!me.isGrouped) {
      return records;
    }
    const groupedRecords = [], field = me.groupers[0].field;
    let curGroup = null, curGroupRecord = null, childCount = 0;
    function addFooter() {
      const val = curGroupRecord.meta.groupRowFor, id = `group-footer-${typeof val === "number" ? val : StringHelper.createId(val)}`, footer = me.getById(id) || new me.modelClass({
        id
      }, me, {
        specialRow: true,
        groupFooterFor: val,
        groupRecord: curGroupRecord
      });
      footer.stores = [me];
      me.register(footer);
      footer.groupChildren = curGroupRecord.groupChildren;
      if (!curGroupRecord.meta.collapsed) {
        groupedRecords.push(footer);
      }
      me.allRecords.push(footer);
      curGroupRecord.groupChildren.push(footer);
      childCount++;
      return footer;
    }
    records.forEach((record) => {
      var _record$groupChildren;
      const val = record[field] == void 0 ? "__novalue__" : record[field], id = `group-header-${typeof val === "number" ? val : StringHelper.createId(val)}`;
      if (((_record$groupChildren = record.groupChildren) === null || _record$groupChildren === void 0 ? void 0 : _record$groupChildren.length) === 0) {
        me.unregister(record);
        return;
      }
      if (!ObjectHelper.isEqual(val, curGroup)) {
        if (curGroupRecord) {
          if (me.useGroupFooters) {
            addFooter();
          }
          curGroupRecord.meta.childCount = childCount;
        }
        curGroupRecord = me.getById(id) || new me.modelClass({
          id
        }, me, {
          specialRow: true,
          groupRowFor: val,
          groupField: field
        });
        curGroupRecord.meta.collapsed = toCollapse.has(id);
        curGroupRecord.stores = [me];
        me.register(curGroupRecord);
        curGroupRecord.groupChildren = [];
        groupedRecords.push(curGroupRecord);
        me.allRecords.push(curGroupRecord);
        curGroup = val;
        childCount = 0;
      }
      record.instanceMeta(me.id).groupParent = curGroupRecord;
      if (!toCollapse.has(id)) {
        groupedRecords.push(record);
      }
      curGroupRecord.groupChildren.push(record);
      childCount++;
    });
    if (curGroupRecord) {
      if (me.useGroupFooters) {
        addFooter();
      }
      curGroupRecord.meta.childCount = childCount;
    }
    me._idMap = null;
    return groupedRecords;
  }
  get isGrouped() {
    var _this$groupers;
    return Boolean((_this$groupers = this.groupers) === null || _this$groupers === void 0 ? void 0 : _this$groupers.length);
  }
  group(field, ascending, add = false, performSort = true, silent = false) {
    const me = this;
    let newGrouper, fn2;
    if (field && typeof field === "object") {
      ascending = field.ascending;
      fn2 = field.fn;
      field = field.field;
    }
    if (add) {
      me.groupers.push(newGrouper = {
        field,
        ascending,
        complexMapping: field.includes(".")
      });
    } else if (field) {
      if (ascending == null) {
        var _me$groupInfo, _me$groupInfo2;
        ascending = ((_me$groupInfo = me.groupInfo) === null || _me$groupInfo === void 0 ? void 0 : _me$groupInfo.field) === field && ((_me$groupInfo2 = me.groupInfo) === null || _me$groupInfo2 === void 0 ? void 0 : _me$groupInfo2.fn) === fn2 ? !me.groupInfo.ascending : true;
      }
      me.groupInfo = newGrouper = {
        field,
        ascending,
        fn: fn2,
        complexMapping: field.includes(".")
      };
      me.groupers = [me.groupInfo];
    }
    if (newGrouper) {
      const {
        prototype: prototype2
      } = me.modelClass;
      if (newGrouper.complexMapping && !Object.prototype.hasOwnProperty.call(prototype2, field)) {
        Object.defineProperty(prototype2, field, {
          get() {
            return ObjectHelper.getPath(this, field);
          }
        });
      }
    }
    if (performSort !== false) {
      if (me.remoteSort && !me.isRemoteDataLoading) {
        return me.sort(null, null, false, true).then(() => me.onAfterGrouping(silent));
      } else {
        me.sort(null, null, false, true);
      }
    }
    me.onAfterGrouping(silent);
  }
  onAfterGrouping(silent) {
    if (silent) {
      return;
    }
    const me = this;
    me.trigger("group", {
      isGrouped: me.isGrouped,
      groupers: me.groupers,
      records: me.storage.values
    });
    me.trigger("refresh", {
      action: "group",
      isGrouped: me.isGrouped,
      groupers: me.groupers,
      records: me.storage.values
    });
  }
  addGrouper(field, ascending = true) {
    return this.group(field, ascending, true);
  }
  removeGrouper(field) {
    const me = this, {
      groupers
    } = me, index = groupers.findIndex((grouper) => grouper.field === field);
    if (index > -1) {
      groupers.splice(index, 1);
      if (!groupers.length) {
        return me.clearGroupers();
      } else {
        return me.group();
      }
    }
  }
  clearGroupers(silent = false) {
    return this.setGroupers(null, {
      silent
    });
  }
  isRecordInGroup(record, groupValue) {
    var _this$groupers$;
    if (!this.isGrouped) {
      return null;
    }
    const groupField = (_this$groupers$ = this.groupers[0]) === null || _this$groupers$ === void 0 ? void 0 : _this$groupers$.field;
    return record[groupField] === groupValue && !record.isSpecialRow;
  }
  isInCollapsedGroup(record) {
    const parentGroupRec = record.instanceMeta(this).groupParent;
    return parentGroupRec === null || parentGroupRec === void 0 ? void 0 : parentGroupRec.meta.collapsed;
  }
  getGroupRecords(groupValue) {
    if (!this.isGrouped) {
      return null;
    }
    return this.storage.values.filter((record) => this.isRecordInGroup(record, groupValue));
  }
  getGroupTitles() {
    if (!this.isGrouped) {
      return null;
    }
    return this.getDistinctValues(this.groupers[0].field);
  }
  onDataChanged({
    changes,
    action
  }) {
    if (this.isGrouped && (!changes && resortActions[action] || changes && this.groupers.some((grouper) => grouper.field in changes))) {
      this.sort();
    }
  }
  internalIncludeExcludeGroupRecords(groupRecord, include) {
    const me = this, index = me.indexOf(groupRecord), {
      id: mapId,
      storage
    } = me, {
      meta,
      groupChildren
    } = groupRecord;
    if (index === -1 || meta.collapsed && !include || !meta.collapsed && include) {
      return;
    }
    groupChildren.forEach((child) => child.instanceMeta(mapId).hiddenByCollapse = !include);
    if (include) {
      const includeChildren = groupChildren.filter((r) => !me.isAvailable(r));
      storage.values.splice(index + 1, 0, ...includeChildren);
    } else {
      storage.values.splice(index + 1, groupChildren.length);
    }
    storage._indicesInvalid = true;
    me._idMap = null;
  }
  excludeGroupRecords(groupRecord) {
    this.internalIncludeExcludeGroupRecords(groupRecord, false);
  }
  includeGroupRecords(groupRecord) {
    this.internalIncludeExcludeGroupRecords(groupRecord, true);
  }
  collectGroupRecords(allRecords, includeHeaders = true) {
    const records = allRecords ? this.storage.allValues : this.storage.values;
    return records.reduce((records2, record) => {
      if (record.isSpecialRow) {
        if (includeHeaders && !record.isGroupFooter) {
          records2.push(record);
        }
        if (record.isGroupHeader) {
          records2.push.apply(records2, record.groupChildren);
        }
      }
      return records2;
    }, []);
  }
};
var StoreProxy = (Target) => class StoreProxy extends (Target || Base$1) {
  static get configurable() {
    return {
      objectify: null
    };
  }
  initProxy() {
    if (!globalThis.Proxy) {
      throw new Error("Proxy not supported");
    }
    const proxy = new Proxy(this, {
      get(target, property) {
        if (property in target) {
          return target[property];
        }
        if (property === "$store") {
          return target;
        }
        let record = target.getById(property);
        if (!record && !isNaN(parseInt(property))) {
          record = target.getAt(parseInt(property));
        }
        return record;
      },
      set(target, property, value) {
        if (property in target || target.isDestroying) {
          target[property] = value;
        } else {
          target.add(_objectSpread2({
            [target.modelClass.idField]: property
          }, value));
        }
        return true;
      },
      deleteProperty(target, property) {
        if (target.isDestroying) {
          delete target[property];
          return true;
        }
        return Boolean(target.remove(property).length);
      },
      has(target, property) {
        if (property in target) {
          return true;
        }
        if (property.startsWith("{") && property.endsWith("}")) {
          const data = StringHelper.safeJsonParse(property);
          property = data === null || data === void 0 ? void 0 : data.id;
        }
        return target.includes(property);
      }
    });
    return proxy;
  }
};
var StoreRelation = (Target) => {
  var _class;
  return _class = class StoreRelation extends (Target || Base$1) {
    initRelations(reset) {
      const me = this, relations = me.modelClass.exposedRelations;
      if (reset && me.modelRelations) {
        me.modelRelations.forEach((relation) => {
          var _relation$storeDetach;
          return (_relation$storeDetach = relation.storeDetacher) === null || _relation$storeDetach === void 0 ? void 0 : _relation$storeDetach.call(relation);
        });
      }
      if ((!me.modelRelations || me.modelRelations.length === 0 || reset) && relations) {
        me.modelRelations = [];
        relations === null || relations === void 0 ? void 0 : relations.forEach((modelRelationConfig) => {
          const config = _objectSpread2({}, modelRelationConfig), {
            foreignStore,
            relationName,
            relatedCollectionName
          } = config, relatedStore = typeof foreignStore === "string" ? me[foreignStore] : foreignStore;
          config.dependentStore = me;
          me.modelRelations.push(config);
          if (relatedStore) {
            config.foreignStoreProperty = config.foreignStore;
            config.foreignStore = relatedStore;
            const dependentStoreConfigs = relatedStore.dependentStoreConfigs;
            if (dependentStoreConfigs.has(me)) {
              const dependentConfigs = dependentStoreConfigs.get(me);
              if (reset) {
                const existingConfig = dependentConfigs.find((c) => c.relationName === relationName);
                if (existingConfig) {
                  ArrayHelper.remove(dependentConfigs, existingConfig);
                }
              }
              dependentConfigs.push(config);
            } else {
              dependentStoreConfigs.set(me, [config]);
            }
            if (relatedCollectionName) {
              relatedStore.initRelationCollection(config, me);
            }
            if (relatedStore.count > 0) {
              relatedStore.updateDependentStores("dataset", relatedStore.records);
            }
          }
        });
      }
    }
    initRelationCollection(config, collectionStore) {
      const me = this, name = config.relatedCollectionName, collectionStores = me.collectionStores || (me.collectionStores = {});
      collectionStores[name] = {
        store: collectionStore,
        config
      };
      if (!me[name + "Store"]) {
        me[name + "Store"] = collectionStore;
      }
      if (me.count > 0) {
        me.initModelRelationCollection(name, me.records);
      }
    }
    initModelRelationCollection(name, records) {
      const me = this;
      records.forEach((record) => {
        record.traverse((node) => {
          const useName = name in node ? `$related${StringHelper.capitalize(name)}` : name;
          Object.defineProperty(node, useName, {
            enumerable: true,
            configurable: true,
            get: function() {
              return me.getCollection(this, name);
            },
            set: function(value) {
              return me.setCollection(this, name, value);
            }
          });
        });
      });
    }
    resetRelationCache() {
      this.relationCache = {};
      this.forEach((record) => record.initRelations());
    }
    updateRecordRelationCache(record, relations) {
      relations === null || relations === void 0 ? void 0 : relations.forEach((relation) => {
        const {
          config
        } = relation, foreignId = relation.related ? relation.related.id : record.get(config.foreignKey);
        foreignId !== void 0 && this.cacheRelatedRecord(record, foreignId, config.relationName, foreignId);
      });
    }
    getRelationCollection(name, recordOrId) {
      const id = Model.asId(recordOrId);
      return this.relationCache[name] && this.relationCache[name][id] || [];
    }
    getCollection(record, name) {
      const {
        config,
        store
      } = this.collectionStores[name];
      return store.relationCache[config.relationName] && store.relationCache[config.relationName][record.id] || [];
    }
    setCollection(model, name, records) {
      const {
        config,
        store
      } = this.collectionStores[name], relationCache = store.relationCache[config.relationName] || (store.relationCache[config.relationName] = {}), old = (relationCache[model.id] || []).slice(), added = [], removed = [];
      store.suspendEvents();
      old.forEach((record) => {
        if (!records.includes(record)) {
          record[config.foreignKey] = null;
          store.remove(record);
          removed.push(record);
        }
      });
      records.forEach((record) => {
        if (record.isModel instanceof Model) {
          if (!record.stores.includes(store)) {
            store.add(record);
            added.push(record);
          }
        } else {
          [record] = store.add(record);
          added.push(record);
        }
        record[config.foreignKey] = model.id;
      });
      store.resumeEvents();
      if (removed.length) {
        store.trigger("remove", {
          records: removed
        });
        store.trigger("change", {
          action: "remove",
          records: removed
        });
      }
      if (added.length) {
        store.trigger("add", {
          records: added
        });
        store.trigger("change", {
          action: "add",
          records: added
        });
      }
    }
    cacheRelatedRecord(record, id, name, uncacheId = null) {
      const me = this, cache = me.relationCache[name] || (me.relationCache[name] = {});
      if (uncacheId !== null) {
        me.uncacheRelatedRecord(record, name, uncacheId);
      }
      if (id != null) {
        ArrayHelper.include(cache[id] || (cache[id] = []), record);
      }
    }
    uncacheRelatedRecord(record, name = null, id = null) {
      const me = this;
      function remove(relationName, relatedId) {
        const cache = me.relationCache[relationName], oldCache = cache === null || cache === void 0 ? void 0 : cache[relatedId];
        if (oldCache) {
          const uncacheIndex = oldCache.indexOf(record);
          uncacheIndex >= 0 && oldCache.splice(uncacheIndex, 1);
          if (oldCache.length === 0) {
            delete cache[relatedId];
          }
        }
      }
      if (id != null) {
        remove(name, id);
      } else {
        if (record.meta.relationCache) {
          Object.entries(record.meta.relationCache).forEach(([relationName, relatedRecord]) => remove(relationName, relatedRecord === null || relatedRecord === void 0 ? void 0 : relatedRecord.id));
        }
      }
    }
    updateDependentStores(action, records) {
      this.dependentStoreConfigs.forEach((configs) => {
        configs.forEach((config) => {
          const {
            dependentStore,
            relatedCollectionName,
            relationName,
            foreignKey
          } = config, cache = dependentStore.relationCache[relationName];
          if (action === "dataset") {
            relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);
            dependentStore.forEach((record) => {
              const foreign = record.initRelation(config);
              foreign && dependentStore.cacheRelatedRecord(record, foreign.id, relationName, foreign.id);
            });
            return;
          }
          if (action === "removeall") {
            dependentStore.forEach((record) => record.removeRelation(config));
            delete dependentStore.relationCache[relationName];
            return;
          }
          if (action === "add") {
            relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);
          }
          if (action === "add" || action === "remove") {
            records.forEach((record) => {
              const dependentRecords = cache === null || cache === void 0 ? void 0 : cache[record.id];
              switch (action) {
                case "remove":
                  if (dependentRecords) {
                    dependentRecords.forEach((dependentRecord) => dependentRecord.removeRelation(config));
                  }
                  break;
                case "add":
                  dependentStore.forEach((dependentRecord) => {
                    if (dependentRecord.get(foreignKey) == record.id) {
                      dependentRecord.initRelation(config);
                      dependentStore.cacheRelatedRecord(dependentRecord, record.id, relationName);
                    }
                  });
                  break;
              }
            });
          }
        });
      });
    }
    updateDependentRecordIds(oldValue, value) {
      var _this$dependentStoreC;
      (_this$dependentStoreC = this.dependentStoreConfigs) === null || _this$dependentStoreC === void 0 ? void 0 : _this$dependentStoreC.forEach((configs) => {
        configs.forEach((config) => {
          var _cache$oldValue;
          const {
            dependentStore,
            relationName,
            foreignKey
          } = config, cache = dependentStore.relationCache[relationName], localRecords = cache === null || cache === void 0 ? void 0 : (_cache$oldValue = cache[oldValue]) === null || _cache$oldValue === void 0 ? void 0 : _cache$oldValue.slice();
          localRecords === null || localRecords === void 0 ? void 0 : localRecords.forEach((localRecord) => {
            dependentStore.cacheRelatedRecord(localRecord, value, relationName, oldValue);
            localRecord.set(foreignKey, value, false, true);
          });
        });
      });
    }
  }, _defineProperty(_class, "$name", "StoreRelation"), _class;
};
var StoreSum = (Target) => class StoreSum extends (Target || Base$1) {
  static get $name() {
    return "StoreSum";
  }
  sum(field, records = this.storage.values) {
    if (!records)
      return 0;
    return records.reduce((sum, record) => {
      if (record.isSpecialRow)
        return sum;
      const v = Number(record[field]);
      return isNaN(v) ? sum : sum + v;
    }, 0);
  }
  min(field, records = this.storage.values) {
    if (!records || !records.length)
      return 0;
    return records.reduce((min2, record) => {
      var _record$field;
      const type = typeof ((_record$field = record[field]) === null || _record$field === void 0 ? void 0 : _record$field.valueOf());
      if (type === "number" && record[field] < min2)
        min2 = record[field];
      return min2;
    }, records[0][field]);
  }
  max(field, records = this.storage.values) {
    if (!records || !records.length)
      return 0;
    return records.reduce((max, record) => {
      var _record$field2;
      const type = typeof ((_record$field2 = record[field]) === null || _record$field2 === void 0 ? void 0 : _record$field2.valueOf());
      if (type === "number" && record[field] > max)
        max = record[field];
      return max;
    }, records[0][field]);
  }
  average(field, records = this.storage.values) {
    if (!records || !records.length)
      return 0;
    let count = 0;
    const sum = records.reduce((sum2, record) => {
      if (record.isSpecialRow)
        return sum2;
      const v = parseFloat(record[field]);
      if (!isNaN(v)) {
        count++;
        return sum2 + v;
      } else {
        return sum2;
      }
    }, 0);
    return count > 0 ? sum / count : 0;
  }
  groupSum(groupValue, field) {
    return this.sum(field, this.getGroupRecords(groupValue));
  }
};
var findInString = (value, text) => String(value).toLowerCase().includes(text);
var matchFns = {
  string: findInString,
  number: findInString,
  boolean: findInString,
  date: (value, text) => {
    if (value instanceof Date && text instanceof Date) {
      return value - text === 0;
    }
    return String(value.getMonth() + 1).includes(text) || String(value.getDate()).includes(text) || String(value.getFullYear()).includes(text);
  },
  object: (value, text) => value === text,
  undefined: (value, text) => value === text
};
var StoreSearch = (Target) => class StoreSearch extends (Target || Base$1) {
  static get $name() {
    return "StoreSearch";
  }
  search(text, fields = null, formatters, searchAllRecords) {
    const records = this.isTree && !searchAllRecords ? this.rootNode.allChildren : this.getAllDataRecords(searchAllRecords), len = records.length, found = [];
    if (text == null) {
      return [];
    }
    if (typeof text === "string") {
      text = text.toLowerCase();
    }
    let i, j, record, value, valueType, comparison;
    for (i = 0; i < len; i++) {
      record = records[i];
      j = 0;
      for (const key of fields || record.fieldNames) {
        var _comparison;
        value = record[key];
        valueType = value instanceof Date ? "date" : typeof value;
        const formatter = formatters === null || formatters === void 0 ? void 0 : formatters[j];
        if (formatter) {
          value = formatter(value);
          valueType = "string";
        }
        comparison = matchFns[valueType];
        if (value && (_comparison = comparison) !== null && _comparison !== void 0 && _comparison(value, text)) {
          found.push({
            index: i,
            data: record,
            field: key,
            id: record.id
          });
        }
        j++;
      }
    }
    return found;
  }
  findByField(field, value, distinct2 = false, searchAllRecords = false) {
    const records = this.getAllDataRecords(searchAllRecords), len = records.length, usedValues = /* @__PURE__ */ new Set(), found = [];
    let i, record, fieldValue;
    if (value != null) {
      value = String(value).toLowerCase();
    }
    for (i = 0; i < len; i++) {
      record = records[i];
      fieldValue = record[field];
      if (!distinct2 || !usedValues.has(fieldValue)) {
        const type = fieldValue instanceof Date ? "date" : typeof fieldValue, matchFn = matchFns[type];
        if (value == null && fieldValue === value || value && matchFn(fieldValue, value)) {
          found.push({
            id: record.id,
            index: i,
            data: record
          });
          if (distinct2) {
            usedValues.add(fieldValue);
          }
        }
      }
    }
    return found;
  }
  find(fn2, searchAllRecords = false) {
    return this.getAllDataRecords(searchAllRecords).find(fn2);
  }
  findRecord(fieldName, value, searchAllRecords = false) {
    const matchFn = (r) => ObjectHelper.isEqual(r[fieldName], value);
    if (this.isTree) {
      return this.query(matchFn, searchAllRecords)[0];
    }
    return this.getAllDataRecords(searchAllRecords).find(matchFn);
  }
  query(fn2, searchAllRecords = false) {
    if (this.isTree) {
      const matches = [];
      this.traverse((node) => {
        if (fn2(node)) {
          matches.push(node);
        }
      }, void 0, void 0, searchAllRecords);
      return matches;
    }
    return this.getAllDataRecords(searchAllRecords).filter(fn2);
  }
  some(fn2, searchAllRecords = false) {
    return this.getAllDataRecords(searchAllRecords).some(fn2);
  }
};
var nestedRe = /\./;
var StoreSort = (Target) => class StoreSort extends (Target || Base$1) {
  static get $name() {
    return "StoreSort";
  }
  static get defaultConfig() {
    return {
      useLocaleSort: null
    };
  }
  static get configurable() {
    return {
      sorters: [],
      reapplySortersOnAdd: false
    };
  }
  get isSorted() {
    return Boolean(this.sorters.length) || this.isGrouped;
  }
  changeSorters(sorters) {
    return sorters.map((sorter) => this.normalizeSorterConfig(sorter, true));
  }
  updateReapplySortersOnAdd(enable) {
    this.storage.autoSort = enable;
  }
  sort(field, ascending, add = false, silent = false) {
    const me = this, records = me.allRecords, currentSorters = me.sorters ? me.sorters.slice() : [];
    let currentDir = null, curSort;
    if (field) {
      if (Array.isArray(field)) {
        me.sorters = field.map((sorter) => me.normalizeSorterConfig(sorter, typeof sorter === "string" ? true : ascending));
      } else {
        const sorter = me.normalizeSorterConfig(field, ascending);
        if (add) {
          curSort = me.getCurrentSorterByField(sorter.field);
          if (curSort) {
            currentDir = curSort.ascending;
            curSort.ascending = sorter.ascending;
          } else {
            me.sorters.push(sorter);
          }
        } else {
          me.sorters = [sorter];
        }
      }
    }
    if (!silent && me.trigger("beforeSort", {
      sorters: me.sorters,
      records,
      currentSorters
    }) === false) {
      me.sorters = currentSorters;
      if (currentDir !== null) {
        curSort.ascending = currentDir;
      }
      return null;
    }
    return me.performSort(silent);
  }
  normalizeSorterConfig(field, ascending) {
    const me = this, sorter = {
      ascending
    };
    if (typeof field === "object") {
      var _field$ascending;
      ObjectHelper.assign(sorter, field);
      if (field.fn) {
        delete sorter.fn;
        sorter.sortFn = field.fn;
      }
      sorter.ascending = (_field$ascending = field.ascending) !== null && _field$ascending !== void 0 ? _field$ascending : ascending;
    } else if (typeof field === "function") {
      sorter.sortFn = field;
    } else {
      sorter.field = field;
    }
    if (sorter.ascending == null) {
      const curSort = me.getCurrentSorterByField(sorter.field);
      sorter.ascending = curSort ? !curSort.ascending : true;
    }
    if (sorter.sortFn == null) {
      var _me$modelClass, _me$modelClass$$meta$;
      const compareItems = (_me$modelClass = me.modelClass) === null || _me$modelClass === void 0 ? void 0 : (_me$modelClass$$meta$ = _me$modelClass.$meta.fields.map[sorter.field]) === null || _me$modelClass$$meta$ === void 0 ? void 0 : _me$modelClass$$meta$.compareItems;
      if (compareItems) {
        sorter.sortFn = compareItems;
      }
    }
    return sorter;
  }
  getCurrentSorterByField(field) {
    return typeof field === "string" && this.sorters.find((s) => s.field === field) || null;
  }
  addSorter(field, ascending = true) {
    return this.sort(field, ascending, true);
  }
  removeSorter(field) {
    const sorterIndex = this.sorters.findIndex((sorter) => sorter.field === field || sorter.sortFn === field);
    if (sorterIndex > -1) {
      this.sorters.splice(sorterIndex, 1);
      return this.sort();
    }
  }
  clearSorters(silent = false) {
    if (this.sorters.length) {
      this.sorters.length = 0;
      return this.sort(void 0, void 0, void 0, silent);
    }
  }
  createSorterFn(sorters) {
    const storeLocaleSort = this.useLocaleSort;
    return (lhs, rhs) => {
      for (let i = 0; i < sorters.length; i++) {
        const sorter = sorters[i], {
          field,
          ascending = true,
          useLocaleSort = storeLocaleSort
        } = sorter, fn2 = sorter.fn || sorter.sortFn, direction = ascending ? 1 : -1;
        if (fn2) {
          const val = fn2.call(sorter, lhs, rhs);
          if (val !== null) {
            return val * direction;
          }
        }
        const nested = nestedRe.test(field), lhsValue = nested ? lhs.get(field) : lhs[field], rhsValue = nested ? rhs.get(field) : rhs[field];
        if (lhsValue === rhsValue) {
          continue;
        }
        if (lhsValue == null) {
          return -direction;
        }
        if (rhsValue == null) {
          return direction;
        }
        if (useLocaleSort && typeof lhsValue === "string") {
          if (useLocaleSort === true) {
            return String(lhsValue).localeCompare(rhsValue) * direction;
          }
          if (typeof useLocaleSort === "string") {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort) * direction;
          }
          if (typeof useLocaleSort === "object") {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort.locale, useLocaleSort) * direction;
          }
        }
        if (lhsValue > rhsValue) {
          return direction;
        }
        if (lhsValue < rhsValue) {
          return -direction;
        }
      }
      return 0;
    };
  }
  get sorterFn() {
    const me = this, {
      sorters
    } = me;
    return me.createSorterFn(me.remoteSort ? [{
      field: "_remoteSortIndex"
    }] : me.isGrouped ? me.groupers.concat(sorters) : sorters);
  }
  performSort(silent) {
    const me = this, {
      rootNode,
      storage,
      sorterFn: sorter
    } = me;
    if (me.tree) {
      !me.isChained && rootNode.traverse((node) => {
        if (node.isLoaded && node.isParent) {
          node.children.sort(sorter);
          node.updateChildrenIndices(node.children, "parentIndex", true);
        }
      });
      storage.replaceValues({
        values: me.collectDescendants(rootNode).visible,
        silent: true
      });
    } else if (me.isGrouped) {
      storage.replaceValues({
        values: me.prepareGroupRecords(sorter),
        silent: true
      });
    } else {
      storage.replaceValues({
        values: storage.values.sort(sorter),
        silent: true
      });
    }
    me.afterPerformSort(silent || me.isRemoteDataLoading);
  }
  afterPerformSort(silent) {
    if (silent) {
      return;
    }
    const me = this;
    me._idMap = null;
    const event = {
      action: "sort",
      sorters: me.sorters,
      records: me.allRecords
    };
    me.trigger("sort", event);
    me.trigger("refresh", event);
  }
};
var returnTrue$1 = (rec) => true;
var StoreChained = (Target) => class StoreChained extends (Target || Base$1) {
  static get $name() {
    return "StoreChained";
  }
  static get defaultConfig() {
    return {
      chainedFilterFn: null,
      chainedFields: null,
      masterStore: null,
      doRelayToMaster: ["add", "remove", "insert"],
      dontRelayToMaster: [],
      keepUncommittedChanges: false,
      excludeCollapsedRecords: true
    };
  }
  static get properties() {
    return {
      chainedStores: null
    };
  }
  construct(config) {
    super.construct(config);
    const me = this, {
      masterStore
    } = me, sort = me.syncOrder ? "sort" : "";
    if (masterStore) {
      me.methodNamesToRelay.forEach((fnName) => me[fnName] = (...params) => me.relayToMaster(fnName, params));
      me.removeAll = (...params) => {
        masterStore.remove(me.getRange(), ...params);
      };
      masterStore.ion({
        changePreCommit: me.onMasterDataChangedPreCommit,
        change: me.onMasterDataChanged,
        [sort]: me.onMasterDataChanged,
        prio: 1,
        thisObj: me
      });
      if (!masterStore.chainedStores) {
        masterStore.chainedStores = [];
      }
      masterStore.chainedStores.push(me);
      me.fillFromMaster();
    }
  }
  get $master() {
    return this.masterStore || this;
  }
  get isChained() {
    return Boolean(this.masterStore);
  }
  set chainedFilterFn(chainedFilterFn) {
    this._chainedFilterFn = this.thisObj ? chainedFilterFn.bind(this.thisObj) : chainedFilterFn;
  }
  get chainedFilterFn() {
    return this._chainedFilterFn || returnTrue$1;
  }
  get methodNamesToRelay() {
    const doIsArray = Array.isArray(this.doRelayToMaster), dontIsArray = Array.isArray(this.dontRelayToMaster);
    return doIsArray && this.doRelayToMaster.filter((name) => !dontIsArray || !this.dontRelayToMaster.includes(name)) || [];
  }
  updateChainedStores() {
    if (this.chainedStores) {
      this.chainedStores.forEach((store) => store.fillFromMaster());
    }
  }
  fillFromMaster() {
    const me = this, {
      masterStore,
      isTree
    } = me, isRecordFilter = me.chainedFilterFn.length > 0 || me.chainedFilterFn.toString().length <= 10;
    let records;
    if (!me.isChained) {
      throw new Error("fillFromMaster only allowed on chained store");
    }
    if (me.keepUncommittedChanges) {
      if (isTree) {
        throw new Error("Cannot use keepUncommittedChanges on a chained tree store");
      }
      if (isRecordFilter) {
        records = masterStore.allRecords.filter((r) => !me.removed.includes(r) && !me.added.includes(r) && me.chainedFilterFn(r));
      } else {
        records = me.chainedFilterFn().filter((r) => !me.removed.includes(r) && !me.added.includes(r));
      }
      records = me.added.values.filter((r) => !me.removed.includes(r)).concat(records);
    } else {
      if (isRecordFilter) {
        records = masterStore.allRecords.filter(me.chainedFilterFn);
      } else {
        records = me.chainedFilterFn();
      }
      if (isTree) {
        me.idRegister = {};
        me.internalIdRegister = {};
        records.forEach((r) => {
          if (r.stores.includes(me)) {
            me.register(r);
          } else {
            r.joinStore(me);
          }
        });
        if (me.excludeCollapsedRecords) {
          const children = me.getChildren(me.rootNode);
          records = me.doIncludeExclude(children, true);
        }
      }
    }
    me.data = records;
  }
  commitToMaster() {
    const me = this, master = me.masterStore;
    if (!me.isChained) {
      throw new Error("commitToMaster only allowed on chained store");
    }
    master.beginBatch();
    master.remove(me.removed.values);
    master.add(me.added.values);
    master.endBatch();
    return me.commit();
  }
  relayToMaster(fnName, params) {
    return this.masterStore[fnName](...params);
  }
  onMasterDataChangedPreCommit(event) {
    this.onMasterDataChanged(event);
    this.$masterEventhandled = true;
  }
  onMasterDataChanged({
    action,
    changes,
    $handled,
    isMove
  }) {
    var _this$chainedFields;
    if (this.$masterEventhandled) {
      this.$masterEventhandled = false;
      return;
    }
    if (isMove && action === "remove") {
      return;
    }
    if (action !== "update" || (_this$chainedFields = this.chainedFields) !== null && _this$chainedFields !== void 0 && _this$chainedFields.some((field) => field in changes)) {
      this.fillFromMaster();
    }
  }
  makeChained(chainedFilterFn = returnTrue$1, chainedFields, config) {
    return new ((config === null || config === void 0 ? void 0 : config.storeClass) || this.constructor)(_objectSpread2(_objectSpread2({}, config || {}), {}, {
      tree: false,
      autoTree: false,
      masterStore: this.$master,
      modelClass: this.modelClass,
      syncDataOnLoad: false,
      chainedFilterFn,
      chainedFields
    }));
  }
  chain() {
    return this.makeChained(...arguments);
  }
  doDestroy() {
    var _this$chainedStores;
    (_this$chainedStores = this.chainedStores) === null || _this$chainedStores === void 0 ? void 0 : _this$chainedStores.forEach((chainedStore) => chainedStore.destroy());
    super.doDestroy();
  }
};
var StoreState = (Target) => class StoreState extends (Target || Base$1) {
  static get $name() {
    return "StoreState";
  }
  getState() {
    const {
      sorters,
      groupers,
      filters
    } = this, state = {};
    if (sorters !== null && sorters !== void 0 && sorters.length) {
      state.sorters = sorters.map((sorter) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(sorter));
        delete clone.fn;
        delete clone.sortFn;
        return clone;
      });
    }
    if (groupers !== null && groupers !== void 0 && groupers.length) {
      state.groupers = groupers.map((grouper) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(grouper));
        delete clone.fn;
        return clone;
      });
    }
    if (filters !== null && filters !== void 0 && filters.values.length) {
      state.filters = filters.values.map((filter2) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(filter2.config));
        clone.value = filter2.value;
        if (clone.caseSensitive) {
          delete clone.caseSensitive;
        }
        return clone;
      });
    }
    return state;
  }
  applyState(state) {
    const me = this, {
      sorters = [],
      groupers = [],
      filters = []
    } = state, {
      sortParamName,
      filterParamName
    } = me;
    me.sorters = sorters.filter((sorter) => sorter.field || sorter.sortFn && !sortParamName);
    me.groupers = groupers.slice();
    me.sort();
    me.filters = filters.filter((filter2) => filter2.property || filter2.filterBy && !filterParamName);
    me.filter();
  }
};
var zeroPad = (v) => String(v).padStart(6, "0");
var Wbs = class {
  constructor(value) {
    this.value = value;
    this._padded = null;
  }
  set value(value) {
    this._value = String(value !== null && value !== void 0 ? value : "");
  }
  get value() {
    return this._value;
  }
  static from(value) {
    return value == null ? value : value instanceof Wbs ? value : new Wbs(value);
  }
  static pad(value) {
    return value instanceof Wbs ? value.valueOf() : Wbs.split(value).map(zeroPad).join(".");
  }
  static split(value) {
    let i, ret;
    if (value || value === 0) {
      switch (typeof value) {
        case "object":
          value = String(value);
        case "string":
          ret = value.split(".");
          for (i = ret.length; i-- > 0; ) {
            ret[i] = parseInt(ret[i], 10);
          }
          break;
        case "number":
          ret = [value];
          break;
      }
    }
    return ret || [];
  }
  static compare(lhs, rhs) {
    if (lhs === rhs) {
      return 0;
    }
    if (!lhs || !rhs) {
      return lhs ? 1 : rhs ? -1 : 0;
    }
    lhs = Wbs.pad(lhs);
    rhs = Wbs.pad(rhs);
    return lhs < rhs ? -1 : rhs < lhs ? 1 : 0;
  }
  append(value) {
    const s = this.value;
    return Wbs.from(s ? `${s}.${value}` : value);
  }
  isEqual(value) {
    return !Wbs.compare(this, value);
  }
  match(pattern) {
    let ret = false;
    if (pattern) {
      const wbs = this.value, globLeft = pattern[0] === "*", globRight = pattern.endsWith("*"), n = pattern.length;
      if (globLeft === globRight) {
        ret = wbs.indexOf(globLeft ? pattern.substr(1, n - 2) : pattern) > -1;
      } else if (globLeft) {
        ret = wbs.endsWith(pattern.substr(1));
      } else {
        ret = wbs.startsWith(pattern.substr(0, n - 1));
      }
    }
    return ret;
  }
  toString() {
    return this.value;
  }
  toJSON() {
    return this.toString();
  }
  valueOf() {
    var _this$_padded;
    return (_this$_padded = this._padded) !== null && _this$_padded !== void 0 ? _this$_padded : this._padded = Wbs.pad(this.value);
  }
};
Wbs._$name = "Wbs";
var emptyArray$a = Object.freeze([]);
var StoreTree = (Target) => {
  var _class;
  return _class = class StoreTree extends (Target || Base$1) {
    get isTree() {
      return this.tree || this.masterStore && this.masterStore.tree;
    }
    get leaves() {
      const me = this, result = [];
      if (me.isTree) {
        me.traverse((record) => {
          if (record.isLeaf) {
            result.push(record);
          }
        });
        return result;
      } else {
        me.allRecords.forEach((r) => {
          if (r.isLeaf) {
            result.push(r);
          }
          r.traverse((record) => {
            if (record.isLeaf) {
              result.push(record);
            }
          }, true);
        });
      }
      return result;
    }
    async loadChildren(parentRecord) {
    }
    onNodeAddChild(parent, children, index, isMove, silent = false) {
      const me = this, isRootLoad = parent === me.rootNode && parent.isLoading, {
        storage
      } = me, toAddToUI = [], toAdd = [], {
        previousSibling
      } = children[0];
      let storeInsertionPoint;
      me.collectDescendants(children, toAddToUI, toAdd, {
        inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me))
      });
      if (!isRootLoad && toAdd.length) {
        for (const record of toAdd) {
          if (!me.modified.includes(record) && !isMove[record.id]) {
            if (me.removed.includes(record)) {
              me.removed.remove(record);
            } else if (!record.isLinked) {
              me.added.add(record);
            }
          }
        }
      }
      if (isRootLoad && me.rootVisible) {
        toAddToUI.unshift(parent);
        toAdd.unshift(parent);
      }
      if (toAddToUI.length) {
        if (index === 0 || !previousSibling) {
          storeInsertionPoint = storage.indexOf(parent);
        } else {
          storeInsertionPoint = storage.indexOf(previousSibling) + previousSibling.getDescendantCount(true, me);
        }
        storage.suspendEvents();
        me.storage.splice(++storeInsertionPoint, 0, toAddToUI);
        storage.resumeEvents();
        me._idMap = null;
      }
      me.updateDependentStores("add", children);
      if (isRootLoad && toAddToUI.length) {
        var _me$afterLoadData;
        if (me.sorters.length) {
          me.sort(null, null, false, true);
        }
        (_me$afterLoadData = me.afterLoadData) === null || _me$afterLoadData === void 0 ? void 0 : _me$afterLoadData.call(me);
        if (!silent) {
          const event = {
            action: "dataset",
            data: me._data,
            records: toAddToUI
          };
          me.trigger("refresh", event);
          me.trigger("change", event);
        }
      } else if (!silent) {
        const event = {
          action: "add",
          parent,
          isChild: true,
          isMove,
          records: children,
          allRecords: toAdd,
          index: storeInsertionPoint
        };
        me.trigger("add", event);
        me.trigger("change", event);
        if (Object.values(isMove).some((wasMoved) => wasMoved)) {
          const event2 = {
            newParent: parent,
            records: children.filter((record) => isMove[record.id]),
            oldParents: children.map((child) => {
              const parent2 = me.getById(child.meta.oldParentId);
              return parent2 !== null && parent2 !== void 0 && parent2.isRoot ? null : parent2;
            })
          };
          me.trigger("move", event2);
        }
      }
    }
    onNodeRemoveChild(parent, children, index, flags = {
      isMove: false,
      silent: false,
      unfiltered: false
    }) {
      const me = this, {
        storage
      } = me, toRemoveFromUI = [], toRemove = [], {
        isMove,
        silent,
        unfiltered
      } = flags, removeUnfiltered = unfiltered && me.isFiltered, childrenToRemove = removeUnfiltered && parent.unfilteredChildren ? parent.unfilteredChildren : children;
      me.collectDescendants(childrenToRemove, toRemoveFromUI, toRemove, {
        inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me)),
        unfiltered: removeUnfiltered
      });
      if (!isMove) {
        for (const record of children) {
          record.unjoinStore(me);
        }
        for (const record of toRemove) {
          if (record.stores.includes(me)) {
            record.unjoinStore(me);
          }
          if (me.added.includes(record)) {
            me.added.remove(record);
          } else if (!record.isLinked) {
            me.removed.add(record);
          }
        }
        me.modified.remove(toRemove);
      }
      if (toRemoveFromUI.length) {
        index = storage.indexOf(toRemoveFromUI[0]);
        if (index > -1) {
          storage.suspendEvents();
          storage.splice(index, toRemoveFromUI.length);
          storage.resumeEvents();
          me._idMap = null;
        }
      } else {
        index = -1;
      }
      if (!silent && (me.fireRemoveEventForMoveAction || !isMove)) {
        const event = {
          action: "remove",
          parent,
          isChild: true,
          isMove,
          records: children,
          allRecords: toRemove,
          index
        };
        me.trigger("remove", event);
        me.trigger("change", event);
      }
      return toRemove;
    }
    collectDescendants(node, visible = [], all = [], flags) {
      const me = this, {
        inCollapsedBranch = false,
        unfiltered = false
      } = flags || 0, children = Array.isArray(node) ? node : me.getChildren(node, unfiltered);
      if (children) {
        for (let i = 0, len = children.length, child; i < len; i++) {
          child = children[i];
          if (!inCollapsedBranch) {
            visible.push(child);
          }
          all.push(child);
          me.collectDescendants(child, visible, all, {
            inCollapsedBranch: inCollapsedBranch || !child.isExpanded(me),
            unfiltered
          });
        }
      }
      return {
        visible,
        all
      };
    }
    getChildren(parent, unfiltered = false) {
      const me = this, children = (unfiltered || me.isChained) && parent.unfilteredChildren || parent.children;
      return !(children !== null && children !== void 0 && children.length) ? emptyArray$a : me.isChained ? children.filter(me.chainedFilterFn).sort(me.sorterFn) : children;
    }
    internalToggleTreeSubRecords(parentRecord, include) {
      const me = this, {
        storage
      } = me, index = storage.indexOf(parentRecord), children = me.doIncludeExclude(me.getChildren(parentRecord), include);
      if (me.isFiltered && include && parentRecord.unfilteredChildren) {
        me.updateChildrenHiddenState(parentRecord);
      }
      if (children.length && index !== false) {
        storage.suspendEvents();
        if (include) {
          storage.splice(index + 1, 0, ...children);
          const event = {
            action: "add",
            isExpand: true,
            records: children,
            index: index + 1
          };
          me.trigger("add", event);
          me.trigger("change", event);
        } else {
          storage.splice(index + 1, children.length);
          const event = {
            action: "remove",
            isCollapse: true,
            records: children,
            index: index + 1
          };
          me.trigger("remove", event);
          me.trigger("change", event);
        }
        storage.resumeEvents();
        me._idMap = null;
      }
    }
    updateChildrenHiddenState(parentRecord) {
      var _parentRecord$unfilte;
      (_parentRecord$unfilte = parentRecord.unfilteredChildren) === null || _parentRecord$unfilte === void 0 ? void 0 : _parentRecord$unfilte.forEach((child) => {
        child.instanceMeta(this.id).hidden = false;
        if (!child.isLeaf) {
          this.updateChildrenHiddenState(child);
        }
      });
    }
    doIncludeExclude(children, include, result = []) {
      const me = this, childCount = (children === null || children === void 0 ? void 0 : children.length) || 0;
      for (let i = 0; i < childCount; i++) {
        const child = children[i];
        if (!me.isChained || me.chainedFilterFn(child)) {
          const mapMeta = child.instanceMeta(me.id);
          if (include || !mapMeta.hidden) {
            result.push(child);
          }
          mapMeta.hidden = !include;
          if (child.isExpanded(me)) {
            me.doIncludeExclude(me.getChildren(child), include, result);
          }
        }
      }
      return result;
    }
    async toggleCollapse(idOrRecord, collapse) {
      const me = this, record = me.getById(idOrRecord), meta = record.instanceMeta(me);
      if (collapse === void 0) {
        collapse = !meta.collapsed;
      }
      if (!meta.isLoadingChildren && !record.isLeaf && record.isExpanded(me) === collapse) {
        me.trigger("beforeToggleNode", {
          record,
          collapse
        });
        meta.collapsed = collapse;
        if (meta.collapsed) {
          me.onNodeCollapse(record);
          return true;
        } else {
          me.onNodeExpand(record);
          let success2 = true;
          if (!record.isLoaded) {
            meta.isLoadingChildren = true;
            try {
              await me.loadChildren(record);
            } catch (exception) {
              meta.collapsed = true;
              success2 = false;
              me.trigger("loadChildrenException", {
                record,
                exception
              });
            } finally {
              meta.isLoadingChildren = false;
            }
          }
          return success2;
        }
      }
    }
    onNodeCollapse(parentRecord) {
      if (parentRecord.ancestorsExpanded(this)) {
        return this.internalToggleTreeSubRecords(parentRecord, false);
      }
    }
    onNodeExpand(parentRecord) {
      if (parentRecord.ancestorsExpanded(this)) {
        return this.internalToggleTreeSubRecords(parentRecord, true);
      }
    }
    transformToTree(data) {
      const {
        parentIdField,
        idField,
        childrenField
      } = this.modelClass, parents = /* @__PURE__ */ new Map(), transformed = [];
      for (const node of data) {
        const parentId = node[parentIdField];
        if (parentId != null) {
          let parent = parents.get(parentId);
          if (parent === void 0) {
            var _data$find;
            parent = (_data$find = data.find((node2) => node2[idField] === parentId)) !== null && _data$find !== void 0 ? _data$find : null;
            parents.set(parentId, parent);
          }
          if (parent) {
            if (!parent[childrenField]) {
              parent[childrenField] = [];
            }
            parent[childrenField].push(node);
          }
        } else {
          transformed.push(node);
        }
      }
      return transformed;
    }
    treeify(fields, parentTransform, convertParents = false) {
      const {
        length
      } = fields, parents = [], newRoot = {};
      let i, lastParent;
      for (i = 0; i < length; i++) {
        if (!fields[i].call) {
          const field = fields[i];
          fields[i] = (n) => n[field];
        }
        parents[i] = /* @__PURE__ */ new Map();
      }
      this.rootNode.traverse((n) => {
        lastParent = null;
        if (n.isLeaf) {
          for (i = 0; i < length; i++) {
            var _lastParent;
            const lastParentPath = ((_lastParent = lastParent) === null || _lastParent === void 0 ? void 0 : _lastParent.path) || "", nodeMap = parents[i], key = fields[i](n), path = `${lastParentPath + key}/`, id = StringHelper.makeValidDomId(`generated_${path}`, "_"), parent = nodeMap.get(id) || nodeMap.set(id, {
              id,
              key,
              path,
              expanded: true,
              readOnly: true,
              children: [],
              generatedParent: true
            }).get(id);
            if (lastParent && !lastParent.children.includes(parent)) {
              lastParent.children.push(parent);
            }
            lastParent = parent;
          }
          lastParent.children.push(n);
        }
      }, true);
      parents.forEach((p) => p.forEach((p2, id, map2) => {
        parentTransform === null || parentTransform === void 0 ? void 0 : parentTransform(p2);
        if (convertParents) {
          p2 = this.createRecord(p2);
          map2.set(id, p2);
        }
      }));
      newRoot.children = [...parents[0].values()];
      const sort = (n) => {
        if (n.children) {
          n.children.sort((lhs, rhs) => {
            if (lhs.isLeaf) {
              let result;
              for (let i2 = 0; !result && i2 < length; i2++) {
                const lv = fields[i2](lhs), rv = fields[i2](rhs);
                result = lv < rv ? -1 : rv > lv ? 1 : 0;
              }
              return result;
            } else {
              if (typeof lhs.key === "string" || typeof rhs.key === "string") {
                return lhs.key.localeCompare(rhs.key, void 0, {
                  numeric: true
                });
              }
              return lhs.key < rhs.key ? -1 : lhs.key > rhs.key ? 1 : 0;
            }
          });
          n.children.forEach(sort);
        }
      };
      sort(newRoot);
      return newRoot;
    }
    treeifyFlatData(data) {
      const {
        childrenField,
        parentIdField
      } = this.modelClass;
      let hasParentId = false, shouldTransform = true;
      for (const node of data) {
        if (node.isModel || Array.isArray(node[childrenField])) {
          shouldTransform = false;
          break;
        }
        if (node[parentIdField] != null) {
          hasParentId = true;
        }
      }
      if (shouldTransform && hasParentId) {
        data = this.transformToTree(data);
      }
      return data;
    }
    async indent(nodes) {
      const me = this;
      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes = nodes.filter((node) => {
        let result = Boolean(node.previousSibling);
        while (result && !node.isRoot) {
          result = !nodes.includes(node.parent);
          node = node.parent;
        }
        return result;
      });
      if (nodes.length && me.trigger("beforeIndent", {
        records: nodes
      }) !== false) {
        nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));
        me.beginBatch();
        for (const node of nodes) {
          const newParent = node.previousSibling;
          newParent.appendChild(node);
          me.toggleCollapse(newParent, false);
        }
        me.endBatch();
        me.trigger("indent", {
          records: nodes
        });
        me.trigger("change", {
          action: "indent",
          records: nodes
        });
      }
    }
    async outdent(nodes) {
      const me = this;
      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes = nodes.filter((node) => {
        const {
          parent
        } = node;
        let result = parent && !parent.isRoot;
        while (result && !node.isRoot) {
          result = !nodes.includes(parent);
          node = node.parent;
        }
        return result;
      });
      if (nodes.length && me.trigger("beforeOutdent", {
        records: nodes
      }) !== false) {
        nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));
        me.beginBatch();
        for (const node of nodes) {
          const {
            parent
          } = node, newChildren = parent.children.slice(parent.children.indexOf(node) + 1);
          parent.parent.insertChild(node, parent.nextSibling);
          node.appendChild(newChildren);
          me.toggleCollapse(node, false);
        }
        me.endBatch();
        me.trigger("outdent", {
          records: nodes
        });
        me.trigger("change", {
          action: "outdent",
          records: nodes
        });
      }
    }
  }, _defineProperty(_class, "$name", "StoreTree"), _defineProperty(_class, "configurable", {
    transformFlatData: null,
    fireRemoveEventForMoveAction: VersionHelper.checkVersion("core", "6.0", "<")
  }), _class;
};
var WalkHelper = class {
  static preWalk(data, childrenFn, fn2) {
    const walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack.pop();
      fn2(node);
      children = childrenFn(node);
      if (children) {
        walkStack.push.apply(walkStack, children.slice().reverse());
      }
    }
  }
  static preWalkWithParent(data, childrenFn, fn2) {
    const walkStack = [{
      node: data,
      parent: null
    }];
    while (walkStack.length) {
      const {
        parent,
        node
      } = walkStack.pop();
      fn2(parent, node);
      const children = childrenFn(node);
      if (Array.isArray(children)) {
        walkStack.push(...children.slice().reverse().map((child) => ({
          node: child,
          parent: node
        })));
      }
    }
  }
  static preWalkUnordered(data, childrenFn, fn2) {
    const walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      fn2(node);
      children = childrenFn(node);
      if (children) {
        walkStack.splice(walkStack.length - 1, 1, ...children);
      } else {
        walkStack.length = walkStack.length - 1;
      }
    }
  }
  static postWalk(data, childrenFn, fn2) {
    const visited = /* @__PURE__ */ new Map(), walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      if (visited.has(node)) {
        fn2(node);
        walkStack.pop();
      } else {
        children = childrenFn(node);
        if (children) {
          walkStack.push(...children.slice().reverse());
        }
        visited.set(node, node);
      }
    }
  }
  static prePostWalk(data, childrenFn, inFn, outFn) {
    const visited = /* @__PURE__ */ new Map(), walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      if (visited.has(node)) {
        outFn(node);
        walkStack.pop();
      } else {
        inFn(node);
        children = childrenFn(node);
        if (children) {
          walkStack.push(...children.slice().reverse());
        }
        visited.set(node, node);
      }
    }
  }
};
WalkHelper._$name = "WalkHelper";
var StoreSync = (Target) => class StoreSync extends (Target || Base$1) {
  static get $name() {
    return "StoreSync";
  }
  static get configurable() {
    return {
      syncDataOnLoad: null
    };
  }
  syncDataset(data) {
    const me = this, {
      storage
    } = me;
    me.isSyncingDataOnLoad = true;
    const {
      toAdd,
      toRemove,
      toMove,
      updated,
      ids
    } = me.tree ? me.syncTreeDataset(data) : me.syncFlatDataset(data);
    let {
      threshold
    } = me.syncDataOnLoad, surpassed = false;
    if (threshold) {
      if (typeof threshold === "string") {
        threshold = parseInt(threshold, 10) / 100 * me.count;
      }
      surpassed = toAdd.length + toRemove.length + toMove.length + updated.length > threshold;
    }
    if (me.tree) {
      if (toAdd.length) {
        const added = me.add(toAdd, surpassed);
        added.forEach((node) => node.clearParentId());
      }
      if (toMove.length) {
        for (const {
          parent,
          node,
          index
        } of toMove) {
          const newParent = me.getById(parent.id);
          newParent.insertChild(node, index);
        }
      }
      me.remove(toRemove, surpassed);
    } else {
      if (surpassed) {
        me.suspendEvents();
      }
      me.remove(toRemove);
      me.add(toAdd);
      if (surpassed) {
        me.resumeEvents();
      }
    }
    if (threshold && !surpassed) {
      updated.forEach(({
        record,
        toSet,
        wasSet
      }) => me.onModelChange(record, toSet, wasSet));
    }
    me.acceptChanges();
    const event = {
      added: toAdd,
      removed: toRemove,
      updated,
      thresholdSurpassed: surpassed
    };
    if (me.isFiltered && !me.remoteFilter) {
      me.filter({
        silent: me.isRemoteDataLoading
      });
    }
    if (me.isGrouped) {
      me.group(null, null, false, true, me.isRemoteDataLoading);
    } else if (me.isSorted) {
      if (me.remoteSort) {
        storage.replaceValues({
          values: storage.values.sort(me.createSorterFn(me.sorters)),
          silent: true
        });
      } else {
        me.sort();
      }
    } else if (!me.tree) {
      if (storage.values.some((record, index) => record.id !== ids[index])) {
        storage.replaceValues({
          values: storage.values.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id)),
          silent: true
        });
        !surpassed && me.afterPerformSort();
      }
    } else {
      let unsorted = false, i = 0;
      WalkHelper.preWalk(me.rootNode, (n) => Array.isArray(n.children) && !unsorted ? n.children : null, (node) => {
        if (node.id !== ids[i++]) {
          unsorted = true;
        }
      });
      if (unsorted) {
        me.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id), void 0, void 0, true);
        me.clearSorters(true);
        !surpassed && me.afterPerformSort();
      }
    }
    if (surpassed) {
      me.trigger("refresh", {
        action: "batch",
        data,
        records: storage.values,
        syncInfo: event
      });
    }
    me.isSyncingDataOnLoad = false;
    me.trigger("loadSync", event);
  }
  syncFlatDataset(data) {
    if (!data) {
      return {
        toRemove: this.records
      };
    }
    const me = this, {
      idField,
      allFields
    } = me.modelClass, toRemove = [], toAdd = [], updated = [], usedIds = {}, ids = [];
    const {
      threshold,
      keepMissingValues
    } = me.syncDataOnLoad;
    let hitCount = 0;
    data.forEach((rawData) => {
      rawData = rawData.isModel ? rawData.data : rawData;
      const id = rawData[idField], record = me.getById(id);
      if (record) {
        if (keepMissingValues === false) {
          for (const field of allFields) {
            if (!(field.dataSource in rawData) && field.dataSource in record.data) {
              rawData[field.dataSource] = field.defaultValue;
            }
          }
        }
        const wasSet = record.set(rawData, null, Boolean(threshold));
        if (wasSet) {
          updated.push({
            record,
            wasSet,
            toSet: rawData
          });
        }
        hitCount++;
      } else {
        toAdd.push(me.processRecord(me.createRecord(rawData)));
      }
      usedIds[id] = 1;
      ids.push(id);
    });
    if (hitCount < me.allCount) {
      me.forEach((record) => {
        if (!usedIds[record.id]) {
          toRemove.push(record);
        }
      });
    }
    return {
      toAdd,
      toRemove,
      toMove: [],
      updated,
      ids
    };
  }
  syncTreeDataset(data) {
    if (!data) {
      return {
        toRemove: this.records
      };
    }
    const me = this, {
      idField,
      parentIdField,
      childrenField,
      allFields
    } = me.modelClass, {
      keepMissingValues
    } = me.syncDataOnLoad, toRemove = [], toAdd = [], toMove = [], updated = [], usedIds = {}, ids = [];
    if (me.transformFlatData) {
      data = me.treeifyFlatData(data);
    }
    const {
      threshold
    } = me.syncDataOnLoad;
    WalkHelper.preWalkWithParent({
      isRoot: true,
      id: me.rootNode.id,
      children: data
    }, (n) => n.children, (parent, rawData) => {
      if (parent) {
        const id = rawData[idField], node = me.getById(id);
        if (node) {
          let childrenUpdated;
          const oldChildrenValue = node.children;
          if (oldChildrenValue !== true && rawData[childrenField] === true) {
            node.clearChildren();
            node.data[childrenField] = node.children = true;
            delete rawData[childrenField];
            me.toggleCollapse(node, true);
            childrenUpdated = true;
          }
          if (node.parent.id !== parent[idField]) {
            toMove.push({
              node,
              parent,
              index: parent[childrenField].indexOf(rawData)
            });
          }
          if (keepMissingValues === false) {
            for (const field of allFields) {
              if (field.name !== "parentId" && !(field.dataSource in rawData) && field.dataSource in node.data) {
                rawData[field.dataSource] = field.defaultValue;
              }
            }
          }
          const wasSet = node.set(rawData, null, Boolean(threshold));
          if (wasSet) {
            updated.push({
              record: node,
              wasSet,
              toSet: rawData
            });
          } else if (childrenUpdated) {
            node.signalNodeChanged({
              [childrenField]: {
                value: true,
                oldValue: oldChildrenValue
              }
            });
          }
        } else {
          rawData[parentIdField] = parent[idField];
          toAdd.push(_objectSpread2(_objectSpread2({}, rawData), Array.isArray(rawData[childrenField]) ? {
            children: []
          } : void 0));
        }
        usedIds[id] = 1;
        ids.push(id);
      }
    });
    me.traverse((node) => {
      if (!usedIds[node.id]) {
        toRemove.push(node);
      }
    });
    return {
      toAdd,
      toRemove,
      toMove,
      updated,
      ids
    };
  }
};
var STM_PROP = Symbol("STM_PROP");
var StoreStm = (Target) => class StoreStm extends (Target || Base$1) {
  static get $name() {
    return "StoreStm";
  }
  static get defaultConfig() {
    return {
      stm: null,
      ignoreRemoteChangesInSTM: false
    };
  }
  get stm() {
    return this[STM_PROP];
  }
  set stm(stm) {
    const me = this;
    if (me.stm !== stm) {
      var _me$stm;
      if ((_me$stm = me.stm) !== null && _me$stm !== void 0 && _me$stm.hasStore(me)) {
        me.stm.removeStore(me);
      }
      me[STM_PROP] = stm;
      if (me.stm && !me.stm.hasStore(me)) {
        me.stm.addStore(me);
      }
    }
  }
  add(records, silent = false, options = {}) {
    let result;
    const {
      stm
    } = this;
    if (!this.tree && stm !== null && stm !== void 0 && stm.enabled) {
      var _result;
      result = super.add(records, silent);
      if ((_result = result) !== null && _result !== void 0 && _result.length) {
        stm.onStoreModelAdd(this, result, silent);
      }
    } else {
      result = super.add(records, silent, options);
    }
    return result;
  }
  insert(index, records, silent = false) {
    let result;
    const {
      stm
    } = this;
    if (!this.tree && stm !== null && stm !== void 0 && stm.enabled) {
      var _result2;
      const context = (Array.isArray(records) ? records : [records]).reduce((context2, r) => {
        const index2 = r instanceof Model ? this.indexOf(r) : void 0;
        if (index2 !== void 0 && index2 !== -1) {
          context2.set(r, index2);
        }
        return context2;
      }, /* @__PURE__ */ new Map());
      result = super.insert(index, records);
      if ((_result2 = result) !== null && _result2 !== void 0 && _result2.length) {
        index = this.indexOf(result[0]);
        stm.onStoreModelInsert(this, index, result, context, silent);
      }
    } else {
      result = super.insert(index, records, silent);
    }
    return result;
  }
  remove(recordsOrIds, silent = false, fromRemoveChild) {
    let result;
    const {
      stm
    } = this;
    if (!this.tree && stm !== null && stm !== void 0 && stm.enabled) {
      var _result3;
      const recordsOrIdsNormalized = (Array.isArray(recordsOrIds) ? recordsOrIds : [recordsOrIds]).map((r) => this.getById(r)).filter((r) => !!r);
      const context = recordsOrIdsNormalized.reduce((context2, r) => {
        const index = this.indexOf(r);
        if (index !== void 0 && index !== -1) {
          context2.set(r, index);
        }
        return context2;
      }, /* @__PURE__ */ new Map());
      result = super.remove(recordsOrIds, silent, fromRemoveChild);
      if ((_result3 = result) !== null && _result3 !== void 0 && _result3.length) {
        stm.onStoreModelRemove(this, result, context, silent);
      }
    } else {
      result = super.remove(recordsOrIds, silent, fromRemoveChild);
    }
    return result;
  }
  removeAll(silent) {
    const {
      stm
    } = this;
    let result;
    if (stm !== null && stm !== void 0 && stm.enabled) {
      const {
        tree,
        rootNode,
        allRecords
      } = this, wasNotEmpty = allRecords.length, records = tree ? rootNode.children.slice() : allRecords.slice();
      result = super.removeAll(silent);
      if (wasNotEmpty && this.count === 0) {
        stm.onStoreRemoveAll(this, records, silent);
      }
    } else {
      result = super.removeAll(silent);
    }
    return result;
  }
  beforeApplyChangeset() {
    const {
      stm,
      crudManager
    } = this;
    let shouldResume = false;
    if (!(crudManager !== null && crudManager !== void 0 && crudManager.applyingChangeset) && stm !== null && stm !== void 0 && stm.enabled) {
      shouldResume = true;
      if (stm.isRecording) {
        stm.stash();
      }
      if (this.ignoreRemoteChangesInSTM) {
        stm.disable();
      } else {
        stm.startTransaction();
      }
    }
    return shouldResume;
  }
  applyChangeset(changes, transformFn, phantomIdField, remote, logChanges) {
    const shouldResume = this.beforeApplyChangeset(), log = super.applyChangeset(changes, transformFn, phantomIdField, remote, logChanges);
    this.afterApplyChangeset(shouldResume);
    return log;
  }
  afterApplyChangeset(shouldResume) {
    if (shouldResume) {
      const {
        stm
      } = this;
      if (this.ignoreRemoteChangesInSTM) {
        stm.enable();
      } else {
        stm.stopTransaction();
      }
      stm.applyStash();
    }
  }
};
var dataAddRemoveActions$2 = {
  splice: 1,
  clear: 1
};
var defaultTraverseOptions = {
  includeFilteredOutRecords: false,
  includeCollapsedGroupRecords: false
};
var fixTraverseOptions = (store, options) => {
  options = options || false;
  if (typeof options === "boolean") {
    options = {
      includeFilteredOutRecords: options,
      includeCollapsedGroupRecords: false
    };
  }
  return options || defaultTraverseOptions;
};
var Store = class extends Base$1.mixin(
  Delayable,
  Identifiable,
  Events,
  Pluggable,
  State,
  StoreFilter,
  StoreChanges,
  StoreCRUD,
  StoreRelation,
  StoreSum,
  StoreSearch,
  StoreSort,
  StoreGroup,
  StoreChained,
  StoreState,
  StoreTree,
  StoreStm,
  StoreSync,
  StoreProxy
) {
  static get $name() {
    return "Store";
  }
  static get properties() {
    return {
      relationCache: {},
      dependentStoreConfigs: /* @__PURE__ */ new Map()
    };
  }
  static get configurable() {
    return {
      id: true,
      modelClass: Model,
      verifyNoGeneratedIds: true
    };
  }
  static get defaultConfig() {
    return {
      fields: null,
      autoTree: true,
      data: null,
      tree: false,
      callOnFunctions: true,
      storage: null,
      useRawData: false,
      allowNoId: true,
      preventSubClassingModel: null
    };
  }
  static get identifiable() {
    return {
      registerGeneratedId: false
    };
  }
  constructor(...args) {
    super(...args);
    if (this.objectify) {
      return this.initProxy();
    }
  }
  construct(config = {}) {
    const me = this;
    Object.assign(me, {
      added: new StoreBag(),
      removed: new StoreBag(),
      modified: new StoreBag(),
      idRegister: {},
      internalIdRegister: {},
      oldIdMap: {}
    });
    if (config.storeId) {
      config = ObjectHelper.assign({
        id: config.storeId
      }, config);
    }
    super.construct(config);
    me.initRelations();
  }
  static from(config, defaults = {}, converterFn = null) {
    if (config && !config.isStore) {
      if (typeof config === "string") {
        config = Store.getStore(config);
      } else {
        if (Array.isArray(config)) {
          if (converterFn) {
            config = config.map((data) => data.isModel ? data : converterFn(data));
          }
          config = ObjectHelper.assign({}, defaults, {
            data: config
          });
        }
        config = new Store(config);
      }
    }
    return config;
  }
  doDestroy() {
    var _me$_storage, _me$stm, _me$stm$removeStore;
    const me = this, allRecords = me.registeredRecords;
    for (let i = allRecords.length - 1, rec; i >= 0; i--) {
      var _rec;
      rec = allRecords[i];
      if (!((_rec = rec) !== null && _rec !== void 0 && _rec.isDestroyed)) {
        rec.unjoinStore(me);
      }
    }
    (_me$_storage = me._storage) === null || _me$_storage === void 0 ? void 0 : _me$_storage.destroy();
    (_me$stm = me.stm) === null || _me$stm === void 0 ? void 0 : (_me$stm$removeStore = _me$stm.removeStore) === null || _me$stm$removeStore === void 0 ? void 0 : _me$stm$removeStore.call(_me$stm, me);
    if (!me.isChained) {
      var _me$rootNode;
      (_me$rootNode = me.rootNode) === null || _me$rootNode === void 0 ? void 0 : _me$rootNode.destroy();
    }
    super.doDestroy();
  }
  beginBatch() {
    this.suspendEvents();
  }
  endBatch() {
    if (this.resumeEvents()) {
      this.trigger("refresh", {
        action: "batch",
        data: this.storage.values,
        records: this.storage.values
      });
    }
  }
  set storage(storage) {
    const me = this;
    if (storage !== null && storage !== void 0 && storage.isCollection) {
      me._storage = storage;
    } else {
      me._storage = new Collection(storage);
    }
    me._storage.autoFilter = me.reapplyFilterOnAdd;
    me._storage.autoSort = me.reapplySortersOnAdd;
    for (const r of me._storage) {
      r.joinStore(me);
    }
    me._storage.ion({
      change: "onDataChange",
      thisObj: me
    });
  }
  get storage() {
    if (!this._storage) {
      this.storage = {};
    }
    return this._storage;
  }
  get allRecords() {
    const me = this;
    if (me.isTree) {
      const result = me.collectDescendants(me.rootNode, void 0, void 0, {
        unfiltered: true
      }).all;
      if (me.rootVisible) {
        result.unshift(me.rootNode);
      }
      return result;
    } else {
      return me.isGrouped ? me.collectGroupRecords() : me.storage.allValues;
    }
  }
  getAllDataRecords(searchAllRecords) {
    return this.isGrouped ? this.collectGroupRecords(searchAllRecords, false) : searchAllRecords ? this.storage.allValues : this.storage.values;
  }
  onIsCreatingToggle(record, isCreating) {
    const me = this, newlyPersistable = record.isPersistable && !isCreating;
    me.added[newlyPersistable ? "add" : "remove"](record);
    if (newlyPersistable) {
      me.trigger("addConfirmed", {
        record
      });
      if (me.autoCommit) {
        me.doAutoCommit();
      }
    }
  }
  joinRecordsToStore(records) {
    const {
      allCount
    } = this;
    for (let i = 0; i < records.length; i++) {
      const record = records[i];
      record.setData("parentIndex", allCount + i - records.length);
      record.joinStore(this);
    }
  }
  onDataChange({
    source: storage,
    action,
    added,
    removed,
    replaced,
    oldCount,
    items: items2,
    from,
    to
  }) {
    const me = this, isAddRemove = dataAddRemoveActions$2[action], addedCount = isAddRemove && (added === null || added === void 0 ? void 0 : added.length), removedCount = isAddRemove && (removed === null || removed === void 0 ? void 0 : removed.length);
    let filtersWereReapplied, sortersWereReapplied;
    me._idMap = null;
    if (addedCount) {
      me.joinRecordsToStore(added);
    }
    replaced === null || replaced === void 0 ? void 0 : replaced.forEach(([oldRecord, newRecord]) => {
      oldRecord.unjoinStore(me, true);
      newRecord.joinStore(me);
    });
    super.onDataChange(...arguments);
    if (!me.isTree) {
      if (addedCount) {
        for (const record of added) {
          if (me.removed.includes(record)) {
            me.removed.remove(record);
          } else if (!record.isLinked) {
            me.added.add(record);
          }
        }
        filtersWereReapplied = !me.remoteFilter && me.filtered && me.reapplyFilterOnAdd;
        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
        sortersWereReapplied = !me.remoteSort && me.isSorted && me.reapplySortersOnAdd;
        if (sortersWereReapplied) {
          me.sort(null, null, false, true);
        }
      }
      if (removedCount) {
        for (const record of removed) {
          record.cancelBatch();
          record.unjoinStore(me);
          if (me.added.includes(record)) {
            me.added.remove(record);
          } else if (!record._undoingInsertion && !record.isCreating && !record.isLinked) {
            me.removed.add(record);
          }
        }
        me.modified.remove(removed);
        filtersWereReapplied = !me.remoteFilter && me.filtered;
        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
      }
    }
    switch (action) {
      case "clear":
        me.relationCache = {};
        me.updateDependentStores("removeall");
        me.trigger("removeAll");
        me.trigger("change", {
          action: "removeall"
        });
        break;
      case "splice":
        if (addedCount) {
          me.updateDependentStores("add", added);
          const oldIndex = added.reduce((lowest, record) => {
            const {
              previousIndex
            } = record.meta;
            if (previousIndex > -1 && previousIndex < lowest)
              lowest = previousIndex;
            return lowest;
          }, added[0].meta.previousIndex), index = storage.indexOf(added[0], !storage.autoFilter), params = {
            records: added,
            index
          };
          if (oldIndex > -1) {
            params.oldIndex = oldIndex;
          }
          me.trigger("add", params);
          me.trigger("change", Object.assign({
            action: "add"
          }, params));
          if (filtersWereReapplied) {
            me.triggerFilterEvent({
              action: "filter",
              filters: me.filters,
              oldCount,
              records: me.storage.allValues
            });
          }
          if (sortersWereReapplied) {
            me.trigger("sort", {
              action: "sort",
              sorters: me.sorters,
              records: me.storage.allValues
            });
          }
        }
        if (removed.length) {
          me.updateDependentStores("remove", removed);
          me.trigger("remove", {
            records: removed
          });
          me.trigger("change", {
            action: "remove",
            records: removed
          });
        }
        if (replaced.length) {
          me.trigger("replace", {
            records: replaced,
            all: me.records.length === replaced.length
          });
          me.trigger("change", {
            action: "replace",
            replaced,
            all: me.records.length === replaced.length
          });
        }
        break;
      case "filter":
        if (me.isGrouped || me.isSorted) {
          me.performSort(true);
        }
        break;
      case "move": {
        const start = Math.min(from, to), end = Math.min(me.storage.allValues.length - 1, Math.max(from, to));
        for (let allRecords = me.storage.allValues, i = start; i <= end; i++) {
          allRecords[i].setData("parentIndex", i);
        }
        me.trigger("move", {
          record: items2[0],
          records: items2,
          from,
          to
        });
        if (me.isFiltered) {
          me.performFilter();
        }
        me.trigger("change", {
          action,
          record: items2[0],
          records: items2,
          from,
          to
        });
        break;
      }
    }
  }
  onDataReplaced(action, data) {
    var _me$afterLoadData;
    const me = this, {
      storage
    } = me, all = storage.allValues, sorted = Boolean(me.sorters.length > 0);
    for (let i = 0; i < all.length; i++) {
      all[i].joinStore(me);
    }
    const groupRecords = me.prepareGroupRecords();
    if (!me.remoteFilter && me.isFiltered) {
      me.filter({
        silent: true
      });
    }
    if (me.remoteSort) {
      if (me.isGrouped) {
        storage.replaceValues({
          values: groupRecords,
          silent: true
        });
      }
    } else {
      if (me.isGrouped) {
        me.group(null, null, false, !sorted, true);
      }
      if (sorted) {
        me.sort(null, null, false, true);
      }
    }
    if (!me.useRawData.disableDuplicateIdCheck) {
      const {
        idMap
      } = me;
      if (Object.keys(idMap).length < storage.values.length) {
        const collisions = [];
        storage.values.forEach((r) => idMap[r.id] ? delete idMap[r.id] : collisions.push(r));
        throw new Error(`Id collision on ${collisions.map((r) => r.id)}`);
      }
    }
    const event = {
      action,
      data,
      records: storage.values
    };
    me.updateDependentStores(action, event.records);
    (_me$afterLoadData = me.afterLoadData) === null || _me$afterLoadData === void 0 ? void 0 : _me$afterLoadData.call(me);
    if (!me.isRemoteDataLoading) {
      me.trigger("refresh", event);
    }
    me.trigger("change", event);
  }
  onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {
    const me = this, event = {
      record,
      records: [record],
      changes: wasSet,
      batch: record.batching != null,
      fromRelationUpdate
    }, committable = record.ignoreBag || record.isLinked ? false : me.updateModifiedBagForRecord(record);
    me.storage.onItemMutation(record, wasSet);
    if ("id" in wasSet) {
      const {
        oldValue,
        value
      } = toSet.id;
      me.updateDependentRecordIds(oldValue, value);
      me.onRecordIdChange({
        record,
        oldValue,
        value
      });
    }
    if (!silent) {
      if ("id" in wasSet) {
        const {
          oldValue,
          value
        } = toSet.id;
        me.trigger("idChange", {
          store: me,
          record,
          oldValue,
          value
        });
      }
      me.onUpdateRecord(record, wasSet);
      me.trigger("update", event);
      me.trigger("change", Object.assign({
        action: "update"
      }, event));
    }
    if (me.autoCommit && committable) {
      me.doAutoCommit();
    }
  }
  updateModifiedBagForRecord(record) {
    const me = this;
    let addedToBag = false;
    if (record.isModified) {
      if (!me.modified.includes(record) && !me.added.includes(record) && record.isPartOfStore(me) && !record.isAutoRoot) {
        if (record.isPhantom) {
          me.added.add(record);
        } else {
          me.modified.add(record);
        }
        addedToBag = true;
      }
    } else {
      me.modified.remove(record);
    }
    return addedToBag;
  }
  get idMap() {
    const me = this, needsRebuild = !me._idMap, idMap = me._idMap || (me._idMap = {});
    if (needsRebuild) {
      const processedRecords = me.storage.values;
      for (let record, index = 0, visibleIndex = 0; index < processedRecords.length; index++) {
        record = processedRecords[index];
        idMap[record.id] = {
          index,
          visibleIndex,
          record
        };
        if (!record.isSpecialRow) {
          visibleIndex++;
        }
      }
    }
    return idMap;
  }
  changeModelClass(ClassDef) {
    const {
      fields
    } = this;
    this.originalModelClass = ClassDef;
    let ClassDefEx = ClassDef;
    if (fields !== null && fields !== void 0 && fields.length) {
      ClassDefEx = class extends ClassDef {
        static get fields() {
          return fields;
        }
      };
    } else if (!this.preventSubClassingModel) {
      ClassDefEx = class extends ClassDef {
      };
    }
    ClassDefEx.initClass();
    return ClassDefEx;
  }
  set storeId(storeId) {
    this.id = storeId;
  }
  get storeId() {
    return this.id;
  }
  changeId(id, oldId) {
    return super.changeId(id !== true && id, oldId);
  }
  updateId(id, oldId) {
    const duplicate = Store.getById(id);
    duplicate && Store.unregisterInstance(duplicate);
    super.updateId(id, oldId);
  }
  generateAutoId() {
    return Store.generateId(`store-`);
  }
  get tree() {
    return this._tree;
  }
  set tree(tree) {
    this._tree = tree;
    if (tree && !this.rootNode) {
      this.rootNode = this.buildRootNode();
      this.rootNode.isAutoRoot = true;
    }
  }
  buildRootNode() {
    return {};
  }
  static getStore(id, storeClass) {
    if (id instanceof Store) {
      return id;
    }
    if (this.getById(id)) {
      return this.getById(id);
    }
    if (Array.isArray(id)) {
      let storeModel;
      const storeData = id.map((item) => {
        if (item instanceof Model) {
          storeModel = item.constructor;
        } else if (typeof item === "string") {
          item = {
            text: item
          };
        } else
          ;
        return item;
      });
      id = {
        autoCreated: true,
        data: storeData,
        modelClass: storeModel || class extends Model {
        },
        allowNoId: true
      };
      if (!storeClass) {
        storeClass = Store;
      }
    }
    if (storeClass) {
      return new storeClass(id);
    }
  }
  static get stores() {
    return Store.registeredInstances;
  }
  get rootNode() {
    return this.masterStore ? this.masterStore.rootNode : this._rootNode;
  }
  set rootNode(rootNode) {
    var _rootNode$children;
    const me = this, oldRoot = me._rootNode;
    if (rootNode === oldRoot) {
      return;
    }
    if (oldRoot) {
      me.clear(true);
    }
    if (rootNode instanceof Model) {
      rootNode.instanceMeta(me).collapsed = false;
      me._rootNode = rootNode;
    } else {
      me._rootNode = rootNode = new me.modelClass(Object.assign({
        expanded: true,
        [me.modelClass.idField]: `${me.id}-rootNode`
      }, rootNode), me, null, true);
    }
    me._tree = true;
    rootNode.isRoot = true;
    rootNode.joinStore(me);
    if ((_rootNode$children = rootNode.children) !== null && _rootNode$children !== void 0 && _rootNode$children.length || me.rootVisible) {
      rootNode.isLoading = true;
      me.onNodeAddChild(rootNode, rootNode.children || [], 0);
      rootNode.isLoading = false;
    }
    me.trigger("rootChange", {
      oldRoot,
      rootNode
    });
  }
  set data(data) {
    this.setStoreData(data);
  }
  setStoreData(data) {
    var _data, _data2;
    const me = this, {
      idField,
      childrenField
    } = me.modelClass;
    if (me.transformFlatData && ((_data = data) === null || _data === void 0 ? void 0 : _data.length) > 0 && !Object.isExtensible(data[0])) {
      me.useRawData = me.useRawData || {
        disableDuplicateIdCheck: false,
        disableDefaultValue: false,
        disableTypeConversion: false
      };
      data = ObjectHelper.clone(data);
    }
    me.getConfig("plugins");
    me.processConfiguredListeners();
    if (data && !Array.isArray(data)) {
      data = ObjectHelper.transformNamedObjectToArray(data, idField);
    }
    me.tree = !me.isChained && (me.tree || Boolean(me.autoTree && ((_data2 = data) === null || _data2 === void 0 ? void 0 : _data2.some((r) => r[childrenField]))));
    if (data && (me.remoteSort || me.remoteFilter)) {
      for (let i = 0; i < data.length; i++) {
        data[i]._remoteSortIndex = i;
      }
    }
    if (!me.syncDataOnLoad || !me._data) {
      me._data = data;
      if (me.tree) {
        if (me.transformFlatData) {
          data = me.treeifyFlatData(data);
        }
        const root2 = me.rootNode;
        root2.isLoading = true;
        me._data.forEach((record) => delete record.parentId);
        me.clear(true);
        root2.appendChild(data);
        me.updateDependentStores("dataset", [root2]);
        root2.isLoading = false;
        if (data.length === 0) {
          const event = {
            action: "dataset",
            data: [],
            records: []
          };
          me.trigger("refresh", event);
          me.trigger("change", event);
        } else if (me.isFiltered) {
          me.filter();
        }
      } else {
        me.loadData(data);
      }
      me.added.clear();
      me.removed.clear();
      me.modified.clear();
    } else {
      me.syncDataset(data);
    }
  }
  loadData(data, action = "dataset") {
    const me = this, {
      storage,
      allowNoId
    } = me, idField = me.modelClass.fieldMap.id.dataSource, creatingRecord = me.find((rec) => rec.isCreating);
    if (creatingRecord) {
      storage.values.splice(me.records.indexOf(creatingRecord), 1);
    }
    let warnGenerated = me.verifyNoGeneratedIds;
    me.removeHeadersAndFooters(me.storage.values);
    me._idMap = null;
    me.oldIdMap = {};
    if (data) {
      const isRaw = !(data[0] instanceof Model);
      if (isRaw) {
        me.modelClass.exposeProperties(data[0]);
        const count = data.length, records = new Array(count);
        for (let i = 0; i < count; i++) {
          var _recordData$idField, _recordData$idField$s, _recordData$idField2;
          const recordData = data[i];
          if (!allowNoId && recordData[idField] == null) {
            throw new Error(`Id required but not found on row ${i}`);
          }
          if (warnGenerated && (_recordData$idField = recordData[idField]) !== null && _recordData$idField !== void 0 && (_recordData$idField$s = (_recordData$idField2 = _recordData$idField).startsWith) !== null && _recordData$idField$s !== void 0 && _recordData$idField$s.call(_recordData$idField2, "_generated")) {
            console.warn(`Generated id found in data: ${recordData[idField]}. Generated ids are temporary and should be replaced with real ids by the backend`);
            warnGenerated = false;
          }
          records[i] = me.processRecord(me.createRecord(recordData, true), true);
          records[i].setData("parentIndex", i);
        }
        me.clear(true);
        storage.replaceValues({
          values: records,
          isNewDataset: true,
          silent: true
        });
      } else {
        me.clear(true);
        storage.replaceValues({
          values: data.slice(),
          isNewDataset: true,
          silent: true
        });
      }
      if (creatingRecord) {
        storage.values.push(creatingRecord);
      }
      me._data = data;
      me.onDataReplaced(action, data);
    } else {
      me.clear(true);
      me._data = null;
    }
    me.isSyncingDataOnLoad = false;
  }
  get data() {
    return this._data;
  }
  getRange(start, end, all = true) {
    return (all ? this.storage.allValues : this.storage.values).slice(start, end);
  }
  createRecord(data, skipExpose = false, rawData = false) {
    return new this.modelClass(data, this, null, skipExpose, false, rawData);
  }
  processRecord(record, isDataset = false) {
    return record;
  }
  refreshData() {
    this.filter();
    this.sort();
  }
  onRecordIdChange({
    record,
    oldValue,
    value
  }) {
    const me = this, idMap = me._idMap, {
      idRegister,
      oldIdMap
    } = me;
    me.storage._indicesInvalid = true;
    oldIdMap[oldValue] = record;
    if (idMap && !idMap[value]) {
      const entry = idMap[oldValue];
      delete idMap[oldValue];
      idMap[value] = entry;
    }
    me.added.changeId(oldValue, value);
    me.removed.changeId(oldValue, value);
    me.modified.changeId(oldValue, value);
    delete idRegister[oldValue];
    idRegister[value] = record;
    record.index = me.storage.indexOf(record);
  }
  onUpdateRecord(record, changes) {
    const me = this, {
      internalId
    } = changes, {
      internalIdRegister
    } = me;
    if (internalId) {
      this.storage._indicesInvalid = true;
      delete internalIdRegister[internalId.oldValue];
      internalIdRegister[internalId.value] = record;
    }
    if (me.reapplyFilterOnUpdate && me.isFiltered) {
      me.filter();
    }
  }
  get useRawData() {
    return this._useRawData;
  }
  set useRawData(options) {
    if (options === true) {
      this._useRawData = {
        enabled: true,
        disableDuplicateIdCheck: true,
        disableTypeConversion: true,
        disableDefaultValue: false
      };
    } else {
      this._useRawData = options ? Object.assign(options, {
        enabled: true
      }) : {
        enabled: false
      };
    }
  }
  getCount(countProcessed = true) {
    return countProcessed ? this.count : this.originalCount;
  }
  get originalCount() {
    var _this$groupRecords;
    return this.storage.totalCount - (((_this$groupRecords = this.groupRecords) === null || _this$groupRecords === void 0 ? void 0 : _this$groupRecords.length) || 0);
  }
  get count() {
    return this.storage.count;
  }
  get allCount() {
    return this.isTree ? this.rootNode.descendantCount : this.storage.totalCount;
  }
  get records() {
    return this.storage.values;
  }
  get first() {
    return this.storage.values[0];
  }
  get last() {
    return this.storage.values[this.storage.values.length - 1];
  }
  getAt(index, all = false) {
    return this.storage.getAt(index, all);
  }
  register(record) {
    const me = this;
    if (!me.useRawData.disableDuplicateIdCheck) {
      const existingRec = me.isTree && me.idRegister[record.id];
      if (existingRec && existingRec !== record) {
        throw new Error(`Id collision on ${record.id}`);
      }
    }
    me.idRegister[record.id] = record;
    me.internalIdRegister[record.internalId] = record;
  }
  unregister(record) {
    delete this.idRegister[record.id];
    delete this.internalIdRegister[record.internalId];
  }
  get registeredRecords() {
    return Object.values(this.idRegister);
  }
  getById(id) {
    if (id !== null && id !== void 0 && id.isModel) {
      const record = id;
      if (record.hasLinks && !this.storage.allValues.includes(record)) {
        return record.$links.find((r) => this.storage.allValues.includes(r));
      }
      return record;
    }
    return this.idRegister[id];
  }
  isAvailable(recordOrId) {
    const record = this.getById(recordOrId);
    return record && this.storage.includes(record) || false;
  }
  getByInternalId(internalId) {
    return this.internalIdRegister[internalId];
  }
  includes(recordOrId) {
    if (this.isTree) {
      return this.idRegister[Model.asId(recordOrId)] != null;
    }
    return this.indexOf(recordOrId) > -1;
  }
  indexOf(recordOrId, visibleRecords = false, allExceptFilteredOutRecords = false) {
    if (recordOrId !== null && recordOrId !== void 0 && recordOrId.isModel && !recordOrId.stores.includes(this.$store || this)) {
      const linkedRecord = recordOrId.$links.find((r) => this.storage.allValues.includes(r));
      if (linkedRecord) {
        return this.indexOf(linkedRecord, visibleRecords);
      }
      return -1;
    }
    if (this.isTree) {
      return (allExceptFilteredOutRecords ? this.rootNode.allChildren : this.storage.values).indexOf(this.getById(recordOrId));
    }
    const id = Model.asId(recordOrId);
    if (id == null) {
      return -1;
    }
    const found = this.idMap[id];
    return found ? found[visibleRecords ? "visibleIndex" : "index"] : -1;
  }
  allIndexOf(recordOrId) {
    if (this.isTree) {
      const record = this.getById(recordOrId);
      let result = -1;
      if (record) {
        record.bubble((n) => {
          if (n.parent) {
            result += n.parentIndex + 1;
          } else if (n === this.rootNode && this.rootVisible) {
            result += 1;
          }
        });
      }
      return result;
    } else {
      return this.storage.indexOf(recordOrId, true);
    }
  }
  getDistinctValues(field, searchAllRecords = false) {
    const me = this, values = [], keys = {};
    let value;
    me.forEach((r) => {
      if (!r.isSpecialRow && !r.isRoot) {
        value = r.get(field);
        const primitiveValue = value instanceof Date ? value.getTime() : value;
        if (!keys[primitiveValue]) {
          values.push(value);
          keys[primitiveValue] = 1;
        }
      }
    }, me, searchAllRecords);
    return values;
  }
  getValueCount(field, value) {
    let count = 0;
    this.forEach((r) => {
      if (ObjectHelper.isEqual(r.get(field), value))
        count++;
    });
    return count;
  }
  set json(json) {
    if (typeof json === "string") {
      json = StringHelper.safeJsonParse(json);
    }
    this.data = json;
  }
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  get formattedJSON() {
    return StringHelper.safeJsonStringify(this, null, 4);
  }
  toJSON() {
    return (this.isTree ? this.rootNode.unfilteredChildren || this.rootNode.children || [] : this.allRecords).map((record) => record.toJSON());
  }
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs(configs);
    delete configs.project;
  }
  getInlineData(options) {
    const data = [];
    if (this.tree) {
      var _this$rootNode$childr;
      (_this$rootNode$childr = this.rootNode.children) === null || _this$rootNode$childr === void 0 ? void 0 : _this$rootNode$childr.forEach((r) => data.push(r.getCurrentConfig(options)));
    } else {
      this.forEach((r) => data.push(r.getCurrentConfig(options)));
    }
    return data;
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options), {
      state
    } = this;
    if (result) {
      var _result$modelClass;
      if (result.data) {
        result.data = this.getInlineData(options);
      }
      delete result.project;
      delete result.stm;
      delete result.asyncEvents;
      if (((_result$modelClass = result.modelClass) === null || _result$modelClass === void 0 ? void 0 : _result$modelClass.$meta.hierarchy[result.modelClass.$meta.hierarchy.length - 2]) === this.constructor.defaultConfig.modelClass) {
        delete result.modelClass;
      }
      if (!this.tree) {
        delete result.tree;
      }
      if (state) {
        Object.assign(result, state);
      }
    }
    return result;
  }
  forEach(fn2, thisObj = this, options) {
    const me = this, callback = (r, i) => {
      if (!r.isRoot && !r.isSpecialRow) {
        return fn2.call(thisObj, r, i);
      }
    };
    options = fixTraverseOptions(me, options);
    if (me.isTree) {
      if (me.isChained) {
        options = _objectSpread2(_objectSpread2({}, options), {}, {
          sorterFn: me.sorterFn
        });
      }
      me.rootNode.traverseWhile(callback, false, options);
    } else {
      const records = options.includeFilteredOutRecords ? me.storage.allValues : me.storage.values;
      if (me.isGrouped && options.includeCollapsedGroupRecords) {
        for (let i = 0; i < records.length; i++) {
          const record = records[i];
          if (record.groupChildren && record.meta.collapsed === true) {
            for (let j = 0; j < record.groupChildren.length; j++) {
              const rec = record.groupChildren[j];
              if (callback(rec, j) === false) {
                return;
              }
            }
          } else if (callback(record, i) === false) {
            return;
          }
        }
      } else {
        for (let i = 0; i < records.length; i++) {
          if (callback(records[i], i) === false) {
            return;
          }
        }
      }
    }
  }
  map(fn2, thisObj = this) {
    return this.storage.values.map(fn2, thisObj);
  }
  every(fn2, thisObj = this, ignoreFilters) {
    return this.storage[ignoreFilters ? "allValues" : "values"].every(fn2, thisObj);
  }
  reduce(fn2, initialValue = [], thisObj = this) {
    if (thisObj !== this) {
      fn2 = fn2.bind(thisObj);
    }
    return this.storage.values.reduce(fn2, initialValue, thisObj);
  }
  [Symbol.iterator]() {
    return this.storage.values[Symbol.iterator]();
  }
  traverse(fn2, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {
    const me = this;
    options = fixTraverseOptions(me, options);
    if (me.isTree) {
      if (typeof topNode === "boolean") {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }
      if (me.isChained) {
        const passedFn = fn2;
        fn2 = (node) => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }
      topNode.traverse(fn2, skipTopNode, options);
    } else {
      me.forEach((rec) => rec.traverse(fn2, false, options), me, options);
    }
  }
  traverseWhile(fn2, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {
    const me = this;
    options = fixTraverseOptions(me, options);
    if (me.isTree) {
      if (typeof topNode === "boolean") {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }
      if (me.isChained) {
        const passedFn = fn2;
        fn2 = (node) => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }
      topNode.traverseWhile(fn2, skipTopNode, options);
    } else {
      for (const record of me.storage) {
        if (record.traverse(fn2, false, options) === false) {
          break;
        }
      }
    }
  }
  getNext(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this, records = me.storage.values;
    let idx = me.indexOf(recordOrId);
    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }
    const record = records[idx + 1];
    if (skipSpecialRows && record && record.isSpecialRow) {
      return me.getNext(records[idx + 1], wrap, true);
    }
    return record;
  }
  getPrev(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this, records = me.storage.values;
    let idx = me.indexOf(recordOrId);
    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }
    const record = records[idx - 1];
    if (skipSpecialRows && record && record.isSpecialRow && idx > 0) {
      return me.getPrev(records[idx - 1], wrap, true);
    }
    return record;
  }
  getAdjacent(recordOrId, next = true, wrap = false, skipSpecialRows = false) {
    return next ? this.getNext(recordOrId, wrap, skipSpecialRows) : this.getPrev(recordOrId, wrap, skipSpecialRows);
  }
  getNextLeaf(recordOrId, wrap = false) {
    const me = this, records = me.leaves, record = me.getById(recordOrId);
    let idx = records.indexOf(record);
    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }
    return records[idx + 1];
  }
  getPrevLeaf(recordOrId, wrap = false) {
    const me = this, records = me.leaves, record = me.getById(recordOrId);
    let idx = records.indexOf(record);
    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }
    return records[idx - 1];
  }
  getAdjacentLeaf(recordOrId, next = true, wrap = false) {
    return next ? this.getNextLeaf(recordOrId, wrap) : this.getPrevLeaf(recordOrId, wrap);
  }
};
Store.initClass();
Store._$name = "Store";
var processParamEntry = (paramArray, entry) => {
  if (Array.isArray(entry[1])) {
    entry[1].forEach((value) => paramArray.push(encodeURIComponent(entry[0]) + "=" + encodeURIComponent(value)));
  } else {
    paramArray.push(encodeURIComponent(entry[0]) + "=" + encodeURIComponent(entry[1]));
  }
  return paramArray;
};
var immediatePromise$6 = Promise.resolve();
var prependZeros = (num) => {
  return String(num).padStart(2, "0");
};
var dateToString = (date2) => {
  return `${date2.getFullYear()}-${prependZeros(date2.getMonth() + 1)}-${prependZeros(date2.getDate())}T${prependZeros(date2.getHours())}:${prependZeros(date2.getMinutes())}:${prependZeros(date2.getSeconds())}.${date2.getMilliseconds()}`;
};
var AjaxStore = class extends Store {
  static get defaultConfig() {
    return {
      headers: null,
      fetchOptions: null,
      sendAsFormData: null,
      writeAllFields: null,
      parentIdParamName: "id",
      responseSuccessProperty: "success",
      responseDataProperty: "data",
      responseTotalProperty: "total",
      filterParamName: null,
      restfulFilter: false,
      sortParamName: null,
      pageParamName: null,
      pageStartParamName: null,
      pageSizeParamName: "pageSize",
      pageSize: 50,
      useRestfulMethods: null,
      httpMethods: {
        create: "POST",
        read: "GET",
        update: "PUT",
        delete: "DELETE"
      }
    };
  }
  static get configurable() {
    return {
      params: null
    };
  }
  afterConstruct(config) {
    super.afterConstruct(config);
    if (this.autoLoad) {
      this.load().catch(() => {
      });
    }
  }
  get isLoading() {
    return this._isLoading ? 2 : this.loadTriggerPromise ? 1 : false;
  }
  get isCommitting() {
    return Boolean(this.commitPromise);
  }
  set pageParamName(pageParamName) {
    if (this.tree) {
      throw new Error("Paging cannot be supported for tree stores");
    }
    if (this.pageStartParamName) {
      throw new Error("Configs pageStartParamName and pageParamName are mutually exclusive");
    }
    this._pageParamName = pageParamName;
  }
  get pageParamName() {
    return this._pageParamName;
  }
  set pageStartParamName(pageStartParamName) {
    if (this.tree) {
      throw new Error("Paging cannot be supported for tree stores");
    }
    if (this.pageParamName) {
      throw new Error("Configs pageParamName and pageStartParamName are mutually exclusive");
    }
    this._pageStartParamName = pageStartParamName;
  }
  get pageStartParamName() {
    return this._pageStartParamName;
  }
  get isPaged() {
    return this.pageParamName || this.pageStartParamName;
  }
  get allCount() {
    return "remoteTotal" in this ? this.remoteTotal : super.allCount;
  }
  get lastPage() {
    if (this.isPaged) {
      return Math.floor((this.allCount + this.pageSize - 1) / this.pageSize);
    }
  }
  buildQueryString(url, ...paramObjects) {
    const hasParamsInUrl = url.includes("?"), queryString = Object.entries(Object.assign({}, ...paramObjects)).reduce(processParamEntry, []).join("&");
    return queryString ? (hasParamsInUrl ? "&" : "?") + queryString : "";
  }
  async performSort(silent) {
    const me = this;
    if (me.remoteSort && !me.isRemoteDataLoading) {
      me.isRemoteDataLoading = true;
      const result = await me.internalLoad({}, "", (event) => {
        me.data = event.data;
        me.afterPerformSort(silent);
      });
      me.isRemoteDataLoading = false;
      return result;
    } else {
      super.performSort(silent);
    }
  }
  async performFilter(silent) {
    const me = this;
    if (me.remoteFilter) {
      var _me$loadingPromise;
      (_me$loadingPromise = me.loadingPromise) === null || _me$loadingPromise === void 0 ? void 0 : _me$loadingPromise.abort();
      me.isRemoteDataLoading = true;
      const oldCount = me.count, {
        filters
      } = me;
      me.currentPage = 1;
      const result = await me.internalLoad({}, "", (event) => {
        me.data = event.data;
        event = silent ? null : {
          action: "filter",
          filters,
          oldCount,
          records: me.storage.values
        };
        me.afterPerformFilter(event);
        me.trigger("refresh", event);
      });
      me.isRemoteDataLoading = false;
      return result;
    } else {
      super.performFilter(silent);
    }
  }
  encodeFilterParams(filters) {
    const result = [];
    for (const {
      property,
      operator,
      value,
      caseSensitive
    } of filters) {
      result.push({
        field: property,
        operator,
        value,
        caseSensitive
      });
    }
    return JSON.stringify(result, function(key, value) {
      return key === "" ? value : this[key] instanceof Date ? dateToString(this[key]) : value;
    });
  }
  encodeSorterParams(sorters) {
    return JSON.stringify(sorters.filter((sorter) => !sorter.sortFn).map((sorter) => sorter));
  }
  buildReadUrl() {
    const {
      readUrl
    } = this;
    if (this.restfulFilter && this.filters.count) {
      const url = readUrl.endsWith("/") ? readUrl : readUrl + "/";
      return url + this.filters.first.value;
    }
    return readUrl;
  }
  internalLoad(params, eventName, successFn, delay2 = 0) {
    params = ObjectHelper.assign({}, this.params, params);
    const me = this, url = me.buildReadUrl(), event = {
      action: "read" + eventName,
      params,
      url
    };
    if (!url) {
      throw new Error("No load url specified");
    }
    if (me.trigger("beforeLoad" + eventName, event) === false) {
      throw false;
    }
    me.loadArgs = [url, event, params, eventName, successFn];
    if (delay2 === false) {
      return new Promise((resolve, reject) => me.sendLoadRequest(resolve, reject));
    }
    return me.loadTriggerPromise || (me.loadTriggerPromise = new Promise((resolve, reject) => {
      me.setTimeout({
        delay: delay2,
        fn: "sendLoadRequest",
        args: [resolve, reject],
        cancelOutstanding: true
      });
    }));
  }
  async sendLoadRequest(resolve, reject) {
    const me = this, [url, event, params, eventName, successFn] = me.loadArgs;
    me.loadTriggerPromise = null;
    if (url) {
      me._isLoading = true;
      me.trigger(`load${eventName}Start`, event);
      me.trigger("beforeRequest", event);
      if (me.filterParamName && me.isFiltered) {
        params[me.filterParamName] = me.encodeFilterParams(me.filters.values);
      }
      if (me.remoteSort && me.isSorted) {
        params[me.sortParamName] = me.encodeSorterParams(me.groupers ? me.groupers.concat(me.sorters) : me.sorters);
      }
      if (me.isPaged) {
        if (!(me.pageParamName in params || me.pageStartParamName in params)) {
          const page = Math.min(me.currentPage || 1, me.allCount ? me.lastPage : Infinity);
          if (me.pageParamName) {
            params[me.pageParamName] = page;
          } else {
            params[me.pageStartParamName] = (page - 1) * me.pageSize;
          }
        }
        params[me.pageSizeParamName] = me.pageSize;
      }
      const options = {
        headers: me.headers,
        parseJson: true
      };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.read;
        if (event.body) {
          options.body = JSON.stringify(event.body);
        }
      }
      try {
        const promise = me.loadingPromise = AjaxHelper.get(event.url + me.buildQueryString(event.url, params), ObjectHelper.assign(options, me.fetchOptions)), response = await promise, data = response.parsedJson, isArray2 = Array.isArray(data), success2 = isArray2 || data && ObjectHelper.getPath(data, me.responseSuccessProperty) !== false, remoteTotal = isArray2 ? null : ObjectHelper.getPath(data, me.responseTotalProperty);
        if (me.isDestroyed) {
          return;
        }
        me.loadingPromise = null;
        me._isLoading = false;
        event.response = response;
        event.json = data;
        if (success2) {
          if (remoteTotal != null) {
            me.remoteTotal = parseInt(remoteTotal, 10);
          }
          if (me.isPaged) {
            if (me.remoteTotal >= 0) {
              const requestedPage = me.pageParamName ? params[me.pageParamName] : params[me.pageStartParamName] / me.pageSize + 1;
              me.currentPage = Math.min(requestedPage, me.lastPage);
            } else {
              throw new Error("A paged store must receive its responseTotalProperty in each data packet");
            }
          }
          event.data = isArray2 ? data : ObjectHelper.getPath(data, me.responseDataProperty);
          await successFn(event);
          !me.isDestroyed && me.trigger("load" + eventName, event);
          resolve(event);
        } else {
          Object.assign(event, {
            exception: true,
            exceptionType: "server",
            error: data === null || data === void 0 ? void 0 : data.error
          });
          !me.isDestroyed && me.trigger("exception", event);
          reject(event);
        }
        !me.isDestroyed && me.trigger("afterRequest", event);
      } catch (responseOrError) {
        me._isLoading = false;
        event.exception = true;
        if (responseOrError instanceof Response) {
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        !me.isDestroyed && me.trigger("exception", event);
        reject(event);
        !me.isDestroyed && me.trigger("afterRequest", event);
      }
    }
  }
  async load(params) {
    const me = this;
    if (me.isPaged) {
      return me.loadPage(me.currentPage || 1, params);
    } else {
      return me.internalLoad(params, "", (event) => {
        me.data = event.data;
      });
    }
  }
  async loadChildren(parentRecord) {
    return this.readUrl ? this.internalLoad({
      [this.parentIdParamName]: parentRecord.id
    }, "Children", (event) => {
      event.parentRecord = parentRecord;
      if (parentRecord.children.length) {
        parentRecord.clearChildren(true);
      }
      parentRecord.data[parentRecord.constructor.childrenField] = event.data;
      parentRecord.processChildren(parentRecord.stores);
    }, false) : this.immediatePromise;
  }
  async loadPage(page, params) {
    if (this.allCount) {
      page = Math.min(page, this.lastPage);
    }
    const me = this, pageParam = me.pageParamName ? {
      [me.pageParamName]: page
    } : {
      [me.pageStartParamName]: (page - 1) * me.pageSize
    };
    pageParam[me.pageSizeParamName] = me.pageSize;
    return me.internalLoad(ObjectHelper.assign(pageParam, params), "Page", (event) => {
      me.loadData(event.data, "pageLoad");
    });
  }
  async nextPage(params) {
    const me = this;
    return me.isPaged && me.currentPage !== me.lastPage ? me.loadPage(me.currentPage + 1, params) : immediatePromise$6;
  }
  async previousPage(params) {
    return this.isPaged && this.currentPage !== 1 ? this.loadPage(this.currentPage - 1, params) : immediatePromise$6;
  }
  async commit() {
    const me = this, {
      changes
    } = me, allPromises = [];
    if (me.commitPromise) {
      return false;
    }
    if (!changes) {
      if (me.modified.count) {
        me.modified.forEach((record) => record.clearChanges(true, false));
        me.modified.clear();
      }
      return immediatePromise$6;
    }
    if (me.trigger("beforeCommit", {
      changes
    }) !== false) {
      [...changes.added, ...changes.modified, ...changes.removed].forEach((record) => record.meta.committing = true);
      me.trigger("commitStart", {
        changes
      });
      const commitState = {
        action: "commit",
        exception: false,
        changes
      };
      let p = me.commitRemoved(commitState);
      if (p) {
        allPromises.push(p);
      }
      p = me.commitAdded(commitState);
      if (p) {
        allPromises.push(p);
      }
      p = me.commitModified(commitState);
      if (p) {
        allPromises.push(p);
      }
      if (!allPromises.length) {
        me.modified.forEach((r) => r.clearChanges(true, false));
        me.modified.clear();
        me.added.forEach((r) => r.clearChanges(true, false));
        me.added.clear();
        me.removed.clear();
        me.trigger("commit", {
          changes
        });
        return immediatePromise$6;
      }
      p = allPromises.length === 1 ? allPromises[0] : Promise.all(allPromises);
      return me.commitPromise = new Promise((resolve, reject) => {
        p.then(() => {
          me.commitPromise = null;
          if (commitState.exception) {
            me.trigger("exception", commitState);
            reject(commitState);
          } else {
            me.trigger("commit", {
              changes
            });
            resolve(commitState);
          }
        }).catch(() => {
          me.commitPromise = null;
          reject(commitState);
        });
      });
    }
  }
  doAutoCommit() {
    if (this.suspendCount <= 0) {
      this.commit().catch((commitState) => {
        const {
          response
        } = commitState;
        if (!(response && (response.ok && response.parsedJson || [500, 404].includes(response.status)))) {
          throw commitState;
        }
      });
    }
  }
  commitAdded(commitState) {
    const me = this, added = me.added, event = {
      action: "create",
      params: me.params
    };
    return added.count && me.createUrl ? new Promise((resolve) => {
      const toAdd = added.values.map((r) => r.persistableData);
      commitState.create = event;
      event.body = {
        data: toAdd
      };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("data", JSON.stringify(toAdd));
        dataToSend = formData;
      }
      const options = {
        headers: me.headers,
        parseJson: true
      }, url = me.createUrl + me.buildQueryString(me.createUrl, me.params);
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.create;
      }
      AjaxHelper.post(url, dataToSend, ObjectHelper.assign(options, me.fetchOptions)).then((response) => {
        const data = response.parsedJson, isArray2 = Array.isArray(data), success2 = isArray2 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success2) {
          me.processReturnedData(added.values, isArray2 ? data : ObjectHelper.getPath(data, me.responseDataProperty));
          added.clear();
          me.trigger("commitAdded");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          added.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          commitState.exceptionType = event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        added.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        me.trigger("exception", event);
        resolve(commitState);
        me.trigger("afterRequest", event);
      });
    }) : null;
  }
  commitModified(commitState) {
    const me = this, {
      modified
    } = me.changes, event = {
      action: "update",
      params: me.params
    }, result = modified.length && me.updateUrl ? new Promise((resolve) => {
      const modifications = modified.map((record) => {
        if (me.writeAllFields) {
          return record.persistableData;
        } else {
          return record.modificationDataToWrite;
        }
      }).filter((el) => !ObjectHelper.isEmpty(el));
      if (modifications.length === 0) {
        me.modified.clear();
        modified.forEach((r) => r.meta.committing = false);
        resolve();
        return;
      }
      commitState.update = event;
      event.body = {
        data: modifications
      };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("data", JSON.stringify(modifications));
        dataToSend = formData;
      }
      const options = {
        headers: me.headers,
        parseJson: true
      };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.update;
      }
      AjaxHelper.post(me.updateUrl + me.buildQueryString(me.updateUrl, me.params), dataToSend, ObjectHelper.assign(options, me.fetchOptions)).then((response) => {
        const data = response.parsedJson, isArray2 = Array.isArray(data), success2 = isArray2 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success2) {
          me.processReturnedData(modified, isArray2 ? data : ObjectHelper.getPath(data, me.responseDataProperty), true);
          me.modified.clear();
          me.trigger("commitModified");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          modified.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        modified.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        me.trigger("exception", event);
        resolve(commitState);
        me.trigger("afterRequest", event);
      });
    }) : null;
    if (!modified.length && me.modified.count) {
      me.modified.clear();
    }
    return result;
  }
  processReturnedData(localRecords, returnedData, isUpdating = false) {
    const me = this, Model2 = me.modelClass, idDataSource = Model2.fieldMap.id.dataSource;
    returnedData.forEach((recData, i) => {
      const record = localRecords[i];
      record.clearChanges(true, false);
      record.syncId(recData[idDataSource]);
      Object.assign(localRecords[i].data, Model2.processData(recData, isUpdating, me, record));
    });
  }
  commitRemoved(commitState) {
    const me = this, removed = me.removed, event = {
      action: "delete",
      params: me.params
    };
    return removed.count && me.deleteUrl ? new Promise((resolve) => {
      commitState.delete = event;
      event.body = {
        ids: removed.map((r) => r.id)
      };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("id", JSON.stringify(dataToSend.ids));
        dataToSend = formData;
      }
      const options = {
        headers: me.headers,
        parseJson: true
      };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.delete;
      }
      AjaxHelper.post(me.deleteUrl + me.buildQueryString(me.deleteUrl, me.params), dataToSend, ObjectHelper.assign(options, me.fetchOptions)).then((response) => {
        const data = response.parsedJson, isArray2 = Array.isArray(data), success2 = isArray2 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success2) {
          removed.forEach((record) => record.meta.committing = false);
          removed.clear();
          me.trigger("commitRemoved");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          removed.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        removed.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        me.trigger("exception", event);
        resolve(commitState);
        me.trigger("afterRequest", event);
      });
    }) : null;
  }
  get remoteFilter() {
    return Boolean(this.filterParamName || this.restfulFilter);
  }
  get remoteSort() {
    return Boolean(this.sortParamName);
  }
};
_defineProperty(AjaxStore, "$name", "AjaxStore");
AjaxStore._$name = "AjaxStore";
var DomDataStore = class {
  static get(element, key) {
    const result = element._domData || (element._domData = {});
    return key != null ? result[key] : result;
  }
  static remove(element, key) {
    const {
      _domData
    } = element, was = _domData === null || _domData === void 0 ? void 0 : _domData[key];
    _domData === null || _domData === void 0 ? true : delete _domData[key];
    return was;
  }
  static set(element, data, value) {
    if (arguments.length === 3) {
      (element._domData || (element._domData = {}))[data] = value;
    } else {
      element._domData = data;
    }
  }
  static assign(element, data) {
    Object.assign(element._domData || (element._domData = {}), data);
  }
};
DomDataStore._$name = "DomDataStore";
var throwAbstractMethodCall$1 = () => {
  throw new Error("Abstract method call!");
};
var ActionBase = class extends Base$1 {
  get type() {
    return this.constructor.name;
  }
  undo() {
    throwAbstractMethodCall$1();
  }
  redo() {
    throwAbstractMethodCall$1();
  }
};
ActionBase._$name = "ActionBase";
var throwAbstractMethodCall = () => {
  throw new Error("Abstract method call!");
};
var throwInvalidMethodCall = () => {
  throw new Error("Method cannot be called at this state!");
};
var StateBase = class extends Base$1 {
  canUndo(stm) {
    throwAbstractMethodCall();
  }
  canRedo(stm) {
    throwAbstractMethodCall();
  }
  onUndo(stm) {
    throwAbstractMethodCall();
  }
  onRedo(stm) {
    throwAbstractMethodCall();
  }
  onStartTransaction(stm) {
    throwAbstractMethodCall();
  }
  onStopTransaction(stm) {
    throwAbstractMethodCall();
  }
  onStopTransactionDelayed(stm) {
    throwAbstractMethodCall();
  }
  onRejectTransaction(stm) {
    throwAbstractMethodCall();
  }
  onEnable(stm) {
    throwAbstractMethodCall();
  }
  onDisable(stm) {
    throwAbstractMethodCall();
  }
  onAutoRecordOn(stm) {
    throwAbstractMethodCall();
  }
  onAutoRecordOff(stm) {
    throwAbstractMethodCall();
  }
  onResetQueue(stm) {
    throwAbstractMethodCall();
  }
  onModelUpdate(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelAdd(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelInsert(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelRemove(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelRemoveAll(stm) {
    throwAbstractMethodCall();
  }
  onModelInsertChild(stm) {
    throwAbstractMethodCall();
  }
  onModelRemoveChild(stm) {
    throwAbstractMethodCall();
  }
};
StateBase._$name = "StateBase";
var STATE_PROP = Symbol("STATE_PROP");
var STORES_PROP = Symbol("STORES_PROP");
var QUEUE_PROP = Symbol("QUEUE_PROP");
var POS_PROP = Symbol("POS_PROP");
var TRANSACTION_PROP = Symbol("TRANSACTION_PROP");
var TRANSACTION_TIMER_PROP = Symbol("TRANSACTION_TIMER_PROP");
var AUTO_RECORD_PROP = Symbol("AUTO_RECORD_PROP");
Object.freeze([STATE_PROP, STORES_PROP, QUEUE_PROP, POS_PROP, TRANSACTION_PROP, TRANSACTION_TIMER_PROP, AUTO_RECORD_PROP]);
var registry = /* @__PURE__ */ new Map();
var registerStmState = (name, state) => {
  registry.set(name, state);
};
var resolveStmState = (state) => {
  if (typeof state === "string") {
    state = registry.get(state);
  }
  return state;
};
var Registry = {
  registerStmState,
  resolveStmState
};
var resetQueue = (stm, options) => {
  const {
    undo,
    redo
  } = options;
  let newProps;
  if (undo && !redo) {
    newProps = {
      [QUEUE_PROP]: stm[QUEUE_PROP].slice(stm.position),
      [POS_PROP]: 0
    };
  } else if (redo && !undo) {
    newProps = {
      [QUEUE_PROP]: stm[QUEUE_PROP].slice(0, stm.position)
    };
  } else {
    newProps = {
      [QUEUE_PROP]: [],
      [POS_PROP]: 0
    };
  }
  return [newProps, () => {
    stm.notifyStoresAboutQueueReset(options);
  }];
};
var DisabledStateClass = class extends StateBase {
  canUndo() {
    return false;
  }
  canRedo() {
    return false;
  }
  onUndo() {
    throwInvalidMethodCall();
  }
  onRedo() {
    throwInvalidMethodCall();
  }
  onEnable(stm) {
    return stm.autoRecord ? "autoreadystate" : "readystate";
  }
  onDisable() {
    throwInvalidMethodCall();
  }
  onAutoRecordOn() {
    return {
      [AUTO_RECORD_PROP]: true
    };
  }
  onAutoRecordOff() {
    return {
      [AUTO_RECORD_PROP]: false
    };
  }
  onStartTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onRejectTransaction() {
    throwInvalidMethodCall();
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onModelUpdate() {
  }
  onModelInsertChild() {
  }
  onModelRemoveChild() {
  }
  onStoreModelAdd() {
  }
  onStoreModelInsert() {
  }
  onStoreModelRemove() {
  }
  onStoreRemoveAll() {
  }
};
var DisabledState = new DisabledStateClass();
Registry.registerStmState("disabledstate", DisabledState);
var ACTION_QUEUE_PROP = Symbol("ACTION_QUEUE_PROP");
var Transaction = class extends Base$1 {
  get defaultConfig() {
    return {
      title: null
    };
  }
  construct(...args) {
    this[ACTION_QUEUE_PROP] = [];
    super.construct(...args);
  }
  get queue() {
    return this[ACTION_QUEUE_PROP].slice(0);
  }
  get length() {
    return this[ACTION_QUEUE_PROP].length;
  }
  addAction(action) {
    this[ACTION_QUEUE_PROP].push(action);
  }
  undo() {
    const queue = this[ACTION_QUEUE_PROP];
    for (let i = queue.length - 1; i >= 0; --i) {
      queue[i].undo();
    }
  }
  redo() {
    const queue = this[ACTION_QUEUE_PROP];
    for (let i = 0, len = queue.length; i < len; ++i) {
      queue[i].redo();
    }
  }
};
Transaction._$name = "Transaction";
var ReadyStateClass = class extends StateBase {
  canUndo(stm) {
    return 0 < stm.position && stm.position <= stm.length;
  }
  canRedo(stm) {
    return 0 <= stm.position && stm.position < stm.length;
  }
  onUndo(stm, steps) {
    let curPos = stm.position;
    const queue = stm[QUEUE_PROP], newPos = Math.max(0, curPos - steps), next = () => {
      stm.notifyStoresAboutStateRestoringStart();
      const undoneTransactions = [];
      while (curPos !== newPos) {
        const transaction = queue[--curPos];
        transaction.undo();
        undoneTransactions.push(transaction);
      }
      return [stm.autoRecord ? "autoreadystate" : "readystate", () => {
        stm.notifyStoresAboutStateRestoringStop({
          cause: "undo",
          transactions: undoneTransactions
        });
      }];
    };
    return [{
      [STATE_PROP]: "restoringstate",
      [POS_PROP]: newPos
    }, next];
  }
  onRedo(stm, steps) {
    let curPos = stm.position;
    const queue = stm[QUEUE_PROP], newPos = Math.min(queue.length, curPos + steps);
    const next = () => {
      stm.notifyStoresAboutStateRestoringStart();
      const redoneTransactions = [];
      do {
        const transaction = queue[curPos++];
        transaction.redo();
        redoneTransactions.push(transaction);
      } while (curPos !== newPos);
      return [stm.autoRecord ? "autoreadystate" : "readystate", () => {
        stm.notifyStoresAboutStateRestoringStop({
          cause: "redo",
          transactions: redoneTransactions
        });
      }];
    };
    return [{
      [STATE_PROP]: "restoringstate",
      [POS_PROP]: newPos
    }, next];
  }
  onEnable() {
    throwInvalidMethodCall();
  }
  onDisable() {
    return "disabledstate";
  }
  onAutoRecordOn() {
    return {
      [STATE_PROP]: "autoreadystate",
      [AUTO_RECORD_PROP]: true
    };
  }
  onAutoRecordOff() {
    throwInvalidMethodCall();
  }
  onStartTransaction(stm, title) {
    const transaction = new Transaction({
      title
    });
    return [{
      [STATE_PROP]: "recordingstate",
      [TRANSACTION_PROP]: transaction
    }, () => {
      stm.notifyStoresAboutStateRecordingStart(transaction);
    }];
  }
  onStopTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onRejectTransaction() {
    throwInvalidMethodCall();
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onModelUpdate() {
  }
  onModelInsertChild() {
  }
  onModelRemoveChild() {
  }
  onStoreModelAdd() {
  }
  onStoreModelInsert() {
  }
  onStoreModelRemove() {
  }
  onStoreRemoveAll() {
  }
};
var ReadyState = new ReadyStateClass();
Registry.registerStmState("readystate", ReadyState);
var RecordingStateClass = class extends StateBase {
  canUndo() {
    return false;
  }
  canRedo() {
    return false;
  }
  onEnable() {
  }
  onDisable(stm) {
    const transaction = stm[TRANSACTION_PROP];
    stm.notifyStoresAboutStateRecordingStop(transaction, {
      disabled: true
    });
    return {
      [STATE_PROP]: "disabledstate",
      [TRANSACTION_PROP]: null
    };
  }
  onAutoRecordOn(stm) {
    return [{
      [STATE_PROP]: "autorecordingstate",
      [AUTO_RECORD_PROP]: true
    }, () => {
      stm.stopTransactionDelayed();
    }];
  }
  onAutoRecordOff() {
    throwInvalidMethodCall();
  }
  onStartTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransaction(stm, title) {
    const transaction = stm[TRANSACTION_PROP], queue = stm[QUEUE_PROP];
    let position = stm[POS_PROP];
    if (transaction.length) {
      if (!transaction.title && !title && stm.getTransactionTitle) {
        transaction.title = stm.getTransactionTitle(transaction);
      } else if (title) {
        transaction.title = title;
      }
      queue[position] = transaction;
      queue.length = ++position;
    }
    return [{
      [STATE_PROP]: "readystate",
      [POS_PROP]: position,
      [TRANSACTION_PROP]: null
    }, () => {
      stm.notifyStoresAboutStateRecordingStop(transaction, {
        stop: true
      });
    }];
  }
  onRejectTransaction(stm) {
    const transaction = stm[TRANSACTION_PROP];
    return [{
      [STATE_PROP]: "restoringstate",
      [TRANSACTION_PROP]: null
    }, () => {
      if (transaction.length) {
        transaction.undo();
      }
      return ["readystate", () => {
        stm.notifyStoresAboutStateRecordingStop(transaction, {
          rejected: true
        });
      }];
    }];
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onModelUpdate(stm, model, newData, oldData, isInitialUserAction) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelUpdateAction(model, newData, oldData, isInitialUserAction));
  }
  onModelInsertChild(stm, parentModel, index, childModel, previousParent, previousIndex) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelInsertChildAction(parentModel, index, childModel, previousParent, previousIndex));
  }
  onModelRemoveChild(stm, parentModel, childModels, context) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelRemoveChildAction(parentModel, childModels, context));
  }
  onStoreModelAdd(stm, store, models, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelAddAction(store, models, silent));
  }
  onStoreModelInsert(stm, store, index, models, context, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelInsertAction(store, index, models, context, silent));
  }
  onStoreModelRemove(stm, store, models, context, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelRemoveAction(store, models, context, silent));
  }
  onStoreRemoveAll(stm, store, allRecords, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreRemoveAllAction(store, allRecords, silent));
  }
};
var RecordingState = new RecordingStateClass();
Registry.registerStmState("recordingstate", RecordingState);
var RestoringStateClass = class extends StateBase {
  static get $name() {
    return "RestoringStateClass";
  }
  canUndo() {
    return false;
  }
  canRedo() {
    return false;
  }
  onUndo() {
    throwInvalidMethodCall();
  }
  onRedo() {
    throwInvalidMethodCall();
  }
  onEnable() {
    throwInvalidMethodCall();
  }
  onDisable() {
    throwInvalidMethodCall();
  }
  onAutoRecordOn() {
    return {
      [AUTO_RECORD_PROP]: true
    };
  }
  onAutoRecordOff() {
    return {
      [AUTO_RECORD_PROP]: false
    };
  }
  onStartTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onRejectTransaction() {
    throwInvalidMethodCall();
  }
  onQueueReset() {
    throwInvalidMethodCall();
  }
  onModelUpdate() {
  }
  onModelInsertChild() {
  }
  onModelRemoveChild() {
  }
  onStoreModelAdd() {
  }
  onStoreModelInsert() {
  }
  onStoreModelRemove() {
  }
  onStoreRemoveAll() {
  }
};
var RestoringState = new RestoringStateClass();
Registry.registerStmState("restoringstate", RestoringState);
var AutoReadyStateClass = class extends ReadyStateClass {
  onAutoRecordOn() {
    throwInvalidMethodCall();
  }
  onAutoRecordOff() {
    return {
      [STATE_PROP]: "readystate",
      [AUTO_RECORD_PROP]: false
    };
  }
  onStartTransaction(stm, title) {
    const transaction = new Transaction({
      title
    });
    return [{
      [STATE_PROP]: "autorecordingstate",
      [TRANSACTION_PROP]: transaction
    }, () => {
      stm.notifyStoresAboutStateRecordingStart(transaction);
      stm.stopTransactionDelayed();
    }];
  }
  onModelUpdate(stm, model, newData, oldData) {
    stm.startTransaction();
    stm.onModelUpdate(model, newData, oldData);
  }
  onModelInsertChild(stm, parentModel, index, childModels, context) {
    stm.startTransaction();
    stm.onModelInsertChild(parentModel, index, childModels, context);
  }
  onModelRemoveChild(stm, parentModel, childModels, context) {
    stm.startTransaction();
    stm.onModelRemoveChild(parentModel, childModels, context);
  }
  onStoreModelAdd(stm, store, models, silent) {
    stm.startTransaction();
    stm.onStoreModelAdd(store, models, silent);
  }
  onStoreModelInsert(stm, store, index, models, context, silent) {
    stm.startTransaction();
    stm.onStoreModelInsert(store, index, models, context, silent);
  }
  onStoreModelRemove(stm, store, models, context, silent) {
    stm.startTransaction();
    stm.onStoreModelRemove(store, models, context, silent);
  }
  onStoreRemoveAll(stm, store, allRecords, silent) {
    stm.startTransaction();
    stm.onStoreRemoveAll(store, allRecords, silent);
  }
};
var AutoReadyState = new AutoReadyStateClass();
Registry.registerStmState("autoreadystate", AutoReadyState);
var AutoRecordingStateClass = class extends RecordingStateClass.mixin(Delayable) {
  onDisable(stm) {
    const transaction = stm[TRANSACTION_PROP], timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    stm.notifyStoresAboutStateRecordingStop(transaction, {
      disabled: true
    });
    return {
      [STATE_PROP]: "disabledstate",
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    };
  }
  onAutoRecordOn(stm) {
    throwInvalidMethodCall();
  }
  onAutoRecordOff(stm) {
    const timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    return {
      [STATE_PROP]: "recordingstate",
      [AUTO_RECORD_PROP]: false,
      [TRANSACTION_TIMER_PROP]: null
    };
  }
  onStopTransaction(stm, title) {
    const transaction = stm[TRANSACTION_PROP], timer = stm[TRANSACTION_TIMER_PROP], queue = stm[QUEUE_PROP];
    let position = stm[POS_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    if (transaction.length) {
      if (!transaction.title && !title && stm.getTransactionTitle) {
        transaction.title = stm.getTransactionTitle(transaction);
      } else if (title) {
        transaction.title = title;
      }
      queue[position] = transaction;
      queue.length = ++position;
    }
    return [{
      [STATE_PROP]: "autoreadystate",
      [POS_PROP]: position,
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    }, () => {
      stm.notifyStoresAboutStateRecordingStop(transaction, {
        stop: true
      });
    }];
  }
  onStopTransactionDelayed(stm) {
    let timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    timer = this.setTimeout(() => {
      stm.stopTransaction();
    }, stm.autoRecordTransactionStopTimeout);
    return {
      [STATE_PROP]: AutoRecordingState,
      [TRANSACTION_TIMER_PROP]: timer
    };
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onRejectTransaction(stm) {
    const transaction = stm[TRANSACTION_PROP], timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    return [{
      [STATE_PROP]: "restoringstate",
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    }, () => {
      if (transaction.length) {
        transaction.undo();
      }
      return ["autoreadystate", () => {
        stm.notifyStoresAboutStateRecordingStop(transaction, {
          rejected: true
        });
      }];
    }];
  }
  onModelUpdate(stm, ...rest) {
    super.onModelUpdate(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onModelInsertChild(stm, ...rest) {
    super.onModelInsertChild(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onModelRemoveChild(stm, ...rest) {
    super.onModelRemoveChild(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreModelAdd(stm, ...rest) {
    super.onStoreModelAdd(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreModelInsert(stm, ...rest) {
    super.onStoreModelInsert(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreModelRemove(stm, ...rest) {
    super.onStoreModelRemove(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreRemoveAll(stm, ...rest) {
    super.onStoreRemoveAll(stm, ...rest);
    stm.stopTransactionDelayed();
  }
};
var AutoRecordingState = new AutoRecordingStateClass();
Registry.registerStmState("autorecordingstate", AutoRecordingState);
var MODEL_PROP = Symbol("MODEL_PROP");
var NEW_DATA_PROP = Symbol("NEW_DATA_PROP");
var OLD_DATA_PROP = Symbol("OLD_DATA_PROP");
var UpdateAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      model: void 0,
      newData: void 0,
      oldData: void 0,
      isInitialUserAction: false
    };
  }
  get type() {
    return "UpdateAction";
  }
  get model() {
    return this[MODEL_PROP];
  }
  set model(value) {
    this[MODEL_PROP] = value;
  }
  get newData() {
    return this[NEW_DATA_PROP];
  }
  set newData(value) {
    this[NEW_DATA_PROP] = _objectSpread2({}, value);
  }
  get oldData() {
    return this[OLD_DATA_PROP];
  }
  set oldData(value) {
    this[OLD_DATA_PROP] = _objectSpread2({}, value);
  }
  undo() {
    const {
      model,
      oldData
    } = this;
    if (model.$) {
      Object.assign(model, oldData);
    }
    model.set(oldData, null, null, null, true);
  }
  redo() {
    const {
      model,
      newData
    } = this;
    if (model.$) {
      Object.assign(model, newData);
    }
    model.set(newData, null, null, null, true);
  }
};
UpdateAction._$name = "UpdateAction";
var PARENT_MODEL_PROP$1 = Symbol("PARENT_MODEL_PROP");
var CHILD_MODELS_PROP$1 = Symbol("CHILD_MODELS_PROP");
var INSERT_INDEX_PROP$1 = Symbol("INSERT_INDEX_PROP");
var CONTEXT_PROP$3 = Symbol("CONTEXT_PROP");
var InsertChildAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      parentModel: void 0,
      childModels: void 0,
      insertIndex: void 0,
      context: void 0
    };
  }
  get type() {
    return "InsertChildAction";
  }
  get parentModel() {
    return this[PARENT_MODEL_PROP$1];
  }
  set parentModel(model) {
    this[PARENT_MODEL_PROP$1] = model;
  }
  get childModels() {
    return this[CHILD_MODELS_PROP$1];
  }
  set childModels(models) {
    this[CHILD_MODELS_PROP$1] = models.slice(0);
  }
  get insertIndex() {
    return this[INSERT_INDEX_PROP$1];
  }
  set insertIndex(index) {
    this[INSERT_INDEX_PROP$1] = index;
  }
  get context() {
    return this[CONTEXT_PROP$3];
  }
  set context(ctx) {
    this[CONTEXT_PROP$3] = ctx;
  }
  undo() {
    const {
      parentModel,
      context,
      childModels
    } = this;
    childModels.sort((lhs, rhs) => {
      const {
        lhsParent,
        lhsIndex
      } = context.get(lhs) || {}, {
        rhsParent,
        rhsIndex
      } = context.get(rhs) || {};
      return lhsParent && lhsParent === rhsParent ? lhsIndex - rhsIndex : 0;
    });
    childModels.forEach((m) => {
      const {
        parent,
        index
      } = context.get(m) || {};
      if (parent) {
        if (parent === parentModel) {
          let adjustedIndex;
          adjustedIndex = index > m.parentIndex ? index + 1 : index;
          adjustedIndex = index === parent.children.length - 1 ? null : adjustedIndex;
          const insertBefore = parent.children[adjustedIndex];
          parent.insertChild(m, insertBefore);
        } else {
          parent.insertChild(m, parent.children[index]);
        }
      } else {
        parentModel.removeChild(m);
      }
    });
  }
  redo() {
    const {
      parentModel,
      insertIndex,
      childModels
    } = this, insertBefore = parentModel.children[insertIndex];
    parentModel.insertChild(childModels, insertBefore);
  }
};
InsertChildAction._$name = "InsertChildAction";
var PARENT_MODEL_PROP = Symbol("PARENT_MODEL_PROP");
var CHILD_MODELS_PROP = Symbol("CHILD_MODELS_PROP");
var CONTEXT_PROP$2 = Symbol("CONTEXT_PROP");
var RemoveChildAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      parentModel: void 0,
      childModels: void 0,
      context: void 0
    };
  }
  get type() {
    return "RemoveChildAction";
  }
  get parentModel() {
    return this[PARENT_MODEL_PROP];
  }
  set parentModel(model) {
    this[PARENT_MODEL_PROP] = model;
  }
  get childModels() {
    return this[CHILD_MODELS_PROP];
  }
  set childModels(models) {
    this[CHILD_MODELS_PROP] = models.slice(0);
  }
  get context() {
    return this[CONTEXT_PROP$2];
  }
  set context(ctx) {
    this[CONTEXT_PROP$2] = ctx;
  }
  undo() {
    const {
      parentModel,
      context,
      childModels
    } = this;
    childModels.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs), rhsIndex = context.get(rhs);
      return lhsIndex - rhsIndex;
    });
    childModels.forEach((m) => {
      parentModel.insertChild(m, context.get(m));
    });
  }
  redo() {
    this.parentModel.removeChild(this.childModels);
  }
};
RemoveChildAction._$name = "RemoveChildAction";
var STORE_PROP$3 = Symbol("STORE_PROP");
var MODEL_LIST_PROP$2 = Symbol("MODEL_LIST_PROP");
var AddAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      store: void 0,
      modelList: void 0,
      silent: false
    };
  }
  get type() {
    return "AddAction";
  }
  get store() {
    return this[STORE_PROP$3];
  }
  set store(store) {
    this[STORE_PROP$3] = store;
  }
  get modelList() {
    return this[MODEL_LIST_PROP$2];
  }
  set modelList(list) {
    this[MODEL_LIST_PROP$2] = list.slice(0);
  }
  undo() {
    this.store.remove(this.modelList, this.silent);
  }
  redo() {
    this.store.add(this.modelList, this.silent);
  }
};
AddAction._$name = "AddAction";
var STORE_PROP$2 = Symbol("STORE_PROP");
var MODEL_LIST_PROP$1 = Symbol("MODEL_LIST_PROP");
var INSERT_INDEX_PROP = Symbol("INSERT_INDEX_PROP");
var CONTEXT_PROP$1 = Symbol("CONTEXT_PROP");
var InsertAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      store: void 0,
      modelList: void 0,
      insertIndex: void 0,
      context: void 0,
      silent: false
    };
  }
  get type() {
    return "InsertAction";
  }
  get store() {
    return this[STORE_PROP$2];
  }
  set store(store) {
    this[STORE_PROP$2] = store;
  }
  get modelList() {
    return this[MODEL_LIST_PROP$1];
  }
  set modelList(list) {
    this[MODEL_LIST_PROP$1] = list.slice(0);
  }
  get insertIndex() {
    return this[INSERT_INDEX_PROP];
  }
  set insertIndex(index) {
    this[INSERT_INDEX_PROP] = index;
  }
  get context() {
    return this[CONTEXT_PROP$1];
  }
  set context(context) {
    this[CONTEXT_PROP$1] = context;
  }
  undo() {
    const {
      store,
      modelList,
      context,
      silent
    } = this;
    modelList.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs), rhsIndex = context.get(rhs);
      return lhsIndex !== void 0 && rhsIndex !== void 0 ? lhsIndex - rhsIndex : 0;
    });
    modelList.forEach((m) => {
      const index = context.get(m);
      m._undoingInsertion = true;
      if (index !== void 0) {
        store.insert(index, m, silent);
      } else {
        store.remove(m, silent);
      }
      m._undoingInsertion = false;
    });
  }
  redo() {
    const me = this;
    me.store.insert(me.insertIndex, me.modelList, me.silent);
  }
};
InsertAction._$name = "InsertAction";
var STORE_PROP$1 = Symbol("STORE_PROP");
var MODEL_LIST_PROP = Symbol("MODEL_LIST_PROP");
var CONTEXT_PROP = Symbol("CONTEXT_PROP");
var RemoveAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      store: void 0,
      modelList: void 0,
      context: void 0,
      silent: false
    };
  }
  get type() {
    return "RemoveAction";
  }
  get store() {
    return this[STORE_PROP$1];
  }
  set store(store) {
    this[STORE_PROP$1] = store;
  }
  get modelList() {
    return this[MODEL_LIST_PROP];
  }
  set modelList(list) {
    this[MODEL_LIST_PROP] = list.slice(0);
  }
  get context() {
    return this[CONTEXT_PROP];
  }
  set context(context) {
    this[CONTEXT_PROP] = context;
  }
  undo() {
    const {
      store,
      context,
      modelList,
      silent
    } = this;
    modelList.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs), rhsIndex = context.get(rhs);
      return lhsIndex - rhsIndex;
    });
    modelList.forEach((m) => {
      const index = context.get(m);
      store.insert(index, m, silent);
    });
  }
  redo() {
    this.store.remove(this.modelList, this.silent);
  }
};
RemoveAction._$name = "RemoveAction";
var STORE_PROP = Symbol("STORE_PROP");
var ALL_RECORDS_PROP = Symbol("ALL_RECORDS_PROP");
var RemoveAllAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      store: void 0,
      allRecords: void 0,
      silent: false
    };
  }
  get type() {
    return "RemoveAllAction";
  }
  get store() {
    return this[STORE_PROP];
  }
  set store(store) {
    this[STORE_PROP] = store;
  }
  get allRecords() {
    return this[ALL_RECORDS_PROP];
  }
  set allRecords(records) {
    this[ALL_RECORDS_PROP] = records.slice(0);
  }
  undo() {
    const {
      store,
      allRecords,
      silent
    } = this;
    store.add(allRecords, silent);
  }
  redo() {
    this.store.removeAll(this.silent);
  }
};
RemoveAllAction._$name = "RemoveAllAction";
var makeModelUpdateAction = (model, newData, oldData, isInitialUserAction) => {
  return new UpdateAction({
    model,
    newData,
    oldData,
    isInitialUserAction
  });
};
var makeModelInsertChildAction = (parentModel, insertIndex, childModels, context) => {
  return new InsertChildAction({
    parentModel,
    childModels,
    insertIndex,
    context
  });
};
var makeModelRemoveChildAction = (parentModel, childModels, context) => {
  return new RemoveChildAction({
    parentModel,
    childModels,
    context
  });
};
var makeStoreModelAddAction = (store, modelList, silent) => {
  return new AddAction({
    store,
    modelList,
    silent
  });
};
var makeStoreModelInsertAction = (store, insertIndex, modelList, context, silent) => {
  return new InsertAction({
    store,
    insertIndex,
    modelList,
    context,
    silent
  });
};
var makeStoreModelRemoveAction = (store, modelList, context, silent) => {
  return new RemoveAction({
    store,
    modelList,
    context,
    silent
  });
};
var makeStoreRemoveAllAction = (store, allRecords, silent) => {
  return new RemoveAllAction({
    store,
    allRecords,
    silent
  });
};
var stateTransition = (stm, event, ...args) => {
  const oldState = stm.state, newState = event.call(stm[STATE_PROP], stm, ...args);
  if (typeof newState === "string") {
    stm[STATE_PROP] = Registry.resolveStmState(newState);
  } else if (newState instanceof StateBase) {
    stm[STATE_PROP] = newState;
  } else if (Array.isArray(newState)) {
    const [state, next] = newState;
    if (typeof state === "string") {
      stm[STATE_PROP] = Registry.resolveStmState(state);
    } else if (state instanceof StateBase) {
      stm[STATE_PROP] = state;
    } else if (state && typeof state === "object") {
      stm = Object.assign(stm, state);
      stm[STATE_PROP] = Registry.resolveStmState(stm[STATE_PROP]);
    }
    if (typeof next === "function") {
      stateTransition(stm, next, ...args);
    }
  } else if (newState && typeof newState === "object") {
    stm = Object.assign(stm, newState);
    stm[STATE_PROP] = Registry.resolveStmState(stm[STATE_PROP]);
  }
  if (oldState !== ReadyState && oldState !== AutoReadyState && newState !== ReadyState && newState !== AutoReadyState) {
    stm.trigger("ready");
  }
};
var StateTrackingManager = class extends Events(Base$1) {
  static get defaultConfig() {
    return {
      disabled: true,
      autoRecord: false,
      autoRecordTransactionStopTimeout: 100,
      makeModelUpdateAction,
      makeModelInsertChildAction,
      makeModelRemoveChildAction,
      makeStoreModelAddAction,
      makeStoreModelInsertAction,
      makeStoreModelRemoveAction,
      makeStoreRemoveAllAction,
      getTransactionTitle: null
    };
  }
  construct(...args) {
    Object.assign(this, {
      [STATE_PROP]: ReadyState,
      [STORES_PROP]: [],
      [QUEUE_PROP]: [],
      [POS_PROP]: 0,
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null,
      [AUTO_RECORD_PROP]: false
    });
    super.construct(...args);
  }
  get state() {
    return this[STATE_PROP];
  }
  get position() {
    return this[POS_PROP];
  }
  get length() {
    return this[QUEUE_PROP].length;
  }
  get stores() {
    return Array.from(this[STORES_PROP]);
  }
  hasStore(store) {
    return this[STORES_PROP].includes(store);
  }
  addStore(store) {
    if (!this.hasStore(store)) {
      this[STORES_PROP].push(store);
      store.stm = this;
    }
  }
  removeStore(store) {
    if (this.hasStore(store)) {
      this[STORES_PROP] = this[STORES_PROP].filter((s) => s !== store);
      store.stm = null;
    }
  }
  forEachStore(fn2) {
    this[STORES_PROP].forEach((s) => fn2(s, s.id));
  }
  get disabled() {
    return this.state === DisabledState;
  }
  set disabled(val) {
    const me = this;
    if (me.disabled !== val) {
      if (val) {
        stateTransition(me, me.state.onDisable, me);
      } else {
        stateTransition(me, me.state.onEnable, me);
      }
      me.trigger("stmDisabled", {
        disabled: val
      });
      me.trigger("disabled", {
        disabled: val
      });
    }
  }
  get enabled() {
    return !this.disabled;
  }
  enable() {
    this.disabled = false;
  }
  disable() {
    this.disabled = true;
  }
  get isReady() {
    return this.state === ReadyState || this.state === AutoReadyState;
  }
  waitForReadiness() {
    return this.await("ready", false);
  }
  get isRecording() {
    return this.state === RecordingState || this.state === AutoRecordingState;
  }
  get autoRecord() {
    return this[AUTO_RECORD_PROP];
  }
  set autoRecord(value) {
    const me = this;
    if (me.autoRecord != value) {
      if (value) {
        stateTransition(me, me.state.onAutoRecordOn, me);
      } else {
        stateTransition(me, me.state.onAutoRecordOff, me);
      }
    }
  }
  startTransaction(title = null) {
    stateTransition(this, this.state.onStartTransaction, title);
  }
  stopTransaction(title = null) {
    stateTransition(this, this.state.onStopTransaction, title);
  }
  stopTransactionDelayed() {
    stateTransition(this, this.state.onStopTransactionDelayed);
  }
  rejectTransaction() {
    stateTransition(this, this.state.onRejectTransaction);
  }
  get transaction() {
    return this[TRANSACTION_PROP];
  }
  get queue() {
    return this[QUEUE_PROP].map((t) => t.title);
  }
  get isRestoring() {
    return this.state === RestoringState;
  }
  get canUndo() {
    return this.state.canUndo(this);
  }
  get canRedo() {
    return this.state.canRedo(this);
  }
  async undo(steps = 1) {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    stateTransition(this, this.state.onUndo, steps);
  }
  async undoAll() {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    this.undo(this.length);
  }
  async redo(steps = 1) {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    stateTransition(this, this.state.onRedo, steps);
  }
  async redoAll() {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    this.redo(this.length);
  }
  resetQueue(options = {
    undo: true,
    redo: true
  }) {
    stateTransition(this, this.state.onResetQueue, options);
  }
  resetUndoQueue() {
    this.resetQueue({
      undo: true
    });
  }
  resetRedoQueue() {
    this.resetQueue({
      redo: true
    });
  }
  notifyStoresAboutStateRecordingStart(transaction) {
    this.forEachStore((store) => {
      var _store$onStmRecording;
      return (_store$onStmRecording = store.onStmRecordingStart) === null || _store$onStmRecording === void 0 ? void 0 : _store$onStmRecording.call(store, this, transaction);
    });
    this.trigger("recordingStart", {
      stm: this,
      transaction
    });
  }
  notifyStoresAboutStateRecordingStop(transaction, reason) {
    this.forEachStore((store) => {
      var _store$onStmRecording2;
      return (_store$onStmRecording2 = store.onStmRecordingStop) === null || _store$onStmRecording2 === void 0 ? void 0 : _store$onStmRecording2.call(store, this, transaction, reason);
    });
    this.trigger("recordingStop", {
      stm: this,
      transaction,
      reason
    });
  }
  notifyStoresAboutStateRestoringStart() {
    this.forEachStore((store) => {
      var _store$onStmRestoring;
      return (_store$onStmRestoring = store.onStmRestoringStart) === null || _store$onStmRestoring === void 0 ? void 0 : _store$onStmRestoring.call(store, this);
    });
    this.trigger("restoringStart", {
      stm: this
    });
  }
  notifyStoresAboutStateRestoringStop({
    cause,
    transactions
  }) {
    this.forEachStore((store) => {
      var _store$onStmRestoring2;
      return (_store$onStmRestoring2 = store.onStmRestoringStop) === null || _store$onStmRestoring2 === void 0 ? void 0 : _store$onStmRestoring2.call(store, this);
    });
    this.trigger("restoringStop", {
      stm: this,
      cause,
      transactions
    });
  }
  notifyStoresAboutQueueReset(options) {
    this.forEachStore((store) => {
      var _store$onStmQueueRese;
      return (_store$onStmQueueRese = store.onStmQueueReset) === null || _store$onStmQueueRese === void 0 ? void 0 : _store$onStmQueueRese.call(store, this, options);
    });
    this.trigger("queueReset", {
      stm: this,
      options
    });
  }
  onModelUpdate(model, newData, oldData, isInitialUserAction) {
    stateTransition(this, this.state.onModelUpdate, model, newData, oldData, isInitialUserAction);
  }
  onModelInsertChild(parentModel, index, childModels, context) {
    stateTransition(this, this.state.onModelInsertChild, parentModel, index, childModels, context);
  }
  onModelRemoveChild(parentModel, childModels, context) {
    stateTransition(this, this.state.onModelRemoveChild, parentModel, childModels, context);
  }
  onStoreModelAdd(store, models, silent) {
    stateTransition(this, this.state.onStoreModelAdd, store, models, silent);
  }
  onStoreModelInsert(store, index, models, context, silent) {
    stateTransition(this, this.state.onStoreModelInsert, store, index, models, context, silent);
  }
  onStoreModelRemove(store, models, context, silent) {
    stateTransition(this, this.state.onStoreModelRemove, store, models, context, silent);
  }
  onStoreRemoveAll(store, allRecords, silent) {
    stateTransition(this, this.state.onStoreRemoveAll, store, allRecords, silent);
  }
  onUndoKeyPress(event) {
    const me = this;
    if (me.enabled) {
      if (event.shiftKey) {
        if (me.canRedo) {
          event.preventDefault();
          me.redo();
        }
      } else if (me.canUndo) {
        event.preventDefault();
        me.undo();
      }
    }
  }
  stash() {
    if (this.transaction) {
      this.stashedTransaction = this.transaction;
      this.rejectTransaction();
    }
  }
  applyStash() {
    if (this.stashedTransaction) {
      this.startTransaction(this.stashedTransaction.title);
      this.stashedTransaction.redo();
      delete this.stashedTransaction;
    }
  }
};
StateTrackingManager._$name = "StateTrackingManager";
var arraySlice = Array.prototype.slice;
var emptyArray$9 = Object.freeze([]);
var emptyObject$a = Object.freeze({});
var htmlRe = /[&<]/;
var {
  getPrototypeOf
} = Object;
var {
  toString
} = Object.prototype;
var {
  isEqual,
  isObject
} = ObjectHelper;
var checkEqualityIgnore = {
  parent: 1,
  elementData: 1,
  ns: 1,
  syncOptions: 1
};
var makeCheckEqualityOptions = () => ({
  ignore: checkEqualityIgnore,
  refsFound: /* @__PURE__ */ new Set()
});
var isClass = {
  class: 1,
  className: 1,
  classname: 1
};
var simpleTypes = {
  bigint: 1,
  boolean: 1,
  function: 1,
  number: 1,
  string: 1,
  symbol: 1
};
var syncIgnoreAttributes = {
  tag: 1,
  html: 1,
  text: 1,
  children: 1,
  tooltip: 1,
  parent: 1,
  nextSibling: 1,
  ns: 1,
  reference: 1,
  elementData: 1,
  retainElement: 1,
  compareHtml: 1,
  syncOptions: 1,
  listeners: 1,
  isReleased: 1,
  null: 1,
  "": 1,
  keepChildren: 1
};
var addAndCacheCls = (cls, lastDomConfig) => {
  const propertyName = "className" in lastDomConfig ? "className" : "class", propertyValue = lastDomConfig[propertyName];
  if (propertyValue) {
    if (typeof propertyValue === "string") {
      const value = propertyValue.split(" ");
      if (!value.includes(cls)) {
        value.push(cls);
        lastDomConfig[propertyName] = value.join(" ");
      }
    } else if (Array.isArray(propertyValue)) {
      if (!propertyValue.includes(cls)) {
        propertyValue.push(cls);
      }
    } else if (propertyValue.isDomClassList) {
      propertyValue.add(cls);
    } else if (ObjectHelper.isObject(propertyValue)) {
      propertyValue[cls] = 1;
    }
  }
};
var removeAndUncacheCls = (cls, lastDomConfig) => {
  const propertyName = "className" in lastDomConfig ? "className" : "class", propertyValue = lastDomConfig[propertyName];
  if (propertyValue) {
    if (typeof propertyValue === "string") {
      const value = propertyValue.split(" ");
      if (value.includes(cls)) {
        value.splice(value.indexOf(cls), 1);
        lastDomConfig[propertyName] = value.join(" ");
      }
    } else if (Array.isArray(propertyValue)) {
      if (propertyValue.includes(cls)) {
        propertyValue.splice(propertyValue.indexOf(cls), 1);
      }
    } else if (propertyValue.isDomClassList) {
      propertyValue.remove(cls);
    } else if (ObjectHelper.isObject(propertyValue)) {
      delete propertyValue[cls];
    }
  }
};
var DomSync = class {
  static checkEquality(is, was, options, ignoreRefs) {
    if (is === was) {
      return true;
    }
    if (is == null) {
      return was == null;
    }
    if (!is || !was) {
      return false;
    }
    const typeA = typeof is, typeB = typeof was;
    if (typeA !== typeB || simpleTypes[typeA]) {
      return false;
    }
    let cache = options.equalityCache || (options.equalityCache = /* @__PURE__ */ new Map()), ignoreChildRefs = Boolean(ignoreRefs), equal2, i, ignore, ignoreRefOpt, key, syncOptions, val;
    cache = cache.get(is) || cache.set(is, /* @__PURE__ */ new Map()).get(is);
    equal2 = cache.get(was);
    if (equal2 === void 0) {
      equal2 = true;
      if (getPrototypeOf(is) !== getPrototypeOf(was) || is instanceof Node) {
        equal2 = false;
      } else if (Array.isArray(is)) {
        i = is.length;
        if (i !== was.length) {
          equal2 = false;
        } else {
          while (i-- > 0) {
            if (!DomSync.checkEquality(is[i], was[i], options, ignoreChildRefs)) {
              equal2 = false;
              break;
            }
          }
        }
      } else {
        var _syncOptions;
        syncOptions = is.syncOptions;
        ignoreRefOpt = (_syncOptions = syncOptions) === null || _syncOptions === void 0 ? void 0 : _syncOptions.ignoreRefs;
        if (ignoreRefOpt) {
          ignoreChildRefs = true;
          ignoreRefs = ignoreRefOpt !== "children";
        }
        ignore = options.ignore || emptyObject$a;
        for (key in was) {
          if (!ignore[key] && !(key in is) && !(ignoreRefs && key === "reference")) {
            equal2 = false;
            break;
          }
        }
        if (equal2) {
          if (toString.call(was) === "[object Date]") {
            equal2 = is.getTime() === was.getTime();
          } else {
            for (key in is) {
              if (!ignore[key] && !(ignoreRefs && key === "reference")) {
                if (!(key in was)) {
                  equal2 = false;
                  break;
                }
                val = is[key];
                if (!DomSync.checkEquality(val, was[key], options, ignoreChildRefs)) {
                  equal2 = false;
                  break;
                }
              }
            }
          }
        }
      }
      if (!ignoreRefs && isObject(is) && is.reference) {
        var _options$refsFound;
        (_options$refsFound = options.refsFound) === null || _options$refsFound === void 0 ? void 0 : _options$refsFound.add(is.reference);
      }
      cache.set(was, equal2);
    }
    return equal2;
  }
  static sync(options) {
    const optionsIn = options, {
      refOwner
    } = options, refsWas = refOwner === null || refOwner === void 0 ? void 0 : refOwner.byRef, checkEqualityOptions = makeCheckEqualityOptions();
    let affected = options.affected, i, ref, targetNode, lastDomConfig;
    if (typeof affected === "string") {
      affected = [affected];
    }
    options = _objectSpread2(_objectSpread2({}, options), {}, {
      checkEqualityOptions
    });
    if (refOwner) {
      refOwner.byRef = {};
      if (affected) {
        for (ref in refsWas) {
          if (!affected.includes(ref)) {
            refOwner.byRef[ref] = refsWas[ref];
          }
        }
      }
      options.refsWas = refsWas;
    }
    optionsIn.changed = DomSync.performSync(options, options.targetElement);
    if (refOwner) {
      if (!affected) {
        affected = Object.keys(refsWas);
      }
      for (i = 0; i < affected.length; ++i) {
        ref = affected[i];
        targetNode = refsWas[ref];
        if (checkEqualityOptions.refsFound.has(ref) || targetNode.retainElement) {
          refOwner.byRef[ref] = targetNode;
        } else {
          lastDomConfig = targetNode.lastDomConfig;
          targetNode.remove();
          refOwner.detachRef(ref, targetNode, lastDomConfig);
        }
      }
    }
    return options.targetElement;
  }
  static performSync(options, targetElement) {
    const {
      domConfig,
      callback
    } = options, {
      lastDomConfig
    } = targetElement, configIsEqual = options.configEquality || DomSync.checkEquality;
    if (!configIsEqual(domConfig, lastDomConfig, options.checkEqualityOptions, options.ignoreRefs)) {
      if (domConfig) {
        if (!domConfig.onlyChildren) {
          DomSync.syncAttributes(domConfig, targetElement, options);
          DomSync.syncContent(domConfig, targetElement);
        }
        if (!domConfig.keepChildren) {
          DomSync.syncChildren(options, targetElement);
        }
      } else {
        targetElement.innerHTML = null;
        targetElement.syncIdMap = null;
      }
      targetElement.lastDomConfig = !(domConfig !== null && domConfig !== void 0 && domConfig.onlyChildren && lastDomConfig) ? domConfig : _objectSpread2(_objectSpread2({}, lastDomConfig), {}, {
        children: domConfig.children
      });
      return true;
    } else {
      callback === null || callback === void 0 ? void 0 : callback({
        action: "none",
        domConfig,
        targetElement
      });
    }
    return false;
  }
  static syncDataset(domConfig, targetElement) {
    const {
      lastDomConfig
    } = targetElement, sameConfig = domConfig === lastDomConfig, source = Object.keys(domConfig.dataset), target = lastDomConfig && lastDomConfig.dataset && Object.keys(lastDomConfig.dataset), delta = ArrayHelper.delta(source, target);
    let attr, i, name, value;
    for (i = 0; i < delta.onlyInA.length; i++) {
      attr = delta.onlyInA[i];
      value = domConfig.dataset[attr];
      if (value != null) {
        targetElement.setAttribute(`data-${StringHelper.hyphenate(attr)}`, value);
      }
    }
    for (i = 0; i < delta.inBoth.length; i++) {
      attr = delta.inBoth[i];
      value = domConfig.dataset[attr];
      if (sameConfig || value != lastDomConfig.dataset[attr]) {
        name = `data-${StringHelper.hyphenate(attr)}`;
        if (value == null) {
          targetElement.removeAttribute(name);
        } else {
          targetElement.setAttribute(name, value);
        }
      }
    }
    for (i = 0; i < delta.onlyInB.length; i++) {
      targetElement.removeAttribute(`data-${StringHelper.hyphenate(delta.onlyInB[i])}`);
    }
  }
  static addCls(cls, targetElement) {
    const {
      lastDomConfig
    } = targetElement;
    cls = DomClassList.normalize(cls, "array");
    cls.forEach((cls2) => {
      targetElement.classList.add(cls2);
      addAndCacheCls(cls2, lastDomConfig);
    });
  }
  static removeCls(cls, targetElement) {
    const {
      lastDomConfig
    } = targetElement;
    cls = DomClassList.normalize(cls, "array");
    cls.forEach((cls2) => {
      targetElement.classList.remove(cls2);
      removeAndUncacheCls(cls2, lastDomConfig);
    });
  }
  static syncClassList(domConfig, targetElement, lastDomConfig) {
    let cls = domConfig.className || domConfig.class, changed = false, c, currentClasses, i, k, keep, last;
    if (lastDomConfig) {
      currentClasses = DomClassList.normalize(targetElement, "array");
      cls = DomClassList.normalize(cls, "object");
      last = DomClassList.normalize(lastDomConfig.className || lastDomConfig.class, "object");
      keep = [];
      for (i = 0, k = currentClasses.length; i < k; ++i) {
        c = currentClasses[i];
        if (cls[c] || !(c in last)) {
          last[c] = 1;
          keep.push(c);
        } else {
          changed = true;
        }
      }
      for (c in cls) {
        if (!last[c]) {
          keep.push(c);
          changed = true;
        }
      }
      if (!changed) {
        return;
      }
      cls = keep.join(" ");
    } else {
      cls = DomClassList.normalize(cls);
    }
    targetElement.setAttribute("class", cls);
  }
  static getSyncAttributes(domConfig) {
    const attributes = {}, names = [];
    if (domConfig) {
      Object.keys(domConfig).forEach((attr) => {
        if (!syncIgnoreAttributes[attr]) {
          const name = attr.toLowerCase();
          attributes[name] = domConfig[attr];
          names.push(name);
        }
      });
    }
    return {
      attributes,
      names
    };
  }
  static syncAttributes(domConfig, targetElement, options) {
    const {
      lastDomConfig
    } = targetElement, sameConfig = domConfig === lastDomConfig, sourceSyncAttrs = DomSync.getSyncAttributes(domConfig), {
      attributes: sourceAttributes,
      names: sourceNames
    } = sourceSyncAttrs, {
      attributes: targetAttributes,
      names: targetNames
    } = sameConfig ? sourceSyncAttrs : DomSync.getSyncAttributes(lastDomConfig), {
      onlyInA: toAdd,
      onlyInB: toRemove,
      inBoth: toSync
    } = sameConfig ? {
      onlyInA: emptyArray$9,
      onlyInB: emptyArray$9,
      inBoth: sourceNames
    } : ArrayHelper.delta(sourceNames, targetNames);
    let attr, i;
    for (i = 0; i < toAdd.length; i++) {
      attr = toAdd[i];
      const sourceAttr = sourceAttributes[attr];
      if (attr === "style" && sourceAttr != null) {
        DomHelper.applyStyle(targetElement, sourceAttr, true);
      } else if (attr === "dataset") {
        DomSync.syncDataset(domConfig, targetElement);
      } else if (isClass[attr]) {
        DomSync.syncClassList(domConfig, targetElement);
      } else if (sourceAttr != null) {
        targetElement.setAttribute(attr, sourceAttr);
      }
    }
    for (i = 0; i < toRemove.length; i++) {
      targetElement.removeAttribute(toRemove[i]);
    }
    for (i = 0; i < toSync.length; i++) {
      attr = toSync[i];
      const sourceAttr = sourceAttributes[attr], targetAttr = targetAttributes[attr];
      if (sourceAttr == null) {
        targetElement.removeAttribute(attr);
      } else if (attr === "style") {
        if (options.strict) {
          if (sameConfig) {
            DomSync.syncStyles(targetElement, sourceAttr);
          } else if (!isEqual(sourceAttr, targetAttr, true)) {
            DomSync.syncStyles(targetElement, sourceAttr, targetAttr);
          }
        } else if (sameConfig || !isEqual(sourceAttr, targetAttr, true)) {
          DomHelper.applyStyle(targetElement, sourceAttr, true);
        }
      } else if (attr === "dataset") {
        DomSync.syncDataset(domConfig, targetElement);
      } else if (isClass[attr]) {
        DomSync.syncClassList(domConfig, targetElement, options.strict && targetElement.lastDomConfig);
      } else if (sameConfig || sourceAttr !== targetAttr) {
        targetElement.setAttribute(attr, sourceAttr);
      }
    }
  }
  static syncStyles(targetElement, sourceAttr, targetAttr) {
    let styles, key, value;
    if (!targetAttr) {
      styles = sourceAttr;
    } else {
      styles = {};
      sourceAttr = DomHelper.parseStyle(sourceAttr);
      targetAttr = DomHelper.parseStyle(targetAttr);
      if (sourceAttr) {
        for (key in sourceAttr) {
          value = sourceAttr[key];
          if (targetAttr[key] !== value) {
            styles[key] = value;
          }
        }
      }
      for (key in targetAttr) {
        if (!(key in sourceAttr)) {
          styles[key] = "";
        }
      }
    }
    DomHelper.applyStyle(targetElement, styles);
  }
  static syncContent(domConfig, targetElement) {
    const {
      html,
      text
    } = domConfig, content = text !== null && text !== void 0 ? text : html;
    targetElement.didSetTextContent = false;
    if (domConfig.elementData) {
      targetElement.elementData = domConfig.elementData;
    }
    if (content instanceof DocumentFragment) {
      if (targetElement.childNodes.length === 1 && DomHelper.getChildElementCount(targetElement) === 0 && content.childNodes.length === 1 && DomHelper.getChildElementCount(content) === 0) {
        DomHelper.setInnerText(targetElement, content.firstChild.data);
      } else {
        targetElement.innerHTML = "";
        targetElement.appendChild(content);
      }
    } else if (html != null && htmlRe.test(html)) {
      targetElement.innerHTML = String(html);
    } else if (content != null) {
      var _lastDomConfig$childr;
      const {
        lastDomConfig
      } = targetElement;
      if (lastDomConfig !== null && lastDomConfig !== void 0 && (_lastDomConfig$childr = lastDomConfig.children) !== null && _lastDomConfig$childr !== void 0 && _lastDomConfig$childr.length || lastDomConfig !== null && lastDomConfig !== void 0 && lastDomConfig.html && htmlRe.test(targetElement.lastDomConfig.html)) {
        targetElement.innerHTML = content;
      } else {
        DomHelper.setInnerText(targetElement, String(content));
        targetElement.didSetTextContent = true;
      }
    }
  }
  static insertTextNode(text, targetElement, callback, refOwner, beforeElement = null) {
    const newNode = document.createTextNode(text);
    targetElement.insertBefore(newNode, beforeElement);
    if (refOwner) {
      newNode.$refOwnerId = refOwner.id;
    }
    callback === null || callback === void 0 ? void 0 : callback({
      action: "newNode",
      domConfig: text,
      targetElement: newNode
    });
  }
  static insertElement(domConfig, targetElement, targetNode, refOwner, syncIdMap, syncId, options) {
    var _options$callback;
    const newElement = options.ns ? document.createElementNS(options.ns, domConfig.tag || "svg") : document.createElement(domConfig.tag || "div");
    targetElement.insertBefore(newElement, targetNode);
    DomSync.performSync(options, newElement);
    if (syncId != null) {
      syncIdMap[syncId] = newElement;
    }
    if (!domConfig.role && !domConfig.tabIndex && !domConfig["aria-hidden"] && !DomHelper.isFocusable(newElement, true) && !newElement.htmlFor) {
      newElement.setAttribute("role", "presentation");
    }
    if (refOwner) {
      newElement.$refOwnerId = refOwner.id;
      if (syncId) {
        newElement.$reference = syncId;
        refOwner.attachRef(syncId, newElement, domConfig);
      }
    }
    (_options$callback = options.callback) === null || _options$callback === void 0 ? void 0 : _options$callback.call(options, {
      action: "newElement",
      domConfig,
      targetElement: newElement,
      syncId
    });
  }
  static syncChildren(options, targetElement) {
    var _domConfig$html, _syncOptions$ignoreRe;
    let {
      domConfig,
      syncIdField,
      callback,
      releaseThreshold,
      configEquality,
      ns: ns2,
      refOwner,
      refsWas,
      strict,
      checkEqualityOptions,
      ignoreRefs
    } = options, syncOptions = domConfig.syncOptions || {}, cleanupNodes = null, index, nextNode, syncId;
    if ((_domConfig$html = domConfig.html) !== null && _domConfig$html !== void 0 ? _domConfig$html : domConfig.text) {
      return;
    }
    ignoreRefs = Boolean((_syncOptions$ignoreRe = syncOptions.ignoreRefs) !== null && _syncOptions$ignoreRe !== void 0 ? _syncOptions$ignoreRe : ignoreRefs);
    if (ignoreRefs) {
      refOwner = refsWas = null;
    }
    if ("strict" in syncOptions) {
      strict = syncOptions.strict;
    }
    const newSyncIdMap = refOwner ? refOwner.byRef : {}, sourceConfigs = arraySlice.call(domConfig.children || []), targetNodes = arraySlice.call(targetElement.childNodes), syncIdMap = refsWas || targetElement.syncIdMap || {}, releasedIdMap = targetElement.releasedIdMap || {}, nextTarget = (remove) => {
      while (targetNodes.length && targetNodes[0].parentNode !== targetElement) {
        targetNodes.shift();
      }
      return (remove ? targetNodes.shift() : targetNodes[0]) || null;
    };
    syncIdField = syncOptions.syncIdField || syncIdField;
    strict = syncOptions.strict || strict;
    callback = syncOptions.callback || callback;
    configEquality = syncOptions.configEquality || configEquality;
    releaseThreshold = "releaseThreshold" in syncOptions ? syncOptions.releaseThreshold : releaseThreshold;
    if (syncIdField) {
      targetElement.syncIdMap = newSyncIdMap;
    }
    const syncChildOptions = {
      checkEqualityOptions: checkEqualityOptions || makeCheckEqualityOptions(),
      ignoreRefs,
      refOwner,
      refsWas,
      strict,
      syncIdField,
      releaseThreshold,
      callback,
      configEquality
    };
    while (sourceConfigs.length) {
      const sourceConfig = sourceConfigs.shift();
      syncId = null;
      if (!sourceConfig) {
        continue;
      }
      if (DomHelper.isReactElement(sourceConfig)) {
        callback({
          jsx: sourceConfig,
          targetElement
        });
        continue;
      }
      if (sourceConfig instanceof Node) {
        nextNode = nextTarget();
        if (sourceConfig !== nextNode) {
          targetElement.insertBefore(sourceConfig, nextNode);
        }
        index = targetNodes.indexOf(sourceConfig);
        if (index > -1) {
          targetNodes.splice(index, 1);
        }
        continue;
      }
      const isTextNode = typeof sourceConfig === "string";
      syncChildOptions.domConfig = sourceConfig;
      syncChildOptions.ns = sourceConfig.ns || ns2;
      if (!isTextNode) {
        if (refOwner) {
          syncId = sourceConfig.reference;
        } else if (syncIdField && sourceConfig.dataset) {
          syncId = sourceConfig.dataset[syncIdField];
        }
        if (syncId != null && !sourceConfig.unmatched) {
          const syncTargetElement = syncIdMap[syncId] || releasedIdMap[syncId];
          if (syncTargetElement) {
            const {
              lastDomConfig
            } = syncTargetElement;
            if (syncTargetElement.retainElement)
              ;
            else if (DomSync.performSync(syncChildOptions, syncTargetElement)) {
              var _callback;
              (_callback = callback) === null || _callback === void 0 ? void 0 : _callback({
                action: "reuseOwnElement",
                domConfig: sourceConfig,
                targetElement: syncTargetElement,
                lastDomConfig,
                syncId
              });
            }
            if (sourceConfig.retainElement) {
              syncTargetElement.retainElement = true;
            }
            newSyncIdMap[syncId] = syncTargetElement;
            ArrayHelper.remove(targetNodes, syncTargetElement);
            delete releasedIdMap[syncId];
            syncTargetElement.isReleased = false;
            nextNode = nextTarget();
            if (syncTargetElement.parentNode !== targetElement || strict && syncTargetElement.nextSibling !== nextNode) {
              targetElement.insertBefore(syncTargetElement, nextNode);
            }
          } else if (strict) {
            DomSync.insertElement(sourceConfig, targetElement, nextTarget(), refOwner, newSyncIdMap, syncId, syncChildOptions);
          } else {
            sourceConfigs.push(sourceConfig);
            sourceConfig.unmatched = true;
          }
          continue;
        }
        if (sourceConfig.unmatched) {
          delete sourceConfig.unmatched;
        }
      }
      let beforeNode = null, targetNode = null, cleanupNode;
      while (!targetNode && (cleanupNode = nextTarget(true))) {
        if (refOwner) {
          if (cleanupNode.$refOwnerId !== refOwner.id) {
            continue;
          }
          if (cleanupNode.$reference) {
            if (!strict) {
              continue;
            }
            beforeNode = cleanupNode;
            break;
          }
          targetNode = cleanupNode;
        } else if (!cleanupNode.retainElement) {
          targetNode = cleanupNode;
        }
        if (!targetNode) {
          (cleanupNodes || (cleanupNodes = [])).push(cleanupNode);
        }
      }
      if (beforeNode || !targetNode) {
        if (isTextNode) {
          DomSync.insertTextNode(sourceConfig, targetElement, callback, refOwner, beforeNode);
        } else {
          DomSync.insertElement(sourceConfig, targetElement, beforeNode, refOwner, newSyncIdMap, syncId, syncChildOptions);
        }
      } else {
        if (!isTextNode && targetNode.nodeType === Node.ELEMENT_NODE && (sourceConfig.tag || "div").toLowerCase() === targetNode.tagName.toLowerCase()) {
          var _lastDomConfig$datase, _callback2;
          const {
            lastDomConfig
          } = targetNode, result = DomSync.performSync(syncChildOptions, targetNode);
          if (syncIdField && (lastDomConfig === null || lastDomConfig === void 0 ? void 0 : (_lastDomConfig$datase = lastDomConfig.dataset) === null || _lastDomConfig$datase === void 0 ? void 0 : _lastDomConfig$datase[syncIdField]) != null) {
            const lastSyncId = lastDomConfig.dataset[syncIdField];
            delete releasedIdMap[lastSyncId];
            delete syncIdMap[lastSyncId];
          }
          if (syncId != null) {
            newSyncIdMap[syncId] = targetNode;
          }
          targetNode.isReleased = false;
          result && ((_callback2 = callback) === null || _callback2 === void 0 ? void 0 : _callback2({
            action: "reuseElement",
            domConfig: sourceConfig,
            targetElement: targetNode,
            lastDomConfig,
            syncId
          }));
        } else if (isTextNode && targetNode.nodeType === Node.TEXT_NODE) {
          targetNode.data = sourceConfig;
        } else {
          if (isTextNode) {
            DomSync.insertTextNode(sourceConfig, targetElement, callback, refOwner, targetNode);
          } else {
            DomSync.insertElement(sourceConfig, targetElement, targetNode, refOwner, newSyncIdMap, syncId, syncChildOptions);
          }
          targetNode.remove();
        }
      }
    }
    if (targetElement.didSetTextContent && targetNodes.length === 1 && targetNodes[0].nodeType === Node.TEXT_NODE) {
      return;
    }
    while (nextNode = nextTarget(true)) {
      if (!refOwner || nextNode.$refOwnerId === refOwner.id && !nextNode.$reference) {
        (cleanupNodes || (cleanupNodes = [])).push(nextNode);
      }
    }
    if (cleanupNodes) {
      DomSync.syncChildrenCleanup(targetElement, cleanupNodes, newSyncIdMap, callback, refOwner, releaseThreshold, syncIdField);
    }
  }
  static syncChildrenCleanup(targetElement, cleanupNodes, newSyncIdMap, callback, refOwner, releaseThreshold, syncIdField) {
    let releaseCount = 0, ref;
    for (const targetNode of cleanupNodes) {
      const {
        lastDomConfig
      } = targetNode;
      if (targetNode.nodeType === Element.TEXT_NODE) {
        targetNode.remove();
        continue;
      }
      if (!targetNode.retainElement) {
        if (!refOwner && syncIdField && (releaseThreshold == null || releaseCount < releaseThreshold)) {
          if (!targetNode.isReleased) {
            targetNode.className = "b-released";
            targetNode.isReleased = true;
            if (lastDomConfig !== null && lastDomConfig !== void 0 && lastDomConfig.dataset) {
              if (!targetElement.releasedIdMap) {
                targetElement.releasedIdMap = {};
              }
              targetElement.releasedIdMap[lastDomConfig.dataset[syncIdField]] = targetNode;
            }
            callback === null || callback === void 0 ? void 0 : callback({
              action: "releaseElement",
              domConfig: lastDomConfig,
              lastDomConfig,
              targetElement: targetNode
            });
            if (lastDomConfig) {
              lastDomConfig.isReleased = true;
              if (lastDomConfig.className) {
                lastDomConfig.className = "b-released";
              }
              if (lastDomConfig.class) {
                lastDomConfig.class = "b-released";
              }
              if (lastDomConfig.style) {
                lastDomConfig.style = null;
              }
            }
          }
          releaseCount++;
        } else {
          targetNode.remove();
          if (refOwner) {
            ref = targetNode.$reference;
            if (ref) {
              refOwner.detachRef(ref, targetNode, lastDomConfig);
            }
          }
          if (targetElement.releasedIdMap && syncIdField && lastDomConfig !== null && lastDomConfig !== void 0 && lastDomConfig.dataset) {
            delete targetElement.releasedIdMap[lastDomConfig.dataset[syncIdField]];
          }
          callback === null || callback === void 0 ? void 0 : callback({
            action: "removeElement",
            domConfig: targetNode.lastDomConfig,
            lastDomConfig: targetNode.lastDomConfig,
            targetElement: targetNode
          });
        }
      } else if (syncIdField) {
        if (lastDomConfig) {
          newSyncIdMap[targetNode.dataset[syncIdField]] = targetNode;
        }
      }
    }
  }
  static removeChild(parentElement, childElement) {
    if (parentElement.contains(childElement)) {
      const syncIdMap = parentElement.syncIdMap;
      if (syncIdMap) {
        const index = Object.values(syncIdMap).indexOf(childElement);
        if (index > -1) {
          delete syncIdMap[Object.keys(syncIdMap)[index]];
        }
      }
      parentElement.removeChild(childElement);
    }
  }
  static addChild(parentElement, childElement, syncId) {
    parentElement.appendChild(childElement);
    if (!parentElement.syncIdMap) {
      parentElement.syncIdMap = {};
    }
    parentElement.syncIdMap[syncId] = childElement;
  }
  static getChild(element, path) {
    const syncIds = String(path).split(".");
    for (const id of syncIds) {
      var _element, _element$syncIdMap;
      element = (_element = element) === null || _element === void 0 ? void 0 : (_element$syncIdMap = _element.syncIdMap) === null || _element$syncIdMap === void 0 ? void 0 : _element$syncIdMap[id];
      if (!element) {
        return null;
      }
    }
    return element;
  }
};
DomSync._$name = "DomSync";
var Fullscreen = class {
  static init() {
    const fnNames = ["fullscreenEnabled", "requestFullscreen", "exitFullscreen", "fullscreenElement"], prefixFn = (prefix) => fnNames.map((fn2) => {
      let result = prefix + StringHelper.capitalize(fn2);
      if (prefix === "moz") {
        result = result.replace("screen", "Screen");
        if ("mozCancelFullScreen" in document && fn2 === "exitFullscreen") {
          result = "mozCancelFullScreen";
        }
      }
      return result;
    });
    this.functions = "fullscreenEnabled" in document && fnNames || "webkitFullscreenEnabled" in document && prefixFn("webkit") || "mozFullScreenEnabled" in document && prefixFn("moz") || "msFullscreenEnabled" in document && prefixFn("ms") || [];
    const eventNames = ["fullscreenchange", "fullscreenerror"], msEventNames = ["MSFullscreenChange", "MSFullscreenError"], prefixEvt = (prefix) => eventNames.map((eventName) => prefix + StringHelper.capitalize(eventName));
    this.events = "fullscreenEnabled" in document && eventNames || "webkitFullscreenEnabled" in document && prefixEvt("webkit") || "mozFullscreenEnabled" in document && prefixEvt("moz") || "msFullscreenEnabled" in document && msEventNames || [];
  }
  static get enabled() {
    return Boolean(this.functions[0] && document[this.functions[0]]);
  }
  static async request(element) {
    return this.functions[1] && (element === null || element === void 0 ? void 0 : element[this.functions[1]]());
  }
  static async exit() {
    return this.functions[2] && document[this.functions[2]]();
  }
  static get isFullscreen() {
    return !!this.element;
  }
  static get element() {
    return this.functions[3] && document[this.functions[3]];
  }
  static onFullscreenChange(fn2) {
    if (this.events[0]) {
      document.addEventListener(this.events[0], fn2);
    }
  }
  static unFullscreenChange(fn2) {
    if (this.events[0]) {
      document.removeEventListener(this.events[0], fn2);
    }
  }
};
Fullscreen.init();
Fullscreen._$name = "Fullscreen";
var resizeFireTimer = null;
var resizedQueue = [];
var isAbsolutelyPositioned = (n) => {
  var _n$ownerDocument$defa;
  return n.nodeType === n.ELEMENT_NODE && ((_n$ownerDocument$defa = n.ownerDocument.defaultView) === null || _n$ownerDocument$defa === void 0 ? void 0 : _n$ownerDocument$defa.getComputedStyle(n).getPropertyValue("position")) === "absolute";
};
var ResizeMonitor = class {
  static addResizeListener(element, handler) {
    const me = this;
    if (element === document || element === globalThis) {
      element = document.body;
    }
    if (element.nodeType === element.DOCUMENT_FRAGMENT_NODE) {
      element = element.host;
    }
    if (!element.classList.contains("b-resize-monitored")) {
      element.classList.add("b-resize-monitored");
      element._bResizemonitor = {
        handlers: []
      };
    }
    if (element === document.body) {
      if (!me.hasWindowResizeListener) {
        globalThis.addEventListener("resize", me.onWindowResize);
        me.hasWindowResizeListener = true;
      }
    } else if (globalThis.ResizeObserver) {
      if (!me.resizeObserver) {
        me.resizeObserver = new ResizeObserver(me.onElementResize);
      }
      me.resizeObserver.observe(element);
    } else {
      element.classList.add("b-no-resizeobserver");
      const [monitors, expand, shrink] = DomHelper.createElement({
        parent: element,
        className: "b-resize-monitors",
        children: [{
          className: "b-resize-monitor-expand"
        }, {
          className: "b-resize-monitor-shrink"
        }]
      }, {
        returnAll: true
      });
      expand.scrollLeft = expand.scrollTop = shrink.scrollLeft = shrink.scrollTop = 1e6;
      expand.addEventListener("scroll", me.onSizeMonitorScroll, true);
      shrink.addEventListener("scroll", me.onSizeMonitorScroll, true);
      (handler.targetMutationMonitor = new MutationObserver((m) => {
        const addedNodes = [], removedNodes = [];
        for (const mr of m) {
          if (mr.type === "childList") {
            addedNodes.push.apply(addedNodes, mr.addedNodes);
            removedNodes.push.apply(removedNodes, mr.removedNodes);
          }
        }
        const changedNodes = [...addedNodes.filter((r) => !removedNodes.includes(r)), ...removedNodes.filter((r) => !addedNodes.includes(r))];
        if (changedNodes.length === 0) {
          return;
        }
        if (changedNodes.length > 0 && changedNodes.every(isAbsolutelyPositioned)) {
          return;
        }
        expand.dispatchEvent(new CustomEvent("scroll", {
          bubbles: false
        }));
      })).observe(element, {
        childList: true,
        subtree: true
      });
      handler.monitorElement = monitors;
    }
    element._bResizemonitor.handlers.push(handler);
  }
  static removeResizeListener(element, handler) {
    if (element) {
      if (element === document || element === globalThis) {
        element = document.body;
      }
      const resizeMonitor = element._bResizemonitor;
      let listenerCount = 0;
      if (resizeMonitor && resizeMonitor.handlers) {
        ArrayHelper.remove(resizeMonitor.handlers, handler);
        listenerCount = resizeMonitor.handlers.length;
      }
      if (!listenerCount) {
        element.classList.remove("b-resize-monitored");
        if (this.resizeObserver) {
          this.resizeObserver.unobserve(element);
        } else {
          if (handler.monitorElement) {
            handler.monitorElement.remove();
            handler.monitorElement = null;
          }
          if (handler.targetMutationMonitor) {
            handler.targetMutationMonitor.disconnect();
          }
        }
      }
    }
  }
  static onElementResize(entries) {
    for (const resizeObserverEntry of entries) {
      const resizedElement = resizeObserverEntry.target, resizeMonitor = resizedElement._bResizemonitor, newRect = resizeObserverEntry.contentRect || resizedElement.getBoundingClientRect();
      if (hasLayout(resizedElement)) {
        if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
          const oldRect = resizeMonitor.rectangle;
          resizeMonitor.rectangle = newRect;
          for (const resizeHandler of resizeMonitor.handlers) {
            resizeHandler(resizedElement, oldRect, newRect);
          }
        }
      }
    }
  }
  static onSizeMonitorScroll(e) {
    var _document$body;
    if ((_document$body = document.body) !== null && _document$body !== void 0 && _document$body.contains(e.target)) {
      e.stopImmediatePropagation();
      const monitorNode = e.target.parentNode, resizedElement = monitorNode.parentNode, resizeMonitor = resizedElement._bResizemonitor, newRect = resizedElement.getBoundingClientRect();
      if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
        resizedQueue.push([resizedElement, resizeMonitor.rectangle, newRect]);
        resizeMonitor.rectangle = newRect;
        if (!resizeFireTimer) {
          resizeFireTimer = requestAnimationFrame(ResizeMonitor.fireResizeEvents);
        }
      }
      monitorNode.firstChild.scrollLeft = monitorNode.firstChild.scrollTop = monitorNode.childNodes[1].scrollTop = monitorNode.childNodes[1].scrollLeft = 1e6;
    }
  }
  static onWindowResize(e) {
    const resizedElement = document.body, resizeMonitor = resizedElement._bResizemonitor, oldRect = resizeMonitor.rectangle;
    resizeMonitor.rectangle = document.documentElement.getBoundingClientRect();
    for (const resizeHandler of resizeMonitor.handlers) {
      resizeHandler(resizedElement, oldRect, resizeMonitor.rectangle);
    }
  }
  static fireResizeEvents() {
    for (const resizedEntry of resizedQueue) {
      for (const resizeHandler of resizedEntry[0]._bResizemonitor.handlers) {
        if (resizedEntry[0].offsetParent) {
          resizeHandler.apply(this, resizedEntry);
        }
      }
    }
    resizeFireTimer = null;
    resizedQueue.length = 0;
  }
  static removeGlobalListeners() {
    globalThis.removeEventListener("resize", this.onWindowResize);
  }
};
ResizeMonitor._$name = "ResizeMonitor";
var scrollLiterals = {
  auto: "auto",
  true: "auto",
  false: "hidden",
  "hidden-scroll": "auto",
  clip: BrowserHelper.supportsOverflowClip ? "clip" : "hidden"
};
var scrollerCls = "b-widget-scroller";
var defaultScrollOptions$4 = {
  block: "nearest"
};
var immediatePromise$5 = Promise.resolve();
var scrollPromise = (element) => new Promise((resolve) => EventHelper.on({
  element: element === document.documentElement ? window : element,
  scroll: resolve,
  once: true
}));
var xAxis$1 = {
  x: 1
};
var isScrollable = {
  auto: 1,
  scroll: 1
};
var isScrollableConfig = {
  true: 1,
  auto: 1
};
var allScroll = {
  overflowX: "auto",
  overflowY: "auto"
};
var normalizeEdgeOffset = (edgeOffset) => {
  let top, bottom, start, end;
  if (!edgeOffset) {
    top = bottom = start = end = 0;
  } else if (typeof edgeOffset === "number") {
    top = bottom = start = end = edgeOffset;
  } else {
    var _edgeOffset$top, _edgeOffset$bottom, _edgeOffset$start, _edgeOffset$end;
    top = (_edgeOffset$top = edgeOffset.top) !== null && _edgeOffset$top !== void 0 ? _edgeOffset$top : 0;
    bottom = (_edgeOffset$bottom = edgeOffset.bottom) !== null && _edgeOffset$bottom !== void 0 ? _edgeOffset$bottom : 0;
    start = (_edgeOffset$start = edgeOffset.start) !== null && _edgeOffset$start !== void 0 ? _edgeOffset$start : 0;
    end = (_edgeOffset$end = edgeOffset.end) !== null && _edgeOffset$end !== void 0 ? _edgeOffset$end : 0;
  }
  return {
    top,
    bottom,
    start,
    end
  };
};
var Scroller = class extends Delayable(Events(Base$1)) {
  static get configurable() {
    return {
      widget: null,
      element: {
        $config: {
          nullify: true
        },
        value: null
      },
      contentElement: {
        $config: {
          nullify: true
        },
        value: null
      },
      overflowX: null,
      overflowY: null,
      translate: null,
      x: 0,
      y: 0,
      rtlSource: null
    };
  }
  static get delayable() {
    return {
      onScrollEnd: {
        type: "buffer",
        delay: 100
      }
    };
  }
  get isRTL() {
    var _this$rtlSource;
    return Boolean((_this$rtlSource = this.rtlSource) === null || _this$rtlSource === void 0 ? void 0 : _this$rtlSource.rtl);
  }
  syncOverflowState() {
    const me = this, {
      element
    } = me, classList = new DomClassList(element.classList), x = me.hasOverflowX = element.scrollWidth > element.clientWidth, y = me.hasOverflowY = element.scrollHeight > element.clientHeight;
    classList.value = element.classList;
    const changed = classList.toggle("b-horizontal-overflow", x) || classList.toggle("b-vertical-overflow", y);
    if (changed) {
      DomHelper.syncClassList(element, classList);
      if (!me.isConfiguring) {
        me.trigger("overflowChange", {
          x,
          y
        });
      }
    }
  }
  hasOverflow(axis = "y") {
    const overflowSetting = this[`overflow${axis.toUpperCase()}`], otherAxis = this[`overflow${axis === "y" ? "x" : "y"}`];
    if (!DomHelper.scrollBarWidth || !isScrollableConfig[overflowSetting] || otherAxis === "hidden-scroll" || BrowserHelper.isFirefox) {
      const dimension = axis === "y" ? "Height" : "Width";
      return this[`scroll${dimension}`] > this[`client${dimension}`];
    } else {
      return this[`hasOverflow${axis.toUpperCase()}`];
    }
  }
  hasScrollbar(axis = "y") {
    const {
      element
    } = this;
    if (element && DomHelper.scrollBarWidth) {
      const vertical = axis === "y", dimension = vertical ? "Width" : "Height", clientSize = element[`client${dimension}`], borderSize = parseInt(DomHelper.getStyleValue(element, `border${vertical ? "Left" : "Top"}Width`)) + parseInt(DomHelper.getStyleValue(element, `border${vertical ? "Right" : "Bottom"}Width`)), difference = element[`offset${dimension}`] - borderSize - clientSize;
      return Math.abs(difference - DomHelper.scrollBarWidth) < 2;
    }
  }
  addPartner(otherScroller, axes = xAxis$1) {
    const me = this;
    if (typeof axes === "string") {
      axes = {
        [axes]: 1
      };
    }
    if (!me.partners) {
      me.partners = {};
    }
    me.partners[otherScroller.id] = {
      scroller: otherScroller,
      axes
    };
    if (axes.x) {
      otherScroller.x = me.x;
    }
    if (axes.y) {
      otherScroller.y = me.y;
    }
    if (!otherScroller.isPartneredWith(me)) {
      otherScroller.addPartner(me, axes);
    }
  }
  eachPartner(fn2) {
    const {
      partners
    } = this;
    if (partners) {
      Object.values(partners).forEach(fn2);
    }
  }
  removePartner(otherScroller) {
    if (this.isPartneredWith(otherScroller)) {
      delete this.partners[otherScroller.id];
      otherScroller.removePartner(this);
    }
  }
  isPartneredWith(otherScroller) {
    var _this$partners;
    return Boolean((_this$partners = this.partners) === null || _this$partners === void 0 ? void 0 : _this$partners[otherScroller.id]);
  }
  clearPartners() {
    if (this.partners) {
      Object.values(this.partners).forEach((otherScroller) => otherScroller.scroller.removePartner(this));
    }
  }
  async scrollIntoView(element, options = defaultScrollOptions$4) {
    const me = this, {
      isRectangle
    } = element, originalRect = isRectangle ? element : Rectangle.from(element), {
      xDelta,
      yDelta
    } = me.getDeltaTo(element, options), result = me.scrollBy(xDelta, yDelta, options);
    if (options.highlight || options.focus) {
      result.then(() => {
        if (isRectangle) {
          element = originalRect.translate(-xDelta, -yDelta);
        }
        if (options.highlight) {
          if (isNaN(options.highlight)) {
            (me.widget || me).callback(options.highlight, null, [element]);
          } else {
            DomHelper.highlight(element, me);
          }
        }
        if (options.focus) {
          DomHelper.focusWithoutScrolling(element);
        }
      });
    }
    return result;
  }
  static async scrollIntoView(element, options = defaultScrollOptions$4, rtl = false) {
    const target = Rectangle.from(element), animate = typeof options === "object" ? options.animate : options, scrollable = Scroller._globalScroller || (Scroller._globalScroller = new Scroller()), deltas = [];
    scrollable.rtlSource = {
      rtl
    };
    let totalX = 0, totalY = 0, result;
    for (let ancestor = element.parentNode; ancestor.nodeType === Node.ELEMENT_NODE; ancestor = ancestor.parentNode) {
      if (ancestor === document.body && ancestor !== document.scrollingElement) {
        continue;
      }
      const style = ancestor === document.scrollingElement ? allScroll : ancestor.ownerDocument.defaultView.getComputedStyle(ancestor);
      if (options.y !== false && isScrollable[style.overflowY] && ancestor.scrollHeight > ancestor.clientHeight || options.x !== false && isScrollable[style.overflowX] && ancestor.scrollWidth > ancestor.clientWidth) {
        scrollable.element = ancestor;
        scrollable.positionDirty = true;
        const {
          xDelta,
          yDelta
        } = scrollable.getDeltaTo(target, options);
        if (xDelta || yDelta) {
          deltas.push({
            element: ancestor,
            x: ancestor.scrollLeft,
            y: ancestor.scrollTop,
            xDelta,
            yDelta
          });
          target.translate(-xDelta, -yDelta);
          totalX += xDelta;
          totalY += yDelta;
        }
      }
    }
    if (deltas.length) {
      const absX = Math.abs(totalX), absY = Math.abs(totalY);
      let duration = animate && (typeof animate === "number" ? animate : typeof animate.duration === "number" ? animate.duration : 300);
      if (duration && (absX > 10 || absY > 10)) {
        if (Math.max(absX, absY) < 50) {
          duration = Math.min(duration, 500);
        }
        result = scrollable.scrollAnimation = FunctionHelper.animate(duration, (progress) => {
          const isEnd = progress === 1;
          for (const {
            element: element2,
            x,
            y,
            xDelta,
            yDelta
          } of deltas) {
            scrollable.element = element2;
            if (xDelta) {
              scrollable.x = Math[rtl ? "min" : "max"](x + (isEnd ? xDelta : Math.round(xDelta * progress)), 0);
            }
            if (yDelta) {
              scrollable.y = Math.max(y + (isEnd ? yDelta : Math.round(yDelta * progress)), 0);
            }
          }
        }, null, animate.easing);
        result.then(() => {
          scrollable.scrollAnimation = null;
        });
      } else {
        for (const {
          element: element2,
          xDelta,
          yDelta
        } of deltas) {
          element2.scrollTop += yDelta;
          element2.scrollLeft += xDelta;
        }
        result = scrollPromise(deltas[deltas.length - 1].element);
      }
    } else {
      result = immediatePromise$5;
    }
    if (options.highlight || options.focus) {
      result.then(() => {
        if (options.highlight) {
          if (isNaN(options.highlight)) {
            scrollable.callback(options.highlight, null, [element]);
          } else {
            DomHelper.highlight(element, scrollable);
          }
        }
        if (options.focus) {
          element.focus();
        }
      });
    }
    return result;
  }
  async scrollBy(xDelta = 0, yDelta = 0, options = defaultScrollOptions$4) {
    const me = this, animate = typeof options === "object" ? options.animate : options, absX = Math.abs(xDelta), absY = Math.abs(yDelta);
    if (me.scrollAnimation) {
      me.scrollAnimation.cancel();
      me.scrollAnimation = null;
    }
    if (xDelta || yDelta) {
      me.silent = options.silent;
    }
    let duration = animate && (typeof animate === "number" ? animate : typeof animate.duration === "number" ? animate.duration : 300);
    if (duration && (absX > 10 || absY > 10)) {
      const {
        x,
        y
      } = me;
      let lastX = x, lastY = y;
      if (Math.max(absX, absY) < 50) {
        duration = Math.min(duration, 500);
      }
      me.scrollAnimation = FunctionHelper.animate(duration, (progress) => {
        const isEnd = progress === 1;
        if (xDelta) {
          if (me.x !== lastX && !options.force) {
            var _me$scrollAnimation;
            return (_me$scrollAnimation = me.scrollAnimation) === null || _me$scrollAnimation === void 0 ? void 0 : _me$scrollAnimation.cancel();
          }
          me.x = Math.max(x + (isEnd ? xDelta : Math.round(xDelta * progress)), 0);
        }
        if (yDelta) {
          if (me.y !== lastY && !options.force) {
            var _me$scrollAnimation2;
            return (_me$scrollAnimation2 = me.scrollAnimation) === null || _me$scrollAnimation2 === void 0 ? void 0 : _me$scrollAnimation2.cancel();
          }
          me.y = Math.max(y + (isEnd ? yDelta : Math.round(yDelta * progress)), 0);
        }
        lastX = me.x;
        lastY = me.y;
      }, me, animate.easing);
      me.element.classList.add("b-scrolling");
      me.scrollAnimation.then(() => {
        if (!me.isDestroyed) {
          me.element.classList.remove("b-scrolling");
          me.scrollAnimation = null;
        }
      });
      return me.scrollAnimation;
    } else {
      if (xDelta | yDelta) {
        const xBefore = me.x, yBefore = me.y;
        me.x += xDelta;
        me.y += yDelta;
        if (me.x !== xBefore || me.y !== yBefore) {
          return scrollPromise(me.element);
        }
      }
      return immediatePromise$5;
    }
  }
  async scrollTo(toX, toY, options) {
    const {
      x,
      y
    } = this, xDelta = toX == null ? 0 : toX - x, yDelta = toY == null ? 0 : toY - y;
    return this.scrollBy(xDelta, yDelta, options);
  }
  doDestroy() {
    var _me$scrollAnimation3;
    const me = this;
    if (me._element) {
      var _me$wheelListenerRemo;
      me._element.removeEventListener("scroll", me.scrollHandler);
      (_me$wheelListenerRemo = me.wheelListenerRemover) === null || _me$wheelListenerRemo === void 0 ? void 0 : _me$wheelListenerRemo.call(me);
    }
    (_me$scrollAnimation3 = me.scrollAnimation) === null || _me$scrollAnimation3 === void 0 ? void 0 : _me$scrollAnimation3.cancel();
    Object.values(me.partners || {}).forEach(({
      scroller
    }) => scroller.removePartner(me));
    super.doDestroy();
  }
  onElMutation(mutations) {
    const me = this, [x, y] = DomHelper.getTranslateXY(me.element);
    if (me._x !== -x || me.y !== -y) {
      const scrollEvent = new CustomEvent("scroll", {
        bubbles: true
      });
      Object.defineProperty(scrollEvent, "target", {
        get: () => me.element
      });
      me.onScroll(scrollEvent);
    }
  }
  onElResize() {
    const me = this, {
      widget
    } = me;
    if (!(widget !== null && widget !== void 0 && widget.isAnimating)) {
      me.syncOverflowState();
    } else if (widget.findListener("animationend", "onElResize", me) === -1) {
      widget.ion({
        animationEnd: "onElResize",
        thisObj: me,
        once: true
      });
    }
  }
  onScroll(e) {
    const me = this, {
      _x,
      _y,
      element
    } = me;
    let vetoed = 0;
    if (me.overflowX === "clip" && element.scrollLeft !== _x) {
      element.scrollLeft = _x;
      ++vetoed;
    }
    if (me.overflowY === "clip" && element.scrollTop !== _y) {
      element.scrollTop = _y;
      ++vetoed;
    }
    if (vetoed === 2) {
      return;
    }
    if (!me.widget || !me.widget.isDestroyed) {
      me.positionDirty = true;
      if (!element.classList.contains("b-scrolling")) {
        element.classList.add("b-scrolling");
      }
      e.widget = me.widget;
      if (!me.silent) {
        me.trigger("scroll", e);
      }
      me.syncPartners();
      me.controllingPartner = null;
      me.onScrollEnd(e);
    }
  }
  syncPartners(force, propagate) {
    const me = this;
    if (me.partners) {
      Object.values(me.partners).forEach(({
        axes,
        scroller
      }) => {
        if (scroller !== me.controllingPartner || force) {
          if (scroller.sync(me, axes) && propagate) {
            scroller.syncPartners(force, propagate);
          }
        }
      });
    }
  }
  onScrollEnd(e) {
    const me = this;
    if (me.silent) {
      me.silent = false;
    }
    me.trigger("scrollEnd", e);
    me.controllingPartner = null;
    me.element.classList.remove("b-scrolling");
  }
  getDeltaTo(element, options) {
    const me = this;
    if (!me.viewport) {
      return {
        xDelta: 0,
        yDelta: 0
      };
    }
    const {
      x,
      y,
      scrollWidth,
      scrollHeight,
      isRTL
    } = me, elementRect = element instanceof Rectangle ? element : Rectangle.from(element), block = options.block || "nearest", scrollerRect = me.viewport, edgeOffset = normalizeEdgeOffset(options.edgeOffset), xOffset = scrollerRect.width >= elementRect.width + (edgeOffset.start + edgeOffset.end) ? edgeOffset : {
      start: 0,
      end: 0
    }, yOffset = scrollerRect.height >= elementRect.height + (edgeOffset.top + edgeOffset.bottom) ? edgeOffset : {
      top: 0,
      bottom: 0
    }, constrainTo = new Rectangle(isRTL ? scrollerRect.right - -x - scrollWidth : scrollerRect.x - x, scrollerRect.y - y, scrollWidth, scrollHeight), elRect = elementRect.clone().adjust(-xOffset.start, -yOffset.top, xOffset.end, yOffset.bottom).constrainTo(constrainTo), targetRect = elRect.clone(), xFactor = me.isRTL ? -1 : 1;
    let xDelta = 0, yDelta = 0;
    if (block === "start") {
      targetRect.moveTo(scrollerRect.x + (me.isRTL ? scrollerRect.width : 0), scrollerRect.y);
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    } else if (block === "end") {
      if (me.isRTL) {
        targetRect.moveTo(scrollerRect.left + (me.isRTL ? targetRect.width : 0), scrollerRect.y);
      } else {
        targetRect.translate(scrollerRect.right - targetRect.right, scrollerRect.bottom - targetRect.bottom);
      }
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    } else {
      if (block === "center") {
        const center = scrollerRect.center;
        targetRect.moveTo(center.x - targetRect.width / 2, center.y - targetRect.height / 2);
        xDelta = xDelta || elRect.x - targetRect.x;
        yDelta = yDelta || elRect.y - targetRect.y;
      } else {
        if (targetRect.width > scrollerRect.width) {
          xDelta = targetRect.x - scrollerRect.x;
        } else {
          if (targetRect.right > scrollerRect.right) {
            xDelta = targetRect.right - scrollerRect.right;
          } else if (targetRect.x < scrollerRect.x) {
            xDelta = targetRect.x - scrollerRect.x;
          }
        }
        if (targetRect.height > scrollerRect.height) {
          yDelta = targetRect.y - scrollerRect.y;
        } else {
          if (targetRect.bottom > scrollerRect.bottom) {
            yDelta = targetRect.bottom - scrollerRect.bottom;
          } else if (targetRect.y < scrollerRect.y) {
            yDelta = targetRect.y - scrollerRect.y;
          }
        }
      }
    }
    xDelta = xFactor * Math.round(xDelta);
    yDelta = Math.round(yDelta);
    return {
      xDelta: options.x === false ? 0 : Math.max(Math.min(xDelta, me.maxX - x), -x),
      yDelta: options.y === false ? 0 : Math.max(Math.min(yDelta, me.maxY - y), -y)
    };
  }
  get viewport() {
    return Rectangle.client(this.element);
  }
  updateWidget(widget) {
    this.rtlSource = this.owner = widget;
  }
  updateElement(element, oldElement) {
    const me = this;
    if (me === Scroller._globalScroller) {
      me._element = element;
      me.positionDirty = true;
      return;
    }
    const scrollHandler = me.scrollHandler || (me.scrollHandler = me.onScroll.bind(me)), resizeHandler = me.resizeHandler || (me.resizeHandler = me.onElResize.bind(me));
    if (oldElement) {
      if (me.translate) {
        var _me$mutationObserver;
        (_me$mutationObserver = me.mutationObserver) === null || _me$mutationObserver === void 0 ? void 0 : _me$mutationObserver.disconnect(oldElement);
      } else {
        oldElement.removeEventListener("scroll", scrollHandler);
        oldElement.classList.remove(scrollerCls);
        oldElement.style.overflowX = oldElement.style.overflowY = "";
      }
      ResizeMonitor.removeResizeListener(oldElement, resizeHandler);
    }
    if (element) {
      if (me.translate) {
        if (!me.mutationObserver) {
          me.mutationObserver = new MutationObserver(me.mutationHandler || (me.mutationHandler = me.onElMutation.bind(me)));
        }
        me._x = me._y = 0;
        if (document.contains(element)) {
          const [x, y] = DomHelper.getTranslateXY(element);
          me._x = -x;
          me._y = -y;
        }
        me.mutationObserver.observe(element, {
          attributes: true
        });
      } else {
        element.addEventListener("scroll", scrollHandler);
        element.classList.add(scrollerCls);
      }
      ResizeMonitor.addResizeListener(element, resizeHandler);
      if (!me.widget) {
        me.rtlSource = {
          get rtl() {
            return DomHelper.getStyleValue(element, "direction") === "rtl";
          }
        };
      }
      if (me.isRTL) {
        element.classList.add("b-rtl");
      }
      if (me.positionDirty) {
        me.updateOverflowX(me.overflowX);
        me.updateOverflowY(me.overflowY);
      }
      me.syncOverflowState();
      if (me.isConfiguring) {
        me._x && me.updateX(me._x);
        me._y && me.updateY(me._y);
      }
    }
    me.positionDirty = true;
  }
  get x() {
    const me = this, {
      element
    } = me;
    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        me._x = Math.abs(element.scrollLeft);
        me._y = element.scrollTop;
      }
      me.positionDirty = false;
    }
    return me._x;
  }
  get scrollLeft() {
    return this.element.scrollLeft;
  }
  changeX(x) {
    x = Math.max(x, 0);
    if (!this.isConfiguring || x) {
      return x;
    }
    this._x = x;
  }
  updateContentElement(contentElement) {
    if (contentElement) {
      contentElement = typeof contentElement === "string" ? this.element.querySelector(contentElement) : contentElement;
      ResizeMonitor.addResizeListener(contentElement, this.resizeHandler);
    }
  }
  updateX(x) {
    var _this$widget;
    const {
      element
    } = this;
    if (element && !((_this$widget = this.widget) !== null && _this$widget !== void 0 && _this$widget.isConfiguring)) {
      x = Math.round(x);
      this.trigger("scrollStart", {
        x
      });
      if (this.translate) {
        DomHelper.setTranslateX(element, -x);
      } else {
        element.scrollLeft = this.isRTL ? -x : x;
      }
    }
    this.positionDirty = true;
  }
  sync(controllingPartner, axes) {
    const me = this, {
      x,
      y
    } = axes;
    let result = false;
    if (x != null) {
      if (me.x !== controllingPartner.x) {
        me.controllingPartner = controllingPartner;
        me.x = controllingPartner.x;
        result = true;
      }
    }
    if (y != null) {
      if (me.y !== controllingPartner.y) {
        me.controllingPartner = controllingPartner;
        me.y = controllingPartner.y;
        result = true;
      }
    }
    return result;
  }
  get y() {
    const me = this, {
      element
    } = me;
    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        me._x = element.scrollLeft;
        me._y = element.scrollTop;
      }
      me.positionDirty = false;
    }
    return me._y;
  }
  changeY(y) {
    if (!this.isConfiguring || y) {
      return y;
    }
    this._y = y;
  }
  updateY(y) {
    const {
      element,
      widget
    } = this;
    if (element && !(widget !== null && widget !== void 0 && widget.isConfiguring)) {
      this.trigger("scrollStart", {
        y
      });
      if (this.translate) {
        DomHelper.setTranslateY(element, -y);
      } else {
        element.scrollTop = y;
      }
    }
    this.positionDirty = true;
  }
  get maxX() {
    return this.scrollWidth - this.clientWidth;
  }
  get maxY() {
    return this.scrollHeight - this.clientHeight;
  }
  get lastScrollLeft() {
    return (this.scrollWidth - this.clientWidth) * (this.isRTL ? -1 : 1);
  }
  updateOverflowX(overflowX, oldOverflowX) {
    const me = this, {
      element,
      translate
    } = me, {
      style,
      classList
    } = element;
    if (oldOverflowX === "hidden-scroll") {
      classList.remove("b-hide-scroll");
    }
    if (overflowX === "hidden-scroll" && !translate) {
      const otherAxisScrollable = isScrollable[style.overflowY];
      if (otherAxisScrollable) {
        overflowX = "hidden";
        me.enableWheel();
      } else {
        classList.add("b-hide-scroll");
      }
    }
    if (!translate) {
      style.overflowX = scrollLiterals[overflowX] || overflowX;
    }
    if (!me.isConfiguring) {
      me.positionDirty = true;
      me.syncOverflowState();
    }
  }
  updateOverflowY(overflowY, oldOverflowY) {
    const me = this, {
      element,
      translate
    } = me, {
      style,
      classList
    } = element;
    if (oldOverflowY === "hidden-scroll") {
      classList.remove("b-hide-scroll");
    }
    if (overflowY === "hidden-scroll" && !translate) {
      const otherAxisScrollable = isScrollable[style.overflowX];
      if (otherAxisScrollable) {
        overflowY = "hidden";
        me.enableWheel();
      } else {
        classList.add("b-hide-scroll");
      }
    }
    if (!translate) {
      style.overflowY = scrollLiterals[overflowY] || overflowY;
    }
    if (!me.isConfiguring) {
      me.positionDirty = true;
      me.syncOverflowState();
    }
  }
  enableWheel() {
    if (!this.wheelListenerRemover) {
      this.wheelListenerRemover = EventHelper.on({
        element: this.element,
        wheel: "onWheel",
        thisObj: this
      });
    }
  }
  onWheel(e) {
    if (Math.abs(e.deltaX) > Math.abs(e.deltaY) && this.overflowX === "hidden-scroll") {
      this.x += e.deltaX;
    } else if (this.overflowY === "hidden-scroll") {
      this.y += e.deltaY;
    }
  }
  get scrollWidth() {
    var _this$element$scrollW, _this$element;
    return (_this$element$scrollW = (_this$element = this.element) === null || _this$element === void 0 ? void 0 : _this$element.scrollWidth) !== null && _this$element$scrollW !== void 0 ? _this$element$scrollW : 0;
  }
  set scrollWidth(scrollWidth) {
    const me = this, {
      element,
      isRTL
    } = me;
    let stretcher = me.widthStretcher;
    if (stretcher && scrollWidth == null) {
      stretcher.remove();
      me.widthStretcher = null;
    } else if (scrollWidth) {
      scrollWidth = Math.abs(scrollWidth);
      if (!stretcher) {
        stretcher = me.widthStretcher = DomHelper.createElement({
          className: "b-scroller-stretcher b-horizontal-stretcher",
          retainElement: true
        });
      }
      stretcher.style.transform = `translateX(${(scrollWidth - 1) * (isRTL ? -1 : 1)}px)`;
      if (element && !element.contains(stretcher)) {
        element.insertBefore(stretcher, element.firstElementChild);
      }
    }
    if (me.propagate !== false) {
      me.eachPartner(({
        scroller
      }) => {
        scroller.propagate = false;
        scroller.scrollWidth = scrollWidth;
        delete scroller.propagate;
      });
    }
    me.positionDirty = true;
    me.syncOverflowState();
  }
  get scrollHeight() {
    var _this$element$scrollH, _this$element2;
    return (_this$element$scrollH = (_this$element2 = this.element) === null || _this$element2 === void 0 ? void 0 : _this$element2.scrollHeight) !== null && _this$element$scrollH !== void 0 ? _this$element$scrollH : 0;
  }
  set scrollHeight(scrollHeight) {
    const me = this, stretcher = me.stretcher || (me.stretcher = DomHelper.createElement({
      className: "b-scroller-stretcher"
    }));
    stretcher.style.transform = `translateY(${scrollHeight - 1}px)`;
    if (me.element && me.element.lastChild !== stretcher) {
      me.element.appendChild(stretcher);
    }
    me.positionDirty = true;
    me.syncOverflowState();
  }
  get clientWidth() {
    var _this$element3;
    return ((_this$element3 = this.element) === null || _this$element3 === void 0 ? void 0 : _this$element3.clientWidth) || 0;
  }
  get clientHeight() {
    var _this$element4;
    return ((_this$element4 = this.element) === null || _this$element4 === void 0 ? void 0 : _this$element4.clientHeight) || 0;
  }
  get id() {
    if (!this._id) {
      if (this.widget) {
        this._id = `${this.widget.id}-scroller`;
      } else {
        this._id = IdHelper.generateId("scroller-");
      }
    }
    return this._id;
  }
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs();
    delete configs.widget;
    delete configs.element;
  }
};
Scroller._$name = "Scroller";
var Promissory = class {
  constructor(fn2) {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
    if (fn2) {
      fn2(this);
    }
  }
};
Promissory._$name = "Promissory";
var {
  defineProperty: defineProperty$2
} = Reflect;
var Renderable = class extends Base$1.mixin(Localizable, Events, Delayable, Identifiable) {
  static get configurable() {
    return {
      element: null
    };
  }
  static get delayable() {
    return {
      refreshDom: "raf"
    };
  }
  static get identifiable() {
    return {};
  }
  static get renderConfigs() {
    const me = this, meta = me.$meta;
    let renderConfigs = meta.renderConfigs, configs, name;
    if (renderConfigs === void 0) {
      renderConfigs = null;
      configs = meta.configs;
      for (name in configs) {
        if (configs[name].render) {
          (renderConfigs || (renderConfigs = /* @__PURE__ */ new Set())).add(name);
        }
      }
      meta.renderConfigs = me.prototype.$renderConfigs = renderConfigs;
    }
    return renderConfigs;
  }
  construct(...args) {
    this.$iid = ++Renderable.$idSeed;
    this.byRef = {};
    super.construct(...args);
    if (this.onDraw !== Renderable.prototype.onDraw) {
      this.initDrawable();
    }
  }
  startConfigure(config) {
    this.element = this.renderContext.renderDom();
    super.startConfigure(config);
  }
  get element() {
    this.refreshDom.flush();
    return this._element;
  }
  changeElement(element, oldElement) {
    const me = this;
    if (oldElement) {
      oldElement.remove();
    }
    if (element) {
      element.id = me.id;
      element = DomHelper.createElement(element, {
        refOwner: me
      });
    }
    return element;
  }
  updateId(id, oldId) {
    const me = this;
    if (oldId) {
      const element = me.element;
      element.id = id;
      me.fixRefOwnerId(element, id, oldId);
    }
  }
  get classes() {
    return this.element.classList;
  }
  fixRefOwnerId(el, id, oldId) {
    if (el.$refOwnerId === oldId) {
      el.$refOwnerId = id;
      const ref = el.$reference;
      if (ref) {
        el.id = `${id}-${ref}`;
      }
      for (const c of el.childNodes) {
        this.fixRefOwnerId(c, id, oldId);
      }
    }
  }
  onConfigChange({
    name
  }) {
    if (!this.isConfiguring && this.$renderConfigs.has(name)) {
      this.refreshDom();
    }
  }
  attachRef(name, el, domConfig) {
    const me = this, key = "_" + name, {
      listeners
    } = domConfig;
    if (!(key in me)) {
      defineProperty$2(me, name, {
        get() {
          me.refreshDom.flush();
          return me[key];
        },
        set(el2) {
          me[key] = el2;
        }
      });
    }
    el.id = `${me.id}-${name}`;
    me.byRef[name] = el;
    me[name] = el;
    if (listeners) {
      domConfig.listeners = {
        on: listeners,
        un: EventHelper.on(Object.assign({
          element: el,
          thisObj: me
        }, listeners))
      };
    }
  }
  detachRef(name, el, domConfig) {
    if (domConfig.listeners) {
      domConfig.listeners.un();
      domConfig.listeners = null;
    }
    this[name] = null;
    delete this.byRef[name];
  }
  renderDom() {
    return {};
  }
  get renderContext() {
    const me = this, meta = me.$meta, C = me.constructor;
    let renderConfigs = meta.renderConfigs || C.renderConfigs, context = me;
    if (!renderConfigs) {
      context = Object.create(me);
      renderConfigs = /* @__PURE__ */ new Set();
      for (const name in meta.configs) {
        defineProperty$2(context, name, {
          get() {
            renderConfigs.add(name);
            return me[name];
          }
        });
      }
      context.renderDom = () => {
        return me.renderDom.call(context);
      };
      me.$renderConfigs = renderConfigs;
    }
    defineProperty$2(me, "renderContext", {
      value: context
    });
    return context;
  }
  refreshDom() {
    DomSync.sync({
      targetElement: this.element,
      domConfig: this.renderContext.renderDom(),
      refOwner: this,
      strict: true
    });
  }
  onListen(eventName) {
    if (eventName === "draw") {
      this.initDrawable();
    }
  }
  initDrawable() {
    const me = this;
    if (!me.intersector) {
      let el = Object.values(me.byRef).find((el2) => el2.classList.contains("b-drawable"));
      if (!el) {
        el = me.element;
        el.classList.add("b-drawable");
      }
      me.intersector = new IntersectionObserver((entries) => {
        if (!me.isDestroyed) {
          entries.forEach((ent) => {
            if (ent.isIntersecting) {
              me.onDraw({
                count: ++me.drawCounter
              });
            }
          });
        }
      });
      me.intersector.observe(el);
    }
  }
  onDraw(ev) {
    this.trigger("draw", ev);
  }
};
Renderable.$idSeed = 0;
Object.assign(Renderable.prototype, {
  drawCounter: 0,
  hasGeneratedId: false,
  intersector: null
});
Renderable._$name = "Renderable";
var Mask = class extends Renderable {
  construct(config) {
    if (config) {
      let el = config.element, cfg;
      if (el) {
        VersionHelper.deprecate("Core", "4.0.0", 'Mask "element" config has been renamed to "target"');
        config = cfg = Object.assign({}, config);
        delete cfg.element;
        cfg.target = el;
      }
      el = config.target;
      if (typeof el === "string") {
        config = cfg = cfg || Object.assign({}, config);
        cfg.target = config.owner[el];
      }
    }
    super.construct(config);
    const me = this, {
      type
    } = me;
    if (!me.target) {
      me.target = document.body;
    }
    me.maskName = `mask${typeof type === "string" ? type.trim() : ""}-${Mask.counter++}`;
    me.show();
  }
  doDestroy() {
    const me = this, {
      element
    } = me;
    if (me.type === "trial") {
      return false;
    }
    if (element) {
      me.element = null;
      if (me.mode.endsWith("blur")) {
        DomHelper.forEachChild(element, (child) => {
          child.classList.remove(`b-masked-${me.mode}`);
        });
      }
      me.target.classList.remove("b-masked");
      me.target[me.maskName] = null;
      ArrayHelper.remove(Mask.masks, me);
    }
    super.doDestroy();
  }
  get maskElement() {
    return this.element;
  }
  set error(value) {
    this.setConfig(this.errorDefaults);
    this.text = value;
  }
  renderDom() {
    const me = this, {
      maxProgress
    } = me;
    return {
      class: {
        "b-mask": 1,
        "b-delayed-show": me.showDelay,
        "b-widget": 1,
        [`b-mask-${me.mode}`]: 1,
        "b-progress": maxProgress,
        "b-prevent-transitions": !me.useTransition
      },
      children: [{
        reference: "maskContent",
        class: "b-mask-content b-drawable",
        children: [maxProgress ? {
          reference: "progressElement",
          class: "b-mask-progress-bar",
          style: {
            width: `${Math.max(0, Math.min(100, Math.round(me.progress / maxProgress * 100)))}%`
          }
        } : null, {
          reference: "maskText",
          class: "b-mask-text",
          html: (me.icon ? `<i class="b-mask-icon ${me.icon}"></i>` : "") + me.text
        }]
      }]
    };
  }
  static mergeConfigs(...sources) {
    const ret = {};
    for (const src of sources) {
      if (typeof src === "string") {
        ret.text = src;
      } else {
        ObjectHelper.assign(ret, src);
      }
    }
    return ret;
  }
  static mask(text, target = document.body) {
    return Mask.new({
      target
    }, typeof text !== "string" ? _objectSpread2({}, text) : {
      text
    });
  }
  static unmask(element = document.body) {
    const masks = this.getElementMasks(element);
    if (masks.length > 0) {
      return masks[masks.length - 1].close();
    }
    return null;
  }
  static unmaskAll(element = document.body) {
    return this.getElementMasks(element).forEach((mask) => mask.close());
  }
  static getElementMasks(element) {
    return this.masks.filter((mask) => mask.target === element);
  }
  updateAutoClose(delay2) {
    this.deferredClose.cancel();
    if (delay2) {
      this.deferredClose.delay = delay2;
      this.deferredClose();
    }
  }
  updateCover() {
    this.syncCover();
  }
  syncCover() {
    var _this$owner, _this$owner$syncMaskC;
    (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : (_this$owner$syncMaskC = _this$owner.syncMaskCover) === null || _this$owner$syncMaskC === void 0 ? void 0 : _this$owner$syncMaskC.call(_this$owner, this);
  }
  onOwnerResize() {
    this.syncCover();
  }
  updateOwner(owner) {
    this.detachListeners("cover");
    owner === null || owner === void 0 ? void 0 : owner.ion({
      name: "cover",
      recompose: "onOwnerResize",
      resize: "onOwnerResize",
      thisObj: this
    });
  }
  updateShowDelay(delay2) {
    const {
      delayedShow
    } = this;
    delayedShow.delay = delay2;
    if (!delay2) {
      delayedShow.flush();
    }
  }
  deferredClose() {
    var _owner$onMaskAutoClos2;
    const {
      owner
    } = this;
    this.close().then(() => {
      var _owner$onMaskAutoClos;
      owner === null || owner === void 0 ? void 0 : (_owner$onMaskAutoClos = owner.onMaskAutoClose) === null || _owner$onMaskAutoClos === void 0 ? void 0 : _owner$onMaskAutoClos.call(owner, this);
    });
    owner === null || owner === void 0 ? void 0 : (_owner$onMaskAutoClos2 = owner.onMaskAutoClosing) === null || _owner$onMaskAutoClos2 === void 0 ? void 0 : _owner$onMaskAutoClos2.call(owner, this);
  }
  delayedShow() {
    this.classes.remove("b-delayed-show");
  }
  show() {
    const me = this, {
      element,
      target,
      hiding,
      maskName
    } = me;
    if (hiding) {
      hiding.resolve();
      me.hiding = null;
      me.clearTimeout("hide");
    }
    if (me.showDelay) {
      element.classList.add("b-delayed-show");
      me.delayedShow();
    }
    element.classList.add("b-visible");
    element.classList.remove("b-hidden");
    target.classList.add("b-masked");
    if (!target[maskName]) {
      target[maskName] = me;
      target.appendChild(element);
    }
    ArrayHelper.include(Mask.masks, me);
    me.shown = true;
    me.trigger("show");
    if (me.mode.endsWith("blur")) {
      DomHelper.forEachChild(target, (child) => {
        if (child !== element) {
          child.classList.add(`b-masked-${me.mode}`);
        }
      });
    }
  }
  hide() {
    const me = this, {
      target,
      element
    } = me;
    let {
      hiding
    } = me;
    if (!hiding) {
      if (!me.shown) {
        return Promise.resolve();
      }
      me.hiding = hiding = new Promissory();
      me.shown = false;
      element.classList.remove("b-visible");
      element.classList.add("b-hidden");
      target.classList.remove("b-masked");
      if (me.mode.endsWith("blur")) {
        DomHelper.forEachChild(target, (child) => {
          if (child !== element) {
            child.classList.remove(`b-masked-${me.mode}`);
          }
        });
      }
      hiding.promise = hiding.promise.then(() => {
        if (me.hiding === hiding) {
          me.hiding = null;
        }
      });
      me.setTimeout(() => hiding.resolve(), 500, "hide");
    }
    return hiding.promise;
  }
  async close() {
    await this.hide();
    this.destroy();
  }
};
_defineProperty(Mask, "$name", "Mask");
_defineProperty(Mask, "type", "mask");
_defineProperty(Mask, "configurable", {
  autoClose: null,
  cover: null,
  icon: "b-icon b-icon-spinner",
  errorDefaults: {
    icon: "b-icon b-icon-warning",
    autoClose: 3e3,
    showDelay: 0
  },
  maxProgress: null,
  mode: "dark",
  progress: null,
  owner: {
    $config: "nullify",
    value: null
  },
  target: null,
  text: null,
  type: null,
  showDelay: null,
  useTransition: false
});
_defineProperty(Mask, "delayable", {
  deferredClose: 0,
  delayedShow: 0,
  syncCover: {
    type: "throttle",
    delay: 100
  }
});
_defineProperty(Mask, "counter", 0);
_defineProperty(Mask, "masks", []);
Mask._$name = "Mask";
var KeyMap = (Target) => {
  var _class;
  return _class = class KeyMap extends (Target || Base$1) {
    get widgetClass() {
    }
    get keyMapElement() {
      return this.element;
    }
    get keyMapSubComponents() {
      return this.features;
    }
    performKeyMapAction(keyEvent) {
      const {
        keyMap
      } = this;
      let actionHandled = false;
      if (keyMap && !keyEvent.handled && keyEvent.key !== void 0) {
        const keyCombination = ObjectHelper.keys(keyMap).find((keyString) => {
          const keys = keyString.split("+"), requireAlt = keys.includes("Alt"), requireShift = keys.includes("Shift"), requireCtrl = keys.includes("Ctrl");
          let actualKey = keys[keys.length - 1].toLowerCase();
          if (actualKey === "space") {
            actualKey = " ";
          }
          return actualKey === keyEvent.key.toLowerCase() && (!keyEvent.altKey && !requireAlt || keyEvent.altKey && requireAlt) && (!keyEvent.ctrlKey && !requireCtrl || keyEvent.ctrlKey && requireCtrl) && (!keyEvent.shiftKey && !requireShift || keyEvent.shiftKey && requireShift);
        });
        if (keyMap[keyCombination]) {
          const actions = ArrayHelper.asArray(keyMap[keyCombination]);
          keyEvent.fromKeyMap = true;
          let preventDefault2;
          for (let action of actions) {
            preventDefault2 = true;
            if (ObjectHelper.isObject(action)) {
              if (!action.handler) {
                continue;
              }
              if (action.preventDefault === false) {
                preventDefault2 = false;
              }
              action = action.handler;
            }
            if (typeof action === "string") {
              var _thisObj$isActionAvai;
              const {
                thisObj,
                handler
              } = this.resolveKeyMapAction(action);
              if (((_thisObj$isActionAvai = thisObj.isActionAvailable) === null || _thisObj$isActionAvai === void 0 ? void 0 : _thisObj$isActionAvai.call(thisObj, keyCombination, action, keyEvent)) !== false) {
                if (handler.call(thisObj, keyEvent) !== false) {
                  actionHandled = true;
                  break;
                }
              }
            } else if (action.call(this) !== false) {
              actionHandled = true;
              break;
            }
          }
          delete keyEvent.fromKeyMap;
          if (actionHandled) {
            if (preventDefault2) {
              keyEvent.preventDefault();
            }
            keyEvent.handled = true;
          }
        }
      }
      return actionHandled;
    }
    resolveKeyMapAction(action) {
      const {
        keyMapSubComponents
      } = this;
      if (keyMapSubComponents && action.includes(".")) {
        const [component, actionName] = action.split(".");
        if (component && actionName) {
          return {
            thisObj: keyMapSubComponents[component],
            handler: keyMapSubComponents[component][actionName]
          };
        }
      }
      return {
        thisObj: this,
        handler: this[action]
      };
    }
    updateKeyMap(keyMap) {
      var _this$keyMapDetacher;
      (_this$keyMapDetacher = this.keyMapDetacher) === null || _this$keyMapDetacher === void 0 ? void 0 : _this$keyMapDetacher.call(this);
      if (!ObjectHelper.isEmpty(keyMap)) {
        this.keyMapDetacher = EventHelper.on({
          element: this.keyMapElement,
          keydown: "keyMapOnKeyDown",
          thisObj: this
        });
      }
    }
    keyMapOnKeyDown(event) {
      this.performKeyMapAction(event);
    }
    mergeKeyMaps(target, source, subPrefix = null) {
      const mergedKeyMap = {};
      if (target) {
        ObjectHelper.assign(mergedKeyMap, target);
      }
      for (const key in source) {
        if (!source[key]) {
          continue;
        }
        const existingActions = ArrayHelper.asArray(target === null || target === void 0 ? void 0 : target[key]), actions = [];
        if (existingActions !== null && existingActions !== void 0 && existingActions.length) {
          actions.push(...existingActions);
        }
        for (const action of ArrayHelper.asArray(source[key])) {
          if (ObjectHelper.isObject(action) && action.handler) {
            actions.push(ObjectHelper.assignIf({
              handler: (subPrefix ? subPrefix + "." : "") + action.handler
            }, action));
          } else {
            actions.push((subPrefix ? subPrefix + "." : "") + action);
          }
        }
        actions.sort((a, b) => {
          const weight = (a.weight || 0) - (b.weight || 0);
          if (weight === 0 && existingActions !== null && existingActions !== void 0 && existingActions.length) {
            return existingActions.indexOf(a) - existingActions.indexOf(b);
          }
          return weight;
        });
        mergedKeyMap[key] = actions;
      }
      return mergedKeyMap;
    }
  }, _defineProperty(_class, "$name", "KeyMap"), _defineProperty(_class, "configurable", {
    keyMap: {
      value: null,
      $config: {
        merge: "objects",
        nullify: true
      }
    }
  }), _class;
};
var RTL = (Target) => {
  var _class;
  return _class = class RTL extends (Target || Base$1) {
    get widgetClass() {
    }
    updateRtl(rtl) {
      const {
        element
      } = this;
      if (element) {
        element.classList.toggle("b-rtl", rtl === true);
        element.classList.toggle("b-ltr", rtl === false);
      }
    }
    startConfigure(config) {
      var _super$startConfigure;
      (_super$startConfigure = super.startConfigure) === null || _super$startConfigure === void 0 ? void 0 : _super$startConfigure.call(this, arguments);
      if (!config.floating && config.rtl == null) {
        var _me$parent;
        const me = this, el = config.rootElement || config.forElement || ((_me$parent = me.parent) === null || _me$parent === void 0 ? void 0 : _me$parent.contentElement) || (me.floating ? me.floatRoot : me.changeElementRef(me.getRenderContext(config)[0] || config.adopt || document.body)), owner = config.owner || config.parent || me.constructor.fromElement(el);
        if (owner) {
          config.rtl = owner[owner.isConfiguring ? "peekConfig" : "getConfig"]("rtl");
        } else {
          config.rtl = (el === null || el === void 0 ? void 0 : el.nodeType) === 1 && getComputedStyle(el).getPropertyValue("direction") === "rtl";
        }
        if (config.rtl) {
          me.configDone.rtl = false;
        }
      }
    }
    render(...args) {
      var _this$owner;
      super.render && super.render(...args);
      if (BrowserHelper.isChrome && BrowserHelper.chromeVersion < 87 || BrowserHelper.isFirefox && BrowserHelper.firefoxVersion < 66 || BrowserHelper.isSafari && BrowserHelper.safariVersion < 14.1) {
        this.element.classList.add("b-legacy-inset");
      }
      if (getComputedStyle(this.element).direction === "rtl" || (_this$owner = this.owner) !== null && _this$owner !== void 0 && _this$owner.rtl) {
        var _this$childItems;
        this.rtl = true;
        (_this$childItems = this.childItems) === null || _this$childItems === void 0 ? void 0 : _this$childItems.forEach((i) => i.rtl = true);
      }
    }
  }, _defineProperty(_class, "$name", "RTL"), _defineProperty(_class, "configurable", {
    rtl: null
  }), _class;
};
var assignValueDefaults = Object.freeze({
  highlight: false,
  onlyName: false
});
var floatRoots = [];
var highlightExternalChange = "highlightExternalChange";
var isTransparent = /transparent|rgba\(0,\s*0,\s*0,\s*0\)/;
var textInputTypes = {
  INPUT: 1,
  TEXTAREA: 1
};
var addElementListeners = (me, element, domConfig, refName) => {
  var _listeners;
  let listeners = (domConfig === null || domConfig === void 0 ? void 0 : domConfig.listeners) || (domConfig === null || domConfig === void 0 ? void 0 : domConfig.internalListeners);
  listeners = ((_listeners = listeners) === null || _listeners === void 0 ? void 0 : _listeners.ion) || listeners;
  if (listeners) {
    const un = EventHelper.on(ObjectHelper.assign({
      element,
      thisObj: me
    }, listeners));
    if (refName) {
      (me._refListeners || (me._refListeners = /* @__PURE__ */ Object.create(null)))[refName] = un;
    } else {
      domConfig.listeners = {
        on: listeners,
        un
      };
    }
  }
};
var mergeAnim = (value, was) => {
  return value && was && was[ObjectHelper.keys(value)[0]] ? Config.merge(value, was) : value;
};
var widgetTriggerPaint = (w) => {
  w.isVisible && w.triggerPaint();
};
var negationPseudo = /^:not\((.+)\)$/;
var nonFlowedPositions = /absolute|fixed/i;
var isScaled = (w) => w.scale != null;
var {
  hasOwnProperty: hasOwnProperty$2
} = Object.prototype;
var {
  defineProperty: defineProperty$1
} = Reflect;
var parseDuration = (d) => parseFloat(d) * (d.endsWith("ms") ? 1 : 1e3);
var alignedClass = ["b-aligned-above", "b-aligned-right", "b-aligned-below", "b-aligned-left"];
var returnFalseProp = {
  configurable: true,
  get() {
    return false;
  }
};
var localizeRE = /(?:L\{([^}.]+)\})/;
var localizeTooltip = (string2, part) => "L{Tooltip." + part + "}";
var alignSpecRe = /^([trblc])(\d*)-([trblc])(\d*)$/i;
var mergeAlign = (oldValue, newValue) => {
  if (alignSpecRe.test(oldValue)) {
    oldValue = {
      align: oldValue
    };
  }
  if (alignSpecRe.test(newValue)) {
    newValue = {
      align: newValue
    };
  }
  return Config.merge(oldValue, newValue);
};
var callbackRe = /^[\w.]+$/;
var Widget = class extends Base$1.mixin(Localizable, Events, Delayable, Identifiable, Factoryable, KeyMap, RTL) {
  static mergeCls(newValue, oldValue) {
    if (oldValue && newValue) {
      newValue = new DomClassList(oldValue).assign(typeof newValue === "string" ? new DomClassList(newValue) : newValue);
    } else if (newValue && !newValue.isDomClassList) {
      newValue = new DomClassList(newValue);
    }
    return newValue;
  }
  static get $name() {
    return "Widget";
  }
  static get type() {
    return "widget";
  }
  static get configurable() {
    return {
      element: true,
      callOnFunctions: true,
      id: "",
      html: null,
      content: null,
      cls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      ui: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      collapsify: null,
      contentElementCls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      defaultCls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      dock: null,
      forwardTwinEvents: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      parent: null,
      tab: null,
      elementAttributes: null,
      htmlCls: {
        $config: {
          merge: "classList"
        },
        value: {
          "b-html": 1
        }
      },
      style: null,
      disabled: null,
      readOnly: {
        value: null,
        default: false,
        $config: null
      },
      ignoreParentReadOnly: null,
      adopt: null,
      appendTo: null,
      insertBefore: null,
      insertFirst: null,
      dataset: null,
      tooltip: {
        $config: ["lazy", "nullify"],
        value: null
      },
      showTooltipWhenDisabled: true,
      preventTooltipOnTouch: null,
      monitorResize: {
        $config: ["lazy", "nullify"],
        value: null
      },
      masked: {
        $config: "nullify",
        value: null
      },
      maskDefaults: {
        target: "element"
      },
      cache: {},
      floating: null,
      positioned: null,
      draggable: null,
      align: {
        $config: {
          merge: mergeAlign
        },
        value: "t-b"
      },
      centered: null,
      constrainTo: void 0,
      anchor: null,
      owner: null,
      scrollAction: null,
      hideAnimation: {
        $config: {
          merge: mergeAnim
        },
        value: null
      },
      showAnimation: {
        $config: {
          merge: mergeAnim
        },
        value: null
      },
      x: null,
      y: null,
      scrollable: {
        $config: ["lazy", "nullify"],
        value: null
      },
      scrollerClass: Scroller,
      defaultBindProperty: "html",
      defaultAction: null,
      overflowable: {
        value: null,
        default: true,
        $config: null
      },
      width: null,
      height: null,
      maxHeight: null,
      maxWidth: null,
      minWidth: null,
      minHeight: null,
      scaleToFitWidth: null,
      allowGrowWidth: true,
      margin: null,
      flex: null,
      weight: null,
      alignSelf: null,
      ripple: null,
      title: null,
      localizableProperties: ["title", "ariaLabel", "ariaDescription"],
      requireSize: false,
      ref: null,
      hidden: null,
      textAlign: null,
      ignoreScrollDuration: 500,
      tag: "div",
      recomposeAsync: null,
      rootElement: null,
      htmlMutationObserver: {
        $config: ["lazy", "nullify"],
        value: {
          childList: true,
          subtree: true
        }
      },
      role: {
        $config: "lazy",
        value: "presentation"
      },
      ariaLabel: {
        $config: "lazy",
        value: null
      },
      ariaDescription: {
        $config: "lazy",
        value: null
      },
      ariaElement: "element",
      ariaHasPopup: null,
      realignTimeout: 300,
      testConfig: {
        ignoreScrollDuration: 100,
        realignTimeout: 50
      }
    };
  }
  static get prototypeProperties() {
    return {
      hasGeneratedId: false,
      innerItem: true
    };
  }
  static get declarable() {
    return [
      "renderConfigs"
    ];
  }
  static get delayable() {
    return {
      recompose: "raf",
      doHideOrRealign: "raf",
      onAlignConstraintChange: "raf"
    };
  }
  static get factoryable() {
    return {
      defaultType: "widget"
    };
  }
  static get identifiable() {
    return {};
  }
  static get all() {
    return super.all;
  }
  static get recomposeAsync() {
    return Widget._recomposeAsync;
  }
  static set recomposeAsync(value) {
    Widget._recomposeAsync = value;
    if (value != null) {
      const {
        all
      } = Widget;
      for (let i = 0; i < all.length; ++i) {
        if (all[i].isComposable) {
          all[i].recomposeAsync = value;
        }
      }
    }
  }
  isType(type, deep) {
    return Widget.isType(this, type, deep);
  }
  static setupRenderConfigs(cls, meta) {
    let {
      renderConfigs
    } = cls, i;
    if (renderConfigs) {
      const obj = meta.getInherited("renderConfigs", false) || /* @__PURE__ */ Object.create(null);
      if (Array.isArray(renderConfigs)) {
        for (i = 0; i < renderConfigs.length; ++i) {
          obj[renderConfigs[i]] = true;
        }
        renderConfigs = obj;
      } else {
        renderConfigs = Object.assign(obj, renderConfigs);
      }
    }
    meta.renderConfigs = renderConfigs;
  }
  construct(config = {}, ...args) {
    const me = this, {
      domSyncCallback
    } = me;
    me.configureAriaDescription = config.ariaDescription;
    me._isAnimatingCounter = 0;
    me.alignConstrained = 0;
    me.byRef = /* @__PURE__ */ Object.create(null);
    me.onTargetResize = me.onTargetResize.bind(me);
    me.onFullscreenChange = me.onFullscreenChange.bind(me);
    me.domSyncCallback = domSyncCallback.$nullFn ? null : domSyncCallback.bind(me);
    me._isUserAction = false;
    super.construct(config, ...args);
    const {
      recomposeAsync
    } = Widget;
    if (recomposeAsync != null && me.recomposeAsync == null) {
      me.recomposeAsync = recomposeAsync;
    }
    me.finalizeInit();
  }
  startConfigure(config) {
    super.startConfigure(config);
    const me = this, {
      adopt,
      element
    } = me;
    if (adopt) {
      me.adoptElement(element, adopt, config.id);
      me.updateElement(me._element, element);
    }
  }
  finalizeInit() {
    const me = this;
    if (me.insertBefore || me.appendTo || me.insertFirst || me.adopt) {
      me.render();
    }
  }
  doDestroy() {
    const me = this, {
      preExistingElements,
      element,
      _refListeners
    } = me;
    if (_refListeners) {
      Object.values(_refListeners, (un) => un());
      me._refListeners = null;
    }
    if (element) {
      var _Widget$Tooltip, _me$dragEventDetacher, _me$dragOverEventDeta;
      const sharedTooltip = !me._tooltip && me._rootElement && ((_Widget$Tooltip = Widget.Tooltip) === null || _Widget$Tooltip === void 0 ? void 0 : _Widget$Tooltip.getSharedTooltip(me._rootElement, true));
      if ((sharedTooltip === null || sharedTooltip === void 0 ? void 0 : sharedTooltip.owner) === me) {
        sharedTooltip.owner = null;
        sharedTooltip.hide();
      }
      me.onExitFullscreen();
      me.clearTimeout(me.scrollListenerTimeout);
      me.clearTimeout(me.resizeListenerTimeout);
      me.removeTransientListeners();
      if (me.floating || me.positioned) {
        me.hide(false);
      } else {
        me.revertFocus();
      }
      ResizeMonitor.removeResizeListener(element.parentElement, me.onParentElementResize);
      ResizeMonitor.removeResizeListener(element, me.onElementResize);
      if (me.adopt) {
        for (let nodes = Array.from(element.childNodes), i = 0, {
          length
        } = nodes; i < length; i++) {
          const el = nodes[i];
          if (!preExistingElements.includes(el) && el !== me.floatRoot) {
            el.remove();
          }
        }
        element.className = me.adoptedElementClassName;
        element.style.cssText = me.adoptedElementCssText;
      } else {
        element.remove();
      }
      (_me$dragEventDetacher = me.dragEventDetacher) === null || _me$dragEventDetacher === void 0 ? void 0 : _me$dragEventDetacher.call(me);
      (_me$dragOverEventDeta = me.dragOverEventDetacher) === null || _me$dragOverEventDeta === void 0 ? void 0 : _me$dragOverEventDeta.call(me);
      me.dragGhost.remove();
    }
    super.doDestroy();
  }
  get assignValueDefaults() {
    return assignValueDefaults;
  }
  get valueName() {
    return this.name || this.ref || this.id;
  }
  getValueName(onlyName) {
    onlyName = onlyName && typeof onlyName === "object" ? onlyName.onlyName : onlyName;
    return onlyName ? this.name : this.valueName;
  }
  assignFieldValue(values, key, value) {
    const me = this, valueBindProperty = me.defaultBindProperty;
    if (valueBindProperty in me) {
      me[valueBindProperty] = value;
    }
  }
  assignValue(values, options) {
    options = options || assignValueDefaults;
    const me = this, hec = me[highlightExternalChange], key = me.getValueName(options);
    if (key && (!values || key in values)) {
      if (options.highlight === false) {
        me[highlightExternalChange] = false;
      }
      me.assignFieldValue(values, key, values ? values[key] : null);
      me[highlightExternalChange] = hec;
    }
  }
  gatherValue(values) {
    const me = this, valueBindProperty = me.defaultBindProperty;
    if (me.constructor !== Widget && valueBindProperty in me) {
      values[me.name || me.ref || me.id] = me[valueBindProperty];
    }
  }
  gatherValues(values) {
    this.eachWidget((widget) => widget.gatherValue(values), false);
  }
  get forwardTwinEvents() {
    const value = this._forwardTwinEvents;
    return value && ObjectHelper.getTruthyKeys(value);
  }
  configureOverflowTwin(overrides) {
    var _me$forwardTwinEvents;
    const me = this;
    let config = ObjectHelper.clone(me.initialConfig);
    delete config.id;
    config.hidden = false;
    config.type = me.type;
    config._overflowTwinOrigin = me;
    config.disabled = me.disabled;
    if ("value" in me) {
      config.value = me.value;
    }
    (_me$forwardTwinEvents = me.forwardTwinEvents) === null || _me$forwardTwinEvents === void 0 ? void 0 : _me$forwardTwinEvents.forEach((ev) => {
      delete config[`on${StringHelper.capitalize(ev)}`];
    });
    if (overrides) {
      config = typeof overrides === "function" ? overrides(config) || config : ObjectHelper.assign(config, overrides);
    }
    return config;
  }
  createOverflowTwin(overrides) {
    var _me$forwardTwinEvents2;
    const me = this, config = me.configureOverflowTwin(overrides), overflowTwin = Widget.create(config);
    (_me$forwardTwinEvents2 = me.forwardTwinEvents) === null || _me$forwardTwinEvents2 === void 0 ? void 0 : _me$forwardTwinEvents2.forEach((ev) => {
      overflowTwin.ion({
        [ev]: (info) => {
          if (me.overflowTwin === info.source) {
            info = ObjectHelper.assign({}, info);
            delete info.source;
            me.trigger(info.type, info);
          }
        }
      });
    });
    return overflowTwin;
  }
  ensureOverflowTwin(overrides, onCreate) {
    let {
      overflowTwin
    } = this;
    if (!overflowTwin) {
      this.overflowTwin = overflowTwin = this.createOverflowTwin(overrides);
      onCreate === null || onCreate === void 0 ? void 0 : onCreate(overflowTwin);
    }
    return overflowTwin;
  }
  get isComposable() {
    return !this.compose.$nullFn;
  }
  adoptElement(element, adopt, id) {
    const me = this, adoptElement = typeof adopt === "string" ? document.getElementById(adopt) : adopt, previousHolder = Widget.fromElement(adoptElement);
    if (previousHolder && previousHolder.adopt && previousHolder !== me) {
      const previousHolderAdopt = typeof previousHolder.adopt === "string" ? document.getElementById(previousHolder.adopt) : previousHolder.adopt;
      if (previousHolderAdopt === adoptElement) {
        previousHolder.destroy();
      }
    }
    me.preExistingElements = Array.from(adoptElement.childNodes);
    me.adoptedElementClassName = adoptElement.className;
    me.adoptedElementCssText = adoptElement.style.cssText;
    if (adoptElement.id && !id) {
      me.id = element.id = adoptElement.id;
    }
    DomHelper.syncAttributes(element, adoptElement);
    for (let i = 0, {
      length
    } = element.childNodes; i < length; i++) {
      adoptElement.appendChild(element.childNodes[0]);
    }
    delete me._contentRange;
    me._element = adoptElement;
    const domConfig = element.lastDomConfig, listeners = domConfig === null || domConfig === void 0 ? void 0 : domConfig.listeners;
    if (listeners && me.isComposable) {
      var _listeners$un;
      (_listeners$un = listeners.un) === null || _listeners$un === void 0 ? void 0 : _listeners$un.call(listeners);
      addElementListeners(me, adoptElement, domConfig);
    }
    adoptElement.lastDomConfig = domConfig || adoptElement.lastDomConfig;
    adoptElement.$refOwnerId = me.id;
    if (!me.scaleToFitWidth) {
      me.getConfig("monitorResize");
    }
  }
  addRefAccessor(name, key) {
    const {
      prototype: prototype2
    } = this.constructor;
    defineProperty$1(prototype2, key, {
      writable: true,
      value: null
    });
    defineProperty$1(prototype2, name, {
      get() {
        this.recompose.flush();
        return this[key];
      },
      set(el) {
        this[key] = el;
      }
    });
  }
  attachRef(name, el, domConfig) {
    const me = this, key = "_" + name;
    el.dataset && (el.dataset.ownerCmp = me.id);
    if (me.isComposable) {
      if (!(key in me)) {
        me.addRefAccessor(name, key);
      }
      addElementListeners(me, el, domConfig, name);
    }
    me.byRef[name] = el;
    me[name] = el;
  }
  detachRef(name, el, domConfig) {
    const me = this, listeners = me._refListeners;
    if (listeners !== null && listeners !== void 0 && listeners[name]) {
      listeners[name]();
      delete listeners[name];
    }
    me[name] = null;
    delete me.byRef[name];
  }
  afterRecompose() {
  }
  compose() {
    return {
      class: DomClassList.normalize(this.widgetClassList, "object")
    };
  }
  doCompose() {
    const me = this, {
      $meta: meta
    } = me, classes = meta.hierarchy;
    let {
      composers
    } = meta, domConfig = null, c, key, firstTime, i, proto2, renderConfigs;
    me.recompose.suspend();
    if (!composers) {
      firstTime = true;
      meta.composers = composers = [];
      for (i = classes.indexOf(Widget); i < classes.length; ++i) {
        proto2 = classes[i].prototype;
        if (hasOwnProperty$2.call(proto2, "compose")) {
          composers.push(proto2);
        }
      }
      if (!(renderConfigs = meta.getInherited("renderConfigs", false))) {
        renderConfigs = /* @__PURE__ */ Object.create(null);
        me.configObserver = {
          get(name) {
            renderConfigs[name] = true;
          }
        };
      }
      meta.$renderConfigs = renderConfigs;
    }
    for (i = 0; i < composers.length; ++i) {
      c = composers[i].compose.call(me, domConfig);
      domConfig = domConfig ? DomHelper.merge(domConfig, c) : c;
    }
    if (hasOwnProperty$2.call(me, "compose") && (c = me.compose)) {
      c = c.call(me, domConfig);
      DomHelper.merge(domConfig, c);
    }
    firstTime && delete me.configObserver;
    return DomHelper.normalizeChildren(domConfig, (childName, hoist) => {
      if (hoist) {
        key = "_" + childName;
        if (!(key in me)) {
          me.addRefAccessor(childName, key);
        }
      }
    });
  }
  get element() {
    if (this.isComposable && !this.isDestroying) {
      this.recompose.flush();
    }
    return this._element;
  }
  domSyncCallback(info) {
  }
  changeElement(element) {
    const me = this, compose = me.isComposable;
    if (compose) {
      element = me.doCompose();
    }
    if (typeof element === "string") {
      element = DomHelper.createElementFromTemplate(element);
    } else if (ObjectHelper.isObject(element)) {
      element = DomHelper.createElement(element, {
        refOwner: me,
        callback: me.domSyncCallback
      });
      me.recompose.resume();
      compose && addElementListeners(me, element, element.lastDomConfig);
    } else if (DomHelper.isReactElement(me.peekConfig("html"))) {
      element = document.createElement("div");
    } else if (element.nodeType !== 1) {
      element = DomHelper.createElementFromTemplate(me.template(me));
    }
    element.id = me.id;
    if (me.elementAttributes) {
      DomHelper.setAttributes(element, me.elementAttributes);
    }
    return element;
  }
  updateElement(element) {
    const me = this, {
      className
    } = element, {
      contentElement,
      contentElementCls,
      isComposable
    } = me, hasChildContent = contentElement !== element, namedElements = !isComposable && element.querySelectorAll("[data-reference]"), classes = isComposable ? [] : me.widgetClassList;
    let uiClasses = (hasChildContent || !isComposable) && me.uiClasses;
    className && classes.unshift(className);
    me._hidden && classes.push("b-hidden");
    me._readOnly && classes.push("b-readonly");
    FunctionHelper.noThrow(element, "remove");
    if (uiClasses) {
      if (contentElementCls !== null && contentElementCls !== void 0 && contentElementCls.value) {
        uiClasses = uiClasses.slice();
        uiClasses.push(contentElementCls.value);
      }
      uiClasses = uiClasses.join(" ");
    } else {
      uiClasses = contentElementCls === null || contentElementCls === void 0 ? void 0 : contentElementCls.value;
    }
    if (uiClasses) {
      if (hasChildContent) {
        contentElement.className += " " + uiClasses;
      } else {
        classes.push(uiClasses);
      }
    }
    if (!me.parent) {
      const {
        defaultCls
      } = me, {
        outerCls
      } = Widget;
      classes.push(...defaultCls ? outerCls.filter((c) => !(c in defaultCls) || defaultCls[c]) : outerCls);
    }
    element.className = classes.join(" ");
    if (namedElements) {
      for (let el, i = 0; i < namedElements.length; ++i) {
        el = namedElements[i];
        me.attachRef(el.getAttribute("data-reference"), el);
        el.removeAttribute("data-reference");
      }
    }
    if (!me.adopt && !me.scaleToFitWidth) {
      me.getConfig("monitorResize");
    }
    me.getConfig("role");
    me.getConfig("ariaLabel");
    me.getConfig("ariaDescription");
    if (me._html) {
      me.getConfig("htmlMutationObserver");
    }
    me.trigger("elementCreated", {
      element
    });
  }
  updateAriaDescription(ariaDescription) {
    const {
      ariaElement
    } = this, descElId = `${this.id}-aria-desc-el`;
    if (ariaDescription) {
      const ariaDescEl = this._ariaDescEl || (this._ariaDescEl = DomHelper.createElement({
        className: "b-aria-desc-element",
        id: descElId,
        parent: ariaElement
      }));
      ariaDescEl.innerText = ariaDescription.match(localizeRE) ? this.L(ariaDescription, this) : ariaDescription;
      ariaElement.setAttribute("aria-describedBy", ariaDescEl.id);
    } else if (ariaElement.getAttribute("aria-describedby") === descElId) {
      ariaElement.removeAttribute("aria-describedBy");
    }
  }
  updateAriaLabel(ariaLabel) {
    DomHelper.setAttributes(this.ariaElement, {
      "aria-label": ariaLabel !== null && ariaLabel !== void 0 && ariaLabel.match(localizeRE) ? this.L(ariaLabel, this) : ariaLabel
    });
  }
  updateAriaHasPopup(ariaHasPopup) {
    DomHelper.setAttributes(this.ariaElement, {
      "aria-haspopup": ariaHasPopup
    });
  }
  updateRole(role) {
    if (role) {
      var _this$ariaElement;
      (_this$ariaElement = this.ariaElement) === null || _this$ariaElement === void 0 ? void 0 : _this$ariaElement.setAttribute("role", role);
    } else {
      var _this$ariaElement2;
      (_this$ariaElement2 = this.ariaElement) === null || _this$ariaElement2 === void 0 ? void 0 : _this$ariaElement2.removeAttribute("role");
    }
  }
  get ariaElement() {
    this.getConfig("element");
    const {
      _ariaElement
    } = this;
    return _ariaElement.nodeType === Node.ELEMENT_NODE ? _ariaElement : ObjectHelper.getPath(this, _ariaElement);
  }
  isCollapsified(collapsed, overlay) {
    const {
      collapsify
    } = this;
    let ret = !overlay;
    if (collapsify == null) {
      ret = overlay ? collapsed : !collapsed;
    } else if (collapsify === "overlay") {
      ret = overlay;
    }
    return Boolean(ret);
  }
  async recompose() {
    const me = this, options = {
      targetElement: me.element,
      domConfig: me.doCompose(),
      refOwner: me,
      callback: me.domSyncCallback,
      strict: true
    };
    if (me.transitionRecompose) {
      me.isTransitioningDom = true;
      await DomHelper.transition(ObjectHelper.assign({
        element: me.element,
        action() {
          DomSync.sync(options);
        }
      }, me.transitionRecompose));
      if (me.isDestroyed) {
        return;
      }
      me.isTransitioningDom = false;
      me.trigger("transitionedRecompose");
    } else {
      DomSync.sync(options);
    }
    if (options.changed) {
      me.afterRecompose();
      me.trigger("recompose");
    }
    me.recompose.resume();
  }
  changeElementRef(el) {
    if (typeof el === "string") {
      const id = el;
      if (!(el = document.getElementById(id))) {
        throw new Error(`No element found with id '${id}'`);
      }
    }
    return el;
  }
  changeAppendTo(appendTo) {
    return this.changeElementRef(appendTo);
  }
  updateAppendTo(appendTo) {
    if (!this.isConfiguring && appendTo) {
      this.render();
    }
  }
  changeInsertBefore(insertBefore) {
    return this.changeElementRef(insertBefore);
  }
  updateInsertBefore(insertBefore) {
    if (!this.isConfiguring && insertBefore) {
      this.render();
    }
  }
  changeInsertFirst(insertFirst) {
    return this.changeElementRef(insertFirst);
  }
  updateInsertFirst(insertFirst) {
    if (!this.isConfiguring && insertFirst) {
      this.render();
    }
  }
  getRenderContext(config = this, renderTo) {
    let parentElement = renderTo || config.appendTo, {
      insertFirst,
      insertBefore
    } = config;
    if (insertFirst) {
      parentElement = insertFirst;
      insertBefore = parentElement.firstChild;
    }
    if (insertBefore) {
      if (!parentElement) {
        parentElement = insertBefore.parentElement;
      }
    }
    return [parentElement, insertBefore || void 0];
  }
  render(renderTo, triggerPaint = true) {
    const me = this, {
      element
    } = me, [parentElement, insertBefore] = me.getRenderContext(me, renderTo);
    me.emptyCache();
    if (me.syncElement && me.currentElement) {
      DomHelper.sync(element, me.currentElement);
    } else {
      parentElement === null || parentElement === void 0 ? void 0 : parentElement.insertBefore(element, insertBefore);
      me.currentElement = element;
    }
    if (Widget.fromElement(element.parentElement)) {
      element.classList.remove(...Widget.outerCls);
    }
    super.render(parentElement, triggerPaint);
    me.rendered = true;
    me.getConfig("role");
    if (triggerPaint) {
      me.getConfig("contentRange");
      me.triggerPaint();
    }
    me.setupFocusListeners();
  }
  template({
    tag,
    html,
    htmlCls,
    name
  }) {
    var _html;
    const me = this;
    if (typeof html === "string" && callbackRe.test(html) && me.resolveCallback(html, me, false)) {
      html = me.callback(html, me, [me]);
    }
    const content = (_html = html) !== null && _html !== void 0 && _html.call ? html.call(me, me) : html;
    return `<${tag} class="${content ? htmlCls : ""}" ${name ? `data-name="${name}"` : ""}>${content || ""}</${tag}>`;
  }
  updateRecomposeAsync(async) {
    this.recompose.immediate = !async;
  }
  onConfigChange({
    name
  }) {
    var _this$$meta$$renderCo;
    if (this._element && !this.isDestroying && (_this$$meta$$renderCo = this.$meta.$renderConfigs) !== null && _this$$meta$$renderCo !== void 0 && _this$$meta$$renderCo[name]) {
      this.recompose();
    }
  }
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs(configs);
    delete configs.parent;
  }
  getConfigValue(name, options) {
    if (name === "style") {
      return this._style;
    }
    return super.getConfigValue(name, options);
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    if ((options === null || options === void 0 ? void 0 : options.depth) > 0) {
      result.type = this.type;
    }
    return result;
  }
  get dataset() {
    return this.element.dataset;
  }
  changeDataset(dataset) {
    Object.assign(this.dataset, dataset);
  }
  get dragGhost() {
    return this.constructor._dragGhost || (this.constructor._dragGhost = DomHelper.createElement({
      html: "\xA0",
      style: "position:absolute;top:-10000em;left:-10000em"
    }));
  }
  updateParent(parent) {
    const {
      _element: element
    } = this;
    if (element) {
      element.classList[parent ? "remove" : "add"](...Widget.outerCls);
    }
  }
  get constrainTo() {
    var _result;
    let result = this._constrainTo;
    result = result === void 0 ? globalThis : ((_result = result) === null || _result === void 0 ? void 0 : _result.nodeType) === Node.DOCUMENT_FRAGMENT_NODE ? result.host || result.ownerDocument : result;
    if (this.positioned) {
      const {
        offsetParent
      } = this.element;
      if (offsetParent && DomHelper.getStyleValue(offsetParent, "overflow") === "hidden") {
        result = Rectangle.from(offsetParent).moveTo(0, 0);
      } else if (result && !result.isRectangle) {
        const isViewport = result === document || result === globalThis;
        result = Rectangle.from(result, offsetParent);
        if (isViewport) {
          result.translate(globalThis.pageXOffset, globalThis.pageYOffset);
        }
      }
    }
    return result;
  }
  updateCentered(value) {
    const {
      element,
      _anchorElement
    } = this;
    if (value && !this.floating && !this.positioned) {
      throw new Error("`centered` is only relevant when a Widget is `floating` or `positioned`");
    }
    if (value) {
      element.classList.add("b-centered");
      element.style.transform = element.style.left = element.style.top = "";
      _anchorElement === null || _anchorElement === void 0 ? void 0 : _anchorElement.classList.add("b-hide-display");
      element.classList.remove("b-anchored");
    } else {
      element.classList.remove("b-centered");
    }
  }
  get contentElement() {
    return this.element;
  }
  get contentRange() {
    const me = this, {
      contentElement
    } = me, contentRange = me._contentRange || (me._contentRange = new Range());
    if (contentRange.collapsed) {
      contentRange.setStart(contentElement, me.contentRangeStartOffset || 0);
      contentRange.setEnd(contentElement, me.contentRangeEndOffset || contentElement.childNodes.length);
    }
    return contentRange;
  }
  fixRefOwnerId(el, id, oldId) {
    if (el.$refOwnerId === oldId) {
      el.$refOwnerId = id;
      for (let {
        childNodes
      } = el, i = childNodes.length; i-- > 0; ) {
        this.fixRefOwnerId(childNodes[i], id, oldId);
      }
    }
  }
  get placement() {
    const me = this, {
      element
    } = me;
    let adjRect, placement, rect;
    if (element !== null && element !== void 0 && element.offsetParent && !nonFlowedPositions.test(DomHelper.getStyleValue(element, "position"))) {
      const next = element.nextElementSibling, previous = element.previousElementSibling, last = !next && previous;
      placement = DomHelper.getStyleValue(element.parentElement, "flex-direction");
      if (placement) {
        placement = placement.startsWith("row") ? "h" : "v";
      } else {
        var _ref;
        adjRect = (_ref = next || previous) === null || _ref === void 0 ? void 0 : _ref.getBoundingClientRect();
        rect = adjRect && element.getBoundingClientRect();
        placement = adjRect && Math.abs(adjRect.top - rect.top) < Math.abs(adjRect.left - rect.left) ? "h" : "v";
      }
      placement += placement === "h" ? last ? "r" : "l" : last ? "b" : "t";
    }
    return placement;
  }
  updateId(id, oldId) {
    super.updateId(id, oldId);
    if (oldId) {
      const {
        byRef,
        element
      } = this;
      for (const ref in byRef) {
        byRef[ref].dataset && (byRef[ref].dataset.ownerCmp = id);
      }
      element.id = id;
      this.fixRefOwnerId(element, id, oldId);
    }
  }
  get style() {
    const {
      element
    } = this;
    return (element === null || element === void 0 ? void 0 : element.ownerDocument.defaultView.getComputedStyle(element)) || this._style;
  }
  updateStyle(style) {
    this.element && DomHelper.applyStyle(this.element, style);
  }
  updateTitle(title) {
    if (this.titleElement) {
      this.titleElement.innerHTML = title;
    }
  }
  beforeAlignTo(spec) {
  }
  alignTo(spec) {
    var _anchor;
    const me = this, {
      lastAlignSpec,
      element
    } = me, {
      offsetParent,
      style,
      classList
    } = element;
    if (lastAlignSpec) {
      lastAlignSpec.monitorIntersection && me.intersectionObserver.unobserve(lastAlignSpec.target);
      if (isFinite(lastAlignSpec.zone)) {
        element.classList.remove(alignedClass[lastAlignSpec.zone]);
      }
    }
    if (!spec) {
      me.removeTransientListeners();
      me.anchor = me.lastAlignSpec = null;
      return;
    }
    me.beforeAlignTo(spec);
    if (spec.nodeType === Element.ELEMENT_NODE || spec.isWidget || spec.$$name === "Point") {
      spec = {
        target: spec
      };
    }
    me.releaseSizeConstraints();
    const {
      scrollable,
      constrainTo
    } = me, positioned = me.positioned && DomHelper.getStyleValue(element, "position") !== "fixed", scale = me.scale || 1, passedTarget = spec.target, target = passedTarget && (passedTarget.isRectangle ? passedTarget : passedTarget.element || passedTarget), myPosition = Rectangle.from(element, positioned ? offsetParent : null, true), {
      width: startWidth,
      height: startHeight
    } = myPosition, aligningToElement = target && target.nodeType === Element.ELEMENT_NODE;
    spec = spec.realignTarget ? spec : ObjectHelper.assign({
      aligningToElement,
      constrainTo,
      align: "b-t",
      axisLock: me.axisLock,
      anchor: me.anchor
    }, me.align, spec);
    const minWidth = spec.minWidth || me.minWidth, minHeight = spec.minHeight || me.minHeight;
    myPosition.isAlignRectangle = true;
    minWidth && (myPosition.minWidth = minWidth * scale);
    minHeight && (myPosition.minHeight = minHeight * scale);
    me.lastAlignSpec = spec;
    if (aligningToElement) {
      me.lastAlignSpec.target = target;
    }
    if (aligningToElement && hasLayout(target instanceof SVGElement ? target.closest("svg") : target)) {
      spec = Object.setPrototypeOf({}, spec);
      spec.target = me.lastAlignSpec.targetRect = spec.realignTarget || (spec.allowTargetOut ? Rectangle.from(target, positioned ? offsetParent : null, !positioned) : DomHelper.isInView(target, false, me));
      if (!spec.target) {
        const result2 = me.hide();
        if (!me.isDestroyed) {
          me.lastAlignSpec.targetOutOfView = true;
        }
        return result2;
      }
      spec.target.height = Math.max(spec.target.height, 1);
      spec.target.width = Math.max(spec.target.width, 1);
      me.lastAlignSpec.anchoredTo = target;
    }
    if (spec.anchor) {
      spec.anchorSize = me.anchorSize;
      if (!element.contains(me.anchorPathElement)) {
        element.appendChild(me.anchorElement);
      }
    }
    me.isAligning = true;
    me.trigger("beforeAlign", spec);
    me.isAligning = false;
    spec.rtl = me.rtl;
    if (spec.align.includes("s") || spec.align.includes("e")) {
      if (me.rtl) {
        spec.align = spec.align.replace(/s/g, "r").replace(/e/g, "l");
      } else {
        spec.align = spec.align.replace(/s/g, "l").replace(/e/g, "r");
      }
    }
    const result = myPosition.alignTo(spec);
    let {
      align,
      anchor,
      x,
      y,
      width,
      height,
      overlap
    } = result;
    me.lastAlignSpec.zone = result.zone;
    if (height != startHeight) {
      if (!("configuredHeight" in me)) {
        me.configuredHeight = style.height;
      }
      me.height = height / scale;
      me.alignConstrained = me.alignConstrained | 1;
      if (scrollable) {
        scrollable.overflowY = true;
      }
    }
    if (width != startWidth) {
      if (!("configuredWidth" in me)) {
        me.configuredWidth = style.width;
      }
      me.width = width / scale;
      me.alignConstrained = me.alignConstrained | 2;
      if (scrollable) {
        scrollable.overflowX = scrollable.clientWidth > scrollable.scrollWidth;
      }
    }
    if (align && me.alignConstrained) {
      spec.align = align;
      const newResult = Rectangle.from(element, positioned ? offsetParent : null, true).alignTo(spec);
      anchor = newResult.anchor;
      x = newResult.x;
      y = newResult.y;
      width = newResult.width;
      height = newResult.height;
    }
    if (!me.centered) {
      me.setXY(x, y);
    }
    if (!result.overlap && isFinite(result.zone)) {
      classList.add(alignedClass[result.zone]);
    }
    if ((_anchor = anchor) !== null && _anchor !== void 0 && _anchor.edge) {
      var _colourSource;
      const {
        edge
      } = anchor, {
        anchorElement
      } = me, elRect = Rectangle.from(element), colorMatchPoint = [];
      if (edge === "top" || edge === "bottom") {
        colorMatchPoint[0] = anchor.x;
        colorMatchPoint[1] = edge === "top" ? 1 : elRect.height - 1;
      } else {
        colorMatchPoint[0] = edge === "left" ? 1 : elRect.width - 1;
        colorMatchPoint[1] = anchor.y;
      }
      let colourSource = DomHelper.childFromPoint(element, ...colorMatchPoint);
      if ((_colourSource = colourSource) !== null && _colourSource !== void 0 && _colourSource.matches(":hover,:focus") && element.compareDocumentPosition(colourSource) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
        colourSource = colourSource.parentNode;
      }
      if (colourSource && colourSource !== document) {
        let fillColour = DomHelper.getStyleValue(colourSource, "background-color");
        while (fillColour.match(isTransparent) && DomHelper.getStyleValue(colourSource, "position") !== "absolute") {
          colourSource = colourSource.parentNode;
          if (colourSource === document) {
            break;
          }
          fillColour = DomHelper.getStyleValue(colourSource, "background-color");
        }
        if (fillColour.match(isTransparent)) {
          me.anchorPathElement.setAttribute("fill", me.defaultAnchorBackgroundColor);
        } else {
          me.anchorPathElement.setAttribute("fill", fillColour);
        }
      }
      anchorElement.classList.remove("b-hide-display");
      anchorElement.style.transform = "";
      anchorElement.className = `b-anchor b-anchor-${edge}`;
      anchor.x && (anchor.x /= scale);
      anchor.y && (anchor.y /= scale);
      DomHelper.setTranslateXY(anchorElement, anchor.x, anchor.y);
      classList.add("b-anchored");
    } else if (me._anchorElement) {
      me.anchorElement.classList.add("b-hide-display");
      classList.remove("b-anchored");
    }
    if (!aligningToElement) {
      style.pointerEvents = "none";
      const el = DomHelper.elementFromPoint(x, y);
      if (!me.owns(el)) {
        me.lastAlignSpec.anchoredTo = el;
      }
      style.pointerEvents = "";
    }
    if ((me.scrollAction === "realign" && aligningToElement || me.scrollAction === "hide") && !me.documentScrollListener) {
      me.clearTimeout(me.scrollListenerTimeout);
      if (spec.monitorTargetMutation && !me.targetObserver) {
        const targetObserver = me.targetObserver || (me.targetObserver = new MutationObserver(me.onTargetParentMutation.bind(me)));
        targetObserver.observe(DomHelper.getRootElement(target), {
          childList: true,
          attributes: true,
          subtree: true
        });
      }
      me.scrollListenerTimeout = me.setTimeout(() => {
        var _target$getRootNode;
        const targetRoot = (_target$getRootNode = target.getRootNode) === null || _target$getRootNode === void 0 ? void 0 : _target$getRootNode.call(target);
        me.documentScrollListener = EventHelper.addListener(document, "scroll", "doHideOrRealign", {
          capture: true,
          thisObj: me
        });
        if (targetRoot !== null && targetRoot !== void 0 && targetRoot.mode) {
          me.targetRootScrollListener = EventHelper.addListener(targetRoot, "scroll", "doHideOrRealign", {
            capture: true,
            thisObj: me
          });
        }
      }, me.scrollAction === "hide" ? me.ignoreScrollDuration : 0);
    }
    if (aligningToElement) {
      if (spec.monitorResize && !me.targetResizeListener) {
        ResizeMonitor.addResizeListener(target, me.onTargetResize);
        me.targetResizeListener = true;
      }
      if (spec.monitorIntersection && !(overlap || target.contains(element) || target.ownerSVGElement)) {
        me.intersectionObserver.observe(target);
      }
    }
    if (!BrowserHelper.isAndroid) {
      if (!me.constrainListeners) {
        const el = constrainTo !== null && constrainTo !== void 0 && constrainTo.isRectangle ? globalThis : constrainTo;
        me.clearTimeout(me.resizeListenerTimeout);
        me.resizeListenerTimeout = me.setTimeout(() => {
          me.constrainListeners = true;
          ResizeMonitor.addResizeListener(el || globalThis, me.onAlignConstraintChange);
        }, me.ignoreScrollDuration);
      }
    }
  }
  onTargetParentMutation(mutationRecords) {
    const {
      element,
      lastAlignSpec
    } = this;
    if (lastAlignSpec !== null && lastAlignSpec !== void 0 && lastAlignSpec.aligningToElement) {
      if (!isInDocument(lastAlignSpec.target)) {
        this.hide();
      } else if (mutationRecords.some(({
        target
      }) => target.contains(lastAlignSpec.target) && !element.contains(target))) {
        this.realign();
      }
    }
  }
  get intersectionObserver() {
    return this._intersectionObserver || (this._intersectionObserver = new IntersectionObserver(this.onTargetIntersectionchange.bind(this), {
      root: BrowserHelper.isSafari ? this.rootElement : this.rootElement.ownerDocument
    }));
  }
  onTargetIntersectionchange(entries) {
    if (!this.isDestroyed) {
      const e = entries[entries.length - 1];
      if (!e.isIntersecting) {
        this.onAlignTargetOutOfView(e.target);
      }
    }
  }
  onTargetResize() {
    const {
      lastAlignSpec
    } = this;
    if (lastAlignSpec) {
      const {
        width: lastWidth,
        height: lastHeight
      } = lastAlignSpec.targetRect, {
        width,
        height
      } = lastAlignSpec.target.getBoundingClientRect();
      if (width !== lastWidth || height !== lastHeight) {
        this.onAlignConstraintChange(...arguments);
      }
    }
  }
  onAlignTargetOutOfView(target) {
    this.hide();
    this.lastAlignSpec && (this.lastAlignSpec.targetOutOfView = true);
  }
  onAlignConstraintChange(el, oldRect, {
    height
  }) {
    const {
      style
    } = this.contentElement, {
      overflowY
    } = style;
    this.setTimeout(this.realign, 50);
    if (oldRect && height > oldRect.height) {
      style.overflowY = "hidden";
      this.requestAnimationFrame(() => style.overflowY = overflowY);
    }
  }
  realign() {
    const me = this, {
      lastAlignSpec
    } = me;
    if ((me.floating || me.positioned) && lastAlignSpec && me.isVisible) {
      if (lastAlignSpec.aligningToElement) {
        const insideTarget = lastAlignSpec.target.contains(this.element), realignTarget = DomHelper.isInView(lastAlignSpec.target, false, me);
        if (!lastAlignSpec.allowTargetOut && (!hasLayout(lastAlignSpec.target) || !realignTarget)) {
          me.hide();
          if (!me.isDestroyed) {
            me.lastAlignSpec.targetOutOfView = true;
          }
          return;
        }
        lastAlignSpec.realignTarget = insideTarget ? null : realignTarget;
      }
      DomHelper.addTemporaryClass(me.element, "b-realigning", me.realignTimout, me);
      me.alignTo(lastAlignSpec);
    }
  }
  rectangle(which, relativeTo, ignorePageScroll) {
    return this.rectangleOf("element", which, relativeTo, ignorePageScroll);
  }
  rectangleOf(element, which, relativeTo, ignorePageScroll) {
    var _relativeTo;
    if (typeof which !== "string") {
      ignorePageScroll = relativeTo;
      relativeTo = which;
      which = "";
    } else if (which === "border") {
      which = "";
    }
    if (typeof relativeTo === "boolean") {
      ignorePageScroll = relativeTo;
      relativeTo = void 0;
    }
    if (element !== "element" && relativeTo === void 0) {
      relativeTo = this.element;
    }
    relativeTo = (_relativeTo = relativeTo) !== null && _relativeTo !== void 0 && _relativeTo.isWidget ? relativeTo.element : relativeTo;
    return Rectangle[which || "from"](this[element], relativeTo, ignorePageScroll);
  }
  releaseSizeConstraints() {
    const me = this, scroller = me.scrollable;
    if (me.alignConstrained & 1) {
      me.height = me.configuredHeight;
      if (scroller) {
        scroller.overflowY = scroller.config.overflowY;
      }
    }
    if (me.alignConstrained & 2) {
      me.width = me.configuredWidth;
      if (scroller) {
        scroller.overflowX = scroller.config.overflowX;
      }
    }
    me.alignConstrained = 0;
  }
  toFront() {
    const {
      element
    } = this, parent = this.floating ? this.floatRoot : this.positioned ? element === null || element === void 0 ? void 0 : element.parentNode : null;
    if (element !== null && element !== void 0 && element.nextSibling) {
      const r = this._toFrontRange || (this._toFrontRange = document.createRange());
      r.setStartBefore(element.nextSibling);
      r.setEndAfter(parent.lastElementChild);
      parent.insertBefore(r.extractContents(), element);
    }
  }
  updateRef(ref) {
    this.element.dataset.ref = ref;
  }
  get overflowElement() {
    return this.contentElement;
  }
  get maxHeightElement() {
    return this.element;
  }
  changeAlign(align) {
    return typeof align === "string" ? {
      align
    } : align;
  }
  changeScrollable(scrollable, oldScrollable) {
    if (typeof scrollable === "boolean") {
      scrollable = {
        overflowX: scrollable,
        overflowY: scrollable
      };
    }
    if (scrollable) {
      scrollable.element = this.overflowElement;
      scrollable.widget = this;
      if (!scrollable.isScroller) {
        scrollable = oldScrollable ? oldScrollable.setConfig(scrollable) : new this.scrollerClass(scrollable);
      }
      scrollable.syncOverflowState();
    } else {
      oldScrollable === null || oldScrollable === void 0 ? void 0 : oldScrollable.destroy();
    }
    return scrollable;
  }
  handleReactElement(html) {
    const parent = this.closest((cmp) => cmp.reactComponent);
    if (parent !== null && parent !== void 0 && parent.reactComponent) {
      parent.reactComponent.processWidgetContent({
        reactElement: html,
        widget: this,
        reactComponent: parent.reactComponent
      });
    }
  }
  get html() {
    if (this.initializingElement || !this.element) {
      return this.content || this._html;
    }
    return this.contentElement.innerHTML;
  }
  updateHtml(html) {
    const me = this, isClearing = html == null, {
      element,
      contentElement,
      htmlCls
    } = me;
    if (!element && DomHelper.isReactElement(html)) {
      me.whenVisible(() => me.handleReactElement(html));
      return;
    }
    if (element) {
      me.updatingHtml = true;
      const anchorEl = contentElement === element && me._anchorElement;
      if (htmlCls) {
        htmlCls.values.forEach((value) => element.classList[isClearing ? "remove" : "add"](value));
      }
      if (anchorEl) {
        element.removeChild(anchorEl);
      }
      if (html && typeof html === "object") {
        if (DomHelper.isReactElement(html)) {
          me.handleReactElement(html);
        } else {
          DomSync.sync({
            domConfig: _objectSpread2(_objectSpread2({}, html), {}, {
              onlyChildren: true
            }),
            targetElement: me.contentElement
          });
        }
      } else {
        me.contentElement.innerHTML = isClearing ? "" : html;
      }
      me.getConfig("htmlMutationObserver");
      if (anchorEl) {
        element.appendChild(anchorEl);
      }
      if (me.isComposable) {
        me.recompose();
      } else if (me.floating || me.positioned) {
        if (!me.isAligning) {
          me.realign();
        }
      }
    }
  }
  changeHtmlMutationObserver(htmlMutationObserver, was) {
    const me = this, {
      contentElement
    } = me;
    was === null || was === void 0 ? void 0 : was.disconnect(contentElement);
    if (htmlMutationObserver) {
      const result = new MutationObserver(() => {
        if (me.updatingHtml) {
          me.updatingHtml = false;
        } else {
          me._html = contentElement.innerHTML;
        }
      });
      result.observe(contentElement, htmlMutationObserver);
      return result;
    }
  }
  updateContent(html) {
    const me = this, isClearing = html == null, {
      element,
      htmlCls
    } = me;
    if (element) {
      const {
        contentRange
      } = me;
      if (htmlCls) {
        htmlCls.values.forEach((value) => element.classList[isClearing ? "remove" : "add"](value));
      }
      if (isInDocument(element)) {
        contentRange.deleteContents();
        if (!isClearing) {
          contentRange.insertNode(DomHelper.createElementFromTemplate(html, {
            fragment: true
          }));
        }
      } else {
        me.contentElement.innerHTML = html;
      }
      me.contentRangeStartOffset = contentRange.startOffset;
      me.contentRangeEndOffset = contentRange.endOffset;
      if ((me.floating || me.positioned) && !me.isAligning) {
        me.realign();
      }
    }
  }
  onThemeChange() {
    var _this$anchorElement;
    if ((_this$anchorElement = this.anchorElement) !== null && _this$anchorElement !== void 0 && _this$anchorElement.offsetParent) {
      this._anchorSize = null;
      this.realign();
    }
  }
  get anchorSize() {
    const me = this;
    let result = this._anchorSize;
    if (!result) {
      const borderWidth = parseFloat(DomHelper.getStyleValue(me.element, "border-top-width")), borderColour = DomHelper.getStyleValue(me.element, "border-top-color"), anchorElement = me.anchorElement, {
        className
      } = anchorElement, svgEl = anchorElement.firstElementChild, pathElement = me.anchorPathElement = svgEl.lastElementChild, hidden = me._hidden;
      anchorElement.className = "b-anchor b-anchor-top";
      let backgroundColour = DomHelper.getStyleValue(me.contentElement, "background-color");
      if (backgroundColour.match(isTransparent)) {
        backgroundColour = DomHelper.getStyleValue(me.element, "background-color");
      }
      me.defaultAnchorBackgroundColor = backgroundColour;
      result = anchorElement.getBoundingClientRect();
      const [width, height] = result = me._anchorSize = [result.width, result.height];
      anchorElement.className = className;
      svgEl.setAttribute("height", height + borderWidth);
      svgEl.setAttribute("width", width);
      pathElement.setAttribute("d", `M0,${height}L${width / 2},0.5L${width},${height}`);
      if (borderWidth) {
        pathElement.setAttribute("stroke-width", borderWidth);
        pathElement.setAttribute("stroke", borderColour);
      }
      result[1] -= borderWidth;
      if (hidden) {
        me.element.classList.add("b-hidden");
      }
      if (!me.themeChangeListener) {
        me.themeChangeListener = GlobalEvents$1.ion({
          theme: "onThemeChange",
          thisObj: me
        });
      }
      me.anchorPathElement.setAttribute("fill", me.defaultAnchorBackgroundColor);
    }
    return result;
  }
  get anchorElement() {
    const me = this;
    if (!me._anchorElement) {
      const useFilter = me.floating, filterId = `${me.id}-shadow-filter`;
      me._anchorElement = DomHelper.createElement({
        parent: me.element,
        className: "b-anchor b-anchor-top",
        children: [{
          tag: "svg",
          ns: "http://www.w3.org/2000/svg",
          version: "1.1",
          class: "b-pointer-el",
          children: [useFilter ? {
            tag: "defs",
            children: [{
              tag: "filter",
              id: filterId,
              children: [{
                tag: "feDropShadow",
                dx: 0,
                dy: -1,
                stdDeviation: 1,
                "flood-opacity": 0.2
              }]
            }]
          } : null, {
            tag: "path",
            [useFilter ? "filter" : ""]: `url(#${filterId})`
          }]
        }]
      });
    }
    return me._anchorElement;
  }
  updateAnchor(anchor) {
    if (this._anchorElement) {
      this._anchorElement.classList[anchor ? "remove" : "add"]("b-hide-display");
    }
  }
  updateDraggable(draggable) {
    const me = this, {
      element
    } = me;
    if (draggable) {
      me.dragEventDetacher = EventHelper.addListener({
        element,
        dragstart: "onWidgetDragStart",
        dragend: "onWidgetDragEnd",
        thisObj: me
      });
      me.dragDetacher = EventHelper.on({
        element,
        mousedown(event) {
          const {
            target
          } = event, closestWidget = Widget.fromElement(target);
          if (!event.target.closest(".b-field-inner") && closestWidget === this || this.strips && Object.values(this.strips).includes(closestWidget)) {
            element.setAttribute("draggable", "true");
          }
        },
        thisObj: me
      });
    } else {
      var _me$dragEventDetacher2, _me$dragOverEventDeta2, _me$dragDetacher;
      (_me$dragEventDetacher2 = me.dragEventDetacher) === null || _me$dragEventDetacher2 === void 0 ? void 0 : _me$dragEventDetacher2.call(me);
      (_me$dragOverEventDeta2 = me.dragOverEventDetacher) === null || _me$dragOverEventDeta2 === void 0 ? void 0 : _me$dragOverEventDeta2.call(me);
      (_me$dragDetacher = me.dragDetacher) === null || _me$dragDetacher === void 0 ? void 0 : _me$dragDetacher.call(me);
    }
  }
  onWidgetDragStart(e) {
    var _ref2;
    const me = this;
    if (!me.validateDragStartEvent(e)) {
      return;
    }
    const {
      element,
      align,
      constrainTo
    } = me, positioned = me.positioned && DomHelper.getStyleValue(element, "position") !== "fixed", parentElement = positioned ? element.parentElement : me.rootElement, myRect = Rectangle.from(element, positioned ? parentElement : null), dragStartX = e.clientX, dragStartY = e.clientY, scrollingPageElement = document.scrollingElement || document.body, [widgetX, widgetY] = positioned ? DomHelper.getOffsetXY(element, parentElement) : me.getXY(), constrainRect = (_ref2 = positioned ? Rectangle.content(parentElement).moveTo(0, 0) : constrainTo && (constrainTo !== null && constrainTo !== void 0 && constrainTo.isRectangle ? constrainTo : Rectangle.from(constrainTo))) === null || _ref2 === void 0 ? void 0 : _ref2.deflate(align.constrainPadding || 0), dragListeners = {
      element: parentElement,
      dragover: (event) => {
        element.classList.remove("b-centered");
        myRect.moveTo(widgetX + event.clientX - dragStartX - (positioned ? 0 : scrollingPageElement.scrollLeft), widgetY + event.clientY - dragStartY - (positioned ? 0 : scrollingPageElement.scrollTop));
        if (constrainRect) {
          myRect.constrainTo(constrainRect);
        }
        DomHelper.setTranslateXY(element, myRect.x, myRect.y);
      }
    };
    if (BrowserHelper.isTouchDevice) {
      dragListeners.touchmove = (e13) => e13.preventDefault();
    }
    me.floatRoot.appendChild(me.dragGhost);
    me.setDragImage(e);
    e.dataTransfer.effectAllowed = "none";
    me.dragOverEventDetacher = EventHelper.addListener(dragListeners);
    me.alignTo();
  }
  validateDragStartEvent(e) {
    const me = this, {
      element
    } = me, actualTarget = DomHelper.elementFromPoint(e.clientX, e.clientY), {
      handleSelector
    } = me.draggable;
    if (handleSelector) {
      var _negationPseudo$exec;
      const blacklist = (_negationPseudo$exec = negationPseudo.exec(handleSelector)) === null || _negationPseudo$exec === void 0 ? void 0 : _negationPseudo$exec[1];
      if (blacklist) {
        if (actualTarget.closest(`#${element.id} ${blacklist}`)) {
          e.preventDefault();
          return false;
        }
      } else if (!actualTarget.closest(`#${element.id} ${handleSelector}`)) {
        e.preventDefault();
        return false;
      }
    }
    return true;
  }
  setDragImage(e) {
    if (e.dataTransfer.setDragImage) {
      e.dataTransfer.setData("application/node type", "");
      e.dataTransfer.setDragImage(this.dragGhost, -9999, -9999);
    }
  }
  setStyle(name, value) {
    DomHelper.applyStyle(this.element, ObjectHelper.isObject(name) ? name : {
      [name]: value
    });
    return this;
  }
  onWidgetDragEnd() {
    this.dragGhost.remove();
    this.dragOverEventDetacher();
    this.element.removeAttribute("draggable");
  }
  changeFloating(value) {
    return Boolean(value);
  }
  changePositioned(value) {
    return Boolean(value);
  }
  updatePositioned(positioned) {
    this.element.classList[positioned ? "add" : "remove"]("b-positioned");
  }
  getXY() {
    return [DomHelper.getPageX(this.element), DomHelper.getPageY(this.element)];
  }
  setXY(x, y) {
    const me = this, {
      element
    } = me;
    if (me.floating || me.positioned) {
      if (x != null) {
        me._x = x;
      }
      if (y != null) {
        me._y = y;
      }
      if (DomHelper.getStyleValue(element, "position") === "fixed") {
        const r = element.getBoundingClientRect(), [cx, cy] = DomHelper.getTranslateXY(element), xDelta = x - r.x, yDelta = y - r.y;
        DomHelper.setTranslateXY(element, cx + xDelta, cy + yDelta);
      } else {
        DomHelper.setTranslateXY(element, me._x || 0, me._y || 0);
      }
      if (me.isConstructing) {
        me.centered = false;
      } else {
        element.classList.remove("b-centered");
      }
    }
  }
  get x() {
    return this.getXY()[0];
  }
  changeX(x) {
    this.setXY(x);
  }
  get y() {
    return this.getXY()[1];
  }
  changeY(y) {
    this.setXY(null, y);
  }
  get width() {
    const me = this, element = me.element;
    if (me.monitorResize) {
      if (me._width == null) {
        me._width = element.offsetWidth;
      }
      return me._width;
    }
    return element.offsetWidth;
  }
  changeWidth(width) {
    const me = this;
    DomHelper.setLength(me.element, "width", width);
    me._lastWidth = width;
    me._width = null;
    me._flex = null;
    me.element.style.flex = "";
  }
  clearWidthCache() {
    this._width = null;
  }
  get maxWidth() {
    return DomHelper.measureSize(this.element.style.maxWidth, this.element);
  }
  updateMaxWidth(maxWidth) {
    DomHelper.setLength(this.element, "maxWidth", maxWidth);
  }
  get minWidth() {
    return DomHelper.measureSize(this.element.style.minWidth, this.element);
  }
  updateMinWidth(minWidth) {
    DomHelper.setLength(this.element, "minWidth", minWidth);
  }
  updateFlex(flex) {
    this.getConfig("width");
    if (typeof flex === "number" || !isNaN(flex)) {
      flex = `${flex} ${flex}`;
    }
    this.element.style.flex = flex;
    this.element.style.width = "";
  }
  updateAlignSelf(alignSelf) {
    this.element.style.alignSelf = alignSelf;
  }
  updateMargin(margin) {
    this.element.style.margin = this.parseTRBL(margin).join(" ");
  }
  updateTextAlign(align, oldAlign) {
    oldAlign && this.element.classList.remove(`b-text-align-${oldAlign}`);
    this.element.classList.add(`b-text-align-${align}`);
  }
  updatePlaceholder(placeholder) {
    if (this.input) {
      if (placeholder == null) {
        this.input.removeAttribute("placeholder");
      } else {
        this.input.placeholder = placeholder;
      }
    }
  }
  get height() {
    const me = this, element = me.element;
    if (me.monitorResize) {
      if (me._height == null) {
        me._height = element.offsetHeight;
      }
      return me._height;
    }
    return element.offsetHeight;
  }
  changeHeight(height) {
    DomHelper.setLength(this.element, "height", height);
    this._lastHeight = height;
    this._height = null;
  }
  get maxHeight() {
    return DomHelper.measureSize(this.maxHeightElement.style.maxHeight, this.element);
  }
  updateMaxHeight(maxHeight) {
    DomHelper.setLength(this.maxHeightElement, "maxHeight", maxHeight);
  }
  get minHeight() {
    return DomHelper.measureSize(this.element.style.minHeight, this.element);
  }
  updateMinHeight(minHeight) {
    DomHelper.setLength(this.element, "minHeight", minHeight);
  }
  updateDisabled(disabled = false) {
    const {
      element,
      focusElement,
      ariaElement
    } = this;
    this.trigger("beforeUpdateDisabled", {
      disabled
    });
    if (disabled) {
      this.revertFocus();
      if (this._disabled !== disabled) {
        return;
      }
    }
    if (element) {
      element.classList[disabled ? "add" : "remove"]("b-disabled");
      if (focusElement) {
        focusElement.disabled = disabled;
      }
      if (ariaElement) {
        ariaElement.setAttribute("aria-disabled", disabled);
      }
    }
    this.onDisabled(disabled);
  }
  onDisabled(disabled) {
  }
  disable() {
    this.disabled = true;
  }
  enable() {
    this.disabled = false;
  }
  requestFullscreen() {
    const me = this, result = Fullscreen.request(me.floating ? me.floatRoot : me.element);
    Fullscreen.onFullscreenChange(me.onFullscreenChange);
    if (!me.floating) {
      me.floatRoot._oldParent = me.floatRoot.parentElement;
      me.element.appendChild(me.floatRoot);
    }
    me.element.classList.add("b-fullscreen");
    return result;
  }
  exitFullscreen() {
    return Fullscreen.exit();
  }
  onFullscreenChange() {
    if (!Fullscreen.isFullscreen) {
      this.onExitFullscreen();
    }
  }
  onExitFullscreen() {
    var _me$_rootElement;
    const me = this, floatRoot = (_me$_rootElement = me._rootElement) === null || _me$_rootElement === void 0 ? void 0 : _me$_rootElement.floatRoot;
    Fullscreen.unFullscreenChange(me.onFullscreenChange);
    me.element.classList.remove("b-fullscreen");
    if (me.element.contains(floatRoot) && floatRoot !== null && floatRoot !== void 0 && floatRoot._oldParent) {
      floatRoot._oldParent.appendChild(floatRoot);
      floatRoot._oldParent = null;
    }
  }
  get tooltip() {
    if (this._tooltip) {
      return this._tooltip;
    } else {
      var _Widget$Tooltip2;
      const tooltip = (_Widget$Tooltip2 = Widget.Tooltip) === null || _Widget$Tooltip2 === void 0 ? void 0 : _Widget$Tooltip2.getSharedTooltip(this.rootElement);
      if (tooltip && tooltip.activeTarget === this._element && tooltip.isVisible) {
        return tooltip;
      }
    }
  }
  changeTooltip(tooltip, oldTooltip) {
    const me = this, {
      element
    } = me;
    if (tooltip) {
      if (!(me.preventTooltipOnTouch && BrowserHelper.isTouchDevice)) {
        if (!tooltip.isTooltip && tooltip.constructor.name !== "Object") {
          tooltip = {
            html: typeof tooltip === "string" ? tooltip : me.placeholder,
            textContent: true
          };
        }
        if (!me.configureAriaDescription) {
          var _tooltip$html;
          me.ariaDescription = (_tooltip$html = tooltip.html) !== null && _tooltip$html !== void 0 && _tooltip$html.match(localizeRE) ? tooltip.html.replace(localizeRE, localizeTooltip) : tooltip.html;
        }
        if (oldTooltip !== null && oldTooltip !== void 0 && oldTooltip.isTooltip || tooltip.newInstance) {
          tooltip.type = "tooltip";
          if (!tooltip.forElement)
            tooltip.forElement = element;
          if (!("showOnHover" in tooltip) && !tooltip.forSelector)
            tooltip.showOnHover = true;
          if (!("autoClose" in tooltip))
            tooltip.autoClose = true;
          tooltip = Widget.reconfigure(oldTooltip, tooltip, me);
          me.detachListeners("tooltipValueListener");
          if (!me.configureAriaDescription) {
            tooltip.ion({
              name: "tooltipValueListener",
              innerHtmlUpdate: "onTooltipValueChange",
              thisObj: me
            });
          }
        } else {
          element.dataset.btip = true;
          me.tipConfig = tooltip;
          return;
        }
      }
    } else {
      if (oldTooltip) {
        if (tooltip == null && oldTooltip.isTooltip) {
          oldTooltip.destroy();
        } else {
          oldTooltip.html = null;
          return;
        }
      } else {
        delete element.dataset.btip;
      }
    }
    return tooltip;
  }
  onTooltipValueChange({
    value,
    source
  }) {
    this.ariaDescription = typeof value == "string" ? value : source.contentElement.innerText;
  }
  get tooltipText() {
    const tooltip = this._tooltip;
    if (tooltip) {
      return tooltip.isTooltip ? tooltip.contentElement.innerText : typeof tooltip === "string" ? tooltip : tooltip.html;
    } else if (this.tipConfig) {
      return this.tipConfig.html;
    }
  }
  get isVisible() {
    const me = this, {
      element
    } = me;
    let owner;
    return Boolean(element && !me._hidden && !me.isDestroying && isInDocument(element) && (!me.requireSize || hasLayout(element)) && (!(owner = me.containingWidget) || owner.isVisible));
  }
  whenVisible(callback, thisObj = this, args, id = callback) {
    const me = this;
    if (me.isVisible && me.isPainted) {
      me.callback(callback, thisObj, args);
    } else {
      (me.toCallWhenVisible || (me.toCallWhenVisible = /* @__PURE__ */ new Map())).set(id, {
        callback,
        thisObj,
        args
      });
    }
  }
  focus() {
    if (this.isFocusable) {
      DomHelper.focusWithoutScrolling(this.focusElement);
    }
  }
  get focusElement() {
  }
  get isFocusable() {
    const focusElement = !this.isDestroying && this.isVisible && !this.disabled && this.focusElement;
    return focusElement && (focusElement === document.body || focusElement.offsetParent);
  }
  async show({
    align,
    animate = true
  } = {}) {
    const me = this, {
      element,
      floating
    } = me, {
      style
    } = element, showAnimation = animate && me.showAnimation;
    let styleProp, animProps, trigger = !me.isVisible;
    if (trigger) {
      trigger = me.trigger("beforeShow");
      if (ObjectHelper.isPromise(trigger)) {
        trigger = await trigger;
      }
    }
    if (trigger !== false && (!me.internalBeforeShow || me.internalBeforeShow() !== false)) {
      return new Promise((resolve) => {
        me.cancelHideShowAnimation();
        me.updateCentered(me._centered);
        if (floating) {
          const floatRoot = me.floatRoot;
          if (!floatRoot.contains(element)) {
            if (me.rendered) {
              floatRoot.appendChild(me.element);
            } else {
              me.render(floatRoot, false);
            }
          }
          if (style.transform.includes("scale")) {
            me.scale = null;
            style.transform = style.transformOrigin = "";
          }
          const scaledAncestor = me.closest(isScaled);
          if (scaledAncestor) {
            const {
              scale
            } = scaledAncestor;
            me.scale = scale;
            style.transform = `scale(${scale})`;
            style.transformOrigin = `0 0`;
          }
        }
        me._hidden = false;
        element.classList.remove("b-hidden");
        if (floating && !isVisible(element)) {
          me.hide(false);
          resolve();
        }
        me.onConfigChange({
          name: "hidden",
          value: false,
          was: true,
          config: me.$meta.configs.hidden
        });
        if (showAnimation) {
          styleProp = Object.keys(showAnimation)[0];
          animProps = showAnimation[styleProp];
          const currentAnimation = me.currentAnimation = {
            showing: true,
            styleProp,
            resolve
          };
          me.isAnimating = true;
          me.currentAnimation.detacher = EventHelper.onTransitionEnd({
            element,
            property: styleProp,
            duration: parseDuration(animProps.duration) + 20,
            handler: () => me.afterHideShowAnimate(currentAnimation),
            thisObj: me
          });
          style[styleProp] = animProps.from;
          DomHelper.getStyleValue(element, styleProp);
          style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
          style[styleProp] = animProps.to;
        }
        me.afterShow(align, !showAnimation ? resolve : null);
      });
    } else {
      return Promise.resolve();
    }
  }
  async showBy(align, yCoord, options) {
    const me = this, isArray2 = Array.isArray(align);
    if (isArray2 || typeof align === "number") {
      const xy = isArray2 ? align : [align, yCoord];
      align = Object.assign({
        target: new Point(xy[0] + 1, xy[1] + 1),
        matchSize: false,
        align: "t0-b0"
      }, isArray2 ? yCoord : options);
    }
    me.requireSize = true;
    if (me.isVisible) {
      DomHelper.addTemporaryClass(me.element, "b-realigning", 300, me);
      me.alignTo(align);
    } else {
      return me.show({
        align
      });
    }
  }
  async showByPoint() {
    VersionHelper.deprecate("Core", "6.0.0", "Widget.showByPoint() replaced by Widget.showBy() with the same signature");
    return this.showBy(...arguments);
  }
  afterShow(align, resolveFn) {
    var _me$owner, _me$owner$onChildShow;
    const me = this;
    me.trigger("show");
    me._configuredAnchorState = me.anchor;
    (_me$owner = me.owner) === null || _me$owner === void 0 ? void 0 : (_me$owner$onChildShow = _me$owner.onChildShow) === null || _me$owner$onChildShow === void 0 ? void 0 : _me$owner$onChildShow.call(_me$owner, me);
    me.triggerPaint();
    if (me.floating || me.positioned) {
      if (align) {
        me.alignTo(align);
      } else if (me.centered) {
        me.alignTo({
          target: me.constrainTo,
          align: "c-c"
        });
      } else if (me.forElement) {
        me.alignTo(me.forElement);
      }
    }
    resolveFn === null || resolveFn === void 0 ? void 0 : resolveFn();
  }
  onChildHide(hidden) {
    if (hidden.floating) {
      this.ariaElement.removeAttribute("aria-owns");
    }
  }
  onChildShow(shown) {
    if (shown.floating) {
      this.ariaHasPopup = shown.role;
      this.ariaElement.setAttribute("aria-owns", shown.id);
    }
  }
  triggerPaint() {
    const me = this, {
      element,
      toCallWhenVisible
    } = me, firstPaint = !me.isPainted;
    if (me.isVisible) {
      if (firstPaint) {
        me.getConfig("scrollable");
        if (me.scaleToFitWidth && !me.monitorResize) {
          me.onParentElementResize = me.onParentElementResize.bind(me);
          ResizeMonitor.addResizeListener(element.parentElement, me.onParentElementResize);
          me.updateScale();
        }
        if (!me.hideBryntumDomMessage && (me.isTaskBoardBase || me.isGridBase || me.isCalendar)) {
          element.insertBefore(new Comment("POWERED BY BRYNTUM (https://bryntum.com)"), element.firstChild);
        }
      }
      me.eachWidget(widgetTriggerPaint, false);
      if (firstPaint) {
        me.rootElement = DomHelper.getRootElement(element);
        me.getConfig("tooltip");
        if (!Widget.Ripple && Widget.RippleClass) {
          Widget.Ripple = new Widget.RippleClass({
            rootElement: me.rootElement
          });
        }
      }
      me.isPainted = true;
      firstPaint && me.triggerConfigs("paint");
      me.trigger("paint", {
        firstPaint
      });
      if (toCallWhenVisible !== null && toCallWhenVisible !== void 0 && toCallWhenVisible.size) {
        for (const {
          callback,
          thisObj,
          args
        } of toCallWhenVisible.values()) {
          me.callback(callback, thisObj, args);
        }
        toCallWhenVisible.clear();
      }
      if (firstPaint) {
        if (me.monitorResize && !me.scaleToFitWidth) {
          ResizeMonitor.onElementResize([{
            target: element
          }]);
        }
      }
    }
  }
  cancelHideShowAnimation() {
    const me = this, {
      currentAnimation,
      element
    } = me;
    if (currentAnimation) {
      me.isAnimating = false;
      if (element.classList.contains("b-hiding")) {
        element.classList.remove("b-hiding");
        me._hidden = false;
      }
      currentAnimation.detacher();
      currentAnimation.resolve();
      element.style.transition = element.style[currentAnimation.styleProp] = "";
      me.currentAnimation = null;
      me.trigger(`${currentAnimation.showing ? "show" : "hide"}AnimationEnd`);
    }
  }
  afterHideShowAnimate(currentAnimation) {
    const me = this;
    if (currentAnimation === me.currentAnimation) {
      me.element.classList.remove("b-hiding");
      me.cancelHideShowAnimation();
      if (me._hidden) {
        me.afterHideAnimation();
      }
    }
  }
  suspendVisibility() {
    this._visibilitySuspended = (this._visibilitySuspended || 0) + 1;
    Object.defineProperty(this, "isVisible", returnFalseProp);
  }
  resumeVisibility(triggerPaint = true) {
    if (!--this._visibilitySuspended) {
      delete this.isVisible;
      if (triggerPaint) {
        this.triggerPaint();
      }
    }
  }
  hide(animate = true) {
    return new Promise((resolve) => {
      const me = this, {
        element,
        lastAlignSpec
      } = me, {
        style
      } = element, hideAnimation = animate && me.hideAnimation;
      me.clearTimeout(me.scrollListenerTimeout);
      me.clearTimeout(me.resizeListenerTimeout);
      if (!me._hidden && me.trigger("beforeHide", {
        animate
      }) !== false) {
        me._hidden = true;
        if (lastAlignSpec) {
          lastAlignSpec.targetOutOfView = null;
          if (lastAlignSpec.monitorIntersection) {
            me.intersectionObserver.takeRecords();
            me.intersectionObserver.unobserve(lastAlignSpec.target);
          }
        }
        me.onConfigChange({
          name: "hidden",
          value: true,
          was: false,
          config: me.$meta.configs.hidden
        });
        if (!element) {
          resolve();
          return;
        }
        if (element.contains(DomHelper.getActiveElement(element))) {
          me.revertFocus(true);
        }
        if (me.isDestroyed) {
          resolve();
          return;
        }
        me.cancelHideShowAnimation();
        if (hideAnimation) {
          const styleProp = Object.keys(hideAnimation)[0], animProps = hideAnimation[styleProp];
          if (Number(getComputedStyle(me.element)[styleProp]) !== animProps.to) {
            const currentAnimation = me.currentAnimation = {
              hiding: true,
              styleProp,
              resolve
            };
            element.classList.add("b-hiding");
            me.isAnimating = true;
            me.currentAnimation.detacher = EventHelper.onTransitionEnd({
              element,
              property: styleProp,
              duration: parseDuration(animProps.duration) + 20,
              handler: () => me.afterHideShowAnimate(currentAnimation),
              thisObj: me
            });
            style[styleProp] = animProps.from;
            DomHelper.getStyleValue(element, styleProp);
            style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
            style[styleProp] = animProps.to;
          } else {
            element.classList.add("b-hidden");
          }
        } else {
          element.classList.add("b-hidden");
        }
        me.afterHide(!hideAnimation && resolve, hideAnimation);
      }
    });
  }
  doHideOrRealign({
    target,
    isTrusted
  }) {
    const me = this, {
      lastAlignSpec,
      element
    } = me, anchoredTo = lastAlignSpec === null || lastAlignSpec === void 0 ? void 0 : lastAlignSpec.anchoredTo, lastTarget = lastAlignSpec === null || lastAlignSpec === void 0 ? void 0 : lastAlignSpec.target, position = lastAlignSpec === null || lastAlignSpec === void 0 ? void 0 : lastAlignSpec.position, activeEl = DomHelper.getActiveElement(me);
    if (!isTrusted || !hasLayout(element) || target && (element.contains(target) || target.nodeType === Element.DOCUMENT_NODE && element.contains(activeEl) && textInputTypes[activeEl] && globalThis.innerHeight < document.body.offsetHeight)) {
      return;
    }
    if (lastAlignSpec.aligningToElement) {
      const newTarget = DomHelper.isInView(lastTarget, false, me);
      if (newTarget && newTarget.equals(lastAlignSpec.targetRect)) {
        return;
      }
    }
    const xy = me.scrollAction === "hide" && me.getXY();
    me.realign();
    if (!me.isDestroyed && isVisible(element) && me.scrollAction === "hide") {
      const [newX, newY] = me.getXY(), moved = newX !== xy[0] || newY !== xy[1];
      if ((moved || (lastTarget === null || lastTarget === void 0 ? void 0 : lastTarget.$$name) === "Point" || position) && (!anchoredTo || !hasLayout(anchoredTo) || target && DomHelper.isDescendant(target, anchoredTo))) {
        me.hide();
      }
    }
  }
  afterHide(resolveFn = null, hideAnimation = this.hideAnimation) {
    var _me$owner2, _me$owner2$onChildHid;
    const me = this;
    me._anchor = me._configuredAnchorState;
    me.removeTransientListeners();
    if (!hideAnimation) {
      me.afterHideAnimation();
    }
    me.trigger("hide");
    (_me$owner2 = me.owner) === null || _me$owner2 === void 0 ? void 0 : (_me$owner2$onChildHid = _me$owner2.onChildHide) === null || _me$owner2$onChildHid === void 0 ? void 0 : _me$owner2$onChildHid.call(_me$owner2, me);
    resolveFn && resolveFn();
  }
  removeTransientListeners() {
    var _me$documentScrollLis, _me$targetRootScrollL;
    const me = this, {
      targetObserver,
      lastAlignSpec
    } = me;
    me.clearTimeout(me.resizeListenerTimeout);
    me.clearTimeout(me.scrollListenerTimeout);
    if (targetObserver) {
      targetObserver.disconnect();
      delete me.targetObserver;
    }
    me.documentScrollListener = (_me$documentScrollLis = me.documentScrollListener) === null || _me$documentScrollLis === void 0 ? void 0 : _me$documentScrollLis.call(me);
    me.targetRootScrollListener = (_me$targetRootScrollL = me.targetRootScrollListener) === null || _me$targetRootScrollL === void 0 ? void 0 : _me$targetRootScrollL.call(me);
    if (me.targetResizeListener) {
      ResizeMonitor.removeResizeListener(lastAlignSpec.target, me.onTargetResize);
      me.targetResizeListener = false;
    }
    if (me.constrainListeners) {
      var _lastAlignSpec$constr;
      const el = (_lastAlignSpec$constr = lastAlignSpec.constrainTo) !== null && _lastAlignSpec$constr !== void 0 && _lastAlignSpec$constr.isRectangle ? globalThis : lastAlignSpec.constrainTo;
      ResizeMonitor.removeResizeListener(el || globalThis, me.onAlignConstraintChange);
      me.constrainListeners = false;
    }
  }
  afterHideAnimation() {
    const me = this, {
      element
    } = me;
    if (me.floating && me.floatRoot.contains(element)) {
      element.remove();
    } else {
      element.classList.add("b-hidden");
    }
    if (me.defaultAnchorBackgroundColor) {
      me.anchorPathElement.setAttribute("fill", me.defaultAnchorBackgroundColor);
    }
  }
  changeHidden(value) {
    const me = this;
    let ret;
    if (me.isConfiguring) {
      ret = Boolean(value);
      me.element.classList[value ? "add" : "remove"]("b-hidden");
    } else {
      me.trigger("beforeChangeHidden", {
        hidden: value
      });
      if (value) {
        me.hide();
      } else {
        me.show();
      }
    }
    return ret;
  }
  get assignedId() {
    return this.hasGeneratedId ? null : this.id;
  }
  get owner() {
    return this.parent || this._owner || this.containingWidget;
  }
  get containingWidget() {
    let result = this.parent;
    if (!result) {
      var _this$forElement, _this$element;
      const owningEl = ((_this$forElement = this.forElement) === null || _this$forElement === void 0 ? void 0 : _this$forElement.nodeType) === Element.ELEMENT_NODE ? this.forElement : (_this$element = this.element) === null || _this$element === void 0 ? void 0 : _this$element.parentNode;
      result = (owningEl === null || owningEl === void 0 ? void 0 : owningEl.closest(".b-widget")) && Widget.fromElement(owningEl);
    }
    return result;
  }
  get previousSibling() {
    return this.getSibling(-1);
  }
  get nextSibling() {
    return this.getSibling(1);
  }
  getSibling(increment) {
    const me = this, {
      parent
    } = me, siblings = parent ? parent.childItems : Array.from(me.element.parentElement.querySelectorAll(".b-widget"));
    return parent ? siblings[siblings.indexOf(me) + increment] : Widget.fromElement(siblings[siblings.indexOf(me.element) + increment]);
  }
  up(selector, deep, limit) {
    var _owner$closest;
    const {
      owner
    } = this;
    return selector ? owner === null || owner === void 0 ? void 0 : (_owner$closest = owner.closest) === null || _owner$closest === void 0 ? void 0 : _owner$closest.call(owner, selector, deep, limit) : owner;
  }
  closest(selector, deep, limit) {
    const limitType = typeof limit, numericLimit = limitType === "number", selectorLimit = limitType === "string";
    for (let result = this, steps = 1; result; result = result.owner, steps++) {
      if (Widget.widgetMatches(result, selector, deep)) {
        return result;
      }
      if (numericLimit && steps >= limit) {
        return;
      } else if (selectorLimit && Widget.widgetMatches(result, limit, deep)) {
        return;
      } else if (result === limit) {
        return;
      }
    }
  }
  owns(target) {
    if (target) {
      if ("eventPhase" in target) {
        target = target.target;
      }
      if (target.nodeType === Element.ELEMENT_NODE) {
        if (this.element.contains(target)) {
          return true;
        }
        target = Widget.fromElement(target);
      }
      while (target) {
        if (target === this) {
          return true;
        }
        target = target.owner;
      }
    }
    return false;
  }
  eachAncestor(fn2) {
    let ancestor = this.owner;
    while (ancestor) {
      if (fn2(ancestor) === false) {
        return false;
      }
      ancestor = ancestor.owner;
    }
    return true;
  }
  changeMonitorResize(monitorResize, oldMonitorResize) {
    const result = this.scaleToFitWidth ? false : Boolean(monitorResize);
    if (result !== Boolean(oldMonitorResize)) {
      return result;
    }
  }
  updateMonitorResize(monitorResize) {
    const me = this;
    if (!hasOwnProperty$2.call(me, "onElementResize")) {
      me.onElementResize = me.onElementResize.bind(me);
    }
    ResizeMonitor[monitorResize ? "addResizeListener" : "removeResizeListener"](me.element, me.onElementResize);
  }
  changeReadOnly(readOnly) {
    readOnly = Boolean(readOnly);
    if (Boolean(this._readOnly) !== readOnly) {
      return readOnly;
    }
  }
  updateReadOnly(readOnly) {
    var _this$element2;
    (_this$element2 = this.element) === null || _this$element2 === void 0 ? void 0 : _this$element2.classList[readOnly ? "add" : "remove"]("b-readonly");
    if (!this.isConfiguring) {
      this.eachWidget((widget) => {
        if (widget.ignoreParentReadOnly) {
          return;
        }
        if (!("_originalReadOnly" in widget)) {
          widget._originalReadOnly = widget.config.readOnly || false;
        }
        widget.readOnly = readOnly || widget._originalReadOnly;
      }, false);
      this.trigger("readOnly", {
        readOnly
      });
    }
  }
  eachWidget(fn2, deep = true) {
    const widgets = this.childItems, length = (widgets === null || widgets === void 0 ? void 0 : widgets.length) || 0, control = {};
    for (let i = 0; i < length; i++) {
      const widget = widgets[i];
      control.down = deep;
      if (fn2(widget, control) === false) {
        return false;
      }
      if (control.down && widget.eachWidget) {
        if (widget.eachWidget(fn2, deep) === false) {
          return false;
        }
      }
    }
    return true;
  }
  queryAll(filter2) {
    const result = [];
    this.eachWidget((w) => {
      if (filter2(w)) {
        result.push(w);
      }
    });
    return result;
  }
  query(filter2) {
    let result = null;
    this.eachWidget((w) => {
      if (filter2(w)) {
        result = w;
        return false;
      }
    });
    return result;
  }
  getWidgetByRef(ref) {
    var _this$widgetMap, _this$owner;
    if (ref instanceof Widget) {
      return ref;
    }
    return (this === null || this === void 0 ? void 0 : (_this$widgetMap = this.widgetMap) === null || _this$widgetMap === void 0 ? void 0 : _this$widgetMap[ref]) || (this === null || this === void 0 ? void 0 : (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.getWidgetByRef(ref));
  }
  onFocusIn(e) {
    const me = this, {
      element
    } = me;
    me.containsFocus = true;
    me.focusInEvent = e;
    element.classList.add("b-contains-focus");
    me.updateAriaLabel(me.localizeProperty("ariaLabel"));
    me.updateAriaDescription(me.localizeProperty("ariaDescription"));
    if (element.contains(e._target) && me.onInternalKeyDown && !me.keyDownListenerRemover) {
      me.keyDownListenerRemover = EventHelper.on({
        element,
        keydown: "onInternalKeyDown",
        thisObj: me
      });
    }
    me.trigger("focusin", e);
  }
  onFocusOut(e) {
    const me = this;
    if (me.keyDownListenerRemover) {
      me.keyDownListenerRemover();
      me.keyDownListenerRemover = null;
    }
    if (!me.isDestroyed) {
      if (!e.relatedTarget) {
        me.revertFocus(!me.isVisible);
      }
      me.containsFocus = false;
      me.element.classList.remove("b-contains-focus");
      me.updateAriaLabel(me.localizeProperty("ariaLabel"));
      me.updateAriaDescription(me.localizeProperty("ariaDescription"));
      me.trigger("focusout", e);
    }
  }
  captureFocus() {
    const me = this, activeElementWas = DomHelper.getActiveElement(me), restore = me.contains(activeElementWas) && me.captureFocusItem(activeElementWas);
    return (scrollIntoView, force) => {
      if (restore && !me.isDestroying) {
        const activeElementNow = DomHelper.getActiveElement(me);
        if (activeElementNow !== activeElementWas || force) {
          restore(scrollIntoView);
        }
      }
    };
  }
  captureFocusItem(activeElement) {
    return (scrollIntoView = true) => {
      if (this.contains(activeElement)) {
        scrollIntoView ? activeElement.focus() : DomHelper.focusWithoutScrolling(activeElement);
      }
    };
  }
  contains(elementOrWidget, strict) {
    const {
      element
    } = this;
    if (elementOrWidget && element) {
      if (elementOrWidget.isWidget) {
        elementOrWidget = elementOrWidget.element;
      }
      return element.contains(elementOrWidget) && (!strict || element !== elementOrWidget);
    }
  }
  revertFocus(force) {
    var _me$focusInEvent, _target;
    const me = this, activeElement = DomHelper.getActiveElement(me);
    let target = (_me$focusInEvent = me.focusInEvent) === null || _me$focusInEvent === void 0 ? void 0 : _me$focusInEvent.relatedTarget;
    if (force || me.containsFocus && ((_target = target) === null || _target === void 0 ? void 0 : _target.nodeType) === Element.ELEMENT_NODE && me.element.contains(activeElement)) {
      if (!target || !DomHelper.isFocusable(target)) {
        target = me.getFocusRevertTarget();
      }
      me._isRevertingFocus = true;
      if (target && DomHelper.isFocusable(target)) {
        target._isRevertingFocus = true;
        DomHelper.focusWithoutScrolling(target);
        target._isRevertingFocus = false;
      } else {
        activeElement === null || activeElement === void 0 ? void 0 : activeElement.blur();
      }
      me._isRevertingFocus = false;
    }
  }
  getFocusRevertTarget() {
    const me = this, {
      owner,
      focusInEvent
    } = me, searchDirection = focusInEvent ? focusInEvent.backwards ? 1 : -1 : -1;
    let target = focusInEvent && focusInEvent.relatedTarget;
    const toComponent = target && Widget.fromElement(target);
    if (owner && !owner.isDestroyed && (!target || !DomHelper.isFocusable(target) || toComponent && !toComponent.isFocusable)) {
      var _owner$getFocusRevert;
      target = null;
      if (owner.eachWidget) {
        const siblings = [];
        owner.eachWidget((w) => {
          if (w === me || w.isFocusable) {
            siblings.push(w);
          }
        }, false);
        if (siblings.length > 1) {
          const myIndex = siblings.indexOf(me);
          target = siblings[myIndex + searchDirection] || siblings[myIndex - searchDirection];
        }
      }
      if (!target && owner.isFocusable) {
        target = owner;
      }
      target = target ? target.focusElement : (_owner$getFocusRevert = owner.getFocusRevertTarget) === null || _owner$getFocusRevert === void 0 ? void 0 : _owner$getFocusRevert.call(owner);
    }
    return target;
  }
  getStaticWidgetClasses(topMostBase, suffix) {
    const classList = new DomClassList(), hierarchy = this.$meta.hierarchy;
    let cls, i, name, widgetClass, widgetClassProperty;
    for (i = hierarchy.indexOf(topMostBase); i < hierarchy.length; ++i) {
      var _widgetClassProperty;
      cls = hierarchy[i];
      widgetClassProperty = Reflect.getOwnPropertyDescriptor(cls.prototype, "widgetClass");
      if ((_widgetClassProperty = widgetClassProperty) !== null && _widgetClassProperty !== void 0 && _widgetClassProperty.get) {
        widgetClass = widgetClassProperty.get.call(this);
      } else {
        name = hasOwnProperty$2.call(cls, "$$name") || hasOwnProperty$2.call(cls, "$name") || hasOwnProperty$2.call(cls, "_$name") ? cls.$$name : cls.name;
        if (name.length < 3 || name.includes("$")) {
          console.warn(`Class "${name}" extending "${cls.$name}" should have "$name" static getter with no less than 3 chars.`);
        }
        widgetClass = `b-${name.toLowerCase()}`;
      }
      if (widgetClass) {
        classList.add(suffix ? widgetClass + suffix : widgetClass);
      }
    }
    return classList;
  }
  get rootUiClass() {
    return Widget;
  }
  get staticClassList() {
    const {
      $meta: meta
    } = this;
    let classList = meta.staticClassList;
    if (!classList) {
      meta.staticClassList = classList = this.getStaticWidgetClasses(Widget);
      BrowserHelper.isTouchDevice && classList.add("b-touch");
    }
    return classList;
  }
  get uiClasses() {
    this.getConfig("ui");
    return this._uiClasses;
  }
  get uiClassList() {
    this.getConfig("ui");
    return this._uiClassList;
  }
  get widgetClassList() {
    const me = this, {
      cls,
      defaultCls,
      uiClasses
    } = me;
    let {
      staticClassList
    } = me;
    if (defaultCls || cls) {
      staticClassList = staticClassList.clone();
      defaultCls && staticClassList.assign(defaultCls);
      cls && staticClassList.assign(cls);
    }
    const classList = staticClassList.values;
    uiClasses && classList.push(...uiClasses);
    me.floating && classList.push("b-floating");
    if (me.collapsify === "hide") {
      classList.push("b-collapsify-hide");
    }
    return classList;
  }
  changeCls(cls) {
    return DomClassList.from(cls);
  }
  changeContentElementCls(cls) {
    return DomClassList.from(cls);
  }
  changeHtmlCls(cls) {
    return DomClassList.from(cls);
  }
  changeDefaultCls(cls) {
    return DomClassList.from(cls, true);
  }
  changeUi(ui) {
    return DomClassList.from(ui);
  }
  updateUi(ui) {
    var _uiClassList;
    let uiClassList = null, cls, suffix;
    if (ui) {
      const staticClassList = this.getStaticWidgetClasses(this.rootUiClass);
      for (suffix in ui) {
        if (ui[suffix]) {
          for (cls in staticClassList) {
            if (staticClassList[cls]) {
              (uiClassList || (uiClassList = new DomClassList()))[`${cls}-ui-${suffix}`] = 1;
            }
          }
        }
      }
    }
    this._uiClasses = (_uiClassList = uiClassList) === null || _uiClassList === void 0 ? void 0 : _uiClassList.values;
    this._uiClassList = uiClassList;
  }
  fromCache(query, children = false, element = this.element) {
    if (!element)
      return null;
    const me = this;
    if (!me.cache[query]) {
      me.cache[query] = children ? DomHelper.children(element, query) : DomHelper.down(element, query);
    }
    return me.cache[query];
  }
  emptyCache() {
    this.cache = {};
  }
  changeMasked(mask, maskInstance) {
    var _this$masked;
    if (((_this$masked = this.masked) === null || _this$masked === void 0 ? void 0 : _this$masked.type) === "trial") {
      return;
    }
    if (mask === true || mask === "") {
      mask = "\xA0";
    }
    if (maskInstance && !maskInstance.isDestroyed) {
      if (typeof mask === "string") {
        maskInstance.text = mask;
        mask = maskInstance;
      } else if (mask) {
        maskInstance.setConfig(mask);
        mask = maskInstance;
      } else {
        maskInstance.destroy();
      }
    } else if (mask) {
      const Mask2 = Widget.resolveType("mask");
      mask = Mask2.mergeConfigs(this.maskDefaults, mask);
      mask.owner = this;
      mask = Mask2.mask(mask);
    }
    return mask || null;
  }
  onMaskAutoClose(mask) {
    if (mask.isDestroyed && mask === this.masked) {
      this.masked = null;
    }
  }
  mask(msg) {
    this.masked = msg;
    return this.masked;
  }
  unmask() {
    this.masked = null;
  }
  onInternalResize(element, width, height, oldWidth, oldHeight) {
    this._width = element.offsetWidth;
    this._height = element.offsetHeight;
  }
  onElementResize(resizedElement, lastRect) {
    const me = this, {
      element
    } = me, oldWidth = me._width, oldHeight = me._height, newWidth = element.offsetWidth, newHeight = element.offsetHeight;
    if (me.floating && lastRect) {
      me.onFloatingWidgetResize(...arguments);
    }
    if (!me.suspendResizeMonitor && (oldWidth !== newWidth || oldHeight !== newHeight)) {
      me.onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight);
      me.trigger("resize", {
        width: newWidth,
        height: newHeight,
        oldWidth,
        oldHeight
      });
    }
  }
  onFloatingWidgetResize(resizedElement, lastRect, myRect) {
    const me = this, {
      lastAlignSpec,
      constrainTo
    } = me;
    if (me.isVisible && lastAlignSpec && lastAlignSpec.target) {
      const heightChange = !lastRect || myRect.height !== lastRect.height, widthChange = !lastRect || myRect.width !== lastRect.width, failsConstraint = constrainTo && !Rectangle.from(constrainTo).contains(Rectangle.from(me.element, null, true));
      if (heightChange && lastAlignSpec.zone !== 2 || widthChange && lastAlignSpec.zone !== 1 || failsConstraint) {
        me.requestAnimationFrame(() => me.realign());
      }
    }
  }
  updateScale() {
    const me = this, element = me.element, parentElement = element.parentElement;
    if (!me.configuredWidth) {
      me.configuredWidth = me.width;
    }
    element.style.display = "none";
    const rect = Rectangle.client(parentElement), scale = rect.width / me.configuredWidth, adjustedScale = me.scale = me.allowGrowWidth ? Math.min(scale, 1) : scale;
    element.style.transform = `scale(${adjustedScale})`;
    element.style.transformOrigin = "top left";
    element.style.display = "";
    if (me.allowGrowWidth && scale > 1) {
      me.width = me.configuredWidth * scale;
    }
  }
  onParentElementResize(event) {
    this.updateScale();
  }
  parseTRBL(values, units = "px") {
    values = values || 0;
    if (typeof values === "number") {
      return [`${values}${units}`, `${values}${units}`, `${values}${units}`, `${values}${units}`];
    }
    const parts = values.split(" "), len = parts.length;
    if (len === 1) {
      parts[1] = parts[2] = parts[3] = parts[0];
    } else if (len === 2) {
      parts[2] = parts[0];
      parts[3] = parts[1];
    } else if (len === 3) {
      parts[3] = parts[1];
    }
    return [isFinite(parts[0]) ? `${parts[0]}${units}` : parts[0], isFinite(parts[1]) ? `${parts[1]}${units}` : parts[2], isFinite(parts[2]) ? `${parts[2]}${units}` : parts[3], isFinite(parts[3]) ? `${parts[3]}${units}` : parts[4]];
  }
  get documentRoot() {
    var _this$owner2;
    return ((_this$owner2 = this.owner) === null || _this$owner2 === void 0 ? void 0 : _this$owner2.documentRoot) || this.element.getRootNode();
  }
  get rootElement() {
    const me = this;
    if (!me._rootElement) {
      var _me$owner3;
      let root2 = ((_me$owner3 = me.owner) === null || _me$owner3 === void 0 ? void 0 : _me$owner3.rootElement) || DomHelper.getRootElement(me.forElement || (isInDocument(me.element) ? me.element : me.getRenderContext()[0] || me.element));
      if (!root2) {
        root2 = document.body;
      }
      me._rootElement = root2;
    }
    return me._rootElement;
  }
  get floatRoot() {
    var _me$owner4;
    const me = this, rootElement = me.rootElement || ((_me$owner4 = me.owner) === null || _me$owner4 === void 0 ? void 0 : _me$owner4.rootElement);
    let {
      floatRoot
    } = rootElement;
    if (!floatRoot) {
      var _DomHelper$getThemeIn;
      const {
        outerCls
      } = Widget, themeName = (_DomHelper$getThemeIn = DomHelper.getThemeInfo(null, rootElement)) === null || _DomHelper$getThemeIn === void 0 ? void 0 : _DomHelper$getThemeIn.name;
      if (!DomHelper.isValidFloatRootParent(rootElement)) {
        throw new Error("Attaching float root to wrong root");
      }
      if (themeName) {
        outerCls.push(`b-theme-${themeName.toLowerCase()}`);
      }
      floatRoot = rootElement.floatRoot = DomHelper.createElement({
        className: `b-float-root ${outerCls.join(" ")}`,
        parent: rootElement
      });
      floatRoots.push(floatRoot);
      if (BrowserHelper.isAndroid) {
        floatRoot.style.height = `${screen.height}px`;
        EventHelper.on({
          element: globalThis,
          orientationchange: () => floatRoot.style.height = `${screen.height}px`,
          thisObj: this
        });
      }
      if (!BrowserHelper.isHoverableDevice && globalThis.visualViewport) {
        EventHelper.on({
          element: globalThis.visualViewport,
          resize: ({
            target: viewport
          }) => floatRoot.style.height = `${viewport.height}px`,
          thisObj: this
        });
      }
      GlobalEvents$1.ion({
        theme: ({
          theme,
          prev
        }) => {
          floatRoot.classList.add(`b-theme-${theme.toLowerCase()}`);
          floatRoot.classList.remove(`b-theme-${prev.toLowerCase()}`);
        }
      });
    } else if (!rootElement.contains(floatRoot)) {
      rootElement.appendChild(floatRoot);
    }
    return floatRoot;
  }
  get floatRootMaxZIndex() {
    let max = 1;
    Array.from(this.floatRoot.children).forEach((child) => {
      const zIndex = parseInt(getComputedStyle(child).zIndex || 0, 10);
      if (zIndex > max) {
        max = zIndex;
      }
    });
    return max;
  }
  static resetFloatRootScroll() {
    floatRoots.forEach((floatRoot) => floatRoot.scrollTop = floatRoot.scrollLeft = 0);
  }
  static get floatRoots() {
    return floatRoots;
  }
  static removeFloatRoot(floatRoot) {
    floatRoots.splice(floatRoots.indexOf(floatRoot), 1);
  }
  static get outerCls() {
    const result = ["b-outer"], {
      platform
    } = BrowserHelper;
    if (platform) {
      result.push(`b-${platform}`);
    }
    if (BrowserHelper.isTouchDevice) {
      result.push("b-touch-events");
    }
    if (DomHelper.scrollBarWidth) {
      result.push("b-visible-scrollbar");
    } else {
      result.push("b-overlay-scrollbar");
    }
    if (BrowserHelper.isChrome) {
      result.push("b-chrome");
    } else if (BrowserHelper.isSafari) {
      result.push("b-safari");
    } else if (BrowserHelper.isFirefox) {
      result.push("b-firefox");
    }
    if (!globalThis.ResizeObserver) {
      result.push("b-no-resizeobserver");
    }
    return result;
  }
  get isAnimating() {
    return this._isAnimatingCounter > 0;
  }
  set isAnimating(value) {
    const me = this, {
      _isAnimatingCounter
    } = me;
    me._isAnimatingCounter = Math.max(0, _isAnimatingCounter + (value ? 1 : -1));
    if (_isAnimatingCounter === 0 && value) {
      me.element.classList.add("b-animating");
      me.trigger("animationStart");
    } else if (_isAnimatingCounter === 1 && !value) {
      me.element.classList.remove("b-animating");
      me.trigger("animationEnd");
    }
  }
  async waitForAnimations() {
    if (this.isAnimating) {
      await this.await("animationend", {
        checkLog: false
      });
    }
  }
  static query(selector, deep = false) {
    const {
      idMap
    } = Widget.identifiable;
    for (const id in idMap) {
      if (Widget.widgetMatches(idMap[id], selector, deep)) {
        return idMap[id];
      }
    }
    return null;
  }
  static queryAll(selector, deep = false) {
    const {
      idMap
    } = Widget.identifiable, result = [];
    for (const id in idMap) {
      if (Widget.widgetMatches(idMap[id], selector, deep)) {
        result.push(idMap[id]);
      }
    }
    return result;
  }
  static fromElement(element, type, limit) {
    const typeOfType = typeof type;
    if (element && !element.nodeType) {
      element = element.target;
    }
    if (typeOfType === "number" || type && type.nodeType === Element.ELEMENT_NODE) {
      limit = type;
      type = null;
    }
    let target = element, depth = 0, topmost, cmpId, cmp;
    if (typeof limit !== "number") {
      topmost = limit;
      limit = Number.MAX_VALUE;
    }
    if (typeOfType === "string") {
      type = type.toLowerCase();
    }
    while (target && target.nodeType === Element.ELEMENT_NODE && depth < limit && target !== topmost) {
      cmpId = target.dataset && target.dataset.ownerCmp || target.id;
      if (cmpId) {
        cmp = Widget.getById(cmpId);
        if (cmp) {
          if (type) {
            if (typeOfType === "function") {
              if (type(cmp)) {
                return cmp;
              }
            } else if (Widget.widgetMatches(cmp, type, true)) {
              return cmp;
            }
          } else {
            return cmp;
          }
        }
        depth++;
      }
      target = target.parentNode;
    }
    return null;
  }
  triggerFieldChange(params, trigger = true) {
    if (trigger) {
      this.trigger("change", params);
    }
    this.eachAncestor((ancestor) => {
      var _ancestor$onFieldChan, _ancestor$isolateFiel;
      (_ancestor$onFieldChan = ancestor.onFieldChange) === null || _ancestor$onFieldChan === void 0 ? void 0 : _ancestor$onFieldChan.call(ancestor, params);
      if ((_ancestor$isolateFiel = ancestor.isolateFieldChange) !== null && _ancestor$isolateFiel !== void 0 && _ancestor$isolateFiel.call(ancestor, this)) {
        return false;
      }
    });
  }
  isolateFieldChange(field) {
    return this.isolateFields;
  }
  setupFocusListeners() {
    GlobalEvents$1.setupFocusListenersOnce(this._rootElement, EventHelper);
  }
  static widgetMatches(candidate, selector, deep) {
    if (selector === "*") {
      return true;
    }
    if (typeof selector === "function") {
      return selector(candidate);
    }
    return Widget.isType(candidate, selector, deep);
  }
  static attachTooltip(element, configOrText) {
    if (typeof configOrText === "string")
      configOrText = {
        html: configOrText
      };
    Widget.create(Object.assign({
      forElement: element
    }, configOrText), "tooltip");
    return element;
  }
  changeDock(dock) {
    if (dock === "start") {
      return "left";
    }
    if (dock === "end") {
      return "right";
    }
    return dock;
  }
  updateRtl(rtl) {
    super.updateRtl(rtl);
    this.eachWidget((item) => {
      if (!("rtl" in item.initialConfig)) {
        item.rtl = rtl;
      }
    });
  }
};
var proto$1 = Widget.prototype;
["compose", "domSyncCallback"].forEach((fn2) => proto$1[fn2].$nullFn = true);
Widget.initClass();
Widget.register("mask", Mask);
DomHelper.Widget = Widget;
GlobalEvents$1.Widget = Widget;
Mask.identifiable.idMap = Widget.identifiable.idMap;
Object.assign(globalThis.bryntum || (globalThis.bryntum = {}), {
  get: Widget.getById.bind(Widget),
  query: Widget.query,
  queryAll: Widget.queryAll,
  fromElement: Widget.fromElement
});
Widget._$name = "Widget";
var Layout = class extends Base$1.mixin(Events, Factoryable) {
  get contentElement() {
    var _this$owner;
    return (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.contentElement;
  }
  onChildAdd(item) {
  }
  onChildRemove(item) {
  }
  renderChildren() {
    const me = this, {
      owner,
      itemCls
    } = me, {
      contentElement,
      items: items2
    } = owner, ownerItemCls = owner.itemCls, itemCount = items2 === null || items2 === void 0 ? void 0 : items2.length;
    if (itemCount) {
      owner.textContent = false;
      for (let i = 0; i < itemCount; i++) {
        const item = items2[i], {
          element
        } = item, {
          classList
        } = element;
        element.dataset.itemIndex = i;
        if (classList.contains("b-outer")) {
          classList.remove(...Widget.outerCls);
        }
        if (itemCls) {
          classList.add(itemCls);
        }
        if (ownerItemCls) {
          classList.add(ownerItemCls);
        }
        item.render(contentElement, Boolean(owner.isPainted));
      }
    }
    me.syncPendingConfigs();
    me.syncChildCount();
  }
  removeChild(child) {
    const me = this, {
      element
    } = child, {
      owner,
      itemCls
    } = me, {
      contentElement
    } = owner, ownerItemCls = owner.itemCls;
    if (contentElement.contains(element)) {
      element.remove();
    }
    delete element.dataset.itemIndex;
    if (itemCls) {
      element.classList.remove(itemCls);
    }
    if (ownerItemCls) {
      element.classList.remove(ownerItemCls);
    }
    me.fixChildIndices();
    me.syncChildCount();
  }
  appendChild(child) {
    const {
      element
    } = child, {
      owner,
      itemCls
    } = this, {
      contentElement
    } = owner, ownerItemCls = owner.itemCls;
    element.dataset.itemIndex = owner.indexOfChild(child);
    owner.textContent = false;
    if (itemCls) {
      element.classList.add(itemCls);
    }
    if (ownerItemCls) {
      element.classList.add(ownerItemCls);
    }
    child.render(contentElement, Boolean(owner.isPainted));
    this.syncChildCount();
  }
  insertChild(toAdd, childIndex) {
    const me = this, {
      element
    } = toAdd, {
      owner,
      itemCls
    } = me, {
      contentElement
    } = owner, nextSibling = DomHelper.getChild(contentElement, `[data-item-index="${childIndex}"]`), ownerItemCls = owner.itemCls;
    owner.textContent = false;
    if (itemCls) {
      element.classList.add(itemCls);
    }
    if (ownerItemCls) {
      element.classList.add(ownerItemCls);
    }
    contentElement.insertBefore(element, nextSibling);
    toAdd.render(null, Boolean(owner.isPainted));
    me.fixChildIndices();
    me.syncChildCount();
  }
  fixChildIndices() {
    this.owner.items.forEach((child, index) => {
      child.element.dataset.itemIndex = index;
    });
  }
  syncChildCount() {
    var _owner$contentElement;
    const {
      owner
    } = this, {
      length
    } = owner.items;
    (_owner$contentElement = owner.contentElement) === null || _owner$contentElement === void 0 ? void 0 : _owner$contentElement.classList[length === 1 ? "add" : "remove"]("b-single-child");
  }
  syncConfigLater(config) {
    const pendingConfigs = this.pendingConfigs || (this.pendingConfigs = []);
    if (!pendingConfigs.includes(config)) {
      pendingConfigs.push(config);
    }
  }
  syncConfigStyle({
    name,
    style,
    classes,
    map: map2
  }) {
    const me = this, baseCls = `b-box-${name}-`, {
      contentElement
    } = me, raw = me[name];
    let value = (map2 === null || map2 === void 0 ? void 0 : map2[raw]) || raw;
    if (contentElement) {
      if (classes) {
        const {
          classList
        } = contentElement;
        classes.forEach((c) => {
          if (c !== value) {
            classList.remove(baseCls + c);
          }
        });
        if (classes.includes(value)) {
          classList.add(baseCls + value);
          value = "";
        }
      }
      contentElement.style[style] = value;
    } else {
      me.syncConfigLater(name);
    }
  }
  syncPendingConfigs() {
    const me = this, {
      pendingConfigs
    } = me;
    let name;
    if (pendingConfigs) {
      me.pendingConfigs = null;
      while (name = pendingConfigs.pop()) {
        me[me.$meta.configs[name].updater](me[name]);
      }
    }
  }
};
_defineProperty(Layout, "type", "default");
_defineProperty(Layout, "configurable", {
  owner: null,
  containerCls: "b-auto-container",
  itemCls: null
});
_defineProperty(Layout, "factoryable", {
  defaultType: "default"
});
Layout.initClass();
Layout._$name = "Layout";
var lastTouchTime = 0;
var hasRipple = (w) => w.ripple;
var Ripple = class extends Widget {
  static get defaultConfig() {
    return {
      old_element: {
        children: [{
          className: "b-ripple-inner",
          reference: "rippleElement"
        }]
      },
      element: {
        children: [{
          tag: "svg",
          class: "b-ripple-inner",
          reference: "rippleElement",
          ns: "http://www.w3.org/2000/svg",
          version: "1.1",
          viewBox: "0 0 100 100",
          children: [{
            reference: "circleElement",
            tag: "circle",
            cx: "0",
            cy: "0",
            r: 10
          }]
        }]
      },
      floating: true,
      hideAnimation: false,
      showAnimation: false,
      scrollAction: "realign",
      color: "rgba(0,0,0,.3)",
      startRadius: 10,
      radius: 100
    };
  }
  static get $name() {
    return "Ripple";
  }
  afterConstruct() {
    super.afterConstruct();
    EventHelper.on({
      element: this.rootElement,
      mousedown: "onRippleControllingEvent",
      thisObj: this,
      capture: true,
      once: true
    });
  }
  onRippleControllingEvent(event) {
    var _me$listenerDetacher;
    const me = this;
    me.show();
    const rippleAnimation = DomHelper.getStyleValue(me.circleElement, "animationName");
    me.hide();
    (_me$listenerDetacher = me.listenerDetacher) === null || _me$listenerDetacher === void 0 ? void 0 : _me$listenerDetacher.call(me);
    if (rippleAnimation && rippleAnimation !== "none") {
      me.listenerDetacher = EventHelper.on({
        mousedown: {
          element: me.rootElement,
          capture: true,
          handler: "onMousedown"
        },
        touchstart: {
          element: me.rootElement,
          capture: true,
          handler: "onTouchStart"
        },
        animationend: {
          element: me.circleElement,
          handler: "onAnimationEnd"
        },
        thisObj: me
      });
      if (event.type === "mousedown") {
        me.onMousedown(event);
        GlobalEvents$1.ion({
          theme: "onRippleControllingEvent",
          thisObj: this
        });
      }
    }
  }
  onTouchStart(event) {
    lastTouchTime = performance.now();
    this.handleTriggerEvent(event);
  }
  onMousedown(event) {
    if (performance.now() - lastTouchTime > 200) {
      this.handleTriggerEvent(event);
    }
  }
  handleTriggerEvent(event) {
    const targetWidget = Widget.fromElement(event.target, hasRipple);
    if (targetWidget) {
      const rippleCfg = targetWidget.ripple, target = rippleCfg.delegate ? event.target.closest(rippleCfg.delegate) : targetWidget.focusElement || targetWidget.element;
      if (target) {
        const ripple = ObjectHelper.assign({
          event,
          target,
          radius: this.radius
        }, rippleCfg);
        if (typeof ripple.clip === "string") {
          ripple.clip = targetWidget[ripple.clip] || event.target.closest(ripple.clip);
          if (!ripple.clip) {
            return;
          }
        }
        this.ripple(ripple);
      }
    }
  }
  ripple({
    event,
    point = EventHelper.getClientPoint(event),
    target = event.target,
    clip = target,
    radius = this.radius,
    color = this.color
  }) {
    this.clip = clip;
    clip = Rectangle.from(clip, null, true);
    const me = this, centreDelta = clip.getDelta(point), rippleStyle = me.rippleElement.style, circleElement = me.circleElement, borderRadius = DomHelper.getStyleValue(target, "border-radius");
    me.hide();
    rippleStyle.transform = `translateX(${centreDelta[0]}px) translateY(${centreDelta[1]}px)`;
    rippleStyle.height = rippleStyle.width = `${radius}px`;
    me.element.style.borderRadius = borderRadius;
    circleElement.setAttribute("r", radius);
    circleElement.setAttribute("fill", color);
    me.showBy({
      target: clip,
      align: "c-c",
      matchSize: true
    });
  }
  onAnimationEnd(event) {
    if (event.animationName === "b-ripple-expand") {
      this.hide();
    }
  }
};
Widget.RippleClass = Ripple;
Ripple._$name = "Ripple";
var emptyObject$9 = Object.freeze({});
var {
  isArray
} = Array;
var returnWeight = (i) => i.weight;
var sortByWeight = ({
  weight: a
}, {
  weight: b
}) => {
  if (typeof a === "string" || typeof b === "string") {
    return String(a).localeCompare(String(b));
  }
  return (a !== null && a !== void 0 ? a : Number.MAX_SAFE_INTEGER) - (b !== null && b !== void 0 ? b : Number.MAX_SAFE_INTEGER);
};
var isNotHidden = (w) => w && !w.hidden;
var stylesToCheck = ["display", "flex-direction"];
var boxLayouts = {
  default: 1,
  box: 1
};
var Container = class extends Widget {
  static get $name() {
    return "Container";
  }
  static get type() {
    return "container";
  }
  static get configurable() {
    return {
      items: null,
      lazyItems: {
        $config: ["lazy"],
        value: null
      },
      defaults: null,
      defaultType: "widget",
      layoutStyle: null,
      itemCls: null,
      layout: {
        type: "default"
      },
      namedItems: null,
      overflowable: {
        value: null,
        default: false,
        $config: null
      },
      textContent: true,
      record: null,
      autoUpdateRecord: null,
      autoUpdateFields: null,
      hideWhenEmpty: null,
      contentElMutationObserver: {
        $config: ["lazy", "nullify"],
        value: true
      },
      isolateFields: false,
      focusDescendant: false,
      defaultBindProperty: null,
      defaultFocus: null
    };
  }
  static get prototypeProperties() {
    return {
      flexRowCls: "b-flex-row",
      flexColCls: "b-flex-column",
      initialItems: true
    };
  }
  startConfigure(config) {
    const items2 = config.items || config.lazyItems;
    if (!(this.hasItems = Boolean(items2 && (isArray(items2) ? items2 : Object.keys(items2)).length))) {
      this.initialItems = false;
    }
    super.startConfigure(config);
  }
  get firstItem() {
    return this.getAt(0);
  }
  get lastItem() {
    return this.getAt(-1);
  }
  getAt(index) {
    return this.ensureItems().at(index);
  }
  remove(...toRemove) {
    let returnArray = true;
    if (toRemove.length === 1) {
      if (isArray(toRemove[0])) {
        toRemove = toRemove[0];
      } else {
        returnArray = false;
      }
    }
    const me = this, {
      _items
    } = me, result = [];
    for (let i = 0; i < toRemove.length; i++) {
      const childToRemove = toRemove[i];
      if (_items.includes(childToRemove)) {
        _items.remove(childToRemove);
        me.layout.removeChild(childToRemove);
        result.push(childToRemove);
        me.onChildRemove(childToRemove);
      }
    }
    return returnArray ? result : result[0];
  }
  removeAll() {
    return this.remove(this.items);
  }
  add(...toAdd) {
    const me = this, items2 = me.ensureItems(), result = [];
    let returnArray = true, childToAdd, i, index;
    if (toAdd.length === 1) {
      if (isArray(toAdd[0])) {
        toAdd = toAdd[0];
      } else {
        returnArray = false;
      }
    }
    for (i = 0; i < toAdd.length; i++) {
      var _childToAdd;
      childToAdd = toAdd[i];
      if (childToAdd.isWidget) {
        childToAdd.parent = me;
      } else {
        childToAdd = me.createWidget(childToAdd);
      }
      if (((_childToAdd = childToAdd) === null || _childToAdd === void 0 ? void 0 : _childToAdd.weight) != null) {
        index = ArrayHelper.findInsertionIndex(childToAdd, items2.values, sortByWeight);
        result.push(me.insert(childToAdd, index));
      } else if (childToAdd) {
        if (!items2.includes(childToAdd)) {
          items2.add(childToAdd);
          me.onChildAdd(childToAdd);
          me.layout.appendChild(childToAdd);
          result.push(childToAdd);
        }
      }
    }
    return returnArray ? result : result[0];
  }
  ensureItems() {
    const me = this;
    me.getConfig("items");
    me.getConfig("lazyItems");
    if (!me._items) {
      me.items = [];
    }
    return me._items;
  }
  insert(toAdd, index) {
    const me = this, items2 = me.ensureItems();
    if (toAdd instanceof Widget) {
      toAdd.parent = me;
    } else {
      toAdd = me.createWidget(toAdd);
    }
    if (items2.includes(index)) {
      index = me.indexOfChild(index);
    }
    index = Math.min(index, items2.count);
    const newValues = items2.values;
    newValues.splice(index, 0, toAdd);
    items2.values = newValues;
    me.onChildAdd(toAdd);
    me.layout.insertChild(toAdd, index);
    return toAdd;
  }
  indexOfChild(child) {
    return this.items.indexOf(child);
  }
  changeLazyItems(lazyItems) {
    this.items = lazyItems;
    this.layout.renderChildren();
  }
  changeItems(items2, oldItems) {
    const me = this, newItems = [], result = new Bag();
    if (isArray(items2)) {
      me.processItemsArray(items2, newItems);
    } else if (items2) {
      me.processItemsObject(items2, me.namedItems, newItems);
    }
    if (newItems.some(returnWeight)) {
      newItems.sort(sortByWeight);
    }
    result.add(newItems);
    if (oldItems) {
      oldItems.forEach((w) => {
        me.remove(w);
        if (!result.includes(w) && w._createdBy === me) {
          w.destroy();
        }
      });
    }
    return result;
  }
  afterConstruct() {
    const {
      rtl
    } = this, {
      classList
    } = this.contentElement;
    classList.toggle("b-rtl", rtl === true);
    classList.toggle("b-ltr", rtl === false);
  }
  updateRtl(rtl) {
    super.updateRtl(rtl);
    const {
      contentElement
    } = this;
    if (contentElement) {
      contentElement.classList.toggle("b-rtl", rtl === true);
      contentElement.classList.toggle("b-ltr", rtl === false);
    }
  }
  updateItems(items2, oldItems) {
    let index = 0;
    items2.forEach((item) => {
      this.onChildAdd(item);
      if (oldItems && !oldItems.temporary) {
        this.layout.insertChild(item, index);
      }
      ++index;
    });
    this.initialItems = false;
  }
  updateHideWhenEmpty() {
    this.syncChildCount(this.rendered);
  }
  get items() {
    const me = this;
    me.getConfig("lazyItems");
    if (!me._items) {
      if (me.initializingItems) {
        return [];
      }
      me._items = new Bag();
      me._items.temporary = true;
    }
    return me._items.values;
  }
  processItemsArray(items2, result) {
    const len = items2.length;
    let i, item;
    for (i = 0; i < len; i++) {
      item = items2[i];
      if (item instanceof Widget) {
        item.parent = this;
        item.element.classList.remove(...Widget.outerCls);
      } else {
        item = this.createWidget(item);
      }
      if (item) {
        if (item.ref || item.id) {
          this.addDescendant(item);
        }
        result.push(item);
      }
    }
  }
  processItemsObject(items2, namedItems, result) {
    let item, ref;
    for (ref in items2) {
      item = items2[ref];
      if (item) {
        if (namedItems && ref in namedItems) {
          item = typeof item === "object" ? ObjectHelper.merge(ObjectHelper.clone(namedItems[ref]), item) : namedItems[ref];
        }
        if (item) {
          if (item instanceof Widget) {
            item.parent = this;
          } else {
            if (item instanceof Object) {
              item.ref = ref;
            }
            item = this.createWidget(item);
          }
          if (item) {
            item.ref = ref;
            this.addDescendant(item);
            result.push(item);
          }
        }
      }
    }
  }
  onChildAdd(item) {
    if (item.innerItem && this.readOnly && !item.ignoreParentReadOnly) {
      item.readOnly = true;
    }
    this.onChildAddLayout(item);
    if (item.ref || item.id) {
      for (let current = this; current; current = current.parent) {
        current.addDescendant(item);
      }
    }
    this.syncChildCount(true);
  }
  onChildAddLayout(item) {
    if (item.innerItem) {
      this.layout.onChildAdd(item);
    }
  }
  onChildHide(hidden) {
    var _this$_items;
    super.onChildHide(hidden);
    if ((_this$_items = this._items) !== null && _this$_items !== void 0 && _this$_items.includes(hidden)) {
      this.syncChildCount(true);
    }
  }
  onChildShow(shown) {
    var _this$_items2;
    super.onChildShow(shown);
    if ((_this$_items2 = this._items) !== null && _this$_items2 !== void 0 && _this$_items2.includes(shown)) {
      this.syncChildCount(true);
    }
  }
  syncChildCount(enforceHideWhenEmpty) {
    if (!this.isConfiguring) {
      const me = this, {
        items: items2,
        hasItems
      } = me, visibleItems = items2.filter(isNotHidden), {
        length: visibleLength
      } = visibleItems;
      me.visibleChildCount = visibleLength;
      if (me.hideWhenEmpty && enforceHideWhenEmpty) {
        const shouldHide = Boolean(!visibleLength);
        if (Boolean(me._hidden) !== shouldHide) {
          me.hidden = shouldHide;
        }
      }
      items2.forEach((childItem) => childItem.element.classList.remove("b-last-visible-child", "b-first-visible-child"));
      if (visibleLength) {
        visibleItems[0].element.classList.add("b-first-visible-child");
        visibleItems[visibleLength - 1].element.classList.add("b-last-visible-child");
      }
      me.hasItems = Boolean(me.childItems.length);
      me.contentElement.classList[visibleLength ? "remove" : "add"]("b-no-visible-children");
      if (!me.isComposable) {
        me.updateTextContent(me._textContent);
      } else if (hasItems !== me.hasItems) {
        me.recompose();
      }
    }
  }
  syncFlexDirection() {
    const me = this, {
      contentElement,
      flexColCls,
      flexRowCls
    } = me, classList = new DomClassList(contentElement.className), styles = DomHelper.getStyleValue(contentElement, stylesToCheck);
    classList[flexRowCls] = classList[flexColCls] = 0;
    if (styles.display === "flex") {
      classList[styles["flex-direction"] === "row" ? flexRowCls : flexColCls] = 1;
    }
    DomHelper.syncClassList(contentElement, classList);
  }
  addDescendant(item) {
    const ref = item.ref || item.id, widgetMap = this._widgetMap || (this._widgetMap = {});
    if (!widgetMap[ref]) {
      widgetMap[ref] = item;
    }
  }
  onChildRemove(item) {
    const me = this, ref = item.ref || item.id;
    if (ref) {
      for (let current = me; current; current = current.parent) {
        if (current.widgetMap[ref] === item) {
          delete current.widgetMap[ref];
        }
      }
    }
    me.layout.onChildRemove(item);
    me.syncChildCount(true);
  }
  get widgetMap() {
    if (!this._widgetMap) {
      this._widgetMap = {};
    }
    if (!this.initializingItems) {
      this.getConfig("items");
    }
    return this._widgetMap;
  }
  changeRecord(record) {
    this._record = record == null ? emptyObject$9 : null;
    return record;
  }
  updateRecord(record) {
    var _me$recordUpdateDetac;
    const me = this;
    (_me$recordUpdateDetac = me.recordUpdateDetacher) === null || _me$recordUpdateDetac === void 0 ? void 0 : _me$recordUpdateDetac.call(me);
    me.trigger("beforeSetRecord", {
      record
    });
    me.setValues(record, {
      onlyName: true,
      highlight: Boolean(me.$highlight)
    });
    if (me.autoUpdateFields && record !== null && record !== void 0 && record.firstStore) {
      me.recordUpdateDetacher = record.firstStore.ion({
        update: me.onRecordUpdated,
        thisObj: me
      });
    }
  }
  setRecord(record, highlightChanges) {
    this.$highlight = highlightChanges;
    this.record = record;
    this.$highlight = false;
  }
  onRecordUpdated({
    record
  }) {
    if (record === this.record) {
      this.setValues(this.record, true, true);
    }
  }
  onFieldChange({
    source,
    userAction
  }) {
    if (this.autoUpdateRecord && userAction) {
      const {
        record
      } = this, {
        name,
        isValid = true,
        value
      } = source;
      if (record && name && isValid) {
        record[name] = value;
      }
    }
  }
  getValues(filterFn) {
    const values = {};
    this.eachWidget((widget, control) => {
      if (widget.isolateFields) {
        control.down = false;
      } else if ("name" in widget && (!filterFn || filterFn(widget))) {
        values[widget.name] = widget.value;
      }
    }, true);
    return values;
  }
  get hasNoChildren() {
    const me = this, {
      items: items2,
      lazyItems
    } = me.initialConfig, itemsArray = items2 && (isArray(items2) ? items2 : ObjectHelper.values(items2)), lazyItemsArray = lazyItems && (isArray(lazyItems) ? lazyItems : ObjectHelper.values(lazyItems)), whichItems = me.isConfiguring ? lazyItemsArray || itemsArray : me.items;
    return !(whichItems !== null && whichItems !== void 0 && whichItems.filter(isNotHidden).length);
  }
  afterRecompose() {
    super.afterRecompose();
    this.realign();
  }
  updateTextContent(textContent) {
    const me = this;
    if (!me.isComposable) {
      const needsClass = Boolean(textContent && me.hasNoChildren), {
        classList
      } = me.contentElement, changed = needsClass !== classList.contains("b-text-content");
      if (changed) {
        classList[needsClass ? "add" : "remove"]("b-text-content");
        if (me.rendered) {
          me.realign();
        }
      }
    }
  }
  updateLayoutStyle(layoutStyle) {
    DomHelper.applyStyle(this.contentElement, layoutStyle);
  }
  updateElement(element) {
    super.updateElement(...arguments);
    if (element) {
      const {
        classList
      } = this.contentElement, {
        containerCls
      } = this.layout;
      classList.add("b-content-element");
      if (containerCls) {
        classList.add(containerCls);
      }
    }
  }
  onPaint() {
    var _super$onPaint;
    (_super$onPaint = super.onPaint) === null || _super$onPaint === void 0 ? void 0 : _super$onPaint.call(this, ...arguments);
    this.getConfig("contentElMutationObserver");
  }
  changeContentElMutationObserver(contentElMutationObserver, oldContentElMutationObserver) {
    if (oldContentElMutationObserver) {
      oldContentElMutationObserver.takeRecords();
      oldContentElMutationObserver.disconnect();
    }
    if (contentElMutationObserver) {
      const me = this, {
        element,
        contentElement
      } = me;
      contentElMutationObserver = new MutationObserver((mutations) => me.onContentElMutation(mutations));
      contentElMutationObserver.observe(contentElement, {
        attributes: true
      });
      if (contentElement !== element) {
        contentElMutationObserver.observe(element, {
          attributes: true
        });
      }
      me.syncFlexDirection();
    }
    return contentElMutationObserver;
  }
  onContentElMutation() {
    if (boxLayouts[this.layout.type] && this.isVisible) {
      this.syncFlexDirection();
    }
  }
  changeLayout(config, existingLayout) {
    return Layout.reconfigure(existingLayout, config, {
      owner: this,
      defaults: {
        owner: this
      }
    });
  }
  get childItems() {
    return this.items;
  }
  getWidgetById(id) {
    return this.widgetMap[id];
  }
  processWidgetConfig(widget) {
  }
  setupWidgetConfig(widgetConfig, type) {
    const me = this;
    if (typeof widgetConfig === "string") {
      widgetConfig = {
        html: widgetConfig
      };
    } else if (widgetConfig.nodeType === Element.ELEMENT_NODE) {
      widgetConfig = {
        element: widgetConfig,
        id: widgetConfig.id
      };
    }
    if (typeof type === "string" || !type && (type = widgetConfig.type)) {
      type = Widget.resolveType(type, true);
    }
    widgetConfig = (type || Widget).mergeConfigs(me.defaults, widgetConfig, {
      parent: me
    });
    for (let ancestor = widgetConfig.parent; ancestor; ancestor = ancestor.parent) {
      if (ancestor.processWidgetConfig(widgetConfig) === false) {
        return null;
      }
    }
    if (me.trigger("beforeWidgetCreate", {
      widgetConfig
    }) === false) {
      return null;
    }
    return widgetConfig;
  }
  createWidget(widget) {
    const result = Widget.create(this.setupWidgetConfig(widget), this.defaultType);
    result && (result._createdBy = this);
    return result;
  }
  updateDefaults(defaults, oldDefaults) {
    if (!this.isConfiguring && defaults) {
      const entries = Object.entries(defaults);
      this.eachWidget((widget) => {
        entries.forEach(([prop, value]) => {
          if (!oldDefaults || widget[prop] === oldDefaults[prop]) {
            widget[prop] = value;
          }
        });
      }, false);
    }
  }
  render() {
    this.getConfig("lazyItems");
    this.layout.renderChildren();
    this.syncChildCount();
    super.render(...arguments);
  }
  get focusElement() {
    const firstFocusable = this.query(this.defaultFocus || ((w) => {
      var _w$ref;
      return w.isFocusable && w.ref !== "close" && !((_w$ref = w.ref) !== null && _w$ref !== void 0 && _w$ref.endsWith("collapse"));
    }));
    if (firstFocusable) {
      return firstFocusable.focusElement;
    }
    return super.focusElement;
  }
  doDestroy() {
    var _this$_items3;
    (_this$_items3 = this._items) === null || _this$_items3 === void 0 ? void 0 : _this$_items3.forEach((widget) => {
      var _widget$destroy;
      return (_widget$destroy = widget.destroy) === null || _widget$destroy === void 0 ? void 0 : _widget$destroy.call(widget);
    });
    this.layout.destroy();
    super.doDestroy();
  }
  get isValid() {
    let valid = true;
    this.eachWidget((widget) => {
      if (widget.isVisible && "isValid" in widget && !widget.isValid) {
        valid = false;
      }
    }, true);
    return valid;
  }
  get values() {
    const values = {};
    this.gatherValue(values);
    return values;
  }
  set values(values) {
    this.assignValue(values);
  }
  get isSettingValues() {
    return Boolean(this.assigningValues);
  }
  get assigningValues() {
    var _this$parent;
    return this._assigningValues || ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.assigningValues);
  }
  set assigningValues(v) {
    this._assigningValues = v;
  }
  assignValue(values, options) {
    super.assignValue(values, options);
    if (!this.isolateFields) {
      this.setValues(values, options);
    }
  }
  gatherValue(values) {
    super.gatherValue(values);
    if (!this.isolateFields) {
      this.gatherValues(values);
    }
  }
  setValues(values, options) {
    options = options || this.assignValueDefaults;
    this.assigningValues = options;
    this.eachWidget((widget) => widget.assignValue(values, options), false);
    this.assigningValues = false;
  }
};
Container.initClass();
Container._$name = "Container";
var {
  assign
} = ObjectHelper;
var now = () => performance.now();
var nostart = {
  start: false
};
var unitRe = /^[.\d]+([^\d].*)?$/;
var getTransitions = (element) => {
  const $bryntum = element.$bryntum || (element.$bryntum = {});
  return $bryntum.transitions || ($bryntum.transitions = /* @__PURE__ */ Object.create(null));
};
var milliseconds = (duration, unit) => {
  if (typeof duration === "string") {
    var _unitRe$exec;
    unit = (_unitRe$exec = unitRe.exec(duration)) === null || _unitRe$exec === void 0 ? void 0 : _unitRe$exec[1];
    duration = parseFloat(duration);
  }
  return duration && duration * (unit === "s" || !unit && duration < 10 ? 1e3 : 1);
};
var syncTransitions = (element) => {
  const all = ObjectHelper.values(getTransitions(element)).filter((a) => a.completed == null).map((a) => a.toString());
  element.style.transition = all.join(", ");
};
var Anim = (Target) => class Anim extends Target {
  static get prototypeProperties() {
    return {
      _delay: null,
      _duration: null,
      _retain: null,
      _timing: null,
      _unit: null,
      owner: null,
      reverting: null
    };
  }
  constructor(...args) {
    super(...args);
    this.id = ++idSeed$1;
  }
  start() {
    this.startTime = now();
  }
  get delay() {
    var _ref, _this$_delay, _this$owner;
    return milliseconds((_ref = (_this$_delay = this._delay) !== null && _this$_delay !== void 0 ? _this$_delay : (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.delay) !== null && _ref !== void 0 ? _ref : 0, this.unit);
  }
  set delay(v) {
    this._delay = v;
  }
  get duration() {
    var _this$_duration;
    const {
      owner,
      unit
    } = this;
    return milliseconds((_this$_duration = this._duration) !== null && _this$_duration !== void 0 ? _this$_duration : owner ? owner.duration : Animator.defaultDuration, unit);
  }
  set duration(v) {
    this._duration = v;
  }
  get elapsed() {
    return now() - this.startTime;
  }
  get remaining() {
    return this.duration - this.elapsed;
  }
  get retain() {
    var _this$_retain, _this$owner2;
    return (_this$_retain = this._retain) !== null && _this$_retain !== void 0 ? _this$_retain : (_this$owner2 = this.owner) === null || _this$owner2 === void 0 ? void 0 : _this$owner2.retain;
  }
  set retain(v) {
    this._retain = v;
  }
  get timing() {
    var _this$_timing, _this$owner3;
    return (_this$_timing = this._timing) !== null && _this$_timing !== void 0 ? _this$_timing : (_this$owner3 = this.owner) === null || _this$owner3 === void 0 ? void 0 : _this$owner3.timing;
  }
  set timing(v) {
    this._timing = v;
  }
  get unit() {
    var _this$_unit, _this$owner4;
    return (_this$_unit = this._unit) !== null && _this$_unit !== void 0 ? _this$_unit : (_this$owner4 = this.owner) === null || _this$owner4 === void 0 ? void 0 : _this$owner4.unit;
  }
  set unit(v) {
    this._unit = v;
  }
};
var idSeed$1 = 0;
var AnimatorTransition = class extends Base$1.mixin(Anim) {
  static get $name() {
    return "AnimatorTransition";
  }
  static get prototypeProperties() {
    return {
      element: null,
      property: null,
      from: null,
      to: null,
      completed: null,
      promissory: null,
      reverting: null
    };
  }
  afterConstruct() {
    super.afterConstruct();
    const me = this, {
      element,
      transitions
    } = me;
    let {
      property
    } = me;
    [property, me.to] = DomHelper.unitize(property, me.to);
    me.from = DomHelper.unitize(property, me.from)[1];
    me.promissory = new Promissory();
    me.property = property;
    const was = transitions[property];
    transitions[property] = me;
    let {
      from
    } = me;
    if (was) {
      me.from = was.to;
      from = null;
      was.destroy();
    }
    if (from === null) {
      from = me.getCurrentStyleValue();
      if (!was) {
        me.from = from;
      }
    }
    element.style[property] = from;
    me.getCurrentStyleValue();
  }
  doDestroy() {
    const me = this;
    me.finish(false);
    if (me.completed && !me.retain) {
      me.clearStyle();
    }
    super.doDestroy();
  }
  get promise() {
    var _this$promissory;
    return (_this$promissory = this.promissory) === null || _this$promissory === void 0 ? void 0 : _this$promissory.promise;
  }
  get transitions() {
    return getTransitions(this.element);
  }
  clearStyle() {
    this.setStyle("");
  }
  finish(complete) {
    const me = this, {
      transitions,
      promissory,
      property
    } = me;
    if (promissory) {
      me.completed = complete;
      me.promissory = null;
      promissory.resolve(complete);
      if (transitions[property] === me) {
        delete transitions[property];
        if (!complete) {
          syncTransitions(me.element);
          me.clearStyle();
        }
      } else {
        me.completed = false;
      }
    }
  }
  getCurrentStyleValue() {
    return DomHelper.getStyleValue(this.element, this.property);
  }
  revert() {
    const {
      duration,
      elapsed,
      element,
      from,
      property,
      _retain: retain,
      _timing: timing
    } = this;
    return new AnimatorTransition({
      element,
      property,
      retain,
      timing,
      duration: Math.round(Math.min(duration, elapsed)),
      reverting: this,
      to: from,
      unit: "ms"
    });
  }
  setStyle(value) {
    this.element.style[this.property] = value;
  }
  start() {
    const me = this, {
      delay: delay2,
      duration,
      element,
      property
    } = me;
    EventHelper.onTransitionEnd({
      element,
      property,
      duration: delay2 + duration + 20,
      thisObj: me.owner,
      handler: () => {
        var _me$finish;
        return (_me$finish = me.finish) === null || _me$finish === void 0 ? void 0 : _me$finish.call(me, true);
      }
    });
    super.start();
    me.setStyle(me.to);
  }
  toString() {
    const {
      delay: delay2,
      duration,
      property,
      timing
    } = this;
    return `${property} ${duration}ms ${timing || "ease-in-out"}${delay2 ? ` ${delay2}ms` : ""}`;
  }
};
AnimatorTransition.initClass();
var Animator = class extends Base$1.mixin(Anim) {
  static get $name() {
    return "Animator";
  }
  static get prototypeProperties() {
    return {
      element: null,
      finalize: null,
      prefinalize: null,
      completed: null,
      items: null
    };
  }
  static register(name, fn2) {
    if (ObjectHelper.isObject(name)) {
      ObjectHelper.entries(name).forEach((entry) => Animator.register(...entry));
      return;
    }
    Animator.fx[name] = fn2;
    Animator[name] = (options) => {
      if (DomHelper.isElement(options)) {
        options = {
          element: options,
          [name]: {}
        };
      } else {
        options = {
          element: options.element,
          [name]: options
        };
        delete options[name].element;
      }
      return Animator.run(options);
    };
  }
  static run(options) {
    return new Animator(options).start();
  }
  constructor(options) {
    var _me$items;
    super(null);
    const me = this, items2 = [], properties = {};
    let anim, fx, key, t;
    if (Array.isArray(options)) {
      me.items = options;
    } else {
      for (key in options) {
        (Animator.specialPropsRe.test(key) ? me : properties)[key] = options[key];
      }
    }
    ObjectHelper.keys(properties).forEach((property) => {
      t = properties[property];
      if (t != null && t !== false && t === t) {
        if (!(fx = Animator.fx[property])) {
          t = assign(me.defaults, typeof t === "object" ? t : {
            to: t
          });
          t.owner = me;
          t.property = property;
          anim = new AnimatorTransition(t);
        } else {
          t = assign(me.defaults, fx(t, me, property));
          t.owner = me;
          anim = new Animator(t);
        }
        items2.push(anim);
      }
    });
    (_me$items = me.items) === null || _me$items === void 0 ? void 0 : _me$items.forEach((item) => {
      if (ObjectHelper.isInstantiated(item)) {
        item.owner = me;
      } else {
        item = assign(me.defaults, item);
        item.owner = me;
        item = new Animator(item);
      }
      items2.push(item);
    });
    me.items = items2;
    me.promise = (items2.length === 1 ? items2[0].promise : Promise.all(items2.map((it) => it.promise))).then((res) => {
      var _me$finish2;
      (_me$finish2 = me.finish) === null || _me$finish2 === void 0 ? void 0 : _me$finish2.call(me, res);
      return me.completed || false;
    });
  }
  doDestroy() {
    this.items.forEach((a) => a.destroy());
    super.doDestroy();
  }
  get defaults() {
    return {
      element: this.element
    };
  }
  get retain() {
    const {
      _retain,
      finalize,
      owner
    } = this;
    return _retain !== null && _retain !== void 0 ? _retain : finalize ? false : owner ? owner.retain : true;
  }
  set retain(v) {
    super.retain = v;
  }
  done() {
    return this.promise;
  }
  finish(complete) {
    var _me$prefinalize, _me$finalize;
    const me = this, {
      items: items2
    } = me;
    syncTransitions(me.element);
    me.completed = typeof complete === "boolean" ? complete : !complete.some((a) => !a);
    (_me$prefinalize = me.prefinalize) === null || _me$prefinalize === void 0 ? void 0 : _me$prefinalize.call(me, me.completed, me);
    while (items2.length) {
      items2.pop().destroy();
    }
    (_me$finalize = me.finalize) === null || _me$finalize === void 0 ? void 0 : _me$finalize.call(me, me.completed, me);
  }
  revert(options) {
    var _options$start;
    const me = this, {
      reverting
    } = me, start = !options || ((_options$start = options.start) !== null && _options$start !== void 0 ? _options$start : true);
    let anim = me.defaults;
    if (reverting) {
      if (reverting.finalize) {
        anim.finalize = reverting.finalize;
      }
      if (reverting.prefinalize) {
        anim.prefinalize = reverting.prefinalize;
      }
      anim.retain = reverting._retain;
    }
    anim = assign(anim, options, {
      items: me.items.map((it) => it.revert(nostart)),
      reverting: me
    });
    anim = new Animator(anim);
    start && anim.start();
    return anim;
  }
  start() {
    const {
      element,
      items: items2
    } = this;
    super.start();
    if (items2.length) {
      syncTransitions(element);
      items2.forEach((a) => a.start());
    }
    return this;
  }
};
Animator.initClass().Transition = AnimatorTransition;
Animator.specialPropsRe = new RegExp(`^(?:${Object.keys(Animator.prototypeProperties).concat(Object.keys(Animator.superclass.prototypeProperties)).map((s) => s[0] === "_" ? s.substr(1) : s).join("|")})$`);
Animator.defaultDuration = 200;
Animator.fx = {};
Animator.register({
  puff(anim) {
    if (anim === true) {
      anim = {};
    } else if (typeof anim !== "object") {
      anim = {
        transform: `scale(${anim})`
      };
    } else if (anim.scale) {
      anim = ObjectHelper.clone(anim);
      anim.transform = `scale(${anim.scale})`;
      delete anim.scale;
    }
    return assign({
      opacity: 0,
      transform: "scale(8)"
    }, anim);
  }
});
Animator._$name = "Animator";
var ClickRepeater = class extends Base$1.mixin(Delayable) {
  static get configurable() {
    return {
      element: null,
      delegate: null,
      delay: 500,
      startRate: 2,
      endRate: 20,
      accelerateDuration: 4e3,
      pressedCls: "b-pressed"
    };
  }
  doDestroy() {
    var _this$mousedownRemove;
    (_this$mousedownRemove = this.mousedownRemover) === null || _this$mousedownRemove === void 0 ? void 0 : _this$mousedownRemove.call(this);
    this.cancel();
    super.doDestroy();
  }
  cancel() {
    var _me$activeElement, _me$acceleration, _me$activeListenerRem;
    const me = this;
    (_me$activeElement = me.activeElement) === null || _me$activeElement === void 0 ? void 0 : _me$activeElement.classList.remove(me.pressedCls);
    me.activeElement = null;
    (_me$acceleration = me.acceleration) === null || _me$acceleration === void 0 ? void 0 : _me$acceleration.cancel();
    me.activeListenerRemover = (_me$activeListenerRem = me.activeListenerRemover) === null || _me$activeListenerRem === void 0 ? void 0 : _me$activeListenerRem.call(me);
    me.clearTimeout(me.autoRepeatTimer);
    me.clearTimeout(me.repeatTimer);
  }
  updateElement(element) {
    var _this$mousedownRemove2;
    (_this$mousedownRemove2 = this.mousedownRemover) === null || _this$mousedownRemove2 === void 0 ? void 0 : _this$mousedownRemove2.call(this);
    this.mousedownRemover = EventHelper.on({
      element,
      mousedown: "onMouseDown",
      thisObj: this
    });
  }
  onMouseDown(e) {
    const me = this, target = me.delegate ? e.target.closest(me.delegate) : me.element;
    me.cancel();
    if (target) {
      me.activeElement = target;
      me.triggerEvent = e;
      target.classList.add(me.pressedCls);
      me.activeListenerRemover = EventHelper.on({
        mouseup: {
          element: document,
          capture: true,
          handler: "onMouseUp"
        },
        mousemove: {
          element: target,
          handler: "onTargetMouseMove"
        },
        mouseleave: {
          element: target,
          handler: "onTargetMouseLeave"
        },
        mouseenter: {
          element: target,
          handler: "onTargetMouseEnter"
        },
        thisObj: me
      });
      me.autoRepeatTimer = me.setTimeout("startAutoRepeat", me.delay);
    }
  }
  onMouseUp() {
    this.cancel();
  }
  onTargetMouseLeave() {
    this.activeElement.classList.remove(this.pressedCls);
    this.clearTimeout(this.repeatTimer);
  }
  onTargetMouseEnter(e) {
    const me = this;
    if (!e.buttons) {
      me.cancel();
    } else {
      me.activeElement.classList.add(me.pressedCls);
      me.triggerEvent = e;
      me.fireClick();
    }
  }
  onTargetMouseMove(e) {
    this.triggerEvent = e;
  }
  startAutoRepeat() {
    const me = this;
    me.interval = me.startInterval = 1e3 / me.startRate;
    me.accelerationDelta = me.startInterval - 1e3 / me.endRate;
    me.fireClick();
    me.acceleration = FunctionHelper.animate(me.accelerateDuration, me.nextTick, me, "easeOutQuad");
  }
  nextTick(progress) {
    this.interval = this.startInterval - this.accelerationDelta * progress;
  }
  fireClick() {
    const me = this, clickEvent = new MouseEvent("click", me.triggerEvent);
    me.triggerEvent.target.dispatchEvent(clickEvent);
    me.repeatTimer = me.setTimeout(me.fireClick, me.interval);
  }
};
ClickRepeater._$name = "ClickRepeater";
var autoRotateRe = /^(?:undefined|null|LEFT|RIGHT)$/;
var inverted = {
  TOP: "BOTTOM",
  RIGHT: "LEFT",
  BOTTOM: "TOP",
  LEFT: "RIGHT"
};
var canonicalDock = (dock) => {
  const DOCK = dock === null || dock === void 0 ? void 0 : dock.toUpperCase();
  return [DOCK, DOCK === "LEFT" || DOCK === "RIGHT"];
};
var Rotatable = (Target) => class Rotatable extends (Target || Base$1) {
  static get $name() {
    return "Rotatable";
  }
  static get configurable() {
    return {
      rotate: null,
      invertRotate: null
    };
  }
  compose() {
    const {
      rotate
    } = this;
    return {
      class: {
        [`b-rotate-${(rotate || "").toLowerCase()}`]: rotate,
        "b-rotate-vertical": rotate
      }
    };
  }
  syncRotationToDock(dock) {
    if (autoRotateRe.test(String(this.rotate))) {
      const [DOCK, vertical] = canonicalDock(dock);
      this.rotate = vertical ? this.invertRotate ? inverted[DOCK] : DOCK : null;
    }
  }
  get widgetClass() {
    return null;
  }
};
var Tool = class extends Widget.mixin(Rotatable) {
  compose() {
    const {
      align,
      href
    } = this;
    return {
      tag: href != null ? "a" : "button",
      class: {
        [`b-align-${align || "end"}`]: 1,
        "b-icon": 1
      },
      listeners: {
        click: "onInternalClick"
      }
    };
  }
  get focusElement() {
    return this.element;
  }
  get panel() {
    var _this$parent, _this$element;
    if ((_this$parent = this.parent) !== null && _this$parent !== void 0 && _this$parent.isPanel && (_this$element = this.element) !== null && _this$element !== void 0 && _this$element.parentNode.matches(".b-panel-header")) {
      return this.parent;
    }
  }
  changeAlign(align) {
    return align;
  }
  onInternalClick(domEvent) {
    const me = this, {
      handler,
      panel
    } = me, bryntumEvent = {
      domEvent,
      tool: me
    };
    if (me.disabled) {
      return;
    }
    me.trigger("click", bryntumEvent);
    if (!me.isDestroyed) {
      me.trigger("action", bryntumEvent);
      if (!me.isDestroyed && (panel === null || panel === void 0 ? void 0 : panel.trigger("toolClick", bryntumEvent)) !== false) {
        handler && me.callback(handler, panel, [domEvent, panel, me]);
      }
    }
  }
  onInternalKeyDown(keyEvent) {
    const keyName = keyEvent.key.trim() || keyEvent.code;
    if (keyName === "Enter") {
      keyEvent.cancelBubble = true;
      keyEvent.stopPropagation();
    }
  }
  updateDisabled(disabled, was) {
    var _this$repeat;
    super.updateDisabled(disabled, was);
    disabled && ((_this$repeat = this.repeat) === null || _this$repeat === void 0 ? void 0 : _this$repeat.cancel());
  }
  changeRepeat(repeat, oldRepeat) {
    oldRepeat === null || oldRepeat === void 0 ? void 0 : oldRepeat.destroy();
    return repeat && ClickRepeater.new({
      element: this.element
    }, repeat);
  }
};
_defineProperty(Tool, "$name", "Tool");
_defineProperty(Tool, "type", "tool");
_defineProperty(Tool, "configurable", {
  align: {
    value: null,
    $config: {
      merge: "replace"
    }
  },
  href: null,
  repeat: null,
  defaultBindProperty: null
});
Tool.initClass();
Tool._$name = "Tool";
var rightRe = /right/i;
var autoAlign = (tool) => (tool.collapsed || tool.collapsing) && tool.owner.expandedHeaderDock === "top" && tool.owner.collapsible.direction.match(rightRe) ? "start" : "end";
var CollapseTool = class extends Tool {
  static get $name() {
    return "CollapseTool";
  }
  static get type() {
    return "collapsetool";
  }
  static get configurable() {
    return {
      autoAlign: true,
      collapsed: null,
      collapsing: null,
      collapsify: false,
      direction: "up",
      defaultBindProperty: null
    };
  }
  compose() {
    const {
      collapsed,
      direction
    } = this;
    return {
      class: {
        [`b-icon-collapse-${direction}`]: 1,
        "b-collapsed": collapsed
      }
    };
  }
  changeAutoAlign(v) {
    return v === true ? autoAlign : v;
  }
  syncAutoAlign() {
    const {
      autoAlign: autoAlign2
    } = this;
    if (autoAlign2) {
      this.align = autoAlign2(this);
    }
  }
  updateAutoAlign() {
    this.syncAutoAlign();
  }
  updateCollapsed() {
    this.syncAutoAlign();
  }
  updateCollapsing() {
    this.syncAutoAlign();
  }
  updateDirection() {
    this.syncAutoAlign();
  }
};
CollapseTool.initClass();
CollapseTool._$name = "CollapseTool";
var defaultedDirectionRe = /^(?:UP|DOWN|LEFT|RIGHT)$/;
var dockBeforeRe = /^(left|top)$/i;
var emptyArray$8 = [];
var emptySplit$1 = [emptyArray$8, emptyArray$8];
var headerDockRe = /^b-dock-(top|left|right|bottom)$/;
var revealerCls = "b-panel-collapse-revealer";
var sideDockRe = /^(?:left|right)$/i;
var unflexCls = "b-collapse-unflex";
var {
  round
} = Math;
var canonicalDirection = ["up", "down", "left", "right"].reduce((o, v) => {
  o[v.toUpperCase()] = o[v] = v;
  return o;
}, {});
var clipByDock = {
  top: ["top", "bottom"],
  right: ["right", "left"],
  bottom: ["bottom", "top"],
  left: ["left", "right"]
};
var collapseDirectionByPlacement = {
  hl: "LEFT",
  hr: "RIGHT",
  vb: "DOWN",
  vt: "UP"
};
var crossAxis = {
  h: "w",
  w: "h"
};
var dockByDirection = {
  up: "top",
  right: "right",
  down: "bottom",
  left: "left"
};
var dockIsHorz$1 = {
  top: false,
  right: true,
  bottom: false,
  left: true
};
var directionByDock = {
  top: "UP",
  right: "RIGHT",
  bottom: "DOWN",
  left: "LEFT"
};
var transverseTransform = {
  top: (rect) => `translate(0, -${round(rect.height || 0)}px)`,
  bottom: (rect) => `translate(0, ${round(rect.height || 0)}px)`,
  right: (rect) => `translate(${round(rect.width || 0)}px, 0)`,
  left: (rect) => `translate(-${round(rect.width || 0)}px, 0)`
};
var idSeed = 0;
var PanelCollapser = class extends Base$1.mixin(Factoryable) {
  static get $name() {
    return "PanelCollapser";
  }
  static get type() {
    return "inline";
  }
  static get configurable() {
    return {
      animation: {
        duration: 200
      },
      collapsed: {
        value: null,
        $config: null,
        default: false
      },
      direction: null,
      collapseTooltip: "L{Collapse}",
      expandTooltip: "L{Expand}",
      panel: {
        value: null,
        $config: "nullify"
      },
      supportAxis: null,
      tool: {
        type: "collapsetool",
        handler(ev) {
          var _this$collapsible;
          (_this$collapsible = this.collapsible) === null || _this$collapsible === void 0 ? void 0 : _this$collapsible.onCollapseClick(ev);
        }
      }
    };
  }
  static get factoryable() {
    return {
      defaultType: "inline"
    };
  }
  get collapsing() {
    return this.collapsingExpanding === "collapsing";
  }
  get collapsingExpanding() {
    var _this$currentOperatio;
    const state = (_this$currentOperatio = this.currentOperation) === null || _this$currentOperatio === void 0 ? void 0 : _this$currentOperatio.collapsing;
    return state == null ? null : state ? "collapsing" : "expanding";
  }
  get currentDock() {
    var _this$panel$header$do, _this$panel, _this$panel$header, _this$panel$header$do2;
    return (_this$panel$header$do = (_this$panel = this.panel) === null || _this$panel === void 0 ? void 0 : (_this$panel$header = _this$panel.header) === null || _this$panel$header === void 0 ? void 0 : (_this$panel$header$do2 = _this$panel$header.dock) === null || _this$panel$header$do2 === void 0 ? void 0 : _this$panel$header$do2.toLowerCase()) !== null && _this$panel$header$do !== void 0 ? _this$panel$header$do : "top";
  }
  get expanding() {
    return this.collapsingExpanding === "expanding";
  }
  get collapseTool() {
    var _this$panel2, _this$panel2$tools;
    return (_this$panel2 = this.panel) === null || _this$panel2 === void 0 ? void 0 : (_this$panel2$tools = _this$panel2.tools) === null || _this$panel2$tools === void 0 ? void 0 : _this$panel2$tools.collapse;
  }
  get collapseDim() {
    return sideDockRe.test(this.collapseDir) ? "width" : "height";
  }
  getCollapseDir(canonical) {
    let {
      direction,
      panel
    } = this;
    if (!direction || defaultedDirectionRe.test(direction)) {
      const placement = panel === null || panel === void 0 ? void 0 : panel.placement;
      if (placement) {
        direction = collapseDirectionByPlacement[placement];
      } else {
        var _panel$header;
        direction = directionByDock[(panel === null || panel === void 0 ? void 0 : (_panel$header = panel.header) === null || _panel$header === void 0 ? void 0 : _panel$header.dock) || "top"];
      }
    }
    return canonical ? canonicalDirection[direction] : direction;
  }
  get collapseDir() {
    return this.getCollapseDir(true);
  }
  get collapseDock() {
    return this.collapseInfo[0];
  }
  get collapseInfo() {
    const {
      panel
    } = this, headerDock2 = panel.hasHeader && panel.expandedHeaderDock;
    let dock = dockByDirection[this.collapseDir], transverse = false;
    if (headerDock2) {
      if (!(transverse = dockIsHorz$1[dock] !== dockIsHorz$1[headerDock2])) {
        dock = headerDock2;
      }
    }
    return [dock, transverse];
  }
  get toolsConfig() {
    const {
      direction,
      tool
    } = this;
    return tool && {
      collapse: ObjectHelper.assign({
        direction: direction.toLowerCase()
      }, tool)
    };
  }
  beforeCollapse(operation) {
    const {
      panel
    } = this, {
      element
    } = panel;
    if (element.contains(DomHelper.getActiveElement(element))) {
      panel.revertFocus(true);
    }
  }
  changeTool(tool) {
    const me = this, {
      panel
    } = me;
    if (me.isConfiguring || me.isDestroying || !panel || panel.isDestroying) {
      return tool;
    }
    panel.tools = {
      collapse: tool
    };
  }
  collapse(collapsed) {
    var _collapsed, _currentOperation, _currentOperation$ani, _currentOperation2, _currentOperation2$an;
    const me = this, {
      panel
    } = me, operation = {
      id: ++idSeed,
      completed: false,
      panel
    };
    let {
      currentOperation
    } = me;
    collapsed = (_collapsed = collapsed) !== null && _collapsed !== void 0 ? _collapsed : true;
    if (ObjectHelper.isObject(collapsed)) {
      operation.collapsed = true;
      ObjectHelper.assign(operation, collapsed);
      collapsed = operation.collapsed;
      delete operation.collapsed;
    }
    operation.collapsing = collapsed;
    operation.previous = (_currentOperation = currentOperation) !== null && _currentOperation !== void 0 ? _currentOperation : null;
    if (collapsed !== me.collapsed) {
      if (currentOperation) {
        if (currentOperation.collapsing !== collapsed) {
          operation.animation = currentOperation.animation.revert({
            finalize() {
              var _me$collapseFinalize;
              (_me$collapseFinalize = me.collapseFinalize) === null || _me$collapseFinalize === void 0 ? void 0 : _me$collapseFinalize.call(me, operation, true);
            }
          });
          operation.collapsing = collapsed;
          currentOperation = operation;
        }
      } else {
        operation.animation = ObjectHelper.clone(("animation" in operation ? operation : me).animation);
        if (me.beforeCollapse(operation) !== false) {
          if (operation.animation) {
            operation.animation.finalize = (complete) => {
              var _me$collapseFinalize2;
              return (_me$collapseFinalize2 = me.collapseFinalize) === null || _me$collapseFinalize2 === void 0 ? void 0 : _me$collapseFinalize2.call(me, operation, complete);
            };
          }
          panel.changingCollapse = true;
          me[collapsed ? "collapseBegin" : "expandBegin"](operation);
          if (operation.animation) {
            currentOperation = operation;
          } else {
            operation.completed = true;
            me[collapsed ? "collapseEnd" : "expandEnd"](operation);
          }
          panel.changingCollapse = false;
          if (!operation.animation) {
            me.onComplete(collapsed ? "collapse" : "expand");
          }
        }
      }
    } else if (currentOperation && currentOperation.collapsing !== collapsed) {
      me[collapsed ? "expandRevert" : "collapseRevert"](operation);
      operation.animation = currentOperation.animation.revert({
        finalize() {
          var _me$collapseFinalize3;
          (_me$collapseFinalize3 = me.collapseFinalize) === null || _me$collapseFinalize3 === void 0 ? void 0 : _me$collapseFinalize3.call(me, operation, false);
        }
      });
      currentOperation = operation;
    }
    me.currentOperation = currentOperation;
    return (_currentOperation$ani = (_currentOperation2 = currentOperation) === null || _currentOperation2 === void 0 ? void 0 : (_currentOperation2$an = _currentOperation2.animation) === null || _currentOperation2$an === void 0 ? void 0 : _currentOperation2$an.done()) !== null && _currentOperation$ani !== void 0 ? _currentOperation$ani : Promise.resolve(collapsed === me.collapsed);
  }
  collapseFinalize(operation, complete) {
    const me = this, {
      currentOperation,
      panel
    } = me, action = panel.collapsed ? "expand" : "collapse";
    if (currentOperation === operation) {
      me.currentOperation = null;
      operation.completed = complete;
      panel.changingCollapse = true;
      me[action + "End"](operation);
      panel.changingCollapse = false;
      complete && me.onComplete(action);
    }
  }
  applyHeaderDock(collapsed, flush = true) {
    const me = this, {
      currentDock,
      panel
    } = me, dock = collapsed ? me.collapseDock : panel.expandedHeaderDock;
    if (dock !== currentDock && panel.hasHeader) {
      panel.header = {
        dock
      };
      flush && panel.recompose.flush();
    }
  }
  composeHeader(header) {
    const {
      panel
    } = this, {
      class: cls
    } = header, dock = panel.expandedHeaderDock || Object.keys(cls).filter((k) => cls[k] && headerDockRe.test(k)).map((k) => headerDockRe.exec(k)[1][0]);
    cls[revealerCls] = 1;
    cls[`b-collapsible-${dock[0]}${this.collapseDir[0]}`] = 1;
    return header;
  }
  composeTitle(title) {
    title.class[revealerCls] = 1;
    return title;
  }
  collapseBegin(operation) {
    var _panel$headerElement;
    const me = this, {
      animation
    } = operation, {
      collapseDim,
      collapseTool,
      panel
    } = me, {
      element,
      placement
    } = panel, [collapseDock, transverse] = me.collapseInfo, collapseToolClasses = collapseTool === null || collapseTool === void 0 ? void 0 : collapseTool.element.classList, unflex = !placement || placement[0] === "h" && collapseDim === "width" || placement[0] === "v" && collapseDim === "height";
    me.configuredWidth = panel._lastWidth;
    me.configuredHeight = panel._lastHeight;
    me.transverseCollapse = transverse;
    me.applyHeaderDock(true);
    const panelRect = panel.rectangle(), bodyWrapRect = me.lockInnerSize().moveTo(0, 0), bodyWrapClipRect = bodyWrapRect.clone(), clipDir = clipByDock[collapseDock], headerRect = (_panel$headerElement = panel.headerElement) === null || _panel$headerElement === void 0 ? void 0 : _panel$headerElement.getBoundingClientRect(), collapsedSize = round((headerRect === null || headerRect === void 0 ? void 0 : headerRect[collapseDim]) || 0);
    element.classList.toggle(unflexCls, unflex);
    if (animation) {
      bodyWrapClipRect[clipDir[0]] = bodyWrapClipRect[clipDir[1]];
      element.classList.add("b-collapsing");
      collapseToolClasses === null || collapseToolClasses === void 0 ? void 0 : collapseToolClasses.add("b-collapsed", "b-collapsing");
      if (collapseTool) {
        collapseTool.collapsing = true;
      }
      if (collapseToolClasses) {
        collapseToolClasses.remove("b-collapsed");
        panel.rectangle();
        collapseToolClasses.remove("b-collapsing");
        collapseToolClasses.add("b-collapsed");
      }
      animation.element = element;
      animation.retain = true;
      animation[collapseDim] = {
        from: round(panelRect[collapseDim]),
        to: collapsedSize
      };
      animation.items = [{
        element: me.innerElement,
        retain: false,
        clip: {
          from: `rect(${bodyWrapRect})`,
          to: `rect(${bodyWrapClipRect})`
        }
      }];
      if (transverse) {
        animation.items.push({
          element: panel.headerElement,
          duration: animation.duration,
          retain: false,
          transform: {
            from: transverseTransform[collapseDock](headerRect),
            to: `translate(0, 0)`
          }
        });
      }
      operation.animation = Animator.run(animation);
    } else {
      element.style[collapseDim] = `${collapsedSize}px`;
      if (collapseTool) {
        collapseToolClasses.add("b-collapsing", "b-collapsed");
        collapseTool.rectangle();
        collapseToolClasses.remove("b-collapsing");
      }
    }
  }
  collapseEnd(operation) {
    const me = this, {
      collapseTool
    } = me;
    me.panel.element.classList.remove("b-collapsing");
    if (collapseTool) {
      collapseTool.collapsing = false;
    }
    if (operation.completed) {
      me.collapsed = true;
    } else {
      me.applyHeaderDock(false);
      me.restoreConfiguredSize();
      me.lockInnerSize(false);
    }
  }
  collapseRevert(operation) {
    var _this$collapseTool;
    (_this$collapseTool = this.collapseTool) === null || _this$collapseTool === void 0 ? void 0 : _this$collapseTool.element.classList.remove("b-collapsed");
  }
  expandBegin(operation) {
    const me = this, {
      animation
    } = operation, {
      collapseDim,
      collapseTool,
      panel
    } = me, [collapseDock, transverse] = me.collapseInfo, {
      element
    } = panel, elementClassList = element.classList, unflex = elementClassList.contains(unflexCls), fromRect = panel.rectangle();
    elementClassList.remove("b-collapsed", "b-collapsing");
    panel.element.style[collapseDim] = "";
    me.restoreConfiguredSize();
    me.lockInnerSize(false);
    const toRect = panel.rectangle(), bodyWrapRect = me.lockInnerSize().moveTo(0, 0), bodyWrapClipRect = bodyWrapRect.clone(), clipDir = clipByDock[me.collapseDock];
    collapseTool === null || collapseTool === void 0 ? void 0 : collapseTool.element.classList.remove("b-collapsed");
    if (animation) {
      bodyWrapClipRect[clipDir[0]] = bodyWrapClipRect[clipDir[1]];
      elementClassList.add("b-collapsed", "b-expanding");
      unflex && elementClassList.add(unflexCls);
      animation.element = element;
      animation[collapseDim] = {
        from: round(fromRect[collapseDim]),
        to: round(toRect[collapseDim])
      };
      animation.items = [{
        element: me.innerElement,
        retain: false,
        clip: {
          from: `rect(${bodyWrapClipRect})`,
          to: `rect(${bodyWrapRect})`
        }
      }];
      if (transverse) {
        animation.items.push({
          element: panel.headerElement,
          duration: animation.duration,
          retain: false,
          transform: {
            from: `translate(0, 0)`,
            to: transverseTransform[collapseDock](fromRect)
          }
        });
      }
      operation.animation = Animator.run(animation);
    }
  }
  expandEnd(operation) {
    const me = this;
    me.panel.element.classList.remove("b-expanding");
    if (operation.completed) {
      me.collapsed = false;
      me.applyHeaderDock(false);
      me.restoreConfiguredSize();
      me.lockInnerSize(false);
    }
  }
  expandRevert(operation) {
    var _this$collapseTool2;
    (_this$collapseTool2 = this.collapseTool) === null || _this$collapseTool2 === void 0 ? void 0 : _this$collapseTool2.element.classList.add("b-collapsed");
  }
  get innerElement() {
    return this.panel.collapseWrapElement || this.panel.bodyWrapElement;
  }
  get innerSizeElement() {
    return this.transverseCollapse ? this.panel.element : this.innerElement;
  }
  get supportAxis() {
    let {
      _supportAxis
    } = this;
    const fullSupport = _supportAxis === true;
    if (fullSupport || _supportAxis == null) {
      _supportAxis = this.collapseDim[0];
      if (fullSupport || DomHelper.getStyleValue(this.panel.element, "position") === "absolute") {
        _supportAxis += crossAxis[_supportAxis];
      }
    }
    return _supportAxis || "";
  }
  lockInnerSize(lock = true) {
    const me = this, {
      innerElement,
      panel
    } = me, supportAxis = lock ? me.supportAxis : "", panelEl = panel.element, headerEl = panel.headerElement, headerRect = lock && headerEl && Rectangle.from(headerEl, panelEl), innerRect = lock && Rectangle.from(me.innerSizeElement, panelEl), innerStyle = innerElement.style;
    if (headerEl) {
      headerEl.style.minWidth = supportAxis.includes("w") ? `${headerRect.width}px` : "";
      headerEl.style.minHeight = supportAxis.includes("h") ? `${headerRect.height}px` : "";
    }
    innerStyle.width = lock ? `${innerRect.width}px` : "";
    innerStyle.height = lock ? `${innerRect.height}px` : "";
    innerElement.classList[lock ? "add" : "remove"]("b-panel-collapse-size-locker");
    return innerRect;
  }
  onCollapseClick(e) {
    let collapsed = this.collapsing ? false : this.expanding ? true : !this.collapsed;
    if (e.altKey) {
      collapsed = {
        animation: null,
        collapsed
      };
    }
    this.collapse(collapsed);
  }
  onComplete(action) {
    var _this$panel3;
    (_this$panel3 = this.panel) === null || _this$panel3 === void 0 ? void 0 : _this$panel3.trigger(action);
  }
  onHeaderClick({
    event
  }) {
    if (event.button === 0 && this.panel.collapsed && event.target.classList.contains(revealerCls)) {
      this.onRevealerClick();
    }
  }
  onPanelConfigChange({
    name,
    value
  }) {
    const me = this, {
      panel
    } = me;
    if (name === "collapsed") {
      if (panel.isPainted) {
        me.collapsed = value;
      }
    } else if (name === "header" && !panel.changingCollapse) {
      me.syncDirection();
    }
  }
  onPanelPaint() {
    this.syncDirection();
    if (this.panel.collapsed && !this.collapsed) {
      this.collapse({
        animation: null,
        collapsed: true
      });
    }
  }
  onRevealerClick() {
    this.panel._collapse({
      collapsed: false
    });
  }
  restoreConfiguredSize(which) {
    var _which;
    const {
      configuredHeight,
      configuredWidth,
      panel
    } = this;
    which = (_which = which) !== null && _which !== void 0 ? _which : "wh";
    panel.element.classList.remove(unflexCls);
    if (configuredWidth != null && which.includes("w")) {
      panel.width = configuredWidth;
    }
    if (configuredHeight != null && which.includes("h")) {
      panel.height = configuredHeight;
    }
  }
  splitHeaderItems() {
    return emptySplit$1;
  }
  syncDirection() {
    const me = this, {
      direction
    } = me;
    if (!direction || defaultedDirectionRe.test(direction)) {
      me.direction = me.getCollapseDir();
    }
  }
  updateCollapsed(collapsed) {
    const {
      collapseTool,
      panel
    } = this;
    if (panel) {
      panel.collapsed = collapsed;
      panel.element.classList[collapsed ? "add" : "remove"]("b-collapsed");
    }
    if (collapseTool) {
      collapseTool.collapsed = collapsed;
    }
  }
  updateDirection(direction) {
    const {
      collapseTool,
      panel
    } = this;
    if (collapseTool) {
      collapseTool.direction = canonicalDirection[direction];
    }
    if (panel !== null && panel !== void 0 && panel.rendered) {
      panel.recompose();
    }
  }
  updatePanel(panel) {
    var _me$panelChangeDetach;
    const me = this;
    me.syncDirection();
    (_me$panelChangeDetach = me.panelChangeDetacher) === null || _me$panelChangeDetach === void 0 ? void 0 : _me$panelChangeDetach.call(me);
    me.panelChangeDetacher = panel && FunctionHelper.after(panel, "onConfigChange", "onPanelConfigChange", me, {
      return: false
    });
  }
  wrapCollapser(key, body) {
    var _panel$tools;
    const me = this, [collapseDock, transverse] = me.collapseInfo;
    if (!transverse) {
      return [key, body];
    }
    const {
      collapseDir,
      panel
    } = me, {
      expandedHeaderDock,
      header: panelHeader,
      uiClassList
    } = panel, recollapse = (_panel$tools = panel.tools) === null || _panel$tools === void 0 ? void 0 : _panel$tools.recollapse, [before, after] = me.splitHeaderItems({
      dock: collapseDock,
      as: "element"
    }), title = panel.hasHeader ? panel.title || (panelHeader === null || panelHeader === void 0 ? void 0 : panelHeader.title) || "\xA0" : null, headerElement = title && {
      tag: "header",
      class: new DomClassList(_objectSpread2(_objectSpread2({}, uiClassList), {}, {
        [`b-dock-${expandedHeaderDock}`]: 1,
        "b-panel-header": 1,
        "b-panel-collapser-header": 1
      }), panelHeader === null || panelHeader === void 0 ? void 0 : panelHeader.cls),
      children: [...before, {
        reference: "collapserTitleElement",
        html: title,
        class: _objectSpread2(_objectSpread2({}, uiClassList), {}, {
          [`b-align-${(panelHeader === null || panelHeader === void 0 ? void 0 : panelHeader.titleAlign) || "start"}`]: 1,
          "b-header-title": 1
        })
      }, ...after]
    };
    if (recollapse) {
      recollapse.direction = collapseDir;
    }
    return ["collapseWrapElement", {
      class: _objectSpread2(_objectSpread2({}, uiClassList), {}, {
        [`b-panel-collapser-header-${expandedHeaderDock}`]: 1,
        [`b-panel-collapser-${collapseDir}`]: 1,
        [`b-${dockIsHorz$1[expandedHeaderDock] ? "h" : "v"}box`]: 1,
        "b-panel-collapser": 1,
        "b-box-center": 1
      }),
      children: dockBeforeRe.test(expandedHeaderDock) ? {
        collapserHeaderElement: headerElement,
        [key]: body
      } : {
        [key]: body,
        collapserHeaderElement: headerElement
      }
    }];
  }
};
PanelCollapser.maps = {
  clipByDock,
  dockByDirection,
  dockIsHorz: dockIsHorz$1
};
PanelCollapser.initClass();
PanelCollapser._$name = "PanelCollapser";
var PENDING = Symbol("pendingCreate");
var DynamicObject = class extends Base$1 {
  static get prototypeProperties() {
    return {
      cleanup: null,
      configName: null,
      created: null,
      factory: null,
      inferType: "name",
      owner: null,
      ownerName: null,
      proxyable: typeof Proxy !== "undefined",
      setup: null,
      transform: null
    };
  }
  static get properties() {
    return {
      defaults: {},
      instances: {},
      object: /* @__PURE__ */ Object.create({})
    };
  }
  get proxy() {
    const me = this;
    let proxy = null;
    if (me.proxyable) {
      proxy = new Proxy(me.instances, {
        get(o, name) {
          return me.get(name);
        },
        set(o, name, value) {
          me.set(name, value);
          return true;
        },
        deleteProperty(o, name) {
          me.set(name, null);
          return true;
        }
      });
    }
    Reflect.defineProperty(me, "proxy", {
      configurable: true,
      value: proxy
    });
    return proxy;
  }
  get target() {
    return this.proxy || this.object;
  }
  define(name, config) {
    const me = this, {
      transform
    } = me, transformed = transform ? transform(config, name) : config, instantiated = ObjectHelper.isInstantiated(transformed);
    me.instances[name] = PENDING;
    if (!instantiated) {
      me.setDefaults(name, transformed);
    }
    me.defineProp(name, true);
    if (instantiated) {
      me.set(name, transformed);
    }
  }
  defineProp(name, base) {
    const me = this, {
      object
    } = me;
    if (!me.proxy) {
      Reflect.defineProperty(base ? Object.getPrototypeOf(object) : object, name, {
        configurable: !base,
        enumerable: true,
        get() {
          return me.get(name);
        },
        set(value) {
          return me.set(name, value);
        }
      });
    }
  }
  flush() {
    const me = this;
    try {
      var _me$afterConfigureOwn;
      me.updating = true;
      for (const name in me.defaults) {
        me.get(name);
      }
      me.afterConfigureOwner = (_me$afterConfigureOwn = me.afterConfigureOwner) === null || _me$afterConfigureOwn === void 0 ? void 0 : _me$afterConfigureOwn.call(me);
    } finally {
      me.updating = false;
    }
  }
  get(name) {
    const {
      defaults,
      instances
    } = this;
    if (instances[name] === PENDING) {
      this.set(name, PENDING);
    }
    return instances[name] || defaults[name] && null;
  }
  set(name, value) {
    const me = this, {
      cleanup,
      configName,
      defaults,
      factory,
      instances,
      owner,
      setup,
      transform,
      updating
    } = me, inform = owner && configName && !updating, was = instances[name] === PENDING ? null : instances[name], instance = factory.reconfigure(was, value === PENDING ? {} : value || null, {
      cleanup: cleanup && ((instance2) => cleanup(instance2, name)),
      defaults: defaults[name] || me.setDefaults(name, {}),
      owner: me.owner,
      setup: setup && ((config, type, defaults2) => setup(config, name, type, defaults2)),
      transform: transform && ((config) => transform(config, name))
    });
    if (instance !== was) {
      const before = inform && _objectSpread2({}, instances);
      instances[name] = instance;
      if (instance) {
        var _me$created;
        me.defineProp(name);
        (_me$created = me.created) === null || _me$created === void 0 ? void 0 : _me$created.call(me, instance, name);
      } else {
        delete me.object[name];
        delete instances[name];
      }
      if (inform) {
        owner.onConfigChange({
          name: configName,
          config: owner.$meta.configs[configName],
          value: me.target,
          was: before
        });
      }
    }
  }
  setDefaults(name, config) {
    const {
      defaults,
      factory,
      inferType,
      instances,
      owner,
      ownerName
    } = this, {
      typeKey
    } = factory.factoryable;
    config = config === true ? {} : ObjectHelper.assign({}, config);
    if (inferType === "name" || inferType === true && !config[typeKey]) {
      config[typeKey] = name;
    }
    if (ownerName) {
      config[ownerName] = owner;
    }
    config.beforeConfigure = (instance) => {
      instances[name] = instance;
    };
    return defaults[name] = config;
  }
  update(members) {
    const me = this, {
      owner
    } = me;
    let name, config;
    try {
      me.updating = true;
      if (members) {
        for (name in members) {
          config = members[name];
          if (me.defaults[name]) {
            me.set(name, config);
          } else if (config) {
            me.define(name, config);
          }
        }
      } else {
        for (name in me.instances) {
          me.set(name, null);
        }
      }
    } finally {
      me.updating = false;
    }
    if (owner) {
      if (!owner.isConfiguring) {
        me.flush();
      } else if (!me.afterConfigureOwner) {
        me.afterConfigureOwner = FunctionHelper.before(owner, "afterConfigure", "flush", me);
      }
    }
  }
};
DynamicObject.initClass();
DynamicObject._$name = "DynamicObject";
var emptyArray$7 = [];
var emptyObject$8 = {};
var toolConfigs = {
  align: 1,
  weight: 1
};
var Toolable = (Target) => class Toolable extends (Target || Widget) {
  static get $name() {
    return "Toolable";
  }
  static get configurable() {
    return {
      tools: {
        value: null,
        $config: {
          nullify: true
        }
      },
      toolDefaults: {
        "*": {
          type: "tool",
          align: "end"
        }
      }
    };
  }
  byWeightSortFn(a, b) {
    return (a.weight || 0) - (b.weight || 0);
  }
  byWeightReverseSortFn(a, b) {
    return (b.weight || 0) - (a.weight || 0);
  }
  gatherTools({
    align,
    overlay,
    refs
  } = emptyObject$8) {
    const {
      collapsed,
      tools
    } = this;
    let ret = [], alignment, key, i, item, tool;
    for (key in tools) {
      var _ref, _tool$align$align, _tool, _tool$align, _tool2;
      tool = tools[key];
      alignment = (_ref = (_tool$align$align = (_tool = tool) === null || _tool === void 0 ? void 0 : (_tool$align = _tool.align) === null || _tool$align === void 0 ? void 0 : _tool$align.align) !== null && _tool$align$align !== void 0 ? _tool$align$align : (_tool2 = tool) === null || _tool2 === void 0 ? void 0 : _tool2.align) !== null && _ref !== void 0 ? _ref : "end";
      if (alignment === align && tool.isCollapsified(collapsed, overlay)) {
        ret.push(tool);
      }
    }
    ret.sort(this[align === "end" ? "byWeightReverseSortFn" : "byWeightSortFn"]);
    if (refs) {
      const asWidget = refs === "widget", asRefs = {};
      for (i = 0; i < ret.length; ++i) {
        item = ret[i];
        asRefs[item.ref] = asWidget ? item : item.element;
      }
      ret = asRefs;
    }
    return ret;
  }
  getEndTools({
    overlay,
    refs
  } = emptyObject$8) {
    return this.gatherTools({
      align: "end",
      overlay,
      refs
    });
  }
  getStartTools({
    overlay,
    refs
  } = emptyObject$8) {
    return this.gatherTools({
      align: "start",
      overlay,
      refs
    });
  }
  get childItems() {
    return [...this.getStartTools(), ...this._items || emptyArray$7, ...this.getEndTools()];
  }
  changeTools(tools, oldTools) {
    const me = this, manager = me.$tools || (me.$tools = new DynamicObject({
      configName: "tools",
      factory: Widget,
      inferType: false,
      owner: me,
      created(instance) {
        var _instance$syncRotatio, _me$header;
        instance.innerItem = false;
        (_instance$syncRotatio = instance.syncRotationToDock) === null || _instance$syncRotatio === void 0 ? void 0 : _instance$syncRotatio.call(instance, (_me$header = me.header) === null || _me$header === void 0 ? void 0 : _me$header.dock);
        FunctionHelper.after(instance, "onConfigChange", (ret, {
          name
        }) => {
          if (toolConfigs[name]) {
            me.onConfigChange({
              name: "tools",
              value: manager.target
            });
          }
        });
        me.onChildAdd(instance);
      },
      setup(config, name) {
        config = ObjectHelper.merge({}, me.toolDefaults["*"], me.toolDefaults[name], config);
        config.parent = me;
        config.ref = name;
        return config;
      }
    }));
    manager.update(tools);
    if (!oldTools) {
      return manager.target;
    }
  }
  get widgetClass() {
  }
};
var directionCls = ["b-hbox", "b-vbox"];
var syncAlign = {
  name: "align",
  style: "alignItems"
};
var syncContentAlign = {
  name: "contentAlign",
  style: "alignContent"
};
var syncDirection = {
  name: "direction",
  style: "flexDirection"
};
var syncJustify = {
  name: "justify",
  style: "justifyContent",
  classes: ["stretch"]
};
var syncWrap = {
  name: "wrap",
  style: "flexWrap",
  map: {
    false: "nowrap",
    true: "wrap",
    reverse: "wrap-reverse"
  }
};
var Box = class extends Layout {
  get vertical() {
    return this.horizontal === false;
  }
  set vertical(v) {
    return this.horizontal = !v;
  }
  updateAlign() {
    this.syncConfigStyle(syncAlign);
  }
  updateContentAlign() {
    this.syncConfigStyle(syncContentAlign);
  }
  updateDirection() {
    this.syncConfigStyle(syncDirection);
  }
  updateHorizontal() {
    var _me$contentElement;
    const me = this, classList = (_me$contentElement = me.contentElement) === null || _me$contentElement === void 0 ? void 0 : _me$contentElement.classList, vertical = Number(me.vertical);
    if (classList) {
      classList.remove(directionCls[1 - vertical]);
      classList.add(directionCls[vertical]);
    } else {
      me.syncConfigLater("horizontal");
    }
    me.syncDirection();
  }
  updateJustify() {
    this.syncConfigStyle(syncJustify);
  }
  updateReverse() {
    this.syncDirection();
  }
  updateWrap() {
    this.syncConfigStyle(syncWrap);
  }
  syncDirection() {
    const me = this, {
      reverse
    } = me;
    me.direction = reverse ? `${me.vertical ? "column" : "row"}${reverse ? "-reverse" : ""}` : null;
  }
};
_defineProperty(Box, "$name", "Box");
_defineProperty(Box, "type", "box");
_defineProperty(Box, "alias", "hbox");
_defineProperty(Box, "configurable", {
  itemCls: "b-box-item",
  align: null,
  contentAlign: null,
  direction: null,
  horizontal: true,
  justify: null,
  reverse: null,
  wrap: null
});
Box.initClass();
Box._$name = "Box";
var VBox = class extends Box {
};
_defineProperty(VBox, "$name", "VBox");
_defineProperty(VBox, "type", "vbox");
_defineProperty(VBox, "configurable", {
  horizontal: false
});
VBox.initClass();
VBox._$name = "VBox";
var Badge = (Target) => class Badge extends (Target || Base$1) {
  static get $name() {
    return "Badge";
  }
  static get configurable() {
    return {
      badge: null
    };
  }
  compose() {
    const {
      badge
    } = this;
    return {
      dataset: {
        badge
      },
      class: {
        "b-badge": badge != null && badge !== ""
      }
    };
  }
};
var bIcon$1 = /(?:^|\s)b-icon-/;
var bFa$1 = /(?:^|\s)b-fa-/;
var defaultToggleable = Symbol("defaultToggleable");
var fullConfigKeys = ["items", "type", "widgets", "html", "listeners"];
var menuListenersName = Symbol("defaultListener");
var Button = class extends Widget.mixin(Badge, Rotatable) {
  static get $name() {
    return "Button";
  }
  static get type() {
    return "button";
  }
  static get configurable() {
    return {
      icon: null,
      menuIcon: "b-icon-picker",
      pressedIcon: null,
      iconAlign: "start",
      text: {
        value: null,
        $config: null,
        default: ""
      },
      color: null,
      toggleable: defaultToggleable,
      pressed: false,
      toggleGroup: null,
      ripple: {
        radius: 75
      },
      forwardTwinEvents: ["action", "toggle"],
      localizableProperties: ["text"],
      menu: {
        $config: ["lazy", "nullify"],
        value: null
      },
      menuDefaults: {
        type: "menu",
        autoShow: false,
        autoClose: true,
        floating: true,
        scrollAction: "realign",
        align: "t0-b0"
      },
      href: null,
      target: null,
      defaultBindProperty: null
    };
  }
  updateElement(element, oldElement) {
    var _constructor$resolveT, _constructor$resolveT2, _constructor$configur;
    const me = this, {
      constructor
    } = me, result = super.updateElement(element, oldElement), menu = me.peekConfig("menu"), role = menu ? menu.isWidget ? menu.role : ((_constructor$resolveT = constructor.resolveType(menu.type)) === null || _constructor$resolveT === void 0 ? void 0 : (_constructor$resolveT2 = _constructor$resolveT.configurable) === null || _constructor$resolveT2 === void 0 ? void 0 : _constructor$resolveT2.role) || ((_constructor$configur = constructor.configurable.menuDefaults) === null || _constructor$configur === void 0 ? void 0 : _constructor$configur.type) || "menu" : false;
    me.ariaHasPopup = role;
    return result;
  }
  compose() {
    const {
      color,
      href,
      icon,
      iconAlign,
      pressed,
      pressedIcon,
      target,
      text,
      toggleable,
      toggleGroup,
      menuIcon
    } = this, hasMenu = this.hasConfig("menu"), iconCls = pressed && pressedIcon ? pressedIcon : icon;
    return {
      tag: href ? "a" : "button",
      href,
      target,
      class: {
        [`b-icon-align-${iconAlign}`]: icon,
        [color]: Boolean(color),
        "b-pressed": pressed && toggleable,
        "b-text": Boolean(text),
        "b-has-menu": hasMenu
      },
      "aria-pressed": pressed,
      dataset: {
        group: toggleGroup
      },
      listeners: {
        click: "onInternalClick",
        mousedown: "onInternalMousedown"
      },
      children: {
        iconElement: (icon || pressedIcon) && {
          "aria-hidden": true,
          tag: "i",
          class: _objectSpread2(_objectSpread2({}, DomClassList.normalize(iconCls, "object")), {}, {
            "b-icon": bIcon$1.test(iconCls),
            "b-fa": bFa$1.test(iconCls)
          })
        },
        label: text && {
          tag: "label",
          text
        },
        menuIconElement: hasMenu && menuIcon && {
          tag: "i",
          class: {
            "b-icon": bIcon$1.test(menuIcon),
            "b-fa": bFa$1.test(menuIcon),
            "b-button-menu-icon": 1,
            [menuIcon]: 1
          }
        }
      }
    };
  }
  configureOverflowTwin(overrides) {
    const me = this, config = super.configureOverflowTwin(overrides);
    if (!config.text) {
      config.text = me.tooltipText;
    }
    return config;
  }
  onHide() {
    var _this$_menu;
    (_this$_menu = this._menu) === null || _this$_menu === void 0 ? void 0 : _this$_menu.hide();
  }
  get childItems() {
    return this._menu && [this.menu];
  }
  onFocusOut(e) {
    var _this$menu;
    super.onFocusOut(e);
    (_this$menu = this.menu) === null || _this$menu === void 0 ? void 0 : _this$menu.hide();
  }
  get focusElement() {
    return this.element;
  }
  changeText(text) {
    return text == null ? "" : text;
  }
  changeToggleable(toggleable) {
    if (toggleable === defaultToggleable) {
      return this.toggleGroup || this.config.menu;
    }
    return toggleable;
  }
  changeMenu(menu, oldMenu) {
    const me = this, {
      element: forElement
    } = me;
    if (menu) {
      if (menu.isWidget) {
        menu.forElement = forElement;
        menu.owner = me;
        menu.constrainTo = me.rootElement;
      } else {
        if (typeof menu === "object" && !fullConfigKeys.some((key) => key in menu)) {
          menu = {
            lazyItems: menu
          };
        }
        menu = Widget.reconfigure(oldMenu, menu ? ObjectHelper.merge({
          owner: me,
          constrainTo: me.rootElement,
          forElement
        }, me.menuDefaults, menu) : null, me);
      }
      menu.align.constrainPadding = 10;
      me.detachListeners(menuListenersName);
      menu.ion({
        name: menuListenersName,
        beforeShow: "onMenuBeforeShow",
        hide: "onMenuHide",
        show: "onMenuShow",
        thisObj: this
      });
    } else {
      oldMenu === null || oldMenu === void 0 ? void 0 : oldMenu.destroy();
    }
    return menu;
  }
  onMenuBeforeShow({
    source
  }) {
    return this.trigger("beforeShowMenu", {
      menu: source
    });
  }
  onMenuShow() {
    this.ariaElement.setAttribute("aria-expanded", true);
  }
  onMenuHide() {
    this.ariaElement.setAttribute("aria-expanded", false);
    this.toggle(false);
  }
  updateMenu(menu) {
    this.toggleable = Boolean(menu);
  }
  updatePressed(pressed) {
    const me = this;
    if (!me.toggleable || me.isConfiguring) {
      return;
    }
    const {
      menu
    } = me;
    if (pressed) {
      DomHelper.forEachSelector(me.rootElement, `button[data-group=${me.toggleGroup}]`, (btnEl) => {
        if (btnEl !== me.element) {
          Widget.getById(btnEl.id).pressed = false;
        }
      });
    }
    if (menu) {
      var _menu$_minHeight, _menu$_minWidth;
      if (!menu.initialConfig.minWidth) {
        menu.minWidth = me.width;
      }
      menu.align.minHeight = (_menu$_minHeight = menu._minHeight) !== null && _menu$_minHeight !== void 0 ? _menu$_minHeight : 100;
      menu.align.minWidth = (_menu$_minWidth = menu._minWidth) !== null && _menu$_minWidth !== void 0 ? _menu$_minWidth : 100;
      menu[pressed ? "show" : "hide"]();
    }
    me.trigger("toggle", {
      pressed
    });
  }
  onInternalMousedown(event) {
    var _this$_menu2;
    if ((_this$_menu2 = this._menu) !== null && _this$_menu2 !== void 0 && _this$_menu2.containsFocus && this.pressed) {
      event.preventDefault();
    }
  }
  onInternalClick(event) {
    const me = this, bryntumEvent = {
      event
    };
    if (me.disabled) {
      return;
    }
    if (me.toggleable) {
      if (me.toggleGroup && me.pressed) {
        return;
      }
      me.toggle(!me.pressed);
      if (me.isDestroyed) {
        return;
      }
    }
    me.trigger("click", bryntumEvent);
    if (!me.isDestroyed) {
      me.trigger("action", bryntumEvent);
    }
    if (!me.href) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  toggle(pressed = !this.pressed) {
    if (this.trigger("beforeToggle", {
      pressed
    }) !== false) {
      this.pressed = pressed;
    }
  }
};
Button.initClass();
Button._$name = "Button";
var asElementRefs = {
  refs: "element"
};
var onCreateTwin = (overflowTwin) => overflowTwin.element.style.margin = "";
var isToolbar = (w) => w.isToolbar;
var itemScoreFn = (ent) => ent[0] + (ent[1].minifiable ? 0 : 9e9);
var twinOverrides = {
  hidden: false,
  width: ""
};
var twinOverridesHorz = _objectSpread2(_objectSpread2({}, twinOverrides), {}, {
  flex: ""
});
var _axisProps = [{
  box: "hbox",
  clientSizeProp: "clientWidth",
  edgeProp: "right",
  flexDir: "row",
  horizontal: true,
  max: "maxX",
  overflow: "overflowX",
  pos: "x",
  scrollSize: "scrollWidth",
  sizeProp: "width"
}, {
  box: "vbox",
  clientSizeProp: "clientHeight",
  edgeProp: "bottom",
  flexDir: "column",
  horizontal: false,
  max: "maxY",
  overflow: "overflowY",
  pos: "y",
  scrollSize: "scrollHeight",
  sizeProp: "height"
}];
var defaultRepeat = {
  delay: 0,
  startRate: 40,
  endRate: 200,
  accelerateDuration: 500
};
var nonSyncedConfigs = {
  menu: 1,
  pressed: 1
};
var Toolbar = class extends Container.mixin(Toolable) {
  static get $name() {
    return "Toolbar";
  }
  static get type() {
    return "toolbar";
  }
  static get delayable() {
    return {
      syncOverflowVisibility: {
        type: "raf",
        cancelOutstanding: true
      }
    };
  }
  static get configurable() {
    return {
      defaultType: "button",
      dock: "top",
      layout: {
        type: "box"
      },
      overflow: {
        $config: ["lazy", "nullify"],
        value: {
          type: "menu"
        }
      },
      toolDefaults: {
        overflowMenuButton: {
          type: "button",
          hidden: true,
          icon: "b-icon-menu",
          menuIcon: null,
          defaultCls: {
            "b-overflow-button": 1
          }
        },
        overflowScrollEnd: {
          handler: "up.onEndScrollClick",
          hidden: true,
          defaultCls: {
            "b-icon-angle-right": 1,
            "b-overflow-button": 1,
            "b-icon": 1
          }
        },
        overflowScrollStart: {
          align: "start",
          handler: "up.onStartScrollClick",
          hidden: true,
          defaultCls: {
            "b-icon-angle-left": 1,
            "b-overflow-button": 1,
            "b-icon": 1
          }
        }
      },
      widgetCls: null,
      ignoreParentReadOnly: true
    };
  }
  static get prototypeProperties() {
    return {
      flexRowCls: "b-hbox",
      flexColCls: "b-vbox"
    };
  }
  static getEvictionList(visibleItems) {
    const ret = visibleItems.filter((it) => it.overflowable !== "none");
    ret.forEach((it, n) => ret[n] = [n, it]);
    ret.sort((a, b) => itemScoreFn(b) - itemScoreFn(a));
    return ret;
  }
  compose() {
    const me = this, {
      axisProps,
      dock
    } = me, endToolElementRefs = me.getEndTools(asElementRefs), startToolElementRefs = me.getStartTools(asElementRefs);
    return {
      class: {
        [`b-dock-${dock}`]: 1,
        [`b-${dock}-toolbar`]: 1,
        [`b-${axisProps.box}`]: 1
      },
      children: _objectSpread2(_objectSpread2({}, startToolElementRefs), {}, {
        toolbarContent: {
          class: {
            "b-box-center": 1,
            "b-toolbar-content": 1
          }
        }
      }, endToolElementRefs)
    };
  }
  get axisProps() {
    return _axisProps[this.layout.horizontal ? 0 : 1];
  }
  get contentElement() {
    return this.toolbarContent;
  }
  get overflowMenuButton() {
    var _this$tools;
    return (_this$tools = this.tools) === null || _this$tools === void 0 ? void 0 : _this$tools.overflowMenuButton;
  }
  get overflowType() {
    const {
      overflow
    } = this;
    return typeof overflow === "string" ? overflow : overflow === null || overflow === void 0 ? void 0 : overflow.type;
  }
  onChildAdd(item) {
    var _item$syncRotationToD;
    super.onChildAdd(item);
    this.processAddedLeafItem(item);
    (_item$syncRotationToD = item.syncRotationToDock) === null || _item$syncRotationToD === void 0 ? void 0 : _item$syncRotationToD.call(item, this.dock);
  }
  onChildRemove(item) {
    super.onChildRemove(item);
    this.syncOverflowVisibility();
  }
  processAddedLeafItem(item) {
    FunctionHelper.after(item, "onConfigChange", this.onLeafItemConfigChange, item);
    if (item.isContainer) {
      item.eachWidget((w) => this.processAddedLeafItem(w));
    }
  }
  onPaint({
    firstPaint
  }) {
    var _super$onPaint;
    (_super$onPaint = super.onPaint) === null || _super$onPaint === void 0 ? void 0 : _super$onPaint.call(this, ...arguments);
    if (firstPaint) {
      this.getConfig("overflow");
    }
  }
  updateDock(dock) {
    const me = this, {
      layout
    } = me, {
      vertical
    } = layout;
    layout.vertical = canonicalDock(dock)[1];
    if (!me.initialItems) {
      if (vertical !== layout.vertical) {
        me.updateOverflow(me.overflow);
      }
      for (const item of me.childItems) {
        var _item$syncRotationToD2;
        (_item$syncRotationToD2 = item.syncRotationToDock) === null || _item$syncRotationToD2 === void 0 ? void 0 : _item$syncRotationToD2.call(item, dock);
      }
    }
  }
  updateOverflow(overflow, oldOverflow) {
    var _me$overflowMenuButto;
    const me = this, {
      axisProps,
      contentElement,
      overflowType
    } = me, {
      flexDir
    } = axisProps, overflowMenu = (_me$overflowMenuButto = me.overflowMenuButton) === null || _me$overflowMenuButto === void 0 ? void 0 : _me$overflowMenuButto._menu, overflowTools = {};
    if (overflowMenu) {
      if (overflow) {
        overflowMenu === null || overflowMenu === void 0 ? void 0 : overflowMenu.removeAll();
      } else {
        overflowMenu.eachWidget((overflowTwin) => {
          overflowTwin._overflowTwinOrigin.overflowTwin = null;
        });
      }
    }
    if (oldOverflow === "menu") {
      overflowTools.overflowMenuButton = null;
    } else if (oldOverflow === "scroll") {
      overflowTools.overflowScrollStart = overflowTools.overflowScrollEnd = null;
    }
    if (overflowType === "menu") {
      var _me$scrollable;
      (_me$scrollable = me.scrollable) === null || _me$scrollable === void 0 ? void 0 : _me$scrollable.destroy();
      contentElement.style.overflow = contentElement.style.overflowX = contentElement.style.overflowY = "";
      overflowTools.overflowMenuButton = {
        cls: {
          [`b-${flexDir}-menu`]: 1
        }
      };
    } else if (overflowType === "scroll") {
      const repeat = typeof overflow === "object" && (overflow === null || overflow === void 0 ? void 0 : overflow.repeat) || defaultRepeat;
      me.scrollable = {
        [axisProps.overflow]: "hidden-scroll",
        element: contentElement,
        internalListeners: {
          scroll: "onContentScroll",
          thisObj: me
        }
      };
      overflowTools.overflowScrollStart = {
        repeat,
        invertRotate: true,
        cls: {
          [`b-${flexDir}-start-scroller`]: 1
        }
      };
      overflowTools.overflowScrollEnd = {
        repeat,
        invertRotate: true,
        cls: {
          [`b-${flexDir}-end-scroller`]: 1
        }
      };
    }
    me.tools = overflowTools;
    if (overflowType) {
      contentElement.classList.add("b-overflow");
      me.monitorResize = true;
      me.syncOverflowVisibility();
    } else {
      contentElement.classList.remove("b-overflow");
      me.monitorResize = false;
    }
  }
  onContentScroll() {
    this.syncScrollerState();
  }
  onStartScrollClick() {
    this.scrollable[this.axisProps.pos] -= 2;
  }
  onEndScrollClick() {
    this.scrollable[this.axisProps.pos] += 2;
  }
  onInternalResize() {
    super.onInternalResize(...arguments);
    if (this.isPainted) {
      this.syncOverflowVisibility();
    }
  }
  syncOverflowVisibility() {
    const me = this, {
      overflowType,
      contentElement,
      isVisible: isVisible2
    } = me, {
      clientSizeProp,
      edgeProp,
      sizeProp
    } = me.axisProps, {
      overflowMenuButton,
      overflowScrollStart,
      overflowScrollEnd
    } = me.tools, rtl = me.rtl && me.layout.horizontal, menuOverflow = overflowType === "menu", getAvailSpace = () => Math.ceil(contentElement[clientSizeProp] + (!overflowScrollStart || overflowScrollStart.hidden ? 0 : overflowScrollStart.rectangle("outer")[sizeProp]) + (!overflowScrollEnd || overflowScrollEnd.hidden ? 0 : overflowScrollEnd.rectangle("outer")[sizeProp])), getContentSize = () => {
      if (visibleItems.length === 0) {
        return 0;
      }
      const rect = visibleItems[visibleItems.length - 1].rectangle(contentElement);
      return Math.floor(rtl ? contentElement[clientSizeProp] - rect.left : rect[edgeProp]);
    };
    let availableSpace, contentSize, eviction, evictionList, it, itemSize, minifiable, minifiables, minified, overflowable, overflowItems, visibleItems;
    if (!isVisible2 || !overflowType || me.items.length === 0) {
      return;
    }
    me.inSyncOverflowVisibility = true;
    overflowMenuButton === null || overflowMenuButton === void 0 ? void 0 : overflowMenuButton.hide();
    me.eachWidget((item, control) => {
      minifiable = item.minifiable;
      overflowable = item.overflowable;
      overflowable = minifiable ? overflowable || minifiable : overflowable;
      if (item.floating) {
        control.down = false;
      } else {
        control.down = !overflowable;
        if (item.innerItem) {
          if (item._toolbarOverflow) {
            item.hidden = item._toolbarOverflow = false;
          }
          if (item._toolbarMinified) {
            item.minified = item._toolbarMinified = false;
          }
          if (item.isVisible) {
            minifiable && (minifiables || (minifiables = [])).push(item);
            overflowable && (visibleItems || (visibleItems = [])).push(item);
          }
        }
      }
    });
    if (visibleItems) {
      availableSpace = getAvailSpace();
      contentSize = getContentSize();
    }
    if (visibleItems && contentSize > availableSpace) {
      if (menuOverflow) {
        while (contentSize > availableSpace && (it = (_minifiables = minifiables) === null || _minifiables === void 0 ? void 0 : _minifiables.pop())) {
          var _minifiables;
          itemSize = contentSize;
          it._toolbarMinified = true;
          it.minified = true;
          contentSize = getContentSize();
          itemSize -= contentSize;
          (minified || (minified = [])).push([it, itemSize]);
        }
        if (contentSize > availableSpace) {
          overflowMenuButton.show();
          availableSpace = getAvailSpace();
          evictionList = Toolbar.getEvictionList(visibleItems);
          for (eviction of evictionList) {
            if (contentSize > availableSpace) {
              it = eviction[1];
              it._toolbarOverflowWidth = it.width;
              it._toolbarOverflow = true;
              it.hidden = true;
              visibleItems.splice(visibleItems.indexOf(it), 1);
              (overflowItems || (overflowItems = [])).push(eviction);
              contentSize = getContentSize();
            }
          }
          if (overflowItems) {
            overflowItems.sort((a, b) => a[0] - b[0]).forEach((ent, n) => overflowItems[n] = ent[1]);
            while ((_minified = minified) !== null && _minified !== void 0 && _minified.length) {
              var _minified;
              [it, itemSize] = minified.pop();
              if (contentSize + itemSize <= availableSpace && !it._toolbarOverflow) {
                contentSize += itemSize;
                it.minified = it._toolbarMinified = false;
              }
            }
            me.syncOverflowMenuButton(overflowItems);
          } else {
            overflowMenuButton.hide();
          }
        }
      } else {
        overflowScrollEnd.show();
        overflowScrollStart.show();
        me.syncScrollerState();
      }
    } else if (!menuOverflow) {
      overflowScrollEnd === null || overflowScrollEnd === void 0 ? void 0 : overflowScrollEnd.hide();
      overflowScrollStart === null || overflowScrollStart === void 0 ? void 0 : overflowScrollStart.hide();
    }
    me.inSyncOverflowVisibility = false;
  }
  syncOverflowMenuButton(overflowItems) {
    var _overflowMenuButton$_;
    const me = this, {
      axisProps,
      overflowMenuButton
    } = me, menu = {
      cls: "b-toolbar-overflow-menu",
      minWidth: 280,
      items: [],
      align: {
        align: axisProps.horizontal ? "t100-b100" : "r100-l100",
        axisLock: "flexible"
      }
    };
    me.addToMenu(menu, overflowItems.filter((item) => me.overflowItemFilter(item)));
    if ((_overflowMenuButton$_ = overflowMenuButton._menu) !== null && _overflowMenuButton$_ !== void 0 && _overflowMenuButton$_.isMenu) {
      const existingMenu = overflowMenuButton.menu, {
        toAdd,
        toRemove
      } = ArrayHelper.delta(menu.items, existingMenu.items, 1);
      existingMenu.remove(toRemove);
      if (existingMenu.items.length) {
        for (let i = toAdd.length - 1; i >= 0; i--) {
          existingMenu.insert(toAdd[i], 0);
        }
      } else {
        existingMenu.add(toAdd);
      }
    } else {
      overflowMenuButton.menu = menu;
    }
  }
  syncScrollerState() {
    const me = this, {
      axisProps,
      scrollable
    } = me, {
      overflowScrollStart,
      overflowScrollEnd
    } = me.tools, scrollPos = scrollable[axisProps.pos], maxScrollPos = scrollable[axisProps.max];
    overflowScrollStart.disabled = !scrollPos;
    overflowScrollEnd.disabled = Math.abs(Math.ceil(scrollPos)) >= Math.abs(maxScrollPos);
  }
  overflowItemFilter(item) {
    const {
      filter: filter2
    } = this.overflow;
    return Boolean(filter2 ? filter2.call(this, item) : DomHelper.getChildElementCount(item.element));
  }
  addToMenu(menu, overflowingItems) {
    const overrides = this.horizontal ? twinOverridesHorz : twinOverrides;
    for (const item of overflowingItems) {
      const overflowTwin = item.ensureOverflowTwin(overrides, onCreateTwin);
      menu.items.push(overflowTwin);
    }
  }
  onLeafItemConfigChange(origResult, {
    name,
    value
  }) {
    const item = this, toolbar = item.up(isToolbar), overflow = toolbar.hasConfig("overflow"), {
      overflowTwin
    } = item;
    if (!overflow || toolbar !== null && toolbar !== void 0 && toolbar.inSyncOverflowVisibility || name === "hidden" && value === item._toolbarOverflow) {
      return;
    }
    if (overflowTwin && !nonSyncedConfigs[name]) {
      overflowTwin[name] = value;
    }
    if (toolbar !== null && toolbar !== void 0 && toolbar.isPainted && item.ref !== "overflowMenuButton") {
      if (!(item.isTextField && name === "value" && (item.containsFocus || overflowTwin !== null && overflowTwin !== void 0 && overflowTwin.containsFocus))) {
        toolbar.syncOverflowVisibility();
      }
    }
  }
  createWidget(widget) {
    if (widget === "->") {
      widget = {
        type: "widget",
        cls: "b-toolbar-fill"
      };
    } else if (widget === "|") {
      widget = {
        type: "widget",
        cls: "b-toolbar-separator"
      };
    } else if (typeof widget === "string") {
      widget = {
        type: "widget",
        cls: "b-toolbar-text",
        html: widget
      };
    }
    const result = super.createWidget(widget);
    if (this.widgetCls) {
      result.element.classList.add(this.widgetCls);
    }
    return result;
  }
};
Toolbar.initClass();
Toolbar._$name = "Toolbar";
var acceptNode = (e) => !e.classList.contains("b-focus-trap") && DomHelper.isFocusable(e) ? DomHelper.NodeFilter.FILTER_ACCEPT : DomHelper.NodeFilter.FILTER_SKIP;
var emptyArray$6 = [];
var emptyObject$7 = {};
var emptySplit = [emptyArray$6, emptyArray$6];
var finishBodyWrap = (config, classes, final) => {
  const {
    vertical
  } = config;
  delete config.vertical;
  return _objectSpread2(_objectSpread2({}, config), {}, {
    class: _objectSpread2(_objectSpread2({}, classes), {}, {
      [`b-${vertical ? "v" : "h"}box`]: 1,
      "b-box-center": 1,
      "b-panel-bar-wrap": !final
    })
  });
};
var wrapBody = (inner, bodyWrapTag, vertical = false) => {
  const wrap = {
    vertical,
    children: inner ? [inner] : []
  };
  if (bodyWrapTag) {
    wrap.tag = bodyWrapTag;
  }
  return wrap;
};
var barConfigs = {
  dock: 1,
  hidden: 1,
  weight: 1
};
var dockDirection = {
  top: [true, true],
  bottom: [true, false],
  left: [false, true],
  right: [false, false]
};
var headerDock = {
  header: 1,
  "pre-header": 1
};
var Panel = class extends Container.mixin(State, Toolable) {
  static get $name() {
    return "Panel";
  }
  static get type() {
    return "panel";
  }
  static get configurable() {
    return {
      localizableProperties: ["title"],
      collapsed: {
        value: null,
        $config: null,
        default: false
      },
      collapsible: {
        value: null,
        $config: "nullify"
      },
      bodyCls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      bodyTag: null,
      bodyWrapTag: null,
      trapFocus: null,
      title: null,
      header: null,
      stateful: ["collapsed"],
      stripDefaults: {
        "*": {
          type: "toolbar",
          dock: "top"
        },
        bbar: {
          dock: "bottom",
          weight: -1e3
        },
        tbar: {
          weight: -1e3
        }
      },
      strips: {
        value: null,
        $config: "nullify"
      },
      toolDefaults: {
        close: {
          weight: -1e3
        },
        collapse: {
          weight: -990
        }
      },
      footer: null,
      revealed: null,
      tbar: null,
      bbar: null,
      role: "region"
    };
  }
  updateElement(element, oldElement) {
    const result = super.updateElement(element, oldElement);
    if (this.titleElement) {
      DomHelper.setAttributes(this.ariaElement, {
        "aria-describedby": this.titleElement.id
      });
    }
    return result;
  }
  compose() {
    const me = this, {
      collapsible,
      focusable,
      hasItems,
      revealed,
      tools
    } = me, header = me.composeHeader(), horz = (header === null || header === void 0 ? void 0 : header.class["b-dock-left"]) || (header === null || header === void 0 ? void 0 : header.class["b-dock-right"]);
    let body = me.composeBody(), key = "bodyWrapElement";
    if (collapsible) {
      [key, body] = collapsible.wrapCollapser(key, body);
    }
    return {
      tabIndex: hasItems && focusable !== false || focusable ? 0 : null,
      class: {
        [`b-panel-collapsible-${collapsible === null || collapsible === void 0 ? void 0 : collapsible.type}`]: collapsible,
        [`b-panel-collapse-${collapsible === null || collapsible === void 0 ? void 0 : collapsible.collapseDir}`]: collapsible,
        [`b-${horz ? "h" : "v"}box`]: 1,
        "b-panel-collapsible": collapsible,
        "b-panel-has-header": header,
        "b-panel-has-tools": tools ? 1 : 0,
        "b-panel-overlay-revealed": revealed
      },
      children: {
        topFocusTrap: {
          "aria-hidden": true,
          tabIndex: 0,
          class: {
            "b-focus-trap": 1
          }
        },
        headerElement: header,
        [key]: body,
        bottomFocusTrap: {
          "aria-hidden": true,
          tabIndex: 0,
          class: {
            "b-focus-trap": 1,
            "b-end-focus-trap": 1
          }
        }
      }
    };
  }
  composeBody() {
    const me = this, {
      bodyCls,
      bodyConfig,
      bodyWrapTag,
      footer,
      uiClassList
    } = me, strips = ObjectHelper.values(me.strips, (k, v) => !dockDirection[v === null || v === void 0 ? void 0 : v.dock]).sort(me.byWeightSortFn);
    let bar, before, dock, i, name, vertical, wrap;
    if (footer) {
      dock = footer.dock || "bottom";
      strips.unshift({
        dock,
        element: {
          tag: "footer",
          reference: "footerElement",
          html: typeof footer === "string" ? footer : footer.html,
          class: _objectSpread2(_objectSpread2({}, uiClassList), {}, {
            [`b-dock-${dock}`]: 1,
            [`${footer.cls || ""}`]: 1
          })
        }
      });
    }
    if (bodyCls) {
      if (!bodyConfig[name = "className"]) {
        name = "class";
      }
      bodyConfig[name] = new DomClassList(bodyConfig[name]).assign(bodyCls);
    }
    for (i = strips.length; i-- > 0; ) {
      bar = strips[i];
      [vertical, before] = dockDirection[bar.dock];
      if (!wrap) {
        wrap = wrapBody(bodyConfig, bodyWrapTag, vertical);
      } else if (wrap.vertical !== vertical) {
        wrap = wrapBody(finishBodyWrap(wrap, uiClassList), "", vertical);
      }
      wrap.children[before ? "unshift" : "push"](bar.element);
    }
    const body = finishBodyWrap(wrap || wrapBody(bodyConfig, bodyWrapTag), uiClassList, true);
    body.class["b-panel-body-wrap"] = 1;
    body.class[`b-${me.$$name.toLowerCase()}-body-wrap`] = 1;
    return body;
  }
  get hasHeader() {
    if (this.header === false) {
      return false;
    }
    const {
      header,
      title,
      tools,
      parent
    } = this, hasVisibleTools = this.maximizable || Object.values(tools || {}).some((tool) => !tool.hidden);
    return header || !(parent !== null && parent !== void 0 && parent.suppressChildHeaders) && (title || hasVisibleTools);
  }
  get rootUiClass() {
    return Panel;
  }
  composeHeader(force) {
    var _me$collapsible;
    const me = this;
    if (!me.hasHeader && !force) {
      return;
    }
    const header = me.header || {}, dock = header.dock || "top", [before, after] = me.splitHeaderItems({
      dock,
      as: "element"
    }), classes = me.$meta.hierarchy, title = me.composeTitle(header), cls = new DomClassList(_objectSpread2({
      [`b-dock-${dock}`]: 1
    }, me.uiClassList), header.cls);
    let i, name;
    for (i = classes.indexOf(Panel); i < classes.length; ++i) {
      name = classes[i].$$name;
      if (name !== "Grid") {
        cls[`b-${name.toLowerCase()}-header`] = 1;
      }
    }
    const headerConfig = {
      tag: "header",
      class: cls,
      children: [...before, title, ...after]
    };
    return ((_me$collapsible = me.collapsible) === null || _me$collapsible === void 0 ? void 0 : _me$collapsible.composeHeader(headerConfig)) || headerConfig;
  }
  composeTitle(header) {
    var _this$collapsible;
    const title = typeof header === "string" ? header : this.title || header.title, titleConfig = {
      reference: "titleElement",
      id: `${this.id}-panel-title`,
      html: title !== null && title !== void 0 ? title : "\xA0",
      class: _objectSpread2({
        [`b-align-${header.titleAlign || "start"}`]: 1,
        "b-header-title": 1
      }, this.uiClassList)
    };
    if (ObjectHelper.isObject(title)) {
      delete titleConfig.html;
      ObjectHelper.merge(titleConfig, title);
    }
    return ((_this$collapsible = this.collapsible) === null || _this$collapsible === void 0 ? void 0 : _this$collapsible.composeTitle(titleConfig)) || titleConfig;
  }
  updateTitle() {
  }
  afterRecompose() {
    var _me$_headerClickDetac;
    super.afterRecompose();
    const me = this, {
      headerElement
    } = me;
    (_me$_headerClickDetac = me._headerClickDetacher) === null || _me$_headerClickDetac === void 0 ? void 0 : _me$_headerClickDetac.call(me);
    me._headerClickDetacher = headerElement && EventHelper.on({
      element: headerElement,
      click: (ev) => {
        var _me$trigger;
        return (_me$trigger = me.trigger) === null || _me$trigger === void 0 ? void 0 : _me$trigger.call(me, "headerClick", {
          event: ev
        });
      }
    });
  }
  onHeaderClick(info) {
    var _this$collapsible2;
    (_this$collapsible2 = this.collapsible) === null || _this$collapsible2 === void 0 ? void 0 : _this$collapsible2.onHeaderClick(info);
  }
  onPaint() {
    var _this$collapsible3;
    super.onPaint(...arguments);
    (_this$collapsible3 = this.collapsible) === null || _this$collapsible3 === void 0 ? void 0 : _this$collapsible3.onPanelPaint(this);
  }
  splitHeaderItems({
    as,
    overlay,
    dock
  } = emptyObject$7) {
    const me = this, asElement = as === "element", {
      collapsed
    } = me, endTools = me.getEndTools({
      overlay
    }), startTools = me.getStartTools({
      overlay
    }), strips = ObjectHelper.values(me.strips, (k, v) => !headerDock[v === null || v === void 0 ? void 0 : v.dock] && v.isCollapsified(collapsed, overlay));
    let ret = emptySplit, after, before, i;
    if (strips.length + endTools.length + startTools.length) {
      ret = [
        before = [...startTools, ...strips.filter((e) => e.dock === "pre-header").sort(me.byWeightSortFn)],
        after = [...strips.filter((e) => e.dock === "header").sort(me.byWeightReverseSortFn), ...endTools]
      ];
      for (i = 0; i < before.length; ++i) {
        var _before$i$syncRotatio, _before$i;
        dock && ((_before$i$syncRotatio = (_before$i = before[i]).syncRotationToDock) === null || _before$i$syncRotatio === void 0 ? void 0 : _before$i$syncRotatio.call(_before$i, dock));
        if (asElement) {
          before[i] = before[i].element;
        }
      }
      for (i = 0; i < after.length; ++i) {
        var _after$i$syncRotation, _after$i;
        dock && ((_after$i$syncRotation = (_after$i = after[i]).syncRotationToDock) === null || _after$i$syncRotation === void 0 ? void 0 : _after$i$syncRotation.call(_after$i, dock));
        if (asElement) {
          after[i] = after[i].element;
        }
      }
    }
    return ret;
  }
  set bodyConfig(bodyConfig) {
    this._bodyConfig = bodyConfig;
  }
  get bodyConfig() {
    const me = this, {
      bodyTag
    } = me, result = ObjectHelper.merge({
      reference: "bodyElement",
      className: _objectSpread2(_objectSpread2({}, me.getStaticWidgetClasses(Panel, "-content")), {}, {
        "b-box-center": 1,
        "b-text-content": me.textContent && me.hasNoChildren
      })
    }, me._bodyConfig);
    if (bodyTag) {
      result.tag = bodyTag;
    }
    if (me.initializingElement || !me._element) {
      result.html = me.content || me._html;
    }
    return result;
  }
  changeBodyCls(cls) {
    return DomClassList.from(cls);
  }
  changeTbar(bar) {
    this.getConfig("strips");
    this.strips = {
      tbar: bar
    };
    return this.strips.tbar;
  }
  changeBbar(bar) {
    this.getConfig("strips");
    this.strips = {
      bbar: bar
    };
    return this.strips.bbar;
  }
  get childItems() {
    var _me$collapsible2;
    const me = this, strips = ObjectHelper.values(me.strips, (k, v) => !dockDirection[v === null || v === void 0 ? void 0 : v.dock]).sort(me.byWeightSortFn), [before, after] = me.splitHeaderItems(), [before2, after2] = ((_me$collapsible2 = me.collapsible) === null || _me$collapsible2 === void 0 ? void 0 : _me$collapsible2.splitHeaderItems()) || emptySplit;
    return [
      ...before,
      ...before2,
      ...after,
      ...after2,
      ...strips.filter((b) => dockDirection[b.dock][1]),
      ...me._items || emptyArray$6,
      ...strips.filter((b) => !dockDirection[b.dock][1]).reverse()
    ];
  }
  changeStrips(strips, oldStrips) {
    const me = this, manager = me.$strips || (me.$strips = new DynamicObject({
      configName: "strips",
      factory: Widget,
      inferType: false,
      owner: me,
      created(instance) {
        var _instance$layout;
        const {
          dock
        } = instance;
        if (!headerDock[dock] && !dockDirection[dock]) {
          throw new Error(`Invalid dock value "${dock}"; must be: top, left, right, bottom, header, or pre-header`);
        }
        FunctionHelper.after(instance, "onConfigChange", (ret, {
          name
        }) => {
          if (barConfigs[name]) {
            me.onConfigChange({
              name: "strips",
              value: manager.target
            });
          }
        });
        instance.innerItem = false;
        me.onChildAdd(instance);
        instance.parent = me;
        (_instance$layout = instance.layout) === null || _instance$layout === void 0 ? void 0 : _instance$layout.renderChildren();
        if (instance.hasItems) {
          me.hasItems = true;
        }
      },
      setup(config, name) {
        config = ObjectHelper.merge(ObjectHelper.clone(me.stripDefaults["*"]), me.stripDefaults[name], config);
        config.parent = me;
        config.ref = name;
        return config;
      },
      transform(config) {
        if (Array.isArray(config)) {
          config = {
            items: config
          };
        }
        return config || null;
      }
    }));
    manager.update(strips);
    if (!oldStrips) {
      return manager.target;
    }
  }
  get collapsing() {
    var _this$collapsible4;
    return (_this$collapsible4 = this.collapsible) === null || _this$collapsible4 === void 0 ? void 0 : _this$collapsible4.collapsing;
  }
  get collapsingExpanding() {
    var _this$collapsible5;
    return (_this$collapsible5 = this.collapsible) === null || _this$collapsible5 === void 0 ? void 0 : _this$collapsible5.collapsingExpanding;
  }
  get expanding() {
    var _this$collapsible6;
    return (_this$collapsible6 = this.collapsible) === null || _this$collapsible6 === void 0 ? void 0 : _this$collapsible6.expanding;
  }
  changeCollapsed(value) {
    const me = this, {
      collapsible
    } = me;
    me.recompose.flush();
    value = Boolean(value);
    if (!collapsible || me.changingCollapse || !me.isPainted) {
      return value;
    }
    collapsible === null || collapsible === void 0 ? void 0 : collapsible.collapse({
      animation: null,
      collapsed: value
    });
  }
  changeCollapsible(collapsible, was) {
    const me = this;
    me.getConfig("tools");
    if (collapsible) {
      if (collapsible === true) {
        collapsible = {};
      } else if (typeof collapsible === "string") {
        collapsible = {
          [dockDirection[collapsible] ? "direction" : "type"]: collapsible
        };
      }
    }
    return PanelCollapser.reconfigure(was, collapsible, {
      owner: me,
      defaults: {
        panel: me
      },
      cleanup() {
        if (me.collapsed) {
          was.collapse({
            animation: null,
            collapsed: false
          });
          me._collapsed = 1;
        }
      }
    });
  }
  updateCollapsible(collapsible) {
    const me = this, tools = collapsible === null || collapsible === void 0 ? void 0 : collapsible.toolsConfig;
    me.tools = {
      collapse: (tools === null || tools === void 0 ? void 0 : tools.collapse) || null,
      recollapse: (tools === null || tools === void 0 ? void 0 : tools.recollapse) || null
    };
    if (collapsible && me.isPainted && me.collapsed) {
      me._collapsed = 1;
    }
    if (me.collapsed === 1) {
      me.collapsed = true;
    }
  }
  _collapse(collapsed, options) {
    var _this$collapsible7;
    if (options !== true && options !== void 0) {
      if (options === false) {
        collapsed.collapsed = !collapsed.collapsed;
      } else if (typeof options === "number") {
        collapsed.animation = {
          duration: options
        };
      } else if (options === null) {
        collapsed.animation = options;
      } else if (options === true)
        ;
      else if ("animation" in options) {
        ObjectHelper.merge(collapsed, options);
      } else {
        collapsed.animation = options;
      }
    }
    return (_this$collapsible7 = this.collapsible) === null || _this$collapsible7 === void 0 ? void 0 : _this$collapsible7.collapse(collapsed);
  }
  collapse(options) {
    return this._collapse({
      collapsed: true
    }, options);
  }
  expand(options) {
    return this._collapse({
      collapsed: false
    }, options);
  }
  toggleCollapsed(options) {
    return this.collapsed ? this.expand(options) : this.collapse(options);
  }
  get expandedHeaderDock() {
    var _ref, _this$_expandedHeader, _this$initialConfig$h;
    return (_ref = (_this$_expandedHeader = this._expandedHeaderDock) !== null && _this$_expandedHeader !== void 0 ? _this$_expandedHeader : (_this$initialConfig$h = this.initialConfig.header) === null || _this$initialConfig$h === void 0 ? void 0 : _this$initialConfig$h.dock) !== null && _ref !== void 0 ? _ref : "top";
  }
  set expandedHeaderDock(v) {
    this._expandedHeaderDock = v === null || v === void 0 ? void 0 : v.toLowerCase();
  }
  updateHeader(header) {
    if (!this.changingCollapse) {
      this.expandedHeaderDock = header === null || header === void 0 ? void 0 : header.dock;
    }
  }
  updateTrapFocus(trapFocus) {
    var _me$focusTrapListener;
    const me = this;
    me.element.classList[trapFocus ? "add" : "remove"]("b-focus-trapped");
    me.focusTrapListener = (_me$focusTrapListener = me.focusTrapListener) === null || _me$focusTrapListener === void 0 ? void 0 : _me$focusTrapListener.call(me);
    if (trapFocus) {
      me.focusTrapListener = EventHelper.on({
        element: me.element,
        focusin: "onFocusTrapped",
        delegate: ".b-focus-trap",
        thisObj: me
      });
      if (!me.treeWalker) {
        me.treeWalker = this.setupTreeWalker(me.element, DomHelper.NodeFilter.SHOW_ELEMENT, acceptNode);
      }
    }
  }
  setupTreeWalker(root2, whatToShow, filter2) {
    return document.createTreeWalker(root2, whatToShow, filter2);
  }
  onFocusTrapped(e) {
    const me = this, treeWalker = me.treeWalker;
    if (e.target === me.bottomFocusTrap) {
      treeWalker.currentNode = me.topFocusTrap;
      treeWalker.nextNode();
    } else if (e.target === me.topFocusTrap) {
      treeWalker.currentNode = me.bottomFocusTrap;
      treeWalker.previousNode();
    } else {
      return;
    }
    me.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }
  get focusElement() {
    return this.hasItems && (super.focusElement || this.element);
  }
  get contentElement() {
    return this.element && this.bodyElement;
  }
  get widgetClassList() {
    const me = this, result = super.widgetClassList;
    if (me.hasHeader) {
      var _me$header;
      result.push("b-panel-has-header", `b-header-dock-${((_me$header = me.header) === null || _me$header === void 0 ? void 0 : _me$header.dock) || "top"}`);
    }
    if (me.tbar) {
      result.push("b-panel-has-top-toolbar");
    }
    if (me.bbar) {
      result.push("b-panel-has-bottom-toolbar");
    }
    return result;
  }
};
Panel.initClass();
Panel._$name = "Panel";
var Popup = class extends Panel {
  static get $name() {
    return "Popup";
  }
  static get type() {
    return "popup";
  }
  static get configurable() {
    return {
      autoShow: true,
      autoClose: true,
      showOnClick: false,
      forElement: null,
      monitorResize: true,
      floating: true,
      hidden: true,
      axisLock: true,
      hideAnimation: {
        opacity: {
          from: 1,
          to: 0,
          duration: ".3s",
          delay: "0s"
        }
      },
      showAnimation: {
        opacity: {
          from: 0,
          to: 1,
          duration: ".4s",
          delay: "0s"
        }
      },
      stripDefaults: {
        bbar: {
          layout: {
            justify: "flex-end"
          }
        }
      },
      testConfig: {
        hideAnimation: null,
        showAnimation: null
      },
      closeAction: "hide",
      trapFocus: true,
      focusOnToFront: true,
      closable: null,
      maximizable: null,
      modal: null,
      maximized: null,
      tools: {
        close: {
          cls: "b-popup-close",
          handler: "close",
          weight: -1e3,
          ariaLabel: "L{Popup.close}",
          hidden: true
        },
        maximize: {
          cls: "b-popup-expand",
          handler: "toggleMaximized",
          weight: -999,
          hidden: true
        }
      },
      highlightReturnedFocus: true,
      role: "dialog"
    };
  }
  finalizeInit() {
    const me = this, {
      forElement
    } = me;
    me.anchoredTo = forElement;
    me.initialAnchor = me.anchor;
    if (forElement && me.showOnClick) {
      if (!me.initialConfig.autoShow) {
        me.autoShow = false;
      }
      EventHelper.on({
        element: forElement,
        click: "onElementUserAction",
        thisObj: me
      });
    }
    super.finalizeInit();
    if (me.autoShow && (!forElement || DomHelper.isVisible(forElement))) {
      if (me.autoShow === true) {
        me.show();
      } else {
        me.setTimeout(() => me.show(), me.autoShow);
      }
    }
  }
  onPaint({
    firstPaint
  }) {
    var _super$onPaint;
    (_super$onPaint = super.onPaint) === null || _super$onPaint === void 0 ? void 0 : _super$onPaint.call(this, ...arguments);
    const me = this;
    if (firstPaint && me.headerElement) {
      EventHelper.on({
        element: me.headerElement,
        dblclick: me.onHeaderDblClick,
        thisObj: me
      });
    }
  }
  doDestroy() {
    this.syncModalMask();
    super.doDestroy();
  }
  compose() {
    const {
      hasNoChildren,
      textContent
    } = this;
    return {
      class: {
        "b-text-popup": Boolean(textContent && hasNoChildren)
      }
    };
  }
  close() {
    const me = this;
    if (!me._hidden && me.trigger("beforeClose") !== false || me._hidden && me.closeAction === "destroy") {
      me.modal && me.closeAction === "destroy" && me.revertFocus();
      me.unmask();
      if (me.containsFocus && me.highlightReturnedFocus) {
        me.setTimeout(() => me.element.classList.add("b-using-keyboard"), 0);
      }
      return me[me.closeAction]();
    }
  }
  toggleMaximized() {
    this.maximized = !this.maximized;
  }
  updateMaximized(value) {
    DomHelper.toggleClasses(this.element, ["b-maximized"], value);
  }
  onInternalKeyDown(event) {
    const me = this;
    if (event.key === "Escape") {
      event.stopImmediatePropagation();
      if (me.floating || me.positioned) {
        me.close(true);
      } else if (me.collapsible) {
        if (me.revealed) {
          me.collapsible.toggleReveal();
        } else {
          me.collapse();
        }
      }
    }
  }
  onDocumentMouseDown({
    event
  }) {
    const me = this, {
      owner
    } = me, {
      target
    } = event;
    if (event.type !== "touchend" && owner !== null && owner !== void 0 && owner.isButton && owner._menu === me && owner.element.contains(target)) {
      event.preventDefault();
      return false;
    }
    if (me.modal && target === Popup.modalMask) {
      event.preventDefault();
      if (me.modal.closeOnMaskTap) {
        me.close();
      } else if (!me.containsFocus) {
        me.focus();
      }
    } else if (!me.owns(target) && me.autoClose && !me.containsFocus) {
      me.close();
    }
  }
  get isTopModal() {
    return DomHelper.isVisible(Popup.modalMask) && this.element.previousElementSibling === Popup.modalMask;
  }
  onFocusIn(e) {
    const activeEl = DomHelper.getActiveElement(this);
    super.onFocusIn(e);
    if (DomHelper.getActiveElement(this) === activeEl && e.target === this.element) {
      this.focus();
    }
  }
  onFocusOut(e) {
    const usingVirtualKeyboard = globalThis.visualViewport && globalThis.visualViewport.height < document.documentElement.clientHeight - 1;
    if (!usingVirtualKeyboard && !this.modal && this.autoClose) {
      this.close();
    }
    super.onFocusOut(e);
  }
  onShow() {
    var _super$onShow;
    const me = this;
    if (me.autoClose) {
      me.addDocumentMouseDownListener();
    }
    if (me.focusOnToFront) {
      me.focus();
    }
    (_super$onShow = super.onShow) === null || _super$onShow === void 0 ? void 0 : _super$onShow.call(this);
    me.syncModalMask();
  }
  addDocumentMouseDownListener() {
    if (!this.mouseDownRemover) {
      this.mouseDownRemover = GlobalEvents$1.ion({
        globaltap: "onDocumentMouseDown",
        thisObj: this
      });
    }
  }
  updateModal(modal) {
    if (modal) {
      this.floating = true;
    }
  }
  syncModalMask() {
    const me = this, {
      modal,
      element
    } = me;
    element.setAttribute("aria-modal", Boolean(modal));
    if (modal && me.isVisible) {
      if (typeof me._x !== "number" && typeof me._y !== "number") {
        me.centered = true;
        me.anchor = false;
      }
      me.modalMask.classList.remove("b-hide-display");
      element.classList.add("b-modal");
    } else if (me.isPainted) {
      element.classList.remove("b-modal");
      const remainingModals = me.floatRoot.querySelectorAll(".b-modal"), topModal = remainingModals.length ? Popup.fromElement(remainingModals[remainingModals.length - 1], "popup") : null;
      if (topModal) {
        topModal.syncModalMask();
      } else {
        Popup.modalMask.classList.add("b-hide-display");
      }
    }
  }
  onHide() {
    var _me$mouseDownRemover, _super$onHide;
    const me = this;
    (_me$mouseDownRemover = me.mouseDownRemover) === null || _me$mouseDownRemover === void 0 ? void 0 : _me$mouseDownRemover.call(me);
    me.mouseDownRemover = null;
    (_super$onHide = super.onHide) === null || _super$onHide === void 0 ? void 0 : _super$onHide.call(this);
    me.syncModalMask();
  }
  onElementUserAction() {
    this.show();
  }
  onHeaderDblClick() {
    if (this.maximizable) {
      this.toggleMaximized();
    }
  }
  updateClosable(closable) {
    this.tools.close.hidden = !closable;
  }
  updateMaximizable(maximizable) {
    this.tools.maximize.hidden = !maximizable;
  }
  get modalMask() {
    const {
      modalMask
    } = Popup;
    if (modalMask.nextElementSibling !== this.element) {
      this.floatRoot.insertBefore(modalMask, this.element);
    }
    return modalMask;
  }
  static get modalMask() {
    if (!this._modalMask) {
      this._modalMask = DomHelper.createElement({
        className: "b-modal-mask b-hide-display"
      });
      EventHelper.on({
        element: this._modalMask,
        wheel: (e) => e.preventDefault()
      });
    }
    return this._modalMask;
  }
};
Popup.initClass();
Popup._$name = "Popup";
var bIcon = /^b-icon-/;
var bFa = /^b-fa-/;
var MenuItem = class extends Widget {
  static get $name() {
    return "MenuItem";
  }
  static get type() {
    return "menuitem";
  }
  static get configurable() {
    return {
      checked: null,
      separator: null,
      toggleGroup: null,
      menu: {
        value: null,
        $config: ["lazy", "nullify"]
      },
      icon: null,
      closeParent: null,
      href: null,
      target: null,
      localizableProperties: ["text"],
      role: "menuitem",
      closeMenuDelay: 200
    };
  }
  updateElement(element, oldElement) {
    const result = super.updateElement(element, oldElement);
    if (typeof this.checked === "boolean") {
      this.role = "menuitemcheckbox";
    }
    this.ariaHasPopup = this.hasMenu ? "menu" : false;
    return result;
  }
  compose() {
    var _me$cls;
    const me = this, {
      checked,
      href,
      hasMenu,
      separator,
      target,
      text,
      toggleGroup
    } = me, isCheckItem = typeof checked === "boolean", icon = me.icon || (isCheckItem ? "b-fw-icon" : ""), checkCls = `b-icon-${toggleGroup ? "radio-" : ""}`, hasCustomContent = typeof text === "object";
    return {
      tag: href ? "a" : "div",
      tabIndex: -1,
      href,
      target,
      class: {
        "b-has-submenu": hasMenu,
        "b-checked": checked,
        "b-separator": separator || ((_me$cls = me.cls) === null || _me$cls === void 0 ? void 0 : _me$cls["b-separator"])
      },
      dataset: {
        group: me.toggleGroup
      },
      [isCheckItem ? "aria-checked" : ""]: checked,
      [hasMenu ? "aria-expanded" : ""]: false,
      children: {
        iconElement: icon && {
          "aria-hidden": true,
          tag: "i",
          class: _objectSpread2({
            "b-fa": bFa.test(icon),
            "b-icon": bIcon.test(icon),
            "b-menuitem-icon": 1,
            [`${checkCls}checked`]: checked === true,
            [`${checkCls}unchecked`]: checked === false
          }, DomClassList.normalize(icon, "object"))
        },
        textElement: {
          tag: "span",
          html: hasCustomContent ? null : text,
          class: {
            "b-menu-text": 1,
            "b-menu-custom-content": hasCustomContent
          },
          children: hasCustomContent ? [text] : null
        },
        subMenuIcon: hasMenu && {
          "aria-hidden": true,
          tag: "i",
          class: {
            "b-fw-icon": 1,
            "b-icon-sub-menu": 1
          }
        }
      }
    };
  }
  doAction(event) {
    const item = this, menu = this.parent, itemEvent = {
      menu,
      item,
      element: item.element,
      bubbles: true
    };
    if (typeof item.checked === "boolean") {
      const newCheckedState = !item.checked;
      if (!item.toggleGroup || newCheckedState) {
        item.checked = !item.checked;
      }
    }
    item.trigger("beforeItem", itemEvent);
    item.trigger("item", itemEvent);
    if (item.closeParent && menu) {
      menu.rootMenu.close();
      if (event && !item.href) {
        event.preventDefault();
      }
    }
  }
  get focusElement() {
    return this.element;
  }
  get contentElement() {
    return this.textElement;
  }
  get isFocusable() {
    const {
      focusElement
    } = this;
    return focusElement && this.isVisible && (focusElement === document.body || focusElement.offsetParent);
  }
  get hasMenu() {
    return this.hasConfig("menu");
  }
  get childItems() {
    const {
      _menu
    } = this;
    return _menu ? [_menu] : [];
  }
  get text() {
    return this.html;
  }
  set text(text) {
    this.html = text;
  }
  onFocusIn(e) {
    super.onFocusIn(e);
    if (!this.disabled && this.menu) {
      this.delay("openMenu", 200);
    }
  }
  onFocusOut(e) {
    this.clearTimeout("openMenu");
    super.onFocusOut(e);
    if (this._menu) {
      this.menu.closeTimer = this.menu.setTimeout(() => this.closeMenu(), this.closeMenuDelay);
    }
  }
  openMenu(andFocus) {
    const {
      menu
    } = this;
    if (!this.disabled && menu) {
      menu.focusOnToFront = andFocus;
      menu.show();
    }
  }
  onChildShow(shown) {
    super.onChildShow(shown);
    this.ariaElement.setAttribute("aria-expanded", true);
  }
  closeMenu() {
    if (this._menu instanceof Widget) {
      this.menu.close();
    }
  }
  onChildHide(hidden) {
    super.onChildHide(hidden);
    this.ariaElement.setAttribute("aria-expanded", false);
  }
  changeToggleGroup(toggleGroup) {
    if (toggleGroup && typeof this.checked !== "boolean") {
      this.checked = false;
    }
    return toggleGroup;
  }
  changeChecked(checked, old) {
    if (this.isConfiguring || typeof old === "boolean") {
      return Boolean(checked);
    }
  }
  updateChecked(checked) {
    const me = this;
    if (!me.isConfiguring) {
      if (me.toggleGroup) {
        me.uncheckToggleGroupMembers();
      }
      me.element.setAttribute("aria-checked", checked);
      me.trigger("toggle", {
        menu: me.owner,
        item: me,
        element: me.element,
        bubbles: true,
        checked
      });
    }
  }
  getToggleGroupMembers() {
    const me = this, {
      checked,
      toggleGroup,
      element
    } = me, result = [];
    if (checked && toggleGroup) {
      DomHelper.forEachSelector(me.rootElement, `[data-group=${toggleGroup}]`, (otherElement) => {
        if (otherElement !== element) {
          const partnerCheckItem = Widget.fromElement(otherElement);
          partnerCheckItem && result.push(partnerCheckItem);
        }
      });
    }
    return result;
  }
  uncheckToggleGroupMembers() {
    if (this.checked && this.toggleGroup) {
      this.getToggleGroupMembers().forEach((widget) => widget.checked = false);
    }
  }
  get closeParent() {
    const result = typeof this.checked === "boolean" ? this._closeParent : this._closeParent !== false;
    return result && !this.hasMenu;
  }
  changeMenu(config, existingMenu) {
    const me = this, {
      constrainTo,
      scrollAction
    } = me.owner;
    if (config && typeof config === "object" && !("items" in config) && !("widgets" in config) && !("html" in config)) {
      config = {
        lazyItems: config
      };
    }
    return Menu.reconfigure(existingMenu, config, {
      owner: me,
      defaults: {
        type: "menu",
        align: "s0-e0",
        anchor: true,
        autoClose: true,
        autoShow: false,
        cls: "b-sub-menu",
        forElement: me.element,
        owner: me,
        ariaLabel: me.text,
        constrainTo,
        scrollAction
      }
    });
  }
};
MenuItem.initClass();
MenuItem._$name = "MenuItem";
var validKeys = {
  ArrowUp: 1,
  ArrowDown: 1,
  ArrowRight: 1,
  ArrowLeft: 1,
  Enter: 1,
  Escape: 1
};
var Menu = class extends Popup {
  static get $name() {
    return "Menu";
  }
  static get type() {
    return "menu";
  }
  static get configurable() {
    return {
      focusable: true,
      align: "t-b",
      scrollAction: "hide",
      focusOnHover: null,
      scrollable: false,
      defaultType: "menuitem",
      tools: {
        close: false
      },
      role: "menu",
      ariaElement: "bodyElement"
    };
  }
  construct(config) {
    if (Array.isArray(config)) {
      config = {
        lazyItems: config
      };
    }
    super.construct(config);
    EventHelper.on({
      element: this.element,
      click: "onMouseClick",
      mouseover: "onMouseOver",
      mouseenter: "onMouseEnter",
      mouseleave: "onMouseLeave",
      thisObj: this
    });
  }
  afterShow(resolveFn) {
    const {
      items: items2,
      element
    } = this, hasSubmenu = items2.some((item) => Boolean(item._menu));
    if (hasSubmenu) {
      element.classList.add("b-menu-with-submenu");
    }
    const hasIcon = items2.some((item) => item.icon);
    if (hasIcon) {
      element.classList.add("b-menu-with-icon");
    }
    super.afterShow(resolveFn);
  }
  createWidget(item) {
    if (typeof item === "string") {
      item = {
        text: item
      };
    }
    return super.createWidget(item);
  }
  get focusElement() {
    var _me$parentMenu;
    const me = this, fromParentMenu = (_me$parentMenu = me.parentMenu) === null || _me$parentMenu === void 0 ? void 0 : _me$parentMenu.element.contains(DomHelper.getActiveElement(me.parentMenu)), firstWidget = me.items[0];
    if (fromParentMenu || DomHelper.usingKeyboard || !(firstWidget instanceof MenuItem)) {
      return super.focusElement;
    }
    return me.element;
  }
  onDocumentMouseDown({
    event
  }) {
    if (!this.parentMenu || !this.parentMenu.owns(event.target)) {
      return super.onDocumentMouseDown(...arguments);
    }
  }
  hide(animate) {
    const me = this;
    super.hide(animate);
    if (!me.isVisible) {
      var _me$currentSubMenu, _me$currentSubMenu$hi;
      (_me$currentSubMenu = me.currentSubMenu) === null || _me$currentSubMenu === void 0 ? void 0 : (_me$currentSubMenu$hi = _me$currentSubMenu.hide) === null || _me$currentSubMenu$hi === void 0 ? void 0 : _me$currentSubMenu$hi.call(_me$currentSubMenu, animate);
      if (me.parentMenu) {
        me.parentMenu.currentSubMenu = null;
      }
    }
  }
  show() {
    super.show(...arguments);
    const {
      parentMenu
    } = this;
    if (this.isVisible && parentMenu) {
      parentMenu.currentSubMenu = this;
    }
  }
  onMouseClick(event) {
    const menuItem = event.target.closest(".b-menuitem");
    if (menuItem) {
      this.triggerElement(menuItem, event);
    }
  }
  onMouseOver(event) {
    if (this.focusOnHover !== false) {
      var _event$relatedTarget;
      const fromItemElement = (_event$relatedTarget = event.relatedTarget) === null || _event$relatedTarget === void 0 ? void 0 : _event$relatedTarget.closest(".b-widget"), toItemElement = event.target.closest(".b-widget"), overItem = Widget.fromElement(toItemElement);
      if (!DomHelper.isTouchEvent && toItemElement && toItemElement !== fromItemElement && overItem.parent === this) {
        this.setTimeout({
          fn: "handleMouseOver",
          delay: 30,
          args: [overItem],
          cancelOutstanding: true
        });
      }
    }
  }
  handleMouseOver(overItem) {
    overItem.focus();
  }
  onMouseEnter() {
    this.clearTimeout(this.closeTimer);
  }
  onMouseLeave(event) {
    const me = this, {
      relatedTarget
    } = event, leavingToChild = relatedTarget && me.owns(relatedTarget);
    let targetCmp = relatedTarget instanceof HTMLElement && Widget.fromElement(relatedTarget), shouldHideMenu = !leavingToChild;
    if (targetCmp) {
      while (targetCmp.ownerCmp) {
        targetCmp = targetCmp.ownerCmp;
      }
      shouldHideMenu &= !DomHelper.getAncestor(targetCmp.element, [event.target]);
    }
    if (!leavingToChild && shouldHideMenu) {
      if (me.currentSubMenu && !me.currentSubMenu.closeTimer) {
        me.currentSubMenu.hide();
      }
      if (me.element.contains(DomHelper.getActiveElement(me)) && DomHelper.getActiveElement(me).matches(".b-menuitem")) {
        me.focusElement.focus();
      }
    }
  }
  onInternalKeyDown(event) {
    const sourceWidget = Widget.fromElement(event), isFromWidget = sourceWidget && sourceWidget !== this && !(sourceWidget instanceof MenuItem);
    if (event.key === "Escape") {
      (isFromWidget ? this : this.rootMenu).close();
      return;
    }
    super.onInternalKeyDown(event);
    if (isFromWidget) {
      return;
    }
    if (validKeys[event.key]) {
      event.preventDefault();
    }
    const el = this.element, active = DomHelper.getActiveElement(el);
    this.navigateFrom(active !== el && el.contains(active) ? active : null, event.key, event);
  }
  navigateFrom(active, key, event) {
    const me = this, {
      treeWalker
    } = me, item = active && me.getItem(active), enterSubMenu = me.rtl ? "ArrowLeft" : "ArrowRight", exitSubMenu = me.rtl ? "ArrowRight" : "ArrowLeft";
    let toActivate;
    switch (key) {
      case "ArrowUp":
        treeWalker.currentNode = active || (active = me.bottomFocusTrap);
        treeWalker.previousNode();
        toActivate = treeWalker.currentNode;
        break;
      case "ArrowDown":
        treeWalker.currentNode = active || (active = me.topFocusTrap);
        treeWalker.nextNode();
        toActivate = treeWalker.currentNode;
        break;
      case " ":
        if (active && !active.classList.contains("b-disabled")) {
          if (item !== null && item !== void 0 && item.menu) {
            me.openSubMenu(active, item);
          } else {
            me.triggerElement(active, event);
          }
        }
        break;
      case enterSubMenu:
        if (active && item !== null && item !== void 0 && item.menu && !active.classList.contains("b-disabled")) {
          const openedMenu = me.openSubMenu(active, item);
          openedMenu === null || openedMenu === void 0 ? void 0 : openedMenu.focus();
        } else {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }
        break;
      case exitSubMenu:
        if (me.isSubMenu) {
          me.hide();
        } else if (!active) {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }
        break;
      case "Enter":
        if (active && !active.classList.contains("b-disabled")) {
          me.triggerElement(active, event);
        }
        break;
    }
    if (toActivate) {
      if (toActivate === me.element) {
        me.navigateFrom(me.bottomFocusTrap, "ArrowUp", event);
      } else if (toActivate === active) {
        me.navigateFrom(me.topFocusTrap, "ArrowDown", event);
      } else {
        toActivate.focus();
      }
    }
  }
  getItem(item) {
    if (item != null) {
      if (typeof item === "number") {
        return this.items[item];
      }
      if (item.nodeType === Element.ELEMENT_NODE) {
        return Widget.fromElement(item, "menuitem", this.contentElement);
      }
      return this.items.find((c) => c.id == item);
    }
  }
  triggerElement(menuItemElement, event) {
    const item = this.getItem(menuItemElement);
    if (item && !item.disabled) {
      item.doAction(event);
    }
  }
  get isSubMenu() {
    var _this$owner;
    return this === ((_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.menu);
  }
  openSubMenu(element, item) {
    const me = this, subMenu = item.menu;
    if (subMenu) {
      if (!subMenu.isVisible) {
        var _item$onBeforeSubMenu;
        const event = {
          item,
          element
        };
        if (me.trigger("beforeSubMenu", event) === false) {
          return;
        }
        if (((_item$onBeforeSubMenu = item.onBeforeSubMenu) === null || _item$onBeforeSubMenu === void 0 ? void 0 : _item$onBeforeSubMenu.call(item, event)) === false) {
          return;
        }
        subMenu.show();
      }
      return me.currentSubMenu = subMenu;
    }
  }
  set selectedElement(element) {
    const me = this, lastSelected = me._selectedElement;
    if (lastSelected) {
      const lastItem = me.getItem(lastSelected), lastItemMenu = lastItem === null || lastItem === void 0 ? void 0 : lastItem.menu;
      lastItemMenu === null || lastItemMenu === void 0 ? void 0 : lastItemMenu.hide();
      lastSelected.classList.remove("b-active");
    }
    me._selectedElement = element;
    if (element) {
      const doFocus = DomHelper.isFocusable(element);
      element.classList.add("b-active");
      me.scrollable.scrollIntoView(element, {
        animate: !doFocus,
        focus: doFocus
      });
    }
  }
  get selectedElement() {
    return this._selectedElement;
  }
  selectFirst() {
    const treeWalker = this.treeWalker;
    treeWalker.currentNode = this.topFocusTrap;
    treeWalker.nextNode();
    this.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }
  get parentMenu() {
    var _result$up;
    const result = this.owner;
    return result && (result.isMenu ? result : (_result$up = result.up) === null || _result$up === void 0 ? void 0 : _result$up.call(result, "menu"));
  }
  get rootMenu() {
    let menu = this;
    while (menu.parentMenu instanceof this.constructor) {
      menu = menu.parentMenu;
    }
    return menu;
  }
};
Menu.initClass();
Menu._$name = "Menu";
var contextMenuKeyEvent;
var ContextMenuBase = class extends InstancePlugin {
  static get $name() {
    return "ContextMenuBase";
  }
  static get configurable() {
    return {
      type: null,
      menu: {
        $config: ["lazy", "nullify"],
        value: {
          type: "menu",
          autoShow: false,
          closeAction: "hide",
          scrollAction: "hide",
          constrainTo: globalThis
        }
      },
      items: {},
      triggerEvent: false,
      keyMap: {
        " ": {
          handler: "showContextMenuByKey",
          weight: 100
        },
        "Ctrl+Space": "showContextMenuByKey"
      }
    };
  }
  static get pluginConfig() {
    return {
      assign: ["showContextMenu"],
      chain: ["onElementContextMenu", "onElementClick", "onElementDblClick"]
    };
  }
  construct(...args) {
    var _this$type;
    super.construct(...args);
    if (!((_this$type = this.type) !== null && _this$type !== void 0 && _this$type.length)) {
      throw new Error(`Config 'type' is required to be specified for context menu`);
    }
  }
  onElementContextMenu(event) {
    this.onElementEvent(event);
  }
  onElementClick(event) {
    this.onElementEvent(event);
  }
  onElementDblClick(event) {
    this.onElementEvent(event);
  }
  onElementEvent(event) {
    if (event.ctrlKey === true) {
      event.preventDefault();
      return;
    }
    if (!event.handled && this.triggerEvent === event.type) {
      const originalEvent = event;
      if (contextMenuKeyEvent) {
        const {
          target
        } = contextMenuKeyEvent;
        event = EventHelper.fixEvent(new MouseEvent(event.type, event));
        Object.defineProperty(event, "target", {
          get: () => target,
          configurable: true
        });
        event.preventDefault = function() {
          originalEvent.preventDefault();
          originalEvent.handled = true;
        };
      }
      this.internalShowContextMenu(event);
    }
  }
  showContextMenuByKey(event) {
    if (!DomHelper.isEditable(event.target)) {
      const target = this.getKeyboardContextMenuTarget(event.target);
      if (target) {
        contextMenuKeyEvent = event;
        DomHelper.triggerMouseEvent(target, this.triggerEvent);
        event.handled = true;
        event.preventDefault();
        event.stopImmediatePropagation();
        contextMenuKeyEvent = null;
        return true;
      }
    }
    return false;
  }
  getKeyboardContextMenuTarget(targetElement) {
    const targetRect = DomHelper.isInView(targetElement);
    return targetElement.children.length ? DomHelper.childFromPoint(targetElement, targetRect.width / 2, targetRect.height / 2) : targetElement;
  }
  internalShowContextMenu(domEvent) {
    const me = this;
    if (me.disabled) {
      return;
    }
    const data = me.getDataFromEvent(domEvent);
    if (!domEvent.handled && data && me.shouldShowMenu(data)) {
      if (domEvent.type === "contextmenu" && BrowserHelper.isSafari && domEvent.ctrlKey && !domEvent.metaKey) {
        EventHelper.on({
          element: domEvent.target,
          capture: true,
          once: true,
          thisObj: this,
          click(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        });
      }
      data.domEvent = domEvent;
      me.showContextMenu(data);
    }
  }
  getDataFromEvent(event) {
    return {
      event,
      targetElement: this.getTargetElementFromEvent(event)
    };
  }
  getTargetElementFromEvent(event) {
    return event.target;
  }
  showContextMenu(event, alignSpec) {
    var _me$_menu;
    const me = this, isDOMEvent = DomHelper.isDOMEvent(event), menuContext = isDOMEvent ? me.getDataFromEvent(event) : event, domEvent = isDOMEvent ? event : menuContext.domEvent;
    (_me$_menu = me._menu) === null || _me$_menu === void 0 ? void 0 : _me$_menu.hide();
    if (me.disabled) {
      return;
    }
    me.menuContext = menuContext;
    const {
      type,
      client,
      processItems
    } = me, elCenter = DomHelper.isInView(menuContext.targetElement).center;
    Objects.assign(menuContext, {
      feature: me,
      point: domEvent !== null && domEvent !== void 0 && domEvent.clientX ? [domEvent.clientX + 1, domEvent.clientY + 1] : [elCenter.x, elCenter.y],
      menu: me,
      items: {},
      selection: client.selectedRecords
    });
    me.callChainablePopulateMenuMethod(menuContext);
    Objects.merge(menuContext.items, me.baseItems);
    me.preventDefaultEvent(menuContext);
    if ((!processItems || me.callback(processItems, client, [menuContext]) !== false) && me.hasActiveMenuItems(menuContext)) {
      me.populateItemsWithData(menuContext);
      if (me.beforeContextMenuShow(menuContext) !== false) {
        const {
          menu
        } = me;
        if (client.trigger(`${type}MenuBeforeShow`, menuContext) !== false) {
          var _me$touchMoveDetacher;
          menu.items = menuContext.items;
          menu.showBy(alignSpec || menuContext.point);
          (_me$touchMoveDetacher = me.touchMoveDetacher) === null || _me$touchMoveDetacher === void 0 ? void 0 : _me$touchMoveDetacher.call(me);
          me.touchMoveDetacher = EventHelper.on({
            element: client.element,
            touchmove: () => menu.hide(),
            thisObj: menu,
            once: true
          });
          if (domEvent) {
            domEvent.preventDefault();
            domEvent.handled = true;
          }
        }
      }
    }
  }
  get baseItems() {
    if (!this._baseItems) {
      const me = this, {
        namedItems
      } = me, baseItems = me._baseItems = Objects.assign({}, me.items);
      for (const ref in baseItems) {
        const item = baseItems[ref];
        if (item) {
          if (namedItems && ref in namedItems) {
            baseItems[ref] = typeof item === "object" ? Objects.merge(Objects.clone(namedItems[ref]), item) : namedItems[ref];
          } else if (item === true) {
            delete baseItems[ref];
          }
        }
      }
    }
    return this._baseItems;
  }
  hideContextMenu(animate) {
    var _this$menu;
    (_this$menu = this.menu) === null || _this$menu === void 0 ? void 0 : _this$menu.hide(animate);
  }
  callChainablePopulateMenuMethod(eventParams) {
    var _this$client, _this$client2;
    (_this$client = (_this$client2 = this.client)[`populate${StringHelper.capitalize(this.type)}Menu`]) === null || _this$client === void 0 ? void 0 : _this$client.call(_this$client2, eventParams);
  }
  hasActiveMenuItems(eventParams) {
    return Object.values(eventParams.items).some((item) => item && !item.hidden);
  }
  shouldShowMenu() {
    return true;
  }
  beforeContextMenuShow(eventParams) {
  }
  populateItemsWithData(eventParams) {
  }
  preventDefaultEvent(eventParams) {
    var _eventParams$event;
    (_eventParams$event = eventParams.event) === null || _eventParams$event === void 0 ? void 0 : _eventParams$event.preventDefault();
  }
  changeTriggerEvent(triggerEvent) {
    return triggerEvent || this.client.contextMenuTriggerEvent;
  }
  changeMenu(menu, oldMenu) {
    const me = this, {
      client,
      type
    } = me;
    if (menu) {
      return Menu.reconfigure(oldMenu, menu ? Menu.mergeConfigs({
        owner: client,
        rootElement: client.rootElement,
        onItem(itemEvent) {
          client.trigger(`${type}MenuItem`, itemEvent);
        },
        onToggle(itemEvent) {
          client.trigger(`${type}MenuToggleItem`, itemEvent);
        },
        onDestroy() {
          me.menu = null;
        },
        onBeforeItem(itemEvent) {
          Object.assign(itemEvent, me.menuContext);
        },
        onShow({
          source: menu2
        }) {
          me.menuContext.menu = menu2;
          client.trigger(`${type}MenuShow`, me.menuContext);
        }
      }, menu) : null, me);
    } else if (oldMenu !== null && oldMenu !== void 0 && oldMenu.isWidget) {
      oldMenu.destroy();
    }
  }
};
ContextMenuBase._$name = "ContextMenuBase";
var CSSHelper = class {
  static insertRule(cssText, parentElement = document.head) {
    const styleSheet = this.getStyleSheet(parentElement), oldCount = styleSheet.cssRules.length;
    styleSheet.insertRule(cssText, 0);
    if (styleSheet.cssRules.length > oldCount) {
      return styleSheet.cssRules[0];
    }
  }
  static findRule(selector) {
    let result;
    const isFn = typeof selector === "function";
    Array.prototype.find.call(document.head.querySelectorAll("link[rel=stylesheet],style[type*=css]"), (element) => {
      result = Array.prototype.find.call(element.sheet.rules || element.sheet.cssRules, (r) => {
        return isFn ? selector(r) : r.selectorText === selector;
      });
      if (result) {
        return true;
      }
    });
    return result;
  }
  static getStyleSheet(parentElement = document.head) {
    if (!parentElement.$bryntumStylesheet) {
      parentElement.$bryntumStylesheet = DomHelper.createElement({
        tag: "style",
        id: "bryntum-private-styles",
        type: "text/css",
        parent: parentElement
      }).sheet;
    }
    return parentElement.$bryntumStylesheet;
  }
};
CSSHelper._$name = "CSSHelper";
var DragHelperContainer = (Target) => class DragHelperContainer extends (Target || Base$1) {
  static get $name() {
    return "DragHelperContainer";
  }
  initContainerDrag() {
    const me = this;
    if (!me.mode) {
      me.mode = "container";
    }
    if (me.mode === "container" && !me.containers) {
      throw new Error("Container drag mode must specify containers");
    }
  }
  grabContainerDrag(event) {
    const me = this;
    if (!me.ignoreSelector || !event.target.closest(me.ignoreSelector)) {
      const element = DomHelper.getAncestor(event.target, me.containers, me.outerElement);
      if (element) {
        const box = element.getBoundingClientRect();
        me.context = {
          element,
          valid: true,
          action: "container",
          offsetX: event.pageX - box.left,
          offsetY: event.pageY - box.top,
          originalPosition: {
            parent: element.parentElement,
            prev: element.previousElementSibling,
            next: element.nextElementSibling
          }
        };
      }
      return true;
    }
    return false;
  }
  startContainerDrag(event) {
    var _outerWidgetEl$parent;
    const me = this, {
      context,
      floatRootOwner
    } = me, {
      element: dragElement
    } = context, clonedNode = dragElement.cloneNode(true), box = dragElement.getBoundingClientRect(), outerWidgetEl = floatRootOwner === null || floatRootOwner === void 0 ? void 0 : floatRootOwner.element.closest(".b-outer");
    clonedNode.classList.add(me.dragProxyCls);
    clonedNode.classList.add(me.draggingCls);
    ((floatRootOwner === null || floatRootOwner === void 0 ? void 0 : floatRootOwner.floatRoot) || DomHelper.getRootElement(dragElement)).appendChild(clonedNode);
    context.dragProxy = clonedNode;
    clonedNode.style.width = box.width + "px";
    clonedNode.style.height = box.height + "px";
    DomHelper.setTranslateXY(context.dragProxy, box.left, box.top);
    context.dragging = dragElement;
    dragElement.classList.add(me.dropPlaceholderCls);
    if (outerWidgetEl !== null && outerWidgetEl !== void 0 && (_outerWidgetEl$parent = outerWidgetEl.parentElement) !== null && _outerWidgetEl$parent !== void 0 && _outerWidgetEl$parent.matches(".b-float-root")) {
      clonedNode.style.zIndex = floatRootOwner.floatRootMaxZIndex + 1;
    }
  }
  updateContainerDrag(event) {
    var _context$dragging;
    const me = this, {
      context
    } = me;
    if (!context.started || !context.targetElement) {
      return;
    }
    const containerElement = DomHelper.getAncestor(context.targetElement, me.containers, "b-gridbase"), willLoseFocus = (_context$dragging = context.dragging) === null || _context$dragging === void 0 ? void 0 : _context$dragging.contains(DomHelper.getActiveElement(context.dragging));
    if (containerElement && DomHelper.isDescendant(context.element, containerElement)) {
      return;
    }
    if (willLoseFocus) {
      GlobalEvents$1.suspendFocusEvents();
    }
    if (containerElement && context.valid) {
      me.moveNextTo(containerElement, event);
    } else {
      me.revertPosition();
    }
    if (willLoseFocus) {
      GlobalEvents$1.resumeFocusEvents();
    }
    event.preventDefault();
  }
  finishContainerDrag(event) {
    const me = this, {
      context
    } = me, {
      dragging,
      dragProxy,
      valid,
      draggedTo,
      insertBefore,
      originalPosition
    } = context;
    if (dragging) {
      context.valid = valid && draggedTo && (dragging !== insertBefore || originalPosition.parent !== draggedTo);
      context.finalize = (valid2 = context.valid) => {
        if (!valid2 && me.context) {
          me.revertPosition();
        }
        dragging.classList.remove(me.dropPlaceholderCls);
        dragProxy.remove();
        me.reset();
      };
      context.async = false;
      me.trigger("drop", {
        context,
        event
      });
      if (!context.async) {
        context.finalize();
      }
    }
  }
  abortContainerDrag(invalid = false, event = null, silent = false) {
    const me = this, {
      context
    } = me;
    if (context.dragging) {
      context.dragging.classList.remove(me.dropPlaceholderCls);
      context.dragProxy.remove();
      me.revertPosition();
    }
    if (!silent) {
      me.trigger(invalid ? "drop" : "abort", {
        context,
        event
      });
    }
    me.reset();
  }
  updateContainerProxy(event) {
    const me = this, {
      context
    } = me, proxy = context.dragProxy;
    let newX = event.pageX - context.offsetX, newY = event.pageY - context.offsetY;
    if (typeof me.minX === "number") {
      newX = Math.max(me.minX, newX);
    }
    if (typeof me.maxX === "number") {
      newX = Math.min(me.maxX - proxy.offsetWidth, newX);
    }
    if (typeof me.minY === "number") {
      newY = Math.max(me.minY, newY);
    }
    if (typeof me.maxY === "number") {
      newY = Math.min(me.maxY - proxy.offsetHeight, newY);
    }
    if (me.lockX) {
      DomHelper.setTranslateY(proxy, newY);
    } else if (me.lockY) {
      DomHelper.setTranslateX(proxy, newX);
    } else {
      DomHelper.setTranslateXY(proxy, newX, newY);
    }
    let targetElement;
    if (event.type === "touchmove") {
      const touch = event.changedTouches[0];
      targetElement = DomHelper.elementFromPoint(touch.clientX, touch.clientY);
    } else {
      targetElement = event.target;
    }
    context.targetElement = targetElement;
  }
  moveNextTo(targetElement, event) {
    const {
      context
    } = this, dragElement = context.dragging, parent = targetElement.parentElement;
    if (targetElement !== dragElement) {
      const centerX = Rectangle.from(targetElement).center.x;
      if (this.isRTL && event.pageX > centerX || !this.isRTL && event.pageX < centerX) {
        parent.insertBefore(dragElement, targetElement);
        context.insertBefore = targetElement;
      } else {
        if (targetElement.nextElementSibling) {
          if (targetElement.nextElementSibling !== dragElement) {
            context.insertBefore = targetElement.nextElementSibling;
            parent.insertBefore(dragElement, targetElement.nextElementSibling);
          } else if (!context.insertBefore && dragElement.parentElement.lastElementChild !== dragElement) {
            context.insertBefore = targetElement.nextElementSibling;
          }
        } else {
          parent.appendChild(dragElement);
          context.insertBefore = null;
        }
      }
      context.draggedTo = parent;
    }
  }
  revertPosition() {
    const {
      context
    } = this, {
      dragging
    } = context, {
      parent,
      next
    } = context.originalPosition;
    if (next) {
      const isNoop = next.previousSibling === dragging || !next && dragging === parent.lastChild;
      if (!isNoop) {
        parent.insertBefore(dragging, next);
      }
    } else {
      parent.appendChild(dragging);
    }
    context.draggedTo = null;
  }
};
var noScroll = {
  pageXOffset: 0,
  pageYOffset: 0
};
var DragHelperTranslate = (Target) => class DragHelperTranslate extends Delayable(Target || Base$1) {
  static get $name() {
    return "DragHelperTranslate";
  }
  static get configurable() {
    return {
      positioning: null,
      skipUpdatingElement: null
    };
  }
  initTranslateDrag() {
    const me = this;
    if (!me.isElementDraggable && me.targetSelector) {
      me.isElementDraggable = (element) => element.closest(me.targetSelector);
    }
  }
  grabTranslateDrag(event) {
    const element = this.getTarget(event);
    if (element) {
      this.context = {
        valid: true,
        element,
        startPageX: event.pageX,
        startPageY: event.pageY,
        startClientX: event.clientX,
        startClientY: event.clientY
      };
      return true;
    }
    return false;
  }
  getTarget(event) {
    return event.target.closest(this.targetSelector);
  }
  getX(element) {
    if (this.positioning === "absolute") {
      return parseFloat(element.style.left, 10);
    } else {
      return DomHelper.getTranslateX(element);
    }
  }
  getY(element) {
    if (this.positioning === "absolute") {
      return parseFloat(element.style.top, 10);
    } else {
      return DomHelper.getTranslateY(element);
    }
  }
  getXY(element) {
    if (this.positioning === "absolute") {
      return [element.offsetLeft, element.offsetTop];
    } else {
      return DomHelper.getTranslateXY(element);
    }
  }
  setXY(element, x, y) {
    if (this.skipUpdatingElement) {
      return;
    }
    if (this.positioning === "absolute") {
      element.style.left = x + "px";
      element.style.top = y + "px";
    } else {
      DomHelper.setTranslateXY(element, x, y);
    }
  }
  startTranslateDrag(event) {
    const me = this, {
      context,
      outerElement,
      proxySelector
    } = me, dragWithin = me.dragWithin = me.dragWithin || me.cloneTarget && document.body;
    let element = context.dragProxy || context.element;
    const grabbed = element, grabbedParent = element.parentElement;
    if (me.cloneTarget) {
      const elementToClone = proxySelector ? element.querySelector(proxySelector) : element, {
        width,
        height,
        x: proxyX,
        y: proxyY
      } = Rectangle.from(elementToClone, dragWithin);
      element = me.createProxy(element);
      let x = proxyX, y = proxyY;
      if (me.autoSizeClonedTarget) {
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;
      }
      element.classList.add(me.dragProxyCls, me.draggingCls);
      element.classList.remove("b-hover", "b-selected", "b-focused");
      dragWithin.appendChild(element);
      if (!me.autoSizeClonedTarget || proxySelector) {
        const proxyRect = element.getBoundingClientRect(), {
          x: dragWithinX,
          y: dragWithinY
        } = dragWithin.getBoundingClientRect(), localX = event.clientX - dragWithinX, localY = event.clientY - dragWithinY + (dragWithin !== document.body ? document.body.getBoundingClientRect().y : 0);
        x = localX - proxyRect.width / 2;
        y = localY - proxyRect.height / 2;
        context.startPageX = event.pageX;
        context.startPageY = event.pageY;
      }
      me.setXY(element, x, y);
      grabbed.classList.add("b-drag-original");
      if (me.hideOriginalElement) {
        grabbed.classList.add("b-hidden");
      }
    }
    element.classList.add(me.draggingCls);
    Object.assign(context, {
      element,
      grabbed,
      grabbedParent,
      grabbedNextSibling: element.nextElementSibling,
      elementStartX: me.getX(element),
      elementStartY: me.getY(element),
      elementX: DomHelper.getOffsetX(element, dragWithin || outerElement),
      elementY: DomHelper.getOffsetY(element, dragWithin || outerElement),
      scrollX: 0,
      scrollY: 0,
      scrollManagerElementContainsDragProxy: !me.cloneTarget || dragWithin === outerElement
    });
    if (dragWithin) {
      context.parentElement = element.parentElement;
      if (dragWithin !== element.parentElement) {
        dragWithin.appendChild(element);
      }
      me.updateTranslateProxy(event);
    }
  }
  onDragStarted() {
    var _relatedElements;
    const me = this, {
      context
    } = me;
    let {
      relatedElements
    } = context;
    if (me.unifiedProxy) {
      context.element.classList.add("b-drag-main", "b-drag-unified-proxy");
    }
    if (((_relatedElements = relatedElements) === null || _relatedElements === void 0 ? void 0 : _relatedElements.length) > 0) {
      context.relatedElStartPos = [];
      context.relatedElDragFromPos = [];
      const {
        proxySelector
      } = me;
      let [elementStartX, elementStartY] = [context.elementStartX, context.elementStartY];
      context.originalRelatedElements = relatedElements;
      relatedElements = context.relatedElements = relatedElements.map((relatedEl, i) => {
        const proxyTemplateElement = proxySelector ? relatedEl.querySelector(proxySelector) : relatedEl, {
          x,
          y,
          width,
          height
        } = Rectangle.from(proxyTemplateElement, me.dragWithin), relatedElementToDrag = me.cloneTarget ? me.createProxy(relatedEl) : relatedEl;
        relatedElementToDrag.classList.add(me.draggingCls);
        relatedElementToDrag.classList.remove("b-hover", "b-selected", "b-focused");
        if (me.cloneTarget) {
          me.setXY(relatedElementToDrag, x, y);
          me.dragWithin.appendChild(relatedElementToDrag);
          relatedElementToDrag.classList.add(me.dragProxyCls);
          if (me.autoSizeClonedTarget) {
            relatedElementToDrag.style.width = `${width}px`;
            relatedElementToDrag.style.height = `${height}px`;
          }
          if (me.hideOriginalElement) {
            relatedEl.classList.add("b-hidden");
          }
          relatedEl.classList.add("b-drag-original");
        }
        context.relatedElStartPos[i] = context.relatedElDragFromPos[i] = me.getXY(relatedElementToDrag);
        if (me.unifiedProxy) {
          relatedElementToDrag.classList.add("b-drag-unified-animation", "b-drag-unified-proxy");
          elementStartX += me.unifiedOffset;
          elementStartY += me.unifiedOffset;
          me.setXY(relatedElementToDrag, elementStartX, elementStartY);
          context.relatedElDragFromPos[i] = [elementStartX, elementStartY];
          relatedElementToDrag.style.zIndex = 100 - i;
        }
        return relatedElementToDrag;
      });
      if (me.unifiedProxy && relatedElements && relatedElements.length > 0) {
        EventHelper.onTransitionEnd({
          element: relatedElements[0],
          property: "transform",
          handler() {
            relatedElements.forEach((el) => el.classList.remove("b-drag-unified-animation"));
          },
          thisObj: me,
          once: true
        });
      }
    }
  }
  applyConstraints(element, x, y) {
    const me = this, {
      constrain,
      dragWithin
    } = me, {
      pageXOffset,
      pageYOffset
    } = dragWithin === document.body ? globalThis : noScroll;
    if (dragWithin && constrain) {
      if (x < 0) {
        x = 0;
      }
      if (x + element.offsetWidth > dragWithin.scrollWidth) {
        x = dragWithin.scrollWidth - element.offsetWidth;
      }
      if (y < 0) {
        y = 0;
      }
      if (y + element.offsetHeight > dragWithin.scrollHeight) {
        y = dragWithin.scrollHeight - element.offsetHeight;
      }
    }
    if (typeof me.minX === "number") {
      x = Math.max(me.minX + pageXOffset, x);
    }
    if (typeof me.maxX === "number") {
      x = Math.min(me.maxX + pageXOffset, x);
    }
    if (typeof me.minY === "number") {
      y = Math.max(me.minY + pageYOffset, y);
    }
    if (typeof me.maxY === "number") {
      y = Math.min(me.maxY + pageYOffset, y);
    }
    return {
      constrainedX: x,
      constrainedY: y
    };
  }
  updateTranslateProxy(event, scrollManagerConfig) {
    const me = this, {
      lockX,
      lockY,
      context
    } = me, element = context.dragProxy || context.element, {
      relatedElements,
      relatedElDragFromPos
    } = context;
    if (context.scrollManagerElementContainsDragProxy && scrollManagerConfig) {
      context.scrollX = scrollManagerConfig.getRelativeLeftScroll(element);
      context.scrollY = scrollManagerConfig.getRelativeTopScroll(element);
    }
    context.pageX = event.pageX;
    context.pageY = event.pageY;
    context.clientX = event.clientX;
    context.clientY = event.clientY;
    let newX = context.elementStartX + event.pageX - context.startPageX + context.scrollX, newY = context.elementStartY + event.pageY - context.startPageY + context.scrollY;
    if (me.snapCoordinates) {
      const snapped = me.snapCoordinates({
        element,
        newX,
        newY
      });
      newX = snapped.x;
      newY = snapped.y;
    }
    const {
      constrainedX,
      constrainedY
    } = me.applyConstraints(element, newX, newY);
    if (context.started || constrainedX !== newX || constrainedY !== newY) {
      me.setXY(element, lockX ? void 0 : constrainedX, lockY ? void 0 : constrainedY);
    }
    if (relatedElements) {
      const deltaX = lockX ? 0 : constrainedX - context.elementStartX, deltaY = lockY ? 0 : constrainedY - context.elementStartY;
      relatedElements.forEach((r, i) => {
        const [x, y] = relatedElDragFromPos[i];
        me.setXY(r, x + deltaX, y + deltaY);
      });
    }
    context.newX = constrainedX;
    context.newY = constrainedY;
  }
  async finishTranslateDrag(event) {
    const me = this, context = me.context, {
      target
    } = event, xChanged = !me.lockX && Math.round(context.newX) !== Math.round(context.elementStartX), yChanged = !me.lockY && Math.round(context.newY) !== Math.round(context.elementStartY), element = context.dragProxy || context.element, {
      relatedElements
    } = context;
    if (!me.ignoreSamePositionDrop || xChanged || yChanged) {
      if (context.valid === false) {
        await me.abortTranslateDrag(true, event);
      } else {
        const targetRect = !me.allowDropOutside && Rectangle.from(me.dragWithin || me.outerElement);
        if (targetRect && (typeof me.minX !== "number" && me.minX !== true && event.pageX < targetRect.left || typeof me.maxX !== "number" && me.maxX !== true && event.pageX > targetRect.right || typeof me.minY !== "number" && me.minY !== true && event.pageY < targetRect.top || typeof me.maxY !== "number" && me.maxY !== true && event.pageY > targetRect.bottom)) {
          context.valid = false;
          await me.abortTranslateDrag(true, event);
        } else {
          context.finalize = async (valid = context.valid) => {
            if (context.finalized) {
              console.warn("DragHelper: Finalizing already finalized drag");
              return;
            }
            context.finalized = true;
            if (!valid && me.context) {
              await me.abortTranslateDrag(true, null, true);
            }
            if (!me.isDestroyed) {
              me.trigger("dropFinalized", {
                context,
                event,
                target
              });
              me.reset();
            }
            if (!me.cloneTarget && element.parentElement !== context.grabbedParent) {
              [element, ...relatedElements || []].forEach((el) => el.style.transform = "");
            }
          };
          context.async = false;
          await me.trigger("drop", {
            context,
            event,
            target
          });
          if (!context.async) {
            await context.finalize();
          }
        }
      }
    } else {
      me.abortTranslateDrag(false, event);
    }
  }
  async abortTranslateDrag(invalid = false, event = null, silent = false) {
    var _me$scrollManager, _me$context;
    const me = this, {
      cloneTarget,
      context,
      proxySelector,
      dragWithin,
      draggingCls
    } = me, {
      relatedElements,
      relatedElStartPos,
      grabbed
    } = context, element = context.dragProxy || context.element;
    (_me$scrollManager = me.scrollManager) === null || _me$scrollManager === void 0 ? void 0 : _me$scrollManager.stopMonitoring();
    if (context.aborted) {
      console.warn("DragHelper: Aborting already aborted drag");
      return;
    }
    let {
      elementStartX,
      elementStartY
    } = context;
    if (element && context.started) {
      if (!cloneTarget && dragWithin && dragWithin !== context.grabbedParent) {
        context.grabbedParent.insertBefore(element, context.grabbedNextSibling);
      }
      if (cloneTarget) {
        if (proxySelector) {
          const animateTo = grabbed.querySelector(proxySelector) || grabbed, {
            x,
            y
          } = Rectangle.from(animateTo);
          elementStartX = x;
          elementStartY = y;
        }
      }
      element.classList.add("b-aborting");
      me.setXY(element, elementStartX, elementStartY);
      relatedElements === null || relatedElements === void 0 ? void 0 : relatedElements.forEach((element2, i) => {
        element2.classList.remove(draggingCls);
        element2.classList.add("b-aborting");
        me.setXY(element2, relatedElStartPos[i][0], relatedElStartPos[i][1]);
      });
      if (!silent) {
        me.trigger(invalid ? "drop" : "abort", {
          context,
          event
        });
      }
      if (!DomHelper.isOrphaned(element) && !me.isDestroying) {
        await EventHelper.waitForTransitionEnd({
          element,
          property: DomHelper.getPropertyTransitionDuration(element, "transform") ? "transform" : "all",
          thisObj: me,
          once: true,
          runOnDestroy: true
        });
      }
      if (!me.isDestroyed) {
        me.trigger("abortFinalized", {
          context,
          event
        });
      }
    }
    if ((_me$context = me.context) !== null && _me$context !== void 0 && _me$context.started) {
      me.reset();
    }
  }
  cleanUp() {
    const me = this, {
      context,
      cloneTarget,
      draggingCls,
      dragProxyCls
    } = me, element = context.dragProxy || context.element, {
      relatedElements,
      originalRelatedElements,
      grabbed
    } = context, removeClonedProxies = cloneTarget && (me.removeProxyAfterDrop || !context.valid), cssClassesToRemove = [draggingCls, "b-aborting", dragProxyCls, "b-drag-main", "b-drag-unified-proxy"];
    element.classList.remove(...cssClassesToRemove);
    if (removeClonedProxies) {
      element.remove();
    }
    relatedElements === null || relatedElements === void 0 ? void 0 : relatedElements.forEach((element2) => {
      if (removeClonedProxies) {
        element2.remove();
      } else {
        element2.classList.remove(...cssClassesToRemove);
      }
    });
    grabbed.classList.remove("b-drag-original", "b-hidden");
    originalRelatedElements === null || originalRelatedElements === void 0 ? void 0 : originalRelatedElements.forEach((element2) => element2.classList.remove("b-hidden", "b-drag-original"));
  }
};
var rootElementListeners = {
  move: "onMouseMove",
  up: "onMouseUp",
  docclick: "onDocumentClick",
  touchstart: "onTouchStart",
  touchmove: "onTouchMove",
  touchend: "onTouchEnd",
  keydown: "onKeyDown"
};
var DragHelper = class extends Base$1.mixin(Events, DragHelperContainer, DragHelperTranslate) {
  static get defaultConfig() {
    return {
      dragProxyCls: "b-drag-proxy",
      invalidCls: "b-drag-invalid",
      draggingCls: "b-dragging",
      dropPlaceholderCls: "b-drop-placeholder",
      dragThreshold: 5,
      outerElement: document.body,
      dragWithin: null,
      unifiedProxy: null,
      monitoringConfig: null,
      constrain: true,
      minX: null,
      maxX: null,
      minY: null,
      maxY: null,
      mode: "translateXY",
      isElementDraggable: null,
      targetSelector: null,
      dropTargetSelector: null,
      dropTargetCls: null,
      proxySelector: null,
      cloneTarget: false,
      autoSizeClonedTarget: true,
      hideOriginalElement: false,
      containers: null,
      ignoreSelector: null,
      startEvent: null,
      lockX: false,
      lockY: false,
      touchStartDelay: 300,
      scrollManager: null,
      snapCoordinates: null,
      unifiedOffset: 5,
      removeProxyAfterDrop: true,
      clickSwallowDuration: 50,
      ignoreSamePositionDrop: true,
      allowDropOutside: null,
      floatRootOwner: null,
      mouseMoveListenerElement: document,
      testConfig: {
        transitionDuration: 10,
        clickSwallowDuration: 50,
        touchStartDelay: 100
      },
      rtlSource: null,
      createProxy: null
    };
  }
  construct(config) {
    const me = this;
    super.construct(config);
    me.initListeners();
    if (me.isContainerDrag) {
      me.initContainerDrag();
    } else {
      me.initTranslateDrag();
    }
    me.onScrollManagerScrollCallback = me.onScrollManagerScrollCallback.bind(me);
  }
  doDestroy() {
    this.reset(true);
    super.doDestroy();
  }
  initListeners() {
    const me = this, {
      outerElement
    } = me, dragStartListeners = {
      element: outerElement,
      pointerdown: "onPointerDown",
      thisObj: me
    };
    me.mouseMoveListenerElement = me.getMouseMoveListenerTarget(outerElement);
    EventHelper.on(dragStartListeners);
  }
  getMouseMoveListenerTarget(element) {
    const root2 = element.getRootNode();
    let result = this.mouseMoveListenerElement;
    if (root2.nodeType === Node.DOCUMENT_FRAGMENT_NODE && root2.mode === "closed") {
      result = element.closest(".b-outer") || result;
    }
    return result;
  }
  get isRTL() {
    var _this$rtlSource;
    return Boolean((_this$rtlSource = this.rtlSource) === null || _this$rtlSource === void 0 ? void 0 : _this$rtlSource.rtl);
  }
  onPointerDown(event) {
    const me = this;
    if (event.button !== 0 || !DomHelper.isVisible(event.target) || me.context) {
      return;
    }
    if (me.isElementDraggable && !me.isElementDraggable(event.target, event)) {
      return;
    }
    me.startEvent = event;
    const handled = me.isContainerDrag ? me.grabContainerDrag(event) : me.grabTranslateDrag(event);
    if (handled) {
      me.blurDetacher = EventHelper.on({
        element: globalThis,
        blur: me.onWindowBlur,
        thisObj: me
      });
      const dragListeners = {
        element: me.mouseMoveListenerElement,
        thisObj: me,
        capture: true,
        keydown: rootElementListeners.keydown
      };
      if (event.pointerType === "touch") {
        me.touchStartTimer = me.setTimeout(() => me.touchStartTimer = null, me.touchStartDelay, "touchStartDelay");
        dragListeners.touchmove = {
          handler: rootElementListeners.touchmove,
          passive: false
        };
        dragListeners.touchend = dragListeners.pointerup = rootElementListeners.touchend;
      } else {
        dragListeners.pointermove = rootElementListeners.move;
        dragListeners.pointerup = rootElementListeners.up;
      }
      me.dragListenersDetacher = EventHelper.on(dragListeners);
      if (me.dragWithin && me.dragWithin !== me.outerElement && me.outerElement.contains(me.dragWithin)) {
        const box = Rectangle.from(me.dragWithin, me.outerElement);
        me.minY = box.top;
        me.maxY = box.bottom;
        me.minX = box.left;
        me.maxX = box.right;
      }
    }
  }
  internalMove(event) {
    var _event$target;
    if (event.scrollInitiated) {
      return;
    }
    const me = this, {
      context
    } = me, distance = EventHelper.getDistanceBetween(me.startEvent, event), abortTouchDrag = me.touchStartTimer && distance > me.dragThreshold;
    if (abortTouchDrag) {
      me.abort(true);
      return;
    }
    if (!me.touchStartTimer && context !== null && context !== void 0 && context.element && (context.started || distance >= me.dragThreshold) && ((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.nodeType) === Node.ELEMENT_NODE) {
      if (!context.started) {
        var _me$scrollManager, _me$onDragStarted;
        if (me.trigger("beforeDragStart", {
          context,
          event
        }) === false) {
          return me.abort();
        }
        if (me.isContainerDrag) {
          me.startContainerDrag(event);
        } else {
          me.startTranslateDrag(event);
        }
        context.started = true;
        (_me$scrollManager = me.scrollManager) === null || _me$scrollManager === void 0 ? void 0 : _me$scrollManager.startMonitoring(ObjectHelper.merge({
          scrollables: [{
            element: me.dragWithin || me.outerElement
          }],
          callback: me.onScrollManagerScrollCallback
        }, me.monitoringConfig));
        context.outermostEl = DomHelper.getOutermostElement(event.target);
        context.outermostEl.classList.add("b-draghelper-active");
        if (me.dropTargetSelector && me.dropTargetCls) {
          DomHelper.getRootElement(me.outerElement).querySelectorAll(me.dropTargetSelector).forEach((el) => el.classList.add(me.dropTargetCls));
        }
        me.trigger("dragStart", {
          context,
          event
        });
        (_me$onDragStarted = me.onDragStarted) === null || _me$onDragStarted === void 0 ? void 0 : _me$onDragStarted.call(me);
        me.trigger("afterDragStart", {
          context,
          event
        });
      }
      me.update(event);
      if (event.type === "touchmove") {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    }
  }
  onScrollManagerScrollCallback(config) {
    var _this$context;
    const {
      lastMouseMoveEvent
    } = this;
    if ((_this$context = this.context) !== null && _this$context !== void 0 && _this$context.element && lastMouseMoveEvent) {
      lastMouseMoveEvent.isScroll = true;
      this.update(lastMouseMoveEvent, config);
    }
  }
  onTouchMove(event) {
    this.internalMove(event);
  }
  onMouseMove(event) {
    this.internalMove(event);
  }
  update(event, scrollManagerConfig) {
    const me = this, {
      context
    } = me, scrollingPageElement = document.scrollingElement || document.body;
    let target = me.getMouseMoveEventTarget(event);
    if (event.type === "touchmove") {
      const touch = event.changedTouches[0];
      target = DomHelper.elementFromPoint(touch.clientX + scrollingPageElement.scrollLeft, touch.clientY + scrollingPageElement.scrollTop);
    }
    context.target = target;
    let internallyValid = me.allowDropOutside || !me.dragWithin || me.dragWithin.contains(event.target);
    if (internallyValid && me.dropTargetSelector) {
      var _target;
      internallyValid = internallyValid && Boolean((_target = target) === null || _target === void 0 ? void 0 : _target.closest(me.dropTargetSelector));
    }
    if (me.isContainerDrag) {
      me.updateContainerProxy(event, scrollManagerConfig);
    } else {
      me.updateTranslateProxy(event, scrollManagerConfig);
    }
    context.valid = internallyValid;
    me.trigger("drag", {
      context,
      event
    });
    if (me.isContainerDrag) {
      me.updateContainerDrag(event, scrollManagerConfig);
    }
    context.valid = context.valid && internallyValid;
    for (const element of me.draggedElements) {
      element.classList.toggle(me.invalidCls, !context.valid);
    }
    if (event) {
      me.lastMouseMoveEvent = event;
    }
  }
  get draggedElements() {
    var _context$relatedEleme;
    const {
      context
    } = this;
    return [context.dragProxy || context.element, ...(_context$relatedEleme = context.relatedElements) !== null && _context$relatedEleme !== void 0 ? _context$relatedEleme : []];
  }
  async abort(silent = false) {
    var _me$scrollManager2, _me$scrollManager2$st;
    const me = this, {
      context
    } = me;
    (_me$scrollManager2 = me.scrollManager) === null || _me$scrollManager2 === void 0 ? void 0 : (_me$scrollManager2$st = _me$scrollManager2.stopMonitoring) === null || _me$scrollManager2$st === void 0 ? void 0 : _me$scrollManager2$st.call(_me$scrollManager2);
    me.removeListeners();
    if (context !== null && context !== void 0 && context.started && !context.aborted) {
      context.element.getBoundingClientRect();
      context.valid = false;
      if (me.isContainerDrag) {
        me.abortContainerDrag(void 0, void 0, silent);
      } else {
        me.abortTranslateDrag(void 0, void 0, silent);
      }
      context.aborted = true;
    } else {
      me.reset(true);
    }
  }
  removeListeners() {
    var _this$dragListenersDe, _this$blurDetacher;
    (_this$dragListenersDe = this.dragListenersDetacher) === null || _this$dragListenersDe === void 0 ? void 0 : _this$dragListenersDe.call(this);
    (_this$blurDetacher = this.blurDetacher) === null || _this$blurDetacher === void 0 ? void 0 : _this$blurDetacher.call(this);
  }
  reset(silent) {
    const me = this, {
      context
    } = me;
    if (context !== null && context !== void 0 && context.started) {
      for (const element of me.draggedElements) {
        element.classList.remove(me.invalidCls);
      }
      context.outermostEl.classList.remove("b-draghelper-active");
      if (me.isContainerDrag) {
        context.dragProxy.remove();
      } else {
        me.cleanUp();
      }
      if (me.dropTargetSelector && me.dropTargetCls) {
        DomHelper.getRootElement(me.outerElement).querySelectorAll(me.dropTargetSelector).forEach((el) => el.classList.remove(me.dropTargetCls));
      }
    }
    me.removeListeners();
    if (!silent) {
      me.trigger("reset");
    }
    me.context = me.lastMouseMoveEvent = null;
  }
  onTouchEnd(event) {
    this.onMouseUp(event);
  }
  onDocumentClick(event) {
    event.stopPropagation();
  }
  onMouseUp(event) {
    const me = this, {
      context
    } = me;
    me.removeListeners();
    if (context) {
      var _me$scrollManager3;
      (_me$scrollManager3 = me.scrollManager) === null || _me$scrollManager3 === void 0 ? void 0 : _me$scrollManager3.stopMonitoring();
      if (context.started) {
        event.stopPropagation();
        context.finalizing = true;
        if (me.isContainerDrag) {
          me.finishContainerDrag(event);
        } else {
          me.finishTranslateDrag(event);
        }
        EventHelper.on({
          element: document,
          thisObj: me,
          click: rootElementListeners.docclick,
          capture: true,
          expires: me.clickSwallowDuration,
          once: true
        });
      } else {
        me.reset(true);
      }
    }
  }
  onKeyDown(event) {
    var _this$context2;
    if ((_this$context2 = this.context) !== null && _this$context2 !== void 0 && _this$context2.started && event.key === "Escape") {
      event.stopImmediatePropagation();
      this.abort();
    }
  }
  onWindowBlur() {
    if (this.context && !this.context.finalizing) {
      this.abort();
    }
  }
  createProxy(element) {
    if (this.proxySelector) {
      element = element.querySelector(this.proxySelector) || element;
    }
    const proxy = element.cloneNode(true);
    proxy.removeAttribute("id");
    return proxy;
  }
  get isContainerDrag() {
    return this.mode === "container";
  }
  async animateProxyTo(targetElement, alignSpec = {
    align: "c-c"
  }) {
    const {
      context,
      draggedElements
    } = this, {
      element
    } = context, targetRect = targetElement.isRectangle ? targetElement : Rectangle.from(targetElement);
    draggedElements.forEach((el) => {
      el.classList.add("b-drag-final-transition");
      DomHelper.alignTo(el, targetRect, alignSpec);
    });
    await EventHelper.waitForTransitionEnd({
      element,
      property: "all",
      thisObj: this,
      once: true
    });
    draggedElements.forEach((el) => el.classList.remove("b-drag-final-transition"));
  }
  get isDragging() {
    var _this$context3;
    return Boolean((_this$context3 = this.context) === null || _this$context3 === void 0 ? void 0 : _this$context3.started);
  }
  getMouseMoveEventTarget(event) {
    return !event.isScroll ? event.target : DomHelper.elementFromPoint(event.clientX, event.clientY);
  }
};
DragHelper._$name = "DragHelper";
var documentListeners = {
  down: "onMouseDown",
  move: "onMouseMove",
  up: "onMouseUp",
  docclick: "onDocumentClick",
  touchstart: {
    handler: "onTouchStart",
    passive: false
  },
  touchmove: "onTouchMove",
  touchend: "onTouchEnd",
  keydown: "onKeyDown"
};
var ResizeHelper = class extends Events(Base$1) {
  static get defaultConfig() {
    return {
      resizingCls: "b-resizing",
      dragThreshold: 5,
      handleSize: 10,
      dynamicHandleSize: null,
      reservedSpace: 10,
      touchHandleSize: 30,
      minWidth: 1,
      maxWidth: 0,
      minHeight: 1,
      maxHeight: 0,
      outerElement: document.body,
      scroller: null,
      allowResize: null,
      dragWithin: null,
      isElementResizable: null,
      targetSelector: null,
      leftHandle: true,
      rightHandle: true,
      topHandle: true,
      bottomHandle: true,
      handleSelector: null,
      handleContainerSelector: null,
      startEvent: null,
      grab: null,
      invalidCls: "b-resize-invalid",
      handleVisibilityThreshold: null,
      skipTranslate: false,
      direction: "horizontal",
      clickSwallowDuration: 50,
      rtlSource: null
    };
  }
  construct(config) {
    const me = this;
    super.construct(config);
    if (!me.handleSelector && !BrowserHelper.isHoverableDevice) {
      me.handleSize = me.touchHandleSize;
    }
    me.handleVisibilityThreshold = me.handleVisibilityThreshold || 2 * me.handleSize;
    me.initListeners();
    me.initResize();
  }
  doDestroy() {
    this.abort(true);
    super.doDestroy();
  }
  updateSkipUpdatingElement(skip) {
    if (skip) {
      this.skipTranslate = true;
    }
  }
  initResize() {
    const me = this;
    if (!me.isElementResizable && me.targetSelector) {
      me.isElementResizable = (element) => element.closest(me.targetSelector);
    }
    if (me.grab) {
      const {
        edge,
        element,
        event
      } = me.grab;
      me.startEvent = event;
      const cursorOffset = me.getCursorOffsetToElementEdge(event, element, edge);
      me.context = {
        element,
        edge,
        valid: true,
        async: false,
        elementStartX: DomHelper.getTranslateX(element) || element.offsetLeft,
        elementStartY: DomHelper.getTranslateY(element) || element.offsetTop,
        newX: DomHelper.getTranslateX(element) || element.offsetLeft,
        newY: DomHelper.getTranslateY(element) || element.offsetTop,
        elementWidth: element.offsetWidth,
        elementHeight: element.offsetHeight,
        cursorOffset,
        startX: event.clientX + cursorOffset.x + me.scrollLeft,
        startY: event.clientY + cursorOffset.y + me.scrollTop,
        finalize: () => {
          var _me$reset;
          return (_me$reset = me.reset) === null || _me$reset === void 0 ? void 0 : _me$reset.call(me);
        }
      };
      element.classList.add(me.resizingCls);
      me.internalStartResize(me.isTouch);
    }
  }
  initListeners() {
    const me = this, dragStartListeners = {
      element: me.outerElement,
      mousedown: documentListeners.down,
      touchstart: documentListeners.touchstart,
      thisObj: me
    };
    if (!me.handleSelector && BrowserHelper.isHoverableDevice) {
      dragStartListeners.mousemove = {
        handler: documentListeners.move,
        delegate: me.targetSelector
      };
      dragStartListeners.mouseleave = {
        handler: "onMouseLeaveTarget",
        delegate: me.targetSelector,
        capture: true
      };
    }
    EventHelper.on(dragStartListeners);
  }
  get isRTL() {
    var _this$rtlSource;
    return Boolean((_this$rtlSource = this.rtlSource) === null || _this$rtlSource === void 0 ? void 0 : _this$rtlSource.rtl);
  }
  get scrollLeft() {
    if (this.scroller) {
      return this.scroller.x;
    }
    return this.outerElement.scrollLeft;
  }
  get scrollTop() {
    if (this.scroller) {
      return this.scroller.y;
    }
    return this.outerElement.scrollTop;
  }
  internalStartResize(isTouch) {
    const dragListeners = {
      element: document,
      keydown: documentListeners.keydown,
      thisObj: this
    };
    if (isTouch) {
      dragListeners.touchmove = documentListeners.touchmove;
      dragListeners.touchend = dragListeners.pointerup = documentListeners.touchend;
    } else {
      dragListeners.mousemove = documentListeners.move;
      dragListeners.mouseup = documentListeners.up;
    }
    this.removeDragListeners = EventHelper.on(dragListeners);
  }
  removeDragListeners() {
  }
  reset() {
    var _this$removeDragListe;
    (_this$removeDragListe = this.removeDragListeners) === null || _this$removeDragListe === void 0 ? void 0 : _this$removeDragListe.call(this);
    this.context = null;
    this.trigger("reset");
  }
  canResize(element, event) {
    return !this.isElementResizable || this.isElementResizable(element, event);
  }
  onPointerDown(isTouch, event) {
    const me = this;
    me.startEvent = event;
    if (me.canResize(event.target, event) && me.grabResizeHandle(isTouch, event)) {
      event.stopImmediatePropagation();
      if (event.type === "touchstart") {
        event.preventDefault();
      }
      me.internalStartResize(isTouch);
    }
  }
  onTouchStart(event) {
    if (event.touches.length > 1) {
      return;
    }
    this.onPointerDown(true, event);
  }
  onMouseDown(event) {
    if (event.button !== 0) {
      return;
    }
    this.onPointerDown(false, event);
  }
  internalMove(isTouch, event) {
    const me = this, {
      context,
      direction
    } = me;
    if (context !== null && context !== void 0 && context.element && (context.started || EventHelper.getDistanceBetween(me.startEvent, event) >= me.dragThreshold)) {
      if (!context.started) {
        var _me$scrollManager;
        (_me$scrollManager = me.scrollManager) === null || _me$scrollManager === void 0 ? void 0 : _me$scrollManager.startMonitoring(ObjectHelper.merge({
          scrollables: [{
            element: me.dragWithin || me.outerElement,
            direction
          }],
          callback: (config) => {
            var _me$context;
            return ((_me$context = me.context) === null || _me$context === void 0 ? void 0 : _me$context.element) && me.lastMouseMoveEvent && me.update(me.lastMouseMoveEvent, config);
          }
        }, me.monitoringConfig));
        me.trigger("resizeStart", {
          context,
          event
        });
        context.started = true;
      }
      me.update(event);
    } else if (!isTouch && !me.handleSelector) {
      me.checkResizeHandles(event);
    }
  }
  onTouchMove(event) {
    this.internalMove(true, event);
  }
  onMouseMove(event) {
    this.internalMove(false, event);
  }
  onPointerUp(isTouch, event) {
    var _me$removeDragListene;
    const me = this, context = me.context;
    (_me$removeDragListene = me.removeDragListeners) === null || _me$removeDragListene === void 0 ? void 0 : _me$removeDragListene.call(me);
    if (context) {
      var _me$scrollManager2;
      (_me$scrollManager2 = me.scrollManager) === null || _me$scrollManager2 === void 0 ? void 0 : _me$scrollManager2.stopMonitoring();
      if (context.started) {
        EventHelper.on({
          element: document,
          thisObj: me,
          click: documentListeners.docclick,
          expires: me.clickSwallowDuration,
          capture: true,
          once: true
        });
      }
      me.finishResize(event);
    } else {
      var _me$reset2;
      (_me$reset2 = me.reset) === null || _me$reset2 === void 0 ? void 0 : _me$reset2.call(me);
    }
  }
  onTouchEnd(event) {
    this.onPointerUp(true, event);
  }
  onMouseUp(event) {
    this.onPointerUp(false, event);
  }
  onDocumentClick(event) {
    event.stopPropagation();
  }
  onKeyDown(event) {
    if (event.key === "Escape") {
      this.abort();
    }
  }
  update(event) {
    const me = this, context = me.context, parentRectangle = Rectangle.from(me.outerElement);
    context.currentX = Math.max(Math.min(event.clientX + context.cursorOffset.x, parentRectangle.right), parentRectangle.x) + me.scrollLeft;
    context.currentY = Math.max(Math.min(event.clientY + context.cursorOffset.y, parentRectangle.bottom), parentRectangle.y) + me.scrollTop;
    if (event) {
      if (me.updateResize(event)) {
        me.trigger("resizing", {
          context,
          event
        });
        context.element.classList.toggle(me.invalidCls, context.valid === false);
      }
      me.lastMouseMoveEvent = event;
    }
  }
  abort(silent = false) {
    var _me$scrollManager3, _me$scrollManager3$st;
    const me = this;
    (_me$scrollManager3 = me.scrollManager) === null || _me$scrollManager3 === void 0 ? void 0 : (_me$scrollManager3$st = _me$scrollManager3.stopMonitoring) === null || _me$scrollManager3$st === void 0 ? void 0 : _me$scrollManager3$st.call(_me$scrollManager3);
    if (me.context) {
      me.abortResize(null, silent);
    } else if (!me.isDestroyed) {
      me.reset();
    }
  }
  grabResizeHandle(isTouch, event) {
    const me = this;
    if (me.allowResize && !me.allowResize(event.target, event)) {
      return false;
    }
    const handleSelector = me.handleSelector, coordsFrom = event.type === "touchstart" ? event.changedTouches[0] : event, clientX = coordsFrom.clientX, clientY = coordsFrom.clientY, element = me.targetSelector ? event.target.closest(me.targetSelector) : event.target;
    if (element) {
      let edge;
      if (handleSelector) {
        if (event.target.matches(handleSelector)) {
          if (me.direction === "horizontal") {
            if (event.pageX < DomHelper.getPageX(element) + element.offsetWidth / 2) {
              edge = me.isRTL ? "right" : "left";
            } else {
              edge = me.isRTL ? "left" : "right";
            }
          } else {
            if (event.pageY < DomHelper.getPageY(element) + element.offsetHeight / 2) {
              edge = "top";
            } else {
              edge = "bottom";
            }
          }
        } else {
          return false;
        }
      } else {
        if (me.direction === "horizontal") {
          if (me.overLeftHandle(event, element)) {
            edge = me.isRTL ? "right" : "left";
          } else if (me.overRightHandle(event, element)) {
            edge = me.isRTL ? "left" : "right";
          }
        } else {
          if (me.overTopHandle(event, element)) {
            edge = "top";
          } else if (me.overBottomHandle(event, element)) {
            edge = "bottom";
          }
        }
        if (!edge) {
          me.context = null;
          return false;
        }
      }
      if (event.type === "touchstart") {
        event.preventDefault();
      }
      const cursorOffset = me.getCursorOffsetToElementEdge(coordsFrom, element, edge);
      if (me.trigger("beforeResizeStart", {
        element,
        event
      }) !== false) {
        me.context = {
          element,
          edge,
          isTouch,
          valid: true,
          async: false,
          direction: me.direction,
          elementStartX: DomHelper.getTranslateX(element) || element.offsetLeft,
          elementStartY: DomHelper.getTranslateY(element) || element.offsetTop,
          newX: DomHelper.getTranslateX(element) || element.offsetLeft,
          newY: DomHelper.getTranslateY(element) || element.offsetTop,
          elementWidth: element.offsetWidth,
          elementHeight: element.offsetHeight,
          cursorOffset,
          startX: clientX + cursorOffset.x + me.scrollLeft,
          startY: clientY + cursorOffset.y + me.scrollTop,
          finalize: () => {
            var _me$reset3;
            return (_me$reset3 = me.reset) === null || _me$reset3 === void 0 ? void 0 : _me$reset3.call(me);
          }
        };
        element.classList.add(me.resizingCls);
        return true;
      }
    }
    return false;
  }
  getCursorOffsetToElementEdge(event, element, edge) {
    const rectEl = Rectangle.from(element);
    let x = 0, y = 0;
    switch (edge) {
      case "left":
        x = rectEl.x - (this.isRTL ? rectEl.width : 0) - event.clientX;
        break;
      case "right":
        x = rectEl.x + (this.isRTL ? 0 : rectEl.width) - event.clientX;
        break;
      case "top":
        y = rectEl.y - event.clientY;
        break;
      case "bottom":
        y = rectEl.y + rectEl.height - event.clientY;
        break;
    }
    return {
      x,
      y
    };
  }
  checkResizeHandles(event) {
    const me = this, target = me.targetSelector ? event.target.closest(me.targetSelector) : event.target;
    if (target && (!me.allowResize || me.allowResize(event.target, event))) {
      me.currentElement = me.handleContainerSelector ? event.target.closest(me.handleContainerSelector) : event.target;
      if (me.currentElement) {
        let over;
        if (me.direction === "horizontal") {
          over = me.overLeftHandle(event, target) || me.overRightHandle(event, target);
        } else {
          over = me.overTopHandle(event, target) || me.overBottomHandle(event, target);
        }
        if (over) {
          me.highlightHandle();
        } else {
          me.unHighlightHandle();
        }
      }
    } else if (me.currentElement) {
      me.unHighlightHandle();
    }
  }
  onMouseLeaveTarget(event) {
    const me = this;
    me.currentElement = me.handleContainerSelector ? event.target.closest(me.handleContainerSelector) : event.target;
    if (me.currentElement) {
      me.unHighlightHandle();
    }
  }
  updateResize(event) {
    const me = this, {
      context,
      allowEdgeSwitch,
      skipTranslate,
      skipUpdatingElement
    } = me;
    let updated;
    if (allowEdgeSwitch) {
      if (me.direction === "horizontal") {
        context.edge = context.currentX > context.startX ? "right" : "left";
      } else {
        context.edge = context.currentY > context.startY ? "bottom" : "top";
      }
    }
    const {
      element,
      elementStartX,
      elementStartY,
      elementWidth,
      elementHeight,
      edge
    } = context, {
      style
    } = element, deltaX = context.currentX - context.startX, deltaY = context.currentY - context.startY, minWidth = DomHelper.getExtremalSizePX(element, "minWidth") || me.minWidth, maxWidth = DomHelper.getExtremalSizePX(element, "maxWidth") || me.maxWidth, minHeight = DomHelper.getExtremalSizePX(element, "minHeight") || me.minHeight, maxHeight = DomHelper.getExtremalSizePX(element, "maxHeight") || me.maxHeight, sign = edge === "right" && !me.isRTL || edge === "bottom" ? 1 : -1, newWidth = elementWidth + deltaX * sign, newHeight = elementHeight + deltaY * sign;
    let width = Math.max(minWidth, newWidth), height = Math.max(minHeight, newHeight);
    if (maxWidth > 0) {
      width = Math.min(width, maxWidth);
    }
    if (maxHeight > 0) {
      height = Math.min(height, maxHeight);
    }
    if (style.flex) {
      style.flex = "";
    }
    if (me.direction === "horizontal" && elementWidth !== width) {
      if (!skipUpdatingElement) {
        style.width = Math.abs(width) + "px";
      }
      context.newWidth = width;
      if (edge === "left" || width < 0) {
        const newX = Math.max(Math.min(elementStartX + elementWidth - me.minWidth, elementStartX + deltaX), 0);
        if (!skipTranslate) {
          DomHelper.setTranslateX(element, Math.round(newX));
        }
        context.newX = newX;
      } else if (edge === "right" && allowEdgeSwitch && !skipTranslate) {
        DomHelper.setTranslateX(element, elementStartX);
      }
      updated = true;
    } else if (me.direction === "vertical" && elementHeight !== newHeight) {
      if (!skipUpdatingElement) {
        style.height = Math.abs(height) + "px";
      }
      context.newHeight = height;
      if (edge === "top" || height < 0) {
        context.newY = Math.max(Math.min(elementStartY + elementHeight - me.minHeight, elementStartY + deltaY), 0);
        if (!skipTranslate) {
          DomHelper.setTranslateY(element, context.newY);
        }
      } else if (edge === "bottom" && allowEdgeSwitch && !skipTranslate) {
        DomHelper.setTranslateY(element, elementStartY);
      }
      updated = true;
    }
    return updated;
  }
  finishResize(event) {
    const me = this, context = me.context, eventObject = {
      context,
      event
    };
    context.element.classList.remove(me.resizingCls);
    if (context.started) {
      let changed = false;
      if (me.direction === "horizontal") {
        changed = context.newWidth && context.newWidth !== context.elementWidth;
      } else {
        changed = context.newHeight && context.newHeight !== context.elementHeight;
      }
      me.trigger(changed ? "resize" : "cancel", eventObject);
      if (!context.async) {
        context.finalize();
      }
    } else {
      var _me$reset4;
      (_me$reset4 = me.reset) === null || _me$reset4 === void 0 ? void 0 : _me$reset4.call(me);
    }
  }
  abortResize(event = null, silent = false) {
    const me = this, context = me.context;
    context.element.classList.remove(me.resizingCls);
    if (me.direction === "horizontal") {
      if (context.edge === "left" || context.allowEdgeSwitch && !context.skipTranslate) {
        DomHelper.setTranslateX(context.element, context.elementStartX);
      }
      context.element.style.width = context.elementWidth + "px";
    } else {
      DomHelper.setTranslateY(context.element, context.elementStartY);
      context.element.style.height = context.elementHeight + "px";
    }
    !silent && me.trigger("cancel", {
      context,
      event
    });
    if (!me.isDestroyed) {
      me.reset();
    }
  }
  highlightHandle() {
    const me = this, target = me.targetSelector ? me.currentElement.closest(me.targetSelector) : me.currentElement;
    me.currentElement.classList.add("b-resize-handle");
    target.classList.add("b-over-resize-handle");
  }
  unHighlightHandle() {
    const me = this, target = me.targetSelector ? me.currentElement.closest(me.targetSelector) : me.currentElement;
    target && target.classList.remove("b-over-resize-handle");
    me.currentElement.classList.remove("b-resize-handle");
    me.currentElement = null;
  }
  overAnyHandle(event, target) {
    return this.overStartHandle(event, target) || this.overEndHandle(event, target);
  }
  overStartHandle(event, target) {
    return this.direction === "horizontal" ? this.overLeftHandle(event, target) : this.overTopHandle(event, target);
  }
  overEndHandle(event, target) {
    return this.direction === "horizontal" ? this.overRightHandle(event, target) : this.overBottomHandle(event, target);
  }
  getDynamicHandleSize(opposite, offsetWidth) {
    const handleCount = opposite ? 2 : 1, {
      handleSize
    } = this;
    if (this.dynamicHandleSize && handleSize * handleCount > offsetWidth - this.reservedSpace) {
      return Math.max(Math.floor((offsetWidth - this.reservedSpace) / handleCount), 0);
    }
    return handleSize;
  }
  overLeftHandle(event, target) {
    const me = this, {
      offsetWidth
    } = target;
    if (me.leftHandle && me.canResize(target, event) && (offsetWidth >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const leftHandle = Rectangle.from(target);
      leftHandle.width = me.getDynamicHandleSize(me.rightHandle, offsetWidth);
      return leftHandle.width > 0 && leftHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
  overRightHandle(event, target) {
    const me = this, {
      offsetWidth
    } = target;
    if (me.rightHandle && me.canResize(target, event) && (offsetWidth >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const rightHandle = Rectangle.from(target);
      rightHandle.x = rightHandle.right - me.getDynamicHandleSize(me.leftHandle, offsetWidth);
      return rightHandle.width > 0 && rightHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
  overTopHandle(event, target) {
    const me = this, {
      offsetHeight
    } = target;
    if (me.topHandle && me.canResize(target, event) && (offsetHeight >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const topHandle = Rectangle.from(target);
      topHandle.height = me.getDynamicHandleSize(me.bottomHandle, offsetHeight);
      return topHandle.height > 0 && topHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
  overBottomHandle(event, target) {
    const me = this, {
      offsetHeight
    } = target;
    if (me.bottomHandle && me.canResize(target, event) && (offsetHeight >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const bottomHandle = Rectangle.from(target);
      bottomHandle.y = bottomHandle.bottom - me.getDynamicHandleSize(me.bottomHandle, offsetHeight);
      return bottomHandle.height > 0 && bottomHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
};
_defineProperty(ResizeHelper, "configurable", {
  skipUpdatingElement: null
});
ResizeHelper._$name = "ResizeHelper";
var tagSpaceRe = />[ \t\r\n]+</g;
var multiSpaceRe = /\s\s+/g;
var TemplateHelper = class {
  static tpl(strings, ...values) {
    let count = 0, output = values.map((val, i) => {
      let ret = strings[i];
      if (Array.isArray(val)) {
        ret += val.reduce((ack, item) => ack += (typeof item === "string" ? item.trim() : item) + "\n", "");
      } else {
        if (val === void 0) {
          val = "";
        }
        ret += typeof val === "string" ? val.trim() : val;
      }
      count++;
      return ret;
    }).join("");
    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }
    return output.replace(tagSpaceRe, "><").replace(multiSpaceRe, " ").trim();
  }
  static docsTpl(strings, ...values) {
    let count = 0, output = values.map((val, i) => {
      let ret = strings[i];
      if (Array.isArray(val)) {
        ret += val.reduce((ack, item) => ack += (typeof item === "string" ? item.trim() : item) + "\n", "");
      } else {
        if (val === void 0) {
          val = "";
        }
        ret += typeof val === "string" ? val.trim() : val;
      }
      count++;
      return ret;
    }).join("");
    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }
    return output.replace(tagSpaceRe, "><").trim();
  }
  static repeat(times) {
    return function(...args) {
      return TemplateHelper.tpl(...args).repeat(times);
    };
  }
  static loop(times) {
  }
};
TemplateHelper._$name = "TemplateHelper";
var TimeZoneOffsetInfo = class extends Array {
  constructor(timeZone, year) {
    super();
    this.timeZone = timeZone;
    this.year = year;
  }
};
var TimeZoneDate = class {
  constructor(asString, timeZone) {
    this.asString = asString;
    this.timeZone = timeZone;
    this.asArray = parseStringDate(asString);
  }
  get asLocalDate() {
    if (!this._asLocalDate) {
      this._asLocalDate = new Date(...this.asArray);
    }
    return this._asLocalDate;
  }
  get asTicksUtc() {
    if (!this._asTicksUtc) {
      this._asTicksUtc = new Date(Date.UTC(...this.asArray)).getTime();
    }
    return this._asTicksUtc;
  }
};
var toTimeZoneInternal = (date2, timeZone) => {
  const tzDateString = date2.toLocaleString("sv-SE", {
    timeZone
  });
  return new TimeZoneDate(tzDateString, timeZone);
};
var getOffsetUtc = (ticks, timeZone) => {
  const {
    asTicksUtc,
    asString
  } = toTimeZoneInternal(new Date(ticks), timeZone);
  return {
    offset: (ticks - asTicksUtc) / 6e4,
    tzTicksUtc: asTicksUtc,
    tzString: asString
  };
};
var parseStringDate = (stringDate) => {
  const parsed = stringDate.split(/[\s-:]/).map((i) => i * 1);
  parsed[1] -= 1;
  return parsed;
};
var min = -6e4;
var hour = 36e5;
var day = -864e5;
var month = 2592e6;
var findOffsetDates = (timeZone, year) => {
  const cached = offsetDateCache.get(timeZone, year);
  if (cached) {
    return cached;
  }
  const offsets = new TimeZoneOffsetInfo(timeZone, year), startUtcTicks = new Date(Date.UTC(year, 0, 1)).getTime();
  let ticks = startUtcTicks, incr = month, monthIndex = 0, previousOffset = [], currentOffset = null, tzTicksUtc, tzString, offset, done;
  while (!done) {
    ({
      offset,
      tzTicksUtc,
      tzString
    } = getOffsetUtc(ticks, timeZone));
    if (currentOffset == null) {
      currentOffset = offset;
      offsets.push({
        offset
      });
    } else if (incr > 0 && offset !== currentOffset) {
      incr = incr === month ? day : min;
    } else if (incr < 0 && offset === currentOffset) {
      if (incr === day) {
        incr = hour;
      } else {
        if (offsets.length === 1) {
          offsets.push(previousOffset);
          currentOffset = previousOffset.offset;
        } else {
          offsets[0].startTicks = previousOffset.startTicks;
          offsets[0].startDateString = previousOffset.startDateString;
          done = true;
        }
        incr = month;
      }
    }
    previousOffset = {
      offset,
      startDateString: tzString,
      startTicks: tzTicksUtc
    };
    if (incr === month) {
      ticks = startUtcTicks;
      ticks += monthIndex * month;
      monthIndex += 1;
    }
    ticks += incr;
    if (monthIndex > 11) {
      done = true;
    }
  }
  offsetDateCache.set(offsets);
  return offsets;
};
var offsetDateCache = {
  _cache: {},
  get(timeZone, year) {
    var _this$_cache$timeZone;
    return (_this$_cache$timeZone = this._cache[timeZone]) === null || _this$_cache$timeZone === void 0 ? void 0 : _this$_cache$timeZone[year];
  },
  set(offsetInfo) {
    const {
      timeZone
    } = offsetInfo, {
      _cache
    } = this;
    if (!_cache[timeZone]) {
      _cache[timeZone] = {};
    }
    _cache[timeZone][offsetInfo.year] = offsetInfo;
  }
};
var TimeZoneHelper = class {
  static get $name() {
    return "TimeZoneHelper";
  }
  static toTimeZone(date2, timeZone) {
    if (typeof timeZone === "number") {
      return this.toUtcOffset(date2, timeZone);
    }
    const tzDate = toTimeZoneInternal(date2, timeZone);
    if (tzDate.asArray[3] !== tzDate.asLocalDate.getHours()) {
      console.error("Incorrect transformation due to local dst");
    }
    return tzDate.asLocalDate;
  }
  static fromTimeZone(date2, timeZone) {
    if (typeof timeZone === "number") {
      return this.fromUtcOffset(date2, timeZone);
    }
    const dateArr = this.dateAsArray(date2), offsetDates = findOffsetDates(timeZone, date2.getUTCFullYear());
    let useOffset = offsetDates[0].offset;
    if (offsetDates.length === 2) {
      const utcTicks = Date.UTC(...dateArr);
      if (utcTicks >= offsetDates[1].startTicks && utcTicks < offsetDates[0].startTicks) {
        useOffset = offsetDates[1].offset;
      }
    }
    dateArr[4] += useOffset;
    return new Date(Date.UTC(...dateArr));
  }
  static toUtcOffset(date2, utcOffset) {
    const offset = date2.getTimezoneOffset() + utcOffset;
    return new Date(date2.getTime() + offset * 60 * 1e3);
  }
  static fromUtcOffset(date2, utcOffset) {
    const offset = -date2.getTimezoneOffset() - utcOffset;
    return new Date(date2.getTime() + offset * 60 * 1e3);
  }
  static dateAsArray(date2) {
    return [date2.getFullYear(), date2.getMonth(), date2.getDate(), date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getMilliseconds()];
  }
};
TimeZoneHelper._$name = "TimeZoneHelper";
var Toast = class extends Widget {
  static get $name() {
    return "Toast";
  }
  static get type() {
    return "toast";
  }
  static get configurable() {
    return {
      testConfig: {
        destroyTimeout: 1,
        timeout: 100
      },
      floating: true,
      timeout: 2500,
      autoDestroy: null,
      destroyTimeout: 200,
      showProgress: true,
      color: null,
      bottomMargin: 20
    };
  }
  compose() {
    const {
      appendTo,
      color,
      html,
      showProgress,
      style,
      timeout
    } = this;
    return {
      parent: appendTo || this.floatRoot,
      class: _objectSpread2(_objectSpread2({}, DomClassList.normalize(color, "object")), {}, {
        "b-toast-hide": 1
      }),
      html,
      style,
      children: {
        progressElement: showProgress && {
          style: `animation-duration:${timeout / 1e3}s;`,
          class: {
            "b-toast-progress": 1
          }
        }
      },
      listeners: {
        click: "hide"
      }
    };
  }
  doDestroy() {
    this.untoast();
    super.doDestroy();
  }
  get nextBottom() {
    const {
      bottomMargin,
      element
    } = this;
    return parseInt(element.style.bottom, 10) + element.offsetHeight + bottomMargin;
  }
  async show() {
    await super.show(...arguments);
    const me = this, {
      element
    } = me, {
      toasts
    } = Toast;
    if (!toasts.includes(me)) {
      var _toasts$0$nextBottom, _toasts$;
      element.style.bottom = ((_toasts$0$nextBottom = (_toasts$ = toasts[0]) === null || _toasts$ === void 0 ? void 0 : _toasts$.nextBottom) !== null && _toasts$0$nextBottom !== void 0 ? _toasts$0$nextBottom : me.bottomMargin) + "px";
      toasts.unshift(me);
      element.getBoundingClientRect();
      element.classList.remove("b-toast-hide");
      if (me.timeout > 0) {
        me.hideTimeout = me.setTimeout("hide", me.timeout);
      }
    }
  }
  async hide() {
    const me = this;
    me.untoast();
    me.element.classList.add("b-toast-hide");
    if (me.autoDestroy && !me.destroyTimer) {
      me.destroyTimer = me.setTimeout("destroy", me.destroyTimeout);
    }
  }
  untoast() {
    const {
      toasts
    } = Toast;
    if (toasts.includes(this)) {
      toasts.splice(toasts.indexOf(this), 1);
    }
  }
  static hideAll() {
    Toast.toasts.slice().reverse().forEach((toast) => toast.hide());
  }
  static show(config) {
    const toast = Toast.new({
      autoDestroy: true,
      rootElement: document.body
    }, typeof config === "string" ? {
      html: config
    } : config);
    toast.show();
    return toast;
  }
};
Toast.toasts = [];
Toast.initClass();
Toast._$name = "Toast";
var WidgetHelper = class {
  static getById(id) {
    return Widget.getById(id);
  }
  static fromElement(element, type, limit) {
    return Widget.fromElement(element, type, limit);
  }
  static createWidget(config = {}) {
    return config.isWidget ? config : Widget.create(config);
  }
  static append(widget, config) {
    widget = Array.isArray(widget) && widget || [widget];
    if (config instanceof HTMLElement || typeof config === "string") {
      config = {
        appendTo: config
      };
    }
    if (config.insertFirst) {
      const target = typeof config.insertFirst === "string" ? document.getElementById(config.insertFirst) : config.insertFirst;
      if (target.firstChild) {
        config.insertBefore = target.firstChild;
      } else {
        config.appendTo = target;
      }
    }
    return widget.map((item) => Widget.create(ObjectHelper.assign({}, config || {}, item)));
  }
  static openPopup(element, config) {
    return Widget.create(ObjectHelper.assign({
      forElement: element
    }, typeof config === "string" ? {
      html: config
    } : config), "popup");
  }
  static showContextMenu(element, config) {
    const me = this;
    if (me.currentContextMenu) {
      me.currentContextMenu.destroy();
    }
    if (element instanceof HTMLElement) {
      config.forElement = element;
    } else if (Array.isArray(element)) {
      config.forElement = {
        target: new Point(...element)
      };
    } else if (element instanceof Point) {
      config.forElement = {
        target: element
      };
    }
    me.currentContextMenu = Widget.create(config, "menu");
    me.currentContextMenu.ion({
      destroy: () => {
        me.currentContextMenu = null;
      }
    });
    return me.currentContextMenu;
  }
  static attachTooltip(element, configOrText) {
    return Widget.attachTooltip(element, configOrText);
  }
  static hasTooltipAttached(element) {
    return Widget.resolveType("tooltip").hasTooltipAttached(element);
  }
  static destroyTooltipAttached(element) {
    return Widget.resolveType("tooltip").destroyTooltipAttached(element);
  }
  static mask(element, msg = "Loading") {
    if (element) {
      if (element instanceof HTMLElement) {
        element = {
          target: element,
          text: msg
        };
      }
      return Mask.mask(element, element.target);
    }
  }
  static unmask(element, close = true) {
    if (element.mask) {
      if (close) {
        element.mask.close();
      } else {
        element.mask.hide();
      }
    }
  }
  static toast(msg) {
    return Toast.show(msg);
  }
};
WidgetHelper._$name = "WidgetHelper";
var XMLHelper = class {
  static convertFromObject(obj, options = {}) {
    Objects.assignIf(options, {
      rootName: "root",
      elementName: "element",
      includeHeader: true,
      rootElementForArray: true
    });
    const {
      rootName,
      elementName,
      includeHeader,
      rootElementForArray
    } = options;
    let {
      xmlns
    } = options;
    xmlns = xmlns ? ` xmlns="${xmlns}"` : "";
    const header = includeHeader ? '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' : "";
    const converter = (o) => {
      const xmlItems = [];
      for (const key in o) {
        const item = o[key];
        if (Array.isArray(item)) {
          if (rootElementForArray) {
            xmlItems.push(`<${key}>`);
          }
          for (const subItem of item) {
            if (elementName.length) {
              xmlItems.push(`<${elementName}>`);
            } else {
              xmlItems.push(`<${key}>`);
            }
            xmlItems.push(converter(subItem));
            if (elementName.length) {
              xmlItems.push(`</${elementName}>`);
            } else {
              xmlItems.push(`</${key}>`);
            }
          }
          if (rootElementForArray) {
            xmlItems.push(`</${key}>`);
          }
        } else if (Objects.isObject(item)) {
          xmlItems.push(`<${key}>${converter(item)}</${key}>`);
        } else {
          if (item == null) {
            xmlItems.push(`<${key}/>`);
          } else {
            xmlItems.push(`<${key}>${StringHelper.encodeHtml(item)}</${key}>`);
          }
        }
      }
      return xmlItems.join("");
    };
    return `${header}<${rootName}${xmlns}>${converter(obj)}</${rootName}>`;
  }
};
XMLHelper._$name = "XMLHelper";
var RandomGenerator = class {
  constructor() {
    this.random100 = [46, 2, 36, 46, 54, 59, 18, 20, 71, 55, 88, 98, 13, 61, 61, 40, 2, 15, 3, 32, 51, 45, 64, 25, 81, 85, 54, 13, 57, 49, 64, 22, 81, 94, 0, 62, 17, 7, 11, 2, 33, 99, 85, 26, 83, 83, 96, 26, 20, 89, 91, 38, 26, 13, 11, 79, 32, 30, 5, 51, 70, 7, 5, 56, 58, 77, 37, 89, 40, 80, 78, 59, 26, 36, 8, 51, 60, 23, 86, 5, 11, 96, 64, 94, 87, 64, 4, 78, 17, 85, 35, 0, 90, 86, 23, 55, 53, 9, 35, 59, 29, 2, 64, 42, 8, 49, 43, 73, 6, 53, 38, 9, 39, 31, 32, 40, 49, 13, 78, 68, 20, 99, 24, 78, 35, 91, 73, 46, 67, 76, 89, 69, 30, 69, 25, 3, 4, 55, 1, 65, 66, 76, 83, 19, 67, 1, 95, 24, 54, 45, 56, 40, 67, 92, 72, 4, 69, 8, 47, 50, 27, 2, 38, 9, 14, 83, 12, 14, 62, 95, 22, 47, 35, 18, 38, 14, 86, 64, 68, 61, 52, 69, 39, 93, 20, 73, 32, 52, 74, 6, 56, 68, 99, 29, 24, 92, 40, 67, 6, 72, 31, 41, 91, 53, 80, 55, 33, 97, 97, 99, 18, 20, 5, 27, 82, 84, 61, 78, 27, 67, 7, 42, 75, 95, 91, 25, 63, 21, 70, 36, 46, 0, 1, 45, 84, 6, 86, 15, 10, 62, 96, 94, 10, 23, 93, 83, 94, 47, 5, 29, 29, 52, 51, 37, 77, 96, 43, 72, 43, 14, 54, 14, 72, 52, 4, 39, 15, 26, 68, 28, 25, 76, 60, 50, 22, 40, 72, 74, 68, 58, 8, 48, 40, 62, 52, 24, 9, 26, 47, 44, 49, 96, 7, 77, 90, 45, 76, 47, 5, 86, 1, 36, 18, 42, 19, 90, 34, 23, 70, 32, 69, 79, 0, 99, 57, 80, 72, 21, 19, 72, 85, 68, 4, 40, 86, 62, 0, 63, 4, 11, 69, 31, 78, 31, 21, 78, 29, 84, 13, 53, 57, 10, 26, 50, 24, 30, 90, 42, 51, 96, 93, 21, 99, 23, 81, 0, 89, 43, 86, 63, 93, 19, 54, 71, 92, 36, 4, 95, 37, 99, 60, 29, 23, 50, 68, 95, 57, 95, 77, 53, 99, 78, 75, 12, 92, 47, 23, 14, 0, 41, 98, 11, 34, 64, 26, 90, 50, 23, 38, 31, 74, 76, 16, 76, 66, 23, 22, 72, 48, 50, 20, 36, 37, 58, 5, 43, 49, 64, 81, 30, 8, 21, 98, 75, 60, 17, 50, 42, 27, 38, 90, 74, 45, 68, 67, 27, 31, 15, 58, 76, 41, 99, 23, 98, 53, 98, 56, 19, 79, 2, 4, 38, 96, 24, 65, 51, 43, 42, 41, 60, 46, 7, 90, 65, 3, 27, 63, 99, 51, 44, 86, 1, 54, 40, 15, 74, 3, 81, 51, 63, 87, 79, 84, 72, 22, 38, 96, 95, 33, 41, 21, 99, 21, 69, 7, 49, 40, 52, 41, 6, 91, 19, 76, 40, 54, 17, 33, 11, 11, 0, 1, 32, 94, 33, 13, 18, 45, 7, 85, 61, 42, 54, 45, 72, 78, 96, 17, 9, 80, 87, 41, 96, 66, 0, 8, 59, 18, 21, 2, 28, 64, 75, 97, 32, 80, 86, 97, 97, 55, 2, 73, 75, 11, 89, 67, 58, 70, 76, 12, 46, 64, 17, 22, 97, 25, 35, 93, 57, 82, 46, 57, 61, 31, 74, 27, 4, 32, 85, 53, 86, 53, 53, 42, 5, 28, 50, 65, 63, 70, 61, 73, 37, 13, 80, 7, 34, 22, 3, 26, 6, 62, 78, 12, 56, 87, 41, 58, 64, 31, 27, 45, 35, 18, 66, 62, 43, 89, 69, 94, 93, 33, 74, 2, 43, 85, 37, 82, 41, 74, 9, 15, 44, 33, 42, 65, 19, 1, 49, 78, 12, 29, 9, 78, 7, 55, 12, 45, 40, 33, 16, 86, 14, 52, 16, 73, 76, 0, 98, 75, 91, 78, 46, 99, 95, 90, 69, 78, 45, 62, 55, 37, 88, 49, 77, 27, 83, 38, 73, 39, 1, 75, 40, 65, 83, 54, 95, 7, 73, 4, 30, 26, 36, 89, 21, 5, 95, 11, 14, 87, 45, 36, 21, 77, 55, 5, 66, 51, 98, 48, 62, 74, 58, 23, 82, 30, 28, 19, 53, 89, 76, 98, 8, 34, 70, 28, 54, 16, 52, 35, 93, 54, 54, 72, 49, 18, 93, 72, 90, 71, 73, 15, 60, 38, 80, 76, 53, 70, 39, 69, 25, 5, 31, 61, 46, 6, 54, 34, 31, 52, 33, 36, 79, 76, 44, 29, 28, 38, 1, 66, 2, 90, 91, 1, 76, 78, 31, 55, 37, 71, 2, 3, 38, 85, 0, 95, 42, 2, 39, 57, 87, 61, 77, 98, 2, 24, 80, 48, 27, 47, 71, 15, 7, 49, 60, 86, 3, 2, 29, 38, 54, 36, 59, 83, 27, 47, 9, 36, 42, 8, 73, 85, 9, 16, 73, 60, 39, 12, 43, 25, 23, 29, 28, 47, 40, 77, 20, 89, 22, 30, 41, 59, 96, 19, 56, 20, 76, 73, 39, 46, 72, 40, 47, 37, 52, 29, 79, 37, 39, 50, 41, 87, 66, 17, 75, 31, 45, 26, 88, 70, 11, 90, 40, 74, 9, 32, 65, 72, 61, 6, 93, 54, 15, 84, 22, 99, 47, 10, 96, 4, 84, 19, 85, 73, 45, 25, 16, 8, 94, 99, 39, 28, 26, 68, 87, 48, 1, 65, 86, 46, 86, 7, 60, 82, 45, 75, 38, 56, 41, 35, 30, 86, 91, 97, 85, 45, 5, 14, 69, 85, 96, 37, 18, 26, 16, 38, 16, 1, 44, 94, 85, 58, 60, 20, 5, 47, 52, 41, 50, 71, 43, 42, 67, 64, 38, 65, 83, 99, 78, 96, 33, 20, 98, 24, 6, 2, 25, 16, 16, 44, 63, 24, 68, 56, 49, 91, 15, 59, 99, 27, 43, 34, 28, 36, 45, 1, 10, 19, 54, 26, 75, 17, 88, 96, 63, 24, 71, 93, 72, 97, 66, 87, 18, 86];
    this.randomCache = {};
    this.rndIndex = 0;
  }
  nextRandom(max) {
    const {
      randomCache
    } = this;
    let randomNumbers;
    if (randomCache[max]) {
      randomNumbers = randomCache[max];
    } else {
      randomNumbers = this.random100.filter((num) => num < max);
      randomCache[max] = randomNumbers;
    }
    return randomNumbers[this.rndIndex++ % randomNumbers.length];
  }
  reset() {
    this.rndIndex = 0;
  }
  fromArray(array) {
    return array[this.nextRandom(array.length)];
  }
  randomArray(array, maxLength) {
    const result = [], length = this.nextRandom(maxLength + 1), used = {};
    for (let i = 0, index = this.nextRandom(array.length); i < length; i++) {
      while (used[index]) {
        index = this.nextRandom(array.length);
      }
      used[index] = true;
      result.push(array[index]);
    }
    return result;
  }
};
RandomGenerator._$name = "RandomGenerator";
var lorem = ["Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.", "Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.", "Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.", "Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.", "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo.", "Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui atione voluptatem sequi nesciunt.", "Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem.", "Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur?", "Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"];
var DataGenerator = class {
  static reset() {
    this.rnd.reset();
    this.rndTime.reset();
    this.rndRating.reset();
  }
  static *generate(count, randomHeight = false, initialId = 1) {
    let addSkills, rowCallback;
    if (typeof count === "object") {
      var _count$initialId;
      randomHeight = count.randomHeight;
      initialId = (_count$initialId = count.initialId) !== null && _count$initialId !== void 0 ? _count$initialId : 1;
      addSkills = count.addSkills;
      rowCallback = count.rowCallback;
      count = count.count;
    }
    const me = this, {
      rnd,
      rndTime,
      rndRating,
      rndText,
      firstNames,
      surNames,
      teams,
      foods,
      colors,
      cities,
      skills
    } = me;
    for (let i = 0; i < count; i++) {
      var _rowCallback;
      const firstName = rnd.fromArray(firstNames), surName = rnd.fromArray(surNames), name = `${firstName} ${String.fromCharCode(65 + i % 25)} ${surName}`, startDay = rnd.nextRandom(60) + 1, start = new Date(2019, 0, startDay), finish = new Date(2019, 0, startDay + rnd.nextRandom(30) + 2), row = {
        id: initialId > -1 ? i + initialId : void 0,
        title: "Row " + i,
        name,
        firstName,
        surName,
        city: rnd.fromArray(cities),
        team: rnd.fromArray(cities) + " " + rnd.fromArray(teams),
        age: 10 + rnd.nextRandom(80),
        food: rnd.fromArray(foods),
        color: rnd.fromArray(colors),
        score: rnd.nextRandom(100) * 10,
        rank: rnd.nextRandom(100) + 1,
        start,
        finish,
        time: DateHelper.getTime(rndTime.nextRandom(24), rndTime.nextRandom(12) * 5),
        percent: rnd.nextRandom(100),
        done: rnd.nextRandom(100) < 50,
        rating: rndRating.nextRandom(5),
        relatedTo: Math.min(count - 1, i + initialId + rnd.nextRandom(10)),
        notes: lorem[rndText.nextRandom(7) + 1]
      };
      if (addSkills) {
        row.skills = rnd.randomArray(skills, 7);
      }
      const additionalData = (_rowCallback = rowCallback) === null || _rowCallback === void 0 ? void 0 : _rowCallback(row);
      additionalData && Object.assign(row, additionalData);
      if (randomHeight) {
        row.rowHeight = rnd.nextRandom(randomHeight === true ? 20 : randomHeight) * 5 + 20;
      }
      yield row;
    }
  }
  static generateData(count, randomHeight = false, initialId = 1, reset = true) {
    let args = count;
    if (typeof count !== "object") {
      args = {
        count,
        randomHeight,
        initialId,
        reset
      };
    }
    args.reset !== false && this.reset();
    if (DataGenerator.overrideRowCount) {
      args.count = DataGenerator.overrideRowCount;
    }
    const rows = [], generator = this.generate(args);
    for (let i = 0; i < args.count; i++) {
      rows.push(generator.next().value);
    }
    return rows;
  }
  static generateEvents({
    viewStartDate,
    viewEndDate,
    nbrResources = 50,
    nbrEvents = 5,
    dependencies,
    tickUnit = "days",
    minDuration = 2,
    maxDuration = 10
  }) {
    const resources = this.generateData(nbrResources), events = [];
    dependencies = [];
    for (let i = 0; i < nbrResources; i++) {
      for (let j = 0; j < nbrEvents; j++) {
        const visibleDuration = DateHelper.getDurationInUnit(viewStartDate, viewEndDate, tickUnit), startDate = DateHelper.add(viewStartDate, Math.round(Math.random() * 0.9 * visibleDuration), tickUnit), duration = Math.round(Math.random() * (maxDuration - minDuration)) + minDuration, endDate = DateHelper.add(startDate, duration, "days"), eventId = events.length + 1;
        events.push({
          id: eventId,
          name: this.tasks[(i + j) % (this.tasks.length - 1)],
          startDate,
          duration,
          endDate,
          resourceId: i
        });
        if (dependencies && i > 0) {
          dependencies.push({
            id: dependencies.length + 1,
            from: eventId - 1,
            to: eventId
          });
        }
      }
    }
    return {
      resources,
      events,
      dependencies
    };
  }
  static generateRow() {
    return DataGenerator.generateData(1, false, -1, false)[0];
  }
};
Object.assign(DataGenerator, {
  rnd: new RandomGenerator(),
  rndTime: new RandomGenerator(),
  rndRating: new RandomGenerator(),
  rndText: new RandomGenerator(),
  cities: ["Stockholm", "Barcelona", "Paris", "Dubai", "New York", "San Francisco", "Washington", "Moscow"],
  firstNames: ["Mike", "Linda", "Don", "Karen", "Doug", "Jenny", "Daniel", "Melissa", "John", "Jane", "Theo", "Lisa", "Adam", "Mary", "Barbara", "James", "David"],
  surNames: ["McGregor", "Ewans", "Scott", "Smith", "Johnson", "Adams", "Williams", "Brown", "Jones", "Miller", "Davis", "More", "Wilson", "Taylor", "Anderson", "Thomas", "Jackson"],
  teams: ["Lions", "Eagles", "Tigers", "Horses", "Dogs", "Cats", "Panthers", "Rats", "Ducks", "Cougars", "Hens", "Roosters"],
  foods: ["Pancake", "Burger", "Fish n chips", "Carbonara", "Taco", "Salad", "Bolognese", "Mac n cheese", "Waffles"],
  colors: ["Blue", "Green", "Red", "Yellow", "Pink", "Purple", "Orange", "Teal", "Black"],
  skills: ["JavaScript", "CSS", "TypeScript", "React", "Vue", "Angular", "Java", "PHP", "Python", "C#", "C++", "BASIC", "COBOL", "FORTRAN", "PASCAL", "SQL"],
  tasks: ["Meetings", "Documentation", "Email communication", "Project management", "Budgeting", "Marketing and advertising", "Customer service", "Research and analysis", "Data entry", "IT support", "Employee management", "Sales and business development", "Event planning", "Graphic design", "Writing and editing", "Presentation", "Travel arrangements and expense management", "Training and development", "Quality assurance", "Customer support", "Technical writing", "Social media management", "Translation", "Legal research", "Data analysis and visualization", "Video editing and production", "Network admin", "Content creation", "Market research", "Public relations", "Teaching and training", "Recruiting", "Product development"]
});
DataGenerator._$name = "DataGenerator";
var knownProps = ["action", "target", "to", "deltaX", "deltaY", "x", "y", "text"];
var DemoBot = class extends Events(Delayable()) {
  static get defaultConfig() {
    return {
      repeat: true,
      outerElement: document.body,
      callOnFunctions: true
    };
  }
  construct(config) {
    super.construct(config);
    const me = this;
    if (me.widget) {
      me.outerElement = me.widget.element;
      me.widget.playingDemo = true;
    }
    EventHelper.playingDemo = true;
    Object.assign(me, {
      prevTarget: null,
      currentStep: 0,
      mouse: DomHelper.createElement({
        parent: me.outerElement,
        tag: "div",
        className: "simulated-mouse"
      }),
      timeoutId: null,
      innerIntervalId: null,
      mouseOutElements: []
    });
    me.intervalId = me.setInterval(me.nextStep.bind(me), 1e3);
    me.outerElement.classList.add("b-playing-demo");
    me.outerElement.addEventListener("click", (event) => {
      if (event.isTrusted) {
        me.abort();
      }
    });
  }
  doDestroy() {
    this.abort();
  }
  abort(atEnd = false) {
    const me = this;
    me.mouse.style.top = "-100px";
    me.clearInterval(me.intervalId);
    me.timeoutId && me.clearTimeout(me.timeoutId);
    me.innerIntervalId && me.clearInterval(me.innerIntervalId);
    me.outerElement.classList.remove("b-playing-demo");
    if (me.widget) {
      me.widget.playingDemo = false;
    }
    EventHelper.playingDemo = false;
    me.trigger(atEnd ? "done" : "abort");
  }
  triggerEvent(element, type, data) {
    if (!element)
      return null;
    let event;
    if (type.startsWith("mouse")) {
      const box = this.mouse.getBoundingClientRect();
      event = new MouseEvent(type, Object.assign({
        view: globalThis,
        bubbles: true,
        cancelable: true,
        clientX: box.left,
        clientY: box.top
      }, data || {}));
    } else {
      event = document.createEvent("Event");
      event.initEvent(type, true, false);
    }
    element.dispatchEvent(event);
    return event;
  }
  handleMouseMove(step, target) {
    const me = this, mouse = me.mouse;
    mouse.classList.add("quick");
    if (me.mouseDown)
      mouse.classList.add("drag");
    const mouseBox = Rectangle.from(mouse, me.outerElement), x = mouseBox.x, y = mouseBox.y;
    let deltaX = 0, deltaY = 0;
    if (step.to) {
      if (typeof step.to === "string") {
        const toElement = me.outerElement.querySelector(step.to);
        if (toElement) {
          const rect = Rectangle.from(toElement, me.outerElement), toX = rect.x + rect.width / 2, toY = rect.y + rect.height / 2;
          deltaX = (toX - x) / 10;
          deltaY = (toY - y) / 10;
        }
      } else if (step.to.x) {
        deltaX = (step.to.x - x) / 10;
      } else {
        deltaX = step.to[0] / 10;
        deltaY = step.to[1] / 10;
      }
    } else if (step.deltaX) {
      deltaX = step.deltaX / 10;
    } else if (step.x) {
      deltaX = (step.x - x) / 10;
    }
    if (step.deltaY) {
      deltaY = step.deltaY / 10;
    }
    let i = 0;
    me.innerIntervalId = me.setInterval(() => {
      if (me.shouldPause) {
        return;
      }
      if (i++ === 9) {
        clearInterval(me.innerIntervalId);
        if (step.then) {
          step.then();
        }
      }
      const mouseX = x + deltaX * i, mouseY = y + deltaY * i;
      mouse.style.left = mouseX + "px";
      mouse.style.top = mouseY + "px";
      const mouseBounds = mouse.getBoundingClientRect(), clientX = mouseBounds.left, clientY = mouseBounds.top, eventTarget = DomHelper.elementFromPoint(clientX, clientY);
      if (eventTarget !== me.prevTarget) {
        if (me.prevTarget) {
          me.mouseOutElements.push(me.prevTarget);
          if (!DomHelper.isDescendant(me.mouseOutElements[0], eventTarget)) {
            me.mouseOutElements.forEach((element) => me.triggerEvent(element, "mouseout"));
            me.mouseOutElements.length = 0;
          }
        }
        me.prevTarget = eventTarget;
        me.triggerEvent(eventTarget, "mouseover");
      }
      me.triggerEvent(eventTarget, step.action, {
        clientX,
        clientY
      });
    }, 50);
  }
  getTarget(step) {
    const me = this, target = step.target;
    if (!target) {
      return me.prevTarget || me.outerElement;
    }
    if (typeof target === "function") {
      return target(step);
    }
    return document.querySelector(target);
  }
  normalizeStep(step) {
    if (step.action) {
      if (typeof step.action === "function") {
        return step.action(step);
      }
      return step;
    }
    if (typeof step === "function") {
      step();
      return step;
    }
    for (const prop in step) {
      if (Object.hasOwnProperty.call(step, prop) && !knownProps.includes(prop)) {
        step.action = prop.toLowerCase();
        step.to = step[prop];
      }
    }
    if (!step.target && (typeof step.to === "string" || typeof step.to === "function"))
      step.target = step.to;
    return step;
  }
  get isScrolling() {
    const me = this, box = me.outerElement.getBoundingClientRect(), scrolled = me.lastTop && box.top !== me.lastTop;
    me.lastTop = box.top;
    return scrolled;
  }
  get isInView() {
    const box = this.outerElement.getBoundingClientRect();
    return box.top < globalThis.innerHeight && box.bottom > 0;
  }
  get shouldPause() {
    return !this.isInView || this.isScrolling || document.hidden || !document.hasFocus();
  }
  nextStep() {
    const me = this;
    if (me.shouldPause) {
      return;
    }
    if (me.currentStep === me.steps.length) {
      if (me.repeat) {
        me.currentStep = 0;
      } else {
        return me.abort(true);
      }
    }
    if (me.currentStep === 0) {
      me.trigger("initialize");
    }
    const mouse = me.mouse, step = me.normalizeStep(me.steps[me.currentStep++]), target = me.getTarget(step), action = step.action;
    if (target && action) {
      mouse.className = "simulated-mouse";
      if (action === "mousemove") {
        me.handleMouseMove(step, target);
      } else {
        if (target !== me.prevTarget) {
          const rect = Rectangle.from(target, me.outerElement);
          mouse.style.left = rect.x + rect.width / 2 + "px";
          mouse.style.top = rect.y + rect.height / 2 + "px";
        }
        if (action === "mousedown") {
          me.mouseDown = true;
        }
        if (action === "mouseup") {
          me.mouseDown = false;
        }
        me.timeoutId = me.setTimeout(() => {
          me.prevTarget = target;
          mouse.classList.add(action);
          if (action === "type") {
            const field = Widget.fromElement(target), parts = step.text.split("|");
            field.value = parts[parts.length === 1 || field.value != parts[0] ? 0 : 1];
          } else {
            me.triggerEvent(target, action);
          }
        }, action === "type" ? 100 : 550);
      }
    }
  }
};
DemoBot._$name = "DemoBot";
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var cacheKey = null;
function setParser(me, parser) {
  Object.defineProperty(me, "parser", {
    value: parser
  });
  return parser;
}
var Default = class {
  constructor(formatter) {
    this.formatter = formatter;
  }
  format(value) {
    return this.formatter.defaultFormat(value);
  }
  parse(value, strict) {
    return this.formatter.defaultParse(value, strict);
  }
  resolvedOptions() {
    return null;
  }
};
var Formatter = class {
  static get(format2) {
    if (format2 == null) {
      return this.NULL;
    }
    if (format2 instanceof this) {
      return format2;
    }
    const key = typeof format2 === "string" ? format2 : JSON.stringify(format2), cache = this.cache;
    let fmt = cache.get(key);
    if (!fmt) {
      cacheKey = key;
      fmt = new this(format2);
      cache.set(key, fmt);
    }
    return fmt;
  }
  static get cache() {
    return hasOwnProperty$1.call(this, "_cache") && this._cache || (this._cache = /* @__PURE__ */ new Map());
  }
  static get NULL() {
    return hasOwnProperty$1.call(this, "_null") ? this._null : this._null = new this(null);
  }
  constructor(config) {
    const me = this;
    me.cacheKey = cacheKey;
    cacheKey = null;
    me.initialize();
    if (config === null) {
      me.formatter = new Default(me);
    } else {
      me.configure(config);
      for (const [key, value] of Object.entries(me.resolvedOptions())) {
        if (value != null && key in me.defaults) {
          me[key] = value;
        }
      }
    }
  }
  get parser() {
    return setParser(this, new this.constructor.Parser(this));
  }
  defaultFormat(value) {
    return value == null ? value : String(value);
  }
  defaultParse(value) {
    return value;
  }
  format(value) {
    return value == null ? value : this.formatter.format(value);
  }
  parse(value, strict) {
    return value == null ? value : this.parser.parse(value, strict);
  }
  parseStrict(value) {
    return this.parse(value, true);
  }
  resolvedOptions() {
    return this.formatter.resolvedOptions();
  }
};
Formatter._$name = "Formatter";
var Navigator = class extends Base$1.mixin(Events, Factoryable) {
  static get $name() {
    return "Navigator";
  }
  static get type() {
    return "navigator";
  }
  static get configurable() {
    return {
      ownerCmp: null,
      itemsTabbable: null,
      target: null,
      keyEventTarget: null,
      processEvent: null,
      itemSelector: null,
      activeItem: null,
      focusCls: "b-active",
      keys: null,
      allowCtrlKey: null,
      allowShiftKey: null,
      scrollDuration: 50,
      disabled: null,
      datasetIdProperty: "id",
      testConfig: {
        scrollDuration: 1
      }
    };
  }
  static get factoryable() {
    return {
      defaultType: "navigator"
    };
  }
  get activeItem() {
    const {
      _activeItem
    } = this;
    if (this.target.contains(_activeItem)) {
      return _activeItem;
    }
    this._activeItem = null;
  }
  updateOwnerCmp(ownerCmp) {
    if (!this.itemSelector) {
      this.itemSelector = `.${this.ownerCmp.itemCls}`;
    }
    DomHelper.setAttributes(this.keyEventTarget, {
      "aria-activedescendant": `${this.owner.id}-active-descendant`
    });
  }
  set navigationEvent(navigationEvent) {
    const {
      owner
    } = this;
    this._navigationEvent = owner.navigationEvent = navigationEvent;
    if (navigationEvent) {
      Promise.resolve(1).then(() => this.navigationEvent = null);
    }
  }
  get navigationEvent() {
    return this._navigationEvent;
  }
  static getComposedKeyName(keyEvent) {
    const keyName = (keyEvent.key || "").trim() || keyEvent.code;
    return `${keyEvent.ctrlKey ? "CTRL+" : ""}${keyEvent.shiftKey ? "SHIFT+" : ""}${keyEvent.altKey ? "ALT+" : ""}${keyName}`;
  }
  onKeyDown(keyEvent) {
    const me = this, {
      ownerCmp,
      itemSelector,
      activeItem,
      itemsTabbable
    } = me, {
      target
    } = keyEvent, firstItem = me.target.querySelector(itemSelector), keyName = (keyEvent.key || "").trim() || keyEvent.code, composedKeyName = me.constructor.getComposedKeyName(keyEvent), validTarget = target.matches(itemSelector) || target === me.keyEventTarget;
    if (!me.disabled && me.processEvent) {
      keyEvent = me.processEvent.call(ownerCmp, keyEvent);
    }
    if (keyEvent && !me.disabled && firstItem && me.target.offsetParent && validTarget) {
      if (!itemsTabbable) {
        if (me.inlineFlow == null) {
          const itemContainer = firstItem.parentNode, itemPositionStyle = DomHelper.getStyleValue(firstItem, "position"), itemDisplayStyle = DomHelper.getStyleValue(firstItem, "display"), itemFloatStyle = DomHelper.getStyleValue(firstItem, "float");
          me.inlineFlow = itemPositionStyle === "absolute" || itemDisplayStyle === "inline" || itemDisplayStyle === "inline-block" || itemFloatStyle === "left" || itemFloatStyle === "right" || DomHelper.getStyleValue(itemContainer, "display") === "flex" && DomHelper.getStyleValue(itemContainer, "flex-direction") === "row";
        }
        if (!me.prevKey) {
          if (me.inlineFlow) {
            me.prevKey = "ArrowLeft";
            me.nextKey = "ArrowRight";
          } else {
            me.prevKey = "ArrowUp";
            me.nextKey = "ArrowDown";
          }
        }
      }
      me.navigationEvent = keyEvent;
      if (activeItem) {
        switch (keyName) {
          case me.prevKey:
            if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
              return;
            }
            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }
            keyEvent.preventDefault();
            keyEvent.handled = true;
            me.navigatePrevious(keyEvent);
            break;
          case me.nextKey:
            if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
              return;
            }
            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }
            keyEvent.preventDefault();
            keyEvent.handled = true;
            me.navigateNext(keyEvent);
            break;
          default: {
            var _me$keys;
            const keyHandler = (_me$keys = me.keys) === null || _me$keys === void 0 ? void 0 : _me$keys[composedKeyName];
            if (keyHandler && !me.disabled) {
              if (me.callback(keyHandler, me.thisObj || ownerCmp, [keyEvent]) === false) {
                return;
              }
            } else if (ownerCmp.onInternalKeyDown) {
              ownerCmp.onInternalKeyDown(keyEvent);
            }
            if (DomHelper.getActiveElement(target) !== target) {
              keyEvent.preventDefault();
            }
            if (itemsTabbable) {
              return;
            }
          }
        }
      } else {
        if (itemsTabbable) {
          return;
        }
        if (keyName === me.nextKey || keyName === me.prevKey) {
          me.activeItem = me.getDefaultNavigationItem(keyEvent);
        }
      }
      if (me.activeItem !== activeItem) {
        me.triggerNavigate(keyEvent);
      }
    }
  }
  getDefaultNavigationItem(keyEvent) {
    const {
      target,
      itemSelector,
      prevKey,
      nextKey
    } = this;
    if (target.compareDocumentPosition(keyEvent.target) & 4 && keyEvent.key === prevKey) {
      return target.querySelector(`${itemSelector}:last-of-type`);
    }
    if (target.compareDocumentPosition(keyEvent.target) & 2 && keyEvent.key === nextKey) {
      return target.querySelector(`${itemSelector}`);
    }
  }
  navigatePrevious(keyEvent) {
    const me = this, previous = me.previous;
    keyEvent.preventDefault();
    if (previous) {
      me.ownerCmp.scrollable.scrollIntoView(previous, {
        animate: me.scrollDuration
      }).then(() => {
        me.activeItem = previous;
        me.triggerNavigate(keyEvent);
      });
    }
  }
  navigateNext(keyEvent) {
    const me = this, next = me.next;
    keyEvent.preventDefault();
    if (next) {
      me.ownerCmp.scrollable.scrollIntoView(next, {
        animate: me.scrollDuration
      }).then(() => {
        me.activeItem = next;
        me.triggerNavigate(keyEvent);
      });
    }
  }
  get owner() {
    return this.ownerCmp;
  }
  get previous() {
    return this.getAdjacent(-1);
  }
  get next() {
    return this.getAdjacent(1);
  }
  getAdjacent(direction = 1, from = this.activeItem) {
    const treeWalker = this.treeWalker;
    treeWalker.currentNode = from;
    treeWalker[direction < 0 ? "previousNode" : "nextNode"]();
    if (treeWalker.currentNode !== this.activeItem) {
      return treeWalker.currentNode;
    }
  }
  onTargetFocusIn(focusInEvent) {
    const me = this, {
      target,
      relatedTarget
    } = focusInEvent, {
      owner,
      itemsTabbable,
      skipScrollIntoView,
      previousActiveItem
    } = me;
    if (!target.matches(".b-focus-trap")) {
      if (target.matches(me.itemSelector)) {
        me.skipScrollIntoView = true;
        me.activeItem = target;
        me.skipScrollIntoView = skipScrollIntoView;
        if (me.activeItem && itemsTabbable) {
          me.triggerNavigate(focusInEvent);
        }
      } else if (target === me.target) {
        const fromWhere = relatedTarget ? target.compareDocumentPosition(relatedTarget) : 0;
        if (fromWhere & Node.DOCUMENT_POSITION_CONTAINED_BY) {
          var _owner$previousSiblin;
          (_owner$previousSiblin = owner.previousSibling) === null || _owner$previousSiblin === void 0 ? void 0 : _owner$previousSiblin.focus();
        } else {
          me.activeItem = previousActiveItem && me.target.contains(previousActiveItem) ? previousActiveItem : 0;
        }
      }
    }
  }
  onTargetFocusOut(focusOutEvent) {
    const me = this, {
      relatedTarget
    } = focusOutEvent;
    if (!(relatedTarget !== null && relatedTarget !== void 0 && relatedTarget.matches(".b-focus-trap"))) {
      if (!relatedTarget || !me.target.contains(relatedTarget) || !relatedTarget.matches(me.itemSelector)) {
        if (me.activeItem) {
          me.activeItem = null;
          if (me.itemsTabbable) {
            me.triggerNavigate(focusOutEvent);
          }
        }
      }
    }
  }
  onTargetMouseDown(mouseDownEvent) {
    const me = this, target = mouseDownEvent.target.closest(me.itemSelector);
    me.navigationEvent = mouseDownEvent;
    if (me.itemsTabbable) {
      if (target === me.activeItem) {
        me.triggerNavigate(mouseDownEvent);
      }
    } else if (me.ownerCmp.itemsFocusable === false) {
      me.onFocusGesture(mouseDownEvent);
    } else if (target) {
      mouseDownEvent.preventDefault();
      DomHelper.focusWithoutScrolling(target);
    }
  }
  onTargetClick(clickEvent) {
    var _me$navigationEvent;
    const me = this, {
      skipScrollIntoView
    } = me;
    if (me.skipNextClick || (_me$navigationEvent = me.navigationEvent) !== null && _me$navigationEvent !== void 0 && _me$navigationEvent.ignoreNavigation) {
      me.skipNextClick = false;
      return;
    }
    if (me.disabled) {
      return;
    }
    me.skipScrollIntoView = true;
    if (me.processEvent) {
      clickEvent = me.processEvent.call(me.ownerCmp, clickEvent);
    }
    if (clickEvent) {
      me.activeItem = clickEvent.target.closest(me.itemSelector);
      me.triggerNavigate(clickEvent);
    }
    me.skipScrollIntoView = skipScrollIntoView;
  }
  onFocusGesture(event) {
    if (event.target === this.ownerCmp.contentElement || event.target.closest(this.itemSelector) && this.ownerCmp.itemsFocusable === false) {
      event.preventDefault();
    }
  }
  acceptNode(node) {
    return node.offsetParent && node.matches && node.matches(this.itemSelector) ? DomHelper.NodeFilter.FILTER_ACCEPT : DomHelper.NodeFilter.FILTER_SKIP;
  }
  changeActiveItem(activeItem) {
    if (activeItem != null) {
      if (this.ownerCmp.getItem) {
        activeItem = this.ownerCmp.getItem(activeItem);
      }
    }
    return activeItem;
  }
  updateActiveItem(activeItem, oldActiveItem) {
    const me = this, {
      ownerCmp
    } = me, isActive = oldActiveItem && me.target.contains(oldActiveItem), needsFocus = activeItem && DomHelper.isFocusable(activeItem) && activeItem !== DomHelper.getActiveElement(activeItem);
    if (isActive) {
      me.previousActiveItem = oldActiveItem;
    }
    if (oldActiveItem) {
      oldActiveItem.classList.remove(me.focusCls);
      oldActiveItem.removeAttribute("id");
    }
    if (activeItem != null) {
      if (me.skipScrollIntoView) {
        if (needsFocus) {
          DomHelper.focusWithoutScrolling(activeItem);
        }
      } else {
        var _ownerCmp$scrollable;
        (_ownerCmp$scrollable = ownerCmp.scrollable) === null || _ownerCmp$scrollable === void 0 ? void 0 : _ownerCmp$scrollable.scrollIntoView(activeItem, {
          block: "nearest",
          focus: needsFocus,
          silent: me.scrollSilently
        });
      }
      if (activeItem === oldActiveItem && isActive) {
        return;
      }
      activeItem.classList.add(me.focusCls);
      activeItem.id = `${me.owner.id}-active-descendant`;
      me._activeItem = activeItem;
    } else {
      me._activeItem = null;
      if (oldActiveItem === DomHelper.getActiveElement(oldActiveItem)) {
        ownerCmp.revertFocus();
      }
    }
  }
  updateTarget(target, oldTarget) {
    const me = this, listeners = {
      element: target,
      thisObj: me,
      focusin: "onTargetFocusIn",
      focusout: "onTargetFocusOut",
      mousedown: {
        handler: "onTargetMouseDown",
        delegate: me.itemSelector
      }
    };
    if (!me.itemsTabbable && !me.itemsFocusable) {
      listeners.click = "onTargetClick";
    }
    if (!Object.prototype.hasOwnProperty.call(me, "acceptNode")) {
      me.acceptNode = me.acceptNode.bind(me);
      me.acceptNode.acceptNode = me.acceptNode;
    }
    EventHelper.on(listeners);
    me.treeWalker = me.setupTreeWalker(target, DomHelper.NodeFilter.SHOW_ELEMENT, me.acceptNode);
    if (!me.keyEventTarget) {
      me.keyEventTarget = target;
    }
    (me.targetMutationMonitor = new MutationObserver(me.onTargetChildListChange.bind(me))).observe(target, {
      childList: true,
      subtree: true
    });
  }
  setupTreeWalker(root2, whatToShow, filter2) {
    return document.createTreeWalker(root2, whatToShow, filter2);
  }
  onTargetChildListChange() {
    const me = this, {
      activeItem,
      datasetIdProperty
    } = me;
    if (activeItem) {
      if (me.target.contains(activeItem)) {
        if (!activeItem.classList.contains(me.focusCls)) {
          activeItem.classList.add(me.focusCls);
        }
      } else {
        var _me$target$querySelec;
        me.activeItem = me.target.querySelector(`${me.itemSelector}.${me.focusCls}[data-${StringHelper.hyphenate(datasetIdProperty)}="${activeItem.dataset[datasetIdProperty]}"]`) || ((_me$target$querySelec = me.target.querySelector(`${me.itemSelector}.${me.focusCls}`)) === null || _me$target$querySelec === void 0 ? void 0 : _me$target$querySelec[activeItem.dataset.index]) || null;
      }
    }
  }
  changeKeyEventTarget(keyEventTarget) {
    this._keyEventTarget = keyEventTarget;
    EventHelper.on({
      element: keyEventTarget,
      keydown: "onKeyDown",
      thisObj: this
    });
  }
  triggerNavigate(event, item = this.activeItem) {
    var _this$ownerCmp;
    const navEvent = {
      event,
      item,
      oldItem: this.previousActiveItem
    };
    this.trigger("navigate", navEvent);
    (_this$ownerCmp = this.ownerCmp) === null || _this$ownerCmp === void 0 ? void 0 : _this$ownerCmp.trigger("navigate", navEvent);
  }
};
Navigator._$name = "Navigator";
var escapeRegExp = StringHelper.escapeRegExp;
var digitsRe = /[\d+-]/g;
var newFormatter = (locale2, config) => new Intl.NumberFormat(locale2 || void 0, config);
var numFormatRe = /^(?:([$])\s*)?(?:(\d+)>)?\d+(,\d+)?(?:\.((\d*)(?:#*)|[*]))?(?:\s*([%])?)?$/;
var unicodeMinus = "\u2212";
var NumberParser = class {
  constructor(formatter) {
    const me = this, locale2 = formatter.locale, numFmt = newFormatter(locale2, {
      maximumFractionDigits: 3
    }), currency = formatter.is.currency ? me._decodeStyle(locale2, {
      style: "currency",
      currency: formatter.currency,
      currencyDisplay: formatter.currencyDisplay
    }) : null, percent = formatter.is.percent ? me._decodeStyle(locale2, {
      style: "percent"
    }) : null, decimal = numFmt.format(1.2).replace(digitsRe, "")[0], grouper = numFmt.format(1e9).replace(digitsRe, "")[0] || "";
    Object.assign(me, {
      currency,
      decimal,
      formatter,
      grouper,
      percent
    });
    me.decimal = decimal;
    me.decimalRe = escapeRegExp(decimal, "g");
    me.grouper = grouper;
    me.stripRe = new RegExp(`(?:\\s+|${escapeRegExp(grouper)})` + (currency ? `|(?:${escapeRegExp(currency.text)})` : "") + (percent ? `|(?:${escapeRegExp(percent.text)})` : ""), "g");
  }
  decimalPlaces(value) {
    value = value.replace(this.stripRe, "");
    const dot = value.indexOf(this.decimal) + 1;
    return dot && value.length - dot;
  }
  parse(value, strict) {
    if (typeof value === "string") {
      value = value.replace(this.stripRe, "").replace(this.decimalRe, ".").replace(unicodeMinus, "-");
      value = strict ? Number(value) : parseFloat(value);
      if (this.formatter.is.percent) {
        value /= 100;
      }
    }
    return value;
  }
  _decodeStyle(locale2, fmtDef) {
    const fmt = newFormatter(locale2, fmtDef), decFmt = newFormatter(locale2, Object.assign(fmt.resolvedOptions(), {
      style: "decimal"
    })), zero = fmt.format(0), zeroDec = decFmt.format(0);
    return {
      suffix: zero.startsWith(zeroDec),
      text: zero.replace(zeroDec, "").trim()
    };
  }
};
var NumberFormat = class extends Formatter {
  static get $name() {
    return "NumberFormat";
  }
  initialize() {
    this._as = {};
    this.is = {
      decimal: false,
      currency: false,
      percent: false,
      null: true,
      from: null
    };
  }
  get truncator() {
    const scale = this.maximumFractionDigits;
    return scale == null ? null : this.as({
      style: "decimal",
      maximumFractionDigits: Math.min(20, scale + 1)
    }, "truncator");
  }
  configure(options) {
    const me = this;
    if (typeof options !== "string") {
      Object.assign(me, options);
    } else {
      me.template = options;
    }
    const config = {}, loc = me.locale ? LocaleManagerSingleton.locales[me.locale] : LocaleManagerSingleton.locale, defaults = loc && loc.NumberFormat, template = me.template;
    if (defaults) {
      for (const key in defaults) {
        if (me[key] == null && typeof defaults[key] !== "function") {
          me[key] = defaults[key];
        }
      }
    }
    if (template) {
      const match = numFormatRe.exec(template), m2 = match[2], m4 = match[4];
      me.useGrouping = !!match[3];
      me.style = match[1] ? "currency" : match[6] ? "percent" : "decimal";
      if (m2) {
        me.integer = +m2;
      }
      if (m4 === "*") {
        me.fraction = [0, 20];
      } else if (m4 != null) {
        me.fraction = [match[5].length, m4.length];
      }
    }
    me._minMax("fraction", true, true);
    me._minMax("integer", true, false);
    me._minMax("significant", false, true);
    for (const key in me.defaults) {
      if (me[key] != null) {
        config[key] = me[key];
      }
    }
    me.is.from = me.from && me.from.is;
    me.is[me.style] = !(me.is.null = false);
    me.formatter = newFormatter(me.locale, config);
  }
  as(change, cacheAs = null) {
    const config = this.resolvedOptions() || {
      template: "9.*"
    }, cache = this._as;
    let ret = cacheAs && cache[cacheAs];
    if (!ret) {
      if (typeof change === "string") {
        config.style = change;
      } else {
        Object.assign(config, change);
      }
      config.from = this;
      ret = new NumberFormat(config);
    }
    if (cacheAs) {
      cache[cacheAs] = ret;
    }
    return ret;
  }
  defaultParse(value, strict) {
    return value == null ? value : strict ? Number(value) : parseFloat(value);
  }
  format(value) {
    if (typeof value === "string") {
      const v = Number(value);
      value = isNaN(v) ? this.parse(value) : v;
    }
    return super.format(value);
  }
  round(value) {
    return this.parse(this.format(value));
  }
  truncate(value) {
    const me = this, scale = me.maximumFractionDigits, {
      truncator
    } = me;
    let v = me.parse(value), dot;
    if (truncator) {
      v = truncator.format(v);
      dot = v.indexOf(truncator.parser.decimal);
      if (dot > -1 && v.length - dot - 1 > scale) {
        v = v.substr(0, dot + scale + 1);
      }
      v = truncator.parse(v);
    }
    return v;
  }
  resolvedOptions() {
    const options = super.resolvedOptions();
    for (const key in options) {
      if (options[key] === void 0) {
        options[key] = this[key];
      }
    }
    return options;
  }
  _minMax(name, setMin, setMax) {
    const me = this, value = me[name];
    if (value != null) {
      const capName = StringHelper.capitalize(name), max = `maximum${capName}Digits`, min2 = `minimum${capName}Digits`;
      if (typeof value === "number") {
        if (setMin) {
          me[min2] = value;
        }
        if (setMax) {
          me[max] = value;
        }
      } else {
        me[min2] = value[0];
        me[max] = value[1];
      }
    }
  }
};
NumberFormat.Parser = NumberParser;
Object.assign(NumberFormat.prototype, {
  defaults: {
    style: "decimal",
    currency: null,
    currencyDisplay: "symbol",
    locale: null,
    maximumFractionDigits: null,
    minimumFractionDigits: null,
    minimumIntegerDigits: null,
    maximumSignificantDigits: null,
    minimumSignificantDigits: null,
    useGrouping: true
  },
  fraction: null,
  from: null,
  integer: null,
  significant: null,
  template: null
});
Object.assign(NumberFormat.prototype, NumberFormat.prototype.defaults);
Formatter.number = (format2, value) => NumberFormat.format(format2, value);
NumberFormat._$name = "NumberFormat";
var WebSocketManager = class extends Events(Base$1) {
  construct(config = {}) {
    const me = this;
    super.construct(config);
    me.onWsOpen = me.onWsOpen.bind(me);
    me.onWsClose = me.onWsClose.bind(me);
    me.onWsMessage = me.onWsMessage.bind(me);
    me.onWsError = me.onWsError.bind(me);
    if (me.autoConnect && me.address) {
      me.open();
    }
  }
  doDestroy() {
    const me = this;
    if (me.connector) {
      me.detachSocketListeners(me.connector);
      me.connector.close();
      me.connector = null;
    }
    super.doDestroy();
  }
  get isConnecting() {
    var _this$connector;
    return ((_this$connector = this.connector) === null || _this$connector === void 0 ? void 0 : _this$connector.readyState) === this.constructor.webSocketImplementation.CONNECTING;
  }
  get isOpened() {
    var _this$connector2;
    return ((_this$connector2 = this.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.readyState) === this.constructor.webSocketImplementation.OPEN;
  }
  get isClosing() {
    var _this$connector3;
    return ((_this$connector3 = this.connector) === null || _this$connector3 === void 0 ? void 0 : _this$connector3.readyState) === this.constructor.webSocketImplementation.CLOSING;
  }
  get isClosed() {
    var _this$connector4;
    return ((_this$connector4 = this.connector) === null || _this$connector4 === void 0 ? void 0 : _this$connector4.readyState) === this.constructor.webSocketImplementation.CLOSED;
  }
  createWebSocketConnector() {
    const connector = this.connector = new this.constructor.webSocketImplementation(this.address);
    this.attachSocketListeners(connector);
  }
  destroyWebSocketConnector() {
    this.detachSocketListeners(this.connector);
    this.connector.close();
    this.connector = null;
  }
  attachSocketListeners(connector) {
    const me = this;
    connector.addEventListener("open", me.onWsOpen);
    connector.addEventListener("close", me.onWsClose);
    connector.addEventListener("message", me.onWsMessage);
    connector.addEventListener("error", me.onWsError);
  }
  detachSocketListeners(connector) {
    const me = this;
    connector.removeEventListener("open", me.onWsOpen);
    connector.removeEventListener("close", me.onWsClose);
    connector.removeEventListener("message", me.onWsMessage);
    connector.removeEventListener("error", me.onWsError);
  }
  async open() {
    const me = this;
    if (me._openPromise) {
      return me._openPromise;
    }
    if (!me.address) {
      console.warn("Server me.address cannot be empty");
      return;
    }
    if (me.isOpened) {
      return true;
    }
    me.createWebSocketConnector();
    let detacher2;
    me._openPromise = new Promise((resolve) => {
      detacher2 = me.ion({
        open() {
          resolve(true);
        },
        error() {
          resolve(false);
        }
      });
    }).then((value) => {
      detacher2();
      me._openPromise = null;
      if (!value) {
        me.destroyWebSocketConnector();
      }
      return value;
    }).catch(() => {
      me._openPromise = null;
      me.destroyWebSocketConnector();
    });
    return me._openPromise;
  }
  close() {
    if (this.connector) {
      this.destroyWebSocketConnector();
      this.trigger("close");
    }
  }
  send(command, data = {}) {
    var _this$connector5;
    (_this$connector5 = this.connector) === null || _this$connector5 === void 0 ? void 0 : _this$connector5.send(JSON.stringify(_objectSpread2({
      command
    }, data)));
  }
  onWsOpen(event) {
    this.trigger("open", {
      event
    });
  }
  onWsClose(event) {
    this.trigger("close", {
      event
    });
  }
  onWsMessage(message) {
    try {
      const data = JSON.parse(message.data);
      this.trigger("message", {
        data
      });
    } catch (error) {
      this.trigger("error", {
        error
      });
    }
  }
  onWsError(error) {
    this.trigger("error", {
      error
    });
  }
};
_defineProperty(WebSocketManager, "webSocketImplementation", typeof WebSocket === "undefined" ? null : WebSocket);
_defineProperty(WebSocketManager, "configurable", {
  address: "",
  userName: "User",
  autoConnect: true
});
WebSocketManager._$name = "WebSocketManager";
var Finalizable = (Target) => class Finalizable extends (Target || Base$1) {
  static get $name() {
    return "Finalizable";
  }
  construct(...args) {
    super.construct(...args);
    this.finalizer = null;
    this.finalizing = null;
    this.isFinalized = false;
    this.isFinalizing = false;
  }
  doFinalize() {
    this.destroy();
  }
  finalize() {
    const me = this;
    let ret = me.finalizing;
    if (!ret && !me.isFinalized) {
      me.isFinalizing = true;
      me.finalizing = ret = me._awaitFinalizer();
    }
    return ret;
  }
  async _awaitFinalizer() {
    const me = this;
    try {
      await me.finalizer;
    } finally {
      me.finalizing = null;
      me.isFinalized = true;
      me.doFinalize();
    }
  }
};
var ABORTED = Symbol("dragAbort");
var INIT = Symbol("dragInit");
var DRAGGING = Symbol("dragDrag");
var DROPPED = Symbol("dragDrop");
var lockDirections = {
  x: "horizontal",
  y: "vertical"
};
var DragContext = class extends Base$1.mixin(Finalizable, Delayable, Identifiable) {
  static get configurable() {
    return {
      itemElement: null,
      scrollManager: null,
      monitoringConfig: null,
      source: null,
      target: null,
      targetElement: null,
      threshold: 5,
      touchStartDelay: 300
    };
  }
  static get identifiable() {
    return {};
  }
  construct(...args) {
    super.construct(...args);
    const me = this, {
      event
    } = me;
    Object.assign(me, {
      altKey: null,
      cleaners: [],
      ctrlKey: null,
      data: /* @__PURE__ */ new Map(),
      element: event.target,
      endEvent: null,
      lastMoveEvent: null,
      metaKey: null,
      previousTarget: null,
      scrollerAction: null,
      shiftKey: null,
      state: INIT,
      startEvent: event,
      touchStartTimer: null,
      _valid: true
    });
    if ("touches" in event && me.touchStartDelay) {
      me.touchStartTimer = me.setTimeout(() => me.touchStartTimer = null, me.touchStartDelay, "touchStartDelay");
    }
    EventHelper.on({
      element: globalThis,
      blur: "onWindowBlur",
      thisObj: me
    });
  }
  doDestroy() {
    const me = this, {
      source,
      target
    } = me;
    me.cleanup();
    if ((target === null || target === void 0 ? void 0 : target.dropping) === me) {
      target.dropping = null;
    }
    if ((source === null || source === void 0 ? void 0 : source.dragging) === me) {
      source.dragging = null;
    }
    super.doDestroy();
  }
  onWindowBlur() {
    if (this.started) {
      this.abort();
    }
  }
  get aborted() {
    return this.state === ABORTED;
  }
  get completed() {
    return this.isDestroying || this.aborted || this.endEvent !== null;
  }
  get pending() {
    return this.state === INIT;
  }
  get started() {
    return this.state !== INIT && !this.aborted;
  }
  get valid() {
    return this.started && this.targetElement != null && this._valid;
  }
  set valid(v) {
    this._valid = v;
  }
  async get(name) {
    if (this.aborted) {
      throw new Error("Data is not available on aborted drag");
    }
    if (!this.completed) {
      throw new Error("Data is not available until drag completion");
    }
    if (Array.isArray(name)) {
      return Promise.all(name.map((s) => this.get(s)));
    }
    let value = this.data.get(name);
    if (typeof value === "function") {
      value = await value();
      this.data.set(name, value);
    }
    return value;
  }
  has(name) {
    return this.data.has(name);
  }
  peek(name) {
    if (this.aborted) {
      throw new Error("Data is not available on aborted drag");
    }
    if (Array.isArray(name)) {
      return name.map((s) => this.peek(s));
    }
    let value = this.data.get(name);
    if (typeof value === "function") {
      value = true;
    }
    return value;
  }
  set(name, value) {
    this.data.set(name, value);
  }
  changeTarget(target, was) {
    if (target !== was) {
      const me = this;
      me._target = target;
      me.previousTarget = was;
      if (was) {
        was.dropping = null;
      }
      if (target) {
        target.dropping = me;
        if (target.dropping !== me) {
          target = null;
          me.valid = false;
        }
      }
      me._target = was;
    }
    return target;
  }
  updateTarget(target, was) {
    const me = this;
    if (was) {
      me.source.dragLeaveTarget(me, was);
    }
    if (target) {
      me.valid = true;
      target.dragMove(me);
      me.source.dragEnterTarget(me);
    }
  }
  updateTargetElement(targetElement) {
    let droppable, droppables, droppableSelector, i, t;
    for (t = targetElement; t; t = t.parentElement) {
      droppables = DomDataStore.get(t, "droppables");
      if (droppables) {
        for (i = 0; i < droppables.length; ++i) {
          droppable = droppables[i];
          if (droppable.dropRootElement.contains(targetElement)) {
            droppableSelector = droppable.droppableSelector;
            if (!droppableSelector || targetElement.closest(`#${DomHelper.getId(droppable.dropRootElement)} ${droppableSelector}`)) {
              this.target = droppable;
              if (this.target === droppable) {
                return;
              }
            }
          }
        }
      }
    }
  }
  abort() {
    const me = this, {
      element,
      source
    } = me;
    element === null || element === void 0 ? void 0 : element.getBoundingClientRect();
    if (me.state !== DROPPED) {
      me.state = ABORTED;
      me.cleanup();
    }
    source === null || source === void 0 ? void 0 : source.endDrag(me);
  }
  begin() {
    const me = this, {
      source
    } = me, ret = source.beforeDrag(me);
    if (ret !== false) {
      source.dragging = me;
    }
    return ret;
  }
  cleanup() {
    let cleaner;
    while (cleaner = this.cleaners.pop()) {
      cleaner();
    }
  }
  end(event) {
    const me = this, {
      lastMoveEvent: lastEvent,
      target
    } = me, {
      dragSwallowClickTime
    } = me.source;
    me.event = me.endEvent = event;
    me.syncFlags();
    if (me.started) {
      if ((lastEvent === null || lastEvent === void 0 ? void 0 : lastEvent.clientX) !== event.clientX || (lastEvent === null || lastEvent === void 0 ? void 0 : lastEvent.clientY) !== event.clientY || (lastEvent === null || lastEvent === void 0 ? void 0 : lastEvent.target) !== event.target) {
        me.track();
      }
      if (dragSwallowClickTime) {
        EventHelper.on({
          element: document,
          capture: true,
          expires: dragSwallowClickTime,
          once: true,
          click(event2) {
            event2.stopPropagation();
          }
        });
      }
      me.state = DROPPED;
      if (target !== me.source) {
        target === null || target === void 0 ? void 0 : target.dragDrop(me);
      }
    }
  }
  fakeKey(event, down) {
    const me = this, {
      lastMoveEvent
    } = me;
    if (lastMoveEvent && me.element) {
      let changed;
      lastMoveEvent.isKey = true;
      if (event.key === "Alt") {
        if (me.altKey !== down) {
          me.altKey = down;
          changed = true;
        }
      } else if (event.key === "Control") {
        if (me.ctrlKey !== down) {
          me.ctrlKey = down;
          changed = true;
        }
      }
      if (changed) {
        me.event = lastMoveEvent;
        me.track();
      }
    }
  }
  keyDown(event) {
    if (!this.completed) {
      if (event.key === "Escape") {
        this.abort();
      } else if (this.isDragToggleKey(event.key)) {
        this.fakeKey(event, true);
      }
    }
  }
  keyUp(event) {
    if (!this.completed && this.isDragToggleKey(event.key)) {
      this.fakeKey(event, false);
    }
  }
  getDistance(event) {
    return EventHelper.getDistanceBetween(this.startEvent, event);
  }
  isDragToggleKey(key) {
    return key === "Control" || key === "Alt";
  }
  move(event) {
    const me = this, {
      target
    } = event, distance = me.getDistance(event), significant = distance >= me.threshold;
    me.syncFlags();
    if (me.touchStartTimer) {
      if (significant) {
        me.abort();
      }
      return;
    }
    if (target && target.nodeType === Node.ELEMENT_NODE) {
      if (significant && !me.started) {
        me.event = event;
        if (me.start() === false) {
          me.abort();
          return;
        }
      }
      if (me.started && !me.completed) {
        me.lastMoveEvent = me.event = event;
        if (event.type === "touchmove") {
          event.preventDefault();
          event.stopImmediatePropagation();
        }
        me.track();
      }
    }
  }
  start() {
    const me = this, {
      scrollManager,
      monitoringConfig,
      source
    } = me, {
      draggingBodyCls: activeCls,
      dragLock
    } = source, element = source.dragRootElement;
    me.state = DRAGGING;
    if (scrollManager) {
      const detacher2 = scrollManager.startMonitoring(Objects.merge({
        scrollables: [{
          element
        }],
        direction: lockDirections[dragLock] || dragLock || "both",
        callback(scrollerAction) {
          const {
            lastMoveEvent
          } = me;
          if (lastMoveEvent && me.element) {
            lastMoveEvent.isScroll = true;
            me.event = lastMoveEvent;
            me.scrollerAction = scrollerAction;
            me.track();
            me.scrollerAction = null;
          }
        }
      }, monitoringConfig));
      me.cleaners.push(detacher2);
    }
    const rootEl = source.dragRootElement.closest(".b-outer") || document.body;
    rootEl.classList.add(activeCls);
    me.cleaners.push(() => rootEl.classList.remove(activeCls));
    if (source.startDrag(me) === false) {
      me.cleanup();
      return false;
    }
  }
  syncFlags() {
    const me = this, {
      event
    } = me;
    me.altKey = event.altKey;
    me.ctrlKey = event.ctrlKey || event.metaKey;
    me.metaKey = event.metaKey;
    me.shiftKey = event.shiftKey;
  }
  track() {
    const me = this, {
      event,
      source,
      target
    } = me;
    let targetElement = event.target, touch;
    if (event.type === "touchmove") {
      touch = event.changedTouches[0];
      targetElement = DomHelper.elementFromPoint(touch.clientX, touch.clientY);
    }
    me.targetElement = targetElement;
    if (target === me.target) {
      target === null || target === void 0 ? void 0 : target.dragMove(me);
    }
    source.trackDrag(me);
  }
};
_defineProperty(DragContext, "$name", "DragContext");
DragContext.prototype.STATE = DragContext.STATE = Object.freeze({
  ABORTED,
  INIT,
  DRAGGING,
  DROPPED
});
DragContext._$name = "DragContext";
var DragProxy = class extends Base$1.mixin(Factoryable) {
  static get type() {
    return "default";
  }
  static get configurable() {
    return {
      dragging: null
    };
  }
  static get factoryable() {
    return {
      defaultType: DragProxy
    };
  }
  updateDragging(drag, was) {
    if (was) {
      this.close(was);
    }
    if (drag) {
      this.open(drag);
    }
  }
  close(drag) {
  }
  open(drag) {
  }
  dragStart(drag) {
    this.dragging = drag;
  }
  dragMove(drag) {
  }
  dragEnd(drag) {
    this.dragging = null;
  }
};
DragProxy.initClass();
DragProxy._$name = "DragProxy";
var Draggable = (Target) => class Draggable extends (Target || Base$1) {
  static get $name() {
    return "Draggable";
  }
  static get configurable() {
    return {
      dragging: {
        $config: "nullify",
        value: null
      },
      draggingClsSelector: null,
      dragDocumentListeners: {
        element: document,
        keydown: "onDragKeyDown",
        keyup: "onDragKeyUp",
        contextmenu: "onDragContextMenu",
        mousemove: "onDragPointerMove",
        mouseup: "onDragPointerUp",
        pointerup: "onDragPointerUp",
        touchend: "onDragPointerUp",
        touchmove: {
          handler: "onDragPointerMove",
          passive: false
        }
      },
      dragItemSelector: null,
      dragItemOverCls: null,
      dragLock: null,
      dragMinDistance: 1,
      dragProxy: {
        $config: ["lazy", "nullify"],
        value: null
      },
      dragRootElement: {
        $config: "nullify",
        value: null
      },
      dragSameTargetDrop: false,
      dragSelector: null,
      ignoreSelector: null,
      dragSwallowClickTime: 50,
      dragThreshold: 5,
      dragTouchStartDelay: 300,
      dropTargetSelector: null,
      overItem: null,
      testConfig: {
        dragSwallowClickTime: 50
      }
    };
  }
  static get properties() {
    return {
      draggingCls: "b-draggable-active",
      draggingBodyCls: "b-draghelper-active",
      draggingItemCls: "b-dragging-item",
      draggingStartedCls: "b-draggable-started",
      draggableCls: "b-draggable"
    };
  }
  beforeDrag(drag) {
    const {
      dragRootElement,
      dragSelector,
      ignoreSelector
    } = this, target = dragSelector && drag.element.closest(dragSelector);
    return !dragSelector || Boolean(target && target === dragRootElement || dragRootElement.contains(target) && (!ignoreSelector || !drag.element.matches(ignoreSelector)));
  }
  dragStart(drag) {
  }
  dragOver(drag) {
  }
  dragEnterTarget(drag) {
  }
  dragLeaveTarget(drag, oldTarget) {
  }
  dragDrop(drag) {
  }
  dragEnd(drag) {
  }
  get activeDrag() {
    const {
      dragging: drag
    } = this;
    return drag !== null && drag !== void 0 && drag.started && !drag.completed ? drag : null;
  }
  get dragEventer() {
    return this.trigger ? this : null;
  }
  get draggingClassElement() {
    const {
      draggingClsSelector,
      dragRootElement
    } = this;
    return draggingClsSelector ? dragRootElement === null || dragRootElement === void 0 ? void 0 : dragRootElement.closest(draggingClsSelector) : dragRootElement;
  }
  beginDrag(drag) {
    const {
      draggingCls,
      draggingClassElement
    } = this;
    if (draggingCls && draggingClassElement) {
      draggingClassElement.classList.add(draggingCls);
      drag.cleaners.push(() => draggingClassElement.classList.remove(draggingCls));
    }
  }
  async endDrag(drag) {
    const me = this, {
      dragEventer,
      dragProxy
    } = me;
    if (drag.valid) {
      await me.dragDrop(drag);
    }
    if (me.isDestroyed) {
      return;
    }
    if (drag.pending) {
      drag.destroy();
    } else {
      me.dragEnd(drag);
      dragProxy === null || dragProxy === void 0 ? void 0 : dragProxy.dragEnd(drag);
      dragEventer === null || dragEventer === void 0 ? void 0 : dragEventer.trigger(drag.valid ? "drop" : "dragCancel", {
        drag,
        event: drag.event
      });
      me.finalizeDrag(drag);
    }
  }
  async finalizeDrag(drag) {
    var _drag$finalize;
    await ((_drag$finalize = drag.finalize) === null || _drag$finalize === void 0 ? void 0 : _drag$finalize.call(drag));
  }
  moveDrag(drag) {
    if (this.dragOver(drag) !== false) {
      const {
        dragEventer,
        dragProxy
      } = this;
      dragProxy === null || dragProxy === void 0 ? void 0 : dragProxy.dragMove(drag);
      dragEventer === null || dragEventer === void 0 ? void 0 : dragEventer.trigger("drag", {
        drag,
        event: drag.event
      });
    }
  }
  setupDragContext(event) {
    const me = this, {
      dragItemSelector,
      id
    } = me, {
      target
    } = event;
    return {
      event,
      id: id ? `${id}-drag-${me._nextDragId = (me._nextDragId || 0) + 1}` : null,
      itemElement: dragItemSelector ? target.closest(dragItemSelector) : target,
      touchStartDelay: me.dragTouchStartDelay,
      source: me,
      threshold: me.dragThreshold
    };
  }
  startDrag(drag) {
    const {
      draggingStartedCls,
      draggingClassElement,
      draggingItemCls,
      dragEventer,
      dragProxy
    } = this, {
      itemElement
    } = drag;
    if ((dragEventer === null || dragEventer === void 0 ? void 0 : dragEventer.trigger("beforeDragStart", {
      drag,
      event: drag.event
    })) === false) {
      return false;
    }
    if (draggingStartedCls && draggingClassElement) {
      draggingClassElement.classList.add(draggingStartedCls);
      drag.cleaners.push(() => draggingClassElement.classList.remove(draggingStartedCls));
    }
    if (draggingItemCls && itemElement) {
      itemElement.classList.add(draggingItemCls);
      drag.cleaners.push(() => itemElement.classList.remove(draggingItemCls));
    }
    dragProxy === null || dragProxy === void 0 ? void 0 : dragProxy.dragStart(drag);
    const result = this.dragStart(drag);
    if (result !== false) {
      dragEventer === null || dragEventer === void 0 ? void 0 : dragEventer.trigger("dragStart", {
        drag,
        event: drag.event
      });
    }
    return result;
  }
  trackDrag(drag) {
    var _drag$targetElement;
    const {
      dropTargetSelector
    } = this;
    drag.valid = !(dropTargetSelector && !((_drag$targetElement = drag.targetElement) !== null && _drag$targetElement !== void 0 && _drag$targetElement.closest(dropTargetSelector)));
    this.moveDrag(drag);
  }
  configureListeners(drag) {
    const me = this, listeners = ObjectHelper.assign({
      thisObj: me
    }, me.dragDocumentListeners);
    if ("touches" in drag.startEvent) {
      delete listeners.mousemove;
      delete listeners.mouseup;
    } else {
      delete listeners.contextmenu;
      delete listeners.touchmove;
      delete listeners.touchend;
      delete listeners.pointerup;
    }
    return listeners;
  }
  updateDragging(drag, old) {
    const me = this;
    if (drag) {
      const listeners = me.configureListeners(drag);
      drag.cleaners.push(EventHelper.on(listeners));
      me.beginDrag(drag);
    } else if (old) {
      old.destroy();
    }
  }
  changeDragProxy(config, existing) {
    return DragProxy.reconfigure(existing, config, {
      owner: this,
      defaults: {
        owner: this
      }
    });
  }
  updateDragRootElement(rootEl, was) {
    var _me$_dragRootDetacher;
    const me = this, {
      draggableCls,
      dragItemSelector,
      onDragItemMouseMove
    } = me;
    was === null || was === void 0 ? void 0 : was.classList.remove(draggableCls);
    (_me$_dragRootDetacher = me._dragRootDetacher) === null || _me$_dragRootDetacher === void 0 ? void 0 : _me$_dragRootDetacher.call(me);
    if (rootEl) {
      const listeners = {
        thisObj: me,
        element: rootEl,
        mousedown: "onDragMouseDown",
        touchstart: "onDragTouchStart",
        pointerdown: (e) => {
          var _e$target$releasePoin, _e$target;
          return e.pointerId && ((_e$target$releasePoin = (_e$target = e.target).releasePointerCapture) === null || _e$target$releasePoin === void 0 ? void 0 : _e$target$releasePoin.call(_e$target, e.pointerId));
        }
      };
      if (onDragItemMouseMove) {
        listeners.mousemove = {
          delegate: dragItemSelector,
          handler: "onDragItemMouseMove"
        };
      }
      if (me.dragItemOverCls || onDragItemMouseMove || me.onDragItemMouseEnter || me.onDragItemMouseLeave) {
        Object.assign(listeners, {
          mouseover: {
            delegate: dragItemSelector,
            handler: "onDragItemMouseOver"
          },
          mouseout: {
            delegate: dragItemSelector,
            handler: "onDragItemMouseOut"
          }
        });
      }
      rootEl.classList.add(draggableCls);
      me._dragRootDetacher = EventHelper.on(listeners);
    }
  }
  onDragItemMouseOver(event) {
    this.overItem = event;
  }
  onDragItemMouseOut(event) {
    if (!this.dragging) {
      this.overItem = event;
    }
  }
  changeOverItem(event) {
    this.enterLeaveEvent = event;
    if (event.type === "mouseout") {
      var _event$relatedTarget;
      return ((_event$relatedTarget = event.relatedTarget) === null || _event$relatedTarget === void 0 ? void 0 : _event$relatedTarget.closest(this.dragItemSelector)) || null;
    } else {
      return event.target.closest(this.dragItemSelector);
    }
  }
  updateOverItem(overItem, oldOverItem) {
    const me = this, {
      dragItemOverCls
    } = me;
    if (oldOverItem) {
      var _me$onDragItemMouseLe;
      dragItemOverCls && oldOverItem.classList.remove(dragItemOverCls);
      (_me$onDragItemMouseLe = me.onDragItemMouseLeave) === null || _me$onDragItemMouseLe === void 0 ? void 0 : _me$onDragItemMouseLe.call(me, me.enterLeaveEvent, oldOverItem);
    }
    if (overItem) {
      var _me$onDragItemMouseEn;
      dragItemOverCls && overItem.classList.add(dragItemOverCls);
      (_me$onDragItemMouseEn = me.onDragItemMouseEnter) === null || _me$onDragItemMouseEn === void 0 ? void 0 : _me$onDragItemMouseEn.call(me, me.enterLeaveEvent, overItem);
    }
  }
  onDragContextMenu(event) {
    event.preventDefault();
  }
  onDragKeyDown(event) {
    this.dragging.keyDown(event);
  }
  onDragKeyUp(event) {
    this.dragging.keyUp(event);
  }
  onDragMouseDown(event) {
    if (event.button === 0) {
      this.onDragPointerDown(event);
    }
  }
  onDragPointerDown(event) {
    let {
      dragging: drag
    } = this;
    if (!drag) {
      drag = this.setupDragContext(event);
      if (drag) {
        drag = new DragContext(drag);
        if (drag.begin() === false) {
          drag.destroy();
        }
      }
    } else if (!drag.isFinalizing) {
      drag.abort();
    }
  }
  changeDragging(value, was) {
    was === null || was === void 0 ? void 0 : was.destroy();
    return value;
  }
  onDragPointerMove(event) {
    const {
      dragging: drag
    } = this;
    if (drag && !drag.completed) {
      drag === null || drag === void 0 ? void 0 : drag.move(event);
    }
  }
  onDragPointerUp(event) {
    const {
      dragging: drag
    } = this;
    if (drag && !drag.completed) {
      drag.end(event);
      this.endDrag(drag);
    }
  }
  onDragTouchStart(event) {
    if (event.touches.length === 1) {
      this.onDragPointerDown(event);
    }
  }
};
var Droppable = (Target) => class Droppable extends (Target || Base$1) {
  static get $name() {
    return "Droppable";
  }
  static get configurable() {
    return {
      droppableSelector: null,
      dropping: null,
      dropRootElement: {
        $config: "nullify",
        value: null
      }
    };
  }
  get dropEventer() {
    return this.trigger ? this : null;
  }
  get droppableCls() {
    return "b-droppable";
  }
  dragEnter(drag) {
    var _this$dropEventer;
    return (_this$dropEventer = this.dropEventer) === null || _this$dropEventer === void 0 ? void 0 : _this$dropEventer.trigger("dragEnter", {
      drag,
      event: drag.event
    });
  }
  dragMove(drag) {
    var _this$dropEventer2;
    return (_this$dropEventer2 = this.dropEventer) === null || _this$dropEventer2 === void 0 ? void 0 : _this$dropEventer2.trigger("dragMove", {
      drag,
      event: drag.event
    });
  }
  dragDrop(drag) {
    var _this$dropEventer3;
    return (_this$dropEventer3 = this.dropEventer) === null || _this$dropEventer3 === void 0 ? void 0 : _this$dropEventer3.trigger("drop", {
      drag,
      event: drag.event
    });
  }
  dragLeave(drag) {
    var _this$dropEventer4;
    return (_this$dropEventer4 = this.dropEventer) === null || _this$dropEventer4 === void 0 ? void 0 : _this$dropEventer4.trigger("dragLeave", {
      drag,
      event: drag.event
    });
  }
  changeDropping(dropping, was) {
    if (dropping !== was) {
      const me = this;
      if (was) {
        if (was.aborted || !was.completed) {
          me.dragLeave(was);
        }
      }
      if (dropping) {
        me._dropping = dropping;
        if (me.dragEnter(dropping) === false) {
          dropping = null;
        }
        me._dropping = was;
      }
    }
    return dropping;
  }
  updateDropRootElement(rootEl, was) {
    const me = this, {
      droppableCls
    } = me;
    let droppables, i, removeCls;
    if (was) {
      droppables = DomDataStore.get(was, "droppables");
      removeCls = true;
      if (Array.isArray(droppables) && (i = droppables.indexOf(me)) > -1) {
        if (droppables.length < 2) {
          DomDataStore.remove(was, "droppables");
        } else {
          droppables.splice(i, 1);
          droppables.forEach((d) => {
            if (droppableCls === d.droppableCls) {
              removeCls = false;
            }
          });
        }
      }
      removeCls && was.classList.remove(droppableCls);
    }
    if (rootEl) {
      droppables = DomDataStore.get(rootEl, "droppables");
      if (droppables) {
        droppables.push(me);
      } else {
        DomDataStore.set(rootEl, "droppables", [me]);
      }
      rootEl.classList.add(droppableCls);
    }
  }
};
var Featureable = (Target) => class Featureable extends (Target || Base$1) {
  static get $name() {
    return "Featureable";
  }
  static get configurable() {
    return {
      features: null
    };
  }
  static get declarable() {
    return [
      "featureable"
    ];
  }
  static setupFeatureable(cls) {
    const featureable = _objectSpread2({
      ownerName: "client"
    }, cls.featureable);
    featureable.factory.initClass();
    Reflect.defineProperty(cls, "featureable", {
      get() {
        return featureable;
      }
    });
  }
  doDestroy() {
    const features = this.features;
    super.doDestroy();
    for (const name in features) {
      var _feature$destroy;
      const feature = features[name];
      (_feature$destroy = feature.destroy) === null || _feature$destroy === void 0 ? void 0 : _feature$destroy.call(feature);
    }
  }
  hasFeature(name) {
    var _this$features;
    return Boolean((_this$features = this.features) === null || _this$features === void 0 ? void 0 : _this$features[name]);
  }
  changeFeatures(features, was) {
    if (this.isDestroying) {
      return;
    }
    const me = this, {
      featureable
    } = me.constructor, manager = me.$features || (me.$features = new DynamicObject({
      configName: "features",
      factory: featureable.factory,
      owner: me,
      ownerName: featureable.ownerName
    }));
    manager.update(features);
    if (!was) {
      return manager.target;
    }
  }
  get widgetClass() {
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options), {
      features
    } = result;
    if (features) {
      for (const featureName in features) {
        if (Object.keys(features[featureName]).length === 0) {
          features[featureName] = true;
        }
      }
    }
    return result;
  }
};
var EDGES = {
  e: "b-hover-edge",
  t: "b-hover-top",
  r: "b-hover-right",
  b: "b-hover-bottom",
  l: "b-hover-left"
};
var EDGE_CLASSES = {
  [EDGES.e]: 1,
  [EDGES.t]: 1,
  [EDGES.r]: 1,
  [EDGES.b]: 1,
  [EDGES.l]: 1
};
var ZONES = {
  t: [EDGES.e, EDGES.t],
  r: [EDGES.e, EDGES.r],
  b: [EDGES.e, EDGES.b],
  l: [EDGES.e, EDGES.l],
  tr: [EDGES.e, EDGES.t, EDGES.r],
  bl: [EDGES.e, EDGES.b, EDGES.l],
  tl: [EDGES.e, EDGES.t, EDGES.l],
  br: [EDGES.e, EDGES.b, EDGES.r]
};
var Hoverable = (Target) => class Hoverable extends Target.mixin(Delayable) {
  static get $name() {
    return "Hoverable";
  }
  static get configurable() {
    return {
      hoverCls: null,
      hoverAnimationCls: null,
      hoverRootCls: null,
      hoverRootActiveCls: null,
      hoverDelay: null,
      hoverElement: null,
      hoverIgnoreElement: null,
      hoverEdges: null,
      hoverEdgeSize: 10,
      hoverRootElement: {
        $config: "nullify",
        value: null
      },
      hoverSelector: null,
      hoverTarget: {
        $config: "nullify",
        value: null
      },
      hoverTrack: null,
      hoverZone: null
    };
  }
  static get delayable() {
    return {
      setHoverTarget: 0
    };
  }
  hoverEnter(leaving) {
  }
  hoverIgnore(element) {
    var _this$hoverIgnoreElem;
    return (_this$hoverIgnoreElem = this.hoverIgnoreElement) === null || _this$hoverIgnoreElem === void 0 ? void 0 : _this$hoverIgnoreElem.contains(element);
  }
  hoverLeave(leaving) {
  }
  hoverMove(event) {
  }
  onHoverMouseMove(event) {
    const me = this, {
      hoverEdges,
      hoverEdgeSize,
      hoverTarget
    } = me;
    if (hoverTarget) {
      if (hoverEdges) {
        const {
          top,
          left,
          width,
          height,
          right,
          bottom
        } = hoverTarget.getBoundingClientRect(), {
          clientX,
          clientY
        } = event, centerX = left + width / 2, centerY = top + height / 2, t = clientY < (hoverEdgeSize ? top + hoverEdgeSize : centerY), r = clientX >= (hoverEdgeSize ? right - hoverEdgeSize : centerX), b = clientY >= (hoverEdgeSize ? bottom - hoverEdgeSize : centerY), l = clientX < (hoverEdgeSize ? left + hoverEdgeSize : centerX), tb = t || b ? t ? "t" : "b" : "", rl = r || l ? r ? "r" : "l" : "";
        me.hoverZone = (hoverEdges.includes(tb) ? tb : "") + (hoverEdges.includes(rl) ? rl : "");
      }
      me.hoverEvent = event;
      me.hoverTrack && me.hoverMove(event);
    }
  }
  onHoverMouseOver(event) {
    this.hoverEvent = event;
    this.hoverElement = event.target;
  }
  onHoverMouseOut(event) {
    this.hoverEvent = event;
    this.hoverElement = event.relatedTarget;
  }
  updateHoverDelay(delay2) {
    this.setHoverTarget.delay = delay2;
  }
  changeHoverEdges(edges) {
    return edges === true ? "trbl" : (edges || "").replace("v", "tb").replace("h", "lr");
  }
  updateHoverEdges() {
    this.syncHoverListeners();
  }
  changeHoverElement(element) {
    if (!this.hoverIgnore(element)) {
      return element;
    }
  }
  updateHoverElement(hoverEl) {
    const {
      hoverSelector
    } = this;
    if (hoverSelector) {
      var _hoverEl;
      hoverEl = (_hoverEl = hoverEl) === null || _hoverEl === void 0 ? void 0 : _hoverEl.closest(hoverSelector);
    }
    this.setHoverTarget(hoverEl);
  }
  updateHoverRootElement(rootEl, was) {
    const {
      hoverRootCls
    } = this;
    if (hoverRootCls) {
      was === null || was === void 0 ? void 0 : was.classList.remove(hoverRootCls);
      rootEl === null || rootEl === void 0 ? void 0 : rootEl.classList.add(hoverRootCls);
    }
    this.syncHoverListeners();
  }
  changeHoverTarget(hoverEl, was) {
    if (was) {
      this.hoverZone = null;
    }
    return hoverEl;
  }
  updateHoverTarget(hoverEl, was) {
    const me = this, {
      hoverCls,
      hoverAnimationCls,
      hoverRootActiveCls,
      hoverRootElement
    } = me;
    if (hoverRootActiveCls) {
      hoverRootElement === null || hoverRootElement === void 0 ? void 0 : hoverRootElement.classList[hoverEl ? "add" : "remove"](hoverRootActiveCls);
    }
    if (was) {
      hoverCls && was.classList.remove(hoverCls);
      hoverAnimationCls && was.classList.remove(hoverAnimationCls);
      me.hoverLeave(was);
    }
    if (hoverEl) {
      hoverCls && hoverEl.classList.add(hoverCls);
      me.hoverEnter(was);
      if (me.hoverTrack) {
        me.hoverMove(me.hoverEvent);
      }
      if (hoverAnimationCls) {
        hoverEl.getBoundingClientRect();
        hoverEl.classList.add(hoverAnimationCls);
      }
    }
  }
  updateHoverTrack() {
    this.syncHoverListeners();
  }
  updateHoverZone(zone) {
    const {
      hoverAnimationCls,
      hoverTarget
    } = this;
    if (hoverTarget) {
      const {
        className
      } = hoverTarget, cls = DomClassList.change(className, zone ? ZONES[zone] : null, EDGE_CLASSES);
      if (className !== cls) {
        hoverTarget.className = cls;
        if (zone && hoverAnimationCls) {
          hoverTarget.classList.remove(hoverAnimationCls);
          hoverTarget.getBoundingClientRect();
          hoverTarget.classList.add(hoverAnimationCls);
        }
      }
    }
  }
  setHoverTarget(target) {
    this.hoverTarget = target;
  }
  syncHoverListeners() {
    var _me$_hoverRootDetache;
    const me = this, element = me.hoverRootElement, listeners = {
      element,
      thisObj: me,
      mouseover: "onHoverMouseOver",
      mouseout: "onHoverMouseOut"
    };
    if (me.hoverTrack || me.hoverEdges) {
      listeners.mousemove = "onHoverMouseMove";
    }
    (_me$_hoverRootDetache = me._hoverRootDetacher) === null || _me$_hoverRootDetache === void 0 ? void 0 : _me$_hoverRootDetache.call(me);
    me._hoverRootDetacher = element && EventHelper.on(listeners);
  }
};
var LoadMaskable = (Target) => class LoadMaskable extends Target {
  static get $name() {
    return "LoadMaskable";
  }
  static get configurable() {
    return {
      loadMaskDefaults: {
        useTransition: true,
        showDelay: 1e3
      },
      loadMaskError: {
        icon: "b-icon b-icon-warning",
        autoClose: 3e3,
        showDelay: 0
      },
      loadMask: {
        text: "L{GridBase.loadMask}"
      },
      syncMask: {
        text: "L{GridBase.syncMask}"
      },
      localizableProperties: ["loadMask.text", "syncMask.text"],
      testConfig: {
        loadMaskError: {
          icon: "b-icon b-icon-warning",
          autoClose: 500,
          showDelay: 0
        }
      }
    };
  }
  applyLoadMask() {
    const me = this, {
      loadMask
    } = me;
    if (loadMask) {
      me.masked = Mask.mergeConfigs(me.loadMaskDefaults, loadMask);
    }
    return me.masked;
  }
  applyMaskError(error) {
    const {
      loadMaskError,
      masked
    } = this;
    if (loadMaskError === false) {
      masked.hide();
    } else if (masked) {
      ObjectHelper.assign(masked.errorDefaults, loadMaskError);
      masked.error = error;
    }
    return masked;
  }
  get widgetClass() {
  }
};
var excludedPropNames = {
  constructor: 1,
  prototype: 1,
  name: 1,
  length: 1,
  arguments: 1,
  caller: 1,
  callee: 1,
  __proto__: 1
};
var Override = class {
  static apply(override) {
    if (!override.target)
      throw new Error("Override must specify what it overrides, using static getter target");
    if (!override.target.class)
      throw new Error("Override must specify which class it overrides, using target.class");
    if (!this.shouldApplyOverride(override))
      return false;
    const staticKeys = Object.getOwnPropertyNames(override), instanceKeys = Object.getOwnPropertyNames(override.prototype);
    staticKeys.splice(staticKeys.indexOf("target"), 1);
    this.internalOverrideAll(override.target.class, staticKeys, override);
    this.internalOverrideAll(override.target.class.prototype, instanceKeys, override.prototype);
    return true;
  }
  static internalOverrideAll(targetClass, properties, overrideDefinition) {
    Reflect.ownKeys(overrideDefinition).forEach((key) => {
      if (properties.includes(key) && !excludedPropNames[key]) {
        const desc = Object.getOwnPropertyDescriptor(overrideDefinition, key);
        let currentTargetClass = targetClass;
        let targetProperty = null;
        while (!targetProperty && currentTargetClass) {
          targetProperty = Object.getOwnPropertyDescriptor(currentTargetClass, key);
          if (!targetProperty) {
            currentTargetClass = Object.getPrototypeOf(currentTargetClass);
          }
        }
        if (targetProperty) {
          this.internalOverride(currentTargetClass, key, desc, targetProperty);
        }
      }
    });
  }
  static internalOverride(target, key, desc, targetDesc) {
    const overrides = target._overridden = target._overridden || {};
    overrides[key] = target[key];
    if (targetDesc.get) {
      Object.defineProperty(target, key, {
        enumerable: false,
        configurable: true,
        get: desc.get
      });
    } else {
      target[key] = desc.value;
    }
  }
  static shouldApplyOverride(override) {
    const config = override.target;
    if (!config.maxVersion && !config.minVersion)
      return true;
    if (!config.product)
      throw new Error("Override must specify product when using versioning");
    if (config.maxVersion && VersionHelper[config.product].isNewerThan(config.maxVersion)) {
      return false;
    }
    if (config.minVersion && VersionHelper[config.product].isOlderThan(config.minVersion)) {
      return false;
    }
    return true;
  }
};
Override._$name = "Override";
var {
  defineProperty
} = Object;
var {
  hasOwn
} = ObjectHelper;
var fencibleSymbol = Symbol("fencible");
var NONE = [];
var distinct = (array) => Array.from(new Set(array));
var parseNames = (names) => names ? distinct(StringHelper.split(names)) : NONE;
var fenceMethod = (target, name, options) => {
  if (options === true) {
    options = name;
  }
  if (!ObjectHelper.isObject(options)) {
    options = {
      all: options
    };
  }
  let any = parseNames(options.any);
  const all = parseNames(options.all), lock = options.lock ? parseNames(options.lock) : distinct(all.concat(any)), implName = name + "Impl", fence = function(...params) {
    const me = this, fences = hasOwn(me, fencibleSymbol) ? me[fencibleSymbol] : me[fencibleSymbol] = {}, isFree = (key) => !fences[key];
    if (all.every(isFree) && (!any || any.some(isFree))) {
      try {
        lock.forEach((key) => fences[key] = (fences[key] || 0) + 1);
        return me[implName](...params);
      } finally {
        lock.forEach((key) => --fences[key]);
      }
    }
  };
  any = any.length ? any : null;
  !target[implName] && defineProperty(target, implName, {
    configurable: true,
    value: target[name]
  });
  defineProperty(target, name, {
    configurable: true,
    value: fence
  });
};
var Fencible = (Target) => {
  var _class;
  return _class = class Fencible extends (Target || Base$1) {
    static setupFenced(cls) {
      let {
        fenced
      } = cls;
      const statics = fenced.static, pairs = [];
      if (statics) {
        fenced = _objectSpread2({}, fenced);
        delete fenced.static;
        pairs.push([statics, cls]);
      }
      pairs.push([fenced, cls.prototype]);
      for (const [methods, target] of pairs) {
        for (const methodName in methods) {
          fenceMethod(target, methodName, methods[methodName]);
        }
      }
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "$name", "Fencible"), _defineProperty(_class, "declarable", [
    "fenced"
  ]), _class;
};
var MILLIS_PER_MINUTE = 60 * 1e3;
var MILLIS_PER_HOUR$1 = 60 * MILLIS_PER_MINUTE;
var MILLIS_PER_DAY$1 = 24 * MILLIS_PER_HOUR$1;
var timeRe = /(\d+)?:?(\d*)/;
var DayTime = class {
  static format(timeOfDay) {
    const h = Math.floor(timeOfDay / MILLIS_PER_HOUR$1), m = Math.floor(timeOfDay / MILLIS_PER_MINUTE) % 60;
    return `${h}:${m < 10 ? "0" : ""}${m}`;
  }
  static parse(time) {
    const type = typeof time;
    if (type === "string") {
      const match = timeRe.exec(time);
      time = Number(match[1] || 0) * MILLIS_PER_HOUR$1 + Number(match[2] || 0) * MILLIS_PER_MINUTE;
    } else if (type !== "number") {
      time = DateHelper.getTimeOfDay(time);
    } else if (time <= 24) {
      time *= MILLIS_PER_HOUR$1;
    }
    return Math.min(Math.max(Math.floor(time), 0), MILLIS_PER_DAY$1);
  }
  constructor(config) {
    let startShift = 0, startTime, endTime;
    if (config !== null && config !== void 0 && config.isDayView) {
      startShift = config.dayStartShift;
      startTime = config.dayStartTime;
      endTime = config.dayEndTime;
    } else if (typeof config === "number") {
      startShift = startTime = endTime = config;
    } else if (config) {
      startShift = config.startShift;
      startTime = config.timeStart;
      endTime = config.timeEnd;
    }
    this.startShift = startShift = DayTime.parse(startShift || 0);
    this.timeEnd = (endTime == null ? (startShift + MILLIS_PER_DAY$1) % MILLIS_PER_DAY$1 : DayTime.parse(endTime)) || MILLIS_PER_DAY$1;
    this.timeStart = startTime == null ? startShift : DayTime.parse(startTime);
  }
  get startHour() {
    return Math.floor(this.timeStart / MILLIS_PER_HOUR$1);
  }
  get endHour() {
    return Math.floor(this.timeEnd / MILLIS_PER_HOUR$1);
  }
  get startTimeOffsetMs() {
    const {
      startShift,
      timeStart
    } = this;
    return timeStart < startShift ? MILLIS_PER_DAY$1 - startShift + timeStart : timeStart - startShift;
  }
  get today() {
    return this.startOfDay(new Date());
  }
  ceil(date2) {
    const ret = this.startOfDay(date2);
    if (ret < date2) {
      ret.setDate(ret.getDate() + 1);
    }
    return ret;
  }
  contains(date2) {
    return !this.outside(date2);
  }
  dateKey(date2) {
    date2 = this.shiftDate(date2, -1);
    return DateHelper.makeKey(date2);
  }
  dayOfDate(date2) {
    return this.shiftDate(DateHelper.clearTime(date2));
  }
  dayOfWeek(date2) {
    date2 = this.shiftDate(date2, -1);
    return date2.getDay();
  }
  delta(date2, unit = "ms") {
    const {
      timeStart
    } = this, time = DayTime.parse(date2), t = (this.startShift && time < timeStart ? time + MILLIS_PER_DAY$1 : time) - timeStart;
    return unit === "ms" ? t : DateHelper.as(unit, t, "ms");
  }
  duration(unit = "ms") {
    const {
      timeStart,
      timeEnd
    } = this, millis = timeStart < timeEnd ? timeEnd - timeStart : MILLIS_PER_DAY$1 - timeStart + timeEnd;
    return unit === "ms" ? millis : DateHelper.as(unit, millis, "ms");
  }
  equals(other) {
    return this.startShift === (other === null || other === void 0 ? void 0 : other.startShift) && this.timeStart === other.timeStart && this.timeEnd === other.timeEnd;
  }
  intersects(startDate, endDate) {
    const me = this, {
      timeStart,
      timeEnd
    } = me, [date0, date1] = me._dateRangeArgs(startDate, endDate), [start, end] = me.timeRange(date0, date1);
    if (timeStart < timeEnd) {
      if (start < end) {
        return start < timeEnd && timeStart <= end;
      }
      return start < timeEnd || timeStart <= end;
    }
    return !(start < end) || start < timeEnd || timeStart <= end;
  }
  isIntraDay(startDate, endDate) {
    const me = this, [date0, date1] = me._dateRangeArgs(startDate, endDate), dayStart = me.startOfDay(date0), diff = MILLIS_PER_DAY$1 - DateHelper.diff(dayStart, date1, "ms");
    if (diff < 0) {
      return false;
    }
    return diff > 0 || dayStart < date0;
  }
  isInterDay(timeSpan) {
    return timeSpan.allDay || !this.isIntraDay(...arguments);
  }
  outside(date2) {
    const {
      startShift,
      timeStart,
      timeEnd
    } = this, time = DayTime.parse(date2);
    if (timeStart < timeEnd) {
      if (time < timeStart) {
        return time < startShift ? 1 : -1;
      }
      if (time < timeEnd) {
        return 0;
      }
      return time < startShift ? -1 : 1;
    }
    if (time < timeEnd || time >= timeStart) {
      return 0;
    }
    return time < startShift ? 1 : -1;
  }
  parseKey(key) {
    return this.dayOfDate(DateHelper.parseKey(key));
  }
  shiftDate(date2, direction = 1) {
    const {
      startShift
    } = this, type = typeof date2;
    date2 = type === "number" ? new Date(date2) : type === "string" ? DateHelper.parse(date2) : new Date(date2.getTime());
    if (direction && startShift) {
      date2.setMilliseconds(direction > 0 ? startShift : -startShift);
    }
    return date2;
  }
  sortEvents(date2, events) {
    const startOfDay = this.startOfDay(date2);
    return events === null || events === void 0 ? void 0 : events.sort((event1, event2) => {
      event1 = event1.eventRecord || event1;
      event2 = event2.eventRecord || event2;
      let {
        startDate: start1
      } = event1, {
        startDate: start2
      } = event2;
      if (!start1) {
        return -1;
      }
      if (!start2) {
        return 1;
      }
      start1 = start1 < startOfDay ? startOfDay : start1;
      start2 = start2 < startOfDay ? startOfDay : start2;
      return start1 - start2 || event2.endDate - start2 - (event1.endDate - start1);
    });
  }
  startOfDay(date2) {
    date2 = this.shiftDate(date2, -1);
    date2 = DateHelper.clearTime(date2);
    date2 = this.shiftDate(date2);
    return date2;
  }
  timeRange(startDate, endDate) {
    const [start, end] = this._dateRangeArgs(startDate, endDate);
    return [DateHelper.getTimeOfDay(start), DateHelper.getTimeOfDay(end)];
  }
  toString() {
    const {
      startShift,
      timeEnd,
      timeStart
    } = this, suffix = startShift ? `@${DayTime.format(startShift)}` : "", prefix = DayTime.format(timeStart);
    if (timeStart === timeEnd) {
      return startShift ? suffix : prefix;
    }
    return `${prefix}-${DayTime.format(timeEnd)}${suffix}`;
  }
  _dateRangeArgs(startDate, endDate) {
    return startDate.isModel ? [startDate.startDate, startDate.endingDate] : [startDate, endDate];
  }
};
DayTime.MIDNIGHT = new DayTime({
  startShift: 0,
  timeStart: 0,
  timeEnd: 24
});
DayTime.MILLIS_PER_MINUTE = MILLIS_PER_MINUTE;
DayTime.MILLIS_PER_HOUR = MILLIS_PER_HOUR$1;
DayTime.MILLIS_PER_DAY = MILLIS_PER_DAY$1;
DayTime._$name = "DayTime";
var Month = class extends Events(Base$1) {
  static get configurable() {
    return {
      date: {
        $config: {
          equal: "date"
        },
        value: DateHelper.clearTime(new Date())
      },
      month: null,
      year: null,
      weekStartDay: null,
      hideNonWorkingDays: null,
      nonWorkingDays: null,
      sixWeeks: null
    };
  }
  configure(config) {
    super.configure(config);
    this.updateDayNumbers();
    if (config.date) {
      this.date = config.date;
    }
    this.generation = 0;
  }
  changeDate(date2) {
    if (this.isConfiguring) {
      return;
    }
    date2 = typeof date2 === "string" ? DateHelper.parse(date2, "YYYY-MM-DD") : new Date(date2);
    if (isNaN(date2)) {
      throw new Error("Month date ingestion must be passed a Date, or a valid YYYY-MM-DD date string");
    }
    return date2;
  }
  updateDate(newDate, oldDate) {
    const me = this, {
      dayColumnIndex,
      weekCount
    } = me, monthStart = DateHelper.getFirstDateOfMonth(newDate), monthEnd = DateHelper.getLastDateOfMonth(monthStart), startWeekDay = dayColumnIndex[monthStart.getDay()], endWeekDay = dayColumnIndex[monthEnd.getDay()], yearChanged = !oldDate || newDate.getFullYear() !== oldDate.getFullYear(), monthChanged = !oldDate || newDate.getMonth() !== oldDate.getMonth(), changes = me.eventListeners && (oldDate ? newDate.getDate() !== oldDate.getDate() | (me.getWeekId(newDate) !== me.getWeekId(oldDate)) << 1 | monthChanged << 2 | yearChanged << 3 : 15);
    me._year = newDate.getFullYear();
    me._month = newDate.getMonth();
    me.startDayOfMonth = 1 - startWeekDay;
    me.endDayOfMonth = monthEnd.getDate() + (6 - endWeekDay);
    if (me.sixWeeks) {
      me.endDayOfMonth += (6 - me.weekCount) * 7;
    }
    if (!me.weekBase || yearChanged) {
      me.calculateWeekBase();
    }
    if (monthChanged || yearChanged) {
      me.generation++;
    }
    if (changes) {
      const event = {
        newDate,
        oldDate,
        changes: {
          d: true,
          w: Boolean(changes & 2),
          m: Boolean(changes & 12),
          y: Boolean(changes & 8),
          r: me.weekCount !== weekCount
        }
      };
      me.trigger("dateChange", event);
      if (changes & 2) {
        me.trigger("weekChange", event);
      }
      if (changes & 12) {
        me.trigger("monthChange", event);
      }
      if (changes & 8) {
        me.trigger("yearChange", event);
      }
    }
  }
  calculateWeekBase() {
    const me = this, {
      dayColumnIndex
    } = me, jan1 = new Date(me.year, 0, 1), dec31 = new Date(me.year, 11, 31), january = me.month ? me.getOtherMonth(jan1) : me;
    if (me.dayColumnIndex[jan1.getDay()] > 3) {
      me.weekBase = january.startDate;
    } else {
      me.weekBase = new Date(me.year, 0, january.startDayOfMonth - 7);
    }
    const dec31Week = Math.floor(DateHelper.diff(me.weekBase, dec31, "day") / 7);
    me.has53weeks = dec31Week === 53 && dayColumnIndex[dec31.getDay()] > 2;
  }
  getWeekStart(week) {
    if (typeof week === "number") {
      return DateHelper.add(this.weekBase, Math.max(week, 1) * 7, "day");
    }
    const me = this, [year, weekOfYear] = week;
    if (year === me.year) {
      return me.getWeekStart(weekOfYear);
    }
    return me.getOtherMonth(new Date(year, 0, 1)).getWeekStart(weekOfYear);
  }
  getOtherMonth(date2) {
    const me = this, result = me === otherMonth ? new Month(null) : otherMonth;
    result.configure({
      weekBase: null,
      weekStartDay: me.weekStartDay,
      nonWorkingDays: me.nonWorkingDays,
      hideNonWorkingDays: me.hideNonWorkingDays,
      sixWeeks: me.sixWeeks,
      date: new Date(date2.getFullYear(), 0, 1)
    });
    result.date = date2;
    result.updateDate(result.date, result.date);
    return result;
  }
  changeYear(year) {
    const newDate = new Date(this.date);
    newDate.setFullYear(year);
    this.date = newDate;
  }
  changeMonth(month2) {
    const newDate = new Date(this.date);
    newDate.setMonth(month2);
    this.date = newDate;
  }
  get weekStartDay() {
    return typeof this._weekStartDay === "number" ? this._weekStartDay : DateHelper.weekStartDay;
  }
  updateWeekStartDay() {
    const me = this;
    me.updateDayNumbers();
    if (!me.isConfiguring && me.date) {
      me.weekBase = null;
      me.updateDate(me.date, me.date);
    }
  }
  get nonWorkingDays() {
    return this._nonWorkingDays || DateHelper.nonWorkingDays;
  }
  changeNonWorkingDays(nonWorkingDays) {
    return ObjectHelper.assign({}, nonWorkingDays);
  }
  updateNonWorkingDays() {
    this.updateDayNumbers();
  }
  updateHideNonWorkingDays() {
    this.updateDayNumbers();
  }
  updateSixWeeks() {
    if (!this.isConfiguring) {
      this.updateDate(this.date, this.date);
    }
  }
  get dayCount() {
    return this.endDayOfMonth + 1 - this.startDayOfMonth;
  }
  get weekCount() {
    return this.dayCount / 7;
  }
  get startDate() {
    const me = this;
    if (me.year != null && me.month != null && me.startDayOfMonth != null) {
      return new Date(me.year, me.month, me.startDayOfMonth);
    }
  }
  get endDate() {
    const me = this;
    if (me.year != null && me.month != null && me.startDayOfMonth != null) {
      return new Date(me.year, me.month, me.endDayOfMonth);
    }
  }
  eachDay(fn2) {
    for (let dayOfMonth = this.startDayOfMonth; dayOfMonth <= this.endDayOfMonth; dayOfMonth++) {
      fn2(new Date(this.year, this.month, dayOfMonth));
    }
  }
  eachWeek(fn2) {
    const me = this, {
      weekCount
    } = me;
    for (let dayOfMonth = me.startDayOfMonth, week = 0; week < weekCount; week++) {
      const weekDates = [], weekOfYear = me.getWeekNumber(new Date(me.year, me.month, dayOfMonth));
      for (let day2 = 0; day2 < 7; day2++, dayOfMonth++) {
        weekDates.push(new Date(me.year, me.month, dayOfMonth));
      }
      fn2(weekOfYear, weekDates);
    }
  }
  getWeekNumber(date2) {
    const me = this;
    date2 = DateHelper.clearTime(date2);
    if (date2.getFullYear() !== me.year) {
      return me.getOtherMonth(new Date(date2.getFullYear(), 0, 1)).getWeekNumber(date2);
    }
    let weekNo = Math.floor(DateHelper.diff(me.weekBase, date2, "day") / 7), year = date2.getFullYear();
    if (!weekNo) {
      return me.getOtherMonth(new Date(me.year - 1, 0, 1)).getWeekNumber(new Date(me.year, 0, 0));
    } else if (weekNo === 53 && !me.has53weeks) {
      weekNo = 1;
      year++;
    } else if (weekNo > 53) {
      weekNo = weekNo % 52;
    }
    return [year, weekNo];
  }
  getWeekId(date2) {
    const week = this.getWeekNumber(date2);
    return week[0] * 100 + week[1];
  }
  getCellData(date2, ownerMonth, dayTime = DayTime.MIDNIGHT) {
    const me = this, day2 = date2.getDay(), visibleColumnIndex = me.visibleDayColumnIndex[day2], isNonWorking = me.nonWorkingDays[day2], isHiddenDay = me.hideNonWorkingDays && isNonWorking;
    if (date2 < me.startDate || date2 > me.endDate) {
      me.month = date2.getMonth();
    }
    return {
      day: day2,
      dayTime,
      visibleColumnIndex,
      isNonWorking,
      week: me.getOtherMonth(date2).getWeekNumber(date2),
      key: DateHelper.format(date2, "YYYY-MM-DD"),
      columnIndex: me.dayColumnIndex[day2],
      date: new Date(date2),
      dayEnd: dayTime.duration("s"),
      tomorrow: dayTime.dayOfDate(DateHelper.add(date2, 1, "day")),
      isOtherMonth: Math.sign(date2.getMonth() + date2.getFullYear() * 12 - (ownerMonth.month + ownerMonth.year * 12)),
      visible: !isHiddenDay && date2 >= ownerMonth.startDate && date2 < DateHelper.add(ownerMonth.endDate, 1, "day"),
      isRowStart: visibleColumnIndex === 0,
      isRowEnd: visibleColumnIndex === me.visibleColumnCount - 1
    };
  }
  updateDayNumbers() {
    const me = this, {
      weekStartDay,
      nonWorkingDays,
      hideNonWorkingDays
    } = me, dayColumnIndex = me.dayColumnIndex = [], canonicalDayNumbers = me.canonicalDayNumbers = [], visibleDayColumnIndex = me.visibleDayColumnIndex = [];
    let visibleColumnIndex = 0;
    for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
      const canonicalDay = (weekStartDay + columnIndex) % 7;
      canonicalDayNumbers[columnIndex] = canonicalDay;
      dayColumnIndex[canonicalDay] = columnIndex;
      if (!hideNonWorkingDays || !nonWorkingDays[canonicalDay]) {
        visibleDayColumnIndex[canonicalDay] = visibleColumnIndex++;
      }
    }
    me.visibleColumnCount = visibleColumnIndex;
    me.weekLength = hideNonWorkingDays ? 7 - ObjectHelper.keys(nonWorkingDays).length : 7;
  }
};
_defineProperty(Month, "$name", "Month");
var otherMonth = new Month(null);
Month._$name = "Month";
var nextObjectIdentity = 0;
var objectIdentityMap = /* @__PURE__ */ new WeakMap();
var argsToCacheKey = (...args) => args.map((arg) => {
  let result;
  if (arg && typeof arg == "object" || typeof arg == "function") {
    result = objectIdentityMap.get(arg);
    if (result === void 0) {
      result = ++nextObjectIdentity;
      objectIdentityMap.set(arg, result);
    }
  } else {
    result = String(arg);
  }
  return result;
}).join("-");
var memo = (fn2) => {
  const mlist = /* @__PURE__ */ new Map();
  return (...args) => {
    const mkey = argsToCacheKey(args);
    let result = mlist.get(mkey);
    if (result === void 0) {
      result = fn2(...args);
      mlist.set(mkey, result);
    }
    return result;
  };
};
var memoCps = (fn2) => {
  const table = /* @__PURE__ */ new Map(), entryContinuations = (entry) => entry[0], entryResults = (entry) => entry[1], pushContinuation = (entry, cont) => entryContinuations(entry).push(cont), pushResult = (entry, result) => entryResults(entry).push(result), isResultSubsumed = (entry, result) => entryResults(entry).some((r) => ObjectHelper.isEqual(r, result)), makeEntry = () => [[], []], isEmptyEntry = (entry) => !entryResults(entry).length && !entryContinuations(entry).length, tableRef = (str) => {
    let entry = table.get(str);
    if (entry === void 0) {
      entry = makeEntry();
      table.set(str, entry);
    }
    return entry;
  };
  return (str, cont) => {
    const entry = tableRef(str);
    if (isEmptyEntry(entry)) {
      pushContinuation(entry, cont);
      fn2(str, (result) => {
        if (!isResultSubsumed(entry, result)) {
          pushResult(entry, result);
          entryContinuations(entry).forEach((cont2) => cont2(result));
        }
      });
    } else {
      pushContinuation(entry, cont);
      entryResults(entry).forEach((result) => cont(result));
    }
  };
};
var SUCCESS = Symbol("success");
var FAILURE = Symbol("failure");
var success = (val, rest) => [SUCCESS, val, rest];
var failure = (rest) => [FAILURE, rest];
var isSuccess = (result) => result.length && result[0] === SUCCESS;
var resolveParser = (p) => typeof p === "function" && !p.length ? p() : p;
var succeed = memo((val) => memoCps((str, cont) => cont(success(val, str))));
var string = memo((match) => memoCps((str, cont) => {
  const len = Math.min(match.length, str.length), head = str.substr(0, len), tail = str.substr(len);
  cont(head === match ? success(head, tail) : failure(tail));
}));
var bind = (p, fn2) => (str, cont) => resolveParser(p)(str, (result) => {
  if (isSuccess(result)) {
    const [, val, rest] = result;
    fn2(val)(rest, cont);
  } else {
    cont(result);
  }
});
var seq = memo((...parsers2) => {
  const seq2 = memo((a, b) => memoCps(bind(a, (x) => bind(b, (y) => succeed([].concat(x, y))))));
  return parsers2.reduce(seq2, succeed([]));
});
var alt = memo((...parsers2) => memoCps((str, cont) => parsers2.forEach((p) => resolveParser(p)(str, cont))));
var regexp = memo((pattern) => (str, cont) => {
  const rexp = new RegExp(`^${pattern}`), match = rexp.exec(str);
  if (match) {
    const head = match[0], tail = str.substr(head.length);
    cont(success(head, tail));
  } else {
    cont(failure(str));
  }
});
var red = memo((p, fn2) => bind(p, (...val) => succeed(fn2(...[].concat.apply([], val)))));
var runParser = (body, str) => {
  const results = [];
  body(str, (result) => {
    if (isSuccess(result)) {
      const [, , left] = result;
      if (left === "") {
        results.push(result);
      }
    }
  });
  return results;
};
var defineParser = (body) => (str, cont) => cont ? resolveParser(body)(str, cont) : runParser(resolveParser(body), str);
var Parser = {
  memo,
  memoCps,
  success,
  failure,
  isSuccess,
  resolveParser,
  succeed,
  string,
  bind,
  seq,
  alt,
  regexp,
  red,
  runParser,
  defineParser
};
var ScrollManager = class extends Delayable(Base$1) {
  static get configurable() {
    return {
      element: null,
      zoneWidth: 50,
      scrollSpeed: 5,
      direction: "both",
      startScrollDelay: 500,
      stopScrollWhenPointerOut: false,
      testConfig: {
        scrollSpeed: 2,
        startScrollDelay: 100
      },
      activeScroll: {
        $config: ["lazy"],
        value: {}
      },
      monitoring: {
        $config: ["lazy", "nullify"],
        value: true
      },
      owner: null
    };
  }
  changeMonitoring(value, was) {
    was === null || was === void 0 ? void 0 : was.clear();
    return /* @__PURE__ */ new Map();
  }
  doDestroy() {
    this.stopMonitoring();
    super.doDestroy();
  }
  get isScrolling() {
    return Object.keys(this.activeScroll).length !== 0;
  }
  get rtl() {
    var _this$owner;
    return (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.rtl;
  }
  startMonitoring(config = {}) {
    const me = this, {
      element,
      direction: defaultDirection
    } = me, {
      scrollables = [],
      direction = defaultDirection,
      callback
    } = config, attachedElements = [];
    if (!scrollables.length) {
      scrollables.push({
        element
      });
    }
    scrollables.forEach((scrollable) => {
      const target = scrollable.element;
      if (typeof target === "string") {
        DomHelper.forEachSelector(element, target, (element2) => {
          me.createMonitor(element2, scrollable.direction || direction, scrollable.callback || callback);
          attachedElements.push(element2);
        });
      } else {
        me.createMonitor(target, scrollable.direction || direction, scrollable.callback || callback);
        attachedElements.push(target);
      }
    });
    return function detacher2() {
      var _me$stopMonitoring;
      (_me$stopMonitoring = me.stopMonitoring) === null || _me$stopMonitoring === void 0 ? void 0 : _me$stopMonitoring.call(me, attachedElements);
    };
  }
  createMonitor(element, direction, callback) {
    const {
      monitoring
    } = this;
    if (!monitoring.has(element)) {
      monitoring.set(element, new ScrollManagerMonitor({
        scrollManager: this,
        element,
        direction,
        callback
      }));
    }
  }
  stopMonitoring(element) {
    const me = this, {
      monitoring
    } = me;
    element = ArrayHelper.asArray(element);
    if (monitoring) {
      if (!element) {
        monitoring.forEach((monitor) => me.stopMonitoring(monitor.element));
        return;
      }
      element.forEach((element2) => {
        const monitor = monitoring.get(element2);
        element2.classList.remove("b-scrolling");
        if (monitor) {
          monitor.destroy();
          monitoring.delete(element2);
        }
      });
    }
  }
  requestScroll(direction, monitor) {
    const {
      activeScroll
    } = this;
    if (direction in activeScroll && activeScroll[direction] !== monitor) {
      return false;
    } else {
      activeScroll[direction] = monitor;
      return true;
    }
  }
  releaseScroll(monitor) {
    const {
      activeScroll = {}
    } = this;
    Object.keys(activeScroll).forEach((key) => {
      if (activeScroll[key] === monitor) {
        delete activeScroll[key];
      }
    });
  }
  getRelativeScroll(element, direction = "left") {
    let result = 0;
    this.monitoring.forEach((monitor, monitoredElement) => {
      if (DomHelper.isDescendant(monitoredElement, element)) {
        result += direction === "left" ? monitor.scrollRelativeLeft : monitor.scrollRelativeTop;
      }
    });
    return result;
  }
};
var ScrollManagerMonitor = class extends Base$1 {
  construct(config) {
    const me = this, {
      element
    } = config, startScrollLeft = element.scrollLeft, startScrollTop = element.scrollTop;
    Object.assign(config, {
      startScrollLeft,
      startScrollTop
    });
    super.construct(config);
    EventHelper.on({
      element,
      scroll: "onElementScroll",
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      capture: true,
      thisObj: me
    });
    EventHelper.on({
      element,
      pointerleave: "onPointerLeave",
      thisObj: me
    });
  }
  doDestroy() {
    this.stopScroll();
    super.doDestroy();
  }
  startScroll() {
    this.scrolling = true;
    this.performScroll();
  }
  stopScroll() {
    const me = this;
    me.scrolling = false;
    if (me.scrollRequested) {
      me.scrollManager.cancelAnimationFrame(me.frameId);
      me.scrollRequested = false;
    }
    me.scrollManager.clearTimeout(me.scrollTimeout);
    me.scrollManager.releaseScroll(me);
    me.scrollTimeout = null;
  }
  onPointerLeave() {
    this.scrollManager.stopScrollWhenPointerOut && this.stopScroll();
  }
  onMouseMove(event) {
    const me = this, {
      scrollManager
    } = me, box = me.element.getBoundingClientRect(), width = scrollManager.zoneWidth, speed = scrollManager.scrollSpeed;
    me.scrollDeltaX = me.scrollDeltaY = 0;
    if (me.direction !== "vertical") {
      const {
        scrollLeft,
        scrollWidth,
        clientWidth
      } = me.element;
      if (scrollManager.rtl) {
        if (event.clientX < box.left + width && scrollWidth + scrollLeft - clientWidth >= 1) {
          me.scrollDeltaX = -Math.round((width + (box.left - event.clientX)) / speed) - 1;
        } else if (event.clientX > box.right - width && scrollLeft < 0) {
          me.scrollDeltaX = Math.round((width - (box.right - event.clientX)) / speed) + 1;
        }
      } else {
        if (event.clientX > box.right - width && scrollWidth - scrollLeft - clientWidth >= 1) {
          me.scrollDeltaX = Math.round((width - (box.right - event.clientX)) / speed) + 1;
        } else if (event.clientX < box.left + width && scrollLeft > 0) {
          me.scrollDeltaX = -Math.round((width + (box.left - event.clientX)) / speed) - 1;
        }
      }
    }
    if (me.direction !== "horizontal") {
      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = me.element;
      if (event.clientY > box.bottom - width && scrollHeight - scrollTop - clientHeight >= 1) {
        me.scrollDeltaY = Math.round((width - (box.bottom - event.clientY)) / speed) + 1;
      } else if (event.clientY < box.top + width && scrollTop > 0) {
        me.scrollDeltaY = -Math.round((width + (box.top - event.clientY)) / speed) - 1;
      }
    }
    if (me.scrollDeltaX !== 0 && !scrollManager.requestScroll("horizontal", me)) {
      me.scrollDeltaX = 0;
    }
    if (me.scrollDeltaY !== 0 && !scrollManager.requestScroll("vertical", me)) {
      me.scrollDeltaY = 0;
    }
    if (me.scrollDeltaX === 0 && me.scrollDeltaY === 0) {
      me.stopScroll();
    } else if (!me.scrollTimeout) {
      me.scrollTimeout = scrollManager.setTimeout(() => me.startScroll(), scrollManager.startScrollDelay);
    }
  }
  performScroll() {
    const me = this, {
      element
    } = me;
    if (me.scrolling && !me.scrollRequested) {
      if (me.scrollDeltaX !== 0) {
        const oldScrollLeft = element.scrollLeft, newScrollLeft = Math.min(oldScrollLeft + me.scrollDeltaX, element.scrollWidth - element.clientWidth);
        if (newScrollLeft !== oldScrollLeft) {
          element.scrollLeft = newScrollLeft;
        }
      }
      if (me.scrollDeltaY !== 0) {
        const oldScrollTop = element.scrollTop, newScrollTop = Math.min(oldScrollTop + me.scrollDeltaY, element.scrollHeight - element.clientHeight);
        if (newScrollTop !== oldScrollTop) {
          element.scrollTop = newScrollTop;
        }
      }
      me.scrollRequested = true;
      me.frameId = me.scrollManager.requestAnimationFrame(() => {
        me.scrollRequested = false;
        me.performScroll(me);
      });
    }
  }
  onElementScroll() {
    var _this$config, _this$config$callback;
    (_this$config = this.config) === null || _this$config === void 0 ? void 0 : (_this$config$callback = _this$config.callback) === null || _this$config$callback === void 0 ? void 0 : _this$config$callback.call(this.thisObj || this.scrollManager, this);
  }
  get scrollLeft() {
    return this.element.scrollLeft;
  }
  get scrollTop() {
    return this.verticalElement ? this.verticalElement.scrollTop : this.element.scrollTop;
  }
  get scrollRelativeLeft() {
    return this.scrollLeft - this.startScrollLeft;
  }
  get scrollRelativeTop() {
    return this.scrollTop - this.startScrollTop;
  }
  getRelativeLeftScroll(element) {
    return this.scrollManager.getRelativeScroll(element, "left");
  }
  getRelativeTopScroll(element) {
    return this.scrollManager.getRelativeScroll(element, "top");
  }
};
ScrollManager._$name = "ScrollManager";
var realignTransitions = {
  left: true,
  right: true,
  top: true,
  bottom: true,
  transform: true
};
var isBoolean = {
  true: 1,
  false: 1
};
var immediatePromise$4 = Promise.resolve();
var Tooltip = class extends Popup {
  static get $name() {
    return "Tooltip";
  }
  static get type() {
    return "tooltip";
  }
  static get configurable() {
    return {
      mouseOffsetX: 15,
      mouseOffsetY: 15,
      html: {
        $config: {
          equals: () => false
        }
      },
      getHtml: null,
      forElement: null,
      trackMouse: null,
      updateContentOnMouseMove: false,
      forSelector: null,
      hideOnDelegateChange: null,
      anchorToTarget: true,
      showOnHover: false,
      hoverDelay: 500,
      autoShow: false,
      dismissDelay: 0,
      hideDelay: 500,
      loadingMsg: "Loading...",
      allowOver: null,
      anchor: true,
      align: {
        align: "b-t",
        minHeight: 300
      },
      axisLock: true,
      activeTarget: null,
      testConfig: {
        hideDelay: 100,
        hoverDelay: 100,
        showAnimation: null,
        hideAnimation: null
      }
    };
  }
  afterConfigure() {
    const me = this, {
      forSelector
    } = me;
    if (forSelector) {
      me.showOnHover = true;
      if (!me.forElement) {
        if (!me.anchorToTarget) {
          me.trackMouse = true;
        }
        me.forElement = me.rootElement.host || me.rootElement;
      }
    }
    super.afterConfigure();
    if (me.forElement && me.showOnHover) {
      me.pointerOverOutDetacher = EventHelper.on({
        element: me.forElement,
        pointerover: "internalOnPointerOver",
        pointerout: "internalOnPointerOut",
        thisObj: me
      });
    }
  }
  doDestroy() {
    var _this$pointerOverOutD;
    (_this$pointerOverOutD = this.pointerOverOutDetacher) === null || _this$pointerOverOutD === void 0 ? void 0 : _this$pointerOverOutD.call(this);
    super.doDestroy();
  }
  set focusOnToFront(focusOnToFront) {
    super.focusOnToFront = focusOnToFront;
  }
  get focusOnToFront() {
    return super.focusOnToFront && DomHelper.usingKeyboard;
  }
  get focusElement() {
    const result = super.focusElement;
    if (result !== this.element) {
      return result;
    }
  }
  get anchorToTarget() {
    return this._anchorToTarget && !this.trackMouse;
  }
  get anchor() {
    return super.anchor && !this.trackMouse;
  }
  set anchor(anchor) {
    super.anchor = anchor;
  }
  onDocumentMouseDown({
    event
  }) {
    const me = this, {
      triggeredByEvent
    } = me;
    if (triggeredByEvent && DomHelper.isTouchEvent) {
      if (event.pageX === triggeredByEvent.pageX && event.pageY === triggeredByEvent.pageY && me.activeTarget.contains(event.target) && performance.now() - triggeredByEvent.timeStamp < 500) {
        return;
      }
    }
    me.abortDelayedShow();
    super.onDocumentMouseDown({
      event
    });
  }
  internalOnPointerOver(event) {
    const me = this, {
      target,
      relatedTarget
    } = event, {
      forElement,
      forSelector,
      activeTarget
    } = me;
    let newTarget;
    if (me.disabled || me.owner && !me.owner.showTooltipWhenDisabled && me.owner.disabled) {
      return;
    }
    if (me.allowOver && me.element.contains(target)) {
      return;
    }
    if (forSelector) {
      newTarget = target.closest(forSelector);
      if (activeTarget !== null && activeTarget !== void 0 && activeTarget.contains(target) && activeTarget.contains(relatedTarget) && newTarget === activeTarget) {
        return;
      }
      if (newTarget && (relatedTarget === null || relatedTarget === void 0 ? void 0 : relatedTarget.closest(forSelector)) === newTarget) {
        return;
      }
    } else if (!forElement.contains(relatedTarget)) {
      newTarget = forElement;
    } else {
      return;
    }
    if (newTarget) {
      me.handleForElementOver(event, newTarget);
    } else if (activeTarget) {
      me.handleForElementOut();
    }
  }
  onTransitionEnd(event) {
    const me = this, {
      currentOverElement
    } = Tooltip;
    if (realignTransitions[event.propertyName]) {
      var _me$activeTarget;
      if (me.allowOver && me.element.contains(currentOverElement)) {
        return;
      }
      if ((_me$activeTarget = me.activeTarget) !== null && _me$activeTarget !== void 0 && _me$activeTarget.contains(currentOverElement) && !me.trackMouse) {
        me.realign();
      }
    }
  }
  async handleForElementOver(event, newTarget) {
    const me = this, {
      activeTarget,
      hideOnDelegateChange,
      anchorToTarget
    } = me, isNewTarget = newTarget !== activeTarget, needsHide = isNewTarget && hideOnDelegateChange;
    if (me.trigger("pointerOver", {
      event,
      target: newTarget
    }) === false) {
      me.internalOnPointerOut(event);
    } else {
      me.triggeredByEvent = event;
      if (me.hasTimeout("hide")) {
        me.abortDelayedHide();
        if (!isNewTarget) {
          return;
        }
      }
      if (!hideOnDelegateChange && me.element.classList.contains("b-hiding")) {
        me.cancelHideShowAnimation();
      }
      if (!me._hidden && needsHide) {
        me.hide(false);
      }
      me.activeTarget = newTarget;
      if (me.isVisible) {
        const result = me.updateContent();
        if (Objects.isPromise(result) && !me.loadingMsg) {
          await result;
        }
        if (me.trigger("beforeShow") === false) {
          return me.hide();
        }
        me.alignTo({
          [anchorToTarget ? "target" : "position"]: anchorToTarget ? newTarget : "mouse",
          overlap: !(anchorToTarget && me.anchor)
        });
        me.trigger("show");
        me.afterShowByTarget();
      } else {
        me.delayShow(newTarget);
      }
    }
  }
  async delayShow(target) {
    var _me$currentAnimation;
    const me = this;
    if ((_me$currentAnimation = me.currentAnimation) !== null && _me$currentAnimation !== void 0 && _me$currentAnimation.showing) {
      me.cancelHideShowAnimation();
    }
    if (!me.isVisible && !me.hasTimeout("show")) {
      if (!me.hoverDelay || me.forSelector && Date.now() - me.lastHidden < me.quickShowInterval) {
        const result = me.updateContent();
        if (Objects.isPromise(result) && !me.loadingMsg) {
          await result;
        }
        me.showByTarget(target);
      } else {
        me.addDocumentMouseDownListener();
        if (!me.listeningForMouseMove && !me.anchorToTarget) {
          me.mouseMoveRemover = EventHelper.on({
            element: me.rootElement,
            mousemove: "onMouseMove",
            thisObj: me
          });
        }
        me.setTimeout(async () => {
          if (!DomHelper.isOrphaned(target)) {
            const result = me.updateContent();
            if (Objects.isPromise(result) && !me.loadingMsg) {
              await result;
            }
            me.showByTarget(target);
          }
        }, !me.triggeredByEvent || me.triggeredByEvent.type === "pointerover" ? me.hoverDelay : 0, "show");
      }
    } else if (me.isVisible) {
      me.showByTarget(target);
    }
  }
  changeAllowOver(allowOver) {
    if (!this.inAfterShow) {
      this.configuredAllowOver = allowOver;
    }
    return allowOver;
  }
  updateAllowOver(allowOver) {
    const me = this, {
      element
    } = me;
    element.classList.toggle("b-allow-over", Boolean(allowOver));
    if (allowOver) {
      me.allowOverlisteners = EventHelper.on({
        element,
        mouseenter: "onOwnElementMouseEnter",
        mouseleave: "internalOnPointerOut",
        thisObj: me
      });
    } else {
      var _me$allowOverlistener;
      (_me$allowOverlistener = me.allowOverlisteners) === null || _me$allowOverlistener === void 0 ? void 0 : _me$allowOverlistener.call(me);
    }
  }
  updateContent() {
    const me = this;
    if (me.getHtml) {
      const result = me.callback(me.getHtml, me, [{
        tip: me,
        element: me.element,
        activeTarget: me.activeTarget,
        event: me.triggeredByEvent
      }]);
      me.html = result;
      return result;
    }
  }
  get hasContent() {
    return Boolean(DomHelper.isReactElement(this._html) || this._html !== "" && typeof this.html === "string" && this.html.length || this.items.length);
  }
  internalBeforeShow() {
    return (this.updateContentOnMouseMove || this.hasContent) && !this.disabled;
  }
  showAsyncMessage(message = this.optionalL(this.loadingMsg)) {
    if (message) {
      this.html = `
                <div class="b-tooltip-loading">
                    <i class="b-icon b-icon-spinner"></i>
                    ${message}
                </div>
            `;
    }
  }
  beforeAlignTo(spec) {
    super.beforeAlignTo(spec);
    const me = this;
    if (!me.anchorToTarget && spec.position === "mouse") {
      spec.position = new Point(me.triggeredByEvent.pageX - globalThis.pageXOffset + me.mouseOffsetX * (me.rtl ? -1 : 1), me.triggeredByEvent.pageY - globalThis.pageYOffset + me.mouseOffsetY);
    }
  }
  showByTarget(target) {
    var _me$mouseMoveRemover;
    const me = this, {
      anchorToTarget
    } = me;
    me.mouseMoveRemover = (_me$mouseMoveRemover = me.mouseMoveRemover) === null || _me$mouseMoveRemover === void 0 ? void 0 : _me$mouseMoveRemover.call(me);
    me.showBy({
      [anchorToTarget ? "target" : "position"]: anchorToTarget ? target : "mouse",
      overlap: !(anchorToTarget && me.anchor)
    });
  }
  afterShowByTarget() {
    const me = this, {
      dismissDelay
    } = me;
    me.abortDelayedShow();
    if (dismissDelay) {
      me.setTimeout("hide", dismissDelay);
    }
    me.toFront();
    if (!me.mouseMoveRemover && (me.trackMouse || me.updateContentOnMouseMove)) {
      me.mouseMoveRemover = EventHelper.on({
        element: me.rootElement,
        pointermove: "onMouseMove",
        thisObj: me
      });
    }
    me.inAfterShow = true;
    me.allowOver = me.allowOver || me.configuredAllowOver != false && me.childItems.some((w) => w.isVisible && !w.disabled && w.focusElement);
    me.inAfterShow = false;
  }
  updateActiveTarget(newTarget, lastTarget) {
    if (newTarget && !this.isConfiguring) {
      this.trigger("overTarget", {
        newTarget,
        lastTarget
      });
    }
  }
  internalOnPointerOut(event) {
    var _me$activeTarget2;
    const me = this, toElement = event.relatedTarget;
    if (me.allowOver && me.element.contains(toElement)) {
      return;
    }
    if (me.element.contains(event.target) && (_me$activeTarget2 = me.activeTarget) !== null && _me$activeTarget2 !== void 0 && _me$activeTarget2.contains(toElement)) {
      return;
    }
    if (me.activeTarget && !me.activeTarget.contains(toElement)) {
      me.handleForElementOut();
    }
  }
  handleForElementOut() {
    const me = this, {
      hideDelay
    } = me;
    if (me.trigger("pointerOut") === false) {
      me.activeTarget = null;
      return;
    }
    me.abortDelayedShow();
    if (me.isVisible && hideDelay !== false) {
      me.abortDelayedHide();
      if (hideDelay > 0) {
        me.setTimeout("hide", hideDelay);
      } else {
        me.hide();
      }
    }
  }
  show(spec) {
    const me = this;
    if (!spec && me.forElement && me.anchorToTarget && !me.forSelector) {
      me.showByTarget(me.forElement);
    } else {
      super.show(...arguments);
    }
    me.afterShowByTarget();
    if (me.forElement && !me.transitionEndDetacher && !me._hidden) {
      me.transitionEndDetacher = EventHelper.on({
        element: me.forElement,
        transitionend: "onTransitionEnd",
        thisObj: me
      });
    }
  }
  hide() {
    const me = this;
    me.abortDelayedShow();
    if (!me._hidden) {
      var _me$mouseMoveRemover2, _me$transitionEndDeta;
      me.abortDelayedHide();
      const result = super.hide(...arguments);
      me.lastHidden = Date.now();
      me.activeTarget = null;
      (_me$mouseMoveRemover2 = me.mouseMoveRemover) === null || _me$mouseMoveRemover2 === void 0 ? void 0 : _me$mouseMoveRemover2.call(me);
      me.mouseMoveRemover = null;
      (_me$transitionEndDeta = me.transitionEndDetacher) === null || _me$transitionEndDeta === void 0 ? void 0 : _me$transitionEndDeta.call(me);
      me.transitionEndDetacher = null;
      return result;
    } else {
      return immediatePromise$4;
    }
  }
  abortDelayedShow() {
    const me = this;
    if (me.hasTimeout("show")) {
      var _me$mouseDownRemover, _me$mouseMoveRemover3, _me$transitionEndDeta2;
      (_me$mouseDownRemover = me.mouseDownRemover) === null || _me$mouseDownRemover === void 0 ? void 0 : _me$mouseDownRemover.call(me);
      me.mouseDownRemover = null;
      me.clearTimeout("show");
      (_me$mouseMoveRemover3 = me.mouseMoveRemover) === null || _me$mouseMoveRemover3 === void 0 ? void 0 : _me$mouseMoveRemover3.call(me);
      me.mouseMoveRemover = null;
      (_me$transitionEndDeta2 = me.transitionEndDetacher) === null || _me$transitionEndDeta2 === void 0 ? void 0 : _me$transitionEndDeta2.call(me);
      me.transitionEndDetacher = null;
    }
  }
  abortDelayedHide() {
    this.clearTimeout("hide");
  }
  realign() {
    const me = this, spec = me.lastAlignSpec;
    if (!me.isConfiguring && !me.isVisible && spec !== null && spec !== void 0 && spec.targetOutOfView) {
      if (spec.allowTargetOut || DomHelper.isInView(spec.target, false, me)) {
        me.show();
        spec.targetOutOfView = false;
      }
    }
    super.realign();
  }
  alignTo(spec) {
    const me = this;
    if (!me.isVisible) {
      return;
    }
    if (spec && !(me.triggeredByEvent && me.element.contains(me.triggeredByEvent.target))) {
      if (spec.nodeType === Node.ELEMENT_NODE) {
        spec = {
          target: spec
        };
      }
    }
    super.alignTo(spec);
  }
  changeHtml(htmlOrPromise) {
    const me = this;
    if (Objects.isPromise(htmlOrPromise)) {
      me.showAsyncMessage();
      htmlOrPromise.target = me.activeTarget;
      htmlOrPromise.then((html) => {
        if (htmlOrPromise.target === me.activeTarget) {
          me.html = html;
        }
      });
      return;
    }
    if (typeof htmlOrPromise !== "object") {
      htmlOrPromise = htmlOrPromise != null ? me.optionalL(String(htmlOrPromise)) : "";
    }
    return htmlOrPromise;
  }
  updateHtml(value, was) {
    const me = this;
    let empty2 = value === "";
    if (!empty2) {
      super.updateHtml(value, was);
      if (me.hasContent) {
        if (me.isVisible) {
          me.realign();
        }
        if (!Objects.isPromise(value)) {
          me.trigger("innerHtmlUpdate", {
            value
          });
        }
      } else {
        empty2 = true;
      }
    }
    if (empty2) {
      me.hide();
    }
  }
  onMouseMove(event) {
    const me = this, {
      forElement,
      activeTarget
    } = me, isHiding = me.hasTimeout("hide"), target = event.target;
    me.triggeredByEvent = event;
    if (!me._hidden) {
      let hideVetoed;
      const isWithinTarget = activeTarget === null || activeTarget === void 0 ? void 0 : activeTarget.contains(target), isElementOut = !isWithinTarget && me.forSelector && activeTarget && !isHiding && target.nodeType === Node.ELEMENT_NODE && !target.matches(me.forSelector) && !(me.allowOver && me.element.contains(target)), containingElement = forElement !== null && forElement !== void 0 && forElement.document ? forElement.document.documentElement : forElement, forElementContainsTarget = containingElement && (containingElement.contains ? containingElement.contains(target) : containingElement.compareDocumentPosition(target) & 16);
      if (isElementOut) {
        hideVetoed = me.handleForElementOut();
      }
      if (hideVetoed || !isHiding || forElementContainsTarget) {
        if (me.dismissDelay && !isHiding) {
          me.setTimeout("hide", me.dismissDelay);
        }
        if (me.updateContentOnMouseMove && me.getHtml) {
          me.html = me.callback(me.getHtml, me, [{
            tip: me,
            element: me.element,
            forElement: activeTarget,
            event
          }]);
          if (!me.html) {
            me.hide();
            return;
          }
        }
        if (me.trackMouse) {
          me.alignTo({
            position: "mouse",
            ignorePageScroll: true
          });
        }
      }
    }
  }
  onOwnElementMouseEnter(event) {
    this.abortDelayedHide();
  }
  static getSharedTooltip(rootElement, skipCreating) {
    var _rootElement$bryntum, _rootElement$bryntum$;
    let sharedTooltip = (_rootElement$bryntum = rootElement.bryntum) === null || _rootElement$bryntum === void 0 ? void 0 : (_rootElement$bryntum$ = _rootElement$bryntum.tooltip) === null || _rootElement$bryntum$ === void 0 ? void 0 : _rootElement$bryntum$.get(Tooltip);
    if (!sharedTooltip && !skipCreating) {
      var _rootElement$bryntum2;
      if (!((_rootElement$bryntum2 = rootElement.bryntum) !== null && _rootElement$bryntum2 !== void 0 && _rootElement$bryntum2.tooltip)) {
        ObjectHelper.setPath(rootElement, "bryntum.tooltip", /* @__PURE__ */ new Map());
      }
      const map2 = rootElement.bryntum.tooltip;
      map2.set(Tooltip, true);
      sharedTooltip = new Tooltip({
        forElement: rootElement,
        rootElement,
        forSelector: "[data-btip]",
        resetCfg: {},
        isShared: true,
        cls: "b-tooltip-shared",
        internalListeners: {
          pointerOver({
            source: me,
            target
          }) {
            for (const key in me.resetCfg) {
              if (key === "listeners") {
                me.un(me.resetCfg[key].set);
              } else if (key !== "html") {
                me[key] = me.resetCfg[key].was;
              }
            }
            me.resetCfg = {};
            const forComponent = Widget.getById(target.id), config = (forComponent === null || forComponent === void 0 ? void 0 : forComponent.tipConfig) || me.gatherDataConfigs(target.dataset);
            if (forComponent && forComponent.element !== target || !forComponent && target.matches(".b-widget") || forComponent !== null && forComponent !== void 0 && forComponent.disabled && !forComponent.showTooltipWhenDisabled) {
              return false;
            }
            me.owner = forComponent;
            for (const key in config) {
              me.resetCfg[key] = {
                set: config[key],
                was: me[key]
              };
              if (key === "listeners") {
                me.ion(config[key]);
              } else {
                me[key] = config[key];
              }
            }
          },
          hide({
            source: me
          }) {
            me.owner = null;
          }
        },
        gatherDataConfigs(dataset) {
          const me = this, config = {};
          for (const key in dataset) {
            if (key.startsWith("btip")) {
              if (key.length > 4) {
                const configProp = StringHelper.uncapitalize(key.substr(4));
                if (configProp in me.getDefaultConfiguration()) {
                  const value = dataset[key];
                  config[configProp] = isBoolean[value] ? value === "true" : isNaN(value) ? value : parseInt(value, 10);
                }
              } else {
                config.html = dataset[key];
              }
            }
          }
          return config;
        }
      });
      EventHelper.on({
        element: rootElement,
        mouseenter: (event) => Tooltip.currentOverElement = event.target,
        keydown: (event) => Tooltip.currentOverElement = event.target,
        capture: true,
        thisObj: sharedTooltip
      });
      map2.set(Tooltip, sharedTooltip);
    }
    return sharedTooltip;
  }
  static encodeConfig(tooltip) {
    const dataset = {};
    if (typeof tooltip === "string") {
      dataset.btip = tooltip;
    } else {
      for (const config in tooltip) {
        dataset[`btip${config === "html" ? "" : StringHelper.capitalize(config)}`] = tooltip[config];
      }
    }
    return dataset;
  }
};
Tooltip.initClass();
Object.defineProperty(Widget, "tooltip", {
  get() {
    return Tooltip.getSharedTooltip(document.body);
  }
});
Widget.Tooltip = Tooltip;
Tooltip._$name = "Tooltip";
var DragTipProxy = class extends DragProxy {
  static get type() {
    return "tip";
  }
  static get configurable() {
    return {
      align: "t10-b50",
      offset: 20,
      tooltip: {
        $config: ["lazy", "nullify"],
        value: {
          type: "tooltip"
        }
      }
    };
  }
  open() {
    this.getConfig("tooltip");
  }
  close() {
    var _this$tooltip;
    (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.hide();
  }
  dragMove(drag) {
    const {
      offset,
      tooltip
    } = this, {
      event
    } = drag;
    if (tooltip) {
      if (!tooltip.isVisible) {
        tooltip.show();
      }
      tooltip.alignTo({
        align: this.align,
        target: new Rectangle(event.clientX - offset, event.clientY - offset, offset * 2, offset * 2)
      });
    }
  }
  changeTooltip(config, existing) {
    return Widget.reconfigure(existing, config, this);
  }
};
DragTipProxy.initClass();
DragTipProxy._$name = "DragTipProxy";
var Labelable = (Target) => class Labelable extends (Target || Base$1) {
  static get $name() {
    return "Labelable";
  }
  static get configurable() {
    return {
      label: null,
      labelPosition: "before",
      labelCls: null,
      labelWidth: {
        value: null,
        $config: {
          localeKey: "L{labelWidth}"
        }
      }
    };
  }
  get hasLabel() {
    return Boolean(this.label);
  }
  compose() {
    const {
      hasLabel,
      labelPosition
    } = this;
    return {
      class: {
        [`b-label-${labelPosition}`]: hasLabel,
        "b-has-label": hasLabel
      }
    };
  }
  changeLabel(label) {
    return label || "";
  }
  setupLabel(lbl) {
    return ObjectHelper.assign({
      tag: "label",
      for: `${this.id}-input`,
      class: `b-label b-align-${lbl.align || "start"}`
    }, lbl);
  }
  updateLabelWidth(newValue) {
    if (this.labelElement) {
      this.labelElement.style.flex = `0 0 ${DomHelper.setLength(newValue)}`;
      this.inputWrap.style.flexBasis = newValue == null ? "" : "auto";
    }
  }
  get widgetClass() {
  }
};
var FieldContainer = class extends Container {
  static get $name() {
    return "FieldContainer";
  }
  static get type() {
    return "fieldcontainer";
  }
  static get configurable() {
    return {
      animation: {
        duration: 300
      },
      collapsed: null,
      collapser: {
        value: null,
        $config: "nullify"
      },
      syncableConfigs: null,
      syncConfigTriggers: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      testConfig: {
        animation: {
          duration: 10
        }
      }
    };
  }
  static get delayable() {
    return {
      syncChildConfigs: "raf"
    };
  }
  get inline() {
    var _this$owner$inline;
    return (_this$owner$inline = this.owner.inline) !== null && _this$owner$inline !== void 0 ? _this$owner$inline : this.ensureItems().count === 1;
  }
  changeCollapsed(collapsed) {
    if (this.togglingCollapse) {
      this.togglingCollapse = false;
      return collapsed;
    }
    this.toggleCollapse(Boolean(collapsed));
  }
  updateCollapsed(collapsed) {
    var _this$collapser;
    this.collapser = (_this$collapser = this.collapser) === null || _this$collapser === void 0 ? void 0 : _this$collapser.destroy();
    this.setCollapsedCls(collapsed);
  }
  updateCollapser(collapser, was) {
    if (was && was.completed == null) {
      if (!was.reverting || !collapser) {
        was.destroy();
      }
    }
    this.setOwnerCls("b-collapsing", collapser);
  }
  get collapsing() {
    const {
      collapser
    } = this;
    return collapser != null && collapser.collapsed;
  }
  get collapsingExpanding() {
    return this.collapser != null;
  }
  get expanding() {
    const {
      collapser
    } = this;
    return collapser != null && !collapser.collapsed;
  }
  collapse(animation) {
    this.toggleCollapse(true, animation);
  }
  expand(animation) {
    this.toggleCollapse(false, animation);
  }
  setCollapsedCls(collapsed) {
    this.setOwnerCls("b-collapsed", collapsed);
  }
  setOwnerCls(cls, state) {
    var _this$owner, _this$owner$element;
    (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : (_this$owner$element = _this$owner.element) === null || _this$owner$element === void 0 ? void 0 : _this$owner$element.classList[state ? "add" : "remove"](cls);
  }
  syncChildConfigs() {
    const me = this, {
      owner,
      syncableConfigs
    } = me;
    if (syncableConfigs) {
      let destProp, val;
      for (destProp in syncableConfigs) {
        val = syncableConfigs[destProp](owner);
        me.eachWidget((item) => {
          item[destProp] = val;
        }, false);
      }
    }
    owner.afterSyncChildConfigs(me);
  }
  syncContainer() {
    const {
      inline,
      layout
    } = this;
    if (this.autoLayout) {
      layout.horizontal = inline;
      layout.justify = inline ? "center" : "stretch";
    }
  }
  toggleCollapse(collapsed, animation) {
    const me = this, {
      animation: collapseAnimation,
      collapser,
      inline
    } = me, {
      containerWrapElement
    } = me.owner, finalize = (complete) => {
      if (complete) {
        me.element.style.height = "";
        me.togglingCollapse = true;
        me.collapsed = collapsed;
        me.collapser = null;
      }
    };
    if (collapsed == null) {
      collapsed = !me.collapsed;
    }
    if (animation !== false && animation !== null) {
      if (!containerWrapElement || !me.isVisible) {
        animation = null;
      } else {
        if (animation === true) {
          animation = {};
        } else if (typeof animation === "number") {
          animation = {
            duration: animation
          };
        }
        animation = collapseAnimation || animation ? ObjectHelper.merge({}, collapseAnimation, animation) : null;
      }
    }
    if (!animation) {
      me.togglingCollapse = true;
      me.collapsed = collapsed;
    } else if (collapser && collapsed !== collapser.collapsed) {
      me.collapser = collapser.revert({
        finalize
      });
      me.collapser.collapsed = collapsed;
    } else if (!collapser && collapsed !== me.collapsed) {
      !collapsed && me.setCollapsedCls(false);
      const {
        element
      } = me, {
        height
      } = element.getBoundingClientRect(), expanded = inline ? 1 : height;
      !collapsed && me.setCollapsedCls(true);
      element.style.height = `${height}px`;
      me.collapser = Animator.run(ObjectHelper.merge({
        finalize,
        element: containerWrapElement,
        [inline ? "opacity" : "height"]: {
          from: collapsed ? expanded : 0,
          to: collapsed ? 0 : expanded
        }
      }, animation));
      me.collapser.collapsed = collapsed;
    }
  }
};
FieldContainer.initClass();
FieldContainer._$name = "FieldContainer";
var byWeight$1 = (l, r) => (l.weight || 0) - (r.weight || 0);
var byWeightReverse = (l, r) => (r.weight || 0) - (l.weight || 0);
var emptyArray$5 = [];
var triggerConfigs = {
  align: true,
  weight: true
};
var Field = class extends Widget.mixin(Badge, Labelable) {
  static get $name() {
    return "Field";
  }
  static get type() {
    return "field";
  }
  static get configurable() {
    return {
      defaultBindProperty: "value",
      placeholder: null,
      value: "",
      name: null,
      labels: null,
      required: null,
      clearable: null,
      revertOnEscape: null,
      hint: null,
      hintHtml: null,
      inputWidth: null,
      keyStrokeChangeDelay: 0,
      readOnly: null,
      editable: true,
      defaultAction: "change",
      triggers: null,
      highlightExternalChange: true,
      localizableProperties: ["label", "title", "placeholder", "labelWidth"],
      autoSelect: false,
      autoComplete: "off",
      spellCheck: null,
      validateOnInput: true,
      inputAttributes: null,
      inputType: "text",
      inputAlign: null,
      attributes: {
        value: ["placeholder", "autoComplete", "spellCheck", "minLength", "maxLength", "pattern", "tabIndex", "min", "max"],
        $config: {
          merge: "distinct"
        }
      },
      nullValue: {
        $config: null,
        value: null,
        default: null
      },
      updatedClsDuration: 500,
      inputReadOnly: false,
      ariaElement: "input",
      container: {
        $config: "nullify",
        value: null
      },
      containerDefaults: {
        type: "fieldcontainer",
        syncableConfigs: {
          disabled: (field) => field.disabled
        },
        syncConfigTriggers: {
          disabled: 1
        }
      },
      containValues: null,
      inline: null,
      testConfig: {
        updatedClsDuration: 10
      },
      keyMap: {}
    };
  }
  static get delayable() {
    return {
      highlightChanged: "raf"
    };
  }
  doDestroy() {
    var _me$inputListenerRemo, _me$keyListenerRemove, _me$container;
    const me = this, {
      triggers
    } = me, errorTip = me.isPainted && Field.getSharedErrorTooltip(me.rootElement, true);
    (_me$inputListenerRemo = me.inputListenerRemover) === null || _me$inputListenerRemo === void 0 ? void 0 : _me$inputListenerRemo.call(me);
    (_me$keyListenerRemove = me.keyListenerRemover) === null || _me$keyListenerRemove === void 0 ? void 0 : _me$keyListenerRemove.call(me);
    (_me$container = me.container) === null || _me$container === void 0 ? void 0 : _me$container.destroy();
    super.doDestroy();
    if (triggers) {
      for (const t of Object.values(triggers)) {
        t.destroy();
      }
    }
    if ((errorTip === null || errorTip === void 0 ? void 0 : errorTip.field) === me) {
      errorTip.hide();
    }
  }
  get childItems() {
    const {
      container,
      triggers
    } = this, ret = triggers ? Object.values(triggers) : [];
    return container ? [...ret, ...container.childItems] : ret;
  }
  get invalidValueError() {
    return "L{invalidValue}";
  }
  get errorTip() {
    return this.constructor.getSharedErrorTooltip(this.rootElement);
  }
  static getSharedErrorTooltip(rootElement, doNotCreate) {
    var _rootElement$bryntum;
    let sharedErrorTooltip = (_rootElement$bryntum = rootElement.bryntum) === null || _rootElement$bryntum === void 0 ? void 0 : _rootElement$bryntum.errorTooltip;
    if (!sharedErrorTooltip && !doNotCreate) {
      rootElement.bryntum = rootElement.bryntum || {};
      sharedErrorTooltip = new Tooltip({
        cls: "b-field-error-tip",
        forSelector: ".b-field.b-invalid .b-field-inner",
        align: {
          align: "l-r",
          monitorTargetMutation: true
        },
        scrollAction: "realign",
        trapFocus: false,
        rootElement,
        onBeforeShow() {
          const tip = this, field = Widget.fromElement(tip.activeTarget);
          if (field) {
            const errors = field.getErrors();
            if (errors) {
              tip.html = errors.join("<br>");
              tip.field = field;
              return true;
            }
          }
          return false;
        }
      });
      rootElement.bryntum.errorTooltip = sharedErrorTooltip;
    }
    return sharedErrorTooltip;
  }
  static get errorTip() {
    return this.getSharedErrorTooltip(document.body);
  }
  construct(config) {
    super.construct(config);
    const me = this;
    if (me.keyStrokeChangeDelay) {
      me.changeOnKeyStroke = me.buffer(me.internalOnChange, me.keyStrokeChangeDelay);
    }
  }
  changeKeyMap(keyMap) {
    const me = this;
    let mergedKeyMap = {};
    if (keyMap) {
      if (!me._fieldKeyMap) {
        me._fieldKeyMap = keyMap;
        ObjectHelper.assign(mergedKeyMap, keyMap);
      } else {
        ObjectHelper.assign(mergedKeyMap, me._fieldKeyMap);
      }
    }
    for (const triggerName in me.triggers) {
      var _me$triggers$triggerN;
      if ((_me$triggers$triggerN = me.triggers[triggerName]) !== null && _me$triggers$triggerN !== void 0 && _me$triggers$triggerN.keyMap) {
        mergedKeyMap = me.mergeKeyMaps(mergedKeyMap, me.triggers[triggerName].keyMap, triggerName);
      }
    }
    return mergedKeyMap;
  }
  get keyMapSubComponents() {
    return this.triggers;
  }
  onFocusIn(e) {
    const me = this;
    me.valueOnFocus = ObjectHelper.clone(me.value);
    me.validOnFocus = !(me.errors && Object.keys(me.errors).length);
    super.onFocusIn(e);
    me.focusing = true;
    me.syncInvalid();
    me.focusing = false;
  }
  onFocusOut(e) {
    super.onFocusOut(e);
    this.syncRequired();
    this.onEditComplete();
  }
  onEditComplete() {
  }
  get rootUiClass() {
    return Field;
  }
  compose() {
    this.getConfig("clearable");
    const me = this, {
      container,
      innerElements,
      label,
      labels,
      labelCls,
      readOnly,
      triggers
    } = me, triggerInstances = ObjectHelper.values(triggers, (k, v) => !v), startTriggers = triggerInstances.filter((t) => t.align === "start").sort(byWeight$1), endTriggers = triggerInstances.filter((t) => t.align !== "start").sort(byWeightReverse), setupLabel = me.setupLabel.bind(me), innerChildren = [...startTriggers.map((t) => t.element), ...innerElements, ...endTriggers.map((t) => t.element)];
    return {
      class: {
        "b-has-start-trigger": startTriggers.length,
        "b-no-input": !innerElements.length,
        "b-readonly": readOnly,
        "b-field-container": Boolean(container),
        "b-field-container-inline": container === null || container === void 0 ? void 0 : container.inline
      },
      children: [...(labels || emptyArray$5).filter((t) => t && t.align !== "end").map(setupLabel), (label || null) && setupLabel({
        reference: "labelElement",
        class: `b-label b-align-start ${labelCls || ""}`,
        html: label
      }), innerChildren.length ? {
        class: "b-field-inner",
        reference: "inputWrap",
        children: innerChildren
      } : null, ...(labels || emptyArray$5).filter((t) => (t === null || t === void 0 ? void 0 : t.align) === "end").map(setupLabel), ...container ? [{
        reference: "containerWrapElement",
        children: [container.element],
        class: {
          "b-field-container-wrap": 1
        }
      }] : emptyArray$5]
    };
  }
  updateElement(element, was) {
    var _me$keyListenerRemove2;
    const me = this, value = me.initialConfig.value, {
      input
    } = me;
    super.updateElement(element, was);
    if (value != null) {
      me.value = value;
    }
    me.syncEmpty();
    me.updateInputReadOnly(me.inputReadOnly);
    me.syncInvalid();
    const keyEventElement = input || me.focusElement;
    (_me$keyListenerRemove2 = me.keyListenerRemover) === null || _me$keyListenerRemove2 === void 0 ? void 0 : _me$keyListenerRemove2.call(me);
    me.keyListenerRemover = keyEventElement && EventHelper.on({
      element: keyEventElement,
      thisObj: me,
      keydown: "internalOnKeyEvent",
      keypress: "internalOnKeyEvent",
      keyup: "internalOnKeyEvent"
    });
  }
  get innerElements() {
    return [this.inputElement];
  }
  get inputElement() {
    const {
      attributes,
      inputAttributes,
      id,
      inputCls,
      inputType,
      name
    } = this, domConfig = ObjectHelper.assign({
      reference: "input",
      tag: "input",
      type: inputType,
      name: name || id,
      id: `${id}-input`,
      retainElement: true
    }, inputAttributes);
    if (inputCls) {
      domConfig.class = inputCls;
    }
    for (let key, value, i = attributes.length; i-- > 0; ) {
      key = attributes[i];
      value = this[key];
      if (value != null) {
        domConfig[key] = value;
      }
    }
    return domConfig;
  }
  get caretPos() {
    return this.textSelection[0];
  }
  set caretPos(value) {
    this.textSelection = value;
  }
  get focusElement() {
    return this.input;
  }
  get textSelection() {
    const input = this.input;
    let ret;
    try {
      ret = [input.selectionStart, input.selectionEnd, input.selectionDirection];
    } catch (e) {
      var _input$value;
      ret = ((_input$value = input.value) === null || _input$value === void 0 ? void 0 : _input$value.length) || 0;
      ret = [ret, ret];
    }
    return ret;
  }
  set textSelection(value) {
    if (typeof value === "number") {
      this.select(value, value);
    } else {
      this.select(...value);
    }
  }
  get hasTextSelection() {
    const [selectionStart, selectionEnd] = this.textSelection;
    return selectionStart && selectionEnd - selectionStart > 0;
  }
  getAfterValue(text) {
    const [begin, end] = this.textSelection, value = this.input.value;
    return `${value.substr(0, begin)}${text}${value.substr(end || begin)}`;
  }
  select(start, end) {
    const input = this.focusElement;
    if (input.value.length) {
      if (arguments.length === 0) {
        this.selectAll();
        return;
      }
      if (!this.supportsTextSelection) {
        return;
      }
      input.setSelectionRange(start, end);
    }
  }
  moveCaretToEnd() {
    const input = this.input;
    if (input.createTextRange) {
      const range = input.createTextRange();
      range.collapse(false);
      range.select();
    } else if (this.supportsTextSelection) {
      this.select(input.value.length, input.value.length);
    }
  }
  selectAll() {
    this.focusElement.select();
  }
  syncEmpty() {
    var _this$triggers;
    const {
      isEmptyInput,
      isEmpty,
      element
    } = this, clear = (_this$triggers = this.triggers) === null || _this$triggers === void 0 ? void 0 : _this$triggers.clear, empty2 = isEmptyInput && isEmpty;
    if (element) {
      if (clear) {
        clear[empty2 ? "hide" : "show"]();
      }
      element.classList.toggle("b-empty", empty2);
    }
  }
  updateHint() {
    this.syncHint();
  }
  updateHintHtml() {
    this.syncHint();
  }
  syncHint() {
    const me = this, {
      input,
      hint,
      hintHtml
    } = me, parent = input === null || input === void 0 ? void 0 : input.parentElement;
    if (input) {
      let hintValue = hintHtml || hint;
      const hintElement = me.hintElement || hintValue && (me.hintElement = DomHelper.createElement({
        parent,
        className: "b-field-hint",
        nextSibling: input.nextSibling,
        children: [{
          className: "b-field-hint-content"
        }]
      }));
      if (hintElement) {
        if (typeof hintValue === "function") {
          hintValue = hintValue({
            source: me,
            value: me.value
          });
        }
        hintElement.firstChild[hintHtml ? "innerHTML" : "textContent"] = hintValue || "";
      }
      me.element.classList[hintValue ? "remove" : "add"]("b-field-no-hint");
    }
  }
  syncInvalid() {
    const me = this, {
      isPainted
    } = me;
    me.updatingInvalid = true;
    if (isPainted) {
      const {
        isValid,
        element,
        inputWrap
      } = me;
      element.classList[isValid ? "remove" : "add"]("b-invalid");
      if (isValid) {
        const errorTip = me.constructor.getSharedErrorTooltip(me.rootElement, true);
        if (errorTip !== null && errorTip !== void 0 && errorTip.isVisible && errorTip.field === me) {
          errorTip.hide();
        }
      } else {
        const errorTip = me.errorTip;
        if (errorTip && (me.containsFocus || me.isVisible && inputWrap.contains(Tooltip.currentOverElement))) {
          if (errorTip.activeTarget === inputWrap && errorTip.isVisible) {
            errorTip.onBeforeShow();
          } else {
            errorTip.activeTarget = inputWrap;
            errorTip.showBy(inputWrap);
          }
        }
      }
    }
    me.updatingInvalid = false;
  }
  updateEditable() {
    this.syncInputReadOnly();
  }
  syncInputReadOnly() {
    this.getConfig("readOnly");
    this.inputReadOnly = this._readOnly || this.editable === false;
  }
  updateInputReadOnly(readOnly) {
    const me = this, {
      input,
      inputListenerRemover
    } = me;
    if (input) {
      input.readOnly = readOnly ? "readOnly" : null;
      if (readOnly) {
        me.inputListenerRemover = inputListenerRemover === null || inputListenerRemover === void 0 ? void 0 : inputListenerRemover();
      } else if (!inputListenerRemover) {
        me.inputListenerRemover = EventHelper.on({
          element: input,
          thisObj: me,
          focus: "internalOnInputFocus",
          change: "internalOnChange",
          input: "internalOnInput"
        });
      }
    }
  }
  changeReadOnly(value) {
    return Boolean(value);
  }
  updateReadOnly(readOnly) {
    this.syncInputReadOnly();
  }
  updateClearable(clearable) {
    const me = this;
    me.getConfig("triggers");
    me.triggers = {
      clear: clearable && ObjectHelper.assign({
        cls: "b-icon-remove",
        weight: 1e3,
        key: "Shift+backspace",
        handler() {
          me._isUserAction = true;
          me.clear(...arguments);
          me._isUserAction = false;
        }
      }, clearable) || null
    };
  }
  changeTriggers(triggers, was) {
    const me = this, manager = me.$triggers || (me.$triggers = new DynamicObject({
      configName: "triggers",
      factory: Field.Trigger,
      inferType: false,
      owner: me,
      created(instance) {
        FunctionHelper.after(instance, "onConfigChange", (ret, {
          name
        }) => {
          if (triggerConfigs[name]) {
            me.onConfigChange({
              name: "triggers",
              value: manager.target
            });
          }
        });
      },
      setup(config, name) {
        config.reference = config.ref = name;
        config.parent = me;
      }
    }));
    if (me.stepTriggers === false && (triggers.back || triggers.forward)) {
      triggers = ObjectHelper.assign({}, triggers);
      delete triggers.back;
      delete triggers.forward;
    }
    manager.update(triggers);
    if (me.element) {
      me.keyMap = me.keyMap;
    }
    if (!was) {
      return manager.target;
    }
  }
  updateInputWidth(newValue) {
    this.input.style.width = DomHelper.setLength(newValue);
    this.element.classList.add("b-has-width");
  }
  updateInputAlign(newValue) {
    this.input.style.textAlign = newValue;
  }
  get isValid() {
    const me = this;
    if (!me.disabled) {
      me.syncRequired();
      if (me.errors && Object.keys(me.errors).length) {
        return false;
      }
      const validity = me.validity;
      if (validity) {
        return validity.valid;
      }
    }
    return true;
  }
  get isEmpty() {
    return this.value == null || this.value === "";
  }
  get isEmptyInput() {
    return !this.input || this.input.value == null || this.input.value === "";
  }
  get validity() {
    const input = this.input;
    return input === null || input === void 0 ? void 0 : input.validity;
  }
  changeValue(value, was) {
    if (value == null) {
      value = this.nullValue;
    }
    if (this.hasChanged(was, value)) {
      return value;
    }
    if (value === "") {
      this.syncRequired();
    }
    return was;
  }
  updateValue(value, oldValue) {
    const me = this;
    if (!me.isConfiguring) {
      me.syncRequired();
      if (!me.inputting) {
        me.triggerChange();
      }
    }
    if (!me.inputting) {
      me._lastValue = value;
    }
    me.syncInputFieldValue();
    if (me.overflowTwin && !me._overflowTwinSync) {
      me._overflowTwinSync = true;
      me.overflowTwin.value = value;
      me._overflowTwinSync = false;
    }
  }
  hasChanged(oldValue, newValue) {
    return newValue !== oldValue;
  }
  syncInputFieldValue(skipHighlight = false) {
    const me = this, {
      input,
      parent,
      inputValueAttr,
      inputValue
    } = me;
    if (input && !me.inputting && input[inputValueAttr] !== inputValue) {
      input[inputValueAttr] = inputValue;
      if (!me.isConfiguring && !me.containsFocus && me.highlightExternalChange) {
        input.classList.remove("b-field-updated");
        me.clearTimeout("removeUpdatedCls");
        if (parent) {
          const {
            assigningValues
          } = parent;
          if (assigningValues === true || (assigningValues === null || assigningValues === void 0 ? void 0 : assigningValues.highlight) === false) {
            skipHighlight = true;
          }
        }
        if (!skipHighlight) {
          me.highlightChanged();
        }
      }
    }
    me.syncEmpty();
    me.syncInvalid();
  }
  highlightChanged() {
    this.input.classList.add("b-field-updated");
    this.setTimeout("removeUpdatedCls", this.updatedClsDuration);
  }
  removeUpdatedCls() {
    this.input.classList.remove("b-field-updated");
  }
  get inputValue() {
    return this.value == null ? "" : this.value;
  }
  get inputValueAttr() {
    return "value";
  }
  get supportsTextSelection() {
    const input = this.focusElement;
    return input && (input.tagName.toLowerCase() === "textarea" || input.type && /text|search|password|tel|url/.test(input.type));
  }
  internalOnInputFocus() {
    if (this.autoSelect) {
      this.selectAll();
    }
  }
  internalOnChange(event) {
    const me = this;
    if (me.hasChanged(me._lastValue, me.value) && me.isValid) {
      me.triggerChange(event, true);
      me._lastValue = me.value;
    }
  }
  triggerChange(event, userAction = Boolean(this._isUserAction)) {
    const me = this, {
      value,
      _lastValue: oldValue,
      isValid: valid
    } = me;
    me.syncHint();
    me.triggerFieldChange({
      value,
      oldValue,
      event,
      userAction,
      valid
    });
    if (me.defaultAction === "change") {
      me.trigger("action", {
        value,
        oldValue,
        event,
        userAction,
        valid
      });
    }
  }
  fetchInputValue() {
    this.value = this.input[this.inputValueAttr];
  }
  internalOnInput(event) {
    var _me$changeOnKeyStroke;
    const me = this;
    if (!me.validateOnInput) {
      me.errorTip.hide();
    }
    me.inputting = true;
    me.fetchInputValue();
    me.inputting = false;
    me.trigger("input", {
      value: me.value,
      event
    });
    (_me$changeOnKeyStroke = me.changeOnKeyStroke) === null || _me$changeOnKeyStroke === void 0 ? void 0 : _me$changeOnKeyStroke.call(me, event);
  }
  get needsInputSync() {
    var _this$inputValue;
    return this.input[this.inputValueAttr] !== String((_this$inputValue = this.inputValue) !== null && _this$inputValue !== void 0 ? _this$inputValue : "");
  }
  internalOnKeyEvent(event) {
    const me = this, {
      value
    } = me;
    let stopEvent2 = false;
    if (event.type === "keydown") {
      if (event.key === "Escape" && !(me.readOnly || me.disabled)) {
        const wasValid = me.isValid, initialValue = "initialValue" in me ? me.initialValue : me.valueOnFocus, valueChanged = me.hasChanged(initialValue, value), {
          needsInputSync
        } = me;
        if (me.revertOnEscape && (!wasValid || valueChanged || needsInputSync)) {
          if (valueChanged) {
            me.value = initialValue;
          }
          if (needsInputSync) {
            me.syncInputFieldValue(true);
          }
          me.clearError();
          stopEvent2 = (valueChanged || needsInputSync) && me.isValid || wasValid !== me.validOnFocus;
        }
      }
    }
    if (!me.isDestroyed) {
      if (stopEvent2) {
        event.stopImmediatePropagation();
      }
      me.trigger(event.type, {
        event
      });
    }
  }
  clear(event) {
    const me = this, {
      value
    } = me;
    if (value !== me.nullValue || me.input.value.length > 0) {
      me.value = me.nullValue;
      me.clearError();
      me.syncInvalid();
      me.trigger("clear", {
        event
      });
    }
  }
  onDisabled() {
    this.syncInvalid();
  }
  syncRequired() {
    var _me$parent;
    const me = this;
    if (!me.isConfiguring && !me.focusing && me.required && me.isEmpty && !((_me$parent = me.parent) !== null && _me$parent !== void 0 && _me$parent.isSettingValues)) {
      me.setError("L{fieldRequired}", me.updatingInvalid);
    } else {
      me.clearError("L{fieldRequired}", me.updatingInvalid);
    }
  }
  setError(error, silent, temporary) {
    const me = this;
    (me.errors || (me.errors = {}))[me.optionalL(error)] = 1;
    if (!silent) {
      me.syncInvalid();
    }
    if (temporary) {
      const clearError = () => {
        me.clearError(error);
        remover();
      }, remover = me.ion({
        keydown: clearError,
        focusOut: clearError
      });
    }
  }
  clearError(error, silent) {
    const me = this;
    if (me.errors) {
      if (error) {
        delete this.errors[this.optionalL(error)];
      } else {
        me.errors = {};
      }
    }
    if (!silent) {
      me.syncInvalid();
    }
  }
  getErrors() {
    const me = this;
    if (!me.isValid) {
      var _errors;
      const validity = me.validity, stateName = ObjectHelper.keys(validity).find((key) => key !== "valid" && key !== "customError" && validity[key]), errorKeys = me.errors && Object.keys(me.errors);
      let errors;
      if (errorKeys !== null && errorKeys !== void 0 && errorKeys.length) {
        errors = errorKeys;
      } else if (validity.customError) {
        errors = [me.input.validationMessage];
      } else if (stateName) {
        errors = [me.L(stateName, {
          min: me.min,
          max: me.max
        })];
      } else {
        errors = [me.L(me.invalidValueError)];
      }
      if (((_errors = errors) === null || _errors === void 0 ? void 0 : _errors.length) > 0) {
        return errors;
      }
    }
  }
  createOverflowTwin(overrides) {
    const me = this, overflowTwin = super.createOverflowTwin(overrides);
    overflowTwin.ion({
      change({
        value
      }) {
        me._overflowTwinSync = true;
        me.value = value;
        me._overflowTwinSync = false;
      }
    });
    return overflowTwin;
  }
  get containerCollapsed() {
    var _this$container;
    return (_this$container = this.container) === null || _this$container === void 0 ? void 0 : _this$container.collapsed;
  }
  set containerCollapsed(collapsed) {
    const {
      container
    } = this;
    if (container) {
      container.collapsed = collapsed;
    }
  }
  afterSyncChildConfigs(container) {
  }
  changeContainer(config, existing) {
    if (config && (Array.isArray(config) || !("type" in config || "items" in config))) {
      config = {
        items: config
      };
    }
    const me = this, defaults = config && ObjectHelper.merge({
      owner: me,
      layout: "box"
    }, me.containerDefaults), container = Widget.reconfigure(existing, config, {
      owner: me,
      defaults
    });
    if (container) {
      container.autoLayout = (defaults === null || defaults === void 0 ? void 0 : defaults.layout) === "box";
      if (container === existing) {
        container.syncContainer();
        return;
      }
    }
    return container;
  }
  onConfigChange(info) {
    var _this$container2, _this$container2$sync;
    super.onConfigChange(info);
    if ((_this$container2 = this.container) !== null && _this$container2 !== void 0 && (_this$container2$sync = _this$container2.syncConfigTriggers) !== null && _this$container2$sync !== void 0 && _this$container2$sync[info.name]) {
      this.container.syncChildConfigs();
    }
  }
  assignValue(values, options) {
    const me = this, {
      container,
      containValues
    } = me, valueName = me.getValueName(options), storedValue = values && valueName in values;
    if (container && containValues !== false) {
      if (values && containValues === "nested") {
        if (storedValue) {
          values = ObjectHelper.clone(values[valueName]);
          super.assignValue({
            [valueName]: values && !("value" in values) || values.value
          }, options);
          if (values) {
            delete values.value;
          }
          container.assignValue(values, options);
        }
      } else {
        super.assignValue(values, options);
        container.assignValue(values, options);
      }
    } else {
      super.assignValue(values, options);
    }
  }
  gatherValue(values) {
    super.gatherValue(values);
    this.gatherValues(values);
  }
  gatherValues(values, storedValue) {
    var _storedValue;
    const me = this, {
      container,
      containValues,
      valueName
    } = me, cvt = typeof containValues;
    storedValue = (_storedValue = storedValue) !== null && _storedValue !== void 0 ? _storedValue : valueName in values;
    if (container && containValues !== false) {
      if (containValues === "nested") {
        if (storedValue) {
          values[valueName] = _objectSpread2({
            value: values[valueName]
          }, container.values);
        }
      } else if (containValues === true || containValues == null && storedValue || cvt === "string" && me[containValues] || cvt === "function" && containValues(me)) {
        container.gatherValues(values);
      }
    }
  }
  updateContainer(container, was) {
    was && this.detachListeners(was.id);
    if (container) {
      if (!container.rendered) {
        container.render();
      }
      container.syncContainer();
      container.syncChildConfigs();
    }
  }
};
Field.Trigger = class FieldTrigger extends Widget {
  static get $name() {
    return "FieldTrigger";
  }
  static get factoryable() {
    return {
      defaultType: Field.Trigger,
      extends: null
    };
  }
  static get type() {
    return "trigger";
  }
  static get configurable() {
    return {
      align: null,
      weight: null,
      role: void 0
    };
  }
  get field() {
    return this.parent;
  }
  construct() {
    super.construct(...arguments);
    if (this.key) {
      this.keyMap = {
        [this.key]: "onClick"
      };
    }
  }
  compose() {
    return {
      "aria-hidden": true,
      class: {
        [`b-align-${this.align || "end"}`]: 1,
        "b-icon": 1
      },
      listeners: {
        click: "onClick",
        mousedown: "onMousedown"
      }
    };
  }
  changeAlign(align) {
    return align;
  }
  onClick(e) {
    const me = this, {
      field
    } = me;
    if (!(field.disabled || field.readOnly)) {
      if (e.key) {
        e.preventDefault();
      }
      if (field.trigger("trigger", {
        trigger: me
      }) !== false && me.handler) {
        field.callback(me.handler, field, [e, me]);
      }
    }
  }
  onMousedown(e) {
    const field = this.field, isKeyEvent = "key" in e;
    if (!isKeyEvent && DomHelper.isTouchEvent) {
      if (field.editable) {
        field.editable = false;
        field.setTimeout(() => field.editable = true, 500);
      }
    }
    e.preventDefault();
    if (DomHelper.getActiveElement(field.input) !== field.input) {
      field.focus();
    }
  }
};
Field.SpinTrigger = class SpinTrigger extends Field.Trigger {
  static get $name() {
    return "SpinTrigger";
  }
  static get type() {
    return "spintrigger";
  }
  static get configurable() {
    return {
      repeat: {
        $config: ["nullify"],
        value: true
      }
    };
  }
  compose() {
    return {
      children: {
        upButton: {
          class: {
            "b-icon": 1,
            "b-spin-up": 1
          }
        },
        downButton: {
          class: {
            "b-icon": 1,
            "b-spin-down": 1
          }
        }
      }
    };
  }
  updateRepeat(repeat) {
    var _this$clickRepeater;
    (_this$clickRepeater = this.clickRepeater) === null || _this$clickRepeater === void 0 ? void 0 : _this$clickRepeater.destroy();
    this.clickRepeater = repeat ? ClickRepeater.new({
      element: this.element
    }, repeat) : null;
  }
  onClick(e) {
    const me = this, {
      field
    } = me;
    if (!(field.disabled || field.readOnly)) {
      if (e.target === me.upButton) {
        field.doSpinUp(e.shiftKey);
      } else if (e.target === me.downButton) {
        field.doSpinDown(e.shiftKey);
      }
    }
  }
};
Field.Trigger.initClass();
Field.SpinTrigger.initClass();
Widget.register(Field.Trigger, "trigger");
Widget.register(Field.SpinTrigger, "spintrigger");
Field._$name = "Field";
var TextField = class extends Field {
  static get type() {
    return "textfield";
  }
  static get alias() {
    return "text";
  }
  static get configurable() {
    return {
      nullValue: ""
    };
  }
  static get $name() {
    return "TextField";
  }
  construct(config) {
    if ((config === null || config === void 0 ? void 0 : config.inputType) === "hidden") {
      config.hidden = true;
    }
    super.construct(...arguments);
  }
};
TextField.initClass();
TextField._$name = "TextField";
var PickerField = class extends TextField {
  static get $name() {
    return "PickerField";
  }
  static get type() {
    return "pickerfield";
  }
  static get configurable() {
    return {
      editable: true,
      pickerAlignElement: "inputWrap",
      value: null,
      triggers: {
        expand: {
          cls: "bars"
        }
      },
      autoClose: true,
      autoExpand: null,
      picker: {
        value: {
          floating: true
        },
        $config: ["lazy", "nullify"]
      },
      inputType: "text",
      monitorResize: true,
      nullValue: null
    };
  }
  doDestroy() {
    var _this$globalTapListen;
    (_this$globalTapListen = this.globalTapListener) === null || _this$globalTapListen === void 0 ? void 0 : _this$globalTapListen.call(this);
    super.doDestroy();
  }
  updateEditable(editable) {
    const me = this, {
      element,
      ariaElement
    } = me;
    super.updateEditable(...arguments);
    if (editable === false) {
      var _me$globalTapListener;
      ariaElement.removeAttribute("aria-autocomplete");
      (_me$globalTapListener = me.globalTapListener) === null || _me$globalTapListener === void 0 ? void 0 : _me$globalTapListener.call(me);
      element.classList.add("b-not-editable");
      EventHelper.on({
        element: me.nonEditableClickTarget,
        click: (e) => {
          const target = document.elementFromPoint(e.clientX, e.clientY);
          if (e.target === me.nonEditableClickTarget && target === me.nonEditableClickTarget) {
            me.onTriggerClick(e);
          }
        },
        thisObj: me
      });
    } else {
      ariaElement.setAttribute("aria-autocomplete", "list");
      me.globalTapListener = GlobalEvents$1.ion({
        globaltap: "showKeyboard",
        thisObj: me
      });
    }
  }
  get nonEditableClickTarget() {
    return this.input;
  }
  updateElement(element, oldElement) {
    var _this$constructor$res;
    const result = super.updateElement(element, oldElement), picker = this.peekConfig("picker"), role = picker ? picker.isWidget ? picker.role : (_this$constructor$res = this.constructor.resolveType(picker.type)) === null || _this$constructor$res === void 0 ? void 0 : _this$constructor$res.$meta.config.role : false;
    this.ariaHasPopup = role;
    return result;
  }
  changePicker(picker, oldPicker) {
    throw new Error("changePicker(oldPicker, newPicker) must be implemented in PickerField subclass implementations");
  }
  get childItems() {
    const result = super.childItems;
    if (this._picker) {
      result.push(this.picker);
    }
    return result;
  }
  onEditComplete() {
    super.onEditComplete();
    this.autoClosePicker();
  }
  onElementResize(resizedElement) {
    const me = this;
    if (me.pickerVisible) {
      me.picker.requestAnimationFrame(me.picker.realign, null, me.picker);
    }
    super.onElementResize(resizedElement);
  }
  internalOnKeyEvent(event) {
    const me = this;
    let callSuper = true;
    if (event.type === "keydown" && !me.disabled && !event.shiftKey && !event.ctrlKey) {
      if (me.pickerVisible) {
        const {
          picker
        } = me;
        if (event.key === "Escape") {
          event.preventDefault();
          event.stopImmediatePropagation();
          me.hidePicker();
          callSuper = false;
        } else if (picker.onInternalKeyDown) {
          picker.onInternalKeyDown(event);
        } else if (event.key === "ArrowDown") {
          if (picker.focusable) {
            picker.focus();
          }
        }
      } else if (event.key === "ArrowDown") {
        event.stopImmediatePropagation();
        event.preventDefault();
        me.onTriggerClick(event);
      }
    }
    if (callSuper) {
      super.internalOnKeyEvent(event);
    }
  }
  onFocusIn(e) {
    const me = this;
    super.onFocusIn(e);
    if (me.autoExpand) {
      me.minChars = 0;
      me.onTriggerClick(e);
      me.ignoreTriggerClick = true;
      me.setTimeout(() => me.ignoreTriggerClick = false, 100);
    }
  }
  onTriggerClick(event) {
    if (!this.disabled) {
      this.togglePicker("key" in event);
    }
  }
  showKeyboard({
    event
  }) {
    const input = this.input;
    if (DomHelper.isTouchEvent && DomHelper.getActiveElement(input) === input && event.target === input) {
      GlobalEvents$1.suspendFocusEvents();
      input.blur();
      input.focus();
      GlobalEvents$1.resumeFocusEvents();
    }
  }
  togglePicker(focus) {
    if (this.pickerVisible) {
      this.hidePicker();
    } else {
      this.showPicker(focus);
    }
  }
  showPicker(focus) {
    const me = this, {
      picker
    } = me;
    if (!me.pickerHideShowListenersAdded) {
      picker.ion({
        show: "onPickerShow",
        hide: "onPickerHide",
        thisObj: me
      });
      me.pickerHideShowListenersAdded = true;
    }
    DomHelper.setAttributes(me.ariaElement, {
      "aria-controls": picker.id,
      "aria-expanded": true
    });
    picker.autoClose = me.autoClose;
    picker.show();
    if (picker.isVisible) {
      if (focus) {
        me.focusPicker();
      }
    }
  }
  onPickerShow() {
    const me = this;
    me.pickerVisible = true;
    me.element.classList.add("b-open");
    me.trigger("togglePicker", {
      show: true
    });
    me.pickerTapOutRemover = GlobalEvents$1.ion({
      globaltap: "onPickerTapOut",
      thisObj: me
    });
    me.pickerKeyDownRemover = EventHelper.on({
      element: me.picker.element,
      keydown: "onPickerKeyDown",
      thisObj: me
    });
  }
  onPickerHide() {
    var _me$pickerTapOutRemov, _me$pickerKeyDownRemo;
    const me = this;
    me.ariaElement.setAttribute("aria-expanded", false);
    me.pickerVisible = false;
    me.element.classList.remove("b-open");
    me.trigger("togglePicker", {
      show: false
    });
    (_me$pickerTapOutRemov = me.pickerTapOutRemover) === null || _me$pickerTapOutRemov === void 0 ? void 0 : _me$pickerTapOutRemov.call(me);
    (_me$pickerKeyDownRemo = me.pickerKeyDownRemover) === null || _me$pickerKeyDownRemo === void 0 ? void 0 : _me$pickerKeyDownRemo.call(me);
  }
  onPickerTapOut({
    event
  }) {
    if (!this.containsFocus && !this.owns(event.target)) {
      this.autoClosePicker();
    }
  }
  onPickerKeyDown(event) {
    if (event.key === "Tab" && !this.picker.trapFocus) {
      const activeEl = DomHelper.getActiveElement(this.input), forwardedEvent = new KeyboardEvent("keydown", event);
      this.input.dispatchEvent(forwardedEvent);
      if (forwardedEvent.defaultPrevented) {
        event.preventDefault();
      }
      if (DomHelper.getActiveElement(this.input) === activeEl) {
        this.input.focus();
      } else {
        event.preventDefault();
      }
      if (!this.isDestroyed) {
        this.hidePicker();
      }
    }
  }
  autoClosePicker() {
    if (this.autoClose) {
      this.hidePicker();
    }
  }
  hidePicker() {
    if (this.pickerVisible) {
      this.picker.hide();
    }
  }
  focusPicker() {
  }
  focus() {
    const input = this.input;
    if (DomHelper.isTouchEvent && this.editable) {
      input.readOnly = true;
      this.setTimeout(() => input.readOnly = false, 500);
    }
    super.focus();
  }
};
PickerField._$name = "PickerField";
var itemRange = document.createRange();
var List = class extends Widget {
  static get $name() {
    return "List";
  }
  static get type() {
    return "list";
  }
  static get configurable() {
    return {
      itemCls: "b-list-item",
      selectedCls: "b-selected",
      selectIconCls: "b-icon-check",
      tag: "ul",
      items: null,
      displayField: "text",
      store: null,
      navigator: true,
      scrollable: {
        overflowX: false,
        overflowY: true
      },
      itemsFocusable: true,
      multiSelect: false,
      toggleAllIfCtrlPressed: false,
      selectAllItem: false,
      itemTpl(record) {
        let text = StringHelper.encodeHtml(record[this.displayField]);
        if (text == null || text === "") {
          text = "&nbsp;";
        }
        return text;
      },
      getItemStyle: null,
      getItemCls: null,
      groupHeaderTpl: (record, groupName) => {
        let name = StringHelper.encodeHtml(groupName);
        if (name == null || name === "") {
          name = "&nbsp;";
        }
        return name;
      },
      allowGroupSelect: true,
      selected: {
        $config: "nullify",
        value: {}
      },
      activateOnMouseover: null,
      role: "listbox",
      keyMap: {
        "Ctrl+a": "selectAll"
      }
    };
  }
  construct(config, ...args) {
    var _me$store;
    const me = this;
    if (Array.isArray(config)) {
      config = {
        items: config
      };
    }
    super.construct(config, ...args);
    const {
      element
    } = me, {
      classList
    } = element;
    if (me.multiSelect) {
      classList.add("b-multiselect");
    }
    if ((_me$store = me.store) !== null && _me$store !== void 0 && _me$store.count) {
      me.refresh();
    } else {
      classList.add("b-empty");
    }
    EventHelper.on({
      element,
      delegate: me.itemSelector,
      mouseover: "onMouseOver",
      click: "onClick",
      thisObj: me
    });
  }
  doDestroy() {
    var _this$navigator;
    this.detachListeners("store");
    (_this$navigator = this.navigator) === null || _this$navigator === void 0 ? void 0 : _this$navigator.destroy();
    super.doDestroy();
  }
  onFocusIn(e) {
    var _e$_target;
    this.restoreActiveItem((_e$_target = e._target) === null || _e$_target === void 0 ? void 0 : _e$_target.closest(this.itemSelector));
    super.onFocusIn(e);
  }
  contentTpl() {
    const me = this, allRecordsTpl = me.store.records.map((record, i) => me.itemWrapperTpl(record, i));
    if (me.multiSelect && me.selectAllItem !== false) {
      allRecordsTpl.unshift(me.selectAllItemTpl());
    }
    return TemplateHelper.tpl`${allRecordsTpl}`;
  }
  itemWrapperTpl(record, i) {
    const {
      selected,
      getItemStyle
    } = this, style = getItemStyle ? `style="${this.callback(getItemStyle, this, [record])}"` : "";
    return TemplateHelper.tpl`<li ${style} class="${this.getItemClasses(record, i)}" role="option" aria-selected="${selected.includes(record)}" data-index="${i}" data-id="${StringHelper.encodeHtml(record.id)}" ${this.itemsFocusable ? 'tabindex="-1"' : ""}>${this.itemContentTpl(record, i)}</li>`;
  }
  itemContentTpl(record, i) {
    if ("groupRowFor" in record.meta) {
      return this.groupHeaderTpl(record, StringHelper.capitalize(record.groupChildren[0][record.meta.groupField]));
    }
    return `${this.itemIconTpl(record, i)}${this.itemTpl(record, i)}`;
  }
  itemIconTpl(record, i) {
    return this.multiSelect ? `<i class="b-selected-icon b-icon ${this.selectIconCls}"></i>` : "";
  }
  selectAllItemTpl() {
    const selectedCls = this.allSelected ? "b-selected" : "";
    return `<li class="${this.itemCls} b-select-all-item ${selectedCls}" data-noselect data-select-all data-id="select-all">${this.itemIconTpl({})}<div>${this.optionalL("Select All")}</div></li>`;
  }
  getItemClasses(record) {
    var _me$_navigator;
    const me = this, {
      getItemCls
    } = me, activeItem = (_me$_navigator = me._navigator) === null || _me$_navigator === void 0 ? void 0 : _me$_navigator.activeItem, isActive = (activeItem === null || activeItem === void 0 ? void 0 : activeItem.dataset.id) == record.id, groupHeaderCls = "groupRowFor" in record.meta ? "b-list-item-group-header" : "", isSelected = me.selected.includes(record), itemCls = getItemCls ? this.callback(getItemCls, this, [record]) : "";
    return `${me.itemCls} ${record.cls || ""} ${itemCls} ${isSelected ? me.selectedCls : ""} ${isActive ? me.navigator.focusCls : ""} ${groupHeaderCls}`;
  }
  onBeforeStoreLoad() {
    this.mask(this.L("L{loading}"));
  }
  onAfterStoreRequest() {
    this.unmask();
  }
  onStoreChange({
    source: store,
    action,
    records,
    record,
    changes
  }) {
    const me = this, {
      selected
    } = me;
    switch (action) {
      case "dataset": {
        selected.match(store.storage, !me._externallyOwnedSelection);
        break;
      }
      case "remove":
        selected.remove(records);
        break;
      case "clear":
        me.deselectAll();
        break;
      case "update": {
        const {
          id
        } = changes;
        if (id) {
          DomHelper.setAttributes(me.contentElement.querySelector(StringHelper.encodeAttributeSelector(`data-id`, id.oldValue)), {
            "data-id": id.value
          });
        }
        me.refreshItem(record);
        return;
      }
    }
    me.refresh();
  }
  onStoreRefresh() {
    this.refresh();
  }
  refresh() {
    const me = this;
    if (me.isVisible) {
      var _me$navigator;
      const activeItem = (_me$navigator = me.navigator) === null || _me$navigator === void 0 ? void 0 : _me$navigator.activeItem;
      me.paintListener = null;
      const node = DomHelper.createElementFromTemplate(me.contentTpl(), {
        fragment: true
      });
      me.clearItems().insertNode(node);
      if (activeItem) {
        me.restoreActiveItem(activeItem);
      }
      me.refreshCount = (me.refreshCount || 0) + 1;
      me.element.classList[me.store.count > 0 ? "remove" : "add"]("b-empty");
      me.updateSelectAllState();
    } else if (!me.paintListener) {
      me.paintListener = me.ion({
        paint: "refresh",
        thisObj: me,
        once: true
      });
    }
  }
  clearItems() {
    const me = this, firstItem = me.contentElement.querySelector(me.itemSelector), lastChild = me.contentElement.lastChild;
    if (firstItem) {
      const items2 = me.contentElement.querySelectorAll(`${me.itemSelector}:not(.b-mask)`);
      itemRange.setStartBefore(firstItem);
      itemRange.setEndAfter(items2[items2.length - 1]);
      itemRange.deleteContents();
    } else {
      if (lastChild) {
        itemRange.setStartAfter(lastChild);
        itemRange.setEndAfter(lastChild);
      } else {
        itemRange.setStart(me.contentElement, 0);
        itemRange.setEnd(me.contentElement, 0);
      }
    }
    return itemRange;
  }
  refreshItem(...records) {
    for (const record of records) {
      const item = this.getItem(record);
      if (item) {
        const index = this.store.indexOf(record), newItem = DomHelper.createElementFromTemplate(this.itemWrapperTpl(record, index));
        DomHelper.sync(newItem, item);
      }
    }
  }
  getItem(recordOrId) {
    if (recordOrId != null) {
      var _recordOrId;
      if (typeof recordOrId === "number") {
        return this.contentElement.querySelector(`[data-index="${recordOrId < 0 ? this.store.count + recordOrId : recordOrId}"]`);
      } else if (recordOrId.nodeType === Element.ELEMENT_NODE) {
        recordOrId = recordOrId.dataset.id;
      }
      if (((_recordOrId = recordOrId) === null || _recordOrId === void 0 ? void 0 : _recordOrId.id) != null) {
        recordOrId = recordOrId.id;
      }
      return this.contentElement.querySelector(StringHelper.encodeAttributeSelector(`data-id`, recordOrId));
    }
  }
  getRecordFromElement(element) {
    if (element.target) {
      element = element.target;
    }
    element = element.closest(this.itemSelector);
    return this.store.getAt(parseInt(element.dataset.index));
  }
  updateItems(items2) {
    const me = this;
    if (me.store && me.store.autoCreated) {
      me.store.destroy();
    }
    me.store = Store.getStore(items2);
  }
  updateDisabled(disabled) {
    super.updateDisabled(...arguments);
    this.navigator && (this.navigator.disabled = disabled);
  }
  changeSelected(selected, oldSelected) {
    if (selected) {
      let initialSelection;
      if (selected.isCollection) {
        this._externallyOwnedSelection = true;
      } else {
        if (Array.isArray(selected)) {
          initialSelection = selected;
          selected = {};
        } else if (selected.values) {
          initialSelection = selected.values;
          selected = _objectSpread2(_objectSpread2({}, selected), {}, {
            values: []
          });
        }
        selected = new Collection(selected);
      }
      selected.ion({
        change: "onSelectionChange",
        thisObj: this
      });
      this.initialSelection = initialSelection;
    } else {
      oldSelected === null || oldSelected === void 0 ? void 0 : oldSelected.destroy();
    }
    return selected;
  }
  get itemSelector() {
    return `.${this.itemCls}`;
  }
  get selected() {
    return this._selected;
  }
  get store() {
    this.getConfig("items");
    return this._store;
  }
  changeStore(store) {
    const me = this;
    if (!(store instanceof Store)) {
      if (Array.isArray(store)) {
        store = {
          data: store
        };
      }
      store = new Store(store);
    }
    me.detachListeners("store");
    if (store) {
      const storeListeners = {
        name: "store",
        change: "onStoreChange",
        refresh: "onStoreRefresh",
        thisObj: me
      };
      if (store.readUrl) {
        storeListeners.beforeLoad = "onBeforeStoreLoad";
        storeListeners.afterRequest = "onAfterStoreRequest";
      }
      if (store.isGrouped) {
        me.element.classList.add("b-grouped");
        storeListeners.groupchange = "onStoreRefresh";
      }
      store.ion(storeListeners);
    }
    return store;
  }
  updateStore(store) {
    const {
      initialSelection
    } = this;
    if (initialSelection !== null && initialSelection !== void 0 && initialSelection.length) {
      if (store.count) {
        this.select(initialSelection);
      } else {
        store.ion({
          refresh: () => this.select(initialSelection),
          once: true
        });
      }
    }
    this.refresh();
  }
  changeNavigator(navigator2, oldNavigator) {
    const me = this, {
      element
    } = me;
    if (element) {
      var _navigator;
      navigator2 = Navigator.reconfigure(oldNavigator, navigator2 ? Navigator.mergeConfigs({
        ownerCmp: me,
        disabled: me.disabled,
        target: element,
        keyEventTarget: element
      }, navigator2) : null, me);
      if (((_navigator = navigator2) === null || _navigator === void 0 ? void 0 : _navigator.keyEventTarget) === element && !me.itemsTabbable) {
        element.tabIndex = 0;
      }
    }
    return navigator2;
  }
  get minAlignHeight() {
    const lastItem = this.element.lastElementChild, minHeight = this.minHeight;
    if (minHeight != null) {
      return lastItem ? Math.min(lastItem.offsetTop + lastItem.offsetHeight, minHeight) : 0;
    }
  }
  alignTo(...args) {
    super.minHeight = this.minAlignHeight;
    super.alignTo(...args);
  }
  hide(...args) {
    this.navigator && (this.navigator.activeItem = null);
    return super.hide(...args);
  }
  show() {
    const {
      refreshCount
    } = this, {
      previousActiveItem
    } = this.navigator;
    super.minHeight = this._minHeight;
    const retVal = super.show(...arguments);
    if (this.refreshCount === refreshCount) {
      this.restoreActiveItem(previousActiveItem, true);
    }
    return retVal;
  }
  restoreActiveItem(activeItem = this.navigator.previousActiveItem, block = "nearest") {
    const me = this, {
      navigator: navigator2,
      lastAlignSpec
    } = me;
    if (activeItem != null) {
      if (typeof block !== "string") {
        const alignZone = lastAlignSpec ? lastAlignSpec.zone : 1;
        block = alignZone & 1 ? "nearest" : alignZone ? "start" : "end";
      }
      activeItem = me.getItem(activeItem);
      if (activeItem && !me.disabled) {
        me.scrollable.scrollIntoView(activeItem, {
          block
        });
        navigator2.activeItem = activeItem;
      }
    }
  }
  onMouseOver(event) {
    const me = this, itemElement = event.currentTarget;
    if (!DomHelper.isTouchEvent && itemElement && me.navigator && me.activateOnMouseover) {
      me.setTimeout({
        fn: "handleMouseOver",
        delay: 30,
        args: [itemElement],
        cancelOutstanding: true
      });
    }
  }
  handleMouseOver(itemElement) {
    this.navigator.activeItem = itemElement;
  }
  onClick(event) {
    const itemElement = event.target.closest(this.itemSelector);
    if (itemElement) {
      this.onItemClick(itemElement, event);
    }
  }
  onInternalKeyDown(event) {
    const me = this, active = me.navigator.activeItem;
    if (me.disabled) {
      return;
    }
    switch (event.key) {
      case " ":
        if (event.target.nodeName.toUpperCase() === "INPUT" && !event.target.readOnly) {
          break;
        }
      case "Enter":
        if (active) {
          this.onItemClick(active, event);
          event.stopImmediatePropagation();
          event.preventDefault();
        }
    }
  }
  onItemClick(item, event) {
    const me = this, index = parseInt(item.dataset.index);
    let record = me.store.getAt(index);
    if (me.disabled || me.trigger("beforeItem", {
      item,
      record,
      index,
      event,
      userAction: true
    }) === false) {
      return;
    }
    me._isUserAction = true;
    if (me.allowGroupSelect || record && !record.isSpecialRow) {
      if (!item.contains(event.target.closest("[data-noselect]"))) {
        const selected = me.selected;
        let isSelected = selected.includes(record);
        if (me.multiSelect) {
          if (me.toggleAllIfCtrlPressed && event.ctrlKey) {
            record = me.store.records;
          } else if (me.allowGroupSelect && record.isSpecialRow) {
            isSelected = !record.groupChildren.some((rec) => !selected.includes(rec));
            record = record.groupChildren;
          }
          selected[isSelected ? "remove" : "add"](record);
        } else {
          selected.splice(0, selected.count, record);
        }
      } else if (item.contains(event.target.closest("[data-select-all]"))) {
        me.onSelectAllClick(item, event);
      }
    }
    me.lastClicked = record;
    me.trigger("item", {
      item,
      record,
      index,
      event,
      userAction: true
    });
    me._isUserAction = false;
  }
  onSelectionChange({
    action,
    removed,
    added,
    replaced
  }) {
    const me = this, {
      selectedCls,
      unselectedCls
    } = me;
    let record, item;
    if (action === "clear") {
      for (item of me.element.querySelectorAll(`.${selectedCls}`)) {
        item.classList.remove(selectedCls);
        item.setAttribute("aria-selected", false);
        unselectedCls && item.classList.remove(unselectedCls);
      }
    } else if (action !== "replaceValues") {
      for (record of removed) {
        item = me.getItem(record);
        if (item) {
          item.classList.remove(selectedCls);
          item.setAttribute("aria-selected", false);
        }
      }
      for (record of added) {
        item = me.getItem(record);
        if (item) {
          item.classList.add(selectedCls);
          item.setAttribute("aria-selected", true);
        }
      }
    }
    me.selectAllItem && me.updateSelectAllState();
  }
  onSelectAllClick(item) {
    const checked = item.classList.contains(this.selectedCls);
    if (checked) {
      this.deselectAll();
    } else {
      this.selectAll();
    }
  }
  updateSelectAllState() {
    var _this$element$querySe;
    (_this$element$querySe = this.element.querySelector(".b-select-all-item")) === null || _this$element$querySe === void 0 ? void 0 : _this$element$querySe.classList.toggle(this.selectedCls, this.allSelected);
  }
  get allSelected() {
    const {
      selected,
      store
    } = this;
    return selected.count && (store.isFiltered ? store.records.every((r) => selected.includes(r)) : store.count === selected.count);
  }
  selectAll(keyEvent) {
    const me = this;
    if (me.multiSelect || !keyEvent) {
      me.selected.add(me.store.records);
      if (keyEvent && !me.navigator.activeItem) {
        me.navigator.activeItem = me.getItem(-1);
      }
    }
  }
  deselectAll() {
    this.selected.clear();
  }
  select(toSelect) {
    const {
      store
    } = this, {
      modelClass
    } = store;
    toSelect = ArrayHelper.asArray(toSelect).reduce((v, c) => {
      c = store.getById(modelClass.asId(c));
      if (c) {
        v.push(c);
      }
      return v;
    }, []);
    this.selected.add(toSelect);
  }
  deselect(toDeselect) {
    const {
      modelClass
    } = this.store;
    toDeselect = ArrayHelper.asArray(toDeselect).reduce((v, c) => {
      c = this.selected.get(modelClass.asId(c));
      if (c) {
        v.push(c);
      }
      return v;
    }, []);
    this.selected.remove(toDeselect);
  }
};
List.initClass();
List.prototype.navigatorClass = Navigator;
List._$name = "List";
var ChipView = class extends List {
  static get $name() {
    return "ChipView";
  }
  static get type() {
    return "chipview";
  }
  static get configurable() {
    return {
      itemCls: "b-chip",
      multiSelect: false,
      closable: true,
      iconTpl: null,
      closeHandler: null
    };
  }
  itemContentTpl(record, i) {
    const me = this;
    return TemplateHelper.tpl`${me.iconTpl ? this.iconTpl(record) : ""}
            ${me.itemTpl(record, i)}
            ${me.closable ? '<div class="b-icon b-close-icon b-icon-clear" data-noselect></div>' : ""}`;
  }
  onInternalKeyDown(event) {
    const me = this;
    if (me.closable && me.selected.count && (event.key === "Delete" || event.key === "Backspace")) {
      me.callback(me.closeHandler, me.owner, [me.selected.values, {
        isKeyEvent: true
      }]);
    } else {
      super.onInternalKeyDown(event);
    }
  }
  updateClosable(closable) {
    this.element.classList[closable ? "add" : "remove"]("b-chips-closable");
    this.navigator && (this.navigator.disabled = !closable);
    if (!this.isConfiguring) {
      this.refresh();
    }
  }
  onClick(event) {
    const me = this, item = event.target.closest(`.${me.itemCls}`);
    if (me.closable && event.target.classList.contains("b-close-icon")) {
      const record = me.store.getAt(parseInt(item.dataset.index));
      me.callback(me.closeHandler, me.owner, [[record]]);
    } else {
      super.onClick(event);
    }
  }
};
ChipView.initClass();
ChipView._$name = "ChipView";
var errorFieldRequired = "L{Field.fieldRequired}";
var errorValidateFilter = "L{Field.validateFilter}";
var errorRecordNotCommitted = "L{Combo.recordNotCommitted}";
var Combo = class extends PickerField {
  static get $name() {
    return "Combo";
  }
  static get type() {
    return "combo";
  }
  static get alias() {
    return "combobox,dropdown";
  }
  static get configurable() {
    return {
      primaryFilter: {},
      picker: {
        type: "list",
        floating: true,
        scrollAction: "realign",
        itemsFocusable: false,
        activateOnMouseover: true,
        align: {
          align: "t0-b0",
          axisLock: true
        },
        maxHeight: 324,
        scrollable: {
          overflowY: true
        },
        autoShow: false,
        focusOnHover: false
      },
      multiSelect: null,
      items: null,
      store: null,
      valueField: void 0,
      displayField: "text",
      pickerWidth: null,
      minChars: null,
      selected: null,
      listItemTpl: null,
      displayValueRenderer: null,
      listCls: null,
      triggers: {
        expand: {
          cls: "b-icon-picker",
          handler: "onTriggerClick"
        }
      },
      filterParamName: null,
      encodeFilterParams: (filters) => filters.map((f) => f.value),
      filterOnEnter: false,
      hideTrigger: null,
      overlayAnchor: null,
      keyStrokeFilterDelay: null,
      defaultAction: "select",
      triggerAction: "all",
      filterOperator: "startsWith",
      caseSensitive: false,
      hidePickerOnSelect: null,
      chipView: {
        $config: ["lazy", "nullify"],
        value: {
          type: "combochipview"
        }
      },
      chipStore: {
        $config: ["lazy", "nullify"],
        value: {}
      },
      filterSelected: null,
      emptyText: null,
      value: null,
      valueCollection: {
        $config: ["nullify", "lazy"],
        value: {}
      },
      validateFilter: true,
      clearTextOnPickerHide: true,
      destroyStore: false,
      multiValueSeparator: ",",
      createOnUnmatched: null,
      role: "combobox",
      inlinePicker: null,
      testConfig: {
        keyStrokeFilterDelay: 0
      },
      localizeDisplayFields: false,
      buildItems: null
    };
  }
  static get queryLast() {
    return "last";
  }
  construct(config) {
    super.construct(...arguments);
    if (!this.store) {
      this.items = [];
    }
    if (this.filterOnEnter) {
      this.hideTrigger = true;
    }
  }
  startConfigure(config) {
    this.usingRecordAsValue = config.valueField === null;
    super.startConfigure(...arguments);
  }
  afterConfigure() {
    super.afterConfigure();
    const me = this;
    if (!ObjectHelper.hasOwn(me, "_value")) {
      me._value = me.valueField === me.displayField ? "" : null;
      me._lastValue = me._lastValue || me._value;
    }
  }
  get childItems() {
    const {
      _chipView,
      _picker
    } = this, result = super.childItems;
    if (_chipView) {
      result.push(_chipView);
    }
    if (_picker) {
      result.push(_picker);
    }
    return result;
  }
  get innerElements() {
    var _this$_chipView;
    const chipViewElement = (_this$_chipView = this._chipView) === null || _this$_chipView === void 0 ? void 0 : _this$_chipView.element, {
      input,
      inputElement
    } = this;
    if (chipViewElement) {
      DomSync.sync({
        targetElement: input,
        domConfig: inputElement
      });
    }
    return [chipViewElement || inputElement];
  }
  updateInlinePicker(inlinePicker) {
    if (inlinePicker) {
      this.element.classList.add("b-inline-picker");
      this.getConfig("picker");
      this.triggers.expand = null;
      this.pickerVisible = true;
    }
  }
  hidePicker() {
    if (!this.inlinePicker) {
      return super.hidePicker(...arguments);
    }
  }
  changeChipStore(chipStore) {
    if (chipStore && !(chipStore instanceof Store)) {
      chipStore = new Store(Store.mergeConfigs({
        storage: this.valueCollection
      }, chipStore));
    }
    return chipStore;
  }
  updateChipStore(store, was) {
    was === null || was === void 0 ? void 0 : was.destroy();
  }
  changeChipView(chipView, oldChipView) {
    const me = this;
    me.element.classList[chipView ? "add" : "remove"]("b-uses-chipview");
    if (chipView) {
      const {
        input
      } = me;
      if (!me.chipStore) {
        me.chipStore = {};
      }
      return ComboChipView.reconfigure(oldChipView, chipView, {
        defaults: {
          parent: me,
          insertBefore: input,
          store: me.chipStore,
          closable: !me.readOnly,
          navigator: {
            type: "combochipnavigator",
            keyEventTarget: input
          }
        }
      });
    }
    oldChipView === null || oldChipView === void 0 ? void 0 : oldChipView.destroy();
  }
  updateChipView(chipView) {
    var _me$_chipViewEventDet;
    const me = this;
    me._chipViewEventDetacher = (_me$_chipViewEventDet = me._chipViewEventDetacher) === null || _me$_chipViewEventDet === void 0 ? void 0 : _me$_chipViewEventDet.call(me);
    me.chipStore = chipView === null || chipView === void 0 ? void 0 : chipView.store;
    if (chipView) {
      chipView.element.appendChild(me.input);
      me._chipViewEventDetacher = EventHelper.on({
        element: chipView.element,
        mousedown: "onChipViewMousedown",
        thisObj: me
      });
    }
  }
  updateMultiSelect(multiSelect, oldMultiSelect) {
    const me = this, {
      input,
      element
    } = me, fixValue = !me.isConfiguring;
    let {
      value
    } = me;
    element.classList[multiSelect ? "add" : "remove"]("b-multiselect");
    if (multiSelect) {
      const {
        chipView
      } = me, {
        parentNode: parentNode2
      } = input, chipViewEl = chipView === null || chipView === void 0 ? void 0 : chipView.element;
      if (chipViewEl && chipViewEl !== parentNode2) {
        parentNode2.insertBefore(chipViewEl, input);
        chipViewEl.appendChild(input);
        me.chipView.refresh();
      }
      input.value = "";
      if (fixValue) {
        value = ArrayHelper.asArray(value);
      }
    } else {
      const chipView = me._chipView, {
        parentNode: parentNode2
      } = input, chipViewEl = chipView === null || chipView === void 0 ? void 0 : chipView.element;
      if (chipViewEl === parentNode2) {
        chipViewEl.parentNode.insertBefore(input, chipViewEl);
        chipViewEl.remove();
        element.classList.remove("b-uses-chipview");
      }
      if (fixValue && typeof value !== "string") {
        var _value;
        value = (_value = value) !== null && _value !== void 0 && _value.length ? value[0] : null;
      }
    }
    if (fixValue) {
      me.value = value;
    }
  }
  onChipViewMousedown(mousedownEvent) {
    mousedownEvent.preventDefault();
    if (!this.containsFocus) {
      this.focus();
    }
  }
  onChipClose(records, options = {}) {
    if (options.isKeyEvent && this.input.value === "" || !options.isKeyEvent) {
      this._isUserAction = true;
      this.valueCollection.remove(records);
      this._isUserAction = false;
    }
  }
  updateFilterParamName(filterParamName) {
    if (this.hideTrigger !== false) {
      this.hideTrigger = Boolean(filterParamName);
    }
  }
  updateHideTrigger(hideTrigger) {
    this.element.classList[hideTrigger ? "add" : "remove"]("b-hide-trigger");
  }
  updateKeyStrokeFilterDelay(delay2) {
    this.filterOnInput.delay = delay2;
  }
  updateReadOnly(readOnly) {
    super.updateReadOnly(...arguments);
    this._chipView && (this._chipView.closable = !readOnly);
  }
  updateDisabled(disabled) {
    super.updateDisabled(...arguments);
    this._chipView && (this._chipView.closable = !disabled);
  }
  updateFilterOperator(filterOperator) {
    if (this.primaryFilter) {
      this.primaryFilter.operator = filterOperator;
    }
  }
  get minChars() {
    const minChars = this._minChars;
    if (minChars != null) {
      return minChars;
    }
    return this.remoteFilter ? 4 : 1;
  }
  get validateFilter() {
    return this._validateFilter && !this.createOnUnmatched;
  }
  get items() {
    return this.store.allRecords;
  }
  updateBuildItems(fn2) {
    if (fn2) {
      this.items = fn2.call(this);
    }
  }
  changeItems(items2) {
    var _items;
    const me = this;
    if (items2 == null) {
      if (me.store && !me.store.isItemStore) {
        return;
      }
      items2 = [];
    }
    if (me.buildItems && !((_items = items2) !== null && _items !== void 0 && _items.length)) {
      items2 = me.buildItems();
    }
    if (items2 instanceof Store) {
      me.store = items2;
      return;
    }
    const displayField = me.displayField;
    let itemModel, valueField = me.valueField, storeData;
    if (Array.isArray(items2)) {
      storeData = items2.map((item) => {
        let result = item;
        if (item instanceof Model) {
          itemModel = item.constructor;
          if (!valueField) {
            me.valueField = valueField = itemModel.idField;
          }
        } else {
          if (typeof item === "string" || typeof item === "number") {
            if (!valueField) {
              me.valueField = valueField = me.displayField;
            }
            result = {
              [valueField]: item,
              [displayField]: item
            };
          } else {
            if (!valueField) {
              me.valueField = valueField = "value";
            }
            if (Array.isArray(item)) {
              result = {
                [valueField]: item[0],
                [displayField]: item[1]
              };
            }
          }
        }
        if (item.selected) {
          me.value = result;
        }
        return result;
      });
    } else {
      if (!valueField) {
        me.valueField = valueField = "value";
      }
      storeData = [];
      Object.entries(items2).forEach(([key, value]) => {
        storeData.push({
          [valueField]: key,
          [displayField]: value
        });
      });
    }
    if (me.store) {
      me.store.data = storeData;
    } else {
      const valueFieldDefinition = valueField === displayField ? {
        name: "value",
        dataSource: displayField
      } : valueField;
      me.store = new Store({
        isItemStore: true,
        data: storeData,
        idField: valueField,
        verifyNoGeneratedIds: false,
        modelClass: itemModel || class extends Model {
          static get idField() {
            return me.valueField;
          }
          static set idField(idField) {
            super.idField = idField;
          }
          static get fields() {
            return [valueFieldDefinition, displayField];
          }
        }
      });
    }
  }
  get value() {
    const me = this, {
      valueCollection,
      valueField
    } = me;
    if (valueField == null) {
      return me.multiSelect ? valueCollection.values.slice() : valueCollection.first;
    }
    let value;
    if (me.multiSelect) {
      value = valueCollection.count ? valueCollection.map((r) => r[valueField]) : me._lastValue || [];
    } else {
      value = valueCollection.count ? valueCollection.first[valueField] : me._lastValue;
    }
    return value;
  }
  set value(value) {
    super.value = value;
  }
  get needsInputSync() {
    return this.usesChipView ? false : !this.editable;
  }
  changeValue(value, oldValue) {
    var _me$hidePickerOnSelec;
    const me = this;
    if (value === oldValue) {
      me.syncInputFieldValue(true);
      return;
    }
    if (!me.multiSelect && Array.isArray(value) && value.length > 1) {
      throw new Error("Multiple values cannot be set to a non-multiSelect Combo");
    }
    me.triggerConfig("items");
    if (!me.inputting) {
      var _me$_chipView;
      (_me$_chipView = me._chipView) === null || _me$_chipView === void 0 ? void 0 : _me$_chipView.selected.clear();
    }
    if (!me.store) {
      me.items = [];
    }
    const {
      valueField,
      displayField,
      store,
      valueCollection,
      _picker
    } = me, {
      storage
    } = store, hidePicker = (_me$hidePickerOnSelec = me.hidePickerOnSelect) !== null && _me$hidePickerOnSelec !== void 0 ? _me$hidePickerOnSelec : !me.multiSelect, isUserAction = me._isUserAction || (_picker === null || _picker === void 0 ? void 0 : _picker._isUserAction) || hidePicker && me.pickerVisible || false;
    if (!me.remoteFilter && store.isAjaxStore && !store.count) {
      store.ion({
        load: () => me.value = value,
        once: true,
        thisObj: me
      });
      me._lastValue = value;
      return;
    }
    if (me.remoteFilter) {
      if (value != null) {
        if (ObjectHelper.isObject(value) || value.isModel) {
          me.store.data = [value];
          me.valueCollection.splice(0, me.valueCollection.count, me.store.first);
        } else {
          const wasConfiguring = me.isConfiguring;
          me.primaryFilter.setConfig({
            value,
            disabled: false
          });
          store.performFilter(true).then(() => {
            if (me.isDestroyed) {
              return;
            }
            const {
              isConfiguring
            } = me;
            me.isConfiguring = wasConfiguring;
            valueCollection.splice(0, valueCollection.count, store.allRecords);
            me.isConfiguring = isConfiguring;
          });
        }
        return;
      }
    } else if (store.filtered) {
      me.primaryFilter.disabled = true;
      store.filter();
    }
    let record;
    if (value != null) {
      const arrayPassed = Array.isArray(value), values = arrayPassed ? value.slice() : [value];
      for (let i = 0, len = values.length; i < len; i++) {
        let currentValue = values[i];
        if (currentValue instanceof Model) {
          if (!storage.includes(currentValue, true)) {
            store.add(currentValue);
          }
        } else {
          const isObject2 = ObjectHelper.isObject(currentValue);
          if (isObject2) {
            currentValue = currentValue[store.modelClass.fieldMap[valueField].dataSource];
          }
          record = storage.getBy(displayField, currentValue) || storage.getBy(valueField, currentValue) || valueCollection.getBy(displayField, currentValue) || valueCollection.getBy(valueField, currentValue);
          if (record instanceof Set) {
            record = [...record][0];
          }
          if (record) {
            if (isObject2) {
              record.set(values[i]);
            }
            values[i] = record;
          } else {
            values.splice(i, 1);
            len--;
            i--;
          }
        }
      }
      const noMatches = !values.length;
      const vcGen = valueCollection.generation;
      valueCollection.splice(0, valueCollection.count, values);
      if (noMatches) {
        me._value = arrayPassed && value.length === 0 ? null : value;
        me._lastValue = me._value;
      }
      if (noMatches || valueCollection.generation === vcGen) {
        me.syncInputFieldValue();
      }
      me.syncEmpty();
      if (noMatches && !me.isConfiguring) {
        me.triggerFieldChange({
          value,
          oldValue,
          userAction: isUserAction,
          valid: me.isValid
        });
      }
    } else {
      if (valueCollection.count) {
        valueCollection.clear();
      } else {
        const oldValue2 = me._value;
        me._value = null;
        me.syncInputFieldValue();
        me.syncEmpty();
        if (!me.isConfiguring) {
          me.triggerFieldChange({
            value,
            oldValue: oldValue2,
            userAction: isUserAction,
            valid: me.isValid
          });
        }
      }
    }
    me._lastValue = me._value;
  }
  hasChanged(oldValue, newValue) {
    if (this.multiSelect) {
      return !ObjectHelper.isEqual(oldValue, newValue);
    }
    return super.hasChanged(...arguments);
  }
  onComboStoreChange({
    action
  }) {
    if (action !== "filter") {
      this.syncInputFieldValue(true);
    }
  }
  syncInputFieldValue(skipHighlight) {
    if (this.usesChipView) {
      var _this$chipView;
      (_this$chipView = this.chipView) === null || _this$chipView === void 0 ? void 0 : _this$chipView.refresh();
    } else {
      super.syncInputFieldValue(skipHighlight);
    }
  }
  get usesChipView() {
    return Boolean(this.multiSelect && this._chipView);
  }
  get isEmpty() {
    return this.valueCollection.count === 0;
  }
  get inputValue() {
    const me = this;
    let result = me.selected ? me.selected[me.displayField] : me.value;
    if (me.displayValueRenderer) {
      result = me.callback(me.displayValueRenderer, me, [me.selected, me]);
    }
    return result == null ? "" : result;
  }
  get nonEditableClickTarget() {
    var _this$chipView2;
    return this.multiSelect && ((_this$chipView2 = this.chipView) === null || _this$chipView2 === void 0 ? void 0 : _this$chipView2.element) || super.nonEditableClickTarget;
  }
  changeValueCollection(valueCollection, oldValueCollection) {
    oldValueCollection === null || oldValueCollection === void 0 ? void 0 : oldValueCollection.destroy();
    if (valueCollection) {
      if (!valueCollection.isCollection) {
        valueCollection = new Collection({
          internalListeners: {
            noChange: "onValueCollectionNoChange",
            change: "onValueCollectionChange",
            prio: -1e3,
            thisObj: this
          }
        });
      }
      return valueCollection;
    }
  }
  changePrimaryFilter(primaryFilter) {
    if (primaryFilter.isCollectionFilter) {
      primaryFilter.setConfig({
        disabled: true,
        property: this.displayField,
        operator: this.filterOperator,
        caseSensitive: this.caseSensitive
      });
    } else {
      if (typeof primaryFilter === "function") {
        primaryFilter = {
          filterBy: primaryFilter
        };
      }
      primaryFilter = new CollectionFilter(_objectSpread2({
        "id": "primary",
        disabled: true,
        property: this.displayField,
        operator: this.filterOperator,
        caseSensitive: this.caseSensitive
      }, primaryFilter));
    }
    return primaryFilter;
  }
  changeStore(store) {
    const me = this, storeFilters = [], {
      valueCollection,
      keyStrokeFilterDelay,
      filterParamName
    } = me;
    if (Array.isArray(store)) {
      me.items = store;
      return;
    }
    let remoteFilter;
    if (store) {
      if (store.isStore) {
        const sharedFilter = store.filters.get("primary");
        if (me.remoteFilter) {
          store.filterParamName = filterParamName;
        }
        remoteFilter = store.remoteFilter || store.restfulFilter;
        if (sharedFilter) {
          me.primaryFilter = sharedFilter;
        } else {
          storeFilters.push(me.primaryFilter);
        }
      } else {
        if (typeof store === "string") {
          store = Store.getStore(store);
        } else {
          store = new (store.readUrl ? AjaxStore : Store)(store);
          me.destroyStore = true;
        }
        remoteFilter = me.remoteFilter || store.restfulFilter;
        if (remoteFilter && filterParamName) {
          store.filterParamName = filterParamName;
          if (me.encodeFilterParams) {
            store.encodeFilterParams = me.encodeFilterParams;
          }
        }
        storeFilters.push(me.primaryFilter);
      }
      if (!me.valueField && !me.usingRecordAsValue) {
        me.valueField = store.modelClass.idField;
      }
      if (me.filterSelected) {
        const selectedItemsFilter = (r) => !me.containsFocus || !valueCollection.includes(r);
        if (remoteFilter) {
          store.storage.autoFilter = true;
          store.storage.addFilter({
            id: `${me.id}-selected-filter`,
            filterBy: selectedItemsFilter
          });
        } else {
          storeFilters.push(selectedItemsFilter);
          store.reapplyFilterOnAdd = true;
        }
      }
      valueCollection.addIndex({
        property: me.displayField,
        unique: false
      });
      valueCollection.addIndex({
        property: me.valueField,
        unique: true
      });
      storeFilters.forEach((f) => store.addFilter(f, true));
      if (remoteFilter) {
        me.keyStrokeFilterDelay = Math.max(300, keyStrokeFilterDelay || 0);
      } else {
        me.keyStrokeFilterDelay = keyStrokeFilterDelay !== null && keyStrokeFilterDelay !== void 0 ? keyStrokeFilterDelay : 10;
      }
    }
    return store;
  }
  updateStore(store, oldStore) {
    const me = this, {
      _picker
    } = me;
    let storeListeners;
    if (me.destroyStore && oldStore) {
      oldStore.destroy();
    }
    if (_picker) {
      _picker.store = store;
    }
    store.storage.addIndex({
      property: me.displayField,
      unique: false
    });
    store.storage.addIndex({
      property: me.valueField,
      unique: true
    });
    storeListeners = {
      filter: "onStoreFilter"
    };
    if (me.displayValueRenderer) {
      (storeListeners || (storeListeners = {})).change = "onComboStoreChange";
    }
    me.detachListeners("store");
    (store === null || store === void 0 ? void 0 : store.storage) && me.valueCollection.match(store.storage);
    me.syncInputFieldValue();
    if (storeListeners) {
      storeListeners.name = "store";
      storeListeners.thisObj = me;
      store.ion(storeListeners);
    }
  }
  get remoteFilter() {
    var _this$_store;
    return Boolean(this.filterParamName || ((_this$_store = this._store) === null || _this$_store === void 0 ? void 0 : _this$_store.restfulFilter));
  }
  get record() {
    return this.selected;
  }
  get records() {
    return this.valueCollection.values.slice();
  }
  get selected() {
    const {
      store
    } = this;
    return this.multiSelect ? this.valueCollection.values.slice().sort((l, r) => store.indexOf(l) - store.indexOf(r))[0] : this.valueCollection.first;
  }
  onEditComplete() {
    const me = this, selectionCount = me.valueCollection.count;
    super.onEditComplete();
    if (selectionCount) {
      me.clearError(errorValidateFilter);
      me.syncInputFieldValue();
    }
    if (me.required && !selectionCount) {
      me.setError(errorFieldRequired);
    }
  }
  onTriggerClick(event) {
    const me = this, activatePicker = "key" in event;
    if (me.ignoreTriggerClick || me.remoteFilter && me.filterOnEnter) {
      return;
    }
    if (me.pickerVisible) {
      me.hidePicker();
    } else if (!me.readOnly && !me.disabled) {
      var _me$triggerAction;
      switch ((_me$triggerAction = me.triggerAction) === null || _me$triggerAction === void 0 ? void 0 : _me$triggerAction.toLowerCase()) {
        case "all":
          me.doFilter(null, activatePicker);
          break;
        case "last":
          me.doFilter(me.lastQuery, activatePicker);
          break;
        default:
          me.doFilter(me.input.value, activatePicker);
      }
    }
  }
  internalOnInput(event) {
    const me = this;
    me.syncEmpty();
    me.syncInputWidth();
    me.filterOnInput(event);
    me.trigger("input", {
      value: me.input.value,
      event
    });
  }
  filterOnInput(event) {
    const me = this, value = event.target.value, inputLen = value.length;
    me.inputting = true;
    if (me.inlinePicker || inputLen >= me.minChars && (!me.filterOnEnter || event.key === "Enter")) {
      me.doFilter(value);
    } else {
      if (me.validateFilter && !me.remoteFilter) {
        me[inputLen ? "setError" : "clearError"](errorValidateFilter);
      }
      me.hidePicker();
    }
    me.inputting = false;
  }
  syncInputWidth() {
    const me = this;
    if (me.usesChipView) {
      const input = me.input, inputPadding = me._inputPadding || (me._inputPadding = DomHelper.getEdgeSize(input, "padding", "lr")), value = input.value || "", width = DomHelper.measureText(value + "W", input, false, me.element) + inputPadding.width;
      input.style.flex = `1 1 ${Math.ceil(width)}px`;
    }
  }
  doFilter(queryString, activatePicker) {
    var _me$filterPromise;
    const me = this, {
      store,
      picker
    } = me, disableFilter = queryString == null || queryString === "";
    me.lastQuery = queryString;
    me.primaryFilter.setConfig({
      value: queryString,
      disabled: disableFilter
    });
    if (me.remoteFilter) {
      store.clear(true);
    }
    const onAfterFilter = () => {
      const {
        navigator: navigator2,
        isVisible: isVisible2
      } = picker;
      if (store.count) {
        if (!disableFilter && navigator2) {
          navigator2.activeItem = 0;
        }
      } else if (!me.remoteFilter && !disableFilter) {
        if (navigator2) {
          navigator2.activeItem = null;
        }
        if (me.validateFilter) {
          me.setError(errorValidateFilter);
        }
      }
      isVisible2 && picker.realign();
    };
    (_me$filterPromise = me.filterPromise = store.filter()) === null || _me$filterPromise === void 0 ? void 0 : _me$filterPromise.then(() => {
      me.filterPromise = null;
      onAfterFilter();
    });
    if (!me.inlinePicker) {
      if (picker !== null && picker !== void 0 && picker.isVisible) {
        if (picker.lastAlignSpec.zone === 0) {
          picker.realign();
        }
      } else {
        me.showPicker(activatePicker);
      }
    }
    if (!me.filterPromise) {
      onAfterFilter();
    }
  }
  onStoreFilter({
    source: store
  }) {
    const me = this, picker = me._picker, dataset = picker === null || picker === void 0 ? void 0 : picker.element.dataset, {
      count
    } = store;
    if (me.remoteFilter) {
      if (count) {
        if (picker) {
          picker.navigator.activeItem = 0;
        }
      } else {
        if (me.validateFilter) {
          me.setError(errorValidateFilter);
        }
      }
      if (me.filterSelected && me.valueCollection.count) {
        store.storage.onFiltersChanged({
          action: "splice",
          oldCount: 1
        });
        if (picker) {
          picker.refresh();
        }
      }
    }
    if (dataset) {
      if (me.createOnUnmatched && !count) {
        dataset.addNewValue = me.L("L{addNewValue}")(me.primaryFilter.value);
      } else {
        dataset === null || dataset === void 0 ? true : delete dataset.addNewValue;
      }
    }
  }
  onValueCollectionChange({
    source: valueCollection
  }) {
    var _me$hidePickerOnSelec2;
    const me = this, {
      multiSelect,
      _picker
    } = me, hidePicker = (_me$hidePickerOnSelec2 = me.hidePickerOnSelect) !== null && _me$hidePickerOnSelec2 !== void 0 ? _me$hidePickerOnSelec2 : !multiSelect, record = multiSelect ? valueCollection.values.slice() : valueCollection.first, records = valueCollection.values.slice(), isUserAction = me._isUserAction || (_picker === null || _picker === void 0 ? void 0 : _picker._isUserAction) || hidePicker && me.pickerVisible || false, oldValue = me._value;
    if (hidePicker) {
      me.hidePicker();
    }
    if (!valueCollection.count && me.required) {
      me.setError(errorFieldRequired);
    } else {
      me.clearError(errorFieldRequired);
      me.clearError(errorValidateFilter);
    }
    if (me.validateFilter && record) {
      me.clearError(errorValidateFilter);
    }
    if (me.filterSelected) {
      if (me.remoteFilter) {
        me.store.storage.onFiltersChanged({
          action: "splice",
          oldCount: 1
        });
        if (me._picker) {
          me._picker.refresh();
        }
      } else {
        me.store.filter();
      }
    }
    me._value = null;
    me._lastValue = null;
    const value = me.cacheCurrentValue(me.value);
    me.syncInputFieldValue();
    me.syncEmpty();
    if (!me.isConfiguring) {
      me.triggerFieldChange({
        value,
        oldValue,
        userAction: isUserAction,
        valid: me.isValid
      });
      me.trigger("select", {
        record,
        records,
        userAction: isUserAction
      });
      if (me.defaultAction === "select") {
        me.trigger("action", {
          value,
          record,
          records,
          userAction: isUserAction
        });
      }
    }
  }
  cacheCurrentValue(v) {
    return this._value = v;
  }
  onValueCollectionNoChange({
    toAdd
  }) {
    if (!this.inlinePicker && !this.multiSelect && toAdd.length && this.pickerVisible) {
      this.picker.hide();
    }
  }
  showPicker() {
    const me = this, {
      picker
    } = me;
    if (me.readOnly || me.inlinePicker) {
      return;
    }
    picker.multiSelect = me.multiSelect;
    super.showPicker(...arguments);
    if (me.overlayAnchor && !picker.align.offset) {
      picker.align.offset = -picker.anchorSize[1];
      picker.realign();
    }
    if (picker.restoreActiveItem) {
      if (me.multiSelect) {
        var _picker$navigator;
        picker.restoreActiveItem(((_picker$navigator = picker.navigator) === null || _picker$navigator === void 0 ? void 0 : _picker$navigator.previousActiveItem) || me.selected || 0, true);
      } else {
        picker.restoreActiveItem(me.selected || 0, true);
      }
    }
    me.input.focus();
  }
  changePicker(picker, oldPicker) {
    var _picker2;
    const me = this, pickerWidth = me.pickerWidth || ((_picker2 = picker) === null || _picker2 === void 0 ? void 0 : _picker2.width), config = List.mergeConfigs({
      owner: me,
      store: me.store,
      selected: me.valueCollection,
      multiSelect: me.multiSelect,
      cls: me.listCls,
      displayField: me.displayField,
      forElement: me[me.pickerAlignElement],
      align: {
        matchSize: pickerWidth == null,
        anchor: me.overlayAnchor,
        target: me[me.pickerAlignElement],
        minHeight: me.inlinePicker ? null : Math.min(3, me.store.count) * 40
      },
      [me.listItemTpl ? "itemTpl" : void 0]: me.listItemTpl,
      width: pickerWidth,
      navigator: {
        keyEventTarget: me.input
      }
    }, picker);
    if (me.inlinePicker) {
      Object.assign(config, {
        floating: false,
        align: null,
        activateOnMouseover: false,
        maxHeight: null,
        appendTo: me.element
      });
    }
    picker = List.reconfigure(oldPicker, picker ? config : null, me);
    if (picker) {
      picker.element.classList.add("b-combo-picker");
      picker.element.dataset.emptyText = me.emptyText ? me.L(me.emptyText) : me.L("L{noResults}");
      picker.ion({
        navigate: "onPickerNavigate",
        thisObj: me
      });
    }
    return picker;
  }
  onPickerNavigate({
    event
  }) {
    if (event.target.matches("[data-add-new-value]")) {
      this.addNewRecord(this.primaryFilter.value);
    }
  }
  onPickerHide() {
    const me = this;
    super.onPickerHide();
    if (me.multiSelect && me.clearTextOnPickerHide) {
      me.input.value = "";
    }
  }
  async internalOnKeyEvent(keyEvent) {
    const me = this, value = me.input[me.inputValueAttr], inputLen = value.length, {
      key
    } = keyEvent, {
      store,
      _picker: picker,
      multiSelect
    } = me;
    if (keyEvent.type === "keydown" && picker !== null && picker !== void 0 && picker.isVisible && picker.navigator) {
      const {
        activeItem
      } = picker.navigator;
      if (activeItem && multiSelect && key === me.multiValueSeparator) {
        me.input.value = "";
        me.primaryFilter.setConfig({
          value: "",
          disabled: true
        });
        store.filter();
        picker.onItemClick(activeItem, keyEvent);
        picker.hide();
        keyEvent.preventDefault();
        return;
      }
      if (!activeItem && me.createOnUnmatched && (multiSelect && key === me.multiValueSeparator || key === "Enter")) {
        keyEvent.preventDefault();
        await me.addNewRecord(value);
        return;
      }
    }
    super.internalOnKeyEvent(...arguments);
    if (keyEvent.type === "keydown" && key === "Enter" && me.filterOnEnter && inputLen >= me.minChars) {
      keyEvent.stopPropagation();
      me.filterOnInput.now(keyEvent);
    }
  }
  async addNewRecord(value) {
    const me = this, {
      store,
      _picker: picker,
      valueCollection,
      multiSelect,
      primaryFilter
    } = me, remoteAutoCommit = store.remoteFilter && store.autoCommit;
    if (me.filterPromise) {
      await me.filterPromise;
    }
    if (!remoteAutoCommit) {
      primaryFilter.setConfig({
        value: "",
        disabled: true
      });
      store.filter();
    }
    const [newRecord] = store.add(me.callback(me.createOnUnmatched, me, [value, me]));
    if (store.isCommitting) {
      let error;
      try {
        await store.commitPromise;
      } catch (exception) {
        var _exception$response, _exception$response$p;
        error = (_exception$response = exception.response) === null || _exception$response === void 0 ? void 0 : (_exception$response$p = _exception$response.parsedJson) === null || _exception$response$p === void 0 ? void 0 : _exception$response$p.error;
      }
      if (newRecord.isPhantom) {
        me.clearError();
        me.setError(error || errorRecordNotCommitted, false, true);
        store.remove(newRecord);
        store.removed.remove(newRecord);
      }
    }
    if (remoteAutoCommit) {
      primaryFilter.setConfig({
        value: "",
        disabled: true
      });
      store.filter();
    }
    me.input.value = "";
    if (store.includes(newRecord)) {
      valueCollection.splice(multiSelect ? valueCollection.count : 0, multiSelect ? 0 : valueCollection.count, newRecord);
    }
    picker === null || picker === void 0 ? void 0 : picker.hide();
  }
  changeCreateOnUnmatched(createOnUnmatched) {
    if (createOnUnmatched === true) {
      createOnUnmatched = this.defaultRecordCreater;
    }
    return createOnUnmatched;
  }
  defaultRecordCreater(value) {
    return this.store.createRecord({
      [this.displayField]: value
    });
  }
  updateLocalization() {
    super.updateLocalization();
    const me = this, {
      displayField
    } = me;
    let {
      localizedDisplayFieldsMap
    } = me;
    if (me.localizeDisplayFields === true) {
      if (!localizedDisplayFieldsMap) {
        me.localizedDisplayFieldsMap = localizedDisplayFieldsMap = /* @__PURE__ */ new Map();
      }
      if (!me.store && me.buildItems) {
        me.items = me.buildItems();
      }
      for (const item of me.items) {
        if (item.id) {
          var _item$displayField;
          let localeString = localizedDisplayFieldsMap.get(item.id);
          if (!localeString && (_item$displayField = item[displayField]) !== null && _item$displayField !== void 0 && _item$displayField.startsWith("L{")) {
            localeString = item[displayField];
            localizedDisplayFieldsMap.set(item.id, localeString);
          }
          if (localeString) {
            item[displayField] = me.L(localeString);
          }
        }
      }
      me.syncInputFieldValue();
    }
  }
};
_defineProperty(Combo, "delayable", {
  filterOnInput: 0
});
var ComboChipView = class extends ChipView {
  static get $name() {
    return "ComboChipView";
  }
  static get type() {
    return "combochipview";
  }
  static get defaultConfig() {
    return {
      closeHandler: "up.onChipClose",
      itemsFocusable: false,
      multiSelect: true,
      itemTpl(record) {
        return StringHelper.encodeHtml(record[this.owner.displayField]);
      },
      scrollable: {
        overflowY: "auto"
      }
    };
  }
};
var ComboChipNavigator = class extends Navigator {
  static get $name() {
    return "ComboChipNavigator";
  }
  static get type() {
    return "combochipnavigator";
  }
  static get configurable() {
    return {
      allowShiftKey: true
    };
  }
  onTargetClick(clickEvent) {
    const me = this, item = clickEvent.target.closest(me.itemSelector);
    if (item && !clickEvent.target.classList.contains("b-close-icon")) {
      if (!clickEvent.shiftKey && !item.contains(clickEvent.target.closest("[data-noselect]"))) {
        me.ownerCmp.selected.clear();
      }
      me.inClickHandler = true;
      me.activeItem = item;
      me.inClickHandler = false;
    }
  }
  onKeyDown(keyEvent) {
    if (keyEvent.key !== "Enter") {
      super.onKeyDown(keyEvent);
    }
  }
  updateActiveItem(activeItem, oldActiveItem) {
    const chipView = this.ownerCmp;
    super.updateActiveItem(activeItem, oldActiveItem);
    if (activeItem && !this.inClickHandler) {
      chipView.selected.add(chipView.getRecordFromElement(activeItem));
    }
  }
  navigatePrevious(keyEvent) {
    const chipView = this.ownerCmp;
    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }
    if (this.previous) {
      super.navigatePrevious(keyEvent);
    } else {
      this.activeItem = null;
    }
  }
  navigateNext(keyEvent) {
    const chipView = this.ownerCmp;
    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }
    if (this.next) {
      super.navigateNext(keyEvent);
    } else {
      this.activeItem = null;
    }
  }
};
Combo.initClass();
ComboChipView.initClass();
ComboChipNavigator.initClass();
Combo._$name = "Combo";
var UndoRedoBase = class extends Container {
  static get $name() {
    return "UndoRedoBase";
  }
  static get type() {
    return "undoredobase";
  }
  static get configurable() {
    return {
      project: null,
      stm: null,
      text: null,
      color: null,
      showZeroActionBadge: null,
      cls: "b-undo-controls b-toolbar",
      layoutStyle: {
        alignItems: "stretch",
        flexFlow: "row nowrap",
        overflow: "visible"
      },
      items: {
        undoBtn: {
          type: "button",
          icon: "b-icon-undo",
          tooltip: "L{UndoRedo.UndoLastAction}",
          onAction: "up.onUndo"
        },
        transactionsCombo: {
          type: "combo",
          valueField: "idx",
          editable: false,
          store: {},
          emptyText: "L{UndoRedo.NoActions}",
          onAction: "up.onTransactionSelected",
          displayValueRenderer: "up.transactionsDisplayValueRenderer"
        },
        redoBtn: {
          type: "button",
          icon: "b-icon-redo",
          tooltip: "L{UndoRedo.RedoLastAction}",
          onAction: "up.onRedo"
        }
      }
    };
  }
  afterConstruct() {
    this.updateUndoRedoControls();
  }
  updateStm(stm) {
    this.detachListeners("undoredo");
    stm === null || stm === void 0 ? void 0 : stm.ion({
      name: "undoredo",
      recordingstop: "updateUndoRedoControls",
      restoringstop: "updateUndoRedoControls",
      queueReset: "updateUndoRedoControls",
      disabled: "updateUndoRedoControls",
      thisObj: this
    });
  }
  changeItems(items2) {
    const {
      undoBtn,
      redoBtn
    } = items2;
    if (this.color) {
      undoBtn && (undoBtn.color = this.color);
      redoBtn && (redoBtn.color = this.color);
    }
    if (this.text) {
      undoBtn && (undoBtn.text = "L{UndoRedo.Undo}");
      redoBtn && (redoBtn.text = "L{UndoRedo.Redo}");
    }
    return super.changeItems(items2);
  }
  updateProject(project) {
    this.stm = project.stm;
  }
  fillUndoRedoCombo() {
    const {
      transactionsCombo
    } = this.widgetMap;
    transactionsCombo && (transactionsCombo.items = this.stm.queue.map((title, idx) => [idx, title || `Transaction ${idx}`]));
  }
  updateUndoRedoControls() {
    const {
      stm,
      showZeroActionBadge
    } = this, {
      undoBtn,
      redoBtn
    } = this.widgetMap;
    undoBtn.badge = stm.position || (showZeroActionBadge ? "0" : "");
    redoBtn.badge = stm.length - stm.position || (showZeroActionBadge ? "0" : "");
    undoBtn.disabled = !stm.canUndo;
    redoBtn.disabled = !stm.canRedo;
    this.fillUndoRedoCombo();
  }
  transactionsDisplayValueRenderer(record, combo) {
    var _this$stm;
    const stmPos = ((_this$stm = this.stm) === null || _this$stm === void 0 ? void 0 : _this$stm.position) || 0;
    return `${stmPos} undo actions / ${combo.store.count - stmPos} redo actions`;
  }
  onUndo() {
    this.stm.canUndo && this.stm.undo();
  }
  onRedo() {
    this.stm.canRedo && this.stm.redo();
  }
  onTransactionSelected(combo) {
    const stm = this.stm, value = combo.value;
    if (value >= 0) {
      if (stm.canUndo && value < stm.position) {
        stm.undo(stm.position - value);
      } else if (stm.canRedo && value >= stm.position) {
        stm.redo(value - stm.position + 1);
      }
    }
  }
};
UndoRedoBase._$name = "UndoRedoBase";
var BooleanCombo = class extends Combo {
  static get $name() {
    return "BooleanCombo";
  }
  static get type() {
    return "booleancombo";
  }
  static get configurable() {
    return {
      positiveValue: true,
      positiveText: null,
      negativeValue: false,
      negativeText: null,
      store: {
        value: [],
        $config: "lazy"
      },
      value: false
    };
  }
  changeStore(store, oldStore) {
    const me = this;
    return super.changeStore(new Store({
      data: [{
        id: me.positiveValue,
        text: me.positiveText || me.L("L{Object.Yes}")
      }, {
        id: me.negativeValue,
        text: me.negativeText || me.L("L{Object.No}")
      }]
    }), oldStore);
  }
};
BooleanCombo.initClass();
BooleanCombo._$name = "BooleanCombo";
var ButtonGroup = class extends Container.mixin(Rotatable) {
  onChildAdd(item) {
    super.onChildAdd(item);
    item.ion({
      click: "resetValueCache",
      toggle: "onItemToggle",
      thisObj: this,
      prio: 1e4
    });
  }
  onChildRemove(item) {
    item.un({
      toggle: "resetValueCache",
      click: "resetValueCache",
      thisObj: this
    });
    super.onChildRemove(item);
  }
  onItemToggle(event) {
    const me = this;
    me.resetValueCache();
    if (!me.isSettingValue && (!me.toggleGroup || event.pressed)) {
      me.triggerFieldChange({
        value: me.value,
        userAction: true,
        event
      });
    }
  }
  resetValueCache() {
    this._value = null;
  }
  createWidget(widget) {
    const me = this, type = me.constructor.resolveType(widget.type || "button");
    if (type.isButton) {
      if (me.color && !widget.color) {
        widget.color = me.color;
      }
      if (me.toggleGroup && !widget.toggleGroup) {
        if (typeof me.toggleGroup === "boolean") {
          me.toggleGroup = ButtonGroup.generateId("toggleGroup");
        }
        widget.toggleGroup = me.toggleGroup;
      }
    }
    if (me.columns) {
      widget.width = `${100 / me.columns}%`;
    }
    widget = super.createWidget(widget);
    me.relayEvents(widget, ["click", "action", "toggle"]);
    return widget;
  }
  updateRotate(rotate) {
    this.eachWidget((btn) => {
      if (btn.rotate !== false) {
        btn.rotate = rotate;
      }
    });
  }
  get value() {
    if (!this._value) {
      const values = [];
      this.items.forEach((w) => {
        if (w.pressed && w.value !== void 0) {
          values.push(w.value);
        }
      });
      this._value = values.join(this.valueSeparator);
    }
    return this._value;
  }
  set value(value) {
    const me = this, oldValue = me.value;
    if (!Array.isArray(value)) {
      if (value === void 0 || value === null) {
        value = [];
      } else if (typeof value == "string") {
        value = value.split(me.valueSeparator);
      } else {
        value = [value];
      }
    }
    me._value = value.join(me.valueSeparator);
    me.isSettingValue = true;
    me.items.forEach((w) => {
      if (w.value !== void 0) {
        w.pressed = value.includes(w.value);
      }
    });
    me.isSettingValue = false;
    if (!me.isConfiguring && oldValue !== me.value) {
      me.triggerFieldChange({
        value: me.value,
        userAction: false
      });
    }
  }
  updateDisabled(disabled) {
    this.items.forEach((button) => button.disabled = disabled || !button.ignoreParentReadOnly && this.readOnly);
  }
  updateReadOnly(readOnly) {
    super.updateReadOnly(readOnly);
    this.updateDisabled(this.disabled);
  }
  get widgetClassList() {
    const classList = super.widgetClassList;
    this.columns && classList.push("b-columned");
    return classList;
  }
};
_defineProperty(ButtonGroup, "$name", "ButtonGroup");
_defineProperty(ButtonGroup, "type", "buttongroup");
_defineProperty(ButtonGroup, "configurable", {
  defaultType: "button",
  cls: null,
  items: null,
  color: null,
  toggleGroup: null,
  valueSeparator: ",",
  columns: null,
  hideWhenEmpty: true,
  defaultBindProperty: "value"
});
ButtonGroup.initClass();
ButtonGroup._$name = "ButtonGroup";
var CalendarPanel = class extends Panel {
  static get $name() {
    return "CalendarPanel";
  }
  static get type() {
    return "calendarpanel";
  }
  static get configurable() {
    return {
      textContent: false,
      date: {
        $config: {
          equal: "date"
        },
        value: null
      },
      month: {},
      year: null,
      weekStartDay: null,
      sixWeeks: true,
      showWeekNumber: null,
      showWeekColumn: null,
      disabledDates: null,
      headerRenderer: null,
      weekRenderer: null,
      cellRenderer: null,
      disableWeekends: null,
      hideNonWorkingDays: null,
      hideNonWorkingDaysCls: "b-hide-nonworking-days",
      nonWorkingDays: null,
      tip: null,
      dayCellCls: "b-calendar-cell",
      dayHeaderCls: "b-calendar-day-header",
      disabledCls: "b-disabled-date",
      otherMonthCls: "b-other-month",
      weekendCls: "b-weekend",
      todayCls: "b-today",
      nonWorkingDayCls: "b-nonworking-day",
      dayNameFormat: "ddd",
      minRowHeight: {
        $config: ["lazy"],
        value: null
      },
      minColumnWidth: {
        $config: ["lazy"],
        value: null
      },
      disableOtherMonthCells: null,
      disableOtherMonthCellsCls: "b-disable-othermonth-cells",
      hideOtherMonthCells: null,
      hideOtherMonthCellsCls: "b-hide-othermonth-cells",
      animateTimeShift: true
    };
  }
  construct(config) {
    super.construct(config);
    if (!this.refreshCount) {
      this.refresh();
    }
  }
  onPaint({
    firstPaint
  }) {
    var _super$onPaint;
    (_super$onPaint = super.onPaint) === null || _super$onPaint === void 0 ? void 0 : _super$onPaint.call(this, ...arguments);
    if (firstPaint) {
      if (!this.refreshCount) {
        this.refresh();
      }
      this.getConfig("minColumnWidth");
      this.getConfig("minRowHeight");
    }
  }
  get overflowElement() {
    return this.weeksElement;
  }
  doDestroy() {
    var _this$tip;
    (_this$tip = this.tip) === null || _this$tip === void 0 ? void 0 : _this$tip.destroy();
    super.doDestroy();
  }
  changeMinRowHeight(minRowHeight) {
    const minValue = parseInt(DomHelper.getStyleValue(this.element, "--min-row-height"), 10) || 75;
    return isNaN(minRowHeight) ? minRowHeight : Math.max(parseInt(minRowHeight) || 0, minValue);
  }
  updateMinRowHeight(minRowHeight) {
    this.weekElements.forEach((w) => DomHelper.setLength(w, "minHeight", minRowHeight));
    this.scrollable = {
      overflowY: minRowHeight ? "auto" : false
    };
  }
  changeMinColumnWidth(minColumnWidth) {
    const minValue = parseInt(DomHelper.getStyleValue(this.element, "--min-column-width"), 10) || 75;
    return minColumnWidth == null ? minColumnWidth : Math.max(parseInt(minColumnWidth) || 0, minValue);
  }
  updateMinColumnWidth(minColumnWidth) {
    const me = this;
    me.weekdayCells.forEach((c) => DomHelper.setLength(c, "minWidth", minColumnWidth));
    me.cellElements.forEach((c) => c.matches(`.${me.dayCellCls}`) && DomHelper.setLength(c, "minWidth", minColumnWidth));
    me.scrollable = {
      overflowX: minColumnWidth ? "auto" : false
    };
    me.overflowElement.classList[minColumnWidth ? "add" : "remove"]("b-min-columnwidth");
  }
  getDateFromDomEvent(domEvent) {
    const element = (domEvent.nodeType === Element.ELEMENT_NODE ? domEvent : domEvent.target).closest(`#${this.id} [data-date]`);
    if (element) {
      return DateHelper.parseKey(element.dataset.date);
    }
  }
  changeTip(tip, existingTip) {
    const me = this;
    return Tooltip.reconfigure(existingTip, tip, {
      owner: me,
      defaults: {
        type: "tooltip",
        owner: me,
        id: `${me.id}-cell-tip`,
        forElement: me.bodyElement,
        forSelector: `.${me.dayCellCls}`
      }
    });
  }
  updateTip(tip) {
    this.detachListeners("tip");
    tip === null || tip === void 0 ? void 0 : tip.ion({
      pointerOver: "onTipOverCell",
      name: "tip",
      thisObj: this
    });
  }
  updateElement(element, was) {
    const me = this;
    super.updateElement(element, was);
    me.updateHideNonWorkingDays(me.hideNonWorkingDays);
    me.weekdayCells = Array.from(element.querySelectorAll(".b-calendar-day-header"));
    me.weekElements = Array.from(element.querySelectorAll(".b-calendar-week"));
    me.weekDayElements = Array.from(element.querySelectorAll(".b-calendar-days"));
    me.cellElements = [];
    for (let i = 0, {
      length
    } = me.weekDayElements; i < length; i++) {
      me.cellElements.push(me.weekDayElements[i].previousSibling, ...me.weekDayElements[i].children);
    }
  }
  changeDate(date2) {
    date2 = typeof date2 === "string" ? DateHelper.parse(date2) : new Date(date2);
    if (isNaN(date2)) {
      throw new Error("CalendarPanel date ingestion must be passed a Date, or a YYYY-MM-DD date string");
    }
    return DateHelper.clearTime(date2);
  }
  updateDate(value) {
    this.month.date = value;
  }
  updateDayNameFormat() {
    const d = new Date("2000-06-04T12:00:00");
    this.shortDayNames = [];
    for (let date2 = 4; date2 < 11; date2++) {
      d.setDate(date2);
      this.shortDayNames.push(DateHelper.format(d, this.dayNameFormat));
    }
  }
  get weekStartDay() {
    return typeof this._weekStartDay === "number" ? this._weekStartDay : DateHelper.weekStartDay;
  }
  updateWeekStartDay(weekStartDay) {
    const me = this;
    if (me._month) {
      me.month.weekStartDay = weekStartDay;
      me.dayNames = [];
      for (let i = 0; i < 7; i++) {
        me.dayNames[i] = me.shortDayNames[me.canonicalDayNumbers[i]];
      }
      if (me.refreshCount) {
        me.refresh();
      }
    }
  }
  updateHideNonWorkingDays(hideNonWorkingDays) {
    var _this$scrollable;
    this.contentElement.classList.toggle(this.hideNonWorkingDaysCls, Boolean(hideNonWorkingDays));
    (_this$scrollable = this.scrollable) === null || _this$scrollable === void 0 ? void 0 : _this$scrollable.syncOverflowState();
    if (this._month) {
      this.month.hideNonWorkingDays = hideNonWorkingDays;
    }
    if (!this.isConfiguring) {
      this.refresh();
    }
  }
  updateHideOtherMonthCells(hideOtherMonthCells) {
    var _this$scrollable2;
    this.element.classList.toggle(this.hideOtherMonthCellsCls, Boolean(hideOtherMonthCells));
    (_this$scrollable2 = this.scrollable) === null || _this$scrollable2 === void 0 ? void 0 : _this$scrollable2.syncOverflowState();
  }
  updateDisableOtherMonthCells(disableOtherMonthCells) {
    var _this$scrollable3;
    this.element.classList.toggle(this.disableOtherMonthCellsCls, Boolean(disableOtherMonthCells));
    (_this$scrollable3 = this.scrollable) === null || _this$scrollable3 === void 0 ? void 0 : _this$scrollable3.syncOverflowState();
  }
  get nonWorkingDays() {
    return this._nonWorkingDays || this._localeNonWorkingDays || (this._localeNonWorkingDays = DateHelper.nonWorkingDays);
  }
  get weekends() {
    return this._localeWeekends || (this._localeWeekends = DateHelper.weekends);
  }
  changeNonWorkingDays(nonWorkingDays) {
    return ObjectHelper.assign({}, nonWorkingDays);
  }
  updateNonWorkingDays(nonWorkingDays) {
    if (this._month) {
      var _this$scrollable4;
      this.month.nonWorkingDays = nonWorkingDays;
      this.refresh();
      (_this$scrollable4 = this.scrollable) === null || _this$scrollable4 === void 0 ? void 0 : _this$scrollable4.syncOverflowState();
    }
  }
  get visibleDayColumnIndex() {
    return this.month.visibleDayColumnIndex;
  }
  get dayColumnIndex() {
    return this.month.dayColumnIndex;
  }
  get canonicalDayNumbers() {
    return this.month.canonicalDayNumbers;
  }
  get visibleColumnCount() {
    return this.month.visibleColumnCount;
  }
  get weekLength() {
    return this.month.weekLength;
  }
  get startDate() {
    return this.month.startDate;
  }
  get duration() {
    return DateHelper.diff(this.month.startDate, this.month.endDate, "day") + 1;
  }
  get endDate() {
    const {
      endDate
    } = this.month;
    if (endDate) {
      return DateHelper.add(endDate, 1, "day");
    }
  }
  changeMonth(month2, currentMonth) {
    const me = this;
    if (!(month2 instanceof Month)) {
      if (typeof month2 === "number") {
        if (currentMonth) {
          currentMonth.month = month2;
          return;
        }
        const date2 = me.date || DateHelper.clearTime(new Date());
        date2.setMonth(month2);
        month2 = {
          date: date2
        };
      }
      month2 = Month.new({
        weekStartDay: me.weekStartDay,
        nonWorkingDays: me.nonWorkingDays,
        hideNonWorkingDays: me.hideNonWorkingDays,
        sixWeeks: me.sixWeeks
      }, month2);
    }
    month2.ion({
      dateChange: "onMonthDateChange",
      thisObj: me
    });
    return month2;
  }
  onMonthDateChange({
    source: month2,
    newDate,
    oldDate,
    changes
  }) {
    const me = this;
    me.year = month2.year;
    if (!me.isConfiguring) {
      if (!me.getCell(newDate) || changes.m || changes.y) {
        me.refresh();
        if (me.animateTimeShift && me.isVisible) {
          DomHelper.slideIn(me.contentElement, newDate > oldDate ? 1 : -1);
        }
      }
      me.trigger("dateChange", {
        changes,
        value: newDate,
        oldValue: oldDate
      });
    }
  }
  updateYear(year) {
    this.month.year = year;
  }
  updateShowWeekNumber(showWeekNumber) {
    this.updateShowWeekColumn(showWeekNumber);
  }
  updateShowWeekColumn(showWeekColumn) {
    const me = this;
    me.element.classList[showWeekColumn ? "add" : "remove"]("b-show-week-column");
    if (me.floating) {
      if (!me.isAligning) {
        me.realign();
      }
    }
  }
  updateSixWeeks(sixWeeks) {
    if (this.month) {
      this.month.sixWeeks = sixWeeks;
      this.refresh();
    }
  }
  refresh() {
    this.doRefresh();
  }
  doRefresh() {
    var _me$project;
    this.getConfig("element");
    const me = this, timeZone = me.timeZone != null ? me.timeZone : (_me$project = me.project) === null || _me$project === void 0 ? void 0 : _me$project.timeZone, today = timeZone != null ? TimeZoneHelper.toTimeZone(new Date(), timeZone) : new Date(), {
      weekElements,
      weekDayElements,
      date: date2,
      month: month2,
      dayCellCls,
      dayHeaderCls,
      disabledCls,
      otherMonthCls,
      weekendCls,
      todayCls,
      nonWorkingDayCls,
      nonWorkingDays,
      canonicalDayNumbers,
      sixWeeks
    } = me;
    today.setHours(0, 0, 0, 0);
    if (!date2) {
      me.date = today;
      return;
    }
    me.trigger("beforeRefresh");
    me.getConfig("dayNameFormat");
    for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
      const cell = me.weekdayCells[columnIndex], cellDay = me.canonicalDayNumbers[columnIndex], cellClassList = {
        [dayHeaderCls]: 1,
        [weekendCls]: DateHelper.weekends[cellDay],
        [nonWorkingDayCls]: nonWorkingDays[cellDay]
      };
      if (me.headerRenderer) {
        cell.innerHTML = "";
        me.callback(me.headerRenderer, me, [cell, columnIndex, cellDay]);
      } else {
        DomHelper.setInnerText(cell, me.shortDayNames[cellDay]);
      }
      DomHelper.syncClassList(cell, cellClassList);
      cell.dataset.columnIndex = columnIndex;
      cell.dataset.cellDay = cellDay;
    }
    let rowIndex = 0, cellIndex = 0, lastWorkingColumn = 6;
    for (let columnIndex = 6; columnIndex >= 0; columnIndex--) {
      if (!nonWorkingDays[canonicalDayNumbers[columnIndex]]) {
        lastWorkingColumn = columnIndex;
        break;
      }
    }
    weekElements[4].classList.toggle("b-hide-display", month2.weekCount < 5 && !sixWeeks);
    weekElements[5].classList.toggle("b-hide-display", month2.weekCount < 6 && !sixWeeks);
    month2.eachWeek((week, dates) => {
      const weekDayElement = weekDayElements[rowIndex], weekCells = [weekDayElement.previousSibling, ...weekDayElement.children];
      weekElements[rowIndex].dataset.week = `${week[0]},${week[1]}`;
      if (me.weekRenderer) {
        me.callback(me.weekRenderer, me, [weekCells[0], week]);
      } else {
        weekCells[0].innerText = week[1];
      }
      for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
        const date3 = dates[columnIndex], day2 = date3.getDay(), isNonWorking = nonWorkingDays[day2], cell = weekCells[columnIndex + 1], cellClassList = {
          [dayCellCls]: 1,
          [disabledCls]: me.isDisabledDate(date3),
          [otherMonthCls]: date3.getMonth() !== month2.month,
          [weekendCls]: DateHelper.weekends[day2],
          [todayCls]: date3.getTime() === today.getTime(),
          [nonWorkingDayCls]: isNonWorking,
          "b-last-working-day": columnIndex === lastWorkingColumn,
          "b-first-visible-cell": !(date3 - (me.firstVisibleDate || -1)),
          "b-last-visible-cell": !(date3 - (me.lastVisibleDate || -1)),
          [`b-day-of-week-${day2}`]: 1
        };
        DomHelper.syncClassList(cell, cellClassList);
        cell.dataset.date = DateHelper.makeKey(date3);
        cell.dataset.cellIndex = cellIndex;
        cell.dataset.columnIndex = columnIndex;
        if (cell.lastDomConfig) {
          delete cell.lastDomConfig.class;
          delete cell.lastDomConfig.className;
        }
        if (me.cellRenderer) {
          me.callback(me.cellRenderer, me, [{
            cell,
            date: date3,
            day: day2,
            row: weekElements[rowIndex],
            rowIndex,
            cellIndex,
            columnIndex,
            visibleColumnIndex: me.visibleDayColumnIndex[day2],
            week
          }]);
        } else {
          cell.innerHTML = date3.getDate();
        }
        cellIndex++;
      }
      rowIndex++;
    });
    me.visibleWeekCount = rowIndex;
    if (me.floating) {
      if (!me.isAligning) {
        me.realign();
      }
    }
    me.refreshCount = (me.refreshCount || 0) + 1;
    me.trigger("refresh");
  }
  isDisabledDate(date2) {
    const day2 = date2.getDay(), {
      disabledDates,
      nonWorkingDays
    } = this;
    if (this.disableWeekends && nonWorkingDays[day2]) {
      return true;
    }
    if (disabledDates) {
      if (Array.isArray(disabledDates)) {
        date2 = DateHelper.clearTime(date2, true);
        return disabledDates.some((d) => !(DateHelper.clearTime(d, true) - date2));
      } else {
        return this.callback(this.disabledDates, this, [date2]);
      }
    }
  }
  get bodyConfig() {
    const result = super.bodyConfig, weeksContainerChildren = [];
    result.children = [{
      tag: "div",
      className: "b-calendar-row b-calendar-weekdays",
      reference: "weekdaysHeader",
      children: [{
        class: "b-week-number-cell"
      }, ...ArrayHelper.fill(7, {
        class: this.dayHeaderCls
      }), DomHelper.scrollBarPadElement]
    }, {
      className: "b-weeks-container notranslate",
      reference: "weeksElement",
      children: weeksContainerChildren
    }];
    for (let i = 0; i < 6; i++) {
      const weekRow = {
        className: "b-calendar-row b-calendar-week",
        dataset: {
          rowIndex: i
        },
        children: [{
          className: "b-week-number-cell"
        }, {
          className: "b-calendar-days",
          children: [{}, {}, {}, {}, {}, {}, {}],
          syncOptions: {
            ignoreRefs: true,
            strict: false
          }
        }]
      };
      weeksContainerChildren.push(weekRow);
    }
    return result;
  }
  get firstVisibleDate() {
    if (this.hideOtherMonthCells) {
      const {
        year,
        month: month2
      } = this.month;
      return new Date(year, month2, 1);
    }
    for (const me = this, date2 = me.month.startDate; ; date2.setDate(date2.getDate() + 1)) {
      if (!me.hideNonWorkingDays || !me.nonWorkingDays[date2.getDay()]) {
        return date2;
      }
    }
  }
  get lastVisibleDate() {
    const lastDate = DateHelper.add(this.endDate, -1, "d");
    if (this.hideOtherMonthCells) {
      return lastDate;
    }
    for (const me = this, date2 = lastDate; ; date2.setDate(date2.getDate() - 1)) {
      if (!me.hideNonWorkingDays || !me.nonWorkingDays[date2.getDay()]) {
        return date2;
      }
    }
  }
  getCell(date2, strict) {
    if (!(typeof date2 === "string")) {
      date2 = DateHelper.makeKey(date2);
    }
    const cell = this.weeksElement.querySelector(`[data-date="${date2}"]`);
    if (cell && (!strict || !cell.classList.contains(this.otherMonthCls))) {
      return cell;
    }
  }
  onTipOverCell({
    source: tip,
    target
  }) {
    tip.date = DateHelper.parseKey(target.dataset.date);
  }
  updateLocalization() {
    this._localeNonWorkingDays = this._localeWeekends = null;
    this.updateDayNameFormat();
    this.updateWeekStartDay(this.weekStartDay);
    super.updateLocalization();
  }
};
CalendarPanel.initClass();
CalendarPanel._$name = "CalendarPanel";
var whenNotChecked = (field) => !field.value;
var Checkbox = class extends Field {
  static get $name() {
    return "Checkbox";
  }
  static get type() {
    return "checkbox";
  }
  static get alias() {
    return "check";
  }
  static get configurable() {
    return {
      inputType: "checkbox",
      autoCollapse: null,
      containerDefaults: {
        syncableConfigs: {
          disabled: (field) => field.disabled || !field.value
        },
        syncConfigTriggers: {
          autoCollapse: 1,
          value: 1
        }
      },
      text: "",
      checkedValue: true,
      uncheckedValue: false,
      color: null,
      value: "",
      toggleGroup: null,
      localizableProperties: ["label", "text"]
    };
  }
  construct(config) {
    if ("checked" in config) {
      config = ObjectHelper.assign({}, config);
      config.value = config.checked;
      delete config.checked;
    }
    super.construct(config);
    this.syncHasText();
  }
  get textLabelCls() {
    return "b-checkbox-label";
  }
  get innerElements() {
    return [this.inputElement, {
      tag: "label",
      class: this.textLabelCls,
      for: `${this.id}-input`,
      reference: "textLabel",
      html: this.text || ""
    }];
  }
  get inputElement() {
    const config = super.inputElement;
    if (this.toggleGroup) {
      config.dataset = {
        group: this.toggleGroup
      };
    }
    config.listeners = {
      click: "internalOnClick",
      change: "internalOnChange",
      input: "internalOnInput"
    };
    return config;
  }
  get checked() {
    return this.value;
  }
  set checked(value) {
    this.value = value;
  }
  syncHasText() {
    this.element.classList[this.text ? "add" : "remove"]("b-text");
  }
  updateText(value) {
    if (this.textLabel) {
      this.syncHasText();
      this.textLabel.innerHTML = value;
    }
  }
  afterSyncChildConfigs(container) {
    super.afterSyncChildConfigs(container);
    let {
      autoCollapse
    } = this;
    if (autoCollapse) {
      autoCollapse = autoCollapse === true ? whenNotChecked : autoCollapse;
      container.collapsed = autoCollapse(this);
    }
  }
  assignFieldValue(values, key, value) {
    this.value = value === this.checkedValue || (value === this.uncheckedValue ? false : null);
  }
  fetchInputValue() {
    if (!this.readOnly) {
      this.value = this.input.checked;
    }
  }
  gatherValue(values) {
    var _values$valueName;
    const me = this, value = me.value ? me.checkedValue : me.uncheckedValue, storedValue = value !== void 0, {
      valueName
    } = me;
    if (storedValue) {
      values[valueName] = value;
    }
    me.gatherValues(values, storedValue);
    if (value === true && ((_values$valueName = values[valueName]) === null || _values$valueName === void 0 ? void 0 : _values$valueName.value) === value) {
      delete values[valueName].value;
    }
  }
  changeValue(value) {
    return value === "false" ? false : Boolean(value);
  }
  updateValue(value) {
    var _me$container;
    const me = this, changed = me.input.checked !== value;
    me.input.checked = value;
    (_me$container = me.container) === null || _me$container === void 0 ? void 0 : _me$container.syncChildConfigs();
    if (changed && !me.inputting && !me.isConfiguring) {
      me.uncheckToggleGroupMembers();
      me.triggerChange(false);
    }
  }
  get inputValueAttr() {
    return "checked";
  }
  updateColor(value, was) {
    const classes = this.element.classList;
    if (was) {
      classes.remove(was);
    }
    if (value) {
      classes.add(value);
    }
  }
  getToggleGroupMembers() {
    const me = this, {
      checked,
      toggleGroup,
      input: checkedElement,
      type
    } = me, result = [];
    if (checked && toggleGroup) {
      DomHelper.forEachSelector(me.rootElement, `input[type=${type}][data-group=${toggleGroup}]`, (inputEl) => {
        if (inputEl !== checkedElement) {
          const partnerCheckbox = Widget.fromElement(inputEl);
          partnerCheckbox && result.push(partnerCheckbox);
        }
      });
    }
    return result;
  }
  uncheckToggleGroupMembers() {
    if (this.checked && this.toggleGroup) {
      this.getToggleGroupMembers().forEach((widget) => widget.checked = false);
    }
  }
  check() {
    this.checked = true;
  }
  uncheck() {
    this.checked = false;
  }
  toggle() {
    this.checked = !this.checked;
  }
  internalOnClick(event) {
    if (this.readOnly) {
      event.preventDefault();
      return false;
    }
    return this.trigger("click", {
      event
    });
  }
  internalOnChange(event) {
    const me = this;
    if (me.readOnly && me.value !== me.input.checked) {
      me.input.checked = me.value;
      return;
    }
    me.value = me.input.checked;
    if (!me.inputting) {
      me.inputting = true;
      me.triggerChange(true);
      me.inputting = false;
    }
  }
  updateInputReadOnly(readOnly) {
  }
  triggerChange(userAction) {
    const me = this, {
      checked
    } = me.input;
    const eventObject = {
      checked,
      value: checked,
      userAction,
      valid: true
    }, prevented = !checked && userAction && me.toggleGroup && me.getToggleGroupMembers().filter((widget) => widget.isVisible && !widget.disabled).length || me.trigger("beforeChange", eventObject) === false;
    if (prevented) {
      me.input.checked = me._value = !checked;
    } else {
      me.triggerFieldChange(eventObject, false);
      if (userAction) {
        me.uncheckToggleGroupMembers();
      }
      me.trigger("action", eventObject);
      me.trigger("change", eventObject);
      return true;
    }
  }
};
Checkbox.initClass();
Checkbox._$name = "Checkbox";
var YearPicker = class extends Panel {
  construct(config) {
    super.construct(_objectSpread2({
      year: new Date().getFullYear()
    }, config));
    EventHelper.on({
      element: this.contentElement,
      click: "onYearClick",
      delegate: ".b-yearpicker-year",
      thisObj: this
    });
  }
  get focusElement() {
    return this.getYearButton(this.year) || this.getYearButton(this.startYear);
  }
  getYearButton(y) {
    return this.contentElement.querySelector(`.b-yearpicker-year[data-year="${y}"]`);
  }
  get value() {
    return this.year;
  }
  set value(year) {
    this.year = year;
  }
  onYearClick({
    target
  }) {
    const clickedYear = Math.min(Math.max(parseInt(target.innerText), this.minYear || 1), this.maxYear || 9999);
    if (this.year === clickedYear) {
      this.trigger("select", {
        oldValue: clickedYear,
        value: clickedYear
      });
    } else {
      this.year = clickedYear;
    }
  }
  handleTitleClick(e) {
    this.trigger("titleClick", e);
  }
  previous() {
    this.startYear = this.startYear - this.yearButtonCount;
  }
  next() {
    this.startYear = this.endYear + 1;
  }
  ingestYear(year) {
    if (!isNaN(year)) {
      return ObjectHelper.isDate(year) ? year.getFullYear() : year;
    }
  }
  changeYear(year) {
    if (year = this.ingestYear(year)) {
      return Math.min(Math.max(year, this.minYear || 1), this.maxYear || 9999);
    }
  }
  updateYear(year, oldValue) {
    const me = this;
    if (!me.startYear || year > me.endYear) {
      me.startYear = year;
    } else if (year < me.startYear) {
      me.startYear = year - (me.yearButtonCount - 1);
    }
    if (!me.isConfiguring) {
      me.trigger("select", {
        oldValue,
        value: year
      });
    }
  }
  get endYear() {
    return this.startYear + this.yearButtonCount - 1;
  }
  changeStartYear(startYear) {
    if (startYear = this.ingestYear(startYear)) {
      startYear = this.minYear ? Math.max(startYear, this.minYear) : startYear;
      return this.maxYear ? Math.min(startYear, this.maxYear - (this.yearButtonCount - 1)) : startYear;
    }
  }
  async updateStartYear(startYear, oldStartYear) {
    if (this.isVisible) {
      DomHelper.slideIn(this.contentElement, Math.sign(startYear - oldStartYear));
    }
  }
  composeBody() {
    this.getConfig("year");
    const {
      startYear
    } = this, result = super.composeBody(), children = result.children[this.tbar ? 1 : 0].children = [];
    this.widgetMap.title.text = `${`000${startYear}`.slice(-4)} - ${`000${this.endYear}`.slice(-4)}`;
    for (let i = 0, y = startYear; i < this.yearButtonCount; i++, y++) {
      children.push({
        tag: "button",
        dataset: {
          year: y
        },
        class: {
          "b-yearpicker-year": 1,
          "b-selected": y === this.year
        },
        text: `000${y}`.slice(-4)
      });
    }
    return result;
  }
};
_defineProperty(YearPicker, "$name", "YearPicker");
_defineProperty(YearPicker, "type", "yearpicker");
_defineProperty(YearPicker, "configurable", {
  textContent: false,
  tbar: {
    overflow: null,
    items: {
      previous: {
        type: "tool",
        cls: "b-icon b-icon-previous",
        onAction: "up.previous",
        weight: 100
      },
      title: {
        type: "button",
        cls: "b-yearpicker-title",
        weight: 200,
        onAction: "up.handleTitleClick"
      },
      next: {
        type: "tool",
        cls: "b-icon b-icon-next",
        onAction: "up.next",
        weight: 300
      }
    }
  },
  itemCls: "b-year-container",
  yearButtonCount: 12,
  year: null,
  minYear: null,
  maxYear: null,
  startYear: null
});
YearPicker.initClass();
YearPicker._$name = "YearPicker";
var DisplayField = class extends TextField {
  static get $name() {
    return "DisplayField";
  }
  static get type() {
    return "displayfield";
  }
  static get alias() {
    return "display";
  }
  static get configurable() {
    return {
      readOnly: true,
      editable: false,
      cls: "b-display-field",
      template: null,
      ariaElement: "displayElement"
    };
  }
  get focusElement() {
  }
  changeReadOnly() {
    return true;
  }
  changeEditable() {
    return false;
  }
  get inputElement() {
    return {
      tag: "span",
      id: `${this.id}-input`,
      reference: "displayElement",
      html: this.template ? this.template(this.value) : StringHelper.encodeHtml(this.value)
    };
  }
};
DisplayField.initClass();
DisplayField._$name = "DisplayField";
var generateMonthNames = () => DateHelper.getMonthNames().map((m, i) => [i, m]);
var dateSort = (lhs, rhs) => lhs.valueOf() - rhs.valueOf();
var emptyArray$4 = Object.freeze([]);
var ReadOnlyCombo = class extends Combo {
  static get $name() {
    return "ReadOnlyCombo";
  }
  static get type() {
    return "readonlycombo";
  }
  static get configurable() {
    return {
      editable: false,
      inputAttributes: {
        tag: "div",
        tabIndex: -1
      },
      inputValueAttr: "innerHTML",
      highlightExternalChange: false,
      monitorResize: false,
      triggers: {
        expand: false
      },
      picker: {
        align: {
          align: "t-b",
          axisLock: true,
          matchSize: false
        },
        cls: "b-readonly-combo-list",
        scrollable: {
          overflowX: false
        }
      }
    };
  }
};
ReadOnlyCombo.initClass();
var DatePicker = class extends CalendarPanel {
  static get $name() {
    return "DatePicker";
  }
  static get type() {
    return "datepicker";
  }
  static get delayable() {
    return {
      refresh: "raf"
    };
  }
  static get configurable() {
    return {
      activeDate: {
        value: new Date(),
        $config: {
          equal: "date"
        }
      },
      focusable: true,
      textContent: false,
      tbar: {
        overflow: null,
        items: {
          prevYear: {
            cls: "b-icon b-icon-first",
            onAction: "up.gotoPrevYear",
            tooltip: "L{DatePicker.gotoPrevYear}"
          },
          prevMonth: {
            cls: "b-icon b-icon-previous",
            onAction: "up.gotoPrevMonth",
            tooltip: "L{DatePicker.gotoPrevMonth}"
          },
          fields: {
            type: "container",
            cls: "b-datepicker-title",
            items: {
              monthField: {
                type: "readonlycombo",
                cls: "b-datepicker-monthfield",
                items: generateMonthNames(),
                internalListeners: {
                  select: "up.onMonthPicked"
                }
              },
              yearButton: {
                type: "button",
                cls: "b-datepicker-yearbutton",
                internalListeners: {
                  click: "up.onYearPickerRequested"
                }
              }
            }
          },
          nextMonth: {
            cls: "b-icon b-icon-next",
            onAction: "up.gotoNextMonth",
            tooltip: "L{DatePicker.gotoNextMonth}"
          },
          nextYear: {
            cls: "b-icon b-icon-last",
            onAction: "up.gotoNextYear",
            tooltip: "L{DatePicker.gotoNextYear}"
          }
        }
      },
      yearPicker: {
        value: {
          type: "YearPicker",
          yearButtonCount: 16,
          trapFocus: true,
          positioned: true,
          hidden: true,
          internalListeners: {
            titleClick: "up.onYearPickerTitleClick",
            select: "up.onYearPicked"
          }
        },
        $config: "lazy"
      },
      date: null,
      minDate: {
        value: null,
        $config: {
          equal: "date"
        }
      },
      maxDate: {
        value: null,
        $config: {
          equal: "date"
        }
      },
      focusDisabledDates: null,
      multiSelect: false,
      selection: {
        $config: {
          equal: (v1, v2) => v1 && v1.equals(v2)
        },
        value: null
      },
      editMonth: true,
      dayNameFormat: "dd",
      trapFocus: true,
      role: "grid",
      focusDescendant: true,
      alwaysRefreshOnMonthChange: null
    };
  }
  static get prototypeProperties() {
    return {
      outOfRangeCls: "b-out-of-range",
      activeCls: "b-active-date",
      selectedCls: "b-selected-date"
    };
  }
  construct(config) {
    const me = this;
    super.construct(config);
    me.externalCellRenderer = me.cellRenderer;
    me.cellRenderer = me.internalCellRenderer;
    me.element.setAttribute("aria-activedescendant", `${me.id}-active-day`);
    me.weeksElement.setAttribute("role", "grid");
    me.weekElements.forEach((w) => w.setAttribute("role", "row"));
    me.element.setAttribute("ariaLabelledBy", me.widgetMap.fields.id);
    EventHelper.on({
      element: me.weeksElement,
      click: {
        handler: "onCellClick",
        delegate: `.${me.dayCellCls}:not(.${me.disabledCls}):not(.${me.outOfRangeCls})`
      },
      mousedown: {
        handler: "onCellMousedown",
        delegate: `.${me.dayCellCls}`
      },
      thisObj: me
    });
    me.widgetMap.monthField.readOnly = me.widgetMap.yearButton.disabled = !me.editMonth;
    me.refresh.flush();
  }
  afterHide() {
    var _this$_yearPicker;
    (_this$_yearPicker = this._yearPicker) === null || _this$_yearPicker === void 0 ? void 0 : _this$_yearPicker.hide();
    super.afterHide(...arguments);
  }
  doDestroy() {
    var _this$yearButton, _this$monthField;
    (_this$yearButton = this.yearButton) === null || _this$yearButton === void 0 ? void 0 : _this$yearButton.destroy();
    (_this$monthField = this.monthField) === null || _this$monthField === void 0 ? void 0 : _this$monthField.destroy();
    super.doDestroy();
  }
  get focusElement() {
    return this.weeksElement.querySelector(`.${this.dayCellCls}[tabIndex="0"]`);
  }
  doRefresh() {
    const me = this, oldActiveCell = me.focusElement, activeDate = DateHelper.betweenLesser(me.activeDate, me.month.startDate, me.month.endDate) ? me.activeDate : me._activeDate = me.date;
    super.doRefresh(...arguments);
    const dateOfOldActiveCell = DateHelper.parseKey(oldActiveCell === null || oldActiveCell === void 0 ? void 0 : oldActiveCell.dataset.date);
    if (activeDate - dateOfOldActiveCell) {
      me.syncActiveDate(activeDate, dateOfOldActiveCell);
    }
  }
  internalCellRenderer({
    cell,
    date: date2
  }) {
    const me = this, {
      activeCls,
      selectedCls,
      externalCellRenderer
    } = me, isSelected = me.isSelectedDate(date2), cellClassList = {
      [activeCls]: activeCls && me.isActiveDate(date2),
      [selectedCls]: isSelected,
      [me.outOfRangeCls]: me.minDate && date2 < me.minDate || me.maxDate && date2 > me.maxDate
    };
    if (isSelected) {
      if (me.multiSelect) {
        const isStart = !me.isSelectedDate(DateHelper.add(date2, -1, "d")), isEnd = !me.isSelectedDate(DateHelper.add(date2, 1, "d"));
        cellClassList["b-range-start"] = isStart;
        cellClassList["b-range-end"] = isEnd;
        cellClassList["b-in-range"] = !isStart && !isEnd;
      }
    }
    DomHelper.updateClassList(cell, cellClassList);
    cell.innerHTML = `<div class="b-datepicker-cell-inner">${date2.getDate()}</div>`;
    cell.setAttribute("role", "gridcell");
    cell.setAttribute("aria-label", DateHelper.format(date2, "MMMM D, YYYY"));
    if (me.isActiveDate(date2)) {
      cell.id = `${me.id}-active-day`;
    } else {
      cell.removeAttribute("id");
    }
    if (externalCellRenderer) {
      arguments[0].cell = cell.firstChild;
      me.callback(externalCellRenderer, this, arguments);
    }
  }
  onCellMousedown(event) {
    const cell = event.target.closest("[data-date]");
    event.preventDefault();
    cell.focus();
    this.activeDate = DateHelper.parseKey(cell.dataset.date);
  }
  onCellClick(event) {
    const cell = event.target.closest("[data-date]");
    this.onUIDateSelect(DateHelper.parseKey(cell.dataset.date), event);
  }
  onMonthDateChange({
    newDate,
    changes
  }) {
    this.getConfig("tbar");
    super.onMonthDateChange(...arguments);
    if (changes.m || changes.y) {
      this.widgetMap.monthField.value = newDate.getMonth();
      this.widgetMap.yearButton.text = newDate.getFullYear();
    }
  }
  onUIDateSelect(date2, event) {
    const me = this, {
      lastClickedDate,
      multiSelect
    } = me;
    me.lastClickedDate = date2;
    if (!me.isDisabledDate(date2)) {
      me.activatingEvent = event;
      if (multiSelect) {
        me.handleMultiSelect(lastClickedDate, date2, event);
      } else {
        me.selection = date2;
        if (me.floating) {
          me.hide();
        }
      }
      me.activatingEvent = null;
    }
  }
  handleMultiSelect(lastClickedDate, date2, event) {
    const me = this, {
      multiSelect,
      _selection
    } = me, selection = _selection.dates, singleRange = multiSelect === "range", {
      size,
      generation
    } = _selection, rangeEnds = size && {
      [DateHelper.makeKey(DateHelper.add(selection[0], -1, "d"))]: 1,
      [DateHelper.makeKey(selection[0])]: 1,
      [DateHelper.makeKey(selection[selection.length - 1])]: 1,
      [DateHelper.makeKey(DateHelper.add(selection[selection.length - 1], 1, "d"))]: 1
    }, isSelected = _selection.has(date2), toggleFn = isSelected ? "delete" : "add";
    const clickedRangeEnd = singleRange && (rangeEnds === null || rangeEnds === void 0 ? void 0 : rangeEnds[DateHelper.makeKey(date2)]);
    if (event.ctrlKey) {
      if (multiSelect === true || !size || clickedRangeEnd) {
        _selection[toggleFn](date2);
        if (singleRange && !_selection.has(me.rangeStartDate)) {
          me.rangeStartDate.setDate(me.rangeStartDate.getDate() + (date2 < selection[1] ? 1 : -1));
        }
      }
    } else if (event.shiftKey && size) {
      const [start, end] = [new Date(singleRange ? me.rangeStartDate || (me.rangeStartDate = selection[0]) : lastClickedDate), date2].sort(dateSort);
      if (singleRange) {
        _selection.clear();
      }
      for (const d = start; d <= end; d.setDate(d.getDate() + 1)) {
        _selection.add(d);
      }
    } else if (!(_selection.has(date2) && _selection.size === 1)) {
      _selection.clear();
      _selection.add(date2);
    }
    const newSize = _selection.size;
    if (newSize === 1) {
      me.rangeStartDate = date2;
    } else if (!newSize) {
      me.rangeStartDate = null;
    }
    if (_selection.generation !== generation) {
      me.updateSelection(_selection);
    }
  }
  changeSelection(selection) {
    const me = this;
    let result, rangeStartDate;
    if (selection) {
      if (!selection.forEach) {
        selection = [selection];
      }
      selection.forEach((d, i) => selection[i] = me.changeDate(d));
      rangeStartDate = selection[0];
      selection.sort(dateSort);
      if (me.multiSelect === "range" && selection.length === 2) {
        result = new DateSet();
        for (const d = new Date(selection[0]); d <= selection[1]; d.setDate(d.getDate() + 1)) {
          result.add(d);
        }
      } else {
        rangeStartDate = selection[0];
        result = new DateSet(selection);
      }
    } else {
      result = new DateSet();
    }
    if (rangeStartDate) {
      me.activeDate = me.rangeStartDate = DateHelper.clearTime(rangeStartDate);
    }
    return result;
  }
  updateSelection(dateSet) {
    const me = this, {
      dates
    } = dateSet, selection = me.multiSelect === "range" ? [dates[0], dates[dates.length - 1]] : dates;
    dates.length && (me.date = dates[0]);
    if (!me.isConfiguring) {
      me.refresh.now();
      me.trigger("selectionChange", {
        selection,
        userAction: Boolean(me.activatingEvent)
      });
    }
  }
  get selection() {
    const {
      _selection
    } = this, dates = _selection ? _selection.dates : emptyArray$4;
    return this.multiSelect === "range" && dates.length ? [dates[0], dates[dates.length - 1]] : dates;
  }
  onInternalKeyDown(keyEvent) {
    const me = this, keyName = keyEvent.key.trim() || keyEvent.code, activeDate = me.activeDate;
    let newDate = new Date(activeDate);
    if (keyName === "Escape" && me.floating) {
      return me.hide();
    }
    if (activeDate && me.weeksElement.contains(keyEvent.target)) {
      do {
        switch (keyName) {
          case "ArrowLeft":
            keyEvent.preventDefault();
            if (keyEvent.ctrlKey) {
              newDate = me.gotoPrevMonth();
            } else {
              newDate.setDate(newDate.getDate() - 1);
            }
            break;
          case "ArrowUp":
            keyEvent.preventDefault();
            newDate.setDate(newDate.getDate() - 7);
            break;
          case "ArrowRight":
            keyEvent.preventDefault();
            if (keyEvent.ctrlKey) {
              newDate = me.gotoNextMonth();
            } else {
              newDate.setDate(newDate.getDate() + 1);
            }
            break;
          case "ArrowDown":
            keyEvent.preventDefault();
            newDate.setDate(newDate.getDate() + 7);
            break;
          case "Enter":
            return me.onUIDateSelect(activeDate, keyEvent);
        }
      } while (me.isDisabledDate(newDate) && !me.focusDisabledDates);
      if (me.minDate && newDate < me.minDate) {
        return;
      }
      if (me.maxDate && newDate > me.maxDate) {
        return;
      }
      me.activeDate = newDate;
    }
  }
  changeMinDate(minDate) {
    return minDate && CalendarPanel.prototype.changeDate.apply(this, arguments);
  }
  updateMinDate(minDate) {
    this._yearpicker && (this._yearpicker.minYear = minDate === null || minDate === void 0 ? void 0 : minDate.getFullYear());
    this.refresh();
  }
  changeMaxDate(minDate) {
    return minDate && CalendarPanel.prototype.changeDate.apply(this, arguments);
  }
  updateMaxDate(maxDate) {
    this._yearpicker && (this._yearpicker.maxYear = maxDate === null || maxDate === void 0 ? void 0 : maxDate.getFullYear());
    this.refresh();
  }
  changeDate(date2) {
    return DateHelper.clamp(super.changeDate(date2), this.minDate, this.maxDate);
  }
  updateDate(date2) {
    const me = this;
    me.isConfiguring && !me.initializingActiveDate && (me.selection = date2);
    if (!me.month.date || date2.getMonth() === me.month.month || !me.getCell(date2) || me.alwaysRefreshOnMonthChange || me.isNavigating) {
      super.updateDate(date2);
    }
  }
  changeActiveDate(activeDate, oldActiveDate) {
    if (this.trigger("beforeActiveDateChange", {
      activeDate,
      oldActiveDate
    }) === false) {
      return;
    }
    activeDate = activeDate ? this.changeDate(activeDate) : this.date || (this.date = DateHelper.clearTime(new Date()));
    if (isNaN(activeDate)) {
      throw new Error("DatePicker date ingestion must be passed a Date, or a YYYY-MM-DD date string");
    }
    return DateHelper.clamp(activeDate, this.minDate, this.maxDate);
  }
  updateActiveDate(activeDate, wasActiveDate) {
    const me = this, {
      isConfiguring
    } = me;
    if (isConfiguring || !me.getCell(activeDate)) {
      me.initializingActiveDate = isConfiguring;
      me.date = activeDate;
      me.initializingActiveDate = false;
    }
    if (!isConfiguring && !me.refresh.isPending) {
      me.syncActiveDate(activeDate, wasActiveDate);
    }
  }
  syncActiveDate(activeDate, wasActiveDate) {
    const me = this, {
      activeCls
    } = me, activeCell = me.getCell(activeDate), wasActiveCell = wasActiveDate && me.getCell(wasActiveDate), activeElement = DomHelper.getActiveElement(me.element);
    activeCell.setAttribute("tabIndex", 0);
    activeCls && activeCell.classList.add(activeCls);
    activeCell.id = `${me.id}-active-day`;
    if (me.weeksElement.contains(activeElement)) {
      activeCell.focus();
    }
    if (wasActiveCell && wasActiveCell !== activeCell) {
      wasActiveCell.removeAttribute("tabIndex");
      activeCls && wasActiveCell.classList.remove(activeCls);
      wasActiveCell.removeAttribute("id");
    }
  }
  set value(value) {
    const me = this;
    if (value) {
      value = me.changeDate(value, me.value);
      if (value !== void 0) {
        me.selection = value;
      }
    } else {
      me.date = new Date();
      me.selection = null;
    }
  }
  get value() {
    return this.selection[this.selection.length - 1];
  }
  gotoPrevYear() {
    return this.goto(-1, "year");
  }
  gotoPrevMonth() {
    return this.goto(-1, "month");
  }
  gotoNextMonth() {
    return this.goto(1, "month");
  }
  gotoNextYear() {
    return this.goto(1, "year");
  }
  goto(direction, unit) {
    const me = this, {
      activeDate
    } = me, activeCell = activeDate && me.getCell(activeDate);
    let newDate;
    if (unit === "month" && activeCell && (activeDate === null || activeDate === void 0 ? void 0 : activeDate.getMonth()) === me.month.month + direction) {
      newDate = activeDate;
    } else {
      newDate = DateHelper.add(activeCell ? activeDate : me.date, direction, unit);
    }
    const firstDateOfNewMonth = new Date(newDate);
    firstDateOfNewMonth.setDate(1);
    const lastDateOfNewMonth = DateHelper.add(DateHelper.add(firstDateOfNewMonth, 1, "month"), -1, "day");
    if (me.minDate && direction < 0 && lastDateOfNewMonth < me.minDate || me.maxDate && direction > 0 && firstDateOfNewMonth > me.maxDate) {
      return;
    }
    me.isNavigating = true;
    const result = me.date = newDate;
    if (activeCell) {
      me.activeDate = newDate;
    }
    me.isNavigating = false;
    return result;
  }
  isActiveDate(date2) {
    return !(date2 - this.activeDate);
  }
  isSelectedDate(date2) {
    var _this$_selection;
    return (_this$_selection = this._selection) === null || _this$_selection === void 0 ? void 0 : _this$_selection.has(date2);
  }
  onMonthPicked({
    record,
    userAction
  }) {
    if (userAction) {
      var _this$focusElement;
      this.activeDate = DateHelper.add(this.activeDate, record.value - this.activeDate.getMonth(), "month");
      (_this$focusElement = this.focusElement) === null || _this$focusElement === void 0 ? void 0 : _this$focusElement.focus();
    }
  }
  onYearPickerRequested() {
    const {
      yearPicker
    } = this;
    if (yearPicker.isVisible) {
      yearPicker.hide();
    } else {
      yearPicker.year = yearPicker.startYear = this.activeDate.getFullYear();
      yearPicker.show();
      yearPicker.focus();
    }
  }
  onYearPickerTitleClick() {
    this.yearPicker.hide();
  }
  onYearPicked({
    value,
    source
  }) {
    const newDate = new Date(this.activeDate);
    newDate.setFullYear(value);
    this.activeDate = newDate;
    this.focusElement && DomHelper.focusWithoutScrolling(this.focusElement);
    source.hide();
  }
  changeYearPicker(yearPicker, oldYearPicker) {
    var _this$minDate, _this$maxDate;
    return YearPicker.reconfigure(oldYearPicker, yearPicker ? YearPicker.mergeConfigs({
      owner: this,
      appendTo: this.element,
      minYear: (_this$minDate = this.minDate) === null || _this$minDate === void 0 ? void 0 : _this$minDate.getFullYear(),
      maxYear: (_this$maxDate = this.maxDate) === null || _this$maxDate === void 0 ? void 0 : _this$maxDate.getFullYear()
    }, yearPicker) : null, this);
  }
  get childItems() {
    const {
      _yearPicker
    } = this, result = super.childItems;
    if (_yearPicker) {
      result.push(_yearPicker);
    }
    return result;
  }
  updateLocalization() {
    const {
      monthField
    } = this.widgetMap, newData = generateMonthNames();
    if (!this.isConfiguring && !newData.every((d, i) => d[1] === monthField.store.getAt(i).text)) {
      newData[monthField.value].selected = true;
      monthField.items = newData;
    }
    super.updateLocalization();
  }
};
var DateSet = class extends Set {
  add(d) {
    d = DateHelper.makeKey(d);
    if (!this.has(d)) {
      this.generation = (this.generation || 0) + 1;
    }
    return super.add(d);
  }
  delete(d) {
    d = DateHelper.makeKey(d);
    if (this.has(d)) {
      this.generation++;
    }
    return super.delete(d);
  }
  has(d) {
    return super.has(DateHelper.makeKey(d));
  }
  clear() {
    if (this.size) {
      this.generation++;
    }
    return super.clear();
  }
  equals(other) {
    Array.isArray(other) && (other = new DateSet(other));
    return other.size === this.size && [...this].every((s) => other.has(s));
  }
  get dates() {
    return [...this].sort().map((k) => DateHelper.parseKey(k));
  }
};
DatePicker.initClass();
DatePicker._$name = "DatePicker";
var DateField = class extends PickerField {
  static get $name() {
    return "DateField";
  }
  static get type() {
    return "datefield";
  }
  static get alias() {
    return "date";
  }
  static get configurable() {
    return {
      format: "L",
      strictParsing: false,
      fallbackFormat: "YYYY-MM-DD",
      timeFormat: "HH:mm:ss:SSS",
      keepTime: false,
      pickerFormat: null,
      validateDateOnly: null,
      triggers: {
        expand: {
          cls: "b-icon-calendar",
          handler: "onTriggerClick",
          weight: 200
        },
        back: {
          cls: "b-icon b-icon-angle-left b-step-trigger",
          key: "Shift+ArrowDown",
          handler: "onBackClick",
          align: "start",
          weight: 100
        },
        forward: {
          cls: "b-icon b-icon-angle-right b-step-trigger",
          key: "Shift+ArrowUp",
          handler: "onForwardClick",
          align: "end",
          weight: 100
        }
      },
      calendarContainerCls: "",
      min: null,
      max: null,
      step: false,
      stepTriggers: null,
      weekStartDay: null,
      picker: {
        type: "datepicker",
        role: "dialog",
        floating: true,
        scrollAction: "realign",
        align: {
          align: "t0-b0",
          axisLock: true
        }
      },
      value: null
    };
  }
  changePicker(picker, oldPicker) {
    const me = this, defaults = {
      owner: me,
      forElement: me[me.pickerAlignElement],
      minDate: me.min,
      maxDate: me.max,
      weekStartDay: me._weekStartDay,
      align: {
        anchor: me.overlayAnchor,
        target: me[me.pickerAlignElement]
      },
      onSelectionChange: ({
        selection,
        source: picker2
      }) => {
        if (picker2.isVisible) {
          me._isUserAction = me._isPickerInput = true;
          me.value = selection[0];
          me._isPickerInput = me._isUserAction = false;
          picker2.hide();
        }
      }
    };
    if (me.calendarContainerCls) {
      defaults.cls = me.calendarContainerCls;
    }
    if (me.value) {
      defaults.value = me.value;
    } else {
      defaults.activeDate = new Date();
    }
    const result = DatePicker.reconfigure(oldPicker, picker, {
      owner: me,
      defaults
    });
    result === null || result === void 0 ? void 0 : result.refresh.flush();
    return result;
  }
  get backShiftDate() {
    return DateHelper.add(this.value, -1 * this._step.magnitude, this._step.unit);
  }
  onBackClick() {
    const me = this, {
      min: min2
    } = me;
    if (!me.readOnly && me.value) {
      const newValue = me.backShiftDate;
      if (!min2 || min2.getTime() <= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  get forwardShiftDate() {
    return DateHelper.add(this.value, this._step.magnitude, this._step.unit);
  }
  onForwardClick() {
    const me = this, {
      max
    } = me;
    if (!me.readOnly && me.value) {
      const newValue = me.forwardShiftDate;
      if (!max || max.getTime() >= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  showPicker(focusPicker) {
    if (this.readOnly) {
      return;
    }
    const me = this, {
      _picker
    } = me;
    if (_picker) {
      const pickerConfig = {
        minDate: me.min,
        maxDate: me.max
      };
      if (me.value) {
        pickerConfig.value = me.value;
      } else {
        pickerConfig.activeDate = new Date();
      }
      _picker.setConfig(pickerConfig);
    }
    super.showPicker(focusPicker);
  }
  focusPicker() {
    this.picker.focus();
  }
  get isValid() {
    const me = this;
    me.clearError("L{Field.minimumValueViolation}", true);
    me.clearError("L{Field.maximumValueViolation}", true);
    let value = me.value;
    if (value) {
      const {
        min: min2,
        max,
        validateDateOnly
      } = me;
      if (validateDateOnly) {
        value = DateHelper.clearTime(value, false);
      }
      if (min2 && value < min2) {
        me.setError("L{Field.minimumValueViolation}", true);
        return false;
      }
      if (max && value > max) {
        me.setError("L{Field.maximumValueViolation}", true);
        return false;
      }
    }
    return super.isValid;
  }
  transformDateValue(value) {
    const me = this;
    if (value != null) {
      if (!DateHelper.isDate(value)) {
        if (typeof value === "string") {
          value = DateHelper.parse(value, me.format, me.strictParsing) || DateHelper.parse(value, me.fallbackFormat, me.strictParsing);
        } else {
          value = new Date(value);
        }
      }
      if (DateHelper.isValidDate(value)) {
        if ((!me.min || value - me.min > -DateHelper.MS_PER_DAY) && (!me.max || value <= me.max)) {
          return me.transformTimeValue(value);
        }
        return value;
      }
    }
    return null;
  }
  transformTimeValue(value) {
    const me = this, {
      keepTime
    } = me;
    value = DateHelper.clone(value);
    if (!keepTime) {
      DateHelper.clearTime(value, false);
    } else if (keepTime !== "entered") {
      const timeValue = DateHelper.parse(keepTime, me.timeFormat);
      if (DateHelper.isValidDate(timeValue)) {
        DateHelper.copyTimeValues(value, timeValue);
      } else if (DateHelper.isValidDate(me.value)) {
        DateHelper.copyTimeValues(value, me.value);
      }
    } else if (me._isPickerInput && DateHelper.isValidDate(me.value)) {
      DateHelper.copyTimeValues(value, me.value);
    }
    return value;
  }
  changeMin(value) {
    return this.transformDateValue(value);
  }
  updateMin(min2) {
    const {
      input,
      _picker
    } = this;
    if (input) {
      if (min2 == null) {
        input.removeAttribute("min");
      } else {
        input.min = min2;
      }
    }
    if (_picker) {
      _picker.minDate = min2;
    }
    this.syncInvalid();
  }
  changeMax(value) {
    return this.transformDateValue(value);
  }
  updateMax(max) {
    const {
      input,
      _picker
    } = this;
    if (input) {
      if (max == null) {
        input.removeAttribute("max");
      } else {
        input.max = max;
      }
    }
    if (_picker) {
      _picker.maxDate = max;
    }
    this.syncInvalid();
  }
  get weekStartDay() {
    return typeof this._weekStartDay === "number" ? this._weekStartDay : DateHelper.weekStartDay;
  }
  updateWeekStartDay(weekStartDay) {
    if (this._picker) {
      this._picker.weekStartDay = weekStartDay;
    }
  }
  changeValue(value, oldValue) {
    const me = this, newValue = me.transformDateValue(value);
    if (value && !newValue) {
      me.setError("L{invalidDate}");
      return;
    }
    me.clearError("L{invalidDate}");
    if (me.hasChanged(oldValue, newValue)) {
      return super.changeValue(newValue, oldValue);
    }
    if (!me.inputting) {
      me.syncInputFieldValue();
    }
  }
  updateValue(value, oldValue) {
    const picker = this._picker;
    if (picker && !this.inputting) {
      picker.value = value;
    }
    super.updateValue(value, oldValue);
  }
  changeStep(value, was) {
    const type = typeof value;
    if (!value) {
      return null;
    }
    if (type === "number") {
      value = {
        magnitude: Math.abs(value),
        unit: was ? was.unit : "day"
      };
    } else if (type === "string") {
      value = DateHelper.parseDuration(value);
    }
    if (value && value.unit && value.magnitude) {
      if (value.magnitude < 0) {
        value = {
          magnitude: -value.magnitude,
          unit: value.unit
        };
      }
      return value;
    }
  }
  updateStep(value) {
    this.element.classList[value ? "remove" : "add"]("b-no-steppers");
    this.syncInvalid();
  }
  hasChanged(oldValue, newValue) {
    if (oldValue !== null && oldValue !== void 0 && oldValue.getTime && newValue !== null && newValue !== void 0 && newValue.getTime && this.keepTime !== "entered") {
      return !DateHelper.isEqual(DateHelper.clearTime(oldValue), DateHelper.clearTime(newValue));
    }
    return super.hasChanged(oldValue && oldValue.getTime(), newValue && newValue.getTime());
  }
  get inputValue() {
    const date2 = this.value;
    return date2 ? DateHelper.format(date2, this.format) : "";
  }
  updateFormat() {
    if (!this.isConfiguring) {
      this.syncInputFieldValue(true);
    }
  }
  updateLocalization() {
    super.updateLocalization();
    this.syncInputFieldValue(true);
  }
  internalOnKeyEvent(event) {
    super.internalOnKeyEvent(event);
    if (event.key === "Enter" && this.isValid) {
      this.picker.hide();
    }
  }
};
DateField.initClass();
DateField._$name = "DateField";
var NumberField = class extends Field {
  static get $name() {
    return "NumberField";
  }
  static get type() {
    return "numberfield";
  }
  static get alias() {
    return "number";
  }
  static get configurable() {
    return {
      min: null,
      max: null,
      step: 1,
      largeStep: 0,
      value: null,
      format: "",
      decimalPrecision: null,
      leadingZeroes: null,
      triggers: {
        spin: {
          type: "spintrigger"
        }
      },
      changeOnSpin: true,
      inputType: null
    };
  }
  construct(config) {
    super.construct(config);
    const me = this;
    me.input.addEventListener("dblclick", () => {
      me.select();
    });
    if (typeof me.changeOnSpin === "number") {
      me.bufferedSpinChange = me.buffer(me.triggerChange, me.changeOnSpin);
    }
  }
  acceptValue(value, rawValue) {
    let accept = !isNaN(value);
    if (accept && !this.hasTextSelection) {
      accept = false;
      const raw = this.input.value, current = parseFloat(raw);
      if (raw !== rawValue) {
        accept = !this.acceptValue(current, raw);
      }
    }
    return accept;
  }
  okMax(value) {
    return isNaN(this.max) || value <= this.max;
  }
  okMin(value) {
    return isNaN(this.min) || value >= this.min;
  }
  internalOnKeyEvent(e) {
    if (e.type === "keydown") {
      const me = this, key = e.key;
      let block;
      if (key === "ArrowUp") {
        me.doSpinUp(e.shiftKey);
        block = true;
      } else if (key === "ArrowDown") {
        me.doSpinDown(e.shiftKey);
        block = true;
      } else if (!e.altKey && !e.ctrlKey && key && key.length === 1) {
        const after = me.getAfterValue(key), afterValue = me.formatter.parseStrict(after), accepted = afterValue === me.value || after === "-" && (isNaN(me.min) || me.min < 0);
        block = !accepted && !me.acceptValue(afterValue, after);
      }
      if (key === "Enter" && me._changedBySilentSpin) {
        me.triggerChange(e, true);
        me._changedBySilentSpin = false;
      }
      if (block) {
        e.preventDefault();
      }
    }
    super.internalOnKeyEvent(e);
  }
  doSpinUp(largeStep = false) {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.value || 0) + (largeStep ? me.largeStep : me.step);
    if (!me.okMin(newValue)) {
      newValue = me.min;
    }
    if (me.okMax(newValue)) {
      me.applySpinChange(newValue);
    }
  }
  doSpinDown(largeStep = false) {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.value || 0) - (largeStep ? me.largeStep : me.step);
    if (!me.okMax(newValue)) {
      newValue = me.max;
    }
    if (me.okMin(newValue)) {
      me.applySpinChange(newValue);
    }
  }
  applySpinChange(newValue) {
    const me = this;
    me._isUserAction = true;
    if (me.changeOnSpin !== true) {
      me._changedBySilentSpin = true;
      me.silenceChange = true;
      me.bufferedSpinChange && me.bufferedSpinChange(null, true);
    }
    me.value = newValue;
    me._isUserAction = false;
    me.silenceChange = false;
  }
  triggerChange() {
    if (!this.silenceChange) {
      super.triggerChange(...arguments);
    }
  }
  onFocusOut(e) {
    var _me$triggers, _me$triggers$spin, _me$triggers$spin$cli;
    super.onFocusOut(...arguments);
    const me = this, {
      input
    } = me, raw = input.value, value = me.formatter.truncate(raw), formatted = isNaN(value) ? raw : me.formatValue(value);
    (_me$triggers = me.triggers) === null || _me$triggers === void 0 ? void 0 : (_me$triggers$spin = _me$triggers.spin) === null || _me$triggers$spin === void 0 ? void 0 : (_me$triggers$spin$cli = _me$triggers$spin.clickRepeater) === null || _me$triggers$spin$cli === void 0 ? void 0 : _me$triggers$spin$cli.cancel();
    if (raw !== formatted) {
      input.value = formatted;
    }
    if (me._changedBySilentSpin) {
      me.triggerChange(e, true);
      me._changedBySilentSpin = false;
    }
  }
  internalOnInput(event) {
    const me = this, {
      formatter,
      input
    } = me, {
      parser
    } = formatter, raw = input.value, decimals = parser.decimalPlaces(raw);
    if (formatter.truncator && decimals) {
      let value = raw;
      const trunc = formatter.truncate(raw);
      if (!isNaN(trunc)) {
        value = me.formatValue(trunc);
        if (parser.decimalPlaces(value) < decimals) {
          const pos = raw.length - me.caretPos;
          input.value = value;
          me.caretPos = value.length - pos;
        }
      }
    }
    super.internalOnInput(event);
  }
  formatValue(value) {
    return this.formatter.format(value);
  }
  changeFormat(format2) {
    const me = this;
    if (format2 === "") {
      const {
        leadingZeroes,
        decimalPrecision
      } = me;
      format2 = leadingZeroes ? `${leadingZeroes}>9` : null;
      if (decimalPrecision != null) {
        format2 = `${format2 || ""}9.${"#".repeat(decimalPrecision)}`;
      } else if (format2) {
        format2 += ".*";
      }
    }
    return format2;
  }
  get formatter() {
    const me = this, format2 = me.format;
    let formatter = me._formatter;
    if (!formatter || me._lastFormat !== format2) {
      formatter = NumberFormat.get(me._lastFormat = format2);
      me._formatter = formatter;
    }
    return formatter;
  }
  updateStep(step) {
    this.element.classList[step ? "remove" : "add"]("b-hide-spinner");
    this._step = step;
  }
  changeLargeStep(largeStep) {
    return largeStep || this.step * 10;
  }
  get validity() {
    const value = this.value, validity = {};
    if (value != null) {
      validity.rangeUnderflow = !this.okMin(value);
      validity.rangeOverflow = !this.okMax(value);
    }
    validity.valid = !validity.rangeUnderflow && !validity.rangeOverflow;
    return validity;
  }
  changeValue(value, was) {
    const me = this;
    if (value || value === 0) {
      let valueIsNaN;
      if (typeof value !== "number") {
        value = typeof value === "string" ? me.formatter.parse(value) : Number(value);
        valueIsNaN = isNaN(value);
        if (valueIsNaN) {
          value = "";
        }
      }
      if (!valueIsNaN && me.format) {
        value = me.formatter.round(value);
      }
    } else {
      value = void 0;
    }
    return super.changeValue(value, was);
  }
  get inputValue() {
    let value = this.value;
    if (value != null && this.format) {
      value = this.formatValue(value);
    }
    return value;
  }
};
NumberField.initClass();
NumberField._$name = "NumberField";
var TimePicker = class extends Container {
  static get $name() {
    return "TimePicker";
  }
  static get type() {
    return "timepicker";
  }
  construct(config) {
    super.construct(config);
    this.refresh();
  }
  updateSeconds(seconds) {
    this.widgetMap.second[seconds ? "show" : "hide"]();
  }
  onFieldChange() {
    if (!this.isConfiguring && !this.isRefreshing) {
      this.value = this.pickerToTime();
    }
  }
  onAmPmButtonClick({
    source
  }) {
    this._pm = source.ref === "pmButton";
    if (this._value) {
      this.value = this.pickerToTime();
    }
  }
  onInternalKeyDown(keyEvent) {
    var _super$onInternalKeyD;
    const me = this;
    switch (keyEvent.key) {
      case "Escape":
        me.triggerTimeChange(me._initialValue);
        me.hide();
        keyEvent.preventDefault();
        return;
      case "Enter":
        me.value = me.pickerToTime();
        me.hide();
        keyEvent.preventDefault();
        return;
    }
    (_super$onInternalKeyD = super.onInternalKeyDown) === null || _super$onInternalKeyD === void 0 ? void 0 : _super$onInternalKeyD.call(this, keyEvent);
  }
  pickerToTime() {
    const me = this, pm2 = me._pm, {
      hour: hour2,
      minute,
      second
    } = me.widgetMap;
    hour2.format = me._is24Hour ? "2>9" : null;
    let hours = hour2.value, newValue = new Date(me.value);
    if (!me._is24Hour) {
      if (pm2 && hours < 12)
        hours = hours + 12;
      if (!pm2 && hours === 12)
        hours = 0;
    }
    newValue.setHours(hours);
    newValue.setMinutes(minute.value);
    if (me.seconds) {
      newValue.setSeconds(second.value);
    }
    if (me._min) {
      newValue = DateHelper.max(me._min, newValue);
    }
    if (me._max) {
      newValue = DateHelper.min(me._max, newValue);
    }
    return newValue;
  }
  triggerTimeChange(time) {
    this.trigger("timeChange", {
      time
    });
  }
  updateInitialValue(initialValue) {
    this.value = initialValue;
  }
  changeValue(value) {
    var _value;
    if (value) {
      value = typeof value === "string" ? DateHelper.parse(value, this.format) : value;
    }
    if (!this.isVisible) {
      this._initialValue = value;
    }
    return (_value = value) !== null && _value !== void 0 ? _value : DateHelper.getTime(0);
  }
  updateValue(value) {
    if (this.isVisible) {
      this.triggerTimeChange(value);
    }
    this.refresh();
  }
  updateFormat(format2) {
    this._is24Hour = DateHelper.is24HourFormat(format2);
    this.refresh();
  }
  changeMin(min2) {
    return typeof min2 === "string" ? DateHelper.parse(min2, this.format) : min2;
  }
  changeMax(max) {
    return typeof max === "string" ? DateHelper.parse(max, this.format) : max;
  }
  refresh() {
    const me = this;
    if (!me.isConfiguring && me.value) {
      me.isRefreshing = true;
      const {
        hour: hour2,
        minute,
        second,
        amButton,
        pmButton
      } = me.widgetMap, time = me.value, is24 = me._is24Hour, hours = time.getHours(), pm2 = me._pm = hours >= 12;
      me.element.classList[is24 ? "add" : "remove"]("b-24h");
      hour2.min = is24 ? 0 : 1;
      hour2.max = is24 ? 23 : 12;
      hour2.value = is24 ? hours : hours % 12 || 12;
      minute.value = time.getMinutes();
      second.value = time.getSeconds();
      amButton.pressed = !pm2;
      pmButton.pressed = pm2;
      amButton.hidden = pmButton.hidden = is24;
      me.isRefreshing = false;
    }
  }
};
_defineProperty(TimePicker, "configurable", {
  floating: true,
  items: {
    hour: {
      label: "L{TimePicker.hour}",
      type: "number",
      min: 0,
      max: 23,
      highlightExternalChange: false,
      format: "2>9"
    },
    minute: {
      label: "L{TimePicker.minute}",
      type: "number",
      min: 0,
      max: 59,
      highlightExternalChange: false,
      format: "2>9"
    },
    second: {
      hidden: true,
      label: "L{TimePicker.second}",
      type: "number",
      min: 0,
      max: 59,
      highlightExternalChange: false,
      format: "2>9"
    },
    amButton: {
      type: "button",
      text: "AM",
      toggleGroup: "am-pm",
      cls: "b-blue",
      onClick: "up.onAmPmButtonClick"
    },
    pmButton: {
      type: "button",
      text: "PM",
      toggleGroup: "am-pm",
      cls: "b-blue",
      onClick: "up.onAmPmButtonClick"
    }
  },
  autoShow: false,
  trapFocus: true,
  seconds: null,
  value: {
    $config: {
      equal: "date"
    },
    value: null
  },
  format: null,
  max: null,
  min: null,
  initialValue: null
});
TimePicker.initClass();
TimePicker._$name = "TimePicker";
var TimeField = class extends PickerField {
  static get $name() {
    return "TimeField";
  }
  static get type() {
    return "timefield";
  }
  static get alias() {
    return "time";
  }
  static get configurable() {
    return {
      picker: {
        type: "timepicker",
        align: {
          align: "t0-b0",
          axisLock: true
        }
      },
      format: "LT",
      triggers: {
        expand: {
          align: "end",
          handler: "onTriggerClick",
          compose: () => ({
            children: [{
              class: {
                "b-icon-clock-live": 1
              }
            }]
          })
        },
        back: {
          align: "start",
          cls: "b-icon b-icon-angle-left b-step-trigger",
          key: "Shift+ArrowDown",
          handler: "onBackClick"
        },
        forward: {
          align: "end",
          cls: "b-icon b-icon-angle-right b-step-trigger",
          key: "Shift+ArrowUp",
          handler: "onForwardClick"
        }
      },
      min: null,
      max: null,
      step: "5m",
      stepTriggers: null,
      value: null,
      keepDate: false
    };
  }
  changePicker(picker, oldPicker) {
    const me = this;
    return TimePicker.reconfigure(oldPicker, picker, {
      owner: me,
      defaults: {
        value: me.value,
        forElement: me[me.pickerAlignElement],
        owner: me,
        align: {
          anchor: me.overlayAnchor,
          target: me[me.pickerAlignElement]
        },
        onTimeChange({
          time
        }) {
          me._isUserAction = true;
          me.value = time;
          me._isUserAction = false;
        }
      }
    });
  }
  onBackClick() {
    const me = this, {
      min: min2
    } = me;
    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, -1 * me.step.magnitude, me.step.unit);
      if (!min2 || min2.getTime() <= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  onForwardClick() {
    const me = this, {
      max
    } = me;
    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, me.step.magnitude, me.step.unit);
      if (!max || max.getTime() >= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  get isValid() {
    const me = this;
    me.clearError("L{Field.minimumValueViolation}", true);
    me.clearError("L{Field.maximumValueViolation}", true);
    let value = me.value;
    if (value) {
      value = value.getTime();
      if (me._min && me._min.getTime() > value) {
        me.setError("L{Field.minimumValueViolation}", true);
        return false;
      }
      if (me._max && me._max.getTime() < value) {
        me.setError("L{Field.maximumValueViolation}", true);
        return false;
      }
    }
    return super.isValid;
  }
  hasChanged(oldValue, newValue) {
    if (oldValue !== null && oldValue !== void 0 && oldValue.getTime && newValue !== null && newValue !== void 0 && newValue.getTime) {
      return oldValue.getHours() !== newValue.getHours() || oldValue.getMinutes() !== newValue.getMinutes() || oldValue.getSeconds() !== newValue.getSeconds() || oldValue.getMilliseconds() !== newValue.getMilliseconds();
    }
    return super.hasChanged(oldValue, newValue);
  }
  showPicker() {
    const me = this, {
      picker,
      value
    } = me;
    if (me.readOnly) {
      return;
    }
    picker.value = value;
    picker.format = me.format;
    picker.maxTime = me.max;
    picker.minTime = me.min;
    if (!value) {
      me.value = picker.value;
    }
    super.showPicker(true);
  }
  onPickerShow() {
    var _this$pickerKeyDownRe;
    super.onPickerShow();
    this.pickerKeyDownRemover = (_this$pickerKeyDownRe = this.pickerKeyDownRemover) === null || _this$pickerKeyDownRe === void 0 ? void 0 : _this$pickerKeyDownRe.call(this);
  }
  focusPicker() {
    this.picker.focus();
  }
  transformTimeValue(value) {
    if (value != null) {
      if (typeof value === "string") {
        value = DateHelper.parse(value, this.format);
        if (this.keepDate) {
          value = DateHelper.copyTimeValues(new Date(this.value), value);
        }
      } else {
        value = new Date(value);
      }
      if (DateHelper.isValidDate(value)) {
        if (!this.keepDate) {
          return DateHelper.getTime(value);
        } else {
          return value;
        }
      }
    }
    return null;
  }
  changeMin(value) {
    return this.transformTimeValue(value);
  }
  updateMin(value) {
    const {
      input
    } = this;
    if (input) {
      if (value == null) {
        input.removeAttribute("min");
      } else {
        input.min = value;
      }
    }
    this.syncInvalid();
  }
  changeMax(value) {
    return this.transformTimeValue(value);
  }
  updateMax(value) {
    const {
      input
    } = this;
    if (input) {
      if (value == null) {
        input.removeAttribute("max");
      } else {
        input.max = value;
      }
    }
    this.syncInvalid();
  }
  changeValue(value, was) {
    const me = this, newValue = me.transformTimeValue(value);
    if (value && !newValue || me.isRequired && value === "") {
      me.setError("L{invalidTime}");
      return;
    }
    me.clearError("L{invalidTime}");
    if (me.hasChanged(was, newValue)) {
      return super.changeValue(newValue, was);
    }
    if (!me.inputting) {
      me.syncInputFieldValue(true);
    }
  }
  updateValue(value, was) {
    const {
      expand
    } = this.triggers;
    if (expand && value) {
      expand.element.firstElementChild.style.animationDelay = -((value.getHours() * 60 + value.getMinutes()) / 10) + "s";
    }
    super.updateValue(value, was);
  }
  changeStep(value, was) {
    var _value, _value2;
    const type = typeof value;
    if (!value) {
      return null;
    }
    if (type === "number") {
      value = {
        magnitude: Math.abs(value),
        unit: was ? was.unit : "hour"
      };
    } else if (type === "string") {
      value = DateHelper.parseDuration(value);
    }
    if ((_value = value) !== null && _value !== void 0 && _value.unit && (_value2 = value) !== null && _value2 !== void 0 && _value2.magnitude) {
      if (value.magnitude < 0) {
        value = {
          magnitude: -value.magnitude,
          unit: value.unit
        };
      }
      return value;
    }
  }
  updateStep(value) {
    this.element.classList[value ? "remove" : "add"]("b-no-steppers");
    this.syncInvalid();
  }
  updateFormat() {
    this.syncInputFieldValue(true);
  }
  get inputValue() {
    return DateHelper.format(this.value, this.format);
  }
  updateLocalization() {
    super.updateLocalization();
    this.syncInputFieldValue(true);
  }
};
TimeField.initClass();
TimeField._$name = "TimeField";
var DateTimeField = class extends Field {
  doDestroy() {
    this.dateField.destroy();
    this.timeField.destroy();
    super.doDestroy();
  }
  get focusElement() {
    return this.dateField.input;
  }
  get innerElements() {
    return [this.dateField.element, this.timeField.element];
  }
  internalOnKeyEvent() {
  }
  updateRevertOnEscape(revertOnEscape) {
    this.timeField.revertOnEscape = revertOnEscape;
    this.dateField.revertOnEscape = revertOnEscape;
  }
  changeTimeField(config) {
    const me = this, result = TimeField.new({
      revertOnEscape: me.revertOnEscape,
      syncInvalid(...args) {
        const updatingInvalid = me.updatingInvalid;
        TimeField.prototype.syncInvalid.apply(this, args);
        me.timeField && !updatingInvalid && me.syncInvalid();
      }
    }, config);
    EventHelper.on({
      element: result.element,
      keydown: "onTimeFieldKeyDown",
      thisObj: me
    });
    if (me.readOnly) {
      result.readOnly = true;
    }
    return result;
  }
  updateTimeField(timeField) {
    const me = this;
    timeField.ion({
      change({
        userAction,
        value
      }) {
        if (userAction && !me.$settingValue) {
          const dateAndTime = me.dateField.value;
          me._isUserAction = true;
          me.value = dateAndTime ? DateHelper.copyTimeValues(dateAndTime, value) : null;
          me._isUserAction = false;
        }
      },
      thisObj: me
    });
  }
  changeDateField(config) {
    const me = this, type = (config === null || config === void 0 ? void 0 : config.type) || "datefield", cls = Widget.resolveType(config.type || "datefield"), result = Widget.create(ObjectHelper.assign({
      type,
      revertOnEscape: me.revertOnEscape,
      syncInvalid(...args) {
        const updatingInvalid = me.updatingInvalid;
        cls.prototype.syncInvalid.apply(this, args);
        me.dateField && !updatingInvalid && me.syncInvalid();
      }
    }, config));
    EventHelper.on({
      element: result.element,
      keydown: "onDateFieldKeyDown",
      thisObj: me
    });
    if (me.readOnly) {
      result.readOnly = true;
    }
    result.ion({
      keydown: ({
        event
      }) => {
        var _this$timeField;
        if (event.key === "Tab" && !event.shiftKey && (_this$timeField = this.timeField) !== null && _this$timeField !== void 0 && _this$timeField.isVisible) {
          event.stopPropagation();
          event.cancelBubble = true;
        }
      }
    });
    return result;
  }
  get childItems() {
    return [this.dateField, this.timeField];
  }
  updateDateField(dateField) {
    const me = this;
    dateField.ion({
      change({
        userAction,
        value
      }) {
        if (userAction && !me.$isInternalChange) {
          me._isUserAction = true;
          if (!me.timeField.value) {
            me.timeField.value = value;
          } else if (value) {
            DateHelper.copyTimeValues(value, me.timeField.value);
          }
          me.value = value;
          me._isUserAction = false;
        }
      },
      thisObj: me
    });
  }
  updateWeekStartDay(weekStartDay) {
    if (this.dateField) {
      this.dateField.weekStartDay = weekStartDay;
    }
  }
  changeWeekStartDay(value) {
    var _this$dateField$weekS, _this$dateField;
    return typeof value === "number" ? value : (_this$dateField$weekS = (_this$dateField = this.dateField) === null || _this$dateField === void 0 ? void 0 : _this$dateField.weekStartDay) !== null && _this$dateField$weekS !== void 0 ? _this$dateField$weekS : DateHelper.weekStartDay;
  }
  syncInputFieldValue(skipHighlight = this.isConfiguring) {
    super.syncInputFieldValue(true);
    const me = this, {
      dateField,
      timeField
    } = me, highlightDate = dateField.highlightExternalChange, highlightTime = timeField.highlightExternalChange;
    if (!skipHighlight && !me.highlightExternalChange) {
      skipHighlight = true;
    }
    me.$isInternalChange = true;
    dateField.highlightExternalChange = false;
    dateField.value = null;
    dateField.highlightExternalChange = highlightDate;
    if (skipHighlight) {
      timeField.highlightExternalChange = dateField.highlightExternalChange = false;
    }
    timeField.value = dateField.value = me.inputValue;
    dateField.highlightExternalChange = highlightDate;
    timeField.highlightExternalChange = highlightTime;
    me.$isInternalChange = false;
    me.syncInvalid();
  }
  onTimeFieldKeyDown(e) {
    const me = this;
    if (e.key === "Enter" || e.key === "Tab") {
      const dateAndTime = me.dateField.value;
      me._isUserAction = true;
      me.value = dateAndTime ? DateHelper.copyTimeValues(dateAndTime, me.timeField.value) : null;
      me._isUserAction = false;
    }
  }
  onDateFieldKeyDown(e) {
    const me = this;
    if (e.key === "Tab" && !e.shiftKey) {
      e.stopPropagation();
      e.preventDefault();
      me.timeField.focus();
    } else if (e.key === "Enter") {
      me.value = me.dateField.value;
    }
  }
  updateRequired(required, was) {
    this.timeField.required = this.dateField.required = required;
  }
  updateReadOnly(readOnly, was) {
    super.updateReadOnly(readOnly, was);
    if (!this.isConfiguring) {
      this.timeField.readOnly = this.dateField.readOnly = readOnly;
    }
  }
  onDisabled(value) {
    this.timeField.disabled = this.dateField.disabled = value;
  }
  focus() {
    this.dateField.focus();
  }
  hasChanged(oldValue, newValue) {
    return !DateHelper.isEqual(oldValue, newValue);
  }
  get isValid() {
    return this.timeField.isValid && this.dateField.isValid;
  }
  setError(error, silent) {
    [this.dateField, this.timeField].forEach((f) => f.setError(error, silent));
  }
  getErrors() {
    const errors = [...this.dateField.getErrors() || [], ...this.timeField.getErrors() || []];
    return errors.length ? errors : null;
  }
  clearError(error, silent) {
    [this.dateField, this.timeField].forEach((f) => f.clearError(error, silent));
  }
  updateInvalid() {
    this.updatingInvalid = true;
    [this.dateField, this.timeField].forEach((f) => f.updateInvalid());
    this.updatingInvalid = false;
  }
};
_defineProperty(DateTimeField, "configurable", {
  timeField: {},
  dateField: {
    keepTime: true,
    step: "1 d"
  },
  weekStartDay: null,
  inputTemplate: () => "",
  ariaElement: "element"
});
_defineProperty(DateTimeField, "$name", "DateTimeField");
_defineProperty(DateTimeField, "type", "datetimefield");
_defineProperty(DateTimeField, "alias", "datetime");
DateTimeField.initClass();
DateTimeField._$name = "DateTimeField";
var DurationField = class extends TextField {
  static get $name() {
    return "DurationField";
  }
  static get type() {
    return "durationfield";
  }
  static get alias() {
    return "duration";
  }
  static get defaultConfig() {
    return {
      value: null,
      step: 1,
      unit: null,
      defaultUnit: "day",
      magnitude: null,
      useAbbreviation: false,
      allowNegative: false,
      decimalPrecision: null,
      triggers: {
        spin: {
          type: "spintrigger"
        }
      },
      nullValue: null
    };
  }
  static get configurable() {
    return {
      min: null,
      max: null,
      allowedUnits: null
    };
  }
  changeMin(value) {
    return typeof value === "string" ? new Duration(value) : value;
  }
  changeMax(value) {
    return typeof value === "string" ? new Duration(value) : value;
  }
  changeAllowedUnits(units) {
    if (typeof units === "string") {
      units = units.split(",");
    }
    return units;
  }
  updateAllowedUnits(units) {
    this.allowedUnitsRe = new RegExp(`(${units.join("|")})`, "i");
  }
  get inputValue() {
    return this.value == null ? "" : this.calcValue(true).toString(this.useAbbreviation);
  }
  set unit(unit) {
    this._unit = unit;
    this.value = this.calcValue();
  }
  get unit() {
    return this._unit;
  }
  get unitWithDefault() {
    return this._unit || DurationField.defaultConfig.defaultUnit;
  }
  set magnitude(magnitude) {
    this.clearError("L{invalidUnit}");
    this._magnitude = magnitude;
    super.value = this.calcValue();
  }
  get magnitude() {
    return this._magnitude;
  }
  roundMagnitude(value) {
    return value && this.decimalPrecision != null ? ObjectHelper.round(value, this.decimalPrecision) : value;
  }
  get allowDecimals() {
    return this.decimalPrecision !== 0;
  }
  get isValid() {
    const me = this, isEmpty = me.value == null || me.value && me.value.magnitude == null;
    return super.isValid && (isEmpty && !me.required || !isEmpty && (me.allowNegative || me.value.magnitude >= 0));
  }
  internalOnChange(event) {
    const me = this, value = me.value, oldVal = me._lastValue;
    if (me.hasChanged(oldVal, value)) {
      me._lastValue = value;
      me.triggerFieldChange({
        value,
        event,
        userAction: true,
        valid: me.isValid
      });
    }
  }
  onFocusOut(e) {
    var _this$triggers, _this$triggers$spin, _this$triggers$spin$c;
    this.syncInputFieldValue(true);
    (_this$triggers = this.triggers) === null || _this$triggers === void 0 ? void 0 : (_this$triggers$spin = _this$triggers.spin) === null || _this$triggers$spin === void 0 ? void 0 : (_this$triggers$spin$c = _this$triggers$spin.clickRepeater) === null || _this$triggers$spin$c === void 0 ? void 0 : _this$triggers$spin$c.cancel();
    return super.onFocusOut(e);
  }
  set value(value) {
    const me = this;
    let newMagnitude, newUnit;
    this.clearError("L{invalidUnit}");
    if (typeof value === "number") {
      newMagnitude = value;
      newUnit = me._unit;
    } else if (typeof value === "string") {
      if (/^\s*$/.test(value)) {
        newMagnitude = null;
      } else {
        const parsedDuration = DateHelper.parseDuration(value, me.allowDecimals, me.unitWithDefault);
        if (parsedDuration) {
          if (!me.allowedUnitsRe || me.allowedUnitsRe.test(parsedDuration.unit)) {
            newUnit = parsedDuration.unit;
            newMagnitude = parsedDuration.magnitude;
          } else {
            me.setError("L{invalidUnit}");
          }
        }
      }
    } else {
      if (value && "unit" in value && "magnitude" in value) {
        newUnit = value.unit;
        newMagnitude = value.magnitude;
      } else {
        newUnit = null;
        newMagnitude = null;
      }
    }
    if (me._magnitude !== newMagnitude || me._unit != newUnit) {
      me._magnitude = newMagnitude;
      if (newUnit) {
        me._unit = newUnit;
      }
      super.value = me.calcValue();
    }
  }
  okMax(value) {
    if (typeof value === "number") {
      value = new Duration({
        unit: this.unitWithDefault,
        magnitude: value
      });
    }
    return this.max == null || value <= this.max;
  }
  okMin(value) {
    if (typeof value === "number") {
      value = new Duration({
        unit: this.unitWithDefault,
        magnitude: value
      });
    }
    return this.min == null || value >= this.min;
  }
  get validity() {
    const value = this.value, validity = {};
    if (value != null) {
      validity.rangeUnderflow = !this.okMin(value);
      validity.rangeOverflow = !this.okMax(value);
    }
    validity.valid = !validity.rangeUnderflow && !validity.rangeOverflow;
    return validity;
  }
  get value() {
    return super.value;
  }
  calcValue(round2 = false) {
    const me = this;
    if ((!me._unit || me._magnitude == null) && me.clearable) {
      return null;
    } else {
      return new Duration(round2 ? this.roundMagnitude(me._magnitude) : this._magnitude, me.unitWithDefault);
    }
  }
  hasChanged(oldValue, newValue) {
    return newValue && !oldValue || !newValue && oldValue || newValue && oldValue && !oldValue.isEqual(newValue);
  }
  get milliseconds() {
    return this.value ? this.value.milliseconds : 0;
  }
  onInternalKeyDown(keyEvent) {
    if (keyEvent.key === "ArrowUp") {
      this.doSpinUp();
    } else if (keyEvent.key === "ArrowDown") {
      this.doSpinDown();
    }
  }
  doSpinUp() {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.magnitude || 0) + me.step;
    me._isUserAction = true;
    if (!me.okMin(newValue)) {
      newValue = me.min;
    }
    if (me.okMax(newValue)) {
      me.value = newValue;
    }
    me._isUserAction = false;
  }
  doSpinDown() {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.magnitude || 0) - me.step;
    if (!me.okMax(newValue)) {
      newValue = me.max;
    }
    if (me.okMin(newValue) && (me.allowNegative || (me.magnitude || 0) > 0)) {
      me._isUserAction = true;
      me.value = newValue;
      me._isUserAction = false;
    }
  }
};
DurationField.initClass();
DurationField._$name = "DurationField";
var Fit = class extends Layout {
};
_defineProperty(Fit, "$name", "Fit");
_defineProperty(Fit, "type", "fit");
_defineProperty(Fit, "configurable", {
  containerCls: "b-fit-container",
  itemCls: "b-fit-item"
});
Fit.initClass();
Fit._$name = "Fit";
var Editor = class extends Container {
  afterConfigure() {
    const me = this;
    super.afterConfigure();
    me.onTargetSizeChange = me.onTargetSizeChange.bind(me);
    EventHelper.on({
      element: me.element,
      keydown: "onKeyDown",
      contextmenu: "stopMouseEvents",
      mousedown: "stopMouseEvents",
      mouseover: "stopMouseEvents",
      mouseout: "stopMouseEvents",
      mouseup: "stopMouseEvents",
      click: "stopMouseEvents",
      dblclick: "stopMouseEvents",
      thisObj: me
    });
    me.ion({
      beforeHide: "beforeEditorHide",
      hide: "afterEditorHide",
      thisObj: me
    });
    LocaleManagerSingleton.ion({
      locale: "onLocaleChange",
      thisObj: me
    });
  }
  onLocaleChange() {
    const {
      inputField
    } = this;
    if (inputField && !inputField.isDestroyed) {
      if (inputField.syncInputFieldValue) {
        inputField.syncInputFieldValue(true);
      }
    }
  }
  render(renderTo) {
    const oldParent = this.element.parentNode, [parentElement] = this.getRenderContext(this, renderTo);
    parentElement.classList.add("b-editing");
    super.render(...arguments);
    if (oldParent !== null && oldParent !== void 0 && oldParent.classList && parentElement !== oldParent) {
      oldParent.classList.remove("b-editing");
    }
  }
  async startEdit(editObject) {
    const me = this;
    editObject = ObjectHelper.assignIf(editObject, {
      align: me.align,
      hideTarget: me.hideTarget,
      matchSize: me.matchSize,
      matchFont: me.matchFont,
      fitTargetContent: me.fitTargetContent,
      focus: true
    });
    if (me.trigger("beforeStart", editObject) !== false) {
      var _inputField$clearErro, _inputField$focus, _inputField$value$;
      const {
        target,
        hideTarget,
        matchSize,
        matchFont,
        fitTargetContent,
        record,
        field = me.inputField.name,
        focus
      } = editObject, {
        inputField
      } = me, {
        input
      } = inputField, targetFontSize = DomHelper.getStyleValue(target, "font-size"), targetFontFamily = DomHelper.getStyleValue(target, "font-family");
      let {
        value,
        align
      } = editObject;
      if (record && field) {
        me.record = record;
        me.dataField = field;
        if (value === void 0) {
          value = record[field];
        }
      }
      if (matchSize) {
        if (target instanceof HTMLElement) {
          me.updateSize(target, matchSize);
        }
        if (target instanceof HTMLElement) {
          ResizeMonitor.addResizeListener(target, me.onTargetSizeChange);
        }
      }
      if (input) {
        if (matchFont) {
          input.style.fontSize = targetFontSize;
          input.style.fontFamily = targetFontFamily;
        } else {
          input.style.fontSize = input.style.fontFamily = "";
        }
      }
      me.assigningValues = true;
      (_inputField$clearErro = inputField.clearError) === null || _inputField$clearErro === void 0 ? void 0 : _inputField$clearErro.call(inputField);
      inputField.value = value;
      me.assigningValues = false;
      if (typeof align === "string") {
        align = {
          align
        };
      }
      await me.showBy(_objectSpread2({
        target,
        allowTargetOut: true
      }, align));
      if (fitTargetContent) {
        const overflow = input.scrollWidth - input.clientWidth;
        if (overflow > 0) {
          me.width += overflow + DomHelper.scrollBarWidth;
        }
      }
      focus && ((_inputField$focus = inputField.focus) === null || _inputField$focus === void 0 ? void 0 : _inputField$focus.call(inputField));
      if (target.nodeType === Element.ELEMENT_NODE) {
        if (hideTarget) {
          target.classList.add("b-hide-visibility");
        }
      }
      me.editing = true;
      me.trigger("start", {
        value: inputField.value
      });
      if (Array.isArray(inputField.value) && inputField.editingRecords && (_inputField$value$ = inputField.value[0]) !== null && _inputField$value$ !== void 0 && _inputField$value$.isModel) {
        me.oldValue = inputField.value.map((record2) => record2.copy(record2.id));
      } else {
        me.oldValue = inputField.value;
        if (Array.isArray(me.oldValue)) {
          me.oldValue = me.oldValue.slice();
        }
      }
      inputField.initialValue = me.oldValue;
      return true;
    }
    return false;
  }
  refreshEdit() {
    if (this.isVisible) {
      const {
        record,
        dataField,
        inputField
      } = this;
      if (record && dataField) {
        const value = record[dataField];
        if (!ObjectHelper.isEqual(inputField.value, value)) {
          inputField.value = value;
        }
      }
    }
  }
  finishEdit() {
    const {
      target,
      aligningToElement
    } = this.lastAlignSpec;
    if (aligningToElement) {
      target.classList.remove("b-editing");
      target.classList.remove("b-hide-visibility");
    }
    this.editing = false;
    this.trigger("finishEdit");
  }
  onKeyDown(event) {
    var _me$trigger;
    const me = this;
    switch (event.key) {
      case me.completeKey:
        me.completeEdit(null, event);
        event.stopImmediatePropagation();
        break;
      case me.cancelKey:
        me.cancelEdit(event);
        event.stopImmediatePropagation();
        break;
    }
    (_me$trigger = me.trigger) === null || _me$trigger === void 0 ? void 0 : _me$trigger.call(me, "keydown", {
      event
    });
  }
  stopMouseEvents(e) {
    if (!this.allowMouseEvents) {
      e.stopPropagation();
    }
  }
  onFocusOut(event) {
    super.onFocusOut(event);
    const me = this;
    if (!me.isFinishing && me.editing) {
      switch (me.blurAction) {
        case "cancel":
          me.cancelEdit(event);
          break;
        case "complete":
          me.completeEdit(null, event);
      }
    }
  }
  async completeEdit(finalize, triggeredByEvent) {
    const me = this, {
      inputField,
      oldValue,
      record
    } = me, invalidAction = inputField.invalidAction || (inputField.allowInvalid === false ? "block" : me.invalidAction), {
      value
    } = inputField;
    if (!me.isVisible) {
      return;
    }
    if (!inputField.isValid && invalidAction !== "allow") {
      if (invalidAction === "block") {
        var _inputField$focus2;
        (_inputField$focus2 = inputField.focus) === null || _inputField$focus2 === void 0 ? void 0 : _inputField$focus2.call(inputField);
        return false;
      } else if (invalidAction === "revert") {
        me.cancelEdit(triggeredByEvent);
        return true;
      }
    } else if (ObjectHelper.isEqual(value, oldValue)) {
      me.cancelEdit(triggeredByEvent);
      return true;
    } else {
      const context = {
        inputField,
        record,
        value,
        oldValue
      };
      if (me.trigger("beforeComplete", context) === false) {
        var _inputField$focus3;
        (_inputField$focus3 = inputField.focus) === null || _inputField$focus3 === void 0 ? void 0 : _inputField$focus3.call(inputField);
      } else {
        if (!finalize) {
          var _context$editorContex;
          finalize = context.finalize || ((_context$editorContex = context.editorContext) === null || _context$editorContex === void 0 ? void 0 : _context$editorContex.finalize);
        }
        if (finalize) {
          let result = await finalize(context);
          if (result === true) {
            me.onEditComplete();
          } else {
            if (inputField.setError) {
              const error = result || inputField.invalidValueError, clearError = () => {
                listeners();
                inputField.clearError(error);
              }, listeners = inputField.ion({
                change: clearError,
                input: clearError
              });
              inputField.setError(error);
            }
            if (invalidAction === "block") {
              var _inputField$focus4;
              (_inputField$focus4 = inputField.focus) === null || _inputField$focus4 === void 0 ? void 0 : _inputField$focus4.call(inputField);
            } else if (invalidAction === "revert") {
              inputField.value = oldValue;
              result = true;
            }
            result = false;
          }
          return result;
        } else {
          me.onEditComplete();
          return true;
        }
      }
    }
    return false;
  }
  cancelEdit(triggeredByEvent) {
    const me = this, {
      inputField,
      oldValue
    } = me, {
      value
    } = inputField;
    if (me.editing && !me.isFinishing && me.trigger("beforeCancel", {
      value,
      oldValue,
      event: triggeredByEvent
    }) !== false) {
      me.isFinishing = true;
      me.hide();
      me.trigger("cancel", {
        value,
        oldValue,
        event: triggeredByEvent
      });
      me.finishEdit();
      me.isFinishing = false;
    }
  }
  onEditComplete() {
    const me = this, {
      record,
      dataField,
      inputField,
      oldValue
    } = me, {
      value
    } = inputField;
    if (!me.isFinishing) {
      me.isFinishing = true;
      me.hide();
      if (record) {
        const setterName = `set${StringHelper.capitalize(dataField)}`;
        if (record[setterName]) {
          record[setterName](value);
        } else if (dataField.includes(".")) {
          record.set(dataField, value);
        } else {
          record[dataField] = value;
        }
      }
      me.trigger("complete", {
        value,
        oldValue
      });
      me.finishEdit();
      me.isFinishing = false;
    }
  }
  doDestroy() {
    if (this.createdInputField) {
      this.inputField.destroy();
    }
    super.doDestroy();
  }
  set owner(owner) {
    this._owner = owner;
  }
  get owner() {
    return this._owner || Widget.fromElement(this.element.parentNode);
  }
  changeInputField(inputField, oldInputField) {
    const me = this;
    if (oldInputField) {
      oldInputField.destroy();
    }
    if (typeof inputField === "string") {
      inputField = {
        type: inputField
      };
    }
    if (!(inputField instanceof Widget)) {
      inputField = Widget.create(inputField);
      me.createdInputField = true;
    }
    if (me.completeOnChange) {
      inputField.ion({
        change: "onInputFieldChange",
        thisObj: me
      });
    }
    inputField.parent = me;
    return inputField;
  }
  updateInputField(inputField) {
    this.removeAll();
    this.add(inputField);
  }
  get inputField() {
    return this.items[0];
  }
  onInputFieldChange() {
    if (this.containsFocus) {
      this.completeEdit();
    }
  }
  onTargetSizeChange(resizedElement, oldRect, newRect) {
    if (oldRect && newRect) {
      this.updateSize(resizedElement);
    }
  }
  updateSize(targetEl, matchSize = this.lastMatchSize) {
    const me = this, rect = Rectangle.inner(targetEl);
    me.width = matchSize.width === false ? "auto" : rect.width - me.align.offset[0];
    me.height = matchSize.height === false ? "auto" : rect.height;
    me.lastMatchSize = matchSize;
  }
  beforeEditorHide() {
    if (this.editing && !this.isFinishing) {
      this.cancelEdit();
      return false;
    }
  }
  afterEditorHide() {
    if (this.positioned) {
      this.element.remove();
    }
    ResizeMonitor.removeResizeListener(this.lastAlignSpec.target, this.onTargetSizeChange);
  }
};
_defineProperty(Editor, "$name", "Editor");
_defineProperty(Editor, "type", "editor");
_defineProperty(Editor, "configurable", {
  positioned: true,
  hidden: true,
  layout: "fit",
  align: {
    align: "t0-t0",
    offset: [0, 0]
  },
  hideTarget: false,
  matchSize: true,
  matchFont: true,
  fitTargetContent: false,
  inputField: "textfield",
  blurAction: "complete",
  completeKey: "Enter",
  cancelKey: "Escape",
  invalidAction: "block",
  completeOnChange: null,
  isolateFields: true
});
Editor.initClass();
Editor._$name = "Editor";
var SUPPORTED_FIELD_DATA_TYPES = ["number", "boolean", "string", "date", "duration"];
var isSupportedDurationField = (field) => {
  var _field$column;
  return ((_field$column = field.column) === null || _field$column === void 0 ? void 0 : _field$column.type) === "duration";
};
var EMPTY_STRING = "";
var FieldFilterPicker = class extends Container {
  static get $name() {
    return "FieldFilterPicker";
  }
  static get type() {
    return "fieldfilterpicker";
  }
  static get defaultValueFieldPlaceholders() {
    return {
      string: "L{enterAValue}",
      number: "L{enterANumber}",
      date: "L{selectADate}",
      list: "L{selectOneOrMoreValues}",
      duration: "L{enterAValue}"
    };
  }
  afterConstruct() {
    const me = this;
    if (!me._fields) {
      throw new Error(`${FieldFilterPicker.name} requires 'fields' to be configured.`);
    }
    if (!me._filter) {
      throw new Error(`${FieldFilterPicker.name} requires 'filter' to be configured.`);
    }
    super.afterConstruct();
    const {
      widgetMap: {
        propertyPicker,
        operatorPicker,
        caseSensitive
      }
    } = me;
    propertyPicker.ion({
      select: "onPropertySelect",
      thisObj: me
    });
    operatorPicker.ion({
      select: "onOperatorSelect",
      thisObj: me
    });
    caseSensitive.ion({
      change: "onCaseSensitiveChange",
      thisObj: me
    });
    me.propertyFieldConfig && propertyPicker.setConfig(me.propertyFieldConfig);
    me.operatorFieldConfig && operatorPicker.setConfig(me.operatorFieldConfig);
    propertyPicker.cls = me.allPropertyPickerClasses;
    operatorPicker.cls = me.allOperatorPickerClasses;
    me.populateUIFromFilter();
  }
  changeDateFormat(dateFormat) {
    return this.L(dateFormat);
  }
  get allChildInputs() {
    const {
      propertyPicker,
      operatorPicker,
      caseSensitive
    } = this.widgetMap;
    return [propertyPicker, operatorPicker, ...this.valueFields, caseSensitive];
  }
  updateDisabled(newDisabled) {
    this.allChildInputs.forEach((field) => field.disabled = newDisabled);
  }
  updateReadOnly(newReadOnly) {
    const {
      propertyPicker,
      operatorPicker
    } = this.widgetMap;
    this.allChildInputs.forEach((field) => field.readOnly = newReadOnly);
    propertyPicker.readOnly = propertyPicker.readOnly || newReadOnly;
    operatorPicker.readOnly = operatorPicker.readOnly || newReadOnly;
  }
  updatePropertyLocked(newPropertyLocked) {
    this.widgetMap.propertyPicker.readOnly = newPropertyLocked || this.readOnly;
    this.widgetMap.propertyPicker.cls = this.allPropertyPickerClasses;
  }
  updateOperatorLocked(newOperatorLocked) {
    this.widgetMap.operatorPicker.readOnly = newOperatorLocked || this.readOnly;
    this.widgetMap.operatorPicker.cls = this.allOperatorPickerClasses;
  }
  changeOperators(newOperators) {
    const operators = newOperators !== null && newOperators !== void 0 ? newOperators : FieldFilterPicker.defaultOperators;
    return Object.keys(operators).reduce((outOperators, dataType) => _objectSpread2(_objectSpread2({}, outOperators), {}, {
      [dataType]: operators[dataType].map((op) => _objectSpread2(_objectSpread2({}, op), {}, {
        text: this.L(op.text)
      }))
    }), {});
  }
  changeFields(newFields) {
    let fields = newFields;
    if (Array.isArray(newFields)) {
      VersionHelper.deprecate("Core", "6.0.0", "FieldOption[] deprecated, use Object<String, FieldOption> keyed by field name instead");
      fields = ArrayHelper.keyBy(fields, "name");
    }
    return fields;
  }
  get isMultiSelectValueField() {
    var _this$_filter;
    return ["isIncludedIn", "isNotIncludedIn"].includes((_this$_filter = this._filter) === null || _this$_filter === void 0 ? void 0 : _this$_filter.operator);
  }
  get allPropertyPickerClasses() {
    var _this$propertyFieldCo;
    return new DomClassList(`b-${FieldFilterPicker.type}-property`, (_this$propertyFieldCo = this.propertyFieldConfig) === null || _this$propertyFieldCo === void 0 ? void 0 : _this$propertyFieldCo.cls, {
      [`b-${FieldFilterPicker.type}-combo-locked`]: this.propertyLocked
    });
  }
  get allOperatorPickerClasses() {
    var _this$operatorFieldCo;
    return new DomClassList(`b-${FieldFilterPicker.type}-operator`, (_this$operatorFieldCo = this.operatorFieldConfig) === null || _this$operatorFieldCo === void 0 ? void 0 : _this$operatorFieldCo.cls, {
      [`b-${FieldFilterPicker.type}-combo-locked`]: this.operatorLocked
    });
  }
  getValueFieldConfigs() {
    const me = this, {
      valueFieldCls,
      fieldType,
      _filter: {
        operator
      },
      onValueChange,
      filterValues,
      isMultiSelectValueField,
      operatorArgCount,
      getValueFieldConfig
    } = me, valueFieldPlaceholders = ObjectHelper.merge({}, FieldFilterPicker.defaultValueFieldPlaceholders, me.valueFieldPlaceholders);
    if (!fieldType || !operator || operatorArgCount === 0) {
      return [];
    }
    let valueFieldCfg = {
      type: "textfield",
      listeners: {
        change: onValueChange,
        input: onValueChange,
        thisObj: me
      },
      cls: valueFieldCls,
      dataset: {
        type: fieldType
      },
      placeholder: me.L(valueFieldPlaceholders[isMultiSelectValueField ? "list" : fieldType])
    };
    if (isMultiSelectValueField) {
      valueFieldCfg = _objectSpread2(_objectSpread2({}, valueFieldCfg), {}, {
        type: "combo",
        multiSelect: true,
        createOnUnmatched: true,
        items: this.getUniqueDataValues(filterValues),
        value: filterValues !== null && filterValues !== void 0 ? filterValues : []
      });
    } else if (["number", "date", "boolean"].includes(fieldType)) {
      valueFieldCfg.type = `${fieldType}field`;
    } else if (fieldType === "duration") {
      valueFieldCfg.type = "durationfield";
    }
    if (getValueFieldConfig) {
      valueFieldCfg = me.callback(getValueFieldConfig, me, [me.filter, valueFieldCfg]);
    }
    if (isMultiSelectValueField) {
      return [valueFieldCfg];
    }
    return ArrayHelper.populate(operatorArgCount, (index) => [{
      type: "widget",
      tag: "div",
      cls: `b-${FieldFilterPicker.type}-value-separator`,
      content: me.L("L{FieldFilterPicker.and}")
    }, _objectSpread2(_objectSpread2({}, valueFieldCfg), {}, {
      value: filterValues[index]
    })]).flat().slice(1);
  }
  getUniqueDataValues(extraValuesToInclude = []) {
    var _me$_filter;
    const me = this, {
      fieldType
    } = me;
    if (!me.store || !((_me$_filter = me._filter) !== null && _me$_filter !== void 0 && _me$_filter.property)) {
      return [];
    }
    const {
      relatedDisplayField
    } = me.selectedField;
    let values, sortedValues;
    if (me.fieldIsRelation) {
      const {
        foreignStore
      } = me.currentPropertyRelationConfig;
      if (relatedDisplayField) {
        values = foreignStore.allRecords.reduce((options, record) => {
          if (record.id != null) {
            options.push({
              text: record[relatedDisplayField],
              value: record.id
            });
          }
          return options;
        }, []);
        sortedValues = values.sort((a, b) => me.sortStrings(a.text, b.text));
      } else {
        values = foreignStore.allRecords.map((record) => record.id);
      }
    } else {
      values = me.store.allRecords.map((record) => record[me._filter.property]);
    }
    if (!sortedValues) {
      values.push(...extraValuesToInclude);
      const uniqueValues = ArrayHelper.unique(values.reduce((primitiveValues, value) => {
        if (value != null && String(value).trim() !== "") {
          if (fieldType === "date") {
            primitiveValues.push(value.valueOf());
          } else if (fieldType === "duration") {
            primitiveValues.push(value.toString());
          } else {
            primitiveValues.push(value);
          }
        }
        return primitiveValues;
      }, []));
      if (fieldType === "string") {
        sortedValues = uniqueValues.sort(me.sortStrings);
      } else if (fieldType === "duration") {
        sortedValues = uniqueValues.map((durationStr) => new Duration(durationStr)).filter((duration) => duration.isValid).sort(me.sortDurations);
      } else {
        sortedValues = uniqueValues.sort(me.sortNumerics);
      }
      if (fieldType === "date") {
        sortedValues = sortedValues.map((timestamp) => {
          const date2 = new Date(timestamp);
          return {
            text: DateHelper.format(date2, me.dateFormat),
            value: timestamp
          };
        });
      } else if (fieldType === "duration") {
        sortedValues = sortedValues.map((duration) => duration.toString());
      }
    }
    return sortedValues;
  }
  sortStrings(a, b) {
    return (a !== null && a !== void 0 ? a : EMPTY_STRING).localeCompare(b !== null && b !== void 0 ? b : EMPTY_STRING);
  }
  sortNumerics(a, b) {
    return a - b;
  }
  sortDurations(a, b) {
    return a.valueOf() - b.valueOf();
  }
  get fieldType() {
    var _this$selectedField;
    return (_this$selectedField = this.selectedField) === null || _this$selectedField === void 0 ? void 0 : _this$selectedField.type;
  }
  get selectedField() {
    var _this$fields, _this$_filter2;
    return (_this$fields = this.fields) === null || _this$fields === void 0 ? void 0 : _this$fields[(_this$_filter2 = this._filter) === null || _this$_filter2 === void 0 ? void 0 : _this$_filter2.property];
  }
  get propertyOptions() {
    var _this$fields2;
    return Object.entries((_this$fields2 = this.fields) !== null && _this$fields2 !== void 0 ? _this$fields2 : {}).filter(([, fieldDef]) => SUPPORTED_FIELD_DATA_TYPES.includes(fieldDef.type) || isSupportedDurationField(fieldDef)).map(([fieldName, {
      title
    }]) => ({
      value: fieldName,
      text: title !== null && title !== void 0 ? title : fieldName
    })).sort((a, b) => a.text.localeCompare(b.text));
  }
  get operatorOptions() {
    return this.operators[this.fieldIsRelation ? "relation" : this.fieldType];
  }
  get fieldIsRelation() {
    return Boolean(this.currentPropertyRelationConfig);
  }
  get currentPropertyRelationConfig() {
    var _this$store, _this$store$modelRela;
    return (_this$store = this.store) === null || _this$store === void 0 ? void 0 : (_this$store$modelRela = _this$store.modelRelations) === null || _this$store$modelRela === void 0 ? void 0 : _this$store$modelRela.find(({
      foreignKey
    }) => {
      var _this$_filter3;
      return foreignKey === ((_this$_filter3 = this._filter) === null || _this$_filter3 === void 0 ? void 0 : _this$_filter3.property);
    });
  }
  updateOperators() {
    delete this._operatorArgCountLookup;
  }
  get operatorArgCountLookup() {
    return this._operatorArgCountLookup || (this._operatorArgCountLookup = FieldFilterPicker.buildOperatorArgCountLookup(this.operators));
  }
  updateFilter() {
    if (this._filter) {
      this.onFilterChange();
    }
  }
  updateStore(newStore) {
    var _this$_store;
    (_this$_store = this._store) === null || _this$_store === void 0 ? void 0 : _this$_store.un(this);
    newStore === null || newStore === void 0 ? void 0 : newStore.ion({
      refresh: "onStoreRefresh",
      thisObj: this
    });
  }
  onStoreRefresh({
    action
  }) {
    if (this.isMultiSelectValueField && ["dataset", "create", "update", "delete"].includes(action)) {
      this.valueFields[0].items = this.getUniqueDataValues(this.filterValues);
    }
  }
  refreshValueFields() {
    const me = this, {
      valueFieldRow
    } = me.widgetMap;
    valueFieldRow.removeAll();
    valueFieldRow.add(me.getValueFieldConfigs());
    delete me._valueFields;
    me.refreshCaseSensitive();
  }
  refreshCaseSensitive() {
    var _me$_filter2, _me$_filter3;
    const me = this, {
      fieldType,
      operatorArgCount,
      isMultiSelectValueField
    } = me, operator = (_me$_filter2 = me._filter) === null || _me$_filter2 === void 0 ? void 0 : _me$_filter2.operator, {
      caseSensitive
    } = me.widgetMap;
    caseSensitive.hidden = fieldType !== "string" || !operator || isMultiSelectValueField || operatorArgCount === 0;
    caseSensitive.checked = ((_me$_filter3 = me._filter) === null || _me$_filter3 === void 0 ? void 0 : _me$_filter3.caseSensitive) !== false;
  }
  onPropertySelect(event) {
    var _event$record;
    const me = this, {
      _filter
    } = me;
    _filter.property = ((_event$record = event.record) === null || _event$record === void 0 ? void 0 : _event$record.data.value) || null;
    if (me.fieldType !== me._fieldType) {
      _filter.operator = null;
      _filter.value = null;
    }
    me._fieldType = _filter.type = me.fieldType;
    me.refreshOperatorPicker();
    me.refreshValueFields();
    me.triggerChange();
  }
  onCaseSensitiveChange({
    checked
  }) {
    this._filter.caseSensitive = checked;
    this.triggerChange();
  }
  onOperatorSelect(event) {
    var _event$record2;
    const me = this, wasMultiSelectValueField = me.isMultiSelectValueField;
    const prevArgCount = this.operatorArgCount;
    me._filter.operator = ((_event$record2 = event.record) === null || _event$record2 === void 0 ? void 0 : _event$record2.data.value) || null;
    if (me.operatorArgCount !== prevArgCount) {
      me._filter.value = null;
    }
    if (me.isMultiSelectValueField && !wasMultiSelectValueField) {
      me._filter.value = [];
    }
    me.refreshValueFields();
    me.triggerChange();
  }
  triggerChange() {
    const {
      filter: filter2,
      isValid
    } = this;
    this.trigger("change", {
      filter: filter2,
      isValid
    });
  }
  onValueChange() {
    const me = this, {
      isMultiSelectValueField,
      fieldType,
      _filter
    } = me, values = this.valueFields.map((field) => field.value);
    if (isMultiSelectValueField && fieldType === "date") {
      _filter.value = values[0].map((timestamp) => new Date(timestamp));
    } else if (isMultiSelectValueField && fieldType === "duration") {
      _filter.value = values[0].map((durationStr) => new Duration(durationStr));
    } else {
      if (fieldType === "date" && _filter.operator === "between" && DateHelper.isValidDate(values[1])) {
        values[1].setHours(23, 59, 59, 999);
      }
      _filter.value = values.length === 1 ? values[0] : values;
    }
    me.triggerChange();
  }
  refreshOperatorPicker() {
    const {
      operatorPicker
    } = this.widgetMap, {
      _filter: {
        operator,
        property
      },
      operatorOptions
    } = this;
    operatorPicker.items = operatorOptions;
    operatorPicker.value = operator;
    operatorPicker.hidden = property === null;
  }
  populateUIFromFilter(forceRefreshValueFields = false) {
    const me = this, {
      filterValues,
      widgetMap: {
        propertyPicker,
        operatorPicker
      },
      _filter: {
        property,
        operator,
        disabled
      },
      propertyOptions,
      operatorOptions,
      isMultiSelectValueField
    } = me;
    propertyPicker.items = propertyOptions;
    operatorPicker.items = operatorOptions;
    operatorPicker.hidden = property === null;
    let refreshValueFields = forceRefreshValueFields;
    if (propertyPicker.value !== property) {
      propertyPicker.value = property;
      me.refreshOperatorPicker();
      refreshValueFields = true;
    }
    if (operatorPicker.value !== operator) {
      if (operator === null) {
        operatorPicker.clear();
      } else {
        operatorPicker.value = operator;
      }
      refreshValueFields = true;
    }
    if (refreshValueFields) {
      me.refreshValueFields();
    }
    me.refreshCaseSensitive();
    me.valueFields.forEach((valueField, fieldIndex) => {
      if (isMultiSelectValueField && (valueField.value.length > 0 || filterValues.length > 0)) {
        if (me.fieldType === "date") {
          valueField.value = filterValues.map((date2) => date2 === null || date2 === void 0 ? void 0 : date2.valueOf());
        } else if (me.fieldType === "duration") {
          valueField.value = filterValues.map((duration) => duration === null || duration === void 0 ? void 0 : duration.toString());
        } else {
          valueField.value = filterValues;
        }
      } else if (fieldIndex >= filterValues.length) {
        valueField.clear();
      } else {
        valueField.value = filterValues[fieldIndex];
      }
    });
    me.allChildInputs.forEach((widget) => widget.disabled = me.disabled || disabled);
  }
  get valueFields() {
    return this._valueFields || (this._valueFields = this.widgetMap.valueFieldRow.queryAll((w) => ["textfield", "datefield", "numberfield", "durationfield", "combo"].includes(w.type)));
  }
  get filterValues() {
    var _this$_filter4;
    if (((_this$_filter4 = this._filter) === null || _this$_filter4 === void 0 ? void 0 : _this$_filter4.value) == null) {
      return [];
    }
    return ArrayHelper.asArray(this._filter.value);
  }
  onFilterChange() {
    const me = this, newFieldType = me.fieldType, forceRefreshValueFields = newFieldType !== me._fieldType;
    me._fieldType = me._filter.type = newFieldType;
    me.populateUIFromFilter(forceRefreshValueFields);
  }
  get operatorArgCount() {
    const {
      fieldType,
      filter: {
        operator
      },
      operatorArgCountLookup
    } = this;
    return fieldType && operator ? operatorArgCountLookup[fieldType][operator] : 1;
  }
  get isValid() {
    const me = this, {
      filter: filter2,
      fieldType,
      filterValues,
      isMultiSelectValueField,
      operatorArgCount
    } = me, {
      operator
    } = filter2, missingValue = operatorArgCount > 0 && (filter2 === null || filter2 === void 0 ? void 0 : filter2.value) == null;
    return fieldType && operator && !missingValue && (isMultiSelectValueField && filterValues.length > 0 || filterValues.length === operatorArgCount) && filterValues.every((value) => value != null && (fieldType !== "duration" || value.isValid));
  }
};
_defineProperty(FieldFilterPicker, "operators", {
  empty: {
    value: "empty",
    text: "L{isEmpty}",
    argCount: 0
  },
  notEmpty: {
    value: "notEmpty",
    text: "L{isNotEmpty}",
    argCount: 0
  },
  "=": {
    value: "=",
    text: "L{equals}"
  },
  "!=": {
    value: "!=",
    text: "L{doesNotEqual}"
  },
  ">": {
    value: ">",
    text: "L{isGreaterThan}"
  },
  "<": {
    value: "<",
    text: "L{isLessThan}"
  },
  ">=": {
    value: ">=",
    text: "L{isGreaterThanOrEqualTo}"
  },
  "<=": {
    value: "<=",
    text: "L{isLessThanOrEqualTo}"
  },
  between: {
    value: "between",
    text: "L{isBetween}",
    argCount: 2
  },
  notBetween: {
    value: "notBetween",
    text: "L{isNotBetween}",
    argCount: 2
  },
  isIncludedIn: {
    value: "isIncludedIn",
    text: "L{isOneOf}"
  },
  isNotIncludedIn: {
    value: "isNotIncludedIn",
    text: "L{isNotOneOf}"
  }
});
_defineProperty(FieldFilterPicker, "defaultOperators", {
  string: [
    FieldFilterPicker.operators.empty,
    FieldFilterPicker.operators.notEmpty,
    FieldFilterPicker.operators["="],
    FieldFilterPicker.operators["!="],
    {
      value: "includes",
      text: "L{contains}"
    },
    {
      value: "doesNotInclude",
      text: "L{doesNotContain}"
    },
    {
      value: "startsWith",
      text: "L{startsWith}"
    },
    {
      value: "endsWith",
      text: "L{endsWith}"
    },
    FieldFilterPicker.operators.isIncludedIn,
    FieldFilterPicker.operators.isNotIncludedIn
  ],
  number: [FieldFilterPicker.operators.empty, FieldFilterPicker.operators.notEmpty, FieldFilterPicker.operators["="], FieldFilterPicker.operators["!="], FieldFilterPicker.operators[">"], FieldFilterPicker.operators["<"], FieldFilterPicker.operators[">="], FieldFilterPicker.operators["<="], FieldFilterPicker.operators.between, FieldFilterPicker.operators.notBetween, FieldFilterPicker.operators.isIncludedIn, FieldFilterPicker.operators.isNotIncludedIn],
  date: [FieldFilterPicker.operators.empty, FieldFilterPicker.operators.notEmpty, FieldFilterPicker.operators["="], FieldFilterPicker.operators["!="], {
    value: "<",
    text: "L{isBefore}"
  }, {
    value: ">",
    text: "L{isAfter}"
  }, FieldFilterPicker.operators.between, {
    value: "isToday",
    text: "L{isToday}",
    argCount: 0
  }, {
    value: "isTomorrow",
    text: "L{isTomorrow}",
    argCount: 0
  }, {
    value: "isYesterday",
    text: "L{isYesterday}",
    argCount: 0
  }, {
    value: "isThisWeek",
    text: "L{isThisWeek}",
    argCount: 0
  }, {
    value: "isNextWeek",
    text: "L{isNextWeek}",
    argCount: 0
  }, {
    value: "isLastWeek",
    text: "L{isLastWeek}",
    argCount: 0
  }, {
    value: "isThisMonth",
    text: "L{isThisMonth}",
    argCount: 0
  }, {
    value: "isNextMonth",
    text: "L{isNextMonth}",
    argCount: 0
  }, {
    value: "isLastMonth",
    text: "L{isLastMonth}",
    argCount: 0
  }, {
    value: "isThisYear",
    text: "L{isThisYear}",
    argCount: 0
  }, {
    value: "isNextYear",
    text: "L{isNextYear}",
    argCount: 0
  }, {
    value: "isLastYear",
    text: "L{isLastYear}",
    argCount: 0
  }, {
    value: "isYearToDate",
    text: "L{isYearToDate}",
    argCount: 0
  }, FieldFilterPicker.operators.isIncludedIn, FieldFilterPicker.operators.isNotIncludedIn],
  boolean: [{
    value: "isTrue",
    text: "L{isTrue}",
    argCount: 0
  }, {
    value: "isFalse",
    text: "L{isFalse}",
    argCount: 0
  }],
  duration: [FieldFilterPicker.operators.empty, FieldFilterPicker.operators.notEmpty, FieldFilterPicker.operators["="], FieldFilterPicker.operators["!="], FieldFilterPicker.operators[">"], FieldFilterPicker.operators["<"], FieldFilterPicker.operators[">="], FieldFilterPicker.operators["<="], FieldFilterPicker.operators.between, FieldFilterPicker.operators.notBetween, FieldFilterPicker.operators.isIncludedIn, FieldFilterPicker.operators.isNotIncludedIn],
  relation: [FieldFilterPicker.operators.isIncludedIn, FieldFilterPicker.operators.isNotIncludedIn]
});
_defineProperty(FieldFilterPicker, "configurable", {
  fields: null,
  disabled: false,
  readOnly: false,
  layout: "vbox",
  propertyLocked: false,
  operatorLocked: false,
  filter: null,
  propertyFieldConfig: null,
  operatorFieldConfig: null,
  valueFieldCls: null,
  items: {
    propertyAndOperator: {
      type: "container",
      layout: "box",
      items: {
        propertyPicker: {
          type: "combo",
          items: {},
          cls: `b-${FieldFilterPicker.type}-property`,
          placeholder: "L{FieldFilterPicker.selectAProperty}"
        },
        operatorPicker: {
          type: "combo",
          items: {},
          cls: `b-${FieldFilterPicker.type}-operator`,
          placeholder: "L{FieldFilterPicker.selectAnOperator}"
        }
      }
    },
    valueFieldRow: {
      type: "container",
      cls: `b-${FieldFilterPicker.type}-values`,
      items: {}
    },
    caseSensitive: {
      type: "checkbox",
      text: "L{FieldFilterPicker.caseSensitive}",
      cls: `b-${FieldFilterPicker.type}-case-sensitive`
    }
  },
  operators: FieldFilterPicker.defaultOperators,
  dateFormat: "L{FieldFilterPicker.dateFormat}",
  store: null,
  valueFieldPlaceholders: null,
  getValueFieldConfig: null
});
_defineProperty(FieldFilterPicker, "buildOperatorArgCountLookup", (operators) => ArrayHelper.keyBy(Object.entries(operators), ([fieldType]) => fieldType, ([, operators2]) => ArrayHelper.keyBy(operators2, ({
  value
}) => value, ({
  argCount
}) => argCount === void 0 ? 1 : argCount)));
FieldFilterPicker.initClass();
FieldFilterPicker._$name = "FieldFilterPicker";
var Label = class extends Widget {
  compose() {
    const {
      text,
      html
    } = this;
    return {
      tag: "label",
      text,
      html
    };
  }
};
_defineProperty(Label, "$name", "Label");
_defineProperty(Label, "type", "label");
_defineProperty(Label, "configurable", {
  text: null,
  localizableProperties: ["text"]
});
Label.initClass();
Label._$name = "Label";
var FieldFilterPickerGroup = class extends Container {
  static get $name() {
    return "FieldFilterPickerGroup";
  }
  static get type() {
    return "fieldfilterpickergroup";
  }
  afterConstruct() {
    const me = this;
    me.validateConfig();
    const {
      addFilterButton
    } = me.widgetMap;
    addFilterButton.ion({
      click: "addFilter",
      thisObj: me
    });
    addFilterButton.text = me.L(addFilterButton.text);
    me.store && me.updateStore(me.store);
    super.afterConstruct();
  }
  changeDateFormat(dateFormat) {
    return this.L(dateFormat);
  }
  validateConfig() {
    if (!this.fields && !this.store) {
      throw new Error(`FieldFilterPickerGroup requires either a 'fields' or 'store' config property.`);
    }
  }
  get someFiltersNotShown() {
    return this.store && this.store.filters.count > this.filters.length;
  }
  updateFields(newFields) {
    this.widgetMap.pickers.childItems.forEach((picker) => picker.fields = newFields);
  }
  updateFilters(newFilters, oldFilters) {
    const me = this;
    if (oldFilters) {
      oldFilters.filter((filter2) => !newFilters.find((newFilter) => newFilter.id === filter2.id)).forEach((filter2) => {
        var _me$store;
        return (_me$store = me.store) === null || _me$store === void 0 ? void 0 : _me$store.removeFilter(filter2.id);
      });
    }
    newFilters.forEach((filter2) => filter2.id = filter2.id || me.nextFilterId);
    me.widgetMap.pickers.items = (newFilters === null || newFilters === void 0 ? void 0 : newFilters.map((filter2) => me.getPickerRowConfig(filter2))) || [];
  }
  changeFilters(newFilters) {
    const {
      canManageFilter
    } = this;
    return newFilters && canManageFilter ? newFilters.filter((filter2) => this.callback(canManageFilter, this, [filter2])) : newFilters;
  }
  updateStore(newStore) {
    const me = this;
    me.detachListeners("store");
    if (newStore) {
      me.widgetMap.pickers.childItems.forEach(({
        widgetMap: {
          filterPicker: {
            filter: filter2,
            isValid
          }
        }
      }) => {
        newStore.removeFilter(filter2.id, true);
        if (isValid) {
          newStore.addFilter(filter2, true);
        }
      });
      newStore.filter();
      me.appendFiltersFromStore();
      newStore.ion({
        name: "store",
        filter: "onStoreFilter",
        thisObj: me
      });
    }
    me.widgetMap.pickers.childItems.forEach((picker) => picker.store = newStore);
  }
  updateShowAddFilterButton(newShow) {
    this.widgetMap.addFilterButton.hidden = !newShow;
  }
  updateAddFilterButtonText(newText) {
    this.widgetMap.addFilterButton.text = newText !== null && newText !== void 0 ? newText : FieldFilterPickerGroup.addFilterButtonDefaultText;
  }
  appendFiltersFromStore() {
    const me = this;
    me.store.filters.forEach((filter2) => {
      var _me$filters;
      const canManage = me.canManage(filter2), {
        property,
        operator,
        value,
        id,
        disabled = false,
        caseSensitive
      } = filter2;
      if (canManage && property && operator && !((_me$filters = me.filters) !== null && _me$filters !== void 0 && _me$filters.find((filter3) => filter3.id === id))) {
        me.appendFilter({
          id,
          property,
          operator,
          value,
          disabled,
          caseSensitive
        });
      }
    });
  }
  canManage(filter2) {
    const me = this;
    return !me.canManageFilter || me.callback(me.canManageFilter, me, [filter2]) === true;
  }
  getFilterPickerConfig(filter2) {
    const me = this, {
      fields,
      store,
      disabled,
      readOnly,
      valueFieldCls,
      operators,
      limitToProperty,
      dateFormat,
      getFieldFilterPickerConfig
    } = me;
    return _objectSpread2({
      type: me.constructor.childPickerType,
      fields: fields !== null && fields !== void 0 ? fields : me.getFieldsFromStore(store),
      filter: filter2,
      store,
      disabled,
      readOnly,
      propertyLocked: Boolean(limitToProperty),
      valueFieldCls,
      operators,
      dateFormat,
      internalListeners: {
        change: "onFilterPickerChange",
        thisObj: me
      },
      flex: 1
    }, getFieldFilterPickerConfig ? me.callback(getFieldFilterPickerConfig, me, [filter2]) : void 0);
  }
  getFieldsFromStore(store) {
    var _store$fields$map, _store$fields;
    return Object.fromEntries((_store$fields$map = (_store$fields = store.fields) === null || _store$fields === void 0 ? void 0 : _store$fields.map(({
      name,
      type
    }) => [name, {
      type
    }])) !== null && _store$fields$map !== void 0 ? _store$fields$map : []);
  }
  getPickerRowConfig(filter2) {
    const me = this, {
      disabled,
      readOnly,
      canDeleteFilter
    } = me;
    return {
      type: "container",
      layout: "box",
      layoutStyle: {
        alignItems: "start"
      },
      cls: `b-${FieldFilterPickerGroup.type}-row`,
      dataset: {
        separatorText: me.L("L{FieldFilterPicker.and}")
      },
      items: {
        activeCheckbox: {
          type: "checkbox",
          disabled,
          readOnly,
          checked: !Boolean(filter2.disabled),
          listeners: {
            change: "onFilterActiveChange",
            thisObj: me
          },
          cls: `b-${FieldFilterPickerGroup.type}-filter-active`
        },
        filterPicker: me.getFilterPickerConfig(filter2),
        removeButton: {
          type: "button",
          ref: "removeButton",
          disabled,
          readOnly,
          hidden: canDeleteFilter && me.callback(canDeleteFilter, me, [filter2]) === false,
          cls: `b-transparent b-${FieldFilterPickerGroup.type}-remove`,
          icon: "b-fa-trash",
          internalListeners: {
            click: "removeFilter",
            thisObj: me
          }
        }
      }
    };
  }
  get allInputs() {
    const childInputTypes = [this.constructor.childPickerType, "button", "checkbox"];
    return this.queryAll((w) => childInputTypes.includes(w.type));
  }
  updateDisabled(newDisabled) {
    this.allInputs.forEach((input) => input.disabled = newDisabled);
  }
  updateReadOnly(newReadOnly) {
    this.allInputs.forEach((input) => input.readOnly = newReadOnly);
  }
  onFilterActiveChange({
    source,
    checked
  }) {
    const me = this, filterIndex = me.getFilterIndex(source), filter2 = me.filters[filterIndex], filterPicker = me.getFilterPicker(filterIndex);
    filter2.disabled = !checked;
    filterPicker.onFilterChange();
    if (me.store && filterPicker.isValid) {
      me.store.addFilter(filter2, true);
    }
    me.updateStoreFilter();
    me.triggerChange();
  }
  onFilterPickerChange({
    source,
    filter: filter2,
    isValid
  }) {
    const me = this, {
      store
    } = me, filterIndex = me.getFilterIndex(source);
    if (store) {
      store.removeFilter(filter2.id, true);
      if (isValid) {
        store.addFilter(filter2, true);
      }
      me.updateStoreFilter();
    }
    Object.assign(me.filters[filterIndex], filter2);
    me.triggerChange();
  }
  getFilterIndex(eventSource) {
    return this.widgetMap.pickers.childItems.indexOf(eventSource.containingWidget);
  }
  getPickerRow(index) {
    return this.widgetMap.pickers.childItems[index];
  }
  getFilterPicker(filterIndex) {
    return this.getPickerRow(filterIndex).widgetMap.filterPicker;
  }
  get nextFilterId() {
    this._nextId = (this._nextId || 0) + 1;
    return `${this.id}-filter-${this._nextId}`;
  }
  removeFilter({
    source
  }) {
    const me = this, filterIndex = me.getFilterIndex(source), filter2 = me.filters[filterIndex], pickerRow = me.getPickerRow(filterIndex), newFocusWidget = me.query((w) => w.isFocusable && w.type !== "container" && !pickerRow.contains(w));
    if (newFocusWidget) {
      newFocusWidget.focus();
    }
    me.removeFilterAt(filterIndex);
    if (me.store) {
      me.store.removeFilter(filter2.id, true);
      me.updateStoreFilter();
    }
    me.trigger("remove", {
      filter: filter2
    });
    me.triggerChange();
  }
  addFilter({
    property = null,
    operator = null,
    value = null
  } = {}) {
    const me = this, {
      filters
    } = me, newFilter = {
      property: me.limitToProperty || property,
      operator,
      value,
      disabled: false,
      id: me.nextFilterId,
      caseSensitive: false
    };
    me.appendFilter(newFilter);
    if (me.getFilterPicker(filters.length - 1).isValid) {
      var _me$store2;
      (_me$store2 = me.store) === null || _me$store2 === void 0 ? void 0 : _me$store2.addFilter(newFilter, true);
      me.store && me.updateStoreFilter();
    }
    me.trigger("add", {
      filter: newFilter
    });
    me.triggerChange();
  }
  appendFilter(filter2) {
    const me = this;
    if (!me.limitToProperty || filter2.property === me.limitToProperty) {
      me.filters.push(filter2);
      me.widgetMap.pickers.add(me.getPickerRowConfig(filter2, me.filters.length - 1));
    }
  }
  onStoreFilter(event) {
    const me = this;
    if (me._isUpdatingStore) {
      return;
    }
    const {
      filters
    } = event, storeFiltersById = filters.values.reduce((byId, filter2) => _objectSpread2(_objectSpread2({}, byId), {}, {
      [filter2.id]: filter2
    }), {});
    for (let filterIndex = me.filters.length - 1; filterIndex >= 0; filterIndex--) {
      const filter2 = me.filters[filterIndex], storeFilter = storeFiltersById[filter2.id], filterRow = me.getPickerRow(filterIndex);
      if (filterRow) {
        const {
          filterPicker,
          activeCheckbox
        } = filterRow.widgetMap;
        if (!storeFilter && filterPicker.isValid) {
          me.removeFilterAt(filterIndex);
        } else if (storeFilter !== void 0) {
          const {
            operator,
            value,
            property,
            disabled,
            caseSensitive
          } = storeFilter;
          if (filter2 !== storeFilter) {
            Object.assign(filter2, {
              operator,
              value,
              property,
              disabled,
              caseSensitive
            });
          }
          filterPicker.filter = filter2;
          filterPicker.onFilterChange();
          activeCheckbox.checked = !disabled;
        }
      }
    }
    me.appendFiltersFromStore();
    me.triggerChange();
  }
  removeFilterAt(filterIndex) {
    const {
      widgetMap: {
        pickers
      },
      filters
    } = this;
    pickers.remove(pickers.childItems[filterIndex]);
    filters.splice(filterIndex, 1);
    this.triggerChange();
  }
  updateStoreFilter() {
    this._isUpdatingStore = true;
    this.store.filter();
    this._isUpdatingStore = false;
  }
  get value() {
    return this.filters;
  }
  triggerChange() {
    this.trigger("change", {
      filters: this.value
    });
  }
  activateAll() {
    this.setAllActiveStatus(true);
  }
  deactivateAll() {
    this.setAllActiveStatus(false);
  }
  setAllActiveStatus(newActive) {
    const me = this, {
      _filters,
      store
    } = me;
    _filters.forEach((filter2, filterIndex) => {
      if (newActive === filter2.disabled) {
        const {
          filterPicker,
          activeCheckbox
        } = me.getPickerRow(filterIndex).widgetMap;
        filter2.disabled = !newActive;
        filterPicker.onFilterChange();
        activeCheckbox.checked = newActive;
        if (newActive && store && filterPicker.isValid) {
          store.addFilter(filter2, true);
        }
      }
    });
    me.updateStoreFilter();
  }
};
_defineProperty(FieldFilterPickerGroup, "addFilterButtonDefaultText", "L{FieldFilterPickerGroup.addFilter}");
_defineProperty(FieldFilterPickerGroup, "configurable", {
  filters: [],
  fields: null,
  disabled: false,
  readOnly: false,
  layout: "vbox",
  store: null,
  limitToProperty: null,
  valueFieldCls: null,
  showAddFilterButton: true,
  canDeleteFilter: null,
  getFieldFilterPickerConfig: null,
  canManageFilter: null,
  addFilterButtonText: null,
  items: {
    pickers: {
      type: "container",
      layout: "vbox",
      scrollable: true,
      items: {}
    },
    addFilterButton: {
      type: "button",
      text: FieldFilterPickerGroup.addFilterButtonDefaultText,
      cls: `b-${FieldFilterPickerGroup.type}-add-button`,
      hidden: true
    }
  },
  operators: null,
  dateFormat: "L{FieldFilterPicker.dateFormat}"
});
_defineProperty(FieldFilterPickerGroup, "childPickerType", "fieldfilterpicker");
FieldFilterPickerGroup.initClass();
FieldFilterPickerGroup._$name = "FieldFilterPickerGroup";
var FieldSet = class extends Panel.mixin(Labelable) {
  static get $name() {
    return "FieldSet";
  }
  static get type() {
    return "fieldset";
  }
  static get configurable() {
    return {
      bodyTag: "fieldset",
      focusable: false,
      inline: null,
      inlineInternal: null,
      layout: {
        type: "box",
        horizontal: false
      }
    };
  }
  static get prototypeProperties() {
    return {
      flexRowCls: "b-hbox",
      flexColCls: "b-vbox"
    };
  }
  get bodyConfig() {
    const result = super.bodyConfig, {
      className
    } = result, {
      inlineInternal: inline,
      hasLabel,
      title
    } = this;
    delete result.html;
    className["b-inline"] = inline;
    className["b-fieldset-has-label"] = hasLabel;
    if (title) {
      result.children = {
        legendElement: {
          tag: "legend",
          text: title,
          class: {
            "b-fieldset-legend": 1
          }
        }
      };
    }
    return result;
  }
  compose() {
    const {
      inlineInternal: inline,
      label,
      labelCls,
      labelWidth
    } = this;
    return {
      class: {
        "b-field": label,
        "b-vbox": !inline
      },
      children: {
        "labelElement > headerElement": (label || null) && {
          tag: "label",
          html: label,
          class: {
            "b-label": 1,
            "b-align-start": 1,
            [labelCls]: labelCls
          },
          style: {
            width: DomHelper.unitize("width", labelWidth)[1]
          }
        }
      }
    };
  }
  syncInlineInternal() {
    var _this$inline;
    this.inlineInternal = (_this$inline = this.inline) !== null && _this$inline !== void 0 ? _this$inline : this.label != null && this.labelPosition === "before";
  }
  updateDisabled(value, was) {
    super.updateDisabled(value, was);
    this.eachWidget((item) => {
      item.disabled = value;
    }, false);
  }
  updateInline() {
    this.syncInlineInternal();
  }
  updateInlineInternal(inline) {
    this.layout.horizontal = inline;
  }
  updateLabel() {
    this.syncInlineInternal();
  }
  updateLabelPosition() {
    this.syncInlineInternal();
  }
};
FieldSet.initClass();
FieldSet._$name = "FieldSet";
var FileField = class extends Field {
  static get $name() {
    return "FileField";
  }
  static get type() {
    return "filefield";
  }
  static get configurable() {
    return {
      multiple: null,
      accept: null,
      inputType: "file",
      attributes: ["multiple", "accept"]
    };
  }
  get files() {
    return this.input.files;
  }
  pickFile() {
    this.input.click();
  }
  get multiple() {
    return this._multiple ? "" : null;
  }
  clear() {
    this.input.value = null;
  }
  triggerChange(event) {
    this.triggerFieldChange({
      event,
      value: this.input.value,
      oldValue: this._lastValue,
      userAction: true,
      valid: true
    });
  }
};
FileField.initClass();
FileField._$name = "FileField";
var FilePicker = class extends Container {
  static get $name() {
    return "FilePicker";
  }
  static get type() {
    return "filepicker";
  }
  static get defaultConfig() {
    return {
      defaultBindProperty: "value",
      buttonConfig: null,
      fileFieldConfig: null
    };
  }
  construct(config = {}) {
    const me = this;
    config.items = [Object.assign({
      type: "button",
      ref: "fileButton",
      text: "L{FilePicker.file}",
      localeClass: this
    }, config.buttonConfig), Object.assign({
      type: "filefield",
      ref: "fileField",
      style: "display: none"
    }, config.fileFieldConfig)].concat(config.items || []);
    super.construct(config);
    me.button.ion({
      click: me.onButtonClick,
      thisObj: me
    });
    me.fileField.ion({
      change: me.onFileFieldChange,
      thisObj: me
    });
    me._thisIsAUsedExpression(me.fileTip);
  }
  get button() {
    return this.widgetMap.fileButton;
  }
  get fileField() {
    return this.widgetMap.fileField;
  }
  get files() {
    return this.fileField.files;
  }
  get fileTip() {
    const me = this;
    return me._fileTip || (me._fileTip = new Tooltip({
      cls: "b-file-tip",
      forElement: me.button.element,
      showOnHover: true,
      align: "b-t",
      scrollAction: "realign",
      internalListeners: {
        beforeshow() {
          const tip = this, files = me.files;
          if (files && files.length) {
            tip.html = `${Array.from(files).map((file) => file.name).join("<br>")}`;
            return true;
          }
          return false;
        }
      }
    }));
  }
  clear() {
    const me = this;
    me.fileField.clear();
    me.button.badge = "";
    me.trigger("clear");
  }
  onButtonClick({
    event
  }) {
    const me = this;
    me.fileField.pickFile();
    event.preventDefault();
  }
  onFileFieldChange({
    valid
  }) {
    const me = this;
    me.button.badge = me.files.length || "";
    me.triggerFieldChange({
      files: me.files,
      valid
    });
  }
};
FilePicker.initClass();
FilePicker._$name = "FilePicker";
var FilterField = class extends TextField {
  static get $name() {
    return "FilterField";
  }
  static get type() {
    return "filterfield";
  }
  static get configurable() {
    return {
      field: null,
      store: null,
      filterFunction: null,
      clearable: true,
      keyStrokeChangeDelay: 100,
      onChange({
        value
      }) {
        const {
          store,
          field,
          filterFunction
        } = this;
        if (store) {
          const filterId = `${field || this.id}-Filter`;
          if (value.length === 0) {
            store.removeFilter(filterId);
          } else {
            let filterBy;
            if (filterFunction) {
              filterBy = (record) => filterFunction(record, value);
            } else {
              value = value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
              filterBy = (record) => record.get(field).match(new RegExp(value, "i"));
            }
            store.filter({
              id: filterId,
              filterBy
            });
          }
        }
      }
    };
  }
  updateValue(value, old) {
    super.updateValue(value, old);
    if (value && this.isConfiguring) {
      this.onChange({
        value
      });
    }
  }
};
FilterField.initClass();
FilterField._$name = "FilterField";
var items = [{
  ref: "cancelButton",
  cls: "b-messagedialog-cancelbutton b-gray",
  text: "L{Object.Cancel}",
  onClick: "up.onCancelClick"
}, {
  ref: "okButton",
  cls: "b-messagedialog-okbutton b-raised b-blue",
  text: "L{Object.Ok}",
  onClick: "up.onOkClick"
}];
if (BrowserHelper.isWindows) {
  items.reverse();
}
var MessageDialogConstructor = class extends Popup {
  static get $name() {
    return "MessageDialog";
  }
  static get type() {
    return "messagedialog";
  }
  static get configurable() {
    return {
      centered: true,
      modal: true,
      hidden: true,
      autoShow: false,
      closeAction: "hide",
      title: "\xA0",
      lazyItems: {
        $config: ["lazy"],
        value: [{
          cls: "b-messagedialog-message",
          ref: "message"
        }, {
          type: "textfield",
          cls: "b-messagedialog-input",
          ref: "input"
        }]
      },
      showClass: null,
      bbar: {
        overflow: null,
        items
      }
    };
  }
  construct() {
    this.okButton = this.yesButton = 1;
    this.cancelButton = 3;
    super.construct(...arguments);
  }
  destroy() {
  }
  async confirm() {
    return this.showDialog("confirm", ...arguments);
  }
  async alert() {
    return this.showDialog("alert", ...arguments);
  }
  async prompt({
    textField
  }) {
    const field = this.widgetMap.input;
    Widget.reconfigure(field, textField);
    field.value = "";
    return this.showDialog("prompt", ...arguments);
  }
  showDialog(mode, {
    message = "",
    title = "\xA0",
    cancelButton,
    okButton,
    rootElement = document.body
  }) {
    const me = this;
    me.rootElement = rootElement;
    me.getConfig("lazyItems");
    me.title = me.optionalL(title);
    me.widgetMap.message.html = me.optionalL(message);
    me.showClass = `b-messagedialog-${mode}`;
    if (okButton) {
      okButton = typeof okButton === "string" ? {
        text: okButton
      } : okButton;
    }
    if (cancelButton) {
      cancelButton = typeof cancelButton === "string" ? {
        text: cancelButton
      } : cancelButton;
    }
    okButton = Object.assign({}, me.widgetMap.okButton.initialConfig, okButton);
    cancelButton = Object.assign({}, me.widgetMap.cancelButton.initialConfig, cancelButton);
    okButton.text = me.optionalL(okButton.text);
    cancelButton.text = me.optionalL(cancelButton.text);
    Widget.reconfigure(me.widgetMap.okButton, okButton);
    Widget.reconfigure(me.widgetMap.cancelButton, cancelButton);
    me.show();
    return me.promise = new Promise((resolve) => {
      me.resolve = resolve;
    });
  }
  show() {
    const activeElement = DomHelper.getActiveElement(this.element);
    this.owner = this.element.contains(activeElement) ? null : MessageDialogConstructor.fromElement(document.activeElement);
    return super.show(...arguments);
  }
  updateShowClass(showClass, oldShowClass) {
    const {
      classList
    } = this.element;
    if (oldShowClass) {
      classList.remove(oldShowClass);
    }
    if (showClass) {
      classList.add(showClass);
    }
  }
  doResolve(value) {
    const me = this, {
      resolve
    } = me;
    if (resolve) {
      const isPrompt = me.showClass === "b-messagedialog-prompt";
      if (isPrompt && value === me.okButton && !me.widgetMap.input.isValid) {
        return;
      }
      me.resolve = me.reject = me.promise = null;
      resolve(isPrompt ? {
        button: value,
        text: me.widgetMap.input.value
      } : value);
      me.hide();
    }
  }
  onInternalKeyDown(event) {
    if (event.key === "Escape") {
      event.stopImmediatePropagation();
      this.onCancelClick();
    }
    if (event.key === "Enter") {
      event.stopImmediatePropagation();
      event.preventDefault();
      this.onOkClick();
    }
    super.onInternalKeyDown(event);
  }
  onOkClick() {
    this.doResolve(MessageDialog.okButton);
  }
  onCancelClick() {
    this.doResolve(MessageDialog.cancelButton);
  }
};
MessageDialogConstructor.initClass();
var MessageDialog = new Proxy({}, {
  get(target, prop) {
    const instance = target.instance || (target.instance = new MessageDialogConstructor({
      rootElement: document.body
    })), result = instance[prop];
    return typeof result === "function" ? result.bind(instance) : result;
  }
});
var PagingToolbar = class extends Toolbar {
  static get $name() {
    return "PagingToolbar";
  }
  static get type() {
    return "pagingtoolbar";
  }
  static get defaultConfig() {
    return {
      store: null,
      defaults: {
        localeClass: this
      },
      items: {
        firstPageButton: {
          onClick: "up.onFirstPageClick",
          icon: "b-icon-first",
          weight: 100,
          tooltip: "L{PagingToolbar.firstPage}"
        },
        previousPageButton: {
          onClick: "up.onPreviousPageClick",
          icon: "b-icon-previous",
          weight: 110,
          tooltip: "L{PagingToolbar.prevPage}"
        },
        pageNumber: {
          type: "numberfield",
          label: "L{page}",
          min: 1,
          max: 1,
          triggers: null,
          onChange: "up.onPageNumberChange",
          highlightExternalChange: false,
          weight: 120
        },
        pageCount: {
          type: "widget",
          cls: "b-pagecount b-toolbar-text",
          weight: 130
        },
        nextPageButton: {
          onClick: "up.onNextPageClick",
          icon: "b-icon-next",
          weight: 140,
          tooltip: "L{PagingToolbar.nextPage}"
        },
        lastPageButton: {
          onClick: "up.onLastPageClick",
          icon: "b-icon-last",
          weight: 150,
          tooltip: "L{PagingToolbar.lastPage}"
        },
        separator: {
          type: "widget",
          cls: "b-toolbar-separator",
          weight: 151
        },
        reloadButton: {
          onClick: "up.onReloadClick",
          icon: "b-icon-reload",
          weight: 160,
          tooltip: "L{PagingToolbar.reload}"
        },
        spacer: {
          type: "widget",
          cls: "b-toolbar-fill",
          weight: 161
        },
        dataSummary: {
          type: "widget",
          cls: "b-toolbar-text",
          weight: 170
        }
      }
    };
  }
  set parent(parent) {
    super.parent = parent;
    if (!this.store) {
      this.store = parent.store;
    }
  }
  get parent() {
    return super.parent;
  }
  set store(store) {
    const me = this;
    me.detachListeners("store");
    me._store = store;
    if (store) {
      store.ion({
        name: "store",
        beforerequest: "onStoreBeforeRequest",
        afterrequest: "onStoreChange",
        change: "onStoreChange",
        thisObj: me
      });
      if (store.isLoading) {
        me.onStoreBeforeRequest();
      }
    }
  }
  get store() {
    return this._store;
  }
  onStoreBeforeRequest() {
    this.eachWidget((w) => w.disable());
  }
  updateLocalization() {
    this.updateSummary();
    super.updateLocalization();
  }
  updateSummary() {
    const me = this, {
      pageCount,
      dataSummary
    } = me.widgetMap;
    let count = 0, lastPage = 0, start = 0, end = 0, allCount = 0;
    if (me.store) {
      const {
        store
      } = me, {
        pageSize,
        currentPage
      } = store;
      count = store.count;
      lastPage = store.lastPage;
      allCount = store.allCount;
      start = Math.max(0, (currentPage - 1) * pageSize + 1);
      end = Math.min(allCount, start + pageSize - 1);
    }
    pageCount.html = me.L("L{pageCountTemplate}")({
      lastPage
    });
    dataSummary.html = count ? me.L("L{summaryTemplate}")({
      start,
      end,
      allCount
    }) : me.L("L{noRecords}");
  }
  onStoreChange() {
    const me = this, {
      widgetMap,
      store
    } = me, {
      count,
      lastPage,
      currentPage
    } = store, {
      pageNumber,
      pageCount,
      firstPageButton,
      previousPageButton,
      nextPageButton,
      lastPageButton,
      dataSummary
    } = widgetMap;
    me.eachWidget((w) => w.enable());
    pageNumber.value = currentPage;
    pageNumber.max = lastPage;
    dataSummary.disabled = pageNumber.disabled = pageCount.disabled = !count;
    firstPageButton.disabled = previousPageButton.disabled = currentPage <= 1 || !count;
    nextPageButton.disabled = lastPageButton.disabled = currentPage >= lastPage || !count;
    me.updateSummary();
  }
  onPageNumberChange({
    value
  }) {
    if (this.store.currentPage !== value) {
      this.store.loadPage(value);
    }
  }
  onFirstPageClick() {
    this.store.loadPage(1);
  }
  onPreviousPageClick() {
    this.store.previousPage();
  }
  onNextPageClick() {
    this.store.nextPage();
  }
  onLastPageClick() {
    this.store.loadPage(this.store.lastPage);
  }
  onReloadClick() {
    this.store.loadPage(this.store.currentPage);
  }
};
PagingToolbar.initClass();
PagingToolbar._$name = "PagingToolbar";
var {
  dockIsHorz
} = PanelCollapser.maps;
var collapseExposeEdge = {
  top: 0,
  down: 0,
  left: 1,
  bottom: 2,
  up: 2,
  right: 3
};
var emptyObject$6 = {};
var translateByDir = {
  up: {
    from: `translate(0,0)`,
    to: "translate(0,-100%)"
  },
  down: {
    from: `translate(0,0)`,
    to: "translate(0,100%)"
  },
  left: {
    from: `translate(0,0)`,
    to: "translate(-100%,0)"
  },
  right: {
    from: `translate(0,0)`,
    to: "translate(100%,0)"
  }
};
var PanelCollapserOverlay = class extends PanelCollapser.mixin(Delayable) {
  static get $name() {
    return "PanelCollapserOverlay";
  }
  static get type() {
    return "overlay";
  }
  static get configurable() {
    return {
      autoCloseDelay: 1e3,
      autoClose: true,
      revealing: {
        value: null,
        $config: null,
        default: false
      },
      recollapseTool: {
        type: "collapsetool",
        cls: "b-recollapse",
        collapsify: "overlay",
        handler() {
          var _this$collapsible;
          (_this$collapsible = this.collapsible) === null || _this$collapsible === void 0 ? void 0 : _this$collapsible.toggleReveal();
        }
      }
    };
  }
  static get delayable() {
    return {
      doAutoClose: 0
    };
  }
  doAutoClose() {
    this.toggleReveal(false);
  }
  updateAutoCloseDelay(delay2) {
    const {
      doAutoClose
    } = this;
    if (!(doAutoClose.suspended = delay2 == null || delay2 < 0)) {
      doAutoClose.delay = delay2;
      doAutoClose.immediate = !delay2;
    }
  }
  changeRecollapseTool(tool) {
    const me = this, {
      panel
    } = me;
    if (me.isConfiguring || me.isDestroying || !panel || panel.isDestroying) {
      return tool;
    }
    panel.tools = {
      recollapse: tool
    };
  }
  beforeCollapse(operation) {
    if (super.beforeCollapse(operation) === false) {
      return false;
    }
    if (this.panel.revealed) {
      operation.animation = null;
    }
  }
  applyHeaderDock(collapsed, flush = true) {
    var _this$panel;
    (_this$panel = this.panel) === null || _this$panel === void 0 ? void 0 : _this$panel.recompose();
    super.applyHeaderDock(collapsed, flush);
  }
  collapseBegin(operation) {
    const me = this, {
      collapseDir,
      innerElement
    } = me, {
      animation
    } = operation, {
      collapseTool,
      panel
    } = me;
    me.configuredWidth = panel._lastWidth;
    me.configuredHeight = panel._lastHeight;
    me.applyHeaderDock(true);
    me.lockInnerSize();
    collapseTool === null || collapseTool === void 0 ? void 0 : collapseTool.element.classList.add("b-collapsed");
    if (animation) {
      panel.element.classList.add("b-collapsing");
      animation.element = innerElement;
      animation.transform = translateByDir[collapseDir];
      operation.animation = Animator.run(animation);
    }
  }
  onComplete(action) {
    var _me$autoCloseLeaveDet, _me$autoCloseClickDet;
    super.onComplete(action);
    const me = this, {
      panel
    } = me, {
      element
    } = panel;
    me.autoCloseLeaveDetacher = (_me$autoCloseLeaveDet = me.autoCloseLeaveDetacher) === null || _me$autoCloseLeaveDet === void 0 ? void 0 : _me$autoCloseLeaveDet.call(me);
    me.autoCloseClickDetacher = (_me$autoCloseClickDet = me.autoCloseClickDetacher) === null || _me$autoCloseClickDet === void 0 ? void 0 : _me$autoCloseClickDet.call(me);
    me.doAutoClose.cancel();
    if (action === "reveal" && me.autoClose) {
      if (panel.containsFocus) {
        me.autoCloseLeaveDetacher = EventHelper.on({
          element,
          mouseenter: (ev) => {
            me.doAutoClose.cancel();
          },
          mouseleave: (ev) => {
            me.doAutoClose();
          }
        });
      }
      me.autoCloseClickDetacher = EventHelper.on({
        element: document.body,
        thisObj: panel,
        mousedown: (ev) => {
          if (ev.target !== element && !element.contains(ev.target) && me.autoCloseDelay != null) {
            var _panel$focusInEvent;
            const el = panel.containsFocus && ((_panel$focusInEvent = panel.focusInEvent) === null || _panel$focusInEvent === void 0 ? void 0 : _panel$focusInEvent.relatedTarget) || DomHelper.getActiveElement(element);
            if (!(el !== null && el !== void 0 && el.contains(ev.target))) {
              me.doAutoClose.now();
            }
          }
        }
      });
    }
  }
  expandBegin(operation) {
    const me = this, {
      animation
    } = operation, {
      collapseDir,
      collapseTool,
      innerElement,
      panel
    } = me, {
      element
    } = panel;
    element.classList.remove("b-collapsed", "b-collapsing");
    me.restoreConfiguredSize();
    me.lockInnerSize(false);
    me.lockInnerSize();
    collapseTool === null || collapseTool === void 0 ? void 0 : collapseTool.element.classList.remove("b-collapsed");
    if (animation) {
      element.classList.add("b-collapsed", "b-expanding");
      animation.element = innerElement;
      animation.transform = {
        from: translateByDir[collapseDir].to,
        to: translateByDir[collapseDir].from
      };
      operation.animation = Animator.run(animation);
    }
  }
  expandEnd(operation) {
    super.expandEnd(operation);
    const {
      panel
    } = this;
    if (operation.completed) {
      panel.revealed = false;
    }
    panel.element.classList.remove("b-expanding");
  }
  expandRevert(operation) {
    super.expandRevert(operation);
    this.panel.element.classList.add("b-expanding");
  }
  get innerElement() {
    return this.panel.overlayElement;
  }
  get innerSizeElement() {
    return this.panel.element;
  }
  get toolsConfig() {
    const me = this, {
      direction
    } = me, config = super.toolsConfig, tool = me.recollapseTool;
    if (tool) {
      return _objectSpread2(_objectSpread2({}, config), {}, {
        recollapse: tool && ObjectHelper.assign({
          direction: direction.toLowerCase()
        }, tool)
      });
    }
    return config;
  }
  lockInnerSize(lock = true) {
    const me = this, {
      panel
    } = me, panelRect = lock && panel.rectangle(), inset = lock ? [0, 0, 0, 0] : "", innerRect = super.lockInnerSize(lock);
    if (lock) {
      inset[collapseExposeEdge[me.collapseDir]] = `-${panelRect[me.collapseDim] + 10}px`;
    }
    panel.element.style.clipPath = lock ? `inset(${inset.join(" ")})` : "";
    return innerRect;
  }
  onOverlayTransitionDone(ev) {
    const me = this, {
      panel
    } = me;
    if (ev.srcElement === panel.overlayElement && me.revealing) {
      me.revealing = false;
      me.onComplete(panel.revealed ? "reveal" : "unreveal");
    }
  }
  onRevealerClick() {
    this.toggleReveal();
  }
  splitHeaderItems({
    as,
    dock
  } = emptyObject$6) {
    var _this$panel2;
    return (_this$panel2 = this.panel) === null || _this$panel2 === void 0 ? void 0 : _this$panel2.splitHeaderItems({
      as,
      dock,
      overlay: true
    });
  }
  toggleReveal(state) {
    const {
      panel
    } = this, {
      element
    } = panel;
    if (panel.collapsed) {
      if (state == null) {
        state = !panel.revealed;
      }
      if (panel.revealed !== state && panel.trigger("beforeToggleReveal", {
        reveal: state
      }) !== false) {
        if (!state && element.contains(DomHelper.getActiveElement(element))) {
          panel.revertFocus(true);
        }
        this.revealing = true;
        panel.revealed = state;
      }
    }
  }
  updateRevealing(value) {
    const me = this, horzDirRe = /left|right/i, {
      panel
    } = me, dim = horzDirRe.test(me.collapseDir) ? "height" : "width";
    if (panel) {
      me.innerElement.style[dim] = "0px";
      me.innerElement.style[`min-${dim}`] = "100%";
      panel.element.classList[value ? "add" : "remove"]("b-panel-overlay-revealing");
    }
  }
  wrapCollapser(key, body) {
    var _panel$tools;
    const me = this, {
      collapseDir,
      panel
    } = me, {
      expandedHeaderDock,
      header,
      uiClassList
    } = panel, recollapse = (_panel$tools = panel.tools) === null || _panel$tools === void 0 ? void 0 : _panel$tools.recollapse, [before, after] = me.splitHeaderItems({
      dock: me.collapseDock,
      as: "element"
    }), horz = dockIsHorz[expandedHeaderDock], title = panel.hasHeader ? panel.title || (header === null || header === void 0 ? void 0 : header.title) || "\xA0" : null;
    if (recollapse) {
      recollapse.direction = collapseDir;
    }
    return ["overlayElement", {
      class: _objectSpread2(_objectSpread2({}, uiClassList), {}, {
        [`b-panel-overlay-header-${expandedHeaderDock}`]: 1,
        [`b-panel-overlay-${collapseDir}`]: 1,
        [`b-${horz ? "h" : "v"}box`]: 1,
        "b-panel-overlay": 1,
        "b-box-center": 1
      }),
      listeners: {
        transitionend: (ev) => me.onOverlayTransitionDone(ev)
      },
      children: {
        overlayHeaderElement: title && {
          tag: "header",
          class: new DomClassList(_objectSpread2(_objectSpread2({}, uiClassList), {}, {
            [`b-dock-${expandedHeaderDock}`]: 1,
            "b-panel-header": 1,
            "b-panel-overlay-header": 1
          }), header === null || header === void 0 ? void 0 : header.cls),
          children: [...before, {
            reference: "overlayTitleElement",
            html: title,
            class: _objectSpread2(_objectSpread2({}, uiClassList), {}, {
              [`b-align-${(header === null || header === void 0 ? void 0 : header.titleAlign) || "start"}`]: 1,
              "b-header-title": 1
            })
          }, ...after]
        },
        [key]: body
      }
    }];
  }
};
PanelCollapserOverlay.initClass();
PanelCollapserOverlay._$name = "PanelCollapserOverlay";
var PasswordField = class extends Field {
  static get type() {
    return "passwordfield";
  }
  static get alias() {
    return "password";
  }
  static get $name() {
    return "PasswordField";
  }
  construct(config = {}) {
    config.inputType = "password";
    super.construct(...arguments);
    this.element.classList.add("b-textfield");
  }
};
PasswordField.initClass();
PasswordField._$name = "PasswordField";
var Radio = class extends Checkbox {
  static get $name() {
    return "Radio";
  }
  static get type() {
    return "radio";
  }
  static get alias() {
    return "radiobutton";
  }
  static get configurable() {
    return {
      inputType: "radio",
      clearable: null,
      uncheckedValue: void 0
    };
  }
  get textLabelCls() {
    return super.textLabelCls + " b-radio-label";
  }
  internalOnClick(info) {
    if (super.internalOnClick(info) !== false) {
      if (this.checked && this.clearable) {
        this.checked = false;
      }
    }
  }
  updateName(name) {
    this.toggleGroup = name;
  }
  updateClearable() {
  }
};
Radio.initClass();
Radio._$name = "Radio";
var RadioGroup = class extends FieldSet {
  static get $name() {
    return "RadioGroup";
  }
  static get type() {
    return "radiogroup";
  }
  static get configurable() {
    return {
      defaultType: "radio",
      clearable: null,
      name: null,
      options: {
        value: null,
        $config: {
          merge: "items"
        }
      },
      defaultBindProperty: "value"
    };
  }
  get existingOptions() {
    const {
      name
    } = this;
    return this.ensureItems().filter((c) => c.name === name);
  }
  get refPrefix() {
    return `${this.name || this.ref || this.id}_`;
  }
  get selected() {
    return this.existingOptions.filter((c) => c.input.checked)[0] || null;
  }
  get value() {
    const {
      selected
    } = this;
    return selected ? selected.checkedValue : null;
  }
  set value(v) {
    this.existingOptions.forEach((c) => {
      c.isConfiguring = this.isConfiguring;
      c.checked = c.checkedValue === v;
      c.isConfiguring = false;
    });
  }
  ensureItems() {
    this.getConfig("options");
    return super.ensureItems();
  }
  changeOptions(options, was) {
    if (!(options && was && ObjectHelper.isDeeplyEqual(was, options))) {
      return options;
    }
  }
  convertOption(key, option, existing) {
    const me = this, {
      name
    } = me, ret = {
      name,
      type: "radio",
      value: key === me.value,
      ref: `${me.refPrefix}${key}`,
      checkedValue: key
    };
    if (typeof option === "string") {
      ret.text = option;
    } else {
      ObjectHelper.assign(ret, option);
    }
    return existing ? Widget.reconfigure(existing, ret) : ret;
  }
  isOurRadio(item) {
    return item.isRadio && item.name === this.name;
  }
  isolateFieldChange(field) {
    return this.isOurRadio(field);
  }
  onChildAdd(item) {
    super.onChildAdd(item);
    if (this.isOurRadio(item)) {
      item.ion({
        name: item.id,
        beforeChange: "onRadioItemBeforeChange",
        change: "onRadioItemChange",
        click: "onRadioClick",
        thisObj: this
      });
    }
  }
  onChildRemove(item) {
    if (this.isOurRadio(item)) {
      this.detachListeners(item.id);
    }
    super.onChildRemove(item);
  }
  onRadioClick(ev) {
    const {
      source
    } = ev;
    if (source.checked && this.clearable && source.clearable == null) {
      source.checked = false;
    }
  }
  onRadioItemBeforeChange(ev) {
    if (ev.checked) {
      const me = this, {
        lastValue
      } = me;
      if (!me.reverting && me.trigger("beforeChange", me.wrapRadioEvent(ev)) === false) {
        if (lastValue != null && lastValue !== me.value) {
          me.reverting = true;
          ev.source.uncheckToggleGroupMembers();
          me.value = lastValue;
          me.lastValue = lastValue;
          me.reverting = false;
          return false;
        }
      }
    }
  }
  onRadioItemChange(ev) {
    const me = this;
    if (ev.checked && !me.reverting) {
      me.triggerFieldChange(me.wrapRadioEvent(ev));
      me.lastValue = me.value;
    }
  }
  wrapRadioEvent(ev) {
    return {
      from: ev,
      item: ev.source,
      userAction: ev.userAction,
      lastValue: this.lastValue,
      value: this.value
    };
  }
  updateOptions() {
    const me = this, {
      options,
      refPrefix
    } = me, existingOptions = me.existingOptions.reduce((m, c) => {
      m[c.ref.substring(refPrefix.length)] = c;
      return m;
    }, {});
    let index = 0, key, option;
    if (options) {
      for (key in options) {
        option = me.convertOption(key, options[key], existingOptions[key]);
        delete existingOptions[key];
        me.insert(option, index++);
      }
    }
    const existing = Object.values(existingOptions);
    if (existing !== null && existing !== void 0 && existing.length) {
      me.remove(existing);
      existing.forEach((c) => c.destroy());
    }
  }
};
RadioGroup.initClass();
RadioGroup._$name = "RadioGroup";
var arrowKeys = {
  ArrowUp: 1,
  ArrowDown: 1,
  ArrowLeft: 1,
  ArrowRight: 1
};
var Slider = class extends Widget {
  static get $name() {
    return "Slider";
  }
  static get type() {
    return "slider";
  }
  static get configurable() {
    return {
      text: null,
      showValue: true,
      showTooltip: false,
      min: 0,
      max: 100,
      step: 1,
      value: 50,
      unit: null,
      thumbSize: 20,
      tooltip: {
        $config: ["lazy", "nullify"],
        value: {
          type: "tooltip",
          align: "b-t",
          anchor: false,
          axisLock: true
        }
      },
      localizableProperties: ["text"],
      triggerChangeOnInput: null,
      defaultBindProperty: "value"
    };
  }
  compose() {
    const {
      id,
      min: min2,
      max,
      showValue,
      step,
      text,
      value,
      unit = "",
      disabled
    } = this, inputId = `${id}-input`, hasText = Boolean(text || showValue);
    return {
      class: {
        "b-has-label": hasText,
        "b-text": hasText,
        "b-disabled": disabled
      },
      children: {
        input: {
          tag: "input",
          type: "range",
          id: inputId,
          reference: "input",
          disabled,
          min: min2,
          max,
          step,
          value,
          listeners: {
            input: "onInternalInput",
            change: "onInternalChange",
            mouseover: "onInternalMouseOver",
            mouseout: "onInternalMouseOut"
          }
        },
        label: {
          tag: "label",
          for: inputId,
          html: showValue ? text ? `${text} (${value}${unit})` : value + unit : text
        }
      }
    };
  }
  get focusElement() {
    return this.input;
  }
  get percentProgress() {
    return (this.value - this.min) / (this.max - this.min) * 100;
  }
  onInternalKeyDown(e) {
    if (!this.readOnly && arrowKeys[e.key]) {
      e.stopImmediatePropagation();
    }
  }
  onInternalChange() {
    this.updateUI();
    this.triggerChange(true);
    this.trigger("action", {
      value: this.value
    });
  }
  onInternalInput() {
    const me = this;
    if (me.readOnly) {
      me.input.value = me.value;
      return;
    }
    me.value = parseInt(me.input.value, 10);
    me.trigger("input", {
      value: me.value
    });
    if (me.triggerChangeOnInput) {
      me.triggerChange(me);
    }
  }
  onInternalMouseOver() {
    var _me$tooltip;
    const me = this, thumbPosition = me.rtl ? 100 - me.percentProgress : me.percentProgress;
    (_me$tooltip = me.tooltip) === null || _me$tooltip === void 0 ? void 0 : _me$tooltip.showBy({
      target: Rectangle.from(me.input).inflate(me.thumbSize / 2, -me.thumbSize / 2),
      align: `b-t${Math.round(thumbPosition)}`
    });
  }
  onInternalMouseOut() {
    var _this$tooltip;
    (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.hide();
  }
  triggerChange(userAction) {
    this.triggerFieldChange({
      value: this.value,
      valid: true,
      userAction
    });
  }
  updateMax(max) {
    const me = this;
    if (me.input && me._value > max) {
      me.value = max;
      me.trigger("input", {
        value: me.value
      });
    }
  }
  updateMin(min2) {
    const me = this;
    if (me.input && me._value < min2) {
      me.value = min2;
      me.trigger("input", {
        value: me.value
      });
    }
  }
  changeTooltip(config, existingTooltip) {
    var _this$unit;
    if (config) {
      config.owner = this;
    }
    return this.showTooltip ? Tooltip.reconfigure(existingTooltip, config, {
      owner: this,
      defaults: {
        forElement: this.input,
        html: String(this.value) + ((_this$unit = this.unit) !== null && _this$unit !== void 0 ? _this$unit : "")
      }
    }) : null;
  }
  changeValue(value) {
    const me = this, {
      min: min2,
      step
    } = me;
    value = Math.min(Math.max(value, min2), me.max);
    if (value > min2) {
      return min2 + ObjectHelper.roundTo(value - min2, step);
    }
    return ObjectHelper.roundTo(value, step);
  }
  updateValue(value) {
    const me = this, {
      input,
      _tooltip
    } = me;
    if (_tooltip) {
      var _me$unit;
      _tooltip.html = me.value + ((_me$unit = me.unit) !== null && _me$unit !== void 0 ? _me$unit : "");
    }
    if (input && input.value !== String(value)) {
      input.value = value;
      me.triggerChange(false);
    }
    me.updateUI();
  }
  updateUI() {
    var _me$_tooltip, _me$_tooltip2;
    const me = this;
    ((_me$_tooltip = me._tooltip) === null || _me$_tooltip === void 0 ? void 0 : _me$_tooltip.isVisible) && ((_me$_tooltip2 = me._tooltip) === null || _me$_tooltip2 === void 0 ? void 0 : _me$_tooltip2.alignTo({
      target: Rectangle.from(me.input).inflate(me.thumbSize / 2, -me.thumbSize / 2),
      align: `b-t${Math.round(me.percentProgress)}`
    }));
  }
};
Slider.initClass();
Slider._$name = "Slider";
var SlideToggle = class extends Checkbox {
  static get $name() {
    return "SlideToggle";
  }
  static get type() {
    return "slidetoggle";
  }
  static get properties() {
    return {
      toggledCls: "b-slidetoggle-checked"
    };
  }
  construct(config) {
    if (config !== null && config !== void 0 && config.checked) {
      config.cls = (config.cls || "") + " " + this.constructor.properties.toggledCls;
    }
    super.construct(config);
  }
  get innerElements() {
    const innerEls = super.innerElements;
    innerEls.splice(1, 0, this.toggleElement);
    if (this.text) {
      innerEls[innerEls.length - 1].class = "b-slidetoggle-label";
    } else {
      innerEls.pop();
    }
    return innerEls;
  }
  get toggleElement() {
    return {
      class: "b-slidetoggle-toggle",
      reference: "slideToggle",
      children: [{
        class: "b-slidetoggle-thumb",
        reference: "slideThumb"
      }]
    };
  }
  internalOnChange() {
    super.internalOnChange();
    this.element.classList[this.value ? "add" : "remove"](this.toggledCls);
  }
};
SlideToggle.initClass();
SlideToggle._$name = "SlideToggle";
var classesHV = ["b-horizontal", "b-vertical"];
var hasFlex = (el) => DomHelper.getStyleValue(el.parentElement, "display") === "flex" && (parseInt(DomHelper.getStyleValue(el, "flex-basis"), 10) || parseInt(DomHelper.getStyleValue(el, "flex-grow"), 10));
var verticality = {
  horizontal: false,
  vertical: true
};
var Splitter = class extends Widget {
  static get $name() {
    return "Splitter";
  }
  static get type() {
    return "splitter";
  }
  static get configurable() {
    return {
      orientation: "auto",
      vertical: null,
      containerElement: {
        $config: "nullify",
        value: null
      },
      nextNeighbor: {
        $config: "nullify",
        value: null
      },
      previousNeighbor: {
        $config: "nullify",
        value: null
      }
    };
  }
  static get delayable() {
    return {
      syncState: "raf"
    };
  }
  doDestroy() {
    var _this$mouseDetacher;
    (_this$mouseDetacher = this.mouseDetacher) === null || _this$mouseDetacher === void 0 ? void 0 : _this$mouseDetacher.call(this);
    super.doDestroy();
  }
  compose() {
    return {
      class: {
        "b-splitter": 1
      },
      listeners: _objectSpread2({
        pointerdown: "onMouseDown",
        mouseenter: "syncState"
      }, !BrowserHelper.supportsPointerEvents && {
        mousedown: "onMouseDown",
        touchstart: "onMouseDown"
      })
    };
  }
  get currentOrientation() {
    return this.vertical ? "vertical" : "horizontal";
  }
  get nextWidget() {
    return Widget.fromElement(this.element.nextElementSibling, 1);
  }
  get previousWidget() {
    return Widget.fromElement(this.element.previousElementSibling, 1);
  }
  updateContainerElement(containerElement) {
    var _me$stateDetector;
    const me = this;
    me.stateDetector = (_me$stateDetector = me.stateDetector) === null || _me$stateDetector === void 0 ? void 0 : _me$stateDetector.disconnect();
    if (containerElement) {
      me.stateDetector = new MutationObserver(() => me.syncState());
      me.stateDetector.observe(containerElement, {
        attributes: true,
        childList: true
      });
    }
  }
  updateNextNeighbor(next) {
    this.watchNeighbor(next, "next");
  }
  updatePreviousNeighbor(previous) {
    this.watchNeighbor(previous, "previous");
  }
  watchNeighbor(neighbor, name) {
    this.detachListeners(name);
    neighbor === null || neighbor === void 0 ? void 0 : neighbor.ion({
      name,
      thisObj: this,
      collapse: "syncState",
      expand: "syncState",
      hide: "syncState",
      show: "syncState"
    });
  }
  updateOrientation() {
    this.syncState.now();
  }
  updateVertical(vertical) {
    var _this$element;
    const classList = (_this$element = this.element) === null || _this$element === void 0 ? void 0 : _this$element.classList;
    classList === null || classList === void 0 ? void 0 : classList.add(classesHV[vertical ? 1 : 0]);
    classList === null || classList === void 0 ? void 0 : classList.remove(classesHV[vertical ? 0 : 1]);
  }
  syncState() {
    var _verticality$me$orien;
    const me = this, {
      element,
      nextWidget,
      previousWidget
    } = me;
    let vertical = (_verticality$me$orien = verticality[me.orientation]) !== null && _verticality$me$orien !== void 0 ? _verticality$me$orien : null;
    me.nextNeighbor = nextWidget;
    me.previousNeighbor = previousWidget;
    me.disabled = nextWidget && (nextWidget.collapsible && nextWidget.collapsed || nextWidget.hidden) || previousWidget && (previousWidget.collapsible && previousWidget.collapsed || previousWidget.hidden);
    if (vertical !== null && nextWidget && previousWidget) {
      me.containerElement = null;
    } else {
      me.containerElement = element.parentElement;
      if (me.rendered && element.offsetParent) {
        const flexDirection = DomHelper.getStyleValue(element.parentElement, "flex-direction");
        if (flexDirection) {
          vertical = !flexDirection.startsWith("column");
        } else {
          const previous = element.previousElementSibling, next = element.nextElementSibling;
          if (!previous || !next) {
            return;
          }
          const prevRect = previous.getBoundingClientRect(), nextRect = next.getBoundingClientRect(), topMost = prevRect.top < nextRect.top ? prevRect : nextRect, bottomMost = topMost === nextRect ? prevRect : nextRect;
          vertical = topMost.top === bottomMost.top;
        }
      }
    }
    me.vertical = vertical;
  }
  onMouseDown(event) {
    var _me$mouseDetacher;
    event.preventDefault();
    if (event.touches) {
      event = event.touches[0];
    }
    const me = this, {
      element
    } = me, prev = element.previousElementSibling, next = element.nextElementSibling, prevHasFlex = hasFlex(prev), nextHasFlex = hasFlex(next), flexed = [];
    (_me$mouseDetacher = me.mouseDetacher) === null || _me$mouseDetacher === void 0 ? void 0 : _me$mouseDetacher.call(me);
    for (const child of element.parentElement.children) {
      if (hasFlex(child) && child !== element) {
        flexed.push({
          element: child,
          width: child.offsetWidth,
          height: child.offsetHeight
        });
      }
    }
    me.context = {
      startX: event.pageX,
      startY: event.pageY,
      prevWidth: prev.offsetWidth,
      prevHeight: prev.offsetHeight,
      nextWidth: next.offsetWidth,
      nextHeight: next.offsetHeight,
      prevHasFlex,
      nextHasFlex,
      flexed,
      prev,
      next
    };
    const events = {
      element: document,
      pointermove: "onMouseMove",
      pointerup: "onMouseUp",
      thisObj: me
    };
    if (!BrowserHelper.supportsPointerEvents) {
      events.mousemove = events.touchmove = "onMouseMove";
      events.mouseup = events.touchend = "onMouseUp";
    }
    element.classList.add("b-moving");
    me.mouseDetacher = EventHelper.on(events);
  }
  onMouseMove(event) {
    const me = this, {
      context,
      nextWidget,
      previousWidget
    } = me, prevStyle = context.prev.style, nextStyle = context.next.style, deltaX = (event.pageX - context.startX) * (me.rtl ? -1 : 1), deltaY = event.pageY - context.startY;
    event.preventDefault();
    Object.assign(context, {
      deltaX,
      deltaY
    });
    if (!context.started) {
      context.started = true;
      me.trigger("dragStart", {
        context,
        event
      });
      context.flexed.forEach((flexed) => {
        flexed.element.style.flexGrow = me.vertical ? flexed.width : flexed.height;
        flexed.element.style.flexBasis = "0";
      });
    }
    if (me.vertical) {
      const newPrevWidth = context.prevWidth + deltaX, newNextWidth = context.nextWidth - deltaX;
      if (context.prevHasFlex) {
        prevStyle.flexGrow = newPrevWidth;
      } else if (previousWidget) {
        previousWidget.width = newPrevWidth;
      } else {
        prevStyle.width = `${newPrevWidth}px`;
      }
      if (context.nextHasFlex) {
        nextStyle.flexGrow = newNextWidth;
      } else if (nextWidget) {
        nextWidget.width = newNextWidth;
      } else {
        nextStyle.width = `${newNextWidth}px`;
      }
    } else {
      const newPrevHeight = context.prevHeight + deltaY, newNextHeight = context.nextHeight - deltaY;
      if (context.prevHasFlex) {
        prevStyle.flexGrow = newPrevHeight;
      } else if (previousWidget) {
        previousWidget.height = newPrevHeight;
      } else {
        prevStyle.height = `${newPrevHeight}px`;
      }
      if (context.nextHasFlex) {
        nextStyle.flexGrow = newNextHeight;
      } else if (nextWidget) {
        nextWidget.height = newNextHeight;
      } else {
        nextStyle.height = `${newNextHeight}px`;
      }
    }
    me.trigger("drag", {
      context,
      event
    });
  }
  onMouseUp(event) {
    var _me$mouseDetacher2;
    const me = this;
    (_me$mouseDetacher2 = me.mouseDetacher) === null || _me$mouseDetacher2 === void 0 ? void 0 : _me$mouseDetacher2.call(me);
    me.mouseDetacher = null;
    me.element.classList.remove("b-moving");
    if (me.context.started) {
      me.trigger("drop", {
        context: me.context,
        event
      });
    }
    me.context = null;
  }
  render() {
    super.render(...arguments);
    this.syncState.now();
    if (this.vertical === null) {
      this.syncState();
    }
  }
};
Splitter.initClass();
Splitter._$name = "Splitter";
var Tab = class extends Button {
  static get $name() {
    return "Tab";
  }
  static get type() {
    return "tab";
  }
  static get configurable() {
    return {
      active: null,
      index: null,
      isFirst: null,
      isLast: null,
      item: {
        value: null,
        $config: "nullify"
      },
      itemCls: null,
      tabPanel: null,
      titleProperty: "text",
      titleSource: "title",
      role: "tab"
    };
  }
  compose() {
    const {
      active,
      cls,
      index,
      isFirst,
      isLast
    } = this, setSize = this.owner.visibleChildCount;
    return {
      tabindex: 0,
      "aria-selected": active,
      "aria-setsize": setSize,
      "aria-posinset": index + 1,
      class: _objectSpread2({
        "b-tabpanel-tab": 1,
        "b-active": active,
        "b-tab-first": isFirst,
        "b-tab-last": isLast
      }, cls),
      dataset: {
        index
      }
    };
  }
  updateIndex(index) {
    this.isFirst = !index;
  }
  updateItem(item, was) {
    var _me$itemChangeDetache, _me$itemHideDetacher;
    const me = this;
    if ((was === null || was === void 0 ? void 0 : was.tab) === me) {
      was.tab = null;
    }
    if (item) {
      item.tab = me;
      me[me.titleProperty] = item[me.titleSource];
      me.itemCls = item.cls;
      me.ariaElement.setAttribute("aria-controls", item.id);
      item.role = "tabpanel";
    }
    (_me$itemChangeDetache = me.itemChangeDetacher) === null || _me$itemChangeDetache === void 0 ? void 0 : _me$itemChangeDetache.call(me);
    me.itemChangeDetacher = item && FunctionHelper.after(item, "onConfigChange", "onItemConfigChange", me, {
      return: false
    });
    (_me$itemHideDetacher = me.itemHideDetacher) === null || _me$itemHideDetacher === void 0 ? void 0 : _me$itemHideDetacher.call(me);
    me.itemHideDetacher = item === null || item === void 0 ? void 0 : item.ion({
      beforeChangeHidden: "onItemBeforeChangeHidden",
      beforeHide: "onItemBeforeHide",
      beforeUpdateDisabled: "onItemBeforeUpdateDisabled",
      thisObj: me,
      prio: 1e3
    });
    me.syncMinMax();
  }
  updateItemCls(cls, was) {
    const {
      element
    } = this, classList = element && DomClassList.from(element === null || element === void 0 ? void 0 : element.classList, true);
    if (element) {
      classList.remove(was).add(cls);
      element.className = classList.value;
    }
  }
  updateRotate(rotate, was) {
    if (!rotate !== !was) {
      this.syncMinMax();
    }
  }
  syncMinMax() {
    const me = this, {
      rotate,
      tabPanel
    } = me;
    let {
      _minWidth: minWidth,
      _minHeight: minHeight,
      _maxWidth: maxWidth,
      _maxHeight: maxHeight
    } = me;
    if (tabPanel) {
      const {
        tabMinWidth,
        tabMaxWidth
      } = tabPanel;
      if (tabMinWidth != null) {
        if (rotate) {
          if (minWidth === tabMinWidth) {
            minWidth = null;
          }
          minHeight = tabMinWidth;
        } else {
          if (minHeight === tabMinWidth) {
            minHeight = null;
          }
          minWidth = tabMinWidth;
        }
      }
      if (tabMaxWidth != null) {
        if (rotate) {
          if (maxWidth === tabMaxWidth) {
            maxWidth = null;
          }
          maxHeight = tabMaxWidth;
        } else {
          if (maxHeight === tabMaxWidth) {
            maxHeight = null;
          }
          maxWidth = tabMaxWidth;
        }
      }
      me.minWidth = minWidth;
      me.minHeight = minHeight;
      me.maxWidth = maxWidth;
      me.maxHeight = maxHeight;
    }
  }
  onItemBeforeChangeHidden({
    source: hidingChild,
    hidden
  }) {
    if (!hidingChild.$isDeactivating && !hidingChild.$isActivating) {
      const {
        tabPanel
      } = this;
      this.hidden = hidden;
      if (hidden && hidingChild === tabPanel.activeItem) {
        tabPanel.activateAvailableTab(hidingChild);
      }
    }
  }
  onItemBeforeHide() {
    if (!this.item.$isDeactivating) {
      this.hide();
    }
  }
  onItemBeforeUpdateDisabled({
    source: disablingChild,
    disabled
  }) {
    const {
      tabPanel
    } = this;
    this.disabled = disabled;
    if (disablingChild === tabPanel.activeItem) {
      tabPanel.activateAvailableTab(disablingChild);
    }
  }
  onItemConfigChange({
    name,
    value
  }) {
    if (name === this.titleSource) {
      this[this.titleProperty] = value;
    }
  }
};
Tab.initClass();
Tab._$name = "Tab";
var isTab = (t) => t.isTab;
var TabBar = class extends Toolbar {
  static get $name() {
    return "TabBar";
  }
  static get type() {
    return "tabbar";
  }
  static get configurable() {
    return {
      defaultType: "tab",
      overflow: "scroll",
      role: "tablist",
      ignoreParentReadOnly: true
    };
  }
  get firstTab() {
    return this.tabAt(0);
  }
  get lastTab() {
    return this.tabAt(-1);
  }
  get tabCount() {
    return this._items.countOf(isTab);
  }
  get tabs() {
    return ArrayHelper.from(this._items, isTab);
  }
  compose() {
    return {
      children: {
        toolbarContent: {
          class: {
            "b-tabpanel-tabs": 1
          }
        }
      }
    };
  }
  indexOfTab(tab) {
    return this._items.indexOf(tab, isTab);
  }
  onChildAdd(child) {
    super.onChildAdd(child);
    if (child.index == null) {
      this.syncTabs();
    }
  }
  onChildRemove(child) {
    super.onChildRemove(child);
    this.syncTabs();
  }
  onFocusIn() {
    const {
      activeIndex
    } = this.owner;
    if (!isNaN(activeIndex)) {
      this.tabs[activeIndex].focus();
    }
  }
  syncTabs() {
    const {
      tabs
    } = this;
    for (let i = 0, n = tabs.length; i < n; ++i) {
      tabs[i].index = i;
      tabs[i].isFirst = !i;
      tabs[i].isLast = i === n - 1;
    }
  }
  tabAt(index) {
    return this._items.find(isTab, index) || null;
  }
};
TabBar.initClass();
TabBar._$name = "TabBar";
var animationClasses = ["b-slide-out-left", "b-slide-out-right", "b-slide-in-left", "b-slide-in-right"];
var Card = class extends Layout {
  onChildAdd(item) {
    super.onChildAdd(item);
    const me = this, {
      activeItem,
      owner
    } = me, activeIndex = owner.activeIndex != null ? owner.activeIndex : me.activeIndex || 0, itemIndex = owner.items.indexOf(item), isActive = activeItem != null ? item === activeItem : itemIndex === activeIndex;
    item.ion({
      beforeHide: "onBeforeChildHide",
      beforeShow: "onBeforeChildShow",
      thisObj: me
    });
    if (isActive) {
      me._activeIndex = itemIndex;
      me._activeItem = item;
      item.show();
    } else {
      item.$isDeactivating = true;
      item.hide();
      item.$isDeactivating = false;
    }
  }
  onChildRemove(item) {
    super.onChildRemove(item);
    const me = this;
    if (me._activeItem === item) {
      me.activateSiblingOf(item);
    }
    me._activeIndex = me.owner.items.indexOf(me._activeItem);
    item.un({
      beforeHide: "onBeforeChildHide",
      beforeShow: "onBeforeChildShow",
      thisObj: me
    });
  }
  onBeforeChildShow({
    source: showingChild
  }) {
    if (!this.owner.isConfiguring && !showingChild.$isActivating) {
      this.activeItem = showingChild;
      return false;
    }
  }
  onBeforeChildHide({
    source: hidingChild
  }) {
    if (!this.owner.isConfiguring && !hidingChild.$isDeactivating) {
      this.activateSiblingOf(hidingChild);
      return false;
    }
  }
  activateSiblingOf(item) {
    const {
      owner
    } = this, items2 = owner.items.slice(), removeAt = items2.indexOf(item);
    items2.splice(removeAt, 1);
    this.activeIndex = Math.min(removeAt, items2.length - 1);
  }
  setActiveItem(activeIndex, prevActiveIndex = this.activeIndex, options) {
    const me = this, {
      owner
    } = me, {
      items: items2
    } = owner, widgetPassed = activeIndex instanceof Widget, prevActiveItem = items2[prevActiveIndex], newActiveItem = owner.items[activeIndex = widgetPassed ? items2.indexOf(activeIndex) : parseInt(activeIndex, 10)], animation = (options === null || options === void 0 ? void 0 : options.animation) !== false, chatty = !(options !== null && options !== void 0 && options.silent), event = {
      prevActiveIndex,
      prevActiveItem
    };
    if (newActiveItem && !newActiveItem.$isActivating && newActiveItem !== prevActiveItem) {
      var _owner$onBeginActiveI;
      const prevItemElement = prevActiveItem && prevActiveItem.element, newActiveElement = newActiveItem && newActiveItem.element;
      if (me.animateDetacher) {
        const activeCardChange = me.animateDetacher.event;
        if (activeCardChange.activeItem === newActiveItem) {
          return activeCardChange.promise;
        }
        me.animateDetacher();
        activeCardChange.prevActiveItem.element.classList.remove(...animationClasses);
        activeCardChange.activeItem.element.classList.remove(...animationClasses);
        me.animateDetacher = null;
      }
      event.activeIndex = activeIndex;
      event.activeItem = newActiveItem;
      if (chatty && owner.trigger("beforeActiveItemChange", event) === false) {
        return null;
      }
      const reset = me._activeIndex !== event.activeIndex;
      if (reset) {
        me._activeIndex = event.activeIndex;
      }
      chatty && ((_owner$onBeginActiveI = owner.onBeginActiveItemChange) === null || _owner$onBeginActiveI === void 0 ? void 0 : _owner$onBeginActiveI.call(owner, event));
      if (reset) {
        me._activeIndex = event.prevActiveIndex;
      }
      if (animation && prevItemElement && owner.isVisible && me.animateCardChange) {
        event.promise = me.cardChangeAnimation = new Promise((resolve, reject) => {
          const wasMonitoringSize = prevActiveItem.monitorResize;
          prevActiveItem.monitorResize = false;
          me.contentElement.style.overflowX = "hidden";
          prevActiveItem._hidden = true;
          newActiveItem.$isActivating = true;
          newActiveItem.show();
          newActiveItem.$isActivating = false;
          prevItemElement.classList.add(activeIndex > prevActiveIndex ? "b-slide-out-left" : "b-slide-out-right");
          newActiveElement.classList.add(activeIndex < prevActiveIndex ? "b-slide-in-left" : "b-slide-in-right");
          owner.isAnimating = true;
          me.animateDetacher = EventHelper.onTransitionEnd({
            mode: "animation",
            element: newActiveElement,
            thisObj: prevActiveItem,
            handler() {
              owner.isAnimating = me.cardChangeAnimation = false;
              if (!me.animateDetacher) {
                me.setActiveItem(activeIndex, prevActiveIndex, options);
                return;
              }
              me.animateDetacher = null;
              newActiveElement.classList.remove(...animationClasses);
              if (prevItemElement) {
                prevItemElement.classList.remove(...animationClasses);
                prevActiveItem.$isDeactivating = true;
                prevActiveItem._hidden = false;
                prevActiveItem.hide();
                prevActiveItem.monitorResize = wasMonitoringSize;
                prevActiveItem.$isDeactivating = false;
              }
              me.contentElement.style.overflowX = "";
              me.onActiveItemChange(event, resolve, !chatty);
            }
          });
          me.animateDetacher.reject = reject;
          me.animateDetacher.event = event;
        });
      } else {
        newActiveItem.$isActivating = true;
        newActiveItem.show();
        newActiveItem.focus();
        newActiveItem.$isActivating = false;
        if (prevActiveItem) {
          prevActiveItem.$isDeactivating = true;
          prevActiveItem.hide();
          prevActiveItem.$isDeactivating = false;
        }
        me.onActiveItemChange(event, null, !chatty);
      }
    }
    return event;
  }
  onActiveItemChange(event, resolve, silent) {
    const me = this;
    me._activeItem = event.activeItem;
    me._activeIndex = event.activeIndex;
    !silent && me.owner.trigger("activeItemChange", event);
    event.activeItem.focus();
    resolve === null || resolve === void 0 ? void 0 : resolve(event);
  }
  renderChildren() {
    const {
      owner
    } = this;
    owner.contentElement.classList.toggle(this.hideChildHeaderCls, owner.suppressChildHeaders);
    super.renderChildren();
  }
  changeActiveIndex(activeIndex) {
    const {
      owner
    } = this;
    return owner.isConfiguring && !owner._items ? activeIndex : Math.min(activeIndex, owner.items.length - 1);
  }
  updateActiveIndex(activeIndex, oldActiveIndex) {
    if (!this.owner.isConfiguring) {
      this.setActiveItem(activeIndex, oldActiveIndex);
    }
  }
  updateActiveItem(activeItem) {
    if (!this.owner.isConfiguring) {
      this.setActiveItem(activeItem, this.activeIndex);
    }
  }
  get isChangingCard() {
    return Boolean(this.animateDetacher);
  }
};
_defineProperty(Card, "$name", "Card");
_defineProperty(Card, "type", "card");
_defineProperty(Card, "configurable", {
  containerCls: "b-card-container",
  itemCls: "b-card-item",
  hideChildHeaderCls: "b-hide-child-headers",
  animateCardChange: true,
  activeItem: null,
  activeIndex: null
});
Card.initClass();
Card._$name = "Card";
var TabPanel = class extends Panel {
  static get $name() {
    return "TabPanel";
  }
  static get type() {
    return "tabpanel";
  }
  static get alias() {
    return "tabs";
  }
  static get configurable() {
    return {
      activeTab: 0,
      animateTabChange: true,
      autoHeight: false,
      defaultType: "container",
      focusable: false,
      itemCls: "b-tabpanel-item",
      layout: {
        type: "card"
      },
      suppressChildHeaders: true,
      tabBar: {
        type: "tabbar",
        weight: -2e3
      },
      tabMinWidth: null,
      tabMaxWidth: null
    };
  }
  get activeIndex() {
    return this.layout.activeIndex;
  }
  get activeItem() {
    return this.layout.activeItem;
  }
  get activeTabItemIndex() {
    var _tabBar$tabs$activeTa;
    const {
      activeTab,
      items: items2,
      tabBar
    } = this;
    return items2.indexOf((_tabBar$tabs$activeTa = tabBar.tabs[activeTab]) === null || _tabBar$tabs$activeTa === void 0 ? void 0 : _tabBar$tabs$activeTa.item);
  }
  get bodyConfig() {
    return ObjectHelper.merge({
      className: {
        "b-tabpanel-body": 1
      }
    }, super.bodyConfig);
  }
  get focusElement() {
    var _activeTab$tab;
    const activeTab = this.items[this.activeTab || 0];
    return (activeTab === null || activeTab === void 0 ? void 0 : activeTab.focusElement) || (activeTab === null || activeTab === void 0 ? void 0 : (_activeTab$tab = activeTab.tab) === null || _activeTab$tab === void 0 ? void 0 : _activeTab$tab.focusElement);
  }
  get tabPanelBody() {
    return this.bodyElement;
  }
  finalizeInit() {
    super.finalizeInit();
    const me = this, {
      activeTab,
      layout
    } = me, {
      activeIndex
    } = layout, {
      tabs
    } = me.tabBar, activeTabItemIndex = activeTab >= 0 && activeTab < tabs.length && me.items.indexOf(tabs[activeTab].item);
    if (tabs.length > 0 && (activeTabItemIndex === false || activeTabItemIndex < 0)) {
      throw new Error(`Invalid activeTab ${activeTab} (${tabs.length} tabs)`);
    }
    if (activeTabItemIndex !== activeIndex) {
      layout.setActiveItem(activeTabItemIndex, activeIndex, {
        animation: false,
        silent: true
      });
    }
    layout.animateCardChange = me.animateTabChange;
  }
  onChildAdd(child) {
    super.onChildAdd(child);
    if (!this.initialItems) {
      const me = this, {
        tabBar
      } = me, config = me.makeTabConfig(child), firstTab = config && (tabBar === null || tabBar === void 0 ? void 0 : tabBar.firstTab), tabBarItems = firstTab && tabBar._items, tabItems = firstTab && ArrayHelper.from(me._items, (it) => it.tab || it === child), index = firstTab ? tabItems.indexOf(child) + tabBarItems.indexOf(firstTab) : 0;
      if (config && tabBar) {
        if (firstTab && child.weight == null && index < tabBarItems.count - 1) {
          tabBar.insert(config, index);
        } else {
          tabBar.add(config);
        }
      }
    }
  }
  onChildRemove(child) {
    const {
      tab
    } = child, {
      items: items2
    } = this;
    if (tab) {
      this.tabBar.remove(tab);
      tab.destroy();
    }
    if (child === this.activeItem) {
      this._activeTab = null;
      if (items2.length) {
        this.activeTab = items2[Math.min(this.activeIndex, items2.length - 1)];
      }
    }
    super.onChildRemove(child);
  }
  isDisabledOrHiddenTab(tabIndex) {
    const {
      tabs
    } = this.tabBar, tab = tabs === null || tabs === void 0 ? void 0 : tabs[tabIndex];
    return tab && (tab.disabled || tab.hidden);
  }
  findAvailableTab(item, delta = 1) {
    const {
      tabs
    } = this.tabBar, tabCount = tabs.length, itemIndex = Math.max(0, tabs.indexOf(item.tab));
    if (itemIndex) {
      delta = -delta;
    }
    let activeTab;
    for (let n = 1; n <= tabCount; ++n) {
      activeTab = (itemIndex + (delta < 0 ? tabCount : 0) + n * delta) % tabCount;
      if (!this.isDisabledOrHiddenTab(activeTab)) {
        break;
      }
    }
    return activeTab;
  }
  activateAvailableTab(item, delta = 1) {
    this.activeTab = this.findAvailableTab(item, delta);
  }
  changeActiveTab(activeTab, oldActiveTab) {
    const me = this, {
      tabBar,
      layout
    } = me, {
      tabCount
    } = tabBar;
    if (activeTab.isWidget || ObjectHelper.isObject(activeTab)) {
      if (me.items.indexOf(activeTab) === -1) {
        activeTab = me.add(activeTab);
      }
      activeTab = tabBar.indexOfTab(activeTab.tab);
    } else {
      activeTab = parseInt(activeTab, 10);
    }
    if (!me.initialItems && tabCount > 0 && (activeTab < -1 || activeTab >= tabCount)) {
      throw new Error(`Invalid activeTab ${activeTab} (${tabCount} tabs)`);
    }
    if (me.isDisabledOrHiddenTab(activeTab)) {
      activeTab = me.findAvailableTab(activeTab);
    }
    if (layout.animateCardChange && layout.cardChangeAnimation) {
      layout.cardChangeAnimation.then((cardChange) => {
        if ((cardChange === null || cardChange === void 0 ? void 0 : cardChange.activeIndex) !== activeTab) {
          me._activeTab = activeTab;
          me.updateActiveTab(activeTab, oldActiveTab);
        }
      });
    } else {
      return activeTab;
    }
  }
  async updateActiveTab() {
    if (!this.initialItems) {
      const {
        activeTabItemIndex,
        layout
      } = this;
      if (activeTabItemIndex > -1) {
        var _layout$setActiveItem;
        if (layout.animateCardChange) {
          await this.tabSelectionPromise;
        }
        this.tabSelectionPromise = (_layout$setActiveItem = layout.setActiveItem(this.items[activeTabItemIndex])) === null || _layout$setActiveItem === void 0 ? void 0 : _layout$setActiveItem.promise;
      }
    }
  }
  changeTabBar(bar) {
    this.getConfig("strips");
    this.strips = {
      tabBar: bar
    };
    return this.strips.tabBar;
  }
  makeTabConfig(item) {
    const {
      tab
    } = item, config = {
      item,
      type: "tab",
      tabPanel: this,
      disabled: Boolean(item.disabled),
      hidden: item.initialConfig.hidden,
      weight: item.weight || 0,
      internalListeners: {
        click: "onTabClick",
        thisObj: this
      },
      localizableProperties: {
        text: false
      }
    };
    if (tab === false) {
      return null;
    }
    return ObjectHelper.isObject(tab) ? Tab.mergeConfigs(config, tab) : config;
  }
  updateItems(items2, was) {
    const me = this, {
      activeTab,
      initialItems
    } = me;
    let index = 0, tabs;
    super.updateItems(items2, was);
    if (initialItems) {
      tabs = Array.from(items2, (it) => me.makeTabConfig(it)).filter((it) => {
        if (it) {
          it.index = index++;
          return true;
        }
      });
      if (index) {
        tabs[0].isFirst = true;
        tabs[index - 1].isLast = true;
        tabs[activeTab].active = true;
        me.tabBar.add(tabs);
        me.activeTab = activeTab;
      }
    }
  }
  updateTabMinWidth(tabMinWidth) {
    var _this$tabBar;
    (_this$tabBar = this.tabBar) === null || _this$tabBar === void 0 ? void 0 : _this$tabBar.items.forEach((tab) => {
      if (tab.isTab) {
        tab.minWidth = tabMinWidth;
      }
    });
  }
  updateTabMaxWidth(tabMaxWidth) {
    var _this$tabBar2;
    (_this$tabBar2 = this.tabBar) === null || _this$tabBar2 === void 0 ? void 0 : _this$tabBar2.items.forEach((tab) => {
      if (tab.isTab) {
        tab.maxWidth = tabMaxWidth;
      }
    });
  }
  updateAutoHeight(autoHeight) {
    this.detachListeners("themeAutoHeight");
    autoHeight && GlobalEvents$1.ion({
      name: "themeAutoHeight",
      theme: "internalOnThemeChange",
      thisObj: this
    });
    this.$measureHeight = autoHeight;
  }
  applyAutoHeight() {
    const me = this, {
      layout,
      activeTab,
      element
    } = me, {
      animateCardChange
    } = layout;
    layout.animateCardChange = false;
    me.height = null;
    me.height = Math.max(...me.items.map((tab) => {
      me.activeTab = tab;
      return element.clientHeight;
    })) + 1;
    me.activeTab = activeTab;
    layout.animateCardChange = animateCardChange;
    me.$measureHeight = false;
  }
  internalOnThemeChange() {
    if (this.isVisible) {
      this.applyAutoHeight();
    } else {
      this.$measureHeight = true;
    }
  }
  onBeginActiveItemChange(activeItemChangeEvent) {
    const tabs = this.tabBar.tabs, {
      activeItem,
      prevActiveItem
    } = activeItemChangeEvent;
    this.activeTab = tabs.indexOf(activeItem === null || activeItem === void 0 ? void 0 : activeItem.tab);
    if (prevActiveItem !== null && prevActiveItem !== void 0 && prevActiveItem.tab) {
      prevActiveItem.tab.active = false;
    }
    if (activeItem !== null && activeItem !== void 0 && activeItem.tab) {
      activeItem.tab.active = true;
      activeItem.tab.show();
    }
  }
  onBeforeActiveItemChange(activeItemChangeEvent) {
    return this.trigger("beforeTabChange", activeItemChangeEvent);
  }
  onActiveItemChange(activeItemChangeEvent) {
    this.trigger("tabChange", activeItemChangeEvent);
  }
  onTabClick(event) {
    this.activeTab = event.source.item;
  }
  onPaint() {
    super.onPaint(...arguments);
    if (this.$measureHeight) {
      this.applyAutoHeight();
    }
  }
};
TabPanel.initClass();
TabPanel._$name = "TabPanel";
var TextAreaField = class extends Field {
  static get $name() {
    return "TextAreaField";
  }
  static get type() {
    return "textareafield";
  }
  static get alias() {
    return "textarea";
  }
  static get configurable() {
    return {
      resize: "none",
      inputAttributes: {
        tag: "textarea"
      }
    };
  }
  updateResize(resize) {
    this.input.style.resize = resize;
  }
};
TextAreaField.initClass();
TextAreaField._$name = "TextAreaField";
var TextAreaPickerField = class extends PickerField {
  static get $name() {
    return "TextAreaPickerField";
  }
  static get type() {
    return "textareapickerfield";
  }
  static get configurable() {
    return {
      picker: {
        type: "widget",
        tag: "textarea",
        cls: "b-textareapickerfield-picker",
        scrollAction: "realign",
        align: {
          align: "t-b",
          axisLock: true
        },
        autoShow: false
      },
      triggers: {
        expand: {
          cls: "b-icon-picker",
          handler: "onTriggerClick"
        }
      },
      resize: "none",
      inputType: null
    };
  }
  startConfigure(config) {
    if (typeof config.inline === "boolean") {
      VersionHelper.deprecate("Core", "6.0.0", "TextAreaPickerField.inline config is no longer supported");
    }
    super.startConfigure(config);
  }
  get inputElement() {
    const result = super.inputElement;
    result.readOnly = "readonly";
    result.reference = "displayElement";
    this.ariaElement = "displayElement";
    return result;
  }
  get focusElement() {
    var _this$_picker;
    return (_this$_picker = this._picker) !== null && _this$_picker !== void 0 && _this$_picker.isVisible ? this.input : this.displayElement;
  }
  get needsInputSync() {
    var _this$inputValue;
    return this.displayElement[this.inputValueAttr] !== String((_this$inputValue = this.inputValue) !== null && _this$inputValue !== void 0 ? _this$inputValue : "");
  }
  showPicker() {
    const me = this, {
      picker
    } = me;
    if (!me.inline) {
      picker.width = me.pickerWidth || me[me.pickerAlignElement].offsetWidth;
      super.showPicker(true);
    }
  }
  focusPicker() {
    this.input.focus();
  }
  onPickerKeyDown(keyEvent) {
    const me = this, realInput = me.input;
    switch (keyEvent.key.trim() || keyEvent.code) {
      case "Escape":
        me.picker.hide();
        return;
      case "Enter":
        if (keyEvent.ctrlKey) {
          me.syncInputFieldValue();
          me.picker.hide();
        }
        break;
    }
    me.input = me.displayElement;
    const result = super.onPickerKeyDown(keyEvent);
    me.input = realInput;
    return result;
  }
  syncInputFieldValue(skipHighlight) {
    if (this.displayElement) {
      this.displayElement.value = this.inputValue;
    }
    super.syncInputFieldValue(skipHighlight);
  }
  changeValue(value) {
    return value == null ? "" : value;
  }
  changePicker(picker, oldPicker) {
    var _picker, _me$value;
    const me = this, pickerWidth = me.pickerWidth || ((_picker = picker) === null || _picker === void 0 ? void 0 : _picker.width);
    picker = TextAreaPickerField.reconfigure(oldPicker, picker ? Objects.merge({
      owner: me,
      forElement: me[me.pickerAlignElement],
      align: {
        matchSize: pickerWidth == null,
        anchor: me.overlayAnchor,
        target: me[me.pickerAlignElement]
      },
      id: me.id + "-input",
      style: {
        resize: me.resize
      },
      html: (_me$value = me.value) !== null && _me$value !== void 0 ? _me$value : ""
    }, picker) : null, me);
    if (picker) {
      const input = me.input = picker.element;
      me.inputListenerRemover = EventHelper.on({
        element: input,
        thisObj: me,
        focus: "internalOnInputFocus",
        change: "internalOnChange",
        input: "internalOnInput",
        keydown: "internalOnKeyEvent",
        keypress: "internalOnKeyEvent",
        keyup: "internalOnKeyEvent"
      });
    }
    return picker;
  }
};
TextAreaPickerField.initClass();
TextAreaPickerField._$name = "TextAreaPickerField";
var Minifiable = (Target) => {
  var _class;
  return _class = class Minifiable extends (Target || Base$1) {
    compose() {
      const {
        minified
      } = this;
      return {
        class: {
          "b-minified": minified
        }
      };
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "$name", "Minifiable"), _defineProperty(_class, "configurable", {
    minifiable: true,
    minified: null
  }), _class;
};
var EMPTY$1 = [];
var isStateName = (name) => name[0] !== "*";
var pop = (object, key) => {
  const ret = object[key] || null;
  delete object[key];
  return ret;
};
var responsiveRootFn = (widget) => widget.responsiveRoot;
var scoring = {
  number: (threshold) => ({
    width
  }) => width <= threshold && threshold
};
var splitConfigs = (configs) => {
  delete configs.once;
  return {
    callback: pop(configs, "callback"),
    configs,
    when: pop(configs, "when")
  };
};
var splitMergedConfigs = (cls, ...parts) => {
  const once = parts.flatMap((p) => (p === null || p === void 0 ? void 0 : p.once) || EMPTY$1), configs = cls.mergeConfigs(...parts), ret = splitConfigs(configs);
  ret.once = once.length ? splitConfigs(cls.mergeConfigs(...once)) : null;
  return ret;
};
var wrapWidget = (widget, handler) => {
  let triggers, desc = Proxy.revocable(widget, {
    get(o, name) {
      if (triggers) {
        triggers[name] = true;
      }
      return widget[name];
    }
  }), detacher2 = FunctionHelper.after(widget, "onConfigChange", (ignore, {
    name
  }) => {
    var _triggers;
    if ((_triggers = triggers) !== null && _triggers !== void 0 && _triggers[name]) {
      handler();
    }
  }), resizer = widget.ion({
    resize: () => {
      handler();
    }
  });
  widget.monitorResize = true;
  return {
    widget,
    get object() {
      var _desc;
      return (_desc = desc) === null || _desc === void 0 ? void 0 : _desc.proxy;
    },
    destroy() {
      if (desc) {
        desc.revoke();
        detacher2();
        resizer();
        desc = detacher2 = resizer = null;
      }
    },
    reset() {
      triggers = /* @__PURE__ */ Object.create(null);
    }
  };
};
var Responsive = (Target) => {
  var _class;
  return _class = class Responsive extends (Target || Base$1).mixin(Delayable, Fencible) {
    get isResponsivePending() {
      return this.responsiveUpdateCount === 0 && this.hasConfig("responsive");
    }
    get isResponsiveUpdating() {
      var _this$responsiveWidge;
      return this._responsiveUpdating || ((_this$responsiveWidge = this.responsiveWidget) === null || _this$responsiveWidge === void 0 ? void 0 : _this$responsiveWidge._responsiveUpdating);
    }
    updateResponsive(responsive) {
      const me = this, cls = me.constructor, {
        responsiveDefaults
      } = me, stateNames = Array.from(new Set(ObjectHelper.keys(responsive).concat(ObjectHelper.keys(responsiveDefaults)))).filter(isStateName);
      let states = null, hasWhen, name, state, when;
      if (responsive) {
        states = {
          "*": splitMergedConfigs(cls, responsiveDefaults["*"], responsive["*"])
        };
        for (name of stateNames) {
          state = responsive[name];
          if (state !== null && state !== false) {
            var _scoring$when;
            hasWhen = hasWhen || state && "when" in state;
            states[name] = splitMergedConfigs(cls, responsiveDefaults["*"], responsiveDefaults[name], responsive["*"], state);
            when = states[name].when;
            states[name].when = ((_scoring$when = scoring[typeof when]) === null || _scoring$when === void 0 ? void 0 : _scoring$when.call(scoring, when)) || when;
          }
        }
      }
      me.$responsiveStates = states;
      me.$responsiveWhen = hasWhen;
      me.syncResponsiveWidget();
    }
    updateResponsiveState(state, oldState) {
      var _me$element;
      const me = this, {
        $responsiveStates: states
      } = me, initial = ++me.responsiveStateChanges === 1, classList = (_me$element = me.element) === null || _me$element === void 0 ? void 0 : _me$element.classList, defaults = states["*"], def = states[state] || defaults, once = initial && (def.once || defaults.once), isStateful = initial && me.isStateful, target = me.responsiveWidget;
      let config = def.configs, otherConfigs = once === null || once === void 0 ? void 0 : once.configs;
      if (otherConfigs) {
        config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;
      }
      oldState && (classList === null || classList === void 0 ? void 0 : classList.remove(`b-responsive-${oldState.toLowerCase()}`));
      state && (classList === null || classList === void 0 ? void 0 : classList.add(`b-responsive-${state.toLowerCase()}`));
      if (isStateful) {
        otherConfigs = me.loadStatefulData();
        if (otherConfigs) {
          config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;
        }
        me.suspendStateful();
      }
      me._responsiveUpdating = true;
      try {
        var _me$trigger, _def$callback, _once$callback, _me$trigger2;
        (_me$trigger = me.trigger) === null || _me$trigger === void 0 ? void 0 : _me$trigger.call(me, "beforeResponsiveStateChange", {
          state,
          oldState,
          target
        });
        config && me.setConfig(config);
        (_def$callback = def.callback) === null || _def$callback === void 0 ? void 0 : _def$callback.call(def, {
          source: me,
          state,
          oldState,
          target,
          initial
        });
        once === null || once === void 0 ? void 0 : (_once$callback = once.callback) === null || _once$callback === void 0 ? void 0 : _once$callback.call(once, {
          source: me,
          state,
          oldState,
          target,
          initial
        });
        (_me$trigger2 = me.trigger) === null || _me$trigger2 === void 0 ? void 0 : _me$trigger2.call(me, "responsiveStateChange", {
          state,
          oldState,
          target
        });
      } finally {
        me._responsiveUpdating = false;
        isStateful && me.resumeStateful();
      }
    }
    get responsiveTarget() {
      return this.responsiveWidget || this._responsiveTarget;
    }
    updateResponsiveTarget() {
      this.syncResponsiveWidget();
    }
    updateResponsiveWidget(target) {
      var _me$$responsiveWrappe;
      const me = this, responsiveUpdate = target && me.responsiveUpdate;
      (_me$$responsiveWrappe = me.$responsiveWrapper) === null || _me$$responsiveWrappe === void 0 ? void 0 : _me$$responsiveWrappe.destroy();
      me.$responsiveWrapper = target && wrapWidget(target, responsiveUpdate);
      responsiveUpdate === null || responsiveUpdate === void 0 ? void 0 : responsiveUpdate.now();
    }
    responsiveUpdate() {
      const me = this, {
        $responsiveStates: states,
        $responsiveWrapper: wrapper
      } = me, responsiveTarget = wrapper === null || wrapper === void 0 ? void 0 : wrapper.widget;
      if (states && wrapper) {
        let best = null, bestScore = 0, fromWhen = states, score, state;
        if (responsiveTarget && responsiveTarget !== me && !me.$responsiveWhen) {
          responsiveTarget.getConfig("responsive");
          fromWhen = responsiveTarget.$responsiveStates || fromWhen;
        }
        wrapper.reset();
        for (state in states) {
          if (state !== "*") {
            score = fromWhen[state].when(wrapper.object, BrowserHelper);
            if (score != null && score !== false && (!best || score < bestScore)) {
              best = state;
              bestScore = score;
            }
          }
        }
        ++me.responsiveUpdateCount;
        me.responsiveState = best;
      }
    }
    syncResponsiveWidget() {
      const me = this;
      let widget = null, responsiveTarget;
      if (!me.isDestroying && me.responsive) {
        responsiveTarget = me.responsiveTarget;
        if (!(widget = responsiveTarget)) {
          var _me$up;
          widget = !me.responsiveRoot && ((_me$up = me.up) === null || _me$up === void 0 ? void 0 : _me$up.call(me, responsiveRootFn)) || me;
        } else if (typeof responsiveTarget === "string") {
          widget = responsiveTarget === "@" ? me : responsiveTarget[0] === "@" ? me[responsiveTarget.substring(1)] : me.up(responsiveTarget);
          if (!widget) {
            throw new Error(`No match for responsiveTarget="${responsiveTarget}"`);
          }
        }
        if (!widget.isWidget) {
          throw new Error(`${widget.constructor.$$name} is not a widget and cannot be a responsiveTarget`);
        }
      }
      me.responsiveWidget = widget;
      return widget;
    }
    changeBreakpoints(breakpoints) {
      ObjectHelper.assertObject(breakpoints, "breakpoints");
      if (breakpoints !== null && breakpoints !== void 0 && breakpoints.width) {
        Object.keys(breakpoints.width).forEach((key) => {
          breakpoints.width[key].maxWidth = key;
        });
      }
      if (breakpoints !== null && breakpoints !== void 0 && breakpoints.height) {
        Object.keys(breakpoints.height).forEach((key) => {
          breakpoints.height[key].maxHeight = key;
        });
      }
      return breakpoints;
    }
    updateBreakpoints(breakpoints) {
      if (breakpoints) {
        this.monitorResize = true;
      }
    }
    getBreakpoint(levels, dimension) {
      const ascendingLevels = Object.keys(levels).map((l) => parseInt(l)).sort(), breakpoint = ascendingLevels.find((bp) => dimension <= bp);
      return levels[breakpoint !== null && breakpoint !== void 0 ? breakpoint : levels["*"] && "*"];
    }
    activateBreakpoint(orientation, breakpoint) {
      const me = this, prevBreakpoint = me[`current${orientation}Breakpoint`];
      if (breakpoint !== prevBreakpoint) {
        var _breakpoint$callback, _me$recompose;
        me[`current${orientation}Breakpoint`] = breakpoint;
        me.setConfig(breakpoint.configs);
        prevBreakpoint && me.element.classList.remove(`b-breakpoint-${prevBreakpoint.name.toLowerCase()}`);
        me.element.classList.add(`b-breakpoint-${breakpoint.name.toLowerCase()}`);
        me.trigger(`responsive${orientation}Change`, {
          breakpoint,
          prevBreakpoint
        });
        (_breakpoint$callback = breakpoint.callback) === null || _breakpoint$callback === void 0 ? void 0 : _breakpoint$callback.call(breakpoint, {
          source: me,
          breakpoint,
          prevBreakpoint
        });
        (_me$recompose = me.recompose) === null || _me$recompose === void 0 ? void 0 : _me$recompose.call(me);
      }
    }
    applyResponsiveBreakpoints(width, height) {
      var _me$breakpoints;
      const me = this, {
        width: widths,
        height: heights
      } = (_me$breakpoints = me.breakpoints) !== null && _me$breakpoints !== void 0 ? _me$breakpoints : {};
      if (widths) {
        const breakpoint = me.getBreakpoint(widths, width);
        me.activateBreakpoint("Width", breakpoint);
      }
      if (heights) {
        const breakpoint = me.getBreakpoint(heights, height);
        me.activateBreakpoint("Height", breakpoint);
      }
    }
    onInternalResize(element, width, height, oldWidth, oldHeight) {
      super.onInternalResize(element, width, height, oldWidth, oldHeight);
      this.applyResponsiveBreakpoints(width, height);
    }
  }, _defineProperty(_class, "$name", "Responsive"), _defineProperty(_class, "configurable", {
    responsive: {
      $config: {
        lazy: "paint"
      },
      value: null
    },
    responsiveDefaults: {
      small: {
        when: 400
      },
      medium: {
        when: 800
      },
      large: {
        when: () => Infinity
      },
      "*": {}
    },
    responsiveRoot: null,
    responsiveState: null,
    responsiveTarget: {
      value: null,
      $config: {
        lazy: "paint"
      }
    },
    responsiveWidget: {
      value: null,
      $config: {
        nullify: true
      }
    },
    breakpoints: null
  }), _defineProperty(_class, "delayable", {
    responsiveUpdate: "raf"
  }), _defineProperty(_class, "fenced", {
    syncResponsiveWidget: true
  }), _defineProperty(_class, "prototypeProperties", {
    responsiveStateChanges: 0,
    responsiveUpdateCount: 0
  }), _class;
};
var Styleable = (Target) => {
  var _class;
  return _class = class Styleable extends (Target || Base$1) {
    changeCssVarPrefix(prefix) {
      ObjectHelper.assertString(prefix, "prefix");
      if (prefix && !prefix.endsWith("-")) {
        prefix = prefix + "-";
      }
      return prefix || "";
    }
    changeCss(css) {
      ObjectHelper.assertObject(css, "css");
      const me = this;
      if (!globalThis.Proxy) {
        throw new Error("Proxy not supported");
      }
      const proxy = new Proxy({}, {
        get(target, property) {
          var _styles$getPropertyVa;
          const styles = getComputedStyle(me.element || document.documentElement);
          return (_styles$getPropertyVa = styles.getPropertyValue(`--${me.cssVarPrefix}${StringHelper.hyphenate(property)}`)) === null || _styles$getPropertyVa === void 0 ? void 0 : _styles$getPropertyVa.trim();
        },
        set(target, property, value) {
          const element = me.element || document.documentElement;
          element.style.setProperty(`--${me.cssVarPrefix}${StringHelper.hyphenate(property)}`, value);
          return true;
        }
      });
      if (css) {
        if (me._element) {
          ObjectHelper.assign(proxy, css);
        } else {
          me.$initialCSS = css;
        }
      }
      return proxy;
    }
    updateElement(element, ...args) {
      super.updateElement(element, ...args);
      if (this.$initialCSS) {
        ObjectHelper.assign(this.css, this.$initialCSS);
      }
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "$name", "Styleable"), _defineProperty(_class, "configurable", {
    cssVarPrefix: "",
    css: {}
  }), _class;
};
var ns$1 = "http://www.w3.org/2000/svg";
var typePrio = {
  bar: 1,
  outline: 2,
  text: 3
};
var byDatasetOrder = (l, r) => parseInt(l.dataset.order, 10) - parseInt(r.dataset.order, 10);
var getField = (s) => s.field;
var returnFalse = () => false;
var Histogram = class extends Widget {
  static get type() {
    return "histogram";
  }
  static get $name() {
    return "Histogram";
  }
  static get defaultConfig() {
    return {
      data: null,
      values: null,
      series: null,
      topValue: null,
      element: {
        children: [{
          ns: ns$1,
          tag: "svg",
          reference: "svgElement",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "none",
          children: [{
            ns: ns$1,
            tag: "g",
            reference: "scaledSvgGroup"
          }, {
            ns: ns$1,
            tag: "g",
            reference: "unscaledSvgGroup"
          }]
        }]
      },
      omitZeroHeightBars: null,
      monitorResize: true,
      getRectClass: null,
      getBarTip: null,
      getBarText: null,
      getBarTextRenderData: null,
      getBarTextTip: null
    };
  }
  construct(config) {
    super.construct(config);
    this.scheduleRefresh = this.createOnFrame(this.refresh, [], this, true);
    this.refresh();
  }
  set tip(tip) {
    var _me$tip;
    const me = this;
    (_me$tip = me.tip) === null || _me$tip === void 0 ? void 0 : _me$tip.destroy();
    if (tip) {
      me._tip = Tooltip.new({
        owner: me,
        forElement: me.svgElement,
        forSelector: "rect",
        internalListeners: {
          beforeShow: "up.onBeforeTipShow"
        }
      }, tip);
    } else {
      me._tip = null;
    }
  }
  onElementResize() {
    super.onElementResize(...arguments);
    const svgRect = this.svgElement.getBoundingClientRect();
    this.scaledSvgGroup.setAttribute("transform", `scale(${svgRect.width} ${svgRect.height})`);
  }
  onBeforeTipShow({
    source: tip
  }) {
    const index = parseInt(tip.activeTarget.dataset.index);
    tip.html = tip.contentTemplate({
      histogram: this,
      index
    });
  }
  set series(value) {
    const me = this, series = me._series = {};
    for (const id in value) {
      if (value[id] !== false) {
        const data = series[id] = Object.assign({}, value[id]);
        if (!data.type && value[id].type) {
          data.type = value[id].type;
        }
        if (!data.field && value[id].field) {
          data.field = value[id].field;
        }
        if (!("order" in series)) {
          data.order = typePrio[data.type];
        }
        data.id = id;
      }
    }
    me.scheduleRefresh();
  }
  get series() {
    return this._series;
  }
  set data(data) {
    const me = this;
    me._data = data;
    if (!me.topValue) {
      const fields = Object.values(me.series).map(getField);
      for (let i = 0, {
        length
      } = data; i < length; i++) {
        for (let j = 0, {
          length: length2
        } = fields; j < length2; j++) {
          me.topValue = Math.max(me.topValue || 0, data[i][fields[j]]);
        }
      }
    }
    me.scheduleRefresh();
  }
  get data() {
    return this._data;
  }
  set topValue(value) {
    this._topValue = value;
    this.scheduleRefresh();
  }
  get topValue() {
    return this._topValue;
  }
  scheduleRefresh() {
  }
  refresh() {
    const me = this, {
      series,
      _tip
    } = me, histogramElements = [];
    for (const id in series) {
      const data = series[id], elConfig = me[`draw${StringHelper.capitalize(data.type)}`](data);
      if (Array.isArray(elConfig)) {
        histogramElements.push.apply(histogramElements, elConfig);
      } else {
        histogramElements.push(elConfig);
      }
    }
    histogramElements.sort(byDatasetOrder);
    DomSync.syncChildren({
      domConfig: {
        children: histogramElements
      },
      configEquality: returnFalse
    }, me.scaledSvgGroup);
    DomSync.syncChildren({
      domConfig: {
        children: me.drawText()
      }
    }, me.unscaledSvgGroup);
    if (_tip && _tip.isVisible) {
      me.onBeforeTipShow({
        source: _tip
      });
    }
  }
  drawBar(series) {
    const me = this, {
      topValue,
      data,
      omitZeroHeightBars,
      barStyle
    } = me, {
      field,
      order
    } = series, defaultWidth = 1 / data.length, children = [];
    let width;
    for (let index = 0, x = 0, {
      length
    } = data; index < length; index++, x += width) {
      const datum = data[index], value = datum[field], height = datum.height || (value > topValue ? topValue : value) / topValue, y = 1 - height, rectConfig = datum.rectConfig = {
        ns: ns$1,
        tag: "rect",
        dataset: {}
      }, barTip = me.callback("getBarTip", me, [series, rectConfig, datum, index]);
      width = datum.width || defaultWidth;
      if (barStyle) {
        rectConfig.style = barStyle;
      } else {
        delete rectConfig.style;
      }
      Object.assign(rectConfig.dataset, {
        index,
        order
      });
      Object.assign(rectConfig, {
        x,
        y,
        width,
        height,
        class: me.callback("getRectClass", me, [series, rectConfig, datum, index])
      });
      if (barTip) {
        rectConfig.dataset.btip = barTip;
      } else {
        delete rectConfig.dataset.btip;
      }
      if (height || !omitZeroHeightBars) {
        children.push(rectConfig);
      }
    }
    return children;
  }
  drawOutline(series) {
    const me = this, {
      topValue,
      data
    } = me, {
      field,
      order
    } = series, defaultWidth = 1 / data.length, coords = ["M 0,1"], result = series.outlineElement || (series.outlineElement = {
      ns: ns$1,
      tag: "path",
      dataset: {
        order
      }
    });
    let barWidth, command1 = "M", command2 = "L";
    for (let i = 0, x = 0, {
      length
    } = data; i < length; i++) {
      const barHeight = 1 - data[i][field] / topValue;
      barWidth = data[i].width || defaultWidth;
      coords.push(`${command1} ${x},${barHeight} ${command2} ${x += barWidth},${barHeight}`);
      command1 = command2 = "";
    }
    result.d = coords.join(" ");
    return result;
  }
  drawText() {
    const me = this, {
      data
    } = me, defaultWidth = 1 / data.length, defaultY = "100%", unscaledSvgGroups = [];
    for (let index = 0, width, x = 0, {
      length
    } = data; index < length; index++, x += width) {
      width = data[index].width || defaultWidth;
      const barText = me.callback("getBarText", me, [data[index], index]);
      if (barText) {
        const renderData = me.callback("getBarTextRenderData", me, [{
          ns: ns$1,
          tag: "text",
          className: "b-bar-legend",
          html: barText,
          x: `${(x + width / 2) * 100}%`,
          y: data[index].y !== void 0 ? data[index].y : defaultY,
          dataset: {
            index
          }
        }, data[index], index]);
        const barTip = me.callback("getBarTextTip", me, [renderData, data[index], index]);
        if (barTip) {
          renderData.dataset.btip = barTip;
        } else {
          delete renderData.dataset.btip;
        }
        unscaledSvgGroups.push(renderData);
      }
    }
    return unscaledSvgGroups;
  }
  getBarText(datum, index) {
    return "";
  }
  getBarTextRenderData(renderData, datum, index) {
    return renderData;
  }
  getBarTip(series, rectConfig, datum, index) {
  }
  getBarTextTip(renderData, datum, index) {
  }
  getRectClass(series, rectConfig, datum, index) {
    return "";
  }
};
Histogram.initClass();
Histogram._$name = "Histogram";
var ns = "http://www.w3.org/2000/svg";
var Scale = class extends Widget {
  static get type() {
    return "scale";
  }
  static get $name() {
    return "Scale";
  }
  static get configurable() {
    return {
      scalePoints: null,
      scaleMaxPadding: 0.1,
      horizontal: false,
      align: {
        value: false,
        $config: {
          merge: "replace"
        }
      },
      element: {
        children: [{
          ns,
          tag: "svg",
          reference: "svgElement",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "none",
          children: [{
            ns,
            tag: "g",
            reference: "scaledSvgGroup",
            children: [{
              ns,
              tag: "path",
              reference: "pathElement"
            }]
          }, {
            ns,
            tag: "g",
            reference: "unscaledSvgGroup"
          }]
        }]
      },
      monitorResize: true
    };
  }
  construct(config) {
    super.construct(config);
    this.scheduleRefresh = this.createOnFrame(this.refresh, [], this, true);
    this.refresh();
  }
  changeAlign(align) {
    if (!align) {
      align = this.horizontal ? "bottom" : "right";
    }
    return align;
  }
  updateAlign(align, oldAlign) {
    this.element.classList.remove(`b-align-${oldAlign}`);
    this.element.classList.add(`b-align-${align}`);
  }
  updateHorizontal(horizontal, oldHorizontal) {
    this.element.classList.remove(`b-scale-${oldHorizontal ? "horizontal" : "vertical"}`);
    this.element.classList.add(`b-scale-${horizontal ? "horizontal" : "vertical"}`);
  }
  onElementResize() {
    super.onElementResize(...arguments);
    this.scheduleRefresh();
  }
  scheduleRefresh() {
  }
  refresh() {
    const me = this, {
      horizontal,
      width,
      height,
      align,
      scalePoints,
      scaleMaxPadding
    } = me, scaleMax = scalePoints[scalePoints.length - 1].value, path = [], labels = [];
    const posFactor = 1 / (scaleMax + scaleMaxPadding * scaleMax);
    me.scaledSvgGroup.setAttribute("transform", `scale(${horizontal ? width : 1} ${horizontal ? 1 : height})`);
    for (const point of scalePoints) {
      const isLabelStep = Boolean(point.text), pos = posFactor * point.value;
      if (isLabelStep) {
        const label = {
          ns,
          tag: "text",
          className: "b-scale-tick-label",
          html: point.text,
          dataset: {
            tick: point.value
          }
        };
        if (horizontal) {
          label.x = `${pos * 100}%`;
          label.y = align === "top" ? "1.6em" : height - 12;
        } else {
          label.x = align === "left" ? "12" : `${width - 12}`;
          label.y = `${(1 - pos) * 100}%`;
        }
        labels.push(label);
      }
      if (horizontal) {
        if (align === "top") {
          path.push(`M${pos},0 L${pos},${isLabelStep ? 10 : 5}`);
        } else {
          path.push(`M${pos},${height} L${pos},${height - (isLabelStep ? 10 : 5)}`);
        }
      } else {
        if (align === "left") {
          path.push(`M0,${1 - pos} L${isLabelStep ? 10 : 5},${1 - pos}`);
        } else {
          path.push(`M${width},${1 - pos} L${width - (isLabelStep ? 10 : 5)},${1 - pos}`);
        }
      }
    }
    me.pathElement.setAttribute("d", path.join(""));
    DomSync.syncChildren({
      domConfig: {
        children: labels
      }
    }, me.unscaledSvgGroup);
  }
};
Scale.initClass();
Scale._$name = "Scale";
var AvatarRendering = class extends Base$1 {
  static get $name() {
    return "AvatarRendering";
  }
  static get configurable() {
    return {
      element: null,
      colorPrefix: "b-sch-",
      tooltip: null,
      size: null
    };
  }
  doDestroy() {
    var _this$tooltip;
    (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.destroy();
    super.doDestroy();
  }
  updateElement(element) {
    EventHelper.on({
      element,
      delegate: ".b-resource-image",
      error: "onImageErrorEvent",
      thisObj: this,
      capture: true
    });
  }
  changeTooltip(config) {
    return Tooltip.new({
      forElement: this.element,
      forSelector: ".b-resource-avatar",
      cls: "b-resource-avatar-tooltip"
    }, config);
  }
  static get failedUrls() {
    if (!this._failedUrls) {
      this._failedUrls = /* @__PURE__ */ new Set();
    }
    return this._failedUrls;
  }
  getResourceAvatar({
    initials,
    color,
    iconCls,
    imageUrl,
    defaultImageUrl,
    dataset = {},
    resourceRecord,
    alt: alt2 = StringHelper.encodeHtml(resourceRecord === null || resourceRecord === void 0 ? void 0 : resourceRecord.name)
  }) {
    return this.getImageConfig(initials, color, imageUrl, defaultImageUrl, dataset, alt2) || this.getIconConfig(iconCls, dataset) || this.getResourceInitialsConfig(initials, color, dataset);
  }
  getImageConfig(initials, color, imageUrl, defaultImageUrl, dataset, alt2) {
    const {
      size
    } = this;
    imageUrl = AvatarRendering.failedUrls.has(imageUrl) ? defaultImageUrl : imageUrl || defaultImageUrl;
    if (imageUrl) {
      return _objectSpread2(_objectSpread2({
        tag: "img",
        draggable: "false",
        loading: "lazy",
        class: {
          "b-resource-avatar": 1,
          "b-resource-image": 1
        }
      }, size ? {
        style: {
          height: size + "px",
          width: size + "px"
        }
      } : void 0), {}, {
        alt: alt2,
        elementData: {
          defaultImageUrl,
          imageUrl,
          initials,
          color,
          dataset
        },
        src: imageUrl,
        dataset
      });
    }
  }
  getIconConfig(iconCls, dataset) {
    if (iconCls) {
      return iconCls && {
        tag: "i",
        class: {
          "b-resource-avatar": 1,
          "b-resource-icon": 1,
          [iconCls]: 1
        },
        dataset
      };
    }
  }
  getResourceInitialsConfig(initials, color, dataset) {
    const {
      size
    } = this, namedColor = DomHelper.isNamedColor(color) && color, hexColor = !namedColor && color;
    return {
      tag: "div",
      class: {
        "b-resource-avatar": 1,
        "b-resource-initials": 1,
        [`${this.colorPrefix}${namedColor}`]: namedColor
      },
      style: _objectSpread2({
        backgroundColor: hexColor || null
      }, size ? {
        height: size + "px",
        width: size + "px"
      } : void 0),
      children: [initials],
      dataset
    };
  }
  onImageErrorEvent({
    target
  }) {
    if (!target.matches(".b-resource-avatar")) {
      return;
    }
    const {
      defaultImageUrl,
      initials,
      color,
      imageUrl,
      dataset
    } = target.elementData;
    if (defaultImageUrl && !target.src.endsWith(defaultImageUrl.replace(/^[./]*/gm, ""))) {
      target.src = defaultImageUrl;
    } else {
      const initialsEl = DomHelper.createElement(this.getResourceInitialsConfig(initials, color, dataset));
      initialsEl.elementData = target.elementData;
      target.parentElement.replaceChild(initialsEl, target);
    }
    AvatarRendering.failedUrls.add(imageUrl);
  }
};
AvatarRendering._$name = "AvatarRendering";
if (window && !window.bryntum) {
  window.bryntum = {};
}
var Location = class {
  constructor(location) {
    if (location) {
      if (location.isLocation) {
        return location;
      }
      if (location.nodeType === Node.ELEMENT_NODE) {
        const grid = Widget.fromElement(location, "gridbase"), cell = grid && location.closest(grid.focusableSelector);
        if (cell) {
          const {
            dataset
          } = cell.parentNode;
          this.init({
            grid,
            rowIndex: grid.store.includes(dataset.id) ? grid.store.indexOf(dataset.id) : dataset.index || -1,
            columnId: cell.dataset.columnId
          });
          this.initialTarget = location;
        }
      } else {
        this.init(location);
      }
    }
  }
  init(config) {
    var _me$record;
    const me = this;
    const grid = me.grid = config.grid, {
      store,
      columns
    } = grid, {
      visibleColumns
    } = columns;
    if (config.target) {
      me.actionTargets = [me._target = config.target];
    }
    if (config.record) {
      me._id = config.record.id;
    } else if ("id" in config) {
      me._id = config.id;
      if (config.id == null) {
        me._rowIndex = -1;
      }
    } else {
      var _store$getAt;
      const rowIndex = !isNaN(config.row) ? config.row : !isNaN(config.rowIndex) ? config.rowIndex : NaN;
      me._rowIndex = Math.max(Math.min(Number(rowIndex), store.count - 1), grid.hideHeaders ? 0 : -1);
      me._id = (_store$getAt = store.getAt(me._rowIndex)) === null || _store$getAt === void 0 ? void 0 : _store$getAt.id;
    }
    if (!("_rowIndex" in me)) {
      me._rowIndex = store.indexOf(me.id);
    }
    me.isSpecialRow = (_me$record = me.record) === null || _me$record === void 0 ? void 0 : _me$record.isSpecialRow;
    if ("columnId" in config) {
      me._column = columns.getById(config.columnId);
    } else if ("field" in config) {
      me._column = columns.get(config.field);
    } else {
      const columnIndex = !isNaN(config.column) ? config.column : !isNaN(config.columnIndex) ? config.columnIndex : NaN;
      if (!isNaN(columnIndex)) {
        me._columnIndex = Math.min(Number(columnIndex), visibleColumns.length - 1);
        me._column = visibleColumns[me._columnIndex];
      } else {
        me._column = "column" in config ? isNaN(config.column) ? config.column : visibleColumns[config.column] : visibleColumns[0];
      }
    }
    if (!("_columnIndex" in me)) {
      me._columnIndex = visibleColumns.indexOf(me._column);
    }
  }
  get isLocation() {
    return true;
  }
  equals(other, shallow = false) {
    const me = this;
    return (other === null || other === void 0 ? void 0 : other.isLocation) && other.grid === me.grid && (shallow ? me.id === other.id && me._column === other._column : other.record === me.record && other.column === me.column && other.target === me.target);
  }
  get rowIndex() {
    const {
      _id
    } = this, {
      store
    } = this.grid;
    return store.includes(_id) ? store.indexOf(_id) : Math.min(this._rowIndex, store.count - 1);
  }
  get visibleRowIndex() {
    const {
      rowManager
    } = this.grid, {
      rowIndex
    } = this;
    return rowIndex === -1 ? rowIndex : Math.max(Math.min(rowIndex, rowManager.lastFullyVisibleTow.dataIndex), rowManager.firstFullyVisibleTow.dataIndex);
  }
  get isSelectable() {
    return this.grid.store.includes(this._id) && !this.isSpecialRow;
  }
  get record() {
    if (this._rowIndex > -1) {
      const {
        store
      } = this.grid;
      if (!store.includes(this._id)) {
        return store.getAt(this._rowIndex);
      }
      return store.getById(this._id);
    }
  }
  get id() {
    return this._id;
  }
  get column() {
    const {
      visibleColumns
    } = this.grid.columns;
    if (!(visibleColumns !== null && visibleColumns !== void 0 && visibleColumns.includes(this._column))) {
      return visibleColumns === null || visibleColumns === void 0 ? void 0 : visibleColumns[this.columnIndex];
    }
    return this._column;
  }
  get columnId() {
    var _this$column;
    return (_this$column = this.column) === null || _this$column === void 0 ? void 0 : _this$column.id;
  }
  get columnIndex() {
    var _this$grid$columns$vi;
    return Math.min(this._columnIndex, ((_this$grid$columns$vi = this.grid.columns.visibleColumns) === null || _this$grid$columns$vi === void 0 ? void 0 : _this$grid$columns$vi.length) - 1);
  }
  move(where) {
    const me = this, {
      record,
      column,
      grid
    } = me, {
      store
    } = grid, columns = grid.columns.visibleColumns, result = new Location();
    let rowIndex = store.includes(record) ? store.indexOf(record) : me.rowIndex, columnIndex = columns.includes(column) ? columns.indexOf(column) : me.columnIndex;
    const rowMin = grid.hideHeaders ? 0 : -1, rowMax = store.count - 1, colMax = columns.length - 1, atFirstRow = rowIndex === rowMin, atLastRow = rowIndex === rowMax, atFirstColumn = columnIndex === 0, atLastColumn = columnIndex === colMax;
    switch (where) {
      case Location.PREV_CELL:
        if (atFirstColumn) {
          if (!atFirstRow) {
            columnIndex = colMax;
            rowIndex--;
          }
        } else {
          columnIndex--;
        }
        break;
      case Location.NEXT_CELL:
        if (atLastColumn) {
          if (!atLastRow) {
            columnIndex = 0;
            rowIndex++;
          }
        } else {
          columnIndex++;
        }
        break;
      case Location.UP:
        if (!atFirstRow) {
          rowIndex--;
        }
        break;
      case Location.DOWN:
        if (!atLastRow) {
          if (rowIndex === -1) {
            rowIndex = grid.rowManager.firstFullyVisibleRow.dataIndex;
          } else {
            rowIndex++;
          }
        }
        break;
      case Location.FIRST_COLUMN:
        columnIndex = 0;
        break;
      case Location.LAST_COLUMN:
        columnIndex = colMax;
        break;
      case Location.FIRST_CELL:
        rowIndex = rowMin;
        columnIndex = 0;
        break;
      case Location.LAST_CELL:
        rowIndex = rowMax;
        columnIndex = colMax;
        break;
      case Location.PREV_PAGE:
        rowIndex = Math.max(rowMin, rowIndex - Math.floor(grid.scrollable.clientHeight / grid.rowHeight));
        break;
      case Location.NEXT_PAGE:
        rowIndex = Math.min(rowMax, rowIndex + Math.floor(grid.scrollable.clientHeight / grid.rowHeight));
        break;
    }
    result.init({
      grid,
      rowIndex,
      columnIndex
    });
    return result;
  }
  get cell() {
    const me = this, {
      grid,
      id,
      _cell
    } = me;
    if (_cell) {
      return _cell;
    }
    if (id == null) {
      var _grid$columns$getById;
      return (_grid$columns$getById = grid.columns.getById(me.columnId)) === null || _grid$columns$getById === void 0 ? void 0 : _grid$columns$getById.element;
    } else {
      const {
        row
      } = me;
      if (row) {
        var _grid$columns$getAt;
        return row.getCell(me.columnId) || row.getCell((_grid$columns$getAt = grid.columns.getAt(me.columnIndex)) === null || _grid$columns$getAt === void 0 ? void 0 : _grid$columns$getAt.id);
      }
    }
  }
  get row() {
    return this.grid.getRowById(this.id) || this.grid.getRow(this.rowIndex);
  }
  get target() {
    const {
      cell,
      _target
    } = this, {
      focusableFinder
    } = this.grid;
    if (cell) {
      if (_target) {
        return _target;
      }
      focusableFinder.currentNode = this.grid.focusableFinderCell = cell;
      return focusableFinder.nextNode() || cell;
    }
  }
  get isActionable() {
    const {
      cell,
      _target
    } = this, containsFocus = (cell === null || cell === void 0 ? void 0 : cell.compareDocumentPosition(DomHelper.getActiveElement(cell))) & Node.DOCUMENT_POSITION_CONTAINED_BY;
    return Boolean(containsFocus || _target && _target !== this.cell);
  }
  get isColumnHeader() {
    return this.cell && this.rowIndex === -1;
  }
  get isCell() {
    return this.cell && this.record;
  }
};
Location.UP = 1;
Location.NEXT_CELL = 2;
Location.DOWN = 3;
Location.PREV_CELL = 4;
Location.FIRST_COLUMN = 5;
Location.LAST_COLUMN = 6;
Location.FIRST_CELL = 7;
Location.LAST_CELL = 8;
Location.PREV_PAGE = 9;
Location.NEXT_PAGE = 10;
Location._$name = "Location";
var validWidth = (value) => typeof value === "number" || (value === null || value === void 0 ? void 0 : value.endsWith("px"));
var Column = class extends Model.mixin(Events, Localizable) {
  static get $name() {
    return "Column";
  }
  static get type() {
    return "column";
  }
  static get fields() {
    return [
      "type",
      "text",
      "field",
      "renderer",
      "width",
      "flex",
      "autoWidth",
      "autoHeight",
      {
        name: "fitMode",
        defaultValue: "exact"
      },
      {
        name: "editor",
        defaultValue: {}
      },
      "cellEditor",
      "finalizeCellEdit",
      {
        name: "revertOnEscape",
        defaultValue: true
      },
      {
        name: "invalidAction",
        defaultValue: "block"
      },
      {
        name: "sortable",
        defaultValue: true,
        convert(value, column) {
          if (!value) {
            return false;
          }
          if (value === true) {
            return true;
          }
          const sorter = {};
          if (typeof value === "function") {
            sorter.originalSortFn = value;
            sorter.sortFn = value.bind(column);
          } else if (typeof value === "object") {
            Object.assign(sorter, value);
            if (sorter.fn) {
              sorter.sortFn = sorter.fn;
              delete sorter.fn;
            }
          }
          return sorter;
        }
      },
      {
        name: "searchable",
        defaultValue: true
      },
      {
        name: "collapsible",
        defaultValue: false
      },
      {
        name: "collapsed",
        defaultValue: false
      },
      {
        name: "collapseMode"
      },
      {
        name: "filterable",
        defaultValue: true,
        convert(value) {
          if (!value) {
            return false;
          }
          if (value === true) {
            return true;
          }
          const filter2 = {
            columnOwned: true
          };
          if (typeof value === "function") {
            filter2.filterFn = value;
          } else if (typeof value === "object") {
            Object.assign(filter2, value);
          }
          return filter2;
        }
      },
      {
        name: "sealed"
      },
      {
        name: "hideable",
        defaultValue: true
      },
      {
        name: "draggable",
        defaultValue: true
      },
      {
        name: "groupable",
        defaultValue: true
      },
      {
        name: "resizable",
        defaultValue: true
      },
      "groupRenderer",
      "headerRenderer",
      "tooltip",
      "tooltipRenderer",
      "cellCls",
      "cls",
      "icon",
      "align",
      {
        name: "minWidth",
        defaultValue: 60
      },
      "maxWidth",
      {
        name: "hidden",
        defaultValue: false
      },
      {
        name: "locked"
      },
      {
        name: "region"
      },
      {
        name: "mergeCells",
        type: "boolean"
      },
      {
        name: "mergeable",
        type: "boolean",
        defaultValue: true
      },
      "mergedRenderer",
      {
        name: "showColumnPicker",
        defaultValue: true
      },
      {
        name: "enableHeaderContextMenu",
        defaultValue: true
      },
      {
        name: "enableCellContextMenu",
        defaultValue: true
      },
      "headerMenuItems",
      "cellMenuItems",
      "sum",
      "summaries",
      "summaryRenderer",
      "responsiveLevels",
      "tags",
      "touchConfig",
      "tree",
      "filterType",
      {
        name: "htmlEncode",
        defaultValue: true
      },
      {
        name: "htmlEncodeHeaderText",
        defaultValue: true
      },
      {
        name: "autoSyncHtml",
        defaultValue: false
      },
      {
        name: "alwaysClearCell",
        defaultValue: false
      },
      {
        name: "headerWidgets"
      },
      {
        name: "instantUpdate",
        defaultValue: false
      },
      {
        name: "repaintOnResize",
        defaultValue: false
      },
      "editTargetSelector",
      {
        name: "exportable",
        defaultValue: true
      },
      {
        name: "exportedType"
      },
      {
        name: "ariaLabel",
        defaultValue: "L{Column.columnLabel}"
      },
      {
        name: "cellAriaLabel",
        defaultValue: "L{cellLabel}"
      }
    ];
  }
  static get autoExposeFields() {
    return false;
  }
  construct(data, store) {
    var _me$field;
    const me = this;
    me.masterStore = store;
    if (store) {
      me._grid = Array.isArray(store) ? store[0].grid : store.grid;
    }
    me.localizableProperties = Config.mergeMethods.distinct(data.localizableProperties, ["text", "ariaLabel", "cellAriaLabel"]);
    if (data.localeClass) {
      me.localeClass = data.localeClass;
    }
    super.construct(...arguments);
    if (me.isLeaf && !("field" in me.data)) {
      me.field = "_" + (me.type || "") + ++Column.emptyCount;
      me.noFieldSpecified = true;
    }
    me.hasComplexMapping = (_me$field = me.field) === null || _me$field === void 0 ? void 0 : _me$field.includes(".");
    if (!me.width && !me.flex && !me.children) {
      me.set({
        width: Column.defaultWidth,
        flex: null
      }, null, true);
    }
    me.headerWidgets && me.initHeaderWidgets(me.headerWidgets);
    if (me.isParent) {
      me.meta.visibleChildren = /* @__PURE__ */ new Set();
      if (me.collapsible) {
        me.collapsible = true;
      }
    }
  }
  get isCollapsible() {
    var _this$children;
    return ((_this$children = this.children) === null || _this$children === void 0 ? void 0 : _this$children.length) > 1 && this.collapsible;
  }
  get collapsed() {
    return this.get("collapsed");
  }
  set collapsed(collapsed) {
    this.set("collapsed", collapsed, true);
    this.onCollapseChange(!collapsed);
    this.trigger("toggleCollapse", {
      collapsed
    });
  }
  onCellFocus(location) {
    this.location = location;
    this.updateHeaderAriaLabel(this.localizeProperty("ariaLabel"));
    if (location.rowIndex !== -1) {
      this.updateCellAriaLabel(this.localizeProperty("cellAriaLabel"));
    }
  }
  updateHeaderAriaLabel(headerAriaLabel) {
    DomHelper.setAttributes(this.element, {
      "aria-label": headerAriaLabel
    });
  }
  updateCellAriaLabel(cellAriaLabel) {
    var _this$location, _this$location2;
    if (!((_this$location = this.location) !== null && _this$location !== void 0 && _this$location.isSpecialRow) && (_this$location2 = this.location) !== null && _this$location2 !== void 0 && _this$location2.cell) {
      var _cellAriaLabel;
      if (!((_cellAriaLabel = cellAriaLabel) !== null && _cellAriaLabel !== void 0 && _cellAriaLabel.length)) {
        cellAriaLabel = this.location.column.text;
      }
      DomHelper.setAttributes(this.location.cell, {
        "aria-label": cellAriaLabel
      });
    }
  }
  doDestroy() {
    var _this$data, _this$data$editor, _this$data$editor$des;
    (_this$data = this.data) === null || _this$data === void 0 ? void 0 : (_this$data$editor = _this$data.editor) === null || _this$data$editor === void 0 ? void 0 : (_this$data$editor$des = _this$data$editor.destroy) === null || _this$data$editor$des === void 0 ? void 0 : _this$data$editor$des.call(_this$data$editor);
    this.destroyHeaderWidgets();
    super.doDestroy();
  }
  set headerWidgets(widgets) {
    this.initHeaderWidgets(widgets);
    this.set("headerWidgets", widgets);
  }
  get headerWidgets() {
    return this.get("headerWidgets");
  }
  initHeaderWidgets(widgets) {
    this.destroyHeaderWidgets();
    const headerWidgetMap = this.headerWidgetMap = {};
    for (const config of widgets) {
      const widget = Widget.create(_objectSpread2({
        owner: this
      }, config));
      headerWidgetMap[widget.ref || widget.id] = widget;
    }
  }
  destroyHeaderWidgets() {
    for (const widget of Object.values(this.headerWidgetMap || {})) {
      var _widget$destroy;
      (_widget$destroy = widget.destroy) === null || _widget$destroy === void 0 ? void 0 : _widget$destroy.call(widget);
    }
  }
  static generateAutoCls() {
    let columnAutoCls = "";
    for (let c = this; c !== Column; c = c.superclass) {
      c.type && (columnAutoCls += `b-${c.type.toLowerCase()}-cell `);
    }
    (Column.autoClsMap || (Column.autoClsMap = /* @__PURE__ */ new Map())).set(this, columnAutoCls);
    return columnAutoCls;
  }
  getCellClass(cellContext) {
    var _Column$autoClsMap, _record$fieldMap$colu;
    const {
      record,
      column
    } = cellContext, {
      cellCls,
      internalCellCls,
      grid,
      constructor,
      align
    } = column, autoCls = ((_Column$autoClsMap = Column.autoClsMap) === null || _Column$autoClsMap === void 0 ? void 0 : _Column$autoClsMap.get(constructor)) || constructor.generateAutoCls(), isEditing = cellContext.cell.classList.contains("b-editing"), result = {
      [grid.cellCls]: grid.cellCls,
      [autoCls]: autoCls,
      [cellCls]: cellCls,
      [internalCellCls]: internalCellCls,
      "b-cell-dirty": record.isFieldModified(column.field) && (column.compositeField || ((_record$fieldMap$colu = record.fieldMap[column.field]) === null || _record$fieldMap$colu === void 0 ? void 0 : _record$fieldMap$colu.persist) !== false),
      [`b-grid-cell-align-${align}`]: align,
      "b-selected": grid.selectionMode.cell && grid.isCellSelected(cellContext),
      "b-focused": grid.isFocused(cellContext),
      "b-auto-height": column.autoHeight,
      "b-editing": isEditing
    };
    if (record.isSpecialRow && result["b-checkbox-selection"]) {
      result["b-checkbox-selection"] = false;
    }
    return result;
  }
  get locked() {
    return this.data.region === "locked";
  }
  set locked(locked) {
    this.region = locked ? "locked" : "normal";
  }
  get region() {
    if (!this.parent.isRoot) {
      return this.parent.region;
    }
    return this.get("region");
  }
  set region(region) {
    this.set("region", region);
  }
  get sortable() {
    return this.isLeaf && this.data.sortable;
  }
  set sortable(sortable) {
    this.set("sortable", sortable);
  }
  get groupable() {
    return this.isLeaf && this.data.groupable;
  }
  set groupable(groupable) {
    this.set("groupable", groupable);
  }
  get editor() {
    const me = this;
    let {
      editor
    } = me.data;
    if (editor && !editor.isWidget) {
      const result = me.grid.processCellEditor({
        editor,
        field: me.field
      });
      if (result) {
        editor = me.data.editor = result.editor;
      } else {
        if (typeof editor === "string") {
          editor = {
            type: editor
          };
        }
        editor = me.data.editor = Widget.create(ObjectHelper.merge(me.defaultEditor, {
          owner: me.grid,
          label: StringHelper.encodeHtml(me.text)
        }, editor));
      }
    }
    return editor;
  }
  set editor(editor) {
    this.data.editor = editor;
  }
  get defaultEditor() {
    return {
      type: "textfield",
      name: this.field
    };
  }
  getFilterableValue(record) {
    return this.getRawValue(record);
  }
  get owner() {
    return this._owner || this.subGrid;
  }
  set owner(owner) {
    this._owner = owner;
  }
  get grid() {
    var _this$parent;
    return this._grid || ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.grid);
  }
  set subGrid(subGrid) {
    this._subGrid = subGrid;
  }
  get subGrid() {
    var _this$grid;
    return this._subGrid || ((_this$grid = this.grid) === null || _this$grid === void 0 ? void 0 : _this$grid.getSubGridFromColumn(this));
  }
  get subGridElement() {
    return this.subGrid.element;
  }
  get element() {
    return this.grid.getHeaderElement(this);
  }
  get nextVisibleSibling() {
    const region = this.region;
    let next = this.nextSibling;
    while (next && (next.hidden || next.region !== region)) {
      next = next.nextSibling;
    }
    return next;
  }
  get isLastInSubGrid() {
    return !this.nextVisibleSibling && (this.parent.isRoot || this.parent.isLastInSubGrid);
  }
  get textWrapper() {
    return DomHelper.getChild(this.element, ".b-grid-header-text");
  }
  get textElement() {
    return DomHelper.down(this.element, ".b-grid-header-text-content");
  }
  get contentElement() {
    return DomHelper.down(this.element, ".b-grid-header-children");
  }
  get isSorted() {
    return this.grid.store.sorters.some((s) => s.field === this.field);
  }
  get isFocusable() {
    return this.isLeaf;
  }
  static get text() {
    return this.$meta.fields.defaults.text;
  }
  get headerText() {
    return this.htmlEncodeHeaderText ? StringHelper.encodeHtml(this.text) : this.text;
  }
  get isVisible() {
    return !this.hidden && (!this.parent || this.parent.isVisible);
  }
  hide(silent = false, hidingParent = false) {
    const me = this, {
      parent
    } = me;
    if (!me.hidden) {
      me.hidden = true;
      if (parent && !parent.isRoot && !parent.isTogglingAll) {
        const anyVisible = parent.children.some((child) => child.hidden !== true);
        if (!anyVisible && !parent.hidden) {
          silent = true;
          parent.hide();
        }
      }
      if (me.isParent) {
        me.children.forEach((child) => child.hide(true, true));
      } else if (!parent.isRoot) {
        parent.meta.visibleChildren[hidingParent ? "add" : "delete"](me);
      }
      if (!silent) {
        me.stores.forEach((store) => store.trigger("columnHide", {
          column: me
        }));
      }
    }
  }
  show(silent = false) {
    const me = this, {
      parent
    } = me;
    if (me.hidden) {
      me.hidden = false;
      if (parent !== null && parent !== void 0 && parent.hidden) {
        parent.show();
      }
      if (me.isParent) {
        var _me$meta$visibleChild;
        (_me$meta$visibleChild = me.meta.visibleChildren) === null || _me$meta$visibleChild === void 0 ? void 0 : _me$meta$visibleChild.forEach((child) => child.show(true));
      }
      if (!silent) {
        me.stores.forEach((store) => store.trigger("columnShow", {
          column: me
        }));
      }
    }
  }
  toggle(forceVisible) {
    if (this.hidden && forceVisible === void 0 || forceVisible === true) {
      return this.show();
    }
    if (!this.hidden && forceVisible === void 0 || forceVisible === false) {
      return this.hide();
    }
  }
  toggleChildren(columns = this.children, force = void 0) {
    var _me$grid$columns, _me$grid$columns2;
    const me = this;
    (_me$grid$columns = me.grid.columns) === null || _me$grid$columns === void 0 ? void 0 : _me$grid$columns.beginBatch();
    me.isTogglingAll = true;
    columns.forEach((childColumn) => childColumn.toggle(force));
    me.isTogglingAll = false;
    (_me$grid$columns2 = me.grid.columns) === null || _me$grid$columns2 === void 0 ? void 0 : _me$grid$columns2.endBatch();
  }
  onCollapseChange(force = void 0) {
    const me = this;
    if (me.collapseMode === "toggleAll") {
      me.toggleChildren();
    } else {
      var _me$grid$columns3, _me$grid$columns4;
      const {
        firstChild
      } = me;
      if (firstChild.flex != null && me.collapsed) {
        firstChild.oldFlex = firstChild.flex;
        firstChild.width = firstChild.element.offsetWidth;
      } else if (!me.collapsed && firstChild.oldFlex) {
        firstChild.flex = firstChild.oldFlex;
        firstChild.oldFlex = null;
      }
      (_me$grid$columns3 = me.grid.columns) === null || _me$grid$columns3 === void 0 ? void 0 : _me$grid$columns3.beginBatch();
      me.isTogglingAll = true;
      me.children.slice(1).forEach((childColumn) => childColumn.toggle(force));
      me.isTogglingAll = false;
      (_me$grid$columns4 = me.grid.columns) === null || _me$grid$columns4 === void 0 ? void 0 : _me$grid$columns4.endBatch();
    }
  }
  set collapsible(collapsible) {
    const me = this;
    me.set("collapsible", collapsible);
    if (me.isParent) {
      const {
        headerWidgets = []
      } = me;
      if (collapsible) {
        headerWidgets.push({
          type: "button",
          ref: "collapseExpand",
          toggleable: true,
          pressed: me.collapsed,
          icon: `b-icon-collapse-${me.grid.rtl ? "right" : "left"}`,
          pressedIcon: `b-icon-collapse-${me.grid.rtl ? "left" : "right"}`,
          cls: "b-grid-header-collapse-button b-transparent",
          onToggle: ({
            pressed
          }) => me.collapsed = pressed
        });
      } else {
        const index = headerWidgets.findIndex((w) => w.ref === "collapseExpand");
        index > -1 && headerWidgets.splice(index, 1);
      }
      me.headerWidgets = headerWidgets;
      if (me.collapsed) {
        me.onCollapseChange(false);
      }
    }
  }
  get collapsible() {
    return this.get("collapsible");
  }
  generateId() {
    if (!Column.generatedIdIndex) {
      Column.generatedIdIndex = 0;
    }
    return (this.field ? this.field.replace(/\./g, "-") : "col") + ++Column.generatedIdIndex;
  }
  get allIndex() {
    return this.masterStore.indexOf(this);
  }
  measureSize(value) {
    var _this$subGrid;
    return DomHelper.measureSize(value, (_this$subGrid = this.subGrid) === null || _this$subGrid === void 0 ? void 0 : _this$subGrid.element);
  }
  get calcMinWidth() {
    const {
      width,
      minWidth
    } = this.data;
    if (validWidth(width) && validWidth(minWidth)) {
      return Math.max(parseInt(width) || 0, parseInt(minWidth) || 0);
    } else {
      return width;
    }
  }
  get width() {
    return this.data.width;
  }
  set width(width) {
    const data = {
      width
    };
    if (width && "flex" in this.data) {
      data.flex = null;
    }
    this.set(data);
  }
  set flex(flex) {
    const data = {
      flex
    };
    if (flex && "width" in this.data) {
      data.width = null;
    }
    this.set(data);
  }
  get flex() {
    return this.data.flex;
  }
  calculateMinWidth() {
    const me = this, width = me.measureSize(me.width), minWidth = me.measureSize(me.minWidth);
    let minChildWidth = 0;
    if (me.children) {
      minChildWidth = me.children.reduce((result, column) => {
        return result + column.calculateMinWidth();
      }, 0);
    }
    return Math.max(width, minWidth, minChildWidth);
  }
  resizeToFitContent(widthMin, widthMax, batch = false) {
    const me = this, {
      grid,
      element,
      fitMode
    } = me, {
      rowManager,
      store
    } = grid, {
      count
    } = store;
    if (count <= 0 || me.fitMode === "none" || !me.fitMode) {
      return;
    }
    const [row] = rowManager.rows, {
      rowElement,
      cellElement
    } = grid.beginGridMeasuring(), cellContext = new Location({
      grid,
      column: me,
      id: null
    });
    let maxWidth = 0, start, end, i, record, value, length, longest = {
      length: 0,
      record: null
    };
    cellElement._domData = {
      columnId: me.id,
      row,
      rowElement
    };
    cellContext._cell = cellElement;
    cellContext.updatingSingleRow = true;
    cellContext.isMeasuring = true;
    cellElement.innerHTML = "";
    if (grid.resizeToFitIncludesHeader) {
      if (!grid.$headerPadding) {
        const style = globalThis.getComputedStyle(element);
        grid.$headerPadding = parseInt(style.paddingLeft);
      }
      const headerText = element.querySelector(".b-grid-header-text-content");
      headerText.style.cssText = "flex: none; width: auto";
      maxWidth = headerText.offsetWidth + grid.$headerPadding * 2 + 2;
      headerText.style.cssText = "";
    }
    if (count > 1e3) {
      start = Math.max(Math.min(rowManager.topIndex + Math.round(rowManager.rowCount / 2) - 500, count - 1e3), 0);
      end = start + 1e3;
    } else {
      start = 0;
      end = count;
    }
    for (i = start; i < end; i++) {
      record = store.getAt(i);
      value = me.getRawValue(record);
      if (fitMode === "value") {
        length = String(value).length;
      } else {
        cellContext._record = longest.record;
        cellContext._id = record.id;
        cellContext._rowIndex = i;
        row.renderCell(cellContext);
        if (fitMode === "textContent") {
          length = cellElement.textContent.length;
        } else {
          const width = cellElement.offsetWidth;
          if (width > maxWidth) {
            maxWidth = width;
          }
        }
      }
      if (length > longest.length) {
        longest = {
          record,
          length,
          rowIndex: i
        };
      }
    }
    if (longest.length > 0 && (fitMode === "value" || fitMode === "textContent")) {
      cellContext._record = longest.record;
      cellContext._id = longest.record.id;
      cellContext._rowIndex = longest.rowIndex;
      row.renderCell(cellContext);
      maxWidth = Math.max(maxWidth, cellElement.offsetWidth);
    }
    if (Array.isArray(widthMin)) {
      [widthMin, widthMax] = widthMin;
    }
    maxWidth = Math.max(maxWidth, widthMin || 0);
    maxWidth = Math.min(maxWidth, widthMax || 1e6);
    if (!batch) {
      grid.endGridMeasuring();
    }
    me.width = me.maxWidth ? maxWidth = Math.min(maxWidth, me.maxWidth) : maxWidth;
    return maxWidth;
  }
  getState() {
    const me = this, state = {
      id: me.id,
      hidden: me.hidden,
      region: me.region,
      locked: me.locked
    };
    if (!me.children) {
      state[me.flex ? "flex" : "width"] = me.flex || me.width;
    }
    if (me.isCollapsible) {
      state.collapsed = me.collapsed;
    }
    return state;
  }
  applyState(state) {
    const me = this;
    me.beginBatch();
    if ("locked" in state) {
      me.locked = state.locked;
    }
    if ("width" in state) {
      me.width = state.width;
    }
    if ("flex" in state) {
      me.flex = state.flex;
    }
    if ("width" in state && me.flex) {
      me.flex = void 0;
    } else if ("flex" in state && me.width) {
      me.width = void 0;
    }
    if ("region" in state) {
      me.region = state.region;
    }
    me.endBatch();
    if ("hidden" in state) {
      me.toggle(state.hidden !== true);
    }
    if ("collapsed" in state) {
      me.collapsed = state.collapsed;
    }
  }
  remove() {
    const {
      subGrid,
      grid
    } = this, focusedCell = subGrid && (grid === null || grid === void 0 ? void 0 : grid.focusedCell);
    if ((focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.columnId) === this.id) {
      if (grid.owns(DomHelper.getActiveElement(grid))) {
        grid.navigateRight();
      } else {
        grid._focusedCell = new Location({
          grid,
          rowIndex: focusedCell.rowIndex,
          column: subGrid.columns.getAdjacentVisibleLeafColumn(this.id, true, true)
        });
      }
    }
    super.remove();
  }
  getRawValue(record) {
    if (this.hasComplexMapping) {
      return ObjectHelper.getPath(record, this.field);
    }
    return record[this.field];
  }
  refreshCell(record) {
    this.grid.rowManager.refreshCell(record, this.id);
  }
  clearCell(cellElement) {
    cellElement.innerHTML = "";
    delete cellElement._content;
  }
  canEdit(record) {
    if (record.isEditable) {
      const isEditable = record.isEditable(this.field);
      if (isEditable !== void 0) {
        return isEditable;
      }
    }
    return true;
  }
  insertChild(childColumn, before = null, silent = false) {
    childColumn = Array.isArray(childColumn) ? childColumn : [childColumn];
    childColumn.forEach((col) => {
      const {
        parent
      } = col;
      if (parent !== null && parent !== void 0 && parent.collapsed && col === parent.firstChild && parent.children.length > 1 && parent.children.filter((child) => !child.hidden).length === 1) {
        col.nextSibling.hidden = false;
      }
    });
    return this.sealed && !this.inProcessChildren ? null : super.insertChild(...arguments);
  }
  canFillValue() {
    return true;
  }
  getCurrentConfig(options) {
    var _this$sortable;
    const result = super.getCurrentConfig(options);
    if ((_this$sortable = this.sortable) !== null && _this$sortable !== void 0 && _this$sortable.originalSortFn) {
      result.sortable = this.sortable.originalSortFn;
    }
    if (result.renderer === this.internalRenderer) {
      delete result.renderer;
    }
    if (result.headerRenderer === this.internalHeaderRenderer) {
      delete result.headerRenderer;
    }
    delete result.ariaLabel;
    delete result.cellAriaLabel;
    return result;
  }
};
Column.emptyCount = 0;
Column.defaultWidth = 100;
Column.exposeProperties();
Column._$name = "Column";
var columnDefinitions = {
  boolean: {
    type: "check"
  },
  date: {
    type: "date"
  },
  integer: {
    type: "number",
    format: {
      maximumFractionDigits: 0
    }
  },
  number: {
    type: "number"
  }
};
var lockedColumnSorters = [{
  field: "region"
}];
var ColumnStore = class extends Localizable(Store) {
  static get defaultConfig() {
    return {
      modelClass: Column,
      tree: true,
      autoAddField: false,
      sorters: lockedColumnSorters
    };
  }
  construct(config) {
    const me = this;
    if (config.grid) {
      config.grid._columnStore = me;
      me.id = `${config.grid.id}-columns`;
      config.grid.ion({
        subGridCollapse: "clearSubGridCaches",
        subGridExpand: "clearSubGridCaches",
        thisObj: me
      });
    }
    super.construct(config);
    me.ion({
      change: me.onStoreChange,
      sort: () => me.updateChainedStores(),
      thisObj: me,
      prio: 1
    });
  }
  get modelClass() {
    return this._modelClass;
  }
  set modelClass(ClassDef) {
    this._modelClass = ClassDef;
  }
  doDestroy() {
    const allColumns = [];
    if (!this.isChained) {
      this.traverse((column) => allColumns.push(column));
    }
    super.doDestroy();
    if (!this.isChained) {
      allColumns.forEach((column) => column.destroy());
    }
  }
  getById(id) {
    return super.getById(id) || this.idRegister[id];
  }
  forEach(fn2, thisObj = this) {
    this.traverseWhile((n, i) => fn2.call(thisObj, n, i), true);
  }
  get totalFixedWidth() {
    let result = 0;
    for (const col of this) {
      if (!col.hidden) {
        if (col.children) {
          col.children.forEach((childCol) => result += this.calculateFixedWidth(childCol));
        } else {
          result += this.calculateFixedWidth(col);
        }
      }
    }
    return result;
  }
  get hasFlex() {
    return this.visibleColumns.some((column) => column.flex);
  }
  calculateFixedWidth(column) {
    if (column.flex) {
      return column.measureSize(Column.defaultWidth);
    } else {
      return Math.max(column.measureSize(column.width), column.measureSize(column.minWidth));
    }
  }
  get topColumns() {
    return this.isChained ? this.masterStore.rootNode.children.filter(this.chainedFilterFn) : this.rootNode.children;
  }
  get visibleColumns() {
    const me = this;
    if (!me._visibleColumns) {
      me._visibleColumns = me.leaves.filter((column) => column.isVisible && (!column.subGrid || !column.subGrid.collapsed));
    }
    return me._visibleColumns;
  }
  onStoreChange({
    action,
    changes
  }) {
    if (action === "update" && !("hidden" in changes)) {
      return;
    }
    this.clearCaches();
  }
  clearSubGridCaches({
    subGrid
  }) {
    subGrid.columns.clearCaches();
    this.clearCaches();
  }
  clearCaches() {
    var _this$masterStore;
    this._visibleColumns = null;
    (_this$masterStore = this.masterStore) === null || _this$masterStore === void 0 ? void 0 : _this$masterStore.clearCaches();
  }
  onMasterDataChanged(event) {
    super.onMasterDataChanged(event);
    if (event.action !== "update" || "hidden" in event.changes) {
      this.clearCaches();
    }
  }
  getAdjacentVisibleLeafColumn(columnOrId, next = true, wrap = false) {
    const columns = this.visibleColumns, column = columnOrId instanceof Column ? columnOrId : this.getById(columnOrId);
    let idx = columns.indexOf(column) + (next ? 1 : -1);
    if (!columns[idx]) {
      if (wrap) {
        idx = next ? 0 : columns.length - 1;
      } else {
        return null;
      }
    }
    return columns[idx];
  }
  get bottomColumns() {
    return this.leaves;
  }
  get(field) {
    return this.findRecord("field", field, true);
  }
  createRecord(data) {
    var _store$modelClass, _store$modelClass$fie;
    const {
      grid = {}
    } = this, {
      store
    } = grid, dataField = store === null || store === void 0 ? void 0 : (_store$modelClass = store.modelClass) === null || _store$modelClass === void 0 ? void 0 : (_store$modelClass$fie = _store$modelClass.fieldMap) === null || _store$modelClass$fie === void 0 ? void 0 : _store$modelClass$fie[data.field];
    let columnClass = this.modelClass;
    if (dataField !== null && dataField !== void 0 && dataField.column) {
      data = Objects.merge({}, dataField.column, data);
    }
    if (data.type) {
      columnClass = ColumnStore.getColumnClass(data.type);
      if (!columnClass) {
        throw new Error(`Column type '${data.type}' not registered`);
      }
    }
    if (data.locked) {
      data.region = "locked";
      delete data.locked;
    }
    const column = new columnClass(data, this);
    if (!column.data.region) {
      column.data.region = grid.defaultRegion || "normal";
    }
    if (this.autoAddField && !column.noFieldSpecified && store && !dataField) {
      let fieldDefinition = column.field;
      if (column.constructor.fieldType) {
        fieldDefinition = {
          name: column.field,
          type: column.constructor.fieldType
        };
      }
      store.modelClass.addField(fieldDefinition);
    }
    return column;
  }
  indexOf(recordOrId) {
    if (recordOrId == null) {
      return -1;
    }
    const index = super.indexOf(recordOrId);
    if (index > -1)
      return index;
    return this.records.findIndex((r) => r.field === recordOrId);
  }
  get usesAutoHeight() {
    return this.find((column) => column.autoHeight);
  }
  get usesFlexAutoHeight() {
    return this.find((column) => column.autoHeight && column.flex != null);
  }
  static registerColumnType(columnClass, simpleRenderer = false) {
    columnClass.simpleRenderer = simpleRenderer;
    (ColumnStore.columnTypes || (ColumnStore.columnTypes = {}))[columnClass.type] = columnClass;
  }
  static getColumnClass(type) {
    return ColumnStore.columnTypes && ColumnStore.columnTypes[type];
  }
  generateColumnForField(dataField, defaults) {
    if (typeof dataField === "string" && this.grid) {
      var _this$grid$store;
      dataField = (_this$grid$store = this.grid.store) === null || _this$grid$store === void 0 ? void 0 : _this$grid$store.modelClass.fieldMap[dataField];
    }
    let column = dataField.column || columnDefinitions[dataField.type] || {};
    if (typeof column === "string") {
      column = {
        type: column
      };
    }
    column = Object.assign({
      text: dataField.text || StringHelper.separate(dataField.name),
      field: dataField.name
    }, defaults, column);
    if (dataField.precision != null) {
      column.format.maximumFractionDigits = dataField.precision;
    }
    if (dataField.columnType) {
      column.type = dataField.columnType;
    }
    return this.createRecord(column);
  }
};
var columnResizeEvent = (handler, thisObj) => ({
  update: ({
    store,
    record,
    changes
  }) => {
    let result = true;
    if ("width" in changes || "minWidth" in changes || "maxWidth" in changes || "flex" in changes) {
      result = handler.call(thisObj, {
        store,
        record,
        changes
      });
    }
    return result;
  }
});
ColumnStore.registerColumnType(Column, true);
ColumnStore._$name = "ColumnStore";
var ActionColumn = class extends Column {
  get groupHeaderReserved() {
    return true;
  }
  construct(config, store) {
    const me = this;
    super.construct(...arguments);
    if (!config.width && !config.flex) {
      me.grid.ion({
        paint: "updateAutoWidth",
        thisObj: me
      });
    }
    if (me.disableIfGridReadOnly) {
      me.grid.element.classList.add("b-actioncolumn-readonly");
    }
    me.externalRenderer = me.renderer;
    me.renderer = me.internalRenderer;
  }
  internalRenderer({
    grid,
    column,
    record,
    callExternalRenderer = true
  }) {
    var _column$actions;
    const inGroupTitle = record && "groupRowFor" in record.meta, {
      subGrid
    } = column;
    if (callExternalRenderer) {
      var _this$externalRendere;
      (_this$externalRendere = this.externalRenderer) === null || _this$externalRendere === void 0 ? void 0 : _this$externalRendere.call(this, ...arguments);
    }
    return {
      className: {
        "b-action-ct": 1
      },
      children: (_column$actions = column.actions) === null || _column$actions === void 0 ? void 0 : _column$actions.map((actionConfig, index) => {
        var _tooltip$startsWith;
        if ("visible" in actionConfig) {
          if (typeof actionConfig.visible === "function" && actionConfig.visible({
            record
          }) === false) {
            return "";
          }
          if (actionConfig.visible === false) {
            return "";
          }
        }
        if (inGroupTitle && !actionConfig.showForGroup || !inGroupTitle && actionConfig.showForGroup) {
          return "";
        }
        const {
          tooltip,
          renderer
        } = actionConfig, btip = typeof tooltip === "function" || tooltip !== null && tooltip !== void 0 && (_tooltip$startsWith = tooltip.startsWith) !== null && _tooltip$startsWith !== void 0 && _tooltip$startsWith.call(tooltip, "up.") ? subGrid.callback(tooltip, subGrid, [{
          record
        }]) : tooltip || "";
        if (renderer) {
          const customRendererData = subGrid.callback(renderer, subGrid, [{
            index,
            record,
            column,
            tooltip: btip,
            action: actionConfig
          }]);
          if (typeof customRendererData === "string") {
            return {
              tag: "span",
              dataset: _objectSpread2(_objectSpread2({}, Tooltip.encodeConfig(btip)), {}, {
                index
              }),
              html: customRendererData
            };
          } else {
            customRendererData.dataset = customRendererData.dataset || {};
            customRendererData.dataset.index = index;
            return customRendererData;
          }
        } else {
          return {
            tag: "button",
            dataset: _objectSpread2(_objectSpread2({}, Tooltip.encodeConfig(btip)), {}, {
              index
            }),
            "aria-label": btip,
            className: {
              "b-tool": 1,
              "b-action-item": 1,
              [actionConfig.cls]: actionConfig.cls
            }
          };
        }
      })
    };
  }
  onCellClick({
    grid,
    column,
    record,
    target
  }) {
    var _column$actions2;
    if (column !== this || !target.classList.contains("b-action-item")) {
      return;
    }
    let actionIndex = target.dataset.index;
    if (!actionIndex) {
      actionIndex = target.parentElement.dataset && target.parentElement.dataset.index;
    }
    const action = (_column$actions2 = column.actions) === null || _column$actions2 === void 0 ? void 0 : _column$actions2[actionIndex], actionHandler = action && action.onClick;
    if (actionHandler) {
      this.callback(actionHandler, column, [{
        record,
        action,
        target
      }]);
    }
  }
  updateAutoWidth() {
    const me = this, groupActions = [], {
      actions: oldActions
    } = me;
    if (!me.element) {
      return;
    }
    const actions = me.actions = [];
    oldActions === null || oldActions === void 0 ? void 0 : oldActions.forEach((actionOriginal) => {
      const action = _objectSpread2({}, actionOriginal);
      delete action.visible;
      if (action.showForGroup) {
        delete action.showForGroup;
        groupActions.push(action);
      } else {
        actions.push(action);
      }
    });
    if (groupActions.length > actions.length) {
      me._actions = groupActions;
    }
    const actionsHtml = DomHelper.createElement(me.internalRenderer({
      column: me,
      callExternalRenderer: false
    })).outerHTML;
    me.width = DomHelper.measureText(actionsHtml, me.element, true, me.element.parentElement);
    me.actions = oldActions;
  }
};
_defineProperty(ActionColumn, "type", "action");
_defineProperty(ActionColumn, "fields", [
  {
    name: "actions",
    type: "array"
  },
  {
    name: "disableIfGridReadOnly",
    defaultValue: false
  }
]);
_defineProperty(ActionColumn, "defaults", {
  filterable: false,
  groupable: false,
  sortable: false,
  editor: false,
  searchable: false,
  htmlEncode: false,
  resizable: false,
  minWidth: 30
});
ColumnStore.registerColumnType(ActionColumn);
ActionColumn.exposeProperties();
ActionColumn._$name = "ActionColumn";
var NumberColumn = class extends Column {
  static get defaults() {
    return {
      filterType: "number",
      format: ""
    };
  }
  get defaultEditor() {
    const {
      format: format2,
      name,
      max,
      min: min2,
      step,
      largeStep,
      align
    } = this;
    return ObjectHelper.cleanupProperties({
      type: "numberfield",
      format: format2,
      name,
      max,
      min: min2,
      step,
      largeStep,
      textAlign: align
    });
  }
  get formatter() {
    const me = this, {
      format: format2
    } = me;
    let formatter = me._formatter;
    if (!formatter || me._lastFormat !== format2) {
      me._formatter = formatter = NumberFormat.get(me._lastFormat = format2);
    }
    return formatter;
  }
  formatValue(value) {
    var _value;
    if (value != null) {
      value = this.formatter.format(value);
      if (this.unit) {
        value = `${value}${this.unit}`;
      }
    }
    return (_value = value) !== null && _value !== void 0 ? _value : "";
  }
  defaultRenderer({
    value
  }) {
    return this.formatValue(value);
  }
};
_defineProperty(NumberColumn, "type", "number");
_defineProperty(NumberColumn, "fieldType", "number");
_defineProperty(NumberColumn, "fields", [
  "format",
  "min",
  "max",
  "step",
  "largeStep",
  "unit"
]);
ColumnStore.registerColumnType(NumberColumn, true);
NumberColumn.exposeProperties();
NumberColumn._$name = "NumberColumn";
var AggregateColumn = class extends NumberColumn {
  static get defaults() {
    return {
      function: "sum",
      includeParentInChangeSet: false
    };
  }
  construct(data, columnStore) {
    this.configuredAlign = "align" in data;
    this.configuredEditor = "editor" in data;
    super.construct(...arguments);
    const {
      grid
    } = columnStore;
    if (this.function === "sum") {
      this.function = "sumChildren";
    }
    if (grid) {
      this.store = grid.store;
    }
  }
  set store(store) {
    const me = this, storeListeners = {
      update: "onRecordUpdate",
      thisObj: me,
      prio: 1e3
    }, oldStore = me._store;
    if (store !== oldStore) {
      if (oldStore) {
        oldStore.un(storeListeners);
      }
      me._store = store;
      const {
        modelClass
      } = store, field = modelClass.fieldMap[me.field];
      if (field && field.type === "number") {
        if (!me.configuredAlign) {
          me.align = "end";
        }
        if (!me.configuredEditor) {
          me.editor = "number";
        }
      }
      store.ion(storeListeners);
    }
  }
  canEdit(record) {
    return record.isLeaf;
  }
  get store() {
    return this._store;
  }
  sumChildren(...args) {
    let result = 0;
    for (let i = 0, {
      length
    } = args; i < length; i++) {
      result += parseFloat(args[i] || 0, 10);
    }
    return result;
  }
  avg(...args) {
    let result = 0;
    const {
      length
    } = args;
    for (let i = 0; i < length; i++) {
      result += parseFloat(args[i] || 0, 10);
    }
    return result / length;
  }
  onRecordUpdate({
    record,
    changes
  }) {
    const me = this, {
      rowManager
    } = me.grid;
    if (me.field in changes) {
      if (record.isLeaf) {
        record.bubble((rec) => {
          const row = rowManager.getRowFor(rec);
          if (row) {
            const cellElement = row.getCell(me.field);
            if (cellElement) {
              row.renderCell(cellElement);
            }
          }
        }, true);
      }
    }
  }
  getRawValue(record) {
    var _record$children;
    let value = 0;
    if ((_record$children = record.children) !== null && _record$children !== void 0 && _record$children.length) {
      const me = this, fn2 = me.function, isMathFn = typeof fn2 === "string" && typeof Math[fn2] === "function", {
        handler,
        thisObj
      } = isMathFn ? {
        handler: Math[fn2],
        thisObj: Math
      } : me.resolveCallback(fn2);
      value = handler.apply(thisObj, record.children.map((r) => me.getRawValue(r)));
      if (me.includeParentInChangeSet) {
        record.set(me.field, value, true);
      } else {
        record.setData(me.field, value);
      }
    } else {
      value = record[this.field];
    }
    return value;
  }
  canFillValue() {
    return false;
  }
};
_defineProperty(AggregateColumn, "type", "aggregate");
_defineProperty(AggregateColumn, "fields", ["function", "includeParentInChangeSet"]);
ColumnStore.registerColumnType(AggregateColumn, true);
AggregateColumn.exposeProperties();
AggregateColumn._$name = "AggregateColumn";
var WidgetColumn = class extends Column {
  static get defaults() {
    return {
      filterable: false,
      sortable: false,
      editor: false,
      searchable: false,
      fitMode: false,
      alwaysClearCell: false
    };
  }
  construct(config, store) {
    const me = this;
    me.widgetMap = {};
    super.construct(...arguments);
    me.externalRenderer = me.renderer;
    me.renderer = me.internalRenderer;
  }
  doDestroy() {
    for (const widget of Object.values(this.widgetMap)) {
      widget.destroy && widget.destroy();
    }
    super.doDestroy();
  }
  updateReadOnly(readOnly) {
    for (const widget of Object.values(this.widgetMap)) {
      if (!widget.cellInfo.record.readOnly) {
        widget.readOnly = readOnly;
      }
    }
  }
  internalRenderer(renderData) {
    var _this$externalRendere;
    const me = this, {
      cellElement,
      column,
      record,
      isExport
    } = renderData, {
      widgets
    } = column;
    if (!isExport && widgets) {
      if (!cellElement.widgets) {
        me.clearCell(cellElement);
      }
      cellElement.widgets = renderData.widgets = widgets.map((widgetCfg, i) => {
        var _me$onBeforeWidgetSet, _me$onAfterWidgetSetV;
        let widget, widgetNextSibling;
        if (cellElement.widgets) {
          widget = cellElement.widgets[i];
          widgetNextSibling = widget.element.nextElementSibling;
          if (widgetCfg.recreate && widget) {
            delete me.widgetMap[widget.id];
            widget.destroy();
            cellElement.widgets[i] = null;
          }
        }
        if (!widget) {
          me.onBeforeWidgetCreate(widgetCfg, renderData);
          widgetCfg.recomposeAsync = false;
          widget = WidgetHelper.append(widgetCfg, widgetNextSibling ? {
            insertBefore: widgetNextSibling
          } : cellElement)[0];
          me.widgetMap[widget.id] = widget;
          me.onAfterWidgetCreate(widget, renderData);
          if (widget.name) {
            widget.ion({
              change: ({
                value
              }) => {
                widget.cellInfo.record[widget.name] = value;
              }
            });
          }
        }
        widget.cellInfo = {
          record,
          column
        };
        if (me.grid && !me.meta.isSelectionColumn) {
          widget.readOnly = me.grid.readOnly || record.readOnly;
        }
        if (((_me$onBeforeWidgetSet = me.onBeforeWidgetSetValue) === null || _me$onBeforeWidgetSet === void 0 ? void 0 : _me$onBeforeWidgetSet.call(me, widget, renderData)) !== false) {
          const valueProperty = widgetCfg.valueProperty || "value" in widget && "value" || widget.defaultBindProperty;
          if (valueProperty) {
            const value = widget.name ? record[widget.name] : renderData.value;
            widget[valueProperty] = value;
          }
        }
        (_me$onAfterWidgetSetV = me.onAfterWidgetSetValue) === null || _me$onAfterWidgetSetV === void 0 ? void 0 : _me$onAfterWidgetSetV.call(me, widget, renderData);
        return widget;
      });
    }
    if (isExport) {
      return null;
    }
    return (_this$externalRendere = this.externalRenderer) === null || _this$externalRendere === void 0 ? void 0 : _this$externalRendere.call(this, renderData);
  }
  onBeforeWidgetCreate(widgetCfg, renderData) {
  }
  onAfterWidgetCreate(widget, renderData) {
  }
  clearCell(cellElement) {
    if (cellElement.widgets) {
      cellElement.widgets.forEach((widget) => {
        delete this.widgetMap[widget.id];
        widget.destroy();
      });
      cellElement.widgets = null;
    }
    super.clearCell(cellElement);
  }
  resizeToFitContent() {
  }
};
_defineProperty(WidgetColumn, "type", "widget");
_defineProperty(WidgetColumn, "fields", [
  "widgets"
]);
ColumnStore.registerColumnType(WidgetColumn);
WidgetColumn.exposeProperties();
WidgetColumn._$name = "WidgetColumn";
var CheckColumn = class extends WidgetColumn {
  construct(config, store) {
    super.construct(...arguments);
    const me = this;
    Object.assign(me, {
      externalHeaderRenderer: me.headerRenderer,
      externalOnBeforeWidgetSetValue: me.onBeforeWidgetSetValue,
      externalOnAfterWidgetSetValue: me.onAfterWidgetSetValue,
      onBeforeWidgetSetValue: me.internalOnBeforeWidgetSetValue,
      onAfterWidgetSetValue: me.internalOnAfterWidgetSetValue,
      headerRenderer: me.internalHeaderRenderer
    });
    if (!me.meta.isSelectionColumn) {
      var _me$grid;
      const modelClass = (_me$grid = me.grid) === null || _me$grid === void 0 ? void 0 : _me$grid.store.modelClass;
      if (!me.field) {
        console.warn("CheckColumn MUST be configured with a field, otherwise the checked state will not be persistent. Widgets are recycled and reused");
      } else if (modelClass && !modelClass.fieldMap[me.field] && !me.constructor.suppressNoModelFieldWarning) {
        console.warn(me.$$name + " is configured with a field, but this is not part of your Model `fields` collection.");
        modelClass.addField({
          name: me.field,
          type: "boolean"
        });
      }
    }
  }
  doDestroy() {
    var _this$headerCheckbox;
    (_this$headerCheckbox = this.headerCheckbox) === null || _this$headerCheckbox === void 0 ? void 0 : _this$headerCheckbox.destroy();
    super.doDestroy();
  }
  internalHeaderRenderer({
    headerElement,
    column
  }) {
    let returnValue;
    headerElement.classList.add("b-check-header");
    if (column.showCheckAll) {
      headerElement.classList.add("b-check-header-with-checkbox");
      if (column.headerCheckbox) {
        headerElement.appendChild(column.headerCheckbox.element);
      } else {
        column.headerCheckbox = new Checkbox({
          appendTo: headerElement,
          owner: this.grid,
          ariaLabel: "L{Checkbox.toggleSelection}",
          internalListeners: {
            change: "onCheckAllChange",
            thisObj: column
          }
        });
      }
    } else {
      returnValue = column.headerText;
    }
    returnValue = column.externalHeaderRenderer ? column.externalHeaderRenderer.call(this, ...arguments) : returnValue;
    return column.showCheckAll ? void 0 : returnValue;
  }
  updateCheckAllState(value) {
    if (this.headerCheckbox) {
      this.suspendEvents();
      this.headerCheckbox.checked = value;
      this.resumeEvents();
    }
  }
  onCheckAllChange({
    checked
  }) {
    const me = this;
    if (me.field) {
      const {
        store
      } = me.grid;
      store.beginBatch();
      store.forEach((record) => me.updateRecord(record, me.field, checked));
      store.endBatch();
    }
    me.trigger("toggleAll", {
      checked
    });
  }
  internalRenderer({
    value,
    isExport,
    record,
    cellElement
  }) {
    if (isExport) {
      return value == null ? "" : value;
    }
    const result = super.internalRenderer(...arguments);
    if (record.readOnly && !this.meta.isSelectionColumn) {
      cellElement.widgets[0].readOnly = true;
    }
    return result;
  }
  onBeforeWidgetCreate(widgetCfg, event) {
    widgetCfg.cls = this.checkCls;
  }
  onAfterWidgetCreate(widget, event) {
    event.cellElement.widget = widget;
    widget.ion({
      beforeChange: "onBeforeCheckboxChange",
      change: "onCheckboxChange",
      thisObj: this
    });
  }
  internalOnBeforeWidgetSetValue(widget) {
    var _this$externalOnBefor;
    widget.record = widget.cellInfo.record;
    this.isInitialSet = true;
    (_this$externalOnBefor = this.externalOnBeforeWidgetSetValue) === null || _this$externalOnBefor === void 0 ? void 0 : _this$externalOnBefor.call(this, ...arguments);
  }
  internalOnAfterWidgetSetValue(widget) {
    var _this$externalOnAfter;
    this.isInitialSet = false;
    (_this$externalOnAfter = this.externalOnAfterWidgetSetValue) === null || _this$externalOnAfter === void 0 ? void 0 : _this$externalOnAfter.call(this, ...arguments);
  }
  onBeforeCheckboxChange({
    source,
    checked,
    userAction
  }) {
    const me = this, {
      grid
    } = me, {
      record
    } = source.cellInfo;
    if (userAction && me.field && (!grid.features.cellEdit || grid.features.cellEdit.disabled) || me.meta.isSelectionColumn && !grid.isSelectable(record) && checked) {
      return false;
    }
    if (!me.isInitialSet) {
      return me.trigger("beforeToggle", {
        record,
        checked
      });
    }
  }
  onCheckboxChange({
    source,
    checked
  }) {
    if (!this.isInitialSet) {
      const me = this, {
        record
      } = source.cellInfo, {
        field
      } = me;
      if (field) {
        me.updateRecord(record, field, checked);
        if (checked) {
          me.updateCheckAllState(me.grid.store.every((r) => r[field], null, true));
        } else {
          me.updateCheckAllState(false);
        }
      }
      me.trigger("toggle", {
        record,
        checked
      });
    }
  }
  updateRecord(record, field, checked) {
    const setterName = `set${StringHelper.capitalize(field)}`;
    if (record[setterName]) {
      record[setterName](checked);
    } else {
      record.set(field, checked);
    }
  }
  onCellKeyDown({
    event,
    cellElement
  }) {
    if (event.key === " ") {
      const checkbox = cellElement.widget;
      checkbox === null || checkbox === void 0 ? void 0 : checkbox.toggle();
      event.preventDefault();
      event.handled = true;
    }
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    delete result.onBeforeWidgetSetValue;
    delete result.onAfterWidgetSetValue;
    if (this.externalOnBeforeWidgetSetValue) {
      result.onBeforeWidgetSetValue = this.externalOnBeforeWidgetSetValue;
    }
    if (this.externalOnAfterWidgetSetValue) {
      result.onAfterWidgetSetValue = this.externalOnAfterWidgetSetValue;
    }
    return result;
  }
};
_defineProperty(CheckColumn, "$name", "CheckColumn");
_defineProperty(CheckColumn, "type", "check");
_defineProperty(CheckColumn, "fields", ["checkCls", "showCheckAll", "onAfterWidgetSetValue", "onBeforeWidgetSetValue", "callOnFunctions", "onBeforeToggle", "onToggle", "onToggleAll"]);
_defineProperty(CheckColumn, "defaults", {
  align: "center",
  checkCls: null,
  showCheckAll: false,
  sortable: true,
  filterable: true,
  widgets: [{
    type: "checkbox",
    valueProperty: "checked"
  }]
});
ColumnStore.registerColumnType(CheckColumn, true);
CheckColumn._$name = "CheckColumn";
var DateColumn = class extends Column {
  static get defaults() {
    return {
      format: "L",
      step: 1,
      minWidth: 85,
      filterType: "date"
    };
  }
  defaultRenderer({
    value
  }) {
    return value ? this.formatValue(value) : "";
  }
  groupRenderer({
    cellElement,
    groupRowFor
  }) {
    cellElement.innerHTML = this.formatValue(groupRowFor);
  }
  formatValue(value) {
    if (typeof value === "string") {
      value = DateHelper.parse(value, this.format || void 0);
    }
    return DateHelper.format(value, this.format || void 0);
  }
  set format(value) {
    const {
      editor
    } = this.data;
    this.set("format", value);
    if (editor) {
      editor.format = value;
    }
  }
  get format() {
    return this.get("format");
  }
  get defaultEditor() {
    const me = this, {
      min: min2,
      max,
      step,
      format: format2
    } = me;
    return {
      name: me.field,
      type: "date",
      calendarContainerCls: "b-grid-cell-editor-related",
      weekStartDay: me.grid.weekStartDay,
      format: format2,
      max,
      min: min2,
      step
    };
  }
};
_defineProperty(DateColumn, "$name", "DateColumn");
_defineProperty(DateColumn, "type", "date");
_defineProperty(DateColumn, "fieldType", "date");
_defineProperty(DateColumn, "fields", ["format", "pickerFormat", "step", "min", "max"]);
ColumnStore.registerColumnType(DateColumn, true);
DateColumn.exposeProperties();
DateColumn._$name = "DateColumn";
var PercentColumn = class extends NumberColumn {
  static get defaults() {
    return {
      min: 0,
      max: 100,
      showValue: false,
      lowThreshold: 20,
      htmlEncode: false,
      searchable: false,
      summaryRenderer: (sum) => `${sum}%`,
      fitMode: false
    };
  }
  constructor(config, store) {
    super(...arguments);
    this.internalCellCls = "b-percent-bar-cell";
  }
  defaultRenderer({
    value
  }) {
    value = value || 0;
    return {
      className: "b-percent-bar-outer",
      role: "progressbar",
      "aria-Valuemin": 0,
      "aria-Valuemax": 100,
      "aria-Valuenow": value,
      tabIndex: 0,
      children: [{
        tag: "div",
        className: {
          "b-percent-bar": 1,
          "b-zero": value === 0,
          "b-low": value < this.lowThreshold
        },
        style: {
          width: value + "%"
        },
        children: [this.showValue ? {
          tag: "span",
          text: value + "%"
        } : void 0]
      }]
    };
  }
  resizeToFitContent() {
  }
};
_defineProperty(PercentColumn, "type", "percent");
_defineProperty(PercentColumn, "fieldType", "number");
_defineProperty(PercentColumn, "fields", ["showValue", "lowThreshold"]);
PercentColumn.sum = "average";
ColumnStore.registerColumnType(PercentColumn, true);
PercentColumn._$name = "PercentColumn";
var RatingColumn = class extends NumberColumn {
  static get defaults() {
    return {
      min: 0,
      max: 5,
      emptyIcon: "b-icon b-icon-star",
      filledIcon: "b-icon b-icon-star",
      editable: true,
      filterType: "number",
      searchable: false,
      width: "11.2em",
      htmlEncode: false,
      minWidth: "11.2em",
      editor: false,
      fitMode: "value"
    };
  }
  renderer({
    value
  }) {
    return {
      className: {
        "b-rating-cell-inner": 1,
        "b-not-editable": !this.editable
      },
      children: ArrayHelper.populate(this.max, (i) => {
        const filled = i < value;
        return {
          tag: "i",
          className: {
            "b-rating-icon": true,
            "b-filled": filled,
            "b-empty": !filled,
            [filled ? this.filledIcon : this.emptyIcon]: true
          }
        };
      })
    };
  }
  onCellClick({
    grid,
    column,
    record,
    target,
    event
  }) {
    if (target.classList.contains("b-rating-icon") && !grid.readOnly && column.editable) {
      let starIndex = [].indexOf.call(target.parentNode.childNodes, target);
      if (target.classList.contains("b-filled") && (event.metaKey || event.shiftKey)) {
        starIndex = starIndex - 1;
      }
      if (record.get(column.field) === 1 && starIndex === 0) {
        starIndex = -1;
      }
      record.set(column.field, starIndex + 1);
    }
  }
};
_defineProperty(RatingColumn, "$name", "RatingColumn");
_defineProperty(RatingColumn, "type", "rating");
_defineProperty(RatingColumn, "fieldType", "number");
_defineProperty(RatingColumn, "fields", ["emptyIcon", "filledIcon", "editable"]);
ColumnStore.registerColumnType(RatingColumn, true);
RatingColumn.exposeProperties();
RatingColumn._$name = "RatingColumn";
var RowNumberColumn = class extends Column {
  static get defaults() {
    return {
      groupable: false,
      sortable: false,
      filterable: false,
      searchable: false,
      resizable: false,
      draggable: false,
      minWidth: 50,
      width: 50,
      align: "center",
      text: "#",
      editor: false
    };
  }
  construct(config) {
    super.construct(...arguments);
    const me = this, {
      grid
    } = me;
    me.internalCellCls = "b-row-number-cell";
    me.externalHeaderRenderer = me.headerRenderer;
    me.headerRenderer = me.internalHeaderRenderer;
    if (grid) {
      grid.ion({
        bindStore: "bindStore",
        thisObj: me
      });
      me.bindStore({
        store: grid.store,
        initial: true
      });
      if (grid.store.count && !grid.rendered) {
        grid.ion({
          paint: "resizeToFitContent",
          thisObj: me,
          once: true
        });
      }
    }
  }
  get groupHeaderReserved() {
    return true;
  }
  bindStore({
    store,
    initial
  }) {
    const me = this;
    me.detachListeners("grid");
    store.ion({
      name: "grid",
      [`change${me.grid.asyncEventSuffix}`]: "onStoreChange",
      thisObj: me
    });
    if (!initial) {
      me.resizeToFitContent();
    }
  }
  onStoreChange({
    action
  }) {
    if (action === "dataset" || action === "add" || action === "remove" || action === "removeall") {
      this.resizeToFitContent();
    }
  }
  renderer({
    record,
    grid
  }) {
    return record.isSpecialRow ? "" : grid.store.indexOf(record, true) + 1;
  }
  resizeToFitContent() {
    const {
      grid
    } = this, {
      store
    } = grid, {
      count
    } = store;
    if (count && !this.hidden) {
      const cellElement = grid.element.querySelector(`.b-grid-cell[data-column-id="${this.id}"]`);
      if (cellElement) {
        const cellPadding = parseInt(DomHelper.getStyleValue(cellElement, "padding-left")), maxWidth = DomHelper.measureText(count, cellElement);
        this.width = Math.max(this.minWidth, maxWidth + 2 * cellPadding);
      }
    }
  }
  set flex(f) {
  }
  internalHeaderRenderer({
    headerElement,
    column
  }) {
    var _column$externalHeade;
    headerElement.classList.add("b-rownumber-header");
    return ((_column$externalHeade = column.externalHeaderRenderer) === null || _column$externalHeade === void 0 ? void 0 : _column$externalHeade.call(this, ...arguments)) || column.headerText;
  }
};
_defineProperty(RowNumberColumn, "$name", "RowNumberColumn");
_defineProperty(RowNumberColumn, "type", "rownumber");
ColumnStore.registerColumnType(RowNumberColumn, true);
RowNumberColumn._$name = "RowNumberColumn";
var TemplateColumn = class extends Column {
  static get defaults() {
    return {
      htmlEncode: false
    };
  }
  constructor(config, store) {
    super(...arguments);
    const me = this;
    if (!me.template) {
      throw new Error("TemplateColumn needs a template");
    }
    if (typeof me.template !== "function") {
      throw new Error("TemplateColumn.template must be a function");
    }
  }
  renderer(renderData) {
    if (!renderData.record.isSpecialRow) {
      return this.template({
        value: renderData.value,
        record: renderData.record,
        field: renderData.column.field
      });
    }
  }
};
_defineProperty(TemplateColumn, "type", "template");
_defineProperty(TemplateColumn, "fields", [
  "template"
]);
ColumnStore.registerColumnType(TemplateColumn, true);
TemplateColumn.exposeProperties();
TemplateColumn._$name = "TemplateColumn";
var TimeColumn = class extends Column {
  static get defaults() {
    return {
      format: "LT",
      minWidth: 140,
      filterType: "time"
    };
  }
  defaultRenderer({
    value
  }) {
    return value ? this.formatValue(value) : "";
  }
  groupRenderer({
    cellElement,
    groupRowFor
  }) {
    cellElement.innerHTML = this.formatValue(groupRowFor);
  }
  formatValue(value) {
    if (typeof value === "string") {
      value = DateHelper.parse(value, this.format);
    }
    return DateHelper.format(value, this.format);
  }
  set format(value) {
    const {
      editor
    } = this;
    this.set("format", value);
    if (editor) {
      editor.format = value;
    }
  }
  get format() {
    return this.get("format");
  }
  get defaultEditor() {
    return {
      name: this.field,
      type: "time",
      format: this.format
    };
  }
};
_defineProperty(TimeColumn, "type", "time");
_defineProperty(TimeColumn, "fieldType", "date");
_defineProperty(TimeColumn, "fields", ["format"]);
ColumnStore.registerColumnType(TimeColumn, true);
TimeColumn.exposeProperties();
TimeColumn._$name = "TimeColumn";
var currentParentHasIcon = false;
var TreeColumn = class extends Column {
  static get defaults() {
    return {
      tree: true,
      hideable: false,
      minWidth: 150
    };
  }
  static get fields() {
    return [
      {
        name: "expandIconCls",
        defaultValue: "b-icon b-icon-tree-expand"
      },
      {
        name: "collapseIconCls",
        defaultValue: "b-icon b-icon-tree-collapse"
      },
      {
        name: "collapsedFolderIconCls"
      },
      {
        name: "expandedFolderIconCls"
      },
      {
        name: "indentSize",
        defaultValue: 1.7
      },
      {
        name: "leafIconCls",
        defaultValue: "b-icon b-icon-tree-leaf"
      },
      {
        name: "editTargetSelector",
        defaultValue: ".b-tree-cell-value"
      },
      "renderer"
    ];
  }
  constructor(config, store) {
    super(...arguments);
    const me = this;
    me.shouldHtmlEncode = me.htmlEncode;
    me.setData("htmlEncode", false);
    if (me.renderer) {
      me.originalRenderer = me.renderer;
    }
    me.renderer = me.treeRenderer.bind(me);
  }
  treeRenderer(renderData) {
    const me = this, {
      grid,
      column,
      cellElement,
      row,
      record,
      isExport
    } = renderData, gridMeta = record.instanceMeta(grid.store), isCollapsed = !record.isLeaf && gridMeta.collapsed, innerConfig = {
      className: "b-tree-cell-value"
    }, children = [innerConfig], result = {
      className: "b-tree-cell-inner",
      tag: record.href ? "a" : "div",
      href: record.href,
      target: record.target,
      children
    }, rowClasses = {
      "b-tree-parent-row": 0,
      "b-tree-collapsed": 0,
      "b-tree-expanded": 0,
      "b-loading-children": 0
    };
    let outputIsObject, iconCls, {
      value
    } = renderData;
    if (me.originalRenderer) {
      var _grid$hasFrameworkRen;
      const rendererHtml = me.originalRenderer(renderData), hasFrameworkRenderer = (_grid$hasFrameworkRen = grid.hasFrameworkRenderer) === null || _grid$hasFrameworkRen === void 0 ? void 0 : _grid$hasFrameworkRen.call(grid, {
        cellContent: rendererHtml,
        column
      });
      outputIsObject = typeof rendererHtml === "object" && !hasFrameworkRenderer;
      value = hasFrameworkRenderer ? "" : rendererHtml === false ? cellElement.innerHTML : rendererHtml;
      renderData.rendererHtml = rendererHtml;
    }
    if (!outputIsObject) {
      var _value;
      value = String((_value = value) !== null && _value !== void 0 ? _value : "");
    }
    if (isExport) {
      return value;
    }
    if (!record.isLeaf) {
      var _record$children;
      const isCollapsed2 = !record.isExpanded(grid.store), expanderIconCls = isCollapsed2 ? me.expandIconCls : me.collapseIconCls, folderIconCls = isCollapsed2 ? me.collapsedFolderIconCls : me.expandedFolderIconCls;
      rowClasses["b-tree-parent-row"] = 1;
      rowClasses["b-tree-collapsed"] = isCollapsed2;
      rowClasses["b-tree-expanded"] = !isCollapsed2;
      rowClasses["b-loading-children"] = gridMeta.isLoadingChildren;
      cellElement.classList.add("b-tree-parent-cell");
      children.unshift({
        tag: "i",
        className: {
          "b-tree-expander": 1,
          [expanderIconCls]: 1,
          "b-empty-parent": !gridMeta.isLoadingChildren && record.children !== true && !((_record$children = record.children) !== null && _record$children !== void 0 && _record$children.length)
        }
      });
      currentParentHasIcon = iconCls = renderData.iconCls || record.iconCls || folderIconCls;
    } else {
      cellElement.classList.add("b-tree-leaf-cell");
      iconCls = renderData.iconCls || record.iconCls || me.leafIconCls;
    }
    if (iconCls) {
      children.splice(children.length - 1, 0, {
        tag: "i",
        className: {
          "b-tree-icon": 1,
          [iconCls]: 1
        }
      });
    }
    if (row.isRow) {
      row.assignCls(rowClasses);
      if (!record.isLeaf) {
        row.setAttribute("aria-expanded", !isCollapsed);
        if (isCollapsed) {
          row.removeAttribute("aria-owns");
        } else {
          for (const region in grid.subGrids) {
            var _record$children2, _record$children3;
            const el = row.elements[region];
            DomHelper.setAttributes(el, {
              "aria-owns": (_record$children2 = record.children) !== null && _record$children2 !== void 0 && _record$children2.length ? (_record$children3 = record.children) === null || _record$children3 === void 0 ? void 0 : _record$children3.map((r) => `${grid.id}-${region}-${r.id}`).join(" ") : null
            });
          }
        }
      }
    }
    if (outputIsObject || me.shouldHtmlEncode || !value.includes("<")) {
      if (outputIsObject) {
        Object.assign(innerConfig, value);
      }
      innerConfig.children = innerConfig.children || [];
      innerConfig.children.unshift(outputIsObject ? null : value);
    } else {
      innerConfig.html = value;
    }
    const padding = record.childLevel * me.indentSize + (record.isLeaf ? currentParentHasIcon ? 2 : iconCls ? 0.5 : 0.4 : 0);
    result.style = `padding-inline-start:${padding}em`;
    return result;
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    result.renderer = this.originalRenderer;
    return result;
  }
};
_defineProperty(TreeColumn, "$name", "TreeColumn");
_defineProperty(TreeColumn, "type", "tree");
ColumnStore.registerColumnType(TreeColumn, true);
TreeColumn.exposeProperties();
TreeColumn._$name = "TreeColumn";
var GridRowModel = class extends Model {
  static get fields() {
    return [
      {
        name: "iconCls",
        internal: true
      },
      {
        name: "expanded",
        internal: true
      },
      {
        name: "cls",
        internal: true
      },
      {
        name: "rowHeight",
        internal: true
      },
      {
        name: "href",
        internal: true
      },
      {
        name: "target",
        internal: true
      }
    ];
  }
};
GridRowModel.exposeProperties();
GridRowModel._$name = "GridRowModel";
var consumerToFeatureMap = /* @__PURE__ */ new Map();
var consumerToDefaultFeatureMap = /* @__PURE__ */ new Map();
var DEFAULT_FOR_TYPE = "Grid";
var remapToBase = {
  Grid: "GridBase",
  Scheduler: "SchedulerBase",
  SchedulerPro: "SchedulerProBase",
  Gantt: "GanttBase"
};
var classNameFix = /\$\d+$/;
var GridFeatureManager = class {
  static registerFeature(featureClass, onByDefault = false, forType = null, as = null) {
    as = StringHelper.uncapitalize(as || Object.prototype.hasOwnProperty.call(featureClass, "$name") && featureClass.$$name || featureClass.name);
    as = as.replace(classNameFix, "");
    if (!Array.isArray(forType)) {
      forType = [forType || DEFAULT_FOR_TYPE];
    }
    forType.forEach((forType2) => {
      const type = remapToBase[forType2] || forType2, consumerFeaturesMap = consumerToFeatureMap.get(type) || /* @__PURE__ */ new Map(), consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type) || /* @__PURE__ */ new Map();
      consumerFeaturesMap.set(as, featureClass);
      consumerDefaultFeaturesMap.set(featureClass, onByDefault);
      consumerToFeatureMap.set(type, consumerFeaturesMap);
      consumerToDefaultFeatureMap.set(type, consumerDefaultFeaturesMap);
    });
  }
  static getTypeNameFeatures(forType = DEFAULT_FOR_TYPE) {
    const type = remapToBase[forType] || forType, consumerFeaturesMap = consumerToFeatureMap.get(type), features = {};
    if (consumerFeaturesMap) {
      consumerFeaturesMap.forEach((featureClass, as) => features[as] = featureClass);
    }
    return features;
  }
  static getTypeNameDefaultFeatures(forType = DEFAULT_FOR_TYPE) {
    const type = remapToBase[forType] || forType, consumerFeaturesMap = consumerToFeatureMap.get(type), consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type);
    const features = {};
    if (consumerFeaturesMap && consumerDefaultFeaturesMap) {
      consumerFeaturesMap.forEach((featureClass, as) => {
        if (consumerDefaultFeaturesMap.get(featureClass)) {
          features[as] = featureClass;
        }
      });
    }
    return features;
  }
  static getInstanceFeatures(instance) {
    return instance.$meta.names.reduce((features, typeName) => Object.assign(features, this.getTypeNameFeatures(typeName)), {});
  }
  static getInstanceDefaultFeatures(instance) {
    return instance.$meta.names.reduce((features, typeName) => Object.entries(this.getTypeNameFeatures(typeName)).reduce((features2, [as, featureClass]) => {
      if (this.isDefaultFeatureForTypeName(featureClass, typeName)) {
        features2[as] = featureClass;
      } else {
        delete features2[as];
      }
      return features2;
    }, features), {});
  }
  static isDefaultFeatureForTypeName(featureClass, forType = DEFAULT_FOR_TYPE) {
    const type = remapToBase[forType] || forType, consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type);
    return consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.get(featureClass) || false;
  }
  static isDefaultFeatureForInstance(featureClass, instance) {
    const typeChain = instance.$meta.names.slice().reverse();
    let result = null;
    for (let i = 0, len = typeChain.length; i < len && result === null; ++i) {
      const consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(typeChain[i]);
      if (consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.has(featureClass)) {
        result = consumerDefaultFeaturesMap.get(featureClass);
      }
    }
    return result || false;
  }
  static reset() {
    consumerToFeatureMap.clear();
    consumerToDefaultFeatureMap.clear();
  }
};
var CellCopyPaste = class extends InstancePlugin {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "entityName", "cell");
  }
  afterConstruct() {
    super.afterConstruct();
    this.afterSelectionModeChange();
  }
  afterSelectionModeChange() {
    const me = this;
    if (!me.client.selectionMode.cell) {
      me.disabled = true;
    } else if (me._disabledBySelectionMode) {
      me.disabled = false;
      delete me._disabledBySelectionMode;
    }
  }
  get copyOnly() {
    var _this$client$features;
    return this._copyOnly || !((_this$client$features = this.client.features.cellEdit) !== null && _this$client$features !== void 0 && _this$client$features.enabled);
  }
  get canCopy() {
    return !this.disabled && !this.client.selectedRecords.length && this.client.selectedCells.length;
  }
  get canCutPaste() {
    var _this$client$features2;
    return this.canCopy && !this.copyOnly && !((_this$client$features2 = this.client.features.cellEdit) !== null && _this$client$features2 !== void 0 && _this$client$features2.isEditing) && !this.client.readOnly;
  }
  isActionAvailable(key, action) {
    return this.canCopy && (action === "copy" || this.canCutPaste);
  }
  async sendToClipboard(cells) {
    const me = this;
    let lastRowIndex = 0, lastColIndex = 0, stringData = "";
    cells.sort((c1, c2) => c1.rowIndex === c2.rowIndex ? c1.columnIndex - c2.columnIndex : c1.rowIndex - c2.rowIndex);
    for (const cell of cells) {
      var _column$toClipboardSt, _cellValue;
      const {
        record,
        column,
        rowIndex,
        columnIndex
      } = cell;
      if (rowIndex > lastRowIndex) {
        if (stringData.length > 0) {
          stringData += "\n".repeat(rowIndex - lastRowIndex);
        }
        lastRowIndex = rowIndex;
        lastColIndex = columnIndex;
      } else if (columnIndex > lastColIndex) {
        if (stringData.length > 0) {
          stringData += "	".repeat(columnIndex - lastColIndex);
        }
        lastColIndex = columnIndex;
      }
      let cellValue = (_column$toClipboardSt = column.toClipboardString) === null || _column$toClipboardSt === void 0 ? void 0 : _column$toClipboardSt.call(column, cell);
      if (cellValue === void 0) {
        var _record$get;
        cellValue = (_record$get = record.get(column.field)) === null || _record$get === void 0 ? void 0 : _record$get.toString();
      }
      if (me.toCopyString) {
        cellValue = me.toCopyString({
          currentValue: cellValue,
          column,
          record
        });
      }
      cellValue = (_cellValue = cellValue) === null || _cellValue === void 0 ? void 0 : _cellValue.replace(/[\n\t]/, " ");
      stringData += cellValue || me.emptyValueChar;
    }
    await BrowserHelper.writeToClipboard(stringData, this.useNativeClipboard);
    return stringData;
  }
  async cut() {
    await this.copy(true);
  }
  async copy(cut) {
    const me = this, {
      client,
      entityName
    } = me, isCut = typeof cut === "boolean" ? cut : false, cells = isCut ? client.selectedCells.filter((r) => {
      var _r$record;
      return !((_r$record = r.record) !== null && _r$record !== void 0 && _r$record.readOnly);
    }) : client.selectedCells;
    if (cells) {
      if ((isCut ? !me.canCutPaste : !me.canCopy) || client.trigger("beforeCopy", {
        cells,
        isCut,
        entityName
      }) === false) {
        return;
      }
      const copiedDataString = await me.sendToClipboard(cells);
      if (isCut === true) {
        for (const cell of cells) {
          if (!cell.column.readOnly) {
            cell.record.set(cell.column.field, null);
          }
        }
      }
      client.trigger("copy", {
        cells,
        copiedDataString,
        isCut,
        entityName
      });
    }
  }
  async paste() {
    const me = this, {
      client,
      entityName
    } = me, clipboardData = await BrowserHelper.readFromClipboard(me.useNativeClipboard), targetCell = client.selectedCells[0];
    if (!me.canCutPaste || !(clipboardData !== null && clipboardData !== void 0 && clipboardData.length) || !targetCell || client.trigger("beforePaste", {
      clipboardData,
      targetCell,
      entityName
    }) === false) {
      return;
    }
    const modifiedRecords = /* @__PURE__ */ new Set(), rows = me.stringAs2dArray(clipboardData), targetCells = [], {
      _shiftSelectRange
    } = client;
    if (!(rows !== null && rows !== void 0 && rows.length)) {
      return;
    }
    if (_shiftSelectRange !== null && _shiftSelectRange !== void 0 && _shiftSelectRange.some((cell) => cell.equals(targetCell))) {
      const cellRows = me.cellSelectorsAs2dArray(_shiftSelectRange);
      if ((cellRows === null || cellRows === void 0 ? void 0 : cellRows.length) % rows.length === 0 && cellRows.columnCount % rows.columnCount === 0) {
        for (let curI = 0; curI < cellRows.length; curI += rows.length) {
          for (let curX = 0; curX < cellRows.columnCount; curX += rows.columnCount) {
            targetCells.push(cellRows[curI][curX]);
          }
        }
      }
    }
    if (!targetCells.length) {
      targetCells.push(targetCell);
    }
    for (const targetCell2 of targetCells) {
      for (let rI = 0; rI < rows.length; rI++) {
        const row = rows[rI], targetRecord = client.store.getAt(targetCell2.rowIndex + rI);
        if (targetRecord && !targetRecord.readOnly) {
          for (let cI = 0; cI < row.length; cI++) {
            const targetColumn = client.columns.getAt(targetCell2.columnIndex + cI), targetField = targetColumn === null || targetColumn === void 0 ? void 0 : targetColumn.field;
            let value = row[cI];
            if (targetField && value && !targetColumn.readOnly) {
              if (value === me.emptyValueChar) {
                value = null;
              }
              if (targetColumn.fromClipboardString) {
                value = targetColumn.fromClipboardString({
                  string: value,
                  record: targetRecord
                });
              }
              if (me.toPasteValue) {
                value = me.toPasteValue({
                  currentValue: value,
                  record: targetRecord,
                  column: targetColumn,
                  field: targetField
                });
              }
              targetRecord.set(targetField, value, false, false, false, true);
              modifiedRecords.add(targetRecord);
            }
          }
        }
      }
    }
    client.trigger("paste", {
      clipboardData,
      targetCell,
      modifiedRecords: [...modifiedRecords],
      entityName
    });
  }
  cellSelectorsAs2dArray(locations) {
    const rows = [];
    let rId = null, columns;
    for (const location of locations) {
      if (location.id !== rId) {
        rId = location.id;
        columns = [];
        rows.push(columns);
      }
      columns.push(location);
    }
    rows.columnCount = rows[0].length;
    if (rows.some((row) => row.length !== rows.columnCount)) {
      return false;
    }
    return rows;
  }
  stringAs2dArray(string2) {
    const rows = [], stringRows = string2.split(/\r\n|(?!\r\n)[\n-\r\x85\u2028\u2029]/);
    for (const row of stringRows) {
      const columns = row.split("	");
      if (rows.columnCount && columns.length !== rows.columnCount) {
        return false;
      }
      rows.columnCount = columns.length;
      rows.push(columns);
    }
    return rows;
  }
  populateCellMenu({
    record,
    items: items2
  }) {
    const me = this;
    if (me.canCopy) {
      items2.cutCell = {
        text: me.cutText,
        localeClass: me,
        icon: "b-icon b-icon-cut",
        weight: 115,
        disabled: record.readOnly || !me.canCutPaste,
        onItem: () => me.cut()
      };
      items2.pasteCell = {
        text: me.pasteText,
        localeClass: me,
        icon: "b-icon b-icon-paste",
        weight: 120,
        disabled: record.readOnly || !me.canCutPaste,
        onItem: () => me.paste()
      };
      items2.copyCell = {
        text: me.copyText,
        localeClass: me,
        cls: "b-separator",
        icon: "b-icon b-icon-copy",
        weight: 110,
        onItem: () => me.copy()
      };
    }
  }
};
_defineProperty(CellCopyPaste, "$name", "CellCopyPaste");
_defineProperty(CellCopyPaste, "pluginConfig", {
  chain: ["populateCellMenu", "afterSelectionModeChange"]
});
_defineProperty(CellCopyPaste, "configurable", {
  copyOnly: null,
  emptyValueChar: " ",
  keyMap: {
    "Ctrl+C": "copy",
    "Ctrl+X": "cut",
    "Ctrl+V": "paste"
  },
  useNativeClipboard: !VersionHelper.isTestEnv,
  toCopyString: null,
  toPasteValue: null,
  copyText: "L{copy}",
  cutText: "L{cut}",
  pasteText: "L{paste}"
});
CellCopyPaste._$name = "CellCopyPaste";
GridFeatureManager.registerFeature(CellCopyPaste);
var editingActions = {
  finishAndEditNextRow: 1,
  finishAndEditPrevRow: 1,
  finishEditing: 1,
  cancelEditing: 1,
  finishAndEditNextCell: 1,
  finishAndEditPrevCell: 1
};
var CellEdit = class extends Delayable(InstancePlugin) {
  static get defaultConfig() {
    return {
      autoSelect: true,
      blurAction: "complete",
      continueEditingOnCellClick: true,
      addNewAtEnd: null,
      autoEdit: null,
      editNextOnEnterPress: true,
      editorClass: Editor,
      triggerEvent: "celldblclick",
      touchEditDelay: 300,
      focusCellAnimationDuration: false,
      multiEdit: true,
      keyMap: {
        Enter: ["startEditing", "finishAndEditNextRow"],
        "Ctrl+Enter": ["finishAllSelected", "finishEditing"],
        "Shift+Enter": "finishAndEditPrevRow",
        "Alt+Enter": "finishEditing",
        F2: ["startEditing", "finishEditing"],
        Escape: "cancelEditing",
        Tab: "finishAndEditNextCell",
        "Shift+Tab": "finishAndEditPrevCell"
      }
    };
  }
  static get pluginConfig() {
    return {
      assign: ["startEditing", "finishEditing", "cancelEditing"],
      before: ["onElementKeyDown", "onElementPointerUp"],
      chain: ["onElementClick", "bindStore"]
    };
  }
  construct(grid, config) {
    super.construct(grid, config);
    const me = this, gridListeners = {
      renderRows: "onGridRefreshed",
      cellClick: "onCellClick",
      thisObj: me
    };
    me.grid = grid;
    if (me.triggerEvent !== "cellclick") {
      gridListeners[me.triggerEvent] = "onTriggerEditEvent";
    }
    if (me.autoEdit && !("editNextOnEnterPress" in config)) {
      me.editNextOnEnterPress = false;
    }
    grid.ion(gridListeners);
    grid.rowManager.ion({
      changeTotalHeight: "onGridRefreshed",
      thisObj: me
    });
    me.bindStore(grid.store);
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      update: "onStoreUpdate",
      beforeSort: "onStoreBeforeSort",
      thisObj: this
    });
  }
  async confirm(options) {
    let result = true;
    if (this.editorContext) {
      MessageDialog.owner = this.editorContext.editor.inputField;
      options.rootElement = this.grid.rootElement;
      result = await MessageDialog.confirm(options);
      MessageDialog.owner = null;
    }
    return result === MessageDialog.yesButton;
  }
  doDestroy() {
    this.grid.columns.allRecords.forEach((column) => {
      var _column$_cellEditor;
      (_column$_cellEditor = column._cellEditor) === null || _column$_cellEditor === void 0 ? void 0 : _column$_cellEditor.destroy();
    });
    super.doDestroy();
  }
  doDisable(disable) {
    if (disable && !this.isConfiguring) {
      this.cancelEditing(true);
    }
    super.doDisable(disable);
  }
  set disabled(disabled) {
    super.disabled = disabled;
  }
  get disabled() {
    const {
      grid
    } = this;
    return Boolean(super.disabled || grid.disabled || grid.readOnly);
  }
  get isEditing() {
    return Boolean(this.editorContext);
  }
  get activeRecord() {
    var _this$editorContext;
    return ((_this$editorContext = this.editorContext) === null || _this$editorContext === void 0 ? void 0 : _this$editorContext.record) || null;
  }
  getEditorForCell({
    id,
    cell,
    column,
    columnId,
    editor
  }) {
    var _cellEditor;
    const me = this, {
      grid,
      editorClass
    } = me;
    let cellEditor = column.cellEditor, leftOffset = 0;
    if (column.editTargetSelector) {
      const editorTarget = cell.querySelector(column.editTargetSelector);
      leftOffset = editorTarget.offsetLeft;
    }
    editor.autoSelect = me.autoSelect;
    if (!((_cellEditor = cellEditor) !== null && _cellEditor !== void 0 && _cellEditor.isEditor)) {
      cellEditor = column.data.cellEditor = editorClass.create(editorClass.mergeConfigs({
        type: editorClass.type,
        constrainTo: null,
        cls: "b-cell-editor",
        inputField: editor,
        blurAction: "none",
        invalidAction: column.invalidAction,
        completeKey: false,
        cancelKey: false,
        owner: grid,
        align: {
          align: "t0-t0",
          offset: [leftOffset, 0]
        },
        internalListeners: me.getEditorListeners(),
        onInternalKeyDown: me.onEditorKeydown.bind(me),
        allowMouseEvents: editor.allowMouseEvents
      }, cellEditor));
    }
    cellEditor.minHeight = grid.rowHeight;
    if (cellEditor.inputField !== editor) {
      cellEditor.remove(cellEditor.items[0]);
      cellEditor.add(editor);
    }
    cellEditor.align.offset[0] = leftOffset;
    if (column.instantUpdate && !editor.cellEditValueSetter) {
      ObjectHelper.wrapProperty(editor, "value", null, (value) => {
        const {
          editorContext
        } = me, inputField = editorContext === null || editorContext === void 0 ? void 0 : editorContext.editor.inputField;
        if (editorContext !== null && editorContext !== void 0 && editorContext.editor.isValid && !ObjectHelper.isEqual(editorContext.record[editorContext.column.field], value) && (!(inputField !== null && inputField !== void 0 && inputField.isDateField) || inputField._isPickerInput)) {
          editorContext.record[editorContext.column.field] = value;
        }
      });
      editor.cellEditValueSetter = true;
    }
    Object.assign(cellEditor.element.dataset, {
      rowId: id,
      columnId,
      field: column.field
    });
    cellEditor.inputField.revertOnEscape = column.revertOnEscape;
    return me.editor = cellEditor;
  }
  getEditorListeners() {
    return {
      focusOut: "onEditorFocusOut",
      focusIn: "onEditorFocusIn",
      start: "onEditorStart",
      beforeComplete: "onEditorBeforeComplete",
      complete: "onEditorComplete",
      beforeCancel: "onEditorBeforeCancel",
      cancel: "onEditorCancel",
      beforeHide: "onBeforeEditorHide",
      finishEdit: "onEditorFinishEdit",
      thisObj: this
    };
  }
  onEditorStart({
    source: editor
  }) {
    const me = this, editorContext = me.editorContext = editor.cellEditorContext;
    if (editorContext) {
      var _me$removeEditingList;
      const {
        grid
      } = me;
      if (me.triggerEvent !== "cellclick") {
        me.detachListeners("cellClickWhileEditing");
        grid.ion({
          name: "cellClickWhileEditing",
          cellclick: "onCellClickWhileEditing",
          thisObj: me
        });
      }
      (_me$removeEditingList = me.removeEditingListeners) === null || _me$removeEditingList === void 0 ? void 0 : _me$removeEditingList.call(me);
      me.removeEditingListeners = GlobalEvents$1.addListener({
        globaltap: "onTapOut",
        thisObj: me
      });
      grid.trigger("startCellEdit", {
        grid,
        editorContext
      });
    }
  }
  onEditorBeforeComplete(context) {
    const {
      grid
    } = this, editor = context.source, editorContext = editor.cellEditorContext;
    context.grid = grid;
    context.editorContext = editorContext;
    return grid.trigger("beforeFinishCellEdit", context);
  }
  onEditorComplete({
    source: editor
  }) {
    const {
      grid
    } = this, editorContext = editor.cellEditorContext;
    editorContext.value = editor.inputField.value;
    grid.trigger("finishCellEdit", {
      grid,
      editorContext
    });
  }
  onEditorBeforeCancel() {
    const {
      editorContext
    } = this;
    return this.grid.trigger("beforeCancelCellEdit", {
      editorContext
    });
  }
  onEditorCancel({
    event
  }) {
    const {
      editorContext,
      muteEvents,
      grid
    } = this;
    if (!muteEvents) {
      grid.trigger("cancelCellEdit", {
        grid,
        editorContext,
        event
      });
    }
  }
  onBeforeEditorHide({
    source
  }) {
    const me = this, {
      row,
      cell
    } = source.cellEditorContext;
    cell === null || cell === void 0 ? void 0 : cell.classList.remove("b-editing");
    row === null || row === void 0 ? void 0 : row.removeCls("b-editing");
    me.detachListeners("cellClickWhileEditing");
    me.removeEditingListeners();
  }
  onEditorFinishEdit({
    source
  }) {
    source.cellEditorContext = this.editorContext = null;
  }
  getAdjacentEditableCell(cellInfo, isForward) {
    const {
      grid
    } = this, {
      store,
      columns
    } = grid, {
      visibleColumns
    } = columns;
    let rowId = cellInfo.id, column = columns.getAdjacentVisibleLeafColumn(cellInfo.columnId, isForward);
    while (rowId) {
      if (column) {
        if (column.editor && column.canEdit(store.getById(rowId))) {
          return {
            id: rowId,
            columnId: column.id
          };
        }
        column = columns.getAdjacentVisibleLeafColumn(column, isForward);
      } else {
        const record = store.getAdjacent(cellInfo.id, isForward, false, true);
        rowId = record === null || record === void 0 ? void 0 : record.id;
        if (record) {
          column = isForward ? visibleColumns[0] : visibleColumns[visibleColumns.length - 1];
        }
      }
    }
    return null;
  }
  doAddNewAtEnd() {
    const newRecordConfig = typeof this.addNewAtEnd === "object" ? ObjectHelper.clone(this.addNewAtEnd) : {}, {
      grid
    } = this, record = grid.store.add(newRecordConfig)[0];
    if (!grid.rowManager.getRowFor(record)) {
      grid.rowManager.displayRecordAtBottom();
    }
    return record;
  }
  getEditingContext(cellContext) {
    cellContext = this.grid.normalizeCellContext(cellContext);
    const {
      column,
      record
    } = cellContext;
    if (column !== null && column !== void 0 && column.isVisible && column.editor && record && !record.isSpecialRow && !record.readOnly && column.canEdit(record)) {
      const value = record ? column.getRawValue(record) : record;
      Object.assign(cellContext, {
        value: value === void 0 ? null : value,
        editor: column.editor
      });
      return cellContext;
    } else {
      return false;
    }
  }
  async startEditing(cellContext = {}) {
    const me = this;
    if (!me.disabled) {
      var _cellContext, _grid$focusedCell, _me$onCellEditStart;
      const {
        grid
      } = me;
      if ((_cellContext = cellContext) !== null && _cellContext !== void 0 && _cellContext.fromKeyMap) {
        cellContext = me.grid.focusedCell;
      }
      if (ObjectHelper.isEmpty(cellContext)) {
        cellContext.id = grid.firstVisibleRow.id;
      }
      if (grid.store.isTree && grid.features.tree) {
        var _cellContext$record;
        const record2 = cellContext.id ? grid.store.getById(cellContext.id) : (_cellContext$record = cellContext.record) !== null && _cellContext$record !== void 0 ? _cellContext$record : grid.store.getAt(cellContext.row);
        if (record2) {
          await grid.expandTo(record2);
        } else {
          return false;
        }
      }
      const editorContext = me.getEditingContext(cellContext);
      if (!editorContext) {
        return false;
      }
      if (me.editorContext) {
        me.cancelEditing();
      }
      if (!((_grid$focusedCell = grid.focusedCell) !== null && _grid$focusedCell !== void 0 && _grid$focusedCell.equals(editorContext))) {
        grid.focusCell(editorContext);
      }
      if (grid.trigger("beforeCellEditStart", {
        grid,
        editorContext
      }) === false) {
        return false;
      }
      const editor = editorContext.editor = me.getEditorForCell(editorContext), {
        row,
        cell,
        record
      } = editorContext;
      editor.inputField.highlightExternalChange = false;
      editor.cellEditorContext = editorContext;
      editor.render(cell);
      cell.classList.add("b-editing");
      row.addCls("b-editing");
      if (!await editor.startEdit({
        target: cell,
        field: editor.inputField.name || editorContext.column.field,
        value: editorContext.value,
        record
      })) {
        cell.classList.remove("b-editing");
        row.removeCls("b-editing");
      }
      (_me$onCellEditStart = me.onCellEditStart) === null || _me$onCellEditStart === void 0 ? void 0 : _me$onCellEditStart.call(me);
      return true;
    }
    return false;
  }
  cancelEditing(silent = false, triggeredByEvent) {
    var _me$afterCellEdit;
    const me = this, {
      editorContext,
      editor
    } = me;
    if (silent.fromKeyMap) {
      triggeredByEvent = silent;
      silent = false;
    }
    if (editorContext) {
      me.muteEvents = silent;
      editor.cancelEdit(triggeredByEvent);
      me.muteEvents = false;
    }
    me.finishEditingPromise = false;
    (_me$afterCellEdit = me.afterCellEdit) === null || _me$afterCellEdit === void 0 ? void 0 : _me$afterCellEdit.call(me);
  }
  async finishEditing() {
    const me = this, {
      editorContext,
      grid
    } = me;
    let result = false;
    if (me.finishEditingPromise) {
      return me.finishEditingPromise;
    }
    if (editorContext) {
      var _me$afterCellEdit2;
      const {
        column
      } = editorContext;
      me.finishEditingPromise = editorContext.editor.completeEdit(column.bindCallback(column.finalizeCellEdit));
      result = await me.finishEditingPromise;
      await grid.waitForAnimations();
      me.finishEditingPromise = null;
      (_me$afterCellEdit2 = me.afterCellEdit) === null || _me$afterCellEdit2 === void 0 ? void 0 : _me$afterCellEdit2.call(me);
    }
    return result;
  }
  async onCellClickWhileEditing({
    event,
    cellSelector
  }) {
    const me = this;
    if (DomHelper.isTouchEvent) {
      await me.finishEditing();
      return;
    }
    if (me.finishEditingPromise) {
      return;
    }
    if (me.editorContext && !me.editorContext.editor.owns(event.target)) {
      if (me.getEditingContext(cellSelector)) {
        if (await me.finishEditing()) {
          if (me.continueEditingOnCellClick) {
            await me.startEditing(cellSelector);
          }
        } else {
          me.grid.focusCell(me.editorContext);
          me.editor.inputField.focus();
        }
      } else {
        await me.finishEditing();
      }
    }
  }
  async onCellClick({
    source: grid,
    cellSelector,
    target,
    event,
    column
  }) {
    if (column.onCellClick) {
      return;
    }
    const me = this, {
      focusedCell
    } = me.client;
    if (target.closest(".b-tree-expander")) {
      return false;
    } else if (DomHelper.isTouchEvent && me._lastCellClicked === (focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.cell) && event.timeStamp - me.touchEditDelay > me._lastCellClickedTime) {
      await me.startEditing(cellSelector);
    } else if (this.triggerEvent === "cellclick") {
      await me.onTriggerEditEvent({
        cellSelector,
        target
      });
    }
    me._lastCellClicked = focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.cell;
    me._lastCellClickedTime = event.timeStamp;
  }
  onElementPointerUp(event) {
    if (event.target.closest(".b-tree-expander")) {
      this.cancelEditing(void 0, event);
    }
  }
  async onTriggerEditEvent({
    cellSelector,
    target,
    event
  }) {
    var _client$features$cell;
    const {
      editorContext,
      client
    } = this;
    if (target.closest(".b-tree-expander") || DomHelper.isTouchEvent && event.type === "dblclick") {
      return;
    }
    if (event && ((_client$features$cell = client.features.cellMenu) === null || _client$features$cell === void 0 ? void 0 : _client$features$cell.triggerEvent) === event.type) {
      return;
    }
    if (editorContext) {
      if (editorContext.equals(this.grid.normalizeCellContext(cellSelector)) || !await this.finishEditing()) {
        return;
      }
    }
    await this.startEditing(cellSelector);
  }
  onStoreUpdate({
    changes,
    record
  }) {
    const {
      editorContext
    } = this;
    if (editorContext !== null && editorContext !== void 0 && editorContext.editor.isVisible) {
      if (record === editorContext.record && editorContext.editor.dataField in changes) {
        editorContext.editor.refreshEdit();
      }
    }
  }
  onStoreBeforeSort() {
    var _this$editorContext2;
    const editor = (_this$editorContext2 = this.editorContext) === null || _this$editorContext2 === void 0 ? void 0 : _this$editorContext2.editor;
    if (this.isEditing && !(editor !== null && editor !== void 0 && editor.isFinishing) && !editor.isValid) {
      this.cancelEditing();
    }
  }
  onGridRefreshed() {
    const me = this, {
      grid,
      editorContext
    } = me;
    if (editorContext && grid.isVisible && grid.focusedCell) {
      const cell = grid.getCell(grid.focusedCell), {
        editor
      } = editorContext;
      if (cell && DomHelper.isInView(cell) && !editor.isFinishing) {
        editorContext._cell = cell;
        GlobalEvents$1.suspendFocusEvents();
        editor.render(cell);
        editor.showBy(cell);
        editor.focus();
        GlobalEvents$1.resumeFocusEvents();
      } else {
        me.cancelEditing();
      }
    }
  }
  get gridSelection() {
    return [...this.grid.selectedRecords, ...this.grid.selectedCells];
  }
  isActionAvailable(keyCombination, action, event) {
    const me = this;
    action = action.replace("cellEdit.", "");
    if (!me.disabled && !event.target.closest(".b-grid-header")) {
      if (me.isEditing) {
        if (action === "finishAllSelected") {
          return me.multiEdit && me.gridSelection.length > 1;
        } else if (editingActions[action]) {
          return true;
        }
      } else if (action === "startEditing") {
        return me.grid.focusedCell.cell === event.target;
      }
    }
    return false;
  }
  async finishAllSelected() {
    const me = this, {
      dataField,
      record
    } = me.editor;
    if (await me.finishEditing() && !me.isDestroyed) {
      for (const selected of me.gridSelection) {
        if (selected.isModel) {
          if (selected !== record) {
            selected[dataField] = record[dataField];
          }
        } else {
          selected.record.set(selected.column.field, record[dataField]);
        }
      }
    }
  }
  async finishAndEditNextRow(event, previous = false) {
    const me = this, {
      grid
    } = me, {
      record
    } = me.editorContext;
    let nextCell;
    if (await me.finishEditing()) {
      if (me.isDestroyed) {
        return;
      }
      if (!me.isEditing) {
        if (previous) {
          nextCell = grid.internalNextPrevRow(false, true, event, false);
        } else {
          if (me.addNewAtEnd && record === grid.store.last) {
            await me.doAddNewAtEnd();
          }
          if (!me.isDestroyed) {
            nextCell = grid.internalNextPrevRow(true, true, event);
          }
        }
        if (nextCell && me.editNextOnEnterPress && !grid.touch) {
          me.startEditing(nextCell);
        }
      }
    }
  }
  finishAndEditPrevRow(event) {
    this.finishAndEditNextRow(event, true);
  }
  async finishAndEditNextCell(event, previous = false) {
    const me = this, {
      focusedCell
    } = me.grid;
    if (focusedCell) {
      let cellInfo = me.getAdjacentEditableCell(focusedCell, !previous);
      if (!cellInfo && !previous && me.addNewAtEnd) {
        const currentEditableFinalizationResult = await me.finishEditing();
        if (currentEditableFinalizationResult === true) {
          await this.doAddNewAtEnd();
          cellInfo = !me.isDestroyed && me.getAdjacentEditableCell(focusedCell, !previous);
        }
      }
      if (cellInfo) {
        let finalizationResult = true;
        if (me.isEditing) {
          finalizationResult = await me.finishEditing();
        }
        if (!me.isDestroyed && finalizationResult) {
          me.grid.focusCell(cellInfo, {
            animate: me.focusCellAnimationDuration
          });
          if (!await me.startEditing(cellInfo)) {
            await me.finishAndEditNextCell(event, previous);
          }
        }
      }
    }
  }
  finishAndEditPrevCell(event) {
    this.finishAndEditNextCell(event, true);
  }
  async onElementKeyDown(event) {
    const me = this, {
      grid
    } = me, {
      focusedCell
    } = grid, {
      key
    } = event;
    if (event.handled || !me.autoEdit || me.isEditing || !focusedCell || focusedCell.isActionable || event.ctrlKey) {
      return;
    }
    if (key.length <= 1 && await me.startEditing(focusedCell)) {
      const {
        inputField
      } = me.editor, {
        input
      } = inputField;
      if (input) {
        inputField.internalOnKeyEvent(event);
        if (!event.defaultPrevented) {
          input.value = key;
          inputField.internalOnInput(event);
        }
      }
      event.preventDefault();
    } else if (event.key === "Delete" || event.key === "Backspace") {
      const {
        gridSelection
      } = me;
      if (me.multiEdit && gridSelection.length > 1) {
        for (const selected of gridSelection) {
          if (selected.isModel) {
            grid.visibleColumns.forEach((col) => {
              selected.set(col.field, null);
            });
          } else {
            selected.record.set(selected.column.field, null);
          }
        }
      } else {
        focusedCell.record.set(focusedCell.column.field, null);
      }
    }
  }
  onEditorKeydown(event) {
    if (event.key.startsWith("Arrow")) {
      event.handled = true;
      event.stopPropagation();
      return false;
    }
  }
  async onEditorFocusOut(event) {
    const me = this, {
      grid,
      editor,
      editorContext
    } = me, toCell = new Location(event.relatedTarget), isEditableCellClick = toCell.grid === grid && me.getEditingContext(toCell);
    if (editorContext && !editor.isFinishing && editor.owns(event._target)) {
      if (me.blurAction === "cancel") {
        me.cancelEditing(void 0, event);
      } else if (!me.finishEditingPromise && (me.triggerEvent === "cellclick" || me.triggerEvent !== "cellclick" && !isEditableCellClick)) {
        await me.finishEditing();
      }
    }
  }
  onEditorFocusIn(event) {
    const widget = event.toWidget;
    if (widget === this.editor.inputField) {
      if (this.autoSelect && widget.selectAll && !widget.readOnly && !widget.disabled) {
        widget.selectAll();
      }
    }
  }
  async onTapOut({
    event
  }) {
    const me = this;
    if (!me.grid.bodyContainer.contains(event.target) || event.button) {
      if (!me.editor.owns(event.target)) {
        me.editingStoppedByTapOutside = true;
        if (me.blurAction === "cancel") {
          me.cancelEditing(void 0, event);
        } else {
          await me.finishEditing();
        }
        delete me.editingStoppedByTapOutside;
      }
    }
  }
  async onElementClick(event) {
    if (event.target.classList.contains("b-grid-body-container") && this.editorContext) {
      await this.finishEditing();
    }
  }
};
_defineProperty(CellEdit, "$name", "CellEdit");
CellEdit._$name = "CellEdit";
GridFeatureManager.registerFeature(CellEdit, true);
var CellMenu = class extends ContextMenuBase {
  static get $name() {
    return "CellMenu";
  }
  static get defaultConfig() {
    return {
      processItems: null,
      items: null,
      type: "cell"
    };
  }
  static get pluginConfig() {
    const config = super.pluginConfig;
    config.chain.push("populateCellMenu");
    return config;
  }
  showContextMenu(eventParams) {
    const me = this, {
      cellSelector,
      event
    } = eventParams;
    me.client.focusCell(cellSelector, {
      doSelect: !me.client.isSelected(cellSelector),
      event
    });
    super.showContextMenu(eventParams);
  }
  shouldShowMenu({
    column
  }) {
    return column && column.enableCellContextMenu !== false;
  }
  getDataFromEvent(event) {
    const cellData = this.client.getCellDataFromEvent(event);
    if (cellData) {
      return ObjectHelper.assign(super.getDataFromEvent(event), cellData);
    }
  }
  beforeContextMenuShow({
    record,
    items: items2,
    column
  }) {
    if (column.cellMenuItems === false) {
      return false;
    }
    if (!record || record.isSpecialRow) {
      items2.removeRow = false;
    }
  }
  populateCellMenu({
    items: items2,
    column,
    record
  }) {
    const {
      client
    } = this;
    if (column !== null && column !== void 0 && column.cellMenuItems) {
      ObjectHelper.merge(items2, column.cellMenuItems);
    }
    if (!client.readOnly) {
      items2.removeRow = {
        text: "L{removeRow}",
        localeClass: this,
        icon: "b-fw-icon b-icon-trash",
        cls: "b-separator",
        weight: 100,
        disabled: record.readOnly,
        onItem: () => client.store.remove(client.selectedRecords.filter((r) => !r.readOnly))
      };
    }
  }
  get showMenu() {
    return true;
  }
};
CellMenu.featureClass = "";
CellMenu._$name = "CellMenu";
GridFeatureManager.registerFeature(CellMenu, true, ["Grid", "Scheduler"]);
GridFeatureManager.registerFeature(CellMenu, false, ["Gantt"]);
var CellTooltip = class extends InstancePlugin {
  construct(grid, config) {
    super.construct(grid, this.processConfig(config));
  }
  initTip() {
    const me = this;
    me.tip = Tooltip.new({
      forElement: me.client.element,
      forSelector: ".b-grid-row:not(.b-group-row) .b-grid-cell, .b-grid-merged-cells",
      hoverDelay: 1e3,
      trackMouse: false,
      cls: "b-celltooltip-tip",
      getHtml: me.getTooltipContent.bind(me),
      internalListeners: {
        pointerOver: "onPointerOver",
        thisObj: me
      },
      listeners: me.configuredListeners
    }, me.initialConfig);
    me.relayEvents(me.tip, ["beforeShow", "show"]);
  }
  onPointerOver({
    target
  }) {
    const column = this.client.getColumnFromElement(target);
    return column.tooltipRenderer !== false && Boolean(column.tooltipRenderer || this.tooltipRenderer);
  }
  processConfig(config) {
    if (typeof config === "function") {
      return {
        tooltipRenderer: config
      };
    }
    return config;
  }
  setConfig(config) {
    super.setConfig(this.processConfig(config));
  }
  doDestroy() {
    this.tip && this.tip.destroy();
    super.doDestroy();
  }
  doDisable(disable) {
    if (!disable) {
      this.initTip();
    } else if (this.tip) {
      this.tip.destroy();
      this.tip = null;
    }
    super.doDisable(disable);
  }
  getTooltipContent({
    tip,
    activeTarget: cellElement,
    event
  }) {
    const me = this, record = me.client.getRecordFromElement(cellElement), column = me.client.getColumnFromElement(cellElement), arg = {
      cellElement,
      record,
      column,
      event,
      tip,
      cellTooltip: me
    };
    let result;
    if (!me.forSelector && record === me.lastRecord && record.generation === me.lastRecordGeneration && column === me.lastColumn) {
      return me.tip._html;
    }
    me.lastRecord = record;
    me.lastRecordGeneration = record.generation;
    me.lastColumn = column;
    if (column.tooltipRenderer) {
      result = column.tooltipRenderer(arg);
    } else if (me.tooltipRenderer && column.tooltipRenderer !== false) {
      result = me.tooltipRenderer(arg);
    }
    if (Objects.isPromise(result)) {
      me.lastRecord = me.lastRecordGeneration = me.lastColumn = null;
    }
    return result;
  }
};
_defineProperty(CellTooltip, "$name", "CellTooltip");
_defineProperty(CellTooltip, "configurable", {
  tooltipRenderer: null
});
CellTooltip._$name = "CellTooltip";
GridFeatureManager.registerFeature(CellTooltip);
var storeListenerName$1 = "store";
var ColumnAutoWidth = class extends Delayable(InstancePlugin) {
  static get $name() {
    return "ColumnAutoWidth";
  }
  static get configurable() {
    return {
      default: null,
      delay: 0
    };
  }
  static get pluginConfig() {
    return {
      after: {
        bindStore: "bindStore",
        unbindStore: "unbindStore",
        renderRows: "syncAutoWidthColumns",
        onInternalResize: "onInternalResize"
      },
      assign: ["columnAutoWidthPending", "syncAutoWidthColumns"]
    };
  }
  construct(config) {
    super.construct(config);
    const {
      store
    } = this.client;
    store && this.bindStore(store);
  }
  doDestroy() {
    this.unbindStore();
    super.doDestroy();
  }
  bindStore(store) {
    this.lastSync = null;
    store.ion({
      name: storeListenerName$1,
      [`change${this.client.asyncEventSuffix}`]: "onStoreChange",
      thisObj: this
    });
  }
  unbindStore() {
    this.detachListeners(storeListenerName$1);
  }
  get columnAutoWidthPending() {
    return this.lastSync === null || this.hasTimeout("syncAutoWidthColumns");
  }
  onStoreChange({
    action
  }) {
    if (action !== "move") {
      const me = this, {
        cellEdit
      } = me.client.features;
      ++me.storeGeneration;
      if (cellEdit !== null && cellEdit !== void 0 && cellEdit.isEditing && !cellEdit.editingStoppedByTapOutside) {
        me.syncAutoWidthColumns();
      } else if (!me.hasTimeout("syncAutoWidthColumns")) {
        me.setTimeout("syncAutoWidthColumns", me.delay);
      }
    }
  }
  onInternalResize(element, newWidth, newHeight, oldWidth) {
    if (oldWidth === 0) {
      this.lastSync = null;
      this.syncAutoWidthColumns();
    }
  }
  syncAutoWidthColumns() {
    const me = this, grid = me.client, storeGeneration = me.storeGeneration;
    if (me.lastSync !== storeGeneration) {
      me.lastSync = storeGeneration;
      let autoWidth, resizingColumns;
      for (const column of grid.columns.visibleColumns) {
        autoWidth = column.autoWidth;
        if (autoWidth) {
          if (autoWidth === true) {
            autoWidth = me.default;
          }
          grid.resizingColumns = resizingColumns = true;
          column.resizeToFitContent(autoWidth);
        }
      }
      if (resizingColumns) {
        grid.resizingColumns = false;
        grid.afterColumnsResized();
      }
    }
    if (me.hasTimeout("syncAutoWidthColumns")) {
      me.clearTimeout("syncAutoWidthColumns");
    }
  }
};
ColumnAutoWidth.prototype.storeGeneration = 0;
ColumnAutoWidth._$name = "ColumnAutoWidth";
GridFeatureManager.registerFeature(ColumnAutoWidth, true);
var ColumnDragToolbar = class extends Delayable(InstancePlugin) {
  static get $name() {
    return "ColumnDragToolbar";
  }
  static get pluginConfig() {
    return {
      after: ["render"]
    };
  }
  construct(grid, config) {
    var _grid$features$column;
    (_grid$features$column = grid.features.columnReorder) === null || _grid$features$column === void 0 ? void 0 : _grid$features$column.ion({
      beforeDestroy: "onColumnReorderBeforeDestroy",
      thisObj: this
    });
    this.grid = grid;
    super.construct(grid, config);
  }
  doDestroy() {
    const me = this;
    if (me.grid.features.columnReorder && !me.grid.features.columnReorder.isDestroyed) {
      me.detachFromColumnReorder();
    }
    me.element && me.element.remove();
    me.element = null;
    super.doDestroy();
  }
  doDisable(disable) {
    if (this.initialized) {
      if (disable) {
        this.detachFromColumnReorder();
      } else {
        this.init();
      }
    }
    super.doDisable(disable);
  }
  init() {
    const me = this, grid = me.grid;
    if (!grid.features.columnReorder) {
      return;
    }
    me.reorderDetacher = grid.features.columnReorder.ion({
      gridheaderdragstart({
        context
      }) {
        const column = grid.columns.getById(context.element.dataset.columnId);
        me.showToolbar(column);
      },
      gridheaderdrag: ({
        context
      }) => me.onDrag(context),
      gridheaderabort: () => {
        me.hideToolbar();
      },
      gridheaderdrop: ({
        context
      }) => {
        if (context.valid) {
          me.hideToolbar();
        } else {
          me.onDrop(context);
        }
      },
      thisObj: me
    });
    me.initialized = true;
  }
  onColumnReorderBeforeDestroy() {
    this.detachFromColumnReorder();
  }
  detachFromColumnReorder() {
    const me = this;
    me.grid.features.columnReorder.un("beforedestroy", me.onColumnReorderBeforeDestroy, me);
    me.reorderDetacher && me.reorderDetacher();
    me.reorderDetacher = null;
  }
  render() {
    if (!this.initialized) {
      this.init();
    }
  }
  showToolbar(column) {
    const me = this, buttons = me.grid.getColumnDragToolbarItems(column, []), groups = [];
    me.clearTimeout(me.buttonHideTimer);
    buttons.forEach((button) => {
      button.text = button.localeClass.L(button.text);
      let group = groups.find((group2) => group2.text === button.group);
      if (!group) {
        group = {
          text: button.localeClass.L(button.group),
          buttons: []
        };
        groups.push(group);
      }
      group.buttons.push(button);
    });
    me.element = DomHelper.append(me.grid.element, me.template(groups));
    me.groups = groups;
    me.buttons = buttons;
    me.column = column;
  }
  async hideToolbar() {
    const me = this, element = me.element;
    if (element) {
      element.classList.add("b-remove");
      await EventHelper.waitForTransitionEnd({
        element,
        mode: "animation",
        thisObj: me.client
      });
      element.remove();
      me.element = null;
    }
  }
  onDrag(info) {
    var _info$targetElement;
    const me = this;
    if (info.dragProxy.getBoundingClientRect().top - me.grid.element.getBoundingClientRect().top > 100) {
      me.element.classList.add("b-closer");
    } else {
      me.element.classList.remove("b-closer");
    }
    if (me.hoveringButton) {
      me.hoveringButton.classList.remove("b-hover");
      me.hoveringButton = null;
    }
    if ((_info$targetElement = info.targetElement) !== null && _info$targetElement !== void 0 && _info$targetElement.closest(".b-columndragtoolbar")) {
      me.element.classList.add("b-hover");
      const button = info.targetElement.closest(".b-columndragtoolbar  .b-target-button:not([data-disabled=true])");
      if (button) {
        button.classList.add("b-hover");
        me.hoveringButton = button;
      }
    } else {
      me.element.classList.remove("b-hover");
    }
  }
  onDrop(info) {
    const me = this;
    if (info.targetElement && info.targetElement.matches(".b-columndragtoolbar .b-target-button:not([data-disabled=true])")) {
      const buttonEl = info.targetElement, button = me.buttons.find((button2) => button2.ref === buttonEl.dataset.ref);
      if (button) {
        buttonEl.classList.add("b-activate");
        me.buttonHideTimer = me.setTimeout(() => {
          me.hideToolbar();
          button.onDrop({
            column: me.column
          });
        }, 100);
      }
    } else {
      me.hideToolbar();
    }
  }
  template(groups) {
    return TemplateHelper.tpl`
            <div class="b-columndragtoolbar">     
            <div class="b-title"></div>          
            ${groups.map((group) => TemplateHelper.tpl`
                <div class="b-group">
                    <div class="b-buttons">
                    ${group.buttons.map((btn) => TemplateHelper.tpl`
                        <div class="b-target-button" data-ref="${btn.ref}" data-disabled="${btn.disabled}">
                            <i class="${btn.icon}"></i>
                            ${btn.text}
                        </div>
                    `)}
                    </div>
                    <div class="b-title">${group.text}</div>
                </div>
            `)}
            </div>`;
  }
};
ColumnDragToolbar.featureClass = "b-hascolumndragtoolbar";
ColumnDragToolbar._$name = "ColumnDragToolbar";
GridFeatureManager.registerFeature(ColumnDragToolbar, BrowserHelper.isTouchDevice);
var ColumnPicker = class extends InstancePlugin {
  static get pluginConfig() {
    return {
      chain: ["populateHeaderMenu", "getColumnDragToolbarItems"]
    };
  }
  get grid() {
    return this.client;
  }
  getColumnPickerItems(columnStore) {
    const me = this, {
      createColumnsFromModel
    } = me;
    let result;
    if (me.groupByRegion) {
      result = me.grid.regions.map((region) => {
        const columns = me.grid.getSubGrid(region).columns.topColumns;
        return {
          text: StringHelper.capitalize(region),
          menu: me.buildColumnMenu(columns),
          disabled: columns.length === 0,
          region
        };
      });
      if (createColumnsFromModel) {
        result.push({
          text: me.L("L{newColumns}"),
          menu: me.createAutoColumnItems()
        });
      }
    } else if (me.groupByTag) {
      const tags = {};
      columnStore.topColumns.forEach((column) => {
        column.tags && Array.isArray(column.tags) && column.hideable !== false && column.tags.forEach((tag) => {
          if (!tags[tag]) {
            tags[tag] = 1;
          }
        });
      });
      result = Object.keys(tags).sort().map((tag) => ({
        text: StringHelper.capitalize(tag),
        menu: me.buildColumnMenu(me.getColumnsForTag(tag)),
        tag,
        onBeforeSubMenu: ({
          item,
          itemEl
        }) => {
          me.refreshTagMenu(item, itemEl);
        }
      }));
      if (createColumnsFromModel) {
        result.push({
          text: me.L("L{newColumns}"),
          menu: me.createAutoColumnItems()
        });
      }
    } else {
      result = me.buildColumnMenu(columnStore.topColumns);
      if (createColumnsFromModel) {
        result.items.push(...ObjectHelper.transformNamedObjectToArray(me.createAutoColumnItems()));
      }
    }
    return result;
  }
  createAutoColumnItems() {
    const me = this, {
      grid
    } = me, {
      columns,
      store
    } = grid, {
      modelClass
    } = store, {
      allFields
    } = modelClass, result = {};
    for (let i = 0, {
      length
    } = allFields; i < length; i++) {
      const field = allFields[i], fieldName = field.name;
      if (!columns.get(fieldName)) {
        if (!field.internal) {
          result[fieldName] = {
            text: field.text || StringHelper.separate(field.name),
            checked: false,
            onToggle: (event) => {
              const column = columns.get(fieldName);
              if (column) {
                column[event.checked ? "show" : "hide"]();
              } else {
                columns.add(columns.generateColumnForField(field, {
                  region: me.forColumn.region
                }));
              }
              event.bubbles = false;
            }
          };
        }
      }
    }
    return result;
  }
  getColumnsForTag(tag) {
    return this.grid.columns.records.filter((column) => column.tags && Array.isArray(column.tags) && column.tags.includes(tag) && column.hideable !== false);
  }
  refreshTagMenu(item, itemEl) {
    const columns = this.getColumnsForTag(item.tag);
    columns.forEach((column) => {
      const subItem = item.items.find((subItem2) => subItem2.column === column);
      if (subItem)
        subItem.checked = column.hidden !== true;
    });
  }
  buildColumnMenu(columns) {
    let currentRegion = columns.length > 0 && columns[0].region;
    const {
      grid
    } = this, items2 = columns.reduce((items3, column) => {
      const visibleInRegion = grid.columns.visibleColumns.filter((col) => col.region === column.region);
      if (column.hideable !== false) {
        const itemConfig = {
          grid,
          column,
          text: column.headerText,
          checked: column.hidden !== true,
          disabled: column.hidden !== true && visibleInRegion.length === 1,
          cls: column.region !== currentRegion ? "b-separator" : ""
        };
        currentRegion = column.region;
        if (column.children && !column.isCollapsible) {
          itemConfig.menu = this.buildColumnMenu(column.children);
        }
        items3.push(itemConfig);
      }
      return items3;
    }, []);
    return {
      cls: this.menuCls,
      items: items2
    };
  }
  populateHeaderMenu({
    column,
    items: items2
  }) {
    const me = this, {
      columns
    } = me.grid;
    me.forColumn = column;
    if (column.showColumnPicker !== false && columns.some((col) => col.hideable)) {
      items2.columnPicker = {
        text: "L{columnsMenu}",
        localeClass: me,
        icon: "b-fw-icon b-icon-columns",
        cls: "b-separator",
        weight: 200,
        menu: me.getColumnPickerItems(columns),
        onToggle: me.onColumnToggle,
        disabled: me.disabled
      };
    }
    if (column.hideable !== false && !column.parent.isCollapsible) {
      const visibleInRegion = columns.visibleColumns.filter((col) => col.region === column.region);
      items2.hideColumn = {
        text: "L{hideColumn}",
        localeClass: me,
        icon: "b-fw-icon b-icon-hide-column",
        weight: 210,
        disabled: visibleInRegion.length === 1 || me.disabled,
        onItem: () => column.hide()
      };
    }
  }
  onColumnToggle({
    menu,
    item,
    checked
  }) {
    if (Boolean(item.column.hidden) !== !checked) {
      var _features$headerMenu, _item$menu;
      item.column[checked ? "show" : "hide"]();
      const {
        grid,
        column
      } = item, {
        columns,
        features
      } = grid, siblingItems = menu.items, visibleInRegion = columns.visibleColumns.filter((col) => col.region === item.column.region), hideItem = ((_features$headerMenu = features.headerMenu) === null || _features$headerMenu === void 0 ? void 0 : _features$headerMenu.enabled) && features.headerMenu.menu.widgetMap.hideColumn;
      if (visibleInRegion.length === 1) {
        const lastVisibleItem = siblingItems.find((menuItem) => menuItem.column === visibleInRegion[0]);
        if (lastVisibleItem) {
          lastVisibleItem.disabled = true;
        }
        if (hideItem && column.region === item.column.region) {
          hideItem.disabled = true;
        }
      } else {
        visibleInRegion.forEach((col) => {
          const siblingItem = siblingItems.find((sibling) => sibling.column === col);
          if (siblingItem) {
            siblingItem.disabled = false;
          }
        });
        if (hideItem && column.region === item.column.region) {
          hideItem.disabled = false;
        }
      }
      (_item$menu = item.menu) === null || _item$menu === void 0 ? void 0 : _item$menu.eachWidget((subItem) => {
        subItem.checked = checked;
      });
      const parentItem = menu.owner;
      if (parentItem && parentItem.column === column.parent) {
        parentItem.checked = siblingItems.some((subItem) => subItem.checked === true);
      }
    }
  }
  getColumnDragToolbarItems(column, items2) {
    const visibleInRegion = this.grid.columns.visibleColumns.filter((col) => col.region === column.region);
    if (column.hideable !== false && visibleInRegion.length > 1) {
      items2.push({
        text: "L{hideColumnShort}",
        ref: "hideColumn",
        group: "L{column}",
        localeClass: this,
        icon: "b-fw-icon b-icon-hide-column",
        weight: 101,
        onDrop: ({
          column: column2
        }) => column2.hide()
      });
    }
    return items2;
  }
};
_defineProperty(ColumnPicker, "$name", "ColumnPicker");
_defineProperty(ColumnPicker, "configurable", {
  groupByRegion: false,
  groupByTag: false,
  createColumnsFromModel: false,
  menuCls: "b-column-picker-menu b-sub-menu"
});
ColumnPicker._$name = "ColumnPicker";
GridFeatureManager.registerFeature(ColumnPicker, true);
var ColumnRename = class extends InstancePlugin {
  doDestroy() {
    var _this$editor;
    (_this$editor = this.editor) === null || _this$editor === void 0 ? void 0 : _this$editor.destroy();
    super.doDestroy();
  }
  static get pluginConfig() {
    return {
      after: ["populateHeaderMenu"]
    };
  }
  populateHeaderMenu({
    items: items2,
    column
  }) {
    items2.rename = {
      weight: 215,
      icon: "b-fw-icon b-icon-edit",
      text: this.L("L{rename}"),
      disabled: column.readOnly,
      onItem: () => this.startEdit(column)
    };
  }
  startEdit(column) {
    if (column instanceof Event) {
      var _this$client$getHeade;
      column = (_this$client$getHeade = this.client.getHeaderDataFromEvent(column)) === null || _this$client$getHeade === void 0 ? void 0 : _this$client$getHeade.column;
    }
    if (column) {
      if (column.readOnly) {
        return false;
      }
      const {
        textWrapper
      } = column;
      let {
        editor
      } = this;
      if (!editor) {
        this.editor = editor = new Editor({
          owner: this.client,
          align: {
            align: "t0-t0"
          }
        });
      }
      editor.render(textWrapper);
      editor.startEdit({
        target: textWrapper,
        record: column,
        field: "text"
      });
    }
  }
};
_defineProperty(ColumnRename, "$name", "ColumnRename");
_defineProperty(ColumnRename, "configurable", {
  keyMap: {
    F2: "startEdit"
  }
});
ColumnRename._$name = "ColumnRename";
GridFeatureManager.registerFeature(ColumnRename, false);
var ColumnReorder = class extends Delayable(InstancePlugin) {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ignoreSelectors", [".b-grid-header-resize-handle", ".b-field"]);
  }
  doDestroy() {
    var _this$dragHelper, _this$dragHelper2;
    (_this$dragHelper = this.dragHelper) === null || _this$dragHelper === void 0 ? void 0 : _this$dragHelper.scrollManager.destroy();
    (_this$dragHelper2 = this.dragHelper) === null || _this$dragHelper2 === void 0 ? void 0 : _this$dragHelper2.destroy();
    super.doDestroy();
  }
  get grid() {
    return this.client;
  }
  init() {
    const me = this, {
      grid
    } = me, gridEl = grid.element, containers = DomHelper.children(gridEl, ".b-grid-headers");
    containers.push(...DomHelper.children(gridEl, ".b-grid-header-children"));
    if (me.dragHelper) {
      me.dragHelper.containers = containers;
    } else {
      me.dragHelper = new DragHelper({
        name: "columnReorder",
        mode: "container",
        dragThreshold: 10,
        targetSelector: ".b-grid-header",
        floatRootOwner: grid,
        rtlSource: grid,
        outerElement: grid.headerContainer,
        monitoringConfig: {
          scrollables: [{
            element: ".b-grid-headers"
          }]
        },
        scrollManager: ScrollManager.new({
          direction: "horizontal",
          element: grid.headerContainer
        }),
        containers,
        isElementDraggable(element) {
          const abort = Boolean(element.closest(me.ignoreSelectors.join(",")));
          if (abort || me.disabled) {
            return false;
          }
          const columnEl = element.closest(this.targetSelector), column = columnEl && grid.columns.getById(columnEl.dataset.columnId), isLast = (column === null || column === void 0 ? void 0 : column.childLevel) === 0 && grid.subGrids[column.region].columns.count === 1;
          return Boolean(column) && column.draggable !== false && !isLast;
        },
        ignoreSelector: ".b-filter-icon,.b-grid-header-resize-handle",
        internalListeners: {
          beforeDragStart: me.onBeforeDragStart,
          dragstart: me.onDragStart,
          drag: me.onDrag,
          drop: me.onDrop,
          thisObj: me
        }
      });
      me.relayEvents(me.dragHelper, ["dragStart", "drag", "drop", "abort"], "gridHeader");
    }
  }
  static get pluginConfig() {
    return {
      after: ["onPaint", "renderContents"]
    };
  }
  onDrag({
    context,
    event
  }) {
    const me = this, targetHeader = Widget.fromElement(event.target, "gridheader");
    if (targetHeader !== null && targetHeader !== void 0 && targetHeader.subGrid.sealedColumns) {
      context.valid = false;
      return;
    }
    if (!me.grid.features.columnDragToolbar) {
      context.valid = Boolean(event.target.closest(".b-grid-headers"));
    }
  }
  onBeforeDragStart({
    context,
    event
  }) {
    const {
      element
    } = context, column = context.column = this.client.columns.getById(element.dataset.columnId);
    return this.client.trigger("beforeColumnDragStart", {
      column,
      event
    });
  }
  onDragStart({
    context,
    event
  }) {
    const me = this, {
      grid
    } = me, {
      column
    } = context;
    if (!grid.features.columnDragToolbar) {
      const headerContainerBox = grid.element.querySelector(".b-grid-header-container").getBoundingClientRect();
      me.dragHelper.minY = headerContainerBox.top;
      me.dragHelper.maxY = headerContainerBox.bottom;
    }
    grid.headerContainer.classList.add("b-dragging-header");
    context.dragProxy.style.fontSize = DomHelper.getStyleValue(context.element, "fontSize");
    grid.trigger("columnDragStart", {
      column,
      event
    });
  }
  onDrop({
    context,
    event
  }) {
    if (!context.valid) {
      return this.onInvalidDrop({
        context
      });
    }
    const me = this, {
      grid
    } = me, element = context.dragging, onHeader = context.target.closest(".b-grid-header"), droppedInRegion = context.draggedTo.dataset.region, onColumn = onHeader ? grid.columns.get(onHeader.dataset.column) : grid.subGrids[droppedInRegion].columns.last, toRegion = droppedInRegion || onColumn.region, sibling = context.insertBefore, column = grid.columns.getById(element.dataset.columnId), oldParent = column.parent, insertBefore = sibling ? grid.columns.getById(sibling.dataset.columnId) : grid.subGrids[toRegion].columns.last.nextSibling;
    let newParent;
    if (insertBefore) {
      newParent = insertBefore.parent;
    } else {
      const groupNode = onHeader === null || onHeader === void 0 ? void 0 : onHeader.parentElement.closest(".b-grid-header");
      if (groupNode) {
        newParent = grid.columns.getById(groupNode.dataset.columnId);
      } else {
        newParent = grid.columns.rootNode;
      }
    }
    grid.headerContainer.classList.remove("b-dragging-header");
    element.remove();
    let vetoed = toRegion === column.region && oldParent === newParent && (onColumn === column.previousSibling || insertBefore === column.nextSibling);
    vetoed = vetoed || grid.trigger("beforeColumnDropFinalize", {
      column,
      newParent,
      insertBefore,
      event
    }) === false;
    if (!vetoed) {
      vetoed = !newParent.insertChild(column, insertBefore);
    }
    context.valid = !vetoed;
    if (!vetoed) {
      column.region = toRegion;
      if (oldParent.children.length === 0) {
        oldParent.parent.removeChild(oldParent);
      }
    }
    grid.trigger("columnDrop", {
      column,
      newParent,
      insertBefore,
      valid: context.valid,
      event
    });
  }
  onInvalidDrop() {
    this.grid.headerContainer.classList.remove("b-dragging-header");
  }
  renderContents() {
    this.init();
  }
  onPaint() {
    this.init();
  }
};
_defineProperty(ColumnReorder, "$name", "ColumnReorder");
ColumnReorder.featureClass = "b-column-reorder";
ColumnReorder._$name = "ColumnReorder";
GridFeatureManager.registerFeature(ColumnReorder, true);
var ColumnResize = class extends InstancePlugin {
  static get $name() {
    return "ColumnResize";
  }
  static get configurable() {
    return {
      liveResize: "auto"
    };
  }
  construct(grid, config) {
    const me = this;
    me.grid = grid;
    super.construct(grid, config);
    me.resizer = new ResizeHelper({
      name: "columnResize",
      targetSelector: ".b-grid-header",
      handleSelector: ".b-grid-header-resize-handle",
      outerElement: grid.element,
      rtlSource: grid,
      internalListeners: {
        beforeresizestart: me.onBeforeResizeStart,
        resizestart: me.onResizeStart,
        resizing: me.onResizing,
        resize: me.onResize,
        cancel: me.onCancel,
        thisObj: me
      }
    });
  }
  doDestroy() {
    var _this$resizer;
    (_this$resizer = this.resizer) === null || _this$resizer === void 0 ? void 0 : _this$resizer.destroy();
    super.doDestroy();
  }
  changeLiveResize(liveResize) {
    if (liveResize === "auto") {
      return !BrowserHelper.isMobileSafari;
    }
    return liveResize;
  }
  onBeforeResizeStart() {
    return !this.disabled;
  }
  onResizeStart({
    context
  }) {
    const {
      grid,
      resizer
    } = this, column = context.column = grid.columns.getById(context.element.dataset.columnId);
    resizer.minWidth = column.minWidth;
    grid.element.classList.add("b-column-resizing");
  }
  onResizing({
    context
  }) {
    if (context.valid && this.liveResize) {
      this.grid.resizingColumns = true;
      context.column.width = context.newWidth;
    }
  }
  onResize({
    context
  }) {
    const {
      grid
    } = this, {
      column
    } = context;
    grid.element.classList.remove("b-column-resizing");
    if (context.valid) {
      if (this.liveResize) {
        grid.resizingColumns = false;
        grid.afterColumnsResized(column);
      } else {
        column.width = context.newWidth;
      }
    }
  }
  onCancel({
    context
  }) {
    const {
      grid
    } = this;
    grid.element.classList.remove("b-column-resizing");
    context.column.width = context.elementWidth;
    grid.resizingColumns = false;
  }
};
ColumnResize._$name = "ColumnResize";
GridFeatureManager.registerFeature(ColumnResize, true);
var FillHandle = class extends InstancePlugin.mixin(Delayable) {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "delayable", {
      handleSelection: "raf"
    });
  }
  afterConstruct() {
    super.afterConstruct();
    if (!this.client.selectionMode.cell) {
      this.disabled = true;
    }
    this._fillListeners = {};
  }
  onContentChange() {
    this.handleSelection();
  }
  afterColumnsChange() {
    this.handleSelection();
  }
  fixElementHeights() {
    this.handleSelection();
  }
  getCellDataFromEvent(event, includeSingleAxisMatch) {
    if (includeSingleAxisMatch) {
      includeSingleAxisMatch = !event.target.classList.contains("b-fill-handle");
    }
    return this.overridden.getCellDataFromEvent(event, includeSingleAxisMatch);
  }
  findPatternsIn2dRange(range, horizontal, negative) {
    const values = {};
    for (const cell of range) {
      const id = horizontal ? cell.id : cell.columnId;
      let value = cell.record[cell.column.field];
      if (value && typeof value === "string" && !isNaN(value)) {
        value = parseFloat(value);
      }
      if (!values[id]) {
        values[id] = [];
      }
      values[id].push(value);
    }
    for (const rowOrCol in values) {
      values[rowOrCol].pattern = this.findPatternsIn1dRange(values[rowOrCol], negative);
    }
    return values;
  }
  findPatternsIn1dRange(range, negative) {
    const lastValue = range[negative ? 0 : range.length - 1], pattern = {
      next: () => lastValue,
      lastValue
    };
    if (range.every((val) => typeof val === "number") || range.every((val) => val instanceof Date)) {
      const diffs = range.map((val, ix) => val - range[ix - 1]);
      diffs.shift();
      if (new Set(diffs).size === 1) {
        pattern.increaseBy = diffs[0] * (negative ? -1 : 1);
        pattern.next = () => {
          if (pattern.lastValue instanceof Date) {
            pattern.lastValue = new Date(pattern.lastValue.getTime() + pattern.increaseBy);
          } else {
            pattern.lastValue += pattern.increaseBy;
          }
          return pattern.lastValue;
        };
      }
    } else if (range.length > 1) {
      pattern.stringPattern = [...range];
      pattern.next = () => {
        if (pattern.currentIndex === void 0) {
          pattern.currentIndex = 0;
        } else {
          pattern.currentIndex += 1;
          if (pattern.currentIndex >= pattern.stringPattern.length) {
            pattern.currentIndex = 0;
          }
        }
        return pattern.stringPattern[pattern.currentIndex];
      };
    }
    return pattern;
  }
  afterSelectionChange() {
    const me = this;
    if (GlobalEvents$1.isMouseDown()) {
      me.client.delayUntilMouseUp(() => me.handleSelection(true));
      me.removeElements();
    } else {
      me.handleSelection(true);
    }
  }
  handleSelection() {
    if (!this._isExtending) {
      const range = this.rangeSelection;
      if (range) {
        this.drawFillHandleAndBorder(range[0], range[range.length - 1]);
      } else {
        this.removeElements();
      }
    }
  }
  onMouseDown(event) {
    this._fillListeners.mouseMoveOrUp = EventHelper.on({
      element: globalThis,
      mouseover: "onMouseOver",
      mouseup: "onMouseUp",
      thisObj: this
    });
    event.stopImmediatePropagation();
    event.handled = true;
  }
  onMouseUp() {
    const me = this, {
      client,
      currentRange,
      _isCropping
    } = me, range = me.rangeSelection, selectionChange = range && currentRange && client.internalSelectRange(currentRange.from, currentRange.to), selectedCells = (selectionChange === null || selectionChange === void 0 ? void 0 : selectionChange.selectedCells) || [], extensionCells = _isCropping ? me.croppingCells : selectedCells.filter((cell) => !range.some((sel) => sel.equals(cell, true)));
    delete me._isCropping;
    if (me._isExtending) {
      client.disableScrollingCloseToEdges(client.items);
      delete me._isExtending;
    }
    if (!(extensionCells !== null && extensionCells !== void 0 && extensionCells.length)) {
      me.handleSelection();
      return;
    }
    client.suspendRefresh();
    if (_isCropping) {
      extensionCells.forEach((cell) => cell.record.set(cell.column.field, null, false, false, false, true));
    } else {
      const [firstCell] = extensionCells, horizontal = range.some((sel) => sel.record === firstCell.record), negative = horizontal ? firstCell.columnIndex < range[0].columnIndex : firstCell.rowIndex < range[0].rowIndex, patterns = me.findPatternsIn2dRange(range, horizontal, negative), changeMap = /* @__PURE__ */ new Map();
      if (negative) {
        extensionCells.reverse();
      }
      for (const cell of extensionCells) {
        const {
          column,
          record
        } = cell;
        if (column.canFillValue({
          range,
          record,
          cell
        })) {
          var _me$calculateFillValu, _column$calculateFill;
          let value = (_me$calculateFillValu = me.calculateFillValue) === null || _me$calculateFillValu === void 0 ? void 0 : _me$calculateFillValu.call(me, {
            range,
            column,
            record,
            cell
          }), changed = changeMap.get(record);
          if (!changed) {
            changed = {};
            changeMap.set(record, changed);
          }
          if (value === void 0) {
            const pattern = patterns[horizontal ? cell.id : cell.columnId].pattern;
            value = pattern.next();
          }
          changed[column.field] = ((_column$calculateFill = column.calculateFillValue) === null || _column$calculateFill === void 0 ? void 0 : _column$calculateFill.call(column, {
            value,
            record,
            range
          })) || value;
        }
      }
      for (const [record, changes] of changeMap) {
        record.set(changes, null, null, null, null, true);
      }
    }
    client.resumeRefresh(true);
    client.performSelection(selectionChange);
    delete me.currentRange;
    me.handleSelection();
  }
  onMouseOver(event) {
    var _cellSelector, _cellSelector$_column;
    const me = this, {
      client,
      rangeSelection
    } = me, first = rangeSelection[0], last = rangeSelection[rangeSelection.length - 1], cellData = client.getCellDataFromEvent(event, true);
    let cellSelector = cellData && client.normalizeCellContext(cellData.cellSelector);
    if (((_cellSelector = cellSelector) === null || _cellSelector === void 0 ? void 0 : (_cellSelector$_column = _cellSelector._column) === null || _cellSelector$_column === void 0 ? void 0 : _cellSelector$_column.region) === first._column.region) {
      const equalOrSmaller = rangeSelection.some((cs) => cs.equals(cellSelector, true));
      let negative;
      if (!me._isExtending) {
        client.enableScrollingCloseToEdges(client.items);
      }
      if (equalOrSmaller) {
        me._isCropping = me.allowCropping && (cellSelector.rowIndex < last.rowIndex || cellSelector.columnIndex < last.columnIndex);
      } else {
        if (cellSelector.rowIndex >= first.rowIndex && cellSelector.rowIndex <= last.rowIndex) {
          negative = first.columnIndex > cellSelector.columnIndex;
          cellSelector = new Location({
            grid: client,
            record: negative ? first.record : last.record,
            column: cellSelector.column
          });
        } else {
          negative = first.rowIndex > cellSelector.rowIndex;
          cellSelector = new Location({
            grid: client,
            record: cellSelector.record,
            column: negative ? first.column : last.column
          });
        }
      }
      const from = negative ? cellSelector : first, to = negative || equalOrSmaller && !me._isCropping ? last : cellSelector;
      me.currentRange = {
        from,
        to
      };
      me._isExtending = true;
      me.drawFillHandleAndBorder(from, to, true);
    }
  }
  drawFillHandleAndBorder(from, to, keepListeners = false) {
    var _me$rangeSelection;
    const me = this, {
      client,
      currentRange,
      _fillListeners
    } = me, regionEl = client.subGrids[from.column.region].element, {
      x
    } = Rectangle.from(from.cell || from.column.element, regionEl), {
      right
    } = Rectangle.from(to.cell || to.column.element, regionEl), {
      y
    } = client.getRecordCoords(from.record, true), bottom = client.getRecordCoords(to.record, true).bottom - 1;
    let {
      borderElement,
      handleElement
    } = me;
    me.removeElements(keepListeners);
    if (!borderElement) {
      me.borderElement = borderElement = DomHelper.createElement({
        className: "b-fill-selection-border"
      });
      me.handleElement = handleElement = DomHelper.createElement({
        className: "b-fill-handle"
      });
    }
    DomHelper.setRect(borderElement, {
      y,
      x,
      width: right - x,
      height: bottom - y
    });
    regionEl.appendChild(borderElement);
    DomHelper.setTopLeft(handleElement, bottom, right >= regionEl.scrollWidth ? x : right);
    regionEl.appendChild(handleElement);
    me.toggleCroppingCls(false);
    delete me.croppingCells;
    if (me._isCropping && (_me$rangeSelection = me.rangeSelection) !== null && _me$rangeSelection !== void 0 && _me$rangeSelection.length) {
      const newCells = client.getRange(currentRange.from, currentRange.to);
      me.croppingCells = me.rangeSelection.filter((sel) => !newCells.some((cell) => cell.equals(sel, true)));
      me.toggleCroppingCls();
    }
    if (!_fillListeners.handleClick) {
      _fillListeners.handleClick = EventHelper.on({
        element: globalThis,
        delegate: ".b-fill-handle",
        mousedown: "onMouseDown",
        thisObj: me
      });
    }
    me.hasFillElements = true;
  }
  toggleCroppingCls(add = true) {
    var _this$croppingCells;
    (_this$croppingCells = this.croppingCells) === null || _this$croppingCells === void 0 ? void 0 : _this$croppingCells.forEach((sel) => {
      var _this$client$getCell;
      return (_this$client$getCell = this.client.getCell(sel)) === null || _this$client$getCell === void 0 ? void 0 : _this$client$getCell.classList.toggle("b-indicate-crop", add);
    });
  }
  removeElements(keepListeners = false) {
    var _me$handleElement, _me$borderElement;
    const me = this;
    (_me$handleElement = me.handleElement) === null || _me$handleElement === void 0 ? void 0 : _me$handleElement.remove();
    (_me$borderElement = me.borderElement) === null || _me$borderElement === void 0 ? void 0 : _me$borderElement.remove();
    if (!keepListeners) {
      me.removeListeners();
    }
    me.hasFillElements = false;
  }
  removeListeners() {
    const me = this;
    for (const listener in me._fillListeners) {
      me._fillListeners[listener]();
    }
    me._fillListeners = {};
  }
  get rangeSelection() {
    var _client$_shiftSelectR;
    const {
      client
    } = this, {
      selectedCells
    } = client, range = (_client$_shiftSelectR = client._shiftSelectRange) !== null && _client$_shiftSelectR !== void 0 ? _client$_shiftSelectR : selectedCells.length === 1 && selectedCells;
    if (!client.selectedRecords.length && range !== null && range !== void 0 && range.length && range.length === selectedCells.length && range.every((c1) => selectedCells.some((c2) => c1.equals(c2, true)) && c1._column.parent && c1._column.region === range[0]._column.region && client.store.isAvailable(c1.id))) {
      return range;
    }
    return null;
  }
};
_defineProperty(FillHandle, "$name", "FillHandle");
_defineProperty(FillHandle, "configurable", {
  calculateFillValue: null,
  allowCropping: false
});
_defineProperty(FillHandle, "pluginConfig", {
  chain: ["afterSelectionChange", "onContentChange", "afterColumnsChange", "fixElementHeights"],
  override: ["getCellDataFromEvent"]
});
FillHandle._$name = "FillHandle";
GridFeatureManager.registerFeature(FillHandle);
var GridFieldFilterPicker = class extends FieldFilterPicker {
  static get $name() {
    return "GridFieldFilterPicker";
  }
  static get type() {
    return "gridfieldfilterpicker";
  }
  afterConstruct() {
    var _me$fields;
    const me = this;
    if (!me.grid) {
      throw new Error(`${me.constructor.$name} requires 'grid' to be configured.`);
    }
    me.fields = (_me$fields = me.fields) !== null && _me$fields !== void 0 ? _me$fields : {};
    super.afterConstruct();
  }
  updateGrid(newGrid) {
    var _newGrid$store;
    if (!((_newGrid$store = newGrid.store) !== null && _newGrid$store !== void 0 && _newGrid$store.modelClass)) {
      throw new Error(`Grid does not have a store with a modelClass defined.`);
    }
    if (!newGrid.columns) {
      throw new Error(`Grid does not have a column store.`);
    }
  }
  static getModelClassFields(modelClass) {
    const ownFieldNames = new Set(modelClass.fields.map(({
      name
    }) => name));
    return (modelClass === null || modelClass === void 0 ? void 0 : modelClass.allFields.filter((field) => !field.internal && (SUPPORTED_FIELD_DATA_TYPES.includes(field.type) || isSupportedDurationField(field)) && (field.definedBy !== Model || ownFieldNames.has(field.name)))) || [];
  }
  static getColumnFields(columnStore, modelClass, allowedFieldNames) {
    var _columnStore$records$;
    const modelFields = ArrayHelper.keyBy(GridFieldFilterPicker.getModelClassFields(modelClass), "name"), allowedNameSet = allowedFieldNames && new Set(allowedFieldNames);
    return Object.fromEntries((_columnStore$records$ = columnStore === null || columnStore === void 0 ? void 0 : columnStore.records.filter(({
      field
    }) => field && modelFields[field] && (!allowedNameSet || allowedNameSet.has(field))).map(({
      field,
      text
    }) => [field, {
      title: text || field,
      type: isSupportedDurationField(modelFields[field]) ? "duration" : modelFields[field].type
    }])) !== null && _columnStore$records$ !== void 0 ? _columnStore$records$ : []);
  }
  changeFields(newFields) {
    var _this$grid$store;
    let localFields = newFields;
    if (Array.isArray(newFields)) {
      VersionHelper.deprecate("Core", "6.0.0", "FieldOption[] deprecated, use Object<String, FieldOption[]> keyed by field name instead");
      localFields = ArrayHelper.keyBy(localFields, "name");
    }
    return ObjectHelper.merge({}, GridFieldFilterPicker.getColumnFields(this.grid.columns, (_this$grid$store = this.grid.store) === null || _this$grid$store === void 0 ? void 0 : _this$grid$store.modelClass, this.allowedFieldNames), localFields);
  }
};
_defineProperty(GridFieldFilterPicker, "configurable", {
  grid: null,
  allowedFieldNames: null
});
GridFieldFilterPicker.initClass();
GridFieldFilterPicker._$name = "GridFieldFilterPicker";
var GridFieldFilterPickerGroup = class extends FieldFilterPickerGroup {
  static get $name() {
    return "GridFieldFilterPickerGroup";
  }
  static get type() {
    return "gridfieldfilterpickergroup";
  }
  validateConfig() {
    if (!this.grid) {
      throw new Error(`${this.constructor.$name} requires the 'grid' config property.`);
    }
  }
  getFilterPickerConfig(filter2) {
    const {
      grid,
      allowedFieldNames
    } = this;
    return _objectSpread2(_objectSpread2({}, super.getFilterPickerConfig(filter2)), {}, {
      grid,
      allowedFieldNames
    });
  }
  updateGrid(newGrid) {
    this.store = this.grid.store;
  }
  canManage(filter2) {
    const me = this;
    return super.canManage(filter2) && (!me.allowedFieldNames || me.allowedFieldNames.includes(filter2.property));
  }
};
_defineProperty(GridFieldFilterPickerGroup, "configurable", {
  grid: null,
  allowedFieldNames: null
});
_defineProperty(GridFieldFilterPickerGroup, "childPickerType", "gridfieldfilterpicker");
GridFieldFilterPickerGroup.initClass();
GridFieldFilterPickerGroup._$name = "GridFieldFilterPickerGroup";
var fieldTypeMap = {
  date: "date",
  int: "number",
  integer: "number",
  number: "number",
  string: "text",
  duration: "duration"
};
var Filter = class extends InstancePlugin {
  static get $name() {
    return "Filter";
  }
  static get configurable() {
    return {
      prioritizeColumns: false,
      keyMap: {
        f: "showFilterEditorByKey"
      },
      isMulti: false
    };
  }
  construct(grid, config) {
    if (grid.features.filterBar) {
      throw new Error("Grid.feature.Filter feature may not be used together with Grid.feature.FilterBar. These features are mutually exclusive.");
    }
    const me = this;
    me.grid = grid;
    me.closeFilterEditor = me.closeFilterEditor.bind(me);
    super.construct(grid, config);
    me.bindStore(grid.store);
    if (config && typeof config === "object") {
      const clone = ObjectHelper.clone(config);
      delete clone.prioritizeColumns;
      delete clone.isMulti;
      delete clone.dateFormat;
      if (!ObjectHelper.isEmpty(clone)) {
        grid.store.filter(clone, null, grid.isConfiguring);
      }
    }
  }
  doDestroy() {
    var _this$filterTip, _this$filterEditorPop;
    (_this$filterTip = this.filterTip) === null || _this$filterTip === void 0 ? void 0 : _this$filterTip.destroy();
    (_this$filterEditorPop = this.filterEditorPopup) === null || _this$filterEditorPop === void 0 ? void 0 : _this$filterEditorPop.destroy();
    super.doDestroy();
  }
  get store() {
    return this.grid.store;
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      beforeFilter: "onStoreBeforeFilter",
      filter: "onStoreFilter",
      thisObj: this
    });
  }
  static get pluginConfig() {
    return {
      chain: ["renderHeader", "populateCellMenu", "populateHeaderMenu", "onElementClick", "bindStore"]
    };
  }
  refreshHeaders(reRenderRows) {
    const me = this, grid = me.grid, element = grid.headerContainer;
    if (element) {
      DomHelper.children(element, ".b-filter-icon.b-latest").forEach((iconElement) => iconElement.classList.remove("b-latest"));
      if (!me.filterTip) {
        me.filterTip = new Tooltip({
          forElement: element,
          forSelector: ".b-filter-icon",
          getHtml({
            activeTarget
          }) {
            return activeTarget.dataset.filterText;
          }
        });
      }
      if (!grid.store.isFiltered) {
        me.filterTip.hide();
      }
      grid.columns.visibleColumns.forEach((column) => {
        if (column.filterable !== false) {
          const columnFilters = me.store.filters.allValues.filter(({
            property,
            disabled,
            internal
          }) => property === column.field && !disabled && !internal), isColumnFiltered = columnFilters.length > 0, headerEl = column.element;
          if (headerEl) {
            const textEl = column.textWrapper;
            let filterIconEl = textEl === null || textEl === void 0 ? void 0 : textEl.querySelector(".b-filter-icon"), filterText;
            if (isColumnFiltered) {
              const bullet = "&#x2022 ";
              filterText = `${me.L("L{filter}")}: ` + (columnFilters.length > 1 ? "<br/><br/>" : "") + columnFilters.map((columnFilter) => {
                var _columnFilter$value, _me$store, _me$store$modelRelati;
                let value = (_columnFilter$value = columnFilter.value) !== null && _columnFilter$value !== void 0 ? _columnFilter$value : "";
                const isArray2 = Array.isArray(value), relation = (_me$store = me.store) === null || _me$store === void 0 ? void 0 : (_me$store$modelRelati = _me$store.modelRelations) === null || _me$store$modelRelati === void 0 ? void 0 : _me$store$modelRelati.find(({
                  foreignKey
                }) => foreignKey === columnFilter.property);
                if (columnFilter.displayValue) {
                  value = columnFilter.displayValue;
                } else {
                  if (me.isMulti && relation) {
                    var _me$isMulti$fields;
                    const {
                      relatedDisplayField
                    } = (_me$isMulti$fields = me.isMulti.fields) === null || _me$isMulti$fields === void 0 ? void 0 : _me$isMulti$fields[columnFilter.property];
                    if (relatedDisplayField) {
                      const getDisplayValue = (foreignId) => {
                        var _relation$foreignStor;
                        return (_relation$foreignStor = relation.foreignStore.getById(foreignId)) === null || _relation$foreignStor === void 0 ? void 0 : _relation$foreignStor[relatedDisplayField];
                      };
                      if (isArray2) {
                        value = value[relatedDisplayField].sort((a, b) => (a !== null && a !== void 0 ? a : "").localeCompare(b !== null && b !== void 0 ? b : ""));
                      } else {
                        value = getDisplayValue(value);
                      }
                    }
                  } else if (column.formatValue && value) {
                    value = isArray2 ? value.map((val) => column.formatValue(val)) : column.formatValue(value);
                  }
                  if (isArray2) {
                    value = `[ ${value.join(", ")} ]`;
                  }
                }
                return (columnFilters.length > 1 ? bullet : "") + (typeof columnFilter === "string" ? columnFilter : `${columnFilter.operator} ${value}`);
              }).join("<br/><br/>");
            } else {
              filterText = me.L("L{applyFilter}");
            }
            if (!filterIconEl) {
              filterIconEl = DomHelper.createElement({
                parent: textEl,
                tag: "div",
                className: "b-filter-icon",
                dataset: {
                  filterText
                }
              });
            } else {
              filterIconEl.dataset.filterText = filterText;
            }
            if (column.field === me.store.latestFilterField)
              filterIconEl.classList.add("b-latest");
            headerEl.classList.add("b-filterable");
            headerEl.classList.toggle("b-filter", isColumnFiltered);
          }
          column.meta.isFiltered = isColumnFiltered;
        }
      });
      if (reRenderRows) {
        grid.refreshRows();
      }
    }
  }
  applyFilter(column, config) {
    const {
      store
    } = this, {
      filterFn
    } = column.filterable;
    column.$filter = store.addFilter(_objectSpread2(_objectSpread2(_objectSpread2({}, column.filterable), config), {}, {
      property: column.field,
      [filterFn ? "filterBy" : "_"]: function(record) {
        return filterFn({
          value: this.value,
          record,
          operator: this.operator,
          property: this.property,
          column
        });
      }
    }), true);
    store.filter();
  }
  removeFilter(column) {
    if (this.isMulti) {
      for (const filter2 of this.getCurrentMultiFilters(column)) {
        this.store.removeFilter(filter2);
      }
    } else {
      this.store.removeFilter(column.field);
    }
  }
  disableFilter(column) {
    for (const filter2 of this.getCurrentMultiFilters(column)) {
      filter2.disabled = true;
      this.store.filter(filter2);
    }
    this.store.filter();
  }
  getCurrentMultiFilters(column) {
    return this.store.filters.values.filter((filter2) => filter2.property === column.field);
  }
  getPopupDateItems(column, fieldType, filter2, initialValue, store, changeCallback, closeCallback, filterField) {
    const me = this, onClose = changeCallback;
    function onClear() {
      me.removeFilter(column);
    }
    function onKeydown({
      event
    }) {
      if (event.key === "Enter") {
        changeCallback();
      }
    }
    function onChange({
      source,
      value
    }) {
      if (value == null) {
        onClear();
      } else {
        me.clearSiblingsFields(source);
        me.applyFilter(column, {
          operator: source.operator,
          value,
          displayValue: source._value,
          type: "date"
        });
      }
    }
    return [ObjectHelper.assign({
      type: "date",
      ref: "on",
      placeholder: "L{on}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
      value: (filter2 === null || filter2 === void 0 ? void 0 : filter2.operator) === "sameDay" ? filter2.value : initialValue,
      operator: "sameDay",
      onKeydown,
      onChange,
      onClose,
      onClear
    }, filterField), ObjectHelper.assign({
      type: "date",
      ref: "before",
      placeholder: "L{before}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-before"></i>',
      value: (filter2 === null || filter2 === void 0 ? void 0 : filter2.operator) === "<" ? filter2.value : null,
      operator: "<",
      onKeydown,
      onChange,
      onClose,
      onClear
    }, filterField), ObjectHelper.assign({
      type: "date",
      ref: "after",
      cls: "b-last-row",
      placeholder: "L{after}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-after"></i>',
      value: (filter2 === null || filter2 === void 0 ? void 0 : filter2.operator) === ">" ? filter2.value : null,
      operator: ">",
      onKeydown,
      onChange,
      onClose,
      onClear
    }, filterField)];
  }
  getPopupNumberItems(column, fieldType, filter2, initialValue, store, changeCallback, closeCallback, filterField) {
    const me = this, onEsc = changeCallback;
    function onClear() {
      me.removeFilter(column);
    }
    function onKeydown({
      event
    }) {
      if (event.key === "Enter") {
        changeCallback();
      }
    }
    function onChange({
      source,
      value
    }) {
      if (value == null) {
        onClear();
      } else {
        me.clearSiblingsFields(source);
        me.applyFilter(column, {
          operator: source.operator,
          value
        });
      }
    }
    return [ObjectHelper.assign({
      type: "number",
      placeholder: "L{Filter.equals}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
      value: (filter2 === null || filter2 === void 0 ? void 0 : filter2.operator) === "=" ? filter2.value : initialValue,
      operator: "=",
      onKeydown,
      onChange,
      onEsc,
      onClear
    }, filterField), ObjectHelper.assign({
      type: "number",
      placeholder: "L{lessThan}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-less"></i>',
      value: (filter2 === null || filter2 === void 0 ? void 0 : filter2.operator) === "<" ? filter2.value : null,
      operator: "<",
      onKeydown,
      onChange,
      onEsc,
      onClear
    }, filterField), ObjectHelper.assign({
      type: "number",
      cls: "b-last-row",
      placeholder: "L{moreThan}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-more"></i>',
      value: (filter2 === null || filter2 === void 0 ? void 0 : filter2.operator) === ">" ? filter2.value : null,
      operator: ">",
      onKeydown,
      onChange,
      onEsc,
      onClear
    }, filterField)];
  }
  clearSiblingsFields(sourceField) {
    var _this$filterEditorPop2;
    (_this$filterEditorPop2 = this.filterEditorPopup) === null || _this$filterEditorPop2 === void 0 ? void 0 : _this$filterEditorPop2.items.forEach((field) => {
      field !== sourceField && (field === null || field === void 0 ? void 0 : field.clear());
    });
  }
  getPopupDurationItems(column, fieldType, filter2, initialValue, store, changeCallback, closeCallback, filterField) {
    const me = this, onEsc = changeCallback, onClear = () => me.removeFilter(column);
    me.removeFilter(column);
    function onChange({
      source,
      value
    }) {
      me.clearSiblingsFields(source);
      me.applyFilter(column, {
        operator: source.operator,
        value
      });
    }
    return [ObjectHelper.assign({
      type: "duration",
      placeholder: "L{Filter.equals}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
      value: (filter2 === null || filter2 === void 0 ? void 0 : filter2.operator) === "=" ? filter2.value : initialValue,
      operator: "=",
      onChange,
      onEsc,
      onClear
    }, filterField), ObjectHelper.assign({
      type: "duration",
      placeholder: "L{lessThan}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-less"></i>',
      value: (filter2 === null || filter2 === void 0 ? void 0 : filter2.operator) === "<" ? filter2.value : null,
      operator: "<",
      onChange,
      onEsc,
      onClear
    }, filterField), ObjectHelper.assign({
      type: "duration",
      cls: "b-last-row",
      placeholder: "L{moreThan}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-more"></i>',
      value: (filter2 === null || filter2 === void 0 ? void 0 : filter2.operator) === ">" ? filter2.value : null,
      operator: ">",
      onChange,
      onEsc,
      onClear
    }, filterField)];
  }
  getPopupStringItems(column, fieldType, filter2, initialValue, store, changeCallback, closeCallback, filterField) {
    const me = this;
    return [ObjectHelper.assign({
      type: fieldType,
      cls: "b-last-row",
      placeholder: "L{filter}",
      localeClass: me,
      clearable: true,
      label: '<i class="b-fw-icon b-icon-filter-equal"></i>',
      value: filter2 ? filter2.value || filter2 : initialValue,
      operator: "*",
      onChange({
        source,
        value
      }) {
        if (value === "") {
          closeCallback();
        } else {
          me.applyFilter(column, {
            operator: source.operator,
            value,
            displayValue: source.displayField && source.records ? source.records.map((rec) => rec[source.displayField]).join(", ") : void 0
          });
          if (!source.multiSelect) {
            changeCallback();
          }
        }
      },
      onClose: changeCallback,
      onClear: closeCallback
    }, filterField)];
  }
  getPopupItems(column, fieldType, filter2, initialValue, store, changeCallback, closeCallback, filterField) {
    const me = this;
    if (me.isMulti) {
      return me.getMultiFilterPopupItems(...arguments);
    }
    switch (fieldType) {
      case "date":
        return me.getPopupDateItems(...arguments);
      case "number":
        return me.getPopupNumberItems(...arguments);
      case "duration":
        return me.getPopupDurationItems(...arguments);
      default:
        return me.getPopupStringItems(...arguments);
    }
  }
  getMultiFilterPopupItems(column) {
    var _grid$store;
    const {
      grid,
      isMulti
    } = this, existingFilter = (_grid$store = grid.store) === null || _grid$store === void 0 ? void 0 : _grid$store.filters.find((filter2) => filter2.property === column.field);
    return [_objectSpread2(_objectSpread2({}, typeof isMulti === "object" ? isMulti : void 0), {}, {
      type: "gridfieldfilterpickergroup",
      ref: "pickerGroup",
      limitToProperty: column.field,
      grid,
      filters: existingFilter ? [] : [{
        property: column.field
      }],
      propertyFieldCls: "b-transparent property-field",
      operatorFieldCls: "b-transparent operator-field",
      valueFieldCls: "b-transparent value-field",
      width: "400px"
    })];
  }
  showFilterEditor(column, value) {
    column = this.grid.columns.getById(column);
    const me = this, {
      store,
      isMulti
    } = me, headerEl = column.element, filter2 = store.filters.getBy("property", column.field), fieldType = me.getFilterType(column);
    if (column.filterable === false) {
      return;
    }
    me.closeFilterEditor();
    const items2 = me.getPopupItems(
      column,
      fieldType,
      filter2 !== null && filter2 !== void 0 && filter2.internal ? null : filter2,
      value,
      store,
      me.closeFilterEditor,
      () => {
        me.removeFilter(column);
        me.closeFilterEditor();
      },
      column.filterable.filterField,
      isMulti
    );
    items2.forEach((item) => item.placeholder = item.placeholder ? this.L(item.placeholder) : item.placeholder);
    me.filterEditorPopup = WidgetHelper.openPopup(headerEl, {
      owner: me.grid,
      cls: "b-filter-popup",
      scrollAction: "realign",
      layout: {
        type: "vbox",
        align: "stretch"
      },
      items: items2
    });
  }
  closeFilterEditor() {
    var _this$filterEditorPop3;
    (_this$filterEditorPop3 = this.filterEditorPopup) === null || _this$filterEditorPop3 === void 0 ? void 0 : _this$filterEditorPop3.setTimeout(this.filterEditorPopup.destroy);
    this.filterEditorPopup = null;
  }
  getFilterType(column) {
    const fieldName = column.field, field = this.client.store.modelClass.getFieldDefinition(fieldName), type = column.filterType;
    return type ? fieldTypeMap[type] : fieldTypeMap[column.type] || field && fieldTypeMap[field.type] || "text";
  }
  populateCellMenuWithDateItems({
    column,
    record,
    items: items2
  }) {
    const property = column.field, type = this.getFilterType(column);
    if (type === "date") {
      const me = this, value = record[property], filter2 = (operator) => {
        me.applyFilter(column, {
          operator,
          value,
          displayValue: column.formatValue ? column.formatValue(value) : value,
          type: "date"
        });
      };
      items2.filterDateEquals = {
        text: "L{on}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-equal",
        cls: "b-separator",
        weight: 300,
        disabled: me.disabled,
        onItem: () => filter2("=")
      };
      items2.filterDateBefore = {
        text: "L{before}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-before",
        weight: 310,
        disabled: me.disabled,
        onItem: () => filter2("<")
      };
      items2.filterDateAfter = {
        text: "L{after}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-after",
        weight: 320,
        disabled: me.disabled,
        onItem: () => filter2(">")
      };
    }
  }
  populateCellMenuWithNumberItems({
    column,
    record,
    items: items2
  }) {
    const property = column.field, type = this.getFilterType(column);
    if (type === "number") {
      const me = this, value = record[property], filter2 = (operator) => {
        me.applyFilter(column, {
          operator,
          value
        });
      };
      items2.filterNumberEquals = {
        text: "L{equals}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-equal",
        cls: "b-separator",
        weight: 300,
        disabled: me.disabled,
        onItem: () => filter2("=")
      };
      items2.filterNumberLess = {
        text: "L{lessThan}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-less",
        weight: 310,
        disabled: me.disabled,
        onItem: () => filter2("<")
      };
      items2.filterNumberMore = {
        text: "L{moreThan}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-more",
        weight: 320,
        disabled: me.disabled,
        onItem: () => filter2(">")
      };
    }
  }
  populateCellMenuWithDurationItems({
    column,
    record,
    items: items2
  }) {
    const property = column.field, type = this.getFilterType(column);
    if (type === "duration") {
      const me = this, value = record[property], filter2 = (operator) => {
        me.applyFilter(column, {
          operator,
          value
        });
      };
      items2.filterDurationEquals = {
        text: "L{equals}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-equal",
        cls: "b-separator",
        weight: 300,
        disabled: me.disabled,
        onItem: () => filter2("=")
      };
      items2.filterDurationLess = {
        text: "L{lessThan}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-less",
        weight: 310,
        disabled: me.disabled,
        onItem: () => filter2("<")
      };
      items2.filterDurationMore = {
        text: "L{moreThan}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-more",
        weight: 320,
        disabled: me.disabled,
        onItem: () => filter2(">")
      };
    }
  }
  populateCellMenuWithStringItems({
    column,
    record,
    items: items2
  }) {
    const type = this.getFilterType(column);
    if (!/(date|number|duration)/.test(type)) {
      var _column$filterable$fi, _column$filterable$fi2;
      const me = this, value = column.getFilterableValue(record), operator = (_column$filterable$fi = (_column$filterable$fi2 = column.filterable.filterField) === null || _column$filterable$fi2 === void 0 ? void 0 : _column$filterable$fi2.operator) !== null && _column$filterable$fi !== void 0 ? _column$filterable$fi : "*";
      items2.filterStringEquals = {
        text: "L{equals}",
        localeClass: me,
        icon: "b-fw-icon b-icon-filter-equal",
        cls: "b-separator",
        weight: 300,
        disabled: me.disabled,
        onItem: () => me.applyFilter(column, {
          value,
          operator
        })
      };
    }
  }
  populateCellMenu({
    column,
    record,
    items: items2
  }) {
    const me = this;
    if (column.filterable !== false && !record.isSpecialRow) {
      me.populateCellMenuWithDateItems(...arguments);
      me.populateCellMenuWithNumberItems(...arguments);
      me.populateCellMenuWithDurationItems(...arguments);
      me.populateCellMenuWithStringItems(...arguments);
      if (column.meta.isFiltered) {
        items2.filterRemove = {
          text: "L{removeFilter}",
          localeClass: me,
          icon: "b-fw-icon b-icon-remove",
          cls: "b-separator",
          weight: 400,
          disabled: me.disabled || me.isMulti && !me.columnHasRemovableFilters(column),
          onItem: () => me.removeFilter(column)
        };
      }
      if (me.isMulti) {
        items2.filterDisable = {
          text: "L{disableFilter}",
          localeClass: me,
          icon: "b-fw-icon b-icon-filter-disable",
          cls: "b-separator",
          weight: 400,
          disabled: me.disabled || !me.columnHasEnabledFilters(column),
          onItem: () => me.disableFilter(column)
        };
      }
    }
  }
  columnHasRemovableFilters(column) {
    const me = this;
    return Boolean(me.getCurrentMultiFilters(column).find((filter2) => !me.canDeleteFilter || me.callback(me.canDeleteFilter, me, [filter2]) !== false));
  }
  columnHasEnabledFilters(column) {
    return Boolean(this.getCurrentMultiFilters(column).find((filter2) => !filter2.disabled));
  }
  populateHeaderMenu({
    column,
    items: items2
  }) {
    const me = this;
    if (column.meta.isFiltered) {
      items2.editFilter = {
        text: "L{editFilter}",
        localeClass: me,
        weight: 100,
        icon: "b-fw-icon b-icon-filter",
        cls: "b-separator",
        disabled: me.disabled,
        onItem: () => me.showFilterEditor(column)
      };
      items2.removeFilter = {
        text: "L{removeFilter}",
        localeClass: me,
        weight: 110,
        icon: "b-fw-icon b-icon-remove",
        disabled: me.disabled || me.isMulti && !me.columnHasRemovableFilters(column),
        onItem: () => me.removeFilter(column)
      };
      if (me.isMulti) {
        items2.disableFilter = {
          text: "L{disableFilter}",
          localeClass: me,
          icon: "b-fw-icon b-icon-filter-disable",
          weight: 115,
          disabled: me.disabled || !me.columnHasEnabledFilters(column),
          onItem: () => me.disableFilter(column)
        };
      }
    } else if (column.filterable !== false) {
      items2.filter = {
        text: "L{filter}",
        localeClass: me,
        weight: 100,
        icon: "b-fw-icon b-icon-filter",
        cls: "b-separator",
        disabled: me.disabled,
        onItem: () => me.showFilterEditor(column)
      };
    }
  }
  onStoreBeforeFilter({
    filters
  }) {
    const {
      columns
    } = this.client;
    for (let i = 0; i < filters.count; i++) {
      const filter2 = filters.getAt(i);
      if (!filter2.internal) {
        var _column$filterable;
        const column = (filter2.columnOwned || this.prioritizeColumns) && columns.find((col) => col.filterable !== false && col.field === filter2.property);
        if (column !== null && column !== void 0 && (_column$filterable = column.filterable) !== null && _column$filterable !== void 0 && _column$filterable.filterFn) {
          if (!column.$filter) {
            column.$filter = new CollectionFilter({
              columnOwned: true,
              property: filter2.property,
              operator: filter2.operator,
              value: filter2.value,
              filterBy(record) {
                return column.filterable.filterFn({
                  value: this.value,
                  record,
                  operator: this.operator,
                  property: this.property,
                  column
                });
              }
            });
          }
          column.$filter.value = filter2.value;
          column.$filter.displayValue = filter2.displayValue;
          column.$filter.operator = filter2.operator;
          filters.splice(i, 1, column.$filter);
        }
      }
    }
  }
  onStoreFilter() {
    this.refreshHeaders(false);
  }
  renderHeader() {
    this.refreshHeaders(false);
  }
  onElementClick({
    target
  }) {
    if (this.filterEditorPopup) {
      this.closeFilterEditor();
    }
    if (target.classList.contains("b-filter-icon")) {
      const headerEl = target.closest(".b-grid-header");
      this.showFilterEditor(headerEl.dataset.columnId);
      return false;
    }
  }
  showFilterEditorByKey({
    target
  }) {
    const headerEl = target.matches(".b-grid-header") && target;
    if (headerEl) {
      this.showFilterEditor(headerEl.dataset.columnId);
    }
    return Boolean(headerEl);
  }
  isActionAvailable(key, action, event) {
    const headerElement = event.target.closest(".b-grid-header"), column = headerElement && this.client.columns.find((col) => col.id === headerElement.dataset.columnId);
    return Boolean(column === null || column === void 0 ? void 0 : column.filterable);
  }
};
Filter._$name = "Filter";
GridFeatureManager.registerFeature(Filter);
var complexOperators = {
  "*": null,
  isIncludedIn: null,
  startsWith: null,
  endsWidth: null
};
var FilterBar = class extends InstancePlugin {
  static get $name() {
    return "FilterBar";
  }
  static get configurable() {
    return {
      prioritizeColumns: false,
      keyStrokeFilterDelay: 300,
      compactMode: false,
      clearStoreFiltersOnHide: true,
      keyMap: {
        ArrowUp: {
          handler: "disableGridNavigation",
          preventDefault: false
        },
        ArrowRight: {
          handler: "disableGridNavigation",
          preventDefault: false
        },
        ArrowDown: {
          handler: "disableGridNavigation",
          preventDefault: false
        },
        ArrowLeft: {
          handler: "disableGridNavigation",
          preventDefault: false
        },
        Enter: {
          handler: "disableGridNavigation",
          preventDefault: false
        }
      }
    };
  }
  static get pluginConfig() {
    return {
      before: ["renderContents"],
      chain: ["afterColumnsChange", "renderHeader", "populateHeaderMenu", "bindStore"]
    };
  }
  static get properties() {
    return {
      filterFieldCls: "b-filter-bar-field",
      filterFieldInputCls: "b-filter-bar-field-input",
      filterableColumnCls: "b-filter-bar-enabled",
      filterFieldInputSelector: ".b-filter-bar-field-input",
      filterableColumnSelector: ".b-filter-bar-enabled",
      filterParseRegExp: /^\s*([<>=*])?(.*)$/,
      storeTrackingSuspended: 0
    };
  }
  construct(grid, config) {
    if (grid.features.filter) {
      throw new Error("Grid.feature.FilterBar feature may not be used together with Grid.feature.Filter, These features are mutually exclusive.");
    }
    const me = this;
    me.grid = grid;
    me.onColumnFilterFieldChange = me.onColumnFilterFieldChange.bind(me);
    super.construct(grid, Array.isArray(config) ? {
      filter: config
    } : config);
    me.bindStore(grid.store);
    if (me.filter) {
      grid.store.filter(me.filter);
    }
    me.gridDetacher = grid.ion({
      beforeElementClick: "onBeforeElementClick",
      thisObj: me
    });
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      beforeFilter: "onStoreBeforeFilter",
      filter: "onStoreFilter",
      thisObj: this
    });
  }
  doDestroy() {
    var _this$gridDetacher;
    this.destroyFilterBar();
    (_this$gridDetacher = this.gridDetacher) === null || _this$gridDetacher === void 0 ? void 0 : _this$gridDetacher.call(this);
    super.doDestroy();
  }
  doDisable(disable) {
    const {
      columns
    } = this.grid;
    columns === null || columns === void 0 ? void 0 : columns.forEach((column) => {
      const widget = this.getColumnFilterField(column);
      if (widget) {
        widget.disabled = disable;
      }
    });
    super.doDisable(disable);
  }
  updateCompactMode(value) {
    this.client.headerContainer.classList[value ? "add" : "remove"]("b-filter-bar-compact");
    for (const prop in this._columnFilters) {
      const field = this._columnFilters[prop];
      field.placeholder = value ? field.column.headerText : null;
    }
  }
  destroyFilterBar() {
    var _this$grid$columns;
    (_this$grid$columns = this.grid.columns) === null || _this$grid$columns === void 0 ? void 0 : _this$grid$columns.forEach(this.destroyColumnFilterField, this);
  }
  hideFilterBar() {
    var _me$grid$columns;
    const me = this;
    me.clearStoreFiltersOnHide && me.suspendStoreTracking();
    (_me$grid$columns = me.grid.columns) === null || _me$grid$columns === void 0 ? void 0 : _me$grid$columns.forEach((col) => me.hideColumnFilterField(col, true));
    me.grid.store.filter();
    me.clearStoreFiltersOnHide && me.resumeStoreTracking();
    me.hidden = true;
  }
  showFilterBar() {
    this.suspendStoreTracking();
    this.renderFilterBar();
    this.resumeStoreTracking();
    this.hidden = false;
  }
  toggleFilterBar() {
    if (this.hidden) {
      this.showFilterBar();
    } else {
      this.hideFilterBar();
    }
  }
  renderFilterBar() {
    if (this.grid.hideHeaders) {
      return;
    }
    this.grid.columns.visibleColumns.forEach((column) => this.renderColumnFilterField(column));
    this.rendered = true;
  }
  renderColumnFilterField(column) {
    const me = this, {
      grid
    } = me, filterable = me.getColumnFilterable(column);
    if (filterable && column.isVisible) {
      const headerEl = column.element, filter2 = grid.store.filters.get(column.id) || grid.store.filters.getBy("property", column.field);
      let widget = me.getColumnFilterField(column);
      if (!widget) {
        const type = `${column.filterType || "text"}field`, {
          filterField
        } = filterable, externalCls = filterField === null || filterField === void 0 ? void 0 : filterField.cls;
        if (externalCls) {
          delete filterable.filterField.cls;
        }
        widget = WidgetHelper.append(ObjectHelper.assign({
          type,
          cls: {
            [me.filterFieldCls]: 1,
            [externalCls]: externalCls
          },
          dataset: {
            column: column.field
          },
          column,
          owner: grid,
          clearable: true,
          name: column.field,
          value: filter2 && !filter2._filterBy && !filter2.internal ? me.buildFilterValue(filter2) : "",
          inputCls: me.filterFieldInputCls,
          keyStrokeChangeDelay: me.keyStrokeFilterDelay,
          onChange: me.onColumnFilterFieldChange,
          onClear: me.onColumnFilterFieldChange,
          disabled: me.disabled,
          placeholder: me.compactMode ? column.headerText : null,
          format: column.format
        }, filterField), headerEl)[0];
        if (!(filterField !== null && filterField !== void 0 && filterField.hasOwnProperty("min"))) {
          Object.defineProperty(widget, "min", {
            get: () => {
              var _column$editor;
              return (_column$editor = column.editor) === null || _column$editor === void 0 ? void 0 : _column$editor.min;
            },
            set: () => null
          });
        }
        if (!(filterField !== null && filterField !== void 0 && filterField.hasOwnProperty("max"))) {
          Object.defineProperty(widget, "max", {
            get: () => {
              var _column$editor2;
              return (_column$editor2 = column.editor) === null || _column$editor2 === void 0 ? void 0 : _column$editor2.max;
            },
            set: () => null
          });
        }
        if (!(filterField !== null && filterField !== void 0 && filterField.hasOwnProperty("strictParsing"))) {
          Object.defineProperty(widget, "strictParsing", {
            get: () => {
              var _column$editor3;
              return (_column$editor3 = column.editor) === null || _column$editor3 === void 0 ? void 0 : _column$editor3.strictParsing;
            },
            set: () => null
          });
        }
        widget.element.retainElement = true;
        me.setColumnFilterField(column, widget);
        const hasFilterFieldStoreData = (filterField === null || filterField === void 0 ? void 0 : filterField.store) && (filterField.store.readUrl || filterField.store.data || filterField.store.isChained);
        if (widget.isCombo && !hasFilterFieldStoreData && widget.store.count === 0) {
          const configuredValue = widget.value, refreshData = () => {
            if (!(widget.store.readUrl || widget.store.isChained)) {
              widget.store.data = grid.store.getDistinctValues(column.field, true).map((value) => grid.store.modelClass.new({
                id: value,
                [column.field]: value
              }));
            }
          };
          widget.value = null;
          if (!widget.store.isSorted) {
            widget.store.sort({
              field: column.field,
              ascending: true
            });
          }
          widget.picker.ion({
            beforeShow: refreshData
          });
          refreshData();
          widget.value = configuredValue;
        }
        if (!me.filter && widget.value && grid.store.autoLoad !== false) {
          me.onColumnFilterFieldChange({
            source: widget,
            value: widget.value
          });
        }
      } else {
        me.onColumnFilterFieldChange({
          source: widget,
          value: widget.value
        });
        widget.render(headerEl);
        widget.show();
      }
      headerEl.classList.add(me.filterableColumnCls);
    }
  }
  updateColumnFilterFields() {
    const me = this, {
      columns,
      store
    } = me.grid;
    let field, filter2;
    me._updatingFields = true;
    for (const column of columns.visibleColumns) {
      field = me.getColumnFilterField(column);
      if (field) {
        filter2 = store.filters.get(column.id) || store.filters.getBy("property", column.field);
        if (filter2 && !filter2.internal) {
          if (!filter2._filterBy) {
            field.value = me.buildFilterValue(filter2);
          } else {
            field.value = filter2.value;
          }
        } else {
          field.value = "";
        }
      }
    }
    me._updatingFields = false;
  }
  getColumnFilterable(column) {
    if (!column.isRoot && column.filterable !== false && column.field && column.isLeaf) {
      if (typeof column.filterable === "function") {
        column.filterable = {
          filterFn: column.filterable
        };
      }
      return column.filterable;
    }
  }
  destroyColumnFilterField(column) {
    const widget = this.getColumnFilterField(column);
    if (widget) {
      this.hideColumnFilterField(column, true);
      widget.destroy();
      this.setColumnFilterField(column, void 0);
    }
  }
  hideColumnFilterField(column, silent) {
    const me = this, {
      store
    } = me.grid, columnEl = column.element, widget = me.getColumnFilterField(column);
    if (widget) {
      if (!me.isDestroying) {
        widget.hide();
      }
      const {
        $filter
      } = column;
      if (!store.isDestroyed && me.clearStoreFiltersOnHide && $filter) {
        store.removeFilter($filter, silent);
      }
      columnEl === null || columnEl === void 0 ? void 0 : columnEl.classList.remove(me.filterableColumnCls);
    }
  }
  getColumnFilterField(column) {
    var _this$_columnFilters;
    return (_this$_columnFilters = this._columnFilters) === null || _this$_columnFilters === void 0 ? void 0 : _this$_columnFilters[column.id];
  }
  setColumnFilterField(column, widget) {
    this._columnFilters = this._columnFilters || {};
    this._columnFilters[column.data.id] = widget;
  }
  parseFilterValue(column, value, field) {
    var _column$filterable;
    if (Array.isArray(value)) {
      return {
        value
      };
    }
    if (ObjectHelper.isDate(value)) {
      return {
        operator: field.isDateField ? "sameDay" : field.isTimeField ? "sameTime" : "=",
        value
      };
    }
    const match = String(value).match(this.filterParseRegExp);
    return {
      operator: match[1] || ((_column$filterable = column.filterable) === null || _column$filterable === void 0 ? void 0 : _column$filterable.operator) || "*",
      value: match[2]
    };
  }
  buildFilterValue({
    operator,
    value
  }) {
    return value instanceof Date || Array.isArray(value) ? value : (operator in complexOperators ? "" : operator) + value;
  }
  onStoreBeforeFilter({
    filters
  }) {
    const {
      columns
    } = this.client;
    for (let i = 0; i < filters.count; i++) {
      var _column$filterable2;
      const filter2 = filters.getAt(i), column = (filter2.columnOwned || this.prioritizeColumns) && columns.find((col) => col.filterable !== false && col.field === filter2.property);
      if (column !== null && column !== void 0 && (_column$filterable2 = column.filterable) !== null && _column$filterable2 !== void 0 && _column$filterable2.filterFn) {
        if (!column.$filter) {
          column.$filter = new CollectionFilter({
            columnOwned: true,
            property: filter2.property,
            id: column.id,
            filterBy(record) {
              return column.filterable.filterFn({
                value: this.value,
                record,
                property: this.property,
                column
              });
            }
          });
        }
        column.$filter.value = filter2.value;
        filters.splice(i, 1, column.$filter);
      }
    }
  }
  onStoreFilter() {
    if (!this.storeTrackingSuspended && this.rendered) {
      this.updateColumnFilterFields();
    }
  }
  afterColumnsChange({
    changes,
    column
  }) {
    if (!this.hidden && changes !== null && changes !== void 0 && changes.hidden) {
      const hidden = changes.hidden.value;
      if (hidden) {
        this.destroyColumnFilterField(column);
      } else {
        this.renderColumnFilterField(column);
      }
    }
  }
  suspendStoreTracking() {
    this.storeTrackingSuspended++;
  }
  resumeStoreTracking() {
    this.storeTrackingSuspended--;
  }
  renderHeader() {
    if (!this.hidden) {
      this.renderFilterBar();
    }
  }
  renderContents() {
    if (this._columnFilters) {
      for (const field of Object.values(this._columnFilters)) {
        field === null || field === void 0 ? void 0 : field.element.remove();
      }
    }
  }
  disableGridNavigation(event) {
    if (event.target.matches(this.filterFieldInputSelector)) {
      return true;
    }
    return false;
  }
  onBeforeElementClick({
    event
  }) {
    if (event.target.closest(`.${this.filterFieldCls}`)) {
      return false;
    }
  }
  onColumnFilterFieldChange({
    source: field,
    value
  }) {
    const me = this, {
      column
    } = field, {
      filterFn
    } = column.filterable, {
      store
    } = me.grid, filter2 = column.$filter || store.filters.find((f) => (f.id === column.id || f.property === column.field) && !f.internal);
    if (me._updatingFields) {
      return;
    }
    const isClearingFilter = value == null || value === "" || Array.isArray(value) && value.length === 0;
    store.removeFilter(filter2, true);
    column.$filter = null;
    if (isClearingFilter) {
      if (!filter2) {
        return;
      }
    } else {
      var _column$filterable3, _column$filterable4;
      column.$filter = store.addFilter(_objectSpread2(_objectSpread2({
        property: field.name
      }, me.parseFilterValue(column, value, field)), {}, {
        [typeof ((_column$filterable3 = column.filterable) === null || _column$filterable3 === void 0 ? void 0 : _column$filterable3.caseSensitive) === "boolean" ? "caseSensitive" : void 0]: (_column$filterable4 = column.filterable) === null || _column$filterable4 === void 0 ? void 0 : _column$filterable4.caseSensitive,
        [filterFn ? "filterBy" : "_"]: function(record) {
          return filterFn({
            value: this.value,
            record,
            operator: this.operator,
            property: this.property,
            column
          });
        }
      }), true);
    }
    store.filter();
  }
  populateHeaderMenu({
    items: items2
  }) {
    items2.toggleFilterBar = {
      text: this.hidden ? "L{enableFilterBar}" : "L{disableFilterBar}",
      localeClass: this,
      weight: 120,
      icon: "b-fw-icon b-icon-filter",
      cls: "b-separator",
      onItem: () => this.toggleFilterBar()
    };
  }
};
FilterBar.featureClass = "b-filter-bar";
FilterBar._$name = "FilterBar";
GridFeatureManager.registerFeature(FilterBar);
var Group = class extends InstancePlugin {
  static get $name() {
    return "Group";
  }
  static get configurable() {
    return {
      field: null,
      groupSortFn: null,
      renderer: null,
      keyMap: {
        " ": "toggleGroup"
      }
    };
  }
  construct(grid, config) {
    const me = this;
    if (grid.features.tree) {
      return;
    }
    me._thisIsAUsedExpression(grid.features.groupSummary);
    config = me.processConfig(config);
    me.grid = grid;
    super.construct(grid, config);
    me.bindStore(grid.store);
    grid.rowManager.ion({
      beforeRenderRow: "onBeforeRenderRow",
      renderCell: "renderCell",
      prio: 1100,
      thisObj: me
    });
  }
  processConfig(config) {
    if (typeof config === "string") {
      return {
        field: config,
        ascending: null
      };
    }
    return config;
  }
  setConfig(config) {
    if (config === null) {
      this.store.clearGroupers();
    } else {
      super.setConfig(this.processConfig(config));
    }
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      group: "onStoreGroup",
      change: "onStoreChange",
      thisObj: this
    });
  }
  updateRenderer(renderer) {
    this.groupRenderer = renderer;
  }
  updateField(field) {
    this.store.group({
      field,
      ascending: this.ascending,
      fn: this.groupSortFn
    });
  }
  updateGroupSortFn(fn2) {
    if (!this.isConfiguring) {
      this.store.group({
        field: this.field,
        ascending: this.ascending,
        fn: fn2
      });
    }
  }
  doDestroy() {
    super.doDestroy();
  }
  doDisable(disable) {
    const {
      store
    } = this;
    if (disable && store.isGrouped) {
      const {
        sorters
      } = store;
      sorters.unshift(...store.groupers);
      store.clearGroupers();
      store.sort(sorters);
    }
    super.doDisable(disable);
  }
  get store() {
    return this.grid.store;
  }
  static get pluginConfig() {
    return {
      assign: ["collapseAll", "expandAll"],
      chain: ["renderHeader", "populateHeaderMenu", "getColumnDragToolbarItems", "onElementTouchStart", "onElementClick", "bindStore"]
    };
  }
  toggleCollapse(recordOrId, collapse) {
    this.internalToggleCollapse(recordOrId, collapse);
  }
  internalToggleCollapse(recordOrId, collapse, skipRender = false) {
    const me = this, {
      store,
      grid
    } = me, groupRecord = store.getById(recordOrId);
    if (!groupRecord.isGroupHeader) {
      return;
    }
    collapse = collapse === void 0 ? !groupRecord.meta.collapsed : collapse;
    if (grid.trigger("beforeToggleGroup", {
      groupRecord,
      collapse
    }) === false) {
      return;
    }
    if (collapse) {
      store.collapse(groupRecord);
    } else {
      store.expand(groupRecord);
    }
    if (!skipRender) {
      if (grid.rowManager.rowCount > grid.store.count) {
        grid.rowManager.renderFromRow();
      } else {
        grid.rowManager.renderFromRecord(groupRecord);
      }
    }
    grid.trigger("toggleGroup", {
      groupRecord,
      collapse
    });
    grid.afterToggleGroup();
  }
  collapseAll() {
    const me = this;
    if (me.store.isGrouped && !me.disabled) {
      me.store.groupRecords.forEach((r) => me.internalToggleCollapse(r, true, true));
      me.grid.refreshRows(true);
    }
  }
  expandAll() {
    const me = this;
    if (me.store.isGrouped && !me.disabled) {
      me.store.groupRecords.forEach((r) => me.internalToggleCollapse(r, false, true));
      me.grid.refreshRows();
    }
  }
  onBeforeRenderRow({
    row
  }) {
    const oldRecord = row.grid.store.getById(row.id);
    row.forceInnerHTML = row.forceInnerHTML || (oldRecord === null || oldRecord === void 0 ? void 0 : oldRecord.isGroupHeader);
  }
  renderCell(renderData) {
    const me = this, {
      cellElement,
      row,
      column
    } = renderData, {
      meta
    } = renderData.record, rowClasses = {
      "b-group-row": 0,
      "b-grid-group-collapsed": 0
    };
    if (!me.disabled && me.store.isGrouped && "groupRowFor" in meta) {
      if (column.type === "action") {
        return;
      }
      column.clearCell(cellElement);
      rowClasses["b-grid-group-collapsed"] = meta.collapsed;
      rowClasses["b-group-row"] = 1;
      if (column === me.groupHeaderColumn) {
        cellElement.classList.add("b-group-title");
        cellElement.$groupHeader = true;
      }
      me.buildGroupHeader(renderData);
    } else if (cellElement.$groupHeader) {
      cellElement.classList.remove("b-group-title");
      cellElement.$groupHeader = false;
    }
    row.assignCls(rowClasses);
  }
  buildGroupHeader(renderData) {
    const me = this, {
      record,
      cellElement,
      column,
      persist
    } = renderData, {
      grid
    } = me, meta = record.meta, {
      groupRowFor
    } = meta, {
      groupSummary
    } = grid.features, count = meta.childCount - (groupSummary && groupSummary.target !== "header" ? 1 : 0);
    let html = null, applyDefault = true;
    if (persist || column) {
      const groupColumn = grid.columns.get(meta.groupField), isGroupHeaderColumn = renderData.isFirstColumn = column === me.groupHeaderColumn;
      if (groupColumn !== null && groupColumn !== void 0 && groupColumn.groupRenderer) {
        if (isGroupHeaderColumn) {
          html = groupColumn.groupRenderer(_objectSpread2(_objectSpread2({}, renderData), {}, {
            groupRowFor,
            groupRecords: record.groupChildren,
            groupColumn,
            count
          }));
          applyDefault = false;
        }
      } else if (me.groupRenderer) {
        html = me.groupRenderer(_objectSpread2(_objectSpread2({}, renderData), {}, {
          groupRowFor,
          groupRecords: record.groupChildren,
          groupColumn,
          count,
          isFirstColumn: isGroupHeaderColumn
        }));
      }
      if (isGroupHeaderColumn && html == null && applyDefault && DomHelper.getChildElementCount(cellElement) === 0) {
        html = StringHelper.encodeHtml(`${groupRowFor === "__novalue__" ? "" : groupRowFor} (${count})`);
      }
    } else if (me.groupRenderer) {
      html = me.groupRenderer(renderData);
    }
    if (typeof html === "string") {
      cellElement.innerHTML = html;
    } else if (typeof html === "object") {
      DomSync.sync({
        targetElement: cellElement,
        domConfig: {
          onlyChildren: true,
          children: ArrayHelper.asArray(html)
        }
      });
    }
    if (DomHelper.getChildElementCount(cellElement) > 0) {
      cellElement._hasHtml = true;
    }
    return cellElement.innerHTML;
  }
  get groupHeaderColumn() {
    return this.grid.columns.visibleColumns.find((column) => !column.groupHeaderReserved);
  }
  renderHeader(headerContainerElement) {
    const {
      store,
      grid
    } = this;
    if (store.isGrouped) {
      for (const groupInfo of store.groupers) {
        const column = grid.columns.get(groupInfo.field), header = column && grid.getHeaderElement(column.id);
        header === null || header === void 0 ? void 0 : header.classList.add("b-group", groupInfo.ascending ? "b-asc" : "b-desc");
      }
    }
  }
  populateHeaderMenu({
    column,
    items: items2
  }) {
    const me = this;
    if (column.groupable !== false) {
      items2.groupAsc = {
        text: "L{groupAscending}",
        localeClass: me,
        icon: "b-fw-icon b-icon-group-asc",
        cls: "b-separator",
        weight: 400,
        disabled: me.disabled,
        onItem: () => me.store.group(column.field, true)
      };
      items2.groupDesc = {
        text: "L{groupDescending}",
        localeClass: me,
        icon: "b-fw-icon b-icon-group-desc",
        weight: 410,
        disabled: me.disabled,
        onItem: () => me.store.group(column.field, false)
      };
    }
    if (me.store.isGrouped) {
      items2.groupRemove = {
        text: "L{stopGrouping}",
        localeClass: me,
        icon: "b-fw-icon b-icon-clear",
        cls: column.groupable ? "" : "b-separator",
        weight: 420,
        disabled: me.disabled,
        onItem: () => me.store.clearGroupers()
      };
    }
  }
  getColumnDragToolbarItems(column, items2) {
    var _store$groupers;
    const me = this, {
      store,
      disabled
    } = me;
    items2.push({
      text: "L{groupAscendingShort}",
      group: "L{group}",
      localeClass: me,
      icon: "b-icon b-icon-group-asc",
      ref: "groupAsc",
      cls: "b-separator",
      weight: 110,
      disabled,
      onDrop: ({
        column: column2
      }) => store.group(column2.field, true)
    });
    items2.push({
      text: "L{groupDescendingShort}",
      group: "L{group}",
      localeClass: me,
      icon: "b-icon b-icon-group-desc",
      ref: "groupDesc",
      weight: 110,
      disabled,
      onDrop: ({
        column: column2
      }) => store.group(column2.field, false)
    });
    const grouped = ((_store$groupers = store.groupers) === null || _store$groupers === void 0 ? void 0 : _store$groupers.some((col) => col.field === column.field)) && !disabled;
    items2.push({
      text: "L{stopGroupingShort}",
      group: "L{group}",
      localeClass: me,
      icon: "b-icon b-icon-clear",
      ref: "groupRemove",
      disabled: !grouped,
      weight: 110,
      onDrop: ({
        column: column2
      }) => store.removeGrouper(column2.field)
    });
    return items2;
  }
  onStoreGroup({
    groupers
  }) {
    const {
      grid
    } = this, {
      element
    } = grid, curGroupHeaders = element && DomHelper.children(element, ".b-grid-header.b-group");
    if (element) {
      for (const header of curGroupHeaders) {
        header.classList.remove("b-group", "b-asc", "b-desc");
      }
      if (groupers) {
        for (const groupInfo of groupers) {
          const header = grid.getHeaderElementByField(groupInfo.field);
          if (header) {
            header.classList.add("b-group", groupInfo.ascending ? "b-asc" : "b-desc");
          }
        }
      }
    }
  }
  onStoreChange({
    action,
    records
  }) {
    const {
      client
    } = this, {
      rowManager,
      store
    } = client;
    if (store.isGrouped && action === "move") {
      const {
        field
      } = store.groupers[0], fromRow = Math.min(...records.reduce((result, record) => {
        result.push(store.indexOf(record.instanceMeta(store).groupParent));
        if (field in record.meta.modified) {
          const oldGroup = store.groupRecords.find((r) => r.meta.groupRowFor === record.meta.modified[field]);
          if (oldGroup) {
            result.push(store.indexOf(oldGroup));
          }
        }
        return result;
      }, []));
      rowManager.renderFromRow(rowManager.getRow(fromRow));
    }
  }
  onElementTouchStart(event) {
    const me = this, {
      target
    } = event, header = target.closest(".b-grid-header"), column = header && me.grid.getColumnFromElement(header);
    if (event.touches.length > 1 && column && column.groupable !== false && !me.disabled) {
      me.store.group(column.field);
    }
  }
  onElementClick(event) {
    const me = this, {
      store
    } = me, {
      target
    } = event, row = target.closest(".b-group-row"), header = target.closest(".b-grid-header"), field = header === null || header === void 0 ? void 0 : header.dataset.column;
    if (target.classList.contains("b-resizer") || me.disabled || target.classList.contains("b-action-item") || event.handled) {
      return;
    }
    if (header && field) {
      var _store$groupers2;
      const columnGrouper = (_store$groupers2 = store.groupers) === null || _store$groupers2 === void 0 ? void 0 : _store$groupers2.find((g) => g.field === field);
      if (columnGrouper && !event.shiftKey) {
        store.group(field, !columnGrouper.ascending);
        return false;
      } else if (event.shiftKey) {
        const column = me.grid.columns.get(field);
        if (column.groupable !== false) {
          if (event.altKey) {
            store.removeGrouper(field);
          } else {
            store.group(field);
          }
        }
      }
    }
    if (row) {
      me.internalToggleCollapse(DomDataStore.get(row).id);
      return false;
    }
  }
  toggleGroup(event) {
    var _focusedCell$record;
    const {
      grid
    } = this, {
      focusedCell
    } = grid;
    if (!this.disabled && !focusedCell.isActionable && (_focusedCell$record = focusedCell.record) !== null && _focusedCell$record !== void 0 && _focusedCell$record.isGroupHeader) {
      this.internalToggleCollapse(focusedCell.id);
      return true;
    }
    return false;
  }
};
Group._$name = "Group";
GridFeatureManager.registerFeature(Group, true, ["Grid", "Scheduler"]);
GridFeatureManager.registerFeature(Group, false, ["TreeGrid"]);
var SummaryFormatter = (Target) => class SummaryFormatter extends (Target || Base$1) {
  static get $name() {
    return "SummaryFormatter";
  }
  generateHtml(column, records, cls, groupRecord, groupField, groupValue) {
    const store = this.store, summaries = column.summaries || (column.sum ? [{
      sum: column.sum,
      renderer: column.summaryRenderer
    }] : []);
    let html = `<table class="${cls}">`;
    summaries.forEach((config) => {
      let type = config.sum, sum = null;
      if (type === true)
        type = "sum";
      switch (type) {
        case "sum":
        case "add":
          sum = store.sum(column.field, records);
          break;
        case "max":
          sum = store.max(column.field, records);
          break;
        case "min":
          sum = store.min(column.field, records);
          break;
        case "average":
        case "avg":
          sum = store.average(column.field, records);
          break;
        case "count":
          sum = records.length;
          break;
        case "countNotEmpty":
          sum = records.reduce((sum2, record) => {
            const value = record[column.field];
            return sum2 + (value != null ? 1 : 0);
          }, 0);
          break;
      }
      if (typeof type === "function") {
        sum = records.reduce(type, "seed" in config ? config.seed : 0);
      }
      if (sum !== null) {
        const valueCls = "b-grid-summary-value", labelHtml = config.label ? `<td class="b-grid-summary-label">${config.label}</td>` : "";
        let valueHtml = config.renderer ? config.renderer({
          config,
          sum
        }) : sum, summaryHtml;
        if (valueHtml == null) {
          valueHtml = "";
        }
        if (!String(valueHtml).includes("<td>")) {
          summaryHtml = labelHtml ? `${labelHtml}<td class="${valueCls}">${valueHtml}</td>` : `<td colspan="2" class="${valueCls}">${valueHtml}</td>`;
        } else {
          summaryHtml = valueHtml;
        }
        html += `<tr>${summaryHtml}</tr>`;
      }
    });
    return html + "</table>";
  }
};
var GroupSummary$1 = class extends SummaryFormatter(InstancePlugin) {
  static get $name() {
    return "GroupSummary";
  }
  static get configurable() {
    return {
      collapseToHeader: null,
      target: "footer"
    };
  }
  construct(grid, config) {
    this.grid = grid;
    super.construct(grid, config);
    if (!grid.features.group) {
      throw new Error("Requires Group feature to work, please enable");
    }
    this.bindStore(grid.store);
    grid.rowManager.ion({
      beforeRenderRow: "onBeforeRenderRow",
      renderCell: "renderCell",
      prio: 1e3,
      thisObj: this
    });
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      update: "onStoreUpdate",
      prio: 1,
      thisObj: this
    });
  }
  get store() {
    return this.grid.store;
  }
  doDisable(disable) {
    this.updateTarget(this.target);
    super.doDisable(disable);
  }
  changeTarget(target) {
    ObjectHelper.assertString(target, "target");
    return target;
  }
  updateTarget(target) {
    this.store.useGroupFooters = !this.disabled && target === "footer";
    if (!this.isConfiguring) {
      this.store.group();
    }
  }
  changeCollapseToHeader(collapseToHeader) {
    ObjectHelper.assertBoolean(collapseToHeader, "collapseToHeader");
    return collapseToHeader;
  }
  updateCollapseToHeader() {
    if (!this.isConfiguring) {
      this.store.group();
    }
  }
  static get pluginConfig() {
    return {
      chain: ["bindStore"]
    };
  }
  onBeforeRenderRow({
    row,
    record
  }) {
    if (row.isGroupFooter && !("groupFooterFor" in record.meta)) {
      row.isGroupFooter = false;
      row.forceInnerHTML = true;
    } else if (row.isGroupHeader && !record.meta.collapsed) {
      row.eachElement(this.removeSummaryElements);
    }
  }
  removeSummaryElements(rowEl) {
  }
  renderCell({
    column,
    cellElement,
    row,
    record,
    size,
    isFirstColumn
  }) {
    const me = this, {
      meta
    } = record, {
      rowHeight
    } = me.grid, isGroupHeader = "groupRowFor" in meta, isGroupFooter = "groupFooterFor" in meta, targetsHeader = me.target === "header", rowClasses = {
      "b-group-footer": 0,
      "b-header-summary": 0
    }, isSummaryTarget = isGroupHeader && (targetsHeader || me.collapseToHeader && meta.collapsed) && !isFirstColumn || isGroupFooter && !targetsHeader;
    if (isGroupHeader || isGroupFooter) {
      size.height = rowHeight;
    }
    if (me.store.isGrouped && isSummaryTarget && !me.disabled) {
      column.clearCell(cellElement);
      const groupRecord = isGroupHeader ? record : meta.groupRecord;
      row.isGroupFooter = isGroupFooter;
      row.isGroupHeader = isGroupHeader;
      if (isGroupFooter) {
        rowClasses["b-group-footer"] = 1;
      } else {
        rowClasses["b-header-summary"] = 1;
      }
      const heightSetting = me.updateSummaryHtml(cellElement, column, groupRecord), count = typeof heightSetting === "number" ? heightSetting : heightSetting.count;
      if (count > 1) {
        size.height += meta.collapsed && !targetsHeader ? 0 : count * rowHeight * 0.1;
      }
      if (heightSetting.height) {
        size.height += heightSetting.height;
      }
    }
    row.assignCls(rowClasses);
  }
  updateSummaryHtml(cellElement, column, groupRecord) {
    const records = groupRecord.groupChildren.slice();
    if (records[records.length - 1].isGroupFooter) {
      records.pop();
    }
    const html = this.generateHtml(column, records, "b-grid-group-summary", groupRecord, groupRecord.meta.groupField, groupRecord.meta.groupRowFor);
    if (!cellElement.children.length) {
      cellElement.innerHTML = html;
    } else {
      DomHelper.sync(html, cellElement.firstElementChild);
    }
    return column.summaries ? column.summaries.length : column.sum ? 1 : 0;
  }
  onStoreUpdate({
    source: store,
    changes
  }) {
    if (!this.disabled && store.isGrouped) {
      if (changes && store.groupers.find((grouper) => grouper.field in changes)) {
        return;
      }
      const shouldUpdate = Object.keys(changes).some((field) => {
        const colField = this.grid.columns.get(field);
        return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));
      });
      if (shouldUpdate) {
        this.grid.forceFullRefresh = true;
      }
    }
  }
  refresh() {
    this.grid.columns.visibleColumns.forEach((column) => {
      if (this.hasSummary(column)) {
        this.grid.refreshColumn(column);
      }
    });
  }
  hasSummary(column) {
    return column.sum || column.summaries;
  }
};
GroupSummary$1.featureClass = "b-group-summary";
GroupSummary$1._$name = "GroupSummary";
GridFeatureManager.registerFeature(GroupSummary$1);
var HeaderMenu = class extends ContextMenuBase {
  static get $name() {
    return "HeaderMenu";
  }
  static get configurable() {
    return {
      type: "header",
      items: null,
      moveColumns: null
    };
  }
  static get defaultConfig() {
    return {
      processItems: null
    };
  }
  static get pluginConfig() {
    const config = super.pluginConfig;
    config.chain.push("populateHeaderMenu");
    return config;
  }
  shouldShowMenu(eventParams) {
    const {
      column
    } = eventParams;
    return column && column.enableHeaderContextMenu !== false && column !== this.client.timeAxisColumn;
  }
  getDataFromEvent(event) {
    return ObjectHelper.assign(super.getDataFromEvent(event), this.client.getHeaderDataFromEvent(event));
  }
  populateHeaderMenu({
    items: items2,
    column
  }) {
    const me = this;
    if (column) {
      if (column.headerMenuItems) {
        ObjectHelper.merge(items2, column.headerMenuItems);
      }
      if (column.isCollapsible) {
        const {
          collapsed
        } = column, icon = collapsed ? me.client.rtl ? "left" : "right" : me.client.rtl ? "right" : "left";
        items2.toggleCollapse = {
          weight: 215,
          icon: `b-fw-icon b-icon-collapse-${icon}`,
          text: me.L(collapsed ? "L{expandColumn}" : "L{collapseColumn}"),
          onItem: () => column.collapsed = !collapsed
        };
      }
      if (me.moveColumns) {
        const columnToMoveBefore = me.getColumnToMoveBefore(column), columnToMoveAfter = me.getColumnToMoveAfter(column);
        if (columnToMoveBefore) {
          items2.movePrev = {
            weight: 220,
            icon: "b-fw-icon b-icon-column-move-left",
            text: me.L("L{moveBefore}", StringHelper.encodeHtml(columnToMoveBefore.text)),
            onItem: () => {
              const {
                parent: oldParent
              } = column;
              if (columnToMoveBefore.parent.insertChild(column, columnToMoveBefore)) {
                var _oldParent$children;
                column.region = columnToMoveBefore.region;
                if (!((_oldParent$children = oldParent.children) !== null && _oldParent$children !== void 0 && _oldParent$children.length)) {
                  oldParent.remove();
                }
              }
            }
          };
        }
        if (columnToMoveAfter) {
          items2.moveNext = {
            weight: 230,
            icon: "b-fw-icon b-icon-column-move-right",
            text: me.L("L{moveAfter}", StringHelper.encodeHtml(columnToMoveAfter.text)),
            onItem: () => {
              const {
                parent: oldParent
              } = column;
              if (columnToMoveAfter.parent.insertChild(column, columnToMoveAfter.nextSibling)) {
                var _oldParent$children2;
                column.region = columnToMoveAfter.region;
                if (!((_oldParent$children2 = oldParent.children) !== null && _oldParent$children2 !== void 0 && _oldParent$children2.length)) {
                  oldParent.remove();
                }
              }
            }
          };
        }
      }
    }
    return items2;
  }
  getColumnToMoveBefore(column) {
    const {
      previousSibling,
      parent
    } = column;
    if (previousSibling) {
      return previousSibling.children && !column.children ? previousSibling.children[previousSibling.children.length - 1] : previousSibling;
    }
    if (!parent.isRoot) {
      return parent;
    }
  }
  getColumnToMoveAfter(column) {
    const {
      nextSibling,
      parent
    } = column;
    if (nextSibling) {
      return nextSibling;
    }
    if (!parent.isRoot) {
      return parent;
    }
  }
};
HeaderMenu.featureClass = "";
HeaderMenu._$name = "HeaderMenu";
GridFeatureManager.registerFeature(HeaderMenu, true);
var camelCase = {
  mousedown: "mouseDown",
  mousemove: "mouseMove",
  mouseup: "mouseUp",
  touchdown: "touchDown",
  touchmove: "touchMove",
  touchup: "touchUp",
  mouseover: "mouseOver",
  mouseout: "mouseOut",
  dblclick: "dblClick",
  keydown: "keyDown",
  keypress: "keyPress",
  keyup: "keyUp",
  contextmenu: "contextMenu"
};
var MergeCells = class extends InstancePlugin {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "mergedRanges", []);
    _defineProperty(this, "mergedMap", {});
  }
  static get pluginConfig() {
    return {
      chain: [
        "beforeRenderCell",
        "afterRenderRow",
        "bindStore",
        "afterColumnsChange",
        "afterRemove",
        "afterToggleGroup",
        "afterToggleSubGrid",
        "handleEvent",
        "populateHeaderMenu",
        "afterSelectionChange"
      ],
      before: ["onInternalResize"],
      override: ["getColumnFromElement", "getRecordFromElement"]
    };
  }
  afterConstruct() {
    const me = this, {
      client
    } = me;
    client.eachSubGrid((subGrid) => me.setupSubGrid(subGrid));
    client.rowManager.ion({
      renderDone: "onRenderDone",
      thisObj: me
    });
    me.bindStore(client.store);
  }
  setupSubGrid(subGrid) {
    subGrid.$mergedCellsElement = DomHelper.createElement({
      parent: subGrid.element,
      className: {
        "b-grid-merged-cells-container": 1
      }
    });
  }
  doDisable(disable) {
    if (!this.isConfiguring) {
      this.isDisabling = true;
      this.reset();
      this.isDisabling = false;
    }
    super.doDisable(disable);
  }
  updatePassthrough(use) {
    this.client.element.classList.toggle("b-mergecells-passthrough", use);
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      change: "onStoreChange",
      refresh: {
        prio: 1,
        fn: "onStoreRefresh"
      },
      thisObj: this
    });
  }
  onInternalResize() {
    this.refreshBounds();
  }
  beforeRenderCell(renderData) {
    const {
      column,
      record,
      cellElement
    } = renderData, subGrid = this.client.subGrids[column.region];
    if (!this.disabled && column.mergeCells && column.isSorted && !record.isSpecialRow && !subGrid.collapsed) {
      const mergedRange = this.getMergeRange(record, column);
      if (mergedRange !== null && mergedRange !== void 0 && mergedRange.use) {
        cellElement.classList.add("b-merged-cell");
        cellElement.innerHTML = "";
        renderData.cellElement = mergedRange.cellElement;
      }
    }
  }
  afterRenderRow({
    row,
    oldId,
    oldHeight
  }) {
    if (oldId === row.id && oldHeight !== row.height) {
      this.heightChanged = true;
    }
  }
  afterColumnsChange({
    action,
    changes,
    column
  }) {
    if (this.disabled) {
      return;
    }
    if (action === "update" && changes.mergeCells && !column.mergeCells) {
      for (const range of this.mergedRanges.slice()) {
        if (range.column === column) {
          this.removeRange(range);
        }
      }
      this.syncDom();
      return;
    }
    this.refreshBounds();
  }
  afterRemove() {
    !this.disabled && this.reset();
  }
  afterToggleGroup() {
    !this.disabled && this.reset();
  }
  afterToggleSubGrid() {
    !this.disabled && this.reset();
  }
  afterSelectionChange() {
    if (!this.passthrough) {
      const {
        client
      } = this, indices = client.selectedRecords.map((r) => client.store.indexOf(r));
      let changed = false;
      for (const range of this.mergedRanges) {
        let allSelected = true;
        for (let i = range.fromIndex; i <= range.toIndex && allSelected; i++) {
          allSelected = indices.includes(i);
        }
        if (range.isSelected !== allSelected) {
          range.isSelected = allSelected;
          changed = true;
        }
      }
      changed && this.syncDom();
    }
  }
  getRecordFromElement(element) {
    var _element$elementData;
    if ((_element$elementData = element.elementData) !== null && _element$elementData !== void 0 && _element$elementData.range) {
      return this.client.store.getAt(element.elementData.range.fromIndex);
    }
    return this.overridden.getRecordFromElement(element);
  }
  getColumnFromElement(element) {
    var _element$elementData2;
    if ((_element$elementData2 = element.elementData) !== null && _element$elementData2 !== void 0 && _element$elementData2.range) {
      return element.elementData.range.column;
    }
    return this.overridden.getColumnFromElement(element);
  }
  populateHeaderMenu({
    column,
    items: items2
  }) {
    if (column.mergeable !== false) {
      items2.mergeCells = {
        text: "L{MergeCells.mergeCells}",
        icon: `b-fw-icon ${column.mergeCells ? "b-icon-checked" : "b-icon-unchecked"}`,
        tooltip: "L{MergeCells.menuTooltip}",
        cls: "b-separator",
        weight: 500,
        disabled: this.disabled,
        onItem: () => column.mergeCells = !column.mergeCells
      };
    }
  }
  async handleEvent(event) {
    if (!this.passthrough) {
      const mergedCellsElement = event.target.closest(".b-grid-merged-cells");
      if (mergedCellsElement) {
        var _camelCase$event$type;
        const {
          client
        } = this, {
          range
        } = mergedCellsElement.elementData, {
          cellEdit
        } = client.features, {
          column
        } = range, type = StringHelper.capitalize((_camelCase$event$type = camelCase[event.type]) !== null && _camelCase$event$type !== void 0 ? _camelCase$event$type : event.type), eventData = {
          grid: client,
          records: [],
          column,
          cellElement: mergedCellsElement.firstElementChild,
          target: event.target,
          event
        };
        for (let i = range.fromIndex; i <= range.toIndex; i++) {
          eventData.records.push(client.store.getAt(i));
        }
        client.trigger(`mergedCell${type}`, eventData);
        if ((cellEdit === null || cellEdit === void 0 ? void 0 : cellEdit.triggerEvent.toLowerCase()) === `cell${type}`.toLowerCase()) {
          const row = client.rowManager.getRowAt(event.clientY);
          await cellEdit.startEditing({
            id: row.id,
            columnId: column.id
          });
        } else if (event.type === "click") {
          this.onRangeClick({
            range
          });
        }
      }
    }
  }
  onRangeClick({
    range
  }) {
    const records = [];
    for (let i = range.fromIndex; i <= range.toIndex; i++) {
      records.push(this.client.store.getAt(i));
    }
    this.client.selectedRecords = records;
  }
  onStoreChange() {
    !this.disabled && this.reset();
  }
  onStoreRefresh({
    action
  }) {
    if (action !== "filter" && action !== "dataset") {
      !this.disabled && this.reset(false);
    }
  }
  createRangeElement(range) {
    var _parent$syncIdMap$syn, _parent$syncIdMap, _parent$releasedIdMap;
    const parent = this.client.getSubGridFromColumn(range.column).$mergedCellsElement, syncId = `${range.fromIndex}-@-${range.column.id}`;
    let element = (_parent$syncIdMap$syn = (_parent$syncIdMap = parent.syncIdMap) === null || _parent$syncIdMap === void 0 ? void 0 : _parent$syncIdMap[syncId]) !== null && _parent$syncIdMap$syn !== void 0 ? _parent$syncIdMap$syn : (_parent$releasedIdMap = parent.releasedIdMap) === null || _parent$releasedIdMap === void 0 ? void 0 : _parent$releasedIdMap[syncId];
    if (parent.releasedIdMap) {
      delete parent.releasedIdMap[syncId];
    }
    if (!element) {
      element = DomHelper.createElement(this.createRangeDomConfig(range));
    }
    DomSync.addChild(parent, element, syncId);
    range.element = element;
    range.cellElement = element.firstElementChild;
    return element;
  }
  createRangeDomConfig(range) {
    var _column$mergedRendere;
    const {
      column,
      fromIndex,
      toIndex,
      top,
      left,
      width,
      height
    } = range, {
      type
    } = column, record = this.client.store.getAt(fromIndex), domConfig = {
      className: {
        "b-grid-merged-cells": 1,
        "b-selected": range.isSelected
      },
      elementData: {
        range
      },
      style: {
        top,
        left,
        height,
        width
      },
      dataset: {
        syncId: `${fromIndex}-@-${column.id}`,
        fromIndex,
        toIndex,
        column: column.field,
        columnId: column.id
      },
      children: [
        {
          className: new DomClassList(this.client.cellCls).assign({
            [`b-${type === null || type === void 0 ? void 0 : type.toLowerCase()}-cell`]: type,
            [column.cellCls]: column.cellCls,
            [column.internalCellCls]: column.internalCellCls
          }).assign(column.autoCls),
          keepChildren: true,
          elementData: {
            range
          },
          dataset: {
            column: column.field,
            columnId: column.id
          },
          style: {
            height: this.client.rowManager.rowHeight
          }
        }
      ]
    };
    (_column$mergedRendere = column.mergedRenderer) === null || _column$mergedRendere === void 0 ? void 0 : _column$mergedRendere.call(column, {
      domConfig,
      value: column.getRawValue(record),
      record,
      column,
      fromIndex,
      toIndex
    });
    return domConfig;
  }
  buildMergedCellsConfig(fromIndex, toIndex, rows) {
    var _fromIndex, _rowManager$topRow, _toIndex, _rowManager$bottomRow;
    const me = this, {
      client
    } = me, {
      rowManager
    } = client;
    fromIndex = (_fromIndex = fromIndex) !== null && _fromIndex !== void 0 ? _fromIndex : (_rowManager$topRow = rowManager.topRow) === null || _rowManager$topRow === void 0 ? void 0 : _rowManager$topRow.dataIndex;
    toIndex = (_toIndex = toIndex) !== null && _toIndex !== void 0 ? _toIndex : (_rowManager$bottomRow = rowManager.bottomRow) === null || _rowManager$bottomRow === void 0 ? void 0 : _rowManager$bottomRow.dataIndex;
    const domConfigMap = client.regions.reduce((map2, region) => {
      map2[region] = {
        className: {
          "b-grid-merged-cells-container": 1
        },
        children: []
      };
      return map2;
    }, {});
    for (const range of me.mergedRanges) {
      if (range.use && range.fromIndex <= toIndex && range.toIndex >= fromIndex) {
        me.updateRange(range, me.heightChanged, rows);
        domConfigMap[range.column.region].children.push(me.createRangeDomConfig(range));
      }
    }
    return domConfigMap;
  }
  syncDom(force = false) {
    const me = this, {
      client
    } = me, {
      rowManager
    } = client;
    if (!force && !rowManager.topRow || me.disabled && !me.isDisabling) {
      return;
    }
    const domConfigMap = this.buildMergedCellsConfig();
    client.eachSubGrid((subGrid) => {
      DomSync.sync({
        targetElement: subGrid.$mergedCellsElement,
        syncIdField: "syncId",
        domConfig: domConfigMap[subGrid.region]
      });
    });
    me.heightChanged = false;
  }
  onRenderDone() {
    this.syncDom();
  }
  removeRange(range) {
    ArrayHelper.remove(this.mergedRanges, range);
    for (let index = range.fromIndex; index <= range.toIndex; index++) {
      delete this.mergedMap[`${index}-@-${range.column.id}`];
    }
  }
  reset(redraw = true) {
    const me = this, columns = me.client.columns.visibleColumns.filter((c) => c.mergeCells && c.isSorted, true), hadRanges = me.mergedRanges.length;
    me.mergedRanges = [];
    me.mergedMap = {};
    if (redraw && !me.client.refreshSuspended) {
      for (const row of me.client.rowManager.rows) {
        for (const column of columns) {
          row.renderCell(row.getCell(column.id));
        }
      }
      me.syncDom(hadRanges && !me.client.rowManager.rowCount);
    }
  }
  refreshBounds() {
    const {
      mergedRanges
    } = this, boundsMap = /* @__PURE__ */ new Map();
    for (const range of mergedRanges.slice()) {
      const {
        column
      } = range, {
        element
      } = column;
      if (element) {
        let bounds = boundsMap.get(column);
        if (!bounds) {
          boundsMap.set(column, bounds = Rectangle.from(element, element.parentElement));
        }
        range.left = bounds.left;
        range.width = bounds.width;
      } else {
        this.removeRange(range);
      }
    }
    this.syncDom();
  }
  updateRange(range, force, rows = null) {
    const {
      store,
      rowManager
    } = this.client, {
      topRendered,
      bottomRendered
    } = range, {
      rowOffsetHeight
    } = rowManager;
    let {
      fromIndex,
      toIndex
    } = range, topRow, bottomRow;
    force = rows ? rows.length > 0 : force;
    if (!force && topRendered && bottomRendered) {
      return;
    }
    if (!topRendered || force) {
      if (rows) {
        const index = rows.findIndex((row) => row.dataIndex >= fromIndex);
        topRow = rows[index];
        fromIndex = topRow.dataIndex;
      } else {
        do {
          topRow = rowManager.getRowById(store.getAt(fromIndex));
        } while (!topRow && fromIndex++ < toIndex);
      }
      range.topRendered = fromIndex === range.fromIndex;
      const rowsAbove = fromIndex - range.fromIndex;
      range.top = topRow.top - rowsAbove * (rows ? topRow.offsetHeight : rowOffsetHeight);
    }
    if (!bottomRendered || force) {
      if (rows) {
        const index = rows.findIndex((row) => row.dataIndex === toIndex);
        bottomRow = rows[index === -1 ? rows.length - 1 : index];
        fromIndex = bottomRow.dataIndex;
      } else {
        do {
          bottomRow = rowManager.getRowById(store.getAt(toIndex));
        } while (!bottomRow && toIndex-- > fromIndex);
      }
      range.bottomRendered = toIndex === range.toIndex;
      const rowsBelow = range.toIndex - toIndex;
      range.bottom = bottomRow.bottom + rowsBelow * (rows ? bottomRow.offsetHeight : rowOffsetHeight);
    }
    range.height = range.bottom - range.top;
  }
  getMergeRange(record, column) {
    if (record.isSpecialRow) {
      return;
    }
    const me = this, {
      mergedMap
    } = me, {
      store
    } = me.client, columnId = column.id, index = store.indexOf(record), key = `${index}-@-${columnId}`;
    let range = mergedMap[key];
    if (!range) {
      const value = column.getRawValue(record);
      range = mergedMap[key] = {
        column
      };
      me.mergedRanges.push(range);
      let earlierRecord, earlierValue, earlierIndex = index;
      do {
        earlierRecord = store.getAt(--earlierIndex);
        earlierValue = earlierRecord && column.getRawValue(earlierRecord);
        if (earlierValue === value) {
          mergedMap[`${earlierIndex}-@-${columnId}`] = range;
        }
      } while (earlierRecord && earlierValue === value);
      let laterRecord, laterValue, laterIndex = index;
      do {
        laterRecord = store.getAt(++laterIndex);
        laterValue = laterRecord && column.getRawValue(laterRecord);
        if (laterValue === value) {
          mergedMap[`${laterIndex}-@-${columnId}`] = range;
        }
      } while (laterRecord && laterValue === value);
      range.fromIndex = earlierIndex + 1;
      range.toIndex = laterIndex - 1;
      if (range.toIndex - range.fromIndex > 0) {
        const headerBounds = Rectangle.from(column.element, column.element.parentElement);
        range.left = headerBounds.left;
        range.width = headerBounds.width;
        range.use = true;
      }
    }
    if (!range.element && range.use) {
      me.createRangeElement(range);
    }
    return range;
  }
};
_defineProperty(MergeCells, "$name", "MergeCells");
_defineProperty(MergeCells, "configurable", {
  passthrough: true
});
MergeCells._$name = "MergeCells";
GridFeatureManager.registerFeature(MergeCells);
var QuickFind = class extends InstancePlugin {
  static get $name() {
    return "QuickFind";
  }
  static get pluginConfig() {
    return {
      chain: ["onElementKeyPress", "onCellNavigate"]
    };
  }
  static get properties() {
    return {
      hitCls: "b-quick-hit",
      hitCellCls: "b-quick-hit-cell",
      hitCellBadgeCls: "b-quick-hit-cell-badge",
      hitTextCls: "b-quick-hit-text"
    };
  }
  construct(grid, config) {
    super.construct(grid, config);
    Object.assign(this, {
      grid,
      treeWalker: grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)
    });
  }
  isActionAvailable() {
    const {
      focusedCell
    } = this.grid;
    return !this.disabled && (focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.record) && !focusedCell.isActionable && this.find.length > 0;
  }
  doDisable(disable) {
    if (disable) {
      this.clear();
    }
    super.doDisable(disable);
  }
  get store() {
    return this.grid.store;
  }
  showQuickFind() {
    const me = this, header = me.grid.getHeaderElement(me.columnId);
    if (header) {
      if (!me.headerField) {
        const [element, field, badge] = DomHelper.createElement({
          tag: "div",
          className: "b-quick-hit-header",
          children: [{
            tag: "div",
            className: "b-quick-hit-field"
          }, {
            tag: "div",
            className: "b-quick-hit-badge"
          }]
        }, {
          returnAll: true
        });
        if (me.mode === "header") {
          header.appendChild(element);
        } else {
          element.className += " b-quick-hit-mode-grid";
          me.grid.element.appendChild(element);
        }
        me.headerField = {
          header: element,
          field,
          badge,
          colHeader: header
        };
      }
      me.headerField.field.innerHTML = me.find;
      me.headerField.badge.innerHTML = me.found.length;
      header.classList.add("b-quick-find-header");
      if (!me.renderListenerInitialized) {
        me.grid.rowManager.ion({
          rendercell: me.renderCell,
          thisObj: me
        });
        me.renderListenerInitialized = true;
      }
    }
  }
  hideQuickFind() {
    const me = this, {
      grid,
      headerField
    } = me;
    for (const hit of me.prevFound || me.found) {
      const row = grid.getRowById(hit.id);
      if (row) {
        row.forceInnerHTML = true;
        const cellElement = row.getCell(me.columnId);
        cellElement._content = null;
        row.renderCell(cellElement);
        row.forceInnerHTML = false;
      }
    }
    if (headerField) {
      headerField.header.parentNode.removeChild(headerField.header);
      headerField.colHeader.classList.remove("b-quick-find-header");
      me.headerField = null;
    }
    if (me.renderListenerInitialized) {
      grid.rowManager.un({
        rendercell: me.renderCell
      }, me);
      me.renderListenerInitialized = false;
    }
    grid.trigger("hideQuickFind");
  }
  search(find, columnFieldOrId = this.columnId) {
    const me = this, {
      grid
    } = me, column = grid.columns.getById(columnFieldOrId) || grid.columns.get(columnFieldOrId), found = me.store.findByField(column.field, find, column.mergeCells && column.isSorted);
    let i = 1;
    Object.assign(me, {
      foundMap: {},
      prevFound: me.found,
      found,
      find,
      columnId: column.id,
      findRe: new RegExp(`(\\s+)?(${StringHelper.escapeRegExp(String(find))})(\\s+)?`, "ig")
    });
    if (find) {
      me.showQuickFind();
    } else {
      me.hideQuickFind();
    }
    for (const cellElement of DomHelper.children(grid.element, `.${me.hitCls}`)) {
      cellElement.classList.remove(me.hitCls, me.hitCellCls);
      if (cellElement._originalContent) {
        cellElement.innerHTML = cellElement._originalContent;
        cellElement._originalContent = null;
      }
    }
    if (!found) {
      return;
    }
    if (found.length > 0) {
      me.gotoClosestHit(grid.focusedCell, found);
    }
    for (const hit of found) {
      me.foundMap[hit.id] = i++;
      const row = grid.getRowById(hit.data.id);
      row === null || row === void 0 ? void 0 : row.renderCell(row.getCell(column.id));
      if (i > 1e3) {
        break;
      }
    }
    grid.trigger("quickFind", {
      find,
      found
    });
  }
  clear() {
    var _this$found;
    if (this.find || (_this$found = this.found) !== null && _this$found !== void 0 && _this$found.length) {
      this.search("");
    }
  }
  get foundCount() {
    var _this$found$length, _this$found2;
    return (_this$found$length = (_this$found2 = this.found) === null || _this$found2 === void 0 ? void 0 : _this$found2.length) !== null && _this$found$length !== void 0 ? _this$found$length : 0;
  }
  gotoHit(index) {
    const nextHit = this.found[index];
    if (nextHit) {
      this.grid.focusCell({
        columnId: this.columnId,
        id: nextHit.id
      }, {
        doSelect: true
      });
    }
    return !!nextHit;
  }
  gotoClosestHit(focusedCell, found) {
    const focusedIndex = focusedCell ? this.grid.store.indexOf(focusedCell.id) : 0, foundSorted = found.slice().sort((a, b) => Math.abs(a.index - focusedIndex) - Math.abs(b.index - focusedIndex));
    this.gotoHit(found.indexOf(foundSorted[0]));
  }
  gotoFirstHit() {
    this.gotoHit(0);
  }
  gotoLastHit() {
    this.gotoHit(this.found.length - 1);
  }
  gotoNextHit() {
    var _grid$_focusedCell$id, _grid$_focusedCell, _grid$lastFocusedCell;
    const me = this, {
      grid
    } = me, currentId = (_grid$_focusedCell$id = (_grid$_focusedCell = grid._focusedCell) === null || _grid$_focusedCell === void 0 ? void 0 : _grid$_focusedCell.id) !== null && _grid$_focusedCell$id !== void 0 ? _grid$_focusedCell$id : (_grid$lastFocusedCell = grid.lastFocusedCell) === null || _grid$lastFocusedCell === void 0 ? void 0 : _grid$lastFocusedCell.id, currentIndex = grid.store.indexOf(currentId) || 0, nextHit = me.found.find((hit) => hit.index > currentIndex);
    if (nextHit) {
      grid.focusCell({
        columnId: me.columnId,
        id: nextHit.id
      }, {
        doSelect: true
      });
    } else {
      me.gotoFirstHit();
    }
  }
  gotoPrevHit() {
    var _grid$_focusedCell$id2, _grid$_focusedCell2, _grid$lastFocusedCell2;
    const me = this, {
      grid,
      found
    } = me, currentId = (_grid$_focusedCell$id2 = (_grid$_focusedCell2 = grid._focusedCell) === null || _grid$_focusedCell2 === void 0 ? void 0 : _grid$_focusedCell2.id) !== null && _grid$_focusedCell$id2 !== void 0 ? _grid$_focusedCell$id2 : (_grid$lastFocusedCell2 = grid.lastFocusedCell) === null || _grid$lastFocusedCell2 === void 0 ? void 0 : _grid$lastFocusedCell2.id, currentIndex = grid.store.indexOf(currentId) || 0;
    let prevHit;
    if (!found.length) {
      return;
    }
    for (let i = found.length - 1; i--; i >= 0) {
      if (found[i].index < currentIndex) {
        prevHit = found[i];
        break;
      }
    }
    if (prevHit) {
      grid.focusCell({
        columnId: me.columnId,
        id: prevHit.id
      }, {
        doSelect: true
      });
    } else {
      me.gotoLastHit();
    }
  }
  renderCell({
    cellElement,
    column,
    record
  }) {
    var _me$foundMap;
    const me = this, {
      classList
    } = cellElement, {
      treeWalker,
      findRe,
      hitTextCls
    } = me, hitIndex = me.columnId === column.id && ((_me$foundMap = me.foundMap) === null || _me$foundMap === void 0 ? void 0 : _me$foundMap[record.id]);
    if (hitIndex) {
      classList.add(me.hitCls);
      cellElement.isQuickHit = true;
      cellElement._originalContent = cellElement.innerHTML;
      const inner = treeWalker.currentNode = DomHelper.down(cellElement, ".b-grid-cell-value,.b-tree-cell-value") || cellElement;
      for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode); ) {
        const nodeToReplace = textNode, textContent = textNode.nodeValue, newText = ["<span>"];
        textNode = treeWalker.nextNode();
        let offset = findRe.lastIndex;
        for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {
          const preamble = textContent.substring(offset, match.index), spaceBefore = match[1] ? "\xA0" : "", v = match[2], spaceAfter = match[3] ? "\xA0" : "";
          newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class="${hitTextCls}">${v}</span>${spaceAfter}`);
          offset = findRe.lastIndex;
        }
        newText.push(StringHelper.encodeHtml(textContent.substring(offset)), "</span>");
        nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(""), {
          fragment: true
        }), nodeToReplace);
        nodeToReplace.remove();
      }
      DomHelper.createElement({
        parent: cellElement,
        className: me.hitCellBadgeCls,
        text: hitIndex
      });
    }
  }
  onBackspace(event) {
    const me = this;
    if (me.find) {
      me.find = me.find.substr(0, me.find.length - 1);
      me.search(me.find);
      return true;
    }
    return false;
  }
  clearSearch() {
    if (this.find) {
      this.find = "";
      this.search(this.find);
      return true;
    }
    return false;
  }
  showFilterEditor() {
    const me = this, {
      filter: filter2
    } = me.client.features;
    if (filter2 && me.columnId && me.foundCount) {
      me.clear();
      filter2.showFilterEditor(me.client.columns.getById(me.columnId), me.find);
    }
  }
  onElementKeyPress(event) {
    var _event$key;
    const me = this, {
      grid
    } = me, {
      focusedCell
    } = grid;
    if (!event.handled && !me.disabled && focusedCell !== null && focusedCell !== void 0 && focusedCell.record && !focusedCell.isActionable && ((_event$key = event.key) === null || _event$key === void 0 ? void 0 : _event$key.length) === 1) {
      const column = grid.columns.getById(grid._focusedCell.columnId);
      if (column && column.searchable !== false) {
        me.columnId = grid._focusedCell.columnId;
        me.find += event.key;
        me.search(me.find);
      }
    }
  }
  onCellNavigate(grid, fromCellSelector, toCellSelector) {
    const me = this;
    if (me.find && (!toCellSelector || toCellSelector.columnId !== me.columnId)) {
      me.clear();
    }
  }
};
_defineProperty(QuickFind, "configurable", {
  mode: "header",
  find: "",
  keyMap: {
    F3: "gotoNextHit",
    "Shift+F3": "gotoPrevHit",
    "Ctrl+g": "gotoNextHit",
    "Ctrl+Shift+g": "gotoPrevHit",
    "Ctrl+Shift+f": "showFilterEditor",
    Escape: "clearSearch",
    Backspace: "onBackspace"
  }
});
QuickFind._$name = "QuickFind";
GridFeatureManager.registerFeature(QuickFind);
var RegionResize = class extends InstancePlugin {
  static get pluginConfig() {
    return {
      chain: ["onElementPointerDown", "onElementDblClick", "onElementTouchMove", "onSubGridCollapse", "onSubGridExpand", "render"]
    };
  }
  onElementDblClick(event) {
    const me = this, {
      client
    } = me, splitterEl = event.target.closest(".b-grid-splitter-collapsed");
    if (splitterEl && !me.expanding) {
      me.expanding = true;
      let region = splitterEl.dataset.region, subGrid = client.getSubGrid(region);
      if (!subGrid.collapsed) {
        region = client.getLastRegions()[1];
        subGrid = client.getSubGrid(region);
      }
      subGrid.expand().then(() => me.expanding = false);
    }
  }
  startMove(splitterElement, clientX) {
    const me = this, {
      client
    } = me, region = splitterElement.dataset.region, gridEl = client.element, nextRegion = client.regions[client.regions.indexOf(region) + 1], nextSubGrid = client.getSubGrid(nextRegion), splitterSubGrid = client.getSubGrid(region);
    let subGrid = splitterSubGrid, flip = 1;
    if (subGrid.flex != null) {
      if (nextSubGrid.flex == null) {
        subGrid = nextSubGrid;
        flip = -1;
      }
    }
    if (client.rtl) {
      flip *= -1;
    }
    if (splitterElement.classList.contains("b-grid-splitter-collapsed")) {
      return;
    }
    const availableWidth = subGrid.element.offsetWidth + nextSubGrid.element.offsetWidth;
    me.dragContext = {
      element: splitterElement,
      headerEl: subGrid.header.element,
      subGridEl: subGrid.element,
      subGrid,
      splitterSubGrid,
      originalWidth: subGrid.element.offsetWidth,
      originalX: clientX,
      minWidth: subGrid.minWidth || 0,
      maxWidth: Math.min(availableWidth, subGrid.maxWidth || availableWidth),
      flip
    };
    gridEl.classList.add("b-moving-splitter");
    splitterSubGrid.toggleSplitterCls("b-moving");
    me.pointerDetacher = EventHelper.on({
      element: document,
      pointermove: "onPointerMove",
      pointerup: "onPointerUp",
      thisObj: me
    });
  }
  endMove() {
    const me = this, {
      dragContext
    } = me;
    if (dragContext) {
      me.pointerDetacher();
      me.client.element.classList.remove("b-moving-splitter");
      dragContext.splitterSubGrid.toggleSplitterCls("b-moving", false);
      me.dragContext = null;
    }
  }
  onCollapseClick(subGrid, splitterEl) {
    const me = this, {
      client
    } = me, region = splitterEl.dataset.region, regions = client.getLastRegions();
    if (regions[0] === region) {
      const lastSubGrid = client.getSubGrid(regions[1]);
      if (lastSubGrid.collapsed) {
        lastSubGrid.expand();
        return;
      }
    }
    subGrid.collapse();
  }
  onExpandClick(subGrid, splitterEl) {
    const me = this, {
      client
    } = me, region = splitterEl.dataset.region, regions = client.getLastRegions();
    if (regions[0] === region) {
      if (!subGrid.collapsed) {
        const lastSubGrid = client.getSubGrid(regions[1]);
        lastSubGrid.collapse();
        return;
      }
    }
    subGrid.expand();
  }
  updateMove(newClientX) {
    const {
      dragContext
    } = this;
    if (dragContext) {
      const difX = newClientX - dragContext.originalX, newWidth = Math.max(Math.min(dragContext.maxWidth, dragContext.originalWidth + difX * dragContext.flip), 0);
      dragContext.subGrid.width = Math.max(newWidth, dragContext.minWidth);
    }
  }
  onElementPointerDown(event) {
    const me = this, {
      target
    } = event, splitter = event.button === 0 && target.closest(":not(.b-row-reordering):not(.b-dragging-event):not(.b-dragging-task):not(.b-dragging-header):not(.b-dragselecting) .b-grid-splitter"), subGrid = splitter && me.client.getSubGrid(splitter.dataset.region);
    let toggle;
    if (splitter) {
      if (target.closest(".b-grid-splitter-button-collapse")) {
        me.onCollapseClick(subGrid, splitter);
      } else if (target.closest(".b-grid-splitter-button-expand")) {
        me.onExpandClick(subGrid, splitter);
      } else {
        me.startMove(splitter, event.clientX);
        toggle = splitter;
      }
    }
    if (event.pointerType === "touch") {
      me.toggleTouchSplitter(toggle);
    }
  }
  onPointerMove(event) {
    if (this.dragContext) {
      this.updateMove(event.clientX);
      event.preventDefault();
    }
  }
  onElementTouchMove(event) {
    if (this.dragContext) {
      event.preventDefault();
    }
  }
  onPointerUp(event) {
    if (this.dragContext) {
      this.endMove();
      event.preventDefault();
    }
  }
  onSubGridCollapse({
    subGrid
  }) {
    const splitterEl = this.client.resolveSplitter(subGrid), regions = this.client.getLastRegions();
    if (regions[1] === subGrid.region) {
      splitterEl.classList.add("b-grid-splitter-allow-collapse");
    }
  }
  onSubGridExpand({
    subGrid
  }) {
    const splitterEl = this.client.resolveSplitter(subGrid);
    splitterEl.classList.remove("b-grid-splitter-allow-collapse");
  }
  toggleTouchSplitter(splitterElement) {
    const me = this, {
      touchedSplitter
    } = me;
    if (splitterElement && touchedSplitter && splitterElement.dataset.region !== touchedSplitter.dataset.region) {
      me.toggleTouchSplitter();
    }
    const splitterSubGrid = me.client.getSubGrid(splitterElement ? splitterElement.dataset.region : touchedSplitter === null || touchedSplitter === void 0 ? void 0 : touchedSplitter.dataset.region);
    if (splitterSubGrid) {
      splitterSubGrid.toggleSplitterCls("b-touching", Boolean(splitterElement));
      if (splitterElement) {
        splitterSubGrid.startSplitterButtonSyncing();
      } else {
        splitterSubGrid.stopSplitterButtonSyncing();
      }
    }
    me.touchedSplitter = splitterElement;
  }
  render() {
    const {
      regions,
      subGrids
    } = this.client;
    if (regions.length > 2) {
      subGrids[regions[0]].splitterElement.classList.add("b-left-only");
      subGrids[regions[1]].splitterElement.classList.add("b-right-only");
    }
  }
};
_defineProperty(RegionResize, "$name", "RegionResize");
RegionResize.featureClass = "b-split";
RegionResize._$name = "RegionResize";
GridFeatureManager.registerFeature(RegionResize);
var RowCopyPaste = class extends InstancePlugin {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "entityName", "row");
  }
  construct(grid, config) {
    super.construct(grid, config);
    grid.rowManager.ion({
      beforeRenderRow: "onBeforeRenderRow",
      thisObj: this
    });
    this.grid = grid;
  }
  onBeforeRenderRow({
    row,
    record
  }) {
    row.cls["b-cut-row"] = this._isCut && this.clipboardRecords.includes(record);
  }
  isActionAvailable(key, action, event) {
    var _grid$selectedRecords;
    const {
      grid
    } = this, {
      cellEdit
    } = grid.features, {
      target
    } = event;
    return !this.disabled && globalThis.getSelection().toString().length === 0 && (!cellEdit || !cellEdit.isEditing) && ((_grid$selectedRecords = grid.selectedRecords) === null || _grid$selectedRecords === void 0 ? void 0 : _grid$selectedRecords.length) > 0 && (!target || Boolean(target.closest(".b-gridbase:not(.b-schedulerbase) .b-grid-subgrid,.b-grid-subgrid:not(.b-timeaxissubgrid)")));
  }
  copy() {
    this.copyRows();
  }
  cut() {
    this.copyRows(true);
  }
  paste(referenceRecord) {
    this.pasteRows(referenceRecord !== null && referenceRecord !== void 0 && referenceRecord.isModel ? referenceRecord : null);
  }
  copyRows(isCut = false) {
    const me = this, {
      client,
      entityName
    } = me, records = me.selectedRecords.filter((r) => !r.readOnly || !isCut);
    if (!records.length || client.readOnly || client.trigger("beforeCopy", {
      records,
      isCut,
      entityName
    }) === false) {
      return;
    }
    me._isCut = isCut;
    me.clipboardRecords.forEach((rec) => {
      var _client$rowManager$ge;
      return (_client$rowManager$ge = client.rowManager.getRowById(rec)) === null || _client$rowManager$ge === void 0 ? void 0 : _client$rowManager$ge.removeCls("b-cut-row");
    });
    me.clipboardRecords = records.slice();
    client.store.forEach((rec) => {
      rec.meta.isCut = me._isCut && me.clipboardRecords.includes(rec);
    });
    records.forEach((record) => this.onRowCutOrCopy(record, isCut));
    client.trigger("copy", {
      records,
      isCut,
      entityName
    });
  }
  onRowCutOrCopy(record, isCut) {
    var _this$client$rowManag;
    (_this$client$rowManag = this.client.rowManager.getRowById(record)) === null || _this$client$rowManag === void 0 ? void 0 : _this$client$rowManag.toggleCls("b-cut-row", isCut);
  }
  pasteRows(record) {
    var _client$getRowFor, _client$getRowFor$cel;
    const me = this, records = me.clipboardRecords, {
      client,
      entityName
    } = me, {
      store
    } = client, referenceRecord = record || client.selectedRecord;
    if (client.readOnly || client.isTreeGrouped || !records.length || store.tree && me._isCut && records.some((rec) => rec.contains(referenceRecord, true)) || client.trigger("beforePaste", {
      records,
      referenceRecord,
      isCut: me._isCut,
      entityName
    }) === false) {
      return [];
    }
    me.sortByIndex(records);
    const idMap = {}, recordsToProcess = me.extractParents(records, idMap);
    me.insertCopiedRecords(recordsToProcess, referenceRecord);
    if (me._isCut) {
      me.clearClipboard();
    } else {
      client.selectedRecords = recordsToProcess;
    }
    client.trigger("paste", {
      records: recordsToProcess,
      originalRecords: records,
      isCut: me._isCut,
      referenceRecord,
      entityName
    });
    (_client$getRowFor = client.getRowFor(recordsToProcess[recordsToProcess.length - 1])) === null || _client$getRowFor === void 0 ? void 0 : (_client$getRowFor$cel = _client$getRowFor.cells) === null || _client$getRowFor$cel === void 0 ? void 0 : _client$getRowFor$cel[0].focus();
    return recordsToProcess;
  }
  clearClipboard() {
    if (this._isCut) {
      this.clipboardRecords.forEach((rec) => {
        var _this$client$rowManag2;
        return (_this$client$rowManag2 = this.client.rowManager.getRowById(rec)) === null || _this$client$rowManag2 === void 0 ? void 0 : _this$client$rowManag2.removeCls("b-cut-row");
      });
    }
    this._isCut = false;
    this.clipboardRecords = [];
  }
  generateNewName(record) {
    const originalName = record[this.nameField];
    let counter = 2;
    while (this.client.store.findRecord(this.nameField, `${originalName} - ${counter}`)) {
      counter++;
    }
    return `${originalName} - ${counter}`;
  }
  insertCopiedRecords(toInsert, recordReference) {
    const {
      store
    } = this.client, insertAt = store.indexOf(recordReference) + 1;
    if (store.tree) {
      return recordReference.parent.insertChild(toInsert, recordReference.nextSibling, false, {
        orderedBeforeNode: recordReference.nextOrderedSibling
      });
    } else if (this._isCut) {
      store.move(toInsert, store.getAt(insertAt));
    } else {
      return store.insert(insertAt, toInsert);
    }
  }
  get selectedRecords() {
    const records = [...this.client.selectedRecords];
    this.client.selectedCells.forEach((cell) => {
      if (!records.includes(cell.record)) {
        records.push(cell.record);
      }
    });
    return records;
  }
  getMenuItemText(action) {
    var _me$client$features$c;
    const me = this;
    let text = me[action + "RecordText"];
    if (((_me$client$features$c = me.client.features.cellCopyPaste) === null || _me$client$features$c === void 0 ? void 0 : _me$client$features$c.enabled) === true && me.client.selectedCells.length) {
      text += ` (${me.selectedRecords.length > 1 ? me.rowSpecifierTextPlural : me.rowSpecifierText})`;
    }
    return text;
  }
  populateCellMenu({
    record,
    items: items2
  }) {
    const me = this, {
      client
    } = me;
    if (!client.readOnly && !client.isTreeGrouped && (record === null || record === void 0 ? void 0 : record.isSpecialRow) === false && me.selectedRecords.length) {
      items2.cut = {
        text: me.getMenuItemText("cut"),
        localeClass: me,
        icon: "b-icon b-icon-cut",
        weight: 135,
        disabled: record.readOnly,
        onItem: () => me.cut()
      };
      items2.copy = {
        text: me.getMenuItemText("copy"),
        localeClass: me,
        cls: "b-separator",
        icon: "b-icon b-icon-copy",
        weight: 120,
        onItem: () => me.copy()
      };
      items2.paste = {
        text: me.getMenuItemText("paste"),
        localeClass: me,
        icon: "b-icon b-icon-paste",
        weight: 140,
        disabled: !me.clipboardRecords.length,
        onItem: () => me.paste(record)
      };
    }
  }
  sortByIndex(array) {
    const {
      store
    } = this.client;
    return array.sort((rec1, rec2) => {
      const idx1 = rec1.indexPath, idx2 = rec2.indexPath;
      if (!array.includes(rec1.parent) && !array.includes(rec2.parent)) {
        return store.indexOf(rec1) - store.indexOf(rec2);
      }
      if (idx1.length === idx2.length) {
        for (let i = 0; i < idx1.length; i++) {
          if (idx1[i] < idx2[i]) {
            return -1;
          }
          if (idx1[i] > idx2[i]) {
            return 1;
          }
        }
        return 0;
      } else {
        return idx1.length - idx2.length;
      }
    });
  }
  extractParents(taskRecords, idMap) {
    const me = this, {
      client,
      _isCut: isCut
    } = me;
    if (client.store.tree) {
      taskRecords.forEach((node) => {
        node.traverse((n) => {
          const parents = n.getTopParent(true);
          if (!taskRecords.includes(n) && (!isCut || !taskRecords.some((rec) => parents.includes(rec)))) {
            taskRecords.push(n);
          }
        });
      });
    }
    const result = taskRecords.reduce((parents, node) => {
      let copy;
      const parentId = node.parentId || node.meta.modified;
      if (isCut) {
        copy = node;
        copy.meta.isCut = false;
      } else {
        copy = node.copy();
        copy[me.nameField] = me.generateNewName(copy);
        if (node.expanded) {
          copy.data.expanded = node.expanded;
        }
      }
      idMap[node.id] = copy;
      if (node.parent === client.store.rootNode) {
        parents.push(copy);
      } else if (parentId in idMap) {
        idMap[parentId].appendChild(copy);
      } else {
        parents.push(copy);
      }
      return parents;
    }, []);
    result.forEach((parent) => {
      parent.sortOrderedChildren(true, true);
    });
    return result;
  }
};
_defineProperty(RowCopyPaste, "$name", "RowCopyPaste");
_defineProperty(RowCopyPaste, "type", "rowCopyPaste");
_defineProperty(RowCopyPaste, "pluginConfig", {
  assign: ["copyRows", "pasteRows"],
  chain: ["populateCellMenu"]
});
_defineProperty(RowCopyPaste, "properties", {
  clipboardRecords: []
});
_defineProperty(RowCopyPaste, "configurable", {
  nameField: "name",
  keyMap: {
    "Ctrl+C": "copy",
    "Ctrl+X": "cut",
    "Ctrl+V": "paste"
  },
  copyRecordText: "L{copyRecord}",
  cutRecordText: "L{cutRecord}",
  pasteRecordText: "L{pasteRecord}",
  rowSpecifierText: "L{row}",
  rowSpecifierTextPlural: "L{rows}",
  localizableProperties: ["copyRecordText", "cutRecordText", "pasteRecordText", "rowSpecifierText", "rowSpecifierTextPlural"]
});
RowCopyPaste.featureClass = "b-row-copypaste";
RowCopyPaste._$name = "RowCopyPaste";
GridFeatureManager.registerFeature(RowCopyPaste, true, "Grid");
GridFeatureManager.registerFeature(RowCopyPaste, false, "Gantt");
GridFeatureManager.registerFeature(RowCopyPaste, false, "SchedulerPro");
GridFeatureManager.registerFeature(RowCopyPaste, false, "ResourceHistogram");
var storeRemoveActions = {
  remove: 1,
  filter: 1,
  dataset: 1,
  replace: 1
};
var RowExpander = class extends InstancePlugin {
  static get properties() {
    return {
      expanderBodyClass: "b-rowexpander-body",
      expandedRowClass: "b-rowexpander-row-expanded",
      recordStateMap: /* @__PURE__ */ new Map(),
      collapsingRecords: /* @__PURE__ */ new Set()
    };
  }
  static get pluginConfig() {
    return {
      chain: ["afterColumnsChange", "beforeRenderRow", "processRowHeight", "bindStore"],
      override: ["onGridBodyFocusIn"]
    };
  }
  afterConstruct() {
    const me = this, {
      client
    } = me;
    if (!me.renderer) {
      console.warn("RowExpander requires implementing the renderer function.");
      return;
    }
    if (client.isGanttBase && client.fixedRowHeight !== false) {
      console.warn("When using RowExpander on a Gantt, the Gantt`s fixedRowHeight config must be set to false.");
    }
    me.bindStore(client.store);
    if (me.triggerEvent) {
      client.ion({
        [me.triggerEvent]: "onTriggerEvent",
        thisObj: me
      });
    }
    me.addColumn();
  }
  bindStore(store) {
    const me = this;
    me.recordStateMap.clear();
    me.collapsingRecords.clear();
    me.detachListeners("clientStoreChange");
    store.ion({
      name: "clientStoreChange",
      change: me.onStoreChange,
      thisObj: me
    });
  }
  doDisable(disable) {
    const {
      client
    } = this;
    if (disable) {
      this.recordStateMap.clear();
      this.collapsingRecords.clear();
    }
    if (!client.isConfiguring) {
      client.rowManager.renderFromRow();
    }
    super.doDisable(disable);
  }
  changeLoadingIndicatorText(text) {
    return text ? this.L(text) : text;
  }
  onGridBodyFocusIn(event) {
    var _this$client$lastMous, _this$client$lastMous2;
    if (!((_this$client$lastMous = this.client.lastMousedownEvent) !== null && _this$client$lastMous !== void 0 && (_this$client$lastMous2 = _this$client$lastMous.target) !== null && _this$client$lastMous2 !== void 0 && _this$client$lastMous2.closest(".b-rowexpander-body"))) {
      this.overridden.onGridBodyFocusIn(event);
    }
  }
  get isAnimating() {
    return this.client.isAnimating;
  }
  set isAnimating(value) {
    const {
      client
    } = this, wasAnimating = client.isAnimating;
    client.isAnimating = value;
    if (client.isAnimating !== wasAnimating) {
      client.element.classList.toggle("b-rowexpander-animating");
    }
  }
  afterColumnsChange() {
    this.addColumn();
  }
  changeColumn(config) {
    if (config == null) {
      return config;
    }
    return _objectSpread2(_objectSpread2({
      type: "action",
      actions: [{
        cls: "b-icon b-icon-collapse-down",
        tooltip: ({
          record
        }) => this.L(this.recordStateMap.has(record) ? "L{RowExpander.collapse}" : "L{RowExpander.expand}"),
        onClick: ({
          record
        }) => this.toggleExpand(record)
      }],
      width: 40,
      hideable: false,
      align: "center",
      region: this.client.regions[0]
    }, config), {}, {
      field: "expanderActionColumn"
    });
  }
  addColumn() {
    const me = this, {
      column
    } = me, {
      columns
    } = me.client;
    if (!me._isAddingExpanderColumn && column && (!me._expander || !columns.includes(me._expander))) {
      me._isAddingExpanderColumn = true;
      if (me.columnPosition === "last") {
        [me._expander] = columns.add(column);
      } else {
        [me._expander] = columns.insert(0, column);
      }
      me._isAddingExpanderColumn = false;
    }
  }
  onTriggerEvent({
    target
  }) {
    if (this.disabled || target !== null && target !== void 0 && target.closest(".b-action-cell") || !target.closest(".b-grid-cell")) {
      return;
    }
    this.toggleExpand(this.client.getRecordFromElement(target));
  }
  toggleExpand(record) {
    if (record) {
      if (this.recordStateMap.has(record)) {
        this.collapse(record);
      } else {
        this.expand(record);
      }
    }
  }
  onStoreChange({
    action,
    source,
    records
  }) {
    const me = this, {
      recordStateMap,
      collapsingRecords
    } = me;
    if (me.disabled) {
      return;
    }
    if (action === "removeAll") {
      recordStateMap.clear();
      collapsingRecords.clear();
    } else if (storeRemoveActions[action]) {
      for (const [record] of recordStateMap) {
        if (!source.includes(record)) {
          recordStateMap.delete(record);
          collapsingRecords.delete(record);
        }
      }
    } else if (me.refreshOnRecordChange && records !== null && records !== void 0 && records.length) {
      if (action === "update") {
        const recordState = recordStateMap.get(records[0]);
        if (recordState !== null && recordState !== void 0 && recordState.isCreated) {
          recordState.isCreated = false;
          me.client.rowManager.renderFromRecord(records[0]);
        }
      } else if (action === "updatemultiple") {
        let topRecordIndex, topRecord;
        for (const rec of records) {
          const recordState = recordStateMap.get(rec);
          if (recordState !== null && recordState !== void 0 && recordState.isCreated) {
            recordState.isCreated = false;
            const index = source.records.indexOf(rec);
            if (!topRecord || topRecordIndex > index) {
              topRecordIndex = index;
              topRecord = rec;
            }
          }
        }
        if (topRecord) {
          me.client.rowManager.renderFromRecord(topRecord);
        }
      }
    }
  }
  processRowHeight(record, height) {
    var _recordState$expander;
    const recordState = this.recordStateMap.get(record);
    if (recordState) {
      if (!recordState.isCreated && recordState.isRenderingAsync) {
        return this.loadingIndicatorHeight + height;
      }
      if (!recordState.expanderBodyHeight) {
        for (const region of this.client.regions) {
          const height2 = recordState.expandElements[region].offsetHeight;
          if (height2 > recordState.expanderBodyHeight) {
            recordState.expanderBodyHeight = height2;
          }
        }
      }
    }
    return ((_recordState$expander = recordState === null || recordState === void 0 ? void 0 : recordState.expanderBodyHeight) !== null && _recordState$expander !== void 0 ? _recordState$expander : 0) + height;
  }
  beforeRenderRow({
    row,
    record
  }) {
    const me = this, {
      regions
    } = me.client, {
      expandedRowClass
    } = me;
    row.cls.toggle("b-rowexpander-disabled", me.disabled);
    if (row.cls[expandedRowClass]) {
      if (me.enableAnimations && me.isAnimating && me.collapsingRecords.has(record)) {
        me.waitForTransition(row, () => {
          if (me.collapsingRecords.has(record)) {
            me.removeExpander(row);
          }
        });
      } else {
        me.removeExpander(row);
      }
    } else {
      me.collapsingRecords.delete(record);
    }
    const recordState = me.recordStateMap.get(record);
    if (!me.disabled && recordState) {
      if (!recordState.isCreated) {
        me.renderExpander(record, row, recordState);
      }
      row.cls.add(expandedRowClass);
      for (const region of regions) {
        const rowElement = row.getElement(region);
        if (recordState.isCreated) {
          rowElement.appendChild(recordState.expandElements[region]);
        } else {
          me.renderLoadingIndicator(rowElement, recordState);
        }
        me.lockCellHeight(rowElement, recordState.cellHeight, false);
      }
      if (me._shouldScrollIntoView) {
        me._shouldScrollIntoView = false;
        if (!DomHelper.isInView(recordState.expandElements[regions[0]], true)) {
          me.client.rowManager.ion({
            once: true,
            thisObj: me,
            renderDone: () => me.scrollRowIntoView(row, record)
          });
        }
      }
    }
  }
  scrollRowIntoView(row, record) {
    if (this.isAnimating) {
      this.waitForTransition(row, () => this.client.scrollRowIntoView(record));
    } else {
      this.client.scrollRowIntoView(record);
    }
  }
  waitForTransition(row, fn2) {
    EventHelper.onTransitionEnd({
      element: row.element,
      property: "height",
      handler: fn2,
      thisObj: this
    });
  }
  removeExpander(row) {
    row.cls.remove(this.expandedRowClass);
    for (const region of this.client.regions) {
      const rowElement = row.getElement(region);
      rowElement.classList.remove(this.expandedRowClass);
      DomHelper.removeEachSelector(rowElement, "." + this.expanderBodyClass);
      this.lockCellHeight(rowElement, null, false);
    }
  }
  renderLoadingIndicator(rowElement, recordState) {
    DomHelper.createElement({
      parent: rowElement,
      className: this.expanderBodyClass + " b-rowexpander-loading",
      style: {
        top: recordState.cellHeight,
        height: this.loadingIndicatorHeight
      },
      children: [{
        tag: "i",
        className: "b-icon b-icon-spinner"
      }, this.loadingIndicatorText]
    });
  }
  renderExpander(record, row, recordState) {
    var _row$cells$;
    const me = this, cellHeight = (_row$cells$ = row.cells[0]) === null || _row$cells$ === void 0 ? void 0 : _row$cells$.offsetHeight, expandElements = {}, renderings = [], continueRendering = (content, expanderElement, region) => {
      if (content != null) {
        if (typeof content === "string") {
          expanderElement.innerHTML = content;
        } else {
          content = DomHelper.createElement(content);
          expanderElement.appendChild(content);
        }
      }
      expandElements[region] = expanderElement;
    };
    if (recordState.isRenderingAsync) {
      return;
    }
    Object.assign(recordState, {
      cellHeight,
      expandElements,
      expanderBodyHeight: 0
    });
    for (const region of me.client.regions) {
      const rowElement = row.getElement(region);
      row.addCls(me.expandedRowClass);
      const expanderElement = DomHelper.createElement({
        parent: rowElement,
        className: me.expanderBodyClass,
        style: {
          top: cellHeight + "px"
        }
      });
      const renderResponse = me.renderer({
        record,
        expanderElement,
        rowElement,
        region
      });
      if (Objects.isPromise(renderResponse)) {
        renderings.push(renderResponse.then((content) => continueRendering(content, expanderElement, region)));
      } else {
        continueRendering(renderResponse, expanderElement, region);
      }
    }
    if (renderings.length) {
      recordState.isRenderingAsync = true;
      Promise.all(renderings).then(() => {
        var _me$renderRowsWithAni;
        recordState.isCreated = true;
        (_me$renderRowsWithAni = me.renderRowsWithAnimation) === null || _me$renderRowsWithAni === void 0 ? void 0 : _me$renderRowsWithAni.call(me, record);
        recordState.isRenderingAsync = false;
      });
    } else {
      recordState.isCreated = true;
    }
  }
  renderRowsWithAnimation(record) {
    const me = this;
    if (me.enableAnimations) {
      const row = me.client.rowManager.getRowById(record);
      if (row) {
        me.isAnimating = true;
        if (me.collapsingRecords.has(record)) {
          row.addCls("b-row-is-collapsing");
        }
        me.waitForTransition(row, () => {
          me.isAnimating = false;
          if (!row.isDestroyed) {
            var _row$removeCls;
            (_row$removeCls = row.removeCls) === null || _row$removeCls === void 0 ? void 0 : _row$removeCls.call(row, "b-row-is-collapsing");
          }
        });
      }
    }
    me.client.rowManager.renderFromRecord(record);
  }
  lockCellHeight(rowElement, cellHeight, unlock) {
    for (let a = 0; a < rowElement.children.length; a++) {
      const child = rowElement.children[a];
      if (!child.classList.contains(this.expanderBodyClass)) {
        child.style.height = unlock ? "" : cellHeight + "px";
      }
    }
  }
  async expand(record) {
    const me = this;
    if (me.disabled) {
      return;
    }
    if (await me.trigger("beforeExpand", {
      record
    }) === false) {
      return;
    }
    me.recordStateMap.set(record, {
      isCreated: false
    });
    me.collapsingRecords.delete(record);
    me._shouldScrollIntoView = true;
    me.renderRowsWithAnimation(record);
  }
  async collapse(record) {
    const me = this;
    if (me.disabled) {
      return;
    }
    if (await me.trigger("beforeCollapse", {
      record
    }) === false) {
      return;
    }
    me.recordStateMap.delete(record);
    me.collapsingRecords.add(record);
    me.renderRowsWithAnimation(record);
  }
};
_defineProperty(RowExpander, "$name", "RowExpander");
_defineProperty(RowExpander, "configurable", {
  renderer: null,
  triggerEvent: null,
  column: {},
  columnPosition: "first",
  refreshOnRecordChange: false,
  loadingIndicatorHeight: 100,
  loadingIndicatorText: "L{loading}",
  enableAnimations: true
});
RowExpander._$name = "RowExpander";
GridFeatureManager.registerFeature(RowExpander);
var RowReorder = class extends Delayable(InstancePlugin) {
  construct(grid, config) {
    this.grid = grid;
    super.construct(...arguments);
  }
  doDestroy() {
    var _this$dragHelper;
    (_this$dragHelper = this.dragHelper) === null || _this$dragHelper === void 0 ? void 0 : _this$dragHelper.destroy();
    super.doDestroy();
  }
  init() {
    const me = this, {
      grid
    } = me;
    me.dragHelper = DragHelper.new({
      name: "rowReorder",
      cloneTarget: true,
      dragThreshold: 10,
      proxyTopOffset: 10,
      targetSelector: ".b-grid-row",
      lockX: true,
      dragWithin: grid.bodyContainer,
      allowDropOutside: true,
      scrollManager: grid.scrollManager,
      outerElement: me.targetSubGridElement,
      touchStartDelay: me.touchStartDelay,
      isElementDraggable: me.isElementDraggable.bind(me),
      monitoringConfig: {
        scrollables: [{
          element: grid.scrollable.element,
          direction: "vertical"
        }]
      },
      setXY(element, x, y) {
        const {
          context
        } = this;
        if (!context.started) {
          const elementRect = Rectangle.from(context.element, this.dragWithin), pointerDownOffset = context.startPageY - window.pageYOffset - context.element.getBoundingClientRect().top;
          y = elementRect.top + pointerDownOffset + this.proxyTopOffset;
        }
        DomHelper.setTranslateXY(element, x, y);
      },
      ignoreSamePositionDrop: false,
      createProxy(element) {
        const clone = element.cloneNode(true), container = document.createElement("div");
        container.classList.add("b-row-reorder-proxy");
        clone.removeAttribute("id");
        clone.style.transform = "";
        container.appendChild(clone);
        if (grid.selectedRecords.length > 1) {
          const clone2 = clone.cloneNode(true);
          clone2.classList.add("b-row-dragging-multiple");
          container.appendChild(clone2);
        }
        DomHelper.removeClsGlobally(container, "b-selected", "b-hover", "b-focused");
        return container;
      },
      internalListeners: {
        beforedragstart: "onBeforeDragStart",
        dragstart: "onDragStart",
        drag: "onDrag",
        drop: "onDrop",
        reset: "onReset",
        prio: 1e4,
        thisObj: me
      }
    }, me.dragHelperConfig);
    me.relayEvents(me.dragHelper, ["beforeDragStart", "dragStart", "drag", "abort"], "gridRow");
    me.dropIndicator = DomHelper.createElement({
      className: "b-row-drop-indicator"
    });
    me.dropOverTargetCls = ["b-row-reordering-target", "b-hover"];
  }
  get targetSubGridElement() {
    const targetSubGrid = this.grid.regions[0];
    return this.grid.subGrids[targetSubGrid].element;
  }
  isElementDraggable(el, event) {
    if (!el.closest(".b-grid-cell .b-widget")) {
      if (this.gripOnly) {
        const firstCell = el.closest(".b-grid-cell:first-child");
        if (firstCell) {
          const gripperStyle = getComputedStyle(firstCell, ":before"), offsetX = this.grid.rtl ? firstCell.getBoundingClientRect().width - event.borderOffsetX : event.borderOffsetX;
          return DomHelper.roundPx(offsetX) <= DomHelper.roundPx(parseFloat(gripperStyle.width));
        }
      } else {
        return true;
      }
    }
  }
  onBeforeDragStart({
    event,
    source,
    context
  }) {
    const me = this, {
      grid
    } = me, subGridEl = me.targetSubGridElement;
    if (me.disabled || grid.readOnly || grid.isTreeGrouped || !subGridEl.contains(context.element)) {
      return false;
    }
    const startRecord = context.startRecord = grid.getRecordFromElement(context.element);
    if (startRecord.readOnly || startRecord.isSpecialRow) {
      return false;
    }
    context.originalRowTop = grid.rowManager.getRowFor(startRecord).top;
    if (!grid.selectionMode.checkboxOnly) {
      if (source.startEvent.pointerType === "touch") {
        if (!grid.isSelected(startRecord)) {
          grid.selectRow({
            record: startRecord,
            addToSelection: false
          });
        }
      } else if (!grid.isSelected(startRecord) && !event.shiftKey && !event.ctrlKey) {
        grid.selectRow({
          record: startRecord
        });
      }
    }
    const selectedRecords = grid.selectedRecords.filter((r) => !r.readOnly);
    context.records = [startRecord];
    if (selectedRecords.includes(startRecord)) {
      context.records.push(...selectedRecords.filter((r) => r !== startRecord));
      context.records.sort((r1, r2) => grid.store.indexOf(r1) - grid.store.indexOf(r2));
    }
    return true;
  }
  onDragStart({
    context
  }) {
    var _cellMenu$hideContext, _headerMenu$hideConte;
    const me = this, {
      grid
    } = me, {
      cellEdit,
      cellMenu,
      headerMenu
    } = grid.features;
    if (cellEdit) {
      me.cellEditDisabledState = cellEdit.disabled;
      cellEdit.disabled = true;
    }
    cellMenu === null || cellMenu === void 0 ? void 0 : (_cellMenu$hideContext = cellMenu.hideContextMenu) === null || _cellMenu$hideContext === void 0 ? void 0 : _cellMenu$hideContext.call(cellMenu, false);
    headerMenu === null || headerMenu === void 0 ? void 0 : (_headerMenu$hideConte = headerMenu.hideContextMenu) === null || _headerMenu$hideConte === void 0 ? void 0 : _headerMenu$hideConte.call(headerMenu, false);
    grid.element.classList.add("b-row-reordering");
    const focusedCell = context.element.querySelector(".b-focused");
    focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.classList.remove("b-focused");
    context.element.firstElementChild.classList.remove("b-selected", "b-hover");
    grid.bodyContainer.appendChild(me.dropIndicator);
  }
  onDrag({
    context,
    event
  }) {
    const me = this, {
      grid
    } = me, {
      store,
      rowManager
    } = grid, {
      clientY
    } = event;
    let valid = true, row = rowManager.getRowAt(clientY), overRecord, dataIndex, after, over, insertBefore;
    if (row) {
      const rowTop = row.top + grid._bodyRectangle.y - grid.scrollable.y, quarter = row.height / 4, topQuarter = rowTop + quarter, middleY = rowTop + row.height / 2, bottomQuarter = rowTop + quarter * 3;
      dataIndex = row.dataIndex;
      overRecord = store.getAt(dataIndex);
      if (store.tree) {
        over = (overRecord.isParent || me.dropOnLeaf) && clientY > topQuarter && clientY < bottomQuarter;
      } else if (store.isGrouped) {
        over = overRecord.isGroupHeader && overRecord.meta.collapsed;
      }
      after = !over && event.clientY >= middleY;
    } else {
      if (event.pageY < grid._bodyRectangle.y) {
        dataIndex = 0;
        overRecord = store.first;
        after = false;
      } else {
        dataIndex = store.count - 1;
        overRecord = store.last;
        after = true;
      }
      row = grid.rowManager.getRow(dataIndex);
    }
    if (overRecord === me.overRecord && me.after === after && me.over === over) {
      context.valid = me.reorderValid;
      return;
    }
    if (me.overRecord !== overRecord) {
      var _rowManager$getRowByI;
      (_rowManager$getRowByI = rowManager.getRowById(me.overRecord)) === null || _rowManager$getRowByI === void 0 ? void 0 : _rowManager$getRowByI.removeCls(me.dropOverTargetCls);
    }
    me.overRecord = overRecord;
    me.after = after;
    me.over = over;
    if (overRecord === context.startRecord || !after && !over && dataIndex === 0 && store.isGrouped || after && overRecord.isGroupHeader && overRecord.meta.collapsed && store.indexOf(overRecord) === store.count - 1) {
      valid = false;
    }
    if (store.tree) {
      insertBefore = after ? overRecord.nextSibling : overRecord;
      if (context.records.some((rec) => rec.contains(overRecord))) {
        valid = false;
      }
      context.parent = valid && over ? overRecord : overRecord.parent;
      me.clearTimeout(me.hoverTimer);
      if (overRecord && overRecord.isParent && !overRecord.isExpanded(store)) {
        me.hoverTimer = me.setTimeout(() => grid.expand(overRecord), me.hoverExpandTimeout);
      }
    } else {
      insertBefore = after ? store.getAt(dataIndex + 1) : overRecord;
    }
    row.toggleCls(me.dropOverTargetCls, valid && over);
    if (!over && dataIndex === store.indexOf(context.startRecord) + (after ? -1 : 1) && context.parent && context.startRecord.parent === context.parent) {
      valid = false;
    }
    row && DomHelper.setTranslateY(me.dropIndicator, Math.max(row.top + (after ? row.element.getBoundingClientRect().height : 0), 1));
    me.dropIndicator.style.visibility = over ? "hidden" : "visible";
    me.dropIndicator.classList.toggle("b-drag-invalid", !valid);
    context.insertBefore = insertBefore;
    context.valid = me.reorderValid = valid;
  }
  async onDrop(event) {
    const me = this, {
      context
    } = event;
    context.valid = context.valid && me.reorderValid;
    if (context.valid) {
      context.async = true;
      if (me.client.store.tree) {
        context.oldPositionContext = context.records.map((record) => {
          var _record$parent;
          return {
            record,
            parentId: (_record$parent = record.parent) === null || _record$parent === void 0 ? void 0 : _record$parent.id,
            parentIndex: record.parentIndex
          };
        });
      }
      const result = await me.trigger("gridRowBeforeDropFinalize", event);
      if (result === false) {
        context.valid = false;
      }
      await me.dragHelper.animateProxyTo(me.dropIndicator, {
        align: "l0-l0"
      });
      await me.finalizeReorder(context);
    }
    me.clearTimeout(me.hoverTimer);
    me.overRecord = me.after = me.over = null;
    me.trigger("gridRowDrop", event);
  }
  async finalizeReorder(context) {
    const me = this, {
      grid
    } = me, {
      store,
      focusedCell
    } = grid;
    let {
      records
    } = context;
    context.valid = context.valid && !records.some((rec) => !store.includes(rec));
    if (context.valid) {
      let result;
      if (store.tree) {
        var _context$parent$child, _context$parent$child2;
        records = records.filter((record) => !record.parent || record.bubbleWhile((parent) => !records.includes(parent), true));
        result = await context.parent.tryInsertChild(records, me.over ? (_context$parent$child = context.parent.children) === null || _context$parent$child === void 0 ? void 0 : _context$parent$child[0] : context.insertBefore);
        grid.rowManager.forEach((r) => r.removeCls(me.dropOverTargetCls));
        if (!context.parent.isExpanded() && (_context$parent$child2 = context.parent.children) !== null && _context$parent$child2 !== void 0 && _context$parent$child2.length) {
          grid.expand(context.parent);
        }
        context.valid = result !== false;
      } else if (store.isGrouped && me.over) {
        store.move(records, store.getAt(store.indexOf(context.insertBefore) + 1));
      } else {
        store.move(records, context.insertBefore);
      }
      if ((focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell._rowIndex) >= 0) {
        grid._focusedCell = null;
        grid.focusCell({
          grid,
          record: focusedCell.record,
          columnId: focusedCell.columnId
        });
      }
      store.clearSorters();
    }
    context.finalize(context.valid);
    grid.element.classList.remove("b-row-reordering");
  }
  onReset() {
    const me = this, {
      grid
    } = me, cellEdit = grid.features.cellEdit;
    grid.element.classList.remove("b-row-reordering");
    if (cellEdit) {
      cellEdit.disabled = me.cellEditDisabledState;
    }
    me.dropIndicator.remove();
    DomHelper.removeClsGlobally(grid.element, ...me.dropOverTargetCls);
  }
  onPaint({
    firstPaint
  }) {
    if (firstPaint) {
      this.init();
    }
  }
  updateShowGrip(show) {
    this.grid.element.classList.toggle("b-row-reorder-with-grip", show);
  }
};
_defineProperty(RowReorder, "$name", "RowReorder");
_defineProperty(RowReorder, "configurable", {
  showGrip: null,
  gripOnly: null,
  hoverExpandTimeout: 1e3,
  touchStartDelay: 300,
  dropOnLeaf: false,
  dragHelperConfig: null
});
_defineProperty(RowReorder, "pluginConfig", {
  after: ["onPaint"]
});
RowReorder.featureClass = "";
RowReorder._$name = "RowReorder";
GridFeatureManager.registerFeature(RowReorder, false);
GridFeatureManager.registerFeature(RowReorder, true, "Gantt");
var Search = class extends Delayable(InstancePlugin) {
  static get $name() {
    return "Search";
  }
  static get configurable() {
    return {
      limit: 1e3,
      showHitIndex: true,
      keyMap: {
        F3: "gotoNextHit",
        "Ctrl+g": "gotoNextHit",
        "Shift+F3": "gotoPrevHit",
        "Ctrl+Shift+g": "gotoPrevHit"
      }
    };
  }
  static get properties() {
    return {
      hitCls: "b-search-hit",
      hitCellCls: "b-search-hit-cell",
      hitCellBadgeCls: "b-search-hit-cell-badge",
      hitTextCls: "b-search-hit-text"
    };
  }
  construct(grid, config) {
    const me = this;
    super.construct(grid, config);
    Object.assign(me, {
      grid,
      text: "",
      hitEls: [],
      treeWalker: grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)
    });
    grid.ion({
      expandNode: "onTreeNodeExpand",
      thisObj: me
    });
  }
  isActionAvailable() {
    return Boolean(this.text);
  }
  onTreeNodeExpand() {
    if (this.text) {
      this.requestAnimationFrame(this.search, [this.text, false, true]);
    }
  }
  doDestroy() {
    this.clear(true);
    super.doDestroy();
  }
  doDisable(disable) {
    if (disable) {
      this.clear();
    }
    super.doDisable(disable);
  }
  get store() {
    return this.grid.store;
  }
  static get pluginConfig() {
    return {
      chain: ["populateCellMenu"]
    };
  }
  async search(text, gotoHit = true, reapply = false, fields) {
    const me = this;
    if (!text) {
      return me.clear();
    }
    if (!reapply && text === me.text || me.disabled) {
      return;
    }
    const {
      grid,
      store
    } = me, columns = grid.columns.visibleColumns.filter((col) => col.searchable !== false), formatters = [];
    fields = fields || columns.map((col) => {
      var _col$formatValue;
      formatters.push((_col$formatValue = col.formatValue) === null || _col$formatValue === void 0 ? void 0 : _col$formatValue.bind(col));
      return col.field;
    });
    const found = store.search(text, fields, formatters);
    if (store.isTree && found.length) {
      await grid.expandTo(found.map((hit) => hit.id));
    }
    for (const column of columns) {
      if (column.mergeCells && column.isSorted) {
        let prevValue = null, belongsTo = null;
        for (const hit of found) {
          if (hit.field === column.field) {
            const value = hit.data[hit.field];
            if (value === prevValue) {
              hit.belongsTo = belongsTo;
            }
            prevValue = value;
            belongsTo = `${hit.field}-${hit.id}`;
          }
        }
      }
    }
    let i = 1;
    Object.assign(me, {
      foundMap: {},
      prevFound: me.found,
      found,
      text,
      findRe: new RegExp(`(\\s+)?(${StringHelper.escapeRegExp(String(text))})(\\s+)?`, "ig")
    });
    me.clearHits();
    if (!found) {
      return;
    }
    for (const hit of found) {
      me.foundMap[`${hit.field}-${hit.id}`] = hit.belongsTo ? me.foundMap[hit.belongsTo] : i++;
      if (i > me.limit) {
        break;
      }
    }
    if (!me.listenersInitialized) {
      grid.rowManager.ion({
        name: "renderCell",
        renderCell: "renderCell",
        thisObj: me
      });
      store.ion({
        name: "storeRefresh",
        [`refresh${grid.asyncEventSuffix}`]: "onStoreRefresh",
        thisObj: me
      });
      me.listenersInitialized = true;
    }
    grid.refreshRows();
    grid.trigger("search", {
      grid,
      find: text,
      found
    });
    if (gotoHit && !me.isHitFocused) {
      me.gotoNextHit(true);
    }
    return found;
  }
  clearHits() {
    for (const cellElement of DomHelper.children(this.grid.element, "." + this.hitCls)) {
      cellElement.classList.remove(this.hitCls, this.hitCellCls);
      const row = DomDataStore.get(cellElement).row;
      if (row) {
        row.forceInnerHTML = true;
        row.renderCell(cellElement);
        row.forceInnerHTML = false;
      }
    }
  }
  clear(silent = false) {
    const me = this, {
      grid
    } = me;
    if (me.foundMap) {
      delete me.foundMap;
    }
    me.text = null;
    me.clearHits();
    if (me.listenersInitialized) {
      this.detachListeners("renderCell");
      this.detachListeners("storeRefresh");
      me.listenersInitialized = false;
    }
    if (!silent) {
      grid.trigger("clearSearch", {
        grid
      });
    }
  }
  get foundCount() {
    var _this$found$length, _this$found;
    return (_this$found$length = (_this$found = this.found) === null || _this$found === void 0 ? void 0 : _this$found.length) !== null && _this$found$length !== void 0 ? _this$found$length : 0;
  }
  get isHitFocused() {
    var _focusedCell$cell;
    const me = this, {
      grid
    } = me, {
      focusedCell
    } = grid;
    if (focusedCell !== null && focusedCell !== void 0 && (_focusedCell$cell = focusedCell.cell) !== null && _focusedCell$cell !== void 0 && _focusedCell$cell.contains(DomHelper.getActiveElement(grid.element))) {
      const {
        rowIndex,
        column
      } = focusedCell;
      return rowIndex !== -1 && me.found.some((hit) => hit.index === rowIndex && column && hit.field === column.field);
    }
  }
  gotoNextHit(fromStart = false) {
    var _me$found;
    const me = this;
    if (!((_me$found = me.found) !== null && _me$found !== void 0 && _me$found.length))
      return;
    const {
      grid,
      store
    } = me, fromCell = grid.focusedCell || grid.lastFocusedCell, currentIndex = fromCell && fromStart !== true ? store.indexOf(fromCell.record, void 0, true) : -1, nextHit = me.found.findIndex((hit) => hit.index > currentIndex);
    if (nextHit !== -1) {
      me.gotoHit(nextHit);
    }
  }
  gotoPrevHit() {
    var _me$found2;
    const me = this, {
      store
    } = me;
    if (!((_me$found2 = me.found) !== null && _me$found2 !== void 0 && _me$found2.length))
      return;
    const {
      grid,
      found
    } = me, fromCell = grid.focusedCell || grid.lastFocusedCell, currentIndex = fromCell ? store.indexOf(fromCell.record, void 0, true) : 0;
    for (let i = found.length - 1; i--; i >= 0) {
      const hit = found[i];
      if (hit.index < currentIndex) {
        me.gotoHit(i);
        break;
      }
    }
  }
  gotoHit(index) {
    const {
      grid
    } = this, nextHit = this.found[index];
    if (nextHit) {
      grid.focusCell({
        field: nextHit.field,
        id: nextHit.id
      });
    }
    return Boolean(nextHit);
  }
  gotoFirstHit() {
    this.gotoHit(0);
  }
  gotoLastHit() {
    this.gotoHit(this.found.length - 1);
  }
  renderCell({
    cellElement,
    column,
    record,
    value
  }) {
    var _me$foundMap;
    const me = this, {
      treeWalker,
      findRe,
      hitTextCls,
      showHitIndex
    } = me, hitIndex = (_me$foundMap = me.foundMap) === null || _me$foundMap === void 0 ? void 0 : _me$foundMap[column.field + "-" + record.id];
    if (hitIndex) {
      var _cellElement$querySel;
      cellElement.classList.add(me.hitCls);
      showHitIndex && ((_cellElement$querySel = cellElement.querySelector(`.${me.hitCellBadgeCls}`)) === null || _cellElement$querySel === void 0 ? void 0 : _cellElement$querySel.remove());
      const inner = DomHelper.down(cellElement, ".b-grid-cell-value,.b-tree-cell-value") || cellElement;
      if (String(value).toLowerCase() === String(me.text).toLowerCase()) {
        inner.innerHTML = `<span class="${me.hitTextCls}">${inner.innerHTML}</span>${showHitIndex ? `<div class="${me.hitCellBadgeCls}">${hitIndex}</div>` : ""}`;
      } else {
        treeWalker.currentNode = inner;
        for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode); ) {
          const nodeToReplace = textNode, textContent = textNode.nodeValue, newText = ["<span>"];
          textNode = treeWalker.nextNode();
          let offset = findRe.lastIndex;
          for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {
            const preamble = textContent.substring(offset, match.index), spaceBefore = match[1] ? "\xA0" : "", v = match[2], spaceAfter = match[3] ? "\xA0" : "";
            newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class="${hitTextCls}">${v}</span>${spaceAfter}`);
            offset = findRe.lastIndex;
          }
          newText.push(StringHelper.encodeHtml(textContent.substring(offset)), "<span>");
          nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(""), {
            fragment: true
          }), nodeToReplace);
          nodeToReplace.remove();
        }
        if (showHitIndex) {
          DomHelper.createElement({
            parent: cellElement,
            className: me.hitCellBadgeCls,
            text: hitIndex
          });
        }
      }
      me.hitEls.push(cellElement);
    }
  }
  populateCellMenu({
    column,
    record,
    items: items2,
    cellElement
  }) {
    const me = this;
    if (column.searchable) {
      items2.search = {
        text: "L{searchForValue}",
        localeClass: me,
        icon: "b-fw-icon b-icon-search",
        cls: "b-separator",
        weight: 200,
        disabled: me.disabled,
        onItem: () => {
          let sel = globalThis.getSelection().toString();
          if (!sel) {
            sel = cellElement.innerText;
          }
          me.search(sel);
        }
      };
    }
  }
  onStoreRefresh() {
    this.search(this.text, false, true);
  }
};
Search.featureClass = "b-search";
Search._$name = "Search";
GridFeatureManager.registerFeature(Search);
var Sort = class extends InstancePlugin {
  static get $name() {
    return "Sort";
  }
  static get configurable() {
    return {
      multiSort: true,
      prioritizeColumns: false
    };
  }
  static get properties() {
    return {
      ignoreRe: new RegExp([
        "b-grid-header-resize-handle",
        "b-filter-icon"
      ].join("|")),
      sortableCls: "b-sortable",
      sortedCls: "b-sort",
      sortedAscCls: "b-asc",
      sortedDescCls: "b-desc"
    };
  }
  construct(grid, config) {
    config = this.processConfig(config);
    this.grid = grid;
    this.bindStore(this.store);
    super.construct(grid, config);
  }
  processConfig(config) {
    if (typeof config === "string" || Array.isArray(config)) {
      return {
        field: config,
        ascending: null
      };
    }
    return config;
  }
  setConfig(config) {
    super.setConfig(this.processConfig(config));
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      beforeSort: "onStoreBeforeSort",
      sort: "syncHeaderSortState",
      thisObj: this
    });
  }
  set field(field) {
    const column = this.grid.columns.get(field);
    if (column && typeof column.sortable === "object") {
      column.sortable.field = column.sortable.property || field;
      field = column.sortable;
    }
    this.store.sort(field, this.ascending);
  }
  get store() {
    return this.grid[this.grid.sortFeatureStore];
  }
  static get pluginConfig() {
    return {
      chain: ["onElementClick", "populateHeaderMenu", "getColumnDragToolbarItems", "renderHeader", "onPaint", "bindStore"]
    };
  }
  syncHeaderSortState() {
    const me = this, {
      grid
    } = me;
    if (!grid.hideHeaders && grid.isPainted) {
      const storeSorters = me.store.sorters, sorterCount = storeSorters.length, classList = new DomClassList();
      let sorter;
      for (const leafColumn of grid.columns.visibleColumns) {
        var _leafColumn$textWrapp;
        const leafHeader = leafColumn.element, dataset = (_leafColumn$textWrapp = leafColumn.textWrapper) === null || _leafColumn$textWrapp === void 0 ? void 0 : _leafColumn$textWrapp.dataset;
        let sortDirection = "none";
        (dataset === null || dataset === void 0 ? void 0 : dataset.sortIndex) && delete dataset.sortIndex;
        classList.value = leafHeader.classList;
        if (leafColumn.sortable !== false) {
          classList.add(me.sortableCls);
          sorter = storeSorters.find((sort) => sort.field === leafColumn.field || sort.sortFn && sort.sortFn === leafColumn.sortable.sortFn);
          if (sorter) {
            if (sorterCount > 1 && dataset) {
              dataset.sortIndex = storeSorters.indexOf(sorter) + 1;
            }
            classList.add(me.sortedCls);
            if (sorter.ascending) {
              classList.add(me.sortedAscCls);
              classList.remove(me.sortedDescCls);
              sortDirection = "ascending";
            } else {
              classList.add(me.sortedDescCls);
              classList.remove(me.sortedAscCls);
              sortDirection = "descending";
            }
          } else {
            classList.remove(me.sortedCls);
            if (!classList["b-group"]) {
              classList.remove(me.sortedAscCls);
              classList.remove(me.sortedDescCls);
            }
          }
        } else {
          classList.remove(me.sortableCls);
        }
        DomHelper.syncClassList(leafHeader, classList);
        DomHelper.setAttributes(leafHeader, {
          "aria-sort": sortDirection
        });
      }
    }
  }
  populateHeaderMenu({
    column,
    items: items2
  }) {
    const me = this, {
      store
    } = me, sortBy = _objectSpread2(_objectSpread2({}, column.sortable), {}, {
      field: column.field,
      columnOwned: true
    });
    if (column.sortable !== false) {
      items2.sortAsc = {
        text: "L{sortAscending}",
        localeClass: me,
        icon: "b-fw-icon b-icon-sort-asc",
        cls: "b-separator",
        weight: 300,
        disabled: me.disabled,
        onItem: () => store.sort(sortBy, true)
      };
      items2.sortDesc = {
        text: "L{sortDescending}",
        localeClass: me,
        icon: "b-fw-icon b-icon-sort-desc",
        weight: 310,
        disabled: me.disabled,
        onItem: () => store.sort(sortBy, false)
      };
      if (me.multiSort && me.grid.columns.records.some((col) => col.sortable)) {
        const sorter = store.sorters.find((s) => s.field === column.field || column.sortable.sortFn && column.sortable.sortFn === s.sortFn);
        items2.multiSort = {
          text: "L{multiSort}",
          localeClass: me,
          icon: "b-fw-icon b-icon-sort",
          weight: 320,
          disabled: me.disabled,
          menu: {
            addSortAsc: {
              text: sorter ? "L{toggleSortAscending}" : "L{addSortAscending}",
              localeClass: me,
              icon: "b-fw-icon b-icon-sort-asc",
              disabled: sorter && (sorter === null || sorter === void 0 ? void 0 : sorter.ascending),
              weight: 330,
              onItem: () => store.addSorter(sortBy, true)
            },
            addSortDesc: {
              text: sorter ? "L{toggleSortDescending}" : "L{addSortDescending}",
              localeClass: me,
              icon: "b-fw-icon b-icon-sort-desc",
              disabled: sorter && !sorter.ascending,
              weight: 340,
              onItem: () => store.addSorter(sortBy, false)
            },
            removeSorter: {
              text: "L{removeSorter}",
              localeClass: me,
              icon: "b-fw-icon b-icon-remove",
              weight: 350,
              disabled: !sorter,
              onItem: () => {
                store.removeSorter(sortBy.field);
              }
            }
          }
        };
      }
    }
  }
  getColumnDragToolbarItems(column, items2) {
    const me = this, {
      store,
      disabled
    } = me;
    if (column.sortable !== false) {
      const sorter = store.sorters.find((s) => s.field === column.field);
      items2.push({
        text: "L{sortAscendingShort}",
        group: "L{sort}",
        localeClass: me,
        icon: "b-icon b-icon-sort-asc",
        ref: "sortAsc",
        cls: "b-separator",
        weight: 105,
        disabled,
        onDrop: ({
          column: column2
        }) => store.sort(column2.field, true)
      }, {
        text: "L{sortDescendingShort}",
        group: "L{sort}",
        localeClass: me,
        icon: "b-icon b-icon-sort-desc",
        ref: "sortDesc",
        weight: 105,
        disabled,
        onDrop: ({
          column: column2
        }) => store.sort(column2.field, false)
      }, {
        text: "L{addSortAscendingShort}",
        group: "L{multiSort}",
        localeClass: me,
        icon: "b-icon b-icon-sort-asc",
        ref: "multisortAddAsc",
        disabled: disabled || sorter && sorter.ascending,
        weight: 105,
        onDrop: ({
          column: column2
        }) => store.addSorter(column2.field, true)
      }, {
        text: "L{addSortDescendingShort}",
        group: "L{multiSort}",
        localeClass: me,
        icon: "b-icon b-icon-sort-desc",
        ref: "multisortAddDesc",
        disabled: disabled || sorter && !sorter.ascending,
        weight: 105,
        onDrop: ({
          column: column2
        }) => store.addSorter(column2.field, false)
      }, {
        text: "L{removeSorterShort}",
        group: "L{multiSort}",
        localeClass: me,
        icon: "b-icon b-icon-remove",
        ref: "multisortRemove",
        weight: 105,
        disabled: disabled || !sorter,
        onDrop: ({
          column: column2
        }) => store.removeSorter(column2.field)
      });
    }
    return items2;
  }
  onStoreBeforeSort({
    sorters
  }) {
    const {
      columns
    } = this.client;
    for (let i = 0; i < sorters.length; i++) {
      var _column$sortable;
      const sorter = sorters[i], column = (sorter.columnOwned || this.prioritizeColumns) && columns.get(sorter.field);
      if (column !== null && column !== void 0 && (_column$sortable = column.sortable) !== null && _column$sortable !== void 0 && _column$sortable.sortFn) {
        sorters[i] = _objectSpread2(_objectSpread2(_objectSpread2({}, sorter), column.sortable), {}, {
          columnOwned: true
        });
      }
    }
  }
  onElementClick(event) {
    const me = this, {
      store
    } = me, {
      target
    } = event, header = target.closest(".b-grid-header.b-sortable"), field = header === null || header === void 0 ? void 0 : header.dataset.column;
    if (me.ignoreRe.test(target.className) || me.disabled || event.handled) {
      return;
    }
    if (header && field) {
      const column = me.grid.columns.getById(header.dataset.columnId), columnGrouper = store.isGrouped && store.groupers.find((g) => g.field === field);
      if (columnGrouper && !event.shiftKey) {
        return;
      }
      if (column.sortable && !event.shiftKey) {
        if (event.ctrlKey && event.altKey) {
          store.removeSorter(column.field);
        } else {
          const sortBy = {
            columnOwned: true,
            field: column.field
          };
          if (typeof column.sortable === "object") {
            ObjectHelper.assign(sortBy, column.sortable);
          }
          store.sort(sortBy, null, event.ctrlKey);
        }
      }
    }
  }
  renderHeader() {
    this.syncHeaderSortState();
  }
  onPaint() {
    this.syncHeaderSortState();
  }
};
Sort.featureClass = "b-sort";
Sort._$name = "Sort";
GridFeatureManager.registerFeature(Sort, true);
var StickyCells = class extends InstancePlugin {
  static get $name() {
    return "StickyCells";
  }
  static get defaultConfig() {
    return {
      contentSelector: null,
      currentTopRowCls: "b-sticky-cells-current-top-row"
    };
  }
  static get pluginConfig() {
    return {
      before: ["renderRows"]
    };
  }
  construct(grid, config) {
    super.construct(grid, config);
    grid.ion({
      scroll: "onGridScroll",
      thisObj: this
    });
    Object.assign(this, DomHelper.createElement({
      reference: "element",
      parent: grid.element,
      className: "b-grid-sticky-row",
      children: [{
        reference: "contentElement",
        className: "b-grid-cell"
      }]
    }));
    this.removeClasses = {
      "b-focused": false,
      "b-hover": false,
      "b-selected": false,
      [this.currentTopRowCls]: false
    };
  }
  renderRows() {
    this.element.classList.add("b-hide-visibility");
  }
  onGridScroll() {
    const me = this, {
      client: grid,
      element,
      contentElement
    } = me, gridViewport = Rectangle.client(grid.bodyContainer).roundPx(), currentTopRow = grid.rowManager.getRowAt(gridViewport.y), topRowChanged = currentTopRow !== me.currentTopRow;
    if (currentTopRow) {
      if (topRowChanged) {
        if (me.currentTopRow) {
          me.currentTopRow.removeCls(me.currentTopRowCls);
          me.currentTopRow.removeCls("b-not-enough-height");
        }
        me.currentTopRow = currentTopRow;
        currentTopRow.addCls(me.currentTopRowCls);
        contentElement.innerHTML = "";
        contentElement.appendChild(me.updateStickyContent());
      }
      const notEnoughHeight = me.currentTopRow.bottom - me.client.scrollable.y <= me.stickyContentHeight;
      me.element.classList[notEnoughHeight ? "add" : "remove"]("b-hide-visibility");
      me.currentTopRow[notEnoughHeight ? "addCls" : "removeCls"]("b-not-enough-height");
      gridViewport.y += me.stickyContentTop;
      DomHelper.alignTo(element, me.stickyEls[0], {
        align: "t0-t0",
        constrainTo: gridViewport
      }, true);
    }
    me.lastProcessedTopRow = currentTopRow;
  }
  updateStickyContent() {
    const me = this, {
      currentTopRow,
      removeClasses
    } = me, rowClasses = {
      "b-grid-sticky-row": 1
    }, cellClasses = {}, stickyContent = me.stickyContent || (me.stickyContent = document.createDocumentFragment()), stickyEls = me.stickyEls || (me.stickyEls = []);
    stickyEls.forEach((e) => {
      e.classList.remove("b-sticky-content-el");
    });
    stickyEls.length = 0;
    currentTopRow.eachElement((rowEl) => {
      stickyEls.push(...rowEl.querySelectorAll(me.contentSelector));
    });
    while (stickyContent.firstChild) {
      stickyContent.remove(stickyContent.firstChild);
    }
    me.stickyContentHeight = 0;
    me.stickyContentTop = 0;
    stickyEls.map((e) => {
      e.closest(".b-grid-cell").classList.forEach((cls) => cellClasses[cls] = 1);
      e.closest(".b-grid-row").classList.forEach((cls) => rowClasses[cls] = 1);
      Object.assign(cellClasses, removeClasses);
      Object.assign(rowClasses, removeClasses);
      const eTop = e.offsetTop;
      me.stickyContentTop = Math.max(me.stickyContentTop, eTop);
      e.style.alignSelf = "flex-end";
      me.stickyContentHeight = Math.max(me.stickyContentHeight, me.currentTopRow.height - e.offsetTop + eTop);
      e.style.alignSelf = "";
      const result = e.cloneNode(true);
      e.classList.add("b-sticky-content-el");
      stickyContent.appendChild(result);
      return result;
    });
    cellClasses["b-focused"] = false;
    DomHelper.syncClassList(me.contentElement, cellClasses);
    DomHelper.syncClassList(me.element, rowClasses);
    return stickyContent;
  }
};
StickyCells._$name = "StickyCells";
GridFeatureManager.registerFeature(StickyCells, false);
var Stripe = class extends InstancePlugin {
  static get $name() {
    return "Stripe";
  }
  construct(grid, config) {
    super.construct(grid, config);
    grid.ion({
      renderrow: "onRenderRow",
      thisObj: this
    });
  }
  doDisable(disable) {
    if (!this.isConfiguring) {
      this.client.refreshRows();
    }
    super.doDisable(disable);
  }
  onRenderRow({
    row
  }) {
    const {
      disabled
    } = this, even = row.dataIndex % 2 === 0;
    row.assignCls({
      "b-even": !disabled && even,
      "b-odd": !disabled && !even
    });
  }
};
Stripe._$name = "Stripe";
GridFeatureManager.registerFeature(Stripe);
var Summary$1 = class extends SummaryFormatter(InstancePlugin) {
  static get configurable() {
    return {
      selectedOnly: null,
      hideFooters: false
    };
  }
  static get pluginConfig() {
    return {
      chain: ["renderRows", "bindStore"]
    };
  }
  static get $name() {
    return "Summary";
  }
  construct(grid, config) {
    this.grid = grid;
    super.construct(grid, config);
    this.bindStore(grid.store);
    grid.hideFooters = this.hideFooters;
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      change: "onStoreChange",
      thisObj: this
    });
  }
  get store() {
    return this.grid.store;
  }
  doDestroy() {
    super.doDestroy();
  }
  doDisable(disable) {
    super.doDisable(disable);
    const {
      client
    } = this;
    if (disable) {
      client.element.classList.add("b-summary-disabled");
    } else {
      this.updateSummaries();
      client.element.classList.remove("b-summary-disabled");
      client.eachSubGrid((subGrid) => subGrid.scrollable.syncPartners());
    }
  }
  renderRows() {
    this.updateSummaries();
  }
  updateSummaries() {
    const me = this, {
      grid,
      store
    } = me, cells = DomHelper.children(grid.element, ".b-grid-footer"), selectedOnly = me.selectedOnly && grid.selectedRecords.length > 0, records = (store.isFiltered ? store.storage.values : store.allRecords).filter((r) => !r.isSpecialRow && (!selectedOnly || grid.isSelected(r)));
    grid.columns.forEach((column) => {
      var _column$summaries;
      (_column$summaries = column.summaries) === null || _column$summaries === void 0 ? void 0 : _column$summaries.forEach((config) => {
        if ("seed" in config) {
          if (!("initialSeed" in config)) {
            config.initialSeed = config.seed;
          }
          if (["number", "string", "date"].includes(typeof config.initialSeed)) {
            config.seed = config.initialSeed;
          } else {
            config.seed = Object.assign({}, config.initialSeed);
          }
        }
      });
    });
    cells.forEach((cellElement) => {
      if (!cellElement.dataset.column) {
        return;
      }
      const column = grid.columns.get(cellElement.dataset.column), html = me.generateHtml(column, records, "b-grid-footer-summary");
      if (column.summaries ? column.summaries.length : column.sum ? 1 : 0) {
        if (!cellElement.children.length) {
          cellElement.innerHTML = html;
        } else {
          DomHelper.sync(html, cellElement.firstElementChild);
        }
      }
    });
  }
  onStoreChange({
    action,
    changes
  }) {
    let shouldUpdate = true;
    if (this.disabled) {
      return;
    }
    if (action === "update") {
      shouldUpdate = Object.keys(changes).some((field) => {
        const colField = this.grid.columns.get(field);
        return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));
      });
    }
    if (shouldUpdate) {
      this.updateSummaries();
    }
  }
  updateSelectedOnly(value) {
    const me = this;
    me.detachListeners("selectionChange");
    if (value) {
      me.grid.ion({
        name: "selectionChange",
        selectionChange: me.refresh,
        thisObj: me
      });
    }
    me.refresh();
  }
  refresh() {
    this.updateSummaries();
  }
};
Summary$1.featureClass = "b-summary";
Summary$1._$name = "Summary";
GridFeatureManager.registerFeature(Summary$1);
var immediatePromise$3 = Promise.resolve();
var Tree = class extends InstancePlugin.mixin(Delayable) {
  static get pluginConfig() {
    return {
      assign: ["collapseAll", "expandAll", "collapse", "expand", "expandTo", "toggleCollapse"],
      chain: ["onElementPointerUp", "onElementClick", "bindStore"]
    };
  }
  construct(client, config) {
    super.construct(client, config);
    if (!this.treeColumn) {
      console.info("To use the tree feature, one column should be configured with `type: 'tree'`");
    }
    client.store && this.bindStore(client.store);
  }
  doDisable(disable) {
    if (disable) {
      throw new Error("Tree feature cannot be disabled");
    }
  }
  get store() {
    return this.client.store;
  }
  get treeColumn() {
    const me = this, {
      columns
    } = me.client;
    if (!me._treeColumn || !columns.includes(me._treeColumn)) {
      me._treeColumn = columns.find((column) => column.isTreeColumn);
    }
    return me._treeColumn;
  }
  bindStore(store) {
    this.detachListeners("store");
    store.ion({
      name: "store",
      beforeLoadChildren: "onBeforeLoadChildren",
      loadChildren: "onLoadChildren",
      loadChildrenException: "onLoadChildrenException",
      beforeToggleNode: "onBeforeToggleNode",
      thisObj: this
    });
  }
  async toggleCollapse(idOrRecord, collapse, skipRefresh = false) {
    if (idOrRecord == null) {
      throw new Error("Tree#toggleCollapse must be passed a record");
    }
    const me = this, {
      store,
      client
    } = me, {
      rowManager
    } = client, record = store.getById(idOrRecord), meta = record.instanceMeta(store);
    if (await store.toggleCollapse(record, collapse)) {
      const row = rowManager.getRowFor(record);
      if (row && record.ancestorsExpanded()) {
        const cellElement = me.treeColumn && !me.treeColumn.subGrid.collapsed && row.getCell(me.treeColumn.id);
        cellElement && row.renderCell(cellElement);
      }
      if (!me.isTogglingNode) {
        client.element.classList.add("b-toggling-node");
        me.isTogglingNode = true;
        me.requestAnimationFrame(() => {
          client.element.classList.remove("b-toggling-node");
          me.isTogglingNode = false;
        });
      }
      client.trigger(meta.collapsed ? "collapseNode" : "expandNode", {
        record
      });
      client.trigger("toggleNode", {
        record,
        collapse: meta.collapsed
      });
    }
  }
  async collapse(idOrRecord) {
    return this.toggleCollapse(idOrRecord, true);
  }
  async expand(idOrRecord) {
    return this.toggleCollapse(idOrRecord, false);
  }
  onBeforeToggleNode({
    record,
    collapse
  }) {
    this.client.trigger("beforeToggleNode", {
      record,
      collapse
    });
  }
  onBeforeLoadChildren({
    source: store,
    params
  }) {
    const parent = store.getById(params[store.modelClass.idField]), row = this.client.rowManager.getRowFor(parent);
    row === null || row === void 0 ? void 0 : row.addCls("b-loading-children");
  }
  onLoadChildren({
    source: store,
    params
  }) {
    const parent = store.getById(params[store.modelClass.idField]), row = this.client.rowManager.getRowFor(parent);
    row === null || row === void 0 ? void 0 : row.removeCls("b-loading-children");
  }
  onLoadChildrenException({
    record
  }) {
    const row = this.client.rowManager.getRowFor(record);
    row === null || row === void 0 ? void 0 : row.removeCls("b-loading-children");
  }
  async expandOrCollapseAll(collapse = true, topNode = this.store.rootNode) {
    const {
      client,
      store
    } = this, promises = [], childRecords = [];
    client.trigger("beforeToggleAllNodes", {
      collapse
    });
    store.suspendEvents();
    store.traverse((record) => {
      const gridMeta = record.instanceMeta(store);
      if (!record.isLeaf) {
        if (collapse && !gridMeta.collapsed) {
          this.toggleCollapse(record, true, true);
          childRecords.push(...record.children);
        } else if (!collapse && gridMeta.collapsed) {
          if (Array.isArray(record.children)) {
            childRecords.push(...record.children);
          }
          promises.push(this.toggleCollapse(record, false, true));
        }
      }
    }, topNode, topNode === store.rootNode);
    store.resumeEvents();
    return (collapse ? immediatePromise$3 : Promise.all(promises)).then(() => {
      client.refreshRows(collapse);
      if (childRecords.length) {
        if (collapse) {
          store.trigger("remove", {
            records: childRecords,
            isCollapse: true,
            isCollapseAll: true
          });
        } else {
          store.trigger("add", {
            records: childRecords,
            isExpand: true,
            isExpandAll: true
          });
        }
      }
      client.trigger("toggleAllNodes", {
        collapse
      });
    });
  }
  async collapseAll() {
    return this.expandOrCollapseAll(true);
  }
  async expandAll() {
    return this.expandOrCollapseAll(false);
  }
  async expandTo(idOrRecord, scrollIntoView = true) {
    const me = this, {
      store,
      client
    } = me;
    if (Array.isArray(idOrRecord)) {
      if (idOrRecord.length > 0) {
        client.suspendRefresh();
        for (let i = idOrRecord.length - 1; i >= 0; i--) {
          var _me$expandTo;
          const record2 = store.getById(idOrRecord[i]);
          if (i === 0) {
            var _client$resumeRefresh;
            (_client$resumeRefresh = client.resumeRefresh) === null || _client$resumeRefresh === void 0 ? void 0 : _client$resumeRefresh.call(client);
            client.rowManager.refresh();
          }
          await ((_me$expandTo = me.expandTo) === null || _me$expandTo === void 0 ? void 0 : _me$expandTo.call(me, record2, i === 0));
        }
      }
      return;
    }
    const record = store.getById(idOrRecord);
    if (record.instanceMeta(me.store).hiddenByCollapse === false) {
      return;
    }
    if (!record.ancestorsExpanded()) {
      var _client$refreshRows;
      const parents = [];
      for (let parent = record.parent; parent && !parent.isRoot; parent = parent.parent) {
        if (!parent.isExpanded(store)) {
          parents.unshift(parent);
        }
      }
      for (const parent of parents) {
        if (!me.isDestroyed) {
          await me.toggleCollapse(parent, false, true);
        }
      }
      (_client$refreshRows = client.refreshRows) === null || _client$refreshRows === void 0 ? void 0 : _client$refreshRows.call(client);
    }
    if (!me.isDestroyed && scrollIntoView) {
      await client.scrollRowIntoView(record);
    }
  }
  onElementPointerUp(event) {
    const me = this, target = event.target, cellData = me.client.getCellDataFromEvent(event), clickedExpander = target.closest(".b-tree-expander");
    if (clickedExpander || me.expandOnCellClick && cellData !== null && cellData !== void 0 && cellData.record.isParent) {
      me.toggleCollapse(cellData.record);
    }
  }
  onElementClick(event) {
    if (event.target.closest(".b-tree-expander")) {
      event.preventDefault();
    }
  }
  toggleCollapseByKey() {
    const {
      focusedCell
    } = this.client;
    if ((focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.rowIndex) > -1 && !focusedCell.isActionable) {
      this.toggleCollapse(focusedCell.id);
      return true;
    }
    return false;
  }
  expandIfSingleColumn() {
    if (this.client.columns.count === 1) {
      return this.expandByKey();
    }
    return false;
  }
  expandByKey() {
    const me = this, {
      client
    } = me, {
      focusedCell
    } = client, record = focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.record;
    if (focusedCell !== null && focusedCell !== void 0 && focusedCell.column.tree && record.isParent && record.instanceMeta(client.store).collapsed) {
      me.expand(record);
      return true;
    }
    return false;
  }
  collapseIfSingleColumn() {
    if (this.client.columns.count === 1) {
      return this.collapseByKey();
    }
    return false;
  }
  collapseByKey() {
    const me = this, {
      client
    } = me, {
      focusedCell
    } = client, record = focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.record;
    if (focusedCell !== null && focusedCell !== void 0 && focusedCell.column.tree) {
      if (record.isParent && !record.instanceMeta(client.store).collapsed) {
        me.collapse(record);
        return true;
      }
      if (record.parent && !record.parent.isRoot) {
        client.deselectAll();
        client.focusCell({
          record: record.parent,
          column: focusedCell.column
        });
        return true;
      }
    }
    return false;
  }
};
_defineProperty(Tree, "$name", "Tree");
_defineProperty(Tree, "configurable", {
  expandOnCellClick: false,
  keyMap: {
    " ": "toggleCollapseByKey",
    ArrowRight: "expandIfSingleColumn",
    "Shift+ArrowRight": "expandByKey",
    ArrowLeft: "collapseIfSingleColumn",
    "Shift+ArrowLeft": "collapseByKey"
  }
});
Tree.featureClass = "b-tree";
Tree._$name = "Tree";
GridFeatureManager.registerFeature(Tree, false, "Grid");
GridFeatureManager.registerFeature(Tree, true, "TreeGrid");
var TreeGroup = class extends InstancePlugin {
  construct(grid, config) {
    super.construct(grid, config);
    if (!grid.hasFeature("tree")) {
      throw new Error("The TreeGroup feature requires the Tree feature to be enabled");
    }
  }
  processParentData(parentData) {
    if (this.parentCls) {
      parentData.cls = this.parentCls;
    }
  }
  processTransformedData(transformedData) {
  }
  async waitForReadiness() {
    if (this.originalStore.isLoading) {
      await this.originalStore.await("load", false);
      if (this.isDestroyed) {
        return;
      }
    }
    const {
      crudManager
    } = this.client;
    if (crudManager) {
      if (crudManager.isLoadingOrSyncing) {
        await crudManager.await("requestDone");
        if (this.isDestroyed) {
          return;
        }
      }
      await this.client.project.commitAsync();
    }
  }
  async applyLevels(levels) {
    const me = this, {
      client
    } = me, treeColumn = client.columns.find((col) => col instanceof TreeColumn);
    let {
      store
    } = client, result = null;
    me._levels = levels;
    me.isApplying++;
    client.suspendRefresh();
    if (levels && !me.originalStore) {
      me.originalStore = store;
      store = new store.constructor({
        tree: true,
        modelClass: store.modelClass
      });
      client.store = store;
    }
    await me.waitForReadiness();
    if (me.isDestroyed) {
      return;
    }
    if (levels) {
      store.data = me.originalStore.allRecords.flatMap((record) => record.isLeaf ? [record.link()] : []);
      result = store.treeify(levels, (parentData) => {
        ObjectHelper.setPath(parentData, store.modelClass.getFieldDataSource(treeColumn.field), parentData.key);
        me.processParentData(parentData);
      });
      me.processTransformedData(result);
      store.data = result.children;
    } else {
      client.store = me.originalStore;
      me.originalStore = null;
    }
    me.isApplying--;
    client.resumeRefresh();
    client.rowManager.reinitialize();
    return result;
  }
  updateLevels(levels) {
    if (levels || !this.isConfiguring) {
      this.applyLevels(levels);
    }
  }
  async group(levels) {
    ObjectHelper.assertArray(levels, "group()");
    await this.applyLevels(levels);
  }
  async clearGroups() {
    if (this.isGrouped) {
      await this.applyLevels(null);
    }
  }
  get isGrouped() {
    return Boolean(this._levels);
  }
};
_defineProperty(TreeGroup, "$name", "TreeGroup");
_defineProperty(TreeGroup, "configurable", {
  levels: null,
  parentCls: "b-generated-parent"
});
_defineProperty(TreeGroup, "pluginConfig", {
  assign: ["group", "clearGroups"]
});
_defineProperty(TreeGroup, "properties", {
  isApplying: 0,
  originalStore: null
});
TreeGroup._$name = "TreeGroup";
GridFeatureManager.registerFeature(TreeGroup);
var RowsRange = {
  all: "all",
  visible: "visible"
};
var PaperFormat = {
  A6: {
    width: 4.11,
    height: 5.81
  },
  A5: {
    width: 5.81,
    height: 8.25
  },
  A4: {
    width: 8.25,
    height: 11.69
  },
  A3: {
    width: 11.69,
    height: 16.49
  },
  Legal: {
    width: 8.5,
    height: 14
  },
  Letter: {
    width: 8.5,
    height: 11
  }
};
var Orientation = {
  portrait: "portrait",
  landscape: "landscape"
};
var FileFormat = {
  pdf: "pdf",
  png: "png"
};
var FileMIMEType = {
  pdf: "application/pdf",
  png: "image/png"
};
var ExportRowsCombo = class extends Combo {
  static get $name() {
    return "ExportRowsCombo";
  }
  static get type() {
    return "exportrowscombo";
  }
  static get defaultConfig() {
    return {
      editable: false
    };
  }
  buildItems() {
    const me = this;
    return [{
      id: RowsRange.all,
      text: me.L("L{all}")
    }, {
      id: RowsRange.visible,
      text: me.L("L{visible}")
    }];
  }
};
ExportRowsCombo.initClass();
ExportRowsCombo._$name = "ExportRowsCombo";
var ExportOrientationCombo = class extends Combo {
  static get $name() {
    return "ExportOrientationCombo";
  }
  static get type() {
    return "exportorientationcombo";
  }
  static get defaultConfig() {
    return {
      editable: false
    };
  }
  buildItems() {
    const me = this;
    return [{
      id: Orientation.portrait,
      text: me.L("L{portrait}")
    }, {
      id: Orientation.landscape,
      text: me.L("L{landscape}")
    }];
  }
};
ExportOrientationCombo.initClass();
ExportOrientationCombo._$name = "ExportOrientationCombo";
function buildComboItems(obj, fn2 = (x) => x) {
  return Object.keys(obj).map((key) => ({
    id: key,
    text: fn2(key)
  }));
}
var ExportDialog = class extends Popup {
  static get $name() {
    return "ExportDialog";
  }
  static get type() {
    return "exportdialog";
  }
  static get configurable() {
    return {
      autoShow: false,
      autoClose: false,
      closable: true,
      centered: true,
      client: null,
      autoSelectVisibleColumns: true,
      hidePNGMultipageOption: true,
      title: "L{exportSettings}",
      maxHeight: "80%",
      scrollable: {
        overflowY: true
      },
      defaults: {
        localeClass: this
      },
      items: {
        columnsField: {
          type: "combo",
          label: "L{ExportDialog.columns}",
          store: {},
          valueField: "id",
          displayField: "text",
          multiSelect: true,
          weight: 100,
          maxHeight: 100
        },
        rowsRangeField: {
          type: "exportrowscombo",
          label: "L{ExportDialog.rows}",
          value: "all",
          weight: 200
        },
        exporterTypeField: {
          type: "combo",
          label: "L{ExportDialog.exporterType}",
          editable: false,
          value: "singlepage",
          displayField: "text",
          buildItems() {
            const dialog = this.parent;
            return dialog.exporters.map((exporter) => ({
              id: exporter.type,
              text: dialog.optionalL(exporter.title, this)
            }));
          },
          onChange({
            value
          }) {
            this.owner.widgetMap.alignRowsField.hidden = value === "singlepage";
            this.owner.widgetMap.repeatHeaderField.hidden = value !== "multipagevertical";
          },
          weight: 300
        },
        alignRowsField: {
          type: "checkbox",
          label: "L{ExportDialog.alignRows}",
          checked: false,
          hidden: true,
          weight: 400
        },
        repeatHeaderField: {
          type: "checkbox",
          label: "L{ExportDialog.repeatHeader}",
          localeClass: this,
          hidden: true,
          weight: 500
        },
        fileFormatField: {
          type: "combo",
          label: "L{ExportDialog.fileFormat}",
          localeClass: this,
          editable: false,
          value: "pdf",
          items: [],
          onChange({
            value,
            oldValue
          }) {
            const dialog = this.parent;
            if (dialog.hidePNGMultipageOption) {
              const exporterField = dialog.widgetMap.exporterTypeField, exporter = exporterField.store.find((r) => r.id === "singlepage");
              if (value === FileFormat.png && exporter) {
                this._previousDisabled = exporterField.disabled;
                exporterField.disabled = true;
                this._previousValue = exporterField.value;
                exporterField.value = "singlepage";
              } else if (oldValue === FileFormat.png && this._previousValue) {
                exporterField.disabled = this._previousDisabled;
                exporterField.value = this._previousValue;
              }
            }
          },
          weight: 600
        },
        paperFormatField: {
          type: "combo",
          label: "L{ExportDialog.paperFormat}",
          editable: false,
          value: "A4",
          items: [],
          weight: 700
        },
        orientationField: {
          type: "exportorientationcombo",
          label: "L{ExportDialog.orientation}",
          value: "portrait",
          weight: 800
        }
      },
      bbar: {
        defaults: {
          localeClass: this
        },
        items: {
          exportButton: {
            color: "b-green",
            text: "L{ExportDialog.export}",
            weight: 100,
            onClick: "up.onExportClick"
          },
          cancelButton: {
            color: "b-gray",
            text: "L{ExportDialog.cancel}",
            weight: 200,
            onClick: "up.onCancelClick"
          }
        }
      }
    };
  }
  construct(config = {}) {
    const me = this, {
      client
    } = config;
    if (!client) {
      throw new Error("`client` config is required");
    }
    me.columnsStore = client.columns.chain((column) => column.isLeaf && column.exportable, null, {
      excludeCollapsedRecords: false
    });
    me.applyInitialValues(config);
    super.construct(config);
    LocaleManagerSingleton.ion({
      locale: "onLocaleChange",
      prio: -1,
      thisObj: me
    });
  }
  applyInitialValues(config) {
    const me = this, items2 = config.items = config.items || {};
    config.width = config.width || me.L("L{width}");
    config.defaults = config.defaults || {};
    config.defaults.labelWidth = config.defaults.labelWidth || me.L("L{ExportDialog.labelWidth}");
    items2.columnsField = items2.columnsField || {};
    items2.fileFormatField = items2.fileFormatField || {};
    items2.paperFormatField = items2.paperFormatField || {};
    items2.fileFormatField.items = buildComboItems(FileFormat, (value) => value.toUpperCase());
    items2.paperFormatField.items = buildComboItems(PaperFormat);
    items2.columnsField.store = me.columnsStore;
  }
  onBeforeShow() {
    var _super$onBeforeShow;
    const {
      columnsField,
      alignRowsField,
      exporterTypeField,
      repeatHeaderField
    } = this.widgetMap;
    if (this.autoSelectVisibleColumns) {
      columnsField.value = this.columnsStore.query((c) => !c.hidden);
    }
    alignRowsField.hidden = exporterTypeField.value === "singlepage";
    repeatHeaderField.hidden = exporterTypeField.value !== "multipagevertical";
    (_super$onBeforeShow = super.onBeforeShow) === null || _super$onBeforeShow === void 0 ? void 0 : _super$onBeforeShow.call(this, ...arguments);
  }
  onLocaleChange() {
    const labelWidth = this.L("L{labelWidth}");
    this.width = this.L("L{width}");
    this.eachWidget((widget) => {
      if (widget instanceof Field) {
        widget.labelWidth = labelWidth;
      }
    });
  }
  onExportClick() {
    const values = this.values;
    this.trigger("export", {
      values
    });
  }
  onCancelClick() {
    this.trigger("cancel");
    this.hide();
  }
  get values() {
    const fieldRe = /field/i, result = {};
    this.eachWidget((widget) => {
      if (fieldRe.test(widget.ref)) {
        result[widget.ref.replace(fieldRe, "")] = widget instanceof Checkbox ? widget.checked : widget.value;
      }
    });
    return result;
  }
};
ExportDialog.initClass();
ExportDialog._$name = "ExportDialog";
var cellContentRange = document.createRange();
var Row = class extends Base$1 {
  static get configurable() {
    return {
      cls: {
        $config: {
          equal: (c1, c2) => (c1 === null || c1 === void 0 ? void 0 : c1.isDomClassList) && (c2 === null || c2 === void 0 ? void 0 : c2.isDomClassList) && c1.isEqual(c2)
        }
      }
    };
  }
  construct(config) {
    Object.assign(this, {
      _elements: {},
      _elementsArray: [],
      _cells: {},
      _allCells: [],
      _regions: [],
      lastHeight: 0,
      lastTop: -1,
      _dataIndex: 0,
      _top: 0,
      _height: 0,
      _id: null,
      forceInnerHTML: false,
      isGroupFooter: false,
      cellContext: new Location({
        grid: config.grid,
        id: null,
        columnIndex: 0
      })
    });
    super.construct(config);
    if (this.grid.positionMode === "position") {
      this.translateElements = this.positionElements;
    }
  }
  doDestroy() {
    const me = this;
    if (!me.rowManager.isDestroying) {
      me.removeElements();
      if (me.rowManager.idMap[me.id] === me) {
        delete me.rowManager.idMap[me.id];
      }
    }
    super.doDestroy();
  }
  get index() {
    return this._index;
  }
  set index(index) {
    this._index = index;
  }
  get dataIndex() {
    return this._dataIndex;
  }
  set dataIndex(dataIndex) {
    if (this._dataIndex !== dataIndex) {
      this._dataIndex = dataIndex;
      this.eachElement((element) => {
        element.dataset.index = dataIndex;
        element.ariaRowIndex = this.grid.hideHeaders ? dataIndex + 1 : dataIndex + 2;
      });
    }
  }
  get id() {
    return this._id;
  }
  set id(id) {
    const me = this, idObj = {
      id
    }, idMap = me.rowManager.idMap;
    if (me._id !== id || idMap[id] !== me) {
      if (idMap[me._id] === me)
        delete idMap[me._id];
      idMap[id] = me;
      me._id = id;
      me.eachElement((element) => {
        DomDataStore.assign(element, idObj);
        element.dataset.id = id;
      });
      me.eachCell((cell) => DomDataStore.assign(cell, idObj));
    }
  }
  addElement(region, element) {
    const me = this;
    let cellElement = element.firstElementChild;
    me._elements[region] = element;
    me._elementsArray.push(element);
    me._regions.push(region);
    DomDataStore.assign(element, {
      index: me.index
    });
    me._cells[region] = [];
    while (cellElement) {
      me._cells[region].push(cellElement);
      me._allCells.push(cellElement);
      DomDataStore.set(cellElement, {
        column: cellElement.dataset.column,
        columnId: cellElement.dataset.columnId,
        rowElement: cellElement.parentNode,
        row: me
      });
      cellElement = cellElement.nextElementSibling;
    }
    element.dataset.index = me.index;
    element.ariaRowIndex = me.grid.hideHeaders ? me.index + 1 : me.index + 2;
  }
  getElement(region) {
    return this._elements[region];
  }
  getRectangle(region) {
    return Rectangle.from(this.getElement(region));
  }
  eachElement(fn2) {
    this._elementsArray.forEach(fn2);
  }
  eachCell(fn2) {
    this._allCells.forEach(fn2);
  }
  get elements() {
    return this._elements;
  }
  get element() {
    const region = Object.keys(this._elements)[0];
    return this._elements[region];
  }
  get cells() {
    return this._allCells;
  }
  getCells(region) {
    return this._cells[region];
  }
  getCell(columnId) {
    return this._allCells.find((cell) => {
      const cellData = DomDataStore.get(cell);
      return cellData.columnId == columnId || cellData.column == columnId;
    });
  }
  removeElements(onlyRelease = false) {
    const me = this;
    me.rowManager.trigger("removeRow", {
      row: me
    });
    if (!onlyRelease) {
      me.eachElement((element) => element.remove());
    }
    me._elements = {};
    me._cells = {};
    me._elementsArray.length = me._regions.length = me._allCells.length = me.lastHeight = me.height = 0;
    me.lastTop = -1;
  }
  get height() {
    return this._height;
  }
  set height(height) {
    this._height = height;
  }
  get offsetHeight() {
    return this.height + this.grid._rowBorderHeight;
  }
  updateElementsHeight(isExport) {
    const me = this;
    if (!isExport) {
      me.rowManager.storeKnownHeight(me.id, me.height);
    }
    if (me.lastHeight !== me.height) {
      this.eachElement((element) => element.style.height = `${me.offsetHeight}px`);
      me.lastHeight = me.height;
    }
  }
  addCls(classes) {
    this.updateCls(this.cls.add(classes));
  }
  removeCls(classes) {
    this.updateCls(this.cls.remove(classes));
  }
  toggleCls(classes, add) {
    this.updateCls(this.cls[add ? "add" : "remove"](classes));
  }
  assignCls(classes) {
    this.updateCls(this.cls.assign(classes));
  }
  changeCls(cls) {
    return cls !== null && cls !== void 0 && cls.isDomClassList ? cls : new DomClassList(cls);
  }
  updateCls(cls) {
    this.eachElement((element) => DomHelper.syncClassList(element, cls));
  }
  setAttribute(attribute, value) {
    this.eachElement((element) => element.setAttribute(attribute, value));
  }
  removeAttribute(attribute) {
    this.eachElement((element) => element.removeAttribute(attribute));
  }
  get isFirst() {
    return this.dataIndex === 0;
  }
  get top() {
    return this._top;
  }
  get bottom() {
    return this._top + this._height + this.grid._rowBorderHeight;
  }
  setTop(top, silent) {
    if (this._top !== top) {
      this._top = top;
      this.translateElements(silent);
    }
  }
  setBottom(bottom, silent) {
    this.setTop(bottom - this.offsetHeight, silent);
  }
  translate(top, silent = false) {
    this.setTop(top, silent);
    return top + this.offsetHeight;
  }
  translateElements(silent) {
    const me = this, {
      top,
      _elementsArray
    } = me;
    if (me.lastTop !== top) {
      for (let i = 0, {
        length
      } = _elementsArray; i < length; i++) {
        _elementsArray[i].style.transform = `translate(0,${top}px)`;
      }
      !silent && me.rowManager.trigger("translateRow", {
        row: me
      });
      me.lastTop = top;
    }
  }
  positionElements(silent) {
    const me = this, {
      top,
      _elementsArray
    } = me;
    if (me.lastTop !== top) {
      for (let i = 0, {
        length
      } = _elementsArray; i < length; i++) {
        _elementsArray[i].style.top = `${top}px`;
      }
      !silent && me.rowManager.trigger("translateRow", {
        row: me
      });
      me.lastTop = top;
    }
  }
  offset(offsetTop) {
    let newTop = this._top + offsetTop;
    if (newTop < 0) {
      offsetTop -= newTop;
      newTop = 0;
    }
    this.setTop(newTop);
    return offsetTop;
  }
  render(recordIndex, record, updatingSingleRow = true, batch = false, isExport = false) {
    var _record, _record2, _maxRequestedHeight, _grid$processRowHeigh;
    const me = this, {
      cellContext,
      cls,
      elements,
      cells,
      grid,
      rowManager,
      height: oldHeight,
      _id: oldId
    } = me, rowElData = DomDataStore.get(me._elementsArray[0]), rowHeight = rowManager._rowHeight, {
      store
    } = grid, {
      isTree
    } = store;
    let i = 0, size;
    if (!record && record !== false) {
      record = grid.store.getById(rowElData.id);
      recordIndex = grid.store.indexOf(record);
    }
    if (!record) {
      return;
    }
    const rCls = (_record = record) === null || _record === void 0 ? void 0 : _record.cls, recordCls = rCls ? rCls.isDomClassList ? rCls : new DomClassList(rCls) : null;
    cls.assign({
      "b-grid-row-updating": updatingSingleRow && grid.transitionDuration && !isExport,
      "b-selected": grid.isSelected((_record2 = record) === null || _record2 === void 0 ? void 0 : _record2.id),
      "b-readonly": record.readOnly,
      "b-linked": record.isLinked,
      "b-original": record.hasLinks
    });
    if (me.lastRecordCls) {
      cls.remove(me.lastRecordCls);
    }
    if (recordCls) {
      cls.add(recordCls);
      me.lastRecordCls = Object.assign({}, recordCls);
    } else {
      me.lastRecordCls = null;
    }
    rowManager.trigger("beforeRenderRow", {
      row: me,
      record,
      recordIndex,
      oldId
    });
    grid.beforeRenderRow({
      row: me,
      record,
      recordIndex,
      oldId
    });
    me.updateCls(cls);
    if (updatingSingleRow && grid.transitionDuration && !isExport) {
      grid.setTimeout(() => {
        if (!me.isDestroyed) {
          cls.remove("b-grid-row-updating");
          me.updateCls(cls);
        }
      }, grid.transitionDuration);
    }
    me.id = record.id;
    me.dataIndex = recordIndex;
    const height = !grid.fixedRowHeight && grid.getRowHeight(record) || rowHeight;
    let maxRequestedHeight = me.maxRequestedHeight = null;
    if (isTree) {
      for (const region in elements) {
        const el = elements[region];
        el.id = `${grid.id}-${region}-${me.id}`;
        DomHelper.setAttributes(el, {
          "aria-level": record.childLevel + 1,
          "aria-setsize": record.parent.children.length,
          "aria-posinset": record.parentIndex + 1
        });
        if (record.isExpanded(store)) {
          var _record$children, _record$children2;
          DomHelper.setAttributes(el, {
            "aria-expanded": true,
            "aria-owns": (_record$children = record.children) !== null && _record$children !== void 0 && _record$children.length ? (_record$children2 = record.children) === null || _record$children2 === void 0 ? void 0 : _record$children2.map((r) => `${grid.id}-${region}-${r.id}`).join(" ") : null
          });
        } else {
          if (record.isLeaf) {
            el.removeAttribute("aria-expanded");
          } else {
            el.setAttribute("aria-expanded", false);
          }
          el.removeAttribute("aria-owns");
        }
      }
    }
    cellContext._record = record;
    cellContext._id = record.id;
    cellContext._rowIndex = recordIndex;
    for (i = 0; i < cells.length; i++) {
      cellContext._columnId = cells[i].dataset.columnId;
      cellContext._column = grid.columns.getById(cellContext._columnId);
      cellContext._columnIndex = i;
      cellContext._cell = cells[i];
      cellContext.height = height;
      cellContext.maxRequestedHeight = maxRequestedHeight;
      cellContext.updatingSingleRow = updatingSingleRow;
      size = me.renderCell(cellContext);
      if (!rowManager.fixedRowHeight) {
        if (size.height != null) {
          maxRequestedHeight = Math.max(maxRequestedHeight, size.height);
          if (!size.transient) {
            me.maxRequestedHeight = maxRequestedHeight;
          }
        }
      }
    }
    const useHeight = (_maxRequestedHeight = maxRequestedHeight) !== null && _maxRequestedHeight !== void 0 ? _maxRequestedHeight : height;
    me.height = (_grid$processRowHeigh = grid.processRowHeight(record, useHeight)) !== null && _grid$processRowHeigh !== void 0 ? _grid$processRowHeigh : useHeight;
    me.updateElementsHeight(isExport);
    if (updatingSingleRow && !isExport) {
      if (oldHeight !== me.height) {
        rowManager.translateFromRow(me, batch);
      }
      rowManager.trigger("updateRow", {
        row: me,
        record,
        recordIndex,
        oldId
      });
      rowManager.trigger("renderDone");
    }
    grid.afterRenderRow({
      row: me,
      record,
      recordIndex,
      oldId,
      oldHeight,
      isExport
    });
    rowManager.trigger("renderRow", {
      row: me,
      record,
      recordIndex,
      oldId,
      isExport
    });
    if (oldHeight && me.height !== oldHeight) {
      rowManager.trigger("rowRowHeight", {
        row: me,
        record,
        height: me.height,
        oldHeight
      });
    }
    me.forceInnerHTML = false;
  }
  renderCell(cellContext) {
    var _grid$features, _grid$hasFrameworkRen;
    if (!cellContext.isLocation) {
      cellContext = new Location(cellContext);
    }
    let {
      cell: cellElement,
      record
    } = cellContext;
    const me = this, {
      grid,
      column,
      height,
      maxRequestedHeight,
      updatingSingleRow = true,
      isMeasuring = false
    } = cellContext, cellEdit = (_grid$features = grid.features) === null || _grid$features === void 0 ? void 0 : _grid$features.cellEdit, cellElementData = DomDataStore.get(cellElement), rowElement = cellElementData.rowElement, rowElementData = DomDataStore.get(rowElement);
    if (!record) {
      record = cellContext.record = grid.store.getById(rowElementData.id);
      if (!record) {
        return;
      }
    }
    let cellContent = column.getRawValue(record);
    const dataField = record.fieldMap[column.field], size = {
      configuredHeight: height,
      height: null,
      maxRequestedHeight
    }, cellCls = column.getCellClass(cellContext), rendererData = {
      cellElement,
      dataField,
      rowElement,
      value: cellContent,
      record,
      column,
      size,
      grid,
      row: cellElementData.row,
      updatingSingleRow,
      isMeasuring
    }, useRenderer = column.renderer || column.defaultRenderer;
    grid.beforeRenderCell(rendererData);
    if (rendererData.cellElement !== cellElement) {
      cellElement = rendererData.cellElement;
    }
    DomHelper.syncClassList(cellElement, cellCls);
    let shouldSetContent = true;
    if (useRenderer) {
      cellContent = useRenderer.call(column, rendererData);
      if (cellContent === void 0 && column.alwaysClearCell === false) {
        shouldSetContent = false;
      }
    } else if (dataField) {
      cellContent = dataField.print(cellContent);
    }
    const hasFrameworkRenderer = (_grid$hasFrameworkRen = grid.hasFrameworkRenderer) === null || _grid$hasFrameworkRen === void 0 ? void 0 : _grid$hasFrameworkRen.call(grid, {
      cellContent,
      column
    });
    if (hasFrameworkRenderer && record.isSpecialRow) {
      cellContent = "";
    }
    const frameworkPerformsFullRendering = hasFrameworkRenderer && !column.data.tree && !record.isSpecialRow;
    if (shouldSetContent && !frameworkPerformsFullRendering) {
      var _cellEdit$editorConte;
      let renderTarget = cellElement;
      if (cellEdit !== null && cellEdit !== void 0 && (_cellEdit$editorConte = cellEdit.editorContext) !== null && _cellEdit$editorConte !== void 0 && _cellEdit$editorConte.equals(cellContext) && !cellEdit.editor.isFinishing) {
        renderTarget = me.moveContentFromCell(cellElement, cellEdit.editor.element);
      }
      const hasObjectContent = cellContent != null && typeof cellContent === "object", hasStringContent = typeof cellContent === "string", text = hasObjectContent || cellContent == null ? "" : String(cellContent);
      if (me.forceInnerHTML) {
        renderTarget.innerHTML = "";
        delete renderTarget._content;
        cellElement.lastDomConfig = null;
      }
      if (!hasObjectContent && column.htmlEncode && !column.disableHtmlEncode) {
        if (cellElement._hasHtml) {
          renderTarget.innerText = text;
          cellElement._hasHtml = false;
        } else {
          DomHelper.setInnerText(renderTarget, text);
        }
      } else {
        if (column.autoSyncHtml && (!hasStringContent || DomHelper.getChildElementCount(renderTarget))) {
          if (hasStringContent) {
            DomHelper.sync(text, renderTarget.firstElementChild);
          } else if (hasObjectContent) {
            DomSync.sync({
              domConfig: cellContent,
              targetElement: renderTarget
            });
          }
        } else if (hasObjectContent) {
          DomSync.sync({
            targetElement: renderTarget,
            domConfig: {
              onlyChildren: true,
              children: ArrayHelper.asArray(cellContent)
            }
          });
        } else if (renderTarget._content !== text) {
          renderTarget.innerHTML = renderTarget._content = text;
        }
      }
      if (renderTarget !== cellElement) {
        const {
          firstChild
        } = cellElement;
        for (const node of renderTarget.childNodes) {
          cellElement.insertBefore(node, firstChild);
        }
      }
    }
    if (!record.isSpecialRow) {
      var _grid$processCellCont;
      (_grid$processCellCont = grid.processCellContent) === null || _grid$processCellCont === void 0 ? void 0 : _grid$processCellCont.call(grid, {
        cellElementData,
        rendererData,
        rendererHtml: rendererData.rendererHtml || cellContent
      });
    }
    if (column.autoHeight && size.height == null) {
      cellElement.classList.add("b-measuring-auto-height");
      size.height = Math.max(cellElement.offsetHeight, grid.rowHeight);
      cellElement.classList.remove("b-measuring-auto-height");
    }
    if (!isMeasuring) {
      me.rowManager.trigger("renderCell", rendererData);
    }
    return size;
  }
  moveContentFromCell(cellElement, editorElement) {
    cellContentRange.setStart(cellElement, 0);
    cellContentRange.setEndBefore(editorElement);
    const renderTarget = document.createElement("div");
    renderTarget.appendChild(cellContentRange.extractContents());
    return renderTarget;
  }
};
_defineProperty(Row, "$name", "Row");
Row.initClass();
Row._$name = "Row";
var Exporter = class extends Delayable(Events(Localizable(Base$1))) {
  static get defaultConfig() {
    return {
      translateURLsToAbsolute: true,
      keepPathName: true,
      filterStyles: (styles) => styles
    };
  }
  pageTpl(data) {
    const {
      title,
      header,
      footer,
      styles,
      htmlClasses,
      bodyStyle,
      bodyClasses = [],
      paperHeight,
      paperWidth,
      html
    } = data;
    bodyClasses.push(`b-${this.constructor.type}`);
    if (DomHelper.scrollBarWidth) {
      bodyClasses.push("b-visible-scrollbar");
    } else {
      bodyClasses.push("b-overlay-scrollbar");
    }
    if (BrowserHelper.isChrome) {
      bodyClasses.push("b-chrome");
    } else if (BrowserHelper.isSafari) {
      bodyClasses.push("b-safari");
    } else if (BrowserHelper.isFirefox) {
      bodyClasses.push("b-firefox");
    }
    return TemplateHelper.tpl`
            <!DOCTYPE html>
            <html class="${htmlClasses}" style="width: ${paperWidth}in; height: ${paperHeight}in;">
                <head>
                    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
                    <title>${title}</title>
                    ${styles.join("")}
                </head>
                <body class="b-export ${bodyClasses.join(" ")}" style="width: ${paperWidth}in; height: ${paperHeight}in; ${bodyStyle}">
                    <div class="b-export-content">
                        ${header && `<div class="b-export-header" style="width: 100%">${header}</div>`}
                        <div class="b-export-body"><div class="b-export-viewport">${html}</div></div>
                        ${footer && `<div class="b-export-footer" style="width: 100%">${footer}</div>`}
                    </div>
                </body>
            </html>`;
  }
  get stylesheets() {
    const me = this;
    if (me._stylesheets) {
      return me._stylesheets;
    }
    const translate = me.translateURLsToAbsolute, origin = globalThis.origin, styleSheetNodes = Array.from(document.querySelectorAll('link[rel="stylesheet"], style')), styles = [];
    styleSheetNodes.forEach((node) => {
      node = node.cloneNode(true);
      if (translate && node.href) {
        let result;
        if (translate === true) {
          result = node.href;
        } else if (this.keepPathName) {
          result = node.href.replace(origin, translate);
        } else {
          result = new URL(node.getAttribute("href"), translate);
        }
        node.setAttribute("href", result);
      }
      let styleText = node.outerHTML;
      if (translate && /style/i.test(node.tagName)) {
        const converter = me.getStyleTagURLConverter(translate);
        styleText = styleText.replace(/url\(['"]?(.+?)['"]?\)/g, converter);
      }
      styles.push(styleText);
    });
    styles.push(`<style>
                body, html {
                    overflow: auto;
                }
                body {
                    position: relative;
                    margin: 0;
                }
            </style>`);
    return me._stylesheets = me.filterStyles(styles);
  }
  set stylesheets(value) {
    this._stylesheets = value ? this.filterStyles(value) : value;
  }
  getStyleTagURLConverter(translate) {
    return function(match, url) {
      let result;
      try {
        let base;
        if (/^#/.test(url)) {
          result = match;
        } else {
          if (translate === true) {
            base = globalThis.location.href;
          } else if (this.keepPathName) {
            base = globalThis.location.href.replace(globalThis.location.origin, translate);
          } else {
            base = translate;
          }
          result = `url('${new URL(url, base).href}')`;
        }
      } catch (e) {
        result = match;
      }
      return result;
    }.bind(this);
  }
  saveState({
    client
  }) {
    this.state = client.state;
  }
  async restoreState({
    client
  }) {
    const promises = [], detachers = /* @__PURE__ */ new Set();
    detachers.add(client.scrollable.ion({
      scroll() {
        promises.push(client.scrollable.await("scrollEnd"));
      }
    }));
    client.eachSubGrid(({
      header,
      scrollable
    }) => {
      detachers.add(scrollable.ion({
        scroll() {
          promises.push(scrollable.await("scrollEnd"));
        }
      }));
      detachers.add(header.scrollable.ion({
        scroll() {
          promises.push(header.scrollable.await("scrollEnd"));
        }
      }));
    });
    client.state = this.state;
    await Promise.all(promises);
    detachers.forEach((fn2) => fn2());
  }
  beforeExport() {
    this.element = document.createElement("div");
  }
  cloneElement(element, target = this.element, clear = true) {
    if (clear) {
      target.innerHTML = "";
    }
    target.appendChild(element.cloneNode(true));
    DomHelper.removeEachSelector(target, ".b-grid-row,.b-grid-merged-cells-container");
    const maskEl = target.querySelector(".b-gridbase > .b-mask");
    if (maskEl) {
      maskEl.remove();
    }
  }
  createPlaceholder(el, clear = true, config = {}) {
    if (clear) {
      el.innerHTML = "";
    }
    return DomHelper.createElement(Object.assign({
      parent: el,
      id: IdHelper.generateId("export")
    }, config));
  }
  prepareElement({
    client
  }) {
    const {
      tbar,
      bbar
    } = client;
    if (tbar) {
      this.element.querySelector(`#${tbar.id}`).remove();
    }
    if (bbar) {
      this.element.querySelector(`#${bbar.id}`).remove();
    }
  }
  measureElement(html = "") {
    if (html instanceof HTMLElement) {
      html = html.outerHTML;
    }
    const target = DomHelper.createElement({
      parent: document.body,
      style: {
        visibility: "hidden",
        position: "absolute"
      },
      html: `<div style="height: 1px"></div>${html}<div style="height: 1px"></div>`
    });
    const result = target.offsetHeight - 2;
    target.remove();
    return result;
  }
  prepareHTML(html) {
    if (html instanceof HTMLElement) {
      html = html.outerHTML;
    }
    const target = DomHelper.createElement({
      parent: document.body,
      style: {
        visibility: "hidden",
        position: "absolute"
      },
      html
    });
    const elements = target.querySelectorAll("img");
    for (let i = 0, l = elements.length; i < l; i++) {
      elements[i].setAttribute("src", elements[i].src);
    }
    const result = target.innerHTML;
    target.remove();
    return result;
  }
  getVirtualScrollerHeight(client) {
    let result = 0;
    client.eachSubGrid((subGrid) => {
      if (subGrid.overflowingHorizontally) {
        result = DomHelper.scrollBarWidth;
      }
    });
    return result === 0 ? result : result + 1;
  }
  inchToPx(value) {
    return value * 96;
  }
  getScaleValue(base, value) {
    return Math.floor(base * 1e4 / value) / 1e4;
  }
  getVisibleRowsCount(client) {
    const rowManager = client.rowManager, firstVisibleIndex = rowManager.rows.indexOf(rowManager.firstVisibleRow), lastVisibleIndex = rowManager.rows.indexOf(rowManager.lastVisibleRow);
    let result;
    if (firstVisibleIndex !== -1) {
      if (lastVisibleIndex === -1) {
        result = client.store.count - firstVisibleIndex;
      } else {
        result = lastVisibleIndex - firstVisibleIndex + 1;
      }
    } else {
      result = client.store.count;
    }
    return result;
  }
  async export(config) {
    const me = this;
    let pages;
    me.beforeExport();
    me.saveState(config);
    await me.prepareComponent(config);
    try {
      pages = await me.getPages(config);
    } finally {
      await me.restoreComponent(config);
      me.stylesheets = null;
      await new Promise((resolve) => me.requestAnimationFrame(resolve));
      await me.restoreState(config);
    }
    return pages;
  }
  async getPages(config) {
    const generator = this.pagesExtractor(config), pages = [];
    let step;
    while ((step = await generator.next()) && !step.done) {
      pages.push(step.value);
    }
    return pages;
  }
  adjustRowBuffer(client) {
    const {
      contentHeight
    } = this.exportMeta, {
      rowManager
    } = client;
    this.oldRowManagerConfig = {
      prependRowBuffer: rowManager.prependRowBuffer,
      appendRowBuffer: rowManager.appendRowBuffer
    };
    const adjustedRowBuffer = Math.ceil(contentHeight / rowManager.rowOffsetHeight);
    rowManager.prependRowBuffer = adjustedRowBuffer;
    rowManager.appendRowBuffer = adjustedRowBuffer;
    client.renderRows();
    client.rowManager.jumpToPosition(client.scrollable.y);
  }
  restoreRowBuffer(client) {
    client.rowManager.prependRowBuffer = this.oldRowManagerConfig.prependRowBuffer;
    client.rowManager.appendRowBuffer = this.oldRowManagerConfig.appendRowBuffer;
  }
  async prepareComponent(config) {
    const me = this, {
      client,
      columns,
      rowsRange,
      keepRegionSizes,
      enableDirectRendering
    } = config, {
      rowManager
    } = client, exportMeta = me.exportMeta = {
      enableDirectRendering,
      totalWidth: 0,
      totalHeight: 0 - (enableDirectRendering ? 0 : me.getVirtualScrollerHeight(client)),
      subGrids: {}
    };
    client.columns.forEach((column) => {
      if (columns.includes(column.id)) {
        column.show();
      } else {
        column.hide();
      }
    });
    await new Promise((resolve) => client.requestAnimationFrame(resolve));
    if (client.rowManager.rowCount > 0) {
      if (rowsRange === RowsRange.all) {
        exportMeta.firstVisibleDataIndex = rowManager.rows[0].dataIndex;
      } else {
        exportMeta.firstVisibleDataIndex = rowManager.firstVisibleRow.dataIndex;
        config.alignRows = true;
      }
      if (!enableDirectRendering) {
        await client.scrollRowIntoView(client.store.getAt(exportMeta.firstVisibleDataIndex), {
          block: "start"
        });
      }
    }
    const {
      element
    } = me;
    me.cloneElement(client.element);
    me.prepareElement(config);
    let fakeRow;
    if (enableDirectRendering) {
      exportMeta.fakeRow = fakeRow = new Row({
        cls: client.rowCls,
        rowManager: client.rowManager,
        grid: client,
        index: -10,
        dataIndex: -10
      });
    }
    client.eachSubGrid((subGrid) => {
      var _subGrid$splitterElem, _subGrid$header, _subGrid$footer;
      if (fakeRow) {
        subGrid.onAddRow({
          rows: [fakeRow],
          isExport: true
        });
        fakeRow.element.dataset.ownerCmp = client.id;
      }
      const placeHolder = me.createPlaceholder(element.querySelector(`[id="${subGrid.id}"]`), false);
      let width;
      if (keepRegionSizes !== null && keepRegionSizes !== void 0 && keepRegionSizes[subGrid.region]) {
        width = subGrid.element.offsetWidth;
      } else {
        width = subGrid.columns.visibleColumns.reduce((result, column) => {
          if (typeof column.width === "number") {
            result += column.width;
          } else {
            result += (client.hideHeaders ? client.rowManager.rows[0].getCell(column.id) : column.element).offsetWidth;
          }
          return result;
        }, 0);
      }
      exportMeta.totalWidth += width;
      const splitterWidth = ((_subGrid$splitterElem = subGrid.splitterElement) === null || _subGrid$splitterElem === void 0 ? void 0 : _subGrid$splitterElem.offsetWidth) || 0;
      exportMeta.totalWidth += splitterWidth;
      exportMeta.subGrids[subGrid.region] = {
        id: subGrid.id,
        headerId: ((_subGrid$header = subGrid.header) === null || _subGrid$header === void 0 ? void 0 : _subGrid$header.id) || null,
        footerId: ((_subGrid$footer = subGrid.footer) === null || _subGrid$footer === void 0 ? void 0 : _subGrid$footer.id) || null,
        rows: [],
        splitterWidth,
        placeHolder,
        width
      };
    });
  }
  prepareExportElement() {
    const me = this, {
      element,
      exportMeta
    } = me;
    Object.values(exportMeta.subGrids).forEach(({
      width,
      id,
      headerId,
      footerId
    }) => {
      [id, headerId, footerId].forEach((id2) => {
        if (id2) {
          const childElement = element.querySelector(`[id="${id2}"]`);
          if (childElement) {
            childElement.style.width = `${width}px`;
            childElement.style.flex = "";
          }
        }
      });
    });
    return element.innerHTML;
  }
  async restoreComponent(config) {
    if (this.exportMeta.fakeRow) {
      this.exportMeta.fakeRow.destroy();
      delete this.exportMeta.fakeRow;
    }
  }
  async scrollRowIntoView(client, index) {
    await client.scrollRowIntoView(client.store.getAt(index), {
      block: "start"
    });
    await new Promise((resolve) => this.requestAnimationFrame(resolve));
  }
  collectRow(row) {
    const subGrids = this.exportMeta.subGrids, re = /data-owner-cmp=".+?"/;
    Object.entries(row.elements).forEach(([key, value]) => {
      subGrids[key].rows.push([
        value.outerHTML.replace(re, ""),
        row.top,
        row.offsetHeight,
        /* @__PURE__ */ new Map()
      ]);
    });
  }
  renderMergedCells(config, fromIndex, toIndex, rows) {
    const me = this, {
      client
    } = config, {
      subGrids
    } = me.exportMeta, domConfigMap = client.features.mergeCells.buildMergedCellsConfig(fromIndex, toIndex, rows);
    for (const subGridName in subGrids) {
      const subGrid = subGrids[subGridName], target = document.createElement("div");
      DomSync.sync({
        targetElement: target,
        domConfig: {
          children: domConfigMap[subGridName].children
        }
      });
      if (target.childNodes.length) {
        target.childNodes.forEach((child) => {
          const {
            syncId
          } = child.dataset, range = client.features.mergeCells.mergedRanges.find((range2) => {
            var _range$cellElement;
            return ((_range$cellElement = range2.cellElement) === null || _range$cellElement === void 0 ? void 0 : _range$cellElement.parentNode.dataset.syncId) === syncId;
          });
          if (range) {
            child.innerHTML = range.cellElement.outerHTML;
          }
        });
        subGrid.mergedCellsHtml = [target.innerHTML];
      }
    }
  }
};
Exporter.prototype.pagesExtractor = async function* pagesExtractor() {
  throw new Error("Implement this method in a subclass");
};
Exporter._$name = "Exporter";
var MultiPageExporter$1 = class extends Exporter {
  static get $name() {
    return "MultiPageExporter";
  }
  static get type() {
    return "multipage";
  }
  static get title() {
    return this.L("L{multipage}");
  }
  static get exportingPageText() {
    return "L{exportingPage}";
  }
  async stateNextPage({
    client,
    rowsRange,
    enableDirectRendering
  }) {
    const {
      exportMeta
    } = this;
    ++exportMeta.currentPage;
    ++exportMeta.verticalPosition;
    delete exportMeta.lastExportedRowBottom;
    if (exportMeta.verticalPosition >= exportMeta.verticalPages) {
      Object.assign(exportMeta, {
        verticalPosition: 0,
        horizontalPosition: exportMeta.horizontalPosition + 1,
        currentPageTopMargin: 0,
        lastTop: 0,
        lastRowIndex: rowsRange === RowsRange.visible ? client.rowManager.firstVisibleRow.dataIndex : 0
      });
      delete exportMeta.lastRowDataIndex;
      if (!enableDirectRendering) {
        await this.scrollRowIntoView(client, exportMeta.firstVisibleDataIndex, {
          block: "start"
        });
      }
    }
  }
  async prepareComponent(config) {
    await super.prepareComponent(config);
    const me = this, {
      exportMeta
    } = me, {
      client,
      headerTpl,
      footerTpl,
      alignRows,
      rowsRange,
      enableDirectRendering
    } = config, paperFormat = PaperFormat[config.paperFormat], isPortrait = config.orientation === Orientation.portrait, paperWidth = isPortrait ? paperFormat.width : paperFormat.height, paperHeight = isPortrait ? paperFormat.height : paperFormat.width, pageWidth = me.inchToPx(paperWidth), pageHeight = me.inchToPx(paperHeight), onlyVisibleRows = rowsRange === RowsRange.visible, horizontalPages = Math.ceil(exportMeta.totalWidth / pageWidth);
    let contentHeight = pageHeight;
    if (headerTpl) {
      contentHeight -= me.measureElement(headerTpl({
        totalWidth: exportMeta.totalWidth,
        totalPages: -1,
        currentPage: -1
      }));
    }
    if (footerTpl) {
      contentHeight -= me.measureElement(footerTpl({
        totalWidth: exportMeta.totalWidth,
        totalPages: -1,
        currentPage: -1
      }));
    }
    let totalHeight, verticalPages, totalRows = client.store.count;
    if (onlyVisibleRows) {
      totalRows = me.getVisibleRowsCount(client);
      totalHeight = exportMeta.totalHeight + client.headerHeight + client.footerHeight + client.bodyHeight;
    } else {
      totalHeight = exportMeta.totalHeight + client.headerHeight + client.footerHeight + client.scrollable.scrollHeight;
    }
    if (alignRows && !onlyVisibleRows) {
      const rowHeight = client.rowManager.rowOffsetHeight, rowsOnFirstPage = Math.floor((contentHeight - client.headerHeight) / rowHeight), rowsPerPage = Math.floor(contentHeight / rowHeight), remainingRows = totalRows - rowsOnFirstPage;
      verticalPages = 1 + Math.ceil(remainingRows / rowsPerPage);
    } else {
      verticalPages = Math.ceil(totalHeight / contentHeight);
    }
    Object.assign(exportMeta, {
      paperWidth,
      paperHeight,
      pageWidth,
      pageHeight,
      horizontalPages,
      verticalPages,
      totalHeight,
      contentHeight,
      totalRows,
      totalPages: horizontalPages * verticalPages,
      currentPage: 0,
      verticalPosition: 0,
      horizontalPosition: 0,
      currentPageTopMargin: 0,
      lastTop: 0,
      lastRowIndex: onlyVisibleRows ? client.rowManager.firstVisibleRow.dataIndex : 0
    });
    if (!enableDirectRendering) {
      this.adjustRowBuffer(client);
    }
  }
  async restoreComponent(config) {
    await super.restoreComponent(config);
    if (!config.enableDirectRendering) {
      this.restoreRowBuffer(config.client);
    }
  }
  async collectRows(config) {
    const me = this, {
      exportMeta
    } = me, {
      client,
      alignRows,
      rowsRange
    } = config, {
      subGrids,
      currentPageTopMargin,
      verticalPosition,
      contentHeight,
      totalRows,
      lastRowDataIndex
    } = exportMeta, {
      rowManager
    } = client, {
      rows
    } = rowManager, onlyVisible = rowsRange === RowsRange.visible, hasMergeCells = client.hasActiveFeature("mergeCells");
    let remainingHeight, index;
    if (onlyVisible && lastRowDataIndex != null) {
      if (lastRowDataIndex === rows[rows.length - 1].dataIndex) {
        index = rows.length - 1;
      } else {
        index = rows.findIndex((r) => r.dataIndex === lastRowDataIndex);
      }
    } else {
      index = onlyVisible ? rows.findIndex((r) => r.bottom > Math.ceil(client.scrollable.y)) : rows.findIndex((r) => r.bottom + currentPageTopMargin + client.headerHeight > 0);
    }
    const firstRowIndex = index, overflowingHeight = onlyVisible || verticalPosition === 0 ? 0 : rows[index].top + currentPageTopMargin + client.headerHeight;
    remainingHeight = contentHeight - overflowingHeight;
    if (verticalPosition === 0) {
      remainingHeight -= client.headerHeight;
    }
    let lastDataIndex, offset = 0;
    while (remainingHeight > 0) {
      const row = rows[index];
      if (alignRows && remainingHeight < row.offsetHeight) {
        offset = -remainingHeight;
        remainingHeight = 0;
        me.exportMeta.lastExportedRowBottom = rows[index - 1].bottom;
      } else {
        me.collectRow(row);
        remainingHeight -= row.offsetHeight;
        lastDataIndex = row.dataIndex;
        if (++index === rows.length && remainingHeight > 0) {
          remainingHeight = 0;
        } else if (onlyVisible && index - firstRowIndex === totalRows) {
          remainingHeight = 0;
        }
      }
    }
    if (hasMergeCells) {
      for (const subGridName in subGrids) {
        const subGrid = subGrids[subGridName], mergedCells = client.subGrids[subGridName].element.querySelectorAll(`.b-grid-merged-cells`);
        subGrid.mergedCellsHtml = [];
        for (const mergedCell of mergedCells) {
          subGrid.mergedCellsHtml.push(mergedCell.outerHTML);
        }
      }
    }
    const lastRow = rows[index - 1];
    if (lastRow) {
      exportMeta.exactGridHeight = lastRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;
      exportMeta.lastRowDataIndex = lastRow.dataIndex + 1;
    }
    await me.onRowsCollected(rows.slice(firstRowIndex, index), config);
    if (onlyVisible) {
      exportMeta.exactGridHeight -= exportMeta.scrollableTopMargin = client.scrollable.y;
    } else {
      const detacher2 = rowManager.ion({
        offsetRows: ({
          offset: value
        }) => offset += value
      });
      await me.scrollRowIntoView(client, lastDataIndex + 1);
      detacher2();
    }
    return offset;
  }
  async renderRows(config) {
    const me = this, {
      exportMeta
    } = me, {
      client,
      alignRows,
      rowsRange
    } = config, {
      currentPageTopMargin,
      verticalPosition,
      contentHeight,
      totalRows,
      lastRowIndex,
      fakeRow
    } = exportMeta, {
      store
    } = client, hasMergeCells = client.hasActiveFeature("mergeCells"), onlyVisibleRows = rowsRange === RowsRange.visible;
    let index = lastRowIndex, {
      lastTop
    } = exportMeta, remainingHeight;
    const firstRowIndex = index, overflowingHeight = onlyVisibleRows || verticalPosition === 0 ? 0 : lastTop + currentPageTopMargin + client.headerHeight, rows = [];
    remainingHeight = contentHeight - overflowingHeight;
    if (verticalPosition === 0) {
      remainingHeight -= client.headerHeight;
    }
    let lastDataIndex, previousTop, offset = 0;
    while (remainingHeight > 0) {
      fakeRow.render(index, store.getAt(index), true, false, true);
      if (alignRows && remainingHeight < fakeRow.offsetHeight) {
        offset = -remainingHeight;
        remainingHeight = 0;
        me.exportMeta.lastExportedRowBottom = lastTop;
      } else {
        previousTop = lastTop;
        lastDataIndex = index;
        lastTop = fakeRow.translate(lastTop);
        remainingHeight -= fakeRow.offsetHeight;
        me.collectRow(fakeRow);
        rows.push({
          top: fakeRow.top,
          bottom: fakeRow.bottom,
          offsetHeight: fakeRow.offsetHeight,
          dataIndex: fakeRow.dataIndex
        });
        if (++index === store.count && remainingHeight > 0) {
          remainingHeight = 0;
        } else if (onlyVisibleRows && index - firstRowIndex === totalRows) {
          remainingHeight = 0;
        }
      }
    }
    if (hasMergeCells) {
      me.renderMergedCells(config, firstRowIndex, index, rows);
    }
    exportMeta.lastRowIndex = alignRows ? index : lastDataIndex;
    exportMeta.lastTop = alignRows ? lastTop : previousTop;
    if (fakeRow) {
      exportMeta.exactGridHeight = fakeRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;
    }
    await me.onRowsCollected(rows, config);
    return offset;
  }
  async buildPage(config) {
    const me = this, {
      exportMeta
    } = me, {
      client,
      headerTpl,
      footerTpl,
      enableDirectRendering
    } = config, {
      totalWidth,
      totalPages,
      currentPage,
      subGrids
    } = exportMeta;
    Object.values(subGrids).forEach((subGrid) => subGrid.rows = []);
    if (config.rowsRange === RowsRange.all) {
      exportMeta.totalHeight = client.height - client.bodyHeight + client.scrollable.scrollHeight - me.getVirtualScrollerHeight(client);
    }
    let header, footer;
    if (headerTpl) {
      header = me.prepareHTML(headerTpl({
        totalWidth,
        totalPages,
        currentPage
      }));
    }
    if (footerTpl) {
      footer = me.prepareHTML(footerTpl({
        totalWidth,
        totalPages,
        currentPage
      }));
    }
    let offset;
    if (enableDirectRendering) {
      offset = await me.renderRows(config);
    } else {
      offset = await me.collectRows(config);
    }
    const html = me.buildPageHtml(config);
    return {
      html,
      header,
      footer,
      offset
    };
  }
  async onRowsCollected() {
  }
  buildPageHtml() {
    const me = this, {
      subGrids
    } = me.exportMeta;
    let html = me.prepareExportElement();
    Object.values(subGrids).forEach(({
      placeHolder,
      rows,
      mergedCellsHtml
    }) => {
      const placeHolderText = placeHolder.outerHTML;
      let contentHtml = rows.reduce((result, row) => {
        result += row[0];
        return result;
      }, "");
      if (mergedCellsHtml !== null && mergedCellsHtml !== void 0 && mergedCellsHtml.length) {
        contentHtml += `<div class="b-grid-merged-cells-container">${mergedCellsHtml.join("")}</div>`;
      }
      html = html.replace(placeHolderText, contentHtml);
    });
    return html;
  }
  prepareExportElement() {
    const me = this, {
      element,
      exportMeta
    } = me;
    if (exportMeta.scrollableTopMargin) {
      element.querySelector(".b-grid-vertical-scroller").style.marginTop = `-${exportMeta.scrollableTopMargin}px`;
    }
    return super.prepareExportElement();
  }
};
MultiPageExporter$1.prototype.pagesExtractor = async function* pagesExtractor2(config) {
  const me = this, {
    exportMeta,
    stylesheets
  } = me, {
    totalWidth,
    totalPages,
    paperWidth,
    paperHeight,
    contentHeight
  } = exportMeta;
  let currentPage;
  while ((currentPage = exportMeta.currentPage) < totalPages) {
    me.trigger("exportStep", {
      text: me.L(MultiPageExporter$1.exportingPageText, {
        currentPage,
        totalPages
      }),
      progress: Math.round((currentPage + 1) / totalPages * 90)
    });
    const {
      html,
      header,
      footer,
      offset
    } = await me.buildPage(config);
    const styles = [...stylesheets, `
                <style>
                    #${config.client.id} {
                        height: ${exportMeta.exactGridHeight}px !important;
                        width: ${totalWidth}px !important;
                    }
                    .b-export-body .b-export-viewport {
                        margin-inline-start : ${-paperWidth * exportMeta.horizontalPosition}in;
                        margin-top  : ${exportMeta.currentPageTopMargin}px;
                    }
                </style>
            `];
    exportMeta.currentPageTopMargin -= contentHeight + offset;
    await me.stateNextPage(config);
    yield {
      html: me.pageTpl({
        html,
        header,
        footer,
        styles,
        paperWidth,
        paperHeight
      })
    };
  }
};
MultiPageExporter$1._$name = "MultiPageExporter";
var MultiPageVerticalExporter$1 = class extends Exporter {
  static get $name() {
    return "MultiPageVerticalExporter";
  }
  static get type() {
    return "multipagevertical";
  }
  static get title() {
    return this.L("L{multipagevertical}");
  }
  static get exportingPageText() {
    return "L{exportingPage}";
  }
  async stateNextPage({
    client
  }) {
    const {
      exportMeta
    } = this, {
      totalRows,
      processedRows,
      totalPages
    } = exportMeta;
    ++exportMeta.currentPage;
    ++exportMeta.verticalPosition;
    if (exportMeta.currentPage === totalPages && processedRows.size !== totalRows) {
      ++exportMeta.totalPages;
      ++exportMeta.verticalPages;
    }
  }
  estimateTotalPages(config) {
    const me = this, {
      exportMeta
    } = me, {
      client,
      headerTpl,
      footerTpl,
      alignRows,
      rowsRange,
      repeatHeader,
      enableDirectRendering
    } = config, {
      pageWidth,
      pageHeight,
      totalWidth
    } = exportMeta, scale = me.getScaleValue(pageWidth, totalWidth);
    let totalHeight = 0 - me.getVirtualScrollerHeight(client) + client.height - client.bodyElement.offsetHeight + client.scrollable.scrollHeight, contentHeight = pageHeight / scale, totalRows = client.store.count, initialScroll = 0, rowsHeight = totalHeight, verticalPages;
    if (headerTpl) {
      contentHeight -= me.measureElement(headerTpl({
        totalWidth,
        totalPages: -1,
        currentPage: -1
      }));
    }
    if (footerTpl) {
      contentHeight -= me.measureElement(footerTpl({
        totalWidth,
        totalPages: -1,
        currentPage: -1
      }));
    }
    if (repeatHeader) {
      contentHeight -= client.headerHeight + client.footerHeight;
      totalHeight -= client.headerHeight + client.footerHeight;
    }
    if (rowsRange === RowsRange.visible) {
      const rowManager = client.rowManager, firstRow = rowManager.firstVisibleRow, lastRow = rowManager.lastVisibleRow;
      if (!enableDirectRendering) {
        initialScroll = firstRow.top;
      }
      totalRows = me.getVisibleRowsCount(client);
      if (enableDirectRendering) {
        totalHeight = client.headerHeight + client.footerHeight + lastRow.bottom - firstRow.top;
        rowsHeight = lastRow.bottom - firstRow.top;
      } else {
        rowsHeight = totalHeight = totalHeight - client.scrollable.scrollHeight + lastRow.bottom - firstRow.top;
      }
      exportMeta.lastRowIndex = firstRow.dataIndex;
      exportMeta.finishRowIndex = lastRow.dataIndex;
    } else {
      exportMeta.finishRowIndex = client.store.count - 1;
    }
    if (alignRows && !repeatHeader && rowsRange !== RowsRange.visible) {
      const rowHeight = client.rowManager.rowOffsetHeight, rowsOnFirstPage = Math.floor((contentHeight - client.headerHeight) / rowHeight), rowsPerPage = Math.floor(contentHeight / rowHeight), remainingRows = totalRows - rowsOnFirstPage;
      verticalPages = 1 + Math.ceil(remainingRows / rowsPerPage);
    } else {
      verticalPages = Math.ceil(rowsHeight / contentHeight);
    }
    Object.assign(exportMeta, {
      scale,
      contentHeight,
      totalRows,
      totalHeight,
      verticalPages,
      initialScroll,
      horizontalPages: 1,
      totalPages: verticalPages
    });
  }
  async prepareComponent(config) {
    await super.prepareComponent(config);
    const me = this, {
      exportMeta
    } = me, {
      client
    } = config, paperFormat = PaperFormat[config.paperFormat], isPortrait = config.orientation === Orientation.portrait, paperWidth = isPortrait ? paperFormat.width : paperFormat.height, paperHeight = isPortrait ? paperFormat.height : paperFormat.width, pageWidth = me.inchToPx(paperWidth), pageHeight = me.inchToPx(paperHeight), horizontalPages = 1;
    Object.assign(exportMeta, {
      paperWidth,
      paperHeight,
      pageWidth,
      pageHeight,
      horizontalPages,
      currentPage: 0,
      verticalPosition: 0,
      horizontalPosition: 0,
      currentPageTopMargin: 0,
      lastTop: 0,
      lastRowIndex: 0,
      processedRows: /* @__PURE__ */ new Set()
    });
    me.estimateTotalPages(config);
    if (!config.enableDirectRendering) {
      me.adjustRowBuffer(client);
    }
  }
  async restoreComponent(config) {
    await super.restoreComponent(config);
    if (!config.enableDirectRendering) {
      this.restoreRowBuffer(config.client);
    }
  }
  async collectRows(config) {
    const me = this, {
      exportMeta
    } = me, {
      client,
      alignRows,
      repeatHeader
    } = config, {
      subGrids,
      currentPageTopMargin,
      verticalPosition,
      totalRows,
      contentHeight
    } = exportMeta, clientHeaderHeight = repeatHeader ? 0 : client.headerHeight, {
      rowManager
    } = client, {
      rows
    } = rowManager, onlyVisibleRows = config.rowsRange === RowsRange.visible, hasMergeCells = client.hasActiveFeature("mergeCells");
    let index = onlyVisibleRows ? rows.findIndex((r) => r.bottom > client.scrollable.y) : rows.findIndex((r) => r.bottom + currentPageTopMargin + clientHeaderHeight > 0), remainingHeight;
    const firstRowIndex = index, overflowingHeight = verticalPosition === 0 ? 0 : rows[index].top + currentPageTopMargin + clientHeaderHeight;
    remainingHeight = contentHeight - overflowingHeight;
    if (verticalPosition === 0) {
      remainingHeight -= clientHeaderHeight;
    }
    let lastDataIndex, offset = 0;
    while (remainingHeight > 0) {
      const row = rows[index];
      if (alignRows && remainingHeight < row.offsetHeight) {
        offset = -remainingHeight;
        remainingHeight = 0;
      } else {
        me.collectRow(row);
        remainingHeight -= row.offsetHeight;
        if (remainingHeight > 0) {
          exportMeta.processedRows.add(row.dataIndex);
        }
        lastDataIndex = row.dataIndex;
        if (++index === rows.length && remainingHeight > 0) {
          remainingHeight = 0;
        } else if (onlyVisibleRows && index - firstRowIndex === totalRows) {
          remainingHeight = 0;
        }
      }
    }
    if (hasMergeCells) {
      for (const subGridName in subGrids) {
        const subGrid = subGrids[subGridName], mergedCells = client.subGrids[subGridName].element.querySelectorAll(`.b-grid-merged-cells`);
        subGrid.mergedCellsHtml = [];
        for (const mergedCell of mergedCells) {
          subGrid.mergedCellsHtml.push(mergedCell.outerHTML);
        }
      }
    }
    const lastRow = rows[index - 1];
    if (lastRow) {
      exportMeta.exactGridHeight = lastRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;
    }
    await me.onRowsCollected(rows.slice(firstRowIndex, index), config);
    if (onlyVisibleRows) {
      exportMeta.scrollableTopMargin = client.scrollable.y;
    } else {
      const detacher2 = rowManager.ion({
        offsetRows: ({
          offset: value
        }) => offset += value
      });
      await me.scrollRowIntoView(client, lastDataIndex + 1);
      detacher2();
    }
    return offset;
  }
  async renderRows(config) {
    const me = this, {
      exportMeta
    } = me, {
      client,
      alignRows,
      repeatHeader
    } = config, {
      currentPageTopMargin,
      verticalPosition,
      totalRows,
      contentHeight,
      lastRowIndex,
      finishRowIndex,
      fakeRow
    } = exportMeta, clientHeaderHeight = repeatHeader ? 0 : client.headerHeight, {
      store
    } = client, hasMergeCells = client.hasActiveFeature("mergeCells"), onlyVisibleRows = config.rowsRange === RowsRange.visible;
    let index = lastRowIndex, {
      lastTop
    } = exportMeta, remainingHeight;
    const firstRowIndex = index, overflowingHeight = verticalPosition === 0 ? 0 : lastTop + currentPageTopMargin + clientHeaderHeight, rows = [];
    remainingHeight = contentHeight - overflowingHeight;
    if (verticalPosition === 0) {
      remainingHeight -= clientHeaderHeight;
    }
    let lastDataIndex, nextPageTop, offset = 0;
    while (remainingHeight > 0) {
      fakeRow.render(index, store.getAt(index), true, false, true);
      if (alignRows && remainingHeight < fakeRow.offsetHeight) {
        offset = -remainingHeight;
        remainingHeight = 0;
      } else {
        nextPageTop = lastTop;
        lastDataIndex = index;
        lastTop = fakeRow.translate(lastTop);
        remainingHeight -= fakeRow.offsetHeight;
        me.collectRow(fakeRow);
        rows.push({
          top: fakeRow.top,
          bottom: fakeRow.bottom,
          offsetHeight: fakeRow.offsetHeight,
          dataIndex: fakeRow.dataIndex
        });
        if (remainingHeight > 0) {
          exportMeta.processedRows.add(index);
        }
        if (index === finishRowIndex) {
          remainingHeight = 0;
        } else if (++index - firstRowIndex === totalRows && onlyVisibleRows) {
          remainingHeight = 0;
        }
      }
    }
    if (hasMergeCells) {
      me.renderMergedCells(config, firstRowIndex, index, rows);
    }
    exportMeta.lastRowIndex = lastDataIndex;
    exportMeta.lastTop = nextPageTop;
    if (fakeRow) {
      exportMeta.exactGridHeight = fakeRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;
    }
    await me.onRowsCollected(rows, config);
    return offset;
  }
  async buildPage(config) {
    const me = this, {
      exportMeta
    } = me, {
      client,
      headerTpl,
      footerTpl,
      enableDirectRendering
    } = config, {
      totalWidth,
      totalPages,
      currentPage,
      subGrids
    } = exportMeta;
    Object.values(subGrids).forEach((subGrid) => subGrid.rows = []);
    if (config.rowsRange === RowsRange.all) {
      exportMeta.totalHeight = client.headerHeight + client.footerHeight + client.scrollable.scrollHeight;
      if (!enableDirectRendering) {
        exportMeta.totalHeight -= me.getVirtualScrollerHeight(client);
      }
    }
    let header, footer, offset;
    if (headerTpl) {
      header = me.prepareHTML(headerTpl({
        totalWidth,
        totalPages,
        currentPage
      }));
    }
    if (footerTpl) {
      footer = me.prepareHTML(footerTpl({
        totalWidth,
        totalPages,
        currentPage
      }));
    }
    if (enableDirectRendering) {
      offset = await me.renderRows(config);
    } else {
      offset = await me.collectRows(config);
    }
    const html = me.buildPageHtml(config);
    return {
      html,
      header,
      footer,
      offset
    };
  }
  async onRowsCollected() {
  }
  buildPageHtml() {
    const me = this, {
      subGrids
    } = me.exportMeta;
    let html = me.prepareExportElement();
    Object.values(subGrids).forEach(({
      placeHolder,
      rows,
      mergedCellsHtml
    }) => {
      const placeHolderText = placeHolder.outerHTML;
      let contentHtml = rows.reduce((result, row) => {
        result += row[0];
        return result;
      }, "");
      if (mergedCellsHtml !== null && mergedCellsHtml !== void 0 && mergedCellsHtml.length) {
        contentHtml += `<div class="b-grid-merged-cells-container">${mergedCellsHtml.join("")}</div>`;
      }
      html = html.replace(placeHolderText, contentHtml);
    });
    return html;
  }
};
MultiPageVerticalExporter$1.prototype.pagesExtractor = async function* pagesExtractor3(config) {
  const me = this, {
    exportMeta,
    stylesheets
  } = me, {
    totalWidth,
    paperWidth,
    paperHeight,
    contentHeight,
    scale,
    initialScroll
  } = exportMeta;
  let {
    totalPages
  } = exportMeta, currentPage;
  while ((currentPage = exportMeta.currentPage) < totalPages) {
    me.trigger("exportStep", {
      text: me.L(MultiPageVerticalExporter$1.exportingPageText, {
        currentPage,
        totalPages
      }),
      progress: Math.round((currentPage + 1) / totalPages * 90)
    });
    const {
      html,
      header,
      footer,
      offset
    } = await me.buildPage(config);
    const styles = [...stylesheets, `
                <style>
                    #${config.client.id} {
                        width: ${totalWidth}px !important;
                    }
                    .b-export .b-export-content {
                        transform: scale(${scale});
                        transform-origin: top left;
                        height: auto;
                    }
                </style>
            `];
    if (config.repeatHeader) {
      const gridHeight = exportMeta.exactGridHeight ? `${exportMeta.exactGridHeight + exportMeta.currentPageTopMargin}px` : "100%";
      styles.push(`
                <style>
                    #${config.client.id} {
                        height: ${gridHeight} !important;
                    }
                    .b-export .b-export-content {
                        height: ${100 / scale}%;
                    }
                    .b-export-body {
                        height: 100%;
                        display: flex;
                    }
                    .b-export-viewport {
                        height: 100%;
                    }
                    .b-grid-vertical-scroller {
                        margin-top: ${exportMeta.currentPageTopMargin - initialScroll}px;
                    }
                </style>
                `);
    } else {
      const gridHeight = exportMeta.exactGridHeight || contentHeight - exportMeta.currentPageTopMargin;
      styles.push(`
                <style>
                    #${config.client.id} {
                        height: ${gridHeight}px !important;
                    }
                    .b-export-body {
                        overflow: hidden;
                    }
                    .b-export .b-export-content {
                        height: ${100 / scale}%;
                    }
                    .b-export-body .b-export-viewport {
                        margin-top: ${exportMeta.currentPageTopMargin}px;
                    }
                    .b-grid-vertical-scroller {
                        margin-top: -${initialScroll}px;
                    }
                </style>
                `);
    }
    exportMeta.currentPageTopMargin -= contentHeight + offset;
    await me.stateNextPage(config);
    ({
      totalPages
    } = exportMeta);
    yield {
      html: me.pageTpl({
        html,
        header,
        footer,
        styles,
        paperWidth,
        paperHeight
      })
    };
  }
};
MultiPageVerticalExporter$1._$name = "MultiPageVerticalExporter";
var SinglePageExporter$1 = class extends Exporter {
  static get $name() {
    return "SinglePageExporter";
  }
  static get type() {
    return "singlepage";
  }
  static get title() {
    return this.localize("L{singlepage}");
  }
  static get defaultConfig() {
    return {
      centerContentHorizontally: false
    };
  }
  async prepareComponent(config) {
    await super.prepareComponent(config);
    Object.assign(this.exportMeta, {
      verticalPages: 1,
      horizontalPages: 1,
      totalPages: 1,
      currentPage: 0,
      verticalPosition: 0,
      horizontalPosition: 0
    });
  }
  async onRowsCollected() {
  }
  positionRows(rows, config) {
    if (config.enableDirectRendering) {
      return rows.map((r) => r[0]);
    } else {
      let currentTop = 0;
      return rows.map(([html, , height]) => {
        const result = html.replace(/translate\(\d+px, \d+px\)/, `translate(0px, ${currentTop}px)`);
        currentTop += height;
        return result;
      });
    }
  }
  async collectRows(config) {
    const me = this, {
      client
    } = config, {
      rowManager,
      store
    } = client, hasMergeCells = client.hasActiveFeature("mergeCells"), {
      subGrids
    } = me.exportMeta, totalRows = config.rowsRange === RowsRange.visible && store.count ? me.getVisibleRowsCount(client) : store.count;
    let {
      totalHeight
    } = me.exportMeta, processedRows = 0, lastDataIndex = -1;
    if (rowManager.rows.length > 0) {
      if (config.rowsRange === RowsRange.visible) {
        lastDataIndex = rowManager.firstVisibleRow.dataIndex - 1;
      }
      if (hasMergeCells) {
        for (const subGrid of Object.values(subGrids)) {
          subGrid.mergedCellsHtml = [];
        }
      }
      while (processedRows < totalRows) {
        const rows = rowManager.rows, lastRow = rows[rows.length - 1], lastProcessedRowIndex = processedRows;
        rows.forEach((row) => {
          if (row.dataIndex > lastDataIndex && processedRows < totalRows) {
            ++processedRows;
            totalHeight += row.offsetHeight;
            me.collectRow(row);
          }
        });
        if (hasMergeCells) {
          for (const subGridName in subGrids) {
            const subGrid = subGrids[subGridName], mergedCells = client.subGrids[subGridName].element.querySelectorAll(`.b-grid-merged-cells`);
            for (const mergedCell of mergedCells) {
              subGrid.mergedCellsHtml.push(mergedCell.outerHTML);
            }
          }
        }
        const firstNewRowIndex = rows.findIndex((r) => r.dataIndex === lastDataIndex + 1), lastNewRowIndex = firstNewRowIndex + (processedRows - lastProcessedRowIndex);
        await me.onRowsCollected(rows.slice(firstNewRowIndex, lastNewRowIndex), config);
        if (processedRows < totalRows) {
          lastDataIndex = lastRow.dataIndex;
          await me.scrollRowIntoView(client, lastDataIndex + 1);
        }
      }
    }
    return totalHeight;
  }
  async renderRows(config) {
    const me = this, {
      client,
      rowsRange
    } = config, {
      rowManager,
      store
    } = client, hasMergeCells = client.hasActiveFeature("mergeCells"), onlyVisibleRows = rowsRange === RowsRange.visible;
    let {
      totalHeight
    } = me.exportMeta;
    if (store.count) {
      const {
        fakeRow
      } = me.exportMeta, {
        firstVisibleRow
      } = rowManager, fromIndex = onlyVisibleRows ? firstVisibleRow.dataIndex : 0, toIndex = onlyVisibleRows ? rowManager.lastVisibleRow.dataIndex : store.count - 1, rows = [];
      let top = 0;
      if (fakeRow.cells.length) {
        for (let i = fromIndex; i <= toIndex; i++) {
          fakeRow.render(i, store.getAt(i), true, false, true);
          top = fakeRow.translate(top);
          me.collectRow(fakeRow);
          rows.push({
            top: fakeRow.top,
            bottom: fakeRow.bottom,
            offsetHeight: fakeRow.offsetHeight,
            dataIndex: fakeRow.dataIndex
          });
        }
        await me.onRowsCollected(rows, config);
      }
      totalHeight += top;
      if (hasMergeCells) {
        me.renderMergedCells(config, fromIndex, toIndex, rows);
      }
    }
    return totalHeight;
  }
  buildPageHtml(config) {
    const me = this, {
      subGrids
    } = me.exportMeta;
    let html = me.prepareExportElement();
    Object.values(subGrids).forEach(({
      placeHolder,
      rows,
      mergedCellsHtml
    }) => {
      const placeHolderText = placeHolder.outerHTML;
      let contentHtml = me.positionRows(rows, config).join("");
      if (mergedCellsHtml !== null && mergedCellsHtml !== void 0 && mergedCellsHtml.length) {
        contentHtml += `<div class="b-grid-merged-cells-container">${mergedCellsHtml.join("")}</div>`;
      }
      html = html.replace(placeHolderText, contentHtml);
    });
    return html;
  }
};
SinglePageExporter$1.prototype.pagesExtractor = async function* pagesExtractor4(config) {
  const me = this, {
    client
  } = config, {
    totalWidth
  } = me.exportMeta, styles = me.stylesheets, portrait = config.orientation === Orientation.portrait, paperFormat = PaperFormat[config.paperFormat], paperWidth = portrait ? paperFormat.width : paperFormat.height, paperHeight = portrait ? paperFormat.height : paperFormat.width;
  let totalHeight, header, footer;
  if (config.enableDirectRendering) {
    totalHeight = await me.renderRows(config);
    totalHeight += client.headerHeight + client.footerHeight;
  } else {
    totalHeight = await me.collectRows(config);
    totalHeight += client.height - client.bodyHeight;
  }
  const html = me.buildPageHtml(config);
  const totalClientHeight = totalHeight;
  if (config.headerTpl) {
    header = me.prepareHTML(config.headerTpl({
      totalWidth
    }));
    const height = me.measureElement(header);
    totalHeight += height;
  }
  if (config.footerTpl) {
    footer = me.prepareHTML(config.footerTpl({
      totalWidth
    }));
    const height = me.measureElement(footer);
    totalHeight += height;
  }
  const widthScale = Math.min(1, me.getScaleValue(me.inchToPx(paperWidth), totalWidth)), heightScale = Math.min(1, me.getScaleValue(me.inchToPx(paperHeight), totalHeight)), scale = Math.min(widthScale, heightScale);
  styles.push(`<style>
                #${client.id} {
                    height: ${totalClientHeight}px !important;
                    width: ${totalWidth}px !important;
                }
                .b-export-content {
                    ${me.centerContentHorizontally ? "left: 50%;" : ""}
                    transform: scale(${scale}) ${me.centerContentHorizontally ? "translateX(-50%)" : ""};
                    transform-origin: top left;
                    height: ${scale === 1 ? "inherit" : "auto !important"};
                }
            </style>`);
  if (BrowserHelper.isIE11) {
    styles.push(`<style>
                .b-export-body {
                   min-height: ${totalClientHeight}px !important;
                }
         </style>`);
  }
  yield {
    html: me.pageTpl({
      html,
      header,
      footer,
      styles,
      paperWidth,
      paperHeight
    })
  };
};
SinglePageExporter$1._$name = "SinglePageExporter";
var PdfExport$1 = class extends InstancePlugin {
  static get $name() {
    return "PdfExport";
  }
  static get configurable() {
    return {
      dialogClass: ExportDialog,
      exportServer: void 0,
      exportDialog: {
        value: true,
        $config: ["lazy"]
      },
      fileName: null,
      fileFormat: "pdf",
      clientURL: null,
      paperFormat: "A4",
      orientation: "portrait",
      rowsRange: "all",
      alignRows: false,
      repeatHeader: false,
      keepRegionSizes: null,
      pagesPerRequest: 0,
      exporterConfig: null,
      exporterType: "singlepage",
      exporters: [SinglePageExporter$1, MultiPageExporter$1, MultiPageVerticalExporter$1],
      translateURLsToAbsolute: true,
      keepPathName: true,
      openAfterExport: true,
      sendAsBinary: false,
      openInNewTab: false,
      headerTpl: null,
      footerTpl: null,
      fetchOptions: null,
      exportMask: "L{Generating pages}",
      exportProgressMask: "L{Waiting for response from server}",
      showErrorToast: true,
      localizableProperties: ["exportMask", "exportProgressMask"],
      filterStyles: (styles) => styles,
      enableDirectRendering: true
    };
  }
  updateEnableDirectRendering(value) {
    if (!value) {
      VersionHelper.deprecate("Grid", "6.0.0", "Indirect rendering is deprecated");
    }
  }
  doDestroy() {
    var _this$exportDialog;
    (_this$exportDialog = this.exportDialog) === null || _this$exportDialog === void 0 ? void 0 : _this$exportDialog.destroy();
    this.exportersMap.forEach((exporter) => exporter.destroy());
    super.doDestroy();
  }
  get currentExportPromise() {
    return this._currentExportPromise;
  }
  set currentExportPromise(value) {
    this._currentExportPromise = value;
  }
  get exportersMap() {
    return this._exportersMap || (this._exportersMap = /* @__PURE__ */ new Map());
  }
  getExporter(config = {}) {
    const me = this, {
      exportersMap
    } = me, {
      type
    } = config;
    let exporter;
    if (exportersMap.has(type)) {
      exporter = exportersMap.get(type);
      Object.assign(exporter, config);
    } else {
      const exporterClass = this.exporters.find((cls) => cls.type === type);
      if (!exporterClass) {
        throw new Error(`Exporter type ${type} is not found. Make sure you've configured it`);
      }
      config = ObjectHelper.clone(config);
      delete config.type;
      exporter = new exporterClass(config);
      exporter.relayAll(me);
      exportersMap.set(type, exporter);
    }
    return exporter;
  }
  buildRequest(pages, config) {
    return {
      html: JSON.stringify(pages),
      fileFormat: config.fileFormat,
      format: config.paperFormat,
      orientation: config.orientation
    };
  }
  buildExportConfig(config = {}) {
    const me = this, {
      client,
      exportServer,
      clientURL,
      fileFormat,
      fileName,
      paperFormat,
      rowsRange,
      alignRows,
      repeatHeader,
      keepRegionSizes,
      orientation,
      translateURLsToAbsolute,
      keepPathName,
      sendAsBinary,
      headerTpl,
      footerTpl,
      filterStyles,
      enableDirectRendering
    } = me;
    if (!config.columns) {
      config.columns = client.columns.visibleColumns.filter((column) => column.exportable).map((column) => column.id);
    }
    const result = ObjectHelper.assign({
      client,
      exportServer,
      clientURL,
      fileFormat,
      paperFormat,
      rowsRange,
      alignRows,
      repeatHeader,
      keepRegionSizes,
      orientation,
      translateURLsToAbsolute,
      keepPathName,
      sendAsBinary,
      headerTpl,
      footerTpl,
      enableDirectRendering,
      exporterType: me.exporterType,
      fileName: fileName || client.$$name
    }, config);
    result.columns = config.columns.slice();
    if (result.exporterType !== "multipagevertical") {
      result.repeatHeader = false;
    }
    if (!("alignRows" in config) && config.repeatHeader) {
      result.alignRows = true;
    }
    if (!("keepRegionSizes" in config) && !result.keepRegionSizes) {
      const collapsed = [], keepRegionSizes2 = {};
      client.eachSubGrid((s) => s.collapsed && collapsed.push(s.region));
      if (collapsed.length) {
        client.eachSubGrid((s) => {
          if (!collapsed.includes(s.region)) {
            keepRegionSizes2[s.region] = true;
          }
        });
        result.keepRegionSizes = keepRegionSizes2;
      }
    }
    result.exporterConfig = ObjectHelper.assign({
      type: result.exporterType,
      translateURLsToAbsolute: result.translateURLsToAbsolute,
      keepPathName: result.keepPathName,
      filterStyles
    }, result.exporterConfig || {});
    delete result.exporterType;
    delete result.translateURLsToAbsolute;
    delete result.keepPathName;
    return result;
  }
  async export(config = {}) {
    const me = this, {
      client,
      pagesPerRequest
    } = me;
    config = me.buildExportConfig(config);
    let result;
    if (client.trigger("beforePdfExport", {
      config
    }) !== false) {
      client.isExporting = true;
      client.mask(me.exportMask);
      try {
        const exporter = me.getExporter(config.exporterConfig);
        if (pagesPerRequest === 0) {
          var _me$exportDialog;
          const pages = await exporter.export(config);
          if (me.isDestroying) {
            return;
          }
          (_me$exportDialog = me.exportDialog) === null || _me$exportDialog === void 0 ? void 0 : _me$exportDialog.close();
          client.unmask();
          me.trigger("exportStep", {
            progress: 90,
            text: me.exportProgressMask,
            contentGenerated: true
          });
          const responsePromise = me.receiveExportContent(pages, config);
          me.toast = me.showLoadingToast(responsePromise);
          const response = await responsePromise;
          result = {
            response
          };
          await me.processExportContent(response, config);
        }
      } catch (error) {
        if (error instanceof Response) {
          result = {
            response: error
          };
        } else {
          result = {
            error
          };
        }
        throw error;
      } finally {
        if (me.toast && !me.toast.isDestroying) {
          me.toast.hide();
        }
        if (!me.isDestroying) {
          var _me$exportDialog2;
          (_me$exportDialog2 = me.exportDialog) === null || _me$exportDialog2 === void 0 ? void 0 : _me$exportDialog2.close();
          client.unmask();
          if (me.showErrorToast) {
            if (result.error) {
              if (result.error.name !== "AbortError") {
                Toast.show({
                  html: me.L("L{Export failed}"),
                  rootElement: me.rootElement
                });
              }
            } else if (!result.response.ok) {
              Toast.show({
                html: me.L("L{Server error}"),
                rootElement: me.rootElement
              });
            }
          }
          client.trigger("pdfExport", result);
          client.isExporting = false;
        }
      }
    }
    return result;
  }
  receiveExportContent(pages, config) {
    return AjaxHelper.fetch(config.exportServer, Object.assign({
      method: "POST",
      credentials: "omit",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        html: pages,
        orientation: config.orientation,
        format: config.paperFormat,
        fileFormat: config.fileFormat,
        fileName: config.fileName,
        clientURL: config.clientURL,
        sendAsBinary: config.sendAsBinary
      })
    }, this.fetchOptions));
  }
  async processExportContent(response, config) {
    const me = this;
    if (response.ok && me.openAfterExport) {
      response = response.clone();
      const contentType = response.headers.get("content-type");
      if (contentType.match(/application\/octet-stream/)) {
        const MIMEType = FileMIMEType[config.fileFormat], objectURL = await me.responseBlobToObjectURL(response, MIMEType), link = me.getDownloadLink(config.fileName, objectURL);
        link.click();
      } else if (contentType.match(/application\/json/)) {
        const responseJSON = await response.json();
        if (responseJSON.success) {
          const link = me.getDownloadLink(config.fileName, responseJSON.url);
          link.click();
        } else {
          Toast.show({
            html: responseJSON.msg,
            rootElement: this.rootElement
          });
        }
      }
    }
  }
  async responseBlobToObjectURL(response, mimeType) {
    const blob = await response.blob();
    return URL.createObjectURL(blob.slice(0, blob.size, mimeType));
  }
  getDownloadLink(name, href) {
    const link = document.createElement("a");
    link.download = name;
    link.href = href;
    if (this.openInNewTab) {
      link.target = "_blank";
    }
    return link;
  }
  get defaultExportDialogConfig() {
    return ObjectHelper.copyProperties({}, this, ["client", "exporters", "exporterType", "orientation", "fileFormat", "paperFormat", "alignRows", "rowsRange", "repeatHeader"]);
  }
  changeExportDialog(exportDialog, oldExportDialog) {
    const me = this;
    oldExportDialog === null || oldExportDialog === void 0 ? void 0 : oldExportDialog.destroy();
    if (exportDialog) {
      const config = me.dialogClass.mergeConfigs({
        rootElement: me.rootElement,
        client: me.client,
        items: {
          rowsRangeField: {
            value: me.rowsRange
          },
          exporterTypeField: {
            value: me.exporterType
          },
          orientationField: {
            value: me.orientation
          },
          paperFormatField: {
            value: me.paperFormat
          },
          repeatHeaderField: {
            value: me.repeatHeader
          },
          fileFormatField: {
            value: me.fileFormat
          },
          alignRowsField: {
            checked: me.alignRows
          }
        }
      }, me.defaultExportDialogConfig, exportDialog);
      exportDialog = me.dialogClass.new(config);
      exportDialog.ion({
        export: me.onExportButtonClick,
        thisObj: me
      });
    }
    return exportDialog;
  }
  async showExportDialog() {
    return this.exportDialog.show();
  }
  onExportButtonClick({
    values
  }) {
    const me = this, dialogMask = me.exportDialog.mask({
      progress: 0,
      maxProgress: 100,
      text: me.exportMask
    });
    const detacher2 = me.ion({
      exportstep({
        progress,
        text,
        contentGenerated
      }) {
        if (contentGenerated) {
          me.exportDialog.unmask();
          detacher2();
        } else {
          dialogMask.progress = progress;
          if (text != null) {
            dialogMask.text = text;
          }
        }
      }
    });
    me.currentExportPromise = me.export(values);
    me.currentExportPromise.catch(() => {
    }).finally(() => {
      var _me$exportDialog3;
      detacher2();
      (_me$exportDialog3 = me.exportDialog) === null || _me$exportDialog3 === void 0 ? void 0 : _me$exportDialog3.unmask();
      me.currentExportPromise = null;
    });
  }
  showLoadingToast(exportPromise) {
    const toast = Toast.show({
      timeout: 0,
      showProgress: false,
      rootElement: this.rootElement,
      html: `
    <span class="b-mask-icon b-icon b-icon-spinner"></span>
    <span>${this.L("L{Waiting for response from server}")}</span>
    <button class="b-button">${this.L("L{Click to abort}")}</button>`
    });
    EventHelper.on({
      element: toast.element,
      click() {
        var _exportPromise$abort;
        (_exportPromise$abort = exportPromise.abort) === null || _exportPromise$abort === void 0 ? void 0 : _exportPromise$abort.call(exportPromise);
      }
    });
    return toast;
  }
};
PdfExport$1._$name = "PdfExport";
GridFeatureManager.registerFeature(PdfExport$1, false, "Grid");
var TableExporter = class extends Base$1 {
  static get defaultConfig() {
    return {
      target: null,
      defaultColumnWidth: 100,
      exportDateAsInstance: true,
      showGroupHeader: true,
      columns: null,
      indent: true,
      indentationSymbol: "\xA0\xA0\xA0\xA0"
    };
  }
  export(config = {}) {
    const me = this;
    config = ObjectHelper.assign({}, me.config, config);
    me.normalizeColumns(config);
    return me.generateExportData(config);
  }
  generateExportData(config) {
    const me = this, columns = me.generateColumns(config), rows = me.generateRows(config);
    return {
      rows,
      columns
    };
  }
  normalizeColumns(config) {
    const columns = config.columns || this.target.columns.visibleColumns.filter((rec) => rec.exportable !== false);
    config.columns = columns.map((col) => {
      if (typeof col === "string") {
        return this.target.columns.find((column) => column.field === col) || {
          field: col
        };
      } else {
        return col;
      }
    });
  }
  generateColumns(config) {
    return config.columns.map((col) => this.processColumn(col, config));
  }
  generateRows(config) {
    const {
      columns,
      rows
    } = config;
    if (columns.length === 0 || (rows === null || rows === void 0 ? void 0 : rows.length) === 0) {
      return [];
    }
    const me = this, {
      target
    } = me;
    return (rows || target.store).map((record) => me.processRecord(record, columns, config)).filter((cells) => cells === null || cells === void 0 ? void 0 : cells.length);
  }
  getColumnType(column, store = this.target.store) {
    let result = column.exportedType || "object";
    if (column.exportedType === void 0) {
      if (column.field) {
        const fieldDefinition = store.modelClass.getFieldDefinition(column.field);
        if (fieldDefinition && fieldDefinition.type !== "auto") {
          result = fieldDefinition.type;
        }
      }
    }
    return result;
  }
  processColumn(column, config) {
    const me = this, {
      target
    } = me, {
      defaultColumnWidth
    } = config;
    let {
      field,
      text: value,
      width,
      minWidth
    } = column;
    if (!(field in target.store.modelClass.fieldMap)) {
      field = "";
    }
    if (!value || !width) {
      const gridColumn = target.columns.find((col) => col.field === field);
      if (!value) {
        value = gridColumn && gridColumn.text || field;
      }
      if (width == null) {
        width = gridColumn && gridColumn.width || defaultColumnWidth;
      }
    }
    width = Math.max(width || defaultColumnWidth, minWidth || defaultColumnWidth);
    return {
      field,
      value,
      width,
      type: me.getColumnType(column)
    };
  }
  processRecord(record, columns, config) {
    const {
      target
    } = this, {
      showGroupHeader,
      indent,
      indentationSymbol
    } = config;
    let cells;
    if (!record) {
      cells = columns.map(() => "");
    } else if (record.isSpecialRow) {
      if (showGroupHeader && record.meta.groupRowFor) {
        cells = columns.map((column) => {
          return target.features.group.buildGroupHeader({
            cellElement: DomHelper.createElement(),
            grid: target,
            record,
            column
          });
        });
      }
    } else {
      cells = columns.map((column) => {
        var _column$field;
        let value = (_column$field = column.field) !== null && _column$field !== void 0 && _column$field.includes(".") ? record.get(column.field) : record[column.field];
        const useRenderer = column.renderer || column.defaultRenderer;
        if (useRenderer && !(value && column.isDateColumn && config.exportDateAsInstance)) {
          value = useRenderer.call(column, {
            value,
            record,
            column,
            grid: target,
            isExport: true
          });
        }
        if (indent && column.tree) {
          value = `${indentationSymbol.repeat(record.childLevel)}${value}`;
        }
        return value;
      });
    }
    return cells;
  }
};
TableExporter._$name = "TableExporter";
var BooleanUnicodeSymbol = class {
  constructor(value) {
    this._value = value;
  }
  get value() {
    return this._value;
  }
  toString() {
    return Boolean(this.value) ? "\u2713" : "";
  }
};
BooleanUnicodeSymbol._$name = "BooleanUnicodeSymbol";
var ExcelExporter$1 = class extends InstancePlugin {
  static get $name() {
    return "ExcelExporter";
  }
  static get defaultConfig() {
    return {
      filename: null,
      dateFormat: "YYYY-MM-DD",
      exporterClass: TableExporter,
      exporterConfig: null,
      zipcelx: null,
      convertEmptyValueToEmptyString: true
    };
  }
  processValue(value) {
    if (value === void 0 || value === null || Number.isNaN(value) || typeof value === "function" || typeof value === "object" && String(value) === "[object Object]") {
      return "";
    } else {
      return value;
    }
  }
  generateExportData(config) {
    const me = this, {
      rows,
      columns
    } = me.exporter.export(config.exporterConfig);
    return {
      rows: rows.map((row) => {
        return row.map((value, index) => {
          var _columns$index;
          if (value instanceof Date) {
            value = DateHelper.format(value, config.dateFormat);
          } else if (typeof value === "boolean") {
            value = new BooleanUnicodeSymbol(value);
          }
          if (me.convertEmptyValueToEmptyString) {
            value = me.processValue(value);
          }
          const type = ((_columns$index = columns[index]) === null || _columns$index === void 0 ? void 0 : _columns$index.type) === "number" ? "number" : "string";
          return {
            value,
            type
          };
        });
      }),
      columns: columns.map((col) => {
        let {
          field,
          value,
          width,
          type
        } = col;
        type = "string";
        return {
          field,
          value,
          width,
          type
        };
      })
    };
  }
  export(config = {}) {
    const me = this, zipcelx2 = me.zipcelx || globalThis.zipcelx;
    if (!zipcelx2) {
      throw new Error('ExcelExporter: "zipcelx" library is required');
    }
    if (me.disabled) {
      return;
    }
    config = ObjectHelper.assign({}, me.config, config);
    if (!config.filename) {
      config.filename = me.client.$$name;
    }
    const {
      filename
    } = config, {
      rows,
      columns
    } = me.generateExportData(config);
    return zipcelx2({
      filename,
      sheet: {
        data: [columns].concat(rows),
        cols: columns
      }
    });
  }
  construct(grid, config) {
    super.construct(grid, config);
    if (!this.zipcelx) {
      if (typeof zipcelx !== "undefined") {
        this.zipcelx = globalThis.zipcelx;
      }
    }
  }
  get exporter() {
    const me = this;
    return me._exporter || (me._exporter = me.exporterClass.new({
      target: me.client
    }, me.exporterConfig));
  }
};
ExcelExporter$1._$name = "ExcelExporter";
GridFeatureManager.registerFeature(ExcelExporter$1, false, "Grid");
var Bar = class extends Widget {
  static get $name() {
    return "Bar";
  }
  static get type() {
    return "gridbar";
  }
  static get defaultConfig() {
    return {
      htmlCls: "",
      scrollable: {
        overflowX: "hidden-scroll"
      }
    };
  }
  get columns() {
    return this._columns || this.subGrid.columns;
  }
  set columns(columns) {
    this._columns = columns;
  }
  fixCellWidths() {
    const me = this, {
      hasFlex: hasFlex2
    } = me.columns;
    let flexBasis;
    me.columns.traverse((column) => {
      const cellEl = me.getBarCellElement(column.id), domWidth = DomHelper.setLength(column.width), domMinWidth = DomHelper.setLength(column.minWidth), domMaxWidth = DomHelper.setLength(column.maxWidth);
      if (cellEl) {
        flexBasis = domWidth;
        cellEl.style.maxWidth = domMaxWidth;
        if (column.isParent && column.width == null && column.flex == null) {
          const flex = column.children.reduce((result, child) => result += !child.hidden && child.flex || 0, 0);
          cellEl.style.flex = flex > 0 ? `${flex} 0 auto` : "";
          cellEl.style.minWidth = null;
          if (flex > 0) {
            column.traverse((col) => col.data.minWidth = null);
          }
        } else {
          if (parseInt(column.minWidth) >= 0) {
            cellEl.style.minWidth = domMinWidth;
          }
          cellEl.style.flex = cellEl.style.flexBasis = cellEl.style.width = "";
          if (column.flex) {
            if (!isNaN(parseInt(column.flex)) && column.children) {
              cellEl.style.flex = `${column.flex} 0 auto`;
            } else {
              cellEl.style.flex = column.flex;
            }
          } else if (parseInt(column.width) >= 0) {
            const parent = column.parent;
            if (me.isHeader && !parent.isRoot && !parent.width) {
              cellEl.style.width = domWidth;
            } else {
              cellEl.style.flexBasis = flexBasis;
            }
          }
        }
        if (column.height >= 0) {
          cellEl.style.height = DomHelper.setLength(column.height);
        }
      }
    });
    me.scrollable.element.classList.toggle("b-has-flex", hasFlex2);
  }
  getLrPadding(cellEl) {
    if (!this.cellLrPadding) {
      const s = cellEl.ownerDocument.defaultView.getComputedStyle(cellEl);
      this.cellLrPadding = parseInt(s.getPropertyValue("padding-left")) + parseInt(s.getPropertyValue("padding-right")) + parseInt(s.getPropertyValue("border-left-width")) + parseInt(s.getPropertyValue("border-right-width"));
    }
    return this.cellLrPadding;
  }
  getBarCellElement(columnId) {
    return this.element.querySelector(`[data-column-id="${columnId}"]`);
  }
};
Bar.initClass();
Bar._$name = "Bar";
var Footer = class extends Bar {
  static get $name() {
    return "Footer";
  }
  static get type() {
    return "gridfooter";
  }
  get subGrid() {
    return this._subGrid;
  }
  set subGrid(subGrid) {
    this._subGrid = this.owner = subGrid;
  }
  refreshContent() {
    this.element.firstElementChild.innerHTML = this.contentTemplate();
    this.fixFooterWidths();
  }
  onPaint({
    firstPaint
  }) {
    if (firstPaint) {
      this.refreshContent();
    }
  }
  template() {
    const region = this.subGrid.region;
    return TemplateHelper.tpl`
            <div class="b-grid-footer-scroller b-grid-footer-scroller-${region}" role="presentation">
                <div data-reference="footersElement" class="b-grid-footers b-grid-footers-${region}" data-region="${region}" role="presentation"></div>
            </div>
        `;
  }
  get overflowElement() {
    return this.footersElement;
  }
  getFooter(columnId) {
    return this.getBarCellElement(columnId);
  }
  contentTemplate() {
    const me = this;
    return me.columns.visibleColumns.map((column) => {
      return TemplateHelper.tpl`
                <div
                    class="b-grid-footer ${column.align ? `b-grid-footer-align-${column.align}` : ""} ${column.cls || ""}"
                    data-column="${column.field || ""}" data-column-id="${column.id}" data-all-index="${column.allIndex}"
                    role="presentation">
                    ${column.footerText || ""}
                </div>`;
    }).join("");
  }
  fixFooterWidths() {
    this.fixCellWidths();
  }
};
Footer.initClass();
Footer._$name = "Footer";
var RowManager = class extends InstancePlugin {
  static get pluginConfig() {
    return {
      chain: ["destroy"],
      assign: ["rowHeight", "topRow", "bottomRow", "firstVisibleRow", "lastVisibleRow", "firstFullyVisibleRow", "lastFullyVisibleRow", "getRowById", "getRecordCoords", "getRow", "getRowFor", "getRowFromElement"]
    };
  }
  static get defaultConfig() {
    return {
      prependRowBuffer: 5,
      appendRowBuffer: 5,
      rowHeight: null,
      fixedRowHeight: null,
      autoHeight: false
    };
  }
  static get properties() {
    return {
      idMap: {},
      topIndex: 0,
      lastScrollTop: 0,
      _rows: [],
      heightMap: /* @__PURE__ */ new Map(),
      totalKnownHeight: 0,
      _totalHeight: 0,
      averageRowHeight: 0,
      scrollTargetRecordId: null,
      refreshDetails: {
        topRowIndex: 0,
        topRowTop: 0
      }
    };
  }
  construct(config) {
    config.grid._rowManager = this;
    super.construct(config.grid, config);
  }
  doDestroy() {
    this._rows.forEach((row) => row.destroy());
    super.doDestroy();
  }
  initWithHeight(height, isRendering = false) {
    const me = this;
    if (me.autoHeight) {
      height = me.store.allCount * me.preciseRowOffsetHeight;
    }
    me.viewHeight = height;
    me.calculateRowCount(isRendering);
    return height;
  }
  reinitialize(returnToTop = false) {
    const me = this;
    me.calculateRowCount(false, true, true);
    if (me.topIndex + me.rowCount - 1 > me.store.count) {
      returnToTop = true;
    }
    const top = me.topRow && !returnToTop ? me.topRow.top : 0;
    me.scrollTargetRecordId = null;
    if (returnToTop) {
      me.topIndex = me.lastScrollTop = 0;
    }
    const {
      topRow
    } = me;
    if (topRow) {
      topRow.dataIndex = me.topIndex;
      topRow.setTop(top, true);
    }
    me.estimateTotalHeight();
    me.renderFromRow(topRow);
  }
  matchRowCount(skipRender = false) {
    const me = this, {
      rows,
      grid
    } = me, numRows = rows.length, delta = numRows - me.rowCount;
    if (delta) {
      if (delta < 0) {
        const newRows = [];
        for (let index = numRows, dataIndex = numRows ? rows[numRows - 1].dataIndex + 1 : 0; index < me.rowCount; index++, dataIndex++) {
          newRows.push(new Row({
            cls: grid.rowCls,
            rowManager: me,
            grid,
            index,
            dataIndex
          }));
        }
        rows.push.apply(rows, newRows);
        me.trigger("addRows", {
          rows: newRows
        });
        if (!skipRender) {
          me.renderFromRow(rows[Math.max(0, numRows - 1)]);
        }
      } else {
        var _focusedCell$cell;
        const {
          focusedCell
        } = grid, rowActive = (focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.id) != null && (focusedCell === null || focusedCell === void 0 ? void 0 : (_focusedCell$cell = focusedCell.cell) === null || _focusedCell$cell === void 0 ? void 0 : _focusedCell$cell.contains(DomHelper.getActiveElement(grid))), removedRows = rows.splice(numRows - delta, delta);
        if (rowActive) {
          var _me$getRowFor;
          if (delta === numRows) {
            grid.onFocusedRowDerender();
          } else if (((_me$getRowFor = me.getRowFor(focusedCell._record)) === null || _me$getRowFor === void 0 ? void 0 : _me$getRowFor.index) >= rows.length) {
            rows[rows.length - 1].cells[focusedCell.columnIndex].focus();
          }
        }
        me.trigger("removeRows", {
          rows: removedRows
        });
        removedRows.forEach((row) => row.destroy());
      }
    }
  }
  calculateRowCount(skipMatchRowCount = false, allowRowCountShrink = true, skipRender = false) {
    var _me$grid$columns;
    const me = this, {
      store
    } = me, visibleRowCount = Math.ceil(me.viewHeight / me.minRowOffsetHeight), maxRenderRowCount = visibleRowCount + me.prependRowBuffer + me.appendRowBuffer;
    if (!((_me$grid$columns = me.grid.columns) !== null && _me$grid$columns !== void 0 && _me$grid$columns.count) || isNaN(visibleRowCount)) {
      me.rowCount = 0;
      return 0;
    }
    if (maxRenderRowCount < me.rowCount && !allowRowCountShrink) {
      return me.rowCount;
    }
    me.visibleRowCount = visibleRowCount;
    me.rowCount = Math.min(store.count, maxRenderRowCount);
    if (!skipMatchRowCount) {
      if (me.rows && me.rowCount !== me.rows.length) {
        var _me$bottomRow;
        me.matchRowCount(skipRender);
        if (((_me$bottomRow = me.bottomRow) === null || _me$bottomRow === void 0 ? void 0 : _me$bottomRow.dataIndex) >= store.count && me.topRow.dataIndex !== 0) {
          const indexDelta = me.bottomRow.dataIndex - store.count + 1;
          for (const row of me.rows) {
            row.dataIndex -= indexDelta;
          }
          me.topIndex -= indexDelta;
        }
      } else if (!me.rowCount) {
        me.trigger("changeTotalHeight", {
          totalHeight: me.totalHeight
        });
      }
      me.grid.toggleEmptyText();
    }
    return me.rowCount;
  }
  removeAllRows() {
    const me = this, {
      topRow
    } = me, result = topRow ? me.refreshDetails = {
      topRowIndex: topRow.dataIndex,
      topRowTop: topRow.top
    } : me.refreshDetails, removedRows = me.rows.slice();
    me.trigger("removeRows", {
      rows: removedRows
    });
    me.rows.forEach((row) => row.destroy());
    me.rows.length = 0;
    me.idMap = {};
    return result;
  }
  setPosition(refreshDetails) {
    const {
      topRow
    } = this, {
      topRowIndex,
      topRowTop
    } = refreshDetails;
    topRow.setTop(topRowTop);
    topRow.dataIndex = topRowIndex;
  }
  get store() {
    return this.client.store;
  }
  get rows() {
    return this._rows;
  }
  getRow(index) {
    if (this.rowCount) {
      return this.rows[index - this.topIndex];
    }
  }
  getRowById(recordOrId) {
    if (recordOrId && recordOrId.isModel) {
      recordOrId = recordOrId.id;
    }
    return this.idMap[recordOrId];
  }
  getRowFromElement(element) {
    element = element.closest(".b-grid-row");
    return element && this.getRow(element.dataset.index);
  }
  getRowAt(y, local = false) {
    if (!local) {
      y -= Rectangle.from(this.grid.bodyContainer, null, true).roundPx(1).top;
      y += this.grid.scrollable.y;
    }
    y = DomHelper.roundPx(y);
    return this.rows.find((r) => y >= r.top && y < r.bottom);
  }
  getRowFor(recordOrId) {
    if (recordOrId instanceof HTMLElement) {
      return this.getRowFromElement(recordOrId);
    }
    return this.getRowById(recordOrId);
  }
  getNextRow(indexOrRow) {
    const index = typeof indexOrRow === "number" ? indexOrRow : indexOrRow.index;
    return this.getRow((index + 1) % this.rowCount);
  }
  get topRow() {
    return this.rows[0];
  }
  get bottomRow() {
    const rowCount = Math.min(this.rowCount, this.store.count);
    return this.rows[rowCount - 1];
  }
  get firstVisibleRow() {
    return this.rows.find((r) => r.bottom > Math.ceil(this.grid.scrollable.y));
  }
  get firstFullyVisibleRow() {
    return this.rows.find((r) => r.top >= Math.ceil(this.grid.scrollable.y));
  }
  get lastVisibleRow() {
    const {
      grid
    } = this;
    return ArrayHelper.findLast(this.rows, (r) => r.top < grid.scrollable.y + grid.bodyHeight);
  }
  get lastFullyVisibleRow() {
    const {
      grid
    } = this;
    return ArrayHelper.findLast(this.rows, (r) => r.bottom < grid.scrollable.y + grid.bodyHeight);
  }
  offsetRows(offset) {
    if (offset !== 0) {
      const {
        rows
      } = this, {
        length
      } = rows;
      for (let i = 0; i < length; i++) {
        rows[i].offset(offset);
      }
    }
    this.trigger("offsetRows", {
      offset
    });
  }
  get prependBufferHeight() {
    return this.prependRowBuffer * this.rowOffsetHeight;
  }
  get appendBufferHeight() {
    return this.appendRowBuffer * this.rowOffsetHeight;
  }
  get rowHeight() {
    return this._rowHeight;
  }
  set rowHeight(height) {
    const me = this, {
      grid,
      fixedRowHeight
    } = me, oldHeight = me.rowHeight;
    if (oldHeight === height) {
      return;
    }
    ObjectHelper.assertNumber(height, "rowHeight");
    if (height < 10) {
      height = 10;
    }
    me.trigger("beforeRowHeight", {
      height
    });
    me.minRowHeight = me._rowHeight = height;
    if (fixedRowHeight) {
      me.averageRowHeight = height;
    }
    if (me.rows.length) {
      const oldY = grid.scrollable.y, topRow = me.getRowAt(oldY, true), edgeOffset = topRow ? topRow.top - oldY : 0;
      let average, oldAverage;
      if (fixedRowHeight) {
        average = height;
        oldAverage = oldHeight;
      } else {
        oldAverage = average = me.averageRowHeight;
        me.clearKnownHeights();
        average *= height / oldHeight;
      }
      me.calculateRowCount(false, true, true);
      me.topRow.setTop(me.topRow.dataIndex * (average + grid._rowBorderHeight), true);
      me.refresh();
      const newY = oldY * (average / oldAverage);
      if (newY !== oldY) {
        grid.scrollRowIntoView(topRow.id, {
          block: "start",
          edgeOffset
        });
      }
    }
    me.trigger("rowHeight", {
      height,
      oldHeight
    });
  }
  get rowOffsetHeight() {
    return Math.floor(this.preciseRowOffsetHeight);
  }
  get preciseRowOffsetHeight() {
    return (this.averageRowHeight || this._rowHeight) + this.grid._rowBorderHeight;
  }
  get minRowOffsetHeight() {
    return (this.minRowHeight || this._rowHeight) + this.grid._rowBorderHeight;
  }
  get allHeightsKnown() {
    return this.fixedRowHeight || this.heightMap.size >= this.store.count;
  }
  storeKnownHeight(id, height) {
    const me = this, {
      heightMap
    } = me;
    if (!me.fixedRowHeight) {
      if (heightMap.has(id)) {
        me.totalKnownHeight -= heightMap.get(id);
      }
      heightMap.set(id, height);
      me.totalKnownHeight += height;
      if (height < me.minRowHeight) {
        me.minRowHeight = height;
      }
      me.averageRowHeight = me.totalKnownHeight / heightMap.size;
    }
  }
  getOffsetHeight(record) {
    const me = this;
    return (record && me.heightMap.get(record.id) || record && me.grid.getRowHeight(record) || me.averageRowHeight || me.rowHeight) + me.grid._rowBorderHeight;
  }
  invalidateKnownHeight(records) {
    const me = this;
    if (!me.fixedRowHeight) {
      const {
        heightMap
      } = me;
      records = ArrayHelper.asArray(records);
      records.forEach((record) => {
        if (record) {
          if (heightMap.has(record.id)) {
            me.totalKnownHeight -= heightMap.get(record.id);
            heightMap.delete(record.id);
          }
        }
      });
      me.averageRowHeight = me.totalKnownHeight / heightMap.size;
    }
  }
  clearKnownHeights() {
    this.heightMap.clear();
    this.averageRowHeight = this.totalKnownHeight = 0;
  }
  calculateTop(index) {
    if (this.fixedRowHeight) {
      return index * this.rowOffsetHeight;
    }
    const {
      store
    } = this;
    let top = 0;
    for (let i = 0; i < index; i++) {
      const record = store.getAt(i);
      top += this.getOffsetHeight(record);
    }
    return Math.floor(top);
  }
  getRecordCoords(recordOrId, local = false, roughly = false) {
    const me = this, row = me.getRowById(recordOrId);
    let scrollingViewport = me.client._bodyRectangle;
    if (!local) {
      scrollingViewport = me.client.refreshBodyRectangle();
    }
    if (row) {
      return new Rectangle(scrollingViewport.x, local ? Math.round(row.top) : Math.round(row.top + scrollingViewport.y - me.client.scrollable.y), scrollingViewport.width, row.offsetHeight);
    }
    return me.getRecordCoordsByIndex(me.store.indexOf(recordOrId), local, roughly);
  }
  getRecordCoordsByIndex(recordIndex, local = false, roughly = false) {
    const me = this, {
      topRow,
      bottomRow
    } = me, scrollingViewport = me.client._bodyRectangle, {
      id
    } = me.store.getAt(recordIndex), height = me.preciseRowOffsetHeight, currentTopIndex = topRow.dataIndex, currentBottomIndex = bottomRow.dataIndex, calculateFrom = recordIndex > currentBottomIndex ? {
      index: recordIndex - currentBottomIndex - 1,
      y: bottomRow.bottom,
      from: "bottomRow"
    } : recordIndex > currentTopIndex / 2 ? {
      index: recordIndex - currentTopIndex,
      y: topRow.top,
      from: "topRow"
    } : {
      index: recordIndex,
      y: 0,
      from: "top"
    }, top = me.allHeightsKnown && !roughly ? me.calculateTop(recordIndex) : Math.floor(calculateFrom.y + calculateFrom.index * height), result = new Rectangle(
      scrollingViewport.x,
      local ? top : top + scrollingViewport.y - me.client.scrollable.y,
      scrollingViewport.width,
      Math.floor(me.heightMap.get(id) || height)
    );
    result.virtual = true;
    result.block = result.bottom < scrollingViewport.y ? "start" : result.y > scrollingViewport.bottom ? "end" : "nearest";
    return result;
  }
  get totalHeight() {
    return this._totalHeight;
  }
  forEach(fn2) {
    this.rows.forEach(fn2);
  }
  [Symbol.iterator]() {
    return this.rows[Symbol.iterator]();
  }
  refreshCell(record, columnId) {
    const cellContext = new Location({
      grid: this.grid,
      record,
      columnId
    });
    return Boolean(cellContext.cell && cellContext.row.renderCell(cellContext));
  }
  returnToTop() {
    const me = this;
    me.topIndex = 0;
    me.lastScrollTop = 0;
    if (me.topRow) {
      me.topRow.dataIndex = 0;
      me.topRow.setTop(0, true);
    }
    me.refresh();
    me.grid.scrollable.y = 0;
  }
  renderFromRecord(record) {
    const row = this.getRowById(record.id);
    if (row) {
      this.renderFromRow(row);
    }
  }
  renderFromRow(fromRow = null) {
    const me = this, {
      rows,
      store
    } = me, storeCount = store.count;
    if (me.calculateRowCount(false, storeCount < rows.length, true) === 0) {
      me.estimateTotalHeight(true);
      return;
    }
    const fromRowIndex = fromRow ? rows.indexOf(fromRow) : 0;
    let dataIndex = fromRow ? fromRow.dataIndex : rows[0].dataIndex;
    const recordsAfter = storeCount - dataIndex - 1, toRowIndex = Math.min(rows.length - 1, fromRowIndex + recordsAfter);
    let leftOverCount = rows.length - toRowIndex - 1, top = fromRowIndex > 0 ? rows[fromRowIndex - 1].bottom : rows[fromRowIndex].top, row;
    for (let i = fromRowIndex; i <= toRowIndex; i++) {
      row = rows[i];
      row.dataIndex = dataIndex;
      row.setTop(top, true);
      row.render(dataIndex, store.getAt(dataIndex++), false);
      top += row.offsetHeight;
    }
    while (leftOverCount-- > 0) {
      me.displayRecordAtTop();
    }
    if (me.bottomRow.bottom < me.viewHeight) {
      me.calculateRowCount();
    }
    me.estimateTotalHeight(true);
    me.trigger("renderDone");
  }
  renderRows(rows) {
    let oldHeight, heightChanged = false;
    rows = Array.from(rows);
    rows.sort((a, b) => a.dataIndex - b.dataIndex);
    for (const row of rows) {
      oldHeight = row.height;
      row.render(null, null, false);
      heightChanged |= row.height !== oldHeight;
    }
    if (heightChanged) {
      this.translateFromRow(rows[0]);
    }
    this.trigger("renderDone");
  }
  translateFromRow(fromRow, batch = false) {
    const me = this;
    let top = fromRow.bottom, row, index;
    for (index = fromRow.dataIndex + 1, row = me.getRow(index); row; row = me.getRow(++index)) {
      top = row.translate(top);
    }
    if (!batch) {
      me.estimateTotalHeight(true);
    }
  }
  refresh() {
    const me = this, {
      topRow
    } = me;
    if (!topRow || me.grid.refreshSuspended) {
      return;
    }
    me.idMap = {};
    me.renderFromRow(topRow);
    me.trigger("refresh");
  }
  jumpToPosition(newScrollTop, forceRecordIndex) {
    const me = this, {
      store,
      heightMap
    } = me, storeCount = store.count;
    if (me.allHeightsKnown && !me.fixedRowHeight) {
      const top = newScrollTop - me.prependBufferHeight, border = me.grid._rowBorderHeight;
      let accumulated = 0, targetIndex = 0;
      while (accumulated < top) {
        const record = store.getAt(targetIndex);
        accumulated += heightMap.get(record.id) + border;
        targetIndex++;
      }
      const startIndex = Math.max(Math.min(targetIndex, storeCount - me.rowCount), 0);
      me.lastScrollTop = newScrollTop;
      me.topRow.dataIndex = me.topIndex = startIndex;
      me.topRow.setTop(me.calculateTop(startIndex), false);
      me.refresh();
    } else {
      const rowHeight = me.preciseRowOffsetHeight, targetIndex = forceRecordIndex == null ? Math.floor(newScrollTop / rowHeight) - me.prependRowBuffer : forceRecordIndex - Math.floor(me.rowCount / 2), startIndex = Math.max(Math.min(targetIndex, storeCount - me.rowCount), 0), viewportTop = me.client.scrollable.y, viewportBottom = Math.min(me.client._bodyRectangle.height + viewportTop + me.appendBufferHeight, me.totalHeight);
      me.lastScrollTop = newScrollTop;
      me.topRow.dataIndex = me.topIndex = startIndex;
      me.topRow.setTop(Math.floor(startIndex * rowHeight), false);
      me.refresh();
      if (me.bottomRow.bottom < viewportBottom) {
        me.calculateRowCount(false, false, false);
        while (me.bottomRow.bottom < viewportBottom && me._rows[me.prependRowBuffer].top < viewportTop && me.bottomRow.dataIndex < storeCount - 1) {
          me.displayRecordAtBottom();
        }
      }
      me.estimateTotalHeight();
    }
    if (forceRecordIndex != null) {
      const {
        scrollable
      } = me.grid, targetRow = me.getRow(forceRecordIndex), rowCenter = targetRow && Rectangle.from(targetRow._elementsArray[0]).center.y, viewportCenter = scrollable.viewport.center.y;
      if (targetRow) {
        scrollable.y = newScrollTop = Math.floor(scrollable.y + (rowCenter - viewportCenter));
      }
    }
    return newScrollTop;
  }
  warpIfNeeded(newScrollTop) {
    const me = this, result = {
      newScrollTop,
      deltaTop: newScrollTop - me.lastScrollTop
    };
    if (Math.abs(result.deltaTop) > me.rowCount * me.rowOffsetHeight * 3) {
      let index;
      if (me.scrollTargetRecordId) {
        index = me.store.indexOf(me.scrollTargetRecordId);
      }
      me.grid.onFocusedRowDerender();
      result.newScrollTop = me.jumpToPosition(newScrollTop, index);
      result.deltaTop = 0;
    }
    return result;
  }
  updateRenderedRows(newScrollTop, force, ignoreError = false) {
    const me = this, clientRect = me.client._bodyRectangle;
    if (me.rowCount === 0) {
      return 0;
    }
    let result = me.totalHeight;
    if (force || Math.abs(newScrollTop - me.lastScrollTop) >= me.rowOffsetHeight || me.topRow.top > newScrollTop || me.bottomRow.bottom < newScrollTop + clientRect.height) {
      const posInfo = me.warpIfNeeded(newScrollTop);
      me.scrollTargetRecordId = null;
      me.lastScrollTop = posInfo.newScrollTop;
      if (posInfo.deltaTop > 0) {
        me.fillBelow(posInfo.newScrollTop);
      } else if (posInfo.deltaTop < 0) {
        me.fillAbove(posInfo.newScrollTop);
      }
      if (!me.fixedRowHeight && !ignoreError) {
        me.correctError(posInfo, clientRect, newScrollTop);
      }
      result = me.estimateTotalHeight();
    }
    return result;
  }
  correctError(posInfo, clientRect, newScrollTop) {
    const me = this;
    let error = 0;
    if (me.allHeightsKnown) {
      error = me.topRow.top - me.calculateTop(me.topRow.dataIndex);
    } else {
      if (posInfo.deltaTop < 0 && newScrollTop < clientRect.height * 2 || posInfo.deltaTop > 0 && newScrollTop > me.totalHeight - clientRect.height * 2 - 3) {
        error = me.topRow.top - me.calculateTop(me.topRow.dataIndex);
      }
    }
    if (error) {
      me.offsetRows(-error);
      me.grid.scrollable.y = me.lastScrollTop = me.grid.scrollable.y - error;
    }
  }
  fillAbove(newTop) {
    const me = this, fillHeight = newTop - me.topRow.top - me.prependBufferHeight;
    let accumulatedHeight = 0;
    while (accumulatedHeight > fillHeight && me.topIndex > 0) {
      accumulatedHeight -= me.displayRecordAtTop();
    }
    me.trigger("renderDone");
  }
  fillBelow(newTop) {
    const me = this, fillHeight = newTop - me.topRow.top - me.prependBufferHeight, recordCount = me.store.count, rowCount = me.rowCount;
    let accumulatedHeight = 0;
    while (accumulatedHeight < fillHeight && me.topIndex + rowCount < recordCount && me.topRow.top + me.topRow.offsetHeight < newTop) {
      accumulatedHeight += me.displayRecordAtBottom();
    }
    me.trigger("renderDone");
  }
  estimateTotalHeight(immediate = false) {
    const me = this;
    if (me.grid.renderingRows) {
      return;
    }
    const recordCount = me.store.count, unknownCount = recordCount - me.heightMap.size, {
      bottomRow
    } = me;
    let estimate;
    if (me.fixedRowHeight) {
      estimate = recordCount * me.rowOffsetHeight;
    } else {
      estimate = me.totalKnownHeight + me.heightMap.size * me.grid._rowBorderHeight + unknownCount * me.preciseRowOffsetHeight;
      if (bottomRow && unknownCount) {
        const bottom = bottomRow.bottom;
        if (bottom > estimate || me.topIndex + me.rowCount >= recordCount && estimate > bottom && bottom > 0) {
          estimate = bottom;
          if (bottomRow.dataIndex < recordCount - 1) {
            estimate += (recordCount - 1 - bottomRow.dataIndex) * me.preciseRowOffsetHeight;
          }
        }
      }
      estimate = Math.floor(estimate);
    }
    if (estimate !== me.totalHeight) {
      if (me.trigger("changeTotalHeight", {
        totalHeight: estimate,
        immediate
      }) !== false) {
        me._totalHeight = estimate;
      }
    }
    return estimate;
  }
  displayRecordAtTop() {
    var _grid$focusedCell;
    const me = this, {
      grid
    } = me, recordIndex = me.topIndex - 1, record = me.store.getAt(recordIndex), bottomRow = me.bottomRow, bottomRowTop = bottomRow.top;
    me.trigger("beforeTranslateRow", {
      row: bottomRow,
      newRecord: record
    });
    if (bottomRow.dataIndex === ((_grid$focusedCell = grid.focusedCell) === null || _grid$focusedCell === void 0 ? void 0 : _grid$focusedCell.rowIndex)) {
      grid.onFocusedRowDerender();
    }
    bottomRow._top = me.topRow.top - me.getOffsetHeight(record);
    bottomRow.estimatedTop = !me.fixedRowHeight;
    bottomRow.render(recordIndex, record, false);
    bottomRow._top = bottomRowTop;
    bottomRow.setBottom(me.topRow.top);
    bottomRow.estimatedTop = false;
    me.topIndex--;
    me._rows.unshift(me._rows.pop());
    return bottomRow.offsetHeight;
  }
  displayRecordAtBottom() {
    var _grid$focusedCell2;
    const me = this, {
      grid
    } = me, recordIndex = me.topIndex + me.rowCount, record = me.store.getAt(recordIndex), topRow = me.topRow;
    me.trigger("beforeTranslateRow", {
      row: topRow,
      newRecord: record
    });
    if (topRow.dataIndex === ((_grid$focusedCell2 = grid.focusedCell) === null || _grid$focusedCell2 === void 0 ? void 0 : _grid$focusedCell2.rowIndex)) {
      grid.onFocusedRowDerender();
    }
    topRow.dataIndex = recordIndex;
    topRow.setTop(me.bottomRow.bottom);
    topRow.render(recordIndex, record, false);
    me.topIndex++;
    me._rows.push(me._rows.shift());
    return topRow.offsetHeight;
  }
};
RowManager.featureClass = "";
RowManager._$name = "RowManager";
var xAxis = {
  x: 1
};
var GridScroller = class extends Scroller {
  addScroller(scroller) {
    (this.xScrollers || (this.xScrollers = [])).push(scroller);
  }
  addPartner(otherScroller, axes = xAxis) {
    if (typeof axes === "string") {
      axes = {
        [axes]: 1
      };
    }
    if (axes.x) {
      otherScroller.owner.initScroll();
      this.xScrollers.forEach((scroller, i) => scroller.addPartner(otherScroller.xScrollers[i], "x"));
    }
    if (axes.y) {
      super.addPartner(otherScroller, "y");
    }
  }
  removePartner(otherScroller) {
    this.xScrollers.forEach((scroller, i) => {
      if (!scroller.isDestroyed) {
        scroller.removePartner(otherScroller.xScrollers[i]);
      }
    });
    super.removePartner(otherScroller);
  }
  updateOverflowX(overflowX) {
    var _this$xScrollers;
    const hideScroll = overflowX === false;
    (_this$xScrollers = this.xScrollers) === null || _this$xScrollers === void 0 ? void 0 : _this$xScrollers.forEach((s) => s.overflowX = hideScroll ? "hidden" : "hidden-scroll");
    this.widget.virtualScrollers.classList.toggle("b-hide-display", hideScroll);
  }
  scrollIntoView(element, options) {
    if (element.nodeType === Element.ELEMENT_NODE && this.element.contains(element)) {
      for (const subGridScroller of this.xScrollers) {
        if (subGridScroller.element.contains(element)) {
          return subGridScroller.scrollIntoView(element, options);
        }
      }
    } else {
      return super.scrollIntoView(element, options);
    }
  }
  hasOverflow(axis = "y") {
    return axis === "y" ? this.scrollHeight > this.clientHeight : false;
  }
  set x(x) {
    if (this.xScrollers) {
      this.xScrollers[0].x = x;
    }
  }
  get x() {
    return this.xScrollers ? this.xScrollers[0].x : 0;
  }
};
GridScroller._$name = "GridScroller";
var Header$1 = class extends Bar {
  static get $name() {
    return "Header";
  }
  static get type() {
    return "gridheader";
  }
  get subGrid() {
    return this._subGrid;
  }
  set subGrid(subGrid) {
    this._subGrid = this.owner = subGrid;
  }
  get region() {
    var _this$subGrid;
    return (_this$subGrid = this.subGrid) === null || _this$subGrid === void 0 ? void 0 : _this$subGrid.region;
  }
  changeElement(element, was) {
    const {
      region
    } = this;
    this.getConfig("columns");
    return super.changeElement({
      className: {
        "b-grid-header-scroller": 1,
        [`b-grid-header-scroller-${region}`]: region
      },
      children: [{
        reference: "headersElement",
        className: {
          "b-grid-headers": 1,
          [`b-grid-headers-${region}`]: region
        },
        dataset: {
          region,
          reference: "headersElement",
          maxDepth: this.maxDepth
        }
      }]
    }, was);
  }
  get overflowElement() {
    return this.headersElement;
  }
  getColumnConfig(column) {
    const {
      id,
      align,
      resizable,
      isLeaf,
      isParent,
      isLastInSubGrid,
      cls,
      childLevel,
      field,
      tooltip,
      children,
      isFocusable,
      grid
    } = column, focusedCell = grid === null || grid === void 0 ? void 0 : grid.focusedCell, isFocused = (focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.rowIndex) === -1 && (focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.column) === column;
    if (column.isVisible) {
      return {
        className: {
          "b-grid-header": 1,
          "b-grid-header-parent": isParent,
          [`b-level-${childLevel}`]: 1,
          [`b-depth-${column.meta.depth}`]: 1,
          [`b-grid-header-align-${align}`]: align,
          "b-grid-header-resizable": resizable && isLeaf,
          [cls]: cls,
          "b-collapsible": column.collapsible,
          "b-last-parent": isParent && isLastInSubGrid,
          "b-last-leaf": isLeaf && isLastInSubGrid
        },
        role: isFocusable ? "columnheader" : "presentation",
        "aria-sort": "none",
        "aria-label": column.ariaLabel,
        [isFocusable ? "tabIndex" : ""]: isFocused ? 0 : -1,
        dataset: _objectSpread2(_objectSpread2({}, Tooltip.encodeConfig(tooltip)), {}, {
          columnId: id,
          [field ? "column" : ""]: field
        }),
        children: [{
          className: "b-grid-header-text",
          children: [{
            [grid && isFocusable ? "id" : ""]: `${grid === null || grid === void 0 ? void 0 : grid.id}-column-${column.id}`,
            className: "b-grid-header-text-content"
          }]
        }, children ? {
          className: "b-grid-header-children",
          children: children.map((child) => this.getColumnConfig(child))
        } : null, {
          className: "b-grid-header-resize-handle"
        }]
      };
    }
  }
  calculateMinWidthForSafari() {
    let minWidth = 0;
    this.columns.visibleColumns.forEach((column) => {
      minWidth += column.calculateMinWidth();
    });
    return minWidth;
  }
  fixHeaderWidths() {
    this.fixCellWidths();
  }
  refreshHeaders() {
    const me = this;
    me.columns.traverse((column) => {
      const headerElement = me.getBarCellElement(column.id);
      if (headerElement) {
        let html = column.headerText;
        if (column.headerRenderer) {
          html = column.headerRenderer.call(column.thisObj || me, {
            column,
            headerElement
          });
        }
        if (column.headerWidgetMap) {
          Object.values(column.headerWidgetMap).forEach((widget) => {
            widget.render(column.textWrapper);
          });
        }
        if (column.icon) {
          html = `<i class="${StringHelper.encodeHtml(column.icon)}"></i>` + (html || "");
        }
        const innerEl = headerElement.querySelector(".b-grid-header-text-content");
        if (innerEl) {
          innerEl.innerHTML = html || "";
        }
      }
    });
    me.fixHeaderWidths();
  }
  get columns() {
    const me = this, result = super.columns;
    if (!me.columnsDetacher) {
      me.columnsDetacher = result.ion({
        change() {
          me.initDepths();
        },
        thisObj: me
      });
      me.initDepths();
    }
    return result;
  }
  set columns(columns) {
    super.columns = columns;
  }
  initDepths(columns = this.columns.topColumns, parent = null) {
    const me = this;
    let maxDepth = 0;
    if (parent !== null && parent !== void 0 && parent.meta) {
      parent.meta.depth++;
    }
    for (const column of columns) {
      const {
        meta
      } = column;
      meta.depth = 0;
      if (column.children) {
        me.initDepths(column.children.filter(me.columns.chainedFilterFn), column);
        if (meta.depth && parent) {
          parent.meta.depth += meta.depth;
        }
      }
      if (meta.depth > maxDepth) {
        maxDepth = meta.depth;
      }
    }
    if (!parent) {
      me.maxDepth = maxDepth;
    }
    return maxDepth;
  }
  getHeader(columnId) {
    return this.getBarCellElement(columnId);
  }
  get contentElement() {
    return this.element.firstElementChild;
  }
  refreshContent() {
    const me = this;
    DomSync.sync({
      domConfig: {
        children: me.columns.topColumns.map((col) => me.getColumnConfig(col)),
        onlyChildren: true,
        strict: true,
        syncIdField: "columnId",
        releaseThreshold: 0
      },
      targetElement: me.contentElement
    });
    me.refreshHeaders();
  }
  onPaint({
    firstPaint
  }) {
    if (firstPaint) {
      this.refreshContent();
    }
  }
};
Header$1.initClass();
Header$1._$name = "Header";
var gridBodyElementEventHandlers = {
  touchstart: "onElementTouchStart",
  touchmove: "onElementTouchMove",
  touchend: "onElementTouchEnd",
  mouseover: "onElementMouseOver",
  mouseout: "onElementMouseOut",
  mousedown: "onElementMouseDown",
  mousemove: "onElementMouseMove",
  mouseup: "onElementMouseUp",
  click: "onHandleElementClick",
  dblclick: "onElementDblClick",
  keyup: "onElementKeyUp",
  keypress: "onElementKeyPress",
  contextmenu: "onElementContextMenu",
  pointerdown: "onElementPointerDown",
  pointerup: "onElementPointerUp"
};
var eventProps = ["pageX", "pageY", "clientX", "clientY", "screenX", "screenY"];
function toggleHover(element, add = true) {
  element === null || element === void 0 ? void 0 : element.classList.toggle("b-hover", add);
}
function setCellHover(columnId, row, add = true) {
  row && columnId && toggleHover(row.getCell(columnId), add);
}
var GridElementEvents = (Target) => class GridElementEvents extends (Target || Base$1) {
  static get $name() {
    return "GridElementEvents";
  }
  static get configurable() {
    return {
      longPressTime: 400,
      enableUndoRedoKeys: true,
      keyMap: {
        "Ctrl+z": "undoRedoKeyPress",
        "Ctrl+Shift+z": "undoRedoKeyPress",
        " ": {
          handler: "clickCellByKey",
          weight: 1e3
        }
      }
    };
  }
  initInternalEvents() {
    const handledEvents = Object.keys(gridBodyElementEventHandlers), len = handledEvents.length, listeners = {
      element: this.bodyElement,
      thisObj: this
    };
    for (let i = 0; i < len; i++) {
      const eventName = handledEvents[i];
      listeners[eventName] = {
        handler: "handleEvent"
      };
      if (eventName.startsWith("touch")) {
        listeners[eventName].passive = false;
      }
    }
    EventHelper.on(listeners);
    EventHelper.on({
      focusin: "onGridBodyFocusIn",
      element: this.bodyElement,
      thisObj: this,
      capture: true
    });
  }
  getCellDataFromEvent(event, includeSingleAxisMatch = false) {
    const me = this, {
      columns
    } = me, {
      target
    } = event;
    let cellElement = target.closest(".b-grid-cell");
    if (!cellElement && includeSingleAxisMatch && !target.classList.contains("b-grid-row") && !target.classList.contains("b-grid-subgrid")) {
      const {
        top,
        left,
        right,
        bottom
      } = me.bodyContainer.getBoundingClientRect();
      let match, {
        x,
        y
      } = event;
      if (x >= left && x <= right) {
        y = match = Math.ceil(me[`${y < top ? "first" : "last"}FullyVisibleRow`].element.getBoundingClientRect().y);
      } else if (y >= top && y <= bottom) {
        x = match = Math.ceil(columns.visibleColumns[x < left ? 0 : columns.visibleColumns.length - 1].element.getBoundingClientRect().x);
      }
      if (match !== void 0) {
        var _document$elementFrom;
        cellElement = (_document$elementFrom = document.elementFromPoint(x, y)) === null || _document$elementFrom === void 0 ? void 0 : _document$elementFrom.closest(".b-grid-cell");
      }
    }
    if (cellElement) {
      const cellData = DomDataStore.get(cellElement), {
        id,
        columnId
      } = cellData, record = me.store.getById(id), column = columns.getById(columnId);
      return record ? {
        cellElement,
        cellData,
        columnId,
        id,
        record,
        column,
        cellSelector: {
          id,
          columnId
        }
      } : null;
    }
  }
  getHeaderDataFromEvent(event) {
    const headerElement = event.target.closest(".b-grid-header");
    if (headerElement) {
      const headerData = ObjectHelper.assign({}, headerElement.dataset), {
        columnId
      } = headerData, column = this.columns.getById(columnId);
      return column ? {
        headerElement,
        headerData,
        columnId,
        column
      } : null;
    }
  }
  handleEvent(event) {
    if (!this.disabled && gridBodyElementEventHandlers[event.type]) {
      this[gridBodyElementEventHandlers[event.type]](event);
    }
  }
  onElementTouchStart(event) {
    const me = this, cellData = me.getCellDataFromEvent(event);
    DomHelper.isTouchEvent = true;
    if (event.touches.length === 1) {
      me.longPressTimeout = me.setTimeout(() => {
        me.onElementLongPress(event);
        event.preventDefault();
        me.longPressPerformed = true;
      }, me.longPressTime);
    }
    if (cellData && !event.defaultPrevented) {
      me.onFocusGesture(event);
    }
  }
  onElementTouchMove(event) {
    const me = this, {
      lastTouchTarget
    } = me, touch = event.changedTouches[0], {
      pageX,
      pageY
    } = touch, touchTarget = document.elementFromPoint(pageX, pageY);
    if (me.longPressTimeout) {
      me.clearTimeout(me.longPressTimeout);
      me.longPressTimeout = null;
    }
    if (touchTarget !== lastTouchTarget) {
      if (lastTouchTarget) {
        const mouseoutEvent = new MouseEvent("mouseout", ObjectHelper.copyProperties({
          relatedTarget: touchTarget,
          pointerType: "touch",
          bubbles: true
        }, touch, eventProps));
        mouseoutEvent.preventDefault = () => event.preventDefault();
        lastTouchTarget === null || lastTouchTarget === void 0 ? void 0 : lastTouchTarget.dispatchEvent(mouseoutEvent);
      }
      if (touchTarget) {
        const mouseoverEvent = new MouseEvent("mouseover", ObjectHelper.copyProperties({
          relatedTarget: lastTouchTarget,
          pointerType: "touch",
          bubbles: true
        }, touch, eventProps));
        mouseoverEvent.preventDefault = () => event.preventDefault();
        touchTarget === null || touchTarget === void 0 ? void 0 : touchTarget.dispatchEvent(mouseoverEvent);
      }
    }
    me.lastTouchTarget = touchTarget;
  }
  onElementTouchEnd(event) {
    const me = this;
    if (me.longPressPerformed) {
      if (event.cancelable) {
        event.preventDefault();
      }
      me.longPressPerformed = false;
    }
    if (me.longPressTimeout) {
      me.clearTimeout(me.longPressTimeout);
      me.longPressTimeout = null;
    }
  }
  onElementLongPress(event) {
  }
  triggerCellMouseEvent(name, event, cellData = this.getCellDataFromEvent(event)) {
    const me = this;
    if (cellData) {
      const column = me.columns.getById(cellData.columnId), eventData = {
        grid: me,
        record: cellData.record,
        column,
        cellSelector: cellData.cellSelector,
        cellElement: cellData.cellElement,
        target: event.target,
        event
      };
      me.trigger("cell" + StringHelper.capitalize(name), eventData);
      if (name === "click") {
        var _column$onCellClick;
        (_column$onCellClick = column.onCellClick) === null || _column$onCellClick === void 0 ? void 0 : _column$onCellClick.call(column, eventData);
      }
    }
  }
  onElementMouseDown(event) {
    const me = this, cellData = me.getCellDataFromEvent(event);
    me.skipFocusSelection = true;
    if (me.isScrollbarOrRowBorderOrSplitterClick(event)) {
      event.preventDefault();
    } else {
      me.triggerCellMouseEvent("mousedown", event, cellData);
      if (cellData && !event.defaultPrevented) {
        me.onFocusGesture(event);
      }
    }
  }
  isScrollbarOrRowBorderOrSplitterClick({
    target,
    x,
    y
  }) {
    if (target.closest(".b-grid-splitter") || target.matches(".b-grid-row, .b-virtual-width")) {
      return true;
    }
    if (target.matches(".b-vertical-overflow")) {
      const rect = target.getBoundingClientRect();
      return x > rect.right - DomHelper.scrollBarWidth;
    } else if (target.matches(".b-horizontal-overflow")) {
      const rect = target.getBoundingClientRect();
      return y > rect.bottom - DomHelper.scrollBarWidth - 1;
    }
  }
  onElementMouseMove(event) {
    this.mouseMoveEvent = event;
  }
  onElementMouseUp(event) {
  }
  onElementPointerDown(event) {
  }
  onElementPointerUp(event) {
  }
  onHandleElementClick(event) {
    if (this.trigger("beforeElementClick", {
      event
    }) !== false) {
      this.onElementClick(event);
    }
  }
  onElementClick(event) {
    const me = this, cellData = me.getCellDataFromEvent(event);
    if (cellData) {
      me.triggerCellMouseEvent("click", event, cellData);
    }
  }
  onFocusGesture(event) {
    const me = this, isContextMenu = event.button === 2, isTreeExpander = !isContextMenu && event.target.matches(".b-icon-tree-expand, .b-icon-tree-collapse"), isUnfocusedRightClick = !document.hasFocus() && BrowserHelper.isMac && isContextMenu;
    if (isTreeExpander || isUnfocusedRightClick) {
      event.preventDefault();
    } else {
      var _me$focusedCell;
      me.navigationEvent = event;
      if (isContextMenu || (_me$focusedCell = me.focusedCell) !== null && _me$focusedCell !== void 0 && _me$focusedCell.equals(new Location(event.target))) {
        me.focusCell(new Location(event.target));
      }
    }
  }
  onElementDblClick(event) {
    const {
      target
    } = event;
    this.triggerCellMouseEvent("dblClick", event);
    if (target.classList.contains("b-grid-header-resize-handle")) {
      const header = target.closest(".b-grid-header"), column = this.columns.getById(header.dataset.columnId);
      column.resizeToFitContent();
    }
  }
  onElementMouseOver(event) {
    if (!this.scrolling) {
      const shouldHover = typeof event.buttons !== "number" || event.buttons === 0, cellElement = event.target.closest(".b-grid-cell");
      if (shouldHover && !cellElement && event.target.classList.contains("b-grid-row")) {
        this.setHovered(document.elementFromPoint(event.x, event.y - 2).closest(".b-grid-cell"));
      }
      if (cellElement) {
        if (shouldHover) {
          this.setHovered(cellElement);
        }
        this.triggerCellMouseEvent("mouseOver", event);
      }
      this.trigger("mouseOver", {
        event
      });
    }
  }
  onElementMouseOut(event) {
    this.setHovered(null);
    if (!this.scrolling) {
      const cellElement = event.target.closest(".b-grid-cell");
      if (cellElement) {
        this.triggerCellMouseEvent("mouseOut", event);
      }
      this.trigger("mouseOut", {
        event
      });
    }
  }
  setHovered(cellElement) {
    var _me$columns$find, _me$checkboxSelection;
    const me = this, {
      selectionMode
    } = me, rowNumberColumnId = selectionMode.rowNumber && ((_me$columns$find = me.columns.find((c) => c.type == "rownumber")) === null || _me$columns$find === void 0 ? void 0 : _me$columns$find.id), checkboxSelectionColumnId = selectionMode.checkbox && ((_me$checkboxSelection = me.checkboxSelectionColumn) === null || _me$checkboxSelection === void 0 ? void 0 : _me$checkboxSelection.id);
    if (me._hoveredCell) {
      toggleHover(me._hoveredCell, false);
      const prevSelector = DomDataStore.get(me._hoveredCell), {
        row: prevRow
      } = prevSelector;
      if (prevRow && !prevRow.isDestroyed) {
        setCellHover(rowNumberColumnId, prevRow, false);
        setCellHover(checkboxSelectionColumnId, prevRow, false);
      }
      if (prevSelector !== null && prevSelector !== void 0 && prevSelector.columnId) {
        var _me$columns$getById;
        toggleHover((_me$columns$getById = me.columns.getById(prevSelector.columnId)) === null || _me$columns$getById === void 0 ? void 0 : _me$columns$getById.element, false);
      }
      me._hoveredCell = null;
    }
    if (me._hoveredRow && !me._hoveredRow.isDestroyed) {
      me._hoveredRow.removeCls("b-hover");
    }
    me._hoveredRow = null;
    if (cellElement && !me.scrolling) {
      const selector = DomDataStore.get(cellElement), {
        row
      } = selector;
      if (row) {
        if (selectionMode.cell && selector.columnId !== rowNumberColumnId && selector.columnId !== checkboxSelectionColumnId) {
          var _me$columns$getById2;
          toggleHover(cellElement);
          me._hoveredCell = cellElement;
          setCellHover(checkboxSelectionColumnId, row);
          setCellHover(rowNumberColumnId, row);
          toggleHover((_me$columns$getById2 = me.columns.getById(selector.columnId)) === null || _me$columns$getById2 === void 0 ? void 0 : _me$columns$getById2.element);
        } else {
          me._hoveredRow = row;
          row.addCls("b-hover");
        }
      }
    }
  }
  keyMapOnKeyDown(event) {
    this.onElementKeyDown(event);
    super.keyMapOnKeyDown(event);
  }
  onElementKeyDown(event) {
    if (event.handled) {
      return;
    }
    const me = this, focusedCell = me.focusedCell;
    if (focusedCell !== null && focusedCell !== void 0 && focusedCell.isCell && !focusedCell.isActionable) {
      var _me$columns$getById$o, _me$columns$getById3;
      const cellElement = focusedCell.cell;
      (_me$columns$getById$o = (_me$columns$getById3 = me.columns.getById(cellElement.dataset.columnId)).onCellKeyDown) === null || _me$columns$getById$o === void 0 ? void 0 : _me$columns$getById$o.call(_me$columns$getById3, {
        event,
        cellElement
      });
    }
  }
  undoRedoKeyPress(event) {
    var _this$features$cellEd;
    const {
      stm
    } = this.store;
    if (stm && this.enableUndoRedoKeys && !((_this$features$cellEd = this.features.cellEdit) !== null && _this$features$cellEd !== void 0 && _this$features$cellEd.isEditing)) {
      stm.onUndoKeyPress(event);
      return true;
    }
    return false;
  }
  clickCellByKey(event) {
    const me = this, focusedCell = me.focusedCell, cellElement = focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.cell, column = me.columns.getById(cellElement.dataset.columnId);
    if (focusedCell !== null && focusedCell !== void 0 && focusedCell.isCell && !focusedCell.isActionable) {
      if (column.onCellClick) {
        column.onCellClick({
          grid: me,
          column,
          record: me.store.getById(focusedCell.id),
          cellElement,
          target: event.target,
          event
        });
        return true;
      }
    }
    return false;
  }
  onElementKeyPress(event) {
  }
  onElementKeyUp(event) {
  }
  onElementContextMenu(event) {
    const me = this, cellData = me.getCellDataFromEvent(event);
    if (cellData) {
      me.triggerCellMouseEvent("contextMenu", event, cellData);
      if (DomHelper.isTouchEvent) {
        me.onFocusGesture(event);
      }
    }
  }
  onInternalResize(element, width, height, oldWidth, oldHeight) {
    const me = this;
    if (me._devicePixelRatio && me._devicePixelRatio !== globalThis.devicePixelRatio) {
      DomHelper.resetScrollBarWidth();
    }
    me._devicePixelRatio = globalThis.devicePixelRatio;
    me._bodyRectangle = Rectangle.client(me.bodyContainer);
    super.onInternalResize(...arguments);
    if (height !== oldHeight) {
      me._bodyHeight = me.bodyContainer.offsetHeight;
      if (me.isPainted) {
        me.rowManager.initWithHeight(me._bodyHeight);
      }
    }
    me.refreshVirtualScrollbars();
    if (width !== oldWidth) {
      me.setTimeout(() => {
        if (!me.isDestroyed) {
          me.updateResponsive(width, oldWidth);
        }
      }, 0);
    }
  }
  get widgetClass() {
  }
};
var validConfigTypes = {
  string: 1,
  object: 1,
  function: 1
};
var GridFeatures = (Target) => class GridFeatures extends (Target || Base$1) {
  static get $name() {
    return "GridFeatures";
  }
  set features(features) {
    const me = this, defaultFeatures = GridFeatureManager.getInstanceDefaultFeatures(this);
    features = me._features = ObjectHelper.assign({}, features);
    if (defaultFeatures) {
      Object.keys(defaultFeatures).forEach((feature) => {
        if (!(feature in features)) {
          features[feature] = true;
        }
      });
    }
    const registeredInstanceFeatures = GridFeatureManager.getInstanceFeatures(this);
    for (const featureName of Object.keys(features)) {
      const config = features[featureName];
      if (config) {
        const throwIfError = !globalThis.__bryntum_code_editor_changed;
        if (StringHelper.uncapitalize(featureName) !== featureName) {
          const errorMessage = `Invalid feature name '${featureName}', must start with a lowercase letter`;
          if (throwIfError) {
            throw new Error(errorMessage);
          }
          console.error(errorMessage);
          me._errorDuringConfiguration = errorMessage;
        }
        const featureClass = registeredInstanceFeatures[featureName];
        if (!featureClass) {
          const errorMessage = `Feature '${featureName}' not available, make sure you have imported it`;
          if (throwIfError) {
            throw new Error(errorMessage);
          }
          console.error(errorMessage);
          me._errorDuringConfiguration = errorMessage;
          return;
        }
        Reflect.defineProperty(features, featureName, me.createFeatureInitializer(features, featureName, featureClass, config));
      }
    }
  }
  get features() {
    return this._features;
  }
  createFeatureInitializer(features, featureName, featureClass, config) {
    const constructorArgs = [this], construct = featureClass.prototype.construct;
    if (config === true) {
      config = {};
    }
    if (validConfigTypes[typeof config]) {
      constructorArgs[1] = config;
    }
    return {
      configurable: true,
      get() {
        delete features[featureName];
        featureClass.prototype.construct = function(...args) {
          features[featureName] = this;
          construct.apply(this, args);
          featureClass.prototype.construct = construct;
        };
        return new featureClass(...constructorArgs);
      }
    };
  }
  hasFeature(name) {
    const {
      features
    } = this;
    if (features) {
      const featureProp = Object.getOwnPropertyDescriptor(this.features, name);
      if (featureProp) {
        return Boolean(featureProp.value || featureProp.get);
      }
    }
    return false;
  }
  hasActiveFeature(name) {
    var _this$features, _this$features2;
    return Boolean(((_this$features = this.features) === null || _this$features === void 0 ? void 0 : _this$features[name]) && !((_this$features2 = this.features) !== null && _this$features2 !== void 0 && _this$features2[name].disabled));
  }
  getConfigValue(name, options) {
    if (name === "features") {
      const result = {};
      for (const feature in this.features) {
        var _this$features$featur, _this$features$featur2, _this$features$featur3;
        const featureConfig = (_this$features$featur = this.features[feature]) === null || _this$features$featur === void 0 ? void 0 : (_this$features$featur2 = (_this$features$featur3 = _this$features$featur).getCurrentConfig) === null || _this$features$featur2 === void 0 ? void 0 : _this$features$featur2.call(_this$features$featur3, options);
        if (featureConfig) {
          if (ObjectHelper.isEmpty(featureConfig)) {
            if (!GridFeatureManager.isDefaultFeatureForInstance(this.features[feature].constructor, this)) {
              result[feature] = true;
            }
          } else {
            result[feature] = featureConfig;
          }
        } else {
          result[feature] = false;
        }
      }
      return result;
    }
    return super.getConfigValue(name, options);
  }
  get widgetClass() {
  }
};
var defaultFocusOptions = Object.freeze({});
var disableScrolling = Object.freeze({
  x: false,
  y: false
});
var containedFocusable = function(e) {
  if (!this.focusableFinderCell.contains(e)) {
    return DomHelper.NodeFilter.FILTER_REJECT;
  }
  if (DomHelper.isFocusable(e) && !e.disabled) {
    return DomHelper.NodeFilter.FILTER_ACCEPT;
  }
  return DomHelper.NodeFilter.FILTER_SKIP;
};
var GridNavigation = (Target) => {
  var _class;
  return _class = class GridNavigation extends (Target || Base$1) {
    static get $name() {
      return "GridNavigation";
    }
    onStoreRecordIdChange(event) {
      var _super$onStoreRecordI;
      (_super$onStoreRecordI = super.onStoreRecordIdChange) === null || _super$onStoreRecordI === void 0 ? void 0 : _super$onStoreRecordI.call(this, event);
      const {
        focusedCell
      } = this, {
        oldValue,
        value
      } = event;
      if (focusedCell && focusedCell.id === oldValue) {
        focusedCell._id = value;
      }
    }
    onFocusedRowDerender() {
      const me = this, {
        focusedCell
      } = me;
      if ((focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.id) != null && focusedCell.cell) {
        const isActive = focusedCell.cell.contains(DomHelper.getActiveElement(me));
        if (me.hideHeaders) {
          if (isActive) {
            me.revertFocus();
          }
        } else {
          const headerContext = me.normalizeCellContext({
            rowIndex: -1,
            columnIndex: isActive ? focusedCell.columnIndex : 0
          });
          if (isActive) {
            me.focusCell(headerContext);
          } else {
            headerContext.cell.tabIndex = 0;
          }
        }
        focusedCell.cell.tabIndex = -1;
      }
    }
    navigateFirstCell() {
      this.focusCell(Location.FIRST_CELL);
    }
    navigateFirstColumn() {
      this.focusCell(Location.FIRST_COLUMN);
    }
    navigateLastCell() {
      this.focusCell(Location.LAST_CELL);
    }
    navigateLastColumn() {
      this.focusCell(Location.LAST_COLUMN);
    }
    navigatePrevPage() {
      this.focusCell(Location.PREV_PAGE);
    }
    navigateNextPage() {
      this.focusCell(Location.NEXT_PAGE);
    }
    activateHeader(keyEvent) {
      if (keyEvent.target.classList.contains("b-grid-header") && this.focusedCell.isColumnHeader) {
        var _column$onKeyDown;
        const {
          column
        } = this.focusedCell;
        (_column$onKeyDown = column.onKeyDown) === null || _column$onKeyDown === void 0 ? void 0 : _column$onKeyDown.call(column, keyEvent);
        this.getHeaderElement(column.id).click();
      }
      return false;
    }
    onEscape(keyEvent) {
      const {
        focusedCell
      } = this;
      if (!keyEvent.target.closest(".b-dragging") && focusedCell !== null && focusedCell !== void 0 && focusedCell.isActionable) {
        keyEvent.stopImmediatePropagation();
        this._focusedCell = null;
        this.focusCell({
          rowIndex: focusedCell.rowIndex,
          column: focusedCell.column
        }, {
          disableActionable: true
        });
      }
    }
    onTab(keyEvent) {
      const {
        target
      } = keyEvent, {
        focusedCell,
        bodyElement
      } = this, {
        isActionable,
        actionTargets
      } = focusedCell, isEditable = isActionable && DomHelper.isEditable(target) && !target.readOnly;
      if (isEditable && target === actionTargets[actionTargets.length - 1]) {
        keyEvent.preventDefault();
        this.navigateRight(keyEvent);
      } else if (!isActionable || target === actionTargets[actionTargets.length - 1]) {
        bodyElement.style.display = "none";
        this.requestAnimationFrame(() => bodyElement.style.display = "");
        return false;
      }
    }
    onShiftTab(keyEvent) {
      const me = this, {
        target
      } = keyEvent, {
        focusedCell,
        bodyElement
      } = me, {
        cell,
        isActionable,
        actionTargets
      } = focusedCell, isEditable = isActionable && DomHelper.isEditable(target) && !target.readOnly, onFirstCell = focusedCell.columnIndex === 0 && focusedCell.rowIndex === (me.hideHeaders ? 0 : -1);
      if (!onFirstCell && isEditable && target === actionTargets[0]) {
        keyEvent.preventDefault();
        me.navigateLeft(keyEvent);
      } else if (!isActionable || target === actionTargets[0]) {
        const f = !onFirstCell && !me.hideHeaders && me.focusCell({
          rowIndex: -1,
          column: 0
        }, {
          disableActionable: true
        });
        if (f) {
          f.cell.tabIndex = -1;
          cell.tabIndex = 0;
          me._focusedCell = focusedCell;
        } else {
          bodyElement.style.display = "none";
          me.requestAnimationFrame(() => bodyElement.style.display = "");
        }
        return false;
      }
    }
    onSpace(keyEvent) {
      if (!this.focusedCell.isActionable) {
        keyEvent.preventDefault();
      }
      return false;
    }
    get focusedCell() {
      return this._focusedCell;
    }
    get isActionableLocation() {
      var _this$_focusedCell;
      return (_this$_focusedCell = this._focusedCell) === null || _this$_focusedCell === void 0 ? void 0 : _this$_focusedCell.isActionable;
    }
    set focusedCell(cellSelector) {
      this.focusCell(cellSelector);
    }
    get focusedRecord() {
      var _this$_focusedCell2;
      return (_this$_focusedCell2 = this._focusedCell) === null || _this$_focusedCell2 === void 0 ? void 0 : _this$_focusedCell2.record;
    }
    get cellCSSSelector() {
      const cell = this._focusedCell;
      return cell ? `[data-index=${cell.rowIndex}] [data-column-id=${cell.columnId}]` : "";
    }
    afterHide() {
      super.afterHide(...arguments);
      this.lastFocusedCell = null;
    }
    isFocused(cellSelector) {
      var _this$_focusedCell3;
      return Boolean((_this$_focusedCell3 = this._focusedCell) === null || _this$_focusedCell3 === void 0 ? void 0 : _this$_focusedCell3.equals(this.normalizeCellContext(cellSelector)));
    }
    get focusElement() {
      if (!this.isDestroying) {
        let focusCell;
        if (this.store.count && this._focusedCell) {
          focusCell = this._focusedCell.target;
        } else {
          var _this$_focusedCell4;
          focusCell = this.normalizeCellContext({
            rowIndex: -1,
            columnIndex: ((_this$_focusedCell4 = this._focusedCell) === null || _this$_focusedCell4 === void 0 ? void 0 : _this$_focusedCell4.columnIndex) || 0
          }).target;
        }
        const superFocusEl = super.focusElement;
        if (superFocusEl && (!focusCell || focusCell.compareDocumentPosition(superFocusEl) === Node.DOCUMENT_POSITION_PRECEDING)) {
          return superFocusEl;
        }
        return focusCell;
      }
    }
    onPaint({
      firstPaint
    }) {
      var _super$onPaint;
      const me = this;
      (_super$onPaint = super.onPaint) === null || _super$onPaint === void 0 ? void 0 : _super$onPaint.call(this, ...arguments);
      const defaultFocus = this.normalizeCellContext({
        rowIndex: me.hideHeaders ? 0 : -1,
        column: me.hideHeaders ? 0 : me.columns.find((col) => !col.hidden && col.isFocusable)
      });
      if (defaultFocus.cell) {
        me._focusedCell = defaultFocus;
        const {
          target
        } = defaultFocus;
        if (target === defaultFocus.cell) {
          defaultFocus.cell.tabIndex = 0;
        }
      }
    }
    onGridBodyFocusIn(focusEvent) {
      const me = this, {
        bodyElement
      } = me, lastFocusedCell = me.focusedCell, lastTarget = (lastFocusedCell === null || lastFocusedCell === void 0 ? void 0 : lastFocusedCell.initialTarget) || (lastFocusedCell === null || lastFocusedCell === void 0 ? void 0 : lastFocusedCell.target), {
        target,
        relatedTarget
      } = focusEvent, targetCell = target.closest(me.focusableSelector);
      if (targetCell && (!GlobalEvents$1.currentMouseDown || GlobalEvents$1.isMouseDown(0) || GlobalEvents$1.isMouseDown(2))) {
        var _me$onCellNavigate;
        const cellSelector = new Location(target), {
          cell
        } = cellSelector, lastCell = lastFocusedCell === null || lastFocusedCell === void 0 ? void 0 : lastFocusedCell.cell, actionTargets = cellSelector.actionTargets = me.findFocusables(targetCell), doSelect = (!me._fromFocusCell || me.selectOnFocus) && (target === cell || me._selectActionCell) && !(target !== null && target !== void 0 && target._isRevertingFocus);
        if (!me.store.getById(targetCell.parentNode.dataset.id) && cell !== targetCell) {
          cell.focus({
            preventScroll: true
          });
          return;
        }
        if (target.matches(me.focusableSelector)) {
          if (me.disableActionable) {
            cellSelector._target = cell;
          } else if (actionTargets.length) {
            var _GlobalEvents$current;
            me._selectActionCell = ((_GlobalEvents$current = GlobalEvents$1.currentMouseDown) === null || _GlobalEvents$current === void 0 ? void 0 : _GlobalEvents$current.target) === target;
            actionTargets[0].focus();
            delete me._selectActionCell;
            return;
          }
        } else {
          var _GlobalEvents$current2;
          if (lastFocusedCell !== null && lastFocusedCell !== void 0 && lastFocusedCell.target && relatedTarget && (!GlobalEvents$1.isMouseDown() || !bodyElement.contains((_GlobalEvents$current2 = GlobalEvents$1.currentMouseDown) === null || _GlobalEvents$current2 === void 0 ? void 0 : _GlobalEvents$current2.target)) && !bodyElement.contains(relatedTarget) && !cellSelector.equals(lastFocusedCell)) {
            lastTarget.focus();
            return;
          }
          cellSelector._target = target;
        }
        if (lastCell) {
          lastCell.classList.remove("b-focused");
          lastCell.tabIndex = -1;
        }
        if (cell) {
          cell.classList.add("b-focused");
          cellSelector.column.onCellFocus(cellSelector);
          if (cell === target) {
            cell.tabIndex = 0;
          }
          if (cell.contains(focusEvent.relatedTarget)) {
            if (lastTarget === target) {
              return;
            }
          }
        }
        me._focusedCell = cellSelector;
        (_me$onCellNavigate = me.onCellNavigate) === null || _me$onCellNavigate === void 0 ? void 0 : _me$onCellNavigate.call(me, me, lastFocusedCell, cellSelector, doSelect);
        me.trigger("navigate", {
          lastFocusedCell,
          focusedCell: cellSelector,
          event: focusEvent
        });
      } else {
        lastTarget === null || lastTarget === void 0 ? void 0 : lastTarget.focus();
      }
    }
    findFocusables(cell) {
      const {
        focusableFinder
      } = this, result = [];
      focusableFinder.currentNode = this.focusableFinderCell = cell;
      for (let focusable = focusableFinder.nextNode(); focusable; focusable = focusableFinder.nextNode()) {
        result.push(focusable);
      }
      return result;
    }
    get focusableFinder() {
      const me = this;
      if (!me._focusableFinder) {
        me._focusableFinder = me.setupTreeWalker(me.bodyElement, DomHelper.NodeFilter.SHOW_ELEMENT, {
          acceptNode: containedFocusable.bind(me)
        });
      }
      return me._focusableFinder;
    }
    restoreActiveItem(item = this._focusedCell) {
      if (this.rowManager.count) {
        if (!isNaN(item)) {
          item = this.store.getAt(item);
        } else if (!item.isModel) {
          item = this.store.getById(item);
        }
        return this.focusCell(item);
      }
    }
    focusCell(cellSelector, options = defaultFocusOptions) {
      var _cellSelector, _cellSelector2;
      const me = this, {
        _focusedCell
      } = me, {
        scroll,
        disableActionable
      } = options;
      if (((_cellSelector = cellSelector) === null || _cellSelector === void 0 ? void 0 : _cellSelector.rowIndex) === -1 && me.hideHeaders) {
        me.revertFocus();
        return;
      }
      cellSelector = typeof cellSelector === "number" && _focusedCell !== null && _focusedCell !== void 0 && _focusedCell.isLocation ? _focusedCell.move(cellSelector) : me.normalizeCellContext(cellSelector);
      const doSelect = "doSelect" in options ? options.doSelect : !cellSelector.isActionable || cellSelector.initialTarget === cellSelector.cell;
      if (cellSelector.equals(_focusedCell)) {
        var _me$onCellNavigate2;
        (_me$onCellNavigate2 = me.onCellNavigate) === null || _me$onCellNavigate2 === void 0 ? void 0 : _me$onCellNavigate2.call(me, me, _focusedCell, cellSelector, doSelect);
        return _focusedCell;
      }
      const subGrid = me.getSubGridFromColumn(cellSelector.columnId), {
        cell
      } = cellSelector, testCell = cell || me.getCell({
        rowIndex: me.rowManager.topIndex,
        columnId: cellSelector.columnId
      }), subGridRect = Rectangle.from(subGrid.element), bodyRect = Rectangle.from(me.bodyElement), cellRect = Rectangle.from(testCell).moveTo(null, subGridRect.y);
      if (scroll === false || cellSelector.rowIndex === -1) {
        options = Object.assign({}, options, disableScrolling);
      } else {
        options = Object.assign({}, options, scroll);
        if (cellRect.width > subGridRect.width || cellRect.height > bodyRect.height) {
          options.x = options.y = false;
        } else {
          options.column = cellSelector.columnId;
        }
        me.scrollRowIntoView(cellSelector.id, options);
      }
      if (me._hoveredRow || me._hoveredCell) {
        me.setHovered();
      }
      me.disableActionable = disableActionable;
      me.selectOnFocus = doSelect;
      me._fromFocusCell = true;
      (_cellSelector2 = cellSelector[disableActionable ? "cell" : "target"]) === null || _cellSelector2 === void 0 ? void 0 : _cellSelector2.focus();
      me.disableActionable = me.selectOnFocus = false;
      delete me._fromFocusCell;
      return cellSelector;
    }
    blurCell(cellSelector) {
      const me = this, cell = me.getCell(cellSelector);
      if (cell) {
        cell.classList.remove("b-focused");
      }
    }
    clearFocus(fullClear) {
      const me = this;
      if (me._focusedCell) {
        me.lastFocusedCell = fullClear ? null : me._focusedCell;
        me.blurCell(me._focusedCell);
        me._focusedCell = null;
      }
    }
    internalNextPrevCell(next = true) {
      const me = this, cellSelector = me._focusedCell;
      if (cellSelector) {
        return me.focusCell({
          id: cellSelector.id,
          columnId: me.columns.getAdjacentVisibleLeafColumn(cellSelector.columnId, next, true).id
        });
      }
      return null;
    }
    navigateRight() {
      var _arguments$;
      if ((_arguments$ = arguments[0]) !== null && _arguments$ !== void 0 && _arguments$.fromKeyMap) {
        return this.focusCell(this.rtl ? Location.PREV_CELL : Location.NEXT_CELL);
      }
      if (arguments[0]) {
        VersionHelper.deprecate("Grid", "6.0.0", "Event argument removed, unused param");
      }
      return this.internalNextPrevCell(!this.rtl);
    }
    navigateLeft() {
      var _arguments$2;
      if ((_arguments$2 = arguments[0]) !== null && _arguments$2 !== void 0 && _arguments$2.fromKeyMap) {
        return this.focusCell(this.rtl ? Location.NEXT_CELL : Location.PREV_CELL);
      }
      if (arguments[0]) {
        VersionHelper.deprecate("Grid", "6.0.0", "Event argument removed, unused param");
      }
      return this.internalNextPrevCell(Boolean(this.rtl));
    }
    internalNextPrevRow(next, skipSpecialRows = true, moveToHeader = true) {
      const me = this, cell = me._focusedCell;
      if (!cell)
        return false;
      const record = me.store[`get${next ? "Next" : "Prev"}`](cell.id, false, skipSpecialRows);
      if (record) {
        return me.focusCell({
          id: record.id,
          columnId: cell.columnId,
          scroll: {
            x: false
          }
        });
      } else if (!next && moveToHeader && !cell.isColumnHeader) {
        this.clearFocus();
        return this.getHeaderElement(cell.columnId).focus();
      }
    }
    navigateDown() {
      var _arguments$3;
      if ((_arguments$3 = arguments[0]) !== null && _arguments$3 !== void 0 && _arguments$3.fromKeyMap) {
        return this.focusCell(Location.DOWN);
      }
      if (arguments[0]) {
        VersionHelper.deprecate("Grid", "6.0.0", "Event argument removed, unused param");
      }
      return this.internalNextPrevRow(true, false);
    }
    navigateUp() {
      var _arguments$4;
      if ((_arguments$4 = arguments[0]) !== null && _arguments$4 !== void 0 && _arguments$4.fromKeyMap) {
        return this.focusCell(Location.UP);
      }
      if (arguments[0]) {
        VersionHelper.deprecate("Grid", "6.0.0", "Event argument removed, unused param");
      }
      return this.internalNextPrevRow(false, false);
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "configurable", {
    focusable: false,
    focusableSelector: ".b-grid-cell,.b-grid-header.b-depth-0",
    keyMap: {
      ArrowUp: {
        handler: "navigateUp",
        weight: 10
      },
      ArrowRight: {
        handler: "navigateRight",
        weight: 10
      },
      ArrowDown: {
        handler: "navigateDown",
        weight: 10
      },
      ArrowLeft: {
        handler: "navigateLeft",
        weight: 10
      },
      "Ctrl+Home": "navigateFirstCell",
      Home: "navigateFirstColumn",
      "Ctrl+End": "navigateLastCell",
      End: "navigateLastColumn",
      PageUp: "navigatePrevPage",
      PageDown: "navigateNextPage",
      Enter: "activateHeader",
      Escape: {
        handler: "onEscape",
        weight: 10
      },
      "Shift+Tab": {
        handler: "onShiftTab",
        preventDefault: false
      },
      Tab: {
        handler: "onTab",
        preventDefault: false
      },
      " ": {
        handler: "onSpace",
        preventDefault: false
      }
    }
  }), _class;
};
var GridResponsive = (Target) => class GridResponsive extends (Target || Base$1) {
  static get $name() {
    return "GridResponsive";
  }
  static get defaultConfig() {
    return {
      responsiveLevels: Object.freeze({
        small: 400,
        medium: 600,
        large: "*"
      })
    };
  }
  getClosestBiggerLevel(width) {
    const me = this, levels = Object.keys(ObjectHelper.assign({}, me.responsiveLevels));
    let useLevel = null, minDelta = 99995, biggestLevel = null;
    levels.forEach((level) => {
      let levelSize = me.responsiveLevels[level];
      if (!["number", "string"].includes(typeof levelSize)) {
        levelSize = levelSize.levelWidth;
      }
      if (levelSize === "*") {
        biggestLevel = level;
      } else if (width < levelSize) {
        const delta = levelSize - width;
        if (delta < minDelta) {
          minDelta = delta;
          useLevel = level;
        }
      }
    });
    return useLevel || biggestLevel;
  }
  get responsiveLevel() {
    return this.getClosestBiggerLevel(this.width);
  }
  updateResponsive(width, oldWidth) {
    const me = this, oldLevel = me.getClosestBiggerLevel(oldWidth), level = me.getClosestBiggerLevel(width);
    if (oldWidth === 0 || oldLevel !== level) {
      const levelConfig = me.responsiveLevels[level];
      if (!["number", "string"].includes(typeof levelConfig)) {
        me.applyState(levelConfig);
      }
      me.columns.forEach((column) => {
        const levels = column.responsiveLevels;
        if (levels) {
          if (levels[level]) {
            column.applyState(levels[level]);
          } else if (levels["*"]) {
            column.applyState(levels["*"]);
          }
        }
      });
      me.element.classList.remove("b-responsive-" + oldLevel);
      me.element.classList.add("b-responsive-" + level);
      me.trigger("responsive", {
        level,
        width,
        oldLevel,
        oldWidth
      });
    }
  }
  get widgetClass() {
  }
};
var validIdTypes = {
  string: 1,
  number: 1
};
var isDataLoadAction = {
  dataset: 1,
  batch: 1
};
var GridSelection = (Target) => {
  var _class;
  return _class = class GridSelection extends (Target || Base$1) {
    static get $name() {
      return "GridSelection";
    }
    construct(config) {
      this._selectedCells = [];
      super.construct(config);
      if (config !== null && config !== void 0 && config.selectedRecords) {
        this.selectedRecords = config.selectedRecords;
      }
    }
    getDefaultGridSelection(clas) {
      if (clas.$name === "GridSelection") {
        return clas.configurable.selectionMode;
      } else if (clas.superclass) {
        return this.getDefaultGridSelection(clas.superclass);
      }
    }
    changeSelectionMode(mode) {
      const me = this;
      if (me.selectionMode) {
        ObjectHelper.assign(me.selectionMode, mode);
        return me.selectionMode;
      }
      me.$defaultGridSelection = me.getDefaultGridSelection(me.constructor);
      return new Proxy(mode, {
        set(obj, prop, value) {
          const old = ObjectHelper.assign({}, obj);
          obj[prop] = value;
          me.updateSelectionMode(obj, old);
          return true;
        }
      });
    }
    updateSelectionMode(mode, oldMode = this.$defaultGridSelection) {
      const me = this, {
        columns,
        checkboxSelectionColumn
      } = me, changed = {}, {
        rowReorder
      } = me.features;
      for (const property in mode) {
        if (mode[property] != oldMode[property]) {
          changed[property] = mode[property];
        }
      }
      if (mode.rowCheckboxSelection && !mode.checkboxOnly) {
        mode.checkboxOnly = true;
        delete mode.rowCheckboxSelection;
      }
      if (changed.column) {
        mode.cell = true;
        mode.multiSelect = true;
      }
      if (changed.cell) {
        mode.checkboxOnly = false;
      }
      if (changed.cell === false) {
        mode.column = false;
      }
      if (changed.checkboxOnly) {
        if (!mode.checkbox) {
          mode.checkbox = true;
        }
        mode.cell = false;
      }
      if (changed.checkbox === false) {
        changed.checkboxOnly = false;
        changed.showCheckAll = false;
      }
      if (changed.showCheckAll) {
        mode.checkbox = true;
        mode.multiSelect = true;
      }
      if (changed.includeChildren || changed.includeParents) {
        mode.multiSelect = true;
      }
      if (changed.multiSelect === false) {
        mode.column = mode.showCheckAll = mode.dragSelect = mode.includeChildren = mode.includeParents = false;
      }
      if (changed.dragSelect) {
        if (rowReorder !== null && rowReorder !== void 0 && rowReorder.enabled && rowReorder.gripOnly !== true) {
          rowReorder.showGrip = rowReorder.gripOnly = true;
        }
        mode.multiSelect = true;
        me._selectionListenersDetachers = {};
      }
      if (changed.dragSelect === false && me._selectionListenersDetachers) {
        var _me$_selectionListene, _me$_selectionListene2;
        (_me$_selectionListene = (_me$_selectionListene2 = me._selectionListenersDetachers).selectiondrag) === null || _me$_selectionListene === void 0 ? void 0 : _me$_selectionListene.call(_me$_selectionListene2);
        delete me._selectionListenersDetachers.selectiondrag;
      }
      if (oldMode && (changed.cell !== void 0 || changed.deselectFilteredOutRecords !== void 0 || changed.multiSelect !== void 0)) {
        me.deselectAll();
      }
      if (changed.rowNumber) {
        if (!columns.findRecord("type", "rownumber")) {
          columns.insert(0, _objectSpread2(_objectSpread2({}, typeof mode.rowNumber == "object" ? mode.rowNumber : {}), {}, {
            type: "rownumber"
          }));
          me._selectionAddedRowNumberColumn = true;
        }
      } else if (changed.rowNumber === false && me._selectionAddedRowNumberColumn) {
        columns.remove(columns.findRecord("type", "rownumber"));
        delete me._selectionAddedRowNumberColumn;
      }
      if (mode.checkbox !== (oldMode === null || oldMode === void 0 ? void 0 : oldMode.checkbox) || mode.checkbox && mode.showCheckAll !== (oldMode === null || oldMode === void 0 ? void 0 : oldMode.showCheckAll)) {
        if (oldMode) {
          me.deselectAll();
        }
        if (me.isConfiguring) {
          me.shouldInitCheckboxSelection = true;
        } else {
          me.initCheckboxSelection();
        }
      }
      if (oldMode && mode.checkbox && oldMode.checkbox && mode.checkboxIndex !== oldMode.checkboxIndex && checkboxSelectionColumn) {
        checkboxSelectionColumn.parent.insertChild(checkboxSelectionColumn, columns.getAt(me.checkboxSelectionColumnInsertIndex));
      }
      me.trigger("selectionModeChange", ObjectHelper.clone(mode));
      me.afterSelectionModeChange(mode);
    }
    afterConfigure() {
      if (this.shouldInitCheckboxSelection) {
        this.shouldInitCheckboxSelection = false;
        this.initCheckboxSelection();
      }
      super.afterConfigure();
    }
    initCheckboxSelection() {
      const me = this, {
        selectionMode,
        columns,
        checkboxSelectionColumn
      } = me, {
        checkbox
      } = selectionMode;
      if (checkboxSelectionColumn) {
        me.checkboxSelectionColumn = null;
        columns.remove(checkboxSelectionColumn);
      }
      if (checkbox) {
        var _me$items, _me$items$;
        const checkColumnClass = ColumnStore.getColumnClass("check"), config = checkbox === true ? null : checkbox;
        if (!checkColumnClass) {
          throw new Error("CheckColumn must be imported for checkbox selection mode to work");
        }
        const col = me.checkboxSelectionColumn = new checkColumnClass(ObjectHelper.assign({
          id: `${me.id}-selection-column`,
          width: "4em",
          minWidth: "4em",
          field: null,
          sortable: false,
          filterable: false,
          cellCls: "b-checkbox-selection",
          region: (_me$items = me.items) === null || _me$items === void 0 ? void 0 : (_me$items$ = _me$items[0]) === null || _me$items$ === void 0 ? void 0 : _me$items$.region,
          showCheckAll: selectionMode.showCheckAll,
          draggable: false,
          resizable: false,
          widgets: [{
            type: "checkbox",
            valueProperty: "checked",
            ariaLabel: "L{Checkbox.toggleRowSelect}"
          }]
        }, config), columns, {
          isSelectionColumn: true
        });
        col.meta.depth = 0;
        col._grid = me;
        const checkboxRenderer = col.renderer;
        col.renderer = (renderData) => {
          renderData.value = me.isSelected(renderData.record);
          checkboxRenderer.call(col, renderData);
        };
        col.ion({
          toggle: "onCheckChange",
          toggleAll: "onCheckAllChange",
          thisObj: me
        });
        columns.insert(me.checkboxSelectionColumnInsertIndex, col);
      }
    }
    get checkboxSelectionColumnInsertIndex() {
      const {
        columns
      } = this;
      let {
        checkboxIndex
      } = this.selectionMode;
      if (!checkboxIndex) {
        checkboxIndex = columns.indexOf(columns.findRecord("type", "rownumber")) + 1;
      } else if (typeof checkboxIndex === "string") {
        checkboxIndex = columns.indexOf(columns.getById(checkboxIndex));
      }
      return checkboxIndex;
    }
    afterSelectionChange() {
    }
    afterSelectionModeChange() {
    }
    changeSelectedRecordCollection(collection) {
      return collection instanceof Collection ? collection : new Collection(collection);
    }
    updateSelectedRecordCollection(collection) {
      collection.ion({
        change: "onSelectedRecordCollectionChange",
        thisObj: this
      });
    }
    onSelectedRecordCollectionChange({
      added = [],
      removed
    }) {
      if (!this.selectedRecordCollection._fromSelection) {
        added = added.filter((row) => this.isSelectable(row));
        this.performSelection({
          selectedCells: [],
          deselectedCells: [],
          selectedRecords: added,
          deselectedRecords: removed
        });
      }
    }
    changeSelectedRecordCollectionSilent(fn2) {
      this.selectedRecordCollection._fromSelection = true;
      const result = fn2(this.selectedRecordCollection);
      delete this.selectedRecordCollection._fromSelection;
      return result;
    }
    bindStore(store) {
      var _super$bindStore;
      this.detachListeners("selectionStoreFilter");
      store.ion({
        name: "selectionStoreFilter",
        filter: "onStoreFilter",
        thisObj: this
      });
      (_super$bindStore = super.bindStore) === null || _super$bindStore === void 0 ? void 0 : _super$bindStore.call(this, store);
    }
    unbindStore(oldStore) {
      this.detachListeners("selectionStoreFilter");
      super.unbindStore(oldStore);
    }
    onStoreFilter({
      source
    }) {
      const me = this, deselect = [];
      for (const selectedRecord of me.selectedRecords) {
        if (!source.includes(selectedRecord)) {
          deselect.push(selectedRecord);
        }
      }
      const selectionChange = me.prepareSelection(me.selectionMode.deselectFilteredOutRecords ? deselect : []);
      if (me.isCellSelectionMode) {
        const {
          deselectedCells
        } = me.prepareSelection(me.getSelectedCellsForRecords(deselect));
        if (deselectedCells !== null && deselectedCells !== void 0 && deselectedCells.length) {
          selectionChange.deselectedCells = (selectionChange.deselectedCells || []).concat(deselectedCells);
        }
      }
      if (selectionChange.deselectedCells.length || selectionChange.deselectedRecords.length) {
        me.performSelection(selectionChange, false);
        me.updateCheckboxHeader();
      }
    }
    onStoreRecordIdChange({
      record,
      oldValue
    }) {
      var _super$onStoreRecordI;
      (_super$onStoreRecordI = super.onStoreRecordIdChange) === null || _super$onStoreRecordI === void 0 ? void 0 : _super$onStoreRecordI.call(this, ...arguments);
      const item = this.selectedRecordCollection.get(oldValue);
      if (item === record) {
        this.selectedRecordCollection.rebuildIndices();
      }
    }
    onStoreRemove(event) {
      var _super$onStoreRemove;
      (_super$onStoreRemove = super.onStoreRemove) === null || _super$onStoreRemove === void 0 ? void 0 : _super$onStoreRemove.call(this, event);
      if (!event.isCollapse) {
        const me = this, deselectedRecords = event.records.filter((rec) => this.isSelected(rec));
        if (deselectedRecords.length) {
          const selectionChange = me.prepareSelection(deselectedRecords);
          if (me.isCellSelectionMode) {
            const {
              deselectedCells
            } = me.prepareSelection(me.getSelectedCellsForRecords(deselectedRecords));
            if (deselectedCells !== null && deselectedCells !== void 0 && deselectedCells.length) {
              selectionChange.deselectedCells = (selectionChange.deselectedCells || []).concat(deselectedCells);
            }
          }
          me.performSelection(selectionChange);
        }
      }
    }
    onStoreDataChange({
      action,
      source: store
    }) {
      var _super$onStoreDataCha;
      const me = this, {
        selectionMode
      } = me;
      let selectionChange;
      (_super$onStoreDataCha = super.onStoreDataChange) === null || _super$onStoreDataCha === void 0 ? void 0 : _super$onStoreDataCha.call(this, ...arguments);
      if (action === "pageLoad") {
        if (!selectionMode.preserveSelectionOnPageChange) {
          selectionChange = me.prepareSelection(null, null, true);
        }
        me.updateCheckboxHeader();
      } else if (isDataLoadAction[action]) {
        const deselect = [];
        if (selectionMode.preserveSelectionOnDatasetChange === false) {
          selectionChange = me.prepareSelection(null, null, true);
        } else {
          deselect.push(...me.changeSelectedRecordCollectionSilent((c) => c.match(store.storage)));
          for (const selectedCell of me._selectedCells) {
            if (!store.getById(selectedCell.id)) {
              deselect.push(selectedCell);
            }
          }
          selectionChange = me.prepareSelection(deselect);
        }
      }
      if (selectionChange) {
        me.performSelection(selectionChange, false);
        me.updateCheckboxHeader();
      }
    }
    onStoreRemoveAll() {
      var _super$onStoreRemoveA;
      (_super$onStoreRemoveA = super.onStoreRemoveAll) === null || _super$onStoreRemoveA === void 0 ? void 0 : _super$onStoreRemoveA.call(this);
      this.performSelection(this.prepareSelection(null, null, true), false);
    }
    onCheckChange({
      checked,
      record
    }) {
      const me = this, deselectAll = !me.selectionMode.multiSelect && checked, deselect = !deselectAll && !checked ? [record] : null, select = checked ? [record] : null;
      if (checked && !GlobalEvents$1.shiftKeyDown) {
        me._lastSelectionChecked = record;
      }
      if (checked && me._lastSelectionChecked && GlobalEvents$1.shiftKeyDown) {
        me.performSelection(me.internalSelectRange(me._lastSelectionChecked, record, true));
      } else {
        me.performSelection(me.prepareSelection(deselect, select, deselectAll, true));
      }
    }
    updateCheckboxHeader() {
      const {
        selectionMode,
        checkboxSelectionColumn,
        store
      } = this;
      if (selectionMode.checkbox && selectionMode.showCheckAll && checkboxSelectionColumn !== null && checkboxSelectionColumn !== void 0 && checkboxSelectionColumn.headerCheckbox) {
        const allSelected = store.count && !store.some((record) => !this.isSelected(record));
        if (checkboxSelectionColumn.headerCheckbox.checked !== allSelected) {
          checkboxSelectionColumn.suspendEvents();
          checkboxSelectionColumn.headerCheckbox.checked = allSelected;
          checkboxSelectionColumn.resumeEvents();
        }
      }
    }
    onCheckAllChange({
      checked
    }) {
      this[checked ? "selectAll" : "deselectAll"](this.store.isPaged && this.selectionMode.preserveSelectionOnPageChange);
    }
    onSelectionDrag(event) {
      const me = this, {
        _selectionStartCell
      } = me;
      if (!GlobalEvents$1.isMouseDown()) {
        me.onSelectionEnd();
      }
      if (!_selectionStartCell) {
        return;
      }
      const {
        items: items2,
        _lastSelectionDragRegion
      } = me, cellData = me.getCellDataFromEvent(event, true), region = cellData === null || cellData === void 0 ? void 0 : cellData.column.region, cellSelector = (cellData === null || cellData === void 0 ? void 0 : cellData.cellSelector) && me.normalizeCellContext(cellData.cellSelector);
      if (cellSelector && !cellSelector.equals(me._lastSelectionDragCell, true)) {
        if (!me._isSelectionDragging) {
          me.enableScrollingCloseToEdges(items2);
        }
        if (me._clearSelectionOnSelectionDrag && !_selectionStartCell.equals(cellSelector, true)) {
          me.deselectAll();
          delete me._clearSelectionOnSelectionDrag;
        }
        if (_lastSelectionDragRegion && region !== _lastSelectionDragRegion) {
          var _me$scrollManager$_ac, _me$scrollManager$_ac2;
          const leavingSubGrid = me.subGrids[_lastSelectionDragRegion], enteringSubGrid = me.subGrids[region], leavingScrollable = leavingSubGrid.scrollable, enteringScrollable = enteringSubGrid.scrollable, goingForward = items2.indexOf(leavingSubGrid) - items2.indexOf(enteringSubGrid) < 0;
          enteringScrollable.x = goingForward ? 0 : enteringScrollable.maxX;
          if (goingForward ? leavingScrollable.x < leavingScrollable.maxX - 1 : leavingScrollable.x > 1) {
            return;
          }
          (_me$scrollManager$_ac = me.scrollManager._activeScroll) === null || _me$scrollManager$_ac === void 0 ? void 0 : (_me$scrollManager$_ac2 = _me$scrollManager$_ac.horizontal) === null || _me$scrollManager$_ac2 === void 0 ? void 0 : _me$scrollManager$_ac2.stopScroll();
        }
        me._lastSelectionDragRegion = region;
        me._lastSelectionDragCell = cellSelector;
        me._isSelectionDragging = true;
        const selectionChange = me._lastSelectionDragChange = me.internalSelectRange(_selectionStartCell, cellSelector, me.isRowNumberSelecting(cellSelector) || me.isRowNumberSelecting(_selectionStartCell));
        selectionChange.deselectedCells = selectionChange.deselectedCells.filter((cell) => !me.isCellSelected(cell));
        selectionChange.deselectedRecords = selectionChange.deselectedRecords.filter((record) => !me.isSelected(record));
        me.refreshGridSelectionUI(selectionChange);
        me.trigger("dragSelecting", selectionChange);
      }
    }
    onSelectionEnd() {
      var _me$_selectionListene3, _me$_selectionListene4;
      const me = this, lastChange = me._lastSelectionDragChange;
      if (me._isSelectionDragging && !me._selectionStartCell.equals(me._lastSelectionDragCell, true) && lastChange) {
        me.performSelection(lastChange, false);
      }
      me.disableScrollingCloseToEdges(me.items);
      me._isSelectionDragging = false;
      me._lastSelectionDragChange = null;
      me._lastSelectionDragCell = null;
      (_me$_selectionListene3 = (_me$_selectionListene4 = me._selectionListenersDetachers).selectiondrag) === null || _me$_selectionListene3 === void 0 ? void 0 : _me$_selectionListene3.call(_me$_selectionListene4);
      delete me._selectionListenersDetachers.selectiondrag;
    }
    onHandleElementClick(event) {
      const me = this;
      if (me.selectionMode.rowNumber && event.target.closest(".b-rownumber-header")) {
        event.handled = true;
        if (me.store.count && me.store.some((record) => !me.isSelected(record))) {
          me.selectAll();
        } else {
          me.deselectAll();
        }
      } else if (me.selectionMode.column && event.target.closest(".b-grid-header")) {
        event.handled = true;
        me.selectColumn(event, event.ctrlKey);
      }
      super.onHandleElementClick(event);
    }
    selectColumn(event, addToSelection = false) {
      const me = this, {
        store
      } = me, {
        columnId
      } = me.getHeaderDataFromEvent(event);
      me._shiftSelectRange = null;
      if (!event.shiftKey) {
        me._shiftSelectColumn = columnId;
      }
      const fromColumnId = event.shiftKey && me._shiftSelectColumn || columnId, selectionChange = me.internalSelectRange(me.normalizeCellContext({
        id: store.first.id,
        columnId: fromColumnId
      }), me.normalizeCellContext({
        id: store.last.id,
        columnId
      }));
      if (addToSelection && !selectionChange.selectedCells.some((sc) => !me.isCellSelected(sc))) {
        selectionChange.deselectedCells = selectionChange.selectedCells;
        selectionChange.selectedCells = [];
      }
      if (!addToSelection) {
        selectionChange.deselectedCells = me._selectedCells;
      }
      me.cleanSelectionChange(selectionChange);
      me.performSelection(selectionChange);
    }
    isSelected(cellSelectorOrId) {
      var _cellSelectorOrId;
      if ((_cellSelectorOrId = cellSelectorOrId) !== null && _cellSelectorOrId !== void 0 && _cellSelectorOrId.id) {
        cellSelectorOrId = cellSelectorOrId.id;
      }
      if (validIdTypes[typeof cellSelectorOrId]) {
        return Boolean(this.selectedRecordCollection.get(cellSelectorOrId));
      }
      return false;
    }
    isCellSelected(cellSelector, includeRow) {
      cellSelector = this.normalizeCellContext(cellSelector);
      return this.isCellSelectionMode && this._selectedCells.some((cell) => cellSelector.equals(cell, true)) || includeRow && this.isSelected(cellSelector);
    }
    isSelectable(recordCellOrId) {
      return this.normalizeCellContext({
        id: recordCellOrId.id || recordCellOrId
      }).isSelectable;
    }
    get selectedRecord() {
      return this.selectedRecords[this.selectedRecords.length - 1] || null;
    }
    set selectedRecord(record) {
      this.selectRow({
        record
      });
    }
    get selectedRecords() {
      return this.selectedRecordCollection.values;
    }
    set selectedRecords(selectedRecords) {
      this.selectRows(selectedRecords);
    }
    spliceSelectedRecords(index, toRemove, toAdd) {
      const me = this;
      if (typeof toRemove == "number") {
        const select = [...me.selectedRecords];
        select.splice(index, toRemove, ...ArrayHelper.asArray(toAdd));
        me.performSelection(me.prepareSelection(null, select, true, true));
      } else {
        me.performSelection(me.prepareSelection(toRemove, toAdd, false, true));
      }
    }
    selectRow(options) {
      if (typeof options === "number" || options.isModel || !("record" in options)) {
        options = {
          records: [options]
        };
      }
      ObjectHelper.assignIf(options, {
        scrollIntoView: true
      });
      this.selectRows(options);
    }
    selectRows(options) {
      if (!options || Array.isArray(options) || options.isModel || typeof options === "number" || !("records" in options) && !("record" in options)) {
        options = {
          records: ArrayHelper.asArray(options) || []
        };
      }
      const me = this, {
        store
      } = me, toSelect = [], {
        records = options.record ? [options.record] : [],
        column = me.columns.visibleColumns[0],
        scrollIntoView,
        addToSelection = arguments[1]
      } = options;
      for (let record of records) {
        record = store.getById(record);
        if (record) {
          toSelect.push(record);
        }
      }
      if (!addToSelection) {
        me._shiftSelectRange = null;
      }
      me.performSelection(me.prepareSelection(null, toSelect, !addToSelection, true));
      if (toSelect.length && scrollIntoView) {
        me.scrollRowIntoView(toSelect[0].id, {
          column
        });
      }
    }
    selectAll(silent = false) {
      const {
        store
      } = this, records = (store.isGrouped ? store.allRecords : store.records).filter((r) => !r.isSpecialRow);
      this.performSelection(this.prepareSelection(null, records, false, true), true, silent);
    }
    deselectAll(removeCurrentRecordsOnly = false, silent = false) {
      const {
        store
      } = this, records = removeCurrentRecordsOnly ? (store.isGrouped ? store.allRecords : store.records).filter((r) => !r.isSpecialRow) : null;
      this.performSelection(this.prepareSelection(records, null, !removeCurrentRecordsOnly), true, silent);
    }
    deselectRow(record) {
      this.deselectRows(record);
    }
    deselectRows(recordsOrIds) {
      const {
        store
      } = this, records = ArrayHelper.asArray(recordsOrIds).map((recordOrId) => store.getById(recordOrId)).filter((rec) => rec);
      this.performSelection(this.prepareSelection(records));
    }
    selectRange(fromId, toId, addToSelection = false) {
      const me = this, {
        store
      } = me, selection = me.internalSelectRange(store.getById(fromId), store.getById(toId), true);
      me._shiftSelectRange = null;
      me.performSelection(selection);
    }
    get selectedCell() {
      return this._selectedCells[this._selectedCells.length - 1];
    }
    set selectedCell(cellSelector) {
      this.selectCells([cellSelector]);
    }
    get selectedCells() {
      return [...this._selectedCells];
    }
    set selectedCells(cellSelectors) {
      this.selectCells(cellSelectors);
    }
    get selectedCellCSSSelector() {
      const cell = this.selectedCell, row = cell && this.getRowById(cell.id);
      if (!cell || !row)
        return "";
      return `[data-index=${row.dataIndex}] [data-column-id=${cell.columnId}]`;
    }
    selectCell(options) {
      var _this$selectCells;
      if ("id" in options) {
        options = {
          cell: options
        };
        options = Object.assign({
          scrollIntoView: arguments[1],
          addToSelection: arguments[2],
          silent: arguments[3]
        }, options);
      }
      return (_this$selectCells = this.selectCells(options)) === null || _this$selectCells === void 0 ? void 0 : _this$selectCells[0];
    }
    selectCells(options) {
      if (Array.isArray(options)) {
        options = {
          cells: options
        };
      }
      const me = this, {
        cells = options.cell ? [options.cell] : [],
        scrollIntoView = true,
        addToSelection = false,
        silent = false
      } = options, selectionChange = me.prepareSelection(null, cells, !addToSelection);
      if (!addToSelection) {
        me._shiftSelectRange = null;
      }
      me.performSelection(selectionChange, true, silent);
      if (scrollIntoView) {
        me.scrollRowIntoView(cells[0].id, {
          column: cells[0].columnId
        });
      }
      return me.isCellSelectionMode ? selectionChange.selectedCells : selectionChange.selectedRecords;
    }
    deselectCell(cellSelector) {
      var _this$deselectCells;
      return (_this$deselectCells = this.deselectCells([cellSelector])) === null || _this$deselectCells === void 0 ? void 0 : _this$deselectCells[0];
    }
    deselectCells(cellSelectors) {
      const selectionChange = this.prepareSelection(cellSelectors);
      this.performSelection(selectionChange);
      return this.isCellSelectionMode ? selectionChange.deselectedCells : selectionChange.deselectedRecords;
    }
    toggleSelection(keyEvent) {
      const me = this, {
        _focusedCell,
        selectionMode
      } = me, isRowNumber = me.isRowNumberSelecting(_focusedCell), isSelected = me.isCellSelected(_focusedCell, true);
      if (selectionMode.selectOnKeyboardNavigation === true || _focusedCell.isActionable) {
        return false;
      }
      me.performSelection(me.prepareSelection(isSelected ? _focusedCell : null, isSelected ? null : _focusedCell, !selectionMode.multiSelect, isRowNumber));
      keyEvent.preventDefault();
    }
    selectCellRange(from, to) {
      this.performSelection(this.internalSelectRange(from, to));
    }
    getSelection() {
      if (this.isRowSelectionMode) {
        return this.selectedRecords;
      } else {
        return this.selectedCells;
      }
    }
    cleanSelectionChange(selectionChange) {
      const {
        deselectedRecords,
        selectedRecords,
        deselectedCells,
        selectedCells
      } = selectionChange;
      if (deselectedRecords !== null && deselectedRecords !== void 0 && deselectedRecords.length && selectedRecords !== null && selectedRecords !== void 0 && selectedRecords.length) {
        selectionChange.deselectedRecords = deselectedRecords.filter((dr) => !selectedRecords.some((sr) => dr === sr));
      }
      if (deselectedCells !== null && deselectedCells !== void 0 && deselectedCells.length && selectedCells !== null && selectedCells !== void 0 && selectedCells.length) {
        selectionChange.deselectedCells = deselectedCells.filter((dc) => !selectedCells.some((sc) => dc.equals(sc, true)));
      }
      return selectionChange;
    }
    getSelectedCellsForRecords(records) {
      return this._selectedCells.filter((cell) => cell.id && records.some((record) => record.id === cell.id));
    }
    delayUntilMouseUp(fn2) {
      const detacher2 = EventHelper.on({
        element: globalThis,
        blur: (ev) => fn2(ev, detacher2),
        mouseup: (ev) => fn2(ev, detacher2),
        thisObj: this,
        once: true
      });
    }
    get isRowSelectionMode() {
      return !this.isCellSelectionMode;
    }
    get isCellSelectionMode() {
      return this.selectionMode.cell === true;
    }
    isRowNumberSelecting(...selectors) {
      return this.selectionMode.rowNumber && !selectors.some((cs) => cs.column.type !== "rownumber");
    }
    extendSelectionLeft() {
      this.extendSelection("Left");
    }
    extendSelectionRight() {
      this.extendSelection("Right");
    }
    extendSelectionUp() {
      this.extendSelection("Up");
    }
    extendSelectionDown() {
      this.extendSelection("Down");
    }
    extendSelection(dir) {
      this._isKeyboardRangeSelecting = true;
      this["navigate" + dir]();
      this._isKeyboardRangeSelecting = false;
    }
    onCellNavigate(me, fromCellSelector, toCellSelector, doSelect) {
      var _toCellSelector$recor;
      const {
        selectionMode,
        _selectionListenersDetachers
      } = me, {
        rowReorder
      } = me.features, {
        multiSelect,
        deselectOnClick,
        dragSelect
      } = selectionMode, {
        ctrlKeyDown,
        shiftKeyDown
      } = GlobalEvents$1, isMouseLeft = GlobalEvents$1.isMouseDown(), isMouseRight = GlobalEvents$1.isMouseDown(2), currentEvent = GlobalEvents$1.currentMouseDown || GlobalEvents$1.currentKeyDown, currentTarget = currentEvent === null || currentEvent === void 0 ? void 0 : currentEvent.target;
      toCellSelector = me.normalizeCellContext(toCellSelector);
      if (!doSelect || toCellSelector.rowIndex === -1 || (_toCellSelector$recor = toCellSelector.record) !== null && _toCellSelector$recor !== void 0 && _toCellSelector$recor.isGroupHeader || currentEvent !== null && currentEvent !== void 0 && currentEvent.fromKeyMap && !selectionMode.selectOnKeyboardNavigation || me.columns.getById(toCellSelector.columnId) === me.checkboxSelectionColumn || selectionMode.checkboxOnly || currentTarget && rowReorder !== null && rowReorder !== void 0 && rowReorder.gripOnly && rowReorder.isElementDraggable(currentTarget, currentEvent) || (currentEvent === null || currentEvent === void 0 ? void 0 : currentEvent.handled) === true) {
        return;
      }
      if (!shiftKeyDown) {
        me._isAddingToSelection = ctrlKeyDown && multiSelect;
        me._selectionStartCell = toCellSelector;
      }
      if (multiSelect && dragSelect && isMouseLeft && !_selectionListenersDetachers.selectiondrag) {
        _selectionListenersDetachers.selectiondrag = EventHelper.on({
          name: "selectiondrag",
          element: globalThis,
          blur: "onSelectionEnd",
          mouseup: "onSelectionEnd",
          mousemove: "onSelectionDrag",
          thisObj: me
        });
      }
      const startCell = me._selectionStartCell, adding = me._isAddingToSelection;
      if ((shiftKeyDown && isMouseLeft || me._isKeyboardRangeSelecting) && startCell && multiSelect) {
        me.performSelection(me.internalSelectRange(startCell, toCellSelector, me.isRowNumberSelecting(startCell, toCellSelector)));
      } else {
        let delay2 = false, continueSelecting = true, deselect;
        if (me.isCellSelected(toCellSelector, true)) {
          if (isMouseRight) {
            return;
          }
          if (adding || deselectOnClick) {
            deselect = deselectOnClick ? null : [toCellSelector];
            continueSelecting = false;
          } else if (me.selectedRecords.length + (me.isCellSelectionMode ? me._selectedCells.length : 0) <= 1) {
            return;
          }
          delay2 = deselectOnClick || multiSelect;
        }
        if (!deselect && !adding) {
          deselect = null;
          if (dragSelect && delay2 && _selectionListenersDetachers.selectiondrag) {
            me._clearSelectionOnSelectionDrag = true;
          }
        }
        const finishSelection = (mouseUpEvent, detacher2) => {
          var _mouseUpEvent$target;
          detacher2 === null || detacher2 === void 0 ? void 0 : detacher2();
          if ((mouseUpEvent === null || mouseUpEvent === void 0 ? void 0 : (_mouseUpEvent$target = mouseUpEvent.target) === null || _mouseUpEvent$target === void 0 ? void 0 : _mouseUpEvent$target.nodeType) === Node.ELEMENT_NODE) {
            const mouseUpSelector = new Location(mouseUpEvent.target);
            if (mouseUpSelector !== null && mouseUpSelector !== void 0 && mouseUpSelector.grid && !mouseUpSelector.equals(toCellSelector, true)) {
              return;
            }
          }
          if (!shiftKeyDown) {
            me._shiftSelectRange = null;
          }
          me.performSelection(me.prepareSelection(deselect, continueSelecting && [toCellSelector], deselect === null, continueSelecting && me.isRowNumberSelecting(toCellSelector)));
        };
        if (delay2) {
          me.delayUntilMouseUp(finishSelection);
        } else {
          finishSelection();
        }
      }
    }
    prepareSelection(cellSelectorsToDeselect, cellSelectorsToSelect, deselectAll = false, forceRecordSelection = false) {
      const me = this, isDragging = me._isSelectionDragging, {
        includeParents
      } = me.selectionMode, selectedRecords = [], selectedCells = [];
      let deselectedCells = [], deselectedRecords = [];
      if (deselectAll) {
        deselectedCells = me._selectedCells;
        deselectedRecords = me.selectedRecords;
      } else if (cellSelectorsToDeselect) {
        for (const selector of ArrayHelper.asArray(cellSelectorsToDeselect)) {
          const cellSelector = me.normalizeCellContext(selector), record = (cellSelector === null || cellSelector === void 0 ? void 0 : cellSelector.record) || (selector.isModel ? selector : me.store.getById(cellSelector.id));
          if (!cellSelector.isSpecialRow) {
            deselectedCells.push(cellSelector);
            if (record && !deselectedRecords.some((r) => r.id === record.id)) {
              var _record$allChildren;
              if (isDragging || me.isSelected(record)) {
                deselectedRecords.push(record);
              }
              if (me.selectionMode.includeChildren && me.selectionMode.multiSelect && !record.isLeaf && (_record$allChildren = record.allChildren) !== null && _record$allChildren !== void 0 && _record$allChildren.length) {
                for (const child of record.allChildren) {
                  if (!deselectedRecords.some((r) => r.id === child.id) && (isDragging || me.isSelected(child))) {
                    deselectedRecords.push(child);
                  }
                }
              }
            }
          }
        }
      }
      if (cellSelectorsToSelect) {
        for (const selector of ArrayHelper.asArray(cellSelectorsToSelect)) {
          const cellSelector = me.normalizeCellContext(selector), record = (cellSelector === null || cellSelector === void 0 ? void 0 : cellSelector.record) || (selector.isModel ? selector : me.store.getById(cellSelector.id));
          if (record && !cellSelector.isSpecialRow) {
            if (me.isCellSelectionMode && !forceRecordSelection) {
              selectedCells.push(cellSelector);
            }
            if ((me.isRowSelectionMode || forceRecordSelection) && !selectedRecords.some((r) => r.id === record.id)) {
              var _record$allChildren2;
              selectedRecords.push(record);
              if (me.selectionMode.includeChildren && me.selectionMode.multiSelect && !record.isLeaf && (_record$allChildren2 = record.allChildren) !== null && _record$allChildren2 !== void 0 && _record$allChildren2.length) {
                for (const child of record.allChildren) {
                  if (!selectedRecords.some((r) => r.id === child.id)) {
                    selectedRecords.push(child);
                  }
                }
              }
            }
          }
        }
      }
      if (includeParents && (deselectedRecords.length || selectedRecords.length)) {
        const allChanges = [...deselectedRecords, ...selectedRecords], lowestLevelParents = ArrayHelper.unique(allChanges.filter((rec) => rec.parent && !rec.allChildren.some((child) => allChanges.includes(child))).map((rec) => rec.parent));
        lowestLevelParents.forEach((parent) => me.toggleParentSelection(parent, selectedRecords, deselectedRecords));
      }
      return me.cleanSelectionChange({
        selectedCells,
        selectedRecords,
        deselectedCells,
        deselectedRecords,
        deselectAll,
        action: selectedRecords !== null && selectedRecords !== void 0 && selectedRecords.length || selectedCells !== null && selectedCells !== void 0 && selectedCells.length ? "select" : "deselect"
      });
    }
    toggleParentSelection(parent, toSelect, toDeselect) {
      if (!parent || parent.isRoot) {
        return;
      }
      const isSelected = this.isSelected(parent), inToSelect = toSelect.includes(parent), inToDeselect = toDeselect.includes(parent), childIsSelected = (child) => this.isSelected(child) && !toDeselect.includes(child) || toSelect.includes(child);
      if (this.selectionMode.includeParents === "some") {
        if (parent.allChildren.some(childIsSelected)) {
          if ((!isSelected || inToDeselect) && !inToSelect) {
            toSelect.push(parent);
          }
        } else if (isSelected && !inToDeselect) {
          toDeselect.push(parent);
        }
      } else {
        if (isSelected) {
          if (!inToDeselect && !inToSelect && parent.allChildren.some((child) => toDeselect.includes(child))) {
            toDeselect.push(parent);
          }
        } else if (!inToSelect) {
          if (parent.allChildren.every(childIsSelected)) {
            toSelect.push(parent);
          }
        }
      }
      if (parent.parent) {
        this.toggleParentSelection(parent.parent, toSelect, toDeselect);
      }
    }
    internalSelectRange(fromSelector, toSelector, forceRecordSelection = false) {
      const me = this, selectRecords = me.isRowSelectionMode || forceRecordSelection, selectionChange = me.prepareSelection(me._shiftSelectRange, me.getRange(fromSelector, toSelector, selectRecords), false, forceRecordSelection);
      me._shiftSelectRange = selectionChange[`selected${selectRecords ? "Records" : "Cells"}`];
      return selectionChange;
    }
    getRange(fromSelector, toSelector, selectRecords = false) {
      const me = this, {
        store
      } = me, fromCell = me.normalizeCellContext(fromSelector), toCell = me.normalizeCellContext(toSelector), startRowIndex = Math.min(fromCell.rowIndex, toCell.rowIndex), endRowIndex = Math.max(fromCell.rowIndex, toCell.rowIndex), toSelect = [], startColIndex = Math.min(fromCell.columnIndex, toCell.columnIndex), endColIndex = Math.max(fromCell.columnIndex, toCell.columnIndex);
      if (startRowIndex === -1 || endRowIndex === -1) {
        throw new Error("Record not found in selectRange");
      }
      if (selectRecords) {
        const range = store.getRange(startRowIndex, endRowIndex + 1, false);
        if (toCell.rowIndex < fromCell.rowIndex) {
          range.reverse();
        }
        toSelect.push(...range);
      } else {
        for (let rIx = startRowIndex; rIx <= endRowIndex; rIx++) {
          for (let cIx = startColIndex; cIx <= endColIndex; cIx++) {
            toSelect.push({
              rowIndex: rIx,
              columnIndex: cIx
            });
          }
        }
      }
      return toSelect.map((s) => me.normalizeCellContext(s));
    }
    performSelection(selectionChange, updateUI = true, silent = false) {
      const me = this, {
        selectedRecords,
        selectedCells,
        deselectedRecords,
        deselectedCells,
        action
      } = selectionChange, rowMode = me.isRowSelectionMode;
      if (me.trigger("beforeSelectionChange", {
        mode: rowMode ? "row" : "cell",
        action,
        selected: (rowMode ? selectedRecords : selectedCells) || [],
        deselected: (rowMode ? deselectedRecords : deselectedCells) || [],
        selection: (rowMode ? me.selectedRecords : me.selectedCells) || []
      }) === false) {
        return;
      }
      if (me._selectedCells === deselectedCells) {
        me._selectedCells = [];
      } else {
        const keepCells = [];
        for (const selectedCell of me._selectedCells) {
          if (!deselectedCells.some((cellSelector) => selectedCell.equals(cellSelector, true))) {
            keepCells.push(selectedCell);
          }
        }
        me._selectedCells = keepCells;
      }
      selectionChange.deselectedRecords = [...selectionChange.deselectedRecords];
      if (deselectedRecords === me.selectedRecords) {
        me.changeSelectedRecordCollectionSilent((c) => c.clear());
      } else {
        const keepRecords = [];
        for (const selectedRecord of me.selectedRecords) {
          if (!deselectedRecords.some((record) => selectedRecord.id === record.id)) {
            keepRecords.push(selectedRecord);
          }
        }
        me.changeSelectedRecordCollectionSilent((c) => c.values = keepRecords);
      }
      if (selectedCells.length) {
        for (const selectedCell of selectedCells) {
          if (!me._selectedCells.some((cellSelector) => cellSelector.equals(selectedCell, true))) {
            me._selectedCells.push(selectedCell);
          }
        }
      }
      if (selectedRecords.length) {
        me.changeSelectedRecordCollectionSilent((c) => c.add(...selectedRecords));
      }
      if (updateUI) {
        me.refreshGridSelectionUI(selectionChange);
      }
      me.afterSelectionChange(selectionChange);
      if (!silent) {
        me.triggerSelectionChangeEvent(selectionChange);
      }
    }
    refreshGridSelectionUI({
      selectedRecords,
      selectedCells,
      deselectedRecords,
      deselectedCells
    }) {
      const me = this, {
        checkboxSelectionColumn
      } = me;
      checkboxSelectionColumn === null || checkboxSelectionColumn === void 0 ? void 0 : checkboxSelectionColumn.suspendEvents();
      me.updateGridSelectionRecords(selectedRecords, true);
      me.updateGridSelectionRecords(deselectedRecords, false);
      me.updateCheckboxHeader();
      checkboxSelectionColumn === null || checkboxSelectionColumn === void 0 ? void 0 : checkboxSelectionColumn.resumeEvents();
      if (me.isCellSelectionMode) {
        me.updateGridSelectionCells(selectedCells, true);
        if (me.selectionMode.column) {
          me.updateGridSelectionColumns(selectedCells);
        }
      }
      me.updateGridSelectionCells(deselectedCells, false);
    }
    updateGridSelectionRecords(records, selected) {
      const {
        checkboxSelectionColumn
      } = this;
      if (records !== null && records !== void 0 && records.length) {
        for (let i = 0; i < records.length; i++) {
          const row = this.getRowFor(records[i]);
          if (row) {
            row.toggleCls("b-selected", selected);
            row.setAttribute("aria-selected", selected);
            if (checkboxSelectionColumn && !checkboxSelectionColumn.hidden && !records[i].isSpecialRow) {
              row.getCell(checkboxSelectionColumn.id).widget.checked = selected;
            }
          }
        }
      }
    }
    updateGridSelectionCells(cells, selected) {
      if (cells !== null && cells !== void 0 && cells.length) {
        for (let i = 0; i < cells.length; i++) {
          const cell = this.getCell(cells[i]);
          if (cell) {
            cell.setAttribute("aria-selected", selected);
            cell.classList.toggle("b-selected", selected);
          }
        }
      }
    }
    updateGridSelectionColumns(selectedCells) {
      const {
        count
      } = this.store;
      for (const column of this.columns.visibleColumns) {
        var _column$element;
        (_column$element = column.element) === null || _column$element === void 0 ? void 0 : _column$element.classList.toggle("b-selected", (selectedCells === null || selectedCells === void 0 ? void 0 : selectedCells.filter((s) => s.columnId === column.id).length) === count);
      }
    }
    triggerSelectionChangeEvent(selectionChange) {
      const rowMode = this.isRowSelectionMode;
      this.trigger("selectionChange", {
        mode: rowMode ? "row" : "cell",
        action: selectionChange.action,
        selected: (rowMode ? selectionChange.selectedRecords : selectionChange.selectedCells) || [],
        deselected: (rowMode ? selectionChange.deselectedRecords : selectionChange.deselectedCells) || [],
        selection: (rowMode ? this.selectedRecords : this.selectedCells) || []
      });
    }
    doDestroy() {
      var _this$selectedRecordC;
      (_this$selectedRecordC = this.selectedRecordCollection) === null || _this$selectedRecordC === void 0 ? void 0 : _this$selectedRecordC.destroy();
      this._selectedCells.length = 0;
      for (const detacher2 in this._selectionListenersDetachers) {
        this._selectionListenersDetachers[detacher2]();
      }
      super.doDestroy();
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "configurable", {
    selectionMode: {
      cell: false,
      multiSelect: true,
      checkboxOnly: false,
      checkbox: false,
      checkboxPosition: null,
      showCheckAll: false,
      deselectFilteredOutRecords: false,
      includeChildren: false,
      includeParents: false,
      preserveSelectionOnPageChange: false,
      preserveSelectionOnDatasetChange: true,
      deselectOnClick: false,
      dragSelect: false,
      selectOnKeyboardNavigation: true,
      column: false,
      rowNumber: false
    },
    keyMap: {
      "Shift+ArrowUp": "extendSelectionUp",
      "Shift+ArrowDown": "extendSelectionDown",
      "Shift+ArrowLeft": "extendSelectionLeft",
      "Shift+ArrowRight": "extendSelectionRight",
      " ": {
        handler: "toggleSelection",
        weight: 10
      }
    },
    selectedRecordCollection: {}
  }), _class;
};
var suspendStoreEvents = (subGrid) => subGrid.columns.suspendEvents();
var resumeStoreEvents = (subGrid) => subGrid.columns.resumeEvents();
var fillSubGridColumns = (subGrid) => {
  subGrid.columns.clearCaches();
  subGrid.columns.fillFromMaster();
};
var compareStateSortIndex = (a, b) => a.stateSortIndex - b.stateSortIndex;
var GridState = (Target) => class GridState extends (Target || Base$1) {
  static get $name() {
    return "GridState";
  }
  static get configurable() {
    return {
      statefulEvents: ["subGridCollapse", "subGridExpand", "horizontalScroll", "stateChange"]
    };
  }
  updateStore(store, was) {
    var _super$updateStore;
    (_super$updateStore = super.updateStore) === null || _super$updateStore === void 0 ? void 0 : _super$updateStore.call(this, store, was);
    this.detachListeners("stateStoreListeners");
    store === null || store === void 0 ? void 0 : store.ion({
      name: "stateStoreListeners",
      filter: "triggerUpdate",
      group: "triggerUpdate",
      sort: "triggerUpdate",
      thisObj: this
    });
  }
  updateColumns(columns, was) {
    var _super$updateColumns;
    (_super$updateColumns = super.updateColumns) === null || _super$updateColumns === void 0 ? void 0 : _super$updateColumns.call(this, columns, was);
    this.detachListeners("stateColumnListeners");
    columns.ion({
      name: "stateColumnListeners",
      change: "triggerUpdate",
      thisObj: this
    });
  }
  updateRowManager(manager, was) {
    var _super$updateRowManag;
    (_super$updateRowManag = super.updateRowManager) === null || _super$updateRowManag === void 0 ? void 0 : _super$updateRowManag.call(this, manager, was);
    this.detachListeners("stateRowManagerListeners");
    manager.ion({
      name: "stateRowManagerListeners",
      rowHeight: "triggerUpdate",
      thisObj: this
    });
  }
  triggerUpdate() {
    this.trigger("stateChange");
  }
  finalizeInit() {
    super.finalizeInit();
    this.ion({
      selectionChange: "triggerUpdate",
      thisObj: this
    });
  }
  getState() {
    const me = this, style = me.element.style.cssText, state = {
      rowHeight: me.rowHeight
    };
    if (style) {
      state.style = style;
    }
    if (me.selectedCell) {
      const {
        id,
        columnId
      } = me.selectedCell;
      state.selectedCell = {
        id,
        columnId
      };
    }
    state.selectedRecords = me.selectedRecords.map((entry) => entry.id);
    state.columns = me.columns.allRecords.map((column) => column.getState());
    state.store = me.store.state;
    state.scroll = me.storeScroll();
    state.subGrids = {};
    me.eachSubGrid((subGrid) => {
      var _subGrid$collapsed;
      const config = state.subGrids[subGrid.region] = state.subGrids[subGrid.region] || {};
      if (subGrid.isPainted) {
        if (subGrid.flex == null) {
          config.width = subGrid.width;
        }
      } else {
        if (subGrid.config.width != null) {
          config.width = subGrid.config.width;
        } else {
          config.flex = subGrid.config.flex;
        }
      }
      config.collapsed = (_subGrid$collapsed = subGrid.collapsed) !== null && _subGrid$collapsed !== void 0 ? _subGrid$collapsed : false;
      if (config.collapsed) {
        config._beforeCollapseState = subGrid._beforeCollapseState;
      }
    });
    return state;
  }
  applyState(state) {
    const me = this;
    me.suspendRefresh();
    if ("columns" in state) {
      let columnsChanged = false, needSort = false;
      me.columns.suspendEvents();
      me.eachSubGrid(suspendStoreEvents);
      state.columns.forEach((columnState, index) => {
        const column = me.columns.getById(columnState.id);
        if (column) {
          const columnGeneration = column.generation;
          column.applyState(columnState);
          columnsChanged = columnsChanged || column.generation !== columnGeneration;
          column.stateSortIndex = index;
          if (column.allIndex !== index) {
            needSort = columnsChanged = true;
          }
        }
      });
      if (columnsChanged) {
        me.eachSubGrid(fillSubGridColumns);
      }
      if (needSort) {
        me.eachSubGrid((subGrid) => {
          subGrid.columns.records.sort(compareStateSortIndex);
          subGrid.columns.allRecords.sort(compareStateSortIndex);
        });
        me.columns.sort({
          fn: compareStateSortIndex,
          ascending: true
        });
      }
      if (me.isPainted && columnsChanged) {
        me.renderContents();
      }
      me.columns.resumeEvents();
      me.eachSubGrid(resumeStoreEvents);
    }
    if ("subGrids" in state) {
      me.eachSubGrid((subGrid) => {
        if (subGrid.region in state.subGrids) {
          const subGridState = state.subGrids[subGrid.region];
          if ("width" in subGridState) {
            subGrid.width = subGridState.width;
          } else if ("flex" in subGridState) {
            subGrid.flex = subGridState.flex;
          }
          if ("collapsed" in subGridState) {
            subGrid.collapsed = subGridState.collapsed;
            subGrid._beforeCollapseState = subGridState._beforeCollapseState;
          }
        }
        subGrid.clearWidthCache();
      });
    }
    if ("rowHeight" in state) {
      me.rowHeight = state.rowHeight;
    }
    if ("style" in state) {
      me.style = state.style;
    }
    if ("selectedCell" in state) {
      me.selectedCell = state.selectedCell;
    }
    if ("store" in state) {
      me.store.state = state.store;
    }
    if ("selectedRecords" in state) {
      me.selectedRecords = state.selectedRecords;
    }
    me.resumeRefresh(true);
    me.eachSubGrid((s) => s.refreshFakeScroll());
    if ("scroll" in state) {
      me.restoreScroll(state.scroll);
      if (state.scroll.scrollTop) {
        me.element.querySelectorAll(".b-resize-monitored").forEach((element) => {
          const widget = WidgetHelper.fromElement(element);
          if (widget) {
            widget.onElementResize(element);
          }
        });
      }
    }
  }
  get widgetClass() {
  }
};
var immediatePromise$2 = Promise.resolve();
var defaultScrollOptions$3 = {
  block: "nearest"
};
var SubGridScroller = class extends Scroller {
  static get configurable() {
    return {
      propagate: false,
      overflowX: "hidden-scroll"
    };
  }
  scrollIntoView(element, options = defaultScrollOptions$3) {
    const me = this, {
      xDelta,
      yDelta
    } = me.getDeltaTo(element, options), result = xDelta || yDelta ? me.scrollBy(xDelta, yDelta, options) : immediatePromise$2;
    if (options.highlight || options.focus) {
      result.then(() => {
        if (options.highlight) {
          if (element instanceof Rectangle) {
            element.translate(-xDelta, -yDelta).highlight();
          } else {
            DomHelper.highlight(element);
          }
        }
        options.focus && element.focus && element.focus();
      });
    }
    return result;
  }
  scrollBy(xDelta, yDelta, options) {
    const yPromise = yDelta && this.yScroller.scrollBy(0, yDelta, options), xPromise = xDelta && super.scrollBy(xDelta, 0, options);
    if (xPromise && xPromise.cancel && yPromise && yPromise.cancel) {
      const cancelX = xPromise.cancel, cancelY = yPromise.cancel;
      xPromise.cancel = yPromise.cancel = () => {
        cancelX();
        cancelY();
      };
      return Promise.all([xPromise, yPromise]);
    }
    return xPromise || yPromise || immediatePromise$2;
  }
  scrollTo(toX, toY, options) {
    const yPromise = toY != null && this.yScroller.scrollTo(null, toY, options), xPromise = toX != null && super.scrollTo(toX, null, options);
    if (!(options && options.animate)) {
      this.syncPartners();
    }
    if (xPromise && xPromise.cancel && yPromise && yPromise.cancel) {
      const cancelX = xPromise.cancel, cancelY = yPromise.cancel;
      xPromise.cancel = yPromise.cancel = () => {
        cancelX();
        cancelY();
      };
      return Promise.all([xPromise, yPromise]);
    }
    return xPromise || yPromise || immediatePromise$2;
  }
  get viewport() {
    const elementBounds = Rectangle.from(this.element), viewport = elementBounds.intersect(Rectangle.from(this.yScroller.element));
    return viewport || new Rectangle(elementBounds.x, elementBounds.y, elementBounds.width, 0);
  }
  set y(y) {
    if (this.yScroller) {
      this.yScroller.y = y;
    }
  }
  get y() {
    return this.yScroller ? this.yScroller.y : 0;
  }
  get maxY() {
    return this.yScroller ? this.yScroller.maxY : 0;
  }
  get scrollHeight() {
    return this.yScroller ? this.yScroller.scrollHeight : 0;
  }
  get clientHeight() {
    return this.yScroller ? this.yScroller.clientHeight : 0;
  }
};
SubGridScroller._$name = "SubGridScroller";
var sumWidths = (t, e) => t + e.getBoundingClientRect().width;
var SubGrid = class extends Widget {
  static get $name() {
    return "SubGrid";
  }
  static get type() {
    return "subgrid";
  }
  static get defaultConfig() {
    return {
      insertRowsBefore: null,
      appendTo: null,
      monitorResize: true,
      headerClass: null,
      footerClass: null,
      weight: null,
      collapsed: null,
      scrollable: {
        overflowX: "hidden-scroll"
      },
      scrollerClass: SubGridScroller,
      hasCalculatedWidth: null,
      sealedColumns: null
    };
  }
  static get configurable() {
    return {
      element: true,
      header: {},
      footer: {},
      virtualScrollerElement: true,
      splitterElement: true,
      headerSplitter: true,
      scrollerSplitter: true,
      footerSplitter: true,
      resizable: null,
      role: "presentation"
    };
  }
  construct(config) {
    const me = this;
    super.construct(config);
    this.rowManager.ion({
      addRows: "onAddRow",
      thisObj: this
    });
    if (BrowserHelper.isFirefox) {
      const {
        element
      } = me, verticalScroller = me.grid.scrollable;
      let lastScrollTop = 0;
      element.addEventListener("wheel", ({
        ctrlKey,
        deltaY,
        deltaX
      }) => {
        const isVerticalScroll = Math.abs(deltaY) > Math.abs(deltaX);
        if (!ctrlKey && isVerticalScroll && !me.scrollEndDetacher && verticalScroller.y !== lastScrollTop) {
          element.style.pointerEvents = "none";
          lastScrollTop = verticalScroller.y;
          me.scrollEndDetacher = verticalScroller.ion({
            scrollEnd: async () => {
              lastScrollTop = verticalScroller.y;
              element.style.pointerEvents = "";
              me.scrollEndDetacher = null;
            },
            once: true
          });
        }
      });
    }
  }
  doDestroy() {
    var _me$fakeScroller;
    const me = this;
    me.header.destroy();
    me.footer.destroy();
    (_me$fakeScroller = me.fakeScroller) === null || _me$fakeScroller === void 0 ? void 0 : _me$fakeScroller.destroy();
    me.virtualScrollerElement.remove();
    me.splitterElements.forEach((element) => element.remove());
    super.doDestroy();
  }
  get barConfig() {
    const me = this, {
      width,
      flex
    } = me.element.style, config = {
      subGrid: me,
      parent: me,
      maxWidth: me.maxWidth || void 0,
      minWidth: me.minWidth || void 0
    };
    if (flex) {
      config.flex = flex;
    } else if (width) {
      config.width = width;
    }
    return config;
  }
  changeHeader(header) {
    return new this.headerClass(ObjectHelper.assign({
      id: this.id + "-header"
    }, this.barConfig, header));
  }
  changeFooter(footer) {
    return new this.footerClass(ObjectHelper.assign({
      id: this.id + "-footer"
    }, this.barConfig, footer));
  }
  get splitterElements() {
    return [this.splitterElement, this.headerSplitter, this.scrollerSplitter, this.footerSplitter];
  }
  toggleSplitterCls(cls, add = true) {
    this.splitterElements.forEach((el) => el === null || el === void 0 ? void 0 : el.classList[add ? "add" : "remove"](cls));
  }
  hideSplitter() {
    this.splitterElements.forEach((el) => el.classList.add("b-hide-display"));
    this.$showingSplitter = false;
  }
  showSplitter() {
    this.splitterElements.forEach((el) => el.classList.remove("b-hide-display"));
    this.$showingSplitter = true;
  }
  changeElement(element, was) {
    const {
      region
    } = this;
    return super.changeElement({
      "aria-label": region,
      className: {
        "b-grid-subgrid": 1,
        [`b-grid-subgrid-${region}`]: region,
        "b-grid-subgrid-collapsed": this.collapsed
      },
      dataset: {
        region
      }
    }, was);
  }
  get rowElementConfig() {
    const {
      grid
    } = this;
    return {
      role: "row",
      className: grid.rowCls,
      children: this.columns.visibleColumns.map((column, columnIndex) => ({
        role: "gridcell",
        "aria-colindex": columnIndex + 1,
        tabIndex: grid.cellTabIndex,
        className: "b-grid-cell",
        dataset: {
          column: column.field || "",
          columnId: column.id
        }
      }))
    };
  }
  changeVirtualScrollerElement() {
    const references = DomHelper.createElement({
      role: "presentation",
      reference: "virtualScrollerElement",
      className: "b-virtual-scroller",
      tabIndex: -1,
      dataset: {
        region: this.region
      },
      children: [{
        reference: "virtualScrollerWidth",
        className: "b-virtual-width"
      }]
    });
    this.virtualScrollerWidth = references.virtualScrollerWidth;
    return references.virtualScrollerElement;
  }
  changeSplitterElement() {
    const references = DomHelper.createElement({
      reference: "splitterElement",
      className: {
        "b-grid-splitter": 1,
        "b-grid-splitter-collapsed": this.collapsed,
        "b-hide-display": 1
      },
      dataset: {
        region: this.region
      },
      children: [BrowserHelper.isTouchDevice ? {
        className: "b-splitter-touch-area"
      } : null, {
        className: "b-grid-splitter-inner b-grid-splitter-main",
        children: [{
          className: "b-grid-splitter-buttons",
          reference: "splitterButtons",
          children: [{
            className: "b-grid-splitter-button-collapse",
            children: [BrowserHelper.isTouchDevice ? {
              className: "b-splitter-button-touch-area"
            } : null, {
              tag: "svg",
              ns: "http://www.w3.org/2000/svg",
              version: "1.1",
              className: "b-grid-splitter-button-icon b-gridregion-collapse-arrow",
              viewBox: "0 0 256 512",
              children: [{
                tag: "path",
                d: "M192 448c-8.188 0-16.38-3.125-22.62-9.375l-160-160c-12.5-12.5-12.5-32.75 0-45.25l160-160c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25L77.25 256l137.4 137.4c12.5 12.5 12.5 32.75 0 45.25C208.4 444.9 200.2 448 192 448z"
              }]
            }]
          }, {
            className: "b-grid-splitter-button-expand",
            children: [BrowserHelper.isTouchDevice ? {
              className: "b-splitter-button-touch-area"
            } : null, {
              tag: "svg",
              ns: "http://www.w3.org/2000/svg",
              version: "1.1",
              className: "b-grid-splitter-button-icon b-gridregion-expand-arrow",
              viewBox: "0 0 256 512",
              children: [{
                tag: "path",
                d: "M64 448c-8.188 0-16.38-3.125-22.62-9.375c-12.5-12.5-12.5-32.75 0-45.25L178.8 256L41.38 118.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0l160 160c12.5 12.5 12.5 32.75 0 45.25l-160 160C80.38 444.9 72.19 448 64 448z"
              }]
            }]
          }]
        }]
      }]
    });
    this.splitterButtons = references.splitterButtons;
    return references.splitterElement;
  }
  get splitterConfig() {
    return {
      className: this.splitterElement.className.trim(),
      children: [BrowserHelper.isTouchDevice ? {
        className: "b-splitter-touch-area"
      } : null, {
        className: "b-grid-splitter-inner"
      }],
      dataset: {
        region: this.region
      }
    };
  }
  changeHeaderSplitter() {
    return DomHelper.createElement(this.splitterConfig);
  }
  changeScrollerSplitter() {
    return DomHelper.createElement(this.splitterConfig);
  }
  changeFooterSplitter() {
    return DomHelper.createElement(this.splitterConfig);
  }
  render(...args) {
    const me = this;
    super.render(...args);
    if (me.grid) {
      me.updateHasFlex();
      me.element.parentNode.insertBefore(me.splitterElement, me.element.nextElementSibling);
      me.splitterElements.forEach((element) => EventHelper.on({
        element,
        mouseenter: "onSplitterMouseEnter",
        mouseleave: "onSplitterMouseLeave",
        thisObj: me
      }));
      me._collapsed && me.collapse();
    }
  }
  refreshHeader() {
    this.header.refreshContent();
  }
  refreshFooter() {
    var _this$footer;
    (_this$footer = this.footer) === null || _this$footer === void 0 ? void 0 : _this$footer.refreshContent();
  }
  eachWidget(fn2, deep = true) {
    const me = this, widgets = [me.header, me.footer];
    for (let i = 0; i < widgets.length; i++) {
      const widget = widgets[i];
      if (fn2(widget) === false) {
        return;
      }
      if (deep && widget.eachWidget) {
        widget.eachWidget(fn2, deep);
      }
    }
  }
  fixCellWidths(rowElement) {
    const {
      visibleColumns
    } = this.columns;
    let cell = rowElement.firstElementChild, i = 0;
    while (cell) {
      const column = visibleColumns[i], {
        element
      } = column;
      if (column.minWidth) {
        cell.style.minWidth = DomHelper.setLength(column.minWidth);
      }
      if (column.maxWidth) {
        cell.style.maxWidth = DomHelper.setLength(column.maxWidth);
      }
      if (column.flex) {
        if (column.childLevel && element) {
          cell.style.flex = `0 0 ${element.getBoundingClientRect().width}px`;
          cell.style.width = "";
        } else {
          cell.style.flex = column.flex;
          cell.style.width = "";
        }
      } else if (column.width) {
        cell.style.width = DomHelper.setLength(column.width);
      } else {
        cell.style.flex = cell.style.width = cell.style.minWidth = "";
      }
      cell = cell.nextElementSibling;
      i++;
    }
  }
  get totalFixedWidth() {
    return this.columns.totalFixedWidth;
  }
  fixWidths() {
    const me = this, {
      element,
      header,
      footer
    } = me;
    if (!me.collapsed) {
      if (me.flex) {
        header.flex = me.flex;
        if (footer) {
          footer.flex = me.flex;
        }
        element.style.flex = me.flex;
      } else {
        if (me.hasCalculatedWidth && !me.columns.some((col) => !col.hidden && col.flex) && me.totalFixedWidth !== me.width) {
          me.width = me.totalFixedWidth;
          me.hasCalculatedWidth = true;
          return;
        }
        let totalWidth = me.width;
        if (!totalWidth && me.hasCalculatedWidth) {
          totalWidth = 0;
          for (const col of me.columns) {
            if (!col.flex && !col.hidden)
              totalWidth += col.width;
          }
        }
        element.style.width = `${totalWidth}px`;
        header.width = totalWidth;
        if (footer) {
          footer.width = totalWidth;
        }
      }
      me.syncScrollingPartners(false);
    }
  }
  fixRowWidthsInSafariEdge() {
    if (BrowserHelper.isSafari) {
      const me = this, {
        region,
        header
      } = me, minWidth = header.calculateMinWidthForSafari();
      me.rowManager.forEach((row) => {
        const element = row.getElement(region);
        if (element) {
          element.style.width = `${minWidth}px`;
        }
      });
      header.headersElement.style.width = `${minWidth}px`;
    }
  }
  set width(width) {
    const me = this;
    me.hasCalculatedWidth = false;
    super.width = width;
    me.header.width = width;
    me.footer.width = width;
    if (me.isPainted) {
      me.onElementResize();
    }
  }
  get width() {
    return super.width;
  }
  set flex(flex) {
    const me = this;
    me.hasCalculatedWidth = false;
    me.header.flex = flex;
    me.footer.flex = flex;
    super.flex = flex;
    if (me.isPainted) {
      me.onElementResize();
    }
  }
  get flex() {
    return super.flex;
  }
  onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {
    const me = this, {
      grid
    } = me;
    super.onInternalResize(...arguments);
    if (grid !== null && grid !== void 0 && grid.isPainted) {
      me.syncSplitterButtonPosition();
      if (newWidth !== oldWidth) {
        grid.trigger("horizontalScroll", {
          grid,
          subGrid: me,
          scrollLeft: me.scrollable.element.scrollLeft,
          scrollX: me.scrollable.x
        });
        me.fakeScroller && me.refreshFakeScroll();
        grid.syncFlexedSubCols();
        me.fixRowWidthsInSafariEdge();
      }
      if (newHeight !== oldHeight) {
        grid.onHeightChange();
      }
      me.trigger("afterInternalResize", me);
    }
  }
  syncParallelSplitters(collapsed) {
    const me = this, {
      grid
    } = me;
    if (me.splitterElement && me.$showingSplitter) {
      me.toggleSplitterCls("b-grid-splitter-collapsed", collapsed);
    } else {
      const prevGrid = grid.getSubGrid(grid.getPreviousRegion(me.region));
      if (prevGrid && prevGrid.splitterElement) {
        prevGrid.syncParallelSplitters(collapsed);
      }
    }
  }
  onSplitterMouseEnter() {
    const me = this, {
      nextSibling
    } = me;
    if (!me.collapsed && (!nextSibling || !nextSibling.collapsed)) {
      me.toggleSplitterCls("b-hover");
    }
    me.startSplitterButtonSyncing();
  }
  onSplitterMouseLeave() {
    const me = this, {
      nextSibling
    } = me;
    me.toggleSplitterCls("b-hover", false);
    if (!me.collapsed && (!nextSibling || !nextSibling.collapsed)) {
      me.stopSplitterButtonSyncing();
    }
  }
  startSplitterButtonSyncing() {
    const me = this;
    if (me.splitterElement) {
      me.syncSplitterButtonPosition();
      if (!me.splitterSyncScrollListener) {
        me.splitterSyncScrollListener = me.grid.scrollable.ion({
          scroll: "syncSplitterButtonPosition",
          thisObj: me
        });
      }
    }
  }
  stopSplitterButtonSyncing() {
    if (this.splitterSyncScrollListener) {
      this.splitterSyncScrollListener();
      this.splitterSyncScrollListener = null;
    }
  }
  syncSplitterButtonPosition() {
    const {
      grid
    } = this;
    this.splitterButtons.style.top = `${grid.scrollable.y + (grid.bodyHeight - (this.headerSplitter ? grid.headerHeight : 0)) / 2}px`;
  }
  get viewRectangle() {
    const {
      scrollable
    } = this;
    return new Rectangle(scrollable.x, scrollable.y, this.width || 0, this.rowManager.viewHeight);
  }
  updateHasFlex() {
    this.scrollable.element.classList.toggle("b-has-flex", this.columns.hasFlex);
  }
  updateResizable(resizable) {
    this.splitterElements.forEach((splitter) => DomHelper.toggleClasses(splitter, ["b-disabled"], !resizable));
  }
  resizeColumnsToFitContent() {
    this.grid.beginGridMeasuring();
    this.columns.visibleColumns.forEach((column) => {
      column.resizeToFitContent(null, null, true);
    });
    this.grid.endGridMeasuring();
  }
  get overflowingHorizontally() {
    return !this.collapsed && this.scrollable.hasOverflow("x");
  }
  get overflowingVertically() {
    return false;
  }
  refreshFakeScroll() {
    const me = this, {
      element,
      virtualScrollerElement,
      virtualScrollerWidth,
      header,
      footer,
      scrollable
    } = me, totalFixedWidth = [...header.contentElement.children].reduce(sumWidths, 0);
    scrollable.scrollWidth = totalFixedWidth;
    virtualScrollerElement.style.width = element.style.width;
    virtualScrollerElement.style.flex = element.style.flex;
    virtualScrollerElement.style.minWidth = element.style.minWidth;
    virtualScrollerElement.style.maxWidth = element.style.maxWidth;
    header.scrollable.syncOverflowState();
    footer.scrollable.syncOverflowState();
    if (!me.collapsed) {
      if (me.overflowingHorizontally) {
        virtualScrollerWidth.style.width = `${scrollable.scrollWidth || 0}px`;
        me.grid.virtualScrollers.classList.remove("b-hide-display");
      } else {
        virtualScrollerWidth.style.width = 0;
      }
    }
  }
  initScroll() {
    const me = this, {
      scrollable,
      virtualScrollerElement
    } = me;
    me.syncPartnersOnFrame = me.createOnFrame(me.syncScrollingPartners);
    if (BrowserHelper.isFirefox) {
      scrollable.element.addEventListener("wheel", (event) => {
        if (event.deltaX) {
          scrollable.x += event.deltaX;
          event.preventDefault();
        }
      });
    }
    scrollable.yScroller = me.grid.scrollable;
    scrollable.yScroller.addScroller(scrollable);
    me.fakeScroller = new Scroller({
      element: virtualScrollerElement,
      overflowX: true,
      widget: me
    });
    scrollable.ion({
      scroll: "onSubGridScroll",
      scrollend: "onSubGridScrollEnd",
      thisObj: me
    });
    scrollable.addPartner(me.fakeScroller, "x");
    scrollable.addPartner(me.header.scrollable, "x");
    scrollable.addPartner(me.footer.scrollable, "x");
    me.refreshFakeScroll();
  }
  onSubGridScrollEnd() {
    const me = this;
    if (!me.forceScrollUpdate) {
      me.syncScrollingPartners();
    }
    me.scrolling = false;
    if (!DomHelper.scrollBarWidth) {
      me.grid.virtualScrollers.classList.remove("b-scrolling");
      me.hideOverlayScroller();
    }
  }
  onSubGridScroll() {
    if (this.forceScrollUpdate) {
      this.syncScrollingPartners();
      this.forceScrollUpdate = false;
    } else {
      this.syncPartnersOnFrame();
    }
  }
  showOverlayScroller() {
    this.hideOverlayScroller.cancel();
    this.virtualScrollerElement.classList.add("b-show-virtual-scroller");
  }
  hideOverlayScroller() {
    this.virtualScrollerElement.classList.remove("b-show-virtual-scroller");
  }
  set scrolling(scrolling) {
    this._scrolling = scrolling;
  }
  get scrolling() {
    return this._scrolling;
  }
  syncScrollingPartners(addCls = true) {
    const subGrid = this, {
      grid
    } = subGrid;
    if (!subGrid.scrolling && addCls) {
      subGrid.scrolling = true;
      if (!DomHelper.scrollBarWidth) {
        grid.virtualScrollers.classList.add("b-scrolling");
        subGrid.showOverlayScroller();
      }
    }
    grid.trigger("horizontalScroll", {
      subGrid,
      grid,
      scrollLeft: subGrid.scrollable.element.scrollLeft,
      scrollX: subGrid.scrollable.x
    });
  }
  scrollColumnIntoView(column, options) {
    const {
      columns,
      header
    } = this, scroller = header.scrollable;
    column = column instanceof Column ? column : columns.get(column) || columns.getById(column) || columns.getAt(column);
    if (column) {
      const columnHeaderElement = header.getHeader(column.id);
      if (columnHeaderElement) {
        return scroller.scrollIntoView(Rectangle.from(columnHeaderElement, null, true), options);
      }
    }
  }
  onAddRow({
    rows,
    isExport
  }) {
    const me = this, config = me.rowElementConfig, frag = document.createDocumentFragment();
    rows.forEach((row) => {
      const rowElement = DomHelper.createElement(config);
      frag.appendChild(rowElement);
      row.addElement(me.region, rowElement);
      me.fixCellWidths(rowElement);
    });
    if (!isExport) {
      me.fixRowWidthsInSafariEdge();
      me.element.insertBefore(frag, me.insertRowsBefore);
    }
  }
  get rowElements() {
    return this.fromCache(".b-grid-row", true);
  }
  clearRows() {
    this.emptyCache();
    const all = this.element.querySelectorAll(".b-grid-row"), range = document.createRange();
    if (all.length) {
      range.setStartBefore(all[0]);
      range.setEndAfter(all[all.length - 1]);
      range.deleteContents();
    }
  }
  addNewRowElement() {
    const rowElement = DomHelper.append(this.element, this.rowElementConfig);
    this.fixCellWidths(rowElement);
    return rowElement;
  }
  get store() {
    return this.grid.store;
  }
  get rowManager() {
    var _this$grid;
    return (_this$grid = this.grid) === null || _this$grid === void 0 ? void 0 : _this$grid.rowManager;
  }
  toggleTransitionClasses(doRemove = false) {
    const me = this, grid = me.grid, nextRegion = grid.getSubGrid(grid.getNextRegion(me.region)), splitter = grid.resolveSplitter(nextRegion);
    nextRegion.element.classList[doRemove ? "remove" : "add"]("b-grid-subgrid-animate-collapse");
    nextRegion.header.element.classList[doRemove ? "remove" : "add"]("b-grid-subgrid-animate-collapse");
    me.element.classList[doRemove ? "remove" : "add"]("b-grid-subgrid-animate-collapse");
    me.header.element.classList[doRemove ? "remove" : "add"]("b-grid-subgrid-animate-collapse");
    splitter.classList[doRemove ? "remove" : "add"]("b-grid-splitter-animate");
  }
  get collapsed() {
    return this._collapsed;
  }
  set collapsed(collapsed) {
    if (this.isConfiguring) {
      this._collapsed = collapsed;
    } else {
      if (collapsed) {
        this.collapse();
      } else {
        this.expand();
      }
    }
  }
  async collapse() {
    const me = this, {
      grid,
      element
    } = me, nextRegion = grid.getSubGrid(grid.getNextRegion(me.region)), splitterOwner = me.splitterElement ? me : me.previousSibling;
    let {
      _beforeCollapseState
    } = me, expandedRegions = 0;
    if (grid.rendered && me._collapsed === true) {
      return;
    }
    grid.eachSubGrid((subGrid) => {
      subGrid !== me && !subGrid._collapsed && ++expandedRegions;
    });
    if (expandedRegions === 0) {
      await nextRegion.expand();
    }
    return new Promise((resolve) => {
      if (!_beforeCollapseState) {
        _beforeCollapseState = me._beforeCollapseState = {};
        let widthChanged = false;
        if (me.width) {
          widthChanged = true;
          me.ion({
            afterinternalresize: () => {
              resolve(me);
            },
            thisObj: me,
            once: true
          });
        }
        _beforeCollapseState.width = me.width;
        _beforeCollapseState.elementWidth = element.style.width;
        if (nextRegion.element.style.flex === "") {
          _beforeCollapseState.nextRegionWidth = nextRegion.width;
          nextRegion.width = "";
          nextRegion.flex = "1";
        }
        if (element.style.flex !== "") {
          _beforeCollapseState.flex = element.style.flex;
          me.header.element.style.flex = element.style.flex = "";
        }
        element.classList.add("b-grid-subgrid-collapsed");
        me.virtualScrollerElement.classList.add("b-collapsed");
        me.header.element.classList.add("b-collapsed");
        me.footer.element.classList.add("b-collapsed");
        me._collapsed = true;
        me.width = "";
        if (!widthChanged) {
          me.syncParallelSplitters(true);
          resolve(false);
        }
      } else {
        resolve();
      }
    }).then((value) => {
      if (!me.isDestroyed) {
        if (value !== false) {
          var _splitterOwner$startS;
          grid.refreshVirtualScrollbars();
          me.syncParallelSplitters(true);
          (_splitterOwner$startS = splitterOwner.startSplitterButtonSyncing) === null || _splitterOwner$startS === void 0 ? void 0 : _splitterOwner$startS.call(splitterOwner);
        }
        grid.trigger("subGridCollapse", {
          subGrid: me
        });
        grid.afterToggleSubGrid({
          subGrid: me,
          collapsed: true
        });
      }
    });
  }
  async expand() {
    const me = this, {
      grid,
      _beforeCollapseState
    } = me, nextRegion = grid.getSubGrid(grid.getNextRegion(me.region)), splitterOwner = me.splitterElement ? me : me.previousSibling;
    if (grid.rendered && me._collapsed !== true) {
      return;
    }
    return new Promise((resolve) => {
      if (_beforeCollapseState != null) {
        let widthChanged = false;
        if (me.width !== _beforeCollapseState.elementWidth) {
          widthChanged = true;
          me.ion({
            afterinternalresize() {
              me.setTimeout(() => resolve(me), 10);
            },
            thisObj: me,
            once: true
          });
        }
        if (_beforeCollapseState.nextRegionWidth) {
          nextRegion.width = _beforeCollapseState.nextRegionWidth;
          nextRegion.flex = null;
        }
        me.element.classList.remove("b-grid-subgrid-collapsed");
        me._collapsed = false;
        me.virtualScrollerElement.classList.remove("b-collapsed");
        me.header.element.classList.remove("b-collapsed");
        me.footer.element.classList.remove("b-collapsed");
        if (_beforeCollapseState.flex) {
          me.width = _beforeCollapseState.width;
          me.header.flex = me.flex = _beforeCollapseState.flex;
          me.footer.flex = _beforeCollapseState.flex;
          me._width = null;
        } else {
          me.width = _beforeCollapseState.elementWidth;
        }
        me.element.classList.remove("b-grid-subgrid-collapsed");
        me._collapsed = false;
        if (!widthChanged) {
          resolve(false);
        } else {
          splitterOwner.stopSplitterButtonSyncing();
          me.syncParallelSplitters(false);
        }
        delete me._beforeCollapseState;
      } else {
        resolve();
      }
    }).then((value) => {
      if (value !== false && !me.isDestroyed) {
        grid.trigger("subGridExpand", {
          subGrid: me
        });
        grid.afterToggleSubGrid({
          subGrid: me,
          collapsed: false
        });
      }
    });
  }
};
_defineProperty(SubGrid, "delayable", {
  hideOverlayScroller: 1e3
});
SubGrid.initClass();
SubGrid._$name = "SubGrid";
var GridSubGrids = (Target) => class GridSubGrids extends (Target || Base$1) {
  static get $name() {
    return "GridSubGrids";
  }
  static get properties() {
    return {
      subGrids: {}
    };
  }
  changeSubGridConfigs(configs) {
    const me = this, usedRegions = /* @__PURE__ */ new Set();
    for (const column of me.columns) {
      const {
        region
      } = column;
      if (region) {
        if (!configs[region]) {
          configs[region] = {};
        }
        usedRegions.add(region);
      }
    }
    if (configs.normal && ObjectHelper.isEmpty(configs.normal)) {
      configs.normal = GridBase.defaultConfig.subGridConfigs.normal;
    }
    for (const region of usedRegions) {
      me.createSubGrid(region, configs[region]);
    }
    me.items = me.subGrids;
    return configs;
  }
  createSubGrid(region, config = null) {
    const me = this, subGridColumns = me.columns.makeChained((column) => column.region === region, ["region"]), subGridConfig = ObjectHelper.assign({
      type: "subgrid",
      id: `${me.id}-${region}Subgrid`,
      parent: me,
      grid: me,
      region,
      headerClass: me.headerClass,
      footerClass: me.footerClass,
      columns: subGridColumns,
      weight: region
    }, config || me.subGridConfigs[region]);
    let hasCalculatedWidth = false;
    if (!subGridConfig.flex && !subGridConfig.width) {
      subGridConfig.width = subGridColumns.totalFixedWidth;
      hasCalculatedWidth = true;
    }
    const subGrid = me.subGrids[region] = SubGrid.create(subGridConfig);
    subGrid.hasCalculatedWidth = hasCalculatedWidth;
    if (region === me.regions[0]) {
      subGrid.isFirstRegion = true;
    }
    return subGrid;
  }
  onChildAdd(subGrid) {
    if (subGrid.isSubGrid) {
      const me = this, {
        items: items2,
        headerContainer,
        virtualScrollers,
        footerContainer
      } = me, index = items2.indexOf(subGrid) * 2;
      if (!me.hideHeaders) {
        DomHelper.insertAt(headerContainer, subGrid.headerSplitter, index);
        DomHelper.insertAt(headerContainer, subGrid.header.element, index);
      }
      DomHelper.insertAt(virtualScrollers, subGrid.scrollerSplitter, index);
      DomHelper.insertAt(virtualScrollers, subGrid.virtualScrollerElement, index);
      DomHelper.insertAt(footerContainer, subGrid.footerSplitter, index);
      DomHelper.insertAt(footerContainer, subGrid.footer.element, index);
      items2.forEach((subGrid2, i) => {
        if (i < items2.length - 1) {
          subGrid2.showSplitter();
        }
      });
      if (index === 0 && me.emptyTextEl) {
        subGrid.element.appendChild(me.emptyTextEl);
      }
    }
    return super.onChildAdd(subGrid);
  }
  onChildRemove(subGrid) {
    super.onChildRemove(subGrid);
    if (subGrid.isSubGrid) {
      const {
        items: items2
      } = this;
      delete this.subGrids[subGrid.region];
      ArrayHelper.remove(this.regions, subGrid.region);
      subGrid.destroy();
      if (items2.length) {
        items2[items2.length - 1].hideSplitter();
      }
    }
  }
  doDestroy() {
    this.eachSubGrid((subGrid) => subGrid.destroy());
    super.doDestroy();
  }
  eachSubGrid(fn2, thisObj = null) {
    this.items.forEach((subGrid, i) => {
      subGrid.isSubGrid && fn2.call(thisObj || subGrid, subGrid, i++);
    });
  }
  callEachSubGrid(fnName, ...params) {
    let returnValue = null;
    this.items.forEach((subGrid, i) => {
      if (subGrid.isSubGrid && subGrid[fnName]) {
        const partialReturnValue = subGrid[fnName](...params);
        if (i === 0)
          returnValue = partialReturnValue;
      }
    });
    return returnValue;
  }
  get regions() {
    return this.items.map((item) => item.region);
  }
  getLastRegions() {
    const result = this.regions.slice(-2);
    return result.length === 2 ? result : [result[0], result[0]];
  }
  getNextRegion(region) {
    const regions = this.regions;
    return regions[regions.indexOf(region) + 1] || regions[regions.length - 2];
  }
  getPreviousRegion(region) {
    return this.regions[this.regions.indexOf(region) - 1];
  }
  getSubGrid(region) {
    return this.subGrids[region];
  }
  getSubGridFromColumn(column) {
    column = column instanceof Column ? column : this.columns.getById(column) || this.columns.get(column);
    return this.getSubGrid(column.region);
  }
  resolveSplitter(subGrid) {
    const regions = this.getLastRegions();
    let region = subGrid instanceof SubGrid ? subGrid.region : subGrid;
    if (regions[1] === region) {
      region = regions[0];
    }
    return this.subGrids[region].splitterElement;
  }
  get widgetClass() {
  }
};
var emptyString$1 = new String();
var locale$2 = {
  localeName: "En",
  localeDesc: "English (US)",
  localeCode: "en-US",
  ColumnPicker: {
    column: "Column",
    columnsMenu: "Columns",
    hideColumn: "Hide column",
    hideColumnShort: "Hide",
    newColumns: "New columns"
  },
  Filter: {
    applyFilter: "Apply filter",
    filter: "Filter",
    editFilter: "Edit filter",
    on: "On",
    before: "Before",
    after: "After",
    equals: "Equals",
    lessThan: "Less than",
    moreThan: "More than",
    removeFilter: "Remove filter",
    disableFilter: "Disable filter"
  },
  FilterBar: {
    enableFilterBar: "Show filter bar",
    disableFilterBar: "Hide filter bar"
  },
  Group: {
    group: "Group",
    groupAscending: "Group ascending",
    groupDescending: "Group descending",
    groupAscendingShort: "Ascending",
    groupDescendingShort: "Descending",
    stopGrouping: "Stop grouping",
    stopGroupingShort: "Stop"
  },
  HeaderMenu: {
    moveBefore: (text) => `Move before "${text}"`,
    moveAfter: (text) => `Move after "${text}"`,
    collapseColumn: "Collapse column",
    expandColumn: "Expand column"
  },
  ColumnRename: {
    rename: "Rename"
  },
  MergeCells: {
    mergeCells: "Merge cells",
    menuTooltip: "Merge cells with same value when sorted by this column"
  },
  Search: {
    searchForValue: "Search for value"
  },
  Sort: {
    sort: "Sort",
    sortAscending: "Sort ascending",
    sortDescending: "Sort descending",
    multiSort: "Multi sort",
    removeSorter: "Remove sorter",
    addSortAscending: "Add ascending sorter",
    addSortDescending: "Add descending sorter",
    toggleSortAscending: "Change to ascending",
    toggleSortDescending: "Change to descending",
    sortAscendingShort: "Ascending",
    sortDescendingShort: "Descending",
    removeSorterShort: "Remove",
    addSortAscendingShort: "+ Ascending",
    addSortDescendingShort: "+ Descending"
  },
  Column: {
    columnLabel: (column) => `${column.text ? `${column.text} column. ` : ""}SPACE for context menu${column.sortable ? ", ENTER to sort" : ""}`,
    cellLabel: emptyString$1
  },
  Checkbox: {
    toggleRowSelect: "Toggle row selection",
    toggleSelection: "Toggle selection of entire dataset"
  },
  RatingColumn: {
    cellLabel: (column) => {
      var _column$location;
      return `${column.text ? column.text : ""} ${(_column$location = column.location) !== null && _column$location !== void 0 && _column$location.record ? `rating : ${column.location.record[column.field] || 0}` : ""}`;
    }
  },
  GridBase: {
    loadFailedMessage: "Data loading failed!",
    syncFailedMessage: "Data synchronization failed!",
    unspecifiedFailure: "Unspecified failure",
    networkFailure: "Network error",
    parseFailure: "Failed to parse server response",
    serverResponse: "Server response:",
    noRows: "No records to display",
    moveColumnLeft: "Move to left section",
    moveColumnRight: "Move to right section",
    moveColumnTo: (region) => `Move column to ${region}`
  },
  CellMenu: {
    removeRow: "Delete"
  },
  RowCopyPaste: {
    copyRecord: "Copy",
    cutRecord: "Cut",
    pasteRecord: "Paste",
    rows: "rows",
    row: "row"
  },
  CellCopyPaste: {
    copy: "Copy",
    cut: "Cut",
    paste: "Paste"
  },
  PdfExport: {
    "Waiting for response from server": "Waiting for response from server...",
    "Export failed": "Export failed",
    "Server error": "Server error",
    "Generating pages": "Generating pages...",
    "Click to abort": "Cancel"
  },
  ExportDialog: {
    width: "40em",
    labelWidth: "12em",
    exportSettings: "Export settings",
    export: "Export",
    exporterType: "Control pagination",
    cancel: "Cancel",
    fileFormat: "File format",
    rows: "Rows",
    alignRows: "Align rows",
    columns: "Columns",
    paperFormat: "Paper format",
    orientation: "Orientation",
    repeatHeader: "Repeat header"
  },
  ExportRowsCombo: {
    all: "All rows",
    visible: "Visible rows"
  },
  ExportOrientationCombo: {
    portrait: "Portrait",
    landscape: "Landscape"
  },
  SinglePageExporter: {
    singlepage: "Single page"
  },
  MultiPageExporter: {
    multipage: "Multiple pages",
    exportingPage: ({
      currentPage,
      totalPages
    }) => `Exporting page ${currentPage}/${totalPages}`
  },
  MultiPageVerticalExporter: {
    multipagevertical: "Multiple pages (vertical)",
    exportingPage: ({
      currentPage,
      totalPages
    }) => `Exporting page ${currentPage}/${totalPages}`
  },
  RowExpander: {
    loading: "Loading",
    expand: "Expand",
    collapse: "Collapse"
  }
};
LocaleHelper.publishLocale(locale$2);
var resolvedPromise = new Promise((resolve) => resolve());
var storeListenerName = "GridBase:store";
var defaultScrollOptions$2 = {
  block: "nearest",
  inline: "nearest"
};
var datasetReplaceActions = {
  dataset: 1,
  pageLoad: 1,
  filter: 1
};
var GridBase = class extends Panel.mixin(Pluggable, State, GridElementEvents, GridFeatures, GridNavigation, GridResponsive, GridSelection, GridState, GridSubGrids, LoadMaskable) {
  static get $name() {
    return "GridBase";
  }
  static get type() {
    return "gridbase";
  }
  static get delayable() {
    return {
      onGridVerticalScroll: {
        type: "raf"
      },
      bufferedAfterColumnsResized: 250,
      bufferedElementResize: 250
    };
  }
  static get configurable() {
    return {
      autoHeight: null,
      enableSticky: null,
      enableTextSelection: null,
      fillLastColumn: true,
      positionMode: "translate",
      showDirty: null,
      subGridConfigs: {
        normal: {
          flex: 1
        }
      },
      store: {
        value: {},
        $config: "nullify"
      },
      rowManager: {
        value: {},
        $config: ["nullify", "lazy"]
      },
      scrollManager: {
        value: {},
        $config: ["nullify", "lazy"]
      },
      columns: {
        value: [],
        $config: "nullify"
      },
      minHeight: "10em",
      hideFooters: true,
      contentElMutationObserver: false,
      trapFocus: false,
      ariaElement: "bodyElement",
      cellTabIndex: -1,
      rowCls: {
        value: "b-grid-row",
        $config: {
          merge: this.mergeCls
        }
      },
      cellCls: {
        value: "b-grid-cell",
        $config: {
          merge: this.mergeCls
        }
      },
      emptyText: "L{noRows}",
      sortFeatureStore: "store"
    };
  }
  static get defaultConfig() {
    return {
      rowHeight: null,
      fixedRowHeight: null,
      defaultRowHeight: 45,
      fullRowRefresh: true,
      hideHeaders: null,
      preserveScrollOnDatasetChange: null,
      preserveFocusOnDatasetChange: true,
      data: null,
      defaultRegion: "normal",
      destroyStore: null,
      maskDefaults: {
        cover: "body",
        target: "element"
      },
      columnLines: true,
      resizeToFitIncludesHeader: true,
      animateRemovingRows: true,
      disableGridRowModelWarning: null,
      headerClass: Header$1,
      footerClass: Footer,
      testPerformance: false,
      rowScrollMode: "move",
      monitorResize: true,
      features: true,
      scrollable: {
        overflowY: true
      },
      scrollerClass: GridScroller,
      refreshSuspended: 0,
      transitionDuration: 500,
      contextMenuTriggerEvent: "contextmenu",
      localizableProperties: ["emptyText"],
      asyncEventSuffix: "",
      testConfig: {
        transitionDuration: 50
      }
    };
  }
  static get properties() {
    return {
      _selectedRecords: [],
      _verticalScrollHeight: 0,
      virtualScrollHeight: 0,
      _scrollTop: null
    };
  }
  finishConfigure(config) {
    const me = this, {
      initScroll
    } = me;
    me.initScroll = () => !me.scrollInitialized && initScroll.call(me);
    super.finishConfigure(config);
    LocaleManagerSingleton.ion({
      locale: "onBeforeLocaleChange",
      prio: 1,
      thisObj: me
    });
    LocaleManagerSingleton.ion({
      locale: "onLocaleChange",
      prio: -1,
      thisObj: me
    });
    GlobalEvents$1.ion({
      theme: "onThemeChange",
      thisObj: me
    });
    me.ion({
      subGridExpand: "onSubGridExpand",
      prio: -1,
      thisObj: me
    });
    me.bufferedFixElementHeights = me.buffer("fixElementHeights", 350, me);
    me.setGridClassList(me.element.classList);
  }
  onSubGridExpand() {
    this.renderContents();
  }
  onBeforeLocaleChange() {
    this._suspendRenderContentsOnColumnsChanged = true;
  }
  onLocaleChange() {
    this._suspendRenderContentsOnColumnsChanged = false;
    if (this.isPainted) {
      this.renderContents();
    }
  }
  finalizeInit() {
    super.finalizeInit();
    if (this.store.isLoading) {
      this.onStoreBeforeRequest();
    }
  }
  changeScrollManager(scrollManager, oldScrollManager) {
    oldScrollManager === null || oldScrollManager === void 0 ? void 0 : oldScrollManager.destroy();
    if (scrollManager) {
      return ScrollManager.new({
        element: this.element,
        owner: this
      }, scrollManager);
    } else {
      return null;
    }
  }
  doDestroy() {
    var _me$scrollManager;
    const me = this;
    me.detachListeners(storeListenerName);
    (_me$scrollManager = me.scrollManager) === null || _me$scrollManager === void 0 ? void 0 : _me$scrollManager.destroy();
    for (const feature of Object.values(me.features)) {
      var _feature$destroy;
      (_feature$destroy = feature.destroy) === null || _feature$destroy === void 0 ? void 0 : _feature$destroy.call(feature);
    }
    me._focusedCell = null;
    me.columns.destroy();
    super.doDestroy();
  }
  setGridClassList(classList) {
    const me = this;
    Object.values(me.features).forEach((feature) => {
      if (feature.disabled) {
        return;
      }
      let featureClass;
      if (Object.prototype.hasOwnProperty.call(feature.constructor, "featureClass")) {
        featureClass = feature.constructor.featureClass;
      } else {
        featureClass = `b-${feature instanceof Base$1 ? feature.$$name : feature.constructor.name}`;
      }
      if (featureClass) {
        classList.add(featureClass.toLowerCase());
      }
    });
  }
  compose() {
    const {
      autoHeight,
      enableSticky,
      enableTextSelection,
      fillLastColumn,
      positionMode,
      showDirty
    } = this;
    return {
      class: {
        [`b-grid-${positionMode}`]: 1,
        "b-enable-sticky": enableSticky,
        "b-grid-notextselection": !enableTextSelection,
        "b-autoheight": autoHeight,
        "b-fill-last-column": fillLastColumn,
        "b-show-dirty": showDirty
      }
    };
  }
  get cellCls() {
    const {
      _cellCls
    } = this;
    return _cellCls.value || _cellCls;
  }
  get bodyConfig() {
    const {
      autoHeight,
      hideFooters,
      hideHeaders
    } = this;
    return {
      reference: "bodyElement",
      className: {
        "b-autoheight": autoHeight,
        "b-grid-panel-body": 1
      },
      [this.hasHeader ? "ariaLabelledBy" : ""]: `${this.id}-panel-title`,
      children: {
        headerContainer: {
          tag: "header",
          role: "row",
          "aria-rowindex": 1,
          className: {
            "b-grid-header-container": 1,
            "b-hidden": hideHeaders
          }
        },
        bodyContainer: {
          className: "b-grid-body-container",
          tabIndex: -1,
          role: "presentation",
          children: {
            verticalScroller: {
              className: "b-grid-vertical-scroller"
            }
          }
        },
        virtualScrollers: {
          className: "b-virtual-scrollers b-hide-display",
          style: BrowserHelper.isFirefox && DomHelper.scrollBarWidth ? {
            height: `${DomHelper.scrollBarWidth}px`
          } : void 0
        },
        footerContainer: {
          tag: "footer",
          className: {
            "b-grid-footer-container": 1,
            "b-hidden": hideFooters
          }
        }
      }
    };
  }
  get contentElement() {
    return this.verticalScroller;
  }
  get overflowElement() {
    return this.bodyContainer;
  }
  updateHideFooters(hide) {
    var _this$footerContainer;
    (_this$footerContainer = this.footerContainer) === null || _this$footerContainer === void 0 ? void 0 : _this$footerContainer.classList[hide ? "add" : "remove"]("b-hidden");
  }
  changeColumns(columns, currentStore) {
    const me = this;
    if (!columns && currentStore) {
      if (me.isDestroying) {
        currentStore.owner === me && currentStore.destroy();
      } else {
        currentStore.removeAll();
      }
      return currentStore;
    }
    if (columns.isStore) {
      (currentStore === null || currentStore === void 0 ? void 0 : currentStore.owner) === me && currentStore.destroy();
      columns.grid = me;
      return columns;
    }
    if (Array.isArray(columns)) {
      if (currentStore) {
        me._suspendRenderContentsOnColumnsChanged = true;
        const columnsToDestroy = currentStore.allRecords.filter((column) => !columns.includes(column) && column !== me.checkboxSelectionColumn);
        currentStore.remove(currentStore.allRecords, true);
        columnsToDestroy.forEach((column) => {
          var _column$destroy;
          return (_column$destroy = column.destroy) === null || _column$destroy === void 0 ? void 0 : _column$destroy.call(column);
        });
        currentStore.data = columns;
        me._suspendRenderContentsOnColumnsChanged = false;
        return currentStore;
      }
      columns = {
        data: columns
      };
    }
    if (currentStore) {
      throw new Error("Replacing ColumnStore is not supported");
    }
    return ColumnStore.new({
      grid: me,
      owner: me
    }, columns);
  }
  updateColumns(columns, was) {
    var _super$updateColumns, _me$bodyElement;
    const me = this;
    (_super$updateColumns = super.updateColumns) === null || _super$updateColumns === void 0 ? void 0 : _super$updateColumns.call(this, columns, was);
    columns.ion({
      refresh: me.onColumnsChanged,
      change: me.onColumnsChanged,
      sort: me.onColumnsChanged,
      thisObj: me
    });
    columns.ion(columnResizeEvent(me.onColumnsResized, me));
    if (BrowserHelper.isTouchDevice) {
      me.touch = true;
      columns.forEach((column) => {
        const {
          touchConfig
        } = column;
        if (touchConfig) {
          column.applyState(touchConfig);
        }
      });
    }
    (_me$bodyElement = me.bodyElement) === null || _me$bodyElement === void 0 ? void 0 : _me$bodyElement.setAttribute("aria-colcount", columns.visibleColumns.length);
  }
  onColumnsChanged({
    type,
    action,
    changes,
    record: column,
    records: addedColumns,
    isMove
  }) {
    const isSingleFieldChange = changes && Object.keys(changes).length === 1;
    if (type === "refresh" && action !== "batch" || action === "update" && isSingleFieldChange && "parentIndex" in changes) {
      return;
    }
    const me = this, {
      columns,
      checkboxSelectionColumn
    } = me;
    if (!me.isPainted || isMove && action === "remove") {
      return;
    }
    if (action === "add") {
      for (const column2 of addedColumns) {
        const {
          region
        } = column2;
        if (!me.subGrids[region]) {
          me.add(me.createSubGrid(region, me.subGridConfigs[region]));
        }
      }
    }
    if (action === "update") {
      if ("width" in changes || "minWidth" in changes || "maxWidth" in changes || "flex" in changes) {
        const region = column.region;
        columns.visibleColumns.forEach((col) => {
          if (col.region === region && col.repaintOnResize) {
            me.refreshColumn(col);
          }
        });
        me.afterColumnsChange({
          action,
          changes,
          column
        });
        return;
      }
      if ("text" in changes && isSingleFieldChange) {
        column.subGrid.refreshHeader();
        return;
      }
      if ("hidden" in changes) {
        const subGrid = me.getSubGridFromColumn(column.id);
        subGrid.header.fixHeaderWidths();
        subGrid.footer.fixFooterWidths();
        subGrid.updateHasFlex();
      }
    }
    if (action === "dataset" || action === "batch" || action === "update" && "region" in changes) {
      const regions = columns.getDistinctValues("region"), {
        toRemove,
        toAdd
      } = ArrayHelper.delta(regions, me.regions, true);
      me.remove(toRemove.map((region) => me.getSubGrid(region)));
      me.add(toAdd.map((region) => me.createSubGrid(region)));
    }
    if (checkboxSelectionColumn && !columns.includes(checkboxSelectionColumn)) {
      const insertIndex = columns.indexOf(columns.findRecord("type", "rownumber")) + 1;
      columns.insert(insertIndex, checkboxSelectionColumn, true);
    }
    if (!me._suspendRenderContentsOnColumnsChanged) {
      me.renderContents();
    }
    me.syncFlexedSubCols();
    me.bodyElement.setAttribute("aria-colcount", columns.visibleColumns.length);
    me.afterColumnsChange({
      action,
      changes,
      column
    });
  }
  onColumnsResized({
    changes,
    record: column
  }) {
    const me = this;
    if (me.isConfiguring) {
      return;
    }
    const domWidth = DomHelper.setLength(column.width), domMinWidth = DomHelper.setLength(column.minWidth), domMaxWidth = DomHelper.setLength(column.maxWidth), subGrid = me.getSubGridFromColumn(column.id);
    subGrid.header.fixHeaderWidths();
    subGrid.footer.fixFooterWidths();
    subGrid.updateHasFlex();
    if (!(column.flex && column.childLevel)) {
      if (!me.cellEls || column !== me.lastColumnResized) {
        me.cellEls = DomHelper.children(me.element, `.b-grid-cell[data-column-id="${column.id}"]`);
        me.lastColumnResized = column;
      }
      for (const cell of me.cellEls) {
        if ("width" in changes) {
          cell.style.width = domWidth;
        }
        if ("minWidth" in changes) {
          cell.style.minWidth = domMinWidth;
        }
        if ("maxWidth" in changes) {
          cell.style.maxWidth = domMaxWidth;
        }
        if ("flex" in changes) {
          var _column$flex;
          cell.style.flex = (_column$flex = column.flex) !== null && _column$flex !== void 0 ? _column$flex : null;
        }
      }
    }
    if (!me.resizingColumns) {
      me.afterColumnsResized(column);
    }
    me.syncFlexedSubCols();
  }
  afterColumnsResized(column) {
    const me = this;
    me.eachSubGrid((subGrid) => {
      if (!subGrid.collapsed && (!column || column.region === subGrid.region)) {
        subGrid.fixWidths();
        subGrid.fixRowWidthsInSafariEdge();
      }
    });
    me.lastColumnResized = me.cellEls = null;
    me.bufferedAfterColumnsResized(column);
    me.onHeightChange();
  }
  syncFlexedSubCols() {
    const flexedSubCols = this.columns.query((c) => c.flex && c.childLevel && c.element);
    if (flexedSubCols) {
      for (const column of flexedSubCols) {
        const width = column.element.getBoundingClientRect().width, cellEls = DomHelper.children(this.element, `.b-grid-cell[data-column-id="${column.id}"]`);
        for (const cell of cellEls) {
          cell.style.flex = `0 0 ${width}px`;
        }
      }
    }
  }
  bufferedAfterColumnsResized(column) {
    if (this.columns.usesAutoHeight) {
      this.refreshRows();
    }
    this.refreshVirtualScrollbars();
    this.eachSubGrid((subGrid) => {
      if (!subGrid.collapsed && (!column || column.region === subGrid.region)) {
        subGrid.refreshFakeScroll();
      }
    });
  }
  bufferedElementResize() {
    this.refreshRows();
  }
  onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {
    if (DomHelper.scrollBarWidth && newWidth < oldWidth) {
      this.eachSubGrid((subGrid) => {
        if (subGrid.flex) {
          subGrid.onElementResize(subGrid.element);
        }
      });
    }
    super.onInternalResize(...arguments);
    if (this.isPainted && newWidth !== oldWidth && this.columns.usesFlexAutoHeight) {
      this.bufferedElementResize();
    }
  }
  changeRowManager(rowManager, oldRowManager) {
    const me = this;
    if (!me._isRowMeasured) {
      me.measureRowHeight();
    }
    oldRowManager === null || oldRowManager === void 0 ? void 0 : oldRowManager.destroy();
    if (rowManager) {
      const result = RowManager.new({
        grid: me,
        rowHeight: me.rowHeight,
        rowScrollMode: me.rowScrollMode || "move",
        autoHeight: me.autoHeight,
        fixedRowHeight: me.fixedRowHeight,
        internalListeners: {
          changeTotalHeight: "onRowManagerChangeTotalHeight",
          requestScrollChange: "onRowManagerRequestScrollChange",
          thisObj: me
        }
      }, rowManager);
      me.relayEvents(result, ["beforeRenderRow", "renderRow"]);
      me._rowManager = null;
      return result;
    }
  }
  getRowHeight(record) {
    return record.rowHeight;
  }
  processRowHeight(record, height) {
  }
  bindStore(store) {
    const suffix = this.asyncEventSuffix;
    store.ion({
      name: storeListenerName,
      [`refresh${suffix}`]: "onStoreDataChange",
      [`add${suffix}`]: "onStoreAdd",
      [`remove${suffix}`]: "onStoreRemove",
      [`replace${suffix}`]: "onStoreReplace",
      [`removeAll${suffix}`]: "onStoreRemoveAll",
      [`move${suffix}`]: store.tree ? null : "onFlatStoreMove",
      change: "relayStoreDataChange",
      idChange: "onStoreRecordIdChange",
      update: "onStoreUpdateRecord",
      beforeRequest: "onStoreBeforeRequest",
      afterRequest: "onStoreAfterRequest",
      exception: "onStoreException",
      commit: "onStoreCommit",
      thisObj: this
    });
    super.bindStore(store);
  }
  unbindStore(oldStore) {
    this.detachListeners(storeListenerName);
    if (this.destroyStore) {
      oldStore.destroy();
    }
  }
  changeStore(store) {
    if (store == null) {
      return null;
    }
    if (typeof store === "string") {
      store = Store.getStore(store);
    }
    if (!store.isStore) {
      var _this$initialConfig$f;
      store = ObjectHelper.assign({
        data: this.data,
        tree: Boolean((_this$initialConfig$f = this.initialConfig.features) === null || _this$initialConfig$f === void 0 ? void 0 : _this$initialConfig$f.tree)
      }, store);
      if (!store.data) {
        delete store.data;
      }
      if (!store.modelClass) {
        store.modelClass = GridRowModel;
      }
      store = new (store.readUrl ? AjaxStore : Store)(store);
    }
    return store;
  }
  updateStore(store, was) {
    var _super$updateStore;
    const me = this;
    (_super$updateStore = super.updateStore) === null || _super$updateStore === void 0 ? void 0 : _super$updateStore.call(this, store, was);
    if (was) {
      me.unbindStore(was);
    }
    if (store) {
      if (was) {
        me.deselectAll();
      }
      me.bindStore(store);
    }
    me.trigger("bindStore", {
      store,
      oldStore: was
    });
    if (!me.isDestroying && me.isPainted && !me.refreshSuspended) {
      var _me$_rowManager;
      (_me$_rowManager = me._rowManager) === null || _me$_rowManager === void 0 ? void 0 : _me$_rowManager.reinitialize();
    }
  }
  onStoreUpdateRecord({
    source: store,
    record,
    changes
  }) {
    const me = this;
    if (me.refreshSuspended) {
      return;
    }
    if (me.forceFullRefresh) {
      me.rowManager.refresh();
      me.forceFullRefresh = false;
    } else {
      let row;
      if (record.isFieldModified("id")) {
        row = me.getRowFor(record.meta.modified.id);
      }
      row = row || me.getRowFor(record);
      if (!row) {
        return;
      }
      if (me.fullRowRefresh || record.isSpecialRow) {
        const index = store.indexOf(record);
        if (index !== -1) {
          row.render(index, record);
        }
      } else {
        me.columns.visibleColumns.forEach((column) => {
          const field = column.field, isSafe = column.constructor.simpleRenderer && !Object.prototype.hasOwnProperty.call(column.data, "renderer");
          if (!isSafe || changes[field]) {
            const cellElement = row.getCell(field);
            if (cellElement) {
              row.renderCell(cellElement);
            }
          }
        });
      }
    }
  }
  refreshFromRowOnStoreAdd(row, context) {
    const me = this, {
      rowManager
    } = me;
    rowManager.renderFromRow(row);
    rowManager.trigger("changeTotalHeight", {
      totalHeight: rowManager.totalHeight
    });
    if (me.store.count === 1) {
      me.callEachSubGrid("refreshFakeScroll");
    }
  }
  onMaskAutoClose(mask) {
    super.onMaskAutoClose(mask);
    this.toggleEmptyText();
  }
  onStoreAdd({
    source: store,
    records,
    index,
    oldIndex,
    isChild,
    oldParent,
    parent,
    isMove,
    isExpandAll
  }) {
    if (!this.isPainted || isExpandAll || this.refreshSuspended) {
      return;
    }
    const hasExpandedOldParent = isMove && records.some((record) => {
      if (isMove[record.id]) {
        const oldParent2 = store.getById(record.meta.modified.parentId);
        return (oldParent2 === null || oldParent2 === void 0 ? void 0 : oldParent2.isExpanded(store)) && (oldParent2 === null || oldParent2 === void 0 ? void 0 : oldParent2.ancestorsExpanded(store));
      }
    });
    if (isChild && !records[0].ancestorsExpanded(store) && !hasExpandedOldParent) {
      if (!parent.isLeaf) {
        const parentRow = this.rowManager.getRowById(parent);
        if (parentRow) {
          this.rowManager.renderRows([parentRow]);
        }
      }
      return;
    }
    this.rowManager.calculateRowCount(false, true, true);
    if (store.isFiltered) {
      index = store.indexOf(records[0]);
    }
    const me = this, {
      rowManager
    } = me, {
      topIndex,
      rows,
      rowCount
    } = rowManager, bottomIndex = rowManager.topIndex + rowManager.rowCount - 1, dataStart = index, dataEnd = index + records.length - 1, atEnd = bottomIndex >= store.count - records.length - 1;
    if (oldParent || oldIndex > -1 || isChild && isMove) {
      rowManager.refresh();
    } else if (dataStart >= topIndex && dataStart < topIndex + rowCount) {
      me.refreshFromRowOnStoreAdd(rows[dataStart - topIndex], ...arguments);
    } else if (dataEnd >= topIndex && dataEnd < topIndex + rowCount) {
      rowManager.refresh();
    } else {
      if (atEnd && index > bottomIndex) {
        rowManager.fillBelow(me._scrollTop || 0);
      }
      rowManager.estimateTotalHeight(true);
    }
  }
  onStoreException({
    action,
    type,
    response,
    exceptionType,
    error
  }) {
    var _response$parsedJson;
    const me = this;
    let message;
    switch (type) {
      case "server":
        message = response.message || me.L("L{unspecifiedFailure}");
        break;
      case "exception":
        message = exceptionType === "network" ? me.L("L{networkFailure}") : (error === null || error === void 0 ? void 0 : error.message) || (response === null || response === void 0 ? void 0 : (_response$parsedJson = response.parsedJson) === null || _response$parsedJson === void 0 ? void 0 : _response$parsedJson.message) || me.L("L{parseFailure}");
        break;
    }
    me.applyMaskError(`<div class="b-grid-load-failure">
                <div class="b-grid-load-fail">${me.L(action === "read" ? "L{loadFailedMessage}" : "L{syncFailedMessage}")}</div>
                ${response !== null && response !== void 0 && response.url ? `<div class="b-grid-load-fail">${response.url}</div>` : ""}
                <div class="b-grid-load-fail">${me.L("L{serverResponse}")}</div>
                <div class="b-grid-load-fail">${message}</div>
            </div>`);
  }
  onStoreDataChange({
    action,
    changes,
    source: store,
    syncInfo
  }) {
    var _super$onStoreDataCha, _syncInfo$removed;
    if (this.refreshSuspended || !this.rowManager) {
      return;
    }
    const me = this, isGroupFieldChange = store.isGrouped && changes && store.groupers.some((grouper) => grouper.field in changes);
    (_super$onStoreDataCha = super.onStoreDataChange) === null || _super$onStoreDataCha === void 0 ? void 0 : _super$onStoreDataCha.call(this, ...arguments);
    if (action === "batch" && syncInfo !== null && syncInfo !== void 0 && (_syncInfo$removed = syncInfo.removed) !== null && _syncInfo$removed !== void 0 && _syncInfo$removed.length) {
      me.rowManager.renderFromRow(me.topRow);
    } else {
      if (action === "dataset") {
        me.rowManager.clearKnownHeights();
      }
      if (me.isPainted && !isGroupFieldChange) {
        me.renderRows(Boolean(!(action in datasetReplaceActions) || me.preserveScrollOnDatasetChange));
      }
    }
    me.toggleEmptyText();
  }
  onStoreRecordIdChange() {
    super.onStoreRecordIdChange && super.onStoreRecordIdChange(...arguments);
  }
  onStoreBeforeRequest() {
    this.applyLoadMask();
  }
  onStoreAfterRequest(event) {
    if (this.loadMask && !event.exception) {
      this.masked = null;
      this.toggleEmptyText();
    }
  }
  needsFullRefreshOnStoreRemove({
    isCollapse
  }) {
    const features = this._features;
    return (features === null || features === void 0 ? void 0 : features.group) && !features.group.disabled || (features === null || features === void 0 ? void 0 : features.groupSummary) && !features.groupSummary.disabled || this.store.tree && !isCollapse && this.store.modelClass.convertEmptyParentToLeaf;
  }
  onStoreRemove({
    records,
    isCollapse,
    isChild,
    isMove,
    isCollapseAll
  }) {
    if (!this.isPainted || isMove || isCollapseAll) {
      return;
    }
    super.onStoreRemove && super.onStoreRemove(...arguments);
    const me = this, {
      rowManager
    } = me;
    rowManager.invalidateKnownHeight(records);
    if (me.animateRemovingRows && !isCollapse && !isChild) {
      const rowsToRemove = records.reduce((result, record) => {
        const row = rowManager.getRowById(record.id);
        row && result.push(row);
        return result;
      }, []);
      if (rowsToRemove.length) {
        const topRow = rowsToRemove[0];
        me.isAnimating = true;
        EventHelper.onTransitionEnd({
          element: topRow._elementsArray[0],
          property: "left",
          duration: me.transitionDuration,
          thisObj: me,
          handler: () => {
            me.isAnimating = false;
            rowsToRemove.forEach((row) => !row.isDestroyed && row.removeCls("b-removing"));
            rowManager.refresh();
            me.trigger("rowRemove");
            me.afterRemove(arguments[0]);
          }
        });
        rowsToRemove.forEach((row) => row.addCls("b-removing"));
        return;
      }
    }
    if (me.needsFullRefreshOnStoreRemove(...arguments)) {
      rowManager.refresh();
      me.afterRemove(arguments[0]);
    } else {
      const oldTopIndex = rowManager.topIndex;
      rowManager.calculateRowCount(false, true, true);
      if (rowManager.topIndex !== oldTopIndex) {
        rowManager.renderFromRow(rowManager.topRow);
      } else {
        const {
          rows
        } = rowManager, topRowIndex = records.reduce((result, record) => {
          const row = rowManager.getRowById(record.id);
          if (row) {
            result = Math.min(result, rows.indexOf(row));
          }
          return result;
        }, rows.length);
        if (rows[topRowIndex]) {
          !me.refreshSuspended && rowManager.renderFromRow(rows[topRowIndex]);
        } else {
          rowManager.trigger("changeTotalHeight", {
            totalHeight: rowManager.totalHeight
          });
        }
      }
      me.trigger("rowRemove", {
        isCollapse
      });
      me.afterRemove(arguments[0]);
    }
  }
  onFlatStoreMove({
    from,
    to
  }) {
    const {
      rowManager
    } = this, {
      topIndex,
      rowCount
    } = rowManager, [dataStart, dataEnd] = [from, to].sort((a, b) => a - b);
    if (dataStart >= topIndex && dataStart < topIndex + rowCount) {
      rowManager.renderFromRow(rowManager.rows[dataStart - topIndex]);
    } else if (dataEnd >= topIndex && dataEnd < topIndex + rowCount) {
      rowManager.refresh();
    }
  }
  onStoreReplace({
    records,
    all
  }) {
    const {
      rowManager
    } = this;
    if (all) {
      rowManager.clearKnownHeights();
      rowManager.refresh();
    } else {
      const rows = records.reduce((rows2, [, record]) => {
        const row = this.getRowFor(record);
        if (row) {
          rows2.push(row);
        }
        return rows2;
      }, []);
      rowManager.invalidateKnownHeight(records);
      rowManager.renderRows(rows);
    }
  }
  relayStoreDataChange(event) {
    this.ariaElement.setAttribute("aria-rowcount", this.store.count + 1);
    if (!this.project) {
      return this.trigger("dataChange", _objectSpread2(_objectSpread2({}, event), {}, {
        store: event.source,
        source: this
      }));
    }
  }
  onStoreRemoveAll() {
    super.onStoreRemoveAll && super.onStoreRemoveAll(...arguments);
    if (this.isPainted) {
      this.rowManager.clearKnownHeights();
      this.renderRows(false);
      this.toggleEmptyText();
    }
  }
  onStoreCommit({
    changes
  }) {
    if (this.showDirty && changes.modified.length) {
      const rows = [];
      changes.modified.forEach((record) => {
        const row = this.rowManager.getRowFor(record);
        row && rows.push(row);
      });
      this.rowManager.renderRows(rows);
    }
  }
  get data() {
    if (this._store) {
      return this._store.records;
    } else {
      return this._data;
    }
  }
  set data(data) {
    if (this._store) {
      this._store.data = data;
    } else {
      this._data = data;
    }
  }
  populateHeaderMenu({
    column,
    items: items2
  }) {
    const me = this, {
      subGrids,
      regions
    } = me, {
      parent
    } = column;
    let first = true;
    Object.entries(subGrids).forEach(([region, subGrid]) => {
      if (subGrid.sealedColumns) {
        return;
      }
      if (column.draggable && region !== column.region && (!parent && subGrids[column.region].columns.count > 1 || parent && parent.children.length > 1)) {
        const preceding = subGrid.element.compareDocumentPosition(subGrids[column.region].element) === document.DOCUMENT_POSITION_PRECEDING, moveRight = me.rtl ? !preceding : preceding, text = regions.length > 2 ? me.L("L{moveColumnTo}", me.optionalL(region)) : me.L(moveRight ? "L{moveColumnRight}" : "L{moveColumnLeft}");
        items2[`${region}Region`] = {
          targetSubGrid: region,
          text,
          icon: "b-fw-icon b-icon-column-move-" + (moveRight ? "right" : "left"),
          separator: first,
          onItem: ({
            item
          }) => {
            column.traverse((col) => col.region = region);
            me.columns.insert(me.columns.indexOf(subGrids[item.targetSubGrid].columns.last) + 1, column);
            me.scrollColumnIntoView(column);
          }
        };
        first = false;
      }
    });
  }
  populateCellMenu({
    record,
    items: items2
  }) {
  }
  getColumnDragToolbarItems(column, items2) {
    return items2;
  }
  normalizeCellContext(cellContext) {
    const grid = this, {
      columns
    } = grid;
    if (cellContext.isLocation) {
      return cellContext;
    }
    if (cellContext.isModel) {
      return new Location({
        grid,
        id: cellContext.id,
        columnId: columns.visibleColumns[0].id
      });
    }
    return new Location(ObjectHelper.assign({
      grid
    }, cellContext));
  }
  getCell(cellContext) {
    const {
      store,
      columns
    } = this, {
      visibleColumns
    } = this.columns, rowIndex = !isNaN(cellContext.row) ? cellContext.row : !isNaN(cellContext.rowIndex) ? cellContext.rowIndex : store.indexOf(cellContext.record || cellContext.id), columnIndex = !isNaN(cellContext.column) ? cellContext.column : !isNaN(cellContext.columnIndex) ? cellContext.columnIndex : visibleColumns.indexOf(cellContext.column || columns.getById(cellContext.columnId) || columns.get(cellContext.field) || visibleColumns[0]);
    return rowIndex > -1 && rowIndex < store.count && columnIndex > -1 && columnIndex < visibleColumns.length && this.normalizeCellContext(cellContext).cell || null;
  }
  getHeaderElement(columnId) {
    if (columnId.isModel) {
      columnId = columnId.id;
    }
    return this.fromCache(`.b-grid-header[data-column-id="${columnId}"]`);
  }
  getHeaderElementByField(field) {
    const column = this.columns.get(field);
    return column ? this.getHeaderElement(column) : null;
  }
  get bodyHeight() {
    return this._bodyHeight;
  }
  get headerHeight() {
    const me = this;
    if (me.isPainted && !me._headerHeight) {
      me._headerHeight = me.headerContainer.offsetHeight;
    }
    return me._headerHeight;
  }
  get footerHeight() {
    const me = this;
    if (me.isPainted && !me._footerHeight) {
      me._footerHeight = me.footerContainer.offsetHeight;
    }
    return me._footerHeight;
  }
  get isTreeGrouped() {
    var _this$features$treeGr;
    return Boolean((_this$features$treeGr = this.features.treeGroup) === null || _this$features$treeGr === void 0 ? void 0 : _this$features$treeGr.isGrouped);
  }
  getRecordFromElement(element) {
    const el = element.closest(".b-grid-row");
    if (!el)
      return null;
    return this.store.getAt(el.dataset.index);
  }
  getColumnFromElement(element) {
    const cell = element.closest(".b-grid-cell, .b-grid-header");
    if (!cell)
      return null;
    if (cell.matches(".b-grid-header")) {
      return this.columns.getById(cell.dataset.columnId);
    }
    const cellData = DomDataStore.get(cell);
    return this.columns.getById(cellData.columnId);
  }
  updateAutoHeight(autoHeight) {
    ObjectHelper.assertBoolean(autoHeight, "autoHeight");
  }
  get columnLines() {
    return this._columnLines;
  }
  set columnLines(columnLines) {
    ObjectHelper.assertBoolean(columnLines, "columnLines");
    DomHelper.toggleClasses(this.element, "b-no-column-lines", !columnLines);
    this._columnLines = columnLines;
  }
  get keyMapElement() {
    return this.bodyElement;
  }
  fixSizes() {
    this.callEachSubGrid("fixWidths");
    const colHeaders = this.headerContainer.querySelectorAll(".b-grid-header.b-depth-0");
    for (let i = 0, {
      length
    } = colHeaders; i < length; i++) {
      colHeaders[i].setAttribute("aria-colindex", i + 1);
    }
  }
  onRowManagerChangeTotalHeight({
    totalHeight,
    immediate
  }) {
    return this.refreshTotalHeight(totalHeight, immediate);
  }
  refreshTotalHeight(height = this.rowManager.totalHeight, immediate = false) {
    const me = this;
    if (me.renderingRows || !me.isVisible) {
      return false;
    }
    const scroller = me.scrollable, delta = Math.abs(me.virtualScrollHeight - height), clientHeight = me._bodyRectangle.height, newMaxY = height - clientHeight;
    if (delta) {
      const isCritical = newMaxY - me._scrollTop < clientHeight * 2 || me._verticalScrollHeight && me._verticalScrollHeight - clientHeight < me._scrollTop;
      scroller.scrollHeight = me.virtualScrollHeight = height;
      if (me.isPainted && (me.scrolling && !isCritical || delta < 100) && !immediate) {
        me.bufferedFixElementHeights();
      } else {
        me.virtualScrollHeightDirty && me.virtualScrollHeightDirty();
        me.bufferedFixElementHeights.cancel();
        me.fixElementHeights();
      }
    }
  }
  fixElementHeights() {
    const me = this, height = me.virtualScrollHeight, heightInPx = `${height}px`;
    me._verticalScrollHeight = height;
    me.verticalScroller.style.height = heightInPx;
    me.virtualScrollHeightDirty = false;
    if (me.autoHeight) {
      me.bodyContainer.style.height = heightInPx;
      me._bodyHeight = height;
      me.refreshBodyRectangle();
    }
    me.refreshVirtualScrollbars();
  }
  refreshBodyRectangle() {
    return this._bodyRectangle = Rectangle.client(this.bodyContainer);
  }
  set scrolling(scrolling) {
    this._scrolling = scrolling;
  }
  get scrolling() {
    return this._scrolling;
  }
  enableScrollingCloseToEdges(subGrids) {
    this.scrollManager.startMonitoring({
      scrollables: [{
        element: this.scrollable.element,
        direction: "vertical"
      }, ...ArrayHelper.asArray(subGrids || []).map((subGrid) => ({
        element: (typeof subGrid === "string" ? this.subGrids[subGrid] : subGrid).scrollable.element
      }))],
      direction: "horizontal"
    });
  }
  disableScrollingCloseToEdges(subGrids) {
    this.scrollManager.stopMonitoring([this.scrollable.element, ...ArrayHelper.asArray(subGrids || []).map((subGrid) => (typeof subGrid === "string" ? this.subGrids[subGrid] : subGrid).element)]);
  }
  onRowManagerRequestScrollChange({
    bottom
  }) {
    this.scrollable.y = bottom - this.bodyHeight;
  }
  initScroll() {
    const me = this, {
      scrollable
    } = me;
    if (!me.scrollInitialized) {
      me.scrollInitialized = true;
      scrollable.contentElement = me.contentElement;
      scrollable.ion({
        scroll: "onGridVerticalScroll",
        scrollend: "onGridVerticalScrollEnd",
        thisObj: me
      });
      me.callEachSubGrid("initScroll");
      if (BrowserHelper.isMobileSafari) {
        scrollable.element.style.transform = "translate3d(0, 0, 0)";
      }
    }
  }
  onGridVerticalScroll({
    source: scrollable
  }) {
    const me = this, {
      y: scrollTop
    } = scrollable;
    if (scrollTop !== me._scrollTop) {
      me._scrollTop = scrollTop;
      if (!me.scrolling) {
        me.scrolling = true;
        me.eachSubGrid((s) => s.suspendResizeMonitor = true);
      }
      me.rowManager.updateRenderedRows(scrollTop);
      me.afterScroll({
        scrollTop
      });
      me.trigger("scroll", {
        scrollTop
      });
    }
  }
  onGridVerticalScrollEnd() {
    this.scrolling = false;
    this.eachSubGrid((s) => s.suspendResizeMonitor = false);
  }
  async scrollRowIntoView(recordOrId, options = defaultScrollOptions$2) {
    const me = this, blockPosition = options.block || "nearest", {
      rowManager
    } = me, record = me.store.getById(recordOrId);
    if (record) {
      let scrollPromise2;
      if (me.store.indexOf(record) === -1) {
        return resolvedPromise;
      }
      let scroller = me.scrollable, recordRect = me.getRecordCoords(record);
      const scrollerRect = Rectangle.from(scroller.element);
      if (recordRect.virtual) {
        const virtualBlock = recordRect.block, innerOptions = blockPosition !== "nearest" ? options : {
          block: virtualBlock
        };
        scrollPromise2 = scroller.scrollIntoView(recordRect, {
          block: "center"
        });
        rowManager.scrollTargetRecordId = record;
        rowManager.updateRenderedRows(scroller.y, true);
        recordRect = me.getRecordCoords(record);
        rowManager.lastScrollTop = scroller.y;
        if (recordRect.virtual) {
          return resolvedPromise;
        }
        if (options.animate) {
          scroller.suspendEvents();
          if (blockPosition === "end" || blockPosition === "nearest" && virtualBlock === "end") {
            scroller.y -= scrollerRect.bottom - recordRect.bottom;
          } else if (blockPosition === "start" || blockPosition === "nearest" && virtualBlock === "start") {
            scroller.y += recordRect.y - scrollerRect.y;
          }
          rowManager.updateRenderedRows(scroller.y, false, true);
          if (virtualBlock === "end") {
            scroller.y -= rowManager.appendRowBuffer * rowManager.rowHeight - 1;
          } else {
            scroller.y += rowManager.prependRowBuffer * rowManager.rowHeight - 1;
          }
          scroller.scrollIntoView(me.getRecordCoords(record), Object.assign({}, options, innerOptions));
          scroller.resumeEvents();
        } else {
          var _me$scrollRowIntoView;
          if (!options.recursive) {
            await scrollPromise2;
          }
          await ((_me$scrollRowIntoView = me.scrollRowIntoView) === null || _me$scrollRowIntoView === void 0 ? void 0 : _me$scrollRowIntoView.call(me, record, Object.assign({
            recursive: true
          }, options, innerOptions)));
        }
      } else {
        let {
          column
        } = options;
        if (column) {
          if (!column.isModel) {
            column = me.columns.getById(column) || me.columns.get(column);
          }
          if (column) {
            scroller = me.getSubGridFromColumn(column).scrollable;
            const cellRect = Rectangle.from(rowManager.getRowFor(record).getCell(column.id));
            recordRect.x = cellRect.x;
            recordRect.width = cellRect.width;
          }
        } else {
          options.x = false;
        }
        return scroller.scrollIntoView(recordRect, options);
      }
    }
  }
  scrollColumnIntoView(column, options) {
    column = column instanceof Column ? column : this.columns.get(column) || this.columns.getById(column) || this.columns.getAt(column);
    return this.getSubGridFromColumn(column).scrollColumnIntoView(column, options);
  }
  scrollCellIntoView(cellContext, options) {
    return this.scrollRowIntoView(cellContext.id, Object.assign({
      column: cellContext.columnId
    }, typeof options === "boolean" ? {
      animate: options
    } : options));
  }
  scrollToBottom(options) {
    return this.scrollRowIntoView(this.store.last, options);
  }
  scrollToTop(options) {
    return this.scrollable.scrollBy(0, -this.scrollable.y, options);
  }
  storeScroll() {
    const me = this, state = me.storedScrollState = {
      scrollTop: me.scrollable.y,
      scrollLeft: {}
    };
    me.eachSubGrid((subGrid) => {
      state.scrollLeft[subGrid.region] = subGrid.scrollable.x;
    });
    return state;
  }
  restoreScroll(state = this.storedScrollState) {
    const me = this;
    me.eachSubGrid((subGrid) => {
      const x = state.scrollLeft[subGrid.region];
      if (x != null) {
        var _subGrid$fakeScroller;
        subGrid.scrollable.updateX(x);
        subGrid.header.scrollable.updateX(x);
        subGrid.footer.scrollable.updateX(x);
        (_subGrid$fakeScroller = subGrid.fakeScroller) === null || _subGrid$fakeScroller === void 0 ? void 0 : _subGrid$fakeScroller.updateX(x);
      }
    });
    me.scrollable.updateY(state.scrollTop);
  }
  beginGridMeasuring() {
    const me = this;
    if (!me.$measureCellElements) {
      me.$measureCellElements = DomHelper.createElement({
        className: "b-grid-subgrid " + (!me._isRowMeasured && me.hasFeature("stripe") ? "b-stripe" : ""),
        reference: "subGridElement",
        style: {
          position: "absolute",
          top: "-10000px",
          left: "-100000px",
          visibility: "hidden",
          contain: "strict"
        },
        children: [{
          className: "b-grid-row",
          reference: "rowElement",
          children: [{
            className: "b-grid-cell",
            reference: "cellElement",
            style: {
              width: "auto",
              contain: BrowserHelper.isFirefox ? "layout paint" : "layout style paint"
            }
          }]
        }]
      });
    }
    me.getConfig("element");
    me.verticalScroller.appendChild(me.$measureCellElements.subGridElement);
    if (!me.rendered) {
      const targetEl = me.appendTo || me.insertBefore || document.body, rootElement = DomHelper.getRootElement(typeof targetEl === "string" ? document.getElementById(targetEl) : targetEl);
      if (!me.adopt || !rootElement.contains(me.element)) {
        rootElement.appendChild(me.element);
        me.$removeAfterMeasuring = true;
      }
    }
    return me.$measureCellElements;
  }
  endGridMeasuring() {
    if (this.$removeAfterMeasuring) {
      this.element.remove();
      this.$removeAfterMeasuring = false;
    }
    this.$measureCellElements.subGridElement.remove();
  }
  measureRowHeight() {
    const me = this, {
      rowElement
    } = me.beginGridMeasuring(), styles = DomHelper.getStyleValue(rowElement, ["height", "border-top-width", "border-bottom-width"]), styleHeight = parseInt(styles.height), multiplier = BrowserHelper.isFirefox ? globalThis.devicePixelRatio / Math.max(Math.trunc(globalThis.devicePixelRatio), 1) : 1, borderTop = styles["border-top-width"] ? Math.round(multiplier * parseFloat(styles["border-top-width"])) : 0, borderBottom = styles["border-bottom-width"] ? Math.round(multiplier * parseFloat(styles["border-bottom-width"])) : 0;
    if (me.rowHeight == null || me.rowHeight === me._rowHeightFromStyle) {
      me.rowHeight = !isNaN(styleHeight) && styleHeight ? styleHeight : me.defaultRowHeight;
      me._rowHeightFromStyle = me.rowHeight;
    }
    me._rowBorderHeight = borderTop + borderBottom;
    me._isRowMeasured = true;
    me.endGridMeasuring();
  }
  onThemeChange({
    theme
  }) {
    this.whenVisible("measureRowHeight");
    this.trigger("theme", {
      theme
    });
  }
  refreshRows(returnToTop = false) {
    const {
      element,
      rowManager
    } = this;
    element.classList.add("b-notransition");
    if (returnToTop) {
      rowManager.returnToTop();
    } else {
      rowManager.refresh();
    }
    element.classList.remove("b-notransition");
  }
  refreshColumn(column) {
    if (column.isVisible) {
      if (column.isLeaf) {
        this.rowManager.forEach((row) => row.renderCell(row.getCell(column.id)));
      } else {
        column.children.forEach((child) => this.refreshColumn(child));
      }
    }
  }
  refreshVirtualScrollbars() {
    const me = this, {
      headerContainer,
      footerContainer,
      virtualScrollers,
      scrollable,
      hasVerticalOverflow
    } = me, {
      classList
    } = virtualScrollers, hadHorizontalOverflow = !classList.contains("b-hide-display"), hasHorizontalOverflow = Object.values(me.subGrids).some((subGrid) => subGrid.overflowingHorizontally), horizontalOverflowChanged = hasHorizontalOverflow !== hadHorizontalOverflow;
    if (horizontalOverflowChanged) {
      virtualScrollers.classList.toggle("b-hide-display", !hasHorizontalOverflow);
    }
    if (DomHelper.scrollBarWidth) {
      const needsPadding = hasVerticalOverflow || scrollable.overflowY === "scroll";
      headerContainer.classList.toggle("b-show-yscroll-padding", needsPadding);
      footerContainer.classList.toggle("b-show-yscroll-padding", needsPadding);
      virtualScrollers.classList.toggle("b-show-yscroll-padding", needsPadding);
      if (horizontalOverflowChanged) {
        if (hasHorizontalOverflow) {
          me.callEachSubGrid("refreshFakeScroll");
        }
        me.onHeightChange();
      }
    }
  }
  get hasVerticalOverflow() {
    return this.scrollable.hasOverflow("y");
  }
  get contentHeight() {
    const rowManager = this.rowManager;
    return Math.max(rowManager.totalHeight, rowManager.bottomRow ? rowManager.bottomRow.bottom : 0);
  }
  onContentChange() {
    const me = this, rowManager = me.rowManager;
    if (me.isVisible) {
      rowManager.estimateTotalHeight();
      me.paintListener = null;
      me.refreshTotalHeight(me.contentHeight);
      me.callEachSubGrid("refreshFakeScroll");
      me.onHeightChange();
    } else if (!me.paintListener) {
      me.paintListener = me.ion({
        paint: "onContentChange",
        once: true,
        thisObj: me
      });
    }
  }
  triggerPaint() {
    if (!this.isPainted) {
      this.refreshBodyRectangle();
    }
    super.triggerPaint();
  }
  onHeightChange() {
    const me = this;
    me.refreshBodyRectangle();
    me._bodyHeight = me.autoHeight ? me.contentHeight : me.bodyContainer.offsetHeight;
  }
  suspendRefresh() {
    this.refreshSuspended++;
  }
  resumeRefresh(trigger) {
    if (this.refreshSuspended && !--this.refreshSuspended) {
      if (trigger) {
        this.refreshRows();
      }
      this.trigger("resumeRefresh", {
        trigger
      });
    }
  }
  renderRows(keepScroll = true) {
    const me = this, scrollState = keepScroll && me.storeScroll();
    if (me.refreshSuspended) {
      return;
    }
    me.trigger("beforeRenderRows");
    me.renderingRows = true;
    me.element.classList.add("b-grid-refreshing");
    if (!keepScroll) {
      me.scrollable.y = me._scrollTop = 0;
    }
    me.rowManager.reinitialize(!keepScroll);
    me.trigger("renderRows");
    me.renderingRows = false;
    me.onContentChange();
    if (keepScroll) {
      me.restoreScroll(scrollState);
    }
    me.element.classList.remove("b-grid-refreshing");
  }
  renderContents() {
    const me = this, {
      element,
      headerContainer,
      footerContainer,
      rowManager
    } = me;
    me.emptyCache();
    if (me.isPainted) {
      me._headerHeight = null;
      me.callEachSubGrid("refreshHeader", headerContainer);
      me.callEachSubGrid("refreshFooter", footerContainer);
      me.renderHeader(headerContainer, element);
      me.renderFooter(footerContainer, element);
      me.fixSizes();
      const refreshContext = rowManager.removeAllRows();
      rowManager.calculateRowCount(false, true, true);
      if (rowManager.rowCount) {
        rowManager.setPosition(refreshContext);
        me.renderRows();
      }
    }
  }
  onPaintOverride() {
  }
  onPaint({
    firstPaint
  }) {
    var _super$onPaint;
    const me = this;
    me.ariaElement.setAttribute("aria-rowcount", me.store.count + 1);
    (_super$onPaint = super.onPaint) === null || _super$onPaint === void 0 ? void 0 : _super$onPaint.call(this, ...arguments);
    if (me.onPaintOverride() || !firstPaint) {
      return;
    }
    const {
      rowManager,
      store,
      element,
      headerContainer,
      bodyContainer,
      footerContainer
    } = me, scrollPad = DomHelper.scrollBarPadElement;
    let columnsChanged, maxDepth = 0;
    me.role = store !== null && store !== void 0 && store.isTree ? "treegrid" : "grid";
    me.columns.ion({
      change: () => columnsChanged = true,
      once: true
    });
    me.updateResponsive(me.width, 0);
    if (columnsChanged) {
      me.callEachSubGrid("refreshHeader", headerContainer);
      me.callEachSubGrid("refreshFooter", footerContainer);
    }
    me.renderHeader(headerContainer, element);
    me.renderFooter(footerContainer, element);
    DomHelper.append(headerContainer, scrollPad);
    DomHelper.append(footerContainer, scrollPad);
    DomHelper.append(me.virtualScrollers, scrollPad);
    me.refreshBodyRectangle();
    const bodyOffsetHeight = me.bodyContainer.offsetHeight;
    if (me.autoHeight) {
      me._bodyHeight = rowManager.initWithHeight(element.offsetHeight - headerContainer.offsetHeight - footerContainer.offsetHeight, true);
      bodyContainer.style.height = me.bodyHeight + "px";
    } else {
      me._bodyHeight = bodyOffsetHeight;
      rowManager.initWithHeight(me._bodyHeight, true);
    }
    me.eachSubGrid((subGrid) => {
      if (subGrid.header.maxDepth > maxDepth) {
        maxDepth = subGrid.header.maxDepth;
      }
    });
    headerContainer.dataset.maxDepth = maxDepth;
    me.fixSizes();
    if (store.count || !store.isLoading) {
      me.renderRows();
    }
    if (me.columns.usesAutoHeight) {
      const {
        fonts
      } = document;
      if ((fonts === null || fonts === void 0 ? void 0 : fonts.status) !== "loaded") {
        fonts.ready.then(() => !me.isDestroyed && me.refreshRows());
      }
    }
    me.initScroll();
    me.initInternalEvents();
  }
  render() {
    const me = this;
    me.requireSize = Boolean(me.owner);
    super.render(...arguments);
    if (!me.autoHeight) {
      if (me.headerContainer.offsetHeight && !me.bodyContainer.offsetHeight) {
        console.warn("Grid element not sized correctly, please check your CSS styles and review how you size the widget");
      }
      if (!("minHeight" in me.initialConfig) && !("height" in me.initialConfig) && parseInt(globalThis.getComputedStyle(me.element).minHeight) === me.height) {
        console.warn(`The ${me.$$name} is sized by its predefined minHeight, likely this is not intended. Please check your CSS and review how you size the widget, or assign a fixed height in the config. For more information, see the "Basics/Sizing the component" guide in docs.`);
      }
    }
  }
  renderHeader(headerContainer, element) {
  }
  renderFooter(footerContainer, element) {
  }
  beforeRenderCell() {
  }
  beforeRenderRow() {
  }
  afterRenderRow() {
  }
  afterScroll() {
  }
  processCellEditor(editorConfig) {
  }
  afterColumnsChange() {
  }
  afterRemove(removeEvent) {
  }
  afterToggleGroup() {
  }
  afterToggleSubGrid() {
  }
  syncMaskCover(mask = this.masked) {
    if (mask) {
      const bodyRect = mask.cover === "body" && this.rectangleOf("bodyContainer"), scrollerRect = bodyRect && this.rectangleOf("virtualScrollers"), {
        style
      } = mask.element;
      style.marginTop = bodyRect ? `${bodyRect.y}px` : "";
      style.height = bodyRect ? `${bodyRect.height + ((scrollerRect === null || scrollerRect === void 0 ? void 0 : scrollerRect.height) || 0)}px` : "";
    }
  }
  maskBody(loadMask) {
    let ret;
    if (this.bodyContainer) {
      this.masked = Mask.mergeConfigs(this.loadMaskDefaults, loadMask);
      ret = this.masked;
    }
    return ret;
  }
  unmaskBody() {
    this.masked = null;
  }
  updateEmptyText(emptyText) {
    var _this$emptyTextEl, _this$firstItem;
    (_this$emptyTextEl = this.emptyTextEl) === null || _this$emptyTextEl === void 0 ? void 0 : _this$emptyTextEl.remove();
    this.emptyTextEl = DomHelper.createElement({
      parent: (_this$firstItem = this.firstItem) === null || _this$firstItem === void 0 ? void 0 : _this$firstItem.element,
      className: "b-empty-text",
      [emptyText !== null && emptyText !== void 0 && emptyText.includes("<") ? "html" : "text"]: emptyText
    });
  }
  toggleEmptyText() {
    const {
      bodyContainer,
      store
    } = this;
    bodyContainer === null || bodyContainer === void 0 ? void 0 : bodyContainer.classList.toggle("b-grid-empty", !(store.count > 0 || store.isLoading || store.isCommitting));
  }
  updateReadOnly(readOnly, old) {
    super.updateReadOnly(readOnly, old);
    if (!this.isConfiguring) {
      for (const column of this.columns.bottomColumns) {
        var _column$updateReadOnl;
        (_column$updateReadOnl = column.updateReadOnly) === null || _column$updateReadOnl === void 0 ? void 0 : _column$updateReadOnl.call(column, readOnly);
      }
    }
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options), {
      store
    } = this, data = store.getInlineData(options), storeState = store.getCurrentConfig(options) || result.store;
    if (data.length) {
      result.data = data;
    }
    if (storeState && store.originalModelClass === GridRowModel) {
      delete storeState.modelClass;
    }
    if (!ObjectHelper.isEmpty(storeState)) {
      result.store = storeState;
    }
    if (result.store) {
      delete result.store.data;
    }
    return result;
  }
};
GridBase.initClass();
VersionHelper.setVersion("grid", "5.3.0");
GridBase._$name = "GridBase";
var Grid = class extends GridBase {
  static get $name() {
    return "Grid";
  }
  static get type() {
    return "grid";
  }
};
Grid.initClass();
Grid._$name = "Grid";
var TreeGrid = class extends Grid {
  static get $name() {
    return "TreeGrid";
  }
  static get type() {
    return "treegrid";
  }
  static get configurable() {
    return {
      store: {
        tree: true
      }
    };
  }
  updateStore(store, was) {
    if (store && !store.tree) {
      throw new Error("TreeGrid requires a Store configured with tree : true");
    }
    super.updateStore(store, was);
  }
};
TreeGrid.initClass();
TreeGrid._$name = "TreeGrid";
var TreeCombo = class extends Combo {
  configure(config) {
    super.configure(config);
    const me = this;
    me.ion({
      change() {
        me.picker.selectedRecords = me.value;
      }
    });
  }
  changePicker(picker, oldPicker) {
    const me = this;
    return super.changePicker(ObjectHelper.assign({}, picker, {
      type: "treegrid",
      minWidth: "35em",
      readOnly: me.readOnly,
      disableGridRowModelWarning: true,
      selectedRecords: me.value.map((val) => me.store.getById(val)),
      selectionMode: {
        row: true,
        multiSelect: me.multiSelect,
        rowCheckboxSelection: true
      },
      internalListeners: {
        selectionChange({
          selection
        }) {
          me.value = selection;
        }
      }
    }), oldPicker);
  }
};
_defineProperty(TreeCombo, "$name", "TreeCombo");
_defineProperty(TreeCombo, "type", "treecombo");
_defineProperty(TreeCombo, "configurable", {
  multiSelect: true,
  chipView: {
    itemTpl(record) {
      return StringHelper.xss`${record.name}`;
    },
    scrollable: {
      overflowX: "hidden-scroll"
    }
  }
});
TreeCombo.initClass();
TreeCombo._$name = "TreeCombo";
var diffSecond = (date2, diff) => {
  return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), date2.getHours(), date2.getMinutes(), date2.getSeconds() + diff, date2.getMilliseconds());
};
var later = function() {
  var later2 = {
    version: "1.2.0"
  };
  if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function(searchElement) {
      if (this == null) {
        throw new TypeError();
      }
      var t = Object(this);
      var len = t.length >>> 0;
      if (len === 0) {
        return -1;
      }
      var n = 0;
      if (arguments.length > 1) {
        n = Number(arguments[1]);
        if (n != n) {
          n = 0;
        } else if (n != 0 && n != Infinity && n != -Infinity) {
          n = (n > 0 || -1) * Math.floor(Math.abs(n));
        }
      }
      if (n >= len) {
        return -1;
      }
      var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
      for (; k < len; k++) {
        if (k in t && t[k] === searchElement) {
          return k;
        }
      }
      return -1;
    };
  }
  if (!String.prototype.trim) {
    String.prototype.trim = function() {
      return this.replace(/^\s+|\s+$/g, "");
    };
  }
  later2.array = {};
  later2.array.sort = function(arr, zeroIsLast) {
    arr.sort(function(a, b) {
      return +a - +b;
    });
    if (zeroIsLast && arr[0] === 0) {
      arr.push(arr.shift());
    }
  };
  later2.array.next = function(val, values, extent) {
    var cur, zeroIsLargest = extent[0] !== 0, nextIdx = 0;
    for (var i = values.length - 1; i > -1; --i) {
      cur = values[i];
      if (cur === val) {
        return cur;
      }
      if (cur > val || cur === 0 && zeroIsLargest && extent[1] > val) {
        nextIdx = i;
        continue;
      }
      break;
    }
    return values[nextIdx];
  };
  later2.array.nextInvalid = function(val, values, extent) {
    var min2 = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min2 !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;
    while (next === (values[i] || zeroVal)) {
      next++;
      if (next > max) {
        next = min2;
      }
      i++;
      if (i === len) {
        i = 0;
      }
      if (next === start) {
        return void 0;
      }
    }
    return next;
  };
  later2.array.prev = function(val, values, extent) {
    var cur, len = values.length, zeroIsLargest = extent[0] !== 0, prevIdx = len - 1;
    for (var i = 0; i < len; i++) {
      cur = values[i];
      if (cur === val) {
        return cur;
      }
      if (cur < val || cur === 0 && zeroIsLargest && extent[1] < val) {
        prevIdx = i;
        continue;
      }
      break;
    }
    return values[prevIdx];
  };
  later2.array.prevInvalid = function(val, values, extent) {
    var min2 = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min2 !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;
    while (next === (values[i] || zeroVal)) {
      next--;
      if (next < min2) {
        next = max;
      }
      i--;
      if (i === -1) {
        i = len - 1;
      }
      if (next === start) {
        return void 0;
      }
    }
    return next;
  };
  later2.day = later2.D = {
    name: "day",
    range: 86400,
    val: function(d) {
      return d.D || (d.D = later2.date.getDate.call(d));
    },
    isValid: function(d, val) {
      return later2.D.val(d) === (val || later2.D.extent(d)[1]);
    },
    extent: function(d) {
      if (d.DExtent)
        return d.DExtent;
      var month2 = later2.M.val(d), max = later2.DAYS_IN_MONTH[month2 - 1];
      if (month2 === 2 && later2.dy.extent(d)[1] === 366) {
        max = max + 1;
      }
      return d.DExtent = [1, max];
    },
    start: function(d) {
      return d.DStart || (d.DStart = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d)));
    },
    end: function(d) {
      return d.DEnd || (d.DEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d)));
    },
    next: function(d, val) {
      val = val > later2.D.extent(d)[1] ? 1 : val;
      var month2 = later2.date.nextRollover(d, val, later2.D, later2.M), DMax = later2.D.extent(month2)[1];
      val = val > DMax ? 1 : val || DMax;
      return later2.date.next(later2.Y.val(month2), later2.M.val(month2), val);
    },
    prev: function(d, val) {
      var month2 = later2.date.prevRollover(d, val, later2.D, later2.M), DMax = later2.D.extent(month2)[1];
      return later2.date.prev(later2.Y.val(month2), later2.M.val(month2), val > DMax ? DMax : val || DMax);
    }
  };
  later2.dayOfWeekCount = later2.dc = {
    name: "day of week count",
    range: 604800,
    val: function(d) {
      return d.dc || (d.dc = Math.floor((later2.D.val(d) - 1) / 7) + 1);
    },
    isValid: function(d, val) {
      return later2.dc.val(d) === val || val === 0 && later2.D.val(d) > later2.D.extent(d)[1] - 7;
    },
    extent: function(d) {
      return d.dcExtent || (d.dcExtent = [1, Math.ceil(later2.D.extent(d)[1] / 7)]);
    },
    start: function(d) {
      return d.dcStart || (d.dcStart = later2.date.next(later2.Y.val(d), later2.M.val(d), Math.max(1, (later2.dc.val(d) - 1) * 7 + 1 || 1)));
    },
    end: function(d) {
      return d.dcEnd || (d.dcEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), Math.min(later2.dc.val(d) * 7, later2.D.extent(d)[1])));
    },
    next: function(d, val) {
      val = val > later2.dc.extent(d)[1] ? 1 : val;
      var month2 = later2.date.nextRollover(d, val, later2.dc, later2.M), dcMax = later2.dc.extent(month2)[1];
      val = val > dcMax ? 1 : val;
      var next = later2.date.next(later2.Y.val(month2), later2.M.val(month2), val === 0 ? later2.D.extent(month2)[1] - 6 : 1 + 7 * (val - 1));
      if (next.getTime() <= d.getTime()) {
        month2 = later2.M.next(d, later2.M.val(d) + 1);
        return later2.date.next(later2.Y.val(month2), later2.M.val(month2), val === 0 ? later2.D.extent(month2)[1] - 6 : 1 + 7 * (val - 1));
      }
      return next;
    },
    prev: function(d, val) {
      var month2 = later2.date.prevRollover(d, val, later2.dc, later2.M), dcMax = later2.dc.extent(month2)[1];
      val = val > dcMax ? dcMax : val || dcMax;
      return later2.dc.end(later2.date.prev(later2.Y.val(month2), later2.M.val(month2), 1 + 7 * (val - 1)));
    }
  };
  later2.dayOfWeek = later2.dw = later2.d = {
    name: "day of week",
    range: 86400,
    val: function(d) {
      return d.dw || (d.dw = later2.date.getDay.call(d) + 1);
    },
    isValid: function(d, val) {
      return later2.dw.val(d) === (val || 7);
    },
    extent: function() {
      return [1, 7];
    },
    start: function(d) {
      return later2.D.start(d);
    },
    end: function(d) {
      return later2.D.end(d);
    },
    next: function(d, val) {
      val = val > 7 ? 1 : val || 7;
      return later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val - later2.dw.val(d)) + (val <= later2.dw.val(d) ? 7 : 0));
    },
    prev: function(d, val) {
      val = val > 7 ? 7 : val || 7;
      return later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val - later2.dw.val(d)) + (val >= later2.dw.val(d) ? -7 : 0));
    }
  };
  later2.dayOfYear = later2.dy = {
    name: "day of year",
    range: 86400,
    val: function(d) {
      return d.dy || (d.dy = Math.ceil(1 + (later2.D.start(d).getTime() - later2.Y.start(d).getTime()) / later2.DAY));
    },
    isValid: function(d, val) {
      return later2.dy.val(d) === (val || later2.dy.extent(d)[1]);
    },
    extent: function(d) {
      var year = later2.Y.val(d);
      return d.dyExtent || (d.dyExtent = [1, year % 4 ? 365 : 366]);
    },
    start: function(d) {
      return later2.D.start(d);
    },
    end: function(d) {
      return later2.D.end(d);
    },
    next: function(d, val) {
      val = val > later2.dy.extent(d)[1] ? 1 : val;
      var year = later2.date.nextRollover(d, val, later2.dy, later2.Y), dyMax = later2.dy.extent(year)[1];
      val = val > dyMax ? 1 : val || dyMax;
      return later2.date.next(later2.Y.val(year), later2.M.val(year), val);
    },
    prev: function(d, val) {
      var year = later2.date.prevRollover(d, val, later2.dy, later2.Y), dyMax = later2.dy.extent(year)[1];
      val = val > dyMax ? dyMax : val || dyMax;
      return later2.date.prev(later2.Y.val(year), later2.M.val(year), val);
    }
  };
  later2.hour = later2.h = {
    name: "hour",
    range: 3600,
    val: function(d) {
      return d.h || (d.h = later2.date.getHour.call(d));
    },
    isValid: function(d, val) {
      return later2.h.val(d) === val;
    },
    extent: function() {
      return [0, 23];
    },
    start: function(d) {
      return d.hStart || (d.hStart = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d)));
    },
    end: function(d) {
      return d.hEnd || (d.hEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d)));
    },
    next: function(d, val) {
      val = val > 23 ? 0 : val;
      var next = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val <= later2.h.val(d) ? 1 : 0), val);
      if (!later2.date.isUTC && next.getTime() <= d.getTime()) {
        next = later2.date.next(later2.Y.val(next), later2.M.val(next), later2.D.val(next), val + 1);
      }
      return next;
    },
    prev: function(d, val) {
      val = val > 23 ? 23 : val;
      return later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val >= later2.h.val(d) ? -1 : 0), val);
    }
  };
  later2.minute = later2.m = {
    name: "minute",
    range: 60,
    val: function(d) {
      return d.m || (d.m = later2.date.getMin.call(d));
    },
    isValid: function(d, val) {
      return later2.m.val(d) === val;
    },
    extent: function(d) {
      return [0, 59];
    },
    start: function(d) {
      return d.mStart || (d.mStart = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d), later2.m.val(d)));
    },
    end: function(d) {
      return d.mEnd || (d.mEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d), later2.m.val(d)));
    },
    next: function(d, val) {
      var m = later2.m.val(d), s = later2.s.val(d), inc = val > 59 ? 60 - m : val <= m ? 60 - m + val : val - m, next = new Date(d.getTime() + inc * later2.MIN - s * later2.SEC);
      if (!later2.date.isUTC && next.getTime() <= d.getTime()) {
        next = new Date(d.getTime() + (inc + 120) * later2.MIN - s * later2.SEC);
      }
      return next;
    },
    prev: function(d, val) {
      val = val > 59 ? 59 : val;
      return later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d) + (val >= later2.m.val(d) ? -1 : 0), val);
    }
  };
  later2.month = later2.M = {
    name: "month",
    range: 2629740,
    val: function(d) {
      return d.M || (d.M = later2.date.getMonth.call(d) + 1);
    },
    isValid: function(d, val) {
      return later2.M.val(d) === (val || 12);
    },
    extent: function() {
      return [1, 12];
    },
    start: function(d) {
      return d.MStart || (d.MStart = later2.date.next(later2.Y.val(d), later2.M.val(d)));
    },
    end: function(d) {
      return d.MEnd || (d.MEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d)));
    },
    next: function(d, val) {
      val = val > 12 ? 1 : val || 12;
      return later2.date.next(later2.Y.val(d) + (val > later2.M.val(d) ? 0 : 1), val);
    },
    prev: function(d, val) {
      val = val > 12 ? 12 : val || 12;
      return later2.date.prev(later2.Y.val(d) - (val >= later2.M.val(d) ? 1 : 0), val);
    }
  };
  later2.second = later2.s = {
    name: "second",
    range: 1,
    val: function(d) {
      return d.s || (d.s = later2.date.getSec.call(d));
    },
    isValid: function(d, val) {
      return later2.s.val(d) === val;
    },
    extent: function() {
      return [0, 59];
    },
    start: function(d) {
      return d;
    },
    end: function(d) {
      return d;
    },
    next: function(d, val) {
      var s = later2.s.val(d), inc = val > 59 ? 60 - s : val <= s ? 60 - s + val : val - s, next = new Date(d.getTime() + inc * later2.SEC);
      if (!later2.date.isUTC && next.getTime() <= d.getTime()) {
        next = new Date(d.getTime() + (inc + 7200) * later2.SEC);
      }
      return next;
    },
    prev: function(d, val, cache) {
      val = val > 59 ? 59 : val;
      return later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d), later2.m.val(d) + (val >= later2.s.val(d) ? -1 : 0), val);
    }
  };
  later2.time = later2.t = {
    name: "time",
    range: 1,
    val: function(d) {
      return d.t || (d.t = later2.h.val(d) * 3600 + later2.m.val(d) * 60 + later2.s.val(d));
    },
    isValid: function(d, val) {
      return later2.t.val(d) === val;
    },
    extent: function() {
      return [0, 86399];
    },
    start: function(d) {
      return d;
    },
    end: function(d) {
      return d;
    },
    next: function(d, val) {
      val = val > 86399 ? 0 : val;
      var next = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val <= later2.t.val(d) ? 1 : 0), 0, 0, val);
      if (!later2.date.isUTC && next.getTime() < d.getTime()) {
        next = later2.date.next(later2.Y.val(next), later2.M.val(next), later2.D.val(next), later2.h.val(next), later2.m.val(next), val + 7200);
      }
      return next;
    },
    prev: function(d, val) {
      val = val > 86399 ? 86399 : val;
      return later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val >= later2.t.val(d) ? -1 : 0), 0, 0, val);
    }
  };
  later2.weekOfMonth = later2.wm = {
    name: "week of month",
    range: 604800,
    val: function(d) {
      return d.wm || (d.wm = (later2.D.val(d) + (later2.dw.val(later2.M.start(d)) - 1) + (7 - later2.dw.val(d))) / 7);
    },
    isValid: function(d, val) {
      return later2.wm.val(d) === (val || later2.wm.extent(d)[1]);
    },
    extent: function(d) {
      return d.wmExtent || (d.wmExtent = [1, (later2.D.extent(d)[1] + (later2.dw.val(later2.M.start(d)) - 1) + (7 - later2.dw.val(later2.M.end(d)))) / 7]);
    },
    start: function(d) {
      return d.wmStart || (d.wmStart = later2.date.next(later2.Y.val(d), later2.M.val(d), Math.max(later2.D.val(d) - later2.dw.val(d) + 1, 1)));
    },
    end: function(d) {
      return d.wmEnd || (d.wmEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), Math.min(later2.D.val(d) + (7 - later2.dw.val(d)), later2.D.extent(d)[1])));
    },
    next: function(d, val) {
      val = val > later2.wm.extent(d)[1] ? 1 : val;
      var month2 = later2.date.nextRollover(d, val, later2.wm, later2.M), wmMax = later2.wm.extent(month2)[1];
      val = val > wmMax ? 1 : val || wmMax;
      return later2.date.next(later2.Y.val(month2), later2.M.val(month2), Math.max(1, (val - 1) * 7 - (later2.dw.val(month2) - 2)));
    },
    prev: function(d, val) {
      var month2 = later2.date.prevRollover(d, val, later2.wm, later2.M), wmMax = later2.wm.extent(month2)[1];
      val = val > wmMax ? wmMax : val || wmMax;
      return later2.wm.end(later2.date.next(later2.Y.val(month2), later2.M.val(month2), Math.max(1, (val - 1) * 7 - (later2.dw.val(month2) - 2))));
    }
  };
  later2.weekOfYear = later2.wy = {
    name: "week of year (ISO)",
    range: 604800,
    val: function(d) {
      if (d.wy)
        return d.wy;
      var wThur = later2.dw.next(later2.wy.start(d), 5), YThur = later2.dw.next(later2.Y.prev(wThur, later2.Y.val(wThur) - 1), 5);
      return d.wy = 1 + Math.ceil((wThur.getTime() - YThur.getTime()) / later2.WEEK);
    },
    isValid: function(d, val) {
      return later2.wy.val(d) === (val || later2.wy.extent(d)[1]);
    },
    extent: function(d) {
      if (d.wyExtent)
        return d.wyExtent;
      var year = later2.dw.next(later2.wy.start(d), 5), dwFirst = later2.dw.val(later2.Y.start(year)), dwLast = later2.dw.val(later2.Y.end(year));
      return d.wyExtent = [1, dwFirst === 5 || dwLast === 5 ? 53 : 52];
    },
    start: function(d) {
      return d.wyStart || (d.wyStart = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d) - (later2.dw.val(d) > 1 ? later2.dw.val(d) - 2 : 6)));
    },
    end: function(d) {
      return d.wyEnd || (d.wyEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (later2.dw.val(d) > 1 ? 8 - later2.dw.val(d) : 0)));
    },
    next: function(d, val) {
      val = val > later2.wy.extent(d)[1] ? 1 : val;
      var wyThur = later2.dw.next(later2.wy.start(d), 5), year = later2.date.nextRollover(wyThur, val, later2.wy, later2.Y);
      if (later2.wy.val(year) !== 1) {
        year = later2.dw.next(year, 2);
      }
      var wyMax = later2.wy.extent(year)[1], wyStart = later2.wy.start(year);
      val = val > wyMax ? 1 : val || wyMax;
      return later2.date.next(later2.Y.val(wyStart), later2.M.val(wyStart), later2.D.val(wyStart) + 7 * (val - 1));
    },
    prev: function(d, val) {
      var wyThur = later2.dw.next(later2.wy.start(d), 5), year = later2.date.prevRollover(wyThur, val, later2.wy, later2.Y);
      if (later2.wy.val(year) !== 1) {
        year = later2.dw.next(year, 2);
      }
      var wyMax = later2.wy.extent(year)[1], wyEnd = later2.wy.end(year);
      val = val > wyMax ? wyMax : val || wyMax;
      return later2.wy.end(later2.date.next(later2.Y.val(wyEnd), later2.M.val(wyEnd), later2.D.val(wyEnd) + 7 * (val - 1)));
    }
  };
  later2.year = later2.Y = {
    name: "year",
    range: 31556900,
    val: function(d) {
      return d.Y || (d.Y = later2.date.getYear.call(d));
    },
    isValid: function(d, val) {
      return later2.Y.val(d) === val;
    },
    extent: function() {
      return [1970, 2099];
    },
    start: function(d) {
      return d.YStart || (d.YStart = later2.date.next(later2.Y.val(d)));
    },
    end: function(d) {
      return d.YEnd || (d.YEnd = later2.date.prev(later2.Y.val(d)));
    },
    next: function(d, val) {
      return val > later2.Y.val(d) && val <= later2.Y.extent()[1] ? later2.date.next(val) : later2.NEVER;
    },
    prev: function(d, val) {
      return val < later2.Y.val(d) && val >= later2.Y.extent()[0] ? later2.date.prev(val) : later2.NEVER;
    }
  };
  later2.fullDate = later2.fd = {
    name: "full date",
    range: 1,
    val: function(d) {
      return d.fd || (d.fd = d.getTime());
    },
    isValid: function(d, val) {
      return later2.fd.val(d) === val;
    },
    extent: function() {
      return [0, 3250368e7];
    },
    start: function(d) {
      return d;
    },
    end: function(d) {
      return d;
    },
    next: function(d, val) {
      return later2.fd.val(d) < val ? new Date(val) : later2.NEVER;
    },
    prev: function(d, val) {
      return later2.fd.val(d) > val ? new Date(val) : later2.NEVER;
    }
  };
  later2.modifier = {};
  later2.modifier.after = later2.modifier.a = function(constraint, values) {
    var value = values[0];
    return {
      name: "after " + constraint.name,
      range: (constraint.extent(new Date())[1] - value) * constraint.range,
      val: constraint.val,
      isValid: function(d, val) {
        return this.val(d) >= value;
      },
      extent: constraint.extent,
      start: constraint.start,
      end: constraint.end,
      next: function(startDate, val) {
        if (val != value)
          val = constraint.extent(startDate)[0];
        return constraint.next(startDate, val);
      },
      prev: function(startDate, val) {
        val = val === value ? constraint.extent(startDate)[1] : value - 1;
        return constraint.prev(startDate, val);
      }
    };
  };
  later2.modifier.before = later2.modifier.b = function(constraint, values) {
    var value = values[values.length - 1];
    return {
      name: "before " + constraint.name,
      range: constraint.range * (value - 1),
      val: constraint.val,
      isValid: function(d, val) {
        return this.val(d) < value;
      },
      extent: constraint.extent,
      start: constraint.start,
      end: constraint.end,
      next: function(startDate, val) {
        val = val === value ? constraint.extent(startDate)[0] : value;
        return constraint.next(startDate, val);
      },
      prev: function(startDate, val) {
        val = val === value ? value - 1 : constraint.extent(startDate)[1];
        return constraint.prev(startDate, val);
      }
    };
  };
  later2.compile = function(schedDef) {
    var constraints = [], constraintsLen = 0, tickConstraint;
    for (var key in schedDef) {
      var nameParts = key.split("_"), name = nameParts[0], mod = nameParts[1], vals = schedDef[key], constraint = mod ? later2.modifier[mod](later2[name], vals) : later2[name];
      constraints.push({
        constraint,
        vals
      });
      constraintsLen++;
    }
    constraints.sort(function(a, b) {
      var ra = a.constraint.range, rb = b.constraint.range;
      return rb < ra ? -1 : rb > ra ? 1 : 0;
    });
    tickConstraint = constraints[constraintsLen - 1].constraint;
    function compareFn(dir) {
      return dir === "next" ? function(a, b) {
        return a.getTime() > b.getTime();
      } : function(a, b) {
        return b.getTime() > a.getTime();
      };
    }
    return {
      start: function(dir, startDate) {
        var next = startDate, nextVal = later2.array[dir], maxAttempts = 1e3, done;
        while (maxAttempts-- && !done && next) {
          done = true;
          for (var i = 0; i < constraintsLen; i++) {
            var constraint2 = constraints[i].constraint, curVal = constraint2.val(next), extent = constraint2.extent(next), newVal = nextVal(curVal, constraints[i].vals, extent);
            if (!constraint2.isValid(next, newVal)) {
              next = constraint2[dir](next, newVal);
              done = false;
              break;
            }
          }
        }
        if (next !== later2.NEVER) {
          next = dir === "next" ? tickConstraint.start(next) : tickConstraint.end(next);
        }
        return next;
      },
      end: function(dir, startDate) {
        var result, nextVal = later2.array[dir + "Invalid"], compare = compareFn(dir);
        for (var i = constraintsLen - 1; i >= 0; i--) {
          var constraint2 = constraints[i].constraint, curVal = constraint2.val(startDate), extent = constraint2.extent(startDate), newVal = nextVal(curVal, constraints[i].vals, extent), next;
          if (newVal !== void 0) {
            next = constraint2[dir](startDate, newVal);
            if (next && (!result || compare(result, next))) {
              result = next;
            }
          }
        }
        return result;
      },
      tick: function(dir, date2) {
        return new Date(dir === "next" ? tickConstraint.end(date2).getTime() + later2.SEC : tickConstraint.start(date2).getTime() - later2.SEC);
      },
      tickSafe: function(dir, date2) {
        return dir === "next" ? diffSecond(tickConstraint.end(date2), 1) : diffSecond(tickConstraint.start(date2), -1);
      },
      tickStart: function(date2) {
        return tickConstraint.start(date2);
      }
    };
  };
  later2.schedule = function(sched) {
    if (!sched)
      throw new Error("Missing schedule definition.");
    if (!sched.schedules)
      throw new Error("Definition must include at least one schedule.");
    var schedules = [], schedulesLen = sched.schedules.length, exceptions = [], exceptionsLen = sched.exceptions ? sched.exceptions.length : 0;
    for (var i = 0; i < schedulesLen; i++) {
      schedules.push(later2.compile(sched.schedules[i]));
    }
    for (var j = 0; j < exceptionsLen; j++) {
      exceptions.push(later2.compile(sched.exceptions[j]));
    }
    function getInstances(dir, count, startDate, endDate, isRange) {
      var compare = compareFn(dir), loopCount = count, maxAttempts = 1e6, schedStarts = [], exceptStarts = [], next, end, results = [], isForward = dir === "next", lastResult, rStart = isForward ? 0 : 1, rEnd = isForward ? 1 : 0;
      startDate = startDate ? new Date(startDate) : new Date();
      if (!startDate || !startDate.getTime())
        throw new Error("Invalid start date.");
      setNextStarts(dir, schedules, schedStarts, startDate);
      setRangeStarts(dir, exceptions, exceptStarts, startDate);
      while (maxAttempts-- && loopCount && (next = findNext(schedStarts, compare))) {
        if (endDate && compare(next, endDate)) {
          break;
        }
        if (exceptionsLen) {
          updateRangeStarts(dir, exceptions, exceptStarts, next);
          if (end = calcRangeOverlap(dir, exceptStarts, next)) {
            updateNextStarts(dir, schedules, schedStarts, end);
            continue;
          }
        }
        if (isRange) {
          var maxEndDate = calcMaxEndDate(exceptStarts, compare);
          end = calcEnd(dir, schedules, schedStarts, next, maxEndDate);
          var r = isForward ? [new Date(Math.max(startDate, next)), end ? new Date(endDate ? Math.min(end, endDate) : end) : void 0] : [end ? new Date(endDate ? Math.max(endDate, end.getTime() + later2.SEC) : end.getTime() + later2.SEC) : void 0, new Date(Math.min(startDate, next.getTime() + later2.SEC))];
          if (lastResult && r[rStart].getTime() === lastResult[rEnd].getTime()) {
            lastResult[rEnd] = r[rEnd];
            loopCount++;
          } else {
            lastResult = r;
            results.push(lastResult);
          }
          if (!end)
            break;
          updateNextStarts(dir, schedules, schedStarts, end);
        } else {
          results.push(isForward ? new Date(Math.max(startDate, next)) : getStart(schedules, schedStarts, next, endDate));
          tickStarts(dir, schedules, schedStarts, next);
        }
        loopCount--;
      }
      for (var i2 = 0, len = results.length; i2 < len; i2++) {
        var result = results[i2];
        results[i2] = Object.prototype.toString.call(result) === "[object Array]" ? [cleanDate(result[0]), cleanDate(result[1])] : cleanDate(result);
      }
      return results.length === 0 ? later2.NEVER : count === 1 ? results[0] : results;
    }
    function cleanDate(d) {
      if (d instanceof Date && !isNaN(d.valueOf())) {
        return new Date(d);
      }
      return void 0;
    }
    function setNextStarts(dir, schedArr, startsArr, startDate) {
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        startsArr[i2] = schedArr[i2].start(dir, startDate);
      }
    }
    function updateNextStarts(dir, schedArr, startsArr, startDate) {
      var compare = compareFn(dir);
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        if (startsArr[i2] && !compare(startsArr[i2], startDate)) {
          startsArr[i2] = schedArr[i2].start(dir, startDate);
        }
      }
    }
    function setRangeStarts(dir, schedArr, rangesArr, startDate) {
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        var nextStart = schedArr[i2].start(dir, startDate);
        if (!nextStart) {
          rangesArr[i2] = later2.NEVER;
        } else {
          rangesArr[i2] = [nextStart, schedArr[i2].end(dir, nextStart)];
        }
      }
    }
    function updateRangeStarts(dir, schedArr, rangesArr, startDate) {
      var compare = compareFn(dir);
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        if (rangesArr[i2] && !compare(rangesArr[i2][0], startDate)) {
          var nextStart = schedArr[i2].start(dir, startDate);
          if (!nextStart) {
            rangesArr[i2] = later2.NEVER;
          } else {
            rangesArr[i2] = [nextStart, schedArr[i2].end(dir, nextStart)];
          }
        }
      }
    }
    function tickStarts(dir, schedArr, startsArr, startDate) {
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        if (startsArr[i2] && startsArr[i2].getTime() === startDate.getTime()) {
          const newStart = schedArr[i2].start(dir, schedArr[i2].tick(dir, startDate));
          if (newStart !== later2.NEVER && newStart.getTime() === startsArr[i2].getTime()) {
            startsArr[i2] = schedArr[i2].start(dir, schedArr[i2].tickSafe(dir, startDate));
          } else {
            startsArr[i2] = newStart;
          }
        }
      }
    }
    function getStart(schedArr, startsArr, startDate, minEndDate) {
      var result;
      for (var i2 = 0, len = startsArr.length; i2 < len; i2++) {
        if (startsArr[i2] && startsArr[i2].getTime() === startDate.getTime()) {
          var start = schedArr[i2].tickStart(startDate);
          if (minEndDate && start < minEndDate) {
            return minEndDate;
          }
          if (!result || start > result) {
            result = start;
          }
        }
      }
      return result;
    }
    function calcRangeOverlap(dir, rangesArr, startDate) {
      var compare = compareFn(dir), result;
      for (var i2 = 0, len = rangesArr.length; i2 < len; i2++) {
        var range = rangesArr[i2];
        if (range && !compare(range[0], startDate) && (!range[1] || compare(range[1], startDate))) {
          if (!result || compare(range[1], result)) {
            result = range[1];
          }
        }
      }
      return result;
    }
    function calcMaxEndDate(exceptsArr, compare) {
      var result;
      for (var i2 = 0, len = exceptsArr.length; i2 < len; i2++) {
        if (exceptsArr[i2] && (!result || compare(result, exceptsArr[i2][0]))) {
          result = exceptsArr[i2][0];
        }
      }
      return result;
    }
    function calcEnd(dir, schedArr, startsArr, startDate, maxEndDate) {
      var compare = compareFn(dir), result;
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        var start = startsArr[i2];
        if (start && start.getTime() === startDate.getTime()) {
          var end = schedArr[i2].end(dir, start);
          if (maxEndDate && (!end || compare(end, maxEndDate))) {
            return maxEndDate;
          }
          if (!result || compare(end, result)) {
            result = end;
          }
        }
      }
      return result;
    }
    function compareFn(dir) {
      return dir === "next" ? function(a, b) {
        return !b || a.getTime() > b.getTime();
      } : function(a, b) {
        return !a || b.getTime() > a.getTime();
      };
    }
    function findNext(arr, compare) {
      var next = arr[0];
      for (var i2 = 1, len = arr.length; i2 < len; i2++) {
        if (arr[i2] && compare(next, arr[i2])) {
          next = arr[i2];
        }
      }
      return next;
    }
    return {
      isValid: function(d) {
        return getInstances("next", 1, d, d) !== later2.NEVER;
      },
      next: function(count, startDate, endDate) {
        return getInstances("next", count || 1, startDate, endDate);
      },
      prev: function(count, startDate, endDate) {
        return getInstances("prev", count || 1, startDate, endDate);
      },
      nextRange: function(count, startDate, endDate) {
        return getInstances("next", count || 1, startDate, endDate, true);
      },
      prevRange: function(count, startDate, endDate) {
        return getInstances("prev", count || 1, startDate, endDate, true);
      }
    };
  };
  later2.setTimeout = function(fn2, sched) {
    var s = later2.schedule(sched), t;
    if (fn2) {
      scheduleTimeout();
    }
    function scheduleTimeout() {
      var now2 = Date.now(), next = s.next(2, now2);
      if (!next[0]) {
        t = void 0;
        return;
      }
      var diff = next[0].getTime() - now2;
      if (diff < 1e3) {
        diff = next[1] ? next[1].getTime() - now2 : 1e3;
      }
      if (diff < 2147483647) {
        t = setTimeout(fn2, diff);
      } else {
        t = setTimeout(scheduleTimeout, 2147483647);
      }
    }
    return {
      isDone: function() {
        return !t;
      },
      clear: function() {
        clearTimeout(t);
      }
    };
  };
  later2.setInterval = function(fn2, sched) {
    if (!fn2) {
      return;
    }
    var t = later2.setTimeout(scheduleTimeout, sched), done = t.isDone();
    function scheduleTimeout() {
      if (!done) {
        fn2();
        t = later2.setTimeout(scheduleTimeout, sched);
      }
    }
    return {
      isDone: function() {
        return t.isDone();
      },
      clear: function() {
        done = true;
        t.clear();
      }
    };
  };
  later2.date = {};
  later2.date.timezone = function(useLocalTime) {
    later2.date.build = useLocalTime ? function(Y, M, D, h, m, s) {
      return new Date(Y, M, D, h, m, s);
    } : function(Y, M, D, h, m, s) {
      return new Date(Date.UTC(Y, M, D, h, m, s));
    };
    var get = useLocalTime ? "get" : "getUTC", d = Date.prototype;
    later2.date.getYear = d[get + "FullYear"];
    later2.date.getMonth = d[get + "Month"];
    later2.date.getDate = d[get + "Date"];
    later2.date.getDay = d[get + "Day"];
    later2.date.getHour = d[get + "Hours"];
    later2.date.getMin = d[get + "Minutes"];
    later2.date.getSec = d[get + "Seconds"];
    later2.date.isUTC = !useLocalTime;
  };
  later2.date.UTC = function() {
    later2.date.timezone(false);
  };
  later2.date.localTime = function() {
    later2.date.timezone(true);
  };
  later2.date.UTC();
  later2.SEC = 1e3;
  later2.MIN = later2.SEC * 60;
  later2.HOUR = later2.MIN * 60;
  later2.DAY = later2.HOUR * 24;
  later2.WEEK = later2.DAY * 7;
  later2.DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  later2.NEVER = 0;
  later2.date.next = function(Y, M, D, h, m, s) {
    return later2.date.build(Y, M !== void 0 ? M - 1 : 0, D !== void 0 ? D : 1, h || 0, m || 0, s || 0);
  };
  later2.date.nextRollover = function(d, val, constraint, period) {
    var cur = constraint.val(d), max = constraint.extent(d)[1];
    return (val || max) <= cur || val > max ? new Date(period.end(d).getTime() + later2.SEC) : period.start(d);
  };
  later2.date.prev = function(Y, M, D, h, m, s) {
    var len = arguments.length;
    M = len < 2 ? 11 : M - 1;
    D = len < 3 ? later2.D.extent(later2.date.next(Y, M + 1))[1] : D;
    h = len < 4 ? 23 : h;
    m = len < 5 ? 59 : m;
    s = len < 6 ? 59 : s;
    return later2.date.build(Y, M, D, h, m, s);
  };
  later2.date.prevRollover = function(d, val, constraint, period) {
    var cur = constraint.val(d);
    return val >= cur || !val ? period.start(period.prev(d, period.val(d) - 1)) : period.start(d);
  };
  later2.parse = {};
  later2.parse.cron = function(expr, hasSeconds) {
    var NAMES = {
      JAN: 1,
      FEB: 2,
      MAR: 3,
      APR: 4,
      MAY: 5,
      JUN: 6,
      JUL: 7,
      AUG: 8,
      SEP: 9,
      OCT: 10,
      NOV: 11,
      DEC: 12,
      SUN: 1,
      MON: 2,
      TUE: 3,
      WED: 4,
      THU: 5,
      FRI: 6,
      SAT: 7
    };
    var REPLACEMENTS = {
      "* * * * * *": "0/1 * * * * *",
      "@YEARLY": "0 0 1 1 *",
      "@ANNUALLY": "0 0 1 1 *",
      "@MONTHLY": "0 0 1 * *",
      "@WEEKLY": "0 0 * * 0",
      "@DAILY": "0 0 * * *",
      "@HOURLY": "0 * * * *"
    };
    var FIELDS = {
      s: [0, 0, 59],
      m: [1, 0, 59],
      h: [2, 0, 23],
      D: [3, 1, 31],
      M: [4, 1, 12],
      Y: [6, 1970, 2099],
      d: [5, 1, 7, 1]
    };
    function getValue(value, offset, max) {
      return isNaN(value) ? NAMES[value] || null : Math.min(+value + (offset || 0), max || 9999);
    }
    function cloneSchedule(sched) {
      var clone = {}, field;
      for (field in sched) {
        if (field !== "dc" && field !== "d") {
          clone[field] = sched[field].slice(0);
        }
      }
      return clone;
    }
    function add(sched, name, min2, max, inc) {
      var i = min2;
      if (!sched[name]) {
        sched[name] = [];
      }
      while (i <= max) {
        if (sched[name].indexOf(i) < 0) {
          sched[name].push(i);
        }
        i += inc || 1;
      }
      sched[name].sort(function(a, b) {
        return a - b;
      });
    }
    function addHash(schedules, curSched, value, hash) {
      if (curSched.d && !curSched.dc || curSched.dc && curSched.dc.indexOf(hash) < 0) {
        schedules.push(cloneSchedule(curSched));
        curSched = schedules[schedules.length - 1];
      }
      add(curSched, "d", value, value);
      add(curSched, "dc", hash, hash);
    }
    function addWeekday(s, curSched, value) {
      var except1 = {}, except2 = {};
      if (value === 1) {
        add(curSched, "D", 1, 3);
        add(curSched, "d", NAMES.MON, NAMES.FRI);
        add(except1, "D", 2, 2);
        add(except1, "d", NAMES.TUE, NAMES.FRI);
        add(except2, "D", 3, 3);
        add(except2, "d", NAMES.TUE, NAMES.FRI);
      } else {
        add(curSched, "D", value - 1, value + 1);
        add(curSched, "d", NAMES.MON, NAMES.FRI);
        add(except1, "D", value - 1, value - 1);
        add(except1, "d", NAMES.MON, NAMES.THU);
        add(except2, "D", value + 1, value + 1);
        add(except2, "d", NAMES.TUE, NAMES.FRI);
      }
      s.exceptions.push(except1);
      s.exceptions.push(except2);
    }
    function addRange(item, curSched, name, min2, max, offset) {
      var incSplit = item.split("/"), inc = +incSplit[1], range = incSplit[0];
      if (range !== "*" && range !== "0") {
        var rangeSplit = range.split("-");
        min2 = getValue(rangeSplit[0], offset, max);
        max = getValue(rangeSplit[1], offset, max) || max;
      }
      add(curSched, name, min2, max, inc);
    }
    function parse(item, s, name, min2, max, offset) {
      var value, split2, schedules = s.schedules, curSched = schedules[schedules.length - 1];
      if (item === "L") {
        item = min2 - 1;
      }
      if ((value = getValue(item, offset, max)) !== null) {
        add(curSched, name, value, value);
      } else if ((value = getValue(item.replace("W", ""), offset, max)) !== null) {
        addWeekday(s, curSched, value);
      } else if ((value = getValue(item.replace("L", ""), offset, max)) !== null) {
        addHash(schedules, curSched, value, min2 - 1);
      } else if ((split2 = item.split("#")).length === 2) {
        value = getValue(split2[0], offset, max);
        addHash(schedules, curSched, value, getValue(split2[1]));
      } else {
        addRange(item, curSched, name, min2, max, offset);
      }
    }
    function isHash(item) {
      return item.indexOf("#") > -1 || item.indexOf("L") > 0;
    }
    function itemSorter(a, b) {
      return isHash(a) && !isHash(b) ? 1 : a - b;
    }
    function parseExpr(expr2) {
      var schedule = {
        schedules: [{}],
        exceptions: []
      }, components = expr2.replace(/(\s)+/g, " ").split(" "), field, f, component, items2;
      for (field in FIELDS) {
        f = FIELDS[field];
        component = components[f[0]];
        if (component && component !== "*" && component !== "?") {
          items2 = component.split(",").sort(itemSorter);
          var i, length = items2.length;
          for (i = 0; i < length; i++) {
            parse(items2[i], schedule, field, f[1], f[2], f[3]);
          }
        }
      }
      return schedule;
    }
    function prepareExpr(expr2) {
      var prepared = expr2.toUpperCase();
      return REPLACEMENTS[prepared] || prepared;
    }
    var e = prepareExpr(expr);
    return parseExpr(hasSeconds ? e : "0 " + e);
  };
  later2.parse.recur = function() {
    var schedules = [], exceptions = [], cur, curArr = schedules, curName, values, every2, modifier, applyMin, applyMax, i, last;
    function add(name, min2, max) {
      name = modifier ? name + "_" + modifier : name;
      if (!cur) {
        curArr.push({});
        cur = curArr[0];
      }
      if (!cur[name]) {
        cur[name] = [];
      }
      curName = cur[name];
      if (every2) {
        values = [];
        for (i = min2; i <= max; i += every2) {
          values.push(i);
        }
        last = {
          n: name,
          x: every2,
          c: curName.length,
          m: max
        };
      }
      values = applyMin ? [min2] : applyMax ? [max] : values;
      var length = values.length;
      for (i = 0; i < length; i += 1) {
        var val = values[i];
        if (curName.indexOf(val) < 0) {
          curName.push(val);
        }
      }
      values = every2 = modifier = applyMin = applyMax = 0;
    }
    return {
      schedules,
      exceptions,
      on: function() {
        values = arguments[0] instanceof Array ? arguments[0] : arguments;
        return this;
      },
      every: function(x) {
        every2 = x || 1;
        return this;
      },
      after: function(x) {
        modifier = "a";
        values = [x];
        return this;
      },
      before: function(x) {
        modifier = "b";
        values = [x];
        return this;
      },
      first: function() {
        applyMin = 1;
        return this;
      },
      last: function() {
        applyMax = 1;
        return this;
      },
      time: function() {
        for (var i2 = 0, len = values.length; i2 < len; i2++) {
          var split2 = values[i2].split(":");
          if (split2.length < 3)
            split2.push(0);
          values[i2] = +split2[0] * 3600 + +split2[1] * 60 + +split2[2];
        }
        add("t");
        return this;
      },
      second: function() {
        add("s", 0, 59);
        return this;
      },
      minute: function() {
        add("m", 0, 59);
        return this;
      },
      hour: function() {
        add("h", 0, 23);
        return this;
      },
      dayOfMonth: function() {
        add("D", 1, applyMax ? 0 : 31);
        return this;
      },
      dayOfWeek: function() {
        add("d", 1, 7);
        return this;
      },
      onWeekend: function() {
        values = [1, 7];
        return this.dayOfWeek();
      },
      onWeekday: function() {
        values = [2, 3, 4, 5, 6];
        return this.dayOfWeek();
      },
      dayOfWeekCount: function() {
        add("dc", 1, applyMax ? 0 : 5);
        return this;
      },
      dayOfYear: function() {
        add("dy", 1, applyMax ? 0 : 366);
        return this;
      },
      weekOfMonth: function() {
        add("wm", 1, applyMax ? 0 : 5);
        return this;
      },
      weekOfYear: function() {
        add("wy", 1, applyMax ? 0 : 53);
        return this;
      },
      month: function() {
        add("M", 1, 12);
        return this;
      },
      year: function() {
        add("Y", 1970, 2450);
        return this;
      },
      fullDate: function() {
        for (var i2 = 0, len = values.length; i2 < len; i2++) {
          values[i2] = values[i2].getTime();
        }
        add("fd");
        return this;
      },
      customModifier: function(id, vals) {
        var custom = later2.modifier[id];
        if (!custom)
          throw new Error("Custom modifier " + id + " not recognized!");
        modifier = id;
        values = arguments[1] instanceof Array ? arguments[1] : [arguments[1]];
        return this;
      },
      customPeriod: function(id) {
        var custom = later2[id];
        if (!custom)
          throw new Error("Custom time period " + id + " not recognized!");
        add(id, custom.extent(new Date())[0], custom.extent(new Date())[1]);
        return this;
      },
      startingOn: function(start) {
        return this.between(start, last.m);
      },
      between: function(start, end) {
        cur[last.n] = cur[last.n].splice(0, last.c);
        every2 = last.x;
        add(last.n, start, end);
        return this;
      },
      and: function() {
        cur = curArr[curArr.push({}) - 1];
        return this;
      },
      except: function() {
        curArr = exceptions;
        cur = null;
        return this;
      }
    };
  };
  later2.parse.text = function(str) {
    var recur = later2.parse.recur, pos = 0, input = "", error;
    var TOKENTYPES = {
      eof: /^$/,
      fullDate: /^(\d\d\d\d-\d\d-\d\dt\d\d:\d\d:\d\d)\b/,
      rank: /^((\d\d\d\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\b/,
      time: /^((([0]?[1-9]|1[0-2]):[0-5]\d(\s)?(am|pm))|(([0]?\d|1\d|2[0-3]):[0-5]\d))\b/,
      dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\b/,
      monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\b/,
      yearIndex: /^(\d\d\d\d)\b/,
      every: /^every\b/,
      after: /^after\b/,
      before: /^before\b/,
      second: /^(s|sec(ond)?(s)?)\b/,
      minute: /^(m|min(ute)?(s)?)\b/,
      hour: /^(h|hour(s)?)\b/,
      day: /^(day(s)?( of the month)?)\b/,
      dayInstance: /^day instance\b/,
      dayOfWeek: /^day(s)? of the week\b/,
      dayOfYear: /^day(s)? of the year\b/,
      weekOfYear: /^week(s)?( of the year)?\b/,
      weekOfMonth: /^week(s)? of the month\b/,
      weekday: /^weekday\b/,
      weekend: /^weekend\b/,
      month: /^month(s)?\b/,
      year: /^year(s)?\b/,
      between: /^between (the)?\b/,
      start: /^(start(ing)? (at|on( the)?)?)\b/,
      at: /^(at|@)\b/,
      and: /^(,|and\b)/,
      except: /^(except\b)/,
      also: /(also)\b/,
      first: /^(first)\b/,
      last: /^last\b/,
      "in": /^in\b/,
      of: /^of\b/,
      onthe: /^on the\b/,
      on: /^on\b/,
      through: /(-|^(to|through)\b)/
    };
    var NAMES = {
      jan: 1,
      feb: 2,
      mar: 3,
      apr: 4,
      may: 5,
      jun: 6,
      jul: 7,
      aug: 8,
      sep: 9,
      oct: 10,
      nov: 11,
      dec: 12,
      sun: 1,
      mon: 2,
      tue: 3,
      wed: 4,
      thu: 5,
      fri: 6,
      sat: 7,
      "1st": 1,
      fir: 1,
      "2nd": 2,
      sec: 2,
      "3rd": 3,
      thi: 3,
      "4th": 4,
      "for": 4
    };
    function t(start, end, text, type) {
      return {
        startPos: start,
        endPos: end,
        text,
        type
      };
    }
    function peek(expected) {
      var scanTokens = expected instanceof Array ? expected : [expected], whiteSpace = /\s+/, token, curInput, m, scanToken, start, len;
      scanTokens.push(whiteSpace);
      start = pos;
      while (!token || token.type === whiteSpace) {
        len = -1;
        curInput = input.substring(start);
        token = t(start, start, input.split(whiteSpace)[0]);
        var i, length = scanTokens.length;
        for (i = 0; i < length; i++) {
          scanToken = scanTokens[i];
          m = scanToken.exec(curInput);
          if (m && m.index === 0 && m[0].length > len) {
            len = m[0].length;
            token = t(start, start + len, curInput.substring(0, len), scanToken);
          }
        }
        if (token.type === whiteSpace) {
          start = token.endPos;
        }
      }
      return token;
    }
    function scan(expectedToken) {
      var token = peek(expectedToken);
      pos = token.endPos;
      return token;
    }
    function parseThroughExpr(tokenType) {
      var start = +parseTokenValue(tokenType), end = checkAndParse(TOKENTYPES.through) ? +parseTokenValue(tokenType) : start, nums = [];
      for (var i = start; i <= end; i++) {
        nums.push(i);
      }
      return nums;
    }
    function parseRanges(tokenType) {
      var nums = parseThroughExpr(tokenType);
      while (checkAndParse(TOKENTYPES.and)) {
        nums = nums.concat(parseThroughExpr(tokenType));
      }
      return nums;
    }
    function parseEvery(r) {
      var num, period, start, end;
      if (checkAndParse(TOKENTYPES.weekend)) {
        r.on(NAMES.sun, NAMES.sat).dayOfWeek();
      } else if (checkAndParse(TOKENTYPES.weekday)) {
        r.on(NAMES.mon, NAMES.tue, NAMES.wed, NAMES.thu, NAMES.fri).dayOfWeek();
      } else {
        num = parseTokenValue(TOKENTYPES.rank);
        r.every(num);
        period = parseTimePeriod(r);
        if (checkAndParse(TOKENTYPES.start)) {
          num = parseTokenValue(TOKENTYPES.rank);
          r.startingOn(num);
          parseToken(period.type);
        } else if (checkAndParse(TOKENTYPES.between)) {
          start = parseTokenValue(TOKENTYPES.rank);
          if (checkAndParse(TOKENTYPES.and)) {
            end = parseTokenValue(TOKENTYPES.rank);
            r.between(start, end);
          }
        }
      }
    }
    function parseOnThe(r) {
      if (checkAndParse(TOKENTYPES.first)) {
        r.first();
      } else if (checkAndParse(TOKENTYPES.last)) {
        r.last();
      } else {
        r.on(parseRanges(TOKENTYPES.rank));
      }
      parseTimePeriod(r);
    }
    function parseScheduleExpr(str2) {
      pos = 0;
      input = str2;
      error = -1;
      var r = recur();
      while (pos < input.length && error < 0) {
        var token = parseToken([TOKENTYPES.every, TOKENTYPES.after, TOKENTYPES.before, TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES["in"], TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except, TOKENTYPES.also]);
        switch (token.type) {
          case TOKENTYPES.every:
            parseEvery(r);
            break;
          case TOKENTYPES.after:
            if (peek(TOKENTYPES.time).type !== void 0) {
              r.after(parseTokenValue(TOKENTYPES.time));
              r.time();
            } else if (peek(TOKENTYPES.fullDate).type !== void 0) {
              r.after(parseTokenValue(TOKENTYPES.fullDate));
              r.fullDate();
            } else {
              r.after(parseTokenValue(TOKENTYPES.rank));
              parseTimePeriod(r);
            }
            break;
          case TOKENTYPES.before:
            if (peek(TOKENTYPES.time).type !== void 0) {
              r.before(parseTokenValue(TOKENTYPES.time));
              r.time();
            } else if (peek(TOKENTYPES.fullDate).type !== void 0) {
              r.before(parseTokenValue(TOKENTYPES.fullDate));
              r.fullDate();
            } else {
              r.before(parseTokenValue(TOKENTYPES.rank));
              parseTimePeriod(r);
            }
            break;
          case TOKENTYPES.onthe:
            parseOnThe(r);
            break;
          case TOKENTYPES.on:
            r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();
            break;
          case TOKENTYPES.of:
            r.on(parseRanges(TOKENTYPES.monthName)).month();
            break;
          case TOKENTYPES["in"]:
            r.on(parseRanges(TOKENTYPES.yearIndex)).year();
            break;
          case TOKENTYPES.at:
            r.on(parseTokenValue(TOKENTYPES.time)).time();
            while (checkAndParse(TOKENTYPES.and)) {
              r.on(parseTokenValue(TOKENTYPES.time)).time();
            }
            break;
          case TOKENTYPES.and:
            break;
          case TOKENTYPES.also:
            r.and();
            break;
          case TOKENTYPES.except:
            r.except();
            break;
          default:
            error = pos;
        }
      }
      return {
        schedules: r.schedules,
        exceptions: r.exceptions,
        error
      };
    }
    function parseTimePeriod(r) {
      var timePeriod = parseToken([TOKENTYPES.second, TOKENTYPES.minute, TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek, TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month, TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear]);
      switch (timePeriod.type) {
        case TOKENTYPES.second:
          r.second();
          break;
        case TOKENTYPES.minute:
          r.minute();
          break;
        case TOKENTYPES.hour:
          r.hour();
          break;
        case TOKENTYPES.dayOfYear:
          r.dayOfYear();
          break;
        case TOKENTYPES.dayOfWeek:
          r.dayOfWeek();
          break;
        case TOKENTYPES.dayInstance:
          r.dayOfWeekCount();
          break;
        case TOKENTYPES.day:
          r.dayOfMonth();
          break;
        case TOKENTYPES.weekOfMonth:
          r.weekOfMonth();
          break;
        case TOKENTYPES.weekOfYear:
          r.weekOfYear();
          break;
        case TOKENTYPES.month:
          r.month();
          break;
        case TOKENTYPES.year:
          r.year();
          break;
        default:
          error = pos;
      }
      return timePeriod;
    }
    function checkAndParse(tokenType) {
      var found = peek(tokenType).type === tokenType;
      if (found) {
        scan(tokenType);
      }
      return found;
    }
    function parseToken(tokenType) {
      var t2 = scan(tokenType);
      if (t2.type) {
        t2.text = convertString(t2.text, tokenType);
      } else {
        error = pos;
      }
      return t2;
    }
    function parseTokenValue(tokenType) {
      return parseToken(tokenType).text;
    }
    function convertString(str2, tokenType) {
      var output = str2;
      switch (tokenType) {
        case TOKENTYPES.time:
          var parts = str2.split(/(:|am|pm)/), hour2 = parts[3] === "pm" && parts[0] < 12 ? parseInt(parts[0], 10) + 12 : parts[0], min2 = parts[2].trim();
          output = (hour2.length === 1 ? "0" : "") + hour2 + ":" + min2;
          break;
        case TOKENTYPES.rank:
          output = parseInt(/^\d+/.exec(str2)[0], 10);
          break;
        case TOKENTYPES.monthName:
        case TOKENTYPES.dayName:
          output = NAMES[str2.substring(0, 3)];
          break;
        case TOKENTYPES.fullDate:
          output = new Date(str2.toUpperCase());
          break;
      }
      return output;
    }
    return parseScheduleExpr(str.toLowerCase());
  };
  return later2;
}();
later.date.localTime();
function split(iterable) {
  const gen1Pending = [];
  const gen2Pending = [];
  let iterator;
  const gen1 = function* () {
    if (!iterator)
      iterator = iterable[Symbol.iterator]();
    while (true) {
      if (gen1Pending.length) {
        yield* gen1Pending;
        gen1Pending.length = 0;
      }
      if (!iterator)
        break;
      const {
        value,
        done
      } = iterator.next();
      if (done) {
        iterator = null;
        iterable = null;
        break;
      }
      gen2Pending.push(value);
      yield value;
    }
  };
  const gen2 = function* () {
    if (!iterator)
      iterator = iterable[Symbol.iterator]();
    while (true) {
      if (gen2Pending.length) {
        yield* gen2Pending;
        gen2Pending.length = 0;
      }
      if (!iterator)
        break;
      const {
        value,
        done
      } = iterator.next();
      if (done) {
        iterator = null;
        iterable = null;
        break;
      }
      gen1Pending.push(value);
      yield value;
    }
  };
  return [gen1(), gen2()];
}
function* inBatchesBySize(iterator, batchSize) {
  if (batchSize < 0)
    throw new Error("Batch size needs to a natural number");
  batchSize = batchSize | 0;
  const runningBatch = [];
  for (const el of iterator) {
    if (runningBatch.length === batchSize) {
      yield runningBatch;
      runningBatch.length = 0;
    }
    runningBatch.push(el);
  }
  if (runningBatch.length > 0)
    yield runningBatch;
}
function* filter(iterator, func) {
  let i = 0;
  for (const el of iterator) {
    if (func(el, i++))
      yield el;
  }
}
function* drop(iterator, howMany) {
  let i = 0;
  for (const el of iterator) {
    if (++i > howMany)
      yield el;
  }
}
function every(iterator, func) {
  let i = 0;
  for (const el of iterator) {
    if (!func(el, i++))
      return false;
  }
  return true;
}
function some(iterator, func) {
  let i = 0;
  for (const el of iterator) {
    if (func(el, i++))
      return true;
  }
  return false;
}
function* map(iterator, func) {
  let i = 0;
  for (const el of iterator)
    yield func(el, i++);
}
function reduce(iterator, func, initialAcc) {
  let i = 0;
  let acc = initialAcc;
  for (const el of iterator) {
    acc = func(acc, el, i++);
  }
  return acc;
}
function* uniqueOnly(iterator) {
  const seen = /* @__PURE__ */ new Set();
  for (const el of iterator) {
    if (!seen.has(el)) {
      seen.add(el);
      yield el;
    }
  }
}
function* uniqueOnlyBy(iterator, func) {
  const seen = /* @__PURE__ */ new Set();
  for (const el of iterator) {
    const uniqueBy = func(el);
    if (!seen.has(uniqueBy)) {
      seen.add(uniqueBy);
      yield el;
    }
  }
}
function* takeWhile(iterator, func) {
  let i = 0;
  for (const el of iterator) {
    if (func(el, i++))
      yield el;
    else
      return;
  }
}
function* concatIterable(iteratorsProducer) {
  for (const iterator of iteratorsProducer)
    yield* iterator;
}
var ChainedIteratorClass = class {
  constructor(iterable) {
    this.iterable = void 0;
    if (!iterable)
      throw new Error("Require an iterable instance for chaining");
    this.iterable = iterable;
  }
  derive(iterable) {
    this.iterable = void 0;
    return new ChainedIteratorClass(iterable);
  }
  copy() {
    const [iter1, iter2] = split(this.iterable);
    this.iterable = iter2;
    return new ChainedIteratorClass(iter1);
  }
  split() {
    const [iter1, iter2] = split(this.iterable);
    return [new ChainedIteratorClass(iter1), this.derive(iter2)];
  }
  inBatchesBySize(batchSize) {
    return this.derive(inBatchesBySize(this.iterable, batchSize));
  }
  filter(func) {
    return this.derive(filter(this.iterable, func));
  }
  drop(howMany) {
    return this.derive(drop(this.iterable, howMany));
  }
  map(func) {
    return this.derive(map(this.iterable, func));
  }
  reduce(func, initialAcc) {
    return reduce(this, func, initialAcc);
  }
  concat() {
    return this.derive(concatIterable(this.iterable));
  }
  uniqueOnly() {
    return this.derive(uniqueOnly(this.iterable));
  }
  uniqueOnlyBy(func) {
    return this.derive(uniqueOnlyBy(this.iterable, func));
  }
  every(func) {
    return every(this, func);
  }
  some(func) {
    return some(this, func);
  }
  takeWhile(func) {
    return this.derive(takeWhile(this.iterable, func));
  }
  *[Symbol.iterator]() {
    let iterable = this.iterable;
    if (!iterable)
      throw new Error("Chained iterator already exhausted or used to derive the new one");
    this.iterable = void 0;
    yield* iterable;
    iterable = void 0;
  }
  toArray() {
    return Array.from(this);
  }
  sort(order) {
    return Array.from(this).sort(order);
  }
  toSet() {
    return new Set(this);
  }
  toMap() {
    return new Map(this);
  }
  flush() {
    for (const element of this) {
    }
  }
  memoize() {
    return new MemoizedIteratorClass(this);
  }
};
var ChainedIterator = (iterator) => new ChainedIteratorClass(iterator);
var CI = ChainedIterator;
var MemoizedIteratorClass = class extends ChainedIteratorClass {
  constructor() {
    super(...arguments);
    this.elements = [];
    this.$iterator = void 0;
  }
  set iterable(iterable) {
    this.$iterable = iterable;
  }
  get iterable() {
    return this;
  }
  derive(iterable) {
    return new ChainedIteratorClass(iterable);
  }
  *[Symbol.iterator]() {
    const elements = this.elements;
    if (this.$iterable) {
      if (!this.$iterator)
        this.$iterator = this.$iterable[Symbol.iterator]();
      let iterator = this.$iterator;
      let alreadyConsumed = elements.length;
      if (alreadyConsumed > 0)
        yield* elements;
      while (true) {
        if (elements.length > alreadyConsumed) {
          for (let i = alreadyConsumed; i < elements.length; i++)
            yield elements[i];
          alreadyConsumed = elements.length;
        }
        if (!iterator)
          break;
        const {
          value,
          done
        } = iterator.next();
        if (done) {
          iterator = this.$iterator = null;
          this.$iterable = null;
        } else {
          elements.push(value);
          alreadyConsumed++;
          yield value;
        }
      }
    } else {
      yield* elements;
    }
  }
};
var MemoizedIterator = (iterator) => new MemoizedIteratorClass(iterator);
var MI = MemoizedIterator;
var MixinInstanceOfProperty = Symbol("MixinIdentity");
var MixinStateProperty = Symbol("MixinStateProperty");
var MixinWalkDepthState = class {
  constructor() {
    this.baseEl = void 0;
    this.sourceEl = void 0;
    this.$elementsByTopoLevel = void 0;
    this.$topoLevels = void 0;
    this.linearizedByTopoLevelsSource = MI(this.linearizedByTopoLevels());
  }
  static new(props) {
    const me = new this();
    props && Object.assign(me, props);
    return me;
  }
  get topoLevels() {
    if (this.$topoLevels !== void 0)
      return this.$topoLevels;
    return this.$topoLevels = this.buildTopoLevels();
  }
  buildTopoLevels() {
    return Array.from(this.elementsByTopoLevel.keys()).sort((level1, level2) => level1 - level2);
  }
  get elementsByTopoLevel() {
    if (this.$elementsByTopoLevel !== void 0)
      return this.$elementsByTopoLevel;
    return this.$elementsByTopoLevel = this.buildElementsByTopoLevel();
  }
  getOrCreateLevel(map2, topoLevel) {
    let elementsAtLevel = map2.get(topoLevel);
    if (!elementsAtLevel) {
      elementsAtLevel = [];
      map2.set(topoLevel, elementsAtLevel);
    }
    return elementsAtLevel;
  }
  buildElementsByTopoLevel() {
    let maxTopoLevel = 0;
    const baseElements = this.baseEl ? CI(this.baseEl.walkDepthState.elementsByTopoLevel.values()).concat().toSet() : /* @__PURE__ */ new Set();
    const map2 = CI(this.sourceEl.requirements).map((mixin2) => mixin2.walkDepthState.elementsByTopoLevel).concat().reduce((elementsByTopoLevel, [topoLevel, mixins]) => {
      if (topoLevel > maxTopoLevel)
        maxTopoLevel = topoLevel;
      this.getOrCreateLevel(elementsByTopoLevel, topoLevel).push(mixins);
      return elementsByTopoLevel;
    }, /* @__PURE__ */ new Map());
    this.getOrCreateLevel(map2, maxTopoLevel + 1).push([this.sourceEl]);
    return CI(map2).map(([level, elements]) => {
      return [level, CI(elements).concat().uniqueOnly().filter((mixin2) => !baseElements.has(mixin2)).sort((mixin1, mixin2) => mixin1.id - mixin2.id)];
    }).toMap();
  }
  *linearizedByTopoLevels() {
    yield* CI(this.topoLevels).map((level) => this.elementsByTopoLevel.get(level)).concat();
  }
};
var MIXIN_ID = 1;
var identity = (a) => class extends a {
};
var ZeroBaseClass = class {
};
var MixinState = class {
  constructor() {
    this.id = MIXIN_ID++;
    this.requirements = [];
    this.baseClass = ZeroBaseClass;
    this.identitySymbol = void 0;
    this.mixinLambda = identity;
    this.walkDepthState = void 0;
    this.$minimalClass = void 0;
    this.name = "";
  }
  static new(props) {
    const me = new this();
    props && Object.assign(me, props);
    me.walkDepthState = MixinWalkDepthState.new({
      sourceEl: me,
      baseEl: getMixinState(me.baseClass)
    });
    const mixinLambda = me.mixinLambda;
    const symbol = me.identitySymbol = Symbol(mixinLambda.name);
    const mixinLambdaWrapper = Object.assign(function(base) {
      const extendedClass = mixinLambda(base);
      extendedClass.prototype[symbol] = true;
      return extendedClass;
    }, {
      [MixinInstanceOfProperty]: symbol,
      [MixinStateProperty]: me
    });
    Object.defineProperty(mixinLambdaWrapper, Symbol.hasInstance, {
      value: isInstanceOfStatic
    });
    me.mixinLambda = mixinLambdaWrapper;
    return me;
  }
  get minimalClass() {
    if (this.$minimalClass !== void 0)
      return this.$minimalClass;
    return this.$minimalClass = this.buildMinimalClass();
  }
  getBaseClassMixinId(baseClass) {
    const constructor = this.constructor;
    const mixinId = constructor.baseClassesIds.get(baseClass);
    if (mixinId !== void 0)
      return mixinId;
    const newId = MIXIN_ID++;
    constructor.baseClassesIds.set(baseClass, newId);
    return newId;
  }
  buildMinimalClass() {
    const self2 = this.constructor;
    let baseCls = this.baseClass;
    const minimalClassConstructor = this.walkDepthState.linearizedByTopoLevelsSource.reduce((acc, mixin2) => {
      const {
        cls,
        hash
      } = acc;
      const nextHash = hash + String.fromCharCode(mixin2.id);
      let wrapperCls = self2.minimalClassesByLinearHash.get(nextHash);
      if (!wrapperCls) {
        wrapperCls = mixin2.mixinLambda(cls);
        mixin2.name = wrapperCls.name;
        self2.minimalClassesByLinearHash.set(nextHash, wrapperCls);
      }
      acc.cls = wrapperCls;
      acc.hash = nextHash;
      return acc;
    }, {
      cls: baseCls,
      hash: String.fromCharCode(this.getBaseClassMixinId(baseCls))
    }).cls;
    const minimalClass = Object.assign(minimalClassConstructor, {
      [MixinInstanceOfProperty]: this.identitySymbol,
      [MixinStateProperty]: this,
      mix: this.mixinLambda,
      derive: (base) => Mixin([minimalClass, base], (base2) => class extends base2 {
      }),
      $: this,
      toString: this.toString.bind(this)
    });
    Object.defineProperty(minimalClass, Symbol.hasInstance, {
      value: isInstanceOfStatic
    });
    return minimalClass;
  }
  toString() {
    return this.walkDepthState.linearizedByTopoLevelsSource.reduce((acc, mixin2) => `${mixin2.name}(${acc})`, this.baseClass.name);
  }
};
MixinState.minimalClassesByLinearHash = /* @__PURE__ */ new Map();
MixinState.baseClassesIds = /* @__PURE__ */ new Map();
var isMixinClass = (func) => {
  return Object.getPrototypeOf(func.prototype).constructor.hasOwnProperty(MixinStateProperty);
};
var getMixinState = (func) => {
  return Object.getPrototypeOf(func.prototype).constructor[MixinStateProperty];
};
var mixin = (required, mixinLambda) => {
  let baseClass;
  if (required.length > 0) {
    const lastRequirement = required[required.length - 1];
    if (!isMixinClass(lastRequirement) && lastRequirement !== ZeroBaseClass)
      baseClass = lastRequirement;
  }
  const requirements = [];
  required.forEach((requirement, index) => {
    const mixinState2 = requirement[MixinStateProperty];
    if (mixinState2 !== void 0) {
      const currentBaseClass = mixinState2.baseClass;
      if (currentBaseClass !== ZeroBaseClass) {
        if (baseClass) {
          if (baseClass !== currentBaseClass) {
            const currentIsSub = currentBaseClass.prototype.isPrototypeOf(baseClass.prototype);
            const currentIsSuper = baseClass.prototype.isPrototypeOf(currentBaseClass.prototype);
            if (!currentIsSub && !currentIsSuper)
              throw new Error("Base class mismatch");
            baseClass = currentIsSuper ? currentBaseClass : baseClass;
          }
        } else
          baseClass = currentBaseClass;
      }
      requirements.push(mixinState2);
    } else {
      if (index !== required.length - 1)
        throw new Error("Base class should be provided as the last element of the requirements array");
    }
  });
  const mixinState = MixinState.new({
    requirements,
    mixinLambda,
    baseClass: baseClass || ZeroBaseClass
  });
  return mixinState.minimalClass;
};
var isInstanceOfStatic = function(instance) {
  return Boolean(instance && instance[this[MixinInstanceOfProperty]]);
};
var isInstanceOf = (instance, func) => {
  return Boolean(instance && instance[func[MixinInstanceOfProperty]]);
};
var Mixin = mixin;
var Base = class {
  initialize(props) {
    props && Object.assign(this, props);
  }
  static new(props) {
    const instance = new this();
    instance.initialize(props);
    return instance;
  }
};
var TimeUnit;
(function(TimeUnit2) {
  TimeUnit2["Millisecond"] = "millisecond";
  TimeUnit2["Second"] = "second";
  TimeUnit2["Minute"] = "minute";
  TimeUnit2["Hour"] = "hour";
  TimeUnit2["Day"] = "day";
  TimeUnit2["Week"] = "week";
  TimeUnit2["Month"] = "month";
  TimeUnit2["Quarter"] = "quarter";
  TimeUnit2["Year"] = "year";
})(TimeUnit || (TimeUnit = {}));
var ConstraintType;
(function(ConstraintType2) {
  ConstraintType2["MustStartOn"] = "muststarton";
  ConstraintType2["MustFinishOn"] = "mustfinishon";
  ConstraintType2["StartNoEarlierThan"] = "startnoearlierthan";
  ConstraintType2["StartNoLaterThan"] = "startnolaterthan";
  ConstraintType2["FinishNoEarlierThan"] = "finishnoearlierthan";
  ConstraintType2["FinishNoLaterThan"] = "finishnolaterthan";
})(ConstraintType || (ConstraintType = {}));
var SchedulingMode;
(function(SchedulingMode2) {
  SchedulingMode2["Normal"] = "Normal";
  SchedulingMode2["FixedDuration"] = "FixedDuration";
  SchedulingMode2["FixedEffort"] = "FixedEffort";
  SchedulingMode2["FixedUnits"] = "FixedUnits";
})(SchedulingMode || (SchedulingMode = {}));
var DependencyValidationResult;
(function(DependencyValidationResult2) {
  DependencyValidationResult2[DependencyValidationResult2["NoError"] = 0] = "NoError";
  DependencyValidationResult2[DependencyValidationResult2["CyclicDependency"] = 1] = "CyclicDependency";
  DependencyValidationResult2[DependencyValidationResult2["DuplicatingDependency"] = 2] = "DuplicatingDependency";
})(DependencyValidationResult || (DependencyValidationResult = {}));
var DependencyType;
(function(DependencyType2) {
  DependencyType2[DependencyType2["StartToStart"] = 0] = "StartToStart";
  DependencyType2[DependencyType2["StartToEnd"] = 1] = "StartToEnd";
  DependencyType2[DependencyType2["EndToStart"] = 2] = "EndToStart";
  DependencyType2[DependencyType2["EndToEnd"] = 3] = "EndToEnd";
})(DependencyType || (DependencyType = {}));
var DependenciesCalendar;
(function(DependenciesCalendar2) {
  DependenciesCalendar2["Project"] = "Project";
  DependenciesCalendar2["FromEvent"] = "FromEvent";
  DependenciesCalendar2["ToEvent"] = "ToEvent";
})(DependenciesCalendar || (DependenciesCalendar = {}));
var ProjectType;
(function(ProjectType2) {
  ProjectType2[ProjectType2["SchedulerBasic"] = 1] = "SchedulerBasic";
  ProjectType2[ProjectType2["SchedulerPro"] = 2] = "SchedulerPro";
  ProjectType2[ProjectType2["Gantt"] = 3] = "Gantt";
})(ProjectType || (ProjectType = {}));
var Direction;
(function(Direction2) {
  Direction2["Forward"] = "Forward";
  Direction2["Backward"] = "Backward";
  Direction2["None"] = "None";
})(Direction || (Direction = {}));
var ConstraintIntervalSide;
(function(ConstraintIntervalSide2) {
  ConstraintIntervalSide2["Start"] = "Start";
  ConstraintIntervalSide2["End"] = "End";
})(ConstraintIntervalSide || (ConstraintIntervalSide = {}));
var MIN_DATE = new Date(-864e13);
var MAX_DATE = new Date(864e13);
var isDateFinite = (date2) => {
  if (!date2)
    return false;
  const time = date2.getTime();
  return time !== MIN_DATE.getTime() && time !== MAX_DATE.getTime();
};
var EdgeInclusion;
(function(EdgeInclusion2) {
  EdgeInclusion2[EdgeInclusion2["Left"] = 0] = "Left";
  EdgeInclusion2[EdgeInclusion2["Right"] = 1] = "Right";
})(EdgeInclusion || (EdgeInclusion = {}));
var CalendarIteratorResult;
(function(CalendarIteratorResult2) {
  CalendarIteratorResult2[CalendarIteratorResult2["FullRangeIterated"] = 0] = "FullRangeIterated";
  CalendarIteratorResult2[CalendarIteratorResult2["StoppedByIterator"] = 1] = "StoppedByIterator";
  CalendarIteratorResult2[CalendarIteratorResult2["MaxCacheExtendCyclesReached"] = 2] = "MaxCacheExtendCyclesReached";
  CalendarIteratorResult2[CalendarIteratorResult2["MaxRangeReached"] = 3] = "MaxRangeReached";
})(CalendarIteratorResult || (CalendarIteratorResult = {}));
var CalendarCache = class {
  constructor(config) {
    this.cacheFilledStartDate = MAX_DATE;
    this.cacheFilledEndDate = MIN_DATE;
    this.intervalsCachingChunkDuration = 30;
    this.intervalsCachingChunkUnit = TimeUnit.Day;
    this.maxCacheExtendCycles = 1e3;
    this.maxRange = 5 * 365 * 24 * 60 * 60 * 1e3;
    config && Object.assign(this, config);
  }
  includeWrappingRangeFrom(cache, startDate, endDate) {
    cache.ensureCacheFilledForInterval(startDate, endDate);
    this.intervalCache.includeWrappingRange(cache.intervalCache, startDate, endDate);
  }
  ensureCacheFilledForInterval(startDate, endDate) {
    const cacheFilledStartDateN = this.cacheFilledStartDate.getTime();
    const cacheFilledEndDateN = this.cacheFilledEndDate.getTime();
    if (cacheFilledStartDateN !== MAX_DATE.getTime()) {
      const startDateN = startDate.getTime();
      const endDateN = endDate.getTime();
      if (cacheFilledStartDateN <= startDateN && endDateN <= cacheFilledEndDateN)
        return;
      if (endDateN <= cacheFilledStartDateN) {
        endDate = new Date(cacheFilledStartDateN - 1);
      } else if (startDateN >= cacheFilledEndDateN) {
        startDate = new Date(cacheFilledEndDateN + 1);
      } else if (cacheFilledStartDateN <= startDateN && startDateN <= cacheFilledEndDateN) {
        startDate = new Date(cacheFilledEndDateN + 1);
      } else if (cacheFilledStartDateN <= endDateN && endDateN <= cacheFilledEndDateN) {
        endDate = new Date(cacheFilledStartDateN - 1);
      } else {
        this.ensureCacheFilledForInterval(startDate, new Date(cacheFilledStartDateN - 1));
        this.ensureCacheFilledForInterval(new Date(cacheFilledEndDateN + 1), endDate);
        return;
      }
    }
    if (cacheFilledStartDateN === MAX_DATE.getTime() || startDate.getTime() < cacheFilledEndDateN) {
      this.cacheFilledStartDate = startDate;
    }
    if (cacheFilledEndDateN === MIN_DATE.getTime() || cacheFilledEndDateN < endDate.getTime()) {
      this.cacheFilledEndDate = endDate;
    }
    this.fillCache(startDate, endDate);
  }
  fillCache(_1, _2) {
    throw new Error("Abstract method");
  }
  clear() {
    this.cacheFilledStartDate = MAX_DATE;
    this.cacheFilledEndDate = MIN_DATE;
    this.intervalCache.clear();
  }
  forEachAvailabilityInterval(options, func, scope) {
    var _options$maxRange;
    scope = scope || this;
    const startDate = options.startDate;
    const endDate = options.endDate;
    const startDateN = startDate && startDate.getTime();
    const endDateN = endDate && endDate.getTime();
    const maxRange = (_options$maxRange = options.maxRange) !== null && _options$maxRange !== void 0 ? _options$maxRange : this.maxRange;
    const isForward = options.isForward !== false;
    if (isForward ? !startDate : !endDate) {
      throw new Error("At least `startDate` or `endDate` is required, depending from the `isForward` option");
    }
    const intervalCache = this.intervalCache;
    let cacheCursorDate = isForward ? startDate : endDate;
    let cursorDate = isForward ? startDate : endDate;
    const rangeStart = cursorDate.getTime();
    for (let cycle = 1; cycle < this.maxCacheExtendCycles; cycle++) {
      if (isForward) {
        this.ensureCacheFilledForInterval(cacheCursorDate, endDate || DateHelper.add(cacheCursorDate, this.intervalsCachingChunkDuration, this.intervalsCachingChunkUnit));
      } else {
        this.ensureCacheFilledForInterval(startDate || DateHelper.add(cacheCursorDate, -this.intervalsCachingChunkDuration, this.intervalsCachingChunkUnit), cacheCursorDate);
      }
      let interval = intervalCache.getIntervalOf(cursorDate, isForward ? EdgeInclusion.Left : EdgeInclusion.Right);
      while (interval) {
        const intervalStartDate = interval.startDate;
        const intervalEndDate = interval.endDate;
        if (isForward && endDateN && intervalStartDate.getTime() >= endDateN || !isForward && startDateN && intervalEndDate.getTime() <= startDateN) {
          return CalendarIteratorResult.FullRangeIterated;
        }
        if (isForward && intervalStartDate.getTime() - rangeStart >= maxRange || !isForward && rangeStart - intervalEndDate.getTime() >= maxRange) {
          return CalendarIteratorResult.MaxRangeReached;
        }
        if (isForward && intervalStartDate.getTime() > this.cacheFilledEndDate.getTime() || !isForward && intervalEndDate.getTime() < this.cacheFilledStartDate.getTime()) {
          break;
        }
        cursorDate = isForward ? intervalEndDate : intervalStartDate;
        const countFrom = startDateN && intervalStartDate.getTime() < startDateN ? startDate : intervalStartDate;
        const countTill = endDateN && intervalEndDate.getTime() > endDateN ? endDate : intervalEndDate;
        if (func.call(scope, countFrom, countTill, interval.cacheInterval) === false) {
          return CalendarIteratorResult.StoppedByIterator;
        }
        interval = isForward ? intervalCache.getNextInterval(interval) : intervalCache.getPrevInterval(interval);
      }
      if (isForward && cursorDate.getTime() === MAX_DATE.getTime() || !isForward && cursorDate.getTime() === MIN_DATE.getTime()) {
        return CalendarIteratorResult.FullRangeIterated;
      }
      cacheCursorDate = isForward ? this.cacheFilledEndDate : this.cacheFilledStartDate;
    }
    return CalendarIteratorResult.MaxCacheExtendCyclesReached;
  }
};
var stripDuplicates = (array) => Array.from(new Set(array));
var CalendarCacheInterval = class {
  constructor(config) {
    this.intervals = [];
    config && Object.assign(this, config);
    if (!this.calendar)
      throw new Error("Required attribute `calendar` is missing");
  }
  includeInterval(interval) {
    if (this.intervals.indexOf(interval) == -1) {
      const copy = this.intervals.slice();
      copy.push(interval);
      return new CalendarCacheInterval({
        intervals: copy,
        calendar: this.calendar
      });
    } else
      return this;
  }
  combineWith(interval) {
    return new CalendarCacheInterval({
      intervals: this.intervals.concat(interval.intervals),
      calendar: this.calendar
    });
  }
  getIsWorking() {
    if (this.isWorking != null)
      return this.isWorking;
    const intervals = this.intervals = this.normalizeIntervals(this.intervals);
    return this.isWorking = intervals[0].isWorking;
  }
  normalizeIntervals(intervals) {
    const filtered = stripDuplicates(intervals);
    filtered.sort((interval1, interval2) => interval2.getPriorityField() - interval1.getPriorityField());
    return filtered;
  }
};
var CalendarCacheIntervalMultiple = class {
  constructor(config) {
    this.intervalGroups = [];
    config && Object.assign(this, config);
  }
  combineWith(interval) {
    const copy = this.intervalGroups.slice();
    copy.push([interval.calendar, interval]);
    return new CalendarCacheIntervalMultiple({
      intervalGroups: copy
    });
  }
  getIsWorkingForEvery() {
    if (this.isWorkingForEvery != null)
      return this.isWorkingForEvery;
    for (let [_calendar, intervals] of this.getGroups()) {
      if (!intervals[0].isWorking)
        return this.isWorkingForEvery = false;
    }
    return this.isWorkingForEvery = true;
  }
  getIsWorkingForSome() {
    if (this.isWorkingForSome != null)
      return this.isWorkingForSome;
    for (let [_calendar, intervals] of this.getGroups()) {
      if (intervals[0].isWorking)
        return this.isWorkingForSome = true;
    }
    return this.isWorkingForSome = false;
  }
  getCalendars() {
    this.getGroups();
    return this.calendars;
  }
  isCalendarWorking(calendar) {
    return this.getCalendarsWorkStatus().get(calendar);
  }
  getCalendarsWorkStatus() {
    if (this.calendarsWorkStatus)
      return this.calendarsWorkStatus;
    const res = /* @__PURE__ */ new Map();
    for (let [calendar, intervals] of this.getGroups()) {
      res.set(calendar, intervals[0].isWorking);
    }
    return this.calendarsWorkStatus = res;
  }
  getCalendarsWorking() {
    if (this.calendarsWorking)
      return this.calendarsWorking;
    const calendars = [];
    for (let [calendar, intervals] of this.getGroups()) {
      if (intervals[0].isWorking)
        calendars.push(calendar);
    }
    return this.calendarsWorking = calendars;
  }
  getCalendarsNonWorking() {
    if (this.calendarsNonWorking)
      return this.calendarsNonWorking;
    const calendars = [];
    for (let [calendar, intervals] of this.getGroups()) {
      if (!intervals[0].isWorking)
        calendars.push(calendar);
    }
    return this.calendarsNonWorking = calendars;
  }
  getGroups() {
    if (this.intervalsByCalendar)
      return this.intervalsByCalendar;
    const calendars = this.calendars = [];
    const intervalsByCalendar = /* @__PURE__ */ new Map();
    this.intervalGroups.forEach(([calendar, interval]) => {
      let data = intervalsByCalendar.get(calendar);
      if (!data) {
        calendars.push(calendar);
        data = [];
        intervalsByCalendar.set(calendar, data);
      }
      data.push.apply(data, interval.intervals);
    });
    intervalsByCalendar.forEach((intervals, calendar) => {
      const unique = stripDuplicates(intervals);
      unique.sort(
        (interval1, interval2) => interval2.getPriorityField() - interval1.getPriorityField()
      );
      intervalsByCalendar.set(calendar, unique);
    });
    return this.intervalsByCalendar = intervalsByCalendar;
  }
};
var binarySearch = (value, array, comparator = (a, b) => a - b) => {
  let left = 0;
  let right = array.length;
  while (left < right) {
    const mid = (left + right) / 2 | 0;
    const compare = comparator(value, array[mid]);
    if (compare === 0)
      return {
        found: true,
        index: mid
      };
    else if (compare < 0)
      right = mid;
    else
      left = mid + 1;
  }
  return {
    found: false,
    index: right
  };
};
var IndexPosition;
(function(IndexPosition2) {
  IndexPosition2[IndexPosition2["Exact"] = 0] = "Exact";
  IndexPosition2[IndexPosition2["Next"] = 1] = "Next";
})(IndexPosition || (IndexPosition = {}));
var SortedMap = class {
  constructor(comparator) {
    this.keys = [];
    this.values = [];
    this.comparator = comparator || ((a, b) => a - b);
  }
  set(key, value) {
    const search = binarySearch(key, this.keys, this.comparator);
    if (search.found) {
      this.values[search.index] = value;
    } else {
      this.keys.splice(search.index, 0, key);
      this.values.splice(search.index, 0, value);
    }
    return search.index;
  }
  insertAt(index, key, value) {
    this.keys.splice(index, 0, key);
    this.values.splice(index, 0, value);
  }
  setValueAt(index, value) {
    this.values[index] = value;
  }
  get(key) {
    const search = binarySearch(key, this.keys, this.comparator);
    return search.found ? this.values[search.index] : void 0;
  }
  getEntryAt(index) {
    return index < this.keys.length ? {
      key: this.keys[index],
      value: this.values[index]
    } : void 0;
  }
  getKeyAt(index) {
    return this.keys[index];
  }
  getValueAt(index) {
    return this.values[index];
  }
  delete(key) {
    const search = binarySearch(key, this.keys, this.comparator);
    if (search.found)
      this.deleteAt(search.index);
  }
  size() {
    return this.keys.length;
  }
  deleteAt(index) {
    this.keys.splice(index, 1);
    this.values.splice(index, 1);
  }
  indexOfKey(key) {
    const search = binarySearch(key, this.keys, this.comparator);
    return {
      found: search.found ? IndexPosition.Exact : IndexPosition.Next,
      index: search.index
    };
  }
  map(func) {
    const keys = this.keys;
    const values = this.values;
    const result = [];
    for (let i = 0; i < keys.length; i++)
      result.push(func(values[i], keys[i], i));
    return result;
  }
  getAllEntries() {
    return this.map((value, key) => {
      return {
        value,
        key
      };
    });
  }
  clear() {
    this.keys.length = 0;
    this.values.length = 0;
  }
};
var IntervalCache = class {
  constructor(config) {
    this.points = new SortedMap((a, b) => a.getTime() - b.getTime());
    this.leftInfinityKey = MIN_DATE;
    this.rightInfinityKey = MAX_DATE;
    Object.assign(this, config);
    if (this.emptyInterval === void 0 || !this.combineIntervalsFn)
      throw new Error("All of `emptyPoint`, `combineIntervalsFn` are required");
    this.points.set(this.leftInfinityKey, this.emptyInterval);
  }
  size() {
    return this.points.size();
  }
  indexOf(date2) {
    return this.points.indexOfKey(date2);
  }
  getDateAt(index) {
    return this.points.getKeyAt(index);
  }
  getPointAt(index) {
    return this.points.getValueAt(index);
  }
  getIntervalOf(date2, edgeInclusion = EdgeInclusion.Left) {
    let {
      found,
      index
    } = this.indexOf(date2);
    let startDateIndex;
    if (edgeInclusion === EdgeInclusion.Left) {
      startDateIndex = found === IndexPosition.Exact ? index : index - 1;
    } else {
      startDateIndex = index - 1;
    }
    return this.getIntervalWithStartDateIndex(startDateIndex);
  }
  getPrevInterval(interval) {
    if (interval.startDateIndex === 0)
      return null;
    return this.getIntervalWithStartDateIndex(interval.startDateIndex - 1);
  }
  getNextInterval(interval) {
    if (interval.startDateIndex >= this.size() - 1)
      return null;
    return this.getIntervalWithStartDateIndex(interval.startDateIndex + 1);
  }
  getIntervalWithStartDateIndex(startDateIndex) {
    return {
      startDateIndex,
      startDate: this.getDateAt(startDateIndex),
      endDate: startDateIndex + 1 < this.size() ? this.getDateAt(startDateIndex + 1) : this.rightInfinityKey,
      cacheInterval: this.getPointAt(startDateIndex)
    };
  }
  addInterval(startDate, endDate, extendInterval) {
    const points = this.points;
    const {
      found,
      index
    } = points.indexOfKey(startDate);
    let curIndex;
    let lastUpdatedPoint;
    if (found == IndexPosition.Exact) {
      const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(index));
      points.setValueAt(index, inclusion);
      curIndex = index + 1;
    } else {
      const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(index - 1));
      points.insertAt(index, startDate, inclusion);
      curIndex = index + 1;
    }
    while (curIndex < points.size()) {
      const curDate = points.getKeyAt(curIndex);
      if (curDate.getTime() >= endDate.getTime())
        break;
      const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(curIndex));
      points.setValueAt(curIndex, inclusion);
      curIndex++;
    }
    if (curIndex === points.size()) {
      points.insertAt(points.size(), endDate, this.emptyInterval);
    } else {
      const curDate = points.getKeyAt(curIndex);
      if (curDate.getTime() === endDate.getTime())
        ;
      else {
        points.insertAt(curIndex, endDate, lastUpdatedPoint);
      }
    }
  }
  includeWrappingRange(intervalCache, startDate, endDate) {
    let interval = intervalCache.getIntervalOf(startDate);
    while (interval) {
      this.addInterval(interval.startDate, interval.endDate, (existingInterval) => this.combineIntervalsFn(existingInterval, interval.cacheInterval));
      if (interval.endDate.getTime() > endDate.getTime())
        break;
      interval = intervalCache.getNextInterval(interval);
    }
  }
  getSummary() {
    return this.points.map((label, date2) => {
      return {
        label,
        date: date2
      };
    });
  }
  clear() {
    this.points.clear();
    this.points.set(this.leftInfinityKey, this.emptyInterval);
  }
};
var CalendarCacheMultiple = class extends CalendarCache {
  constructor(config) {
    super(config);
    this.calendarCaches = stripDuplicates(this.calendarCaches);
    this.intervalCache = new IntervalCache({
      emptyInterval: new CalendarCacheIntervalMultiple(),
      combineIntervalsFn: (interval1, interval2) => {
        return interval1.combineWith(interval2);
      }
    });
  }
  fillCache(startDate, endDate) {
    this.calendarCaches.forEach((calendarCache) => {
      calendarCache.fillCache(startDate, endDate);
      this.includeWrappingRangeFrom(calendarCache, startDate, endDate);
    });
  }
};
var COMBINED_CALENDARS_CACHE = /* @__PURE__ */ new Map();
var combineCalendars = (calendars) => {
  const uniqueOnly2 = stripDuplicates(calendars);
  if (uniqueOnly2.length === 0)
    throw new Error("No calendars to combine");
  uniqueOnly2.sort((calendar1, calendar2) => {
    if (calendar1.internalId < calendar2.internalId)
      return -1;
    else
      return 1;
  });
  const hash = uniqueOnly2.map((calendar) => calendar.internalId + "/").join("");
  const versionsHash = uniqueOnly2.map((calendar) => calendar.version + "/").join("");
  let cached = COMBINED_CALENDARS_CACHE.get(hash);
  let res;
  if (cached && cached.versionsHash === versionsHash)
    res = cached.cache;
  else {
    res = new CalendarCacheMultiple({
      calendarCaches: uniqueOnly2.map((calendar) => calendar.calendarCache)
    });
  }
  return res;
};
var CalendarCacheSingle = class extends CalendarCache {
  constructor(config) {
    super(config);
    this.staticIntervalsCached = false;
    if (!this.unspecifiedTimeInterval)
      throw new Error("Required attribute `unspecifiedTimeInterval` is missing");
    this.intervalCache = new IntervalCache({
      emptyInterval: new CalendarCacheInterval({
        intervals: [this.unspecifiedTimeInterval],
        calendar: this.calendar
      }),
      combineIntervalsFn: (interval1, interval2) => {
        return interval1.combineWith(interval2);
      }
    });
  }
  fillCache(startDate, endDate) {
    var _this$calendar$projec;
    if (!this.staticIntervalsCached) {
      this.cacheStaticIntervals();
      this.staticIntervalsCached = true;
    }
    if (this.parentCache)
      this.includeWrappingRangeFrom(this.parentCache, startDate, endDate);
    const startDateN = startDate.getTime();
    const endDateN = endDate.getTime();
    const timeZone = (_this$calendar$projec = this.calendar.project) === null || _this$calendar$projec === void 0 ? void 0 : _this$calendar$projec.timeZone;
    if (startDateN > endDateN)
      throw new Error("Invalid cache fill interval");
    this.forEachRecurrentInterval((interval) => {
      const startSchedule = interval.getStartDateSchedule();
      const endSchedule = interval.getEndDateSchedule();
      let wrappingStartDate = startSchedule.prev(1, startDate);
      let wrappingEndDate;
      if (endSchedule === "EOD") {
        const nextEndDate = startSchedule.next(1, endDate);
        if (nextEndDate !== later.NEVER) {
          wrappingEndDate = DateHelper.getStartOfNextDay(nextEndDate, true);
        } else {
          wrappingEndDate = later.NEVER;
        }
      } else {
        wrappingEndDate = endSchedule.next(1, endDate);
      }
      if (wrappingStartDate !== later.NEVER && wrappingStartDate.getTime() === startDateN) {
        const wrappingStartDates = startSchedule.prev(2, startDate);
        if (wrappingStartDates !== later.NEVER && wrappingStartDates.length === 2)
          wrappingStartDate = wrappingStartDates[1];
      }
      if (wrappingEndDate !== later.NEVER && wrappingEndDate.getTime() === endDateN) {
        const wrappingEndDates = endSchedule.next(2, endDate);
        if (wrappingEndDates !== later.NEVER && wrappingEndDates.length === 2)
          wrappingEndDate = wrappingEndDates[1];
      }
      const startDates = startSchedule.next(Infinity, wrappingStartDate !== later.NEVER ? wrappingStartDate : startDate, wrappingEndDate !== later.NEVER ? new Date(wrappingEndDate.getTime() - 1) : endDate);
      if (startDates === later.NEVER)
        return;
      const endDates = endSchedule === "EOD" ? startDates.map((date2) => DateHelper.getStartOfNextDay(date2, true)) : endSchedule.next(Infinity, new Date(startDates[0].getTime() + 1), wrappingEndDate !== later.NEVER ? wrappingEndDate : endDate);
      if (endDates === later.NEVER)
        return;
      if (endDates.length > startDates.length) {
        endDates.length = startDates.length;
      } else if (endDates.length < startDates.length) {
        startDates.length = endDates.length;
      }
      startDates.forEach((startDate2, index) => {
        let recStartDate = startDate2;
        let recEndDate = endDates[index];
        if (timeZone != null) {
          recStartDate = TimeZoneHelper.toTimeZone(recStartDate, timeZone);
          recEndDate = TimeZoneHelper.toTimeZone(recEndDate, timeZone);
        }
        this.intervalCache.addInterval(recStartDate, recEndDate, (existingCacheInterval) => existingCacheInterval.includeInterval(interval));
      });
    });
  }
  clear() {
    this.staticIntervalsCached = false;
    super.clear();
  }
  cacheStaticIntervals() {
    this.forEachStaticInterval((interval) => {
      var _this$calendar$projec2;
      const timeZone = (_this$calendar$projec2 = this.calendar.project) === null || _this$calendar$projec2 === void 0 ? void 0 : _this$calendar$projec2.timeZone;
      let {
        startDate,
        endDate
      } = interval;
      if (timeZone != null) {
        startDate = TimeZoneHelper.toTimeZone(startDate, timeZone);
        endDate = TimeZoneHelper.toTimeZone(endDate, timeZone);
      }
      this.intervalCache.addInterval(startDate, endDate, (existingCacheInterval) => existingCacheInterval.includeInterval(interval));
    });
  }
  forEachStaticInterval(func) {
    this.intervalStore.forEach((interval) => {
      if (interval.isStatic())
        func(interval);
    });
  }
  forEachRecurrentInterval(func) {
    this.intervalStore.forEach((interval) => {
      if (interval.isRecurrent())
        func(interval);
    });
  }
};
var AbstractPartOfProjectGenericMixin = class extends Mixin([], (base) => {
  base.prototype;
  class AbstractPartOfProjectGenericMixin2 extends base {
    async commitAsync() {
      return this.project.commitAsync();
    }
    set project(project) {
      this.$project = project;
    }
    get project() {
      return this.$project;
    }
    calculateProject() {
      throw new Error("Implement me");
    }
    setProject(project) {
      return this.project = project;
    }
    getProject() {
      if (this.project)
        return this.project;
      return this.setProject(this.calculateProject());
    }
    getAssignmentStore() {
      const project = this.getProject();
      return project === null || project === void 0 ? void 0 : project.assignmentStore;
    }
    getDependencyStore() {
      const project = this.getProject();
      return project === null || project === void 0 ? void 0 : project.dependencyStore;
    }
    getEventStore() {
      const project = this.getProject();
      return project === null || project === void 0 ? void 0 : project.eventStore;
    }
    getResourceStore() {
      const project = this.getProject();
      return project === null || project === void 0 ? void 0 : project.resourceStore;
    }
    getCalendarManagerStore() {
      const project = this.getProject();
      return project === null || project === void 0 ? void 0 : project.calendarManagerStore;
    }
  }
  return AbstractPartOfProjectGenericMixin2;
}) {
};
var AbstractPartOfProjectStoreMixin = class extends Mixin([AbstractPartOfProjectGenericMixin, Store], (base) => {
  const superProto = base.prototype;
  class AbstractPartOfProjectStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.isLoadingData = false;
      this.disableHasLoadedDataToCommitFlag = false;
    }
    construct(config = {}) {
      config.asyncEvents = {
        add: true,
        remove: true,
        removeAll: true,
        change: true,
        refresh: true,
        replace: true,
        move: true,
        update: true
      };
      return superProto.construct.call(this, config);
    }
    trigger(eventName, param) {
      const me = this, {
        asyncEvents,
        project
      } = me, asyncEvent = asyncEvents === null || asyncEvents === void 0 ? void 0 : asyncEvents[eventName], asyncAction = asyncEvent && (asyncEvent === true || asyncEvent[param.action]);
      if (!asyncAction) {
        return superProto.trigger.call(me, eventName, param);
      }
      superProto.trigger.call(me, `${eventName}PreCommit`, _objectSpread2({}, param));
      if (!project || project.isEngineReady() && !project.isWritingData) {
        superProto.trigger.call(me, eventName, param);
      } else if (!me.eventsSuspended && project) {
        if (!project.dataReadyDetacher) {
          project.queuedDataReadyEvents = [];
          project.dataReadyDetacher = project.ion({
            dataReady() {
              this.queuedDataReadyEvents.forEach(([superProto2, scope, eventName2, param2]) => {
                superProto2.trigger.call(scope, eventName2, param2);
              });
              project.queuedDataReadyEvents = null;
              project.dataReadyDetacher();
              project.dataReadyDetacher = null;
            },
            once: true
          });
        }
        project.queuedDataReadyEvents.push([superProto, me, eventName, param]);
      }
      return true;
    }
    calculateProject() {
      return this.project;
    }
    setStoreData(data) {
      var _this$project;
      if (this.project && !(this.syncDataOnLoad || this.disableHasLoadedDataToCommitFlag)) {
        this.project.hasLoadedDataToCommit = true;
      }
      this.isLoadingData = true;
      superProto.setStoreData.call(this, data);
      this.isLoadingData = false;
      (_this$project = this.project) === null || _this$project === void 0 ? void 0 : _this$project.trigger("storeRefresh", {
        store: this
      });
    }
    async doAutoCommit() {
      if (this.suspendCount <= 0 && this.project && !this.project.isEngineReady()) {
        await this.project.commitAsync();
      }
      superProto.doAutoCommit.call(this);
    }
    async addAsync(records, silent) {
      const result = this.add(records, silent);
      await this.project.commitAsync();
      return result;
    }
    async insertAsync(index, records, silent) {
      const result = this.insert(index, records, silent);
      await this.project.commitAsync();
      return result;
    }
    async loadDataAsync(data) {
      this.data = data;
      await this.project.commitAsync();
    }
  }
  return AbstractPartOfProjectStoreMixin2;
}) {
};
var AbstractPartOfProjectModelMixin = class extends Mixin([AbstractPartOfProjectGenericMixin, Model], (base) => {
  const superProto = base.prototype;
  class AbstractPartOfProjectModelMixin2 extends base {
    joinStore(store) {
      let joinedProject = null;
      if (isInstanceOf(store, AbstractPartOfProjectStoreMixin)) {
        const project = store.getProject();
        if (project && !this.getProject()) {
          this.setProject(project);
          joinedProject = project;
        }
      }
      superProto.joinStore.call(this, store);
      if (joinedProject && !joinedProject.isRepopulatingStores)
        this.joinProject();
    }
    unjoinStore(store, isReplacing = false) {
      superProto.unjoinStore.call(this, store, isReplacing);
      const project = this.getProject();
      const isLeavingProjectStore = isInstanceOf(store, AbstractPartOfProjectStoreMixin) && project === store.getProject();
      if (project && !project.isDestroying && !project.isRepopulatingStores && isLeavingProjectStore) {
        this.leaveProject(isReplacing);
        this.setProject(null);
      }
      if (isLeavingProjectStore)
        this.graph = null;
    }
    joinProject() {
    }
    leaveProject(isReplacing = false) {
    }
    calculateProject() {
      const store = this.stores.find((s) => isInstanceOf(s, AbstractPartOfProjectStoreMixin) && !!s.getProject());
      return store === null || store === void 0 ? void 0 : store.getProject();
    }
    async setAsync(fieldName, value, silent) {
      var _this$project;
      const result = this.set(fieldName, value, silent);
      await ((_this$project = this.project) === null || _this$project === void 0 ? void 0 : _this$project.commitAsync());
      return result;
    }
    async getAsync(fieldName) {
      var _this$project2;
      await ((_this$project2 = this.project) === null || _this$project2 === void 0 ? void 0 : _this$project2.commitAsync());
      return this.get(fieldName);
    }
    get isStmRestoring() {
      const project = this.getProject();
      return (project === null || project === void 0 ? void 0 : project.isRestoringData) || (project === null || project === void 0 ? void 0 : project.stm.isRestoring) || false;
    }
  }
  return AbstractPartOfProjectModelMixin2;
}) {
};
var CalendarIntervalMixin = class extends Mixin([AbstractPartOfProjectModelMixin], (base) => {
  base.prototype;
  class CalendarIntervalMixin2 extends base {
    static get fields() {
      return ["name", {
        name: "startDate",
        type: "date"
      }, {
        name: "endDate",
        type: "date"
      }, "recurrentStartDate", "recurrentEndDate", "cls", "iconCls", {
        name: "isWorking",
        type: "boolean",
        defaultValue: false
      }, {
        name: "priority",
        type: "number"
      }];
    }
    getCalendar() {
      return this.stores[0].calendar;
    }
    resetPriority() {
      this.priorityField = null;
      this.getCalendar().getDepth();
    }
    getPriorityField() {
      if (this.priorityField != null)
        return this.priorityField;
      let base2 = 1e4 + this.getCalendar().getDepth() * 100;
      let priority = this.priority;
      if (priority == null) {
        priority = this.isRecurrent() ? 20 : 30;
      }
      return this.priorityField = base2 + priority;
    }
    isRecurrent() {
      return Boolean(this.recurrentStartDate && this.recurrentEndDate && this.getStartDateSchedule() && this.getEndDateSchedule());
    }
    isStatic() {
      return Boolean(this.startDate && this.endDate);
    }
    parseDateSchedule(value) {
      let schedule = value;
      if (value && value !== Object(value)) {
        schedule = later.parse.text(value);
        if (schedule !== Object(schedule) || schedule.error >= 0) {
          try {
            schedule = JSON.parse(value);
          } catch (e) {
            return null;
          }
        }
      }
      return schedule;
    }
    getStartDateSchedule() {
      if (this.startDateSchedule)
        return this.startDateSchedule;
      const schedule = this.parseDateSchedule(this.recurrentStartDate);
      return this.startDateSchedule = later.schedule(schedule);
    }
    getEndDateSchedule() {
      if (this.endDateSchedule)
        return this.endDateSchedule;
      if (this.recurrentEndDate === "EOD")
        return "EOD";
      const schedule = this.parseDateSchedule(this.recurrentEndDate);
      return this.endDateSchedule = later.schedule(schedule);
    }
  }
  return CalendarIntervalMixin2;
}) {
};
var CalendarIntervalStore = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  base.prototype;
  class CalendarIntervalStore2 extends base {
    constructor() {
      super(...arguments);
      this.disableHasLoadedDataToCommitFlag = true;
    }
    static get defaultConfig() {
      return {
        modelClass: CalendarIntervalMixin
      };
    }
  }
  return CalendarIntervalStore2;
}) {
};
var UnspecifiedTimeIntervalModel = class extends Mixin([CalendarIntervalMixin], (base) => {
  base.prototype;
  class UnspecifiedTimeIntervalModel2 extends base {
    getCalendar() {
      return this.calendar;
    }
    getPriorityField() {
      if (this.priorityField != null)
        return this.priorityField;
      return this.priorityField = this.getCalendar().getDepth();
    }
  }
  return UnspecifiedTimeIntervalModel2;
}) {
};
var CorePartOfProjectGenericMixin = class extends Mixin([AbstractPartOfProjectGenericMixin], (base) => {
  base.prototype;
  class CorePartOfProjectGenericMixin2 extends base {
    get eventStore() {
      var _this$project;
      return (_this$project = this.project) === null || _this$project === void 0 ? void 0 : _this$project.eventStore;
    }
    get resourceStore() {
      var _this$project2;
      return (_this$project2 = this.project) === null || _this$project2 === void 0 ? void 0 : _this$project2.resourceStore;
    }
    get assignmentStore() {
      var _this$project3;
      return (_this$project3 = this.project) === null || _this$project3 === void 0 ? void 0 : _this$project3.assignmentStore;
    }
    get dependencyStore() {
      var _this$project4;
      return (_this$project4 = this.project) === null || _this$project4 === void 0 ? void 0 : _this$project4.dependencyStore;
    }
    get calendarManagerStore() {
      var _this$project5;
      return (_this$project5 = this.project) === null || _this$project5 === void 0 ? void 0 : _this$project5.calendarManagerStore;
    }
    getEventById(id) {
      var _this$eventStore;
      return (_this$eventStore = this.eventStore) === null || _this$eventStore === void 0 ? void 0 : _this$eventStore.getById(id);
    }
    getDependencyById(id) {
      var _this$dependencyStore;
      return (_this$dependencyStore = this.dependencyStore) === null || _this$dependencyStore === void 0 ? void 0 : _this$dependencyStore.getById(id);
    }
    getResourceById(id) {
      var _this$resourceStore;
      return (_this$resourceStore = this.resourceStore) === null || _this$resourceStore === void 0 ? void 0 : _this$resourceStore.getById(id);
    }
    getAssignmentById(id) {
      var _this$assignmentStore;
      return (_this$assignmentStore = this.assignmentStore) === null || _this$assignmentStore === void 0 ? void 0 : _this$assignmentStore.getById(id);
    }
    getCalendarById(id) {
      var _this$calendarManager;
      return (_this$calendarManager = this.calendarManagerStore) === null || _this$calendarManager === void 0 ? void 0 : _this$calendarManager.getById(id);
    }
  }
  return CorePartOfProjectGenericMixin2;
}) {
};
var AbstractCalendarMixin = class extends Mixin([AbstractPartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CalendarMixin2 extends base {
    constructor() {
      super(...arguments);
      this.version = 1;
    }
    static get fields() {
      return [{
        name: "version",
        type: "number"
      }, "name", {
        name: "unspecifiedTimeIsWorking",
        type: "boolean",
        defaultValue: true
      }, {
        name: "intervals",
        type: "store",
        subStore: true
      }, "cls", "iconCls"];
    }
    get intervalStoreClass() {
      return CalendarIntervalStore;
    }
    get intervalStore() {
      return this.meta.intervalsStore;
    }
    initIntervalsStore(config) {
      config.storeClass = this.intervalStoreClass;
      config.modelClass = this.getDefaultConfiguration().calendarIntervalModelClass || this.intervalStoreClass.defaultConfig.modelClass;
      config.calendar = this;
    }
    processIntervalsStoreData(intervals) {
      this.bumpVersion();
    }
    isDefault() {
      const project = this.getProject();
      if (project) {
        return this === project.defaultCalendar;
      }
      return false;
    }
    getDepth() {
      return this.childLevel + 1;
    }
    forEachAvailabilityInterval(options, func, scope) {
      const maxRange = this.getProject().maxCalendarRange;
      if (maxRange) {
        options = Object.assign({
          maxRange
        }, options);
      }
      return this.calendarCache.forEachAvailabilityInterval(options, func, scope);
    }
    accumulateWorkingTime(date2, durationMs, isForward) {
      if (durationMs === 0)
        return {
          finalDate: new Date(date2),
          remainingDurationInMs: 0
        };
      if (isNaN(durationMs))
        throw new Error("Invalid duration");
      let finalDate = date2;
      const adjustDurationToDST = this.getProject().adjustDurationToDST;
      this.forEachAvailabilityInterval(isForward ? {
        startDate: date2,
        isForward: true
      } : {
        endDate: date2,
        isForward: false
      }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        let result = true;
        if (calendarCacheInterval.getIsWorking()) {
          let diff = intervalEndDate.getTime() - intervalStartDate.getTime();
          if (durationMs <= diff) {
            if (adjustDurationToDST) {
              const dstDiff = isForward ? intervalStartDate.getTimezoneOffset() - new Date(intervalStartDate.getTime() + durationMs).getTimezoneOffset() : new Date(intervalEndDate.getTime() - durationMs).getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
              durationMs -= dstDiff * 60 * 1e3;
            }
            finalDate = isForward ? new Date(intervalStartDate.getTime() + durationMs) : new Date(intervalEndDate.getTime() - durationMs);
            durationMs = 0;
            result = false;
          } else {
            if (adjustDurationToDST) {
              const dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
              diff += dstDiff * 60 * 1e3;
            }
            finalDate = isForward ? intervalEndDate : intervalStartDate;
            durationMs -= diff;
          }
        }
        return result;
      });
      return {
        finalDate: new Date(finalDate),
        remainingDurationInMs: durationMs
      };
    }
    calculateDurationMs(startDate, endDate, allowNegative = false) {
      let duration = 0;
      const multiplier = startDate.getTime() <= endDate.getTime() || !allowNegative ? 1 : -1;
      if (multiplier < 0) {
        [startDate, endDate] = [endDate, startDate];
      }
      const adjustDurationToDST = this.getProject().adjustDurationToDST;
      this.forEachAvailabilityInterval({
        startDate,
        endDate
      }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        if (calendarCacheInterval.getIsWorking()) {
          duration += intervalEndDate.getTime() - intervalStartDate.getTime();
          if (adjustDurationToDST) {
            const dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
            duration += dstDiff * 60 * 1e3;
          }
        }
      });
      return duration * multiplier;
    }
    calculateEndDate(startDate, durationMs) {
      const isForward = durationMs >= 0;
      const res = this.accumulateWorkingTime(startDate, Math.abs(durationMs), isForward);
      return res.remainingDurationInMs === 0 ? res.finalDate : null;
    }
    calculateStartDate(endDate, durationMs) {
      const isForward = durationMs <= 0;
      const res = this.accumulateWorkingTime(endDate, Math.abs(durationMs), isForward);
      return res.remainingDurationInMs === 0 ? res.finalDate : null;
    }
    skipNonWorkingTime(date2, isForward = true) {
      let workingDate;
      const res = this.forEachAvailabilityInterval(isForward ? {
        startDate: date2,
        isForward: true
      } : {
        endDate: date2,
        isForward: false
      }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        if (calendarCacheInterval.getIsWorking()) {
          workingDate = isForward ? intervalStartDate : intervalEndDate;
          return false;
        }
      });
      if (res === CalendarIteratorResult.MaxRangeReached || res === CalendarIteratorResult.FullRangeIterated)
        return "empty_calendar";
      return workingDate ? new Date(workingDate) : new Date(date2);
    }
    addInterval(interval) {
      return this.addIntervals([interval]);
    }
    addIntervals(intervals) {
      this.bumpVersion();
      return this.intervalStore.add(intervals);
    }
    removeInterval(interval) {
      return this.removeIntervals([interval]);
    }
    removeIntervals(intervals) {
      this.bumpVersion();
      return this.intervalStore.remove(intervals);
    }
    clearIntervals(silent) {
      if (!silent) {
        this.bumpVersion();
      }
      return this.intervalStore.removeAll(silent);
    }
    bumpVersion() {
      this.clearCache();
      this.version++;
    }
    get calendarCache() {
      if (this.$calendarCache !== void 0)
        return this.$calendarCache;
      const unspecifiedTimeInterval = new UnspecifiedTimeIntervalModel({
        isWorking: this.unspecifiedTimeIsWorking
      });
      unspecifiedTimeInterval.calendar = this;
      return this.$calendarCache = new CalendarCacheSingle({
        calendar: this,
        unspecifiedTimeInterval,
        intervalStore: this.intervalStore,
        parentCache: this.parent && !this.parent.isRoot ? this.parent.calendarCache : null
      });
    }
    clearCache() {
      this.$calendarCache && this.$calendarCache.clear();
      this.$calendarCache = void 0;
    }
    resetPriorityOfAllIntervals() {
      this.traverse((calendar) => {
        calendar.intervalStore.forEach((interval) => interval.resetPriority());
      });
    }
    insertChild(child, before, silent) {
      let res = superProto.insertChild.call(this, ...arguments);
      if (!Array.isArray(res)) {
        res = [res];
      }
      res.forEach((r) => {
        r.bumpVersion();
        r.resetPriorityOfAllIntervals();
      });
      return res;
    }
    joinProject() {
      superProto.joinProject.call(this);
      this.intervalStore.setProject(this.getProject());
    }
    leaveProject() {
      superProto.leaveProject.call(this);
      this.intervalStore.setProject(null);
      this.clearCache();
    }
    doDestroy() {
      this.leaveProject();
      this.intervalStore.destroy();
      super.doDestroy();
    }
    isDayHoliday(day2) {
      const startDate = DateHelper.clearTime(day2), endDate = DateHelper.getNext(day2, TimeUnit.Day);
      let hasWorkingTime = false;
      this.forEachAvailabilityInterval({
        startDate,
        endDate,
        isForward: true
      }, (_intervalStartDate, _intervalEndDate, calendarCacheInterval) => {
        hasWorkingTime = calendarCacheInterval.getIsWorking();
        return !hasWorkingTime;
      });
      return !hasWorkingTime;
    }
    getDailyHolidaysRanges(startDate, endDate) {
      const result = [];
      startDate = DateHelper.clearTime(startDate);
      while (startDate < endDate) {
        if (this.isDayHoliday(startDate)) {
          result.push({
            startDate,
            endDate: DateHelper.getStartOfNextDay(startDate, true, true)
          });
        }
        startDate = DateHelper.getNext(startDate, TimeUnit.Day);
      }
      return result;
    }
    getWorkingTimeRanges(startDate, endDate) {
      const result = [];
      this.forEachAvailabilityInterval({
        startDate,
        endDate,
        isForward: true
      }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        if (calendarCacheInterval.getIsWorking()) {
          const entry = calendarCacheInterval.intervals[0];
          result.push({
            name: entry.name,
            startDate: intervalStartDate,
            endDate: intervalEndDate
          });
        }
      });
      return result;
    }
    getNonWorkingTimeRanges(startDate, endDate) {
      const result = [];
      this.forEachAvailabilityInterval({
        startDate,
        endDate,
        isForward: true
      }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        if (!calendarCacheInterval.getIsWorking()) {
          const entry = calendarCacheInterval.intervals[0];
          result.push({
            name: entry.name,
            iconCls: entry.iconCls,
            cls: entry.cls,
            startDate: intervalStartDate,
            endDate: intervalEndDate
          });
        }
      });
      return result;
    }
    isWorkingTime(startDate, endDate, fullyContained) {
      if (fullyContained) {
        let found;
        const res = this.forEachAvailabilityInterval({
          startDate,
          endDate,
          isForward: true
        }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
          if (calendarCacheInterval.getIsWorking() && intervalStartDate <= startDate && intervalEndDate >= endDate) {
            found = true;
            return false;
          }
        });
        if (res === CalendarIteratorResult.MaxRangeReached || res === CalendarIteratorResult.FullRangeIterated)
          return false;
        return found;
      } else {
        const workingTimeStart = this.skipNonWorkingTime(startDate);
        return workingTimeStart && workingTimeStart !== "empty_calendar" ? endDate ? workingTimeStart < endDate : workingTimeStart.getTime() === startDate.getTime() : false;
      }
    }
  }
  return CalendarMixin2;
}) {
};
var AbstractHasAssignmentsMixin = class extends Mixin([AbstractPartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class HasAssignmentsMixin extends base {
    getAssignmentFor(resource) {
      for (const assignment of (_this$assigned = this.assigned) !== null && _this$assigned !== void 0 ? _this$assigned : []) {
        var _this$assigned;
        if (assignment.resource === resource)
          return assignment;
      }
      return null;
    }
    isAssignedTo(resource) {
      return Boolean(this.getAssignmentFor(resource));
    }
    async assign(resource) {
      const assignmentCls = this.project.assignmentStore.modelClass;
      this.addAssignment(new assignmentCls({
        event: this,
        resource
      }));
      return this.commitAsync();
    }
    async unassign(resource) {
      const assignment = this.getAssignmentFor(resource);
      this.removeAssignment(assignment);
      return this.commitAsync();
    }
    leaveProject() {
      if (this.isInActiveTransaction && this.assigned) {
        const eventStore = this.getEventStore();
        this.assigned.forEach((assignment) => eventStore.assignmentsForRemoval.add(assignment));
      }
      superProto.leaveProject.call(this, ...arguments);
    }
    remove() {
      if (this.parent) {
        const eventStore = this.getEventStore();
        superProto.remove.call(this);
        eventStore && eventStore.afterEventRemoval();
      } else {
        return superProto.remove.call(this);
      }
    }
    addAssignment(assignment) {
      this.getProject().assignmentStore.add(assignment);
      return assignment;
    }
    removeAssignment(assignment) {
      this.getProject().assignmentStore.remove(assignment);
      return assignment;
    }
  }
  return HasAssignmentsMixin;
}) {
};
var CorePartOfProjectModelMixin = class extends Mixin([AbstractPartOfProjectModelMixin, CorePartOfProjectGenericMixin, Model], (base) => {
  const superProto = base.prototype;
  class CorePartOfProjectModelMixin2 extends base {
    constructor() {
      super(...arguments);
      this.$isCalculating = false;
      this.$changed = {};
      this.$beforeChange = {};
    }
    get isInActiveTransaction() {
      return true;
    }
    joinProject() {
      this.invalidate();
    }
    leaveProject(isReplacing = false) {
      var _this$project;
      superProto.leaveProject.call(this, isReplacing);
      (_this$project = this.project) === null || _this$project === void 0 ? void 0 : _this$project.bufferedCommitAsync();
    }
    invalidate() {
      var _this$project2;
      (_this$project2 = this.project) === null || _this$project2 === void 0 ? void 0 : _this$project2.invalidate(this);
    }
    getCurrentOrProposed(fieldName) {
      var _this$get;
      if (fieldName in this.$changed && this.$changed[fieldName] !== true) {
        return this.$changed[fieldName];
      }
      return (_this$get = this.get(fieldName)) !== null && _this$get !== void 0 ? _this$get : null;
    }
    hasCurrentOrProposed(fieldName) {
      return fieldName in this.$changed && this.$changed[fieldName] != true || this.get(fieldName) != null;
    }
    propose(changes) {
      var _this$recurringTimeSp;
      if (this.project || (_this$recurringTimeSp = this.recurringTimeSpan) !== null && _this$recurringTimeSp !== void 0 && _this$recurringTimeSp.project) {
        const keys = Object.keys(changes);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          this.$changed[key] = changes[key];
        }
        this.invalidate();
      } else {
        this.set(changes);
      }
    }
    setChanged(field, value, invalidate = true, setData = false) {
      const me = this;
      me.$changed[field] = value;
      if (setData) {
        if (!(field in me.$beforeChange)) {
          me.$beforeChange[field] = me.get(field);
        }
        me.setData(field, value);
      }
      invalidate && me.invalidate();
    }
    calculateInvalidated() {
    }
    finalizeInvalidated(silent = false) {
      const me = this;
      me.$isCalculating = true;
      if (!silent) {
        me.setData(me.$beforeChange);
        me.set(me.$changed);
      } else {
        me.setData(me.$changed);
      }
      me.$changed = {};
      me.$beforeChange = {};
      me.$isCalculating = false;
    }
  }
  return CorePartOfProjectModelMixin2;
}) {
};
var isNotNumber = (value) => Number(value) !== value;
var CIFromSetOrArrayOrValue = (value) => {
  if (value instanceof Set || value instanceof Array)
    return CI(value);
  return CI([value]);
};
var delay = (value) => new Promise((resolve) => setTimeout(resolve, value));
var format = (format2, ...values) => {
  return format2.replace(/{(\d+)}/g, (match, number) => typeof values[number] !== "undefined" ? values[number] : match);
};
var AbstractAssignmentStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class AbstractAssignmentStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.assignmentsForRemoval = /* @__PURE__ */ new Set();
      this.allAssignmentsForRemoval = false;
    }
    remove(records, silent) {
      this.assignmentsForRemoval = CIFromSetOrArrayOrValue(records).toSet();
      const res = superProto.remove.call(this, records, silent);
      this.assignmentsForRemoval.clear();
      return res;
    }
    removeAll(silent) {
      this.allAssignmentsForRemoval = true;
      const res = superProto.removeAll.call(this, silent);
      this.allAssignmentsForRemoval = false;
      return res;
    }
  }
  return AbstractAssignmentStoreMixin2;
}) {
};
var AbstractCalendarManagerStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  base.prototype;
  class AbstractCalendarManagerStoreMixin2 extends base {
    doDestroy() {
      var _this$rootNode;
      const records = [];
      if (!((_this$rootNode = this.rootNode) !== null && _this$rootNode !== void 0 && _this$rootNode.isDestroyed)) {
        this.traverse((record) => records.push(record));
      }
      super.doDestroy();
      records.forEach((record) => record.destroy());
    }
  }
  return AbstractCalendarManagerStoreMixin2;
}) {
};
var AbstractDependencyStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class AbstractDependencyStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.dependenciesForRemoval = /* @__PURE__ */ new Set();
      this.allDependenciesForRemoval = false;
    }
    remove(records, silent) {
      this.dependenciesForRemoval = CIFromSetOrArrayOrValue(records).toSet();
      const res = superProto.remove.call(this, records, silent);
      this.dependenciesForRemoval.clear();
      return res;
    }
    removeAll(silent) {
      this.allDependenciesForRemoval = true;
      const res = superProto.removeAll.call(this, silent);
      this.allDependenciesForRemoval = false;
      return res;
    }
  }
  return AbstractDependencyStoreMixin2;
}) {
};
var dataAddRemoveActions$1 = {
  splice: 1,
  clear: 1
};
var AbstractEventStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class AbstractEventStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.assignmentsForRemoval = /* @__PURE__ */ new Set();
      this.dependenciesForRemoval = /* @__PURE__ */ new Set();
    }
    onDataChange(event) {
      var _event$removed;
      const isAddRemove = dataAddRemoveActions$1[event.action];
      super.onDataChange(event);
      if (isAddRemove && (_event$removed = event.removed) !== null && _event$removed !== void 0 && _event$removed.length)
        this.afterEventRemoval();
    }
    remove(records, silent) {
      const res = superProto.remove.call(this, records, silent);
      this.afterEventRemoval();
      return res;
    }
    removeAll(silent) {
      const res = superProto.removeAll.call(this, silent);
      this.afterEventRemoval();
      return res;
    }
    onNodeRemoveChild(parent, children, index, flags) {
      const removed = superProto.onNodeRemoveChild.call(this, ...arguments);
      this.afterEventRemoval();
      return removed;
    }
    afterEventRemoval() {
      const {
        assignmentsForRemoval,
        dependenciesForRemoval
      } = this;
      if (!assignmentsForRemoval)
        return;
      const assignmentStore = this.getAssignmentStore();
      if (assignmentStore && !assignmentStore.allAssignmentsForRemoval && assignmentsForRemoval.size) {
        const toRemove = [...assignmentsForRemoval].filter((assignment) => !assignmentStore.assignmentsForRemoval.has(assignment));
        toRemove.length > 0 && assignmentStore.remove(toRemove);
      }
      assignmentsForRemoval.clear();
      const dependencyStore = this.getDependencyStore();
      if (dependencyStore && !dependencyStore.allDependenciesForRemoval && dependenciesForRemoval.size) {
        const toRemove = [...dependenciesForRemoval].filter((dependency) => !dependencyStore.dependenciesForRemoval.has(dependency));
        toRemove.length > 0 && dependencyStore.remove(toRemove);
      }
      dependenciesForRemoval.clear();
    }
    processRecord(eventRecord, isDataset = false) {
      var _this$project;
      if (!((_this$project = this.project) !== null && _this$project !== void 0 && _this$project.isRepopulatingStores)) {
        const existingRecord = this.getById(eventRecord.id);
        const isReplacing = existingRecord && existingRecord !== eventRecord;
        if (isReplacing && existingRecord.assigned) {
          for (const assignment of existingRecord.assigned) {
            assignment.event = eventRecord;
          }
        }
      }
      return eventRecord;
    }
  }
  return AbstractEventStoreMixin2;
}) {
};
var dataAddRemoveActions = {
  splice: 1,
  clear: 1
};
var AbstractResourceStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class AbstractResourceStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.assignmentsForRemoval = /* @__PURE__ */ new Set();
    }
    onDataChange(event) {
      var _event$removed;
      const isAddRemove = dataAddRemoveActions[event.action];
      super.onDataChange(event);
      if (isAddRemove && (_event$removed = event.removed) !== null && _event$removed !== void 0 && _event$removed.length)
        this.afterResourceRemoval();
    }
    remove(records, silent) {
      const res = superProto.remove.call(this, records, silent);
      this.afterResourceRemoval();
      return res;
    }
    removeAll(silent) {
      const res = superProto.removeAll.call(this, silent);
      this.afterResourceRemoval();
      return res;
    }
    afterResourceRemoval() {
      const assignmentStore = this.getAssignmentStore();
      if (assignmentStore && !assignmentStore.allAssignmentsForRemoval) {
        const assignmentsForRemoval = [...this.assignmentsForRemoval].filter((assignment) => !assignmentStore.assignmentsForRemoval.has(assignment));
        assignmentsForRemoval.length > 0 && assignmentStore.remove(assignmentsForRemoval);
      }
      this.assignmentsForRemoval.clear();
    }
    processRecord(resourceRecord, isDataset = false) {
      const existingRecord = this.getById(resourceRecord.id);
      const isReplacing = existingRecord && existingRecord !== resourceRecord;
      if (isReplacing) {
        for (const assignment of existingRecord.assigned || []) {
          assignment.resource = resourceRecord;
        }
      }
      return resourceRecord;
    }
  }
  return AbstractResourceStoreMixin2;
}) {
};
var CoreEventMixin = class extends Mixin([CorePartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CoreEventMixin2 extends base {
    constructor() {
      super(...arguments);
      this._startDate = null;
      this._endDate = null;
      this._duration = null;
    }
    static get fields() {
      return [{
        name: "startDate",
        type: "date"
      }, {
        name: "endDate",
        type: "date"
      }, {
        name: "duration",
        type: "number"
      }, {
        name: "durationUnit",
        type: "durationunit",
        defaultValue: "day"
      }];
    }
    get startDate() {
      var _ref, _this$_startDate;
      return (_ref = (_this$_startDate = this._startDate) !== null && _this$_startDate !== void 0 ? _this$_startDate : this.get("startDate")) !== null && _ref !== void 0 ? _ref : null;
    }
    get endDate() {
      var _ref2, _this$_endDate;
      return (_ref2 = (_this$_endDate = this._endDate) !== null && _this$_endDate !== void 0 ? _this$_endDate : this.get("endDate")) !== null && _ref2 !== void 0 ? _ref2 : null;
    }
    get duration() {
      var _ref3, _this$_duration;
      return (_ref3 = (_this$_duration = this._duration) !== null && _this$_duration !== void 0 ? _this$_duration : this.get("duration")) !== null && _ref3 !== void 0 ? _ref3 : null;
    }
    set startDate(value) {
      this.proposeStartDate(value);
    }
    set endDate(value) {
      this.proposeEndDate(value);
    }
    set duration(value) {
      this.proposeDuration(value);
    }
    inSet(field, value, silent, fromRelationUpdate, skipAccessors) {
      const me = this;
      if (me.project && !me.project.isWritingData && typeof field !== "string" && !skipAccessors) {
        if ("startDate" in field && !("startDate" in me.$changed)) {
          me.$changed.startDate = true;
          me.invalidate();
        }
        if ("endDate" in field && !("endDate" in me.$changed)) {
          me.$changed.endDate = true;
          me.invalidate();
        }
      }
      return superProto.inSet.call(me, field, value, silent, fromRelationUpdate, skipAccessors);
    }
    getStartDate() {
      return this.startDate;
    }
    proposeStartDate(startDate, keepDuration = !("endDate" in this.$changed)) {
      var _this$startDate;
      if (this.inSetting || (startDate === null || startDate === void 0 ? void 0 : startDate.getTime()) !== ((_this$startDate = this.startDate) === null || _this$startDate === void 0 ? void 0 : _this$startDate.getTime())) {
        this._startDate = startDate;
        this.propose({
          startDate,
          keepDuration
        });
      }
    }
    async setStartDate(startDate, keepDuration = true) {
      var _this$project;
      this.proposeStartDate(startDate, keepDuration);
      return (_this$project = this.project) === null || _this$project === void 0 ? void 0 : _this$project.commitAsync();
    }
    getEndDate() {
      return this.endDate;
    }
    proposeEndDate(endDate, keepDuration = false) {
      var _this$endDate;
      if (this.inSetting || (endDate === null || endDate === void 0 ? void 0 : endDate.getTime()) !== ((_this$endDate = this.endDate) === null || _this$endDate === void 0 ? void 0 : _this$endDate.getTime())) {
        this._endDate = endDate;
        this.propose({
          endDate,
          keepDuration
        });
      }
    }
    async setEndDate(endDate, keepDuration = false) {
      var _this$project2;
      this.proposeEndDate(endDate, keepDuration);
      return (_this$project2 = this.project) === null || _this$project2 === void 0 ? void 0 : _this$project2.commitAsync();
    }
    getDuration() {
      return this.duration;
    }
    proposeDuration(duration, unit, keepStart = true) {
      this._duration = duration;
      this.propose({
        duration,
        keepStart
      });
      if (unit)
        this.propose({
          durationUnit: unit
        });
    }
    async setDuration(duration, unit, keepStart = true) {
      var _this$project3;
      this.proposeDuration(duration, unit, keepStart);
      return (_this$project3 = this.project) === null || _this$project3 === void 0 ? void 0 : _this$project3.commitAsync();
    }
    getDurationUnit() {
      return this.durationUnit;
    }
    joinProject() {
      const me = this;
      const changed = me.$changed;
      const startDate = me.getCurrentOrProposed("startDate");
      const endDate = me.getCurrentOrProposed("endDate");
      const duration = me.getCurrentOrProposed("duration");
      if (startDate != null)
        changed.startDate = me._startDate = startDate;
      if (endDate != null)
        changed.endDate = me._endDate = endDate;
      if (duration != null)
        changed.duration = me._duration = duration;
      if (me.eventStore && !me.eventStore.isLoadingData) {
        var _me$assignmentStore;
        const unresolved = (_me$assignmentStore = me.assignmentStore) === null || _me$assignmentStore === void 0 ? void 0 : _me$assignmentStore.storage.findItem("event", null);
        if (unresolved) {
          var _me$assignmentStore2;
          const cachedAssignments = (_me$assignmentStore2 = me.assignmentStore) === null || _me$assignmentStore2 === void 0 ? void 0 : _me$assignmentStore2.storage.findItem("eventId", me.id);
          if (cachedAssignments) {
            for (const assignment of cachedAssignments) {
              assignment.setChanged("event", me);
            }
          } else {
            for (const assignment of unresolved) {
              if (assignment.getCurrentOrProposed("event") === me.id) {
                assignment.setChanged("event", me);
              }
            }
          }
        }
      }
      superProto.joinProject.call(me);
    }
    applyValue(useProp, key, value, skipAccessors, field) {
      var _this$recurringTimeSp;
      if (this.project || (_this$recurringTimeSp = this.recurringTimeSpan) !== null && _this$recurringTimeSp !== void 0 && _this$recurringTimeSp.project) {
        if (key === "startDate" || key == "duration" || key === "endDate") {
          useProp = true;
          this["_" + key] = value;
        }
        if (skipAccessors) {
          useProp = false;
        }
      }
      superProto.applyValue.call(this, useProp, key, value, skipAccessors, field);
    }
    afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {
      if (!this.$isCalculating && !skipAccessors) {
        this.setData({
          startDate: this.getCurrentOrProposed("startDate"),
          endDate: this.getCurrentOrProposed("endDate"),
          duration: this.getCurrentOrProposed("duration"),
          durationUnit: this.getCurrentOrProposed("durationUnit")
        });
      }
      superProto.afterChange.call(this, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    calculateInvalidated() {
      const me = this;
      const changed = me.$changed;
      const changedStart = "startDate" in changed;
      const changedEnd = "endDate" in changed;
      const changedDuration = "duration" in changed;
      const {
        startDate,
        endDate,
        duration,
        keepDuration,
        keepStart
      } = changed;
      let calculate = null;
      if (changedStart && !changedEnd && !changedDuration) {
        if (startDate === null) {
          changed.endDate = null;
        } else if (me.hasCurrentOrProposed("endDate") && startDate > me.getCurrentOrProposed("endDate") && !keepDuration) {
          changed.endDate = startDate;
          changed.duration = 0;
        } else if (me.hasCurrentOrProposed("duration") && (keepDuration || !me.hasCurrentOrProposed("endDate"))) {
          calculate = "endDate";
        } else if (me.hasCurrentOrProposed("endDate")) {
          calculate = "duration";
        }
      } else if (!changedStart && changedEnd && !changedDuration) {
        if (endDate === null) {
          changed.startDate = null;
        } else if (me.hasCurrentOrProposed("startDate") && !keepDuration && endDate !== true && endDate < me.getCurrentOrProposed("startDate")) {
          changed.startDate = endDate;
          changed.duration = 0;
        } else if (me.hasCurrentOrProposed("duration") && (keepDuration || !me.hasCurrentOrProposed("startDate"))) {
          calculate = "startDate";
        } else if (me.hasCurrentOrProposed("startDate")) {
          calculate = "duration";
        }
      } else if (!changedStart && !changedEnd && changedDuration) {
        if (duration === null) {
          changed.endDate = null;
        } else if (me.hasCurrentOrProposed("startDate") && (keepStart || !me.hasCurrentOrProposed("endDate"))) {
          if (keepStart && changed.duration < 0) {
            changed.duration = 0;
          }
          calculate = "endDate";
        } else if (me.hasCurrentOrProposed("endDate")) {
          calculate = "startDate";
        }
      } else if (changedStart && changedEnd && !changedDuration) {
        if (startDate === null && endDate === null) {
          changed.duration = null;
        } else {
          calculate = "duration";
        }
      } else if (changedStart && !changedEnd && changedDuration) {
        calculate = "endDate";
      } else if (!changedStart && changedEnd && changedDuration) {
        calculate = "startDate";
      } else if (changedStart && changedEnd && changedDuration) {
        if (duration == null) {
          calculate = "duration";
        } else if (startDate == null) {
          calculate = "startDate";
        } else {
          calculate = "endDate";
        }
      }
      const currentOrProposedStartDate = me.getCurrentOrProposed("startDate");
      const currentOrProposedEndDate = me.getCurrentOrProposed("endDate");
      const currentOrProposedDuration = me.getCurrentOrProposed("duration");
      const currentOrProposedDurationUnit = me.getCurrentOrProposed("durationUnit");
      let hourDuration, targetDuration;
      switch (calculate) {
        case "startDate":
          changed.startDate = DateHelper.add(currentOrProposedEndDate, -currentOrProposedDuration, currentOrProposedDurationUnit);
          break;
        case "endDate":
          hourDuration = DateHelper.as("hour", currentOrProposedDuration, currentOrProposedDurationUnit);
          targetDuration = DateHelper.as(currentOrProposedDurationUnit, hourDuration, "h");
          changed.endDate = DateHelper.add(currentOrProposedStartDate, targetDuration, currentOrProposedDurationUnit);
          break;
        case "duration":
          hourDuration = DateHelper.diff(currentOrProposedStartDate, currentOrProposedEndDate, "h");
          changed.duration = DateHelper.as(currentOrProposedDurationUnit, hourDuration, "h");
          break;
      }
      if ("startDate" in changed && changed.startDate !== true)
        this._startDate = changed.startDate;
      if ("endDate" in changed && changed.endDate !== true)
        this._endDate = changed.endDate;
      if ("duration" in changed && changed.duration !== true)
        this._duration = changed.duration;
      delete changed.keepDuration;
      delete changed.keepStart;
    }
  }
  return CoreEventMixin2;
}) {
};
var CoreResourceMixin = class extends Mixin([CorePartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CoreResourceMixin2 extends base {
    get assigned() {
      var _this$project;
      return (_this$project = this.project) === null || _this$project === void 0 ? void 0 : _this$project.assignmentStore.getResourcesAssignments(this);
    }
    joinProject() {
      if (this.resourceStore && !this.resourceStore.isLoadingData) {
        var _this$assignmentStore;
        (_this$assignmentStore = this.assignmentStore) === null || _this$assignmentStore === void 0 ? void 0 : _this$assignmentStore.query((a) => a.get("resource") === this.id).forEach((unresolved) => unresolved.setChanged("resource", this));
      }
      superProto.joinProject.call(this);
    }
    leaveProject(isReplacing = false) {
      if (this.assigned && !isReplacing) {
        const resourceStore = this.resourceStore;
        this.assigned.forEach((assignment) => resourceStore.assignmentsForRemoval.add(assignment));
      }
      superProto.leaveProject.call(this);
    }
    applyValue(useProp, key, value, skipAccessor, field) {
      if ((field === null || field === void 0 ? void 0 : field.name) === "id") {
        this.assigned.forEach((assignment) => {
          assignment.set("resourceId", value);
        });
      }
      superProto.applyValue.call(this, useProp, key, value, skipAccessor, field);
    }
  }
  return CoreResourceMixin2;
}) {
};
var CoreAssignmentMixin = class extends Mixin([CorePartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CoreAssignmentMixin2 extends base {
    static get fields() {
      return [
        {
          name: "resource",
          isEqual: (a, b) => a === b,
          persist: false
        },
        {
          name: "event",
          isEqual: (a, b) => a === b,
          persist: false
        }
      ];
    }
    setChanged(field, value, invalidate) {
      const {
        assignmentStore,
        eventStore,
        resourceStore,
        project
      } = this;
      let update = false;
      if (field === "event") {
        const event = isInstanceOf(value, CoreEventMixin) ? value : eventStore === null || eventStore === void 0 ? void 0 : eventStore.$master.getById(value);
        if (event)
          update = true;
        value = event || value;
      }
      if (field === "resource") {
        const resource = isInstanceOf(value, CoreResourceMixin) ? value : resourceStore === null || resourceStore === void 0 ? void 0 : resourceStore.$master.getById(value);
        if (resource)
          update = true;
        value = resource || value;
      }
      superProto.setChanged.call(this, field, value, invalidate, true);
      if (assignmentStore && update && !project.isPerformingCommit && !assignmentStore.isLoadingData && !resourceStore.isLoadingData && !assignmentStore.skipInvalidateIndices) {
        assignmentStore.invalidateIndices();
      }
    }
    joinProject() {
      superProto.joinProject.call(this);
      this.setChanged("event", this.get("event"));
      this.setChanged("resource", this.get("resource"));
    }
    calculateInvalidated() {
      let {
        event = this.event,
        resource = this.resource
      } = this.$changed;
      if (event !== null && !isInstanceOf(event, CoreEventMixin)) {
        var _this$eventStore;
        const resolved = (_this$eventStore = this.eventStore) === null || _this$eventStore === void 0 ? void 0 : _this$eventStore.getById(event);
        if (resolved)
          this.setChanged("event", resolved, false);
      }
      if (resource !== null && !isInstanceOf(resource, CoreResourceMixin)) {
        var _this$resourceStore;
        const resolved = (_this$resourceStore = this.resourceStore) === null || _this$resourceStore === void 0 ? void 0 : _this$resourceStore.getById(resource);
        if (resolved)
          this.setChanged("resource", resolved, false);
      }
    }
    finalizeInvalidated(silent) {
      const changed = this.$changed;
      if ("resource" in changed) {
        var _changed$resource;
        changed.resourceId = (_changed$resource = changed.resource) !== null && _changed$resource !== void 0 && _changed$resource.isModel ? changed.resource.id : changed.resource;
      }
      if ("event" in changed) {
        var _changed$event;
        changed.eventId = (_changed$event = changed.event) !== null && _changed$event !== void 0 && _changed$event.isModel ? changed.event.id : changed.event;
      }
      superProto.finalizeInvalidated.call(this, silent);
    }
    set event(event) {
      this.setChanged("event", event);
    }
    get event() {
      const event = this.get("event");
      return (event === null || event === void 0 ? void 0 : event.id) != null ? event : null;
    }
    set resource(resource) {
      this.setChanged("resource", resource);
    }
    get resource() {
      const resource = this.get("resource");
      return (resource === null || resource === void 0 ? void 0 : resource.id) != null ? resource : null;
    }
  }
  return CoreAssignmentMixin2;
}) {
};
var CorePartOfProjectStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin, CorePartOfProjectGenericMixin, Store], (base) => {
  const superProto = base.prototype;
  class CorePartOfProjectStoreMixin2 extends base {
    setProject(project) {
      const result = superProto.setProject.call(this, project);
      if (project)
        this.joinProject(project);
      return result;
    }
    joinProject(project) {
    }
    onCommitAsync() {
    }
  }
  return CorePartOfProjectStoreMixin2;
}) {
};
var emptySet$1 = /* @__PURE__ */ new Set();
var CoreAssignmentStoreMixin = class extends Mixin([AbstractAssignmentStoreMixin, CorePartOfProjectStoreMixin], (base) => {
  base.prototype;
  class CoreAssignmentStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.skipInvalidateIndices = false;
    }
    static get defaultConfig() {
      return {
        modelClass: CoreAssignmentMixin,
        storage: {
          extraKeys: [{
            property: "event",
            unique: false
          }, {
            property: "resource",
            unique: false
          }, {
            property: "eventId",
            unique: false
          }]
        }
      };
    }
    set data(value) {
      this.allAssignmentsForRemoval = true;
      super.data = value;
      this.allAssignmentsForRemoval = false;
    }
    getEventsAssignments(event) {
      return this.storage.findItem("event", event, true) || emptySet$1;
    }
    getResourcesAssignments(resource) {
      return this.storage.findItem("resource", resource.$original, true) || emptySet$1;
    }
    updateIndices() {
      this.storage.rebuildIndices();
    }
    invalidateIndices() {
      this.storage.invalidateIndices();
    }
    afterLoadData() {
      this.eventStore && this.linkAssignments(this.eventStore, "event");
      this.resourceStore && this.linkAssignments(this.resourceStore, "resource");
    }
    linkAssignments(store, modelName) {
      store = store.masterStore || store;
      const unresolved = this.count && this.storage.findItem(modelName, null, true);
      if (unresolved) {
        for (const assignment of unresolved) {
          const record = store.getById(assignment.getCurrentOrProposed(modelName));
          if (record)
            assignment.setChanged(modelName, record);
        }
        this.invalidateIndices();
      }
    }
    unlinkAssignments(modelName) {
      this.forEach((assignment) => {
        var _ref, _assignment$modelName, _assignment$modelName2;
        return assignment.setChanged(modelName, (_ref = (_assignment$modelName = (_assignment$modelName2 = assignment[modelName]) === null || _assignment$modelName2 === void 0 ? void 0 : _assignment$modelName2.id) !== null && _assignment$modelName !== void 0 ? _assignment$modelName : assignment === null || assignment === void 0 ? void 0 : assignment.getData(modelName)) !== null && _ref !== void 0 ? _ref : assignment[modelName + "Id"]);
      });
      this.invalidateIndices();
    }
    onCommitAsync() {
      this.updateIndices();
    }
  }
  return CoreAssignmentStoreMixin2;
}) {
};
var CoreCalendarMixin = class extends Mixin([AbstractCalendarMixin, CorePartOfProjectModelMixin], (base) => {
  base.prototype;
  class CoreCalendarMixin2 extends base {
  }
  return CoreCalendarMixin2;
}) {
};
var CoreCalendarManagerStoreMixin = class extends Mixin([AbstractCalendarManagerStoreMixin, CorePartOfProjectStoreMixin], (base) => {
  base.prototype;
  class CoreCalendarManagerStoreMixin2 extends base {
    static get defaultConfig() {
      return {
        tree: true,
        modelClass: CoreCalendarMixin
      };
    }
  }
  return CoreCalendarManagerStoreMixin2;
}) {
};
var CoreDependencyMixin = class extends Mixin([CorePartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CoreDependencyMixin2 extends base {
    static get fields() {
      return [{
        name: "fromEvent",
        isEqual: (a, b) => a === b,
        persist: false
      }, {
        name: "toEvent",
        isEqual: (a, b) => a === b,
        persist: false
      }];
    }
    setChanged(field, value, invalidate) {
      var _this$dependencyStore;
      let update = false;
      if (field === "fromEvent" || field === "toEvent") {
        var _this$eventStore;
        const event = isInstanceOf(value, CoreEventMixin) ? value : (_this$eventStore = this.eventStore) === null || _this$eventStore === void 0 ? void 0 : _this$eventStore.getById(value);
        if (event)
          update = true;
        value = event || value;
      }
      superProto.setChanged.call(this, field, value, invalidate, true);
      if (update && !this.project.isPerformingCommit && !((_this$dependencyStore = this.dependencyStore) !== null && _this$dependencyStore !== void 0 && _this$dependencyStore.isLoadingData)) {
        var _this$dependencyStore2;
        (_this$dependencyStore2 = this.dependencyStore) === null || _this$dependencyStore2 === void 0 ? void 0 : _this$dependencyStore2.invalidateIndices();
      }
    }
    joinProject() {
      superProto.joinProject.call(this);
      this.setChanged("fromEvent", this.get("fromEvent"));
      this.setChanged("toEvent", this.get("toEvent"));
    }
    calculateInvalidated() {
      let {
        fromEvent,
        toEvent
      } = this.$changed;
      if (fromEvent !== null && !isInstanceOf(fromEvent, CoreEventMixin)) {
        var _this$eventStore2;
        const resolved = (_this$eventStore2 = this.eventStore) === null || _this$eventStore2 === void 0 ? void 0 : _this$eventStore2.getById(fromEvent);
        if (resolved)
          this.$changed.fromEvent = resolved;
      }
      if (toEvent !== null && !isInstanceOf(toEvent, CoreEventMixin)) {
        var _this$eventStore3;
        const resolved = (_this$eventStore3 = this.eventStore) === null || _this$eventStore3 === void 0 ? void 0 : _this$eventStore3.getById(toEvent);
        if (resolved)
          this.$changed.toEvent = resolved;
      }
    }
    set fromEvent(fromEvent) {
      this.setChanged("fromEvent", fromEvent);
    }
    get fromEvent() {
      const fromEvent = this.get("fromEvent");
      return (fromEvent === null || fromEvent === void 0 ? void 0 : fromEvent.id) != null ? fromEvent : null;
    }
    set toEvent(toEvent) {
      this.setChanged("toEvent", toEvent);
    }
    get toEvent() {
      const toEvent = this.get("toEvent");
      return (toEvent === null || toEvent === void 0 ? void 0 : toEvent.id) != null ? toEvent : null;
    }
  }
  return CoreDependencyMixin2;
}) {
};
var emptySet = /* @__PURE__ */ new Set();
var CoreDependencyStoreMixin = class extends Mixin([AbstractDependencyStoreMixin, CorePartOfProjectStoreMixin], (base) => {
  base.prototype;
  class CoreDependencyStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.dependenciesForRemoval = /* @__PURE__ */ new Set();
      this.allDependenciesForRemoval = false;
    }
    static get defaultConfig() {
      return {
        modelClass: CoreDependencyMixin,
        storage: {
          extraKeys: [{
            property: "fromEvent",
            unique: false
          }, {
            property: "toEvent",
            unique: false
          }]
        }
      };
    }
    getIncomingDepsForEvent(event) {
      return this.storage.findItem("toEvent", event) || emptySet;
    }
    getOutgoingDepsForEvent(event) {
      return this.storage.findItem("fromEvent", event) || emptySet;
    }
    set data(value) {
      this.allDependenciesForRemoval = true;
      super.data = value;
      this.allDependenciesForRemoval = false;
    }
    updateIndices() {
      this.storage.rebuildIndices();
    }
    invalidateIndices() {
      this.storage.invalidateIndices();
    }
    onCommitAsync() {
      this.updateIndices();
    }
  }
  return CoreDependencyStoreMixin2;
}) {
};
var CoreHasAssignmentsMixin = class extends Mixin([CoreEventMixin, AbstractHasAssignmentsMixin], (base) => {
  const superProto = base.prototype;
  class CoreHasAssignmentsMixin2 extends base {
    get assigned() {
      var _this$project$assignm, _this$project;
      return (_this$project$assignm = (_this$project = this.project) === null || _this$project === void 0 ? void 0 : _this$project.assignmentStore.getEventsAssignments(this)) !== null && _this$project$assignm !== void 0 ? _this$project$assignm : this.$cachedAssignments;
    }
    leaveProject(isReplacing = false) {
      this.$cachedAssignments = this.assigned;
      super.leaveProject(isReplacing);
    }
    applyValue(useProp, key, value, skipAccessor, field) {
      if (key === "id") {
        var _this$assigned;
        (_this$assigned = this.assigned) === null || _this$assigned === void 0 ? void 0 : _this$assigned.forEach((assignment) => assignment.set("eventId", value));
      }
      superProto.applyValue.call(this, useProp, key, value, skipAccessor, field);
    }
    copy(newId = null, deep = null) {
      const copy = superProto.copy.call(this, newId, deep);
      if (ObjectHelper.isObject(deep) && !deep.skipFieldIdentifiers || !ObjectHelper.isObject(deep)) {
        copy.$cachedAssignments = this.assigned;
      }
      return copy;
    }
  }
  return CoreHasAssignmentsMixin2;
}) {
};
var CoreHasDependenciesMixin = class extends Mixin([CoreEventMixin], (base) => {
  const superProto = base.prototype;
  class CoreHasDependenciesMixin2 extends base {
    get outgoingDeps() {
      return this.project.dependencyStore.getOutgoingDepsForEvent(this);
    }
    get incomingDeps() {
      return this.project.dependencyStore.getIncomingDepsForEvent(this);
    }
    leaveProject() {
      const eventStore = this.eventStore;
      if (this.outgoingDeps) {
        this.outgoingDeps.forEach((dependency) => eventStore.dependenciesForRemoval.add(dependency));
      }
      if (this.incomingDeps) {
        this.incomingDeps.forEach((dependency) => eventStore.dependenciesForRemoval.add(dependency));
      }
      superProto.leaveProject.call(this);
    }
  }
  return CoreHasDependenciesMixin2;
}) {
};
var SchedulerCoreEvent = class extends Mixin([CoreEventMixin, CoreHasAssignmentsMixin, CoreHasDependenciesMixin], (base) => {
  base.prototype;
  class SchedulerCoreEvent2 extends base {
  }
  return SchedulerCoreEvent2;
}) {
};
var CoreEventStoreMixin = class extends Mixin([AbstractEventStoreMixin, CorePartOfProjectStoreMixin], (base) => {
  base.prototype;
  class CoreEventStoreMixin2 extends base {
    static get defaultConfig() {
      return {
        modelClass: SchedulerCoreEvent
      };
    }
    joinProject() {
      var _this$assignmentStore;
      (_this$assignmentStore = this.assignmentStore) === null || _this$assignmentStore === void 0 ? void 0 : _this$assignmentStore.linkAssignments(this, "event");
    }
    afterLoadData() {
      var _this$assignmentStore2;
      this.afterEventRemoval();
      (_this$assignmentStore2 = this.assignmentStore) === null || _this$assignmentStore2 === void 0 ? void 0 : _this$assignmentStore2.linkAssignments(this, "event");
    }
  }
  return CoreEventStoreMixin2;
}) {
};
var CoreResourceStoreMixin = class extends Mixin([AbstractResourceStoreMixin, CorePartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class CoreResourceStoreMixin2 extends base {
    static get defaultConfig() {
      return {
        modelClass: CoreResourceMixin
      };
    }
    joinProject() {
      var _this$assignmentStore;
      (_this$assignmentStore = this.assignmentStore) === null || _this$assignmentStore === void 0 ? void 0 : _this$assignmentStore.linkAssignments(this, "resource");
    }
    afterLoadData() {
      var _this$assignmentStore2;
      (_this$assignmentStore2 = this.assignmentStore) === null || _this$assignmentStore2 === void 0 ? void 0 : _this$assignmentStore2.linkAssignments(this, "resource");
    }
    clear(removing) {
      var _this$assignmentStore3;
      superProto.clear.call(this, removing);
      (_this$assignmentStore3 = this.assignmentStore) === null || _this$assignmentStore3 === void 0 ? void 0 : _this$assignmentStore3.unlinkAssignments("resource");
    }
  }
  return CoreResourceStoreMixin2;
}) {
};
var EventsWrapper = class extends Mixin([], Events) {
};
var DelayableWrapper$1 = class extends Mixin([], Delayable) {
};
var AbstractProjectMixin = class extends Mixin([EventsWrapper, DelayableWrapper$1, Model], (base) => {
  const superProto = base.prototype;
  class AbstractProjectMixin2 extends base {
    constructor() {
      super(...arguments);
      this.isRestoringData = false;
    }
    get isRepopulatingStores() {
      return false;
    }
    get isInitialCommit() {
      return !this.isInitialCommitPerformed || this.hasLoadedDataToCommit;
    }
    construct(config = {}) {
      this.isInitialCommitPerformed = false;
      this.isLoadingInlineData = false;
      this.isWritingData = false;
      this.hasLoadedDataToCommit = false;
      const silenceInitialCommit = "silenceInitialCommit" in config ? config.silenceInitialCommit : true;
      const adjustDurationToDST = "adjustDurationToDST" in config ? config.adjustDurationToDST : false;
      this.maxCalendarRange = "maxCalendarRange" in config ? config.maxCalendarRange : 15768e7;
      delete config.maxCalendarRange;
      delete config.silenceInitialCommit;
      delete config.adjustDurationToDST;
      superProto.construct.call(this, config);
      this.silenceInitialCommit = silenceInitialCommit;
      this.adjustDurationToDST = adjustDurationToDST;
    }
    repopulateStore(store) {
    }
    repopulateReplica() {
    }
    deferUntilRepopulationIfNeeded(deferId, func, args) {
      func(...args);
    }
    attachStore(store) {
    }
    detachStore(store) {
    }
    async commitAsync() {
      throw new Error("Abstract method called");
    }
    isEngineReady() {
      throw new Error("Abstract method called");
    }
    getStm() {
      throw new Error("Abstract method called");
    }
  }
  return AbstractProjectMixin2;
}) {
};
var DelayableWrapper = class extends Mixin([], Delayable) {
};
var SchedulerCoreProjectMixin = class extends Mixin([AbstractProjectMixin, CorePartOfProjectGenericMixin, DelayableWrapper, Model], (base) => {
  const superProto = base.prototype;
  class SchedulerCoreProjectMixin2 extends base {
    static get configurable() {
      return {
        stm: {},
        eventStore: {},
        assignmentStore: {},
        resourceStore: {},
        dependencyStore: {},
        calendarManagerStore: {},
        eventModelClass: SchedulerCoreEvent,
        assignmentModelClass: CoreAssignmentMixin,
        resourceModelClass: CoreResourceMixin,
        dependencyModelClass: CoreDependencyMixin,
        calendarModelClass: CoreCalendarMixin,
        eventStoreClass: CoreEventStoreMixin,
        assignmentStoreClass: CoreAssignmentStoreMixin,
        resourceStoreClass: CoreResourceStoreMixin,
        dependencyStoreClass: CoreDependencyStoreMixin,
        calendarManagerStoreClass: CoreCalendarManagerStoreMixin,
        assignmentsData: null,
        calendarsData: null,
        dependenciesData: null,
        eventsData: null,
        resourcesData: null
      };
    }
    construct(config = {}) {
      const me = this;
      me.$invalidated = /* @__PURE__ */ new Set();
      me.isPerformingCommit = false;
      me.silenceInitialCommit = true;
      me.ongoing = Promise.resolve();
      if (config.eventStore && !config.assignmentStore) {
        var _eventStore$assignmen;
        const eventStore = config.eventStore.masterStore || config.eventStore;
        if ((_eventStore$assignmen = eventStore.assignmentStore) !== null && _eventStore$assignmen !== void 0 && _eventStore$assignmen.isAssignmentStore) {
          config.assignmentStore = eventStore.assignmentStore;
          me.isSharingAssignmentStore = true;
        }
      }
      superProto.construct.call(me, config);
      me.defaultCalendar = new me.calendarManagerStore.modelClass({
        unspecifiedTimeIsWorking: me.unspecifiedTimeIsWorking
      });
      me.defaultCalendar.project = me;
      const {
        calendarsData,
        eventsData,
        dependenciesData,
        resourcesData,
        assignmentsData
      } = me;
      const hasInlineData = Boolean(calendarsData || eventsData || dependenciesData || resourcesData || assignmentsData);
      if (hasInlineData) {
        me.loadInlineData({
          calendarsData,
          eventsData,
          dependenciesData,
          resourcesData,
          assignmentsData
        });
        delete me.calendarsData;
        delete me.eventsData;
        delete me.dependenciesData;
        delete me.resourcesData;
        delete me.assignmentsData;
      } else {
        me.bufferedCommitAsync();
      }
    }
    doDestroy() {
      var _me$eventStore, _me$dependencyStore, _me$assignmentStore, _me$resourceStore, _me$calendarManagerSt, _me$stm;
      const me = this;
      (_me$eventStore = me.eventStore) === null || _me$eventStore === void 0 ? void 0 : _me$eventStore.destroy();
      (_me$dependencyStore = me.dependencyStore) === null || _me$dependencyStore === void 0 ? void 0 : _me$dependencyStore.destroy();
      (_me$assignmentStore = me.assignmentStore) === null || _me$assignmentStore === void 0 ? void 0 : _me$assignmentStore.destroy();
      (_me$resourceStore = me.resourceStore) === null || _me$resourceStore === void 0 ? void 0 : _me$resourceStore.destroy();
      (_me$calendarManagerSt = me.calendarManagerStore) === null || _me$calendarManagerSt === void 0 ? void 0 : _me$calendarManagerSt.destroy();
      me.defaultCalendar.destroy();
      (_me$stm = me.stm) === null || _me$stm === void 0 ? void 0 : _me$stm.destroy();
      superProto.doDestroy.call(this);
    }
    async loadInlineData(data) {
      const me = this;
      me.isLoadingInlineData = true;
      if (data.calendarsData) {
        me.calendarManagerStore.data = data.calendarsData;
      }
      if (data.resourcesData) {
        me.resourceStore.data = data.resourcesData;
      }
      if (data.assignmentsData) {
        me.assignmentStore.data = data.assignmentsData;
      }
      if (data.eventsData) {
        me.eventStore.data = data.eventsData;
      }
      if (data.tasksData) {
        me.eventStore.data = data.tasksData;
      }
      if (data.dependenciesData) {
        me.dependencyStore.data = data.dependenciesData;
      }
      await me.commitLoad();
      me.isLoadingInlineData = false;
      return;
    }
    async commitLoad() {
      await this.commitAsync();
      if (!this.isDestroyed)
        this.trigger("load");
    }
    joinStoreRecords(store) {
      const fn2 = (record) => {
        record.setProject(this);
        record.joinProject();
      };
      if (store.rootNode) {
        store.rootNode.traverse(fn2);
      } else {
        store.forEach(fn2);
      }
    }
    unJoinStoreRecords(store) {
      const fn2 = (record) => {
        record.leaveProject();
        record.setProject(this);
      };
      if (store.rootNode) {
        store.rootNode.traverse((node) => {
          if (node !== store.rootNode)
            fn2(node);
        });
      } else {
        store.forEach(fn2);
      }
    }
    resolveStoreAndModelClass(name, config) {
      const storeClass = (config === null || config === void 0 ? void 0 : config.storeClass) || this[`${name}StoreClass`];
      let modelClass = config === null || config === void 0 ? void 0 : config.modelClass;
      if (!modelClass) {
        if (this.getDefaultConfiguration()[`${name}ModelClass`] !== storeClass.getDefaultConfiguration().modelClass) {
          modelClass = storeClass.getDefaultConfiguration().modelClass;
        } else {
          modelClass = this[`${name}ModelClass`];
        }
      }
      return {
        storeClass,
        modelClass
      };
    }
    setEventStore(eventStore) {
      this.eventStore = eventStore;
    }
    changeEventStore(eventStore, oldStore) {
      const me = this, {
        stm
      } = me;
      me.detachStore(oldStore);
      if (!(eventStore instanceof Store)) {
        const {
          storeClass,
          modelClass
        } = me.resolveStoreAndModelClass("event", eventStore);
        eventStore = new storeClass(ObjectHelper.assign({
          modelClass,
          project: me,
          stm
        }, eventStore));
      } else {
        eventStore.project = me;
        stm.addStore(eventStore);
        me.joinStoreRecords(eventStore);
      }
      if (oldStore && stm.hasStore(oldStore)) {
        stm.removeStore(oldStore);
        me.unJoinStoreRecords(oldStore);
        const {
          assignmentsForRemoval
        } = oldStore;
        assignmentsForRemoval.forEach((assignment) => {
          const oldEvent = assignment.event;
          if (oldEvent) {
            const newEvent = eventStore.getById(oldEvent.id);
            if (newEvent) {
              assignment.event = newEvent;
              assignmentsForRemoval.delete(assignment);
            }
          }
        });
        oldStore.afterEventRemoval();
      }
      eventStore.setProject(me);
      return eventStore;
    }
    updateEventStore(eventStore, oldStore) {
      this.attachStore(eventStore);
      this.trigger("eventStoreChange", {
        store: eventStore
      });
    }
    setAssignmentStore(assignmentStore) {
      this.assignmentStore = assignmentStore;
    }
    changeAssignmentStore(assignmentStore, oldStore) {
      const me = this, {
        stm
      } = me;
      me.detachStore(oldStore);
      if (oldStore && stm.hasStore(oldStore)) {
        stm.removeStore(oldStore);
        me.unJoinStoreRecords(oldStore);
      }
      if (!(assignmentStore instanceof Store)) {
        const {
          storeClass,
          modelClass
        } = me.resolveStoreAndModelClass("assignment", assignmentStore);
        assignmentStore = new storeClass(ObjectHelper.assign({
          modelClass,
          project: me,
          stm
        }, assignmentStore));
      } else {
        assignmentStore.project = me;
        stm.addStore(assignmentStore);
        me.joinStoreRecords(assignmentStore);
      }
      assignmentStore.setProject(me);
      return assignmentStore;
    }
    updateAssignmentStore(assignmentStore, oldStore) {
      this.attachStore(assignmentStore);
      this.trigger("assignmentStoreChange", {
        store: assignmentStore
      });
    }
    setResourceStore(resourceStore) {
      this.resourceStore = resourceStore;
    }
    changeResourceStore(resourceStore, oldStore) {
      const me = this, {
        stm
      } = me;
      me.detachStore(oldStore);
      if (!(resourceStore instanceof Store)) {
        const {
          storeClass,
          modelClass
        } = me.resolveStoreAndModelClass("resource", resourceStore);
        resourceStore = new storeClass(ObjectHelper.assign({
          modelClass,
          project: me,
          stm
        }, resourceStore));
      } else {
        resourceStore.project = me;
        stm.addStore(resourceStore);
        me.joinStoreRecords(resourceStore);
      }
      if (oldStore && stm.hasStore(oldStore)) {
        stm.removeStore(oldStore);
        me.unJoinStoreRecords(oldStore);
        const {
          assignmentsForRemoval
        } = oldStore;
        assignmentsForRemoval.forEach((assignment) => {
          const oldResource = assignment.resource;
          if (oldResource) {
            const newResource = resourceStore.getById(oldResource.id);
            if (newResource) {
              assignment.resource = newResource;
              assignmentsForRemoval.delete(assignment);
            }
          }
        });
        oldStore.afterResourceRemoval();
      }
      resourceStore.setProject(me);
      return resourceStore;
    }
    updateResourceStore(resourceStore, oldStore) {
      this.attachStore(resourceStore);
      this.trigger("resourceStoreChange", {
        store: resourceStore
      });
    }
    setDependencyStore(dependencyStore) {
      this.dependencyStore = dependencyStore;
    }
    changeDependencyStore(dependencyStore, oldStore) {
      const me = this;
      me.detachStore(oldStore);
      if (!(dependencyStore instanceof Store)) {
        const {
          storeClass,
          modelClass
        } = me.resolveStoreAndModelClass("dependency", dependencyStore);
        dependencyStore = new storeClass(ObjectHelper.assign({
          modelClass,
          project: me,
          stm: me.stm
        }, dependencyStore));
      } else {
        dependencyStore.project = me;
        me.stm.addStore(dependencyStore);
        me.joinStoreRecords(dependencyStore);
      }
      return dependencyStore;
    }
    updateDependencyStore(dependencyStore, oldStore) {
      this.attachStore(dependencyStore);
      this.trigger("dependencyStoreChange", {
        store: dependencyStore
      });
    }
    setCalendarManagerStore(calendarManagerStore) {
      this.calendarManagerStore = calendarManagerStore;
    }
    changeCalendarManagerStore(calendarManagerStore, oldStore) {
      const me = this;
      me.detachStore(oldStore);
      if (!(calendarManagerStore instanceof Store)) {
        var _calendarManagerStore, _calendarManagerStore2;
        const storeClass = ((_calendarManagerStore = calendarManagerStore) === null || _calendarManagerStore === void 0 ? void 0 : _calendarManagerStore.storeClass) || me.calendarManagerStoreClass;
        const modelClass = ((_calendarManagerStore2 = calendarManagerStore) === null || _calendarManagerStore2 === void 0 ? void 0 : _calendarManagerStore2.modelClass) || storeClass.getDefaultConfiguration().modelClass || me.calendarModelClass;
        calendarManagerStore = new storeClass(ObjectHelper.assign({
          modelClass,
          project: me,
          stm: me.stm
        }, calendarManagerStore));
      } else {
        me.stm.addStore(calendarManagerStore);
      }
      calendarManagerStore.setProject(me);
      return calendarManagerStore;
    }
    updateCalendarManagerStore(calendarManagerStore, oldStore) {
      this.attachStore(calendarManagerStore);
      this.trigger("calendarManagerStoreChange", {
        store: calendarManagerStore
      });
    }
    get calendar() {
      return this.$calendar || this.defaultCalendar;
    }
    set calendar(calendar) {
      this.$calendar = calendar;
    }
    get effectiveCalendar() {
      return this.calendar;
    }
    async addEvent(event) {
      this.eventStore.add(event);
      return this.commitAsync();
    }
    async addAssignment(assignment) {
      this.assignmentStore.add(assignment);
      return this.commitAsync();
    }
    async addResource(resource) {
      this.resourceStore.add(resource);
      return this.commitAsync();
    }
    async addDependency(dependency) {
      this.dependencyStore.add(dependency);
      return this.commitAsync();
    }
    bufferedCommitAsync() {
      if (!this.hasPendingAutoCommit) {
        this.setTimeout({
          fn: "commitAsync",
          delay: 10
        });
      }
    }
    get hasPendingAutoCommit() {
      return this.hasTimeout("commitAsync");
    }
    unScheduleAutoCommit() {
      this.clearTimeout("commitAsync");
    }
    async commitAsync() {
      if (this.isPerformingCommit)
        return this.ongoing;
      return this.ongoing = this.doCommitAsync();
    }
    async doCommitAsync() {
      const me = this;
      me.isPerformingCommit = true;
      me.unScheduleAutoCommit();
      await delay(0);
      if (!me.isDestroyed) {
        for (const record of me.$invalidated) {
          record.calculateInvalidated();
        }
        const {
          isInitialCommit,
          silenceInitialCommit
        } = me;
        const silenceCommit = isInitialCommit && silenceInitialCommit;
        me.assignmentStore.onCommitAsync();
        me.dependencyStore.onCommitAsync();
        me.isInitialCommitPerformed = true;
        me.hasLoadedDataToCommit = false;
        me.isPerformingCommit = false;
        const stores2 = [me.assignmentStore, me.dependencyStore, me.eventStore, me.resourceStore, me.calendarManagerStore];
        stores2.forEach((store) => {
          var _store$suspendAutoCom;
          return (_store$suspendAutoCom = store.suspendAutoCommit) === null || _store$suspendAutoCom === void 0 ? void 0 : _store$suspendAutoCom.call(store);
        });
        me.isWritingData = true;
        me.trigger("refresh", {
          isInitialCommit,
          isCalculated: true
        });
        if (silenceCommit) {
          for (const record of me.$invalidated) {
            record.finalizeInvalidated(true);
          }
        } else {
          for (const record of me.$invalidated) {
            record.beginBatch(true);
            record.finalizeInvalidated();
          }
          for (const record of me.$invalidated) {
            record.endBatch(false, true);
          }
        }
        me.isWritingData = false;
        me.$invalidated.clear();
        me.trigger("dataReady");
        stores2.forEach((store) => {
          var _store$resumeAutoComm;
          return (_store$resumeAutoComm = store.resumeAutoCommit) === null || _store$resumeAutoComm === void 0 ? void 0 : _store$resumeAutoComm.call(store);
        });
        me.trigger("commitFinalized");
        return true;
      }
    }
    async propagateAsync() {
      return this.commitAsync();
    }
    invalidate(record) {
      this.$invalidated.add(record);
      this.bufferedCommitAsync();
    }
    async isValidDependency() {
      return true;
    }
    getStm() {
      return this.stm;
    }
    set stm(stm) {
      stm = this.$stm = new StateTrackingManager(ObjectHelper.assign({
        disabled: true
      }, stm));
      stm.ion({
        restoringStop: async () => {
          stm.disable();
          await this.commitAsync();
          if (!this.isDestroyed) {
            stm.enable();
            this.trigger("stateRestoringDone");
          }
        }
      });
    }
    get stm() {
      return this.$stm;
    }
    isEngineReady() {
      return !this.hasPendingAutoCommit && !this.isPerformingCommit && this.isInitialCommitPerformed;
    }
  }
  SchedulerCoreProjectMixin2.applyConfigs = true;
  return SchedulerCoreProjectMixin2;
}) {
};
var DurationColumn = class extends NumberColumn {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "compositeField", true);
  }
  static get $name() {
    return "DurationColumn";
  }
  static get type() {
    return "duration";
  }
  static get isGanttColumn() {
    return true;
  }
  static get fields() {
    return [
      {
        name: "decimalPrecision",
        defaultValue: 1
      }
    ];
  }
  static get defaults() {
    return {
      min: null,
      max: null,
      step: 1,
      largeStep: 0,
      field: "fullDuration",
      text: "L{Duration}",
      instantUpdate: true,
      filterType: "duration",
      sortable(durationEntity1, durationEntity2) {
        const ms1 = durationEntity1[this.field], ms2 = durationEntity2[this.field];
        return ms1 - ms2;
      }
    };
  }
  construct() {
    super.construct(...arguments);
    const sortFn = this.sortable;
    this.sortable = (...args) => sortFn.call(this, ...args);
  }
  get defaultEditor() {
    const {
      max,
      min: min2,
      step,
      largeStep
    } = this;
    return ObjectHelper.cleanupProperties({
      type: "duration",
      name: this.field,
      max,
      min: min2,
      step,
      largeStep
    });
  }
  get durationUnitField() {
    return `${this.field}Unit`;
  }
  formatValue(duration, durationUnit) {
    if (duration instanceof Duration) {
      durationUnit = duration.unit;
      duration = duration.magnitude;
    }
    const nbrDecimals = typeof this.grid.durationDisplayPrecision === "number" ? this.grid.durationDisplayPrecision : this.decimalPrecision, multiplier = Math.pow(10, nbrDecimals), rounded = Math.round(duration * multiplier) / multiplier;
    return rounded + " " + DateHelper.getLocalizedNameOfUnit(durationUnit, duration !== 1);
  }
  defaultRenderer({
    record,
    isExport
  }) {
    const value = record[this.field], type = typeof value, durationValue = type === "number" ? value : value === null || value === void 0 ? void 0 : value.magnitude, durationUnit = type === "number" ? record[this.durationUnitField] : value === null || value === void 0 ? void 0 : value.unit;
    if (typeof durationValue !== "number") {
      return isExport ? "" : null;
    }
    return this.formatValue(durationValue, durationUnit);
  }
  toClipboardString({
    record
  }) {
    return record[this.field].toString();
  }
  fromClipboardString({
    string: string2,
    record
  }) {
    const duration = DateHelper.parseDuration(string2, true, this.durationUnit);
    if (duration && "magnitude" in duration) {
      return duration;
    }
    return record.fullDuration;
  }
  calculateFillValue({
    value,
    record
  }) {
    return this.fromClipboardString({
      string: value,
      record
    });
  }
};
ColumnStore.registerColumnType(DurationColumn);
DurationColumn._$name = "DurationColumn";
var ResourceCollapseColumn = class extends Column {
  static get $name() {
    return "ResourceCollapseColumn";
  }
  static get type() {
    return "resourceCollapse";
  }
  static get defaults() {
    return {
      width: "3em",
      align: "center",
      sortable: false,
      groupable: false,
      editor: false,
      minWidth: 0,
      cellCls: "b-resourcecollapse-cell",
      renderer: ({
        record
      }) => ({
        tag: "i",
        class: {
          "b-icon": 1,
          "b-icon-expand-resource": 1,
          "b-flip": record.eventLayout !== "none"
        }
      })
    };
  }
  onCellClick({
    record,
    event
  }) {
    event.preventDefault();
    record.eventLayout = record.eventLayout !== "none" ? "none" : "stack";
  }
};
ColumnStore.registerColumnType(ResourceCollapseColumn);
ResourceCollapseColumn._$name = "ResourceCollapseColumn";
var ResourceInfoColumn = class extends Column {
  static get $name() {
    return "ResourceInfoColumn";
  }
  static get type() {
    return "resourceInfo";
  }
  static get fields() {
    return ["showEventCount", "showRole", "showMeta", "showImage", "validNames", "autoScaleThreshold", "useNameAsImageName"];
  }
  static get defaults() {
    return {
      showImage: true,
      showEventCount: true,
      showMeta: null,
      showRole: false,
      validNames: null,
      autoScaleThreshold: 40,
      useNameAsImageName: true,
      field: "name",
      htmlEncode: false,
      width: 140,
      cellCls: "b-resourceinfo-cell",
      editor: VersionHelper.isTestEnv ? false : "text"
    };
  }
  construct(...args) {
    super.construct(...args);
    this.avatarRendering = new AvatarRendering({
      element: this.grid.element
    });
  }
  doDestroy() {
    super.doDestroy();
    this.avatarRendering.destroy();
  }
  getImageURL(imageName) {
    const resourceImagePath = this.grid.resourceImagePath || "", parts = resourceImagePath.split("//"), urlPart = parts.length > 1 ? parts[1] : resourceImagePath, joined = StringHelper.joinPaths([urlPart || "", imageName || ""]);
    return parts.length > 1 ? parts[0] + "//" + joined : joined;
  }
  template(resourceRecord, value) {
    const me = this, {
      showImage,
      showRole,
      showMeta,
      showEventCount,
      grid
    } = me, {
      timeAxis,
      resourceImageExtension = "",
      defaultResourceImageName
    } = grid, roleField = typeof showRole === "string" ? showRole : "role", count = showEventCount && resourceRecord.eventStore.getEvents({
      includeOccurrences: grid.enableRecurringEvents,
      resourceRecord,
      startDate: timeAxis.startDate,
      endDate: timeAxis.endDate
    }).length;
    let imageUrl;
    if (showImage && resourceRecord.image !== false) {
      if (resourceRecord.imageUrl) {
        imageUrl = resourceRecord.imageUrl;
      } else {
        const imageName = typeof showImage === "string" ? showImage : resourceRecord.image || value && me.useNameAsImageName && value.toLowerCase() + resourceImageExtension || defaultResourceImageName || "";
        imageUrl = imageName && me.getImageURL(imageName);
        if (imageUrl && !imageName.includes(".")) {
          if (!me.validNames || me.validNames.includes(imageName)) {
            imageUrl += resourceImageExtension;
          }
        }
      }
    }
    return {
      class: "b-resource-info",
      children: [
        showImage && me.avatarRendering.getResourceAvatar({
          resourceRecord,
          initials: resourceRecord.initials,
          color: resourceRecord.eventColor,
          iconCls: resourceRecord.iconCls,
          imageUrl,
          defaultImageUrl: defaultResourceImageName && this.getImageURL(defaultResourceImageName)
        }),
        showRole || showEventCount || showMeta ? {
          tag: "dl",
          children: [{
            tag: "dt",
            text: value
          }, showRole ? {
            tag: "dd",
            class: "b-resource-role",
            text: resourceRecord[roleField]
          } : null, showEventCount ? {
            tag: "dd",
            class: "b-resource-events",
            html: me.L("L{eventCountText}", count)
          } : null, showMeta ? {
            tag: "dd",
            class: "b-resource-meta",
            html: me.showMeta(resourceRecord)
          } : null]
        } : value
      ]
    };
  }
  defaultRenderer({
    grid,
    record,
    cellElement,
    value,
    isExport
  }) {
    let result;
    if (record.isSpecialRow) {
      result = "";
    } else if (isExport) {
      result = value;
    } else {
      if (this.autoScaleThreshold && grid.rowHeight < this.autoScaleThreshold) {
        cellElement.style.fontSize = grid.rowHeight / 40 + "em";
      } else {
        cellElement.style.fontSize = "";
      }
      result = this.template(record, value);
    }
    return result;
  }
};
ColumnStore.registerColumnType(ResourceInfoColumn);
ResourceInfoColumn._$name = "ResourceInfoColumn";
function isLastLevel(level, levels) {
  return level === levels.length - 1;
}
function isLastCell(level, cell) {
  return cell === level.cells[level.cells.length - 1];
}
var TimeAxisBase = class extends Widget {
  static get $name() {
    return "TimeAxisBase";
  }
  static get configurable() {
    return {
      compactCellWidthThreshold: 15,
      model: null,
      cls: null,
      sizeProperty: null,
      positionProperty: null
    };
  }
  static get properties() {
    return {
      startDate: null,
      endDate: null,
      levels: [],
      size: null
    };
  }
  set range({
    startDate,
    endDate
  }) {
    const me = this;
    if (me.startDate - startDate || me.endDate - endDate) {
      me.startDate = startDate;
      me.endDate = endDate;
      me.refresh();
    }
  }
  buildCells(start = this.startDate, end = this.endDate) {
    var _me$client;
    const me = this, {
      sizeProperty
    } = me, {
      stickyHeaders,
      isVertical
    } = me.client || {}, featureHeaderConfigs = [], {
      length
    } = me.levels;
    const cellConfigs = me.levels.map((level, i) => {
      var _level$cells;
      const stickyHeader = stickyHeaders && (isVertical || i < length - 1);
      return {
        className: {
          "b-sch-header-row": 1,
          [`b-sch-header-row-${level.position}`]: 1,
          "b-sch-header-row-main": i === me.model.viewPreset.mainHeaderLevel,
          "b-lowest": isLastLevel(i, me.levels),
          "b-sticky-header": stickyHeader
        },
        syncOptions: {
          releaseThreshold: 5,
          syncIdField: "tickIndex"
        },
        dataset: {
          headerFeature: `headerRow${i}`,
          headerPosition: level.position
        },
        children: (_level$cells = level.cells) === null || _level$cells === void 0 ? void 0 : _level$cells.filter((cell) => cell.start < end && cell.end > start).map((cell) => ({
          role: "presentation",
          className: {
            "b-sch-header-timeaxis-cell": 1,
            [cell.headerCellCls]: cell.headerCellCls,
            [`b-align-${cell.align}`]: cell.align,
            "b-last": isLastCell(level, cell)
          },
          dataset: _objectSpread2({
            tickIndex: cell.index
          }, globalThis.DEBUG && {
            date: cell.start.getTime()
          }),
          style: {
            [me.positionProperty]: cell.coord,
            [sizeProperty]: cell.width,
            [`min-${sizeProperty}`]: cell.width
          },
          children: [{
            tag: "span",
            role: "presentation",
            className: {
              "b-sch-header-text": 1,
              "b-sticky-header": stickyHeader
            },
            html: cell.value
          }]
        }))
      };
    });
    (_me$client = me.client) === null || _me$client === void 0 ? void 0 : _me$client.getHeaderDomConfigs(featureHeaderConfigs);
    cellConfigs.push(...featureHeaderConfigs);
    return {
      className: me.widgetClassList,
      syncOptions: {
        releaseThreshold: 0
      },
      children: cellConfigs
    };
  }
  render(targetElement) {
    super.render(targetElement);
    this.refresh(true);
  }
  refresh(rebuild = !this.levels.length) {
    const me = this, {
      columnConfig
    } = me.model, {
      levels
    } = me, oldLevelsCount = levels.length;
    if (rebuild) {
      levels.length = 0;
      columnConfig.forEach((cells, position) => levels[position] = {
        position,
        cells
      });
      me.size = levels[0].cells.reduce((sum, cell) => sum += cell.width, 0);
      const parentEl = me.element.parentElement;
      if (parentEl && (levels.length !== oldLevelsCount || rebuild)) {
        parentEl.classList.remove(`b-sch-timeaxiscolumn-levels-${oldLevelsCount}`);
        parentEl.classList.add(`b-sch-timeaxiscolumn-levels-${levels.length}`);
      }
    }
    if (!me.startDate || !me.endDate) {
      return;
    }
    DomSync.sync({
      domConfig: me.buildCells(),
      targetElement: me.element,
      syncIdField: "headerFeature"
    });
    me.trigger("refresh");
  }
  get widgetClass() {
    return "b-timeaxis";
  }
};
TimeAxisBase._$name = "TimeAxisBase";
var HorizontalTimeAxis = class extends TimeAxisBase {
  static get $name() {
    return "HorizontalTimeAxis";
  }
  static get type() {
    return "horizontaltimeaxis";
  }
  static get configurable() {
    return {
      model: null,
      sizeProperty: "width"
    };
  }
  get positionProperty() {
    var _this$owner;
    return (_this$owner = this.owner) !== null && _this$owner !== void 0 && _this$owner.rtl ? "right" : "left";
  }
  get width() {
    return this.size;
  }
  onModelUpdate() {
    if (this.model.availableSpace !== this.width) {
      this.refresh(true);
    }
  }
  updateModel(timeAxisViewModel) {
    this.detachListeners("tavm");
    timeAxisViewModel === null || timeAxisViewModel === void 0 ? void 0 : timeAxisViewModel.ion({
      name: "tavm",
      update: "onModelUpdate",
      thisObj: this
    });
  }
};
HorizontalTimeAxis._$name = "HorizontalTimeAxis";
var ResourceHeader = class extends Widget {
  construct(config) {
    const me = this;
    config.scheduler._resourceColumns = me;
    super.construct(config);
    if (me.imagePath != null) {
      me.element.classList.add("b-has-images");
    }
    EventHelper.on({
      element: me.element,
      delegate: ".b-resourceheader-cell",
      capture: true,
      click: "onResourceMouseEvent",
      dblclick: "onResourceMouseEvent",
      contextmenu: "onResourceMouseEvent",
      thisObj: me
    });
  }
  changeShowAvatars(show) {
    var _this$avatarRendering;
    (_this$avatarRendering = this.avatarRendering) === null || _this$avatarRendering === void 0 ? void 0 : _this$avatarRendering.destroy();
    if (show) {
      this.avatarRendering = new AvatarRendering({
        element: this.element
      });
    }
    return show;
  }
  updateShowAvatars() {
    if (!this.isConfiguring) {
      this.refresh();
    }
  }
  updateResourceStore(store) {
    const me = this;
    me.detachListeners("resourceStore");
    if (store) {
      store.ion({
        name: "resourceStore",
        changePreCommit: "onResourceStoreDataChange",
        thisObj: me
      });
      if (store.count) {
        me.onResourceStoreDataChange({});
      }
    }
  }
  onResourceStoreDataChange({
    action
  }) {
    const me = this;
    me.getConfig("fillWidth");
    me.getConfig("fitWidth");
    me.updateWidthCache();
    const {
      element
    } = me, width = me.totalWidth;
    if (me.scheduler.variableColumnWidths) {
      me._fillWidth = me._fitWidth = false;
    } else {
      me._fillWidth = me.configuredFillWidth;
      me._fitWidth = me.configuredFitWidth;
    }
    if (width !== me.width) {
      DomHelper.setLength(element, "width", width);
      me.column.set("width", width, me.column.grid.isConfiguring);
    }
    if (action === "removeall") {
      element.innerHTML = "";
    }
    if (action === "remove" || action === "add" || action === "filter" || me.fitWidth || me.fillWidth) {
      me.refreshWidths();
    }
    me.column.grid.toggleEmptyText();
  }
  get totalWidth() {
    return this.updateWidthCache();
  }
  updateWidthCache() {
    let result = 0;
    const {
      scheduler
    } = this;
    scheduler.variableColumnWidths = false;
    scheduler.resourceStore.forEach((resource) => {
      resource.instanceMeta(scheduler).insetStart = result;
      resource.instanceMeta(scheduler).insetEnd = result + (resource.columnWidth || scheduler.resourceColumnWidth);
      if (resource.columnWidth == null) {
        result += scheduler.resourceColumnWidth;
      } else {
        result += resource.columnWidth;
        scheduler.variableColumnWidths = true;
      }
    });
    return result;
  }
  changeColumnWidth(columnWidth) {
    if (!this.refreshingWidths) {
      this.configuredColumnWidth = columnWidth;
    }
    return columnWidth;
  }
  updateColumnWidth(width, oldWidth) {
    const me = this;
    if (!me.refreshingWidths) {
      me.refreshWidths();
    }
    if (!me.isConfiguring) {
      me.refresh();
      me.trigger("columnWidthChange", {
        width,
        oldWidth
      });
    }
  }
  changeFillWidth(fillWidth) {
    return this.configuredFillWidth = fillWidth;
  }
  updateFillWidth() {
    if (!this.isConfiguring) {
      this.refreshWidths();
    }
  }
  changeFitWidth(fitWidth) {
    return this.configuredFitWidth = fitWidth;
  }
  updateFitWidth() {
    if (!this.isConfiguring) {
      this.refreshWidths();
    }
  }
  getImageURL(imageName) {
    return StringHelper.joinPaths([this.imagePath || "", imageName || ""]);
  }
  updateImagePath() {
    if (!this.isConfiguring) {
      this.refresh();
    }
  }
  updateAvailableWidth(width) {
    this.refreshWidths();
  }
  refreshWidths() {
    var _me$resourceStore;
    const me = this, {
      availableWidth,
      configuredColumnWidth
    } = me, count = (_me$resourceStore = me.resourceStore) === null || _me$resourceStore === void 0 ? void 0 : _me$resourceStore.count;
    if (!availableWidth || !count || me.scheduler.variableColumnWidths) {
      return;
    }
    me.refreshingWidths = true;
    const fit = me.fitWidth || me.fillWidth && configuredColumnWidth * count < availableWidth, useWidth = fit ? Math.floor(availableWidth / count) : configuredColumnWidth, shouldAnimate = me.column.grid.enableEventAnimations && Math.abs(me._columnWidth - useWidth) > 30;
    DomHelper.addTemporaryClass(me.element, "b-animating", shouldAnimate ? 300 : 0, me);
    me.columnWidth = useWidth;
    me.refreshingWidths = false;
  }
  set visibleResources({
    firstResource,
    lastResource
  }) {
    this.firstResource = firstResource;
    this.lastResource = lastResource;
    this.updateWidthCache();
    this.refresh();
  }
  refresh() {
    const me = this, {
      firstResource,
      scheduler,
      resourceStore,
      lastResource
    } = me, {
      variableColumnWidths
    } = scheduler, groupField = resourceStore.isGrouped && resourceStore.groupers[0].field, configs = [];
    me.element.classList.toggle("b-grouped", Boolean(groupField));
    if (!me.column.grid.isConfiguring && firstResource > -1 && lastResource > -1 && lastResource < resourceStore.count) {
      let currentGroup;
      for (let i = firstResource; i <= lastResource; i++) {
        var _currentGroup;
        const resourceRecord = resourceStore.allResourceRecords[i], groupRecord = resourceRecord.instanceMeta(resourceStore).groupParent, groupChildren = groupRecord === null || groupRecord === void 0 ? void 0 : groupRecord.groupChildren;
        if (groupField && groupRecord.id !== ((_currentGroup = currentGroup) === null || _currentGroup === void 0 ? void 0 : _currentGroup.dataset.resourceId)) {
          const groupLeft = groupChildren[0].instanceMeta(scheduler).insetStart, groupWidth = groupChildren[groupChildren.length - 1].instanceMeta(scheduler).insetEnd - groupLeft;
          currentGroup = {
            className: "b-resourceheader-group-cell",
            dataset: {
              resourceId: groupRecord.id
            },
            style: {
              left: groupLeft,
              width: groupWidth
            },
            children: [{
              tag: "span",
              html: StringHelper.encodeHtml(groupChildren[0][groupField])
            }, {
              className: "b-resourceheader-group-children",
              children: []
            }]
          };
          configs.push(currentGroup);
        }
        const instanceMeta = resourceRecord.instanceMeta(scheduler), width = resourceRecord.columnWidth || me.columnWidth, position = groupField ? instanceMeta.insetStart - currentGroup.style.left : variableColumnWidths ? instanceMeta.insetStart : i * me.columnWidth, elementConfig = {
          className: new DomClassList({
            "b-resourceheader-cell": 1
          }),
          dataset: {
            resourceId: resourceRecord.id
          },
          style: {
            [scheduler.rtl ? "right" : "left"]: position,
            width
          },
          children: []
        };
        if (me.headerRenderer) {
          const value = me.headerRenderer({
            elementConfig,
            resourceRecord
          });
          if (value != null) {
            elementConfig.html = value;
          }
        } else {
          let imageUrl;
          if (resourceRecord.imageUrl) {
            imageUrl = resourceRecord.imageUrl;
          } else {
            if (me.imagePath != null) {
              if (resourceRecord.image !== false) {
                var _resourceRecord$name;
                const imageName = resourceRecord.image || ((_resourceRecord$name = resourceRecord.name) === null || _resourceRecord$name === void 0 ? void 0 : _resourceRecord$name.toLowerCase()) + me.imageExtension;
                imageUrl = me.getImageURL(imageName);
              }
            }
          }
          elementConfig.children.push(me.showAvatars && me.avatarRendering.getResourceAvatar({
            resourceRecord,
            initials: resourceRecord.initials,
            color: resourceRecord.eventColor,
            iconCls: resourceRecord.iconCls,
            defaultImageUrl: me.defaultImageName && me.getImageURL(me.defaultImageName),
            imageUrl
          }), {
            tag: "span",
            className: "b-resource-name",
            html: StringHelper.encodeHtml(resourceRecord.name)
          });
        }
        if (groupField) {
          currentGroup.children[1].children.push(elementConfig);
        } else {
          configs.push(elementConfig);
        }
      }
    }
    DomSync.sync({
      domConfig: {
        onlyChildren: true,
        children: configs
      },
      targetElement: me.element,
      syncIdField: "resourceId"
    });
  }
  onResourceMouseEvent(event) {
    const resourceCell = event.target.closest(".b-resourceheader-cell"), resourceRecord = this.resourceStore.getById(resourceCell.dataset.resourceId);
    this.trigger("resourceHeader" + StringHelper.capitalize(event.type), {
      resourceRecord,
      event
    });
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    delete result.resourceStore;
    delete result.column;
    delete result.type;
    return result;
  }
};
_defineProperty(ResourceHeader, "$name", "ResourceHeader");
_defineProperty(ResourceHeader, "type", "resourceheader");
_defineProperty(ResourceHeader, "configurable", {
  resourceStore: null,
  headerRenderer: null,
  showAvatars: {
    value: true,
    $config: "nullify"
  },
  fillWidth: true,
  fitWidth: false,
  columnWidth: 150,
  imagePath: null,
  imageExtension: null,
  defaultImageName: null,
  availableWidth: null
});
_defineProperty(ResourceHeader, "properties", {
  firstResource: -1,
  lastResource: -1
});
ResourceHeader._$name = "ResourceHeader";
var TimeAxisColumn = class extends Events(WidgetColumn) {
  static get fields() {
    return [
      {
        name: "locked",
        persist: false
      },
      {
        name: "flex",
        persist: false
      },
      {
        name: "width",
        persist: false
      },
      {
        name: "cellCls",
        persist: false
      },
      {
        name: "field",
        persist: false
      },
      "mode"
    ];
  }
  static get defaults() {
    return {
      draggable: false,
      groupable: false,
      hideable: false,
      showColumnPicker: false,
      filterable: false,
      sortable: false,
      resizable: false,
      searchable: false,
      editor: false,
      enableCellContextMenu: false,
      tooltipRenderer: false,
      cls: "b-sch-timeaxiscolumn",
      needWidth: true,
      mode: null,
      region: "normal",
      exportable: false,
      htmlEncode: false
    };
  }
  static get type() {
    return "timeAxis";
  }
  construct(config) {
    const me = this;
    super.construct(...arguments);
    me.thisObj = me;
    me.timeAxisViewModel = me.grid.timeAxisViewModel;
    me.mode = me.mode;
    me.grid.ion({
      paint: "onTimelinePaint",
      thisObj: me,
      once: true
    });
  }
  static get autoExposeFields() {
    return true;
  }
  doDestroy() {
    var _this$resourceColumns, _this$timeAxisView;
    (_this$resourceColumns = this.resourceColumns) === null || _this$resourceColumns === void 0 ? void 0 : _this$resourceColumns.destroy();
    (_this$timeAxisView = this.timeAxisView) === null || _this$timeAxisView === void 0 ? void 0 : _this$timeAxisView.destroy();
    super.doDestroy();
  }
  set mode(mode) {
    const me = this, {
      grid
    } = me;
    me.set("mode", mode);
    if (mode === "horizontal") {
      me.timeAxisView = new HorizontalTimeAxis({
        model: me.timeAxisViewModel,
        compactCellWidthThreshold: me.compactCellWidthThreshold,
        owner: grid,
        client: grid
      });
    } else if (mode === "vertical") {
      me.resourceColumns = ResourceHeader.new({
        column: me,
        scheduler: grid,
        resourceStore: grid.resourceStore,
        imagePath: grid.resourceImagePath,
        imageExtension: grid.resourceImageExtension,
        defaultImageName: grid.defaultResourceImageName
      }, grid.resourceColumns || {});
      me.relayEvents(me.resourceColumns, ["resourceheaderclick", "resourceheaderdblclick", "resourceheadercontextmenu"]);
    }
  }
  get mode() {
    return this.get("mode");
  }
  onViewModelUpdate({
    source: viewModel
  }) {
    const me = this;
    if (me.mode === "horizontal") {
      me.refreshHeader(true);
      me.width = viewModel.totalSize;
      me.grid.refresh();
      me.subGrid.refreshFakeScroll();
    } else if (me.mode === "vertical") {
      me.grid.refreshRows();
    }
  }
  onTimelinePaint({
    firstPaint
  }) {
    const me = this;
    if (!me.subGrid.insertRowsBefore) {
      return;
    }
    if (firstPaint) {
      me.subGridElement.classList.add("b-timeline-subgrid");
      if (me.mode === "vertical") {
        var _me$grid;
        me.refreshHeader();
        (_me$grid = me.grid) === null || _me$grid === void 0 ? void 0 : _me$grid.onHeightChange();
      }
    }
  }
  refreshHeader(internal) {
    const me = this, {
      element
    } = me;
    if (element) {
      if (me.mode === "horizontal") {
        !internal && me.timeAxisViewModel.update(void 0, void 0, true);
        if (!me.timeAxisView.rendered) {
          element.innerHTML = "";
          me.timeAxisView.render(element);
        } else {
          me.timeAxisView.refresh(true);
        }
      } else if (me.mode === "vertical") {
        if (!me.resourceColumns.currentElement) {
          element.innerHTML = "";
          me.resourceColumns.render(element);
        }
      }
    }
  }
  internalRenderer(renderData) {
    const {
      grid
    } = this;
    if (grid.project.isInitialCommitPerformed || grid.project.isDelayingCalculation) {
      grid.currentOrientation.renderer(renderData);
      return super.internalRenderer(renderData);
    }
  }
  get timeAxisViewModel() {
    return this._timeAxisViewModel;
  }
  set timeAxisViewModel(timeAxisViewModel) {
    const me = this;
    me.detachListeners("tavm");
    timeAxisViewModel === null || timeAxisViewModel === void 0 ? void 0 : timeAxisViewModel.ion({
      name: "tavm",
      update: "onViewModelUpdate",
      prio: -1e4,
      thisObj: me
    });
    me._timeAxisViewModel = timeAxisViewModel;
    if (me.timeAxisView) {
      me.timeAxisView.model = timeAxisViewModel;
    }
  }
  getState() {
    const state = super.getState();
    delete state.width;
    delete state.flex;
    return state;
  }
};
_defineProperty(TimeAxisColumn, "$name", "TimeAxisColumn");
ColumnStore.registerColumnType(TimeAxisColumn);
TimeAxisColumn._$name = "TimeAxisColumn";
var VerticalTimeAxis = class extends TimeAxisBase {
  static get $name() {
    return "VerticalTimeAxis";
  }
  static get configurable() {
    return {
      cls: "b-verticaltimeaxis",
      sizeProperty: "height",
      positionProperty: "top",
      wrapText: true
    };
  }
  buildHorizontalCells() {
    const me = this, {
      client
    } = me, stickyHeaders = client === null || client === void 0 ? void 0 : client.stickyHeaders, featureHeaderConfigs = [], cellConfigs = me.levels.reduce((result, level, i) => {
      if (level.cells) {
        var _level$cells;
        result.push(...(_level$cells = level.cells) === null || _level$cells === void 0 ? void 0 : _level$cells.filter((cell) => cell.start < me.endDate && cell.end > me.startDate).map((cell, j, cells) => ({
          role: "presentation",
          className: {
            "b-sch-header-timeaxis-cell": 1,
            [cell.headerCellCls]: cell.headerCellCls,
            [`b-align-${cell.align}`]: cell.align,
            "b-last": j === cells.length - 1,
            "b-lowest": i === me.levels.length - 1
          },
          dataset: _objectSpread2({
            tickIndex: cell.index,
            cellId: `${i}-${cell.index}`,
            headerPosition: i
          }, globalThis.DEBUG && {
            date: cell.start.getTime()
          }),
          style: {
            top: cell.coord,
            height: cell.width,
            minHeight: cell.width
          },
          children: [{
            role: "presentation",
            className: {
              "b-sch-header-text": 1,
              "b-sticky-header": stickyHeaders
            },
            html: cell.value
          }]
        })));
      }
      return result;
    }, []);
    client === null || client === void 0 ? void 0 : client.getHeaderDomConfigs(featureHeaderConfigs);
    cellConfigs.push(...featureHeaderConfigs);
    return {
      className: me.widgetClassList,
      dataset: {
        headerFeature: `headerRow0`,
        headerPosition: 0
      },
      syncOptions: {
        releaseThreshold: 5,
        syncIdField: "cellId"
      },
      children: cellConfigs
    };
  }
  get height() {
    return this.size;
  }
};
VerticalTimeAxis._$name = "VerticalTimeAxis";
var VerticalTimeAxisColumn = class extends Column {
  static get type() {
    return "verticalTimeAxis";
  }
  static get defaults() {
    return {
      draggable: false,
      groupable: false,
      hideable: false,
      showColumnPicker: false,
      filterable: false,
      sortable: false,
      searchable: false,
      editor: false,
      enableCellContextMenu: false,
      tooltipRenderer: false,
      minWidth: 0,
      resizable: false,
      cellCls: "b-verticaltimeaxiscolumn",
      flex: 1,
      alwaysClearCell: false
    };
  }
  get isFocusable() {
    return false;
  }
  construct(data) {
    super.construct(...arguments);
    this.view = new VerticalTimeAxis({
      model: this.grid.timeAxisViewModel,
      client: this.grid
    });
  }
  renderer({
    cellElement,
    size
  }) {
    this.view.render(cellElement);
    size.height = this.view.height;
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    delete result.id;
    delete result.region;
    delete result.type;
    delete result.field;
    delete result.ariaLabel;
    delete result.cellAriaLabel;
    return result;
  }
};
_defineProperty(VerticalTimeAxisColumn, "$name", "VerticalTimeAxisColumn");
ColumnStore.registerColumnType(VerticalTimeAxisColumn);
VerticalTimeAxisColumn._$name = "VerticalTimeAxisColumn";
var AbstractCrudManagerValidation = (Target) => class AbstractCrudManagerValidation extends Target {
  static get $name() {
    return "AbstractCrudManagerValidation";
  }
  static get configurable() {
    return {
      validateResponse: true,
      skipSuccessProperty: true,
      crudLoadValidationWarningPrefix: "CrudManager load response error(s):",
      crudSyncValidationWarningPrefix: "CrudManager sync response error(s):",
      supportShortSyncResponseNote: 'Note: Please consider enabling "supportShortSyncResponse" option to allow less detailed sync responses (https://bryntum.com/products/scheduler/docs/api/Scheduler/crud/AbstractCrudManagerMixin#config-supportShortSyncResponse)',
      disableValidationNote: 'Note: To disable this validation please set the "validateResponse" config to false'
    };
  }
  get crudLoadValidationMandatoryStores() {
    return [];
  }
  getStoreLoadResponseWarnings(storeInfo, responded, expectedResponse) {
    const messages = [], {
      storeId
    } = storeInfo, mandatoryStores = this.crudLoadValidationMandatoryStores, result = {
      [storeId]: {}
    };
    if (responded) {
      if (!responded.rows) {
        messages.push(`- "${storeId}" store section should have a "rows" property with an array of the store records.`);
        result[storeId].rows = ["..."];
      }
    } else if (mandatoryStores !== null && mandatoryStores !== void 0 && mandatoryStores.includes(storeId)) {
      messages.push(`- No "${storeId}" store section found. It should contain the store data.`);
      result[storeId].rows = ["..."];
    }
    if (messages.length) {
      Object.assign(expectedResponse, result);
    }
    return messages;
  }
  getLoadResponseWarnings(response) {
    const messages = [], expectedResponse = {};
    if (!this.skipSuccessProperty) {
      expectedResponse.success = true;
    }
    this.forEachCrudStore((store, storeId, storeInfo) => {
      messages.push(...this.getStoreLoadResponseWarnings(storeInfo, response === null || response === void 0 ? void 0 : response[storeId], expectedResponse));
    });
    if (messages.length) {
      messages.push("Please adjust your response to look like this:\n" + JSON.stringify(expectedResponse, null, 4).replace(/"\.\.\."/g, "..."));
      messages.push(this.disableValidationNote);
    }
    return messages;
  }
  validateLoadResponse(response) {
    const messages = this.getLoadResponseWarnings(response);
    if (messages.length) {
      console.warn(this.crudLoadValidationWarningPrefix + "\n" + messages.join("\n"));
    }
  }
  getStoreSyncResponseWarnings(storeInfo, requested, responded, expectedResponse) {
    const messages = [], missingRows = [], missingRemoved = [], {
      storeId
    } = storeInfo, result = {
      [storeId]: {}
    }, phantomIdField = storeInfo.phantomIdField || this.phantomIdField, {
      modelClass
    } = storeInfo.store, {
      idField
    } = modelClass, respondedRows = (responded === null || responded === void 0 ? void 0 : responded.rows) || [], respondedRemoved = (responded === null || responded === void 0 ? void 0 : responded.removed) || [];
    let showSupportShortSyncResponseNote = false;
    if (requested !== null && requested !== void 0 && requested.added) {
      missingRows.push(...requested.added.filter((record) => {
        return !respondedRows.find((row) => row[phantomIdField] == record[phantomIdField]) && !respondedRemoved.find((row) => row[phantomIdField] == record[phantomIdField] || row[idField] == record[phantomIdField]);
      }).map((record) => ({
        [phantomIdField]: record[phantomIdField],
        [idField]: "..."
      })));
      if (missingRows.length) {
        const missingIds = missingRows.map((row) => "#" + row[phantomIdField]).join(", ");
        messages.push(`- "${storeId}" store "rows" section should mention added record(s) ${missingIds} sent in the request. It should contain the added records identifiers (both phantom and "real" ones assigned by the backend).`);
      }
    }
    if (this.supportShortSyncResponse) {
      if (!missingRows.length && responded) {
        if (typeof responded !== "object" || Array.isArray(responded)) {
          messages.push(`- "${storeId}" store section should be an Object.`);
          result[storeId]["..."] = "...";
        }
        if (responded.rows && !Array.isArray(responded.rows)) {
          messages.push(`- "${storeId}" store "rows" section should be an array`);
          missingRows.push("...");
        }
        if (responded.removed && !Array.isArray(responded.removed)) {
          messages.push(`- "${storeId}" store "removed" section should be an array:`);
          missingRemoved.push("...");
        }
      }
    } else {
      if (requested !== null && requested !== void 0 && requested.updated) {
        const missingUpdatedRows = requested.updated.filter((record) => !respondedRows.find((row) => row[idField] == record[idField])).map((record) => ({
          [idField]: record[idField]
        }));
        missingRows.push(...missingUpdatedRows);
        if (missingUpdatedRows.length) {
          const missingIds = missingUpdatedRows.map((row) => "#" + row[idField]).join(", ");
          messages.push(`- "${storeId}" store "rows" section should mention updated record(s) ${missingIds} sent in the request. It should contain the updated record identifiers.`);
          showSupportShortSyncResponseNote = true;
        }
      }
      if (missingRows.length) {
        missingRows.push("...");
      }
      if (requested !== null && requested !== void 0 && requested.removed) {
        missingRemoved.push(...requested.removed.filter((record) => !respondedRows.find((row) => row[idField] == record[idField])).map((record) => ({
          [idField]: record[idField]
        })));
        if (missingRemoved.length) {
          const missingIds = missingRemoved.map((row) => "#" + row[idField]).join(", ");
          messages.push(`- "${storeId}" store "removed" section should mention removed record(s) ${missingIds} sent in the request. It should contain the removed record identifiers.`);
          result[storeId].removed = missingRemoved;
          missingRemoved.push("...");
          showSupportShortSyncResponseNote = true;
        }
      }
    }
    if (missingRows.length) {
      result[storeId].rows = missingRows;
    }
    if (!messages.length) {
      delete result[storeId];
    }
    Object.assign(expectedResponse, result);
    return {
      messages,
      showSupportShortSyncResponseNote
    };
  }
  getSyncResponseWarnings(response, requestDesc) {
    const messages = [], expectedResponse = {}, request = requestDesc.pack;
    if (!this.skipSuccessProperty) {
      expectedResponse.success = true;
    }
    let showSupportShortSyncResponseNote = false;
    this.forEachCrudStore((store, storeId, storeInfo) => {
      const warnings = this.getStoreSyncResponseWarnings(storeInfo, request === null || request === void 0 ? void 0 : request[storeId], response[storeId], expectedResponse);
      showSupportShortSyncResponseNote = showSupportShortSyncResponseNote || warnings.showSupportShortSyncResponseNote;
      messages.push(...warnings.messages);
    });
    if (messages.length) {
      messages.push("Please adjust your response to look like this:\n" + JSON.stringify(expectedResponse, null, 4).replace(/"\.\.\.":\s*"\.\.\."/g, ",,,").replace(/"\.\.\."/g, "..."));
      if (showSupportShortSyncResponseNote) {
        messages.push(this.supportShortSyncResponseNote);
      }
      messages.push(this.disableValidationNote);
    }
    return messages;
  }
  validateSyncResponse(response, request) {
    const messages = this.getSyncResponseWarnings(response, request);
    if (messages.length) {
      console.warn(this.crudSyncValidationWarningPrefix + "\n" + messages.join("\n"));
    }
  }
};
var AbstractCrudManagerError = class extends Error {
};
var CrudManagerRequestError = class extends AbstractCrudManagerError {
  constructor(cfg = {}) {
    var _cfg$request, _this$request;
    super(cfg.message || cfg.request && StringHelper.capitalize((_cfg$request = cfg.request) === null || _cfg$request === void 0 ? void 0 : _cfg$request.type) + " failed" || "Crud Manager request failed");
    Object.assign(this, cfg);
    this.action = (_this$request = this.request) === null || _this$request === void 0 ? void 0 : _this$request.type;
  }
};
var storeSortFn = function(lhs, rhs, sortProperty) {
  if (lhs.store) {
    lhs = lhs.store;
  }
  if (rhs.store) {
    rhs = rhs.store;
  }
  lhs = lhs[sortProperty] || 0;
  rhs = rhs[sortProperty] || 0;
  return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
};
var storeLoadSortFn = function(lhs, rhs) {
  return storeSortFn(lhs, rhs, "loadPriority");
};
var storeSyncSortFn = function(lhs, rhs) {
  return storeSortFn(lhs, rhs, "syncPriority");
};
var AbstractCrudManagerMixin = (Target) => {
  var _class;
  Target.$$meta = Target.$meta;
  const mixins = [];
  if (!Target.isEvents) {
    mixins.push(Events);
  }
  if (!Target.isDelayable) {
    mixins.push(Delayable);
  }
  mixins.push(AbstractCrudManagerValidation);
  return _class = class AbstractCrudManagerMixin extends (Target || Base$1).mixin(...mixins) {
    static get $name() {
      return "AbstractCrudManagerMixin";
    }
    static get defaultConfig() {
      return {
        crudRevision: null,
        crudStores: [],
        storeIdProperty: "storeId",
        crudFilterParam: "filter",
        transport: {},
        trackResponseType: false,
        supportShortSyncResponse: true,
        phantomIdField: "$PhantomId",
        phantomParentIdField: "$PhantomParentId",
        autoLoad: false,
        autoSyncTimeout: 100,
        autoSync: false,
        resetIdsBeforeSync: true,
        syncApplySequence: [],
        orderedCrudStores: [],
        writeAllFields: false,
        crudIgnoreUpdates: 0,
        autoSyncSuspendCounter: 0,
        crudLoaded: false,
        applyingLoadResponse: false,
        applyingSyncResponse: false,
        callOnFunctions: true
      };
    }
    get isCrudManager() {
      return true;
    }
    construct(config = {}) {
      this._requestId = 0;
      this.activeRequests = {};
      this.crudStoresIndex = {};
      super.construct(config);
    }
    afterConstruct() {
      super.afterConstruct();
      if (this.autoLoad) {
        this._autoLoadPromise = this.doAutoLoad();
      }
    }
    get loadUrl() {
      var _this$transport, _this$transport$load;
      return (_this$transport = this.transport) === null || _this$transport === void 0 ? void 0 : (_this$transport$load = _this$transport.load) === null || _this$transport$load === void 0 ? void 0 : _this$transport$load.url;
    }
    updateLoadUrl(url) {
      ObjectHelper.setPath(this, "transport.load.url", url);
    }
    get syncUrl() {
      var _this$transport2, _this$transport2$sync;
      return (_this$transport2 = this.transport) === null || _this$transport2 === void 0 ? void 0 : (_this$transport2$sync = _this$transport2.sync) === null || _this$transport2$sync === void 0 ? void 0 : _this$transport2$sync.url;
    }
    updateSyncUrl(url) {
      ObjectHelper.setPath(this, "transport.sync.url", url);
    }
    getStoreDescriptor(storeId) {
      if (!storeId)
        return null;
      if (storeId instanceof Store)
        return this.crudStores.find((storeDesc) => storeDesc.store === storeId);
      if (typeof storeId === "object")
        return this.crudStoresIndex[storeId.storeId];
      return this.crudStoresIndex[storeId] || this.getStoreDescriptor(Store.getStore(storeId));
    }
    fillStoreDescriptor(descriptor) {
      const {
        store
      } = descriptor, {
        storeIdProperty = this.storeIdProperty,
        modelClass
      } = store;
      if (!descriptor.storeId) {
        descriptor.storeId = store[storeIdProperty] || store.id;
      }
      if (!descriptor.idField) {
        descriptor.idField = modelClass.idField;
      }
      if (!descriptor.phantomIdField) {
        descriptor.phantomIdField = modelClass.phantomIdField;
      }
      if (!descriptor.phantomParentIdField) {
        descriptor.phantomParentIdField = modelClass.phantomParentIdField;
      }
      if (!("writeAllFields" in descriptor)) {
        descriptor.writeAllFields = store.writeAllFields;
      }
      return descriptor;
    }
    updateCrudStoreIndex() {
      const crudStoresIndex = this.crudStoresIndex = {};
      this.crudStores.forEach((store) => store.storeId && (crudStoresIndex[store.storeId] = store));
    }
    getCrudStore(storeId) {
      const storeDescriptor = this.getStoreDescriptor(storeId);
      return storeDescriptor === null || storeDescriptor === void 0 ? void 0 : storeDescriptor.store;
    }
    forEachCrudStore(fn2, thisObj = this) {
      if (!fn2) {
        throw new Error("Iterator function must be provided");
      }
      this.crudStores.every((store) => fn2.call(thisObj, store.store, store.storeId, store) !== false);
    }
    set crudStores(stores2) {
      this._crudStores = [];
      this.addCrudStore(stores2);
      for (const store of this._crudStores) {
        store.loadPriority = store.syncPriority = 0;
      }
    }
    get crudStores() {
      return this._crudStores;
    }
    get orderedCrudStores() {
      return this._orderedCrudStores;
    }
    set orderedCrudStores(stores2) {
      return this._orderedCrudStores = stores2;
    }
    set syncApplySequence(stores2) {
      this._syncApplySequence = [];
      this.addStoreToApplySequence(stores2);
    }
    get syncApplySequence() {
      return this._syncApplySequence;
    }
    internalAddCrudStore(store) {
      const me = this;
      let storeInfo;
      if (store instanceof Store) {
        storeInfo = {
          store
        };
      } else if (typeof store === "object") {
        if (!store.store) {
          store = {
            storeId: store.id,
            store: new Store(store)
          };
        }
        storeInfo = store;
      } else {
        storeInfo = {
          store: Store.getStore(store)
        };
      }
      me.fillStoreDescriptor(storeInfo);
      store = storeInfo.store;
      if (store.setCrudManager) {
        store.setCrudManager(me);
      } else {
        store.crudManager = me;
      }
      store.pageSize = null;
      if (me.loadUrl || me.syncUrl) {
        store.autoCommit = false;
        store.autoLoad = false;
        if (store.createUrl || store.updateUrl || store.deleteUrl || store.readUrl) {
          console.warn("You have configured an URL on a Store that is handled by a CrudManager that is also configured with an URL. The Store URL's should be removed.");
        }
      }
      me.bindCrudStoreListeners(store);
      return storeInfo;
    }
    addCrudStore(store, position, fromStore) {
      var _store;
      store = ArrayHelper.asArray(store);
      if (!((_store = store) !== null && _store !== void 0 && _store.length)) {
        return;
      }
      const me = this, stores2 = store.map(me.internalAddCrudStore, me);
      if (typeof position === "undefined") {
        me.crudStores.push(...stores2);
      } else {
        if (fromStore) {
          if (fromStore instanceof Store || typeof fromStore !== "object")
            fromStore = me.getStoreDescriptor(fromStore);
          position += me.crudStores.indexOf(fromStore);
        }
        me.crudStores.splice(position, 0, ...stores2);
      }
      me.orderedCrudStores.push(...stores2);
      me.updateCrudStoreIndex();
    }
    addPrioritizedStore(store) {
      const me = this;
      if (!me.hasCrudStore(store)) {
        me.addCrudStore(store, ArrayHelper.findInsertionIndex(store, me.crudStores, storeLoadSortFn));
      }
      if (!me.hasApplySequenceStore(store)) {
        me.addStoreToApplySequence(store, ArrayHelper.findInsertionIndex(store, me.syncApplySequence, storeSyncSortFn));
      }
    }
    hasCrudStore(store) {
      var _this$crudStores;
      return (_this$crudStores = this.crudStores) === null || _this$crudStores === void 0 ? void 0 : _this$crudStores.some((s) => s === store || s.store === store || s.storeId === store);
    }
    removeCrudStore(store) {
      const me = this, stores2 = me.crudStores, foundStore = stores2.find((s) => s === store || s.store === store || s.storeId === store);
      if (foundStore) {
        me.unbindCrudStoreListeners(foundStore.store);
        delete me.crudStoresIndex[foundStore.storeId];
        ArrayHelper.remove(stores2, foundStore);
        if (me.syncApplySequence) {
          me.removeStoreFromApplySequence(store);
        }
      } else {
        throw new Error("Store not found in stores collection");
      }
    }
    bindCrudStoreListeners(store) {
      store.ion({
        name: store.id,
        addConfirmed: "onCrudStoreChange",
        change: "onCrudStoreChange",
        destroy: "onCrudStoreDestroy",
        thisObj: this
      });
    }
    unbindCrudStoreListeners(store) {
      this.detachListeners(store.id);
    }
    addStoreToApplySequence(store, position, fromStore) {
      if (!store) {
        return;
      }
      store = ArrayHelper.asArray(store);
      const me = this, data = store.reduce((collection, store2) => {
        const s = me.getStoreDescriptor(store2);
        s && collection.push(s);
        return collection;
      }, []);
      if (typeof position === "undefined") {
        me.syncApplySequence.push(...data);
      } else {
        let pos = position;
        if (fromStore) {
          if (fromStore instanceof Store || typeof fromStore !== "object")
            fromStore = me.getStoreDescriptor(fromStore);
          pos += me.syncApplySequence.indexOf(fromStore);
        }
        me.syncApplySequence.splice(pos, 0, ...data);
      }
      const sequenceKeys = me.syncApplySequence.map(({
        storeId
      }) => storeId);
      me.orderedCrudStores = [...me.syncApplySequence];
      me.crudStores.forEach((storeDesc) => {
        if (!sequenceKeys.includes(storeDesc.storeId)) {
          me.orderedCrudStores.push(storeDesc);
        }
      });
    }
    removeStoreFromApplySequence(store) {
      const index = this.syncApplySequence.findIndex((s) => s === store || s.store === store || s.storeId === store);
      if (index > -1) {
        this.syncApplySequence.splice(index, 1);
        this.orderedCrudStores.splice(index, 1);
      }
    }
    hasApplySequenceStore(store) {
      return this.syncApplySequence.some((s) => s === store || s.store === store || s.storeId === store);
    }
    onCrudStoreDestroy({
      source: store
    }) {
      this.removeCrudStore(store);
    }
    onCrudStoreChange(event) {
      const me = this;
      if (me.crudIgnoreUpdates) {
        return;
      }
      if (me.crudStoreHasChanges(event === null || event === void 0 ? void 0 : event.source)) {
        me.trigger("hasChanges");
        if (me.autoSync) {
          me.scheduleAutoSync();
        }
      } else {
        me.trigger("noChanges");
      }
    }
    suspendAutoSync() {
      this.autoSyncSuspendCounter++;
    }
    resumeAutoSync(doSync = true) {
      const me = this;
      me.autoSyncSuspendCounter--;
      if (me.autoSyncSuspendCounter <= 0) {
        me.autoSyncSuspendCounter = 0;
        if (doSync && me.autoSync && me.crudStoreHasChanges()) {
          me.sync();
        }
      }
    }
    get isAutoSyncSuspended() {
      return this.autoSyncSuspendCounter > 0;
    }
    scheduleAutoSync() {
      const me = this;
      if (!me.hasTimeout("autoSync") && !me.isAutoSyncSuspended) {
        me.setTimeout({
          name: "autoSync",
          fn: () => {
            me.sync().catch((error) => {
            });
          },
          delay: me.autoSyncTimeout
        });
      }
    }
    async triggerFailedRequestEvents(request, response, responseText, fetchOptions) {
      const {
        options,
        type: requestType
      } = request;
      this.trigger("requestFail", {
        requestType,
        response,
        responseText,
        responseOptions: fetchOptions
      });
      this.trigger(requestType + "Fail", {
        response,
        responseOptions: fetchOptions,
        responseText,
        options
      });
    }
    async internalOnResponse(request, responseText, fetchOptions) {
      const me = this, response = responseText ? me.decode(responseText) : null, {
        options,
        type: requestType
      } = request;
      if (responseText && !response) {
        console.error("Failed to parse response: " + responseText);
      }
      if (!response || (me.skipSuccessProperty ? response.success === false : !response.success)) {
        me.triggerFailedRequestEvents(request, response, responseText, fetchOptions);
      } else if (me.trigger("beforeResponseApply", {
        requestType,
        response
      }) !== false && me.trigger(`before${StringHelper.capitalize(requestType)}Apply`, {
        response,
        options
      }) !== false) {
        me.crudRevision = response.revision;
        await me.applyResponse(request, response, options);
        if (me.isDestroyed) {
          return;
        }
        me.trigger("requestDone", {
          requestType,
          response,
          responseOptions: fetchOptions
        });
        me.trigger(requestType, {
          response,
          responseOptions: fetchOptions,
          options
        });
        if (requestType === "load" || !me.crudStoreHasChanges()) {
          me.trigger("noChanges");
          if (requestType === "load") {
            me.emitCrudStoreEvents(request.pack.stores, "afterRequest");
          }
        }
      }
      return response;
    }
    suspendChangesTracking() {
      this.crudIgnoreUpdates++;
    }
    resumeChangesTracking(skipChangeCheck) {
      if (this.crudIgnoreUpdates && !--this.crudIgnoreUpdates && !skipChangeCheck) {
        this.onCrudStoreChange();
      }
    }
    get isBatchingChanges() {
      return this.crudIgnoreUpdates > 0;
    }
    crudStoreHasChanges(storeId) {
      return storeId ? this.isCrudStoreDirty(this.getCrudStore(storeId)) : this.crudStores.some((config) => this.isCrudStoreDirty(config.store));
    }
    isCrudStoreDirty(store) {
      return Boolean(store.changes);
    }
    doAutoLoad() {
      return this.load().catch((error) => {
      });
    }
    emitCrudStoreEvents(stores2, eventName, eventParams) {
      const event = _objectSpread2({
        action: "read" + eventName
      }, eventParams);
      for (const store of this.crudStores) {
        if (stores2.includes(store.storeId)) {
          store.store.trigger(eventName, event);
        }
      }
    }
    getLoadPackage(options) {
      const pack = {
        type: "load",
        requestId: this.requestId
      }, stores2 = this.crudStores, optionsCopy = Object.assign({}, options);
      delete optionsCopy.request;
      pack.stores = stores2.map((store) => {
        var _store$store;
        const opts = optionsCopy === null || optionsCopy === void 0 ? void 0 : optionsCopy[store.storeId], pageSize = store.pageSize || ((_store$store = store.store) === null || _store$store === void 0 ? void 0 : _store$store.pageSize);
        if (opts || pageSize) {
          const params = Object.assign({
            storeId: store.storeId,
            page: 1
          }, opts);
          if (pageSize) {
            params.pageSize = pageSize;
          }
          store.currentPage = params.page;
          if (opts) {
            delete optionsCopy[store.storeId];
          }
          return params;
        }
        return store.storeId;
      });
      Object.assign(pack, optionsCopy);
      return pack;
    }
    loadCrudStore(store, data, options) {
      const rows = data === null || data === void 0 ? void 0 : data.rows;
      if (options !== null && options !== void 0 && options.append || data !== null && data !== void 0 && data.append) {
        store.add(rows);
      } else {
        store.data = rows;
      }
      store.trigger("load", {
        data: rows
      });
    }
    loadDataToCrudStore(storeDesc, data, options) {
      const store = storeDesc.store, rows = data === null || data === void 0 ? void 0 : data.rows;
      store.__loading = true;
      if (rows) {
        this.loadCrudStore(store, data, options, storeDesc);
      }
      store.__loading = false;
    }
    loadCrudManagerData(response, options = {}) {
      this.suspendChangesTracking();
      this.crudStores.forEach((storeDesc) => {
        const storeId = storeDesc.storeId, data = response[storeId];
        if (data) {
          this.loadDataToCrudStore(storeDesc, data, options[storeId]);
        }
      });
      this.resumeChangesTracking(true);
    }
    get isCrudManagerLoading() {
      return Boolean(this.activeRequests.load || this.applyingLoadResponse);
    }
    get isCrudManagerSyncing() {
      return Boolean(this.activeRequests.sync || this.applyingSyncResponse);
    }
    get isLoadingOrSyncing() {
      return Boolean(this.isCrudManagerLoading || this.isCrudManagerSyncing);
    }
    load(options) {
      if (typeof options === "string") {
        options = {
          request: {
            url: options
          }
        };
      }
      const me = this, pack = me.getLoadPackage(options);
      return new Promise((resolve, reject) => {
        if (me.trigger("beforeLoad", {
          pack
        }) !== false) {
          var _options;
          const {
            load
          } = me.activeRequests;
          if (load) {
            me.cancelRequest(load.desc, load.reject);
            me.trigger("loadCanceled", {
              pack
            });
          }
          const request = Objects.assign({
            id: pack.requestId,
            data: me.encode(pack),
            type: "load",
            success: me.onCrudRequestSuccess,
            failure: me.onCrudRequestFailure,
            thisObj: me
          }, (_options = options) === null || _options === void 0 ? void 0 : _options.request);
          me.activeRequests.load = {
            type: "load",
            options,
            pack,
            resolve,
            reject(...args) {
              request.success = request.failure = null;
              reject(...args);
            },
            id: pack.requestId,
            desc: me.sendRequest(request)
          };
          me.emitCrudStoreEvents(pack.stores, "loadStart");
          me.trigger("loadStart", {
            pack
          });
        } else {
          me.trigger("loadCanceled", {
            pack
          });
          reject({
            cancelled: true
          });
        }
      });
    }
    getActiveCrudManagerRequest(requestType) {
      let request = this.activeRequests[requestType];
      if (!request && this.trackResponseType) {
        request = Object.values(this.activeRequests)[0];
      }
      return request;
    }
    prepareAddedRecordData(record, storeInfo) {
      const me = this, {
        store
      } = storeInfo, {
        isTree
      } = store, phantomIdField = storeInfo.phantomIdField || me.phantomIdField, phantomParentIdField = storeInfo.phantomParentIdField || me.phantomParentIdField, subStoreFields = store.modelClass.allFields.filter((field) => field.subStore), cls = record.constructor, data = Object.assign(record.persistableData, {
        [phantomIdField]: record.id
      });
      if (isTree) {
        const {
          parent
        } = record;
        if (parent && !parent.isRoot && parent.isPhantom) {
          data[phantomParentIdField] = parent.id;
        }
      }
      if (me.resetIdsBeforeSync) {
        ObjectHelper.deletePath(data, cls.idField);
      }
      subStoreFields.forEach((field) => {
        const subStore = record.get(field.name);
        if (subStore.allCount) {
          data[field.dataSource] = {
            added: subStore.getRange().map((record2) => me.prepareAddedRecordData(record2, {
              store: subStore
            }))
          };
        }
      });
      return data;
    }
    prepareAdded(list, storeInfo) {
      return list.filter((record) => record.isValid).map((record) => this.prepareAddedRecordData(record, storeInfo));
    }
    prepareUpdated(list, storeInfo) {
      const {
        store
      } = storeInfo, {
        isTree
      } = store, writeAllFields = storeInfo.writeAllFields || storeInfo.writeAllFields !== false && this.writeAllFields, phantomParentIdField = storeInfo.phantomParentIdField || this.phantomParentIdField, subStoreFields = store.modelClass.allFields.filter((field) => field.subStore);
      if (storeInfo.store.tree) {
        const rootNode = storeInfo.store.rootNode;
        list = list.filter((record) => record !== rootNode);
      }
      return list.filter((record) => record.isValid).reduce((data, record) => {
        let recordData;
        if (writeAllFields) {
          recordData = record.persistableData;
        } else {
          recordData = record.modificationDataToWrite;
        }
        if (isTree) {
          const {
            parent
          } = record;
          if (parent && !parent.isRoot && parent.isPhantom) {
            recordData[phantomParentIdField] = parent.id;
          }
        }
        subStoreFields.forEach((field) => {
          const subStore = record.get(field.name);
          recordData[field.dataSource] = this.getCrudStoreChanges({
            store: subStore
          });
        });
        if (!ObjectHelper.isEmpty(recordData)) {
          data.push(recordData);
        }
        return data;
      }, []);
    }
    prepareRemoved(list) {
      return list.map((record) => {
        const cls = record.constructor;
        return ObjectHelper.setPath({}, cls.idField, record.id);
      });
    }
    getCrudStoreChanges(storeDescriptor) {
      const {
        store
      } = storeDescriptor;
      let {
        added = [],
        modified: updated = [],
        removed = []
      } = store.changes || {}, result;
      if (added.length)
        added = this.prepareAdded(added, storeDescriptor);
      if (updated.length)
        updated = this.prepareUpdated(updated, storeDescriptor);
      if (removed.length)
        removed = this.prepareRemoved(removed);
      if (added.length || updated.length || removed.length) {
        result = {};
        if (added.length)
          result.added = added;
        if (updated.length)
          result.updated = updated;
        if (removed.length)
          result.removed = removed;
      }
      return result;
    }
    getChangesetPackage() {
      const {
        changes
      } = this;
      return changes || this.forceSync ? _objectSpread2({
        type: "sync",
        requestId: this.requestId,
        revision: this.crudRevision
      }, changes) : null;
    }
    get changes() {
      const data = {};
      this.crudStores.forEach((store) => {
        const changes = this.getCrudStoreChanges(store);
        if (changes) {
          data[store.storeId] = changes;
        }
      });
      return Object.keys(data).length > 0 ? data : null;
    }
    getRowsToApplyChangesTo({
      store,
      storeId
    }, storeResponse, storePack) {
      var _rows, _removed;
      const me = this, {
        modelClass
      } = store, idDataSource = modelClass.idField, {
        updated: requestUpdated,
        removed: requestRemoved
      } = storePack || {};
      let rows, removed, remote;
      if (storeResponse) {
        var _storeResponse$rows, _storeResponse$remove;
        remote = true;
        const respondedIds = {};
        rows = ((_storeResponse$rows = storeResponse.rows) === null || _storeResponse$rows === void 0 ? void 0 : _storeResponse$rows.slice()) || [];
        removed = ((_storeResponse$remove = storeResponse.removed) === null || _storeResponse$remove === void 0 ? void 0 : _storeResponse$remove.slice()) || [];
        [...rows, ...removed].forEach((responseRecord) => {
          const id = ObjectHelper.getPath(responseRecord, idDataSource);
          respondedIds[id] = true;
        });
        if (me.supportShortSyncResponse) {
          requestUpdated === null || requestUpdated === void 0 ? void 0 : requestUpdated.forEach((data) => {
            const id = ObjectHelper.getPath(data, idDataSource);
            if (!respondedIds[id]) {
              rows.push({
                [idDataSource]: id
              });
            }
          });
          requestRemoved === null || requestRemoved === void 0 ? void 0 : requestRemoved.forEach((data) => {
            const id = ObjectHelper.getPath(data, idDataSource);
            if (!respondedIds[id]) {
              removed.push({
                [idDataSource]: id
              });
            }
          });
        }
      } else if (requestUpdated || requestRemoved) {
        remote = false;
        rows = requestUpdated;
        removed = requestRemoved;
      }
      rows = (_rows = rows) !== null && _rows !== void 0 && _rows.length ? rows : null;
      removed = (_removed = removed) !== null && _removed !== void 0 && _removed.length ? removed : null;
      return {
        rows,
        removed,
        remote
      };
    }
    applyChangesToStore(storeDesc, storeResponse, storePack) {
      const me = this, phantomIdField = storeDesc.phantomIdField || me.phantomIdField, {
        store
      } = storeDesc, idField = store.modelClass.getFieldDataSource("id"), subStoreFields = store.modelClass.allFields.filter((field) => field.subStore), {
        rows,
        removed,
        remote
      } = me.getRowsToApplyChangesTo(storeDesc, storeResponse, storePack), added = [], updated = [];
      if (rows) {
        for (const data of rows) {
          var _data$phantomIdField;
          if (store.getById((_data$phantomIdField = data[phantomIdField]) !== null && _data$phantomIdField !== void 0 ? _data$phantomIdField : data[idField])) {
            updated.push(data);
          } else {
            added.push(data);
          }
        }
      }
      const extraLogEntries = [];
      if (updated.length && subStoreFields.length) {
        updated.forEach((updateData) => {
          var _updateData$phantomId, _storePack$added, _storePack$updated;
          const record = store.getById((_updateData$phantomId = updateData[phantomIdField]) !== null && _updateData$phantomId !== void 0 ? _updateData$phantomId : updateData[idField]), recordRequest = ((_storePack$added = storePack.added) === null || _storePack$added === void 0 ? void 0 : _storePack$added.find((t) => t[phantomIdField] == updateData[phantomIdField])) || ((_storePack$updated = storePack.updated) === null || _storePack$updated === void 0 ? void 0 : _storePack$updated.find((t) => t[idField] == updateData[idField]));
          const extraLogInfo = {};
          subStoreFields.forEach((field) => {
            const store2 = record.get(field.name);
            me.applyChangesToStore({
              store: store2
            }, updateData[field.dataSource], recordRequest === null || recordRequest === void 0 ? void 0 : recordRequest[field.dataSource]);
            extraLogInfo[field.dataSource] = "foo";
            delete updateData[field.dataSource];
          });
          extraLogEntries.push([record, extraLogInfo]);
        });
      }
      const log = store.applyChangeset({
        removed,
        added,
        updated
      }, null, phantomIdField, remote, true);
      extraLogEntries.forEach(([record, logEntry]) => Object.assign(log.get(record.id), logEntry));
      return log;
    }
    applySyncResponse(response, request) {
      const me = this, stores2 = me.orderedCrudStores;
      me.applyingChangeset = me.applyingSyncResponse = true;
      me.suspendChangesTracking();
      for (const store of stores2) {
        var _request$pack;
        me.applyChangesToStore(store, response[store.storeId], request === null || request === void 0 ? void 0 : (_request$pack = request.pack) === null || _request$pack === void 0 ? void 0 : _request$pack[store.storeId]);
      }
      me.resumeChangesTracking(true);
      me.applyingChangeset = me.applyingSyncResponse = false;
    }
    applyLoadResponse(response, options) {
      this.applyingLoadResponse = true;
      this.loadCrudManagerData(response, options);
      this.applyingLoadResponse = false;
    }
    async applyResponse(request, response, options) {
      const me = this, responseType = me.trackResponseType && response.type || request.type;
      switch (responseType) {
        case "load":
          if (me.validateResponse) {
            me.validateLoadResponse(response);
          }
          me.applyLoadResponse(response, options);
          break;
        case "sync":
          if (me.validateResponse) {
            me.validateSyncResponse(response, request);
          }
          me.applySyncResponse(response, request);
          break;
      }
    }
    applyChangeset(changes, transformFn = null, phantomIdField, logChanges = false) {
      const me = this, log = logChanges ? /* @__PURE__ */ new Map() : void 0;
      me.suspendAutoSync();
      me.suspendChangesTracking();
      for (const {
        store,
        phantomIdField: phantomIdField2
      } of me.orderedCrudStores) {
        if (changes[store.id]) {
          const storeLog = store.applyChangeset(
            changes[store.id],
            transformFn,
            phantomIdField2 || me.phantomIdField,
            true,
            logChanges
          );
          if (storeLog) {
            log.set(store.id, storeLog);
          }
        }
      }
      me.resumeChangesTracking(true);
      me.resumeAutoSync(false);
      return log;
    }
    get requestId() {
      return Number.parseInt(`${Date.now()}${this._requestId++}`);
    }
    sync() {
      const me = this;
      me.clearTimeout("autoSync");
      if (me.activeRequests.sync) {
        me.trigger("syncDelayed");
        return me.activeSyncPromise = me.activeSyncPromise.finally(() => me.sync());
      }
      return me.activeSyncPromise = new Promise((resolve, reject) => {
        const pack = me.getChangesetPackage();
        if (!pack) {
          resolve(null);
          return;
        }
        if (me.trigger("beforeSync", {
          pack
        }) !== false) {
          me.trigger("syncStart", {
            pack
          });
          me.activeRequests.sync = {
            type: "sync",
            pack,
            resolve,
            reject,
            id: pack.requestId,
            desc: me.sendRequest({
              id: pack.requestId,
              data: me.encode(pack),
              type: "sync",
              success: me.onCrudRequestSuccess,
              failure: me.onCrudRequestFailure,
              thisObj: me
            })
          };
        } else {
          me.trigger("syncCanceled", {
            pack
          });
          reject({
            cancelled: true
          });
        }
      }).catch((error) => {
        if (error && !error.cancelled) {
          throw error;
        }
        return error;
      });
    }
    async onCrudRequestSuccess(rawResponse, fetchOptions, request) {
      var _request;
      const me = this, {
        type: requestType,
        id: requestId
      } = request;
      if (me.isDestroyed)
        return;
      let responseText = "";
      request = me.activeRequests[requestType];
      try {
        responseText = await rawResponse.text();
      } catch (e) {
      }
      if (me.isDestroyed)
        return;
      if (((_request = request) === null || _request === void 0 ? void 0 : _request.id) !== requestId) {
        throw new Error(`Interleaved ${requestType} operation detected`);
      }
      me.activeRequests[requestType] = null;
      const response = await me.internalOnResponse(request, responseText, fetchOptions);
      if (me.isDestroyed)
        return;
      if (!response || (me.skipSuccessProperty ? (response === null || response === void 0 ? void 0 : response.success) === false : !(response !== null && response !== void 0 && response.success))) {
        const error = {
          rawResponse,
          response,
          request
        };
        if (response !== null && response !== void 0 && response.message) {
          error.message = response.message;
        }
        request.reject(new CrudManagerRequestError(error));
      }
      me["crud" + StringHelper.capitalize(request.type) + "ed"] = true;
      request.resolve({
        response,
        rawResponse,
        responseText,
        request
      });
    }
    async onCrudRequestFailure(rawResponse, fetchOptions, request) {
      var _fetchOptions$abortCo;
      const me = this;
      if (me.isDestroyed)
        return;
      request = me.activeRequests[request.type];
      const signal = fetchOptions === null || fetchOptions === void 0 ? void 0 : (_fetchOptions$abortCo = fetchOptions.abortController) === null || _fetchOptions$abortCo === void 0 ? void 0 : _fetchOptions$abortCo.signal, wasAborted = Boolean(signal === null || signal === void 0 ? void 0 : signal.aborted);
      if (!wasAborted) {
        let response, responseText = "";
        try {
          responseText = await rawResponse.text();
          response = me.decode(responseText);
        } catch (e) {
        }
        if (me.isDestroyed)
          return;
        me.triggerFailedRequestEvents(request, response, responseText, fetchOptions);
        if (me.isDestroyed)
          return;
        request.reject(new CrudManagerRequestError({
          rawResponse,
          request
        }));
      }
      me.activeRequests[request.type] = null;
    }
    acceptChanges() {
      this.crudStores.forEach((store) => store.store.acceptChanges());
    }
    revertChanges() {
      this.revertCrudStoreChanges();
    }
    revertCrudStoreChanges() {
      this.orderedCrudStores.forEach((store) => store.store.revertChanges());
    }
    doDestroy() {
      const me = this, {
        load,
        sync
      } = me.activeRequests;
      load && me.cancelRequest(load.desc, load.reject);
      sync && me.cancelRequest(sync.desc, sync.reject);
      while (me.crudStores.length > 0) {
        me.removeCrudStore(me.crudStores[0]);
      }
      super.doDestroy && super.doDestroy();
    }
  }, _defineProperty(_class, "configurable", {
    loadUrl: null,
    syncUrl: null,
    forceSync: null
  }), _class;
};
var AbstractCrudManager = class extends Base$1.mixin(AbstractCrudManagerMixin) {
  get revision() {
    return this.crudRevision;
  }
  set revision(value) {
    this.crudRevision = value;
  }
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  set json(json) {
    if (typeof json === "string") {
      json = StringHelper.safeJsonParse(json);
    }
    this.forEachCrudStore((store) => {
      const dataName = `${store.storeId}Data`;
      if (json[dataName]) {
        store.data = json[dataName];
      }
    });
  }
  static get defaultConfig() {
    return {
      stores: null
    };
  }
  construct(config = {}) {
    if (config.stores) {
      config.crudStores = config.stores;
      delete config.stores;
    }
    super.construct(config);
  }
  toJSON() {
    const result = {};
    this.forEachCrudStore((store, storeId) => result[`${storeId}Data`] = store.toJSON());
    return result;
  }
  get inlineData() {
    return this.toJSON();
  }
  set inlineData(data) {
    this.json = data;
  }
  set stores(stores2) {
    if (stores2 !== this.crudStores) {
      this.crudStores = stores2;
    }
  }
  get stores() {
    return this.crudStores;
  }
  get isLoading() {
    return this.isCrudManagerLoading;
  }
  addStore(...args) {
    return this.addCrudStore(...args);
  }
  removeStore(...args) {
    return this.removeCrudStore(...args);
  }
  getStore(...args) {
    return this.getCrudStore(...args);
  }
  hasChanges(...args) {
    return this.crudStoreHasChanges(...args);
  }
  loadData(...args) {
    return this.loadCrudManagerData(...args);
  }
};
AbstractCrudManager._$name = "AbstractCrudManager";
var AjaxTransport = (Target) => class AjaxTransport2 extends (Target || Base$1) {
  static get $name() {
    return "AjaxTransport";
  }
  static get defaultMethod() {
    return {
      load: "GET",
      sync: "POST"
    };
  }
  cancelRequest(requestPromise, reject) {
    var _requestPromise$abort;
    (_requestPromise$abort = requestPromise.abort) === null || _requestPromise$abort === void 0 ? void 0 : _requestPromise$abort.call(requestPromise);
    if (!this.isDestroying) {
      reject({
        cancelled: true
      });
    }
  }
  shouldUseBodyForRequestData(packCfg, method, paramName) {
    return !(method === "HEAD" || method === "GET") && !paramName;
  }
  sendRequest(request) {
    const me = this, {
      data
    } = request, transportConfig = me.transport[request.type] || {}, requestConfig = Objects.assign({}, transportConfig, transportConfig.requestConfig);
    if (request.url) {
      requestConfig.url = request.url;
    }
    requestConfig.method = requestConfig.method || AjaxTransport2.defaultMethod[request.type];
    requestConfig.params = Objects.assign(requestConfig.params || {}, request.params);
    let {
      paramName
    } = requestConfig;
    if (me.shouldUseBodyForRequestData(transportConfig, requestConfig.method, paramName)) {
      requestConfig.body = data;
      requestConfig.headers = requestConfig.headers || {};
      requestConfig.headers["Content-Type"] = requestConfig.headers["Content-Type"] || "application/json";
    } else {
      paramName = paramName || "data";
      requestConfig.params[paramName] = data;
    }
    if (!requestConfig.url) {
      throw new Error("Trying to request without URL specified");
    }
    delete requestConfig.requestConfig;
    delete requestConfig.paramName;
    let ajaxPromise, resultPromise;
    function performSend() {
      requestConfig.queryParams = requestConfig.params;
      delete requestConfig.params;
      let cancelled = false;
      const fetchOptions = Objects.assign({}, requestConfig, requestConfig.fetchOptions);
      ajaxPromise = AjaxHelper.fetch(requestConfig.url, fetchOptions);
      return ajaxPromise.catch((error) => {
        var _me$trigger, _fetchOptions$abortCo;
        ajaxPromise.done = true;
        (_me$trigger = me.trigger) === null || _me$trigger === void 0 ? void 0 : _me$trigger.call(me, "responseReceived", {
          success: false
        });
        const signal = (_fetchOptions$abortCo = fetchOptions.abortController) === null || _fetchOptions$abortCo === void 0 ? void 0 : _fetchOptions$abortCo.signal;
        if (signal) {
          cancelled = signal.aborted;
          if (!cancelled) {
            console.warn(error);
          }
        }
        return {
          error,
          cancelled
        };
      }).then((response) => {
        var _me$trigger2;
        ajaxPromise.done = true;
        (_me$trigger2 = me.trigger) === null || _me$trigger2 === void 0 ? void 0 : _me$trigger2.call(me, "responseReceived", {
          success: Boolean(response === null || response === void 0 ? void 0 : response.ok)
        });
        const callback = response !== null && response !== void 0 && response.ok ? request.success : request.failure;
        return callback === null || callback === void 0 ? void 0 : callback.call(request.thisObj || me, response, fetchOptions, request);
      });
    }
    const beforeSendResult = me.trigger("beforeSend", {
      params: requestConfig.params,
      type: request.type,
      requestConfig,
      config: request
    });
    if (Objects.isPromise(beforeSendResult)) {
      resultPromise = beforeSendResult.then(performSend);
    } else {
      resultPromise = performSend();
    }
    resultPromise.abort = () => {
      if (!ajaxPromise.done) {
        var _ajaxPromise$abort, _ajaxPromise;
        (_ajaxPromise$abort = (_ajaxPromise = ajaxPromise).abort) === null || _ajaxPromise$abort === void 0 ? void 0 : _ajaxPromise$abort.call(_ajaxPromise);
      }
    };
    return resultPromise;
  }
};
var JsonEncoder = (Target) => class JsonEncoder extends (Target || Base$1) {
  static get $name() {
    return "JsonEncoder";
  }
  static get defaultConfig() {
    return {
      encoder: {}
    };
  }
  encode(requestData) {
    var _this$encoder;
    requestData = Object.assign({}, (_this$encoder = this.encoder) === null || _this$encoder === void 0 ? void 0 : _this$encoder.requestData, requestData);
    return StringHelper.safeJsonStringify(requestData);
  }
  decode(responseText) {
    return StringHelper.safeJsonParse(responseText);
  }
};
var CrudManagerView = (Target) => {
  var _class;
  return _class = class CrudManagerView extends Target.mixin(LoadMaskable) {
    static get $name() {
      return "CrudManagerView";
    }
    afterConstruct() {
      super.afterConstruct();
      const {
        crudManager,
        project
      } = this;
      if (this.loadMask && (crudManager || project).isCrudManagerLoading) {
        this.onCrudManagerLoadStart();
      }
    }
    applySyncMask() {
      const {
        syncMask
      } = this;
      if (syncMask) {
        this.masked = Mask.mergeConfigs(this.loadMaskDefaults, syncMask);
      }
    }
    bindCrudManager(crudManager) {
      this.detachListeners("crudManager");
      crudManager === null || crudManager === void 0 ? void 0 : crudManager.ion({
        name: "crudManager",
        loadStart: "onCrudManagerLoadStart",
        load: "onCrudManagerLoad",
        loadCanceled: "onCrudManagerLoadCanceled",
        syncStart: "onCrudManagerSyncStart",
        sync: "onCrudManagerSync",
        syncCanceled: "onCrudManagerSyncCanceled",
        requestFail: "onCrudManagerRequestFail",
        responseReceived: "onAjaxTransportResponseReceived",
        thisObj: this
      });
    }
    onCrudManagerLoadStart() {
      var _this$toggleEmptyText;
      this.applyLoadMask();
      (_this$toggleEmptyText = this.toggleEmptyText) === null || _this$toggleEmptyText === void 0 ? void 0 : _this$toggleEmptyText.call(this);
    }
    onCrudManagerSyncStart() {
      this.applySyncMask();
    }
    onCrudManagerRequestFinalize(successful = true, requestType, response) {
      const me = this;
      if (successful) {
        var _me$toggleEmptyText;
        (_me$toggleEmptyText = me.toggleEmptyText) === null || _me$toggleEmptyText === void 0 ? void 0 : _me$toggleEmptyText.call(me);
      } else {
        if (!me.masked) {
          me.applyLoadMask();
        }
        me.applyMaskError(`<div class="b-grid-load-failure">
                    <div class="b-grid-load-fail">${me.L(`L{GridBase.${requestType}FailedMessage}`)}</div>
                    ${response && response.message ? `<div class="b-grid-load-fail">${me.L("L{CrudManagerView.serverResponseLabel}")} ${response.message}</div>` : ""}
                </div>`);
      }
    }
    onCrudManagerLoadCanceled() {
      this.onCrudManagerRequestFinalize(true, "load");
    }
    onCrudManagerSyncCanceled() {
      this.onCrudManagerRequestFinalize(true, "sync");
    }
    onCrudManagerLoad() {
      this.onCrudManagerRequestFinalize(true, "load");
    }
    onCrudManagerSync() {
      this.onCrudManagerRequestFinalize(true, "sync");
      this.refresh();
    }
    onCrudManagerRequestFail({
      requestType,
      response
    }) {
      this.onCrudManagerRequestFinalize(false, requestType, response);
    }
    onAjaxTransportResponseReceived() {
      const me = this;
      if (me.clearMaskDelay != null) {
        me.setTimeout(() => me.masked = null, me.clearMaskDelay);
      } else {
        me.masked = null;
      }
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "config", {
    clearMaskDelay: null,
    testConfig: {
      clearMaskDelay: 0
    }
  }), _class;
};
var PartOfProject = (Target) => class PartOfProject extends (Target || Base$1) {
  static get $name() {
    return "PartOfProject";
  }
};
var AssignmentModelMixin = (Target) => class AssignmentModelMixin extends Target {
  static get $name() {
    return "AssignmentModelMixin";
  }
  static get fields() {
    return [
      "resourceId",
      "eventId",
      {
        name: "drawDependencies",
        type: "boolean"
      },
      "event",
      "resource"
    ];
  }
  construct(data, ...args) {
    data = data || {};
    const eventId = data[this.fieldMap.eventId.dataSource], resourceId = data[this.fieldMap.resourceId.dataSource];
    if (eventId != null) {
      data.event = eventId;
    }
    if (resourceId != null) {
      data.resource = resourceId;
    }
    super.construct(data, ...args);
  }
  get eventResourceKey() {
    return this.buildEventResourceKey(this.event, this.resource);
  }
  buildEventResourceKey(event, resource) {
    let eventKey, resourceKey;
    if (event) {
      eventKey = event.isModel ? event.id : event;
    } else {
      eventKey = this.internalId;
    }
    if (resource) {
      resourceKey = resource.isModel ? resource.id : resource;
    } else {
      resourceKey = this.internalId;
    }
    return `${eventKey}-${resourceKey}`;
  }
  buildIndexKey({
    event,
    resource
  }) {
    return this.buildEventResourceKey(event, resource);
  }
  set(field, value, ...args) {
    const toSet = this.fieldToKeys(field, value);
    if ("resource" in toSet) {
      var _toSet$resource;
      if ((_toSet$resource = toSet.resource) !== null && _toSet$resource !== void 0 && _toSet$resource.id) {
        toSet.resourceId = toSet.resource.id;
      }
    } else if ("resourceId" in toSet && this.constructor.isProAssignmentModel) {
      toSet.resource = toSet.resourceId;
    }
    if ("event" in toSet) {
      var _toSet$event;
      if ((_toSet$event = toSet.event) !== null && _toSet$event !== void 0 && _toSet$event.id) {
        toSet.eventId = toSet.event.id;
      }
    } else if ("eventId" in toSet && this.constructor.isProAssignmentModel) {
      toSet.event = toSet.eventId;
    }
    return super.set(toSet, null, ...args);
  }
  afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {
    var _me$resource, _me$project;
    const me = this;
    if (!me.constructor.isProAssignmentModel && wasSet !== null && wasSet !== void 0 && wasSet.resourceId && ((_me$resource = me.resource) === null || _me$resource === void 0 ? void 0 : _me$resource.id) !== wasSet.resourceId.value) {
      me.resource = wasSet.resourceId.value;
    } else if (me.constructor.isProAssignmentModel && (_me$project = me.project) !== null && _me$project !== void 0 && _me$project.propagatingSyncChanges && wasSet !== null && wasSet !== void 0 && wasSet.eventId && !(wasSet !== null && wasSet !== void 0 && wasSet.event) && (toSet.event.value === wasSet.eventId.value || toSet.event.value.id === wasSet.eventId.value)) {
      delete wasSet.eventId;
      delete me.meta.modified.eventId;
    }
    return super.afterChange(...arguments);
  }
  set resourceId(value) {
    const {
      resource
    } = this;
    if (resource !== null && resource !== void 0 && resource.isModel && resource.id === value) {
      this.set("resourceId", value);
    } else {
      this.resource = value;
    }
  }
  get resourceId() {
    var _this$resource;
    return this.get("resourceId") || ((_this$resource = this.resource) === null || _this$resource === void 0 ? void 0 : _this$resource.id);
  }
  set eventId(value) {
    const {
      event
    } = this;
    if (event !== null && event !== void 0 && event.isModel && event.id === value) {
      this.set("eventId", value);
    } else {
      this.event = value;
    }
  }
  get eventId() {
    var _this$event;
    return this.get("eventId") || ((_this$event = this.event) === null || _this$event === void 0 ? void 0 : _this$event.id);
  }
  get eventName() {
    var _this$event2;
    return (_this$event2 = this.event) === null || _this$event2 === void 0 ? void 0 : _this$event2.name;
  }
  get resourceName() {
    var _this$resource2;
    return (_this$resource2 = this.resource) === null || _this$resource2 === void 0 ? void 0 : _this$resource2.name;
  }
  getResource() {
    return this.resource;
  }
  get isAssignment() {
    return true;
  }
  get isPersistable() {
    var _this$event3;
    const {
      event,
      resource,
      unjoinedStores,
      assignmentStore
    } = this, crudManager = assignmentStore === null || assignmentStore === void 0 ? void 0 : assignmentStore.crudManager;
    let result;
    if (assignmentStore) {
      result = this.isValid && event.isPersistable && (crudManager || !event.hasGeneratedId && !resource.hasGeneratedId);
    } else {
      result = !this.isPhantom && Boolean(unjoinedStores[0]);
    }
    return result && super.isPersistable && !((_this$event3 = this.event) !== null && _this$event3 !== void 0 && _this$event3.isCreating);
  }
  get isValid() {
    return this.resource != null && this.event != null;
  }
  toString() {
    if (this.resourceName) {
      return `${this.resourceName} ${Math.round(this.units)}%`;
    }
    return "";
  }
  shouldRecordFieldChange(fieldName, oldValue, newValue) {
    if (!super.shouldRecordFieldChange(fieldName, oldValue, newValue)) {
      return false;
    }
    if (fieldName === "event" || fieldName === "eventId") {
      var _this$project;
      const eventStore = (_this$project = this.project) === null || _this$project === void 0 ? void 0 : _this$project.eventStore;
      if (eventStore && eventStore.oldIdMap[oldValue] === eventStore.getById(newValue)) {
        return false;
      }
    }
    if (fieldName === "resource" || fieldName === "resourceId") {
      var _this$project2;
      const resourceStore = (_this$project2 = this.project) === null || _this$project2 === void 0 ? void 0 : _this$project2.resourceStore;
      if (resourceStore && resourceStore.oldIdMap[oldValue] === resourceStore.getById(newValue)) {
        return false;
      }
    }
    return true;
  }
};
var EngineMixin$8 = CoreAssignmentMixin;
var AssignmentModel = class extends AssignmentModelMixin(PartOfProject(EngineMixin$8.derive(Model))) {
  static get $name() {
    return "AssignmentModel";
  }
  get resource() {
    return super.resource;
  }
  set resource(resource) {
    super.resource = resource;
    this.setChanged("resourceId", this.constructor.asId(resource));
  }
};
AssignmentModel.exposeProperties();
AssignmentModel._$name = "AssignmentModel";
var PartOfBaseProject = (Target) => class PartOfBaseProject extends Target {
  static get $name() {
    return "PartOfBaseProject";
  }
  get assignmentStore() {
    return this.project.assignmentStore;
  }
  get calendarManagerStore() {
    return this.project.calendarManagerStore;
  }
  get dependencyStore() {
    return this.project.dependencyStore;
  }
  get eventStore() {
    return this.project.eventStore;
  }
  get resourceStore() {
    return this.project.resourceStore;
  }
};
var AssignmentStoreMixin = (Target) => class AssignmentStoreMixin extends Target {
  static get $name() {
    return "AssignmentStoreMixin";
  }
  static get defaultConfig() {
    return {
      loadPriority: 300,
      syncPriority: 300,
      storeId: "assignments"
    };
  }
  add(newAssignments, ...args) {
    newAssignments = ArrayHelper.asArray(newAssignments);
    for (let i = 0; i < newAssignments.length; i++) {
      var _assignment$event;
      let assignment = newAssignments[i];
      if (!(assignment instanceof Model)) {
        newAssignments[i] = assignment = this.createRecord(assignment);
      }
      if (!this.isSyncingDataOnLoad && this.storage.findIndex("eventResourceKey", assignment.eventResourceKey, true) !== -1) {
        throw new Error(`Duplicate assignment Event: ${assignment.eventId} to resource: ${assignment.resourceId}`);
      }
      if ((_assignment$event = assignment.event) !== null && _assignment$event !== void 0 && _assignment$event.isCreating) {
        assignment.isCreating = true;
      }
    }
    return super.add(newAssignments, ...args);
  }
  includesAssignment(eventId, resourceId) {
    return this.storage.findIndex("eventResourceKey", `${eventId}-${resourceId}`, true) !== -1;
  }
  setStoreData(data) {
    super.setStoreData(data);
  }
  set storage(storage) {
    super.storage = storage;
    this.storage.addIndex({
      property: "eventResourceKey",
      dependentOn: {
        event: true,
        resource: true
      }
    });
  }
  get storage() {
    return this._storage || super.storage;
  }
  get isAssignmentStore() {
    return true;
  }
  getOccurrence(originalAssignment, occurrence) {
    if (!originalAssignment || !(occurrence !== null && occurrence !== void 0 && occurrence.isOccurrence)) {
      return originalAssignment;
    }
    const me = this;
    return {
      id: `${occurrence.id}:a${originalAssignment.id}`,
      event: occurrence,
      resource: originalAssignment.resource,
      eventId: occurrence.id,
      resourceId: originalAssignment.resource.id,
      isAssignment: true,
      isOccurrenceAssignment: true,
      instanceMeta(instanceOrId) {
        return me.occurrenceInstanceMeta(this, instanceOrId);
      }
    };
  }
  occurrenceInstanceMeta(occurrenceAssignment, instanceOrId) {
    const me = this, instanceId = instanceOrId.id || instanceOrId, {
      id
    } = occurrenceAssignment;
    let {
      occurrenceMeta
    } = me;
    if (!occurrenceMeta) {
      occurrenceMeta = me.occurrenceMeta = {};
    }
    if (!occurrenceMeta[id]) {
      occurrenceMeta[id] = {};
    }
    return occurrenceMeta[id][instanceId] || (occurrenceMeta[id][instanceId] = {});
  }
  mapAssignmentsForEvent(event, fn2, filterFn) {
    event = this.eventStore.getById(event);
    const fnSet = Boolean(fn2), filterFnSet = Boolean(filterFn);
    if (fnSet || filterFnSet) {
      return event.assignments.reduce((result, assignment) => {
        const mapResult = fnSet ? fn2(assignment) : assignment;
        if (!filterFnSet || filterFn(mapResult)) {
          result.push(mapResult);
        }
        return result;
      }, []);
    }
    return event.assignments;
  }
  mapAssignmentsForResource(resource, fn2, filterFn) {
    resource = this.resourceStore.getById(resource);
    const fnSet = Boolean(fn2), filterFnSet = Boolean(filterFn);
    if (fnSet || filterFnSet) {
      return resource.assignments.reduce((result, assignment) => {
        const mapResult = fnSet ? fn2(assignment) : assignment;
        if (!filterFnSet || filterFn(mapResult)) {
          result.push(mapResult);
        }
        return result;
      }, []);
    }
    return resource.assignments;
  }
  getAssignmentsForEvent(event) {
    return event.assignments;
  }
  removeAssignmentsForEvent(event) {
    return this.remove(event.assignments);
  }
  getAssignmentsForResource(resource) {
    resource = this.resourceStore.getById(resource);
    return resource.assignments;
  }
  removeAssignmentsForResource(resource) {
    this.remove(this.getAssignmentsForResource(resource));
  }
  getResourcesForEvent(event) {
    return event.resources;
  }
  getEventsForResource(resource) {
    var _resource;
    resource = this.resourceStore.getById(resource);
    return (_resource = resource) === null || _resource === void 0 ? void 0 : _resource.events;
  }
  assignEventToResource(event, resources, assignmentSetupFn = null, removeExistingAssignments = false) {
    var _me$eventStore;
    const me = this, toRemove = removeExistingAssignments ? new Set(event.assignments) : null;
    resources = ArrayHelper.asArray(resources).map((r) => {
      var _r$$original;
      return (_r$$original = r.$original) !== null && _r$$original !== void 0 ? _r$$original : r;
    });
    if ((_me$eventStore = me.eventStore) !== null && _me$eventStore !== void 0 && _me$eventStore.usesSingleAssignment) {
      var _event$assignments;
      if ((_event$assignments = event.assignments) !== null && _event$assignments !== void 0 && _event$assignments.length) {
        if (!me.isEventAssignedToResource(event, resources[0])) {
          event.resource = resources[0];
        }
        return [];
      } else {
        event.resourceId = resources[0].id;
      }
    }
    let newAssignments = [];
    me.suspendAutoCommit();
    resources.forEach((resource) => {
      const existingAssignment = me.getAssignmentForEventAndResource(event, resource);
      if (!existingAssignment) {
        var _assignmentSetupFn;
        const assignment = {
          event,
          resource
        };
        newAssignments.push((_assignmentSetupFn = assignmentSetupFn === null || assignmentSetupFn === void 0 ? void 0 : assignmentSetupFn(assignment)) !== null && _assignmentSetupFn !== void 0 ? _assignmentSetupFn : assignment);
      } else if (removeExistingAssignments) {
        toRemove.delete(existingAssignment);
      }
    });
    newAssignments = me.add(newAssignments);
    if (removeExistingAssignments) {
      me.remove(Array.from(toRemove));
    }
    me.resumeAutoCommit();
    return newAssignments;
  }
  unassignEventFromResource(event, resources) {
    const me = this, assignmentsToRemove = [];
    if (!resources) {
      return me.removeAssignmentsForEvent(event);
    }
    resources = ArrayHelper.asArray(resources);
    for (let i = 0; i < resources.length; i++) {
      if (me.isEventAssignedToResource(event, resources[i])) {
        assignmentsToRemove.push(me.getAssignmentForEventAndResource(event, resources[i]));
      }
    }
    return me.remove(assignmentsToRemove);
  }
  isEventAssignedToResource(event, resource) {
    return Boolean(this.getAssignmentForEventAndResource(event, resource));
  }
  getAssignmentForEventAndResource(event, resource) {
    let assignments;
    if (!(event = this.eventStore.getById(event)) || !(assignments = event.assignments) || !(resource = this.resourceStore.$master.getById(resource))) {
      return null;
    }
    return this.getOccurrence(assignments.find((a) => {
      var _a$resource;
      return ((_a$resource = a.resource) === null || _a$resource === void 0 ? void 0 : _a$resource.$original) === resource.$original;
    }), event);
  }
};
var EngineMixin$7 = PartOfProject(CoreAssignmentStoreMixin.derive(AjaxStore));
var AssignmentStore = class extends AssignmentStoreMixin(EngineMixin$7) {
  static get defaultConfig() {
    return {
      modelClass: AssignmentModel
    };
  }
};
_defineProperty(AssignmentStore, "$name", "AssignmentStore");
AssignmentStore._$name = "AssignmentStore";
var ResourceStoreMixin = (Target) => class ResourceStoreMixin extends (Target || Base$1) {
  static get $name() {
    return "ResourceStoreMixin";
  }
  get isResourceStore() {
    return true;
  }
  static get defaultConfig() {
    return {
      loadPriority: 200,
      syncPriority: 100,
      storeId: "resources",
      autoTree: true
    };
  }
  construct(config) {
    super.construct(config);
    if (!this.modelClass.isResourceModel) {
      throw new Error("Model for ResourceStore must subclass ResourceModel");
    }
  }
  removeAll() {
    const result = super.removeAll(...arguments);
    result && this.assignmentStore.removeAll();
    return result;
  }
  onRecordIdChange({
    record,
    oldValue,
    value
  }) {
    super.onRecordIdChange({
      record,
      oldValue,
      value
    });
    if (record.isFieldModified("id")) {
      this.isChangingId = true;
      record.updateAssignmentResourceIds();
      this.isChangingId = false;
    }
  }
  get allResourceRecords() {
    return this._allResourceRecords || (this._allResourceRecords = this.getAllDataRecords());
  }
  getAvailableResources({
    startDate,
    endDate
  }) {
    return this.query((resource) => this.eventStore.isDateRangeAvailable(startDate, endDate, null, resource));
  }
};
var ResourceModelMixin = (Target) => class ResourceModelMixin extends Target {
  static get $name() {
    return "ResourceModelMixin";
  }
  static get isResourceModel() {
    return true;
  }
  static get fields() {
    return [
      {
        name: "name",
        type: "string",
        persist: true
      },
      "eventColor",
      "eventStyle",
      "imageUrl",
      "image",
      {
        name: "resourceMargin",
        type: "number"
      },
      {
        name: "barMargin",
        type: "number"
      },
      "eventLayout"
    ];
  }
  updateAssignmentResourceIds() {
    this.assigned.forEach((assignment) => {
      assignment.resourceId = this.id;
    });
  }
  syncId(value) {
    super.syncId(value);
    this.updateAssignmentResourceIds();
  }
  get events() {
    return this.assignments.reduce((events, assignment) => {
      if (assignment.event) {
        events.push(assignment.event);
      }
      return events;
    }, []);
  }
  get assignments() {
    return this.assigned ? [...this.assigned] : [];
  }
  set assignments(assignments) {
    assignments.forEach((assignment) => {
      assignment.resource = this;
    });
  }
  getEvents() {
    return this.events;
  }
  get isPersistable() {
    return super.isPersistable && (!this.parent || this.parent.isPersistable);
  }
  unassignAll() {
    this.assignments && this.assignmentStore.remove(this.assignments);
  }
  get initials() {
    const {
      name = ""
    } = this;
    if (!name) {
      return "";
    }
    const names = name.split(" "), firstInitial = names[0][0], lastInitial = names.length > 1 ? names[names.length - 1][0] : "";
    return firstInitial + lastInitial;
  }
  isWorkingTime(date2) {
    var _this$project, _calendar$isWorkingTi;
    const calendar = this.effectiveCalendar || ((_this$project = this.project) === null || _this$project === void 0 ? void 0 : _this$project.calendar);
    return !calendar || ((_calendar$isWorkingTi = calendar.isWorkingTime) === null || _calendar$isWorkingTi === void 0 ? void 0 : _calendar$isWorkingTi.call(calendar, date2));
  }
};
var EngineMixin$6 = CoreResourceMixin;
var ResourceModel = class extends ResourceModelMixin(PartOfProject(EngineMixin$6.derive(GridRowModel))) {
  static get $name() {
    return "ResourceModel";
  }
};
ResourceModel.exposeProperties();
ResourceModel._$name = "ResourceModel";
var EngineMixin$5 = PartOfProject(CoreResourceStoreMixin.derive(AjaxStore));
var ResourceStore = class extends ResourceStoreMixin(EngineMixin$5) {
  static get defaultConfig() {
    return {
      modelClass: ResourceModel
    };
  }
};
ResourceStore._$name = "ResourceStore";
var EventStoreMixin = (Target) => class EventStoreMixin extends (Target || Base$1) {
  static get $name() {
    return "EventStoreMixin";
  }
  construct(config) {
    super.construct(config);
    this.autoTree = true;
  }
  set filtersFunction(filtersFunction) {
    super.filtersFunction = filtersFunction;
  }
  get filtersFunction() {
    const result = super.filtersFunction;
    if (result && result !== FunctionHelper.returnTrue) {
      return (r) => r.isCreating || result(r);
    }
    return result;
  }
  getEventCounts(options) {
    const me = this, {
      filtersFunction,
      added
    } = me, result = me.getEvents(_objectSpread2(_objectSpread2({}, options), {}, {
      storeFilterFn: me.isFiltered ? me.reapplyFilterOnAdd ? filtersFunction : (eventRecord) => added.includes(eventRecord) ? me.indexOf(eventRecord) > -1 : filtersFunction(eventRecord) : null,
      dateMap: options.dateMap || true
    }));
    result.forEach((value, key) => result.set(key, value.length));
    return result;
  }
  forEachScheduledEvent(fn2, thisObj = this) {
    this.forEach((event) => {
      const {
        startDate,
        endDate
      } = event;
      if (startDate && endDate) {
        return fn2.call(thisObj, event, startDate, endDate);
      }
    });
  }
  getTotalTimeSpan() {
    let earliest = new Date(9999, 0, 1), latest = new Date(0);
    this.forEach((event) => {
      if (event.startDate) {
        earliest = DateHelper.min(event.startDate, earliest);
      }
      if (event.endDate) {
        latest = DateHelper.max(event.endDate, latest);
      }
    });
    earliest = earliest < new Date(9999, 0, 1) ? earliest : null;
    latest = latest > new Date(0) ? latest : null;
    return this.lastTotalTimeSpan = {
      startDate: earliest || null,
      endDate: latest || earliest || null
    };
  }
  isEventPersistable(event) {
    return event.isPersistable;
  }
  isDateRangeAvailable(start, end, excludeEvent, resource) {
    if (resource.data.generatedParent) {
      return false;
    }
    const allEvents = new Set(this.getEventsForResource(resource));
    if (excludeEvent !== null && excludeEvent !== void 0 && excludeEvent.isAssignment) {
      const currentEvent = excludeEvent.event, resources = currentEvent.resources;
      resources.forEach((resource2) => {
        if (resource2.id !== excludeEvent.resourceId) {
          this.getEventsForResource(resource2).forEach((event) => allEvents.add(event));
        }
      });
    }
    if (excludeEvent) {
      const eventToRemove = excludeEvent.isAssignment ? excludeEvent.event : excludeEvent;
      allEvents.delete(eventToRemove);
    }
    return !Array.from(allEvents).some((event) => event.isScheduled && DateHelper.intersectSpans(start, end, event.startDate, event.endDate));
  }
  filterEventsForResource(resource, fn2, thisObj = this) {
    return resource.getEvents(this).filter(fn2.bind(thisObj));
  }
  getResourcesForEvent(event) {
    if (event.isOccurrence) {
      event = event.recurringTimeSpan;
    }
    return this.assignmentStore.getResourcesForEvent(event);
  }
  getEventsForResource(resource) {
    return this.assignmentStore.getEventsForResource(resource);
  }
  getAssignmentsForEvent(event) {
    return this.assignmentStore.getAssignmentsForEvent(event) || [];
  }
  getAssignmentsForResource(resource) {
    return this.assignmentStore.getAssignmentsForResource(resource) || [];
  }
  assignEventToResource(event, resource, removeExistingAssignments = false) {
    return this.assignmentStore.assignEventToResource(event, resource, void 0, removeExistingAssignments);
  }
  unassignEventFromResource(event, resource) {
    this.assignmentStore.unassignEventFromResource(event, resource);
  }
  reassignEventFromResourceToResource(event, oldResource, newResource) {
    const me = this, newResourceId = Model.asId(newResource), assignment = me.assignmentStore.getAssignmentForEventAndResource(event, oldResource);
    if (assignment) {
      assignment.resourceId = newResourceId;
    } else {
      me.assignmentStore.assignEventToResource(event, newResource);
    }
  }
  isEventAssignedToResource(event, resource) {
    return this.assignmentStore.isEventAssignedToResource(event, resource);
  }
  removeAssignmentsForEvent(event) {
    this.assignmentStore.removeAssignmentsForEvent(event);
  }
  removeAssignmentsForResource(resource) {
    this.assignmentStore.removeAssignmentsForResource(resource);
  }
};
var returnTrue = () => true;
var notRecurring = (event) => !event.isRecurring;
var GetEventsMixin = (Target) => {
  var _class;
  return _class = class GetEventsMixin extends Target {
    getEvents({
      filter: filter2,
      date: date2,
      startDate,
      endDate,
      startOnly,
      includeOccurrences,
      allowPartial,
      onlyAssigned = false,
      dateMap = false,
      dayTime = null,
      getDateIndex
    }) {
      const me = this, options = arguments[0], {
        lastDateRange,
        added,
        filtersFunction
      } = me, passedFilter = filter2;
      if (onlyAssigned) {
        options.filter = passedFilter ? (e) => passedFilter(e) && e.resources.length : (e) => e.resources.length;
      }
      if (!("startDate" in options)) {
        startDate = options.startDate = date2;
      }
      if (!("includeOccurrences" in options)) {
        includeOccurrences = options.includeOccurrences = true;
      }
      if (!("allowPartial" in options)) {
        allowPartial = options.allowPartial = !startOnly;
      }
      options.storeFilterFn = me.isFiltered && !options.ignoreFilters ? me.reapplyFilterOnAdd ? filtersFunction : (eventRecord) => added.includes(eventRecord) ? me.indexOf(eventRecord) > -1 : filtersFunction(eventRecord) : null;
      if (!endDate) {
        if (startDate) {
          endDate = options.endDate = DateHelper.clearTime(startDate);
          endDate.setDate(endDate.getDate() + 1);
        } else {
          if (includeOccurrences) {
            throw new Error("getEvents MUST be passed startDate and endDate if recurring occurrences are requested");
          }
          options.dateFilter = returnTrue;
        }
      }
      if (!options.dateFilter) {
        if (startOnly) {
          options.dateFilter = (e) => {
            const eventStartDate = e.hasBatchedChange("startDate") ? e.get("startDate") : e.startDate;
            return eventStartDate && !(DateHelper.clearTime(eventStartDate) - startDate);
          };
        } else if (allowPartial) {
          options.dateFilter = (e) => {
            const eventStartDate = e.hasBatchedChange("startDate") ? e.get("startDate") : e.startDate, eventEndDate = e.hasBatchedChange("endDate") ? e.get("endDate") : e.endDate || eventStartDate, isMilestone = !(eventStartDate - eventEndDate);
            return eventStartDate && (isMilestone ? DateHelper.betweenLesserEqual(eventStartDate, startDate, endDate) : DateHelper.intersectSpans(eventStartDate, eventEndDate, startDate, endDate));
          };
        } else {
          options.dateFilter = (e) => {
            const eventStartDate = e.hasBatchedChange("startDate") ? e.get("startDate") : e.startDate, eventEndDate = e.hasBatchedChange("endDate") ? e.get("endDate") : e.endDate || eventStartDate;
            return eventStartDate && eventStartDate >= startDate && eventEndDate <= endDate;
          };
        }
      }
      const newDateRange = {
        startDate,
        endDate
      };
      me.processConfiguredListeners();
      me.trigger("loadDateRange", {
        old: lastDateRange || {},
        new: Objects.clone(newDateRange),
        changed: !lastDateRange || lastDateRange.startDate - newDateRange.startDate || lastDateRange.endDate - newDateRange.endDate
      });
      me.lastDateRange = Objects.clone(newDateRange);
      return dateMap ? me.getEventsAsMap(options) : me.getEventsAsArray(options);
    }
    getEventsAsArray({
      filter: filter2,
      date: date2,
      resourceRecord,
      startDate = date2,
      endDate,
      startOnly,
      includeOccurrences = true,
      dayTime = null,
      dateFilter,
      storeFilterFn,
      getDateIndex
    }) {
      const me = this, events = [], count = storeFilterFn ? me.count : me.allCount;
      if (count) {
        let candidateEvents = resourceRecord ? me.getEventsForResource(resourceRecord) : null;
        if (!resourceRecord) {
          const dateIndex = me.useDayIndex(dayTime), eventSet = /* @__PURE__ */ new Set(), indexName = startOnly ? "startDate" : "date";
          me.recurringEvents.forEach((e) => {
            if (dateIndex.dayTime.startOfDay(e.startDate) <= startDate) {
              eventSet.add(e);
            }
          });
          for (const date3 = new Date(startDate); date3 < endDate; date3.setDate(date3.getDate() + 1)) {
            const coincidingEvents = dateIndex.get(getDateIndex ? getDateIndex(date3) : indexName, date3);
            coincidingEvents === null || coincidingEvents === void 0 ? void 0 : coincidingEvents.forEach((e) => eventSet.add(e));
          }
          candidateEvents = [...eventSet];
        }
        if (storeFilterFn) {
          candidateEvents = candidateEvents.filter(storeFilterFn);
        }
        for (let i = 0, {
          length
        } = candidateEvents; i < length; i++) {
          const e = candidateEvents[i];
          if (includeOccurrences && e.isRecurring) {
            events.push.apply(events, e.getOccurrencesForDateRange(startDate, endDate).filter(dateFilter));
          } else if (dateFilter(e)) {
            events.push(e);
          }
        }
      }
      return filter2 ? events.filter(filter2) : events;
    }
    getEventsAsMap({
      filter: passedFilter,
      date: date2,
      resourceRecord,
      startDate = date2,
      endDate,
      startOnly,
      includeOccurrences = true,
      dateMap,
      dayTime = null,
      storeFilterFn,
      getDateIndex
    }) {
      var _dateMap;
      const me = this;
      if ((_dateMap = dateMap) !== null && _dateMap !== void 0 && _dateMap.clear) {
        dateMap.clear();
      } else {
        dateMap = /* @__PURE__ */ new Map();
      }
      if (me.count) {
        const dateIndex = me.useDayIndex(dayTime), indexName = startOnly ? "startDate" : "date", recurringEvents = [], filter2 = (e) => (!passedFilter || passedFilter(e)) && (!storeFilterFn || storeFilterFn(e)), baseEventFilter = (e) => notRecurring(e) && filter2(e);
        dayTime = dateIndex.dayTime;
        if (resourceRecord) {
          throw new Error("Querying for events for a resource and returning a date-keyed Map is not supported");
        } else {
          var _me$recurringEvents;
          (_me$recurringEvents = me.recurringEvents) === null || _me$recurringEvents === void 0 ? void 0 : _me$recurringEvents.forEach((e) => {
            if (dayTime.startOfDay(e.startDate) < endDate) {
              recurringEvents.push(e);
            }
          });
          for (const date3 = new Date(startDate); date3 < endDate; date3.setDate(date3.getDate() + 1)) {
            var _coincidingEvents;
            let [coincidingEvents, key] = dateIndex.get(getDateIndex ? getDateIndex(date3) : indexName, date3, true);
            if ((_coincidingEvents = coincidingEvents) !== null && _coincidingEvents !== void 0 && _coincidingEvents.size) {
              coincidingEvents = [...coincidingEvents].filter(baseEventFilter);
              if (coincidingEvents.length) {
                (dateMap.get(key) || dateMap.set(key, []).get(key)).push(...coincidingEvents);
              }
            }
          }
        }
        for (let i = 0, {
          length
        } = recurringEvents; i < length; i++) {
          const e = recurringEvents[i], occurrences = (includeOccurrences ? e.getOccurrencesForDateRange(startDate, endDate) : [e]).filter(filter2), lastDate = DateHelper.add(endDate, 1, "day");
          for (let bucket, i2 = 0, {
            length: length2
          } = occurrences; i2 < length2; i2++) {
            const occurrence = occurrences[i2], date3 = dayTime.startOfDay(occurrence.startDate), indexName2 = getDateIndex ? getDateIndex(date3) : startOnly ? "startDate" : "date", lastInteresctingDate = indexName2 === "startDate" || occurrence.allDay ? DateHelper.add(date3, 1, "day") : DateHelper.min(occurrence.endDate || DateHelper.add(occurrence.startDate, occurrence.duration, occurrence.durationUnit), lastDate);
            for (; date3 < lastInteresctingDate; date3.setDate(date3.getDate() + 1)) {
              const key = dayTime.dateKey(date3);
              (bucket = dateMap.get(key)) || dateMap.set(key, bucket = []);
              bucket.push(occurrence);
            }
          }
        }
      }
      return dateMap;
    }
  }, _defineProperty(_class, "$name", "GetEventsMixin"), _class;
};
var indexNameMap = {
  date: "_dateIndex",
  startDate: "_startDateIndex"
};
var indexProps = Object.values(indexNameMap);
var emptyArray$3 = Object.freeze([]);
var {
  MILLIS_PER_DAY
} = DayTime;
var EventDayIndex = class {
  constructor(store, dayTime) {
    this.dayTime = dayTime || DayTime.MIDNIGHT;
    this.store = store;
    this.users = [this.dayTime];
  }
  add(indexName, date2, eventRecord) {
    const index = this[indexNameMap[indexName]], key = this.dayTime.dateKey(date2), entry = index[key] || (index[key] = /* @__PURE__ */ new Set());
    entry.add(eventRecord);
  }
  addEvent(eventRecord) {
    var _this$dayTime$startOf;
    let dateMS = (_this$dayTime$startOf = this.dayTime.startOfDay(eventRecord.startDate)) === null || _this$dayTime$startOf === void 0 ? void 0 : _this$dayTime$startOf.getTime(), endDateMS;
    if (dateMS) {
      var _eventRecord$endDate$, _eventRecord$endDate;
      endDateMS = (_eventRecord$endDate$ = (_eventRecord$endDate = eventRecord.endDate) === null || _eventRecord$endDate === void 0 ? void 0 : _eventRecord$endDate.getTime()) !== null && _eventRecord$endDate$ !== void 0 ? _eventRecord$endDate$ : dateMS;
      this.add("startDate", dateMS, eventRecord);
      do {
        this.add("date", dateMS, eventRecord);
        dateMS += MILLIS_PER_DAY;
      } while (dateMS < endDateMS);
    }
  }
  clear() {
    indexProps.forEach((name) => this[name] = /* @__PURE__ */ Object.create(null));
  }
  get(indexName, date2, returnKey) {
    !this.initialized && this.initialize();
    let ret = this[indexNameMap[indexName]], key;
    if (date2) {
      key = this.dayTime.dateKey(date2);
      ret = returnKey ? [ret[key], key] : ret[key];
    }
    return ret;
  }
  initialize() {
    this.initialized = true;
    this.clear();
    this.sync("splice", this.store.storage.allValues);
  }
  invalidate() {
    this.initialized = false;
    indexProps.forEach((name) => this[name] = null);
  }
  matches(dayTime) {
    return this.dayTime.startShift === dayTime.startShift;
  }
  remove(indexName, date2, eventRecord) {
    const index = this[indexNameMap[indexName]], key = this.dayTime.dateKey(date2), entry = index[key];
    if (entry) {
      entry.delete(eventRecord);
    }
  }
  removeEvent(eventRecord, startDate, endDate) {
    var _this$dayTime$startOf2;
    let dateMS = (_this$dayTime$startOf2 = this.dayTime.startOfDay(startDate)) === null || _this$dayTime$startOf2 === void 0 ? void 0 : _this$dayTime$startOf2.getTime(), endDateMS;
    if (dateMS) {
      var _endDate$getTime;
      endDateMS = (_endDate$getTime = endDate === null || endDate === void 0 ? void 0 : endDate.getTime()) !== null && _endDate$getTime !== void 0 ? _endDate$getTime : dateMS;
      this.remove("startDate", dateMS, eventRecord);
      do {
        this.remove("date", dateMS, eventRecord);
        dateMS += MILLIS_PER_DAY;
      } while (dateMS < endDateMS);
    }
  }
  sync(action, added, removed, replaced, wasSet) {
    var _wasSet$startDate, _wasSet$endDate;
    added = added || emptyArray$3;
    removed = removed || emptyArray$3;
    const me = this, addedCount = added.length, removedCount = removed.length, replacedCount = replaced === null || replaced === void 0 ? void 0 : replaced.length;
    let i, newEvent, outgoingEvent;
    if (!me.initialized) {
      return;
    }
    switch (action) {
      case "clear":
        me.clear();
        break;
      case "splice":
        if (replacedCount) {
          added = added.slice();
          removed = removed.slice();
          for (i = 0; i < replacedCount; i++) {
            removed.push(replaced[i][0]);
            added.push(replaced[i][1]);
          }
        }
        if (removedCount) {
          for (i = 0; i < removedCount; i++) {
            outgoingEvent = removed[i];
            me.removeEvent(outgoingEvent, outgoingEvent.startDate, outgoingEvent.endDate);
          }
        }
        if (addedCount) {
          for (i = 0; i < addedCount; i++) {
            newEvent = added[i];
            if (newEvent.isScheduled && !newEvent.isParent) {
              me.addEvent(newEvent);
            }
          }
        }
        break;
      case "reschedule":
        outgoingEvent = added[0];
        me.removeEvent(outgoingEvent, ((_wasSet$startDate = wasSet.startDate) === null || _wasSet$startDate === void 0 ? void 0 : _wasSet$startDate.oldValue) || outgoingEvent.startDate, ((_wasSet$endDate = wasSet.endDate) === null || _wasSet$endDate === void 0 ? void 0 : _wasSet$endDate.oldValue) || outgoingEvent.endDate);
        me.sync("splice", added);
        break;
    }
  }
  register(dayTime) {
    this.users.push(dayTime);
  }
  unregister(dayTime) {
    const {
      users
    } = this, i = users.indexOf(dayTime);
    if (i > -1) {
      users.splice(i, 1);
    }
    return !users.length;
  }
};
var proto = EventDayIndex.prototype;
indexProps.forEach((name) => proto[name] = null);
proto.initialized = false;
EventDayIndex._$name = "EventDayIndex";
var {
  MIDNIGHT
} = DayTime;
var DayIndexMixin = (Target) => {
  var _class;
  return _class = class DayIndexMixin extends Target {
    construct(config) {
      super.construct(config);
      this.dayIndices = null;
    }
    afterLoadData() {
      var _super$afterLoadData;
      this.syncIndices("splice", this.storage.allValues);
      (_super$afterLoadData = super.afterLoadData) === null || _super$afterLoadData === void 0 ? void 0 : _super$afterLoadData.call(this);
    }
    onDataChange({
      action,
      added,
      removed,
      replaced
    }) {
      this.syncIndices(action, added, removed, replaced);
      super.onDataChange(...arguments);
    }
    onDataReplaced(action, data) {
      this.syncIndices("clear");
      this.syncIndices("splice", this.storage.values);
      super.onDataReplaced(action, data);
    }
    onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {
      if ("startDate" in wasSet || "endDate" in wasSet) {
        this.syncIndices("reschedule", [record], null, null, wasSet);
      }
      super.onModelChange(...arguments);
    }
    invalidateDayIndices() {
      var _this$dayIndices;
      (_this$dayIndices = this.dayIndices) === null || _this$dayIndices === void 0 ? void 0 : _this$dayIndices.forEach((dayIndex) => dayIndex.invalidate());
    }
    registerDayIndex(dayTime) {
      const me = this, dayIndices = me.dayIndices || (me.dayIndices = []);
      let dayIndex, i;
      for (i = 0; !dayIndex && i < dayIndices.length; ++i) {
        if (dayIndices[i].matches(dayTime)) {
          (dayIndex = dayIndices[i]).register(dayTime);
        }
      }
      !dayIndex && dayIndices.push(dayIndex = new EventDayIndex(me, dayTime));
      return dayIndex;
    }
    syncIndices(...args) {
      var _this$dayIndices2;
      (_this$dayIndices2 = this.dayIndices) === null || _this$dayIndices2 === void 0 ? void 0 : _this$dayIndices2.forEach((dayIndex) => dayIndex.sync(...args));
    }
    unregisterDayIndex(dayTime) {
      const me = this, {
        dayIndices
      } = me;
      for (let i = dayIndices === null || dayIndices === void 0 ? void 0 : dayIndices.length; i-- > 0; ) {
        if (dayIndices[i].matches(dayTime)) {
          if (dayIndices[i].unregister(dayTime)) {
            dayIndices.splice(i, 1);
          }
          break;
        }
      }
    }
    useDayIndex(dayTime) {
      const me = this, {
        dayIndices
      } = me;
      dayTime = dayTime || MIDNIGHT;
      for (let i = 0; dayIndices && i < dayIndices.length; ++i) {
        if (dayIndices[i].matches(dayTime)) {
          return dayIndices[i];
        }
      }
      if (dayTime.startShift) {
        throw new Error(`No day index registered for ${dayTime} on ${me.id}`);
      }
      return me.registerDayIndex(MIDNIGHT);
    }
  }, _defineProperty(_class, "$name", "DayIndexMixin"), _class;
};
var SharedEventStoreMixin = (Target) => class SharedEventStoreMixin extends Target {
  static get $name() {
    return "SharedEventStoreMixin";
  }
  static get defaultConfig() {
    return {
      loadPriority: 100,
      syncPriority: 200,
      storeId: "events",
      removeUnassignedEvent: true,
      singleAssignment: null
    };
  }
  construct(config) {
    super.construct(config, true);
    if (this.singleAssignment) {
      this.usesSingleAssignment = true;
    }
    if (!this.modelClass.isEventModel) {
      throw new Error("The model for the EventStore must subclass EventModel");
    }
  }
  append(record) {
    return this.add(record);
  }
  get project() {
    return super.project;
  }
  set project(project) {
    super.project = project;
    this.detachListeners("project");
    if (project) {
      var _project$assignmentSt;
      if ((_project$assignmentSt = project.assignmentStore) !== null && _project$assignmentSt !== void 0 && _project$assignmentSt.isAssignmentStore) {
        this.attachToAssignmentStore(project.assignmentStore);
      }
      project.ion({
        name: "project",
        assignmentStoreChange: "onProjectAssignmentStoreChange",
        thisObj: this,
        prio: 200
      });
    }
  }
  get usesSingleAssignment() {
    if (this.isChained) {
      return this.masterStore.usesSingleAssignment;
    }
    return this._usesSingleAssignment;
  }
  set usesSingleAssignment(value) {
    this._usesSingleAssignment = value;
  }
  processRecords(eventRecords) {
    var _this$stm;
    const {
      assignmentStore
    } = this, assignmentsToAdd = [];
    if (assignmentStore) {
      assignmentStore.skipInvalidateIndices = true;
    }
    eventRecords = super.processRecords(eventRecords, assignmentStore && !((_this$stm = this.stm) !== null && _this$stm !== void 0 && _this$stm.isRestoring) && ((eventRecord) => {
      const resourceId = eventRecord.get("resourceId");
      if (!eventRecord.reassignedFromReplace && resourceId != null) {
        if (!assignmentStore.includesAssignment(eventRecord.id, resourceId)) {
          assignmentsToAdd.push({
            id: assignmentStore.modelClass.generateId(""),
            resourceId,
            eventId: eventRecord.id
          });
        }
      }
      eventRecord.reassignedFromReplace = false;
    }) || void 0);
    if (assignmentStore) {
      assignmentStore.storage.invalidateIndices();
      assignmentStore.skipInvalidateIndices = false;
      assignmentStore.add(assignmentsToAdd);
    }
    return eventRecords;
  }
  joinRecordsToStore(records) {
    const {
      assignmentStore
    } = this;
    if (assignmentStore) {
      assignmentStore.skipInvalidateIndices = true;
      super.joinRecordsToStore(records);
      assignmentStore.storage.invalidateIndices();
      assignmentStore.skipInvalidateIndices = false;
    } else {
      super.joinRecordsToStore(records);
    }
  }
  processRecord(eventRecord, isDataset = false) {
    eventRecord = super.processRecord(eventRecord, isDataset);
    const resourceId = eventRecord.get("resourceId");
    if (resourceId != null && !eventRecord.meta.skipEnforcingSingleAssignment) {
      const me = this, {
        assignmentStore
      } = me, existingRecord = me.getById(eventRecord.id), isReplacing = existingRecord && existingRecord !== eventRecord && !isDataset;
      if (isReplacing) {
        const assignment = assignmentStore.find((e) => e.eventId === eventRecord.id);
        if (assignment) {
          assignment.resource = resourceId;
          eventRecord.reassignedFromReplace = true;
        }
      } else {
        me.$processResourceIds = true;
      }
      me.usesSingleAssignment = true;
    }
    return eventRecord;
  }
  processResourceIds() {
    const {
      assignmentStore
    } = this;
    if (this.$processResourceIds && assignmentStore !== null && assignmentStore !== void 0 && assignmentStore.isAssignmentStore && !this.project.isSharingAssignmentStore) {
      const assignments = [];
      this.forEach((eventRecord) => {
        const {
          resourceId,
          id: eventId
        } = eventRecord;
        if (resourceId != null) {
          assignments.push({
            id: assignmentStore.modelClass.generateId(""),
            resourceId,
            eventId
          });
        }
      });
      assignmentStore.useRawData = {
        disableDefaultValue: true,
        disableDuplicateIdCheck: true,
        disableTypeConversion: true
      };
      assignmentStore.usesSingleAssignment = false;
      assignmentStore.verifyNoGeneratedIds = false;
      assignmentStore.data = assignments;
      assignmentStore.usesSingleAssignment = true;
      this.$processResourceIds = false;
    }
  }
  loadData() {
    super.loadData(...arguments);
    this.processResourceIds();
  }
  onBeforeRemoveAssignment({
    records
  }) {
    var _me$stm;
    const me = this;
    if (me.removeUnassignedEvent && !me.isRemoving && !me.isSettingData && !((_me$stm = me.stm) !== null && _me$stm !== void 0 && _me$stm.isRestoring) && !me.usesSingleAssignment && !me.assignmentStore.isSyncingDataOnLoad && !me.resourceStore.isSyncingDataOnLoad) {
      const toRemove = /* @__PURE__ */ new Set();
      records.forEach((assignmentRecord) => {
        const {
          event
        } = assignmentRecord;
        if (event && !event.isRemoved && event.assignments.every((a) => records.includes(a))) {
          toRemove.add(event);
        }
      });
      if (toRemove.size) {
        me.remove([...toRemove]);
      }
    }
  }
  onProjectAssignmentStoreChange({
    store
  }) {
    this.attachToAssignmentStore(store);
  }
  attachToAssignmentStore(assignmentStore) {
    const me = this;
    me.detachListeners("assignmentStore");
    if (assignmentStore) {
      me.processResourceIds();
      assignmentStore.ion({
        name: "assignmentStore",
        addPreCommit({
          records
        }) {
          if (me.usesSingleAssignment && !me.isSettingData && !me.isAssigning) {
            records.forEach((assignment) => {
              const {
                event
              } = assignment;
              if (event !== null && event !== void 0 && event.isEvent && event.resourceId !== assignment.resourceId) {
                event.meta.isAssigning = true;
                event.set("resourceId", assignment.resourceId);
                event.meta.isAssigning = false;
              }
            });
          }
        },
        beforeRemove: "onBeforeRemoveAssignment",
        removePreCommit({
          records
        }) {
          if (me.usesSingleAssignment) {
            records.forEach((assignment) => {
              var _me$getById;
              (_me$getById = me.getById(assignment.eventId)) === null || _me$getById === void 0 ? void 0 : _me$getById.set("resourceId", null);
            });
          }
        },
        removeAllPreCommit() {
          if (me.usesSingleAssignment && !me.isSettingData) {
            me.allRecords.forEach((eventRecord) => eventRecord.set("resourceId", null));
          }
        },
        update({
          record,
          changes
        }) {
          if (me.usesSingleAssignment && "resourceId" in changes) {
            const {
              event
            } = record;
            event.meta.isAssigning = true;
            event.set("resourceId", changes.resourceId.value);
            event.meta.isAssigning = false;
          }
        },
        thisObj: me
      });
    }
  }
  set data(data) {
    this.isSettingData = true;
    if (this.usesSingleAssignment && !this.syncDataOnLoad && !this.isChained) {
      this.assignmentStore.removeAll(true);
    }
    super.data = data;
    this.isSettingData = false;
  }
  trigger(eventName, params) {
    const {
      changes
    } = params || {};
    if (changes && "resourceId" in changes && Object.keys(changes).length === 1) {
      params.isAssign = true;
    }
    return super.trigger(...arguments);
  }
};
var emptyArray$2 = Object.freeze([]);
var RecurringTimeSpansMixin = (Target) => class RecurringTimeSpansMixin extends (Target || Base$1) {
  static get $name() {
    return "RecurringTimeSpansMixin";
  }
  construct(...args) {
    const me = this;
    me.globalOccurrences = /* @__PURE__ */ new Map();
    me.recurringEvents = /* @__PURE__ */ new Set();
    super.construct(...args);
  }
  afterLoadData() {
    this.globalOccurrences.clear();
    this.refreshRecurringEventsCache("clear");
    this.refreshRecurringEventsCache("splice", this.storage.allValues);
    super.afterLoadData && super.afterLoadData();
  }
  onDataChange({
    action,
    added,
    removed,
    replaced
  }) {
    this.refreshRecurringEventsCache(action, added, removed, replaced);
    super.onDataChange(...arguments);
  }
  refreshRecurringEventsCache(action, added = emptyArray$2, removed = emptyArray$2, replaced) {
    const me = this, {
      recurringEvents
    } = me, replacedCount = replaced === null || replaced === void 0 ? void 0 : replaced.length;
    switch (action) {
      case "clear":
        recurringEvents.clear();
        break;
      case "splice": {
        if (replacedCount) {
          added = added.slice();
          removed = removed.slice();
          for (let i = 0; i < replacedCount; i++) {
            removed.push(replaced[i][0]);
            added.push(replaced[i][1]);
          }
        }
        const addedCount = added.length, removedCount = removed.length;
        if (removedCount && recurringEvents.size) {
          for (let i = 0; i < removedCount; i++) {
            recurringEvents.delete(removed[i]);
          }
        }
        if (addedCount) {
          for (let i = 0; i < addedCount; i++) {
            const newEvent = added[i];
            if (newEvent.isRecurring) {
              recurringEvents.add(newEvent);
            }
          }
        }
        break;
      }
    }
  }
  getById(id) {
    let result = super.getById(id);
    if (!result) {
      result = this.globalOccurrences.get(this.modelClass.asId(id));
    }
    return result;
  }
  onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {
    const isRecurrenceRelatedFieldChange = this.isRecurrenceRelatedFieldChange(record, wasSet);
    if (isRecurrenceRelatedFieldChange && !silent) {
      record.removeOccurrences();
    }
    super.onModelChange(...arguments);
    if (isRecurrenceRelatedFieldChange && !silent) {
      const event = {
        action: "batch",
        records: this.storage.values
      };
      this.trigger("refresh", event);
      this.trigger("change", event);
    }
  }
  isRecurrenceRelatedFieldChange(timeSpan, wasSet) {
    return timeSpan.isRecurring || "recurrenceRule" in wasSet;
  }
  getOccurrencesForTimeSpan(timeSpan, startDate, endDate) {
    const result = [];
    if (timeSpan.isRecurring) {
      timeSpan.recurrence.forEachOccurrence(startDate, endDate, (r) => result.push(r));
    }
    return result;
  }
  set data(data) {
    this.globalOccurrences.clear();
    super.data = data;
  }
  getRecurringTimeSpans() {
    return [...this.recurringEvents];
  }
};
var RecurringEventsMixin = (Target) => class RecurringEventsMixin extends RecurringTimeSpansMixin(Target || Base$1) {
  static get $name() {
    return "RecurringEventsMixin";
  }
  getRecurringEvents() {
    return this.getRecurringTimeSpans();
  }
  isEventPersistable(event) {
    return super.isEventPersistable(event) && (!event.supportsRecurring || !event.isOccurrence);
  }
};
var dateFieldsToConvert = {
  startDate: 1,
  endDate: 1,
  constraintDate: 1,
  deadlineDate: 1
};
var TimeZonedDatesMixin = (Target) => {
  var _class;
  return _class = class TimeZonedDatesMixin extends (Target || TimeSpan) {
    setLocalDate(field, date2) {
      this.set(field, this._inTimeZone ? TimeZoneHelper.toTimeZone(date2, this._inTimeZone) : date2, true);
      this.data[field] = this[field];
    }
    getLocalDate(field) {
      if (this._inTimeZone && this[field]) {
        return TimeZoneHelper.fromTimeZone(this[field], this._inTimeZone);
      }
      return this[field];
    }
    applyChangeset(rawChanges) {
      const {
        _inTimeZone
      } = this;
      if (_inTimeZone != null) {
        for (const field in dateFieldsToConvert) {
          if (rawChanges[field]) {
            this.setLocalDate(field, new Date(rawChanges[field]));
            delete rawChanges[field];
          }
        }
      }
      return super.applyChangeset(...arguments);
    }
    getFieldPersistentValue(field) {
      if (this._inTimeZone) {
        var _ref, _field$field;
        const fieldName = (_ref = (_field$field = field === null || field === void 0 ? void 0 : field.field) !== null && _field$field !== void 0 ? _field$field : field === null || field === void 0 ? void 0 : field.name) !== null && _ref !== void 0 ? _ref : field;
        if (dateFieldsToConvert[fieldName]) {
          return this.getLocalDate(fieldName);
        }
      }
      return super.getFieldPersistentValue(field);
    }
    convertToTimeZone(timeZone) {
      const me = this, metaModified = _objectSpread2({}, me.meta.modified), convertFields = _objectSpread2({}, dateFieldsToConvert);
      if (me.isTask && !me.manuallyScheduled) {
        delete convertFields.startDate;
        delete convertFields.endDate;
      }
      for (const field in convertFields) {
        if (me[field] != null) {
          convertFields[field] = me[field];
          if (me._inTimeZone) {
            convertFields[field] = me.getLocalDate(field);
            if (metaModified[field]) {
              metaModified[field] = TimeZoneHelper.fromTimeZone(metaModified[field], me._inTimeZone);
            }
          }
        } else {
          delete convertFields[field];
        }
      }
      me._inTimeZone = timeZone;
      for (const field in convertFields) {
        me.setLocalDate(field, convertFields[field], false);
        convertFields[field] = 1;
        if (me._inTimeZone && metaModified[field]) {
          metaModified[field] = TimeZoneHelper.toTimeZone(metaModified[field], me._inTimeZone);
        }
      }
      me.clearChanges(true, true, convertFields);
      if (!ObjectHelper.isEmpty(metaModified)) {
        me.meta.modified = metaModified;
        me.stores.forEach((store) => store.modified.add(me));
      }
    }
  }, _defineProperty(_class, "$name", "TimeZonedDatesMixin"), _class;
};
var TimeSpan = class extends Model.mixin(TimeZonedDatesMixin) {
  static get $name() {
    return "TimeSpan";
  }
  static get fields() {
    return [
      {
        name: "startDate",
        type: "date"
      },
      {
        name: "endDate",
        type: "date"
      },
      {
        name: "duration",
        type: "number",
        allowNull: true,
        internal: true
      },
      {
        type: "durationunit",
        name: "durationUnit",
        defaultValue: "d",
        internal: true
      },
      {
        name: "fullDuration",
        persist: false,
        column: {
          type: "duration"
        }
      },
      {
        name: "cls",
        defaultValue: "",
        internal: true
      },
      {
        name: "iconCls",
        internal: true
      },
      {
        name: "style",
        type: "object",
        internal: true
      },
      {
        name: "name",
        type: "string",
        defaultValue: ""
      }
    ];
  }
  afterConstruct() {
    super.afterConstruct();
    this.normalize();
  }
  get eventStore() {
    const me = this;
    if (me.isOccurrence) {
      return me.recurringTimeSpan.eventStore;
    }
    if (!me._eventStore) {
      var _me$stores;
      me._eventStore = (_me$stores = me.stores) === null || _me$stores === void 0 ? void 0 : _me$stores.find((s) => s.isEventStore);
    }
    return me._eventStore;
  }
  normalize() {
    const me = this, {
      startDate,
      endDate,
      duration,
      durationUnit
    } = me, hasDuration = duration != null;
    if (startDate && endDate && !hasDuration) {
      me.setData("duration", DateHelper.diff(startDate, endDate, durationUnit, true));
    } else if (startDate && !endDate && hasDuration) {
      me.setData("endDate", DateHelper.add(startDate, duration, durationUnit));
    } else if (!startDate && endDate && hasDuration) {
      me.setData("startDate", DateHelper.add(endDate, -duration, durationUnit));
    }
  }
  updateInternalCls(cls) {
    if (this._cls) {
      this._cls.value = cls;
    } else {
      this._cls = new DomClassList(cls);
    }
  }
  set internalCls(cls) {
    this.updateInternalCls(cls);
    this.set("cls", this._cls.value);
  }
  get internalCls() {
    const {
      cls
    } = this;
    if (cls !== null && cls !== void 0 && cls.isDomClassList) {
      return cls;
    }
    this.internalCls = cls;
    return this._cls;
  }
  get cls() {
    if (!this._cls) {
      this._cls = new DomClassList(super.get("cls"));
    }
    return this._cls;
  }
  set cls(cls) {
    this.internalCls = cls;
  }
  get startDate() {
    return this.get("startDate");
  }
  set startDate(date2) {
    this.setStartDate(date2);
  }
  get endDate() {
    return this.get("endDate");
  }
  set endDate(date2) {
    this.setEndDate(date2);
  }
  get endingDate() {
    const me = this, {
      endDate,
      startDate
    } = me;
    if (endDate) {
      return endDate;
    }
    return DateHelper.add(startDate, me.duration, me.durationUnit);
  }
  get duration() {
    return this.get("duration");
  }
  set duration(duration) {
    this.setDuration(duration, this.durationUnit);
  }
  get durationUnit() {
    return this.get("durationUnit");
  }
  setDuration(duration, durationUnit = this.durationUnit) {
    duration = parseFloat(duration);
    const toSet = {
      duration,
      durationUnit
    };
    if (this.startDate) {
      toSet.endDate = DateHelper.add(this.startDate, duration, durationUnit);
    } else if (this.endDate) {
      toSet.startDate = DateHelper.add(this.endDate, -duration, durationUnit);
    }
    this.set(toSet);
  }
  getDurationInUnit(unit, doNotRound) {
    if (this.starDate && this.endDate) {
      return DateHelper.getDurationInUnit(this.startDate, this.endDate, unit, doNotRound);
    } else {
      return DateHelper.as(unit, this.duration, this.durationUnit);
    }
  }
  get fullDuration() {
    return new Duration({
      unit: this.durationUnit,
      magnitude: this.duration
    });
  }
  set fullDuration(duration) {
    if (typeof duration === "string") {
      duration = DateHelper.parseDuration(duration, true, this.durationUnit);
    }
    this.setDuration(duration.magnitude, duration.unit);
  }
  setStartDate(date2, keepDuration = true) {
    const me = this, toSet = {
      startDate: date2
    };
    if (date2) {
      let calcEndDate;
      if (keepDuration) {
        calcEndDate = me.duration != null;
      } else {
        if (me.endDate) {
          toSet.duration = DateHelper.diff(date2, me.endDate, me.durationUnit, true);
          if (toSet.duration < 0)
            throw new Error("Negative duration");
        } else {
          calcEndDate = this.duration != null;
        }
      }
      if (calcEndDate) {
        toSet.endDate = DateHelper.add(date2, me.getDurationInUnit("h"), "h");
      }
    } else {
      toSet.duration = null;
    }
    me.set(toSet);
  }
  setEndDate(date2, keepDuration = false) {
    const me = this, toSet = {
      endDate: date2
    };
    if (date2) {
      let calcStartDate;
      if (keepDuration === true) {
        calcStartDate = me.duration != null;
      } else {
        if (me.startDate) {
          toSet.duration = DateHelper.diff(me.startDate, date2, me.durationUnit, true);
          if (toSet.duration < 0)
            throw new Error("Negative duration");
        } else {
          calcStartDate = this.duration != null;
        }
      }
      if (calcStartDate) {
        toSet.startDate = DateHelper.add(date2, -me.duration, me.durationUnit);
      }
    }
    me.set(toSet);
  }
  setStartEndDate(start, end, silent) {
    this.set({
      startDate: start,
      endDate: end
    }, null, silent);
  }
  get dates() {
    const dates = [], startDate = DateHelper.startOf(this.startDate, "day"), endDate = this.endDate;
    for (let date2 = startDate; date2 < endDate; date2 = DateHelper.add(date2, 1, "day")) {
      dates.push(date2);
    }
    return dates;
  }
  get startDateMS() {
    var _ref;
    return (_ref = this.batching && this.hasBatchedChange("startDate") ? this.get("startDate") : this.startDate) === null || _ref === void 0 ? void 0 : _ref.getTime();
  }
  get endDateMS() {
    var _ref2;
    return (_ref2 = this.batching && this.hasBatchedChange("endDate") ? this.get("endDate") : this.endDate) === null || _ref2 === void 0 ? void 0 : _ref2.getTime();
  }
  get durationMS() {
    const {
      endDateMS,
      startDateMS
    } = this;
    if (endDateMS && startDateMS) {
      return endDateMS - startDateMS;
    } else {
      return DateHelper.asMilliseconds(this.duration || 0, this.durationUnit);
    }
  }
  get isMilestone() {
    return this.duration === 0;
  }
  inSetNormalize(field) {
    if (typeof field !== "string") {
      let {
        startDate,
        endDate,
        duration,
        durationUnit = this.durationUnit
      } = field;
      if (typeof startDate === "string") {
        startDate = this.getFieldDefinition("startDate").convert(startDate);
      }
      if (typeof endDate === "string") {
        endDate = this.getFieldDefinition("endDate").convert(endDate);
      }
      if ("duration" in field) {
        if (startDate && !endDate) {
          endDate = DateHelper.add(startDate, duration, durationUnit, true, true);
        }
        if (!startDate && endDate) {
          startDate = DateHelper.add(endDate, -duration, durationUnit, true, true);
        }
      } else if (startDate && endDate) {
        duration = DateHelper.as(durationUnit, DateHelper.diff(startDate, endDate, "h", true), "h");
      }
      const fieldOrClone = Object.isFrozen(field) ? ObjectHelper.clone(field) : field;
      startDate && (fieldOrClone.startDate = startDate);
      endDate && (fieldOrClone.endDate = endDate);
      duration != null && (fieldOrClone.duration = duration);
      return fieldOrClone;
    }
  }
  inSet(field, value, silent, fromRelationUpdate, skipAccessors, validOnly) {
    if (!skipAccessors) {
      field = this.inSetNormalize(field) || field;
    }
    return super.inSet(field, value, silent, fromRelationUpdate, skipAccessors, validOnly);
  }
  applyValue(useProp, key, value, skipAccessors, field) {
    if (key === "cls") {
      this.updateInternalCls(value);
    }
    if (key === "fullDuration") {
      this[key] = value;
    }
    super.applyValue(useProp, key, value, skipAccessors, field);
  }
  forEachDate(func, thisObj) {
    return this.dates.forEach(func.bind(thisObj));
  }
  get isScheduled() {
    const {
      startDateMS,
      endDateMS
    } = this;
    return endDateMS - startDateMS >= 0;
  }
  get isValid() {
    const {
      startDate,
      endDate
    } = this;
    return !startDate || !endDate || endDate - startDate >= 0;
  }
  shift(amount, unit = this.durationUnit) {
    if (typeof amount === "string") {
      const u = amount;
      amount = unit;
      unit = u;
    }
    return this.setStartDate(DateHelper.add(this.startDate, amount, unit, true), true);
  }
  get wbsCode() {
    return this._wbsCode || this.indexPath.join(".");
  }
  set wbsCode(value) {
    this._wbsCode = value;
  }
  fullCopy() {
    return this.copy.apply(this, arguments);
  }
  intersects(timeSpan) {
    return this.intersectsRange(timeSpan.startDate, timeSpan.endDate);
  }
  intersectsRange(start, end) {
    const myStart = this.startDate, myEnd = this.endDate;
    return myStart && myEnd && DateHelper.intersectSpans(myStart, myEnd, start, end);
  }
  split(splitPoint = 0.5) {
    const me = this, clone = me.copy(), {
      fullDuration,
      eventStore,
      assignmentStore
    } = me, oldDuration = new Duration(fullDuration), cloneDuration = new Duration(fullDuration);
    let ownNewDuration, unitsChanged;
    if (typeof splitPoint === "string") {
      ownNewDuration = new Duration(splitPoint);
      if (ownNewDuration.unit === oldDuration.unit) {
        cloneDuration.magnitude -= ownNewDuration.magnitude;
      } else {
        cloneDuration.magnitude = DateHelper.as(ownNewDuration.unit, oldDuration) - ownNewDuration.magnitude;
        cloneDuration.unit = ownNewDuration.unit;
        unitsChanged = true;
      }
    } else {
      ownNewDuration = new Duration(splitPoint > 1 ? splitPoint : me.duration * splitPoint, me.durationUnit);
      cloneDuration.magnitude -= ownNewDuration.magnitude;
    }
    clone.startDate = DateHelper.add(me.startDate, ownNewDuration.magnitude, ownNewDuration.unit);
    if (unitsChanged) {
      clone.fullDuration = cloneDuration;
      me.fullDuration = ownNewDuration;
    } else {
      clone.duration = cloneDuration.magnitude;
      me.duration = ownNewDuration.magnitude;
    }
    if (eventStore) {
      eventStore.add(clone);
      if (assignmentStore && !eventStore.usesSingleAssignment) {
        assignmentStore.add(me.assignments.map((assignment) => {
          const clonedData = Object.assign({}, assignment.data, {
            eventId: clone.id,
            event: null,
            resource: null
          });
          delete clonedData.id;
          return clonedData;
        }));
      }
    }
    return clone;
  }
  toICSString(icsEventConfig = {}) {
    if (!this.isScheduled) {
      return "";
    }
    const {
      startDate,
      endDate
    } = this, timestamp = icsEventConfig.DTSTAMP || DateHelper.format(new Date(), "uu");
    delete icsEventConfig.DTSTAMP;
    let startEnd = {};
    if (this.allDay) {
      startEnd = {
        "DTSTART;VALUE=DATE": DateHelper.format(startDate, "u"),
        "DTEND;VALUE=DATE": DateHelper.format(endDate, "u")
      };
    } else {
      startEnd = {
        DTSTART: DateHelper.format(startDate, "uu"),
        DTEND: DateHelper.format(endDate, "uu")
      };
    }
    const version = VersionHelper.scheduler && VersionHelper.getVersion("scheduler") || VersionHelper.calendar && VersionHelper.getVersion("calendar") || "", icsWrapConfig = {
      BEGIN: "VCALENDAR",
      VERSION: "2.0",
      CALSCALE: "GREGORIAN",
      PRODID: `-//Bryntum AB//Bryntum Scheduler ${version} //EN`,
      END: "VCALENDAR"
    }, eventConfig = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({
      BEGIN: "VEVENT",
      UID: this.id + "@bryntum.com",
      CLASS: "PUBLIC",
      SUMMARY: this.name,
      DTSTAMP: timestamp
    }, startEnd), this.recurrenceRule ? {
      RRULE: this.recurrenceRule
    } : {}), icsEventConfig), {}, {
      END: "VEVENT"
    }), icsItems = Object.keys(icsWrapConfig).map((key) => `${key}:${icsWrapConfig[key]}`), eventItems = Object.keys(eventConfig).map((key) => `${key}:${eventConfig[key]}`);
    icsItems.splice(icsItems.length - 1, 0, ...eventItems);
    return icsItems.join("\n");
  }
  exportToICS(icsEventConfig) {
    if (this.isScheduled) {
      const blob = new Blob([this.toICSString(icsEventConfig)], {
        type: "text/calendar"
      });
      BrowserHelper.downloadBlob(blob, (this.name || "Event") + ".ics");
    }
  }
  isEditable(fieldName) {
    return this.getFieldDefinition(fieldName) ? true : void 0;
  }
  isFieldModified(fieldName) {
    if (fieldName === "fullDuration") {
      return super.isFieldModified("duration") || super.isFieldModified("durationUnit");
    }
    return super.isFieldModified(fieldName);
  }
};
TimeSpan._$name = "TimeSpan";
var dayParseRegExp = /^([+-]?[0-9])?(SU|MO|TU|WE|TH|FR|SA)$/;
var days = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
var RecurrenceDayRuleEncoder = class extends Base$1 {
  static decodeDay(rawDay) {
    let parsedDay, result;
    if (parsedDay = dayParseRegExp.exec(rawDay)) {
      result = [days.indexOf(parsedDay[2])];
      if (parsedDay[1]) {
        parsedDay[1] = parseInt(parsedDay[1], 10);
        result.push(parsedDay[1]);
      }
    }
    return result;
  }
  static encodeDay(day2) {
    let position;
    if (Array.isArray(day2)) {
      [day2, position] = day2;
    }
    return (position ? position.toString() : "") + days[day2];
  }
  static decode(rawDays) {
    const result = [];
    let parsedDay;
    if (rawDays) {
      for (let i = 0; i < rawDays.length; i++) {
        if (parsedDay = this.decodeDay(rawDays[i])) {
          result.push(parsedDay);
        }
      }
    }
    return result;
  }
  static encode(days2) {
    const result = [];
    let day2;
    if (days2) {
      for (let i = 0; i < days2.length; i++) {
        if (day2 = this.encodeDay(days2[i])) {
          result.push(day2);
        }
      }
    }
    return result;
  }
};
RecurrenceDayRuleEncoder._$name = "RecurrenceDayRuleEncoder";
var frequencyToUnitRe = /ly$/i;
var frequencyToUnit = (frequency) => {
  const result = frequency.replace(frequencyToUnitRe, "");
  return result === "DAI" ? "DAY" : result;
};
var fn = (date2, counter, isFirst, timeSpan) => timeSpan.buildOccurrence(date2, isFirst);
var captureLastOccurrence = (date2) => lastOccurrenceDate = date2;
var lastOccurrenceDate;
var AbstractRecurrenceIterator = class extends Base$1 {
  static processIterationConfig(config) {
    var _endDate;
    const {
      recurrence
    } = config, {
      frequency,
      interval,
      timeSpan,
      endDate: until,
      count
    } = recurrence;
    if (!config.syncingStartDate && !timeSpan.meta.isSyncedWithRule) {
      const intervalEndDate = DateHelper.add(timeSpan.startDate, interval, frequencyToUnit(frequency)), endDate2 = DateHelper.min(intervalEndDate, config.endDate || intervalEndDate);
      this.forEachDate({
        syncingStartDate: true,
        startDate: timeSpan.startDate,
        endDate: endDate2,
        recurrence,
        fn
      });
    }
    const timeSpanStart = timeSpan.startDate;
    let {
      startDate = timeSpanStart,
      endDate = until
    } = config;
    if (startDate < timeSpanStart) {
      startDate = timeSpanStart;
    }
    if (until) {
      if (!endDate || endDate > until) {
        endDate = until;
      }
    } else if (count && startDate > timeSpanStart) {
      this.forEachDate({
        recurrence,
        fn: captureLastOccurrence
      });
      if (!endDate || endDate > lastOccurrenceDate) {
        endDate = new Date(lastOccurrenceDate.getTime() + 1);
      }
    }
    const earliestVisibleDate = startDate;
    if (!config.startOnly) {
      startDate = new Date(DateHelper.max(DateHelper.add(startDate, -interval, frequencyToUnit(frequency)), timeSpanStart));
    }
    return Object.assign({
      extraArgs: [],
      startOnly: !Boolean(timeSpan.durationMS)
    }, config, {
      startDate,
      endDate,
      timeSpan,
      timeSpanStart,
      earliestVisibleDate,
      endDateMS: (_endDate = endDate) === null || _endDate === void 0 ? void 0 : _endDate.getTime(),
      timeSpanStartMS: timeSpanStart.getTime(),
      earliestVisibleDateMS: earliestVisibleDate.getTime(),
      durationMS: timeSpan.durationMS,
      spansStart: startDate <= timeSpanStart && endDate > timeSpanStart
    });
  }
  static getOccurrenceIndex(event) {
    if (event.isOccurrence) {
      return DateHelper.diff(event.recurringTimeSpan.startDate, event.startDate, frequencyToUnit(event.recurringTimeSpan.recurrence.frequency));
    }
  }
  static getNthDayInPeriod(startDate, endDate, day2, index) {
    let result, sign, borderDate;
    if (index) {
      if (index > 0) {
        sign = 1;
        borderDate = startDate;
      } else {
        sign = -1;
        borderDate = endDate;
      }
      const delta = day2 - borderDate.getDay();
      if (sign * delta < 0) {
        index += sign;
      }
      result = new Date(borderDate);
      result.setDate(borderDate.getDate() + (index - sign) * 7 + delta);
      if (result < startDate || result > endDate) {
        result = null;
      }
    }
    return result;
  }
  static buildDate(year, month2, date2) {
    const dt = new Date(year, month2, date2);
    if (dt.getFullYear() === year && dt.getMonth() === month2 && dt.getDate() === date2) {
      return dt;
    }
  }
  static isValidPosition(position) {
    return Boolean(position);
  }
  static forEachDateAtPositions(dates, positions, fn2, scope) {
    const datesLength = dates.length, processed = {};
    for (let i = 0; i < positions.length; i++) {
      const index = positions[i];
      if (this.isValidPosition(index)) {
        const date2 = index > 0 ? dates[index - 1] : dates[datesLength + index];
        if (date2 && !processed[date2.getTime()]) {
          processed[date2.getTime()] = true;
          if (fn2.call(scope, date2) === false) {
            return false;
          }
        }
      }
    }
  }
  static isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan) {
    return (startOnly ? occurrenceDate >= earliestVisibleDate : occurrenceDate.valueOf() + durationMS > earliestVisibleDate) && !timeSpan.hasException(occurrenceDate);
  }
  static isInViewMS(startOnly, occurenceDate, occurrenceDateMS, earliestVisibleDateMS, durationMS, timeSpan) {
    return (startOnly ? occurrenceDateMS >= earliestVisibleDateMS : occurrenceDateMS + durationMS > earliestVisibleDateMS) && !timeSpan.hasException(occurenceDate);
  }
};
_defineProperty(AbstractRecurrenceIterator, "frequency", "NONE");
_defineProperty(AbstractRecurrenceIterator, "MAX_OCCURRENCES_COUNT", 1e6);
AbstractRecurrenceIterator._$name = "AbstractRecurrenceIterator";
var DailyRecurrenceIterator = class extends AbstractRecurrenceIterator {
  static forEachDate(config) {
    const {
      startOnly,
      startDate,
      endDate,
      endDateMS,
      timeSpan,
      timeSpanStart,
      earliestVisibleDateMS,
      durationMS,
      spansStart,
      recurrence,
      fn: fn2,
      extraArgs,
      scope = this
    } = this.processIterationConfig(config), {
      interval
    } = recurrence, delay2 = startDate - timeSpanStart, intervalDuration = interval * 864e5, delayInIntervals = Math.floor(delay2 / intervalDuration);
    let {
      count
    } = recurrence, counter = 0, occurrenceDate = DateHelper.add(timeSpanStart, delayInIntervals * interval, "day"), occurrenceDateMS = occurrenceDate.getTime();
    if (!endDate && !count) {
      count = this.MAX_OCCURRENCES_COUNT;
    }
    while (!endDateMS || occurrenceDateMS < endDateMS) {
      const inView = this.isInViewMS(startOnly, occurrenceDate, occurrenceDateMS, earliestVisibleDateMS, durationMS, timeSpan);
      counter++;
      if (inView && (endDateMS && occurrenceDateMS > endDateMS || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
        break;
      }
      occurrenceDate = DateHelper.add(occurrenceDate, interval, "day");
      occurrenceDateMS = occurrenceDate.getTime();
    }
  }
};
_defineProperty(DailyRecurrenceIterator, "frequency", "DAILY");
DailyRecurrenceIterator._$name = "DailyRecurrenceIterator";
var WeeklyRecurrenceIterator = class extends AbstractRecurrenceIterator {
  static forEachDate(config) {
    var _weekDays;
    const {
      startOnly,
      startDate,
      endDateMS,
      timeSpan,
      timeSpanStart,
      timeSpanStartMS,
      earliestVisibleDateMS,
      durationMS,
      spansStart,
      recurrence,
      fn: fn2,
      extraArgs,
      scope = this
    } = this.processIterationConfig(config), {
      interval,
      days: days2
    } = recurrence, {
      weekStartDay
    } = DateHelper, startHours = timeSpanStart.getHours(), startMinutes = timeSpanStart.getMinutes(), startSeconds = timeSpanStart.getSeconds(), startMS = timeSpanStart.getMilliseconds();
    let counter = 0, {
      count
    } = recurrence, weekDays = RecurrenceDayRuleEncoder.decode(days2), weekStartDate, occurrenceDate;
    if (!((_weekDays = weekDays) !== null && _weekDays !== void 0 && _weekDays.length)) {
      weekDays = [[timeSpanStart.getDay()]];
    }
    if (weekStartDay > 0) {
      for (let i = 0; i < weekDays.length; i++) {
        if (weekStartDay > weekDays[i][0]) {
          weekDays[i][0] = 7 - weekStartDay - weekDays[i][0];
        } else {
          weekDays[i][0] -= weekStartDay;
        }
      }
    }
    weekDays.sort((a, b) => a[0] - b[0]);
    weekStartDate = DateHelper.getNext(count || interval > 1 ? timeSpanStart : startDate, "week", 0);
    if (!endDateMS && !count) {
      count = this.MAX_OCCURRENCES_COUNT;
    }
    while (!endDateMS || weekStartDate.getTime() < endDateMS) {
      for (let i = 0; i < weekDays.length; i++) {
        occurrenceDate = new Date(weekStartDate.getFullYear(), weekStartDate.getMonth(), weekStartDate.getDate() + weekDays[i][0], startHours, startMinutes, startSeconds, startMS);
        const occurrenceDateMS = occurrenceDate.getTime();
        if (occurrenceDateMS >= timeSpanStartMS) {
          const inView = this.isInViewMS(startOnly, occurrenceDate, occurrenceDateMS, earliestVisibleDateMS, durationMS, timeSpan);
          counter++;
          if (inView && (endDateMS && occurrenceDateMS >= endDateMS || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
            return;
          }
        }
      }
      weekStartDate = DateHelper.getNext(weekStartDate, "week", interval);
    }
  }
};
_defineProperty(WeeklyRecurrenceIterator, "frequency", "WEEKLY");
WeeklyRecurrenceIterator._$name = "WeeklyRecurrenceIterator";
var MonthlyRecurrenceIterator = class extends AbstractRecurrenceIterator {
  static getNthDayOfMonth(date2, dayNum) {
    const daysInMonth = DateHelper.daysInMonth(date2);
    let result = null;
    if (dayNum && Math.abs(dayNum) <= daysInMonth) {
      result = new Date(date2.getFullYear(), date2.getMonth(), dayNum < 0 ? daysInMonth + dayNum + 1 : dayNum);
    }
    return result;
  }
  static isValidPosition(position) {
    return position && Math.abs(position) > 0 && Math.abs(position) <= 31;
  }
  static forEachDate(config) {
    const {
      startOnly,
      startDate,
      endDate,
      timeSpan,
      timeSpanStart,
      earliestVisibleDate,
      durationMS,
      spansStart,
      recurrence,
      fn: fn2,
      extraArgs,
      scope = this
    } = this.processIterationConfig(config), {
      interval,
      days: days2,
      count,
      positions
    } = recurrence, weekDays = RecurrenceDayRuleEncoder.decode(days2), hasPositions = positions && positions.length, processedDate = {};
    let {
      monthDays
    } = recurrence, counter = 0, weekDayPosition, monthStartDate, monthEndDate, dates, occurrenceDate, i;
    monthStartDate = DateHelper.startOf(count || interval > 1 ? timeSpanStart : startDate, "month");
    monthEndDate = new Date(DateHelper.getNext(monthStartDate, "month", 1) - 1);
    if (!(monthDays && monthDays.length) && !(weekDays && weekDays.length)) {
      monthDays = [timeSpanStart.getDate()];
    }
    if (weekDays && weekDays.length) {
      weekDays.forEach((day2) => {
        if (day2[1]) {
          weekDayPosition = weekDayPosition || {};
          weekDayPosition[day2[0]] = day2[1];
        }
      });
    }
    while ((!endDate || endDate > monthStartDate) && (!count || counter < count)) {
      dates = [];
      if (weekDays && weekDays.length) {
        weekDays.forEach((day2) => {
          const weekDay = day2[0];
          let from = 1, till = 53;
          if (day2[1]) {
            from = till = day2[1];
          }
          for (i = from; i <= till; i++) {
            if (occurrenceDate = this.getNthDayInPeriod(monthStartDate, monthEndDate, weekDay, i)) {
              occurrenceDate = DateHelper.copyTimeValues(occurrenceDate, timeSpanStart);
              if (!processedDate[occurrenceDate.getTime()]) {
                processedDate[occurrenceDate.getTime()] = true;
                dates.push(occurrenceDate);
              }
            }
          }
        });
        dates.sort((a, b) => a - b);
        if (!hasPositions) {
          for (i = 0; i < dates.length; i++) {
            occurrenceDate = dates[i];
            if (occurrenceDate >= timeSpanStart) {
              const inView = this.isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan);
              counter++;
              if (inView && (endDate && occurrenceDate >= endDate || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
                return false;
              }
            }
          }
        }
      } else {
        const sortedMonthDates = [];
        for (i = 0; i < monthDays.length; i++) {
          if ((occurrenceDate = this.getNthDayOfMonth(monthStartDate, monthDays[i])) && !processedDate[occurrenceDate.getTime()]) {
            processedDate[occurrenceDate.getTime()] = true;
            sortedMonthDates.push(occurrenceDate);
          }
        }
        sortedMonthDates.sort((a, b) => a - b);
        for (i = 0; i < sortedMonthDates.length; i++) {
          occurrenceDate = DateHelper.copyTimeValues(sortedMonthDates[i], timeSpanStart);
          if (hasPositions) {
            dates.push(occurrenceDate);
          } else if (occurrenceDate >= timeSpanStart) {
            const inView = this.isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan);
            counter++;
            if (inView && (endDate && occurrenceDate > endDate || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
              return;
            }
          }
        }
      }
      if (hasPositions && dates.length) {
        this.forEachDateAtPositions(dates, positions, (occurrenceDate2) => {
          if (occurrenceDate2 >= timeSpanStart) {
            const inView = startOnly ? occurrenceDate2 >= earliestVisibleDate : occurrenceDate2.valueOf() + durationMS > earliestVisibleDate && !timeSpan.hasException(occurrenceDate2);
            counter++;
            if (inView && (!endDate || occurrenceDate2 <= endDate) && (fn2.apply(scope, [occurrenceDate2, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
              return false;
            }
          }
        });
      }
      monthStartDate = DateHelper.getNext(monthStartDate, "month", interval);
      monthEndDate = new Date(DateHelper.getNext(monthStartDate, "month", 1) - 1);
    }
  }
};
_defineProperty(MonthlyRecurrenceIterator, "frequency", "MONTHLY");
MonthlyRecurrenceIterator._$name = "MonthlyRecurrenceIterator";
var YearlyRecurrenceIterator = class extends AbstractRecurrenceIterator {
  static forEachDate(config) {
    const {
      startOnly,
      startDate,
      endDate,
      timeSpan,
      timeSpanStart,
      earliestVisibleDate,
      durationMS,
      spansStart,
      recurrence,
      fn: fn2,
      extraArgs,
      scope = this
    } = this.processIterationConfig(config), {
      interval,
      days: days2,
      count,
      positions
    } = recurrence, weekDays = RecurrenceDayRuleEncoder.decode(days2), hasPositions = positions && positions.length, processedDate = {};
    let {
      months
    } = recurrence, counter = 0, i, occurrenceDate, dates, yearStartDate, yearEndDate, weekDayPosition;
    yearStartDate = DateHelper.startOf(count || interval > 1 ? timeSpanStart : startDate, "year");
    yearEndDate = new Date(DateHelper.getNext(yearStartDate, "year", 1) - 1);
    months && months.sort((a, b) => a - b);
    if (!(months && months.length) && !(weekDays && weekDays.length)) {
      months = [timeSpanStart.getMonth() + 1];
    }
    if (weekDays && weekDays.length) {
      weekDays.forEach((day2) => {
        if (day2[1]) {
          weekDayPosition = weekDayPosition || {};
          weekDayPosition[day2[0]] = day2[1];
        }
      });
    }
    while ((!endDate || endDate > yearStartDate) && (!count || counter < count)) {
      dates = [];
      if (weekDays && weekDays.length) {
        weekDays.forEach((day2) => {
          const weekDay = day2[0];
          let from = 1, till = 53;
          if (day2[1]) {
            from = till = day2[1];
          }
          for (i = from; i <= till; i++) {
            if (occurrenceDate = this.getNthDayInPeriod(yearStartDate, yearEndDate, weekDay, i)) {
              occurrenceDate = DateHelper.copyTimeValues(occurrenceDate, timeSpanStart);
              if (!processedDate[occurrenceDate.getTime()]) {
                processedDate[occurrenceDate.getTime()] = true;
                dates.push(occurrenceDate);
              }
            }
          }
        });
        dates.sort((a, b) => a - b);
        if (!hasPositions) {
          for (i = 0; i < dates.length; i++) {
            occurrenceDate = dates[i];
            if (occurrenceDate >= timeSpanStart) {
              const inView = this.isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan);
              counter++;
              if (inView && (endDate && occurrenceDate >= endDate || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
                return;
              }
            }
          }
        }
      } else {
        for (i = 0; i < months.length; i++) {
          if (occurrenceDate = this.buildDate(yearStartDate.getFullYear(), months[i] - 1, timeSpanStart.getDate())) {
            occurrenceDate = DateHelper.copyTimeValues(occurrenceDate, timeSpanStart);
            if (!processedDate[occurrenceDate.getTime()]) {
              processedDate[occurrenceDate.getTime()] = true;
              if (hasPositions) {
                dates.push(occurrenceDate);
              } else if (occurrenceDate >= timeSpanStart) {
                const inView = startOnly ? occurrenceDate >= earliestVisibleDate : occurrenceDate.valueOf() + durationMS > earliestVisibleDate && !timeSpan.hasException(occurrenceDate);
                counter++;
                if (inView && (endDate && occurrenceDate >= endDate || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
                  return;
                }
              }
            }
          }
        }
      }
      if (hasPositions && dates.length) {
        this.forEachDateAtPositions(dates, positions, (occurrenceDate2) => {
          if (occurrenceDate2 >= timeSpanStart) {
            const inView = startOnly ? occurrenceDate2 >= earliestVisibleDate : occurrenceDate2.valueOf() + durationMS > earliestVisibleDate && !timeSpan.hasException(occurrenceDate2);
            counter++;
            if (inView && (!endDate || occurrenceDate2 < endDate)) {
              if (fn2.apply(scope, [occurrenceDate2, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count) {
                return false;
              }
            }
          }
        });
      }
      yearStartDate = DateHelper.getNext(yearStartDate, "year", interval);
      yearEndDate = new Date(DateHelper.getNext(yearStartDate, "year", 1) - 1);
    }
  }
};
_defineProperty(YearlyRecurrenceIterator, "frequency", "YEARLY");
YearlyRecurrenceIterator._$name = "YearlyRecurrenceIterator";
var recurrenceIterators = {};
[DailyRecurrenceIterator, WeeklyRecurrenceIterator, MonthlyRecurrenceIterator, YearlyRecurrenceIterator].forEach((it) => {
  recurrenceIterators[it.frequency] = it;
});
function convertStringOfIntegerItemsValue(value) {
  if (value) {
    if (typeof value == "string") {
      value = value.split(",").map((item) => parseInt(item, 10));
    }
  } else {
    value = null;
  }
  return value;
}
function convertStringOfItemsValue(value) {
  if (value) {
    if (typeof value == "string") {
      value = value.split(",");
    }
  } else {
    value = null;
  }
  return value;
}
function isEqualAsString(value1, value2) {
  return String(value1) === String(value2);
}
function convertInteger(value) {
  if (this.defaultValue && value === void 0) {
    return this.defaultValue;
  }
  if (this.allowNull && value == null) {
    return null;
  }
  value = parseInt(value);
  return isNaN(value) ? void 0 : value;
}
var RecurrenceModel = class extends Model {
  static get $name() {
    return "RecurrenceModel";
  }
  get isRecurrenceModel() {
    return true;
  }
  static get fields() {
    return [
      {
        name: "frequency",
        defaultValue: "DAILY"
      },
      {
        name: "interval",
        defaultValue: 1,
        convert: convertInteger
      },
      {
        name: "endDate",
        type: "date"
      },
      {
        name: "count",
        allowNull: true,
        convert: convertInteger
      },
      {
        name: "days",
        convert: convertStringOfItemsValue,
        isEqual: isEqualAsString
      },
      {
        name: "monthDays",
        convert: convertStringOfIntegerItemsValue,
        isEqual: isEqualAsString
      },
      {
        name: "months",
        convert: convertStringOfIntegerItemsValue,
        isEqual: isEqualAsString
      },
      {
        name: "positions",
        convert: convertStringOfIntegerItemsValue,
        isEqual: isEqualAsString
      }
    ];
  }
  get dateFormat() {
    return this._dateFormat || "YYYYMMDDTHHmmss";
  }
  set dateFormat(format2) {
    this._dateFormat = format2;
  }
  get recurrenceIterator() {
    return recurrenceIterators[this.frequency];
  }
  get timeSpan() {
    return this._timeSpan;
  }
  set timeSpan(value) {
    this._timeSpan = value;
  }
  get rule() {
    const me = this, result = [];
    if (me.frequency) {
      result.push(`FREQ=${me.frequency}`);
      if (me.interval > 1) {
        result.push(`INTERVAL=${me.interval}`);
      }
      if (me.days && me.days.length) {
        result.push("BYDAY=" + me.days.join(","));
      }
      if (me.monthDays && me.monthDays.length) {
        result.push("BYMONTHDAY=" + me.monthDays.join(","));
      }
      if (me.months && me.months.length) {
        result.push("BYMONTH=" + me.months.join(","));
      }
      if (me.count) {
        result.push(`COUNT=${me.count}`);
      }
      if (me.endDate) {
        result.push("UNTIL=" + DateHelper.format(me.endDate, me.dateFormat));
      }
      if (me.positions && me.positions.length) {
        result.push("BYSETPOS=" + me.positions.join(","));
      }
    }
    return result.join(";");
  }
  set rule(rule) {
    const me = this, values = {
      frequency: null,
      interval: null,
      count: null,
      endDate: null,
      days: null,
      monthDays: null,
      months: null,
      positions: null
    };
    me.beginBatch();
    if (rule) {
      const parts = rule.split(";");
      for (let i = 0, len = parts.length; i < len; i++) {
        const part = parts[i].split("="), value = part[1];
        switch (part[0]) {
          case "FREQ":
            values.frequency = value;
            break;
          case "INTERVAL":
            values.interval = value;
            break;
          case "COUNT":
            values.count = value;
            values.until = null;
            break;
          case "UNTIL":
            if (value) {
              values.endDate = DateHelper.parse(value, me.dateFormat);
            } else {
              values.endDate = null;
            }
            values.count = null;
            break;
          case "BYDAY":
            values.days = value;
            break;
          case "BYMONTHDAY":
            values.monthDays = value;
            break;
          case "BYMONTH":
            values.months = value;
            break;
          case "BYSETPOS":
            values.positions = value;
            break;
        }
      }
    }
    me.set(values);
    if (rule) {
      me.sanitize();
    }
    me.endBatch();
  }
  construct(data = {}) {
    const me = this, {
      rule,
      timeSpan
    } = data;
    me._suspendedTimeSpanNotifying = 0;
    delete data.timeSpan;
    delete data.rule;
    super.construct(...arguments);
    if (rule) {
      me.suspendTimeSpanNotifying();
      me.rule = rule;
      me.resumeTimeSpanNotifying();
    }
    me.timeSpan = timeSpan;
  }
  forEachOccurrence(startDate, endDate, fn2) {
    if (this.timeSpan.startDate) {
      this.recurrenceIterator.forEachDate({
        recurrence: this,
        startDate,
        endDate,
        fn(date2, counter, first, timeSpan) {
          return fn2(timeSpan.buildOccurrence(date2, first), first, counter, date2);
        }
      });
    }
  }
  sanitize() {
    var _me$timeSpan;
    const me = this, timeSpanStartDate = (_me$timeSpan = me.timeSpan) === null || _me$timeSpan === void 0 ? void 0 : _me$timeSpan.startDate, values = {};
    me.isSanitizing = true;
    switch (me.frequency) {
      case "DAILY":
        values.positions = null;
        values.days = null;
        values.monthDays = null;
        values.months = null;
        break;
      case "WEEKLY": {
        values.positions = null;
        values.monthDays = null;
        values.months = null;
        const {
          days: days2
        } = me;
        if (timeSpanStartDate && (days2 === null || days2 === void 0 ? void 0 : days2.length) === 1 && days2[0] === RecurrenceDayRuleEncoder.encodeDay(timeSpanStartDate.getDay())) {
          values.days = null;
        }
        break;
      }
      case "MONTHLY": {
        var _me$monthDays;
        if ((_me$monthDays = me.monthDays) !== null && _me$monthDays !== void 0 && _me$monthDays.length) {
          values.positions = null;
          values.days = null;
        }
        values.months = null;
        const {
          monthDays
        } = me;
        if (timeSpanStartDate && (monthDays === null || monthDays === void 0 ? void 0 : monthDays.length) === 1 && monthDays[0] === timeSpanStartDate.getDate()) {
          values.monthDays = null;
        }
        break;
      }
      case "YEARLY": {
        values.monthDays = null;
        const {
          months
        } = me;
        if (timeSpanStartDate && (months === null || months === void 0 ? void 0 : months.length) === 1 && months[0] === timeSpanStartDate.getMonth() + 1) {
          values.months = null;
        }
        break;
      }
    }
    me.set(values);
    me.isSanitizing = false;
  }
  copy(...args) {
    const result = super.copy(...args);
    result.dateFormat = this.dateFormat;
    result.timeSpan = this.timeSpan;
    return result;
  }
  afterChange(toSet, wasSet, silent) {
    const result = super.afterChange(toSet, wasSet, silent), {
      timeSpan
    } = this;
    if (!this.isSanitizing) {
      this.sanitize();
    }
    if (timeSpan) {
      timeSpan.sanitizeRecurrenceData(this);
      if (!this.isTimeSpanNotifyingSuspended) {
        timeSpan.onRecurrenceChanged();
      }
    }
    return result;
  }
  set(field, value, ...args) {
    const values = typeof field === "object" ? field : {
      [field]: value
    };
    if (values.count) {
      values.endDate = null;
    } else if (values.endDate) {
      values.count = null;
    }
    super.set(values, void 0, ...args);
  }
  get isTimeSpanNotifyingSuspended() {
    return Boolean(this._suspendedTimeSpanNotifying);
  }
  suspendTimeSpanNotifying() {
    this._suspendedTimeSpanNotifying++;
  }
  resumeTimeSpanNotifying() {
    if (this._suspendedTimeSpanNotifying)
      this._suspendedTimeSpanNotifying--;
  }
};
RecurrenceModel._$name = "RecurrenceModel";
function convertExceptionDatesValue(value) {
  const result = {}, {
    dateFormat
  } = this;
  if (value) {
    value = typeof value == "string" ? value.split(",") : ArrayHelper.asArray(value);
    value.forEach((item) => {
      if (typeof item == "string") {
        item = DateHelper.parse(item, dateFormat);
      }
      if (!isNaN(item)) {
        result[DateHelper.makeKey(item)] = 1;
      }
    });
  }
  return result;
}
function serializeExceptionDatesValue(value) {
  const result = [], {
    dateFormat
  } = this;
  for (const date2 in value) {
    if (value[date2]) {
      result.push(DateHelper.format(DateHelper.parseKey(date2), dateFormat));
    }
  }
  return result;
}
var emptyArray$1 = [];
var RecurringTimeSpan = (Target) => class RecurringTimeSpan extends (Target || TimeSpan) {
  static get $name() {
    return "RecurringTimeSpan";
  }
  get supportsRecurring() {
    return true;
  }
  static get fields() {
    return [
      {
        name: "recurrenceRule",
        internal: true
      },
      {
        name: "exceptionDates",
        convert: convertExceptionDatesValue,
        serialize: serializeExceptionDatesValue,
        internal: true
      }
    ];
  }
  remove() {
    if (this.isOccurrence) {
      const me = this, {
        recurringTimeSpan
      } = me;
      me.cancelBatch();
      recurringTimeSpan.beginBatch();
      me.detachFromRecurringEvent();
      recurringTimeSpan.endBatch();
    } else {
      return super.remove(...arguments);
    }
  }
  get eventStore() {
    var _this$firstStore;
    let result = this.isOccurrence ? this.recurringEvent.eventStore : super.eventStore;
    if (!result && (_this$firstStore = this.firstStore) !== null && _this$firstStore !== void 0 && _this$firstStore.isRecurringTimeSpansMixin) {
      result = this.firstStore;
    }
    return result;
  }
  get recurrenceModel() {
    return this._recurrenceModel || RecurrenceModel;
  }
  set recurrenceModel(model) {
    this._recurrenceModel = model;
  }
  setRecurrence(recurrence, interval, recurrenceEnd) {
    const me = this;
    let recurrenceRule;
    if (recurrence) {
      if (!recurrence.isRecurrenceModel) {
        if (typeof recurrence === "string") {
          recurrence = {
            frequency: recurrence
          };
          if (interval) {
            recurrence.interval = interval;
          }
          if (recurrenceEnd) {
            if (recurrenceEnd instanceof Date) {
              recurrence.endDate = recurrenceEnd;
            } else {
              recurrence.count = recurrenceEnd;
            }
          }
        }
        recurrence = new me.recurrenceModel(recurrence);
      }
      recurrence.timeSpan = me;
      recurrenceRule = recurrence.rule;
    }
    me.recurrence = recurrence;
    me.recurrenceRule = recurrenceRule;
  }
  get recurrence() {
    const me = this, rule = me.recurrenceRule;
    if (!me._recurrence && rule) {
      me._recurrence = new me.recurrenceModel({
        rule,
        timeSpan: me,
        id: `${me.id}-recurrence`
      });
    }
    return me._recurrence;
  }
  set recurrence(recurrence) {
    const me = this;
    me._recurrence = recurrence;
    if (recurrence) {
      recurrence.timeSpan = me;
      me.recurrenceRule = recurrence.rule;
    } else {
      if (me.isOccurrence) {
        me.setData("recurrenceRule", null);
      } else {
        me.recurrenceRule = null;
      }
    }
  }
  get isRecurring() {
    return Boolean(!this.isOccurrence && this.recurrence);
  }
  get isOccurrence() {
    return Boolean(this.recurringTimeSpan);
  }
  get recurringTimeSpan() {
    return this._recurringTimeSpan;
  }
  get isPersistable() {
    return super.isPersistable && (!this.supportsRecurring || !this.isOccurrence);
  }
  set recurringTimeSpan(recurringTimeSpan) {
    this._recurringTimeSpan = recurringTimeSpan;
  }
  getOccurrencesForDateRange(startDate, endDate = startDate) {
    return this.eventStore.getOccurrencesForTimeSpan(this, startDate, endDate);
  }
  get occurrences() {
    if (this.isRecurring) {
      const result = [];
      this.occurrenceMap.forEach((occurrence) => {
        if (occurrence !== this) {
          result.push(occurrence);
        }
      });
      return result;
    }
    return emptyArray$1;
  }
  get occurrenceMap() {
    return this._occurrencesMap || (this._occurrencesMap = /* @__PURE__ */ new Map());
  }
  removeOccurrence(dateOrTimeSpan) {
    var _this$eventStore;
    const date2 = dateOrTimeSpan.isTimeSpan ? dateOrTimeSpan.occurrenceDate : dateOrTimeSpan;
    (_this$eventStore = this.eventStore) === null || _this$eventStore === void 0 ? void 0 : _this$eventStore.globalOccurrences.delete(this.createRecurrenceKey(date2));
    this.occurrenceMap.delete(DateHelper.makeKey(date2));
  }
  removeOccurrencesFrom(date2) {
    this.occurrenceMap.forEach((occurrence, dateKey) => {
      if (DateHelper.parseKey(dateKey) >= date2) {
        this.removeOccurrence(occurrence);
      }
    });
  }
  removeOccurrences() {
    [this, ...this.occurrences].forEach((occurrence) => this.removeOccurrence(occurrence));
  }
  onRecurrenceChanged() {
    var _this$recurrence;
    this.recurrenceRule = ((_this$recurrence = this.recurrence) === null || _this$recurrence === void 0 ? void 0 : _this$recurrence.rule) || null;
  }
  sanitizeRecurrenceData(recurrence = this.recurrence) {
    if (recurrence.endDate) {
      const endDate = DateHelper.clearTime(recurrence.endDate), {
        exceptionDates
      } = this;
      this.removeOccurrencesFrom(endDate);
      if (exceptionDates) {
        for (const dateKey in exceptionDates) {
          const exceptionDate = DateHelper.parseKey(dateKey);
          if (exceptionDate >= endDate) {
            delete exceptionDates[dateKey];
          }
        }
      }
    }
  }
  get occurrenceDate() {
    var _this$meta$modified;
    return ((_this$meta$modified = this.meta.modified) === null || _this$meta$modified === void 0 ? void 0 : _this$meta$modified.startDate) || this.startDate;
  }
  get occurrenceIndex() {
    return AbstractRecurrenceIterator.getOccurrenceIndex(this);
  }
  buildOccurrence(occurrenceDate, isFirst) {
    var _me$eventStore;
    const me = this, {
      occurrenceMap,
      recurrence,
      meta
    } = me, globalOccurrences = (_me$eventStore = me.eventStore) === null || _me$eventStore === void 0 ? void 0 : _me$eventStore.globalOccurrences, occurrenceKey = DateHelper.makeKey(occurrenceDate), id = me.createRecurrenceKey(occurrenceDate, occurrenceKey), onStartDate = !(occurrenceDate - me.startDate), {
      fieldMap
    } = me.constructor;
    let occurrence = globalOccurrences === null || globalOccurrences === void 0 ? void 0 : globalOccurrences.get(id), {
      duration
    } = me;
    if (me.endDate && (me.allDay || !duration)) {
      duration = DateHelper.as(me.durationUnit, me.endDate.getTime() - me.startDate.getTime());
    }
    const occurrenceEndDate = duration !== void 0 ? DateHelper.add(occurrenceDate, duration, me.durationUnit) : void 0;
    if (!occurrence) {
      if (isFirst || onStartDate) {
        occurrence = me;
        if (!onStartDate) {
          me.setStartEndDate(occurrenceDate, occurrenceEndDate, true);
          recurrence.suspendTimeSpanNotifying();
          recurrence.sanitize();
          recurrence.resumeTimeSpanNotifying();
        }
        meta.isSyncedWithRule = true;
      } else {
        occurrence = me.copy({
          [fieldMap.id.dataSource]: id,
          [fieldMap.startDate.dataSource]: occurrenceDate,
          [fieldMap.endDate.dataSource]: occurrenceEndDate,
          [fieldMap.duration.dataSource]: duration,
          constraintDate: null,
          constraintType: null
        }, {
          creatingOccurrence: true
        });
        occurrence.recurringTimeSpan = me;
      }
      globalOccurrences === null || globalOccurrences === void 0 ? void 0 : globalOccurrences.set(id, occurrence);
      occurrenceMap.set(occurrenceKey, occurrence);
    }
    return occurrence;
  }
  createRecurrenceKey(date2 = this.startDate, dateKey = null) {
    return `_generated:${this.id}:${dateKey || DateHelper.makeKey(date2)}`;
  }
  convertToRealEvent(wasSet, silent) {
    var _wasSet$resourceRecor;
    if (!this.isOccurrence) {
      return;
    }
    const me = this, {
      recurringTimeSpan,
      resource,
      occurrenceIndex,
      recurrence
    } = me, count = recurrence && recurringTimeSpan.recurrence.count, newResource = (wasSet === null || wasSet === void 0 ? void 0 : (_wasSet$resourceRecor = wasSet.resourceRecords) === null || _wasSet$resourceRecor === void 0 ? void 0 : _wasSet$resourceRecor.value) || me.data.newResource;
    recurringTimeSpan.beginBatch();
    me.detachFromRecurringEvent();
    me.clearChanges();
    me.setData("id", me.generateId(recurringTimeSpan.eventStore));
    if (newResource) {
      delete me.data.resourceId;
    }
    recurringTimeSpan.eventStore.add(me, silent);
    if (count) {
      me.recurrence.count = count - occurrenceIndex;
    }
    if (newResource || resource) {
      me.assign(newResource || resource);
    }
    if (newResource) {
      delete me.data.resourceRecords;
    }
    if (wasSet) {
      delete wasSet.resourceRecords;
    }
    recurringTimeSpan.endBatch();
  }
  afterChange(toSet, wasSet, silent, ...args) {
    const me = this, {
      eventStore
    } = me;
    if ("recurrenceRule" in wasSet) {
      me._recurrence = null;
      eventStore === null || eventStore === void 0 ? void 0 : eventStore.recurringEvents[wasSet.recurrenceRule.value ? "add" : "delete"](me);
    }
    if (me.isOccurrence) {
      me.convertToRealEvent(wasSet, silent);
    } else if ("newExceptionDate" in wasSet) {
      me.meta.modified.exceptionDates = true;
      delete me.meta.modified.newExceptionDate;
      me.removeOccurrence(wasSet.newExceptionDate.value);
    }
    return super.afterChange(toSet, wasSet, silent, ...args);
  }
  detachFromRecurringEvent() {
    const me = this, {
      recurringTimeSpan,
      occurrenceDate,
      startDate
    } = me;
    me.recurringTimeSpan = null;
    recurringTimeSpan.addExceptionDate(occurrenceDate);
    if (me.recurrenceRule) {
      recurringTimeSpan.recurrence.endDate = DateHelper.add(startDate, -1, "minute");
    }
  }
  set newExceptionDate(date2) {
    if (date2) {
      const exceptionDates = this.exceptionDates || (this.exceptionDates = {});
      exceptionDates[DateHelper.makeKey(date2)] = 1;
    }
  }
  addExceptionDate(newExceptionDate) {
    return this.set({
      newExceptionDate
    });
  }
  hasException(date2) {
    var _this$exceptionDates;
    return (_this$exceptionDates = this.exceptionDates) === null || _this$exceptionDates === void 0 ? void 0 : _this$exceptionDates[DateHelper.makeKey(date2)];
  }
};
var oneDayMS = 1e3 * 60 * 60 * 24;
var EventModelMixin = (Target) => class EventModelMixin extends Target {
  static get $name() {
    return "EventModelMixin";
  }
  static get isEventModel() {
    return true;
  }
  static get fields() {
    return [
      {
        name: "resourceId",
        internal: true
      },
      {
        name: "resources",
        column: {
          type: "resourceassignment"
        },
        persist: false,
        internal: true
      },
      {
        name: "draggable",
        type: "boolean",
        persist: false,
        defaultValue: true,
        internal: true
      },
      {
        name: "resizable",
        persist: false,
        defaultValue: true,
        internal: true
      },
      {
        name: "allDay",
        type: "boolean",
        defaultValue: false
      },
      {
        name: "eventStyle",
        internal: true
      },
      {
        name: "eventColor",
        internal: true
      },
      {
        name: "milestoneWidth",
        internal: true
      },
      {
        name: "stickyContents",
        internal: true
      }
    ];
  }
  updateAssignmentEventIds() {
    this.assigned.forEach((assignment) => {
      assignment.eventId = this.id;
    });
  }
  syncId(value) {
    super.syncId(value);
    this.updateAssignmentEventIds();
  }
  get resources() {
    return this.assignments.reduce((resources, {
      resource
    }) => {
      resource && resources.push(resource.$original);
      return resources;
    }, []);
  }
  set resources(resources) {
    resources = ArrayHelper.asArray(resources);
    const me = this, newResourceIds = resources.map(me.constructor.asId);
    if (me.usesSingleAssignment) {
      me.set("resourceId", newResourceIds[0]);
    } else {
      const existingResourceIds = me.assignments.map((a) => a.resource.id), {
        onlyInA: toAdd,
        onlyInB: toRemove
      } = ArrayHelper.delta(newResourceIds, existingResourceIds);
      me.assignmentStore.add(toAdd.map((resourceId) => ({
        resource: resourceId,
        event: me
      })));
      me.assignmentStore.remove(toRemove.map((resourceId) => me.assignments.find((a) => a.resource.id === resourceId)));
    }
  }
  forEachResource(fn2, thisObj = this) {
    for (const resource of this.resources) {
      if (fn2.call(thisObj, resource) === false) {
        return;
      }
    }
  }
  getResource(resourceId) {
    if (resourceId == null) {
      return this.resource;
    }
    return this.resourceStore ? this.resourceStore.getById(resourceId) : null;
  }
  get startDate() {
    let dt;
    if (this.isOccurrence) {
      dt = this.get("startDate");
    } else {
      var _this$_startDate;
      dt = (_this$_startDate = this._startDate) !== null && _this$_startDate !== void 0 ? _this$_startDate : super.startDate;
    }
    if (this.allDay) {
      dt = this.constructor.getAllDayStartDate(dt);
    }
    return dt;
  }
  set startDate(startDate) {
    if (this.batching) {
      this._startDate = startDate;
      this.set({
        startDate
      });
    } else {
      super.startDate = startDate;
    }
  }
  get endDate() {
    let dt;
    if (this.isOccurrence) {
      dt = this.get("endDate");
    } else {
      var _this$_endDate;
      dt = (_this$_endDate = this._endDate) !== null && _this$_endDate !== void 0 ? _this$_endDate : super.endDate;
    }
    if (this.allDay) {
      dt = this.constructor.getAllDayEndDate(dt);
    }
    return dt;
  }
  set endDate(endDate) {
    if (this.batching) {
      this._endDate = endDate;
      this.set({
        endDate
      });
    } else {
      super.endDate = endDate;
    }
  }
  get wrapStartDate() {
    return this.startDate;
  }
  set wrapStartDate(value) {
  }
  get wrapEndDate() {
    return this.endDate;
  }
  set wrapEndDate(value) {
  }
  get isEvent() {
    return true;
  }
  get isDraggable() {
    return !this.readOnly && this.draggable;
  }
  get isResizable() {
    return !this.isMilestone && (!this.isParent || this.manuallyScheduled) && this.resizable;
  }
  get isPersistable() {
    return super.isPersistable && !this.isCreating;
  }
  endBatch() {
    const {
      isPersistable: wasPersistable,
      meta: {
        batchChanges
      }
    } = this;
    if (batchChanges) {
      if ("endDate" in batchChanges) {
        delete this._endDate;
        if (this.postamble) {
          this.wrapEndDate = null;
        }
      }
      if ("startDate" in batchChanges) {
        delete this._startDate;
        if (this.preamble) {
          this.wrapStartDate = null;
        }
      }
    }
    super.endBatch(...arguments);
    if (this.isPersistable && !wasPersistable) {
      this.assignments.forEach((assignment) => {
        assignment.stores.forEach((s) => {
          s.updateModifiedBagForRecord(assignment);
        });
      });
    }
  }
  get isCreating() {
    return super.isCreating;
  }
  set isCreating(value) {
    super.isCreating = value;
    this.assignments.forEach((record) => record.isCreating = value);
  }
  get usesSingleAssignment() {
    return !this.eventStore || this.eventStore.usesSingleAssignment;
  }
  copy(...args) {
    const copy = super.copy(...args);
    if (!this.usesSingleAssignment) {
      copy.resourceId = null;
    }
    return copy;
  }
  get persistableData() {
    const data = super.persistableData;
    if (!this.usesSingleAssignment) {
      delete data.resourceId;
    }
    return data;
  }
  get resource() {
    const {
      resources
    } = this;
    return resources.length ? resources[0] : null;
  }
  set resource(resourceRecord) {
    this.resourceId = this.constructor.asId(resourceRecord);
  }
  get resourceId() {
    var _this$resource;
    return this.usesSingleAssignment ? this.get("resourceId") : (_this$resource = this.resource) === null || _this$resource === void 0 ? void 0 : _this$resource.id;
  }
  set resourceId(resourceId) {
    this.applyResourceId(resourceId);
  }
  get $linkedResources() {
    var _this$resources$flatM, _this$resources;
    return (_this$resources$flatM = (_this$resources = this.resources) === null || _this$resources === void 0 ? void 0 : _this$resources.flatMap((resourceRecord) => [resourceRecord, ...resourceRecord.$links])) !== null && _this$resources$flatM !== void 0 ? _this$resources$flatM : [];
  }
  applyResourceId(resourceId, fromApplyValue = false) {
    const me = this, {
      assignments,
      assignmentStore,
      eventStore
    } = me;
    if (eventStore) {
      if (resourceId != null) {
        if (!me.meta.skipEnforcingSingleAssignment) {
          eventStore.usesSingleAssignment = true;
        }
        if (assignments !== null && assignments !== void 0 && assignments.length && resourceId !== assignments[0].resourceId) {
          const eventsSuspended = Boolean(eventStore.eventsSuspended);
          eventsSuspended && assignmentStore.suspendEvents();
          assignments[0].resource = resourceId;
          eventsSuspended && assignmentStore.resumeEvents();
        } else {
          assignmentStore.assignEventToResource(me, resourceId);
        }
      } else {
        assignmentStore.remove(me.assignments);
      }
    } else if (!fromApplyValue) {
      me.set({
        resourceId
      });
    }
  }
  applyValue(useProp, mapping, value, skipAccessors, field) {
    if (field && field.name === "resourceId" && !this.meta.isAssigning) {
      const {
        eventStore
      } = this;
      eventStore && (eventStore.isAssigning = true);
      this.applyResourceId(value, true);
      eventStore && (eventStore.isAssigning = false);
    }
    super.applyValue(useProp, mapping, value, skipAccessors, field);
  }
  get assignments() {
    return [...this.assigned || []];
  }
  assign(resource, removeExistingAssignments = false) {
    const {
      eventStore
    } = this;
    if (eventStore && !eventStore.usesSingleAssignment) {
      eventStore.assignEventToResource(this, resource, removeExistingAssignments);
    } else {
      this.resourceId = this.constructor.asId(resource);
      if (!eventStore) {
        this.meta.skipEnforcingSingleAssignment = true;
      }
    }
  }
  unassign(resource, removingResource = false) {
    var _me$eventStore;
    const me = this;
    resource = me.constructor.asId(resource);
    me.meta.removingResource = removingResource;
    (_me$eventStore = me.eventStore) === null || _me$eventStore === void 0 ? void 0 : _me$eventStore.unassignEventFromResource(me, resource);
    me.meta.removingResource = null;
  }
  reassign(oldResourceId, newResourceId) {
    this.eventStore && this.eventStore.reassignEventFromResourceToResource(this, oldResourceId, newResourceId);
  }
  isAssignedTo(resource) {
    const resourceId = this.constructor.asId(resource);
    return this.assignments.some((assignment) => assignment.resourceId === resourceId);
  }
  get predecessors() {
    var _this$incomingDeps;
    return [...(_this$incomingDeps = this.incomingDeps) !== null && _this$incomingDeps !== void 0 ? _this$incomingDeps : []];
  }
  get successors() {
    var _this$outgoingDeps;
    return [...(_this$outgoingDeps = this.outgoingDeps) !== null && _this$outgoingDeps !== void 0 ? _this$outgoingDeps : []];
  }
  get dependencies() {
    var _this$incomingDeps2, _this$outgoingDeps2;
    return [...(_this$incomingDeps2 = this.incomingDeps) !== null && _this$incomingDeps2 !== void 0 ? _this$incomingDeps2 : [], ...(_this$outgoingDeps2 = this.outgoingDeps) !== null && _this$outgoingDeps2 !== void 0 ? _this$outgoingDeps2 : []];
  }
  normalize() {
  }
  inSetNormalize() {
  }
  get recurringEvent() {
    return this.recurringTimeSpan;
  }
  get isInterDay() {
    const {
      durationMS
    } = this;
    if (durationMS >= oneDayMS || !durationMS && this.allDay) {
      return true;
    }
    const {
      endDate,
      startDate
    } = this, eventStartMidnight = DateHelper.clearTime(startDate);
    if (startDate && endDate) {
      eventStartMidnight.setDate(eventStartMidnight.getDate() + 1);
      return (endDate || DateHelper.add(startDate, durationMS)) > eventStartMidnight;
    }
  }
  static getAllDayStartDate(dt) {
    if (dt && dt.isEvent) {
      dt = dt.get("startDate");
    }
    if (dt) {
      dt = DateHelper.clearTime(dt, true);
    }
    return dt;
  }
  static getAllDayEndDate(dt) {
    if (dt && dt.isEvent) {
      dt = dt.get("endDate");
    }
    if (dt && (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0)) {
      dt = DateHelper.getNext(dt, "d", 1);
    }
    return dt;
  }
  static getAllDayDisplayStartDate(dt) {
    if (dt && dt.isEvent) {
      dt = dt.get("startDate");
    }
    return DateHelper.clearTime(dt, true);
  }
  static getAllDayDisplayEndDate(startDate, endDate) {
    if (startDate && startDate.isEvent) {
      endDate = startDate.get("endDate");
      startDate = startDate.get("startDate");
    }
    if (endDate) {
      startDate = this.constructor.getAllDayDisplayStartDate(startDate);
      if (DateHelper.clearTime(endDate, true).valueOf() === endDate.valueOf()) {
        endDate = DateHelper.add(endDate, DateHelper.DAY, -1);
      } else if (startDate.valueOf() !== endDate.valueOf()) {
        endDate = DateHelper.clearTime(endDate, true);
      }
    }
    return endDate;
  }
  isEditable(fieldName) {
    switch (fieldName) {
      case "endDate":
      case "duration":
      case "fullDuration":
        return this.isLeaf;
    }
    return super.isEditable(fieldName);
  }
};
var EngineMixin$4 = SchedulerCoreEvent;
var EventModel = class extends EngineMixin$4.derive(TimeSpan).mixin(RecurringTimeSpan, PartOfProject, EventModelMixin) {
  static get $name() {
    return "EventModel";
  }
};
EventModel.exposeProperties();
EventModel._$name = "EventModel";
var EngineMixin$3 = PartOfProject(CoreEventStoreMixin.derive(AjaxStore));
var EventStore = class extends EngineMixin$3.mixin(SharedEventStoreMixin, RecurringEventsMixin, EventStoreMixin, DayIndexMixin, GetEventsMixin) {
  static get defaultConfig() {
    return {
      modelClass: EventModel
    };
  }
};
_defineProperty(EventStore, "$name", "EventStore");
EventStore._$name = "EventStore";
var canonicalDependencyTypes = ["SS", "SF", "FS", "FF"];
var DependencyBaseModel = class extends Model {
  static get $name() {
    return "DependencyBaseModel";
  }
  static get Type() {
    return {
      StartToStart: 0,
      StartToEnd: 1,
      EndToStart: 2,
      EndToEnd: 3
    };
  }
  static get fields() {
    return [
      {
        name: "from"
      },
      {
        name: "to"
      },
      {
        name: "type",
        type: "int",
        defaultValue: 2
      },
      {
        name: "cls",
        defaultValue: ""
      },
      {
        name: "bidirectional",
        type: "boolean"
      },
      {
        name: "fromSide",
        type: "string"
      },
      {
        name: "toSide",
        type: "string"
      },
      {
        name: "lag",
        type: "number",
        allowNull: true,
        defaultValue: 0
      },
      {
        name: "lagUnit",
        type: "string",
        defaultValue: "d"
      },
      {
        name: "highlighted",
        persist: false,
        internal: true
      }
    ];
  }
  construct(data) {
    const from = data[this.fieldMap.from.dataSource], to = data[this.fieldMap.to.dataSource];
    if (from != null) {
      data.fromEvent = from;
    }
    if (to != null) {
      data.toEvent = to;
    }
    super.construct(...arguments);
  }
  get eventStore() {
    var _this$unjoinedStores$;
    return this.eventStore || ((_this$unjoinedStores$ = this.unjoinedStores[0]) === null || _this$unjoinedStores$ === void 0 ? void 0 : _this$unjoinedStores$.eventStore);
  }
  set from(value) {
    const {
      fromEvent
    } = this;
    if (fromEvent !== null && fromEvent !== void 0 && fromEvent.isModel && fromEvent.id === value) {
      this.set("from", value);
    } else {
      this.fromEvent = value;
    }
  }
  get from() {
    return this.get("from");
  }
  set to(value) {
    const {
      toEvent
    } = this;
    if (toEvent !== null && toEvent !== void 0 && toEvent.isModel && toEvent.id === value) {
      this.set("to", value);
    } else {
      this.toEvent = value;
    }
  }
  get to() {
    return this.get("to");
  }
  get hardType() {
    return this.getHardType();
  }
  set hardType(type) {
    this.setHardType(type);
  }
  getHardType() {
    return this.get("type");
  }
  setHardType(type) {
    let result;
    if (type !== this.hardType) {
      result = this.set({
        type,
        fromSide: null,
        toSide: null
      });
    }
    return result;
  }
  get lag() {
    return this.get("lag");
  }
  set lag(lag) {
    this.setLag(lag);
  }
  setLag(lag, lagUnit = this.lagUnit) {
    if (arguments.length === 1) {
      if (typeof lag === "number") {
        this.lag = lag;
      } else {
        lag = DateHelper.parseDuration(lag);
        this.set({
          lag: lag.magnitude,
          lagUnit: lag.unit
        });
      }
      return;
    }
    lag = parseFloat(lag);
    this.set({
      lag,
      lagUnit
    });
  }
  getLag() {
    if (this.lag) {
      return `${this.lag < 0 ? "-" : "+"}${Math.abs(this.lag)}${DateHelper.getShortNameOfUnit(this.lagUnit)}`;
    }
    return "";
  }
  get fullLag() {
    return new Duration({
      unit: this.lagUnit,
      magnitude: this.lag
    });
  }
  set fullLag(lag) {
    if (typeof lag === "string") {
      this.setLag(lag);
    } else {
      this.setLag(lag.magnitude, lag.unit);
    }
  }
  get isPersistable() {
    const me = this, {
      stores: stores2,
      unjoinedStores
    } = me, store = stores2[0];
    let result;
    if (store) {
      const {
        fromEvent,
        toEvent
      } = me, crudManager = store.crudManager;
      result = fromEvent && (crudManager || !fromEvent.hasGeneratedId) && toEvent && (crudManager || !toEvent.hasGeneratedId);
    } else {
      result = Boolean(unjoinedStores[0]);
    }
    return result && super.isPersistable;
  }
  getDateRange() {
    const {
      fromEvent,
      toEvent
    } = this;
    if (fromEvent !== null && fromEvent !== void 0 && fromEvent.isScheduled && toEvent !== null && toEvent !== void 0 && toEvent.isScheduled) {
      const Type = DependencyBaseModel.Type;
      let sourceDate, targetDate;
      switch (this.type) {
        case Type.StartToStart:
          sourceDate = fromEvent.startDateMS;
          targetDate = toEvent.startDateMS;
          break;
        case Type.StartToEnd:
          sourceDate = fromEvent.startDateMS;
          targetDate = toEvent.endDateMS;
          break;
        case Type.EndToEnd:
          sourceDate = fromEvent.endDateMS;
          targetDate = toEvent.endDateMS;
          break;
        case Type.EndToStart:
          sourceDate = fromEvent.endDateMS;
          targetDate = toEvent.startDateMS;
          break;
        default:
          throw new Error("Invalid dependency type: " + this.type);
      }
      return {
        start: Math.min(sourceDate, targetDate),
        end: Math.max(sourceDate, targetDate)
      };
    }
    return null;
  }
  highlight(cls) {
    var _this$highlighted$spl, _this$highlighted;
    const classes = (_this$highlighted$spl = (_this$highlighted = this.highlighted) === null || _this$highlighted === void 0 ? void 0 : _this$highlighted.split(" ")) !== null && _this$highlighted$spl !== void 0 ? _this$highlighted$spl : [];
    if (!classes.includes(cls)) {
      this.highlighted = classes.concat(cls).join(" ");
    }
  }
  unhighlight(cls) {
    const {
      highlighted
    } = this;
    if (highlighted) {
      const classes = highlighted.split(" "), index = classes.indexOf(cls);
      if (index >= 0) {
        classes.splice(index, 1);
        this.highlighted = classes.join(" ");
      }
    }
  }
  isHighlightedWith(cls) {
    return this.highlighted && this.highlighted.split(" ").includes(cls);
  }
  getConnectorString(raw) {
    const rawValue = canonicalDependencyTypes[this.type];
    if (raw) {
      return rawValue;
    }
    if (this.type === DependencyBaseModel.Type.EndToStart) {
      return "";
    }
    return rawValue;
  }
  toString() {
    return `${this.from}${this.getConnectorString()}${this.getLag()}`;
  }
  get isValid() {
    const {
      fromEvent,
      toEvent,
      type
    } = this;
    return typeof type === "number" && fromEvent && toEvent && fromEvent !== toEvent;
  }
  get fromEventName() {
    var _this$fromEvent;
    return ((_this$fromEvent = this.fromEvent) === null || _this$fromEvent === void 0 ? void 0 : _this$fromEvent.name) || "";
  }
  get toEventName() {
    var _this$toEvent;
    return ((_this$toEvent = this.toEvent) === null || _this$toEvent === void 0 ? void 0 : _this$toEvent.name) || "";
  }
  shouldRecordFieldChange(fieldName, oldValue, newValue) {
    if (!super.shouldRecordFieldChange(fieldName, oldValue, newValue)) {
      return false;
    }
    if (fieldName === "from" || fieldName === "to" || fieldName === "fromEvent" || fieldName === "toEvent") {
      var _this$project;
      const eventStore = (_this$project = this.project) === null || _this$project === void 0 ? void 0 : _this$project.eventStore;
      if (eventStore && eventStore.oldIdMap[oldValue] === eventStore.getById(newValue)) {
        return false;
      }
    }
    return true;
  }
};
DependencyBaseModel.exposeProperties();
DependencyBaseModel._$name = "DependencyBaseModel";
var EngineMixin$2 = CoreDependencyMixin;
var DependencyModel = class extends PartOfProject(EngineMixin$2.derive(DependencyBaseModel)) {
  static get $name() {
    return "DependencyModel";
  }
  getTypeFromSides(fromSide, toSide, rtl) {
    const types = DependencyBaseModel.Type, startSide = rtl ? "right" : "left", endSide = rtl ? "left" : "right";
    if (fromSide === startSide) {
      return toSide === startSide ? types.StartToStart : types.StartToEnd;
    }
    return toSide === endSide ? types.EndToEnd : types.EndToStart;
  }
};
DependencyModel.exposeProperties();
DependencyModel._$name = "DependencyModel";
var DependencyStoreMixin = (Target) => class DependencyStoreMixin extends Target {
  static get $name() {
    return "DependencyStoreMixin";
  }
  static get defaultConfig() {
    return {
      loadPriority: 400,
      syncPriority: 400,
      storeId: "dependencies"
    };
  }
  reduceEventDependencies(event, reduceFn, result, flat = true, depsGetterFn) {
    depsGetterFn = depsGetterFn || ((event2) => this.getEventDependencies(event2));
    event = ArrayHelper.asArray(event);
    event.reduce((result2, event2) => {
      if (event2.children && !flat) {
        event2.traverse((evt) => {
          result2 = depsGetterFn(evt).reduce(reduceFn, result2);
        });
      } else {
        result2 = depsGetterFn(event2).reduce(reduceFn, result2);
      }
    }, result);
    return result;
  }
  mapEventDependencies(event, fn2, filterFn, flat, depsGetterFn) {
    return this.reduceEventDependencies(event, (result, dependency) => {
      filterFn(dependency) && result.push(dependency);
      return result;
    }, [], flat, depsGetterFn);
  }
  mapEventPredecessors(event, fn2, filterFn, flat) {
    return this.reduceEventPredecessors(event, (result, dependency) => {
      filterFn(dependency) && result.push(dependency);
      return result;
    }, [], flat);
  }
  mapEventSuccessors(event, fn2, filterFn, flat) {
    return this.reduceEventSuccessors(event, (result, dependency) => {
      filterFn(dependency) && result.push(dependency);
      return result;
    }, [], flat);
  }
  getEventDependencies(event) {
    return [].concat(event.predecessors || [], event.successors || []);
  }
  removeEventDependencies(event) {
    this.remove(this.getEventDependencies(event));
  }
  removeEventPredecessors(event) {
    this.remove(event.predecessors);
  }
  removeEventSuccessors(event, flat) {
    this.remove(event.successors);
  }
  getBySourceTargetId(key) {
    return this.records.find((r) => key == this.constructor.makeDependencySourceTargetCompositeKey(r.from, r.to));
  }
  getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) {
    sourceEvent = Model.asId(sourceEvent);
    targetEvent = Model.asId(targetEvent);
    return this.getBySourceTargetId(this.constructor.makeDependencySourceTargetCompositeKey(sourceEvent, targetEvent));
  }
  getEventsLinkingDependency(sourceEvent, targetEvent) {
    return this.getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) || this.getDependencyForSourceAndTargetEvents(targetEvent, sourceEvent);
  }
  async isValidDependency(dependencyOrFromId, toId, type) {
    let fromEvent = dependencyOrFromId, toEvent = toId;
    if (dependencyOrFromId == null) {
      return false;
    }
    if (dependencyOrFromId.isDependencyModel) {
      ({
        fromEvent,
        toEvent
      } = dependencyOrFromId);
    }
    fromEvent = this.eventStore.getById(fromEvent);
    toEvent = this.eventStore.getById(toEvent);
    if (fromEvent && toEvent) {
      if (!fromEvent.project || !toEvent.project) {
        return false;
      }
      return this.project.isValidDependency(fromEvent, toEvent, type);
    }
    return dependencyOrFromId !== toId;
  }
  isValidDependencyToCreate(fromId, toId, type) {
    return this.isValidDependency(fromId, toId, type);
  }
  getHighlightedDependencies(cls) {
    return this.records.reduce((result, dep) => {
      if (dep.isHighlightedWith(cls))
        result.push(dep);
      return result;
    }, []);
  }
  static makeDependencySourceTargetCompositeKey(from, to) {
    return `source(${from})-target(${to})`;
  }
  getTimeSpanDependencies(record) {
    return this.getEventDependencies(record);
  }
};
var EngineMixin$1 = PartOfProject(CoreDependencyStoreMixin.derive(AjaxStore));
var DependencyStore = class extends DependencyStoreMixin(EngineMixin$1.derive(AjaxStore)) {
  static get defaultConfig() {
    return {
      modelClass: DependencyModel
    };
  }
};
DependencyStore._$name = "DependencyStore";
var ProjectCrudManager = (Target) => class ProjectCrudManager extends (Target || Base$1).mixin(AbstractCrudManagerMixin, AjaxTransport, JsonEncoder) {
  static get defaultConfig() {
    return {
      project: null
    };
  }
  startConfigure(config) {
    this.getConfig("project");
    super.startConfigure(config);
    this._changesToClear = /* @__PURE__ */ new Map();
  }
  async doAutoLoad() {
    const {
      project
    } = this;
    if (project) {
      await project.commitAsync();
    }
    return super.doAutoLoad();
  }
  applyProjectResponse(response) {
    const me = this, {
      project
    } = me;
    me.applyingProjectResponse = true;
    const startDateField = project.fieldMap.startDate, endDateField = project.fieldMap.endDate, startDate = ObjectHelper.getPath(response, startDateField.dataSource), endDate = ObjectHelper.getPath(response, endDateField.dataSource);
    if (typeof startDate === "string") {
      ObjectHelper.setPath(response, startDateField.dataSource, startDateField.convert(startDate));
    }
    if (typeof endDate === "string") {
      ObjectHelper.setPath(response, endDateField.dataSource, endDateField.convert(endDate));
    }
    Object.assign(project, response);
    me._changesToClear.set(me, response);
    me.applyingProjectResponse = false;
  }
  loadCrudManagerData(response, options = {}) {
    const me = this, {
      project
    } = me;
    me.suspendChangesTracking();
    super.loadCrudManagerData(...arguments);
    if (response !== null && response !== void 0 && response.project) {
      if (project.delayEnteringReplica) {
        project.ion({
          recordsUnlinked: () => {
            me.suspendChangesTracking();
            me.applyProjectResponse(response.project);
            me.resumeChangesTracking();
          },
          once: true
        });
      } else {
        me.applyProjectResponse(response.project);
      }
    }
    me.resumeChangesTracking();
  }
  async sync() {
    const {
      project
    } = this;
    this.suspendAutoSync();
    if (project) {
      await project.commitAsync();
    }
    if (this.isDestroying) {
      return;
    }
    this.resumeAutoSync(false);
    return super.sync();
  }
  async applyResponse(request, response, options) {
    var _me$project, _request$pack;
    const me = this;
    if (me.isDestroyed || (_me$project = me.project) !== null && _me$project !== void 0 && _me$project.isDestroyed) {
      return;
    }
    me.trigger("startApplyResponse");
    await super.applyResponse(request, response, options);
    if (response !== null && response !== void 0 && response.project || me.supportShortSyncResponse && request !== null && request !== void 0 && (_request$pack = request.pack) !== null && _request$pack !== void 0 && _request$pack.project) {
      var _request$pack2;
      me.applyProjectResponse(response.project || (request === null || request === void 0 ? void 0 : (_request$pack2 = request.pack) === null || _request$pack2 === void 0 ? void 0 : _request$pack2.project));
    }
    if (me.project) {
      var _me$resumeAutoSync, _me$commitRespondedCh;
      let requestType = request.type;
      if (me.trackResponseType) {
        requestType = response.type || requestType;
      }
      const propagationFlag = `propagating${StringHelper.capitalize(requestType)}Changes`;
      me.suspendAutoSync();
      me[propagationFlag] = true;
      const loud = me.project.isInitialCommit && !me.project.silenceInitialCommit;
      await me.project.commitAsync();
      me[propagationFlag] = false;
      (_me$resumeAutoSync = me.resumeAutoSync) === null || _me$resumeAutoSync === void 0 ? void 0 : _me$resumeAutoSync.call(me, loud);
      (_me$commitRespondedCh = me.commitRespondedChanges) === null || _me$commitRespondedCh === void 0 ? void 0 : _me$commitRespondedCh.call(me);
    }
  }
  applySyncResponse(...args) {
    var _me$project2;
    const me = this, stmDisabled = (_me$project2 = me.project) === null || _me$project2 === void 0 ? void 0 : _me$project2.stm.disabled;
    if (stmDisabled === false && me.ignoreRemoteChangesInSTM) {
      me.project.stm.disable();
    }
    super.applySyncResponse(...args);
    if (stmDisabled === false) {
      me.project.stm.enable();
    }
  }
  shouldClearRecordFieldChange(record, field, value) {
    var _field;
    const oldValue = record[field];
    field = record.getFieldDefinition(field);
    return (_field = field) !== null && _field !== void 0 && _field.isEqual ? field.isEqual(oldValue, value) : ObjectHelper.isEqual(oldValue, value);
  }
  commitRespondedChanges() {
    this._changesToClear.forEach((changes, record) => {
      Object.entries(changes).forEach(([key, value]) => {
        if (this.shouldClearRecordFieldChange(record, key, value)) {
          delete record.meta.modified[key];
        }
      });
    });
    this._changesToClear.clear();
  }
  applyChangesToStore(storeDesc, storeResponse, storePack, ...rest) {
    const changesMap = super.applyChangesToStore(storeDesc, storeResponse, storePack, ...rest);
    if (changesMap.size && this.project) {
      for (const [id, changes] of changesMap) {
        const record = storeDesc.store.getById(id);
        record && this._changesToClear.set(record, changes);
      }
    }
    return changesMap;
  }
};
var ProjectModelCommon = (Target) => {
  var _class;
  return _class = class ProjectModelCommon extends (Target || Model) {
    static get configurable() {
      return {
        assignments: null,
        dependencies: null,
        resources: null,
        timeRanges: null
      };
    }
    get assignments() {
      return this.assignmentStore.records;
    }
    updateAssignments(assignments) {
      this.assignmentStore.data = assignments;
    }
    get dependencies() {
      return this.dependencyStore.records;
    }
    updateDependencies(dependencies) {
      this.dependencyStore.data = dependencies;
    }
    get resources() {
      return this.resourceStore.records;
    }
    updateResources(resources) {
      this.resourceStore.data = resources;
    }
    get timeRanges() {
      return this.timeRangeStore.records;
    }
    getTimeRanges(startDate, endDate) {
      const store = this.timeRangeStore, ret = [];
      for (const timeSpan of store) {
        if (timeSpan.isRecurring) {
          ret.push(...timeSpan.getOccurrencesForDateRange(startDate, endDate));
        } else if (timeSpan.startDate < endDate && startDate < timeSpan.endDate) {
          ret.push(timeSpan);
        }
      }
      return ret;
    }
    updateTimeRanges(timeRanges) {
      this.timeRangeStore.data = timeRanges;
    }
    getResourceTimeRanges(startDate, endDate) {
      const store = this.resourceTimeRangeStore, ret = [];
      for (const timeSpan of store) {
        if (timeSpan.isRecurring) {
          ret.push(...timeSpan.getOccurrencesForDateRange(startDate, endDate));
        } else if (timeSpan.startDate < endDate && startDate < timeSpan.endDate) {
          ret.push(timeSpan);
        }
      }
      return ret;
    }
  }, _defineProperty(_class, "$name", "ProjectModelCommon"), _class;
};
var ResourceTimeRangeModel = class extends TimeSpan {
  get domId() {
    return `${this.constructor.domIdPrefix}-${this.id}`;
  }
  get isResourceTimeRange() {
    return true;
  }
  get resources() {
    return this.resource ? [this.resource] : [];
  }
  get $linkedResources() {
    return this.resources;
  }
};
_defineProperty(ResourceTimeRangeModel, "$name", "ResourceTimeRangeModel");
_defineProperty(ResourceTimeRangeModel, "fields", [
  "resourceId",
  "timeRangeColor"
]);
_defineProperty(ResourceTimeRangeModel, "relations", {
  resource: {
    foreignKey: "resourceId",
    foreignStore: "resourceStore",
    relatedCollectionName: "timeRanges",
    nullFieldOnRemove: true
  }
});
_defineProperty(ResourceTimeRangeModel, "domIdPrefix", "resourcetimerange");
ResourceTimeRangeModel._$name = "ResourceTimeRangeModel";
var ResourceTimeRangeStore = class extends AjaxStore {
  static get defaultConfig() {
    return {
      loadPriority: 500,
      syncPriority: 500,
      resourceStore: null,
      modelClass: ResourceTimeRangeModel,
      storeId: "resourceTimeRanges"
    };
  }
  set resourceStore(store) {
    this._resourceStore = store;
    if (!this.isConfiguring) {
      this.initRelations(true);
    }
  }
  get resourceStore() {
    return this._resourceStore;
  }
  getResourcesForEvent(resourceTimeRange) {
    return [resourceTimeRange.resource];
  }
  getRanges({
    resourceRecord,
    startDate,
    endDate
  }) {
    const rangesInDateRange = resourceRecord.timeRanges.flatMap((range) => {
      if (range.supportsRecurring) {
        return range.getOccurrencesForDateRange(startDate, endDate);
      }
      if (range.intersectsRange(startDate, endDate)) {
        return range;
      }
      return [];
    });
    return rangesInDateRange.sort((span1, span2) => span1.startDate - span2.startDate);
  }
};
_defineProperty(ResourceTimeRangeStore, "$name", "ResourceTimeRangeStore");
ResourceTimeRangeStore._$name = "ResourceTimeRangeStore";
var ProjectModelTimeZoneMixin = (Target) => {
  var _class;
  return _class = class ProjectModelTimeZoneMixin extends (Target || Model) {
    afterConstruct() {
      super.afterConstruct(...arguments);
      this._storesWithDates = [this.taskStore, this.timeRangeStore, this.resourceTimeRangeStore];
    }
    relayStoreChange({
      source,
      action,
      records,
      replaced
    }) {
      const me = this;
      if (me.timeZone && me._storesWithDates.includes(source)) {
        if (action === "dataset") {
          me.convertStoresToTimeZone([source]);
          me.ignoreRecordChanges = true;
          me.commitAsync();
        } else if (["add", "replace"].includes(action)) {
          var _records;
          if (!((_records = records) !== null && _records !== void 0 && _records.length) && replaced !== null && replaced !== void 0 && replaced.length) {
            records = replaced;
          }
          if (records.length) {
            records.forEach((record) => record._inTimeZone = me.timeZone);
          }
        }
      }
    }
    convertStoresToTimeZone(stores2) {
      var _me$stm;
      const me = this, {
        timeZone
      } = me, stmAutoRecord = (_me$stm = me.stm) === null || _me$stm === void 0 ? void 0 : _me$stm.autoRecord;
      if (stmAutoRecord) {
        me.stm.autoRecord = false;
      }
      for (const store of stores2) {
        if (store) {
          store.forEach((r) => {
            var _r$baselines;
            r.$ignoreChange = true;
            if ((_r$baselines = r.baselines) !== null && _r$baselines !== void 0 && _r$baselines.count) {
              for (const bl of r.baselines) {
                if (r._inTimeZone !== bl._inTimeZone) {
                  bl._inTimeZone = r._inTimeZone;
                }
                bl.convertToTimeZone(timeZone);
              }
            }
            r.convertToTimeZone(timeZone);
            delete r.$ignoreChange;
          });
        }
      }
      if (stmAutoRecord) {
        me.stmAutoRecord = stmAutoRecord;
      }
    }
    updateTimeZone(timeZone, oldTimeZone) {
      const me = this, isConfiguring = me._isConfiguringTimeZone || me.isConfiguring;
      me.calendarManagerStore.forEach((calendar) => calendar.bumpVersion());
      me.convertStoresToTimeZone(me._storesWithDates);
      if (me.startDate) {
        const startDate = oldTimeZone ? TimeZoneHelper.fromTimeZone(me.startDate, oldTimeZone) : me.startDate;
        me.startDate = timeZone ? TimeZoneHelper.toTimeZone(startDate, timeZone) : startDate;
      }
      me.ignoreRecordChanges = true;
      me.commitAsync().then(() => {
        if (!me.isDestroyed) {
          me.trigger("timeZoneChange", {
            timeZone,
            oldTimeZone,
            isConfiguring
          });
        }
        delete me._isConfiguringTimeZone;
      });
    }
  }, _defineProperty(_class, "$name", "ProjectModelTimeZoneMixin"), _defineProperty(_class, "configurable", {
    timeZone: {
      $config: "lazy",
      value: null
    }
  }), _class;
};
var ProjectModelMixin = (Target) => {
  var _class;
  return _class = class ProjectModelMixin extends (Target || Model).mixin(ProjectModelCommon, ProjectModelTimeZoneMixin) {
    static get $name() {
      return "ProjectModelMixin";
    }
    static get defaultConfig() {
      return {
        stm: {},
        timeRangeModelClass: TimeSpan,
        resourceTimeRangeModelClass: ResourceTimeRangeModel,
        timeRangeStoreClass: Store,
        resourceTimeRangeStoreClass: ResourceTimeRangeStore,
        eventStore: {},
        assignmentStore: {},
        dependencyStore: {},
        resourceStore: {},
        timeRangesData: null
      };
    }
    get inlineData() {
      return StringHelper.safeJsonParse(super.json);
    }
    set inlineData(inlineData) {
      this.json = inlineData;
    }
    construct(config = {}) {
      super.construct(...arguments);
      if (config.timeRangesData) {
        this.timeRangeStore.data = config.timeRangesData;
      }
      if (config.resourceTimeRangesData) {
        this.resourceTimeRangeStore.data = config.resourceTimeRangesData;
      }
    }
    afterConstruct() {
      super.afterConstruct();
      const me = this;
      !me.timeRangeStore.stm && me.stm.addStore(me.timeRangeStore);
      !me.resourceTimeRangeStore.stm && me.stm.addStore(me.resourceTimeRangeStore);
    }
    attachStore(store) {
      store === null || store === void 0 ? void 0 : store.ion({
        name: store.$$name,
        change: "relayStoreChange",
        thisObj: this
      });
    }
    detachStore(store) {
      store && this.detachListeners(store.$$name);
    }
    relayStoreChange(event) {
      super.relayStoreChange(event);
      return this.trigger("change", _objectSpread2(_objectSpread2({
        store: event.source
      }, event), {}, {
        source: this
      }));
    }
    updateTimeRangeStore(store, oldStore) {
      this.detachStore(oldStore);
      this.attachStore(store);
    }
    setTimeRangeStore(store) {
      this.timeRangeStore = store;
    }
    changeTimeRangeStore(store) {
      if (store && !store.isStore) {
        store = this.timeRangeStoreClass.new({
          modelClass: this.timeRangeModelClass
        }, store);
      }
      return store;
    }
    updateResourceTimeRangeStore(store, oldStore) {
      this.detachStore(oldStore);
      this.attachStore(store);
    }
    changeResourceTimeRangeStore(store) {
      if (store && !store.isStore) {
        store = this.resourceTimeRangeStoreClass.new({
          modelClass: this.resourceTimeRangeModelClass
        }, store);
      }
      return store;
    }
    setResourceTimeRangeStore(store) {
      this.resourceTimeRangeStore = store;
    }
    get events() {
      return this.eventStore.records;
    }
    updateEvents(events) {
      this.eventStore.data = events;
    }
    get resourceTimeRanges() {
      return this.resourceTimeRangeStore.records;
    }
    updateResourceTimeRanges(resourceTimeRanges) {
      this.resourceTimeRangeStore.data = resourceTimeRanges;
    }
    async loadInlineData(data) {
      this.isLoadingInlineData = true;
      if (data.resourceTimeRangesData) {
        this.resourceTimeRangeStore.data = data.resourceTimeRangesData;
      }
      if (data.timeRangesData) {
        this.timeRangeStore.data = data.timeRangesData;
      }
      return super.loadInlineData(data);
    }
    toJSON() {
      const me = this, result = {
        eventsData: me.eventStore.toJSON(),
        resourcesData: me.resourceStore.toJSON(),
        dependenciesData: me.dependencyStore.toJSON(),
        timeRangesData: me.timeRangeStore.toJSON(),
        resourceTimeRangesData: me.resourceTimeRangeStore.toJSON()
      };
      if (!me.eventStore.usesSingleAssignment) {
        result.assignmentsData = me.assignmentStore.toJSON();
      }
      return result;
    }
    get json() {
      return super.json;
    }
    changeJson(json) {
      if (typeof json === "string") {
        json = StringHelper.safeJsonParse(json);
      }
      return json;
    }
    updateJson(json) {
      json && this.loadInlineData(json);
    }
    afterChange(toSet, wasSet) {
      super.afterChange(...arguments);
      if (wasSet.calendar) {
        this.trigger("calendarChange");
      }
    }
    doDestroy() {
      this.timeRangeStore.destroy();
      this.resourceTimeRangeStore.destroy();
      super.doDestroy();
    }
  }, _defineProperty(_class, "configurable", {
    json: null,
    timeRangeStore: {
      value: {
        id: "timeRanges",
        modelClass: TimeSpan
      },
      $config: "nullify"
    },
    resourceTimeRangeStore: {
      value: {},
      $config: "nullify"
    },
    events: null,
    resourceTimeRanges: null
  }), _class;
};
var ProjectCurrentConfig = (Target) => class ProjectCurrentConfig extends Target {
  getCurrentConfig(options) {
    const me = this, result = super.getCurrentConfig(options);
    if (result) {
      for (const storeName of ["eventStore", "resourceStore", "assignmentStore", "dependencyStore", "timeRangeStore", "resourceTimeRangeStore"]) {
        const store = me[storeName];
        if (store) {
          if (store.count) {
            result[store.id + "Data"] = store.getInlineData(options);
          }
          const storeState = store.getCurrentConfig(options);
          if (storeState && Object.keys(storeState).length > 0) {
            result[storeName] = Object.assign(result[storeName] || {}, storeState);
          } else if (result[storeName] && Object.keys(result[storeName]).length === 0) {
            delete result[storeName];
          }
        }
      }
      if (result.timeRangeStore) {
        if (me.timeRangeStore.originalModelClass === me.timeRangeModelClass || me.timeRangeStore.originalModelClass.$name === "TimeSpan") {
          delete result.timeRangeStore.modelClass;
        }
        if (result.timeRangeStore.storeId === "timeRanges") {
          delete result.timeRangeStore.storeId;
        }
        if (Object.keys(result.timeRangeStore).length === 1) {
          delete result.timeRangeStore;
        }
      }
      if (me.taskStore.isTaskStore) {
        delete result.eventModelClass;
        delete result.eventStoreClass;
        delete result.children;
      }
      return result;
    }
  }
};
var ModelPersistencyManager = class extends Base$1 {
  set eventStore(newEventStore) {
    const me = this;
    me.eventStoreDetacher && me.eventStoreDetacher();
    me._eventStore = newEventStore;
    if (newEventStore && newEventStore.autoCommit) {
      me.eventStoreDetacher = newEventStore.ion({
        beforecommit: me.onEventStoreBeforeSync,
        thisObj: me,
        detachable: true,
        prio: 100
      });
    }
  }
  get eventStore() {
    return this._eventStore;
  }
  set resourceStore(newResourceStore) {
    const me = this;
    me.resourceStoreDetacher && me.resourceStoreDetacher();
    me._resourceStore = newResourceStore;
    if (newResourceStore && newResourceStore.autoCommit) {
      me.resourceStoreDetacher = newResourceStore.ion({
        beforecommit: me.onResourceStoreBeforeSync,
        thisObj: me,
        detachable: true,
        prio: 100
      });
    }
  }
  get resourceStore() {
    return this._resourceStore;
  }
  set assignmentStore(newAssignmentStore) {
    const me = this;
    me.assignmentStoreDetacher && me.assignmentStoreDetacher();
    me._assignmentStore = newAssignmentStore;
    if (newAssignmentStore && newAssignmentStore.autoSync) {
      me.assignmentStoreDetacher = newAssignmentStore.ion({
        beforecommit: me.onAssignmentStoreBeforeSync,
        thisObj: me,
        detachable: true,
        prio: 100
      });
    }
  }
  get assignmentStore() {
    return this._assignmentStore;
  }
  set dependencyStore(newDependencyStore) {
    const me = this;
    me.dependencyStoreDetacher && me.dependencyStoreDetacher();
    me._dependencyStore = newDependencyStore;
    if (newDependencyStore && newDependencyStore.autoSync) {
      me.dependencyStoreDetacher = newDependencyStore.ion({
        beforecommit: me.onDependencyStoreBeforeSync,
        thisObj: me,
        detachable: true,
        prio: 100
      });
    }
  }
  get dependencyStore() {
    return this._dependencyStore;
  }
  onEventStoreBeforeSync({
    changes
  }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }
  onResourceStoreBeforeSync({
    changes
  }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }
  onAssignmentStoreBeforeSync({
    changes
  }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }
  onDependencyStoreBeforeSync({
    changes
  }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }
  removeNonPersistableRecordsToCreate(changes) {
    const recordsToCreate = changes.added || [];
    let r, i;
    for (i = recordsToCreate.length - 1; i >= 0; --i) {
      r = recordsToCreate[i];
      if (!r.isPersistable) {
        recordsToCreate.splice(recordsToCreate.indexOf(r), 1);
      }
    }
    if (recordsToCreate.length === 0) {
      changes.added.length = 0;
    }
  }
  shallContinueSync(options) {
    return Boolean(options.added && options.added.length > 0 || options.modified && options.modified.length > 0 || options.removed && options.removed.length > 0);
  }
};
ModelPersistencyManager._$name = "ModelPersistencyManager";
var EngineMixin = SchedulerCoreProjectMixin;
var ProjectModel$1 = class extends ProjectCurrentConfig(ProjectModelMixin(EngineMixin)) {
  static get $name() {
    return "ProjectModel";
  }
  static get defaultConfig() {
    return {
      eventModelClass: EventModel,
      dependencyModelClass: DependencyModel,
      resourceModelClass: ResourceModel,
      assignmentModelClass: AssignmentModel,
      eventStoreClass: EventStore,
      dependencyStoreClass: DependencyStore,
      resourceStoreClass: ResourceStore,
      assignmentStoreClass: AssignmentStore
    };
  }
  construct(...args) {
    super.construct(...args);
    if (VersionHelper.isTestEnv) {
      globalThis.bryntum.testProject = this;
    }
    this.modelPersistencyManager = this.createModelPersistencyManager();
  }
  createModelPersistencyManager() {
    return new ModelPersistencyManager({
      eventStore: this,
      resourceStore: this.resourceStore,
      assignmentStore: this.assignmentStore,
      dependencyStore: this.dependencyStore
    });
  }
  doDestroy() {
    this.modelPersistencyManager.destroy();
    super.doDestroy();
  }
  get taskStore() {
    return this.eventStore;
  }
};
ProjectModel$1.applyConfigs = true;
ProjectModel$1.initClass();
ProjectModel$1._$name = "ProjectModel";
var CrudManager$1 = class extends AbstractCrudManager.mixin(ProjectCrudManager, AjaxTransport, JsonEncoder) {
  static get defaultConfig() {
    return {
      projectClass: ProjectModel$1,
      resourceStoreClass: ResourceStore,
      eventStoreClass: EventStore,
      assignmentStoreClass: AssignmentStore,
      dependencyStoreClass: DependencyStore,
      resourceStore: {},
      eventStore: {},
      assignmentStore: {},
      dependencyStore: {},
      project: null
    };
  }
  buildProject() {
    return new this.projectClass(this.buildProjectConfig());
  }
  buildProjectConfig() {
    return ObjectHelper.cleanupProperties({
      eventStore: this.eventStore,
      resourceStore: this.resourceStore,
      assignmentStore: this.assignmentStore,
      dependencyStore: this.dependencyStore,
      resourceTimeRangeStore: this.resourceTimeRangeStore
    });
  }
  set project(project) {
    const me = this;
    if (project !== me._project) {
      me.detachListeners("beforeDataReady");
      me.detachListeners("afterDataReady");
      me._project = project;
      if (project) {
        me.eventStore = project.eventStore;
        me.resourceStore = project.resourceStore;
        me.assignmentStore = project.assignmentStore;
        me.dependencyStore = project.dependencyStore;
        me.timeRangeStore = project.timeRangeStore;
        me.resourceTimeRangeStore = project.resourceTimeRangeStore;
        project.ion({
          name: "beforeDataReady",
          dataReady: () => me.suspendChangesTracking(),
          prio: 100,
          thisObj: me
        });
        project.ion({
          name: "afterDataReady",
          dataReady: () => me.resumeChangesTracking(),
          prio: -100,
          thisObj: me
        });
      }
      if (!me.eventStore) {
        me.eventStore = {};
      }
      if (!me.resourceStore) {
        me.resourceStore = {};
      }
      if (!me.assignmentStore) {
        me.assignmentStore = {};
      }
      if (!me.dependencyStore) {
        me.dependencyStore = {};
      }
    }
  }
  get project() {
    return this._project;
  }
  get timeRangeStore() {
    var _this$_timeRangeStore;
    return (_this$_timeRangeStore = this._timeRangeStore) === null || _this$_timeRangeStore === void 0 ? void 0 : _this$_timeRangeStore.store;
  }
  set timeRangeStore(store) {
    var _this$project;
    this.setFeaturedStore("_timeRangeStore", store, (_this$project = this.project) === null || _this$project === void 0 ? void 0 : _this$project.timeRangeStoreClass);
  }
  get resourceTimeRangeStore() {
    var _this$_resourceTimeRa;
    return (_this$_resourceTimeRa = this._resourceTimeRangeStore) === null || _this$_resourceTimeRa === void 0 ? void 0 : _this$_resourceTimeRa.store;
  }
  set resourceTimeRangeStore(store) {
    var _this$project2;
    this.setFeaturedStore("_resourceTimeRangeStore", store, (_this$project2 = this.project) === null || _this$project2 === void 0 ? void 0 : _this$project2.resourceTimeRangeStoreClass);
  }
  get resourceStore() {
    var _this$_resourceStore;
    return (_this$_resourceStore = this._resourceStore) === null || _this$_resourceStore === void 0 ? void 0 : _this$_resourceStore.store;
  }
  set resourceStore(store) {
    const me = this;
    me.setFeaturedStore("_resourceStore", store, me.resourceStoreClass);
  }
  get eventStore() {
    var _this$_eventStore;
    return (_this$_eventStore = this._eventStore) === null || _this$_eventStore === void 0 ? void 0 : _this$_eventStore.store;
  }
  set eventStore(store) {
    const me = this;
    me.setFeaturedStore("_eventStore", store, me.eventStoreClass);
  }
  get assignmentStore() {
    var _this$_assignmentStor;
    return (_this$_assignmentStor = this._assignmentStore) === null || _this$_assignmentStor === void 0 ? void 0 : _this$_assignmentStor.store;
  }
  set assignmentStore(store) {
    this.setFeaturedStore("_assignmentStore", store, this.assignmentStoreClass);
  }
  get dependencyStore() {
    var _this$_dependencyStor;
    return (_this$_dependencyStor = this._dependencyStore) === null || _this$_dependencyStor === void 0 ? void 0 : _this$_dependencyStor.store;
  }
  set dependencyStore(store) {
    this.setFeaturedStore("_dependencyStore", store, this.dependencyStoreClass);
  }
  setFeaturedStore(property, store, storeClass) {
    var _me$property;
    const me = this, oldStore = (_me$property = me[property]) === null || _me$property === void 0 ? void 0 : _me$property.store;
    if (oldStore !== store) {
      var _store;
      store = Store.getStore(store, ((_store = store) === null || _store === void 0 ? void 0 : _store.storeClass) || storeClass);
      if (oldStore) {
        me.removeStore(oldStore);
      }
      me[property] = store && {
        store
      } || null;
      me.addPrioritizedStore(me[property]);
    }
    return me[property];
  }
  getChangesetPackage() {
    const pack = super.getChangesetPackage();
    if (pack && this.eventStore.usesSingleAssignment) {
      delete pack[this.assignmentStore.storeId];
      if (!this.crudStores.some((storeInfo) => pack[storeInfo.storeId])) {
        return null;
      }
    }
    return pack;
  }
  get crudLoadValidationMandatoryStores() {
    return [this._eventStore.storeId, this._resourceStore.storeId];
  }
};
_defineProperty(CrudManager$1, "$name", "CrudManager");
CrudManager$1._$name = "CrudManager";
var ViewPreset = class extends Model {
  static get fields() {
    return [
      {
        name: "base",
        type: "string"
      },
      {
        name: "name",
        type: "string"
      },
      {
        name: "rowHeight",
        defaultValue: 24
      },
      {
        name: "tickWidth",
        defaultValue: 50
      },
      {
        name: "tickHeight",
        defaultValue: 50
      },
      {
        name: "displayDateFormat",
        defaultValue: "HH:mm"
      },
      {
        name: "shiftUnit",
        defaultValue: "hour"
      },
      {
        name: "shiftIncrement",
        defaultValue: 1
      },
      {
        name: "defaultSpan",
        defaultValue: 12
      },
      {
        name: "mainUnit"
      },
      {
        name: "start"
      },
      "timeResolution",
      "headers",
      "mainHeaderLevel",
      "columnLinesFor"
    ];
  }
  construct() {
    super.construct(...arguments);
    this.normalizeUnits();
  }
  generateId(owner) {
    const me = this, {
      headers
    } = me, parts = [];
    let result = Object.getPrototypeOf(me.data).id;
    if (!result) {
      for (let {
        length
      } = headers, i = length - 1; i >= 0; i--) {
        const {
          unit,
          increment
        } = headers[i], multiple = increment > 1;
        parts.push(`${multiple ? increment : ""}${i ? unit : StringHelper.capitalize(unit)}${multiple ? "s" : ""}`);
      }
      result = parts.join("And");
    }
    if (owner.count && owner.includes(result)) {
      result += `-${me.tickWidth}by${me.tickHeight || me.tickWidth}`;
      if (owner.includes(result)) {
        result += `-${me.bottomHeader.increment}`;
        if (owner.includes(result)) {
          result = IdHelper.generateId(`${result}-`);
        }
      }
    }
    return result;
  }
  normalizeUnits() {
    const me = this, {
      timeResolution,
      headers,
      shiftUnit
    } = me;
    if (headers) {
      for (let i = 0, {
        length
      } = headers; i < length; i++) {
        const header = headers[i];
        header.unit = DateHelper.normalizeUnit(header.unit);
        if (header.splitUnit) {
          header.splitUnit = DateHelper.normalizeUnit(header.splitUnit);
        }
        if (!("increment" in header)) {
          headers[i] = Object.assign({
            increment: 1
          }, header);
        }
      }
    }
    if (timeResolution) {
      timeResolution.unit = DateHelper.normalizeUnit(timeResolution.unit);
    }
    if (shiftUnit) {
      me.shiftUnit = DateHelper.normalizeUnit(shiftUnit);
    }
  }
  static normalizeHeaderConfig(data) {
    const {
      headerConfig,
      columnLinesFor,
      mainHeaderLevel
    } = data, headers = data.headers = [];
    if (headerConfig.top) {
      if (columnLinesFor === "top") {
        data.columnLinesFor = 0;
      }
      if (mainHeaderLevel === "top") {
        data.mainHeaderLevel = 0;
      }
      headers[0] = headerConfig.top;
    }
    if (headerConfig.middle) {
      if (columnLinesFor === "middle") {
        data.columnLinesFor = headers.length;
      }
      if (mainHeaderLevel === "middle") {
        data.mainHeaderLevel = headers.length;
      }
      headers.push(headerConfig.middle);
    } else {
      throw new Error("ViewPreset.headerConfig must be configured with a middle");
    }
    if (headerConfig.bottom) {
      data.mainHeaderLevel = headers.length - 1;
      if (columnLinesFor == null) {
        data.columnLinesFor = headers.length - 1;
      } else if (columnLinesFor === "bottom") {
        data.columnLinesFor = headers.length;
      }
      if (mainHeaderLevel == null) {
        data.mainHeaderLevel = headers.length - 1;
      }
      if (mainHeaderLevel === "bottom") {
        data.mainHeaderLevel = headers.length;
      }
      headers.push(headerConfig.bottom);
    }
  }
  set() {
  }
  inSet() {
  }
  get columnLinesFor() {
    return "columnLinesFor" in this.data ? this.data.columnLinesFor : this.headers.length - 1;
  }
  get tickSize() {
    return this._tickSize || this.tickWidth;
  }
  get tickWidth() {
    return "tickWidth" in this.data ? this.data.tickWidth : 50;
  }
  get tickHeight() {
    return "tickHeight" in this.data ? this.data.tickHeight : 50;
  }
  get headerConfig() {
    if (this.data.headerConfig) {
      return this.data.headerConfig;
    }
    const result = {}, {
      headers
    } = this, {
      length
    } = headers;
    switch (length) {
      case 1:
        result.middle = headers[0];
        break;
      case 2:
        if (this.mainHeaderLevel === 0) {
          result.middle = headers[0];
          result.bottom = headers[1];
        } else {
          result.top = headers[0];
          result.middle = headers[1];
        }
        break;
      case 3:
        result.top = headers[0];
        result.middle = headers[1];
        result.bottom = headers[2];
        break;
      default:
        throw new Error("headerConfig object not supported for >3 header levels");
    }
    return result;
  }
  set mainHeaderLevel(mainHeaderLevel) {
    this.data.mainHeaderLevel = mainHeaderLevel;
  }
  get mainHeaderLevel() {
    if ("mainHeaderLevel" in this.data) {
      return this.data.mainHeaderLevel;
    }
    if (this.data.headers.length === 3) {
      return 1;
    }
    return this.headers.length - 1;
  }
  get mainHeader() {
    return this.headers[this.mainHeaderLevel];
  }
  get bottomHeader() {
    return this.headers[this.headers.length - 1];
  }
  get leafUnit() {
    return this.bottomHeader.unit;
  }
  get leafIncrement() {
    return this.bottomHeader.increment;
  }
  get mainUnit() {
    if ("mainUnit" in this.data) {
      return this.data.mainUnit;
    }
    return this.mainHeader.unit;
  }
  get msPerPixel() {
    const {
      bottomHeader
    } = this;
    return Math.round(DateHelper.asMilliseconds(bottomHeader.increment || 1, bottomHeader.unit) / this.tickWidth);
  }
  get isValid() {
    const me = this;
    let valid = true;
    for (const header of me.headers) {
      valid = valid && Boolean(DateHelper.normalizeUnit(header.unit));
    }
    if (me.timeResolution) {
      valid = valid && DateHelper.normalizeUnit(me.timeResolution.unit);
    }
    if (me.shiftUnit) {
      valid = valid && DateHelper.normalizeUnit(me.shiftUnit);
    }
    return valid;
  }
};
_defineProperty(ViewPreset, "$name", "ViewPreset");
ViewPreset._$name = "ViewPreset";
var locale$1 = {
  localeName: "En",
  localeDesc: "English (US)",
  localeCode: "en-US",
  Object: {
    newEvent: "New event"
  },
  ResourceInfoColumn: {
    eventCountText: (data) => data + " event" + (data !== 1 ? "s" : "")
  },
  Dependencies: {
    from: "From",
    to: "To",
    valid: "Valid",
    invalid: "Invalid"
  },
  DependencyType: {
    SS: "SS",
    SF: "SF",
    FS: "FS",
    FF: "FF",
    StartToStart: "Start-to-Start",
    StartToEnd: "Start-to-Finish",
    EndToStart: "Finish-to-Start",
    EndToEnd: "Finish-to-Finish",
    short: ["SS", "SF", "FS", "FF"],
    long: ["Start-to-Start", "Start-to-Finish", "Finish-to-Start", "Finish-to-Finish"]
  },
  DependencyEdit: {
    From: "From",
    To: "To",
    Type: "Type",
    Lag: "Lag",
    "Edit dependency": "Edit dependency",
    Save: "Save",
    Delete: "Delete",
    Cancel: "Cancel",
    StartToStart: "Start to Start",
    StartToEnd: "Start to End",
    EndToStart: "End to Start",
    EndToEnd: "End to End"
  },
  EventEdit: {
    Name: "Name",
    Resource: "Resource",
    Start: "Start",
    End: "End",
    Save: "Save",
    Delete: "Delete",
    Cancel: "Cancel",
    "Edit event": "Edit event",
    Repeat: "Repeat"
  },
  EventDrag: {
    eventOverlapsExisting: "Event overlaps existing event for this resource",
    noDropOutsideTimeline: "Event may not be dropped completely outside the timeline"
  },
  SchedulerBase: {
    "Add event": "Add event",
    "Delete event": "Delete event",
    "Unassign event": "Unassign event"
  },
  TimeAxisHeaderMenu: {
    pickZoomLevel: "Zoom",
    activeDateRange: "Date range",
    startText: "Start date",
    endText: "End date",
    todayText: "Today"
  },
  EventCopyPaste: {
    copyEvent: "Copy event",
    cutEvent: "Cut event",
    pasteEvent: "Paste event"
  },
  EventFilter: {
    filterEvents: "Filter tasks",
    byName: "By name"
  },
  TimeRanges: {
    showCurrentTimeLine: "Show current timeline"
  },
  PresetManager: {
    secondAndMinute: {
      displayDateFormat: "ll LTS",
      name: "Seconds"
    },
    minuteAndHour: {
      topDateFormat: "ddd MM/DD, hA",
      displayDateFormat: "ll LST"
    },
    hourAndDay: {
      topDateFormat: "ddd MM/DD",
      middleDateFormat: "LST",
      displayDateFormat: "ll LST",
      name: "Day"
    },
    day: {
      name: "Day/hours"
    },
    week: {
      name: "Week/hours"
    },
    dayAndWeek: {
      displayDateFormat: "ll LST",
      name: "Week/days"
    },
    dayAndMonth: {
      name: "Month"
    },
    weekAndDay: {
      displayDateFormat: "ll LST",
      name: "Week"
    },
    weekAndMonth: {
      name: "Weeks"
    },
    weekAndDayLetter: {
      name: "Weeks/weekdays"
    },
    weekDateAndMonth: {
      name: "Months/weeks"
    },
    monthAndYear: {
      name: "Months"
    },
    year: {
      name: "Years"
    },
    manyYears: {
      name: "Multiple years"
    }
  },
  RecurrenceConfirmationPopup: {
    "delete-title": "You are deleting an event",
    "delete-all-message": "Do you want to delete all occurrences of this event?",
    "delete-further-message": "Do you want to delete this and all future occurrences of this event, or only the selected occurrence?",
    "delete-further-btn-text": "Delete All Future Events",
    "delete-only-this-btn-text": "Delete Only This Event",
    "update-title": "You are changing a repeating event",
    "update-all-message": "Do you want to change all occurrences of this event?",
    "update-further-message": "Do you want to change only this occurrence of the event, or this and all future occurrences?",
    "update-further-btn-text": "All Future Events",
    "update-only-this-btn-text": "Only This Event",
    Yes: "Yes",
    Cancel: "Cancel",
    width: 600
  },
  RecurrenceLegend: {
    " and ": " and ",
    Daily: "Daily",
    "Weekly on {1}": ({
      days: days2
    }) => `Weekly on ${days2}`,
    "Monthly on {1}": ({
      days: days2
    }) => `Monthly on ${days2}`,
    "Yearly on {1} of {2}": ({
      days: days2,
      months
    }) => `Yearly on ${days2} of ${months}`,
    "Every {0} days": ({
      interval
    }) => `Every ${interval} days`,
    "Every {0} weeks on {1}": ({
      interval,
      days: days2
    }) => `Every ${interval} weeks on ${days2}`,
    "Every {0} months on {1}": ({
      interval,
      days: days2
    }) => `Every ${interval} months on ${days2}`,
    "Every {0} years on {1} of {2}": ({
      interval,
      days: days2,
      months
    }) => `Every ${interval} years on ${days2} of ${months}`,
    position1: "the first",
    position2: "the second",
    position3: "the third",
    position4: "the fourth",
    position5: "the fifth",
    "position-1": "the last",
    day: "day",
    weekday: "weekday",
    "weekend day": "weekend day",
    daysFormat: ({
      position,
      days: days2
    }) => `${position} ${days2}`
  },
  RecurrenceEditor: {
    "Repeat event": "Repeat event",
    Cancel: "Cancel",
    Save: "Save",
    Frequency: "Frequency",
    Every: "Every",
    DAILYintervalUnit: "day(s)",
    WEEKLYintervalUnit: "week(s)",
    MONTHLYintervalUnit: "month(s)",
    YEARLYintervalUnit: "year(s)",
    Each: "Each",
    "On the": "On the",
    "End repeat": "End repeat",
    "time(s)": "time(s)"
  },
  RecurrenceDaysCombo: {
    day: "day",
    weekday: "weekday",
    "weekend day": "weekend day"
  },
  RecurrencePositionsCombo: {
    position1: "first",
    position2: "second",
    position3: "third",
    position4: "fourth",
    position5: "fifth",
    "position-1": "last"
  },
  RecurrenceStopConditionCombo: {
    Never: "Never",
    After: "After",
    "On date": "On date"
  },
  RecurrenceFrequencyCombo: {
    None: "No repeat",
    Daily: "Daily",
    Weekly: "Weekly",
    Monthly: "Monthly",
    Yearly: "Yearly"
  },
  RecurrenceCombo: {
    None: "None",
    Custom: "Custom..."
  },
  Summary: {
    "Summary for": (date2) => `Summary for ${date2}`
  },
  ScheduleRangeCombo: {
    completeview: "Complete schedule",
    currentview: "Visible schedule",
    daterange: "Date range",
    completedata: "Complete schedule (for all events)"
  },
  SchedulerExportDialog: {
    "Schedule range": "Schedule range",
    "Export from": "From",
    "Export to": "To"
  },
  ExcelExporter: {
    "No resource assigned": "No resource assigned"
  },
  CrudManagerView: {
    serverResponseLabel: "Server response:"
  },
  DurationColumn: {
    Duration: "Duration"
  }
};
LocaleHelper.publishLocale(locale$1);
var PresetStore = class extends Localizable(Store) {
  static get $name() {
    return "PresetStore";
  }
  static get defaultConfig() {
    return {
      useRawData: true,
      modelClass: ViewPreset,
      zoomOrder: 1
    };
  }
  set storage(storage) {
    super.storage = storage;
    this.storage.addSorter((lhs, rhs) => {
      const leftBottomHeader = lhs.bottomHeader, rightBottomHeader = rhs.bottomHeader;
      const order = rhs.msPerPixel - lhs.msPerPixel || unitMagnitudes[leftBottomHeader.unit] - unitMagnitudes[rightBottomHeader.unit] || leftBottomHeader.increment - rightBottomHeader.increment;
      return order * this.zoomOrder;
    });
  }
  get storage() {
    return super.storage;
  }
  getById(id) {
    return super.getById(id) || !this.isPresetManager && pm.getById(id);
  }
  createRecord(data, ...args) {
    let result;
    if (data.isViewPreset) {
      return data;
    }
    if (typeof data === "string") {
      result = this.getById(data);
    } else if (typeof data === "number") {
      result = this.getAt(data);
    } else {
      if (data.base) {
        data = this.copyBaseValues(data);
      }
      return super.createRecord(data, ...args);
    }
    if (!result) {
      throw new Error(`ViewPreset ${data} does not exist`);
    }
    return result;
  }
  updateLocalization() {
    super.updateLocalization();
    const me = this;
    let presets = me.allRecords;
    if (me.isPresetManager) {
      presets = new Set(presets.concat(Object.values(me.basePresets)));
    }
    presets.forEach((preset) => {
      let localePreset = me.optionalL(`L{PresetManager.${preset.id}}`, null, true);
      if (typeof localePreset === "string" && preset.baseId) {
        localePreset = me.optionalL(`L{PresetManager.${preset.baseId}}`, null, true);
      }
      if (localePreset && typeof localePreset === "object") {
        if (!preset.originalDisplayDateFormat) {
          preset.originalDisplayDateFormat = preset.displayDateFormat;
        }
        if (preset.mainHeaderLevel === 0 && localePreset.topDateFormat) {
          localePreset.middleDateFormat = localePreset.middleDateFormat || localePreset.topDateFormat;
        }
        preset.setData("displayDateFormat", localePreset.displayDateFormat || preset.originalDisplayDateFormat);
        ["top", "middle", "bottom"].forEach((level) => {
          const levelConfig = preset.headerConfig[level], localeLevelDateFormat = localePreset[level + "DateFormat"];
          if (levelConfig) {
            if (!levelConfig.originalDateFormat) {
              levelConfig.originalDateFormat = levelConfig.dateFormat;
            }
            if (localeLevelDateFormat && levelConfig.renderer) {
              levelConfig.renderer = null;
            }
            levelConfig.dateFormat = localeLevelDateFormat || levelConfig.originalDateFormat;
          }
        });
        if (localePreset.name) {
          if (!preset.unlocalizedName) {
            preset.unlocalizedName = preset.name;
          }
          preset.setData("name", localePreset.name);
        } else if (preset.unlocalizedName && preset.unlocalizedName !== preset.name) {
          preset.name = preset.unlocalizedName;
          preset.unlocalizedName = null;
        }
      }
    });
  }
  getCurrentConfig(options) {
    return super.getCurrentConfig(options).data;
  }
  copyBaseValues(presetData) {
    let base = this.getById(presetData.base);
    if (!base) {
      throw new Error(`ViewPreset base '${presetData.base}' does not exist.`);
    }
    base = ObjectHelper.clone(base.data);
    delete base.id;
    delete base.name;
    return ObjectHelper.merge(base, presetData);
  }
  add(preset) {
    preset = Array.isArray(preset) ? preset : [preset];
    preset.forEach((preset2) => {
      if (preset2.isViewPreset && preset2.base) {
        preset2.data = this.copyBaseValues(preset2.originalData);
      }
    });
    return super.add(...arguments);
  }
};
PresetStore._$name = "PresetStore";
var PresetManager = class extends PresetStore {
  static get $name() {
    return "PresetManager";
  }
  static get defaultConfig() {
    return {
      preventSubClassingModel: true,
      basePresets: {
        secondAndMinute: {
          name: "Seconds",
          tickWidth: 30,
          tickHeight: 40,
          displayDateFormat: "ll LTS",
          shiftIncrement: 10,
          shiftUnit: "minute",
          defaultSpan: 24,
          timeResolution: {
            unit: "second",
            increment: 5
          },
          headers: [{
            unit: "minute",
            dateFormat: "llll"
          }, {
            unit: "second",
            increment: 10,
            dateFormat: "ss"
          }]
        },
        minuteAndHour: {
          name: "Minutes",
          tickWidth: 60,
          tickHeight: 60,
          displayDateFormat: "ll LT",
          shiftIncrement: 1,
          shiftUnit: "hour",
          defaultSpan: 24,
          timeResolution: {
            unit: "minute",
            increment: 30
          },
          headers: [{
            unit: "hour",
            dateFormat: "ddd MM/DD, hA"
          }, {
            unit: "minute",
            increment: 30,
            dateFormat: "mm"
          }]
        },
        hourAndDay: {
          name: "Day",
          tickWidth: 70,
          tickHeight: 40,
          displayDateFormat: "ll LT",
          shiftIncrement: 1,
          shiftUnit: "day",
          defaultSpan: 24,
          timeResolution: {
            unit: "minute",
            increment: 30
          },
          headers: [{
            unit: "day",
            dateFormat: "ddd DD/MM"
          }, {
            unit: "hour",
            dateFormat: "LT"
          }]
        },
        day: {
          name: "Day/hours",
          displayDateFormat: "LT",
          shiftIncrement: 1,
          shiftUnit: "day",
          defaultSpan: 1,
          timeResolution: {
            unit: "minute",
            increment: 30
          },
          mainHeaderLevel: 0,
          headers: [{
            unit: "day",
            dateFormat: "ddd DD/MM",
            splitUnit: "day"
          }, {
            unit: "hour",
            renderer(value) {
              return `
                                    <div class="b-sch-calendarcolumn-ct"><span class="b-sch-calendarcolumn-hours">${DateHelper.format(value, "HH")}</span>
                                    <span class="b-sch-calendarcolumn-minutes">${DateHelper.format(value, "mm")}</span></div>
                                `;
            }
          }]
        },
        week: {
          name: "Week/hours",
          displayDateFormat: "LT",
          shiftIncrement: 1,
          shiftUnit: "week",
          defaultSpan: 24,
          timeResolution: {
            unit: "minute",
            increment: 30
          },
          mainHeaderLevel: 0,
          headers: [{
            unit: "week",
            dateFormat: "D d",
            splitUnit: "day"
          }, {
            unit: "hour",
            dateFormat: "LT",
            renderer(value) {
              return `
                                    <div class="sch-calendarcolumn-ct">
                                    <span class="sch-calendarcolumn-hours">${DateHelper.format(value, "HH")}</span>
                                    <span class="sch-calendarcolumn-minutes">${DateHelper.format(value, "mm")}</span>
                                    </div>
                                `;
            }
          }]
        },
        dayAndWeek: {
          name: "Days & Weeks",
          tickWidth: 100,
          tickHeight: 80,
          displayDateFormat: "ll LT",
          shiftUnit: "day",
          shiftIncrement: 1,
          defaultSpan: 5,
          timeResolution: {
            unit: "hour",
            increment: 1
          },
          headers: [{
            unit: "week",
            renderer(start) {
              return DateHelper.getShortNameOfUnit("week") + "." + DateHelper.format(start, "WW MMM YYYY");
            }
          }, {
            unit: "day",
            dateFormat: "dd DD"
          }]
        },
        dayAndMonth: {
          name: "Month",
          tickWidth: 100,
          tickHeight: 80,
          displayDateFormat: "ll LT",
          shiftUnit: "month",
          shiftIncrement: 1,
          defaultSpan: 1,
          mainUnit: "month",
          timeResolution: {
            unit: "hour",
            increment: 1
          },
          headers: [{
            unit: "month",
            dateFormat: "MMMM YYYY"
          }, {
            unit: "day",
            dateFormat: "DD"
          }]
        },
        weekAndDay: {
          name: "Week",
          tickWidth: 100,
          tickHeight: 80,
          displayDateFormat: "ll hh:mm A",
          shiftUnit: "week",
          shiftIncrement: 1,
          defaultSpan: 1,
          timeResolution: {
            unit: "day",
            increment: 1
          },
          mainHeaderLevel: 0,
          headers: [{
            unit: "week",
            dateFormat: "YYYY MMMM DD"
          }, {
            unit: "day",
            increment: 1,
            dateFormat: "DD MMM"
          }]
        },
        weekAndMonth: {
          name: "Weeks",
          tickWidth: 100,
          tickHeight: 105,
          displayDateFormat: "ll",
          shiftUnit: "week",
          shiftIncrement: 5,
          defaultSpan: 6,
          timeResolution: {
            unit: "day",
            increment: 1
          },
          headers: [{
            unit: "month",
            dateFormat: "MMM YYYY"
          }, {
            unit: "week",
            dateFormat: "DD MMM"
          }]
        },
        weekAndDayLetter: {
          name: "Weeks/weekdays",
          tickWidth: 20,
          tickHeight: 50,
          displayDateFormat: "ll",
          shiftUnit: "week",
          shiftIncrement: 1,
          defaultSpan: 10,
          timeResolution: {
            unit: "day",
            increment: 1
          },
          mainHeaderLevel: 0,
          headers: [{
            unit: "week",
            dateFormat: "ddd DD MMM YYYY",
            verticalColumnWidth: 115
          }, {
            unit: "day",
            dateFormat: "d1",
            verticalColumnWidth: 25
          }]
        },
        weekDateAndMonth: {
          name: "Months/weeks",
          tickWidth: 30,
          tickHeight: 40,
          displayDateFormat: "ll",
          shiftUnit: "week",
          shiftIncrement: 1,
          defaultSpan: 10,
          timeResolution: {
            unit: "day",
            increment: 1
          },
          headers: [{
            unit: "month",
            dateFormat: "YYYY MMMM"
          }, {
            unit: "week",
            dateFormat: "DD"
          }]
        },
        monthAndYear: {
          name: "Months",
          tickWidth: 110,
          tickHeight: 110,
          displayDateFormat: "ll",
          shiftIncrement: 3,
          shiftUnit: "month",
          defaultSpan: 12,
          timeResolution: {
            unit: "day",
            increment: 1
          },
          headers: [{
            unit: "year",
            dateFormat: "YYYY"
          }, {
            unit: "month",
            dateFormat: "MMM YYYY"
          }]
        },
        year: {
          name: "Years",
          tickWidth: 100,
          tickHeight: 100,
          resourceColumnWidth: 100,
          displayDateFormat: "ll",
          shiftUnit: "year",
          shiftIncrement: 1,
          defaultSpan: 1,
          timeResolution: {
            unit: "month",
            increment: 1
          },
          headers: [{
            unit: "year",
            dateFormat: "YYYY"
          }, {
            unit: "quarter",
            renderer(start, end, cfg) {
              return DateHelper.getShortNameOfUnit("quarter").toUpperCase() + (Math.floor(start.getMonth() / 3) + 1);
            }
          }]
        },
        manyYears: {
          name: "Multiple years",
          tickWidth: 40,
          tickHeight: 50,
          displayDateFormat: "ll",
          shiftUnit: "year",
          shiftIncrement: 1,
          defaultSpan: 10,
          timeResolution: {
            unit: "year",
            increment: 1
          },
          mainHeaderLevel: 0,
          headers: [{
            unit: "year",
            increment: 5,
            renderer: (start, end) => start.getFullYear() + " - " + end.getFullYear()
          }, {
            unit: "year",
            dateFormat: "YY",
            increment: 1
          }]
        }
      },
      defaultPresets: [
        "manyYears",
        {
          width: 80,
          increment: 1,
          resolution: 1,
          base: "manyYears",
          resolutionUnit: "YEAR"
        },
        "year",
        {
          width: 30,
          increment: 1,
          resolution: 1,
          base: "year",
          resolutionUnit: "MONTH"
        },
        {
          width: 50,
          increment: 1,
          resolution: 1,
          base: "year",
          resolutionUnit: "MONTH"
        },
        {
          width: 200,
          increment: 1,
          resolution: 1,
          base: "year",
          resolutionUnit: "MONTH"
        },
        "monthAndYear",
        "weekDateAndMonth",
        "weekAndMonth",
        "weekAndDayLetter",
        "dayAndMonth",
        "weekAndDay",
        {
          width: 54,
          increment: 1,
          resolution: 1,
          base: "weekAndDay",
          resolutionUnit: "HOUR"
        },
        "hourAndDay",
        {
          width: 64,
          increment: 6,
          resolution: 30,
          base: "hourAndDay",
          resolutionUnit: "MINUTE"
        },
        {
          width: 100,
          increment: 6,
          resolution: 30,
          base: "hourAndDay",
          resolutionUnit: "MINUTE"
        },
        {
          width: 64,
          increment: 2,
          resolution: 30,
          base: "hourAndDay",
          resolutionUnit: "MINUTE"
        },
        "minuteAndHour",
        {
          width: 30,
          increment: 15,
          resolution: 5,
          base: "minuteAndHour"
        },
        {
          width: 130,
          increment: 15,
          resolution: 5,
          base: "minuteAndHour"
        },
        {
          width: 60,
          increment: 5,
          resolution: 5,
          base: "minuteAndHour"
        },
        {
          width: 100,
          increment: 5,
          resolution: 5,
          base: "minuteAndHour"
        },
        "secondAndMinute",
        {
          width: 60,
          increment: 10,
          resolution: 5,
          base: "secondAndMinute"
        },
        {
          width: 130,
          increment: 5,
          resolution: 5,
          base: "secondAndMinute"
        }
      ],
      internalListeners: {
        locale: "updateLocalization"
      }
    };
  }
  set basePresets(basePresets) {
    const presetCache = this._basePresets = {};
    for (const id in basePresets) {
      basePresets[id].id = id;
      presetCache[id] = this.createRecord(basePresets[id]);
    }
  }
  get basePresets() {
    return this._basePresets;
  }
  set defaultPresets(defaultPresets) {
    for (let i = 0, {
      length
    } = defaultPresets; i < length; i++) {
      const presetAdjustment = defaultPresets[i], isBase = typeof presetAdjustment === "string", baseType = isBase ? presetAdjustment : presetAdjustment.base;
      let preset;
      if (isBase) {
        preset = this.basePresets[baseType];
      } else {
        const config = Object.setPrototypeOf(ObjectHelper.clone(this.basePresets[baseType].data), {
          id: baseType
        }), {
          timeResolution
        } = config, bottomHeader = config.headers[config.headers.length - 1];
        config.id = void 0;
        if ("width" in presetAdjustment) {
          config.tickWidth = presetAdjustment.width;
        }
        if ("height" in presetAdjustment) {
          config.tickHeight = presetAdjustment.height;
        }
        if ("increment" in presetAdjustment) {
          bottomHeader.increment = presetAdjustment.increment;
        }
        if ("resolution" in presetAdjustment) {
          timeResolution.increment = presetAdjustment.resolution;
        }
        if ("resolutionUnit" in presetAdjustment) {
          timeResolution.unit = DateHelper.getUnitByName(presetAdjustment.resolutionUnit);
        }
        preset = this.createRecord(config);
        preset.baseId = baseType;
      }
      this.add(preset);
    }
  }
  getById(id) {
    return super.getById(id) || this.basePresets[id];
  }
  registerPreset(id, config) {
    const preset = this.createRecord(Object.assign({
      id
    }, config)), existingDuplicate = this.find((p) => p.equals(preset));
    if (existingDuplicate) {
      return existingDuplicate;
    }
    if (preset.isValid) {
      this.add(preset);
    } else {
      throw new Error("Invalid preset, please check your configuration");
    }
    return preset;
  }
  getPreset(preset) {
    if (typeof preset === "number") {
      preset = this.getAt(preset);
    }
    if (typeof preset === "string") {
      preset = this.getById(preset);
    } else if (!(preset instanceof ViewPreset)) {
      preset = this.createRecord(preset);
    }
    return preset;
  }
  normalizePreset(preset) {
    const me = this;
    if (!(preset instanceof ViewPreset)) {
      if (typeof preset === "string") {
        preset = me.getPreset(preset);
        if (!preset) {
          throw new Error("You must define a valid view preset. See PresetManager for reference");
        }
      } else if (typeof preset === "object") {
        if (preset.base) {
          const base = this.getById(preset.base);
          if (!base) {
            throw new Error(`ViewPreset base '${preset.base}' does not exist`);
          }
          preset = ObjectHelper.merge(ObjectHelper.clone(base.data), preset);
        }
        if (preset.id) {
          preset = me.createRecord(preset);
        } else {
          preset = me.createRecord(ObjectHelper.assign({}, preset));
          preset.id = preset.generateId(preset);
        }
      }
    }
    return preset;
  }
  deletePreset(presetOrId) {
    if (typeof presetOrId === "string") {
      presetOrId = this.getById(presetOrId);
    } else if (typeof presetOrId === "number") {
      presetOrId = this.getAt(presetOrId);
    }
    if (presetOrId) {
      this.remove(presetOrId);
      delete this.basePresets[presetOrId.id];
    }
  }
};
var pm = new PresetManager();
var Tick = class extends TimeSpan {
  get startDate() {
    return this.data.startDate;
  }
  get endDate() {
    return this.data.endDate;
  }
};
var TimeAxis = class extends Store {
  static get defaultConfig() {
    return {
      modelClass: Tick,
      continuous: true,
      originalContinuous: null,
      include: null,
      autoAdjust: true,
      adjustedStart: null,
      adjustedEnd: null,
      visibleTickStart: null,
      visibleTickEnd: null,
      tickCache: {},
      viewPreset: null,
      useRawData: {
        disableDuplicateIdCheck: true,
        disableDefaultValue: true,
        disableTypeConversion: true
      }
    };
  }
  static get configurable() {
    return {
      generateTicks: null,
      unit: null,
      increment: null,
      resolutionUnit: null,
      resolutionIncrement: null,
      mainUnit: null,
      shiftUnit: null,
      shiftIncrement: 1,
      defaultSpan: 1,
      weekStartDay: null,
      forceFullTicks: null
    };
  }
  construct(config) {
    const me = this;
    super.construct(config);
    me.originalContinuous = me.continuous;
    me.ion({
      change: ({
        action
      }) => {
        if (action !== "filter") {
          me.trigger("reconfigure", {
            supressRefresh: false
          });
        }
      },
      refresh: () => me.trigger("reconfigure", {
        supressRefresh: false
      }),
      endreconfigure: (event) => me.trigger("reconfigure", event)
    });
    if (me.startDate) {
      me.internalOnReconfigure();
      me.trigger("reconfigure");
    } else if (me.viewPreset) {
      const range = me.getAdjustedDates(new Date());
      me.startDate = range.startDate;
      me.endDate = range.endDate;
    }
  }
  get isTimeAxis() {
    return true;
  }
  reconfigure(config, suppressRefresh = false, preventThrow = false) {
    const me = this, normalized = me.getAdjustedDates(config.startDate, config.endDate), oldConfig = {};
    if (me.trigger("beforeReconfigure", {
      startDate: normalized.startDate,
      endDate: normalized.endDate,
      config
    }) !== false) {
      me.trigger("beginReconfigure");
      me._configuredStartDate = config.startDate;
      me._configuredEndDate = config.endDate;
      for (const propName in config) {
        oldConfig[propName] = me[propName];
      }
      Object.assign(me, config);
      if (me.internalOnReconfigure(preventThrow) === false) {
        return false;
      }
      me.trigger("endReconfigure", {
        suppressRefresh,
        config,
        oldConfig
      });
    }
  }
  internalOnReconfigure(preventThrow = false) {
    const me = this;
    me.isConfigured = true;
    const adjusted = me.getAdjustedDates(me.startDate, me.endDate, true), normalized = me.getAdjustedDates(me.startDate, me.endDate), start = normalized.startDate, end = normalized.endDate;
    if (start >= end) {
      throw new Error(`Invalid start/end dates. Start date must less than end date. Start date: ${start}. End date: ${end}.`);
    }
    const {
      unit,
      increment = 1
    } = me, ticks = me.generateTicks(start, end, unit, increment);
    me.suspendEvents();
    me.data = ticks;
    const {
      count
    } = me;
    if (count === 0) {
      if (preventThrow) {
        me.resumeEvents();
        return false;
      }
      throw new Error("Invalid time axis configuration or filter, please check your input data.");
    }
    me.startDate = me.first.startDate;
    me.endDate = me.last.endDate;
    me.resumeEvents();
    if (me.isContinuous) {
      me.adjustedStart = adjusted.startDate;
      me.adjustedEnd = DateHelper.getNext(count > 1 ? ticks[count - 1].startDate : adjusted.startDate, unit, increment, me.weekStartDay);
    } else {
      me.adjustedStart = me.startDate;
      me.adjustedEnd = me.endDate;
    }
    me.updateVisibleTickBoundaries();
    me.updateTickCache(true);
  }
  updateVisibleTickBoundaries() {
    const me = this, {
      count,
      unit,
      startDate,
      endDate,
      weekStartDay,
      increment = 1
    } = me;
    const startDenominator = DateHelper.getNormalizedUnitDuration(startDate, unit) * increment, endDenominator = DateHelper.getNormalizedUnitDuration(endDate, unit) * increment;
    do {
      me.visibleTickStart = (startDate - me.adjustedStart) / startDenominator;
      if (me.autoAdjust)
        me.visibleTickStart = Math.floor(me.visibleTickStart);
      if (me.visibleTickStart >= 1)
        me.adjustedStart = DateHelper.getNext(me.adjustedStart, unit, increment, weekStartDay);
    } while (me.visibleTickStart >= 1);
    do {
      me.visibleTickEnd = count - (me.adjustedEnd - endDate) / endDenominator;
      if (count - me.visibleTickEnd >= 1)
        me.adjustedEnd = DateHelper.getNext(me.adjustedEnd, unit, -1, weekStartDay);
    } while (count - me.visibleTickEnd >= 1);
    me.fullTicks = !me.visibleTickStart && me.visibleTickEnd === count;
  }
  get viewPreset() {
    return this._viewPreset;
  }
  set viewPreset(preset) {
    const me = this;
    preset = pm.getPreset(preset);
    if (!(preset instanceof ViewPreset)) {
      throw new Error("TimeAxis must be configured with the ViewPreset instance that the Scheduler is using");
    }
    me._viewPreset = preset;
    Object.assign(me, {
      unit: preset.bottomHeader.unit,
      increment: preset.bottomHeader.increment || 1,
      resolutionUnit: preset.timeResolution.unit,
      resolutionIncrement: preset.timeResolution.increment,
      mainUnit: preset.mainHeader.unit,
      shiftUnit: preset.shiftUnit || preset.mainHeader.unit,
      shiftIncrement: preset.shiftIncrement || 1,
      defaultSpan: preset.defaultSpan || 1,
      presetName: preset.id,
      headers: preset.headers
    });
  }
  get weekStartDay() {
    var _this$_weekStartDay;
    return (_this$_weekStartDay = this._weekStartDay) !== null && _this$_weekStartDay !== void 0 ? _this$_weekStartDay : DateHelper.weekStartDay;
  }
  get resolution() {
    return {
      unit: this.resolutionUnit,
      increment: this.resolutionIncrement
    };
  }
  set resolution(resolution) {
    this.resolutionUnit = resolution.unit;
    this.resolutionIncrement = resolution.increment;
  }
  get resolutionUnit() {
    return this.forceFullTicks ? this.unit : this._resolutionUnit;
  }
  get resolutionIncrement() {
    return this.forceFullTicks ? this.increment : this._resolutionIncrement;
  }
  setTimeSpan(newStartDate, newEndDate, preventThrow = false) {
    if (newEndDate && newStartDate - newEndDate === 0) {
      newEndDate = null;
    }
    const me = this, {
      startDate,
      endDate
    } = me.getAdjustedDates(newStartDate, newEndDate);
    if (me.startDate - startDate !== 0 || me.endDate - endDate !== 0) {
      return me.reconfigure({
        startDate,
        endDate
      }, false, preventThrow);
    }
  }
  shift(amount, unit = this.shiftUnit) {
    const me = this;
    let {
      startDate,
      endDate
    } = me;
    if (me.isFiltered) {
      startDate = me.allRecords[0].startDate;
      endDate = me.allRecords[me.allCount - 1].endDate;
    }
    let tries = 0;
    do {
      startDate = DateHelper.add(startDate, amount, unit);
      endDate = DateHelper.add(endDate, amount, unit);
    } while (tries++ < 100 && me.setTimeSpan(startDate, endDate, {
      preventThrow: true
    }) === false);
  }
  shiftNext(amount = this.shiftIncrement) {
    this.shift(amount);
  }
  shiftPrevious(amount = this.shiftIncrement) {
    this.shift(-amount);
  }
  filterBy(fn2, thisObj = this) {
    const me = this;
    me.filters.clear();
    super.filterBy((tick, index) => fn2.call(thisObj, tick.data, index));
    if (me.count === 0) {
      me.trigger("invalidFilter");
      me.clearFilters();
    }
  }
  triggerFilterEvent(event) {
    const me = this;
    if (!event.filters.count) {
      me.continuous = me.originalContinuous;
    } else {
      me.continuous = false;
    }
    me.updateTickCache();
    super.triggerFilterEvent(event);
  }
  get isContinuous() {
    return this.continuous !== false && !this.isFiltered;
  }
  getAdjustedDates(startDate, endDate, forceAdjust = false) {
    const me = this;
    if (endDate && startDate - endDate === 0) {
      endDate = null;
    }
    startDate = startDate || me.startDate;
    endDate = endDate || DateHelper.add(startDate, me.defaultSpan, me.mainUnit);
    return me.autoAdjust || forceAdjust ? {
      startDate: me.floorDate(startDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1),
      endDate: me.ceilDate(endDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1)
    } : {
      startDate,
      endDate
    };
  }
  get startDate() {
    return this._start || (this.first ? new Date(this.first.startDate) : null);
  }
  set startDate(start) {
    this._start = DateHelper.parse(start);
  }
  get endDate() {
    return this._end || (this.last ? new Date(this.last.endDate) : null);
  }
  set endDate(end) {
    if (end)
      this._end = DateHelper.parse(end);
  }
  get startMS() {
    return this._startMS;
  }
  get endMS() {
    return this._endMS;
  }
  floorDate(date2, relativeToStart, resolutionUnit, incr) {
    relativeToStart = relativeToStart !== false;
    const me = this, relativeTo = relativeToStart ? DateHelper.clone(me.startDate) : null, increment = incr || me.resolutionIncrement, unit = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit), snap = (value, increment2) => Math.floor(value / increment2) * increment2;
    if (relativeToStart) {
      const snappedDuration = snap(DateHelper.diff(relativeTo, date2, unit), increment);
      return DateHelper.add(relativeTo, snappedDuration, unit, false);
    }
    const dt = DateHelper.clone(date2);
    if (unit === "week") {
      const day2 = dt.getDay() || 7, startDay = me.weekStartDay || 7;
      DateHelper.add(DateHelper.startOf(dt, "day", false), day2 >= startDay ? startDay - day2 : -(7 - startDay + day2), "day", false);
      if (dt.getDay() !== startDay && dt.getHours() === 23) {
        DateHelper.add(dt, 1, "hour", false);
      }
    } else {
      DateHelper.startOf(dt, unit, false);
      const modifier = ["day", "year"].includes(unit) ? 1 : 0, useUnit = unit === "day" ? "date" : unit, snappedValue = snap(DateHelper.get(dt, useUnit) - modifier, increment) + modifier;
      DateHelper.set(dt, useUnit, snappedValue);
    }
    return dt;
  }
  roundDate(date2, relativeTo, resolutionUnit = this.resolutionUnit, increment = this.resolutionIncrement || 1) {
    const me = this, dt = DateHelper.clone(date2);
    relativeTo = DateHelper.clone(relativeTo || me.startDate);
    switch (resolutionUnit) {
      case "week": {
        DateHelper.startOf(dt, "day", false);
        let distanceToWeekStartDay = dt.getDay() - me.weekStartDay, toAdd;
        if (distanceToWeekStartDay < 0) {
          distanceToWeekStartDay = 7 + distanceToWeekStartDay;
        }
        if (Math.round(distanceToWeekStartDay / 7) === 1) {
          toAdd = 7 - distanceToWeekStartDay;
        } else {
          toAdd = -distanceToWeekStartDay;
        }
        return DateHelper.add(dt, toAdd, "day", false);
      }
      case "month": {
        const nbrMonths = DateHelper.diff(relativeTo, dt, "month") + DateHelper.as("month", dt.getDay() / DateHelper.daysInMonth(dt)), snappedMonths = Math.round(nbrMonths / increment) * increment;
        return DateHelper.add(relativeTo, snappedMonths, "month", false);
      }
      case "quarter":
        DateHelper.startOf(dt, "month", false);
        return DateHelper.add(dt, 3 - dt.getMonth() % 3, "month", false);
      default: {
        const duration = DateHelper.as(resolutionUnit, DateHelper.diff(relativeTo, dt)), offset = DateHelper.as(resolutionUnit, relativeTo.getTimezoneOffset() - dt.getTimezoneOffset(), "minute"), snappedDuration = Math.round((duration + offset) / increment) * increment;
        return DateHelper.add(relativeTo, snappedDuration - offset, resolutionUnit, false);
      }
    }
  }
  ceilDate(date2, relativeToStart, resolutionUnit, increment) {
    const me = this;
    relativeToStart = relativeToStart !== false;
    increment = increment || (relativeToStart ? me.resolutionIncrement : 1);
    const unit = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit), dt = DateHelper.clone(date2);
    let doCall = false;
    switch (unit) {
      case "minute":
        doCall = !DateHelper.isStartOf(dt, "minute");
        break;
      case "hour":
        doCall = !DateHelper.isStartOf(dt, "hour");
        break;
      case "day":
      case "date":
        doCall = !DateHelper.isStartOf(dt, "day");
        break;
      case "week":
        DateHelper.startOf(dt, "day", false);
        doCall = dt.getDay() !== me.weekStartDay || !DateHelper.isEqual(dt, date2);
        break;
      case "month":
        DateHelper.startOf(dt, "day", false);
        doCall = dt.getDate() !== 1 || !DateHelper.isEqual(dt, date2);
        break;
      case "quarter":
        DateHelper.startOf(dt, "day", false);
        doCall = dt.getMonth() % 3 !== 0 || dt.getDate() !== 1 || !DateHelper.isEqual(dt, date2);
        break;
      case "year":
        DateHelper.startOf(dt, "day", false);
        doCall = dt.getMonth() !== 0 || dt.getDate() !== 1 || !DateHelper.isEqual(dt, date2);
        break;
    }
    if (doCall) {
      return DateHelper.getNext(dt, unit, increment, me.weekStartDay);
    }
    return dt;
  }
  get include() {
    return this._include;
  }
  set include(include) {
    const me = this;
    me._include = include;
    me.continuous = !include;
    if (!me.isConfiguring) {
      me.startDate = me._configuredStartDate;
      me.endDate = me._configuredEndDate;
      me.internalOnReconfigure();
      me.trigger("includeChange");
    }
  }
  processExclusion(startDate, endDate, unit) {
    const {
      include
    } = this;
    if (include) {
      return Object.entries(include).some(([includeUnit, rule]) => {
        if (!rule) {
          return false;
        }
        const {
          from,
          to
        } = rule;
        if (DateHelper.compareUnits("day", unit) >= 0 && DateHelper.getLargerUnit(includeUnit) === unit) {
          if (from) {
            DateHelper.set(startDate, includeUnit, from);
          }
          if (to) {
            let stepUnit = unit;
            if (unit === "day") {
              stepUnit = "date";
            }
            DateHelper.set(endDate, {
              [stepUnit]: DateHelper.get(endDate, stepUnit) - 1,
              [includeUnit]: to
            });
          }
        }
        if (DateHelper.compareUnits(includeUnit, unit) >= 0) {
          const datePart = includeUnit === "day" ? startDate.getDay() : DateHelper.get(startDate, includeUnit);
          if (from && datePart < from || to && datePart >= to) {
            return true;
          }
        }
      });
    }
    return false;
  }
  initExclusion() {
    Object.entries(this.include).forEach(([unit, rule]) => {
      if (rule) {
        const {
          from,
          to
        } = rule;
        rule.lengthFactor = DateHelper.getUnitToBaseUnitRatio(unit, DateHelper.getLargerUnit(unit)) / (to - from);
        rule.lengthFactorExcl = DateHelper.getUnitToBaseUnitRatio(unit, DateHelper.getLargerUnit(unit)) / (to - from - 1);
        rule.center = from + from / (rule.lengthFactor - 1);
      }
    });
  }
  updateGenerateTicks() {
    if (!this.isConfiguring) {
      this.reconfigure(this);
    }
  }
  _generateTicks(axisStartDate, axisEndDate, unit = this.unit, increment = this.increment) {
    const me = this, ticks = [], usesExclusion = Boolean(me.include);
    let intervalEnd, tickEnd, isExcluded, dstDiff = 0, {
      startDate,
      endDate
    } = me.getAdjustedDates(axisStartDate, axisEndDate);
    me.tickCache = {};
    if (usesExclusion) {
      me.initExclusion();
    }
    while (startDate < endDate) {
      intervalEnd = DateHelper.getNext(startDate, unit, increment, me.weekStartDay);
      if (!me.autoAdjust && intervalEnd > endDate) {
        intervalEnd = endDate;
      }
      if (unit === "hour" && increment > 1 && ticks.length > 0 && dstDiff === 0) {
        const prev = ticks[ticks.length - 1];
        dstDiff = (prev.startDate.getHours() + increment) % 24 - prev.endDate.getHours();
        if (dstDiff !== 0) {
          intervalEnd = DateHelper.add(intervalEnd, dstDiff, "hour");
        }
      }
      isExcluded = false;
      if (usesExclusion) {
        tickEnd = new Date(intervalEnd.getTime());
        isExcluded = me.processExclusion(startDate, intervalEnd, unit);
      } else {
        tickEnd = intervalEnd;
      }
      if (!isExcluded) {
        ticks.push({
          id: ticks.length + 1,
          startDate,
          endDate: intervalEnd
        });
        me.tickCache[startDate.getTime()] = ticks.length - 1;
      }
      startDate = tickEnd;
    }
    return ticks;
  }
  get visibleTickTimeSpan() {
    const me = this;
    return me.isContinuous ? me.visibleTickEnd - me.visibleTickStart : me.count;
  }
  getTickFromDate(date2) {
    var _date$getTime, _date$getTime2;
    const me = this, ticks = me.records, dateMS = (_date$getTime = (_date$getTime2 = date2.getTime) === null || _date$getTime2 === void 0 ? void 0 : _date$getTime2.call(date2)) !== null && _date$getTime !== void 0 ? _date$getTime : date2;
    let begin = 0, end = ticks.length - 1, middle, tick, tickStart, tickEnd;
    if (!ticks.length || dateMS < ticks[0].startDateMS || dateMS > ticks[end].endDateMS) {
      return -1;
    }
    if (me.isContinuous) {
      while (begin < end) {
        middle = begin + end + 1 >> 1;
        if (dateMS > ticks[middle].endDateMS) {
          begin = middle + 1;
        } else if (dateMS < ticks[middle].startDateMS) {
          end = middle - 1;
        } else {
          begin = middle;
        }
      }
      tick = ticks[begin];
      tickStart = tick.startDateMS;
      if (dateMS > tickStart) {
        tickEnd = tick.endDateMS;
        begin += (dateMS - tickStart) / (tickEnd - tickStart);
      }
      return Math.min(Math.max(begin, me.visibleTickStart), me.visibleTickEnd);
    } else {
      for (let i = 0; i <= end; i++) {
        tickEnd = ticks[i].endDateMS;
        if (dateMS <= tickEnd) {
          tickStart = ticks[i].startDateMS;
          tick = i + (dateMS > tickStart ? (dateMS - tickStart) / (tickEnd - tickStart) : 0);
          return tick;
        }
      }
    }
  }
  getDateFromTick(tick, roundingMethod) {
    const me = this;
    if (tick === me.visibleTickEnd) {
      return me.endDate;
    }
    const wholeTick = Math.floor(tick), fraction = tick - wholeTick, t = me.getAt(wholeTick);
    if (!t) {
      return null;
    }
    const start = wholeTick === 0 ? me.adjustedStart : t.startDate, end = wholeTick === me.count - 1 && me.isContinuous ? me.adjustedEnd : t.endDate;
    let date2 = DateHelper.add(start, fraction * (end - start), "millisecond");
    if (roundingMethod) {
      date2 = me[roundingMethod + "Date"](date2);
    }
    return date2;
  }
  get ticks() {
    return this.records;
  }
  updateTickCache(onlyStartEnd = false) {
    const me = this;
    if (me.count) {
      me._start = me.first.startDate;
      me._end = me.last.endDate;
      me._startMS = me.startDate.getTime();
      me._endMS = me.endDate.getTime();
    } else {
      me._start = me._end = me._startMs = me._endMS = null;
    }
    if (!onlyStartEnd) {
      me.tickCache = {};
      me.forEach((tick, i) => me.tickCache[tick.startDate.getTime()] = i);
    }
  }
  dateInAxis(date2, inclusiveEnd = false) {
    const me = this, axisStart = me.startDate, axisEnd = me.endDate;
    if (me.isContinuous) {
      return inclusiveEnd ? DateHelper.betweenLesserEqual(date2, axisStart, axisEnd) : DateHelper.betweenLesser(date2, axisStart, axisEnd);
    } else {
      const length = me.getCount();
      let tickStart, tickEnd, tick;
      for (let i = 0; i < length; i++) {
        tick = me.getAt(i);
        tickStart = tick.startDate;
        tickEnd = tick.endDate;
        if (inclusiveEnd && date2 <= tickEnd || !inclusiveEnd && date2 < tickEnd) {
          return date2 >= tickStart;
        }
      }
    }
    return false;
  }
  timeSpanInAxis(start, end) {
    const me = this;
    if (!end || end.getTime() === start.getTime()) {
      return this.dateInAxis(start, true);
    }
    if (me.isContinuous) {
      return DateHelper.intersectSpans(start, end, me.startDate, me.endDate);
    }
    return start < me.startDate && end > me.endDate || me.getTickFromDate(start) !== me.getTickFromDate(end);
  }
  isTimeSpanInAxis(timeSpan) {
    const me = this, {
      startMS,
      endMS
    } = me, {
      startDateMS,
      endDateMS
    } = timeSpan;
    if (!startDateMS || !endDateMS)
      return false;
    if (endDateMS === startDateMS) {
      return me.dateInAxis(timeSpan.startDate, true);
    }
    if (me.isContinuous) {
      return endDateMS > startMS && startDateMS < endMS;
    }
    const startTick = me.getTickFromDate(timeSpan.startDate), endTick = me.getTickFromDate(timeSpan.endDate);
    if (startTick === me.count && DateHelper.isEqual(timeSpan.startDate, me.last.endDate) || endTick === 0 && DateHelper.isEqual(timeSpan.endDate, me.first.startDate)) {
      return false;
    }
    return startDateMS < startMS && endDateMS > endMS || startTick !== endTick;
  }
  forEachAuxInterval(unit, increment = 1, iteratorFn, thisObj = this) {
    const end = this.endDate;
    let dt = this.startDate, i = 0, intervalEnd;
    if (dt > end)
      throw new Error("Invalid time axis configuration");
    while (dt < end) {
      intervalEnd = DateHelper.min(DateHelper.getNext(dt, unit, increment, this.weekStartDay), end);
      iteratorFn.call(thisObj, dt, intervalEnd, i, intervalEnd >= end);
      dt = intervalEnd;
      i++;
    }
  }
};
TimeAxis._$name = "TimeAxis";
var RecurrenceLegend = class extends Localizable() {
  static get $name() {
    return "RecurrenceLegend";
  }
  static get allDaysValueAsArray() {
    return ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
  }
  static get allDaysValue() {
    return this.allDaysValueAsArray.join(",");
  }
  static get workingDaysValue() {
    return this.allDaysValueAsArray.filter((day2, index) => !DateHelper.nonWorkingDays[index]).join(",");
  }
  static get nonWorkingDaysValue() {
    return this.allDaysValueAsArray.filter((day2, index) => DateHelper.nonWorkingDays[index]).join(",");
  }
  static getLegend(recurrence, timeSpanStartDate) {
    const me = this, {
      timeSpan,
      interval,
      days: days2,
      monthDays,
      months,
      positions
    } = recurrence, startDate = timeSpanStartDate || timeSpan.startDate, tplData = {
      interval
    };
    let fn2;
    switch (recurrence.frequency) {
      case "DAILY":
        return interval === 1 ? me.L("L{Daily}") : me.L("L{Every {0} days}", tplData);
      case "WEEKLY":
        if (days2 && days2.length) {
          tplData.days = me.getDaysLegend(days2);
        } else if (startDate) {
          tplData.days = DateHelper.getDayName(startDate.getDay());
        }
        return me.L(interval === 1 ? "L{Weekly on {1}}" : "L{Every {0} weeks on {1}}", tplData);
      case "MONTHLY":
        if (days2 && days2.length && positions && positions.length) {
          tplData.days = me.getDaysLegend(days2, positions);
        } else if (monthDays && monthDays.length) {
          monthDays.sort((a, b) => a - b);
          tplData.days = me.arrayToText(monthDays);
        } else if (startDate) {
          tplData.days = startDate.getDate();
        }
        return me.L(interval === 1 ? "L{Monthly on {1}}" : "L{Every {0} months on {1}}", tplData);
      case "YEARLY":
        if (days2 && days2.length && positions && positions.length) {
          tplData.days = me.getDaysLegend(days2, positions);
        } else {
          tplData.days = startDate.getDate();
        }
        if (months && months.length) {
          months.sort((a, b) => a - b);
          if (months.length > 2) {
            fn2 = (month2) => DateHelper.getMonthShortName(month2 - 1);
          } else {
            fn2 = (month2) => DateHelper.getMonthName(month2 - 1);
          }
          tplData.months = me.arrayToText(months, fn2);
        } else {
          tplData.months = DateHelper.getMonthName(startDate.getMonth());
        }
        return me.L(interval === 1 ? "L{Yearly on {1} of {2}}" : "L{Every {0} years on {1} of {2}}", tplData);
    }
  }
  static getDaysLegend(days2, positions) {
    const me = this, tplData = {
      position: ""
    };
    let fn2;
    if (positions && positions.length) {
      tplData.position = me.arrayToText(positions, (position) => me.L(`L{position${position}}`));
    }
    if (days2.length) {
      days2.sort((a, b) => RecurrenceDayRuleEncoder.decodeDay(a)[0] - RecurrenceDayRuleEncoder.decodeDay(b)[0]);
      switch (days2.join(",")) {
        case me.allDaysValue:
          tplData.days = me.L("L{day}");
          break;
        case me.workingDaysValue:
          tplData.days = me.L("L{weekday}");
          break;
        case me.nonWorkingDaysValue:
          tplData.days = me.L("L{weekend day}");
          break;
        default:
          if (days2.length > 2) {
            fn2 = (day2) => DateHelper.getDayShortName(RecurrenceDayRuleEncoder.decodeDay(day2)[0]);
          } else {
            fn2 = (day2) => DateHelper.getDayName(RecurrenceDayRuleEncoder.decodeDay(day2)[0]);
          }
          tplData.days = me.arrayToText(days2, fn2);
      }
    }
    return me.L("L{daysFormat}", tplData);
  }
  static arrayToText(array, fn2) {
    if (fn2) {
      array = array.map(fn2);
    }
    return array.join(", ").replace(/,(?=[^,]*$)/, this.L("L{ and }"));
  }
};
RecurrenceLegend._$name = "RecurrenceLegend";
var AttachToProjectMixin = (Target) => class AttachToProjectMixin extends Target {
  static get $name() {
    return "AttachToProjectMixin";
  }
  async afterConstruct() {
    super.afterConstruct();
    const me = this, projectHolder = me.client || me.grid, {
      project
    } = projectHolder;
    projectHolder.projectSubscribers.push(me);
    if (project) {
      me.attachToProject(project);
      me.attachToResourceStore(project.resourceStore);
      me.attachToEventStore(project.eventStore);
      me.attachToAssignmentStore(project.assignmentStore);
      me.attachToDependencyStore(project.dependencyStore);
      me.attachToCalendarManagerStore(project.calendarManagerStore);
    }
  }
  attachToProject(project) {
    this.detachListeners("project");
    this._project = project;
  }
  attachToEventStore(store) {
    this.detachListeners("eventStore");
  }
  attachToResourceStore(store) {
    this.detachListeners("resourceStore");
  }
  attachToAssignmentStore(store) {
    this.detachListeners("assignmentStore");
  }
  attachToDependencyStore(store) {
    this.detachListeners("dependencyStore");
  }
  attachToCalendarManagerStore(store) {
    this.detachListeners("calendarManagerStore");
  }
  get project() {
    return this._project;
  }
  get calendarManagerStore() {
    return this.project.calendarManagerStore;
  }
  get assignmentStore() {
    return this.project.assignmentStore;
  }
  get resourceStore() {
    return this.project.resourceStore;
  }
  get eventStore() {
    return this.project.eventStore;
  }
  get dependencyStore() {
    return this.project.dependencyStore;
  }
};
var engineStoreNames = ["assignmentStore", "dependencyStore", "eventStore", "resourceStore"];
var ProjectConsumer = (Target) => class ProjectConsumer extends (Target || Base$1) {
  static get $name() {
    return "ProjectConsumer";
  }
  static get declarable() {
    return ["projectStores"];
  }
  static get configurable() {
    return {
      projectModelClass: ProjectModel$1,
      project: {},
      destroyStores: null,
      projectSubscribers: []
    };
  }
  startConfigure(config) {
    this.getConfig("project");
    super.startConfigure(config);
  }
  changeProject(project, oldProject) {
    const me = this, {
      projectStoreNames,
      projectDataNames
    } = me.constructor;
    me.projectCallbacks = /* @__PURE__ */ new Set();
    if (project) {
      me.buildingProjectConfig = true;
      if (!project.isModel) {
        if (me.isConfiguring) {
          me._project = project;
          const {
            crudManager
          } = me;
          if (crudManager) {
            const {
              isCrudManager
            } = crudManager;
            for (const storeName of projectStoreNames) {
              if (crudManager[storeName]) {
                me[storeName] = crudManager[storeName];
                if (!isCrudManager) {
                  delete crudManager[storeName];
                }
              }
            }
          }
          me.getConfig("projectStores");
          for (const dataName of projectDataNames) {
            me.getConfig(dataName);
          }
        }
        const {
          eventStore
        } = project;
        let {
          _sharedProject: sharedProject
        } = me;
        if (eventStore && !eventStore.isEventStoreMixin && eventStore.autoLoad && !eventStore.count) {
          eventStore.autoLoad = false;
          me.delayAutoLoad = true;
        }
        if (sharedProject && engineStoreNames.some((store) => project[store] && project[store] !== sharedProject[store])) {
          for (const store of engineStoreNames) {
            if (project[store] && project[store] === sharedProject[store]) {
              project[store] = project[store].chain();
            }
          }
          sharedProject = null;
        }
        project = sharedProject || new me.projectModelClass(project);
        delete me._project;
      }
      me.buildingProjectConfig = false;
    }
    return project;
  }
  updateProject(project, oldProject) {
    const me = this, {
      projectListeners,
      crudManager
    } = me;
    me.detachListeners("projectConsumer");
    delete me._crudManager;
    if (project) {
      projectListeners.thisObj = me;
      project.ion(projectListeners);
      if (project.isCrudManager) {
        me.crudManager = project;
      } else if (crudManager) {
        crudManager.project = project;
        me.crudManager = crudManager;
      }
      me.projectSubscribers.forEach((subscriber) => subscriber.attachToProject(project));
      for (const storeName of me.constructor.projectStoreNames) {
        me[storeName] = project[storeName];
      }
      if (me.delayAutoLoad) {
        project.eventStore.autoLoad = true;
        project.eventStore.load();
      }
    }
    me.trigger("projectChange", {
      project
    });
  }
  changeCrudManager(crudManager) {
    if (this.buildingProjectConfig) {
      this._crudManager = crudManager.isCrudManager ? crudManager : Object.assign({}, crudManager);
    } else {
      return super.changeCrudManager(crudManager);
    }
  }
  onProjectDataReady() {
    const me = this;
    me.whenVisible(() => {
      if (me.projectCallbacks.size) {
        me.projectCallbacks.forEach((callback) => callback());
        me.projectCallbacks.clear();
      }
    }, null, null, "onProjectDataReady");
  }
  onTimeZoneChange({
    timeZone,
    oldTimeZone
  }) {
    const me = this;
    if (me.startDate) {
      const startDate = oldTimeZone ? TimeZoneHelper.fromTimeZone(me.startDate, oldTimeZone) : me.startDate;
      me.startDate = timeZone ? TimeZoneHelper.toTimeZone(startDate, timeZone) : startDate;
    }
  }
  whenProjectReady(callback) {
    if (this.isEngineReady) {
      callback();
    } else {
      this.projectCallbacks.add(callback);
    }
  }
  get isEngineReady() {
    var _this$project$isEngin, _this$project;
    return Boolean((_this$project$isEngin = (_this$project = this.project).isEngineReady) === null || _this$project$isEngin === void 0 ? void 0 : _this$project$isEngin.call(_this$project));
  }
  doDestroy() {
    super.doDestroy();
    if (this.destroyStores) {
      !this.project.isDestroyed && this.project.destroy();
    }
  }
  get projectStores() {
    const {
      projectStoreNames
    } = this.constructor;
    return projectStoreNames.map((storeName) => this[storeName]);
  }
  static get projectStoreNames() {
    return Object.keys(this.projectStores);
  }
  static get projectDataNames() {
    return this.projectStoreNames.reduce((result, storeName) => {
      const {
        dataName
      } = this.projectStores[storeName];
      if (dataName) {
        result.push(dataName);
      }
      return result;
    }, []);
  }
  static setupProjectStores(cls, meta) {
    const {
      projectStores
    } = cls;
    if (projectStores) {
      const projectListeners = {
        name: "projectConsumer",
        dataReady: "onProjectDataReady",
        change: "relayProjectDataChange",
        timeZoneChange: "onTimeZoneChange"
      }, storeConfigs = {
        projectListeners
      };
      let previousDataName;
      for (const storeName in projectStores) {
        const {
          dataName
        } = projectStores[storeName];
        storeConfigs[storeName] = storeConfigs[dataName] = null;
        if (dataName) {
          Object.defineProperty(meta.class.prototype, dataName, {
            configurable: true,
            get() {
              var _this$project$storeNa;
              return (_this$project$storeNa = this.project[storeName]) === null || _this$project$storeNa === void 0 ? void 0 : _this$project$storeNa.records;
            }
          });
          this.createDataUpdater(storeName, dataName, previousDataName, meta);
        }
        this.createStoreDescriptor(meta, storeName, projectStores[storeName], projectListeners);
        previousDataName = dataName;
      }
      this.setupConfigs(meta, storeConfigs);
    }
  }
  static createDataUpdater(storeName, dataName, previousDataName, meta) {
    meta.class.prototype[`update${StringHelper.capitalize(dataName)}`] = function(data) {
      const {
        project
      } = this;
      previousDataName && this.getConfig(previousDataName);
      if (this.buildingProjectConfig) {
        project[`${dataName}Data`] = data;
      } else {
        project[storeName].data = data;
      }
    };
  }
  static createStoreDescriptor(meta, storeName, {
    listeners
  }, projectListeners) {
    const {
      prototype: clsProto
    } = meta.class, storeNameCap = StringHelper.capitalize(storeName);
    projectListeners[`${storeName}Change`] = function({
      store
    }) {
      this[storeName] = store;
    };
    clsProto[`change${storeNameCap}`] = function(store, oldStore) {
      var _store;
      const me = this, {
        project
      } = me, storeProject = (_store = store) === null || _store === void 0 ? void 0 : _store.project;
      if (me.buildingProjectConfig) {
        if (storeProject !== null && storeProject !== void 0 && storeProject.isProjectModel) {
          me._sharedProject = storeProject;
        }
        project[storeName] = store;
        return;
      }
      if (!me.initializingProject) {
        if (project[storeName] !== store) {
          project[`set${storeNameCap}`](store);
          store = project[storeName];
        }
      }
      if (store !== oldStore) {
        if (listeners) {
          listeners.thisObj = me;
          listeners.name = `${storeName}Listeners`;
          me.detachListeners(listeners.name);
          store.ion(listeners);
        }
        me[`_${storeName}`] = store;
        me.projectSubscribers.forEach((subscriber) => {
          var _subscriber;
          (_subscriber = subscriber[`attachTo${storeNameCap}`]) === null || _subscriber === void 0 ? void 0 : _subscriber.call(subscriber, store);
        });
        me[`_${storeName}`] = null;
      }
      return store;
    };
  }
  relayProjectDataChange(event) {
    return this.trigger("dataChange", _objectSpread2(_objectSpread2({
      project: event.source
    }, event), {}, {
      source: this
    }));
  }
  get widgetClass() {
  }
};
var HorizontalLayout = class extends Base$1 {
  static get defaultConfig() {
    return {
      nbrOfBandsByResource: {},
      bandIndexToPxConvertFn: null,
      bandIndexToPxConvertThisObj: null
    };
  }
  clearCache(resource) {
    if (resource) {
      delete this.nbrOfBandsByResource[resource.id];
    } else {
      this.nbrOfBandsByResource = {};
    }
  }
  applyLayout(events, resource) {
    return this.nbrOfBandsByResource[resource.id] = this.layoutEventsInBands(events);
  }
  layoutEventsInBands(events) {
    throw new Error("Implement in subclass");
  }
};
HorizontalLayout._$name = "HorizontalLayout";
var PackMixin = (Target) => class PackMixin extends (Target || Base$1) {
  static get $name() {
    return "PackMixin";
  }
  static get defaultConfig() {
    return {
      coordProp: "top",
      sizeProp: "height",
      inBandCoordProp: "inBandTop",
      inBandSizeProp: "inBandHeight"
    };
  }
  isSameGroup(a, b) {
    return this.grouped ? a.group === b.group : true;
  }
  packEventsInBands(events, applyClusterFn) {
    const me = this, {
      coordProp,
      sizeProp
    } = me;
    let slot, firstInCluster, cluster, j;
    for (let i = 0, l = events.length; i < l; i++) {
      firstInCluster = events[i];
      slot = me.findStartSlot(events, firstInCluster);
      cluster = me.getCluster(events, i);
      if (cluster.length > 1) {
        firstInCluster[coordProp] = slot.start;
        firstInCluster[sizeProp] = slot.end - slot.start;
        j = 1;
        while (j < cluster.length - 1 && cluster[j + 1].start - firstInCluster.start === 0) {
          j++;
        }
        const nextSlot = me.findStartSlot(events, cluster[j]);
        if (nextSlot && nextSlot.start < 0.8) {
          cluster.length = j;
        }
      }
      const clusterSize = cluster.length, slotSize = (slot.end - slot.start) / clusterSize;
      for (j = 0; j < clusterSize; j++) {
        applyClusterFn(cluster[j], j, slot, slotSize);
      }
      i += clusterSize - 1;
    }
    return 1;
  }
  findStartSlot(events, event) {
    const {
      inBandSizeProp,
      inBandCoordProp,
      coordProp,
      sizeProp
    } = this, priorOverlappers = this.getPriorOverlappingEvents(events, event);
    let i;
    if (priorOverlappers.length === 0) {
      return {
        start: 0,
        end: 1
      };
    }
    for (i = 0; i < priorOverlappers.length; i++) {
      const item = priorOverlappers[i], COORD_PROP = inBandCoordProp in item ? inBandCoordProp : coordProp, SIZE_PROP = inBandSizeProp in item ? inBandSizeProp : sizeProp;
      if (i === 0 && item[COORD_PROP] > 0) {
        return {
          start: 0,
          end: item[COORD_PROP]
        };
      } else {
        if (item[COORD_PROP] + item[SIZE_PROP] < (i < priorOverlappers.length - 1 ? priorOverlappers[i + 1][COORD_PROP] : 1)) {
          return {
            start: item[COORD_PROP] + item[SIZE_PROP],
            end: i < priorOverlappers.length - 1 ? priorOverlappers[i + 1][COORD_PROP] : 1
          };
        }
      }
    }
    return false;
  }
  getPriorOverlappingEvents(events, event) {
    const start = event.start, end = event.end, overlappers = [];
    for (let i = 0, l = events.indexOf(event); i < l; i++) {
      const item = events[i];
      if (this.isSameGroup(item, event) && DateHelper.intersectSpans(start, end, item.start, item.end)) {
        overlappers.push(item);
      }
    }
    overlappers.sort(this.sortOverlappers.bind(this));
    return overlappers;
  }
  sortOverlappers(e13, e22) {
    const {
      coordProp
    } = this;
    return e13[coordProp] - e22[coordProp];
  }
  getCluster(events, startIndex) {
    const startEvent = events[startIndex], result = [startEvent];
    if (startIndex >= events.length - 1) {
      return result;
    }
    let {
      start,
      end
    } = startEvent;
    for (let i = startIndex + 1, l = events.length; i < l; i++) {
      const item = events[i];
      if (!this.isSameGroup(item, startEvent) || !DateHelper.intersectSpans(start, end, item.start, item.end)) {
        break;
      }
      result.push(item);
      start = DateHelper.max(start, item.start);
      end = DateHelper.min(item.end, end);
    }
    return result;
  }
};
var HorizontalLayoutPack = class extends HorizontalLayout.mixin(PackMixin) {
  static get $name() {
    return "HorizontalLayoutPack";
  }
  static get configurable() {
    return {
      type: "pack"
    };
  }
  layoutEventsInBands(events) {
    const result = this.packEventsInBands(events, (event, j, slot, slotSize) => {
      event.height = slotSize;
      event.top = slot.start + j * slotSize;
    });
    events.forEach((event) => {
      Object.assign(event, this.bandIndexToPxConvertFn.call(this.bandIndexToPxConvertThisObj || this, event.top, event.height, event.eventRecord, event.resourceRecord));
    });
    return result;
  }
};
HorizontalLayoutPack._$name = "HorizontalLayoutPack";
var HorizontalLayoutStack = class extends HorizontalLayout {
  static get $name() {
    return "HorizontalLayoutStack";
  }
  static get configurable() {
    return {
      type: "stack"
    };
  }
  layoutEventsInBands(events, heightRun = false) {
    let verticalPosition = 0;
    do {
      let eventIndex = 0, event = events[0];
      while (event) {
        if (!heightRun) {
          event.top = this.bandIndexToPxConvertFn.call(this.bandIndexToPxConvertThisObj || this, verticalPosition, event.eventRecord, event.resourceRecord);
        }
        events.splice(eventIndex, 1);
        eventIndex = this.findClosestSuccessor(event, events);
        event = events[eventIndex];
      }
      verticalPosition++;
    } while (events.length > 0);
    return verticalPosition;
  }
  findClosestSuccessor(eventRenderData, events) {
    const {
      endMS,
      group
    } = eventRenderData, isMilestone = eventRenderData.eventRecord && eventRenderData.eventRecord.duration === 0;
    let minGap = Infinity, closest, gap, event;
    for (let i = 0, l = events.length; i < l; i++) {
      event = events[i];
      gap = event.startMS - endMS;
      if (gap >= 0 && gap < minGap && (gap > 0 || event.endMS - event.startMS > 0 || !isMilestone)) {
        if (this.grouped && group !== event.group) {
          break;
        }
        closest = i;
        minGap = gap;
      }
    }
    return closest;
  }
};
HorizontalLayoutStack._$name = "HorizontalLayoutStack";
var ClockTemplate = class extends Base$1 {
  static get defaultConfig() {
    return {
      minuteHeight: 8,
      minuteTop: 2,
      hourHeight: 8,
      hourTop: 2,
      handLeft: 10,
      div: document.createElement("div"),
      scheduler: null,
      template(data) {
        return `<div class="b-sch-clockwrap b-sch-clock-${data.mode || this.mode} ${data.cls || ""}">
                    <div class="b-sch-clock">
                        <div class="b-sch-hour-indicator">${DateHelper.format(data.date, "MMM")}</div>
                        <div class="b-sch-minute-indicator">${DateHelper.format(data.date, "D")}</div>
                        <div class="b-sch-clock-dot"></div>
                    </div>
                    <span class="b-sch-clock-text">${StringHelper.encodeHtml(data.text)}</span>
                </div>`;
      }
    };
  }
  generateContent(data) {
    return this.div.innerHTML = this.template(data);
  }
  updateDateIndicator(el, date2) {
    const hourIndicatorEl = el === null || el === void 0 ? void 0 : el.querySelector(".b-sch-hour-indicator"), minuteIndicatorEl = el === null || el === void 0 ? void 0 : el.querySelector(".b-sch-minute-indicator");
    if (date2 && hourIndicatorEl && minuteIndicatorEl && BrowserHelper.isBrowserEnv) {
      if (this.mode === "hour") {
        hourIndicatorEl.style.transform = `rotate(${date2.getHours() % 12 * 30}deg)`;
        minuteIndicatorEl.style.transform = `rotate(${date2.getMinutes() * 6}deg)`;
      } else {
        hourIndicatorEl.style.transform = "none";
        minuteIndicatorEl.style.transform = "none";
      }
    }
  }
  set mode(mode) {
    this._mode = mode;
  }
  get mode() {
    if (this._mode) {
      return this._mode;
    }
    const unitLessThanDay = DateHelper.compareUnits(this.scheduler.timeAxisViewModel.timeResolution.unit, "day") < 0, formatContainsHourInfo = DateHelper.formatContainsHourInfo(this.scheduler.displayDateFormat);
    return unitLessThanDay && formatContainsHourInfo ? "hour" : "day";
  }
  set template(template) {
    this._template = template;
  }
  get template() {
    return this._template;
  }
};
ClockTemplate._$name = "ClockTemplate";
var DragBase = class extends InstancePlugin {
  static get defaultConfig() {
    return {
      tooltipTemplate: (data) => `
                <div class="b-sch-tip-${data.valid ? "valid" : "invalid"}">
                    ${data.startClockHtml}
                    ${data.endClockHtml}
                    <div class="b-sch-tip-message">${data.message}</div>
                </div>
            `,
      showTooltip: true,
      showExactDropPosition: false,
      store: null,
      dragHelperConfig: null,
      tooltipCls: "b-eventdrag-tooltip"
    };
  }
  static get configurable() {
    return {
      constrainDragToTimeline: true,
      constrainDragToResource: true,
      constrainDragToTimeSlot: false,
      tip: {
        $config: ["lazy", "nullify"],
        value: {
          align: {
            align: "b-t",
            allowTargetOut: true
          },
          autoShow: true,
          updateContentOnMouseMove: true
        }
      },
      throttleDragEvent: true
    };
  }
  static get pluginConfig() {
    return {
      chain: ["onPaint"]
    };
  }
  internalSnapToPosition(snapTo) {
    var _this$snapToPosition;
    const {
      dragData
    } = this;
    (_this$snapToPosition = this.snapToPosition) === null || _this$snapToPosition === void 0 ? void 0 : _this$snapToPosition.call(this, {
      assignmentRecord: dragData.assignmentRecord,
      eventRecord: dragData.eventRecord,
      resourceRecord: dragData.newResource || dragData.resourceRecord,
      startDate: dragData.startDate,
      endDate: dragData.endDate,
      snapTo
    });
  }
  buildDragHelperConfig() {
    const me = this, {
      client,
      constrainDragToTimeline,
      constrainDragToResource,
      constrainDragToTimeSlot,
      dragHelperConfig = {}
    } = me, {
      timeAxisViewModel,
      isHorizontal
    } = client, lockY = isHorizontal ? constrainDragToResource : constrainDragToTimeSlot, lockX = isHorizontal ? constrainDragToTimeSlot : constrainDragToResource;
    if (me.externalDropTargetSelector) {
      dragHelperConfig.dropTargetSelector = `.b-timeaxissubgrid,${me.externalDropTargetSelector}`;
    }
    return Objects.merge({
      name: me.constructor.name,
      positioning: "absolute",
      lockX,
      lockY,
      minX: true,
      maxX: true,
      constrain: false,
      cloneTarget: !constrainDragToTimeline,
      removeProxyAfterDrop: false,
      dragWithin: constrainDragToTimeline ? null : document.body,
      hideOriginalElement: true,
      dropTargetSelector: ".b-timelinebase",
      dropTargetCls: me.externalDropTargetSelector ? "b-drop-target" : "",
      outerElement: client.timeAxisSubGridElement,
      targetSelector: client.eventSelector,
      scrollManager: constrainDragToTimeline ? client.scrollManager : null,
      createProxy: (el) => me.createProxy(el),
      snapCoordinates: ({
        element,
        newX,
        newY
      }) => {
        const {
          dragData
        } = me;
        if (me.constrainDragToTimeline && !me.constrainDragToTimeSlot && (me.showExactDropPosition || timeAxisViewModel.snap)) {
          const draggedEventRecord = dragData.draggedEntities[0], coordinate = me.getCoordinate(draggedEventRecord, element, [newX, newY]), snappedDate = timeAxisViewModel.getDateFromPosition(coordinate, "round"), {
            calendar
          } = draggedEventRecord;
          if (!calendar || snappedDate && calendar.isWorkingTime(snappedDate, DateHelper.add(snappedDate, draggedEventRecord.fullDuration))) {
            const snappedPosition = snappedDate && timeAxisViewModel.getPositionFromDate(snappedDate);
            if (snappedDate && snappedDate >= client.startDate && snappedPosition != null) {
              if (isHorizontal) {
                newX = snappedPosition;
              } else {
                newY = snappedPosition;
              }
            }
          }
        }
        const snapTo = {
          x: newX,
          y: newY
        };
        me.internalSnapToPosition(snapTo);
        return snapTo;
      },
      internalListeners: {
        beforedragstart: "onBeforeDragStart",
        dragstart: "onDragStart",
        afterdragstart: "onAfterDragStart",
        drag: "onDrag",
        drop: "onDrop",
        abort: "onDragAbort",
        abortFinalized: "onDragAbortFinalized",
        reset: "onDragReset",
        thisObj: me
      }
    }, dragHelperConfig, {
      isElementDraggable: (el, event) => {
        return (!dragHelperConfig || !dragHelperConfig.isElementDraggable || dragHelperConfig.isElementDraggable(el, event)) && me.isElementDraggable(el, event);
      }
    });
  }
  onPaint({
    firstPaint
  }) {
    var _me$drag;
    const me = this, {
      client
    } = me;
    (_me$drag = me.drag) === null || _me$drag === void 0 ? void 0 : _me$drag.destroy();
    me.drag = DragHelper.new(me.buildDragHelperConfig());
    if (firstPaint) {
      client.rowManager.ion({
        changeTotalHeight: () => {
          var _me$dragData;
          return me.updateYConstraint((_me$dragData = me.dragData) === null || _me$dragData === void 0 ? void 0 : _me$dragData[`${client.scheduledEventName}Record`]);
        },
        thisObj: me
      });
    }
    if (me.showTooltip) {
      me.clockTemplate = new ClockTemplate({
        scheduler: client
      });
    }
  }
  doDestroy() {
    var _this$drag, _this$clockTemplate, _this$tip;
    (_this$drag = this.drag) === null || _this$drag === void 0 ? void 0 : _this$drag.destroy();
    (_this$clockTemplate = this.clockTemplate) === null || _this$clockTemplate === void 0 ? void 0 : _this$clockTemplate.destroy();
    (_this$tip = this.tip) === null || _this$tip === void 0 ? void 0 : _this$tip.destroy();
    super.doDestroy();
  }
  get tipId() {
    return `${this.client.id}-event-drag-tip`;
  }
  changeTip(tip, oldTip) {
    const me = this;
    if (tip) {
      const result = Tooltip.reconfigure(oldTip, Tooltip.mergeConfigs({
        forElement: me.element,
        id: me.tipId,
        getHtml: me.getTipHtml.bind(me),
        cls: me.tooltipCls,
        owner: me.client
      }, tip), {
        owner: me.client,
        defaults: {
          type: "tooltip"
        }
      });
      result.ion({
        innerHtmlUpdate: "updateDateIndicator",
        thisObj: me
      });
      return result;
    } else {
      oldTip === null || oldTip === void 0 ? void 0 : oldTip.destroy();
    }
  }
  createProxy(element) {
    const proxy = element.cloneNode(true);
    delete proxy.id;
    proxy.classList.add(`b-sch-${this.client.mode}`);
    return proxy;
  }
  onBeforeDragStart({
    context,
    event
  }) {
    const me = this, {
      client
    } = me, dragData = me.getMinimalDragData(context, event), eventRecord = dragData === null || dragData === void 0 ? void 0 : dragData[`${client.scheduledEventName}Record`], resourceRecord = dragData.resourceRecord;
    if (client.readOnly || me.disabled || !eventRecord || eventRecord.isDraggable === false || eventRecord.readOnly || resourceRecord !== null && resourceRecord !== void 0 && resourceRecord.readOnly) {
      return false;
    }
    context.pointerStartDate = client.getDateFromXY([context.startClientX, context.startPageY], null, false);
    const result = me.triggerBeforeEventDrag(`before${client.capitalizedEventName}Drag`, _objectSpread2(_objectSpread2({}, dragData), {}, {
      event,
      context: _objectSpread2(_objectSpread2({}, context), dragData)
    })) !== false;
    if (result) {
      var _client;
      me.updateYConstraint(eventRecord, resourceRecord);
      (_client = client[`before${client.capitalizedEventName}DragStart`]) === null || _client === void 0 ? void 0 : _client.call(client, context, dragData);
    }
    return result;
  }
  onAfterDragStart({
    context,
    event
  }) {
  }
  get isDragging() {
    var _this$drag2;
    return (_this$drag2 = this.drag) === null || _this$drag2 === void 0 ? void 0 : _this$drag2.isDragging;
  }
  get isActivelyDragging() {
    return this.isDragging && !this.finalizing;
  }
  onDragStart({
    context,
    event
  }) {
    var _me$findClientFromTar, _client2, _menuFeature$hideCont;
    const me = this, client = (_me$findClientFromTar = me.findClientFromTarget(event, context)) !== null && _me$findClientFromTar !== void 0 ? _me$findClientFromTar : me.client;
    me.currentOverClient = client;
    me.drag.unifiedProxy = me.unifiedDrag;
    me.onMouseOverNewTimeline(client, true);
    const dragData = me.dragData = me.getDragData(context);
    me.suspendElementRedrawing(context.element);
    if (me.showTooltip && me.tip) {
      const tipTarget = dragData.context.dragProxy ? dragData.context.dragProxy.firstChild : context.element;
      me.tip.showBy(tipTarget);
    }
    me.triggerDragStart(dragData);
    (_client2 = client[`after${client.capitalizedEventName}DragStart`]) === null || _client2 === void 0 ? void 0 : _client2.call(client, context, dragData);
    const {
      eventMenu,
      taskMenu
    } = client.features, menuFeature = eventMenu || taskMenu;
    menuFeature === null || menuFeature === void 0 ? void 0 : (_menuFeature$hideCont = menuFeature.hideContextMenu) === null || _menuFeature$hideCont === void 0 ? void 0 : _menuFeature$hideCont.call(menuFeature, false);
  }
  updateDateIndicator() {
    const {
      startDate,
      endDate
    } = this.dragData, {
      tip,
      clockTemplate
    } = this, endDateElement = tip.element.querySelector(".b-sch-tooltip-enddate");
    clockTemplate.updateDateIndicator(tip.element, startDate);
    endDateElement && clockTemplate.updateDateIndicator(endDateElement, endDate);
  }
  findClientFromTarget(event, context) {
    let {
      target
    } = event;
    if (/^touch/.test(event.type)) {
      const center = Rectangle.from(context.element, null, true).center;
      target = DomHelper.elementFromPoint(center.x, center.y);
    }
    const client = Widget.fromElement(target, "timelinebase");
    return client !== null && client !== void 0 && client.isResourceHistogram ? null : client;
  }
  onDrag({
    context,
    event
  }) {
    const me = this, dd = me.dragData, start = dd.startDate;
    let client;
    if (me.constrainDragToTimeline) {
      client = me.client;
    } else {
      client = me.findClientFromTarget(event, dd.context);
    }
    me.updateDragContext(context, event);
    if (!client) {
      return;
    }
    if (client !== me.currentOverClient) {
      me.onMouseOverNewTimeline(client);
    }
    if (dd.dirty || !me.throttleDragEvent) {
      const valid = dd.valid;
      me.triggerEventDrag(dd, start);
      if (valid !== dd.valid) {
        dd.context.valid = dd.externalDragValidity = dd.valid;
      }
    }
    if (me.showTooltip && me.tip) {
      me.tip.lastAlignSpec.allowTargetOut = !dd.valid;
      me.tip.realign();
    }
  }
  onMouseOverNewTimeline(newTimeline, initial) {
    const me = this, {
      drag: {
        lockX,
        lockY
      }
    } = me, scrollables = [];
    me.currentOverClient.element.classList.remove("b-dragging-" + me.currentOverClient.scheduledEventName);
    newTimeline.element.classList.add("b-dragging-" + newTimeline.scheduledEventName);
    if (!initial) {
      me.currentOverClient.scrollManager.stopMonitoring();
    }
    if (!lockX) {
      scrollables.push({
        element: newTimeline.timeAxisSubGrid.scrollable.element,
        direction: "horizontal"
      });
    }
    if (!lockY) {
      scrollables.push({
        element: newTimeline.scrollable.element,
        direction: "vertical"
      });
    }
    newTimeline.scrollManager.startMonitoring({
      scrollables,
      callback: me.drag.onScrollManagerScrollCallback
    });
    me.currentOverClient = newTimeline;
  }
  triggerBeforeEventDropFinalize(eventType, eventData, client) {
    client.trigger(eventType, eventData);
  }
  onDrop({
    context,
    event
  }) {
    var _me$tip;
    const me = this, {
      currentOverClient,
      dragData
    } = me;
    let modified = false;
    (_me$tip = me.tip) === null || _me$tip === void 0 ? void 0 : _me$tip.hide();
    context.valid = context.valid && me.isValidDrop(dragData);
    me.drag.removeProxyAfterDrop = Boolean(dragData.externalDropTarget);
    if (context.valid && dragData.startDate && dragData.endDate) {
      let beforeDropTriggered = false;
      dragData.finalize = async (valid) => {
        if (beforeDropTriggered || dragData.async) {
          await me.finalize(valid);
        } else {
          context.valid = context.valid && valid;
        }
      };
      me.triggerBeforeEventDropFinalize(`before${currentOverClient.capitalizedEventName}DropFinalize`, {
        context: dragData,
        domEvent: event
      }, currentOverClient);
      beforeDropTriggered = true;
      context.async = dragData.async;
      if (!context.async && !dragData.externalDropTarget) {
        modified = dragData.startDate - dragData.origStart !== 0 || dragData.newResource !== dragData.resourceRecord;
      }
    }
    if (!context.async) {
      me.finalize(dragData.valid && context.valid && modified);
    }
  }
  onDragAbort({
    context
  }) {
    var _me$tip2;
    const me = this;
    me.client.currentOrientation.onDragAbort({
      context,
      dragData: me.dragData
    });
    me.resetDraggedElements();
    (_me$tip2 = me.tip) === null || _me$tip2 === void 0 ? void 0 : _me$tip2.hide();
    me.triggerDragAbort(me.dragData);
  }
  onDragAbortFinalized({
    context
  }) {
    var _me$client, _me$client2;
    const me = this;
    me.triggerDragAbortFinalized(me.dragData);
    (_me$client = (_me$client2 = me.client)[`after${me.client.capitalizedEventName}DragAbortFinalized`]) === null || _me$client === void 0 ? void 0 : _me$client.call(_me$client2, context, me.dragData);
  }
  onDragReset({
    source: dragHelper
  }) {
    var _dragHelper$context;
    const me = this, currentTimeline = me.currentOverClient;
    currentTimeline === null || currentTimeline === void 0 ? void 0 : currentTimeline.scrollManager.stopMonitoring();
    if ((_dragHelper$context = dragHelper.context) !== null && _dragHelper$context !== void 0 && _dragHelper$context.started) {
      me.resetDraggedElements();
      currentTimeline.trigger(`${currentTimeline.scheduledEventName}DragReset`);
    }
    currentTimeline === null || currentTimeline === void 0 ? void 0 : currentTimeline.element.classList.remove("b-dragging-" + me.currentOverClient.scheduledEventName);
    me.dragData = null;
  }
  resetDraggedElements() {
    const {
      dragData
    } = this, {
      eventBarEls,
      draggedEntities
    } = dragData;
    this.resumeRecordElementRedrawing(dragData.record);
    draggedEntities.forEach((record, i) => {
      this.resumeRecordElementRedrawing(record);
      eventBarEls[i].classList.remove(this.drag.draggingCls);
      eventBarEls[i].retainElement = false;
    });
    dragData.context.element.retainElement = false;
  }
  onInternalInvalidDrop(abort) {
    var _me$tip3;
    const me = this, {
      context
    } = me.drag;
    (_me$tip3 = me.tip) === null || _me$tip3 === void 0 ? void 0 : _me$tip3.hide();
    me.triggerAfterDrop(me.dragData, false);
    context.valid = false;
    if (abort) {
      me.drag.abort();
    }
  }
  async finalize(updateRecords) {
    const me = this, {
      dragData
    } = me;
    if (!dragData || me.finalizing) {
      return;
    }
    const {
      context,
      draggedEntities,
      externalDropTarget
    } = dragData;
    let result;
    me.finalizing = true;
    draggedEntities.forEach((record, i) => {
      me.resumeRecordElementRedrawing(record);
      dragData.eventBarEls[i].classList.remove(me.drag.draggingCls);
      dragData.eventBarEls[i].retainElement = false;
    });
    context.element.retainElement = false;
    if (externalDropTarget && dragData.valid || updateRecords) {
      result = me.updateRecords(dragData);
      if (!externalDropTarget && Objects.isPromise(result)) {
        context.async = true;
        await result;
      }
      if (!dragData.valid) {
        me.onInternalInvalidDrop(true);
      } else {
        if (context.async) {
          context.finalize();
        }
        if (externalDropTarget) {
          me.client.refreshRows(false);
        }
        me.triggerAfterDrop(dragData, true);
      }
    } else {
      me.onInternalInvalidDrop(context.async || dragData.async);
    }
    me.finalizing = false;
    return result;
  }
  updateDragContext(info, event) {
    const me = this, {
      drag
    } = me, dd = me.dragData, client = me.currentOverClient, {
      isHorizontal
    } = client, [record] = dd.draggedEntities, eventRecord = record.isAssignment ? record.event : record, lastDragStartDate = dd.startDate, constrainToTimeSlot = me.constrainDragToTimeSlot || (isHorizontal ? drag.lockX : drag.lockY);
    dd.browserEvent = event;
    Object.assign(dd, me.getProductDragContext(dd));
    if (constrainToTimeSlot) {
      dd.timeDiff = 0;
    } else {
      const {
        dateConstraints
      } = dd;
      let timeDiff;
      if (client.timeAxis.isContinuous) {
        var _info$pageX, _info$pageY;
        const timeAxisPosition = client.isHorizontal ? (_info$pageX = info.pageX) !== null && _info$pageX !== void 0 ? _info$pageX : info.startPageX : (_info$pageY = info.pageY) !== null && _info$pageY !== void 0 ? _info$pageY : info.startPageY, pointerDate = client.getDateFromCoordinate(timeAxisPosition, null, false, true);
        timeDiff = dd.timeDiff = pointerDate - info.pointerStartDate;
      } else {
        const range = me.resolveStartEndDates(info.element);
        dd.valid = Boolean(range.startDate && range.endDate);
        if (dd.valid) {
          timeDiff = range.startDate - dd.origStart;
        }
      }
      if (timeDiff !== null) {
        dd.startDate = me.adjustStartDate(dd.origStart, timeDiff);
        if (dateConstraints) {
          dd.startDate = DateHelper.constrain(dd.startDate, dateConstraints.start, dateConstraints.end ? new Date(dateConstraints.end - eventRecord.durationMS) : null);
        }
        dd.endDate = DateHelper.add(dd.startDate, eventRecord.fullDuration);
        if (dd.valid) {
          dd.timeDiff = dd.startDate - dd.origStart;
        }
      }
    }
    const positionDirty = dd.dirty = dd.dirty || lastDragStartDate - dd.startDate !== 0;
    if (dd.valid) {
      if (me.constrainDragToTimeline && (dd.endDate <= client.timeAxis.startDate || dd.startDate >= client.timeAxis.endDate)) {
        dd.valid = false;
        dd.context.message = me.L("L{EventDrag.noDropOutsideTimeline}");
      } else if (positionDirty || dd.externalDropTarget) {
        const result = dd.externalDragValidity = !event || info.pageX && me.checkDragValidity(dd, event);
        if (!result || typeof result === "boolean") {
          dd.valid = result !== false;
          dd.context.message = "";
        } else {
          dd.valid = result.valid !== false;
          dd.context.message = result.message;
        }
      } else {
        var _dd$externalDragValid;
        dd.valid = dd.externalDragValidity !== false && ((_dd$externalDragValid = dd.externalDragValidity) === null || _dd$externalDragValid === void 0 ? void 0 : _dd$externalDragValid.valid) !== false;
      }
    } else {
      dd.valid = false;
    }
    dd.context.valid = dd.valid;
  }
  suspendRecordElementRedrawing(record, suspend = true) {
    this.suspendElementRedrawing(this.getRecordElement(record), suspend);
    record.instanceMeta(this.client).retainElement = suspend;
  }
  resumeRecordElementRedrawing(record) {
    this.suspendRecordElementRedrawing(record, false);
  }
  suspendElementRedrawing(element, suspend = true) {
    if (element) {
      element.retainElement = suspend;
    }
  }
  resumeElementRedrawing(element) {
    this.suspendElementRedrawing(element, false);
  }
  getDragData(info) {
    const me = this, {
      client,
      drag
    } = me, productDragData = me.setupProductDragData(info), {
      record,
      eventBarEls,
      draggedEntities
    } = productDragData, {
      startEvent
    } = drag, timespan = record.isAssignment ? record.event : record, origStart = timespan.startDate, origEnd = timespan.endDate, timeAxis = client.timeAxis, startsOutsideView = origStart < timeAxis.startDate, endsOutsideView = origEnd > timeAxis.endDate, multiSelect = client.isSchedulerBase ? client.multiEventSelect : client.selectionMode.multiSelect, coordinate = me.getCoordinate(timespan, info.element, [info.elementStartX, info.elementStartY]), clientCoordinate = me.getCoordinate(timespan, info.element, [info.startClientX, info.startClientY]);
    me.suspendRecordElementRedrawing(record);
    draggedEntities.forEach((record2) => me.suspendRecordElementRedrawing(record2));
    if (record.isAssignment) {
      client.selectAssignment(record, startEvent.ctrlKey && multiSelect);
    } else {
      client.selectEvent(record, startEvent.ctrlKey && multiSelect);
    }
    const dragData = _objectSpread2(_objectSpread2({
      context: info
    }, productDragData), {}, {
      sourceDate: startsOutsideView ? origStart : client.getDateFromCoordinate(coordinate),
      screenSourceDate: client.getDateFromCoordinate(clientCoordinate, null, false),
      startDate: origStart,
      endDate: origEnd,
      timeDiff: 0,
      origStart,
      origEnd,
      startsOutsideView,
      endsOutsideView,
      duration: origEnd - origStart,
      browserEvent: startEvent
    });
    eventBarEls.forEach((el) => el.classList.remove("b-sch-event-hover", "b-active"));
    if (eventBarEls.length > 1) {
      info.relatedElements = eventBarEls.slice(1);
    }
    return dragData;
  }
  setupConstraints(constrainRegion, elRegion, tickSize, constrained) {
    const me = this, xTickSize = !me.showExactDropPosition && tickSize > 1 ? tickSize : 0, yTickSize = 0;
    if (constrained) {
      me.setXConstraint(constrainRegion.left, constrainRegion.right - elRegion.width, xTickSize);
    } else {
      me.setXConstraint(true, true, xTickSize);
    }
    me.setYConstraint(constrainRegion.top, constrainRegion.bottom - elRegion.height, yTickSize);
  }
  updateYConstraint(eventRecord, resourceRecord) {
    const me = this, {
      client
    } = me, {
      context
    } = me.drag, tickSize = client.timeAxisViewModel.snapPixelAmount;
    if (context && !me.drag.lockY) {
      let constrainRegion;
      if (me.constrainDragToTimeline) {
        constrainRegion = client.getScheduleRegion(resourceRecord, eventRecord);
      } else {
        me.setYConstraint(null, null, tickSize);
        return;
      }
      me.setYConstraint(constrainRegion.top, constrainRegion.bottom - context.element.offsetHeight, tickSize);
    } else {
      me.setYConstraint(null, null, tickSize);
    }
  }
  setXConstraint(iLeft, iRight, iTickSize) {
    const {
      drag
    } = this;
    drag.minX = iLeft;
    drag.maxX = iRight;
  }
  setYConstraint(iUp, iDown, iTickSize) {
    const {
      drag
    } = this;
    drag.minY = iUp;
    drag.maxY = iDown;
  }
  adjustStartDate(startDate, timeDiff) {
    return this.client.timeAxis.roundDate(new Date(startDate - 0 + timeDiff), this.client.snapRelativeToEventStartDate ? startDate : false);
  }
  resolveStartEndDates(draggedElement) {
    const timeline = this.currentOverClient, {
      timeAxis
    } = timeline, proxyRect = Rectangle.from(draggedElement.querySelector(timeline.eventInnerSelector), timeline.timeAxisSubGridElement), dd = this.dragData, [record] = dd.draggedEntities, {
      fullDuration
    } = record.isAssignment ? record.event : record;
    let {
      start: startDate,
      end: endDate
    } = timeline.getStartEndDatesFromRectangle(proxyRect, "round", fullDuration, !timeAxis.isContinuous);
    if (startDate && endDate) {
      startDate = this.adjustStartDate(startDate, 0);
      if (!dd.startsOutsideView) {
        if (!timeAxis.dateInAxis(startDate, false)) {
          const tick = timeAxis.getTickFromDate(startDate);
          if (tick >= 0) {
            startDate = timeAxis.getDateFromTick(tick);
          }
        }
        endDate = startDate && DateHelper.add(startDate, fullDuration);
      } else if (!dd.endsOutsideView) {
        startDate = endDate && DateHelper.add(endDate, -fullDuration);
      }
    }
    return {
      startDate,
      endDate
    };
  }
  getTipHtml() {
    const me = this, {
      dragData,
      client,
      tooltipTemplate
    } = me, {
      startDate,
      endDate,
      draggedEntities
    } = dragData, startText = client.getFormattedDate(startDate), endText = client.getFormattedEndDate(endDate, startDate), {
      valid,
      message,
      element,
      dragProxy
    } = dragData.context, tipTarget = dragProxy ? dragProxy.firstChild : element, dragged = draggedEntities[0], timeSpanRecord = dragged.isTask ? dragged : dragged.event;
    me.tip.lastAlignSpec.target = tipTarget;
    return tooltipTemplate({
      valid,
      startDate,
      endDate,
      startText,
      endText,
      dragData,
      message: message || "",
      [client.scheduledEventName + "Record"]: timeSpanRecord,
      startClockHtml: me.clockTemplate.template({
        date: startDate,
        text: startText,
        cls: "b-sch-tooltip-startdate"
      }),
      endClockHtml: timeSpanRecord.isMilestone ? "" : me.clockTemplate.template({
        date: endDate,
        text: endText,
        cls: "b-sch-tooltip-enddate"
      })
    });
  }
  updateConstrainDragToTimeSlot(value) {
    const axis = this.client.isHorizontal ? "lockX" : "lockY";
    if (this.drag) {
      this.drag[axis] = value;
    }
  }
  updateConstrainDragToResource(constrainDragToResource) {
    const me = this;
    if (me.drag) {
      const {
        constrainDragToTimeSlot
      } = me, {
        isHorizontal
      } = me.client;
      if (constrainDragToResource) {
        me.constrainDragToTimeline = true;
      }
      me.drag.lockY = isHorizontal ? constrainDragToResource : constrainDragToTimeSlot;
      me.drag.lockX = isHorizontal ? constrainDragToTimeSlot : constrainDragToResource;
    }
  }
  updateConstrainDragToTimeline(constrainDragToTimeline) {
    if (!this.isConfiguring) {
      Object.assign(this.drag, {
        cloneTarget: !constrainDragToTimeline,
        dragWithin: constrainDragToTimeline ? null : document.body,
        scrollManager: constrainDragToTimeline ? this.client.scrollManager : null
      });
    }
  }
  getElementFromContext(context) {
    return context.grabbed || context.dragProxy || context.element;
  }
  getRelatedRecords(record) {
    return [];
  }
  getMinimalDragData(info, event) {
    return {};
  }
  isValidDrop(dragData) {
    throw new Error("Implement in subclass");
  }
  checkDragValidity(dragData) {
    throw new Error("Implement in subclass");
  }
  updateRecords(context) {
    throw new Error("Implement in subclass");
  }
  isElementDraggable(el, event) {
    throw new Error("Implement in subclass");
  }
  getCoordinate(record, element, coord) {
    throw new Error("Implement in subclass");
  }
  setupProductDragData(info) {
    throw new Error("Implement in subclass");
  }
  getProductDragContext(dd) {
    throw new Error("Implement in subclass");
  }
  getRecordElement(record) {
    throw new Error("Implement in subclass");
  }
};
DragBase._$name = "DragBase";
var tipAlign = {
  top: "b-t",
  right: "b100-t100",
  bottom: "t-b",
  left: "b0-t0"
};
var EventResize = class extends InstancePlugin.mixin(Draggable, Droppable) {
  static get $name() {
    return "EventResize";
  }
  static get configurable() {
    return {
      draggingItemCls: "b-sch-event-wrap-resizing",
      resizingItemInnerCls: "b-sch-event-resizing",
      leftHandle: true,
      rightHandle: true,
      topHandle: true,
      bottomHandle: true,
      handleSize: null,
      dynamicHandleSize: true,
      allowResizeToZero: null,
      reservedSpace: 5,
      touchHandleSize: null,
      dragThreshold: 0,
      dragTouchStartDelay: 0,
      draggingClsSelector: ".b-timeline-base",
      showTooltip: true,
      showExactResizePosition: false,
      validatorFn: () => true,
      validatorFnThisObj: null,
      tip: {
        $config: ["lazy", "nullify"],
        value: {
          autoShow: false,
          axisLock: true,
          trackMouse: false,
          updateContentOnMouseMove: true,
          hideDelay: 0
        }
      },
      tooltipTemplate: (context) => `
                <div class="b-sch-tip-${context.valid ? "valid" : "invalid"}">
                    ${context.startClockHtml}
                    ${context.endClockHtml}
                    <div class="b-sch-tip-message">${context.message}</div>
                </div>
            `,
      ignoreSelector: ".b-sch-terminal",
      dragActiveCls: "b-resizing-event"
    };
  }
  static get pluginConfig() {
    return {
      chain: ["render", "onEventDataGenerated", "isEventElementDraggable"]
    };
  }
  doDestroy() {
    var _this$dragging;
    super.doDestroy();
    (_this$dragging = this.dragging) === null || _this$dragging === void 0 ? void 0 : _this$dragging.destroy();
  }
  render() {
    const me = this, {
      client
    } = me;
    me.dragSelector = me.dragItemSelector = client.eventSelector;
    me.dragRootElement = me.dropRootElement = client.timeAxisSubGridElement;
    me.dragLock = client.isVertical ? "y" : "x";
  }
  isEventElementDraggable(eventElement, eventRecord, el, event) {
    const me = this, eventResizable = eventRecord === null || eventRecord === void 0 ? void 0 : eventRecord.resizable;
    if (me.disabled || !eventResizable || eventRecord.isMilestone) {
      return true;
    }
    return (eventResizable !== true && eventResizable !== "start" || !me.isOverStartHandle(event, eventElement)) && (eventResizable !== true && eventResizable !== "end" || !me.isOverEndHandle(event, eventElement));
  }
  onEventDataGenerated({
    eventRecord,
    wrapperCls,
    cls
  }) {
    var _this$dragging2, _this$dragging2$conte;
    if (eventRecord === ((_this$dragging2 = this.dragging) === null || _this$dragging2 === void 0 ? void 0 : (_this$dragging2$conte = _this$dragging2.context) === null || _this$dragging2$conte === void 0 ? void 0 : _this$dragging2$conte.eventRecord)) {
      wrapperCls["b-active"] = wrapperCls[this.draggingItemCls] = wrapperCls["b-over-resize-handle"] = cls["b-resize-handle"] = cls[this.resizingItemInnerCls] = 1;
    }
  }
  onDragPointerMove(event) {
    var _dragging$context;
    const {
      client,
      dragging
    } = this, {
      visibleDateRange,
      isHorizontal
    } = client, rtl = isHorizontal && client.rtl, dimension = isHorizontal ? "X" : "Y", pageScroll = globalThis[`page${dimension}Offset`], coord = event[`page${dimension}`] + (((_dragging$context = dragging.context) === null || _dragging$context === void 0 ? void 0 : _dragging$context.offset) || 0), clientRect = Rectangle.from(client.timeAxisSubGridElement, null, true), startCoord = clientRect.getStart(rtl, isHorizontal), endCoord = clientRect.getEnd(rtl, isHorizontal);
    let date2 = client.getDateFromCoord({
      coord,
      local: false
    });
    if (rtl) {
      if (coord - pageScroll > startCoord) {
        date2 = visibleDateRange.startDate;
      } else if (coord < endCoord) {
        date2 = visibleDateRange.endDate;
      }
    } else if (coord - pageScroll < startCoord) {
      date2 = visibleDateRange.startDate;
    } else if (coord - pageScroll > endCoord) {
      date2 = visibleDateRange.endDate;
    }
    dragging.clientStartCoord = startCoord;
    dragging.clientEndCoord = endCoord;
    dragging.date = date2;
    super.onDragPointerMove(event);
  }
  get isResizing() {
    return Boolean(this.dragging);
  }
  beforeDrag(drag) {
    const {
      client
    } = this, eventRecord = client.resolveTimeSpanRecord(drag.itemElement), resourceRecord = !client.isGanttBase && client.resolveResourceRecord(client.isVertical ? drag.startEvent : drag.itemElement);
    if (this.disabled || client.readOnly || resourceRecord !== null && resourceRecord !== void 0 && resourceRecord.readOnly || eventRecord && (eventRecord.readOnly || !(eventRecord.project || eventRecord.isOccurrence)) || super.beforeDrag(drag) === false) {
      return false;
    }
    drag.mousedownDate = drag.date = client.getDateFromCoordinate(drag.event[`page${client.isHorizontal ? "X" : "Y"}`], null, false);
    return this.triggerBeforeResize(drag);
  }
  dragStart(drag) {
    var _client$features$even, _client$resolveAssign;
    const me = this, {
      client,
      tip
    } = me, {
      startEvent,
      itemElement
    } = drag, name = client.scheduledEventName, eventRecord = client.resolveEventRecord(itemElement), {
      isBatchUpdating,
      wrapStartDate,
      wrapEndDate
    } = eventRecord, useEventBuffer = (_client$features$even = client.features.eventBuffer) === null || _client$features$even === void 0 ? void 0 : _client$features$even.enabled, eventStartDate = isBatchUpdating ? eventRecord.get("startDate") : eventRecord.startDate, eventEndDate = isBatchUpdating ? eventRecord.get("endDate") : eventRecord.endDate, horizontal = me.dragLock === "x", rtl = horizontal && client.rtl, draggingEnd = me.isOverEndHandle(startEvent, itemElement), toSet = draggingEnd ? "endDate" : "startDate", wrapToSet = !useEventBuffer ? null : draggingEnd ? "wrapEndDate" : "wrapStartDate", otherEnd = draggingEnd ? "startDate" : "endDate", setMethod = draggingEnd ? "setEndDate" : "setStartDate", setOtherMethod = draggingEnd ? "setStartDate" : "setEndDate", elRect = Rectangle.from(itemElement), startCoord = horizontal ? startEvent.clientX : startEvent.clientY, endCoord = draggingEnd ? elRect.getEnd(rtl, horizontal) : elRect.getStart(rtl, horizontal), context = drag.context = {
      eventRecord,
      element: itemElement,
      timespanRecord: eventRecord,
      taskRecord: eventRecord,
      owner: me,
      valid: true,
      oldValue: draggingEnd ? eventEndDate : eventStartDate,
      startDate: eventStartDate,
      endDate: eventEndDate,
      offset: useEventBuffer ? 0 : endCoord - startCoord,
      edge: horizontal ? draggingEnd ? "right" : "left" : draggingEnd ? "bottom" : "top",
      finalize: me.finalize,
      event: drag.event,
      originalStartDate: eventStartDate,
      originalEndDate: eventEndDate,
      wrapStartDate,
      wrapEndDate,
      draggingEnd,
      toSet,
      wrapToSet,
      otherEnd,
      setMethod,
      setOtherMethod
    };
    eventRecord.meta.isResizing = true;
    client.element.classList.add(...me.dragActiveCls.split(" "));
    if (!client.listenToBatchedUpdates) {
      client.beginListeningForBatchedUpdates();
    }
    if (!isBatchUpdating) {
      me.beginEventRecordBatch(eventRecord);
    }
    me.setupProductResizeContext(context, startEvent);
    me.triggerEventResizeStart(`${name}ResizeStart`, _objectSpread2({
      [`${name}Record`]: eventRecord,
      event: startEvent
    }, me.getResizeStartParams(context)), context);
    context.resizedRecord = ((_client$resolveAssign = client.resolveAssignmentRecord) === null || _client$resolveAssign === void 0 ? void 0 : _client$resolveAssign.call(client, context.element)) || eventRecord;
    if (tip) {
      tip.show();
      tip.align = tipAlign[context.edge];
      tip.showBy(me.getTooltipTarget(drag));
    }
  }
  triggerBeforeResize(drag) {
    const {
      client
    } = this, eventRecord = client.resolveTimeSpanRecord(drag.itemElement);
    return client.trigger(`before${client.capitalizedEventName}Resize`, _objectSpread2({
      [`${client.scheduledEventName}Record`]: eventRecord,
      event: drag.event
    }, this.getBeforeResizeParams({
      event: drag.startEvent,
      element: drag.itemElement
    })));
  }
  triggerEventResizeStart(eventType, event, context) {
    var _this$client, _this$client2;
    this.client.trigger(eventType, event);
    (_this$client = (_this$client2 = this.client)[`after${StringHelper.capitalize(eventType)}`]) === null || _this$client === void 0 ? void 0 : _this$client.call(_this$client2, context, event);
  }
  triggerEventResizeEnd(eventType, event) {
    this.client.trigger(eventType, event);
  }
  triggerEventPartialResize(eventType, event) {
    this.client.trigger(eventType, event);
  }
  triggerBeforeEventResizeFinalize(eventType, event) {
    this.client.trigger(eventType, event);
  }
  dragEnter(drag) {
    var _drag$context;
    return ((_drag$context = drag.context) === null || _drag$context === void 0 ? void 0 : _drag$context.owner) === this;
  }
  resizeEventPartiallyInternal(eventRecord, context) {
    var _client$features$even2;
    const {
      client
    } = this, {
      toSet
    } = context;
    if ((_client$features$even2 = client.features.eventBuffer) !== null && _client$features$even2 !== void 0 && _client$features$even2.enabled) {
      if (toSet === "startDate") {
        const diff = context.startDate.getTime() - context.originalStartDate.getTime();
        eventRecord.wrapStartDate = new Date(context.wrapStartDate.getTime() + diff);
      } else if (toSet === "endDate") {
        const diff = context.endDate.getTime() - context.originalEndDate.getTime();
        eventRecord.wrapEndDate = new Date(context.wrapEndDate.getTime() + diff);
      }
    }
    eventRecord.set(toSet, context[toSet]);
  }
  applyDateConstraints(date2, eventRecord, context) {
    var _context$dateConstrai, _context$dateConstrai2;
    const minDate = (_context$dateConstrai = context.dateConstraints) === null || _context$dateConstrai === void 0 ? void 0 : _context$dateConstrai.start, maxDate = (_context$dateConstrai2 = context.dateConstraints) === null || _context$dateConstrai2 === void 0 ? void 0 : _context$dateConstrai2.end;
    if (minDate || maxDate) {
      date2 = DateHelper.constrain(date2, minDate, maxDate);
      context.snappedDate = DateHelper.constrain(context.snappedDate, minDate, maxDate);
    }
    return date2;
  }
  moveDrag(drag) {
    const me = this, {
      client,
      tip
    } = me, horizontal = me.dragLock === "x", dimension = horizontal ? "X" : "Y", name = client.scheduledEventName, {
      visibleDateRange,
      enableEventAnimations,
      timeAxis,
      weekStartDay
    } = client, rtl = horizontal && client.rtl, {
      resolutionUnit,
      resolutionIncrement
    } = timeAxis, {
      event,
      context
    } = drag, {
      eventRecord
    } = context, offset = context.offset * (rtl ? -1 : 1), {
      isOccurrence
    } = eventRecord, eventStart = eventRecord.get("startDate"), eventEnd = eventRecord.get("endDate"), coord = event[`client${dimension}`] + offset, clientRect = Rectangle.from(client.timeAxisSubGridElement, null, true), startCoord = clientRect.getStart(rtl, horizontal), endCoord = clientRect.getEnd(rtl, horizontal);
    context.event = event;
    if (event.isScroll) {
      drag.date = client.getDateFromCoordinate(event[`page${dimension}`] + offset, null, false);
    }
    let crossedOver, avoidedZeroSize, {
      date: date2
    } = drag, {
      toSet,
      otherEnd,
      draggingEnd
    } = context;
    if (rtl) {
      if (coord > startCoord) {
        date2 = drag.date = visibleDateRange.startDate;
      } else if (coord < endCoord) {
        date2 = drag.date = visibleDateRange.endDate;
      }
    } else if (coord < startCoord) {
      date2 = drag.date = visibleDateRange.startDate;
    } else if (coord > endCoord) {
      date2 = drag.date = visibleDateRange.endDate;
    }
    if (toSet === "endDate") {
      if (date2 < eventStart) {
        crossedOver = -1;
      }
    } else {
      if (date2 > eventEnd) {
        crossedOver = 1;
      }
    }
    if (crossedOver && me.onDragEndSwitch) {
      me.onDragEndSwitch(context, date2, crossedOver);
      otherEnd = context.otherEnd;
      toSet = context.toSet;
    }
    if (client.snapRelativeToEventStartDate) {
      date2 = timeAxis.roundDate(date2, context.oldValue);
    }
    context.snappedDate = DateHelper.round(date2, timeAxis.resolution, null, weekStartDay);
    const duration = DateHelper.diff(date2, context[otherEnd], resolutionUnit) * (draggingEnd ? -1 : 1);
    if (me.isEventDragCreate) {
      context.tooNarrow = duration < resolutionIncrement / 2;
    } else if (duration < resolutionIncrement) {
      if (me.allowResizeToZero) {
        context.snappedDate = date2 = context[otherEnd];
      } else {
        const sign = otherEnd === "startDate" ? 1 : -1;
        context.snappedDate = date2 = timeAxis.roundDate(DateHelper.add(eventRecord.get(otherEnd), resolutionIncrement * sign, resolutionUnit));
        avoidedZeroSize = true;
      }
    }
    date2 = me.applyDateConstraints(date2, eventRecord, context);
    if (!context.date || date2 - context.date || avoidedZeroSize) {
      context.date = date2;
      context[toSet] = me.showExactResizePosition || client.timeAxisViewModel.snap ? context.snappedDate : date2;
      if (!(context[toSet] - context[toSet === "startDate" ? "endDate" : "startDate"]) && !me.allowResizeToZero) {
        context.valid = false;
        return;
      }
      if (eventRecord.get(toSet) - context[toSet]) {
        context.valid = me.checkValidity(context, event);
        context.message = "";
        if (context.valid && typeof context.valid !== "boolean") {
          context.message = context.valid.message;
          context.valid = context.valid.valid;
        }
        context.valid = context.valid !== false;
        if (context.valid) {
          const partialResizeEvent = {
            [`${name}Record`]: eventRecord,
            startDate: eventStart,
            endDate: eventEnd,
            element: drag.itemElement,
            context
          };
          partialResizeEvent[toSet] = context[toSet];
          me.triggerEventPartialResize(`${name}PartialResize`, partialResizeEvent);
          if (isOccurrence) {
            eventRecord.stores.push(client.eventStore);
          }
          client.enableEventAnimations = false;
          this.resizeEventPartiallyInternal(eventRecord, context);
          client.enableEventAnimations = enableEventAnimations;
          if (isOccurrence) {
            eventRecord.stores.length = 0;
          }
        }
        if (context.tooNarrow) {
          context.valid = false;
        }
      }
    }
    if (tip) {
      tip.align = tipAlign[context.edge];
      tip.alignTo(me.getTooltipTarget(drag));
    }
    super.moveDrag(drag);
  }
  dragEnd(drag) {
    const {
      context
    } = drag;
    if (context) {
      context.event = drag.event;
    }
    if (drag.aborted) {
      context === null || context === void 0 ? void 0 : context.finalize(false);
    } else if (!this.isEventDragCreate && !drag.started && !EventHelper.getPagePoint(drag.event).equals(EventHelper.getPagePoint(drag.startEvent))) {
      this.dragStart(drag);
      this.cleanup(drag.context, false);
    }
  }
  async dragDrop({
    context,
    event
  }) {
    var _this$tip;
    context[context.toSet] = context.snappedDate;
    const {
      client
    } = this, {
      startDate,
      endDate
    } = context;
    let modified;
    (_this$tip = this.tip) === null || _this$tip === void 0 ? void 0 : _this$tip.hide();
    context.valid = startDate && endDate && (this.allowResizeToZero || endDate - startDate > 0) && context[context.toSet] - context.oldValue && context.valid !== false;
    if (context.valid) {
      this.triggerBeforeEventResizeFinalize(`before${client.capitalizedEventName}ResizeFinalize`, {
        context,
        event,
        [`${client.scheduledEventName}Record`]: context.eventRecord
      });
      modified = true;
    }
    if (!context.async) {
      await context.finalize(modified);
    }
  }
  async finalize(updateRecord) {
    const me = this.owner, context = this, {
      eventRecord,
      oldValue,
      toSet
    } = context, {
      snapRelativeToEventStartDate,
      timeAxis
    } = me.client;
    let wasChanged = false;
    if (updateRecord) {
      if (snapRelativeToEventStartDate) {
        context[toSet] = context.snappedDate = timeAxis.roundDate(context.date, oldValue);
      }
      wasChanged = await me.internalUpdateRecord(context, eventRecord);
    } else {
      me.cancelEventRecordBatch(eventRecord);
      if (eventRecord.isOccurrence) {
        eventRecord.resources.forEach((resource) => me.client.repaintEventsForResource(resource));
      }
    }
    me.cleanup(context, wasChanged);
  }
  cleanup(context, changed) {
    var _me$tip;
    const me = this, {
      client
    } = me, {
      element,
      eventRecord
    } = context, name = client.scheduledEventName;
    eventRecord.meta.isResizing = false;
    client.endListeningForBatchedUpdates();
    (_me$tip = me.tip) === null || _me$tip === void 0 ? void 0 : _me$tip.hide();
    me.unHighlightHandle(element);
    client.element.classList.remove(...me.dragActiveCls.split(" "));
    me.triggerEventResizeEnd(`${name}ResizeEnd`, _objectSpread2({
      changed,
      [`${name}Record`]: eventRecord
    }, me.getResizeEndParams(context)));
  }
  async internalUpdateRecord(context, timespanRecord) {
    const {
      client
    } = this, {
      generation
    } = timespanRecord;
    if (timespanRecord.isOccurrence) {
      client.endListeningForBatchedUpdates();
      timespanRecord[timespanRecord.batching > 1 ? "endBatch" : "cancelBatch"]();
      timespanRecord.set(TimeSpan.prototype.inSetNormalize.call(timespanRecord, {
        startDate: context.startDate,
        endDate: context.endDate
      }));
    } else {
      const toSet = {
        [context.toSet]: context[context.toSet]
      };
      if (timespanRecord.isEntity) {
        var _client$features$even3;
        const {
          startDate,
          endDate,
          draggingEnd
        } = context;
        context.duration = toSet.duration = timespanRecord.run("calculateProjectedDuration", startDate, endDate);
        toSet[context.toSet] = timespanRecord.run("calculateProjectedXDateWithDuration", draggingEnd ? startDate : endDate, draggingEnd, context.duration);
        const setOtherEnd = !timespanRecord[context.otherEnd];
        if (setOtherEnd) {
          toSet[context.otherEnd] = context[context.otherEnd];
        }
        timespanRecord.set(toSet);
        client.endListeningForBatchedUpdates();
        this.cancelEventRecordBatch(timespanRecord);
        if ((_client$features$even3 = client.features.eventBuffer) !== null && _client$features$even3 !== void 0 && _client$features$even3.enabled) {
          timespanRecord[context.wrapToSet] = null;
        }
        const promisesToWait = [];
        if (setOtherEnd) {
          promisesToWait.push(timespanRecord[context.setOtherMethod](toSet[context.otherEnd], false));
        }
        promisesToWait.push(timespanRecord[context.setMethod](toSet[context.toSet], false));
        await Promise.all(promisesToWait);
        timespanRecord.endBatch();
      } else {
        const batchChanges = Object.assign({}, timespanRecord.meta.batchChanges);
        delete batchChanges[context.toSet];
        client.endListeningForBatchedUpdates();
        this.cancelEventRecordBatch(timespanRecord);
        timespanRecord.set(batchChanges);
        timespanRecord[context.setMethod](toSet[context.toSet], false);
      }
    }
    await client.project.commitAsync();
    return timespanRecord.generation !== generation;
  }
  onDragItemMouseMove(event) {
    if (event.pointerType !== "touch" && !this.handleSelector) {
      this.checkResizeHandles(event);
    }
  }
  checkResizeHandles(event) {
    const me = this, {
      overItem
    } = me;
    if (overItem && !me.client.readOnly && (!me.allowResize || me.allowResize(overItem, event))) {
      const eventRecord = me.client.resolveTimeSpanRecord(overItem);
      if (eventRecord !== null && eventRecord !== void 0 && eventRecord.readOnly) {
        return;
      }
      if (me.isOverAnyHandle(event, overItem)) {
        me.highlightHandle();
      } else {
        me.unHighlightHandle();
      }
    }
  }
  onDragItemMouseLeave(event, oldOverItem) {
    this.unHighlightHandle(oldOverItem);
  }
  highlightHandle() {
    var _item$syncIdMap$clien, _item$syncIdMap;
    const {
      overItem: item,
      client
    } = this, handleTargetElement = (_item$syncIdMap$clien = (_item$syncIdMap = item.syncIdMap) === null || _item$syncIdMap === void 0 ? void 0 : _item$syncIdMap[client.scheduledEventName]) !== null && _item$syncIdMap$clien !== void 0 ? _item$syncIdMap$clien : item.querySelector(client.eventInnerSelector);
    handleTargetElement.classList.add("b-resize-handle");
    item.classList.add("b-over-resize-handle");
  }
  unHighlightHandle(item = this.overItem) {
    if (item) {
      var _item$syncIdMap$me$cl, _item$syncIdMap2;
      const me = this, inner = (_item$syncIdMap$me$cl = (_item$syncIdMap2 = item.syncIdMap) === null || _item$syncIdMap2 === void 0 ? void 0 : _item$syncIdMap2[me.client.scheduledEventName]) !== null && _item$syncIdMap$me$cl !== void 0 ? _item$syncIdMap$me$cl : item.querySelector(me.client.eventInnerSelector);
      if (inner) {
        inner.classList.remove("b-resize-handle", me.resizingItemInnerCls);
      }
      item.classList.remove("b-over-resize-handle", me.draggingItemCls);
    }
  }
  isOverAnyHandle(event, target) {
    return this.isOverStartHandle(event, target) || this.isOverEndHandle(event, target);
  }
  isOverStartHandle(event, target) {
    var _this$getHandleRect;
    return (_this$getHandleRect = this.getHandleRect("start", event, target)) === null || _this$getHandleRect === void 0 ? void 0 : _this$getHandleRect.contains(EventHelper.getPagePoint(event));
  }
  isOverEndHandle(event, target) {
    var _this$getHandleRect2;
    return (_this$getHandleRect2 = this.getHandleRect("end", event, target)) === null || _this$getHandleRect2 === void 0 ? void 0 : _this$getHandleRect2.contains(EventHelper.getPagePoint(event));
  }
  getHandleRect(side, event, eventEl) {
    if (this.overItem) {
      eventEl = event.target.closest(`.${this.client.eventCls}`) || eventEl.querySelector(`.${this.client.eventCls}`);
      if (!eventEl) {
        return;
      }
      const me = this, start = side === "start", {
        client
      } = me, rtl = Boolean(client.rtl), axis = me.dragLock, horizontal = axis === "x", dim = horizontal ? "width" : "height", handleSpec = `${horizontal ? start && !rtl ? "left" : "right" : start ? "top" : "bottom"}Handle`, {
        offsetWidth
      } = eventEl, timespanRecord = client.resolveTimeSpanRecord(eventEl), resizable = timespanRecord === null || timespanRecord === void 0 ? void 0 : timespanRecord.isResizable, eventRect = Rectangle.from(eventEl), result = eventRect.clone(), handleStyle = window.getComputedStyle(eventEl, ":before"), touchHandleSize = !me.handleSelector && !BrowserHelper.isHoverableDevice ? me.touchHandleSize : void 0, handleSize = touchHandleSize || me.handleSize || parseFloat(handleStyle[dim]), handleVisThresh = me.handleVisibilityThreshold || 2 * me.handleSize, centerGap = me.dynamicHandleSize ? me.reservedSpace / 2 : 0, deflateArgs = [0, 0, 0, 0];
      if (!me.disabled && me[handleSpec] && (offsetWidth >= handleVisThresh || me.dynamicHandleSize) && (resizable === true || resizable === side)) {
        const oppositeEnd = !horizontal && !start || horizontal && rtl === start;
        if (oppositeEnd) {
          result[axis] += eventRect[dim] - handleSize;
          deflateArgs[horizontal ? 3 : 0] = eventRect[dim] / 2 + centerGap;
        } else {
          deflateArgs[horizontal ? 1 : 2] = eventRect[dim] / 2 + centerGap;
        }
        eventRect.deflate(...deflateArgs);
        result[dim] = handleSize;
        result.constrainTo(eventRect);
        if (result[dim]) {
          return result;
        }
      }
    }
  }
  setupDragContext(event) {
    const me = this;
    if (me.overItem && me.isOverAnyHandle(event, me.overItem) && me.isElementResizable(me.overItem, event)) {
      const result = super.setupDragContext(event);
      result.scrollManager = me.client.scrollManager;
      return result;
    }
  }
  changeHandleSize() {
    VersionHelper.deprecate("Scheduler", "6.0.0", "Handle size is from CSS");
  }
  changeTouchHandleSize() {
    VersionHelper.deprecate("Scheduler", "6.0.0", "Handle size is from CSS");
  }
  changeTip(tip, oldTip) {
    const me = this;
    if (!me.showTooltip) {
      return null;
    }
    if (tip) {
      if (tip.isTooltip) {
        tip.owner = me;
      } else {
        tip = Tooltip.reconfigure(oldTip, Tooltip.mergeConfigs({
          id: me.tipId
        }, tip, {
          getHtml: me.getTipHtml.bind(me),
          owner: me.client
        }, me.tip), {
          owner: me,
          defaults: {
            type: "tooltip"
          }
        });
      }
      tip.ion({
        innerhtmlupdate: "updateDateIndicator",
        thisObj: me
      });
      me.clockTemplate = new ClockTemplate({
        scheduler: me.client
      });
    } else if (oldTip) {
      var _me$clockTemplate;
      oldTip.destroy();
      (_me$clockTemplate = me.clockTemplate) === null || _me$clockTemplate === void 0 ? void 0 : _me$clockTemplate.destroy();
    }
    return tip;
  }
  isElementResizable(element, event) {
    var _element$syncIdMap$cl, _element;
    const me = this, {
      client
    } = me, timespanRecord = client.resolveTimeSpanRecord(element);
    if (client.readOnly) {
      return false;
    }
    let resizable = timespanRecord === null || timespanRecord === void 0 ? void 0 : timespanRecord.isResizable;
    const handleHoldingElement = (_element$syncIdMap$cl = (_element = element) === null || _element === void 0 ? void 0 : _element.syncIdMap[client.scheduledEventName]) !== null && _element$syncIdMap$cl !== void 0 ? _element$syncIdMap$cl : element, handleEl = event.target.closest('[class$="-handle"]');
    if (!resizable || handleEl && handleEl !== handleHoldingElement) {
      return false;
    }
    element = event.target.closest(me.dragSelector);
    if (!element) {
      return false;
    }
    const startsOutside = element.classList.contains("b-sch-event-startsoutside"), endsOutside = element.classList.contains("b-sch-event-endsoutside");
    if (resizable === true) {
      if (startsOutside && endsOutside) {
        return false;
      } else if (startsOutside) {
        resizable = "end";
      } else if (endsOutside) {
        resizable = "start";
      } else {
        return me.isOverStartHandle(event, element) || me.isOverEndHandle(event, element);
      }
    }
    if (startsOutside && resizable === "start" || endsOutside && resizable === "end") {
      return false;
    }
    if (me.isOverStartHandle(event, element) && resizable === "start" || me.isOverEndHandle(event, element) && resizable === "end") {
      return true;
    }
    return false;
  }
  updateDateIndicator() {
    const {
      clockTemplate
    } = this, {
      eventRecord,
      draggingEnd,
      snappedDate
    } = this.dragging.context, startDate = draggingEnd ? eventRecord.get("startDate") : snappedDate, endDate = draggingEnd ? snappedDate : eventRecord.get("endDate"), {
      element
    } = this.tip;
    clockTemplate.updateDateIndicator(element.querySelector(".b-sch-tooltip-startdate"), startDate);
    clockTemplate.updateDateIndicator(element.querySelector(".b-sch-tooltip-enddate"), endDate);
  }
  getTooltipTarget({
    itemElement,
    context
  }) {
    const me = this, {
      rtl
    } = me.client, target = Rectangle.from(itemElement, null, true);
    if (me.dragLock === "x") {
      if (!rtl && context.edge === "right" || rtl && context.edge === "left") {
        target.x = target.right - 1;
      } else {
        target.x -= me.tip.anchorSize[0] / 2;
      }
      target.width = me.tip.anchorSize[0] / 2;
    } else {
      if (context.edge === "bottom") {
        target.y = target.bottom - 1;
      }
      target.height = me.tip.anchorSize[1] / 2;
    }
    return {
      target
    };
  }
  basicValidityCheck(context, event) {
    return context.startDate && (context.endDate > context.startDate || this.allowResizeToZero) && this.validatorFn.call(this.validatorFnThisObj || this, context, event);
  }
  getTipHtml({
    tip
  }) {
    const me = this, {
      startDate,
      endDate,
      toSet,
      snappedDate,
      valid,
      message = "",
      timespanRecord
    } = me.dragging.context;
    if (!startDate || !endDate) {
      return tip.html;
    }
    const tipData = {
      record: timespanRecord,
      valid,
      message,
      startDate,
      endDate,
      [toSet]: snappedDate
    };
    tipData.startText = me.client.getFormattedDate(tipData.startDate);
    tipData.endText = me.client.getFormattedDate(tipData.endDate);
    tipData.startClockHtml = me.clockTemplate.template({
      date: tipData.startDate,
      text: tipData.startText,
      cls: "b-sch-tooltip-startdate"
    });
    tipData.endClockHtml = me.clockTemplate.template({
      date: tipData.endDate,
      text: tipData.endText,
      cls: "b-sch-tooltip-enddate"
    });
    return me.tooltipTemplate(tipData);
  }
  beginEventRecordBatch(eventRecord) {
    eventRecord.beginBatch();
  }
  cancelEventRecordBatch(eventRecord) {
    eventRecord.cancelBatch();
  }
  getBeforeResizeParams(context) {
    const {
      client
    } = this;
    return {
      resourceRecord: client.resolveResourceRecord(client.isVertical ? context.event : context.element)
    };
  }
  getResizeStartParams(context) {
    return {
      resourceRecord: context.resourceRecord
    };
  }
  getResizeEndParams(context) {
    return {
      resourceRecord: context.resourceRecord,
      event: context.event
    };
  }
  setupProductResizeContext(context, event) {
    var _client$resolveResour, _client$resolveAssign2, _client$getDateConstr;
    const {
      client
    } = this, {
      element
    } = context, eventRecord = client.resolveEventRecord(element), resourceRecord = (_client$resolveResour = client.resolveResourceRecord) === null || _client$resolveResour === void 0 ? void 0 : _client$resolveResour.call(client, element), assignmentRecord = (_client$resolveAssign2 = client.resolveAssignmentRecord) === null || _client$resolveAssign2 === void 0 ? void 0 : _client$resolveAssign2.call(client, element);
    Object.assign(context, {
      eventRecord,
      taskRecord: eventRecord,
      resourceRecord,
      assignmentRecord,
      dateConstraints: (_client$getDateConstr = client.getDateConstraints) === null || _client$getDateConstr === void 0 ? void 0 : _client$getDateConstr.call(client, resourceRecord, eventRecord)
    });
  }
  checkValidity(context, event) {
    return (this.client.allowOverlap || this.client.isDateRangeAvailable(context.startDate, context.endDate, context.eventRecord, context.resourceRecord)) && this.basicValidityCheck(context, event);
  }
  get tipId() {
    return `${this.client.id}-event-resize-tip`;
  }
};
EventResize._$name = "EventResize";
GridFeatureManager.registerFeature(EventResize, true, "Scheduler");
GridFeatureManager.registerFeature(EventResize, false, "ResourceHistogram");
var getDragCreateDragDistance = function(event) {
  var _this$source, _this$source$client$f;
  if ((_this$source = this.source) !== null && _this$source !== void 0 && (_this$source$client$f = _this$source.client.features.taskEdit) !== null && _this$source$client$f !== void 0 && _this$source$client$f._canceling) {
    return false;
  }
  return EventHelper.getDistanceBetween(this.startEvent, event);
};
var DragCreateBase = class extends EventResize {
  construct(scheduler, config) {
    if ((config === null || config === void 0 ? void 0 : config.showTooltip) === false) {
      config.tip = null;
    }
    super.construct(...arguments);
  }
  changeValidatorFn(validatorFn) {
    this.createValidatorFn = validatorFn;
  }
  render() {
    const me = this, {
      client
    } = me;
    me.dragRootElement = me.dropRootElement = client.timeAxisSubGridElement;
    me.dragLock = client.isVertical ? "y" : "x";
  }
  onDragEndSwitch(context) {
    const {
      client
    } = this, {
      enableEventAnimations
    } = client, {
      eventRecord,
      draggingEnd
    } = context, horizontal = this.dragLock === "x", {
      initialDate
    } = this.dragging;
    client.enableEventAnimations = false;
    eventRecord.set({
      startDate: initialDate,
      endDate: initialDate
    });
    if (draggingEnd) {
      Object.assign(context, {
        endDate: initialDate,
        toSet: "startDate",
        otherEnd: "endDate",
        setMethod: "setStartDate",
        setOtherMethod: "setEndDate",
        edge: horizontal ? "left" : "top"
      });
    } else {
      Object.assign(context, {
        startDate: initialDate,
        toSet: "endDate",
        otherEnd: "startDate",
        setMethod: "setEndDate",
        setOtherMethod: "setStartDate",
        edge: horizontal ? "right" : "bottom"
      });
    }
    context.draggingEnd = this.draggingEnd = !draggingEnd;
    client.enableEventAnimations = enableEventAnimations;
  }
  beforeDrag(drag) {
    const me = this, result = super.beforeDrag(drag), {
      pan,
      eventDragSelect
    } = me.client.features;
    if (result !== false && (me.preventMultiple && !me.isRowEmpty(drag.rowRecord) || me.disabled || pan && !pan.disabled || eventDragSelect && !eventDragSelect.disabled)) {
      return false;
    }
    return result;
  }
  startDrag(drag) {
    const result = super.startDrag(drag);
    if (result !== false) {
      const {
        context
      } = drag;
      drag.initialDate = context.eventRecord.get(this.draggingEnd ? "startDate" : "endDate");
      this.client.trigger("dragCreateStart", {
        proxyElement: drag.element,
        eventElement: drag.element,
        eventRecord: context.eventRecord,
        resourceRecord: context.resourceRecord
      });
      drag.context.offset = 0;
      drag.context.oldValue = drag.mousedownDate;
    }
    return result;
  }
  isOverEndHandle() {
    return this.draggingEnd;
  }
  setupDragContext(event) {
    const {
      client
    } = this;
    if (client.matchScheduleCell(event.target)) {
      var _client$resolveResour;
      const resourceRecord = (_client$resolveResour = client.resolveResourceRecord(event)) === null || _client$resolveResour === void 0 ? void 0 : _client$resolveResour.$original;
      if (resourceRecord && !resourceRecord.isSpecialRow) {
        const result = Draggable().prototype.setupDragContext.call(this, event), scrollables = [];
        if (client.isVertical) {
          scrollables.push({
            element: client.scrollable.element,
            direction: "vertical"
          });
        } else {
          scrollables.push({
            element: client.timeAxisSubGrid.scrollable.element,
            direction: "horizontal"
          });
        }
        result.scrollManager = client.scrollManager;
        result.monitoringConfig = {
          scrollables
        };
        result.resourceRecord = result.rowRecord = resourceRecord;
        result.getDistance = getDragCreateDragDistance;
        return result;
      }
    }
  }
  async dragDrop({
    context,
    event
  }) {
    var _this$tip;
    context[context.toSet] = context.snappedDate;
    const {
      client
    } = this, {
      startDate,
      endDate,
      eventRecord
    } = context, {
      generation
    } = eventRecord;
    let modified;
    (_this$tip = this.tip) === null || _this$tip === void 0 ? void 0 : _this$tip.hide();
    await client.project.commitAsync();
    if (eventRecord.generation !== generation) {
      context.eventRecord[context.toSet] = context.oldValue;
      context.eventRecord[context.toSet] = context[context.toSet];
    }
    context.valid = startDate && endDate && endDate - startDate > 0 && context[context.toSet] - context.oldValue && context.valid !== false;
    if (context.valid) {
      client.trigger("beforeDragCreateFinalize", {
        context,
        event,
        proxyElement: context.element,
        eventElement: context.element,
        eventRecord: context.eventRecord,
        resourceRecord: context.resourceRecord
      });
      modified = true;
    }
    if (!context.async) {
      await context.finalize(modified);
    }
  }
  updateDragTolerance(dragTolerance) {
    this.dragThreshold = dragTolerance;
  }
  changeTip(tip, oldTip) {
    return super.changeTip(!tip || tip.isTooltip ? tip : ObjectHelper.assign({
      id: `${this.client.id}-drag-create-tip`
    }, tip), oldTip);
  }
  async finalize(doCreate) {
    const me = this.owner, context = this, completeFinalization = () => {
      if (!me.isDestroyed) {
        me.client.trigger("afterDragCreate", {
          proxyElement: context.element,
          eventElement: context.element,
          eventRecord: context.eventRecord,
          resourceRecord: context.resourceRecord
        });
        me.cleanup(context);
      }
    };
    if (doCreate) {
      await me.finalizeDragCreate(context);
      completeFinalization();
    } else {
      var _me$onAborted;
      (_me$onAborted = me.onAborted) === null || _me$onAborted === void 0 ? void 0 : _me$onAborted.call(me, context);
      completeFinalization();
    }
  }
  async finalizeDragCreate(context) {
    var _this$client;
    await this.internalUpdateRecord(context, context.eventRecord);
    this.client.trigger("dragCreateEnd", {
      eventRecord: context.eventRecord,
      resourceRecord: context.resourceRecord,
      event: context.event,
      eventElement: context.element
    });
    (_this$client = this.client) === null || _this$client === void 0 ? void 0 : _this$client.trigger("eventAutoCreated", {
      eventRecord: context.eventRecord,
      resourceRecord: context.resourceRecord
    });
  }
  cleanup(context) {
    var _this$tip2;
    const {
      client
    } = this, {
      eventRecord
    } = context;
    eventRecord.meta.isResizing = false;
    client.endListeningForBatchedUpdates();
    (_this$tip2 = this.tip) === null || _this$tip2 === void 0 ? void 0 : _this$tip2.hide();
    client.element.classList.remove(...this.dragActiveCls.split(" "));
    context.element.parentElement.classList.remove("b-sch-dragcreating");
  }
  onElementContextMenu() {
    if (this.proxy) {
      return false;
    }
  }
  prepareCreateContextForFinalization(createContext, event, finalize, async = false) {
    return _objectSpread2(_objectSpread2({}, createContext), {}, {
      async,
      event,
      finalize
    });
  }
  onEventDataGenerated(renderData) {
    var _this$dragging, _this$dragging$contex;
    if (((_this$dragging = this.dragging) === null || _this$dragging === void 0 ? void 0 : (_this$dragging$contex = _this$dragging.context) === null || _this$dragging$contex === void 0 ? void 0 : _this$dragging$contex.eventRecord) === renderData.eventRecord) {
      renderData.wrapperCls["b-sch-dragcreating"] = true;
      renderData.wrapperCls["b-too-narrow"] = this.dragging.context.tooNarrow;
    }
  }
  triggerBeforeResize() {
  }
  triggerEventResizeStart() {
  }
  checkValidity(context, event) {
    throw new Error("Implement in subclass");
  }
  triggerDragCreateEnd(newRecord, context) {
    throw new Error("Implement in subclass");
  }
  handleBeforeDragCreate(dateTime, event) {
    throw new Error("Implement in subclass");
  }
  isRowEmpty(rowRecord) {
    throw new Error("Implement in subclass");
  }
};
_defineProperty(DragCreateBase, "configurable", {
  showTooltip: true,
  dragTolerance: 2,
  preventMultiple: false,
  dragTouchStartDelay: 300,
  validatorFnThisObj: null,
  tipTemplate: (data) => `
            <div class="b-sch-tip-${data.valid ? "valid" : "invalid"}">
                ${data.startClockHtml}
                ${data.endClockHtml}
                <div class="b-sch-tip-message">${data.message}</div>
            </div>
        `,
  dragActiveCls: "b-dragcreating"
});
_defineProperty(DragCreateBase, "pluginConfig", {
  chain: ["render", "onEventDataGenerated"],
  before: ["onElementContextMenu"]
});
DragCreateBase._$name = "DragCreateBase";
var DH = DateHelper;
var scheduleFields = ["startDate", "endDate", "resource", "recurrenceRule"];
var makeDate = (fields) => {
  if (fields.length === 1)
    return fields[0].value;
  else if (fields.length === 2) {
    const [date2, time] = fields[0] instanceof DateField ? fields : fields.reverse(), dateValue = DH.parse(date2.value);
    if (dateValue && time.value) {
      dateValue.setHours(time.value.getHours(), time.value.getMinutes(), time.value.getSeconds(), time.value.getMilliseconds());
    }
    return dateValue ? DateHelper.clone(dateValue) : null;
  }
  return null;
};
var copyTime = (dateTo, dateFrom) => {
  const d = new Date(dateTo.getTime());
  d.setHours(dateFrom.getHours(), dateFrom.getMinutes());
  return d;
};
var adjustEndDate = (startDate, startTime, me) => {
  if (startDate && startTime && me.endDateField && me.endTimeField) {
    const newEndDate = DH.add(copyTime(me.startDateField.value, me.startTimeField.value), me.eventRecord.durationMS, "milliseconds");
    me.endDateField.value = newEndDate;
    me.endTimeField.value = DH.clone(newEndDate);
  }
};
var EditBase = class extends InstancePlugin {
  static get configurable() {
    return {
      saveAndCloseOnEnter: true,
      triggerEvent: null,
      dateFormat: "L",
      timeFormat: "LT",
      editorConfig: null,
      items: null,
      weekStartDay: null
    };
  }
  construct(client, config) {
    const me = this;
    client.eventEdit = me;
    super.construct(client, ObjectHelper.assign({
      weekStartDay: client.weekStartDay
    }, config));
    me.clientListenersDetacher = client.ion({
      [me.triggerEvent]: "onActivateEditor",
      dragCreateEnd: "onDragCreateEnd",
      eventAutoCreated: "onEventAutoCreated",
      thisObj: me
    });
  }
  doDestroy() {
    var _this$_editor;
    this.clientListenersDetacher();
    (_this$_editor = this._editor) === null || _this$_editor === void 0 ? void 0 : _this$_editor.destroy();
    super.doDestroy();
  }
  onEventAutoCreated() {
  }
  changeEditorConfig(editorConfig) {
    const {
      items: items2
    } = this;
    if (items2) {
      editorConfig = Objects.clone(editorConfig);
      editorConfig.items = Config.merge(items2, editorConfig.items);
    }
    return editorConfig;
  }
  changeItems(items2) {
    this.cleanItemsConfig(items2);
    return items2;
  }
  cleanItemsConfig(items2) {
    for (const ref in items2) {
      const itemCfg = items2[ref];
      if (itemCfg === true) {
        delete items2[ref];
      } else if (itemCfg !== null && itemCfg !== void 0 && itemCfg.items) {
        this.cleanItemsConfig(itemCfg.items);
      }
    }
  }
  onDatesChange(params) {
    var _me$startTimeField, _me$startDateField2;
    const me = this, field = params.source, value = params.value;
    if (me.startDateField && me.endDateField) {
      me.endDateField.min = me.startDateField.value;
    }
    if (me.endTimeField) {
      var _me$startDateField, _me$endDateField;
      if (DH.isEqual(DH.clearTime((_me$startDateField = me.startDateField) === null || _me$startDateField === void 0 ? void 0 : _me$startDateField.value), DH.clearTime((_me$endDateField = me.endDateField) === null || _me$endDateField === void 0 ? void 0 : _me$endDateField.value))) {
        me.endTimeField.min = me.startTimeField.value;
      } else {
        me.endTimeField.min = null;
      }
    }
    switch (field.ref) {
      case "startDateField":
        ((_me$startTimeField = me.startTimeField) === null || _me$startTimeField === void 0 ? void 0 : _me$startTimeField.value) && adjustEndDate(value, me.startTimeField.value, me);
        break;
      case "startTimeField":
        ((_me$startDateField2 = me.startDateField) === null || _me$startDateField2 === void 0 ? void 0 : _me$startDateField2.value) && adjustEndDate(me.startDateField.value, value, me);
        break;
    }
  }
  async save() {
    throw new Error("Implement in subclass");
  }
  get values() {
    const me = this, {
      editor
    } = me, startFields = [], endFields = [], {
      values
    } = editor;
    scheduleFields.forEach((f) => delete values[f]);
    editor.eachWidget((widget) => {
      var _editor$widgetMap$rec;
      const {
        name
      } = widget;
      if (!name || widget.hidden || widget.up((w) => w === me.recurrenceEditor)) {
        delete values[name];
        return;
      }
      switch (name) {
        case "startDate":
          startFields.push(widget);
          break;
        case "endDate":
          endFields.push(widget);
          break;
        case "resource":
          values[name] = widget.record;
          break;
        case "recurrenceRule":
          values[name] = ((_editor$widgetMap$rec = editor.widgetMap.recurrenceCombo) === null || _editor$widgetMap$rec === void 0 ? void 0 : _editor$widgetMap$rec.value) === "none" ? "" : widget.value;
          break;
      }
    }, true);
    if (values.allDay && !me.eventRecord.allDay) {
      startFields.push(me.startTimeField);
      endFields.push(me.endTimeField);
    }
    if (startFields.length) {
      values.startDate = makeDate(startFields);
    }
    if (endFields.length) {
      values.endDate = makeDate(endFields);
    }
    if ("startDate" in values && "endDate" in values) {
      values.duration = DH.diff(values.startDate, values.endDate, me.editor.record.durationUnit, true);
    }
    return values;
  }
  onBeforeSave(eventRecord) {
  }
  onAfterSave(eventRecord) {
  }
  updateRecord(record) {
    const {
      values
    } = this;
    if (this.assignmentStore) {
      delete values.resource;
    }
    return record.set(values);
  }
  onBeforeEditorShow() {
    const {
      eventRecord,
      editor
    } = this.editingContext, {
      nameField
    } = editor.widgetMap;
    if (nameField && eventRecord.isCreating) {
      editor.assigningValues = true;
      nameField.value = "";
      editor.assigningValues = false;
      nameField._configuredPlaceholder = nameField.placeholder;
      nameField.placeholder = eventRecord.name;
    }
  }
  resetEditingContext() {
    const me = this;
    if (!me.editingContext) {
      return;
    }
    const {
      client
    } = me, {
      editor,
      eventRecord
    } = me.editingContext, {
      eventStore
    } = client, {
      nameField
    } = editor.widgetMap;
    if (eventRecord.isCreating) {
      if (client.isTimelineBase) {
        var _me$editingContext$ev;
        (_me$editingContext$ev = me.editingContext.eventElement) === null || _me$editingContext$ev === void 0 ? void 0 : _me$editingContext$ev.closest("[data-event-id]").classList.add("b-released");
      }
      eventStore.remove(eventRecord);
      eventRecord.isCreating = false;
    }
    if (nameField) {
      nameField.placeholder = nameField._configuredPlaceholder;
    }
    client.element.classList.remove("b-eventeditor-editing");
    me.targetEventElement = me.editingContext = editor._record = null;
  }
  onPopupKeyDown({
    event
  }) {
    const me = this;
    if (!me.readOnly && event.key === "Enter" && me.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === "input") {
      event.preventDefault();
      if (event.target.name === "startDate") {
        me.startTimeField && adjustEndDate(me.startDateField.value, me.startTimeField.value, me);
      }
      me.onSaveClick();
    }
  }
  async onSaveClick() {
    this.editor.focus();
    const saved = await this.save();
    if (saved) {
      this.editor.close();
      this.client.trigger("afterEventEdit");
    }
    return saved;
  }
  async onDeleteClick() {
    const removed = await this.deleteEvent();
    if (removed) {
      const {
        editor
      } = this;
      if (!editor.autoClose || editor.containsFocus) {
        editor.close();
      }
      this.client.trigger("afterEventEdit");
    }
  }
  onCancelClick() {
    this.editor.close();
    this.client.trigger("afterEventEdit");
  }
};
EditBase._$name = "EditBase";
var ResourceTimeRangesBase = class extends InstancePlugin.mixin(AttachToProjectMixin) {
  static get pluginConfig() {
    return {
      chain: ["getEventsToRender", "onEventDataGenerated", "noFeatureElementsInAxis"],
      override: ["resolveResourceRecord"]
    };
  }
  noFeatureElementsInAxis() {
    const {
      timeAxis
    } = this.client;
    return !this.needsRefresh && this.store && !this.store.storage.values.some((t) => timeAxis.isTimeSpanInAxis(t));
  }
  doDisable(disable) {
    if (this.client.isPainted) {
      this.client.refresh();
    }
    super.doDisable(disable);
  }
  updateTabIndex() {
    if (!this.isConfiguring) {
      this.client.refresh();
    }
  }
  getEventsToRender(resource, events) {
    throw new Error("Implement in subclass");
  }
  onEventDataGenerated(renderData) {
    const me = this, {
      eventRecord,
      iconCls
    } = renderData;
    if (me.shouldInclude(eventRecord)) {
      if (me.client.isVertical) {
        renderData.width = renderData.resourceRecord.columnWidth || me.client.resourceColumnWidth;
      } else {
        renderData.top = 0;
      }
      renderData.fillSize = true;
      renderData.wrapperCls[me.rangeCls] = 1;
      renderData.wrapperCls[`b-sch-color-${eventRecord.timeRangeColor}`] = eventRecord.timeRangeColor;
      renderData.eventContent.text = eventRecord.name;
      renderData.children.push(renderData.eventContent);
      renderData.tabIndex = me.tabIndex != null ? String(me.tabIndex) : null;
      if ((iconCls === null || iconCls === void 0 ? void 0 : iconCls.length) > 0) {
        renderData.children.unshift({
          tag: "i",
          className: iconCls.toString()
        });
      }
      renderData.eventId = me.generateElementId(eventRecord);
    }
  }
  generateElementId(record) {
    return record.domId;
  }
  resolveResourceTimeRangeRecord(rangeElement) {
    var _rangeElement$closest;
    return rangeElement === null || rangeElement === void 0 ? void 0 : (_rangeElement$closest = rangeElement.closest(`.${this.rangeCls}`)) === null || _rangeElement$closest === void 0 ? void 0 : _rangeElement$closest.elementData.eventRecord;
  }
  getElementFromResourceTimeRangeRecord(record) {
    return this.client.foregroundCanvas.syncIdMap[record.domId];
  }
  resolveResourceRecord(event) {
    var _this$resolveResource;
    const record = this.overridden.resolveResourceRecord(...arguments);
    return record || ((_this$resolveResource = this.resolveResourceTimeRangeRecord(event.target || event)) === null || _this$resolveResource === void 0 ? void 0 : _this$resolveResource.resource);
  }
  shouldInclude(eventRecord) {
    throw new Error("Implement in subclass");
  }
  onStoreChange(event) {
    if (event.action === "removeall" || event.action === "dataset") {
      this.needsRefresh = true;
    }
    this.client.onInternalEventStoreChange(event);
    this.needsRefresh = false;
  }
};
_defineProperty(ResourceTimeRangesBase, "configurable", {
  tabIndex: null
});
ResourceTimeRangesBase.featureClass = "";
ResourceTimeRangesBase._$name = "ResourceTimeRangesBase";
var TimeSpanMenuBase = class extends ContextMenuBase {
};
TimeSpanMenuBase._$name = "TimeSpanMenuBase";
var TooltipBase = class extends InstancePlugin {
  static get defaultConfig() {
    return {
      autoUpdate: false,
      hoverDelay: 250,
      hideDelay: 100,
      template: null,
      cls: null,
      align: {
        align: "b-t"
      },
      clockTemplate: null,
      monitorRecordUpdate: null,
      testConfig: {
        hoverDelay: 0
      }
    };
  }
  static get pluginConfig() {
    return {
      chain: ["onPaint"]
    };
  }
  construct(client, config) {
    const me = this;
    config = me.processConfig(config);
    super.construct(client, config);
    if (!me.forSelector) {
      me.forSelector = `${client.eventInnerSelector}:not(.b-dragproxy)`;
    }
    me.clockTemplate = new ClockTemplate({
      scheduler: client
    });
    client.ion({
      [`before${client.scheduledEventName}drag`]: () => {
        var _me$tooltip;
        (_me$tooltip = me.tooltip) === null || _me$tooltip === void 0 ? void 0 : _me$tooltip.hide();
      }
    });
  }
  processConfig(config) {
    if (typeof config === "function") {
      return {
        template: config
      };
    }
    return config;
  }
  setConfig(config) {
    super.setConfig(this.processConfig(config));
  }
  doDestroy() {
    this.destroyProperties("clockTemplate", "tooltip");
    super.doDestroy();
  }
  doDisable(disable) {
    if (this.tooltip) {
      this.tooltip.disabled = disable;
    }
    super.doDisable(disable);
  }
  onPaint({
    firstPaint
  }) {
    if (firstPaint) {
      var _me$tooltip2;
      const me = this, {
        client
      } = me, ignoreSelector = [".b-dragselecting", ".b-eventeditor-editing", ".b-taskeditor-editing", ".b-resizing-event", ".b-task-percent-bar-resizing-task", ".b-dragcreating", `.b-dragging-${client.scheduledEventName}`, ".b-creating-dependency", ".b-dragproxy"].map((cls) => `:not(${cls})`).join("");
      (_me$tooltip2 = me.tooltip) === null || _me$tooltip2 === void 0 ? void 0 : _me$tooltip2.destroy();
      me.tooltip = new Tooltip(_objectSpread2(_objectSpread2({
        axisLock: "flexible",
        id: me.tipId || `${me.client.id}-event-tip`,
        cls: me.tipCls,
        forSelector: `.b-timelinebase${ignoreSelector} .b-grid-body-container:not(.b-scrolling) ${me.forSelector}`,
        scrollAction: "realign",
        forElement: client.timeAxisSubGridElement,
        showOnHover: true,
        anchorToTarget: true,
        getHtml: me.getTipHtml.bind(me),
        disabled: me.disabled
      }, me.config), {}, {
        internalListeners: me.configuredListeners
      }));
      me.tooltip.ion({
        innerhtmlupdate: "updateDateIndicator",
        overtarget: "onOverNewTarget",
        show: "onTipShow",
        hide: "onTipHide",
        thisObj: me
      });
    }
  }
  processConfiguredListeners() {
  }
  addListener(...args) {
    var _this$tooltip;
    const defaultDetacher = super.addListener(...args), tooltipDetacher = (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.addListener(...args);
    if (defaultDetacher || tooltipDetacher) {
      return () => {
        defaultDetacher === null || defaultDetacher === void 0 ? void 0 : defaultDetacher();
        tooltipDetacher === null || tooltipDetacher === void 0 ? void 0 : tooltipDetacher();
      };
    }
  }
  removeListener(...args) {
    var _this$tooltip2;
    super.removeListener(...args);
    (_this$tooltip2 = this.tooltip) === null || _this$tooltip2 === void 0 ? void 0 : _this$tooltip2.removeListener(...args);
  }
  updateDateIndicator() {
    const me = this, tip = me.tooltip, endDateElement = tip.element.querySelector(".b-sch-tooltip-enddate");
    if (!me.record) {
      return;
    }
    me.clockTemplate.updateDateIndicator(tip.element, me.record.startDate);
    endDateElement && me.clockTemplate.updateDateIndicator(endDateElement, me.record.endDate);
  }
  resolveTimeSpanRecord(forElement) {
    return this.client.resolveTimeSpanRecord(forElement);
  }
  getTipHtml({
    tip,
    activeTarget
  }) {
    const me = this, {
      client
    } = me, recordProp = me.recordType || `${client.scheduledEventName}Record`, timeSpanRecord = me.resolveTimeSpanRecord(activeTarget);
    if ((timeSpanRecord === null || timeSpanRecord === void 0 ? void 0 : timeSpanRecord.startDate) instanceof Date) {
      const {
        startDate,
        endDate
      } = timeSpanRecord, startText = client.getFormattedDate(startDate), endDateValue = client.getDisplayEndDate(endDate, startDate), endText = client.getFormattedDate(endDateValue);
      tip.eventRecord = timeSpanRecord;
      return me.template({
        tip,
        [`${recordProp}`]: timeSpanRecord,
        startDate,
        endDate,
        startText,
        endText,
        startClockHtml: me.clockTemplate.template({
          date: startDate,
          text: startText,
          cls: "b-sch-tooltip-startdate"
        }),
        endClockHtml: timeSpanRecord.isMilestone ? "" : me.clockTemplate.template({
          date: endDateValue,
          text: endText,
          cls: "b-sch-tooltip-enddate"
        })
      });
    } else {
      tip.hide();
      return "";
    }
  }
  get record() {
    return this.tooltip.eventRecord;
  }
  onTipShow() {
    const me = this;
    if (me.monitorRecordUpdate && !me.updateListener) {
      me.updateListener = me.client.eventStore.ion({
        update: me.onRecordUpdate,
        thisObj: me
      });
    }
  }
  onTipHide() {
    var _this$updateListener;
    this.tooltip.eventRecord = null;
    (_this$updateListener = this.updateListener) === null || _this$updateListener === void 0 ? void 0 : _this$updateListener.call(this);
    this.updateListener = null;
  }
  onOverNewTarget({
    newTarget
  }) {
    this.tooltip.eventRecord = this.resolveTimeSpanRecord(newTarget);
  }
  onRecordUpdate({
    record
  }) {
    if (record === this.record) {
      this.tooltip.alignTo();
      this.tooltip.updateContent();
    }
  }
};
TooltipBase._$name = "TooltipBase";
var AbstractTimeRanges = class extends InstancePlugin.mixin(Delayable) {
  static get defaultConfig() {
    return {
      rangeCls: "b-sch-range",
      lineCls: "b-sch-line",
      enableResizing: false,
      showTooltip: true,
      tooltipTemplate: null,
      dragTipTemplate: (data) => `
                <div class="b-sch-tip-${data.valid ? "valid" : "invalid"}">
                    <div class="b-sch-tip-name">${StringHelper.encodeHtml(data.name) || ""}</div>
                    ${data.startClockHtml}
                    ${data.endClockHtml || ""}
                </div>
            `,
      baseCls: "b-sch-timerange",
      headerRenderer: null,
      bodyRenderer: null,
      cls: null,
      narrowThreshold: 80
    };
  }
  construct(client, config) {
    const me = this;
    super.construct(client, config);
    if (client.isVertical) {
      client.ion({
        renderRows: me.onUIReady,
        thisObj: me,
        once: true
      });
    }
    me.cls = me.cls || `b-sch-${me.constructor.$$name.toLowerCase()}`;
    me.baseSelector = `.${me.baseCls}.${me.cls}`;
    if (me.enableResizing) {
      me.showHeaderElements = true;
    }
  }
  doDestroy() {
    var _me$clockTemplate, _me$tip, _me$drag, _me$resize;
    const me = this;
    me.detachListeners("timeAxisViewModel");
    me.detachListeners("timeAxis");
    (_me$clockTemplate = me.clockTemplate) === null || _me$clockTemplate === void 0 ? void 0 : _me$clockTemplate.destroy();
    (_me$tip = me.tip) === null || _me$tip === void 0 ? void 0 : _me$tip.destroy();
    (_me$drag = me.drag) === null || _me$drag === void 0 ? void 0 : _me$drag.destroy();
    (_me$resize = me.resize) === null || _me$resize === void 0 ? void 0 : _me$resize.destroy();
    super.doDestroy();
  }
  doDisable(disable) {
    this.renderRanges();
    super.doDisable(disable);
  }
  setupTimeAxisViewModelListeners() {
    const me = this;
    me.detachListeners("timeAxisViewModel");
    me.detachListeners("timeAxis");
    me.client.timeAxisViewModel.ion({
      name: "timeAxisViewModel",
      update: "onTimeAxisViewModelUpdate",
      thisObj: me
    });
    me.client.timeAxis.ion({
      name: "timeAxis",
      includeChange: "renderRanges",
      thisObj: me
    });
  }
  onUIReady() {
    const me = this, {
      client
    } = me;
    client.ion({
      timeAxisViewModelChange: me.setupTimeAxisViewModelListeners,
      thisObj: me
    });
    me.setupTimeAxisViewModelListeners();
    if (!client.hideHeaders) {
      if (me.headerContainerElement) {
        EventHelper.on({
          click: me.onTimeRangeClick,
          dblclick: me.onTimeRangeClick,
          contextmenu: me.onTimeRangeClick,
          delegate: me.baseSelector,
          element: me.headerContainerElement,
          thisObj: me
        });
      }
      if (me.enableResizing) {
        me.drag = DragHelper.new({
          name: "rangeDrag",
          lockX: client.isVertical,
          lockY: client.isHorizontal,
          constrain: true,
          outerElement: me.headerContainerElement,
          targetSelector: `${me.baseSelector}`,
          isElementDraggable: (el, event) => !client.readOnly && me.isElementDraggable(el, event),
          rtlSource: client,
          internalListeners: {
            dragstart: "onDragStart",
            drag: "onDrag",
            drop: "onDrop",
            reset: "onDragReset",
            abort: "onInvalidDrop",
            thisObj: me
          }
        }, me.dragHelperConfig);
        me.resize = ResizeHelper.new({
          direction: client.mode,
          targetSelector: `${me.baseSelector}.b-sch-range`,
          outerElement: me.headerContainerElement,
          isElementResizable: (el) => !el.matches(".b-dragging,.b-readonly"),
          internalListeners: {
            resizestart: "onResizeStart",
            resizing: "onResizeDrag",
            resize: "onResize",
            cancel: "onInvalidResize",
            reset: "onResizeReset",
            thisObj: me
          }
        }, me.resizeHelperConfig);
      }
    }
    me.renderRanges();
    if (me.tooltipTemplate) {
      me.hoverTooltip = new Tooltip({
        forElement: me.headerContainerElement,
        getHtml({
          activeTarget
        }) {
          const timeRange = me.resolveTimeRangeRecord(activeTarget);
          return me.tooltipTemplate({
            timeRange
          });
        },
        forSelector: "." + me.baseCls + (me.cls ? "." + me.cls : "")
      });
    }
  }
  refresh() {
    this._timeRanges = null;
    this.renderRanges();
  }
  getDOMConfig(startDate, endDate) {
    const me = this, bodyConfigs = [], headerConfigs = [];
    if (!me.disabled) {
      me._labelRotationMap = {};
      for (const range of me.timeRanges) {
        const result = me.renderRange(range, startDate, endDate);
        if (result) {
          bodyConfigs.push(result.bodyConfig);
          headerConfigs.push(result.headerConfig);
        }
      }
    }
    return [bodyConfigs, headerConfigs];
  }
  renderRanges() {
    const me = this, {
      foregroundCanvas
    } = me.client;
    if (foregroundCanvas && me.client.isPainted) {
      const {
        headerContainerElement
      } = me, updatedBodyElements = [], [bodyConfigs, headerConfigs] = me.getDOMConfig();
      if (!me.bodyCanvas) {
        me.bodyCanvas = DomHelper.createElement({
          className: `b-timeranges-canvas ${me.cls}-canvas`,
          parent: foregroundCanvas,
          retainElement: true
        });
      }
      DomSync.sync({
        targetElement: me.bodyCanvas,
        childrenOnly: true,
        domConfig: {
          children: bodyConfigs,
          syncOptions: {
            releaseThreshold: 0,
            syncIdField: "id"
          }
        },
        callback: me.showHeaderElements ? null : ({
          targetElement,
          action
        }) => {
          if (action === "reuseElement" || action === "newElement" || action === "reuseOwnElement") {
            updatedBodyElements.push(targetElement);
          }
        }
      });
      if (me.showHeaderElements && !me.headerCanvas) {
        me.headerCanvas = DomHelper.createElement({
          className: `${me.cls}-canvas`,
          parent: headerContainerElement,
          retainElement: true
        });
      }
      if (me.headerCanvas) {
        DomSync.sync({
          targetElement: me.headerCanvas,
          childrenOnly: true,
          domConfig: {
            children: headerConfigs,
            syncOptions: {
              releaseThreshold: 0,
              syncIdField: "id"
            }
          }
        });
      }
      for (const bodyElement of updatedBodyElements) {
        me.cacheRotation(bodyElement.elementData.timeRange, bodyElement);
      }
      for (const bodyElement of updatedBodyElements) {
        me.applyRotation(bodyElement.elementData.timeRange, bodyElement);
      }
    }
  }
  get timeRanges() {
    return [];
  }
  shouldRenderRange(range, startDate = this.client.visibleDateRange.startDate, endDate = this.client.visibleDateRange.endDate) {
    const {
      timeAxis
    } = this.client, {
      startDate: rangeStart,
      endDate: rangeEnd,
      duration
    } = range;
    return Boolean(rangeStart && (!timeAxis.isFiltered || timeAxis.isTimeSpanInAxis(range)) && DateHelper.intersectSpans(
      startDate,
      endDate,
      rangeStart,
      duration ? rangeEnd : DateHelper.add(rangeStart, this._lineBufferDurationMS)
    ));
  }
  getRangeDomConfig(timeRange, minDate, maxDate, relativeTo = 0) {
    const me = this, {
      client
    } = me, {
      rtl
    } = client, startPos = client.getCoordinateFromDate(DateHelper.max(timeRange.startDate, minDate), {
      respectExclusion: true
    }) - relativeTo, endPos = timeRange.endDate ? client.getCoordinateFromDate(DateHelper.min(timeRange.endDate, maxDate), {
      respectExclusion: true,
      isEnd: true
    }) - relativeTo : startPos, size = Math.abs(endPos - startPos), isRange = size > 0, translateX = rtl ? `calc(${startPos}px - 100%)` : `${startPos}px`;
    return {
      className: {
        [me.baseCls]: 1,
        [me.cls]: me.cls,
        [me.rangeCls]: isRange,
        [me.lineCls]: !isRange,
        [timeRange.cls]: timeRange.cls,
        "b-narrow-range": isRange && size < me.narrowThreshold,
        "b-readonly": timeRange.readOnly,
        "b-rtl": rtl
      },
      dataset: {
        id: timeRange.id
      },
      elementData: {
        timeRange
      },
      style: client.isVertical ? `transform: translateY(${translateX}); ${isRange ? `height:${size}px` : ""};` : `transform: translateX(${translateX}); ${isRange ? `width:${size}px` : ""};`
    };
  }
  renderRange(timeRange, startDate, endDate) {
    const me = this, {
      client
    } = me, {
      timeAxis
    } = client;
    if (me.shouldRenderRange(timeRange, startDate, endDate) && timeAxis.startDate) {
      const config = me.getRangeDomConfig(timeRange, timeAxis.startDate, timeAxis.endDate), icon = timeRange.iconCls && StringHelper.xss`<i class="${timeRange.iconCls}"></i>`, name = timeRange.name && StringHelper.encodeHtml(timeRange.name), labelTpl = name || icon ? `<label>${icon || ""}${name || "&nbsp;"}</label>` : "", bodyConfig = _objectSpread2(_objectSpread2({}, config), {}, {
        style: config.style + (timeRange.style || ""),
        html: me.bodyRenderer ? me.bodyRenderer({
          timeRange
        }) : me.showHeaderElements && !me.showLabelInBody ? "" : labelTpl
      });
      let headerConfig;
      if (me.showHeaderElements) {
        headerConfig = _objectSpread2(_objectSpread2({}, config), {}, {
          html: me.headerRenderer ? me.headerRenderer({
            timeRange
          }) : me.showLabelInBody ? "" : labelTpl
        });
      }
      return {
        bodyConfig,
        headerConfig
      };
    }
  }
  cacheRotation(range, bodyElement) {
    if (!range.iconCls && !range.name || !range.duration) {
      return;
    }
    const label = bodyElement.firstElementChild;
    if (label && !range.recurringTimeSpan) {
      this._labelRotationMap[range.id] = this.client.isVertical ? label.offsetHeight < bodyElement.offsetHeight : label.offsetWidth > bodyElement.offsetWidth;
    }
  }
  applyRotation(range, bodyElement) {
    var _range$recurringTimeS, _range$recurringTimeS2, _bodyElement$firstEle;
    const rotate = this._labelRotationMap[(_range$recurringTimeS = (_range$recurringTimeS2 = range.recurringTimeSpan) === null || _range$recurringTimeS2 === void 0 ? void 0 : _range$recurringTimeS2.id) !== null && _range$recurringTimeS !== void 0 ? _range$recurringTimeS : range.id];
    (_bodyElement$firstEle = bodyElement.firstElementChild) === null || _bodyElement$firstEle === void 0 ? void 0 : _bodyElement$firstEle.classList.toggle("b-vertical", Boolean(rotate));
  }
  getBodyElementByRecord(idOrRecord) {
    const id = typeof idOrRecord === "string" ? idOrRecord : idOrRecord === null || idOrRecord === void 0 ? void 0 : idOrRecord.id;
    return id != null && DomSync.getChild(this.bodyCanvas, id);
  }
  resolveTimeRangeRecord(el) {
  }
  get headerContainerElement() {
    const me = this, {
      isVertical,
      timeView,
      timeAxisColumn
    } = me.client;
    if (!me._headerContainerElement) {
      if (isVertical && timeView.element) {
        me._headerContainerElement = timeView.element.parentElement;
      } else if (!isVertical) {
        me._headerContainerElement = timeAxisColumn.element;
      }
    }
    return me._headerContainerElement;
  }
  get showHeaderElements() {
    return !this.client.hideHeaders && this._showHeaderElements;
  }
  updateShowHeaderElements(show) {
    const {
      client
    } = this;
    if (!this.isConfiguring) {
      client.element.classList.toggle("b-sch-timeranges-with-headerelements", Boolean(show));
      this.renderRanges();
    }
  }
  populateTimeAxisHeaderMenu({
    column,
    items: items2
  }) {
  }
  onPaint({
    firstPaint
  }) {
    if (firstPaint && this.client.isHorizontal) {
      this.onUIReady();
    }
  }
  onSchedulerHorizontalScroll() {
    this.client.isHorizontal && this.renderRanges();
  }
  afterScroll() {
    this.client.isVertical && this.renderRanges();
  }
  onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {
    if (this.client.isVertical && oldHeight !== newHeight) {
      this.renderRanges();
    }
  }
  onTimeAxisViewModelUpdate({
    source
  }) {
    this._lineBufferDurationMS = source.getDateFromPosition(50) - source.getDateFromPosition(0);
    this.refresh();
  }
  onTimeRangeClick(event) {
    const timeRangeRecord = this.resolveTimeRangeRecord(event.target);
    this.client.trigger(`timeRangeHeader${StringHelper.capitalize(event.type)}`, {
      event,
      timeRangeRecord
    });
  }
  showTip(context) {
    const me = this;
    if (me.showTooltip) {
      me.clockTemplate = new ClockTemplate({
        scheduler: me.client
      });
      me.tip = new Tooltip(ObjectHelper.assign({
        id: `${me.client.id}-time-range-tip`,
        cls: "b-interaction-tooltip",
        align: "b-t",
        autoShow: true,
        updateContentOnMouseMove: true,
        forElement: context.element,
        getHtml: () => me.getTipHtml(context.record, context.element)
      }, me.showTooltip));
    }
  }
  destroyTip() {
    if (this.tip) {
      this.tip.destroy();
      this.tip = null;
    }
  }
  isElementDraggable(el) {
    el = el.closest(this.baseSelector + ":not(.b-resizing):not(.b-readonly)");
    return el && !el.classList.contains("b-over-resize-handle");
  }
  onDragStart({
    context
  }) {
    const {
      client,
      drag
    } = this;
    if (client.isVertical) {
      drag.minY = 0;
      drag.maxY = client.timeAxisViewModel.totalSize - context.element.offsetHeight;
      drag.minX = 0;
      drag.maxX = Number.MAX_SAFE_INTEGER;
    } else {
      drag.minX = 0;
      drag.maxX = client.timeAxisViewModel.totalSize - context.element.offsetWidth;
      drag.minY = 0;
      drag.maxY = Number.MAX_SAFE_INTEGER;
    }
    client.element.classList.add("b-dragging-timerange");
  }
  onDrop({
    context
  }) {
    this.client.element.classList.remove("b-dragging-timerange");
  }
  onInvalidDrop() {
    this.drag.reset();
    this.client.element.classList.remove("b-dragging-timerange");
    this.destroyTip();
  }
  onDrag() {
  }
  onDragReset() {
  }
  onResizeStart() {
  }
  onResizeDrag() {
  }
  onResize() {
  }
  onInvalidResize() {
  }
  onResizeReset() {
  }
  getTipHtml(record, element) {
    const me = this, {
      client
    } = me, box = Rectangle.from(element), startPos = box.getStart(client.rtl, client.isHorizontal), endPos = box.getEnd(client.rtl, client.isHorizontal), startDate = client.getDateFromCoordinate(startPos, "round", false), endDate = record.endDate && client.getDateFromCoordinate(endPos, "round", false), startText = client.getFormattedDate(startDate), endText = endDate && client.getFormattedEndDate(endDate, startDate);
    return me.dragTipTemplate({
      name: record.name || "",
      startDate,
      endDate,
      startText,
      endText,
      startClockHtml: me.clockTemplate.template({
        date: startDate,
        text: startText,
        cls: "b-sch-tooltip-startdate"
      }),
      endClockHtml: endText && me.clockTemplate.template({
        date: endDate,
        text: endText,
        cls: "b-sch-tooltip-enddate"
      })
    });
  }
};
_defineProperty(AbstractTimeRanges, "configurable", {
  showHeaderElements: true
});
_defineProperty(AbstractTimeRanges, "pluginConfig", {
  chain: ["onPaint", "populateTimeAxisHeaderMenu", "onSchedulerHorizontalScroll", "afterScroll", "onInternalResize"]
});
AbstractTimeRanges._$name = "AbstractTimeRanges";
var emptyObject$5 = Object.freeze({});
var ColumnLines = class extends Delayable(InstancePlugin) {
  static get $name() {
    return "ColumnLines";
  }
  static get delayable() {
    return {
      refresh: {
        type: "raf",
        cancelOutstanding: true
      }
    };
  }
  static get pluginConfig() {
    return {
      after: ["render", "updateCanvasSize", "onVisibleDateRangeChange", "onVisibleResourceRangeChange"]
    };
  }
  construct(client, config) {
    client.useBackgroundCanvas = true;
    super.construct(client, config);
  }
  doDisable(disable) {
    super.doDisable(disable);
    if (!this.isConfiguring) {
      this.refresh();
    }
  }
  render() {
    this.refresh();
  }
  getColumnLinesDOMConfig(startDate, endDate) {
    const me = this, {
      client
    } = me, {
      rtl
    } = client, m = rtl ? -1 : 1, {
      timeAxisViewModel,
      isHorizontal,
      resourceStore,
      variableColumnWidths
    } = client, {
      columnConfig
    } = timeAxisViewModel;
    const linesForLevel = timeAxisViewModel.columnLinesFor, majorLinesForLevel = Math.max(linesForLevel - 1, 0), start = startDate.getTime(), end = endDate.getTime(), domConfigs = [], dates = /* @__PURE__ */ new Set(), dimension = isHorizontal ? "X" : "Y";
    if (!me.disabled) {
      const addLineConfig = (tick, isMajor) => {
        const tickStart = tick.start.getTime();
        if (tickStart > start && tickStart < end && !dates.has(tickStart)) {
          dates.add(tickStart);
          domConfigs.push({
            role: "presentation",
            className: isMajor ? "b-column-line-major" : "b-column-line",
            style: {
              transform: `translate${dimension}(${tick.coord * m}px)`
            },
            dataset: {
              line: isMajor ? `major-${tick.index}` : `line-${tick.index}`
            }
          });
        }
      };
      if (linesForLevel !== majorLinesForLevel) {
        for (let i = 1; i <= columnConfig[majorLinesForLevel].length - 1; i++) {
          addLineConfig(columnConfig[majorLinesForLevel][i], true);
        }
      }
      for (let i = 1; i <= columnConfig[linesForLevel].length - 1; i++) {
        addLineConfig(columnConfig[linesForLevel][i], false);
      }
      if (!isHorizontal && client.columnLines) {
        const {
          columnWidth
        } = client.resourceColumns, {
          first: firstResource,
          last: lastResource
        } = client.currentOrientation.getResourceRange(true);
        if (firstResource > -1) {
          for (let i = firstResource; i < lastResource + 1; i++) {
            const resourceRecord = resourceStore.getAt(i), instanceMeta = resourceRecord.instanceMeta(client), left = variableColumnWidths ? instanceMeta.insetStart + resourceRecord.columnWidth - 1 : (i + 1) * columnWidth - 1;
            domConfigs.push({
              className: "b-column-line b-resource-column-line",
              style: {
                transform: `translateX(${left * m}px)`
              },
              dataset: {
                line: `resource-${i}`
              }
            });
          }
        }
      }
    }
    return domConfigs;
  }
  refresh() {
    const me = this, {
      client
    } = me, {
      timeAxis
    } = client, {
      startDate,
      endDate
    } = client.visibleDateRange || emptyObject$5, axisStart = timeAxis.startDate;
    if (!axisStart || !startDate) {
      return;
    }
    if (!me.element) {
      me.element = DomHelper.createElement({
        parent: client.backgroundCanvas,
        className: "b-column-lines-canvas"
      });
    }
    const domConfigs = me.getColumnLinesDOMConfig(startDate, endDate);
    DomSync.sync({
      targetElement: me.element,
      onlyChildren: true,
      domConfig: {
        children: domConfigs,
        syncOptions: {
          releaseThreshold: 4
        }
      },
      syncIdField: "line"
    });
  }
  onVisibleDateRangeChange() {
    this.refresh();
  }
  onVisibleResourceRangeChange({
    firstResource,
    lastResource
  }) {
    this.refresh();
  }
  updateCanvasSize() {
    this.refresh();
  }
};
ColumnLines._$name = "ColumnLines";
GridFeatureManager.registerFeature(ColumnLines, true, ["Scheduler", "Gantt"]);
var DependencyCreation = (Target) => class DependencyCreation extends (Target || Base$1) {
  static get $name() {
    return "DependencyCreation";
  }
  static get defaultConfig() {
    return {
      allowDropOnEventBar: true,
      showCreationTooltip: true,
      creationTooltip: null,
      terminalCls: "b-sch-terminal",
      terminalSides: ["start", "top", "end", "bottom"],
      allowCreate: true
    };
  }
  construct(view, config) {
    super.construct(view, config);
    const me = this;
    me.view = view;
    me.eventName = view.scheduledEventName;
    view.ion({
      readOnly: () => me.updateCreateListeners()
    });
    me.updateCreateListeners();
    me.chain(view, "onElementTouchMove", "onElementTouchMove");
  }
  doDestroy() {
    var _me$pointerUpMoveDeta, _me$creationTooltip;
    const me = this;
    me.detachListeners("view");
    me.creationData = null;
    (_me$pointerUpMoveDeta = me.pointerUpMoveDetacher) === null || _me$pointerUpMoveDeta === void 0 ? void 0 : _me$pointerUpMoveDeta.call(me);
    (_me$creationTooltip = me.creationTooltip) === null || _me$creationTooltip === void 0 ? void 0 : _me$creationTooltip.destroy();
    super.doDestroy();
  }
  updateCreateListeners() {
    const me = this;
    if (!me.view) {
      return;
    }
    me.detachListeners("view");
    if (me.isCreateAllowed) {
      me.view.ion({
        name: "view",
        [`${me.eventName}mouseenter`]: "onTimeSpanMouseEnter",
        [`${me.eventName}mouseleave`]: "onTimeSpanMouseLeave",
        thisObj: me
      });
    }
  }
  set allowCreate(value) {
    this._allowCreate = value;
    this.updateCreateListeners();
  }
  get allowCreate() {
    return this._allowCreate;
  }
  get isCreateAllowed() {
    return this.allowCreate && !this.view.readOnly && !this.disabled;
  }
  onTimeSpanMouseEnter({
    event,
    source,
    [`${this.eventName}Record`]: record,
    [`${this.eventName}Element`]: element
  }) {
    if (!record.isCreating && !record.readOnly && (!this.client.features.nestedEvents || record.parent.isRoot)) {
      const me = this, {
        creationData
      } = me, eventBarElement = DomHelper.down(element, source.eventInnerSelector);
      if (record !== (creationData === null || creationData === void 0 ? void 0 : creationData.source)) {
        me.showTerminals(record, eventBarElement);
        if (creationData && event.target.closest(me.client.eventSelector)) {
          creationData.timeSpanElement = eventBarElement;
          me.onOverTargetEventBar(event);
        }
      }
    }
  }
  onTimeSpanMouseLeave(event) {
    var _event$event;
    const me = this, {
      creationData
    } = me, element = event[`${me.eventName}Element`], timeSpanLeft = DomHelper.down(element, me.view.eventInnerSelector), target = (_event$event = event.event) === null || _event$event === void 0 ? void 0 : _event$event.relatedTarget, timeSpanElement = creationData === null || creationData === void 0 ? void 0 : creationData.timeSpanElement;
    if (!target) {
      return;
    }
    if (!creationData || !timeSpanElement || !target || !DomHelper.isDescendant(timeSpanElement, target)) {
      if (event.event.isTrusted || timeSpanLeft !== (creationData === null || creationData === void 0 ? void 0 : creationData.sourceElement)) {
        me.hideTerminals(element);
      }
    }
    if (creationData && !creationData.finalizing) {
      creationData.timeSpanElement = null;
      me.onOverNewTargetWhileCreating(void 0, void 0, event);
    }
  }
  onTerminalMouseOver(event) {
    if (this.creationData) {
      this.onOverTargetEventBar(event);
    }
  }
  onTerminalMouseOut(event) {
    const me = this, {
      creationData
    } = me, eventElement = event.target.closest(me.view.eventSelector);
    if (eventElement && (!me.showingTerminalsFor || !DomHelper.isDescendant(eventElement, me.showingTerminalsFor)) && (!creationData || eventElement !== creationData.timeSpanElement)) {
      me.hideTerminals(eventElement);
      me.view.unhover(eventElement, event);
    }
    if (creationData) {
      me.onOverNewTargetWhileCreating(event.relatedTarget, creationData.target, event);
    }
  }
  onTerminalPointerDown(event) {
    const me = this;
    if (event.button === 0 && !me.creationData) {
      var _scheduler$resolveRes;
      const scheduler = me.view, timeAxisSubGridElement = scheduler.timeAxisSubGridElement, terminalNode = event.target, timeSpanElement = terminalNode.closest(scheduler.eventInnerSelector), viewBounds = Rectangle.from(scheduler.element, document.body);
      event.stopPropagation();
      me.creationData = {
        sourceElement: timeSpanElement,
        source: scheduler.resolveTimeSpanRecord(timeSpanElement).$original,
        fromSide: terminalNode.dataset.side,
        startPoint: Rectangle.from(terminalNode, timeAxisSubGridElement).center,
        startX: event.pageX - viewBounds.x + scheduler.scrollLeft,
        startY: event.pageY - viewBounds.y + scheduler.scrollTop,
        valid: false,
        sourceResource: (_scheduler$resolveRes = scheduler.resolveResourceRecord) === null || _scheduler$resolveRes === void 0 ? void 0 : _scheduler$resolveRes.call(scheduler, event),
        tooltip: me.creationTooltip
      };
      me.pointerUpMoveDetacher = EventHelper.on({
        pointerup: {
          element: scheduler.element.getRootNode(),
          handler: "onMouseUp",
          passive: false
        },
        pointermove: {
          element: timeAxisSubGridElement,
          handler: "onMouseMove",
          passive: false
        },
        thisObj: me
      });
      me.documentPointerUpDetacher = EventHelper.on({
        pointerup: {
          element: document,
          handler: "onDocumentMouseUp"
        },
        keydown: {
          element: document,
          handler: ({
            key
          }) => {
            if (key === "Escape") {
              me.abort();
            }
          }
        },
        thisObj: me
      });
    }
  }
  onElementTouchMove(event) {
    var _super$onElementTouch;
    (_super$onElementTouch = super.onElementTouchMove) === null || _super$onElementTouch === void 0 ? void 0 : _super$onElementTouch.call(this, event);
    if (this.connector) {
      event.preventDefault();
    }
  }
  onMouseMove(event) {
    const me = this, {
      view,
      creationData: data
    } = me, viewBounds = Rectangle.from(view.element, document.body), deltaX = event.pageX - viewBounds.x + view.scrollLeft - data.startX, deltaY = event.pageY - viewBounds.y + view.scrollTop - data.startY, length = Math.round(Math.sqrt(deltaX * deltaX + deltaY * deltaY)) - 3, angle = Math.atan2(deltaY, deltaX);
    let {
      connector
    } = me;
    if (!connector) {
      if (me.onRequestDragCreate(event) === false) {
        return;
      }
      connector = me.connector;
    }
    connector.style.width = `${length}px`;
    connector.style.transform = `rotate(${angle}rad)`;
    me.lastMouseMoveEvent = event;
  }
  onRequestDragCreate(event) {
    const me = this, {
      view,
      creationData: data
    } = me;
    if (view.trigger("beforeDependencyCreateDrag", {
      data,
      source: data.source
    }) === false) {
      me.abort();
      return false;
    }
    view.element.classList.add("b-creating-dependency");
    me.createConnector(data.startPoint.x, data.startPoint.y);
    view.trigger("dependencyCreateDragStart", {
      data,
      source: data.source
    });
    if (me.showCreationTooltip) {
      const tip = me.creationTooltip || (me.creationTooltip = me.createDragTooltip());
      me.creationData.tooltip = tip;
      tip.disabled = false;
      tip.show();
      tip.onMouseMove(event);
    }
    view.scrollManager.startMonitoring({
      scrollables: [{
        element: view.timeAxisSubGrid.scrollable.element,
        direction: "horizontal"
      }, {
        element: view.scrollable.element,
        direction: "vertical"
      }],
      callback: () => me.lastMouseMoveEvent && me.onMouseMove(me.lastMouseMoveEvent)
    });
  }
  onOverTargetEventBar(event) {
    var _overEventRecord;
    const me = this, {
      view,
      creationData: data,
      allowDropOnEventBar
    } = me, {
      target
    } = event;
    let overEventRecord = view.resolveTimeSpanRecord(target).$original;
    if ((_overEventRecord = overEventRecord) !== null && _overEventRecord !== void 0 && _overEventRecord.isEventSegment) {
      overEventRecord = overEventRecord.event;
    }
    if (Objects.isPromise(data.valid) || !allowDropOnEventBar && !target.classList.contains(me.terminalCls)) {
      return;
    }
    if (overEventRecord !== data.source) {
      me.onOverNewTargetWhileCreating(target, overEventRecord, event);
    }
  }
  async onOverNewTargetWhileCreating(targetElement, overEventRecord, event) {
    const me = this, {
      view,
      creationData: data,
      allowDropOnEventBar,
      connector
    } = me;
    if (Objects.isPromise(data.valid)) {
      return;
    }
    if (data.finalizing) {
      return;
    }
    if (!connector) {
      return;
    }
    connector.classList.remove("b-valid", "b-invalid");
    data.timeSpanElement && DomHelper.removeClsGlobally(data.timeSpanElement, "b-sch-terminal-active");
    if (!overEventRecord || overEventRecord === data.source || !allowDropOnEventBar && !targetElement.classList.contains(me.terminalCls)) {
      data.target = data.toSide = null;
      data.valid = false;
      connector.classList.add("b-invalid");
    } else {
      var _data$timeSpanElement, _data$timeSpanElement2;
      const target = data.target = overEventRecord, {
        source
      } = data;
      let toSide = targetElement.dataset.side;
      if (allowDropOnEventBar && !targetElement.classList.contains(me.terminalCls)) {
        toSide = me.getTargetSideFromType(me.dependencyStore.modelClass.fieldMap.type.defaultValue || DependencyBaseModel.Type.EndToStart);
      }
      if (view.resolveResourceRecord) {
        data.targetResource = view.resolveResourceRecord(event);
      }
      let dependencyType;
      data.toSide = toSide;
      const fromSide = data.fromSide, updateValidity = (valid2) => {
        if (!me.isDestroyed) {
          data.valid = valid2;
          targetElement.classList.add(valid2 ? "b-valid" : "b-invalid");
          connector.classList.add(valid2 ? "b-valid" : "b-invalid");
          view.trigger("dependencyValidationComplete", {
            data,
            source,
            target,
            dependencyType
          });
        }
      };
      switch (true) {
        case (fromSide === "start" && toSide === "start"):
          dependencyType = DependencyBaseModel.Type.StartToStart;
          break;
        case (fromSide === "start" && toSide === "end"):
          dependencyType = DependencyBaseModel.Type.StartToEnd;
          break;
        case (fromSide === "end" && toSide === "start"):
          dependencyType = DependencyBaseModel.Type.EndToStart;
          break;
        case (fromSide === "end" && toSide === "end"):
          dependencyType = DependencyBaseModel.Type.EndToEnd;
          break;
      }
      view.trigger("dependencyValidationStart", {
        data,
        source,
        target,
        dependencyType
      });
      let valid = data.valid = me.dependencyStore.isValidDependency(source, target, dependencyType);
      if (Objects.isPromise(valid)) {
        valid = await valid;
        updateValidity(valid);
      } else {
        updateValidity(valid);
      }
      const validityCls = valid ? "b-valid" : "b-invalid";
      connector.classList.add(validityCls);
      (_data$timeSpanElement = data.timeSpanElement) === null || _data$timeSpanElement === void 0 ? void 0 : (_data$timeSpanElement2 = _data$timeSpanElement.querySelector(`.b-sch-terminal[data-side=${toSide}]`)) === null || _data$timeSpanElement2 === void 0 ? void 0 : _data$timeSpanElement2.classList.add("b-sch-terminal-active", validityCls);
    }
    me.updateCreationTooltip();
  }
  async onMouseUp() {
    var _me$pointerUpMoveDeta2;
    const me = this, data = me.creationData;
    data.finalizing = true;
    (_me$pointerUpMoveDeta2 = me.pointerUpMoveDetacher) === null || _me$pointerUpMoveDeta2 === void 0 ? void 0 : _me$pointerUpMoveDeta2.call(me);
    if (data.valid) {
      const result = await me.view.trigger("beforeDependencyCreateFinalize", data);
      if (result === false) {
        data.valid = false;
      } else if (Objects.isPromise(data.valid)) {
        data.valid = await data.valid;
      }
      if (data.valid) {
        let dependency = me.createDependency(data);
        if (dependency !== null) {
          if (Objects.isPromise(dependency)) {
            dependency = await dependency;
          }
          data.dependency = dependency;
          me.view.trigger("dependencyCreateDrop", {
            data,
            source: data.source,
            target: data.target,
            dependency
          });
          me.doAfterDependencyDrop(data);
        }
      } else {
        me.doAfterDependencyDrop(data);
      }
    } else {
      data.valid = false;
      me.doAfterDependencyDrop(data);
    }
    me.abort();
  }
  doAfterDependencyDrop(data) {
    this.view.trigger("afterDependencyCreateDrop", _objectSpread2({
      data
    }, data));
  }
  onDocumentMouseUp({
    target
  }) {
    if (!this.view.timeAxisSubGridElement.contains(target)) {
      this.abort();
    }
  }
  abort() {
    var _me$pointerUpMoveDeta3, _me$documentPointerUp;
    const me = this, {
      view,
      creationData
    } = me;
    if (creationData) {
      const {
        source,
        sourceResource,
        target,
        targetResource
      } = creationData;
      if (source) {
        const el = view.getElementFromEventRecord(source, sourceResource);
        if (el) {
          me.hideTerminals(el);
        }
      }
      if (target) {
        const el = view.getElementFromEventRecord(target, targetResource);
        if (el) {
          me.hideTerminals(el);
        }
      }
    }
    if (me.creationTooltip) {
      me.creationTooltip.disabled = true;
    }
    me.creationData = me.lastMouseMoveEvent = null;
    (_me$pointerUpMoveDeta3 = me.pointerUpMoveDetacher) === null || _me$pointerUpMoveDeta3 === void 0 ? void 0 : _me$pointerUpMoveDeta3.call(me);
    (_me$documentPointerUp = me.documentPointerUpDetacher) === null || _me$documentPointerUp === void 0 ? void 0 : _me$documentPointerUp.call(me);
    me.removeConnector();
  }
  createConnector(x, y) {
    const me = this, {
      view
    } = me;
    me.clearTimeout(me.removeConnectorTimeout);
    me.connector = DomHelper.createElement({
      parent: view.timeAxisSubGridElement,
      className: `${me.baseCls}-connector`,
      style: `left:${x}px;top:${y}px`
    });
    view.element.classList.add("b-creating-dependency");
  }
  createDragTooltip() {
    const me = this, {
      view
    } = me;
    return me.creationTooltip = Tooltip.new({
      id: `${view.id}-dependency-drag-tip`,
      cls: "b-sch-dependency-creation-tooltip",
      loadingMsg: "",
      anchorToTarget: false,
      forElement: view.timeAxisSubGridElement,
      trackMouse: true,
      constrainTo: null,
      header: {
        dock: "right"
      },
      internalListeners: {
        beforeShow: "updateCreationTooltip",
        thisObj: me
      }
    }, me.creationTooltip);
  }
  removeConnector() {
    const me = this, {
      connector,
      view
    } = me;
    if (connector) {
      connector.classList.add("b-removing");
      connector.style.width = "0";
      me.removeConnectorTimeout = me.setTimeout(() => {
        connector.remove();
        me.connector = null;
      }, 200);
    }
    view.element.classList.remove("b-creating-dependency");
    me.creationTooltip && me.creationTooltip.hide();
    view.scrollManager.stopMonitoring();
  }
  showTerminals(timeSpanRecord, element) {
    const me = this;
    if (!me.isCreateAllowed || !timeSpanRecord.project) {
      return;
    }
    const cls = me.terminalCls, terminalsVisibleCls = `${cls}s-visible`;
    element = DomHelper.down(element, me.view.eventInnerSelector);
    if (!element.classList.contains(terminalsVisibleCls) && !me.view.element.classList.contains("b-resizing-event") && !me.view.readOnly) {
      me.terminalSides.forEach((side) => {
        side = me.fixSide(side);
        const terminal = DomHelper.createElement({
          parent: element,
          className: `${cls} ${cls}-${side}`,
          dataset: {
            side,
            feature: true
          }
        });
        terminal.detacher = EventHelper.on({
          element: terminal,
          mouseover: "onTerminalMouseOver",
          mouseout: "onTerminalMouseOut",
          pointerdown: {
            handler: "onTerminalPointerDown",
            capture: true
          },
          thisObj: me
        });
      });
      element.classList.add(terminalsVisibleCls);
      timeSpanRecord.internalCls.add(terminalsVisibleCls);
      me.showingTerminalsFor = element;
    }
  }
  fixSide(side) {
    if (side === "left") {
      return "start";
    }
    if (side === "right") {
      return "end";
    }
    return side;
  }
  hideTerminals(eventElement) {
    const me = this, eventParams = me.client.getTimeSpanMouseEventParams(eventElement), timeSpanRecord = eventParams === null || eventParams === void 0 ? void 0 : eventParams[`${me.eventName}Record`], terminalsVisibleCls = `${me.terminalCls}s-visible`;
    DomHelper.forEachSelector(eventElement, `.${me.terminalCls}`, (terminal) => {
      terminal.detacher && terminal.detacher();
      terminal.remove();
    });
    DomHelper.down(eventElement, me.view.eventInnerSelector).classList.remove(terminalsVisibleCls);
    timeSpanRecord.internalCls.remove(terminalsVisibleCls);
    me.showingTerminalsFor = null;
  }
  createDependency(data) {
    const {
      source,
      target,
      fromSide,
      toSide
    } = data, type = (fromSide === "start" ? 0 : 2) + (toSide === "end" ? 1 : 0);
    const newDependency = this.dependencyStore.add({
      from: source.id,
      to: target.id,
      type,
      fromSide,
      toSide
    });
    return newDependency !== null ? newDependency[0] : null;
  }
  getTargetSideFromType(type) {
    if (type === DependencyBaseModel.Type.StartToStart || type === DependencyBaseModel.Type.EndToStart) {
      return "start";
    }
    return "end";
  }
  updateCreationTooltip() {
    const me = this, data = me.creationData, {
      valid
    } = data, tip = me.creationTooltip, {
      classList
    } = tip.element;
    if (Objects.isPromise(valid)) {
      classList.remove("b-invalid");
      classList.add("b-checking");
      return new Promise((resolve) => valid.then((valid2) => {
        data.valid = valid2;
        if (!tip.isDestroyed) {
          resolve(me.updateCreationTooltip());
        }
      }));
    }
    tip.html = me.creationTooltipTemplate(data);
  }
  creationTooltipTemplate(data) {
    var _data$target$name, _data$target;
    const me = this, {
      tooltip,
      valid
    } = data, {
      classList
    } = tooltip.element;
    Object.assign(data, {
      fromText: StringHelper.encodeHtml(data.source.name),
      toText: StringHelper.encodeHtml((_data$target$name = (_data$target = data.target) === null || _data$target === void 0 ? void 0 : _data$target.name) !== null && _data$target$name !== void 0 ? _data$target$name : ""),
      fromSide: data.fromSide,
      toSide: data.toSide || ""
    });
    let tipTitleIconClsSuffix, tipTitleText;
    classList.toggle("b-invalid", !valid);
    classList.remove("b-checking");
    if (valid === true) {
      tipTitleIconClsSuffix = "valid";
      tipTitleText = me.L("L{Dependencies.valid}");
    } else {
      tipTitleIconClsSuffix = "invalid";
      tipTitleText = me.L("L{Dependencies.invalid}");
    }
    tooltip.title = `<i class="b-icon b-icon-${tipTitleIconClsSuffix}"></i>${tipTitleText}`;
    return {
      children: [{
        className: "b-sch-dependency-tooltip",
        children: [{
          dataset: {
            ref: "fromLabel"
          },
          tag: "label",
          text: me.L("L{Dependencies.from}")
        }, {
          dataset: {
            ref: "fromText"
          },
          text: data.fromText
        }, {
          dataset: {
            ref: "fromBox"
          },
          className: `b-sch-box b-${data.fromSide}`
        }, {
          dataset: {
            ref: "toLabel"
          },
          tag: "label",
          text: me.L("L{Dependencies.to}")
        }, {
          dataset: {
            ref: "toText"
          },
          text: data.toText
        }, {
          dataset: {
            ref: "toBox"
          },
          className: `b-sch-box b-${data.toSide}`
        }]
      }]
    };
  }
  doDisable(disable) {
    if (!this.isConfiguring) {
      this.updateCreateListeners();
    }
    super.doDisable(disable);
  }
};
var ROWS_PER_CELL = 25;
var DependencyGridCache = (Target) => {
  var _class;
  return _class = class DependencyGridCache extends Target {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "gridCache", null);
    }
    getDependenciesToConsider(startMS, endMS, startIndex, endIndex) {
      const me = this, {
        gridCache
      } = me, {
        timeAxis
      } = me.client;
      if (gridCache) {
        const dependencies = /* @__PURE__ */ new Set(), fromMSCell = Math.floor((startMS - timeAxis.startMS) / me.MS_PER_CELL), toMSCell = Math.floor((endMS - timeAxis.startMS) / me.MS_PER_CELL), fromRowCell = Math.floor(startIndex / ROWS_PER_CELL), toRowCell = Math.floor(endIndex / ROWS_PER_CELL);
        for (let i = fromMSCell; i <= toMSCell; i++) {
          const msCell = gridCache[i];
          if (msCell) {
            for (let j = fromRowCell; j <= toRowCell; j++) {
              const intersectingDependencies = msCell[j];
              if (intersectingDependencies) {
                for (let i2 = 0; i2 < intersectingDependencies.length; i2++) {
                  dependencies.add(intersectingDependencies[i2]);
                }
              }
            }
          }
        }
        return dependencies;
      }
    }
    afterDrawDependency(dependency, fromIndex, toIndex, fromDateMS, toDateMS) {
      const me = this;
      if (me.constructGridCache) {
        const {
          MS_PER_CELL
        } = me, {
          startMS: timeAxisStartMS,
          endMS: timeAxisEndMS
        } = me.client.timeAxis, timeAxisCells = Math.ceil((timeAxisEndMS - timeAxisStartMS) / MS_PER_CELL), fromMSCell = Math.floor((fromDateMS - timeAxisStartMS) / MS_PER_CELL), toMSCell = Math.floor((toDateMS - timeAxisStartMS) / MS_PER_CELL), fromRowCell = Math.floor(fromIndex / ROWS_PER_CELL), toRowCell = Math.floor(toIndex / ROWS_PER_CELL), firstMSCell = Math.min(fromMSCell, toMSCell), lastMSCell = Math.max(fromMSCell, toMSCell), firstRowCell = Math.min(fromRowCell, toRowCell), lastRowCell = Math.max(fromRowCell, toRowCell);
        if (firstMSCell < 0 && lastMSCell < 0 || firstMSCell > timeAxisCells && lastMSCell > timeAxisCells) {
          return;
        }
        const startMSCell = Math.max(firstMSCell, 0), endMSCell = Math.min(lastMSCell, timeAxisCells);
        for (let i = startMSCell; i <= endMSCell; i++) {
          var _me$gridCache$i;
          const msCell = (_me$gridCache$i = me.gridCache[i]) !== null && _me$gridCache$i !== void 0 ? _me$gridCache$i : me.gridCache[i] = {};
          for (let j = firstRowCell; j <= lastRowCell; j++) {
            var _msCell$j;
            const rowCell = (_msCell$j = msCell[j]) !== null && _msCell$j !== void 0 ? _msCell$j : msCell[j] = [];
            rowCell.push(dependency);
          }
        }
      }
    }
    beforeDraw() {
      const me = this;
      if (!me.gridCache) {
        const {
          visibleDateRange
        } = me.client;
        me.constructGridCache = true;
        me.MS_PER_CELL = Math.max(visibleDateRange.endMS - visibleDateRange.startMS, 1e3);
        me.gridCache = {};
      }
    }
    afterDraw() {
      this.constructGridCache = false;
    }
    reset() {
      this.gridCache = null;
    }
  }, _defineProperty(_class, "$name", "DependencyGridCache"), _class;
};
var THRESHOLD = Math.min(1 / globalThis.devicePixelRatio, 0.75);
var BOX_PROPERTIES = ["start", "end", "top", "bottom"];
var equalEnough = (a, b) => Math.abs(a - b) < 0.1;
var RectangularPathFinder = class extends Base$1 {
  static get configurable() {
    return {
      startSide: "right",
      startArrowMargin: 12,
      startShift: 0,
      endSide: "left",
      endArrowMargin: 12,
      endShift: 0,
      verticalMargin: 2,
      horizontalMargin: 5,
      otherBoxes: null,
      client: {}
    };
  }
  findPath(lineDef, noPathFallbackFn) {
    const me = this, originalLineDef = lineDef;
    let lineDefFull, startBox, endBox, startShift, endShift, startSide, endSide, startArrowMargin, endArrowMargin, horizontalMargin, verticalMargin, startHorizontalMargin, startVerticalMargin, endHorizontalMargin, endVerticalMargin, otherHorizontalMargin, otherVerticalMargin, otherBoxes, connStartPoint, connEndPoint, pathStartPoint, pathEndPoint, gridStartPoint, gridEndPoint, startGridBox, endGridBox, grid, path, tryNum;
    noPathFallbackFn = ArrayHelper.asArray(noPathFallbackFn);
    for (tryNum = 0; lineDef && !path; ) {
      lineDefFull = Object.assign(me.config, lineDef);
      startBox = lineDefFull.startBox;
      endBox = lineDefFull.endBox;
      startShift = lineDefFull.startShift;
      endShift = lineDefFull.endShift;
      startSide = lineDefFull.startSide;
      endSide = lineDefFull.endSide;
      startArrowMargin = lineDefFull.startArrowMargin;
      endArrowMargin = lineDefFull.endArrowMargin;
      horizontalMargin = lineDefFull.horizontalMargin;
      verticalMargin = lineDefFull.verticalMargin;
      startHorizontalMargin = lineDefFull.hasOwnProperty("startHorizontalMargin") ? lineDefFull.startHorizontalMargin : horizontalMargin;
      startVerticalMargin = lineDefFull.hasOwnProperty("startVerticalMargin") ? lineDefFull.startVerticalMargin : verticalMargin;
      endHorizontalMargin = lineDefFull.hasOwnProperty("endHorizontalMargin") ? lineDefFull.endHorizontalMargin : horizontalMargin;
      endVerticalMargin = lineDefFull.hasOwnProperty("endVerticalMargin") ? lineDefFull.endVerticalMargin : verticalMargin;
      otherHorizontalMargin = lineDefFull.hasOwnProperty("otherHorizontalMargin") ? lineDefFull.otherHorizontalMargin : horizontalMargin;
      otherVerticalMargin = lineDefFull.hasOwnProperty("otherVerticalMargin") ? lineDefFull.otherVerticalMargin : verticalMargin;
      otherBoxes = lineDefFull.otherBoxes;
      startSide = me.normalizeSide(startSide);
      endSide = me.normalizeSide(endSide);
      connStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startBox, startSide, startShift);
      connEndPoint = me.getConnectionCoordinatesFromBoxSideShift(endBox, endSide, endShift);
      startGridBox = me.calcGridBaseBoxFromBoxAndDrawParams(startBox, startSide, startArrowMargin, startHorizontalMargin, startVerticalMargin);
      endGridBox = me.calcGridBaseBoxFromBoxAndDrawParams(endBox, endSide, endArrowMargin, endHorizontalMargin, endVerticalMargin);
      BOX_PROPERTIES.forEach((property) => {
        if (Math.abs(startGridBox[property] - endGridBox[property]) <= THRESHOLD) {
          endGridBox[property] = startGridBox[property];
        }
      });
      if (me.shouldLookForPath(startBox, endBox, startGridBox, endGridBox)) {
        var _otherBoxes;
        otherBoxes = (_otherBoxes = otherBoxes) === null || _otherBoxes === void 0 ? void 0 : _otherBoxes.map((box) => me.calcGridBaseBoxFromBoxAndDrawParams(box, false, 0, otherHorizontalMargin, otherVerticalMargin));
        pathStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startGridBox, startSide, startShift);
        pathEndPoint = me.getConnectionCoordinatesFromBoxSideShift(endGridBox, endSide, endShift);
        grid = me.buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherBoxes);
        gridStartPoint = me.convertDecartPointToGridPoint(grid, pathStartPoint);
        gridEndPoint = me.convertDecartPointToGridPoint(grid, pathEndPoint);
        path = me.findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide);
      }
      for (lineDef = false; !path && !lineDef && noPathFallbackFn && tryNum < noPathFallbackFn.length; tryNum++) {
        lineDef = noPathFallbackFn[tryNum](lineDefFull, originalLineDef);
      }
    }
    if (path) {
      path = me.prependPathWithArrowStaffSegment(path, connStartPoint, startSide);
      path = me.appendPathWithArrowStaffSegment(path, connEndPoint, endSide);
      path = me.optimizePath(path);
    }
    return path;
  }
  static calculateRelativePosition(box1, box2, vertical = false) {
    const startProp = vertical ? "top" : "start", endProp = vertical ? "bottom" : "end";
    let result;
    if (box1[endProp] < box2[startProp]) {
      result = 0;
    } else if (box1[endProp] <= box2[endProp] && box1[endProp] >= box2[startProp] && box1[startProp] < box2[startProp]) {
      result = 1;
    } else if (box1[startProp] >= box2[startProp] && box1[endProp] <= box2[endProp]) {
      result = 2;
    } else if (box1[startProp] < box2[startProp] && box1[endProp] > box2[endProp]) {
      result = -2;
    } else if (box1[startProp] <= box2[endProp] && box1[endProp] > box2[endProp]) {
      result = 3;
    } else {
      result = 4;
    }
    return result;
  }
  static boxOverlapChanged(startBox, endBox, gridStartBox, gridEndBox, vertical = false) {
    const calculateOverlap = RectangularPathFinder.calculateRelativePosition, originalOverlap = calculateOverlap(startBox, endBox, vertical), finalOverlap = calculateOverlap(gridStartBox, gridEndBox, vertical);
    return originalOverlap !== finalOverlap;
  }
  shouldLookForPath(startBox, endBox, gridStartBox, gridEndBox) {
    let result = true;
    if ((startBox.end - startBox.start <= this.startArrowMargin || endBox.end - endBox.start <= this.endArrowMargin) && Math.abs(RectangularPathFinder.calculateRelativePosition(startBox, endBox, true)) === 2) {
      result = !RectangularPathFinder.boxOverlapChanged(startBox, endBox, gridStartBox, gridEndBox);
    }
    return result;
  }
  getConnectionCoordinatesFromBoxSideShift(box, side, shift) {
    let coords;
    switch (side) {
      case "left":
        coords = {
          x: box.start,
          y: (box.top + box.bottom) / 2 + shift
        };
        break;
      case "right":
        coords = {
          x: box.end,
          y: (box.top + box.bottom) / 2 + shift
        };
        break;
      case "top":
        coords = {
          x: (box.start + box.end) / 2 + shift,
          y: box.top
        };
        break;
      case "bottom":
        coords = {
          x: (box.start + box.end) / 2 + shift,
          y: box.bottom
        };
        break;
    }
    return coords;
  }
  calcGridBaseBoxFromBoxAndDrawParams(box, side, arrowMargin, horizontalMargin, verticalMargin) {
    let gridBox;
    switch (this.normalizeSide(side)) {
      case "left":
        gridBox = {
          start: box.start - Math.max(arrowMargin, horizontalMargin),
          end: box.end + horizontalMargin,
          top: box.top - verticalMargin,
          bottom: box.bottom + verticalMargin
        };
        break;
      case "right":
        gridBox = {
          start: box.start - horizontalMargin,
          end: box.end + Math.max(arrowMargin, horizontalMargin),
          top: box.top - verticalMargin,
          bottom: box.bottom + verticalMargin
        };
        break;
      case "top":
        gridBox = {
          start: box.start - horizontalMargin,
          end: box.end + horizontalMargin,
          top: box.top - Math.max(arrowMargin, verticalMargin),
          bottom: box.bottom + verticalMargin
        };
        break;
      case "bottom":
        gridBox = {
          start: box.start - horizontalMargin,
          end: box.end + horizontalMargin,
          top: box.top - verticalMargin,
          bottom: box.bottom + Math.max(arrowMargin, verticalMargin)
        };
        break;
      default:
        gridBox = {
          start: box.start - horizontalMargin,
          end: box.end + horizontalMargin,
          top: box.top - verticalMargin,
          bottom: box.bottom + verticalMargin
        };
    }
    return gridBox;
  }
  normalizeSide(side) {
    const {
      rtl
    } = this.client;
    if (side === "start") {
      return rtl ? "right" : "left";
    }
    if (side === "end") {
      return rtl ? "left" : "right";
    }
    return side;
  }
  buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherGridBoxes) {
    let xs, ys, y, x, ix, iy, xslen, yslen, ib, blen, box, permitted, point;
    const points = {}, linearPoints = [];
    xs = [startGridBox.start, startSide === "left" || startSide === "right" ? (startGridBox.start + startGridBox.end) / 2 : pathStartPoint.x, startGridBox.end, endGridBox.start, endSide === "left" || endSide === "right" ? (endGridBox.start + endGridBox.end) / 2 : pathEndPoint.x, endGridBox.end];
    ys = [startGridBox.top, startSide === "top" || startSide === "bottom" ? (startGridBox.top + startGridBox.bottom) / 2 : pathStartPoint.y, startGridBox.bottom, endGridBox.top, endSide === "top" || endSide === "bottom" ? (endGridBox.top + endGridBox.bottom) / 2 : pathEndPoint.y, endGridBox.bottom];
    if (otherGridBoxes) {
      otherGridBoxes.forEach((box2) => {
        xs.push(box2.start, (box2.start + box2.end) / 2, box2.end);
        ys.push(box2.top, (box2.top + box2.bottom) / 2, box2.bottom);
      });
    }
    xs = [...new Set(xs.sort((a, b) => a - b))];
    ys = [...new Set(ys.sort((a, b) => a - b))];
    for (iy = 0, yslen = ys.length; iy < yslen; ++iy) {
      points[iy] = points[iy] || {};
      y = ys[iy];
      for (ix = 0, xslen = xs.length; ix < xslen; ++ix) {
        x = xs[ix];
        permitted = (x <= startGridBox.start || x >= startGridBox.end || y <= startGridBox.top || y >= startGridBox.bottom) && (x <= endGridBox.start || x >= endGridBox.end || y <= endGridBox.top || y >= endGridBox.bottom);
        if (otherGridBoxes) {
          for (ib = 0, blen = otherGridBoxes.length; permitted && ib < blen; ++ib) {
            box = otherGridBoxes[ib];
            permitted = x <= box.start || x >= box.end || y <= box.top || y >= box.bottom || x === pathStartPoint.x && y === pathStartPoint.y || x === pathEndPoint.x && y === pathEndPoint.y;
          }
        }
        point = {
          distance: Number.MAX_SAFE_INTEGER,
          permitted,
          x,
          y,
          ix,
          iy
        };
        points[iy][ix] = point;
        linearPoints.push(point);
      }
    }
    return {
      width: xs.length,
      height: ys.length,
      xs,
      ys,
      points,
      linearPoints
    };
  }
  convertDecartPointToGridPoint(grid, point) {
    const x = grid.xs.indexOf(point.x), y = grid.ys.indexOf(point.y);
    return grid.points[y][x];
  }
  findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide) {
    const me = this;
    let path = false;
    if (gridStartPoint.permitted && gridEndPoint.permitted) {
      grid = me.waveForward(grid, gridStartPoint, 0);
      path = me.collectPath(grid, gridEndPoint, endSide);
    }
    return path;
  }
  getGridPointNeighbors(grid, gridPoint, predicateFn) {
    const ix = gridPoint.ix, iy = gridPoint.iy, result = [];
    let neighbor;
    if (iy < grid.height - 1) {
      neighbor = grid.points[iy + 1][ix];
      (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
    }
    if (iy > 0) {
      neighbor = grid.points[iy - 1][ix];
      (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
    }
    if (ix < grid.width - 1) {
      neighbor = grid.points[iy][ix + 1];
      (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
    }
    if (ix > 0) {
      neighbor = grid.points[iy][ix - 1];
      (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
    }
    return result;
  }
  waveForward(grid, gridStartPoint, distance) {
    const me = this;
    WalkHelper.preWalkUnordered(
      [gridStartPoint, distance],
      ([point, distance2]) => me.getGridPointNeighbors(grid, point, (neighborPoint) => neighborPoint.permitted && neighborPoint.distance > distance2 + 1).map(
        (neighborPoint) => [neighborPoint, distance2 + 1]
      ),
      ([point, distance2]) => point.distance = distance2
    );
    return grid;
  }
  collectPath(grid, gridEndPoint, endSide) {
    const me = this, path = [];
    let pathFound = true, neighbors, lowestDistanceNeighbor, xDiff, yDiff;
    while (pathFound && gridEndPoint.distance) {
      neighbors = me.getGridPointNeighbors(grid, gridEndPoint, (point) => point.permitted && point.distance === gridEndPoint.distance - 1);
      pathFound = neighbors.length > 0;
      if (pathFound) {
        neighbors = neighbors.sort((a, b) => {
          let xDiff2, yDiff2;
          xDiff2 = a.ix - gridEndPoint.ix;
          yDiff2 = a.iy - gridEndPoint.iy;
          const resultA = (endSide === "left" || endSide === "right") && yDiff2 === 0 || (endSide === "top" || endSide === "bottom") && xDiff2 === 0 ? -1 : 1;
          xDiff2 = b.ix - gridEndPoint.ix;
          yDiff2 = b.iy - gridEndPoint.iy;
          const resultB = (endSide === "left" || endSide === "right") && yDiff2 === 0 || (endSide === "top" || endSide === "bottom") && xDiff2 === 0 ? -1 : 1;
          if (resultA > resultB)
            return 1;
          if (resultA < resultB)
            return -1;
          if (resultA === resultB)
            return a.y > b.y ? -1 : 1;
        });
        lowestDistanceNeighbor = neighbors[0];
        path.push({
          x1: lowestDistanceNeighbor.x,
          y1: lowestDistanceNeighbor.y,
          x2: gridEndPoint.x,
          y2: gridEndPoint.y
        });
        xDiff = lowestDistanceNeighbor.ix - gridEndPoint.ix;
        yDiff = lowestDistanceNeighbor.iy - gridEndPoint.iy;
        switch (true) {
          case (!yDiff && xDiff > 0):
            endSide = "left";
            break;
          case (!yDiff && xDiff < 0):
            endSide = "right";
            break;
          case (!xDiff && yDiff > 0):
            endSide = "top";
            break;
          case (!xDiff && yDiff < 0):
            endSide = "bottom";
            break;
        }
        gridEndPoint = lowestDistanceNeighbor;
      }
    }
    return pathFound && path.reverse() || false;
  }
  prependPathWithArrowStaffSegment(path, connStartPoint, startSide) {
    if (path.length > 0) {
      const firstSegment = path[0], prependSegment = {
        x2: firstSegment.x1,
        y2: firstSegment.y1
      };
      switch (startSide) {
        case "left":
          prependSegment.x1 = connStartPoint.x;
          prependSegment.y1 = firstSegment.y1;
          break;
        case "right":
          prependSegment.x1 = connStartPoint.x;
          prependSegment.y1 = firstSegment.y1;
          break;
        case "top":
          prependSegment.x1 = firstSegment.x1;
          prependSegment.y1 = connStartPoint.y;
          break;
        case "bottom":
          prependSegment.x1 = firstSegment.x1;
          prependSegment.y1 = connStartPoint.y;
          break;
      }
      path.unshift(prependSegment);
    }
    return path;
  }
  appendPathWithArrowStaffSegment(path, connEndPoint, endSide) {
    if (path.length > 0) {
      const lastSegment = path[path.length - 1], appendSegment = {
        x1: lastSegment.x2,
        y1: lastSegment.y2
      };
      switch (endSide) {
        case "left":
          appendSegment.x2 = connEndPoint.x;
          appendSegment.y2 = lastSegment.y2;
          break;
        case "right":
          appendSegment.x2 = connEndPoint.x;
          appendSegment.y2 = lastSegment.y2;
          break;
        case "top":
          appendSegment.x2 = lastSegment.x2;
          appendSegment.y2 = connEndPoint.y;
          break;
        case "bottom":
          appendSegment.x2 = lastSegment.x2;
          appendSegment.y2 = connEndPoint.y;
          break;
      }
      path.push(appendSegment);
    }
    return path;
  }
  optimizePath(path) {
    const optPath = [];
    let prevSegment, curSegment;
    if (path.length > 0) {
      prevSegment = path.shift();
      optPath.push(prevSegment);
      while (path.length > 0) {
        curSegment = path.shift();
        if (equalEnough(prevSegment.x1, curSegment.x1) && equalEnough(prevSegment.y1, curSegment.y1) && equalEnough(prevSegment.x2, curSegment.x2) && equalEnough(prevSegment.y2, curSegment.y2)) {
          prevSegment = curSegment;
        } else if (equalEnough(prevSegment.y1, prevSegment.y2) && equalEnough(curSegment.y1, curSegment.y2)) {
          prevSegment.x2 = curSegment.x2;
        } else if (equalEnough(prevSegment.x1, prevSegment.x2) && equalEnough(curSegment.x1, curSegment.x2)) {
          prevSegment.y2 = curSegment.y2;
        } else {
          optPath.push(curSegment);
          prevSegment = curSegment;
        }
      }
    }
    return optPath;
  }
};
RectangularPathFinder._$name = "RectangularPathFinder";
function drawingDirection(pointSet) {
  if (pointSet.x1 === pointSet.x2) {
    return pointSet.y2 > pointSet.y1 ? "d" : "u";
  }
  return pointSet.x2 > pointSet.x1 ? "r" : "l";
}
function segmentLength(pointSet) {
  return pointSet.x1 === pointSet.x2 ? pointSet.y2 - pointSet.y1 : pointSet.x2 - pointSet.x1;
}
function arc(pointSet, nextPointSet, radius) {
  const corner = drawingDirection(pointSet) + drawingDirection(nextPointSet), rx = radius * (corner.includes("l") ? -1 : 1), ry = radius * (corner.includes("u") ? -1 : 1), sweep = corner === "ur" || corner === "lu" || corner === "dl" || corner === "rd" ? 1 : 0;
  return `a${rx},${ry} 0 0 ${sweep} ${rx},${ry}`;
}
function line(pointSet, nextPointSet, location, radius, prevRadius) {
  let line2 = pointSet.x1 === pointSet.x2 ? "v" : "h", useRadius = radius;
  if (radius) {
    const length = segmentLength(pointSet), nextLength = nextPointSet ? Math.abs(segmentLength(nextPointSet)) : Number.MAX_SAFE_INTEGER, sign = Math.sign(length);
    if (prevRadius == null) {
      prevRadius = radius;
    }
    if (Math.abs(length) < radius * 2 || nextLength < radius * 2) {
      useRadius = Math.min(Math.abs(length), nextLength) / 2;
    }
    const subtract = location === "single" ? 0 : location === "first" ? useRadius : location === "between" ? prevRadius + useRadius : prevRadius, useLength = length - subtract * sign;
    line2 += Math.sign(useLength) !== sign ? 0 : useLength;
    if (location !== "last" && location !== "single" && useRadius > 0) {
      line2 += ` ${arc(pointSet, nextPointSet, useRadius)}`;
    }
  } else {
    line2 += segmentLength(pointSet);
  }
  return {
    line: line2,
    currentRadius: radius !== useRadius ? useRadius : null
  };
}
function pathMapper(radius, points) {
  const {
    length
  } = points;
  if (!length) {
    return "";
  }
  let currentRadius = null;
  return `M${points[0].x1},${points[0].y1} ${points.map((pointSet, i) => {
    const location = length === 1 ? "single" : i === length - 1 ? "last" : i === 0 ? "first" : "between", lineSpec = line(pointSet, points[i + 1], location, radius, currentRadius);
    ({
      currentRadius
    } = lineSpec);
    return lineSpec.line;
  }).join(" ")}`;
}
var DependencyLineGenerator = (Target) => {
  var _class;
  return _class = class DependencyLineGenerator extends Target {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "lineCache", {});
    }
    onSVGReady() {
      const me = this;
      me.pathFinder = new RectangularPathFinder(_objectSpread2(_objectSpread2({}, me.pathFinderConfig), {}, {
        client: me.client
      }));
      me.lineDefAdjusters = me.createLineDefAdjusters();
      me.createMarker();
    }
    changeRadius(radius) {
      if (radius !== null) {
        ObjectHelper.assertNumber(radius, "radius");
      }
      return radius;
    }
    updateRadius() {
      if (!this.isConfiguring) {
        this.reset();
      }
    }
    updateRenderer() {
      if (!this.isConfiguring) {
        this.reset();
      }
    }
    changeClickWidth(width) {
      if (width !== null) {
        ObjectHelper.assertNumber(width, "clickWidth");
      }
      return width;
    }
    updateClickWidth() {
      if (!this.isConfiguring) {
        this.reset();
      }
    }
    createMarker() {
      var _me$marker, _me$markerDef;
      const me = this, {
        markerDef
      } = me, svg = this.client.svgCanvas, markerId = markerDef ? `${me.client.id}-arrowEnd` : "arrowEnd";
      (_me$marker = me.marker) === null || _me$marker === void 0 ? void 0 : _me$marker.remove();
      svg.style.setProperty("--scheduler-dependency-marker", `url(#${markerId})`);
      me.marker = DomHelper.createElement({
        parent: svg,
        id: markerId,
        tag: "marker",
        className: "b-sch-dependency-arrow",
        ns: "http://www.w3.org/2000/svg",
        markerHeight: 11,
        markerWidth: 11,
        refX: 8.5,
        refY: 3,
        viewBox: "0 0 9 6",
        orient: "auto-start-reverse",
        markerUnits: "userSpaceOnUse",
        retainElement: true,
        children: [{
          tag: "path",
          ns: "http://www.w3.org/2000/svg",
          d: (_me$markerDef = me.markerDef) !== null && _me$markerDef !== void 0 ? _me$markerDef : "M3,0 L3,6 L9,3 z"
        }]
      });
    }
    updateMarkerDef() {
      if (!this.isConfiguring) {
        this.createMarker();
      }
    }
    getAssignmentElement(assignment) {
      var _this$client$features;
      const proxyElement = (_this$client$features = this.client.features.eventDrag) === null || _this$client$features === void 0 ? void 0 : _this$client$features.getProxyElement(assignment);
      return proxyElement || this.client.getElementFromAssignmentRecord(assignment);
    }
    getDomConfigs(dependency, fromAssignment, toAssignment, forceBoxes) {
      const me = this, key = me.getDependencyKey(dependency, fromAssignment, toAssignment), cached = me.lineCache[key];
      if (me.constructLineCache || !cached || forceBoxes || me.drawingLive && (me.getAssignmentElement(fromAssignment) || me.getAssignmentElement(toAssignment))) {
        const lineDef = me.prepareLineDef(dependency, fromAssignment, toAssignment, forceBoxes), points = lineDef && me.pathFinder.findPath(lineDef, me.lineDefAdjusters), {
          client,
          clickWidth
        } = me, {
          toEvent
        } = dependency;
        if (points) {
          var _me$radius, _me$renderer;
          const highlighted = me.highlighted.get(dependency), domConfig = {
            tag: "path",
            ns: "http://www.w3.org/2000/svg",
            d: pathMapper((_me$radius = me.radius) !== null && _me$radius !== void 0 ? _me$radius : 0, points),
            role: "presentation",
            dataset: {
              syncId: key,
              depId: dependency.id,
              fromId: fromAssignment.id,
              toId: toAssignment.id
            },
            elementData: {
              dependency,
              points
            },
            class: {
              [me.baseCls]: 1,
              [dependency.cls]: dependency.cls,
              [dependency.highlighted]: dependency.highlighted,
              [highlighted && [...highlighted].join(" ")]: highlighted,
              [me.noMarkerCls]: lineDef.hideMarker,
              "b-inactive": dependency.active === false,
              "b-sch-bidirectional-line": dependency.bidirectional,
              "b-readonly": dependency.readOnly,
              "b-sch-dependency-ends-outside": !toEvent.milestone && (toEvent.endDate <= client.startDate || client.endDate <= toEvent.startDate) || toEvent.milestone && (toEvent.endDate < client.startDate || client.endDate < toEvent.startDate)
            }
          };
          (_me$renderer = me.renderer) === null || _me$renderer === void 0 ? void 0 : _me$renderer.call(me, {
            domConfig,
            points,
            dependencyRecord: dependency,
            fromAssignmentRecord: fromAssignment,
            toAssignmentRecord: toAssignment,
            fromBox: lineDef.startBox,
            toBox: lineDef.endBox,
            fromSide: lineDef.startSide,
            toSide: lineDef.endSide
          });
          const configs = [domConfig];
          if (clickWidth > 1) {
            configs.push(_objectSpread2(_objectSpread2({}, domConfig), {}, {
              class: _objectSpread2(_objectSpread2({}, domConfig.class), {}, {
                "b-click-area": 1
              }),
              dataset: _objectSpread2(_objectSpread2({}, domConfig.dataset), {}, {
                syncId: `${domConfig.dataset.syncId}-click-area`
              }),
              style: {
                strokeWidth: clickWidth
              }
            }));
          }
          return me.lineCache[key] = configs;
        }
        return me.lineCache[key] = null;
      }
      return cached;
    }
    generateBoundaryBoxes(box, side) {
      if (side === "bottom") {
        return [{
          start: box.left,
          end: box.left + box.width / 2,
          top: box.rowTop,
          bottom: box.rowBottom
        }, {
          start: box.left + box.width / 2,
          end: box.right,
          top: box.rowTop,
          bottom: box.rowBottom
        }];
      } else {
        return [{
          start: box.left - this.pathFinder.startArrowMargin,
          end: box.right + this.pathFinder.startArrowMargin,
          top: box.rowTop,
          bottom: box.rowBottom
        }];
      }
    }
    getAssignmentBounds(assignment) {
      const {
        client
      } = this, element = this.getAssignmentElement(assignment);
      if (element && !client.isExporting) {
        const rectangle = Rectangle.from(element, this.relativeTo);
        if (client.isHorizontal) {
          let row = client.getRowById(assignment.resource.id);
          if (rectangle.y < row.top || rectangle.bottom > row.bottom) {
            const overRow = client.rowManager.getRowAt(rectangle.center.y, true);
            if (overRow) {
              row = overRow;
            }
          }
          rectangle.rowTop = row.top;
          rectangle.rowBottom = row.bottom;
        }
        return rectangle;
      }
      return client.isEngineReady && client.getAssignmentEventBox(assignment, true);
    }
    getConnectorStartSide(timeSpanRecord) {
      return this.client.currentOrientation.getConnectorStartSide(timeSpanRecord);
    }
    getConnectorEndSide(timeSpanRecord) {
      return this.client.currentOrientation.getConnectorEndSide(timeSpanRecord);
    }
    getDependencyStartSide(dependency) {
      const {
        fromEvent,
        type,
        fromSide
      } = dependency;
      if (fromSide) {
        return fromSide;
      }
      switch (true) {
        case type === DependencyModel.Type.StartToEnd:
        case type === DependencyModel.Type.StartToStart:
          return this.getConnectorStartSide(fromEvent);
        case type === DependencyModel.Type.EndToStart:
        case type === DependencyModel.Type.EndToEnd:
          return this.getConnectorEndSide(fromEvent);
        default:
          return this.getConnectorEndSide(fromEvent);
      }
    }
    getDependencyEndSide(dependency) {
      const {
        toEvent,
        type,
        toSide
      } = dependency;
      if (toSide) {
        return toSide;
      }
      switch (true) {
        case type === DependencyModel.Type.EndToEnd:
        case type === DependencyModel.Type.StartToEnd:
          return this.getConnectorEndSide(toEvent);
        case type === DependencyModel.Type.EndToStart:
        case type === DependencyModel.Type.StartToStart:
          return this.getConnectorStartSide(toEvent);
        default:
          return this.getConnectorStartSide(toEvent);
      }
    }
    createLineDefAdjusters() {
      const {
        client
      } = this;
      function shrinkArrowMargins(lineDef) {
        const {
          barMargin
        } = client;
        let adjusted = false;
        if (lineDef.startArrowMargin > barMargin || lineDef.endArrowMargin > barMargin) {
          lineDef.startArrowMargin = lineDef.endArrowMargin = barMargin;
          adjusted = true;
        }
        return adjusted ? lineDef : adjusted;
      }
      function resetArrowMargins(lineDef) {
        let adjusted = false;
        if (lineDef.startArrowMargin > 0 || lineDef.endArrowMargin > 0) {
          lineDef.startArrowMargin = lineDef.endArrowMargin = 0;
          adjusted = true;
        }
        return adjusted ? lineDef : adjusted;
      }
      function shrinkHorizontalMargin(lineDef, originalLineDef) {
        let adjusted = false;
        if (lineDef.horizontalMargin > 2) {
          lineDef.horizontalMargin = 1;
          adjusted = true;
          originalLineDef.hideMarker = true;
        }
        return adjusted ? lineDef : adjusted;
      }
      return [shrinkArrowMargins, resetArrowMargins, shrinkHorizontalMargin];
    }
    adjustLineDef(dependency, lineDef) {
      return lineDef;
    }
    prepareLineDef(dependency, fromAssignment, toAssignment, forceBoxes) {
      var _forceBoxes$from, _forceBoxes$to;
      const me = this, startSide = me.getDependencyStartSide(dependency), endSide = me.getDependencyEndSide(dependency), startRectangle = (_forceBoxes$from = forceBoxes === null || forceBoxes === void 0 ? void 0 : forceBoxes.from) !== null && _forceBoxes$from !== void 0 ? _forceBoxes$from : me.getAssignmentBounds(fromAssignment), endRectangle = (_forceBoxes$to = forceBoxes === null || forceBoxes === void 0 ? void 0 : forceBoxes.to) !== null && _forceBoxes$to !== void 0 ? _forceBoxes$to : me.getAssignmentBounds(toAssignment), otherBoxes = [];
      if (!startRectangle || !endRectangle) {
        return null;
      }
      let {
        startArrowMargin,
        verticalMargin
      } = me.pathFinder;
      if (me.client.isHorizontal) {
        if (startRectangle.rowTop != null && startRectangle.rowTop !== endRectangle.rowTop) {
          otherBoxes.push(...me.generateBoundaryBoxes(startRectangle, startSide));
        }
        if (!dependency.bidirectional) {
          if (/(top|bottom)/.test(startSide)) {
            startArrowMargin = me.client.barMargin / 2;
          }
          verticalMargin = me.client.barMargin / 2;
        }
      }
      return me.adjustLineDef(dependency, {
        startBox: startRectangle,
        endBox: endRectangle,
        otherBoxes,
        startArrowMargin,
        verticalMargin,
        otherVerticalMargin: 0,
        otherHorizontalMargin: 0,
        startSide,
        endSide
      });
    }
    beforeDraw() {
      super.beforeDraw();
      if (!Object.keys(this.lineCache).length) {
        this.constructLineCache = true;
      }
    }
    afterDraw() {
      super.afterDraw();
      this.constructLineCache = false;
    }
    reset() {
      super.reset();
      this.lineCache = {};
    }
  }, _defineProperty(_class, "$name", "DependencyLineGenerator"), _class;
};
var fromBoxSide = ["start", "start", "end", "end"];
var toBoxSide = ["start", "end", "start", "end"];
var DependencyTooltip = (Target) => {
  var _class;
  return _class = class DependencyTooltip extends Target {
    changeTooltip(tooltip, old) {
      const me = this;
      old === null || old === void 0 ? void 0 : old.destroy();
      if (!me.showTooltip || !tooltip) {
        return null;
      }
      return Tooltip.new({
        align: "b-t",
        id: `${me.client.id}-dependency-tip`,
        forSelector: `.b-timelinebase:not(.b-eventeditor-editing):not(.b-resizing-event):not(.b-dragcreating):not(.b-dragging-event):not(.b-creating-dependency) .${me.baseCls}`,
        forElement: me.client.timeAxisSubGridElement,
        showOnHover: true,
        hoverDelay: 0,
        hideDelay: 0,
        anchorToTarget: false,
        textContent: false,
        trackMouse: false,
        getHtml: me.getHoverTipHtml.bind(me)
      }, tooltip);
    }
    getHoverTipHtml({
      activeTarget
    }) {
      return this.tooltipTemplate(this.resolveDependencyRecord(activeTarget));
    }
  }, _defineProperty(_class, "$name", "DependencyTooltip"), _defineProperty(_class, "configurable", {
    showTooltip: true,
    tooltipTemplate(dependency) {
      return {
        children: [{
          className: "b-sch-dependency-tooltip",
          children: [{
            tag: "label",
            text: this.L("L{Dependencies.from}")
          }, {
            text: dependency.fromEvent.name
          }, {
            className: `b-sch-box b-${dependency.fromSide || fromBoxSide[dependency.type]}`
          }, {
            tag: "label",
            text: this.L("L{Dependencies.to}")
          }, {
            text: dependency.toEvent.name
          }, {
            className: `b-sch-box b-${dependency.toSide || toBoxSide[dependency.type]}`
          }]
        }]
      };
    },
    tooltip: {
      $config: "nullify",
      value: {}
    }
  }), _class;
};
var eventNameMap$3 = {
  click: "Click",
  dblclick: "DblClick",
  contextmenu: "ContextMenu"
};
var collectLinkedAssignments = (assignment) => {
  var _assignment$resource;
  const result = [assignment];
  if ((_assignment$resource = assignment.resource) !== null && _assignment$resource !== void 0 && _assignment$resource.hasLinks) {
    result.push(...assignment.resource.$links.map((l) => ({
      id: `${l.id}_${assignment.id}`,
      resource: l,
      event: assignment.event,
      drawDependencies: assignment.drawDependencies
    })));
  }
  return result;
};
var Dependencies = class extends InstancePlugin.mixin(AttachToProjectMixin, Delayable, DependencyCreation, DependencyGridCache, DependencyLineGenerator, DependencyTooltip) {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "domConfigs", /* @__PURE__ */ new Map());
    _defineProperty(this, "drawingLive", false);
    _defineProperty(this, "lastScrollX", null);
    _defineProperty(this, "highlighted", /* @__PURE__ */ new Map());
    _defineProperty(this, "visibleResources", null);
    _defineProperty(this, "usingLinks", null);
    _defineProperty(this, "visibleDateRange", null);
    _defineProperty(this, "relativeTo", null);
  }
  static get pluginConfig() {
    return {
      chain: ["render", "onPaint", "onElementClick", "onElementDblClick", "onElementContextMenu", "onElementMouseOver", "onElementMouseOut", "bindStore"],
      assign: ["getElementForDependency", "getElementsForDependency", "resolveDependencyRecord"]
    };
  }
  construct(client, config) {
    super.construct(client, config);
    const {
      scheduledEventName
    } = client;
    client.ion({
      svgCanvasCreated: "onSVGReady",
      animationStart: "refresh",
      [scheduledEventName + "DragStart"]: "refresh",
      [scheduledEventName + "ResizeStart"]: "refresh",
      [scheduledEventName + "SegmentDragStart"]: "refresh",
      [scheduledEventName + "SegmentResizeStart"]: "refresh",
      timelineViewportResize: "reset",
      timeAxisViewModelUpdate: "reset",
      toggleNode: "reset",
      thisObj: this
    });
    client.rowManager.ion({
      refresh: "reset",
      changeTotalHeight: "reset",
      thisObj: this
    });
    this.bindStore(client.store);
  }
  doDisable(disable) {
    if (!this.isConfiguring) {
      this._isDisabling = disable;
      this.draw();
      this._isDisabling = false;
    }
    super.doDisable(disable);
  }
  get rowStore() {
    return this.client.isVertical ? this.client.resourceStore : this.client.store;
  }
  bindStore(store) {
    const me = this;
    if (!me.client.isVertical) {
      me.detachListeners("store");
      if (me.client.usesDisplayStore) {
        store === null || store === void 0 ? void 0 : store.ion({
          name: "store",
          refresh: "onStoreRefresh",
          thisObj: me
        });
        me.reset();
      }
    }
  }
  onStoreRefresh() {
    this.reset();
  }
  attachToProject(project) {
    super.attachToProject(project);
    project === null || project === void 0 ? void 0 : project.ion({
      name: "project",
      commitFinalized: "reset",
      thisObj: this
    });
  }
  attachToResourceStore(resourceStore) {
    super.attachToResourceStore(resourceStore);
    resourceStore === null || resourceStore === void 0 ? void 0 : resourceStore.ion({
      name: "resourceStore",
      change: "onResourceStoreChange",
      refresh: "onResourceStoreChange",
      thisObj: this
    });
  }
  onResourceStoreChange() {
    this.usingLinks = null;
    this.reset();
  }
  attachToEventStore(eventStore) {
    super.attachToEventStore(eventStore);
    eventStore === null || eventStore === void 0 ? void 0 : eventStore.ion({
      name: "eventStore",
      refresh: "reset",
      thisObj: this
    });
  }
  attachToAssignmentStore(assignmentStore) {
    super.attachToAssignmentStore(assignmentStore);
    assignmentStore === null || assignmentStore === void 0 ? void 0 : assignmentStore.ion({
      name: "assignmentStore",
      refresh: "reset",
      thisObj: this
    });
  }
  attachToDependencyStore(dependencyStore) {
    super.attachToDependencyStore(dependencyStore);
    dependencyStore === null || dependencyStore === void 0 ? void 0 : dependencyStore.ion({
      name: "dependencyStore",
      change: "reset",
      refresh: "reset",
      thisObj: this
    });
  }
  updateDrawOnScroll(drawOnScroll) {
    const me = this;
    me.detachListeners("scroll");
    if (drawOnScroll) {
      me.client.ion({
        name: "scroll",
        scroll: "doRefresh",
        horizontalScroll: "onHorizontalScroll",
        prio: -100,
        thisObj: me
      });
    } else {
      me.client.scrollable.ion({
        name: "scroll",
        scrollEnd: "draw",
        thisObj: me
      });
      me.client.timeAxisSubGrid.scrollable.ion({
        name: "scroll",
        scrollEnd: "draw",
        thisObj: me
      });
    }
  }
  onHorizontalScroll({
    subGrid,
    scrollX
  }) {
    if (scrollX !== this.lastScrollX && subGrid === this.client.timeAxisSubGrid) {
      this.lastScrollX = scrollX;
      this.draw();
    }
  }
  onPaint() {
    this.refresh();
  }
  static getLocalizedDependencyType(type) {
    return type ? this.L(`L{DependencyType.${type}}`) : "";
  }
  getElementForDependency(dependency, fromAssignment, toAssignment) {
    return this.getElementsForDependency(dependency, fromAssignment, toAssignment)[0];
  }
  getElementsForDependency(dependency, fromAssignment, toAssignment) {
    let selector = `[data-dep-id="${dependency.id}"]`;
    if (fromAssignment) {
      selector += `[data-from-id="${fromAssignment.id}"]`;
    }
    if (toAssignment) {
      selector += `[data-to-id="${toAssignment.id}"]`;
    }
    return Array.from(this.client.svgCanvas.querySelectorAll(selector));
  }
  resolveDependencyRecord(element) {
    var _element$elementData;
    return (_element$elementData = element.elementData) === null || _element$elementData === void 0 ? void 0 : _element$elementData.dependency;
  }
  isDependencyElement(element) {
    return element.matches(`.${this.baseCls}`);
  }
  onElementClick(event) {
    const dependency = this.resolveDependencyRecord(event.target);
    if (dependency) {
      const eventName = eventNameMap$3[event.type];
      this.client.trigger(`dependency${eventName}`, {
        dependency,
        event
      });
    }
  }
  onElementDblClick(event) {
    return this.onElementClick(event);
  }
  onElementContextMenu(event) {
    return this.onElementClick(event);
  }
  onElementMouseOver(event) {
    const me = this, dependency = me.resolveDependencyRecord(event.target);
    if (dependency) {
      me.client.trigger("dependencyMouseOver", {
        dependency,
        event
      });
      if (me.overCls) {
        me.highlight(dependency);
      }
    }
  }
  onElementMouseOut(event) {
    const me = this, dependency = me.resolveDependencyRecord(event.target);
    if (dependency) {
      me.client.trigger("dependencyMouseOut", {
        dependency,
        event
      });
      if (me.overCls) {
        me.unhighlight(dependency);
      }
    }
  }
  isDependencyVisible(dependency) {
    const me = this, {
      rowStore
    } = me, {
      fromEvent,
      toEvent
    } = dependency;
    if (!fromEvent || !toEvent) {
      return false;
    }
    const fromResource = fromEvent.resource, toResource = toEvent.resource;
    if (!rowStore.isAvailable(fromResource) || !rowStore.isAvailable(toResource)) {
      return false;
    }
    return fromEvent.isModel && !fromResource.instanceMeta(rowStore).hidden && !toResource.instanceMeta(rowStore).hidden;
  }
  updateHighlightDependenciesOnEventHover(enable) {
    const me = this;
    if (enable) {
      const {
        client
      } = me;
      client.ion({
        name: "highlightOnHover",
        [`${client.scheduledEventName}MouseEnter`]: (params) => me.highlightEventDependencies(params.eventRecord || params.taskRecord),
        [`${client.scheduledEventName}MouseLeave`]: (params) => me.unhighlightEventDependencies(params.eventRecord || params.taskRecord),
        thisObj: me
      });
    } else {
      me.detachListeners("highlightOnHover");
    }
  }
  highlight(dependency, cls = this.overCls) {
    let classes = this.highlighted.get(dependency);
    if (!classes) {
      this.highlighted.set(dependency, classes = /* @__PURE__ */ new Set());
    }
    classes.add(cls);
    this.lineCache = {};
    this.refresh();
  }
  unhighlight(dependency, cls = this.overCls) {
    const classes = this.highlighted.get(dependency);
    if (classes) {
      classes.delete(cls);
      if (!classes.size) {
        this.highlighted.delete(dependency);
      }
    }
    this.lineCache = {};
    this.refresh();
  }
  highlightEventDependencies(timespan, cls) {
    timespan.dependencies.forEach((dep) => this.highlight(dep, cls));
  }
  unhighlightEventDependencies(timespan, cls) {
    timespan.dependencies.forEach((dep) => this.unhighlight(dep, cls));
  }
  getDependenciesToConsider(startMS, endMS, startIndex, endIndex) {
    var _super$getDependencie, _super$getDependencie2;
    return (_super$getDependencie = (_super$getDependencie2 = super.getDependenciesToConsider) === null || _super$getDependencie2 === void 0 ? void 0 : _super$getDependencie2.call(this, startMS, endMS, startIndex, endIndex)) !== null && _super$getDependencie !== void 0 ? _super$getDependencie : this.project.dependencyStore.records.filter((d) => d.isValid);
  }
  getDependencyKey(dependency, fromAssignment, toAssignment) {
    return `dep:${dependency.id};from:${fromAssignment.id};to:${toAssignment.id}`;
  }
  drawDependency(dependency, batch = false, forceBoxes = null) {
    var _fromAssigned, _toAssigned;
    const me = this, {
      domConfigs,
      client,
      rowStore,
      topIndex,
      bottomIndex
    } = me, {
      eventStore,
      useInitialAnimation
    } = client, {
      idMap
    } = rowStore, {
      startMS,
      endMS
    } = me.visibleDateRange, {
      fromEvent,
      toEvent
    } = dependency;
    let fromAssigned = fromEvent.assigned, toAssigned = toEvent.assigned;
    if (fromEvent.isScheduled && toEvent.isScheduled && eventStore.includes(fromEvent) && eventStore.includes(toEvent) && (_fromAssigned = fromAssigned) !== null && _fromAssigned !== void 0 && _fromAssigned.size && (_toAssigned = toAssigned) !== null && _toAssigned !== void 0 && _toAssigned.size) {
      if (me.usingLinks) {
        fromAssigned = [...fromAssigned].flatMap(collectLinkedAssignments);
        toAssigned = [...toAssigned].flatMap(collectLinkedAssignments);
      }
      for (const from of fromAssigned) {
        for (const to of toAssigned) {
          var _idMap$from$resource$, _from$resource, _idMap$to$resource$id, _to$resource;
          const fromIndex = (_idMap$from$resource$ = idMap[(_from$resource = from.resource) === null || _from$resource === void 0 ? void 0 : _from$resource.id]) === null || _idMap$from$resource$ === void 0 ? void 0 : _idMap$from$resource$.index, toIndex = (_idMap$to$resource$id = idMap[(_to$resource = to.resource) === null || _to$resource === void 0 ? void 0 : _to$resource.id]) === null || _idMap$to$resource$id === void 0 ? void 0 : _idMap$to$resource$id.index, fromDateMS = Math.min(fromEvent.startDateMS, toEvent.startDateMS), toDateMS = Math.max(fromEvent.endDateMS, toEvent.endDateMS);
          if (client.isExporting || fromIndex != null && toIndex != null && from.drawDependencies !== false && to.drawDependencies !== false && rowStore.isAvailable(from.resource) && rowStore.isAvailable(to.resource) && !(fromIndex < topIndex && toIndex < topIndex || fromIndex > bottomIndex && toIndex > bottomIndex || fromDateMS < startMS && toDateMS < startMS || fromDateMS > endMS && toDateMS > endMS)) {
            const key = me.getDependencyKey(dependency, from, to), lineDomConfigs = me.getDomConfigs(dependency, from, to, forceBoxes);
            if (lineDomConfigs) {
              if (useInitialAnimation) {
                lineDomConfigs[0].style = {
                  animationDelay: `${Math.max(fromIndex, toIndex) / 20 * 1e3}ms`
                };
              }
              domConfigs.set(key, lineDomConfigs);
            } else {
              domConfigs.delete(key);
            }
          }
          me.afterDrawDependency(dependency, fromIndex, toIndex, fromDateMS, toDateMS);
        }
      }
    }
    if (!batch) {
      me.domSync();
    }
  }
  afterDrawDependency(dependency, fromIndex, toIndex, fromDateMS, toDateMS) {
    var _super$afterDrawDepen;
    (_super$afterDrawDepen = super.afterDrawDependency) === null || _super$afterDrawDepen === void 0 ? void 0 : _super$afterDrawDepen.call(this, dependency, fromIndex, toIndex, fromDateMS, toDateMS);
  }
  beforeDraw() {
    var _super$beforeDraw;
    (_super$beforeDraw = super.beforeDraw) === null || _super$beforeDraw === void 0 ? void 0 : _super$beforeDraw.call(this);
  }
  afterDraw() {
    var _super$afterDraw;
    (_super$afterDraw = super.afterDraw) === null || _super$afterDraw === void 0 ? void 0 : _super$afterDraw.call(this);
  }
  domSync(targetElement = this.client.svgCanvas) {
    DomSync.sync({
      targetElement,
      domConfig: {
        onlyChildren: true,
        children: Array.from(this.domConfigs.values()).flat()
      },
      syncIdField: "syncId",
      releaseThreshold: 0,
      strict: true,
      callback() {
      }
    });
  }
  fillDrawingCache() {
    const me = this, {
      client
    } = me;
    me.relativeTo = Rectangle.from(client.foregroundCanvas);
    me.visibleResources = client.visibleResources;
    me.visibleDateRange = client.visibleDateRange;
    me.topIndex = me.rowStore.indexOf(me.visibleResources.first);
    me.bottomIndex = me.rowStore.indexOf(me.visibleResources.last);
    if (me.usingLinks == null) {
      me.usingLinks = client.resourceStore.some((r) => r.hasLinks);
    }
  }
  draw() {
    const me = this, {
      client
    } = me;
    if (client.refreshSuspended || !client.foregroundCanvas || !client.isEngineReady || me.disabled && !me._isDisabling || client.isExporting) {
      return;
    }
    me.fillDrawingCache();
    me.domConfigs.clear();
    if (client.firstVisibleRow && client.lastVisibleRow && client.timeAxis.count && !me.disabled && me.visibleDateRange.endMS - me.visibleDateRange.startMS > 0) {
      const {
        visibleDateRange
      } = client, {
        topIndex,
        bottomIndex
      } = me, dependencies = me.getDependenciesToConsider(visibleDateRange.startMS, visibleDateRange.endMS, topIndex, bottomIndex);
      me.beforeDraw();
      for (const dependency of dependencies) {
        me.drawDependency(dependency, true);
      }
      me.afterDraw();
    }
    me.domSync();
    client.trigger("dependenciesDrawn");
  }
  doRefresh() {
    var _client$features, _client$features2, _client$features3, _client$features4;
    const me = this, {
      client
    } = me, {
      scheduledEventName
    } = client;
    me.draw();
    me.drawingLive = client.isAnimating || client.useInitialAnimation || ((_client$features = client.features[`${scheduledEventName}Drag`]) === null || _client$features === void 0 ? void 0 : _client$features.isActivelyDragging) || ((_client$features2 = client.features[`${scheduledEventName}Resize`]) === null || _client$features2 === void 0 ? void 0 : _client$features2.isResizing) || ((_client$features3 = client.features[`${scheduledEventName}SegmentDrag`]) === null || _client$features3 === void 0 ? void 0 : _client$features3.isActivelyDragging) || ((_client$features4 = client.features[`${scheduledEventName}SegmentResize`]) === null || _client$features4 === void 0 ? void 0 : _client$features4.isResizing);
    me.drawingLive && me.refresh();
  }
  refresh() {
    if (!this.client.refreshSuspended && !this.disabled && this.client.isPainted) {
      this.doRefresh();
    }
  }
  reset() {
    var _super$reset;
    (_super$reset = super.reset) === null || _super$reset === void 0 ? void 0 : _super$reset.call(this);
    this.refresh();
  }
  drawForEvent() {
    VersionHelper.deprecate("Scheduler", "6.0.0", "Dependencies.drawForEvent() is no longer needed");
    this.refresh();
  }
  render() {
    this.client.getConfig("svgCanvas");
  }
};
_defineProperty(Dependencies, "$name", "Dependencies");
_defineProperty(Dependencies, "configurable", {
  overCls: "b-sch-dependency-over",
  baseCls: "b-sch-dependency",
  noMarkerCls: "b-sch-dependency-markerless",
  markerDef: null,
  radius: null,
  renderer: null,
  highlightDependenciesOnEventHover: null,
  drawOnScroll: true,
  clickWidth: null
});
_defineProperty(Dependencies, "delayable", {
  doRefresh: 10
});
Dependencies._$name = "Dependencies";
GridFeatureManager.registerFeature(Dependencies, false, ["Scheduler", "ResourceHistogram"]);
GridFeatureManager.registerFeature(Dependencies, true, "SchedulerPro");
var DependencyEditor = class extends Popup {
  static get $name() {
    return "DependencyEditor";
  }
  static get defaultConfig() {
    return {
      items: [],
      draggable: {
        handleSelector: ":not(button,.b-field-inner)"
      },
      axisLock: "flexible"
    };
  }
  processWidgetConfig(widget) {
    const {
      dependencyEditFeature
    } = this;
    if (widget.ref === "lagField" && !dependencyEditFeature.showLagField) {
      return false;
    }
    if (widget.ref === "deleteButton" && !dependencyEditFeature.showDeleteButton) {
      return false;
    }
    return super.processWidgetConfig(widget);
  }
  afterShow(...args) {
    const {
      deleteButton
    } = this.widgetMap;
    if (deleteButton) {
      deleteButton.hidden = !this.record.isPartOfStore();
    }
    super.afterShow(...args);
  }
  onInternalKeyDown(event) {
    this.trigger("keyDown", {
      event
    });
    super.onInternalKeyDown(event);
  }
};
DependencyEditor._$name = "DependencyEditor";
var DependencyEdit = class extends InstancePlugin {
  static get $name() {
    return "DependencyEdit";
  }
  static get configurable() {
    return {
      autoClose: true,
      saveAndCloseOnEnter: true,
      showDeleteButton: true,
      triggerEvent: "dependencydblclick",
      showLagField: false,
      dependencyRecord: null,
      editorConfig: {
        title: "L{Edit dependency}",
        localeClass: this,
        closable: true,
        defaults: {
          localeClass: this
        },
        items: {
          fromNameField: {
            type: "display",
            weight: 100,
            label: "L{From}"
          },
          toNameField: {
            type: "display",
            weight: 200,
            label: "L{To}"
          },
          typeField: {
            type: "combo",
            weight: 300,
            label: "L{Type}",
            name: "type",
            editable: false,
            valueField: "id",
            displayField: "name",
            localizeDisplayFields: true,
            buildItems: function() {
              const dialog = this.parent;
              return Object.keys(DependencyModel.Type).map((type) => {
                return {
                  id: DependencyModel.Type[type],
                  name: dialog.L(type),
                  localeKey: type
                };
              });
            }
          },
          lagField: {
            type: "duration",
            weight: 400,
            label: "L{Lag}",
            name: "lag",
            allowNegative: true
          }
        },
        bbar: {
          defaults: {
            localeClass: this
          },
          items: {
            foo: {
              type: "widget",
              cls: "b-label-filler"
            },
            saveButton: {
              color: "b-green",
              text: "L{Save}"
            },
            deleteButton: {
              color: "b-gray",
              text: "L{Delete}"
            },
            cancelButton: {
              color: "b-gray",
              text: "L{Object.Cancel}"
            }
          }
        }
      }
    };
  }
  construct(client, config) {
    const me = this;
    client.dependencyEdit = me;
    super.construct(client, config);
    if (!client.features.dependencies) {
      throw new Error("Dependencies feature required when using DependencyEdit");
    }
    me.clientListenersDetacher = client.ion({
      [me.triggerEvent]: me.onActivateEditor,
      thisObj: me
    });
  }
  doDestroy() {
    var _this$editor;
    this.clientListenersDetacher();
    (_this$editor = this.editor) === null || _this$editor === void 0 ? void 0 : _this$editor.destroy();
    super.doDestroy();
  }
  changeEditorConfig(config) {
    const me = this, {
      autoClose,
      cls,
      client
    } = me;
    return ObjectHelper.assign({
      owner: client,
      align: "b-t",
      "id": `${client.id}-dependency-editor`,
      autoShow: false,
      anchor: true,
      scrollAction: "realign",
      clippedBy: [client.timeAxisSubGridElement, client.bodyContainer],
      constrainTo: globalThis,
      autoClose,
      cls
    }, config);
  }
  get isValid() {
    return Object.values(this.editor.widgetMap).every((field) => {
      if (!field.name || field.hidden) {
        return true;
      }
      return field.isValid !== false;
    });
  }
  get values() {
    const values = {};
    this.editor.eachWidget((widget) => {
      if (!widget.name || widget.hidden)
        return;
      values[widget.name] = widget.value;
    }, true);
    return values;
  }
  onBeforeSave(dependencyRecord) {
  }
  onAfterSave(dependencyRecord) {
  }
  updateRecord(dependencyRecord) {
    const {
      values
    } = this;
    if (values.lag) {
      values.lagUnit = values.lag.unit;
      values.lag = values.lag.magnitude;
    }
    if ("type" in values) {
      dependencyRecord.fromSide != null && (values.fromSide = null);
      dependencyRecord.toSide != null && (values.toSide = null);
    }
    ObjectHelper.cleanupProperties(values, true);
    dependencyRecord.set(values);
  }
  onPopupKeyDown({
    event
  }) {
    if (event.key === "Enter" && this.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === "input") {
      event.preventDefault();
      this.onSaveClick();
    }
  }
  onSaveClick() {
    if (this.save()) {
      this.editor.hide();
    }
  }
  onDeleteClick() {
    this.deleteDependency();
    this.editor.hide();
  }
  onCancelClick() {
    this.editor.hide();
  }
  internalShowEditor(dependencyRecord) {
    const me = this, {
      client
    } = me;
    let showPoint = me.lastPointerDownCoordinate;
    if (client.trigger("beforeDependencyEdit", {
      dependencyEdit: me,
      dependencyRecord
    }) === false) {
      return;
    }
    const editor = me.getEditor(dependencyRecord);
    me.loadRecord(dependencyRecord);
    client.trigger("beforeDependencyEditShow", {
      dependencyEdit: me,
      dependencyRecord,
      editor
    });
    if (!showPoint) {
      const center = Rectangle.from(me.client.element).center;
      showPoint = [center.x - editor.width / 2, center.y - editor.height / 2];
    }
    editor.showBy(showPoint);
  }
  editDependency(dependencyRecord) {
    if (this.client.readOnly || dependencyRecord.readOnly) {
      return;
    }
    this.internalShowEditor(dependencyRecord);
  }
  getEditor() {
    var _me$saveButton, _me$deleteButton, _me$cancelButton;
    const me = this;
    let {
      editor
    } = me;
    if (editor) {
      return editor;
    }
    editor = me.editor = DependencyEditor.new({
      dependencyEditFeature: me,
      autoShow: false,
      anchor: true,
      scrollAction: "realign",
      constrainTo: globalThis,
      autoClose: me.autoClose,
      cls: me.cls,
      rootElement: me.client.rootElement,
      internalListeners: {
        keydown: me.onPopupKeyDown,
        thisObj: me
      }
    }, me.editorConfig);
    if (editor.items.length === 0) {
      console.warn("Editor configured without any `items`");
    }
    editor.eachWidget((widget) => {
      const ref = widget.ref || widget.id;
      if (ref && !me[ref]) {
        me[ref] = widget;
      }
    });
    (_me$saveButton = me.saveButton) === null || _me$saveButton === void 0 ? void 0 : _me$saveButton.ion({
      click: "onSaveClick",
      thisObj: me
    });
    (_me$deleteButton = me.deleteButton) === null || _me$deleteButton === void 0 ? void 0 : _me$deleteButton.ion({
      click: "onDeleteClick",
      thisObj: me
    });
    (_me$cancelButton = me.cancelButton) === null || _me$cancelButton === void 0 ? void 0 : _me$cancelButton.ion({
      click: "onCancelClick",
      thisObj: me
    });
    return me.editor;
  }
  loadRecord(dependency) {
    const me = this;
    me.fromNameField.value = dependency.fromEvent.name;
    me.toNameField.value = dependency.toEvent.name;
    if (me.lagField) {
      me.lagField.value = new Duration(dependency.lag, dependency.lagUnit);
    }
    me.editor.record = me.dependencyRecord = dependency;
  }
  async save() {
    const me = this, {
      client,
      dependencyRecord
    } = me;
    if (!dependencyRecord || !me.isValid) {
      return;
    }
    const {
      dependencyStore,
      values
    } = me;
    if (client.trigger("beforeDependencySave", {
      dependencyRecord,
      values
    }) !== false) {
      var _client$project;
      me.onBeforeSave(dependencyRecord);
      me.updateRecord(dependencyRecord);
      if (dependencyStore && !dependencyRecord.stores.length) {
        if (client.trigger("beforeDependencyAdd", {
          dependencyRecord,
          dependencyEdit: me
        }) === false) {
          return;
        }
        dependencyStore.add(dependencyRecord);
      }
      await ((_client$project = client.project) === null || _client$project === void 0 ? void 0 : _client$project.commitAsync());
      client.trigger("afterDependencySave", {
        dependencyRecord
      });
      me.onAfterSave(dependencyRecord);
    }
    return dependencyRecord;
  }
  async deleteDependency() {
    const {
      client,
      editor,
      dependencyRecord
    } = this;
    if (client.trigger("beforeDependencyDelete", {
      dependencyRecord
    }) !== false) {
      var _client$project2;
      if (editor.containsFocus) {
        editor.revertFocus();
      }
      client.dependencyStore.remove(dependencyRecord);
      await ((_client$project2 = client.project) === null || _client$project2 === void 0 ? void 0 : _client$project2.commitAsync());
      return true;
    }
    return false;
  }
  get dependencyStore() {
    return this.client.dependencyStore;
  }
  onActivateEditor({
    dependency,
    event
  }) {
    if (!this.disabled) {
      this.lastPointerDownCoordinate = [event.clientX, event.clientY];
      this.editDependency(dependency);
    }
  }
};
DependencyEdit._$name = "DependencyEdit";
GridFeatureManager.registerFeature(DependencyEdit, false);
var ScheduleContext = class extends InstancePlugin.mixin(Delayable) {
  static get $name() {
    return "ScheduleContext";
  }
  construct(client, config) {
    super.construct(client, config);
    const {
      triggerEvent
    } = this, listeners = {
      datachange: "syncContextElement",
      timeaxisviewmodelupdate: "onTimeAxisViewModelUpdate",
      presetchange: "clearContext",
      thisObj: this
    };
    if (triggerEvent === "mouseover") {
      listeners.timelineContextChange = "onTimelineContextChange";
    } else {
      if (triggerEvent === "click" || triggerEvent === "mousedown") {
        listeners.schedulecontextmenu = "onScheduleContextGesture";
      }
      Object.assign(listeners, _objectSpread2({
        [`schedule${triggerEvent}`]: "onScheduleContextGesture",
        [`event${triggerEvent}`]: "onScheduleContextGesture"
      }, listeners));
    }
    client.useBackgroundCanvas = true;
    client.ion(listeners);
    client.rowManager.ion({
      rowheight: "syncContextElement",
      thisObj: this
    });
  }
  changeTriggerEvent(triggerEvent) {
    if (triggerEvent === "hover" || triggerEvent === "mousemove") {
      triggerEvent = "mouseover";
    }
    return triggerEvent;
  }
  get element() {
    return this._element || (this._element = DomHelper.createElement({
      parent: this.client.backgroundCanvas,
      className: "b-schedule-selected-tick"
    }));
  }
  onTimelineContextChange({
    context
  }) {
    this.context = context;
  }
  onScheduleContextGesture(context) {
    this.context = context;
  }
  onTimeAxisViewModelUpdate({
    source: timeAxisViewModel
  }) {
    var _this$context;
    if (timeAxisViewModel.timeAxis.includes((_this$context = this.context) === null || _this$context === void 0 ? void 0 : _this$context.tick)) {
      this.syncContextElement();
    } else {
      this.clearContext();
    }
  }
  clearContext() {
    this.context = null;
  }
  updateContext(context, oldContext) {
    this.syncContextElement();
  }
  syncContextElement() {
    if (this.context && this.enabled) {
      const me = this, {
        client,
        element,
        context,
        renderer
      } = me, {
        isVertical
      } = client, {
        style
      } = element, row = isVertical ? client.rowManager.rows[0] : client.getRowFor(context.resourceRecord);
      if (row) {
        const {
          tickStartDate,
          tickEndDate,
          resourceRecord
        } = context, renderData = client.currentOrientation.getTimeSpanRenderData({
          startDate: tickStartDate,
          endDate: tickEndDate,
          startDateMS: tickStartDate.getTime(),
          endDateMS: tickEndDate.getTime()
        }, resourceRecord);
        let top, width, height;
        if (isVertical) {
          top = renderData.top;
          width = renderData.resourceWidth;
          height = renderData.height;
        } else {
          top = row.top;
          width = renderData.width;
          height = row.height;
        }
        style.display = "";
        style.width = `${width}px`;
        style.height = `${height}px`;
        DomHelper.setTranslateXY(element, renderData.left, top);
        context.index = row.index;
        element.innerHTML = "";
        renderer && me.callback(renderer, me, [context, element]);
      } else {
        style.display = "none";
      }
    } else {
      this.element.style.display = "none";
    }
  }
};
_defineProperty(ScheduleContext, "delayable", {
  syncContextElement: "raf"
});
_defineProperty(ScheduleContext, "configurable", {
  triggerEvent: "click",
  renderer: null,
  context: {
    $config: {
      equal(c1, c2) {
        return (c1 === null || c1 === void 0 ? void 0 : c1.index) === (c2 === null || c2 === void 0 ? void 0 : c2.index) && (c1 === null || c1 === void 0 ? void 0 : c1.tickParentIndex) === (c2 === null || c2 === void 0 ? void 0 : c2.tickParentIndex) && !(((c1 === null || c1 === void 0 ? void 0 : c1.tickStartDate) || 0) - ((c2 === null || c2 === void 0 ? void 0 : c2.tickStartDate) || 0));
      }
    }
  }
});
ScheduleContext.featureClass = "b-scheduler-context";
ScheduleContext._$name = "ScheduleContext";
GridFeatureManager.registerFeature(ScheduleContext, false, ["Scheduler"]);
var EventCopyPaste = class extends InstancePlugin {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "clipboardRecords", []);
    _defineProperty(this, "entityName", "event");
  }
  construct(scheduler, config) {
    super.construct(scheduler, config);
    scheduler.ion({
      eventclick: this.onEventClick,
      scheduleclick: this.onScheduleClick,
      projectChange: () => {
        this.clearClipboard();
        this._cellClickedContext = null;
      },
      thisObj: this
    });
    this.scheduler = scheduler;
  }
  onEventDataGenerated(eventData) {
    const {
      assignmentRecord
    } = eventData;
    if (assignmentRecord) {
      eventData.cls["b-cut-item"] = assignmentRecord.meta.isCut;
    }
  }
  onEventClick(context) {
    this._cellClickedContext = null;
  }
  onScheduleClick(context) {
    this._cellClickedContext = context;
  }
  isActionAvailable(keyCombination, action, event) {
    var _this$client$focusedC;
    const cellEdit = this.client.features.cellEdit;
    return !this.disabled && globalThis.getSelection().toString().length === 0 && !(cellEdit !== null && cellEdit !== void 0 && cellEdit.isEditing) && Boolean(event.target.closest(".b-timeaxissubgrid")) && !((_this$client$focusedC = this.client.focusedCell) !== null && _this$client$focusedC !== void 0 && _this$client$focusedC.isSpecialRow);
  }
  copy() {
    this.copyEvents();
  }
  cut() {
    this.copyEvents(void 0, true);
  }
  paste() {
    this.pasteEvents();
  }
  copyEvents(records = this.scheduler.selectedAssignments, isCut = false) {
    const me = this, {
      scheduler,
      entityName
    } = me;
    if (!(records !== null && records !== void 0 && records.length)) {
      return;
    }
    let assignmentRecords = records.slice();
    if (records[0].isEventModel) {
      assignmentRecords = records.map((r) => r.assignments).flat();
    }
    if (isCut) {
      assignmentRecords = assignmentRecords.filter((a) => !a.event.readOnly);
    }
    const eventRecords = assignmentRecords.map((a) => a.event);
    if (!assignmentRecords.length || scheduler.readOnly || scheduler.trigger("beforeCopy", {
      assignmentRecords,
      records: eventRecords,
      eventRecords,
      isCut,
      entityName
    }) === false) {
      return;
    }
    if (assignmentRecords.length > 0) {
      scheduler.trigger("copy", {
        assignmentRecords,
        eventRecords,
        isCut,
        entityName
      });
    }
    me._isCut = isCut;
    me.clipboard = {
      assignmentRecords,
      eventRecords
    };
    scheduler.assignmentStore.forEach((assignment) => {
      assignment.meta.isCut = isCut && assignmentRecords.includes(assignment);
    });
    scheduler.refreshWithTransition();
  }
  pasteEvents(date2, resourceRecord) {
    const me = this, {
      clipboard,
      scheduler,
      entityName
    } = me, {
      assignmentRecords,
      eventRecords
    } = clipboard, isCut = me._isCut;
    if (arguments.length === 0) {
      const context = me._cellClickedContext || {};
      date2 = context.date;
      resourceRecord = context.resourceRecord;
    }
    if (resourceRecord) {
      if (resourceRecord.readOnly) {
        return;
      }
      resourceRecord = resourceRecord.$original;
    }
    if (!clipboard || scheduler.trigger("beforePaste", {
      assignmentRecords,
      records: eventRecords,
      eventRecords,
      resourceRecord: resourceRecord || assignmentRecords[0].resource,
      date: date2,
      isCut,
      entityName
    }) === false) {
      return;
    }
    let toFocus = null;
    const pastedEvents = /* @__PURE__ */ new Set();
    for (const assignmentRecord of assignmentRecords) {
      let {
        event
      } = assignmentRecord;
      const targetResourceRecord = resourceRecord || assignmentRecord.resource, targetDate = date2 || assignmentRecord.event.startDate;
      if (pastedEvents.has(event)) {
        if (isCut) {
          assignmentRecord.remove();
        }
        continue;
      }
      pastedEvents.add(event);
      if (isCut) {
        assignmentRecord.meta.isCut = false;
        assignmentRecord.resource = targetResourceRecord;
        toFocus = assignmentRecord;
      } else if (scheduler.eventStore.usesSingleAssignment || me.copyPasteAction === "clone") {
        event = event.copy();
        event.name = me.generateNewName(event);
        scheduler.eventStore.add(event);
        event.assign(targetResourceRecord);
        toFocus = scheduler.assignmentStore.last;
      } else if (!event.resources.includes(targetResourceRecord)) {
        const newAssignmentRecord = assignmentRecord.copy();
        newAssignmentRecord.resource = targetResourceRecord;
        [toFocus] = scheduler.assignmentStore.add(newAssignmentRecord);
      }
      event.startDate = targetDate;
      if (event.constraintDate) {
        event.constraintDate = null;
      }
    }
    if (clipboard) {
      scheduler.trigger("paste", {
        assignmentRecords,
        eventRecords,
        resourceRecord,
        date: date2,
        isCut,
        entityName
      });
    }
    const detacher2 = scheduler.ion({
      renderEvent({
        assignmentRecord
      }) {
        if (assignmentRecord === toFocus) {
          scheduler.navigateTo(assignmentRecord, {
            scrollIntoView: false
          });
          detacher2();
        }
      }
    });
    if (isCut) {
      me.clearClipboard();
    }
  }
  clearClipboard() {
    const me = this;
    if (me._isCut) {
      me.clipboard.assignmentRecords.forEach((assignment) => {
        assignment.meta.isCut = false;
      });
      me.scheduler.refreshWithTransition();
      me._isCut = false;
    }
    me.clipboard = null;
  }
  populateEventMenu({
    assignmentRecord,
    items: items2
  }) {
    const me = this;
    if (!me.scheduler.readOnly) {
      items2.copyEvent = {
        text: "L{copyEvent}",
        localeClass: me,
        icon: "b-icon b-icon-copy",
        weight: 110,
        onItem: () => me.copyEvents([assignmentRecord].concat(me.scheduler.selectedAssignments.filter((rec) => rec !== assignmentRecord)))
      };
      items2.cutEvent = {
        text: "L{cutEvent}",
        localeClass: me,
        icon: "b-icon b-icon-cut",
        weight: 120,
        disabled: assignmentRecord.event.readOnly,
        onItem: () => me.copyEvents([assignmentRecord].concat(me.scheduler.selectedAssignments.filter((rec) => rec !== assignmentRecord)), true)
      };
    }
  }
  populateScheduleMenu({
    items: items2,
    resourceRecord
  }) {
    const me = this, {
      scheduler
    } = me;
    if (!scheduler.readOnly && me.clipboard) {
      items2.pasteEvent = {
        text: "L{pasteEvent}",
        localeClass: me,
        icon: "b-icon b-icon-paste",
        disabled: scheduler.resourceStore.count === 0 || resourceRecord.readOnly,
        weight: 110,
        onItem: ({
          date: date2,
          resourceRecord: resourceRecord2
        }) => me.pasteEvents(date2, resourceRecord2, scheduler.getRowFor(resourceRecord2))
      };
    }
  }
  generateNewName(eventRecord) {
    const originalName = eventRecord[this.nameField];
    let counter = 2;
    while (this.client.eventStore.findRecord(this.nameField, `${originalName} - ${counter}`)) {
      counter++;
    }
    return `${originalName} - ${counter}`;
  }
};
_defineProperty(EventCopyPaste, "$name", "EventCopyPaste");
_defineProperty(EventCopyPaste, "pluginConfig", {
  assign: ["copyEvents", "pasteEvents"],
  chain: ["populateEventMenu", "populateScheduleMenu", "onEventDataGenerated"]
});
_defineProperty(EventCopyPaste, "configurable", {
  nameField: "name",
  keyMap: {
    "Ctrl+C": "copy",
    "Ctrl+X": "cut",
    "Ctrl+V": "paste"
  },
  copyPasteAction: "clone"
});
EventCopyPaste.featureClass = "b-event-copypaste";
EventCopyPaste._$name = "EventCopyPaste";
GridFeatureManager.registerFeature(EventCopyPaste, true, "Scheduler");
var EventDrag = class extends DragBase {
  static get $name() {
    return "EventDrag";
  }
  static get configurable() {
    return {
      constrainDragToResource: false,
      constrainDragToTimeSlot: false,
      externalDropTargetSelector: null,
      validatorFn: () => {
      },
      validatorFnThisObj: null,
      unifiedDrag: null,
      snapToPosition: null,
      copyKey: "SHIFT",
      copyMode: "auto",
      mode: "move",
      capitalizedEventName: null
    };
  }
  afterConstruct() {
    this.capitalizedEventName = this.capitalizedEventName || this.client.capitalizedEventName;
    super.afterConstruct(...arguments);
  }
  changeMode(value) {
    const {
      dragData,
      copyMode
    } = this;
    if ((copyMode === "event" || copyMode === "auto" || copyMode === "assignment" && !this.scheduler.eventStore.usesSingleAssignment) && (!dragData || dragData.eventRecords.every((r) => !r.isRecurring))) {
      return value;
    }
  }
  updateMode(mode) {
    if (this.dragData) {
      if (mode === "copy") {
        this.setCopying();
      } else {
        this.setMoving();
      }
      this.client.trigger("eventDragModeChange", {
        mode
      });
    }
  }
  setCopying() {
    const {
      dragData
    } = this;
    if (!dragData) {
      return;
    }
    if (!dragData.eventBarCopies.some((el) => el.isConnected)) {
      dragData.eventBarCopies.forEach((el) => {
        el.classList.add("b-drag-proxy-copy");
        el.classList.remove("b-hidden");
        dragData.context.grabbedParent.appendChild(el);
        el.retainElement = true;
      });
    } else {
      dragData.eventBarCopies.forEach((el) => {
        el.classList.remove("b-hidden");
      });
    }
  }
  setMoving() {
    const {
      dragData
    } = this;
    if (!dragData) {
      return;
    }
    dragData.eventBarCopies.forEach((el) => {
      el.classList.add("b-hidden");
    });
  }
  get scheduler() {
    return this.client;
  }
  onAfterDragStart(event) {
    const me = this, {
      context: {
        element
      }
    } = event;
    super.onAfterDragStart(event);
    me.handleKeyDownOrMove(event.event);
    me.keyEventDetacher = EventHelper.on({
      element: DomHelper.getRootElement(element),
      keydown: me.handleKeyDownOrMove,
      keyup: me.handleKeyUp,
      thisObj: me
    });
  }
  onDragReset(event) {
    var _this$keyEventDetache;
    super.onDragReset(event);
    (_this$keyEventDetache = this.keyEventDetacher) === null || _this$keyEventDetache === void 0 ? void 0 : _this$keyEventDetache.call(this);
    this.mode = "move";
  }
  onDrop(event) {
    var _this$dragData$eventB;
    (_this$dragData$eventB = this.dragData.eventBarCopies) === null || _this$dragData$eventB === void 0 ? void 0 : _this$dragData$eventB.forEach((el) => el.remove());
    return super.onDrop(event);
  }
  getDraggableElement(el) {
    return el === null || el === void 0 ? void 0 : el.closest(this.drag.targetSelector);
  }
  resolveEventRecord(eventElement, client = this.client) {
    return client.resolveEventRecord(eventElement);
  }
  isElementDraggable(el, event) {
    var _client;
    const me = this, {
      client
    } = me, eventElement = me.getDraggableElement(el);
    if (!eventElement || me.disabled || client.readOnly) {
      return false;
    }
    if (el.matches('[class$="-handle"]')) {
      return false;
    }
    const eventRecord = me.resolveEventRecord(eventElement, client);
    if (!eventRecord || !eventRecord.isDraggable || eventRecord.readOnly) {
      return false;
    }
    const prevented = ((_client = client[`is${me.capitalizedEventName}ElementDraggable`]) === null || _client === void 0 ? void 0 : _client.call(client, eventElement, eventRecord, el, event)) === false;
    return !prevented;
  }
  getTriggerParams(dragData) {
    const {
      assignmentRecords,
      eventRecords,
      resourceRecord,
      browserEvent: domEvent
    } = dragData;
    return {
      context: dragData,
      eventRecords,
      resourceRecord,
      assignmentRecords,
      event: domEvent,
      domEvent
    };
  }
  triggerBeforeEventDrag(eventType, event) {
    return this.client.trigger(eventType, event);
  }
  triggerEventDrag(dragData, start) {
    this.client.trigger("eventDrag", Object.assign(this.getTriggerParams(dragData), {
      startDate: dragData.startDate,
      endDate: dragData.endDate,
      newResource: dragData.newResource
    }));
  }
  triggerDragStart(dragData) {
    this.client.navigator.skipNextClick = true;
    this.client.trigger("eventDragStart", this.getTriggerParams(dragData));
  }
  triggerDragAbort(dragData) {
    this.client.trigger("eventDragAbort", this.getTriggerParams(dragData));
  }
  triggerDragAbortFinalized(dragData) {
    this.client.trigger("eventDragAbortFinalized", this.getTriggerParams(dragData));
  }
  triggerAfterDrop(dragData, valid) {
    const me = this;
    me.currentOverClient.trigger("afterEventDrop", Object.assign(me.getTriggerParams(dragData), {
      valid
    }));
    if (!valid) {
      const {
        assignmentStore,
        eventStore
      } = me.client, needRefresh = me.dragData.initialAssignmentsState.find(({
        resource,
        assignment
      }, i) => {
        var _me$dragData$assignme;
        return !assignmentStore.includes(assignment) || !eventStore.includes(assignment.event) || resource.id !== ((_me$dragData$assignme = me.dragData.assignmentRecords[i]) === null || _me$dragData$assignme === void 0 ? void 0 : _me$dragData$assignme.resourceId);
      });
      if (needRefresh) {
        me.client.refresh();
      }
    }
    me.client.setTimeout(() => me.client.navigator.skipNextClick = false, 10);
  }
  handleKeyDownOrMove(event) {
    if (this.mode !== "copy") {
      if (event.key && EventHelper.specialKeyFromEventKey(event.key) === this.copyKey.toLowerCase() || event[`${this.copyKey.toLowerCase()}Key`]) {
        this.mode = "copy";
      }
    }
  }
  handleKeyUp(event) {
    if (EventHelper.specialKeyFromEventKey(event.key) === this.copyKey.toLowerCase()) {
      this.mode = "move";
    }
  }
  isValidDrop(dragData) {
    const {
      newResource,
      resourceRecord
    } = dragData, sourceRecord = dragData.draggedEntities[0];
    if (!newResource) {
      return !this.constrainDragToTimeline && this.externalDropTargetSelector ? Boolean(dragData.browserEvent.target.closest(this.externalDropTargetSelector)) : false;
    }
    if (newResource.isSpecialRow || newResource.readOnly) {
      return false;
    }
    if (resourceRecord !== newResource) {
      return !sourceRecord.event.resources.includes(newResource);
    }
    return true;
  }
  checkDragValidity(dragData, event) {
    var _dragData$newResource;
    const me = this, scheduler = me.currentOverClient;
    let result;
    if ((_dragData$newResource = dragData.newResource) !== null && _dragData$newResource !== void 0 && _dragData$newResource.readOnly) {
      return false;
    }
    if (!scheduler.allowOverlap && !scheduler.isDateRangeAvailable(dragData.startDate, dragData.endDate, dragData.draggedEntities[0], dragData.newResource)) {
      result = {
        valid: false,
        message: me.L("L{eventOverlapsExisting}")
      };
    } else {
      result = me.validatorFn.call(me.validatorFnThisObj || me, dragData, event);
    }
    if (!result || result.valid) {
      var _scheduler$checkEvent, _scheduler$checkEvent2;
      result = (_scheduler$checkEvent = (_scheduler$checkEvent2 = scheduler["checkEventDragValidity"]) === null || _scheduler$checkEvent2 === void 0 ? void 0 : _scheduler$checkEvent2.call(scheduler, dragData, event)) !== null && _scheduler$checkEvent !== void 0 ? _scheduler$checkEvent : result;
    }
    return result;
  }
  async updateRecords(context) {
    const me = this, fromScheduler = me.client, toScheduler = me.currentOverClient, copyKeyPressed = me.mode === "copy";
    let result;
    if (!context.externalDropTarget) {
      fromScheduler.eventStore.suspendAutoCommit();
      toScheduler.eventStore.suspendAutoCommit();
      result = await me.updateAssignments(fromScheduler, toScheduler, context, copyKeyPressed);
      fromScheduler.eventStore.resumeAutoCommit();
      toScheduler.eventStore.resumeAutoCommit();
    }
    toScheduler.trigger("eventDrop", Object.assign(me.getTriggerParams(context), {
      isCopy: copyKeyPressed,
      copyMode: me.copyMode,
      domEvent: context.browserEvent,
      targetEventRecord: context.targetEventRecord,
      targetResourceRecord: context.newResource,
      externalDropTarget: context.externalDropTarget
    }));
    return result;
  }
  async updateAssignments(fromScheduler, toScheduler, context, copy) {
    const me = this, {
      copyMode
    } = me, isCrossScheduler = fromScheduler !== toScheduler, {
      isVertical
    } = toScheduler, {
      assignmentStore: fromAssignmentStore,
      eventStore: fromEventStore
    } = fromScheduler, {
      assignmentStore: toAssignmentStore,
      eventStore: toEventStore
    } = toScheduler, fromResourceStore = fromScheduler.isVertical ? fromScheduler.resourceStore : fromScheduler.store, toResourceStore = isVertical ? toScheduler.resourceStore : toScheduler.store, {
      eventRecords,
      assignmentRecords,
      timeDiff,
      initialAssignmentsState,
      resourceRecord: fromResource,
      newResource: toResource
    } = context, {
      unifiedDrag
    } = me, useSingleAssignment = toEventStore.usesSingleAssignment || toEventStore.usesSingleAssignment !== false && fromEventStore.usesSingleAssignment, event1Date = me.adjustStartDate(assignmentRecords[0].event.startDate, timeDiff), eventsToAdd = [], eventsToRemove = [], assignmentsToAdd = [], assignmentsToRemove = [], eventsToCheck = [], eventsToBatch = /* @__PURE__ */ new Set(), resourcesInStore = fromResourceStore.getAllDataRecords();
    fromScheduler.suspendRefresh();
    toScheduler.suspendRefresh();
    let updated = false, updatedEvent = false, indexDiff;
    if (isCrossScheduler) {
      indexDiff = toResourceStore.indexOf(toResource) - fromResourceStore.indexOf(fromResource);
    } else if (me.constainDragToResource) {
      indexDiff = 0;
    } else if (isVertical && toResourceStore.isGrouped) {
      indexDiff = resourcesInStore.indexOf(fromResource) - resourcesInStore.indexOf(toResource);
    } else {
      indexDiff = fromResourceStore.indexOf(fromResource) - fromResourceStore.indexOf(toResource);
    }
    if (isVertical) {
      eventRecords.forEach((draggedEvent, i) => {
        const eventBar = context.eventBarEls[i];
        delete draggedEvent.instanceMeta(fromScheduler).hasTemporaryDragElement;
        if (eventBar.dataset.transient) {
          eventBar.remove();
        }
      });
    }
    const eventBarEls = context.eventBarEls.slice(), addedEvents = [], copiedAssignmentsMap = {};
    for (let i = 0; i < assignmentRecords.length; i++) {
      const originalAssignment = assignmentRecords[i];
      let draggedEvent = originalAssignment.event, draggedAssignment;
      if (copy) {
        draggedAssignment = originalAssignment.copy();
        copiedAssignmentsMap[originalAssignment.id] = draggedAssignment;
      } else {
        draggedAssignment = originalAssignment;
      }
      if (!draggedAssignment.isOccurrenceAssignment && (!fromAssignmentStore.includes(originalAssignment) || !fromEventStore.includes(draggedEvent))) {
        eventBarEls[i].remove();
        eventBarEls.splice(i, 1);
        assignmentRecords.splice(i, 1);
        i--;
        continue;
      }
      const initialState = initialAssignmentsState[i], originalEventRecord = draggedEvent, originalStartDate = initialState.startDate, originalResourceRecord = initialState.resource, newStartDate = this.constrainDragToTimeSlot ? originalStartDate : unifiedDrag ? event1Date : me.adjustStartDate(originalStartDate, timeDiff);
      if (fromAssignmentStore !== toAssignmentStore) {
        const keepEvent = originalEventRecord.assignments.length > 1 || copy;
        let newAssignment;
        if (copy) {
          newAssignment = draggedAssignment;
        } else {
          newAssignment = draggedAssignment.copy();
          copiedAssignmentsMap[draggedAssignment.id] = newAssignment;
        }
        if (newAssignment.event && !useSingleAssignment) {
          newAssignment.event = newAssignment.event.id;
          newAssignment.resource = newAssignment.resource.id;
        }
        if (!copy) {
          assignmentsToRemove.push(draggedAssignment);
        }
        if (!keepEvent) {
          eventsToRemove.push(originalEventRecord);
        }
        if (copy && (copyMode === "event" || copyMode === "auto" && toEventStore.usesSingleAssignment) || !toEventStore.getById(originalEventRecord.id)) {
          draggedEvent = toEventStore.createRecord(_objectSpread2(_objectSpread2({}, originalEventRecord.data), {}, {
            id: copy && (copyMode === "event" || copyMode === "auto") ? void 0 : originalEventRecord.id,
            calendar: null
          }));
          newAssignment.set({
            eventId: draggedEvent.id,
            event: draggedEvent
          });
          eventsToAdd.push(draggedEvent);
        }
        if (!useSingleAssignment) {
          assignmentsToAdd.push(newAssignment);
        }
        draggedAssignment = newAssignment;
      }
      let newResource = toResource, reassignedFrom = null;
      if (!unifiedDrag) {
        if (!isCrossScheduler) {
          if (indexDiff !== 0) {
            var _newResource;
            let newIndex;
            if (isVertical && toResourceStore.isGrouped) {
              newIndex = Math.max(Math.min(resourcesInStore.indexOf(originalResourceRecord) - indexDiff, resourcesInStore.length - 1), 0);
              newResource = resourcesInStore[newIndex];
            } else {
              newIndex = Math.max(Math.min(fromResourceStore.indexOf(originalResourceRecord) - indexDiff, fromResourceStore.count - 1), 0);
              newResource = fromResourceStore.getAt(newIndex);
              if (newResource.isSpecialRow) {
                newResource = fromResourceStore.getNext(newResource, false, true) || fromResourceStore.getPrevious(newResource, false, true);
              }
            }
            newResource = (_newResource = newResource) === null || _newResource === void 0 ? void 0 : _newResource.$original;
          } else {
            newResource = originalResourceRecord;
          }
        } else if (i > 0) {
          const draggedEventResourceIndex = fromResourceStore.indexOf(originalResourceRecord);
          newResource = toResourceStore.getAt(draggedEventResourceIndex + indexDiff) || newResource;
        }
      }
      if (draggedAssignment.resourceId !== newResource.id) {
        reassignedFrom = fromResourceStore.getById(draggedAssignment.resourceId);
        if (copy) {
          if (fromAssignmentStore === toAssignmentStore) {
            draggedAssignment.resource = newResource;
            draggedAssignment.event = toEventStore.getById(draggedAssignment.eventId);
            if (copyMode === "event" || fromEventStore.usesSingleAssignment && copyMode === "auto") {
              draggedEvent = draggedEvent.copy();
              draggedAssignment.event = draggedEvent;
              if (toEventStore.usesSingleAssignment) {
                draggedEvent.resource = newResource;
                draggedEvent.resourceId = newResource.id;
              }
            }
            if (!toAssignmentStore.find((r) => r.eventId === draggedAssignment.eventId && r.resourceId === draggedAssignment.resourceId) && !assignmentsToAdd.find((r) => r.eventId === draggedAssignment.eventId && r.resourceId === draggedAssignment.resourceId)) {
              eventsToAdd.push(draggedEvent);
              assignmentsToAdd.push(draggedAssignment);
            }
          } else {
            draggedAssignment.resource = newResource;
          }
        } else {
          draggedAssignment.resource = newResource;
        }
        draggedEvent.isEvent && eventsToBatch.add(draggedEvent);
        updated = true;
        if (draggedEvent.isOccurrence) {
          draggedEvent.set("newResource", newResource);
        }
        if (isCrossScheduler && useSingleAssignment) {
          draggedEvent.resourceId = newResource.id;
        }
      } else {
        if (copy && (copyMode === "event" || copyMode === "auto" && fromEventStore.usesSingleAssignment) && !eventsToAdd.includes(draggedEvent)) {
          draggedEvent = draggedEvent.copy();
          eventsToAdd.push(draggedEvent);
          draggedAssignment.event = draggedEvent;
          if (toEventStore.usesSingleAssignment) {
            draggedEvent.set({
              resource: newResource,
              resourceId: newResource.id
            });
          }
          assignmentsToAdd.push(draggedAssignment);
        }
      }
      if (!eventsToCheck.find((ev) => ev.draggedEvent === draggedEvent) && !DateHelper.isEqual(draggedEvent.startDate, newStartDate)) {
        while (!draggedEvent.isOccurrence && draggedEvent.isBatchUpdating) {
          draggedEvent.endBatch(true);
        }
        draggedEvent.startDate = newStartDate;
        eventsToCheck.push({
          draggedEvent,
          originalStartDate
        });
        draggedEvent.isEvent && eventsToBatch.add(draggedEvent);
        updatedEvent = true;
      }
      toScheduler.processEventDrop({
        eventRecord: draggedEvent,
        resourceRecord: newResource,
        element: i === 0 ? context.context.element : context.context.relatedElements[i - 1],
        context,
        toScheduler,
        reassignedFrom,
        eventsToAdd,
        addedEvents,
        draggedAssignment
      });
      toScheduler.trigger("processEventDrop", {
        originalAssignment,
        draggedAssignment,
        context,
        copyMode,
        isCopy: copy
      });
    }
    fromAssignmentStore.remove(assignmentsToRemove);
    fromEventStore.remove(eventsToRemove);
    toAssignmentStore.add(assignmentsToAdd);
    if (copy && fromAssignmentStore === toAssignmentStore) {
      const {
        syncIdMap
      } = fromScheduler.foregroundCanvas;
      Object.entries(copiedAssignmentsMap).forEach(([originalId, cloneRecord]) => {
        const element = syncIdMap[originalId];
        delete syncIdMap[originalId];
        syncIdMap[cloneRecord.id] = element;
      });
    }
    eventsToAdd.length && addedEvents.push(...toEventStore.add(eventsToAdd));
    if (!me.constrainDragToTimeline) {
      for (let i = 0; i < assignmentRecords.length; i++) {
        const assignmentRecord = copiedAssignmentsMap[assignmentRecords[i].id] || assignmentRecords[i], originalDraggedEvent = assignmentRecord.event, draggedEvent = (addedEvents === null || addedEvents === void 0 ? void 0 : addedEvents.find((r) => r.id === originalDraggedEvent.id)) || originalDraggedEvent, eventBar = context.eventBarEls[i], element = i === 0 ? context.context.element : context.context.relatedElements[i - 1], inTimeAxis = toScheduler.isInTimeAxis(draggedEvent);
        if (!copy) {
          DomSync.removeChild(eventBar.parentElement, eventBar);
        }
        if (draggedEvent.resource && (isVertical || toScheduler.rowManager.getRowFor(draggedEvent.resource)) && inTimeAxis) {
          if (!draggedEvent.parent || draggedEvent.parent.isRoot) {
            const elRect = Rectangle.from(element, toScheduler.foregroundCanvas, true);
            DomHelper.setTopLeft(element, elRect.y, elRect.x);
            DomSync.addChild(toScheduler.foregroundCanvas, element, draggedEvent.assignments[0].id);
            isCrossScheduler && toScheduler.processCrossSchedulerEventDrop({
              eventRecord: draggedEvent,
              toScheduler
            });
          }
          element.classList.remove("b-sch-event-hover", "b-active", "b-drag-proxy", "b-dragging");
          element.retainElement = false;
        }
      }
    }
    addedEvents === null || addedEvents === void 0 ? void 0 : addedEvents.forEach((added) => eventsToBatch.add(added));
    if (assignmentsToRemove.length || eventsToRemove.length || assignmentsToAdd.length || eventsToAdd.length) {
      updated = true;
    }
    if (updated || updatedEvent) {
      useSingleAssignment && eventsToBatch.forEach((eventRecord) => eventRecord.beginBatch());
      await Promise.all([toScheduler.project !== fromScheduler.project ? toScheduler.project.commitAsync() : null, fromScheduler.project.commitAsync()]);
      useSingleAssignment && eventsToBatch.forEach((eventRecord) => eventRecord.endBatch(false, true));
    }
    if (!updated) {
      updated = eventsToCheck.some(({
        draggedEvent,
        originalStartDate
      }) => !DateHelper.isEqual(draggedEvent.startDate, originalStartDate));
    }
    toScheduler.resumeRefresh();
    fromScheduler.resumeRefresh();
    if (assignmentRecords.length > 0) {
      if (!updated) {
        context.valid = false;
      } else {
        if (toScheduler.fillTicks) {
          eventBarEls.forEach((el) => delete el.lastDomConfig);
        }
        toScheduler.refreshWithTransition();
        if (isCrossScheduler) {
          fromScheduler.refreshWithTransition();
          toScheduler.selectedEvents = addedEvents;
        }
      }
    }
  }
  getProductDragContext(dragData) {
    const me = this, {
      currentOverClient: scheduler
    } = me, target = dragData.browserEvent.target, previousResolvedResource = dragData.newResource || dragData.resourceRecord, previousTargetEventRecord = dragData.targetEventRecord;
    let targetEventRecord = scheduler ? me.resolveEventRecord(target, scheduler) : null, newResource, externalDropTarget;
    if (dragData.eventRecords.includes(targetEventRecord)) {
      targetEventRecord = null;
    }
    if (me.constrainDragToResource) {
      newResource = dragData.resourceRecord;
    } else if (!me.constrainDragToTimeline) {
      newResource = me.resolveResource();
    } else if (scheduler) {
      newResource = me.resolveResource() || dragData.newResource || dragData.resourceRecord;
    }
    const {
      assignmentRecords,
      eventRecords
    } = dragData, isOverNewResource = previousResolvedResource !== newResource;
    let valid = Boolean(newResource && !newResource.isSpecialRow);
    if (!newResource && me.externalDropTargetSelector) {
      externalDropTarget = target.closest(me.externalDropTargetSelector);
      valid = Boolean(externalDropTarget);
    }
    return {
      valid,
      externalDropTarget,
      eventRecords,
      assignmentRecords,
      newResource,
      targetEventRecord,
      dirty: isOverNewResource || targetEventRecord !== previousTargetEventRecord,
      proxyElements: [dragData.context.element, ...dragData.context.relatedElements || []]
    };
  }
  getMinimalDragData(info) {
    const me = this, {
      scheduler
    } = me, element = me.getElementFromContext(info), eventRecord = me.resolveEventRecord(element, scheduler), resourceRecord = scheduler.resolveResourceRecord(element), assignmentRecord = scheduler.resolveAssignmentRecord(element), assignmentRecords = assignmentRecord ? [assignmentRecord] : [];
    if (assignmentRecord && (scheduler.isAssignmentSelected(assignmentRecords[0]) || me.drag.startEvent.ctrlKey)) {
      assignmentRecords.push.apply(assignmentRecords, me.getRelatedRecords(assignmentRecord));
    }
    const eventRecords = [...new Set(assignmentRecords.map((assignment) => assignment.event))];
    return {
      eventRecord,
      resourceRecord,
      assignmentRecord,
      eventRecords,
      assignmentRecords
    };
  }
  setupProductDragData(info) {
    var _dateConstraints;
    const me = this, {
      scheduler
    } = me, element = me.getElementFromContext(info), {
      eventRecord,
      resourceRecord,
      assignmentRecord,
      assignmentRecords
    } = me.getMinimalDragData(info), eventBarEls = [];
    if (me.constrainDragToResource && !resourceRecord) {
      throw new Error("Resource could not be resolved for event: " + eventRecord.id);
    }
    let dateConstraints;
    if (me.constrainDragToTimeline) {
      var _me$getDateConstraint;
      dateConstraints = (_me$getDateConstraint = me.getDateConstraints) === null || _me$getDateConstraint === void 0 ? void 0 : _me$getDateConstraint.call(me, resourceRecord, eventRecord);
      const constrainRectangle = me.constrainRectangle = me.getConstrainingRectangle(dateConstraints, resourceRecord, eventRecord), eventRegion = Rectangle.from(element, scheduler.timeAxisSubGridElement);
      super.setupConstraints(constrainRectangle, eventRegion, scheduler.timeAxisViewModel.snapPixelAmount, Boolean(dateConstraints.start));
    }
    assignmentRecords.forEach((assignment) => {
      let eventBarEl = scheduler.getElementFromAssignmentRecord(assignment, true);
      if (!eventBarEl) {
        eventBarEl = scheduler.currentOrientation.addTemporaryDragElement(assignment.event, assignment.resource);
      }
      eventBarEls.push(eventBarEl);
    });
    return {
      record: assignmentRecord,
      draggedEntities: assignmentRecords,
      dateConstraints: (_dateConstraints = dateConstraints) !== null && _dateConstraints !== void 0 && _dateConstraints.start ? dateConstraints : null,
      eventBarCopies: eventBarEls.map((el) => me.createProxy(el)),
      eventBarEls
    };
  }
  getDateConstraints(resourceRecord, eventRecord) {
    var _scheduler$getDateCon;
    const {
      scheduler
    } = this, externalDateConstraints = (_scheduler$getDateCon = scheduler.getDateConstraints) === null || _scheduler$getDateCon === void 0 ? void 0 : _scheduler$getDateCon.call(scheduler, resourceRecord, eventRecord);
    let minDate, maxDate;
    if (this.constrainDragToTimeSlot) {
      minDate = eventRecord.startDate;
      maxDate = eventRecord.endDate;
    } else if (externalDateConstraints) {
      minDate = externalDateConstraints.start;
      maxDate = externalDateConstraints.end;
    }
    return {
      start: minDate,
      end: maxDate
    };
  }
  getConstrainingRectangle(dateRange, resourceRecord, eventRecord) {
    return this.scheduler.getScheduleRegion(this.constrainDragToResource && resourceRecord, eventRecord, true, dateRange && {
      start: dateRange.start,
      end: dateRange.end
    });
  }
  getDragData(info) {
    const dragData = this.getMinimalDragData(info) || {};
    return _objectSpread2(_objectSpread2(_objectSpread2({}, super.getDragData(info)), dragData), {}, {
      initialAssignmentsState: dragData.assignmentRecords.map((assignment) => ({
        startDate: assignment.event.startDate,
        resource: assignment.resource,
        assignment
      }))
    });
  }
  getRelatedRecords(assignmentRecord) {
    return this.scheduler.selectedAssignments.filter((selectedRecord) => selectedRecord !== assignmentRecord && !selectedRecord.resource.readOnly && selectedRecord.event.isDraggable);
  }
  getCoordinate(eventRecord, element, coord) {
    const scheduler = this.currentOverClient;
    if (scheduler.isHorizontal) {
      let x = coord[0];
      if (scheduler.milestoneLayoutMode !== "default" && eventRecord.isMilestone) {
        switch (scheduler.milestoneAlign) {
          case "center":
            x += element.offsetWidth / 2;
            break;
          case "end":
            x += element.offsetWidth;
            break;
        }
      }
      return x;
    } else {
      let y = coord[1];
      if (scheduler.milestoneLayoutMode !== "default" && eventRecord.isMilestone) {
        switch (scheduler.milestoneAlign) {
          case "center":
            y += element.offsetHeight / 2;
            break;
          case "end":
            y += element.offsetHeight;
            break;
        }
      }
      return y;
    }
  }
  resolveResource() {
    const me = this, client = me.currentOverClient, {
      isHorizontal
    } = client, {
      context,
      browserEvent,
      dragProxy
    } = me.dragData, element = dragProxy || context.element, pageRect = Rectangle.from(element, null, true), y = client.isVertical || me.unifiedDrag ? context.clientY : pageRect.center.y, localRect = Rectangle.from(element, client.timeAxisSubGridElement, true), {
      x: lx,
      y: ly
    } = localRect.center, eventTarget = me.getMouseMoveEventTarget(browserEvent);
    let resource = null;
    if (client.element.contains(eventTarget)) {
      if (isHorizontal) {
        const row = client.rowManager.getRowAt(y);
        resource = row && client.store.getAt(row.dataIndex);
      } else {
        resource = client.resolveResourceRecord(client.timeAxisSubGridElement.querySelector(".b-sch-timeaxis-cell"), [lx, ly]);
      }
    }
    return resource;
  }
  adjustStartDate(startDate, timeDiff) {
    const scheduler = this.currentOverClient;
    return scheduler.timeAxis.roundDate(new Date(startDate - 0 + timeDiff), scheduler.snapRelativeToEventStartDate ? startDate : false);
  }
  getRecordElement(assignmentRecord) {
    return this.client.getElementFromAssignmentRecord(assignmentRecord, true);
  }
  getProxyElement(assignmentRecord) {
    if (this.isDragging) {
      const index = this.dragData.assignmentRecords.indexOf(assignmentRecord);
      if (index >= 0) {
        return this.dragData.proxyElements[index];
      }
    }
    return null;
  }
  getMouseMoveEventTarget(event) {
    return event.target;
  }
};
EventDrag._$name = "EventDrag";
GridFeatureManager.registerFeature(EventDrag, true, "Scheduler");
GridFeatureManager.registerFeature(EventDrag, false, "ResourceHistogram");
var EventDragCreate = class extends DragCreateBase {
  get scheduler() {
    return this.client;
  }
  get store() {
    return this.client.eventStore;
  }
  updateLockLayout(lock) {
    this.dragActiveCls = `b-dragcreating${lock ? " b-dragcreate-lock" : ""}`;
  }
  handleBeforeDragCreate(drag, eventRecord, event) {
    var _scheduler$getDateCon;
    const {
      resourceRecord
    } = drag;
    if (resourceRecord.readOnly) {
      return false;
    }
    const {
      scheduler
    } = this, isWorkingTime = !scheduler.isSchedulerPro || eventRecord.ignoreResourceCalendar || resourceRecord.isWorkingTime(drag.mousedownDate), result = isWorkingTime && scheduler.trigger("beforeDragCreate", {
      resourceRecord,
      date: drag.mousedownDate,
      event
    });
    this.dateConstraints = (_scheduler$getDateCon = scheduler.getDateConstraints) === null || _scheduler$getDateCon === void 0 ? void 0 : _scheduler$getDateCon.call(scheduler, resourceRecord, eventRecord);
    return result;
  }
  dragStart(drag) {
    var _client$onEventCreate;
    const me = this, {
      client
    } = me, {
      eventStore,
      assignmentStore,
      enableEventAnimations
    } = client, {
      resourceRecord
    } = drag, eventRecord = me.createEventRecord(drag), resourceRecords = [resourceRecord];
    eventRecord.set("duration", DateHelper.diff(eventRecord.startDate, eventRecord.endDate, eventRecord.durationUnit, true));
    eventRecord.isCreating = true;
    eventRecord.meta.isDragCreating = true;
    client.features.taskEdit && client.features.taskEdit.doCancel();
    if (me.handleBeforeDragCreate(drag, eventRecord, drag.event) === false) {
      return false;
    }
    let assignmentRecords = [];
    if (resourceRecord) {
      assignmentRecords = assignmentStore.assignEventToResource(eventRecord, resourceRecord);
    }
    if (client.trigger("beforeEventAdd", {
      eventRecord,
      resourceRecords,
      assignmentRecords
    }) === false) {
      assignmentStore.remove(assignmentRecords);
      return false;
    }
    if (me.lockLayout) {
      eventRecord.meta.excludeFromLayout = true;
    }
    (_client$onEventCreate = client.onEventCreated) === null || _client$onEventCreate === void 0 ? void 0 : _client$onEventCreate.call(client, eventRecord);
    client.enableEventAnimations = false;
    eventStore.addAsync(eventRecord).then(() => client.enableEventAnimations = enableEventAnimations);
    client.isCreating = true;
    client.refreshRows();
    client.isCreating = false;
    drag.itemElement = drag.element = client.getElementFromEventRecord(eventRecord);
    if (!DomHelper.isInView(drag.itemElement)) {
      client.scrollable.scrollIntoView(drag.itemElement, {
        animate: true,
        edgeOffset: client.barMargin
      });
    }
    return super.dragStart(drag);
  }
  checkValidity(context, event) {
    const me = this, {
      client
    } = me;
    context.resourceRecord = me.dragging.resourceRecord;
    return (client.allowOverlap || client.isDateRangeAvailable(context.startDate, context.endDate, context.eventRecord, context.resourceRecord)) && me.createValidatorFn.call(me.validatorFnThisObj || me, context, event);
  }
  isRowEmpty(resourceRecord) {
    const events = this.store.getEventsForResource(resourceRecord);
    return !events || !events.length;
  }
  triggerBeforeFinalize(event) {
    this.client.trigger(`beforeDragCreateFinalize`, event);
  }
  createEventRecord(drag) {
    const me = this, {
      client
    } = me, dimension = client.isHorizontal ? "X" : "Y", {
      timeAxis,
      eventStore,
      weekStartDay
    } = client, {
      event,
      mousedownDate
    } = drag, draggingEnd = me.draggingEnd = event[`page${dimension}`] > drag.startEvent[`page${dimension}`], eventConfig = {
      name: eventStore.modelClass.fieldMap.name.defaultValue || me.L("L{Object.newEvent}"),
      startDate: draggingEnd ? DateHelper.floor(mousedownDate, timeAxis.resolution, null, weekStartDay) : mousedownDate,
      endDate: draggingEnd ? mousedownDate : DateHelper.ceil(mousedownDate, timeAxis.resolution, null, weekStartDay)
    };
    if (client.project.isGanttProjectMixin) {
      ObjectHelper.assign(eventConfig, {
        constraintDate: eventConfig.startDate,
        constraintType: "startnoearlierthan"
      });
    }
    return eventStore.createRecord(eventConfig);
  }
  async finalizeDragCreate(context) {
    const {
      meta
    } = context.eventRecord;
    meta.excludeFromLayout = false;
    meta.isDragCreating = false;
    if (!this.client.hasEventEditor) {
      context.eventRecord.isCreating = false;
    }
    return super.finalizeDragCreate(context);
  }
  getTipHtml(...args) {
    const html = super.getTipHtml(...args), {
      element
    } = this.tip;
    element.classList.add("b-sch-dragcreate-tooltip");
    element.classList.toggle("b-too-narrow", this.dragging.context.tooNarrow);
    return html;
  }
  onAborted(context) {
    var _this$store$unassignE, _this$store;
    const {
      eventRecord,
      resourceRecord
    } = context;
    (_this$store$unassignE = (_this$store = this.store).unassignEventFromResource) === null || _this$store$unassignE === void 0 ? void 0 : _this$store$unassignE.call(_this$store, eventRecord, resourceRecord);
    this.store.remove(eventRecord);
  }
};
_defineProperty(EventDragCreate, "$name", "EventDragCreate");
_defineProperty(EventDragCreate, "configurable", {
  validatorFn: () => true,
  lockLayout: false
});
EventDragCreate._$name = "EventDragCreate";
GridFeatureManager.registerFeature(EventDragCreate, true, "Scheduler");
GridFeatureManager.registerFeature(EventDragCreate, false, "ResourceHistogram");
var EventDragSelect = class extends Delayable(InstancePlugin) {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "targetSelector", ".b-sch-timeaxis-cell, .b-timeaxissubgrid");
  }
  construct(client, config) {
    client.multiEventSelect = true;
    super.construct(client, config);
  }
  onElementMouseDown(event) {
    const me = this, {
      client
    } = me, {
      foregroundCanvas
    } = client, {
      target,
      button,
      touches,
      clientX,
      clientY
    } = event, canvasRect = Rectangle.from(foregroundCanvas, true);
    if (touches || button !== 0 || me.disabled || !target.matches(me.targetSelector) || client.trigger("beforeEventDragSelect", {
      event
    }) === false) {
      return;
    }
    me.startX = clientX - canvasRect.x;
    me.startY = clientY - canvasRect.y;
    me.element = DomHelper.createElement({
      tag: "div",
      className: "b-dragselect-rect",
      parent: client.foregroundCanvas,
      retainElement: true,
      style: {
        transform: `translate(${me.startX}px, ${me.startY}px)`
      }
    });
    client.element.classList.add("b-dragselecting");
    client.clearEventSelection();
    me.subGridElementRect = Rectangle.from(client.timeAxisSubGridElement, true);
    client.navigator.disabled = true;
    client.enableScrollingCloseToEdges(client.timeAxisSubGrid);
    me.mouseUpDetacher = EventHelper.on({
      element: document,
      mouseup: "onDocumentMouseUp",
      thisObj: me
    });
  }
  get eventRectangles() {
    const {
      client
    } = this;
    return Array.from(client.element.querySelectorAll(client.eventSelector)).map((el) => ({
      rectangle: Rectangle.from(el, true),
      record: client.resolveAssignmentRecord(el)
    }));
  }
  onElementMouseMove(event) {
    const me = this;
    if (typeof me.startX === "number") {
      const canvasRect = me.rectangle = Rectangle.from(me.client.foregroundCanvas, true), x = Math.min(Math.max(event.clientX - canvasRect.x, 0), canvasRect.width + 1), y = Math.min(Math.max(event.clientY - canvasRect.y, 0), canvasRect.height + 1), rect = new Rectangle(me.startX, me.startY, x - me.startX, y - me.startY);
      DomHelper.setTranslateXY(me.element, rect.x, rect.y);
      me.element.style.width = `${rect.width}px`;
      me.element.style.height = `${rect.height}px`;
      me.updateSelection();
    }
  }
  onDocumentMouseUp(event) {
    var _me$element;
    const me = this, {
      client
    } = me, {
      selectedAssignments,
      navigator: navigator2
    } = client;
    client.disableScrollingCloseToEdges(client.timeAxisSubGrid);
    (_me$element = me.element) === null || _me$element === void 0 ? void 0 : _me$element.remove();
    client.element.classList.remove("b-dragselecting");
    me.startX = me.startY = null;
    navigator2.skipNextClick = client.timeAxisSubGridElement.contains(event.target);
    navigator2.disabled = false;
    if (selectedAssignments.length) {
      var _navigator$activeItem;
      navigator2.skipScrollIntoView = true;
      client.activeAssignment = selectedAssignments[selectedAssignments.length - 1];
      (_navigator$activeItem = navigator2.activeItem) === null || _navigator$activeItem === void 0 ? void 0 : _navigator$activeItem.focus();
      navigator2.skipScrollIntoView = false;
    }
    me.mouseUpDetacher();
  }
  updateSelection() {
    const me = this, selectionRect = me.rectangle = Rectangle.from(me.element, true), {
      eventRectangles,
      client
    } = me, selection = client.selectedAssignments.reduce((r, a) => {
      if (!client.getElementFromAssignmentRecord(a)) {
        r.push(a);
      }
      return r;
    }, []);
    for (const assignmentData of eventRectangles) {
      const shouldSelect = selectionRect.intersect(assignmentData.rectangle, true);
      if (shouldSelect && !assignmentData.selected) {
        assignmentData.selected = true;
        selection.push(assignmentData.record);
      }
    }
    client.selectedAssignments = selection;
  }
};
_defineProperty(EventDragSelect, "$name", "EventDragSelect");
_defineProperty(EventDragSelect, "pluginConfig", {
  chain: ["onElementMouseDown", "onElementMouseMove"]
});
EventDragSelect._$name = "EventDragSelect";
GridFeatureManager.registerFeature(EventDragSelect, false, "Scheduler");
var EventEditor$1 = class extends Popup {
  static get type() {
    return "eventeditor";
  }
  static get $name() {
    return "EventEditor";
  }
  static get configurable() {
    return {
      items: [],
      draggable: {
        handleSelector: ":not(button,.b-field-inner)"
      },
      axisLock: "flexible",
      scrollable: {
        overflowY: true
      },
      readOnly: null,
      titleRenderer: null
    };
  }
  updateLocalization() {
    super.updateLocalization(...arguments);
    this.initialTitle = this.title || "";
  }
  chainResourceStore() {
    return this.eventEditFeature.resourceStore.chain((record) => !record.isSpecialRow, null, {
      storeClass: Store,
      excludeCollapsedRecords: false
    });
  }
  processWidgetConfig(widget) {
    var _widget$type;
    if ((_widget$type = widget.type) !== null && _widget$type !== void 0 && _widget$type.includes("date") && widget.weekStartDay == null) {
      widget.weekStartDay = this.weekStartDay;
    }
    if (widget.type === "extraItems") {
      return false;
    }
    const {
      eventEditFeature
    } = this, fieldConfig = {};
    if (widget.ref === "resourceField") {
      const {
        store
      } = widget;
      widget.store = this.chainResourceStore();
      if (store) {
        widget.store.setConfig(store);
      }
      if (!("multiSelect" in widget)) {
        widget.multiSelect = !eventEditFeature.eventStore.usesSingleAssignment;
      }
    }
    if ((widget.name === "startDate" || widget.name === "endDate") && widget.type === "date") {
      fieldConfig.format = eventEditFeature.dateFormat;
    }
    if ((widget.name === "startDate" || widget.name === "endDate") && widget.type === "time") {
      fieldConfig.format = eventEditFeature.timeFormat;
    }
    Object.assign(widget, fieldConfig);
    return super.processWidgetConfig(widget);
  }
  onBeforeShow(...args) {
    var _super$onBeforeShow;
    const me = this, {
      record,
      titleRenderer
    } = me, {
      deleteButton
    } = me.widgetMap;
    if (deleteButton) {
      deleteButton.hidden = me.readOnly || record.isCreating;
    }
    if (titleRenderer) {
      me.title = me.callback(titleRenderer, me, [record]);
    } else {
      me.title = me.initialTitle;
    }
    (_super$onBeforeShow = super.onBeforeShow) === null || _super$onBeforeShow === void 0 ? void 0 : _super$onBeforeShow.call(this, ...args);
  }
  onInternalKeyDown(event) {
    this.trigger("keyDown", {
      event
    });
    super.onInternalKeyDown(event);
  }
  updateReadOnly(readOnly) {
    const {
      deleteButton,
      saveButton,
      cancelButton
    } = this.widgetMap;
    super.updateReadOnly(readOnly);
    if (deleteButton) {
      deleteButton.hidden = readOnly;
    }
    if (saveButton) {
      saveButton.hidden = readOnly;
    }
    if (cancelButton) {
      cancelButton.hidden = readOnly;
    }
  }
};
EventEditor$1.initClass();
EventEditor$1._$name = "EventEditor";
var RecurrenceConfirmationPopup = class extends Popup {
  static get $name() {
    return "RecurrenceConfirmationPopup";
  }
  static get type() {
    return "recurrenceconfirmation";
  }
  static get defaultConfig() {
    return {
      localizableProperties: [],
      align: "b-t",
      autoShow: false,
      autoClose: false,
      closeAction: "onRecurrenceClose",
      modal: true,
      centered: true,
      scrollAction: "realign",
      constrainTo: globalThis,
      draggable: true,
      closable: true,
      floating: true,
      eventRecord: null,
      cls: "b-sch-recurrenceconfirmation",
      bbar: {
        defaults: {
          localeClass: this
        },
        items: {
          changeSingleButton: {
            weight: 100,
            cls: "b-raised",
            color: "b-blue",
            text: "L{update-only-this-btn-text}",
            onClick: "up.onChangeSingleButtonClick"
          },
          changeMultipleButton: {
            weight: 200,
            color: "b-green",
            text: "L{Object.Yes}",
            onClick: "up.onChangeMultipleButtonClick"
          },
          cancelButton: {
            weight: 300,
            color: "b-gray",
            text: "L{Object.Cancel}",
            onClick: "up.onCancelButtonClick"
          }
        }
      }
    };
  }
  get changeMultipleButton() {
    return this.widgetMap.changeMultipleButton;
  }
  get changeSingleButton() {
    return this.widgetMap.changeSingleButton;
  }
  get cancelButton() {
    return this.widgetMap.cancelButton;
  }
  onChangeMultipleButtonClick() {
    this.processMultipleRecords();
    this.hide();
  }
  onChangeSingleButtonClick() {
    this.processSingleRecord();
    this.hide();
  }
  onCancelButtonClick() {
    this.cancelFn && this.cancelFn.call(this.thisObj);
    this.hide();
  }
  onRecurrenceClose() {
    if (this.cancelFn) {
      this.cancelFn.call(this.thisObj);
    }
    this.hide();
  }
  confirm(config = {}) {
    const me = this;
    ["actionType", "eventRecord", "title", "html", "changerFn", "cancelFn", "finalizerFn", "thisObj"].forEach((prop) => {
      if (prop in config)
        me[prop] = config[prop];
    });
    me.updatePopupContent();
    return super.show(config);
  }
  updatePopupContent() {
    const me = this, {
      changeMultipleButton,
      changeSingleButton,
      cancelButton
    } = me.widgetMap, {
      eventRecord,
      actionType = "update"
    } = me, isMaster = eventRecord === null || eventRecord === void 0 ? void 0 : eventRecord.isRecurring;
    if (isMaster) {
      changeMultipleButton.text = me.L("L{Object.Yes}");
      me.html = me.L(`${actionType}-all-message`);
    } else {
      changeMultipleButton.text = me.L(`${actionType}-further-btn-text`);
      me.html = me.L(`${actionType}-further-message`);
    }
    changeSingleButton.text = me.L(`${actionType}-only-this-btn-text`);
    cancelButton.text = me.L("L{Object.Cancel}");
    me.width = me.L("L{width}");
    me.title = me.L(`${actionType}-title`);
  }
  processMultipleRecords() {
    const {
      eventRecord,
      changerFn,
      thisObj,
      finalizerFn
    } = this;
    eventRecord.beginBatch();
    changerFn && this.callback(changerFn, thisObj, [eventRecord]);
    eventRecord.endBatch();
    finalizerFn && this.callback(finalizerFn, thisObj, [eventRecord]);
  }
  processSingleRecord() {
    var _firstOccurrence;
    const {
      eventRecord,
      changerFn,
      thisObj,
      finalizerFn
    } = this;
    eventRecord.beginBatch();
    let firstOccurrence;
    if (eventRecord !== null && eventRecord !== void 0 && eventRecord.isRecurring) {
      eventRecord.recurrence.forEachOccurrence(eventRecord.startDate, null, (occurrence, isFirst, index) => {
        if (index > 1) {
          firstOccurrence = occurrence;
          return false;
        }
      });
    }
    (_firstOccurrence = firstOccurrence) === null || _firstOccurrence === void 0 ? void 0 : _firstOccurrence.convertToRealEvent();
    eventRecord.recurrence = null;
    changerFn && this.callback(changerFn, thisObj, [eventRecord]);
    eventRecord.recurrenceRule = null;
    eventRecord.endBatch();
    finalizerFn && this.callback(finalizerFn, thisObj, [eventRecord]);
  }
  updateLocalization() {
    this.updatePopupContent();
    super.updateLocalization();
  }
};
RecurrenceConfirmationPopup.initClass();
RecurrenceConfirmationPopup._$name = "RecurrenceConfirmationPopup";
var RecurrenceFrequencyCombo = class extends Combo {
  buildItems() {
    return [...this.addNone ? [{
      text: "L{None}",
      value: "NONE"
    }] : [], {
      value: "DAILY",
      text: "L{Daily}"
    }, {
      value: "WEEKLY",
      text: "L{Weekly}"
    }, {
      value: "MONTHLY",
      text: "L{Monthly}"
    }, {
      value: "YEARLY",
      text: "L{Yearly}"
    }];
  }
};
_defineProperty(RecurrenceFrequencyCombo, "$name", "RecurrenceFrequencyCombo");
_defineProperty(RecurrenceFrequencyCombo, "type", "recurrencefrequencycombo");
_defineProperty(RecurrenceFrequencyCombo, "configurable", {
  editable: false,
  displayField: "text",
  valueField: "value",
  localizeDisplayFields: true,
  addNone: false
});
RecurrenceFrequencyCombo.initClass();
RecurrenceFrequencyCombo._$name = "RecurrenceFrequencyCombo";
var RecurrenceCombo = class extends RecurrenceFrequencyCombo {
  static get $name() {
    return "RecurrenceCombo";
  }
  static get type() {
    return "recurrencecombo";
  }
  static get defaultConfig() {
    return {
      customValue: "custom",
      placeholder: "None",
      splitCls: "b-recurrencecombo-split",
      items: true,
      highlightExternalChange: false
    };
  }
  buildItems() {
    const me = this;
    return [{
      value: "none",
      text: "L{None}"
    }, ...super.buildItems(), {
      value: me.customValue,
      text: "L{Custom}",
      cls: me.splitCls
    }];
  }
  set value(value) {
    value = value || "none";
    super.value = value;
  }
  get value() {
    return super.value;
  }
  set recurrence(recurrence) {
    const me = this;
    if (recurrence) {
      me.value = me.isCustomRecurrence(recurrence) ? me.customValue : recurrence.frequency;
    } else {
      me.value = null;
    }
  }
  isCustomRecurrence(recurrence) {
    const {
      interval,
      days: days2,
      monthDays,
      months
    } = recurrence;
    return Boolean(interval > 1 || days2 && days2.length || monthDays && monthDays.length || months && months.length);
  }
};
RecurrenceCombo.initClass();
RecurrenceCombo._$name = "RecurrenceCombo";
var RecurrenceLegendButton = class extends Button {
  static get $name() {
    return "RecurrenceLegendButton";
  }
  static get type() {
    return "recurrencelegendbutton";
  }
  static get defaultConfig() {
    return {
      localizableProperties: [],
      recurrence: null
    };
  }
  set recurrence(recurrence) {
    this._recurrence = recurrence;
    this.updateLegend();
  }
  get recurrence() {
    return this._recurrence;
  }
  set eventStartDate(eventStartDate) {
    this._eventStartDate = eventStartDate;
    this.updateLegend();
  }
  get eventStartDate() {
    return this._eventStartDate;
  }
  updateLegend() {
    const {
      recurrence
    } = this;
    this.text = recurrence ? RecurrenceLegend.getLegend(recurrence, this.eventStartDate) : "";
  }
  onLocaleChange() {
    this.updateLegend();
  }
  updateLocalization() {
    this.onLocaleChange();
    super.updateLocalization();
  }
};
RecurrenceLegendButton.initClass();
RecurrenceLegendButton._$name = "RecurrenceLegendButton";
var RecurrenceDaysCombo = class extends Combo {
  static get $name() {
    return "RecurrenceDaysCombo";
  }
  static get type() {
    return "recurrencedayscombo";
  }
  static get defaultConfig() {
    const allDaysValueAsArray = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"], allDaysValue = allDaysValueAsArray.join(",");
    return {
      allDaysValue,
      editable: false,
      defaultValue: allDaysValue,
      workingDaysValue: allDaysValueAsArray.filter((day2, index) => !DateHelper.nonWorkingDays[index]).join(","),
      nonWorkingDaysValue: allDaysValueAsArray.filter((day2, index) => DateHelper.nonWorkingDays[index]).join(","),
      splitCls: "b-recurrencedays-split",
      displayField: "text",
      valueField: "value"
    };
  }
  buildItems() {
    const me = this;
    me._weekDays = null;
    return me.weekDays.concat([{
      value: me.allDaysValue,
      text: me.L("L{day}"),
      cls: me.splitCls
    }, {
      value: me.workingDaysValue,
      text: me.L("L{weekday}")
    }, {
      value: me.nonWorkingDaysValue,
      text: me.L("L{weekend day}")
    }]);
  }
  get weekDays() {
    const me = this;
    if (!me._weekDays) {
      const weekStartDay = DateHelper.weekStartDay;
      const dayNames = DateHelper.getDayNames().map((text, index) => ({
        text,
        value: RecurrenceDayRuleEncoder.encodeDay(index)
      }));
      me._weekDays = dayNames.slice(weekStartDay).concat(dayNames.slice(0, weekStartDay));
    }
    return me._weekDays;
  }
  set value(value) {
    const me = this;
    if (value && Array.isArray(value)) {
      value = value.join(",");
    }
    if (!value || !me.store.findRecord("value", value)) {
      value = me.defaultValue;
    }
    super.value = value;
  }
  get value() {
    let value = super.value;
    if (value && Array.isArray(value)) {
      value = value.join(",");
    }
    return value;
  }
};
RecurrenceDaysCombo.initClass();
RecurrenceDaysCombo._$name = "RecurrenceDaysCombo";
var RecurrenceDaysButtonGroup = class extends ButtonGroup {
  static get $name() {
    return "RecurrenceDaysButtonGroup";
  }
  static get type() {
    return "recurrencedaysbuttongroup";
  }
  static get defaultConfig() {
    return {
      defaults: {
        cls: "b-raised",
        toggleable: true
      }
    };
  }
  construct(config = {}) {
    const me = this;
    config.columns = 7;
    config.items = me.buildItems();
    super.construct(config);
  }
  updateItemText(item) {
    const day2 = RecurrenceDayRuleEncoder.decodeDay(item.value)[0];
    item.text = DateHelper.getDayName(day2).substring(0, 3);
  }
  buildItems() {
    const me = this;
    if (!me.__items) {
      const weekStartDay = DateHelper.weekStartDay;
      const dayNames = DateHelper.getDayNames().map((text, index) => ({
        text: text.substring(0, 3),
        value: RecurrenceDayRuleEncoder.encodeDay(index)
      }));
      me.__items = dayNames.slice(weekStartDay).concat(dayNames.slice(0, weekStartDay));
    }
    return me.__items;
  }
  set value(value) {
    if (value && Array.isArray(value)) {
      value = value.join(",");
    }
    super.value = value;
  }
  get value() {
    let value = super.value;
    if (value && Array.isArray(value)) {
      value = value.join(",");
    }
    return value;
  }
  onLocaleChange() {
    this.items.forEach(this.updateItemText, this);
  }
  updateLocalization() {
    this.onLocaleChange();
    super.updateLocalization();
  }
  get widgetClassList() {
    const classList = super.widgetClassList;
    classList.push("b-field");
    return classList;
  }
};
RecurrenceDaysButtonGroup.initClass();
RecurrenceDaysButtonGroup._$name = "RecurrenceDaysButtonGroup";
var RecurrenceMonthDaysButtonGroup = class extends ButtonGroup {
  static get $name() {
    return "RecurrenceMonthDaysButtonGroup";
  }
  static get type() {
    return "recurrencemonthdaysbuttongroup";
  }
  static get defaultConfig() {
    return {
      defaults: {
        toggleable: true,
        cls: "b-raised"
      }
    };
  }
  get minValue() {
    return 1;
  }
  get maxValue() {
    return 31;
  }
  construct(config = {}) {
    const me = this;
    config.columns = 7;
    config.items = me.buildItems();
    super.construct(config);
  }
  buildItems() {
    const me = this, items2 = [];
    for (let value = me.minValue; value <= me.maxValue; value++) {
      items2.push({
        text: value + "",
        value
      });
    }
    return items2;
  }
  get widgetClassList() {
    const classList = super.widgetClassList;
    classList.push("b-field");
    return classList;
  }
};
RecurrenceMonthDaysButtonGroup.initClass();
RecurrenceMonthDaysButtonGroup._$name = "RecurrenceMonthDaysButtonGroup";
var RecurrenceMonthsButtonGroup = class extends ButtonGroup {
  static get $name() {
    return "RecurrenceMonthsButtonGroup";
  }
  static get type() {
    return "recurrencemonthsbuttongroup";
  }
  static get defaultConfig() {
    return {
      defaults: {
        toggleable: true,
        cls: "b-raised"
      }
    };
  }
  construct(config = {}) {
    const me = this;
    config.columns = 4;
    config.items = me.buildItems();
    super.construct(config);
  }
  buildItems() {
    return DateHelper.getMonthNames().map((item, index) => ({
      text: item.substring(0, 3),
      value: index + 1
    }));
  }
  updateItemText(item) {
    item.text = DateHelper.getMonthName(item.value - 1).substring(0, 3);
  }
  onLocaleChange() {
    this.items.forEach(this.updateItemText, this);
  }
  updateLocalization() {
    this.onLocaleChange();
    super.updateLocalization();
  }
  get widgetClassList() {
    const classList = super.widgetClassList;
    classList.push("b-field");
    return classList;
  }
};
RecurrenceMonthsButtonGroup.initClass();
RecurrenceMonthsButtonGroup._$name = "RecurrenceMonthsButtonGroup";
var RecurrenceStopConditionCombo = class extends Combo {
  static get $name() {
    return "RecurrenceStopConditionCombo";
  }
  static get type() {
    return "recurrencestopconditioncombo";
  }
  static get defaultConfig() {
    return {
      editable: false,
      placeholder: "Never",
      displayField: "text",
      valueField: "value"
    };
  }
  buildItems() {
    return [{
      value: "never",
      text: this.L("L{Never}")
    }, {
      value: "count",
      text: this.L("L{After}")
    }, {
      value: "date",
      text: this.L("L{On date}")
    }];
  }
  set value(value) {
    value = value || "never";
    super.value = value;
  }
  get value() {
    return super.value;
  }
  get recurrence() {
    return this._recurrence;
  }
  set recurrence(recurrence) {
    let value = null;
    if (recurrence.endDate) {
      value = "date";
    } else if (recurrence.count) {
      value = "count";
    }
    this._recurrence = recurrence;
    this.value = value;
  }
};
RecurrenceStopConditionCombo.initClass();
RecurrenceStopConditionCombo._$name = "RecurrenceStopConditionCombo";
var RecurrencePositionsCombo = class extends Combo {
  static get $name() {
    return "RecurrencePositionsCombo";
  }
  static get type() {
    return "recurrencepositionscombo";
  }
  static get defaultConfig() {
    return {
      editable: false,
      splitCls: "b-sch-recurrencepositions-split",
      displayField: "text",
      valueField: "value",
      defaultValue: 1,
      maxPosition: 5
    };
  }
  buildItems() {
    const me = this;
    return me.buildDayNumbers().concat([
      {
        value: "-1",
        text: me.L("L{position-1}"),
        cls: me.splitCls
      }
    ]);
  }
  buildDayNumbers() {
    const me = this;
    return ArrayHelper.populate(me.maxPosition, (i) => ({
      value: i + 1,
      text: me.L(`position${i + 1}`)
    }));
  }
  set value(value) {
    const me = this;
    if (value && Array.isArray(value)) {
      value = value.join(",");
    }
    if (!value || !me.store.findRecord("value", value)) {
      value = me.defaultValue;
    }
    super.value = value;
  }
  get value() {
    const value = super.value;
    return value ? `${value}`.split(",").map((item) => parseInt(item, 10)) : [];
  }
};
RecurrencePositionsCombo.initClass();
RecurrencePositionsCombo._$name = "RecurrencePositionsCombo";
var RecurrenceEditorPanel = class extends Panel {
  updateRecord(record) {
    super.updateRecord(record);
    const me = this, {
      frequencyField,
      daysButtonField,
      monthDaysButtonField,
      monthsButtonField,
      monthDaysRadioField,
      positionAndDayRadioField,
      stopRecurrenceField
    } = me.widgetMap;
    if (record) {
      const event = record.timeSpan, startDate = event === null || event === void 0 ? void 0 : event.startDate;
      if (startDate) {
        if (!record.days || !record.days.length) {
          daysButtonField.value = [RecurrenceDayRuleEncoder.encodeDay(startDate.getDay())];
        }
        if (!record.monthDays || !record.monthDays.length) {
          monthDaysButtonField.value = startDate.getDate();
        }
        if (!record.months || !record.months.length) {
          monthsButtonField.value = startDate.getMonth() + 1;
        }
      }
      if (record.days && record.positions) {
        positionAndDayRadioField.check();
        if (!me.isPainted) {
          monthDaysRadioField.uncheck();
        }
      } else {
        monthDaysRadioField.check();
        if (!me.isPainted) {
          positionAndDayRadioField.uncheck();
        }
      }
      stopRecurrenceField.recurrence = record;
    } else {
      frequencyField.value = "NONE";
    }
  }
  syncEventRecord(recurrence) {
    const values = this.getValues((w) => w.name in recurrence && !w.disabled);
    if (!("endDate" in values)) {
      values.endDate = null;
    }
    if (!("count" in values)) {
      values.count = null;
    }
    recurrence.set(values);
  }
  toggleStopFields() {
    const me = this, {
      countField,
      endDateField
    } = me.widgetMap;
    switch (me.widgetMap.stopRecurrenceField.value) {
      case "count":
        countField.show();
        countField.enable();
        endDateField.hide();
        endDateField.disable();
        break;
      case "date":
        countField.hide();
        countField.disable();
        endDateField.show();
        endDateField.enable();
        break;
      default:
        countField.hide();
        endDateField.hide();
        countField.disable();
        endDateField.disable();
    }
  }
  onMonthDaysRadioFieldChange({
    checked
  }) {
    const {
      monthDaysButtonField
    } = this.widgetMap;
    monthDaysButtonField.disabled = !checked || !this.isWidgetAvailableForFrequency(monthDaysButtonField);
  }
  onPositionAndDayRadioFieldChange({
    checked
  }) {
    const {
      daysCombo,
      positionsCombo
    } = this.widgetMap;
    daysCombo.disabled = positionsCombo.disabled = !checked || !this.isWidgetAvailableForFrequency(daysCombo);
  }
  onStopRecurrenceFieldChange() {
    this.toggleStopFields();
  }
  isWidgetAvailableForFrequency(widget, frequency = this.widgetMap.frequencyField.value) {
    return !widget.forFrequency || widget.forFrequency.includes(frequency);
  }
  onFrequencyFieldChange({
    value,
    oldValue,
    valid
  }) {
    const me = this, items2 = me.queryAll((w) => "forFrequency" in w), {
      intervalField,
      stopRecurrenceField
    } = me.widgetMap;
    if (valid && value) {
      for (let i = 0; i < items2.length; i++) {
        const item = items2[i];
        if (me.isWidgetAvailableForFrequency(item, value)) {
          item.show();
          item.enable();
        } else {
          item.hide();
          item.disable();
        }
      }
      intervalField.hidden = stopRecurrenceField.hidden = value === "NONE";
      if (value !== "NONE") {
        intervalField.hint = me.L(`L{RecurrenceEditor.${value}intervalUnit}`);
      }
      if (oldValue === "NONE" && intervalField.value == null) {
        intervalField.value = 1;
      }
      me.toggleFieldsState();
    }
  }
  toggleFieldsState() {
    const me = this, {
      widgetMap
    } = me;
    me.onMonthDaysRadioFieldChange({
      checked: widgetMap.monthDaysRadioField.checked
    });
    me.onPositionAndDayRadioFieldChange({
      checked: widgetMap.positionAndDayRadioField.checked
    });
    me.onStopRecurrenceFieldChange();
  }
  updateLocalization() {
    const {
      countField,
      intervalField,
      frequencyField
    } = this.widgetMap;
    countField.hint = this.L("L{RecurrenceEditor.time(s)}");
    if (frequencyField.value && frequencyField.value !== "NONE") {
      intervalField.hint = this.L(`L{RecurrenceEditor.${frequencyField.value}intervalUnit}`);
    }
    super.updateLocalization();
  }
};
_defineProperty(RecurrenceEditorPanel, "$name", "RecurrenceEditorPanel");
_defineProperty(RecurrenceEditorPanel, "type", "recurrenceeditorpanel");
_defineProperty(RecurrenceEditorPanel, "configurable", {
  cls: "b-recurrenceeditor",
  record: false,
  addNone: false,
  items: {
    frequencyField: {
      type: "recurrencefrequencycombo",
      name: "frequency",
      label: "L{RecurrenceEditor.Frequency}",
      weight: 10,
      onChange: "up.onFrequencyFieldChange",
      addNone: "up.addNone"
    },
    intervalField: {
      type: "numberfield",
      weight: 15,
      name: "interval",
      label: "L{RecurrenceEditor.Every}",
      min: 1,
      required: true
    },
    daysButtonField: {
      type: "recurrencedaysbuttongroup",
      weight: 20,
      name: "days",
      forFrequency: "WEEKLY"
    },
    monthDaysRadioField: {
      type: "checkbox",
      weight: 30,
      toggleGroup: "radio",
      forFrequency: "MONTHLY",
      label: "L{RecurrenceEditor.Each}",
      checked: true,
      onChange: "up.onMonthDaysRadioFieldChange"
    },
    monthDaysButtonField: {
      type: "recurrencemonthdaysbuttongroup",
      weight: 40,
      name: "monthDays",
      forFrequency: "MONTHLY"
    },
    monthsButtonField: {
      type: "recurrencemonthsbuttongroup",
      weight: 50,
      name: "months",
      forFrequency: "YEARLY"
    },
    positionAndDayRadioField: {
      type: "checkbox",
      weight: 60,
      toggleGroup: "radio",
      forFrequency: "MONTHLY|YEARLY",
      label: "L{RecurrenceEditor.On the}",
      onChange: "up.onPositionAndDayRadioFieldChange"
    },
    positionsCombo: {
      type: "recurrencepositionscombo",
      weight: 80,
      name: "positions",
      forFrequency: "MONTHLY|YEARLY"
    },
    daysCombo: {
      type: "recurrencedayscombo",
      weight: 90,
      name: "days",
      forFrequency: "MONTHLY|YEARLY",
      flex: 1
    },
    stopRecurrenceField: {
      type: "recurrencestopconditioncombo",
      weight: 100,
      label: "L{RecurrenceEditor.End repeat}",
      onChange: "up.onStopRecurrenceFieldChange"
    },
    countField: {
      type: "numberfield",
      weight: 110,
      name: "count",
      min: 2,
      required: true,
      disabled: true,
      label: " "
    },
    endDateField: {
      type: "datefield",
      weight: 120,
      name: "endDate",
      hidden: true,
      disabled: true,
      label: " ",
      required: true
    }
  }
});
RecurrenceEditorPanel.initClass();
RecurrenceEditorPanel._$name = "RecurrenceEditorPanel";
var RecurrenceEditor = class extends Popup {
  static get $name() {
    return "RecurrenceEditor";
  }
  static get type() {
    return "recurrenceeditor";
  }
  static get configurable() {
    return {
      draggable: true,
      closable: true,
      floating: true,
      cls: "b-recurrenceeditor",
      title: "L{Repeat event}",
      autoClose: true,
      width: 470,
      items: {
        recurrenceEditorPanel: {
          type: "recurrenceeditorpanel",
          title: null
        }
      },
      bbar: {
        defaults: {
          localeClass: this
        },
        items: {
          foo: {
            type: "widget",
            cls: "b-label-filler",
            weight: 100
          },
          saveButton: {
            color: "b-green",
            text: "L{Save}",
            onClick: "up.onSaveClick",
            weight: 200
          },
          cancelButton: {
            color: "b-gray",
            text: "L{Object.Cancel}",
            onClick: "up.onCancelClick",
            weight: 300
          }
        }
      }
    };
  }
  updateReadOnly(readOnly) {
    super.updateReadOnly(readOnly);
    this.bbar.hidden = readOnly;
  }
  get recurrenceEditorPanel() {
    return this.widgetMap.recurrenceEditorPanel;
  }
  updateRecord(record) {
    this.recurrenceEditorPanel.record = record;
  }
  onSaveClick() {
    const me = this;
    if (me.saveHandler) {
      me.saveHandler.call(me.thisObj || me, me, me.record);
    } else {
      me.recurrenceEditorPanel.syncEventRecord();
      me.close();
    }
  }
  onCancelClick() {
    const me = this;
    if (me.cancelHandler) {
      me.cancelHandler.call(me.thisObj || me, me, me.record);
    } else {
      me.close();
    }
  }
};
RecurrenceEditor.initClass();
RecurrenceEditor._$name = "RecurrenceEditor";
var RecurringEventEdit = (Target) => class RecurringEventEdit extends (Target || Base$1) {
  static get $name() {
    return "RecurringEventEdit";
  }
  static get configurable() {
    return {
      recurringEventsItems: {
        recurrenceCombo: {
          type: "recurrencecombo",
          label: "L{EventEdit.Repeat}",
          ref: "recurrenceCombo",
          weight: 700
        },
        editRecurrenceButton: {
          type: "recurrencelegendbutton",
          ref: "editRecurrenceButton",
          name: "recurrenceRule",
          color: "b-gray",
          menuIcon: null,
          flex: 1,
          weight: 800,
          ignoreParentReadOnly: true
        }
      },
      showRecurringUI: null
    };
  }
  changeEditorConfig(editorConfig) {
    editorConfig.items = _objectSpread2(_objectSpread2({}, editorConfig.items), this.recurringEventsItems);
    editorConfig = super.changeEditorConfig(editorConfig);
    return editorConfig;
  }
  construct(scheduler, config) {
    super.construct(scheduler, config);
    this.scheduler.ion({
      beforeEventSave: "onRecurrableEventBeforeSave",
      thisObj: this
    });
  }
  doDestroy() {
    var _this$_recurrenceConf, _this$_recurrenceEdit;
    (_this$_recurrenceConf = this._recurrenceConfirmation) === null || _this$_recurrenceConf === void 0 ? void 0 : _this$_recurrenceConf.destroy();
    (_this$_recurrenceEdit = this._recurrenceEditor) === null || _this$_recurrenceEdit === void 0 ? void 0 : _this$_recurrenceEdit.destroy();
    super.doDestroy();
  }
  onEditorConstructed(editor) {
    var _me$recurrenceCombo;
    const me = this;
    editor.ion({
      hide: me.onRecurringEventEditorHide,
      thisObj: me
    });
    if (me.editRecurrenceButton) {
      me.editRecurrenceButton.menu = me.recurrenceEditor;
    }
    (_me$recurrenceCombo = me.recurrenceCombo) === null || _me$recurrenceCombo === void 0 ? void 0 : _me$recurrenceCombo.ion({
      change: me.onRecurrenceComboChange,
      thisObj: me
    });
  }
  updateReadOnly(readOnly) {
    if (this._recurrenceEditor) {
      this._recurrenceEditor.readOnly = readOnly;
    }
  }
  internalShowEditor() {
    this.toggleRecurringFieldsVisibility(this.client.enableRecurringEvents && this.showRecurringUI !== false);
  }
  toggleRecurringFieldsVisibility(show = true) {
    var _this$editRecurrenceB, _this$editRecurrenceB2, _this$recurrenceCombo, _this$recurrenceCombo2;
    const methodName = show ? "show" : "hide";
    (_this$editRecurrenceB = this.editRecurrenceButton) === null || _this$editRecurrenceB === void 0 ? void 0 : (_this$editRecurrenceB2 = _this$editRecurrenceB[methodName]) === null || _this$editRecurrenceB2 === void 0 ? void 0 : _this$editRecurrenceB2.call(_this$editRecurrenceB);
    (_this$recurrenceCombo = this.recurrenceCombo) === null || _this$recurrenceCombo === void 0 ? void 0 : (_this$recurrenceCombo2 = _this$recurrenceCombo[methodName]) === null || _this$recurrenceCombo2 === void 0 ? void 0 : _this$recurrenceCombo2.call(_this$recurrenceCombo);
  }
  onRecurringEventEditorHide() {
    var _this$recurrenceEdito, _this$recurrenceConfi;
    if ((_this$recurrenceEdito = this.recurrenceEditor) !== null && _this$recurrenceEdito !== void 0 && _this$recurrenceEdito.isVisible) {
      this.recurrenceEditor.hide();
    }
    if ((_this$recurrenceConfi = this.recurrenceConfirmation) !== null && _this$recurrenceConfi !== void 0 && _this$recurrenceConfi.isVisible) {
      this.recurrenceConfirmation.hide();
    }
  }
  makeRecurrence(rule) {
    const event = this.eventRecord, eventCopy = event.copy();
    let recurrence = event.recurrence;
    if (!rule && recurrence) {
      recurrence = recurrence.copy();
    } else {
      recurrence = new event.recurrenceModel(rule ? {
        rule
      } : {});
    }
    recurrence.timeSpan = eventCopy;
    eventCopy.setStartDate(this.values.startDate);
    recurrence.suspendTimeSpanNotifying();
    return recurrence;
  }
  onRecurrableEventBeforeSave({
    eventRecord,
    context
  }) {
    const me = this;
    if (me.isEditing && !eventRecord.isCreating && eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence)) {
      me.recurrenceConfirmation.confirm({
        actionType: "update",
        eventRecord,
        changerFn() {
          context.finalize(true);
        },
        cancelFn() {
          context.finalize(false);
        }
      });
      context.async = true;
    }
  }
  set recurrenceConfirmation(recurrenceConfirmation) {
    this._recurrenceConfirmation = recurrenceConfirmation;
  }
  get recurrenceConfirmation() {
    const me = this;
    let recurrenceConfirmation = me._recurrenceConfirmation;
    if (!recurrenceConfirmation || !recurrenceConfirmation.$$name) {
      recurrenceConfirmation = Widget.create(_objectSpread2({
        type: "recurrenceconfirmation",
        owner: me.editor
      }, recurrenceConfirmation));
      me._recurrenceConfirmation = recurrenceConfirmation;
    }
    return recurrenceConfirmation;
  }
  set recurrenceEditor(recurrenceEditor) {
    this._recurrenceEditor = recurrenceEditor;
  }
  get recurrenceEditor() {
    const me = this;
    let recurrenceEditor = me._recurrenceEditor;
    if (!recurrenceEditor || !recurrenceEditor.$$name) {
      me._recurrenceEditor = recurrenceEditor = Widget.create(_objectSpread2({
        type: "recurrenceeditor",
        autoShow: false,
        centered: true,
        modal: true,
        constrainTo: globalThis,
        anchor: false,
        rootElement: me.rootElement,
        saveHandler: me.recurrenceEditorSaveHandler,
        onBeforeShow: me.onBeforeShowRecurrenceEditor.bind(me),
        thisObj: me
      }, recurrenceEditor));
      recurrenceEditor.readOnly = me._readOnly;
    }
    return recurrenceEditor;
  }
  onBeforeShowRecurrenceEditor() {
    const me = this, {
      recurrenceEditor,
      eventRecord
    } = me;
    if (recurrenceEditor && eventRecord !== null && eventRecord !== void 0 && eventRecord.supportsRecurring) {
      if (!me.recurrence) {
        me.recurrence = me.makeRecurrence();
      }
      me.recurrence.timeSpan.setStartDate(me.values.startDate);
      recurrenceEditor.record = me.recurrence;
      recurrenceEditor.centered = true;
    }
  }
  loadRecurrenceData(recurrence) {
    this.recurrence = recurrence;
    this.updateRecurrenceFields(recurrence);
  }
  updateRecurrenceFields(recurrence) {
    const me = this, {
      editRecurrenceButton
    } = me;
    if (me.recurrenceCombo) {
      me.recurrenceCombo.recurrence = recurrence;
    }
    if (editRecurrenceButton) {
      editRecurrenceButton.recurrence = recurrence;
      editRecurrenceButton.value = recurrence ? recurrence.rule : null;
      if (recurrence && me.client.enableRecurringEvents && me.showRecurringUI !== false) {
        editRecurrenceButton.show();
      } else {
        editRecurrenceButton.hide();
      }
    }
  }
  onRecurrenceComboChange({
    source,
    value,
    userAction
  }) {
    if (userAction) {
      const me = this, {
        recurrenceEditor
      } = me;
      if (value === source.customValue) {
        me.recurrenceCombo.recurrence = me.makeRecurrence();
        if (recurrenceEditor.centered) {
          recurrenceEditor.show();
        } else {
          recurrenceEditor.show((me.editRecurrenceButton || source).element);
        }
      } else {
        me.loadRecurrenceData(value && value !== "none" ? me.makeRecurrence(`FREQ=${value}`) : null);
      }
    }
  }
  recurrenceEditorSaveHandler(editor, recurrence) {
    editor.recurrenceEditorPanel.syncEventRecord(recurrence);
    this.updateRecurrenceFields(recurrence);
    editor.close();
  }
  onDatesChange(...args) {
    super.onDatesChange(...args);
    if (!this.loadingRecord && this.editRecurrenceButton) {
      const {
        startDate
      } = this.values;
      if (startDate) {
        this.editRecurrenceButton.eventStartDate = startDate;
      }
    }
  }
  internalLoadRecord(eventRecord) {
    if (eventRecord !== null && eventRecord !== void 0 && eventRecord.supportsRecurring) {
      this.loadRecurrenceData(eventRecord.recurrence ? this.makeRecurrence() : null);
    }
  }
  updateRecord(record) {
    if (record.recurrenceRule && !this.recurrence) {
      record.recurrenceRule = null;
    }
    return super.updateRecord(record);
  }
};
var ResourceCombo = class extends Combo {
  static get $name() {
    return "ResourceCombo";
  }
  static get type() {
    return "resourcecombo";
  }
  static get configurable() {
    return {
      showEventColor: false,
      picker: {
        cls: "b-resourcecombo-picker",
        itemIconTpl(record, i) {
          const {
            eventColor
          } = record, isStyleColor = !DomHelper.isNamedColor(eventColor), style = eventColor ? isStyleColor ? ` style="color:${eventColor}"` : "" : ' style="display:none"', colorClass = !eventColor || isStyleColor ? "" : ` b-sch-foreground-${eventColor}`;
          return `<div class="b-icon b-icon-square${colorClass}"${style}></div>`;
        }
      }
    };
  }
  changeShowEventColor(showEventColor) {
    return Boolean(showEventColor);
  }
  updateShowEventColor(showEventColor) {
    const {
      _picker
    } = this, methodName = showEventColor ? "add" : "remove";
    this.element.classList[methodName]("b-show-event-color");
    _picker === null || _picker === void 0 ? void 0 : _picker.element.classList[methodName]("b-show-event-color");
  }
  changePicker(picker, oldPicker) {
    var _picker2;
    picker = super.changePicker(picker, oldPicker);
    (_picker2 = picker) === null || _picker2 === void 0 ? void 0 : _picker2.element.classList[this.showEventColor ? "add" : "remove"]("b-show-event-color");
    return picker;
  }
  get innerElements() {
    return [{
      class: "b-icon b-resource-icon b-icon-square b-hide-display",
      reference: "resourceIcon"
    }, this.inputElement];
  }
  syncInputFieldValue() {
    var _me$selected$eventCol, _me$selected;
    const me = this, {
      resourceIcon,
      lastResourceIconCls
    } = me, {
      classList
    } = resourceIcon, eventColor = (_me$selected$eventCol = (_me$selected = me.selected) === null || _me$selected === void 0 ? void 0 : _me$selected.eventColor) !== null && _me$selected$eventCol !== void 0 ? _me$selected$eventCol : "";
    super.syncInputFieldValue();
    resourceIcon.style.color = "";
    lastResourceIconCls && classList.remove(lastResourceIconCls);
    me.lastResourceIconCls = null;
    if (eventColor) {
      if (DomHelper.isNamedColor(eventColor)) {
        me.lastResourceIconCls = `b-sch-foreground-${eventColor}`;
        classList.add(me.lastResourceIconCls);
      } else {
        resourceIcon.style.color = eventColor;
      }
      classList.remove("b-hide-display");
    } else {
      classList.add("b-hide-display");
    }
  }
};
ResourceCombo.initClass();
ResourceCombo._$name = "ResourceCombo";
var punctuation = /[^\w\d]/g;
var EventEdit$1 = class extends EditBase.mixin(RecurringEventEdit, Delayable) {
  static get $name() {
    return "EventEdit";
  }
  static get configurable() {
    return {
      triggerEvent: "eventdblclick",
      typeField: "eventType",
      eventRecord: null,
      readOnly: null,
      editorConfig: {
        type: "eventeditor",
        title: "L{EventEdit.Edit event}",
        closable: true,
        localeClass: this,
        defaults: {
          localeClass: this
        },
        items: {
          nameField: {
            type: "text",
            label: "L{Name}",
            clearable: true,
            name: "name",
            weight: 100,
            required: true
          },
          resourceField: {
            type: "resourcecombo",
            label: "L{Resource}",
            name: "resource",
            editable: true,
            valueField: "id",
            displayField: "name",
            highlightExternalChange: false,
            destroyStore: true,
            weight: 200
          },
          startDateField: {
            type: "date",
            cls: "b-inline",
            clearable: false,
            required: true,
            label: "L{Start}",
            name: "startDate",
            validateDateOnly: true,
            weight: 300
          },
          startTimeField: {
            type: "time",
            clearable: false,
            required: true,
            name: "startDate",
            cls: "b-match-label",
            weight: 400
          },
          endDateField: {
            type: "date",
            cls: "b-inline",
            clearable: false,
            required: true,
            label: "L{End}",
            name: "endDate",
            validateDateOnly: true,
            weight: 500
          },
          endTimeField: {
            type: "time",
            clearable: false,
            required: true,
            name: "endDate",
            cls: "b-match-label",
            weight: 600
          }
        },
        bbar: {
          hideWhenEmpty: true,
          defaults: {
            localeClass: this
          },
          items: {
            saveButton: {
              color: "b-blue",
              cls: "b-raised",
              text: "L{Save}",
              weight: 100
            },
            deleteButton: {
              text: "L{Delete}",
              weight: 200
            },
            cancelButton: {
              text: "L{Object.Cancel}",
              weight: 300
            }
          }
        }
      },
      targetEventElement: null
    };
  }
  static get pluginConfig() {
    return {
      chain: ["populateEventMenu", "onEventEnterKey", "editEvent"]
    };
  }
  construct(scheduler, config) {
    this.readOnly = scheduler.readOnly;
    super.construct(scheduler, config);
    scheduler.ion({
      projectChange: "onChangeProject",
      readOnly: "onClientReadOnlyToggle",
      thisObj: this
    });
  }
  get scheduler() {
    return this.client;
  }
  get readOnly() {
    return this._editor ? this.editor.readOnly : this._readOnly;
  }
  updateReadOnly(readOnly) {
    super.updateReadOnly(readOnly);
    if (this._editor) {
      this.editor.readOnly = readOnly;
    }
  }
  onClientReadOnlyToggle({
    readOnly
  }) {
    this.readOnly = readOnly;
  }
  get editor() {
    var _me$onEditorConstruct, _me$eventTypeField, _me$saveButton, _me$deleteButton, _me$cancelButton;
    const me = this, editorListeners = {
      beforehide: "resetEditingContext",
      beforeshow: "onBeforeEditorShow",
      keydown: "onPopupKeyDown",
      thisObj: me
    };
    let {
      _editor: editor
    } = me;
    if (editor) {
      return editor;
    }
    editor = me._editor = Widget.create(me.getEditorConfig());
    if (!editor.floating && !editor.positioned) {
      if (!editor.element.parentNode) {
        me.client.add(editor);
      }
      delete editorListeners.beforehide;
      delete editorListeners.beforShow;
      editorListeners.beforeToggleReveal = "onBeforeEditorToggleReveal";
    }
    editor.readOnly = me._readOnly;
    if (editor.items.length === 0) {
      console.warn("Event Editor configured without any `items`");
    }
    editor.ion(editorListeners);
    me.scheduler.relayEvents(editor, ["beforeSetRecord"], "eventEdit");
    Object.values(editor.widgetMap).forEach((widget) => {
      const ref = widget.ref || widget.id;
      if (ref && !me[ref]) {
        me[ref] = widget;
        switch (widget.name) {
          case "startDate":
          case "endDate":
            widget.ion({
              change: "onDatesChange",
              thisObj: me
            });
            break;
        }
      }
    });
    (_me$onEditorConstruct = me.onEditorConstructed) === null || _me$onEditorConstruct === void 0 ? void 0 : _me$onEditorConstruct.call(me, editor);
    (_me$eventTypeField = me.eventTypeField) === null || _me$eventTypeField === void 0 ? void 0 : _me$eventTypeField.ion({
      change: "onEventTypeChange",
      thisObj: me
    });
    (_me$saveButton = me.saveButton) === null || _me$saveButton === void 0 ? void 0 : _me$saveButton.ion({
      click: "onSaveClick",
      thisObj: me
    });
    (_me$deleteButton = me.deleteButton) === null || _me$deleteButton === void 0 ? void 0 : _me$deleteButton.ion({
      click: "onDeleteClick",
      thisObj: me
    });
    (_me$cancelButton = me.cancelButton) === null || _me$cancelButton === void 0 ? void 0 : _me$cancelButton.ion({
      click: "onCancelClick",
      thisObj: me
    });
    return editor;
  }
  getEditorConfig() {
    const me = this, time = new Date(2e3, 12, 31, 23, 55, 55), dateLength = DateHelper.format(time, me.dateFormat).replace(punctuation, "").length, timeLength = DateHelper.format(time, me.timeFormat).replace(punctuation, "").length, dateTimeLength = dateLength + timeLength, {
      cls,
      scheduler
    } = me, result = ObjectHelper.assign({
      owner: scheduler,
      eventEditFeature: me,
      weekStartDay: me.weekStartDay,
      align: "b-t",
      id: `${scheduler.id}-event-editor`,
      autoShow: false,
      anchor: true,
      scrollAction: "realign",
      constrainTo: globalThis,
      cls
    }, me.editorConfig);
    if (Widget.prototype.getRenderContext(result)[0]) {
      result.floating = false;
    }
    if (result.floating === false && !result.positioned) {
      result.collapsible = {
        type: "overlay",
        direction: "right",
        autoClose: false,
        tool: null,
        recollapseTool: null
      };
      result.collapsed = true;
      result.hidden = result.anchor = false;
      result.hide = function() {
        this.collapsible.toggleReveal(false);
      };
    }
    result.onElementCreated = function({
      element
    }) {
      element.style.setProperty("--date-time-length", `${dateTimeLength}em`);
      element.style.setProperty("--date-width-difference", `${(dateLength - timeLength) / 2}em`);
    };
    return result;
  }
  internalShowEditor(eventRecord, resourceRecord, align = null) {
    var _align, _align$target, _align2;
    const me = this, {
      scheduler
    } = me, eventElement = ((_align = align) === null || _align === void 0 ? void 0 : (_align$target = _align.target) === null || _align$target === void 0 ? void 0 : _align$target.nodeType) === Element.ELEMENT_NODE ? align.target : scheduler.getElementFromEventRecord(eventRecord, resourceRecord), isPartOfStore = eventRecord.isPartOfStore(scheduler.eventStore);
    align = (_align2 = align) !== null && _align2 !== void 0 ? _align2 : {
      target: eventElement,
      anchor: true
    };
    if (align.target || !isPartOfStore || eventRecord.isCreating) {
      var _super$internalShowEd;
      if (scheduler.trigger("beforeEventEdit", {
        eventEdit: me,
        eventRecord,
        resourceRecord,
        eventElement
      }) === false) {
        scheduler.element.classList.remove("b-eventeditor-editing");
        return false;
      }
      me.resourceRecord = resourceRecord;
      const {
        editor
      } = me;
      me.editingContext = {
        eventRecord,
        resourceRecord,
        eventElement,
        editor,
        isPartOfStore
      };
      (_super$internalShowEd = super.internalShowEditor) === null || _super$internalShowEd === void 0 ? void 0 : _super$internalShowEd.call(this, eventRecord, resourceRecord, align);
      if (me.typeField) {
        me.toggleEventType(eventRecord.get(me.typeField));
      }
      me.loadRecord(eventRecord, resourceRecord);
      if (editor.collapsed) {
        editor.setTimeout(async () => {
          await editor.collapsible.toggleReveal(true);
          editor.focus();
        }, 100);
      } else if (editor.centered || !editor.anchor || !editor.floating) {
        editor.show();
      } else if (eventElement) {
        me.targetEventElement = eventElement;
        editor.showBy(align);
      } else {
        editor.show();
        editor.updateCentered(true);
      }
      const timeResolution = scheduler.timeAxisViewModel.timeResolution;
      if (timeResolution.unit === "hour" || timeResolution.unit === "minute") {
        const step = `${timeResolution.increment}${timeResolution.unit}`;
        if (me.startTimeField) {
          me.startTimeField.step = step;
        }
        if (me.endTimeField) {
          me.endTimeField.step = step;
        }
      }
      me.detachListeners("changesWhileEditing");
      scheduler.eventStore.ion({
        change: me.onChangeWhileEditing,
        refresh: me.onChangeWhileEditing,
        thisObj: me,
        name: "changesWhileEditing"
      });
    }
  }
  onChangeWhileEditing() {
    const me = this;
    if (me.isEditing && me.editingContext.isPartOfStore && !me.eventRecord.isPartOfStore(me.scheduler.eventStore)) {
      me.onCancelClick();
    }
  }
  onBeforeEditorShow() {
    super.onBeforeEditorShow(...arguments);
    this.scheduler.trigger("beforeEventEditShow", _objectSpread2({
      eventEdit: this
    }, this.editingContext));
  }
  updateTargetEventElement(targetEventElement, oldTargetEventElement) {
    targetEventElement === null || targetEventElement === void 0 ? void 0 : targetEventElement.classList.add("b-editing");
    oldTargetEventElement === null || oldTargetEventElement === void 0 ? void 0 : oldTargetEventElement.classList.remove("b-editing");
  }
  editEvent(eventRecord, resourceRecord, element = null) {
    const me = this, {
      simpleEventEdit
    } = me.client.features;
    if (me.isEditing) {
      me.resetEditingContext();
    }
    if (me.disabled || eventRecord.readOnly || eventRecord.isCreating && simpleEventEdit !== null && simpleEventEdit !== void 0 && simpleEventEdit.enabled) {
      return;
    }
    const result = me.doEditEvent(...arguments);
    if (me.isEditing) {
      me.scheduler.element.classList.add("b-eventeditor-editing");
    }
    return result;
  }
  get isEditing() {
    const {
      _editor
    } = this;
    return Boolean(
      (_editor === null || _editor === void 0 ? void 0 : _editor.isVisible) && !(_editor.collapsed && !_editor.revealed)
    );
  }
  doEditEvent(eventRecord, resourceRecord, element = null) {
    const me = this, {
      scheduler
    } = me, isNewRecord = eventRecord.isCreating;
    if (!resourceRecord) {
      resourceRecord = eventRecord.resource || me.resourceStore.getById(eventRecord.resourceId);
    }
    if (isNewRecord) {
      TimeSpan.prototype.normalize.call(eventRecord);
    }
    if (element || isNewRecord) {
      me.internalShowEditor(eventRecord, resourceRecord, element ? {
        target: element
      } : null);
    } else {
      scheduler.scrollResourceEventIntoView(resourceRecord, eventRecord, {
        animate: true,
        edgeOffset: 0,
        extendTimeAxis: false
      }).then(() => me.internalShowEditor(eventRecord, resourceRecord), () => scheduler.element.classList.remove("b-eventeditor-editing"));
    }
  }
  loadRecord(eventRecord, resourceRecord) {
    this.loadingRecord = true;
    this.internalLoadRecord(eventRecord, resourceRecord);
    this.loadingRecord = false;
  }
  get eventRecord() {
    var _this$_editor;
    return (_this$_editor = this._editor) === null || _this$_editor === void 0 ? void 0 : _this$_editor.record;
  }
  internalLoadRecord(eventRecord, resourceRecord) {
    var _resourceField$store;
    const me = this, {
      eventStore
    } = me.client, {
      editor,
      resourceField
    } = me;
    me.resourceRecord = resourceRecord;
    if (resourceField && ((_resourceField$store = resourceField.store) === null || _resourceField$store === void 0 ? void 0 : _resourceField$store.masterStore) !== me.resourceStore) {
      resourceField.store = editor.chainResourceStore();
    }
    editor.record = eventRecord;
    if (resourceField) {
      const resources = eventStore.assignmentStore.getResourcesForEvent(eventRecord);
      editor.assigningValues = true;
      if (!eventRecord.isOccurrence && !eventStore.storage.includes(eventRecord, true) && resourceRecord) {
        me.resourceField.value = resourceRecord[me.resourceField.valueField];
      } else if (me.assignmentStore) {
        me.resourceField.value = resources.map((resource) => resource[me.resourceField.valueField]);
      }
      editor.assigningValues = false;
    }
    super.internalLoadRecord(eventRecord, resourceRecord);
  }
  toggleEventType(eventType) {
    this.editor.element.dataset.eventType = eventType || "";
    this.editor.eachWidget((widget) => {
      var _widget$dataset;
      ((_widget$dataset = widget.dataset) === null || _widget$dataset === void 0 ? void 0 : _widget$dataset.eventType) && (widget.hidden = widget.dataset.eventType !== eventType);
    });
  }
  async finalizeEventSave(eventRecord, resourceRecords, resolve, reject) {
    const me = this, {
      scheduler,
      assignmentStore
    } = me;
    assignmentStore.suspendAutoCommit();
    scheduler.suspendRefresh();
    me.onBeforeSave(eventRecord);
    eventRecord.beginBatch();
    me.updateRecord(eventRecord);
    eventRecord.endBatch();
    if (!eventRecord.isOccurrence) {
      if (me.resourceField) {
        assignmentStore.assignEventToResource(eventRecord, resourceRecords, null, true);
      }
    } else if (resourceRecords) {
      eventRecord.set("resourceRecords", resourceRecords);
    }
    eventRecord.isCreating = false;
    {
      await scheduler.project.commitAsync();
    }
    assignmentStore.resumeAutoCommit();
    scheduler.resumeRefresh(true);
    {
      scheduler.trigger("afterEventSave", {
        eventRecord
      });
      me.onAfterSave(eventRecord);
    }
    resolve(eventRecord);
  }
  save() {
    return new Promise((resolve, reject) => {
      var _me$resourceField;
      const me = this, {
        scheduler,
        eventRecord
      } = me;
      if (!eventRecord || !me.editor.isValid) {
        resolve(false);
        return;
      }
      const {
        eventStore,
        values
      } = me, resourceRecords = ((_me$resourceField = me.resourceField) === null || _me$resourceField === void 0 ? void 0 : _me$resourceField.records) || (me.resourceRecord ? [me.resourceRecord] : []);
      if (!me.scheduler.allowOverlap && eventStore) {
        let {
          startDate,
          endDate
        } = values;
        if (!endDate) {
          if ("duration" in values) {
            endDate = DateHelper.add(startDate, values.duration, values.durationUnit || eventRecord.durationUnit);
          } else if ("fullDuration" in values) {
            endDate = DateHelper.add(startDate, values.fullDuration);
          } else {
            endDate = eventRecord.endDate;
          }
        }
        const abort = resourceRecords.some((resource) => {
          return !eventStore.isDateRangeAvailable(startDate, endDate, eventRecord, resource);
        });
        if (abort) {
          resolve(false);
          return;
        }
      }
      const context = {
        finalize(saveEvent) {
          try {
            if (saveEvent !== false) {
              me.finalizeEventSave(eventRecord, resourceRecords, resolve, reject);
            } else {
              resolve(false);
            }
          } catch (e) {
            reject(e);
          }
        }
      };
      if (scheduler.trigger("beforeEventSave", {
        eventRecord,
        resourceRecords,
        values,
        context
      }) === false) {
        resolve(false);
        return;
      }
      if (!context.async) {
        context.finalize();
      }
    });
  }
  deleteEvent() {
    this.detachListeners("changesWhileEditing");
    return new Promise((resolve, reject) => {
      const me = this, {
        eventRecord,
        editor
      } = me;
      me.scheduler.removeEvents([eventRecord], (removeRecord) => {
        if (removeRecord && editor.containsFocus) {
          editor.revertFocus();
        }
        resolve(removeRecord);
      }, editor);
    });
  }
  onChangeProject() {
    if (this.resourceField) {
      this.resourceField.store = {};
    }
  }
  get eventStore() {
    return this.scheduler.project.eventStore;
  }
  get resourceStore() {
    return this.scheduler.project.resourceStore;
  }
  get assignmentStore() {
    return this.scheduler.project.assignmentStore;
  }
  onActivateEditor({
    eventRecord,
    resourceRecord,
    eventElement
  }) {
    this.editEvent(eventRecord, resourceRecord, eventElement);
  }
  onDragCreateEnd({
    eventRecord,
    resourceRecord,
    proxyElement
  }) {
    this.editEvent(eventRecord, resourceRecord, proxyElement);
  }
  onEventEnterKey({
    assignmentRecord,
    eventRecord,
    target
  }) {
    const {
      client
    } = this, element = target[target.matches(client.eventSelector) ? "querySelector" : "closest"](client.eventInnerSelector);
    if (assignmentRecord) {
      this.editEvent(eventRecord, assignmentRecord.resource, element);
    } else if (eventRecord) {
      this.editEvent(eventRecord, eventRecord.resource, element);
    }
  }
  onEventTypeChange({
    value
  }) {
    this.toggleEventType(value);
  }
  populateEventMenu({
    eventRecord,
    resourceRecord,
    items: items2
  }) {
    if (!this.scheduler.readOnly && !this.disabled) {
      items2.editEvent = {
        text: "L{EventEdit.Edit event}",
        localeClass: this,
        icon: "b-icon b-icon-edit",
        weight: 100,
        disabled: eventRecord.readOnly,
        onItem: () => {
          this.editEvent(eventRecord, resourceRecord);
        }
      };
    }
  }
  onBeforeEditorToggleReveal({
    reveal
  }) {
    this[reveal ? "onBeforeEditorShow" : "resetEditingContext"]();
  }
  resetEditingContext() {
    this.detachListeners("changesWhileEditing");
    super.resetEditingContext();
    this.resourceRecord = null;
  }
};
EventEdit$1._$name = "EventEdit";
GridFeatureManager.registerFeature(EventEdit$1, true, "Scheduler");
GridFeatureManager.registerFeature(EventEdit$1, false, ["SchedulerPro", "ResourceHistogram"]);
EventEdit$1.initClass();
var EventFilter = class extends InstancePlugin {
  static get $name() {
    return "EventFilter";
  }
  static get pluginConfig() {
    return {
      chain: ["populateTimeAxisHeaderMenu"]
    };
  }
  populateTimeAxisHeaderMenu({
    items: items2
  }) {
    const me = this;
    items2.eventsFilter = {
      text: "L{filterEvents}",
      icon: "b-fw-icon b-icon-filter",
      disabled: me.disabled,
      localeClass: me,
      weight: 100,
      menu: {
        type: "popup",
        localeClass: me,
        items: {
          nameFilter: {
            weight: 110,
            type: "textfield",
            cls: "b-eventfilter b-last-row",
            clearable: true,
            keyStrokeChangeDelay: 300,
            label: "L{byName}",
            localeClass: me,
            width: 200,
            internalListeners: {
              change: me.onEventFilterChange,
              thisObj: me
            }
          }
        },
        onBeforeShow({
          source: menu
        }) {
          const [filterByName] = menu.items, filter2 = me.store.filters.getBy("property", "name");
          filterByName.value = (filter2 === null || filter2 === void 0 ? void 0 : filter2.value) || "";
        }
      }
    };
  }
  onEventFilterChange({
    value
  }) {
    if (value !== "") {
      this.store.filter("name", value);
    } else {
      this.store.removeFilter("name");
    }
  }
  get store() {
    const {
      client
    } = this;
    return client.isGanttBase ? client.store : client.eventStore;
  }
};
EventFilter.featureClass = "b-event-filter";
EventFilter._$name = "EventFilter";
GridFeatureManager.registerFeature(EventFilter, true, ["Scheduler", "Gantt"]);
GridFeatureManager.registerFeature(EventFilter, false, "ResourceHistogram");
var EventMenu$1 = class extends TimeSpanMenuBase {
  static get $name() {
    return "EventMenu";
  }
  static get configurable() {
    return {
      processItems: null,
      type: "event"
    };
  }
  static get pluginConfig() {
    const config = super.pluginConfig;
    config.chain.push("populateEventMenu");
    return config;
  }
  get resourceStore() {
    return this.client.isHorizontal ? this.client.store : this.client.resourceStore;
  }
  getDataFromEvent(event) {
    var _ref;
    const data = super.getDataFromEvent(event), eventElement = data.targetElement, {
      client
    } = this, eventRecord = client.resolveEventRecord(eventElement), resourceRecord = eventRecord && ((_ref = client.resolveResourceRecord(eventElement) || this.resourceStore.last) === null || _ref === void 0 ? void 0 : _ref.$original), assignmentRecord = eventRecord && client.resolveAssignmentRecord(eventElement);
    return Object.assign(data, {
      eventElement,
      eventRecord,
      resourceRecord,
      assignmentRecord
    });
  }
  getTargetElementFromEvent({
    target
  }) {
    return target.closest(this.client.eventSelector) || target;
  }
  shouldShowMenu(eventParams) {
    return eventParams.eventRecord;
  }
  showContextMenuFor(eventRecord, {
    targetElement,
    event
  } = {}) {
    if (this.disabled) {
      return;
    }
    if (!targetElement) {
      targetElement = this.getElementFromRecord(eventRecord);
      if (!targetElement) {
        return;
      }
    }
    DomHelper.triggerMouseEvent(targetElement, this.tiggerEvent);
  }
  getElementFromRecord(record) {
    return this.client.getElementsFromEventRecord(record)[0];
  }
  populateEventMenu({
    items: items2,
    eventRecord,
    assignmentRecord
  }) {
    const {
      client
    } = this;
    items2.deleteEvent = {
      disabled: eventRecord.readOnly || (assignmentRecord === null || assignmentRecord === void 0 ? void 0 : assignmentRecord.readOnly),
      hidden: client.readOnly
    };
    items2.unassignEvent = {
      disabled: eventRecord.readOnly || (assignmentRecord === null || assignmentRecord === void 0 ? void 0 : assignmentRecord.readOnly),
      hidden: client.readOnly || client.eventStore.usesSingleAssignment
    };
  }
  changeItems(items2) {
    const {
      client
    } = this;
    return Objects.merge({
      deleteEvent: {
        text: "L{SchedulerBase.Delete event}",
        icon: "b-icon b-icon-trash",
        weight: 200,
        onItem({
          menu,
          eventRecord
        }) {
          var _menu$focusInEvent;
          const revertTarget = (_menu$focusInEvent = menu.focusInEvent) === null || _menu$focusInEvent === void 0 ? void 0 : _menu$focusInEvent.relatedTarget;
          if (revertTarget) {
            revertTarget.focus();
            client.navigator.activeItem = revertTarget;
          }
          client.removeEvents(client.isEventSelected(eventRecord) ? client.selectedEvents : [eventRecord]);
        }
      },
      unassignEvent: {
        text: "L{SchedulerBase.Unassign event}",
        icon: "b-icon b-icon-unassign",
        weight: 300,
        onItem({
          menu,
          eventRecord,
          resourceRecord
        }) {
          var _menu$focusInEvent2;
          const revertTarget = (_menu$focusInEvent2 = menu.focusInEvent) === null || _menu$focusInEvent2 === void 0 ? void 0 : _menu$focusInEvent2.relatedTarget;
          if (revertTarget) {
            revertTarget.focus();
            client.navigator.activeItem = revertTarget;
          }
          eventRecord.unassign(resourceRecord);
        }
      }
    }, items2);
  }
};
EventMenu$1.featureClass = "";
EventMenu$1._$name = "EventMenu";
GridFeatureManager.registerFeature(EventMenu$1, true, "Scheduler");
GridFeatureManager.registerFeature(EventMenu$1, false, "ResourceHistogram");
var NonWorkingTimeMixin = (Target) => {
  var _class;
  return _class = class NonWorkingTimeMixin extends Target {
    getNonWorkingTimeRanges(calendar, startDate, endDate) {
      if (!calendar.getNonWorkingTimeRanges) {
        const result = [];
        calendar.forEachAvailabilityInterval({
          startDate,
          endDate,
          isForward: true
        }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
          for (const [entry, cache] of calendarCacheInterval.intervalGroups) {
            if (!cache.getIsWorking()) {
              result.push({
                name: entry.name,
                iconCls: entry.iconCls,
                cls: entry.cls,
                startDate: intervalStartDate,
                endDate: intervalEndDate
              });
            }
          }
        });
        return result;
      }
      return calendar.getNonWorkingTimeRanges(startDate, endDate);
    }
    getCalendarTimeRanges(calendar, ignoreName = false) {
      const me = this, {
        timeAxis,
        fillTicks
      } = me.client, {
        unit,
        increment
      } = timeAxis, shouldPaint = !me.maxTimeAxisUnit || DateHelper.compareUnits(unit, me.maxTimeAxisUnit) <= 0;
      if (calendar && shouldPaint && timeAxis.count) {
        const allRanges = me.getNonWorkingTimeRanges(calendar, timeAxis.startDate, timeAxis.endDate), timeSpans = allRanges.map((interval) => new TimeSpan({
          name: interval.name,
          cls: `b-nonworkingtime ${interval.cls || ""}`,
          startDate: interval.startDate,
          endDate: interval.endDate
        })), mergedSpans = [];
        let prevRange = null;
        for (const range of timeSpans) {
          if (prevRange && range.startDate <= prevRange.endDate && (ignoreName || range.name === prevRange.name) && range.duration > 0) {
            prevRange.endDate = range.endDate;
          } else {
            mergedSpans.push(range);
            range.id = `nonworking-${mergedSpans.length}`;
            prevRange = range;
          }
        }
        if (fillTicks) {
          mergedSpans.forEach((span) => {
            span.setStartEndDate(DateHelper.ceil(span.startDate, {
              magnitude: increment,
              unit
            }), DateHelper.floor(span.endDate, {
              magnitude: increment,
              unit
            }));
          });
        }
        return mergedSpans;
      } else {
        return [];
      }
    }
    setupDefaultCalendar() {
      const {
        client,
        project
      } = this;
      if (!this.autoGeneratedWeekends && !client.isSchedulerPro && !client.isGantt && project.effectiveCalendar === project.defaultCalendar && !project.defaultCalendar.intervalStore.count) {
        this.autoGeneratedWeekends = true;
        this.updateDefaultCalendar();
      }
    }
    updateDefaultCalendar() {
      if (this.autoGeneratedWeekends) {
        const calendar = this.client.project.effectiveCalendar, intervals = this.defaultNonWorkingIntervals, hasIntervals = Boolean(intervals.length);
        calendar.clearIntervals(hasIntervals);
        if (hasIntervals) {
          calendar.addIntervals(intervals);
        }
      }
    }
    updateLocalization() {
      var _super$updateLocaliza;
      (_super$updateLocaliza = super.updateLocalization) === null || _super$updateLocaliza === void 0 ? void 0 : _super$updateLocaliza.call(this);
      this.autoGeneratedWeekends && this.updateDefaultCalendar();
    }
    get defaultNonWorkingIntervals() {
      const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
      return DateHelper.nonWorkingDaysAsArray.map((dayIndex) => ({
        recurrentStartDate: `on ${dayNames[dayIndex]} at 0:00`,
        recurrentEndDate: `on ${dayNames[(dayIndex + 1) % 7]} at 0:00`,
        isWorking: false
      }));
    }
  }, _defineProperty(_class, "$name", "NonWorkingTimeMixin"), _defineProperty(_class, "configurable", {
    maxTimeAxisUnit: "week"
  }), _class;
};
var EventNonWorkingTime = class extends InstancePlugin.mixin(AttachToProjectMixin, NonWorkingTimeMixin) {
  doDisable(disable) {
    this.client.refresh();
    super.doDisable(disable);
  }
  attachToCalendarManagerStore(store) {
    super.attachToCalendarManagerStore(store);
    const me = this;
    store.ion({
      name: "calendarManagerStore",
      change: "onCalendarChange",
      thisObj: me
    });
    if (me.client.isScheduler) {
      me.project.effectiveCalendar.intervals.ion({
        name: "calendarManagerStore",
        change: "onCalendarChange",
        thisObj: me
      });
    }
    me.setupDefaultCalendar();
  }
  onCalendarChange() {
    this.calendarRangeCache.clear();
  }
  onTimeAxisViewModelUpdate() {
    this.calendarRangeCache.clear();
  }
  getRangeDomConfig(timeRange, minDate, maxDate, relativeTo) {
    const me = this, {
      client
    } = me, {
      rtl
    } = client, startPos = client.getCoordinateFromDate(DateHelper.max(timeRange.startDate, minDate)) - relativeTo, endPos = timeRange.endDate ? client.getCoordinateFromDate(DateHelper.min(timeRange.endDate, maxDate)) - relativeTo : startPos, size = Math.abs(endPos - startPos), isRange = size > 0, translateX = rtl ? `calc(${startPos}px - 100%)` : `${startPos}px`;
    return {
      className: {
        "b-sch-timerange": 1,
        "b-sch-range": 1,
        "b-sch-nonworkingtime": 1,
        [timeRange.cls]: timeRange.cls,
        "b-rtl": rtl
      },
      dataset: {
        id: timeRange.id
      },
      elementData: {
        timeRange
      },
      style: client.isVertical ? `transform: translateY(${translateX}); ${isRange ? `height:${size}px` : ""};` : `transform: translateX(${translateX}); ${isRange ? `width:${size}px` : ""};`
    };
  }
  getCalendarTimeRanges(calendar) {
    let cached = this.calendarRangeCache.get(calendar);
    if (!cached) {
      cached = super.getCalendarTimeRanges(calendar, true);
      this.calendarRangeCache.set(calendar, cached);
    }
    return cached;
  }
  onEventDataGenerated({
    eventRecord,
    endMS,
    startMS,
    start,
    end,
    left,
    top,
    children
  }) {
    if (this.enabled) {
      var _eventRecord$effectiv;
      const {
        isVertical
      } = this.client, calendar = (_eventRecord$effectiv = eventRecord.effectiveCalendarsCombination) !== null && _eventRecord$effectiv !== void 0 ? _eventRecord$effectiv : this.client.project.calendar;
      for (const timeRange of this.getCalendarTimeRanges(calendar)) {
        if (timeRange.startDateMS < endMS && timeRange.endDateMS > startMS) {
          const domConfig = this.getRangeDomConfig(timeRange, start, end, isVertical ? top : left);
          children.push(domConfig);
        }
      }
    }
  }
};
_defineProperty(EventNonWorkingTime, "$name", "EventNonWorkingTime");
_defineProperty(EventNonWorkingTime, "pluginConfig", {
  chain: ["onTimeAxisViewModelUpdate", "updateLocalization", "onEventDataGenerated"]
});
_defineProperty(EventNonWorkingTime, "properties", {
  calendarRangeCache: /* @__PURE__ */ new Map()
});
EventNonWorkingTime._$name = "EventNonWorkingTime";
GridFeatureManager.registerFeature(EventNonWorkingTime, false, "Scheduler");
var EventTooltip$1 = class extends TooltipBase {
  static get $name() {
    return "EventTooltip";
  }
  static get defaultConfig() {
    return {
      template: (data) => `
                ${data.eventRecord.name ? StringHelper.xss`<div class="b-sch-event-title">${data.eventRecord.name}</div>` : ""}
                ${data.startClockHtml}
                ${data.endClockHtml}`,
      cls: "b-sch-event-tooltip",
      monitorRecordUpdate: true,
      scrollAction: "hide"
    };
  }
  construct(client, config) {
    const me = this;
    super.construct(client, config);
    if (typeof me.align === "string") {
      me.align = {
        align: me.align
      };
    }
  }
  onPaint({
    firstPaint
  }) {
    super.onPaint(...arguments);
    if (firstPaint) {
      const me = this, dependencies = me.client.features.dependencies;
      if (dependencies) {
        const configuredOffset = me.align.offset;
        me.tooltip.ion({
          beforeShow: ({
            source: tooltip
          }) => {
            if (!dependencies.disabled) {
              tooltip.align.offset = [0, 10];
            } else {
              tooltip.align.offset = configuredOffset;
            }
          }
        });
      }
    }
  }
};
EventTooltip$1._$name = "EventTooltip";
GridFeatureManager.registerFeature(EventTooltip$1, true, "Scheduler");
GridFeatureManager.registerFeature(EventTooltip$1, false, "ResourceHistogram");
var refreshActions = {
  add: 1,
  remove: 1,
  update: 1,
  removeAll: 1,
  filter: 1
};
var GroupSummary = class extends GroupSummary$1 {
  static get $name() {
    return "GroupSummary";
  }
  static get defaultConfig() {
    return {
      showTooltip: true,
      summaries: null,
      renderer: null
    };
  }
  static get properties() {
    return {
      footersToUpdate: /* @__PURE__ */ new Set()
    };
  }
  static get pluginConfig() {
    return {
      chain: ["render"]
    };
  }
  construct(scheduler, config) {
    const me = this;
    if (scheduler.isVertical) {
      throw new Error("GroupSummary feature is not supported in vertical mode");
    }
    me.scheduler = scheduler;
    super.construct(scheduler, config);
    if (!me.summaries && me.renderer) {
      me.summaries = [{
        renderer: me.renderer
      }];
    }
    if (scheduler.isSchedulerBase) {
      scheduler.eventStore.ion({
        changePreCommit: me.onEventStoreChange,
        thisObj: me
      });
      scheduler.ion({
        timeAxisViewModelUpdate: me.onTimeAxisChange,
        thisObj: me
      });
      scheduler.project.ion({
        dataReady: me.onProjectDataReady,
        thisObj: me
      });
    }
  }
  doDestroy() {
    var _this$_tip;
    (_this$_tip = this._tip) === null || _this$_tip === void 0 ? void 0 : _this$_tip.destroy();
    super.doDestroy();
  }
  onTimeAxisChange() {
    this.scheduler.rowManager.forEach((row) => {
      if (row.isGroupFooter) {
        row.render();
      }
    });
  }
  onEventStoreChange({
    action,
    record,
    records,
    changes
  }) {
    if (refreshActions[action]) {
      var _changes$resourceId;
      const {
        rowManager
      } = this.scheduler, events = record ? [record] : records, resources = /* @__PURE__ */ new Set();
      events.forEach((e) => e.resources.forEach((r) => resources.add(r)));
      if ((changes === null || changes === void 0 ? void 0 : (_changes$resourceId = changes.resourceId) === null || _changes$resourceId === void 0 ? void 0 : _changes$resourceId.oldValue) != null) {
        const oldResource = this.scheduler.resourceStore.getById(changes.resourceId.oldValue);
        oldResource && resources.add(oldResource);
      }
      for (const resourceRecord of resources) {
        let row = rowManager.getRowFor(resourceRecord);
        if (this.target === "header") {
          while (row && !row.isGroupHeader) {
            row = rowManager.getRow(row.index - 1);
          }
        } else {
          while (row && !row.isGroupFooter) {
            row = rowManager.getRow(row.index + 1);
          }
        }
        row && this.footersToUpdate.add(row);
      }
    }
  }
  onProjectDataReady() {
    const {
      footersToUpdate,
      client
    } = this;
    if (client.isVisible) {
      if (footersToUpdate.size) {
        for (const footer of footersToUpdate) {
          var _footer$render;
          (_footer$render = footer.render) === null || _footer$render === void 0 ? void 0 : _footer$render.call(footer);
        }
        footersToUpdate.clear();
      }
    } else {
      client.whenVisible("refresh", client, [true]);
    }
  }
  onBeforeRenderRow({
    row,
    record
  }) {
    if (row.isGroupFooter && !record.meta.hasOwnProperty("groupFooterFor")) {
      const timeaxisCell = row.elements.normal.querySelector(".b-sch-timeaxis-cell");
      if (timeaxisCell) {
        timeaxisCell.innerHTML = "";
      }
    }
    super.onBeforeRenderRow(...arguments);
  }
  generateHtml(column, records, cls, groupRecord, groupField, groupValue) {
    if (column.type === "timeAxis") {
      const me = this, {
        scheduler
      } = me, {
        eventStore
      } = scheduler, colCfg = scheduler.timeAxisViewModel.columnConfig;
      let html = "";
      const eventsByTick = scheduler.getResourcesEventsPerTick(records, ({
        event
      }) => {
        return event.resources.some((resource) => records.includes(resource)) && (!eventStore.isFiltered || eventStore.records.includes(event));
      });
      scheduler.timeAxis.forEach((tick, idx) => {
        const groupEvents = eventsByTick[idx] || [], sumHtml = me.summaries.map((config) => {
          const value = config.renderer({
            startDate: tick.startDate,
            endDate: tick.endDate,
            resourceStore: scheduler.resourceStore,
            events: groupEvents,
            resources: records,
            eventStore,
            groupRecord,
            groupField,
            groupValue
          });
          return `<div class="b-timeaxis-summary-value">${value}</div>`;
        }).join("");
        html += `<div class="b-timeaxis-tick" style="width: ${colCfg[colCfg.length - 1][idx].width}px">${sumHtml}</div>`;
      });
      return `<div class="b-timeaxis-group-summary">${html}</div>`;
    }
    return super.generateHtml(column, records, cls, groupRecord, groupField, groupValue);
  }
  updateSummaryHtml(cellElement, column, records) {
    const count = super.updateSummaryHtml(cellElement, column, records);
    if (column.type === "timeAxis") {
      const result = {
        count: 0,
        height: 0
      };
      this.summaries.forEach((config) => {
        if (config.height) {
          result.height += config.height;
        } else {
          result.count++;
        }
      });
      return result;
    }
    return count;
  }
  getTipHtml({
    activeTarget
  }) {
    const me = this, index = Array.from(activeTarget.parentElement.children).indexOf(activeTarget), tick = me.scheduler.timeAxis.getAt(index);
    let tipHtml = `<header>${me.L("L{Summary.Summary for}", me.scheduler.getFormattedDate(tick.startDate))}</header>`, showTip = false;
    DomHelper.forEachSelector(activeTarget, ".b-timeaxis-summary-value", (element, i) => {
      const label = me._labels[i], text = element.innerText.trim();
      tipHtml += `<label>${label || ""}</label><div class="b-timeaxis-summary-value">${text}</div>`;
      if (element.innerHTML) {
        showTip = true;
      }
    });
    return showTip ? tipHtml : null;
  }
  render() {
    const me = this, {
      scheduler
    } = me;
    if (scheduler.isSchedulerBase) {
      var _me$summaries;
      if ((_me$summaries = me.summaries) !== null && _me$summaries !== void 0 && _me$summaries.some((config) => config.label) && me.showTooltip && !me._tip) {
        me._labels = me.summaries.map((config) => config.label || "");
        me._tip = new Tooltip({
          id: `${scheduler.id}-groupsummary-tip`,
          cls: "b-timeaxis-summary-tip",
          hoverDelay: 0,
          hideDelay: 0,
          forElement: scheduler.timeAxisSubGridElement,
          anchorToTarget: true,
          forSelector: ".b-timeaxis-group-summary .b-timeaxis-tick",
          getHtml: me.getTipHtml.bind(me)
        });
      }
    }
  }
  removeSummaryElements(rowEl) {
    const summaryElement = rowEl.querySelector(".b-timeaxis-group-summary");
    summaryElement === null || summaryElement === void 0 ? void 0 : summaryElement.remove();
    super.removeSummaryElements();
  }
  hasSummary(column) {
    return super.hasSummary(column) || column.isTimeAxisColumn;
  }
};
GroupSummary._$name = "GroupSummary";
GridFeatureManager.registerFeature(GroupSummary, false, "Scheduler");
var HeaderZoom = class extends InstancePlugin {
  static get pluginConfig() {
    return {
      chain: ["onElementMouseDown", "onElementMouseMove"]
    };
  }
  onElementMouseDown(event) {
    const me = this;
    if (event.touches || event.button !== 0 || me.disabled) {
      return;
    }
    if (event.target.closest(".b-sch-header-timeaxis-cell")) {
      const headerEl = me.client.subGrids.normal.header.headersElement;
      me.startX = event.clientX;
      me.element = DomHelper.createElement({
        parent: headerEl,
        tag: "div",
        className: "b-headerzoom-rect"
      });
      me.headerElementRect = Rectangle.from(headerEl);
      EventHelper.on({
        element: document,
        mouseup: "onMouseUp",
        thisObj: me,
        once: true
      });
    }
  }
  onElementMouseMove(event) {
    const me = this;
    if (typeof me.startX === "number") {
      const x = Math.max(event.clientX, me.headerElementRect.left), left = Math.min(me.startX, x), width = Math.abs(me.startX - x), rect = new Rectangle(left - me.headerElementRect.x + me.client.scrollLeft, 0, width, me.headerElementRect.height);
      DomHelper.setTranslateX(me.element, rect.left);
      me.element.style.width = rect.width + "px";
    }
  }
  onMouseUp() {
    const me = this;
    if (typeof me.startX === "number") {
      const {
        client
      } = me, rect = Rectangle.from(me.element), startDate = client.getDateFromCoordinate(rect.left, "round", false), endDate = client.getDateFromCoordinate(rect.right, "round", false);
      me.element.remove();
      me.startX = null;
      client.zoomToSpan({
        startDate,
        endDate
      });
    }
  }
};
_defineProperty(HeaderZoom, "$name", "HeaderZoom");
HeaderZoom._$name = "HeaderZoom";
GridFeatureManager.registerFeature(HeaderZoom, false, "Scheduler");
var sides = ["top", "before", "after", "bottom"];
var editorAlign = (side, client) => {
  switch (side) {
    case "top":
      return "b-b";
    case "after":
      return client.rtl ? "r-r" : "l-l";
    case "right":
      return "l-l";
    case "bottom":
      return "t-t";
    case "before":
      return client.rtl ? "l-l" : "r-r";
    case "left":
      return "r-r";
  }
};
var topBottom = {
  top: 1,
  bottom: 1
};
var layoutModes = {
  estimate: 1,
  measure: 1
};
var layoutSides = {
  before: 1,
  after: 1
};
var Labels = class extends InstancePlugin {
  static get $name() {
    return "Labels";
  }
  static get configurable() {
    return {
      labelCls: "b-sch-label",
      top: null,
      after: null,
      right: null,
      bottom: null,
      before: null,
      left: null,
      thisObj: null,
      blurAction: "cancel",
      labelLayoutMode: "default",
      labelCharWidth: 7
    };
  }
  static get pluginConfig() {
    return {
      chain: ["onEventDataGenerated"]
    };
  }
  construct(scheduler, config) {
    const me = this;
    if (scheduler.isVertical) {
      throw new Error("Labels feature is not supported in vertical mode");
    }
    me.scheduler = scheduler;
    super.construct(scheduler, config);
    if (me.top || me.bottom || me.before || me.after) {
      me.updateHostClasslist();
    }
  }
  updateHostClasslist() {
    const {
      top,
      bottom
    } = this, {
      classList
    } = this.scheduler.element;
    classList.remove("b-labels-topbottom");
    classList.remove("b-labels-top");
    classList.remove("b-labels-bottom");
    if (top || bottom) {
      classList.add("b-labels-topbottom");
      if (top) {
        classList.add("b-labels-top");
      }
      if (bottom) {
        classList.add("b-labels-bottom");
      }
    }
  }
  onLabelDblClick(event) {
    const me = this, target = event.target;
    if (target && !me.scheduler.readOnly) {
      const {
        side
      } = target.dataset, labelConfig = me[side], {
        editor,
        field
      } = labelConfig;
      if (editor) {
        const eventRecord = this.scheduler.resolveEventRecord(event.target);
        if (eventRecord.readOnly) {
          return;
        }
        if (!(editor instanceof Editor)) {
          labelConfig.editor = new Editor({
            blurAction: me.blurAction,
            inputField: editor,
            scrollAction: "realign"
          });
        }
        labelConfig.editor.render(me.scheduler.element);
        labelConfig.editor.startEdit({
          target,
          align: editorAlign(side, me.client),
          matchSize: false,
          record: eventRecord,
          field
        });
        event.stopImmediatePropagation();
        return false;
      }
    }
  }
  changeTop(top) {
    return this.processLabelSpec(top, "top");
  }
  updateTop() {
    this.updateHostClasslist();
  }
  changeAfter(after) {
    return this.processLabelSpec(after, "after");
  }
  updateAfter() {
    this.updateHostClasslist();
  }
  changeRight(right) {
    this[this.client.rtl ? "before" : "after"] = right;
  }
  changeBottom(bottom) {
    return this.processLabelSpec(bottom, "bottom");
  }
  updateBottom() {
    this.updateHostClasslist();
  }
  changeBefore(before) {
    return this.processLabelSpec(before, "before");
  }
  updateBefore() {
    this.updateHostClasslist();
  }
  changeLeft(left) {
    this[this.client.rtl ? "after" : "before"] = left;
  }
  processLabelSpec(labelSpec, side) {
    if (typeof labelSpec === "function") {
      labelSpec = {
        renderer: labelSpec
      };
    } else if (typeof labelSpec === "string") {
      labelSpec = {
        field: labelSpec
      };
    } else if (labelSpec) {
      labelSpec = Object.setPrototypeOf({}, labelSpec);
    } else {
      return null;
    }
    const {
      scheduler
    } = this, {
      eventStore,
      resourceStore,
      taskStore,
      id
    } = scheduler, {
      field,
      editor
    } = labelSpec;
    if (topBottom[side]) {
      scheduler.milestoneWidth = null;
    }
    if (eventStore && !taskStore) {
      labelSpec.recordType = "event";
    } else {
      labelSpec.recordType = "task";
    }
    if (field) {
      let fieldDef;
      if (eventStore && !taskStore) {
        fieldDef = eventStore.modelClass.fieldMap[field];
        if (fieldDef) {
          labelSpec.fieldDef = fieldDef;
          labelSpec.recordType = "event";
        } else if (Reflect.has(eventStore.modelClass.prototype, field)) {
          labelSpec.recordType = "event";
        }
      }
      if (!fieldDef && taskStore) {
        fieldDef = taskStore.modelClass.fieldMap[field];
        if (fieldDef) {
          labelSpec.fieldDef = fieldDef;
          labelSpec.recordType = "task";
        } else if (Reflect.has(resourceStore.modelClass.prototype, field)) {
          labelSpec.recordType = "task";
        }
      }
      if (!fieldDef && resourceStore) {
        fieldDef = resourceStore.modelClass.fieldMap[field];
        if (fieldDef) {
          labelSpec.fieldDef = fieldDef;
          labelSpec.recordType = "resource";
        } else if (Reflect.has(resourceStore.modelClass.prototype, field)) {
          labelSpec.recordType = "resource";
        }
      }
      if (editor) {
        if (typeof editor === "boolean") {
          scheduler.editor = {
            type: "textfield"
          };
        } else if (typeof editor === "string") {
          scheduler.editor = {
            type: editor
          };
        }
        EventHelper.on({
          element: scheduler.timeAxisSubGrid.element,
          delegate: ".b-sch-label",
          dblclick: "onLabelDblClick",
          thisObj: this
        });
      }
    }
    return labelSpec;
  }
  doDisable(disable) {
    super.doDisable(disable);
    if (this.client.isPainted) {
      this.client.refresh();
    }
  }
  generateLabelConfigs(data) {
    const me = this, configs = [];
    for (const side of sides) {
      if (me[side]) {
        const {
          field,
          fieldDef,
          recordType,
          renderer,
          thisObj
        } = me[side], domConfig = {
          tag: "label",
          className: {
            [me.labelCls]: 1,
            [`${me.labelCls}-${side}`]: 1
          },
          dataset: {
            side,
            taskFeature: `label-${side}`
          }
        };
        let value;
        const eventRecordProperty = `${recordType}Record`, eventRecord = data[eventRecordProperty];
        if (renderer) {
          value = renderer.call(thisObj || me.thisObj || me, {
            [eventRecordProperty]: eventRecord,
            resourceRecord: data.resourceRecord,
            assignmentRecord: data.assignmentRecord,
            domConfig
          });
        } else {
          value = eventRecord[field];
          if ((fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.type) === "date" && !renderer) {
            value = DateHelper.format(value, me.client.displayDateFormat);
          } else {
            value = StringHelper.encodeHtml(value);
          }
        }
        domConfig.html = value || "\xA0";
        configs.push(domConfig);
      }
    }
    return configs;
  }
  measureLabels(configs, data) {
    const me = this, pxPerMS = me.client.timeAxisViewModel.getSingleUnitInPixels("millisecond");
    for (const config of configs) {
      if (layoutSides[config.dataset.side]) {
        let {
          html
        } = config;
        let length = 0;
        if (me.labelLayoutMode === "estimate") {
          if (html.includes("<")) {
            html = DomHelper.stripTags(html);
          }
          length = html.length * me.labelCharWidth + 18;
        } else {
          const element = me.labelMeasureElement || (me.labelMeasureElement = DomHelper.createElement({
            className: "b-sch-event-wrap b-measure-label",
            parent: me.client.foregroundCanvas
          }));
          element.retainElement = true;
          DomSync.sync({
            targetElement: element,
            childrenOnly: true,
            domConfig: {
              children: [config]
            }
          });
          length = element.firstElementChild.offsetWidth;
        }
        const ms = length / pxPerMS;
        switch (config.dataset.side) {
          case "before":
            data.startMS -= ms;
            break;
          case "after":
            data.endMS += ms;
            break;
        }
      }
    }
  }
  onEventDataGenerated(data) {
    var _data$eventRecord;
    if (!this.disabled && !((_data$eventRecord = data.eventRecord) !== null && _data$eventRecord !== void 0 && _data$eventRecord.isResourceTimeRange)) {
      const configs = this.generateLabelConfigs(data);
      if (layoutModes[this.labelLayoutMode]) {
        this.measureLabels(configs, data);
      }
      data.wrapperChildren.push(...configs);
    }
  }
  updateLabelLayoutMode() {
    if (!this.isConfiguring) {
      this.client.refreshWithTransition();
    }
  }
  updateLabelCharWidth() {
    if (!this.isConfiguring) {
      this.client.refreshWithTransition();
    }
  }
};
Labels.featureClass = "b-sch-labels";
Labels._$name = "Labels";
GridFeatureManager.registerFeature(Labels, false, "Scheduler");
var NonWorkingTime = class extends AbstractTimeRanges.mixin(AttachToProjectMixin, NonWorkingTimeMixin) {
  static get defaultConfig() {
    return {
      highlightWeekends: null,
      hideRangesOnZooming: true,
      showHeaderElements: true,
      showLabelInBody: true,
      autoGeneratedWeekends: false
    };
  }
  doDestroy() {
    this.attachToCalendar(null);
    super.doDestroy();
  }
  set highlightWeekends(highlight) {
    VersionHelper.deprecate("Scheduler", "6.0.0", "Deprecated in favour of disabling the feature");
    this.disabled = !highlight;
  }
  get highlightWeekends() {
    return !this.disabled;
  }
  onConfigChange({
    name
  }) {
    if (!this.isConfiguring && name === "fillTicks") {
      this.refresh();
    }
  }
  attachToProject(project) {
    super.attachToProject(project);
    this.attachToCalendar(project.effectiveCalendar);
    if (!project.graph && !this.client.isScheduler) {
      project.ion({
        name: "project",
        dataReady: {
          fn: () => this.attachToCalendar(project.effectiveCalendar),
          once: true
        },
        thisObj: this
      });
    }
    project.ion({
      name: "project",
      calendarChange: () => this.attachToCalendar(project.effectiveCalendar),
      thisObj: this
    });
  }
  onTimeAxisViewModelUpdate(...args) {
    this._timeAxisUnitDurationMs = null;
    return super.onTimeAxisViewModelUpdate(...args);
  }
  attachToCalendar(calendar) {
    const me = this, {
      project,
      client
    } = me;
    me.detachListeners("calendar");
    me.autoGeneratedWeekends = false;
    if (calendar) {
      me.setupDefaultCalendar();
      calendar.intervalStore.ion({
        name: "calendar",
        change: () => me.setTimeout(() => me.refresh(), 1)
      });
    }
    if (client.isEngineReady && !client.project.isDelayingCalculation && !client.isDestroying) {
      me.refresh();
    } else if (!project.isDestroyed) {
      me.detachListeners("initialProjectListener");
      project.ion({
        name: "initialProjectListener",
        refresh({
          isCalculated
        }) {
          if (isCalculated !== false) {
            me.refresh();
            me.detachListeners("initialProjectListener");
          }
        },
        thisObj: me
      });
    }
  }
  get calendar() {
    var _this$project;
    return (_this$project = this.project) === null || _this$project === void 0 ? void 0 : _this$project.effectiveCalendar;
  }
  get timeAxisUnitDurationMs() {
    if (!this._timeAxisUnitDurationMs) {
      this._timeAxisUnitDurationMs = DateHelper.as("ms", 1, this.client.timeAxis.unit);
    }
    return this._timeAxisUnitDurationMs;
  }
  shouldRenderRange(range) {
    return super.shouldRenderRange(range) && (!this.hideRangesOnZooming || range.durationMS >= this.timeAxisUnitDurationMs);
  }
  get timeRanges() {
    const me = this;
    if (!me._timeRanges) {
      me._timeRanges = me.getCalendarTimeRanges(me.calendar);
    }
    return me._timeRanges;
  }
};
_defineProperty(NonWorkingTime, "$name", "NonWorkingTime");
_defineProperty(NonWorkingTime, "pluginConfig", {
  chain: ["onPaint", "attachToProject", "updateLocalization", "onConfigChange", "onSchedulerHorizontalScroll"]
});
NonWorkingTime._$name = "NonWorkingTime";
GridFeatureManager.registerFeature(NonWorkingTime, false, "Scheduler");
GridFeatureManager.registerFeature(NonWorkingTime, true, ["SchedulerPro", "Gantt", "ResourceHistogram"]);
var Pan = class extends InstancePlugin {
  get targetSelector() {
    return `.b-sch-timeaxis-cell,.b-timeline-subgrid${this.enableInHeader ? ",.b-sch-header-timeaxis-cell,.b-sch-header-text" : ""}`;
  }
  static get pluginConfig() {
    return {
      chain: ["onElementMouseDown"]
    };
  }
  onElementMouseDown(event) {
    const me = this, {
      client
    } = me, {
      button,
      touches,
      target,
      clientX,
      clientY
    } = event, dragFeature = client.features.taskDrag || client.features.eventDrag, enablePanOnEvents = client.readOnly || !(dragFeature !== null && dragFeature !== void 0 && dragFeature.enabled);
    if (touches || button !== 0 || me.disabled || client.trigger("beforePan", {
      event
    }) === false) {
      return;
    }
    if (target.matches(me.targetSelector) || enablePanOnEvents && target.closest(client.eventSelector)) {
      me.mouseX = clientX;
      me.mouseY = clientY;
      me.onHeader = me.enableInHeader && target.closest(".b-sch-header-timeaxis-cell");
      me.mouseDetacher = EventHelper.on({
        element: document,
        mousemove: "onMouseMove",
        mouseup: "onMouseUp",
        thisObj: me
      });
    }
  }
  onMouseMove(event) {
    const me = this, {
      client
    } = me, xScroller = client.timeAxisSubGrid.scrollable, yScroller = client.scrollable, x = event.clientX, y = event.clientY;
    event.preventDefault();
    if (me.vertical && (client.isVertical || !me.onHeader)) {
      yScroller.scrollBy(0, me.mouseY - y);
    }
    if (me.horizontal && (client.isHorizontal || !me.onHeader)) {
      xScroller.scrollBy(me.mouseX - x);
    }
    me.mouseX = x;
    me.mouseY = y;
  }
  onMouseUp() {
    this.mouseDetacher();
    this.mouseDetacher = null;
  }
  get isActive() {
    return Boolean(this.mouseDetacher);
  }
};
_defineProperty(Pan, "$name", "Pan");
_defineProperty(Pan, "configurable", {
  horizontal: true,
  vertical: true,
  enableInHeader: true
});
Pan._$name = "Pan";
GridFeatureManager.registerFeature(Pan, false, ["Scheduler", "Gantt"]);
var ResourceTimeRanges = class extends ResourceTimeRangesBase {
  static get pluginConfig() {
    const superConfig = super.pluginConfig;
    return _objectSpread2(_objectSpread2({}, superConfig), {}, {
      override: ["matchScheduleCell", ...superConfig.override],
      assign: ["resolveResourceTimeRangeRecord", "getElementFromResourceTimeRangeRecord"]
    });
  }
  updateEnableMouseEvents(enable) {
    var _me$mouseEventsDetach;
    const me = this, {
      client
    } = me;
    (_me$mouseEventsDetach = me.mouseEventsDetacher) === null || _me$mouseEventsDetach === void 0 ? void 0 : _me$mouseEventsDetach.call(me);
    me.mouseEventsDetacher = null;
    if (enable) {
      let attachMouseEvents = function() {
        me.mouseEventsDetacher = EventHelper.on({
          element: client.foregroundCanvas,
          delegate: `.${me.rangeCls}`,
          mousedown: "handleRangeMouseEvent",
          mouseup: "handleRangeMouseEvent",
          click: "handleRangeMouseEvent",
          dblclick: "handleRangeMouseEvent",
          contextmenu: "handleRangeMouseEvent",
          mouseover: "handleRangeMouseEvent",
          mouseout: "handleRangeMouseEvent",
          thisObj: me
        });
      };
      client.whenVisible(attachMouseEvents);
    }
    client.element.classList.toggle("b-interactive-resourcetimeranges", Boolean(enable));
  }
  attachToProject(project) {
    const me = this, {
      client: scheduler
    } = me;
    super.attachToProject(project);
    if (!project.resourceTimeRangeStore) {
      project.resourceTimeRangeStore = scheduler.resourceTimeRangeStore || new ResourceTimeRangeStore({
        owner: me
      });
      const {
        crudManager
      } = scheduler;
      if (crudManager && !crudManager.resourceTimeRangeStore) {
        crudManager.resourceTimeRangeStore = project.resourceTimeRangeStore;
      }
    }
    const store = project.resourceTimeRangeStore;
    if (!me.exposedOnScheduler) {
      if (scheduler.resourceTimeRanges) {
        store.add(scheduler.resourceTimeRanges);
        delete scheduler.resourceTimeRanges;
      }
      Object.defineProperty(scheduler, "resourceTimeRanges", {
        get: () => store.records,
        set: (resourceTimeRanges) => store.data = resourceTimeRanges
      });
      me.exposedOnScheduler = true;
    }
    if (!store.resourceStore) {
      store.resourceStore = project.resourceStore;
    }
    me.detachListeners("store");
    store.ion({
      name: "store",
      change: me.onStoreChange,
      thisObj: me
    });
  }
  attachToResourceTimeRangeStore(store) {
    this.attachToProject(this.project);
    this.client.refresh();
  }
  get store() {
    return this.project.resourceTimeRangeStore;
  }
  handleRangeMouseEvent(domEvent) {
    const me = this, rangeElement = domEvent.target.closest(`.${me.rangeCls}`);
    if (rangeElement) {
      var _EventHelper$eventNam;
      const eventName = (_EventHelper$eventNam = EventHelper.eventNameMap[domEvent.type]) !== null && _EventHelper$eventNam !== void 0 ? _EventHelper$eventNam : StringHelper.capitalize(domEvent.type), resourceTimeRangeRecord = me.resolveResourceTimeRangeRecord(rangeElement);
      me.client.trigger("resourceTimeRange" + eventName, {
        feature: me,
        resourceTimeRangeRecord,
        resourceRecord: me.client.resourceStore.getById(resourceTimeRangeRecord.resourceId),
        domEvent
      });
    }
  }
  matchScheduleCell(target) {
    let cell = this.overridden.matchScheduleCell(target);
    if (!cell && this.enableMouseEvents) {
      const {
        client
      } = this, rangeElement = target.closest(`.${this.rangeCls}`);
      cell = rangeElement && client.getCell({
        record: client.isHorizontal ? rangeElement.elementData.resource : client.store.first,
        column: client.timeAxisColumn
      });
    }
    return cell;
  }
  getEventsToRender(resource, events) {
    if (!this.disabled) {
      const {
        timeRanges
      } = resource.$original;
      if (timeRanges !== null && timeRanges !== void 0 && timeRanges.length) {
        const {
          startDate,
          endDate
        } = this.client;
        timeRanges.forEach((timeRange) => {
          if (timeRange.isRecurring) {
            events.push(...timeRange.getOccurrencesForDateRange(startDate, endDate));
          } else {
            events.push(timeRange);
          }
        });
      }
    }
    return events;
  }
  shouldInclude(eventRecord) {
    return eventRecord.isResourceTimeRange && !eventRecord.isNonWorking && !eventRecord.isCalendarHighlightModel;
  }
  doDestroy() {
    var _this$store;
    if (((_this$store = this.store) === null || _this$store === void 0 ? void 0 : _this$store.owner) === this) {
      this.store.destroy();
    }
    super.doDestroy();
  }
};
_defineProperty(ResourceTimeRanges, "$name", "ResourceTimeRanges");
_defineProperty(ResourceTimeRanges, "configurable", {
  rangeCls: "b-sch-resourcetimerange",
  enableMouseEvents: false,
  tabIndex: 0
});
ResourceTimeRanges.featureClass = "";
ResourceTimeRanges._$name = "ResourceTimeRanges";
GridFeatureManager.registerFeature(ResourceTimeRanges, false, "Scheduler");
var ScheduleMenu$1 = class extends TimeSpanMenuBase {
  static get $name() {
    return "ScheduleMenu";
  }
  static get defaultConfig() {
    return {
      type: "schedule",
      items: null,
      processItems: null
    };
  }
  static get pluginConfig() {
    const config = super.pluginConfig;
    config.chain.push("populateScheduleMenu");
    return config;
  }
  shouldShowMenu(eventParams) {
    const {
      client
    } = this, {
      targetElement,
      resourceRecord
    } = eventParams, isTimeAxisColumn = client.timeAxisSubGridElement.contains(targetElement);
    return !targetElement.closest(client.eventSelector) && isTimeAxisColumn && !(resourceRecord && resourceRecord.isSpecialRow);
  }
  getDataFromEvent(event) {
    if (DomHelper.isDOMEvent(event)) {
      var _client$getCellDataFr, _client$getDateFromDo;
      const {
        client
      } = this, cellData = (_client$getCellDataFr = client.getCellDataFromEvent) === null || _client$getCellDataFr === void 0 ? void 0 : _client$getCellDataFr.call(client, event), date2 = (_client$getDateFromDo = client.getDateFromDomEvent) === null || _client$getDateFromDo === void 0 ? void 0 : _client$getDateFromDo.call(client, event, "floor"), resourceRecord = client.resolveResourceRecord(event) || client.isVertical && client.resourceStore.last;
      return ObjectHelper.assign(super.getDataFromEvent(event), cellData, {
        date: date2,
        resourceRecord
      });
    }
    return event;
  }
  populateScheduleMenu({
    items: items2,
    resourceRecord,
    date: date2
  }) {
    const {
      client
    } = this;
    if (!client.readOnly && client.eventStore) {
      items2.addEvent = {
        text: "L{SchedulerBase.Add event}",
        icon: "b-icon b-icon-add",
        disabled: !resourceRecord || resourceRecord.readOnly || !resourceRecord.isWorkingTime(date2),
        weight: 100,
        onItem() {
          client.createEvent(date2, resourceRecord, client.getRowFor(resourceRecord));
        }
      };
    }
  }
};
ScheduleMenu$1.featureClass = "";
ScheduleMenu$1._$name = "ScheduleMenu";
GridFeatureManager.registerFeature(ScheduleMenu$1, true, "Scheduler");
var ScheduleTooltip = class extends InstancePlugin {
  static get $name() {
    return "ScheduleTooltip";
  }
  static get configurable() {
    return {
      messageTemplate: (data) => `<div class="b-sch-hovertip-msg">${data.message}</div>`,
      hideForNonWorkingTime: null
    };
  }
  static get pluginConfig() {
    return {
      chain: ["onPaint"]
    };
  }
  onPaint({
    firstPaint
  }) {
    if (!firstPaint) {
      return;
    }
    const me = this, {
      client
    } = me;
    if (client.isSchedulerPro && me.hideForNonWorkingTime === void 0) {
      me.hideForNonWorkingTime = true;
    }
    let reshowListener;
    const tip = me.hoverTip = new Tooltip(_objectSpread2(_objectSpread2({
      id: `${client.id}-schedule-tip`,
      cls: "b-sch-scheduletip",
      allowOver: true,
      hoverDelay: 0,
      hideDelay: 100,
      showOnHover: true,
      forElement: client.timeAxisSubGridElement,
      anchorToTarget: false,
      trackMouse: true,
      updateContentOnMouseMove: true,
      monitorResize: false,
      textContent: false,
      forSelector: ".b-schedulerbase:not(.b-dragging-event):not(.b-dragcreating) .b-grid-body-container:not(.b-scrolling) .b-timeline-subgrid:not(.b-scrolling) > :not(.b-sch-foreground-canvas):not(.b-group-footer):not(.b-group-row) *",
      constrainTo: null,
      getHtml: me.getHoverTipHtml.bind(me),
      onDocumentMouseDown(event) {
        if (tip.forElement.contains(event.event.target)) {
          reshowListener = EventHelper.on({
            thisObj: me,
            element: client.timeAxisSubGridElement,
            mousemove: (e) => tip.internalOnPointerOver(e),
            capture: true
          });
        }
        const hideAnimation = tip.hideAnimation;
        tip.hideAnimation = false;
        tip.constructor.prototype.onDocumentMouseDown.call(tip, event);
        tip.hideAnimation = hideAnimation;
      }
    }, me.config), {}, {
      internalListeners: me.configuredListeners
    }));
    tip.ion({
      pointerover({
        event
      }) {
        const buttonsPressed = "buttons" in event ? event.buttons > 0 : event.which > 0;
        if (!buttonsPressed && reshowListener) {
          reshowListener();
        }
        return !me.disabled && !buttonsPressed;
      },
      innerhtmlupdate({
        source
      }) {
        me.clockTemplate.updateDateIndicator(source.element, me.lastTime);
      }
    });
    client.ion({
      timeAxisViewModelUpdate: "updateTip",
      thisObj: me
    });
    me.clockTemplate = new ClockTemplate({
      scheduler: client
    });
  }
  processConfiguredListeners() {
  }
  updateTip() {
    if (this.hoverTip.isVisible) {
      this.hoverTip.updateContent();
    }
  }
  doDestroy() {
    this.destroyProperties("clockTemplate", "hoverTip");
    super.doDestroy();
  }
  getHoverTipHtml({
    tip,
    event
  }) {
    const me = this, scheduler = me.client, date2 = event && scheduler.getDateFromDomEvent(event, "floor", true);
    let html = me.lastHtml;
    if (date2 && event.target) {
      const resourceRecord = scheduler.resolveResourceRecord(event);
      if (resourceRecord && (date2 - me.lastTime !== 0 || resourceRecord.id !== me.lastResourceId)) {
        if (me.hideForNonWorkingTime) {
          const isWorkingTime = resourceRecord.isWorkingTime(date2);
          tip.element.classList.toggle("b-nonworking-time", !isWorkingTime);
        }
        me.lastResourceId = resourceRecord.id;
        html = me.lastHtml = me.generateTipContent({
          date: date2,
          event,
          resourceRecord
        });
      }
    } else {
      tip.hide();
      me.lastTime = null;
      me.lastResourceId = null;
    }
    return html;
  }
  generateTipContent({
    date: date2,
    event,
    resourceRecord
  }) {
    const me = this, clockHtml = me.clockTemplate.generateContent({
      date: date2,
      text: me.client.getFormattedDate(date2)
    }), messageHtml = me.messageTemplate({
      message: me.getText(date2, event, resourceRecord) || ""
    });
    me.lastTime = date2;
    return clockHtml + messageHtml;
  }
  getText(date2, event, resourceRecord) {
  }
};
ScheduleTooltip.featureClass = "b-scheduletip";
ScheduleTooltip._$name = "ScheduleTooltip";
GridFeatureManager.registerFeature(ScheduleTooltip, true, "Scheduler");
GridFeatureManager.registerFeature(ScheduleTooltip, false, "ResourceUtilization");
var SimpleEventEdit = class extends InstancePlugin {
  static get $name() {
    return "SimpleEventEdit";
  }
  static get defaultConfig() {
    return {
      triggerEvent: "eventdblclick",
      eventRecord: null,
      field: "name",
      editorConfig: null
    };
  }
  static get pluginConfig() {
    return {
      chain: ["onEventEnterKey", "editEvent"]
    };
  }
  construct(scheduler, config) {
    const me = this;
    me.scheduler = scheduler;
    scheduler.eventEdit = me;
    super.construct(scheduler, config);
    me.clientListenersDetacher = scheduler.ion({
      [me.triggerEvent]: ({
        eventRecord,
        eventElement
      }) => me.editEvent(eventRecord, eventRecord.resource, eventElement),
      dragcreateend: me.onDragCreateEnd,
      thisObj: me
    });
  }
  doDestroy() {
    var _this$editor;
    this.clientListenersDetacher();
    (_this$editor = this.editor) === null || _this$editor === void 0 ? void 0 : _this$editor.destroy();
    super.doDestroy();
  }
  get eventStore() {
    return this.scheduler.eventStore;
  }
  editEvent(eventRecord, resourceRecord, element) {
    const me = this, {
      scheduler
    } = me, {
      eventEdit
    } = me.client.features;
    if (scheduler.readOnly || me.disabled || eventRecord.readOnly || eventEdit && !eventEdit.disabled && !eventRecord.isCreating) {
      return;
    }
    let {
      editor
    } = me;
    element = DomHelper.down(element, scheduler.eventInnerSelector) || element;
    eventRecord = eventRecord.isAssignment ? eventRecord.event : eventRecord;
    me.resource = resourceRecord;
    me.event = eventRecord;
    me.element = element;
    scheduler.element.classList.add("b-eventeditor-editing");
    if (editor) {
      editor.render(scheduler.timeAxisSubGridElement);
    } else {
      me.editor = editor = Editor.new({
        owner: scheduler.timeAxisSubGrid,
        appendTo: scheduler.timeAxisSubGridElement,
        scrollAction: "realign",
        maxHeight: 40,
        align: {
          align: scheduler.isHorizontal ? "c-c" : "t-t"
        },
        cls: "b-simpleeventeditor",
        internalListeners: {
          complete: "onEditorComplete",
          cancel: "onEditorCancel",
          thisObj: me
        },
        onInternalKeyDown: (keyEvent) => keyEvent.stopPropagation()
      }, me.editorConfig);
      me.relayEvents(me.editor, ["beforestart", "start", "beforecomplete", "complete", "beforecancel", "cancel"]);
    }
    if (eventRecord.isCreating) {
      eventRecord.name = "";
    }
    editor.startEdit({
      target: element,
      record: eventRecord,
      field: me.field
    });
    if (scheduler.isVertical && eventRecord.startDate < scheduler.visibleDateRange.startDate) {
      editor.element.scrollIntoView();
    }
    scheduler.navigator.disabled = true;
  }
  onEditorComplete() {
    this.event.isCreating = false;
    this.reset();
  }
  onEditorCancel() {
    if (this.event.isCreating) {
      this.event.remove();
    }
    this.reset();
  }
  reset() {
    this.scheduler.element.classList.remove("b-eventeditor-editing");
    this.scheduler.navigator.disabled = false;
    this.event = null;
    this.resource = null;
  }
  onEventEnterKey({
    assignmentRecord,
    eventRecord
  }) {
    const element = assignmentRecord ? this.scheduler.getElementFromAssignmentRecord(assignmentRecord) : this.scheduler.getElementFromEventRecord(eventRecord), resourceRecord = (assignmentRecord || eventRecord).resource;
    this.editEvent(eventRecord, resourceRecord, element);
  }
  onDragCreateEnd({
    eventRecord,
    resourceRecord,
    eventElement
  }) {
    this.element = eventElement;
    this.editEvent(eventRecord, resourceRecord, eventElement);
  }
};
SimpleEventEdit._$name = "SimpleEventEdit";
GridFeatureManager.registerFeature(SimpleEventEdit, false, "Scheduler");
var zeroMargins = {
  width: 0,
  height: 0
};
var StickyEvents = class extends InstancePlugin {
  construct(scheduler, config) {
    super.construct(scheduler, config);
    if (scheduler.isVertical) {
      this.toUpdate = /* @__PURE__ */ new Set();
      scheduler.ion({
        scroll: "onSchedulerScroll",
        horizontalScroll: "onHorizontalScroll",
        thisObj: this,
        prio: 1e4
      });
    }
  }
  onEventDataGenerated(renderData) {
    if (this.client.isHorizontal) {
      renderData.wrapperCls["b-disable-sticky"] = renderData.eventRecord.stickyContents === false;
    } else {
      this.syncEventContentPosition(renderData, void 0, true);
      this.updateStyles();
    }
  }
  onSchedulerScroll() {
    if (!this.disabled) {
      this.verticalSyncAllEventsContentPosition(this.client);
    }
  }
  onHorizontalScroll({
    subGrid
  }) {
    if (subGrid === this.client.timeAxisSubGrid) {
      this.verticalSyncAllEventsContentPosition(this.client);
    }
  }
  updateStyles() {
    for (const {
      contentEl,
      style
    } of this.toUpdate) {
      DomHelper.applyStyle(contentEl, style);
    }
    this.toUpdate.clear();
  }
  verticalSyncAllEventsContentPosition(scheduler) {
    const {
      resourceMap
    } = scheduler.currentOrientation;
    for (const eventsData of resourceMap.values()) {
      for (const {
        renderData,
        elementConfig
      } of Object.values(eventsData)) {
        const args = [renderData];
        if (elementConfig && renderData.eventRecord.isResourceTimeRange) {
          args.push(elementConfig.children[0]);
        }
        this.syncEventContentPosition.apply(this, args);
      }
    }
    this.toUpdate.size && this.updateStyles();
  }
  syncEventContentPosition(renderData, eventContent = renderData.eventContent, duringGeneration = false) {
    if (this.disabled || renderData.eventRecord.stickyContents === false) {
      return;
    }
    const {
      client
    } = this, {
      eventRecord,
      resourceRecord,
      useEventBuffer,
      bufferAfterWidth,
      bufferBeforeWidth,
      top,
      height
    } = renderData, scrollPosition = client.scrollable.y, wrapperEl = duringGeneration ? null : client.getElementFromEventRecord(eventRecord, resourceRecord, true), contentEl = wrapperEl && DomSync.getChild(wrapperEl, "event.content"), meta = eventRecord.instanceMeta(client), style = typeof eventContent.style === "string" ? eventContent.style = DomHelper.parseStyle(eventContent.style) : eventContent.style || (eventContent.style = {});
    if (wrapperEl !== null && wrapperEl !== void 0 && wrapperEl.classList.contains("b-dragging")) {
      return;
    }
    let start = top, contentSize = height, end = start + contentSize;
    if (useEventBuffer) {
      start += bufferBeforeWidth;
      contentSize = contentSize - bufferBeforeWidth - bufferAfterWidth;
      end = start + contentSize;
    }
    if (start < scrollPosition && end >= scrollPosition && !eventRecord.isMilestone) {
      const contentWidth = contentEl === null || contentEl === void 0 ? void 0 : contentEl.offsetWidth, justify = (contentEl === null || contentEl === void 0 ? void 0 : contentEl.parentNode) && DomHelper.getStyleValue(contentEl.parentNode, "justifyContent"), c = justify === "center" ? (renderData.width - contentWidth) / 2 : 0, eventStart = start, eventEnd = eventStart + contentSize - 1;
      if ((!contentEl || contentWidth) && eventStart < scrollPosition && eventEnd >= scrollPosition) {
        const edgeSizes = this.getEventContentMargins(contentEl), maxOffset = contentEl ? contentSize - contentEl.offsetHeight - edgeSizes.height - c : Number.MAX_SAFE_INTEGER, offset = Math.min(scrollPosition - eventStart, maxOffset - 2);
        style.transform = offset > 0 ? `translateY(${offset}px)` : "";
        meta.stuck = true;
      } else {
        style.transform = "";
        meta.stuck = false;
      }
      if (contentEl) {
        this.toUpdate.add({
          contentEl,
          style
        });
      }
    } else if (contentEl && meta.stuck) {
      style.transform = "";
      meta.stuck = false;
      this.toUpdate.add({
        contentEl,
        style
      });
    }
  }
  getEventContentMargins(contentEl) {
    if (contentEl !== null && contentEl !== void 0 && contentEl.classList.contains("b-sch-event-content")) {
      return DomHelper.getEdgeSize(contentEl, "margin");
    }
    return zeroMargins;
  }
  doDisable() {
    super.doDisable(...arguments);
    if (!this.isConfiguring) {
      this.client.refreshWithTransition();
    }
  }
};
_defineProperty(StickyEvents, "$name", "StickyEvents");
_defineProperty(StickyEvents, "type", "stickyEvents");
_defineProperty(StickyEvents, "pluginConfig", {
  chain: ["onEventDataGenerated"]
});
StickyEvents._$name = "StickyEvents";
GridFeatureManager.registerFeature(StickyEvents, true, "Scheduler");
GridFeatureManager.registerFeature(StickyEvents, false, "ResourceHistogram");
var TimelineSummary = class extends Summary$1 {
  static get $name() {
    return "TimelineSummary";
  }
  static get configurable() {
    return {
      showTooltip: true
    };
  }
  static get pluginConfig() {
    return {
      chain: ["renderRows", "updateProject"]
    };
  }
  construct(client, config) {
    const me = this;
    super.construct(client, config);
    if (!me.summaries) {
      me.summaries = [{
        renderer: me.renderer
      }];
    }
    if (client.isTimelineBase) {
      me.updateProject(client.project);
      client.ion({
        timeAxisViewModelUpdate: me.renderRows,
        thisObj: me
      });
    }
  }
  updateProject(project) {
    this.detachListeners("summaryProject");
    project.ion({
      name: "summaryProject",
      dataReady: "updateTimelineSummaries",
      thisObj: this
    });
  }
  renderRows() {
    if (this.client.isHorizontal) {
      this.client.timeAxisSubGrid.footer.element.querySelector(".b-grid-footer").classList.add("b-sch-summarybar");
    }
    super.renderRows();
    if (!this.disabled) {
      this.render();
    }
  }
  get summaryBarElement() {
    return this.client.element.querySelector(".b-sch-summarybar");
  }
  render() {
    const me = this, {
      client: timeline
    } = me, sizeProp = timeline.isHorizontal ? "width" : "height", colCfg = timeline.timeAxisViewModel.columnConfig, summaryContainer = me.summaryBarElement;
    if (summaryContainer) {
      if (!me._tip && me.showTooltip && me.summaries.some((config) => config.label)) {
        me._tip = new Tooltip({
          id: `${timeline.id}-summary-tip`,
          cls: "b-timeaxis-summary-tip",
          hoverDelay: 0,
          hideDelay: 100,
          forElement: summaryContainer,
          anchorToTarget: true,
          trackMouse: false,
          forSelector: ".b-timeaxis-tick",
          getHtml: ({
            activeTarget
          }) => activeTarget._tipHtml
        });
      }
      summaryContainer.innerHTML = colCfg[colCfg.length - 1].map((col) => `<div class="b-timeaxis-tick" style="${sizeProp}: ${col.width}px"></div>`).join("");
      me.updateTimelineSummaries();
    }
  }
  refresh() {
    super.refresh();
    this.updateTimelineSummaries();
  }
  doDisable(disable) {
    var _this$summaryColumn;
    const {
      isConfiguring
    } = this.client;
    super.doDisable(disable);
    (_this$summaryColumn = this.summaryColumn) === null || _this$summaryColumn === void 0 ? void 0 : _this$summaryColumn.toggle(!disable);
    if (!isConfiguring && !disable) {
      this.render();
    }
  }
  doDestroy() {
    var _this$_tip;
    (_this$_tip = this._tip) === null || _this$_tip === void 0 ? void 0 : _this$_tip.destroy();
    super.doDestroy();
  }
};
TimelineSummary._$name = "TimelineSummary";
var Summary = class extends TimelineSummary {
  static get $name() {
    return "Summary";
  }
  static get configurable() {
    return {
      summaries: null,
      renderer: null,
      verticalSummaryColumnConfig: null
    };
  }
  static get pluginConfig() {
    const config = super.pluginConfig;
    config.chain.push("bindStore", "updateEventStore", "updateResourceStore");
    return config;
  }
  construct(scheduler, config) {
    const me = this;
    me.scheduler = scheduler;
    if (scheduler.isVertical) {
      scheduler.timeAxisSubGrid.resizable = false;
      config.hideFooters = true;
      scheduler.add(scheduler.createSubGrid("right"));
      me.summaryColumn = scheduler.columns.add(ObjectHelper.assign({
        filterable: null,
        region: "right",
        cellCls: "b-grid-footer b-sch-summarybar",
        align: "center",
        sortable: false,
        editor: false,
        groupable: false,
        htmlEncode: false,
        cellMenuItems: false,
        enableHeaderContextMenu: false,
        hidden: me.disabled
      }, me.verticalSummaryColumnConfig))[0];
    }
    super.construct(scheduler, config);
    if (scheduler.isSchedulerBase) {
      me.updateEventStore(scheduler.eventStore);
      me.updateResourceStore(scheduler.resourceStore);
    }
  }
  updateEventStore(eventStore) {
    this.detachListeners("summaryEventStore");
    eventStore.ion({
      name: "summaryEventStore",
      filter: "updateTimelineSummaries",
      thisObj: this
    });
  }
  updateResourceStore(resourceStore) {
    this.detachListeners("summaryResourceStore");
    resourceStore.ion({
      name: "summaryResourceStore",
      filter: "updateTimelineSummaries",
      thisObj: this
    });
  }
  updateTimelineSummaries() {
    const me = this, {
      client: timeline
    } = me, {
      eventStore,
      timeAxis
    } = timeline, summaryContainer = me.summaryBarElement, forResources = me.selectedOnly && timeline.selectedRecords.length ? timeline.selectedRecords : timeline.resourceStore.records;
    if (summaryContainer && timeline.isEngineReady) {
      const eventsByTick = timeline.getResourcesEventsPerTick(forResources, ({
        event
      }) => {
        return !eventStore.isFiltered || eventStore.records.includes(event);
      });
      Array.from(summaryContainer.children).forEach((element, i) => {
        const tick = timeAxis.getAt(i), events = eventsByTick[i] || [];
        let html = "", tipHtml = `<header>${me.L("L{Summary for}", timeline.getFormattedDate(tick.startDate))}</header>`;
        me.summaries.forEach((config) => {
          const value = config.renderer({
            startDate: tick.startDate,
            endDate: tick.endDate,
            resourceStore: timeline.resourceStore,
            eventStore,
            events,
            element
          }), valueHtml = value ? `<div class="b-timeaxis-summary-value">${value}</div>` : "";
          if (me.summaries.length > 1 || value) {
            html += valueHtml;
          }
          tipHtml += valueHtml ? `<label>${config.label || ""}</label>` + valueHtml : "";
        });
        element.innerHTML = html;
        element._tipHtml = html ? tipHtml : "";
      });
    }
  }
};
Summary._$name = "Summary";
GridFeatureManager.registerFeature(Summary, false, "Scheduler");
var setTimeSpanOptions = {
  maintainVisibleStart: true
};
var TimeAxisHeaderMenu = class extends HeaderMenu {
  static get $name() {
    return "TimeAxisHeaderMenu";
  }
  static get defaultConfig() {
    return {
      processItems: null,
      items: null,
      type: "timeAxisHeader"
    };
  }
  static get pluginConfig() {
    const config = super.pluginConfig;
    config.chain.push("populateTimeAxisHeaderMenu");
    return config;
  }
  construct() {
    super.construct(...arguments);
    if (this.triggerEvent.includes("click") && this.client.zoomOnTimeAxisDoubleClick) {
      this.client.zoomOnTimeAxisDoubleClick = false;
    }
  }
  shouldShowMenu(eventParams) {
    const {
      column
    } = eventParams;
    return column && column.enableHeaderContextMenu !== false && column === this.client.timeAxisColumn;
  }
  showContextMenu(eventParams) {
    super.showContextMenu(...arguments);
    if (this.menu) {
      this.menu.scrollAction = "realign";
    }
  }
  populateTimeAxisHeaderMenu({
    items: items2
  }) {
    const me = this, {
      client
    } = me, dateStep = {
      magnitude: client.timeAxis.shiftIncrement,
      unit: client.timeAxis.shiftUnit
    };
    Object.assign(items2, {
      zoomLevel: {
        text: "L{pickZoomLevel}",
        localeClass: me,
        icon: "b-fw-icon b-icon-search-plus",
        disabled: !client.presets.count || me.disabled,
        weight: 200,
        menu: {
          type: "popup",
          items: {
            zoomSlider: {
              weight: 210,
              type: "slider",
              minWidth: 130,
              showValue: false
            }
          },
          onBeforeShow({
            source: menu
          }) {
            const [zoom] = menu.items;
            zoom.min = client.minZoomLevel;
            zoom.max = client.maxZoomLevel;
            zoom.value = client.zoomLevel;
            me.zoomDetatcher = zoom.ion({
              input: "onZoomSliderChange",
              thisObj: me
            });
          },
          onHide() {
            if (me.zoomDetatcher) {
              me.zoomDetatcher();
              me.zoomDetatcher = null;
            }
          }
        }
      },
      dateRange: {
        text: "L{activeDateRange}",
        localeClass: me,
        icon: "b-fw-icon b-icon-calendar",
        weight: 300,
        menu: {
          type: "popup",
          cls: "b-sch-timeaxis-menu-daterange-popup",
          defaults: {
            localeClass: me
          },
          items: {
            startDateField: {
              type: "datefield",
              label: "L{startText}",
              weight: 310,
              labelWidth: "6em",
              required: true,
              step: dateStep,
              internalListeners: {
                change: me.onRangeDateFieldChange,
                thisObj: me
              }
            },
            endDateField: {
              type: "datefield",
              label: "L{endText}",
              weight: 320,
              labelWidth: "6em",
              required: true,
              step: dateStep,
              internalListeners: {
                change: me.onRangeDateFieldChange,
                thisObj: me
              }
            },
            leftShiftBtn: {
              type: "button",
              weight: 330,
              cls: "b-left-nav-btn",
              icon: "b-icon b-icon-previous",
              color: "b-blue b-raised",
              flex: 1,
              margin: 0,
              internalListeners: {
                click: me.onLeftShiftBtnClick,
                thisObj: me
              }
            },
            todayBtn: {
              type: "button",
              weight: 340,
              cls: "b-today-nav-btn",
              color: "b-blue b-raised",
              text: "L{todayText}",
              flex: 4,
              margin: "0 8",
              internalListeners: {
                click: me.onTodayBtnClick,
                thisObj: me
              }
            },
            rightShiftBtn: {
              type: "button",
              weight: 350,
              cls: "b-right-nav-btn",
              icon: "b-icon b-icon-next",
              color: "b-blue b-raised",
              flex: 1,
              internalListeners: {
                click: me.onRightShiftBtnClick,
                thisObj: me
              }
            }
          },
          internalListeners: {
            paint: me.initDateRangeFields,
            thisObj: me
          }
        }
      }
    });
  }
  onZoomSliderChange({
    value
  }) {
    const me = this;
    me.menu.scrollAction = "realign";
    me.client.zoomLevel = value;
    me.menu.setTimeout({
      fn: () => me.menu.scrollAction = "hide",
      delay: 100,
      cancelOutstanding: true
    });
  }
  initDateRangeFields({
    source: dateRange,
    firstPaint
  }) {
    if (firstPaint) {
      const {
        widgetMap
      } = dateRange;
      this.startDateField = widgetMap.startDateField;
      this.endDateField = widgetMap.endDateField;
    }
    this.initDates();
  }
  initDates() {
    const me = this;
    me.startDateField.suspendEvents();
    me.endDateField.suspendEvents();
    me.startDateField.value = me.startDateFieldInitialValue = me.client.startDate;
    me.endDateField.value = me.endDateFieldInitialValue = me.client.endDate;
    me.startDateField.resumeEvents();
    me.endDateField.resumeEvents();
  }
  onRangeDateFieldChange({
    source
  }) {
    const me = this, startDateChanged = source === me.startDateField, {
      client
    } = me, {
      timeAxis
    } = client, startDate = me.startDateFieldInitialValue && !startDateChanged ? me.startDateFieldInitialValue : me.startDateField.value;
    let endDate = me.endDateFieldInitialValue && startDateChanged ? me.endDateFieldInitialValue : me.endDateField.value;
    if (startDateChanged) {
      me.startDateFieldInitialValue = null;
    } else {
      me.endDateFieldInitialValue = null;
    }
    if (!(endDate - startDate)) {
      endDate = DateHelper.add(endDate, timeAxis.shiftIncrement, timeAxis.shiftUnit);
    } else if (endDate < startDate) {
      endDate = DateHelper.add(startDate, timeAxis.shiftIncrement, timeAxis.shiftUnit);
    }
    client.setTimeSpan(startDate, endDate, setTimeSpanOptions);
    me.initDates();
  }
  onLeftShiftBtnClick() {
    this.client.timeAxis.shiftPrevious();
    this.initDates();
  }
  onTodayBtnClick() {
    const today = DateHelper.clearTime(new Date());
    this.client.setTimeSpan(today, DateHelper.add(today, 1, "day"));
    this.initDates();
  }
  onRightShiftBtnClick() {
    this.client.timeAxis.shiftNext();
    this.initDates();
  }
};
TimeAxisHeaderMenu._$name = "TimeAxisHeaderMenu";
GridFeatureManager.registerFeature(TimeAxisHeaderMenu, true, ["Scheduler", "Gantt"]);
GridFeatureManager.registerFeature(TimeAxisHeaderMenu, false, "ResourceHistogram");
var TimeRanges$1 = class extends AbstractTimeRanges.mixin(AttachToProjectMixin) {
  static get $name() {
    return "TimeRanges";
  }
  static get defaultConfig() {
    return {
      store: true
    };
  }
  doDestroy() {
    var _this$storeDetacher;
    (_this$storeDetacher = this.storeDetacher) === null || _this$storeDetacher === void 0 ? void 0 : _this$storeDetacher.call(this);
    super.doDestroy();
  }
  get timeRanges() {
    const me = this;
    if (!me._timeRanges) {
      const {
        store
      } = me;
      let {
        records
      } = store;
      if (store.recurringEvents) {
        const {
          startDate,
          endDate
        } = me.client.timeAxis;
        records = records.flatMap((timeSpan) => {
          if (timeSpan.isRecurring) {
            return timeSpan.getOccurrencesForDateRange(startDate, endDate);
          }
          return timeSpan;
        });
      }
      if (me.currentTimeLine) {
        if (!store.recurringEvents) {
          records = records.slice();
        }
        records.push(me.currentTimeLine);
      }
      me._timeRanges = records;
    }
    return me._timeRanges;
  }
  attachToProject(project) {
    var _me$projectTimeZoneCh;
    super.attachToProject(project);
    const me = this;
    (_me$projectTimeZoneCh = me.projectTimeZoneChangeDetacher) === null || _me$projectTimeZoneCh === void 0 ? void 0 : _me$projectTimeZoneCh.call(me);
    if (me.showCurrentTimeLine) {
      var _me$client$project;
      me.projectTimeZoneChangeDetacher = (_me$client$project = me.client.project) === null || _me$client$project === void 0 ? void 0 : _me$client$project.ion({
        timeZoneChange: () => me.updateCurrentTimeLine()
      });
      if (me.currentTimeLine) {
        me.updateCurrentTimeLine();
      }
    }
  }
  initCurrentTimeLine() {
    const me = this;
    if (me.currentTimeLine || !me.showCurrentTimeLine) {
      return;
    }
    const data = typeof me.showCurrentTimeLine === "object" ? me.showCurrentTimeLine : {};
    me.currentTimeLine = me.store.modelClass.new({
      "id": "currentTime",
      cls: "b-sch-current-time"
    }, data);
    me.currentTimeInterval = me.setInterval(() => me.updateCurrentTimeLine(), me.currentTimeLineUpdateInterval);
    me._timeRanges = null;
    me.updateCurrentTimeLine();
  }
  updateCurrentTimeLine() {
    var _me$project;
    const me = this, {
      currentTimeLine
    } = me;
    currentTimeLine._inTimeZone = (_me$project = me.project) === null || _me$project === void 0 ? void 0 : _me$project.timeZone;
    currentTimeLine.setLocalDate("startDate", new Date());
    currentTimeLine.endDate = currentTimeLine.startDate;
    if (!currentTimeLine.originalData.name) {
      currentTimeLine.name = DateHelper.format(currentTimeLine.startDate, me.currentDateFormat);
    }
    me.renderRanges();
  }
  hideCurrentTimeLine() {
    const me = this;
    if (!me.currentTimeLine) {
      return;
    }
    me.clearInterval(me.currentTimeInterval);
    me.currentTimeLine = null;
    me.refresh();
  }
  updateShowCurrentTimeLine(show) {
    if (show) {
      this.initCurrentTimeLine();
    } else {
      this.hideCurrentTimeLine();
    }
  }
  populateTimeAxisHeaderMenu({
    column,
    items: items2
  }) {
    items2.currentTimeLine = {
      weight: 400,
      text: this.L("L{showCurrentTimeLine}"),
      checked: this.showCurrentTimeLine,
      onToggle: ({
        checked
      }) => {
        this.showCurrentTimeLine = checked;
      }
    };
  }
  attachToStore(store) {
    const me = this;
    let renderRanges = false;
    if (me.storeDetacher) {
      me.storeDetacher();
      renderRanges = true;
    }
    me.storeDetacher = store.ion({
      change: "onStoreChange",
      refresh: "onStoreChange",
      thisObj: me
    });
    me._timeRanges = null;
    renderRanges && me.renderRanges();
  }
  get store() {
    return this.client.project.timeRangeStore;
  }
  updateStore(store) {
    const me = this, {
      client
    } = me, {
      project
    } = client;
    store = project.timeRangeStore;
    me.attachToStore(store);
    if (client.timeRanges && !client._timeRangesExposed) {
      store.add(client.timeRanges);
      delete client.timeRanges;
    }
  }
  attachToTimeRangeStore(store) {
    this.store = store;
  }
  resolveTimeRangeRecord(el) {
    return this.store.getById(el.closest(this.baseSelector).dataset.id);
  }
  onStoreChange({
    type,
    action
  }) {
    const me = this;
    me._timeRanges = null;
    if (me.disabled || !me.client.isVisible || me.isConfiguring || type === "refresh" && action !== "batch") {
      return;
    }
    me.client.runWithTransition(() => me.renderRanges(), !me.client.refreshSuspended);
  }
  onDragStart(event) {
    const me = this, {
      context
    } = event, record = me.resolveTimeRangeRecord(context.element.closest(me.baseSelector)), rangeBodyEl = me.getBodyElementByRecord(record);
    context.relatedElements = [rangeBodyEl];
    Object.assign(context, {
      record,
      rangeBodyEl,
      originRangeX: DomHelper.getTranslateX(rangeBodyEl),
      originRangeY: DomHelper.getTranslateY(rangeBodyEl)
    });
    super.onDragStart(event);
    me.showTip(context);
  }
  onDrop(event) {
    const {
      context
    } = event;
    if (!context.valid) {
      return this.onInvalidDrop({
        context
      });
    }
    const me = this, {
      client
    } = me, {
      record
    } = context, box = Rectangle.from(context.rangeBodyEl), newStart = client.getDateFromCoordinate(box.getStart(client.rtl, client.isHorizontal), "round", false), wasModified = record.startDate - newStart !== 0;
    if (wasModified) {
      record.setStartDate(newStart);
    } else {
      me.onInvalidDrop();
    }
    me.destroyTip();
    super.onDrop(event);
  }
  onResizeStart({
    context
  }) {
    const me = this, record = me.resolveTimeRangeRecord(context.element.closest(me.baseSelector)), rangeBodyEl = me.getBodyElementByRecord(record);
    Object.assign(context, {
      record,
      rangeBodyEl
    });
    me.showTip(context);
  }
  onResizeDrag({
    context
  }) {
    const me = this, {
      rangeBodyEl
    } = context;
    if (me.client.isVertical) {
      if (context.edge === "top") {
        DomHelper.setTranslateY(rangeBodyEl, context.newY);
      }
      rangeBodyEl.style.height = context.newHeight + "px";
    } else {
      if (context.edge === "left") {
        DomHelper.setTranslateX(rangeBodyEl, context.newX);
      }
      rangeBodyEl.style.width = context.newWidth + "px";
    }
  }
  onResize({
    context
  }) {
    if (!context.valid) {
      return this.onInvalidDrop({
        context
      });
    }
    const me = this, {
      client
    } = me, {
      rtl
    } = client, record = context.record, box = Rectangle.from(context.element), startPos = box.getStart(rtl, client.isHorizontal), endPos = box.getEnd(rtl, client.isHorizontal), newStart = client.getDateFromCoordinate(startPos, "round", false), isStart = rtl && context.edge === "right" || !rtl && context.edge === "left" || context.edge === "top", newEnd = client.getDateFromCoordinate(endPos, "round", false), wasModified = isStart && record.startDate - newStart !== 0 || newEnd && record.endDate - newEnd !== 0;
    if (wasModified && newEnd > newStart) {
      if (isStart) {
        record.setStartDate(newStart, false);
      } else {
        record.setEndDate(newEnd, false);
      }
    } else {
      me.onInvalidResize({
        context
      });
    }
    me.destroyTip();
  }
  onInvalidResize({
    context
  }) {
    const me = this;
    me.resize.reset();
    context.rangeBodyEl.parentElement.lastDomConfig = context.rangeBodyEl.lastDomConfig = null;
    me.renderRanges();
    me.destroyTip();
  }
};
_defineProperty(TimeRanges$1, "configurable", {
  store: {
    modelClass: TimeSpan
  },
  currentTimeLineUpdateInterval: 1e4,
  currentDateFormat: "HH:mm",
  showCurrentTimeLine: false
});
TimeRanges$1._$name = "TimeRanges";
GridFeatureManager.registerFeature(TimeRanges$1, false, ["Scheduler", "Gantt"]);
var TimeSelection = class extends AbstractTimeRanges {
  static get configurable() {
    return {
      enableResizing: true,
      showTooltip: false,
      dragTipTemplate: null,
      cls: "b-selected-time-span",
      dragHelperConfig: {
        skipUpdatingElement: true
      },
      resizeHelperConfig: {
        skipUpdatingElement: true
      },
      headerRenderer({
        timeRange
      }) {
        const {
          dateFormat
        } = this.client.timeAxisViewModel.bottomHeader;
        return `<span class="b-selection-start">${DateHelper.format(timeRange.startDate, dateFormat)}</span>
                        <span class="b-selection-end">${DateHelper.format(timeRange.endDate, dateFormat)}</span>
                        <i class='b-icon b-icon-close' data-ref="closeButton" data-btip="L{Popup.close}"></i>`;
      },
      selectedTimeSpan: null
    };
  }
  onUIReady() {
    super.onUIReady();
    this.client.ion({
      timeAxisHeaderMouseDown: "onTimeAxisHeaderMouseDown",
      thisObj: this
    });
  }
  onTimeAxisHeaderMouseDown({
    startDate,
    endDate
  }) {
    if (!this.disabled) {
      this.selectedTimeSpan = {
        startDate,
        endDate
      };
    }
  }
  onTimeRangeClick(event) {
    super.onTimeRangeClick(event);
    const me = this;
    if (!me.disabled && event.target.closest(".b-selected-time-span")) {
      if (event.target.matches('[data-ref="closeButton"]')) {
        me.selectedTimeSpan = null;
      } else {
        me.client.trigger("timeSelectionElementClick", _objectSpread2(_objectSpread2({}, me.selectedTimeSpan), {}, {
          domEvent: event
        }));
      }
    }
  }
  updateFromCoords(x, y, width, height) {
    const {
      client
    } = this, size = client.isHorizontal ? width : height;
    let start = client.isHorizontal ? x : y;
    if (client.rtl && client.isHorizontal) {
      start = Math.max(client.timeAxisViewModel.totalSize - start - size, 0);
    }
    const startDate = client.getDateFromCoord({
      coord: start,
      roundingMethod: "round",
      ignoreRTL: true
    }), endDate = client.getDateFromCoord({
      coord: start + size,
      roundingMethod: "round",
      ignoreRTL: true
    });
    this.selectedTimeSpan = {
      startDate: DateHelper.max(startDate, client.startDate),
      endDate: DateHelper.min(endDate, client.endDate)
    };
  }
  onResizeStart({
    source
  }) {
    const {
      timeAxisViewModel,
      timeResolution
    } = this.client, resolutionDurationMS = DateHelper.asMilliseconds(timeResolution.increment, timeResolution.unit);
    this.resize.minWidth = timeAxisViewModel.getDistanceForDuration(resolutionDurationMS);
  }
  onResizeDrag({
    context
  }) {
    var _context$newWidth, _context$newHeight;
    this.updateFromCoords(context.newX, context.newY, (_context$newWidth = context.newWidth) !== null && _context$newWidth !== void 0 ? _context$newWidth : context.elementWidth, (_context$newHeight = context.newHeight) !== null && _context$newHeight !== void 0 ? _context$newHeight : context.elementHeight);
  }
  onDragStart(event) {
    super.onDragStart(event);
    const {
      context
    } = event;
    context.elementWidth = context.element.offsetWidth;
    context.elementHeight = context.element.offsetHeight;
  }
  onDrag({
    context
  }) {
    this.updateFromCoords(context.newX, context.newY, context.elementWidth, context.elementHeight);
  }
  onDrop() {
    this.client.element.classList.remove("b-dragging-timerange");
  }
  onDragReset() {
    this.refresh();
  }
  get timeRanges() {
    return this.selectedTimeSpan ? [this.selectedTimeSpan] : [];
  }
  shouldRenderRange() {
    return true;
  }
  changeSelectedTimeSpan(timeSpan) {
    if (timeSpan) {
      timeSpan.id = "time-selection";
    }
    return timeSpan;
  }
  updateSelectedTimeSpan(timeSpan) {
    if (!this.isConfiguring) {
      this.refresh();
    }
    this.client.trigger("timeSelectionChange", _objectSpread2({}, timeSpan !== null && timeSpan !== void 0 ? timeSpan : {}));
  }
};
_defineProperty(TimeSelection, "$name", "TimeSelection");
TimeSelection._$name = "TimeSelection";
GridFeatureManager.registerFeature(TimeSelection, false, "Scheduler");
var ScheduleRange = {
  completeview: "completeview",
  currentview: "currentview",
  daterange: "daterange"
};
var immediatePromise$1 = Promise.resolve();
var SchedulerExporterMixin = (base) => class SchedulerExporterMixin extends base {
  async scrollRowIntoView(client, index) {
    const {
      rowManager,
      scrollable
    } = client, oldY = scrollable.y;
    if (index < client.store.count) {
      scrollable.scrollTo(null, rowManager.calculateTop(index));
      if (scrollable.y !== oldY) {
        return new Promise((resolve) => {
          const detacher2 = client.ion({
            scroll({
              scrollTop
            }) {
              if (scrollTop != null && rowManager.getRow(index)) {
                detacher2();
                resolve();
              }
            }
          });
        });
      }
    }
    return immediatePromise$1;
  }
  async scrollToDate(client, date2) {
    let scrollFired = false;
    const promises = [];
    const detacher2 = client.timeAxisSubGrid.scrollable.ion({
      scrollStart({
        x
      }) {
        if (x != null) {
          scrollFired = true;
        }
      }
    });
    promises.push(client.scrollToDate(date2, {
      block: "start"
    }));
    detacher2();
    if (scrollFired) {
      promises.push(client.timeAxisSubGrid.header.scrollable.await("scrollEnd", {
        checkLog: false
      }));
    }
    await Promise.all(promises);
  }
  cloneElement(element, target, clear) {
    super.cloneElement(element, target, clear);
    const clonedEl = this.element.querySelector(".b-schedulerbase");
    clonedEl === null || clonedEl === void 0 ? void 0 : clonedEl.classList.remove(...["fade-in", "slide-from-left", "slide-from-top", "zoom-in"].map((name) => `b-initial-${name}`));
  }
  async prepareComponent(config) {
    const me = this, {
      client
    } = config, {
      currentOrientation
    } = client, includeTimeline = client.timeAxisSubGrid.width > 0;
    switch (config.scheduleRange) {
      case ScheduleRange.completeview:
        config.rangeStart = client.startDate;
        config.rangeEnd = client.endDate;
        break;
      case ScheduleRange.currentview: {
        const {
          startDate,
          endDate
        } = client.visibleDateRange;
        config.rangeStart = startDate;
        config.rangeEnd = endDate;
        break;
      }
    }
    await client.waitForAnimations();
    config.infiniteScroll = client.infiniteScroll;
    client.infiniteScroll = false;
    if (includeTimeline) {
      client.setTimeSpan(config.rangeStart, config.rangeEnd);
      client.svgCanvas;
    }
    me._oldEnableEventAnimations = client.enableEventAnimations;
    client.enableEventAnimations = false;
    if (currentOrientation.isHorizontalRendering) {
      me._oldScrollBuffer = currentOrientation.scrollBuffer;
      me._oldVerticalBuffer = currentOrientation.verticalBufferSize;
      currentOrientation.scrollBuffer = 100;
      currentOrientation.verticalBufferSize = -1;
    }
    client.ignoreViewBox = true;
    await super.prepareComponent(config);
    const {
      exportMeta,
      element
    } = me, fgCanvasEl = element.querySelector(".b-sch-foreground-canvas"), timeAxisEl = element.querySelector(".b-horizontaltimeaxis");
    exportMeta.includeTimeline = includeTimeline;
    if (includeTimeline && config.scheduleRange !== ScheduleRange.completeview) {
      exportMeta.totalWidth -= exportMeta.subGrids.normal.width;
      exportMeta.totalWidth += exportMeta.subGrids.normal.width = client.timeAxisViewModel.getDistanceBetweenDates(config.rangeStart, config.rangeEnd);
      const horizontalPages = Math.ceil(exportMeta.totalWidth / exportMeta.pageWidth), totalPages = horizontalPages * exportMeta.verticalPages;
      exportMeta.horizontalPages = horizontalPages;
      exportMeta.totalPages = totalPages;
      exportMeta.subGrids.normal.scrollLeft = client.getCoordinateFromDate(config.rangeStart);
    }
    exportMeta.timeAxisHeaders = [];
    exportMeta.timeAxisPlaceholders = [];
    exportMeta.headersColleted = false;
    DomHelper.forEachSelector(timeAxisEl, ".b-sch-header-row", (headerRow) => {
      exportMeta.timeAxisPlaceholders.push(me.createPlaceholder(headerRow));
      exportMeta.timeAxisHeaders.push(/* @__PURE__ */ new Map());
    });
    exportMeta.subGrids.normal.eventsPlaceholder = me.createPlaceholder(fgCanvasEl, false);
    DomHelper.removeEachSelector(fgCanvasEl, ".b-sch-event-wrap,.b-sch-resourcetimerange");
    DomHelper.removeEachSelector(me.element, ".b-released");
    exportMeta.eventsBoxes = /* @__PURE__ */ new Map();
    exportMeta.client = client;
    if (client.hasActiveFeature("columnLines")) {
      const columnLinesCanvas = element.querySelector(".b-column-lines-canvas");
      exportMeta.columnLinesPlaceholder = me.createPlaceholder(columnLinesCanvas);
      exportMeta.columnLines = {
        lines: /* @__PURE__ */ new Map(),
        majorLines: /* @__PURE__ */ new Map()
      };
    }
    if (client.hasActiveFeature("timeRanges")) {
      const timeRangesHeaderCanvas = element.querySelector(".b-sch-timeaxiscolumn .b-sch-timeranges-canvas"), timeRangesBodyCanvas = element.querySelector(".b-sch-foreground-canvas .b-sch-timeranges-canvas");
      exportMeta.timeRanges = {};
      if (timeRangesHeaderCanvas) {
        exportMeta.timeRanges.header = {};
        exportMeta.timeRangesHeaderPlaceholder = me.createPlaceholder(timeRangesHeaderCanvas);
      }
      exportMeta.timeRanges.body = {};
      exportMeta.timeRangesBodyPlaceholder = me.createPlaceholder(timeRangesBodyCanvas);
    }
    if (client.hasActiveFeature("dependencies")) {
      client.features.dependencies.fillDrawingCache();
      const svgCanvasEl = element.querySelector(`[id="${client.svgCanvas.getAttribute("id")}"]`);
      if (svgCanvasEl) {
        exportMeta.dependencyCanvasEl = svgCanvasEl;
        exportMeta.dependenciesPlaceholder = me.createPlaceholder(svgCanvasEl, false, {
          ns: "http://www.w3.org/2000/svg",
          tag: "path"
        });
        DomHelper.removeEachSelector(svgCanvasEl, ".b-sch-dependency");
      }
    }
    if (includeTimeline && !DateHelper.betweenLesser(config.rangeStart, client.startDate, client.endDate)) {
      await me.scrollToDate(client, config.rangeStart);
    }
  }
  async restoreState(config) {
    let waitForHorizontalScroll = false;
    const {
      client
    } = config, promises = [];
    const detacher2 = client.timeAxisSubGrid.scrollable.ion({
      scrollStart({
        x
      }) {
        if (this.element.scrollLeft !== x) {
          waitForHorizontalScroll = true;
        }
      }
    });
    promises.push(super.restoreState(config));
    detacher2();
    if (waitForHorizontalScroll) {
      promises.push(client.timeAxisSubGrid.header.scrollable.await("scrollEnd", {
        checkLog: false
      }));
    }
    await Promise.all(promises);
  }
  async restoreComponent(config) {
    const {
      client
    } = config, {
      currentOrientation
    } = client;
    client.ignoreViewBox = false;
    client.infiniteScroll = config.infiniteScroll;
    client.enableEventAnimations = this._oldEnableEventAnimations;
    if (currentOrientation.isHorizontalRendering) {
      currentOrientation.scrollBuffer = this._oldScrollBuffer;
      currentOrientation.verticalBufferSize = this._oldVerticalBuffer;
    }
    await super.restoreComponent(config);
  }
  async onRowsCollected(rows, config) {
    const me = this;
    await super.onRowsCollected(rows, config);
    if (me.exportMeta.includeTimeline) {
      const {
        client,
        enableDirectRendering
      } = config, {
        timeView
      } = client, {
        pageRangeStart,
        pageRangeEnd
      } = me.getCurrentPageDateRange(config);
      if (enableDirectRendering) {
        if (pageRangeStart && pageRangeEnd) {
          me.renderHeaders(config, pageRangeStart, pageRangeEnd);
          me.renderLines(config, pageRangeStart, pageRangeEnd);
          me.renderRanges(config, pageRangeStart, pageRangeEnd);
          me.renderEvents(config, rows, pageRangeStart, pageRangeEnd);
        }
      } else {
        if (pageRangeStart) {
          let rangeProcessed = false;
          await me.scrollToDate(client, pageRangeStart);
          while (!rangeProcessed) {
            me.collectLines(config);
            me.collectHeaders(config);
            me.collectRanges(config);
            me.collectEvents(rows, config);
            if (DateHelper.timeSpanContains(timeView.startDate, timeView.endDate, pageRangeStart, pageRangeEnd)) {
              rangeProcessed = true;
            } else if (timeView.endDate.getTime() >= pageRangeEnd.getTime()) {
              rangeProcessed = true;
            } else {
              const endDate = timeView.endDate;
              await me.scrollToDate(client, timeView.endDate);
              if (endDate.getTime() === timeView.endDate.getTime()) {
                throw new Error("Could not scroll to date");
              }
            }
          }
        }
        await me.scrollToDate(client, config.rangeStart);
      }
    }
  }
  getCurrentPageDateRange({
    rangeStart,
    rangeEnd,
    enableDirectRendering,
    client
  }) {
    const me = this, {
      exportMeta
    } = me, {
      horizontalPages,
      horizontalPosition,
      pageWidth,
      subGrids
    } = exportMeta;
    let pageRangeStart, pageRangeEnd;
    if (horizontalPages > 1) {
      const pageStartX = horizontalPosition * pageWidth, pageEndX = (horizontalPosition + 1) * pageWidth, normalGridX = subGrids.locked.width + subGrids.locked.splitterWidth;
      if (pageEndX <= normalGridX) {
        pageRangeEnd = pageRangeStart = null;
      } else {
        const {
          scrollLeft = 0
        } = subGrids.normal;
        pageRangeStart = client.getDateFromCoordinate(Math.max(pageStartX - normalGridX + scrollLeft, 0));
        const multiplier = enableDirectRendering ? 1 : 1.2;
        pageRangeEnd = client.getDateFromCoordinate((pageEndX - normalGridX + scrollLeft) * multiplier) || rangeEnd;
      }
    } else {
      pageRangeStart = rangeStart;
      pageRangeEnd = rangeEnd;
    }
    return {
      pageRangeStart,
      pageRangeEnd
    };
  }
  prepareExportElement() {
    const {
      element,
      exportMeta
    } = this, {
      id,
      headerId,
      footerId,
      scrollLeft
    } = exportMeta.subGrids.normal, el = element.querySelector(`[id="${id}"]`);
    [".b-sch-background-canvas", ".b-sch-foreground-canvas"].forEach((selector) => {
      const canvasEl = el.querySelector(selector);
      if (canvasEl) {
        if (exportMeta.lastExportedRowBottom) {
          canvasEl.style.height = `${exportMeta.lastExportedRowBottom}px`;
        } else {
          canvasEl.style.height = "";
        }
        if (scrollLeft) {
          canvasEl.style.marginLeft = `-${scrollLeft}px`;
        }
      }
    });
    if (scrollLeft) {
      [headerId, footerId].forEach((id2) => {
        const el2 = element.querySelector(`[id="${id2}"] .b-widget-scroller`);
        if (el2) {
          el2.style.marginLeft = `-${scrollLeft}px`;
        }
      });
    }
    return super.prepareExportElement();
  }
  collectHeaders(config) {
    const me = this, {
      client
    } = config, {
      exportMeta
    } = me;
    if (!exportMeta.headersCollected) {
      const timeAxisEl = client.timeView.element, timeAxisHeaders = exportMeta.timeAxisHeaders;
      DomHelper.forEachSelector(timeAxisEl, ".b-sch-header-row", (headerRow, index, headerRows) => {
        const headersMap = timeAxisHeaders[index];
        DomHelper.forEachSelector(headerRow, ".b-sch-header-timeaxis-cell", (el) => {
          if (!headersMap.has(el.dataset.tickIndex)) {
            headersMap.set(el.dataset.tickIndex, el.outerHTML);
          }
        });
        if (index === headerRows.length - 1 && headersMap.has(String(client.timeAxis.count - 1))) {
          exportMeta.headersCollected = true;
        }
      });
    }
  }
  collectRanges(config) {
    const me = this, {
      client
    } = config, {
      exportMeta
    } = me, {
      timeRanges
    } = exportMeta;
    if (!exportMeta.headersCollected && timeRanges) {
      const {
        headerCanvas,
        bodyCanvas
      } = client.features.timeRanges;
      if (headerCanvas) {
        DomHelper.forEachSelector(headerCanvas, ".b-sch-timerange", (el) => {
          timeRanges.header[el.dataset.id] = el.outerHTML;
        });
      }
      DomHelper.forEachSelector(bodyCanvas, ".b-sch-timerange", (el) => {
        timeRanges.body[el.dataset.id] = el.outerHTML;
      });
    }
  }
  collectLines(config) {
    const me = this, {
      client
    } = config, {
      exportMeta
    } = me, {
      columnLines
    } = exportMeta;
    if (!exportMeta.headersCollected && columnLines) {
      const bgCanvas = client.backgroundCanvas;
      DomHelper.forEachSelector(bgCanvas, ".b-column-line, .b-column-line-major", (lineEl) => {
        if (lineEl.classList.contains("b-column-line")) {
          const lineIndex = Number(lineEl.dataset.line.replace(/line-/, ""));
          columnLines.lines.set(lineIndex, lineEl.outerHTML);
        } else {
          const lineIndex = Number(lineEl.dataset.line.replace(/major-/, ""));
          columnLines.majorLines.set(lineIndex, lineEl.outerHTML);
        }
      });
    }
  }
  collectEvents(rows, config) {
    const me = this, addedRows = rows.length, {
      client
    } = config, normalRows = me.exportMeta.subGrids.normal.rows;
    rows.forEach((row, index) => {
      var _resource$events, _resource$timeRanges;
      const rowConfig = normalRows[normalRows.length - addedRows + index], resource = client.store.getAt(row.dataIndex), eventsMap = rowConfig[3];
      (_resource$events = resource.events) === null || _resource$events === void 0 ? void 0 : _resource$events.forEach((event) => {
        if (event.isScheduled) {
          let el = client.getElementFromEventRecord(event, resource);
          if (el && (el = el.parentElement) && !eventsMap.has(event.id)) {
            eventsMap.set(event.id, [el.outerHTML, Rectangle.from(el, el.offsetParent)]);
          }
        }
      });
      (_resource$timeRanges = resource.timeRanges) === null || _resource$timeRanges === void 0 ? void 0 : _resource$timeRanges.forEach((timeRange) => {
        var _client$features$reso;
        const elId = ((_client$features$reso = client.features.resourceTimeRanges) === null || _client$features$reso === void 0 ? void 0 : _client$features$reso.generateElementId(timeRange)) || "", el = client.foregroundCanvas.syncIdMap[elId];
        if (el && !eventsMap.has(elId)) {
          eventsMap.set(elId, [el.outerHTML, Rectangle.from(el, el.offsetParent)]);
        }
      });
    });
  }
  renderHeaders(config, start, end) {
    const me = this, {
      exportMeta
    } = me, {
      client
    } = config, timeAxisHeaders = exportMeta.timeAxisHeaders, {
      timeAxisView
    } = client.timeAxisColumn, domConfig = timeAxisView.buildCells(start, end), targetElement = document.createElement("div");
    DomSync.sync({
      targetElement,
      domConfig
    });
    DomHelper.forEachSelector(targetElement, ".b-sch-header-row", (headerRow, index) => {
      const headersMap = timeAxisHeaders[index];
      DomHelper.forEachSelector(headerRow, ".b-sch-header-timeaxis-cell", (el) => {
        if (!headersMap.has(el.dataset.tickIndex)) {
          headersMap.set(el.dataset.tickIndex, el.outerHTML);
        }
      });
    });
  }
  renderEvents(config, rows, start, end) {
    const me = this, {
      client
    } = config, normalRows = me.exportMeta.subGrids.normal.rows;
    rows.forEach((row, index) => {
      const rowConfig = normalRows[index], eventsMap = rowConfig[3], resource = client.store.getAt(row.dataIndex), resourceLayout = client.currentOrientation.getResourceLayout(resource), left = client.getCoordinateFromDate(start), right = client.getCoordinateFromDate(end), eventDOMConfigs = client.currentOrientation.getEventDOMConfigForCurrentView(resourceLayout, row, left, right), targetElement = document.createElement("div");
      eventDOMConfigs.forEach((domConfig) => {
        const {
          eventId
        } = domConfig.dataset, {
          left: left2,
          top,
          width,
          height
        } = domConfig.style;
        DomSync.sync({
          targetElement,
          domConfig
        });
        eventsMap.set(eventId, [targetElement.outerHTML, new Rectangle(left2, top, width, height)]);
      });
    });
  }
  renderLines(config, start, end) {
    const me = this, {
      client
    } = config, {
      exportMeta
    } = me, {
      columnLines
    } = exportMeta;
    if (columnLines) {
      const domConfigs = client.features.columnLines.getColumnLinesDOMConfig(start, end), targetElement = document.createElement("div");
      DomSync.sync({
        targetElement,
        domConfig: {
          children: domConfigs
        },
        onlyChildren: true
      });
      columnLines.lines.set(0, targetElement.innerHTML);
    }
  }
  renderRanges(config, start, end) {
    const me = this, {
      client
    } = config, {
      exportMeta
    } = me, {
      timeRanges
    } = exportMeta;
    if (timeRanges) {
      const domConfigs = client.features.timeRanges.getDOMConfig(start, end), targetElement = document.createElement("div");
      domConfigs.forEach((children, i) => {
        DomSync.sync({
          targetElement,
          domConfig: {
            children,
            onlyChildren: true
          }
        });
        if (i === 0) {
          timeRanges.body = targetElement.innerHTML;
        } else {
          timeRanges.header = targetElement.innerHTML;
        }
      });
    }
  }
  buildPageHtml(config) {
    const me = this, {
      subGrids,
      timeAxisHeaders,
      timeAxisPlaceholders,
      columnLines,
      columnLinesPlaceholder,
      timeRanges,
      timeRangesHeaderPlaceholder,
      timeRangesBodyPlaceholder
    } = me.exportMeta, {
      enableDirectRendering
    } = config;
    let html = me.prepareExportElement();
    Object.values(subGrids).forEach(({
      placeHolder,
      eventsPlaceholder,
      rows,
      mergedCellsHtml
    }) => {
      const placeHolderText = placeHolder.outerHTML, {
        resources,
        events
      } = me.positionRows(rows, config);
      let contentHtml = resources.join("");
      if (mergedCellsHtml !== null && mergedCellsHtml !== void 0 && mergedCellsHtml.length) {
        contentHtml += `<div class="b-grid-merged-cells-container">${mergedCellsHtml.join("")}</div>`;
      }
      html = html.replace(placeHolderText, contentHtml);
      if (eventsPlaceholder) {
        html = html.replace(eventsPlaceholder.outerHTML, events.join(""));
      }
    });
    timeAxisHeaders.forEach((headers, index) => {
      html = html.replace(timeAxisPlaceholders[index].outerHTML, Array.from(headers.values()).join(""));
    });
    if (columnLines) {
      const lineElements = Array.from(columnLines.lines.values()).concat(Array.from(columnLines.majorLines.values()));
      html = html.replace(columnLinesPlaceholder.outerHTML, lineElements.join(""));
      if (enableDirectRendering) {
        me.exportMeta.columnLines.lines.clear();
        me.exportMeta.columnLines.majorLines.clear();
      }
    }
    if (timeRanges) {
      if (enableDirectRendering) {
        html = html.replace(timeRangesBodyPlaceholder.outerHTML, timeRanges.body);
        if (timeRangesHeaderPlaceholder) {
          html = html.replace(timeRangesHeaderPlaceholder.outerHTML, timeRanges.header);
        }
        me.exportMeta.timeRanges = {};
      } else {
        html = html.replace(timeRangesBodyPlaceholder.outerHTML, Object.values(timeRanges.body).join(""));
        if (timeRangesHeaderPlaceholder) {
          html = html.replace(timeRangesHeaderPlaceholder.outerHTML, Object.values(timeRanges.body).join(""));
        }
      }
    }
    html = me.buildDependenciesHtml(html);
    return html;
  }
  getEventBox(event) {
    const me = this, {
      eventsBoxes,
      enableDirectRendering
    } = me.exportMeta;
    const box = event && eventsBoxes.get(String(event.id));
    if (enableDirectRendering && box && event.isMilestone) {
      box.translate(-box.width / 2, 0);
    }
    return box;
  }
  renderDependencies() {
    const me = this, {
      client,
      eventsBoxes
    } = me.exportMeta, {
      dependencies
    } = client, dependencyFeature = client.features.dependencies, targetElement = DomHelper.createElement();
    let draw = false;
    dependencies.forEach((dependency) => {
      if (!eventsBoxes.has(String(dependency.from)) && !eventsBoxes.has(String(dependency.to)) || !dependencyFeature.isDependencyVisible(dependency)) {
        return;
      }
      const fromBox = me.getEventBox(dependency.fromEvent), toBox = me.getEventBox(dependency.toEvent);
      dependencyFeature.drawDependency(dependency, true, {
        from: fromBox === null || fromBox === void 0 ? void 0 : fromBox.clone(),
        to: toBox === null || toBox === void 0 ? void 0 : toBox.clone()
      });
      draw = true;
    });
    if (draw) {
      dependencyFeature.domSync(targetElement);
    }
    return targetElement.innerHTML;
  }
  buildDependenciesHtml(html) {
    const {
      dependenciesPlaceholder,
      includeTimeline
    } = this.exportMeta;
    if (dependenciesPlaceholder && includeTimeline) {
      const placeholder = dependenciesPlaceholder.outerHTML;
      html = html.replace(placeholder, this.renderDependencies());
    }
    return html;
  }
};
var MultiPageExporter = class extends SchedulerExporterMixin(MultiPageExporter$1) {
  static get $name() {
    return "MultiPageExporter";
  }
  static get type() {
    return "multipage";
  }
  async stateNextPage(config) {
    await super.stateNextPage(config);
    this.exportMeta.eventsBoxes.clear();
  }
  positionRows(rows) {
    const resources = [], events = [];
    rows.forEach(([html, top, height, eventsHtml]) => {
      resources.push(html);
      eventsHtml && Array.from(eventsHtml.entries()).forEach(([key, [html2, box, extras = []]]) => {
        events.push(html2 + extras.join(""));
        this.exportMeta.eventsBoxes.set(String(key), box);
      });
    });
    return {
      resources,
      events
    };
  }
};
MultiPageExporter._$name = "MultiPageExporter";
var MultiPageVerticalExporter = class extends SchedulerExporterMixin(MultiPageVerticalExporter$1) {
  static get $name() {
    return "MultiPageVerticalExporter";
  }
  static get type() {
    return "multipagevertical";
  }
  async stateNextPage(config) {
    await super.stateNextPage(config);
    this.exportMeta.eventsBoxes.clear();
  }
  async prepareComponent(config) {
    await super.prepareComponent(config);
    if (config.scheduleRange !== ScheduleRange.completeview) {
      this.estimateTotalPages(config);
    }
  }
  positionRows(rows) {
    const resources = [], events = [];
    rows.forEach(([html, , , eventsHtml]) => {
      resources.push(html);
      eventsHtml && Array.from(eventsHtml.entries()).forEach(([key, [html2, box, extras = []]]) => {
        events.push(html2 + extras.join(""));
        this.exportMeta.eventsBoxes.set(String(key), box);
      });
    });
    return {
      resources,
      events
    };
  }
};
MultiPageVerticalExporter._$name = "MultiPageVerticalExporter";
var ScheduleRangeCombo = class extends Combo {
  static get $name() {
    return "ScheduleRangeCombo";
  }
  static get type() {
    return "schedulerangecombo";
  }
  static get defaultConfig() {
    return {
      editable: false,
      localizeDisplayFields: true,
      displayField: "text",
      buildItems() {
        return Object.entries(ScheduleRange).map(([id, text]) => ({
          value: id,
          text: "L{" + text + "}"
        }));
      }
    };
  }
};
ScheduleRangeCombo.initClass();
ScheduleRangeCombo._$name = "ScheduleRangeCombo";
var SchedulerExportDialog = class extends ExportDialog {
  static get $name() {
    return "SchedulerExportDialog";
  }
  static get type() {
    return "schedulerexportdialog";
  }
  static get configurable() {
    return {
      defaults: {
        localeClass: this
      },
      items: {
        scheduleRangeField: {
          type: "schedulerangecombo",
          label: "L{Schedule range}",
          value: "completeview",
          weight: 150,
          onChange({
            value
          }) {
            this.parent.widgetMap.rangesContainer.hidden = value !== ScheduleRange.daterange;
          }
        },
        rangesContainer: {
          type: "container",
          flex: "1 0 100%",
          weight: 151,
          hidden: true,
          defaults: {
            localeClass: this
          },
          items: {
            filler: {
              weight: 0,
              type: "widget"
            },
            rangeStartField: {
              type: "datefield",
              label: "L{Export from}",
              labelWidth: "3em",
              flex: "1 0 25%",
              weight: 10,
              onChange({
                value
              }) {
                this.parent.widgetMap.rangeEndField.min = DateHelper.add(value, 1, "d");
              }
            },
            filler2: {
              type: "widget",
              weight: 20,
              width: "0.5em"
            },
            rangeEndField: {
              type: "datefield",
              label: "L{Export to}",
              labelWidth: "1em",
              flex: "1 0 25%",
              weight: 30,
              onChange({
                value
              }) {
                this.parent.widgetMap.rangeStartField.max = DateHelper.add(value, -1, "d");
              }
            }
          }
        }
      }
    };
  }
  onLocaleChange() {
    const labelWidth = this.L("labelWidth");
    this.width = this.L("L{width}");
    this.items.forEach((widget) => {
      if (widget instanceof Field) {
        widget.labelWidth = labelWidth;
      } else if (widget.ref === "rangesContainer") {
        widget.items[0].width = labelWidth;
      }
    });
  }
  applyInitialValues(config) {
    super.applyInitialValues(config);
    const me = this, {
      client,
      scheduleRange
    } = config, items2 = config.items = config.items || {}, scheduleRangeField = items2.scheduleRangeField = items2.scheduleRangeField || {}, rangesContainer = items2.rangesContainer = items2.rangesContainer || {}, rangesContainerItems = rangesContainer.items = rangesContainer.items || {}, filler = rangesContainerItems.filler = rangesContainerItems.filler || {}, rangeStartField = rangesContainerItems.rangeStartField = rangesContainerItems.rangeStartField || {}, rangeEndField = rangesContainerItems.rangeEndField = rangesContainerItems.rangeEndField || {};
    filler.width = me.L("labelWidth");
    scheduleRangeField.value = scheduleRangeField.value || scheduleRange;
    if (scheduleRangeField.value === ScheduleRange.daterange) {
      rangesContainer.hidden = false;
    }
    const rangeStart = rangeStartField.value = rangeStartField.value || client.startDate;
    rangeStartField.max = DateHelper.max(client.startDate, DateHelper.add(client.endDate, -1, "d"));
    let rangeEnd = rangeEndField.value || client.endDate;
    if (rangeEnd <= rangeStart) {
      rangeEnd = DateHelper.add(rangeStart, 1, "d");
    }
    rangeEndField.value = rangeEnd;
    rangeEndField.min = DateHelper.min(client.endDate, DateHelper.add(client.startDate, 1, "d"));
  }
};
SchedulerExportDialog._$name = "SchedulerExportDialog";
var SinglePageExporter = class extends SchedulerExporterMixin(SinglePageExporter$1) {
  static get $name() {
    return "SinglePageExporter";
  }
  static get type() {
    return "singlepage";
  }
  collectDependencies() {
  }
  positionRows(rows, config) {
    const resources = [], events = [], translateRe = /translate\((\d+.?\d*)px, (\d+.?\d*)px\)/, topRe = /top:.+?px/;
    if (config.enableDirectRendering) {
      rows.forEach(([html, , , eventsHtml]) => {
        resources.push(html);
        eventsHtml && Array.from(eventsHtml.entries()).forEach(([key, [html2, box, extras = []]]) => {
          this.exportMeta.eventsBoxes.set(String(key), box);
          events.push(html2 + extras.join(""));
        });
      });
    } else {
      let currentTop = 0;
      rows.forEach(([html, top, height, eventsHtml]) => {
        resources.push(html.replace(translateRe, `translate($1px, ${currentTop}px)`));
        const rowTopDelta = currentTop - top;
        eventsHtml && Array.from(eventsHtml.entries()).forEach(([key, [html2, box]]) => {
          box.translate(0, rowTopDelta);
          this.exportMeta.eventsBoxes.set(String(key), box);
          events.push(html2.replace(topRe, `top: ${box.y}px`));
        });
        currentTop += height;
      });
    }
    return {
      resources,
      events
    };
  }
};
SinglePageExporter._$name = "SinglePageExporter";
var PdfExport = class extends PdfExport$1 {
  static get $name() {
    return "PdfExport";
  }
  static get defaultConfig() {
    return {
      exporters: [SinglePageExporter, MultiPageExporter, MultiPageVerticalExporter],
      dialogClass: SchedulerExportDialog,
      scheduleRange: "completeview",
      rangeStart: null,
      rangeEnd: null
    };
  }
  get defaultExportDialogConfig() {
    return ObjectHelper.copyProperties(super.defaultExportDialogConfig, this, ["scheduleRange"]);
  }
  buildExportConfig(config) {
    config = super.buildExportConfig(config);
    const {
      scheduleRange,
      rangeStart,
      rangeEnd
    } = this;
    if (config.columns && !config.columns.find((col) => col.type === "timeAxis")) {
      config.columns.push(config.client.timeAxisColumn.id);
    }
    return ObjectHelper.assign({
      scheduleRange,
      rangeStart,
      rangeEnd
    }, config);
  }
};
PdfExport._$name = "PdfExport";
GridFeatureManager.registerFeature(PdfExport, false, "Scheduler");
var TimeAxisViewModel = class extends Events() {
  static get defaultConfig() {
    return {
      timeAxis: null,
      availableSpace: null,
      tickSize: 100,
      snap: false,
      forceFit: false,
      headers: null,
      mode: "horizontal",
      suppressFit: false,
      columnConfig: [],
      viewPreset: null,
      columnLinesFor: null,
      originalTickSize: null,
      headersDatesCache: []
    };
  }
  construct(config) {
    const me = this;
    me.unitToPixelsCache = {};
    super.construct(config);
    const viewPreset = me.timeAxis.viewPreset || me.viewPreset;
    if (viewPreset) {
      if (viewPreset instanceof ViewPreset) {
        me.consumeViewPreset(viewPreset);
      } else {
        const preset = pm.getPreset(viewPreset);
        preset && me.consumeViewPreset(preset);
      }
    }
    me.timeAxis.ion({
      reconfigure: "onTimeAxisReconfigure",
      thisObj: me
    });
    me.configured = true;
  }
  doDestroy() {
    this.timeAxis.un("reconfigure", this.onTimeAxisReconfigure, this);
    super.doDestroy();
  }
  calculateInfiniteScrollingDateRange(date2, centered, preset = this.viewPreset) {
    const {
      timeAxis,
      availableSpace
    } = this, {
      bufferCoef
    } = this.owner, {
      leafUnit,
      leafIncrement,
      tickSize
    } = preset;
    if (centered) {
      const halfSpan = Math.ceil((availableSpace * bufferCoef + availableSpace / 2) / tickSize);
      return {
        startDate: timeAxis.floorDate(DateHelper.add(date2, -halfSpan * leafIncrement, leafUnit), false, leafUnit, leafIncrement),
        endDate: timeAxis.ceilDate(DateHelper.add(date2, halfSpan * leafIncrement, leafUnit), false, leafUnit, leafIncrement)
      };
    } else {
      const bufferedTicks = Math.ceil(availableSpace * bufferCoef / tickSize);
      return {
        startDate: timeAxis.floorDate(DateHelper.add(date2, -bufferedTicks * leafIncrement, leafUnit), false, leafUnit, leafIncrement),
        endDate: timeAxis.ceilDate(DateHelper.add(date2, Math.ceil((availableSpace / tickSize + bufferedTicks) * leafIncrement), leafUnit), false, leafUnit, leafIncrement)
      };
    }
  }
  get columnConfig() {
    return this._columnConfig;
  }
  set columnConfig(config) {
    this._columnConfig = config;
  }
  get headers() {
    return this._headers;
  }
  set headers(headers) {
    if (headers && headers.length && headers[headers.length - 1].cellGenerator) {
      throw new Error("`cellGenerator` cannot be used for the bottom level of your headers. Use TimeAxis#generateTicks() instead.");
    }
    this._headers = headers;
  }
  get isTimeAxisViewModel() {
    return true;
  }
  get isHorizontal() {
    return this.mode !== "vertical";
  }
  get isVertical() {
    return this.mode === "vertical";
  }
  set forceFit(value) {
    if (value !== this._forceFit) {
      this._forceFit = value;
      this.update();
    }
  }
  reconfigure(config) {
    this.headers = null;
    this.setConfig(config);
    this.trigger("reconfigure");
  }
  onTimeAxisReconfigure({
    source: timeAxis,
    suppressRefresh
  }) {
    if (this.viewPreset !== timeAxis.viewPreset) {
      this.consumeViewPreset(timeAxis.viewPreset);
    }
    if (!suppressRefresh) {
      this.update();
    }
  }
  update(availableSpace, silent = false, forceUpdate = false) {
    const me = this, {
      timeAxis,
      headers
    } = me;
    if (me.isConfiguring || me._availableSpace === availableSpace) {
      if (forceUpdate) {
        me.trigger("update");
      }
      return;
    }
    me._availableSpace = Math.max(availableSpace || me.availableSpace || 0, 0);
    if (typeof me.availableSpace !== "number") {
      throw new Error("Invalid available space provided to TimeAxisModel");
    }
    me.columnConfig = [];
    const tickSize = me._tickSize = me.calculateTickSize(me.originalTickSize);
    if (typeof tickSize !== "number" || tickSize <= 0) {
      throw new Error("Invalid timeAxis tick size");
    }
    me.unitToPixelsCache = {};
    me._totalSize = null;
    for (let pos = 0, {
      length
    } = headers; pos < length; pos++) {
      const header = headers[pos];
      if (header.cellGenerator) {
        const headerCells = header.cellGenerator.call(me, timeAxis.startDate, timeAxis.endDate);
        me.columnConfig[pos] = me.createHeaderRow(pos, header, headerCells);
      } else {
        me.columnConfig[pos] = me.createHeaderRow(pos, header);
      }
    }
    if (!silent) {
      me.trigger("update");
    }
  }
  getDistanceBetweenDates(start, end) {
    return this.getPositionFromDate(end) - this.getPositionFromDate(start);
  }
  getDistanceForDuration(durationMs) {
    return this.getSingleUnitInPixels("millisecond") * durationMs;
  }
  getPositionFromDate(date2, options = {}) {
    const tick = this.getScaledTick(date2, options);
    if (tick === -1) {
      return -1;
    }
    return this.tickSize * (tick - this.timeAxis.visibleTickStart);
  }
  getScaledTick(date2, {
    respectExclusion,
    snapToNextIncluded,
    isEnd,
    min: min2,
    max
  }) {
    const {
      timeAxis
    } = this, {
      include,
      unit
    } = timeAxis;
    let tick = timeAxis.getTickFromDate(date2);
    if (tick !== -1 && respectExclusion && include) {
      let tickChanged = false;
      if (include.hour && DateHelper.compareUnits(unit, "hour") > 0 && unit !== "day") {
        const {
          from,
          to,
          lengthFactor,
          center
        } = include.hour, originalHours = date2.getHours(), croppedHours = Math.min(Math.max(originalHours, from), to);
        if (!snapToNextIncluded && croppedHours !== originalHours) {
          return -1;
        }
        const fractionalHours = croppedHours + date2.getMinutes() / 60, hoursFromCenter = center - fractionalHours, newHours = center - hoursFromCenter * lengthFactor;
        date2 = DateHelper.add(date2, newHours - originalHours, "h");
        tickChanged = true;
      }
      if (include.day && DateHelper.compareUnits(unit, "day") > 0) {
        const {
          from,
          to,
          lengthFactor,
          center
        } = include.day;
        let checkDay = date2.getDay();
        if (isEnd && date2.getHours() === 0 && date2.getMinutes() === 0 && date2.getSeconds() === 0 && date2.getMilliseconds() === 0) {
          if (--checkDay < 0) {
            checkDay = 6;
          }
        }
        let addDays = 0;
        if (checkDay < from || checkDay >= to) {
          if (snapToNextIncluded) {
            if (isEnd) {
              addDays = (to - checkDay - 8) % 7;
            } else {
              addDays = (from - checkDay + 7) % 7;
            }
            date2 = DateHelper.add(date2, addDays, "d");
            date2 = DateHelper.startOf(date2, "d", false);
            if (max && date2.getTime() >= max || min2 && date2.getTime() <= min2) {
              return -1;
            }
          } else {
            return -1;
          }
        }
        const {
          weekStartDay
        } = timeAxis, fixedCenter = date2.getDay() === 0 ? 0 : center, fractionalDay = date2.getDay() + date2.getHours() / 24, daysFromCenter = fixedCenter - fractionalDay, newDay = fixedCenter - daysFromCenter * lengthFactor;
        date2 = DateHelper.add(date2, newDay - fractionalDay + weekStartDay, "d");
        tickChanged = true;
      }
      if (tickChanged) {
        date2 = DateHelper.constrain(date2, timeAxis.startDate, timeAxis.endDate);
        tick = timeAxis.getTickFromDate(date2);
      }
    }
    return tick;
  }
  getDateFromPosition(position, roundingMethod, allowOutOfRange = false) {
    const me = this, {
      timeAxis
    } = me, tick = me.getScaledPosition(position) / me.tickSize + timeAxis.visibleTickStart;
    if (tick < 0 || tick > timeAxis.count) {
      if (allowOutOfRange) {
        let result;
        if (tick < 0) {
          result = DateHelper.add(timeAxis.startDate, tick, timeAxis.unit);
        } else {
          result = DateHelper.add(timeAxis.endDate, tick - timeAxis.count, timeAxis.unit);
        }
        if (roundingMethod) {
          result = timeAxis[roundingMethod + "Date"](result);
        }
        return result;
      }
      return null;
    }
    return timeAxis.getDateFromTick(tick, roundingMethod);
  }
  getScaledPosition(position) {
    const {
      include,
      unit,
      weekStartDay
    } = this.timeAxis;
    if (include) {
      const dayWidth = this.getSingleUnitInPixels("day");
      if (include.day && DateHelper.compareUnits(unit, "day") > 0) {
        const {
          from,
          lengthFactor
        } = include.day, positionInWeek = position % (dayWidth * 7), weekStartPosition = position - positionInWeek;
        position = positionInWeek / lengthFactor + (from - weekStartDay) * dayWidth + weekStartPosition;
      }
      if (include.hour && DateHelper.compareUnits(unit, "hour") > 0 && unit !== "day") {
        const {
          from,
          lengthFactorExcl
        } = include.hour, hourWidth = this.getSingleUnitInPixels("hour"), positionInDay = position % dayWidth, dayStartPosition = position - positionInDay;
        position = positionInDay / lengthFactorExcl + from * hourWidth + dayStartPosition;
      }
    }
    return position;
  }
  getSingleUnitInPixels(unit) {
    const me = this;
    return me.unitToPixelsCache[unit] || (me.unitToPixelsCache[unit] = DateHelper.getUnitToBaseUnitRatio(me.timeAxis.unit, unit, true) * me.tickSize / me.timeAxis.increment);
  }
  get snapPixelAmount() {
    if (this.snap) {
      const {
        resolution
      } = this.timeAxis;
      return (resolution.increment || 1) * this.getSingleUnitInPixels(resolution.unit);
    }
    return 1;
  }
  get tickSize() {
    return this._tickSize;
  }
  set tickSize(size) {
    this.setTickSize(size, false);
  }
  setTickSize(size, suppressEvent) {
    this._tickSize = this.originalTickSize = size;
    this.update(void 0, suppressEvent);
  }
  get timeResolution() {
    return this.timeAxis.resolution;
  }
  calculateTickSize(proposedSize) {
    const me = this, {
      forceFit,
      timeAxis,
      suppressFit
    } = me, timelineUnit = timeAxis.unit;
    let size = 0, ratio = 1;
    if (me.snap) {
      const resolution = timeAxis.resolution;
      ratio = DateHelper.getUnitToBaseUnitRatio(timelineUnit, resolution.unit) * resolution.increment;
    }
    if (!suppressFit) {
      const fittingSize = me.availableSpace / timeAxis.visibleTickTimeSpan;
      size = forceFit || proposedSize < fittingSize ? fittingSize : proposedSize;
      if (ratio > 0 && (!forceFit || ratio < 1)) {
        size = Math.max(1, ratio * size) / ratio;
      }
    } else {
      size = proposedSize;
    }
    return size;
  }
  get totalSize() {
    return this._totalSize || (this._totalSize = Math.floor(this.tickSize * this.timeAxis.visibleTickTimeSpan));
  }
  get availableSpace() {
    return this._availableSpace;
  }
  set availableSpace(space) {
    const me = this;
    me._availableSpace = Math.max(0, space);
    if (me._availableSpace > 0) {
      const newTickSize = me.calculateTickSize(me.originalTickSize);
      if (newTickSize > 0 && newTickSize !== me.tickSize) {
        me.update();
      }
    }
  }
  getDates(level = this.columnLinesFor, useLowestHeader = false, getEnd = false) {
    const me = this, ticks = [], linesForLevel = useLowestHeader ? me.lowestHeader : level, majorLevel = me.majorHeaderLevel, levelUnit = me.headers && me.headers[level].unit, majorUnit = majorLevel != null && me.headers && me.headers[majorLevel].unit, validMajor = majorLevel != null && DateHelper.doesUnitsAlign(majorUnit, levelUnit), hasGenerator = !!(me.headers && me.headers[linesForLevel].cellGenerator);
    if (hasGenerator) {
      const cells = me.columnConfig[linesForLevel];
      for (let i = 1, l = cells.length; i < l; i++) {
        ticks.push({
          date: cells[i].startDate
        });
      }
    } else {
      me.forEachInterval(linesForLevel, (start, end) => {
        ticks.push({
          date: getEnd ? end : start,
          isMajor: majorLevel !== level && validMajor && me.isMajorTick(getEnd ? end : start)
        });
      });
    }
    return ticks;
  }
  get forceFit() {
    return this._forceFit;
  }
  fitToAvailableSpace(suppressEvent) {
    const proposedSize = Math.floor(this.availableSpace / this.timeAxis.visibleTickTimeSpan);
    this.setTickSize(proposedSize, suppressEvent);
  }
  get snap() {
    return this._snap;
  }
  set snap(value) {
    if (value !== this._snap) {
      this._snap = value;
      if (this.configured) {
        this.update();
      }
    }
  }
  createHeaderRow(position, headerRowConfig, headerCells) {
    const me = this, cells = [], {
      align,
      headerCellCls = ""
    } = headerRowConfig, today = DateHelper.clearTime(new Date()), {
      timeAxis
    } = me, tickLevel = me.headers.length - 1, createCellContext = (start, end, i, isLast, data) => {
      let value = DateHelper.format(start, headerRowConfig.dateFormat);
      const isInteriorTick = i > 0 && !isLast, cellData = {
        align,
        start,
        end,
        value: data ? data.header : value,
        headerCellCls,
        width: tickLevel === position && me.owner && (timeAxis.fullTicks || isInteriorTick) ? me.owner.tickSize : me.getDistanceBetweenDates(start, end),
        index: i
      };
      if (cellData.width === 0) {
        return;
      }
      cellData.coord = size - 1;
      size += cellData.width;
      me.headersDatesCache[position][start.getTime()] = 1;
      if (headerRowConfig.renderer) {
        value = headerRowConfig.renderer.call(headerRowConfig.thisObj || me, start, end, cellData, i);
        cellData.value = value == null ? "" : value;
      }
      if (headerRowConfig.unit === "day" && (!headerRowConfig.increment || headerRowConfig.increment === 1)) {
        cellData.headerCellCls += " b-sch-dayheadercell-" + start.getDay();
        if (DateHelper.clearTime(start, true) - today === 0) {
          cellData.headerCellCls += " b-sch-dayheadercell-today";
        }
      }
      cells.push(cellData);
    };
    let size = 0;
    me.headersDatesCache[position] = {};
    if (headerCells) {
      headerCells.forEach((cellData, i) => createCellContext(cellData.start, cellData.end, i, i === headerCells.length - 1, cellData));
    } else {
      me.forEachInterval(position, createCellContext);
    }
    return cells;
  }
  get mainHeader() {
    return "mainHeaderLevel" in this ? this.headers[this.mainHeaderLevel] : this.bottomHeader;
  }
  get bottomHeader() {
    return this.headers[this.headers.length - 1];
  }
  get lowestHeader() {
    return this.headers.length - 1;
  }
  get majorHeaderLevel() {
    const {
      headers
    } = this;
    if (headers) {
      return Math.max(headers.length - 2, 0);
    }
    return null;
  }
  isMajorTick(date2) {
    const nextLevel = this.majorHeaderLevel;
    return nextLevel != null && this.headersDatesCache[nextLevel] && this.headersDatesCache[nextLevel][date2.getTime()] || false;
  }
  forEachInterval(position, iteratorFn, thisObj = this) {
    const {
      headers,
      timeAxis
    } = this;
    if (headers) {
      if (position === headers.length - 1) {
        timeAxis.forEach((r, index) => iteratorFn.call(thisObj, r.startDate, r.endDate, index, index === timeAxis.count - 1));
      } else {
        const header = headers[position];
        timeAxis.forEachAuxInterval(header.unit, header.increment, iteratorFn, thisObj);
      }
    }
  }
  forEachMainInterval(iteratorFn, thisObj) {
    this.forEachInterval(this.mainHeaderLevel, iteratorFn, thisObj);
  }
  consumeViewPreset(preset) {
    const me = this;
    me.headers = null;
    me.getConfig("tickSize");
    me.viewPreset = preset;
    Object.assign(me, {
      headers: preset.headers,
      columnLinesFor: preset.columnLinesFor,
      mainHeaderLevel: preset.mainHeaderLevel,
      _tickSize: me.isHorizontal ? preset.tickWidth : preset.tickHeight
    });
    me.originalTickSize = me.tickSize;
  }
};
TimeAxisViewModel._$name = "TimeAxisViewModel";
var tempDate = new Date();
var TimelineDateMapper = (Target) => {
  var _class;
  return _class = class TimelineDateMapper extends (Target || Base$1) {
    getRtlX(x) {
      if (this.rtl && this.isHorizontal) {
        x = this.timeAxisViewModel.totalSize - x;
      }
      return x;
    }
    getDateFromCoordinate(coordinate, roundingMethod, local = true, allowOutOfRange = false, ignoreRTL = false) {
      if (!local) {
        coordinate = this.currentOrientation.translateToScheduleCoordinate(coordinate);
      }
      if (!ignoreRTL) {
        coordinate = this.getRtlX(coordinate);
      }
      return this.timeAxisViewModel.getDateFromPosition(coordinate, roundingMethod, allowOutOfRange);
    }
    getDateFromCoord(options) {
      return this.getDateFromCoordinate(options.coord, options.roundingMethod, options.local, options.allowOutOfRange, options.ignoreRTL);
    }
    getDateFromXY(xy, roundingMethod, local = true, allowOutOfRange = false) {
      return this.currentOrientation.getDateFromXY(xy, roundingMethod, local, allowOutOfRange);
    }
    getDateFromDomEvent(e, roundingMethod, allowOutOfRange = false) {
      return this.getDateFromXY([e.pageX, e.pageY], roundingMethod, false, allowOutOfRange);
    }
    getStartEndDatesFromRectangle(rect, roundingMethod, duration, allowOutOfRange = false) {
      const me = this, {
        isHorizontal
      } = me, startPos = isHorizontal ? rect.x : rect.top, endPos = isHorizontal ? rect.right : rect.bottom;
      let start, end;
      if (startPos >= 0 && endPos < me.timeAxisViewModel.totalSize) {
        start = me.getDateFromCoordinate(startPos, roundingMethod, true);
        end = me.getDateFromCoordinate(endPos, roundingMethod, true);
      } else if (startPos < 0) {
        end = me.getDateFromCoordinate(endPos, roundingMethod, true, allowOutOfRange);
        start = end && DateHelper.add(end, -duration, "ms");
      } else {
        start = me.getDateFromCoordinate(startPos, roundingMethod, true, allowOutOfRange);
        end = start && DateHelper.add(start, duration, "ms");
      }
      return {
        start,
        end
      };
    }
    get displayDateFormat() {
      return this._displayDateFormat;
    }
    set displayDateFormat(format2) {
      this._displayDateFormat = format2;
      this.trigger("displayDateFormatChange", {
        format: format2
      });
    }
    getFormattedDate(date2) {
      return DateHelper.format(date2, this.displayDateFormat);
    }
    getDisplayEndDate(endDate, startDate) {
      if (endDate.getHours() === 0 && endDate.getMinutes() === 0 && (!startDate || !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate())) && !DateHelper.formatContainsHourInfo(this.displayDateFormat)) {
        endDate = DateHelper.add(endDate, -1, "day");
      }
      return endDate;
    }
    getFormattedEndDate(endDate, startDate) {
      return this.getFormattedDate(this.getDisplayEndDate(endDate, startDate));
    }
    getCoordinateFromDate(date2, options = true) {
      const me = this, {
        timeAxisViewModel
      } = me, {
        isContinuous,
        startMS,
        endMS,
        startDate,
        endDate,
        unit
      } = me.timeAxis, dateMS = date2.valueOf();
      if (options === true) {
        options = {
          local: true
        };
      } else if (!options) {
        options = {
          local: false
        };
      } else if (!("local" in options)) {
        options.local = true;
      }
      let pos;
      if (!(date2 instanceof Date)) {
        tempDate.setTime(date2);
        date2 = tempDate;
      }
      if (isContinuous && date2.getTimezoneOffset() === startDate.getTimezoneOffset() && startDate.getTimezoneOffset() === endDate.getTimezoneOffset() && DateHelper.getUnitToBaseUnitRatio(unit, "day") !== -1) {
        if (dateMS < startMS || dateMS > endMS) {
          return -1;
        }
        pos = (dateMS - startMS) / (endMS - startMS) * timeAxisViewModel.totalSize;
      } else {
        pos = timeAxisViewModel.getPositionFromDate(date2, options);
      }
      if (me.rtl && me.isHorizontal) {
        pos = timeAxisViewModel.totalSize - pos;
      }
      if (!options.local) {
        pos = me.currentOrientation.translateToPageCoordinate(pos);
      }
      return pos;
    }
    getTimeSpanDistance(startDate, endDate) {
      return this.timeAxisViewModel.getDistanceBetweenDates(startDate, endDate);
    }
    get viewportCenterDate() {
      const {
        timeAxis,
        timelineScroller
      } = this;
      if (timeAxis.isContinuous) {
        const timeAxisOffset = (timelineScroller.position + timelineScroller.clientSize / 2) / timelineScroller.scrollSize;
        return new Date(timeAxis.startMS + (timeAxis.endMS - timeAxis.startMS) * timeAxisOffset);
      }
      return this.getDateFromCoordinate(timelineScroller.position + timelineScroller.clientSize / 2);
    }
    get viewportCenterDateCached() {
      return this.cachedCenterDate || (this.cachedCenterDate = this.viewportCenterDate);
    }
    get timeResolution() {
      return this.timeAxis.resolution;
    }
    set timeResolution(resolution) {
      this.timeAxis.resolution = typeof resolution === "number" ? {
        increment: resolution,
        unit: this.timeAxis.resolution.unit
      } : resolution;
    }
    get snap() {
      var _this$_timeAxisViewMo, _this$_timeAxisViewMo2;
      return (_this$_timeAxisViewMo = (_this$_timeAxisViewMo2 = this._timeAxisViewModel) === null || _this$_timeAxisViewMo2 === void 0 ? void 0 : _this$_timeAxisViewMo2.snap) !== null && _this$_timeAxisViewMo !== void 0 ? _this$_timeAxisViewMo : this._snap;
    }
    updateSnap(snap) {
      if (!this.isConfiguring) {
        this.timeAxisViewModel.snap = snap;
        this.timeAxis.forceFullTicks = snap && this.fillTicks;
      }
    }
    onSchedulerHorizontalScroll({
      subGrid,
      scrollLeft,
      scrollX
    }) {
      if (!this.scrollingToCenter) {
        this.cachedCenterDate = null;
      }
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "$name", "TimelineDateMapper"), _defineProperty(_class, "configurable", {
    snap: false
  }), _class;
};
var {
  eventNameMap: eventNameMap$2
} = EventHelper;
var TimelineDomEvents = (Target) => {
  var _class;
  return _class = class TimelineDomEvents extends (Target || Base$1) {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "hoveredEvents", /* @__PURE__ */ new Set());
    }
    initDomEvents() {
      const me = this, {
        schedulerEvents,
        schedulerEnterLeaveEvents
      } = me;
      schedulerEvents.element = schedulerEnterLeaveEvents.element = me.timeAxisSubGridElement;
      schedulerEvents.thisObj = schedulerEnterLeaveEvents.thisObj = me;
      EventHelper.on(schedulerEvents);
      EventHelper.on(schedulerEnterLeaveEvents);
      if (BrowserHelper.supportsPointerEventConstructor) {
        EventHelper.on({
          element: document,
          scroll: "onScheduleScroll",
          capture: true,
          thisObj: me
        });
      }
    }
    getTimeSpanMouseEventParams(eventElement, event) {
      throw new Error("Implement in subclass");
    }
    getScheduleMouseEventParams(cellData, event) {
      throw new Error("Implement in subclass");
    }
    handleScheduleEvent(event) {
      const me = this, timelineContext = me.getTimelineEventContext(event);
      me.lastPointerEvent = event;
      if (timelineContext) {
        me.trigger(`${timelineContext.eventElement ? me.scheduledEventName : "schedule"}${eventNameMap$2[event.type] || StringHelper.capitalize(event.type)}`, timelineContext);
      }
      me.timelineContext = timelineContext;
    }
    handleScheduleEnterLeaveEvent(event) {
      if (event.target.parentElement === this.foregroundCanvas) {
        this.handleScheduleEvent(event);
      }
    }
    onScheduleScroll({
      target
    }) {
      var _me$features$pan;
      const me = this;
      if (target && me.updateTimelineContextOnScroll && !((_me$features$pan = me.features.pan) !== null && _me$features$pan !== void 0 && _me$features$pan.isActive) && !me.partners.some((p) => {
        var _p$features$pan;
        return (_p$features$pan = p.features.pan) === null || _p$features$pan === void 0 ? void 0 : _p$features$pan.isActive;
      }) && (target.contains(me.element) || me.bodyElement.contains(target))) {
        const {
          timelineContext,
          lastPointerEvent
        } = me;
        if (timelineContext) {
          const targetElement = DomHelper.elementFromPoint(timelineContext.domEvent.clientX, timelineContext.domEvent.clientY), pointerEvent = new PointerEvent("pointermove", lastPointerEvent), mouseEvent = new MouseEvent("mousemove", lastPointerEvent);
          pointerEvent.scrollInitiated = mouseEvent.scrollInitiated = true;
          targetElement === null || targetElement === void 0 ? void 0 : targetElement.dispatchEvent(pointerEvent);
          targetElement === null || targetElement === void 0 ? void 0 : targetElement.dispatchEvent(mouseEvent);
        }
      }
    }
    updateTimelineContext(context, oldContext) {
      this.trigger("timelineContextChange", {
        oldContext,
        context
      });
      if (!context) {
        this.trigger("scheduleMouseLeave");
      }
    }
    getTimelineEventContext(domEvent) {
      const me = this, eventElement = domEvent.target.closest(me.eventInnerSelector), cellElement = me.getCellElementFromDomEvent(domEvent);
      if (cellElement) {
        const clickedDate = me.getDateFromDomEvent(domEvent, "floor");
        if (!clickedDate) {
          return;
        }
        const cellData = DomDataStore.get(cellElement), mouseParams = eventElement ? me.getTimeSpanMouseEventParams(eventElement, domEvent) : me.getScheduleMouseEventParams(cellData, domEvent);
        if (!mouseParams) {
          return;
        }
        const index = me.isVertical ? me.resourceStore.indexOf(mouseParams.resourceRecord) : cellData.row.dataIndex, tickIndex = me.timeAxis.getTickFromDate(clickedDate), tick = me.timeAxis.getAt(Math.floor(tickIndex));
        if (tick) {
          return _objectSpread2({
            isTimelineContext: true,
            domEvent,
            eventElement,
            cellElement,
            index,
            tick,
            tickIndex,
            date: clickedDate,
            tickStartDate: tick.startDate,
            tickEndDate: tick.endDate,
            tickParentIndex: tick.parentIndex,
            row: cellData.row,
            event: domEvent
          }, mouseParams);
        }
      }
    }
    getCellElementFromDomEvent({
      target,
      clientY,
      type
    }) {
      const me = this, {
        isVertical,
        foregroundCanvas
      } = me, eventElement = target.closest(me.eventSelector);
      if (eventElement) {
        return me.getCell({
          [isVertical ? "row" : "record"]: isVertical ? 0 : me.resolveRowRecord(eventElement),
          column: me.timeAxisColumn
        });
      } else if (foregroundCanvas.contains(target)) {
        if (target === foregroundCanvas || type === "mousemove") {
          var _me$rowManager$getRow;
          return (_me$rowManager$getRow = me.rowManager.getRowAt(clientY, false)) === null || _me$rowManager$getRow === void 0 ? void 0 : _me$rowManager$getRow.getCell(me.timeAxisColumn.id);
        }
      } else {
        return target.matches(".b-grid-row") ? target.firstElementChild : target.closest(me.timeCellSelector);
      }
    }
    matchScheduleCell(element) {
      return element.closest(this.timeCellSelector);
    }
    onElementMouseButtonEvent(event) {
      const target = event.target.closest(".b-sch-header-timeaxis-cell");
      if (target) {
        const index = target.dataset.tickIndex, position = target.parentElement.dataset.headerPosition, columnConfig = this.timeAxisViewModel.columnConfig[position][index], contextMenu = this.features.contextMenu;
        if (!contextMenu || event.type !== contextMenu.triggerEvent) {
          this.trigger(`timeAxisHeader${StringHelper.capitalize(event.type)}`, {
            startDate: columnConfig.start,
            endDate: columnConfig.end,
            event
          });
        }
      }
    }
    onElementMouseDown(event) {
      this.onElementMouseButtonEvent(event);
      super.onElementMouseDown(event);
    }
    onElementClick(event) {
      this.onElementMouseButtonEvent(event);
      super.onElementClick(event);
    }
    onElementDblClick(event) {
      this.onElementMouseButtonEvent(event);
      super.onElementDblClick(event);
    }
    onElementContextMenu(event) {
      this.onElementMouseButtonEvent(event);
      super.onElementContextMenu(event);
    }
    onElementMouseOver(event) {
      var _me$features$eventDra;
      super.onElementMouseOver(event);
      const me = this, {
        target
      } = event, {
        hoveredEvents
      } = me;
      if (target.closest(me.eventInnerSelector) && !((_me$features$eventDra = me.features.eventDrag) !== null && _me$features$eventDra !== void 0 && _me$features$eventDra.isDragging)) {
        const eventElement = target.closest(me.eventSelector);
        if (!hoveredEvents.has(eventElement) && !me.preventOverCls) {
          hoveredEvents.add(eventElement);
          eventElement.classList.add(me.overScheduledEventClass);
          const params = me.getTimeSpanMouseEventParams(eventElement, event);
          if (params) {
            me.trigger(`${me.scheduledEventName}MouseEnter`, params);
          }
        }
      } else if (hoveredEvents.size) {
        me.unhoverAll(event);
      }
    }
    onElementMouseOut(event) {
      var _me$features$eventDra2;
      super.onElementMouseOut(event);
      const me = this, {
        target,
        relatedTarget
      } = event, eventInner = target.closest(me.eventInnerSelector), eventWrap = target.closest(me.eventSelector), timeSpanRecord = me.resolveTimeSpanRecord(target);
      if (eventInner && timeSpanRecord && me.hoveredEvents.has(eventWrap) && !((_me$features$eventDra2 = me.features.eventDrag) !== null && _me$features$eventDra2 !== void 0 && _me$features$eventDra2.isDragging)) {
        if (relatedTarget && DomHelper.isDescendant(eventInner, relatedTarget)) {
          return;
        }
        me.unhover(eventWrap, event);
      }
    }
    unhover(element, event) {
      const me = this;
      element.classList.remove(me.overScheduledEventClass);
      me.trigger(`${me.scheduledEventName}MouseLeave`, me.getTimeSpanMouseEventParams(element, event));
      me.hoveredEvents.delete(element);
    }
    unhoverAll(event) {
      for (const element of this.hoveredEvents) {
        !element.isReleased && !element.classList.contains("b-released") && this.unhover(element, event);
      }
      this.hoveredEvents.clear();
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "$name", "TimelineDomEvents"), _defineProperty(_class, "configurable", {
    timelineContext: {
      $config: {
        equal(c1, c2) {
          return (c1 === null || c1 === void 0 ? void 0 : c1.index) === (c2 === null || c2 === void 0 ? void 0 : c2.index) && (c1 === null || c1 === void 0 ? void 0 : c1.tickParentIndex) === (c2 === null || c2 === void 0 ? void 0 : c2.tickParentIndex) && !(((c1 === null || c1 === void 0 ? void 0 : c1.tickStartDate) || 0) - ((c2 === null || c2 === void 0 ? void 0 : c2.tickStartDate) || 0));
        }
      }
    },
    updateTimelineContextOnScroll: true
  }), _defineProperty(_class, "properties", {
    schedulerEvents: {
      mouseover: "handleScheduleEvent",
      mousedown: "handleScheduleEvent",
      mouseup: "handleScheduleEvent",
      click: "handleScheduleEvent",
      dblclick: "handleScheduleEvent",
      contextmenu: "handleScheduleEvent",
      mousemove: "handleScheduleEvent",
      mouseout: "handleScheduleEvent"
    },
    schedulerEnterLeaveEvents: {
      mouseenter: "handleScheduleEnterLeaveEvent",
      mouseleave: "handleScheduleEnterLeaveEvent",
      capture: true
    }
  }), _defineProperty(_class, "delayable", {
    onScheduleScroll: "raf"
  }), _class;
};
var datesDiffer = (d1 = 0, d2 = 0) => d2 - d1;
var TimelineViewPresets = (Target) => class TimelineViewPresets extends (Target || Base$1) {
  static get $name() {
    return "TimelineViewPresets";
  }
  static get configurable() {
    return {
      viewPreset: "weekAndDayLetter",
      presets: true,
      displayDateFormat: null
    };
  }
  changePresets(presets) {
    const config = {
      owner: this
    };
    let data = [];
    if (presets === true) {
      data = pm.allRecords;
    } else if (Array.isArray(presets)) {
      for (const preset of presets) {
        if (typeof preset === "string") {
          const presetRecord = pm.getById(preset);
          if (presetRecord) {
            data.push(presetRecord);
          }
        } else {
          data.push(preset);
        }
      }
    } else {
      ObjectHelper.assign(config, presets);
    }
    const presetStore = new PresetStore(config);
    presetStore.add(data);
    return presetStore;
  }
  changeViewPreset(viewPreset, oldViewPreset) {
    const me = this, {
      presets
    } = me;
    if (viewPreset) {
      viewPreset = presets.createRecord(viewPreset);
      presets.add(viewPreset);
    } else {
      viewPreset = presets.first;
    }
    const lastOpts = me.lastViewPresetOptions || {}, options = viewPreset.options || (viewPreset.options = {}), event = options.event = {
      startDate: options.startDate,
      endDate: options.endDate,
      from: oldViewPreset,
      to: viewPreset,
      preset: viewPreset
    }, presetChanged = !me._viewPreset || !me._viewPreset.equals(viewPreset), optionsChanged = datesDiffer(options.startDate, lastOpts.startDate) || datesDiffer(options.endDate, lastOpts.endDate) || datesDiffer(options.centerDate, lastOpts.centerDate) || options.startDate && datesDiffer(options.startDate, me.startDate) || options.endDate && datesDiffer(options.endDate, me.endDate);
    if (presetChanged || optionsChanged) {
      if (!presetChanged) {
        me._viewPreset = null;
      }
      if (me.isConfiguring || me.trigger("beforePresetChange", event) !== false) {
        return viewPreset;
      }
    }
  }
  get displayDateFormat() {
    return this._displayDateFormat || this.viewPreset.displayDateFormat;
  }
  updateViewPreset(preset) {
    const me = this, {
      options
    } = preset, {
      event,
      startDate,
      endDate
    } = options, {
      isHorizontal,
      _timeAxis: timeAxis,
      _timeAxisViewModel: timeAxisViewModel
    } = me;
    let {
      centerDate,
      zoomDate,
      zoomPosition
    } = options, forceUpdate = false;
    me._viewPresetChanging = true;
    if (timeAxis && !me.isConfiguring) {
      me.lastViewPresetOptions = options;
      if (timeAxis.isConfigured) {
        me.suspendRefresh();
        const timeAxisCfg = ObjectHelper.copyProperties({}, me, ["weekStartDay", "startTime", "endTime"]);
        if (me.infiniteScroll) {
          Object.assign(timeAxisCfg, timeAxisViewModel.calculateInfiniteScrollingDateRange(centerDate || new Date((startDate.getTime() + endDate.getTime()) / 2), true, preset));
        } else if (startDate) {
          timeAxisCfg.startDate = startDate;
          timeAxisCfg.endDate = endDate;
          if (!centerDate && endDate) {
            centerDate = new Date((startDate.getTime() + endDate.getTime()) / 2);
          }
        } else {
          timeAxisCfg.startDate = timeAxis.startDate;
          timeAxisCfg.endDate = endDate || timeAxis.endDate;
          if (!centerDate) {
            centerDate = me.viewportCenterDate;
          }
        }
        timeAxis.isConfigured = false;
        timeAxis.viewPreset = preset;
        timeAxis.reconfigure(timeAxisCfg, true);
        timeAxisViewModel.reconfigure({
          viewPreset: preset,
          headers: preset.headers,
          columnLinesFor: preset.columnLinesFor != null ? preset.columnLinesFor : preset.headers.length - 1,
          tickSize: isHorizontal ? preset.tickWidth : preset.tickHeight || preset.tickWidth || 60
        });
        me.resumeRefresh(false);
      }
      me.refresh();
      if (!options.notScroll && me.isPainted) {
        if (zoomDate && zoomPosition) {
          const unitMagnitude = unitMagnitudes[timeAxis.resolutionUnit], unit = unitMagnitude > 3 ? "hour" : "minute", milliseconds2 = DateHelper.asMilliseconds(unit === "minute" ? 15 : 1, unit), targetDate = new Date(Math.round(zoomDate / milliseconds2) * milliseconds2);
          event.zoomDate = zoomDate;
          event.zoomPosition = zoomPosition;
          event.zoomLevel = options.zoomLevel;
          me.timelineScroller.scrollBy(me.getCoordinateFromDate(targetDate) - zoomPosition);
        } else if (centerDate) {
          me.cachedCenterDate = centerDate;
          event.centerDate = centerDate;
          const viewportSize = me.timelineScroller.clientSize, coord = Math.max(me.getCoordinateFromDate(centerDate, true) - viewportSize / 2, 0);
          me.scrollingToCenter = true;
          if (coord === (me.isHorizontal ? me.scrollLeft : me.scrollTop)) {
            forceUpdate = true;
          } else if (me.isHorizontal) {
            me.scrollHorizontallyTo(coord, false);
          } else {
            me.scrollVerticallyTo(coord, false);
          }
          me.setTimeout(() => {
            me.scrollingToCenter = false;
          }, 100);
        } else {
          if ((me.isHorizontal ? me.scrollLeft : me.scrollTop) === 0) {
            forceUpdate = true;
          } else {
            me.timelineScroller.scrollTo(0);
          }
        }
      }
    }
    me.dataset.presetId = preset.id;
    me.trigger("presetChange", event);
    me._viewPresetChanging = false;
    if (forceUpdate) {
      if (me.isHorizontal) {
        me.currentOrientation.updateFromHorizontalScroll(me.scrollLeft, me.scrollX);
      } else {
        me.currentOrientation.updateFromVerticalScroll(me.scrollTop);
      }
    }
  }
  doDestroy() {
    if (this._presets.owner === this) {
      this._presets.destroy();
    }
    super.doDestroy();
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    if (result.viewPreset && result.viewPreset.name && !result.viewPreset.base) {
      delete result.viewPreset.name;
    }
    return result;
  }
  get widgetClass() {
  }
};
var TimelineZoomable = (Target) => class TimelineZoomable extends (Target || Base$1) {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "lastWheelTime", -1);
    _defineProperty(this, "lastZoomPosition", -1);
  }
  static get $name() {
    return "TimelineZoomable";
  }
  static get defaultConfig() {
    return {
      zoomOnMouseWheel: true,
      zoomOnTimeAxisDoubleClick: true,
      minZoomLevel: 0,
      maxZoomLevel: null,
      visibleZoomFactor: 5,
      zoomKeepsOriginalTimespan: null
    };
  }
  construct(config) {
    const me = this;
    super.construct(config);
    if (me.zoomOnMouseWheel) {
      EventHelper.on({
        element: me.timeAxisSubGridElement,
        wheel: "onWheel",
        throttled: {
          buffer: 100,
          alt: (e) => e.ctrlKey && e.preventDefault()
        },
        thisObj: me,
        capture: true,
        passive: false
      });
    }
    if (me.zoomOnTimeAxisDoubleClick) {
      me.ion({
        timeaxisheaderdblclick: ({
          startDate,
          endDate
        }) => {
          me.zoomToSpan({
            startDate,
            endDate
          });
        }
      });
    }
  }
  get maxZoomLevel() {
    return this._maxZoomLevel || this.presets.count - 1;
  }
  set maxZoomLevel(level) {
    if (typeof level !== "number") {
      level = this.presets.count - 1;
    }
    if (level < 0 || level >= this.presets.count) {
      throw new Error("Invalid range for `maxZoomLevel`");
    }
    this._maxZoomLevel = level;
  }
  get minZoomLevel() {
    return this._minZoomLevel;
  }
  set minZoomLevel(level) {
    if (typeof level !== "number") {
      level = 0;
    }
    if (level < 0 || level >= this.presets.count) {
      throw new Error("Invalid range for `minZoomLevel`");
    }
    this._minZoomLevel = level;
  }
  get zoomLevel() {
    return this.presets.indexOf(this.viewPreset);
  }
  set zoomLevel(level) {
    this.zoomToLevel(level);
  }
  getMilliSecondsPerPixelForZoomLevel(preset, ignoreActualWidth) {
    const {
      bottomHeader
    } = preset, width = this.isHorizontal ? preset.tickWidth : preset.tickHeight;
    return Math.round((DateHelper.add(new Date(1, 0, 1), bottomHeader.increment || 1, bottomHeader.unit) - new Date(1, 0, 1)) / (ignoreActualWidth ? width : preset.actualWidth || width));
  }
  zoomTo(config) {
    const me = this;
    if (typeof config === "object") {
      if (config.preset) {
        me.zoomToLevel(config.preset, config);
      } else if (config.level != null) {
        me.zoomToLevel(config.level, config);
      } else {
        me.zoomToSpan(config);
      }
    } else {
      me.zoomToLevel(config);
    }
  }
  zoomToLevel(preset, options = {}) {
    if (typeof preset === "number") {
      preset = Math.min(Math.max(preset, this.minZoomLevel), this.maxZoomLevel);
    }
    const me = this, {
      presets
    } = me, tickSizeProp = me.isVertical ? "tickHeight" : "tickWidth", newPreset = presets.createRecord(preset), configuredTickSize = newPreset[tickSizeProp], startDate = options.startDate ? new Date(options.startDate) : null, endDate = options.endDate ? new Date(options.endDate) : null;
    presets.add(newPreset);
    let span = startDate && endDate ? {
      startDate,
      endDate
    } : null;
    const centerDate = options.centerDate ? new Date(options.centerDate) : span ? new Date((startDate.getTime() + endDate.getTime()) / 2) : me.viewportCenterDateCached, scrollableViewportSize = me.isVertical ? me.scrollable.clientHeight : me.timeAxisSubGrid.width;
    if (scrollableViewportSize === 0) {
      return null;
    }
    if (!span) {
      span = me.calculateOptimalDateRange(centerDate, scrollableViewportSize, newPreset);
    }
    if ("width" in options) {
      newPreset.setData(tickSizeProp, options.width);
    }
    me.isZooming = true;
    newPreset.options = _objectSpread2(_objectSpread2({}, options), {}, {
      startDate: span.startDate || me.startDate,
      endDate: span.endDate || me.endDate,
      centerDate
    });
    me.viewPreset = newPreset;
    newPreset.actualWidth = me.timeAxisViewModel.tickSize;
    me.isZooming = false;
    newPreset.setData(tickSizeProp, configuredTickSize);
    return me.zoomLevel;
  }
  zoomToFit(options) {
    const eventStore = this.eventStore, span = eventStore.getTotalTimeSpan();
    options = _objectSpread2(_objectSpread2({
      leftMargin: 0,
      rightMargin: 0
    }, options), span);
    if (options.startDate && options.endDate) {
      if (options.endDate > options.startDate) {
        this.zoomToSpan(options);
      } else {
        this.scrollToDate(options.startDate);
      }
    }
  }
  zoomToSpan(config = {}) {
    if (config.leftMargin || config.rightMargin) {
      config.adjustStart = 0;
      config.adjustEnd = 0;
    }
    if (!config.leftMargin)
      config.leftMargin = 0;
    if (!config.rightMargin)
      config.rightMargin = 0;
    if (!config.startDate || !config.endDate)
      throw new Error("zoomToSpan: must provide startDate + endDate dates");
    const me = this, {
      timeAxis
    } = me, needToAdjust = config.adjustStart >= 0 || config.adjustEnd >= 0;
    let {
      startDate,
      endDate
    } = config;
    if (needToAdjust) {
      startDate = DateHelper.add(startDate, -config.adjustStart, timeAxis.mainUnit);
      endDate = DateHelper.add(endDate, config.adjustEnd, timeAxis.mainUnit);
    }
    if (startDate <= endDate) {
      const {
        availableSpace
      } = me.timeAxisViewModel, presets = me.presets.allRecords, diffMS = endDate - startDate || 1;
      let currLevel = me.zoomLevel, inc, range;
      if (currLevel === -1)
        currLevel = 0;
      let msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(presets[currLevel], true), candidateLevel = currLevel + (inc = diffMS / msPerPixel + config.leftMargin + config.rightMargin > availableSpace ? -1 : 1), zoomLevel, levelToZoom = null;
      while (candidateLevel >= 0 && candidateLevel <= presets.length - 1) {
        zoomLevel = presets[candidateLevel];
        msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);
        const spanWidth = diffMS / msPerPixel + config.leftMargin + config.rightMargin;
        if (inc === -1) {
          if (spanWidth <= availableSpace) {
            levelToZoom = candidateLevel;
            break;
          }
        } else {
          if (spanWidth <= availableSpace) {
            if (currLevel !== candidateLevel - inc) {
              levelToZoom = candidateLevel;
            }
          } else {
            break;
          }
        }
        candidateLevel += inc;
      }
      levelToZoom = levelToZoom != null ? levelToZoom : candidateLevel - inc;
      zoomLevel = presets[levelToZoom];
      const unitToZoom = zoomLevel.bottomHeader.unit;
      msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);
      if (config.leftMargin || config.rightMargin) {
        startDate = new Date(startDate.getTime() - msPerPixel * config.leftMargin);
        endDate = new Date(endDate.getTime() + msPerPixel * config.rightMargin);
      }
      const tickCount = DateHelper.getDurationInUnit(startDate, endDate, unitToZoom, true) / zoomLevel.bottomHeader.increment;
      if (tickCount === 0) {
        return null;
      }
      const customWidth = Math.floor(availableSpace / tickCount), centerDate = config.centerDate || new Date((startDate.getTime() + endDate.getTime()) / 2);
      if (needToAdjust) {
        range = {
          startDate,
          endDate
        };
      } else {
        range = me.calculateOptimalDateRange(centerDate, availableSpace, zoomLevel);
      }
      let result = me.zoomLevel;
      if (me.zoomLevel === levelToZoom) {
        timeAxis.reconfigure(range);
      } else {
        result = me.zoomToLevel(levelToZoom, Object.assign(range, {
          width: customWidth,
          centerDate
        }));
      }
      if (me.infiniteScroll) {
        me.scrollToDate(startDate, {
          block: "start"
        });
      }
      return result;
    }
    return null;
  }
  zoomIn(levels = 1, options) {
    const currentZoomLevelIndex = this.zoomLevel;
    if (currentZoomLevelIndex >= this.maxZoomLevel) {
      return null;
    }
    return this.zoomToLevel(currentZoomLevelIndex + levels, options);
  }
  zoomOut(levels = 1, options) {
    const currentZoomLevelIndex = this.zoomLevel;
    if (currentZoomLevelIndex <= this.minZoomLevel) {
      return null;
    }
    return this.zoomToLevel(currentZoomLevelIndex - levels, options);
  }
  zoomInFull() {
    return this.zoomToLevel(this.maxZoomLevel);
  }
  zoomOutFull() {
    return this.zoomToLevel(this.minZoomLevel);
  }
  calculateOptimalDateRange(centerDate, viewportSize, viewPreset, userProvidedSpan) {
    if (userProvidedSpan)
      return userProvidedSpan;
    const me = this, {
      timeAxis
    } = me, {
      bottomHeader
    } = viewPreset, tickWidth = me.isHorizontal ? viewPreset.tickWidth : viewPreset.tickHeight;
    if (me.zoomKeepsOriginalTimespan) {
      return {
        startDate: timeAxis.startDate,
        endDate: timeAxis.endDate
      };
    }
    const unit = bottomHeader.unit, difference = Math.ceil(viewportSize / tickWidth * bottomHeader.increment * me.visibleZoomFactor / 2), startDate = DateHelper.add(centerDate, -difference, unit), endDate = DateHelper.add(centerDate, difference, unit);
    if (me.infiniteScroll) {
      return me.timeAxisViewModel.calculateInfiniteScrollingDateRange(centerDate, true);
    } else {
      return {
        startDate: timeAxis.floorDate(startDate, false, unit, bottomHeader.increment),
        endDate: timeAxis.ceilDate(endDate, false, unit, bottomHeader.increment)
      };
    }
  }
  onElementMouseMove(event) {
    const {
      isHorizontal,
      zoomContext
    } = this;
    super.onElementMouseMove(event);
    if (event.isTrusted && zoomContext) {
      if (Math.abs(event[`client${isHorizontal ? "X" : "Y"}`] - zoomContext.coordinate) > 10) {
        this.zoomContext = null;
      }
    }
  }
  async onWheel(event) {
    if (event.ctrlKey) {
      event.preventDefault();
      const me = this, {
        zoomContext,
        isHorizontal,
        timelineScroller,
        zoomLevel
      } = me, now2 = performance.now(), coordinate = event[`client${isHorizontal ? "X" : "Y"}`], zoomPosition = coordinate - timelineScroller.viewport[`${isHorizontal ? "x" : "y"}`] + timelineScroller.position;
      if (now2 - me.lastWheelTime > 200 || !zoomContext || Math.abs(coordinate - me.zoomContext.coordinate) > 20) {
        me.zoomContext = {
          zoomLevel,
          coordinate,
          zoomPosition,
          zoomDate: me.getDateFromDomEvent(event)
        };
      } else {
        if (zoomLevel > zoomContext.zoomLevel) {
          zoomContext.zoomDate = me.getDateFromDomEvent(event);
          zoomContext.zoomLevel = zoomLevel;
        }
        zoomContext.zoomPosition = zoomPosition;
      }
      me.lastWheelTime = now2;
      me[`zoom${event.deltaY > 0 ? "Out" : "In"}`](void 0, me.zoomContext);
    }
  }
  setTimeSpan(startDate, endDate) {
    this.timeAxis.setTimeSpan(startDate, endDate);
  }
  shift(amount, unit) {
    this.timeAxis.shift(amount, unit);
  }
  shiftNext(amount) {
    this.timeAxis.shiftNext(amount);
  }
  shiftPrevious(amount) {
    this.timeAxis.shiftPrevious(amount);
  }
  get widgetClass() {
  }
};
var RecurringEvents = (Target) => {
  var _class;
  return _class = class RecurringEvents extends (Target || Base$1) {
    construct(config) {
      super.construct(config);
      this.ion({
        beforeEventDropFinalize: "onRecurrableBeforeEventDropFinalize",
        beforeEventResizeFinalize: "onRecurrableBeforeEventResizeFinalize",
        beforeAssignmentDelete: "onRecurrableAssignmentBeforeDelete"
      });
    }
    changeRecurrenceConfirmationPopup(recurrenceConfirmationPopup, oldRecurrenceConfirmationPopup) {
      const result = this.constructor.reconfigure(oldRecurrenceConfirmationPopup, recurrenceConfirmationPopup, "recurrenceconfirmation");
      result.owner = this;
      return result;
    }
    findRecurringEventToConfirmDelete(eventRecords) {
      return eventRecords.find((eventRecord) => eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence));
    }
    onRecurrableAssignmentBeforeDelete({
      assignmentRecords,
      context
    }) {
      const eventRecords = assignmentRecords.map((as) => as.event), eventRecord = this.findRecurringEventToConfirmDelete(eventRecords);
      if (this.enableRecurringEvents && eventRecord) {
        this.recurrenceConfirmationPopup.confirm({
          actionType: "delete",
          eventRecord,
          changerFn() {
            context.finalize(true);
          },
          cancelFn() {
            context.finalize(false);
          }
        });
        return false;
      }
    }
    onRecurrableBeforeEventDropFinalize({
      context
    }) {
      if (this.enableRecurringEvents) {
        const {
          eventRecords
        } = context, recurringEvents = eventRecords.filter((eventRecord) => eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence));
        if (recurringEvents.length) {
          context.async = true;
          this.recurrenceConfirmationPopup.confirm({
            actionType: "update",
            eventRecord: recurringEvents[0],
            changerFn() {
              context.finalize(true);
            },
            cancelFn() {
              context.finalize(false);
            }
          });
        }
      }
    }
    onRecurrableBeforeEventResizeFinalize({
      context
    }) {
      if (this.enableRecurringEvents) {
        const {
          eventRecord
        } = context, isRecurring = eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence);
        if (isRecurring) {
          context.async = true;
          this.recurrenceConfirmationPopup.confirm({
            actionType: "update",
            eventRecord,
            changerFn() {
              context.finalize(true);
            },
            cancelFn() {
              context.finalize(false);
            }
          });
        }
      }
    }
    onAssignmentChange({
      action,
      records: assignments
    }) {
      if (action !== "dataset" && Array.isArray(assignments)) {
        for (const assignment of assignments) {
          var _assignment$event;
          if ((_assignment$event = assignment.event) !== null && _assignment$event !== void 0 && _assignment$event.isRecurring && !assignment.event.isBatchUpdating) {
            assignment.event.removeOccurrences();
          }
        }
      }
    }
    getOccurrencesFor(recurringEvent) {
      return this.eventStore.getOccurrencesForTimeSpan(recurringEvent, this.timeAxis.startDate, this.timeAxis.endDate);
    }
    async removeEvents(eventRecords, callback = null, popupOwner = this) {
      const me = this;
      if (!me.readOnly && eventRecords.length) {
        const context = {
          finalize(removeRecord = true) {
            if (callback) {
              callback(removeRecord);
            }
            if (removeRecord !== false) {
              if (eventRecords.some((record) => {
                var _record$event;
                return record.isOccurrence || ((_record$event = record.event) === null || _record$event === void 0 ? void 0 : _record$event.isOccurrence);
              })) {
                eventRecords.forEach((record) => record.isOccurrenceAssignment ? record.event.remove() : record.remove());
              } else {
                const store = eventRecords[0].isAssignment ? me.assignmentStore : me.eventStore;
                store.remove(eventRecords);
              }
            }
          }
        };
        let shouldFinalize;
        if (eventRecords[0].isAssignment) {
          shouldFinalize = me.trigger("beforeAssignmentDelete", {
            assignmentRecords: eventRecords,
            context
          });
        } else {
          shouldFinalize = me.trigger("beforeEventDelete", {
            eventRecords,
            context
          });
        }
        if (shouldFinalize !== false) {
          const recurringEventRecord = eventRecords.find((eventRecord) => eventRecord.isRecurring || eventRecord.isOccurrence);
          if (recurringEventRecord) {
            me.recurrenceConfirmationPopup.owner = popupOwner;
            me.recurrenceConfirmationPopup.confirm({
              actionType: "delete",
              eventRecord: recurringEventRecord,
              changerFn() {
                context.finalize(true);
              },
              cancelFn() {
                context.finalize(false);
              }
            });
          } else {
            context.finalize(true);
          }
          return true;
        }
      }
      return false;
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "$name", "RecurringEvents"), _defineProperty(_class, "configurable", {
    enableRecurringEvents: false,
    recurrenceConfirmationPopup: {
      $config: ["lazy"],
      value: {
        type: "recurrenceconfirmation"
      }
    }
  }), _class;
};
var TimelineEventRendering = (Target) => {
  var _class;
  return _class = class TimelineEventRendering extends (Target || Base$1) {
    static get $name() {
      return "TimelineEventRendering";
    }
    static get defaultConfig() {
      return {
        resourceMargin: null,
        managedEventSizing: true,
        generatedIdCls: "b-sch-dirty-new",
        dirtyCls: "b-sch-dirty",
        committingCls: "b-sch-committing",
        endsOutsideViewCls: "b-sch-event-endsoutside",
        startsOutsideViewCls: "b-sch-event-startsoutside",
        fixedEventCls: "b-sch-event-fixed",
        eventStyle: "plain",
        eventColor: "green",
        tickSize: null
      };
    }
    updateFillTicks(fillTicks) {
      if (!this.isConfiguring) {
        this.timeAxis.forceFullTicks = fillTicks && this.snap;
        this.refreshWithTransition();
        this.trigger("stateChange");
      }
    }
    changeBarMargin(margin) {
      ObjectHelper.assertNumber(margin, "barMargin");
      if (this.isHorizontal && this.rowHeight) {
        return Math.min(Math.ceil(this.rowHeight / 2), margin);
      }
      return margin;
    }
    updateBarMargin() {
      if (this.rendered) {
        this.currentOrientation.onBeforeRowHeightChange();
        this.refreshWithTransition();
        this.trigger("stateChange");
      }
    }
    get resourceMargin() {
      return this._resourceMargin == null ? this.barMargin : this._resourceMargin;
    }
    set resourceMargin(margin) {
      const me = this;
      ObjectHelper.assertNumber(margin, "resourceMargin");
      if (me.isHorizontal && me.rowHeight) {
        margin = Math.min(Math.ceil(me.rowHeight / 2), margin);
      }
      if (me._resourceMargin !== margin) {
        me._resourceMargin = margin;
        if (me.rendered) {
          me.currentOrientation.onBeforeRowHeightChange();
          me.refreshWithTransition();
        }
      }
    }
    set tickSize(width) {
      ObjectHelper.assertNumber(width, "tickSize");
      this.timeAxisViewModel.tickSize = width;
    }
    get tickSize() {
      return this.timeAxisViewModel.tickSize;
    }
    static get eventColors() {
      return ["red", "pink", "purple", "violet", "indigo", "blue", "cyan", "teal", "green", "lime", "yellow", "orange", "deep-orange", "gray"];
    }
    static get eventStyles() {
      return ["plain", "border", "hollow", "colored", "line", "dashed", "minimal", "rounded"];
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "configurable", {
    barMargin: 10,
    fillTicks: false
  }), _class;
};
var maintainVisibleStart = {
  maintainVisibleStart: true
};
var defaultScrollOptions$1 = {
  block: "nearest"
};
var TimelineScroll = (Target) => class TimelineScroll extends (Target || Base$1) {
  static get $name() {
    return "TimelineScroll";
  }
  static get configurable() {
    return {
      bufferCoef: 5,
      bufferThreshold: 0.2,
      infiniteScroll: false
    };
  }
  initScroll() {
    const me = this, {
      isHorizontal
    } = me;
    super.initScroll();
    const {
      scrollable
    } = isHorizontal ? me.timeAxisSubGrid : me;
    scrollable.ion({
      scroll: "onTimelineScroll",
      thisObj: me
    });
    if (me.infiniteScroll) {
      const {
        visibleDate
      } = me, date2 = visibleDate ? visibleDate.date || visibleDate : me.viewportCenterDate, centered = visibleDate && "block" in visibleDate ? visibleDate.block === "center" : true, {
        startDate,
        endDate
      } = me.timeAxisViewModel.calculateInfiniteScrollingDateRange(date2, centered);
      me.setTimeSpan(startDate, endDate, {
        visibleDate: date2
      });
    }
  }
  get timelineScroller() {
    const me = this;
    if (!me.scrollInitialized) {
      me.initScroll();
    }
    return me._timelineScroller || (me._timelineScroller = new TimelineScroller({
      widget: me,
      scrollable: me.isHorizontal ? me.timeAxisSubGrid.scrollable : me.scrollable,
      isHorizontal: me.isHorizontal
    }));
  }
  doDestroy() {
    var _this$_timelineScroll;
    (_this$_timelineScroll = this._timelineScroller) === null || _this$_timelineScroll === void 0 ? void 0 : _this$_timelineScroll.destroy();
    super.doDestroy();
  }
  onTimelineScroll({
    source
  }) {
    if (this.infiniteScroll) {
      this.checkTimeAxisScroll(source[this.isHorizontal ? "x" : "y"]);
    }
  }
  checkTimeAxisScroll(scrollPos) {
    const me = this, scrollable = me.timelineScroller, {
      clientSize
    } = scrollable, requiredSize = clientSize * me.bufferCoef, limit = requiredSize * me.bufferThreshold, maxScroll = scrollable.maxPosition, {
      style
    } = me.timeAxisSubGrid.virtualScrollerElement;
    if (maxScroll - scrollPos < limit || scrollPos < limit) {
      style.overflow = "hidden";
      style.pointerEvents = "none";
      style.paddingBottom = `${DomHelper.scrollBarWidth}px`;
      me.setTimeout(() => {
        style.overflow = "";
        style.paddingBottom = "";
        style.pointerEvents = "";
      }, 100);
      me.shiftToDate(me.getDateFromCoordinate(scrollPos, null, true));
    }
  }
  shiftToDate(date2, centered) {
    const newRange = this.timeAxisViewModel.calculateInfiniteScrollingDateRange(date2, centered);
    this.setTimeSpan(newRange.startDate, newRange.endDate, maintainVisibleStart);
  }
  updateInfiniteScroll(infiniteScroll) {
    if (!this.isConfiguring && infiniteScroll) {
      this.checkTimeAxisScroll(this.timelineScroller.position);
    }
  }
  scrollToDate(date2, options = {}) {
    const me = this, {
      timeAxis,
      visibleDateRange,
      infiniteScroll
    } = me, {
      unit,
      increment
    } = timeAxis, edgeOffset = options.edgeOffset || 0, visibleWidth = DateHelper.ceil(visibleDateRange.endDate, increment + " " + unit) - DateHelper.floor(visibleDateRange.startDate, increment + " " + unit), direction = date2 > me.viewportCenterDate ? 1 : -1, extraScroll = (infiniteScroll ? visibleWidth * me.bufferCoef * me.bufferThreshold : options.block === "center" ? visibleWidth / 2 : edgeOffset ? me.getMilliSecondsPerPixelForZoomLevel(me.viewPreset) * edgeOffset : 0) * direction, visibleDate = new Date(date2.getTime() + extraScroll), shiftDirection = visibleDate > timeAxis.endDate ? 1 : visibleDate < timeAxis.startDate ? -1 : 0;
    if (shiftDirection && me.infiniteScroll) {
      me.shiftToDate(new Date(date2 - extraScroll), null, true);
    }
    const scrollerViewport = me.timelineScroller.viewport, localCoordinate = me.getCoordinateFromDate(date2, true), target = me.isHorizontal ? new Rectangle(me.getCoordinateFromDate(date2, false), scrollerViewport.y, Math.min(me.timeAxisViewModel.tickSize, me.timeAxisViewModel.availableSpace), scrollerViewport.height) : new Rectangle(scrollerViewport.x, me.getCoordinateFromDate(date2, false), scrollerViewport.width, me.timeAxisViewModel.tickSize);
    return me.scrollToCoordinate(localCoordinate, target, date2, options);
  }
  scrollToNow(options = {}) {
    return this.scrollToDate(new Date(), options);
  }
  async scrollToCoordinate(localCoordinate, target, date2, options = {}) {
    const me = this;
    if (localCoordinate < 0) {
      const visibleSpan = me.endDate - me.startDate, {
        unit,
        increment
      } = me.timeAxis, newStartDate = DateHelper.floor(new Date(date2.getTime() - visibleSpan / 2), increment + " " + unit), newEndDate = DateHelper.add(newStartDate, visibleSpan);
      if (newStartDate - me.startDate !== 0 && newEndDate - me.endDate !== 0) {
        me.setTimeSpan(newStartDate, newEndDate);
        return me.scrollToDate(date2, options);
      }
      return;
    }
    await me.timelineScroller.scrollIntoView(target, options);
    return !me.isDestroyed && me.nextAnimationFrame();
  }
  set scrollLeft(left) {
    this.timeAxisSubGrid.scrollable.element.scrollLeft = left;
  }
  get scrollLeft() {
    return this.timeAxisSubGrid.scrollable.element.scrollLeft;
  }
  set scrollX(x) {
    this.timeAxisSubGrid.scrollable.x = x;
  }
  get scrollX() {
    return this.timeAxisSubGrid.scrollable.x;
  }
  set scrollTop(top) {
    this.scrollable.y = top;
  }
  get scrollTop() {
    return this.scrollable.y;
  }
  scrollHorizontallyTo(coordinate, options = true) {
    return this.timeAxisSubGrid.scrollable.scrollTo(coordinate, null, options);
  }
  scrollVerticallyTo(y, options = true) {
    return this.scrollable.scrollTo(null, y, options);
  }
  scrollTo(x, options = true) {
    return this.timeAxisSubGrid.scrollable.scrollTo(x, null, options);
  }
  get widgetClass() {
  }
};
var TimelineScroller = class extends Scroller {
  static get configurable() {
    return {
      position: null,
      x: null,
      y: null
    };
  }
  updateOverflowX() {
  }
  updateOverflowY() {
  }
  onScroll(e) {
    super.onScroll(e);
    this._position = null;
  }
  syncPartners(force) {
    this.scrollable.syncPartners(force);
  }
  updatePosition(position) {
    this.scrollable[this.isHorizontal ? "x" : "y"] = position;
  }
  get viewport() {
    return this.scrollable.viewport;
  }
  get position() {
    return this._position = this.scrollable[this.isHorizontal ? "x" : "y"];
  }
  get clientSize() {
    return this.scrollable[`client${this.isHorizontal ? "Width" : "Height"}`];
  }
  get scrollSize() {
    return this.scrollable[`scroll${this.isHorizontal ? "Width" : "Height"}`];
  }
  get maxPosition() {
    return this.scrollable[`max${this.isHorizontal ? "X" : "Y"}`];
  }
  scrollTo(position, options) {
    return this.isHorizontal ? this.scrollable.scrollTo(position, null, options) : this.scrollable.scrollTo(null, position, options);
  }
  scrollBy(xDelta = 0, yDelta = 0, options = defaultScrollOptions$1) {
    return this.isHorizontal ? this.scrollable.scrollBy(xDelta || yDelta, 0, options) : this.scrollable.scrollBy(0, yDelta || xDelta, options);
  }
  scrollIntoView() {
    return this.scrollable.scrollIntoView(...arguments);
  }
  changeX(x) {
    this.position = x;
  }
  changeY(y) {
    this.position = y;
  }
  get x() {
    return this.position;
  }
  set x(x) {
    this.scrollable[this.isHorizontal ? "x" : "y"] = x;
  }
  get y() {
    return this.position;
  }
  set y(y) {
    this.scroller[this.isHorizontal ? "x" : "y"] = y;
  }
  get clientWidth() {
    return this.clientSize;
  }
  get clientHeight() {
    return this.clientSize;
  }
  get scrollWidth() {
    return this.scrollSize;
  }
  get scrollHeight() {
    return this.scrollSize;
  }
  get maxX() {
    return this.maxPosition;
  }
  get maxY() {
    return this.maxPosition;
  }
};
var copyProperties$1 = ["barMargin"];
var TimelineState = (Target) => class TimelineState extends (Target || Base$1) {
  static get $name() {
    return "TimelineState";
  }
  getState() {
    const me = this, state = ObjectHelper.copyProperties(super.getState(), me, copyProperties$1);
    state.zoomLevel = me.zoomLevel;
    state.zoomLevelOptions = {
      startDate: me.startDate,
      endDate: me.endDate,
      centerDate: !me.infiniteScroll || me.timeAxisViewModel.availableSpace ? me.viewportCenterDate : void 0,
      width: me.tickSize
    };
    return state;
  }
  applyState(state) {
    const me = this;
    me.suspendRefresh();
    ObjectHelper.copyProperties(me, state, copyProperties$1);
    super.applyState(state);
    if (state.zoomLevel != null) {
      if (me.infiniteScroll) {
        var _state$scroll;
        if (state !== null && state !== void 0 && (_state$scroll = state.scroll) !== null && _state$scroll !== void 0 && _state$scroll.scrollLeft) {
          state.scroll.scrollLeft = {};
        }
      }
      if (me.isPainted) {
        me.zoomToLevel(state.zoomLevel, state.zoomLevelOptions);
      } else {
        me._zoomAfterPaint = {
          zoomLevel: state.zoomLevel,
          zoomLevelOptions: state.zoomLevelOptions
        };
      }
    }
    me.resumeRefresh(true);
  }
  onPaint(...args) {
    super.onPaint(...args);
    if (this._zoomAfterPaint) {
      const {
        zoomLevel,
        zoomLevelOptions
      } = this._zoomAfterPaint;
      this.zoomToLevel(zoomLevel, zoomLevelOptions);
      delete this._zoomAfterPaint;
    }
  }
  get widgetClass() {
  }
};
var Header = class extends Header$1 {
  static get $name() {
    return "SchedulerHeader";
  }
  refreshContent() {
    var _this$headersElement;
    if (!((_this$headersElement = this.headersElement) !== null && _this$headersElement !== void 0 && _this$headersElement.querySelector(".b-sch-timeaxiscolumn"))) {
      super.refreshContent();
    }
  }
};
Header._$name = "Header";
var TimeAxisSubGrid = class extends SubGrid {
  static get $name() {
    return "TimeAxisSubGrid";
  }
  static get type() {
    return "timeaxissubgrid";
  }
  static get configurable() {
    return {
      sealedColumns: true,
      headerClass: Header
    };
  }
  startConfigure(config) {
    const {
      grid: scheduler
    } = config;
    scheduler.timeAxisSubGrid = this;
    super.startConfigure(config);
    if (scheduler.isHorizontal) {
      config.header = {
        cls: {
          "b-sticky-headers": scheduler.stickyHeaders
        }
      };
      delete config.headerClass;
    }
    if (!("flex" in config || "width" in config)) {
      config.flex = 1;
    }
  }
  changeScrollable() {
    const me = this, scrollable = super.changeScrollable(...arguments);
    if (scrollable) {
      Object.defineProperty(scrollable, "scrollWidth", {
        get() {
          var _this$element$scrollW, _this$element;
          return (_this$element$scrollW = (_this$element = this.element) === null || _this$element === void 0 ? void 0 : _this$element.scrollWidth) !== null && _this$element$scrollW !== void 0 ? _this$element$scrollW : 0;
        },
        set() {
          me.grid.updateCanvasSize();
        }
      });
    }
    return scrollable;
  }
  syncScrollingPartners(addCls = true) {
    if (!this.grid._viewPresetChanging) {
      super.syncScrollingPartners(addCls);
    }
  }
  onInternalResize(element, width, height, oldWidth, oldHeight) {
    const me = this;
    if (me.isPainted && width !== oldWidth) {
      const scheduler = me.grid, bodyHeight = scheduler._bodyRectangle.height;
      if (DomHelper.scrollBarWidth && width < oldWidth) {
        me.monitorResize = false;
      }
      scheduler.onSchedulerViewportResize(width, bodyHeight, oldWidth, bodyHeight);
      if (!me.monitorResize) {
        me.requestAnimationFrame(() => me.monitorResize = true);
      }
    }
    super.onInternalResize(...arguments);
  }
  clearWidthCache() {
    super.clearWidthCache();
    if (this.owner.isHorizontal) {
      this.owner.updateViewModelAvailableSpace(this.width);
    }
  }
};
TimeAxisSubGrid.initClass();
TimeAxisSubGrid._$name = "TimeAxisSubGrid";
var exitTransition = {
  fn: "exitTransition",
  delay: 0,
  cancelOutstanding: true
};
var emptyObject$4 = {};
var TimelineBase = class extends GridBase.mixin(TimelineDateMapper, TimelineDomEvents, TimelineEventRendering, TimelineScroll, TimelineState, TimelineViewPresets, TimelineZoomable, RecurringEvents) {
  static get $name() {
    return "TimelineBase";
  }
  static get type() {
    return "timelinebase";
  }
  static get defaultConfig() {
    return {
      workingTime: null,
      timeAxis: null,
      timeAxisViewModel: null,
      autoAdjustTimeAxis: true,
      snapRelativeToEventStartDate: false,
      suppressFit: false,
      timeCellCls: null,
      scheduledEventName: null,
      overScheduledEventClass: null,
      preventOverCls: false,
      useBackgroundCanvas: false,
      enableEventAnimations: true,
      disableGridRowModelWarning: true,
      animateRemovingRows: false,
      partner: null,
      schedulerRegion: "normal",
      transitionDuration: 200,
      animationTimeout: null,
      defaultRegion: "locked",
      durationDisplayPrecision: 1,
      asyncEventSuffix: "PreCommit",
      viewportResizeTimeout: 250
    };
  }
  updateTimeZone(timeZone) {
    if (this.isConfiguring) {
      this.project._isConfiguringTimeZone = true;
    }
    this.project.timeZone = timeZone;
  }
  get timeZone() {
    return this.project.timeZone;
  }
  populateEventMenu() {
  }
  populateScheduleMenu() {
  }
  onVisibleDateRangeChange(range) {
    if (!this.handlingVisibleDateRangeChange) {
      const me = this, {
        _visibleDateRange
      } = me, dateRangeChange = !_visibleDateRange || _visibleDateRange.startDate - range.startDate || _visibleDateRange.endDate - range.endDate;
      if (dateRangeChange) {
        me.timeView.range = range;
        me.handlingVisibleDateRangeChange = true;
        me.trigger("visibleDateRangeChange", {
          old: _visibleDateRange,
          new: range
        });
        me.handlingVisibleDateRangeChange = false;
        me._visibleDateRange = range;
      }
    }
  }
  onVisibleResourceRangeChange() {
  }
  construct(config = {}) {
    const me = this;
    super.construct(config);
    me.$firstVerticalOverflow = true;
    me.initDomEvents();
    me.currentOrientation.init();
    me.rowManager.ion({
      refresh: () => {
        me.forceLayout = false;
      }
    });
  }
  createSubGrid(region, config = {}) {
    const me = this, {
      stickyHeaders
    } = me;
    if (region === (me.schedulerRegion || "normal")) {
      config.type = "timeaxissubgrid";
    } else if (region === "locked" && stickyHeaders && me.isVertical) {
      config.scrollable = {
        overflowX: "visible",
        overflowY: "visible"
      };
      me.bodyContainer.classList.add("b-sticky-headers");
    }
    return super.createSubGrid(region, config);
  }
  doDestroy() {
    const me = this, {
      partneredWith,
      currentOrientation
    } = me;
    currentOrientation === null || currentOrientation === void 0 ? void 0 : currentOrientation.destroy();
    if (partneredWith) {
      partneredWith.forEach((p) => {
        me.removePartner(p);
      });
      partneredWith.destroy();
    } else {
      me.timeAxisViewModel.destroy();
      me.timeAxis.destroy();
    }
    super.doDestroy();
  }
  startConfigure(config) {
    super.startConfigure(config);
    ResizeMonitor.addResizeListener(this.bodyContainer, this.onBodyResize.bind(this));
    this.getConfig("partner");
  }
  changeStartDate(startDate) {
    if (typeof startDate === "string") {
      startDate = DateHelper.parse(startDate);
    }
    return startDate;
  }
  onPaint({
    firstPaint
  }) {
    if (firstPaint) {
      const me = this, scrollable = me.isHorizontal ? me.timeAxisSubGrid.scrollable : me.scrollable, availableSpace = scrollable.element.getBoundingClientRect()[me.isHorizontal ? "width" : "height"];
      me.timeAxisViewModel.update(availableSpace, me.infiniteScroll, true);
      if (me.infiniteScroll) {
        var _me$currentOrientatio, _me$currentOrientatio2;
        (_me$currentOrientatio = (_me$currentOrientatio2 = me.currentOrientation).doUpdateTimeView) === null || _me$currentOrientatio === void 0 ? void 0 : _me$currentOrientatio.call(_me$currentOrientatio2);
      }
    }
    super.onPaint(...arguments);
  }
  onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX) {
    this.currentOrientation.updateFromHorizontalScroll(scrollX);
    super.onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX);
  }
  initScroll() {
    const me = this;
    let frameCount = 0;
    super.initScroll();
    me.ion({
      horizontalScroll: ({
        subGrid,
        scrollLeft,
        scrollX
      }) => {
        if (me.isPainted && subGrid === me.timeAxisSubGrid && !me.isDestroying && !me.refreshSuspended) {
          me.onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX);
        }
        frameCount++;
      }
    });
    if (me.testPerformance === "horizontal") {
      me.setTimeout(() => {
        const start = performance.now();
        let scrollSpeed = 5, direction = 1;
        const scrollInterval = me.setInterval(() => {
          scrollSpeed = scrollSpeed + 5;
          me.scrollX += (10 + Math.floor(scrollSpeed)) * direction;
          if (direction === 1 && me.scrollX > 5500) {
            direction = -1;
            scrollSpeed = 5;
          }
          if (direction === -1 && me.scrollX <= 0) {
            const done = performance.now(), elapsed = done - start;
            const timePerFrame = elapsed / frameCount, fps = Math.round(1e3 / timePerFrame * 10) / 10;
            clearInterval(scrollInterval);
            console.log(me.eventPositionMode, me.eventScrollMode, fps + "fps");
          }
        }, 0);
      }, 500);
    }
  }
  preserveViewCenter(fn2, thisObj = this, ...args) {
    const me = this, centerDate = me.viewportCenterDate, result = fn2.apply(thisObj, args), scroller = me.timelineScroller, {
      clientSize
    } = scroller, scrollStart = Math.max(Math.floor(me.getCoordinateFromDate(centerDate, true) - clientSize / 2), 0);
    me.scrollingToCenter = true;
    scroller.scrollTo(scrollStart, false).then(() => me.scrollingToCenter = false);
    return result;
  }
  setTimeSpan(newStartDate, newEndDate, {
    preventThrow = false,
    maintainVisibleStart: maintainVisibleStart2 = false,
    visibleDate
  } = emptyObject$4) {
    const me = this, {
      timeAxis
    } = me, {
      startDate,
      endDate
    } = timeAxis.getAdjustedDates(newStartDate, newEndDate), startChanged = timeAxis.startDate - startDate !== 0, endChanged = timeAxis.endDate - endDate !== 0;
    if (startChanged || endChanged) {
      if (maintainVisibleStart2) {
        const {
          timeAxisViewModel
        } = me, {
          totalSize
        } = timeAxisViewModel, oldTickSize = timeAxisViewModel.tickSize, scrollable = me.timelineScroller, currentScroll = scrollable.position, visibleStart = timeAxisViewModel.getDateFromPosition(currentScroll);
        if (visibleStart >= startDate && visibleStart < endDate) {
          timeAxisViewModel.ion({
            update() {
              const tickSizeChanged = timeAxisViewModel.tickSize !== oldTickSize;
              me.updateCanvasSize();
              if (startChanged && !endChanged && !tickSizeChanged) {
                scrollable.position += timeAxisViewModel.totalSize - totalSize;
              } else if (!startChanged && !tickSizeChanged) {
                scrollable.position = currentScroll;
              } else {
                scrollable.position = timeAxisViewModel.getPositionFromDate(visibleStart);
              }
              scrollable.syncPartners(true);
            },
            prio: 1e4,
            once: true
          });
        }
      }
      const returnValue = timeAxis.reconfigure({
        startDate,
        endDate
      }, false, preventThrow);
      if (visibleDate) {
        me.scrollToDate(visibleDate.date || visibleDate, visibleDate);
      }
      return returnValue;
    }
  }
  get hasVisibleEvents() {
    return !this.noFeatureElementsInAxis() || this.eventStore.storage.values.some((t) => this.timeAxis.isTimeSpanInAxis(t));
  }
  noFeatureElementsInAxis() {
  }
  get capitalizedEventName() {
    if (!this._capitalizedEventName) {
      this._capitalizedEventName = StringHelper.capitalize(this.scheduledEventName);
    }
    return this._capitalizedEventName;
  }
  set partner(partner) {
    this._partner = partner;
    this.addPartner(partner);
  }
  addPartner(partner) {
    const me = this;
    if (!me.isPartneredWith(partner)) {
      const partneredWith = me.partneredWith || (me.partneredWith = new Collection());
      partneredWith.add(partner);
      (partner.partneredWith || (partner.partneredWith = new Collection())).add(me);
      me.getConfig("viewPreset");
      partner.ion({
        presetchange: "onPartnerPresetChange",
        thisObj: me
      });
      partner.scrollable.ion({
        overflowChange: "onPartnerOverflowChange",
        thisObj: me
      });
      const partnerSharedConfig = me.partnerSharedConfigs.reduce((config, configName) => {
        config[configName] = partner[configName];
        return config;
      }, {});
      me.setConfig(partnerSharedConfig);
      me.ion({
        presetchange: "onPartnerPresetChange",
        thisObj: partner
      });
      me.scrollable.ion({
        overflowChange: "onPartnerOverflowChange",
        thisObj: partner
      });
      if (me.isPainted) {
        me.scrollable.addPartner(partner.scrollable, me.isHorizontal ? "x" : "y");
        partner.syncPartnerSubGrids();
      } else {
        me.initScroll = FunctionHelper.createSequence(me.initScroll, () => {
          me.scrollable.addPartner(partner.scrollable, me.isHorizontal ? "x" : "y");
          partner.syncPartnerSubGrids();
        }, me);
      }
    }
  }
  removePartner(partner) {
    const me = this, {
      partneredWith
    } = me;
    if (me.isPartneredWith(partner)) {
      partneredWith.remove(partner);
      me.scrollable.removePartner(partner.scrollable);
      me.un({
        presetchange: "onPartnerPresetChange",
        thisObj: partner
      });
      me.scrollable.un({
        overflowChange: "onPartnerOverflowChange",
        thisObj: partner
      });
      partner.removePartner(me);
    }
  }
  isPartneredWith(partner) {
    var _this$partneredWith;
    return Boolean((_this$partneredWith = this.partneredWith) === null || _this$partneredWith === void 0 ? void 0 : _this$partneredWith.includes(partner));
  }
  onPartnerOverflowChange({
    source: otherScrollable,
    y
  }) {
    const {
      scrollable
    } = this, ourY = scrollable.hasOverflow("y");
    if (ourY !== y) {
      if (ourY) {
        otherScrollable.overflowY = "scroll";
      } else {
        otherScrollable.overflowY = true;
        scrollable.overflowY = "scroll";
        this.refreshVirtualScrollbars();
      }
    } else {
      scrollable.overflowY = true;
    }
  }
  onPartnerPresetChange({
    preset,
    startDate,
    endDate,
    centerDate,
    zoomDate,
    zoomPosition,
    zoomLevel
  }) {
    if (!this._viewPresetChanging && this.viewPreset !== preset) {
      preset.options = {
        startDate,
        endDate,
        centerDate,
        zoomDate,
        zoomPosition,
        zoomLevel
      };
      this.viewPreset = preset;
    }
  }
  get partner() {
    return this._partner;
  }
  get partners() {
    const partners = this.partner ? [this.partner] : [];
    if (this.partneredWith) {
      partners.push.apply(partners, this.partneredWith.allValues);
    }
    return partners;
  }
  get timeAxisColumn() {
    return this.columns && this._timeAxisColumn;
  }
  get columns() {
    return super.columns;
  }
  set columns(columns) {
    const me = this;
    let timeAxisColumnIndex, timeAxisColumnConfig, timeAxisColumn;
    if (columns) {
      const isArray2 = Array.isArray(columns);
      let cols = columns;
      if (!isArray2) {
        cols = columns.data;
      }
      timeAxisColumnIndex = cols && cols.length;
      cols.some((col, index) => {
        if (col.type === "timeAxis") {
          timeAxisColumnIndex = index;
          timeAxisColumnConfig = ObjectHelper.assign(col, me.timeAxisColumn);
          return true;
        }
        return false;
      });
      if (me.isVertical) {
        me._horizontalColumns = columns;
        cols = [
          ObjectHelper.assign({
            type: "verticalTimeAxis",
            locked: true
          }, me.verticalTimeAxisColumn),
          cols[timeAxisColumnIndex]
        ];
        timeAxisColumnIndex = 1;
      } else {
        cols = cols.slice();
      }
      cols[timeAxisColumnIndex] = _objectSpread2({
        type: "timeAxis",
        locked: false,
        cellCls: me.timeCellCls,
        mode: me.mode
      }, timeAxisColumnConfig);
      if (isArray2) {
        columns = cols;
      } else {
        columns.data = cols;
      }
    }
    super.columns = columns;
    if (columns) {
      timeAxisColumn = me._timeAxisColumn = me.columns.find((c) => c.isTimeAxisColumn);
      if (me.isVertical) {
        me.verticalTimeAxisColumn = me.columns.find((c) => c.isVerticalTimeAxisColumn);
        me.verticalTimeAxisColumn.relayAll(me);
      }
      timeAxisColumn.relayAll(me);
    }
  }
  onColumnsChanged({
    action,
    changes,
    record: column
  }) {
    const {
      timeAxisColumn,
      columns
    } = this;
    if (action === "dataset" && !columns.includes(timeAxisColumn)) {
      columns.add(timeAxisColumn, true);
    } else if (column === timeAxisColumn && "width" in changes) {
      this.updateCanvasSize();
    }
    super.onColumnsChanged(...arguments);
  }
  get timeView() {
    const me = this;
    return me.columns && me.isVertical ? me.verticalTimeAxisColumn && me.verticalTimeAxisColumn.view : me.timeAxisColumn && me.timeAxisColumn.timeAxisView;
  }
  updateEventCls(eventCls) {
    const me = this;
    if (!me.eventSelector) {
      me.unreleasedEventSelector = me.eventSelector = `.${eventCls}-wrap`;
    }
    if (!me.eventInnerSelector) {
      me.eventInnerSelector = `.${eventCls}`;
    }
  }
  set timeAxisViewModel(timeAxisViewModel) {
    var _timeAxisViewModel;
    const me = this, currentModel = me._timeAxisViewModel, tavmListeners = {
      name: "timeAxisViewModel",
      update: "onTimeAxisViewModelUpdate",
      prio: 100,
      thisObj: me
    };
    if (me.partner && !timeAxisViewModel || currentModel && currentModel === timeAxisViewModel) {
      return;
    }
    if ((currentModel === null || currentModel === void 0 ? void 0 : currentModel.owner) === me) {
      currentModel.destroy();
    }
    me.detachListeners("timeAxisViewModel");
    if ((_timeAxisViewModel = timeAxisViewModel) !== null && _timeAxisViewModel !== void 0 && _timeAxisViewModel.isTimeAxisViewModel) {
      timeAxisViewModel.ion(tavmListeners);
    } else {
      timeAxisViewModel = TimeAxisViewModel.new({
        mode: me._mode,
        snap: me.snap,
        forceFit: me.forceFit,
        timeAxis: me.timeAxis,
        suppressFit: me.suppressFit,
        internalListeners: tavmListeners,
        owner: me
      }, timeAxisViewModel);
    }
    if (!me.isConfiguring) {
      if (me.isHorizontal) {
        me.timeAxisColumn.timeAxisViewModel = timeAxisViewModel;
      } else {
        me.verticalTimeAxisColumn.view.model = timeAxisViewModel;
      }
    }
    me._timeAxisViewModel = timeAxisViewModel;
    me.relayEvents(timeAxisViewModel, ["update"], "timeAxisViewModel");
    if (currentModel && timeAxisViewModel) {
      me.trigger("timeAxisViewModelChange", {
        timeAxisViewModel
      });
    }
  }
  get timeAxisViewModel() {
    if (!this._timeAxisViewModel) {
      this.timeAxisViewModel = null;
    }
    return this._timeAxisViewModel;
  }
  get suppressFit() {
    var _this$_timeAxisViewMo, _this$_timeAxisViewMo2;
    return (_this$_timeAxisViewMo = (_this$_timeAxisViewMo2 = this._timeAxisViewModel) === null || _this$_timeAxisViewMo2 === void 0 ? void 0 : _this$_timeAxisViewMo2.suppressFit) !== null && _this$_timeAxisViewMo !== void 0 ? _this$_timeAxisViewMo : this._suppressFit;
  }
  set suppressFit(value) {
    if (this._timeAxisViewModel) {
      this.timeAxisViewModel.suppressFit = value;
    } else {
      this._suppressFit = value;
    }
  }
  set timeAxis(timeAxis) {
    var _timeAxis;
    const me = this, currentTimeAxis = me._timeAxis, timeAxisListeners = {
      name: "timeAxis",
      reconfigure: "onTimeAxisReconfigure",
      thisObj: me
    };
    if (me.partner && !timeAxis || currentTimeAxis && currentTimeAxis === timeAxis) {
      return;
    }
    if (currentTimeAxis) {
      if (currentTimeAxis.owner === me) {
        currentTimeAxis.destroy();
      }
    }
    me.detachListeners("timeAxis");
    if (!((_timeAxis = timeAxis) !== null && _timeAxis !== void 0 && _timeAxis.isTimeAxis)) {
      timeAxis = ObjectHelper.assign({
        owner: me,
        viewPreset: me.viewPreset,
        autoAdjust: me.autoAdjustTimeAxis,
        weekStartDay: me.weekStartDay,
        forceFullTicks: me.fillTicks && me.snap
      }, timeAxis);
      if (me.startDate) {
        timeAxis.startDate = me.startDate;
      }
      if (me.endDate) {
        timeAxis.endDate = me.endDate;
      }
      if (me.workingTime) {
        me.applyWorkingTime(timeAxis);
      }
      timeAxis = new TimeAxis(timeAxis);
    }
    timeAxis.ion(timeAxisListeners);
    me._timeAxis = timeAxis;
  }
  onTimeAxisReconfigure({
    config,
    oldConfig
  }) {
    if (config) {
      const dateRangeChange = !oldConfig || oldConfig.startDate - config.startDate || oldConfig.endDate - config.endDate;
      if (dateRangeChange) {
        this.trigger("dateRangeChange", {
          old: {
            startDate: oldConfig.startDate,
            endDate: oldConfig.endDate
          },
          new: {
            startDate: config.startDate,
            endDate: config.endDate
          }
        });
      }
    }
    this.trigger("timeAxisChange", {
      config
    });
  }
  get timeAxis() {
    if (!this._timeAxis) {
      this.timeAxis = null;
    }
    return this._timeAxis;
  }
  updateForceFit(value) {
    if (this._timeAxisViewModel) {
      this._timeAxisViewModel.forceFit = value;
    }
  }
  set workingTime(config) {
    this._workingTime = config;
    if (!this.isConfiguring) {
      this.applyWorkingTime(this.timeAxis);
    }
  }
  get workingTime() {
    return this._workingTime;
  }
  applyWorkingTime(timeAxis) {
    const me = this, config = me._workingTime;
    if (config) {
      let hour2 = null;
      if (config.fromHour >= 0 && config.fromHour < 24 && config.toHour > config.fromHour && config.toHour <= 24 && config.toHour - config.fromHour < 24) {
        hour2 = {
          from: config.fromHour,
          to: config.toHour
        };
      }
      let day2 = null;
      if (config.fromDay >= 0 && config.fromDay < 7 && config.toDay > config.fromDay && config.toDay <= 7 && config.toDay - config.fromDay < 7) {
        day2 = {
          from: config.fromDay,
          to: config.toDay
        };
      }
      if (hour2 || day2) {
        timeAxis.include = {
          hour: hour2,
          day: day2
        };
      } else {
        timeAxis.include = null;
      }
    } else {
      timeAxis.include = null;
    }
    if (me.isPainted) {
      var _me$features$columnLi;
      me.timeAxisColumn.refreshHeader();
      (_me$features$columnLi = me.features.columnLines) === null || _me$features$columnLi === void 0 ? void 0 : _me$features$columnLi.refresh();
      me.refreshWithTransition();
    }
  }
  updateStartDate(date2) {
    this.setStartDate(date2);
  }
  setStartDate(date2, keepDuration = true) {
    const me = this, ta = me._timeAxis, {
      startDate,
      endDate,
      mainUnit
    } = ta || emptyObject$4;
    if (typeof date2 === "string") {
      date2 = DateHelper.parse(date2);
    }
    if (ta && endDate) {
      if (date2) {
        let calcEndDate = endDate;
        if (keepDuration && startDate) {
          const diff = DateHelper.diff(startDate, endDate, mainUnit, true);
          calcEndDate = DateHelper.add(date2, diff, mainUnit);
        }
        me.setTimeSpan(date2, calcEndDate);
      }
    } else {
      me._tempStartDate = date2;
    }
  }
  get startDate() {
    const me = this;
    if (me._timeAxis) {
      return me._timeAxis.startDate;
    }
    return me._tempStartDate || new Date();
  }
  changeEndDate(date2) {
    if (typeof date2 === "string") {
      date2 = DateHelper.parse(date2);
    }
    this.setEndDate(date2);
  }
  setEndDate(date2, keepDuration = false) {
    const me = this, ta = me._timeAxis, {
      startDate,
      endDate,
      mainUnit
    } = ta || emptyObject$4;
    if (typeof date2 === "string") {
      date2 = DateHelper.parse(date2);
    }
    if (ta && startDate) {
      if (date2) {
        let calcStartDate = startDate;
        if (keepDuration && endDate) {
          const diff = DateHelper.diff(startDate, endDate, mainUnit, true);
          calcStartDate = DateHelper.add(date2, -diff, mainUnit);
        }
        me.setTimeSpan(calcStartDate, date2);
      }
    } else {
      me._tempEndDate = date2;
    }
  }
  get endDate() {
    const me = this;
    if (me._timeAxis) {
      return me._timeAxis.endDate;
    }
    return me._tempEndDate || DateHelper.add(me.startDate, me.viewPreset.defaultSpan, me.viewPreset.mainHeader.unit);
  }
  changeVisibleDate(options) {
    return options instanceof Date ? {
      date: options
    } : options;
  }
  updateVisibleDate(options) {
    const me = this;
    if (me.isPainted) {
      me.scrollToDate(options.date, options);
    } else {
      me.ion({
        paint: () => me.scrollToDate(options.date, options),
        once: true
      });
    }
  }
  get features() {
    return super.features;
  }
  set features(features) {
    features = features === true ? {} : features;
    if (!("regionResize" in features)) {
      features.regionResize = true;
    }
    super.features = features;
  }
  get eventStyle() {
    return this._eventStyle;
  }
  set eventStyle(style) {
    this._eventStyle = style;
    this.refreshWithTransition();
    this.trigger("stateChange");
  }
  get eventColor() {
    return this._eventColor;
  }
  set eventColor(color) {
    this._eventColor = color;
    this.refreshWithTransition();
    this.trigger("stateChange");
  }
  onLocaleChange() {
    super.onLocaleChange();
    const oldAutoAdjust = this.timeAxis.autoAdjust;
    this.timeAxis.reconfigure({
      autoAdjust: false
    });
    this.timeAxis.autoAdjust = oldAutoAdjust;
  }
  onBodyResize(element, oldRect, {
    width,
    height
  }) {
    if (this.isVertical && oldRect && width !== oldRect.width) {
      delete this.timeAxisSubGrid._width;
    }
    const newWidth = this.timeAxisSubGrid.element.offsetWidth;
    if (this._bodyRectangle && oldRect && height !== oldRect.height) {
      this.onSchedulerViewportResize(newWidth, height, newWidth, oldRect.height);
    }
  }
  onSchedulerViewportResize(width, height, oldWidth, oldHeight) {
    if (this.isPainted) {
      const me = this, {
        isHorizontal,
        partneredWith
      } = me;
      me.currentOrientation.onViewportResize(width, height, oldWidth, oldHeight);
      me.updateViewModelAvailableSpace(isHorizontal ? width : Math.floor(height));
      if (partneredWith && !me.isSyncingFromPartner) {
        me.syncPartnerSubGrids();
      }
      me.trigger("timelineViewportResize", {
        width,
        height,
        oldWidth,
        oldHeight
      });
    }
  }
  updateViewModelAvailableSpace(space) {
    this.timeAxisViewModel.availableSpace = space;
  }
  onTimeAxisViewModelUpdate() {
    if (!this._viewPresetChanging) {
      this.updateCanvasSize();
      this.currentOrientation.onTimeAxisViewModelUpdate();
    }
  }
  syncPartnerSubGrids() {
    this.partneredWith.forEach((partner) => {
      if (!partner.isSyncingFromPartner) {
        partner.isSyncingFromPartner = true;
        this.eachSubGrid((subGrid) => {
          const partnerSubGrid = partner.subGrids[subGrid.region];
          if (partnerSubGrid.width !== subGrid.width) {
            if (subGrid.collapsed) {
              partnerSubGrid.collapse();
            } else {
              if (partnerSubGrid.collapsed) {
                partnerSubGrid.expand();
              }
              if (subGrid.flex) {
                if (subGrid.flex !== partnerSubGrid.flex) {
                  partnerSubGrid.flex = subGrid.flex;
                }
              } else {
                partnerSubGrid.width = subGrid.width;
              }
            }
          }
        });
        partner.isSyncingFromPartner = false;
      }
    });
  }
  get currentOrientation() {
    throw new Error("Implement in subclass");
  }
  get isHorizontal() {
    return true;
  }
  get backgroundCanvas() {
    return this._backgroundCanvas;
  }
  get foregroundCanvas() {
    return this._foregroundCanvas;
  }
  get svgCanvas() {
    const me = this;
    if (!me._svgCanvas) {
      const svg = me._svgCanvas = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("id", IdHelper.generateId("svg"));
      svg.retainElement = true;
      me.foregroundCanvas.appendChild(svg);
      me.trigger("svgCanvasCreated", {
        svg
      });
    }
    return me._svgCanvas;
  }
  get timeAxisSubGridElement() {
    if (!this._timeAxisSubGridElement) {
      var _this$timeAxisColumn;
      this.getConfig("regions");
      this._timeAxisSubGridElement = (_this$timeAxisColumn = this.timeAxisColumn) === null || _this$timeAxisColumn === void 0 ? void 0 : _this$timeAxisColumn.subGridElement;
    }
    return this._timeAxisSubGridElement;
  }
  updateCanvasSize() {
    const me = this, {
      totalSize
    } = me.timeAxisViewModel, width = me.isHorizontal ? totalSize : me.timeAxisColumn.width;
    let result = false;
    if (me.isVertical) {
      if (me.isPainted) {
        me.refreshTotalHeight(totalSize + me._rowBorderHeight, true);
      }
      if (me.suppressFit) {
        DomHelper.setLength(me.foregroundCanvas, "height", totalSize);
      }
      result = true;
    }
    if (width !== me.$canvasWidth && me.foregroundCanvas) {
      if (me.backgroundCanvas) {
        DomHelper.setLength(me.backgroundCanvas, "width", width);
      }
      DomHelper.setLength(me.foregroundCanvas, "width", width);
      me.$canvasWidth = width;
      result = true;
    }
    return result;
  }
  getHeaderDomConfigs(configs) {
  }
  getForegroundDomConfigs(configs) {
  }
  async onStoreDataChange({
    action
  }) {
    const me = this;
    if (me.isVisible) {
      if (action === "dataset" && me.project.isRepopulatingStores) {
        await me.project.await("refresh", false);
      }
      super.onStoreDataChange(...arguments);
    } else {
      me.whenVisible("refresh", me, [true]);
    }
  }
  refresh(forceLayout = true) {
    const me = this;
    if (me.isPainted && !me.refreshSuspended) {
      if (me.hasVisibleEvents || me.timeAxisSubGridElement.querySelector(me.eventSelector)) {
        if (me.isEngineReady) {
          me.refreshRows(false, forceLayout);
        } else {
          me.refreshAfterProjectRefresh = true;
          me.currentOrientation.refreshAllWhenReady = true;
        }
      } else {
        me.rowManager.trigger("refresh");
      }
    }
  }
  render() {
    const me = this, schedulerEl = me.timeAxisSubGridElement;
    if (me.useBackgroundCanvas) {
      me._backgroundCanvas = DomHelper.createElement({
        className: "b-sch-background-canvas",
        parent: schedulerEl,
        nextSibling: schedulerEl.firstElementChild
      });
    }
    const fgCanvas = me._foregroundCanvas = DomHelper.createElement({
      className: "b-sch-foreground-canvas",
      style: `font-size:${me.rowHeight - me.resourceMargin * 2}px`,
      parent: schedulerEl
    });
    me.timeAxisSubGrid.insertRowsBefore = fgCanvas;
    if (me.isVertical && me.suppressFit) {
      me.updateCanvasSize();
    }
    super.render(...arguments);
  }
  refreshRows(returnToTop = false, reLayoutEvents = true) {
    const me = this;
    if (me.isConfiguring) {
      return;
    }
    me.currentOrientation.refreshRows(reLayoutEvents);
    super.refreshRows(returnToTop);
  }
  getCellDataFromEvent(event, includeSingleAxisMatch) {
    if (includeSingleAxisMatch) {
      includeSingleAxisMatch = !Boolean(event.target.closest(".b-sch-foreground-canvas"));
    }
    return super.getCellDataFromEvent(event, includeSingleAxisMatch);
  }
  runWithTransition(fn2, duration) {
    const me = this;
    if (me.isVisible) {
      if (duration == null || duration === true) {
        duration = me.transitionDuration;
      }
      if (duration && me.enableEventAnimations) {
        if (!me.hasTimeout("exitTransition")) {
          me.isAnimating = true;
        }
        exitTransition.delay = duration;
        me.setTimeout(exitTransition);
      }
    }
    fn2();
  }
  exitTransition() {
    this.isAnimating = false;
    this.trigger("transitionend");
  }
  async waitForAnimations() {
    if (!this.isEngineReady) {
      await this.project.await("dataReady", false);
    }
    await super.waitForAnimations();
  }
  refreshWithTransition(forceLayout, duration) {
    if (this.isPainted && !this.refreshSuspended) {
      this.runWithTransition(() => this.refresh(forceLayout), duration);
    }
  }
  get visibleDateRange() {
    return this.currentOrientation.visibleDateRange;
  }
  isRowNumberSelecting(...selectors) {
    return super.isRowNumberSelecting(...selectors) || selectors.some((cs) => {
      var _cs$cell;
      return cs.column ? cs.column.isTimeAxisColumn : (_cs$cell = cs.cell) === null || _cs$cell === void 0 ? void 0 : _cs$cell.closest(".b-timeaxis-cell");
    });
  }
  formatDuration(duration, nbrDecimals = this.durationDisplayPrecision) {
    const multiplier = Math.pow(10, nbrDecimals);
    return Math.round(duration * multiplier) / multiplier;
  }
  beginListeningForBatchedUpdates() {
    this.listenToBatchedUpdates = (this.listenToBatchedUpdates || 0) + 1;
  }
  endListeningForBatchedUpdates() {
    if (this.listenToBatchedUpdates) {
      this.listenToBatchedUpdates -= 1;
    }
  }
};
_defineProperty(TimelineBase, "configurable", {
  partnerSharedConfigs: {
    value: ["timeAxisViewModel", "timeAxis", "viewPreset"],
    $config: {
      merge: "distinct"
    }
  },
  startDate: {
    $config: {
      equal: "date"
    },
    value: null
  },
  endDate: {
    $config: {
      equal: "date"
    },
    value: null
  },
  stickyHeaders: true,
  visibleDate: null,
  eventCls: null,
  forceFit: false,
  timeZone: null
});
_defineProperty(TimelineBase, "properties", {
  timeCellSelector: null
});
TimelineBase.initClass();
VersionHelper.setVersion("scheduler", "5.3.0");
TimelineBase._$name = "TimelineBase";
var stores = ["eventStore", "taskStore", "assignmentStore", "resourceStore", "dependencyStore", "timeRangeStore", "resourceTimeRangeStore"];
var inlineProperties = ["events", "tasks", "resources", "assignments", "dependencies", "timeRanges", "resourceTimeRanges"];
var CurrentConfig = (Target) => class CurrentConfig extends Target {
  static get $name() {
    return "CurrentConfig";
  }
  preProcessCurrentConfigs(configs) {
    for (const prop of inlineProperties) {
      delete configs[prop];
    }
    super.preProcessCurrentConfigs(configs);
  }
  getCurrentConfig(options) {
    const project = this.project.getCurrentConfig(options), result = super.getCurrentConfig(options);
    if (project) {
      result.project = project;
      const {
        crudManager
      } = result;
      if (crudManager) {
        for (const store of stores) {
          if (crudManager[store]) {
            project[store] = crudManager[store];
          }
        }
      }
      if (Object.keys(project).length === 0) {
        delete result.project;
      }
    }
    delete result.data;
    delete result.crudManager;
    return result;
  }
  get widgetClass() {
  }
};
var arrayify = (format2) => !format2 || Array.isArray(format2) ? format2 : [format2];
var pickFormat = (formats2, index, defaultFormat) => formats2 && formats2[index] !== true ? formats2[index] : defaultFormat;
var Describable = (Target) => {
  var _class;
  return _class = class Describable extends (Target || Base$1) {
    get dateBounds() {
      return [this.date];
    }
    get description() {
      var _me$descriptionFormat;
      const me = this, {
        dateBounds,
        dateFormat,
        descriptionRenderer
      } = me, descriptionFormat = (_me$descriptionFormat = me.descriptionFormat) !== null && _me$descriptionFormat !== void 0 ? _me$descriptionFormat : arrayify(me.defaultDescriptionFormat);
      let end, ret;
      if (descriptionRenderer) {
        ret = me.callback(descriptionRenderer, me, [me]);
      } else {
        const format0 = pickFormat(descriptionFormat, 0, dateFormat);
        ret = DateHelper.format(dateBounds[0], format0);
        end = dateBounds.length > 1 && (descriptionFormat === null || descriptionFormat === void 0 ? void 0 : descriptionFormat.length) > 1 && DateHelper.format(dateBounds[0], format0) !== DateHelper.format(dateBounds[1], format0);
        if (end) {
          ret = DateHelper.formatRange(dateBounds, pickFormat(descriptionFormat, 1, `S${dateFormat}${me.dateSeparator}E${dateFormat}`));
        }
      }
      return ret;
    }
    changeDescriptionFormat(format2) {
      return arrayify(format2);
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "$name", "Describable"), _defineProperty(_class, "configurable", {
    dateFormat: "MMMM d, YYYY",
    dateSeparator: " - ",
    descriptionFormat: null,
    descriptionRenderer: null
  }), _class;
};
var SchedulerDom = (Target) => class SchedulerDom extends (Target || Base$1) {
  static get $name() {
    return "SchedulerDom";
  }
  getElementFromAssignmentRecord(assignmentRecord, returnWrapper = false) {
    if (this.isPainted && assignmentRecord) {
      var _this$foregroundCanva, _wrapper, _wrapper$syncIdMap;
      let wrapper = (_this$foregroundCanva = this.foregroundCanvas.syncIdMap) === null || _this$foregroundCanva === void 0 ? void 0 : _this$foregroundCanva[assignmentRecord.id];
      if (!wrapper && assignmentRecord.resource.hasLinks) {
        for (const link of assignmentRecord.resource.$links) {
          var _this$foregroundCanva2;
          wrapper = (_this$foregroundCanva2 = this.foregroundCanvas.syncIdMap) === null || _this$foregroundCanva2 === void 0 ? void 0 : _this$foregroundCanva2[`${assignmentRecord.id}_${link.id}`];
          if (wrapper) {
            break;
          }
        }
      }
      return returnWrapper ? wrapper : (_wrapper = wrapper) === null || _wrapper === void 0 ? void 0 : (_wrapper$syncIdMap = _wrapper.syncIdMap) === null || _wrapper$syncIdMap === void 0 ? void 0 : _wrapper$syncIdMap.event;
    }
    return null;
  }
  getElementFromEventRecord(eventRecord, resourceRecord = (() => {
    var _eventRecord$resource;
    return (_eventRecord$resource = eventRecord.resources) === null || _eventRecord$resource === void 0 ? void 0 : _eventRecord$resource[0];
  })(), returnWrapper = false) {
    if (eventRecord.isResourceTimeRange) {
      var _this$foregroundCanva3;
      const wrapper = (_this$foregroundCanva3 = this.foregroundCanvas.syncIdMap) === null || _this$foregroundCanva3 === void 0 ? void 0 : _this$foregroundCanva3[eventRecord.domId];
      return returnWrapper ? wrapper : wrapper === null || wrapper === void 0 ? void 0 : wrapper.syncIdMap.event;
    }
    const assignmentRecord = this.assignmentStore.getAssignmentForEventAndResource(eventRecord, resourceRecord);
    return this.getElementFromAssignmentRecord(assignmentRecord, returnWrapper);
  }
  getElementsFromEventRecord(eventRecord, resourceRecord, returnWrapper = false) {
    if (resourceRecord) {
      return [this.getElementFromEventRecord(eventRecord, resourceRecord, returnWrapper)];
    } else {
      return eventRecord.resources.reduce((result, resourceRecord2) => {
        const el = this.getElementFromEventRecord(eventRecord, resourceRecord2, returnWrapper);
        el && result.push(el);
        return result;
      }, []);
    }
  }
  resolveResourceRecord(elementOrEvent, xy) {
    return this.currentOrientation.resolveRowRecord(elementOrEvent, xy);
  }
  resolveRowRecord(elementOrEvent) {
    return this.resolveResourceRecord(elementOrEvent);
  }
  resolveEventRecord(elementOrEvent) {
    var _elementOrEvent;
    if (elementOrEvent instanceof Event) {
      elementOrEvent = elementOrEvent.target;
    }
    const element = (_elementOrEvent = elementOrEvent) === null || _elementOrEvent === void 0 ? void 0 : _elementOrEvent.closest(this.eventSelector);
    if (element) {
      if (element.dataset.eventId) {
        return this.eventStore.getById(element.dataset.eventId);
      }
      if (element.dataset.assignmentId) {
        return this.assignmentStore.getById(element.dataset.assignmentId).event;
      }
    }
    return null;
  }
  resolveTimeSpanRecord(element) {
    return this.resolveEventRecord(element);
  }
  resolveAssignmentRecord(element) {
    const eventElement = element.closest(this.eventSelector), assignmentRecord = eventElement && this.assignmentStore.getById(eventElement.dataset.assignmentId), eventRecord = eventElement && this.eventStore.getById(eventElement.dataset.eventId);
    return this.assignmentStore.getOccurrence(assignmentRecord, eventRecord);
  }
  isRowVisible(resourceRecord) {
    return this.store.indexOf(resourceRecord) >= 0;
  }
  get widgetClass() {
  }
};
var SchedulerDomEvents = (Target) => class SchedulerDomEvents extends (Target || Base$1) {
  static get $name() {
    return "SchedulerDomEvents";
  }
  getTimeSpanMouseEventParams(eventElement, event) {
    const eventRecord = this.resolveEventRecord(eventElement);
    return eventRecord && {
      eventRecord,
      resourceRecord: this.resolveResourceRecord(eventElement),
      assignmentRecord: this.resolveAssignmentRecord(eventElement),
      eventElement,
      event
    };
  }
  getScheduleMouseEventParams(cellData, event) {
    const resourceRecord = this.isVertical ? this.resolveResourceRecord(event) : this.store.getById(cellData.id);
    return {
      resourceRecord
    };
  }
  onElementKeyDown(event) {
    const result = super.onElementKeyDown(event), me = this;
    if (me.selectedEvents.length) {
      me.trigger(me.scheduledEventName + "KeyDown", {
        eventRecords: me.selectedEvents,
        assignmentRecords: me.selectedAssignments,
        event,
        eventRecord: me.selectedEvents,
        assignmentRecord: me.selectedAssignments
      });
    }
    return result;
  }
  onElementKeyUp(event) {
    super.onElementKeyUp(event);
    const me = this;
    if (me.selectedEvents.length) {
      me.trigger(me.scheduledEventName + "KeyUp", {
        eventRecords: me.selectedEvents,
        assignmentRecords: me.selectedAssignments,
        event,
        eventRecord: me.selectedEvents,
        assignmentRecord: me.selectedAssignments
      });
    }
  }
  get widgetClass() {
  }
};
var SchedulerEventRendering = (Target) => class SchedulerEventRendering extends (Target || Base$1) {
  static get $name() {
    return "SchedulerEventRendering";
  }
  static get configurable() {
    return {
      milestoneTextPosition: "outside",
      milestoneAlign: "center",
      milestoneCharWidth: 10,
      milestoneLayoutMode: "default",
      eventLayout: "stack",
      overlappingEventSorter: null,
      horizontalEventSorterFn: null,
      resourceMargin: null,
      useInitialAnimation: true,
      eventRenderer: null,
      eventRendererThisObj: null,
      eventBarTextField: "name",
      eventBodyTemplate: null,
      horizontalLayoutPackClass: HorizontalLayoutPack,
      horizontalLayoutStackClass: HorizontalLayoutStack,
      resourceColumns: null,
      resourceImagePath: null,
      defaultResourceImageName: null,
      resourceImageExtension: ".jpg",
      isFirstRender: true,
      initialAnimationDuration: 2e3,
      narrowEventWidth: 10,
      internalEventLayout: null,
      eventPositionMode: "translate",
      eventScrollMode: "move"
    };
  }
  changeEventLayout(eventLayout) {
    this.internalEventLayout = eventLayout;
    return this.internalEventLayout.type;
  }
  changeInternalEventLayout(eventLayout) {
    return this.getEventLayout(eventLayout);
  }
  updateInternalEventLayout(eventLayout, oldEventLayout) {
    const me = this;
    if (oldEventLayout) {
      me.element.classList.remove(`b-eventlayout-${oldEventLayout.type}`);
    }
    me.element.classList.add(`b-eventlayout-${eventLayout.type}`);
    if (!me.isConfiguring) {
      me.refreshWithTransition();
      me.trigger("stateChange");
    }
  }
  changeHorizontalEventSorterFn(fn2) {
    VersionHelper.deprecate("Scheduler", "6.0.0", "Replaced by overlappingEventSorter()");
    this.overlappingEventSorter = fn2;
  }
  updateOverlappingEventSorter(fn2) {
    if (!this.isConfiguring) {
      this.refreshWithTransition();
    }
  }
  getEventLayout(value) {
    var _value;
    if ((_value = value) !== null && _value !== void 0 && _value.isModel) {
      value = value.eventLayout || this.internalEventLayout;
    }
    if (typeof value === "string") {
      value = {
        type: value
      };
    }
    return value;
  }
  getEventLayoutHandler(eventLayout) {
    const me = this;
    if (!me.isHorizontal) {
      return null;
    }
    const {
      timeAxisViewModel,
      horizontal
    } = me, {
      type
    } = eventLayout;
    if (!me.layouts) {
      me.layouts = {};
    }
    switch (type) {
      case "stack": {
        if (!me.layouts.horizontalStack) {
          me.layouts.horizontalStack = new me.horizontalLayoutStackClass(ObjectHelper.assign({
            scheduler: me,
            timeAxisViewModel,
            bandIndexToPxConvertFn: horizontal.layoutEventVerticallyStack,
            bandIndexToPxConvertThisObj: horizontal
          }, eventLayout));
        }
        return me.layouts.horizontalStack;
      }
      case "pack": {
        if (!me.layouts.horizontalPack) {
          me.layouts.horizontalPack = new me.horizontalLayoutPackClass(ObjectHelper.assign({
            scheduler: me,
            timeAxisViewModel,
            bandIndexToPxConvertFn: horizontal.layoutEventVerticallyPack,
            bandIndexToPxConvertThisObj: horizontal
          }, eventLayout));
        }
        return me.layouts.horizontalPack;
      }
      default:
        return null;
    }
  }
  get resourceColumns() {
    var _this$timeAxisColumn;
    return ((_this$timeAxisColumn = this.timeAxisColumn) === null || _this$timeAxisColumn === void 0 ? void 0 : _this$timeAxisColumn.resourceColumns) || this._resourceColumns;
  }
  get resourceColumnWidth() {
    var _this$resourceColumns;
    return ((_this$resourceColumns = this.resourceColumns) === null || _this$resourceColumns === void 0 ? void 0 : _this$resourceColumns.columnWidth) || null;
  }
  getEventsToRender(resource, events) {
    return events;
  }
  repaintEventsForResource(resourceRecord) {
    this.currentOrientation.repaintEventsForResource(resourceRecord);
  }
  repaintEvent(eventRecord) {
    const resources = this.eventStore.getResourcesForEvent(eventRecord);
    resources.forEach((resourceRecord) => this.repaintEventsForResource(resourceRecord));
  }
  getResourceMargin(resourceRecord) {
    var _resourceRecord$resou;
    return (_resourceRecord$resou = resourceRecord === null || resourceRecord === void 0 ? void 0 : resourceRecord.resourceMargin) !== null && _resourceRecord$resou !== void 0 ? _resourceRecord$resou : this.resourceMargin;
  }
  getBarMargin(resourceRecord) {
    var _resourceRecord$barMa;
    return (_resourceRecord$barMa = resourceRecord === null || resourceRecord === void 0 ? void 0 : resourceRecord.barMargin) !== null && _resourceRecord$barMa !== void 0 ? _resourceRecord$barMa : this.barMargin;
  }
  getResourceHeight(resourceRecord) {
    var _resourceRecord$rowHe;
    return (_resourceRecord$rowHe = resourceRecord.rowHeight) !== null && _resourceRecord$rowHe !== void 0 ? _resourceRecord$rowHe : this.isHorizontal ? this.rowHeight : this.getResourceWidth(resourceRecord);
  }
  getResourceWidth(resourceRecord) {
    var _resourceRecord$colum;
    return (_resourceRecord$colum = resourceRecord.columnWidth) !== null && _resourceRecord$colum !== void 0 ? _resourceRecord$colum : this.resourceColumnWidth;
  }
  getAppliedResourceHeight(resourceRecord) {
    var _row$maxRequestedHeig;
    const row = this.getRowById(resourceRecord);
    return (_row$maxRequestedHeig = row === null || row === void 0 ? void 0 : row.maxRequestedHeight) !== null && _row$maxRequestedHeig !== void 0 ? _row$maxRequestedHeig : this.getResourceHeight(resourceRecord);
  }
  getResourceLayoutSettings(resourceRecord, parentEventRecord = null) {
    const resourceMargin = this.getResourceMargin(resourceRecord, parentEventRecord), rowHeight = this.getAppliedResourceHeight(resourceRecord, parentEventRecord);
    return {
      barMargin: this.getBarMargin(resourceRecord, parentEventRecord),
      contentHeight: Math.max(rowHeight - resourceMargin * 2, 1),
      rowHeight,
      resourceMargin
    };
  }
  getEventStyle(eventRecord, resourceRecord) {
    return eventRecord.eventStyle || resourceRecord.eventStyle || this.eventStyle;
  }
  getEventColor(eventRecord, resourceRecord) {
    var _eventRecord$event, _eventRecord$parent;
    return eventRecord.eventColor || ((_eventRecord$event = eventRecord.event) === null || _eventRecord$event === void 0 ? void 0 : _eventRecord$event.eventColor) || ((_eventRecord$parent = eventRecord.parent) === null || _eventRecord$parent === void 0 ? void 0 : _eventRecord$parent.eventColor) || resourceRecord.eventColor || this.eventColor;
  }
  generateRenderData(eventRecord, resourceRecord, includeOutside = {
    viewport: true
  }) {
    const me = this, renderData = me.currentOrientation.getTimeSpanRenderData(eventRecord, resourceRecord, includeOutside), {
      isEvent
    } = eventRecord, {
      eventResize
    } = me.features, isMilestone = !eventRecord.meta.isDragCreating && eventRecord.isMilestone, assignmentRecord = isEvent && eventRecord.assignments.find((a) => a.resourceId === resourceRecord.$originalId), eventContent = {
      className: "b-sch-event-content",
      role: "presentation",
      dataset: {
        taskBarFeature: "content"
      }
    };
    if (renderData) {
      var _renderData$iconCls2;
      renderData.tabIndex = "0";
      let resizable = eventRecord.isResizable;
      if (eventResize && resizable) {
        if (renderData.startsOutsideView) {
          if (resizable === true) {
            resizable = "end";
          } else if (resizable === "start") {
            resizable = false;
          }
        }
        if (renderData.endsOutsideView) {
          if (resizable === true) {
            resizable = "start";
          } else if (resizable === "end") {
            resizable = false;
          }
        }
        if (resizable) {
          if (me.isHorizontal) {
            if (!me.rtl && !eventResize.leftHandle || me.rtl && !eventResize.rightHandle) {
              resizable = resizable === "start" ? false : "end";
            } else if (!me.rtl && !eventResize.rightHandle || me.rtl && !eventResize.leftHandle) {
              resizable = resizable === "end" ? false : "start";
            }
          } else {
            if (!eventResize.topHandle) {
              resizable = resizable === "start" ? false : "end";
            } else if (!eventResize.bottomHandle) {
              resizable = resizable === "end" ? false : "start";
            }
          }
        }
      }
      const isDirty = Boolean(eventRecord.hasPersistableChanges || (assignmentRecord === null || assignmentRecord === void 0 ? void 0 : assignmentRecord.hasPersistableChanges)), clsListObj = {
        [resourceRecord.cls]: resourceRecord.cls,
        [me.generatedIdCls]: !eventRecord.isOccurrence && eventRecord.hasGeneratedId,
        [me.dirtyCls]: isDirty,
        [me.committingCls]: eventRecord.isCommitting,
        [me.endsOutsideViewCls]: renderData.endsOutsideView,
        [me.startsOutsideViewCls]: renderData.startsOutsideView,
        "b-clipped-start": renderData.clippedStart,
        "b-clipped-end": renderData.clippedEnd,
        "b-iscreating": eventRecord.isCreating,
        "b-rtl": me.rtl
      }, wrapperClsListObj = {
        [`${me.eventCls}-parent`]: resourceRecord.isParent,
        "b-readonly": eventRecord.readOnly || (assignmentRecord === null || assignmentRecord === void 0 ? void 0 : assignmentRecord.readOnly),
        "b-linked-resource": resourceRecord.isLinked,
        "b-original-resource": resourceRecord.hasLinks
      }, clsList = eventRecord.isResourceTimeRange ? new DomClassList() : eventRecord.internalCls.clone(), wrapperClsList = eventRecord.isResourceTimeRange ? eventRecord.internalCls.clone() : new DomClassList();
      renderData.wrapperStyle = "";
      renderData.isWrap = true;
      if (isEvent) {
        const selected = assignmentRecord && me.isAssignmentSelected(assignmentRecord);
        ObjectHelper.assign(clsListObj, {
          [me.eventCls]: 1,
          "b-milestone": isMilestone,
          "b-sch-event-narrow": !isMilestone && renderData.width < me.narrowEventWidth,
          [me.fixedEventCls]: eventRecord.isDraggable === false,
          [`b-sch-event-resizable-${resizable}`]: Boolean((eventResize === null || eventResize === void 0 ? void 0 : eventResize.enabled) && !eventRecord.readOnly),
          [me.eventSelectedCls]: selected,
          [me.eventAssignHighlightCls]: me.eventAssignHighlightCls && !selected && me.isEventSelected(eventRecord),
          "b-recurring": eventRecord.isRecurring,
          "b-occurrence": eventRecord.isOccurrence,
          "b-inactive": eventRecord.inactive
        });
        renderData.eventId = eventRecord.id;
        const eventStyle2 = me.getEventStyle(eventRecord, resourceRecord), eventColor2 = me.getEventColor(eventRecord, resourceRecord), hasAnimation = me.isFirstRender && me.useInitialAnimation && globalThis.bryntum.noAnimations !== true;
        ObjectHelper.assign(wrapperClsListObj, {
          [`${me.eventCls}-wrap`]: 1,
          "b-milestone-wrap": isMilestone
        });
        if (hasAnimation) {
          const index = renderData.row ? renderData.row.index : (renderData.top - me.scrollTop) / me.tickSize, delayMS = index / 20 * 1e3;
          renderData.wrapperStyle = `animation-delay: ${delayMS}ms;`;
          me.maxDelay = Math.max(me.maxDelay || 0, delayMS);
          if (!me.initialAnimationDetacher) {
            me.initialAnimationDetacher = EventHelper.on({
              element: me.foregroundCanvas,
              delegate: me.eventSelector,
              once: true,
              animationend: () => me.setTimeout({
                fn: "stopInitialAnimation",
                delay: me.maxDelay,
                cancelOutstanding: true
              }),
              expires: {
                alt: "stopInitialAnimation",
                delay: me.initialAnimationDuration + me.maxDelay
              },
              thisObj: me
            });
          }
        }
        renderData.eventColor = eventColor2;
        renderData.eventStyle = eventStyle2;
        renderData.assignmentRecord = renderData.assignment = assignmentRecord;
      }
      renderData.wrapperCls = ObjectHelper.assign(wrapperClsList, wrapperClsListObj);
      renderData.cls = ObjectHelper.assign(clsList, clsListObj);
      renderData.iconCls = new DomClassList(eventRecord.get(me.eventBarIconClsField) || eventRecord.iconCls);
      if (eventRecord.isResourceTimeRange) {
        renderData.style = "";
        renderData.wrapperStyle += eventRecord.style || "";
      } else {
        renderData.style = eventRecord.style || "";
      }
      renderData.resource = renderData.resourceRecord = resourceRecord;
      renderData.resourceId = renderData.rowId;
      if (isEvent) {
        let childContent = null, milestoneLabelConfig = null, value;
        if (me.eventRenderer) {
          const rendererValue = me.eventRenderer.call(me.eventRendererThisObj || me, {
            eventRecord,
            resourceRecord,
            assignmentRecord: renderData.assignmentRecord,
            renderData
          });
          if (typeof renderData.cls === "string") {
            renderData.cls = new DomClassList(renderData.cls);
          }
          if (typeof renderData.wrapperCls === "string") {
            renderData.wrapperCls = new DomClassList(renderData.wrapperCls);
          }
          if (typeof renderData.iconCls === "string") {
            renderData.iconCls = new DomClassList(renderData.iconCls);
          }
          if (me.eventBodyTemplate) {
            value = me.eventBodyTemplate(rendererValue);
          } else {
            value = rendererValue;
          }
        } else if (me.eventBodyTemplate) {
          value = me.eventBodyTemplate(eventRecord);
        } else if (me.eventBarTextField) {
          value = StringHelper.encodeHtml(eventRecord[me.eventBarTextField] || "");
        }
        if (!me.eventBodyTemplate || Array.isArray(value)) {
          var _renderData$iconCls;
          eventContent.children = [];
          if (isMilestone && (me.milestoneLayoutMode === "default" || me.milestoneTextPosition === "always-outside") && value != null && value !== "") {
            eventContent.children.unshift(milestoneLabelConfig = {
              tag: "label",
              children: []
            });
          }
          if ((_renderData$iconCls = renderData.iconCls) !== null && _renderData$iconCls !== void 0 && _renderData$iconCls.length) {
            eventContent.children.unshift({
              tag: "i",
              className: renderData.iconCls
            });
          }
          if (Array.isArray(value)) {
            (milestoneLabelConfig || eventContent).children.push(...value);
          } else if (StringHelper.isHtml(value)) {
            if (eventContent.children.length) {
              childContent = {
                tag: "span",
                class: "b-event-text-wrap",
                html: value
              };
            } else {
              eventContent.children = null;
              eventContent.html = value;
            }
          } else if (typeof value === "string" || typeof value === "object") {
            childContent = value;
          } else if (value != null) {
            childContent = String(value);
          }
          if (childContent != null) {
            (milestoneLabelConfig || eventContent).children.push(childContent);
            renderData.cls.add("b-has-content");
          }
          if (eventContent.html != null || eventContent.children.length) {
            renderData.children.push(eventContent);
          }
        } else {
          eventContent.html = value;
          renderData.children.push(eventContent);
        }
      }
      const {
        eventStyle,
        eventColor
      } = renderData;
      renderData.wrapperCls[`b-sch-style-${eventStyle || "none"}`] = 1;
      if (DomHelper.isNamedColor(eventColor)) {
        renderData.wrapperCls[`b-sch-color-${eventColor}`] = eventColor;
      } else if (eventColor) {
        const colorProp = eventStyle ? "color" : "background-color";
        renderData.style = `${colorProp}:${eventColor};` + renderData.style;
        renderData.wrapperCls["b-sch-custom-color"] = 1;
      } else {
        renderData.wrapperCls[`b-sch-color-none`] = 1;
      }
      if (renderData.style && isMilestone && eventContent) {
        eventContent.style = renderData.style;
        delete renderData.style;
      }
      renderData.cls["b-sch-event-withicon"] = (_renderData$iconCls2 = renderData.iconCls) === null || _renderData$iconCls2 === void 0 ? void 0 : _renderData$iconCls2.length;
      renderData.eventContent = eventContent;
      renderData.wrapperChildren = [];
      me.onEventDataGenerated(renderData);
    }
    return renderData;
  }
  onEventDataGenerated(eventData) {
  }
  changeUseInitialAnimation(name) {
    return name === true ? "fade-in" : name;
  }
  updateUseInitialAnimation(name, old) {
    const {
      classList
    } = this.element;
    if (old) {
      classList.remove(`b-initial-${old}`);
    }
    if (name) {
      classList.add(`b-initial-${name}`);
      if (BrowserHelper.isFirefox) {
        classList.add("b-prevent-event-transitions");
      }
    }
  }
  restartInitialAnimation(initialAnimation) {
    var _me$initialAnimationD;
    const me = this;
    (_me$initialAnimationD = me.initialAnimationDetacher) === null || _me$initialAnimationD === void 0 ? void 0 : _me$initialAnimationD.call(me);
    me.initialAnimationDetacher = null;
    me.useInitialAnimation = initialAnimation;
    me.isFirstRender = true;
    me.refresh();
  }
  stopInitialAnimation() {
    const me = this;
    me.initialAnimationDetacher();
    me.isFirstRender = false;
    me.useInitialAnimation = false;
    if (BrowserHelper.isFirefox) {
      me.setTimeout(() => me.element.classList.remove("b-prevent-event-transitions"), 100);
    }
  }
  getMilestoneLabelWidth(eventRecord, resourceRecord) {
    const me = this, mode = me.milestoneLayoutMode, size = me.getResourceLayoutSettings(resourceRecord).contentHeight;
    if (mode === "measure") {
      const html = StringHelper.encodeHtml(eventRecord.name), color = me.getEventColor(eventRecord, resourceRecord), style = me.getEventStyle(eventRecord, resourceRecord), element = me.milestoneMeasureElement || (me.milestoneMeasureElement = DomHelper.createElement({
        className: {
          "b-sch-event-wrap": 1,
          "b-milestone-wrap": 1,
          "b-measure": 1,
          [`b-sch-color-${color}`]: color,
          [`b-sch-style-${style}`]: style
        },
        children: [{
          className: "b-sch-event b-milestone",
          children: [{
            className: "b-sch-event-content",
            children: [{
              tag: "label"
            }]
          }]
        }],
        parent: me.foregroundCanvas
      }));
      element.retainElement = true;
      element.style.fontSize = `${size}px`;
      if (me.milestoneTextPosition === "always-outside") {
        const label = element.firstElementChild.firstElementChild.firstElementChild;
        label.innerHTML = html;
        const bounds = Rectangle.from(label, label.parentElement);
        return bounds.left + bounds.width + 2;
      } else {
        element.firstElementChild.firstElementChild.innerHTML = `<label></label>${html}`;
        return element.firstElementChild.offsetWidth;
      }
    }
    if (mode === "estimate") {
      return eventRecord.name.length * me.milestoneCharWidth + (me.milestoneTextPosition === "always-outside" ? size : 0);
    }
    if (mode === "data") {
      return eventRecord.milestoneWidth;
    }
    return 0;
  }
  updateMilestoneLayoutMode(mode) {
    const me = this, alwaysOutside = me.milestoneTextPosition === "always-outside";
    me.element.classList.toggle("b-sch-layout-milestones", mode !== "default" && !alwaysOutside);
    me.element.classList.toggle("b-sch-layout-milestone-labels", mode !== "default" && alwaysOutside);
    if (!me.isConfiguring) {
      me.refreshWithTransition();
    }
  }
  updateMilestoneTextPosition(position) {
    this.element.classList.toggle("b-sch-layout-milestone-text-position-inside", position === "inside");
    this.updateMilestoneLayoutMode(this.milestoneLayoutMode);
  }
  updateMilestoneAlign() {
    if (!this.isConfiguring) {
      this.refreshWithTransition();
    }
  }
  updateMilestoneCharWidth() {
    if (!this.isConfiguring) {
      this.refreshWithTransition();
    }
  }
  get widgetClass() {
  }
};
var SchedulerStores = (Target) => class SchedulerStores extends ProjectConsumer(Target || Base$1) {
  static get $name() {
    return "SchedulerStores";
  }
  static get projectStores() {
    return {
      resourceStore: {
        dataName: "resources"
      },
      eventStore: {
        dataName: "events",
        listeners: {
          batchedUpdate: "onEventStoreBatchedUpdate",
          changePreCommit: "onInternalEventStoreChange",
          commitStart: "onEventCommitStart",
          commit: "onEventCommit",
          exception: "onEventException",
          idchange: "onEventIdChange",
          beforeLoad: "applyStartEndParameters"
        }
      },
      assignmentStore: {
        dataName: "assignments",
        listeners: {
          changePreCommit: "onAssignmentChange",
          commitStart: "onAssignmentCommitStart",
          commit: "onAssignmentCommit",
          exception: "onAssignmentException",
          beforeRemove: {
            fn: "onAssignmentBeforeRemove",
            prio: -1e3
          }
        }
      },
      dependencyStore: {
        dataName: "dependencies"
      },
      calendarManagerStore: {},
      timeRangeStore: {},
      resourceTimeRangeStore: {}
    };
  }
  static get configurable() {
    return {
      store: null,
      startParamName: "startDate",
      endParamName: "endDate",
      passStartEndParameters: false,
      crudManagerClass: null,
      crudManager: null
    };
  }
  updateProject(project, oldProject) {
    super.updateProject(project, oldProject);
    this.detachListeners("schedulerStores");
    project.ion({
      name: "schedulerStores",
      refresh: "onProjectRefresh",
      thisObj: this
    });
  }
  onProjectRefresh({
    isInitialCommit
  }) {
    const me = this;
    if (me.isVisible) {
      if (isInitialCommit) {
        if (me.isVertical) {
          me.refreshAfterProjectRefresh = false;
          me.refreshWithTransition();
        }
      }
      if (me.navigateToAfterRefresh) {
        me.navigateTo(me.navigateToAfterRefresh);
        me.navigateToAfterRefresh = null;
      }
      if (me.refreshAfterProjectRefresh) {
        me.refreshWithTransition(false, !isInitialCommit);
        me.refreshAfterProjectRefresh = false;
      }
    } else {
      me.whenVisible("refresh", me, [true]);
    }
  }
  changeCrudManager(crudManager) {
    const me = this;
    if (crudManager && !crudManager.isCrudManager) {
      crudManager = me.crudManagerClass.new({
        scheduler: me
      }, crudManager);
    }
    me._crudManager = crudManager;
    me.bindCrudManager(crudManager);
  }
  get store() {
    if (!this._store && this.isVertical) {
      this._store = new Store({
        data: [{
          "id": "verticalTimeAxisRow",
          cls: "b-verticaltimeaxis-row"
        }]
      });
    }
    return super.store;
  }
  set store(store) {
    super.store = store;
  }
  refreshFromRowOnStoreAdd(row, {
    isExpand,
    records
  }) {
    const args = arguments;
    this.runWithTransition(() => {
      this.currentOrientation.suspended = !isExpand && !records.some((r) => r.isLinked);
      super.refreshFromRowOnStoreAdd(row, ...args);
      this.currentOrientation.suspended = false;
    }, !isExpand);
  }
  onStoreAdd(event) {
    super.onStoreAdd(event);
    if (this.isPainted) {
      this.calculateRowHeights(event.records);
    }
  }
  onStoreUpdateRecord({
    source: store,
    record,
    changes
  }) {
    let ignoreCount = 0;
    if ("assigned" in changes) {
      ignoreCount++;
    }
    if ("calendar" in changes) {
      ignoreCount++;
    }
    if (ignoreCount !== Object.keys(changes).length) {
      super.onStoreUpdateRecord(...arguments);
    }
  }
  updateResourceStore(resourceStore) {
    if (resourceStore && this.isHorizontal) {
      resourceStore.metaMapId = this.id;
      this.store = resourceStore;
    }
  }
  get usesDisplayStore() {
    return this.store !== this.resourceStore;
  }
  onEventIdChange(params) {
    this.currentOrientation.onEventStoreIdChange && this.currentOrientation.onEventStoreIdChange(params);
  }
  onEventStoreBatchedUpdate(event) {
    if (this.listenToBatchedUpdates) {
      return this.onInternalEventStoreChange(event);
    }
  }
  onInternalEventStoreChange(params) {
    if (!this.isPainted || !this._mode || params.isAssign || this.assignmentStore.isRemovingAssignment) {
      return;
    }
    this.currentOrientation.onEventStoreChange(params);
  }
  onEventCommit({
    changes
  }) {
    let resourcesToRepaint = [...changes.added, ...changes.modified].map((eventRecord) => this.eventStore.getResourcesForEvent(eventRecord));
    resourcesToRepaint = Array.prototype.concat.apply([], resourcesToRepaint);
    new Set(resourcesToRepaint).forEach((resourceRecord) => this.repaintEventsForResource(resourceRecord));
  }
  onEventCommitStart({
    changes
  }) {
    const {
      currentOrientation,
      committingCls
    } = this;
    [...changes.added, ...changes.modified].forEach((eventRecord) => eventRecord.assignments.forEach((assignmentRecord) => currentOrientation.toggleCls(assignmentRecord, committingCls, true)));
  }
  onEventException({
    action
  }) {
    if (action === "commit") {
      const {
        changes
      } = this.eventStore;
      [...changes.added, ...changes.modified, ...changes.removed].forEach((eventRecord) => this.repaintEvent(eventRecord));
    }
  }
  onAssignmentCommit({
    changes
  }) {
    this.repaintEventsForAssignmentChanges(changes);
  }
  onAssignmentCommitStart({
    changes
  }) {
    const {
      currentOrientation,
      committingCls
    } = this;
    [...changes.added, ...changes.modified].forEach((assignmentRecord) => {
      currentOrientation.toggleCls(assignmentRecord, committingCls, true);
    });
  }
  onAssignmentException({
    action
  }) {
    if (action === "commit") {
      this.repaintEventsForAssignmentChanges(this.assignmentStore.changes);
    }
  }
  repaintEventsForAssignmentChanges(changes) {
    const resourcesToRepaint = [...changes.added, ...changes.modified, ...changes.removed].map((assignmentRecord) => assignmentRecord.getResource());
    new Set(resourcesToRepaint).forEach((resourceRecord) => this.repaintEventsForResource(resourceRecord));
  }
  onAssignmentBeforeRemove({
    records,
    removingAll
  }) {
    if (removingAll) {
      return;
    }
    const me = this;
    let moveTo;
    if (!me.isConfiguring && (me.navigateToAfterRefresh || me.activeAssignment && records.includes(me.activeAssignment))) {
      if (records.includes(me.navigateToAfterRefresh)) {
        me.navigateToAfterRefresh = null;
      }
      if (GlobalEvents$1.lastInteractionType === "key") {
        for (let i = 0, l = records.length; i < l && !moveTo; i++) {
          const assignment = records[i];
          if (assignment.resource && assignment.resource.isModel) {
            let next = me.getNext(assignment);
            if (!next || records.includes(next)) {
              next = me.getPrevious(assignment);
            }
            if (next && !records.includes(next)) {
              moveTo = next;
            }
          }
        }
      }
      if (moveTo) {
        me.navigateTo(moveTo);
        me.navigateToAfterRefresh = moveTo;
      } else {
        DomHelper.focusWithoutScrolling(me.focusElement);
      }
    }
  }
  set timeRanges(timeRanges) {
    this.project.timeRanges = timeRanges;
  }
  get timeRanges() {
    return this.project.timeRanges;
  }
  set resourceTimeRanges(resourceTimeRanges) {
    this.project.resourceTimeRanges = resourceTimeRanges;
  }
  get resourceTimeRanges() {
    return this.project.resourceTimeRanges;
  }
  applyStartEndParameters({
    source: eventStore,
    params
  }) {
    const me = this, field = eventStore.modelClass.fieldMap.startDate;
    if (me.passStartEndParameters) {
      params[me.startParamName] = field.print(me.startDate);
      params[me.endParamName] = field.print(me.endDate);
    }
  }
  getResourcesEventsPerTick(resources, filterFn) {
    const {
      timeAxis,
      resourceStore
    } = this, eventsByTick = [];
    resources = resources || resourceStore.records;
    resources.forEach((resource) => {
      resource.events.forEach((event) => {
        if (!timeAxis.isTimeSpanInAxis(event) || filterFn && !filterFn.call(this, {
          resource,
          event
        })) {
          return;
        }
        let startTick = Math.floor(timeAxis.getTickFromDate(event.startDate)), endTick = Math.ceil(timeAxis.getTickFromDate(event.endDate));
        if (startTick == -1) {
          startTick = 0;
        }
        if (endTick === -1) {
          endTick = timeAxis.ticks.length;
        }
        do {
          if (!eventsByTick[startTick]) {
            eventsByTick[startTick] = [event];
          } else {
            eventsByTick[startTick].push(event);
          }
        } while (++startTick < endTick);
      });
    });
    return eventsByTick;
  }
  get widgetClass() {
  }
};
var defaultScrollOptions = {
  block: "nearest",
  edgeOffset: 20
};
var unrenderedScrollOptions = {
  highlight: false,
  focus: false
};
var SchedulerScroll = (Target) => class SchedulerScroll extends (Target || Base$1) {
  static get $name() {
    return "SchedulerScroll";
  }
  async scrollEventIntoView(eventRecord, options = defaultScrollOptions) {
    const me = this, resources = eventRecord.resources || [eventRecord];
    if (resources.length > 1) {
      throw new Error("scrollEventIntoView() is not applicable for events with multiple assignments, please use scrollResourceEventIntoView() instead.");
    }
    if (!resources.length) {
      console.warn("You have asked to scroll to an event which is not assigned to a resource");
    }
    await me.scrollResourceEventIntoView(resources[0], eventRecord, options);
  }
  scrollAssignmentIntoView(assignmentRecord, ...args) {
    return this.scrollResourceEventIntoView(assignmentRecord.resource, assignmentRecord.event, ...args);
  }
  async scrollResourceEventIntoView(resourceRecord, eventRecord, options = defaultScrollOptions) {
    const me = this, eventStart = eventRecord.startDate, eventEnd = eventRecord.endDate, eventIsOutside = eventRecord.isScheduled && eventStart < me.timeAxis.startDate | (eventEnd > me.timeAxis.endDate) << 1;
    if (arguments.length > 3) {
      options = arguments[3];
    }
    let el;
    if (options.edgeOffset == null) {
      options.edgeOffset = 20;
    }
    if (eventIsOutside && options.extendTimeAxis !== false) {
      const currentTimeSpanRange = me.timeAxis.endDate - me.timeAxis.startDate;
      if (eventIsOutside === 3) {
        me.setTimeSpan(new Date(eventStart.valueOf() - currentTimeSpanRange / 2), new Date(eventEnd.getTime() + currentTimeSpanRange / 2));
      } else {
        if (eventIsOutside & 1) {
          me.setTimeSpan(new Date(eventStart), new Date(eventStart.valueOf() + currentTimeSpanRange));
        } else {
          me.setTimeSpan(new Date(eventEnd.valueOf() - currentTimeSpanRange), new Date(eventEnd));
        }
      }
    }
    if (me.store.tree) {
      var _me$expandTo;
      await ((_me$expandTo = me.expandTo) === null || _me$expandTo === void 0 ? void 0 : _me$expandTo.call(me, resourceRecord));
    }
    if (eventRecord.parent && !eventRecord.parent.isRoot) {
      await this.scrollEventIntoView(eventRecord.parent);
    }
    el = me.getElementFromEventRecord(eventRecord, resourceRecord);
    if (el) {
      if (!DomHelper.isFocusable(el)) {
        el = el.parentNode;
      }
      const scroller = me.timeAxisSubGrid.scrollable;
      me.timeAxisSubGrid.forceScrollUpdate = true;
      await scroller.scrollIntoView(el, options);
    } else if (eventIsOutside && options.extendTimeAxis === false) {
      console.warn("You have asked to scroll to an event which is outside the current view and extending timeaxis is disabled");
    } else if (!eventRecord.isOccurrence && !me.eventStore.isAvailable(eventRecord)) {
      console.warn("You have asked to scroll to an event which is not available");
    } else if (eventRecord.isScheduled) {
      await me.scrollUnrenderedEventIntoView(resourceRecord, eventRecord, options);
    } else {
      await me.scrollResourceIntoView(resourceRecord, options);
    }
  }
  scrollUnrenderedEventIntoView(resourceRec, eventRec, options = defaultScrollOptions) {
    return new Promise((resolve) => {
      const me = this, modifiedOptions = Object.assign({
        edgeOffset: 20
      }, options, unrenderedScrollOptions), scroller = me.timeAxisSubGrid.scrollable, box = me.getResourceEventBox(eventRec, resourceRec), scrollerViewport = scroller.viewport;
      if (!scrollerViewport || !box) {
        resolve();
        return;
      }
      box.x = Math.ceil(box.x);
      box.y = Math.ceil(box.y);
      if (me.rtl) {
        box.translate(-me.timeAxisViewModel.totalSize + scrollerViewport.width, 0);
      }
      box.translate(scrollerViewport.x - scroller.scrollLeft, scrollerViewport.y - scroller.y);
      const onEventRender = async ({
        eventRecord,
        element,
        targetElement
      }) => {
        if (eventRecord === eventRec) {
          const el = element || targetElement;
          detacher2();
          await initialScrollPromise;
          options.highlight && DomHelper.highlight(el);
          options.focus && el.focus();
          resolve();
        }
      }, detacher2 = me.ion({
        renderEvent: onEventRender
      }), initialScrollPromise = scroller.scrollIntoView(box, modifiedOptions);
    });
  }
  scrollResourceIntoView(resourceRecord, options = defaultScrollOptions) {
    if (this.isVertical) {
      return this.currentOrientation.scrollResourceIntoView(resourceRecord, options);
    } else {
      return this.scrollRowIntoView(resourceRecord, options);
    }
  }
  get widgetClass() {
  }
};
var SchedulerRegions = (Target) => class SchedulerRegions extends (Target || Base$1) {
  static get $name() {
    return "SchedulerRegions";
  }
  getScheduleRegion(resourceRecord, eventRecord, local = true, dateConstraints) {
    return this.currentOrientation.getScheduleRegion(...arguments);
  }
  getResourceRegion(resourceRecord, startDate, endDate) {
    return this.currentOrientation.getRowRegion(...arguments);
  }
  getAssignmentEventBox(assignmentRecord, includesOutside) {
    return this.getResourceEventBox(assignmentRecord.event, assignmentRecord.resource, includesOutside);
  }
  getResourceEventBox(eventRecord, resourceRecord, includeOutside = false, roughly = false) {
    return this.currentOrientation.getResourceEventBox(...arguments);
  }
  getItemBox(event, includeOutside = false) {
    return event.resources.map((resource) => this.getResourceEventBox(event, resource, includeOutside));
  }
  get widgetClass() {
  }
};
var copyProperties = ["eventLayout", "mode", "eventColor", "eventStyle", "tickSize", "fillTicks"];
var SchedulerState = (Target) => class SchedulerState extends (Target || Base$1) {
  static get $name() {
    return "SchedulerState";
  }
  getState() {
    return ObjectHelper.copyProperties(super.getState(), this, copyProperties);
  }
  applyState(state) {
    var _state$zoomLevelOptio;
    this.suspendRefresh();
    let propsToCopy = copyProperties.slice();
    if ((state === null || state === void 0 ? void 0 : state.eventLayout) === "layoutFn") {
      delete state.eventLayout;
      propsToCopy.splice(propsToCopy.indexOf("eventLayout"), 1);
    }
    if (state !== null && state !== void 0 && (_state$zoomLevelOptio = state.zoomLevelOptions) !== null && _state$zoomLevelOptio !== void 0 && _state$zoomLevelOptio.width) {
      propsToCopy = propsToCopy.filter((p) => p !== "tickSize");
    }
    ObjectHelper.copyProperties(this, state, propsToCopy);
    super.applyState(state);
    this.resumeRefresh(true);
  }
  get widgetClass() {
  }
};
var SchedulerEventSelection = (Target) => class EventSelection extends (Target || Base$1) {
  static get $name() {
    return "EventSelection";
  }
  static get configurable() {
    return {
      highlightPredecessors: false,
      highlightSuccessors: false,
      deselectOnClick: false
    };
  }
  static get defaultConfig() {
    return {
      multiEventSelect: false,
      eventSelectionDisabled: false,
      eventSelectedCls: "b-sch-event-selected",
      triggerSelectionChangeOnRemove: false,
      maintainSelectionOnDatasetChange: true,
      eventAssignHighlightCls: "b-sch-event-assign-selected",
      selectedCollection: {}
    };
  }
  afterConstruct() {
    var _this$navigator;
    super.afterConstruct();
    (_this$navigator = this.navigator) === null || _this$navigator === void 0 ? void 0 : _this$navigator.ion({
      navigate: "onEventNavigate",
      thisObj: this
    });
  }
  set selectedCollection(selectedCollection) {
    if (!(selectedCollection instanceof Collection)) {
      selectedCollection = new Collection(selectedCollection);
    }
    this._selectedCollection = selectedCollection;
    selectedCollection.ion({
      change: (...args) => this.project.deferUntilRepopulationIfNeeded("onSelectedCollectionChange", (...args2) => !this.isDestroying && this.onSelectedCollectionChange(...args2), args),
      beforeSplice: "onBeforeSelectedCollectionSplice",
      thisObj: this
    });
  }
  get selectedCollection() {
    return this._selectedCollection;
  }
  getActionType(selection, selected, deselected) {
    return selection.length > 0 ? selected.length > 0 && deselected.length > 0 ? "update" : selected.length > 0 ? "select" : "deselect" : "clear";
  }
  getEventsFromAssignments(assignments) {
    return ArrayHelper.unique(assignments.map((assignment) => assignment.event));
  }
  get selectedEvents() {
    return this.getEventsFromAssignments(this.selectedCollection.values);
  }
  set selectedEvents(events) {
    var _events;
    const assignments = [];
    events = ArrayHelper.asArray(events);
    (_events = events) === null || _events === void 0 ? void 0 : _events.forEach((event) => {
      if (this.isEventSelectable(event) !== false) {
        assignments.push(...event.assignments);
      }
    });
    this.selectedCollection.splice(0, this.selectedCollection.count, assignments);
  }
  get selectedAssignments() {
    return this.selectedCollection.values;
  }
  set selectedAssignments(assignments) {
    this.selectedCollection.splice(0, this.selectedCollection.count, assignments || []);
  }
  isEventSelected(event) {
    const {
      selectedCollection
    } = this;
    return Boolean(selectedCollection.count && selectedCollection.includes(event.assignments));
  }
  isEventSelectable(event) {
  }
  isAssignmentSelected(assignment) {
    return this.selectedCollection.includes(assignment);
  }
  select(eventOrAssignment, preserveSelection = false) {
    if (eventOrAssignment.isAssignment) {
      this.selectAssignment(eventOrAssignment, preserveSelection);
    } else {
      this.selectEvent(eventOrAssignment, preserveSelection);
    }
  }
  selectEvent(event, preserveSelection = false) {
    if (!this.isEventSelected(event)) {
      this.selectEvents([event], preserveSelection);
    }
  }
  selectAssignment(assignment, preserveSelection = false, event) {
    if (!this.isAssignmentSelected(assignment)) {
      preserveSelection ? this.selectedCollection.add(assignment) : this.selectedAssignments = assignment;
    }
  }
  deselect(eventOrAssignment) {
    if (eventOrAssignment.isAssignment) {
      this.deselectAssignment(eventOrAssignment);
    } else {
      this.deselectEvent(eventOrAssignment);
    }
  }
  deselectEvent(event) {
    if (this.isEventSelected(event)) {
      this.selectedCollection.remove(...event.assignments);
    }
  }
  deselectAssignment(assignment) {
    if (this.isAssignmentSelected(assignment)) {
      this.selectedCollection.remove(assignment);
    }
  }
  selectEvents(events, preserveSelection = false) {
    if (preserveSelection) {
      const assignments = events.reduce((assignments2, event) => {
        if (this.isEventSelectable(event) !== false) {
          assignments2.push(...event.assignments);
        }
        return assignments2;
      }, []);
      this.selectedCollection.add(assignments);
    } else {
      this.selectedEvents = events;
    }
  }
  deselectEvents(events) {
    this.selectedCollection.remove(events.reduce((assignments, event) => {
      assignments.push(...event.assignments);
      return assignments;
    }, []));
  }
  selectAssignments(assignments) {
    this.selectedCollection.add(assignments);
  }
  deselectAssignments(assignments) {
    this.selectedCollection.remove(assignments);
  }
  clearEventSelection() {
    this.selectedAssignments = [];
  }
  onBeforeSelectedCollectionSplice({
    toAdd,
    toRemove,
    index
  }) {
    const me = this, selection = me._selectedCollection.values, selected = toAdd, deselected = toRemove > 0 ? selected.slice(index, toRemove + index) : [], action = me.getActionType(selection, selected, deselected);
    if (me.trigger("beforeEventSelectionChange", {
      action,
      selection: me.getEventsFromAssignments(selection) || [],
      selected: me.getEventsFromAssignments(selected) || [],
      deselected: me.getEventsFromAssignments(deselected) || []
    }) === false) {
      return false;
    }
    if (me.trigger("beforeAssignmentSelectionChange", {
      action,
      selection,
      selected,
      deselected
    }) === false) {
      return false;
    }
  }
  onSelectedCollectionChange({
    added,
    removed
  }) {
    const me = this, selection = me.selectedAssignments, selected = added || [], deselected = removed || [];
    function updateSelection(assignmentRecord, select) {
      const eventRecord = assignmentRecord.event;
      if (eventRecord) {
        const {
          eventAssignHighlightCls
        } = me, element = me.getElementFromAssignmentRecord(assignmentRecord);
        me.currentOrientation.toggleCls(assignmentRecord, me.eventSelectedCls, select);
        eventAssignHighlightCls && me.getElementsFromEventRecord(eventRecord).forEach((el) => {
          if (el !== element) {
            const otherAssignmentRecord = me.resolveAssignmentRecord(el);
            me.currentOrientation.toggleCls(otherAssignmentRecord, eventAssignHighlightCls, select);
            if (select) {
              el.style.animation = "none";
              el.offsetHeight;
              el.style.animation = "";
            }
            el.classList.toggle(eventAssignHighlightCls, select);
          }
        });
      }
    }
    deselected.forEach((record) => updateSelection(record, false));
    selected.forEach((record) => updateSelection(record, true));
    if (me.highlightSuccessors || me.highlightPredecessors) {
      me.highlightLinkedEvents(me.selectedEvents);
    }
    me.$selectedAssignments = selection.map((assignment) => ({
      eventId: assignment.eventId,
      resourceId: assignment.resourceId
    }));
    if (!me.silent) {
      const action = this.getActionType(selection, selected, deselected);
      me.trigger("assignmentSelectionChange", {
        action,
        selection,
        selected,
        deselected
      });
      me.trigger("eventSelectionChange", {
        action,
        selection: me.selectedEvents,
        selected: me.getEventsFromAssignments(selected),
        deselected: me.getEventsFromAssignments(deselected)
      });
    }
  }
  onAssignmentChange(event) {
    super.onAssignmentChange(event);
    const me = this, {
      action,
      records: assignments
    } = event;
    me.silent = !me.triggerSelectionChangeOnRemove;
    if (action === "remove") {
      me.deselectAssignments(assignments);
    } else if (action === "removeall" && !me.eventStore.isSettingData) {
      me.clearEventSelection();
    } else if (action === "dataset" && me.$selectedAssignments) {
      if (!me.maintainSelectionOnDatasetChange) {
        me.clearEventSelection();
      } else {
        const newAssignments = me.$selectedAssignments.map((selector) => assignments.find((a) => a.eventId === selector.eventId && a.resourceId === selector.resourceId));
        me.selectedAssignments = ArrayHelper.clean(newAssignments);
      }
    }
    me.silent = false;
  }
  onInternalEventStoreChange({
    source,
    action,
    records
  }) {
    if (!source.isResourceTimeRangeStore && action === "dataset" && !records.length) {
      this.clearEventSelection();
    }
    super.onInternalEventStoreChange(...arguments);
  }
  onAssignmentSelectionClick(event, clickedRecord) {
    const me = this;
    if (me.isAssignmentSelected(clickedRecord)) {
      if (me.deselectOnClick || event.ctrlKey) {
        me.deselectAssignment(clickedRecord, me.multiEventSelect, event);
      }
    } else if (this.isEventSelectable(clickedRecord.event) !== false) {
      me.selectAssignment(clickedRecord, event.ctrlKey && me.multiEventSelect, event);
    }
  }
  onEventNavigate({
    event,
    item
  }) {
    if (!this.eventSelectionDisabled) {
      const assignment = item && (item.nodeType === Element.ELEMENT_NODE ? this.resolveAssignmentRecord(item) : item);
      if (assignment) {
        this.onAssignmentSelectionClick(event, assignment);
      } else {
        this.clearEventSelection();
      }
    }
  }
  changeHighlightSuccessors(value) {
    return this.changeLinkedEvents(value);
  }
  changeHighlightPredecessors(value) {
    return this.changeLinkedEvents(value);
  }
  changeLinkedEvents(value) {
    const me = this;
    if (value) {
      me.highlighted = me.highlighted || /* @__PURE__ */ new Set();
      me.highlightLinkedEvents(me.selectedEvents);
    } else if (me.highlighted) {
      me.highlightLinkedEvents();
    }
    return value;
  }
  highlightLinkedEvents(eventRecords = []) {
    const me = this, {
      highlighted,
      eventStore
    } = me, dependenciesFeature = me.features.dependencies;
    highlighted.forEach((eventRecord) => {
      if (!eventRecords.includes(eventRecord)) {
        eventRecord.meta.highlight = false;
        highlighted.delete(eventRecord);
        if (eventStore.includes(eventRecord)) {
          eventRecord.dependencies.forEach((dep) => dependenciesFeature.unhighlight(dep, "b-highlight"));
        }
      }
    });
    eventRecords.forEach((eventRecord) => {
      const toWalk = [eventRecord];
      while (toWalk.length) {
        const record = toWalk.pop();
        highlighted.add(record);
        if (me.highlightSuccessors) {
          record.outgoingDeps.forEach((outgoing) => {
            dependenciesFeature.highlight(outgoing, "b-highlight");
            !highlighted.has(outgoing.toEvent) && toWalk.push(outgoing.toEvent);
          });
        }
        if (me.highlightPredecessors) {
          record.incomingDeps.forEach((incoming) => {
            dependenciesFeature.highlight(incoming, "b-highlight");
            !highlighted.has(incoming.fromEvent) && toWalk.push(incoming.fromEvent);
          });
        }
      }
      highlighted.forEach((record) => record.meta.highlight = true);
    });
    me.element.classList.toggle("b-highlighting", eventRecords.length > 0);
    me.refreshWithTransition();
  }
  onEventDataGenerated(renderData) {
    if (this.highlightSuccessors || this.highlightPredecessors) {
      renderData.cls["b-highlight"] = renderData.eventRecord.meta.highlight;
    }
    super.onEventDataGenerated(renderData);
  }
  updateProject(project, old) {
    this.clearEventSelection();
    super.updateProject(project, old);
  }
  doDestroy() {
    var _this$_selectedCollec;
    (_this$_selectedCollec = this._selectedCollection) === null || _this$_selectedCollec === void 0 ? void 0 : _this$_selectedCollec.destroy();
    super.doDestroy();
  }
  get widgetClass() {
  }
};
var preventDefault$1 = (e) => e.preventDefault();
var isArrowKey = {
  ArrowRight: 1,
  ArrowLeft: 1,
  ArrowUp: 1,
  ArrowDown: 1
};
var animate100 = {
  animate: 100
};
var emptyObject$3 = Object.freeze({});
var SchedulerEventNavigation = (Target) => class EventNavigation extends Delayable(Target || Base$1) {
  static get $name() {
    return "EventNavigation";
  }
  static get configurable() {
    return {
      navigator: {
        allowCtrlKey: true,
        scrollSilently: true,
        keys: {
          Space: "onEventSpaceKey",
          Enter: "onEventEnterKey",
          Delete: "onDeleteKey",
          Backspace: "onDeleteKey",
          ArrowUp: "onArrowUpKey",
          ArrowDown: "onArrowDownKey",
          Escape: "onEscapeKey",
          Tab: "onTab",
          "SHIFT+Tab": "onShiftTab"
        }
      },
      isNavigationKey: {
        ArrowDown: 1,
        ArrowUp: 1,
        ArrowLeft: 1,
        ArrowRight: 1
      }
    };
  }
  static get defaultConfig() {
    return {
      focusCls: "b-active",
      enableDeleteKey: true,
      onDeleteKeyBuffer: 500,
      navigatePreviousBuffer: 200,
      navigateNextBuffer: 200,
      testConfig: {
        onDeleteKeyBuffer: 1
      }
    };
  }
  construct(config) {
    const me = this;
    me.isInTimeAxis = me.isInTimeAxis.bind(me);
    me.onDeleteKey = me.throttle(me.onDeleteKey, me.onDeleteKeyBuffer, me);
    super.construct(config);
  }
  changeNavigator(navigator2) {
    const me = this;
    me.getConfig("subGridConfigs");
    return new Navigator(me.constructor.mergeConfigs({
      ownerCmp: me,
      target: me.timeAxisSubGridElement,
      processEvent: me.processEvent,
      itemSelector: `.${me.eventCls}-wrap`,
      focusCls: me.focusCls,
      navigatePrevious: me.throttle(me.navigatePrevious, {
        delay: me.navigatePreviousBuffer,
        throttled: preventDefault$1
      }),
      navigateNext: me.throttle(me.navigateNext, {
        delay: me.navigateNextBuffer,
        throttled: preventDefault$1
      })
    }, navigator2));
  }
  doDestroy() {
    this.navigator.destroy();
    super.doDestroy();
  }
  isInTimeAxis(record) {
    return !record.instanceMeta(this).excluded && this.timeAxis.isTimeSpanInAxis(record);
  }
  onElementKeyDown(keyEvent) {
    var _me$focusedCell, _me$focusedCell2;
    const me = this, {
      navigator: navigator2
    } = me;
    if (((_me$focusedCell = me.focusedCell) === null || _me$focusedCell === void 0 ? void 0 : _me$focusedCell.rowIndex) !== -1 && ((_me$focusedCell2 = me.focusedCell) === null || _me$focusedCell2 === void 0 ? void 0 : _me$focusedCell2.column) === me.timeAxisColumn && !keyEvent.target.closest(navigator2.itemSelector) && keyEvent.key === "Enter") {
      const firstAssignment = me.getFirstVisibleAssignment();
      if (firstAssignment) {
        me.navigateTo(firstAssignment, {
          uiEvent: keyEvent
        });
        return false;
      }
    } else {
      var _super$onElementKeyDo;
      (_super$onElementKeyDo = super.onElementKeyDown) === null || _super$onElementKeyDo === void 0 ? void 0 : _super$onElementKeyDo.call(this, keyEvent);
    }
  }
  getFirstVisibleAssignment(location = this.focusedCell) {
    const me = this, {
      currentOrientation,
      rowManager,
      eventStore
    } = me;
    if (me.isHorizontal) {
      var _renderedEvents;
      let renderedEvents = currentOrientation.rowMap.get(rowManager.getRow(location.rowIndex));
      if ((_renderedEvents = renderedEvents) !== null && _renderedEvents !== void 0 && _renderedEvents.length) {
        var _renderedEvents$;
        return (_renderedEvents$ = renderedEvents[0]) === null || _renderedEvents$ === void 0 ? void 0 : _renderedEvents$.elementData.assignmentRecord;
      } else {
        var _currentOrientation$r, _renderedEvents2;
        renderedEvents = (_currentOrientation$r = currentOrientation.resourceMap.get(location.id)) === null || _currentOrientation$r === void 0 ? void 0 : _currentOrientation$r.eventsData;
        if ((_renderedEvents2 = renderedEvents) !== null && _renderedEvents2 !== void 0 && _renderedEvents2.length) {
          var _renderedEvents$filte;
          return (_renderedEvents$filte = renderedEvents.filter((e) => eventStore.isAvailable(e.eventRecord))[0]) === null || _renderedEvents$filte === void 0 ? void 0 : _renderedEvents$filte.assignmentRecord;
        }
      }
    } else {
      const firstResource = [...currentOrientation.resourceMap.values()][0], renderedEvents = firstResource && Object.values(firstResource);
      if (renderedEvents !== null && renderedEvents !== void 0 && renderedEvents.length) {
        return renderedEvents.filter((e) => eventStore.isAvailable(e.renderData.eventRecord))[0].renderData.assignmentRecord;
      }
    }
  }
  onGridBodyFocusIn(focusEvent) {
    const isGridCellFocus = focusEvent.target.closest(this.focusableSelector);
    if (this.timeAxisSubGridElement.contains(focusEvent.target)) {
      const me = this, {
        navigationEvent
      } = me, {
        target
      } = focusEvent, eventFocus = target.closest(me.navigator.itemSelector), destinationCell = eventFocus ? me.normalizeCellContext({
        rowIndex: me.isVertical ? 0 : me.resourceStore.indexOf(me.resolveResourceRecord(target)),
        column: me.timeAxisColumn,
        target
      }) : new Location(target);
      if (eventFocus) {
        var _me$onCellNavigate;
        const {
          _focusedCell
        } = me;
        me._focusedCell = destinationCell;
        (_me$onCellNavigate = me.onCellNavigate) === null || _me$onCellNavigate === void 0 ? void 0 : _me$onCellNavigate.call(me, me, _focusedCell, destinationCell, navigationEvent, true);
        return;
      }
      if (isGridCellFocus && (!navigationEvent || isArrowKey[navigationEvent.key])) {
        const firstAssignment = me.getFirstVisibleAssignment(destinationCell);
        if (firstAssignment) {
          me.navigateTo(firstAssignment, {
            scrollIntoView: Boolean(navigationEvent && navigationEvent.type !== "mousedown"),
            uiEvent: navigationEvent || focusEvent
          });
          return;
        }
      }
    }
    if (isGridCellFocus) {
      super.onGridBodyFocusIn(focusEvent);
    }
  }
  accessibleFocusCell(cellSelector, options) {
    const me = this;
    cellSelector = me.normalizeCellContext(cellSelector);
    if (cellSelector.columnId === me.timeAxisColumn.id)
      ;
    else {
      return super.focusCell(cellSelector, options);
    }
  }
  normalizeTarget(event) {
    return event.assignmentRecord;
  }
  getPrevious(assignmentRecord, isDelete) {
    const me = this, {
      resourceStore
    } = me, {
      eventSorter
    } = me.currentOrientation, {
      startDate,
      endDate
    } = me.timeAxis, eventRecord = assignmentRecord.event, resourceEvents = me.eventStore.getEvents({
      resourceRecord: assignmentRecord.resource,
      startDate,
      endDate
    }).filter(this.isInTimeAxis).sort(eventSorter);
    let resourceRecord = assignmentRecord.resource, previousEvent = resourceEvents[resourceEvents.indexOf(eventRecord) - 1];
    if (!previousEvent) {
      for (let rowIdx = resourceStore.indexOf(resourceRecord) - 1; (!previousEvent || isDelete && previousEvent === eventRecord) && rowIdx >= 0; rowIdx--) {
        resourceRecord = resourceStore.getAt(rowIdx);
        const events = me.eventStore.getEvents({
          resourceRecord,
          startDate,
          endDate
        }).filter(me.isInTimeAxis).sort(eventSorter);
        previousEvent = events.length && events[events.length - 1];
      }
    }
    return me.assignmentStore.getAssignmentForEventAndResource(previousEvent, resourceRecord);
  }
  navigatePrevious(keyEvent) {
    const me = this, previousAssignment = me.getPrevious(me.normalizeTarget(keyEvent));
    keyEvent.preventDefault();
    if (previousAssignment) {
      if (!keyEvent.ctrlKey) {
        me.clearEventSelection();
      }
      return me.navigateTo(previousAssignment, {
        uiEvent: keyEvent
      });
    }
    return me.doGridNavigation(keyEvent);
  }
  getNext(assignmentRecord, isDelete) {
    const me = this, {
      resourceStore
    } = me, {
      eventSorter
    } = me.currentOrientation, {
      startDate,
      endDate
    } = me.timeAxis, eventRecord = assignmentRecord.event, resourceEvents = me.eventStore.getEvents({
      resourceRecord: assignmentRecord.resource,
      startDate,
      endDate
    }).filter(this.isInTimeAxis).sort(eventSorter);
    let resourceRecord = assignmentRecord.resource, nextEvent = resourceEvents[resourceEvents.indexOf(eventRecord) + 1];
    if (!nextEvent) {
      for (let rowIdx = resourceStore.indexOf(resourceRecord) + 1; (!nextEvent || isDelete && nextEvent === eventRecord) && rowIdx < resourceStore.count; rowIdx++) {
        resourceRecord = resourceStore.getAt(rowIdx);
        const events = me.eventStore.getEvents({
          resourceRecord,
          startDate,
          endDate
        }).filter(me.isInTimeAxis).sort(eventSorter);
        nextEvent = events[0];
      }
    }
    return me.assignmentStore.getAssignmentForEventAndResource(nextEvent, resourceRecord);
  }
  navigateNext(keyEvent) {
    const me = this, nextAssignment = me.getNext(me.normalizeTarget(keyEvent));
    keyEvent.preventDefault();
    if (nextAssignment) {
      if (!keyEvent.ctrlKey) {
        me.clearEventSelection();
      }
      return me.navigateTo(nextAssignment, {
        uiEvent: keyEvent
      });
    }
    return me.doGridNavigation(keyEvent);
  }
  doGridNavigation(keyEvent) {
    if (!keyEvent.handled && keyEvent.key.indexOf("Arrow") === 0) {
      this[`navigate${keyEvent.key.substring(5)}ByKey`](keyEvent);
    }
  }
  async navigateTo(targetAssignment, {
    scrollIntoView = true,
    uiEvent = {}
  } = emptyObject$3) {
    const me = this, {
      navigator: navigator2
    } = me, {
      skipScrollIntoView
    } = navigator2;
    if (targetAssignment) {
      if (scrollIntoView) {
        navigator2.disabled = true;
        await me.scrollAssignmentIntoView(targetAssignment, animate100);
        navigator2.disabled = false;
      } else {
        navigator2.skipScrollIntoView = true;
      }
      if (!me.isDestroyed && this.getElementFromAssignmentRecord(targetAssignment)) {
        me.activeAssignment = targetAssignment;
        navigator2.skipScrollIntoView = skipScrollIntoView;
        navigator2.trigger("navigate", {
          event: uiEvent,
          item: me.getElementFromAssignmentRecord(targetAssignment).closest(navigator2.itemSelector)
        });
      }
    }
  }
  set activeAssignment(assignmentRecord) {
    const assignmentEl = this.getElementFromAssignmentRecord(assignmentRecord, true);
    if (assignmentEl) {
      this.navigator.activeItem = assignmentEl;
    }
  }
  get activeAssignment() {
    const {
      activeItem
    } = this.navigator;
    if (activeItem) {
      return this.resolveAssignmentRecord(activeItem);
    }
  }
  get previousActiveEvent() {
    const {
      previousActiveItem
    } = this.navigator;
    if (previousActiveItem) {
      return this.resolveEventRecord(previousActiveItem);
    }
  }
  processEvent(keyEvent) {
    const me = this, eventElement = keyEvent.target.closest(me.eventSelector);
    if (!me.navigator.disabled && eventElement) {
      keyEvent.assignmentRecord = me.resolveAssignmentRecord(eventElement);
      keyEvent.eventRecord = me.resolveEventRecord(eventElement);
      keyEvent.resourceRecord = me.resolveResourceRecord(eventElement);
    }
    return keyEvent;
  }
  onDeleteKey(keyEvent) {
    const me = this;
    if (!me.readOnly && me.enableDeleteKey) {
      const records = me.eventStore.usesSingleAssignment ? me.selectedEvents : me.selectedAssignments;
      me.removeEvents(records.filter((r) => !r.readOnly));
    }
  }
  onArrowUpKey(keyEvent) {
    this.focusCell({
      rowIndex: this.focusedCell.rowIndex - 1,
      column: this.timeAxisColumn
    });
    keyEvent.handled = true;
  }
  onArrowDownKey(keyEvent) {
    if (this.focusedCell.rowIndex < this.resourceStore.count - 1) {
      this.focusCell({
        rowIndex: this.focusedCell.rowIndex + 1,
        column: this.timeAxisColumn
      });
      keyEvent.handled = true;
    }
  }
  onEscapeKey(keyEvent) {
    if (!keyEvent.target.closest(".b-dragging")) {
      this.focusCell({
        rowIndex: this.focusedCell.rowIndex,
        column: this.timeAxisColumn
      });
      keyEvent.handled = true;
    }
  }
  onEventSpaceKey(keyEvent) {
  }
  onEventEnterKey(keyEvent) {
  }
  get isActionableLocation() {
    if (!this.navigator.activeItem) {
      return super.isActionableLocation;
    }
  }
  get widgetClass() {
  }
};
var releaseEventActions$1 = {
  releaseElement: 1,
  reuseElement: 1
};
var renderEventActions$1 = {
  newElement: 1,
  reuseOwnElement: 1,
  reuseElement: 1
};
var MAX_WIDTH = 9999999;
var heightEventSorter = ({
  startDateMS: lhs
}, {
  startDateMS: rhs
}) => lhs - rhs;
var chronoFields$1 = {
  startDate: 1,
  endDate: 1,
  duration: 1
};
function getStartEnd(scheduler, eventRecord, useEnd, fieldName, useEventBuffer) {
  var _eventRecord$hasBatch;
  const {
    timeAxis
  } = scheduler, date2 = eventRecord.isBatchUpdating && !useEventBuffer ? eventRecord.get(fieldName) : eventRecord[fieldName], hasBatchedChange = (_eventRecord$hasBatch = eventRecord.hasBatchedChange) === null || _eventRecord$hasBatch === void 0 ? void 0 : _eventRecord$hasBatch.call(eventRecord, fieldName), useTickDates = scheduler.fillTicks && (!eventRecord.meta.isResizing || !hasBatchedChange);
  if (useTickDates) {
    let tick = timeAxis.getTickFromDate(date2);
    if (tick >= 0) {
      if (useEnd && tick === Math.round(tick) && tick > 0) {
        tick--;
      }
      const tickIndex = Math.floor(tick), tickRecord = timeAxis.getAt(tickIndex);
      return tickRecord[fieldName].getTime();
    }
  }
  return date2 === null || date2 === void 0 ? void 0 : date2.getTime();
}
var HorizontalRendering = class extends Base$1.mixin(AttachToProjectMixin) {
  static get configurable() {
    return {
      scrollBuffer: 0,
      bufferSize: 150,
      verticalBufferSize: 150
    };
  }
  static get properties() {
    return {
      resourceMap: /* @__PURE__ */ new Map(),
      rowMap: /* @__PURE__ */ new Map(),
      eventConfigs: [],
      isFirstRefresh: true,
      toDrawOnProjectRefresh: /* @__PURE__ */ new Set(),
      toDrawOnDataReady: /* @__PURE__ */ new Set()
    };
  }
  construct(scheduler) {
    const me = this;
    me.client = me.scheduler = scheduler;
    me.eventSorter = me.eventSorter.bind(scheduler);
    scheduler.scrollable.ion({
      scroll: "onEarlyScroll",
      prio: 1,
      thisObj: me
    });
    scheduler.rowManager.ion({
      name: "rowManager",
      renderDone: "onRenderDone",
      removeRows: "onRemoveRows",
      translateRow: "onTranslateRow",
      offsetRows: "onOffsetRows",
      beforeRowHeight: "onBeforeRowHeightChange",
      thisObj: me
    });
    super.construct({});
  }
  init() {
  }
  updateVerticalBufferSize() {
    const {
      rowManager
    } = this.scheduler;
    if (this.scheduler.isPainted) {
      rowManager.renderRows(rowManager.rows);
    }
  }
  get visibleDateRange() {
    return this._visibleDateRange;
  }
  getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {
    const {
      scheduler
    } = this;
    let coord = xy[0];
    if (!local) {
      coord = this.translateToScheduleCoordinate(coord);
    }
    coord = scheduler.getRtlX(coord);
    return scheduler.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);
  }
  translateToScheduleCoordinate(x) {
    const {
      scheduler
    } = this, {
      scrollable
    } = scheduler.timeAxisSubGrid;
    let result = x - scheduler.timeAxisSubGridElement.getBoundingClientRect().left - globalThis.scrollX;
    if (scheduler.rtl) {
      result += scrollable.maxX - Math.abs(scheduler.scrollLeft);
    } else {
      result += scheduler.scrollLeft;
    }
    return result;
  }
  translateToPageCoordinate(x) {
    const {
      scheduler
    } = this, {
      scrollable
    } = scheduler.timeAxisSubGrid;
    let result = x + scheduler.timeAxisSubGridElement.getBoundingClientRect().left;
    if (scheduler.rtl) {
      result -= scrollable.maxX - Math.abs(scheduler.scrollLeft);
    } else {
      result -= scheduler.scrollLeft;
    }
    return result;
  }
  getScheduleRegion(resourceRecord, eventRecord, local = true, dateConstraints, stretch = false) {
    var _dateConstraints, _scheduler$getDateCon;
    const me = this, {
      scheduler
    } = me, {
      timeAxisSubGridElement,
      timeAxis
    } = scheduler, resourceMargin = (!stretch || resourceRecord) && scheduler.getResourceMargin(resourceRecord) || 0;
    let region;
    if (resourceRecord) {
      const eventElement = eventRecord && scheduler.getElementsFromEventRecord(eventRecord, resourceRecord)[0];
      region = Rectangle.from(scheduler.getRowById(resourceRecord.id).getElement("normal"), timeAxisSubGridElement);
      if (eventElement) {
        const eventRegion = Rectangle.from(eventElement, timeAxisSubGridElement);
        region.y = eventRegion.y;
        region.bottom = eventRegion.bottom;
      } else {
        region.y = region.y + resourceMargin;
        region.bottom = region.bottom - resourceMargin;
      }
    } else {
      region = Rectangle.from(timeAxisSubGridElement).moveTo(null, 0);
      region.width = timeAxisSubGridElement.scrollWidth;
      region.y = region.y + resourceMargin;
      region.bottom = region.bottom - resourceMargin;
    }
    const taStart = timeAxis.startDate, taEnd = timeAxis.endDate;
    dateConstraints = ((_dateConstraints = dateConstraints) === null || _dateConstraints === void 0 ? void 0 : _dateConstraints.start) && dateConstraints || ((_scheduler$getDateCon = scheduler.getDateConstraints) === null || _scheduler$getDateCon === void 0 ? void 0 : _scheduler$getDateCon.call(scheduler, resourceRecord, eventRecord)) || {
      start: taStart,
      end: taEnd
    };
    let startX = scheduler.getCoordinateFromDate(dateConstraints.start ? DateHelper.max(taStart, dateConstraints.start) : taStart), endX = scheduler.getCoordinateFromDate(dateConstraints.end ? DateHelper.min(taEnd, dateConstraints.end) : taEnd);
    if (!local) {
      startX = me.translateToPageCoordinate(startX);
      endX = me.translateToPageCoordinate(endX);
    }
    region.left = Math.min(startX, endX);
    region.right = Math.max(startX, endX);
    return region;
  }
  getRowRegion(rowRecord, startDate, endDate) {
    const {
      scheduler
    } = this, {
      timeAxis
    } = scheduler, row = scheduler.getRowById(rowRecord.id);
    if (!row) {
      return null;
    }
    const taStart = timeAxis.startDate, taEnd = timeAxis.endDate, start = startDate ? DateHelper.max(taStart, startDate) : taStart, end = endDate ? DateHelper.min(taEnd, endDate) : taEnd, startX = scheduler.getCoordinateFromDate(start), endX = scheduler.getCoordinateFromDate(end, true, true), y = row.top, x = Math.min(startX, endX), bottom = y + row.offsetHeight;
    return new Rectangle(x, y, Math.max(startX, endX) - x, bottom - y);
  }
  getResourceEventBox(eventRecord, resourceRecord, includeOutside, roughly = false) {
    const resourceData = this.resourceMap.get(resourceRecord.id);
    let eventLayout = null, approx = false;
    if (resourceData) {
      eventLayout = resourceData.eventsData.find((d) => d.eventRecord === eventRecord);
    }
    if (!eventLayout) {
      eventLayout = this.getTimeSpanRenderData(eventRecord, resourceRecord, {
        viewport: true,
        timeAxis: includeOutside
      });
      approx = true;
    }
    if (eventLayout) {
      const rowBox = this.scheduler.rowManager.getRecordCoords(resourceRecord, true, roughly), absoluteTop = eventLayout.top + rowBox.top, box = new Rectangle(eventLayout.left, absoluteTop, eventLayout.width, eventLayout.height);
      box.layout = !approx;
      box.rowTop = rowBox.top;
      box.rowBottom = rowBox.bottom;
      box.resourceId = resourceRecord.id;
      return box;
    }
    return null;
  }
  resolveRowRecord(elementOrEvent) {
    const me = this, {
      scheduler
    } = me, element = elementOrEvent.nodeType ? elementOrEvent : elementOrEvent.target, el = element.nodeType === Element.TEXT_NODE ? element.parentElement : element, eventNode = el.closest(scheduler.eventSelector);
    if (eventNode) {
      return me.resourceStore.getById(eventNode.dataset.resourceId);
    }
    return scheduler.getRecordFromElement(el);
  }
  attachToProject(project) {
    super.attachToProject(project);
    this.refreshAllWhenReady = true;
    if (!this.scheduler.isConfiguring) {
      this.clearAll({
        clearDom: true
      });
    }
    project === null || project === void 0 ? void 0 : project.ion({
      name: "project",
      refresh: "onProjectRefresh",
      commitFinalized: "onProjectCommitFinalized",
      thisObj: this
    });
  }
  onProjectCommitFinalized() {
    const {
      scheduler,
      toDrawOnDataReady,
      project
    } = this;
    if (scheduler.isVisible) {
      if (scheduler.isPainted && !scheduler.refreshSuspended) {
        if (!toDrawOnDataReady.size && project.timeZone && project.ignoreRecordChanges) {
          toDrawOnDataReady.add(...project.resourceStore.records.flatMap((r) => r.id));
        }
        if (toDrawOnDataReady.size) {
          this.clearResources(toDrawOnDataReady);
          this.refreshResources(toDrawOnDataReady);
        }
        toDrawOnDataReady.clear();
      }
    } else {
      scheduler.whenVisible("refreshRows");
    }
  }
  onProjectRefresh({
    isCalculated,
    isInitialCommit
  }) {
    const me = this, {
      scheduler,
      toDrawOnProjectRefresh
    } = me;
    if (scheduler.isVisible) {
      if (scheduler.isPainted && !scheduler.isConfiguring && !scheduler.refreshSuspended) {
        if (me.refreshAllWhenReady || isInitialCommit && isCalculated) {
          scheduler.calculateAllRowHeights(true);
          const {
            rowManager
          } = scheduler;
          if (rowManager.topRow) {
            me.clearAll();
            if (!scheduler.refreshAfterProjectRefresh) {
              if (rowManager.topRow.dataIndex >= scheduler.store.count) {
                scheduler.renderRows(false);
              } else {
                scheduler.refreshWithTransition(false, !me.isFirstRefresh && isCalculated && !isInitialCommit);
              }
            }
            me.isFirstRefresh = false;
          } else {
            rowManager.reinitialize();
          }
          me.refreshAllWhenReady = false;
        } else if (toDrawOnProjectRefresh.size) {
          me.refreshResources(toDrawOnProjectRefresh);
        }
        toDrawOnProjectRefresh.clear();
      }
    } else {
      scheduler.whenVisible("refresh", scheduler, [true]);
    }
  }
  attachToAssignmentStore(assignmentStore) {
    this.refreshAllWhenReady = true;
    super.attachToAssignmentStore(assignmentStore);
    if (assignmentStore) {
      assignmentStore.ion({
        name: "assignmentStore",
        changePreCommit: "onAssignmentStoreChange",
        refreshPreCommit: "onAssignmentStoreRefresh",
        thisObj: this
      });
    }
  }
  onAssignmentStoreChange({
    source,
    action,
    records: assignmentRecords = [],
    replaced,
    changes
  }) {
    const me = this, {
      scheduler
    } = me, resourceIds = new Set(assignmentRecords.flatMap((assignmentRecord) => {
      var _assignmentRecord$res, _assignmentRecord$res2, _assignmentRecord$res3;
      return [
        assignmentRecord.resourceId,
        ...(_assignmentRecord$res = (_assignmentRecord$res2 = assignmentRecord.resource) === null || _assignmentRecord$res2 === void 0 ? void 0 : (_assignmentRecord$res3 = _assignmentRecord$res2.$links) === null || _assignmentRecord$res3 === void 0 ? void 0 : _assignmentRecord$res3.map((link) => link.id)) !== null && _assignmentRecord$res !== void 0 ? _assignmentRecord$res : []
      ];
    }));
    if (me.resourceStore.isRemoving || me.resourceStore.isChangingId) {
      return;
    }
    switch (action) {
      case "dataset": {
        if (!me.eventStore.usesSingleAssignment) {
          if (resourceIds.size) {
            me.refreshResourcesWhenReady(resourceIds);
          } else {
            me.clearAll();
            scheduler.refreshWithTransition();
          }
        }
        return;
      }
      case "add":
      case "remove":
      case "updateMultiple":
        me.refreshResourcesWhenReady(resourceIds);
        return;
      case "removeall":
        me.refreshAllWhenReady = true;
        return;
      case "replace":
        replaced.forEach(([oldAssignment, newAssignment]) => {
          resourceIds.add(oldAssignment.resourceId);
          resourceIds.add(newAssignment.resourceId);
        });
        me.refreshResourcesWhenReady(resourceIds);
        return;
      case "filter":
        me.clearAll();
        scheduler.calculateAllRowHeights(true);
        scheduler.refreshWithTransition();
        return;
      case "update": {
        if ("eventId" in changes || "resourceId" in changes || "id" in changes) {
          if ("resourceId" in changes) {
            resourceIds.add(changes.resourceId.oldValue);
          }
          if (source === scheduler.project.assignmentStore) {
            me.refreshResourcesOnDataReady(resourceIds);
          } else {
            me.refreshResources(resourceIds);
          }
        }
        break;
      }
      case "clearchanges": {
        const {
          added,
          modified,
          removed
        } = changes;
        if (modified) {
          scheduler.refreshWithTransition();
        } else {
          added.forEach((r) => resourceIds.add(r.resourceId));
          removed.forEach((r) => resourceIds.add(r.resourceId));
          me.refreshResourcesOnDataReady(resourceIds);
        }
      }
    }
  }
  onAssignmentStoreRefresh({
    action,
    records
  }) {
    if (action === "batch") {
      this.clearAll();
      this.scheduler.refreshWithTransition();
    }
  }
  attachToEventStore(eventStore) {
    this.refreshAllWhenReady = true;
    super.attachToEventStore(eventStore);
    if (eventStore) {
      eventStore.ion({
        name: "eventStore",
        refreshPreCommit: "onEventStoreRefresh",
        thisObj: this
      });
    }
  }
  onEventStoreRefresh({
    action
  }) {
    if (action === "batch") {
      const {
        scheduler
      } = this;
      if (scheduler.isEngineReady && scheduler.isPainted) {
        this.clearAll();
        scheduler.refreshWithTransition();
      }
    }
  }
  onEventStoreChange({
    action,
    records: eventRecords = [],
    record,
    replaced,
    changes,
    source
  }) {
    const me = this, {
      scheduler
    } = me, isResourceTimeRange = source.isResourceTimeRangeStore, resourceIds = /* @__PURE__ */ new Set();
    if (!scheduler.isPainted) {
      return;
    }
    eventRecords.forEach((eventRecord) => {
      var _eventRecord$$linkedR;
      const renderedEventResources = (_eventRecord$$linkedR = eventRecord.$linkedResources) === null || _eventRecord$$linkedR === void 0 ? void 0 : _eventRecord$$linkedR.filter((r) => me.resourceStore.includes(r));
      renderedEventResources === null || renderedEventResources === void 0 ? void 0 : renderedEventResources.forEach((resourceRecord) => resourceIds.add(resourceRecord.id));
    });
    if (isResourceTimeRange) {
      switch (action) {
        case "removeall":
        case "dataset":
          me.clearAll();
          scheduler.refreshWithTransition();
          return;
      }
      me.refreshResources(resourceIds);
    } else {
      switch (action) {
        case "batch":
        case "sort":
        case "group":
        case "move":
          return;
        case "remove":
          return;
        case "clearchanges":
          me.clearAll();
          scheduler.refreshWithTransition();
          return;
        case "dataset": {
          me.clearAll();
          if (scheduler.isEngineReady) {
            scheduler.refreshWithTransition();
          } else {
            me.refreshAllWhenReady = true;
          }
          return;
        }
        case "add":
        case "updateMultiple":
          break;
        case "replace":
          replaced.forEach(([, newEvent]) => {
            newEvent.resources.map((resourceRecord) => resourceIds.add(resourceRecord.id));
          });
          break;
        case "removeall":
        case "filter":
          if (!scheduler.isEngineReady) {
            me.refreshAllWhenReady = true;
            return;
          }
          me.clearAll();
          scheduler.calculateAllRowHeights(true);
          scheduler.refreshWithTransition();
          return;
        case "update": {
          const allChrono = record.$entity ? !Object.keys(changes).some((name) => !record.$entity.getField(name)) : !Object.keys(changes).some((name) => !chronoFields$1[name]);
          let dateChanges = 0;
          "startDate" in changes && dateChanges++;
          "endDate" in changes && dateChanges++;
          "duration" in changes && dateChanges++;
          if ("resourceId" in changes) {
            resourceIds.add(changes.resourceId.oldValue);
          }
          if (resourceIds.size && (!allChrono || dateChanges && !("duration" in changes && dateChanges === 1) || "percentDone" in changes || "inactive" in changes || "segments" in changes)) {
            var _me$project, _me$project2;
            if ((_me$project = me.project) !== null && _me$project !== void 0 && _me$project.propagatingLoadChanges || (_me$project2 = me.project) !== null && _me$project2 !== void 0 && _me$project2.isWritingData) {
              me.refreshResourcesOnDataReady(resourceIds);
            } else {
              me.refreshResources(resourceIds);
            }
          }
          return;
        }
      }
      me.refreshResourcesWhenReady(resourceIds);
    }
  }
  attachToResourceStore(resourceStore) {
    this.refreshAllWhenReady = true;
    super.attachToResourceStore(resourceStore);
    if (resourceStore) {
      this.clearAll({
        clearLayoutCache: true
      });
      resourceStore.ion({
        name: "resourceStore",
        changePreCommit: "onResourceStoreChange",
        thisObj: this
      });
    }
  }
  get resourceStore() {
    return this.client.store;
  }
  onResourceStoreChange({
    action,
    isExpand,
    records,
    changes
  }) {
    const me = this, resourceIds = records === null || records === void 0 ? void 0 : records.flatMap((r) => r.isLinked ? [r.id, r.$originalId] : [r.id]);
    if (!me.scheduler.isPainted) {
      return;
    }
    switch (action) {
      case "add":
        if (!isExpand) {
          if (records.every((r) => r.isLinked)) {
            me.refreshResources(resourceIds);
          } else {
            me.refreshResourcesWhenReady(resourceIds);
          }
        }
        return;
      case "update": {
        if (!me.project.isBatchingChanges && !changes.isLeaf) {
          me.refreshResources(resourceIds);
        }
        return;
      }
      case "filter":
        return;
      case "removeall":
        me.clearAll({
          clearLayoutCache: true
        });
        return;
      case "dataset":
        return;
    }
    resourceIds && me.clearResources(resourceIds);
  }
  onTranslateRow({
    row
  }) {
    if (row.id != null) {
      this.refreshEventsForResource(row, false);
    }
  }
  onOffsetRows() {
    this.clearAll();
    this.doUpdateTimeView();
  }
  calculateRowHeight(resourceRecord) {
    var _resourceRecord$assig;
    const {
      scheduler
    } = this, rowHeight = scheduler.getResourceHeight(resourceRecord), eventLayout = scheduler.getEventLayout(resourceRecord), layoutType = eventLayout.type;
    if (layoutType === "stack" && scheduler.isEngineReady && !resourceRecord.isSpecialRow && ((_resourceRecord$assig = resourceRecord.assigned) === null || _resourceRecord$assig === void 0 ? void 0 : _resourceRecord$assig.size) > 1) {
      const {
        assignmentStore,
        eventStore,
        timeAxis
      } = scheduler, {
        barMargin,
        resourceMargin,
        contentHeight
      } = scheduler.getResourceLayoutSettings(resourceRecord), eventFilter = (eventStore.isFiltered || assignmentStore.isFiltered) && ((eventRecord) => eventRecord.assignments.some((a) => a.resource === resourceRecord.$original && assignmentStore.includes(a))), events = eventStore.getEvents({
        resourceRecord,
        includeOccurrences: scheduler.enableRecurringEvents,
        startDate: timeAxis.startDate,
        endDate: timeAxis.endDate,
        filter: eventFilter
      }).sort(heightEventSorter).map((eventRecord) => {
        const startDate = eventRecord.isBatchUpdating ? eventRecord.get("startDate") : eventRecord.startDate, endDate = eventRecord.isBatchUpdating ? eventRecord.get("endDate") : eventRecord.endDate || startDate;
        return {
          eventRecord,
          resourceRecord,
          startMS: startDate.getTime(),
          endMS: endDate.getTime()
        };
      }), layoutHandler = scheduler.getEventLayoutHandler(eventLayout), nbrOfBandsRequired = layoutHandler.layoutEventsInBands(events, true);
      if (layoutHandler.type === "layoutFn") {
        return nbrOfBandsRequired;
      }
      return nbrOfBandsRequired * contentHeight + (nbrOfBandsRequired - 1) * barMargin + resourceMargin * 2;
    }
    return rowHeight;
  }
  doUpdateTimeView() {
    const {
      scrollable
    } = this.scheduler.timeAxisSubGrid;
    this.updateFromHorizontalScroll(scrollable.x);
  }
  onTimeAxisViewModelUpdate() {
    const me = this, {
      scheduler
    } = me;
    me.clearAll();
    if (scheduler.refreshSuspended) {
      me.detachListeners("renderingSuspend");
      scheduler.ion({
        name: "renderingSuspend",
        resumeRefresh({
          trigger
        }) {
          if (scheduler.isEngineReady && trigger) {
            me.doUpdateTimeView();
          }
        },
        thisObj: me,
        once: true
      });
    }
    me.doUpdateTimeView();
  }
  getConnectorStartSide(eventRecord) {
    return "start";
  }
  getConnectorEndSide(eventRecord) {
    return "end";
  }
  refreshRows(reLayoutEvents) {
    if (reLayoutEvents) {
      this.clearAll();
    }
  }
  onLocaleChange() {
    this.clearAll();
  }
  onViewportResize(width, height, oldWidth, oldHeight) {
    if (height > oldHeight) {
      this.onRenderDone();
    }
  }
  onDragAbort({
    context,
    dragData
  }) {
    if (this.resourceStore.indexOf(dragData.record.resource) < this.scheduler.topRow.dataIndex) {
      context.element.remove();
    }
  }
  toggleCls(assignmentRecord, cls, add = true, useWrapper = false) {
    const element = this.client.getElementFromAssignmentRecord(assignmentRecord, useWrapper), resourceData = this.resourceMap.get(assignmentRecord.isModel ? assignmentRecord.get("resourceId") : assignmentRecord.resourceId), eventData = resourceData === null || resourceData === void 0 ? void 0 : resourceData.eventsData.find((d) => d.eventId === assignmentRecord.eventId);
    if (eventData) {
      eventData[useWrapper ? "wrapperCls" : "cls"][cls] = add;
    }
    if (element) {
      element.classList[add ? "add" : "remove"](cls);
      element.lastDomConfig.className[cls] = add;
    }
  }
  onRemoveRows({
    rows
  }) {
    rows.forEach((row) => this.rowMap.delete(row));
    this.onRenderDone();
  }
  onEarlyScroll() {
    this.rendererCalled = false;
  }
  updateFromVerticalScroll() {
    this.fromScroll = true;
    if (!this.rendererCalled) {
      this.onRenderDone();
    }
  }
  updateFromHorizontalScroll(scrollX) {
    const me = this, {
      scheduler,
      scrollBuffer
    } = me, {
      timeAxisSubGrid,
      timeAxis,
      rtl
    } = scheduler, {
      width
    } = timeAxisSubGrid, {
      totalSize
    } = scheduler.timeAxisViewModel, start = scrollX, returnEnd = timeAxisSubGrid.scrollable.maxX !== 0 && Math.abs(timeAxisSubGrid.scrollable.maxX) <= Math.round(start) + 5, startDate = scheduler.getDateFromCoord({
      coord: Math.max(0, start - scrollBuffer),
      ignoreRTL: true
    }), endDate = returnEnd ? timeAxis.endDate : scheduler.getDateFromCoord({
      coord: start + width + scrollBuffer,
      ignoreRTL: true
    }) || timeAxis.endDate;
    if (startDate && !scheduler._viewPresetChanging) {
      me._visibleDateRange = {
        startDate,
        endDate,
        startMS: startDate.getTime(),
        endMS: endDate.getTime()
      };
      me.viewportCoords = rtl ? {
        left: totalSize - scrollX - width + scrollBuffer,
        right: totalSize - scrollX - scrollBuffer
      } : {
        left: scrollX - scrollBuffer,
        right: scrollX + width + scrollBuffer
      };
      const range = scheduler.timeView.range = {
        startDate,
        endDate
      };
      scheduler.onVisibleDateRangeChange(range);
      if (!scheduler.refreshSuspended && scheduler.rowManager.rows.length) {
        if (scheduler.rowManager.rows[0].id === null) {
          return;
        }
        me.fromScroll = true;
        scheduler.rowManager.rows.forEach((row) => me.refreshEventsForResource(row, false, false));
        me.onRenderDone();
      }
    }
  }
  repaintEventsForResource(resourceRecord) {
    this.refreshResources([resourceRecord.id]);
  }
  onBeforeRowHeightChange() {
    this.clearAll();
  }
  refreshResourcesOnDataReady(resourceIds) {
    resourceIds.forEach((id) => this.toDrawOnDataReady.add(id));
  }
  refreshResourcesWhenReady(resourceIds) {
    this.clearResources(resourceIds);
    resourceIds.forEach((id) => this.toDrawOnProjectRefresh.add(id));
  }
  refreshResources(ids, transition = true) {
    const me = this, {
      scheduler
    } = me, rows = [], noRows = [];
    me.clearResources(ids);
    if (!scheduler.refreshSuspended) {
      ids.forEach((id) => {
        const row = scheduler.getRowById(id);
        if (row) {
          rows.push(row);
        } else {
          noRows.push(row);
        }
      });
      scheduler.runWithTransition(() => {
        scheduler.calculateRowHeights(noRows.map((id) => this.resourceStore.getById(id)), true);
        scheduler.rowManager.renderRows(rows);
      }, transition);
    }
  }
  layoutEventVerticallyStack(bandIndex, eventRecord, resourceRecord) {
    const {
      barMargin,
      resourceMargin,
      contentHeight
    } = this.scheduler.getResourceLayoutSettings(resourceRecord, eventRecord.parent);
    return bandIndex === 0 ? resourceMargin : resourceMargin + bandIndex * contentHeight + bandIndex * barMargin;
  }
  layoutEventVerticallyPack(topFraction, heightFraction, eventRecord, resourceRecord) {
    const {
      barMargin,
      resourceMargin,
      contentHeight
    } = this.scheduler.getResourceLayoutSettings(resourceRecord, eventRecord.parent), count = 1 / heightFraction, bandIndex = topFraction * count, height = (contentHeight - (count - 1) * barMargin) * heightFraction, top = resourceMargin + bandIndex * height + bandIndex * barMargin;
    return {
      top,
      height
    };
  }
  addTemporaryDragElement(eventRecord, resourceRecord = eventRecord.resource) {
    const {
      scheduler
    } = this, renderData = scheduler.generateRenderData(eventRecord, resourceRecord, {
      timeAxis: true,
      viewport: true
    });
    renderData.absoluteTop = renderData.row ? renderData.top + renderData.row.top : scheduler.getResourceEventBox(eventRecord, resourceRecord, true).top;
    const domConfig = this.renderEvent(renderData), {
      dataset
    } = domConfig;
    delete domConfig.tabIndex;
    delete dataset.eventId;
    delete dataset.resourceId;
    delete dataset.assignmentId;
    delete dataset.syncId;
    dataset.transient = true;
    domConfig.parent = this.scheduler.foregroundCanvas;
    domConfig.retainElement = true;
    const result = DomHelper.createElement(domConfig);
    result.innerElement = result.firstChild;
    eventRecord.instanceMeta(scheduler).hasTemporaryDragElement = true;
    return result;
  }
  eventSorter(a, b) {
    if (this.overlappingEventSorter) {
      return this.overlappingEventSorter(a.eventRecord || a, b.eventRecord || b);
    }
    const startA = a.isModel ? a.startDateMS : a.dataStartMS || a.startMS, endA = a.isModel ? a.endDateMS : a.dataEndMS || a.endMS, startB = b.isModel ? b.startDateMS : b.dataStartMS || b.startMS, endB = b.isModel ? b.endDateMS : b.dataEndMS || b.endMS, nameA = a.isModel ? a.name : a.eventRecord.name, nameB = b.isModel ? b.name : b.eventRecord.name;
    return startA - startB || endB - endA || (nameA < nameB ? -1 : nameA == nameB ? 0 : 1);
  }
  calculateMS(eventRecord, startDateField, endDateField, useEventBuffer, resourceRecord) {
    const me = this, {
      scheduler
    } = me, {
      timeAxisViewModel
    } = scheduler;
    let startMS = getStartEnd(scheduler, eventRecord, false, startDateField, useEventBuffer), endMS = getStartEnd(scheduler, eventRecord, true, endDateField, useEventBuffer), durationMS = endMS - startMS;
    if (scheduler.milestoneLayoutMode !== "default" && durationMS === 0) {
      const pxPerMinute = timeAxisViewModel.getSingleUnitInPixels("minute"), lengthInPx = scheduler.getMilestoneLabelWidth(eventRecord, resourceRecord), duration = lengthInPx * (1 / pxPerMinute);
      durationMS = duration * 60 * 1e3;
      if (scheduler.milestoneTextPosition === "always-outside") {
        const diamondSize = scheduler.getResourceLayoutSettings(resourceRecord, eventRecord.parent).contentHeight, diamondMS = diamondSize * (1 / pxPerMinute) * 60 * 1e3;
        startMS -= diamondMS / 2;
        endMS = startMS + durationMS;
      } else {
        switch (scheduler.milestoneAlign) {
          case "start":
          case "left":
            endMS = startMS + durationMS;
            break;
          case "end":
          case "right":
            endMS = startMS;
            startMS = endMS - durationMS;
            break;
          default:
            endMS = startMS + durationMS / 2;
            startMS = endMS - durationMS;
            break;
        }
      }
    }
    return {
      startMS,
      endMS,
      durationMS
    };
  }
  setupRenderData(timeSpan, rowRecord) {
    var _scheduler$features$e;
    const me = this, {
      scheduler
    } = me, {
      timeAxis,
      timeAxisViewModel
    } = scheduler, {
      preamble,
      postamble
    } = timeSpan, useEventBuffer = me.isProHorizontalRendering && ((_scheduler$features$e = scheduler.features.eventBuffer) === null || _scheduler$features$e === void 0 ? void 0 : _scheduler$features$e.enabled) && (preamble || postamble) && !timeSpan.isMilestone, pxPerMinute = timeAxisViewModel.getSingleUnitInPixels("minute"), {
      isBatchUpdating
    } = timeSpan, startDateField = useEventBuffer ? "wrapStartDate" : "startDate", endDateField = useEventBuffer ? "wrapEndDate" : "endDate", timespanStart = isBatchUpdating && !useEventBuffer ? timeSpan.get(startDateField) : timeSpan[startDateField], timespanEnd = isBatchUpdating && !useEventBuffer ? timeSpan.get(endDateField) : timeSpan[endDateField] || timespanStart, viewStartMS = timeAxis.startMS, viewEndMS = timeAxis.endMS, {
      startMS,
      endMS,
      durationMS
    } = me.calculateMS(timeSpan, startDateField, endDateField, useEventBuffer, rowRecord), startsOutsideView = startMS < viewStartMS | (startMS > viewEndMS) << 1, endsOutsideView = endMS > viewEndMS | (endMS <= viewStartMS) << 1, durationMinutes = durationMS / (1e3 * 60), width = endsOutsideView ? pxPerMinute * durationMinutes : null, row = scheduler.getRowById(rowRecord);
    return {
      eventRecord: timeSpan,
      taskRecord: timeSpan,
      start: timespanStart,
      end: timespanEnd,
      rowId: rowRecord.id,
      children: [],
      startMS,
      endMS,
      durationMS,
      startsOutsideView,
      endsOutsideView,
      width,
      row,
      useEventBuffer
    };
  }
  fillTimeSpanHorizontalPosition(renderData) {
    const {
      startMS,
      endMS,
      durationMS
    } = renderData, result = startMS != null && endMS != null && this.calculateHorizontalPosition(renderData, startMS, endMS, durationMS);
    if (result) {
      Object.assign(renderData, result);
      return true;
    }
    return false;
  }
  calculateHorizontalPosition(renderData, startMS, endMS, durationMS) {
    const {
      scheduler
    } = this, {
      timeAxis,
      timeAxisViewModel
    } = scheduler, {
      startsOutsideView,
      endsOutsideView,
      eventRecord
    } = renderData, viewStartMS = timeAxis.startMS, pxPerMinute = timeAxisViewModel.getSingleUnitInPixels("minute"), durationMinutes = durationMS / (1e3 * 60), width = endsOutsideView ? pxPerMinute * durationMinutes : null;
    let endX = scheduler.getCoordinateFromDate(endMS, {
      local: true,
      respectExclusion: true,
      isEnd: true
    }), startX, clippedStart = false, clippedEnd = false;
    if (startsOutsideView) {
      startX = (startMS - viewStartMS) / (1e3 * 60) * pxPerMinute;
      if (scheduler.rtl) {
        startX = scheduler.timeAxisSubGrid.scrollable.scrollWidth - startX;
      }
    } else {
      startX = scheduler.getCoordinateFromDate(startMS, {
        local: true,
        respectExclusion: true,
        isEnd: false,
        snapToNextIncluded: endX !== -1
      });
      clippedStart = startX === -1;
    }
    if (endsOutsideView) {
      if (BrowserHelper.isSafari && scheduler.features.stickyEvents) {
        endX = scheduler.getCoordinateFromDate(timeAxis.endMS);
      } else {
        endX = startX + width * (scheduler.rtl ? -1 : 1);
      }
    } else {
      clippedEnd = endX === -1;
    }
    if (clippedEnd && !clippedStart) {
      endX = scheduler.getCoordinateFromDate(endMS, {
        local: true,
        respectExclusion: true,
        isEnd: true,
        snapToNextIncluded: true
      });
    }
    if (width > MAX_WIDTH) {
      if (startsOutsideView === 1) {
        if (endsOutsideView === 1) {
          startX = -100;
          endX = scheduler.timeAxisColumn.width + 100;
        } else {
          startX = endX - MAX_WIDTH;
        }
      } else if (endsOutsideView === 1) {
        endX = startX + MAX_WIDTH;
      }
    }
    if (clippedStart && clippedEnd) {
      startX = scheduler.getCoordinateFromDate(startMS, {
        local: true,
        respectExclusion: true,
        isEnd: false,
        snapToNextIncluded: true,
        max: endMS
      });
      endX = scheduler.getCoordinateFromDate(endMS, {
        local: true,
        respectExclusion: true,
        isEnd: true,
        snapToNextIncluded: true,
        min: startMS
      });
      if (startX === endX) {
        eventRecord.instanceMeta(scheduler).excluded = true;
        return null;
      }
    }
    return {
      left: Math.min(startX, endX),
      width: Math.abs(endX - startX) || (eventRecord.isMilestone && !eventRecord.meta.isDragCreating ? 0 : 6),
      clippedStart,
      clippedEnd
    };
  }
  fillTimeSpanVerticalPosition(renderData, rowRecord) {
    const {
      scheduler
    } = this, {
      start,
      end
    } = renderData, {
      resourceMargin,
      contentHeight
    } = scheduler.getResourceLayoutSettings(rowRecord);
    if (scheduler.fillTicks) {
      renderData.dataStartMS = start.getTime();
      renderData.dataEndMS = end.getTime();
    }
    renderData.top = Math.max(0, resourceMargin);
    if (scheduler.managedEventSizing) {
      renderData.height = contentHeight;
    }
  }
  getTimeSpanRenderData(timeSpan, rowRecord, includeOutside = false) {
    const me = this, {
      scheduler
    } = me, {
      timeAxis
    } = scheduler, includeOutsideTimeAxis = includeOutside === true || includeOutside.timeAxis, includeOutsideViewport = includeOutside === true || includeOutside.viewport;
    if (includeOutsideTimeAxis || timeAxis.isTimeSpanInAxis(timeSpan)) {
      const row = scheduler.getRowById(rowRecord);
      if (row || includeOutsideViewport) {
        const data = me.setupRenderData(timeSpan, rowRecord);
        if (!me.fillTimeSpanHorizontalPosition(data)) {
          return null;
        }
        me.fillTimeSpanVerticalPosition(data, rowRecord);
        return data;
      }
    }
  }
  layoutEvents(resourceRecord, allEvents, includeOutside = false, parentEventRecord, eventSorter) {
    const me = this, {
      scheduler
    } = me, {
      timeAxis
    } = scheduler, eventsData = allEvents.reduce((result, eventRecord) => {
      if (includeOutside || timeAxis.isTimeSpanInAxis(eventRecord)) {
        const eventBox = scheduler.generateRenderData(eventRecord, resourceRecord, false);
        if (eventBox) {
          result.push(eventBox);
        }
      }
      return result;
    }, []);
    eventsData.sort(eventSorter !== null && eventSorter !== void 0 ? eventSorter : me.eventSorter);
    let rowHeight = scheduler.getAppliedResourceHeight(resourceRecord, parentEventRecord);
    const layoutEventData = eventsData.filter(({
      eventRecord
    }) => eventRecord.isEvent && !eventRecord.meta.excludeFromLayout), eventLayout = scheduler.getEventLayout(resourceRecord, parentEventRecord), layoutHandler = scheduler.getEventLayoutHandler(eventLayout);
    if (layoutHandler) {
      const {
        barMargin,
        resourceMargin,
        contentHeight
      } = scheduler.getResourceLayoutSettings(resourceRecord, parentEventRecord), bandsRequired = layoutHandler.applyLayout(layoutEventData, resourceRecord) || 1;
      if (layoutHandler.type === "layoutFn") {
        rowHeight = bandsRequired;
      } else {
        rowHeight = bandsRequired * contentHeight + (bandsRequired - 1) * barMargin + resourceMargin * 2;
      }
    } else if (layoutEventData.length > 0) {
      for (let i = 0; i < layoutEventData.length; i++) {
        const data = layoutEventData[i];
        data.wrapperStyle += `;z-index:${i + 5}`;
      }
    }
    return {
      rowHeight,
      eventsData
    };
  }
  layoutResourceEvents(resourceRecord, includeOutside = false) {
    const me = this, {
      scheduler
    } = me, {
      eventStore,
      assignmentStore,
      timeAxis
    } = scheduler, resourceEvents = eventStore.getEvents({
      includeOccurrences: scheduler.enableRecurringEvents,
      resourceRecord,
      startDate: timeAxis.startDate,
      endDate: timeAxis.endDate,
      filter: (assignmentStore.isFiltered || eventStore.isFiltered) && ((eventRecord) => eventRecord.assignments.some((a) => a.resource === resourceRecord.$original && assignmentStore.includes(a)))
    }), allEvents = scheduler.getEventsToRender(resourceRecord, resourceEvents) || [];
    return me.layoutEvents(resourceRecord, allEvents, includeOutside);
  }
  renderEvent(data, rowHeight) {
    const {
      scheduler
    } = this, {
      resourceRecord,
      assignmentRecord,
      eventRecord
    } = data, {
      milestoneLayoutMode: layoutMode,
      milestoneTextPosition: textPosition
    } = scheduler, syncId = assignmentRecord ? this.assignmentStore.getOccurrence(assignmentRecord, eventRecord).id : data.eventId, eventElementConfig = {
      className: data.cls,
      style: data.style || "",
      children: data.children,
      role: "presentation",
      dataset: {
        taskFeature: "event"
      },
      syncOptions: {
        syncIdField: "taskBarFeature"
      }
    }, elementConfig = {
      className: data.wrapperCls,
      tabIndex: "tabIndex" in data ? data.tabIndex : -1,
      children: [eventElementConfig, ...data.wrapperChildren],
      style: {
        top: data.absoluteTop,
        left: data.left,
        height: data.fillSize ? rowHeight : data.height,
        width: eventRecord.isMilestone && !eventRecord.meta.isDragCreating && (layoutMode === "default" && (textPosition === "outside" || textPosition === "inside" && !data.width) || textPosition === "always-outside") ? data.height : data.width,
        style: data.wrapperStyle,
        fontSize: data.height + "px"
      },
      dataset: {
        resourceId: resourceRecord.id,
        eventId: data.eventId,
        syncId: resourceRecord.isLinked ? `${syncId}_${resourceRecord.id}` : syncId
      },
      elementData: data,
      retainElement: (assignmentRecord === null || assignmentRecord === void 0 ? void 0 : assignmentRecord.instanceMeta(scheduler).retainElement) || eventRecord.instanceMeta(scheduler).retainElement,
      syncOptions: {
        syncIdField: "taskFeature",
        releaseThreshold: 0
      }
    };
    if (data.fillSize) {
      data.height = rowHeight;
    }
    if (data.zIndex) {
      elementConfig.zIndex = data.zIndex;
    }
    if (assignmentRecord) {
      elementConfig.dataset.assignmentId = assignmentRecord.id;
    }
    data.elementConfig = elementConfig;
    return elementConfig;
  }
  refreshEventsForResource(recordOrRow, force = true, draw = true) {
    const me = this, record = me.scheduler.store.getById(recordOrRow.isRow ? recordOrRow.id : recordOrRow), row = me.scheduler.rowManager.getRowFor(record);
    if (force) {
      me.clearResources([record]);
    }
    if (row && record) {
      me.renderer({
        row,
        record
      });
      if (force && draw) {
        me.onRenderDone();
      }
    }
  }
  getResourceLayout(resourceRecord) {
    const me = this;
    let resourceLayout = me.resourceMap.get(resourceRecord.id);
    if (!resourceLayout || resourceLayout.invalid) {
      if (me.suspended) {
        return;
      }
      resourceLayout = me.layoutResourceEvents(resourceRecord, false);
      me.resourceMap.set(resourceRecord.id, resourceLayout);
    }
    return resourceLayout;
  }
  getEventDOMConfigForCurrentView(resourceLayout, row, left, right) {
    const me = this, {
      bufferSize,
      scheduler
    } = me, {
      labels,
      eventBuffer
    } = scheduler.features, usesLabels = (eventBuffer === null || eventBuffer === void 0 ? void 0 : eventBuffer.enabled) || (labels === null || labels === void 0 ? void 0 : labels.enabled) && (labels.left || labels.right || labels.before || labels.after), {
      eventsData
    } = resourceLayout, reusableDOMConfigs = me.fromScroll ? me.rowMap.get(row) : null, eventDOMConfigs = [];
    let useLeft, useRight;
    for (let i = 0; i < eventsData.length; i++) {
      const layout = eventsData[i];
      useLeft = left;
      useRight = right;
      if (usesLabels || layout.width === 0) {
        useLeft -= bufferSize;
        useRight += bufferSize;
      }
      if (layout.left + layout.width >= useLeft && layout.left <= useRight) {
        layout.absoluteTop = layout.top + row.top;
        const prevDomConfig = reusableDOMConfigs === null || reusableDOMConfigs === void 0 ? void 0 : reusableDOMConfigs.find((config) => config.elementData.eventId === layout.eventId);
        eventDOMConfigs.push(prevDomConfig !== null && prevDomConfig !== void 0 ? prevDomConfig : me.renderEvent(layout, resourceLayout.rowHeight));
      }
    }
    return eventDOMConfigs;
  }
  renderer({
    row,
    record: resourceRecord,
    size = {}
  }) {
    const me = this;
    if (resourceRecord.isSpecialRow) {
      me.rowMap.delete(row);
      return;
    }
    const {
      left,
      right
    } = me.viewportCoords, resourceLayout = me.getResourceLayout(resourceRecord);
    if (!resourceLayout) {
      return;
    }
    size.height = resourceLayout.rowHeight;
    size.transient = true;
    const eventDOMConfigs = me.getEventDOMConfigForCurrentView(resourceLayout, row, left, right);
    me.rowMap.set(row, eventDOMConfigs);
    me.rendererCalled = true;
  }
  onRenderDone() {
    var _scheduler$_scrollTop;
    const {
      scheduler,
      rowMap,
      verticalBufferSize
    } = this, visibleEventDOMConfigs = [], bodyTop = (_scheduler$_scrollTop = scheduler._scrollTop) !== null && _scheduler$_scrollTop !== void 0 ? _scheduler$_scrollTop : 0, viewTop = bodyTop - verticalBufferSize, viewBottom = bodyTop + scheduler._bodyRectangle.height + verticalBufferSize, unbuffered = verticalBufferSize < 0, unmanagedSize = !scheduler.managedEventSizing;
    rowMap.forEach((eventDOMConfigs, row) => {
      if (unbuffered || row.bottom > viewTop && row.top < viewBottom) {
        for (let i = 0; i < eventDOMConfigs.length; i++) {
          const config = eventDOMConfigs[i], data = config.elementData, {
            absoluteTop,
            eventRecord
          } = data;
          if (unbuffered || unmanagedSize || eventRecord.meta.isDragCreating || eventRecord.meta.isResizing || absoluteTop + data.height > viewTop && absoluteTop < viewBottom) {
            visibleEventDOMConfigs.push(config);
          }
        }
      }
      for (let i = 0; i < eventDOMConfigs.length; i++) {
        eventDOMConfigs[i] = _objectSpread2({}, eventDOMConfigs[i]);
      }
    });
    this.fromScroll = false;
    this.visibleEventDOMConfigs = visibleEventDOMConfigs;
    DomSync.sync({
      domConfig: {
        onlyChildren: true,
        children: visibleEventDOMConfigs
      },
      targetElement: scheduler.foregroundCanvas,
      syncIdField: "syncId",
      callback({
        action,
        domConfig,
        lastDomConfig,
        targetElement,
        jsx
      }) {
        var _scheduler$processEve, _domConfig$elementDat;
        const {
          reactComponent
        } = scheduler;
        const isRelease = releaseEventActions$1[action], isRender = renderEventActions$1[action];
        if (!isRelease && (_scheduler$processEve = scheduler.processEventContent) !== null && _scheduler$processEve !== void 0 && _scheduler$processEve.call(scheduler, {
          jsx,
          action,
          domConfig,
          targetElement,
          isRelease,
          reactComponent
        }))
          return;
        if (action === "none" || !(domConfig !== null && domConfig !== void 0 && (_domConfig$elementDat = domConfig.elementData) !== null && _domConfig$elementDat !== void 0 && _domConfig$elementDat.isWrap)) {
          return;
        }
        if (isRelease && lastDomConfig !== null && lastDomConfig !== void 0 && lastDomConfig.elementData) {
          var _scheduler$processEve2;
          const {
            eventRecord,
            resourceRecord,
            assignmentRecord
          } = lastDomConfig.elementData, event = {
            renderData: lastDomConfig.elementData,
            element: targetElement,
            eventRecord,
            resourceRecord,
            assignmentRecord
          };
          (_scheduler$processEve2 = scheduler.processEventContent) === null || _scheduler$processEve2 === void 0 ? void 0 : _scheduler$processEve2.call(scheduler, {
            isRelease,
            targetElement,
            reactComponent,
            assignmentRecord
          });
          if (targetElement === DomHelper.getActiveElement(targetElement)) {
            scheduler.focusElement.focus();
          }
          scheduler.trigger("releaseEvent", event);
        }
        if (isRender) {
          const {
            eventRecord,
            resourceRecord,
            assignmentRecord
          } = domConfig.elementData, event = {
            renderData: domConfig.elementData,
            element: targetElement,
            isReusingElement: action === "reuseElement",
            isRepaint: action === "reuseOwnElement",
            eventRecord,
            resourceRecord,
            assignmentRecord
          };
          scheduler.trigger("renderEvent", event);
        }
      }
    });
  }
  clearResources(recordsOrIds) {
    recordsOrIds = ArrayHelper.asArray(recordsOrIds);
    const resourceIds = recordsOrIds.map(Model.asId);
    resourceIds.forEach((resourceId) => {
      const cached = this.resourceMap.get(resourceId);
      if (cached) {
        cached.invalid = true;
      }
      const row = this.scheduler.getRowById(resourceId);
      row && this.rowMap.delete(row);
    });
  }
  clearAll({
    clearDom = false,
    clearLayoutCache = false
  } = {}) {
    const me = this, {
      layouts,
      foregroundCanvas
    } = me.scheduler;
    if (clearLayoutCache && layouts) {
      for (const layout in layouts) {
        layouts[layout].clearCache();
      }
    }
    if (foregroundCanvas && clearDom) {
      foregroundCanvas.syncIdMap = foregroundCanvas.lastDomConfig = null;
      for (const child of foregroundCanvas.children) {
        child.lastDomConfig = child.elementData = null;
      }
    }
    me.resourceMap.clear();
    me.rowMap.clear();
  }
};
_defineProperty(HorizontalRendering, "$name", "HorizontalRendering");
HorizontalRendering._$name = "HorizontalRendering";
var VerticalLayout = class extends PackMixin() {
  static get defaultConfig() {
    return {
      coordProp: "leftFactor",
      sizeProp: "widthFactor"
    };
  }
  applyLayout(events, columnWidth, resourceMargin, barMargin, columnIndex, eventLayout) {
    const me = this, layoutType = eventLayout.type;
    return me.packEventsInBands(events, (tplData, clusterIndex, slot, slotSize) => {
      if (layoutType === "none") {
        tplData.width = columnWidth - resourceMargin * 2;
        tplData.left += resourceMargin;
      } else {
        tplData.widthFactor = slotSize;
        const leftFactor = tplData.leftFactor = slot.start + clusterIndex * slotSize, packColumnCount = Math.round(1 / slotSize), packColumnIndex = leftFactor / slotSize, availableWidth = columnWidth - resourceMargin * 2 - barMargin * (packColumnCount - 1);
        if (layoutType === "mixed" && packColumnCount === 2) {
          tplData.left += leftFactor * columnWidth / 5 + barMargin;
          tplData.width = columnWidth - leftFactor * columnWidth / 5 - barMargin * 2;
          tplData.zIndex = 5 + packColumnIndex;
        } else {
          tplData.width = slotSize * availableWidth;
          tplData.left += leftFactor * availableWidth + resourceMargin + barMargin * packColumnIndex;
        }
      }
      tplData.cls["b-sch-event-narrow"] = tplData.width < me.scheduler.narrowEventWidth;
    });
  }
};
VerticalLayout._$name = "VerticalLayout";
var releaseEventActions = {
  releaseElement: 1,
  reuseElement: 1
};
var renderEventActions = {
  newElement: 1,
  reuseOwnElement: 1,
  reuseElement: 1
};
var chronoFields = {
  startDate: 1,
  endDate: 1,
  duration: 1
};
var emptyObject$2 = Object.freeze({});
var VerticalRendering = class extends Base$1.mixin(Delayable, AttachToProjectMixin) {
  static get properties() {
    return {
      eventMap: /* @__PURE__ */ new Map(),
      resourceMap: /* @__PURE__ */ new Map(),
      releasedElements: {},
      toDrawOnProjectRefresh: /* @__PURE__ */ new Set(),
      resourceBufferSize: 1
    };
  }
  construct(scheduler) {
    this.client = this.scheduler = scheduler;
    this.verticalLayout = new VerticalLayout({
      scheduler
    });
    super.construct({});
  }
  init() {
    const me = this, {
      scheduler,
      resourceColumns
    } = me;
    resourceColumns.resourceStore = me.resourceStore;
    resourceColumns.ion({
      name: "resourceColumns",
      columnWidthChange: "onResourceColumnWidthChange",
      thisObj: me
    });
    me.initialized = true;
    if (scheduler.isPainted) {
      me.renderer();
    }
    resourceColumns.availableWidth = scheduler.timeAxisSubGridElement.offsetWidth;
  }
  resolveRowRecord(elementOrEvent, xy) {
    const me = this, {
      scheduler
    } = me, event = elementOrEvent.nodeType ? null : elementOrEvent, element = event ? event.target : elementOrEvent, coords = event ? [event.borderOffsetX, event.borderOffsetY] : xy, el = element.nodeType === Element.TEXT_NODE ? element.parentElement : element, eventElement = el.closest(scheduler.eventSelector);
    if (eventElement) {
      return scheduler.resourceStore.getById(eventElement.dataset.resourceId);
    }
    if (!element.closest(".b-sch-timeaxis-cell")) {
      return null;
    }
    if (!coords) {
      throw new Error(`Vertical mode needs coordinates to resolve this element. Can also be called with a browser
                event instead of element to extract element and coordinates from`);
    }
    if (scheduler.variableColumnWidths || scheduler.resourceStore.isGrouped) {
      let totalWidth = 0;
      for (const col of me.resourceStore) {
        if (!col.isSpecialRow) {
          totalWidth += col.columnWidth || me.resourceColumns.columnWidth;
        }
        if (totalWidth >= coords[0]) {
          return col;
        }
      }
      return null;
    }
    const index = Math.floor(coords[0] / me.resourceColumns.columnWidth);
    return me.allResourceRecords[index];
  }
  toggleCls(assignmentRecord, cls, add = true, useWrapper = false) {
    var _this$eventMap$get;
    const eventData = (_this$eventMap$get = this.eventMap.get(assignmentRecord.eventId)) === null || _this$eventMap$get === void 0 ? void 0 : _this$eventMap$get[assignmentRecord.resourceId];
    if (eventData) {
      eventData.renderData[useWrapper ? "wrapperCls" : "cls"][cls] = add;
      const element = this.client.getElementFromAssignmentRecord(assignmentRecord, useWrapper);
      if (element) {
        element.classList[add ? "add" : "remove"](cls);
      }
    }
  }
  getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {
    let coord = xy[1];
    if (!local) {
      coord = this.translateToScheduleCoordinate(coord);
    }
    return this.scheduler.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);
  }
  translateToScheduleCoordinate(y) {
    return y - this.scheduler.timeAxisSubGridElement.getBoundingClientRect().top - globalThis.scrollY;
  }
  translateToPageCoordinate(y) {
    return y + this.scheduler.timeAxisSubGridElement.getBoundingClientRect().top + globalThis.scrollY;
  }
  getResourceEventBox(event, resource) {
    var _this$eventMap$get2;
    const eventId = event.id, resourceId = resource.id;
    let {
      renderData
    } = ((_this$eventMap$get2 = this.eventMap.get(eventId)) === null || _this$eventMap$get2 === void 0 ? void 0 : _this$eventMap$get2[resourceId]) || emptyObject$2;
    if (!renderData) {
      var _this$eventMap$get3, _this$eventMap$get3$r;
      this.layoutResource(this.scheduler.resourceStore.getById(resourceId));
      renderData = (_this$eventMap$get3 = this.eventMap.get(eventId)) === null || _this$eventMap$get3 === void 0 ? void 0 : (_this$eventMap$get3$r = _this$eventMap$get3[resourceId]) === null || _this$eventMap$get3$r === void 0 ? void 0 : _this$eventMap$get3$r.renderData;
    }
    return renderData ? new Rectangle(renderData.left, renderData.top, renderData.width, renderData.bottom - renderData.top) : null;
  }
  getScheduleRegion(resourceRecord, eventRecord, local) {
    var _scheduler$getDateCon;
    const me = this, {
      scheduler
    } = me, region = Rectangle.from(scheduler.timeAxisSubGridElement, scheduler.timeAxisSubGridElement);
    if (resourceRecord) {
      region.left = me.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth;
      region.right = region.left + scheduler.resourceColumnWidth;
    }
    const start = scheduler.timeAxis.startDate, end = scheduler.timeAxis.endDate, dateConstraints = ((_scheduler$getDateCon = scheduler.getDateConstraints) === null || _scheduler$getDateCon === void 0 ? void 0 : _scheduler$getDateCon.call(scheduler, resourceRecord, eventRecord)) || {
      start,
      end
    }, startY = scheduler.getCoordinateFromDate(DateHelper.max(start, dateConstraints.start)), endY = scheduler.getCoordinateFromDate(DateHelper.min(end, dateConstraints.end));
    if (!local) {
      region.top = me.translateToPageCoordinate(startY);
      region.bottom = me.translateToPageCoordinate(endY);
    } else {
      region.top = startY;
      region.bottom = endY;
    }
    return region;
  }
  getRowRegion(resourceRecord, startDate, endDate) {
    const me = this, {
      scheduler
    } = me, x = me.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth, taStart = scheduler.timeAxis.startDate, taEnd = scheduler.timeAxis.endDate, start = startDate ? DateHelper.max(taStart, startDate) : taStart, end = endDate ? DateHelper.min(taEnd, endDate) : taEnd, startY = scheduler.getCoordinateFromDate(start), endY = scheduler.getCoordinateFromDate(end, true, true), y = Math.min(startY, endY), height = Math.abs(startY - endY);
    return new Rectangle(x, y, scheduler.resourceColumnWidth, height);
  }
  get visibleDateRange() {
    const scheduler = this.scheduler, scrollPos = scheduler.scrollable.y, height = scheduler.scrollable.clientHeight, startDate = scheduler.getDateFromCoordinate(scrollPos) || scheduler.timeAxis.startDate, endDate = scheduler.getDateFromCoordinate(scrollPos + height) || scheduler.timeAxis.endDate;
    return {
      startDate,
      endDate,
      startMS: startDate.getTime(),
      endMS: endDate.getTime()
    };
  }
  onResourceColumnWidthChange({
    width,
    oldWidth
  }) {
    const me = this, {
      scheduler
    } = me;
    me.resourceColumns.width = scheduler.timeAxisColumn.width = me.allResourceRecords.length * width;
    me.clearAll();
    me.refresh(Math.abs(width - oldWidth) > 30);
  }
  attachToProject(project) {
    super.attachToProject(project);
    if (project) {
      project.ion({
        name: "project",
        refresh: "onProjectRefresh",
        thisObj: this
      });
    }
  }
  onProjectRefresh() {
    const me = this, {
      scheduler,
      toDrawOnProjectRefresh
    } = me;
    if (scheduler.isVisible) {
      if (scheduler.rendered && !scheduler.refreshSuspended) {
        if (me.refreshAllWhenReady) {
          me.clearAll();
          me.refresh();
          me.refreshAllWhenReady = false;
        } else if (toDrawOnProjectRefresh.size) {
          me.refresh();
        }
        toDrawOnProjectRefresh.clear();
      }
    } else {
      scheduler.whenVisible("refresh", scheduler, [true]);
    }
  }
  attachToEventStore(eventStore) {
    super.attachToEventStore(eventStore);
    this.refreshAllWhenReady = true;
    if (eventStore) {
      eventStore.ion({
        name: "eventStore",
        refreshPreCommit: "onEventStoreRefresh",
        thisObj: this
      });
    }
  }
  onEventStoreRefresh({
    action
  }) {
    if (action === "batch") {
      this.refreshAllWhenReady = true;
    }
  }
  onEventStoreChange({
    action,
    records: eventRecords = [],
    record,
    replaced,
    changes,
    isAssign
  }) {
    const me = this, resourceIds = /* @__PURE__ */ new Set();
    eventRecords.forEach((eventRecord) => {
      var _eventRecord$$linkedR;
      const renderedEventResources = (_eventRecord$$linkedR = eventRecord.$linkedResources) === null || _eventRecord$$linkedR === void 0 ? void 0 : _eventRecord$$linkedR.filter((r) => me.resourceStore.includes(r));
      renderedEventResources === null || renderedEventResources === void 0 ? void 0 : renderedEventResources.forEach((resourceRecord) => resourceIds.add(resourceRecord.id));
    });
    switch (action) {
      case "sort":
      case "group":
      case "move":
      case "remove":
        return;
      case "dataset":
        me.refreshAllResourcesWhenReady();
        return;
      case "add":
      case "updateMultiple":
        break;
      case "replace":
        replaced.forEach(([, newEvent]) => {
          newEvent.resources.map((resourceRecord) => resourceIds.add(resourceRecord.id));
        });
        me.clearResources(resourceIds);
        break;
      case "removeall":
      case "filter":
        me.clearAll();
        me.refresh();
        return;
      case "update": {
        const allChrono = record.$entity ? !Object.keys(changes).some((name) => !record.$entity.getField(name)) : !Object.keys(changes).some((name) => !chronoFields[name]);
        let changeCount = 0;
        if ("startDate" in changes)
          changeCount++;
        if ("endDate" in changes)
          changeCount++;
        if ("duration" in changes)
          changeCount++;
        if (!allChrono || changeCount || "percentDone" in changes || "inactive" in changes || "segments" in changes) {
          me.clearResources(resourceIds);
          me.refresh();
        }
        return;
      }
    }
    me.refreshResourcesWhenReady(resourceIds);
  }
  attachToResourceStore(resourceStore) {
    const me = this;
    super.attachToResourceStore(resourceStore);
    me.refreshAllWhenReady = true;
    if (me.resourceColumns) {
      me.resourceColumns.resourceStore = resourceStore;
    }
    resourceStore.ion({
      name: "resourceStore",
      changePreCommit: "onResourceStoreChange",
      refreshPreCommit: "onResourceStoreRefresh",
      load: () => me.scheduler.unmaskBody(),
      thisObj: me,
      prio: 1
    });
    if (me.initialized && me.scheduler.isPainted) {
      me.firstResource = me.lastResource = null;
      me.clearAll();
      me.renderer();
    }
  }
  onResourceStoreChange({
    source: resourceStore,
    action,
    records = [],
    record,
    replaced,
    changes
  }) {
    const me = this, resourceRecords = replaced ? replaced.map((r) => r[1]) : records, resourceIds = new Set(resourceRecords.map((resourceRecord) => resourceRecord.id));
    me.firstResource = me.lastResource = null;
    resourceStore._allResourceRecords = null;
    const {
      allResourceRecords
    } = resourceStore;
    if (me.scheduler.isEngineReady) {
      switch (action) {
        case "update":
          if (changes !== null && changes !== void 0 && changes.id) {
            me.clearResources([changes.id.oldValue, changes.id.value]);
          } else {
            me.clearResources([record.id]);
          }
          break;
        case "filter":
          me.clearAll();
          break;
      }
      if (changes && "columnWidth" in changes) {
        me.clearAll();
      }
      me.refresh(true);
    } else {
      switch (action) {
        case "dataset":
        case "remove":
        case "removeall":
          me.refreshAllResourcesWhenReady();
          return;
        case "replace":
        case "add": {
          const firstIndex = resourceRecords.reduce((index, record2) => Math.min(index, allResourceRecords.indexOf(record2)), allResourceRecords.length);
          for (let i = firstIndex; i < allResourceRecords.length; i++) {
            resourceIds.add(allResourceRecords[i].id);
          }
        }
      }
      me.refreshResourcesWhenReady(resourceIds);
    }
  }
  onResourceStoreRefresh({
    action
  }) {
    const me = this;
    if (action === "sort" || action === "group") {
      me.firstResource = me.lastResource = me.resourceStore._allResourceRecords = null;
      me.clearAll();
      me.refresh();
    }
  }
  attachToAssignmentStore(assignmentStore) {
    super.attachToAssignmentStore(assignmentStore);
    this.refreshAllWhenReady = true;
    if (assignmentStore) {
      assignmentStore.ion({
        name: "assignmentStore",
        changePreCommit: "onAssignmentStoreChange",
        refreshPreCommit: "onAssignmentStoreRefresh",
        thisObj: this
      });
    }
  }
  onAssignmentStoreChange({
    action,
    records: assignmentRecords = [],
    replaced,
    changes
  }) {
    const me = this, resourceIds = new Set(assignmentRecords.map((assignmentRecord) => assignmentRecord.resourceId));
    if (me.scheduler.isEngineReady) {
      switch (action) {
        case "remove":
          me.clearResources(resourceIds);
          break;
        case "filter":
          me.clearAll();
          break;
        case "update": {
          if ("resourceId" in changes) {
            resourceIds.add(changes.resourceId.oldValue);
          }
          if (!Object.keys(changes).filter((field) => field !== "resource" && field !== "event").length) {
            return;
          }
          me.clearResources(resourceIds);
        }
      }
      me.refresh(true);
    } else {
      if (changes && "resourceId" in changes) {
        resourceIds.add(changes.resourceId.oldValue);
      }
      switch (action) {
        case "removeall":
          me.refreshAllResourcesWhenReady();
          return;
        case "replace":
          replaced.forEach(([oldAssignment, newAssignment]) => {
            resourceIds.add(oldAssignment.resourceId);
            resourceIds.add(newAssignment.resourceId);
          });
      }
      me.refreshResourcesWhenReady(resourceIds);
    }
  }
  onAssignmentStoreRefresh({
    action,
    records
  }) {
    if (action === "batch") {
      this.clearAll();
      this.refreshAllResourcesWhenReady();
    }
  }
  refreshRows(reLayoutEvents) {
    if (reLayoutEvents) {
      this.clearAll();
      this.scheduler.refreshFromRerender = false;
    }
  }
  repaintEventsForResource(resourceRecord) {
    this.renderResource(resourceRecord);
  }
  updateFromHorizontalScroll(scrollX) {
    if (scrollX !== this.prevScrollX) {
      this.renderer();
      this.prevScrollX = scrollX;
    }
  }
  updateFromVerticalScroll() {
    this.renderer();
  }
  scrollResourceIntoView(resourceRecord, options) {
    const {
      scheduler
    } = this, x = this.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth;
    return scheduler.scrollHorizontallyTo(x, options);
  }
  get allResourceRecords() {
    return this.scheduler.resourceStore.allResourceRecords;
  }
  onViewportResize(width) {
    this.resourceColumns.availableWidth = width;
    this.renderer();
  }
  get resourceColumns() {
    var _this$scheduler$timeA;
    return (_this$scheduler$timeA = this.scheduler.timeAxisColumn) === null || _this$scheduler$timeA === void 0 ? void 0 : _this$scheduler$timeA.resourceColumns;
  }
  onLocaleChange() {
    this.clearAll();
  }
  onDragAbort() {
  }
  onBeforeRowHeightChange() {
  }
  onTimeAxisViewModelUpdate() {
  }
  updateElementId() {
  }
  releaseTimeSpanDiv() {
  }
  getConnectorStartSide(eventRecord) {
    return "top";
  }
  getConnectorEndSide(eventRecord) {
    return "bottom";
  }
  refreshResourcesWhenReady(resourceIds) {
    this.clearResources(resourceIds);
    resourceIds.forEach((id) => this.toDrawOnProjectRefresh.add(id));
  }
  refreshAllResourcesWhenReady() {
    this.clearAll();
    this.refreshAllWhenReady = true;
  }
  get resourceRange() {
    return this.getResourceRange(true);
  }
  get visibleResources() {
    const {
      first,
      last
    } = this.getResourceRange();
    return {
      first: this.allResourceRecords[first],
      last: this.allResourceRecords[last]
    };
  }
  getResourceRange(withBuffer) {
    const {
      scheduler,
      resourceStore
    } = this, {
      resourceColumnWidth,
      scrollX
    } = scheduler, {
      scrollWidth
    } = scheduler.timeAxisSubGrid.scrollable, resourceBufferSize = withBuffer ? this.resourceBufferSize : 0, viewportStart = scrollX - resourceBufferSize, viewportEnd = scrollX + scrollWidth + resourceBufferSize;
    if (!(resourceStore !== null && resourceStore !== void 0 && resourceStore.count)) {
      return {
        first: -1,
        last: -1
      };
    }
    if (scheduler.variableColumnWidths) {
      let first, last, start, end = 0;
      this.allResourceRecords.forEach((resource, i) => {
        resource.instanceMeta(scheduler).insetStart = start = end;
        end = start + resource.columnWidth;
        if (start > viewportEnd) {
          return false;
        }
        if (end > viewportStart && first == null) {
          first = i;
        } else if (start < viewportEnd) {
          last = i;
        }
      });
      return {
        first,
        last
      };
    } else {
      return {
        first: Math.max(Math.floor(scrollX / resourceColumnWidth) - resourceBufferSize, 0),
        last: Math.min(Math.floor((scrollX + scheduler.timeAxisSubGrid.width) / resourceColumnWidth) + resourceBufferSize, this.allResourceRecords.length - 1)
      };
    }
  }
  get dateRange() {
    const {
      scheduler
    } = this;
    let bottomDate = scheduler.getDateFromCoordinate(Math.min(scheduler.scrollTop + scheduler.bodyHeight + scheduler.tickSize - 1, (scheduler.virtualScrollHeight || scheduler.scrollable.scrollHeight) - 1));
    if (!bottomDate) {
      bottomDate = scheduler.timeAxis.last.endDate;
    }
    let topDate = scheduler.getDateFromCoordinate(Math.max(scheduler.scrollTop - scheduler.tickSize, 0));
    if (!topDate) {
      topDate = scheduler.timeAxis.first.startDate;
      bottomDate = scheduler.getDateFromCoordinate(scheduler.bodyHeight + scheduler.tickSize - 1);
    }
    return {
      topDate,
      bottomDate
    };
  }
  getTimeSpanRenderData(eventRecord, resourceRecord, includeOutside = false) {
    var _scheduler$features$e;
    const me = this, {
      scheduler
    } = me, {
      preamble,
      postamble
    } = eventRecord, {
      variableColumnWidths
    } = scheduler, useEventBuffer = ((_scheduler$features$e = scheduler.features.eventBuffer) === null || _scheduler$features$e === void 0 ? void 0 : _scheduler$features$e.enabled) && me.isProVerticalRendering && (preamble || postamble) && !eventRecord.isMilestone, startDateField = useEventBuffer ? "wrapStartDate" : "startDate", endDateField = useEventBuffer ? "wrapEndDate" : "endDate", startDate = eventRecord.isBatchUpdating && eventRecord.hasBatchedChange(startDateField) && !useEventBuffer ? eventRecord.get(startDateField) : eventRecord[startDateField], endDate = eventRecord.isBatchUpdating && eventRecord.hasBatchedChange(endDateField) && !useEventBuffer ? eventRecord.get(endDateField) : eventRecord[endDateField], resourceMargin = scheduler.getResourceMargin(resourceRecord), top = scheduler.getCoordinateFromDate(startDate), instanceMeta = resourceRecord.instanceMeta(scheduler), left = variableColumnWidths ? instanceMeta.insetStart : me.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth, resourceWidth = scheduler.getResourceWidth(resourceRecord), width = resourceWidth - resourceMargin * 2, startDateMS = startDate.getTime(), endDateMS = endDate.getTime();
    let bottom = scheduler.getCoordinateFromDate(endDate), height = bottom - top;
    if (bottom === -1) {
      height = Math.round((endDateMS - startDateMS) * scheduler.timeAxisViewModel.getSingleUnitInPixels("millisecond"));
      bottom = top + height;
    }
    return {
      eventRecord,
      resourceRecord,
      left,
      top,
      bottom,
      resourceWidth,
      width,
      height,
      startDate,
      endDate,
      startDateMS,
      endDateMS,
      useEventBuffer,
      children: [],
      start: startDate,
      end: endDate,
      startMS: startDateMS,
      endMS: endDateMS
    };
  }
  eventSorter(a, b) {
    const startA = a.dataStartMs || a.startDateMS, endA = a.dataEndMs || a.endDateMS, startB = b.dataStartMs || b.startDateMS, endB = b.dataEndMs || b.endDateMS, nameA = a.isModel ? a.name : a.eventRecord.name, nameB = b.isModel ? b.name : b.eventRecord.name;
    return startA - startB || endB - endA || (nameA < nameB ? -1 : nameA == nameB ? 0 : 1);
  }
  layoutResource(resourceRecord) {
    const me = this, {
      scheduler
    } = me, {
      variableColumnWidths
    } = scheduler, {
      id: resourceId
    } = resourceRecord, instanceMeta = resourceRecord.instanceMeta(scheduler), {
      assignmentStore,
      eventStore,
      timeAxis
    } = scheduler, cache = me.resourceMap.set(resourceId, {}).get(resourceId), resourceIndex = me.allResourceRecords.indexOf(resourceRecord), {
      barMargin,
      resourceMargin
    } = scheduler.getResourceLayoutSettings(resourceRecord);
    let events = eventStore.getEvents({
      includeOccurrences: scheduler.enableRecurringEvents,
      resourceRecord,
      startDate: timeAxis.startDate,
      endDate: timeAxis.endDate,
      filter: (assignmentStore.isFiltered || eventStore.isFiltered) && ((eventRecord) => eventRecord.assignments.some((a) => a.resource === resourceRecord && assignmentStore.includes(a)))
    });
    events = scheduler.getEventsToRender(resourceRecord, events);
    const layoutData = events.reduce((toLayout, eventRecord) => {
      if (eventRecord.isScheduled) {
        const renderData = scheduler.generateRenderData(eventRecord, resourceRecord, false), eventData = {
          renderData
        }, eventResources = ObjectHelper.getMapPath(me.eventMap, renderData.eventId, {});
        eventResources[resourceId] = eventData;
        cache[renderData.eventId] = eventData;
        if (renderData.fillSize) {
          renderData.left = variableColumnWidths ? instanceMeta.insetStart : resourceIndex * scheduler.resourceColumnWidth;
          renderData.width = scheduler.getResourceWidth(resourceRecord);
        } else {
          toLayout.push(renderData);
        }
      }
      return toLayout;
    }, []);
    layoutData.sort(me.eventSorter);
    me.verticalLayout.applyLayout(layoutData, scheduler.getResourceWidth(resourceRecord), resourceMargin, barMargin, resourceIndex, scheduler.getEventLayout(resourceRecord));
    return cache;
  }
  addTemporaryDragElement(eventRecord) {
    const {
      scheduler
    } = this, renderData = scheduler.generateRenderData(eventRecord, eventRecord.resource, {
      timeAxis: true,
      viewport: true
    });
    renderData.top = renderData.row ? renderData.top + renderData.row.top : scheduler.getResourceEventBox(eventRecord, eventRecord.resource, true).top;
    const domConfig = this.renderEvent({
      renderData
    }), {
      dataset
    } = domConfig;
    delete domConfig.tabIndex;
    delete dataset.eventId;
    delete dataset.resourceId;
    delete dataset.assignmentId;
    delete dataset.syncId;
    dataset.transient = true;
    domConfig.parent = this.scheduler.foregroundCanvas;
    domConfig.retainElement = true;
    const result = DomHelper.createElement(domConfig);
    result.innerElement = result.firstChild;
    eventRecord.instanceMeta(scheduler).hasTemporaryDragElement = true;
    return result;
  }
  renderEvent(eventData) {
    const {
      scheduler
    } = this, data = eventData.renderData, {
      resourceRecord,
      assignmentRecord,
      eventRecord
    } = data, elementConfig = {
      className: data.wrapperCls,
      tabIndex: -1,
      children: [{
        role: "presentation",
        className: data.cls,
        style: (data.internalStyle || "") + (data.style || ""),
        children: data.children,
        dataset: {
          taskFeature: "event"
        },
        syncOptions: {
          syncIdField: "taskBarFeature"
        }
      }, ...data.wrapperChildren],
      style: {
        top: data.top,
        [scheduler.rtl ? "right" : "left"]: data.left,
        height: eventRecord.isMilestone ? "1em" : data.height,
        width: data.width,
        style: data.wrapperStyle || "",
        fontSize: eventRecord.isMilestone ? Math.min(data.width, 40) : null
      },
      dataset: {
        resourceId: resourceRecord.id,
        eventId: data.eventId,
        syncId: assignmentRecord ? this.assignmentStore.getOccurrence(assignmentRecord, eventRecord).id : data.eventId
      },
      elementData: eventData,
      retainElement: (assignmentRecord || eventRecord).instanceMeta(this.scheduler).retainElement,
      syncOptions: {
        syncIdField: "taskFeature",
        releaseThreshold: 0
      }
    };
    elementConfig.className["b-sch-vertical"] = 1;
    if (data.zIndex) {
      elementConfig.zIndex = data.zIndex;
    }
    if (assignmentRecord) {
      elementConfig.dataset.assignmentId = assignmentRecord.id;
    }
    eventData.elementConfig = elementConfig;
    return elementConfig;
  }
  renderResource(resourceRecord) {
    const me = this, {
      topDateMS,
      bottomDateMS
    } = me, eventDOMConfigs = [];
    let resourceEntry = me.resourceMap.get(resourceRecord.id);
    if (!resourceEntry) {
      resourceEntry = me.layoutResource(resourceRecord);
    }
    for (const eventId in resourceEntry) {
      const eventData = resourceEntry[eventId], {
        endDateMS,
        startDateMS,
        eventRecord
      } = eventData.renderData;
      if (endDateMS >= topDateMS && startDateMS <= bottomDateMS && !eventRecord.instanceMeta(me.scheduler).hasTemporaryDragElement) {
        var _eventData$elementCon;
        const domConfig = ((_eventData$elementCon = eventData.elementConfig) === null || _eventData$elementCon === void 0 ? void 0 : _eventData$elementCon.className) !== "b-released" && eventData.elementConfig || me.renderEvent(eventData);
        eventDOMConfigs.push(domConfig);
      }
    }
    return eventDOMConfigs;
  }
  isEventElement(domConfig) {
    const className = domConfig && domConfig.className;
    return className && className[this.scheduler.eventCls + "-wrap"];
  }
  renderer() {
    const me = this, {
      scheduler
    } = me, {
      first: firstResource,
      last: lastResource
    } = me.resourceRange, {
      topDate,
      bottomDate
    } = me.dateRange, syncConfigs = [], featureDomConfigs = [];
    if (!me.initialized || !scheduler.isEngineReady && !scheduler.isCreating) {
      return;
    }
    if (!DateHelper.isEqual(topDate, me.topDate) || !DateHelper.isEqual(bottomDate, me.bottomDate)) {
      me.topDate = topDate;
      me.bottomDate = bottomDate;
      me.topDateMS = topDate.getTime();
      me.bottomDateMS = bottomDate.getTime();
      const range = me.timeView.range = {
        startDate: topDate,
        endDate: bottomDate
      };
      scheduler.onVisibleDateRangeChange(range);
    }
    if (firstResource !== -1 && lastResource !== -1) {
      for (let i = firstResource; i <= lastResource; i++) {
        syncConfigs.push.apply(syncConfigs, me.renderResource(me.allResourceRecords[i]));
      }
    }
    scheduler.getForegroundDomConfigs(featureDomConfigs);
    syncConfigs.push.apply(syncConfigs, featureDomConfigs);
    DomSync.sync({
      domConfig: {
        onlyChildren: true,
        children: syncConfigs
      },
      targetElement: scheduler.foregroundCanvas,
      syncIdField: "syncId",
      callback({
        action,
        domConfig,
        lastDomConfig,
        targetElement,
        jsx
      }) {
        var _domConfig$elementDat;
        const {
          reactComponent
        } = scheduler;
        if (me.isEventElement(domConfig) || jsx || domConfig !== null && domConfig !== void 0 && (_domConfig$elementDat = domConfig.elementData) !== null && _domConfig$elementDat !== void 0 && _domConfig$elementDat.jsx) {
          var _scheduler$processEve;
          const isRelease = releaseEventActions[action], isRender = renderEventActions[action];
          if ((_scheduler$processEve = scheduler.processEventContent) !== null && _scheduler$processEve !== void 0 && _scheduler$processEve.call(scheduler, {
            action,
            domConfig,
            isRelease: false,
            targetElement,
            reactComponent,
            jsx
          }))
            return;
          if (isRelease && me.isEventElement(lastDomConfig) && !lastDomConfig.isReleased) {
            var _scheduler$processEve2;
            const data = lastDomConfig.elementData.renderData, event = {
              renderData: data,
              assignmentRecord: data.assignmentRecord,
              eventRecord: data.eventRecord,
              resourceRecord: data.resourceRecord,
              element: targetElement
            };
            (_scheduler$processEve2 = scheduler.processEventContent) === null || _scheduler$processEve2 === void 0 ? void 0 : _scheduler$processEve2.call(scheduler, {
              isRelease,
              targetElement,
              reactComponent,
              assignmentRecord: data.assignmentRecord
            });
            if (targetElement === DomHelper.getActiveElement(targetElement)) {
              scheduler.focusElement.focus();
            }
            scheduler.trigger("releaseEvent", event);
          }
          if (isRender) {
            const data = domConfig.elementData.renderData, event = {
              renderData: data,
              assignmentRecord: data.assignmentRecord,
              eventRecord: data.eventRecord,
              resourceRecord: data.resourceRecord,
              element: targetElement,
              isReusingElement: action === "reuseElement",
              isRepaint: action === "reuseOwnElement"
            };
            event.reusingElement = action === "reuseElement";
            scheduler.trigger("renderEvent", event);
          }
        }
      }
    });
    if (me.firstResource !== firstResource || me.lastResource !== lastResource) {
      const range = me.resourceColumns.visibleResources = {
        firstResource,
        lastResource
      };
      me.firstResource = firstResource;
      me.lastResource = lastResource;
      scheduler.onVisibleResourceRangeChange(range);
      scheduler.trigger("resourceRangeChange", range);
    }
  }
  refresh(transition) {
    this.scheduler.runWithTransition(() => this.renderer(), transition);
  }
  refreshResources(resourceIds) {
    this.clearResources(resourceIds);
    this.refresh();
  }
  refreshEventsForResource(recordOrRow, force = true, draw = true) {
    this.refreshResources([recordOrRow.id]);
  }
  onRenderDone() {
  }
  get timeView() {
    return this.scheduler.timeView;
  }
  clearResources(resourceIds) {
    const {
      resourceMap,
      eventMap
    } = this;
    resourceIds.forEach((resourceId) => {
      if (resourceMap.has(resourceId)) {
        Object.values(resourceMap.get(resourceId)).forEach(({
          renderData: {
            eventId
          }
        }) => {
          delete eventMap.get(eventId)[resourceId];
        });
        resourceMap.delete(resourceId);
      }
    });
  }
  clearAll() {
    this.resourceMap.clear();
    this.eventMap.clear();
  }
};
VerticalRendering._$name = "VerticalRendering";
var descriptionFormats = {
  month: "MMMM, YYYY",
  week: ["MMMM YYYY (Wp)", "S{MMM} - E{MMM YYYY} (S{Wp})"],
  day: "MMMM D, YYYY"
};
var SchedulerBase = class extends TimelineBase.mixin(CrudManagerView, Describable, SchedulerDom, SchedulerDomEvents, SchedulerStores, SchedulerScroll, SchedulerState, SchedulerEventRendering, SchedulerRegions, SchedulerEventSelection, SchedulerEventNavigation, CurrentConfig) {
  static get $name() {
    return "SchedulerBase";
  }
  static get type() {
    return "schedulerbase";
  }
  static get configurable() {
    return {
      date: {
        value: null,
        $config: {
          equal: "date"
        }
      },
      stepUnit: "week",
      range: "week",
      getDateConstraints: null,
      verticalTimeAxisColumn: {},
      createEventOnDblClick: true,
      schedulableAreaSelector: ".b-sch-timeaxis-cell",
      scheduledEventName: "event",
      sortFeatureStore: "resourceStore"
    };
  }
  static get defaultConfig() {
    return {
      mode: "horizontal",
      eventCls: "b-sch-event",
      timeCellCls: "b-sch-timeaxis-cell",
      overScheduledEventClass: "b-sch-event-hover",
      allowOverlap: true,
      rowHeight: 60,
      preCalculateHeightLimit: 1e4,
      crudManagerClass: CrudManager$1,
      testConfig: {
        loadMaskError: {
          autoClose: 10,
          showDelay: 0
        }
      }
    };
  }
  afterConstruct() {
    const me = this;
    super.afterConstruct();
    me.ion({
      scroll: "onVerticalScroll",
      thisObj: me
    });
    if (me.createEventOnDblClick) {
      me.ion({
        scheduledblclick: me.onTimeAxisCellDblClick
      });
    }
  }
  onPaintOverride() {
  }
  get store() {
    return super.store;
  }
  set store(store) {
    super.store = store;
  }
  get visibleResources() {
    var _me$firstVisibleRow, _me$lastVisibleRow;
    const me = this;
    if (me.isVertical) {
      return me.currentOrientation.visibleResources;
    }
    return {
      first: me.store.getById((_me$firstVisibleRow = me.firstVisibleRow) === null || _me$firstVisibleRow === void 0 ? void 0 : _me$firstVisibleRow.id),
      last: me.store.getById((_me$lastVisibleRow = me.lastVisibleRow) === null || _me$lastVisibleRow === void 0 ? void 0 : _me$lastVisibleRow.id)
    };
  }
  onLocaleChange() {
    this.currentOrientation.onLocaleChange();
    super.onLocaleChange();
  }
  onTimeAxisCellDblClick({
    date: startDate,
    resourceRecord,
    row
  }) {
    const me = this;
    if (me.readOnly || resourceRecord.isSpecialRow || resourceRecord.readOnly) {
      return;
    }
    me.createEvent(startDate, resourceRecord, row);
  }
  onVerticalScroll({
    scrollTop
  }) {
    this.currentOrientation.updateFromVerticalScroll(scrollTop);
  }
  onEventCreated(eventRecord) {
  }
  get isHorizontal() {
    return this.mode === "horizontal";
  }
  get isVertical() {
    return this.mode === "vertical";
  }
  get mode() {
    return this._mode;
  }
  set mode(mode) {
    const me = this;
    me._mode = mode;
    if (!me[mode]) {
      me.element.classList.add(`b-sch-${mode}`);
      if (mode === "horizontal") {
        me.horizontal = new HorizontalRendering(me);
        if (me.isPainted) {
          me.horizontal.init();
        }
      } else if (mode === "vertical") {
        me.vertical = new VerticalRendering(me);
        if (me.rendered) {
          me.vertical.init();
        }
      }
    }
  }
  get currentOrientation() {
    return this[this.mode];
  }
  onElementKeyDown(event) {
    return super.onElementKeyDown(event);
  }
  onElementKeyUp(event) {
    return super.onElementKeyUp(event);
  }
  onElementMouseOver(event) {
    return super.onElementMouseOver(event);
  }
  onElementMouseOut(event) {
    return super.onElementMouseOut(event);
  }
  processEventDrop() {
  }
  processCrossSchedulerEventDrop() {
  }
  beforeEventDragStart() {
  }
  afterEventDragStart() {
  }
  afterEventDragAbortFinalized() {
  }
  checkEventDragValidity() {
  }
  afterEventResizeStart() {
  }
  get hasEventEditor() {
    const {
      eventEdit,
      taskEdit,
      simpleEventEdit
    } = this.features;
    return Boolean((eventEdit === null || eventEdit === void 0 ? void 0 : eventEdit.enabled) || (taskEdit === null || taskEdit === void 0 ? void 0 : taskEdit.enabled) || (simpleEventEdit === null || simpleEventEdit === void 0 ? void 0 : simpleEventEdit.enabled));
  }
  editEvent(eventRecord, resourceRecord, element) {
    const me = this, {
      eventStore,
      assignmentStore
    } = me;
    if (!me.hasEventEditor) {
      return false;
    }
    if (eventRecord.eventStore !== eventStore) {
      const {
        enableEventAnimations
      } = me, resourceRecords = [];
      eventRecord.isCreating = true;
      let assignmentRecords = [];
      if (resourceRecord) {
        resourceRecords.push(resourceRecord);
        assignmentRecords = assignmentStore.assignEventToResource(eventRecord, resourceRecord);
      }
      if (me.trigger("beforeEventAdd", {
        eventRecord,
        resourceRecords,
        assignmentRecords
      }) === false) {
        assignmentStore === null || assignmentStore === void 0 ? void 0 : assignmentStore.remove(assignmentRecords);
        return false;
      }
      me.enableEventAnimations = false;
      eventStore.add(eventRecord);
      me.project.commitAsync().then(() => me.enableEventAnimations = enableEventAnimations);
      me.refreshRows();
    }
  }
  async createEvent(startDate, resourceRecord) {
    var _features$eventEdit, _features$taskEdit, _features$simpleEvent;
    const me = this, {
      enableEventAnimations,
      features,
      eventStore,
      assignmentStore
    } = me, resourceRecords = [resourceRecord], useEventModelDefaults = me.createEventOnDblClick.useEventModelDefaults, defaultDuration = useEventModelDefaults ? eventStore.modelClass.defaultValues.duration : 1, defaultDurationUnit = useEventModelDefaults ? eventStore.modelClass.defaultValues.durationUnit : me.timeAxis.unit, eventRecord = eventStore.createRecord({
      startDate,
      endDate: DateHelper.add(startDate, defaultDuration, defaultDurationUnit),
      duration: defaultDuration,
      durationUnit: defaultDurationUnit,
      name: me.L("L{Object.newEvent}")
    }), eventEditAvailable = Boolean(((_features$eventEdit = features.eventEdit) === null || _features$eventEdit === void 0 ? void 0 : _features$eventEdit.enabled) || ((_features$taskEdit = features.taskEdit) === null || _features$taskEdit === void 0 ? void 0 : _features$taskEdit.enabled) || ((_features$simpleEvent = features.simpleEventEdit) === null || _features$simpleEvent === void 0 ? void 0 : _features$simpleEvent.enabled));
    if (me.readOnly || resourceRecord.isSpecialRow || !me.allowOverlap && !me.isDateRangeAvailable(eventRecord.startDate, eventRecord.endDate, null, resourceRecord)) {
      return;
    }
    eventRecord.isCreating = eventEditAvailable;
    me.onEventCreated(eventRecord);
    const assignmentRecords = assignmentStore === null || assignmentStore === void 0 ? void 0 : assignmentStore.assignEventToResource(eventRecord, resourceRecord);
    if (me.trigger("beforeEventAdd", {
      eventRecord,
      resourceRecords,
      assignmentRecords
    }) === false) {
      assignmentStore === null || assignmentStore === void 0 ? void 0 : assignmentStore.remove(assignmentRecords);
      return;
    }
    me.enableEventAnimations = false;
    eventStore.add(eventRecord);
    me.project.commitAsync().then(() => me.enableEventAnimations = enableEventAnimations);
    me.isCreating = true;
    me.refreshRows();
    me.isCreating = false;
    me.trigger("eventAutoCreated", {
      eventRecord,
      resourceRecord
    });
    if (eventEditAvailable) {
      me.editEvent(eventRecord, resourceRecord, me.getEventElement(eventRecord));
    }
  }
  isDateRangeAvailable(start, end, excludeEvent, resource) {
    return this.eventStore.isDateRangeAvailable(start, end, excludeEvent, resource);
  }
  async resumeRefresh(trigger) {
    super.resumeRefresh(false);
    const me = this;
    if (!me.refreshSuspended && trigger) {
      if (!me.isEngineReady) {
        me.currentOrientation.refreshAllWhenReady = true;
        return me.project.commitAsync();
      }
      if (!me.isDestroyed) {
        me.refreshWithTransition();
      }
    }
  }
  toggleEmptyText() {
    const me = this;
    if (me.bodyContainer) {
      var _me$crudManager;
      DomHelper.toggleClasses(me.bodyContainer, "b-grid-empty", !(me.resourceStore.count > 0 || (_me$crudManager = me.crudManager) !== null && _me$crudManager !== void 0 && _me$crudManager.isLoading));
    }
  }
  getRowHeight(resourceRecord) {
    if (this.isHorizontal) {
      const height = this.currentOrientation.calculateRowHeight(resourceRecord);
      this.rowManager.storeKnownHeight(resourceRecord.id, height);
      return height;
    }
  }
  calculateRowHeights(resourceRecords, silent = false) {
    resourceRecords.forEach((resourceRecord) => resourceRecord && this.getRowHeight(resourceRecord));
    if (!silent) {
      this.rowManager.estimateTotalHeight(true);
    }
  }
  calculateAllRowHeights(silent = false) {
    const {
      store,
      rowManager
    } = this, count = Math.min(store.count, this.preCalculateHeightLimit);
    if (count) {
      rowManager.clearKnownHeights();
      for (let i = 0; i < count; i++) {
        this.getRowHeight(store.getAt(i));
      }
      if (!silent) {
        rowManager.estimateTotalHeight(true);
      }
    }
  }
  get dateBounds() {
    const me = this, ret = [me.startDate];
    if (me.range === "week") {
      ret.push(me.lastDate);
    }
    return ret;
  }
  get defaultDescriptionFormat() {
    return descriptionFormats[this.range];
  }
  get lastDate() {
    const lastDate = this.endDate;
    return lastDate && DateHelper.add(lastDate, -1, "day");
  }
  getEventRecord(target) {
    target = DomHelper.getEventElement(target);
    return this.resolveEventRecord(target);
  }
  getEventElement(eventRecord) {
    return this.getElementFromEventRecord(eventRecord);
  }
  changeRange(unit) {
    return DateHelper.normalizeUnit(unit);
  }
  updateRange(unit) {
    if (!this.isConfiguring) {
      const currentDate = this.date, newDate = this.date = DateHelper.startOf(currentDate, unit);
      if (currentDate.getTime() === newDate.getTime()) {
        this.updateDate(newDate);
      }
    }
  }
  changeStepUnit(unit) {
    return DateHelper.normalizeUnit(unit);
  }
  updateDate(newDate) {
    const me = this, start = DateHelper.startOf(newDate, me.range);
    me.setTimeSpan(start, DateHelper.add(start, 1, me.range));
    me.visibleDate = {
      date: DateHelper.max(newDate, me.timeAxis.startDate),
      block: "start",
      animate: true
    };
    me.trigger("descriptionChange");
  }
  previous() {
    this.date = DateHelper.add(this.date, -1, this.stepUnit);
  }
  next() {
    this.date = DateHelper.add(this.date, 1, this.stepUnit);
  }
  async scheduleEvent({
    startDate,
    eventRecord,
    resourceRecord,
    element
  }) {
    const me = this;
    if (!me.eventStore.includes(eventRecord)) {
      [eventRecord] = me.eventStore.add(eventRecord);
    }
    eventRecord.startDate = startDate;
    eventRecord.assign(resourceRecord);
    if (element) {
      const eventRect = Rectangle.from(element, me.foregroundCanvas);
      DomHelper.setTranslateXY(element, 0, 0);
      DomHelper.setTopLeft(element, eventRect.y, eventRect.x);
      DomSync.addChild(me.foregroundCanvas, element, eventRecord.assignments[0].id);
    }
    await me.project.commitAsync();
  }
  onSelectionDrag(event) {
    if (event.target.classList.contains("b-timeaxis-cell")) {
      return;
    }
    super.onSelectionDrag(event);
  }
};
_defineProperty(SchedulerBase, "properties", {
  timeCellSelector: ".b-sch-timeaxis-cell",
  resourceTimeRangeSelector: ".b-sch-resourcetimerange"
});
SchedulerBase.initClass();
SchedulerBase._$name = "SchedulerBase";
var ScheduleTableExporter = class extends Localizable(TableExporter) {
  static get defaultConfig() {
    return {
      includeUnassigned: true,
      eventColumns: [{
        text: "Task",
        field: "name"
      }, {
        text: "Starts",
        field: "startDate",
        width: 140
      }, {
        text: "Ends",
        field: "endDate",
        width: 140
      }],
      eventSortFn: null
    };
  }
  construct(config = {}, ...args) {
    super.construct(config, ...args);
    if (!this.eventSortFn) {
      this.eventSortFn = (a, b) => a.internalId - b.internalId;
    }
  }
  normalizeColumns(config) {
    super.normalizeColumns(config);
    config.eventColumns = config.eventColumns.map((col) => {
      if (typeof col === "string") {
        return {
          field: col
        };
      } else {
        return col;
      }
    });
  }
  generateExportData(config) {
    const me = this, isScheduler = this.target instanceof SchedulerBase, resourceColumns = me.generateColumns(config), eventColumns = isScheduler ? me.generateEventColumns(config) : [], columns = resourceColumns.concat(eventColumns), rows = me.generateRows(config);
    return {
      columns,
      rows
    };
  }
  generateEventColumns(config) {
    return config.eventColumns.map((column) => this.processEventColumn(column, config));
  }
  processEventColumn(column, config) {
    const {
      width,
      minWidth
    } = column, {
      defaultColumnWidth
    } = config;
    return {
      field: column.field,
      value: column.text,
      width: Math.max(width || defaultColumnWidth, minWidth || defaultColumnWidth),
      eventColumn: true,
      type: this.getColumnType(column, this.target.eventStore)
    };
  }
  generateRows(config) {
    const me = this, {
      target
    } = me;
    let result;
    if (!(target instanceof SchedulerBase)) {
      result = super.generateRows(config);
    } else {
      result = [];
      target.resourceStore.map((resourceRecord) => {
        const events = resourceRecord.events || [];
        events.sort(me.eventSortFn);
        if (!events.length) {
          events.push("");
        }
        events.forEach((eventRecord) => result.push(me.getRowData(config, resourceRecord, eventRecord)));
      });
      if (config.includeUnassigned && config.eventColumns.length) {
        const notAssignedEvents = target.eventStore.query((eventRecord) => !eventRecord.resources.length);
        if (notAssignedEvents.length) {
          const cells = new Array(config.columns.length).fill("");
          cells.push(me.L("L{ExcelExporter.No resource assigned}"));
          result.push(cells);
          notAssignedEvents.forEach((eventRecord) => result.push(me.getRowData(config, null, eventRecord)));
        }
      }
      result = result.filter((cells) => cells.length);
    }
    return result;
  }
  getRowData(config, resource, event) {
    const {
      columns,
      eventColumns
    } = config, cells = [], resourceCells = this.processRecord(resource, columns, config);
    resourceCells && cells.push(...resourceCells);
    if (!resource || !resource.isSpecialRow) {
      const eventCells = this.processRecord(event, eventColumns, config);
      eventCells && cells.push(...eventCells);
    }
    return cells;
  }
};
ScheduleTableExporter._$name = "ScheduleTableExporter";
var ExcelExporter = class extends ExcelExporter$1 {
  static get $name() {
    return "ExcelExporter";
  }
  static get defaultConfig() {
    return {
      exporterClass: ScheduleTableExporter,
      exporterConfig: null
    };
  }
};
ExcelExporter._$name = "ExcelExporter";
GridFeatureManager.registerFeature(ExcelExporter, false, "Scheduler");
var Scheduler = class extends SchedulerBase {
  static get $name() {
    return "Scheduler";
  }
  static get type() {
    return "scheduler";
  }
};
Scheduler.initClass();
Scheduler._$name = "Scheduler";
var ProjectCombo = class extends Combo {
  static get $name() {
    return "ProjectCombo";
  }
  static get type() {
    return "projectcombo";
  }
  static get configurable() {
    return {
      project: null,
      displayField: "title",
      valueField: "url",
      highlightExternalChange: false,
      editable: false
    };
  }
  updateProject(project) {
    var _project$transport$lo;
    if ((_project$transport$lo = project.transport.load) !== null && _project$transport$lo !== void 0 && _project$transport$lo.url) {
      this.value = project.transport.load.url;
    }
  }
  onChange({
    value,
    userAction
  }) {
    if (userAction && this.project) {
      this.project.transport.load.url = value;
      this.project.load();
    }
  }
};
ProjectCombo.initClass();
ProjectCombo._$name = "ProjectCombo";
var ResourceFilter = class extends List {
  static get $name() {
    return "ResourceFilter";
  }
  static get type() {
    return "resourcefilter";
  }
  static get delayable() {
    return {
      applyFilter: "raf"
    };
  }
  static get configurable() {
    return {
      eventStore: null,
      multiSelect: true,
      toggleAllIfCtrlPressed: true,
      itemTpl: (record) => StringHelper.encodeHtml(record.name || ""),
      masterFilter: () => true
    };
  }
  itemIconTpl(record, i) {
    const {
      eventColor
    } = record, cls = DomHelper.isNamedColor(eventColor) ? ` b-sch-foreground-${eventColor}` : "", style = !cls && eventColor ? ` style="color:${eventColor}"` : "";
    return this.multiSelect ? `<div class="b-selected-icon b-icon${cls}"${style}></div>` : "";
  }
  updateEventStore(eventStore) {
    var _me$initialConfig$sto, _me$store;
    const me = this, chainedStoreConfig = (_me$initialConfig$sto = me.initialConfig.store) !== null && _me$initialConfig$sto !== void 0 && _me$initialConfig$sto.isStore ? me.initialConfig.store.initialConfig : (_me$store = me.store) === null || _me$store === void 0 ? void 0 : _me$store.config, {
      resourceStore
    } = eventStore, store = me.store = resourceStore.chain(me.masterFilter, null, _objectSpread2(_objectSpread2({}, chainedStoreConfig), {}, {
      syncOrder: true
    })), changeListeners = {
      change: "onStoreChange",
      thisObj: me
    };
    store.un(changeListeners);
    resourceStore.ion(changeListeners);
    if (!resourceStore.count) {
      resourceStore.project.ion({
        name: "project",
        refresh: "initFilter",
        thisObj: me
      });
    } else {
      me.initFilter();
    }
  }
  changeMasterFilter(masterFilter) {
    const me = this;
    return function(r) {
      return masterFilter.call(me, r);
    };
  }
  initFilter() {
    const {
      eventStore,
      selected
    } = this;
    if (eventStore.count && eventStore.resourceStore.count) {
      if (!this.initialSelection) {
        selected.add(this.store.getRange());
      }
      this.detachListeners("project");
    }
  }
  onStoreRefresh({
    source: store,
    action
  }) {
    if (action === "filter" && this.resourceFilter) {
      const {
        resourceFilter
      } = this, {
        disabled
      } = resourceFilter, newDisabled = !store.isFiltered && this.allSelected;
      if (newDisabled !== disabled) {
        resourceFilter.disabled = newDisabled;
        this.applyFilter();
      }
    }
    super.onStoreRefresh(...arguments);
  }
  onSelectionChange({
    source: selected,
    added,
    removed
  }) {
    const me = this, disabled = !me.store.isFiltered && me.allSelected;
    super.onSelectionChange(...arguments);
    if (!me.resourceFilter) {
      me.resourceFilter = me.eventStore.addFilter({
        id: `${me.id}-filter-instance`,
        filterBy: (e) => !e.resource || me.selected.includes(e.resources),
        disabled
      }, added.length === me.store.count);
      return;
    }
    me.resourceFilter.disabled = disabled;
    me.applyFilter();
    if (me.eventListeners.change) {
      const value = selected.values, oldValue = value.concat(removed);
      ArrayHelper.remove(oldValue, added);
      me.triggerFieldChange({
        value,
        oldValue
      });
    }
  }
  get value() {
    return this.selected.values;
  }
  applyFilter() {
    this.eventStore.filter();
  }
};
ResourceFilter.initClass();
ResourceFilter._$name = "ResourceFilter";
var SchedulerDatePicker = class extends DatePicker {
  static get $name() {
    return "SchedulerDatePicker";
  }
  static get type() {
    return "datepicker";
  }
  static get configurable() {
    return {
      showEvents: null,
      eventStore: null
    };
  }
  construct(config) {
    if ("events" in config) {
      config = _objectSpread2(_objectSpread2({}, config), {}, {
        showEvents: config.events
      });
      delete config.events;
      VersionHelper.deprecate(VersionHelper["calendar"] ? "Calendar" : "Scheduler", "6.0.0", "DatePicker#events should be configured as showEvents");
    }
    super.construct(config);
  }
  doRefresh() {
    this.refreshEventsMap();
    return super.doRefresh(...arguments);
  }
  updateShowEvents(showEvents, oldShowEvents) {
    const me = this, {
      classList
    } = me.contentElement;
    let {
      eventStore
    } = me;
    me.requestAnimationFrame(() => {
      var _me$owner;
      me.element.classList.toggle("b-datepicker-with-events", Boolean(showEvents));
      (_me$owner = me.owner) === null || _me$owner === void 0 ? void 0 : _me$owner.element.classList.toggle("b-datepicker-with-events", Boolean(showEvents));
      showEvents && classList.add(`b-show-events-${showEvents}`);
      classList.remove(`b-show-events-${oldShowEvents}`);
    });
    if (showEvents) {
      if (!eventStore) {
        const eventStoreOwner = me.up((w) => w.eventStore);
        if (eventStoreOwner) {
          eventStore = eventStoreOwner.eventStore;
        } else {
          throw new Error("DatePicker configured with events but no eventStore");
        }
      }
    } else {
      me.eventsMap = null;
    }
    if (!me.isConfiguring) {
      me.updateEventStore(eventStore);
      me.doRefresh();
    }
  }
  refreshEventsMap() {
    const me = this;
    if (me.showEvents) {
      me.eventsMap = me.eventStore.getEventCounts({
        startDate: me.startDate,
        endDate: me.endDate,
        dateMap: me.eventsMap
      });
    }
  }
  updateEventStore(eventStore) {
    if (eventStore.findListener("change", "refresh", this) === -1) {
      var _eventStore;
      eventStore === null || eventStore === void 0 ? void 0 : (_eventStore = eventStore[this.showEvents ? "on" : "un"]) === null || _eventStore === void 0 ? void 0 : _eventStore.call(eventStore, {
        change: "refresh",
        thisObj: this
      });
    }
  }
  cellRenderer({
    cell,
    date: date2
  }) {
    var _this$eventCounts, _this$eventCounts$get;
    const {
      showEvents
    } = this, count = (_this$eventCounts = this.eventCounts) === null || _this$eventCounts === void 0 ? void 0 : (_this$eventCounts$get = _this$eventCounts.get) === null || _this$eventCounts$get === void 0 ? void 0 : _this$eventCounts$get.call(_this$eventCounts, DateHelper.makeKey(date2)), isCount = showEvents === "count";
    delete cell.dataset.btip;
    if (count) {
      if (!isCount && this.eventCountTip) {
        cell.dataset.btip = this.L("L{ResourceInfoColumn.eventCountText}", count);
      }
      DomHelper.createElement({
        dataset: {
          count
        },
        class: {
          [isCount ? "b-cell-events-badge" : "b-icon b-icon-circle"]: 1,
          [SchedulerDatePicker.getEventCountClass(count)]: 1
        },
        parent: cell,
        [isCount ? "text" : ""]: count
      });
    }
  }
  static getEventCountClass(count) {
    if (count) {
      if (count < 4) {
        return "b-datepicker-1-to-3-events";
      }
      if (count < 7) {
        return "b-datepicker-4-to-6-events";
      }
      return "b-calendar-7-or-more-events";
    }
    return "";
  }
  static setupClass(meta) {
    meta.replaceType = true;
    super.setupClass(meta);
  }
};
SchedulerDatePicker.initClass();
SchedulerDatePicker._$name = "SchedulerDatePicker";
var isProjectConsumer = (w) => w.isProjectConsumer;
var UndoRedo = class extends UndoRedoBase {
  static get $name() {
    return "UndoRedo";
  }
  static get type() {
    return "undoredo";
  }
  static get configurable() {
    return {
      scheduler: null,
      project: null
    };
  }
  construct() {
    super.construct(...arguments);
    if (!this.stm) {
      this.scheduler = this.up(isProjectConsumer);
    }
  }
  changeScheduler(scheduler) {
    return scheduler.isProjectConsumer ? scheduler : UndoRedo.getById(scheduler);
  }
  updateScheduler(scheduler) {
    const {
      crudManager
    } = scheduler;
    scheduler.ion({
      projectChange: "onProjectChanged",
      thisObj: this
    });
    if (crudManager) {
      this.setupLoadListener(crudManager);
    } else {
      this.onLoad();
    }
    this.stm = scheduler.project.stm;
  }
  setupLoadListener(source) {
    source.detachListeners("load");
    source.ion({
      name: "load",
      load: "onLoad",
      thisObj: this
    });
  }
  async onLoad() {
    await this.scheduler.project.commitAsync();
    if (!this.isDestroyed) {
      this.stm.enable();
      this.fillUndoRedoCombo();
    }
  }
  onProjectChanged({
    project
  }) {
    this.project = project;
  }
  updateProject(project) {
    var _this$scheduler;
    super.updateProject(...arguments);
    if (project && !((_this$scheduler = this.scheduler) !== null && _this$scheduler !== void 0 && _this$scheduler.isConfiguring)) {
      this.setupLoadListener(project);
    }
  }
};
UndoRedo.initClass();
UndoRedo._$name = "UndoRedo";
var ViewPresetCombo = class extends Combo {
  construct() {
    super.construct(...arguments);
    this.scheduler.ion({
      presetchange: this.onClientPresetChange,
      thisObj: this
    });
  }
  get scheduler() {
    return this.client || this.up((widget) => widget.isTimelineBase) || Widget.query((widget) => widget.isTimelineBase);
  }
  changeValue(value, oldValue) {
    this.getConfig("presets");
    return super.changeValue(value, oldValue);
  }
  updatePresets(presets) {
    this.store = this.scheduler.presets.chain((r) => presets.includes(r.id));
    this.store.sort((a, b) => presets.indexOf(a.id) - presets.indexOf(b.id));
  }
  onClientPresetChange({
    preset
  }) {
    const me = this;
    if (!me._isSelecting) {
      me.isSettingValue = true;
      if (me.store.includes(preset.id)) {
        me.value = preset;
      } else {
        me.clear();
      }
      me.isSettingValue = false;
    }
  }
  onSelect({
    record
  }) {
    if (!this.isSettingValue) {
      const {
        scheduler
      } = this, {
        mainUnit,
        start,
        defaultSpan
      } = record;
      scheduler.suspendRefresh();
      this._isSelecting = true;
      scheduler.viewPreset = record;
      this._isSelecting = false;
      if (mainUnit && defaultSpan) {
        let beginningOf = mainUnit;
        if (start && typeof start === "string") {
          var _DateHelper$parseTime;
          beginningOf = (_DateHelper$parseTime = DateHelper.parseTimeUnit(start)) !== null && _DateHelper$parseTime !== void 0 ? _DateHelper$parseTime : start;
        }
        let startDate = DateHelper.startOf(scheduler.startDate, beginningOf);
        if (record.start && typeof start === "number") {
          startDate = DateHelper.add(startDate, start, mainUnit);
        }
        const endDate = DateHelper.add(startDate, defaultSpan, mainUnit);
        scheduler.setTimeSpan(startDate, endDate);
      }
      scheduler.scrollLeft = 0;
      scheduler.resumeRefresh(true);
    }
  }
  updateLocalization() {
    super.updateLocalization();
    this.syncInputFieldValue();
  }
};
_defineProperty(ViewPresetCombo, "$name", "ViewPresetCombo");
_defineProperty(ViewPresetCombo, "type", "viewpresetcombo");
_defineProperty(ViewPresetCombo, "configurable", {
  presets: ["hourAndDay", "weekAndDay", "dayAndMonth"],
  client: null,
  editable: false,
  valueField: "id",
  displayField: "name",
  placeholder: "Select view"
});
ViewPresetCombo.initClass();
ViewPresetCombo._$name = "ViewPresetCombo";
var AgendaColumn = class extends Column {
  static get type() {
    return "agendacolumn";
  }
  static get defaults() {
    return {
      "id": "agenda",
      text: "Agenda",
      filterable: false,
      sortable: false,
      editor: false,
      searchable: false,
      autoHeight: false,
      alwaysClearCell: false
    };
  }
  construct() {
    super.construct(...arguments);
    this.grid.ion({
      beforeResponsiveStateChange: "onBeforeGridResponsiveStateChange",
      thisObj: this
    });
  }
  defaultRenderer({
    cellElement: targetElement,
    record,
    grid,
    size
  }) {
    var _grid$_cellRenderer;
    const me = this, {
      events,
      date: date2
    } = record, children = [];
    for (let i = 0; i < events.length; i++) {
      const eventRecord = events[i], eventEndDate = eventRecord.endDate || DateHelper.add(eventRecord.startDate, eventRecord.duration, eventRecord.durationUnit), isOverflow = eventRecord.startDate < date2, overflows = eventEndDate > record.tomorrow, eventDomConfig = grid.createEventDomConfig({
        date: record.date,
        isAllDay: eventRecord.allDay || overflows || isOverflow,
        eventRecord
      });
      eventDomConfig.className["b-continues-future"] = overflows;
      eventDomConfig.className["b-continues-past"] = isOverflow;
      children.push({
        className: {
          "b-cal-agenda-event-row": 1
        },
        dataset: {
          rowId: eventRecord.id
        },
        children: [grid.eventListEventTimeRenderer(eventRecord, date2), eventDomConfig],
        syncOptions: {
          syncIdField: "rowId",
          releaseThreshold: 0,
          strict: true
        }
      });
    }
    (_grid$_cellRenderer = grid._cellRenderer) === null || _grid$_cellRenderer === void 0 ? void 0 : _grid$_cellRenderer.call(grid, ...arguments);
    targetElement.classList[record.isNonWorking ? "add" : "remove"](grid.nonWorkingDayCls);
    DomSync.sync({
      domConfig: {
        onlyChildren: true,
        children: [grid.agendaEventDateRenderer(date2), {
          className: {
            "b-cal-event-bar-container": 1
          },
          children
        }],
        syncOptions: {
          syncIdField: "date",
          releaseThreshold: 0,
          strict: true
        }
      },
      targetElement
    });
    targetElement.dataset.date = record.id;
    if (!me.autoHeight) {
      const dateBlock = targetElement.querySelector(".b-cal-agenda-date"), cellTbPadding = me._cellTbPadding != null ? me._cellTbPadding : me._cellTbPadding = DomHelper.getEdgeSize(targetElement, "padding", "tb").height, containerPadding = me._containerPadding != null ? me._containerPadding : me._containerPadding = DomHelper.getEdgeSize(targetElement.querySelector(".b-cal-event-bar-container"), "margin", "tb").height, dateBlockHeight = me._dateBlockHeight != null ? me._dateBlockHeight : me._dateBlockHeight = Rectangle.outer(dateBlock).height;
      size.height = Math.max(record.events.length * (grid.eventHeightInPixels + grid.eventRowSpacing) - grid.eventRowSpacing + cellTbPadding + containerPadding + (grid.responsiveState === "small" ? dateBlockHeight : 0), 86);
    }
  }
  onBeforeGridResponsiveStateChange() {
    this._cellTbPadding = this._containerPadding = this._dateBlockHeight = this._dateBlockHeight = null;
  }
  getCellClass(cellContext) {
    const result = super.getCellClass(cellContext);
    result["b-sticky-cell"] = result[`b-day-of-week-${cellContext.record.day}`] = 1;
    return result;
  }
  headerRenderer({
    headerElement: targetElement
  }) {
    targetElement.innerHTML = "";
    DomSync.sync({
      domConfig: {
        className: {
          "b-cal-agenda-header": 1,
          "b-grid-header": 1,
          "b-last-leaf": 1
        },
        children: [{
          className: {
            "b-cal-agenda-header-date": 1
          },
          text: "Date"
        }, {
          className: {
            "b-cal-agenda-header-time": 1
          },
          text: "Time"
        }, {
          className: {
            "b-cal-agenda-header-event": 1
          },
          text: "Event"
        }]
      },
      targetElement
    });
  }
};
_defineProperty(AgendaColumn, "$name", "AgendaColumn");
ColumnStore.registerColumnType(AgendaColumn);
AgendaColumn._$name = "AgendaColumn";
var EventColumn = class extends Column {
  static get type() {
    return "calendarevents";
  }
  static get defaults() {
    return {
      "id": "calendarevents",
      text: "Event Details",
      filterable: false,
      sortable: false,
      editor: false,
      searchable: false,
      autoHeight: true,
      alwaysClearCell: false
    };
  }
  renderer({
    cellElement: targetElement,
    record,
    grid
  }) {
    var _grid$calendar, _grid$_cellRenderer;
    const resourceFilter = (_grid$calendar = grid.calendar) === null || _grid$calendar === void 0 ? void 0 : _grid$calendar.widgetMap.resourceFilter, resources = resourceFilter ? record.resources.filter((r) => resourceFilter.selected.includes(r)) : record.resources;
    (_grid$_cellRenderer = grid._cellRenderer) === null || _grid$_cellRenderer === void 0 ? void 0 : _grid$_cellRenderer.call(grid, ...arguments);
    grid.showResourceAvatars = true;
    DomSync.sync({
      domConfig: {
        onlyChildren: true,
        children: [{
          class: "b-cal-event-resource-avatars",
          children: resources.map((resource) => {
            return {
              class: "b-cal-event-resource-avatar-row",
              children: [grid.getResourceAvatar(resource), {
                class: "b-cal-event-resource-avatar-desc",
                children: [{
                  class: "b-event-column-resource-name",
                  text: resource.name
                }, {
                  class: "b-event-column-resource-role",
                  text: resource.role
                }]
              }]
            };
          })
        }, {
          class: "b-cal-event-column-event-desc",
          children: [{
            class: "b-cal-event-column-event-name",
            text: record.name
          }]
        }, {
          class: "b-cal-event-column-times",
          children: [grid.eventListEventTimeRenderer(record)]
        }],
        syncOptions: {
          syncIdField: "date",
          releaseThreshold: 0,
          strict: true
        }
      },
      targetElement
    });
  }
};
ColumnStore.registerColumnType(EventColumn);
EventColumn.exposeProperties();
EventColumn._$name = "EventColumn";
var TimeRangeModel = class extends TimeSpan {
  afterConstruct() {
    if (!this.endDate) {
      this.endDate = this.startDate;
    }
  }
};
_defineProperty(TimeRangeModel, "fields", [
  {
    name: "alignment",
    defaultValue: "start",
    internal: true
  },
  {
    name: "color",
    internal: true
  },
  {
    name: "footer",
    internal: true
  },
  {
    name: "rotation",
    internal: true
  }
]);
TimeRangeModel._$name = "TimeRangeModel";
var TimeRangeStore = class extends Store {
};
_defineProperty(TimeRangeStore, "$name", "TimeRangeStore");
_defineProperty(TimeRangeStore, "defaultConfig", {
  modelClass: TimeRangeModel
});
TimeRangeStore.initClass();
TimeRangeStore._$name = "TimeRangeStore";
var ProjectModel = class extends ProjectModel$1 {
};
_defineProperty(ProjectModel, "$name", "ProjectModel");
_defineProperty(ProjectModel, "configurable", {
  timeRangeStore: {
    modelClass: TimeRangeModel
  }
});
_defineProperty(ProjectModel, "defaultConfig", {
  timeRangeModelClass: TimeRangeModel,
  timeRangeStoreClass: TimeRangeStore
});
ProjectModel.applyConfigs = true;
ProjectModel.initClass();
ProjectModel._$name = "ProjectModel";
var CrudManager = class extends CrudManager$1 {
  buildProjectConfig() {
    const ret = super.buildProjectConfig(), {
      timeRangeStore
    } = this;
    if (timeRangeStore) {
      ret.timeRangeStore = timeRangeStore;
    }
    return ret;
  }
  get timeRangeStore() {
    return super.timeRangeStore;
  }
  set timeRangeStore(store) {
    var _this$project;
    if (store && ObjectHelper.isObject(store)) {
      store = ObjectHelper.assign({
        modelClass: this.timeRangeClass
      }, store);
    }
    this.setFeaturedStore("_timeRangeStore", store, (_this$project = this.project) === null || _this$project === void 0 ? void 0 : _this$project.timeRangeStoreClass);
  }
};
_defineProperty(CrudManager, "$name", "CrudManager");
_defineProperty(CrudManager, "configurable", {
  projectClass: ProjectModel,
  timeRangeClass: TimeRangeModel
});
CrudManager.initClass();
CrudManager._$name = "CrudManager";
var CalendarFeature = class extends InstancePlugin.mixin(Factoryable) {
  static get factoryable() {
    return {};
  }
  static get configurable() {
    return {
      clientListeners: {
        paint: "onCalendarPaint"
      },
      disableOnReadOnly: null,
      zoneTypes: null
    };
  }
  getViewZoneType(view) {
    const {
      zoneTypes
    } = this;
    let ret;
    if (zoneTypes && (ret = zoneTypes[view.type]) === void 0) {
      if (view.isWeekView && zoneTypes.week !== void 0) {
        ret = zoneTypes.week;
      } else if (view.isDayView) {
        ret = zoneTypes.day;
      } else if (view.isMonthView) {
        ret = zoneTypes.month;
      } else if (view.isYearView) {
        ret = zoneTypes.year;
      } else if (view.isResourceView) {
        ret = zoneTypes.resource;
      } else if (view.isAgendaView) {
        ret = zoneTypes.agenda;
      }
    }
    return ret;
  }
  updateDisableOnReadOnly(disable) {
    const me = this, {
      client
    } = me, name = "readonlyToggle", handler = "onClientReadOnlyToggle";
    if (disable) {
      me[handler]({
        readOnly: client.readOnly
      });
      client.ion({
        name,
        readOnly: handler,
        thisObj: me
      });
    } else {
      me.detachListeners(name);
    }
  }
  doDestroy() {
    this.syncModes();
    super.doDestroy();
  }
  createZone(type, config) {
    return new type(_objectSpread2({
      owner: this
    }, config));
  }
  onClientReadOnlyToggle({
    readOnly
  }) {
    this.disabled = readOnly;
  }
  updateDisabled(disabled, was) {
    super.updateDisabled(disabled, was);
    if (this.client.isPainted) {
      this.syncModes();
    }
  }
  onCalendarPaint({
    firstPaint
  }) {
    if (firstPaint) {
      this.syncModes();
    }
  }
  syncModes() {
    const me = this, {
      client,
      _modeDetacher,
      zones
    } = me;
    let newZones = null, modes, name, view, type, zone;
    if (me.disabled || me.isDestroying || !me.zoneTypes) {
      _modeDetacher === null || _modeDetacher === void 0 ? void 0 : _modeDetacher();
    } else {
      if (client.isCalendar) {
        if (!_modeDetacher) {
          me._modeDetacher = client.ion({
            addMode: () => me.syncModes()
          });
        }
        modes = client.modes;
      } else {
        modes = {
          view: client
        };
      }
      for (name in modes) {
        zone = zones === null || zones === void 0 ? void 0 : zones[name];
        view = modes[name];
        type = me.getViewZoneType(view);
        if (type) {
          var _zone;
          if ((ObjectHelper.isObject(zone) ? zone.type : (_zone = zone) === null || _zone === void 0 ? void 0 : _zone.constructor) === type) {
            delete zones[name];
          } else if (view.isPainted) {
            zone = me.createZone(type, {
              view
            });
          } else {
            zone = me.whenPainted(name, view, type);
          }
          (newZones || (newZones = {}))[name] = zone;
        }
      }
    }
    me.zones = newZones;
    if (zones) {
      for (name in zones) {
        zones[name].destroy();
      }
    }
  }
  whenPainted(name, view, type) {
    const me = this, proxy = {
      type,
      destroy: view.ion({
        once: true,
        prio: 1e4,
        paint() {
          if (me.zones[name] === proxy) {
            me.zones[name] = me.createZone(type, {
              view
            });
          }
        }
      })
    };
    return proxy;
  }
};
CalendarFeature._$name = "CalendarFeature";
var CalendarZone = class extends Base$1 {
  updateView(view) {
    const me = this, listeners = view && me.viewListeners;
    me.detachListeners("viewListeners");
    listeners && (view === null || view === void 0 ? void 0 : view.ion(ObjectHelper.merge({
      thisObj: me,
      name: "viewListeners"
    }, listeners)));
  }
};
_defineProperty(CalendarZone, "$name", "CalendarZone");
_defineProperty(CalendarZone, "configurable", {
  owner: null,
  view: {
    $config: "nullify",
    value: null
  },
  viewListeners: null
});
CalendarZone.initClass();
CalendarZone._$name = "CalendarZone";
var hasEventStore$3 = (w) => w.eventStore;
var EventTip = class extends Tooltip {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "clockTemplate", new ClockTemplate({}));
  }
  static get $name() {
    return "EventTip";
  }
  static get type() {
    return "eventtip";
  }
  static get configurable() {
    return {
      align: {
        monitorResize: true
      },
      dateFormat: "ll",
      eventRecord: {
        $config: "nullify",
        value: null
      },
      recurrenceHint: "",
      timeFormat: "LST",
      axisLock: "flexible",
      closable: null,
      forSelector: ".b-cal-event-wrap",
      maxWidth: "30em",
      minWidth: "14em",
      scrollAction: "realign",
      cls: {
        "b-sch-event-tooltip": 1
      },
      tools: {
        edit: {
          cls: "b-icon-edit",
          handler: "up.onEditClick",
          tooltip: "L{EventEdit.Edit event}",
          weight: 100
        },
        delete: {
          cls: "b-icon-trash",
          handler: "up.onDeleteClick",
          tooltip: "L{SchedulerBase.Delete event}",
          weight: 0
        },
        maximize: null
      },
      titleRenderer: (eventRecord) => StringHelper.encodeHtml(eventRecord.name),
      extendAllDayEndDay: null,
      activeClient: null
    };
  }
  static get delayable() {
    return {
      refreshContent: 20
    };
  }
  get owner() {
    return Tooltip.fromElement(this.activeTarget) || this.ownerFeature.client;
  }
  onEditClick() {
    this.trigger("edit");
  }
  onDeleteClick() {
    this.trigger("delete");
  }
  getHtml(data) {
    const me = this, {
      eventRecord
    } = me;
    if (eventRecord) {
      data.eventRecord = eventRecord;
      me.title = me.titleRenderer ? me.callback(me.titleRenderer, me, [eventRecord]) : "";
      return me.callback(me.renderer || me.internalRenderer, me, [_objectSpread2(_objectSpread2({}, data), {}, {
        eventRecord
      })]);
    }
  }
  internalRenderer({
    eventRecord
  }) {
    const {
      clockTemplate,
      dateFormat,
      recurrenceHint,
      timeFormat
    } = this, {
      allDay,
      endDate,
      startDate,
      recurrence
    } = eventRecord, lastDay = allDay ? this.extendAllDayEndDay ? DateHelper.ceil(endDate, "1 day") : DateHelper.add(endDate, -1, "day") : endDate, startMidnight = DateHelper.clearTime(startDate), lastMidnight = DateHelper.clearTime(lastDay), multiDay = startMidnight < lastMidnight, hasTime = !allDay && startMidnight < startDate || lastMidnight < lastDay, format2 = hasTime ? multiDay ? `${dateFormat} ${timeFormat}` : timeFormat : dateFormat, recurrenceLegend = recurrence ? RecurrenceLegend.getLegend(recurrence) : recurrenceHint, duration = DateHelper.formatDelta(DateHelper.diff(startDate, endDate), allDay ? {
      precision: "d"
    } : null), onlyStartDate = eventRecord.isMilestone || allDay && !multiDay;
    clockTemplate.mode = multiDay ? "day" : "hour";
    return clockTemplate.template({
      date: startDate,
      text: DateHelper.format(startDate, format2),
      cls: "b-sch-tooltip-startdate"
    }) + (onlyStartDate ? "" : clockTemplate.template({
      date: lastDay,
      text: DateHelper.format(lastDay, format2),
      cls: "b-sch-tooltip-enddate"
    })) + (eventRecord.isMilestone ? "" : `<div class="b-cal-tooltip-duration b-icon b-icon-duration">${duration}</div>`) + (recurrenceLegend ? `<div class="b-cal-tooltip-recurrence b-icon b-icon-recurring">${recurrenceLegend}</div>` : "");
  }
  showByEvent(event, element = event.target) {
    const me = this;
    me.activeTarget = element;
    me.pointerEvent = event;
    me.updateContent();
    if (event.type === "contextmenu") {
      return me.showBy({
        position: {
          x: event.clientX,
          y: event.clientY
        },
        anchor: false
      });
    }
    return me.showBy(element);
  }
  afterShowByTarget() {
    var _Tooltip$fromElement;
    const {
      delete: deleteTool
    } = this.tools;
    this.activeClient = (_Tooltip$fromElement = Tooltip.fromElement(this.activeTarget)) === null || _Tooltip$fromElement === void 0 ? void 0 : _Tooltip$fromElement.closest(hasEventStore$3);
    super.afterShowByTarget();
    deleteTool && (deleteTool.disabled = this.ownerFeature.client.readOnly);
  }
  afterHide() {
    super.afterHide(...arguments);
    this.activeClient = null;
  }
  updateActiveTarget(element, was) {
    super.updateActiveTarget(...arguments);
    was === null || was === void 0 ? void 0 : was.classList.remove("b-cal-event-reveal");
    if (element !== null && element !== void 0 && element.classList.contains("b-cal-in-cluster")) {
      element.classList.add("b-cal-event-reveal");
    }
  }
  refreshContent() {
    this.updateContent();
  }
  updateEventRecord(eventRecord) {
    var _me$_changeHook;
    const me = this;
    (_me$_changeHook = me._changeHook) === null || _me$_changeHook === void 0 ? void 0 : _me$_changeHook.call(me);
    me._changeHook = eventRecord && FunctionHelper.after(eventRecord, "afterChange", me.refreshContent, me);
    if (eventRecord) {
      if (me.tools.delete) {
        me.tools.delete.hidden = eventRecord.readOnly;
      }
      if (me.tools.edit) {
        me.tools.edit.hidden = eventRecord.readOnly;
      }
      me.updateContent();
    }
  }
  updateContent() {
    const {
      clockTemplate,
      element,
      eventRecord
    } = this, result = super.updateContent(), startElement = element.querySelector(".b-sch-tooltip-startdate"), endElement = element.querySelector(".b-sch-tooltip-enddate"), {
      edit,
      delete: del
    } = this.tools, {
      client
    } = this.ownerFeature, {
      eventEdit
    } = client.features, readOnly = client.readOnly || eventRecord.readOnly;
    startElement && clockTemplate.updateDateIndicator(startElement, eventRecord.startDate);
    endElement && clockTemplate.updateDateIndicator(endElement, eventRecord.endDate);
    edit && (edit.hidden = readOnly || !(eventEdit !== null && eventEdit !== void 0 && eventEdit.enabled));
    del && (del.hidden = readOnly);
    return result;
  }
  updateActiveClient(activeClient) {
    this.detachListeners("clientOverflowChange");
    if (activeClient) {
      activeClient.ion({
        name: "clientOverflowChange",
        eventsPerCellChange: "onClientOverflowChange",
        thisObj: this
      });
    }
  }
  onClientOverflowChange() {
    if (!DomHelper.isVisible(this.lastAlignSpec.target)) {
      this.hide();
    }
  }
  onDocumentMouseDown({
    event
  }) {
    if (!event.button && this.ownerFeature.showOn === "click" && this.activeTarget.contains(event.target)) {
      return;
    }
    return super.onDocumentMouseDown(...arguments);
  }
};
EventTip.initClass();
EventTip._$name = "EventTip";
var tentativeCls = "b-cal-tentative-event";
var SECONDS = 1e3;
var MINUTES = 60 * SECONDS;
var YYYY_MM_DD = "YYYY-MM-DD";
var edgeRe = /^b-hover-(top|right|bottom|left)$/;
var eventDragSym = Symbol("eventDragMode");
var appendEventFooter = (domConfig, footer) => {
  let ret;
  if (domConfig.className === "b-cal-event-body") {
    domConfig.children.push(ret = footer);
  } else if (Array.isArray(domConfig.children)) {
    domConfig.children.forEach((c) => {
      if (!ret && c) {
        ret = appendEventFooter(c, footer);
      }
    });
  }
  return ret;
};
var makeMode = (type) => Object.freeze({
  type,
  create: false,
  move: false,
  resize: false,
  [type]: true
});
var modeDescriptor = {
  create: {
    finisher: "finishDropCreate",
    mode: makeMode("create"),
    validatorFn: "validateCreateFn"
  },
  move: {
    finisher: "finishDropMove",
    mode: makeMode("move"),
    validatorFn: "validateMoveFn"
  },
  resize: {
    finisher: "finishDropResize",
    mode: makeMode("resize"),
    validatorFn: "validateResizeFn"
  }
};
var isAllDayView = {
  calendarrow: true,
  monthview: true
};
var Zone = class extends CalendarZone.mixin(Draggable, Droppable, Hoverable) {
  static get $name() {
    return "Zone";
  }
  static get configurable() {
    return {
      droppableSelector: "*",
      droppable: true,
      hoverable: null,
      hoverAnimationCls: "b-hover-anim",
      days: {
        $config: {
          equal: "array"
        },
        value: null
      },
      dragProxy: {
        type: "tip",
        tooltip: null
      },
      eventRecord: null,
      hit: null,
      dragItemSelector: ".b-cal-event-wrap",
      overflow: {
        $config: "nullify",
        value: null
      },
      rootElement: null
    };
  }
  get dayTime() {
    var _this$view;
    return (_this$view = this.view) === null || _this$view === void 0 ? void 0 : _this$view.dayTime;
  }
  clearTime(date2) {
    return this.dayTime.startOfDay(date2);
  }
  findRootElement(view) {
    return view.contentElement;
  }
  getDateFromPosition(clientX, clientY) {
    return this.view.getDateFromPosition(clientX, clientY);
  }
  get dragEventer() {
    return this.owner;
  }
  beforeDrag(drag) {
    const me = this, {
      owner
    } = me, hit = me.hitTest(drag), eventRecord = hit === null || hit === void 0 ? void 0 : hit.eventRecord, insetProp = me.view.rtl ? "right" : "left";
    if (!hit || eventRecord !== null && eventRecord !== void 0 && eventRecord.readOnly || eventRecord !== null && eventRecord !== void 0 && eventRecord.isCreating) {
      return false;
    }
    if (hit.date) {
      drag.set("date", hit.date);
    }
    let mode, veto;
    switch (hit.type) {
      case "event":
        drag.set("eventRecord", eventRecord);
        drag.set("eventSourceHit", hit);
        drag.set("eventInset", hit.eventElement.style[insetProp]);
        drag.set("eventWidth", hit.eventElement.offsetWidth);
        mode = "move";
        veto = !owner.draggable || !eventRecord.isDraggable;
        if (!veto) {
          me.captureDragOffset(eventRecord, hit, drag);
        }
        break;
      case "resize":
        drag.set("eventRecord", eventRecord);
        drag.set("eventSourceHit", hit);
        drag.set("eventInset", hit.eventWrap.style[insetProp]);
        drag.set("eventWidth", hit.eventWrap.offsetWidth);
        mode = "resize";
        veto = !owner.resizable || !eventRecord.resizable;
        break;
      case "schedule":
      case "dayNumber":
        drag.set("eventCreate", hit);
        mode = "create";
        veto = !owner.creatable;
        break;
      default:
        return false;
    }
    if (veto) {
      return false;
    }
    drag.set("eventDragMode", drag[eventDragSym] = modeDescriptor[mode].mode);
  }
  dragStart() {
    var _client$scrollManager;
    const me = this, {
      dragging: drag,
      owner,
      view
    } = me, {
      client
    } = owner, callback = () => {
      drag.lastMoveEvent && drag.move(drag.lastMoveEvent);
    }, config = {
      scrollables: client.scrollManager ? [{
        element: client.viewContainer.element,
        callback
      }] : []
    };
    if (me.isResizing || me.isMoving) {
      me.refocus = owner.client.captureFocus();
    }
    if (me.isResizing) {
      var _drag$itemElement;
      (_drag$itemElement = drag.itemElement) === null || _drag$itemElement === void 0 ? void 0 : _drag$itemElement.classList.add("b-resizing");
    }
    if (view.scrollable) {
      config.scrollables.push({
        element: view.scrollable.element,
        callback
      });
    }
    if (view.horizontalScroller) {
      config.scrollables.push({
        element: view.horizontalScroller.element,
        callback
      });
    }
    (_client$scrollManager = client.scrollManager) === null || _client$scrollManager === void 0 ? void 0 : _client$scrollManager.startMonitoring(config);
  }
  captureDragOffset() {
  }
  cleanupDrag() {
    var _dragging$itemElement;
    const me = this, {
      dragProxy,
      dragging
    } = me, {
      tooltip
    } = dragProxy, view = me.view.isOverflowPopup ? me.view.owner : me.view;
    dragging === null || dragging === void 0 ? void 0 : (_dragging$itemElement = dragging.itemElement) === null || _dragging$itemElement === void 0 ? void 0 : _dragging$itemElement.classList.remove("b-resizing");
    view.ion({
      refresh() {
        var _me$refocus;
        (_me$refocus = me.refocus) === null || _me$refocus === void 0 ? void 0 : _me$refocus.call(me, false, true);
        me.refocus = null;
      },
      once: true
    });
    me.days = null;
    if (tooltip) {
      tooltip.hide();
      dragProxy.tooltip = null;
    }
  }
  dragEnd() {
    var _this$owner$client, _this$owner$client$sc;
    (_this$owner$client = this.owner.client) === null || _this$owner$client === void 0 ? void 0 : (_this$owner$client$sc = _this$owner$client.scrollManager) === null || _this$owner$client$sc === void 0 ? void 0 : _this$owner$client$sc.stopMonitoring();
    this.cleanupDrag();
  }
  makeDays(startDate, endDate) {
    const {
      dayTime,
      startDate: minDate,
      endDate: maxDate
    } = this.view, days2 = [];
    startDate = DateHelper.constrain(startDate, minDate, maxDate);
    endDate = DateHelper.constrain(endDate, minDate, maxDate);
    let date2 = dayTime.startOfDay(startDate);
    for (const end = dayTime.ceil(endDate); date2 < end; date2 = DateHelper.add(date2, 1, "day")) {
      days2.push(dayTime.dateKey(date2));
    }
    return days2;
  }
  onShowOverflowPopup({
    overflowPopup
  }) {
    if (!this.overflow) {
      this.overflow = new OverflowZone({
        owner: this.owner,
        view: overflowPopup
      });
    }
  }
  get calendarCellSelector() {
    const {
      hideNonWorkingDays
    } = this.view;
    return `${this.view.visibleCellSelector}${hideNonWorkingDays ? ":not(.b-nonworking-day)" : ""}`;
  }
  get calendarCells() {
    const container = this.dropRootElement;
    return container && DomHelper.children(container, this.calendarCellSelector);
  }
  get isCreating() {
    var _this$dropping, _this$dropping$eventD;
    return (_this$dropping = this.dropping) === null || _this$dropping === void 0 ? void 0 : (_this$dropping$eventD = _this$dropping[eventDragSym]) === null || _this$dropping$eventD === void 0 ? void 0 : _this$dropping$eventD.create;
  }
  get isMoving() {
    var _this$dropping2, _this$dragging, _this$dropping3;
    const mode = ((_this$dropping2 = this.dropping) === null || _this$dropping2 === void 0 ? void 0 : _this$dropping2[eventDragSym]) || ((_this$dragging = this.dragging) === null || _this$dragging === void 0 ? void 0 : _this$dragging[eventDragSym]);
    return mode ? mode.move : Boolean((_this$dropping3 = this.dropping) === null || _this$dropping3 === void 0 ? void 0 : _this$dropping3.peek("eventRecord"));
  }
  get isResizing() {
    var _this$dragging2, _this$dragging2$event;
    return (_this$dragging2 = this.dragging) === null || _this$dragging2 === void 0 ? void 0 : (_this$dragging2$event = _this$dragging2[eventDragSym]) === null || _this$dragging2$event === void 0 ? void 0 : _this$dragging2$event.resize;
  }
  get recurrable() {
    return this.isDayZone || this.isMonthZone;
  }
  cleanupDrop() {
    this.eventRecord = this.eventDom = this.days = null;
    this.noTip = false;
  }
  createEvent(data) {
    var _this$dropping4;
    const mode = ((_this$dropping4 = this.dropping) === null || _this$dropping4 === void 0 ? void 0 : _this$dropping4[eventDragSym]) || modeDescriptor.create;
    this.setupEvent(data, mode.create);
  }
  async dragDrop(drag) {
    if (this.isResizing || drag.target === this) {
      return drag.finalizer = this.finishDrop(drag);
    }
  }
  dragEnter(drag) {
    const me = this, mode = drag[eventDragSym];
    if (me.isMoving) {
      me.startMove(drag.peek("eventRecord"));
    } else if (!mode || drag.source !== me) {
      return false;
    } else if (mode.resize) {
      me.startResize(drag.peek("eventSourceHit"));
    } else if (mode.create) {
      me.startCreate(drag.peek("date"), drag.peek("eventCreate"));
    } else {
      return false;
    }
  }
  dragLeave() {
    if (!this.isResizing) {
      this.cleanupDrop();
    }
  }
  dragMove(drag) {
    this.hit = this.pickDropTarget(drag);
  }
  dropHitMove(drag, hit, eventRecord) {
    const me = this, {
      endDate,
      startDate
    } = eventRecord.isScheduled ? eventRecord : me.eventRecord, durationSec = DateHelper.diff(startDate, endDate, "s");
    let {
      date: date2
    } = hit;
    date2 = me.clearTime(date2);
    if (!eventRecord.allDay) {
      date2 = DateHelper.add(date2, DateHelper.diff(me.clearTime(startDate), startDate, "s"), "s");
    }
    date2 = me.applyDragOffset(date2, drag);
    me.setEventData({
      startDate: date2,
      endDate: DateHelper.add(date2, durationSec, "s")
    });
  }
  dropHitNowhere() {
    this.days = null;
  }
  dropHitResize(drag, hit, eventHit) {
    const me = this, {
      eventRecord
    } = me, {
      startDate,
      endDate
    } = eventRecord, date2 = me.clearTime(hit.date);
    let changes, end;
    if (eventHit.atEnd) {
      end = DateHelper.add(date2, 1, "d");
      changes = {
        startDate,
        endDate: startDate < end ? end : DateHelper.add(startDate, 1, "d")
      };
    } else {
      changes = {
        startDate: date2 < endDate ? date2 : DateHelper.add(endDate, -1, "d"),
        endDate
      };
    }
    changes.duration = DateHelper.diff(changes.startDate, changes.endDate, eventRecord.durationUnit);
    me.setEventData(changes);
  }
  async finishDrop(drag) {
    const me = this, {
      eventRecord,
      owner,
      view
    } = me, {
      eventStore
    } = view, mode = drag[eventDragSym], descriptor = modeDescriptor[(mode === null || mode === void 0 ? void 0 : mode.type) || "move"];
    if (descriptor && me.hit) {
      const validation = descriptor.validatorFn ? await owner.callback(owner[descriptor.validatorFn], owner, [{
        drag,
        eventRecord,
        event: drag.event
      }]) : true;
      if (validation !== false) {
        await me[descriptor.finisher](drag, owner, eventRecord, eventStore, validation, async (eventName) => {
          let info = {
            drag,
            eventRecord,
            validation,
            event: drag.event,
            feature: owner,
            view: drag[me.isResizing ? "source" : "target"].view
          };
          const result = await owner.client.trigger("before" + StringHelper.capitalize(eventName), info);
          if (result === false) {
            info = false;
          } else {
            owner.client.trigger(eventName, info);
          }
          return info;
        });
      }
    }
    me.cleanupDrop();
  }
  async finishDropCreate(drag, owner, eventRecord, eventStore, validation, triggerFn) {
    const add = (validation === null || validation === void 0 ? void 0 : validation.add) !== false;
    const result = await triggerFn("dragCreateEnd");
    if (result === false) {
      if (add) {
        eventStore.remove(eventRecord);
      }
    } else if (add && !eventStore.includes(eventRecord)) {
      eventStore.add(eventRecord);
    }
  }
  async finishDropMove(drag, owner, eventRecord, eventStore, validation, triggerFn) {
    let dropRec = await drag.get("eventRecord");
    const me = this, {
      view
    } = me, storeRec = dropRec.isOccurrence ? dropRec.recurringTimeSpan : dropRec, {
      source
    } = drag, interView = source !== me, isReassign = interView && source.resource !== me.resource;
    if (!isReassign && drag.source === drag.target && DateHelper.isEqual(eventRecord.startDate, dropRec.startDate) && DateHelper.isEqual(eventRecord.endDate, dropRec.endDate)) {
      if (dropRec.eventStore === eventStore) {
        return;
      }
    }
    const result = await triggerFn("dragMoveEnd");
    if (result === false) {
      return;
    }
    if (!eventStore.getByInternalId(storeRec.internalId)) {
      var _ref, _dropRec$resourceId;
      const sourceStore = await drag.get("sourceStore");
      if (sourceStore) {
        sourceStore.remove(dropRec);
        await me.moveEventTo(drag, dropRec);
      } else {
        dropRec = eventRecord;
      }
      const resource = (_ref = (_dropRec$resourceId = dropRec.resourceId) !== null && _dropRec$resourceId !== void 0 ? _dropRec$resourceId : me.resource) !== null && _ref !== void 0 ? _ref : this.owner.client.defaultCalendarId;
      delete dropRec.resourceId;
      eventStore.add(dropRec);
      dropRec.assign(isReassign ? me.resource : resource);
    } else {
      dropRec = await me.finishDropConfirm(dropRec);
      if (dropRec) {
        await me.moveEventTo(drag, dropRec);
        if (isReassign) {
          dropRec.assign(me.resource);
          dropRec.unassign(source.resource);
        }
        if (interView && me.owner.client.activeView.eachView) {
          var _view$getEventElement;
          view.refresh();
          (_view$getEventElement = view.getEventElement(dropRec, dropRec.startDate)) === null || _view$getEventElement === void 0 ? void 0 : _view$getEventElement.focus();
        }
      }
    }
  }
  async finishDropResize(drag, owner, eventRecord, eventStore, validation, triggerFn) {
    const result = await triggerFn("dragResizeEnd");
    if (result === false) {
      return;
    }
    let {
      eventRecord: editRec
    } = await drag.get("eventSourceHit");
    editRec = await this.finishDropConfirm(editRec);
    editRec && editRec.set({
      startDate: eventRecord.startDate,
      endDate: eventRecord.endDate,
      duration: DateHelper.diff(eventRecord.startDate, eventRecord.endDate, editRec.durationUnit)
    });
  }
  async finishDropConfirm(eventRecord) {
    if (eventRecord.isOccurrence || eventRecord.isRecurring) {
      return new Promise((resolve) => {
        const dialog = new RecurrenceConfirmationPopup({
          owner: this.owner
        });
        dialog.confirm({
          actionType: "update",
          eventRecord,
          cancelFn() {
            resolve(null);
          },
          changerFn(eventRec) {
            resolve(eventRec);
          }
        });
      });
    }
    return eventRecord;
  }
  async moveEventTo(drag, eventRecord) {
    const me = this;
    let date2 = me.view.getDateFromElement(drag.targetElement);
    if (eventRecord.startDate) {
      date2 = DateHelper.copyTimeValues(me.clearTime(date2), eventRecord.startDate);
    }
    date2 = me.applyDragOffset(date2, drag);
    if (!me.view.eventStore.getByInternalId(eventRecord.internalId) && !eventRecord.startDate) {
      const autoCreate = drag.target.view.autoCreate || me.owner.client.autoCreate;
      date2.setHours((autoCreate === null || autoCreate === void 0 ? void 0 : autoCreate.startHour) || 8);
    }
    await me.setStartDate(eventRecord, date2);
  }
  pickDropTarget(drag) {
    var _hit;
    const me = this;
    let hit = me.hitTest(drag);
    if (!hit && me.isResizing) {
      hit = me.hit;
    }
    return (_hit = hit) !== null && _hit !== void 0 && _hit.date ? hit : null;
  }
  setStartDate(eventRecord, date2) {
    return eventRecord.set({
      startDate: date2,
      endDate: DateHelper.add(date2, this.eventRecord.duration, this.eventRecord.durationUnit)
    });
  }
  getHoverHandleCls(other) {
    return other ? "" : "b-gripper-vert";
  }
  hoverEnter() {
    var _hit$eventRecord, _hit$eventRecord2;
    const me = this, hit = me.hitTest(me.hoverTarget), {
      gripper
    } = me.owner, cls = me.getHoverHandleCls(), otherCls = me.getHoverHandleCls(true);
    otherCls && gripper.classList.remove(otherCls);
    if ((hit === null || hit === void 0 ? void 0 : (_hit$eventRecord = hit.eventRecord) === null || _hit$eventRecord === void 0 ? void 0 : _hit$eventRecord.resizable) !== false && !(hit !== null && hit !== void 0 && (_hit$eventRecord2 = hit.eventRecord) !== null && _hit$eventRecord2 !== void 0 && _hit$eventRecord2.readOnly)) {
      cls && gripper.classList.add(cls);
      me.hoverTarget.appendChild(gripper);
    }
  }
  hoverLeave(leaving) {
    const me = this, {
      gripper
    } = me.owner, cls = me.getHoverHandleCls();
    if (gripper.parentNode === leaving) {
      cls && gripper.classList.remove(cls);
      leaving.removeChild(gripper);
    }
  }
  applyDragOffset(date2, drag) {
    const eventOffset = drag.peek("eventOffset");
    if (date2 && eventOffset !== null && eventOffset !== void 0 && eventOffset[0]) {
      var _drag$target;
      if (drag.source.constructor === ((_drag$target = drag.target) === null || _drag$target === void 0 ? void 0 : _drag$target.constructor)) {
        date2 = DateHelper.add(date2, -eventOffset[0], eventOffset[1]);
      }
    }
    return date2;
  }
  hitTest(at) {
    const me = this, isDragContext = at === null || at === void 0 ? void 0 : at.isDragContext, event = isDragContext ? at.event : at, target = isDragContext && at.targetElement || DomHelper.getEventElement(event);
    let src = me.view, hit = null, edge, wrapEl;
    if (target) {
      if (!src.calendarHitTest) {
        src = me.owner.client;
      }
      const horizontalStartEdge = src.rtl ? "right" : "left";
      hit = src.calendarHitTest(target);
      if (hit) {
        hit.eventWrap = wrapEl = target.closest(".b-cal-event-wrap");
        if (target.classList.contains("b-gripper")) {
          hit = {
            type: "resize",
            cell: hit.cell,
            date: hit.date,
            edge: edge = {},
            eventRecord: hit.eventRecord,
            eventWrap: wrapEl,
            gripper: target,
            view: hit.view
          };
          DomClassList.normalize(wrapEl.className, "array").forEach((c) => {
            c = edgeRe.exec(c);
            c && (edge[c[1]] = true);
          });
          hit.atEnd = !(edge.top || edge[horizontalStartEdge]);
        } else if (!hit.eventRecord) {
          wrapEl = null;
        }
        if (wrapEl) {
          hit.eventTop = wrapEl.style.top;
        }
        if (target !== event) {
          hit.date = me.getDateFromPosition(event.clientX, event.clientY) || hit.date;
        }
      }
    }
    return hit;
  }
  renderEvent(eventRecord, first, last) {
    const {
      view
    } = this;
    Object.defineProperty(eventRecord, "resource", {
      configurable: true,
      get: () => view.defaultCalendar
    });
    const dom = view.createEventDomConfig({
      eventRecord,
      isAllDay: isAllDayView[view.type]
    });
    dom.className["b-cal-tentative-event"] = 1;
    dom.className["b-cal-tentative-event-first"] = first;
    dom.className["b-cal-tentative-event-last"] = last;
    delete eventRecord.resource;
    if (last) {
      const {
        footer
      } = this.owner;
      if (footer) {
        appendEventFooter(dom, ObjectHelper.assign({
          html: DateHelper.format(eventRecord.endDate, view.timeFormat)
        }, footer));
      }
    }
    return dom;
  }
  setEventData(data, creating) {
    const me = this, {
      eventRecord,
      view
    } = me, {
      duration,
      startDate
    } = data;
    if (startDate && duration != null && !data.endDate) {
      data = _objectSpread2(_objectSpread2({}, data), {}, {
        endDate: DateHelper.add(startDate, duration, eventRecord.durationUnit)
      });
    }
    eventRecord.set(data);
    if (me.eventDom) {
      me.eventDom.className[view.shortEventCls] = eventRecord.durationMS <= view.shortEventDuration;
    } else {
      if (creating) {
        let {
          newName
        } = me.owner;
        if (typeof newName === "function") {
          newName = newName(eventRecord);
        }
        eventRecord.set("name", newName);
      }
      me.eventDom = me.renderEvent(eventRecord);
    }
  }
  setupEvent(data, creating) {
    var _me$dragging;
    const me = this, {
      owner
    } = me, {
      defaultCalendar,
      eventStore
    } = me.view, {
      tooltip
    } = owner, eventRecord = me.eventRecord = owner.eventRecord = eventStore.createRecord({}), assigned = creating ? /* @__PURE__ */ new Set([new eventStore.assignmentStore.modelClass({
      event: eventRecord,
      resource: defaultCalendar
    })]) : data.assigned;
    Object.defineProperty(eventRecord, "assigned", {
      configurable: true,
      get: () => assigned
    });
    me.setEventData(data, creating);
    delete eventRecord.assigned;
    if (me.isCreating && defaultCalendar) {
      eventStore.assignmentStore.assignEventToResource(eventRecord, defaultCalendar);
    }
    const {
      eventDom
    } = me;
    eventDom.className[tentativeCls] = 1;
    if (!me.noTip && !tooltip.disabled && (_me$dragging = me.dragging) !== null && _me$dragging !== void 0 && _me$dragging.has("eventCreate")) {
      tooltip.eventRecord = eventRecord;
      tooltip.recurrenceHint = creating && me.recurrable ? owner.recurrenceTip : "";
      me.dragProxy.tooltip = tooltip;
    }
    return eventDom;
  }
  startCreate(date2) {
    this.createEvent({
      allDay: true,
      startDate: date2,
      endDate: DateHelper.add(date2, 1, "d")
    });
  }
  startMove(eventRecord) {
    var _eventRecord$resource;
    const me = this, data = ObjectHelper.clone(eventRecord.data), color = (_eventRecord$resource = eventRecord.resource) === null || _eventRecord$resource === void 0 ? void 0 : _eventRecord$resource.eventColor;
    if (!data.eventColor && color) {
      data.eventColor = color;
    }
    data.assigned = eventRecord.assigned;
    if (!data.startDate) {
      const hit = me.pickDropTarget(me.dropping);
      data.startDate = (hit === null || hit === void 0 ? void 0 : hit.date) || new Date();
      data.endDate = DateHelper.add(data.startDate, eventRecord.duration || 1, eventRecord.durationUnit || "h");
    }
    if (!data.resourceId) {
      var _me$owner$client;
      data.resourceId = me.dropping.peek("resourceId") || ((_me$owner$client = me.owner.client) === null || _me$owner$client === void 0 ? void 0 : _me$owner$client.defaultCalendarId);
    }
    delete data.id;
    me.setupEvent(data);
  }
  startResize(eventHit) {
    var _eventRecord$resource2;
    const {
      eventRecord
    } = eventHit, data = eventRecord.data;
    this.createEvent(_objectSpread2(_objectSpread2({}, data), {}, {
      id: `dragResize-event-${data.id}`,
      eventColor: data.eventColor || ((_eventRecord$resource2 = eventRecord.resource) === null || _eventRecord$resource2 === void 0 ? void 0 : _eventRecord$resource2.eventColor),
      recurrenceRule: null,
      realEventId: data.id
    }));
  }
  configureListeners(drag) {
    const listeners = super.configureListeners(drag);
    listeners.element = this.view.rootElement;
    return listeners;
  }
  updateHit(hit) {
    const me = this, drag = me.dropping, mode = hit && drag[eventDragSym];
    if (hit) {
      if (me.isMoving) {
        me.dropHitMove(drag, hit, drag.peek("eventRecord"));
      } else if (mode !== null && mode !== void 0 && mode.create) {
        me.dropHitCreate(drag, hit, drag.peek("eventCreate"));
      } else if (mode !== null && mode !== void 0 && mode.resize) {
        me.dropHitResize(drag, hit, drag.peek("eventSourceHit"));
      }
    } else {
      me.dropHitNowhere(drag);
    }
  }
  updateDays(days2) {
    const me = this, {
      calendarCells,
      eventDom,
      dayValues
    } = me, newDayValues = calendarCells && {};
    let first = true, cell, date2, dayValue, i, lastCell;
    me.dayValues = newDayValues;
    if (calendarCells && eventDom) {
      for (i = 0; i < calendarCells.length; ++i) {
        cell = calendarCells[i];
        if (days2 !== null && days2 !== void 0 && days2.includes(cell.dataset.date)) {
          lastCell = cell;
        }
      }
      for (i = 0; i < calendarCells.length; ++i) {
        cell = calendarCells[i];
        date2 = cell.dataset.date;
        if (days2 !== null && days2 !== void 0 && days2.includes(date2)) {
          if (!(dayValue = dayValues === null || dayValues === void 0 ? void 0 : dayValues[date2])) {
            dayValue = me.includeDay(date2, cell, first, cell === lastCell) || true;
            first = false;
          } else {
            delete dayValues[date2];
          }
          newDayValues[date2] = dayValue;
        }
      }
      if (dayValues) {
        for (i in dayValues) {
          me.removeDay(i, dayValues[i]);
        }
      }
    }
  }
  updateEventRecord(record) {
    this.owner.eventRecord = record;
  }
  updateOverflow(value, instance) {
    if (!value && instance) {
      instance.destroy();
    }
    return value;
  }
  updateOwner(owner) {
    this.hoverIgnoreElement = owner === null || owner === void 0 ? void 0 : owner.gripper;
  }
  updateRootElement(rootEl) {
    const me = this;
    me.dragRootElement = rootEl;
    me.dropRootElement = me.droppable ? rootEl : null;
    me.hoverRootElement = me.hoverable ? rootEl : null;
  }
  updateView(view, was) {
    var _me$_overflowDetacher;
    super.updateView(view, was);
    const me = this;
    me.rootElement = view ? me.findRootElement(view) : null;
    (_me$_overflowDetacher = me._overflowDetacher) === null || _me$_overflowDetacher === void 0 ? void 0 : _me$_overflowDetacher.call(me);
    if (view !== null && view !== void 0 && view.isDayCellRenderer) {
      me._overflowDetacher = view.ion({
        thisObj: me,
        showOverflowPopup: "onShowOverflowPopup"
      });
    }
  }
};
Zone.prototype._eventRecord = null;
var BaseDayZone = class extends Zone {
  static get $name() {
    return "BaseDayZone";
  }
  static get configurable() {
    return {
      hoverSelector: ".b-cal-event-wrap",
      draggingClsSelector: ".b-dayview-content"
    };
  }
  getHoverHandleCls(other) {
    let vert = this.isAllDayZone;
    if (other) {
      vert = !vert;
    }
    return `b-gripper-${vert ? "vert" : "horz"}`;
  }
};
var AllDayZone = class extends BaseDayZone {
  static get $name() {
    return "AllDayZone";
  }
  static get configurable() {
    return {
      hoverEdges: "lr"
    };
  }
  beforeDrag(drag) {
    const ret = super.beforeDrag(drag);
    if (ret !== false && !this.draggable) {
      if (drag[eventDragSym].move) {
        return false;
      }
    }
    return ret;
  }
  dragEnter(drag) {
    if (!this.view.eventsPerCell) {
      this.view.expandGutter();
    }
    return super.dragEnter(drag);
  }
  dragLeave(drag) {
    this.view.collapseGutter();
    super.dragLeave(drag);
  }
  captureDragOffset(eventRecord, hit, drag) {
    drag.set("eventOffset", [Math.max(Math.floor(DateHelper.diff(eventRecord.startDate, hit.date, "d")), 0), "d"]);
  }
  dropHitCreate(drag, hit, dragFrom) {
    let endDate = this.clearTime(hit.date), startDate = this.clearTime(dragFrom.date);
    if (endDate < startDate) {
      [startDate, endDate] = [endDate, startDate];
    }
    this.setEventData({
      startDate,
      duration: DateHelper.diff(startDate, endDate, "d") + 1,
      durationUnit: "d"
    });
  }
  async moveEventTo(drag, dropRec) {
    const me = this, hit = me.hitTest(drag), date2 = me.applyDragOffset(hit === null || hit === void 0 ? void 0 : hit.date, drag), newDate = new Date(dropRec.startDate);
    if (date2) {
      newDate.setFullYear(date2.getFullYear());
      newDate.setMonth(date2.getMonth());
      newDate.setDate(date2.getDate());
      if (me.view.dayTime.startShift) {
        newDate.setHours(date2.getHours());
        newDate.setMinutes(date2.getMinutes());
        newDate.setSeconds(date2.getSeconds());
        dropRec.duration = 1;
      } else {
        if (!me.view.isAllDayEvent(dropRec)) {
          dropRec.allDay = true;
        }
      }
      await me.setStartDate(dropRec, newDate);
    }
  }
  setEventData(data, creating) {
    super.setEventData(data, creating);
    const me = this, {
      eventRecord
    } = me;
    const {
      startDate,
      endDate
    } = eventRecord;
    if (creating && !me.view.dayTime.startShift) {
      eventRecord.allDay = true;
    }
    me.days = me.makeDays(startDate, endDate);
  }
  updateDays(days2) {
    const me = this;
    let {
      eventEl
    } = me;
    if (days2 !== null && days2 !== void 0 && days2.length) {
      var _me$dragging2, _me$dragging2$peek;
      if (!eventEl) {
        me.eventEl = eventEl = DomHelper.createElement(_objectSpread2({}, me.eventDom));
        eventEl.classList.add("b-allday");
      }
      const {
        dropRootElement
      } = me, {
        hideNonWorkingDays,
        visibleCellSelector,
        weekLength
      } = me.view, eventTop = (_me$dragging2 = me.dragging) === null || _me$dragging2 === void 0 ? void 0 : (_me$dragging2$peek = _me$dragging2.peek("eventSourceHit")) === null || _me$dragging2$peek === void 0 ? void 0 : _me$dragging2$peek.eventTop, cells = DomHelper.children(dropRootElement, `${visibleCellSelector}${hideNonWorkingDays ? ":not(.b-nonworking-day)" : ""}`), cell = DomHelper.down(dropRootElement, `${visibleCellSelector}${hideNonWorkingDays ? ":not(.b-nonworking-day)" : ""}[data-date='${days2[days2.length - 1]}']`);
      DomHelper.down(cell, ".b-cal-event-bar-container").appendChild(eventEl);
      eventEl.style[me.view.rtl ? "right" : "left"] = DomHelper.percentify(100 * (cells.indexOf(cell) - days2.length + 1) / weekLength);
      eventEl.style.width = DomHelper.percentify(100 * days2.length / weekLength);
      if (eventTop) {
        eventEl.style.top = eventTop;
      }
      me.view.scrollable.scrollIntoView(eventEl, true);
    } else if (eventEl) {
      if (eventEl.classList.contains("b-cal-tentative-event")) {
        eventEl.remove();
      }
      me.eventEl = null;
    }
  }
  updateView(view, was) {
    if (view) {
      const multiDay = DateHelper.diff(view.startDate, view.endDate, "d") > 1;
      this.hoverable = this.draggable = multiDay;
    }
    super.updateView(view, was);
  }
};
var DayZone$1 = class extends BaseDayZone {
  static get $name() {
    return "DayZone";
  }
  static get configurable() {
    return {
      dragEventId: null,
      hoverable: true,
      hoverEdges: "tb",
      times: {
        $config: {
          equal: "array"
        },
        value: null
      }
    };
  }
  construct(...args) {
    const me = this;
    super.construct(...args);
    me.allDayZone = new AllDayZone({
      active: me.active,
      owner: me.owner,
      view: me.view.allDayEvents,
      resource: me.resource
    });
  }
  syncDraggingElements(eventId, active) {
    const {
      dragging: drag
    } = this, {
      draggingItemCls
    } = drag.source, containerEl = drag.itemElement.closest(".b-dayview-day-container"), elements = containerEl.querySelectorAll(`[data-event-id="${eventId}"]`);
    for (const el of elements) {
      el.classList.toggle(draggingItemCls, active);
    }
  }
  updateDragEventId(eventId, previousEventId) {
    previousEventId && this.syncDraggingElements(previousEventId, false);
    eventId && this.syncDraggingElements(eventId, true);
  }
  get eventRecord() {
    var _this$allDayZone;
    return super.eventRecord || ((_this$allDayZone = this.allDayZone) === null || _this$allDayZone === void 0 ? void 0 : _this$allDayZone.eventRecord);
  }
  set eventRecord(value) {
    super.eventRecord = value;
  }
  get recurring() {
    var _this$eventRecord;
    return this.isCreating && ((_this$eventRecord = this.eventRecord) === null || _this$eventRecord === void 0 ? void 0 : _this$eventRecord.recurrenceRule) != null;
  }
  get droppingAllDay() {
    var _this$dropping5, _this$view2;
    const eventRecord = (_this$dropping5 = this.dropping) === null || _this$dropping5 === void 0 ? void 0 : _this$dropping5.peek("eventRecord");
    return (eventRecord === null || eventRecord === void 0 ? void 0 : eventRecord.startDate) && ((_this$view2 = this.view) === null || _this$view2 === void 0 ? void 0 : _this$view2.isAllDayEvent(eventRecord)) || false;
  }
  get useAllDay() {
    return this.droppingAllDay && this.view.showAllDayHeader && this.dropping.source !== this.allDayZone;
  }
  get wasAllDay() {
    return this.droppingAllDay && this.dropping.source === this.allDayZone;
  }
  doDestroy() {
    var _this$allDayZone2;
    (_this$allDayZone2 = this.allDayZone) === null || _this$allDayZone2 === void 0 ? void 0 : _this$allDayZone2.destroy();
    super.doDestroy();
  }
  dragStart() {
    var _this$dragging$peek$i, _this$dragging$peek;
    super.dragStart();
    this.dragEventId = (_this$dragging$peek$i = (_this$dragging$peek = this.dragging.peek("eventRecord")) === null || _this$dragging$peek === void 0 ? void 0 : _this$dragging$peek.id) !== null && _this$dragging$peek$i !== void 0 ? _this$dragging$peek$i : null;
  }
  findRootElement(view) {
    return view.eventContentElement;
  }
  captureDragOffset(eventRecord, hit, drag) {
    drag.set("eventOffset", [Math.floor(DateHelper.diff(eventRecord.startDate, hit.date, "m")), "m"]);
  }
  cleanupDrag() {
    var _this$allDayZone3;
    this.dragEventId = null;
    super.cleanupDrag();
    (_this$allDayZone3 = this.allDayZone) === null || _this$allDayZone3 === void 0 ? void 0 : _this$allDayZone3.cleanupDrag();
  }
  cleanupDrop() {
    var _this$owner$client2, _this$owner$client2$s, _this$allDayZone4;
    super.cleanupDrop();
    (_this$owner$client2 = this.owner.client) === null || _this$owner$client2 === void 0 ? void 0 : (_this$owner$client2$s = _this$owner$client2.scrollManager) === null || _this$owner$client2$s === void 0 ? void 0 : _this$owner$client2$s.stopMonitoring();
    (_this$allDayZone4 = this.allDayZone) === null || _this$allDayZone4 === void 0 ? void 0 : _this$allDayZone4.cleanupDrop();
  }
  dropHitCreate(drag, hit) {
    const me = this, dragFrom = drag.peek("eventCreate");
    let endTime = hit.date, startTime = dragFrom.date, endDate = endTime, startDate = startTime, duration, recurrenceCount;
    const sameDay = !(me.clearTime(startTime) - me.clearTime(endTime)), recurring = drag.ctrlKey && !sameDay;
    if (recurring || sameDay) {
      endDate = me.clearTime(endTime);
      startDate = me.clearTime(startTime);
      startTime = startTime - startDate;
      endTime = endTime - endDate;
      if (endDate < startDate) {
        [startDate, endDate] = [endDate, startDate];
      }
      if (endTime < startTime) {
        [startTime, endTime] = [endTime, startTime];
      }
      startDate.setTime(startDate.getTime() + startTime);
      duration = Math.max(me.view.increment, Math.floor(endTime - startTime)) / MINUTES;
      if (recurring) {
        recurrenceCount = DateHelper.diff(me.clearTime(startDate), me.clearTime(endDate), "d") + 1;
      }
    } else {
      if (endDate < startDate) {
        [startDate, endDate] = [endDate, startDate];
      }
      duration = Math.floor((endDate - startDate) / MINUTES);
    }
    me.setEventData({
      startDate,
      duration,
      recurrenceRule: recurring ? `FREQ=DAILY;COUNT=${recurrenceCount}` : null
    });
  }
  dropHitMove(drag, hit, eventRecord) {
    let startDate = hit.date;
    const me = this, {
      view
    } = me, dayStart = view.dayTime.startOfDay(startDate);
    if (me.useAllDay) {
      me.allDayZone.dropHitMove(drag, hit, eventRecord);
    } else {
      eventRecord = me.eventRecord;
      startDate = me.applyDragOffset(startDate, drag);
      if (view.showAllDayHeader && startDate < dayStart) {
        startDate = dayStart;
      }
      me.setEventData({
        startDate,
        endDate: DateHelper.add(startDate, eventRecord.duration, eventRecord.durationUnit),
        duration: eventRecord.duration
      });
    }
  }
  dropHitResize(drag, hit, eventHit) {
    const me = this, {
      eventRecord
    } = me, date2 = hit.date;
    if (eventHit.atEnd) {
      if (eventRecord.startDate < date2) {
        me.setEventData({
          endDate: date2
        });
      }
    } else if (date2 < eventRecord.endDate) {
      me.setEventData({
        startDate: date2
      });
    }
  }
  async moveEventTo(drag, dropRec) {
    const me = this, hit = me.hitTest(drag), date2 = hit === null || hit === void 0 ? void 0 : hit.date;
    if (date2) {
      if (me.useAllDay) {
        await me.allDayZone.moveEventTo(drag, dropRec);
      } else {
        if (me.wasAllDay) {
          dropRec.allDay = false;
        }
        await me.setStartDate(dropRec, me.applyDragOffset(date2, drag));
      }
    }
  }
  startCreate(date2) {
    this.createEvent({
      duration: 0,
      durationUnit: "m",
      startDate: date2
    });
  }
  includeDay(date2, cell, first, last) {
    return DomHelper.createElement(_objectSpread2({
      parent: cell.querySelector(".b-dayview-event-container")
    }, this.renderEvent(this.eventRecord, first, last)));
  }
  removeDay(date2, value) {
    if (value.classList.contains("b-cal-tentative-event")) {
      value.remove();
    }
  }
  setEventData(data, creating) {
    const me = this;
    if (me.useAllDay) {
      me.allDayZone.setEventData(data, creating);
      return;
    }
    super.setEventData(data, creating);
    const {
      eventRecord
    } = me, {
      endDate,
      startDate
    } = eventRecord, {
      dayTime
    } = me.view;
    let lastDate = endDate;
    if (me.recurring) {
      lastDate = DateHelper.add(lastDate, eventRecord.recurrence.count - 1, "d");
    }
    me.days = me.makeDays(startDate, lastDate);
    me.times = [dayTime.delta(startDate, "s"), dayTime.delta(endDate, "s")];
  }
  setupEvent(data, creating) {
    const me = this;
    if (me.useAllDay) {
      me.allDayZone.setupEvent(data, creating);
    } else {
      if (this.wasAllDay) {
        data.allDay = false;
        data.endDate = DateHelper.add(data.startDate, data.duration = 1, data.durationUnit = "hour");
      }
      super.setupEvent(data, creating);
    }
  }
  updateDays(days2, was) {
    super.updateDays(days2, was);
    this.updateTimes(this.times, null);
  }
  updateTimes(times) {
    if (!times) {
      return;
    }
    const me = this, {
      allDayZone,
      dayValues,
      dragging,
      eventRecord,
      recurring,
      view
    } = me, {
      dayTime,
      eventSpacing
    } = view, insetProp = view.rtl ? "right" : "left", {
      endDate,
      startDate
    } = eventRecord, [startOffset, endOffset] = times, eventInset = !(dragging !== null && dragging !== void 0 && dragging.aborted) && (dragging === null || dragging === void 0 ? void 0 : dragging.peek("eventInset")), eventWidth = !(dragging !== null && dragging !== void 0 && dragging.aborted) && (dragging === null || dragging === void 0 ? void 0 : dragging.peek("eventWidth")), firstDay = dayTime.dateKey(startDate), lastDay = dayTime.dateKey(endDate), multiDay = dayTime.startOfDay(startDate) < dayTime.startOfDay(endDate), heightScale = 100 / dayTime.duration("s");
    let {
      days: days2
    } = me, date2, first, height, style, top;
    if (!days2) {
      return;
    }
    for (date2 in dayValues) {
      first = date2 === firstDay;
      style = dayValues[date2].style;
      top = startOffset * heightScale;
      height = (endOffset - startOffset) * heightScale;
      DomSync.sync({
        targetElement: dayValues[date2],
        domConfig: me.renderEvent(me.eventRecord, first, date2 === days2[days2.length - 1])
      });
      if (!recurring && multiDay) {
        if (first) {
          height = 100 - top;
        } else if (date2 === lastDay) {
          height = top + height;
        } else {
          height = 100;
        }
      }
      style.top = recurring || first ? DomHelper.percentify(top) : 0;
      style.height = DomHelper.percentify(height);
      style.paddingBottom = DomHelper.setLength(eventSpacing);
      if (eventInset) {
        style[insetProp] = eventInset;
      }
      if (eventWidth) {
        style.width = `${eventWidth}px`;
      }
    }
    if (!days2 || days2.length < 2 || recurring) {
      allDayZone === null || allDayZone === void 0 ? void 0 : allDayZone.cleanupDrop();
      days2 = null;
    } else if (allDayZone && view.showAllDayHeader) {
      if (!allDayZone.eventRecord) {
        allDayZone.noTip = true;
        allDayZone.createEvent({
          startDate: eventRecord.startDate,
          endDate: eventRecord.endDate
        });
      }
      allDayZone.eventRecord.set({
        startDate: eventRecord.startDate,
        endDate: DateHelper.add(eventRecord.startDate, days2.length - 1, "d")
      });
      allDayZone.days = days2;
    }
  }
};
var MonthZone = class extends Zone {
  static get $name() {
    return "MonthZone";
  }
  static get configurable() {
    return {
      coverage: {
        $config: {
          equal: ObjectHelper.isEqual
        },
        value: null
      },
      hoverable: true,
      hoverEdges: "lr",
      hoverSelector: ".b-cal-event-wrap.b-allday"
    };
  }
  findRootElement(view) {
    return view.weeksElement;
  }
  captureDragOffset(eventRecord, hit, drag) {
    drag.set("eventOffset", [Math.floor(DateHelper.diff(this.clearTime(eventRecord.startDate), hit.date, "d")), "d"]);
  }
  cleanupDrag() {
    super.cleanupDrag();
    this.coverage = null;
  }
  cleanupDrop() {
    var _this$owner$client3, _this$owner$client3$s;
    super.cleanupDrop();
    (_this$owner$client3 = this.owner.client) === null || _this$owner$client3 === void 0 ? void 0 : (_this$owner$client3$s = _this$owner$client3.scrollManager) === null || _this$owner$client3$s === void 0 ? void 0 : _this$owner$client3$s.stopMonitoring();
    this.coverage = null;
  }
  dropHitCreate(drag, hit) {
    const me = this, recurring = drag.ctrlKey, dragFrom = drag.peek("eventCreate");
    let recurrence = null, count, day12, day2, endDate, startDate, week1, week2;
    endDate = me.clearTime(hit.date);
    startDate = me.clearTime(dragFrom.date);
    day12 = dragFrom.dayNumber;
    day2 = hit.dayNumber;
    week1 = dragFrom.weekOffset;
    week2 = hit.weekOffset;
    if (week2 < week1) {
      [week1, week2] = [week2, week1];
    }
    if (recurring) {
      count = week2 - week1 + 1;
      recurrence = count > 1 ? `FREQ=WEEKLY;COUNT=${count}` : null;
      if (endDate < startDate) {
        startDate = endDate;
        if (day12 < day2) {
          startDate = DateHelper.add(startDate, day12 - day2, "d");
        }
      } else if (day2 < day12) {
        startDate = DateHelper.add(startDate, day2 - day12, "d");
      }
      if (day2 < day12) {
        [day12, day2] = [day2, day12];
      }
    } else if (endDate < startDate) {
      [startDate, endDate] = [endDate, startDate];
      [day12, day2] = [day2, day12];
    }
    me.setEventData({
      startDate,
      duration: (recurring ? day2 - day12 : DateHelper.diff(startDate, endDate, "d")) + 1,
      durationUnit: "d",
      recurrenceRule: recurrence
    });
  }
  dropHitNowhere(drag) {
    super.dropHitNowhere(drag);
    this.coverage = null;
  }
  setEventData(data, creating) {
    super.setEventData(data, creating);
    const {
      dropping,
      eventRecord,
      view
    } = this, {
      visibleCellSelector,
      hideNonWorkingDays
    } = view, weekEls = DomHelper.children(view.weeksElement, "> .b-calendar-week"), coverage = {}, add = (event) => {
      const {
        startDate,
        endDate
      } = event;
      for (let cells, cover, k, n, i = 0; i < weekEls.length; ++i) {
        cells = DomHelper.children(weekEls[i], `${visibleCellSelector}${hideNonWorkingDays ? ":not(.b-nonworking-day)" : ""}`);
        n = cells.length;
        cover = "";
        for (k = 0; k < n; ++k) {
          const dayStart = view.getDateFromElement(cells[k]), dayEnd = DateHelper.add(dayStart, 1, "d");
          if (startDate < dayEnd && dayStart < endDate) {
            if (!k && startDate < dayStart) {
              cover = "<";
            }
            cover += k;
            if (k === n - 1 && dayEnd < endDate) {
              cover += ">";
            }
          }
        }
        if (cover) {
          (coverage[i] || (coverage[i] = [])).push(cover);
        }
      }
    };
    if (dropping !== null && dropping !== void 0 && dropping.has("eventRecord") || !eventRecord.recurrence) {
      add(eventRecord);
    } else {
      eventRecord.recurrence.forEachOccurrence(view.startDate, view.endDate, add);
    }
    this.coverage = coverage;
  }
  updateCoverage(coverage) {
    const me = this, {
      dragging,
      weekValues,
      view
    } = me, {
      rtl
    } = view, {
      visibleCellSelector,
      hideNonWorkingDays
    } = view, eventSourceHit = coverage && (dragging === null || dragging === void 0 ? void 0 : dragging.peek("eventSourceHit")), eventTop = eventSourceHit === null || eventSourceHit === void 0 ? void 0 : eventSourceHit.eventTop, newWeekValues = {}, eventRow = view.getWeekElementFor(eventSourceHit === null || eventSourceHit === void 0 ? void 0 : eventSourceHit.eventElement), {
      weekElements
    } = view;
    let cell, cells, cov, cover, el, eventEl, extL, extR, i, k, weekEl;
    me.weekValues = newWeekValues;
    for (i = 0; i < weekElements.length; ++i) {
      if (!(cover = coverage === null || coverage === void 0 ? void 0 : coverage[i])) {
        continue;
      }
      weekEl = weekElements[i];
      cells = DomHelper.children(weekEl, `${visibleCellSelector}${hideNonWorkingDays ? ":not(.b-nonworking-day)" : ""}`);
      for (k = 0; k < cover.length; ++k) {
        var _weekValues$i;
        if (!(eventEl = weekValues === null || weekValues === void 0 ? void 0 : (_weekValues$i = weekValues[i]) === null || _weekValues$i === void 0 ? void 0 : _weekValues$i.shift())) {
          eventEl = DomHelper.createElement(me.eventDom);
        }
        (newWeekValues[i] || (newWeekValues[i] = [])).push(eventEl);
        cov = cover[k];
        extL = cov.includes("<") ? 1 : 0;
        extR = cov.includes(">") ? 1 : 0;
        cov = cov.substr(extL, cov.length - extR - extL);
        eventEl.classList[extL ? "add" : "remove"]("b-continues-past");
        eventEl.classList[extR ? "add" : "remove"]("b-continues-future");
        eventEl.style[rtl ? "right" : "left"] = DomHelper.percentify(100 * Number(cov[0]) / cells.length);
        eventEl.style.width = DomHelper.percentify(100 * cov.length / cells.length);
        if (eventTop && weekEl === eventRow) {
          eventEl.style.top = eventTop;
        }
        cell = cells[Number(cov[cov.length - 1])];
        el = DomHelper.down(cell, ".b-cal-event-bar-container");
        if (el !== eventEl.parentNode) {
          el.appendChild(eventEl);
        }
      }
    }
    if (weekValues) {
      for (i in weekValues) {
        weekValues[i].forEach((el2) => {
          if (el2.classList.contains("b-cal-tentative-event")) {
            el2.remove();
          }
        });
      }
    }
  }
};
var OverflowZone = class extends Zone {
  static get $name() {
    return "OverflowZone";
  }
  static get configurable() {
    return {
      droppable: false,
      dragProxy: {
        type: "default",
        open(drag) {
          const me = this, {
            owner
          } = drag.source.view, sourceEl = drag.element.closest(".b-cal-event-wrap");
          if (owner.isYearView) {
            me.proxyEl = sourceEl.cloneNode(true);
            me.proxyEl.classList.add("b-cal-drag-proxy");
            me.proxyEl.style.width = `${sourceEl.offsetWidth}px`;
            me.proxyOffset = EventHelper.getClientPoint(drag.startEvent).getDelta(Rectangle.from(sourceEl));
            owner.contentElement.appendChild(me.proxyEl);
          }
        },
        dragMove(drag) {
          if (this.proxyEl) {
            DomHelper.alignTo(this.proxyEl, EventHelper.getClientPoint(drag.event).translate(10, 10), {
              align: "t0-t0"
            });
          }
        },
        close() {
          var _this$proxyEl;
          (_this$proxyEl = this.proxyEl) === null || _this$proxyEl === void 0 ? void 0 : _this$proxyEl.remove();
        }
      }
    };
  }
  findRootElement(view) {
    return view.contentElement;
  }
  beforeDrag(drag) {
    const hit = this.hitTest(drag);
    if ((hit === null || hit === void 0 ? void 0 : hit.type) !== "event" || !this.owner.draggable || !hit.eventRecord.isDraggable) {
      return false;
    }
    drag.set("eventRecord", hit.eventRecord);
    drag.set("eventDragMode", drag[eventDragSym] = modeDescriptor.move.mode);
  }
  dragStart() {
    this.view.hide();
  }
};
var YearZone = class extends Zone {
  static get $name() {
    return "YearZone";
  }
  startCreate() {
    var _this$view$_overflowP;
    (_this$view$_overflowP = this.view._overflowPopup) === null || _this$view$_overflowP === void 0 ? void 0 : _this$view$_overflowP.hide();
    super.startCreate(...arguments);
  }
  dragEnter(drag) {
    const result = super.dragEnter(drag);
    if (result !== false) {
      this.view.contentElement.classList.add(this.draggingCls);
    }
    return result;
  }
  dragLeave(drag) {
    super.dragLeave(drag);
    this.view.contentElement.classList.remove(this.draggingCls);
  }
  dropHitCreate(drag, hit, dragFrom) {
    const me = this;
    let endDate = me.clearTime(hit.date), startDate = me.clearTime(dragFrom.date);
    if (endDate < startDate) {
      [startDate, endDate] = [endDate, startDate];
    }
    me.setEventData({
      startDate,
      endDate: DateHelper.add(endDate, 1, "d")
    });
    me.days = me.makeDayRange(startDate, endDate);
  }
  dropHitMove(drag, hit, eventRecord) {
    super.dropHitMove(drag, hit, eventRecord);
    const me = this, tempRec = me.eventRecord;
    let {
      endDate
    } = tempRec;
    if (tempRec.allDay) {
      endDate = DateHelper.add(endDate, -1, "d");
    }
    me.days = me.makeDayRange(tempRec.startDate, endDate);
  }
  includeDay(date2) {
    const els = DomHelper.children(this.view.bodyElement, `[data-date='${date2}']`);
    els.forEach((e) => e.classList.add(`b-cal-tentative-event${this.view.hideNonWorkingDays ? ":not(.b-nonworking-day)" : ""}`));
    return els;
  }
  makeDayRange(startDate, endDate) {
    const days2 = [];
    for (let date2 = startDate; date2 <= endDate; date2 = DateHelper.add(date2, 1, "d")) {
      days2.push(DateHelper.format(date2, YYYY_MM_DD));
    }
    return days2;
  }
  removeDay(date2, els) {
    els.forEach((e) => e.classList.remove("b-cal-tentative-event"));
  }
};
var ResourceViewZone = class extends Base$1 {
  static get configurable() {
    return {
      view: null,
      zones: {
        $config: ["nullify"],
        value: []
      }
    };
  }
  updateView(view) {
    view.eachView((view2) => {
      this.onResourceViewViewCreate({
        view: view2
      });
    });
    view.ion({
      viewCreate: "onResourceViewViewCreate",
      thisObj: this
    });
  }
  onResourceViewViewCreate({
    view
  }) {
    const me = this, {
      zones,
      owner
    } = me, modes = owner.client.constructor.Modes, type = owner.getViewZoneType(modes.resolveType(view.type));
    type && zones.push(owner.createZone(type, {
      view,
      resource: view.defaultCalendar
    }));
  }
  changeZones(zones, oldZones) {
    if (oldZones !== null && oldZones !== void 0 && oldZones.length && !zones) {
      for (let i = 0, {
        length
      } = oldZones; i < length; i++) {
        oldZones[i].destroy();
      }
    }
    return zones;
  }
};
var CalendarDrag = class extends CalendarFeature {
  static get $name() {
    return "CalendarDrag";
  }
  static get type() {
    return "drag";
  }
  static get configurable() {
    return {
      disableOnReadOnly: true,
      localizableProperties: ["newName", "recurrenceTip"],
      creatable: true,
      draggable: true,
      footer: {
        className: "b-cal-event-footer"
      },
      gripper: {
        class: "b-gripper"
      },
      newName: "L{newEvent}",
      recurrenceTip: "(L{holdCtrlForRecurrence})",
      resizable: true,
      tooltip: {
        $config: ["lazy", "nullify"],
        value: {
          type: "eventTip",
          disabled: true,
          forSelector: null,
          tools: null
        }
      },
      validateCreateFn: () => {
      },
      validateMoveFn: () => {
      },
      validateResizeFn: () => {
      },
      zoneTypes: {
        day: DayZone$1,
        month: MonthZone,
        year: YearZone,
        resource: ResourceViewZone
      }
    };
  }
  changeGripper(gripper, was) {
    was === null || was === void 0 ? void 0 : was.remove();
    return gripper && DomHelper.createElement(gripper);
  }
  changeTooltip(config, existing) {
    if (config) {
      config = config === true ? this.constructor.configurable.tooltip.value : config;
      if (this.initialConfig.tooltip) {
        config.disabled = false;
      }
      config.ownerFeature = this;
    }
    return Widget.reconfigure(existing, config, this);
  }
};
CalendarDrag.initClass();
CalendarDrag._$name = "CalendarDrag";
var EventEditor = class extends EventEditor$1 {
  static get $name() {
    return "EventEditor";
  }
  static get type() {
    return "calendareventeditor";
  }
  static get configurable() {
    return {
      align: {
        monitorResize: true
      }
    };
  }
  updateRecord(record) {
    this.fixTimeFieldVisibility(record.allDay);
    super.updateRecord(record);
  }
  onAllDayChange({
    value,
    userAction
  }) {
    this.fixTimeFieldVisibility(value, userAction);
  }
  fixTimeFieldVisibility(allDay, fromUI) {
    const hideShowMethod = allDay ? "hide" : "show", addRemoveMethod = allDay ? "remove" : "add", {
      startDateField,
      startTimeField,
      endDateField,
      endTimeField
    } = this.widgetMap;
    startTimeField && startTimeField[hideShowMethod]();
    endTimeField && endTimeField[hideShowMethod]();
    startDateField === null || startDateField === void 0 ? void 0 : startDateField.element.classList[addRemoveMethod]("b-inline");
    endDateField === null || endDateField === void 0 ? void 0 : endDateField.element.classList[addRemoveMethod]("b-inline");
    if (!allDay && fromUI) {
      startDateField && (startDateField.value = startTimeField.value = this.record.getData("startDate"));
      endDateField && (endDateField.value = endTimeField.value = this.record.getData("endDate"));
    }
  }
  onBeforeShow() {
    const {
      deleteButton
    } = this.widgetMap;
    super.onBeforeShow(...arguments);
    if (deleteButton && !deleteButton.hidden) {
      if (this.record.isCreating) {
        deleteButton.hide();
      }
    }
  }
  onFocusOut() {
    super.onFocusOut(...arguments);
    this.owner = this.initialConfig.owner;
  }
};
EventEditor.initClass();
EventEditor._$name = "EventEditor";
var EventEdit = class extends EventEdit$1 {
  static get $name() {
    return "EventEdit";
  }
  static get type() {
    return "eventEdit";
  }
  static get configurable() {
    return {
      editorConfig: {
        type: "calendareventeditor",
        items: {
          resourceField: {
            label: "L{Calendar}",
            showEventColor: true
          },
          allDay: {
            type: "checkbox",
            cls: "b-match-label",
            name: "allDay",
            weight: 250,
            label: "L{All day}",
            internalListeners: {
              change: "up.onAllDayChange"
            }
          }
        }
      }
    };
  }
  construct(config) {
    super.construct(config.client, config);
  }
  onDragCreateEnd({
    eventRecord
  }) {
    this.editNewlyCreatedEvent(eventRecord);
  }
  onEventAutoCreated({
    eventRecord
  }) {
    this.editNewlyCreatedEvent(eventRecord);
  }
  editNewlyCreatedEvent(eventRecord) {
    if (!this.disabled) {
      eventRecord.isCreating = true;
      return this.editEvent(eventRecord);
    }
  }
  async doEditEvent(eventRecord, resourceRecord, element) {
    var _view$features, _view$features$cellEd, _me$editor;
    const me = this, {
      client
    } = me, {
      eventStore
    } = client;
    let view = client.eventSource || client.activeSubView, eventAdded = false;
    if (view.isScheduler) {
      me.client = view;
      await super.doEditEvent(...arguments);
      me.client = client;
      return;
    }
    if (!view.isCalendarMixin || (_view$features = view.features) !== null && _view$features !== void 0 && (_view$features$cellEd = _view$features.cellEdit) !== null && _view$features$cellEd !== void 0 && _view$features$cellEd.isEditing) {
      return;
    }
    if (!DateHelper.intersectSpans(eventRecord.startDate, eventRecord.endDate, view.startDate, view.endDate)) {
      client.date = eventRecord.startDate;
    }
    if (!eventRecord.isOccurrence && !eventStore.includes(eventRecord)) {
      eventAdded = eventRecord.isCreating = true;
      await eventStore.addAsync(eventRecord);
    }
    if (view.isAllDayEvent(eventRecord) && view.allDayEvents && view.showAllDayHeader) {
      view = view.allDayEvents;
    }
    const {
      _overflowPopup
    } = view, activeDate = view.getDateFromElement(element);
    let fromOverflow = _overflowPopup === null || _overflowPopup === void 0 ? void 0 : _overflowPopup.isVisible, eventElement = fromOverflow ? _overflowPopup.getEventElement(eventRecord) : view.getEventElement(eventRecord, activeDate);
    if (fromOverflow) {
      if (eventElement) {
        fromOverflow = false;
      } else {
        eventElement = _overflowPopup.getEventElement(eventRecord);
      }
    }
    if (eventRecord.isCreating) {
      var _client$onEventCreate;
      (_client$onEventCreate = client.onEventCreated) === null || _client$onEventCreate === void 0 ? void 0 : _client$onEventCreate.call(client, eventRecord);
    }
    if (!eventElement && view.isEventList) {
      var _view, _view$rowManager, _view$rowManager$getR;
      eventElement = (_view = view) === null || _view === void 0 ? void 0 : (_view$rowManager = _view.rowManager) === null || _view$rowManager === void 0 ? void 0 : (_view$rowManager$getR = _view$rowManager.getRowFor(eventRecord)) === null || _view$rowManager$getR === void 0 ? void 0 : _view$rowManager$getR.element;
    }
    const scrollingAllowed = eventElement && !DomHelper.isInView(eventElement) || !eventRecord.isCreating || !eventAdded;
    if (fromOverflow) {
      eventElement.focus();
    } else if (eventElement) {
      var _view$scrollable;
      if (scrollingAllowed && (_view$scrollable = view.scrollable) !== null && _view$scrollable !== void 0 && _view$scrollable.hasOverflow()) {
        var _view$scrollable2;
        await ((_view$scrollable2 = view.scrollable) === null || _view$scrollable2 === void 0 ? void 0 : _view$scrollable2.scrollIntoView(eventElement, {
          animate: true,
          focus: true
        }));
      } else {
        DomHelper.focusWithoutScrolling(eventElement);
      }
    } else {
      if (!view.isAllDayEvent(eventRecord) && view.hiddenNonWorkingDays[eventRecord.startDate.getDay()]) {
        me.internalShowEditor(eventRecord, null, {
          target: true
        });
        return;
      }
      if (scrollingAllowed) {
        await view.scrollTo(eventRecord);
      } else {
        await view.await("refresh", false);
      }
      eventElement = view.getEventElement(eventRecord);
    }
    if (!eventElement && !element && view.isDayCellRenderer) {
      eventElement = view.getCell(eventRecord.startDate);
    }
    me.internalShowEditor(eventRecord, null, {
      target: eventElement || element,
      allowTargetOut: view.isAnimating
    });
    if ((_me$editor = me.editor) !== null && _me$editor !== void 0 && _me$editor.lastAlignSpec) {
      me.editor.lastAlignSpec.allowTargetOut = false;
    }
  }
  async onSaveClick() {
    const me = this, {
      eventRecord
    } = me, {
      isCreating
    } = eventRecord.meta;
    if (me.isValid) {
      eventRecord.isCreating = false;
    }
    const saved = await super.onSaveClick(...arguments);
    if (isCreating && saved) {
      var _me$client$crudManage;
      me.eventStore.added.add(eventRecord);
      if (!me.eventStore.usesSingleAssignment) {
        me.assignmentStore.added.add(eventRecord.assignments);
      }
      if ((_me$client$crudManage = me.client.crudManager) !== null && _me$client$crudManage !== void 0 && _me$client$crudManage.autoSync) {
        me.client.crudManager.scheduleAutoSync();
      }
    }
  }
  internalShowEditor() {
    var _client$activeView$au, _client$activeView, _client$features$even, _client$features$even2;
    const {
      client,
      startTimeField,
      endTimeField,
      editor
    } = this, autoCreate = (_client$activeView$au = (_client$activeView = client.activeView) === null || _client$activeView === void 0 ? void 0 : _client$activeView.autoCreate) !== null && _client$activeView$au !== void 0 ? _client$activeView$au : client.autoCreate || client.constructor.configurable.autoCreate, step = autoCreate === null || autoCreate === void 0 ? void 0 : autoCreate.step, {
      activeSubView
    } = client, _overflowPopup = activeSubView === null || activeSubView === void 0 ? void 0 : activeSubView._overflowPopup;
    (_client$features$even = client.features.eventTooltip) === null || _client$features$even === void 0 ? void 0 : (_client$features$even2 = _client$features$even._tooltip) === null || _client$features$even2 === void 0 ? void 0 : _client$features$even2.hide();
    editor.owner = _overflowPopup !== null && _overflowPopup !== void 0 && _overflowPopup.isVisible ? _overflowPopup : activeSubView;
    if (super.internalShowEditor(...arguments) === false) {
      editor.owner = editor.initialConfig.owner;
      return;
    }
    if (step) {
      startTimeField && (startTimeField.step = step);
      endTimeField && (endTimeField.step = step);
    }
  }
};
CalendarFeature.register(EventEdit.type, EventEdit);
EventEdit._$name = "EventEdit";
var hasEventStore$2 = (w) => w.eventStore;
var EventMenu = class extends EventMenu$1 {
  static get $name() {
    return "EventMenu";
  }
  static get type() {
    return "eventMenu";
  }
  populateEventMenu({
    items: items2,
    eventRecord,
    assignmentRecord
  }) {
    super.populateEventMenu(...arguments);
    const {
      client
    } = this;
    items2.duplicate = {
      disabled: eventRecord.readOnly || (assignmentRecord === null || assignmentRecord === void 0 ? void 0 : assignmentRecord.readOnly),
      hidden: client.readOnly
    };
  }
  getDataFromEvent(event) {
    const {
      client
    } = this, {
      activeView
    } = client;
    if (activeView.isScheduler) {
      this.client = activeView;
    }
    const result = super.getDataFromEvent(event);
    this.client = client;
    return result;
  }
  changeMenu() {
    const me = this, result = super.changeMenu(...arguments);
    result === null || result === void 0 ? void 0 : result.ion({
      beforeShow({
        source
      }) {
        const {
          activeSubView
        } = me.client, {
          _overflowPopup
        } = activeSubView;
        source.owner = _overflowPopup !== null && _overflowPopup !== void 0 && _overflowPopup.containsFocus ? _overflowPopup : activeSubView;
      }
    });
    return result;
  }
  changeItems(items2) {
    items2 = super.changeItems(...arguments);
    items2.unassignEvent = null;
    return items2;
  }
};
_defineProperty(EventMenu, "configurable", {
  items: {
    duplicate: {
      text: "L{EventMenu.duplicateEvent}",
      icon: "b-icon b-icon-copy",
      weight: 400,
      onItem({
        eventRecord
      }) {
        const dupe = eventRecord.copy(null, {
          skipFieldIdentifiers: true
        }), {
          eventStore
        } = this.up(hasEventStore$2), {
          resources
        } = eventRecord;
        dupe.name = `${eventRecord.name} (${this.L("copy")})`;
        dupe.recurrence = null;
        if (resources !== null && resources !== void 0 && resources.length) {
          eventStore.assignmentStore.assignEventToResource(dupe, resources);
        }
        eventStore.add(dupe);
      }
    }
  }
});
CalendarFeature.register(EventMenu.type, EventMenu);
EventMenu._$name = "EventMenu";
var hasEventStore$1 = (w) => w.eventStore;
var ownConfigs = ["activeElement", "client", "clientListeners", "disabled", "showOn", "tooltip"];
var EventTooltip = class extends CalendarFeature {
  static get $name() {
    return "EventTooltip";
  }
  static get type() {
    return "eventTooltip";
  }
  static get configurable() {
    return {
      showOn: "click",
      closable: true,
      axisLock: "flexible",
      tooltip: {
        $config: ["lazy", "nullify"],
        value: {
          type: "eventTip",
          align: {
            monitorResize: true
          }
        }
      },
      titleRenderer: (eventRecord) => StringHelper.encodeHtml(eventRecord.name),
      renderer: null,
      recurrenceConfirmation: {
        $config: ["lazy", "nullify"],
        value: {
          type: "recurrenceconfirmation"
        }
      },
      extendAllDayEndDay: null,
      align: null
    };
  }
  static get pluginConfig() {
    return {
      chain: ["render"]
    };
  }
  get isVisible() {
    return true;
  }
  changeRecurrenceConfirmation(recurrenceConfirmation, existingInstance) {
    if (recurrenceConfirmation) {
      recurrenceConfirmation.rootElement = this.owner.rootElement;
    }
    return Widget.reconfigure(existingInstance, recurrenceConfirmation, {
      owner: this
    });
  }
  changeTooltip(config, existingInstance) {
    return Widget.reconfigure(existingInstance, config, {
      owner: this,
      setup: "setupTooltip"
    });
  }
  setupTooltip(config) {
    const me = this, ret = me.config;
    ownConfigs.forEach((c) => delete ret[c]);
    return EventTip.mergeConfigs(ret, {
      ownerFeature: me,
      id: `${me.client.id}-event-tip`,
      forSelector: me.showOn === "hover" && ".b-cal-event-wrap:not(.b-editing)",
      cls: {
        "b-eventedit": me.client.features.eventEdit
      },
      disabled: me.disabled,
      internalListeners: {
        thisObj: me,
        delete: "onDeleteClick",
        edit: "onEditClick",
        pointerOver: "onTipPointerOver"
      }
    }, config);
  }
  render() {
    const me = this, clientListeners = {
      eventsPerCellChange: "onClientEventsPerCellChange",
      navigate: "onClientNavigate",
      thisObj: me
    };
    if (me.showOn === "hover") {
      me.getConfig("tooltip");
    } else {
      clientListeners[`event${me.showOn}`] = "onClientTooltipGesture";
    }
    me.client.ion(clientListeners);
  }
  get owner() {
    var _this$client$activeVi;
    if ((_this$client$activeVi = this.client.activeView._overflowPopup) !== null && _this$client$activeVi !== void 0 && _this$client$activeVi.containsFocus) {
      return this.client.activeView.overflowPopup;
    } else {
      return this.client;
    }
  }
  addListener(...args) {
    var _this$tooltip;
    (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.addListener(...args);
  }
  removeListener(...args) {
    var _this$tooltip2;
    (_this$tooltip2 = this.tooltip) === null || _this$tooltip2 === void 0 ? void 0 : _this$tooltip2.removeListener(...args);
  }
  onEditClick() {
    var _activeClient$feature, _overflowPopup$elemen;
    const {
      client,
      activeClient,
      tooltip
    } = this, {
      overflowPopup
    } = activeClient, eventEdit = (activeClient === null || activeClient === void 0 ? void 0 : (_activeClient$feature = activeClient.features) === null || _activeClient$feature === void 0 ? void 0 : _activeClient$feature.eventEdit) || client.features.eventEdit, fromPopup = overflowPopup === null || overflowPopup === void 0 ? void 0 : (_overflowPopup$elemen = overflowPopup.element) === null || _overflowPopup$elemen === void 0 ? void 0 : _overflowPopup$elemen.contains(tooltip.activeTarget), target = fromPopup ? overflowPopup.targetCell : tooltip.activeTarget;
    if (eventEdit && !eventEdit.disabled) {
      eventEdit.editEvent(this.eventRecord, null, target);
      tooltip.hide();
    }
  }
  onDeleteClick() {
    this.activeClient.calendar.removeEvents([this.eventRecord], () => {
      var _this$tooltip3;
      return (_this$tooltip3 = this.tooltip) === null || _this$tooltip3 === void 0 ? void 0 : _this$tooltip3.hide();
    }, this.tooltip);
  }
  onClientEventsPerCellChange() {
    var _this$_tooltip, _this$_tooltip2;
    (_this$_tooltip = this._tooltip) === null || _this$_tooltip === void 0 ? void 0 : _this$_tooltip.requestAnimationFrame((_this$_tooltip2 = this._tooltip) === null || _this$_tooltip2 === void 0 ? void 0 : _this$_tooltip2.hide);
  }
  onClientNavigate(navEvent) {
    var _navEvent$event;
    const {
      _tooltip
    } = this;
    if (_tooltip !== null && _tooltip !== void 0 && _tooltip.activeTarget && (!this.owner.owns(navEvent.event) || navEvent.item !== _tooltip.activeTarget) && !_tooltip.owns((_navEvent$event = navEvent.event) === null || _navEvent$event === void 0 ? void 0 : _navEvent$event.relatedTarget)) {
      _tooltip.hide();
    }
  }
  onClientTooltipGesture({
    domEvent,
    event,
    eventElement,
    eventRecord,
    source: owningCalendarWidget
  }) {
    const {
      tooltip
    } = this;
    domEvent = domEvent || event;
    if (this.onTipPointerOver({
      event: domEvent,
      target: eventElement,
      eventRecord,
      owningCalendarWidget
    }) !== false) {
      if (eventElement.classList.contains("b-cal-in-cluster") && parseAlign(tooltip.align.align).edgeAligned === 2) {
        tooltip.setTimeout({
          fn: "showByEvent",
          args: [domEvent, eventElement],
          delay: 130
        });
      } else {
        tooltip.showByEvent(domEvent, eventElement);
      }
    }
  }
  onTipPointerOver({
    target,
    owningCalendarWidget,
    eventRecord
  }) {
    var _this$client$features, _this$client$features2;
    if (!owningCalendarWidget) {
      var _Widget$fromElement;
      owningCalendarWidget = (_Widget$fromElement = Widget.fromElement(target)) === null || _Widget$fromElement === void 0 ? void 0 : _Widget$fromElement.closest(hasEventStore$1);
    }
    if (!eventRecord) {
      eventRecord = owningCalendarWidget.getEventRecord(target);
    }
    if ((_this$client$features = this.client.features) !== null && _this$client$features !== void 0 && (_this$client$features2 = _this$client$features.eventEdit) !== null && _this$client$features2 !== void 0 && _this$client$features2.isEditing) {
      return false;
    }
    if (owningCalendarWidget) {
      this.tooltip.activeTarget = target;
      this.activeClient = owningCalendarWidget;
      eventRecord = owningCalendarWidget.getEventRecord(target);
      this.tooltip.eventRecord = this.eventRecord = eventRecord;
    }
    return eventRecord != null;
  }
  updateDisabled(disabled, was) {
    super.updateDisabled(disabled, was);
    if (this._tooltip) {
      this._tooltip.disabled = disabled;
    }
  }
};
EventTooltip.initClass();
EventTooltip._$name = "EventTooltip";
var oneHour = {
  magnitude: 1,
  unit: "hour"
};
var ExternalZone = class extends Base$1.mixin(Draggable) {
  static get configurable() {
    return {
      dragItemSelector: ".b-grid-row",
      droppable: false,
      dragProxy: {
        type: "default",
        open(drag) {
          return this.owner.owner.openProxy(drag);
        },
        dragMove(drag) {
          return this.owner.owner.moveProxy(drag);
        },
        close() {
          var _this$owner$owner$pro;
          (_this$owner$owner$pro = this.owner.owner.proxyEl) === null || _this$owner$owner$pro === void 0 ? void 0 : _this$owner$owner$pro.remove();
        }
      }
    };
  }
  beforeDrag(drag) {
    return this.owner.onDragStart(drag);
  }
};
var ExternalEventSource = class extends CalendarFeature.mixin(Delayable) {
  static get $name() {
    return "ExternalEventSource";
  }
  static get delayable() {
    return {
      onCalendarPaint: "raf"
    };
  }
  static get type() {
    return "externalEventSource";
  }
  static get configurable() {
    return {
      grid: {
        $config: ["lazy"],
        value: null
      },
      dragRootElement: null,
      dragItemSelector: null,
      getRecordFromElement: function(element) {
        const grid = this.grid || (this.grid = Widget.fromElement(element, "grid"));
        if (grid) {
          return grid.getRecordFromElement(element);
        }
        return element.innerText;
      },
      hideExternalProxy: true,
      draggable: {
        $config: ["lazy"],
        value: {}
      }
    };
  }
  onCalendarPaint({
    firstPaint
  }) {
    if (firstPaint) {
      this.getConfig("draggable");
    }
  }
  onDragStart(drag) {
    var _me$grid;
    const me = this, {
      client
    } = me, {
      eventStore
    } = client, {
      modelClass
    } = eventStore;
    if (!drag.itemElement) {
      return false;
    }
    let eventRecord = me.callback(me.getRecordFromElement, me, [drag.itemElement]);
    if (eventRecord.isModel) {
      if (!eventRecord.isEventModel) {
        eventRecord = eventStore.createRecord(eventRecord.data);
      }
    } else {
      if (typeof eventRecord === "string") {
        const autoCreate = client.activeView.autoCreate || client.autoCreate, duration = DateHelper.parseDuration((autoCreate === null || autoCreate === void 0 ? void 0 : autoCreate.duration) || oneHour);
        eventRecord = {
          [modelClass.getFieldDataSource("name")]: eventRecord,
          [modelClass.getFieldDataSource("duration")]: duration.magnitude,
          [modelClass.getFieldDataSource("durationUnit")]: duration.unit
        };
      }
      eventRecord = eventStore.createRecord(eventRecord);
    }
    drag.set("sourceStore", (_me$grid = me.grid) === null || _me$grid === void 0 ? void 0 : _me$grid.store);
    drag.set("eventRecord", eventRecord);
  }
  openProxy(drag) {
    const {
      grid
    } = this, sourceEl = drag.element.closest(this.draggable.dragItemSelector), nameCell = sourceEl.querySelector('[data-column="name"]'), proxyEl = this.proxyEl = DomHelper.createElement({
      className: "b-grid-to-cal-drag-proxy"
    });
    proxyEl.innerHTML = nameCell ? nameCell.innerHTML : drag.peek("eventRecord").name;
    this.proxyOffset = EventHelper.getClientPoint(drag.startEvent).getDelta(Rectangle.from(sourceEl));
    ((grid === null || grid === void 0 ? void 0 : grid.element) || this.dragRootElement).parentNode.appendChild(proxyEl);
  }
  moveProxy(drag) {
    const {
      proxyEl
    } = this;
    if (proxyEl) {
      if (this.client.owns(drag.targetElement) && this.hideExternalProxy) {
        proxyEl.classList.add("b-hide-display");
      } else {
        proxyEl.classList.remove("b-hide-display");
        DomHelper.alignTo(proxyEl, EventHelper.getClientPoint(drag.event).translate(10, 10), {
          align: "t0-t0"
        });
      }
    }
  }
  changeDragRootElement(dragRootElement) {
    if (typeof dragRootElement === "string") {
      dragRootElement = document.querySelector(dragRootElement) || document.getElementById(dragRootElement);
    }
    return dragRootElement;
  }
  changeDraggable(draggable) {
    const {
      grid
    } = this, dragRootElement = (grid === null || grid === void 0 ? void 0 : grid.contentElement) || this.dragRootElement, {
      dragItemSelector
    } = this;
    draggable = ExternalEventSource.mergeConfigs({
      owner: this,
      grid
    }, draggable);
    if (dragRootElement) {
      draggable.dragRootElement = dragRootElement;
    }
    if (dragItemSelector) {
      draggable.dragItemSelector = dragItemSelector;
    }
    return new ExternalZone(draggable);
  }
  changeGrid(grid) {
    if (typeof grid === "string") {
      grid = Widget.getById(grid);
    }
    return grid;
  }
};
ExternalEventSource.initClass();
ExternalEventSource._$name = "ExternalEventSource";
var LoadOnDemand = class extends CalendarFeature {
  static get configurable() {
    return {
      startDateParamName: "startDate",
      endDateParamName: "endDate",
      dateFormat: "YYYY-MM-DD",
      beforeRequest: null,
      alwaysLoadNewRange: null,
      clearOnNewRange: null
    };
  }
  construct(config) {
    const {
      client
    } = config;
    client.ion({
      dateRangeRequested: "onClientDateRangeRequested",
      thisObj: this
    });
    client.crudManager.ion({
      beforeLoadApply: "onCrudManagerBeforeApply",
      thisObj: this,
      prio: 9999
    });
    super.construct(...arguments);
  }
  hasOutstandingLoadFor(startDate, endDate) {
    const {
      load
    } = this.client.crudManager.activeRequests;
    if (load) {
      var _load$options;
      const otherDateRangeRequested = (_load$options = load.options) === null || _load$options === void 0 ? void 0 : _load$options.dateRangeRequested;
      if (otherDateRangeRequested && DateHelper.timeSpanContains(otherDateRangeRequested.startDate, otherDateRangeRequested.endDate, startDate, endDate)) {
        return true;
      }
    }
  }
  onCrudManagerBeforeApply({
    response,
    options
  }) {
    this.lastRangeLoaded = response.success && (options === null || options === void 0 ? void 0 : options.dateRangeRequested);
  }
  onClientDateRangeRequested({
    new: {
      startDate,
      endDate
    },
    changed
  }) {
    const me = this, {
      client
    } = me;
    if (!changed && me.alwaysLoadNewRange) {
      return;
    }
    if (changed) {
      DomHelper.addTemporaryClass(client.element, "b-notransition", 100, client);
      if (me.clearOnNewRange) {
        client.eventStore.clear(true);
        me.lastRangeLoaded = null;
      }
    }
    const {
      lastRangeLoaded
    } = me;
    if (lastRangeLoaded && !me.alwaysLoadNewRange) {
      const {
        startDate: lastStartDate,
        endDate: lastEndDate
      } = me.lastRangeLoaded;
      if (DateHelper.timeSpanContains(lastStartDate, lastEndDate, startDate, endDate)) {
        return;
      }
    }
    if (!me.disabled && !me.hasOutstandingLoadFor(startDate, endDate)) {
      me.loadDateRange(startDate, endDate);
    }
  }
  refresh() {
    const {
      lastRangeLoaded
    } = this;
    if (lastRangeLoaded) {
      this.loadDateRange(lastRangeLoaded.startDate, lastRangeLoaded.endDate);
    }
  }
  loadDateRange(startDate, endDate) {
    const me = this, {
      pendingLoad
    } = me;
    if (pendingLoad) {
      pendingLoad.startDate = DateHelper.min(startDate, pendingLoad.startDate);
      pendingLoad.endDate = DateHelper.max(endDate, pendingLoad.endDate);
    } else {
      me.pendingLoad = {
        startDate,
        endDate
      };
      me.client.requestAnimationFrame(() => me.load());
    }
  }
  async load() {
    const me = this, {
      client,
      beforeRequest,
      dateFormat
    } = me, {
      crudManager
    } = client, {
      load
    } = crudManager.activeRequests, {
      startDate,
      endDate
    } = me.pendingLoad;
    const options = {
      dateRangeRequested: me.pendingLoad,
      request: {
        params: {
          [me.startDateParamName]: DateHelper.format(startDate, dateFormat),
          [me.endDateParamName]: DateHelper.format(endDate, dateFormat)
        }
      }
    };
    me.pendingLoad = null;
    if (beforeRequest) {
      me.callback(beforeRequest, client, [options]);
    }
    if (load) {
      if (me.hasOutstandingLoadFor(startDate, endDate)) {
        return;
      }
      try {
        await crudManager.cancelRequest(load.desc, load.reject);
      } catch (e) {
      }
    }
    try {
      await crudManager.load(options);
    } catch (e) {
      if (!client.isDestroyed && client.trigger("loadOnDemandFail", e) !== false) {
        MessageDialog.alert({
          title: client.L("L{Calendar.loadFail}"),
          message: e.message
        });
      }
    }
    !client.isDestroyed && client.trigger("dateRangeLoad", {
      startDate,
      endDate
    });
  }
};
_defineProperty(LoadOnDemand, "$name", "LoadOnDemand");
_defineProperty(LoadOnDemand, "type", "loadOnDemand");
LoadOnDemand.initClass();
LoadOnDemand._$name = "LoadOnDemand";
var Printer = class extends Exporter {
  restoreState({
    client
  }) {
  }
  saveState({
    client
  }) {
  }
  cloneElement(element, target = this.element, clear = true) {
    if (clear) {
      target.innerHTML = "";
    }
    target.appendChild(element.cloneNode(true));
  }
  pageTpl(data) {
    const {
      config,
      title,
      header,
      footer,
      styles,
      htmlClasses,
      bodyStyle,
      bodyClasses = [`b-${this.constructor.type}`, ...this.owner.bodyClasses, ...Widget.outerCls],
      paperHeight,
      paperWidth,
      html
    } = data, afterPrint = BrowserHelper.isSafari ? "" : "window.removeElement && window.removeElement();", script = !(config !== null && config !== void 0 && config.debug) ? `<script type="text/javascript">window.addEventListener('load', function() { window.print(); ${afterPrint} });<\/script>` : "";
    return TemplateHelper.tpl`
            <!DOCTYPE html>
            <html class="${htmlClasses}" style="width: ${paperWidth}in; height: ${paperHeight}in;">
                <head>
                    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
                    <title>${title}</title>
                    ${styles.join("")}
                </head>
                <body class="b-print ${bodyClasses.join(" ")}" style="width: ${paperWidth}in; height: ${paperHeight}in; ${bodyStyle}">
                    <div class="b-print-content">
                        ${header && `<div class="b-print-header" style="width: 100%">${header}</div>`}
                        <div class="b-print-body"><div class="b-print-viewport">${html}</div></div>
                        ${footer && `<div class="b-print-footer" style="width: 100%">${footer}</div>`}
                    </div>
                    ${script}
                </body>
            </html>`;
  }
};
Printer._$name = "Printer";
var bigNumberProperty = {
  configurable: true,
  get: () => Number.MAX_SAFE_INTEGER
};
var CalendarPrinter = class extends Printer {
  static get $name() {
    return "CalendarPrinter";
  }
  static get type() {
    return "calendar";
  }
  getTotalHeight(client) {
    const {
      activeView
    } = client;
    switch (client.mode) {
      case "agenda":
        return activeView.virtualScrollHeight;
      case "day":
        return activeView.dayContentElement.scrollHeight + activeView.alldayRowElement.offsetHeight;
      case "week":
        return activeView.dayContentElement.scrollHeight + activeView.alldayRowElement.offsetHeight;
      case "month":
        if (this.owner.wysiwyg) {
          return activeView.weeksElement.scrollHeight + activeView.weekdaysHeader.offsetHeight + 10;
        }
        break;
      case "year":
        return this.inchToPx(PaperFormat.A4.width);
    }
  }
  getTotalWidth(client) {
    switch (client.mode) {
      case "year":
        return this.inchToPx(PaperFormat.A4.height);
      default:
        return this.inchToPx(PaperFormat.A4.width);
    }
  }
  async prepareComponent(config) {
    const me = this, {
      owner
    } = me, {
      wysiwyg
    } = owner, shrinkwrapRowHeights = !wysiwyg, {
      client
    } = config, {
      activeView
    } = client;
    me.exportMeta = {
      title: owner.callback(owner.titleRenderer, owner, [activeView]),
      totalWidth: me.getTotalWidth(client),
      totalHeight: me.getTotalHeight(client),
      subGrids: {}
    };
    if (client.mode === "month" && shrinkwrapRowHeights) {
      Object.defineProperty(activeView, "eventsPerCell", bigNumberProperty);
      activeView.doRefresh();
    }
    me.cloneElement(activeView.currentElement);
    if (client.mode === "month") {
      let rowHeights;
      if (shrinkwrapRowHeights) {
        rowHeights = activeView.shrinkwrapRowHeights;
        delete activeView.eventsPerCell;
        activeView.doRefresh();
        me.exportMeta.totalHeight = activeView.weekdaysHeader.offsetHeight + rowHeights.reduce((sum, r) => {
          return sum + r;
        }, 5);
      }
      activeView.weekElements.forEach((el, i) => {
        const clonedElement = me.element.querySelector(`[data-week="${el.dataset.week}"]`);
        clonedElement.style.minHeight = "";
        if (shrinkwrapRowHeights) {
          clonedElement.style.flex = `0 0 ${rowHeights[i]}px`;
        } else if (wysiwyg) {
          clonedElement.style.flex = `1 0 ${el.offsetHeight}px`;
        } else {
          clonedElement.style.flex = `1 0 ${250 / 6}mm`;
        }
      });
    }
  }
  pxToInch(value) {
    return (value / 96).toFixed(2);
  }
};
CalendarPrinter.prototype.pagesExtractor = async function* pagesExtractor5(config) {
  const me = this, {
    totalHeight,
    totalWidth,
    title
  } = me.exportMeta;
  yield {
    html: me.pageTpl({
      config,
      title,
      html: me.prepareExportElement(),
      styles: me.stylesheets,
      paperWidth: me.pxToInch(totalWidth),
      paperHeight: me.pxToInch(totalHeight)
    })
  };
};
CalendarPrinter._$name = "CalendarPrinter";
var emptyArray = Object.freeze([]);
var Print = class extends CalendarFeature {
  static get $name() {
    return "Print";
  }
  static get type() {
    return "print";
  }
  static get configurable() {
    return {
      printer: {
        $config: ["lazy", "nullify"],
        value: {
          type: "calendar"
        }
      },
      wysiwyg: false,
      titleRenderer: (activeView) => activeView.description,
      printers: /* @__PURE__ */ new Map([[CalendarPrinter.type, CalendarPrinter]])
    };
  }
  construct() {
    super.construct(...arguments);
    this.client.print = this.print.bind(this);
  }
  changePrinter(config) {
    const me = this, printersMap = me.printersMap || (me.printersMap = /* @__PURE__ */ new Map());
    if (config) {
      let printer;
      const {
        type
      } = config;
      if (printersMap.has(type)) {
        printer = printersMap.get(type);
        printer.setConfig(config);
      } else {
        const printerClass = me.printers.get(type);
        if (!printerClass) {
          throw new Error(`Printer type ${type} is not found. Make sure you've configured it`);
        }
        config = ObjectHelper.clone(config);
        config.owner = me;
        printer = new printerClass(config);
        printer.relayAll(me);
        printersMap.set(type, printer);
      }
      return printer;
    } else {
      printersMap.forEach((printer) => printer.destroy());
    }
  }
  get bodyClasses() {
    if (this.shrinkwrapRowHeights) {
      return ["b-shrinkwrap-row-heights"];
    }
    return emptyArray;
  }
  async print(config = {}) {
    const me = this, {
      client,
      printer
    } = me, iframeId = `${client.id}-print-iframe`;
    if (client.trigger("beforePrint", {
      config,
      printer
    }) !== false) {
      config.client = client;
      const pages = await me.printer.export(config);
      if (config.debug) {
        client.trigger("print", pages);
      } else {
        var _document$getElementB;
        (_document$getElementB = document.getElementById(iframeId)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.remove();
        const iframe = DomHelper.createElement({
          id: iframeId,
          class: "b-calendar-print-iframe",
          tag: "iframe",
          parent: document.body
        });
        iframe.contentWindow.removeElement = () => {
          iframe.remove();
          client.trigger("print", pages);
        };
        iframe.contentWindow.document.write(pages[0].html);
        iframe.contentWindow.document.close();
        return pages;
      }
    }
  }
};
Print.initClass();
Print._$name = "Print";
var ScheduleMenu = class extends ScheduleMenu$1 {
  static get $name() {
    return "ScheduleMenu";
  }
  static get type() {
    return "scheduleMenu";
  }
  getDataFromEvent(event) {
    const {
      client
    } = this, {
      activeView
    } = client, resourceRecord = client.resolveResourceRecord(event) || client.defaultCalendar;
    if (activeView.isScheduler) {
      this.client = activeView;
    }
    const result = super.getDataFromEvent(event);
    if (!result.resourceRecord) {
      result.resourceRecord = resourceRecord;
    }
    this.client = client;
    return result;
  }
  shouldShowMenu({
    date: date2,
    targetElement
  }) {
    const {
      client
    } = this, {
      activeView
    } = client;
    if (activeView.isScheduler) {
      this.client = activeView;
      const result = super.shouldShowMenu(...arguments);
      this.client = client;
      return result;
    }
    return Boolean(date2 && !targetElement.closest(client.eventSelector));
  }
};
CalendarFeature.register(ScheduleMenu.type, ScheduleMenu);
ScheduleMenu._$name = "ScheduleMenu";
var noCalcRe = /^[+-]?\d+(?:\.\d+)?(?:%|px)?$/;
var LayoutDim = class {
  static from(value) {
    if (value == null) {
      return null;
    }
    if (value instanceof LayoutDim) {
      return value;
    }
    if (!(Array.isArray(value) || typeof value === "string" && isNaN(value))) {
      value = Number(value);
      value = value < 1 ? [value, 0] : [0, value];
    }
    return new LayoutDim(...value);
  }
  static get(value) {
    return LayoutDim.from(value) || LayoutDim.ZERO;
  }
  constructor(ratio, delta) {
    this.r = ratio;
    this.d = delta;
  }
  add(v) {
    v = LayoutDim.from(v);
    return v ? new LayoutDim(this.r + v.r, this.d + v.d) : this;
  }
  adjust(r, d) {
    this.r += r || 0;
    this.d += d || 0;
    return this;
  }
  freeze() {
    return Object.freeze(this);
  }
  px(range) {
    return this.r * (range || 100) + this.d;
  }
  sub(v) {
    v = LayoutDim.from(v);
    return v ? new LayoutDim(this.r - v.r, this.d - v.d) : this;
  }
  *[Symbol.iterator]() {
    yield "r";
    yield "d";
  }
  stringify() {
    const str = this.toString();
    return noCalcRe.test(str) ? str : `calc(${str})`;
  }
  toString() {
    const {
      r,
      d
    } = this;
    let str;
    if (r) {
      str = DomHelper.percentify(r * 100);
      if (d) {
        str = `${str} + ${d}px`.replace("+ -", "- ");
      }
    } else {
      str = d ? `${d}px` : "0";
    }
    return str;
  }
};
LayoutDim.ZERO = new LayoutDim(0, 0).freeze();
LayoutDim._$name = "LayoutDim";
var genericRenderer = (renderData) => ({
  className: renderData.cls,
  style: renderData.style
});
var defaultRotation = {
  end: "pos",
  start: "neg"
};
var oppositeAlign = {
  end: "start",
  start: "end"
};
var valueFields = Object.entries({
  alignment: "alignment",
  color: "color",
  footer: "footer",
  header: "name",
  rotation: "rotation"
});
var DayZone = class extends CalendarZone {
  onBeforeLayoutEvents({
    source,
    context
  }) {
    const ranges = source.getTimeRanges(context.cellData.date, context.cellData.tomorrow);
    if (ranges.length) {
      const {
        layout
      } = context, footers = {}, headers = {}, clusters = [], items2 = [];
      let children, item;
      context.timeRangeHeaders = headers;
      context.timeRanges = ranges;
      for (const timeRange of ranges) {
        item = layout.createLayoutItem(timeRange, context);
        item.values = Object.fromEntries(valueFields.map(([name, fieldName]) => [name, timeRange[fieldName]]));
        item.values.rotation = item.values.rotation || defaultRotation[item.values.alignment];
        layout.clusterize(clusters, items2, item, context);
        children = context.dayDomConfig.children.inset;
        children = children.children || (children.children = []);
        children.push(this.renderTimeSpan(context, item, headers, footers));
      }
      if (headers.end || footers.end) {
        context.dayDomConfig.className["b-dayview-inset-after"] = 1;
      }
      if (headers.start || footers.start) {
        context.dayDomConfig.className["b-dayview-inset-before"] = 1;
      }
    }
  }
  renderPart(defaultRenderer, renderer, renderData, part, headerFooter, align, extraData) {
    var _defaultRenderer, _renderer, _defaultRenderer2;
    const isFooter = part === "footer", {
      record
    } = renderData, renderInfo = {
      timeRange: record
    };
    let data = renderData, domConfig, extraDom, value;
    if (typeof part === "string") {
      renderData[part] = data = ObjectHelper.merge({
        part,
        record,
        outer: renderData,
        cls: {
          [`b-cal-timerange-${part}`]: 1
        }
      }, extraData);
      value = renderData.values[part];
      if (value != null) {
        renderInfo.value = data.value = value;
      }
    } else {
      extraDom = part;
      part = "outer";
    }
    defaultRenderer = (_defaultRenderer = defaultRenderer) === null || _defaultRenderer === void 0 ? void 0 : _defaultRenderer[part];
    renderer = (_renderer = renderer) === null || _renderer === void 0 ? void 0 : _renderer[part];
    renderInfo.renderData = data;
    renderInfo.domConfig = extraDom;
    if (renderer) {
      data.style = {};
      const ret = renderer(renderInfo);
      if (typeof ret === "string") {
        extraDom = Object.assign({
          html: ret
        }, extraDom);
      } else if (ObjectHelper.isObject(ret)) {
        domConfig = ret;
      }
    }
    domConfig = domConfig || ((_defaultRenderer2 = defaultRenderer) === null || _defaultRenderer2 === void 0 ? void 0 : _defaultRenderer2(renderInfo));
    if (extraDom) {
      domConfig = ObjectHelper.merge(domConfig || {}, extraDom);
    }
    if (headerFooter && domConfig) {
      align = isFooter && oppositeAlign[align] || align;
      headerFooter[align] = (headerFooter[align] || 0) + 1;
    }
    data.domConfig = domConfig;
    return domConfig;
  }
  renderTimeSpan(context, item, headers, footers) {
    const me = this, {
      owner
    } = me, {
      defaultRenderer,
      renderer
    } = owner, timeRange = item.eventRecord, sizeSeconds = Math.abs(item.end - item.start), isRange = sizeSeconds > 1, isLine = !isRange, {
      rtl
    } = context.layout.owner, {
      values
    } = item, {
      alignment: align,
      color,
      rotation
    } = values, renderData = {
      color,
      values,
      record: timeRange,
      layoutContext: context,
      cls: {
        "b-readonly": timeRange.readOnly,
        "b-rtl": rtl,
        "b-cal-timerange": 1,
        "b-cal-timerange-line": isLine,
        "b-cal-timerange-narrow": isRange && sizeSeconds <= owner.narrowThreshold * 60,
        [`b-cal-timerange-align-${align}`]: align,
        [`b-cal-timerange-rotate-${rotation}`]: isRange && rotation
      }
    };
    isRange && item.height.adjust(0, -1);
    const styles = item.getStyles(rtl);
    return DomHelper.normalizeChildren(me.renderPart(defaultRenderer, renderer, renderData, {
      dataset: {
        "timerange-id": timeRange.id,
        btip: isLine && values.header || null
      },
      className: {
        [timeRange.cls]: timeRange.cls
      },
      elementData: {
        timeRange
      },
      style: {
        top: styles.top,
        height: styles.height
      },
      children: isRange && {
        header: me.renderPart(defaultRenderer, renderer, renderData, "header", headers, align, {
          cls: {
            [timeRange.iconCls]: timeRange.iconCls
          }
        }),
        body: me.renderPart(defaultRenderer, renderer, renderData, "body"),
        footer: me.renderPart(defaultRenderer, renderer, renderData, "footer", footers, align)
      }
    }));
  }
};
_defineProperty(DayZone, "$name", "DayZone");
_defineProperty(DayZone, "configurable", {
  viewListeners: {
    beforeLayoutEvents: "onBeforeLayoutEvents"
  }
});
var TimeRanges = class extends CalendarFeature.mixin(AttachToProjectMixin) {
  attachToProject(project) {
    var _project$timeRangeSto, _project$resourceTime;
    super.attachToProject(project);
    this.detachListeners("project");
    (_project$timeRangeSto = project.timeRangeStore) === null || _project$timeRangeSto === void 0 ? void 0 : _project$timeRangeSto.ion({
      name: "project",
      change: "refresh",
      thisObj: this
    });
    (_project$resourceTime = project.resourceTimeRangeStore) === null || _project$resourceTime === void 0 ? void 0 : _project$resourceTime.ion({
      name: "project",
      change: "refresh",
      thisObj: this
    });
  }
  changeRenderer(renderer) {
    if (typeof renderer === "function") {
      renderer = {
        header: renderer
      };
    }
    return renderer;
  }
  updateHeaderWidth(width) {
    var _this$owner;
    const el = (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.element;
    if (el) {
      var _LayoutDim$from;
      el.style.setProperty("--timerange-header-width", (_LayoutDim$from = LayoutDim.from(width)) === null || _LayoutDim$from === void 0 ? void 0 : _LayoutDim$from.toString());
    }
  }
  refresh() {
    this.client.queryAll((v) => v.isResourceView).forEach((v) => v.eachView("refresh"));
  }
};
_defineProperty(TimeRanges, "$name", "TimeRanges");
_defineProperty(TimeRanges, "type", "timeRanges");
_defineProperty(TimeRanges, "configurable", {
  defaultRenderer: {
    outer({
      renderData
    }) {
      var _renderData$header;
      const ret = genericRenderer(renderData), {
        color
      } = renderData;
      if (color) {
        if (DomHelper.isNamedColor(color)) {
          ret.className[`b-cal-color-${color}`] = 1;
        } else {
          (ret.style || (ret.style = {}))["--timerange-color"] = color;
        }
      }
      ret.className["b-cal-timerange-has-header"] = (_renderData$header = renderData.header) === null || _renderData$header === void 0 ? void 0 : _renderData$header.domConfig;
      return ret;
    },
    body: ({
      renderData
    }) => genericRenderer(renderData),
    header: ({
      renderData,
      value
    }) => value ? _objectSpread2(_objectSpread2({}, genericRenderer(renderData)), {}, {
      children: [{
        className: {
          "b-cal-timerange-header-text": 1
        },
        text: value
      }]
    }) : null,
    footer: ({
      renderData,
      value
    }) => value ? _objectSpread2(_objectSpread2({}, genericRenderer(renderData)), {}, {
      children: [{
        className: {
          "b-cal-timerange-footer-text": 1
        },
        text: value
      }]
    }) : null
  },
  headerWidth: 40,
  narrowThreshold: 60,
  renderer: null,
  zoneTypes: {
    day: DayZone,
    resource: DayZone
  }
});
CalendarFeature.register(TimeRanges.type, TimeRanges);
TimeRanges._$name = "TimeRanges";
var WeekExpander = class extends CalendarFeature {
  static get $name() {
    return "WeekExpander";
  }
  static get type() {
    return "weekExpander";
  }
  static get pluginConfig() {
    return {
      chain: ["render"]
    };
  }
  render() {
    const {
      client
    } = this, monthView = this.monthView = client.isMonthView ? client : client.modes.month;
    if (monthView) {
      const {
        weekRenderer
      } = this;
      monthView.showWeekColumn = true;
      monthView.weekRenderer = monthView.weekRenderer ? FunctionHelper.createSequence(monthView.weekRenderer, weekRenderer) : weekRenderer;
      monthView.ion({
        weeknumberclick: "onWeekNumberClick",
        thisObj: this,
        prio: 1e4
      });
    }
  }
  weekRenderer(parent, [year, week]) {
    if (!parent.querySelector(".b-week-toggle-tool-wrap")) {
      DomHelper.createElement({
        parent,
        className: "b-week-toggle-tool-wrap",
        children: [{
          className: "b-icon b-week-toggle-tool",
          dataset: {
            btip: this.L("L{WeekExpander.expandTip}")
          }
        }]
      });
    }
  }
  onWeekNumberClick({
    domEvent,
    date: date2
  }) {
    const toggleTool = domEvent.target.closest(".b-week-toggle-tool");
    if (toggleTool && !this.disabled) {
      const weekRow = domEvent.target.closest(".b-calendar-row");
      if (weekRow.classList.contains("b-shrinkwrapped")) {
        this.monthView.flexWeekRow(date2);
        toggleTool.dataset.btip = this.L("L{expandTip}");
      } else if (weekRow.classList.contains("b-has-overflow")) {
        this.monthView.shrinkwrapWeekRow(date2);
        toggleTool.dataset.btip = this.L("L{collapseTip}");
      }
      return false;
    }
  }
  updateDisabled(disabled, was) {
    super.updateDisabled(disabled, was);
    this.client.element.classList.toggle("b-weekexpander", !disabled);
  }
};
WeekExpander.initClass();
WeekExpander._$name = "WeekExpander";
var getStyles = function(rtl) {
  var _me$left, _me$width;
  const me = this;
  return {
    [rtl ? "right" : "left"]: (_me$left = me.left) === null || _me$left === void 0 ? void 0 : _me$left.stringify(),
    top: me.top.stringify(),
    width: (_me$width = me.width) === null || _me$width === void 0 ? void 0 : _me$width.stringify(),
    height: me.height.stringify(),
    minWidth: me.minWidth
  };
};
var DayLayout = class extends Base$1.mixin(Factoryable) {
  beforeLayoutEvents(context) {
    this.owner.trigger("beforeLayoutEvents", {
      context
    });
    return context;
  }
  clusterize(clusters, items2, item, context) {
    const cluster = clusters[clusters.length - 1] || null;
    items2.push(item);
    if (cluster && this.overlaps(cluster, item)) {
      item.cluster = cluster;
      cluster.end = Math.max(cluster.end, item.end);
      cluster.items.push(item);
    } else {
      clusters.push(item.cluster = {
        context,
        start: item.start,
        end: item.end,
        items: [item]
      });
    }
  }
  createLayoutContext(cellData, dayDomConfig) {
    const events = cellData === null || cellData === void 0 ? void 0 : cellData.events;
    return {
      cellData,
      dayDomConfig,
      events: (events === null || events === void 0 ? void 0 : events.length) > 1 ? cellData.dayTime.sortEvents(cellData.date, events.slice()) : events || [],
      clusters: [],
      items: [],
      layout: this
    };
  }
  layoutEvents(cellData, dayDomConfig) {
    const me = this, context = me.beforeLayoutEvents(me.createLayoutContext(cellData, dayDomConfig)), {
      clusters,
      events,
      items: items2
    } = context;
    let event, i, item, n;
    for (event of events) {
      item = me.createLayoutItem(event, context);
      me.clusterize(clusters, items2, item, context);
    }
    for (i = 0, n = clusters.length; i < n; ++i) {
      me.layoutCluster(clusters[i]);
    }
    me.owner.trigger("layoutEvents", {
      context
    });
    return context;
  }
  createLayoutItem(eventRecord, context) {
    const {
      date: date2,
      tomorrow,
      dayEnd,
      dayTime
    } = context.cellData, {
      allDay,
      startDate,
      endingDate
    } = eventRecord, startSec = allDay || startDate < date2 ? 0 : dayTime.delta(startDate, "s"), endSec = allDay || endingDate >= tomorrow ? dayEnd : dayTime.delta(endingDate, "s"), start = Math.max(startSec, 0), end = Math.min(endSec, dayEnd), top = LayoutDim.from(start / dayEnd);
    return {
      eventRecord,
      getStyles,
      start,
      end,
      top,
      id: eventRecord.id,
      height: new LayoutDim(end / dayEnd, 0).sub(top),
      startsBefore: startDate < date2 || startSec < 0,
      endsAfter: tomorrow < endingDate || endSec > dayEnd
    };
  }
  overlaps(a, b, tolerance, end) {
    var _tolerance;
    if (typeof tolerance === "string") {
      end = tolerance;
      tolerance = null;
    }
    end = end || "end";
    tolerance = (_tolerance = tolerance) !== null && _tolerance !== void 0 ? _tolerance : this.overlapTolerance * 60 || 0;
    return a.start < b[end] - tolerance && b.start < a[end] - tolerance;
  }
  syncGutter() {
    this.owner.setStyle("--dayview-cell-gutter", String(LayoutDim.get(this.gutter && this.gutterWidth)));
  }
  updateGutter() {
    this.syncGutter();
  }
  updateGutterWidth() {
    this.syncGutter();
  }
  updateInset(inset) {
    this.owner.setStyle("--dayview-cell-inset-size", String(LayoutDim.get(inset)));
  }
};
_defineProperty(DayLayout, "factoryable", {});
_defineProperty(DayLayout, "configurable", {
  gutter: true,
  gutterWidth: 5,
  inset: 40,
  overlapTolerance: null,
  owner: null
});
DayLayout._$name = "DayLayout";
var Packer = class extends PackMixin() {
  static get defaultConfig() {
    return {
      coordProp: "left",
      sizeProp: "width"
    };
  }
  pack(items2) {
    const wrappedItems = items2.map((item) => {
      const {
        startDate
      } = item.eventRecord, endDate = new Date(startDate);
      endDate.setSeconds(endDate.getSeconds() + item.maxEnd - item.start);
      return {
        item,
        start: startDate,
        end: endDate,
        x: 0
      };
    });
    this.packEventsInBands(wrappedItems, (itemData, clusterIndex, slot, slotSize) => {
      itemData.width = slotSize;
      itemData.w = slotSize * COLUMN_WIDTH;
      itemData.x += (itemData.left = slot.start + clusterIndex * slotSize) * COLUMN_WIDTH;
      itemData.item.x = itemData.x;
      itemData.item.w = itemData.w;
    });
  }
};
var COLUMN_WIDTH = 1e4;
var EMPTY = Object.freeze([]);
var packer = new Packer();
var FluidDayLayout = class extends DayLayout {
  createLayoutContext(cellData, dayDomConfig) {
    const me = this, context = super.createLayoutContext(cellData, dayDomConfig), {
      staggerWidth
    } = me;
    return Object.assign(context, {
      indentWidth: LayoutDim.get(me.indentWidth),
      stagger: new LayoutDim(),
      staggerMaximum: LayoutDim.from(me.staggerMaximum),
      staggerMinimum: me.staggerMinimum,
      staggerWidth: LayoutDim.from(staggerWidth === true ? me.gutterWidth : staggerWidth),
      stretch: me.stretch
    });
  }
  layoutCluster(cluster) {
    const me = this, {
      context,
      items: items2
    } = cluster, {
      indentWidth,
      stagger,
      staggerMaximum,
      staggerMinimum,
      staggerWidth,
      stretch
    } = context, treeLevels = me.treeify(items2);
    me._assignSizes(items2, treeLevels);
    for (const item of items2) {
      const depth = item.depth, left = new LayoutDim(), width = new LayoutDim(), root2 = item.majorParent || item;
      for (const k of stagger) {
        stagger[k] = staggerWidth[k] * (depth.height + depth.overlap);
        stagger[k] = staggerMaximum !== null && staggerMaximum !== void 0 && staggerMaximum[k] ? Math.min(staggerMaximum[k], stagger[k]) : stagger[k];
      }
      left.r = root2.x + depth.minor * indentWidth.r * root2.w;
      left.d = depth.minor * indentWidth.d;
      width.r = stretch ? 1 - left.r : root2.w - left.r + root2.x;
      width.d = -left.d;
      if (staggerMinimum) {
        item.minWidth = `calc(${staggerMinimum} * (${width}))`;
      }
      width.r -= stagger.r * root2.w;
      width.d -= stagger.d;
      item.left = left;
      item.width = width;
    }
  }
  treeify(items2) {
    const treeLevels = [];
    for (let i = 0; i < items2.length; i++) {
      this._addChild(items2[i], i, treeLevels);
    }
    return treeLevels;
  }
  _addChild(item, order, treeLevels) {
    const me = this, {
      clearanceMinutes,
      escapeMinutes,
      stretch
    } = me, clearanceSeconds = clearanceMinutes * 60, escapeSeconds = clearanceSeconds + escapeMinutes * 60, overlapTolerance = (me.overlapTolerance || 0) * 60, isMinor = (a, b) => Math.abs(b.start - a.start) >= clearanceSeconds, scoreFn = (item2) => item2.depth.minor * 10 + item2.depth.major * (stretch ? 1 : 0), depth = {
      depth: 0,
      height: 0,
      heightMajor: 0,
      overlap: 0,
      major: 0,
      minor: 0
    };
    item.parent = null;
    item.maxEnd = item.maxEndMajor = item.end;
    item.depth = depth;
    item.order = order;
    if (!treeLevels.length) {
      treeLevels[0] = item;
      item.barriers = EMPTY;
      return;
    }
    let best = 0, child, major, minor, p, parent, score;
    for (p of treeLevels) {
      child = p.lastItem || p;
      if (!me.overlaps(item, p, overlapTolerance, "maxEnd")) {
        parent = p.parent;
        major = true;
        break;
      }
      if (isMinor(item, child)) {
        minor = true;
        if (major) {
          major = false;
          parent = null;
        }
        for (; child !== p; child = child.parent) {
          if (me.overlaps(child, item, overlapTolerance)) {
            break;
          }
        }
        score = scoreFn(child);
        if (!parent || score < best) {
          parent = child;
          best = score;
        }
      } else if (!minor) {
        major = true;
        parent = p;
      }
    }
    if (major) {
      minor = 0;
      major = parent ? parent.depth.major + 1 : 0;
      p = parent = treeLevels[major - 1] || null;
    } else {
      p = parent.majorParent || parent;
      for (; escapeSeconds && parent !== p; parent = parent.parent) {
        if (me.overlaps(parent, item, overlapTolerance) && item.start - parent.start < escapeSeconds) {
          break;
        }
      }
      minor = parent.depth.minor + 1;
      major = parent.depth.major;
    }
    item.parent = parent;
    depth.major = major;
    depth.minor = minor;
    depth.depth = parent ? parent.depth.depth + 1 : 0;
    if (minor) {
      item.majorParent = p;
      item.previousItem = p.lastItem;
      p.lastItem = item;
    } else {
      me._addMajor(item, treeLevels);
    }
    me._adjustOverlap(item);
    me._adjustParents(item);
  }
  _addMajor(item, treeLevels) {
    const me = this, {
      stretch
    } = me, level = item.depth.major;
    treeLevels[level] = item;
    item.barriers = me._getOverlaps(treeLevels, item, 1);
    if (stretch || item.barriers.length) {
      for (const prior of me._getOverlaps(treeLevels, item, -1)) {
        const barriers = prior.barriers.filter((b) => !item.barriers.includes(b));
        if (stretch || barriers.length < prior.barriers.length) {
          prior.barriers = barriers;
          barriers.push(item);
        }
      }
    }
  }
  _adjustOverlap(item) {
    if (item.depth.minor) {
      let overlap, p;
      for (p = item; p.depth.minor > 1; p = p.parent) {
      }
      for (overlap = 0; p = p.previousItem; ) {
        if (this.overlaps(p, item)) {
          overlap = Math.max(overlap, p.depth.height + p.depth.overlap + 1);
        }
      }
      item.depth.overlap = overlap;
    }
  }
  _adjustParents(item) {
    const {
      depth,
      end
    } = item, level = depth.minor + depth.overlap;
    for (let parentDepth, p = item; p = p.parent; ) {
      parentDepth = p.depth;
      if (parentDepth.major !== depth.major) {
        parentDepth.heightMajor = Math.max(parentDepth.heightMajor, depth.major - parentDepth.major);
        continue;
      }
      p.maxEnd = Math.max(p.maxEnd, end);
      while (parentDepth.height < level - parentDepth.minor) {
        ++parentDepth.height;
        if (parentDepth.overlap) {
          --parentDepth.overlap;
        }
      }
    }
  }
  _assignSizes(items2, treeLevels) {
    const {
      complexityLimit,
      stretch
    } = this, topLevelItems = items2.filter((it) => !it.depth.minor);
    if (!complexityLimit) {
      packer.pack(topLevelItems);
      for (const item of topLevelItems) {
        item.x /= COLUMN_WIDTH;
        item.w /= COLUMN_WIDTH;
      }
    } else {
      for (const item of topLevelItems) {
        const paths = item.barriers.map((b) => [b]), {
          parent
        } = item, height = item.depth.heightMajor + 1;
        item.x = parent ? parent.x + parent.w : 0;
        let w = (1 - item.x) / height, i, include, longest, path, tail, v, x;
        if (paths.length) {
          for (i = 0; i < paths.length; ) {
            path = paths[i];
            longest = longest || path;
            if (i > complexityLimit) {
              w = 1 / treeLevels.length;
              break;
            }
            tail = path[path.length - 1];
            if (tail.order < item.order) {
              ++i;
              x = tail.x;
              include = 0;
            } else if (!tail.barriers.length) {
              ++i;
              x = 1;
              include = 1;
            } else {
              paths.splice(i, 1, ...tail.barriers.map((b) => path.concat(b)));
              if (longest === path) {
                longest = null;
              }
              continue;
            }
            v = (x - item.x) / (include + path.length);
            if (v < w) {
              w = v;
              longest = path;
            }
          }
          if (stretch) {
            v = longest.reduce((s, it) => s + it.depth.height + 1, 0);
            for (i = item.lastItem; i; i = i.previousItem) {
              i.depth.overlap += v;
            }
            item.depth.overlap += v;
          }
        }
        item.w = w;
      }
    }
  }
  _getOverlaps(treeLevels, item, step) {
    const {
      end
    } = item, stop = step < 0 ? -1 : treeLevels.length;
    let {
      start
    } = item, i, other, ret;
    for (i = item.depth.major + step; i !== stop && start < end; i += step) {
      other = treeLevels[i];
      if (start < other.maxEnd && other.start < end) {
        (ret || (ret = [])).push(other);
        start = other.maxEnd;
      }
    }
    return ret || EMPTY;
  }
};
_defineProperty(FluidDayLayout, "type", "fluid");
_defineProperty(FluidDayLayout, "configurable", {
  clearanceMinutes: 45,
  complexityLimit: 2e3,
  escapeMinutes: null,
  indentWidth: 10,
  staggerMaximum: null,
  staggerMinimum: 0.4,
  staggerWidth: true,
  stretch: null
});
FluidDayLayout.initClass();
FluidDayLayout._$name = "FluidDayLayout";
var CalendarStores = (Target) => {
  var _class;
  return _class = class CalendarStores extends ProjectConsumer(Target || Base$1) {
    static get projectStores() {
      return {
        resourceStore: {
          dataName: "resources",
          listeners: {
            changePreCommit: "onCalendarStoreChange"
          }
        },
        eventStore: {
          dataName: "events",
          listeners: {
            changePreCommit: "onCalendarStoreChange"
          }
        },
        assignmentStore: {
          dataName: "assignments"
        },
        timeRangeStore: {
          dataName: "timeRanges",
          modelClass: TimeRangeModel
        },
        resourceTimeRangeStore: {
          dataName: "resourceTimeRanges",
          modelClass: ResourceTimeRangeModel
        }
      };
    }
    changeCrudManager(crudManager) {
      var _me$bindCrudManager;
      const me = this;
      if (crudManager && !crudManager.isCrudManager) {
        const type = crudManager.type || me.crudManagerClass;
        crudManager = type.new({
          scheduler: me
        }, crudManager);
      }
      me._crudManager = crudManager;
      (_me$bindCrudManager = me.bindCrudManager) === null || _me$bindCrudManager === void 0 ? void 0 : _me$bindCrudManager.call(me, crudManager);
    }
    updateTimeZone(timeZone) {
      this.project.timeZone = timeZone;
    }
    onTimeZoneChange({
      timeZone,
      oldTimeZone
    }) {
      const me = this, target = me.isCalendar ? me.activeView : !me.calendar && me;
      if (target) {
        const date2 = oldTimeZone ? TimeZoneHelper.fromTimeZone(target.date, oldTimeZone) : target.date;
        (target.calendar || target).date = timeZone ? TimeZoneHelper.toTimeZone(date2, timeZone) : date2;
      }
    }
    get defaultCalendar() {
      const {
        eventStore
      } = this, defaultCalendar = ObjectHelper.hasOwn(this, "_defaultCalendar") ? this._defaultCalendar : eventStore.defaultCalendarId;
      if (defaultCalendar !== null) {
        return defaultCalendar != void 0 ? defaultCalendar.isResourceModel ? defaultCalendar : eventStore.resourceStore.getById(defaultCalendar) : eventStore.resourceStore.first;
      }
    }
    get defaultCalendarId() {
      return this.eventStore.modelClass.asId(this.defaultCalendar);
    }
    updateProject(project, oldProject) {
      super.updateProject(project, oldProject);
      this.getConfig("timeZone");
      this.detachListeners("CalendarStores");
      project.ion({
        name: "CalendarStores",
        dataReady: "onCalendarStoreChange",
        refresh: "onProjectRefresh",
        thisObj: this
      });
    }
    onProjectRefresh({
      source: project,
      isInitialCommit
    }) {
      if (isInitialCommit) {
        project.eventStore.invalidateDayIndices();
      }
    }
    updateEventStore(eventStore, oldEventStore) {
      if (oldEventStore) {
        delete oldEventStore.createRecord;
      }
      if (eventStore && !eventStore.isCalendarEventStore) {
        const storeOwner = this;
        Object.defineProperty(eventStore, "defaultCalendar", {
          get: () => storeOwner.defaultCalendar
        });
        eventStore.isCalendarEventStore = true;
      }
    }
    get widgetClass() {
    }
  }, _defineProperty(_class, "$name", "CalendarStores"), _defineProperty(_class, "configurable", {
    defaultCalendar: null,
    crudManagerClass: CrudManager,
    crudManager: null,
    timeZone: {
      $config: "lazy",
      value: null
    }
  }), _defineProperty(_class, "defaultConfig", {
    projectModelClass: ProjectModel
  }), _class;
};
var EventSlots = class extends Array {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "firstFreeSlot", 0);
  }
  set(index, event) {
    const me = this;
    if (index == null) {
      return me.add(event);
    } else {
      me[index] = event;
    }
    if (me.firstFreeSlot === index) {
      while (me[me.firstFreeSlot]) {
        me.firstFreeSlot++;
      }
    }
  }
  add(event) {
    const result = this.firstFreeSlot;
    this[result] = event;
    while (this[this.firstFreeSlot]) {
      this.firstFreeSlot++;
    }
    return result;
  }
  setEvents(events) {
    const length = this.length = this.firstFreeSlot = events.length;
    for (let i = 0; i < length; i++) {
      this[i] = events[i];
    }
  }
};
EventSlots._$name = "EventSlots";
var EventSorter = class extends Base$1 {
  static defaultSorterFn(event1, event2) {
    event1 = event1.eventRecord || event1;
    event2 = event2.eventRecord || event2;
    const {
      startDate: start1
    } = event1, {
      startDate: start2
    } = event2;
    if (!start1) {
      return -1;
    }
    if (!start2) {
      return 1;
    }
    return start1 - start2 || event2.durationMS - event1.durationMS;
  }
  static interDaySorterFn(event1, event2) {
    event1 = event1.eventRecord || event1;
    event2 = event2.eventRecord || event2;
    const {
      startDate: start1,
      isInterDay: event1InterDay
    } = event1, {
      startDate: start2,
      isInterDay: event2InterDay
    } = event2;
    if (!start1) {
      return -1;
    }
    if (!start2) {
      return 1;
    }
    if (event1InterDay !== event2InterDay) {
      return Number(event2InterDay) - Number(event1InterDay);
    }
    return start1 - start2 || event2.durationMS - event1.durationMS;
  }
};
EventSorter._$name = "EventSorter";
var hasEventStore = (w) => w.isCalendarMixin && w.eventStore;
var eventNameSplitter = /(touch|mouse|pointer|key|context|dbl)(.*)/;
var eventPartReplacer = (match, prefix, remainder) => `${StringHelper.capitalize(prefix)}${StringHelper.capitalize(remainder)}`;
var capitalizeEvent = (domEvent) => domEvent.type.replace(eventNameSplitter, eventPartReplacer);
var SchedulerInterface = (Target) => class SchedulerInterface extends (Target || Base$1) {
  static get $name() {
    return "SchedulerInterface";
  }
  calendarHitTest(domEvent) {
    const {
      activeView
    } = this, target = DomHelper.getEventElement(domEvent);
    return activeView !== null && activeView !== void 0 && activeView.element.contains(target) ? activeView.calendarHitTest(domEvent) : null;
  }
  get timeAxis() {
    const me = this;
    if (!me._timeAxis) {
      me._timeAxis = {
        get startDate() {
          return me.activeView.startDate;
        },
        get endDateDate() {
          return me.activeView.endDate;
        },
        isTimeSpanInAxis(event) {
          return DateHelper.intersectSpans(event.startDate, event.endDate, this.startDate, this.endDate);
        }
      };
    }
    return this._timeAxis;
  }
  get timeAxisViewModel() {
    const me = this;
    if (!me._timeAxisViewModel) {
      me._timeAxisViewModel = {
        get timeResolution() {
          return me.activeView.timeResolution || {};
        }
      };
    }
    return this._timeAxisViewModel;
  }
  resolveEventRecord(elementOrEvent) {
    var _this$constructor$fro;
    if (elementOrEvent instanceof Event) {
      elementOrEvent = elementOrEvent.target;
    }
    const activeClient = (_this$constructor$fro = this.constructor.fromElement(elementOrEvent)) === null || _this$constructor$fro === void 0 ? void 0 : _this$constructor$fro.closest(hasEventStore);
    return activeClient === null || activeClient === void 0 ? void 0 : activeClient.getEventRecord(elementOrEvent);
  }
  resolveAssignmentRecord() {
  }
  resolveResourceRecord(elementOrEvent) {
    var _this$resolveEventRec;
    const {
      activeView
    } = this;
    if (activeView.isResourceView) {
      const element = elementOrEvent.nodeType === Node.ELEMENT_NODE ? elementOrEvent : elementOrEvent.target, sourcePopup = element.closest(".b-overflowpopup"), subView = sourcePopup ? bryntum.fromElement(sourcePopup, "overflowpopup").owner : bryntum.fromElement(elementOrEvent, activeView.viewType.type);
      if (subView) {
        return subView.resource;
      }
    }
    return (_this$resolveEventRec = this.resolveEventRecord(elementOrEvent)) === null || _this$resolveEventRec === void 0 ? void 0 : _this$resolveEventRec.resource;
  }
  handleEvent(domEvent) {
    const eventName = capitalizeEvent(domEvent);
    if (super.handleEvent) {
      super.handleEvent(domEvent);
    } else if (!domEvent.handled && !domEvent.schedulerRedirected) {
      if (this.trigger(`beforeElement${eventName}`, {
        event: domEvent
      }) !== false) {
        var _this;
        (_this = this[`onElement${eventName}`]) === null || _this === void 0 ? void 0 : _this.call(this, domEvent);
      }
      domEvent.schedulerRedirected = true;
    }
  }
  onInternalKeyDown(domEvent) {
    var _this$onCalendarPoint;
    (_this$onCalendarPoint = this.onCalendarPointerInteraction) === null || _this$onCalendarPoint === void 0 ? void 0 : _this$onCalendarPoint.call(this, domEvent);
  }
  getCellDataFromEvent(domEvent) {
    var _super$getCellDataFro;
    return (_super$getCellDataFro = super.getCellDataFromEvent) === null || _super$getCellDataFro === void 0 ? void 0 : _super$getCellDataFro.call(this, domEvent);
  }
  getDateFromDomEvent(domEvent) {
    var _this$constructor$fro2;
    const activeClient = (_this$constructor$fro2 = this.constructor.fromElement(domEvent)) === null || _this$constructor$fro2 === void 0 ? void 0 : _this$constructor$fro2.closest(hasEventStore);
    if (activeClient) {
      return activeClient.getDateFromDomEvent(domEvent);
    }
  }
  createEvent() {
    this.activeView.createEvent(...arguments);
  }
  get enableRecurringEvents() {
    return true;
  }
  getRowFor() {
  }
  suspendRefresh() {
  }
  resumeRefresh() {
  }
  get widgetClass() {
  }
};
var emptyString = new String("");
var EventRenderer = (Target) => {
  var _class;
  return _class = class EventRenderer extends (Target || Base$1) {
    createEventDomConfig(renderData, eventRenderer = this.eventRenderer) {
      var _me$isAllDayEvent, _color, _renderData$iconCls;
      const me = this, {
        eventHeight,
        intradayCls,
        alldayCls,
        solidBarCls,
        pastEventCls,
        showTime,
        timeFormat,
        rtl
      } = me, calendar = me.up("calendar"), {
        eventRecord,
        minimal
      } = renderData, eventEndDate = renderData.eventEndDate || eventRecord.endingDate, resourceRecord = eventRecord.isOccurrence ? eventRecord.recurringEvent.resource : eventRecord.resource, isRecurring = eventRecord.isRecurring || eventRecord.isOccurrence, isAllDay = "isAllDay" in renderData ? renderData.isAllDay : (_me$isAllDayEvent = me.isAllDayEvent) === null || _me$isAllDayEvent === void 0 ? void 0 : _me$isAllDayEvent.call(me, eventRecord), eventInnerStyle = {
        height: eventHeight !== "auto" ? DomHelper.setLength(eventHeight) : null
      }, eventSelectedCls = calendar === null || calendar === void 0 ? void 0 : calendar.eventSelectedCls, dataset = renderData.dataset = {
        eventId: eventRecord.id
      };
      let bodyContent = me.internalBodyContentRenderer(eventRecord), complexContent = typeof bodyContent !== "string", bodyContentType = complexContent ? "children" : "html", color = eventRecord.color || eventRecord.eventColor || (resourceRecord === null || resourceRecord === void 0 ? void 0 : resourceRecord.eventColor) || emptyString;
      renderData.cls = eventRecord.cls.clone();
      renderData.solidBar = isAllDay || minimal;
      renderData.iconStyle = me.iconTarget === "header" && me.showTime && !DomHelper.isNamedColor(color) ? {
        color
      } : {};
      renderData.iconCls = new DomClassList(eventRecord.iconCls);
      renderData.style = Object.assign(DomHelper.parseStyle(resourceRecord === null || resourceRecord === void 0 ? void 0 : resourceRecord.eventStyle), DomHelper.parseStyle(eventRecord.style));
      renderData.eventColor = color;
      renderData.eventHeight = eventHeight;
      renderData.cls[me.shortEventCls] = eventRecord.durationMS <= me.shortEventDuration;
      if (resourceRecord !== null && resourceRecord !== void 0 && resourceRecord.cls) {
        renderData.cls.add(resourceRecord.cls);
      }
      if (eventRenderer && !minimal) {
        const rendererValue = me.callback(eventRenderer, me, [{
          eventRecord,
          resourceRecord,
          renderData
        }]);
        if (renderData.eventHeight !== eventHeight) {
          eventInnerStyle.height = DomHelper.setLength(renderData.eventHeight);
        }
        if (rendererValue != null) {
          complexContent = true;
          bodyContent = rendererValue;
          if (typeof bodyContent !== "string") {
            bodyContent = ArrayHelper.asArray(bodyContent);
            bodyContentType = "children";
          }
        }
        if (typeof renderData.cls === "string") {
          renderData.cls = new DomClassList(renderData.cls);
        }
        if (typeof renderData.iconCls === "string") {
          renderData.iconCls = new DomClassList(renderData.iconCls);
        }
        if (typeof renderData.style === "string") {
          renderData.style = DomHelper.parseStyle(renderData.style);
        }
      }
      bodyContent = [{
        className: {
          "b-cal-event-desc": 1,
          "b-cal-event-desc-complex": complexContent
        },
        [bodyContentType]: bodyContent
      }];
      Object.assign(renderData.cls, {
        "b-cal-event-wrap": 1,
        "b-iscreating": eventRecord.isCreating,
        "b-readonly": eventRecord.readOnly,
        "b-minimal": minimal,
        [alldayCls]: alldayCls && isAllDay,
        [solidBarCls]: solidBarCls && renderData.solidBar,
        [intradayCls]: intradayCls && !isAllDay,
        [pastEventCls]: pastEventCls && eventEndDate < new Date(),
        [eventSelectedCls]: eventSelectedCls && (calendar === null || calendar === void 0 ? void 0 : calendar.isEventSelected(eventRecord)),
        "b-rtl": rtl
      });
      color = renderData.eventColor;
      if ((_color = color) !== null && _color !== void 0 && _color.length) {
        if (DomHelper.isNamedColor(color)) {
          renderData.cls[`b-cal-color-${color}`] = 1;
        } else {
          if (renderData.solidBar) {
            eventInnerStyle["background-color"] = color;
          } else {
            eventInnerStyle[me.eventColourStyleProperty] = color;
          }
        }
      }
      if (showTime && !(isAllDay && this.showAllDayHeader)) {
        bodyContent.unshift({
          className: "b-event-header",
          children: [{
            className: "b-event-time",
            html: DateHelper.format(eventRecord.startDate, timeFormat)
          }]
        });
      }
      const hasIcon = Boolean((_renderData$iconCls = renderData.iconCls) === null || _renderData$iconCls === void 0 ? void 0 : _renderData$iconCls.length), useIconAsRecurrIcon = !hasIcon && isRecurring, showCircle = me.showCircle && !hasIcon && !isRecurring, iconElement = {
        tag: "i",
        className: Object.assign({
          "b-cal-event-icon": !useIconAsRecurrIcon,
          "b-cal-recurrence-icon": useIconAsRecurrIcon,
          "b-icon": 1,
          "b-fw-icon": 1,
          "b-icon-circle": showCircle,
          "b-icon-recurring": useIconAsRecurrIcon
        }, renderData.iconCls),
        style: renderData.iconStyle
      }, eventInnerContent = [{
        className: "b-cal-event-body",
        children: bodyContent
      }], iconParent = me.iconTarget === "header" && me.showTime ? bodyContent[0].children.length > 0 ? bodyContent[0].children : bodyContent : eventInnerContent;
      if (hasIcon || useIconAsRecurrIcon || showCircle) {
        if (me.iconTarget === "header" && me.showTime) {
          iconParent.push(iconElement);
        } else {
          iconParent.unshift(iconElement);
        }
      }
      if (hasIcon && isRecurring) {
        iconParent.push({
          tag: "i",
          className: {
            "b-cal-recurrence-icon": 1,
            "b-icon": 1,
            "b-fw-icon": 1,
            "b-icon-recurring": 1
          },
          style: renderData.iconStyle
        });
      }
      return {
        tabIndex: minimal ? null : 0,
        dataset,
        className: renderData.cls,
        style: renderData.style,
        children: [{
          className: "b-cal-event",
          style: eventInnerStyle,
          children: minimal ? null : eventInnerContent
        }]
      };
    }
    internalBodyContentRenderer(eventRecord) {
      var _eventRecord$assigned;
      const eventNameHtml = StringHelper.encodeHtmlBR(eventRecord.name), {
        showResourceAvatars
      } = this;
      if (showResourceAvatars && (_eventRecord$assigned = eventRecord.assigned) !== null && _eventRecord$assigned !== void 0 && _eventRecord$assigned.size) {
        const content = [{
          class: "b-cal-event-resource-avatars",
          children: eventRecord.resources.map((resource) => this.getResourceAvatar(resource))
        }, {
          tag: "span",
          class: "b-cal-event-name",
          html: eventNameHtml
        }];
        return showResourceAvatars === "last" ? content.reverse() : content;
      } else {
        return eventNameHtml;
      }
    }
  }, _defineProperty(_class, "$name", "EventRenderer"), _defineProperty(_class, "configurable", {
    eventRenderer: null
  }), _class;
};
var locale = {
  localeName: "En",
  localeDesc: "English (US)",
  localeCode: "en-US",
  EventEdit: {
    Calendar: "Calendar",
    "All day": "All day",
    day: "Day",
    week: "Week",
    month: "Month",
    year: "Year",
    decade: "Decade"
  },
  EventMenu: {
    duplicateEvent: "Duplicate event",
    copy: "copy"
  },
  Calendar: {
    Today: "Today",
    next: (range) => `Next ${range}`,
    previous: (range) => `Previous ${range}`,
    plusMore: (value) => `+${value} more`,
    allDay: "All day",
    endsOn: (d) => `Ends ${d}`,
    weekOfYear: ([y, w]) => `Week ${w}, ${y}`,
    loadFail: "Calendar data load failed. Please contact your system administrator"
  },
  CalendarDrag: {
    holdCtrlForRecurrence: "Hold CTRL for a recurring event"
  },
  CalendarMixin: {
    eventCount: (count) => `${count || "No"} event${count === 1 ? "" : "s"}`
  },
  EventTip: {
    "Edit event": "Edit event",
    timeFormat: "LST"
  },
  ModeSelector: {
    includeWeekends: "Include weekends",
    weekends: "Weekends"
  },
  AgendaView: {
    Agenda: "Agenda"
  },
  MonthView: {
    Month: "Month",
    monthUnit: "month"
  },
  WeekView: {
    weekUnit: "week"
  },
  YearView: {
    Year: "Year",
    yearUnit: "year"
  },
  EventList: {
    List: "List",
    Start: "Start",
    Finish: "End"
  },
  DayView: {
    Day: "Day",
    dayUnit: "day",
    daysUnit: "days",
    expandAllDayRow: "Expand all-day section",
    collapseAllDayRow: "Collapse all-day section",
    timeFormat: "LST"
  },
  Sidebar: {
    "Filter events": "Filter events"
  },
  WeekExpander: {
    expandTip: "Click to expand row",
    collapseTip: "Click to collapse row"
  }
};
LocaleHelper.publishLocale(locale);
var immediatePromise = Promise.resolve();
var emptyObject$1 = Object.freeze({});
var {
  eventNameMap: eventNameMap$1
} = EventHelper;
var isFocusedCalendarMixin$1 = (w) => w.isCalendarMixin && w.containsFocus;
var CalendarMixin = (Target) => {
  var _class;
  return _class = class CalendarMixin2 extends (Target || Base$1).mixin(Describable, SchedulerInterface, Featureable, CalendarStores, EventRenderer, Responsive) {
    static get configurable() {
      return {
        localizableProperties: ["autoCreate.newName"],
        eventStore: null,
        resourceStore: null,
        eventSorter: EventSorter.defaultSorterFn,
        responsive: {},
        hideNonWorkingDays: null,
        hideNonWorkingDaysCls: "b-hide-nonworking-days",
        weekStartDay: DateHelper.weekStartDay,
        nonWorkingDays: {
          value: DateHelper.nonWorkingDays,
          $config: {
            merge: "replace"
          }
        },
        nonWorkingDayCls: "b-nonworking-day",
        dayCellCls: "b-calendar-cell",
        weekendCls: "b-weekend",
        todayCls: "b-today",
        pastEventCls: "b-past-event",
        shortEventCls: "b-short-event",
        shortEventDuration: "30 minutes",
        eventHeight: 25,
        eventSpacing: 2,
        intradayCls: "b-intraday",
        alldayCls: "b-allday",
        solidBarCls: "b-solid-bar",
        dayNameSelector: ".b-day-name",
        showTime: false,
        timeFormat: "LT",
        showCircle: true,
        eventColourStyleProperty: "color",
        handlePointerInteraction: true,
        shortDateFormat: "ll",
        shortDateTimeFormat: "ll LT",
        readOnly: null,
        autoCreate: {
          gesture: "dblclick",
          newName: "L{Object.newEvent}",
          step: "15 minutes",
          duration: "1 hour",
          startHour: 8
        },
        autoRefresh: {
          $config: {
            merge: "classList"
          },
          value: null
        },
        allowOverlap: true,
        syncViewDate: true,
        focusable: false,
        avatarRendering: {
          $config: "lazy",
          value: null
        },
        showResourceAvatars: null,
        resourceImagePath: null,
        minDate: null,
        maxDate: null,
        animateTimeShift: true,
        includeTimeRanges: null,
        testConfig: {
          animateTimeShift: false
        }
      };
    }
    static get delayable() {
      return {
        refreshSoon: {
          type: "raf",
          cancelOutstanding: true
        }
      };
    }
    static get featureable() {
      return {
        factory: CalendarFeature
      };
    }
    construct(config) {
      var _me$contentElement;
      const me = this;
      super.construct(config);
      if (!me.isYearView && me.element.tabIndex !== -1 && ((_me$contentElement = me.contentElement) === null || _me$contentElement === void 0 ? void 0 : _me$contentElement.tabIndex) !== -1) {
        (me.contentElement || me.element).tabIndex = -1;
      }
      me.getConfig("avatarRendering");
      EventHelper.on({
        element: me.element,
        keydown: "onCalendarKeyDown",
        thisObj: me
      });
      if (me.handlePointerInteraction) {
        EventHelper.on({
          element: me.element,
          mouseover: "onEventMouseOverOut",
          mouseout: "onEventMouseOverOut",
          mousedown: "onCalendarPointerInteraction",
          mouseup: "onCalendarPointerInteraction",
          click: {
            handler: "onCalendarPointerInteraction",
            block: 300
          },
          dblclick: "onCalendarPointerInteraction",
          contextmenu: "onCalendarPointerInteraction",
          thisObj: me
        });
      }
    }
    getTimeRanges(startDate, endDate) {
      const {
        resourceId,
        project
      } = this, includeTimeRanges = resourceId ? this.owner.includeTimeRanges : true, ranges = resourceId == null || includeTimeRanges ? project === null || project === void 0 ? void 0 : project.getTimeRanges(startDate, endDate) : [];
      if (resourceId != null) {
        const resourceRanges = project === null || project === void 0 ? void 0 : project.getResourceTimeRanges(startDate, endDate).filter((r) => r.resourceId == resourceId);
        resourceRanges.forEach((r) => {
          if (!r.color) {
            r.color = this.resource.eventColor;
          }
        });
        ranges.push(...resourceRanges);
      }
      return ranges;
    }
    updateIncludeTimeRanges() {
      if (!this.isConfiguring) {
        this.refresh();
      }
    }
    onConfigChange(info) {
      var _this$autoRefresh;
      if ((_this$autoRefresh = this.autoRefresh) !== null && _this$autoRefresh !== void 0 && _this$autoRefresh[info === null || info === void 0 ? void 0 : info.name]) {
        this.refreshSoon();
      }
      super.onConfigChange(info);
    }
    changeAvatarRendering(avatarRendering) {
      return AvatarRendering.new({
        element: this.element
      }, avatarRendering);
    }
    updateShowResourceAvatars(showResourceAvatars) {
      if (showResourceAvatars) {
        this.avatarRendering || (this.avatarRendering = true);
      }
    }
    getResourceAvatar(resourceRecord) {
      return this.avatarRendering.getResourceAvatar({
        resourceRecord,
        imageUrl: resourceRecord.image === false ? null : resourceRecord.imageUrl || resourceRecord.image && this.resourceImagePath + resourceRecord.image,
        color: resourceRecord.eventColor,
        initials: resourceRecord.initials,
        dataset: {
          btip: StringHelper.encodeHtml(resourceRecord.name),
          resourceId: resourceRecord.id
        }
      });
    }
    updateEventHeight(eventHeight) {
      const {
        style
      } = this.element;
      this._eventHeightInPixels = null;
      style.setProperty("--event-height", DomHelper.setLength(eventHeight));
      style.setProperty("--arrow-width", "calc(var(--event-height) / 3)");
      style.setProperty("--arrow-margin", "calc(var(--event-height) / -3)");
      if (!this.isConfiguring) {
        this.refreshSoon();
      }
    }
    get eventHeightInPixels() {
      const me = this, {
        eventHeight
      } = me;
      let eventHeightInPixels = me._eventHeightInPixels;
      if (eventHeight !== "auto") {
        if (!eventHeightInPixels) {
          eventHeightInPixels = me._eventHeight;
          if (typeof eventHeightInPixels === "string") {
            eventHeightInPixels = DomHelper.measureSize(eventHeightInPixels, me.contentElement.querySelector(`.${me.eventBarContainerCls}`), false);
          }
          me._eventHeightInPixels = eventHeightInPixels;
        }
      }
      return eventHeightInPixels;
    }
    get visibleCellSelector() {
      const excludes = [];
      if (this.hideOtherMonthCells) {
        excludes.push(`.${this.otherMonthCls}`);
      }
      if (this.hideNonWorkingDays) {
        excludes.push(`.${this.nonWorkingDayCls}`);
      }
      return `.${this.dayCellCls}${excludes.length ? `:not(${excludes.join(",")})` : ""}`;
    }
    get activeView() {
      return this;
    }
    get activeSubView() {
      var _items$filter;
      const {
        items: items2
      } = this, activeSubView = (_items$filter = items2.filter(isFocusedCalendarMixin$1)) === null || _items$filter === void 0 ? void 0 : _items$filter[0];
      return activeSubView || this;
    }
    eachView(fn2, args, thisObj = null) {
      this.callback(fn2, thisObj || this, args || [this]);
    }
    get focusElement() {
      const {
        calendar
      } = this;
      if (calendar) {
        const {
          navigator: navigator2
        } = calendar;
        return navigator2.activeItem || navigator2.previousActiveItem || this.element.querySelector(navigator2.itemSelector) || super.focusElement;
      }
    }
    captureFocusItem(activeElement) {
      const activeEvent = this.getEventRecord(activeElement), base = super.captureFocusItem(activeElement);
      return (scrollIntoView = true) => {
        const newEl = activeEvent && this.getEventElement(activeEvent);
        if (newEl) {
          scrollIntoView ? newEl.focus() : DomHelper.focusWithoutScrolling(newEl);
        } else {
          base === null || base === void 0 ? void 0 : base(scrollIntoView);
        }
      };
    }
    refresh() {
      this.refreshSoon.cancel();
      this.month && this.element.style.setProperty("--week-length", this.month.weekLength);
      this.whenVisible("refreshNow");
    }
    refreshNow() {
      const refocus = this.captureFocus();
      this.doRefresh();
      refocus();
    }
    get displayName() {
      return StringHelper.capitalize(this.title || this.type);
    }
    get hiddenNonWorkingDays() {
      return this.hideNonWorkingDays ? this.nonWorkingDays || this.month.nonWorkingDays : emptyObject$1;
    }
    changeAutoCreate(autoCreate) {
      const defaults = CalendarMixin2.$meta.config.autoCreate;
      if (autoCreate === true) {
        return defaults;
      }
      if (typeof autoCreate === "string") {
        autoCreate = {
          gesture: autoCreate
        };
      }
      return Config.merge(autoCreate, defaults);
    }
    updateDateSeparator() {
      this.refreshCalendarDescription();
    }
    updateDescriptionFormat() {
      this.refreshCalendarDescription();
    }
    refreshCalendarDescription() {
      const {
        calendar
      } = this;
      if (calendar !== null && calendar !== void 0 && calendar.isPainted && calendar.activeView === this) {
        calendar.updateViewDescription();
      }
    }
    changeShortEventDuration(shortEventDuration) {
      return isNaN(shortEventDuration) ? DateHelper.as("ms", shortEventDuration) : Number(shortEventDuration);
    }
    updateShortEventDuration() {
      if (!this.isConfiguring) {
        this.refresh();
      }
    }
    updateLocalization() {
      if (!("weekStartDay" in this.initialConfig)) {
        this.weekStartDay = DateHelper.weekStartDay;
      }
      if (!("nonWorkingDays" in this.initialConfig)) {
        this.nonWorkingDays = DateHelper.nonWorkingDays;
      }
      super.updateLocalization();
      this.refreshCalendarDescription();
    }
    updateAutoCreate(autoCreate) {
      this.updateLocalization();
    }
    updateWeekStartDay(weekStartDay) {
      var _super$updateWeekStar;
      const {
        refreshCount,
        month: month2
      } = this;
      (_super$updateWeekStar = super.updateWeekStartDay) === null || _super$updateWeekStar === void 0 ? void 0 : _super$updateWeekStar.call(this, weekStartDay);
      if (month2) {
        month2.weekStartDay = weekStartDay;
      }
      if (this.isPainted && this.refreshCount === refreshCount) {
        this.refresh();
      }
    }
    changeNonWorkingDays(nonWorkingDays) {
      const me = this, result = new Proxy(ObjectHelper.assign({}, nonWorkingDays), {
        set(target) {
          const result2 = Reflect.set(...arguments);
          me.updateNonWorkingDays(target);
          return result2;
        },
        deleteProperty(target) {
          const result2 = Reflect.deleteProperty(...arguments);
          me.updateNonWorkingDays(target);
          return result2;
        }
      });
      return result;
    }
    updateNonWorkingDays(nonWorkingDays) {
      var _super$updateNonWorki;
      const {
        refreshCount,
        month: month2
      } = this;
      (_super$updateNonWorki = super.updateNonWorkingDays) === null || _super$updateNonWorki === void 0 ? void 0 : _super$updateNonWorki.call(this, nonWorkingDays);
      if (month2) {
        month2.nonWorkingDays = nonWorkingDays;
      }
      if (this.isPainted && this.refreshCount === refreshCount) {
        this.refresh();
      }
    }
    dayOfDate(date2) {
      return DateHelper.clearTime(date2);
    }
    ingestDate(date2) {
      date2 = typeof date2 === "string" ? DateHelper.parse(date2) : new Date(date2);
      if (isNaN(date2)) {
        throw new Error("Calendar widget date ingestion must be passed a Date, or a YYYY-MM-DD date string");
      }
      return this.dayOfDate(date2);
    }
    changeDate(date2, oldDate) {
      date2 = this.ingestDate(date2);
      if (!this.isInIsValidTargetDate && !this.isValidTargetDate(date2)) {
        return;
      }
      if (!oldDate || date2 - oldDate) {
        if (this.trigger("beforeDateChange", {
          date: date2,
          oldDate
        }) !== false) {
          return date2;
        }
      }
    }
    isValidTargetDate(date2, end) {
      var _me$calendar, _me$calendar2;
      const me = this, minDate = me.minDate || ((_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.minDate), maxDate = me.maxDate || ((_me$calendar2 = me.calendar) === null || _me$calendar2 === void 0 ? void 0 : _me$calendar2.maxDate);
      if (!isNaN(minDate) || !isNaN(maxDate)) {
        this.isInIsValidTargetDate = true;
        const newDate = end ? me[`change${StringHelper.capitalize(end)}Date`](date2, null) : date2;
        me.isInIsValidTargetDate = false;
        if (!isNaN(minDate) && newDate < minDate) {
          return false;
        }
        if (!isNaN(maxDate)) {
          return !(end === "end" ? newDate > maxDate : newDate >= maxDate);
        }
      }
      return true;
    }
    changeStartDate(startDate) {
      if (startDate) {
        startDate = this.ingestDate(startDate);
        if (this.isInIsValidTargetDate || this.isValidTargetDate(startDate, "start")) {
          return startDate;
        }
      }
    }
    changeEndDate(endDate) {
      if (endDate) {
        endDate = this.ingestDate(endDate);
        if (this.isInIsValidTargetDate || this.isValidTargetDate(endDate, "end")) {
          return endDate;
        }
      }
    }
    async scrollTo(target, options = {
      animate: true
    }) {
      const me = this, {
        scrollable
      } = me;
      let promise = immediatePromise;
      if (me.scrollPromise) {
        await me.scrollPromise;
      }
      if (target.isEvent) {
        const eventRecord = target;
        if (!DateHelper.intersectSpans(me.startDate, me.endDate, target.startDate, target.endDate)) {
          me.date = target.startDate;
        }
        target = me.getEventElement(target);
        if (!target) {
          me.refresh();
          target = me.getEventElement(eventRecord);
        }
      } else {
        target = me.changeDate(target);
        if (!DateHelper.betweenLesser(target, me.startDate, me.endDate) || !me.getDayElement(target, true)) {
          me.date = target;
        }
        target = me.getDayElement(target);
      }
      if (scrollable) {
        promise = scrollable.scrollIntoView(target, options);
      } else if (options.highlight) {
        if (typeof options.highlight === "boolean") {
          DomHelper.highlight(Rectangle.from(target));
        } else {
          me.callback(options.highlight, me, [target, me]);
        }
      }
      return me.scrollPromise = promise;
    }
    async checkAutoCreateGesture(domEvent, date2) {
      var _this$autoCreate, _this$autoCreate$gest;
      if (date2 && this.isVisible && !this.readOnly && domEvent.type === ((_this$autoCreate = this.autoCreate) === null || _this$autoCreate === void 0 ? void 0 : (_this$autoCreate$gest = _this$autoCreate.gesture) === null || _this$autoCreate$gest === void 0 ? void 0 : _this$autoCreate$gest.toLowerCase())) {
        return this.createEvent(date2);
      }
    }
    createEvent(date2) {
      var _this$owner;
      const handler = this.calendar || ((_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.calendar) || this;
      handler.doCreateEvent(date2, this);
    }
    async doCreateEvent(date2, editingView = this) {
      var _me$owner;
      const wasAutoCreate = this.autoCreate;
      if (!wasAutoCreate) {
        this.autoCreate = true;
      }
      const me = this, calendar = me.calendar || ((_me$owner = me.owner) === null || _me$owner === void 0 ? void 0 : _me$owner.calendar), {
        eventStore
      } = calendar, {
        autoCreate,
        defaultCalendar
      } = me, {
        modelClass
      } = eventStore, {
        newName
      } = autoCreate, dateStart = DateHelper.startOf(date2, void 0, void 0, me.weekStartDay), startHourMS = isNaN(autoCreate.startHour) ? DateHelper.getTimeOfDay(DateHelper.parse(autoCreate.startHour, "HH:mm:ss")) : autoCreate.startHour * 1e3 * 60 * 60, startDate = me.isDayView ? DateHelper.round(date2, autoCreate.step) : DateHelper.add(dateStart, startHourMS), duration = DateHelper.parseDuration(autoCreate.duration), durationMs = DateHelper.as("ms", duration), endDate = DateHelper.add(startDate, durationMs), name = me.resolveCallback(newName, me, false) ? me.callback(newName, me, [me, startDate]) : newName, recordData = {
        [modelClass.getFieldDataSource("name")]: name,
        [modelClass.getFieldDataSource("startDate")]: startDate,
        [modelClass.getFieldDataSource("endDate")]: endDate,
        [modelClass.getFieldDataSource("duration")]: duration.magnitude,
        [modelClass.getFieldDataSource("durationUnit")]: duration.unit,
        allDay: DateHelper.diff(startDate, endDate, "day") === 1
      };
      const newRecord = eventStore.createRecord(recordData);
      if (calendar !== null && calendar !== void 0 && calendar.features.eventEdit && !calendar.features.eventEdit.disabled) {
        newRecord.isCreating = true;
      }
      if (defaultCalendar) {
        eventStore.assignmentStore.assignEventToResource(newRecord, defaultCalendar);
      }
      await eventStore.addAsync(newRecord);
      editingView.editAutoCreatedEvent(newRecord);
      if (!wasAutoCreate) {
        me.autoCreate = false;
      }
    }
    editAutoCreatedEvent(eventRecord) {
      this.trigger("eventAutoCreated", {
        eventRecord
      });
    }
    get duration() {
      return this.endDate ? this.calculateDuration(this.startDate, this.endDate) : 1;
    }
    calculateDuration(startDate, endDate) {
      return DateHelper.diff(startDate, endDate, "day");
    }
    next() {
      this.date = DateHelper.add(this.date, this.duration, "day");
    }
    previous() {
      this.date = DateHelper.add(this.date, -this.duration, "day");
    }
    get eventContentElement() {
      return this.contentElement;
    }
    get firstVisibleCell() {
      return this.eventContentElement.querySelector(this.visibleCellSelector);
    }
    get lastVisibleCell() {
      const visibleCells = this.contentElement.querySelectorAll(this.visibleCellSelector);
      return visibleCells[visibleCells.length - 1];
    }
    get firstVisibleDate() {
      const date2 = new Date(this.startDate), {
        month: month2
      } = this.month;
      while (this.hideOtherMonthCells && date2.getMonth() !== month2 || this.hiddenNonWorkingDays[date2.getDay()]) {
        date2.setDate(date2.getDate() + 1);
      }
      return date2;
    }
    get lastVisibleDate() {
      const date2 = DateHelper.add(this.endDate, -1, "d"), {
        month: month2
      } = this.month;
      while (this.hideOtherMonthCells && date2.getMonth() !== month2 || this.hiddenNonWorkingDays[date2.getDay()]) {
        date2.setDate(date2.getDate() - 1);
      }
      return date2;
    }
    updateHideNonWorkingDays(hideNonWorkingDays) {
      var _me$contentElement2, _super$updateHideNonW;
      const me = this, {
        month: month2,
        calendar
      } = me;
      (_me$contentElement2 = me.contentElement) === null || _me$contentElement2 === void 0 ? void 0 : _me$contentElement2.classList[hideNonWorkingDays ? "add" : "remove"](me.hideNonWorkingDaysCls);
      if (month2 == null) {
        return;
      }
      let activeColumnIndex, date2, activeDay;
      if (!me.isConfiguring && hideNonWorkingDays) {
        var _date;
        date2 = me.date;
        activeDay = (_date = date2) === null || _date === void 0 ? void 0 : _date.getDay();
        if (date2 && me.nonWorkingDays[activeDay] && me.getDayElement(date2)) {
          activeColumnIndex = month2.visibleDayColumnIndex[activeDay];
        }
      }
      month2.hideNonWorkingDays = hideNonWorkingDays;
      (_super$updateHideNonW = super.updateHideNonWorkingDays) === null || _super$updateHideNonW === void 0 ? void 0 : _super$updateHideNonW.call(this, hideNonWorkingDays);
      if (typeof activeColumnIndex === "number") {
        const weekStart = month2.getWeekStart(month2.getWeekNumber(date2)), newActiveColumnIndex = Math.min(activeColumnIndex, month2.visibleColumnCount - 1);
        for (let i = -1; ; weekStart.setDate(weekStart.getDate() + 1)) {
          if (typeof month2.visibleDayColumnIndex[weekStart.getDay()] === "number") {
            if (++i === newActiveColumnIndex) {
              break;
            }
          }
        }
        me.date = weekStart;
        calendar && (calendar.date = date2);
      }
    }
    onCalendarStoreChange({
      source,
      action
    }) {
      const me = this;
      if (action === "dataset" && !source.isChained) {
        return;
      }
      if (me.project.isInitialCommitPerformed && !me.project.isWritingData) {
        var _me$_cellMap;
        (_me$_cellMap = me._cellMap) === null || _me$_cellMap === void 0 ? void 0 : _me$_cellMap.clear();
        me.refreshSoon();
      }
    }
    refreshSoon() {
      this.refresh();
    }
    onEventCreated(eventRecord) {
    }
    getEventRecord(elementOrEvent) {
      var _element;
      let element = elementOrEvent instanceof Event ? elementOrEvent.target : elementOrEvent;
      element = ((_element = element) === null || _element === void 0 ? void 0 : _element.closest("[data-event-id]")) || null;
      return element && this.eventStore.getById(element.dataset.eventId);
    }
    resolveEventRecord(elementOrEvent) {
      return this.getEventRecord(elementOrEvent);
    }
    getDateFromElement(element) {
      let dateElement = element === null || element === void 0 ? void 0 : element.closest("[data-date],[data-header-date],[data-month-date]");
      if (dateElement) {
        return this.dayTime.parseKey(dateElement.dataset.date || dateElement.dataset.headerDate || dateElement.dataset.monthDate);
      }
      dateElement = element === null || element === void 0 ? void 0 : element.closest("[data-week]");
      if (dateElement) {
        var _this$month;
        return (_this$month = this.month) === null || _this$month === void 0 ? void 0 : _this$month.getWeekStart(dateElement.dataset.week.split(",").map(Number));
      }
    }
    getDateFromDomEvent(domEvent) {
      return this.getDateFromElement(DomHelper.getEventElement(domEvent));
    }
    getDateFromPosition() {
      return null;
    }
    dateKey(date2) {
      return DateHelper.makeKey(date2);
    }
    getDayElement(date2, strict) {
      if (typeof date2 !== "string") {
        date2 = this.dateKey(date2);
      }
      return this.eventContentElement.querySelector(`[data-date="${date2}"]`);
    }
    getEventElement(eventRecord, date2 = Math.max(eventRecord.startDate, this.firstVisibleDate || this.startDate)) {
      var _me$calendar3;
      const me = this, activeEventElement = (_me$calendar3 = me.calendar) === null || _me$calendar3 === void 0 ? void 0 : _me$calendar3.navigator.activeItem, activeDate = me.getDateFromElement(activeEventElement), eventId = me.eventStore.modelClass.asId(eventRecord);
      if (document.contains(activeEventElement) && (activeEventElement === null || activeEventElement === void 0 ? void 0 : activeEventElement.dataset.eventId) === String(eventId) && activeDate && !(date2 - activeDate)) {
        return activeEventElement;
      }
      if (date2) {
        const dayCell = me.getDayElement(date2);
        if (dayCell) {
          return DomHelper.down(dayCell, `[data-event-id="${eventId}"]`);
        }
      }
      return me.getEventElements(eventRecord)[0];
    }
    getEventElements(eventRecord) {
      const eventId = this.eventStore.modelClass.asId(eventRecord);
      return this.eventContentElement.querySelectorAll(`[data-event-id="${eventId}"]`);
    }
    onEventMouseOverOut(domEvent) {
      const me = this, {
        currentOverEventEl
      } = me, isOut = domEvent.type === "mouseout", toElement = domEvent[isOut ? "relatedTarget" : "target"], toEventEl = (toElement === null || toElement === void 0 ? void 0 : toElement.closest(".b-cal-event-wrap")) || null, isChange = toEventEl !== (currentOverEventEl || null);
      if (isChange) {
        if (isOut) {
          me.currentOverEventEl = null;
          if (currentOverEventEl) {
            Object.defineProperty(domEvent, "target", {
              configurable: true,
              get: () => currentOverEventEl
            });
          }
          return me.onCalendarPointerInteraction(domEvent);
        } else {
          me.currentOverEventEl = toEventEl;
          return me.onCalendarPointerInteraction(domEvent);
        }
      }
    }
    calendarHitTest(domEvent) {
      const me = this, {
        monthSelector
      } = me, date2 = me.getDateFromDomEvent(domEvent), target = DomHelper.getEventElement(domEvent);
      let ret = null, closest;
      if (closest = target.closest(".b-cal-event-wrap")) {
        ret = {
          type: "event",
          eventElement: closest,
          eventRecord: me.eventStore.getById(closest.dataset.eventId)
        };
      } else if (closest = target.closest(me.dayNameSelector)) {
        ret = {
          type: "dayNumber",
          dayNumberElement: closest
        };
      } else if (closest = target.closest(".b-week-num,.b-week-number-cell")) {
        const weekElement = target.closest(".b-calendar-week");
        if (weekElement && weekElement.dataset.week) {
          ret = {
            type: "weekNumber",
            week: weekElement.dataset.week.split(",").map(Number),
            weekNumberElement: closest,
            weekElement
          };
        }
      } else if (monthSelector && target.closest(monthSelector)) {
        ret = {
          type: "monthName",
          month: date2.getMonth(),
          date: date2
        };
      }
      if (!ret) {
        if (closest = target.closest(".b-cal-cell-overflow")) {
          ret = {
            type: "cellOverflow",
            cellOverflowElement: closest
          };
        } else if (date2) {
          ret = {
            type: "schedule"
          };
        }
      }
      if (ret) {
        ret.cell = target.closest(".b-calendar-cell");
        ret.date = date2;
        ret.view = me;
      }
      return ret;
    }
    onCalendarPointerInteraction(domEvent) {
      const me = this, {
        monthSelector
      } = me, {
        target
      } = domEvent, fromOverflowPopup = Boolean(target.closest(".b-overflowpopup")), domEventName = eventNameMap$1[domEvent.type], date2 = me.getDateFromDomEvent(domEvent), eventWrap = target.closest(".b-cal-event-wrap"), eventRecord = eventWrap ? me.eventStore.getById(eventWrap.dataset.eventId) : me.getEventRecord(target), eventElement = eventWrap || eventRecord && me.getEventElement(eventRecord, date2), resourceElement = target.closest("[data-resource-id]"), resourceRecord = resourceElement && me.resourceStore.getById(resourceElement.dataset.resourceId);
      let result;
      if (resourceRecord) {
        result = me.trigger(`resource${domEventName}`, {
          domEvent,
          date: date2,
          eventElement,
          eventRecord,
          resourceRecord,
          fromOverflowPopup
        });
      }
      if (!fromOverflowPopup && !me.eventContentElement.contains(target)) {
        return;
      }
      if (result !== false && eventRecord) {
        const eventResult = me.trigger(`event${domEventName}`, {
          domEvent,
          date: date2,
          eventElement,
          eventRecord,
          resourceRecord,
          fromOverflowPopup
        });
        if (eventResult) {
          result = eventResult;
        }
      }
      if (eventRecord || resourceRecord) {
        return result;
      }
      if (target.closest(me.dayNameSelector)) {
        result = me.trigger(`dayNumber${domEventName}`, {
          domEvent,
          date: date2,
          cellData: me.cellMap.get(date2) || me.createCellData(date2),
          fromOverflowPopup
        });
        if (result === false) {
          return result;
        }
      }
      if (target.closest(".b-week-num,.b-week-number-cell")) {
        const weekElement = domEvent.target.closest("[data-week]");
        if (weekElement) {
          return me.trigger(`weekNumber${domEventName}`, {
            domEvent,
            week: weekElement.dataset.week.split(",").map(Number),
            date: me.getDateFromElement(weekElement.querySelector(".b-calendar-cell")),
            fromOverflowPopup
          });
        }
      }
      if (monthSelector && target.closest(monthSelector)) {
        return me.trigger(`monthName${domEventName}`, {
          domEvent,
          month: date2.getMonth(),
          date: date2,
          fromOverflowPopup
        });
      }
      if (target.closest(".b-cal-cell-overflow")) {
        if (me.trigger(`cellOverflow${domEventName}`, {
          domEvent,
          date: date2,
          fromOverflowPopup
        }) !== false) {
          return;
        }
      }
      if (date2 && me.dayCellCls && domEvent.target.closest(`.${me.dayCellCls}`)) {
        result = me.trigger(`schedule${domEventName}`, {
          domEvent,
          date: date2,
          fromOverflowPopup
        });
        if (result === false) {
          return result;
        }
      }
      me.checkAutoCreateGesture(domEvent, date2);
      return result;
    }
    onCalendarKeyDown(keyEvent) {
      var _this$calendar;
      if (keyEvent.ctrlKey && keyEvent.key.toLowerCase() === "z" && (_this$calendar = this.calendar) !== null && _this$calendar !== void 0 && _this$calendar.enableUndoRedoKeys) {
        var _this$project, _this$project$stm;
        (_this$project = this.project) === null || _this$project === void 0 ? void 0 : (_this$project$stm = _this$project.stm) === null || _this$project$stm === void 0 ? void 0 : _this$project$stm.onUndoKeyPress(keyEvent);
      } else {
        this.onCalendarPointerInteraction(keyEvent);
      }
    }
    isAllDayEvent(eventRecord) {
      return eventRecord.allDay || (eventRecord.isScheduled && this.dayTime ? this.dayTime.isInterDay(eventRecord) : eventRecord.isInterDay);
    }
    sortEvents(events) {
      events.sort(this.eventSorter);
    }
    preProcessCurrentConfigs(configs) {
      super.preProcessCurrentConfigs(configs);
      delete configs.calendar;
      delete configs.project;
    }
    getCurrentConfig(options) {
      const result = super.getCurrentConfig(options);
      delete result.project;
      return result;
    }
  }, _defineProperty(_class, "$name", "CalendarMixin"), _class;
};
var byKey = ({
  key: lhs
}, {
  key: rhs
}) => {
  return lhs < rhs ? -1 : rhs < lhs ? 1 : 0;
};
var extractEndDate = (e) => e.endDate || DateHelper.add(e.startDate, e.duration, e.durationUnit);
var DayCellCollecter = (Target) => class DayCellCollecter extends (Target || Base$1) {
  static get $name() {
    return "DayCellCollecter";
  }
  static get configurable() {
    return {
      eventFilter: null
    };
  }
  get dayTime() {
    return DayTime.MIDNIGHT;
  }
  get cellMonth() {
    return this._cellMonth || (this._cellMonth = new Month({}));
  }
  createCellMap(getEventsOptions = {}) {
    const me = this, {
      filter: filter2,
      skipPropagate
    } = getEventsOptions, {
      eventFilter,
      cellMonth,
      lastVisibleDate
    } = me, cellMap = getEventsOptions.cellMap || me._cellMap || (me._cellMap = new CellMap());
    if (lastVisibleDate) {
      lastVisibleDate.setDate(lastVisibleDate.getDate() + 1);
    }
    let startDate = getEventsOptions.startDate || me.firstVisibleDate || me.startDate, endDate = getEventsOptions.endDate || lastVisibleDate || me.endDate;
    cellMonth.configure({
      weekBase: null,
      weekStartDay: me.weekStartDay,
      nonWorkingDays: me.nonWorkingDays,
      hideNonWorkingDays: me.hideNonWorkingDays,
      sixWeeks: me.sixWeeks,
      date: startDate
    });
    if (me.eventStore) {
      getEventsOptions = ObjectHelper.assign({
        dayTime: DayTime.MIDNIGHT
      }, getEventsOptions, {
        filter: filter2 && eventFilter ? (e) => filter2(e) && eventFilter(e) : filter2 || eventFilter,
        dateMap: cellMap,
        startDate,
        endDate
      });
      me.collectEvents(getEventsOptions);
      startDate = getEventsOptions.startDate;
      endDate = getEventsOptions.endDate;
      for (const [key, events] of cellMap) {
        let lastEventEndDate = 0;
        me.sortEvents(events);
        const dayTime = getEventsOptions.dayTime, date2 = dayTime.dayOfDate(DateHelper.parseKey(key)), cellData = me.createCellData(date2);
        if (getEventsOptions.rawEvents) {
          lastEventEndDate = Math.min(endDate, Math.max.apply(Math, events.map(extractEndDate)));
          cellData.events = events;
        } else {
          cellData.events = events.map((eventRecord) => {
            const eventEndDate = eventRecord.endingDate, overflows = eventEndDate > cellData.tomorrow, eventData = {
              isAllDay: me.isAllDayEvent(eventRecord),
              isOverflow: eventRecord.startDate < cellData.date && date2 - startDate,
              eventRecord,
              eventEndDate,
              overflows,
              date: date2
            };
            if (!skipPropagate) {
              lastEventEndDate = Math.min(endDate, Math.max(lastEventEndDate, eventEndDate));
              if (overflows) {
                eventData.propagateEndDate = me.calculatePropagateEndDate(eventData, endDate);
              }
            }
            return eventData;
          });
        }
        if (!skipPropagate) {
          for (; date2 < lastEventEndDate; date2.setDate(date2.getDate() + 1)) {
            const key2 = dayTime.dateKey(date2);
            cellMap.has(key2) || cellMap.set(key2, []);
          }
        }
        cellMap.set(key, cellData);
      }
      if (cellMap.size) {
        const cellMapEntries = [...cellMap.values()].sort(byKey);
        let previousEvents;
        cellMap.clear();
        cellMapEntries.forEach((entry) => {
          cellMap.set(entry.key, entry);
          if (previousEvents) {
            previousEvents.nextEvents = entry;
            entry.previousEvents = previousEvents;
          }
          previousEvents = entry;
        });
        if (!skipPropagate) {
          me.propagateCellEvents(cellMapEntries[0], cellMap);
        }
      }
    }
    cellMap.populated = true;
    return cellMap;
  }
  calculatePropagateEndDate(eventData, viewEndDate = this.endDate) {
    const {
      eventEndDate: endDate
    } = eventData, startOfDay = this.dayTime.startOfDay(endDate);
    eventData.propagateEndDate = new Date(Math.min(endDate > startOfDay ? DateHelper.add(startOfDay, 1, "day") : endDate, viewEndDate));
    this.trigger("eventPropagate", eventData);
    return eventData.propagateEndDate;
  }
  collectEvents(options) {
    return this.eventStore.getEvents(options);
  }
  propagateCellEvents(cellData, cellMap) {
    const {
      events,
      renderedEvents,
      previousEvents,
      nextEvents,
      date: date2
    } = cellData, eventsPerCell = this.getEventsPerCell(date2), {
      length
    } = events;
    for (let i = 0; i < length; i++) {
      const event = events[i], {
        eventRecord,
        propagateEndDate,
        eventEndDate
      } = event;
      let renderedSlot = renderedEvents.add(event);
      if (event.overflows) {
        let isVisible2 = cellData.visible, lastEvent2;
        for (let nextDay = nextEvents; nextDay && nextDay.date < propagateEndDate; nextDay = nextDay.nextEvents) {
          if (!nextDay.columnIndex) {
            renderedSlot = nextDay.renderedEvents.firstFreeSlot;
          }
          nextDay.renderedEvents.set(renderedSlot, lastEvent2 = {
            eventRecord,
            eventEndDate,
            propagateEndDate,
            isAllDay: event.isAllDay,
            isOverflow: isVisible2,
            overflows: true
          });
          isVisible2 = isVisible2 || nextDay.visible;
        }
        lastEvent2 && (lastEvent2.overflows = false);
      }
    }
    cellData.maxRow = renderedEvents.length;
    const lastEvent = renderedEvents[eventsPerCell - 1];
    if (renderedEvents.length === eventsPerCell) {
      if (lastEvent !== null && lastEvent !== void 0 && lastEvent.isOverflow && previousEvents !== null && previousEvents !== void 0 && previousEvents.hasOverflow) {
        cellData.maxRow--;
        cellData.hasOverflow = true;
      }
    } else if (renderedEvents.length > eventsPerCell) {
      cellData.maxRow = eventsPerCell - 1;
      cellData.hasOverflow = true;
      if (lastEvent !== null && lastEvent !== void 0 && lastEvent.isOverflow) {
        const weekStartValue = this.firstVisibleDate, eventStartValue = DateHelper.clearTime(lastEvent.eventRecord.startDate).valueOf();
        let originatingCell = cellMap.get(DateHelper.makeKey(new Date(Math.max(weekStartValue, eventStartValue))));
        while (originatingCell.key !== cellData.key) {
          originatingCell.hasOverflow = true;
          originatingCell.maxRow = eventsPerCell - 1;
          originatingCell = originatingCell.nextEvents;
        }
      }
    }
    nextEvents && this.propagateCellEvents(nextEvents, cellMap);
  }
  createCellData(date2) {
    return Object.assign(this.cellMonth.getCellData(date2, this.month, this.dayTime), {
      events: [],
      renderedEvents: new EventSlots()
    });
  }
};
var CellMap = class extends Map {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "populated", false);
  }
  get(d, value) {
    return super.get(DateHelper.makeKey(d), value);
  }
  set(d, value) {
    d = DateHelper.makeKey(d);
    if (!this.has(d)) {
      this.generation = (this.generation || 0) + 1;
    }
    return super.set(d, value);
  }
  delete(d, value) {
    d = DateHelper.makeKey(d);
    if (this.has(d)) {
      this.generation++;
    }
    return super.delete(d, value);
  }
  has(d) {
    return super.has(DateHelper.makeKey(d));
  }
  clear() {
    this.populated = false;
    this.generation = (this.generation || 0) + 1;
    return super.clear();
  }
};
var OverflowPopup = class extends Popup {
  static get $name() {
    return "OverflowPopup";
  }
  static get type() {
    return "overflowpopup";
  }
  static get configurable() {
    return {
      textContent: false,
      autoShow: false,
      floating: false,
      cls: "b-cal-event-list",
      closable: true,
      draggable: {
        handleSelector: ":not(.b-cal-event-wrap)"
      },
      anchor: true,
      layout: "vbox",
      eventRenderer: null,
      eventSorter: EventSorter.interDaySorterFn,
      eventList: {
        type: "widget",
        cls: "b-cal-event-bar-container",
        weight: 500
      },
      items: {},
      tools: {
        maximize: null
      },
      dateFormat: "dddd, MMM DD",
      activeDate: {
        $config: {
          equal: "date"
        },
        value: null
      },
      scrollAction: "hide",
      align: {
        axisLock: "flexible",
        constrainPadding: 20,
        minHeight: 400
      },
      scrollable: {
        overflowY: "auto"
      },
      onlyShowOverflow: null
    };
  }
  calendarHitTest(domEvent) {
    const target = DomHelper.getEventElement(domEvent), closest = target.closest(".b-cal-event-wrap");
    if (closest) {
      return {
        type: "event",
        eventElement: closest,
        eventRecord: this.owner.eventStore.getById(closest.dataset.eventId),
        view: this
      };
    }
    return null;
  }
  onHeaderClick({
    event: domEvent
  }) {
    if (domEvent.target.closest(".b-header-title")) {
      var _this$owner;
      (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.trigger("dayNumberClick", {
        domEvent,
        date: this.activeDate,
        cellData: this.cellData,
        source: this.owner,
        fromOverflowPopup: true
      });
    } else {
      super.onHeaderClick(...arguments);
    }
  }
  get focusElement() {
    var _this$eventList, _this$eventList$eleme;
    const activeElement = DomHelper.getActiveElement(this);
    return this.element.contains(activeElement) ? activeElement : ((_this$eventList = this.eventList) === null || _this$eventList === void 0 ? void 0 : (_this$eventList$eleme = _this$eventList.element) === null || _this$eventList$eleme === void 0 ? void 0 : _this$eventList$eleme.firstElementChild) || super.focusElement;
  }
  getDateFromPosition() {
    return this.activeDate;
  }
  getEventElement(eventRecord) {
    return this.contentElement.querySelector(`[data-event-id="${eventRecord.id}"]`);
  }
  showOverflow(cell, cellData) {
    const date2 = this.activeDate = cellData.date;
    this.cellData = cellData;
    this.targetCell = cell;
    this.refresh(cellData);
    this.showBy(cell);
    if (this.isVisible) {
      var _this$owner2;
      (_this$owner2 = this.owner) === null || _this$owner2 === void 0 ? void 0 : _this$owner2.trigger("showOverflowPopup", {
        cell,
        cellData,
        date: date2,
        overflowPopup: this
      });
    }
  }
  onCalendarStoreChange() {
    const me = this;
    if (me.isVisible) {
      me.cellData = me.owner.cellMap.get(DateHelper.makeKey(me.activeDate));
      me.refresh(me.cellData);
    }
  }
  refresh(cellData) {
    var _cellData, _cellData2;
    if (!this.eventList) {
      return;
    }
    if (cellData) {
      this.cellData = cellData;
    } else {
      cellData = this.cellData;
    }
    const me = this, {
      owner,
      eventRenderer
    } = me, {
      element
    } = me.eventList, slicePoint = me.onlyShowOverflow ? Math.max(owner.eventsPerCell - 1, 0) : 0, events = (_cellData = cellData) === null || _cellData === void 0 ? void 0 : _cellData.renderedEvents.slice(slicePoint).sort(me.eventSorter), children = [];
    if (!(events !== null && events !== void 0 && events.length) || !((_cellData2 = cellData) !== null && _cellData2 !== void 0 && _cellData2.hasOverflow) && !owner.isYearView) {
      return me.hide();
    }
    for (let i = 0, eventRow = 0, {
      length
    } = events; i < length; i++, eventRow++) {
      const renderedEvent = events[i];
      if (renderedEvent) {
        const eventDomConfig = owner.createEventDomConfig(renderedEvent, eventRenderer);
        Object.assign(eventDomConfig.className, {
          "b-continues-past": renderedEvent.eventRecord.startDate < cellData.date,
          "b-continues-future": renderedEvent.eventRecord.endDate > cellData.tomorrow
        });
        eventDomConfig.style.marginBottom = `${owner.eventSpacing}px`;
        children.push(eventDomConfig);
      }
    }
    DomSync.sync({
      domConfig: {
        children
      },
      targetElement: element
    });
    element.dataset.date = cellData.key;
    element.classList.add(`b-day-of-week-${cellData.day}`);
    element.classList.remove(`b-day-of-week-${me.lastRefreshDay}`);
    me.lastRefreshDay = cellData.day;
    me.realign();
  }
  changeItems(items2) {
    const {
      eventList
    } = this;
    if (eventList) {
      items2.eventList = eventList;
    }
    const result = super.changeItems(items2);
    if (eventList) {
      this.eventList = this.widgetMap.eventList;
    }
    return result;
  }
  changeActiveDate(activeDate, oldActiveDate) {
    activeDate = typeof date === "string" ? DateHelper.parse(activeDate) : new Date(activeDate);
    if (isNaN(activeDate)) {
      throw new Error("OverflowPopup date ingestion must be passed a Date, or a YYYY-MM-DD date string");
    }
    return activeDate;
  }
  updateActiveDate(activeDate) {
    this.element.dataset.date = DateHelper.makeKey(activeDate);
    this.title = DateHelper.format(activeDate, this.dateFormat);
  }
  onDocumentMouseDown({
    event
  }) {
    var _this$lastAlignSpec;
    const alignedTo = (_this$lastAlignSpec = this.lastAlignSpec) === null || _this$lastAlignSpec === void 0 ? void 0 : _this$lastAlignSpec.target, {
      target
    } = event;
    if (alignedTo !== null && alignedTo !== void 0 && alignedTo.contains(target)) {
      const cellOverflowButton = target.closest(".b-cal-cell-overflow");
      if (target.closest(".b-cal-event-bar-container") || target.matches(".b-cal-cell-overflow") || (cellOverflowButton === null || cellOverflowButton === void 0 ? void 0 : cellOverflowButton.children.length) === 1) {
        return event.preventDefault();
      }
    }
    super.onDocumentMouseDown(...arguments);
  }
};
OverflowPopup.initClass();
OverflowPopup._$name = "OverflowPopup";
var emptyFn = () => {
};
var {
  eventNameMap
} = EventHelper;
var DayCellRenderer = (Target) => class DayCellRenderer extends (Target || Base$1) {
  static get $name() {
    return "DayCellRenderer";
  }
  static get configurable() {
    return {
      monitorResize: true,
      dayCellRenderer: null,
      dynamicHideNonWorkingdayCls: "b-dynamic-nonworking-day",
      overflowPopup: {
        $config: ["lazy", "nullify"],
        value: {
          type: "overflowpopup"
        }
      },
      overflowPopupTrigger: "click",
      eventBarContainerCls: "b-cal-event-bar-container",
      overflowButtonRenderer: null,
      dayCellNameFormat: null,
      eventSpacing: 2,
      emptyCellCls: "b-cal-empty-cell",
      emptyCellRenderer: null
    };
  }
  onCalendarStoreChange() {
    var _this$_overflowPopup;
    super.onCalendarStoreChange(...arguments);
    if ((_this$_overflowPopup = this._overflowPopup) !== null && _this$_overflowPopup !== void 0 && _this$_overflowPopup.isVisible) {
      this._overflowPopup.onCalendarStoreChange(...arguments);
    }
  }
  onCellOverflowGesture({
    domEvent,
    date: date2
  }) {
    const me = this, cellData = me.cellMap.get(DateHelper.makeKey(date2));
    if (cellData) {
      const {
        overflowPopup
      } = me, cell = me.getCellFromEvent(domEvent);
      if (overflowPopup && me.trigger("beforeShowOverflowPopup", {
        cell,
        cellData,
        date: date2,
        overflowPopup
      })) {
        overflowPopup.showOverflow(cell, cellData);
      }
    }
  }
  getCellFromEvent(domEvent) {
    return domEvent.target.closest(".b-calendar-cell[data-date]");
  }
  updateOverflowPopupTrigger(overflowPopupTrigger) {
    this.onCellOverflowClick = this.onCellOverflowMouseOver = emptyFn;
    overflowPopupTrigger = overflowPopupTrigger.toLowerCase();
    if (overflowPopupTrigger === "mouseover" || overflowPopupTrigger === "hover") {
      overflowPopupTrigger = "mouseOver";
    }
    this[`onCellOverflow${StringHelper.capitalize(overflowPopupTrigger)}`] = this.onCellOverflowGesture;
  }
  changeOverflowPopup(config, instance) {
    const me = this, popupOwner = me.up("calendar") || me.owner || me, ret = OverflowPopup.reconfigure(instance, config, {
      owner: me,
      defaults: {
        owner: me,
        align: {
          constrainTo: globalThis
        }
      }
    });
    if (ret) {
      const {
        element
      } = ret, {
        eventHeightInPixels
      } = me;
      ret.element.classList.add(`b-${me.type}-overflowpopup`);
      if (!ret.floating) {
        ret.positioned = true;
        ret.render(popupOwner.isCalendar ? popupOwner.element : popupOwner.contentElement);
      }
      if (eventHeightInPixels) {
        element.style.setProperty("--event-height", `${eventHeightInPixels}px`);
        element.style.setProperty("--arrow-width", `${eventHeightInPixels / 3}px`);
      }
      if (ret !== instance && popupOwner !== me) {
        EventHelper.on({
          thisObj: me,
          element: ret.bodyElement,
          delegate: ".b-cal-event-wrap",
          mouseover: "onEventMouseOverOut",
          mouseout: "onEventMouseOverOut",
          mousedown: "onCalendarPointerInteraction",
          mouseup: "onCalendarPointerInteraction",
          click: "onCalendarPointerInteraction",
          dblclick: "onCalendarPointerInteraction",
          contextmenu: "onCalendarPointerInteraction"
        });
        if (ret.headerElement) {
          EventHelper.on({
            thisObj: me,
            element: ret.headerElement,
            mousedown: "onCalendarPointerInteraction",
            mouseup: "onCalendarPointerInteraction",
            click: "onCalendarPointerInteraction",
            dblclick: "onCalendarPointerInteraction",
            contextmenu: "onCalendarPointerInteraction"
          });
        }
      }
    }
    return ret;
  }
  onInternalResize(element, width, height, oldWidth, oldHeight) {
    const {
      _eventsPerCell,
      _eventContainerTop
    } = this;
    super.onInternalResize(element, width, height, oldWidth, oldHeight);
    if (this.rendered && height !== oldHeight) {
      this.performResizeRefresh(_eventsPerCell, _eventContainerTop);
    }
  }
  performResizeRefresh(prevEventsPerCell, prevEventContainerTop, now2) {
    this._eventsPerCell = this._eventContainerTop = this._eventContainerHeight = null;
    const me = this, {
      eventsPerCell,
      _overflowPopup
    } = me;
    if (eventsPerCell !== prevEventsPerCell) {
      me.trigger("eventsPerCellChange", {
        value: eventsPerCell,
        oldValue: prevEventsPerCell
      });
    }
    if (me.eventContainerTop !== prevEventContainerTop || eventsPerCell !== prevEventsPerCell) {
      now2 ? me.doRefresh() : me.refresh();
      if (_overflowPopup !== null && _overflowPopup !== void 0 && _overflowPopup.isVisible) {
        _overflowPopup.refresh(me._cellMap.get(DateHelper.makeKey(_overflowPopup.activeDate)));
      }
    }
  }
  updateEventHeight() {
    super.updateEventHeight(...arguments);
    this._eventsPerCell = null;
  }
  updateEventSpacing() {
    this._eventsPerCell = null;
    if (!this.isConfiguring) {
      this.refreshSoon();
    }
  }
  get weeksElement() {
    return this.contentElement;
  }
  get eventContainerHeight() {
    if (this._eventContainerHeight == null && this.isVisible && !this.isConfiguring) {
      const {
        firstVisibleCell
      } = this;
      this._eventContainerHeight = firstVisibleCell ? firstVisibleCell.offsetHeight - this.eventContainerTop : NaN;
    }
    return this._eventContainerHeight;
  }
  get eventContainerTop() {
    const me = this;
    if (me._eventContainerTop == null && me.isVisible && !me.isConfiguring) {
      const {
        firstVisibleCell
      } = me, c = firstVisibleCell && firstVisibleCell.querySelector(`.${me.eventBarContainerCls}`), top = c ? c.getBoundingClientRect().top - c.offsetParent.getBoundingClientRect().top : 0;
      me._eventContainerTop = top === 0 ? null : top;
    }
    return me._eventContainerTop || 0;
  }
  getEventsPerCell(date2) {
    return this.eventsPerCell;
  }
  get eventsPerCell() {
    const me = this;
    if (me._eventsPerCell == null) {
      me._eventsPerCell = Math.floor((me.eventContainerHeight + me.eventSpacing) / (me.eventHeightInPixels + me.eventSpacing));
    }
    return me._eventsPerCell;
  }
  get cellMap() {
    var _this$_cellMap;
    return (_this$_cellMap = this._cellMap) !== null && _this$_cellMap !== void 0 && _this$_cellMap.populated ? this._cellMap : this.createCellMap();
  }
  cellRenderer({
    cell
  }) {
    const domConfig = this.getCellDomConfig(...arguments);
    DomSync.sync({
      domConfig,
      targetElement: cell
    });
  }
  getCellDomConfig({
    cell,
    columnIndex,
    row,
    date: date2,
    day: day2,
    dayTime = DayTime.MIDNIGHT,
    visibleColumnIndex,
    key
  }) {
    var _me$calendar;
    const me = this, {
      eventHeightInPixels,
      eventSpacing,
      weekLength,
      todayCls,
      emptyCellRenderer
    } = me, today = me.dayTime.startOfDay(((_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.dateTimeNow) || new Date()), isToday = date2.getTime() === today.getTime(), dayNumber = date2.getDate(), eventContainer = {
      className: me.eventBarContainerCls,
      role: "presentation",
      children: [],
      syncOptions: {
        syncIdField: "eventId",
        releaseThreshold: 0,
        strict: true
      }
    }, cellHeader = {
      style: {},
      className: new DomClassList({
        "b-cal-cell-header": true,
        [todayCls]: isToday
      })
    }, domConfig = {
      dataset: {},
      style: {},
      className: new DomClassList(cell === null || cell === void 0 ? void 0 : cell.className),
      children: [cellHeader, eventContainer]
    }, isFirstVisibleCell = !(date2 - (me.firstVisibleDate || -1));
    domConfig.className[todayCls] = isToday;
    let dayName, dayEvents = !me.isConfiguring && me.cellMap.get(DateHelper.makeKey(date2));
    if (me.addCellHeaderContent) {
      dayName = me.addCellHeaderContent(cellHeader, dayEvents || (dayEvents = me.createCellData(date2)));
    } else {
      cellHeader.children = [dayName = {
        className: {
          "b-day-name": true
        }
      }];
    }
    let dynamicallySetToNonWorking;
    if (me.dayCellRenderer && !me.isConfiguring) {
      if (!dayEvents) {
        dayEvents = me.createCellData(date2);
      }
      dayEvents.style = domConfig.style;
      dayEvents.cls = domConfig.className;
      dayEvents.headerStyle = cellHeader.style;
      dayEvents.headerCls = cellHeader.className;
      const wasNonWorking = dayEvents && dayEvents.isNonWorking, dayNameContent = me.callback(me.dayCellRenderer, me, [dayEvents, domConfig]);
      if (typeof dayEvents.cls == "string") {
        domConfig.className = new DomClassList(dayEvents.cls);
      }
      if (typeof dayEvents.style === "string") {
        domConfig.style = DomHelper.parseStyle(dayEvents.style);
      }
      if (typeof dayEvents.headerCls == "string") {
        cellHeader.className = new DomClassList(dayEvents.headerCls);
      }
      if (typeof dayEvents.headerStyle === "string") {
        cellHeader.style = DomHelper.parseStyle(dayEvents.headerStyle);
      }
      if (dayNameContent != null) {
        if (typeof dayNameContent === "string") {
          dayName.html = dayNameContent;
        } else {
          dayName.text = null;
          dayName.children = ArrayHelper.asArray(dayNameContent);
        }
      }
      dynamicallySetToNonWorking = !wasNonWorking && dayEvents.isNonWorking;
    }
    if (dayName) {
      if (!(dayName.text || dayName.html)) {
        dayName.text = me.dayCellNameFormat ? DateHelper.format(date2, me.dayCellNameFormat) : dayNumber;
      }
      if ((dayName.text || dayName.html) == dayNumber) {
        dayName.className["b-day-num"] = true;
      }
    }
    if (dayEvents.visible) {
      const {
        hasOverflow,
        renderedEvents,
        maxRow
      } = dayEvents, events = renderedEvents, {
        length
      } = events, children = eventContainer.children;
      domConfig.className[me.nonWorkingDayCls] = dayEvents.isNonWorking;
      domConfig.className[me.dynamicHideNonWorkingdayCls] = dynamicallySetToNonWorking;
      domConfig.className[me.weekendCls] = DateHelper.weekends[day2];
      for (let i = 0, eventRow = 0; i < maxRow; i++, eventRow++) {
        const renderedEvent = events[i];
        if (renderedEvent) {
          const {
            eventRecord,
            isOverflow,
            propagateEndDate
          } = renderedEvent, eventEndDate = renderedEvent.eventEndDate || eventRecord.endingDate, renderedDaySpan = me.getDaySpan(date2, propagateEndDate || eventEndDate, dayTime), daySpan = me.getDaySpan(date2, eventEndDate, dayTime, true), remainingColumns = weekLength - visibleColumnIndex, isHiddenOverflow = visibleColumnIndex && isOverflow, width = DomHelper.percentify(ObjectHelper.round((isHiddenOverflow ? 1 : Math.min(renderedDaySpan, remainingColumns)) / weekLength * 100, 4)), eventDomConfig = me.createEventDomConfig(renderedEvent);
          Object.assign(eventDomConfig.style, {
            width,
            top: `${eventRow * eventHeightInPixels + eventRow * eventSpacing + me.eventContainerTop}px`
          });
          Object.assign(eventDomConfig.className, {
            "b-overflow": isHiddenOverflow,
            "b-continues-past": !isHiddenOverflow && (!visibleColumnIndex || isFirstVisibleCell) && eventRecord.startDate < date2,
            "b-continues-future": !isHiddenOverflow && (daySpan > remainingColumns || daySpan > renderedDaySpan)
          });
          children.push(eventDomConfig);
        }
      }
      if (hasOverflow) {
        row.classList.add("b-has-overflow");
        domConfig.children.push(me.getOverflowButtonDomConfig(length - Math.max(0, maxRow)));
      } else if (!columnIndex) {
        row.classList.remove("b-has-overflow");
      }
      const emptyCell = domConfig.className[me.emptyCellCls] = !events.length;
      if (emptyCell && emptyCellRenderer) {
        const rType = typeof emptyCellRenderer, rCallback = rType === "function" || rType === "string" ? me.resolveCallback(emptyCellRenderer, me, false) : null, noEvents = rCallback !== null && rCallback !== void 0 && rCallback.handler ? rCallback.handler.call(rCallback.thisObj, dayEvents) : emptyCellRenderer;
        if (noEvents) {
          eventContainer.children[0] = {
            tag: "button",
            class: "b-cal-cell-no-content",
            children: [rCallback !== null && rCallback !== void 0 && rCallback.handler ? rCallback.handler.call(rCallback.thisObj, dayEvents) : emptyCellRenderer]
          };
        }
      }
    }
    return domConfig;
  }
  onCalendarPointerInteraction(domEvent) {
    const me = this, {
      target
    } = domEvent;
    if (target.closest(`.${me.emptyCellCls} .${me.eventBarContainerCls}`)) {
      if (!me.emptyCellRenderer || target.closest(".b-cal-cell-no-content")) {
        if (me.trigger(`emptyCell${eventNameMap[domEvent.type]}`, {
          date: me.getDateFromDomEvent(domEvent),
          domEvent
        }) === false) {
          return false;
        }
      }
    }
    return super.onCalendarPointerInteraction(domEvent);
  }
  getDaySpan(startDate, endDate, dayTime, ignoreNonWorkingDays) {
    if (this.hideNonWorkingDays && !ignoreNonWorkingDays) {
      let result = 0;
      for (const date2 = new Date(startDate), spanEnd = dayTime.ceil(endDate, "1 day"); date2 < spanEnd; date2.setDate(date2.getDate() + 1)) {
        if (!this.nonWorkingDays[date2.getDay()]) {
          result++;
        }
      }
      return result;
    } else {
      return Math.max(DateHelper.diff(startDate, dayTime.ceil(endDate, "1 day"), "day"), 1);
    }
  }
  getOverflowButtonDomConfig(overflowCount) {
    const {
      overflowButtonRenderer
    } = this, domConfig = {
      tag: "button",
      className: {
        "b-cal-cell-overflow": 1
      },
      text: this.L("L{Calendar.plusMore}", overflowCount),
      style: {
        lineHeight: `${this.eventHeightInPixels}px`,
        marginBottom: `${this.eventSpacing}px`
      },
      dataset: {
        eventId: "overflow"
      }
    };
    return overflowButtonRenderer ? this.callback(overflowButtonRenderer, this, [domConfig, overflowCount]) : domConfig;
  }
  getCell(date2) {
    if (typeof date2 !== "string") {
      date2 = this.dayTime.dateKey(date2);
    }
    return this.contentElement.querySelector(`[data-date="${date2}"]`);
  }
  getCellOverflowButton(date2) {
    var _this$getCell;
    return (_this$getCell = this.getCell(date2)) === null || _this$getCell === void 0 ? void 0 : _this$getCell.querySelector(".b-cal-cell-overflow");
  }
};
var validRangeUnits = {
  day: 1,
  week: 1,
  month: 1,
  year: 1,
  decade: 1
};
var compareRange = (r1, r2) => (r1 === null || r1 === void 0 ? void 0 : r1.unit) === (r2 === null || r2 === void 0 ? void 0 : r2.unit) && (r1 === null || r1 === void 0 ? void 0 : r1.magnitude) === (r2 === null || r2 === void 0 ? void 0 : r2.magnitude);
var DateRangeOwner = (Target) => {
  var _class;
  return _class = class DateRangeOwner extends (Target || Base$1) {
    previous() {
      const {
        range
      } = this;
      this.date = range ? DateHelper.add(this.date, -range.magnitude, range.unit) : DateHelper.add(this.date, -this.duration, "day");
    }
    next() {
      const {
        range
      } = this;
      this.date = range ? DateHelper.add(this.date, range.magnitude, range.unit) : DateHelper.add(this.date, this.duration, "day");
    }
    changeDate(date2) {
      date2 = super.changeDate(date2 || this.startDate);
      if (this.isConfiguring || this.isValidRange(this.range, date2)) {
        return date2;
      }
    }
    updateDate(date2) {
      var _super$updateDate;
      const me = this, {
        startDate,
        endDate,
        _month
      } = me, newStartDate = me.changeStartDate(date2), generation = _month === null || _month === void 0 ? void 0 : _month.generation;
      if (!startDate || newStartDate - startDate) {
        if (me.hasConfig("endDate")) {
          const duration = DateHelper.diff(startDate, endDate, "d");
          if (!startDate || !endDate || date2 < startDate) {
            me.startDate = date2;
          } else if (date2 >= endDate) {
            me.startDate = DateHelper.add(date2, -(duration - 1), "day");
          }
        } else {
          me.startDate = DateHelper.floor(date2, me.range, void 0, me.weekStartDay);
        }
      }
      if (_month && _month.generation === generation) {
        me._month.date = date2;
      }
      (_super$updateDate = super.updateDate) === null || _super$updateDate === void 0 ? void 0 : _super$updateDate.call(this, ...arguments);
    }
    changeStartDate(startDate, oldStartDate) {
      return super.changeStartDate(this.snapDate(this.ingestDate(startDate)), oldStartDate);
    }
    updateStartDate(startDate, oldStartDate) {
      var _super$updateStartDat;
      const me = this, {
        refreshCount,
        _month
      } = me;
      if (!me.date) {
        me.date = startDate;
      }
      if (_month) {
        _month.date = startDate;
      }
      (_super$updateStartDat = super.updateStartDate) === null || _super$updateStartDat === void 0 ? void 0 : _super$updateStartDat.call(this, ...arguments);
      if (me.hasConfig("endDate")) {
        const duration = DateHelper.diff(oldStartDate || startDate, me.endDate, "day");
        me.endDate = DateHelper.add(startDate, duration, "day");
      }
      if (!me.isConfiguring) {
        if (me.refreshCount === refreshCount) {
          var _me$_cellMap;
          (_me$_cellMap = me._cellMap) === null || _me$_cellMap === void 0 ? void 0 : _me$_cellMap.clear();
          me.refresh();
        }
      }
    }
    changeEndDate(endDate, oldEndDate) {
      return super.changeEndDate(this.snapDate(this.ingestDate(endDate), true), oldEndDate);
    }
    get range() {
      return this.hasConfig("endDate") ? null : this._range;
    }
    get endDate() {
      return this.hasConfig("endDate") ? this._endDate : this.startDate && DateHelper.add(this.startDate, this.range.magnitude, this.range.unit);
    }
    snapDate(date2, end) {
      const range = this.hasConfig("endDate") ? null : this.range;
      return range && range.unit !== "day" && date2 ? DateHelper[end ? "ceil" : "floor"](date2, range, void 0, this.weekStartDay) : date2;
    }
    changeRange(range) {
      if (range) {
        if (typeof range === "string") {
          if (DateHelper.parseTimeUnit(range)) {
            range = {
              magnitude: 1,
              unit: range
            };
          } else {
            range = DateHelper.parseDuration(range);
          }
        } else if (typeof range === "number") {
          return {
            magnitude: range,
            unit: "day"
          };
        }
        if (!validRangeUnits[range.unit]) {
          throw new Error("Range must be in days, weeks, months, years or decades");
        }
        if (this._date && !this.isValidRange(range)) {
          return;
        }
      }
      return range;
    }
    isValidRange(range, date2 = this.date) {
      var _this$calendar, _this$calendar2;
      const minDate = this.minDate || ((_this$calendar = this.calendar) === null || _this$calendar === void 0 ? void 0 : _this$calendar.minDate), maxDate = this.maxDate || ((_this$calendar2 = this.calendar) === null || _this$calendar2 === void 0 ? void 0 : _this$calendar2.maxDate);
      if (range && !isNaN(minDate) || !isNaN(maxDate)) {
        const newRange = this.calculateDateRange(range, date2);
        if (!isNaN(minDate)) {
          if (newRange.startDate < minDate) {
            return false;
          }
        }
        if (!isNaN(maxDate)) {
          if (newRange.endDate > maxDate) {
            return false;
          }
        }
      }
      return true;
    }
    updateRange(range) {
      const me = this, {
        date: date2
      } = me;
      if (range && date2 && !me.hasConfig("endDate")) {
        me.startDate = date2;
      }
    }
    calculateDateRange(range, date2) {
      if (date2) {
        if (range.unit !== "day") {
          return {
            startDate: DateHelper.floor(date2, range, void 0, this.weekStartDay),
            endDate: DateHelper.ceil(DateHelper.add(date2, 1, "day"), range, void 0, this.weekStartDay)
          };
        }
        return {
          startDate: date2,
          endDate: DateHelper.add(date2, range.magnitude, "day")
        };
      }
    }
    changeMonth(month2) {
      var _month2;
      const me = this, {
        date: date2
      } = me;
      if (super.changeMonth) {
        return super.changeMonth(...arguments);
      }
      if (!((_month2 = month2) !== null && _month2 !== void 0 && _month2.isMonth)) {
        month2 = new Month({
          date: date2,
          weekStartDay: me.weekStartDay,
          hideNonWorkingDays: me.hideNonWorkingDays,
          nonWorkingDays: me.nonWorkingDays
        });
        if (me.nonWorkingDays == null) {
          me.nonWorkingDays = month2.nonWorkingDays;
        }
        if (me.weekStartDay == null) {
          me.weekStartDay = month2.weekStartDay;
        }
      }
      return month2;
    }
    get dateBounds() {
      return [this.startDate, this.lastDate];
    }
    get duration() {
      const {
        range
      } = this;
      return range ? DateHelper.as("d", range.magnitude, range.unit) : super.duration;
    }
    get lastDate() {
      const lastDate = this.endDate;
      return lastDate && DateHelper.add(lastDate, -1, "day");
    }
  }, _defineProperty(_class, "$name", "DateRangeOwner"), _defineProperty(_class, "configurable", {
    month: true,
    date: {
      $config: {
        equal: "date"
      },
      value: null
    },
    range: {
      $config: {
        lazy: true,
        equal: compareRange
      },
      value: null
    },
    startDate: {
      $config: {
        equal: "date"
      }
    },
    endDate: {
      $config: {
        equal: "date"
      }
    }
  }), _class;
};
var emptyObject = Object.freeze({});
var expandGestures$1 = {
  shrinkwrap: 1,
  expand: 1
};
var formatDayPart = (format2, sep, d1, d2, compress) => {
  const s12 = DateHelper.format(d1, format2);
  return d2 ? `${s12}${compress ? sep.trim() : sep}${DateHelper.format(d2, format2).slice(compress ? -1 : 0)}` : s12;
};
var CalendarRow = class extends Widget.mixin(CalendarMixin, DayCellCollecter, DayCellRenderer, DateRangeOwner) {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "heightAnimation", Promise.resolve);
  }
  static get $name() {
    return "CalendarRow";
  }
  static get type() {
    return "calendarrow";
  }
  static get configurable() {
    return {
      cls: "b-calendar-days",
      animate: true,
      autoHeight: null,
      autoRefresh: ["dayNameFormat", "dayNumberCompress", "dayNumberFormat", "daySeparator"],
      descriptionFormat: [true, true],
      dayStartShift: null,
      dayTime: 0,
      defaultEventRowCount: 3,
      fullWeek: null,
      minDayWidth: null,
      scrollable: {
        overflowX: "hidden",
        overflowY: "hidden"
      },
      headerScroller: {
        $config: ["lazy", "nullify"],
        value: {
          overflowX: "hidden",
          overflowY: "hidden"
        }
      },
      dayNameFormat: "ddd",
      dayNumberCompress: null,
      dayNumberFormat: "D",
      daySeparator: "-",
      responsive: {
        small: {
          dayNameFormat: "d1",
          dayNumberCompress: true,
          daySeparator: "/"
        },
        "*": {
          dayNameFormat: "ddd",
          dayNumberCompress: false,
          daySeparator: "-"
        }
      },
      dayNameSelector: ".b-cal-cell-header",
      monitorResize: false,
      eventRenderer: null,
      gutterHeight: null,
      expanded: null,
      overflowClickAction: "popup",
      dayHeaderRenderer: null
    };
  }
  compose() {
    return {
      children: {
        headerElement: {
          className: "b-calendarrow-header",
          children: {
            headerCellContainer: {
              className: "b-calendarrow-header-container"
            },
            scrollPadElement: _objectSpread2({}, DomHelper.scrollBarPadElement)
          }
        },
        bodyElement: {
          className: "b-calendarrow-body",
          children: {
            cellContainer: {
              reference: "cellContainer",
              className: "b-calendarrow-cell-container"
            }
          }
        }
      }
    };
  }
  onPaint({
    firstPaint
  }) {
    if (firstPaint) {
      const me = this, {
        fonts
      } = document, onFirstPaint = () => {
        me._eventContainerTop = me._eventContainerHeight = null;
        if (me.eventStore.count) {
          me.performResizeRefresh(null, null, true);
        }
      };
      if ((fonts === null || fonts === void 0 ? void 0 : fonts.status) !== "loaded") {
        fonts.ready.then(() => !me.isDestroyed && onFirstPaint());
      }
      onFirstPaint();
    }
  }
  changeDaySeparator(daySeparator) {
    return Array.isArray(daySeparator) ? daySeparator : [daySeparator, daySeparator];
  }
  changeElement() {
    const result = super.changeElement(...arguments);
    this.scrollable.addPartner(this.headerScroller, "x");
    return result;
  }
  changeHeaderScroller(headerScroller, oldHeaderScroller) {
    if (headerScroller) {
      headerScroller = Scroller.new({
        element: this.headerCellContainer,
        widget: this
      }, headerScroller);
    } else {
      oldHeaderScroller === null || oldHeaderScroller === void 0 ? void 0 : oldHeaderScroller.destroy();
    }
    return headerScroller;
  }
  async scrollTo(target) {
    const me = this, {
      eventFilter
    } = me;
    if (target.isEvent && (!eventFilter || eventFilter(target)) && DateHelper.intersectSpans(me.startDate, me.endDate, target.startDate, target.endDate)) {
      if (!me.getEventElement(target)) {
        if (!(me.expanded || me.autoHeight)) {
          me.toggleExpandCollapse();
        }
      }
    }
    return super.scrollTo(...arguments);
  }
  updateDate(date2, oldDate) {
    var _el, _super$updateDate, _el2;
    const me = this;
    let el = oldDate && me.getDayHeader(oldDate);
    (_el = el) === null || _el === void 0 ? void 0 : _el.classList.remove("b-selected-date");
    (_super$updateDate = super.updateDate) === null || _super$updateDate === void 0 ? void 0 : _super$updateDate.call(this, date2, oldDate);
    el = date2 && me.getDayHeader(date2);
    (_el2 = el) === null || _el2 === void 0 ? void 0 : _el2.classList.add("b-selected-date");
  }
  getDayHeader(date2) {
    if (typeof date2 !== "string") {
      date2 = this.dateKey(date2);
    }
    return this.headerCellContainer.querySelector(`.b-cal-cell-header[data-header-date="${date2}"]`);
  }
  get overflowElement() {
    return this.bodyElement;
  }
  createCellMap(getEventsOptions = {}) {
    const me = this, hiddenDays = me.hideNonWorkingDays ? me.nonWorkingDays : emptyObject, {
      maxEventCount
    } = me, options = ObjectHelper.assign({
      dayTime: me.dayTime
    }, getEventsOptions), cellMap = super.createCellMap(options);
    let newMaxEventCount = 0, lastVisibleCellData;
    cellMap.forEach((cellData) => {
      if (!hiddenDays[cellData.day]) {
        lastVisibleCellData = cellData;
      }
      newMaxEventCount = Math.max(newMaxEventCount, cellData.renderedEvents.length);
    });
    me.maxEventCount = newMaxEventCount;
    if (newMaxEventCount !== maxEventCount) {
      cellMap.clear();
      return me.createCellMap(options);
    }
    lastVisibleCellData && (lastVisibleCellData.isRowEnd = true);
    return cellMap;
  }
  collectEvents(options) {
    options = ObjectHelper.assign({
      dayTime: this.dayTime
    }, options, {
      getDateIndex: (date2) => date2 > (this.firstVisibleDate || this.startDate) ? "startDate" : "date"
    });
    return this.eventStore.getEvents(options);
  }
  createCellData(date2) {
    const me = this, columnIndex = DateHelper.diff(me.startDate, date2, "day"), visibleColumnIndex = columnIndex;
    return Object.assign(me.cellMonth.getCellData(date2, me.month, me.dayTime), {
      visibleColumnIndex,
      columnIndex,
      isRowStart: visibleColumnIndex === 0,
      isRowEnd: false,
      renderedEvents: new EventSlots()
    });
  }
  get dayStartShift() {
    var _this$dayTime$startSh, _this$dayTime;
    return (_this$dayTime$startSh = (_this$dayTime = this.dayTime) === null || _this$dayTime === void 0 ? void 0 : _this$dayTime.startShift) !== null && _this$dayTime$startSh !== void 0 ? _this$dayTime$startSh : this._dayStartShift;
  }
  updateDayStartShift(dayStartShift) {
    this.element.classList.toggle("b-shifted-day", Boolean(dayStartShift));
    this.dayTime = new DayTime(dayStartShift);
  }
  changeDayTime(dayTime) {
    var _this$_dayTime;
    if (!dayTime) {
      dayTime = new DayTime(this.dayStartShift);
    }
    if (!dayTime.isDayTime) {
      dayTime = new DayTime(dayTime);
    }
    if (!((_this$_dayTime = this._dayTime) !== null && _this$_dayTime !== void 0 && _this$_dayTime.equals(dayTime))) {
      return dayTime;
    }
  }
  dayOfDate(date2) {
    return this.dayTime.dayOfDate(date2);
  }
  updateMinDayWidth(minDayWidth) {
    const {
      scrollable,
      headerScroller
    } = this, {
      element
    } = scrollable;
    this.contentElement.style.setProperty("--min-day-width", minDayWidth ? DomHelper.setLength(minDayWidth) : 0);
    if (minDayWidth && element.scrollWidth > element.clientWidth) {
      scrollable.overflowX = headerScroller.overflowX = "hidden-scroll";
    } else {
      scrollable.overflowX = headerScroller.overflowX = false;
    }
  }
  updateEventHeight() {
    super.updateEventHeight(...arguments);
    if (!this.autoHeight && !this.isConfiguring && !this.expanded) {
      this.setEventContentHeight(this.cellContentHeight);
    }
  }
  updateGutterHeight() {
    if (!this.isConfiguring) {
      this.setEventContentHeight(this.cellContentHeight);
    }
  }
  get stepUnit() {
    return this.duration > 1 ? `${this.duration} ${this.L("L{DayView.daysUnit}")}` : this.L("L{DayView.dayUnit}");
  }
  updateNonWorkingDays() {
    this.onVisibleDateRangeChange();
  }
  updateHideNonWorkingDays() {
    super.updateHideNonWorkingDays(...arguments);
    this.onVisibleDateRangeChange();
  }
  onCellOverflowGesture({
    date: date2
  }) {
    if (expandGestures$1[this.overflowClickAction.toLowerCase()]) {
      this.expanded = true;
    } else {
      super.onCellOverflowGesture(...arguments);
    }
  }
  onVisibleDateRangeChange() {
    if (!this.isConfiguring) {
      var _this$_cellMap;
      (_this$_cellMap = this._cellMap) === null || _this$_cellMap === void 0 ? void 0 : _this$_cellMap.clear();
      this.refresh();
    }
  }
  changeAutoHeight(autoHeight) {
    const me = this, {
      eventsPerCell
    } = me;
    me._autoHeight = autoHeight;
    me.setEventContentHeight(me.cellContentHeight);
    me.performResizeRefresh(eventsPerCell, me.eventContainerTop, true);
  }
  async setEventContentHeight(eventContentHeight, syncingSiblings) {
    const me = this, {
      cellContainer: element,
      parent
    } = me;
    if (me._eventContentHeight !== eventContentHeight) {
      var _parent$parent;
      if (!syncingSiblings && parent !== null && parent !== void 0 && parent.isDayView && (_parent$parent = parent.parent) !== null && _parent$parent !== void 0 && _parent$parent.isResourceView) {
        const siblings = parent.parent.items.map((v) => v.allDayEvents).filter((v) => v && v !== me);
        eventContentHeight = Math.max(eventContentHeight || 0, ...siblings.filter((v) => !v.owner.isResourceDayViewTimeAxis).map((v) => v.calculateCellContentHeight() || 0));
        siblings === null || siblings === void 0 ? void 0 : siblings.forEach((v) => {
          v.setEventContentHeight(eventContentHeight, true);
        });
      }
      const {
        height: oldHeight
      } = me;
      let {
        animate
      } = me;
      me.isAnimating = animate;
      const duration = DomHelper.getPropertyTransitionDuration(element, "height");
      if (!duration) {
        me.isAnimating = animate = false;
      }
      element.style.height = `${eventContentHeight}px`;
      me.bodyElement.classList.toggle("b-zero-height", !Boolean(eventContentHeight));
      if (animate) {
        await (me.heightAnimation = EventHelper.waitForTransitionEnd({
          property: "height",
          element,
          duration
        }));
      }
      if (!me.isDestroyed) {
        var _me$owner, _me$owner$syncScrollb;
        const {
          height
        } = me;
        me.isAnimating = false;
        me._eventContentHeight = eventContentHeight;
        (_me$owner = me.owner) === null || _me$owner === void 0 ? void 0 : (_me$owner$syncScrollb = _me$owner.syncScrollbarPadding) === null || _me$owner$syncScrollb === void 0 ? void 0 : _me$owner$syncScrollb.call(_me$owner);
        if (height !== oldHeight) {
          me.trigger("heightChange", {
            height,
            oldHeight
          });
        }
      }
    }
  }
  get hasOverflow() {
    return !this.autoHeight && this.maxEventCount > this.defaultEventRowCount;
  }
  get eventsPerCell() {
    const me = this, {
      maxEventCount
    } = me;
    return me.expanded || me.autoHeight ? maxEventCount : Math.min(maxEventCount, me.defaultEventRowCount);
  }
  get cellContentHeight() {
    return this.calculateCellContentHeight();
  }
  calculateCellContentHeight() {
    const me = this, {
      gutterHeight
    } = me;
    let result = Math.ceil(me.eventContainerTop + me.eventsPerCell * (me.eventHeightInPixels + me.eventSpacing));
    if (gutterHeight) {
      if (me.eventsPerCell) {
        result -= me.eventSpacing;
      }
      if (isNaN(gutterHeight)) {
        result = `calc(${result}px + ${gutterHeight})`;
      } else {
        result += Number(gutterHeight);
      }
    }
    return result;
  }
  getDateFromPosition(clientX, clientY) {
    const me = this, {
      hideNonWorkingDays,
      contentElement
    } = me, dayCells = contentElement.querySelectorAll(`${me.visibleCellSelector}${hideNonWorkingDays ? ":not(.b-nonworking-day" : ""}`), rowRect = contentElement.getBoundingClientRect(), dx = me.rtl ? rowRect.right - clientX : clientX - rowRect.left, weekLength = dayCells.length, {
      width
    } = rowRect, column = Math.floor(dx * weekLength / width);
    if (dx < 0 || width < dx || clientY < rowRect.top || rowRect.bottom < clientY) {
      return null;
    }
    if (me.hideNonWorkingDays) {
      const cellDates = Array.from(dayCells).map((e) => me.getDateFromElement(e));
      return cellDates[column];
    } else {
      const date2 = me.getDateFromElement(dayCells[0]);
      date2.setDate(date2.getDate() + column);
      return date2;
    }
  }
  async toggleExpandCollapse() {
    const {
      expanded
    } = this;
    await this.updateExpanded(!Boolean(expanded), expanded);
  }
  async updateExpanded(expanded, wasExpanded) {
    const me = this;
    me._expanded = wasExpanded;
    const {
      eventsPerCell
    } = me;
    me._expanded = expanded;
    if (me.expanded) {
      me.performResizeRefresh(eventsPerCell, me.eventContainerTop, true);
      await me.heightAnimation;
    } else {
      me.scrollable.overflowY = "hidden";
      await me.setEventContentHeight(me.cellContentHeight);
      if (wasExpanded && !me.isDestroyed) {
        me.performResizeRefresh(eventsPerCell, me.eventContainerTop, true);
      }
    }
  }
  doRefresh() {
    var _this$_cellMap2, _me$nonWorkingDays;
    (_this$_cellMap2 = this._cellMap) === null || _this$_cellMap2 === void 0 ? void 0 : _this$_cellMap2.clear();
    const me = this, {
      dayTime,
      fullWeek,
      startDate,
      endDate,
      headerCellContainer,
      cellContainer,
      dayHeaderRenderer
    } = me, cellMap = (startDate || endDate) && me.cellMap, nonWorkingDays = (_me$nonWorkingDays = me.nonWorkingDays) !== null && _me$nonWorkingDays !== void 0 ? _me$nonWorkingDays : me.month.nonWorkingDays, hiddenDays = me.hideNonWorkingDays ? nonWorkingDays : emptyObject, cellDataBlocks = [], eventCells = [], headerCells = [];
    if (!cellMap) {
      return;
    }
    let columnIndex = 0, visibleColumnIndex = 0, from = new Date(startDate), to = endDate, currentDay, i, lastWorkingDayCell;
    if (fullWeek) {
      from = me.month.getWeekStart(me.month.getWeekNumber(from));
      to = DateHelper.add(from, 7, "d");
    }
    for (const date2 = from; date2 < to; date2.setDate(date2.getDate() + 1), columnIndex++) {
      const cellData = cellMap.get(dayTime.dateKey(date2)) || me.createCellData(date2);
      cellData.columnIndex = cellData.cellIndex = columnIndex;
      if (hiddenDays[cellData.day]) {
        cellData.visibleColumnIndex = void 0;
      } else {
        cellData.isRowStart = visibleColumnIndex === 0;
        cellData.visibleColumnIndex = visibleColumnIndex;
        if (!fullWeek) {
          visibleColumnIndex++;
        }
      }
      cellDataBlocks.push(cellData);
    }
    me.weekLength = fullWeek ? 1 : visibleColumnIndex;
    const length = cellDataBlocks.length;
    for (i = 0; i < length; i++) {
      const cellData = cellDataBlocks[i], {
        day: day2,
        key
      } = cellData;
      if (!hiddenDays[day2]) {
        const isNonWorking = nonWorkingDays[day2], dayCls = `b-day-of-week-${day2}`;
        currentDay = !(cellData.date - me.date);
        cellData.cell = me.getCell(key);
        cellData.row = me.cellContainer;
        const cellDomConfig = me.getCellDomConfig(cellData), headerDomConfig = Objects.merge({
          dataset: {
            headerDate: key
          }
        }, cellDomConfig.children[0]);
        headerDomConfig.className["b-selected-date"] = currentDay;
        headerDomConfig.className["b-current-date"] = fullWeek && currentDay;
        headerDomConfig.className[dayCls] = 1;
        dayHeaderRenderer && me.callback(dayHeaderRenderer, me, [headerDomConfig, cellData]);
        cellDomConfig.dataset.date = key;
        Object.assign(cellDomConfig.className, {
          "b-dayview-allday": 1,
          [me.nonWorkingDayCls]: isNonWorking,
          [me.weekendCls]: DateHelper.weekends[day2],
          [me.dayCellCls]: 1,
          [dayCls]: 1
        });
        cellDomConfig.children.shift();
        headerCells.push(headerDomConfig);
        if (!fullWeek || currentDay) {
          eventCells.push(cellDomConfig);
          if (!isNonWorking) {
            lastWorkingDayCell = cellDomConfig;
          }
        }
      }
    }
    lastWorkingDayCell && (lastWorkingDayCell.className["b-last-working-day"] = 1);
    DomSync.sync({
      targetElement: headerCellContainer,
      domConfig: {
        children: headerCells,
        syncOptions: {
          releaseThreshold: 0,
          strict: true
        }
      }
    });
    DomSync.sync({
      targetElement: cellContainer,
      domConfig: {
        children: eventCells,
        syncOptions: {
          releaseThreshold: 0,
          strict: true
        }
      }
    });
    me.refreshCount = (me.refreshCount || 0) + 1;
    me.collapseGutter();
    me.setEventContentHeight(me.cellContentHeight);
    me.trigger("refresh");
  }
  get eventContainerTop() {
    return 0;
  }
  async expandGutter() {
    const me = this;
    if (!me._isTemporarilyExpanded) {
      me.gutterHeight = (me.gutterHeight || 0) + me.eventHeightInPixels + me.eventSpacing;
      await me.setEventContentHeight(me.cellContentHeight);
      me._isTemporarilyExpanded = true;
    }
  }
  async collapseGutter() {
    const me = this;
    if (me._isTemporarilyExpanded) {
      me.gutterHeight = me.gutterHeight - (me.eventHeightInPixels + me.eventSpacing);
      await me.setEventContentHeight(me.cellContentHeight);
      me._isTemporarilyExpanded = false;
    }
  }
  addCellHeaderContent(cellHeader, cellData) {
    var _me$dayTime;
    const me = this, {
      date: date2,
      day: day2,
      tomorrow
    } = cellData, {
      dayNameFormat,
      dayNumberCompress,
      daySeparator
    } = me, shifted = me === null || me === void 0 ? void 0 : (_me$dayTime = me.dayTime) === null || _me$dayTime === void 0 ? void 0 : _me$dayTime.startShift;
    cellHeader.children = [{
      className: `b-day-name-part b-day-name-day${dayNumberCompress ? " b-day-name-short" : ""}`,
      html: formatDayPart(dayNameFormat, daySeparator[0], date2, shifted && tomorrow)
    }, {
      className: `b-day-name-part b-day-name-date`,
      html: formatDayPart(me.dayNumberFormat, daySeparator[1], date2, shifted && tomorrow, dayNumberCompress)
    }];
    cellHeader.className[me.nonWorkingDayCls] = cellData.isNonWorking;
    cellHeader.className[me.weekendCls] = DateHelper.weekends[day2];
  }
  updateLocalization() {
    if (!this.isConfiguring) {
      this.refresh();
    }
    super.updateLocalization();
  }
};
CalendarRow.initClass();
CalendarRow._$name = "CalendarRow";
var DaySelector = class extends CalendarRow {
  afterConfigure() {
    var _owner$scrollable;
    const me = this, {
      owner
    } = me;
    super.afterConfigure();
    (_owner$scrollable = owner.scrollable) === null || _owner$scrollable === void 0 ? void 0 : _owner$scrollable.ion({
      overflowChange: "onOwnerOverflowChange",
      thisObj: me
    });
    owner.descriptionRenderer = me.descriptionRenderer.bind(me);
    owner.previous = function() {
      this.date = DateHelper.add(owner.date, -owner.duration, "d");
    };
    owner.next = function() {
      this.date = DateHelper.add(owner.date, owner.duration, "d");
    };
    FunctionHelper.before(owner, "updateDate", this.beforeOwnerDateUpdate, this);
  }
  beforeOwnerDateUpdate(date2) {
    this.date = date2;
  }
  onOwnerOverflowChange({
    y
  }) {
    this.headerElement.classList.toggle("b-show-yscroll-padding", Boolean(y));
  }
  onDayNumberClick({
    date: date2
  }) {
    if (this.owner) {
      this.owner.date = date2;
    }
    return false;
  }
  descriptionRenderer() {
    const {
      startDate,
      endDate,
      owner
    } = this, startMonth = startDate.getMonth(), endMonth = endDate.getMonth(), monthDesc = startMonth === endMonth ? DateHelper.format(startDate, "MMMM") : `${DateHelper.format(startDate, "MMM")} - ${DateHelper.format(endDate, "MMM")}`, week = owner.month.getWeekNumber(startDate);
    return `${this.L("L{Object.Week}")} ${week[1]}, ${monthDesc} ${week[0]}`;
  }
};
_defineProperty(DaySelector, "$name", "DaySelector");
_defineProperty(DaySelector, "type", "dayselector");
_defineProperty(DaySelector, "configurable", {
  readOnly: true,
  autoCreate: false,
  flex: "0 0 auto",
  dock: "top"
});
DaySelector.initClass();
DaySelector._$name = "DaySelector";
var DaySelectable = (Target) => class DaySelectable extends (Target || Base$1) {
  static get $name() {
    return "CalendarMixin";
  }
  static get configurable() {
    return {
      daySelector: null
    };
  }
  changeDaySelector(daySelector, oldDaySelector) {
    const me = this;
    if (daySelector) {
      me.range = "1 day";
      me.settings = null;
      me.hideHeaders = true;
      const startDate = me.dayTime.shiftDate(me.month.getWeekStart(me.month.getWeekNumber(me.startDate))), result = DaySelector.reconfigure(oldDaySelector, daySelector, {
        owner: me,
        defaults: {
          type: "dayselector",
          calendar: me.calendar,
          parent: me,
          cls: {
            [`b-${me.type}-dayselector`]: 1
          },
          dayStartShift: me.dayStartShift,
          dayTime: me.dayTime,
          month: me.month,
          date: me.date,
          startDate,
          range: {
            magnitude: 1,
            unit: "week"
          },
          hideNonWorkingDays: me.hideNonWorkingDays,
          nonWorkingDays: me.nonWorkingDays,
          nonWorkingDayCls: me.nonWorkingDayCls,
          weekendCls: me.weekendCls,
          weekStartDay: me.weekStartDay
        }
      });
      me.element.classList.add(`b-${me.type}-with-dayselector`);
      me.tbar = result;
      return result;
    } else {
      oldDaySelector === null || oldDaySelector === void 0 ? void 0 : oldDaySelector.destroy();
    }
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    delete result.daySelector;
    return result;
  }
};
var byStartDate = (lhs, rhs) => lhs.startDate.valueOf() - rhs.startDate.valueOf();
var mergeColumns = (configuredColumns, defaultColumns) => {
  if (defaultColumns) {
    configuredColumns = configuredColumns.data || configuredColumns;
    if (ObjectHelper.isObject(configuredColumns)) {
      const result = defaultColumns.slice();
      for (const id in configuredColumns) {
        const newColumn = configuredColumns[id], matchIndex = result.findIndex((c) => c.id === id || c.field === id);
        if (newColumn) {
          const v = Config.merge(newColumn, result[matchIndex]);
          v.id = id;
          result[matchIndex === -1 ? result.length : matchIndex] = v;
        } else if (matchIndex > -1) {
          result.splice(matchIndex, 1);
        }
      }
      return result;
    } else {
      defaultColumns = new Collection({
        values: defaultColumns,
        idProperty: "field"
      });
      for (let i = 0, {
        length
      } = configuredColumns; i < length; i++) {
        const newColumn = configuredColumns[i], matchedExistingColumn = defaultColumns.get(newColumn.field);
        if (matchedExistingColumn) {
          configuredColumns[i] = Config.merge(newColumn, matchedExistingColumn);
          defaultColumns.remove(matchedExistingColumn);
        }
      }
      configuredColumns.push(...defaultColumns.values);
      return configuredColumns;
    }
  } else {
    return configuredColumns;
  }
};
var EventList = class extends Grid.mixin(CalendarMixin, DayCellCollecter, DaySelectable, DateRangeOwner) {
  static get $name() {
    return "EventList";
  }
  static get type() {
    return "eventlist";
  }
  static get configurable() {
    return {
      cls: "b-slide-vertical",
      eventFilter: null,
      localizableProperties: ["title", "text"],
      title: "L{List}",
      range: "1 month",
      month: true,
      columns: {
        $config: {
          merge: mergeColumns
        },
        value: [{
          text: "L{EventEdit.Name}",
          field: "name",
          flex: 1
        }, {
          text: "L{EventList.Start}",
          type: "date",
          editor: {
            type: "datetime",
            dateField: {
              step: null
            },
            timeField: {
              step: null
            }
          },
          field: "startDate",
          width: "16.5em",
          format: "L LT",
          renderer({
            record,
            value
          }) {
            return record.allDay ? DateHelper.format(value, "L") : this.defaultRenderer(...arguments);
          }
        }, {
          text: "L{EventList.Finish}",
          type: "date",
          editor: {
            type: "datetime",
            dateField: {
              step: null
            },
            timeField: {
              step: null
            }
          },
          field: "endDate",
          width: "16.5em",
          format: "L LT",
          renderer({
            record,
            value
          }) {
            return record.allDay ? DateHelper.format(value, "L") : this.defaultRenderer(...arguments);
          }
        }, {
          type: "widget",
          text: "Resources",
          field: "resources",
          minWidth: 250,
          autoHeight: true,
          widgets: [{
            type: "chipview",
            valueProperty: "items",
            displayField: "name",
            itemsFocusable: false,
            navigator: null,
            closable: false,
            style: {
              flexFlow: "row nowrap",
              display: "flex",
              padding: "5px 0 3px 0"
            },
            scrollable: {
              overflowX: "hidden-scroll",
              overflowY: false
            },
            getItemCls: (r) => DomHelper.isNamedColor(r.eventColor) ? ` b-sch-${r.eventColor}` : "",
            getItemStyle: (r) => `color:#fff;${r.eventColor && !DomHelper.isNamedColor(r.eventColor) ? `background-color:${r.eventColor}` : ""}`
          }],
          editor: false
        }]
      },
      features: {
        group: false,
        rowCopyPaste: false,
        columnPicker: {
          createColumnsFromModel: true
        }
      },
      internalListeners: {
        beforeCellEditStart({
          editorContext
        }) {
          var _this$calendar, _this$calendar$featur, _this$calendar$featur2, _editor$timeField;
          const {
            editor,
            record
          } = editorContext;
          if (record.isRecurring || record.isOccurrence) {
            Toast.show({
              html: "Please use EventEdit to edit recurring events"
            });
            return false;
          }
          (_this$calendar = this.calendar) === null || _this$calendar === void 0 ? void 0 : (_this$calendar$featur = _this$calendar.features.eventTooltip) === null || _this$calendar$featur === void 0 ? void 0 : (_this$calendar$featur2 = _this$calendar$featur._tooltip) === null || _this$calendar$featur2 === void 0 ? void 0 : _this$calendar$featur2.hide();
          (_editor$timeField = editor.timeField) === null || _editor$timeField === void 0 ? void 0 : _editor$timeField[record.allDay ? "hide" : "show"]();
        }
      },
      settings: {
        $config: "lazy",
        value: null
      },
      eventListTimeFormat: "HH:mm"
    };
  }
  static get delayable() {
    return {
      populateStoreSoon: {
        type: "raf",
        cancelOutstanding: true
      }
    };
  }
  doRefresh() {
    this.refreshRows();
  }
  eventListEventTimeRenderer(eventRecord) {
    const me = this, daySpan = DateHelper.diff(DateHelper.clearTime(eventRecord.startDate), DateHelper.clearTime(eventRecord.endDate), "day"), timeString = me.eventTimeRenderer ? me.callback(me.eventTimeRenderer, me, arguments) : daySpan > 1 ? me.L("L{Calendar.endsOn}", DateHelper.format(eventRecord.endDate, "DD MMM")) : eventRecord.allDay ? me.L("L{Calendar.allDay}") : `${DateHelper.format(eventRecord.startDate, me.eventListTimeFormat)} - ${DateHelper.format(eventRecord.endDate, me.eventListTimeFormat)}`;
    return {
      className: {
        "b-cal-eventlist-event-time": 1
      },
      text: timeString
    };
  }
  agendaEventDateRenderer(date2) {
    return {
      className: {
        "b-day-name": 1,
        "b-cal-agenda-date": 1,
        "b-today": !Boolean(DateHelper.clearTime(new Date()) - DateHelper.clearTime(date2))
      },
      children: [{
        className: {
          "b-cal-agenda-date-date-number": 1
        },
        text: date2.getDate()
      }, {
        className: {
          "b-cal-agenda-date-date-text": 1
        },
        children: [{
          text: DateHelper.format(date2, "dddd")
        }, {
          text: DateHelper.format(date2, "MMM YYYY")
        }]
      }]
    };
  }
  destroy() {
    for (const feature of Object.values(this.features)) {
      var _feature$destroy;
      (_feature$destroy = feature.destroy) === null || _feature$destroy === void 0 ? void 0 : _feature$destroy.call(feature);
    }
    super.destroy();
  }
  populateHeaderMenu({
    items: items2
  }) {
    items2.listRangeItem = {
      weight: -1e3,
      icon: "b-icon-calendar-week",
      text: "List Range",
      menu: this.listRangeMenu
    };
    super.populateHeaderMenu(...arguments);
  }
  refreshVirtualScrollbars() {
    super.refreshVirtualScrollbars();
    this.bodyElement.classList[DomHelper.scrollBarWidth && this.hasVerticalOverflow ? "add" : "remove"]("b-has-scrollbar");
  }
  get listRangeMenu() {
    const me = this, {
      unit
    } = me.range;
    if (!me._listRangeMenu) {
      const toggleGroup = `${me.id}-range-items`;
      me._listRangeMenu = {
        anchor: true,
        onToggle: (e) => {
          if (e.checked) {
            me.range = e.item.range;
            e.bubbles = false;
          }
          if (DomHelper.scrollBarWidth) {
            e.menu.realign();
          }
        },
        items: {
          listRangeDayItem: {
            toggleGroup,
            range: "day",
            text: "L{EventEdit.day}",
            _unit: "day"
          },
          listRangeWeekItem: {
            toggleGroup,
            range: "week",
            text: "L{EventEdit.week}",
            _unit: "week"
          },
          listRangeMonthItem: {
            toggleGroup,
            range: "month",
            text: "L{EventEdit.month}",
            _unit: "month"
          },
          listRangeYearItem: {
            toggleGroup,
            range: "year",
            text: "L{EventEdit.year}",
            _unit: "year"
          },
          listRangeDecadeItem: {
            toggleGroup,
            range: "decade",
            text: "L{EventEdit.decade}",
            _unit: "decade"
          }
        }
      };
    }
    for (const i of Object.values(me._listRangeMenu.items)) {
      i.checked = i._unit === unit;
    }
    return me._listRangeMenu;
  }
  updateRowManager(rowManager) {
    var _super$updateRowManag;
    (_super$updateRowManag = super.updateRowManager) === null || _super$updateRowManag === void 0 ? void 0 : _super$updateRowManag.call(this, ...arguments);
    rowManager.ion({
      beforeRenderRow: "onBeforeRenderRow",
      thisObj: this
    });
  }
  onBeforeRenderRow({
    row,
    record
  }) {
    const {
      _elementsArray
    } = row, {
      id,
      startDate
    } = record;
    if (record.isEventModel) {
      for (let i = 0, {
        length
      } = _elementsArray; i < length; i++) {
        _elementsArray[i].dataset.eventId = id;
        _elementsArray[i].dataset.date = DateHelper.makeKey(startDate);
      }
      row.cls[`b-day-of-week-${startDate.getDay()}`] = 1;
    }
  }
  onInternalKeyDown(domEvent) {
  }
  handleEvent(domEvent) {
    this.preventScroll = true;
    super.handleEvent(domEvent);
    this.preventScroll = false;
  }
  get displayName() {
    let s = this.title;
    if (typeof s !== "string") {
      s = this.type;
    }
    return StringHelper.capitalize(s);
  }
  async scrollTo(target, options = {
    animate: true
  }) {
    const me = this;
    if (target instanceof me.store.modelClass) {
      await me.scrollRowIntoView(target, Object.assign({}, options, {
        highlight: false
      }));
      if (options.highlight) {
        target = me.getEventElement(target, target.startDate);
        if (typeof options.highlight === "boolean") {
          DomHelper.highlight(target, me);
        } else {
          (me.widget || me).callback(options.highlight, null, [target]);
        }
      }
    } else if (ObjectHelper.isDate(target) && me.store.count) {
      const index = me.dateIndex, key = DateHelper.makeKey(target);
      if (index[key]) {
        await me.scrollRowIntoView(index[key], options);
        me.scrolledToDate = target;
      } else {
        let closest = Number.MAX_SAFE_INTEGER;
        const keys = Object.keys(index);
        for (let i = 0, {
          length
        } = keys; i < length; i++) {
          const d = DateHelper.parseKey(keys[i]);
          if (Math.abs(d - target) < Math.abs(closest - target)) {
            closest = d;
          }
        }
        await me.scrollTo(closest);
      }
    }
  }
  updateStartDate() {
    const {
      refreshCount
    } = this;
    this.preventScroll = true;
    super.updateStartDate(...arguments);
    this.preventScroll = false;
    if (!this.isConfiguring && this.refreshCount === refreshCount) {
      this.populateStoreSoon();
    }
  }
  updateEndDate() {
    var _super$updateEndDate;
    const {
      refreshCount
    } = this;
    (_super$updateEndDate = super.updateEndDate) === null || _super$updateEndDate === void 0 ? void 0 : _super$updateEndDate.call(this, ...arguments);
    if (!this.isConfiguring && this.refreshCount === refreshCount) {
      this.populateStoreSoon();
    }
  }
  updateRange() {
    var _super$updateRange;
    const {
      refreshCount
    } = this;
    (_super$updateRange = super.updateRange) === null || _super$updateRange === void 0 ? void 0 : _super$updateRange.call(this, ...arguments);
    if (!this.isConfiguring && this.refreshCount === refreshCount) {
      this.populateStoreSoon();
    }
  }
  descriptionRenderer() {
    const me = this, {
      date: date2,
      startDate,
      endDate,
      range,
      count
    } = me;
    let rangeDesc;
    if (range.magnitude === 1) {
      switch (range.unit) {
        case "day":
          rangeDesc = DateHelper.format(date2, "L");
          break;
        case "week": {
          const startMonth = startDate.getMonth(), endMonth = endDate.getMonth(), monthDesc = startMonth === endMonth ? DateHelper.format(startDate, "MMMM") : `${DateHelper.format(startDate, "MMM")} - ${DateHelper.format(endDate, "MMM")}`, week = me.month.getWeekNumber(startDate);
          rangeDesc = `${me.L("L{Object.Week}")} ${week[1]}, ${monthDesc} ${week[0]}`;
          break;
        }
        case "month":
          rangeDesc = DateHelper.format(date2, "MMMM, YYYY");
          break;
        case "year":
          rangeDesc = DateHelper.format(date2, "YYYY");
          break;
        case "decade":
          rangeDesc = `${DateHelper.format(startDate, "YYYY")}s`;
      }
    } else {
      rangeDesc = `${DateHelper.format(me.startDate, "L")} - ${DateHelper.format(me.endDate, "L")}`;
    }
    return `${rangeDesc}. ${me.L("eventCount", count)}`;
  }
  get count() {
    return this.store.count;
  }
  get stepUnit() {
    const {
      range
    } = this;
    return range.magnitude === 1 ? range.unit : this.range;
  }
  updateEventStore(eventStore) {
    var _super$updateEventSto;
    (_super$updateEventSto = super.updateEventStore) === null || _super$updateEventSto === void 0 ? void 0 : _super$updateEventSto.call(this, eventStore);
    eventStore.ion({
      refresh: "onCalendarStoreChange",
      thisObj: this
    });
    this.populateStoreSoon();
  }
  changeStore(store) {
    var _store;
    const me = this;
    if (store) {
      store = Store.mergeConfigs({
        useRawData: {
          ignoreDefaults: true,
          disableDefaultValue: true,
          disableTypeConversion: true,
          enabled: true
        },
        modelClass: me.modelClass
      }, store);
    }
    store = super.changeStore(store);
    if ((_store = store) !== null && _store !== void 0 && _store.modelClass.isEventModel) {
      me.nonWorkingDaysFilter = store.addFilter({
        id: `${me.id}-nonworkingday-filter`,
        filterBy: (event) => !me.dayTime.isIntraDay(event) || !me.hiddenNonWorkingDays[event.startDate.getDay()],
        disabled: !me.hideNonWorkingDays
      }, true);
    }
    return store;
  }
  updateHideNonWorkingDays(hideNonWorkingDays) {
    const me = this, {
      store
    } = me;
    super.updateHideNonWorkingDays(hideNonWorkingDays);
    if (store) {
      me.nonWorkingDaysFilter.disabled = !hideNonWorkingDays;
      store.filter();
    }
    me.trigger("refresh");
  }
  afterRemove({
    records
  }) {
    this.eventStore.remove(records);
    super.afterRemove(...arguments);
  }
  get modelClass() {
    return this.eventStore.modelClass;
  }
  populateStoreSoon() {
    const me = this, {
      project
    } = me;
    if (me.isVisible) {
      if (project.isInitialCommitPerformed && !project.isWritingData || !project.eventStore.count) {
        me.populateStore();
      }
    } else {
      me.whenVisible("populateStore");
    }
  }
  populateStore() {
    var _me$calendar;
    const me = this, events = me.eventStore.getEvents({
      startDate: me.startDate,
      endDate: me.endDate,
      filter: me.eventFilter
    }).sort(byStartDate);
    me.dateIndex = events.reduce((result, event) => {
      const key = DateHelper.makeKey(event.startDate);
      if (!result[key]) {
        result[key] = event;
      }
      return result;
    }, {});
    me.store.data = events;
    me.trigger("refresh");
    (_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.syncUIWithActiveView(this);
  }
  changeMonth() {
    const result = super.changeMonth(...arguments);
    result.ion({
      dateChange: "onMonthChange",
      thisObj: this
    });
    return result;
  }
  onMonthChange({
    newDate
  }) {
    const me = this, {
      startDate
    } = me, newStartDate = me.changeStartDate(newDate);
    if (!startDate || newStartDate - startDate) {
      me.updateRange(me.range);
    }
    if (!me.preventScroll && me.isVisible && me.store.count) {
      me.populateStoreSoon.flush();
      me.scrollTo(newDate);
    }
  }
  onCalendarStoreChange({
    source: eventStore
  }) {
    if (!this.date) {
      this.date = eventStore.map((r) => r.startDate).sort((lhs, rhs) => lhs.valueOf() - rhs.valueOf())[0];
    }
    this.populateStoreSoon();
  }
  changeSettings(settings, oldSettings) {
    return settings && Button.reconfigure(oldSettings, Button.mergeConfigs({
      type: "button",
      positioned: true,
      icon: "b-icon-cog",
      menuIcon: null,
      cls: "b-blue b-cal-widget-settings-button",
      appendTo: this.bodyElement
    }, settings), this);
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    delete result.store;
    delete result.data;
    return result;
  }
};
EventList.initClass();
EventList._$name = "EventList";
var isMouseOverOut = {
  mouseover: 1,
  mouseout: 1
};
var isMouseInteraction = {
  mousedown: 1,
  mouseup: 1,
  click: 1,
  dblclick: 1,
  contextmenu: 1
};
var AgendaView = class extends EventList.mixin(Responsive) {
  static get $name() {
    return "AgendaView";
  }
  static get type() {
    return "agendaview";
  }
  static get configurable() {
    return {
      features: null,
      eventSorter: EventSorter.interDaySorterFn,
      eventRowSpacing: 8,
      title: "L{Agenda}",
      range: "year",
      hideEventOverflow: null,
      offsetStartsBeforeEvents: true,
      handlePointerInteraction: false,
      dayCellRenderer: null,
      eventRenderer: null,
      hideHeaders: true,
      columns: {
        name: null,
        startDate: null,
        endDate: null,
        resources: null,
        agenda: {
          type: "agendacolumn"
        }
      },
      eventTimeRenderer: null,
      enableSticky: true,
      preserveScrollOnDatasetChange: true,
      positionMode: "position",
      settings: {},
      cellTabIndex: null,
      rowCls: {
        "b-cal-agenda-grid-row": 1
      },
      cellCls: {
        "b-calendar-cell": 1
      },
      eventBarContainerCls: "b-cal-event-bar-container",
      keyMap: null
    };
  }
  construct(config) {
    const me = this;
    Object.defineProperty(me, "features", {
      get: () => {
        return {};
      },
      set: () => {
      }
    });
    super.construct(config);
    me.bodyContainer.removeAttribute("tabIndex");
  }
  onResponsiveStateChange({
    state,
    oldState
  }) {
    var _super$onResponsiveSt;
    (_super$onResponsiveSt = super.onResponsiveStateChange) === null || _super$onResponsiveSt === void 0 ? void 0 : _super$onResponsiveSt.call(this, ...arguments);
    if (oldState && (oldState === "small" || state === "small")) {
      this.refresh();
    }
  }
  changeColumns() {
    var _result$forEach;
    const result = super.changeColumns(...arguments);
    result === null || result === void 0 ? void 0 : (_result$forEach = result.forEach) === null || _result$forEach === void 0 ? void 0 : _result$forEach.call(result, (c) => {
      c.autoHeight = Boolean(!c.isAgendaColumn || c.renderer || this.eventRenderer);
    });
    return result;
  }
  onFocusGesture() {
  }
  onGridElementFocus() {
  }
  onGridBodyFocusIn() {
  }
  focusCell() {
  }
  setHoveredRow() {
  }
  onElementKeyDown() {
  }
  onElementMouseDown() {
  }
  editAutoCreatedEvent(event, eventRecord) {
    this.populateStoreSoon.now();
    super.editAutoCreatedEvent(event, eventRecord);
  }
  handleEvent(event) {
    const {
      type
    } = event;
    super.handleEvent(event);
    if (isMouseOverOut[event.type]) {
      this.onEventMouseOverOut(event);
    } else if (isMouseInteraction[type]) {
      this.onCalendarPointerInteraction(event);
    }
  }
  getCellDataFromEvent(domEvent) {
    if (domEvent.target.closest(".b-grid-cell")) {
      const result = super.getCellDataFromEvent(domEvent);
      result && (result.record = this.getEventRecord(domEvent.target));
      return result;
    }
  }
  updateOffsetStartsBeforeEvents(offsetStartsBeforeEvents) {
    this.element.classList.toggle("b-offset-continues-past", Boolean(offsetStartsBeforeEvents));
  }
  updateEventRowSpacing(eventRowSpacing) {
    this.contentElement.style.setProperty("--event-row-spacing", DomHelper.setLength(eventRowSpacing));
  }
  updateSuppressLongEvents() {
    this.fillFromMaster();
  }
  onCalendarStoreChange({
    action,
    oldCount,
    records,
    removed,
    added
  }) {
    const me = this;
    if (me.isPainted) {
      if (action === "filter" && !(removed !== null && removed !== void 0 && removed.length) && !(added !== null && added !== void 0 && added.length)) {
        return;
      }
      if (action === "dataset") {
        return;
      }
      if (action === "remove" && records.length === 1 && records[0].isEventModel) {
        const {
          store
        } = me, eventRecord = records[0], date2 = DateHelper.clearTime(eventRecord.startDate), endDate = DateHelper.clearTime(eventRecord.endDate);
        do {
          const key = DateHelper.makeKey(date2), cellData = me.cellMap.get(key);
          if (cellData) {
            ArrayHelper.remove(cellData.events, eventRecord);
            if (cellData.events.length) {
              me.onStoreUpdateRecord({
                source: store,
                record: me.store.getById(key),
                changes: {}
              });
            } else {
              me.cellMap.delete(key);
              delete me.dateIndex[key];
              store.remove(key, true);
            }
          }
          date2.setDate(date2.getDate() + 1);
        } while (date2 < endDate);
        return;
      }
    }
    me.populateStoreSoon();
  }
  get cellMap() {
    var _this$_cellMap;
    return (_this$_cellMap = this._cellMap) !== null && _this$_cellMap !== void 0 && _this$_cellMap.populated ? this._cellMap : this.createCellMap({
      rawEvents: true,
      skipPropagate: true
    });
  }
  populateStore() {
    var _this$_cellMap2, _rowManager$rows, _me$calendar, _me$settings, _me$settings$_menu;
    (_this$_cellMap2 = this._cellMap) === null || _this$_cellMap2 === void 0 ? void 0 : _this$_cellMap2.clear();
    const me = this, {
      store,
      eventStore,
      rowManager
    } = me, {
      rowHeight
    } = rowManager, rowCount = (_rowManager$rows = rowManager.rows) === null || _rowManager$rows === void 0 ? void 0 : _rowManager$rows.length, eventHeight = isNaN(me.eventHeight) ? 25 : me.eventHeight;
    me.eventCount = 0;
    if (!me.date) {
      me.isConfiguring = true;
      me.date = eventStore.map((r) => r.startDate).sort((lhs, rhs) => lhs.valueOf() - rhs.valueOf())[0];
      me.isConfiguring = false;
    }
    const {
      cellMap
    } = me, cellMapEntries = [...cellMap.values()];
    me.dateIndex = {};
    for (let i = 0, {
      length
    } = cellMapEntries; i < length; i++) {
      const cellData = cellMapEntries[i], {
        events,
        date: date2
      } = cellData;
      for (let j = 0, {
        length: length2
      } = events; j < length2; j++) {
        const event = events[j];
        if (!me.isAllDayEvent(event) || !i || DateHelper.clearTime(event.startDate).valueOf() === date2.valueOf()) {
          me.eventCount++;
        }
      }
      me.dateIndex[cellData.id] = cellMapEntries[i] = store.createRecord(cellData);
    }
    const avgEventsPerCell = me.eventCount ? cellMapEntries.map((e) => e.events.length).reduce((a, b) => a + b, 0) / cellMapEntries.length : 0;
    store.suspendEvents();
    store.loadData(cellMapEntries);
    store.resumeEvents();
    rowManager._rowHeight = 20;
    if (store.count) {
      rowManager.rowHeight = Math.max(avgEventsPerCell * (eventHeight + me.eventSpacing), 70);
    }
    if (!rowCount || !store.count || rowManager.rowHeight === rowHeight) {
      rowManager.calculateRowCount();
      rowManager.estimateTotalHeight(true);
    }
    me.refreshCount = (me.refreshCount || 0) + 1;
    me.trigger("refresh");
    (_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.syncUIWithActiveView(me);
    me.columns.forEach((c) => {
      var _c$constructor$expose, _c$constructor;
      return (_c$constructor$expose = (_c$constructor = c.constructor).exposeProperties) === null || _c$constructor$expose === void 0 ? void 0 : _c$constructor$expose.call(_c$constructor);
    });
    (_me$settings = me.settings) === null || _me$settings === void 0 ? void 0 : (_me$settings$_menu = _me$settings._menu) === null || _me$settings$_menu === void 0 ? void 0 : _me$settings$_menu.realign();
  }
  get count() {
    return this.eventCount;
  }
  collectEvents(options) {
    options.getDateIndex = (date2) => date2 > this.startDate && this.hideEventOverflow ? "startDate" : "date";
    return this.eventStore.getEvents(options);
  }
  changeStore(store) {
    store = super.changeStore(store);
    if (store) {
      this.nonWorkingDaysFilter = store.addFilter({
        id: `${this.id}-nonworkingday-filter`,
        filterBy: (rec) => !rec.isNonWorking,
        disabled: !this.hideNonWorkingDays
      }, true);
      this.detachListeners("agendaStoreFilter");
      store.on({
        name: "agendaStoreFilter",
        filter: "onAgendaStoreFilter",
        thisObj: this
      });
    }
    return store;
  }
  get modelClass() {
    return GridRowModel;
  }
  onAgendaStoreFilter() {
    const me = this;
    me.eventCount = me.store.reduce((result, rec, i) => {
      const {
        events,
        date: date2
      } = rec;
      for (let j = 0, {
        length
      } = events; j < length; j++) {
        const event = events[j];
        if (!me.isAllDayEvent(event) || !i || DateHelper.clearTime(event.startDate).valueOf() === date2.valueOf()) {
          result++;
        }
      }
      return result;
    }, 0);
  }
  updateHideEventOverflow() {
    this.populateStore();
  }
  doRefresh() {
    this.populateStore();
  }
  createCellData(date2) {
    return Object.assign(this.cellMonth.getCellData(date2, this.month), {
      id: DateHelper.makeKey(date2),
      events: []
    });
  }
  set cellRenderer(cellRenderer) {
    this._cellRenderer = cellRenderer;
  }
  changeSettings(settings) {
    return settings && super.changeSettings({
      menu: _objectSpread2({
        align: {
          align: "t100-b100"
        }
      }, this.listRangeMenu)
    });
  }
};
AgendaView.initClass();
AgendaView._$name = "AgendaView";
var CalendarDatePicker = class extends SchedulerDatePicker.mixin(EventRenderer) {
  construct(config) {
    if (!config.eventStore) {
      var _ref;
      const calendar = (_ref = config.owner || config.parent) === null || _ref === void 0 ? void 0 : _ref.up("calendar");
      calendar && (config.eventStore = calendar.eventStore);
    }
    super.construct(...arguments);
  }
  updateMaxDots() {
    this.refresh();
  }
  refreshEventsMap() {
    const me = this;
    if (me.showEvents) {
      me.eventsMap = me.eventStore[me.showEvents === "dots" ? "getEvents" : "getEventCounts"]({
        startDate: me.startDate,
        endDate: me.endDate,
        dateMap: me.eventsMap || (me.eventsMap = /* @__PURE__ */ new Map())
      });
    }
  }
  cellRenderer({
    cell,
    date: date2
  }) {
    var _this$eventsMap, _this$eventsMap$get;
    const {
      showEvents
    } = this, isCount = showEvents === "count", isDots = showEvents === "dots", eventInfo = (_this$eventsMap = this.eventsMap) === null || _this$eventsMap === void 0 ? void 0 : (_this$eventsMap$get = _this$eventsMap.get) === null || _this$eventsMap$get === void 0 ? void 0 : _this$eventsMap$get.call(_this$eventsMap, DateHelper.makeKey(date2)), count = isDots ? eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.length : eventInfo, countCls = isCount ? "b-cell-events-badge" : isDots ? "b-cal-minimal-event-container" : "b-icon b-icon-circle";
    if (isDots) {
      cell.innerHTML = "";
      DomHelper.createElement({
        class: "b-date-cell-inner",
        text: date2.getDate(),
        parent: cell
      });
    }
    delete cell.parentNode.dataset.btip;
    if (count) {
      if (!isCount && this.eventCountTip) {
        cell.parentNode.dataset.btip = this.L("L{ResourceInfoColumn.eventCountText}", count);
      }
      const cellContent = {
        dataset: {
          count
        },
        class: {
          [countCls]: 1,
          [SchedulerDatePicker.getEventCountClass(count)]: 1
        },
        parent: cell,
        [isCount ? "text" : ""]: count
      };
      if (isDots) {
        const children = cellContent.children = [];
        for (let i = 0; i < Math.min((eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.length) || 0, this.maxDots); i++) {
          const eventDomConfig = this.createEventDomConfig({
            eventRecord: eventInfo[i],
            minimal: true
          });
          children.push(eventDomConfig);
        }
      }
      DomHelper.createElement(cellContent);
    }
  }
  static setupClass(meta) {
    meta.replaceType = true;
    super.setupClass(meta);
  }
};
_defineProperty(CalendarDatePicker, "$name", "CalendarDatePicker");
_defineProperty(CalendarDatePicker, "type", "datepicker");
_defineProperty(CalendarDatePicker, "configurable", {
  showEvents: null,
  maxDots: 4,
  eventCountTip: null,
  alwaysRefreshOnMonthChange: true
});
CalendarDatePicker.initClass();
CalendarDatePicker._$name = "CalendarDatePicker";
var {
  MILLIS_PER_HOUR
} = DayTime;
var widestDate = new Date(2020, 10, 22, 22, 59, 59);
var blockedAllDayEvents = {
  paint: 1,
  refresh: 1,
  resize: 1,
  eventspercellchange: 1
};
var stopEvent = (e) => {
  e.stopImmediatePropagation();
  e.cancelBubble = true;
};
var preventDefault = (e) => e.ctrlKey && e.preventDefault();
var hourHeightLevelZero = {
  level: 0,
  step: "1 hour"
};
var zeroRect = new Rectangle(0, 0, 0, 0);
var fiveMinuteSteps = ["30 minutes", "15 minutes", "10 minutes", "5 minutes"];
var sixMinuteSteps = ["30 minutes", "12 minutes", "6 minutes"];
var DayView = class extends Panel.mixin(CalendarMixin, DayCellCollecter, DaySelectable, DateRangeOwner) {
  static get $name() {
    return "DayView";
  }
  static get type() {
    return "dayview";
  }
  static get delayable() {
    return {
      updateElementLayout: {
        type: "raf",
        cancelOutstanding: true
      },
      refreshDayBackground: {
        type: "raf",
        cancelOutstanding: true
      }
    };
  }
  static get configurable() {
    return {
      textContent: false,
      scrollable: {
        overflowY: true
      },
      title: "L{Day}",
      eventRenderer: null,
      eventHeight: "auto",
      hourHeight: 42,
      range: {
        magnitude: 1,
        unit: "day"
      },
      fixedDuration: null,
      visibleStartTime: 7,
      dayStartShift: null,
      dayStartTime: null,
      dayEndTime: null,
      dayTime: 0,
      increment: "15 min",
      intradayCls: null,
      showTime: true,
      showCircle: false,
      iconTarget: "header",
      eventLayout: {
        type: "fluid"
      },
      minDayWidth: null,
      eventColourStyleProperty: "backgroundColor",
      monitorResize: Boolean(DomHelper.scrollBarWidth),
      eventFilter: void 0,
      timeFormat: "LST",
      allDayEvents: {
        $config: ["lazy", "nullify"],
        value: {}
      },
      overflowPopup: null,
      showAllDayHeader: {
        value: null,
        $config: null,
        default: true
      },
      eventSpacing: 1,
      responsive: {
        small: {
          descriptionFormat: "MMMM YYYY"
        },
        "*": {
          descriptionFormat: null
        }
      },
      maxAllDayHeight: null,
      fitHours: null,
      dayCellRenderer: null,
      coreHours: null,
      zoomOnMouseWheel: !BrowserHelper.isTouchDevice,
      hourHeightBreakpoints: [70, 140, 300, 500],
      sixMinuteTicks: null,
      minEventHeight: "1em",
      shortEventHeight: 32,
      currentTimeIndicatorRenderer: () => {
        return {
          className: "b-current-time-indicator",
          retainElement: true
        };
      }
    };
  }
  construct(config) {
    var _config$scrollable;
    const me = this;
    me.configuredHiddenVerticalScroll = ((_config$scrollable = config.scrollable) === null || _config$scrollable === void 0 ? void 0 : _config$scrollable.overflowY) === "hidden-scroll";
    me.cellMapEventFilter = me.cellMapEventFilter.bind(me);
    super.construct(...arguments);
    if (!me.startDate) {
      me.startDate = me.month.date;
    }
    GlobalEvents$1.ion({
      theme: "onThemeChange",
      thisObj: me
    });
  }
  get hasNonWorkingDays() {
    return true;
  }
  updateZoomOnMouseWheel(zoomOnMouseWheel) {
    if (zoomOnMouseWheel) {
      this.zoomListener = EventHelper.on({
        element: this.dayContentElement,
        wheel: "onDayContentMousewheel",
        thisObj: this,
        throttled: {
          buffer: 100,
          alt: preventDefault
        }
      });
    } else {
      var _this$zoomListener;
      (_this$zoomListener = this.zoomListener) === null || _this$zoomListener === void 0 ? void 0 : _this$zoomListener.call(this);
    }
  }
  get childItems() {
    const {
      allDayEvents
    } = this, result = super.childItems;
    if (allDayEvents) {
      result.push(allDayEvents);
    }
    return result;
  }
  get dayEndTime() {
    var _this$dayTime$timeEnd, _this$dayTime;
    return (_this$dayTime$timeEnd = (_this$dayTime = this.dayTime) === null || _this$dayTime === void 0 ? void 0 : _this$dayTime.timeEnd) !== null && _this$dayTime$timeEnd !== void 0 ? _this$dayTime$timeEnd : this._dayEndTime;
  }
  get dayStartTime() {
    var _this$dayTime$timeSta, _this$dayTime2;
    return (_this$dayTime$timeSta = (_this$dayTime2 = this.dayTime) === null || _this$dayTime2 === void 0 ? void 0 : _this$dayTime2.timeStart) !== null && _this$dayTime$timeSta !== void 0 ? _this$dayTime$timeSta : this._dayStartTime;
  }
  get dayStartShift() {
    var _this$dayTime$startSh, _this$dayTime3;
    return (_this$dayTime$startSh = (_this$dayTime3 = this.dayTime) === null || _this$dayTime3 === void 0 ? void 0 : _this$dayTime3.startShift) !== null && _this$dayTime$startSh !== void 0 ? _this$dayTime$startSh : this._dayStartShift;
  }
  updateDayEndTime(dayEndTime) {
    this._dayTime = null;
    this.dayTime = new DayTime({
      startShift: this.dayStartShift,
      timeStart: this.dayStartTime,
      timeEnd: dayEndTime
    });
  }
  updateDayStartTime(dayStartTime) {
    this._dayTime = null;
    this.dayTime = new DayTime({
      startShift: this.dayStartShift,
      timeStart: dayStartTime,
      timeEnd: this.dayEndTime
    });
  }
  updateDayStartShift(dayStartShift) {
    this._dayTime = null;
    this.dayTime = new DayTime({
      startShift: dayStartShift,
      timeStart: this.dayStartTime,
      timeEnd: this.dayEndTime
    });
  }
  changeDayTime(dayTime) {
    var _this$_dayTime;
    if (!dayTime) {
      dayTime = new DayTime(this);
    }
    if (!((_this$_dayTime = this._dayTime) !== null && _this$_dayTime !== void 0 && _this$_dayTime.equals(dayTime))) {
      return dayTime;
    }
  }
  updateDayTime(dayTime, was) {
    const me = this, {
      eventStore
    } = me;
    if (eventStore) {
      eventStore.registerDayIndex(dayTime);
      was && eventStore.unregisterDayIndex(was);
    }
    if (!me.isConfiguring) {
      var _me$allDayEvents;
      const {
        startDate
      } = me;
      me.syncHours();
      me.setConfig({
        date: startDate,
        startDate
      });
      (_me$allDayEvents = me.allDayEvents) === null || _me$allDayEvents === void 0 ? void 0 : _me$allDayEvents.setConfig({
        date: startDate,
        dayTime,
        startDate
      });
    }
  }
  dateKey(date2) {
    return this.dayTime.dateKey(date2);
  }
  dayOfDate(date2) {
    return date2 && this.dayTime.dayOfDate(date2);
  }
  async scrollTo(target, options = {
    animate: true
  }) {
    const me = this, {
      allDayEvents
    } = me;
    if (me.scrollPromise) {
      await me.scrollPromise;
    }
    await (allDayEvents === null || allDayEvents === void 0 ? void 0 : allDayEvents.heightAnimation);
    if (me.isDestroyed) {
      return;
    }
    if (typeof target === "number") {
      target = DateHelper.add(me.startDate, target, "hour");
    }
    const targetIsDate = Boolean(target.getHours);
    await super.scrollTo(target, Object.assign({}, options, {
      y: !targetIsDate
    }));
    if (targetIsDate) {
      target = target.getHours() + target.getMinutes() / 60;
      return me.scrollable.scrollTo(null, me.getPositionFromTime(target), options);
    }
  }
  getEventElement(event, date2) {
    var _this$allDayEvents;
    return super.getEventElement(event, date2) || ((_this$allDayEvents = this.allDayEvents) === null || _this$allDayEvents === void 0 ? void 0 : _this$allDayEvents.getEventElement(event, date2));
  }
  getEventElements(event) {
    var _this$allDayEvents2;
    return super.getEventElements(event) || ((_this$allDayEvents2 = this.allDayEvents) === null || _this$allDayEvents2 === void 0 ? void 0 : _this$allDayEvents2.getEventElements(event));
  }
  getPositionFromTime(time) {
    if (DayTime.parse(time) < DayTime.parse(this.dayStartTime) - this.dayStartShift) {
      return 0;
    }
    return this.dayTime.delta(time, "h") * this.hourHeight;
  }
  updateShowAllDayHeader(showAllDayHeader) {
    var _me$_cellMap, _allDayEvents$_cellMa;
    const me = this, {
      _allDayEvents
    } = me;
    (_me$_cellMap = me._cellMap) === null || _me$_cellMap === void 0 ? void 0 : _me$_cellMap.clear();
    _allDayEvents === null || _allDayEvents === void 0 ? void 0 : (_allDayEvents$_cellMa = _allDayEvents._cellMap) === null || _allDayEvents$_cellMa === void 0 ? void 0 : _allDayEvents$_cellMa.clear();
    if (_allDayEvents) {
      _allDayEvents.element.classList.toggle("b-hide-allday-header", !showAllDayHeader);
      _allDayEvents.refresh();
    }
    me.refresh();
  }
  changeAllDayEvents(alldayEvents, oldAlldayEvents) {
    if (!alldayEvents) {
      return oldAlldayEvents === null || oldAlldayEvents === void 0 ? void 0 : oldAlldayEvents.destroy();
    }
    this.getConfig("date");
    const me = this, {
      autoCreate,
      dayHeaderRenderer,
      overflowButtonRenderer,
      overflowClickAction,
      overflowPopup,
      avatarRendering,
      range
    } = me, result = CalendarRow.reconfigure(oldAlldayEvents, alldayEvents, {
      owner: me,
      defaults: {
        type: "calendarrow",
        calendar: me.calendar,
        parent: me,
        rtl: me.rtl,
        cls: {
          "b-dayview-schedule-container": 1,
          "b-dayview-initializing": 1
        },
        [overflowPopup !== void 0 ? "overflowPopup" : "_"]: overflowPopup,
        [overflowButtonRenderer ? "overflowButtonRenderer" : "_"]: overflowButtonRenderer,
        [overflowClickAction ? "overflowClickAction" : "_"]: overflowClickAction,
        [dayHeaderRenderer ? "dayHeaderRenderer" : "_"]: dayHeaderRenderer,
        [avatarRendering ? "avatarRendering" : "_"]: avatarRendering,
        autoCreate: autoCreate ? {
          newName: autoCreate.newName,
          gesture: autoCreate.gesture,
          startHour: 0,
          duration: "1 day"
        } : null,
        dayNameSelector: ".b-day-name-date",
        eventFilter: (e) => me.showAllDayHeader && me.isAllDayEvent(e) && (!me.eventFilter || me.eventFilter(e)),
        dayStartTime: me.dayStartTime,
        dayEndTime: me.dayEndTime,
        dayStartShift: me.dayStartShift,
        eventRenderer: me.eventRenderer,
        eventStore: me.eventStore,
        month: me.month,
        fullWeek: me.duration === 1,
        startDate: me.startDate,
        [range ? "range" : "_"]: range,
        [range ? "_" : "endDate"]: me.endDate,
        nonWorkingDays: me.nonWorkingDays,
        nonWorkingDayCls: me.nonWorkingDayCls,
        weekendCls: me.weekendCls,
        weekStartDay: me.weekStartDay,
        defaultCalendar: me.defaultCalendar,
        emptyCellRenderer: me.emptyCellRenderer,
        internalListeners: {
          heightChange: "updateElementLayout",
          refresh: "updateElementLayout",
          catchall: "relayAllDayEvents",
          showoverflowpopup: "onAllDayOverflowPopupShown",
          thisObj: me
        },
        editAutoCreatedEvent(eventRecord) {
          (me.showAllDayHeader ? this : me).trigger("eventAutoCreated", {
            eventRecord
          });
        },
        createCellMap() {
          return me.showAllDayHeader ? this.constructor.prototype.createCellMap.call(this, ...arguments) : me.emptyMap || (me.emptyMap = /* @__PURE__ */ new Map());
        }
      },
      setup(config) {
        config.hideNonWorkingDays = me.duration === 1 && !config.fullWeek ? false : me._hideNonWorkingDays;
      }
    });
    if (result) {
      result.height = result.flex = null;
      me.originalAllDayEventsScrollTo = result.scrollTo;
      result.scrollTo = me.allDayEventsScrollTo.bind(me);
    }
    return result;
  }
  onAllDayOverflowPopupShown({
    overflowPopup
  }) {
    this._overflowPopup = overflowPopup;
  }
  allDayEventsScrollTo(target) {
    const me = this, newDate = target.isEvent ? target.startDate : me.changeEndDate(target), dateIntersects = target.isEvent ? DateHelper.intersectSpans(me.startDate, me.endDate, target.startDate, target.endDate) : DateHelper.betweenLesser(newDate, me.startDate, me.endDate);
    if (!dateIntersects) {
      me.date = newDate;
    }
    return me.originalAllDayEventsScrollTo.call(me.allDayEvents, ...arguments);
  }
  updateAutoCreate(autoCreate) {
    var _super$updateAutoCrea;
    const {
      _allDayEvents
    } = this;
    (_super$updateAutoCrea = super.updateAutoCreate) === null || _super$updateAutoCrea === void 0 ? void 0 : _super$updateAutoCrea.call(this, autoCreate);
    if (_allDayEvents) {
      _allDayEvents.autoCreate = autoCreate ? {
        newName: autoCreate.newName,
        gesture: autoCreate.gesture,
        startHour: 0,
        duration: "1 day"
      } : false;
    }
  }
  updateWeekStartDay(weekStartDay, oldWeekStartDay) {
    var _super$updateWeekStar;
    (_super$updateWeekStar = super.updateWeekStartDay) === null || _super$updateWeekStar === void 0 ? void 0 : _super$updateWeekStar.call(this, weekStartDay);
    if (!this.isConfiguring && this.allDayEvents) {
      this.allDayEvents.weekStartDay = weekStartDay;
    }
  }
  updateEventStore(eventStore, was) {
    super.updateEventStore(eventStore, was);
    const {
      dayTime
    } = this;
    if (dayTime) {
      eventStore === null || eventStore === void 0 ? void 0 : eventStore.registerDayIndex(dayTime);
      was === null || was === void 0 ? void 0 : was.unregisterDayIndex(dayTime);
    }
  }
  get overflowPopup() {
    var _this$_allDayEvents;
    return ((_this$_allDayEvents = this._allDayEvents) === null || _this$_allDayEvents === void 0 ? void 0 : _this$_allDayEvents.overflowPopup) || this._overflowPopup;
  }
  get stepUnit() {
    return this.duration > 1 ? `${this.duration} ${this.L("L{daysUnit}")}` : this.L("L{dayUnit}");
  }
  get eventContentElement() {
    return this.dayContainerElement;
  }
  getDateFromDomEvent(domEvent, precise = false) {
    let date2 = super.getDateFromDomEvent(domEvent);
    const me = this, el = DomHelper.getEventElement(domEvent);
    if (date2 && el !== domEvent && me.dayContainerElement.contains(el)) {
      date2 = DateHelper.add(date2, me.dayStartHour - me.dayStartShift / 36e5 + (domEvent.clientY - me.scrollable.element.getBoundingClientRect().y + me.scrollable.y) / me.hourHeight, "hour");
      if (!precise) {
        date2 = DateHelper.round(date2, me.increment);
      }
    }
    return date2;
  }
  getDateFromPosition(clientX, clientY, local = false) {
    const me = this, {
      eventContentElement,
      allDayEvents
    } = me, dayElements = me.dayContainerElement.querySelectorAll(`.${me.dayCellCls}`), rect = local ? zeroRect : Rectangle.fromScreen(eventContentElement).roundPx().translate(-eventContentElement.scrollLeft), width = eventContentElement.scrollWidth, {
      height
    } = Rectangle.fromScreen(dayElements[0]).roundPx(), localX = local ? clientX : clientX - rect.x, dx = me.rtl ? me.eventContentElement.offsetWidth - localX : localX, dy = clientY - rect.y, weekLength = dayElements.length, col = Math.min(Math.floor(dx / width * weekLength), dayElements.length - 1);
    if (allDayEvents && (dx < 0 || width < dx || dy < 0 || height < dy)) {
      return allDayEvents.getDateFromPosition(clientX, clientY);
    }
    let date2 = me.getDateFromElement(dayElements[0]);
    if (me.hideNonWorkingDays) {
      const cellDates = Array.from(dayElements).map((e) => me.getDateFromElement(e));
      date2 = cellDates[col];
    } else if (col) {
      date2.setDate(date2.getDate() + col);
    }
    DateHelper.clearTime(date2, false);
    date2.setMilliseconds(date2.getMilliseconds() + me.dayStartMs + Math.floor(dy / height * me.getDayLength()));
    return DateHelper.round(date2, me.increment);
  }
  doRefresh() {
    const me = this;
    if (me.isVisible) {
      var _me$calendar;
      DomHelper.addTemporaryClass(me.element, "b-no-transitions", 200, me);
      const children = [];
      me.today = me.dayTime.startOfDay(((_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.dateTimeNow) || new Date());
      for (const date2 = new Date(me.startDate); date2 < me.endDate; date2.setDate(date2.getDate() + 1)) {
        children.push(me.getDayDomConfig(date2));
      }
      DomSync.sync({
        targetElement: me.dayContainerElement,
        domConfig: {
          onlyChildren: true,
          children,
          syncOptions: {
            syncIdField: "date",
            releaseThreshold: 0,
            strict: true
          }
        }
      });
      me.refreshDayBackground();
      me.refreshCount = (me.refreshCount || 0) + 1;
      me.syncCurrentTimeIndicator();
      me.trigger("refresh");
    }
  }
  getBaseDayDomConfig(date2) {
    const me = this, key = me.dayTime.dateKey(date2), cellData = me.cellMap.get(key) || me.createCellData(date2), day2 = cellData.day, nonWorkingDays = me.nonWorkingDays || me.month.nonWorkingDays;
    return (!me.hiddenNonWorkingDays[date2.getDay()] || me.duration === 1) && [cellData, {
      dataset: {
        date: key
      },
      className: {
        "b-dayview-day-detail": 1,
        [me.dayCellCls]: 1,
        [me.nonWorkingDayCls]: nonWorkingDays[day2] || false,
        [me.weekendCls]: DateHelper.weekends[day2],
        [me.todayCls]: !(date2 - me.today),
        "b-last-cell": !(date2 - me.lastVisibleDate),
        [`b-day-of-week-${day2}`]: 1
      },
      style: {},
      children: {
        inset: {
          className: {
            "b-dayview-inset": 1
          }
        },
        events: {
          className: {
            "b-dayview-event-container": 1
          },
          children: []
        }
      },
      syncOptions: {
        syncIdField: "eventId",
        releaseThreshold: 0,
        strict: true
      }
    }];
  }
  getDayDomConfig(date2) {
    const me = this, base = me.getBaseDayDomConfig(date2);
    if (base) {
      const {
        dayCellRenderer
      } = me, [cellData, dayDomConfig] = base;
      if (me.coreHours) {
        dayDomConfig.style.backgroundImage = me.getCoreHoursGradient(me.getCoreHoursForDate(date2));
      }
      me.renderEvents(cellData, dayDomConfig);
      return DomHelper.normalizeChildren(dayCellRenderer ? me.callback(dayCellRenderer, me, [dayDomConfig, cellData]) : dayDomConfig);
    }
  }
  getCoreHoursGradient(coreHours) {
    if (!coreHours) {
      return "";
    }
    const me = this, {
      dayTime
    } = me, dayEnd = dayTime.duration("h"), result = ["linear-gradient(to bottom"];
    coreHours = ArrayHelper.asArray(coreHours);
    let lastEnd = 0;
    for (let i = 0, {
      length
    } = coreHours; i < length; i++) {
      const c = coreHours[i], start = Math.max(dayTime.delta(c.start, "h"), 0) / dayEnd * 100, end = Math.min(dayTime.delta(c.end, "h"), dayEnd) / dayEnd * 100;
      if (length === 1 && start === 0 && end === 100) {
        return "";
      }
      if (lastEnd < start) {
        result.push(`var(--dayview-outside-core-hours-color) ${DomHelper.percentify(lastEnd)}, var(--dayview-outside-core-hours-color) ${DomHelper.percentify(start)}`);
      }
      result.push(`transparent ${DomHelper.percentify(start)}, transparent ${DomHelper.percentify(end)}`);
      lastEnd = end;
    }
    if (lastEnd < 100) {
      result.push(`var(--dayview-outside-core-hours-color) ${DomHelper.percentify(lastEnd)}, var(--dayview-outside-core-hours-color) 100%`);
    }
    return result.join(",") + ")";
  }
  getCoreHoursForDate(date2) {
    const {
      coreHours
    } = this;
    if (coreHours.length === 7) {
      return coreHours[date2.getDay()];
    }
    if (typeof coreHours === "object") {
      return coreHours.overlayDay ? coreHours : null;
    }
    return this.callback(coreHours, this, [date2]);
  }
  refreshDayEvents(date2) {
    const me = this;
    date2 = me.changeEndDate(date2);
    me.today = me.dayTime.startOfDay(new Date());
    const domConfig = me.getDayDomConfig(date2);
    DomHelper.addTemporaryClass(me.element, "b-no-transitions", 200, me);
    domConfig.onlyChildren = true;
    DomSync.sync({
      targetElement: me.getDayElement(date2),
      domConfig
    });
  }
  renderEvents(cellData, dayDomConfig) {
    const me = this, context = me.eventLayout.layoutEvents(cellData, dayDomConfig), {
      items: items2
    } = context, {
      eventSpacing,
      rtl
    } = me;
    for (const item of items2) {
      const eventDomConfig = me.createEventDomConfig({
        eventRecord: item.eventRecord
      });
      eventDomConfig.className["b-starts-above"] = item.startsBefore;
      eventDomConfig.className["b-ends-below"] = item.endsAfter;
      if (item.cluster.items.length > 1) {
        eventDomConfig.className["b-cal-in-cluster"] = 1;
      }
      Object.assign(eventDomConfig.style, _objectSpread2({
        [eventSpacing ? "padding-bottom" : ""]: `${eventSpacing}px`
      }, item.getStyles(rtl)));
      dayDomConfig.children.events.children.push(eventDomConfig);
    }
    me.trigger("renderEvents", {
      context
    });
  }
  get overflowElement() {
    return this.dayContentElement;
  }
  get cellMap() {
    var _this$_cellMap;
    return (_this$_cellMap = this._cellMap) !== null && _this$_cellMap !== void 0 && _this$_cellMap.populated ? this._cellMap : this.createCellMap();
  }
  get bodyConfig() {
    const me = this, {
      allDayEvents,
      maxAllDayHeight
    } = me;
    return Object.assign(super.bodyConfig, {
      children: {
        alldayRowElement: allDayEvents ? {
          className: {
            "b-dayview-allday-row": 1
          },
          style: {
            [maxAllDayHeight ? "maxHeight" : ""]: DomHelper.setLength(maxAllDayHeight)
          },
          children: {
            cornerElement: {
              className: {
                "b-dayview-allday-row-start": 1,
                "b-dayview-allday-autoheight": allDayEvents.autoHeight
              },
              children: {
                allDayTextElement: {
                  className: "b-dayview-allday-text",
                  html: me.L("L{EventEdit.All day}")
                },
                allDayToggleIcon: {
                  tag: "button",
                  className: "b-expand-allday-button b-icon b-icon-expand-row",
                  dataset: {
                    btip: "L{DayView.expandAllDayRow}"
                  }
                }
              }
            },
            allDayEvents: allDayEvents === null || allDayEvents === void 0 ? void 0 : allDayEvents.element,
            $scrollerPad: DomHelper.scrollBarPadElement
          }
        } : null,
        dayContentElement: {
          tabIndex: -1,
          className: {
            "b-dayview-day-content": 1
          },
          children: {
            timeAxisElement: {
              children: me.getTimeElementConfigs(),
              className: {
                "b-timeaxis-container": 1
              }
            },
            dayContainerElement: {
              className: {
                "b-dayview-day-container": 1
              }
            }
          }
        },
        horizontalScrollerElement: {
          className: "b-virtual-scrollers b-hide-display",
          children: [{
            className: "b-virtual-scroller"
          }, DomHelper.scrollBarPadElement]
        }
      }
    });
  }
  onDayContentMousewheel(e) {
    if (e.ctrlKey) {
      e.preventDefault();
      const pointerOffsetY = e.clientY - this.scrollable.element.getBoundingClientRect().y, reqDelta = -Math.min(Math.abs(e.deltaY), 10) * Math.sign(e.deltaY);
      this.zoomBy(reqDelta, pointerOffsetY);
    }
  }
  zoomBy(reqDelta, zoomCenter = Math.min(this.scrollable.scrollHeight, this.scrollable.clientHeight) / 2 - 1) {
    this.updateElementLayout.cancel();
    const me = this, {
      scrollable,
      hourHeight: oldHourHeight
    } = me, zoomCenterTime = DateHelper.round(typeof zoomCenter === "number" ? me.getDateFromPosition(me.dayContainerElement.offsetWidth / 2, zoomCenter + scrollable.y, true) : DateHelper.parse(zoomCenter, "HH:mm:ss"), me.increment), hoursInDay = me.getDayLength("h"), newHourHeight = Math.max(oldHourHeight + reqDelta, me.dayContentClientHeight / hoursInDay), pointerOffsetY = me.getPositionFromTime(zoomCenterTime) - scrollable.y;
    me.ion({
      layoutUpdate: () => {
        scrollable.scrollTo(null, me.getPositionFromTime(zoomCenterTime) - pointerOffsetY);
        scrollable.syncPartners(false, true);
      },
      once: true,
      prio: 1e3
    });
    me.fitHours = false;
    me.hourHeight = newHourHeight;
  }
  zoomTo(newHourHeight, zoomCenter) {
    this.zoomBy(newHourHeight - this.hourHeight, zoomCenter);
  }
  createCellMap() {
    const {
      showAllDayHeader
    } = this;
    return super.createCellMap({
      dayTime: this.dayTime,
      startOnly: showAllDayHeader,
      allowPartial: !showAllDayHeader,
      skipPropagate: true,
      rawEvents: true,
      filter: this.cellMapEventFilter
    });
  }
  cellMapEventFilter(eventRecord) {
    const {
      dayTime,
      hiddenNonWorkingDays,
      showAllDayHeader
    } = this;
    return (!showAllDayHeader || dayTime.isIntraDay(eventRecord) && !eventRecord.allDay) && dayTime.intersects(eventRecord) && !hiddenNonWorkingDays[dayTime.dayOfWeek(eventRecord.startDate)];
  }
  getDayLength(as = "ms") {
    return this.dayTime.duration(as);
  }
  changeIncrement(increment) {
    if (typeof increment === "string") {
      increment = DateHelper.parseDuration(increment);
      return DateHelper.as("ms", increment.magnitude, increment.unit);
    }
    return increment;
  }
  get dayStartHour() {
    return this.dayStartTime == null ? 0 : Math.floor(this.dayStartTime / MILLIS_PER_HOUR);
  }
  get dayEndHour() {
    return this.dayEndTime == null ? 24 : Math.ceil(this.dayEndTime / MILLIS_PER_HOUR);
  }
  get dayStartMs() {
    return this.dayStartTime == null ? 0 : this.dayStartTime;
  }
  get dayEndMs() {
    return this.dayEndTime == null ? 24 * MILLIS_PER_HOUR : this.dayEndTime;
  }
  get dayStartOffset() {
    return this.dayTime.startTimeOffsetMs / MILLIS_PER_HOUR * this.hourHeight;
  }
  changeEventFilter(filter2) {
    if (filter2 === void 0) {
      filter2 = (event) => !this.isAllDayEvent(event);
    }
    return filter2;
  }
  changeEventLayout(config, existing) {
    return DayLayout.reconfigure(existing, config, {
      owner: this,
      defaults: {
        owner: this
      }
    });
  }
  updateNonWorkingDays(nonWorkingDays) {
    var _super$updateNonWorki;
    const me = this;
    (_super$updateNonWorki = super.updateNonWorkingDays) === null || _super$updateNonWorki === void 0 ? void 0 : _super$updateNonWorki.call(this, nonWorkingDays);
    me._allDayEvents && (me._allDayEvents.nonWorkingDays = nonWorkingDays);
    if (!me.isConfiguring) {
      var _me$_cellMap2;
      (_me$_cellMap2 = me._cellMap) === null || _me$_cellMap2 === void 0 ? void 0 : _me$_cellMap2.clear();
      me.refresh();
    }
  }
  updateMaxAllDayHeight(maxAllDayHeight) {
    DomHelper.setLength(this.alldayRowElement, "max-height", maxAllDayHeight);
  }
  get hideNonWorkingDays() {
    return this._hideNonWorkingDays === true && this.duration === 1 ? false : this._hideNonWorkingDays;
  }
  set hideNonWorkingDays(hideNonWorkingDays) {
    super.hideNonWorkingDays = hideNonWorkingDays;
  }
  updateHideNonWorkingDays(hideNonWorkingDays) {
    const me = this, {
      _allDayEvents
    } = me;
    super.updateHideNonWorkingDays(hideNonWorkingDays);
    _allDayEvents && (_allDayEvents.hideNonWorkingDays = me.duration === 1 && !_allDayEvents.fullWeek ? false : me._hideNonWorkingDays);
    if (!me.isConfiguring) {
      var _me$_cellMap3;
      (_me$_cellMap3 = me._cellMap) === null || _me$_cellMap3 === void 0 ? void 0 : _me$_cellMap3.clear();
      me.refresh();
    }
  }
  syncHours() {
    var _me$_cellMap4;
    const me = this;
    (_me$_cellMap4 = me._cellMap) === null || _me$_cellMap4 === void 0 ? void 0 : _me$_cellMap4.clear();
    DomSync.sync({
      targetElement: me.timeAxisElement,
      childrenOnly: true,
      domConfig: {
        children: me.getTimeElementConfigs()
      }
    });
    me.updateElementLayout.now();
    me.refresh();
  }
  syncCurrentTimeIndicator() {
    var _me$calendar2;
    const me = this, now2 = ((_me$calendar2 = me.calendar) === null || _me$calendar2 === void 0 ? void 0 : _me$calendar2.dateTimeNow) || new Date(), dayElement = me.getDayElement(now2), {
      currentTimeIndicator,
      dayTime,
      endDate,
      startDate
    } = me;
    if (startDate && endDate) {
      if (dayElement && DateHelper.betweenLesser(now2, startDate, endDate) && dayTime.contains(now2)) {
        const dayLengthMs = me.getDayLength("ms"), nowMS = dayTime.delta(now2, "ms");
        if (currentTimeIndicator.parentNode !== dayElement) {
          dayElement === null || dayElement === void 0 ? void 0 : dayElement.appendChild(currentTimeIndicator);
        }
        currentTimeIndicator.style.top = DomHelper.percentify(nowMS / dayLengthMs * 100);
      } else {
        currentTimeIndicator.remove();
      }
    }
  }
  get currentTimeIndicator() {
    return this._currentTimeIndicator || (this._currentTimeIndicator = DomHelper.createElement(this.callback(this.currentTimeIndicatorRenderer, this)));
  }
  getTimeElementConfigs() {
    const me = this, result = [], {
      dayTime
    } = me, {
      startHour
    } = dayTime, date2 = new Date(2e3, 5, 15, startHour, 0, 0), hours = dayTime.duration("h");
    for (let h, i = 1; i <= hours; i++) {
      const ticks = me.createLeafTicks(date2);
      date2.setHours(h = date2.getHours() + 1);
      date2.setMinutes(0);
      result.push({
        className: `b-dayview-timeaxis-time b-dayview-timeaxis-time-${h < 10 ? "0" : ""}${h}`,
        children: ticks.concat([{
          className: "b-dayview-timeaxis-tick b-dayview-hour-tick",
          text: DateHelper.format(date2, me.timeFormat)
        }])
      });
    }
    if (me.coreHours && me._simpleCoreHours) {
      result.unshift({
        className: "b-dayview-timeaxis-background",
        style: {
          backgroundImage: me.getCoreHoursGradient(me.coreHours)
        }
      });
    }
    return result;
  }
  createLeafTicks(date2) {
    return this[this.sixMinuteTicks ? "createSixMinuteTicks" : "createFiveMinuteTicks"](date2);
  }
  createFiveMinuteTicks(date2) {
    const result = [];
    for (let i = 1; i < 12; i++) {
      date2.setMinutes(i * 5);
      result.push({
        className: {
          "b-dayview-timeaxis-tick": 1,
          "b-dayview-tick-level-4": 1,
          "b-dayview-tick-level-3": !(i & 1),
          "b-dayview-tick-level-2": !(i % 3),
          "b-dayview-tick-level-1": i === 6
        },
        text: DateHelper.format(date2, this.timeFormat)
      });
    }
    return result;
  }
  createSixMinuteTicks(date2) {
    const result = [];
    for (let i = 1; i < 10; i++) {
      date2.setMinutes(i * 6);
      result.push({
        className: {
          "b-dayview-timeaxis-tick": 1,
          "b-dayview-tick-level-3": 1,
          "b-dayview-tick-level-2": !(i & 1),
          "b-dayview-tick-level-1": i === 5
        },
        text: DateHelper.format(date2, this.timeFormat)
      });
    }
    return result;
  }
  changeCoreHours(coreHours) {
    const me = this;
    me._simpleCoreHours = ObjectHelper.isObject(coreHours) || Array.isArray(coreHours) && coreHours.length !== 7;
    if (me._simpleCoreHours) {
      coreHours = ObjectHelper.clone(coreHours);
      coreHours._overlayDay = coreHours.overlayDay;
      Object.defineProperty(coreHours, "overlayDay", {
        set(v) {
          this._overlayDay = v;
          me.updateCoreHours();
        },
        get(v) {
          return this._overlayDay;
        }
      });
    }
    return coreHours;
  }
  updateCoreHours() {
    if (!this.isConfiguring) {
      this.syncHours();
    }
  }
  changeStartDate() {
    return this.dayOfDate(super.changeStartDate(...arguments));
  }
  updateStartDate(startDate) {
    const {
      _allDayEvents
    } = this;
    if (_allDayEvents) {
      this._allDayEvents.setConfig({
        date: this.date,
        startDate
      });
    }
    super.updateStartDate(...arguments);
  }
  changeEndDate() {
    return this.dayOfDate(super.changeEndDate(...arguments));
  }
  updateEndDate(endDate) {
    var _super$updateEndDate;
    const {
      _allDayEvents
    } = this;
    (_super$updateEndDate = super.updateEndDate) === null || _super$updateEndDate === void 0 ? void 0 : _super$updateEndDate.call(this, ...arguments);
    if (_allDayEvents && !this.updatingRange) {
      this._allDayEvents.setConfig({
        date: this.date,
        endDate
      });
    }
  }
  changeMinDayWidth(minDayWidth) {
    return typeof minDayWidth === "number" ? Math.max(minDayWidth, 50) : null;
  }
  updateMinDayWidth(minDayWidth) {
    this.contentElement.style.setProperty("--min-day-width", DomHelper.setLength(minDayWidth));
    this._allDayEvents && (this._allDayEvents.minDayWidth = minDayWidth);
    this.updateElementLayout();
  }
  updateHourHeight(hourHeight) {
    this.shortEventDuration = 36e5 / (hourHeight / this.shortEventHeight);
    if (!this.isConfiguring) {
      this.updateElementLayout();
      if (this.fitHours) {
        this.refresh();
      }
    }
  }
  updateShortEventHeight(shortEventHeight) {
    this.updateHourHeight(this.hourHeight);
  }
  updateMinEventHeight(minEventHeight) {
    this.contentElement.style.setProperty("--dayview-min-event-height", DomHelper.setLength(minEventHeight));
  }
  get hourHeight() {
    return !this.isConfiguring && this.fitHours ? Math.max(this.dayContentClientHeight / this.getDayLength("hour"), this.minHourHeight) : this._hourHeight;
  }
  changeFitHours(fitHours) {
    if (fitHours !== null && fitHours !== void 0 && fitHours.minHeight) {
      this.minHourHeight = Math.max(fitHours.minHeight, 9);
    } else {
      this.minHourHeight = 17;
    }
    return fitHours;
  }
  get dayContentClientHeight() {
    return DomHelper.floorPx(Rectangle.client(this.dayContentElement).height);
  }
  updateFitHours(fitHours) {
    const me = this;
    if (!me.isConfiguring) {
      fitHours && (me.hourHeight = Math.max(me.dayContentClientHeight / me.getDayLength("hour"), me.minHourHeight));
    }
    me.element.classList.toggle("b-fit-hours", Boolean(fitHours));
    me.monitorResize = DomHelper.scrollBarWidth || fitHours;
  }
  updateEventSpacing() {
    if (!this.isConfiguring) {
      var _this$_cellMap2;
      (_this$_cellMap2 = this._cellMap) === null || _this$_cellMap2 === void 0 ? void 0 : _this$_cellMap2.clear();
      this.refresh();
    }
  }
  onPaint({
    firstPaint
  }) {
    const me = this, {
      dayContainerElement,
      horizontalScrollerElement
    } = me, {
      scrollBarWidth: scrollBarWidth2
    } = DomHelper;
    if (firstPaint) {
      const {
        allDayEvents
      } = me;
      me.horizontalScroller = new Scroller({
        widget: me,
        element: dayContainerElement,
        overflowX: scrollBarWidth2 ? "hidden-scroll" : true,
        overflowY: "clip"
      });
      if (allDayEvents) {
        allDayEvents.element.classList.remove("b-dayview-initializing");
        me.horizontalScroller.addPartner(allDayEvents.headerScroller);
      }
      ResizeMonitor.addResizeListener(me.dayContainerElement, me.onDayContainerResize.bind(me));
      me.scrollbarScroller = new Scroller({
        widget: me,
        element: horizontalScrollerElement.firstChild,
        scrollWidth: dayContainerElement.scrollWidth - scrollBarWidth2,
        overflowX: true,
        overflowY: false
      });
      me.horizontalScroller.addPartner(me.scrollbarScroller);
      me.refresh();
      me.updateElementLayout.now();
      me.setInterval(me.syncCurrentTimeIndicator.bind(me), 30 * 1e3, "syncCurrentTimeIndicator");
      if (allDayEvents) {
        EventHelper.on({
          click: {
            element: me.cornerElement,
            handler: "onCornerClick"
          },
          mousemove: {
            element: me.allDayEvents.element.nextSibling,
            handler: stopEvent,
            capture: true
          },
          thisObj: me
        });
        me.scrollable.ion({
          overflowChange: "syncScrollbarPadding",
          thisObj: me
        });
      }
      me.scrollToVisibleStartTime();
    }
  }
  scrollToVisibleStartTime() {
    if (this.visibleStartTime != null) {
      const me = this, {
        scrollable
      } = me, startScrollPos = me.getPositionFromTime(me.visibleStartTime), doScroll = () => {
        scrollable.scrollTo(null, startScrollPos, {
          animate: false,
          block: "start"
        });
      };
      if (startScrollPos > scrollable.maxY && !me.scrollToStartTimer && me.allDayEvents) {
        me.scrollToStartTimer = me.allDayEvents.ion({
          heightChange: doScroll,
          once: true,
          expires: {
            delay: 5e3,
            alt: doScroll
          },
          name: "scrollToVisibleStartTime"
        });
      } else {
        doScroll();
      }
    }
  }
  relayAllDayEvents(event) {
    const {
      type
    } = event;
    if (!blockedAllDayEvents[type]) {
      return this.trigger(type, event);
    }
  }
  async onCornerClick() {
    const {
      allDayEvents
    } = this;
    if (!allDayEvents.isAnimating) {
      await allDayEvents.toggleExpandCollapse();
      if (!this.isDestroyed) {
        this.allDayToggleIcon.dataset.btip = allDayEvents.expanded ? this.L("L{collapseAllDayRow}") : this.L("L{expandAllDayRow}");
      }
    }
  }
  syncScrollbarPadding() {
    if (!this.configuredHiddenVerticalScroll && this.allDayEvents) {
      if (DomHelper.scrollBarWidth) {
        if (!this.allDayEvents.isAnimating) {
          const {
            allDayEvents,
            alldayRowElement,
            scrollable
          } = this, fitHours = this.fitHours && scrollable.clientHeight / this.getDayLength("hour") >= this.minHourHeight, hasOverflow = !fitHours && scrollable.hasOverflow(), {
            headerElement,
            scrollable: verticalScroller
          } = allDayEvents, expanded = allDayEvents.expanded || allDayEvents.autoHeight, allDayHasOverflow = Boolean(expanded && verticalScroller.hasOverflow());
          if (hasOverflow && allDayHasOverflow) {
            headerElement.classList.add("b-show-yscroll-padding");
            alldayRowElement.classList.remove("b-show-yscroll-padding");
            scrollable.overflowY = verticalScroller.overflowY = "auto";
          } else if (allDayHasOverflow !== hasOverflow) {
            if (allDayHasOverflow) {
              headerElement.classList.add("b-show-yscroll-padding");
              verticalScroller.overflowY = "auto";
              scrollable.overflowY = "scroll";
            } else {
              headerElement.classList.remove("b-show-yscroll-padding");
              alldayRowElement.classList.add("b-show-yscroll-padding");
              verticalScroller.overflowY = "hidden";
              scrollable.overflowY = !fitHours && "auto";
            }
          } else {
            alldayRowElement.classList.remove("b-show-yscroll-padding");
            headerElement.classList.remove("b-show-yscroll-padding");
            scrollable.overflowY = !fitHours && "auto";
            verticalScroller.overflowY = "hidden";
          }
        }
      } else {
        this.scrollable.overflowY = this.allDayEvents.scrollable.overflowY = "auto";
      }
    }
  }
  onInternalResize(element, width, height, oldWidth, oldHeight) {
    const {
      _allDayEvents: allDayEvents
    } = this;
    super.onInternalResize(element, width, height, oldWidth, oldHeight);
    if (oldHeight) {
      allDayEvents === null || allDayEvents === void 0 ? void 0 : allDayEvents.performResizeRefresh(allDayEvents.eventsPerCell, allDayEvents.eventContainerTop);
      if (height !== oldHeight) {
        this.updateElementLayout();
        this.syncScrollbarPadding();
      }
    }
  }
  onThemeChange() {
    this.updateElementLayout();
  }
  onDayContainerResize(el, {
    height: oldHeight
  } = {}, {
    height
  }) {
    if (oldHeight && (height !== oldHeight || DomHelper.scrollBarWidth && this.minDayWidth)) {
      this.updateElementLayout();
      if (this.fitHours) {
        this.updateFitHours(this.fitHours);
      }
    }
  }
  async updateElementLayout() {
    var _this$owner;
    if (!this.refreshCount || (_this$owner = this.owner) !== null && _this$owner !== void 0 && _this$owner.isDestroyed) {
      return;
    }
    const me = this, {
      dayContainerElement,
      horizontalScrollerElement,
      horizontalScroller,
      allDayEvents
    } = me, dayElements = dayContainerElement.querySelectorAll(`.${me.dayCellCls}`), {
      scrollBarWidth: scrollBarWidth2
    } = DomHelper;
    let i, end;
    if (allDayEvents) {
      const cornerElementClassList = me.cornerElement.classList;
      if (allDayEvents.hasOverflow) {
        cornerElementClassList.add("b-has-cell-overflow");
        cornerElementClassList.toggle("b-expanded", Boolean(allDayEvents.expanded));
      } else {
        cornerElementClassList.remove("b-has-cell-overflow");
      }
    }
    me.refreshDayBackground.now();
    for (i = 0, end = dayElements.length - 1; i <= end; i++) {
      dayElements[i].classList.toggle("b-last-cell", i === end);
    }
    if (allDayEvents) {
      me.syncScrollbarPadding();
    }
    if (scrollBarWidth2) {
      horizontalScrollerElement.classList.toggle("b-show-yscroll-padding", me.scrollable.hasOverflow());
    }
    if (dayElements.length) {
      if (me.minDayWidth && dayContainerElement.scrollWidth > dayContainerElement.clientWidth) {
        const dayWidth = me.minDayWidth || (dayElements.length ? dayElements[0].offsetWidth : 0), totalDayWidth = dayWidth * dayElements.length;
        horizontalScrollerElement.classList.remove("b-hide-display");
        me.scrollbarScroller.scrollWidth = totalDayWidth;
        horizontalScroller.overflowX = "hidden-scroll";
      } else {
        horizontalScrollerElement.classList.add("b-hide-display");
        horizontalScroller.overflowX = false;
      }
    }
    me.trigger("layoutUpdate");
  }
  refreshDayBackground() {
    const me = this, {
      contentElement,
      hourHeight,
      dayStartOffset,
      _hourHeightLevel,
      hourHeightLevel
    } = me, dayContentCls = me.dayContentElement.classList, dayLength = me.getDayLength("hour"), dayHeight = hourHeight * dayLength, halfHourHeight = (hourHeight - 1) / 2, fiveMinuteHeight = (hourHeight - 1) / 12, sixMinuteHeight = (hourHeight - 1) / 10, contentElementStyle = contentElement.style, timeAxisWidth = Math.ceil(DateHelper.format(widestDate, me.timeFormat).length / 2);
    dayContentCls.remove("b-dayview-hourheight-level-1", "b-dayview-hourheight-level-2", "b-dayview-hourheight-level-3", "b-dayview-hourheight-level-4");
    dayContentCls.add(`b-dayview-hourheight-level-${hourHeightLevel.level}`);
    contentElementStyle.setProperty("--time-axis-width", `${timeAxisWidth}em`);
    contentElementStyle.setProperty("--day-length", dayLength);
    contentElementStyle.setProperty("--day-height", `${dayHeight}px`);
    contentElementStyle.setProperty("--hour-height", `${hourHeight}px`);
    contentElementStyle.setProperty("--half-hour-height", `${halfHourHeight}px`);
    contentElementStyle.setProperty("--five-minute-height", `${fiveMinuteHeight}px`);
    contentElementStyle.setProperty("--leaf-tick-height", `${me.sixMinuteTicks ? sixMinuteHeight : fiveMinuteHeight}px`);
    contentElementStyle.setProperty("--day-start-offset", `${dayStartOffset}px`);
    if (hourHeightLevel.level !== (_hourHeightLevel === null || _hourHeightLevel === void 0 ? void 0 : _hourHeightLevel.level)) {
      me.trigger("tickChange", {
        old: _hourHeightLevel || hourHeightLevelZero,
        new: hourHeightLevel
      });
    }
  }
  updateSixMinuteTicks() {
    if (!this.isConfiguring) {
      this.updateElementLayout();
    }
  }
  changeHourHeightBreakpoints(hourHeightBreakpoints) {
    if (!Array.isArray(hourHeightBreakpoints)) {
      return Object.values(hourHeightBreakpoints);
    }
    return hourHeightBreakpoints;
  }
  updateHourHeightBreakpoints() {
    if (!this.isConfiguring) {
      this.updateElementLayout();
    }
  }
  get hourHeightLevel() {
    const me = this, {
      hourHeight,
      hourHeightBreakpoints,
      sixMinuteTicks
    } = me, steps = sixMinuteTicks ? sixMinuteSteps : fiveMinuteSteps;
    for (let i = sixMinuteTicks ? 2 : 3; i >= 0; i--) {
      if (hourHeight >= hourHeightBreakpoints[i]) {
        return me._hourHeightLevel = {
          level: i + 1,
          step: steps[i]
        };
      }
    }
    return me._hourHeightLevel = hourHeightLevelZero;
  }
  updateLocalization() {
    if (!this.isConfiguring && this.allDayTextElement) {
      DomSync.sync({
        targetElement: this.allDayTextElement,
        domConfig: {
          html: this.L("L{EventEdit.All day}")
        }
      });
    }
    super.updateLocalization();
  }
};
DayView.initClass();
DayView._$name = "DayView";
var ModeSelector = class extends Container.mixin(Fencible, Minifiable, Responsive) {
  get hideNonWorkingDays() {
    var _this$calendar;
    return (_this$calendar = this.calendar) === null || _this$calendar === void 0 ? void 0 : _this$calendar.hideNonWorkingDays;
  }
  set hideNonWorkingDays(value) {
    const {
      calendar
    } = this;
    if (calendar && !(!value && calendar.hideNonWorkingDays == null)) {
      calendar.hideNonWorkingDays = value;
    }
  }
  changeIncludeWeekendsButton(config, existing) {
    var _me$calendar;
    const me = this, includeWeekendsButton = config && ((_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.includeWeekendsButton);
    if (includeWeekendsButton) {
      config = Button.mergeConfigs(config, includeWeekendsButton);
    }
    if (config && !existing) {
      return me.add(config);
    }
    return Button.reconfigure(existing, config, me);
  }
  updateIncludeWeekendsButton(includeWeekendsButton) {
    if (includeWeekendsButton) {
      includeWeekendsButton.toggleGroup = null;
    }
    this.syncFullWeek();
  }
  changeIncludeWeekendsMenuItem(config, existing) {
    var _this$button;
    const menu = this === null || this === void 0 ? void 0 : (_this$button = this.button) === null || _this$button === void 0 ? void 0 : _this$button.menu;
    if (config && !existing) {
      return menu === null || menu === void 0 ? void 0 : menu.add(config);
    }
    return MenuItem.reconfigure(existing, config, menu);
  }
  updateIncludeWeekendsMenuItem() {
    this.syncFullWeek();
  }
  onBeforeFirstShowModeMenu({
    menu
  }) {
    const me = this, {
      calendar
    } = me, {
      activeView
    } = calendar, modes = Object.values(calendar.modes);
    let menuItem, mode;
    for (mode of modes) {
      menuItem = mode.$modeMenuItem;
      menu.add(menuItem);
      menuItem.checked = mode === activeView;
      menuItem.onToggle = "up.onToggleMenuItem";
    }
    me.getConfig("includeWeekendsMenuItem");
    me.syncFullWeek();
    me.menuReady = true;
  }
  addMode(name, view, options) {
    const me = this, {
      buttonBar
    } = me, menuItem = view.$modeMenuItem = MenuItem.reconfigure(view.$modeMenuItem, MenuItem.mergeConfigs({
      type: MenuItem,
      view,
      ref: `${name}ShowMenuItem`,
      checked: false,
      closeParent: true,
      toggleGroup: `${me.id}-modeSelectorMenuItem`,
      localizable: false,
      text: view.displayName,
      weight: 0
    }, options)), button = buttonBar.add(Button.mergeConfigs({
      view,
      ref: `${name}ShowButton`,
      toggleGroup: `${me.id}-modeSelectorButton`,
      text: view.displayName,
      localizable: false,
      onBeforeToggle: "up.onBeforeToggleButton",
      onToggle: "up.onToggleButton",
      weight: 0
    }, options));
    me.getConfig("includeWeekendsButton");
    view.ion({
      thisObj: me,
      localized() {
        button.text = view.displayName;
        menuItem.text = view.displayName;
      }
    });
  }
  onBeforeToggleButton({
    pressed
  }) {
    if (pressed && this.calendar.viewContainer.layout.isChangingCard) {
      return false;
    }
  }
  onToggleButton({
    source,
    pressed
  }) {
    if (pressed) {
      this.calendar.mode = source.view;
    }
  }
  updateDisabled(disabled) {
    this.buttonBar.items.forEach((button) => {
      if (!disabled || !button.containsFocus) {
        button.disabled = disabled;
      }
    });
  }
  onToggleMenuItem({
    source,
    checked
  }) {
    if (checked) {
      this.calendar.mode = source.view;
    }
  }
  onToggleWorkingDaysButton({
    pressed
  }) {
    this.hideNonWorkingDays = !pressed;
  }
  onToggleWorkingDaysMenu({
    checked
  }) {
    this.hideNonWorkingDays = !checked;
  }
  syncActiveMode(activeView) {
    const me = this, buttons = me.buttonBar.items;
    let item;
    me.button.text = activeView.displayName;
    me.includeWeekendsButton.hidden = !activeView.hasNonWorkingDays;
    me.syncFullWeek();
    for (item of buttons) {
      if (item.view) {
        item.pressed = item.view === activeView;
      }
    }
    if (me.menuReady) {
      for (item of me.button.menu.items) {
        var _item$view;
        if (((_item$view = item.view) === null || _item$view === void 0 ? void 0 : _item$view.$modeMenuItem) === item) {
          item.checked = item.view === activeView;
        }
      }
    }
    me[buttons.length > 1 ? "show" : "hide"]();
  }
  syncFullWeek() {
    const {
      calendar,
      hideNonWorkingDays,
      _includeWeekendsButton: includeWeekendsButton,
      _includeWeekendsMenuItem: includeWeekendsMenuItem
    } = this, fullWeek = !hideNonWorkingDays;
    if (!calendar.isConfiguring) {
      if (includeWeekendsButton) {
        includeWeekendsButton.pressed = fullWeek;
      }
      if (includeWeekendsMenuItem) {
        includeWeekendsMenuItem.checked = fullWeek;
      }
    }
  }
  changeButton(config, existing) {
    return Button.reconfigure(existing, config);
  }
  updateButton(button) {
    button && this.add(button);
  }
  changeButtonBar(config, existing) {
    return ButtonGroup.reconfigure(existing, config);
  }
  updateButtonBar(buttonBar) {
    buttonBar && this.add(buttonBar);
  }
  changeCalendar(calendar) {
    if (calendar && !calendar.isWidget) {
      calendar = this.up(calendar);
    }
    return calendar;
  }
  updateCalendar(calendar) {
    this.detachListeners("cal");
    this.syncFullWeek();
    calendar === null || calendar === void 0 ? void 0 : calendar.ion({
      name: "cal",
      changeHideNonWorkingDays: "syncFullWeek",
      thisObj: this
    });
  }
};
_defineProperty(ModeSelector, "$name", "ModeSelector");
_defineProperty(ModeSelector, "type", "calendarmodeselector");
_defineProperty(ModeSelector, "configurable", {
  minifiable: true,
  minified: null,
  button: {
    type: "button",
    icon: "b-icon-calendar-days",
    cls: "b-calendar-mode-button",
    menuIcon: null,
    menu: [],
    internalListeners: {
      beforeShowMenu: "up.onBeforeFirstShowModeMenu",
      once: true
    }
  },
  buttonBar: {
    type: "buttongroup",
    ignoreParentReadOnly: true
  },
  calendar: {
    value: "calendar",
    $config: "lazy"
  },
  includeWeekendsButton: {
    $config: "lazy",
    value: {
      type: "button",
      cls: "b-calendar-fullweek-button",
      toggleGroup: `no`,
      text: "L{ModeSelector.weekends}",
      tooltip: "L{ModeSelector.includeWeekends}",
      onToggle: "up.onToggleWorkingDaysButton",
      weight: -1
    }
  },
  includeWeekendsMenuItem: {
    $config: "lazy",
    value: {
      separator: true,
      text: "L{ModeSelector.includeWeekends}",
      checked: false,
      onToggle: "up.onToggleWorkingDaysMenu",
      weight: 10
    }
  },
  layout: {
    type: "box",
    wrap: false
  },
  overflowable: "none",
  responsive: {
    large: {
      minifiable: true,
      minified: null
    },
    "*": {
      minifiable: false,
      minified: true
    }
  },
  responsiveTarget: "@calendar"
});
_defineProperty(ModeSelector, "fenced", {
  onToggleButton: true,
  onToggleMenuItem: true,
  syncFullWeek: true,
  syncActiveMode: {
    all: "syncActiveMode",
    lock: ["onToggleButton", "onToggleMenuItem", "syncActiveMode"]
  }
});
ModeSelector.initClass();
ModeSelector._$name = "ModeSelector";
var evRegexp = /^(\d+)ev$/;
var expandGestures = {
  shrinkwrap: 1,
  expand: 1
};
var MonthView = class extends CalendarPanel.mixin(CalendarMixin, DayCellCollecter, DayCellRenderer) {
  static get $name() {
    return "MonthView";
  }
  static get type() {
    return "monthview";
  }
  static get configurable() {
    return {
      eventSorter: EventSorter.interDaySorterFn,
      localizableProperties: ["title", "stepUnit"],
      title: "L{Month}",
      stepUnit: "L{monthUnit}",
      localeClass: this,
      descriptionFormat: "MMMM, YYYY",
      dayNumberCentered: null,
      eventHeight: 20,
      minHeight: 485,
      autoRowHeight: {
        $config: "lazy",
        value: false
      },
      maxEventsPerCell: 100,
      minRowHeight: null,
      overflowClickAction: "popup",
      alwaysRefreshOnMonthChange: true
    };
  }
  static get delayable() {
    return {
      syncCalendarWeekDaysWithScrollable: {
        type: "raf",
        cancelOutstanding: true
      },
      onAllWeekElementsCollapsed: {
        type: "raf",
        cancelOutstanding: true
      }
    };
  }
  onCalendarStoreChange() {
    super.onCalendarStoreChange(...arguments);
    this.syncShrinkwrappedRows();
  }
  onDateChange({
    changes
  }) {
    if (changes.m) {
      this.syncShrinkwrappedRows();
    }
  }
  onCellOverflowGesture({
    date: date2
  }) {
    if (expandGestures[this.overflowClickAction.toLowerCase()]) {
      this.shrinkwrapWeekRow(date2);
    } else {
      super.onCellOverflowGesture(...arguments);
    }
  }
  addCellHeaderContent(cellHeader, cellData) {
    const dayName = {
      className: {
        "b-day-name": true
      }
    };
    cellHeader.children = [cellData.visibleColumnIndex || this.showWeekColumn ? null : {
      className: "b-week-num",
      text: cellData.week[1]
    }, dayName];
    return dayName;
  }
  get shrinkwrappedRows() {
    return this.weeksElement.querySelectorAll(".b-shrinkwrapped");
  }
  get shrinkwrapRowHeights() {
    const me = this, rowHeights = [], {
      cellMap
    } = me;
    me.month.eachWeek((week, [date2]) => {
      let eventCount = 0;
      for (let i = 0; i < 7; i++, date2.setDate(date2.getDate() + 1)) {
        const cellData = cellMap.get(DateHelper.makeKey(date2));
        if (cellData) {
          eventCount = Math.max(eventCount, cellData.renderedEvents.length);
        }
      }
      rowHeights.push(eventCount);
    });
    return rowHeights.map((maxEventCount) => me.eventHeightInPixels * maxEventCount + me.eventSpacing * (maxEventCount + 1) + Math.ceil(me._eventContainerTop));
  }
  getEventsPerCell(date2) {
    const me = this;
    if (me.hasShrinkwrappedRows) {
      const rowIndex = Math.floor(DateHelper.diff(me.startDate, date2, "d") / 7);
      if (me.weekElements[rowIndex].classList.contains("b-shrinkwrapped")) {
        return me.maxEventsPerCell;
      } else {
        const firstCell = me.weekElements[rowIndex].querySelector(me.visibleCellSelector), eventContainerHeight = firstCell.offsetHeight - me.eventContainerTop;
        return Math.floor((eventContainerHeight + me.eventSpacing) / (me.eventHeightInPixels + me.eventSpacing));
      }
    } else {
      return me.eventsPerCell;
    }
  }
  getMaxEventsForWeek(week) {
    const {
      row
    } = this.getWeekContext(week);
    return Math.max(...Array.from(row.querySelectorAll(this.visibleCellSelector)).map((c) => {
      const cellData = this.cellMap.get(c.dataset.date);
      return (cellData === null || cellData === void 0 ? void 0 : cellData.renderedEvents.length) || 0;
    }));
  }
  getWeekContext(week) {
    let weekStart, rowIndex;
    if (typeof week === "number") {
      rowIndex = week;
      weekStart = DateHelper.parseKey(this.weekElements[week].querySelector(this.visibleCellSelector).dataset.date);
    } else if (week.nodeType === 1) {
      weekStart = DateHelper.parseKey(week.closest(".b-calendar-row").querySelector("[data-date]").dataset.date);
      rowIndex = Math.floor(DateHelper.diff(this.startDate, weekStart, "d") / 7);
    } else {
      const incr = (week.getDay(week) - DateHelper.weekStartDay + 7) % 7;
      weekStart = DateHelper.add(DateHelper.clearTime(week), -incr, "d");
      rowIndex = Math.floor(DateHelper.diff(this.startDate, week, "d") / 7);
    }
    return {
      rowIndex,
      weekStart,
      row: this.weekElements[rowIndex]
    };
  }
  shrinkwrapWeekRow(week, isLastCall = true) {
    const me = this, {
      weekStart,
      row
    } = me.getWeekContext(week), {
      weekElements
    } = me, wasShrinkwrapped = row.classList.contains("b-shrinkwrapped"), maxEventCount = me.getMaxEventsForWeek(week), shrinkwrapHeight = me.eventHeightInPixels * maxEventCount + me.eventSpacing * (maxEventCount + 1) + Math.ceil(me._eventContainerTop);
    for (let i = 0, {
      length
    } = weekElements; i < length; i++) {
      const weekElement = weekElements[i];
      if (!weekElement.classList.contains("b-shrinkwrapped")) {
        weekElement.style.flex = `0 0 ${DomHelper.percentify(1 / me.visibleWeekCount * 100)}`;
      }
    }
    if (isLastCall) {
      me.scrollable = {
        overflowY: "auto"
      };
    }
    const oldRect = row.getBoundingClientRect();
    row.classList.add("b-shrinkwrapped");
    if (shrinkwrapHeight > oldRect.height) {
      row.classList.add("b-expanded");
    }
    me.hasShrinkwrappedRows = true;
    row.style.flex = `0 0 ${shrinkwrapHeight}px`;
    if (isLastCall) {
      me.refresh();
    }
    if (!wasShrinkwrapped) {
      me.trigger("weekShrinkwrap", {
        weekStart,
        element: row
      });
    }
    if (isLastCall) {
      if (!me.isAnimating) {
        me.isAnimating = true;
      }
      return new Promise((resolve) => {
        EventHelper.onTransitionEnd({
          element: row,
          property: "flex-basis",
          handler: "onAllWeekElementsExpanded",
          thisObj: me,
          args: [resolve]
        });
      });
    }
  }
  onAllWeekElementsExpanded(element, property, resolve) {
    this.isAnimating = false;
    this.syncCalendarWeekDaysWithScrollable();
    resolve();
  }
  flexWeekRow(date2, isLastCall = true) {
    const me = this, {
      weekStart,
      row
    } = me.getWeekContext(date2);
    if (row.classList.contains("b-shrinkwrapped")) {
      row.style.flex = `0 0 ${DomHelper.percentify(1 / me.visibleWeekCount * 100)}`;
      row.classList.add("b-flexing");
      me._autoRowHeight = false;
      me.trigger("weekFlex", {
        weekStart,
        element: row
      });
      if (isLastCall && !me.isAnimating) {
        me.isAnimating = true;
      }
      const result = new Promise((resolve) => {
        EventHelper.onTransitionEnd({
          element: row,
          property: "flex-basis",
          handler: isLastCall ? "onAllWeekElementsCollapsed" : "onWeekElementCollapsed",
          thisObj: me,
          args: [resolve]
        });
      });
      return result;
    }
  }
  onWeekElementCollapsed(weekElement, property, resolve) {
    weekElement.classList.remove("b-shrinkwrapped", "b-flexing", "b-expanded");
    resolve();
  }
  onAllWeekElementsCollapsed(weekElement, property, resolve) {
    const me = this, {
      weekElements
    } = me;
    me.scrollable.overflowY = me.scrollable.hasOverflow("y");
    weekElement.classList.remove("b-shrinkwrapped", "b-flexing", "b-expanded");
    if (!me.contentElement.querySelector(".b-calendar-week.b-shrinkwrapped")) {
      for (let i = 0, {
        length
      } = weekElements; i < length; i++) {
        const weekElement2 = weekElements[i];
        if (!weekElement2.classList.contains("b-shrinkwrapped")) {
          weekElement2.style.flex = "";
        }
      }
    }
    me.isAnimating = false;
    me.hasShrinkwrappedRows = me.shrinkwrappedRows.length;
    me.refresh();
    me.syncCalendarWeekDaysWithScrollable();
    resolve();
  }
  syncCalendarWeekDaysWithScrollable() {
    var _this$scrollable;
    this.weekdaysHeader.classList[(_this$scrollable = this.scrollable) !== null && _this$scrollable !== void 0 && _this$scrollable.hasScrollbar() ? "add" : "remove"]("b-show-yscroll-padding");
  }
  updateHideOtherMonthCells() {
    super.updateHideOtherMonthCells(...arguments);
    this.refresh();
  }
  updateEventHeight(height, oldHeight) {
    const me = this;
    super.updateEventHeight(height, oldHeight);
    if (!me.isConfiguring) {
      var _me$minRowHeight;
      if ((_me$minRowHeight = me.minRowHeight) !== null && _me$minRowHeight !== void 0 && _me$minRowHeight.match(evRegexp)) {
        me.updateMinRowHeight(me._minRowHeight);
      }
      me.syncShrinkwrappedRows();
      const padding = DomHelper.getEdgeSize(me.element, "padding", "tb");
      me.minHeight = ((me.eventHeightInPixels + 1) * 2 + me.eventSpacing * 3 + Math.ceil(me.eventContainerTop)) * 6 + me.weekdaysHeader.offsetHeight + 7 + padding.height;
    }
  }
  updateMinRowHeight(minRowHeight) {
    var _minRowHeight, _minRowHeight$match, _minRowHeight$match$c;
    const me = this, eventCount = parseInt((_minRowHeight = minRowHeight) === null || _minRowHeight === void 0 ? void 0 : (_minRowHeight$match = _minRowHeight.match) === null || _minRowHeight$match === void 0 ? void 0 : (_minRowHeight$match$c = _minRowHeight$match.call(_minRowHeight, evRegexp)) === null || _minRowHeight$match$c === void 0 ? void 0 : _minRowHeight$match$c[1]);
    if (!isNaN(eventCount)) {
      if (me.isConfiguring) {
        return me.ion({
          paint: "updateMinRowHeight",
          args: [minRowHeight],
          once: true
        });
      }
      minRowHeight = me.eventHeightInPixels * eventCount + me.eventSpacing * (eventCount + 1) + Math.ceil(me.eventContainerTop);
    }
    me.cssMinRowHeight = DomHelper.setLength(minRowHeight);
    super.updateMinRowHeight(minRowHeight);
    if (me.isAnimating) {
      me.ion({
        animationEnd: "performResizeRefresh",
        thisObj: me,
        args: [me._eventsPerCell, me._eventContainerTop],
        once: true
      });
    } else {
      me.performResizeRefresh(me._eventsPerCell, me._eventContainerTop);
    }
  }
  async updateAutoRowHeight(autoRowHeight, wasAutoRowHeight) {
    var _ref, _me$calendar;
    if (this.initializingAutoRowHeight && autoRowHeight === Boolean(wasAutoRowHeight)) {
      return;
    }
    const me = this, {
      weekElements
    } = me, {
      length
    } = weekElements, weekExpander = (_ref = me.features || ((_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.features)) === null || _ref === void 0 ? void 0 : _ref.weekExpander;
    let finalPromise;
    if (weekExpander && autoRowHeight) {
      weekExpander.disabled = weekExpander.disabledByAutoRowHeight = true;
    }
    if (autoRowHeight) {
      for (let i = 0; i < length; i++) {
        finalPromise = me.shrinkwrapWeekRow(i, i === length - 1);
      }
    } else {
      for (let i = 0; i < length; i++) {
        finalPromise = me.flexWeekRow(i, i === length - 1);
      }
    }
    await finalPromise;
    if (weekExpander && !autoRowHeight && weekExpander.disabledByAutoRowHeight) {
      weekExpander.disabled = weekExpander.disabledByAutoRowHeight = false;
    }
    if (!autoRowHeight) {
      me._eventContainerHeight = me._eventsPerCell = null;
      me.refresh();
    }
  }
  syncShrinkwrappedRows() {
    if (this.isVisible) {
      const {
        shrinkwrappedRows
      } = this;
      for (let i = 0, {
        length
      } = shrinkwrappedRows; i < length; i++) {
        this.shrinkwrapWeekRow(shrinkwrappedRows[i], i === length - 1);
      }
    }
  }
  changeScrollable(scrollable, oldScrollable) {
    var _scrollable;
    scrollable = super.changeScrollable(scrollable, oldScrollable);
    if ((_scrollable = scrollable) !== null && _scrollable !== void 0 && _scrollable.overflowX) {
      this.weekdaysScrollable || (this.weekdaysScrollable = new Scroller({
        widget: this,
        element: this.weekdaysHeader,
        overflowX: "hidden-scroll"
      }));
      scrollable.addPartner(this.weekdaysScrollable, "x");
    }
    return scrollable;
  }
  collectEvents(options) {
    if (this.hideOtherMonthCells) {
      const {
        year,
        month: month2
      } = this.month;
      options.startDate = new Date(year, month2, 1);
      options.endDate = new Date(year, month2 + 1, 1);
    }
    options.getDateIndex = (date2) => date2 > (this.firstVisibleDate || this.startDate) ? "startDate" : "date";
    return this.eventStore.getEvents(options);
  }
  getDayElement(date2, strict) {
    if (typeof date2 !== "string") {
      date2 = DateHelper.makeKey(date2);
    }
    if (strict && parseInt(date2.substr(5, 2)) !== this.month.month + 1) {
      return;
    }
    return super.getDayElement(date2);
  }
  calendarHitTest(domEvent) {
    const hit = super.calendarHitTest(domEvent), target = DomHelper.getEventElement(domEvent);
    if (hit) {
      var _weekElement$dataset$;
      if (hit.date.getMonth() !== this.month.month && (this.disableOtherMonthCells || this.hideOtherMonthCells)) {
        return;
      }
      const weekElement = target.closest(".b-calendar-week"), week = weekElement === null || weekElement === void 0 ? void 0 : (_weekElement$dataset$ = weekElement.dataset.week) === null || _weekElement$dataset$ === void 0 ? void 0 : _weekElement$dataset$.split(",").map(Number);
      if (week) {
        var _hit$cell;
        hit.cell = hit.cell || target.closest(".b-calendar-cell");
        hit.dayNumber = Number((_hit$cell = hit.cell) === null || _hit$cell === void 0 ? void 0 : _hit$cell.dataset.columnIndex);
        hit.week = week;
        hit.weekElement = weekElement;
        hit.weekNumber = week[1];
        hit.weekOffset = week[1] - Number(this.weeksElement.firstElementChild.dataset.week.split(",")[1]);
      }
    }
    return hit;
  }
  getDateFromPosition(clientX, clientY) {
    const me = this, weekEls = me.weeksElement.childNodes;
    for (let rect, i = 0; i < weekEls.length; ++i) {
      rect = weekEls[i].getBoundingClientRect();
      if (rect.top <= clientY && clientY < rect.bottom) {
        if (rect.left <= clientX && clientX < rect.right) {
          const dx = me.rtl ? rect.right - clientX : clientX - rect.x, column = Math.floor(dx * me.weekLength / rect.width);
          if (me.hideNonWorkingDays) {
            const cellDates = Array.from(weekEls[i].querySelectorAll(me.visibleCellSelector)).map((e) => me.getDateFromElement(e));
            return cellDates[column];
          } else {
            const date2 = me.getDateFromElement(weekEls[i].querySelector(me.visibleCellSelector));
            date2.setDate(date2.getDate() + column);
            return date2;
          }
        }
      }
    }
    return null;
  }
  getWeekElementFor(domEvent) {
    const target = DomHelper.getEventElement(domEvent);
    return (target === null || target === void 0 ? void 0 : target.closest(".b-calendar-week")) || null;
  }
  updateEventStore(eventStore, was) {
    var _super$updateEventSto;
    (_super$updateEventSto = super.updateEventStore) === null || _super$updateEventSto === void 0 ? void 0 : _super$updateEventSto.call(this, eventStore, was);
    CalendarPanel.prototype.doRefresh.call(this);
  }
  updateOverflowClickAction() {
    this.refresh();
  }
  updateSixWeeks() {
    this._eventsPerCell = this._eventContainerTop = this._eventContainerHeight = null;
    super.updateSixWeeks(...arguments);
  }
  onMonthDateChange({
    changes
  }) {
    if (changes.r && !this.sixWeeks) {
      this._eventsPerCell = this._eventContainerTop = this._eventContainerHeight = null;
    }
    super.onMonthDateChange(...arguments);
  }
  doRefresh() {
    if (!this.isConfiguring) {
      var _this$_cellMap;
      this.getConfig("autoRowHeight");
      (_this$_cellMap = this._cellMap) === null || _this$_cellMap === void 0 ? void 0 : _this$_cellMap.clear();
    }
    const result = super.doRefresh();
    this.syncCalendarWeekDaysWithScrollable();
    return result;
  }
  showEvent(eventRecord) {
    this.setDate(eventRecord.startDate);
  }
  changeDayNumberCentered(dayNumberCentered) {
    return Boolean(dayNumberCentered);
  }
  updateShowWeekColumn(showWeekColumn) {
    if (!showWeekColumn && !this.element.querySelector(".b-week-num")) {
      this.doRefresh();
    }
    super.updateShowWeekColumn(showWeekColumn);
  }
  updateHideNonWorkingDays(hideNonWorkingDays) {
    var _super$updateHideNonW;
    (_super$updateHideNonW = super.updateHideNonWorkingDays) === null || _super$updateHideNonW === void 0 ? void 0 : _super$updateHideNonW.call(this, hideNonWorkingDays);
    if (!this.isConfiguring) {
      this.refresh();
    }
  }
  updateDayNumberCentered(dayNumberCentered) {
    const me = this;
    if (!me._dayNumberCentered && !("nonCenteredDayNumShowWeekColumn" in me)) {
      me.nonCenteredDayNumShowWeekColumn = me.showWeekColumn;
    }
    me._dayNumberCentered = dayNumberCentered;
    me.element.classList[dayNumberCentered ? "add" : "remove"]("day-number-center");
    me.showWeekColumn = dayNumberCentered ? true : me.nonCenteredDayNumShowWeekColumn;
  }
  get dayNameSelector() {
    return this.showWeekColumn ? ".b-cal-cell-header" : super.dayNameSelector;
  }
  set dayNameSelector(dayNameSelector) {
    this._dayNameSelector = dayNameSelector;
  }
  isValidTargetDate(date2) {
    const newMonth = date2.getMonth();
    if (newMonth !== this.month.month) {
      var _this$calendar, _this$calendar2;
      const minDate = this.minDate || ((_this$calendar = this.calendar) === null || _this$calendar === void 0 ? void 0 : _this$calendar.minDate), maxDate = this.maxDate || ((_this$calendar2 = this.calendar) === null || _this$calendar2 === void 0 ? void 0 : _this$calendar2.maxDate);
      if (!isNaN(minDate) || !isNaN(maxDate)) {
        const {
          cellMonth
        } = this;
        cellMonth.date = date2;
        if (!isNaN(minDate)) {
          if (cellMonth.startDate < minDate) {
            return false;
          }
        }
        if (!isNaN(maxDate)) {
          if (DateHelper.add(cellMonth.endDate, 1, "d") > maxDate) {
            return false;
          }
        }
      }
    }
    return true;
  }
  set startDate(date2) {
    this.date = date2;
  }
  get startDate() {
    return super.startDate;
  }
  next() {
    this.date = DateHelper.add(this.date || this.startDate, 1, "month");
  }
  previous() {
    this.date = DateHelper.add(this.date || this.startDate, -1, "month");
  }
};
MonthView.initClass();
MonthView._$name = "MonthView";
var day0 = new Date(0);
var day1 = DateHelper.add(day0, 1, "day");
var emptyMap = Object.freeze(/* @__PURE__ */ new Map());
var scrollAxesConfigs = {
  hourHeight: 1,
  showAllDayHeader: 1
};
var ResourceView = class extends Panel.mixin(CalendarMixin) {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "sharedConfigs", ["allowOverlap", "timeFormat", "fitHours", "hourHeight", "visibleStartTime", "dateFormat", "dayStartTime", "dayEndTime", "hideNonWorkingDays", "readOnly", "zoomOnMouseWheel"]);
    _defineProperty(this, "timeAxisConfigs", ["allDayEvents"].concat(this.sharedConfigs));
  }
  static get $name() {
    return "ResourceView";
  }
  static get type() {
    return "resourceview";
  }
  static get configurable() {
    return {
      textContent: false,
      scrollable: {
        overflowX: true
      },
      date: {
        $config: {
          equal: "date"
        },
        value: null
      },
      view: {
        type: "weekview"
      },
      stableResourceOrder: true,
      resourceWidth: null,
      hideNonWorkingDays: null,
      viewCache: {
        $config: ["lazy", "nullify"],
        value: true
      },
      avatarRendering: {},
      meta: null,
      showAvatars: true,
      includeTimeRanges: null
    };
  }
  construct() {
    var _this$calendar$sideba, _this$calendar$sideba2;
    super.construct(...arguments);
    (_this$calendar$sideba = this.calendar.sidebar) === null || _this$calendar$sideba === void 0 ? void 0 : (_this$calendar$sideba2 = _this$calendar$sideba.widgetMap.resourceFilter) === null || _this$calendar$sideba2 === void 0 ? void 0 : _this$calendar$sideba2.ion({
      change: "onResourceFilterSelectionChange",
      thisObj: this
    });
  }
  get isAnimating() {
    return super.isAnimating || this.items.some((v) => v.isAnimating);
  }
  get hasNonWorkingDays() {
    return true;
  }
  changeView(view) {
    const me = this, result = new Proxy(ObjectHelper.assign({}, view), {
      set(target, prop, value) {
        const result2 = Reflect.set(...arguments);
        me.syncViewConfig(prop, value);
        return result2;
      },
      deleteProperty(target, prop) {
        const result2 = Reflect.deleteProperty(...arguments);
        me.syncViewConfig(prop, null);
        return result2;
      }
    });
    me.viewType = bryntum.Calendar.Modes.resolveType(view.type);
    return result;
  }
  eachView(fn2, args, thisObj = null) {
    const passView = args == null, items2 = [...this.viewCache];
    for (let i = 0, {
      length
    } = items2; i < length; i++) {
      const view = items2[i];
      if (passView) {
        args = [view, i];
      }
      if (view.callback(fn2, thisObj || view, args) === false) {
        return;
      }
    }
  }
  get views() {
    return [...this.viewCache];
  }
  updateResourceStore(resourceStore) {
    var _super$updateResource;
    this.detachListeners("resourceViewResourceChange");
    (_super$updateResource = super.updateResourceStore) === null || _super$updateResource === void 0 ? void 0 : _super$updateResource.call(this, resourceStore);
    resourceStore.ion({
      name: "resourceViewResourceChange",
      change: "onResourceStoreChange",
      sort: "onResourceStoreSort",
      thisObj: this
    });
    this.refreshSoon();
  }
  onResourceStoreChange() {
    this.refreshSoon();
  }
  onResourceStoreSort({
    source
  }) {
    const visibleViews = this.items.filter((v) => v.isVisible && !v.isResourceDayViewTimeAxis), resourceIdOrder = source.map((r) => this.createViewId(r)), viewIdOrder = visibleViews.map((v) => v.id);
    if (!ObjectHelper.isEqual(resourceIdOrder, viewIdOrder)) {
      this.remove(...visibleViews);
      this.refreshSoon();
    }
  }
  onResourceFilterSelectionChange() {
    this.refreshSoon();
  }
  changeViewCache(viewCache, oldViewCache) {
    if (viewCache) {
      return new Bag();
    } else if (oldViewCache) {
      oldViewCache.forEach((v) => v.destroy());
      oldViewCache.clear();
    }
  }
  getResourceView(resource) {
    return this.viewCache.get(this.createViewId(resource)) || this.createView(resource);
  }
  doRefresh() {
    var _me$items$, _me$items$$scrollable;
    const me = this, {
      scrollBarWidth: scrollBarWidth2
    } = DomHelper, {
      calendar,
      _items,
      resourceStore
    } = me, {
      resourceFilter
    } = calendar === null || calendar === void 0 ? void 0 : calendar.widgetMap, calendars = resourceFilter ? me.resourceStore.records.filter((c) => resourceFilter.value.includes(c)) : me.resourceStore.records, {
      length
    } = calendars, toAdd = [], toRemove = [], usedIds = {};
    if (!resourceStore.count) {
      const {
        weekStartDay
      } = me, monthStart = DateHelper.getFirstDateOfMonth(me.date), nextMonthStart = DateHelper.add(monthStart, 1, "month");
      me.eventStore.getEvents({
        startDate: DateHelper.add(monthStart, -(monthStart.getDay() - weekStartDay + 7) % 7, "d"),
        endDate: DateHelper.add(nextMonthStart, 7 - (nextMonthStart.getDay() - weekStartDay + 7) % 7, "d")
      });
    }
    me.refreshSoon.cancel();
    let hitCount = 0;
    for (let i = 0; i < length; i++) {
      const view = me.getResourceView(calendars[i]), isShown = _items.includes(view);
      if (resourceStore.getById(view.resourceId)) {
        view.title = me.titleTemplate(view.resource);
        if (isShown) {
          hitCount++;
        } else {
          toAdd.push(view);
        }
        usedIds[view.id] = 1;
      } else if (isShown) {
        toRemove.push(view);
      }
    }
    if (hitCount < _items.count) {
      me.eachView((view) => {
        if (!usedIds[view.id]) {
          toRemove.push(view);
        }
      });
      me.remove(toRemove);
    }
    if (me.viewType.isDayView) {
      if (!_items.includes(me.dayViewTimeAxis)) {
        toAdd.unshift(me.dayViewTimeAxis);
      }
      if (scrollBarWidth2 && !_items.includes(me.dayViewScroller)) {
        toAdd.push(me.dayViewScroller);
      }
    }
    const y = (_me$items$ = me.items[0]) === null || _me$items$ === void 0 ? void 0 : (_me$items$$scrollable = _me$items$.scrollable) === null || _me$items$$scrollable === void 0 ? void 0 : _me$items$$scrollable.y;
    me.add(...toAdd);
    if (y != null) {
      toAdd.forEach((v) => {
        v.scrollable.element.scrollTop = y;
      });
    }
    if (toAdd.length || toRemove.length) {
      let lastView;
      for (let i = 0, {
        items: items2
      } = me, {
        length: length2
      } = items2; i < length2; i++) {
        var _view$allDayEvents;
        const view = items2[i], {
          scrollable
        } = view;
        view.element.classList.remove("b-last-resource-view");
        if (!view.isResourceDayViewTimeAxis) {
          view.element.classList[i > 1 ? "remove" : "add"]("b-first-resource-view");
          lastView = view;
        }
        if (scrollable) {
          scrollable.clearPartners();
          if (i) {
            view.scrollable.addPartner(items2[i - 1].scrollable, "y");
          }
        }
        (_view$allDayEvents = view.allDayEvents) === null || _view$allDayEvents === void 0 ? void 0 : _view$allDayEvents.refresh();
      }
      if (lastView) {
        lastView.element.classList.add("b-last-resource-view");
      }
      if (me.viewType.isDayView) {
        const allDayRows = me.views.filter((v) => v.allDayEvents && v.isVisible), maxHeight = allDayRows.length && Math.max(...allDayRows.map((v) => v.allDayEvents.cellContentHeight));
        if (maxHeight) {
          _items.forEach((v) => {
            var _v$allDayEvents;
            (_v$allDayEvents = v.allDayEvents) === null || _v$allDayEvents === void 0 ? void 0 : _v$allDayEvents.setEventContentHeight(maxHeight, false, true);
          });
        }
      }
    }
    if (me.viewType.isDayView) {
      me.syncDayViewScrollerVisibility();
    }
    me.refreshCount = (me.refreshCount || 0) + 1;
    me.trigger("refresh");
  }
  onCalendarPointerInteraction() {
  }
  onCalendarStoreChange() {
  }
  onChildAdd(child) {
    super.onChildAdd(child);
    FunctionHelper.before(child, "onConfigChange", "onChildViewConfigChange", this, {
      return: false
    });
  }
  onChildViewConfigChange({
    name,
    value
  }) {
    if (!this.syncingChildViewConfigs && this.timeAxisConfigs.includes(name)) {
      const items2 = new Set(this.items.concat([...this.viewCache]));
      this.syncingChildViewConfigs = true;
      items2.forEach((i) => {
        if (name in i) {
          i[name] = value;
        }
      });
      this.syncingChildViewConfigs = false;
    }
  }
  createView(resource) {
    var _result$contentElemen;
    const me = this, {
      id: resourceId
    } = resource, {
      resourceStore,
      viewCache
    } = me, {
      project
    } = resourceStore, config = Objects.merge({
      project,
      calendar: me.calendar,
      id: me.createViewId(resource),
      cls: "b-resourceview-resource",
      defaultCalendar: resourceId,
      resource,
      resourceId,
      includeTimeRanges: me.includeTimeRanges,
      hideNonWorkingDays: me.hideNonWorkingDays,
      parent: me,
      date: me.date,
      dateFormat: me.dateFormat,
      title: me.titleTemplate(resource)
    }, me.view);
    ObjectHelper.copyProperties(config, [...viewCache][0] || me, me.sharedConfigs);
    if (DomHelper.scrollBarWidth && me.viewType.isDayView) {
      config.scrollable = {
        overflowX: false,
        overflowY: "hidden-scroll"
      };
    }
    const result = bryntum.Calendar.Modes.create(config);
    result.ion({
      catchAll: "onChildViewCatchAll",
      thisObj: me
    });
    result.element.removeAttribute("tabIndex");
    result.element.dataset.viewResourceId = resource.id;
    (_result$contentElemen = result.contentElement) === null || _result$contentElemen === void 0 ? void 0 : _result$contentElemen.removeAttribute("tabIndex");
    Object.defineProperty(result, "weight", {
      get() {
        return me.stableResourceOrder ? resourceStore.allIndexOf(resourceId) : 0;
      }
    });
    Object.defineProperty(result, "resource", {
      get() {
        return resourceStore.getById(resourceId);
      }
    });
    Object.defineProperty(result, "eventFilter", {
      get() {
        return (e) => e.resources.includes(this.resource);
      }
    });
    viewCache.add(result);
    me.trigger("viewCreate", {
      view: result
    });
    return result;
  }
  onChildViewCatchAll(e) {
    e.resourceRecord = e.source.resource;
    if (e.type !== "paint") {
      this.trigger(e.type, e);
    }
    if (e.type === "heightchange") {
      this.syncDayViewScrollerVisibility();
    }
  }
  changeAvatarRendering(config) {
    if (config) {
      return AvatarRendering.new({
        element: this.element
      }, config);
    }
  }
  titleTemplate(resource) {
    const me = this, {
      meta
    } = me, metaValue = typeof meta === "string" ? resource[meta] : meta === null || meta === void 0 ? void 0 : meta(resource), namedColor = DomHelper.isNamedColor(resource.eventColor) && resource.eventColor, hexColor = !namedColor && resource.eventColor;
    return {
      class: {
        "b-resourceview-title": 1,
        "b-has-meta": metaValue
      },
      children: [me.showAvatars && {
        class: {
          "b-resource-avatar-container": 1,
          [`b-sch-foreground-${namedColor}`]: namedColor
        },
        style: {
          color: hexColor || null
        },
        children: [me.getResourceAvatar(resource)]
      }, {
        class: "b-resource-name",
        text: resource.name
      }, metaValue && {
        class: "b-resource-meta",
        text: metaValue
      }]
    };
  }
  getEventElement(eventRecord, date2 = eventRecord.startDate) {
    var _this$getResourceView;
    return (_this$getResourceView = this.getResourceView(eventRecord.resource)) === null || _this$getResourceView === void 0 ? void 0 : _this$getResourceView.getEventElement(eventRecord, date2);
  }
  get dayViewTimeAxis() {
    const me = this;
    if (!me._dayViewTimeAxis) {
      const viewConfig = ObjectHelper.copyProperties({}, me.view, me.timeAxisConfigs);
      me._dayViewTimeAxis = ResourceDayViewTimeAxis.create(_objectSpread2(_objectSpread2({}, viewConfig), {}, {
        weight: -1,
        project: me.project,
        type: "resourcedayviewtimeaxis",
        minWidth: 0,
        cls: "b-resource-dayview-timeaxis",
        startDate: day0,
        endDate: day1,
        scrollable: {
          overflowX: false,
          overflowY: "hidden-scroll"
        },
        onCornerClick() {
          const {
            expanded
          } = me.firstChild.allDayEvents, toRefresh = [];
          let drivingView = null;
          me.eachView(({
            allDayEvents
          }) => {
            if (expanded) {
              if (!drivingView || allDayEvents.maxEventCount < drivingView.maxEventCount) {
                drivingView = allDayEvents;
              }
            } else {
              if (!drivingView || allDayEvents.maxEventCount > drivingView.maxEventCount) {
                drivingView = allDayEvents;
              }
            }
          });
          const r = drivingView.refreshCount;
          drivingView.expanded = !expanded;
          if (drivingView.refreshCount === r) {
            toRefresh.push(drivingView);
          }
          me.items.forEach((v) => {
            if (v !== drivingView) {
              const {
                allDayEvents
              } = v, r2 = allDayEvents.refreshCount;
              v.allDayEvents.expanded = !expanded;
              if (allDayEvents.refreshCount === r2) {
                toRefresh.push(allDayEvents);
              }
            }
          });
          for (let i = 0, {
            length
          } = toRefresh; i < length; i++) {
            toRefresh[i].doRefresh();
          }
        }
      }), me);
      ResizeMonitor.addResizeListener(me._dayViewTimeAxis.timeAxisElement, me.syncDayViewScrollerVisibility.bind(me));
    }
    return me._dayViewTimeAxis;
  }
  get dayViewScroller() {
    const me = this;
    if (!me._dayViewScroller) {
      const viewConfig = ObjectHelper.copyProperties({}, me.view, me.timeAxisConfigs);
      me._dayViewScroller = ResourceDayViewTimeAxis.create(_objectSpread2(_objectSpread2({}, viewConfig), {}, {
        weight: 999,
        project: me.project,
        type: "resourcedayviewtimeaxis",
        flex: `0 0 ${DomHelper.scrollBarWidth}px`,
        minWidth: DomHelper.scrollBarWidth,
        cls: "b-resource-dayview-scroller",
        startDate: day0,
        endDate: day1,
        scrollable: {
          overflowX: false,
          overflowY: "scroll"
        }
      }), me);
      me._dayViewScroller.scrollable.addPartner(me.dayViewTimeAxis.scrollable, "y");
      me.monitorResize = true;
    }
    return me._dayViewScroller;
  }
  onElementResize() {
    super.onElementResize();
    this.syncDayViewScrollerVisibility();
  }
  syncDayViewScrollerVisibility() {
    if (this.dayViewScroller) {
      const needsScroller = this.dayViewTimeAxis.scrollable.hasOverflow("y");
      if (this.dayViewScroller.isVisible !== needsScroller) {
        this.dayViewScroller[needsScroller ? "show" : "hide"]();
      }
    }
  }
  scrollTo(target) {
    const {
      items: items2
    } = this;
    if (target.isEventModel) {
      const owningView = items2.find((v) => v.eventStore.includes(target));
      return owningView === null || owningView === void 0 ? void 0 : owningView.scrollTo(target);
    }
    return items2[0].scrollTo(target);
  }
  createViewId(resource) {
    return `${this.id}-resource${this.config.view.type}-${resource.id}`;
  }
  updateDate(date2) {
    this.suspendVisibility();
    this.viewCache.forEach((v) => {
      if (!v.isResourceDayViewTimeAxis) {
        v.date = date2;
      }
    });
    this.resumeVisibility();
    if (this.viewType.isDayView) {
      this.items.forEach((v) => {
        var _v$allDayEvents2, _v$allDayEvents3;
        (_v$allDayEvents2 = v.allDayEvents) === null || _v$allDayEvents2 === void 0 ? void 0 : _v$allDayEvents2.setEventContentHeight((_v$allDayEvents3 = v.allDayEvents) === null || _v$allDayEvents3 === void 0 ? void 0 : _v$allDayEvents3.cellContentHeight);
      });
    }
  }
  updateResourceWidth(value) {
    this.contentElement.style.setProperty("--resource-width", DomHelper.setLength(value));
  }
  updateHideNonWorkingDays(value) {
    if (!this.isConfiguring) {
      this.syncViewConfig("hideNonWorkingDays", value);
    }
  }
  updateNonWorkingDays(value) {
    if (!this.isConfiguring) {
      this.syncViewConfig("nonWorkingDays", value);
    }
  }
  updateIncludeTimeRanges(value) {
    if (!this.isConfiguring) {
      this.syncViewConfig("includeTimeRanges", value);
    }
  }
  syncViewConfig(configName, value) {
    const update = (view) => {
      view[configName] = value;
    };
    if (scrollAxesConfigs[configName]) {
      this.items.forEach(update);
    } else {
      this.eachView(update);
    }
  }
  descriptionRenderer() {
    var _;
    return ((_ = [...this.viewCache.items][0]) === null || _ === void 0 ? void 0 : _.description) || "No resources";
  }
  get startDate() {
    return new Date(Math.min(...this.items.reduce((result, v) => {
      if (!v.isResourceDayViewTimeAxis) {
        result.push(v.startDate);
      }
      return result;
    }, [])));
  }
  get endDate() {
    return new Date(Math.max(...this.items.reduce((result, v) => {
      if (!v.isResourceDayViewTimeAxis) {
        result.push(v.endDate);
      }
      return result;
    }, [])));
  }
  get stepUnit() {
    const firstItem = [...this.viewCache][0];
    return firstItem === null || firstItem === void 0 ? void 0 : firstItem.stepUnit;
  }
  get firstChild() {
    return this.items.filter((w) => !w.isResourceDayViewTimeAxis)[0];
  }
  previous() {
    const firstItem = [...this.viewCache][0];
    if (firstItem) {
      this.date = DateHelper.add(this.date, -firstItem.duration, "day");
    }
  }
  next() {
    const firstItem = [...this.viewCache][0];
    if (firstItem) {
      this.date = DateHelper.add(this.date, firstItem.duration, "day");
    }
  }
};
var ResourceDayViewAllDayEvents = class extends CalendarRow {
  static get $name() {
    return "ResourceDayViewAllDayEvents";
  }
  static get type() {
    return "resourcedayviewalldayevents";
  }
  get hasOverflow() {
    return this.up("resourceview").views.some((v) => {
      var _v$allDayEvents4;
      return (_v$allDayEvents4 = v.allDayEvents) === null || _v$allDayEvents4 === void 0 ? void 0 : _v$allDayEvents4.hasOverflow;
    });
  }
  createCellMap() {
    return emptyMap;
  }
};
var ResourceDayViewTimeAxis = class extends DayView {
  static get $name() {
    return "ResourceDayViewTimeAxis";
  }
  static get type() {
    return "resourcedayviewtimeaxis";
  }
  static get configurable() {
    return {
      allDayEvents: {
        type: "resourcedayviewalldayevents"
      }
    };
  }
  compose() {
    const result = super.compose();
    result["aria-hidden"] = true;
    return result;
  }
  scrollToVisibleStartTime() {
  }
  createCellMap() {
    return emptyMap;
  }
  calculateCellContentHeight() {
    return 0;
  }
  getDateFromPosition(clientX, clientY, local = false) {
    const me = this, date2 = me.startDate, top = local ? 0 : me.dayContentElement.getBoundingClientRect().y, height = me.timeAxisElement.offsetHeight, dy = clientY - top;
    return DateHelper.round(DateHelper.add(DateHelper.clearTime(date2), me.dayStartMs + Math.floor(dy / height * me.getDayLength()), "ms"), me.increment);
  }
};
ResourceDayViewAllDayEvents.initClass();
ResourceDayViewTimeAxis.initClass();
ResourceView.initClass();
ResourceView._$name = "ResourceView";
var Sidebar = class extends Panel.mixin(Responsive) {
  static get $name() {
    return "Sidebar";
  }
  static get type() {
    return "sidebar";
  }
  static get configurable() {
    return {
      focusable: false,
      bbar: {
        cls: "b-cal-nav-item",
        layout: {
          justify: "center"
        },
        items: {
          todayButtonSidebar: {
            text: "L{Calendar.Today}",
            onClick: "up.shiftToNow",
            weight: 200
          },
          prevButtonSidebar: {
            onClick: "up.shiftPrevious",
            cls: "b-borderless",
            icon: "b-icon-previous",
            weight: 300
          },
          nextButtonSidebar: {
            onClick: "up.shiftNext",
            cls: "b-borderless",
            icon: "b-icon-next",
            weight: 400
          }
        }
      },
      items: {
        datePicker: {
          type: "datepicker",
          weight: 100,
          internalListeners: {
            selectionChange: "up.onMonthSelectionChange"
          }
        },
        eventFilter: {
          type: "filterfield",
          field: "name",
          weight: 150,
          placeholder: "L{Filter events}",
          localeClass: this
        },
        resourceFilter: {
          ignoreParentReadOnly: true
        }
      },
      date: {
        $config: {
          equal: "date"
        },
        value: null
      },
      eventStore: null,
      responsive: {},
      stepUnitText: null,
      side: "left",
      collapsible: {
        tool: null
      },
      resourceFilter: {
        type: "resourcefilter",
        flex: "1 1 auto",
        weight: 200,
        minHeight: 110,
        scrollable: {
          overflowY: "auto"
        },
        store: {
          sorters: [{
            field: "name",
            ascending: true
          }]
        },
        masterFilter(r) {
          return this.eventStore.resourceStore.isAvailable(r);
        }
      }
    };
  }
  setupWidgetConfig(widgetConfig, type) {
    let result = super.setupWidgetConfig(...arguments);
    if (result.ref === "eventFilter") {
      result.store = this.initialConfig.eventStore;
    }
    if (result.ref === "resourceFilter") {
      if (!result.type || result.type === this.resourceFilter.type) {
        result = Sidebar.mergeConfigs(this.resourceFilter, result);
      }
    }
    if (result.type === "datepicker") {
      this.element.classList.add("b-has-datepicker");
      this.element.classList.toggle("b-datepicker-with-events", Boolean(result.events));
    }
    return result;
  }
  updateSide(side, oldSide) {
    const {
      classList
    } = this.element;
    classList.remove(`b-sidebar-${oldSide}`);
    classList.add(`b-sidebar-${side}`);
    if (this.collapsible) {
      this.collapsible.direction = side;
    }
  }
  updateStepUnitText(stepUnitText) {
    const me = this, {
      prevButtonSidebar,
      nextButtonSidebar
    } = me.widgetMap;
    if (prevButtonSidebar) {
      prevButtonSidebar.tooltip = stepUnitText ? me.L("L{Calendar.previous}", stepUnitText) : "";
      prevButtonSidebar.disabled = !stepUnitText;
    }
    if (nextButtonSidebar) {
      nextButtonSidebar.tooltip = stepUnitText ? me.L("L{Calendar.next}", stepUnitText) : "";
      nextButtonSidebar.disabled = !stepUnitText;
    }
  }
  updateEventStore(eventStore) {
    const {
      resourceFilter,
      datePicker
    } = this.widgetMap;
    if (resourceFilter) {
      resourceFilter.eventStore = eventStore;
    }
    if (datePicker) {
      datePicker.eventStore = eventStore;
    }
  }
  onMonthSelectionChange({
    selection,
    userAction
  }) {
    this.UIdateChange = userAction;
    this.date = selection[0];
    this.UIdateChange = false;
  }
  changeDate(date2, oldDate) {
    date2 = typeof date2 === "string" ? DateHelper.parse(date2) : new Date(date2);
    if (isNaN(date2)) {
      throw new Error("Calendar widget date ingestion must be passed a Date, or a YYYY-MM-DD date string");
    }
    date2 = DateHelper.clearTime(date2);
    if (!oldDate || date2 - oldDate) {
      return date2;
    }
  }
  updateDate(date2) {
    const {
      datePicker
    } = this.widgetMap;
    datePicker && (datePicker.value = date2);
    this.trigger("dateChange", {
      date: date2,
      userAction: Boolean(this.UIdateChange)
    });
  }
};
Sidebar.initClass();
Sidebar._$name = "Sidebar";
var WeekView = class extends DayView {
  static get $name() {
    return "WeekView";
  }
  static get type() {
    return "weekview";
  }
  static get configurable() {
    return {
      localizableProperties: ["title", "stepUnit"],
      title: "L{Week}",
      stepUnit: "L{weekUnit}",
      range: {
        magnitude: 1,
        unit: "week"
      },
      responsive: {
        small: {
          descriptionFormat: "MMMM YYYY"
        },
        large: {
          descriptionFormat: ["MMMM YYYY (Wp)", "S{MMM} - E{MMM YYYY} (S{Wp})"]
        },
        "*": {
          descriptionFormat: ["MMMM YYYY", "S{MMM} - E{MMM YYYY}"]
        }
      },
      week: null,
      fixedDuration: true
    };
  }
  calculateDuration() {
    return 7;
  }
  updateWeekStartDay(weekStartDay, oldWeekStartDay) {
    var _super$updateWeekStar;
    (_super$updateWeekStar = super.updateWeekStartDay) === null || _super$updateWeekStar === void 0 ? void 0 : _super$updateWeekStar.call(this, weekStartDay);
    if (!this.isConfiguring) {
      const startDate = new Date(this.startDate);
      startDate.setDate(startDate.getDate() + weekStartDay - oldWeekStartDay);
      this.startDate = startDate;
    }
  }
  changeMonth() {
    const result = super.changeMonth(...arguments);
    result.ion({
      weekChange: "onMonthWeekChange",
      thisObj: this
    });
    return result;
  }
  onMonthWeekChange({
    source,
    newDate
  }) {
    this.week = source.getWeekNumber(newDate);
  }
  changeWeek(week, oldWeek) {
    const me = this;
    week = Array.isArray(week) ? week : [me.month.year, week];
    if (!ObjectHelper.isEqual(week, oldWeek)) {
      var _me$calendar, _me$calendar2;
      const minDate = me.minDate || ((_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.minDate), maxDate = me.maxDate || ((_me$calendar2 = me.calendar) === null || _me$calendar2 === void 0 ? void 0 : _me$calendar2.maxDate);
      if (!isNaN(minDate) || !isNaN(maxDate)) {
        const weekStart = me.month.getWeekStart(week), weekEnd = DateHelper.add(weekStart, me.duration, "d");
        if (!isNaN(minDate) && weekStart < minDate) {
          return;
        }
        if (!isNaN(maxDate) && weekEnd > maxDate) {
          return;
        }
      }
      return week;
    }
  }
  updateWeek(week) {
    const me = this, {
      month: month2,
      date: date2,
      dayTime
    } = me, weekStartDate = dayTime.shiftDate(month2.getWeekStart(week));
    if (!date2 || !ObjectHelper.isEqual(month2.getWeekNumber(date2), week)) {
      me.date = weekStartDate;
    } else {
      me.startDate = weekStartDate;
    }
    me.week = month2.getWeekNumber(me.date);
  }
};
WeekView.initClass();
WeekView._$name = "WeekView";
var isHoverGesture = {
  hover: 1,
  mouseover: 1
};
var YearView = class extends Panel.mixin(CalendarMixin, DayCellCollecter, DayCellRenderer) {
  static get $name() {
    return "YearView";
  }
  static get type() {
    return "yearview";
  }
  static get configurable() {
    return {
      textContent: false,
      localizableProperties: ["title", "stepUnit"],
      title: "L{Year}",
      scrollable: {
        overflowY: true
      },
      stepUnit: "L{yearUnit}",
      month: true,
      date: {
        $config: {
          equal: "date"
        },
        value: null
      },
      descriptionFormat: "YYYY",
      year: null,
      monitorResize: false,
      showWeekColumn: true,
      hideWeekColumnCls: "b-hide-week-numbers",
      otherMonthCls: "b-other-month",
      sixWeeks: true,
      dayCellRenderer: null,
      monthSelector: ".b-yearview-month-name",
      focusable: false,
      showEvents: "heatmap",
      maxDots: 4,
      eventCountTip: null
    };
  }
  createCellMap(options) {
    const result = super.createCellMap(options = _objectSpread2({
      skipPropagate: true
    }, options));
    for (const cellData of result.values()) {
      cellData.renderedEvents.setEvents(cellData.events);
    }
    return result;
  }
  get date() {
    return this._date || !this.isConfiguring && this.firstEventDate || this.startDate;
  }
  next() {
    this.date = new Date(this.year + 1, this.date.getMonth(), this.date.getDate());
  }
  previous() {
    this.date = new Date(this.year - 1, this.date.getMonth(), this.date.getDate());
  }
  get firstEventDate() {
    const entries = [...this.cellMap.values()];
    if (entries.length) {
      return entries[0].date;
    }
  }
  get lastEventDate() {
    const entries = [...this.cellMap.values()];
    if (entries.length) {
      return entries[entries.length - 1].date;
    }
  }
  onCalendarPointerInteraction(domEvent) {
    var _me$_overflowPopup, _me$autoCreate;
    const me = this, superCall = super.onCalendarPointerInteraction, {
      target,
      type
    } = domEvent;
    if (type === "mousedown" || type.endsWith("click")) {
      me.clearTimeout(me.cellOverflowTimer);
    }
    if (type === "mousedown" && (_me$_overflowPopup = me._overflowPopup) !== null && _me$_overflowPopup !== void 0 && _me$_overflowPopup.isVisible && target.closest(".b-cal-cell-overflow")) {
      domEvent.preventDefault();
    }
    if (me.overflowPopupTrigger === "click" && ((_me$autoCreate = me.autoCreate) === null || _me$autoCreate === void 0 ? void 0 : _me$autoCreate.gesture) === "dblclick" && type === "click" && target.closest(`.${me.emptyCellCls}`) && !me.emptyCellRenderer) {
      me.cellOverflowTimer = me.setTimeout({
        fn: superCall,
        delay: 300,
        args: [domEvent]
      });
    } else {
      return superCall.apply(me, arguments);
    }
  }
  changeMonth(month2, oldMonth) {
    const me = this, listeners = {
      name: "yearChangeListener",
      yearChange: "onMonthYearChange",
      thisObj: me
    };
    me.detachListeners("yearChangeListener");
    if (month2 instanceof Month) {
      month2.ion(listeners);
      me._year = month2.year;
    } else {
      month2 = new Month({
        date: new Date(me.year || new Date().getFullYear(), 0, 1),
        weekStartDay: me.weekStartDay,
        hideNonWorkingDays: me.hideNonWorkingDays,
        nonWorkingDays: me.nonWorkingDays,
        sixWeeks: me.sixWeeks,
        listeners
      });
    }
    if (me.nonWorkingDays == null) {
      me.nonWorkingDays = me._month.nonWorkingDays;
    }
    me._year = month2.year;
    return month2;
  }
  onMonthYearChange({
    source: month2
  }) {
    const me = this;
    me._year = month2.year;
    if (!me.isConfiguring) {
      me._cellMap && me._cellMap.clear();
      me.date = month2.date;
      me.refresh();
    }
  }
  get eventsPerCell() {
    return 0;
  }
  get startDate() {
    return this.month.getOtherMonth(new Date(this.year, 0, 1)).startDate;
  }
  get endDate() {
    return DateHelper.add(this.month.getOtherMonth(new Date(this.year, 11, 1)).endDate, 1, "day");
  }
  set startDate(startDate) {
    this.date = startDate;
  }
  isValidTargetDate(date2) {
    const newYear = date2.getFullYear();
    if (newYear !== this.year) {
      var _this$calendar, _this$calendar2;
      const minDate = this.minDate || ((_this$calendar = this.calendar) === null || _this$calendar === void 0 ? void 0 : _this$calendar.minDate), maxDate = this.maxDate || ((_this$calendar2 = this.calendar) === null || _this$calendar2 === void 0 ? void 0 : _this$calendar2.maxDate);
      if (!isNaN(minDate) || !isNaN(maxDate)) {
        const {
          cellMonth
        } = this;
        if (!isNaN(minDate)) {
          const newStartDate = cellMonth.getWeekStart(cellMonth.getWeekNumber(new Date(newYear, 0, 1)));
          if (newStartDate < minDate) {
            return false;
          }
        }
        if (!isNaN(maxDate)) {
          cellMonth.date = new Date(newYear, 11, 31);
          if (DateHelper.add(cellMonth.endDate, 1, "d") > maxDate) {
            return false;
          }
        }
      }
    }
    return true;
  }
  updateDate(date2) {
    this.month.date = date2;
  }
  changeYear(year) {
    if (this.isConfiguring) {
      return year;
    }
    this.month.year = year;
    return this.month.year;
  }
  changeShowEvents(showEvents, oldShowEvents) {
    return showEvents === true ? "heatmap" : showEvents;
  }
  updateShowEvents(showEvents, oldShowEvents) {
    const {
      classList
    } = this.contentElement;
    showEvents && classList.add(`b-show-events-${showEvents}`);
    classList.remove(`b-show-events-${oldShowEvents}`);
    if (!this.isConfiguring) {
      this.doRefresh();
    }
  }
  updateShowWeekNumber() {
    this.bodyElement.classList[this.showWeekColumn ? "remove" : "add"](this.hideWeekColumnCls);
  }
  doRefresh() {
    var _me$calendar;
    const me = this, {
      bodyElement: targetElement,
      month: month2,
      dayCellCls,
      otherMonthCls,
      weekendCls,
      todayCls,
      nonWorkingDayCls,
      emptyCellCls,
      cellMap,
      showEvents
    } = me, children = [], today = ((_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.today) || new Date(), todayKey = DateHelper.makeKey(today);
    for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
      month2.month = monthIndex;
      const monthHeader = {
        tag: "button",
        className: "b-yearview-month-name",
        html: DateHelper.getMonthName(monthIndex),
        dataset: {
          monthDate: DateHelper.makeKey(new Date(me.year, monthIndex, 1))
        }
      }, weeknameCells = [{
        className: "b-week-number-cell"
      }], weekNameRow = {
        className: "b-calendar-week b-calendar-weekdays",
        children: weeknameCells
      }, monthElement = {
        className: "b-yearview-month",
        children: [monthHeader, weekNameRow]
      }, weeks = monthElement.children;
      children.push(monthElement);
      let cellIndex = 0;
      month2.eachWeek((week, dates) => {
        if (weeknameCells.length === 1) {
          for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
            weeknameCells.push({
              className: {
                "b-yearview-weekday-cell": 1,
                [nonWorkingDayCls]: me.nonWorkingDays[month2.canonicalDayNumbers[columnIndex]]
              },
              text: DateHelper.format(dates[columnIndex], "d1")
            });
          }
        }
        const weekElement = {
          className: "b-calendar-week",
          dataset: {
            week: `${week[0]},${week[1]}`
          }
        }, dayCells = weekElement.children = [{
          tag: "button",
          ariaLabel: me.L("L{Calendar.weekOfYear}", week),
          className: "b-week-number-cell",
          html: week[1]
        }];
        weeks.push(weekElement);
        for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
          const date2 = dates[columnIndex], isOtherMonth = date2.getMonth() !== month2.month, key = DateHelper.makeKey(date2), day2 = date2.getDay(), cellData = !me.isConfiguring && cellMap.get(key), events = cellData === null || cellData === void 0 ? void 0 : cellData.events, eventCount = (events === null || events === void 0 ? void 0 : events.length) || 0, showOverflow = !isOtherMonth && eventCount, cell = {
            style: {},
            className: {
              "b-day-name": 1,
              [dayCellCls]: 1,
              [emptyCellCls]: !eventCount
            },
            dataset: {
              date: key,
              cellIndex,
              columnIndex
            }
          };
          let content = String(date2.getDate());
          Object.assign(cell.className, {
            [weekendCls]: DateHelper.weekends[day2],
            [todayCls]: key === todayKey && !isOtherMonth,
            [nonWorkingDayCls]: me.nonWorkingDays[day2],
            [otherMonthCls]: isOtherMonth,
            "b-cal-cell-overflow": showOverflow,
            [SchedulerDatePicker.getEventCountClass(eventCount)]: showOverflow,
            [`b-day-of-week-${day2}`]: 1
          });
          if (me.dayCellRenderer) {
            var _cellData$events;
            const result = me.callback(me.dayCellRenderer, me, [{
              cellConfig: cell,
              date: date2,
              events: (cellData === null || cellData === void 0 ? void 0 : (_cellData$events = cellData.events) === null || _cellData$events === void 0 ? void 0 : _cellData$events.map((data) => data.eventRecord)) || []
            }]);
            if (result != null) {
              content = result;
            }
          }
          if (eventCount && me.eventCountTip && !isHoverGesture[me.overflowPopupTrigger]) {
            cell.dataset.btip = me.L("L{ResourceInfoColumn.eventCountText}", eventCount);
          }
          if (showEvents === "dots") {
            const children2 = [];
            for (let i = 0; i < Math.min((events === null || events === void 0 ? void 0 : events.length) || 0, me.maxDots); i++) {
              const eventDomConfig = me.createEventDomConfig({
                eventRecord: events[i].eventRecord,
                minimal: true
              });
              children2.push(eventDomConfig);
            }
            content = [typeof content === "object" ? content : {
              tag: "span",
              html: content
            }, {
              className: "b-cal-minimal-event-container",
              children: children2
            }];
          }
          cell.children = [{
            className: "b-calendar-cell-inner",
            [typeof content === "string" ? "html" : "children"]: content
          }];
          dayCells.push(cell);
          cellIndex++;
        }
      });
    }
    DomSync.sync({
      targetElement,
      domConfig: {
        children
      }
    });
    me.refreshCount = (me.refreshCount || 0) + 1;
    me.trigger("refresh");
  }
  getDayElement(date2, strict) {
    if (typeof date2 !== "string") {
      date2 = DateHelper.makeKey(date2);
    }
    if (strict && parseInt(date2.substr(0, 4)) !== this.year) {
      return;
    }
    return this.contentElement.querySelector(`.b-calendar-cell[data-date="${date2}"]:not(.b-other-month)`);
  }
  getCell() {
    return this.getDayElement(...arguments);
  }
  onPaint({
    firstPaint
  }) {
    if (firstPaint) {
      this.refresh();
    }
  }
};
YearView.initClass();
YearView._$name = "YearView";
var isCalendarMixin = (w) => w.isCalendarMixin;
var EventNavigation = (Target) => class EventNavigation extends SchedulerEventNavigation(Target || Base$1) {
  static get configurable() {
    return {
      navigator: {
        allowCtrlKey: true,
        scrollSilently: true,
        datasetIdProperty: "eventId",
        itemsTabbable: true,
        keys: {
          ArrowUp: null,
          ArrowDown: null,
          Escape: null,
          Tab: null,
          "SHIFT+Tab": null
        }
      }
    };
  }
  normalizeTarget(event) {
    return event.eventRecord;
  }
  changeNavigator(navigator2) {
    const me = this;
    me.getConfig("eventCls");
    return super.changeNavigator(me.constructor.mergeConfigs({
      target: me.element,
      itemSelector: `.b-cal-cell-overflow,.b-cal-cell-no-content,${me.eventSelector}`,
      skipScrollIntoView: true
    }, navigator2));
  }
  onViewRefresh() {
    var _super$onViewRefresh, _this$activeView$over;
    (_super$onViewRefresh = super.onViewRefresh) === null || _super$onViewRefresh === void 0 ? void 0 : _super$onViewRefresh.call(this, ...arguments);
    if (this.navigator.activeItem && !((_this$activeView$over = this.activeView.overflowPopup) !== null && _this$activeView$over !== void 0 && _this$activeView$over.containsFocus)) {
      const activeEvent = this.getEventRecord(this.navigator.activeItem);
      if (activeEvent) {
        this.navigator.updateActiveItem(this.getElementFromEventRecord(activeEvent));
      }
    }
  }
  onCalendarStoreChange({
    action,
    records
  }) {
    var _super$onCalendarStor;
    const me = this, {
      navigator: navigator2
    } = me, activeItem = navigator2 === null || navigator2 === void 0 ? void 0 : navigator2.activeItem;
    if (activeItem && !me.eventStore.includes(activeItem.dataset.eventId)) {
      const activeView = me.constructor.fromElement(activeItem, isCalendarMixin) || me.activeView, {
        _overflowPopup
      } = activeView, nextItem = navigator2.next;
      if (nextItem === activeItem.nextSibling && !nextItem.parentNode.syncIdMap) {
        navigator2.triggerNavigate({
          eventPhase: Event.BUBBLING_PHASE,
          target: nextItem
        }, nextItem);
      } else {
        let fallback = nextItem || navigator2.previous;
        if (_overflowPopup !== null && _overflowPopup !== void 0 && _overflowPopup.containsFocus && !_overflowPopup.contentElement.contains(fallback)) {
          const {
            target
          } = _overflowPopup.lastAlignSpec;
          fallback = navigator2.getAdjacent(1, target.nextSibling) || navigator2.getAdjacent(-1, target);
        }
        if (!fallback) {
          me.widgetMap.viewContainer.revertFocus(true);
        } else {
          const nextActiveDate = activeView.getDateFromElement(fallback), nextActiveEventId = fallback.dataset.eventId, nextActiveView = me.constructor.fromElement(fallback).closest(isCalendarMixin);
          fallback.focus();
          nextActiveView.ion({
            refresh: () => {
              fallback = nextActiveView.getEventElement(nextActiveEventId, nextActiveDate);
              if (fallback) {
                if (fallback === DomHelper.getActiveElement(fallback)) {
                  navigator2.triggerNavigate({
                    eventPhase: Event.BUBBLING_PHASE,
                    target: fallback
                  }, fallback);
                } else {
                  fallback.focus();
                }
              }
              navigator2.updateActiveItem(fallback, activeItem);
            },
            once: true
          });
        }
      }
    }
    (_super$onCalendarStor = super.onCalendarStoreChange) === null || _super$onCalendarStor === void 0 ? void 0 : _super$onCalendarStor.call(this, ...arguments);
  }
  onElementKeyDown(keyEvent) {
    if (keyEvent.target.closest(this.navigator.itemSelector)) {
      var _super$onElementKeyDo;
      (_super$onElementKeyDo = super.onElementKeyDown) === null || _super$onElementKeyDo === void 0 ? void 0 : _super$onElementKeyDo.call(this, keyEvent);
    }
  }
  get activeEvent() {
    const {
      activeItem
    } = this.navigator;
    if (activeItem) {
      return this.resolveEventRecord(activeItem);
    }
  }
  get widgetClass() {
  }
};
var EventSelection = (Target) => class EventSelection extends SchedulerEventSelection(Target || Base$1) {
  normalizeTarget(event) {
    return event.eventRecord;
  }
  onSelectedCollectionChange({
    added,
    removed
  }) {
    const me = this, selection = me.selectedCollection, selected = added || [], deselected = removed || [];
    me.updateSelected();
    if (!me.silent) {
      const action = selection.count > 0 ? selected.length > 0 && deselected.length > 0 ? "update" : selected.length > 0 ? "select" : "deselect" : "clear";
      me.trigger("selectionChange", {
        action,
        selection: selection.values,
        selected,
        deselected
      });
    }
  }
  onCalendarStoreChange({
    action,
    records
  }) {
    var _super$onCalendarStor;
    if (action === "remove") {
      this.selectedCollection.remove(...records);
    }
    (_super$onCalendarStor = super.onCalendarStoreChange) === null || _super$onCalendarStor === void 0 ? void 0 : _super$onCalendarStor.call(this, ...arguments);
  }
  clearEventSelection() {
    this.selectedCollection.clear();
  }
  get selectedEvents() {
    return this.selectedCollection.values;
  }
  set selectedEvents(events) {
    events = ArrayHelper.asArray(events);
    this.selectedCollection.splice(0, this.selectedCollection.count, events);
  }
  isEventSelected(event) {
    return this.selectedCollection.includes(event);
  }
  select(event, preserveSelection = false) {
    this.selectEvent(event, preserveSelection);
  }
  selectEvent(event, preserveSelection = false) {
    const {
      selectedCollection
    } = this;
    if (!this.isEventSelected(event) && this.isEventSelectable(event) !== false) {
      preserveSelection ? selectedCollection.add(event) : selectedCollection.splice(0, selectedCollection.count, event);
    }
  }
  deselect(event) {
    this.deselectEvent(event);
  }
  deselectEvent(event) {
    if (this.isEventSelected(event)) {
      this.selectedCollection.remove(event);
    }
  }
  selectEvents(events) {
    this.selectedCollection.add(events.filter((event) => this.isEventSelectable(event) !== false));
  }
  deselectEvents(events) {
    this.selectedCollection.remove(events);
  }
  onEventSelectionClick(clickedRecord) {
    if (this.isEventSelected(clickedRecord)) {
      if (GlobalEvents$1.ctrlKeyDown) {
        this.deselectEvent(clickedRecord);
      }
    } else {
      this.selectEvent(clickedRecord, this.multiEventSelect && GlobalEvents$1.ctrlKeyDown);
    }
  }
  onEventNavigate({
    event,
    item
  }) {
    if (item) {
      const eventRecord = this.activeView.getEventRecord(item);
      if (eventRecord) {
        if (event.button === 2 && this.isEventSelected(eventRecord)) {
          return;
        }
        this.onEventSelectionClick(eventRecord);
      } else {
        this.clearEventSelection();
      }
    }
  }
  get widgetClass() {
  }
};
var byWeight = (l, r) => (l.weight || 0) - (r.weight || 0);
var capitalizeRegExp = /(?:.)cell|number|name|overflow|mouse|down|up|dbl|click|over|out|context|menu|date|change|element|popup/g;
var relayedEvents = /^.*event.*|.*resource.*|.*cell.*|.*row.*|.*schedule.*|daynumber.*|weeknumber.*|monthname.*|weekname.*$|beforedatechange|tickchange|.*showoverflowpopup/;
var capitalizeWord = (m) => StringHelper.capitalize(m);
var isFocusedCalendarMixin = (w) => w.isCalendarMixin && w.containsFocus;
var Calendar = class extends Panel.mixin(SchedulerInterface, CalendarStores, Featureable, CrudManagerView, EventNavigation, EventSelection, CurrentConfig, Responsive, State, RecurringEvents) {
  static get $name() {
    return "Calendar";
  }
  static get type() {
    return "calendar";
  }
  static get configurable() {
    return {
      enableRecurringEvents: true,
      localizableProperties: ["autoCreate.newName"],
      crudManager: null,
      features: {
        drag: {},
        eventEdit: {},
        eventTooltip: {},
        eventMenu: {}
      },
      navigatorPlacement: null,
      responsive: {
        small: {
          when: 600,
          once: {
            mode: "day"
          }
        },
        medium: {
          when: 800
        },
        large: {
          overlaySidebar: false
        },
        "*": {
          overlaySidebar: true,
          once: {
            mode: "week"
          }
        }
      },
      responsiveRoot: true,
      stateful: ["hideNonWorkingDays", "mode"],
      tbar: {
        cls: "b-calendar-toolbar",
        items: {
          toggleSideBar: {
            icon: "b-icon-menu-vertical",
            cls: "b-sidebar-toggle b-borderless b-transparent",
            onClick: "up.onToggleSidebarClick",
            weight: 100
          },
          todayButton: {
            text: "L{Calendar.Today}",
            cls: "b-cal-nav-item b-calendar-today-button",
            icon: "b-icon-calendar-day",
            onClick: "up.shiftToNow",
            weight: 200
          },
          prevButton: {
            onClick: "up.shiftPrevious",
            cls: "b-cal-nav-item b-borderless b-transparent",
            icon: "b-icon-previous",
            weight: 300
          },
          nextButton: {
            onClick: "up.shiftNext",
            cls: "b-cal-nav-item b-borderless b-transparent",
            icon: "b-icon-next",
            weight: 400
          },
          viewDescription: {
            cls: "b-calendar-view-desc",
            type: "widget",
            flex: "",
            html: "\xA0",
            overflowable: "none",
            weight: 500
          },
          spacer: {
            type: "widget",
            cls: "b-toolbar-fill",
            weight: 600
          },
          modeSelector: {
            type: "calendarModeSelector",
            weight: 700
          }
        }
      },
      items: {
        viewContainer: {
          type: "container",
          cls: "b-calendar-viewcontainer",
          flex: "1 1 100%",
          layout: {
            type: "card"
          },
          scrollable: {
            overflowY: true,
            overflowX: true
          },
          suppressChildHeaders: true,
          layoutStyle: {
            padding: 0
          },
          internalListeners: {
            beforeActiveItemChange: "up.onBeforeModeChange",
            activeItemChange: "up.onModeChange"
          }
        }
      },
      includeWeekendsButton: false,
      layoutStyle: {
        padding: 0,
        flexFlow: "row nowrap"
      },
      modes: {
        day: {
          fixedDuration: true
        },
        week: {},
        month: {},
        year: {},
        agenda: {}
      },
      mode: "week",
      modeDefaults: {
        value: null
      },
      sidebar: {
        $config: {
          merge: "objects"
        },
        value: {
          type: "sidebar",
          side: "left",
          scrollable: {
            overflowY: true
          },
          internalListeners: {
            dateChange: "up.onCalendarDateChange"
          }
        }
      },
      datePicker: {
        $config: {
          merge: "objects"
        },
        value: {
          weight: 100,
          dayNameFormat: "d1",
          editMonth: null,
          focusable: false,
          trapFocus: false
        }
      },
      overlaySidebar: null,
      date: {
        $config: {
          equal: "date"
        },
        value: new Date()
      },
      dateFormat: "MMMM DD, YYYY",
      scrollManager: {
        $config: ["lazy", "nullify"],
        value: {
          direction: "vertical"
        }
      },
      viewUpdateDelay: 2e3,
      readOnly: null,
      allowOverlap: true,
      testConfig: {
        viewUpdateDelay: 5,
        loadMask: {
          text: "L{GridBase.loadMask}",
          showDelay: 0
        }
      },
      highlightDate: null,
      autoCreate: {
        gesture: "dblclick",
        newName: "L{Object.newEvent}",
        step: "15 minutes",
        duration: "1 hour",
        startHour: 8
      },
      focusable: false,
      eventCls: "b-cal-event",
      weekStartDay: false,
      hideNonWorkingDays: null,
      nonWorkingDays: false,
      coreHours: null,
      contextMenuTriggerEvent: "contextmenu",
      enableUndoRedoKeys: true,
      resourceImagePath: null,
      minDate: null,
      maxDate: null
    };
  }
  static get delayable() {
    return {
      refresh: {
        type: "raf",
        cancelOutstanding: true
      },
      syncUIWithActiveView: {
        type: "buffer",
        delay: 1,
        cancelOutstanding: true
      }
    };
  }
  compose() {
    const {
      includeWeekendsButton,
      navigatorPlacement
    } = this;
    return {
      class: {
        [`b-calendar-nav-${navigatorPlacement || "toolbar"}`]: 1,
        "b-calendar-include-weekends-button": includeWeekendsButton
      }
    };
  }
  onPaintOverride() {
  }
  onPaint() {
    if (this.onPaintOverride()) {
      return;
    }
    super.onPaint();
  }
  onShowOverflowPopup({
    overflowPopup
  }) {
    this.element.classList.add("b-overflow-popup-visible");
    overflowPopup.ion({
      hide: () => this.element.classList.remove("b-overflow-popup-visible"),
      once: true
    });
  }
  static get featureable() {
    return {
      factory: CalendarFeature
    };
  }
  get dateTimeNow() {
    if (this.timeZone != null) {
      return TimeZoneHelper.toTimeZone(new Date(), this.timeZone);
    }
    return new Date();
  }
  get today() {
    const today = this.dateTimeNow;
    today.setHours(0, 0, 0, 0);
    return today;
  }
  finalizeInit() {
    var _me$activeView;
    super.finalizeInit();
    const me = this, hideNonWorkingDays = (_me$activeView = me.activeView) === null || _me$activeView === void 0 ? void 0 : _me$activeView.hideNonWorkingDays;
    if (hideNonWorkingDays != null && me.hideNonWorkingDays == null) {
      me.hideNonWorkingDays = hideNonWorkingDays;
    }
  }
  toggleEmptyText() {
    const {
      crudManager
    } = this, {
      eventStore
    } = crudManager || this;
    DomHelper.toggleClasses(this.contentElement, "b-calendar-empty", !(eventStore.count || crudManager !== null && crudManager !== void 0 && crudManager.isLoading));
  }
  refresh() {
    this.eachView((v) => {
      var _v$refresh;
      return (_v$refresh = v.refresh) === null || _v$refresh === void 0 ? void 0 : _v$refresh.call(v);
    });
  }
  get views() {
    const {
      modes
    } = this;
    return modes ? Object.values(modes) : [];
  }
  get activeView() {
    return this.viewContainer.layout.activeItem;
  }
  get activeSubView() {
    var _items$filter;
    const {
      activeView
    } = this, {
      items: items2
    } = activeView, activeSubView = (_items$filter = items2.filter(isFocusedCalendarMixin)) === null || _items$filter === void 0 ? void 0 : _items$filter[0];
    return activeSubView || activeView;
  }
  captureFocus() {
    return this.activeView.captureFocus();
  }
  getEventRecord(elementOrEvent) {
    return this.activeView.getEventRecord(elementOrEvent);
  }
  resolveEventRecord(elementOrEvent) {
    return this.getEventRecord(elementOrEvent);
  }
  onBeforeModeChange({
    prevActiveItem,
    activeItem
  }) {
    var _prevActiveItem$_over, _prevActiveItem$_over2;
    if (this.trigger("beforeActiveItemChange", arguments[0]) === false) {
      return false;
    }
    (_prevActiveItem$_over = prevActiveItem._overflowPopup) === null || _prevActiveItem$_over === void 0 ? void 0 : (_prevActiveItem$_over2 = _prevActiveItem$_over.hide) === null || _prevActiveItem$_over2 === void 0 ? void 0 : _prevActiveItem$_over2.call(_prevActiveItem$_over);
    if ("date" in activeItem && activeItem.syncViewDate !== false) {
      const date2 = this.date || prevActiveItem.date;
      if (date2) {
        activeItem.date = date2;
      }
    }
  }
  onModeChange(event) {
    this.trigger("activeItemChange", event);
  }
  onToggleSidebarClick() {
    const {
      sidebar
    } = this, {
      collapsible
    } = sidebar;
    if (collapsible !== null && collapsible !== void 0 && collapsible.isPanelCollapserOverlay) {
      collapsible.toggleReveal(!sidebar.revealed);
    } else {
      sidebar.toggleCollapsed();
    }
  }
  shiftToNow() {
    var _me$sidebar;
    const me = this, datePicker = (_me$sidebar = me.sidebar) === null || _me$sidebar === void 0 ? void 0 : _me$sidebar.widgetMap.datePicker, {
      dayTime
    } = me.activeView, now2 = new Date(), today = dayTime ? dayTime.startOfDay(now2) : DateHelper.clearTime(now2);
    me.date = today;
    datePicker && (datePicker.date = today);
    me.updateViewDescription();
  }
  shiftPrevious() {
    const {
      activeItem
    } = this.viewContainer.layout;
    if (activeItem !== null && activeItem !== void 0 && activeItem.previous) {
      activeItem.previous();
      this.updateViewDescription(activeItem);
      if (activeItem.animateTimeShift) {
        DomHelper.slideIn(activeItem.contentElement, -1);
      }
    }
  }
  shiftNext() {
    const {
      activeItem
    } = this.viewContainer.layout;
    if (activeItem !== null && activeItem !== void 0 && activeItem.next) {
      activeItem.next();
      this.updateViewDescription(activeItem);
      if (activeItem.animateTimeShift) {
        DomHelper.slideIn(activeItem.contentElement, 1);
      }
    }
  }
  async onCalendarDateChange({
    date: date2,
    userAction
  }) {
    const me = this, {
      activeItem
    } = me.viewContainer.layout, {
      date: oldDate,
      highlightDate
    } = me;
    if (activeItem && activeItem.syncViewDate !== false && "date" in activeItem) {
      const {
        getDayElement
      } = activeItem;
      if (!DateHelper.betweenLesser(date2, activeItem.startDate, activeItem.endDate)) {
        var _activeItem$_overflow, _activeItem$_overflow2;
        (_activeItem$_overflow = activeItem._overflowPopup) === null || _activeItem$_overflow === void 0 ? void 0 : (_activeItem$_overflow2 = _activeItem$_overflow.hide) === null || _activeItem$_overflow2 === void 0 ? void 0 : _activeItem$_overflow2.call(_activeItem$_overflow);
      }
      activeItem.date = date2;
      if (userAction && highlightDate && getDayElement) {
        var _activeItem$getDayEle;
        if (activeItem.scrollTo) {
          await activeItem.scrollTo(date2);
          if (activeItem.scrolledToDate) {
            date2 = activeItem.scrolledToDate;
          }
        }
        const cell = (_activeItem$getDayEle = activeItem.getDayElement) === null || _activeItem$getDayEle === void 0 ? void 0 : _activeItem$getDayEle.call(activeItem, date2);
        if (cell) {
          if (isNaN(highlightDate)) {
            me.callback(highlightDate, me, [cell, me]);
          } else {
            DomHelper.highlight(Rectangle.from(cell));
          }
        }
      }
    }
    me.trigger("dateChange", {
      oldDate,
      date: date2
    });
  }
  updateViewDescription(activeView = this.activeView) {
    const me = this, {
      tbar,
      widgetMap
    } = me, {
      viewDescription
    } = widgetMap, description = `<span class="b-calendar-view-desc-text">${(activeView === null || activeView === void 0 ? void 0 : activeView.description) || ""}</span>`;
    me.element.dataset.mode = me.activeView.modeName;
    if (activeView) {
      if (tbar && viewDescription) {
        if (viewDescription.content !== description) {
          viewDescription.content = description;
        }
      }
      const viewDate = activeView.date || activeView.startDate;
      if (viewDate) {
        this.date = viewDate;
      }
    }
  }
  getStepUnitText(activeView = this.activeView) {
    return activeView.stepUnit;
  }
  syncUIWithActiveView(activeView = this.activeView) {
    const me = this, {
      tbar,
      sidebar,
      widgetMap
    } = me, {
      toggleSideBar
    } = widgetMap;
    if (tbar && activeView !== null && activeView !== void 0 && activeView.isVisible) {
      const {
        prevButton,
        nextButton,
        modeSelector
      } = widgetMap, stepUnitText = me.getStepUnitText(activeView);
      modeSelector === null || modeSelector === void 0 ? void 0 : modeSelector.syncActiveMode(activeView);
      if (sidebar) {
        sidebar.stepUnitText = stepUnitText;
      }
      me.updateViewDescription(activeView);
      if (prevButton) {
        prevButton.tooltip = stepUnitText ? me.L("L{previous}", stepUnitText) : "";
        prevButton.disabled = !stepUnitText;
      }
      if (nextButton) {
        nextButton.tooltip = stepUnitText ? me.L("L{next}", stepUnitText) : "";
        nextButton.disabled = !stepUnitText;
      }
    }
    if (!sidebar) {
      toggleSideBar === null || toggleSideBar === void 0 ? void 0 : toggleSideBar.hide();
    }
  }
  updateEventStore(eventStore) {
    this.detachListeners("eventStoreDateRange");
    this.features.loadOnDemand;
    this.processConfiguredListeners();
    eventStore.ion({
      loadDateRange: "onEventStoreDateRangeRequested",
      name: "eventStoreDateRange",
      thisObj: this
    });
    if (this.sidebar) {
      this.sidebar.eventStore = eventStore;
    }
  }
  eachView(fn2, args, thisObj = null) {
    const passView = args == null;
    for (const view of this.views) {
      if (passView) {
        args = [view];
      }
      if (view.callback(fn2, thisObj || view, args) === false) {
        return;
      }
    }
  }
  onEventStoreDateRangeRequested(event) {
    if (event.changed) {
      this.trigger("dateRangeChange", event);
    }
    this.trigger("dateRangeRequested", event);
  }
  async onModeSelectorToggle({
    source: button,
    pressed
  }) {
    if (pressed) {
      const me = this, {
        layout
      } = me.viewContainer, {
        view
      } = button;
      await me.modeSelectionPromise;
      me.modeSelectionPromise = layout.setActiveItem(view).promise;
    }
  }
  updateMode(mode) {
    const me = this, configs = me.initialConfig || {};
    if (!(me.isConfiguring || me._responsiveUpdating && ("mode" in configs || "activeIndex" in configs))) {
      mode = typeof mode === "string" ? me.modes[mode] : mode;
      if (mode && mode !== me.activeView) {
        me.viewContainer.layout.setActiveItem(mode, void 0, {
          animation: !me.isResponsiveUpdating
        });
      }
    }
  }
  onEventStoreRefresh() {
    if (!this.isConfiguring) {
      this.syncUIWithActiveView(this.viewContainer.layout.activeItem);
    }
  }
  handleViewPaint({
    source: view
  }) {
    this.syncUIWithActiveView(view);
    this._mode = view.modeName;
    this.trigger("viewPaint", _objectSpread2({}, arguments[0]));
  }
  onViewRefresh({
    source: view
  }) {
    var _super$onViewRefresh;
    (_super$onViewRefresh = super.onViewRefresh) === null || _super$onViewRefresh === void 0 ? void 0 : _super$onViewRefresh.call(this, ...arguments);
    if (view.isVisible) {
      if (view === this.activeView) {
        this.updateViewDescription(view);
      } else if (this.activeView.owns(view)) {
        this.syncUIWithActiveView(this.activeView);
      }
    }
  }
  updateEventCls(eventCls) {
    if (!this.initialConfig.eventInnerSelector) {
      this.eventInnerSelector = `.${eventCls}`;
    }
    if (!this.initialConfig.eventSelector) {
      this.eventSelector = `${this.eventInnerSelector}-wrap`;
    }
  }
  changeModes(modes, was) {
    const me = this, {
      mode
    } = me;
    me.getConfig("crudManager");
    me.getConfig("defaultCalendar");
    if (mode && mode in modes) {
      const modeArray = [];
      let activeIndex = null, index = 0, modeConfig;
      for (const modeType in modes) {
        modeConfig = modes[modeType];
        if (modeConfig) {
          var _modeConfig$weight;
          if (typeof modeConfig === "object" && "weight" in modeConfig) {
            activeIndex = null;
          } else if (modeConfig && modeType === mode) {
            activeIndex = index;
          }
          modeArray.push(ObjectHelper.assign({
            modeType,
            weight: (_modeConfig$weight = modeConfig.weight) !== null && _modeConfig$weight !== void 0 ? _modeConfig$weight : 0
          }, modeConfig));
          index++;
        } else {
          modeArray.push(false);
        }
      }
      if (activeIndex == null) {
        modes = {};
        modeArray.sort(byWeight);
        for (let i = 0, {
          length
        } = modeArray; i < length; i++) {
          modeConfig = modeArray[i];
          modes[modeConfig.modeType] = modeConfig;
          if (modeArray[i].modeType === mode) {
            activeIndex = i;
          }
        }
      }
      me.activeModeIndex = activeIndex;
    }
    const {
      tbar,
      element
    } = me, listeners = {
      thisObj: me,
      descriptionChange: "onViewDescriptionChange",
      weekNumberClick: "onViewWeekNumberClick",
      monthNameClick: "onViewMonthNameClick",
      dayNumberClick: "onViewDayNumberClick",
      beforeEventAdd: "onViewBeforeEventAdd",
      catchAll: {
        fn: "onViewCatchAll",
        prio: 1e4
      },
      paint: "handleViewPaint",
      refresh: "onViewRefresh"
    }, manager = me.$modes || (me.$modes = new DynamicObject({
      factory: Modes,
      inferType: true,
      owner: me,
      ownerName: "calendar",
      created(mode2, name) {
        var _tbar$widgetMap;
        mode2.modeName = name;
        if (mode2.isScheduler) {
          const {
            eventEdit
          } = me.features;
          if (eventEdit) {
            eventEdit.applyPluginConfig(mode2);
            mode2.editEvent = me.editEvent.bind(me);
          }
        }
        if (mode2.autoCreate !== false) {
          mode2.autoCreate = me.autoCreate;
        }
        element.classList.add(`b-cal-${name}`);
        mode2.ion(listeners);
        me.relayEvents(mode2, ["eventPropagate"]);
        if (!me.isConfiguring) {
          me.trigger("addMode", {
            mode: mode2
          });
        }
        const modeSelector = tbar === null || tbar === void 0 ? void 0 : (_tbar$widgetMap = tbar.widgetMap) === null || _tbar$widgetMap === void 0 ? void 0 : _tbar$widgetMap.modeSelector;
        if (modeSelector) {
          modeSelector.calendar = me;
          modeSelector.addMode(name, mode2);
        }
      },
      setup(config) {
        const {
          defaultCalendar,
          hideNonWorkingDays,
          modeDefaults
        } = me, viewType = Modes.resolveType(config.type);
        if (modeDefaults) {
          config = ObjectHelper.merge({}, modeDefaults, config);
        }
        if (viewType.isScheduler) {
          const features = config.features || (config.features = {});
          features.eventTooltip = features.eventMenu = features.eventEdit = features.scheduleMenu = false;
        } else {
          config.eventSelector = me.eventSelector;
          config.eventInnerSelector = me.eventInnerSelector;
        }
        config.rtl = me.rtl;
        config.project = me.project;
        config.readOnly = me.readOnly;
        config.allowOverlap = me.allowOverlap;
        config.hidden = true;
        config.weekStartDay = me.weekStartDay;
        config.nonWorkingDays = me.nonWorkingDays;
        config.timeZone = me.timeZone;
        if (me.coreHours) {
          config.coreHours = me.coreHours;
        }
        if (me.resourceImagePath) {
          config.resourceImagePath = me.resourceImagePath;
        }
        if (ObjectHelper.hasOwn(me, "_defaultCalendar")) {
          config.defaultCalendar = me._defaultCalendar;
        } else if (defaultCalendar != null) {
          config.defaultCalendar = defaultCalendar;
        }
        if (hideNonWorkingDays != null) {
          config.hideNonWorkingDays = hideNonWorkingDays;
        }
        if (me.date && !config.date) {
          config.date = me.date;
        }
        if (!config.dateFormat) {
          config.dateFormat = me.dateFormat;
        }
        if (me.visibleStartTime) {
          config.visibleStartTime = me.visibleStartTime;
        }
        return config;
      }
    }));
    manager.update(modes);
    if (!was) {
      return manager.target;
    }
  }
  changeModeDefaults(modeDefaults) {
    const me = this, result = new Proxy(ObjectHelper.assign({}, modeDefaults), {
      set(target, prop, value) {
        const result2 = Reflect.set(...arguments);
        me.updateModeDefaults({
          [prop]: value
        });
        return result2;
      },
      deleteProperty(target, prop) {
        const result2 = Reflect.deleteProperty(...arguments);
        me.updateModeDefaults({
          [prop]: null
        });
        return result2;
      }
    });
    return result;
  }
  updateModeDefaults(modeDefaults) {
    if (!this.isConfiguring) {
      this.eachView((v) => v.setConfig(modeDefaults));
    }
  }
  get collapsibleConfig() {
    const overlaySidebar = this.peekConfig("overlaySidebar"), config = {
      type: overlaySidebar ? "overlay" : "inline",
      tool: null
    };
    if (overlaySidebar) {
      config.recollapseTool = null;
    }
    return config;
  }
  updateOverlaySidebar(overlaySidebar) {
    const {
      sidebar,
      collapsibleConfig
    } = this, collapsible = sidebar === null || sidebar === void 0 ? void 0 : sidebar.collapsible;
    if (collapsible) {
      if (collapsible.type !== collapsibleConfig.type) {
        sidebar.collapsible = collapsibleConfig;
      }
      if (overlaySidebar) {
        if (!sidebar.collapsed) {
          sidebar.collapsed = true;
          sidebar.collapsedDueToOverlay = true;
        }
      } else if (sidebar.collapsedDueToOverlay || sidebar.isVisible && collapsible.isPanelCollapserOverlay) {
        sidebar.collapsed = false;
        sidebar.collapsedDueToOverlay = false;
      }
    }
  }
  changeSidebar(config, sidebar) {
    const me = this, {
      datePicker,
      statefulId: stateId
    } = me;
    if (config) {
      const sidebarItems = config.items || (config.items = {}), sidebarDatePicker = sidebarItems.datePicker;
      if (datePicker) {
        if (sidebarDatePicker !== null && sidebarDatePicker !== false) {
          sidebarItems.datePicker = Calendar.mergeConfigs(sidebarItems.datePicker, datePicker);
        }
      } else {
        sidebarItems.datePicker = null;
      }
    }
    return Sidebar.reconfigure(sidebar, config, {
      owner: me,
      setup: (cfg, type) => me.setupWidgetConfig(cfg, type),
      defaults: {
        stateId: stateId && `${stateId}:sidebar`,
        eventStore: me.eventStore,
        date: me.date,
        weight: (config === null || config === void 0 ? void 0 : config.side) === "right" ? 10 : -10,
        collapsible: me.collapsibleConfig,
        items: {
          datePicker: {
            weekStartDay: me.weekStartDay
          }
        }
      }
    });
  }
  changeDatePicker(config) {
    if (config) {
      return Object.assign(config, {
        eventStore: this.eventStore,
        date: this.date
      });
    }
  }
  get datePicker() {
    return this.isConfiguring ? this._datePicker : this.sidebar.widgetMap.datePicker;
  }
  changeItems(items2) {
    const {
      modes,
      sidebar
    } = this, {
      viewContainer
    } = items2;
    if (sidebar) {
      items2.sidebar = sidebar;
    }
    if (viewContainer) {
      viewContainer.items = modes;
    }
    if (this.activeModeIndex) {
      viewContainer.layout.activeIndex = this.activeModeIndex;
    }
    const result = super.changeItems(items2);
    this.viewContainer = this.widgetMap.viewContainer;
    return result;
  }
  onViewCatchAll(event) {
    const me = this, {
      fromOverflowPopup,
      type,
      source: view
    } = event;
    if (event.bubbles) {
      return;
    }
    let result, date2, {
      domEvent
    } = event;
    if (!domEvent && DomHelper.isDOMEvent(event.event)) {
      domEvent = event.event;
    }
    me.eventSource = view;
    if (!domEvent || me.handleEvent(domEvent) !== false) {
      var _view$getDateFromDomE;
      const isEmptyCell = type.startsWith("emptycell");
      if (type.endsWith("click") && me.activeView.isCalendarMixin && (date2 = event.date || ((_view$getDateFromDomE = view.getDateFromDomEvent) === null || _view$getDateFromDomE === void 0 ? void 0 : _view$getDateFromDomE.call(view, domEvent)))) {
        const isOverflowClick = fromOverflowPopup || type === "celloverflowclick" || domEvent.target.closest(".b-cal-cell-overflow"), isOtherMonth = view.getDayElement && !view.getDayElement(date2, true), changeDate = !(fromOverflowPopup && isOtherMonth) && !isEmptyCell && (type === "daynumberclick" || !(isOtherMonth && (isOverflowClick || type.startsWith("event") || type.startsWith("schedule"))));
        if (changeDate) {
          me.date = date2;
        }
      }
      if (isEmptyCell || relayedEvents.test(type)) {
        result = me.trigger(type.replaceAll(capitalizeRegExp, capitalizeWord), _objectSpread2(_objectSpread2({}, event), {}, {
          view
        }));
      }
    }
    me.eventSource = null;
    return result;
  }
  onViewDescriptionChange() {
    this.updateViewDescription();
  }
  onViewWeekNumberClick({
    week
  }) {
    const weekView = this.modes.week || this.viewContainer.query((v) => {
      var _v$view;
      return ((_v$view = v.view) === null || _v$view === void 0 ? void 0 : _v$view.type.toLowerCase()) === "weekview";
    });
    if (weekView) {
      weekView.week = week;
      this.viewContainer.layout.activeItem = weekView;
    }
  }
  onViewMonthNameClick({
    date: date2
  }) {
    const monthView = this.modes.month || this.viewContainer.query((v) => {
      var _v$view2;
      return ((_v$view2 = v.view) === null || _v$view2 === void 0 ? void 0 : _v$view2.type.toLowerCase()) === "monthview";
    });
    if (monthView) {
      monthView.date = date2;
      this.viewContainer.layout.activeItem = monthView;
    }
  }
  onViewDayNumberClick({
    source,
    date: date2,
    cellData,
    fromOverflowPopup,
    domEvent
  }) {
    var _cellData$events;
    const validYearViewNavigate = source.isYearView && (source.overflowPopupTrigger !== "click" || fromOverflowPopup || !((_cellData$events = cellData.events) !== null && _cellData$events !== void 0 && _cellData$events.length) && !source.emptyCellRenderer);
    if (source.isCalendarRow || source.isMonthView || validYearViewNavigate || source.isAgendaView) {
      const {
        viewContainer
      } = this, dayView = this.modes.day || viewContainer.query((v) => {
        var _v$view3;
        return ((_v$view3 = v.view) === null || _v$view3 === void 0 ? void 0 : _v$view3.type.toLowerCase()) === "dayview";
      });
      if (dayView && source !== dayView.allDayEvents) {
        const {
          layout
        } = viewContainer, {
          activeItem: oldActiveItem
        } = layout, {
          syncViewDate
        } = oldActiveItem;
        oldActiveItem.syncViewDate = false;
        this.date = date2;
        viewContainer.layout.activeItem = dayView;
        oldActiveItem.syncViewDate = syncViewDate;
        return false;
      }
    }
  }
  onViewBeforeEventAdd({
    eventRecord,
    assignmentRecords
  }) {
    const {
      eventEdit
    } = this.features, isCreating = eventEdit && !eventEdit.disabled;
    eventRecord.isCreating = isCreating;
    assignmentRecords === null || assignmentRecords === void 0 ? void 0 : assignmentRecords.forEach((assignmentRecord) => assignmentRecord.isCreating = isCreating);
  }
  createEvent(date2 = this.date) {
    this.doCreateEvent(date2);
  }
  doCreateEvent(date2, source = this.activeView) {
    const {
      modes
    } = this, editingView = source.isYearView ? modes.week || modes.month || modes.day || source : source;
    if (!this.activeView.owns(editingView)) {
      const {
        viewContainer
      } = this.widgetMap, {
        layout
      } = viewContainer;
      if (editingView) {
        viewContainer.ion({
          activeItemChange: "doCreateEvent",
          thisObj: source,
          once: true,
          args: [date2, editingView]
        });
        editingView.date = date2;
        layout.activeItem = editingView;
        return false;
      }
    } else {
      source.doCreateEvent(date2);
    }
  }
  changeDate(date2, oldDate) {
    date2 = typeof date2 === "string" ? DateHelper.parse(date2) : new Date(date2);
    if (isNaN(date2)) {
      throw new Error("Calendar widget date ingestion must be passed a Date, or a YYYY-MM-DD date string");
    }
    date2 = DateHelper.clearTime(date2);
    if (!oldDate || date2 - oldDate) {
      return date2;
    }
  }
  updateAutoCreate() {
    if (!this.isConfiguring) {
      this.syncCommonConfig("autoCreate");
    }
  }
  updateDate(date2, oldDate) {
    if (!this.isConfiguring) {
      const {
        sidebar
      } = this;
      if (sidebar) {
        sidebar.date = date2;
      } else {
        this.onCalendarDateChange({
          date: date2
        });
      }
    }
  }
  updateDateFormat() {
    if (!this.isConfiguring) {
      this.syncCommonConfig("dateFormat");
    }
  }
  changeIncludeWeekendsButton(value) {
    return value === true ? {} : value;
  }
  updateIncludeWeekendsButton(value) {
    if (!this.isConstructing && value && ObjectHelper.isObject(value)) {
      this.widgetMap.modeSelector.includeWeekendsButton = value;
    }
  }
  changeScrollManager(scrollManager, oldScrollManager) {
    oldScrollManager === null || oldScrollManager === void 0 ? void 0 : oldScrollManager.destroy();
    if (this.isDestroying) {
      return;
    }
    return new ScrollManager(Object.assign({
      element: this.element
    }, scrollManager));
  }
  updateDefaultCalendar() {
    if (!this.isConfiguring) {
      this.syncCommonConfig("defaultCalendar");
    }
  }
  changeWeekStartDay(weekStartDay) {
    if (weekStartDay === false) {
      weekStartDay = DateHelper.weekStartDay;
    }
    return weekStartDay;
  }
  updateReadOnly() {
    super.updateReadOnly(...arguments);
    if (!this.isConfiguring) {
      this.syncCommonConfig("readOnly");
    }
  }
  updateWeekStartDay(weekStartDay) {
    if (!this.isConfiguring) {
      var _this$sidebar;
      this.syncCommonConfig("weekStartDay");
      if ((_this$sidebar = this.sidebar) !== null && _this$sidebar !== void 0 && _this$sidebar.widgetMap.datePicker) {
        this.sidebar.widgetMap.datePicker.weekStartDay = weekStartDay;
      }
    }
  }
  updateHideNonWorkingDays(hideNonWorkingDays, was) {
    if (!this.isConfiguring) {
      this.syncCommonConfig("hideNonWorkingDays");
      this.trigger("changeHideNonWorkingDays", {
        value: hideNonWorkingDays,
        was
      });
    }
  }
  changeNonWorkingDays(nonWorkingDays) {
    if (nonWorkingDays === false) {
      nonWorkingDays = ObjectHelper.assign({}, DateHelper.nonWorkingDays);
    }
    return nonWorkingDays;
  }
  updateNonWorkingDays() {
    if (!this.isConfiguring) {
      this.syncCommonConfig("nonWorkingDays");
    }
  }
  updateCoreHours() {
    if (!this.isConfiguring) {
      this.syncCommonConfig("coreHours");
    }
  }
  syncCommonConfig(name) {
    this.eachView((v) => {
      v[name] = this[name];
    });
  }
  onCalendarStoreChange() {
    var _super$onCalendarStor;
    (_super$onCalendarStor = super.onCalendarStoreChange) === null || _super$onCalendarStor === void 0 ? void 0 : _super$onCalendarStor.call(this, ...arguments);
  }
  updateSelected() {
    const eventEls = this.viewContainer.contentElement.querySelectorAll(".b-cal-event-wrap");
    for (let i = 0, {
      length
    } = eventEls; i < length; i++) {
      eventEls[i].classList[this.isEventSelected(eventEls[i].dataset.eventId) ? "add" : "remove"]("b-selected");
    }
  }
  getElementFromEventRecord(record) {
    return this.activeView.getEventElement(record);
  }
  updateLocalization() {
    const me = this;
    if (me.isPainted) {
      let refreshed = false;
      if (!("weekStartDay" in me.initialConfig) && me.weekStartDay !== DateHelper.weekStartDay) {
        me.weekStartDay = DateHelper.weekStartDay;
        refreshed = true;
      }
      if (!("nonWorkingDays" in me.initialConfig) && !ObjectHelper.isEqual(me.nonWorkingDays, DateHelper.nonWorkingDays)) {
        me.nonWorkingDays = DateHelper.nonWorkingDays;
        refreshed = true;
      }
      if (!refreshed) {
        me.refresh();
      }
      me.syncUIWithActiveView();
    }
    super.updateLocalization();
  }
};
Calendar.initClass();
if (globalThis.bryntum) {
  globalThis.bryntum.Calendar = Calendar;
}
var Modes = class extends Base$1.mixin(Factoryable) {
  static get factoryable() {
    return {
      extends: Widget
    };
  }
};
Modes.register("agenda", AgendaView);
Modes.register("year", YearView);
Modes.register("month", MonthView);
Modes.register("week", WeekView);
Modes.register("day", DayView);
Modes.register("list", EventList);
Modes.register("resource", ResourceView);
Calendar.Modes = Modes;
VersionHelper.setVersion("calendar", "5.3.0");
Calendar._$name = "Calendar";

export {
  BrowserHelper,
  StringHelper,
  Objects,
  VersionHelper,
  Config,
  Base$1,
  ArrayHelper,
  FunctionHelper,
  Events,
  AsyncHelper,
  AjaxHelper,
  LocaleHelper,
  LocaleManagerSingleton,
  Localizable,
  unitMagnitudes,
  DateHelper,
  ObjectHelper,
  Rectangle,
  DomClassList,
  Point,
  EventHelper,
  DomHelper,
  GlobalEvents$1,
  InstancePlugin,
  Pluggable,
  Delayable,
  StateStorage,
  StateProvider,
  State,
  Identifiable,
  ModelStm,
  TreeNode,
  ModelLink,
  Factoryable,
  DataField,
  ArrayDataField,
  BooleanDataField,
  DateDataField,
  StringDataField,
  IntegerDataField,
  ModelDataField,
  NumberDataField,
  ObjectDataField,
  StoreDataField,
  Model,
  Duration,
  CollectionFilter,
  IdHelper,
  CollectionSorter,
  Collection,
  Bag,
  StoreCRUD,
  StoreChanges,
  StoreFilter,
  StoreGroup,
  StoreProxy,
  StoreRelation,
  StoreSum,
  StoreSearch,
  StoreSort,
  StoreChained,
  StoreState,
  Wbs,
  StoreTree,
  WalkHelper,
  StoreSync,
  StoreStm,
  Store,
  AjaxStore,
  DomDataStore,
  ActionBase,
  StateBase,
  Transaction,
  UpdateAction,
  StateTrackingManager,
  DomSync,
  Fullscreen,
  ResizeMonitor,
  Scroller,
  Promissory,
  Renderable,
  Mask,
  KeyMap,
  RTL,
  Widget,
  Layout,
  Ripple,
  Container,
  Animator,
  ClickRepeater,
  Rotatable,
  Tool,
  CollapseTool,
  PanelCollapser,
  DynamicObject,
  Toolable,
  Badge,
  Button,
  Toolbar,
  Panel,
  Popup,
  MenuItem,
  Menu,
  ContextMenuBase,
  CSSHelper,
  DragHelper,
  ResizeHelper,
  TemplateHelper,
  TimeZoneHelper,
  Toast,
  WidgetHelper,
  XMLHelper,
  RandomGenerator,
  DataGenerator,
  DemoBot,
  Formatter,
  Navigator,
  NumberFormat,
  WebSocketManager,
  Finalizable,
  DragContext,
  DragProxy,
  Draggable,
  Droppable,
  Featureable,
  Hoverable,
  LoadMaskable,
  Override,
  Fencible,
  DayTime,
  Month,
  Parser,
  ScrollManager,
  Tooltip,
  DragTipProxy,
  Labelable,
  FieldContainer,
  Field,
  TextField,
  PickerField,
  List,
  ChipView,
  Combo,
  UndoRedoBase,
  BooleanCombo,
  ButtonGroup,
  CalendarPanel,
  Checkbox,
  YearPicker,
  DisplayField,
  DatePicker,
  DateField,
  NumberField,
  TimePicker,
  TimeField,
  DateTimeField,
  DurationField,
  Editor,
  FieldFilterPicker,
  Label,
  FieldFilterPickerGroup,
  FieldSet,
  FileField,
  FilePicker,
  FilterField,
  MessageDialog,
  PagingToolbar,
  PanelCollapserOverlay,
  PasswordField,
  Radio,
  RadioGroup,
  Slider,
  SlideToggle,
  Splitter,
  Tab,
  TabBar,
  TabPanel,
  TextAreaField,
  TextAreaPickerField,
  Minifiable,
  Responsive,
  Styleable,
  Histogram,
  Scale,
  AvatarRendering,
  Location,
  Column,
  ColumnStore,
  ActionColumn,
  NumberColumn,
  AggregateColumn,
  WidgetColumn,
  CheckColumn,
  DateColumn,
  PercentColumn,
  RatingColumn,
  RowNumberColumn,
  TemplateColumn,
  TimeColumn,
  TreeColumn,
  GridRowModel,
  GridFeatureManager,
  CellCopyPaste,
  CellEdit,
  CellMenu,
  CellTooltip,
  ColumnAutoWidth,
  ColumnDragToolbar,
  ColumnPicker,
  ColumnRename,
  ColumnReorder,
  ColumnResize,
  FillHandle,
  GridFieldFilterPicker,
  GridFieldFilterPickerGroup,
  Filter,
  FilterBar,
  Group,
  GroupSummary$1,
  HeaderMenu,
  MergeCells,
  QuickFind,
  RegionResize,
  RowCopyPaste,
  RowExpander,
  RowReorder,
  Search,
  Sort,
  StickyCells,
  Stripe,
  Summary$1,
  Tree,
  TreeGroup,
  RowsRange,
  PaperFormat,
  Orientation,
  FileFormat,
  ExportRowsCombo,
  ExportOrientationCombo,
  ExportDialog,
  Row,
  Exporter,
  MultiPageExporter$1,
  MultiPageVerticalExporter$1,
  SinglePageExporter$1,
  PdfExport$1,
  TableExporter,
  ExcelExporter$1,
  Bar,
  Footer,
  RowManager,
  Header$1,
  GridElementEvents,
  GridFeatures,
  GridResponsive,
  GridSelection,
  GridState,
  SubGrid,
  GridSubGrids,
  GridBase,
  Grid,
  TreeGrid,
  TreeCombo,
  later,
  CI,
  MI,
  Base,
  TimeUnit,
  ConstraintType,
  SchedulingMode,
  DependencyValidationResult,
  DependencyType,
  DependenciesCalendar,
  ProjectType,
  Direction,
  ConstraintIntervalSide,
  MIN_DATE,
  MAX_DATE,
  isDateFinite,
  EdgeInclusion,
  CalendarIteratorResult,
  CalendarCache,
  stripDuplicates,
  CalendarCacheInterval,
  CalendarCacheIntervalMultiple,
  binarySearch,
  IndexPosition,
  SortedMap,
  IntervalCache,
  CalendarCacheMultiple,
  combineCalendars,
  CalendarCacheSingle,
  AbstractPartOfProjectGenericMixin,
  AbstractPartOfProjectStoreMixin,
  AbstractPartOfProjectModelMixin,
  CalendarIntervalMixin,
  CalendarIntervalStore,
  UnspecifiedTimeIntervalModel,
  CorePartOfProjectGenericMixin,
  AbstractCalendarMixin,
  AbstractHasAssignmentsMixin,
  CorePartOfProjectModelMixin,
  isNotNumber,
  CIFromSetOrArrayOrValue,
  delay,
  format,
  AbstractAssignmentStoreMixin,
  AbstractCalendarManagerStoreMixin,
  AbstractDependencyStoreMixin,
  AbstractEventStoreMixin,
  AbstractResourceStoreMixin,
  CoreEventMixin,
  CoreResourceMixin,
  CoreAssignmentMixin,
  CorePartOfProjectStoreMixin,
  CoreAssignmentStoreMixin,
  CoreCalendarMixin,
  CoreCalendarManagerStoreMixin,
  CoreDependencyMixin,
  CoreDependencyStoreMixin,
  CoreHasAssignmentsMixin,
  CoreHasDependenciesMixin,
  SchedulerCoreEvent,
  CoreEventStoreMixin,
  CoreResourceStoreMixin,
  DelayableWrapper,
  SchedulerCoreProjectMixin,
  DurationColumn,
  ResourceCollapseColumn,
  ResourceInfoColumn,
  HorizontalTimeAxis,
  ResourceHeader,
  TimeAxisColumn,
  VerticalTimeAxisColumn,
  AbstractCrudManagerValidation,
  AbstractCrudManagerMixin,
  AbstractCrudManager,
  AjaxTransport,
  JsonEncoder,
  CrudManagerView,
  PartOfProject,
  AssignmentModelMixin,
  AssignmentModel,
  PartOfBaseProject,
  AssignmentStoreMixin,
  AssignmentStore,
  ResourceStoreMixin,
  ResourceModelMixin,
  ResourceModel,
  ResourceStore,
  EventStoreMixin,
  GetEventsMixin,
  EventDayIndex,
  SharedEventStoreMixin,
  RecurringTimeSpansMixin,
  RecurringEventsMixin,
  TimeZonedDatesMixin,
  TimeSpan,
  RecurrenceDayRuleEncoder,
  AbstractRecurrenceIterator,
  DailyRecurrenceIterator,
  WeeklyRecurrenceIterator,
  MonthlyRecurrenceIterator,
  YearlyRecurrenceIterator,
  RecurrenceModel,
  RecurringTimeSpan,
  EventModelMixin,
  EventModel,
  EventStore,
  DependencyBaseModel,
  DependencyModel,
  DependencyStoreMixin,
  DependencyStore,
  ProjectCrudManager,
  ProjectModelCommon,
  ResourceTimeRangeModel,
  ResourceTimeRangeStore,
  ProjectModelTimeZoneMixin,
  ProjectModelMixin,
  ProjectModel$1,
  CrudManager$1,
  ViewPreset,
  PresetStore,
  pm,
  TimeAxis,
  RecurrenceLegend,
  AttachToProjectMixin,
  ProjectConsumer,
  PackMixin,
  HorizontalLayoutPack,
  HorizontalLayoutStack,
  ClockTemplate,
  DragBase,
  EventResize,
  DragCreateBase,
  EditBase,
  ResourceTimeRangesBase,
  TimeSpanMenuBase,
  TooltipBase,
  AbstractTimeRanges,
  ColumnLines,
  DependencyCreation,
  RectangularPathFinder,
  DependencyTooltip,
  Dependencies,
  DependencyEdit,
  ScheduleContext,
  EventCopyPaste,
  EventDrag,
  EventDragCreate,
  EventDragSelect,
  EventEditor$1,
  RecurrenceConfirmationPopup,
  RecurrenceFrequencyCombo,
  RecurrenceCombo,
  RecurrenceLegendButton,
  RecurrenceDaysCombo,
  RecurrenceDaysButtonGroup,
  RecurrenceMonthDaysButtonGroup,
  RecurrenceMonthsButtonGroup,
  RecurrenceStopConditionCombo,
  RecurrencePositionsCombo,
  RecurrenceEditorPanel,
  RecurrenceEditor,
  RecurringEventEdit,
  ResourceCombo,
  EventEdit$1,
  EventFilter,
  EventMenu$1,
  NonWorkingTimeMixin,
  EventNonWorkingTime,
  EventTooltip$1,
  GroupSummary,
  HeaderZoom,
  Labels,
  NonWorkingTime,
  Pan,
  ResourceTimeRanges,
  ScheduleMenu$1,
  ScheduleTooltip,
  SimpleEventEdit,
  StickyEvents,
  TimelineSummary,
  Summary,
  TimeAxisHeaderMenu,
  TimeRanges$1,
  TimeSelection,
  ScheduleRange,
  MultiPageExporter,
  MultiPageVerticalExporter,
  ScheduleRangeCombo,
  SchedulerExportDialog,
  SinglePageExporter,
  PdfExport,
  TimeAxisViewModel,
  TimelineDateMapper,
  TimelineDomEvents,
  TimelineViewPresets,
  TimelineZoomable,
  RecurringEvents,
  TimelineEventRendering,
  TimelineScroll,
  TimelineState,
  TimeAxisSubGrid,
  TimelineBase,
  Describable,
  SchedulerDom,
  SchedulerDomEvents,
  SchedulerEventRendering,
  SchedulerStores,
  SchedulerScroll,
  SchedulerRegions,
  SchedulerState,
  SchedulerEventSelection,
  SchedulerEventNavigation,
  HorizontalRendering,
  VerticalRendering,
  SchedulerBase,
  ScheduleTableExporter,
  ExcelExporter,
  Scheduler,
  ProjectCombo,
  ResourceFilter,
  SchedulerDatePicker,
  UndoRedo,
  ViewPresetCombo,
  AgendaColumn,
  EventColumn,
  TimeRangeModel,
  TimeRangeStore,
  ProjectModel,
  CrudManager,
  CalendarFeature,
  EventTip,
  CalendarDrag,
  EventEditor,
  EventEdit,
  EventMenu,
  EventTooltip,
  ExternalEventSource,
  LoadOnDemand,
  Print,
  ScheduleMenu,
  LayoutDim,
  TimeRanges,
  WeekExpander,
  DayLayout,
  FluidDayLayout,
  CalendarStores,
  EventSlots,
  EventSorter,
  EventRenderer,
  CalendarMixin,
  DayCellCollecter,
  OverflowPopup,
  DayCellRenderer,
  DateRangeOwner,
  CalendarRow,
  DaySelector,
  DaySelectable,
  EventList,
  AgendaView,
  CalendarDatePicker,
  DayView,
  ModeSelector,
  MonthView,
  ResourceView,
  Sidebar,
  WeekView,
  YearView,
  EventNavigation,
  EventSelection,
  Calendar
};
/*!
 *
 * Bryntum Calendar 5.3.0
 *
 * Copyright(c) 2023 Bryntum AB
 * https://bryntum.com/contact
 * https://bryntum.com/license
 *
 */
//# sourceMappingURL=chunk-H6KWAF4O.js.map
