/*!
 *
 * Bryntum Grid 5.3.0
 *
 * Copyright(c) 2023 Bryntum AB
 * https://bryntum.com/contact
 * https://bryntum.com/license
 *
 */
import { _defineProperty, _objectSpread2, Tooltip, DomHelper, ArrayHelper, DateHelper, VersionHelper, InstancePlugin, BrowserHelper, Objects, Editor, Delayable, GlobalEvents, EventHelper, Rectangle, StringHelper, DomSync, DomClassList, DomDataStore, Combo, ObjectHelper } from './chunks/Editor.js';
import { ColumnStore, Column, GridFeatureManager, Location } from './chunks/GridBase.js';
export { Bar, CellEdit, CellMenu, CheckColumn, Column, ColumnDragToolbar, ColumnPicker, ColumnReorder, ColumnResize, ColumnStore, Filter, FilterBar, Footer, GridBase, GridElementEvents, GridFeatureManager, GridFeatures, GridFieldFilterPicker, GridFieldFilterPickerGroup, GridResponsive, GridSelection, GridState, GridSubGrids, Group, Header, HeaderMenu, Location, Row, RowManager, RowNumberColumn, Sort, Stripe, SubGrid, WidgetColumn } from './chunks/GridBase.js';
import { NumberColumn } from './chunks/RegionResize.js';
export { NumberColumn, RegionResize } from './chunks/RegionResize.js';
export { DateColumn } from './chunks/DateColumn.js';
export { Tree, TreeColumn } from './chunks/Tree.js';
export { GridRowModel } from './chunks/GridRowModel.js';
export { ColumnAutoWidth, Grid, RowCopyPaste } from './chunks/Grid.js';
export { ExcelExporter, GroupSummary, TableExporter } from './chunks/ExcelExporter.js';
export { RowReorder, TreeGroup } from './chunks/TreeGroup.js';
export { ExportDialog, ExportOrientationCombo, ExportRowsCombo, MultiPageExporter, MultiPageVerticalExporter, PdfExport, SinglePageExporter, Summary } from './chunks/PdfExport.js';
export { Exporter, FileFormat, Orientation, PaperFormat, RowsRange } from './chunks/Exporter.js';
export { TreeGrid } from './chunks/TreeGrid.js';
import './chunks/MessageDialog.js';

/**
 * @module Grid/column/ActionColumn
 */
/**
 * Config object for an action in an ActionColumn.
 * @typedef {Object} ActionConfig
 * @property {String} cls CSS Class for action icon
 * @property {Function|String|TooltipConfig} tooltip Tooltip text, or a config object which can reconfigure the shared
 * tooltip by setting boolean, numeric and string config values, or a function to return the tooltip text, passed the
 * row's `record`
 * @property {Function|Boolean} visible Boolean to define the action icon visibility or a callback function, passed the
 * row's `record`, to change it dynamically
 * @property {Function} onClick Callback to handle click action item event, passed the row's `record`
 * @property {Boolean} showForGroup Set to true to have action icon visible in group headers only when using the `group`
 * feature
 * @property {Function|String} renderer A render function, or the name of a function in the Grid's ownership tree used
 * to define the action element. Passed the row's `record`, expected to return an HTML string or a DOM config object.
 * **Note**: when specified, the `cls` action config is ignored. Make sure you add an action icon manually, for example:
 * ```javascript
 * {
 *      type    : 'action',
 *      text    : 'Increase amount',
 *      actions : [{
 *          cls      : 'b-fa b-fa-plus', // this line will be ignored
 *          renderer : ({ record }) => '<i class="b-action-item b-fa b-fa-plus"></i> ' + record.name,
 *          onClick  : ({ record }) => {}
 *      }]
 * }
 * ```
 *
 * or
 *
 * ```javascript
 * {
 *      type    : 'action',
 *      text    : 'Increase amount',
 *      actions : [{
 *          cls      : 'b-fa b-fa-plus', // this line will be ignored
 *          renderer : 'up.renderAction' // Defined on the Grid
 *          onClick  : ({ record }) => {}
 *      }]
 * }
 * ```
 */
/**
 * A column that displays actions as clickable icons in the cell.
 *
 * {@inlineexample Grid/column/ActionColumn.js}
 *
 * ```javascript
 * new TreeGrid({
 *     appendTo : document.body,
 *     columns  : [{
 *         type    : 'action',
 *         text    : 'Increase amount',
 *         actions : [{
 *             cls      : 'b-fa b-fa-plus',
 *             renderer : ({ action, record }) => `<i class="b-action-item ${action.cls} b-${record.enabled ? "green" : "red"}-class"></i>`,
 *             visible  : ({ record }) => record.canAdd,
 *             tooltip  : ({ record }) => `<p class="b-nicer-than-default">Add to ${record.name}</p>`,
 *             onClick  : ({ record }) => console.log(`Adding ${record.name}`)
 *         }, {
 *             cls     : 'b-fa b-fa-pencil',
 *             tooltip : 'Edit note',
 *             onClick : ({ record }) => console.log(`Editing ${record.name}`)
 *         }]
 *     }]
 * });
 * ```
 *
 * Actions may be placed in {@link Grid/feature/Group} headers, by setting `action.showForGroup` to `true`. Those
 * actions will not be shown on normal rows.
 *
 * @extends Grid/column/Column
 * @classType action
 * @column
 */
class ActionColumn extends Column {
  get groupHeaderReserved() {
    return true;
  }
  construct(config, store) {
    const me = this;
    super.construct(...arguments);
    // use auto-size only as default behaviour
    if (!config.width && !config.flex) {
      me.grid.ion({
        paint: 'updateAutoWidth',
        thisObj: me
      });
    }
    if (me.disableIfGridReadOnly) {
      me.grid.element.classList.add('b-actioncolumn-readonly');
    }
    me.externalRenderer = me.renderer;
    me.renderer = me.internalRenderer;
  }
  /**
   * Renderer that displays action icon(s) in the cell.
   * @private
   */
  internalRenderer({
    grid,
    column,
    record,
    callExternalRenderer = true
  }) {
    var _column$actions;
    const inGroupTitle = record && 'groupRowFor' in record.meta,
      {
        subGrid
      } = column;
    if (callExternalRenderer) {
      var _this$externalRendere;
      (_this$externalRendere = this.externalRenderer) === null || _this$externalRendere === void 0 ? void 0 : _this$externalRendere.call(this, ...arguments);
    }
    return {
      className: {
        'b-action-ct': 1
      },
      children: (_column$actions = column.actions) === null || _column$actions === void 0 ? void 0 : _column$actions.map((actionConfig, index) => {
        var _tooltip$startsWith;
        if ('visible' in actionConfig) {
          if (typeof actionConfig.visible === 'function' && actionConfig.visible({
            record
          }) === false) {
            return '';
          }
          if (actionConfig.visible === false) {
            return '';
          }
        }
        // check if an action allowed to be shown in case of using grouping
        if (inGroupTitle && !actionConfig.showForGroup || !inGroupTitle && actionConfig.showForGroup) {
          return '';
        }
        const {
            tooltip,
            renderer
          } = actionConfig,
          btip = typeof tooltip === 'function' || tooltip !== null && tooltip !== void 0 && (_tooltip$startsWith = tooltip.startsWith) !== null && _tooltip$startsWith !== void 0 && _tooltip$startsWith.call(tooltip, 'up.') ? subGrid.callback(tooltip, subGrid, [{
            record
          }]) : tooltip || '';
        // handle custom renderer if it is specified
        if (renderer) {
          const customRendererData = subGrid.callback(renderer, subGrid, [{
            index,
            record,
            column,
            tooltip: btip,
            action: actionConfig
          }]);
          // take of set data-index to make onClick handler work stable
          if (typeof customRendererData === 'string') {
            return {
              tag: 'span',
              dataset: _objectSpread2(_objectSpread2({}, Tooltip.encodeConfig(btip)), {}, {
                index
              }),
              html: customRendererData
            };
          } else {
            customRendererData.dataset = customRendererData.dataset || {};
            customRendererData.dataset.index = index;
            return customRendererData;
          }
        } else {
          return {
            tag: 'button',
            dataset: _objectSpread2(_objectSpread2({}, Tooltip.encodeConfig(btip)), {}, {
              index
            }),
            'aria-label': btip,
            className: {
              'b-tool': 1,
              'b-action-item': 1,
              [actionConfig.cls]: actionConfig.cls
            }
          };
        }
      })
    };
  }
  /**
   * Handle icon click and call action handler.
   * @private
   */
  onCellClick({
    grid,
    column,
    record,
    target
  }) {
    var _column$actions2;
    if (column !== this || !target.classList.contains('b-action-item')) {
      return;
    }
    let actionIndex = target.dataset.index;
    // index may be set in a parent node if user used an html string in his custom renderer
    // and we take care to set this property to support onClick handler
    if (!actionIndex) {
      actionIndex = target.parentElement.dataset && target.parentElement.dataset.index;
    }
    const action = (_column$actions2 = column.actions) === null || _column$actions2 === void 0 ? void 0 : _column$actions2[actionIndex],
      actionHandler = action && action.onClick;
    if (actionHandler) {
      this.callback(actionHandler, column, [{
        record,
        action,
        target
      }]);
    }
  }
  /**
   * Update width for actions column to fit content.
   * @private
   */
  updateAutoWidth() {
    const me = this,
      groupActions = [],
      {
        actions: oldActions
      } = me;
    // header may be disabled, in that case we won't be able to calculate the width properly
    if (!me.element) {
      return;
    }
    const actions = me.actions = [];
    // collect group and non group actions to check length later
    oldActions === null || oldActions === void 0 ? void 0 : oldActions.forEach(actionOriginal => {
      const action = _objectSpread2({}, actionOriginal);
      // remove possible visibility condition to make sure an action will exists in test HTML
      delete action.visible;
      // group actions shows in different row and never together with non group
      if (action.showForGroup) {
        delete action.showForGroup;
        groupActions.push(action);
      } else {
        actions.push(action);
      }
    });
    // use longest actions length to calculate column width
    if (groupActions.length > actions.length) {
      me._actions = groupActions;
    }
    const actionsHtml = DomHelper.createElement(me.internalRenderer({
      column: me,
      callExternalRenderer: false
    })).outerHTML;
    me.width = DomHelper.measureText(actionsHtml, me.element, true, me.element.parentElement);
    me.actions = oldActions;
  }
}
_defineProperty(ActionColumn, "type", 'action');
_defineProperty(ActionColumn, "fields", [
/**
 * An array of action config objects, see {@link #typedef-ActionConfig} for details.
 *
 * ```javascript
 * new Grid({
 *     columns  : [{
 *         type    : 'action',
 *         text    : 'Actions',
 *         actions : [{
 *             cls      : 'b-fa b-fa-plus',
 *             visible  : ({ record }) => record.canAdd,
 *             onClick  : ({ record }) => console.log(`Adding ${record.name}`)
 *         }, {
 *             cls     : 'b-fa b-fa-pencil',
 *             tooltip : 'Edit note',
 *             onClick : ({ record }) => console.log(`Editing ${record.name}`)
 *         }]
 *     }]
 * });
 * ```
 *
 * @config {ActionConfig[]} actions List of action configs
 * @category Common
 */
{
  name: 'actions',
  type: 'array'
},
/**
 * Set true to hide disable actions in this column if the grid is {@link Core.widget.Widget#config-readOnly}
 * @config {Boolean} disableIfGridReadOnly
 * @default
 * @category Common
 */
{
  name: 'disableIfGridReadOnly',
  defaultValue: false
}]);
_defineProperty(ActionColumn, "defaults", {
  /**
   * Filtering by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.
   * @config {Boolean} filterable
   * @default false
   * @category Interaction
   * @hide
   */
  filterable: false,
  /**
   * Grouping by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.
   * @config {Boolean} groupable
   * @default false
   * @category Interaction
   * @hide
   */
  groupable: false,
  /**
   * Sorting by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.
   * @config {Boolean} sortable
   * @default false
   * @category Interaction
   * @hide
   */
  sortable: false,
  /**
   * Editor for action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.
   * @config {Boolean} editor
   * @default false
   * @category Interaction
   * @hide
   */
  editor: false,
  /**
   * Searching by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.
   * @config {Boolean} searchable
   * @default false
   * @category Interaction
   * @hide
   */
  searchable: false,
  /**
   * By default, for action column this flag is switched to `true`, because the content of this column is always HTML.
   * @config {Boolean} htmlEncode
   * @default false
   * @category Misc
   * @hide
   */
  htmlEncode: false,
  /**
   * Set to `true` to allow the column to being drag-resized when the ColumnResize plugin is enabled.
   * @config {Boolean} resizable
   * @default false
   * @category Interaction
   */
  resizable: false,
  /**
   * Column minimal width. If value is Number then minimal width is in pixels.
   * @config {Number|String} minWidth
   * @default 30
   * @category Layout
   */
  minWidth: 30
});
ColumnStore.registerColumnType(ActionColumn);
ActionColumn.exposeProperties();
ActionColumn._$name = 'ActionColumn';

/**
 * @module Grid/column/AggregateColumn
 */
/**
 * A column, which, when used as part of a {@link Grid.view.TreeGrid}, aggregates the values of this column's descendants using
 * a configured function which defaults to `sum`. The aggregate value is re-calculated after any change to the data,
 * and if you want aggregate values to be change-tracked, please set {@link #config-includeParentInChangeSet} to true.
 *
 * Default editor depends on the data field type. If it is a number, default editor is a {@link Core/widget/NumberField}.
 * Otherwise Default editor is a {@link Core/widget/TextField}.
 *
 * ```javascript
 * const grid = new TreeGrid({
 *     // Custom aggregation handler.
 *     // For test purposes, this just does "sum"
 *     myAggregator(...values) {
 *         let result = 0;
 *
 *         for (let i = 0, { length } = values; i < length; i++) {
 *             result += parseInt(args[i], 10);
 *         }
 *         return result;
 *     },
 *     columns : [
 *         { field : 'name', text : 'Name' },
 *
 *         // Will sum the ages of leaf nodes. This is the default.
 *         { type : 'aggregate', field : 'age', text : 'Age', renderer : ({ value }) => `<b>${value}<b>` },
 *
 *         // Will use AggregateColumn's built-in avg of scores of leaf nodes
 *         { type : 'aggregate', field : 'score', text : 'Score', function : 'avg' },
 *
 *         // Will use the grid's myAggregator function
 *         { type : 'aggregate', field : 'revenue', text : 'Revenue', function : 'up.myAggregator' },
 *     ]
 * });
 * ```
 *
 * @extends Grid/column/NumberColumn
 * @classType aggregate
 * @column
 */
class AggregateColumn extends NumberColumn {
  //region Config

  static get defaults() {
    return {
      /**
       * Math Function name, or function name prepended by `"up."` that is resolvable in an
       * ancestor component (such as the owning Grid, or a hight Container), or a function to
       * use to aggregate child record values for this column, or a function.
       *
       * This Column is provided with a `sum` and `avg` function. The default function is `sum`
       * which is used for the aggregation.
       *
       * The function is passed a set of child node values, each value in a separate argument
       * and should return a single value based upon the value set passed.
       * @config {Function|String}
       * @category Common
       */
      function: 'sum',
      /**
       * Set to `true` to include changes to parent (aggregate) rows in the store's modification tracking.
       * @config {Boolean} includeParentInChangeSet
       * @category Common
       */
      includeParentInChangeSet: false
    };
  }
  construct(data, columnStore) {
    this.configuredAlign = 'align' in data;
    this.configuredEditor = 'editor' in data;
    super.construct(...arguments);
    const {
      grid
    } = columnStore;
    // 'sum' is reserved by Summary feature, so we use a different name
    if (this.function === 'sum') {
      this.function = 'sumChildren';
    }
    if (grid) {
      this.store = grid.store;
    }
  }
  set store(store) {
    const me = this,
      storeListeners = {
        update: 'onRecordUpdate',
        thisObj: me,
        prio: 1000
      },
      oldStore = me._store;
    if (store !== oldStore) {
      if (oldStore) {
        oldStore.un(storeListeners);
      }
      me._store = store;
      const {
          modelClass
        } = store,
        field = modelClass.fieldMap[me.field];
      // It's *likely*, but not certain that this will be used for a numeric field.
      // Use numeric defaults unless configured otherwise if so.
      if (field && field.type === 'number') {
        if (!me.configuredAlign) {
          me.align = 'end';
        }
        if (!me.configuredEditor) {
          me.editor = 'number';
        }
      }
      store.ion(storeListeners);
    }
  }
  canEdit(record) {
    return record.isLeaf;
  }
  get store() {
    return this._store;
  }
  sumChildren(...args) {
    let result = 0;
    for (let i = 0, {
        length
      } = args; i < length; i++) {
      result += parseFloat(args[i] || 0, 10);
    }
    return result;
  }
  avg(...args) {
    let result = 0;
    const {
      length
    } = args;
    for (let i = 0; i < length; i++) {
      result += parseFloat(args[i] || 0, 10);
    }
    return result / length;
  }
  onRecordUpdate({
    record,
    changes
  }) {
    const me = this,
      {
        rowManager
      } = me.grid;
    if (me.field in changes) {
      if (record.isLeaf) {
        record.bubble(rec => {
          const row = rowManager.getRowFor(rec);
          if (row) {
            const cellElement = row.getCell(me.field);
            if (cellElement) {
              row.renderCell(cellElement);
            }
          }
        }, true);
      }
    }
  }
  getRawValue(record) {
    var _record$children;
    let value = 0;
    if ((_record$children = record.children) !== null && _record$children !== void 0 && _record$children.length) {
      const me = this,
        fn = me.function,
        isMathFn = typeof fn === 'string' && typeof Math[fn] === 'function',
        {
          handler,
          thisObj
        } = isMathFn ? {
          handler: Math[fn],
          thisObj: Math
        } : me.resolveCallback(fn);
      // Gather all child node values before passing them to the aggregator function.
      value = handler.apply(thisObj, record.children.map(r => me.getRawValue(r)));
      if (me.includeParentInChangeSet) {
        record.set(me.field, value, true);
      } else {
        record.setData(me.field, value);
      }
    } else {
      value = record[this.field];
    }
    return value;
  }
  canFillValue() {
    return false;
  }
}
_defineProperty(AggregateColumn, "type", 'aggregate');
_defineProperty(AggregateColumn, "fields", ['function', 'includeParentInChangeSet']);
ColumnStore.registerColumnType(AggregateColumn, true);
AggregateColumn.exposeProperties();
AggregateColumn._$name = 'AggregateColumn';

/**
 * @module Grid/column/PercentColumn
 */
/**
 * A column that display a basic progress bar.
 *
 * {@inlineexample Grid/column/PercentColumn.js}
 *
 * ```javascript
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *         { type: 'percent', text: 'Progress', data: 'progress' }
 *     ]
 * });
 * ```
 *
 * Default editor is a {@link Core.widget.NumberField NumberField}.
 *
 * @extends Grid/column/NumberColumn
 * @classType percent
 * @column
 */
class PercentColumn extends NumberColumn {
  // Type to use when auto adding field

  static get defaults() {
    return {
      min: 0,
      max: 100,
      /**
       * Set to `true` to render the number value inside the bar, for example "15%"
       * @config {Boolean}
       * @default
       * @category Rendering
       */
      showValue: false,
      /**
       * When below this percentage the bar will have `b-low` CSS class added. By default it turns the bar red.
       * @config {Number}
       * @default
       * @category Rendering
       */
      lowThreshold: 20,
      htmlEncode: false,
      searchable: false,
      summaryRenderer: sum => `${sum}%`,
      fitMode: false
    };
  }
  constructor(config, store) {
    super(...arguments);
    this.internalCellCls = 'b-percent-bar-cell';
  }
  /**
   * Renderer that displays a progress bar in the cell. If you create a custom renderer, and want to include the
   * default markup you can call `defaultRenderer` from it.
   *
   * ```javascript
   * new Grid({
   *     columns: [
   *         {
   *             type: 'percent',
   *             text : 'Percent',
   *             field : 'percent',
   *             renderer({ value }) {
   *                 const domConfig = this.defaultRenderer();
   *
   *                 if (value > 100) {
   *                     domConfig.className = b-percent-bar-outer over-allocated';
   *                 }
   *
   *                 return domConfig;
   *             }
   *         }
   *     ]
   * }
   * ```
   *
   * @param {Object} rendererData The data object passed to the renderer
   * @param {Number} rendererData.value The value to display
   * @returns {DomConfig} DomConfig object representing the default markup for the cells content
   */
  defaultRenderer({
    value
  }) {
    value = value || 0;
    return {
      className: 'b-percent-bar-outer',
      role: 'progressbar',
      'aria-Valuemin': 0,
      'aria-Valuemax': 100,
      'aria-Valuenow': value,
      tabIndex: 0,
      children: [{
        tag: 'div',
        className: {
          'b-percent-bar': 1,
          'b-zero': value === 0,
          'b-low': value < this.lowThreshold
        },
        style: {
          width: value + '%'
        },
        children: [this.showValue ? {
          tag: 'span',
          text: value + '%'
        } : undefined]
      }]
    };
  }
  // Null implementation because the column width drives the width of its content.
  // So the concept of sizing to content is invalid here.
  resizeToFitContent() {}
}
_defineProperty(PercentColumn, "type", 'percent');
_defineProperty(PercentColumn, "fieldType", 'number');
_defineProperty(PercentColumn, "fields", ['showValue', 'lowThreshold']);
PercentColumn.sum = 'average';
ColumnStore.registerColumnType(PercentColumn, true);
PercentColumn._$name = 'PercentColumn';

/**
 * @module Grid/column/RatingColumn
 */
/**
 * A column that displays a star rating. Click a start to set a value, shift+click to unset a single start from the end.
 * Clicking the first and only star toggles it.
 *
 * This column uses a custom widget as its editor, and it is not intended to be changed.
 *
 * @extends Grid/column/NumberColumn
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *         { type: 'rating', max : 10, field: 'rating' }
 *     ]
 * });
 *
 * @classType rating
 * @inlineexample Grid/column/RatingColumn.js
 * @column
 */
class RatingColumn extends NumberColumn {
  // Do not remove. Assertion strings for Localization sanity check.
  // 'L{Column.cellLabel}'

  // Type to use when auto adding field

  static get defaults() {
    return {
      min: 0,
      max: 5,
      /**
       * The empty rating icon to show
       * @config {String}
       * @category Rendering
       */
      emptyIcon: 'b-icon b-icon-star',
      /**
       * The filled rating icon to show
       * @config {String}
       * @category Rendering
       */
      filledIcon: 'b-icon b-icon-star',
      /**
       * Allow user to click an icon to change the value
       * @config {Boolean}
       * @category Interaction
       */
      editable: true,
      filterType: 'number',
      searchable: false,
      width: '11.2em',
      htmlEncode: false,
      minWidth: '11.2em',
      editor: false,
      fitMode: 'value'
    };
  }
  /**
   * Renderer that displays a number of stars in the cell. Also adds CSS class 'b-rating-cell' to the cell.
   * @private
   */
  renderer({
    value
  }) {
    return {
      className: {
        'b-rating-cell-inner': 1,
        'b-not-editable': !this.editable
      },
      children: ArrayHelper.populate(this.max, i => {
        const filled = i < value;
        return {
          tag: 'i',
          className: {
            'b-rating-icon': true,
            'b-filled': filled,
            'b-empty': !filled,
            [filled ? this.filledIcon : this.emptyIcon]: true
          }
        };
      })
    };
  }
  onCellClick({
    grid,
    column,
    record,
    target,
    event
  }) {
    if (target.classList.contains('b-rating-icon') && !grid.readOnly && column.editable) {
      let starIndex = [].indexOf.call(target.parentNode.childNodes, target);
      if (target.classList.contains('b-filled') && (event.metaKey || event.shiftKey)) {
        starIndex = starIndex - 1;
      }
      // Clicking first star when it is only one removes it
      if (record.get(column.field) === 1 && starIndex === 0) {
        starIndex = -1;
      }
      record.set(column.field, starIndex + 1);
    }
  }
}
_defineProperty(RatingColumn, "$name", 'RatingColumn');
_defineProperty(RatingColumn, "type", 'rating');
_defineProperty(RatingColumn, "fieldType", 'number');
_defineProperty(RatingColumn, "fields", ['emptyIcon', 'filledIcon', 'editable']);
ColumnStore.registerColumnType(RatingColumn, true);
RatingColumn.exposeProperties();
RatingColumn._$name = 'RatingColumn';

/**
 * @module Grid/column/TemplateColumn
 */
/**
 * A column that uses a template for cell content. Any function can be used as template, and the function is passed { value, record, field } properties.
 * It should return a string which will be rendered in the cell.
 *
 * Default editor is a {@link Core.widget.TextField TextField}.
 *
 * @extends Grid/column/Column
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *         { type: 'template', field: 'age', template: ({value}) => `${value} years old` }
 *     ]
 * });
 *
 * @classType template
 * @inlineexample Grid/column/TemplateColumn.js
 * @column
 */
class TemplateColumn extends Column {
  static get defaults() {
    return {
      htmlEncode: false
    };
  }
  constructor(config, store) {
    super(...arguments);
    const me = this;
    if (!me.template) {
      throw new Error('TemplateColumn needs a template');
    }
    if (typeof me.template !== 'function') {
      throw new Error('TemplateColumn.template must be a function');
    }
  }
  /**
   * Renderer that uses a template for cell content.
   * @private
   */
  renderer(renderData) {
    // If it's a special row, such as a group row, we can't use the user's template
    if (!renderData.record.isSpecialRow) {
      return this.template({
        value: renderData.value,
        record: renderData.record,
        field: renderData.column.field
      });
    }
  }
}
_defineProperty(TemplateColumn, "type", 'template');
_defineProperty(TemplateColumn, "fields", [
/**
 * Template function used to generate a value displayed in the cell. Called with arguments `{ value, record, field }`
 * @config {Function} template
 * @param {Object} data An object that contains data about the cell being rendered.
 * @param {*} data.value The value (only present when you set a `field` on the column)
 * @param {Core.data.Model} data.record The record representing the row
 * @param {String} data.field The column field name
 * @category Common
 */
'template']);
ColumnStore.registerColumnType(TemplateColumn, true);
TemplateColumn.exposeProperties();
TemplateColumn._$name = 'TemplateColumn';

/**
 * @module Grid/column/TimeColumn
 */
/**
 * A column that displays a time in the specified format (see {@link Core.helper.DateHelper#function-format-static} for formatting options).
 *
 * Default editor is a {@link Core.widget.TimeField TimeField}.
 *
 * @extends Grid/column/Column
 *
 * @example
 * new Grid({
 *     appendTo : document.body,
 *
 *     columns : [
 *          { type: 'time', text: 'Start time', format: 'HH:mm:ss', data: 'start' }
 *     ]
 * });
 *
 * @classType time
 * @inlineexample Grid/column/TimeColumn.js
 * @column
 */
class TimeColumn extends Column {
  //region Config

  // Type to use when auto adding field

  static get defaults() {
    return {
      /**
       * Time format
       * @config {String}
       * @category Common
       */
      format: 'LT',
      minWidth: 140,
      filterType: 'time'
    };
  }
  //endregion
  //region Display
  /**
   * Renderer that displays the time with the specified format. Also adds cls 'b-time-cell' to the cell.
   * @private
   */
  defaultRenderer({
    value
  }) {
    return value ? this.formatValue(value) : '';
  }
  /**
   * Group renderer that displays the time with the specified format.
   * @private
   */
  groupRenderer({
    cellElement,
    groupRowFor
  }) {
    cellElement.innerHTML = this.formatValue(groupRowFor);
  }
  //endregion
  //region Formatter
  /**
   * Used by both renderer and groupRenderer to do the actual formatting of the time
   * @private
   * @param value
   * @returns {String}
   */
  formatValue(value) {
    // Ideally we should be served a time, but if not make it easier for the user by parsing
    if (typeof value === 'string') {
      value = DateHelper.parse(value, this.format);
    }
    return DateHelper.format(value, this.format);
  }
  //endregion
  //region Getters/Setters
  /**
   * Get/Set format for time displayed in cell and editor (see {@link Core.helper.DateHelper#function-format-static} for formatting options)
   * @property {String}
   */
  set format(value) {
    const {
      editor
    } = this;
    this.set('format', value);
    if (editor) {
      editor.format = value;
    }
  }
  get format() {
    return this.get('format');
  }
  get defaultEditor() {
    return {
      name: this.field,
      type: 'time',
      format: this.format
    };
  }
  //endregion
}
_defineProperty(TimeColumn, "type", 'time');
_defineProperty(TimeColumn, "fieldType", 'date');
_defineProperty(TimeColumn, "fields", ['format']);
ColumnStore.registerColumnType(TimeColumn, true);
TimeColumn.exposeProperties();
TimeColumn._$name = 'TimeColumn';

/**
 * @module Grid/feature/CellCopyPaste
 */
/**
 * Allows using `[Ctrl/CMD + C]`, `[Ctrl/CMD + X]` and `[Ctrl/CMD + V]` to cut, copy and paste cell or cell ranges. Also
 * makes cut, copy and paste actions available via the cell context menu.
 *
 * Requires {@link Grid/view/Grid#config-selectionMode selectionMode.cell} to be activated.
 *
 * This feature will work alongside with {@link Grid/feature/RowCopyPaste} but there is differences on functionality.
 * * When used together, context menu options will be detailed so the user will know to copy the cell or the row.
 * * They will also detect what type of selection is present at the moment. If there are only rows selected, only row
 *   alternatives are shown in the context menu and the keyboard shortcuts will be processed by RowCopyPaste.
 * * If there are only cells selected, there will be context menu options for both row and cell but keyboard shortcuts
 *   will be handled by CellCopyPaste.
 * * They do not share clipboard, so it is possible to have rows and cells copied or cut at the same time.
 *
 * If the {@link https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API Clipboard API} is available, that will
 * be used. This enables copying and pasting between different Bryntum products or completely different applications.
 * Please note that only string values are supported.
 *
 * This feature is **disabled** by default
 *
 * ```javascript
 * const grid = new Grid({
 *     features : {
 *         cellCopyPaste : true
 *     }
 * });
 * ```
 *
 * {@inlineexample Grid/feature/CellCopyPaste.js}
 *
 * ## Keyboard shortcuts
 * The feature has the following default keyboard shortcuts:
 *
 * | Keys   | Action | Action description                                                                      |
 * |--------|--------|-----------------------------------------------------------------------------------------|
 * | Ctrl+C | copy   | Calls {@link #function-copy} which copies selected cell values into the clipboard.      |
 * | Ctrl+X | cut    | Calls {@link #function-cut} which cuts out selected cell values and saves in clipboard. |
 * | Ctrl+V | paste  | Calls {@link #function-paste} which inserts string values from the clipboard.           |
 *
 * For more information on how to customize keyboard shortcuts, please see
 * [this guide](#Grid/guides/customization/keymap.md).
 *
 * @extends Core/mixin/InstancePlugin
 * @classtype cellCopyPaste
 * @feature
 */
class CellCopyPaste extends InstancePlugin {
  constructor(...args) {
    super(...args);
    // Used in events to separate events from different features from each other
    _defineProperty(this, "entityName", 'cell');
  }
  afterConstruct() {
    super.afterConstruct();
    this.afterSelectionModeChange();
  }
  afterSelectionModeChange() {
    const me = this;
    if (!me.client.selectionMode.cell) {
      me.disabled = true;
    } else if (me._disabledBySelectionMode) {
      me.disabled = false;
      delete me._disabledBySelectionMode;
    }
  }
  get copyOnly() {
    var _this$client$features;
    // If celledit is disabled, cut and paste actions are disabled by default
    return this._copyOnly || !((_this$client$features = this.client.features.cellEdit) !== null && _this$client$features !== void 0 && _this$client$features.enabled);
  }
  get canCopy() {
    return !this.disabled && !this.client.selectedRecords.length && this.client.selectedCells.length;
  }
  get canCutPaste() {
    var _this$client$features2;
    return this.canCopy && !this.copyOnly && !((_this$client$features2 = this.client.features.cellEdit) !== null && _this$client$features2 !== void 0 && _this$client$features2.isEditing) && !this.client.readOnly;
  }
  // Called from keyMap. Also used internally here
  isActionAvailable(key, action) {
    return this.canCopy && (action === 'copy' || this.canCutPaste);
  }
  // Takes cell locations and converts them to tab and new-line separated string values.
  // Then stores them in native clipboard or the internal clipboard
  async sendToClipboard(cells) {
    const me = this;
    let lastRowIndex = 0,
      lastColIndex = 0,
      stringData = '';
    // Sorted by rowIndex then by columnIndex
    cells.sort((c1, c2) => c1.rowIndex === c2.rowIndex ? c1.columnIndex - c2.columnIndex : c1.rowIndex - c2.rowIndex);
    for (const cell of cells) {
      var _column$toClipboardSt, _cellValue;
      const {
        record,
        column,
        rowIndex,
        columnIndex
      } = cell;
      // Separate with \n if new row
      if (rowIndex > lastRowIndex) {
        if (stringData.length > 0) {
          stringData += '\n'.repeat(rowIndex - lastRowIndex);
        }
        lastRowIndex = rowIndex;
        lastColIndex = columnIndex;
      }
      // Separate with \t if new column
      else if (columnIndex > lastColIndex) {
        if (stringData.length > 0) {
          stringData += '\t'.repeat(columnIndex - lastColIndex);
        }
        lastColIndex = columnIndex;
      }
      // The column can provide its own toClipboardString
      let cellValue = (_column$toClipboardSt = column.toClipboardString) === null || _column$toClipboardSt === void 0 ? void 0 : _column$toClipboardSt.call(column, cell);
      // Or we use the raw value from the record
      if (cellValue === undefined) {
        var _record$get;
        cellValue = (_record$get = record.get(column.field)) === null || _record$get === void 0 ? void 0 : _record$get.toString();
      }
      // The client can provide its own as well.
      if (me.toCopyString) {
        cellValue = me.toCopyString({
          currentValue: cellValue,
          column,
          record
        });
      }
      cellValue = (_cellValue = cellValue) === null || _cellValue === void 0 ? void 0 : _cellValue.replace(/[\n\t]/, ' ');
      stringData += cellValue || me.emptyValueChar;
    }
    await BrowserHelper.writeToClipboard(stringData, this.useNativeClipboard);
    return stringData;
  }
  /**
   * Cuts selected cells to clipboard (native if accessible) to paste later
   * @async
   */
  async cut() {
    await this.copy(true);
  }
  /**
   * Copies selected cells to clipboard (native if accessible) to paste later
   * @async
   */
  async copy(cut) {
    const me = this,
      {
        client,
        entityName
      } = me,
      isCut = typeof cut === 'boolean' ? cut : false,
      // If called by keymap, arguments[0] will be an event
      cells = isCut ? client.selectedCells.filter(r => {
        var _r$record;
        return !((_r$record = r.record) !== null && _r$record !== void 0 && _r$record.readOnly);
      }) : client.selectedCells;
    if (cells) {
      /**
       * Fires on the owning Grid before a copy action is performed, return `false` to prevent the action
       * @event beforeCopy
       * @preventable
       * @on-owner
       * @param {Grid.view.Grid} source Owner grid
       * @param {Grid.util.Location[]} cells The cells about to be copied or cut
       * @param {Boolean} isCut `true` if this is a cut action
       * @param {String} entityName 'cell' to distinguish this event from other beforeCopy events
       */
      if ((isCut ? !me.canCutPaste : !me.canCopy) || client.trigger('beforeCopy', {
        cells,
        isCut,
        entityName
      }) === false) {
        return;
      }
      const copiedDataString = await me.sendToClipboard(cells);
      if (isCut === true) {
        for (const cell of cells) {
          if (!cell.column.readOnly) {
            cell.record.set(cell.column.field, null);
          }
        }
      }
      /**
       * Fires on the owning Grid after a copy action is performed.
       * @event copy
       * @on-owner
       * @param {Grid.view.Grid} source Owner grid
       * @param {Grid.util.Location[]} cells The cells about to be copied or cut
       * @param {String} copiedDataString The concatenated data string that was copied or cut
       * @param {Boolean} isCut `true` if this was a cut action
       * @param {String} entityName 'cell' to distinguish this event from other copy events
       */
      client.trigger('copy', {
        cells,
        copiedDataString,
        isCut,
        entityName
      });
    }
  }
  /**
   * Pastes string data into a cell or a range of cells. Either from native clipboard if that is accessible or from a
   * fallback clipboard that is only available to the owner Grid.
   *
   * The string data will be split on `\n` and `\t` and put in different rows and columns accordingly.
   *
   * Note that there must be a selected cell to paste the data into.
   * @async
   */
  async paste() {
    const me = this,
      {
        client,
        entityName
      } = me,
      clipboardData = await BrowserHelper.readFromClipboard(me.useNativeClipboard),
      targetCell = client.selectedCells[0];
    /**
     * Fires on the owning Grid before a paste action is performed, return `false` to prevent the action
     * @event beforePaste
     * @preventable
     * @on-owner
     * @param {Grid.view.Grid} source Owner grid
     * @param {String} clipboardData The clipboardData about to be pasted
     * @param {Grid.util.Location} targetCell The cell from which the paste will be started
     * @param {String} entityName 'cell' to distinguish this event from other beforePaste events
     */
    if (!me.canCutPaste || !(clipboardData !== null && clipboardData !== void 0 && clipboardData.length) || !targetCell || client.trigger('beforePaste', {
      clipboardData,
      targetCell,
      entityName
    }) === false) {
      return;
    }
    const modifiedRecords = new Set(),
      // Converts the clipboard data into a 2-dimensional array of string values.
      rows = me.stringAs2dArray(clipboardData),
      targetCells = [],
      {
        _shiftSelectRange
      } = client;
    // No valid clipboard data, break
    if (!(rows !== null && rows !== void 0 && rows.length)) {
      return;
    }
    // If there is a selected range, pasting should be repeated into that range
    if (_shiftSelectRange !== null && _shiftSelectRange !== void 0 && _shiftSelectRange.some(cell => cell.equals(targetCell))) {
      const cellRows = me.cellSelectorsAs2dArray(_shiftSelectRange);
      // The selection must fit the whole paste content. If pasting 2 rows for example, a number of rows that is
      // divisible by 2 is required. Same for columns.
      if ((cellRows === null || cellRows === void 0 ? void 0 : cellRows.length) % rows.length === 0 && cellRows.columnCount % rows.columnCount === 0) {
        // This code will calculate each cell target to repeat the pasting on
        for (let curI = 0; curI < cellRows.length; curI += rows.length) {
          for (let curX = 0; curX < cellRows.columnCount; curX += rows.columnCount) {
            targetCells.push(cellRows[curI][curX]);
          }
        }
      }
    }
    // No valid range, just use one target
    if (!targetCells.length) {
      targetCells.push(targetCell);
    }
    for (const targetCell of targetCells) {
      for (let rI = 0; rI < rows.length; rI++) {
        const row = rows[rI],
          targetRecord = client.store.getAt(targetCell.rowIndex + rI);
        // Starts with targetCell rowIndex and columnIndex and applies values from the clipboard string.
        if (targetRecord && !targetRecord.readOnly) {
          for (let cI = 0; cI < row.length; cI++) {
            const targetColumn = client.columns.getAt(targetCell.columnIndex + cI),
              targetField = targetColumn === null || targetColumn === void 0 ? void 0 : targetColumn.field;
            let value = row[cI];
            // If no value, this column is skipped
            if (targetField && value && !targetColumn.readOnly) {
              if (value === me.emptyValueChar) {
                value = null;
              }
              // Column provided paste conversion function
              if (targetColumn.fromClipboardString) {
                value = targetColumn.fromClipboardString({
                  string: value,
                  record: targetRecord
                });
              }
              // Client provided paste customization function
              if (me.toPasteValue) {
                value = me.toPasteValue({
                  currentValue: value,
                  record: targetRecord,
                  column: targetColumn,
                  field: targetField
                });
              }
              targetRecord.set(targetField, value, false, false, false, true);
              modifiedRecords.add(targetRecord);
            }
          }
        }
      }
    }
    /**
     * Fires on the owning Grid after a paste action is performed.
     * @event paste
     * @on-owner
     * @param {Grid.view.Grid} source Owner grid
     * @param {String} clipboardData The clipboardData that was pasted
     * @param {Core.data.Model[]} modifiedRecords The records which have been modified due to the paste action
     * @param {Grid.util.Location} targetCell The cell from which the paste will be started
     * @param {String} entityName 'cell' to distinguish this event from other paste events
     */
    client.trigger('paste', {
      clipboardData,
      targetCell,
      modifiedRecords: [...modifiedRecords],
      entityName
    });
  }
  /**
   * Converts an array of Location objects to a two-dimensional array where first level is rows and second level is
   * columns. If the array is inconsistent in the number of columns present for each row, the function will return
   * false.
   * @param {Grid.util.Location[]} locations
   * @private
   */
  cellSelectorsAs2dArray(locations) {
    const rows = [];
    let rId = null,
      columns;
    for (const location of locations) {
      // If new id (new record) create new "row"
      if (location.id !== rId) {
        rId = location.id;
        columns = [];
        rows.push(columns);
      }
      columns.push(location);
    }
    // Save number of "columns" for easier access
    rows.columnCount = rows[0].length;
    // All "rows" must have the same number of columns
    if (rows.some(row => row.length !== rows.columnCount)) {
      return false;
    }
    return rows;
  }
  /**
   * Converts a new-line- and tab-separated string to a two-dimensional array where first level is rows and second
   * level is columns. If the string is inconsistent in the number of columns present for each row, the function will
   * return false.
   * @param {String} string String values separated with new-line(\n,\r or similar) and tabs (\t)
   * @private
   */
  stringAs2dArray(string) {
    const rows = [],
      stringRows = string.split(/\r\n|(?!\r\n)[\n-\r\x85\u2028\u2029]/);
    for (const row of stringRows) {
      const columns = row.split('\t');
      // All "rows" must have the same number of columns
      if (rows.columnCount && columns.length !== rows.columnCount) {
        return false;
      }
      // Save number of "columns" for easier access
      rows.columnCount = columns.length;
      rows.push(columns);
    }
    return rows;
  }
  populateCellMenu({
    record,
    items
  }) {
    const me = this;
    if (me.canCopy) {
      items.cutCell = {
        text: me.cutText,
        localeClass: me,
        icon: 'b-icon b-icon-cut',
        weight: 115,
        disabled: record.readOnly || !me.canCutPaste,
        onItem: () => me.cut()
      };
      items.pasteCell = {
        text: me.pasteText,
        localeClass: me,
        icon: 'b-icon b-icon-paste',
        weight: 120,
        disabled: record.readOnly || !me.canCutPaste,
        onItem: () => me.paste()
      };
      items.copyCell = {
        text: me.copyText,
        localeClass: me,
        cls: 'b-separator',
        icon: 'b-icon b-icon-copy',
        weight: 110,
        onItem: () => me.copy()
      };
    }
  }
}
_defineProperty(CellCopyPaste, "$name", 'CellCopyPaste');
_defineProperty(CellCopyPaste, "pluginConfig", {
  chain: ['populateCellMenu', 'afterSelectionModeChange']
});
_defineProperty(CellCopyPaste, "configurable", {
  /**
   * If `true` this prevents cutting and pasting. Will default to `true` if {@link Grid/feature/CellEdit} feature is disabled.
   * Set to `false` to prevent this behaviour.
   * @config {Boolean}
   */
  copyOnly: null,
  /**
   * If an empty value (null or empty string) is copied or cut, this config will replace that value.
   * This allows for clipboard data to skip columns.
   *
   * For example, look at these two selections
   * |  ROW  |   0  |      1       |       2      |   3  |
   * |-------|------|--------------|--------------|------|
   * | ROW 1 | SEL1 | not selected | not selected | SEL2 |
   * | ROW 2 | SEL3 | SEL4 (empty) | SEL5 (empty) | SEL6 |
   *
   * The clipboardData for `ROW 1` will look like this:
   `* SEL1\t\t\SEl2\nSEL3\t\t\SEL4`
   *
   * And `ROW 2` will look like this:
   * `SEL3\t\u{0020}\t\u{0020}\tSEL6`
   *
   * `ROW 1` will set value `SEL1` at column index 0 and `SEL2` at column index 3. This leaves column index 1 and
   * 2 untouched.
   *
   * `ROW 2` will set value `SEL3` at column index 0, `u{0020}` at column index 1 and 2, and `SEL`6 at column
   * index 3.
   *
   * The default `u{0020}` is a blank space.
   *
   * @config {String}
   * @default
   */
  emptyValueChar: '\u{0020}',
  /**
   * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
   * @config {Object<String,String>}
   */
  keyMap: {
    'Ctrl+C': 'copy',
    'Ctrl+X': 'cut',
    'Ctrl+V': 'paste'
  },
  /**
   * Set this to `false` to not use native Clipboard API even if it is available
   * @config {Boolean}
   * @default true
   */
  useNativeClipboard: !VersionHelper.isTestEnv,
  /**
   * Provide a function to be able to customize the string value which is copied.
   *
   * ````javascript
   * new Grid({
   *     features : {
   *         cellCopyPaste : {
   *             toCopyString({currentValue, column, record}) {
   *                 if(record.isAvatar){
   *                     return record.fullName;
   *                 }
   *                 return currentValue;
   *             }
   *         }
   *     }
   * });
   * ````
   *
   * @param {Object} data
   * @param {String} data.currentValue
   * @param {Grid.column.Column} data.column
   * @param {Core.data.Model} data.record
   * @config {Function}
   */
  toCopyString: null,
  /**
   * Provide a function to be able to customize the value which will be set onto the record
   *
   * ````javascript
   * new Grid({
   *     features : {
   *         cellCopyPaste : {
   *             toPasteValue({currentValue, column, record, field}) {
   *                 if(typeof currentValue === 'string'){
   *                     return currentValue.replace('$', '');
   *                 }
   *                 return currentValue;
   *             }
   *         }
   *     }
   * });
   * ````
   *
   * @param {Object} data
   * @param {String} data.currentValue
   * @param {Grid.column.Column} data.column
   * @param {Core.data.Model} data.record
   * @config {Function}
   */
  toPasteValue: null,
  copyText: 'L{copy}',
  cutText: 'L{cut}',
  pasteText: 'L{paste}'
});
CellCopyPaste._$name = 'CellCopyPaste';
GridFeatureManager.registerFeature(CellCopyPaste);

/**
 * @module Grid/feature/CellTooltip
 */
/**
 * Displays a tooltip when hovering cells.
 *
 * {@inlineexample Grid/feature/CellTooltip.js}
 *
 * To show contents when hovering a cell, you can specify a global {@link #config-tooltipRenderer} function for the
 * feature, you can also define a {@link Grid.column.Column#config-tooltipRenderer} for individual columns.
 *
 * ```javascript
 * // Column with its own tooltip renderer
 * {
 *   text            : 'Name',
 *   field           : 'name',
 *   tooltipRenderer : ({ record }) => `My name is\xa0<b>${record.name}</b>`
 * }
 * ```
 *
 * Configuration properties passed into this feature are used to configure the {@link Core.widget.Tooltip} instance
 * used.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * ## Showing async content
 * Showing remotely loaded content is super easy using the {@link #config-tooltipRenderer}:
 *
 * ```javascript
 * // Async tooltip with some custom settings
 * const grid = new Grid({
 *   features: {
 *     cellTooltip: {
 *       // Time that mouse needs to be over cell before tooltip is shown
 *       hoverDelay : 4000,
 *       // Time after mouse out to hide the tooltip, 0 = instantly
 *       hideDelay  : 0,
 *       // Async tooltip renderer, return a Promise which yields the text content
 *       tooltipRenderer({ record, tip }) {
 *         return fetch(`tip.php?id=${record.id}`).then(response => response.text())
 *       }
 *     }
 *   }
 * });
 * ```
 *
 * @extends Core/mixin/InstancePlugin
 * @extendsconfigs Core/widget/Tooltip
 * @demo Grid/celltooltip
 * @classtype cellTooltip
 * @feature
 */
class CellTooltip extends InstancePlugin {
  //region Config

  //endregion
  // region Init
  construct(grid, config) {
    super.construct(grid, this.processConfig(config));
  }
  initTip() {
    const me = this;
    me.tip = Tooltip.new({
      forElement: me.client.element,
      forSelector: '.b-grid-row:not(.b-group-row) .b-grid-cell, .b-grid-merged-cells',
      hoverDelay: 1000,
      trackMouse: false,
      cls: 'b-celltooltip-tip',
      getHtml: me.getTooltipContent.bind(me),
      internalListeners: {
        pointerOver: 'onPointerOver',
        thisObj: me
      },
      listeners: me.configuredListeners
    }, me.initialConfig);
    me.relayEvents(me.tip, ['beforeShow', 'show']);
  }
  onPointerOver({
    target
  }) {
    const column = this.client.getColumnFromElement(target);
    // Veto onPointerOver if column's tooltipRenderer is false
    return column.tooltipRenderer !== false && Boolean(column.tooltipRenderer || this.tooltipRenderer);
  }
  // CellTooltip feature handles special config cases, where user can supply a function to use as tooltipRenderer
  // instead of a normal config object
  processConfig(config) {
    if (typeof config === 'function') {
      return {
        tooltipRenderer: config
      };
    }
    return config;
  }
  // override setConfig to process config before applying it (used mainly from ReactGrid)
  setConfig(config) {
    super.setConfig(this.processConfig(config));
  }
  doDestroy() {
    this.tip && this.tip.destroy();
    super.doDestroy();
  }
  doDisable(disable) {
    if (!disable) {
      this.initTip();
    } else if (this.tip) {
      this.tip.destroy();
      this.tip = null;
    }
    super.doDisable(disable);
  }
  //endregion
  //region Content
  /**
   * Called from Tooltip to populate it with html.
   * @private
   */
  getTooltipContent({
    tip,
    activeTarget: cellElement,
    event
  }) {
    const me = this,
      record = me.client.getRecordFromElement(cellElement),
      column = me.client.getColumnFromElement(cellElement),
      arg = {
        cellElement,
        record,
        column,
        event,
        tip,
        cellTooltip: me
      };
    let result;
    // If we have not changed context, we should not change content, unless we have a custom target selector (element within the cell)
    if (!me.forSelector && record === me.lastRecord && record.generation === me.lastRecordGeneration && column === me.lastColumn) {
      return me.tip._html;
    }
    me.lastRecord = record;
    me.lastRecordGeneration = record.generation;
    me.lastColumn = column;
    // first, use columns tooltipRenderer if any
    if (column.tooltipRenderer) {
      result = column.tooltipRenderer(arg);
    }
    // secondly, try feature's renderer (specifying column.tooltipRenderer as false prevents tooltip in that column)
    else if (me.tooltipRenderer && column.tooltipRenderer !== false) {
      result = me.tooltipRenderer(arg);
    }
    // No caching of async requests
    if (Objects.isPromise(result)) {
      me.lastRecord = me.lastRecordGeneration = me.lastColumn = null;
    }
    return result;
  }
  //endregion
}
_defineProperty(CellTooltip, "$name", 'CellTooltip');
_defineProperty(CellTooltip, "configurable", {
  /**
   * Function called to generate the HTML content for the cell tooltip.
   * The function should return a string (your HTML), or a Promise yielding a string (for remotely loaded
   * content)
   * @prp {Function}
   * @param {Object} context
   * @param {HTMLElement} context.cellElement The cell element
   * @param {Core.data.Model} context.record The row record
   * @param {Grid.column.Column} context.column The column
   * @param {Core.widget.Tooltip} context.tip The Tooltip instance
   * @param {Grid.feature.CellTooltip} context.cellTooltip The feature
   * @param {Event} context.event The raw DOM event
   * @returns {String|Promise}
   */
  tooltipRenderer: null
});
CellTooltip._$name = 'CellTooltip';
GridFeatureManager.registerFeature(CellTooltip);

/**
 * @module Grid/feature/ColumnRename
 */
/**
 * Allows user to rename columns by either right-clicking column header or using keyboard shortcuts when column header
 * is focused.
 *
 * To get notified about column renaming listen to `change` event on {@link Grid.data.ColumnStore columns} store.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * {@inlineexample Grid/feature/ColumnRename.js}
 *
 * ## Keyboard shortcuts
 * This feature has the following default keyboard shortcuts:
 *
 * | Keys          | Action           | Action description                        |
 * |---------------|------------------|-------------------------------------------|
 * | F2            | startEdit        | Starts editing focused column header text |
 *
 * For more information on how to customize keyboard shortcuts, please see
 * [our guide](#Grid/guides/customization/keymap.md)
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @demo Grid/columns
 * @classtype columnRename
 * @feature
 */
class ColumnRename extends InstancePlugin {
  doDestroy() {
    var _this$editor;
    (_this$editor = this.editor) === null || _this$editor === void 0 ? void 0 : _this$editor.destroy();
    super.doDestroy();
  }
  static get pluginConfig() {
    return {
      after: ['populateHeaderMenu']
    };
  }
  populateHeaderMenu({
    items,
    column
  }) {
    items.rename = {
      weight: 215,
      icon: 'b-fw-icon b-icon-edit',
      text: this.L('L{rename}'),
      disabled: column.readOnly,
      onItem: () => this.startEdit(column)
    };
  }
  startEdit(column) {
    if (column instanceof Event) {
      var _this$client$getHeade;
      // If started editing by key
      column = (_this$client$getHeade = this.client.getHeaderDataFromEvent(column)) === null || _this$client$getHeade === void 0 ? void 0 : _this$client$getHeade.column;
    }
    if (column) {
      if (column.readOnly) {
        // return false to let keyMap know that we didn't handle this event
        return false;
      }
      const {
        textWrapper
      } = column;
      let {
        editor
      } = this;
      if (!editor) {
        this.editor = editor = new Editor({
          owner: this.client,
          align: {
            align: 't0-t0'
          }
        });
      }
      editor.render(textWrapper);
      editor.startEdit({
        target: textWrapper,
        record: column,
        field: 'text'
      });
    }
  }
}
_defineProperty(ColumnRename, "$name", 'ColumnRename');
_defineProperty(ColumnRename, "configurable", {
  /**
   * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
   * @config {Object<String,String>}
   */
  keyMap: {
    F2: 'startEdit'
  }
});
ColumnRename._$name = 'ColumnRename';
GridFeatureManager.registerFeature(ColumnRename, false);

/**
 * @module Grid/feature/FillHandle
 */
/**
 * This features adds a fill handle to a Grid range selection, which when dragged, fills the cells being dragged over
 * with values based on the values in the original selected range. This is similar to functionality normally seen in
 * various spreadsheet applications.
 *
 * {@inlineexample Grid/feature/FillHandle.js}
 *
 * Requires {@link Grid/view/Grid#config-selectionMode selectionMode.cell} to be activated.
 *
 * This feature is **disabled** by default
 *
 * ```javascript
 * const grid = new Grid({
 *     features : {
 *         fillHandle : true
 *     }
 * });
 * ```
 *
 * @extends Core/mixin/InstancePlugin
 * @classtype fillHandle
 * @feature
 */
class FillHandle extends InstancePlugin.mixin(Delayable) {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "delayable", {
      handleSelection: 'raf'
    });
  }
  afterConstruct() {
    super.afterConstruct();
    if (!this.client.selectionMode.cell) {
      this.disabled = true;
    }
    this._fillListeners = {};
  }
  onContentChange() {
    this.handleSelection();
  }
  afterColumnsChange() {
    this.handleSelection();
  }
  fixElementHeights() {
    this.handleSelection();
  }
  getCellDataFromEvent(event, includeSingleAxisMatch) {
    if (includeSingleAxisMatch) {
      includeSingleAxisMatch = !event.target.classList.contains('b-fill-handle');
    }
    return this.overridden.getCellDataFromEvent(event, includeSingleAxisMatch);
  }
  // region Pattern recognition
  findPatternsIn2dRange(range, horizontal, negative) {
    const values = {};
    // Converts a cellselector range to values per column or row
    for (const cell of range) {
      const id = horizontal ? cell.id : cell.columnId;
      let value = cell.record[cell.column.field];
      // If a number string, convert to number
      if (value && typeof value === 'string' && !isNaN(value)) {
        value = parseFloat(value);
      }
      if (!values[id]) {
        values[id] = [];
      }
      values[id].push(value);
    }
    // Find patterns for each column or row in range
    for (const rowOrCol in values) {
      values[rowOrCol].pattern = this.findPatternsIn1dRange(values[rowOrCol], negative);
    }
    return values;
  }
  findPatternsIn1dRange(range, negative) {
    const lastValue = range[negative ? 0 : range.length - 1],
      pattern = {
        next: () => lastValue,
        lastValue
      };
    // If all values in same column/row is either number or date
    if (range.every(val => typeof val === 'number') || range.every(val => val instanceof Date)) {
      const diffs = range.map((val, ix) => val - range[ix - 1]);
      diffs.shift(); // Removes initial NaN
      // Found a repeating pattern
      if (new Set(diffs).size === 1) {
        pattern.increaseBy = diffs[0] * (negative ? -1 : 1);
        pattern.next = () => {
          if (pattern.lastValue instanceof Date) {
            pattern.lastValue = new Date(pattern.lastValue.getTime() + pattern.increaseBy);
          } else {
            pattern.lastValue += pattern.increaseBy;
          }
          return pattern.lastValue;
        };
      }
    }
    // Else it's treated as a string value
    else if (range.length > 1) {
      pattern.stringPattern = [...range];
      pattern.next = () => {
        if (pattern.currentIndex === undefined) {
          pattern.currentIndex = 0;
        } else {
          pattern.currentIndex += 1;
          if (pattern.currentIndex >= pattern.stringPattern.length) {
            pattern.currentIndex = 0;
          }
        }
        return pattern.stringPattern[pattern.currentIndex];
      };
    }
    return pattern;
  }
  // endregion
  afterSelectionChange() {
    const me = this;
    // If selection isn't finished, wait for mouse up and then add fill elements
    if (GlobalEvents.isMouseDown()) {
      me.client.delayUntilMouseUp(() => me.handleSelection(true));
      // Remove prev elements immediately in this case
      me.removeElements();
    }
    // Otherwise, add fill elements immediately
    else {
      me.handleSelection(true);
    }
  }
  /**
   * Checks selection and sees to it that fill handle and border is drawn.
   * Runs on next animation frame
   * @internal
   */
  handleSelection() {
    if (!this._isExtending) {
      const range = this.rangeSelection;
      if (range) {
        this.drawFillHandleAndBorder(range[0], range[range.length - 1]);
      } else {
        this.removeElements();
      }
    }
  }
  // region Mouse events
  // On fillHandle mouse down only
  onMouseDown(event) {
    this._fillListeners.mouseMoveOrUp = EventHelper.on({
      element: globalThis,
      mouseover: 'onMouseOver',
      mouseup: 'onMouseUp',
      thisObj: this
    });
    event.stopImmediatePropagation();
    event.handled = true;
  }
  // Responsible for doing the filling
  onMouseUp() {
    const me = this,
      {
        client,
        currentRange,
        _isCropping
      } = me,
      range = me.rangeSelection,
      selectionChange = range && currentRange && client.internalSelectRange(currentRange.from, currentRange.to),
      selectedCells = (selectionChange === null || selectionChange === void 0 ? void 0 : selectionChange.selectedCells) || [],
      // For extending : Only modify cells that are not a part of original range
      // For cropping  : Only clear cells that are not a part of new selection
      extensionCells = _isCropping ? me.croppingCells : selectedCells.filter(cell => !range.some(sel => sel.equals(cell, true)));
    delete me._isCropping; // Removing flag in case we bail out early
    if (me._isExtending) {
      client.disableScrollingCloseToEdges(client.items);
      delete me._isExtending;
    }
    // If no extension, do nothing
    if (!(extensionCells !== null && extensionCells !== void 0 && extensionCells.length)) {
      me.handleSelection();
      return;
    }
    client.suspendRefresh();
    // If trimming (inverted extension), clear cells that where previously selected and not a part of new selection
    if (_isCropping) {
      extensionCells.forEach(cell => cell.record.set(cell.column.field, null, false, false, false, true));
    }
    // Extending cell values depending on pattern
    else {
      const [firstCell] = extensionCells,
        // If extensioncells has a record that is included in original selection, then we are dragging horizontally
        horizontal = range.some(sel => sel.record === firstCell.record),
        // negative in this aspect, means dragging either upwards or to the left depending on horizontal or vertical
        negative = horizontal ? firstCell.columnIndex < range[0].columnIndex : firstCell.rowIndex < range[0].rowIndex,
        patterns = me.findPatternsIn2dRange(range, horizontal, negative),
        changeMap = new Map();
      if (negative) {
        extensionCells.reverse();
      }
      for (const cell of extensionCells) {
        const {
          column,
          record
        } = cell;
        if (column.canFillValue({
          range,
          record,
          cell
        })) {
          var _me$calculateFillValu, _column$calculateFill;
          let value = (_me$calculateFillValu = me.calculateFillValue) === null || _me$calculateFillValu === void 0 ? void 0 : _me$calculateFillValu.call(me, {
              range,
              column,
              record,
              cell
            }),
            changed = changeMap.get(record);
          if (!changed) {
            changed = {};
            changeMap.set(record, changed);
          }
          if (value === undefined) {
            const pattern = patterns[horizontal ? cell.id : cell.columnId].pattern;
            value = pattern.next();
          }
          changed[column.field] = ((_column$calculateFill = column.calculateFillValue) === null || _column$calculateFill === void 0 ? void 0 : _column$calculateFill.call(column, {
            value,
            record,
            range
          })) || value;
        }
      }
      for (const [record, changes] of changeMap) {
        record.set(changes, null, null, null, null, true);
      }
    }
    client.resumeRefresh(true);
    // Selects the extended area
    client.performSelection(selectionChange);
    delete me.currentRange;
    me.handleSelection();
  }
  // The fill border and handle should refresh on mouse move
  onMouseOver(event) {
    var _cellSelector, _cellSelector$_column;
    const me = this,
      {
        client,
        rangeSelection
      } = me,
      first = rangeSelection[0],
      last = rangeSelection[rangeSelection.length - 1],
      cellData = client.getCellDataFromEvent(event, true);
    let cellSelector = cellData && client.normalizeCellContext(cellData.cellSelector);
    if (((_cellSelector = cellSelector) === null || _cellSelector === void 0 ? void 0 : (_cellSelector$_column = _cellSelector._column) === null || _cellSelector$_column === void 0 ? void 0 : _cellSelector$_column.region) === first._column.region) {
      const equalOrSmaller = rangeSelection.some(cs => cs.equals(cellSelector, true));
      let negative;
      if (!me._isExtending) {
        client.enableScrollingCloseToEdges(client.items);
      }
      if (equalOrSmaller) {
        // If were smaller, were cropping (if it's allowed)
        me._isCropping = me.allowCropping && (cellSelector.rowIndex < last.rowIndex || cellSelector.columnIndex < last.columnIndex);
      } else {
        // If cellSelector is on a row in range, endSelector should be current column but end/first row
        if (cellSelector.rowIndex >= first.rowIndex && cellSelector.rowIndex <= last.rowIndex) {
          negative = first.columnIndex > cellSelector.columnIndex;
          cellSelector = new Location({
            grid: client,
            record: negative ? first.record : last.record,
            column: cellSelector.column
          });
        }
        // Else endSelector should be current row but end/first column
        else {
          negative = first.rowIndex > cellSelector.rowIndex;
          cellSelector = new Location({
            grid: client,
            record: cellSelector.record,
            column: negative ? first.column : last.column
          });
        }
      }
      // negative means that current mouse over cell is above or to the left
      const
        // If negative, draw from calculated mouse over cell
        // otherwise, draw from top-left selection cell
        from = negative ? cellSelector : first,
        // If negative or were inside selection (but not cropping), draw to bottom-right selection cell
        // otherwise, draw to calculated mouse over cell
        to = negative || equalOrSmaller && !me._isCropping ? last : cellSelector;
      me.currentRange = {
        from,
        to
      };
      // This flag is true even if were trimming
      me._isExtending = true;
      me.drawFillHandleAndBorder(from, to, true);
    }
  }
  // endregion
  // region Creating, updating and removing fillhandle and fillborder
  drawFillHandleAndBorder(from, to, keepListeners = false) {
    var _me$rangeSelection;
    const me = this,
      {
        client,
        currentRange,
        _fillListeners
      } = me,
      regionEl = client.subGrids[from.column.region].element,
      {
        x
      } = Rectangle.from(from.cell || from.column.element, regionEl),
      {
        right
      } = Rectangle.from(to.cell || to.column.element, regionEl),
      {
        y
      } = client.getRecordCoords(from.record, true),
      bottom = client.getRecordCoords(to.record, true).bottom - 1;
    let {
      borderElement,
      handleElement
    } = me;
    me.removeElements(keepListeners);
    if (!borderElement) {
      me.borderElement = borderElement = DomHelper.createElement({
        className: 'b-fill-selection-border'
      });
      me.handleElement = handleElement = DomHelper.createElement({
        className: 'b-fill-handle'
      });
    }
    DomHelper.setRect(borderElement, {
      y,
      x,
      width: right - x,
      height: bottom - y
    });
    regionEl.appendChild(borderElement);
    // If fill handle is drawn at right edge, put it to the left instead
    DomHelper.setTopLeft(handleElement, bottom, right >= regionEl.scrollWidth ? x : right);
    regionEl.appendChild(handleElement);
    // Remove all previously cropping cls
    me.toggleCroppingCls(false);
    delete me.croppingCells;
    // If were cropping, we should add cls class to the cells that will be "shrunk"
    if (me._isCropping && (_me$rangeSelection = me.rangeSelection) !== null && _me$rangeSelection !== void 0 && _me$rangeSelection.length) {
      const newCells = client.getRange(currentRange.from, currentRange.to);
      me.croppingCells = me.rangeSelection.filter(sel => !newCells.some(cell => cell.equals(sel, true)));
      me.toggleCroppingCls();
    }
    if (!_fillListeners.handleClick) {
      _fillListeners.handleClick = EventHelper.on({
        element: globalThis,
        delegate: '.b-fill-handle',
        mousedown: 'onMouseDown',
        thisObj: me
      });
    }
    me.hasFillElements = true;
  }
  toggleCroppingCls(add = true) {
    var _this$croppingCells;
    (_this$croppingCells = this.croppingCells) === null || _this$croppingCells === void 0 ? void 0 : _this$croppingCells.forEach(sel => {
      var _this$client$getCell;
      return (_this$client$getCell = this.client.getCell(sel)) === null || _this$client$getCell === void 0 ? void 0 : _this$client$getCell.classList.toggle('b-indicate-crop', add);
    });
  }
  removeElements(keepListeners = false) {
    var _me$handleElement, _me$borderElement;
    const me = this;
    (_me$handleElement = me.handleElement) === null || _me$handleElement === void 0 ? void 0 : _me$handleElement.remove();
    (_me$borderElement = me.borderElement) === null || _me$borderElement === void 0 ? void 0 : _me$borderElement.remove();
    if (!keepListeners) {
      me.removeListeners();
    }
    me.hasFillElements = false;
  }
  // Detach listeners
  removeListeners() {
    const me = this;
    for (const listener in me._fillListeners) {
      me._fillListeners[listener]();
    }
    me._fillListeners = {};
  }
  // endregion
  // Gets current selection range. Only allows for single range or single cell.
  get rangeSelection() {
    var _client$_shiftSelectR;
    const {
        client
      } = this,
      {
        selectedCells
      } = client,
      range = (_client$_shiftSelectR = client._shiftSelectRange) !== null && _client$_shiftSelectR !== void 0 ? _client$_shiftSelectR : selectedCells.length === 1 && selectedCells;
    // We only got one selected range, nothing else selected
    // Only allow fill handle on single region selection
    if (!client.selectedRecords.length && range !== null && range !== void 0 && range.length && range.length === selectedCells.length && range.every(c1 => selectedCells.some(c2 => c1.equals(c2, true)) && c1._column.parent && c1._column.region === range[0]._column.region && client.store.isAvailable(c1.id))) {
      return range;
    }
    return null;
  }
}
_defineProperty(FillHandle, "$name", 'FillHandle');
_defineProperty(FillHandle, "configurable", {
  /**
   * Implement this function to be able to customize the value that cells will be filled with.
   * Return `undefined` to use default calculations.
   *
   * ````javascript
   * new Grid({
   *    features : {
   *        fillHandle : {
   *           calculateFillValue({cell, column, range, record}) {
   *              if(column.field === 'number') {
   *                 return range.reduce(
   *                    (sum, location) => sum + location.record[location.column.field]
   *                 );
   *              }
   *           }
   *        }
   *    }
   * });
   * ````
   *
   * @param {Object} data Object containing information about current cell and fill value
   * @param {Grid.util.Location} data.cell Current cell data
   * @param {Grid.column.Column} data.column Current cell column
   * @param {Grid.util.Location[]} data.range Range from where to calculate values
   * @param {Core.data.Model} data.record Current cell record
   * @returns {String|Number|Date} Value to fill current cell
   * @config {Function}
   */
  calculateFillValue: null,
  /**
   * Set to `true` to enable the fill range to crop the original selected range. This clears the cells which were
   * a part of the original selected range, but are no longer a part of the smaller range.
   * @config {Boolean}
   */
  allowCropping: false
});
// Plugin configuration. This plugin chains/overrides some functions in Grid.
_defineProperty(FillHandle, "pluginConfig", {
  chain: ['afterSelectionChange', 'onContentChange', 'afterColumnsChange', 'fixElementHeights'],
  override: ['getCellDataFromEvent']
});
FillHandle._$name = 'FillHandle';
GridFeatureManager.registerFeature(FillHandle);

/**
 * @module Grid/feature/MergeCells
 */
// Maps DOM events to relayed events that need correct casing
const camelCase = {
  mousedown: 'mouseDown',
  mousemove: 'mouseMove',
  mouseup: 'mouseUp',
  touchdown: 'touchDown',
  touchmove: 'touchMove',
  touchup: 'touchUp',
  mouseover: 'mouseOver',
  mouseout: 'mouseOut',
  dblclick: 'dblClick',
  keydown: 'keyDown',
  keypress: 'keyPress',
  keyup: 'keyUp',
  contextmenu: 'contextMenu'
};
/**
 * This feature merges cells that have the same value in sorted columns configured to
 * {@link Grid/column/Column#config-mergeCells}. The content of merged cells is sticky for Grids with a single subgrid
 * section when all columns fit in view (content stays in view until the cell is scrolled fully out of view).
 *
 * <div class="note">Support for sticky content is limited because of how <code>position: sticky</code> works. Grid
 * scrolls vertically in one element, and horizontally in another (to support multiple regions in the grid), and this
 * setup is not supported by current browsers implementation of sticky positioning</div>
 *
 * Try scrolling in the demo below. Also try sorting by the other columns ("City" and "Favorite food" are configured
 * to merge cells):
 *
 * {@inlineexample Grid/feature/MergeCells.js}
 *
 * This feature is **disabled** by default.
 *
 * @extends Core/mixin/InstancePlugin
 * @classtype mergeCells
 * @feature
 */
class MergeCells extends InstancePlugin {
  constructor(...args) {
    super(...args);
    // All current ranges (once rendered)
    _defineProperty(this, "mergedRanges", []);
    // Ranges indexed by row index & column id -> Each range included multiple times, for easy lookup
    _defineProperty(this, "mergedMap", {});
  }
  static get pluginConfig() {
    return {
      chain: ['beforeRenderCell', 'afterRenderRow', 'bindStore', 'afterColumnsChange', 'afterRemove', 'afterToggleGroup', 'afterToggleSubGrid', 'handleEvent', 'populateHeaderMenu',
      // 'setHoveredRow'
      'afterSelectionChange'],
      // Grid must perform its update *after* we do.
      before: ['onInternalResize'],
      override: ['getColumnFromElement', 'getRecordFromElement']
    };
  }
  //endregion
  //region Init
  afterConstruct() {
    const me = this,
      {
        client
      } = me;
    // Each subgrid gets a merged cells container
    client.eachSubGrid(subGrid => me.setupSubGrid(subGrid));
    // Merged cells are synced after rows are updated
    client.rowManager.ion({
      renderDone: 'onRenderDone',
      thisObj: me
    });
    me.bindStore(client.store);
  }
  setupSubGrid(subGrid) {
    // Element that will contain the merged cells
    subGrid.$mergedCellsElement = DomHelper.createElement({
      parent: subGrid.element,
      className: {
        'b-grid-merged-cells-container': 1
      }
    });
  }
  doDisable(disable) {
    if (!this.isConfiguring) {
      // Flag to allow reset to redraw even though we are already disabled at this stage
      this.isDisabling = true;
      this.reset();
      this.isDisabling = false;
    }
    super.doDisable(disable);
  }
  updatePassthrough(use) {
    // Toggle CSS class that has `pointer-events : none`
    this.client.element.classList.toggle('b-mergecells-passthrough', use);
  }
  //endregion
  //region Grid hooks
  bindStore(store) {
    this.detachListeners('store');
    store.ion({
      name: 'store',
      change: 'onStoreChange',
      // Call our refresh logic before grids
      refresh: {
        prio: 1,
        fn: 'onStoreRefresh'
      },
      thisObj: this
    });
  }
  // Refresh all ranges when grid is resized
  onInternalResize() {
    this.refreshBounds();
  }
  // Get / create ranges before cell contents are rendered, redirecting the contents to the range
  beforeRenderCell(renderData) {
    const {
        column,
        record,
        cellElement
      } = renderData,
      subGrid = this.client.subGrids[column.region];
    // Only affect sorted columns configured to merge cells
    if (!this.disabled && column.mergeCells && column.isSorted && !record.isSpecialRow && !subGrid.collapsed) {
      const mergedRange = this.getMergeRange(record, column);
      if (mergedRange !== null && mergedRange !== void 0 && mergedRange.use) {
        // Flag the unmerged cell to allow styling it
        cellElement.classList.add('b-merged-cell');
        // Make sure it is empty
        cellElement.innerHTML = '';
        // Redirect output to the merged cell
        renderData.cellElement = mergedRange.cellElement;
        // TODO Consider bailing out after rendering first available cell of a merge. It would help with
        //  performance, but any side effects from the renderer would be lost (such as assigning classes to row)
      }
    }
  }

  afterRenderRow({
    row,
    oldId,
    oldHeight
  }) {
    // Row reused for same record changed height
    if (oldId === row.id && oldHeight !== row.height) {
      this.heightChanged = true;
    }
  }
  // Refresh all ranges when a column is resized (since it might affect their position and size)
  afterColumnsChange({
    action,
    changes,
    column
  }) {
    if (this.disabled) {
      return;
    }
    if (action === 'update' && changes.mergeCells && !column.mergeCells) {
      // Remove all ranges for the column when mergeCells is set to false
      for (const range of this.mergedRanges.slice()) {
        if (range.column === column) {
          this.removeRange(range);
        }
      }
      this.syncDom();
      return;
    }
    this.refreshBounds();
  }
  // Remove might be transitioned, wait until it finishes before resetting (in the afterRemove hook)
  afterRemove() {
    !this.disabled && this.reset();
  }
  // Group collapsed or expanded
  afterToggleGroup() {
    !this.disabled && this.reset();
  }
  // SubGrid collapsed or expanded
  afterToggleSubGrid() {
    !this.disabled && this.reset();
  }
  // setHoveredRow(row) {
  //     this.$hovered = row && this.mergedRanges.find(r => r.fromIndex <= row.dataIndex && r.toIndex >= row.dataIndex);
  //
  //     this.syncDom();
  // }
  // Selection changed, range is considered selected when all of its rows are selected (only in passthrough mode)
  afterSelectionChange() {
    if (!this.passthrough) {
      const {
          client
        } = this,
        indices = client.selectedRecords.map(r => client.store.indexOf(r));
      let changed = false;
      for (const range of this.mergedRanges) {
        let allSelected = true;
        // Check if all records in the range are selected
        for (let i = range.fromIndex; i <= range.toIndex && allSelected; i++) {
          allSelected = indices.includes(i);
        }
        if (range.isSelected !== allSelected) {
          range.isSelected = allSelected;
          changed = true;
        }
      }
      // Only redraw if a range selection status changed
      changed && this.syncDom();
    }
  }
  //endregion
  //region Grid overrides
  // Extract record from merged cells
  getRecordFromElement(element) {
    var _element$elementData;
    if ((_element$elementData = element.elementData) !== null && _element$elementData !== void 0 && _element$elementData.range) {
      return this.client.store.getAt(element.elementData.range.fromIndex);
    }
    return this.overridden.getRecordFromElement(element);
  }
  // Extract column from merged cells
  getColumnFromElement(element) {
    var _element$elementData2;
    if ((_element$elementData2 = element.elementData) !== null && _element$elementData2 !== void 0 && _element$elementData2.range) {
      return element.elementData.range.column;
    }
    return this.overridden.getColumnFromElement(element);
  }
  //endregion
  //region Header menu
  // Allow toggling merging cells from the column header menu (unless column is explicitly disallowing it)
  populateHeaderMenu({
    column,
    items
  }) {
    if (column.mergeable !== false) {
      items.mergeCells = {
        text: 'L{MergeCells.mergeCells}',
        icon: `b-fw-icon ${column.mergeCells ? 'b-icon-checked' : 'b-icon-unchecked'}`,
        tooltip: 'L{MergeCells.menuTooltip}',
        cls: 'b-separator',
        weight: 500,
        disabled: this.disabled,
        onItem: () => column.mergeCells = !column.mergeCells
      };
    }
  }
  //endregion
  //region Relaying events
  // Relay pointer events from the merged cell on grid
  async handleEvent(event) {
    if (!this.passthrough) {
      const mergedCellsElement = event.target.closest('.b-grid-merged-cells');
      if (mergedCellsElement) {
        var _camelCase$event$type;
        const {
            client
          } = this,
          {
            range
          } = mergedCellsElement.elementData,
          {
            cellEdit
          } = client.features,
          {
            column
          } = range,
          type = StringHelper.capitalize((_camelCase$event$type = camelCase[event.type]) !== null && _camelCase$event$type !== void 0 ? _camelCase$event$type : event.type),
          eventData = {
            grid: client,
            records: [],
            column,
            cellElement: mergedCellsElement.firstElementChild,
            target: event.target,
            event
          };
        for (let i = range.fromIndex; i <= range.toIndex; i++) {
          eventData.records.push(client.store.getAt(i));
        }
        client.trigger(`mergedCell${type}`, eventData);
        // Cell editing, pass through to cell underneath even when not using passthrough mode
        if ((cellEdit === null || cellEdit === void 0 ? void 0 : cellEdit.triggerEvent.toLowerCase()) === `cell${type}`.toLowerCase()) {
          const row = client.rowManager.getRowAt(event.clientY);
          await cellEdit.startEditing({
            id: row.id,
            columnId: column.id
          });
        }
        // Select ranges rows when clicking the merged cell
        else if (event.type === 'click') {
          this.onRangeClick({
            range
          });
        }
      }
    }
  }
  //endregion
  //region Event listeners
  // Select ranges rows when clicking a merged cell
  onRangeClick({
    range
  }) {
    const records = [];
    for (let i = range.fromIndex; i <= range.toIndex; i++) {
      records.push(this.client.store.getAt(i));
    }
    this.client.selectedRecords = records;
  }
  // Reset when data changes
  onStoreChange() {
    !this.disabled && this.reset();
  }
  // Reset before grids refresh listener come into play, grid will redraw
  onStoreRefresh({
    action
  }) {
    // filter & dataset triggers change too, handled above
    if (action !== 'filter' && action !== 'dataset') {
      !this.disabled && this.reset(false);
    }
  }
  //endregion
  //region Render
  // Element is needed early since it is passed to column renderers, and syncing for each rendered cell would give a
  // lot of overhead. Thus creating element directly instead
  createRangeElement(range) {
    var _parent$syncIdMap$syn, _parent$syncIdMap, _parent$releasedIdMap;
    const parent = this.client.getSubGridFromColumn(range.column).$mergedCellsElement,
      syncId = `${range.fromIndex}-@-${range.column.id}`;
    // If there is already an element for the range (also if previously released), we grab that one.
    // We are bending the rules of DomSync here by spawning the element early
    let element = (_parent$syncIdMap$syn = (_parent$syncIdMap = parent.syncIdMap) === null || _parent$syncIdMap === void 0 ? void 0 : _parent$syncIdMap[syncId]) !== null && _parent$syncIdMap$syn !== void 0 ? _parent$syncIdMap$syn : (_parent$releasedIdMap = parent.releasedIdMap) === null || _parent$releasedIdMap === void 0 ? void 0 : _parent$releasedIdMap[syncId];
    // No longer considered released
    if (parent.releasedIdMap) {
      delete parent.releasedIdMap[syncId];
    }
    if (!element) {
      element = DomHelper.createElement(this.createRangeDomConfig(range));
    }
    // New element or reusing released one, DomSync need to be made aware
    DomSync.addChild(parent, element, syncId);
    range.element = element;
    range.cellElement = element.firstElementChild;
    return element;
  }
  // Create a DomConfig object for the supplied range, used initially with DomHelper and thereafter with DomSync
  createRangeDomConfig(range) {
    var _column$mergedRendere;
    const {
        column,
        fromIndex,
        toIndex,
        top,
        left,
        width,
        height
      } = range,
      {
        type
      } = column,
      record = this.client.store.getAt(fromIndex),
      domConfig = {
        className: {
          'b-grid-merged-cells': 1,
          // 'b-hover'             : this.$hovered === range,
          'b-selected': range.isSelected
        },
        elementData: {
          range
        },
        style: {
          top,
          left,
          height,
          width
        },
        dataset: {
          syncId: `${fromIndex}-@-${column.id}`,
          fromIndex,
          toIndex,
          column: column.field,
          columnId: column.id
        },
        children: [
        // Div for an actual cell
        {
          className: new DomClassList(this.client.cellCls).assign({
            [`b-${type === null || type === void 0 ? void 0 : type.toLowerCase()}-cell`]: type,
            [column.cellCls]: column.cellCls,
            [column.internalCellCls]: column.internalCellCls
          }).assign(column.autoCls),
          // Dont touch cell children that might have been added by renderer
          keepChildren: true,
          // Tag along the range for easy resolving later
          elementData: {
            range
          },
          // Dataset expected on cells
          dataset: {
            column: column.field,
            columnId: column.id
          },
          // Size using configured row height, to at least have a chance of lining up with surrounding cells
          style: {
            height: this.client.rowManager.rowHeight
          }
        }]
      };
    // Allow application code a chance to affect the merged cell (intended for styling)
    (_column$mergedRendere = column.mergedRenderer) === null || _column$mergedRendere === void 0 ? void 0 : _column$mergedRendere.call(column, {
      domConfig,
      value: column.getRawValue(record),
      record,
      column,
      fromIndex,
      toIndex
    });
    return domConfig;
  }
  buildMergedCellsConfig(fromIndex, toIndex, rows) {
    var _fromIndex, _rowManager$topRow, _toIndex, _rowManager$bottomRow;
    const me = this,
      {
        client
      } = me,
      {
        rowManager
      } = client;
    // When exporting content we render rows to a document fragment one by one without RowManager. In
    // order to draw ranges correctly in this case we need provide some meta information - list of row-like
    // objects from which we can size for merged cell element, i.e. top, bottom, height, dataIndex
    // Match grids row buffer, drawing ranges from the topmost row to the bottommost
    fromIndex = (_fromIndex = fromIndex) !== null && _fromIndex !== void 0 ? _fromIndex : (_rowManager$topRow = rowManager.topRow) === null || _rowManager$topRow === void 0 ? void 0 : _rowManager$topRow.dataIndex;
    toIndex = (_toIndex = toIndex) !== null && _toIndex !== void 0 ? _toIndex : (_rowManager$bottomRow = rowManager.bottomRow) === null || _rowManager$bottomRow === void 0 ? void 0 : _rowManager$bottomRow.dataIndex;
    const
    // { locked = [], normal = [] }
    domConfigMap = client.regions.reduce((map, region) => {
      map[region] = {
        className: {
          'b-grid-merged-cells-container': 1
        },
        children: []
      };
      return map;
    }, {});
    // Determine and update visible ranges
    for (const range of me.mergedRanges) {
      if (range.use && range.fromIndex <= toIndex && range.toIndex >= fromIndex) {
        // Update the range, in case more of it has been scrolled into view
        me.updateRange(range, me.heightChanged, rows);
        // Create a DomConfig for it
        domConfigMap[range.column.region].children.push(me.createRangeDomConfig(range));
      }
    }
    return domConfigMap;
  }
  syncDom(force = false) {
    const me = this,
      {
        client
      } = me,
      {
        rowManager
      } = client;
    // Bail out if we get here too early (happens in Scheduler) or are disabled
    if (!force && !rowManager.topRow || me.disabled && !me.isDisabling) {
      return;
    }
    const domConfigMap = this.buildMergedCellsConfig();
    // Sync per subgrid
    client.eachSubGrid(subGrid => {
      DomSync.sync({
        targetElement: subGrid.$mergedCellsElement,
        syncIdField: 'syncId',
        domConfig: domConfigMap[subGrid.region]
      });
    });
    me.heightChanged = false;
  }
  // Called after rows are updated, sync visible ranges per subgrid
  onRenderDone() {
    this.syncDom();
  }
  //endregion
  //region Ranges
  // Remove range from list and index/column map, leaving no trace it since we dont know if it will ever
  // come back (element will be released by DomSync)
  removeRange(range) {
    ArrayHelper.remove(this.mergedRanges, range);
    for (let index = range.fromIndex; index <= range.toIndex; index++) {
      delete this.mergedMap[`${index}-@-${range.column.id}`];
    }
  }
  // Full reset, regenerating all ranges
  reset(redraw = true) {
    const me = this,
      columns = me.client.columns.visibleColumns.filter(c => c.mergeCells && c.isSorted, true),
      hadRanges = me.mergedRanges.length;
    me.mergedRanges = [];
    me.mergedMap = {};
    if (redraw && !me.client.refreshSuspended) {
      for (const row of me.client.rowManager.rows) {
        for (const column of columns) {
          row.renderCell(row.getCell(column.id));
        }
      }
      // Redraw, forcing it if all rows are gone
      me.syncDom(hadRanges && !me.client.rowManager.rowCount);
    }
  }
  // Refreshes existing ranges coords
  refreshBounds() {
    const {
        mergedRanges
      } = this,
      boundsMap = new Map();
    for (const range of mergedRanges.slice()) {
      const {
          column
        } = range,
        {
          element
        } = column;
      // Column shown
      if (element) {
        let bounds = boundsMap.get(column);
        if (!bounds) {
          // Temporarily cache bounds to avoid calculating them multiple times
          boundsMap.set(column, bounds = Rectangle.from(element, element.parentElement));
        }
        range.left = bounds.left;
        range.width = bounds.width;
      }
      // Column hidden or removed
      else {
        this.removeRange(range);
      }
    }
    this.syncDom();
  }
  // Updates the range as user scrolls, until its start and end coords are fully known
  // Rows argument is required to render merged cells on export. We provide row-like objects there
  updateRange(range, force, rows = null) {
    const {
        store,
        rowManager
      } = this.client,
      {
        topRendered,
        bottomRendered
      } = range,
      {
        rowOffsetHeight
      } = rowManager;
    let {
        fromIndex,
        toIndex
      } = range,
      topRow,
      bottomRow;
    force = rows ? rows.length > 0 : force;
    // No need to update anything if bounds are correct already
    if (!force && topRendered && bottomRendered) {
      return;
    }
    if (!topRendered || force) {
      if (rows) {
        const index = rows.findIndex(row => row.dataIndex >= fromIndex);
        topRow = rows[index];
        fromIndex = topRow.dataIndex;
      } else {
        // TODO: Should not need to iterate here, calculate top instead
        do {
          topRow = rowManager.getRowById(store.getAt(fromIndex));
        } while (!topRow && fromIndex++ < toIndex);
      }
      // topRow is the actual topmost row in the range
      range.topRendered = fromIndex === range.fromIndex;
      const rowsAbove = fromIndex - range.fromIndex;
      range.top = topRow.top - rowsAbove * (rows ? topRow.offsetHeight : rowOffsetHeight);
    }
    if (!bottomRendered || force) {
      if (rows) {
        // We need to find last index, so we can just pick max between -1 and whatever we find
        const index = rows.findIndex(row => row.dataIndex === toIndex);
        bottomRow = rows[index === -1 ? rows.length - 1 : index];
        fromIndex = bottomRow.dataIndex;
      } else {
        // TODO: Should not need to iterate here, calculate bottom instead
        do {
          bottomRow = rowManager.getRowById(store.getAt(toIndex));
        } while (!bottomRow && toIndex-- > fromIndex);
      }
      // bottomRow is the actual bottommost row in the range
      range.bottomRendered = toIndex === range.toIndex;
      const rowsBelow = range.toIndex - toIndex;
      range.bottom = bottomRow.bottom + rowsBelow * (rows ? bottomRow.offsetHeight : rowOffsetHeight);
    }
    range.height = range.bottom - range.top;
  }
  // Retrieve a range for the specified record / column, creating a new one if none found by walking upwards and
  // downwards until a deviating value is found
  getMergeRange(record, column) {
    if (record.isSpecialRow) {
      return;
    }
    const me = this,
      {
        mergedMap
      } = me,
      {
        store
      } = me.client,
      columnId = column.id,
      index = store.indexOf(record),
      key = `${index}-@-${columnId}`;
    let range = mergedMap[key];
    if (!range) {
      const value = column.getRawValue(record);
      range = mergedMap[key] = {
        column
      };
      me.mergedRanges.push(range);
      // Search up until encountering different value
      let earlierRecord,
        earlierValue,
        earlierIndex = index;
      do {
        earlierRecord = store.getAt(--earlierIndex);
        earlierValue = earlierRecord && column.getRawValue(earlierRecord);
        if (earlierValue === value) {
          mergedMap[`${earlierIndex}-@-${columnId}`] = range;
        }
      } while (earlierRecord && earlierValue === value);
      // And down
      let laterRecord,
        laterValue,
        laterIndex = index;
      do {
        laterRecord = store.getAt(++laterIndex);
        laterValue = laterRecord && column.getRawValue(laterRecord);
        if (laterValue === value) {
          mergedMap[`${laterIndex}-@-${columnId}`] = range;
        }
      } while (laterRecord && laterValue === value);
      range.fromIndex = earlierIndex + 1;
      range.toIndex = laterIndex - 1;
      // We only care about ranges longer than 1 record
      if (range.toIndex - range.fromIndex > 0) {
        const headerBounds = Rectangle.from(column.element, column.element.parentElement); // TODO get relative element with different approach, to work with grouped headers
        range.left = headerBounds.left;
        range.width = headerBounds.width;
        range.use = true;
      }
    }
    if (!range.element && range.use) {
      me.createRangeElement(range);
    }
    return range;
  }
  //endregion
}
//region Config
_defineProperty(MergeCells, "$name", 'MergeCells');
_defineProperty(MergeCells, "configurable", {
  /**
   * By default merged cells allow pointer events to pass through to the underlying row/cell, to allow selecting a
   * row and editing an individual cell even when they are merged. Configure as `false` to allow merged cells to
   * catch and react to the pointer events instead.
   *
   * ```javascript
   * const grid = new Grid({
   *     features : {
   *         mergeCells : {
   *             // Let merged cells react to pointer events
   *             passthrough : false
   *         }
   *     }
   * });
   * ```
   *
   * @config {Boolean}
   */
  passthrough: true
});
MergeCells._$name = 'MergeCells';
GridFeatureManager.registerFeature(MergeCells);

/**
 * @module Grid/feature/QuickFind
 */
/**
 * Feature that allows the user to search in a column by focusing a cell and typing. Navigate between hits using the
 * keyboard, [f3] or [ctrl]/[cmd] + [g] moves to next, also pressing [shift] moves to previous.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * ## Keyboard shortcuts
 * This feature has the following default keyboard shortcuts:
 *
 * | Keys          | Action           | Action description                |
 * |---------------|------------------|-----------------------------------|
 * | F3            | goToNextHit      | Move focus to next search hit     |
 * | Shift+F3      | goToPrevHit      | Move focus to previous search hit |
 * | Ctrl+g        | goToNextHit      | Move focus to next search hit     |
 * | Ctrl+Shift+g  | goToPrevHit      | Move focus to previous search hit |
 * | Ctrl+Shift+F3 | showFilterEditor | Shows the filter editor           |
 * | Escape        | clearSearch      | Removes the search completely     |
 *
 * For more information on how to customize keyboard shortcuts, please see
 * [our guide](#Grid/guides/customization/keymap.md)
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @example
 * // enable QuickFind
 * let grid = new Grid({
 *   features: {
 *     quickFind: true
 *   }
 * });
 *
 * // navigate to next hit programmatically
 * grid.features.quickFind.gotoNextHit();
 *
 * @demo Grid/quickfind
 * @classtype quickFind
 * @inlineexample Grid/feature/QuickFind.js
 * @feature
 */
class QuickFind extends InstancePlugin {
  //region Config
  static get $name() {
    return 'QuickFind';
  }
  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['onElementKeyPress', 'onCellNavigate']
    };
  }
  //endregion
  //region Init
  static get properties() {
    return {
      hitCls: 'b-quick-hit',
      hitCellCls: 'b-quick-hit-cell',
      hitCellBadgeCls: 'b-quick-hit-cell-badge',
      hitTextCls: 'b-quick-hit-text'
    };
  }
  construct(grid, config) {
    super.construct(grid, config);
    Object.assign(this, {
      grid,
      treeWalker: grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)
    });
  }
  isActionAvailable() {
    const {
      focusedCell
    } = this.grid;
    return !this.disabled && (focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.record) && !focusedCell.isActionable && this.find.length > 0;
  }
  doDisable(disable) {
    if (disable) {
      this.clear();
    }
    super.doDisable(disable);
  }
  get store() {
    return this.grid.store;
  }
  //endregion
  //region Show/hide QuickFind
  /**
   * Shows a "searchfield" in the header. Triggered automatically when you have a cell focused and start typing.
   * @private
   */
  showQuickFind() {
    const me = this,
      header = me.grid.getHeaderElement(me.columnId);
    if (header) {
      if (!me.headerField) {
        const [element, field, badge] = DomHelper.createElement({
          tag: 'div',
          className: 'b-quick-hit-header',
          children: [{
            tag: 'div',
            className: 'b-quick-hit-field'
          }, {
            tag: 'div',
            className: 'b-quick-hit-badge'
          }]
        }, {
          returnAll: true
        });
        if (me.mode === 'header') {
          header.appendChild(element);
        } else {
          element.className += ' b-quick-hit-mode-grid';
          me.grid.element.appendChild(element);
        }
        me.headerField = {
          header: element,
          field: field,
          badge: badge,
          colHeader: header
        };
      }
      me.headerField.field.innerHTML = me.find;
      me.headerField.badge.innerHTML = me.found.length;
      header.classList.add('b-quick-find-header');
      if (!me.renderListenerInitialized) {
        me.grid.rowManager.ion({
          rendercell: me.renderCell,
          thisObj: me
        });
        me.renderListenerInitialized = true;
      }
    }
  }
  /**
   * Hide the "searchfield" and remove highlighted hits. Called automatically when pressing [esc] or backspacing away
   * the keywords.
   * @private
   */
  hideQuickFind() {
    const me = this,
      {
        grid,
        headerField
      } = me;
    // rerender cells to remove quick-find markup
    for (const hit of me.prevFound || me.found) {
      const row = grid.getRowById(hit.id);
      if (row) {
        // Need to force replace quick finds markup
        row.forceInnerHTML = true;
        const cellElement = row.getCell(me.columnId);
        cellElement._content = null;
        row.renderCell(cellElement);
        row.forceInnerHTML = false;
      }
    }
    if (headerField) {
      headerField.header.parentNode.removeChild(headerField.header);
      headerField.colHeader.classList.remove('b-quick-find-header');
      me.headerField = null;
    }
    if (me.renderListenerInitialized) {
      grid.rowManager.un({
        rendercell: me.renderCell
      }, me);
      me.renderListenerInitialized = false;
    }
    grid.trigger('hideQuickFind');
  }
  //endregion
  //region Search
  /**
   * Performs a search and highlights hits. If find is empty, QuickFind is closed.
   * @param {String} find Text to search for
   * @param {String} columnFieldOrId Column to search
   */
  search(find, columnFieldOrId = this.columnId) {
    const me = this,
      {
        grid
      } = me,
      column = grid.columns.getById(columnFieldOrId) || grid.columns.get(columnFieldOrId),
      found = me.store.findByField(column.field, find, column.mergeCells && column.isSorted);
    let i = 1;
    Object.assign(me, {
      foundMap: {},
      prevFound: me.found,
      found,
      find,
      columnId: column.id,
      findRe: new RegExp(`(\\s+)?(${StringHelper.escapeRegExp(String(find))})(\\s+)?`, 'ig')
    });
    if (find) {
      me.showQuickFind();
    } else {
      me.hideQuickFind();
    }
    // clear old hits
    for (const cellElement of DomHelper.children(grid.element, `.${me.hitCls}`)) {
      cellElement.classList.remove(me.hitCls, me.hitCellCls);
      if (cellElement._originalContent) {
        cellElement.innerHTML = cellElement._originalContent;
        cellElement._originalContent = null;
      }
    }
    if (!found) {
      return;
    }
    if (found.length > 0) {
      me.gotoClosestHit(grid.focusedCell, found);
    }
    // highlight hits for visible cells
    for (const hit of found) {
      me.foundMap[hit.id] = i++;
      const row = grid.getRowById(hit.data.id);
      row === null || row === void 0 ? void 0 : row.renderCell(row.getCell(column.id));
      // limit highlighted hits
      if (i > 1000) {
        break;
      }
    }
    grid.trigger('quickFind', {
      find,
      found
    });
  }
  /**
   * Clears and closes QuickFind.
   */
  clear() {
    var _this$found;
    if (this.find || (_this$found = this.found) !== null && _this$found !== void 0 && _this$found.length) {
      this.search('');
    }
  }
  /**
   * Number of results found
   * @type {Number}
   * @readonly
   */
  get foundCount() {
    var _this$found$length, _this$found2;
    return (_this$found$length = (_this$found2 = this.found) === null || _this$found2 === void 0 ? void 0 : _this$found2.length) !== null && _this$found$length !== void 0 ? _this$found$length : 0;
  }
  /**
   * Found results (as returned by Store#findByField), an array in format { index: x, data: record }
   * @member {StoreSearchResult[]} found
   * @readonly
   */
  //endregion
  //region Navigation
  /**
   * Go to specified hit.
   * @param {Number} index
   */
  gotoHit(index) {
    const nextHit = this.found[index];
    if (nextHit) {
      this.grid.focusCell({
        columnId: this.columnId,
        id: nextHit.id
      }, {
        doSelect: true
      });
    }
    return !!nextHit;
  }
  gotoClosestHit(focusedCell, found) {
    const focusedIndex = focusedCell ? this.grid.store.indexOf(focusedCell.id) : 0,
      foundSorted = found.slice().sort((a, b) => Math.abs(a.index - focusedIndex) - Math.abs(b.index - focusedIndex));
    this.gotoHit(found.indexOf(foundSorted[0]));
  }
  /**
   * Go to the first hit.
   */
  gotoFirstHit() {
    this.gotoHit(0);
  }
  /**
   * Go to the last hit.
   */
  gotoLastHit() {
    this.gotoHit(this.found.length - 1);
  }
  /**
   * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].
   */
  gotoNextHit() {
    var _grid$_focusedCell$id, _grid$_focusedCell, _grid$lastFocusedCell;
    const me = this,
      {
        grid
      } = me,
      // start from focused cell, or if focus has left grid use lastFocusedCell
      currentId = (_grid$_focusedCell$id = (_grid$_focusedCell = grid._focusedCell) === null || _grid$_focusedCell === void 0 ? void 0 : _grid$_focusedCell.id) !== null && _grid$_focusedCell$id !== void 0 ? _grid$_focusedCell$id : (_grid$lastFocusedCell = grid.lastFocusedCell) === null || _grid$lastFocusedCell === void 0 ? void 0 : _grid$lastFocusedCell.id,
      currentIndex = grid.store.indexOf(currentId) || 0,
      nextHit = me.found.find(hit => hit.index > currentIndex);
    if (nextHit) {
      grid.focusCell({
        columnId: me.columnId,
        id: nextHit.id
      }, {
        doSelect: true
      });
    } else {
      me.gotoFirstHit();
    }
  }
  /**
   * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].
   */
  gotoPrevHit() {
    var _grid$_focusedCell$id2, _grid$_focusedCell2, _grid$lastFocusedCell2;
    const me = this,
      {
        grid,
        found
      } = me,
      currentId = (_grid$_focusedCell$id2 = (_grid$_focusedCell2 = grid._focusedCell) === null || _grid$_focusedCell2 === void 0 ? void 0 : _grid$_focusedCell2.id) !== null && _grid$_focusedCell$id2 !== void 0 ? _grid$_focusedCell$id2 : (_grid$lastFocusedCell2 = grid.lastFocusedCell) === null || _grid$lastFocusedCell2 === void 0 ? void 0 : _grid$lastFocusedCell2.id,
      currentIndex = grid.store.indexOf(currentId) || 0;
    let prevHit;
    if (!found.length) {
      return;
    }
    for (let i = found.length - 1; i--; i >= 0) {
      if (found[i].index < currentIndex) {
        prevHit = found[i];
        break;
      }
    }
    if (prevHit) {
      grid.focusCell({
        columnId: me.columnId,
        id: prevHit.id
      }, {
        doSelect: true
      });
    } else {
      me.gotoLastHit();
    }
  }
  //endregion
  //region Render
  /**
   * Called from SubGrid when a cell is rendered.
   * @private
   */
  renderCell({
    cellElement,
    column,
    record
  }) {
    var _me$foundMap;
    const me = this,
      {
        classList
      } = cellElement,
      {
        treeWalker,
        findRe,
        hitTextCls
      } = me,
      hitIndex = me.columnId === column.id && ((_me$foundMap = me.foundMap) === null || _me$foundMap === void 0 ? void 0 : _me$foundMap[record.id]);
    if (hitIndex) {
      // highlight cell
      classList.add(me.hitCls);
      cellElement.isQuickHit = true;
      cellElement._originalContent = cellElement.innerHTML;
      // if features have added other stuff to the cell, value is in div.b-grid-cell-value
      // highlight in cell if found in innerHTML
      const inner = treeWalker.currentNode = DomHelper.down(cellElement, '.b-grid-cell-value,.b-tree-cell-value') || cellElement;
      for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode);) {
        const nodeToReplace = textNode,
          textContent = textNode.nodeValue,
          newText = ['<span>'];
        // Move onto next text node before we replace the node with a highlight HTML sequence
        textNode = treeWalker.nextNode();
        let offset = findRe.lastIndex;
        // Convert textContent into an innerHTML string which htmlEncodes the text and embeds
        // a highlighting span which contains the target text.
        for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {
          const preamble = textContent.substring(offset, match.index),
            spaceBefore = match[1] ? '\xa0' : '',
            v = match[2],
            spaceAfter = match[3] ? '\xa0' : '';
          newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class="${hitTextCls}">${v}</span>${spaceAfter}`);
          offset = findRe.lastIndex;
        }
        newText.push(StringHelper.encodeHtml(textContent.substring(offset)), '</span>');
        // Insert a fragment with each match wrapped with a span.
        nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(''), {
          fragment: true
        }), nodeToReplace);
        nodeToReplace.remove();
      }
      DomHelper.createElement({
        parent: cellElement,
        className: me.hitCellBadgeCls,
        text: hitIndex
      });
    }
  }
  //endregion
  //region Events
  onBackspace(event) {
    const me = this;
    if (me.find) {
      me.find = me.find.substr(0, me.find.length - 1);
      me.search(me.find);
      return true;
    }
    return false;
  }
  clearSearch() {
    if (this.find) {
      this.find = '';
      this.search(this.find);
      return true;
    }
    return false;
  }
  showFilterEditor() {
    const me = this,
      {
        filter
      } = me.client.features;
    if (filter && me.columnId && me.foundCount) {
      me.clear();
      filter.showFilterEditor(me.client.columns.getById(me.columnId), me.find);
    }
  }
  /**
   * Chained function called on grids keypress event. Handles input for "searchfield".
   * @private
   * @param event
   */
  onElementKeyPress(event) {
    var _event$key;
    const me = this,
      {
        grid
      } = me,
      {
        focusedCell
      } = grid;
    // Only react to keystrokes on grid cell elements
    if (!event.handled && !me.disabled && focusedCell !== null && focusedCell !== void 0 && focusedCell.record && !focusedCell.isActionable && ((_event$key = event.key) === null || _event$key === void 0 ? void 0 : _event$key.length) === 1) {
      const column = grid.columns.getById(grid._focusedCell.columnId);
      // if trying to search in invalid column, it's a hard failure
      if (column && column.searchable !== false) {
        me.columnId = grid._focusedCell.columnId;
        me.find += event.key;
        me.search(me.find);
      }
    }
  }
  onCellNavigate(grid, fromCellSelector, toCellSelector) {
    const me = this;
    if (me.find && (!toCellSelector || toCellSelector.columnId !== me.columnId)) {
      me.clear();
    }
  }
  //endregion
}
_defineProperty(QuickFind, "configurable", {
  mode: 'header',
  find: '',
  /**
   * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
   * @config {Object<String,String>}
   */
  keyMap: {
    F3: 'gotoNextHit',
    'Shift+F3': 'gotoPrevHit',
    'Ctrl+g': 'gotoNextHit',
    'Ctrl+Shift+g': 'gotoPrevHit',
    'Ctrl+Shift+f': 'showFilterEditor',
    Escape: 'clearSearch',
    //Private
    Backspace: 'onBackspace'
  }
});
QuickFind._$name = 'QuickFind';
GridFeatureManager.registerFeature(QuickFind);

/**
 * @module Grid/feature/RowExpander
 */
const storeRemoveActions = {
  remove: 1,
  filter: 1,
  dataset: 1,
  replace: 1
};
/**
 * Enables expanding of Grid rows by either row click or double click, or by adding a separate Grid column which renders
 * a button that expands or collapses the row.
 *
 * {@inlineexample Grid/feature/RowExpander.js}
 *
 * The content of the expanded row body is rendered by providing a {@link #config-renderer} function to the
 * rowExpander feature config.
 *
 * ```javascript
 * new Grid({
 *    features : {
 *        rowExpander : {
 *            renderer({record, region, expanderElement}){
 *                return htmlToBeExpanded;
 *            }
 *        }
 *    }
 * });
 * ```
 *
 * <div class="note">Note that if used in a Gantt, the Gant's `fixedRowHeight` must be set to `false`.</div>
 *
 * This feature is **disabled** by default
 *
 * ## Expand on click
 * Set {@link #config-triggerEvent} to a Grid cell event that should trigger row expanding and collapsing.
 *
 * ```javascript
 * new Grid({
 *    features : {
 *        rowExpander : {
 *            triggerEvent: 'celldblclick',
 *            renderer...
 *        }
 *    }
 * });
 * ```
 *
 * ## Expander column position
 * The expander column can either be inserted before or after the existing Grid columns. If the Grid has multiple
 * regions the column will be added to the first region.
 *
 * Adjust expander column position to last in a specific Grid region by setting {@link #config-columnPosition}
 * to `last` and configuring the {@link #config-column} with a region name.
 *
 * ```javascript
 * new Grid({
 *    features : {
 *        rowExpander : {
 *            column: {
 *                region: 'last'
 *            },
 *            columnPosition: 'last',
 *            renderer...
 *        }
 *    }
 * });
 * ```
 *
 * ## Record update
 * If the expander content depends on row record data, the expander can be re-rendered on record update by setting
 * {@link #config-refreshOnRecordChange} to `true`.
 * ```javascript
 * new Grid({
 *    features : {
 *        rowExpander : {
 *            refreshOnRecordChange: true,
 *            renderer...
 *        }
 *    }
 * });
 * ```
 *
 * ## Async
 * When the content of the row expander should be rendered async just see to it that you return a promise.
 * ```javascript
 * new Grid({
 *    features : {
 *        rowExpander : {
 *            async renderer({record, region, expanderElement}){
 *                return fetchFromBackendAndRenderData(record);
 *            }
 *        }
 *    }
 * });
 * ```
 *
 * @extends Core/mixin/InstancePlugin
 * @classtype rowExpander
 * @feature
 */
class RowExpander extends InstancePlugin {
  //region Config

  // Cannot use `static properties = {}`, new Map/Set would pollute the prototype
  static get properties() {
    return {
      // CSS classes
      expanderBodyClass: 'b-rowexpander-body',
      expandedRowClass: 'b-rowexpander-row-expanded',
      // Map where the keys are the expanded records and values are an object {rowHeight, cellHeight, expandElements}
      recordStateMap: new Map(),
      collapsingRecords: new Set()
    };
  }
  // Plugin configuration. This plugin chains/overrides some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['afterColumnsChange', 'beforeRenderRow', 'processRowHeight', 'bindStore'],
      override: ['onGridBodyFocusIn']
    };
  }
  //endregion
  //region Init
  afterConstruct() {
    const me = this,
      {
        client
      } = me;
    if (!me.renderer) {
      console.warn('RowExpander requires implementing the renderer function.');
      return;
    }
    if (client.isGanttBase && client.fixedRowHeight !== false) {
      console.warn('When using RowExpander on a Gantt, the Gantt`s fixedRowHeight config must be set to false.');
    }
    // Bind initial store
    me.bindStore(client.store);
    if (me.triggerEvent) {
      client.ion({
        [me.triggerEvent]: 'onTriggerEvent',
        thisObj: me
      });
    }
    me.addColumn();
  }
  bindStore(store) {
    const me = this;
    me.recordStateMap.clear();
    me.collapsingRecords.clear();
    me.detachListeners('clientStoreChange');
    store.ion({
      name: 'clientStoreChange',
      change: me.onStoreChange,
      thisObj: me
    });
  }
  doDisable(disable) {
    const {
      client
    } = this;
    if (disable) {
      this.recordStateMap.clear();
      this.collapsingRecords.clear();
    }
    if (!client.isConfiguring) {
      client.rowManager.renderFromRow();
    }
    super.doDisable(disable);
  }
  changeLoadingIndicatorText(text) {
    return text ? this.L(text) : text;
  }
  // Overrides onGridBodyFocusIn to ignore events on row expander body.
  onGridBodyFocusIn(event) {
    var _this$client$lastMous, _this$client$lastMous2;
    if (!((_this$client$lastMous = this.client.lastMousedownEvent) !== null && _this$client$lastMous !== void 0 && (_this$client$lastMous2 = _this$client$lastMous.target) !== null && _this$client$lastMous2 !== void 0 && _this$client$lastMous2.closest('.b-rowexpander-body'))) {
      this.overridden.onGridBodyFocusIn(event);
    }
  }
  get isAnimating() {
    return this.client.isAnimating;
  }
  set isAnimating(value) {
    const {
        client
      } = this,
      wasAnimating = client.isAnimating;
    client.isAnimating = value;
    if (client.isAnimating !== wasAnimating) {
      client.element.classList.toggle('b-rowexpander-animating');
    }
  }
  //endregion
  //region Events
  /**
   * This event fires before row expand is started.
   *
   * Returning `false` from a listener prevents the RowExpander to expand the row.
   *
   * Note that this event fires when the RowExpander toggles the row, not when the actual row expander body is
   * rendered. Most of the time this is synchronous, but in the case of a row that is not yet rendered into view by
   * scrolling, it can happen much later.
   *
   * @event beforeExpand
   * @preventable
   * @async
   * @param {Core.data.Model} record Record
   */
  /**
   * This event fires before row collapse is started.
   *
   * Returning `false` from a listener prevents the RowExpander to collapse the row.
   *
   * Note that this event fires when the RowExpander toggles the row, not when the actual row expander body is
   * rendered. Most of the time this is synchronous, but in the case of a row that is not yet rendered into view by
   * scrolling, it can happen much later.
   *
   * @event beforeCollapse
   * @preventable
   * @async
   * @param {Core.data.Model} record Record
   */
  //endregion
  //region ExpanderColumn
  afterColumnsChange() {
    this.addColumn();
  }
  changeColumn(config) {
    if (config == null) {
      return config;
    }
    return _objectSpread2(_objectSpread2({
      type: 'action',
      actions: [{
        cls: 'b-icon b-icon-collapse-down',
        tooltip: ({
          record
        }) => this.L(this.recordStateMap.has(record) ? 'L{RowExpander.collapse}' : 'L{RowExpander.expand}'),
        onClick: ({
          record
        }) => this.toggleExpand(record)
      }],
      width: 40,
      hideable: false,
      align: 'center',
      region: this.client.regions[0]
    }, config), {}, {
      field: 'expanderActionColumn'
    });
  }
  // Called in construct and if grid columns change
  addColumn() {
    const me = this,
      {
        column
      } = me,
      {
        columns
      } = me.client;
    if (!me._isAddingExpanderColumn && column && (!me._expander || !columns.includes(me._expander))) {
      me._isAddingExpanderColumn = true;
      if (me.columnPosition === 'last') {
        [me._expander] = columns.add(column);
      } else {
        [me._expander] = columns.insert(0, column);
      }
      me._isAddingExpanderColumn = false;
    }
  }
  //endregion
  //region UI events
  onTriggerEvent({
    target
  }) {
    // Only grid cell event is handled. Action-cell event has its own handler.
    if (this.disabled || target !== null && target !== void 0 && target.closest('.b-action-cell') || !target.closest('.b-grid-cell')) {
      return;
    }
    this.toggleExpand(this.client.getRecordFromElement(target));
  }
  /**
   * Toggles expander state.
   * @private
   * @param {Core.data.Model} record The record that should be toggled
   * @category Internal
   */
  toggleExpand(record) {
    if (record) {
      if (this.recordStateMap.has(record)) {
        this.collapse(record);
      } else {
        this.expand(record);
      }
    }
  }
  //endregion
  //region Rendering
  /**
   * Listens to changes in the Grid Store. Will remove expand State data on Store removal.
   * If the refreshOnRecordChange config is `true`, it will trigger a re-render of the expander.
   * @private
   * @param {String} action
   * @param {Core.data.Store} source
   * @param {Core.data.Model[]} records
   * @category Internal
   */
  onStoreChange({
    action,
    source,
    records
  }) {
    const me = this,
      {
        recordStateMap,
        collapsingRecords
      } = me;
    if (me.disabled) {
      return;
    }
    if (action === 'removeAll') {
      recordStateMap.clear();
      collapsingRecords.clear();
    } else if (storeRemoveActions[action]) {
      for (const [record] of recordStateMap) {
        if (!source.includes(record)) {
          recordStateMap.delete(record);
          collapsingRecords.delete(record);
        }
      }
    } else if (me.refreshOnRecordChange && records !== null && records !== void 0 && records.length) {
      if (action === 'update') {
        const recordState = recordStateMap.get(records[0]);
        if (recordState !== null && recordState !== void 0 && recordState.isCreated) {
          recordState.isCreated = false;
          me.client.rowManager.renderFromRecord(records[0]);
        }
      } else if (action === 'updatemultiple') {
        let topRecordIndex, topRecord;
        for (const rec of records) {
          const recordState = recordStateMap.get(rec);
          if (recordState !== null && recordState !== void 0 && recordState.isCreated) {
            recordState.isCreated = false;
            const index = source.records.indexOf(rec);
            if (!topRecord || topRecordIndex > index) {
              topRecordIndex = index;
              topRecord = rec;
            }
          }
        }
        if (topRecord) {
          me.client.rowManager.renderFromRecord(topRecord);
        }
      }
    }
  }
  // Implements grid.processRowHeight hook
  processRowHeight(record, height) {
    var _recordState$expander;
    const recordState = this.recordStateMap.get(record);
    if (recordState) {
      // If we are waiting for async rendering, height is calculated from a fixed loadingIndicatorHeight.
      if (!recordState.isCreated && recordState.isRenderingAsync) {
        return this.loadingIndicatorHeight + height;
      }
      // If we have a recordState but no expanderBodyHeight, we should recalculate height.
      if (!recordState.expanderBodyHeight) {
        for (const region of this.client.regions) {
          const height = recordState.expandElements[region].offsetHeight;
          if (height > recordState.expanderBodyHeight) {
            recordState.expanderBodyHeight = height;
          }
        }
      }
    }
    return ((_recordState$expander = recordState === null || recordState === void 0 ? void 0 : recordState.expanderBodyHeight) !== null && _recordState$expander !== void 0 ? _recordState$expander : 0) + height;
  }
  /**
   * Hooks on before row render to render or remove row expander content depending on record state.
   * @private
   * @category Internal
   */
  beforeRenderRow({
    row,
    record
  }) {
    const me = this,
      {
        regions
      } = me.client,
      {
        expandedRowClass
      } = me;
    row.cls.toggle('b-rowexpander-disabled', me.disabled);
    // If current row is expanded, always remove all expander content and settings.
    if (row.cls[expandedRowClass]) {
      // If animating a collapse, content should not be removed until animation is complete
      if (me.enableAnimations && me.isAnimating && me.collapsingRecords.has(record)) {
        me.waitForTransition(row, () => {
          // Make sure record still should be collapsed after animation is complete
          if (me.collapsingRecords.has(record)) {
            me.removeExpander(row);
          }
        });
      } else {
        me.removeExpander(row);
      }
    } else {
      // Makes sure record should collapse no longer
      me.collapsingRecords.delete(record);
    }
    // The map only contains record that are expanded
    const recordState = me.recordStateMap.get(record);
    if (!me.disabled && recordState) {
      // Expander content is created once, then reused.
      if (!recordState.isCreated) {
        me.renderExpander(record, row, recordState);
      }
      row.cls.add(expandedRowClass);
      for (const region of regions) {
        const rowElement = row.getElement(region);
        if (recordState.isCreated) {
          rowElement.appendChild(recordState.expandElements[region]);
        } else {
          // If the renderer is async, we show a loading indicator.
          me.renderLoadingIndicator(rowElement, recordState);
        }
        me.lockCellHeight(rowElement, recordState.cellHeight, false);
      }
      // If expander body is rendered not fully in view, it will be scrolled into view
      if (me._shouldScrollIntoView) {
        me._shouldScrollIntoView = false;
        if (!DomHelper.isInView(recordState.expandElements[regions[0]], true)) {
          // Waits for rendering to complete, then scrolls
          me.client.rowManager.ion({
            once: true,
            thisObj: me,
            renderDone: () => me.scrollRowIntoView(row, record)
          });
        }
      }
    }
  }
  /**
   * Scrolls expanded row into view. This function is called after rowManager has finished rendering.
   * @private
   * @category Internal
   */
  scrollRowIntoView(row, record) {
    // If animating expand, need to wait for the animation to end before scrolling.
    if (this.isAnimating) {
      this.waitForTransition(row, () => this.client.scrollRowIntoView(record));
    } else {
      this.client.scrollRowIntoView(record);
    }
  }
  /**
   * Waits for height transition on the provided rows element. Then calls provided function.
   * @private
   * @category Internal
   */
  waitForTransition(row, fn) {
    EventHelper.onTransitionEnd({
      element: row.element,
      property: 'height',
      handler: fn,
      thisObj: this
    });
  }
  removeExpander(row) {
    row.cls.remove(this.expandedRowClass);
    for (const region of this.client.regions) {
      const rowElement = row.getElement(region);
      // If this function is called after animation finished, we need to remove class `manually`
      rowElement.classList.remove(this.expandedRowClass);
      DomHelper.removeEachSelector(rowElement, '.' + this.expanderBodyClass);
      this.lockCellHeight(rowElement, null, false);
    }
  }
  renderLoadingIndicator(rowElement, recordState) {
    DomHelper.createElement({
      parent: rowElement,
      className: this.expanderBodyClass + ' b-rowexpander-loading',
      style: {
        top: recordState.cellHeight,
        height: this.loadingIndicatorHeight
      },
      children: [{
        tag: 'i',
        className: 'b-icon b-icon-spinner'
      }, this.loadingIndicatorText]
    });
  }
  /**
   * Creates expander element for each grid region and calls the renderer, also for each grid region.
   * @private
   * @param {Core.data.Model} record
   * @param {Grid.row.Row} row
   * @param {Object} recordState
   * @category Internal
   */
  renderExpander(record, row, recordState) {
    var _row$cells$;
    const me = this,
      cellHeight = (_row$cells$ = row.cells[0]) === null || _row$cells$ === void 0 ? void 0 : _row$cells$.offsetHeight,
      expandElements = {},
      renderings = [],
      // Will be called sync or async depending on the implementation of the renderer function.
      continueRendering = (content, expanderElement, region) => {
        if (content != null) {
          if (typeof content === 'string') {
            expanderElement.innerHTML = content;
          }
          // Everything else will be treated as a dom config for now
          else {
            content = DomHelper.createElement(content);
            expanderElement.appendChild(content);
          }
        }
        expandElements[region] = expanderElement;
      };
    // If another rendering of the same record is made while waiting for async, we should ignore it.
    if (recordState.isRenderingAsync) {
      return;
    }
    Object.assign(recordState, {
      cellHeight,
      expandElements,
      expanderBodyHeight: 0
    });
    for (const region of me.client.regions) {
      const rowElement = row.getElement(region);
      // class needed at this point to give the expander container correct height
      row.addCls(me.expandedRowClass);
      // Create expand container
      // Expander element needs to be in the DOM for appendTo to work correctly
      const expanderElement = DomHelper.createElement({
        parent: rowElement,
        className: me.expanderBodyClass,
        style: {
          top: cellHeight + 'px'
        }
      });
      // The renderer can be async or sync
      const renderResponse = me.renderer({
        record,
        expanderElement,
        rowElement,
        region
      });
      if (Objects.isPromise(renderResponse)) {
        renderings.push(renderResponse.then(content => continueRendering(content, expanderElement, region)));
      } else {
        continueRendering(renderResponse, expanderElement, region);
      }
    }
    // If we have async renderer, wait for all to complete
    if (renderings.length) {
      recordState.isRenderingAsync = true;
      Promise.all(renderings).then(() => {
        var _me$renderRowsWithAni;
        // Flag that indicates the completion of expand rendering
        recordState.isCreated = true;
        // The rows need to refresh to recalculate row height
        // (?. since we might have been destroyed while waiting for promises)
        (_me$renderRowsWithAni = me.renderRowsWithAnimation) === null || _me$renderRowsWithAni === void 0 ? void 0 : _me$renderRowsWithAni.call(me, record);
        recordState.isRenderingAsync = false;
      });
    } else {
      recordState.isCreated = true;
    }
  }
  /**
   * Called when grid rows needs to re-render, for example on expand or collapse.
   * Activates animations on grid, and deactivates them when they are completed.
   * @private
   * @param {Core.data.Model} record Record whose row was toggled
   * @category Internal
   */
  renderRowsWithAnimation(record) {
    const me = this;
    if (me.enableAnimations) {
      const row = me.client.rowManager.getRowById(record);
      if (row) {
        me.isAnimating = true;
        if (me.collapsingRecords.has(record)) {
          row.addCls('b-row-is-collapsing');
        }
        me.waitForTransition(row, () => {
          me.isAnimating = false;
          if (!row.isDestroyed) {
            var _row$removeCls;
            (_row$removeCls = row.removeCls) === null || _row$removeCls === void 0 ? void 0 : _row$removeCls.call(row, 'b-row-is-collapsing');
          }
        });
      }
    }
    me.client.rowManager.renderFromRecord(record);
  }
  /**
   * Called when row is expanded. This function locks all cell's height to current height (before expanding).
   * @private
   * @param {HTMLElement} rowElement
   * @param {Number} cellHeight The height to lock
   * @param {Boolean} unlock To remove locked cell height when the row is collapsed
   * @category Internal
   */
  lockCellHeight(rowElement, cellHeight, unlock) {
    for (let a = 0; a < rowElement.children.length; a++) {
      const child = rowElement.children[a];
      // Should not lock expander element
      if (!child.classList.contains(this.expanderBodyClass)) {
        child.style.height = unlock ? '' : cellHeight + 'px';
      }
    }
  }
  //endregion
  //region Public
  /**
   * Tells the RowExpander that the provided record should be expanded. If or when the record is rendered into view,
   * the record will be expanded.
   *
   * @param {Core.data.Model} record Record whose row should be expanded
   * @category Common
   */
  async expand(record) {
    const me = this;
    if (me.disabled) {
      return;
    }
    if ((await me.trigger('beforeExpand', {
      record
    })) === false) {
      return;
    }
    // Tells renderer that this record should be expanded
    me.recordStateMap.set(record, {
      isCreated: false
    });
    // In the event that we have expanded a record which is in collapsing animation state
    me.collapsingRecords.delete(record);
    me._shouldScrollIntoView = true;
    me.renderRowsWithAnimation(record);
  }
  /**
   * Tells the RowExpander that the provided record should be collapsed. If the record is in view, it will be
   * collapsed. If the record is not in view, it will simply not be expanded when rendered into view.
   *
   * @param {Core.data.Model} record Record whose row should be collapsed
   * @category Common
   */
  async collapse(record) {
    const me = this;
    if (me.disabled) {
      return;
    }
    if ((await me.trigger('beforeCollapse', {
      record
    })) === false) {
      return;
    }
    me.recordStateMap.delete(record);
    me.collapsingRecords.add(record);
    me.renderRowsWithAnimation(record);
  }
  //endregion
}
_defineProperty(RowExpander, "$name", 'RowExpander');
_defineProperty(RowExpander, "configurable", {
  /**
   * The implementation of this function is called each time the body of an expanded row is rendered. Either
   * return an HTML string, or a {@link Core.helper.DomHelper#typedef-DomConfig} object describing the markup.
   *
   * ```javascript
   * new Grid({
   *    features : {
   *        rowExpander : {
   *            renderer({record, region, expanderElement}){
   *                return htmlToBeExpanded;
   *            }
   *        }
   *    }
   * });
   * ```
   *
   * Or return a {@link Core.helper.DomHelper#typedef-DomConfig} object.
   *
   * ```javascript
   * new Grid({
   *    features : {
   *        rowExpander : {
   *            renderer({record, region, expanderElement}){
   *                return {
   *                   tag       : 'form',
   *                   className : 'expanded-row-form',
   *                   children  : [
   *                       {
   *                           tag        : 'textarea',
   *                           name       : 'description',
   *                           className  : 'expanded-textarea'
   *                       },
   *                       {
   *                           tag        : 'button',
   *                           text       : 'Save',
   *                           className  : 'expanded-save-button',
   *                       }
   *                   ]
   *                };
   *            }
   *        }
   *    }
   * });
   * ```
   *
   * It is also possible to add markup directly to the expanderElement.
   *
   * ```javascript
   * new Grid({
   *    features : {
   *        rowExpander : {
   *            renderer({record, region, expanderElement}){
   *                new UIComponent({
   *                    appendTo: expanderElement,
   *                    ...
   *                });
   *            }
   *        }
   *    }
   * });
   * ```
   * The renderer function can also be asynchronous.
   *
   * ```javascript
   * new Grid({
   *    features : {
   *        rowExpander : {
   *            async renderer({record, region, expanderElement}){
   *                return await awaitAsynchronousOperation();
   *            }
   *        }
   *    }
   * });
   * ```
   * @param {Object} renderData Object containing renderer parameters
   * @param {Core.data.Model} renderData.record Record for the row
   * @param {HTMLElement} renderData.expanderElement Expander body element
   * @param {HTMLElement} renderData.rowElement Row element
   * @param {String} renderData.region Grid region name
   * @returns {String|DomConfig} Row expander body content
   * @config {Function}
   * @async
   */
  renderer: null,
  /**
   * The name of the Grid event that will toggle expander. Defaults to `null` but can be set to any event such
   * as {@link Grid.view.mixin.GridElementEvents#event-cellDblClick} or
   * {@link Grid.view.mixin.GridElementEvents#event-cellClick}.
   *
   * ```javascript
   * features : {
   *     rowExpander : {
   *         triggerEvent : 'cellclick'
   *     }
   * }
   * ```
   *
   * @config {String}
   */
  triggerEvent: null,
  /**
   * Provide a column config object to display a button with expand/collapse functionality.
   * Shown by default, set to `null` to not include.
   *
   * ```javascript
   * new Grid({
   *    features : {
   *        rowExpander : {
   *            column: {
   *                // Use column config options here
   *                region: 'last'
   *            }
   *        }
   *    }
   * });
   * ```
   *
   * @config {ActionColumnConfig|Grid.column.ActionColumn}
   */
  column: {},
  /**
   * Makes the expand/collapse button column appear either as the first column (default or `first`) or as the
   * last (set to `last`). Note that the column by default will be added to the first region, if the Grid
   * has multiple regions. Use the {@link #config-column} config to change region.
   * @config {String}
   * @default
   */
  columnPosition: 'first',
  /**
   * If set to `true`, the RowExpander will, on record update, re-render an expanded row by calling the
   * {@link #config-renderer} function.
   * @config {Boolean}
   * @default
   */
  refreshOnRecordChange: false,
  /**
   * Use this for customizing async {@link #config-renderer} loading indicator height.
   * @config {Number}
   * @defalt
   */
  loadingIndicatorHeight: 100,
  /**
   * Use this for customizing async {@link #config-renderer} loading indicator text.
   * @config {String}
   * @default Loading
   */
  loadingIndicatorText: 'L{loading}',
  /**
   * Use this to disable expand and collapse animations.
   * @config {Boolean}
   * @default
   */
  enableAnimations: true
});
RowExpander._$name = 'RowExpander';
GridFeatureManager.registerFeature(RowExpander);

//TODO: Should listen for store search also, to work the other way around
/**
 * @module Grid/feature/Search
 */
/**
 * {@inlineexample Grid/feature/Search.js}
 *
 * Feature that allows the user to search the entire grid. Navigate between hits using the
 * keyboard, [F3] or [Ctrl/CMD + G] moves to next, also pressing [Shift] moves to previous.
 *
 * Note that this feature does not include a UI, please build your own and call appropriate methods in the feature.
 * For a demo implementation, see <a href="../examples/search/" target="_blank">Search example</a>.
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * ## Keyboard shortcuts
 *
 * This feature has the following default keyboard shortcuts:
 *
 * | Keys                   | Action      | Action description                |
 * |------------------------|-------------|-----------------------------------|
 * | [F3]                   | goToNextHit | Move focus to next search hit     |
 * | [Shift + F3]           | goToPrevHit | Move focus to previous search hit |
 * | [Ctrl/CMD + G]         | goToNextHit | Move focus to next search hit     |
 * | [Ctrl/CMD + Shift + G] | goToPrevHit | Move focus to previous search hit |
 *
 * For more information on how to customize keyboard shortcuts, please see
 * [our guide](#Grid/guides/customization/keymap.md)
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @example
 * // enable Search
 * let grid = new Grid({
 *   features: {
 *     search: true
 *   }
 * });
 *
 * // perform search
 * grid.features.search.search('steve');
 *
 * @demo Grid/search
 * @classtype search
 * @feature
 */
class Search extends Delayable(InstancePlugin) {
  //region Init
  static get $name() {
    return 'Search';
  }
  static get configurable() {
    return {
      /**
       * The maximum amount of search hits
       * @config {Number}
       * @default
       */
      limit: 1000,
      /**
       * Set to false to not show the search hit index numbers
       * @config {Boolean}
       * @default
       */
      showHitIndex: true,
      /**
       * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
       * @config {Object<String,String>}
       */
      keyMap: {
        F3: 'gotoNextHit',
        'Ctrl+g': 'gotoNextHit',
        'Shift+F3': 'gotoPrevHit',
        'Ctrl+Shift+g': 'gotoPrevHit'
      }
    };
  }
  static get properties() {
    return {
      hitCls: 'b-search-hit',
      hitCellCls: 'b-search-hit-cell',
      hitCellBadgeCls: 'b-search-hit-cell-badge',
      hitTextCls: 'b-search-hit-text'
    };
  }
  construct(grid, config) {
    const me = this;
    super.construct(grid, config);
    Object.assign(me, {
      grid,
      text: '',
      hitEls: [],
      treeWalker: grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)
    });
    // When new nodes appear due to node expand, include them in the search
    grid.ion({
      expandNode: 'onTreeNodeExpand',
      thisObj: me
    });
  }
  isActionAvailable() {
    return Boolean(this.text);
  }
  onTreeNodeExpand() {
    if (this.text) {
      this.requestAnimationFrame(this.search, [this.text, false, true]);
    }
  }
  doDestroy() {
    this.clear(true);
    super.doDestroy();
  }
  doDisable(disable) {
    if (disable) {
      this.clear();
    }
    super.doDisable(disable);
  }
  get store() {
    return this.grid.store;
  }
  //endregion
  //region Plugin config
  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      chain: ['populateCellMenu']
    };
  }
  //endregion
  //region Search
  /**
   * Performs a search and highlights hits.
   * @param {String} text Text to search for
   * @param {Boolean} [gotoHit] Go to first hit after search
   * @param {Boolean} [reapply] Pass true to force search
   * @param {String[]} [fields] An array of the fields to search for the value in
   */
  async search(text, gotoHit = true, reapply = false, fields) {
    const me = this;
    // empty search considered a clear
    if (!text) {
      return me.clear();
    }
    // searching for same thing again, do nothing
    if (!reapply && text === me.text || me.disabled) {
      return;
    }
    const {
        grid,
        store
      } = me,
      // Only search columns in use
      columns = grid.columns.visibleColumns.filter(col => col.searchable !== false),
      formatters = [];
    fields = fields || columns.map(col => {
      var _col$formatValue;
      // For date / number columns
      formatters.push((_col$formatValue = col.formatValue) === null || _col$formatValue === void 0 ? void 0 : _col$formatValue.bind(col));
      return col.field;
    });
    const found = store.search(text, fields, formatters);
    if (store.isTree && found.length) {
      await grid.expandTo(found.map(hit => hit.id));
    }
    // Only include first result for merged cells in the count
    for (const column of columns) {
      if (column.mergeCells && column.isSorted) {
        let prevValue = null,
          belongsTo = null;
        for (const hit of found) {
          if (hit.field === column.field) {
            const value = hit.data[hit.field];
            if (value === prevValue) {
              hit.belongsTo = belongsTo;
            }
            prevValue = value;
            belongsTo = `${hit.field}-${hit.id}`;
          }
        }
      }
    }
    let i = 1;
    Object.assign(me, {
      foundMap: {},
      prevFound: me.found,
      found,
      text,
      findRe: new RegExp(`(\\s+)?(${StringHelper.escapeRegExp(String(text))})(\\s+)?`, 'ig')
    });
    me.clearHits();
    if (!found) {
      return;
    }
    // highlight hits for visible cells
    for (const hit of found) {
      // merged cells reuse the index of the first hit in the range
      me.foundMap[`${hit.field}-${hit.id}`] = hit.belongsTo ? me.foundMap[hit.belongsTo] : i++;
      // limit hits
      if (i > me.limit) {
        break;
      }
    }
    if (!me.listenersInitialized) {
      grid.rowManager.ion({
        name: 'renderCell',
        renderCell: 'renderCell',
        thisObj: me
      });
      store.ion({
        name: 'storeRefresh',
        [`refresh${grid.asyncEventSuffix}`]: 'onStoreRefresh',
        thisObj: me
      });
      me.listenersInitialized = true;
    }
    grid.refreshRows();
    grid.trigger('search', {
      grid,
      find: text,
      found
    });
    if (gotoHit && !me.isHitFocused) {
      me.gotoNextHit(true);
    }
    return found;
  }
  clearHits() {
    // Clear old hits
    for (const cellElement of DomHelper.children(this.grid.element, '.' + this.hitCls)) {
      cellElement.classList.remove(this.hitCls, this.hitCellCls);
      // Rerender cell to remove search-hit-text
      const row = DomDataStore.get(cellElement).row;
      // Merged cells have no row, but they will be cleared anyway by their own DomSync call
      if (row) {
        // Need to force replace the markup
        row.forceInnerHTML = true;
        row.renderCell(cellElement);
        row.forceInnerHTML = false;
      }
    }
  }
  /**
   * Clears search results.
   */
  clear(silent = false) {
    const me = this,
      {
        grid
      } = me;
    if (me.foundMap) {
      delete me.foundMap;
    }
    me.text = null;
    me.clearHits();
    if (me.listenersInitialized) {
      this.detachListeners('renderCell');
      this.detachListeners('storeRefresh');
      me.listenersInitialized = false;
    }
    if (!silent) {
      grid.trigger('clearSearch', {
        grid
      });
    }
  }
  /**
   * Number of results found
   * @readonly
   * @property {Number}
   */
  get foundCount() {
    var _this$found$length, _this$found;
    return (_this$found$length = (_this$found = this.found) === null || _this$found === void 0 ? void 0 : _this$found.length) !== null && _this$found$length !== void 0 ? _this$found$length : 0;
  }
  //endregion
  //region Navigation
  /**
   * Returns true if focused row is a hit
   * @property {Boolean}
   * @readonly
   */
  get isHitFocused() {
    var _focusedCell$cell;
    const me = this,
      {
        grid
      } = me,
      {
        focusedCell
      } = grid;
    if (focusedCell !== null && focusedCell !== void 0 && (_focusedCell$cell = focusedCell.cell) !== null && _focusedCell$cell !== void 0 && _focusedCell$cell.contains(DomHelper.getActiveElement(grid.element))) {
      const {
        rowIndex,
        column
      } = focusedCell;
      return rowIndex !== -1 && me.found.some(hit => hit.index === rowIndex && column && hit.field === column.field);
    }
  }
  /**
   * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].
   */
  gotoNextHit(fromStart = false) {
    var _me$found;
    const me = this;
    if (!((_me$found = me.found) !== null && _me$found !== void 0 && _me$found.length)) return;
    const {
        grid,
        store
      } = me,
      fromCell = grid.focusedCell || grid.lastFocusedCell,
      currentIndex = fromCell && fromStart !== true ? store.indexOf(fromCell.record, undefined, true) : -1,
      nextHit = me.found.findIndex(hit => hit.index > currentIndex);
    if (nextHit !== -1) {
      me.gotoHit(nextHit);
    }
  }
  /**
   * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].
   */
  gotoPrevHit() {
    var _me$found2;
    const me = this,
      {
        store
      } = me;
    if (!((_me$found2 = me.found) !== null && _me$found2 !== void 0 && _me$found2.length)) return;
    const {
        grid,
        found
      } = me,
      fromCell = grid.focusedCell || grid.lastFocusedCell,
      currentIndex = fromCell ? store.indexOf(fromCell.record, undefined, true) : 0;
    for (let i = found.length - 1; i--; i >= 0) {
      const hit = found[i];
      if (hit.index < currentIndex) {
        me.gotoHit(i);
        break;
      }
    }
  }
  /**
   * Go to specified hit.
   * @param {Number} index
   */
  gotoHit(index) {
    const {
        grid
      } = this,
      nextHit = this.found[index];
    if (nextHit) {
      grid.focusCell({
        field: nextHit.field,
        id: nextHit.id
      });
    }
    return Boolean(nextHit);
  }
  /**
   * Go to the first hit.
   */
  gotoFirstHit() {
    this.gotoHit(0);
  }
  /**
   * Go to the last hit.
   */
  gotoLastHit() {
    this.gotoHit(this.found.length - 1);
  }
  //endregion
  //region Render
  /**
   * Called from SubGrid when a cell is rendered. Highlights search hits.
   * @private
   */
  renderCell({
    cellElement,
    column,
    record,
    value
  }) {
    var _me$foundMap;
    const me = this,
      {
        treeWalker,
        findRe,
        hitTextCls,
        showHitIndex
      } = me,
      hitIndex = (_me$foundMap = me.foundMap) === null || _me$foundMap === void 0 ? void 0 : _me$foundMap[column.field + '-' + record.id];
    if (hitIndex) {
      var _cellElement$querySel;
      // highlight cell
      cellElement.classList.add(me.hitCls);
      // Remove any previous hit badge
      showHitIndex && ((_cellElement$querySel = cellElement.querySelector(`.${me.hitCellBadgeCls}`)) === null || _cellElement$querySel === void 0 ? void 0 : _cellElement$querySel.remove());
      // highlight in cell if found in innerHTML
      const inner = DomHelper.down(cellElement, '.b-grid-cell-value,.b-tree-cell-value') || cellElement;
      if (String(value).toLowerCase() === String(me.text).toLowerCase()) {
        inner.innerHTML = `<span class="${me.hitTextCls}">${inner.innerHTML}</span>${showHitIndex ? `<div class="${me.hitCellBadgeCls}">${hitIndex}</div>` : ''}`;
      }
      // Replace every occurrence of the text in every descendant text node with a span
      // encapsulating the matched string.
      else {
        treeWalker.currentNode = inner;
        for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode);) {
          const nodeToReplace = textNode,
            textContent = textNode.nodeValue,
            newText = ['<span>'];
          // Move onto next text node before we replace the node with a highlihght HTML sequence
          textNode = treeWalker.nextNode();
          let offset = findRe.lastIndex;
          // Convert textContent into an innerHTML string which htmlEncodes the text and embeds
          // a highlighting span which contains the target text.
          for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {
            const preamble = textContent.substring(offset, match.index),
              spaceBefore = match[1] ? '\xa0' : '',
              v = match[2],
              spaceAfter = match[3] ? '\xa0' : '';
            newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class="${hitTextCls}">${v}</span>${spaceAfter}`);
            offset = findRe.lastIndex;
          }
          newText.push(StringHelper.encodeHtml(textContent.substring(offset)), '<span>');
          // Insert a fragment with each match wrapped with a span.
          nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(''), {
            fragment: true
          }), nodeToReplace);
          nodeToReplace.remove();
        }
        if (showHitIndex) {
          DomHelper.createElement({
            parent: cellElement,
            className: me.hitCellBadgeCls,
            text: hitIndex
          });
        }
      }
      me.hitEls.push(cellElement);
    }
  }
  //endregion
  //region Context menu
  /**
   * Add search menu item to cell context menu.
   * @param {Object} options Contains menu items and extra data retrieved from the menu target.
   * @param {Grid.column.Column} options.column Column for which the menu will be shown
   * @param {Core.data.Model} options.record Record for which the menu will be shown
   * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items
   * @internal
   */
  populateCellMenu({
    column,
    record,
    items,
    cellElement
  }) {
    const me = this;
    if (column.searchable) {
      items.search = {
        text: 'L{searchForValue}',
        localeClass: me,
        icon: 'b-fw-icon b-icon-search',
        cls: 'b-separator',
        weight: 200,
        disabled: me.disabled,
        onItem: () => {
          // TODO: Only extract selection from current cell instead? Lazy way for now
          let sel = globalThis.getSelection().toString();
          if (!sel) {
            sel = cellElement.innerText;
          }
          me.search(sel);
        }
      };
    }
  }
  //endregion
  //region Events
  onStoreRefresh() {
    this.search(this.text, false, true);
  }
  //endregion
}

Search.featureClass = 'b-search';
Search._$name = 'Search';
GridFeatureManager.registerFeature(Search);

/**
 * @module Grid/feature/StickyCells
 */
/**
 * A feature which pins configurable content from a grid row to the top of the grid
 * while the row scrolls off the top but is still visible.
 *
 * As soon as the row becomes too small to contain the content, it is unpinned, and
 * scrolls out naturally, and the following row's configured content becomes pinned.
 *
 * For example:
 *
 * ```javascript
 *     new Grid({
 *         features : {
 *             stickyCells : {
 *                 // Identifies elements to clone and pin to the grid top.
 *                 contentSelector : '.myClassName'
 *             }
 *         }
 *     });
 * ```
 * @extends Core/mixin/InstancePlugin
 * @classtype stickyCells
 * @feature
 */
class StickyCells extends InstancePlugin {
  //region Config
  static get $name() {
    return 'StickyCells';
  }
  static get defaultConfig() {
    return {
      /**
       * A CSS selector which must identify the content within your grid row which you
       * require to be pinned to the grid while the row if the topmost row, and remains visible.
       * @config {String}
       */
      contentSelector: null,
      currentTopRowCls: 'b-sticky-cells-current-top-row'
    };
  }
  // Plugin configuration. This plugin chains some of the functions in Grid.
  static get pluginConfig() {
    return {
      before: ['renderRows']
    };
  }
  //endregion
  //region Init
  construct(grid, config) {
    super.construct(grid, config);
    // We cannot chain our client's onGridScroll because that is now a delayable injected method.
    grid.ion({
      scroll: 'onGridScroll',
      thisObj: this
    });
    Object.assign(this, DomHelper.createElement({
      reference: 'element',
      parent: grid.element,
      className: 'b-grid-sticky-row',
      children: [{
        reference: 'contentElement',
        className: 'b-grid-cell'
      }]
    }));
    // Clean these classes from copied cell and row classLists
    this.removeClasses = {
      'b-focused': false,
      'b-hover': false,
      'b-selected': false,
      [this.currentTopRowCls]: false
    };
  }
  renderRows() {
    // Do not leave stranded sticky row visible on data change
    this.element.classList.add('b-hide-visibility');
  }
  onGridScroll() {
    const me = this,
      {
        client: grid,
        element,
        contentElement
      } = me,
      gridViewport = Rectangle.client(grid.bodyContainer).roundPx(),
      currentTopRow = grid.rowManager.getRowAt(gridViewport.y),
      topRowChanged = currentTopRow !== me.currentTopRow;
    if (currentTopRow) {
      if (topRowChanged) {
        if (me.currentTopRow) {
          me.currentTopRow.removeCls(me.currentTopRowCls);
          me.currentTopRow.removeCls('b-not-enough-height');
        }
        me.currentTopRow = currentTopRow;
        currentTopRow.addCls(me.currentTopRowCls);
        contentElement.innerHTML = '';
        contentElement.appendChild(me.updateStickyContent());
      }
      // If the outgoing row is not not too tall, and doesn't *need* the content
      // pinning to the top, hide the sticky row, and make the source sticky
      // elements pin themselves to the bottom of the cell using the b-not-enough-height
      // class to switch them to align-self: flex-end
      const notEnoughHeight = me.currentTopRow.bottom - me.client.scrollable.y <= me.stickyContentHeight;
      me.element.classList[notEnoughHeight ? 'add' : 'remove']('b-hide-visibility');
      me.currentTopRow[notEnoughHeight ? 'addCls' : 'removeCls']('b-not-enough-height');
      // Keep sticky row aligned while constrained to the viewport.
      // This keeps it pinned to the top.
      gridViewport.y += me.stickyContentTop;
      DomHelper.alignTo(element, me.stickyEls[0], {
        align: 't0-t0',
        constrainTo: gridViewport
      }, true);
    }
    me.lastProcessedTopRow = currentTopRow;
  }
  updateStickyContent() {
    const me = this,
      {
        currentTopRow,
        removeClasses
      } = me,
      rowClasses = {
        'b-grid-sticky-row': 1
      },
      cellClasses = {},
      stickyContent = me.stickyContent || (me.stickyContent = document.createDocumentFragment()),
      stickyEls = me.stickyEls || (me.stickyEls = []);
    // Release the sticky state on the previous row's sticky elements
    stickyEls.forEach(e => {
      e.classList.remove('b-sticky-content-el');
    });
    // Collect the elements we need to clone from the current top row
    stickyEls.length = 0;
    currentTopRow.eachElement(rowEl => {
      stickyEls.push(...rowEl.querySelectorAll(me.contentSelector));
    });
    // Clear the documentFragment which we use to hold our clones
    while (stickyContent.firstChild) {
      stickyContent.remove(stickyContent.firstChild);
    }
    me.stickyContentHeight = 0;
    me.stickyContentTop = 0;
    // Clone the selected elements and measure them for alignment.
    stickyEls.map(e => {
      // Collect the app classes that may be necessary on the cell and row elements.
      e.closest('.b-grid-cell').classList.forEach(cls => cellClasses[cls] = 1);
      e.closest('.b-grid-row').classList.forEach(cls => rowClasses[cls] = 1);
      // Clean out grid's classes from the class sets.
      Object.assign(cellClasses, removeClasses);
      Object.assign(rowClasses, removeClasses);
      const eTop = e.offsetTop;
      me.stickyContentTop = Math.max(me.stickyContentTop, eTop);
      // We need to know how tall the sticky content is
      e.style.alignSelf = 'flex-end';
      me.stickyContentHeight = Math.max(me.stickyContentHeight, me.currentTopRow.height - e.offsetTop + eTop);
      e.style.alignSelf = '';
      const result = e.cloneNode(true);
      // Tag the content al *after* cloning it.
      e.classList.add('b-sticky-content-el');
      stickyContent.appendChild(result);
      return result;
    });
    cellClasses['b-focused'] = false;
    DomHelper.syncClassList(me.contentElement, cellClasses);
    DomHelper.syncClassList(me.element, rowClasses);
    return stickyContent;
  }
}
StickyCells._$name = 'StickyCells';
GridFeatureManager.registerFeature(StickyCells, false);

/**
 * @module Grid/widget/TreeCombo
 */
/**
 * A powerful {@link Core/widget/Combo} box using a {@link Grid/view/TreeGrid} as its drop down widget. You can define
 * your own set of columns to display and use all the regular features of the Grid.
 *
 * {@inlineexample Grid/widget/TreeCombo.js}
 *
 * ```javascript
 * new TreeCombo({
 *     label    : 'Pick task(s)',
 *     width    : '30em',
 *     appendTo : document.body,
 *     picker   : {
 *         // Define the columns to show in the grid
 *         columns : [
 *             { type : 'tree', text : 'Tasks', field : 'name', flex : 1 },
 *             { text : 'Priority', field : 'prio' }
 *         ]
 *     },
 *     chipView : {
 *         // Render the chips in the combo field
 *         itemTpl(record) {
 *             return StringHelper.xss`${record.name}`;
 *         }
 *     },
 *     store : {
 *         fields     : [
 *             'prio'
 *         ],
 *         data : [
 *             {
 *                 name     : 'Development Tasks',
 *                 expanded : true,
 *                 children : [
 *                     { id : 1, name : 'Improve React docs', prio : 'High' },
 *                     { id : 2, name : 'Build Angular module', prio : 'Low' },
 *                     { id : 3, name : 'Creat Vue project', prio : 'Low' }
 *                 ]
 *             },
 *             { name : 'Customer meeting', prio : 'Normal' },
 *             {
 *                 name     : 'Customer Tasks',
 *                 expanded : true,
 *                 children : [
 *                     { id : 4, name : 'Intro meeting', prio : 'Normal' },
 *                     { id : 5, name : 'Build POC', prio : 'High' },
 *                     { id : 6, name : 'Documentation', prio : 'Low' }
 *                 ]
 *             }
 *         ]
 *     }
 * });
 * ```
 *
 * @extends Core/widget/Combo
 * @classtype treecombo
 * @inputfield
 */
class TreeCombo extends Combo {
  configure(config) {
    super.configure(config);
    const me = this;
    me.ion({
      change() {
        me.picker.selectedRecords = me.value;
      }
    });
  }
  changePicker(picker, oldPicker) {
    const me = this;
    return super.changePicker(ObjectHelper.assign({}, picker, {
      type: 'treegrid',
      minWidth: '35em',
      readOnly: me.readOnly,
      disableGridRowModelWarning: true,
      selectedRecords: me.value.map(val => me.store.getById(val)),
      selectionMode: {
        row: true,
        multiSelect: me.multiSelect,
        rowCheckboxSelection: true
      },
      internalListeners: {
        selectionChange({
          selection
        }) {
          me.value = selection;
        }
      }
    }), oldPicker);
  }
}
_defineProperty(TreeCombo, "$name", 'TreeCombo');
_defineProperty(TreeCombo, "type", 'treecombo');
_defineProperty(TreeCombo, "configurable", {
  multiSelect: true,
  chipView: {
    itemTpl(record) {
      return StringHelper.xss`${record.name}`;
    },
    scrollable: {
      overflowX: 'hidden-scroll'
    }
  }
});
TreeCombo.initClass();
TreeCombo._$name = 'TreeCombo';

export { ActionColumn, AggregateColumn, CellCopyPaste, CellTooltip, ColumnRename, FillHandle, MergeCells, PercentColumn, QuickFind, RatingColumn, RowExpander, Search, StickyCells, TemplateColumn, TimeColumn, TreeCombo };
//# sourceMappingURL=grid.module.thin.js.map
