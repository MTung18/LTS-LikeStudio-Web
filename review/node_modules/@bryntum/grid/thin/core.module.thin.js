/*!
 *
 * Bryntum Grid 5.3.0
 *
 * Copyright(c) 2023 Bryntum AB
 * https://bryntum.com/contact
 * https://bryntum.com/license
 *
 */
import { DomHelper, DateHelper, Events, Delayable, EventHelper, Rectangle, Widget, Combo, Store, Field, Container, Tooltip, Toolbar, _objectSpread2, BrowserHelper } from './chunks/Editor.js';
export { AjaxHelper, AjaxStore, Animator, ArrayDataField, ArrayHelper, AsyncHelper, Badge, Bag, Base, BooleanDataField, BrowserHelper, Button, ChipView, ClickRepeater, CollapseTool, Collection, CollectionFilter, CollectionSorter, Combo, Config, Container, ContextMenuBase, DataField, DateDataField, DateHelper, DayTime, Delayable, DomClassList, DomDataStore, DomHelper, DomSync, Duration, DynamicObject, Editor, EventHelper, Events, Factoryable, Field, FieldContainer, Fullscreen, FunctionHelper, GlobalEvents, IdHelper, Identifiable, InstancePlugin, IntegerDataField, KeyMap, Labelable, Layout, List, LoadMaskable, LocaleHelper, LocaleManagerSingleton as LocaleManager, Localizable, Mask, Menu, MenuItem, Model, ModelDataField, ModelLink, ModelStm, Navigator, NumberDataField, ObjectDataField, ObjectHelper, Objects, Panel, PanelCollapser, PickerField, Pluggable, Point, Popup, Promissory, RTL, Rectangle, Renderable, ResizeMonitor, Ripple, Rotatable, ScrollManager, Scroller, State, StateProvider, StateStorage, Store, StoreCRUD, StoreChained, StoreChanges, StoreDataField, StoreFilter, StoreGroup, StoreProxy, StoreRelation, StoreSearch, StoreSort, StoreState, StoreStm, StoreSum, StoreSync, StoreTree, StringDataField, StringHelper, TemplateHelper, TextField, TimeZoneHelper, Toast, Tool, Toolable, Toolbar, Tooltip, TreeNode, VersionHelper, WalkHelper, Wbs, Widget, unitMagnitudes } from './chunks/Editor.js';
export { ActionBase, AvatarRendering, DragContext, DragProxy, Draggable, Droppable, Finalizable, Override, StateBase, StateTrackingManager, Transaction, UpdateAction } from './chunks/AvatarRendering.js';
import { Checkbox } from './chunks/MessageDialog.js';
export { CalendarPanel, Checkbox, DateField, DatePicker, DisplayField, DragHelper, DurationField, FieldFilterPicker, FieldFilterPickerGroup, Formatter, Label, MessageDialog, Month, NumberField, NumberFormat, ResizeHelper, TimeField, TimePicker, WidgetHelper, YearPicker } from './chunks/MessageDialog.js';
import { RandomGenerator } from './chunks/TextAreaPickerField.js';
export { Parser, RandomGenerator, TextAreaPickerField, XMLHelper } from './chunks/TextAreaPickerField.js';
export { FieldSet, Radio, RadioGroup, Tab, TabBar, TabPanel, WebSocketManager } from './chunks/TabPanel.js';
export { Featureable, Fencible, FilterField, Responsive } from './chunks/Responsive.js';
export { DragTipProxy, Hoverable, Minifiable, PanelCollapserOverlay } from './chunks/Minifiable.js';
export { UndoRedoBase } from './chunks/UndoRedoBase.js';
export { ButtonGroup } from './chunks/ButtonGroup.js';
export { DateTimeField } from './chunks/Card.js';
export { Slider } from './chunks/Slider.js';
export { TextAreaField } from './chunks/TextAreaField.js';
export { Styleable } from './chunks/Styleable.js';
export { Histogram, Scale } from './chunks/Scale.js';

/**
 * @module Core/helper/CSSHelper
 */
/**
 * Provides methods to add and manipulate CSS style rules.
 *
 * Note that this class is incompatible with [CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)
 *
 * ```
 * this.criticalRule = CSSHelper.insertRule(`#${this.id} .b-sch-event.critical {background-color:${this.criticalColor}}`);
 * ```
 */
class CSSHelper {
  /**
   * Inserts a CSS style rule based upon the passed text
   * @param {String} cssText The text of the rule including selector and rule body just as it would
   * be specified in a CSS file.
   * @returns {CSSRule} The resulting CSS Rule object if the add was successful.
   */
  static insertRule(cssText, parentElement = document.head) {
    const styleSheet = this.getStyleSheet(parentElement),
      oldCount = styleSheet.cssRules.length;
    styleSheet.insertRule(cssText, 0);
    // Only return element zero if the add was successful.
    if (styleSheet.cssRules.length > oldCount) {
      return styleSheet.cssRules[0];
    }
  }
  /**
   * Looks up the first rule which matched the passed selector.
   * @param {String|Function} selector Either the selector string to exactly match or a function which
   * when passed a required selector, returns `true`.
   * @returns {CSSRule} The first matching CSS Rule object if any found.
   */
  static findRule(selector) {
    let result;
    const isFn = typeof selector === 'function';
    // Array#find will stop when the function returns true, stop when the inner
    // find call yields a value from the search string.
    // Array#find better: to http://www.andygup.net/fastest-way-to-find-an-item-in-a-javascript-array/
    Array.prototype.find.call(document.head.querySelectorAll('link[rel=stylesheet],style[type*=css]'), element => {
      result = Array.prototype.find.call(element.sheet.rules || element.sheet.cssRules, r => {
        return isFn ? selector(r) : r.selectorText === selector;
      });
      if (result) {
        return true;
      }
    });
    return result;
  }
  static getStyleSheet(parentElement = document.head) {
    if (!parentElement.$bryntumStylesheet) {
      parentElement.$bryntumStylesheet = DomHelper.createElement({
        tag: 'style',
        id: 'bryntum-private-styles',
        // no-sanity
        type: 'text/css',
        parent: parentElement
      }).sheet;
    }
    return parentElement.$bryntumStylesheet;
  }
}
CSSHelper._$name = 'CSSHelper';

/**
 * @module Core/helper/util/DataGenerator
 */
const lorem = ['Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.', 'Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.', 'Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.', 'Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.', 'Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo.', 'Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui atione voluptatem sequi nesciunt.', 'Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem.', 'Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur?', 'Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?'];
/**
 * Generates a pseudo random data for Grid records.
 * Used to provide data in examples.
 */
class DataGenerator {
  //region Random
  static reset() {
    this.rnd.reset();
    this.rndTime.reset();
    this.rndRating.reset();
  }
  //endregion
  //region Generate data
  static *generate(count, randomHeight = false, initialId = 1) {
    let addSkills, rowCallback;
    if (typeof count === 'object') {
      var _count$initialId;
      randomHeight = count.randomHeight;
      initialId = (_count$initialId = count.initialId) !== null && _count$initialId !== void 0 ? _count$initialId : 1;
      addSkills = count.addSkills;
      rowCallback = count.rowCallback;
      count = count.count;
    }
    const me = this,
      {
        rnd,
        rndTime,
        rndRating,
        rndText,
        firstNames,
        surNames,
        teams,
        foods,
        colors,
        cities,
        skills
      } = me;
    for (let i = 0; i < count; i++) {
      var _rowCallback;
      const firstName = rnd.fromArray(firstNames),
        surName = rnd.fromArray(surNames),
        name = `${firstName} ${String.fromCharCode(65 + i % 25)} ${surName}`,
        startDay = rnd.nextRandom(60) + 1,
        start = new Date(2019, 0, startDay),
        finish = new Date(2019, 0, startDay + rnd.nextRandom(30) + 2),
        row = {
          id: initialId > -1 ? i + initialId : undefined,
          title: 'Row ' + i,
          name,
          firstName,
          surName,
          city: rnd.fromArray(cities),
          team: rnd.fromArray(cities) + ' ' + rnd.fromArray(teams),
          age: 10 + rnd.nextRandom(80),
          food: rnd.fromArray(foods),
          color: rnd.fromArray(colors),
          score: rnd.nextRandom(100) * 10,
          rank: rnd.nextRandom(100) + 1,
          start,
          finish,
          time: DateHelper.getTime(rndTime.nextRandom(24), rndTime.nextRandom(12) * 5),
          percent: rnd.nextRandom(100),
          done: rnd.nextRandom(100) < 50,
          rating: rndRating.nextRandom(5),
          relatedTo: Math.min(count - 1, i + initialId + rnd.nextRandom(10)),
          notes: lorem[rndText.nextRandom(7) + 1]
        };
      if (addSkills) {
        row.skills = rnd.randomArray(skills, 7);
      }
      const additionalData = (_rowCallback = rowCallback) === null || _rowCallback === void 0 ? void 0 : _rowCallback(row);
      additionalData && Object.assign(row, additionalData);
      if (randomHeight) {
        row.rowHeight = rnd.nextRandom(randomHeight === true ? 20 : randomHeight) * 5 + 20;
      }
      yield row;
    }
  }
  /**
   * Generates a pseudo random dataset. Used in Grid examples.
   * @param {Number|Object} count number of records, or an object with properties:
   * @param {Boolean} [count.randomHeight] Generate random row height
   * @param {Boolean} [count.initialId] Row initial id. Set -1 to disable Id generation. Defaults to 1.
   * @param {Boolean} [count.reset] Set true to ensure we get the same dataset on consecutive calls. Defaults to true
   * @param {Boolean} [count.rowCallback] A callback called for each row to allow appending extra data, returned data in
   * object form will be applied to the generated data
   * @param {Boolean} [count.addSkills] Add skills to the dataset
   * @param {Boolean} [randomHeight] Generate random row height
   * @param {Number} [initialId] Row initial id. Set -1 to disable Id generation. Defaults to 1.
   * @param {Boolean} [reset] Set true to ensure we get the same dataset on consecutive calls. Defaults to true
   * @returns {Object[]} Generated rows array
   */
  static generateData(count, randomHeight = false, initialId = 1, reset = true) {
    let args = count;
    if (typeof count !== 'object') {
      args = {
        count,
        randomHeight,
        initialId,
        reset
      };
    }
    args.reset !== false && this.reset();
    if (DataGenerator.overrideRowCount) {
      args.count = DataGenerator.overrideRowCount;
    }
    const rows = [],
      generator = this.generate(args);
    for (let i = 0; i < args.count; i++) {
      rows.push(generator.next().value);
    }
    return rows;
  }
  /**
   * Generates a dataset of events
   * @returns {Object[]}
   */
  static generateEvents({
    viewStartDate,
    viewEndDate,
    nbrResources = 50,
    nbrEvents = 5,
    dependencies,
    tickUnit = 'days',
    minDuration = 2,
    maxDuration = 10
  }) {
    const resources = this.generateData(nbrResources),
      events = [];
    dependencies = [];
    for (let i = 0; i < nbrResources; i++) {
      for (let j = 0; j < nbrEvents; j++) {
        const visibleDuration = DateHelper.getDurationInUnit(viewStartDate, viewEndDate, tickUnit),
          startDate = DateHelper.add(viewStartDate, Math.round(Math.random() * 0.9 * visibleDuration), tickUnit),
          duration = Math.round(Math.random() * (maxDuration - minDuration)) + minDuration,
          endDate = DateHelper.add(startDate, duration, 'days'),
          eventId = events.length + 1;
        events.push({
          id: eventId,
          name: this.tasks[(i + j) % (this.tasks.length - 1)],
          startDate,
          duration,
          endDate,
          resourceId: i
        });
        if (dependencies && i > 0) {
          dependencies.push({
            id: dependencies.length + 1,
            from: eventId - 1,
            to: eventId
          });
        }
      }
    }
    return {
      resources,
      events,
      dependencies
    };
  }
  /**
   * Generates pseudo random data for a Grid row.
   * @returns {Object} Generated row
   */
  static generateRow() {
    return DataGenerator.generateData(1, false, -1, false)[0];
  }
  //endregion
}

Object.assign(DataGenerator, {
  rnd: new RandomGenerator(),
  rndTime: new RandomGenerator(),
  rndRating: new RandomGenerator(),
  rndText: new RandomGenerator(),
  cities: ['Stockholm', 'Barcelona', 'Paris', 'Dubai', 'New York', 'San Francisco', 'Washington', 'Moscow'],
  firstNames: ['Mike', 'Linda', 'Don', 'Karen', 'Doug', 'Jenny', 'Daniel', 'Melissa', 'John', 'Jane', 'Theo', 'Lisa', 'Adam', 'Mary', 'Barbara', 'James', 'David'],
  surNames: ['McGregor', 'Ewans', 'Scott', 'Smith', 'Johnson', 'Adams', 'Williams', 'Brown', 'Jones', 'Miller', 'Davis', 'More', 'Wilson', 'Taylor', 'Anderson', 'Thomas', 'Jackson'],
  teams: ['Lions', 'Eagles', 'Tigers', 'Horses', 'Dogs', 'Cats', 'Panthers', 'Rats', 'Ducks', 'Cougars', 'Hens', 'Roosters'],
  foods: ['Pancake', 'Burger', 'Fish n chips', 'Carbonara', 'Taco', 'Salad', 'Bolognese', 'Mac n cheese', 'Waffles'],
  colors: ['Blue', 'Green', 'Red', 'Yellow', 'Pink', 'Purple', 'Orange', 'Teal', 'Black'],
  skills: ['JavaScript', 'CSS', 'TypeScript', 'React', 'Vue', 'Angular', 'Java', 'PHP', 'Python', 'C#', 'C++', 'BASIC', 'COBOL', 'FORTRAN', 'PASCAL', 'SQL'],
  tasks: ['Meetings', 'Documentation', 'Email communication', 'Project management', 'Budgeting', 'Marketing and advertising', 'Customer service', 'Research and analysis', 'Data entry', 'IT support', 'Employee management', 'Sales and business development', 'Event planning', 'Graphic design', 'Writing and editing', 'Presentation', 'Travel arrangements and expense management', 'Training and development', 'Quality assurance', 'Customer support', 'Technical writing', 'Social media management', 'Translation', 'Legal research', 'Data analysis and visualization', 'Video editing and production', 'Network admin', 'Content creation', 'Market research', 'Public relations', 'Teaching and training', 'Recruiting', 'Product development']
});
DataGenerator._$name = 'DataGenerator';

const knownProps = ['action', 'target', 'to', 'deltaX', 'deltaY', 'x', 'y', 'text'];
class DemoBot extends Events(Delayable()) {
  static get defaultConfig() {
    return {
      repeat: true,
      outerElement: document.body,
      callOnFunctions: true
    };
  }
  // expects an outer element (grid.element/scheduler.element) and an array of steps similar to chain steps in siesta
  construct(config) {
    super.construct(config);
    const me = this;
    if (me.widget) {
      me.outerElement = me.widget.element;
      me.widget.playingDemo = true;
    }
    EventHelper.playingDemo = true;
    Object.assign(me, {
      prevTarget: null,
      currentStep: 0,
      mouse: DomHelper.createElement({
        parent: me.outerElement,
        tag: 'div',
        className: 'simulated-mouse'
      }),
      timeoutId: null,
      innerIntervalId: null,
      mouseOutElements: []
    });
    me.intervalId = me.setInterval(me.nextStep.bind(me), 1000);
    me.outerElement.classList.add('b-playing-demo');
    me.outerElement.addEventListener('click', event => {
      if (event.isTrusted) {
        me.abort();
      }
    });
  }
  doDestroy() {
    this.abort();
  }
  // stops the bot
  abort(atEnd = false) {
    const me = this;
    me.mouse.style.top = '-100px';
    me.clearInterval(me.intervalId);
    me.timeoutId && me.clearTimeout(me.timeoutId);
    me.innerIntervalId && me.clearInterval(me.innerIntervalId);
    me.outerElement.classList.remove('b-playing-demo');
    if (me.widget) {
      me.widget.playingDemo = false;
    }
    EventHelper.playingDemo = false;
    me.trigger(atEnd ? 'done' : 'abort');
  }
  // triggers a synthetic event
  triggerEvent(element, type, data) {
    if (!element) return null;
    let event;
    if (type.startsWith('mouse')) {
      const box = this.mouse.getBoundingClientRect();
      event = new MouseEvent(type, Object.assign({
        view: globalThis,
        bubbles: true,
        cancelable: true,
        clientX: box.left,
        clientY: box.top
      }, data || {}));
    } else {
      event = document.createEvent('Event');
      event.initEvent(type, true, false);
    }
    element.dispatchEvent(event);
    return event;
  }
  // moves mouse to target in 10 steps, with animated transition between steps
  handleMouseMove(step, target) {
    const me = this,
      mouse = me.mouse;
    mouse.classList.add('quick');
    if (me.mouseDown) mouse.classList.add('drag');
    const mouseBox = Rectangle.from(mouse, me.outerElement),
      x = mouseBox.x,
      y = mouseBox.y;
    let deltaX = 0,
      deltaY = 0;
    if (step.to) {
      if (typeof step.to === 'string') {
        const toElement = me.outerElement.querySelector(step.to);
        if (toElement) {
          const rect = Rectangle.from(toElement, me.outerElement),
            toX = rect.x + rect.width / 2,
            toY = rect.y + rect.height / 2;
          deltaX = (toX - x) / 10;
          deltaY = (toY - y) / 10;
        }
      } else if (step.to.x) {
        deltaX = (step.to.x - x) / 10;
      } else {
        deltaX = step.to[0] / 10;
        deltaY = step.to[1] / 10;
      }
    } else if (step.deltaX) {
      deltaX = step.deltaX / 10;
    } else if (step.x) {
      deltaX = (step.x - x) / 10;
    }
    if (step.deltaY) {
      deltaY = step.deltaY / 10;
    }
    let i = 0;
    me.innerIntervalId = me.setInterval(() => {
      // Only move mouse if in view and not scrolling
      if (me.shouldPause) {
        return;
      }
      if (i++ === 9) {
        clearInterval(me.innerIntervalId);
        if (step.then) {
          step.then();
        }
      }
      const mouseX = x + deltaX * i,
        mouseY = y + deltaY * i;
      // Move mouse there also
      mouse.style.left = mouseX + 'px';
      mouse.style.top = mouseY + 'px';
      const mouseBounds = mouse.getBoundingClientRect(),
        clientX = mouseBounds.left,
        clientY = mouseBounds.top,
        eventTarget = DomHelper.elementFromPoint(clientX, clientY);
      if (eventTarget !== me.prevTarget) {
        if (me.prevTarget) {
          me.mouseOutElements.push(me.prevTarget);
          if (!DomHelper.isDescendant(me.mouseOutElements[0], eventTarget)) {
            me.mouseOutElements.forEach(element => me.triggerEvent(element, 'mouseout'));
            me.mouseOutElements.length = 0;
          }
        }
        me.prevTarget = eventTarget;
        me.triggerEvent(eventTarget, 'mouseover');
      }
      me.triggerEvent(eventTarget, step.action, {
        clientX,
        clientY
      });
    }, 50);
  }
  // target can be a string selector, a function or blank to use last target or outerElement if first time
  getTarget(step) {
    const me = this,
      target = step.target;
    if (!target) {
      return me.prevTarget || me.outerElement;
    }
    if (typeof target === 'function') {
      return target(step);
    }
    return document.querySelector(target);
  }
  // action can be a function, a string or extracted from a property by scanning for unknown names
  normalizeStep(step) {
    if (step.action) {
      if (typeof step.action === 'function') {
        return step.action(step);
      }
      return step;
    }
    if (typeof step === 'function') {
      step();
      return step;
    }
    // try to find action among properties
    for (const prop in step) {
      if (Object.hasOwnProperty.call(step, prop) && !knownProps.includes(prop)) {
        step.action = prop.toLowerCase();
        step.to = step[prop];
      }
    }
    if (!step.target && (typeof step.to === 'string' || typeof step.to === 'function')) step.target = step.to;
    return step;
  }
  get isScrolling() {
    const me = this,
      box = me.outerElement.getBoundingClientRect(),
      scrolled = me.lastTop && box.top !== me.lastTop;
    me.lastTop = box.top;
    return scrolled;
  }
  get isInView() {
    const box = this.outerElement.getBoundingClientRect();
    return box.top < globalThis.innerHeight && box.bottom > 0;
  }
  get shouldPause() {
    return !this.isInView || this.isScrolling || document.hidden || !document.hasFocus();
  }
  // process the next step
  nextStep() {
    const me = this;
    // Only perform step if in view and not scrolling
    if (me.shouldPause) {
      return;
    }
    if (me.currentStep === me.steps.length) {
      if (me.repeat) {
        me.currentStep = 0;
      } else {
        return me.abort(true);
      }
    }
    // First step, signal to let demo initialize stuff
    if (me.currentStep === 0) {
      me.trigger('initialize');
    }
    const mouse = me.mouse,
      step = me.normalizeStep(me.steps[me.currentStep++]),
      target = me.getTarget(step),
      action = step.action;
    if (target && action) {
      mouse.className = 'simulated-mouse';
      if (action === 'mousemove') {
        me.handleMouseMove(step, target);
      } else {
        // First move mouse into position
        if (target !== me.prevTarget) {
          const rect = Rectangle.from(target, me.outerElement);
          mouse.style.left = rect.x + rect.width / 2 + 'px';
          mouse.style.top = rect.y + rect.height / 2 + 'px';
        }
        if (action === 'mousedown') {
          me.mouseDown = true;
        }
        if (action === 'mouseup') {
          me.mouseDown = false;
        }
        // Then trigger action
        me.timeoutId = me.setTimeout(() => {
          me.prevTarget = target;
          // Animate click etc.
          mouse.classList.add(action);
          if (action === 'type') {
            const field = Widget.fromElement(target),
              parts = step.text.split('|');
            field.value = parts[parts.length === 1 || field.value != parts[0] ? 0 : 1];
          } else {
            me.triggerEvent(target, action);
          }
        }, action === 'type' ? 100 : 550);
      }
    }
  }
}
DemoBot._$name = 'DemoBot';

/**
 * @module Core/widget/BooleanCombo
 * Boolean combo, a combo box with two options corresponding to true or false.
 *
 * This field can be used as an {@link Grid/column/Column#config-editor} for the {@link Grid/column/Column}.
 *
 * @classType booleancombo
 * @extends Core/widget/Combo
 * @widget
 */
class BooleanCombo extends Combo {
  static get $name() {
    return 'BooleanCombo';
  }
  static get type() {
    return 'booleancombo';
  }
  //region Config
  static get configurable() {
    return {
      /**
       * Positive option value
       *
       * @config {*}
       */
      positiveValue: true,
      /**
       * Positive option display value
       *
       * @config {String}
       */
      positiveText: null,
      /**
       * Negative option value
       *
       * @config {*}
       */
      negativeValue: false,
      /**
       * False option display value
       *
       * @config {String}
       */
      negativeText: null,
      store: {
        value: [],
        $config: 'lazy'
      },
      /**
       * Default value
       *
       * @config {*}
       */
      value: false
    };
  }
  //endregion
  changeStore(store, oldStore) {
    const me = this;
    // We must call super.changeStore() in order to deduce valueField. We also cannot just pass an array since it
    // will convert to a store and call back here (infinite recursion).
    return super.changeStore(new Store({
      data: [{
        id: me.positiveValue,
        text: me.positiveText || me.L('L{Object.Yes}')
      }, {
        id: me.negativeValue,
        text: me.negativeText || me.L('L{Object.No}')
      }]
    }), oldStore);
  }
}
// Register this widget type with its Factory
BooleanCombo.initClass();
BooleanCombo._$name = 'BooleanCombo';

/**
 * @module Core/widget/FileField
 */
/**
 * FileField widget. Wraps native &lt;input type="file"&gt;.
 *
 * {@inlineexample Core/widget/FileField.js vertical}
 *
 * There is a nicer styled wrapper for this field, see {@link Core/widget/FilePicker}
 *
 * @extends Core/widget/Field
 * @classType filefield
 * @inputfield
 */
class FileField extends Field {
  static get $name() {
    return 'FileField';
  }
  // Factoryable type name
  static get type() {
    return 'filefield';
  }
  static get configurable() {
    return {
      /**
       * Set to true to allow picking multiple files. Note that when set to a truthy value,
       * the field is set to accept multiple files, but the value returned will be
       * an empty string since this is what is rendered into the HTML.
       * @config {Boolean}
       * @default
       */
      multiple: null,
      /**
       * Comma-separated list of file extensions or MIME type to to accept. E.g.
       * ".jpg,.png,.doc" or "image/*". Null by default, allowing all files.
       * @config {String}
       */
      accept: null,
      inputType: 'file',
      attributes: ['multiple', 'accept']
    };
  }
  /**
   * Returns list of selected files
   * @property {FileList}
   * @readonly
   */
  get files() {
    return this.input.files;
  }
  /**
   * Opens browser file picker
   * @internal
   */
  pickFile() {
    this.input.click();
  }
  get multiple() {
    return this._multiple ? '' : null;
  }
  /**
   * Clears field value
   */
  clear() {
    this.input.value = null;
  }
  triggerChange(event) {
    this.triggerFieldChange({
      event,
      value: this.input.value,
      oldValue: this._lastValue,
      userAction: true,
      valid: true
    });
  }
}
// Register this widget type with its Factory
FileField.initClass();
FileField._$name = 'FileField';

/**
 * @module Core/widget/FilePicker
 */
/**
 * File input field wrapped into {@link Core/widget/Button button}. Clicking button opens browser file picker window.
 * When files are chosen, badge appears showing amount of files. Hovering the button shows tip with file names.
 *
 * By default only single file allowed.
 *
 * @extends Core/widget/Container
 * @example
 *
 * let fileField = new FilePicker({
 *   fileFieldConfig : {
 *      multiple : true,
 *      accept   : "image/*"
 *   },
 *   buttonConfig : {
 *       text : 'Pick file...'
 *   },
 *   onChange({ files }) {
 *       // Do cool things
 *   }
 * });
 *
 * @classType filepicker
 * @inlineexample Core/widget/FilePicker.js
 * @widget
 */
class FilePicker extends Container {
  static get $name() {
    return 'FilePicker';
  }
  // Factoryable type name
  static get type() {
    return 'filepicker';
  }
  static get defaultConfig() {
    return {
      /**
       * The name of the property to set when a single value is to be applied to this FilePicker. Such as when used
       * in a grid WidgetColumn, this is the property to which the column's `field` is applied.
       * @config {String}
       * @default
       * @category Misc
       */
      defaultBindProperty: 'value',
      /**
       * Fires after user closes file picker dialog.
       * @event change
       * @param {FileList} files List of picked files
       */
      /**
       * Fires when field is cleared with {@link #function-clear} method
       * @event clear
       */
      /**
       * Wrapper button config object. See {@link Core/widget/Button} for list of available configs.
       * @config {ButtonConfig}
       */
      buttonConfig: null,
      /**
       * Underlying field config object. See {@link Core/widget/FileField} for list of available configs.
       * @config {FileFieldConfig}
       */
      fileFieldConfig: null
    };
  }
  construct(config = {}) {
    const me = this;
    config.items = [Object.assign({
      type: 'button',
      ref: 'fileButton',
      text: 'L{FilePicker.file}',
      localeClass: this
    }, config.buttonConfig), Object.assign({
      type: 'filefield',
      ref: 'fileField',
      style: 'display: none'
    }, config.fileFieldConfig)].concat(config.items || []);
    super.construct(config);
    me.button.ion({
      click: me.onButtonClick,
      thisObj: me
    });
    me.fileField.ion({
      change: me.onFileFieldChange,
      thisObj: me
    });
    me._thisIsAUsedExpression(me.fileTip);
  }
  get button() {
    return this.widgetMap.fileButton;
  }
  get fileField() {
    return this.widgetMap.fileField;
  }
  /**
   * List of selected files
   * @property {FileList}
   * @readonly
   */
  get files() {
    return this.fileField.files;
  }
  get fileTip() {
    const me = this;
    return me._fileTip || (me._fileTip = new Tooltip({
      cls: 'b-file-tip',
      forElement: me.button.element,
      showOnHover: true,
      align: 'b-t',
      scrollAction: 'realign',
      internalListeners: {
        beforeshow() {
          const tip = this,
            files = me.files;
          if (files && files.length) {
            tip.html = `${Array.from(files).map(file => file.name).join('<br>')}`;
            return true;
          }
          // Veto show
          return false;
        }
      }
    }));
  }
  /**
   * Clears field
   */
  clear() {
    const me = this;
    me.fileField.clear();
    me.button.badge = '';
    me.trigger('clear');
  }
  onButtonClick({
    event
  }) {
    const me = this;
    // forward click to the file input to open browser file picker
    // me.fileField.input.click();
    me.fileField.pickFile();
    event.preventDefault();
  }
  onFileFieldChange({
    valid
  }) {
    const me = this;
    me.button.badge = me.files.length || '';
    me.triggerFieldChange({
      files: me.files,
      valid
    });
  }
}
// Register this widget type with its Factory
FilePicker.initClass();
FilePicker._$name = 'FilePicker';

/**
 * @module Core/widget/PagingToolbar
 */
/**
 * A special Toolbar class, which, when attached to an {@link Core.data.AjaxStore}, which has been configured to be
 * {@link Core.data.AjaxStore#property-isPaged paged}, controls the loading of that store to page through the data set.
 *
 * ```javascript
 * new Grid({
 *      bbar : {
 *          type  : 'pagingtoolbar'
 *      }
 * });
 * ```
 *
 * {@inlineexample Core/widget/PagingToolbar.js}
 *
 * ### Default toolbar items
 *
 * The toolbar provides some default buttons and other items as described below:
 *
 * | Reference              | Weight | Description                                              |
 * |------------------------|--------|---------------------------------------------------------|
 * | `firstPageButton`      | 100    | Go to first page                                        |
 * | `previousPageButton`   | 110    | Go to previous page                                     |
 * | `pageNumber`           | 120    | TextCurrent page number                                 |
 * | `pageCount`            | 130    | Label showing number of pages                           |
 * | `nextPageButton`       | 140    | Go to next page                                         |
 * | `lastPageButton`       | 150    | Go to last page                                         |
 * | `reloadButton`         | 160    | Reload data                                             |
 * | `dataSummary`          | 170    | Summary text                                            |
 *
 * ### Customizing the toolbar items
 *
 * The toolbar items can be customized, existing items can be changed or removed,
 * and new items can be added. This is handled using the {@link #config-items} config.
 *
 * Adding additional buttons or widgets to the paging toolbar can be done like so:
 *
 * ```javascript
 * bbar : {
 *     type  : 'pagingtoolbar',
 *     items : {
 *         click : {
 *             type : 'button',
 *             text : 'Click me',
 *             weight : 175 // Add after last item
 *         }
 *     }
 * }
 * ```
 *
 * @demo Grid/paged
 * @extends Core/widget/Toolbar
 * @classType pagingtoolbar
 */
class PagingToolbar extends Toolbar {
  static get $name() {
    return 'PagingToolbar';
  }
  // Factoryable type name
  static get type() {
    return 'pagingtoolbar';
  }
  static get defaultConfig() {
    return {
      /**
       * The {@link Core.data.AjaxStore AjaxStore} that this PagingToolbar is to control.
       * @config {Core.data.AjaxStore}
       */
      store: null,
      defaults: {
        localeClass: this
      },
      items: {
        firstPageButton: {
          onClick: 'up.onFirstPageClick',
          icon: 'b-icon-first',
          weight: 100,
          tooltip: 'L{PagingToolbar.firstPage}'
        },
        previousPageButton: {
          onClick: 'up.onPreviousPageClick',
          icon: 'b-icon-previous',
          weight: 110,
          tooltip: 'L{PagingToolbar.prevPage}'
        },
        pageNumber: {
          type: 'numberfield',
          label: 'L{page}',
          min: 1,
          max: 1,
          triggers: null,
          onChange: 'up.onPageNumberChange',
          highlightExternalChange: false,
          weight: 120
        },
        pageCount: {
          type: 'widget',
          cls: 'b-pagecount b-toolbar-text',
          weight: 130
        },
        nextPageButton: {
          onClick: 'up.onNextPageClick',
          icon: 'b-icon-next',
          weight: 140,
          tooltip: 'L{PagingToolbar.nextPage}'
        },
        lastPageButton: {
          onClick: 'up.onLastPageClick',
          icon: 'b-icon-last',
          weight: 150,
          tooltip: 'L{PagingToolbar.lastPage}'
        },
        separator: {
          type: 'widget',
          cls: 'b-toolbar-separator',
          weight: 151
        },
        reloadButton: {
          onClick: 'up.onReloadClick',
          icon: 'b-icon-reload',
          weight: 160,
          tooltip: 'L{PagingToolbar.reload}'
        },
        spacer: {
          type: 'widget',
          cls: 'b-toolbar-fill',
          weight: 161
        },
        dataSummary: {
          type: 'widget',
          cls: 'b-toolbar-text',
          weight: 170
        }
      }
    };
  }
  // Retrieve store from grid when "assigned" to it
  set parent(parent) {
    super.parent = parent;
    if (!this.store) {
      this.store = parent.store;
    }
  }
  get parent() {
    return super.parent;
  }
  set store(store) {
    const me = this;
    me.detachListeners('store');
    me._store = store;
    if (store) {
      store.ion({
        name: 'store',
        beforerequest: 'onStoreBeforeRequest',
        afterrequest: 'onStoreChange',
        change: 'onStoreChange',
        thisObj: me
      });
      if (store.isLoading) {
        me.onStoreBeforeRequest();
      }
    }
  }
  get store() {
    return this._store;
  }
  onStoreBeforeRequest() {
    this.eachWidget(w => w.disable());
  }
  updateLocalization() {
    this.updateSummary();
    super.updateLocalization();
  }
  updateSummary() {
    const me = this,
      {
        pageCount,
        dataSummary
      } = me.widgetMap;
    let count = 0,
      lastPage = 0,
      start = 0,
      end = 0,
      allCount = 0;
    if (me.store) {
      const {
          store
        } = me,
        {
          pageSize,
          currentPage
        } = store;
      count = store.count;
      lastPage = store.lastPage;
      allCount = store.allCount;
      start = Math.max(0, (currentPage - 1) * pageSize + 1);
      end = Math.min(allCount, start + pageSize - 1);
    }
    pageCount.html = me.L('L{pageCountTemplate}')({
      lastPage
    });
    dataSummary.html = count ? me.L('L{summaryTemplate}')({
      start,
      end,
      allCount
    }) : me.L('L{noRecords}');
  }
  onStoreChange() {
    const me = this,
      {
        widgetMap,
        store
      } = me,
      {
        count,
        lastPage,
        currentPage
      } = store,
      {
        pageNumber,
        pageCount,
        firstPageButton,
        previousPageButton,
        nextPageButton,
        lastPageButton,
        dataSummary
      } = widgetMap;
    me.eachWidget(w => w.enable());
    pageNumber.value = currentPage;
    pageNumber.max = lastPage;
    dataSummary.disabled = pageNumber.disabled = pageCount.disabled = !count;
    firstPageButton.disabled = previousPageButton.disabled = currentPage <= 1 || !count;
    nextPageButton.disabled = lastPageButton.disabled = currentPage >= lastPage || !count;
    me.updateSummary();
  }
  onPageNumberChange({
    value
  }) {
    if (this.store.currentPage !== value) {
      this.store.loadPage(value);
    }
  }
  onFirstPageClick() {
    this.store.loadPage(1);
  }
  onPreviousPageClick() {
    this.store.previousPage();
  }
  onNextPageClick() {
    this.store.nextPage();
  }
  onLastPageClick() {
    this.store.loadPage(this.store.lastPage);
  }
  onReloadClick() {
    this.store.loadPage(this.store.currentPage);
  }
}
// Register this widget type with its Factory
PagingToolbar.initClass();
PagingToolbar._$name = 'PagingToolbar';

/**
 * @module Core/widget/PasswordField
 */
/**
 * Password field widget. Wraps native &lt;input type="password"&gt;
 *
 * ```javascript
 * let textField = new PasswordField({
 *     placeholder : 'Enter password'
 * });
 * ```
 *
 * {@inlineexample Core/widget/PasswordField.js}
 * @classType passwordfield
 * @extends Core/widget/Field
 * @inputfield
 */
class PasswordField extends Field {
  // Factoryable type name
  static get type() {
    return 'passwordfield';
  }
  // Factoryable type alias
  static get alias() {
    return 'password';
  }
  static get $name() {
    return 'PasswordField';
  }
  construct(config = {}) {
    config.inputType = 'password';
    super.construct(...arguments);
    this.element.classList.add('b-textfield');
  }
}
// Register this widget type with its Factory
PasswordField.initClass();
PasswordField._$name = 'PasswordField';

/**
 * @module Core/widget/SlideToggle
 */
/**
 * SlideToggle field is a variation of {@link Core.widget.Checkbox} with a sliding toggle instead of box with check mark.
 * It wraps <code>&lt;input type="checkbox"&gt;</code>.
 * Color can be specified and you can optionally configure {@link #config-text} to display in a label to the right of
 * the toggle in addition to a standard field {@link #config-label}.
 *
 * {@inlineexample Core/widget/SlideToggle.js vertical}
 *
 * This field can be used as an {@link Grid.column.Column#config-editor} for the {@link Grid.column.Column}.
 *
 * @extends Core/widget/Checkbox
 * @classType slidetoggle
 * @inputfield
 */
class SlideToggle extends Checkbox {
  static get $name() {
    return 'SlideToggle';
  }
  static get type() {
    return 'slidetoggle';
  }
  static get properties() {
    return {
      toggledCls: 'b-slidetoggle-checked'
    };
  }
  construct(config) {
    if (config !== null && config !== void 0 && config.checked) {
      config.cls = (config.cls || '') + ' ' + this.constructor.properties.toggledCls;
    }
    super.construct(config);
  }
  get innerElements() {
    const innerEls = super.innerElements;
    innerEls.splice(1, 0, this.toggleElement);
    if (this.text) {
      innerEls[innerEls.length - 1].class = 'b-slidetoggle-label';
    } else {
      // Remove label, not used
      innerEls.pop();
    }
    return innerEls;
  }
  get toggleElement() {
    return {
      class: 'b-slidetoggle-toggle',
      reference: 'slideToggle',
      children: [{
        class: 'b-slidetoggle-thumb',
        reference: 'slideThumb'
      }]
    };
  }
  internalOnChange() {
    super.internalOnChange();
    this.element.classList[this.value ? 'add' : 'remove'](this.toggledCls);
  }
}
SlideToggle.initClass();
SlideToggle._$name = 'SlideToggle';

/**
 * @module Core/widget/Splitter
 */
const classesHV = ['b-horizontal', 'b-vertical'],
  hasFlex = el => DomHelper.getStyleValue(el.parentElement, 'display') === 'flex' && (parseInt(DomHelper.getStyleValue(el, 'flex-basis'), 10) || parseInt(DomHelper.getStyleValue(el, 'flex-grow'), 10)),
  verticality = {
    horizontal: false,
    vertical: true
  };
/**
 * A simple splitter widget that resizes the elements next to it or above/below it depending on orientation.
 *
 * @extends Core/widget/Widget
 * @classType splitter
 * @inlineexample Core/widget/Splitter.js
 * @widget
 */
class Splitter extends Widget {
  //region Config
  static get $name() {
    return 'Splitter';
  }
  // Factoryable type name
  static get type() {
    return 'splitter';
  }
  static get configurable() {
    return {
      /**
       * Fired when a drag starts
       * @event dragStart
       * @param {Core.widget.Splitter} source The Splitter
       * @param {MouseEvent|TouchEvent} event The DOM event
       */
      /**
       * Fired while dragging
       * @event drag
       * @param {Core.widget.Splitter} source The Splitter
       * @param {MouseEvent|TouchEvent} event The DOM event
       */
      /**
       * Fired after a drop
       * @event drop
       * @param {Core.widget.Splitter} source The Splitter
       * @param {MouseEvent|TouchEvent} event The DOM event
       */
      /**
       * Splitter orientation, see {@link #config-orientation}. When set to 'auto' then actually used orientation
       * can be retrieved using {@link #property-currentOrientation}.
       * @member {'auto'|'horizontal'|'vertical'} orientation
       * @readonly
       */
      /**
       * The splitters orientation, configurable with 'auto', 'horizontal' or 'vertical'.
       *
       * 'auto' tries to determine the orientation by either checking the `flex-direction` of the parent element
       * or by comparing the positions of the closest sibling elements to the splitter. If they are above and
       * below 'horizontal' is used, if not it uses 'vertical'.
       *
       * ```
       * new Splitter({
       *    orientation : 'horizontal'
       * });
       * ```
       *
       * To receive the actually used orientation when configured with 'auto', see
       * {@link #property-currentOrientation}.
       *
       * @config {'auto'|'horizontal'|'vertical'}
       * @default
       */
      orientation: 'auto',
      vertical: null,
      containerElement: {
        $config: 'nullify',
        value: null
      },
      nextNeighbor: {
        $config: 'nullify',
        value: null
      },
      previousNeighbor: {
        $config: 'nullify',
        value: null
      }
    };
  }
  static get delayable() {
    return {
      syncState: 'raf'
    };
  }
  //endregion
  //region Init & destroy
  doDestroy() {
    var _this$mouseDetacher;
    (_this$mouseDetacher = this.mouseDetacher) === null || _this$mouseDetacher === void 0 ? void 0 : _this$mouseDetacher.call(this);
    super.doDestroy();
  }
  //endregion
  //region Template & element
  compose() {
    return {
      class: {
        'b-splitter': 1
      },
      listeners: _objectSpread2({
        pointerdown: 'onMouseDown',
        mouseenter: 'syncState'
      }, !BrowserHelper.supportsPointerEvents && {
        mousedown: 'onMouseDown',
        touchstart: 'onMouseDown'
      })
    };
  }
  //endregion
  //region Orientation
  /**
   * Get actually used orientation, which is either the configured value for `orientation` or if configured with
   * 'auto' the currently used orientation.
   * @property {String}
   * @readonly
   */
  get currentOrientation() {
    return this.vertical ? 'vertical' : 'horizontal';
  }
  get nextWidget() {
    return Widget.fromElement(this.element.nextElementSibling, 1);
  }
  get previousWidget() {
    return Widget.fromElement(this.element.previousElementSibling, 1);
  }
  updateContainerElement(containerElement) {
    var _me$stateDetector;
    const me = this;
    me.stateDetector = (_me$stateDetector = me.stateDetector) === null || _me$stateDetector === void 0 ? void 0 : _me$stateDetector.disconnect();
    if (containerElement) {
      me.stateDetector = new MutationObserver(() => me.syncState()); // syncState runs on next raf
      me.stateDetector.observe(containerElement, {
        attributes: true,
        // in case style changes flip our orientation (when == 'auto')
        childList: true // watch for our neighbors to render (so we can disable on hidden/collapsed state)
      });
    }
  }

  updateNextNeighbor(next) {
    this.watchNeighbor(next, 'next');
  }
  updatePreviousNeighbor(previous) {
    this.watchNeighbor(previous, 'previous');
  }
  watchNeighbor(neighbor, name) {
    this.detachListeners(name);
    neighbor === null || neighbor === void 0 ? void 0 : neighbor.ion({
      name,
      thisObj: this,
      collapse: 'syncState',
      expand: 'syncState',
      hide: 'syncState',
      show: 'syncState'
    });
  }
  updateOrientation() {
    this.syncState.now();
  }
  updateVertical(vertical) {
    var _this$element;
    const classList = (_this$element = this.element) === null || _this$element === void 0 ? void 0 : _this$element.classList;
    classList === null || classList === void 0 ? void 0 : classList.add(classesHV[vertical ? 1 : 0]);
    classList === null || classList === void 0 ? void 0 : classList.remove(classesHV[vertical ? 0 : 1]);
  }
  /**
   * Determine orientation when set to `'auto'` and detects neighboring widgets to monitor their hidden/collapsed
   * states.
   * @private
   */
  syncState() {
    var _verticality$me$orien;
    const me = this,
      {
        element,
        nextWidget,
        previousWidget
      } = me;
    let vertical = (_verticality$me$orien = verticality[me.orientation]) !== null && _verticality$me$orien !== void 0 ? _verticality$me$orien : null;
    me.nextNeighbor = nextWidget;
    me.previousNeighbor = previousWidget;
    me.disabled = nextWidget && (nextWidget.collapsible && nextWidget.collapsed || nextWidget.hidden) || previousWidget && (previousWidget.collapsible && previousWidget.collapsed || previousWidget.hidden);
    if (vertical !== null && nextWidget && previousWidget) {
      me.containerElement = null;
    } else {
      // we'll need to monitor parent element child list changes until our neighbors are added to the DOM
      me.containerElement = element.parentElement;
      // Orientation auto and already rendered, determine orientation to use
      if (me.rendered && element.offsetParent) {
        const flexDirection = DomHelper.getStyleValue(element.parentElement, 'flex-direction');
        // If used in a flex layout, determine orientation from flex-direction
        if (flexDirection) {
          vertical = !flexDirection.startsWith('column');
        }
        // If used in some other layout, try to determine from sibling elements position
        else {
          const previous = element.previousElementSibling,
            next = element.nextElementSibling;
          if (!previous || !next) {
            // To early in rendering, next sibling not rendered yet
            return;
          }
          const prevRect = previous.getBoundingClientRect(),
            nextRect = next.getBoundingClientRect(),
            topMost = prevRect.top < nextRect.top ? prevRect : nextRect,
            bottomMost = topMost === nextRect ? prevRect : nextRect;
          // orientation = topMost.top !== bottomMost.top ? 'horizontal' : 'vertical';
          vertical = topMost.top === bottomMost.top;
        }
      }
    }
    me.vertical = vertical;
  }
  //endregion
  //region Events
  onMouseDown(event) {
    var _me$mouseDetacher;
    event.preventDefault();
    if (event.touches) {
      event = event.touches[0];
    }
    const me = this,
      {
        element
      } = me,
      prev = element.previousElementSibling,
      next = element.nextElementSibling,
      prevHasFlex = hasFlex(prev),
      nextHasFlex = hasFlex(next),
      flexed = [];
    // First stop any ongoing drag operation, since we cannot trust that we always get the mouseup event
    (_me$mouseDetacher = me.mouseDetacher) === null || _me$mouseDetacher === void 0 ? void 0 : _me$mouseDetacher.call(me);
    // Remember flexed children, to enable maintaining their proportions on resize
    for (const child of element.parentElement.children) {
      if (hasFlex(child) && child !== element) {
        flexed.push({
          element: child,
          width: child.offsetWidth,
          height: child.offsetHeight
        });
      }
    }
    me.context = {
      startX: event.pageX,
      startY: event.pageY,
      prevWidth: prev.offsetWidth,
      prevHeight: prev.offsetHeight,
      nextWidth: next.offsetWidth,
      nextHeight: next.offsetHeight,
      prevHasFlex,
      nextHasFlex,
      flexed,
      prev,
      next
    };
    const events = {
      element: document,
      pointermove: 'onMouseMove',
      pointerup: 'onMouseUp',
      thisObj: me
    };
    // TODO : Re-evaluate if this is needed in 2023, https://caniuse.com/pointer
    if (!BrowserHelper.supportsPointerEvents) {
      events.mousemove = events.touchmove = 'onMouseMove';
      events.mouseup = events.touchend = 'onMouseUp';
    }
    element.classList.add('b-moving');
    me.mouseDetacher = EventHelper.on(events);
  }
  onMouseMove(event) {
    const me = this,
      {
        context,
        nextWidget,
        previousWidget
      } = me,
      prevStyle = context.prev.style,
      nextStyle = context.next.style,
      deltaX = (event.pageX - context.startX) * (me.rtl ? -1 : 1),
      deltaY = event.pageY - context.startY;
    event.preventDefault();
    Object.assign(context, {
      deltaX,
      deltaY
    });
    if (!context.started) {
      context.started = true;
      me.trigger('dragStart', {
        context,
        event
      });
      // Convert heights/widths to flex for flexed elements to maintain proportions
      // 100px high -> flex-grow 100
      context.flexed.forEach(flexed => {
        flexed.element.style.flexGrow = me.vertical ? flexed.width : flexed.height;
        //Remove flex-basis, since it interferes with resizing
        flexed.element.style.flexBasis = '0';
      });
    }
    // Adjust flex-grow or width/height for splitters closest siblings
    if (me.vertical) {
      const newPrevWidth = context.prevWidth + deltaX,
        newNextWidth = context.nextWidth - deltaX;
      if (context.prevHasFlex) {
        prevStyle.flexGrow = newPrevWidth;
      } else if (previousWidget) {
        previousWidget.width = newPrevWidth;
      } else {
        prevStyle.width = `${newPrevWidth}px`;
      }
      if (context.nextHasFlex) {
        nextStyle.flexGrow = newNextWidth;
      } else if (nextWidget) {
        nextWidget.width = newNextWidth;
      } else {
        nextStyle.width = `${newNextWidth}px`;
      }
    } else {
      const newPrevHeight = context.prevHeight + deltaY,
        newNextHeight = context.nextHeight - deltaY;
      if (context.prevHasFlex) {
        prevStyle.flexGrow = newPrevHeight;
      } else if (previousWidget) {
        previousWidget.height = newPrevHeight;
      } else {
        prevStyle.height = `${newPrevHeight}px`;
      }
      if (context.nextHasFlex) {
        nextStyle.flexGrow = newNextHeight;
      } else if (nextWidget) {
        nextWidget.height = newNextHeight;
      } else {
        nextStyle.height = `${newNextHeight}px`;
      }
    }
    me.trigger('drag', {
      context,
      event
    });
  }
  onMouseUp(event) {
    var _me$mouseDetacher2;
    const me = this;
    (_me$mouseDetacher2 = me.mouseDetacher) === null || _me$mouseDetacher2 === void 0 ? void 0 : _me$mouseDetacher2.call(me);
    me.mouseDetacher = null;
    me.element.classList.remove('b-moving');
    if (me.context.started) {
      me.trigger('drop', {
        context: me.context,
        event
      });
    }
    me.context = null;
  }
  //endregion
  render() {
    super.render(...arguments);
    this.syncState.now();
    if (this.vertical === null) {
      this.syncState(); // try again on next raf
    }
  }
}
// Register this widget type with its Factory
Splitter.initClass();
Splitter._$name = 'Splitter';

if (window && !window.bryntum) {
  window.bryntum = {};
}
// endregion

export { BooleanCombo, CSSHelper, DataGenerator, DemoBot, FileField, FilePicker, PagingToolbar, PasswordField, SlideToggle, Splitter };
//# sourceMappingURL=core.module.thin.js.map
