{"version":3,"file":"grid.module.thin.js","sources":["../../lib/Grid/column/ActionColumn.js","../../lib/Grid/column/AggregateColumn.js","../../lib/Grid/column/PercentColumn.js","../../lib/Grid/column/RatingColumn.js","../../lib/Grid/column/TemplateColumn.js","../../lib/Grid/column/TimeColumn.js","../../lib/Grid/feature/CellCopyPaste.js","../../lib/Grid/feature/CellTooltip.js","../../lib/Grid/feature/ColumnRename.js","../../lib/Grid/feature/FillHandle.js","../../lib/Grid/feature/MergeCells.js","../../lib/Grid/feature/QuickFind.js","../../lib/Grid/feature/RowExpander.js","../../lib/Grid/feature/Search.js","../../lib/Grid/feature/StickyCells.js","../../lib/Grid/widget/TreeCombo.js"],"sourcesContent":["import Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\n\n/**\n * @module Grid/column/ActionColumn\n */\n\n/**\n * Config object for an action in an ActionColumn.\n * @typedef {Object} ActionConfig\n * @property {String} cls CSS Class for action icon\n * @property {Function|String|TooltipConfig} tooltip Tooltip text, or a config object which can reconfigure the shared\n * tooltip by setting boolean, numeric and string config values, or a function to return the tooltip text, passed the\n * row's `record`\n * @property {Function|Boolean} visible Boolean to define the action icon visibility or a callback function, passed the\n * row's `record`, to change it dynamically\n * @property {Function} onClick Callback to handle click action item event, passed the row's `record`\n * @property {Boolean} showForGroup Set to true to have action icon visible in group headers only when using the `group`\n * feature\n * @property {Function|String} renderer A render function, or the name of a function in the Grid's ownership tree used\n * to define the action element. Passed the row's `record`, expected to return an HTML string or a DOM config object.\n * **Note**: when specified, the `cls` action config is ignored. Make sure you add an action icon manually, for example:\n * ```javascript\n * {\n *      type    : 'action',\n *      text    : 'Increase amount',\n *      actions : [{\n *          cls      : 'b-fa b-fa-plus', // this line will be ignored\n *          renderer : ({ record }) => '<i class=\"b-action-item b-fa b-fa-plus\"></i> ' + record.name,\n *          onClick  : ({ record }) => {}\n *      }]\n * }\n * ```\n *\n * or\n *\n * ```javascript\n * {\n *      type    : 'action',\n *      text    : 'Increase amount',\n *      actions : [{\n *          cls      : 'b-fa b-fa-plus', // this line will be ignored\n *          renderer : 'up.renderAction' // Defined on the Grid\n *          onClick  : ({ record }) => {}\n *      }]\n * }\n * ```\n */\n\n/**\n * A column that displays actions as clickable icons in the cell.\n *\n * {@inlineexample Grid/column/ActionColumn.js}\n *\n * ```javascript\n * new TreeGrid({\n *     appendTo : document.body,\n *     columns  : [{\n *         type    : 'action',\n *         text    : 'Increase amount',\n *         actions : [{\n *             cls      : 'b-fa b-fa-plus',\n *             renderer : ({ action, record }) => `<i class=\"b-action-item ${action.cls} b-${record.enabled ? \"green\" : \"red\"}-class\"></i>`,\n *             visible  : ({ record }) => record.canAdd,\n *             tooltip  : ({ record }) => `<p class=\"b-nicer-than-default\">Add to ${record.name}</p>`,\n *             onClick  : ({ record }) => console.log(`Adding ${record.name}`)\n *         }, {\n *             cls     : 'b-fa b-fa-pencil',\n *             tooltip : 'Edit note',\n *             onClick : ({ record }) => console.log(`Editing ${record.name}`)\n *         }]\n *     }]\n * });\n * ```\n *\n * Actions may be placed in {@link Grid/feature/Group} headers, by setting `action.showForGroup` to `true`. Those\n * actions will not be shown on normal rows.\n *\n * @extends Grid/column/Column\n * @classType action\n * @column\n */\nexport default class ActionColumn extends Column {\n\n    static type = 'action';\n\n    static fields = [\n        /**\n         * An array of action config objects, see {@link #typedef-ActionConfig} for details.\n         *\n         * ```javascript\n         * new Grid({\n         *     columns  : [{\n         *         type    : 'action',\n         *         text    : 'Actions',\n         *         actions : [{\n         *             cls      : 'b-fa b-fa-plus',\n         *             visible  : ({ record }) => record.canAdd,\n         *             onClick  : ({ record }) => console.log(`Adding ${record.name}`)\n         *         }, {\n         *             cls     : 'b-fa b-fa-pencil',\n         *             tooltip : 'Edit note',\n         *             onClick : ({ record }) => console.log(`Editing ${record.name}`)\n         *         }]\n         *     }]\n         * });\n         * ```\n         *\n         * @config {ActionConfig[]} actions List of action configs\n         * @category Common\n         */\n        { name : 'actions', type : 'array' },\n\n        /**\n         * Set true to hide disable actions in this column if the grid is {@link Core.widget.Widget#config-readOnly}\n         * @config {Boolean} disableIfGridReadOnly\n         * @default\n         * @category Common\n         */\n        { name : 'disableIfGridReadOnly', defaultValue : false }\n    ];\n\n    static defaults = {\n        /**\n         * Filtering by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} filterable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        filterable : false,\n\n        /**\n         * Grouping by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} groupable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        groupable : false,\n\n        /**\n         * Sorting by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} sortable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        sortable : false,\n\n        /**\n         * Editor for action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} editor\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        editor : false,\n\n        /**\n         * Searching by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} searchable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        searchable : false,\n\n        /**\n         * By default, for action column this flag is switched to `true`, because the content of this column is always HTML.\n         * @config {Boolean} htmlEncode\n         * @default false\n         * @category Misc\n         * @hide\n         */\n        htmlEncode : false,\n\n        /**\n         * Set to `true` to allow the column to being drag-resized when the ColumnResize plugin is enabled.\n         * @config {Boolean} resizable\n         * @default false\n         * @category Interaction\n         */\n        resizable : false,\n\n        /**\n         * Column minimal width. If value is Number then minimal width is in pixels.\n         * @config {Number|String} minWidth\n         * @default 30\n         * @category Layout\n         */\n        minWidth : 30\n    };\n\n    get groupHeaderReserved() {\n        return true;\n    }\n\n    construct(config, store) {\n        const me = this;\n\n        super.construct(...arguments);\n\n        // use auto-size only as default behaviour\n        if (!config.width && !config.flex) {\n            me.grid.ion({ paint : 'updateAutoWidth', thisObj : me });\n        }\n\n        if (me.disableIfGridReadOnly) {\n            me.grid.element.classList.add('b-actioncolumn-readonly');\n        }\n\n        me.externalRenderer = me.renderer;\n        me.renderer = me.internalRenderer;\n    }\n\n    /**\n     * Renderer that displays action icon(s) in the cell.\n     * @private\n     */\n    internalRenderer({ grid, column, record, callExternalRenderer = true }) {\n        const\n            inGroupTitle = record && ('groupRowFor' in record.meta),\n            { subGrid }  = column;\n\n        if (callExternalRenderer) {\n            this.externalRenderer?.(...arguments);\n        }\n\n        return {\n            className : { 'b-action-ct' : 1 },\n            children  : column.actions?.map((actionConfig, index) => {\n                if ('visible' in actionConfig) {\n                    if ((typeof actionConfig.visible === 'function') && actionConfig.visible({ record }) === false) {\n                        return '';\n                    }\n                    if (actionConfig.visible === false) {\n                        return '';\n                    }\n                }\n\n                // check if an action allowed to be shown in case of using grouping\n                if ((inGroupTitle && !actionConfig.showForGroup) || (!inGroupTitle && actionConfig.showForGroup)) {\n                    return '';\n                }\n\n                const\n                    {\n                        tooltip,\n                        renderer\n                    }    = actionConfig,\n                    btip = (typeof tooltip === 'function' || tooltip?.startsWith?.('up.')) ? subGrid.callback(tooltip, subGrid, [{ record }]) : tooltip || '';\n\n                // handle custom renderer if it is specified\n                if (renderer) {\n                    const customRendererData = subGrid.callback(renderer, subGrid, [{\n                        index,\n                        record,\n                        column,\n                        tooltip : btip,\n                        action  : actionConfig\n                    }]);\n\n                    // take of set data-index to make onClick handler work stable\n                    if (typeof customRendererData === 'string') {\n                        return {\n                            tag     : 'span',\n                            dataset : {\n                                ...Tooltip.encodeConfig(btip),\n                                index\n                            },\n                            html : customRendererData\n                        };\n                    }\n                    else {\n                        customRendererData.dataset = customRendererData.dataset || {};\n                        customRendererData.dataset.index = index;\n                        return customRendererData;\n                    }\n                }\n                else {\n                    return {\n                        tag     : 'button',\n                        dataset : {\n                            ...Tooltip.encodeConfig(btip),\n                            index\n                        },\n                        'aria-label' : btip,\n                        className    : {\n                            'b-tool'           : 1,\n                            'b-action-item'    : 1,\n                            [actionConfig.cls] : actionConfig.cls\n                        }\n                    };\n                }\n            })\n        };\n    }\n\n    /**\n     * Handle icon click and call action handler.\n     * @private\n     */\n    onCellClick({ grid, column, record, target }) {\n        if (column !== this || !target.classList.contains('b-action-item')) {\n            return;\n        }\n\n        let actionIndex = target.dataset.index;\n        // index may be set in a parent node if user used an html string in his custom renderer\n        // and we take care to set this property to support onClick handler\n        if (!actionIndex) {\n            actionIndex = target.parentElement.dataset && target.parentElement.dataset.index;\n        }\n\n        const\n            action        = column.actions?.[actionIndex],\n            actionHandler = action && action.onClick;\n\n        if (actionHandler) {\n            this.callback(actionHandler, column, [{ record, action, target }]);\n        }\n    }\n\n    /**\n     * Update width for actions column to fit content.\n     * @private\n     */\n    updateAutoWidth() {\n        const\n            me           = this,\n            groupActions = [],\n            {\n                actions : oldActions\n            }            = me;\n\n        // header may be disabled, in that case we won't be able to calculate the width properly\n        if (!me.element) {\n            return;\n        }\n\n        const actions = me.actions = [];\n\n        // collect group and non group actions to check length later\n        oldActions?.forEach(actionOriginal => {\n            const action = { ...actionOriginal };\n\n            // remove possible visibility condition to make sure an action will exists in test HTML\n            delete action.visible;\n            // group actions shows in different row and never together with non group\n            if (action.showForGroup) {\n                delete action.showForGroup;\n                groupActions.push(action);\n            }\n            else {\n                actions.push(action);\n            }\n        });\n\n        // use longest actions length to calculate column width\n        if (groupActions.length > actions.length) {\n            me._actions = groupActions;\n        }\n\n        const actionsHtml = DomHelper.createElement(me.internalRenderer({ column : me, callExternalRenderer : false })).outerHTML;\n\n        me.width = DomHelper.measureText(actionsHtml, me.element, true, me.element.parentElement);\n        me.actions = oldActions;\n    }\n}\n\nColumnStore.registerColumnType(ActionColumn);\nActionColumn.exposeProperties();\n","import ColumnStore from '../data/ColumnStore.js';\nimport NumberColumn from './NumberColumn.js';\n\n/**\n * @module Grid/column/AggregateColumn\n */\n\n/**\n * A column, which, when used as part of a {@link Grid.view.TreeGrid}, aggregates the values of this column's descendants using\n * a configured function which defaults to `sum`. The aggregate value is re-calculated after any change to the data,\n * and if you want aggregate values to be change-tracked, please set {@link #config-includeParentInChangeSet} to true.\n *\n * Default editor depends on the data field type. If it is a number, default editor is a {@link Core/widget/NumberField}.\n * Otherwise Default editor is a {@link Core/widget/TextField}.\n *\n * ```javascript\n * const grid = new TreeGrid({\n *     // Custom aggregation handler.\n *     // For test purposes, this just does \"sum\"\n *     myAggregator(...values) {\n *         let result = 0;\n *\n *         for (let i = 0, { length } = values; i < length; i++) {\n *             result += parseInt(args[i], 10);\n *         }\n *         return result;\n *     },\n *     columns : [\n *         { field : 'name', text : 'Name' },\n *\n *         // Will sum the ages of leaf nodes. This is the default.\n *         { type : 'aggregate', field : 'age', text : 'Age', renderer : ({ value }) => `<b>${value}<b>` },\n *\n *         // Will use AggregateColumn's built-in avg of scores of leaf nodes\n *         { type : 'aggregate', field : 'score', text : 'Score', function : 'avg' },\n *\n *         // Will use the grid's myAggregator function\n *         { type : 'aggregate', field : 'revenue', text : 'Revenue', function : 'up.myAggregator' },\n *     ]\n * });\n * ```\n *\n * @extends Grid/column/NumberColumn\n * @classType aggregate\n * @column\n */\nexport default class AggregateColumn extends NumberColumn {\n    //region Config\n\n    static type = 'aggregate';\n\n    static fields = [\n        'function',\n        'includeParentInChangeSet'\n    ];\n\n    static get defaults() {\n        return {\n            /**\n             * Math Function name, or function name prepended by `\"up.\"` that is resolvable in an\n             * ancestor component (such as the owning Grid, or a hight Container), or a function to\n             * use to aggregate child record values for this column, or a function.\n             *\n             * This Column is provided with a `sum` and `avg` function. The default function is `sum`\n             * which is used for the aggregation.\n             *\n             * The function is passed a set of child node values, each value in a separate argument\n             * and should return a single value based upon the value set passed.\n             * @config {Function|String}\n             * @category Common\n             */\n            function : 'sum',\n\n            /**\n             * Set to `true` to include changes to parent (aggregate) rows in the store's modification tracking.\n             * @config {Boolean} includeParentInChangeSet\n             * @category Common\n             */\n            includeParentInChangeSet : false\n        };\n    }\n\n    construct(data, columnStore) {\n        this.configuredAlign = 'align' in data;\n        this.configuredEditor = 'editor' in data;\n\n        super.construct(...arguments);\n\n        const { grid } = columnStore;\n\n        // 'sum' is reserved by Summary feature, so we use a different name\n        if (this.function === 'sum') {\n            this.function = 'sumChildren';\n        }\n\n        if (grid) {\n            this.store = grid.store;\n        }\n    }\n\n    set store(store) {\n        const\n            me             = this,\n            storeListeners = {\n                update  : 'onRecordUpdate',\n                thisObj : me,\n                prio    : 1000\n            },\n            oldStore = me._store;\n\n        if (store !== oldStore) {\n            if (oldStore) {\n                oldStore.un(storeListeners);\n            }\n\n            me._store = store;\n\n            const\n                { modelClass } = store,\n                field = modelClass.fieldMap[me.field];\n\n            // It's *likely*, but not certain that this will be used for a numeric field.\n            // Use numeric defaults unless configured otherwise if so.\n            if (field && field.type === 'number') {\n                if (!me.configuredAlign) {\n                    me.align = 'end';\n                }\n                if (!me.configuredEditor) {\n                    me.editor = 'number';\n                }\n            }\n\n            store.ion(storeListeners);\n        }\n    }\n\n    canEdit(record) {\n        return record.isLeaf;\n    }\n\n    get store() {\n        return this._store;\n    }\n\n    sumChildren(...args) {\n        let result = 0;\n\n        for (let i = 0, { length } = args; i < length; i++) {\n            result += parseFloat(args[i] || 0, 10);\n        }\n        return result;\n    }\n\n    avg(...args) {\n        let result = 0;\n        const { length } = args;\n\n        for (let i = 0; i < length; i++) {\n            result += parseFloat(args[i] || 0, 10);\n        }\n        return result / length;\n    }\n\n    onRecordUpdate({ record, changes }) {\n        const\n            me = this,\n            { rowManager } = me.grid;\n\n        if (me.field in changes) {\n            if (record.isLeaf) {\n                record.bubble(rec => {\n                    const row = rowManager.getRowFor(rec);\n\n                    if (row) {\n                        const cellElement = row.getCell(me.field);\n\n                        if (cellElement) {\n                            row.renderCell(cellElement);\n                        }\n                    }\n                }, true);\n            }\n        }\n    }\n\n    getRawValue(record) {\n        let value = 0;\n\n        if (record.children?.length) {\n            const\n                me       = this,\n                fn       = me.function,\n                isMathFn = typeof fn === 'string' && typeof Math[fn] === 'function',\n                {\n                    handler,\n                    thisObj\n                } = isMathFn ? {\n                    handler : Math[fn],\n                    thisObj : Math\n                } : me.resolveCallback(fn);\n\n            // Gather all child node values before passing them to the aggregator function.\n            value = handler.apply(thisObj, record.children.map(r => me.getRawValue(r)));\n            if (me.includeParentInChangeSet) {\n                record.set(me.field, value, true);\n            }\n            else {\n                record.setData(me.field, value);\n            }\n        }\n        else {\n            value = record[this.field];\n        }\n        return value;\n    }\n\n    canFillValue() {\n        return false;\n    }\n}\n\nColumnStore.registerColumnType(AggregateColumn, true);\nAggregateColumn.exposeProperties();\n","import NumberColumn from './NumberColumn.js';\nimport ColumnStore from '../data/ColumnStore.js';\n\n/**\n * @module Grid/column/PercentColumn\n */\n\n/**\n * A column that display a basic progress bar.\n *\n * {@inlineexample Grid/column/PercentColumn.js}\n *\n * ```javascript\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         { type: 'percent', text: 'Progress', data: 'progress' }\n *     ]\n * });\n * ```\n *\n * Default editor is a {@link Core.widget.NumberField NumberField}.\n *\n * @extends Grid/column/NumberColumn\n * @classType percent\n * @column\n */\nexport default class PercentColumn extends NumberColumn {\n\n    static type = 'percent';\n\n    // Type to use when auto adding field\n    static fieldType = 'number';\n\n    static fields = ['showValue', 'lowThreshold'];\n\n    static get defaults() {\n        return {\n            min : 0,\n            max : 100,\n\n            /**\n             * Set to `true` to render the number value inside the bar, for example \"15%\"\n             * @config {Boolean}\n             * @default\n             * @category Rendering\n             */\n            showValue : false,\n\n            /**\n             * When below this percentage the bar will have `b-low` CSS class added. By default it turns the bar red.\n             * @config {Number}\n             * @default\n             * @category Rendering\n             */\n            lowThreshold : 20,\n\n            htmlEncode      : false,\n            searchable      : false,\n            summaryRenderer : sum => `${sum}%`,\n            fitMode         : false\n        };\n    }\n\n    constructor(config, store) {\n        super(...arguments);\n\n        this.internalCellCls = 'b-percent-bar-cell';\n    }\n\n    /**\n     * Renderer that displays a progress bar in the cell. If you create a custom renderer, and want to include the\n     * default markup you can call `defaultRenderer` from it.\n     *\n     * ```javascript\n     * new Grid({\n     *     columns: [\n     *         {\n     *             type: 'percent',\n     *             text : 'Percent',\n     *             field : 'percent',\n     *             renderer({ value }) {\n     *                 const domConfig = this.defaultRenderer();\n     *\n     *                 if (value > 100) {\n     *                     domConfig.className = b-percent-bar-outer over-allocated';\n     *                 }\n     *\n     *                 return domConfig;\n     *             }\n     *         }\n     *     ]\n     * }\n     * ```\n     *\n     * @param {Object} rendererData The data object passed to the renderer\n     * @param {Number} rendererData.value The value to display\n     * @returns {DomConfig} DomConfig object representing the default markup for the cells content\n     */\n    defaultRenderer({ value }) {\n        value = value || 0;\n\n        return {\n            className       : 'b-percent-bar-outer',\n            role            : 'progressbar',\n            'aria-Valuemin' : 0,\n            'aria-Valuemax' : 100,\n            'aria-Valuenow' : value,\n            tabIndex        : 0,\n            children        : [\n                {\n                    tag       : 'div',\n                    className : {\n                        'b-percent-bar' : 1,\n                        'b-zero'        : value === 0,\n                        'b-low'         : value < this.lowThreshold\n                    },\n                    style : {\n                        width : value + '%'\n                    },\n                    children : [\n                        this.showValue ? {\n                            tag  : 'span',\n                            text : value + '%'\n                        } : undefined\n                    ]\n                }\n            ]\n        };\n    }\n\n    // Null implementation because the column width drives the width of its content.\n    // So the concept of sizing to content is invalid here.\n    resizeToFitContent() {}\n}\n\nPercentColumn.sum = 'average';\n\nColumnStore.registerColumnType(PercentColumn, true);\n","import NumberColumn from './NumberColumn.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\n\n/**\n * @module Grid/column/RatingColumn\n */\n\n/**\n * A column that displays a star rating. Click a start to set a value, shift+click to unset a single start from the end.\n * Clicking the first and only star toggles it.\n *\n * This column uses a custom widget as its editor, and it is not intended to be changed.\n *\n * @extends Grid/column/NumberColumn\n *\n * @example\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         { type: 'rating', max : 10, field: 'rating' }\n *     ]\n * });\n *\n * @classType rating\n * @inlineexample Grid/column/RatingColumn.js\n * @column\n */\nexport default class RatingColumn extends NumberColumn {\n\n    // Do not remove. Assertion strings for Localization sanity check.\n    // 'L{Column.cellLabel}'\n\n    static $name = 'RatingColumn';\n\n    static type = 'rating';\n\n    // Type to use when auto adding field\n    static fieldType = 'number';\n\n    static fields = ['emptyIcon', 'filledIcon', 'editable'];\n\n    static get defaults() {\n        return {\n            min : 0,\n            max : 5,\n\n            /**\n             * The empty rating icon to show\n             * @config {String}\n             * @category Rendering\n             */\n            emptyIcon : 'b-icon b-icon-star',\n\n            /**\n             * The filled rating icon to show\n             * @config {String}\n             * @category Rendering\n             */\n            filledIcon : 'b-icon b-icon-star',\n\n            /**\n             * Allow user to click an icon to change the value\n             * @config {Boolean}\n             * @category Interaction\n             */\n            editable : true,\n\n            filterType : 'number',\n            searchable : false,\n            width      : '11.2em',\n            htmlEncode : false,\n            minWidth   : '11.2em',\n            editor     : false,\n            fitMode    : 'value'\n        };\n    }\n\n    /**\n     * Renderer that displays a number of stars in the cell. Also adds CSS class 'b-rating-cell' to the cell.\n     * @private\n     */\n    renderer({ value }) {\n        return {\n            className : {\n                'b-rating-cell-inner' : 1,\n                'b-not-editable'      : !this.editable\n            },\n            children : ArrayHelper.populate(this.max, i => {\n                const filled = i < value;\n                return {\n                    tag       : 'i',\n                    className : {\n                        'b-rating-icon'                             : true,\n                        'b-filled'                                  : filled,\n                        'b-empty'                                   : !filled,\n                        [filled ? this.filledIcon : this.emptyIcon] : true\n                    }\n                };\n            })\n        };\n    }\n\n    onCellClick({ grid, column, record, target, event }) {\n        if (target.classList.contains('b-rating-icon') && !grid.readOnly && column.editable) {\n            let starIndex = [].indexOf.call(target.parentNode.childNodes, target);\n\n            if (target.classList.contains('b-filled') && (event.metaKey || event.shiftKey)) {\n                starIndex = starIndex - 1;\n            }\n\n            // Clicking first star when it is only one removes it\n            if (record.get(column.field) === 1 && starIndex === 0) {\n                starIndex = -1;\n            }\n\n            record.set(column.field, starIndex + 1);\n        }\n    }\n}\n\nColumnStore.registerColumnType(RatingColumn, true);\nRatingColumn.exposeProperties();\n","import Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\n\n/**\n * @module Grid/column/TemplateColumn\n */\n\n/**\n * A column that uses a template for cell content. Any function can be used as template, and the function is passed { value, record, field } properties.\n * It should return a string which will be rendered in the cell.\n *\n * Default editor is a {@link Core.widget.TextField TextField}.\n *\n * @extends Grid/column/Column\n *\n * @example\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         { type: 'template', field: 'age', template: ({value}) => `${value} years old` }\n *     ]\n * });\n *\n * @classType template\n * @inlineexample Grid/column/TemplateColumn.js\n * @column\n */\nexport default class TemplateColumn extends Column {\n\n    static type = 'template';\n\n    static fields = [\n        /**\n         * Template function used to generate a value displayed in the cell. Called with arguments `{ value, record, field }`\n         * @config {Function} template\n         * @param {Object} data An object that contains data about the cell being rendered.\n         * @param {*} data.value The value (only present when you set a `field` on the column)\n         * @param {Core.data.Model} data.record The record representing the row\n         * @param {String} data.field The column field name\n         * @category Common\n         */\n        'template'\n    ];\n\n    static get defaults() {\n        return {\n            htmlEncode : false\n        };\n    }\n\n    constructor(config, store) {\n        super(...arguments);\n\n        const me = this;\n\n        if (!me.template) {\n            throw new Error('TemplateColumn needs a template');\n        }\n\n        if (typeof me.template !== 'function') {\n            throw new Error('TemplateColumn.template must be a function');\n        }\n    }\n\n    /**\n     * Renderer that uses a template for cell content.\n     * @private\n     */\n    renderer(renderData) {\n        // If it's a special row, such as a group row, we can't use the user's template\n        if (!renderData.record.isSpecialRow) {\n            return this.template({\n                value  : renderData.value,\n                record : renderData.record,\n                field  : renderData.column.field\n            });\n        }\n    }\n}\n\nColumnStore.registerColumnType(TemplateColumn, true);\nTemplateColumn.exposeProperties();\n","import Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\n\n/**\n * @module Grid/column/TimeColumn\n */\n\n/**\n * A column that displays a time in the specified format (see {@link Core.helper.DateHelper#function-format-static} for formatting options).\n *\n * Default editor is a {@link Core.widget.TimeField TimeField}.\n *\n * @extends Grid/column/Column\n *\n * @example\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *          { type: 'time', text: 'Start time', format: 'HH:mm:ss', data: 'start' }\n *     ]\n * });\n *\n * @classType time\n * @inlineexample Grid/column/TimeColumn.js\n * @column\n */\nexport default class TimeColumn extends Column {\n\n    //region Config\n\n    static type = 'time';\n\n    // Type to use when auto adding field\n    static fieldType = 'date';\n\n    static fields = ['format'];\n\n    static get defaults() {\n        return {\n            /**\n             * Time format\n             * @config {String}\n             * @category Common\n             */\n            format : 'LT',\n\n            minWidth : 140,\n\n            filterType : 'time'\n        };\n    }\n\n    //endregion\n\n    //region Display\n\n    /**\n     * Renderer that displays the time with the specified format. Also adds cls 'b-time-cell' to the cell.\n     * @private\n     */\n    defaultRenderer({ value }) {\n        return value ? this.formatValue(value) : '';\n    }\n\n    /**\n     * Group renderer that displays the time with the specified format.\n     * @private\n     */\n    groupRenderer({ cellElement, groupRowFor }) {\n        cellElement.innerHTML = this.formatValue(groupRowFor);\n    }\n\n    //endregion\n\n    //region Formatter\n\n    /**\n     * Used by both renderer and groupRenderer to do the actual formatting of the time\n     * @private\n     * @param value\n     * @returns {String}\n     */\n    formatValue(value) {\n        // Ideally we should be served a time, but if not make it easier for the user by parsing\n        if (typeof value === 'string') {\n            value = DateHelper.parse(value, this.format);\n        }\n        return DateHelper.format(value, this.format);\n    }\n\n    //endregion\n\n    //region Getters/Setters\n    /**\n     * Get/Set format for time displayed in cell and editor (see {@link Core.helper.DateHelper#function-format-static} for formatting options)\n     * @property {String}\n     */\n    set format(value) {\n        const { editor } = this;\n\n        this.set('format', value);\n\n        if (editor) {\n            editor.format = value;\n        }\n    }\n\n    get format() {\n        return  this.get('format');\n    }\n\n    get defaultEditor() {\n        return {\n            name   : this.field,\n            type   : 'time',\n            format : this.format\n        };\n    }\n\n    //endregion\n}\n\nColumnStore.registerColumnType(TimeColumn, true);\nTimeColumn.exposeProperties();\n","import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\n\n/**\n * @module Grid/feature/CellCopyPaste\n */\n\n/**\n * Allows using `[Ctrl/CMD + C]`, `[Ctrl/CMD + X]` and `[Ctrl/CMD + V]` to cut, copy and paste cell or cell ranges. Also\n * makes cut, copy and paste actions available via the cell context menu.\n *\n * Requires {@link Grid/view/Grid#config-selectionMode selectionMode.cell} to be activated.\n *\n * This feature will work alongside with {@link Grid/feature/RowCopyPaste} but there is differences on functionality.\n * * When used together, context menu options will be detailed so the user will know to copy the cell or the row.\n * * They will also detect what type of selection is present at the moment. If there are only rows selected, only row\n *   alternatives are shown in the context menu and the keyboard shortcuts will be processed by RowCopyPaste.\n * * If there are only cells selected, there will be context menu options for both row and cell but keyboard shortcuts\n *   will be handled by CellCopyPaste.\n * * They do not share clipboard, so it is possible to have rows and cells copied or cut at the same time.\n *\n * If the {@link https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API Clipboard API} is available, that will\n * be used. This enables copying and pasting between different Bryntum products or completely different applications.\n * Please note that only string values are supported.\n *\n * This feature is **disabled** by default\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         cellCopyPaste : true\n *     }\n * });\n * ```\n *\n * {@inlineexample Grid/feature/CellCopyPaste.js}\n *\n * ## Keyboard shortcuts\n * The feature has the following default keyboard shortcuts:\n *\n * | Keys   | Action | Action description                                                                      |\n * |--------|--------|-----------------------------------------------------------------------------------------|\n * | Ctrl+C | copy   | Calls {@link #function-copy} which copies selected cell values into the clipboard.      |\n * | Ctrl+X | cut    | Calls {@link #function-cut} which cuts out selected cell values and saves in clipboard. |\n * | Ctrl+V | paste  | Calls {@link #function-paste} which inserts string values from the clipboard.           |\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [this guide](#Grid/guides/customization/keymap.md).\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype cellCopyPaste\n * @feature\n */\nexport default class CellCopyPaste extends InstancePlugin {\n    static $name = 'CellCopyPaste';\n\n    static pluginConfig = {\n        chain : [\n            'populateCellMenu', 'afterSelectionModeChange'\n        ]\n    }\n\n    static configurable = {\n\n        /**\n         * If `true` this prevents cutting and pasting. Will default to `true` if {@link Grid/feature/CellEdit} feature is disabled.\n         * Set to `false` to prevent this behaviour.\n         * @config {Boolean}\n         */\n        copyOnly : null,\n\n        /**\n         * If an empty value (null or empty string) is copied or cut, this config will replace that value.\n         * This allows for clipboard data to skip columns.\n         *\n         * For example, look at these two selections\n         * |  ROW  |   0  |      1       |       2      |   3  |\n         * |-------|------|--------------|--------------|------|\n         * | ROW 1 | SEL1 | not selected | not selected | SEL2 |\n         * | ROW 2 | SEL3 | SEL4 (empty) | SEL5 (empty) | SEL6 |\n         *\n         * The clipboardData for `ROW 1` will look like this:\n         `* SEL1\\t\\t\\SEl2\\nSEL3\\t\\t\\SEL4`\n         *\n         * And `ROW 2` will look like this:\n         * `SEL3\\t\\u{0020}\\t\\u{0020}\\tSEL6`\n         *\n         * `ROW 1` will set value `SEL1` at column index 0 and `SEL2` at column index 3. This leaves column index 1 and\n         * 2 untouched.\n         *\n         * `ROW 2` will set value `SEL3` at column index 0, `u{0020}` at column index 1 and 2, and `SEL`6 at column\n         * index 3.\n         *\n         * The default `u{0020}` is a blank space.\n         *\n         * @config {String}\n         * @default\n         */\n        emptyValueChar : '\\u{0020}',\n\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            'Ctrl+C' : 'copy',\n            'Ctrl+X' : 'cut',\n            'Ctrl+V' : 'paste'\n        },\n\n        /**\n         * Set this to `false` to not use native Clipboard API even if it is available\n         * @config {Boolean}\n         * @default true\n         */\n        useNativeClipboard : !VersionHelper.isTestEnv,\n\n        /**\n         * Provide a function to be able to customize the string value which is copied.\n         *\n         * ````javascript\n         * new Grid({\n         *     features : {\n         *         cellCopyPaste : {\n         *             toCopyString({currentValue, column, record}) {\n         *                 if(record.isAvatar){\n         *                     return record.fullName;\n         *                 }\n         *                 return currentValue;\n         *             }\n         *         }\n         *     }\n         * });\n         * ````\n         *\n         * @param {Object} data\n         * @param {String} data.currentValue\n         * @param {Grid.column.Column} data.column\n         * @param {Core.data.Model} data.record\n         * @config {Function}\n         */\n        toCopyString : null,\n\n        /**\n         * Provide a function to be able to customize the value which will be set onto the record\n         *\n         * ````javascript\n         * new Grid({\n         *     features : {\n         *         cellCopyPaste : {\n         *             toPasteValue({currentValue, column, record, field}) {\n         *                 if(typeof currentValue === 'string'){\n         *                     return currentValue.replace('$', '');\n         *                 }\n         *                 return currentValue;\n         *             }\n         *         }\n         *     }\n         * });\n         * ````\n         *\n         * @param {Object} data\n         * @param {String} data.currentValue\n         * @param {Grid.column.Column} data.column\n         * @param {Core.data.Model} data.record\n         * @config {Function}\n         */\n        toPasteValue : null,\n\n        copyText  : 'L{copy}',\n        cutText   : 'L{cut}',\n        pasteText : 'L{paste}'\n    }\n\n    afterConstruct() {\n        super.afterConstruct();\n        this.afterSelectionModeChange();\n    }\n\n    afterSelectionModeChange() {\n        const me = this;\n\n        if (!me.client.selectionMode.cell) {\n            me.disabled = true;\n        }\n        else if (me._disabledBySelectionMode) {\n            me.disabled = false;\n            delete me._disabledBySelectionMode;\n        }\n    }\n\n    // Used in events to separate events from different features from each other\n    entityName = 'cell';\n\n    get copyOnly() {\n        // If celledit is disabled, cut and paste actions are disabled by default\n        return this._copyOnly || !this.client.features.cellEdit?.enabled;\n    }\n\n    get canCopy() {\n        return !this.disabled && !this.client.selectedRecords.length && this.client.selectedCells.length;\n    }\n\n    get canCutPaste() {\n        return this.canCopy && !this.copyOnly && !this.client.features.cellEdit?.isEditing && !this.client.readOnly;\n    }\n\n    // Called from keyMap. Also used internally here\n    isActionAvailable(key, action) {\n        return this.canCopy && (action === 'copy' || this.canCutPaste);\n    }\n\n    // Takes cell locations and converts them to tab and new-line separated string values.\n    // Then stores them in native clipboard or the internal clipboard\n    async sendToClipboard(cells) {\n        const\n            me           = this;\n        let lastRowIndex = 0,\n            lastColIndex = 0,\n            stringData   = '';\n\n        // Sorted by rowIndex then by columnIndex\n        cells.sort((c1, c2) => c1.rowIndex === c2.rowIndex ? c1.columnIndex - c2.columnIndex : c1.rowIndex - c2.rowIndex);\n\n        for (const cell of cells) {\n            const { record, column, rowIndex, columnIndex } = cell;\n\n            // Separate with \\n if new row\n            if (rowIndex > lastRowIndex) {\n                if (stringData.length > 0) {\n                    stringData += '\\n'.repeat(rowIndex - lastRowIndex);\n                }\n                lastRowIndex = rowIndex;\n                lastColIndex = columnIndex;\n            }\n            // Separate with \\t if new column\n            else if (columnIndex > lastColIndex) {\n                if (stringData.length > 0) {\n                    stringData += '\\t'.repeat(columnIndex - lastColIndex);\n                }\n                lastColIndex = columnIndex;\n            }\n\n            // The column can provide its own toClipboardString\n            let cellValue = column.toClipboardString?.(cell);\n\n            // Or we use the raw value from the record\n            if (cellValue === undefined) {\n                cellValue = record.get(column.field)?.toString();\n            }\n\n            // The client can provide its own as well.\n            if (me.toCopyString) {\n                cellValue = me.toCopyString({ currentValue : cellValue, column, record });\n            }\n\n            cellValue = cellValue?.replace(/[\\n\\t]/, ' ');\n\n            stringData += cellValue || me.emptyValueChar;\n        }\n\n        await BrowserHelper.writeToClipboard(stringData, this.useNativeClipboard);\n\n        return stringData;\n    }\n\n    /**\n     * Cuts selected cells to clipboard (native if accessible) to paste later\n     * @async\n     */\n    async cut() {\n        await this.copy(true);\n    }\n\n    /**\n     * Copies selected cells to clipboard (native if accessible) to paste later\n     * @async\n     */\n    async copy(cut) {\n        const\n            me    = this,\n            {\n                client,\n                entityName\n            }     = me,\n            isCut = typeof cut === 'boolean' ? cut : false, // If called by keymap, arguments[0] will be an event\n            cells = isCut ? client.selectedCells.filter(r => !r.record?.readOnly) : client.selectedCells;\n\n        if (cells) {\n\n            /**\n             * Fires on the owning Grid before a copy action is performed, return `false` to prevent the action\n             * @event beforeCopy\n             * @preventable\n             * @on-owner\n             * @param {Grid.view.Grid} source Owner grid\n             * @param {Grid.util.Location[]} cells The cells about to be copied or cut\n             * @param {Boolean} isCut `true` if this is a cut action\n             * @param {String} entityName 'cell' to distinguish this event from other beforeCopy events\n             */\n            if ((isCut ? !me.canCutPaste : !me.canCopy) ||\n                client.trigger('beforeCopy', { cells, isCut, entityName }) === false\n            ) {\n                return;\n            }\n\n            const copiedDataString = await me.sendToClipboard(cells);\n\n            if (isCut === true) {\n                for (const cell of cells) {\n                    if (!cell.column.readOnly) {\n                        cell.record.set(cell.column.field, null);\n                    }\n                }\n            }\n\n            /**\n             * Fires on the owning Grid after a copy action is performed.\n             * @event copy\n             * @on-owner\n             * @param {Grid.view.Grid} source Owner grid\n             * @param {Grid.util.Location[]} cells The cells about to be copied or cut\n             * @param {String} copiedDataString The concatenated data string that was copied or cut\n             * @param {Boolean} isCut `true` if this was a cut action\n             * @param {String} entityName 'cell' to distinguish this event from other copy events\n             */\n            client.trigger('copy', { cells, copiedDataString, isCut, entityName });\n\n        }\n    }\n\n    /**\n     * Pastes string data into a cell or a range of cells. Either from native clipboard if that is accessible or from a\n     * fallback clipboard that is only available to the owner Grid.\n     *\n     * The string data will be split on `\\n` and `\\t` and put in different rows and columns accordingly.\n     *\n     * Note that there must be a selected cell to paste the data into.\n     * @async\n     */\n    async paste() {\n        const\n            me            = this,\n            {\n                client,\n                entityName\n            }             = me,\n            clipboardData = await BrowserHelper.readFromClipboard(me.useNativeClipboard),\n            targetCell    = client.selectedCells[0];\n\n        /**\n         * Fires on the owning Grid before a paste action is performed, return `false` to prevent the action\n         * @event beforePaste\n         * @preventable\n         * @on-owner\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {String} clipboardData The clipboardData about to be pasted\n         * @param {Grid.util.Location} targetCell The cell from which the paste will be started\n         * @param {String} entityName 'cell' to distinguish this event from other beforePaste events\n         */\n        if (\n            !me.canCutPaste ||\n            !clipboardData?.length ||\n            !targetCell ||\n            client.trigger('beforePaste', { clipboardData, targetCell, entityName }) === false\n        ) {\n            return;\n        }\n\n        const\n            modifiedRecords       = new Set(),\n            // Converts the clipboard data into a 2-dimensional array of string values.\n            rows                  = me.stringAs2dArray(clipboardData),\n            targetCells           = [],\n            { _shiftSelectRange } = client;\n\n        // No valid clipboard data, break\n        if (!rows?.length) {\n            return;\n        }\n\n        // If there is a selected range, pasting should be repeated into that range\n        if (_shiftSelectRange?.some(cell => cell.equals(targetCell))) {\n            const cellRows = me.cellSelectorsAs2dArray(_shiftSelectRange);\n\n            // The selection must fit the whole paste content. If pasting 2 rows for example, a number of rows that is\n            // divisible by 2 is required. Same for columns.\n            if (cellRows?.length % rows.length === 0 && cellRows.columnCount % rows.columnCount === 0) {\n                // This code will calculate each cell target to repeat the pasting on\n                for (let curI = 0; curI < cellRows.length; curI += rows.length) {\n                    for (let curX = 0; curX < cellRows.columnCount; curX += rows.columnCount) {\n                        targetCells.push(cellRows[curI][curX]);\n                    }\n                }\n            }\n        }\n\n        // No valid range, just use one target\n        if (!targetCells.length) {\n            targetCells.push(targetCell);\n        }\n\n        for (const targetCell of targetCells) {\n            for (let rI = 0; rI < rows.length; rI++) {\n                const\n                    row          = rows[rI],\n                    targetRecord = client.store.getAt(targetCell.rowIndex + rI);\n\n                // Starts with targetCell rowIndex and columnIndex and applies values from the clipboard string.\n                if (targetRecord && !targetRecord.readOnly) {\n                    for (let cI = 0; cI < row.length; cI++) {\n                        const\n                            targetColumn = client.columns.getAt(targetCell.columnIndex + cI),\n                            targetField  = targetColumn?.field;\n                        let value        = row[cI];\n\n                        // If no value, this column is skipped\n                        if (targetField && value && !targetColumn.readOnly) {\n                            if (value === me.emptyValueChar) {\n                                value = null;\n                            }\n\n                            // Column provided paste conversion function\n                            if (targetColumn.fromClipboardString) {\n                                value = targetColumn.fromClipboardString({\n                                    string : value,\n                                    record : targetRecord\n                                });\n                            }\n\n                            // Client provided paste customization function\n                            if (me.toPasteValue) {\n                                value = me.toPasteValue({\n                                    currentValue : value,\n                                    record       : targetRecord,\n                                    column       : targetColumn,\n                                    field        : targetField\n                                });\n                            }\n\n                            targetRecord.set(targetField, value, false, false, false, true);\n                            modifiedRecords.add(targetRecord);\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Fires on the owning Grid after a paste action is performed.\n         * @event paste\n         * @on-owner\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {String} clipboardData The clipboardData that was pasted\n         * @param {Core.data.Model[]} modifiedRecords The records which have been modified due to the paste action\n         * @param {Grid.util.Location} targetCell The cell from which the paste will be started\n         * @param {String} entityName 'cell' to distinguish this event from other paste events\n         */\n        client.trigger('paste', { clipboardData, targetCell, modifiedRecords : [...modifiedRecords], entityName });\n    }\n\n    /**\n     * Converts an array of Location objects to a two-dimensional array where first level is rows and second level is\n     * columns. If the array is inconsistent in the number of columns present for each row, the function will return\n     * false.\n     * @param {Grid.util.Location[]} locations\n     * @private\n     */\n    cellSelectorsAs2dArray(locations) {\n        const\n            rows = [];\n        let rId  = null,\n            columns;\n\n        for (const location of locations) {\n            // If new id (new record) create new \"row\"\n            if (location.id !== rId) {\n                rId = location.id;\n                columns = [];\n                rows.push(columns);\n            }\n            columns.push(location);\n        }\n\n        // Save number of \"columns\" for easier access\n        rows.columnCount = rows[0].length;\n\n        // All \"rows\" must have the same number of columns\n        if (rows.some(row => row.length !== rows.columnCount)) {\n            return false;\n        }\n\n        return rows;\n    }\n\n    /**\n     * Converts a new-line- and tab-separated string to a two-dimensional array where first level is rows and second\n     * level is columns. If the string is inconsistent in the number of columns present for each row, the function will\n     * return false.\n     * @param {String} string String values separated with new-line(\\n,\\r or similar) and tabs (\\t)\n     * @private\n     */\n    stringAs2dArray(string) {\n        const\n            rows       = [],\n            stringRows = string.split(/\\r\\n|(?!\\r\\n)[\\n-\\r\\x85\\u2028\\u2029]/);\n\n        for (const row of stringRows) {\n            const columns = row.split('\\t');\n\n            // All \"rows\" must have the same number of columns\n            if (rows.columnCount && columns.length !== rows.columnCount) {\n                return false;\n            }\n            // Save number of \"columns\" for easier access\n            rows.columnCount = columns.length;\n            rows.push(columns);\n        }\n        return rows;\n    }\n\n    populateCellMenu({ record, items }) {\n        const me = this;\n\n        if (me.canCopy) {\n            items.cutCell = {\n                text        : me.cutText,\n                localeClass : me,\n                icon        : 'b-icon b-icon-cut',\n                weight      : 115,\n                disabled    : record.readOnly || !me.canCutPaste,\n                onItem      : () => me.cut()\n            };\n\n            items.pasteCell = {\n                text        : me.pasteText,\n                localeClass : me,\n                icon        : 'b-icon b-icon-paste',\n                weight      : 120,\n                disabled    : record.readOnly || !me.canCutPaste,\n                onItem      : () => me.paste()\n            };\n\n            items.copyCell = {\n                text        : me.copyText,\n                localeClass : me,\n                cls         : 'b-separator',\n                icon        : 'b-icon b-icon-copy',\n                weight      : 110,\n                onItem      : () => me.copy()\n            };\n        }\n    }\n}\n\nGridFeatureManager.registerFeature(CellCopyPaste);\n","import Objects from '../../Core/helper/util/Objects.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\n\n/**\n * @module Grid/feature/CellTooltip\n */\n\n/**\n * Displays a tooltip when hovering cells.\n *\n * {@inlineexample Grid/feature/CellTooltip.js}\n *\n * To show contents when hovering a cell, you can specify a global {@link #config-tooltipRenderer} function for the\n * feature, you can also define a {@link Grid.column.Column#config-tooltipRenderer} for individual columns.\n *\n * ```javascript\n * // Column with its own tooltip renderer\n * {\n *   text            : 'Name',\n *   field           : 'name',\n *   tooltipRenderer : ({ record }) => `My name is\\xa0<b>${record.name}</b>`\n * }\n * ```\n *\n * Configuration properties passed into this feature are used to configure the {@link Core.widget.Tooltip} instance\n * used.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ## Showing async content\n * Showing remotely loaded content is super easy using the {@link #config-tooltipRenderer}:\n *\n * ```javascript\n * // Async tooltip with some custom settings\n * const grid = new Grid({\n *   features: {\n *     cellTooltip: {\n *       // Time that mouse needs to be over cell before tooltip is shown\n *       hoverDelay : 4000,\n *       // Time after mouse out to hide the tooltip, 0 = instantly\n *       hideDelay  : 0,\n *       // Async tooltip renderer, return a Promise which yields the text content\n *       tooltipRenderer({ record, tip }) {\n *         return fetch(`tip.php?id=${record.id}`).then(response => response.text())\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @extendsconfigs Core/widget/Tooltip\n * @demo Grid/celltooltip\n * @classtype cellTooltip\n * @feature\n */\nexport default class CellTooltip extends InstancePlugin {\n    //region Config\n\n    static $name = 'CellTooltip';\n\n    static configurable = {\n        /**\n         * Function called to generate the HTML content for the cell tooltip.\n         * The function should return a string (your HTML), or a Promise yielding a string (for remotely loaded\n         * content)\n         * @prp {Function}\n         * @param {Object} context\n         * @param {HTMLElement} context.cellElement The cell element\n         * @param {Core.data.Model} context.record The row record\n         * @param {Grid.column.Column} context.column The column\n         * @param {Core.widget.Tooltip} context.tip The Tooltip instance\n         * @param {Grid.feature.CellTooltip} context.cellTooltip The feature\n         * @param {Event} context.event The raw DOM event\n         * @returns {String|Promise}\n         */\n        tooltipRenderer : null\n    };\n\n    //endregion\n\n    // region Init\n\n    construct(grid, config) {\n        super.construct(grid, this.processConfig(config));\n    }\n\n    initTip() {\n        const me = this;\n\n        me.tip = Tooltip.new({\n            forElement        : me.client.element,\n            forSelector       : '.b-grid-row:not(.b-group-row) .b-grid-cell, .b-grid-merged-cells',\n            hoverDelay        : 1000,\n            trackMouse        : false,\n            cls               : 'b-celltooltip-tip',\n            getHtml           : me.getTooltipContent.bind(me),\n            internalListeners : {\n                pointerOver : 'onPointerOver',\n                thisObj     : me\n            },\n            listeners : me.configuredListeners\n        }, me.initialConfig);\n\n        me.relayEvents(me.tip, ['beforeShow', 'show']);\n    }\n\n    onPointerOver({ target }) {\n        const column = this.client.getColumnFromElement(target);\n\n        // Veto onPointerOver if column's tooltipRenderer is false\n        return column.tooltipRenderer !== false && Boolean(column.tooltipRenderer || this.tooltipRenderer);\n    }\n\n    // CellTooltip feature handles special config cases, where user can supply a function to use as tooltipRenderer\n    // instead of a normal config object\n    processConfig(config) {\n        if (typeof config === 'function') {\n            return {\n                tooltipRenderer : config\n            };\n        }\n\n        return config;\n    }\n\n    // override setConfig to process config before applying it (used mainly from ReactGrid)\n    setConfig(config) {\n        super.setConfig(this.processConfig(config));\n    }\n\n    doDestroy() {\n        this.tip && this.tip.destroy();\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        if (!disable) {\n            this.initTip();\n        }\n        else if (this.tip) {\n            this.tip.destroy();\n            this.tip = null;\n        }\n\n        super.doDisable(disable);\n    }\n\n    //endregion\n\n    //region Content\n\n    /**\n     * Called from Tooltip to populate it with html.\n     * @private\n     */\n    getTooltipContent({ tip, activeTarget : cellElement, event }) {\n        const\n            me     = this,\n            record = me.client.getRecordFromElement(cellElement),\n            column = me.client.getColumnFromElement(cellElement),\n            arg    = { cellElement, record, column, event, tip, cellTooltip : me };\n\n        let result;\n\n        // If we have not changed context, we should not change content, unless we have a custom target selector (element within the cell)\n        if (!me.forSelector && record === me.lastRecord && record.generation === me.lastRecordGeneration && column === me.lastColumn) {\n            return me.tip._html;\n        }\n\n        me.lastRecord = record;\n        me.lastRecordGeneration = record.generation;\n        me.lastColumn = column;\n\n        // first, use columns tooltipRenderer if any\n        if (column.tooltipRenderer) {\n            result = column.tooltipRenderer(arg);\n        }\n        // secondly, try feature's renderer (specifying column.tooltipRenderer as false prevents tooltip in that column)\n        else if (me.tooltipRenderer && column.tooltipRenderer !== false) {\n            result = me.tooltipRenderer(arg);\n        }\n\n        // No caching of async requests\n        if (Objects.isPromise(result)) {\n            me.lastRecord = me.lastRecordGeneration = me.lastColumn = null;\n        }\n\n        return result;\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(CellTooltip);\n","import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Editor from '../../Core/widget/Editor.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\n\n/**\n * @module Grid/feature/ColumnRename\n */\n\n/**\n * Allows user to rename columns by either right-clicking column header or using keyboard shortcuts when column header\n * is focused.\n *\n * To get notified about column renaming listen to `change` event on {@link Grid.data.ColumnStore columns} store.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * {@inlineexample Grid/feature/ColumnRename.js}\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys          | Action           | Action description                        |\n * |---------------|------------------|-------------------------------------------|\n * | F2            | startEdit        | Starts editing focused column header text |\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @demo Grid/columns\n * @classtype columnRename\n * @feature\n */\nexport default class ColumnRename extends InstancePlugin {\n\n    static $name = 'ColumnRename';\n\n    static configurable = {\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            F2 : 'startEdit'\n        }\n    }\n\n    doDestroy() {\n        this.editor?.destroy();\n        super.doDestroy();\n    }\n\n    static get pluginConfig() {\n        return {\n            after : ['populateHeaderMenu']\n        };\n    }\n\n    populateHeaderMenu({ items, column }) {\n        items.rename = {\n            weight   : 215,\n            icon     : 'b-fw-icon b-icon-edit',\n            text     : this.L('L{rename}'),\n            disabled : column.readOnly,\n            onItem   : () => this.startEdit(column)\n        };\n    }\n\n    startEdit(column) {\n        if (column instanceof Event) {\n            // If started editing by key\n            column = this.client.getHeaderDataFromEvent(column)?.column;\n        }\n\n        if (column) {\n            if (column.readOnly) {\n                // return false to let keyMap know that we didn't handle this event\n                return false;\n            }\n\n            const { textWrapper } = column;\n            let { editor } = this;\n\n            if (!editor) {\n                this.editor = editor = new Editor({\n                    owner : this.client,\n                    align : {\n                        align : 't0-t0'\n                    }\n                });\n            }\n\n            editor.render(textWrapper);\n\n            editor.startEdit({\n                target : textWrapper,\n                record : column,\n                field  : 'text'\n            });\n        }\n    }\n}\n\nGridFeatureManager.registerFeature(ColumnRename, false);\n","import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Location from '../../Grid/util/Location.js';\nimport GlobalEvents from '../../Core/GlobalEvents.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\n\n/**\n * @module Grid/feature/FillHandle\n */\n\n/**\n * This features adds a fill handle to a Grid range selection, which when dragged, fills the cells being dragged over\n * with values based on the values in the original selected range. This is similar to functionality normally seen in\n * various spreadsheet applications.\n *\n * {@inlineexample Grid/feature/FillHandle.js}\n *\n * Requires {@link Grid/view/Grid#config-selectionMode selectionMode.cell} to be activated.\n *\n * This feature is **disabled** by default\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         fillHandle : true\n *     }\n * });\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype fillHandle\n * @feature\n */\nexport default class FillHandle extends InstancePlugin.mixin(Delayable) {\n    static $name = 'FillHandle';\n\n    static configurable = {\n        /**\n         * Implement this function to be able to customize the value that cells will be filled with.\n         * Return `undefined` to use default calculations.\n         *\n         * ````javascript\n         * new Grid({\n         *    features : {\n         *        fillHandle : {\n         *           calculateFillValue({cell, column, range, record}) {\n         *              if(column.field === 'number') {\n         *                 return range.reduce(\n         *                    (sum, location) => sum + location.record[location.column.field]\n         *                 );\n         *              }\n         *           }\n         *        }\n         *    }\n         * });\n         * ````\n         *\n         * @param {Object} data Object containing information about current cell and fill value\n         * @param {Grid.util.Location} data.cell Current cell data\n         * @param {Grid.column.Column} data.column Current cell column\n         * @param {Grid.util.Location[]} data.range Range from where to calculate values\n         * @param {Core.data.Model} data.record Current cell record\n         * @returns {String|Number|Date} Value to fill current cell\n         * @config {Function}\n         */\n        calculateFillValue : null,\n\n        /**\n         * Set to `true` to enable the fill range to crop the original selected range. This clears the cells which were\n         * a part of the original selected range, but are no longer a part of the smaller range.\n         * @config {Boolean}\n         */\n        allowCropping : false\n\n    }\n\n    // Plugin configuration. This plugin chains/overrides some functions in Grid.\n    static pluginConfig = {\n        chain    : ['afterSelectionChange', 'onContentChange', 'afterColumnsChange', 'fixElementHeights'],\n        override : ['getCellDataFromEvent']\n    }\n\n    afterConstruct() {\n        super.afterConstruct();\n\n        if (!this.client.selectionMode.cell) {\n            this.disabled = true;\n        }\n\n        this._fillListeners = {};\n    }\n\n    delayable = {\n        handleSelection : 'raf'\n    }\n\n    onContentChange() {\n        this.handleSelection();\n    }\n\n    afterColumnsChange() {\n        this.handleSelection();\n    }\n\n    fixElementHeights() {\n        this.handleSelection();\n    }\n\n    getCellDataFromEvent(event, includeSingleAxisMatch) {\n        if (includeSingleAxisMatch) {\n            includeSingleAxisMatch = !event.target.classList.contains('b-fill-handle');\n        }\n        return this.overridden.getCellDataFromEvent(event, includeSingleAxisMatch);\n    }\n\n    // region Pattern recognition\n    findPatternsIn2dRange(range, horizontal, negative) {\n        const values = {};\n\n        // Converts a cellselector range to values per column or row\n        for (const cell of range) {\n            const\n                id    = horizontal ? cell.id : cell.columnId;\n            let value = cell.record[cell.column.field];\n\n            // If a number string, convert to number\n            if (value && typeof value === 'string' && !isNaN(value)) {\n                value = parseFloat(value);\n            }\n\n            if (!values[id]) {\n                values[id] = [];\n            }\n            values[id].push(value);\n        }\n\n        // Find patterns for each column or row in range\n        for (const rowOrCol in values) {\n            values[rowOrCol].pattern = this.findPatternsIn1dRange(values[rowOrCol], negative);\n        }\n\n        return values;\n    }\n\n    findPatternsIn1dRange(range, negative) {\n        const\n            lastValue = range[negative ? 0 : (range.length - 1)],\n            pattern   = {\n                next : () => lastValue,\n                lastValue\n            };\n\n        // If all values in same column/row is either number or date\n        if (range.every(val => typeof val === 'number') || range.every(val => val instanceof Date)) {\n            const diffs = range.map((val, ix) => val - range[ix - 1]);\n            diffs.shift(); // Removes initial NaN\n\n            // Found a repeating pattern\n            if (new Set(diffs).size === 1) {\n                pattern.increaseBy = diffs[0] * (negative ? -1 : 1);\n\n                pattern.next = () => {\n                    if (pattern.lastValue instanceof Date) {\n                        pattern.lastValue = new Date(pattern.lastValue.getTime() + pattern.increaseBy);\n                    }\n                    else {\n                        pattern.lastValue += pattern.increaseBy;\n                    }\n                    return pattern.lastValue;\n                };\n            }\n        }\n        // Else it's treated as a string value\n        else if (range.length > 1) {\n            pattern.stringPattern = [...range];\n            pattern.next = () => {\n                if (pattern.currentIndex === undefined) {\n                    pattern.currentIndex = 0;\n                }\n                else {\n                    pattern.currentIndex += 1;\n                    if (pattern.currentIndex >= pattern.stringPattern.length) {\n                        pattern.currentIndex = 0;\n                    }\n                }\n                return pattern.stringPattern[pattern.currentIndex];\n            };\n        }\n        return pattern;\n    }\n\n    // endregion\n\n    afterSelectionChange() {\n        const me = this;\n\n        // If selection isn't finished, wait for mouse up and then add fill elements\n        if (GlobalEvents.isMouseDown()) {\n            me.client.delayUntilMouseUp(() => me.handleSelection(true));\n            // Remove prev elements immediately in this case\n            me.removeElements();\n        }\n        // Otherwise, add fill elements immediately\n        else {\n            me.handleSelection(true);\n        }\n    }\n\n    /**\n     * Checks selection and sees to it that fill handle and border is drawn.\n     * Runs on next animation frame\n     * @internal\n     */\n    handleSelection() {\n        if (!this._isExtending) {\n            const range = this.rangeSelection;\n\n            if (range) {\n                this.drawFillHandleAndBorder(range[0], range[range.length - 1]);\n            }\n            else {\n                this.removeElements();\n            }\n        }\n    }\n\n    // region Mouse events\n\n    // On fillHandle mouse down only\n    onMouseDown(event) {\n        this._fillListeners.mouseMoveOrUp = EventHelper.on({\n            element   : globalThis,\n            mouseover : 'onMouseOver',\n            mouseup   : 'onMouseUp',\n            thisObj   : this\n        });\n        event.stopImmediatePropagation();\n        event.handled = true;\n    }\n\n    // Responsible for doing the filling\n    onMouseUp() {\n        const\n            me              = this,\n            {\n                client,\n                currentRange,\n                _isCropping\n            }               = me,\n            range           = me.rangeSelection,\n            selectionChange = range && currentRange && client.internalSelectRange(currentRange.from, currentRange.to),\n            selectedCells   = selectionChange?.selectedCells || [],\n            // For extending : Only modify cells that are not a part of original range\n            // For cropping  : Only clear cells that are not a part of new selection\n            extensionCells  = _isCropping ? me.croppingCells\n                : selectedCells.filter(cell => !range.some(sel => sel.equals(cell, true)));\n\n        delete me._isCropping; // Removing flag in case we bail out early\n\n        if (me._isExtending) {\n            client.disableScrollingCloseToEdges(client.items);\n            delete me._isExtending;\n        }\n\n        // If no extension, do nothing\n        if (!extensionCells?.length) {\n            me.handleSelection();\n            return;\n        }\n\n        client.suspendRefresh();\n\n        // If trimming (inverted extension), clear cells that where previously selected and not a part of new selection\n        if (_isCropping) {\n            extensionCells.forEach(cell => cell.record.set(cell.column.field, null, false, false, false, true));\n        }\n        // Extending cell values depending on pattern\n        else {\n            const\n                [firstCell] = extensionCells,\n                // If extensioncells has a record that is included in original selection, then we are dragging horizontally\n                horizontal  = range.some(sel => sel.record === firstCell.record),\n                // negative in this aspect, means dragging either upwards or to the left depending on horizontal or vertical\n                negative    = horizontal\n                    ? firstCell.columnIndex < range[0].columnIndex\n                    : firstCell.rowIndex < range[0].rowIndex,\n                patterns    = me.findPatternsIn2dRange(range, horizontal, negative),\n                changeMap   = new Map();\n\n            if (negative) {\n                extensionCells.reverse();\n            }\n\n            for (const cell of extensionCells) {\n                const { column, record } = cell;\n\n                if (column.canFillValue({ range, record, cell })) {\n                    let value   = me.calculateFillValue?.({ range, column, record, cell }),\n                        changed = changeMap.get(record);\n\n                    if (!changed) {\n                        changed = {};\n                        changeMap.set(record, changed);\n                    }\n\n                    if (value === undefined) {\n                        const pattern = patterns[horizontal ? cell.id : cell.columnId].pattern;\n                        value = pattern.next();\n                    }\n\n                    changed[column.field] = column.calculateFillValue?.({ value, record, range }) || value;\n                }\n            }\n\n            for (const [record, changes] of changeMap) {\n                record.set(changes, null, null, null, null, true);\n            }\n        }\n\n        client.resumeRefresh(true);\n\n        // Selects the extended area\n        client.performSelection(selectionChange);\n\n        delete me.currentRange;\n        me.handleSelection();\n    }\n\n    // The fill border and handle should refresh on mouse move\n    onMouseOver(event) {\n        const\n            me           = this,\n            {\n                client,\n                rangeSelection\n            }            = me,\n            first        = rangeSelection[0],\n            last         = rangeSelection[rangeSelection.length - 1],\n            cellData     = client.getCellDataFromEvent(event, true);\n        let cellSelector = cellData && client.normalizeCellContext(cellData.cellSelector);\n\n        if (cellSelector?._column?.region === first._column.region) {\n            const\n                equalOrSmaller = rangeSelection.some(cs => cs.equals(cellSelector, true));\n            let negative;\n\n            if (!me._isExtending) {\n                client.enableScrollingCloseToEdges(client.items);\n            }\n\n            if (equalOrSmaller) {\n                // If were smaller, were cropping (if it's allowed)\n                me._isCropping = me.allowCropping &&\n                    (cellSelector.rowIndex < last.rowIndex || cellSelector.columnIndex < last.columnIndex);\n            }\n            else {\n                // If cellSelector is on a row in range, endSelector should be current column but end/first row\n                if (cellSelector.rowIndex >= first.rowIndex && cellSelector.rowIndex <= last.rowIndex) {\n                    negative     = first.columnIndex > cellSelector.columnIndex;\n                    cellSelector = new Location({\n                        grid   : client,\n                        record : negative ? first.record : last.record,\n                        column : cellSelector.column\n                    });\n                }\n                // Else endSelector should be current row but end/first column\n                else {\n                    negative     = first.rowIndex > cellSelector.rowIndex;\n                    cellSelector = new Location({\n                        grid   : client,\n                        record : cellSelector.record,\n                        column : negative ? first.column : last.column\n                    });\n                }\n            }\n\n            // negative means that current mouse over cell is above or to the left\n            const\n                // If negative, draw from calculated mouse over cell\n                // otherwise, draw from top-left selection cell\n                from = negative ? cellSelector : first,\n                // If negative or were inside selection (but not cropping), draw to bottom-right selection cell\n                // otherwise, draw to calculated mouse over cell\n                to   = negative || (equalOrSmaller && !me._isCropping) ? last : cellSelector;\n\n            me.currentRange = { from, to };\n\n            // This flag is true even if were trimming\n            me._isExtending = true;\n\n            me.drawFillHandleAndBorder(from, to, true);\n        }\n    }\n\n    // endregion\n\n    // region Creating, updating and removing fillhandle and fillborder\n    drawFillHandleAndBorder(from, to, keepListeners = false) {\n        const\n            me        = this,\n            {\n                client,\n                currentRange,\n                _fillListeners\n            }         = me,\n            regionEl  = client.subGrids[from.column.region].element,\n            { x }     = Rectangle.from(from.cell || from.column.element, regionEl),\n            { right } = Rectangle.from(to.cell || to.column.element, regionEl),\n            { y }     = client.getRecordCoords(from.record, true),\n            bottom    = client.getRecordCoords(to.record, true).bottom - 1;\n        let {\n            borderElement,\n            handleElement\n        }             = me;\n\n        me.removeElements(keepListeners);\n\n        if (!borderElement) {\n            me.borderElement = borderElement = DomHelper.createElement({\n                className : 'b-fill-selection-border'\n            });\n\n            me.handleElement = handleElement = DomHelper.createElement({\n                className : 'b-fill-handle'\n            });\n        }\n\n        DomHelper.setRect(borderElement, { y, x, width : (right - x), height : (bottom - y) });\n        regionEl.appendChild(borderElement);\n\n        // If fill handle is drawn at right edge, put it to the left instead\n        DomHelper.setTopLeft(handleElement, bottom, right >= regionEl.scrollWidth ? x : right);\n        regionEl.appendChild(handleElement);\n\n        // Remove all previously cropping cls\n        me.toggleCroppingCls(false);\n        delete me.croppingCells;\n\n        // If were cropping, we should add cls class to the cells that will be \"shrunk\"\n        if (me._isCropping && me.rangeSelection?.length) {\n            const newCells = client.getRange(currentRange.from, currentRange.to);\n\n            me.croppingCells = me.rangeSelection.filter(sel => !newCells.some(cell => cell.equals(sel, true)));\n            me.toggleCroppingCls();\n        }\n\n        if (!_fillListeners.handleClick) {\n            _fillListeners.handleClick = EventHelper.on({\n                element   : globalThis,\n                delegate  : '.b-fill-handle',\n                mousedown : 'onMouseDown',\n                thisObj   : me\n            });\n        }\n\n        me.hasFillElements = true;\n    }\n\n    toggleCroppingCls(add = true) {\n        this.croppingCells?.forEach(sel => this.client.getCell(sel)?.classList.toggle('b-indicate-crop', add));\n    }\n\n    removeElements(keepListeners = false) {\n        const me = this;\n\n        me.handleElement?.remove();\n        me.borderElement?.remove();\n\n        if (!keepListeners) {\n            me.removeListeners();\n        }\n\n        me.hasFillElements = false;\n    }\n\n    // Detach listeners\n    removeListeners() {\n        const me = this;\n\n        for (const listener in me._fillListeners) {\n            me._fillListeners[listener]();\n        }\n        me._fillListeners = {};\n    }\n\n    // endregion\n\n    // Gets current selection range. Only allows for single range or single cell.\n    get rangeSelection() {\n        const\n            { client }        = this,\n            { selectedCells } = client,\n            range             = client._shiftSelectRange ?? (selectedCells.length === 1 && selectedCells);\n\n        // We only got one selected range, nothing else selected\n        // Only allow fill handle on single region selection\n        if (!client.selectedRecords.length && range?.length && range.length === selectedCells.length &&\n            range.every(c1 => selectedCells.some(c2 => c1.equals(c2, true)) &&\n                c1._column.parent && c1._column.region === range[0]._column.region && client.store.isAvailable(c1.id)\n            )\n        ) {\n            return range;\n        }\n\n        return null;\n    }\n}\n\nGridFeatureManager.registerFeature(FillHandle);\n","import ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport DomClassList from '../../Core/helper/util/DomClassList.js';\n\n/**\n * @module Grid/feature/MergeCells\n */\n\n// Maps DOM events to relayed events that need correct casing\nconst camelCase = {\n    mousedown   : 'mouseDown',\n    mousemove   : 'mouseMove',\n    mouseup     : 'mouseUp',\n    touchdown   : 'touchDown',\n    touchmove   : 'touchMove',\n    touchup     : 'touchUp',\n    mouseover   : 'mouseOver',\n    mouseout    : 'mouseOut',\n    dblclick    : 'dblClick',\n    keydown     : 'keyDown',\n    keypress    : 'keyPress',\n    keyup       : 'keyUp',\n    contextmenu : 'contextMenu'\n};\n\n/**\n * This feature merges cells that have the same value in sorted columns configured to\n * {@link Grid/column/Column#config-mergeCells}. The content of merged cells is sticky for Grids with a single subgrid\n * section when all columns fit in view (content stays in view until the cell is scrolled fully out of view).\n *\n * <div class=\"note\">Support for sticky content is limited because of how <code>position: sticky</code> works. Grid\n * scrolls vertically in one element, and horizontally in another (to support multiple regions in the grid), and this\n * setup is not supported by current browsers implementation of sticky positioning</div>\n *\n * Try scrolling in the demo below. Also try sorting by the other columns (\"City\" and \"Favorite food\" are configured\n * to merge cells):\n *\n * {@inlineexample Grid/feature/MergeCells.js}\n *\n * This feature is **disabled** by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype mergeCells\n * @feature\n */\nexport default class MergeCells extends InstancePlugin {\n    //region Config\n\n    static $name = 'MergeCells';\n\n    static configurable = {\n        /**\n         * By default merged cells allow pointer events to pass through to the underlying row/cell, to allow selecting a\n         * row and editing an individual cell even when they are merged. Configure as `false` to allow merged cells to\n         * catch and react to the pointer events instead.\n         *\n         * ```javascript\n         * const grid = new Grid({\n         *     features : {\n         *         mergeCells : {\n         *             // Let merged cells react to pointer events\n         *             passthrough : false\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         */\n        passthrough : true\n    }\n\n    // All current ranges (once rendered)\n    mergedRanges = [];\n    // Ranges indexed by row index & column id -> Each range included multiple times, for easy lookup\n    mergedMap    = {};\n\n    static get pluginConfig() {\n        return {\n            chain : [\n                'beforeRenderCell',\n                'afterRenderRow',\n                'bindStore',\n                'afterColumnsChange',\n                'afterRemove',\n                'afterToggleGroup',\n                'afterToggleSubGrid',\n                'handleEvent',\n                'populateHeaderMenu',\n                // 'setHoveredRow'\n                'afterSelectionChange'\n            ],\n\n            // Grid must perform its update *after* we do.\n            before : [\n                'onInternalResize'\n            ],\n            override : [\n                'getColumnFromElement',\n                'getRecordFromElement'\n            ]\n        };\n    };\n\n    //endregion\n\n    //region Init\n\n    afterConstruct() {\n        const\n            me         = this,\n            { client } = me;\n\n        // Each subgrid gets a merged cells container\n        client.eachSubGrid(subGrid => me.setupSubGrid(subGrid));\n\n        // Merged cells are synced after rows are updated\n        client.rowManager.ion({\n            renderDone : 'onRenderDone',\n            thisObj    : me\n        });\n\n        me.bindStore(client.store);\n    }\n\n    setupSubGrid(subGrid) {\n        // Element that will contain the merged cells\n        subGrid.$mergedCellsElement = DomHelper.createElement({\n            parent    : subGrid.element,\n            className : {\n                'b-grid-merged-cells-container' : 1\n            }\n        });\n    }\n\n    doDisable(disable) {\n        if (!this.isConfiguring) {\n            // Flag to allow reset to redraw even though we are already disabled at this stage\n            this.isDisabling = true;\n            this.reset();\n            this.isDisabling = false;\n        }\n\n        super.doDisable(disable);\n    }\n\n    updatePassthrough(use) {\n        // Toggle CSS class that has `pointer-events : none`\n        this.client.element.classList.toggle('b-mergecells-passthrough', use);\n    }\n\n    //endregion\n\n    //region Grid hooks\n\n    bindStore(store) {\n        this.detachListeners('store');\n\n        store.ion({\n            name    : 'store',\n            change  : 'onStoreChange',\n            // Call our refresh logic before grids\n            refresh : {\n                prio : 1,\n                fn   : 'onStoreRefresh'\n            },\n            thisObj : this\n        });\n    }\n\n    // Refresh all ranges when grid is resized\n    onInternalResize() {\n        this.refreshBounds();\n    }\n\n    // Get / create ranges before cell contents are rendered, redirecting the contents to the range\n    beforeRenderCell(renderData) {\n        const\n            { column, record, cellElement } = renderData,\n            subGrid                         = this.client.subGrids[column.region];\n\n        // Only affect sorted columns configured to merge cells\n        if (!this.disabled && column.mergeCells && column.isSorted && !record.isSpecialRow && !subGrid.collapsed) {\n            const mergedRange = this.getMergeRange(record, column);\n            if (mergedRange?.use) {\n                // Flag the unmerged cell to allow styling it\n                cellElement.classList.add('b-merged-cell');\n                // Make sure it is empty\n                cellElement.innerHTML = '';\n                // Redirect output to the merged cell\n                renderData.cellElement = mergedRange.cellElement;\n\n                // TODO Consider bailing out after rendering first available cell of a merge. It would help with\n                //  performance, but any side effects from the renderer would be lost (such as assigning classes to row)\n            }\n        }\n    }\n\n    afterRenderRow({ row, oldId, oldHeight }) {\n        // Row reused for same record changed height\n        if (oldId === row.id && oldHeight !== row.height) {\n            this.heightChanged = true;\n        }\n    }\n\n    // Refresh all ranges when a column is resized (since it might affect their position and size)\n    afterColumnsChange({ action, changes, column }) {\n        if (this.disabled) {\n            return;\n        }\n\n        if (action === 'update' && changes.mergeCells && !column.mergeCells) {\n            // Remove all ranges for the column when mergeCells is set to false\n            for (const range of this.mergedRanges.slice()) {\n                if (range.column === column) {\n                    this.removeRange(range);\n                }\n            }\n\n            this.syncDom();\n            return;\n        }\n\n        this.refreshBounds();\n    }\n\n    // Remove might be transitioned, wait until it finishes before resetting (in the afterRemove hook)\n    afterRemove() {\n        !this.disabled && this.reset();\n    }\n\n    // Group collapsed or expanded\n    afterToggleGroup() {\n        !this.disabled && this.reset();\n    }\n\n    // SubGrid collapsed or expanded\n    afterToggleSubGrid() {\n        !this.disabled && this.reset();\n    }\n\n    // setHoveredRow(row) {\n    //     this.$hovered = row && this.mergedRanges.find(r => r.fromIndex <= row.dataIndex && r.toIndex >= row.dataIndex);\n    //\n    //     this.syncDom();\n    // }\n\n    // Selection changed, range is considered selected when all of its rows are selected (only in passthrough mode)\n    afterSelectionChange() {\n        if (!this.passthrough) {\n            const\n                { client } = this,\n                indices    = client.selectedRecords.map(r => client.store.indexOf(r));\n            let changed    = false;\n\n            for (const range of this.mergedRanges) {\n                let allSelected = true;\n                // Check if all records in the range are selected\n                for (let i = range.fromIndex; i <= range.toIndex && allSelected; i++) {\n                    allSelected = indices.includes(i);\n                }\n\n                if (range.isSelected !== allSelected) {\n                    range.isSelected = allSelected;\n                    changed = true;\n                }\n            }\n\n            // Only redraw if a range selection status changed\n            changed && this.syncDom();\n        }\n    }\n\n    //endregion\n\n    //region Grid overrides\n\n    // Extract record from merged cells\n    getRecordFromElement(element) {\n        if (element.elementData?.range) {\n            return this.client.store.getAt(element.elementData.range.fromIndex);\n        }\n\n        return this.overridden.getRecordFromElement(element);\n    }\n\n    // Extract column from merged cells\n    getColumnFromElement(element) {\n        if (element.elementData?.range) {\n            return element.elementData.range.column;\n        }\n\n        return this.overridden.getColumnFromElement(element);\n    }\n\n    //endregion\n\n    //region Header menu\n\n    // Allow toggling merging cells from the column header menu (unless column is explicitly disallowing it)\n    populateHeaderMenu({ column, items }) {\n        if (column.mergeable !== false) {\n            items.mergeCells = {\n                text     : 'L{MergeCells.mergeCells}',\n                icon     : `b-fw-icon ${column.mergeCells ? 'b-icon-checked' : 'b-icon-unchecked'}`,\n                tooltip  : 'L{MergeCells.menuTooltip}',\n                cls      : 'b-separator',\n                weight   : 500,\n                disabled : this.disabled,\n                onItem   : () => column.mergeCells = !column.mergeCells\n            };\n        }\n    }\n\n    //endregion\n\n    //region Relaying events\n\n    // Relay pointer events from the merged cell on grid\n    async handleEvent(event) {\n        if (!this.passthrough) {\n            const mergedCellsElement = event.target.closest('.b-grid-merged-cells');\n\n            if (mergedCellsElement) {\n                const\n                    { client }   = this,\n                    { range }    = mergedCellsElement.elementData,\n                    { cellEdit } = client.features,\n                    { column }   = range,\n                    type         = StringHelper.capitalize(camelCase[event.type] ?? event.type),\n                    eventData    = {\n                        grid        : client,\n                        records     : [],\n                        column,\n                        cellElement : mergedCellsElement.firstElementChild,\n                        target      : event.target,\n                        event\n                    };\n\n                for (let i = range.fromIndex; i <= range.toIndex; i++) {\n                    eventData.records.push(client.store.getAt(i));\n                }\n\n                client.trigger(`mergedCell${type}`, eventData);\n\n                // Cell editing, pass through to cell underneath even when not using passthrough mode\n                if (cellEdit?.triggerEvent.toLowerCase() === `cell${type}`.toLowerCase()) {\n                    const row = client.rowManager.getRowAt(event.clientY);\n                    await cellEdit.startEditing({ id : row.id, columnId : column.id });\n                }\n                // Select ranges rows when clicking the merged cell\n                else if (event.type === 'click') {\n                    this.onRangeClick({ range });\n                }\n            }\n        }\n    }\n\n    //endregion\n\n    //region Event listeners\n\n    // Select ranges rows when clicking a merged cell\n    onRangeClick({ range }) {\n        const records = [];\n\n        for (let i = range.fromIndex; i <= range.toIndex; i++) {\n            records.push(this.client.store.getAt(i));\n        }\n\n        this.client.selectedRecords = records;\n    }\n\n    // Reset when data changes\n    onStoreChange() {\n        !this.disabled && this.reset();\n    }\n\n    // Reset before grids refresh listener come into play, grid will redraw\n    onStoreRefresh({ action }) {\n        // filter & dataset triggers change too, handled above\n        if (action !== 'filter' && action !== 'dataset') {\n            !this.disabled && this.reset(false);\n        }\n    }\n\n    //endregion\n\n    //region Render\n\n    // Element is needed early since it is passed to column renderers, and syncing for each rendered cell would give a\n    // lot of overhead. Thus creating element directly instead\n    createRangeElement(range) {\n        const\n            parent = this.client.getSubGridFromColumn(range.column).$mergedCellsElement,\n            syncId = `${range.fromIndex}-@-${range.column.id}`;\n\n        // If there is already an element for the range (also if previously released), we grab that one.\n        // We are bending the rules of DomSync here by spawning the element early\n        let element = parent.syncIdMap?.[syncId] ?? parent.releasedIdMap?.[syncId];\n\n        // No longer considered released\n        if (parent.releasedIdMap) {\n            delete parent.releasedIdMap[syncId];\n        }\n\n        if (!element) {\n            element = DomHelper.createElement(this.createRangeDomConfig(range));\n        }\n\n        // New element or reusing released one, DomSync need to be made aware\n        DomSync.addChild(parent, element, syncId);\n\n        range.element = element;\n        range.cellElement = element.firstElementChild;\n\n        return element;\n    }\n\n    // Create a DomConfig object for the supplied range, used initially with DomHelper and thereafter with DomSync\n    createRangeDomConfig(range) {\n        const\n            { column, fromIndex, toIndex, top, left, width, height } = range,\n            { type } = column,\n            record = this.client.store.getAt(fromIndex),\n            domConfig = {\n                className : {\n                    'b-grid-merged-cells' : 1,\n                    // 'b-hover'             : this.$hovered === range,\n                    'b-selected'          : range.isSelected\n                },\n                elementData : {\n                    range\n                },\n                style : {\n                    top,\n                    left,\n                    height,\n                    width\n                },\n                dataset : {\n                    syncId   : `${fromIndex}-@-${column.id}`,\n                    fromIndex,\n                    toIndex,\n                    column   : column.field,\n                    columnId : column.id\n                },\n                children : [\n                    // Div for an actual cell\n                    {\n                        className : new DomClassList(this.client.cellCls).assign({\n                            [`b-${type?.toLowerCase()}-cell`] : type,\n                            [column.cellCls]                  : column.cellCls,\n                            [column.internalCellCls]          : column.internalCellCls\n                        }).assign(column.autoCls),\n                        // Dont touch cell children that might have been added by renderer\n                        keepChildren : true,\n                        // Tag along the range for easy resolving later\n                        elementData  : {\n                            range\n                        },\n                        // Dataset expected on cells\n                        dataset : {\n                            column   : column.field,\n                            columnId : column.id\n                        },\n                        // Size using configured row height, to at least have a chance of lining up with surrounding cells\n                        style : {\n                            height : this.client.rowManager.rowHeight\n                        }\n                    }\n                ]\n            };\n\n        // Allow application code a chance to affect the merged cell (intended for styling)\n        column.mergedRenderer?.({ domConfig, value : column.getRawValue(record), record, column, fromIndex, toIndex });\n\n        return domConfig;\n    }\n\n    buildMergedCellsConfig(fromIndex, toIndex, rows) {\n        const\n            me             = this,\n            { client }     = me,\n            { rowManager } = client;\n\n        // When exporting content we render rows to a document fragment one by one without RowManager. In\n        // order to draw ranges correctly in this case we need provide some meta information - list of row-like\n        // objects from which we can size for merged cell element, i.e. top, bottom, height, dataIndex\n        // Match grids row buffer, drawing ranges from the topmost row to the bottommost\n        fromIndex = fromIndex ?? rowManager.topRow?.dataIndex;\n        toIndex = toIndex ?? rowManager.bottomRow?.dataIndex;\n\n        const\n            // { locked = [], normal = [] }\n            domConfigMap = client.regions.reduce((map, region) => {\n                map[region] = {\n                    className : {\n                        'b-grid-merged-cells-container' : 1\n                    },\n                    children : []\n                };\n                return map;\n            }, {});\n\n        // Determine and update visible ranges\n        for (const range of me.mergedRanges) {\n            if (range.use && range.fromIndex <= toIndex && range.toIndex >= fromIndex) {\n                // Update the range, in case more of it has been scrolled into view\n                me.updateRange(range, me.heightChanged, rows);\n                // Create a DomConfig for it\n                domConfigMap[range.column.region].children.push(me.createRangeDomConfig(range));\n            }\n        }\n\n        return domConfigMap;\n    }\n\n    syncDom(force = false) {\n        const\n            me             = this,\n            { client }     = me,\n            { rowManager } = client;\n\n        // Bail out if we get here too early (happens in Scheduler) or are disabled\n        if (!force && !rowManager.topRow || me.disabled && !me.isDisabling) {\n            return;\n        }\n\n        const domConfigMap = this.buildMergedCellsConfig();\n\n        // Sync per subgrid\n        client.eachSubGrid(subGrid => {\n            DomSync.sync({\n                targetElement : subGrid.$mergedCellsElement,\n                syncIdField   : 'syncId',\n                domConfig     : domConfigMap[subGrid.region]\n            });\n        });\n\n        me.heightChanged = false;\n    }\n\n    // Called after rows are updated, sync visible ranges per subgrid\n    onRenderDone() {\n        this.syncDom();\n    }\n\n    //endregion\n\n    //region Ranges\n\n    // Remove range from list and index/column map, leaving no trace it since we dont know if it will ever\n    // come back (element will be released by DomSync)\n    removeRange(range) {\n        ArrayHelper.remove(this.mergedRanges, range);\n        for (let index = range.fromIndex; index <= range.toIndex; index++) {\n            delete this.mergedMap[`${index}-@-${range.column.id}`];\n        }\n    }\n\n    // Full reset, regenerating all ranges\n    reset(redraw = true) {\n        const\n            me        = this,\n            columns   = me.client.columns.visibleColumns.filter(c => c.mergeCells && c.isSorted, true),\n            hadRanges = me.mergedRanges.length;\n\n        me.mergedRanges = [];\n        me.mergedMap = {};\n\n        if (redraw && !me.client.refreshSuspended) {\n            for (const row of me.client.rowManager.rows) {\n                for (const column of columns) {\n                    row.renderCell(row.getCell(column.id));\n                }\n            }\n\n            // Redraw, forcing it if all rows are gone\n            me.syncDom(hadRanges && !me.client.rowManager.rowCount);\n        }\n    }\n\n    // Refreshes existing ranges coords\n    refreshBounds() {\n        const\n            { mergedRanges } = this,\n            boundsMap        = new Map();\n\n        for (const range of mergedRanges.slice()) {\n            const\n                { column }  = range,\n                { element } = column;\n\n            // Column shown\n            if (element) {\n                let bounds = boundsMap.get(column);\n\n                if (!bounds) {\n                    // Temporarily cache bounds to avoid calculating them multiple times\n                    boundsMap.set(column, bounds = Rectangle.from(element, element.parentElement));\n                }\n\n                range.left = bounds.left;\n                range.width = bounds.width;\n            }\n            // Column hidden or removed\n            else {\n                this.removeRange(range);\n            }\n        }\n\n        this.syncDom();\n    }\n\n    // Updates the range as user scrolls, until its start and end coords are fully known\n    // Rows argument is required to render merged cells on export. We provide row-like objects there\n    updateRange(range, force, rows = null) {\n        const\n            { store, rowManager }           = this.client,\n            { topRendered, bottomRendered } = range,\n            { rowOffsetHeight }             = rowManager;\n\n        let { fromIndex, toIndex } = range,\n            topRow, bottomRow;\n\n        force = rows ? rows.length > 0 : force;\n\n        // No need to update anything if bounds are correct already\n        if (!force && topRendered && bottomRendered) {\n            return;\n        }\n\n        if (!topRendered || force) {\n            if (rows) {\n                const index = rows.findIndex(row => row.dataIndex >= fromIndex);\n                topRow = rows[index];\n                fromIndex = topRow.dataIndex;\n            }\n            else {\n                // TODO: Should not need to iterate here, calculate top instead\n                do {\n                    topRow = rowManager.getRowById(store.getAt(fromIndex));\n                }\n                while (!topRow && fromIndex++ < toIndex);\n            }\n\n            // topRow is the actual topmost row in the range\n            range.topRendered = (fromIndex === range.fromIndex);\n\n            const rowsAbove = fromIndex - range.fromIndex;\n\n            range.top = topRow.top - rowsAbove * (rows ? topRow.offsetHeight : rowOffsetHeight);\n        }\n\n        if (!bottomRendered || force) {\n            if (rows) {\n                // We need to find last index, so we can just pick max between -1 and whatever we find\n                const index = rows.findIndex(row => row.dataIndex === toIndex);\n                bottomRow = rows[index === -1 ? rows.length - 1 : index];\n                fromIndex = bottomRow.dataIndex;\n            }\n            else {\n                // TODO: Should not need to iterate here, calculate bottom instead\n                do {\n                    bottomRow = rowManager.getRowById(store.getAt(toIndex));\n                }\n                while (!bottomRow && toIndex-- > fromIndex);\n            }\n\n            // bottomRow is the actual bottommost row in the range\n            range.bottomRendered = (toIndex === range.toIndex);\n\n            const rowsBelow = range.toIndex - toIndex;\n\n            range.bottom = bottomRow.bottom + rowsBelow * (rows ? bottomRow.offsetHeight : rowOffsetHeight);\n        }\n\n        range.height = range.bottom - range.top;\n    }\n\n    // Retrieve a range for the specified record / column, creating a new one if none found by walking upwards and\n    // downwards until a deviating value is found\n    getMergeRange(record, column) {\n        if (record.isSpecialRow) {\n            return;\n        }\n\n        const\n            me            = this,\n            { mergedMap } = me,\n            { store }     = me.client,\n            columnId      = column.id,\n            index         = store.indexOf(record),\n            key           = `${index}-@-${columnId}`;\n\n        let range = mergedMap[key];\n\n        if (!range) {\n            const value = column.getRawValue(record);\n\n            range = mergedMap[key] = {\n                column\n            };\n\n            me.mergedRanges.push(range);\n\n            // Search up until encountering different value\n            let earlierRecord, earlierValue, earlierIndex = index;\n\n            do {\n                earlierRecord = store.getAt(--earlierIndex);\n                earlierValue  = earlierRecord && column.getRawValue(earlierRecord);\n\n                if (earlierValue === value) {\n                    mergedMap[`${earlierIndex}-@-${columnId}`] = range;\n                }\n\n            } while (earlierRecord && earlierValue === value);\n\n            // And down\n            let laterRecord, laterValue, laterIndex = index;\n\n            do {\n                laterRecord = store.getAt(++laterIndex);\n                laterValue  = laterRecord && column.getRawValue(laterRecord);\n\n                if (laterValue === value) {\n                    mergedMap[`${laterIndex}-@-${columnId}`] = range;\n                }\n            } while (laterRecord && laterValue === value);\n\n            range.fromIndex = earlierIndex + 1;\n            range.toIndex   = laterIndex - 1;\n\n            // We only care about ranges longer than 1 record\n            if (range.toIndex - range.fromIndex > 0) {\n                const headerBounds = Rectangle.from(column.element, column.element.parentElement); // TODO get relative element with different approach, to work with grouped headers\n                range.left  = headerBounds.left;\n                range.width = headerBounds.width;\n                range.use = true;\n            }\n        }\n\n        if (!range.element && range.use) {\n            me.createRangeElement(range);\n        }\n\n        return range;\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(MergeCells);\n","//TODO: Handle date columns\n//TODO: Icons to navigate between hits in the header? or in each cell?\n//TODO: Icon to clear quickfind in header\n//TODO: regex for valid key pressed?\n\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n\n/**\n * @module Grid/feature/QuickFind\n */\n\n/**\n * Feature that allows the user to search in a column by focusing a cell and typing. Navigate between hits using the\n * keyboard, [f3] or [ctrl]/[cmd] + [g] moves to next, also pressing [shift] moves to previous.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys          | Action           | Action description                |\n * |---------------|------------------|-----------------------------------|\n * | F3            | goToNextHit      | Move focus to next search hit     |\n * | Shift+F3      | goToPrevHit      | Move focus to previous search hit |\n * | Ctrl+g        | goToNextHit      | Move focus to next search hit     |\n * | Ctrl+Shift+g  | goToPrevHit      | Move focus to previous search hit |\n * | Ctrl+Shift+F3 | showFilterEditor | Shows the filter editor           |\n * | Escape        | clearSearch      | Removes the search completely     |\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @example\n * // enable QuickFind\n * let grid = new Grid({\n *   features: {\n *     quickFind: true\n *   }\n * });\n *\n * // navigate to next hit programmatically\n * grid.features.quickFind.gotoNextHit();\n *\n * @demo Grid/quickfind\n * @classtype quickFind\n * @inlineexample Grid/feature/QuickFind.js\n * @feature\n */\nexport default class QuickFind extends InstancePlugin {\n    //region Config\n\n    static get $name() {\n        return 'QuickFind';\n    }\n\n    static configurable = {\n        mode : 'header',\n        find : '',\n\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            F3             : 'gotoNextHit',\n            'Shift+F3'     : 'gotoPrevHit',\n            'Ctrl+g'       : 'gotoNextHit',\n            'Ctrl+Shift+g' : 'gotoPrevHit',\n            'Ctrl+Shift+f' : 'showFilterEditor',\n            Escape         : 'clearSearch',\n\n            //Private\n            Backspace : 'onBackspace'\n        }\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onElementKeyPress', 'onCellNavigate']\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    static get properties() {\n        return {\n            hitCls          : 'b-quick-hit',\n            hitCellCls      : 'b-quick-hit-cell',\n            hitCellBadgeCls : 'b-quick-hit-cell-badge',\n            hitTextCls      : 'b-quick-hit-text'\n        };\n    }\n\n    construct(grid, config) {\n        super.construct(grid, config);\n\n        Object.assign(this, {\n            grid,\n            treeWalker : grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)\n        });\n    }\n\n    isActionAvailable() {\n        const { focusedCell } = this.grid;\n        return !this.disabled && focusedCell?.record && !focusedCell.isActionable && this.find.length > 0;\n    }\n\n    doDisable(disable) {\n        if (disable) {\n            this.clear();\n        }\n\n        super.doDisable(disable);\n    }\n\n    get store() {\n        return this.grid.store;\n    }\n\n    //endregion\n\n    //region Show/hide QuickFind\n\n    /**\n     * Shows a \"searchfield\" in the header. Triggered automatically when you have a cell focused and start typing.\n     * @private\n     */\n    showQuickFind() {\n        const\n            me     = this,\n            header = me.grid.getHeaderElement(me.columnId);\n\n        if (header) {\n            if (!me.headerField) {\n                const [element, field, badge] = DomHelper.createElement({\n                    tag       : 'div',\n                    className : 'b-quick-hit-header',\n                    children  : [\n                        { tag : 'div', className : 'b-quick-hit-field' },\n                        { tag : 'div', className : 'b-quick-hit-badge' }\n                    ]\n                }, { returnAll : true });\n\n                if (me.mode === 'header') {\n                    header.appendChild(element);\n                }\n                else {\n                    element.className += ' b-quick-hit-mode-grid';\n                    me.grid.element.appendChild(element);\n                }\n\n                me.headerField = {\n                    header    : element,\n                    field     : field,\n                    badge     : badge,\n                    colHeader : header\n                };\n            }\n\n            me.headerField.field.innerHTML = me.find;\n            me.headerField.badge.innerHTML = me.found.length;\n\n            header.classList.add('b-quick-find-header');\n\n            if (!me.renderListenerInitialized) {\n                me.grid.rowManager.ion({\n                    rendercell : me.renderCell,\n                    thisObj    : me\n                });\n                me.renderListenerInitialized = true;\n            }\n        }\n    }\n\n    /**\n     * Hide the \"searchfield\" and remove highlighted hits. Called automatically when pressing [esc] or backspacing away\n     * the keywords.\n     * @private\n     */\n    hideQuickFind() {\n        const\n            me                    = this,\n            { grid, headerField } = me;\n\n        // rerender cells to remove quick-find markup\n        for (const hit of (me.prevFound || me.found)) {\n            const row = grid.getRowById(hit.id);\n            if (row) {\n                // Need to force replace quick finds markup\n                row.forceInnerHTML = true;\n\n                const cellElement = row.getCell(me.columnId);\n                cellElement._content = null;\n                row.renderCell(cellElement);\n\n                row.forceInnerHTML = false;\n            }\n        }\n\n        if (headerField) {\n            headerField.header.parentNode.removeChild(headerField.header);\n            headerField.colHeader.classList.remove('b-quick-find-header');\n            me.headerField = null;\n        }\n\n        if (me.renderListenerInitialized) {\n            grid.rowManager.un({ rendercell : me.renderCell }, me);\n            me.renderListenerInitialized = false;\n        }\n\n        grid.trigger('hideQuickFind');\n    }\n\n    //endregion\n\n    //region Search\n\n    /**\n     * Performs a search and highlights hits. If find is empty, QuickFind is closed.\n     * @param {String} find Text to search for\n     * @param {String} columnFieldOrId Column to search\n     */\n    search(find, columnFieldOrId = this.columnId) {\n        const\n            me       = this,\n            { grid } = me,\n            column   = grid.columns.getById(columnFieldOrId) || grid.columns.get(columnFieldOrId),\n            found    = me.store.findByField(column.field, find, column.mergeCells && column.isSorted);\n\n        let i = 1;\n\n        Object.assign(me, {\n            foundMap  : {},\n            prevFound : me.found,\n            found,\n            find,\n            columnId  : column.id,\n            findRe    : new RegExp(`(\\\\s+)?(${StringHelper.escapeRegExp(String(find))})(\\\\s+)?`, 'ig')\n        });\n\n        if (find) {\n            me.showQuickFind();\n        }\n        else {\n            me.hideQuickFind();\n        }\n\n        // clear old hits\n        for (const cellElement of DomHelper.children(grid.element, `.${me.hitCls}`)) {\n            cellElement.classList.remove(me.hitCls, me.hitCellCls);\n\n            if (cellElement._originalContent) {\n                cellElement.innerHTML = cellElement._originalContent;\n                cellElement._originalContent = null;\n            }\n        }\n\n        if (!found) {\n            return;\n        }\n\n        if (found.length > 0) {\n            me.gotoClosestHit(grid.focusedCell, found);\n        }\n\n        // highlight hits for visible cells\n        for (const hit of found) {\n            me.foundMap[hit.id] = i++;\n\n            const row = grid.getRowById(hit.data.id);\n            row?.renderCell(row.getCell(column.id));\n\n            // limit highlighted hits\n            if (i > 1000) {\n                break;\n            }\n        }\n\n        grid.trigger('quickFind', { find, found });\n    }\n\n    /**\n     * Clears and closes QuickFind.\n     */\n    clear() {\n        if (this.find || this.found?.length) {\n            this.search('');\n        }\n    }\n\n    /**\n     * Number of results found\n     * @type {Number}\n     * @readonly\n     */\n    get foundCount() {\n        return this.found?.length ?? 0;\n    }\n\n    /**\n     * Found results (as returned by Store#findByField), an array in format { index: x, data: record }\n     * @member {StoreSearchResult[]} found\n     * @readonly\n     */\n\n    //endregion\n\n    //region Navigation\n\n    /**\n     * Go to specified hit.\n     * @param {Number} index\n     */\n    gotoHit(index) {\n        const nextHit = this.found[index];\n\n        if (nextHit) {\n            this.grid.focusCell({\n                columnId : this.columnId,\n                id       : nextHit.id\n            }, { doSelect : true });\n        }\n\n        return !!nextHit;\n    }\n\n    gotoClosestHit(focusedCell, found) {\n        const\n            focusedIndex = focusedCell ? this.grid.store.indexOf(focusedCell.id) : 0,\n            foundSorted  = found.slice().sort(\n                (a, b) => Math.abs(a.index - focusedIndex) - Math.abs(b.index - focusedIndex)\n            );\n\n        this.gotoHit(found.indexOf(foundSorted[0]));\n    }\n\n    /**\n     * Go to the first hit.\n     */\n    gotoFirstHit() {\n        this.gotoHit(0);\n    }\n\n    /**\n     * Go to the last hit.\n     */\n    gotoLastHit() {\n        this.gotoHit(this.found.length - 1);\n    }\n\n    /**\n     * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].\n     */\n    gotoNextHit() {\n        const\n            me           = this,\n            { grid }     = me,\n            // start from focused cell, or if focus has left grid use lastFocusedCell\n            currentId    = grid._focusedCell?.id ?? grid.lastFocusedCell?.id,\n            currentIndex = grid.store.indexOf(currentId) || 0,\n            nextHit      = me.found.find(hit => hit.index > currentIndex);\n\n        if (nextHit) {\n            grid.focusCell({\n                columnId : me.columnId,\n                id       : nextHit.id\n            }, { doSelect : true });\n        }\n        else {\n            me.gotoFirstHit();\n        }\n    }\n\n    /**\n     * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].\n     */\n    gotoPrevHit() {\n        const\n            me              = this,\n            { grid, found } = me,\n            currentId       = grid._focusedCell?.id ?? grid.lastFocusedCell?.id,\n            currentIndex    = grid.store.indexOf(currentId) || 0;\n\n        let prevHit;\n\n        if (!found.length) {\n            return;\n        }\n\n        for (let i = found.length - 1; i--; i >= 0) {\n            if (found[i].index < currentIndex) {\n                prevHit = found[i];\n                break;\n            }\n        }\n\n        if (prevHit) {\n            grid.focusCell({\n                columnId : me.columnId,\n                id       : prevHit.id\n            }, { doSelect : true });\n        }\n        else {\n            me.gotoLastHit();\n        }\n    }\n\n    //endregion\n\n    //region Render\n\n    /**\n     * Called from SubGrid when a cell is rendered.\n     * @private\n     */\n    renderCell({ cellElement, column, record }) {\n        const\n            me           = this,\n            { classList } = cellElement,\n            {\n                treeWalker,\n                findRe,\n                hitTextCls\n            }           = me,\n            hitIndex    = me.columnId === column.id && me.foundMap?.[record.id];\n\n        if (hitIndex) {\n            // highlight cell\n            classList.add(me.hitCls);\n            cellElement.isQuickHit = true;\n            cellElement._originalContent = cellElement.innerHTML;\n\n            // if features have added other stuff to the cell, value is in div.b-grid-cell-value\n            // highlight in cell if found in innerHTML\n            const inner = treeWalker.currentNode = DomHelper.down(cellElement, '.b-grid-cell-value,.b-tree-cell-value') || cellElement;\n\n            for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode);) {\n                const\n                    nodeToReplace = textNode,\n                    textContent   = textNode.nodeValue,\n                    newText       = ['<span>'];\n\n                // Move onto next text node before we replace the node with a highlight HTML sequence\n                textNode = treeWalker.nextNode();\n\n                let offset = findRe.lastIndex;\n\n                // Convert textContent into an innerHTML string which htmlEncodes the text and embeds\n                // a highlighting span which contains the target text.\n                for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {\n                    const\n                        preamble    = textContent.substring(offset, match.index),\n                        spaceBefore = match[1] ? '\\xa0' : '',\n                        v           = match[2],\n                        spaceAfter  = match[3] ? '\\xa0' : '';\n\n                    newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class=\"${hitTextCls}\">${v}</span>${spaceAfter}`);\n                    offset = findRe.lastIndex;\n                }\n\n                newText.push(StringHelper.encodeHtml(textContent.substring(offset)), '</span>');\n\n                // Insert a fragment with each match wrapped with a span.\n                nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(''), {\n                    fragment : true\n                }), nodeToReplace);\n                nodeToReplace.remove();\n            }\n            DomHelper.createElement({\n                parent    : cellElement,\n                className : me.hitCellBadgeCls,\n                text      : hitIndex\n            });\n        }\n    }\n\n    //endregion\n\n    //region Events\n\n    onBackspace(event) {\n        const me = this;\n        if (me.find) {\n            me.find = me.find.substr(0, me.find.length - 1);\n            me.search(me.find);\n            return true;\n        }\n        return false;\n    }\n\n    clearSearch() {\n        if (this.find) {\n            this.find = '';\n            this.search(this.find);\n            return true;\n        }\n        return false;\n    }\n\n    showFilterEditor() {\n        const\n            me = this,\n            { filter } = me.client.features;\n\n        if (filter && me.columnId && me.foundCount) {\n            me.clear();\n            filter.showFilterEditor(me.client.columns.getById(me.columnId), me.find);\n        }\n    }\n\n    /**\n     * Chained function called on grids keypress event. Handles input for \"searchfield\".\n     * @private\n     * @param event\n     */\n    onElementKeyPress(event) {\n        const\n            me              = this,\n            { grid }        = me,\n            { focusedCell } = grid;\n\n        // Only react to keystrokes on grid cell elements\n        if (!event.handled && !me.disabled && focusedCell?.record && !focusedCell.isActionable && event.key?.length === 1) {\n            const column = grid.columns.getById(grid._focusedCell.columnId);\n            // if trying to search in invalid column, it's a hard failure\n            //<debug>\n            console.assert(column, 'Focused cell column not found');\n            //</debug>\n            if (column && column.searchable !== false) {\n                me.columnId = grid._focusedCell.columnId;\n                me.find += event.key;\n                me.search(me.find);\n            }\n        }\n    }\n\n    onCellNavigate(grid, fromCellSelector, toCellSelector) {\n        const\n            me    = this;\n\n        if (me.find && (!toCellSelector || toCellSelector.columnId !== me.columnId)) {\n            me.clear();\n        }\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(QuickFind);\n","import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Objects from '../../Core/helper/util/Objects.js';\nimport '../column/ActionColumn.js';\n\n/**\n * @module Grid/feature/RowExpander\n */\n\nconst storeRemoveActions = { remove : 1, filter : 1, dataset : 1, replace : 1 };\n\n/**\n * Enables expanding of Grid rows by either row click or double click, or by adding a separate Grid column which renders\n * a button that expands or collapses the row.\n *\n * {@inlineexample Grid/feature/RowExpander.js}\n *\n * The content of the expanded row body is rendered by providing a {@link #config-renderer} function to the\n * rowExpander feature config.\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            renderer({record, region, expanderElement}){\n *                return htmlToBeExpanded;\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * <div class=\"note\">Note that if used in a Gantt, the Gant's `fixedRowHeight` must be set to `false`.</div>\n *\n * This feature is **disabled** by default\n *\n * ## Expand on click\n * Set {@link #config-triggerEvent} to a Grid cell event that should trigger row expanding and collapsing.\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            triggerEvent: 'celldblclick',\n *            renderer...\n *        }\n *    }\n * });\n * ```\n *\n * ## Expander column position\n * The expander column can either be inserted before or after the existing Grid columns. If the Grid has multiple\n * regions the column will be added to the first region.\n *\n * Adjust expander column position to last in a specific Grid region by setting {@link #config-columnPosition}\n * to `last` and configuring the {@link #config-column} with a region name.\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            column: {\n *                region: 'last'\n *            },\n *            columnPosition: 'last',\n *            renderer...\n *        }\n *    }\n * });\n * ```\n *\n * ## Record update\n * If the expander content depends on row record data, the expander can be re-rendered on record update by setting\n * {@link #config-refreshOnRecordChange} to `true`.\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            refreshOnRecordChange: true,\n *            renderer...\n *        }\n *    }\n * });\n * ```\n *\n * ## Async\n * When the content of the row expander should be rendered async just see to it that you return a promise.\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            async renderer({record, region, expanderElement}){\n *                return fetchFromBackendAndRenderData(record);\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype rowExpander\n * @feature\n */\nexport default class RowExpander extends InstancePlugin {\n\n    //region Config\n    static $name = 'RowExpander';\n\n    // Cannot use `static properties = {}`, new Map/Set would pollute the prototype\n    static get properties() {\n        return {\n            // CSS classes\n            expanderBodyClass : 'b-rowexpander-body',\n            expandedRowClass  : 'b-rowexpander-row-expanded', // Map where the keys are the expanded records and values are an object {rowHeight, cellHeight, expandElements}\n            recordStateMap    : new Map(),\n            collapsingRecords : new Set()\n        };\n    }\n\n    static configurable = {\n\n        /**\n         * The implementation of this function is called each time the body of an expanded row is rendered. Either\n         * return an HTML string, or a {@link Core.helper.DomHelper#typedef-DomConfig} object describing the markup.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            renderer({record, region, expanderElement}){\n         *                return htmlToBeExpanded;\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * Or return a {@link Core.helper.DomHelper#typedef-DomConfig} object.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            renderer({record, region, expanderElement}){\n         *                return {\n         *                   tag       : 'form',\n         *                   className : 'expanded-row-form',\n         *                   children  : [\n         *                       {\n         *                           tag        : 'textarea',\n         *                           name       : 'description',\n         *                           className  : 'expanded-textarea'\n         *                       },\n         *                       {\n         *                           tag        : 'button',\n         *                           text       : 'Save',\n         *                           className  : 'expanded-save-button',\n         *                       }\n         *                   ]\n         *                };\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * It is also possible to add markup directly to the expanderElement.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            renderer({record, region, expanderElement}){\n         *                new UIComponent({\n         *                    appendTo: expanderElement,\n         *                    ...\n         *                });\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         * The renderer function can also be asynchronous.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            async renderer({record, region, expanderElement}){\n         *                return await awaitAsynchronousOperation();\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         * @param {Object} renderData Object containing renderer parameters\n         * @param {Core.data.Model} renderData.record Record for the row\n         * @param {HTMLElement} renderData.expanderElement Expander body element\n         * @param {HTMLElement} renderData.rowElement Row element\n         * @param {String} renderData.region Grid region name\n         * @returns {String|DomConfig} Row expander body content\n         * @config {Function}\n         * @async\n         */\n        renderer : null,\n\n        /**\n         * The name of the Grid event that will toggle expander. Defaults to `null` but can be set to any event such\n         * as {@link Grid.view.mixin.GridElementEvents#event-cellDblClick} or\n         * {@link Grid.view.mixin.GridElementEvents#event-cellClick}.\n         *\n         * ```javascript\n         * features : {\n         *     rowExpander : {\n         *         triggerEvent : 'cellclick'\n         *     }\n         * }\n         * ```\n         *\n         * @config {String}\n         */\n        triggerEvent : null,\n\n        /**\n         * Provide a column config object to display a button with expand/collapse functionality.\n         * Shown by default, set to `null` to not include.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            column: {\n         *                // Use column config options here\n         *                region: 'last'\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {ActionColumnConfig|Grid.column.ActionColumn}\n         */\n        column : { },\n\n        /**\n         * Makes the expand/collapse button column appear either as the first column (default or `first`) or as the\n         * last (set to `last`). Note that the column by default will be added to the first region, if the Grid\n         * has multiple regions. Use the {@link #config-column} config to change region.\n         * @config {String}\n         * @default\n         */\n        columnPosition : 'first',\n\n        /**\n         * If set to `true`, the RowExpander will, on record update, re-render an expanded row by calling the\n         * {@link #config-renderer} function.\n         * @config {Boolean}\n         * @default\n         */\n        refreshOnRecordChange : false,\n\n        /**\n         * Use this for customizing async {@link #config-renderer} loading indicator height.\n         * @config {Number}\n         * @defalt\n         */\n        loadingIndicatorHeight : 100,\n\n        /**\n         * Use this for customizing async {@link #config-renderer} loading indicator text.\n         * @config {String}\n         * @default Loading\n         */\n        loadingIndicatorText : 'L{loading}',\n\n        /**\n         * Use this to disable expand and collapse animations.\n         * @config {Boolean}\n         * @default\n         */\n        enableAnimations : true\n    }\n\n    // Plugin configuration. This plugin chains/overrides some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain    : ['afterColumnsChange', 'beforeRenderRow', 'processRowHeight', 'bindStore'],\n            override : ['onGridBodyFocusIn']\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    afterConstruct() {\n        const\n            me         = this,\n            { client } = me;\n        if (!me.renderer) {\n            console.warn('RowExpander requires implementing the renderer function.');\n            return;\n        }\n        if (client.isGanttBase && client.fixedRowHeight !== false) {\n            console.warn('When using RowExpander on a Gantt, the Gantt`s fixedRowHeight config must be set to false.');\n        }\n\n        // Bind initial store\n        me.bindStore(client.store);\n\n        if (me.triggerEvent) {\n            client.ion({ [me.triggerEvent] : 'onTriggerEvent', thisObj : me });\n        }\n\n        me.addColumn();\n    }\n\n    bindStore(store) {\n        const me = this;\n\n        me.recordStateMap.clear();\n        me.collapsingRecords.clear();\n        me.detachListeners('clientStoreChange');\n\n        store.ion({\n            name    : 'clientStoreChange',\n            change  : me.onStoreChange,\n            thisObj : me\n        });\n    }\n\n    doDisable(disable) {\n        const { client } = this;\n\n        if (disable) {\n            this.recordStateMap.clear();\n            this.collapsingRecords.clear();\n        }\n\n        if (!client.isConfiguring) {\n            client.rowManager.renderFromRow();\n        }\n        super.doDisable(disable);\n    }\n\n    changeLoadingIndicatorText(text) {\n        return text ? this.L(text) : text;\n    }\n\n    // Overrides onGridBodyFocusIn to ignore events on row expander body.\n    onGridBodyFocusIn(event) {\n        if (!this.client.lastMousedownEvent?.target?.closest('.b-rowexpander-body')) {\n            this.overridden.onGridBodyFocusIn(event);\n        }\n    }\n\n    get isAnimating() {\n        return this.client.isAnimating;\n    }\n\n    set isAnimating(value) {\n        const\n            { client }   = this,\n            wasAnimating = client.isAnimating;\n\n        client.isAnimating = value;\n\n        if (client.isAnimating !== wasAnimating) {\n            client.element.classList.toggle('b-rowexpander-animating');\n        }\n    }\n\n    //endregion\n\n    //region Events\n    /**\n     * This event fires before row expand is started.\n     *\n     * Returning `false` from a listener prevents the RowExpander to expand the row.\n     *\n     * Note that this event fires when the RowExpander toggles the row, not when the actual row expander body is\n     * rendered. Most of the time this is synchronous, but in the case of a row that is not yet rendered into view by\n     * scrolling, it can happen much later.\n     *\n     * @event beforeExpand\n     * @preventable\n     * @async\n     * @param {Core.data.Model} record Record\n     */\n\n    /**\n     * This event fires before row collapse is started.\n     *\n     * Returning `false` from a listener prevents the RowExpander to collapse the row.\n     *\n     * Note that this event fires when the RowExpander toggles the row, not when the actual row expander body is\n     * rendered. Most of the time this is synchronous, but in the case of a row that is not yet rendered into view by\n     * scrolling, it can happen much later.\n     *\n     * @event beforeCollapse\n     * @preventable\n     * @async\n     * @param {Core.data.Model} record Record\n     */\n    //endregion\n\n    //region ExpanderColumn\n    afterColumnsChange() {\n        this.addColumn();\n    }\n\n    changeColumn(config) {\n        if (config == null) {\n            return config;\n        }\n        return {\n            type    : 'action',\n            actions : [{\n                cls     : 'b-icon b-icon-collapse-down',\n                tooltip : ({ record }) => this.L(this.recordStateMap.has(record) ? 'L{RowExpander.collapse}' : 'L{RowExpander.expand}'),\n                onClick : ({ record }) => this.toggleExpand(record)\n            }],\n            width    : 40,\n            hideable : false,\n            align    : 'center',\n            region   : this.client.regions[0],\n            ...config,\n            field    : 'expanderActionColumn'\n        };\n    }\n\n    // Called in construct and if grid columns change\n    addColumn() {\n        const\n            me = this,\n            { column } = me,\n            { columns } = me.client;\n\n        if (!me._isAddingExpanderColumn && column && (!me._expander || !columns.includes(me._expander))) {\n            me._isAddingExpanderColumn = true;\n            if (me.columnPosition === 'last') {\n                [me._expander] = columns.add(column);\n            }\n            else {\n                [me._expander] = columns.insert(0, column);\n            }\n            me._isAddingExpanderColumn = false;\n        }\n    }\n    //endregion\n\n    //region UI events\n\n    onTriggerEvent({ target }) {\n        // Only grid cell event is handled. Action-cell event has its own handler.\n        if (this.disabled || target?.closest('.b-action-cell') || !target.closest('.b-grid-cell')) {\n            return;\n        }\n        this.toggleExpand(this.client.getRecordFromElement(target));\n    }\n\n    /**\n     * Toggles expander state.\n     * @private\n     * @param {Core.data.Model} record The record that should be toggled\n     * @category Internal\n     */\n    toggleExpand(record) {\n        if (record) {\n            if (this.recordStateMap.has(record)) {\n                this.collapse(record);\n            }\n            else {\n                this.expand(record);\n            }\n        }\n    }\n\n    //endregion\n\n    //region Rendering\n\n    /**\n     * Listens to changes in the Grid Store. Will remove expand State data on Store removal.\n     * If the refreshOnRecordChange config is `true`, it will trigger a re-render of the expander.\n     * @private\n     * @param {String} action\n     * @param {Core.data.Store} source\n     * @param {Core.data.Model[]} records\n     * @category Internal\n     */\n    onStoreChange({ action, source, records }) {\n        const\n            me = this,\n            { recordStateMap, collapsingRecords } = me;\n        if (me.disabled) {\n            return;\n        }\n        if (action === 'removeAll') {\n            recordStateMap.clear();\n            collapsingRecords.clear();\n        }\n        else if (storeRemoveActions[action]) {\n            for (const [record] of recordStateMap) {\n                if (!source.includes(record)) {\n                    recordStateMap.delete(record);\n                    collapsingRecords.delete(record);\n                }\n            }\n        }\n        else if (me.refreshOnRecordChange && records?.length) {\n            if (action === 'update') {\n                const recordState = recordStateMap.get(records[0]);\n                if (recordState?.isCreated) {\n                    recordState.isCreated = false;\n                    me.client.rowManager.renderFromRecord(records[0]);\n                }\n            }\n            else if (action === 'updatemultiple') {\n                let topRecordIndex,\n                    topRecord;\n                for (const rec of records) {\n                    const recordState = recordStateMap.get(rec);\n                    if (recordState?.isCreated) {\n                        recordState.isCreated = false;\n                        const index = source.records.indexOf(rec);\n                        if (!topRecord || topRecordIndex > index) {\n                            topRecordIndex = index;\n                            topRecord = rec;\n                        }\n                    }\n                }\n                if (topRecord) {\n                    me.client.rowManager.renderFromRecord(topRecord);\n                }\n            }\n        }\n    }\n\n    // Implements grid.processRowHeight hook\n    processRowHeight(record, height) {\n        const recordState = this.recordStateMap.get(record);\n        if (recordState) {\n            // If we are waiting for async rendering, height is calculated from a fixed loadingIndicatorHeight.\n            if (!recordState.isCreated && recordState.isRenderingAsync) {\n                return this.loadingIndicatorHeight + height;\n            }\n            // If we have a recordState but no expanderBodyHeight, we should recalculate height.\n            if (!recordState.expanderBodyHeight) {\n                for (const region of this.client.regions) {\n                    const height = recordState.expandElements[region].offsetHeight;\n                    if (height > recordState.expanderBodyHeight) {\n                        recordState.expanderBodyHeight = height;\n                    }\n                }\n            }\n        }\n        return (recordState?.expanderBodyHeight ?? 0) + height;\n    }\n\n    /**\n     * Hooks on before row render to render or remove row expander content depending on record state.\n     * @private\n     * @category Internal\n     */\n    beforeRenderRow({ row, record }) {\n        const\n            me = this,\n            { regions } = me.client,\n            { expandedRowClass } = me;\n\n        row.cls.toggle('b-rowexpander-disabled', me.disabled);\n\n        // If current row is expanded, always remove all expander content and settings.\n        if (row.cls[expandedRowClass]) {\n            // If animating a collapse, content should not be removed until animation is complete\n            if (me.enableAnimations && me.isAnimating && me.collapsingRecords.has(record)) {\n                me.waitForTransition(row, () => {\n                    // Make sure record still should be collapsed after animation is complete\n                    if (me.collapsingRecords.has(record)) {\n                        me.removeExpander(row);\n                    }\n                });\n            }\n            else {\n                me.removeExpander(row);\n            }\n        }\n        else {\n            // Makes sure record should collapse no longer\n            me.collapsingRecords.delete(record);\n        }\n\n        // The map only contains record that are expanded\n        const recordState = me.recordStateMap.get(record);\n        if (!me.disabled && recordState) {\n            // Expander content is created once, then reused.\n            if (!recordState.isCreated) {\n                me.renderExpander(record, row, recordState);\n            }\n            row.cls.add(expandedRowClass);\n            for (const region of regions) {\n                const rowElement = row.getElement(region);\n                if (recordState.isCreated) {\n                    rowElement.appendChild(recordState.expandElements[region]);\n                }\n                else {\n                    // If the renderer is async, we show a loading indicator.\n                    me.renderLoadingIndicator(rowElement, recordState);\n                }\n                me.lockCellHeight(rowElement, recordState.cellHeight, false);\n            }\n\n            // If expander body is rendered not fully in view, it will be scrolled into view\n            if (me._shouldScrollIntoView) {\n                me._shouldScrollIntoView = false;\n                if (!DomHelper.isInView(recordState.expandElements[regions[0]], true)) {\n                    // Waits for rendering to complete, then scrolls\n                    me.client.rowManager.ion({\n                        once       : true,\n                        thisObj    : me,\n                        renderDone : () => me.scrollRowIntoView(row, record)\n                    });\n                }\n            }\n        }\n    }\n\n    /**\n     * Scrolls expanded row into view. This function is called after rowManager has finished rendering.\n     * @private\n     * @category Internal\n     */\n    scrollRowIntoView(row, record) {\n        // If animating expand, need to wait for the animation to end before scrolling.\n        if (this.isAnimating) {\n            this.waitForTransition(row, () => this.client.scrollRowIntoView(record));\n        }\n        else {\n            this.client.scrollRowIntoView(record);\n        }\n    }\n\n    /**\n     * Waits for height transition on the provided rows element. Then calls provided function.\n     * @private\n     * @category Internal\n     */\n    waitForTransition(row, fn) {\n        EventHelper.onTransitionEnd({\n            element  : row.element,\n            property : 'height',\n            handler  : fn,\n            thisObj  : this\n        });\n    }\n\n    removeExpander(row) {\n        row.cls.remove(this.expandedRowClass);\n        for (const region of this.client.regions) {\n            const rowElement = row.getElement(region);\n            // If this function is called after animation finished, we need to remove class `manually`\n            rowElement.classList.remove(this.expandedRowClass);\n            DomHelper.removeEachSelector(rowElement, '.' + this.expanderBodyClass);\n            this.lockCellHeight(rowElement, null, false);\n        }\n    }\n\n    renderLoadingIndicator(rowElement, recordState) {\n        DomHelper.createElement({\n            parent    : rowElement,\n            className : this.expanderBodyClass + ' b-rowexpander-loading',\n            style     : {\n                top    : recordState.cellHeight,\n                height : this.loadingIndicatorHeight\n            },\n            children : [\n                {\n                    tag       : 'i',\n                    className : 'b-icon b-icon-spinner'\n                },\n                this.loadingIndicatorText\n            ]\n        });\n    }\n\n    /**\n     * Creates expander element for each grid region and calls the renderer, also for each grid region.\n     * @private\n     * @param {Core.data.Model} record\n     * @param {Grid.row.Row} row\n     * @param {Object} recordState\n     * @category Internal\n     */\n    renderExpander(record, row, recordState) {\n        const\n            me                = this,\n            cellHeight        = row.cells[0]?.offsetHeight,\n            expandElements    = {},\n            renderings        = [],\n            // Will be called sync or async depending on the implementation of the renderer function.\n            continueRendering = (content, expanderElement, region) => {\n                if (content != null) {\n                    if (typeof content === 'string') {\n                        expanderElement.innerHTML = content;\n                    }\n                    // Everything else will be treated as a dom config for now\n                    else {\n                        content = DomHelper.createElement(content);\n                        expanderElement.appendChild(content);\n                    }\n                }\n                expandElements[region] = expanderElement;\n            };\n\n        // If another rendering of the same record is made while waiting for async, we should ignore it.\n        if (recordState.isRenderingAsync) {\n            return;\n        }\n\n        Object.assign(recordState, { cellHeight, expandElements, expanderBodyHeight : 0 });\n\n        for (const region of me.client.regions) {\n            const rowElement = row.getElement(region);\n\n            // class needed at this point to give the expander container correct height\n            row.addCls(me.expandedRowClass);\n\n            // Create expand container\n            // Expander element needs to be in the DOM for appendTo to work correctly\n            const expanderElement = DomHelper.createElement({\n                parent    : rowElement,\n                className : me.expanderBodyClass,\n                style     : {\n                    top : cellHeight + 'px'\n                }\n            });\n\n            // The renderer can be async or sync\n            const renderResponse = me.renderer({ record, expanderElement, rowElement, region });\n            if (Objects.isPromise(renderResponse)) {\n                renderings.push(renderResponse.then((content) => continueRendering(content, expanderElement, region)));\n            }\n            else {\n                continueRendering(renderResponse, expanderElement, region);\n            }\n        }\n\n        // If we have async renderer, wait for all to complete\n        if (renderings.length) {\n            recordState.isRenderingAsync = true;\n            Promise.all(renderings).then(() => {\n                // Flag that indicates the completion of expand rendering\n                recordState.isCreated = true;\n                // The rows need to refresh to recalculate row height\n                // (?. since we might have been destroyed while waiting for promises)\n                me.renderRowsWithAnimation?.(record);\n                recordState.isRenderingAsync = false;\n            });\n        }\n        else {\n            recordState.isCreated = true;\n        }\n    }\n\n    /**\n     * Called when grid rows needs to re-render, for example on expand or collapse.\n     * Activates animations on grid, and deactivates them when they are completed.\n     * @private\n     * @param {Core.data.Model} record Record whose row was toggled\n     * @category Internal\n     */\n    renderRowsWithAnimation(record) {\n        const me = this;\n        if (me.enableAnimations) {\n            const row = me.client.rowManager.getRowById(record);\n            if (row) {\n                me.isAnimating = true;\n                if (me.collapsingRecords.has(record)) {\n                    row.addCls('b-row-is-collapsing');\n                }\n                me.waitForTransition(row, () => {\n                    me.isAnimating = false;\n                    if (!row.isDestroyed) {\n                        row.removeCls?.('b-row-is-collapsing');\n                    }\n                });\n            }\n        }\n        me.client.rowManager.renderFromRecord(record);\n    }\n\n    /**\n     * Called when row is expanded. This function locks all cell's height to current height (before expanding).\n     * @private\n     * @param {HTMLElement} rowElement\n     * @param {Number} cellHeight The height to lock\n     * @param {Boolean} unlock To remove locked cell height when the row is collapsed\n     * @category Internal\n     */\n    lockCellHeight(rowElement, cellHeight, unlock) {\n        for (let a = 0; a < rowElement.children.length; a++) {\n            const child = rowElement.children[a];\n            // Should not lock expander element\n            if (!child.classList.contains(this.expanderBodyClass)) {\n                child.style.height = unlock ? '' : cellHeight + 'px';\n            }\n        }\n    }\n    //endregion\n\n    //region Public\n\n    /**\n     * Tells the RowExpander that the provided record should be expanded. If or when the record is rendered into view,\n     * the record will be expanded.\n     *\n     * @param {Core.data.Model} record Record whose row should be expanded\n     * @category Common\n     */\n    async expand(record) {\n        const me = this;\n        if (me.disabled) {\n            return;\n        }\n\n        if (await me.trigger('beforeExpand', { record }) === false) {\n            return;\n        }\n        // Tells renderer that this record should be expanded\n        me.recordStateMap.set(record, { isCreated : false });\n        // In the event that we have expanded a record which is in collapsing animation state\n        me.collapsingRecords.delete(record);\n        me._shouldScrollIntoView = true;\n        me.renderRowsWithAnimation(record);\n    }\n\n    /**\n     * Tells the RowExpander that the provided record should be collapsed. If the record is in view, it will be\n     * collapsed. If the record is not in view, it will simply not be expanded when rendered into view.\n     *\n     * @param {Core.data.Model} record Record whose row should be collapsed\n     * @category Common\n     */\n    async collapse(record) {\n        const me = this;\n        if (me.disabled) {\n            return;\n        }\n\n        if (await me.trigger('beforeCollapse', { record }) === false) {\n            return;\n        }\n        me.recordStateMap.delete(record);\n        me.collapsingRecords.add(record);\n        me.renderRowsWithAnimation(record);\n    }\n    //endregion\n}\n\nGridFeatureManager.registerFeature(RowExpander);\n","//TODO: Should listen for store search also, to work the other way around\n//TODO: Buggy sometimes, try searching for Barcelona tigers, navigate using buttons\n//TODO: Allow regex\n//TODO: Optional case sensitive\n//TODO: build in UI, popup with keyboard shortcut?\n\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport DomDataStore from '../../Core/data/DomDataStore.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n\n/**\n * @module Grid/feature/Search\n */\n\n/**\n * {@inlineexample Grid/feature/Search.js}\n *\n * Feature that allows the user to search the entire grid. Navigate between hits using the\n * keyboard, [F3] or [Ctrl/CMD + G] moves to next, also pressing [Shift] moves to previous.\n *\n * Note that this feature does not include a UI, please build your own and call appropriate methods in the feature.\n * For a demo implementation, see <a href=\"../examples/search/\" target=\"_blank\">Search example</a>.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ## Keyboard shortcuts\n *\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys                   | Action      | Action description                |\n * |------------------------|-------------|-----------------------------------|\n * | [F3]                   | goToNextHit | Move focus to next search hit     |\n * | [Shift + F3]           | goToPrevHit | Move focus to previous search hit |\n * | [Ctrl/CMD + G]         | goToNextHit | Move focus to next search hit     |\n * | [Ctrl/CMD + Shift + G] | goToPrevHit | Move focus to previous search hit |\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @example\n * // enable Search\n * let grid = new Grid({\n *   features: {\n *     search: true\n *   }\n * });\n *\n * // perform search\n * grid.features.search.search('steve');\n *\n * @demo Grid/search\n * @classtype search\n * @feature\n */\nexport default class Search extends Delayable(InstancePlugin) {\n    //region Init\n\n    static get $name() {\n        return 'Search';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * The maximum amount of search hits\n             * @config {Number}\n             * @default\n             */\n            limit : 1000,\n\n            /**\n             * Set to false to not show the search hit index numbers\n             * @config {Boolean}\n             * @default\n             */\n            showHitIndex : true,\n\n            /**\n             * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n             * @config {Object<String,String>}\n             */\n            keyMap : {\n                F3             : 'gotoNextHit',\n                'Ctrl+g'       : 'gotoNextHit',\n                'Shift+F3'     : 'gotoPrevHit',\n                'Ctrl+Shift+g' : 'gotoPrevHit'\n            }\n        };\n    }\n\n    static get properties() {\n        return {\n            hitCls          : 'b-search-hit',\n            hitCellCls      : 'b-search-hit-cell',\n            hitCellBadgeCls : 'b-search-hit-cell-badge',\n            hitTextCls      : 'b-search-hit-text'\n        };\n    }\n\n    construct(grid, config) {\n        const me = this;\n\n        super.construct(grid, config);\n\n        Object.assign(me, {\n            grid,\n            text       : '',\n            hitEls     : [],\n            treeWalker : grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)\n        });\n\n        // When new nodes appear due to node expand, include them in the search\n        grid.ion({\n            expandNode : 'onTreeNodeExpand',\n            thisObj    : me\n        });\n    }\n\n    isActionAvailable() {\n        return Boolean(this.text);\n    }\n\n    onTreeNodeExpand() {\n        if (this.text) {\n            this.requestAnimationFrame(this.search, [this.text, false, true]);\n        }\n    }\n\n    doDestroy() {\n        this.clear(true);\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        if (disable) {\n            this.clear();\n        }\n\n        super.doDisable(disable);\n    }\n\n    get store() {\n        return this.grid.store;\n    }\n\n    //endregion\n\n    //region Plugin config\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['populateCellMenu']\n        };\n    }\n\n    //endregion\n\n    //region Search\n\n    /**\n     * Performs a search and highlights hits.\n     * @param {String} text Text to search for\n     * @param {Boolean} [gotoHit] Go to first hit after search\n     * @param {Boolean} [reapply] Pass true to force search\n     * @param {String[]} [fields] An array of the fields to search for the value in\n     */\n    async search(text, gotoHit = true, reapply = false, fields) {\n        const me = this;\n\n        // empty search considered a clear\n        if (!text) {\n            return me.clear();\n        }\n\n        // searching for same thing again, do nothing\n        if (!reapply && text === me.text || me.disabled) {\n            return;\n        }\n\n        const\n            { grid, store } = me,\n            // Only search columns in use\n            columns         = grid.columns.visibleColumns.filter(col => col.searchable !== false),\n            formatters      = [];\n\n        fields      = fields || columns.map(col => {\n            // For date / number columns\n            formatters.push(col.formatValue?.bind(col));\n            return col.field;\n        });\n        const found = store.search(text, fields, formatters);\n\n        if (store.isTree && found.length) {\n            await grid.expandTo(found.map(hit => hit.id));\n        }\n\n        // Only include first result for merged cells in the count\n        for (const column of columns) {\n            if (column.mergeCells && column.isSorted) {\n                let prevValue = null,\n                    belongsTo = null;\n\n                for (const hit of found) {\n                    if (hit.field === column.field) {\n                        const value = hit.data[hit.field];\n                        if (value === prevValue) {\n                            hit.belongsTo = belongsTo;\n                        }\n                        prevValue = value;\n                        belongsTo = `${hit.field}-${hit.id}`;\n                    }\n                }\n            }\n        }\n\n        let i = 1;\n\n        Object.assign(me, {\n            foundMap  : {},\n            prevFound : me.found,\n            found,\n            text,\n            findRe    : new RegExp(`(\\\\s+)?(${StringHelper.escapeRegExp(String(text))})(\\\\s+)?`, 'ig')\n        });\n\n        me.clearHits();\n\n        if (!found) {\n            return;\n        }\n\n        // highlight hits for visible cells\n        for (const hit of found) {\n            // merged cells reuse the index of the first hit in the range\n            me.foundMap[`${hit.field}-${hit.id}`] = hit.belongsTo ? me.foundMap[hit.belongsTo] : i++;\n            // limit hits\n            if (i > me.limit) {\n                break;\n            }\n        }\n\n        if (!me.listenersInitialized) {\n            grid.rowManager.ion({\n                name       : 'renderCell',\n                renderCell : 'renderCell',\n                thisObj    : me\n            });\n            store.ion({\n                name                                : 'storeRefresh',\n                [`refresh${grid.asyncEventSuffix}`] : 'onStoreRefresh',\n                thisObj                             : me\n            });\n            me.listenersInitialized = true;\n        }\n\n        grid.refreshRows();\n\n        grid.trigger('search', { grid, find : text, found });\n\n        if (gotoHit && !me.isHitFocused) {\n            me.gotoNextHit(true);\n        }\n\n        return found;\n    }\n\n    clearHits() {\n        // Clear old hits\n        for (const cellElement of DomHelper.children(this.grid.element, '.' + this.hitCls)) {\n            cellElement.classList.remove(this.hitCls, this.hitCellCls);\n\n            // Rerender cell to remove search-hit-text\n            const row = DomDataStore.get(cellElement).row;\n\n            // Merged cells have no row, but they will be cleared anyway by their own DomSync call\n            if (row) {\n                // Need to force replace the markup\n                row.forceInnerHTML = true;\n                row.renderCell(cellElement);\n                row.forceInnerHTML = false;\n            }\n        }\n    }\n\n    /**\n     * Clears search results.\n     */\n    clear(silent = false) {\n        const\n            me       = this,\n            { grid } = me;\n\n        if (me.foundMap) {\n            delete me.foundMap;\n        }\n\n        me.text = null;\n\n        me.clearHits();\n\n        if (me.listenersInitialized) {\n            this.detachListeners('renderCell');\n            this.detachListeners('storeRefresh');\n            me.listenersInitialized = false;\n        }\n\n        if (!silent) {\n            grid.trigger('clearSearch', { grid });\n        }\n    }\n\n    /**\n     * Number of results found\n     * @readonly\n     * @property {Number}\n     */\n    get foundCount() {\n        return this.found?.length ?? 0;\n    }\n\n    //endregion\n\n    //region Navigation\n\n    /**\n     * Returns true if focused row is a hit\n     * @property {Boolean}\n     * @readonly\n     */\n    get isHitFocused() {\n        const\n            me              = this,\n            { grid }        = me,\n            { focusedCell } = grid;\n\n        if (focusedCell?.cell?.contains(DomHelper.getActiveElement(grid.element))) {\n            const { rowIndex, column } = focusedCell;\n\n            return rowIndex !== -1 && me.found.some(hit =>\n                hit.index === rowIndex && column && hit.field === column.field\n            );\n        }\n    }\n\n    /**\n     * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].\n     */\n    gotoNextHit(fromStart = false) {\n        const\n            me = this;\n\n        if (!me.found?.length) return;\n\n        const\n            { grid, store } = me,\n            fromCell        = grid.focusedCell || grid.lastFocusedCell,\n            currentIndex    = fromCell && fromStart !== true ? store.indexOf(fromCell.record, undefined, true) : -1,\n            nextHit         = me.found.findIndex(hit => hit.index > currentIndex);\n\n        if (nextHit !== -1) {\n            me.gotoHit(nextHit);\n        }\n    }\n\n    /**\n     * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].\n     */\n    gotoPrevHit() {\n        const\n            me        = this,\n            { store } = me;\n\n        if (!me.found?.length) return;\n\n        const\n            { grid, found } = me,\n            fromCell        = grid.focusedCell || grid.lastFocusedCell,\n            currentIndex    = fromCell ? store.indexOf(fromCell.record, undefined, true) : 0;\n\n        for (let i = found.length - 1; i--; i >= 0) {\n            const hit = found[i];\n            if (hit.index < currentIndex) {\n                me.gotoHit(i);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Go to specified hit.\n     * @param {Number} index\n     */\n    gotoHit(index) {\n        const\n            { grid } = this,\n            nextHit  = this.found[index];\n\n        if (nextHit) {\n            grid.focusCell({\n                field : nextHit.field,\n                id    : nextHit.id\n            });\n        }\n\n        return Boolean(nextHit);\n    }\n\n    /**\n     * Go to the first hit.\n     */\n    gotoFirstHit() {\n        this.gotoHit(0);\n    }\n\n    /**\n     * Go to the last hit.\n     */\n    gotoLastHit() {\n        this.gotoHit(this.found.length - 1);\n    }\n\n    //endregion\n\n    //region Render\n\n    /**\n     * Called from SubGrid when a cell is rendered. Highlights search hits.\n     * @private\n     */\n    renderCell({ cellElement, column, record, value }) {\n        const\n            me       = this,\n            {\n                treeWalker,\n                findRe,\n                hitTextCls,\n                showHitIndex\n            }        = me,\n            hitIndex = me.foundMap?.[column.field + '-' + record.id];\n\n        if (hitIndex) {\n            // highlight cell\n            cellElement.classList.add(me.hitCls);\n\n            // Remove any previous hit badge\n            showHitIndex && cellElement.querySelector(`.${me.hitCellBadgeCls}`)?.remove();\n\n            // highlight in cell if found in innerHTML\n            const inner = DomHelper.down(cellElement, '.b-grid-cell-value,.b-tree-cell-value') || cellElement;\n\n            if (String(value).toLowerCase() === String(me.text).toLowerCase()) {\n                inner.innerHTML = `<span class=\"${me.hitTextCls}\">${inner.innerHTML}</span>${showHitIndex ? `<div class=\"${me.hitCellBadgeCls}\">${hitIndex}</div>` : ''}`;\n            }\n            // Replace every occurrence of the text in every descendant text node with a span\n            // encapsulating the matched string.\n            else {\n                treeWalker.currentNode = inner;\n                for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode);) {\n                    const\n                        nodeToReplace = textNode,\n                        textContent   = textNode.nodeValue,\n                        newText       = ['<span>'];\n\n                    // Move onto next text node before we replace the node with a highlihght HTML sequence\n                    textNode = treeWalker.nextNode();\n\n                    let offset = findRe.lastIndex;\n\n                    // Convert textContent into an innerHTML string which htmlEncodes the text and embeds\n                    // a highlighting span which contains the target text.\n                    for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {\n                        const\n                            preamble    = textContent.substring(offset, match.index),\n                            spaceBefore = match[1] ? '\\xa0' : '',\n                            v           = match[2],\n                            spaceAfter  = match[3] ? '\\xa0' : '';\n\n                        newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class=\"${hitTextCls}\">${v}</span>${spaceAfter}`);\n                        offset = findRe.lastIndex;\n                    }\n\n                    newText.push(StringHelper.encodeHtml(textContent.substring(offset)), '<span>');\n\n                    // Insert a fragment with each match wrapped with a span.\n                    nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(''), {\n                        fragment : true\n                    }), nodeToReplace);\n                    nodeToReplace.remove();\n                }\n\n                if (showHitIndex) {\n                    DomHelper.createElement({\n                        parent    : cellElement,\n                        className : me.hitCellBadgeCls,\n                        text      : hitIndex\n                    });\n                }\n            }\n\n            me.hitEls.push(cellElement);\n        }\n    }\n\n    //endregion\n\n    //region Context menu\n\n    /**\n     * Add search menu item to cell context menu.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Core.data.Model} options.record Record for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateCellMenu({ column, record, items, cellElement }) {\n        const me = this;\n\n        if (column.searchable) {\n            items.search = {\n                text        : 'L{searchForValue}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-search',\n                cls         : 'b-separator',\n                weight      : 200,\n                disabled    : me.disabled,\n                onItem      : () => {\n                    // TODO: Only extract selection from current cell instead? Lazy way for now\n                    let sel = globalThis.getSelection().toString();\n\n                    if (!sel) {\n                        sel = cellElement.innerText;\n                    }\n\n                    me.search(sel);\n                }\n            };\n        }\n    }\n\n    //endregion\n\n    //region Events\n\n    onStoreRefresh() {\n        this.search(this.text, false, true);\n    }\n\n    //endregion\n}\n\nSearch.featureClass = 'b-search';\n\nGridFeatureManager.registerFeature(Search);\n","import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\n\n/**\n * @module Grid/feature/StickyCells\n */\n\n/**\n * A feature which pins configurable content from a grid row to the top of the grid\n * while the row scrolls off the top but is still visible.\n *\n * As soon as the row becomes too small to contain the content, it is unpinned, and\n * scrolls out naturally, and the following row's configured content becomes pinned.\n *\n * For example:\n *\n * ```javascript\n *     new Grid({\n *         features : {\n *             stickyCells : {\n *                 // Identifies elements to clone and pin to the grid top.\n *                 contentSelector : '.myClassName'\n *             }\n *         }\n *     });\n * ```\n * @extends Core/mixin/InstancePlugin\n * @classtype stickyCells\n * @feature\n */\nexport default class StickyCells extends InstancePlugin {\n    //region Config\n\n    static get $name() {\n        return 'StickyCells';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * A CSS selector which must identify the content within your grid row which you\n             * require to be pinned to the grid while the row if the topmost row, and remains visible.\n             * @config {String}\n             */\n            contentSelector : null,\n\n            currentTopRowCls : 'b-sticky-cells-current-top-row'\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            before : ['renderRows']\n        };\n    }\n    //endregion\n\n    //region Init\n\n    construct(grid, config) {\n        super.construct(grid, config);\n\n        // We cannot chain our client's onGridScroll because that is now a delayable injected method.\n        grid.ion({\n            scroll  : 'onGridScroll',\n            thisObj : this\n        });\n        Object.assign(this, DomHelper.createElement({\n            reference : 'element',\n            parent    : grid.element,\n            className : 'b-grid-sticky-row',\n            children  : [{\n                reference : 'contentElement',\n                className : 'b-grid-cell'\n            }]\n        }));\n\n        // Clean these classes from copied cell and row classLists\n        this.removeClasses = {\n            'b-focused'             : false,\n            'b-hover'               : false,\n            'b-selected'            : false,\n            [this.currentTopRowCls] : false\n        };\n    }\n\n    renderRows() {\n        // Do not leave stranded sticky row visible on data change\n        this.element.classList.add('b-hide-visibility');\n    }\n\n    onGridScroll() {\n        const\n            me = this,\n            {\n                client : grid,\n                element,\n                contentElement\n            } = me,\n            gridViewport  = Rectangle.client(grid.bodyContainer).roundPx(),\n            currentTopRow = grid.rowManager.getRowAt(gridViewport.y),\n            topRowChanged = currentTopRow !== me.currentTopRow;\n\n        if (currentTopRow) {\n            if (topRowChanged) {\n                if (me.currentTopRow) {\n                    me.currentTopRow.removeCls(me.currentTopRowCls);\n                    me.currentTopRow.removeCls('b-not-enough-height');\n                }\n\n                me.currentTopRow = currentTopRow;\n                currentTopRow.addCls(me.currentTopRowCls);\n\n                contentElement.innerHTML = '';\n                contentElement.appendChild(me.updateStickyContent());\n            }\n\n            // If the outgoing row is not not too tall, and doesn't *need* the content\n            // pinning to the top, hide the sticky row, and make the source sticky\n            // elements pin themselves to the bottom of the cell using the b-not-enough-height\n            // class to switch them to align-self: flex-end\n            const notEnoughHeight = me.currentTopRow.bottom - me.client.scrollable.y <= me.stickyContentHeight;\n            me.element.classList[notEnoughHeight ? 'add' : 'remove']('b-hide-visibility');\n            me.currentTopRow[notEnoughHeight ? 'addCls' : 'removeCls']('b-not-enough-height');\n\n            // Keep sticky row aligned while constrained to the viewport.\n            // This keeps it pinned to the top.\n            gridViewport.y += me.stickyContentTop;\n            DomHelper.alignTo(element, me.stickyEls[0], { align : 't0-t0', constrainTo : gridViewport }, true);\n        }\n\n        me.lastProcessedTopRow = currentTopRow;\n    }\n\n    updateStickyContent() {\n        const\n            me            = this,\n            {\n                currentTopRow,\n                removeClasses\n            }             = me,\n            rowClasses   = {\n                'b-grid-sticky-row' : 1\n            },\n            cellClasses  = {},\n            stickyContent = me.stickyContent || (me.stickyContent = document.createDocumentFragment()),\n            stickyEls     = me.stickyEls || (me.stickyEls = []);\n\n        // Release the sticky state on the previous row's sticky elements\n        stickyEls.forEach(e => {\n            e.classList.remove('b-sticky-content-el');\n        });\n\n        // Collect the elements we need to clone from the current top row\n        stickyEls.length = 0;\n        currentTopRow.eachElement(rowEl => {\n            stickyEls.push(...rowEl.querySelectorAll(me.contentSelector));\n        });\n\n        // Clear the documentFragment which we use to hold our clones\n        while (stickyContent.firstChild) {\n            stickyContent.remove(stickyContent.firstChild);\n        }\n\n        me.stickyContentHeight = 0;\n        me.stickyContentTop = 0;\n\n        // Clone the selected elements and measure them for alignment.\n        stickyEls.map(e => {\n            // Collect the app classes that may be necessary on the cell and row elements.\n            e.closest('.b-grid-cell').classList.forEach(cls => cellClasses[cls] = 1);\n            e.closest('.b-grid-row').classList.forEach(cls => rowClasses[cls] = 1);\n\n            // Clean out grid's classes from the class sets.\n            Object.assign(cellClasses, removeClasses);\n            Object.assign(rowClasses,  removeClasses);\n\n            const eTop = e.offsetTop;\n\n            me.stickyContentTop = Math.max(me.stickyContentTop, eTop);\n\n            // We need to know how tall the sticky content is\n            e.style.alignSelf = 'flex-end';\n            me.stickyContentHeight = Math.max(me.stickyContentHeight, me.currentTopRow.height - e.offsetTop + eTop);\n            e.style.alignSelf = '';\n\n            const result = e.cloneNode(true);\n\n            // Tag the content al *after* cloning it.\n            e.classList.add('b-sticky-content-el');\n\n            stickyContent.appendChild(result);\n\n            return result;\n        });\n\n        cellClasses['b-focused'] = false;\n        DomHelper.syncClassList(me.contentElement, cellClasses);\n        DomHelper.syncClassList(me.element, rowClasses);\n\n        return stickyContent;\n    }\n}\n\nGridFeatureManager.registerFeature(StickyCells, false);\n","import Combo from '../../Core/widget/Combo.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport '../../Grid/view/TreeGrid.js';\n\n/**\n * @module Grid/widget/TreeCombo\n */\n\n/**\n * A powerful {@link Core/widget/Combo} box using a {@link Grid/view/TreeGrid} as its drop down widget. You can define\n * your own set of columns to display and use all the regular features of the Grid.\n *\n * {@inlineexample Grid/widget/TreeCombo.js}\n *\n * ```javascript\n * new TreeCombo({\n *     label    : 'Pick task(s)',\n *     width    : '30em',\n *     appendTo : document.body,\n *     picker   : {\n *         // Define the columns to show in the grid\n *         columns : [\n *             { type : 'tree', text : 'Tasks', field : 'name', flex : 1 },\n *             { text : 'Priority', field : 'prio' }\n *         ]\n *     },\n *     chipView : {\n *         // Render the chips in the combo field\n *         itemTpl(record) {\n *             return StringHelper.xss`${record.name}`;\n *         }\n *     },\n *     store : {\n *         fields     : [\n *             'prio'\n *         ],\n *         data : [\n *             {\n *                 name     : 'Development Tasks',\n *                 expanded : true,\n *                 children : [\n *                     { id : 1, name : 'Improve React docs', prio : 'High' },\n *                     { id : 2, name : 'Build Angular module', prio : 'Low' },\n *                     { id : 3, name : 'Creat Vue project', prio : 'Low' }\n *                 ]\n *             },\n *             { name : 'Customer meeting', prio : 'Normal' },\n *             {\n *                 name     : 'Customer Tasks',\n *                 expanded : true,\n *                 children : [\n *                     { id : 4, name : 'Intro meeting', prio : 'Normal' },\n *                     { id : 5, name : 'Build POC', prio : 'High' },\n *                     { id : 6, name : 'Documentation', prio : 'Low' }\n *                 ]\n *             }\n *         ]\n *     }\n * });\n * ```\n *\n * @extends Core/widget/Combo\n * @classtype treecombo\n * @inputfield\n */\nexport default class TreeCombo extends Combo {\n    static $name = 'TreeCombo';\n\n    static type = 'treecombo';\n\n    static configurable = {\n        multiSelect : true,\n        chipView    : {\n            itemTpl(record) {\n                return StringHelper.xss`${record.name}`;\n            },\n            scrollable : {\n                overflowX : 'hidden-scroll'\n            }\n        }\n    };\n\n    configure(config) {\n        super.configure(config);\n        const me = this;\n\n        me.ion({\n            change() {\n                me.picker.selectedRecords = me.value;\n            }\n        });\n    }\n\n    changePicker(picker, oldPicker) {\n        const me = this;\n        return super.changePicker(ObjectHelper.assign({}, picker, {\n            type                       : 'treegrid',\n            minWidth                   : '35em',\n            readOnly                   : me.readOnly,\n            disableGridRowModelWarning : true,\n            selectedRecords            : me.value.map(val => me.store.getById(val)),\n            selectionMode              : {\n                row                  : true,\n                multiSelect          : me.multiSelect,\n                rowCheckboxSelection : true\n            },\n            internalListeners : {\n                selectionChange({ selection }) {\n                    me.value = selection;\n                }\n            }\n        }), oldPicker);\n    }\n}\n\nTreeCombo.initClass();\n"],"names":["ActionColumn","Column","groupHeaderReserved","construct","config","store","me","this","super","arguments","width","flex","grid","ion","paint","thisObj","disableIfGridReadOnly","element","classList","add","externalRenderer","renderer","internalRenderer","column","record","callExternalRenderer","_column$actions","inGroupTitle","meta","subGrid","_this$externalRendere","call","className","children","actions","map","actionConfig","index","_tooltip$startsWith","visible","showForGroup","tooltip","btip","startsWith","callback","customRendererData","action","tag","dataset","_objectSpread","Tooltip","encodeConfig","html","cls","onCellClick","target","_column$actions2","contains","actionIndex","parentElement","actionHandler","onClick","updateAutoWidth","groupActions","oldActions","forEach","actionOriginal","push","length","_actions","actionsHtml","DomHelper","createElement","outerHTML","measureText","_defineProperty","name","type","defaultValue","filterable","groupable","sortable","editor","searchable","htmlEncode","resizable","minWidth","ColumnStore","registerColumnType","exposeProperties","_$name","AggregateColumn","NumberColumn","defaults","function","includeParentInChangeSet","data","columnStore","configuredAlign","configuredEditor","storeListeners","update","prio","oldStore","_store","un","modelClass","field","fieldMap","align","canEdit","isLeaf","sumChildren","args","result","i","parseFloat","avg","onRecordUpdate","changes","rowManager","bubble","rec","row","getRowFor","cellElement","getCell","renderCell","getRawValue","_record$children","value","fn","isMathFn","Math","handler","resolveCallback","apply","r","set","setData","canFillValue","PercentColumn","min","max","showValue","lowThreshold","summaryRenderer","sum","fitMode","constructor","internalCellCls","defaultRenderer","role","tabIndex","style","text","undefined","resizeToFitContent","RatingColumn","emptyIcon","filledIcon","editable","filterType","ArrayHelper","populate","filled","event","readOnly","starIndex","indexOf","parentNode","childNodes","metaKey","shiftKey","get","TemplateColumn","template","Error","renderData","isSpecialRow","TimeColumn","format","formatValue","groupRenderer","groupRowFor","innerHTML","DateHelper","parse","defaultEditor","CellCopyPaste","InstancePlugin","afterConstruct","afterSelectionModeChange","client","selectionMode","cell","_disabledBySelectionMode","disabled","copyOnly","_this$client$features","_copyOnly","features","cellEdit","enabled","canCopy","selectedRecords","selectedCells","canCutPaste","_this$client$features2","isEditing","isActionAvailable","key","sendToClipboard","cells","lastRowIndex","lastColIndex","stringData","sort","c1","c2","rowIndex","columnIndex","_column$toClipboardSt","_cellValue","repeat","cellValue","toClipboardString","_record$get","toString","toCopyString","currentValue","replace","emptyValueChar","BrowserHelper","writeToClipboard","useNativeClipboard","cut","copy","entityName","isCut","filter","_r$record","trigger","copiedDataString","paste","clipboardData","readFromClipboard","targetCell","modifiedRecords","Set","rows","stringAs2dArray","targetCells","_shiftSelectRange","some","equals","cellRows","cellSelectorsAs2dArray","columnCount","curI","curX","rI","targetRecord","getAt","cI","targetColumn","columns","targetField","fromClipboardString","string","toPasteValue","locations","rId","location","id","stringRows","split","populateCellMenu","items","cutCell","cutText","localeClass","icon","weight","onItem","pasteCell","pasteText","copyCell","copyText","chain","keyMap","VersionHelper","isTestEnv","GridFeatureManager","registerFeature","CellTooltip","processConfig","initTip","tip","new","forElement","forSelector","hoverDelay","trackMouse","getHtml","getTooltipContent","bind","internalListeners","pointerOver","listeners","configuredListeners","initialConfig","relayEvents","onPointerOver","getColumnFromElement","tooltipRenderer","Boolean","setConfig","doDestroy","destroy","doDisable","disable","activeTarget","getRecordFromElement","arg","cellTooltip","lastRecord","generation","lastRecordGeneration","lastColumn","Objects","isPromise","_html","ColumnRename","_this$editor","pluginConfig","after","populateHeaderMenu","rename","L","startEdit","_this$client$getHeade","Event","getHeaderDataFromEvent","textWrapper","Editor","owner","render","F2","FillHandle","mixin","Delayable","handleSelection","_fillListeners","onContentChange","afterColumnsChange","fixElementHeights","getCellDataFromEvent","includeSingleAxisMatch","overridden","findPatternsIn2dRange","range","horizontal","negative","values","columnId","isNaN","rowOrCol","pattern","findPatternsIn1dRange","lastValue","next","every","val","Date","diffs","ix","shift","size","increaseBy","getTime","stringPattern","currentIndex","afterSelectionChange","GlobalEvents","isMouseDown","delayUntilMouseUp","removeElements","_isExtending","rangeSelection","drawFillHandleAndBorder","onMouseDown","mouseMoveOrUp","EventHelper","on","globalThis","mouseover","mouseup","stopImmediatePropagation","handled","onMouseUp","currentRange","_isCropping","selectionChange","internalSelectRange","from","to","extensionCells","croppingCells","sel","disableScrollingCloseToEdges","suspendRefresh","firstCell","patterns","changeMap","Map","reverse","_me$calculateFillValu","_column$calculateFill","calculateFillValue","changed","resumeRefresh","performSelection","onMouseOver","_cellSelector","_cellSelector$_column","first","last","cellData","cellSelector","normalizeCellContext","_column","region","equalOrSmaller","cs","enableScrollingCloseToEdges","allowCropping","Location","keepListeners","_me$rangeSelection","regionEl","subGrids","x","Rectangle","right","y","getRecordCoords","bottom","borderElement","handleElement","setRect","height","appendChild","setTopLeft","scrollWidth","toggleCroppingCls","newCells","getRange","handleClick","delegate","mousedown","hasFillElements","_this$croppingCells","_this$client$getCell","toggle","_me$handleElement","_me$borderElement","remove","removeListeners","listener","_client$_shiftSelectR","parent","isAvailable","override","camelCase","mousemove","touchdown","touchmove","touchup","mouseout","dblclick","keydown","keypress","keyup","contextmenu","MergeCells","before","eachSubGrid","setupSubGrid","renderDone","bindStore","$mergedCellsElement","isConfiguring","isDisabling","reset","updatePassthrough","use","detachListeners","change","refresh","onInternalResize","refreshBounds","beforeRenderCell","mergeCells","isSorted","collapsed","mergedRange","getMergeRange","afterRenderRow","oldId","oldHeight","heightChanged","mergedRanges","slice","removeRange","syncDom","afterRemove","afterToggleGroup","afterToggleSubGrid","passthrough","indices","allSelected","fromIndex","toIndex","includes","isSelected","_element$elementData","elementData","_element$elementData2","mergeable","handleEvent","mergedCellsElement","closest","_camelCase$event$type","StringHelper","capitalize","eventData","records","firstElementChild","triggerEvent","toLowerCase","getRowAt","clientY","startEditing","onRangeClick","onStoreChange","onStoreRefresh","createRangeElement","_parent$syncIdMap$syn","_parent$syncIdMap","_parent$releasedIdMap","getSubGridFromColumn","syncId","syncIdMap","releasedIdMap","createRangeDomConfig","DomSync","addChild","_column$mergedRendere","top","left","domConfig","DomClassList","cellCls","assign","autoCls","keepChildren","rowHeight","mergedRenderer","buildMergedCellsConfig","_fromIndex","_rowManager$topRow","_toIndex","_rowManager$bottomRow","topRow","dataIndex","bottomRow","domConfigMap","regions","reduce","updateRange","force","sync","targetElement","syncIdField","onRenderDone","mergedMap","redraw","visibleColumns","c","hadRanges","refreshSuspended","rowCount","boundsMap","bounds","topRendered","bottomRendered","rowOffsetHeight","findIndex","getRowById","rowsAbove","offsetHeight","rowsBelow","earlierRecord","earlierValue","earlierIndex","laterRecord","laterValue","laterIndex","headerBounds","QuickFind","$name","properties","hitCls","hitCellCls","hitCellBadgeCls","hitTextCls","Object","treeWalker","setupTreeWalker","NodeFilter","SHOW_TEXT","FILTER_ACCEPT","focusedCell","isActionable","find","clear","showQuickFind","header","getHeaderElement","headerField","badge","returnAll","mode","colHeader","found","renderListenerInitialized","rendercell","hideQuickFind","hit","prevFound","forceInnerHTML","_content","removeChild","search","columnFieldOrId","getById","findByField","foundMap","findRe","RegExp","escapeRegExp","String","_originalContent","gotoClosestHit","_this$found","foundCount","_this$found$length","_this$found2","gotoHit","nextHit","focusCell","doSelect","focusedIndex","foundSorted","a","b","abs","gotoFirstHit","gotoLastHit","gotoNextHit","_grid$_focusedCell$id","_grid$_focusedCell","_grid$lastFocusedCell","currentId","_focusedCell","lastFocusedCell","gotoPrevHit","_grid$_focusedCell$id2","_grid$_focusedCell2","_grid$lastFocusedCell2","prevHit","_me$foundMap","hitIndex","isQuickHit","inner","currentNode","down","textNode","nextNode","nodeToReplace","textContent","nodeValue","newText","offset","lastIndex","match","exec","preamble","substring","spaceBefore","v","spaceAfter","encodeHtml","insertBefore","createElementFromTemplate","join","fragment","onBackspace","substr","clearSearch","showFilterEditor","onElementKeyPress","_event$key","onCellNavigate","fromCellSelector","toCellSelector","F3","Escape","Backspace","storeRemoveActions","RowExpander","expanderBodyClass","expandedRowClass","recordStateMap","collapsingRecords","isGanttBase","fixedRowHeight","console","warn","addColumn","renderFromRow","changeLoadingIndicatorText","onGridBodyFocusIn","_this$client$lastMous","_this$client$lastMous2","lastMousedownEvent","isAnimating","wasAnimating","changeColumn","has","toggleExpand","hideable","_isAddingExpanderColumn","_expander","columnPosition","insert","onTriggerEvent","collapse","expand","source","delete","refreshOnRecordChange","recordState","isCreated","renderFromRecord","topRecordIndex","topRecord","processRowHeight","_recordState$expander","isRenderingAsync","loadingIndicatorHeight","expanderBodyHeight","expandElements","beforeRenderRow","enableAnimations","waitForTransition","removeExpander","renderExpander","rowElement","getElement","renderLoadingIndicator","lockCellHeight","cellHeight","_shouldScrollIntoView","isInView","once","scrollRowIntoView","onTransitionEnd","property","removeEachSelector","loadingIndicatorText","_row$cells$","renderings","continueRendering","content","expanderElement","addCls","renderResponse","then","Promise","all","_me$renderRowsWithAni","renderRowsWithAnimation","_row$removeCls","isDestroyed","removeCls","unlock","child","Search","configurable","limit","showHitIndex","hitEls","expandNode","onTreeNodeExpand","requestAnimationFrame","reapply","fields","col","formatters","_col$formatValue","isTree","expandTo","prevValue","belongsTo","clearHits","listenersInitialized","asyncEventSuffix","refreshRows","isHitFocused","DomDataStore","silent","_focusedCell$cell","getActiveElement","fromStart","_me$found","fromCell","_me$found2","_cellElement$querySel","querySelector","getSelection","innerText","featureClass","StickyCells","defaultConfig","contentSelector","currentTopRowCls","scroll","reference","removeClasses","renderRows","onGridScroll","contentElement","gridViewport","bodyContainer","roundPx","currentTopRow","topRowChanged","updateStickyContent","notEnoughHeight","scrollable","stickyContentHeight","stickyContentTop","alignTo","stickyEls","constrainTo","lastProcessedTopRow","rowClasses","cellClasses","stickyContent","document","createDocumentFragment","e","eachElement","rowEl","querySelectorAll","firstChild","eTop","offsetTop","alignSelf","cloneNode","syncClassList","TreeCombo","Combo","configure","picker","changePicker","oldPicker","ObjectHelper","disableGridRowModelWarning","multiSelect","rowCheckboxSelection","selection","chipView","itemTpl","xss","overflowX","initClass"],"mappings":"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"}