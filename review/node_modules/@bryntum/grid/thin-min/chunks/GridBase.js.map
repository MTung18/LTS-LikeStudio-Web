{"version":3,"file":"GridBase.js","sources":["../../../lib/Grid/util/Location.js","../../../lib/Grid/column/Column.js","../../../lib/Grid/data/ColumnStore.js","../../../lib/Grid/column/WidgetColumn.js","../../../lib/Grid/column/CheckColumn.js","../../../lib/Grid/column/RowNumberColumn.js","../../../lib/Grid/feature/GridFeatureManager.js","../../../lib/Grid/feature/CellEdit.js","../../../lib/Grid/feature/CellMenu.js","../../../lib/Grid/feature/ColumnDragToolbar.js","../../../lib/Grid/feature/ColumnPicker.js","../../../lib/Grid/feature/ColumnReorder.js","../../../lib/Grid/feature/ColumnResize.js","../../../lib/Grid/widget/GridFieldFilterPicker.js","../../../lib/Grid/widget/GridFieldFilterPickerGroup.js","../../../lib/Grid/feature/Filter.js","../../../lib/Grid/feature/FilterBar.js","../../../lib/Grid/feature/Group.js","../../../lib/Grid/feature/HeaderMenu.js","../../../lib/Grid/feature/Sort.js","../../../lib/Grid/feature/Stripe.js","../../../lib/Grid/row/Row.js","../../../lib/Grid/view/Bar.js","../../../lib/Grid/view/Footer.js","../../../lib/Grid/row/RowManager.js","../../../lib/Grid/util/GridScroller.js","../../../lib/Grid/view/Header.js","../../../lib/Grid/view/mixin/GridElementEvents.js","../../../lib/Grid/view/mixin/GridFeatures.js","../../../lib/Grid/view/mixin/GridNavigation.js","../../../lib/Grid/view/mixin/GridResponsive.js","../../../lib/Grid/view/mixin/GridSelection.js","../../../lib/Grid/view/mixin/GridState.js","../../../lib/Grid/util/SubGridScroller.js","../../../lib/Grid/view/SubGrid.js","../../../lib/Grid/view/mixin/GridSubGrids.js","../../../lib/Grid/localization/En.js","../../../lib/Grid/view/GridBase.js"],"sourcesContent":["import DomHelper from '../../Core/helper/DomHelper.js';\nimport Widget from '../../Core/widget/Widget.js';\n\n/**\n * @module Grid/util/Location\n */\n\n/**\n * This class encapsulates a reference to a specific navigable grid location.\n *\n * This encapsulates a grid cell based upon the record and column, but in addition, it could represent\n * an actionable location *within a cell** if the {@link #property-target} is not the grid cell in\n * question.\n *\n * A Location is immutable. That is, once instantiated, the record and column which it references\n * cannot be changed. The {@link #function-move} method returns a new instance.\n *\n * A `Location` that encapsulates a cell within the body of a grid will have the following\n * read-only properties:\n *\n *  - grid        : `Grid` The Grid that owns the Location.\n *  - record      : `Model` The record of the row that owns the Location. (`null` if the header).\n *  - rowIndex    : `Number` The zero-based index of the row that owns the Location. (-1 means the header).\n *  - column      : `Column` The Column that owns the Location.\n *  - columnIndex : `Number` The zero-based index of the column that owns the Location.\n *  - cell        : `HTMLElement` The referenced cell element.\n *  - target      : `HTMLElement` The focusable element. This may be the cell, or a child of the cell.\n *\n * If the location is a column *header*, the `record` will be `null` and the `rowIndex` will be `-1`.\n *\n */\nexport default class Location {\n    /**\n     * The grid which this Location references.\n     * @config {Grid.view.Grid} grid\n     */\n    /**\n     * The record which this Location references. (unless {@link #config-rowIndex} is used to configure)\n     * @config {Core.data.Model} record\n     */\n    /**\n     *\n     * The row index which this Location references. (unless {@link #config-record} is used to configure).\n     *\n     * `-1` means the header row, in which case the {@link #config-record} will be `null`.\n     * @config {Number} rowIndex\n     */\n    /**\n     * The Column which this location references. (unless {@link #config-columnIndex} or {@link #config-columnId} is used to configure)\n     * @config {Grid.column.Column} column\n     */\n    /**\n     * The column id which this location references. (unless {@link #config-column} or {@link #config-columnIndex} is used to configure)\n     * @config {String|Number} columnId\n     */\n    /**\n     * The column index which this location references. (unless {@link #config-column} or {@link #config-columnId} is used to configure)\n     * @config {Number} columnIndex\n     */\n    /**\n     * The field of the column index which this location references. (unless another column identifier is used to configure)\n     * @config {String} field\n     */\n\n    /**\n     * Initializes a new Location.\n     * @param {LocationConfig|HTMLElement} location A grid location specifier. This may be:\n     *  * An element inside a grid cell or a grid cell.\n     *  * An object identifying a cell location using the following properties:\n     *    * grid\n     *    * record\n     *    * rowIndex\n     *    * column\n     *    * columnIndex\n     * @function constructor\n     */\n    constructor(location) {\n        // Private usage of init means that we can create an un attached Location\n        // The move method does this.\n        if (location) {\n            // They passed us a Location, so they already know where to go.\n            if (location.isLocation) {\n                return location;\n            }\n\n            // Passed a DOM node.\n            if (location.nodeType === Node.ELEMENT_NODE) {\n                const\n                    grid = Widget.fromElement(location, 'gridbase'),\n                    cell = grid && location.closest(grid.focusableSelector);\n\n                // We are targeted on, or within a cell.\n                if (cell) {\n                    const { dataset } = cell.parentNode;\n\n                    this.init({\n                        grid,\n\n                        // A .b-grid-row will have a data-index\n                        // If it' a column header, we use rowIndex -1\n                        rowIndex : grid.store.includes(dataset.id) ? grid.store.indexOf(dataset.id) : (dataset.index || -1),\n                        columnId : cell.dataset.columnId\n                    });\n                    this.initialTarget = location;\n                }\n            }\n            else {\n                this.init(location);\n            }\n        }\n    }\n\n    init(config) {\n        const me = this;\n\n        //<debug>\n        if (!config.grid) {\n            throw new Error('Grid Location must include grid property');\n        }\n        //</debug>\n        const\n            grid               = me.grid = config.grid,\n            { store, columns } = grid,\n            { visibleColumns } = columns;\n\n        // If we have a target. This is usually only for actionable locations.\n        if (config.target) {\n            me.actionTargets = [me._target = config.target];\n        }\n\n        // Determine our record and rowIndex\n        if (config.record) {\n            me._id = config.record.id;\n        }\n        else if ('id' in config) {\n            me._id = config.id;\n\n            // Null means that the Location is in the grid header, so rowIndex -1\n            if (config.id == null) {\n                me._rowIndex = -1;\n            }\n        }\n        else {\n            const rowIndex = !isNaN(config.row) ? config.row : !isNaN(config.rowIndex) ? config.rowIndex : NaN;\n            //<debug>\n            if (isNaN(rowIndex)) {\n                throw new Error('Grid Location must include either record, or id or rowIndex property');\n            }\n            //</debug>\n            me._rowIndex = Math.max(Math.min(Number(rowIndex), store.count - 1), grid.hideHeaders ? 0 : -1);\n            me._id = store.getAt(me._rowIndex)?.id;\n        }\n        if (!('_rowIndex' in me)) {\n            me._rowIndex = store.indexOf(me.id);\n        }\n\n        // Cache value that we use now. We do not hold a reference to a record\n        me.isSpecialRow = me.record?.isSpecialRow;\n\n        // Determine our column and columnIndex\n        if ('columnId' in config) {\n            me._column = columns.getById(config.columnId);\n        }\n        else if ('field' in config) {\n            me._column = columns.get(config.field);\n        }\n        else {\n            const columnIndex = !isNaN(config.column) ? config.column : !isNaN(config.columnIndex) ? config.columnIndex : NaN;\n\n            if (!isNaN(columnIndex)) {\n                me._columnIndex = Math.min(Number(columnIndex), visibleColumns.length - 1);\n                me._column = visibleColumns[me._columnIndex];\n            }\n            // Fall back to using 'column' property either as index or the Column.\n            // If no column property, use column zero.\n            else {\n                me._column = ('column' in config) ? isNaN(config.column) ? config.column : visibleColumns[config.column] : visibleColumns[0];\n            }\n        }\n        if (!('_columnIndex' in me)) {\n            me._columnIndex = visibleColumns.indexOf(me._column);\n        }\n    }\n\n    // Class identity indicator. Usually added by extending Base, but we don't do that for perf.\n    get isLocation() {\n        return true;\n    }\n\n    equals(other, shallow = false) {\n        const me = this;\n\n        return other?.isLocation &&\n            other.grid   === me.grid &&\n            (\n                // For a more performant check, use the shallow param\n                shallow ? me.id === other.id && me._column === other._column\n                    : (other.record === me.record && other.column === me.column && other.target === me.target)\n            );\n    }\n\n    /**\n     * Yields the row index of this location.\n     * @property {Number}\n     * @readonly\n     */\n    get rowIndex() {\n        const\n            { _id }   = this,\n            { store } = this.grid;\n\n        // Return the up to date row index for our record\n        return store.includes(_id) ? store.indexOf(_id) : Math.min(this._rowIndex, store.count - 1);\n    }\n\n    /**\n     * Used by GridNavigation.\n     * @private\n     */\n    get visibleRowIndex() {\n        const\n            { rowManager } = this.grid,\n            { rowIndex }   = this;\n\n        return rowIndex === -1 ? rowIndex : Math.max(Math.min(rowIndex, rowManager.lastFullyVisibleTow.dataIndex), rowManager.firstFullyVisibleTow.dataIndex);\n    }\n\n    /**\n     * Yields `true` if the cell and row are selectable.\n     *\n     * That is if the record is present in the grid's store and it's not a group summary or group header record.\n     * @property {Boolean}\n     * @readonly\n     */\n    get isSelectable() {\n        return this.grid.store.includes(this._id) && !this.isSpecialRow;\n    }\n\n    get record() {\n        // -1 means the header row\n        if (this._rowIndex > -1) {\n            const { store } = this.grid;\n\n            // Location's record no longer in store; fall back to record at same index.\n            if (!store.includes(this._id)) {\n                return store.getAt(this._rowIndex);\n            }\n\n            return store.getById(this._id);\n        }\n    }\n\n    get id() {\n        return this._id;\n    }\n\n    get column() {\n        const { visibleColumns } = this.grid.columns;\n\n        // Location's column no longer visible; fall back to column at same index.\n        if (!visibleColumns?.includes(this._column)) {\n            return visibleColumns?.[this.columnIndex];\n        }\n\n        return this._column;\n    }\n\n    get columnId() {\n        return this.column?.id;\n    }\n\n    get columnIndex() {\n        return Math.min(this._columnIndex, this.grid.columns.visibleColumns?.length - 1);\n    }\n\n    /**\n     * Returns a __*new *__ `Location` instance having moved from the current location in the\n     * mode specified.\n     * @param {Number} where Where to move from this Location. May be:\n     *\n     *  - `Location.UP`\n     *  - `Location.NEXT_CELL`\n     *  - `Location.DOWN`\n     *  - `Location.PREV_CELL`\n     *  - `Location.FIRST_COLUMN`\n     *  - `Location.LAST_COLUMN`\n     *  - `Location.FIRST_CELL`\n     *  - `Location.LAST_CELL`\n     *  - `Location.PREV_PAGE`\n     *  - `Location.NEXT_PAGE`\n     * @returns {Grid.util.Location} A Location object encapsulating the target location.\n     */\n    move(where) {\n        const\n            me        = this,\n            {\n                record,\n                column,\n                grid\n            }         = me,\n            { store } = grid,\n            columns   = grid.columns.visibleColumns,\n            result    = new Location();\n\n        let rowIndex    = store.includes(record)   ? store.indexOf(record)   : me.rowIndex,\n            columnIndex = columns.includes(column) ? columns.indexOf(column) : me.columnIndex;\n\n        const\n            rowMin        = grid.hideHeaders ? 0 : -1,\n            rowMax        = store.count - 1,\n            colMax        = columns.length - 1,\n            atFirstRow    = rowIndex === rowMin,\n            atLastRow     = rowIndex === rowMax,\n            atFirstColumn = columnIndex === 0,\n            atLastColumn  = columnIndex === colMax;\n\n        switch (where) {\n            case Location.PREV_CELL:\n                if (atFirstColumn) {\n                    if (!atFirstRow) {\n                        columnIndex = colMax;\n                        rowIndex--;\n                    }\n                }\n                else {\n                    columnIndex--;\n                }\n                break;\n            case Location.NEXT_CELL:\n                if (atLastColumn) {\n                    if (!atLastRow) {\n                        columnIndex = 0;\n                        rowIndex++;\n                    }\n                }\n                else {\n                    columnIndex++;\n                }\n                break;\n            case Location.UP:\n                if (!atFirstRow) {\n                    rowIndex--;\n                }\n                break;\n            case Location.DOWN:\n                if (!atLastRow) {\n                    // From the col header, we drop to the topmost fully visible row.\n                    if (rowIndex === -1) {\n                        rowIndex = grid.rowManager.firstFullyVisibleRow.dataIndex;\n                    }\n                    else {\n                        rowIndex++;\n                    }\n                }\n                break;\n            case Location.FIRST_COLUMN:\n                columnIndex = 0;\n                break;\n            case Location.LAST_COLUMN:\n                columnIndex = colMax;\n                break;\n            case Location.FIRST_CELL:\n                rowIndex = rowMin;\n                columnIndex = 0;\n                break;\n            case Location.LAST_CELL:\n                rowIndex = rowMax;\n                columnIndex = colMax;\n                break;\n            case Location.PREV_PAGE:\n                rowIndex = Math.max(rowMin, rowIndex - Math.floor(grid.scrollable.clientHeight / grid.rowHeight));\n                break;\n            case Location.NEXT_PAGE:\n                rowIndex = Math.min(rowMax, rowIndex + Math.floor(grid.scrollable.clientHeight / grid.rowHeight));\n                break;\n        }\n\n        // Set the calculated coordinates in the result.\n        result.init({\n            grid,\n            rowIndex,\n            columnIndex\n        });\n\n        return result;\n    }\n\n    /**\n     * The cell DOM element which this Location references.\n     * @property {HTMLElement}\n     * @readonly\n     */\n    get cell() {\n        const\n            me = this,\n            {\n                grid,\n                id,\n                _cell\n            }  = me;\n\n        // Property value set\n        if (_cell) {\n            return _cell;\n        }\n\n        // On a header cell\n        if (id == null) {\n            return grid.columns.getById(me.columnId)?.element;\n        }\n        else {\n            const { row } = me;\n\n            if (row) {\n                return row.getCell(me.columnId) || row.getCell(grid.columns.getAt(me.columnIndex)?.id);\n            }\n        }\n    }\n\n    get row() {\n        // Use our record ID by preference, but fall back to our row index if not present\n        return this.grid.getRowById(this.id) || this.grid.getRow(this.rowIndex);\n    }\n\n    /**\n     * The DOM element which encapsulates the focusable target of this Location.\n     *\n     * This is usually the {@link #property-cell}, but if this is an actionable location, this\n     * may be another DOM element within the cell.\n     * @property {HTMLElement}\n     * @readonly\n     */\n    get target() {\n        const\n            { cell, _target }   = this,\n            { focusableFinder } = this.grid;\n\n        // We might be asked for our focusElement before we're fully rendered and painted.\n        if (cell) {\n            // Location was created in disableActionable mode with the target\n            // explicitly directed to the cell.\n            if (_target) {\n                return _target;\n            }\n            focusableFinder.currentNode = this.grid.focusableFinderCell = cell;\n\n            return focusableFinder.nextNode() || cell;\n        }\n    }\n\n    /**\n     * This property is `true` if the focus target is not the cell itself.\n     * @property {Boolean}\n     * @readonly\n     */\n    get isActionable() {\n        const\n            { cell, _target } = this,\n            containsFocus     = cell?.compareDocumentPosition(DomHelper.getActiveElement(cell)) & Node.DOCUMENT_POSITION_CONTAINED_BY;\n\n        // The actual target may be inside the cell, or just positioned to *appear* inside the cell\n        // such as event/task rendering.\n        return Boolean(containsFocus || (_target && _target !== this.cell));\n    }\n\n    /**\n     * This property is `true` if this location represents a column header.\n     * @property {Boolean}\n     * @readonly\n     */\n    get isColumnHeader() {\n        return this.cell && this.rowIndex === -1;\n    }\n\n    /**\n     * This property is `true` if this location represents a cell in the grid body.\n     * @property {Boolean}\n     * @readonly\n     */\n    get isCell() {\n        return this.cell && this.record;\n    }\n}\n\nLocation.UP           = 1;\nLocation.NEXT_CELL    = 2;\nLocation.DOWN         = 3;\nLocation.PREV_CELL    = 4;\nLocation.FIRST_COLUMN = 5;\nLocation.LAST_COLUMN  = 6;\nLocation.FIRST_CELL   = 7;\nLocation.LAST_CELL    = 8;\nLocation.PREV_PAGE    = 9;\nLocation.NEXT_PAGE    = 10;\n","import Model from '../../Core/data/Model.js';\nimport Localizable from '../../Core/localization/Localizable.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Events from '../../Core/mixin/Events.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Config from '../../Core/Config.js';\nimport Location from '../util/Location.js';\n\n/**\n * @module Grid/column/Column\n */\n\nconst validWidth = (value) => ((typeof value === 'number') || value?.endsWith('px'));\n\n/**\n * Base class for other column types, used if no type is specified on a column.\n *\n * Default editor is a {@link Core.widget.TextField}.\n *\n * ```javascript\n * const grid = new Grid({\n *   columns : [{\n *     field : 'name',\n *     text  : 'Name'\n *   }, {\n *     text  : 'Hobby',\n *     field : 'others.hobby', // reading nested field data\n *   }, {\n *     type  : 'number', // Will use NumberColumn\n *     field : 'age',\n *     text  : 'Age'\n *   }]\n * });\n * ```\n *\n * ## Column types\n *\n * Grid ships with multiple different column types. Which type to use for a column is specified by the `type` config.\n * The built-in types are:\n *\n * * {@link Grid.column.ActionColumn action} - displays actions (clickable icons) in the cell.\n * * {@link Grid.column.AggregateColumn aggregate} - a column, which, when used as part of a Tree, aggregates the values\n *   of this column's descendants using a configured function which defaults to `sum`.\n * * {@link Grid.column.CheckColumn check} - displays a checkbox in the cell.\n * * {@link Grid.column.DateColumn date} - displays a date in the specified format.\n * * {@link Grid.column.NumberColumn number} - a column for showing/editing numbers.\n * * {@link Grid.column.PercentColumn percent} - displays a basic progress bar.\n * * {@link Grid.column.RatingColumn rating} - displays a star rating.\n * * {@link Grid.column.RowNumberColumn rownumber} - displays the row number in each cell.\n * * {@link Grid.column.TemplateColumn template} - uses a template for cell content.\n * * {@link Grid.column.TimeColumn time} - displays a time in the specified format.\n * * {@link Grid.column.TreeColumn tree} - displays a tree structure when using the {@link Grid.feature.Tree tree}\n *   feature.\n * * {@link Grid.column.WidgetColumn widget} - displays widgets in the cells.\n *\n * ## Grouped columns / headers\n *\n * You can group headers by defining parent and children columns. A group can be dragged as a whole, or users can drag\n * individual columns between groups. The same applies to column visibility using the column picker in the header menu,\n * a group can be toggled as a whole or each column individually.\n *\n * ```javascript\n * const grid = new Grid({\n *     {\n *             text     : 'Parent',\n *             children : [\n *                 { text : 'Child 1', field : 'field1', flex : 1 },\n *                 { text : 'Child 2', field : 'field2', flex : 1 }\n *             ]\n *         },\n *         ...\n * }\n * ```\n *\n * {@inlineexample Grid/column/ColumnGrouped.js}\n *\n * ## Collapsible columns\n *\n * By configuring a parent column with `collapsible: true` it is made collapsible. When collapsing all child columns\n * except the first one are hidden. This behaviour is configurable using the {@link #config-collapseMode} config. To\n * make a column start collapsed, set the {@link #config-collapsed} config to `true`.\n *\n * {@inlineexample Grid/column/ColumnCollapse.js}\n *\n * ## Cell renderers\n *\n * You can affect the contents and styling of cells in a column using a\n * {@link Grid.column.Column#config-renderer} function.\n *\n * ```javascript\n * const grid = new Grid({\n *   columns : [\n *   ...\n *     {\n *       field      : 'approved',\n *       text       : 'Approved',\n *       htmlEncode : false, // allow to use HTML code\n *       renderer({ value }) {\n *         return value === true ? '<b>Yes</b>' : '<i>No</i>';\n *       }\n *     }\n *     ...\n *     ]\n * });\n * ```\n *\n * ## Menus\n *\n * You can add custom items to the context menu for a columns header and for its cells, using\n * {@link Grid.column.Column#config-headerMenuItems} and {@link Grid.column.Column#config-cellMenuItems}. Here is an\n * example:\n *\n * ```javascript\n * const grid = new Grid({\n *   columns : [\n *     ...\n *     {\n *       type  : 'number',\n *       field : 'age',\n *       text  : 'Age',\n *       headerMenuItems: [{\n *           text : 'My unique header item',\n *           icon : 'b-fa b-fa-paw',\n *           onItem() { console.log('item clicked'); }\n *       }],\n *       cellMenuItems: [{\n *           text : 'My unique cell item',\n *           icon : 'b-fa b-fa-plus',\n *           onItem() { console.log('item clicked'); }\n *       }]\n *     }\n *   ...\n *   ]\n * });\n * ```\n *\n * @extends Core/data/Model\n * @classType column\n * @mixes Core/mixin/Events\n * @mixes Core/localization/Localizable\n * @column\n */\nexport default class Column extends Model.mixin(Events, Localizable) {\n    static get $name() {\n        return 'Column';\n    }\n\n    /**\n     * Column name alias which you can use in the `columns` array of a Grid.\n     *\n     * ```javascript\n     * class MyColumn extends Column {\n     *     static get type() {\n     *        return 'mycolumn';\n     *     }\n     * }\n     * ```\n     *\n     * ```javascript\n     * const grid = new Grid({\n     *    columns : [\n     *       { type : 'mycolumn', text : 'The column', field : 'someField', flex : 1 }\n     *    ]\n     * });\n     * ```\n     *\n     * @static\n     * @member {String} type\n     */\n    static get type() {\n        return 'column';\n    }\n\n    //region Config\n\n    /**\n     * Default settings for the column, applied in constructor. None by default, override in subclass.\n     * @member {Object} defaults\n     * @returns {Object}\n     * @readonly\n     */\n\n    static get fields() {\n        return [\n            //region Common\n\n            'type',\n\n            /**\n             * Header text\n             * @prp {String} text\n             * @category Common\n             */\n            'text',\n\n            /**\n             * The {@link Core.data.field.DataField#config-name} of the {@link Core.data.Model data model} field to read\n             * data from.\n             * @config {String} field\n             * @category Common\n             */\n            'field',\n\n            // NOTE: This is duplicated in WidgetColumn and partly in TreeColumn so remember to change there too if\n            // changing the signature of this function\n            /**\n             * Renderer function, used to format and style the content displayed in the cell. Return the cell text you\n             * want to display. Can also affect other aspects of the cell, such as styling.\n             *\n             * **NOTE:** If you mutate `cellElement`, and you want to prevent cell content from being reset during\n             * rendering, please return `undefined` from the renderer (or just omit the `return` statement) and make\n             * sure that the {@link #config-alwaysClearCell} config is set to `false`.\n             *\n             * ```javascript\n             * new Grid({\n             *     columns : [\n             *         // Returns an empty string if status field value is undefined\n             *         { text : 'Status', renderer : ({ record }) => record.status ?? '' },\n             *\n             *         // From Grid v6.0 there is no need for the undefined check\n             *         // { text : 'Status', renderer : ({ record }) => record.status }\n             *     ]\n             * });\n             * ```\n             *\n             * You can also return a {@link Core.helper.DomHelper#typedef-DomConfig} object describing the markup\n             * ```javascript\n             * new Grid({\n             *     columns : [\n             *         {\n             *              text : 'Status',\n             *              renderer : ({ record }) => {\n             *                  return {\n             *                      class : 'myClass',\n             *                      children : [\n             *                          {\n             *                              tag : 'i',\n             *                              class : 'fa fa-pen'\n             *                          },\n             *                          {\n             *                              tag : 'span',\n             *                              html : record.name\n             *                          }\n             *                      ]\n             *                  };\n             *              }\n             *         }\n             *     ]\n             * });\n             * ```\n             *\n             * You can modify the row element too from inside a renderer to add custom CSS classes:\n             *\n             * ```javascript\n             * new Grid({\n             *     columns : [\n             *         {\n             *             text     : 'Name',\n             *             renderer : ({ record, row }) => {\n             *                // Add special CSS class to new rows that have not yet been saved\n             *               row.cls.newRow = record.isPhantom;\n             *\n             *               return record.name;\n             *         }\n             *     ]\n             * });\n             * ```\n             *\n             * @param {Object} renderData Object containing renderer parameters\n             * @param {HTMLElement} [renderData.cellElement] Cell element, for adding CSS classes, styling etc.\n             * Can be `null` in case of export\n             * @param {*} renderData.value Value to be displayed in the cell\n             * @param {Core.data.Model} renderData.record Record for the row\n             * @param {Grid.column.Column} renderData.column This column\n             * @param {Grid.view.Grid} renderData.grid This grid\n             * @param {Grid.row.Row} [renderData.row] Row object. Can be null in case of export. Use the\n             * {@link Grid.row.Row#function-assignCls row's API} to manipulate CSS class names.\n             * @param {Object} [renderData.size] Set `size.height` to specify the desired row height for the current\n             * row. Largest specified height is used, falling back to configured {@link Grid/view/Grid#config-rowHeight}\n             * in case none is specified. Can be null in case of export\n             * @param {Number} [renderData.size.height] Set this to request a certain row height\n             * @param {Number} [renderData.size.configuredHeight] Row height that will be used if none is requested\n             * @param {Boolean} [renderData.isExport] True if record is being exported to allow special handling during\n             * export.\n             * @param {Boolean} [renderData.isMeasuring] True if the column is being measured for a `resizeToFitContent`\n             * call. In which case an advanced renderer might need to take different actions.\n             * @config {Function} renderer\n             * @category Common\n             */\n            'renderer',\n\n            //'reactiveRenderer',\n\n            /**\n             * Column width. If value is Number then width is in pixels\n             * @config {Number|String} width\n             * @category Common\n             */\n            'width',\n\n            /**\n             * Column width as a flex weight. All columns with flex specified divide the available space (after\n             * subtracting fixed widths) between them according to the flex value. Columns that have flex 2 will be\n             * twice as wide as those with flex 1 (and so on)\n             * @prp {Number} flex\n             * @category Common\n             */\n            'flex',\n\n            /**\n             * This config sizes a column to fits its content. It is used instead of `width` or `flex`.\n             *\n             * This config requires the {@link Grid.feature.ColumnAutoWidth} feature which responds to changes in the\n             * grid's store and synchronizes the widths' of all `autoWidth` columns.\n             *\n             * If this config is not a Boolean value, it is passed as the only argument to the `resizeToFitContent`\n             * method to constrain the column's width.\n             *\n             * @config {Boolean|Number|Number[]} autoWidth\n             * @category Common\n             */\n            'autoWidth',\n\n            /**\n             * This config enables automatic height for all cells in this column. It is achieved by measuring the height\n             * a cell after rendering it to DOM, and then sizing the row using that height (if it is greater than other\n             * heights used for the row).\n             *\n             * Heads up if you render your Grid on page load, if measurement happens before the font you are using is\n             * loaded you might get slightly incorrect heights. For browsers that support it we detect that\n             * and remeasure when fonts are available.\n             *\n             * **NOTE:** Enabling this config comes with a pretty big performance hit. To maintain good performance,\n             * we recommend not using it. You can still set the height of individual rows manually, either through\n             * {@link Grid.data.GridRowModel#field-rowHeight data} or via {@link #config-renderer renderers}.\n             *\n             * Also note that this setting only works fully as intended with non-flex columns.\n             *\n             * Rows will always be at least {@link Grid.view.Grid#config-rowHeight} pixels tall\n             * even if an autoHeight cell contains no data.\n             *\n             * Manually setting a height from a {@link #config-renderer} in this column will take precedence over this\n             * config.\n             *\n             * @config {Boolean} autoHeight\n             * @category Common\n             */\n            'autoHeight',\n\n            /**\n             * Mode to use when measuring the contents of this column in calls to {@link #function-resizeToFitContent}.\n             * Available modes are:\n             *\n             * * 'exact'       - Most precise, renders and measures all cells (Default, slowest)\n             * * 'textContent' - Renders all cells but only measures the one with the longest `textContent`\n             * * 'value'       - Renders and measures only the cell with the longest data (Fastest)\n             * * 'none'/falsy  - Resize to fit content not allowed, a call does nothing\n             *\n             * @config {'exact'|'textContent'|'value'|'none'|null} fitMode\n             * @default 'exact'\n             * @category Common\n             */\n            { name : 'fitMode', defaultValue : 'exact' },\n\n            //endregion\n\n            //region Interaction\n\n            /**\n             * A config object used to create the input field which will be used for editing cells in the\n             * column. Used when {@link Grid.feature.CellEdit} feature is enabled. The Editor refers to\n             * {@link #config-field} for a data source.\n             *\n             * Configure this as `null` to prevent cell editing in this column.\n             *\n             * All subclasses of {@link Core.widget.Field} can be used as editors. The most popular are:\n             * - {@link Core.widget.TextField}\n             * - {@link Core.widget.NumberField}\n             * - {@link Core.widget.DateField}\n             * - {@link Core.widget.TimeField}\n             * - {@link Core.widget.Combo}\n             *\n             * If record has method set + capitalized field, method will be called, e.g. if record has method named\n             * `setFoobar` and the {@link #config-field} is `foobar`, then instead of `record.foobar = value`,\n             * `record.setFoobar(value)` will be called.\n             *\n             * @config {Boolean|String|InputFieldConfig|Core.widget.Field} editor\n             * @category Interaction\n             */\n            { name : 'editor', defaultValue : {} },\n\n            /**\n             * A config object used to configure an {@link Core.widget.Editor} which contains this Column's\n             * {@link #config-editor input field} if {@link Grid.feature.CellEdit} feature is enabled.\n             * @config {EditorConfig} cellEditor\n             * @category Interaction\n             */\n            'cellEditor',\n\n            /**\n             * A function which is called when a cell edit is requested to finish.\n             *\n             * This may be an `async` function which performs complex validation. The edit will not\n             * complete until it returns `false` to mean the edit cannot be finished, or `true` to go\n             * ahead and complete.\n             *\n             * @param {Object} context An object describing the state of the edit at completion request time.\n             * @param {Core.widget.Field} context.inputField The field configured as the column's `editor`.\n             * @param {Core.data.Model} context.record The record being edited.\n             * @param {*} context.oldValue The old value of the cell.\n             * @param {*} context.value The new value of the cell.\n             * @param {Grid.view.Grid} context.grid The host grid.\n             * @param {Object} context.editorContext The {@link Grid.feature.CellEdit} context object.\n             * @param {Grid.column.Column} context.editorContext.column The column being edited.\n             * @param {Core.data.Model} context.editorContext.record The record being edited.\n             * @param {HTMLElement} context.editorContext.cell The cell element hosting the editor.\n             * @param {Core.widget.Editor} context.editorContext.editor The floating Editor widget which is hosting the\n             * input field.\n             * @config {Function} finalizeCellEdit\n             * @category Interaction\n             */\n            'finalizeCellEdit',\n\n            /**\n             * Setting this option means that pressing the `ESCAPE` key after editing the field will\n             * revert the field to the value it had when the edit began. If the value is _not_ changed\n             * from when the edit started, the input field's {@link Core.widget.Field#config-clearable}\n             * behaviour will be activated. Finally, the edit will be canceled.\n             * @config {Boolean} revertOnEscape\n             * @default true\n             * @category Interaction\n             */\n            { name : 'revertOnEscape', defaultValue : true },\n\n            /**\n             * How to handle a request to complete a cell edit in this column if the field is invalid.\n             * There are three choices:\n             *  - `block` The default. The edit is not exited, the field remains focused.\n             *  - `allow` Allow the edit to be completed.\n             *  - `revert` The field value is reverted and the edit is completed.\n             * @config {'block'|'allow'|'revert'} invalidAction\n             * @default 'block'\n             * @category Interaction\n             */\n            { name : 'invalidAction', defaultValue : 'block' },\n\n            /**\n             * Allow sorting of data in the column. You can pass true/false to enable/disable sorting, or provide a\n             * custom sorting function, or a config object for a {@link Core.util.CollectionSorter}\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     columns : [\n             *          {\n             *              // Disable sorting for this column\n             *              sortable : false\n             *          },\n             *          {\n             *              field : 'name',\n             *              // Custom sorting for this column\n             *              sortable(user1, user2) {\n             *                  return user1.name < user2.name ? -1 : 1;\n             *              }\n             *          },\n             *          {\n             *              // A config object for a Core.util.CollectionSorter\n             *              sortable : {\n             *                  property         : 'someField',\n             *                  direction        : 'DESC',\n             *                  useLocaleCompare : 'sv-SE'\n             *              }\n             *          }\n             *     ]\n             * });\n             * ```\n             * When providing a custom sorting function, if the sort feature is configured with\n             * `prioritizeColumns : true` that function will also be used for programmatic sorting of the store:\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     features : {\n             *       sort : {\n             *           prioritizeColumns : true\n             *       }\n             *     },\n             *\n             *     columns : [\n             *          {\n             *              field : 'name',\n             *              // Custom sorting for this column\n             *              sortable(user1, user2) {\n             *                  return user1.name < user2.name ? -1 : 1;\n             *              }\n             *          }\n             *     ]\n             * });\n             *\n             * // Will use sortable() from the column definition above\n             * grid.store.sort('name');\n             * ```\n             *\n             * @config {Boolean|Function|CollectionSorterConfig} sortable\n             * @default true\n             * @category Interaction\n             */\n            {\n                name         : 'sortable',\n                defaultValue : true,\n                // Normalize function/object forms\n                convert(value, column) {\n                    if (!value) {\n                        return false;\n                    }\n\n                    if (value === true) {\n                        return true;\n                    }\n\n                    const sorter = {};\n\n                    if (typeof value === 'function') {\n                        sorter.originalSortFn = value;\n                        // Scope for sortable() expected to be the column\n                        sorter.sortFn = value.bind(column);\n                    }\n                    else if (typeof value === 'object') {\n                        Object.assign(sorter, value);\n\n                        if (sorter.fn) {\n                            sorter.sortFn = sorter.fn;\n                            delete sorter.fn;\n                        }\n                    }\n\n                    return sorter;\n                }\n            },\n\n            /**\n             * Allow searching in the column (respected by QuickFind and Search features)\n             * @config {Boolean} searchable\n             * @default true\n             * @category Interaction\n             */\n            { name : 'searchable', defaultValue : true },\n\n            /**\n             * If `true`, this column will show a collapse/expand icon in its header, only applicable for parent columns\n             * @config {Boolean} collapsible\n             * @default false\n             * @category Interaction\n             */\n            { name : 'collapsible', defaultValue : false },\n\n            /**\n             * The collapsed state of this column, only applicable for parent columns\n             * @config {Boolean} collapsed\n             * @default false\n             * @category Interaction\n             */\n            { name : 'collapsed', defaultValue : false },\n\n            /**\n             * The collapse behavior when collapsing a parent column. Specify \"toggleAll\" or \"showFirst\".\n             * * \"showFirst\" toggles visibility of all but the first columns.\n             * * \"toggleAll\" toggles all children, useful if you have a special initially hidden column which gets shown\n             * in collapsed state.\n             * @config {String} collapseMode\n             * @default 'showFirst'\n             * @category Interaction\n             */\n            { name : 'collapseMode' },\n\n            /**\n             * Allow filtering data in the column (if {@link Grid.feature.Filter} or {@link Grid.feature.FilterBar}\n             * feature is enabled).\n             *\n             * Also allows passing a custom filtering function that will be called for each record with a single\n             * argument of format `{ value, record, [operator] }`. Returning `true` from the function includes the\n             * record in the filtered set.\n             *\n             * Configuration object may be used for {@link Grid.feature.FilterBar} feature to specify `filterField`. See\n             * an example in the code snippet below or check {@link Grid.feature.FilterBar} page for more details.\n             *\n             * ```\n             * const grid = new Grid({\n             *     columns : [\n             *          {\n             *              field : 'name',\n             *              // Disable filtering for this column\n             *              filterable : false\n             *          },\n             *          {\n             *              field : 'age',\n             *              // Custom filtering for this column\n             *              filterable: ({ value, record }) => Math.abs(record.age - value) < 10\n             *          },\n             *          {\n             *              field : 'start',\n             *              // Changing default field type\n             *              filterable: {\n             *                  filterField : {\n             *                      type : 'datetime'\n             *                  }\n             *              }\n             *          },\n             *          {\n             *              field : 'city',\n             *              // Filtering for a value out of a list of values\n             *              filterable: {\n             *                  filterField : {\n             *                      type  : 'combo',\n             *                      value : '',\n             *                      items : [\n             *                          'Paris',\n             *                          'Dubai',\n             *                          'Moscow',\n             *                          'London',\n             *                          'New York'\n             *                      ]\n             *                  }\n             *              }\n             *          },\n             *          {\n             *              field : 'score',\n             *              filterable : {\n             *                  // This filter fn doesn't return 0 values as matching filter 'less than'\n             *                  filterFn : ({ record, value, operator, property }) => {\n             *                      switch (operator) {\n             *                          case '<':\n             *                              return record[property] === 0 ? false : record[property] < value;\n             *                          case '=':\n             *                              return record[property] == value;\n             *                          case '>':\n             *                              return record[property] > value;\n             *                      }\n             *                  }\n             *              }\n             *          }\n             *     ]\n             * });\n             * ```\n             *\n             * When providing a custom filtering function, if the filter feature is configured with\n             * `prioritizeColumns : true` that function will also be used for programmatic filtering of the store:\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     features : {\n             *         filter : {\n             *             prioritizeColumns : true\n             *         }\n             *     },\n             *\n             *     columns : [\n             *          {\n             *              field : 'age',\n             *              // Custom filtering for this column\n             *              filterable: ({ value, record }) => Math.abs(record.age - value) < 10\n             *          }\n             *     ]\n             * });\n             *\n             * // Will use filterable() from the column definition above\n             * grid.store.filter({\n             *     property : 'age',\n             *     value    : 50\n             * });\n             * ```\n             *\n             * To use custom `FilterField` combo `store` it should contain one of these\n             * {@link Core.data.Store#config-data} or {@link Core.data.AjaxStore#config-readUrl} configs.\n             * Otherwise combo will get data from owner Grid store.\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     columns : [\n             *          {\n             *              field : 'name',\n             *              filterable: {\n             *                  filterField {\n             *                      type  : 'combo',\n             *                      store : new Store({\n             *                          data : ['Adam', 'Bob', 'Charlie']\n             *                      })\n             *                  }\n             *              }\n             *          }\n             *     ]\n             * });\n             * ```\n             *\n             * or\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     columns : [\n             *          {\n             *              field : 'name',\n             *              filterable: {\n             *                  filterField : {\n             *                     type  : 'combo',\n             *                     store : new AjaxStore({\n             *                         readUrl  : 'data/names.json',\n             *                         autoLoad : true\n             *                     })\n             *                  }\n             *              }\n             *          }\n             *     ]\n             * });\n             * ```\n             *\n             * @config {Boolean|Function|Object} filterable\n             * @default true\n             * @category Interaction\n             */\n            {\n                name         : 'filterable',\n                defaultValue : true,\n                // Normalize function/object forms\n                convert(value) {\n                    if (!value) {\n                        return false;\n                    }\n\n                    if (value === true) {\n                        return true;\n                    }\n\n                    const filter = {\n                        columnOwned : true\n                    };\n\n                    if (typeof value === 'function') {\n                        filter.filterFn = value;\n                    }\n                    else if (typeof value === 'object') {\n                        Object.assign(filter, value);\n                    }\n\n                    return filter;\n                }\n            },\n\n            /**\n             * Setting this flag to `true` will prevent dropping child columns into a group column\n             * @config {Boolean} sealed\n             * @default false\n             * @category Interaction\n             */\n            { name : 'sealed' },\n\n            /**\n             * Allow column visibility to be toggled through UI\n             * @config {Boolean} hideable\n             * @default true\n             * @category Interaction\n             */\n            { name : 'hideable', defaultValue : true },\n\n            /**\n             * Set to false to prevent this column header from being dragged\n             * @config {Boolean} draggable\n             * @category Interaction\n             */\n            { name : 'draggable', defaultValue : true },\n\n            /**\n             * Set to false to prevent grouping by this column\n             * @config {Boolean} groupable\n             * @category Interaction\n             */\n            { name : 'groupable', defaultValue : true },\n\n            /**\n             * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.\n             * @config {Boolean} resizable\n             * @default true\n             * @category Interaction\n             */\n            { name : 'resizable', defaultValue : true },\n\n            //endregion\n\n            //region Rendering\n\n            /**\n             * Renderer function for group headers (when using Group feature).\n             * @param {Object} renderData\n             * @param {HTMLElement} renderData.cellElement Cell element, for adding CSS classes, styling etc.\n             * @param {*} renderData.groupRowFor Current group value\n             * @param {Core.data.Model} renderData.record Record for the row\n             * @param {Core.data.Model[]} renderData.groupRecords Records in the group\n             * @param {Grid.column.Column} renderData.column Current rendering column\n             * @param {Grid.column.Column} renderData.groupColumn Column that the grid is grouped by\n             * @param {Number} renderData.count Number of records in the group\n             * @param {Grid.view.Grid} renderData.grid This grid\n             * @config {Function} groupRenderer\n             * @returns {String} The header grouping text\n             * @category Rendering\n             */\n            'groupRenderer',\n\n            /**\n             * Renderer function for the column header.\n             * @param {Object} renderData\n             * @param {Grid.column.Column} renderData.column This column\n             * @param {HTMLElement} renderData.headerElement The header element\n             * @config {Function} headerRenderer\n             * @category Rendering\n             */\n            'headerRenderer',\n\n            /**\n             * A tooltip string to show when hovering the column header, or a config object which can\n             * reconfigure the shared tooltip by setting boolean, numeric and string config values.\n             * @config {String|TooltipConfig} tooltip\n             * @category Rendering\n             */\n            'tooltip',\n\n            /**\n             * Renderer function for the cell tooltip (used with {@link Grid.feature.CellTooltip} feature).\n             * Specify `false` to disable tooltip for this column.\n             * @param {HTMLElement} cellElement Cell element\n             * @param {Core.data.Model} record Record for cell row\n             * @param {Grid.column.Column} column Cell column\n             * @param {Grid.feature.CellTooltip} cellTooltip Feature instance, used to set tooltip content async\n             * @param {MouseEvent} event The event that triggered the tooltip\n             * @config {Function|Boolean} tooltipRenderer\n             * @category Rendering\n             */\n            'tooltipRenderer',\n\n            /**\n             * CSS class added to each cell in this column\n             * @prp {String} cellCls\n             * @category Rendering\n             */\n            'cellCls',\n\n            /**\n             * CSS class added to the header of this column\n             * @config {String} cls\n             * @category Rendering\n             */\n            'cls',\n\n            /**\n             * Icon to display in header. Specifying an icon will render a `<i>` element with the icon as value for the\n             * class attribute\n             * @prp {String} icon\n             * @category Rendering\n             */\n            'icon',\n\n            //endregion\n\n            //region Layout\n\n            /**\n             * Text align. Accepts `'left'`/`'center'`/`'right'` or direction neutral `'start'`/`'end'`\n             * @config {'left'|'center'|'right'|'start'|'end'} align\n             * @category Layout\n             */\n            'align',\n\n            /**\n             * Column minimal width. If value is `Number`, then minimal width is in pixels\n             * @config {Number|String} minWidth\n             * @default 60\n             * @category Layout\n             */\n            { name : 'minWidth', defaultValue : 60 },\n\n            /**\n             * Column maximal width. If value is Number, then maximal width is in pixels\n             * @config {Number|String} maxWidth\n             * @category Common\n             */\n            'maxWidth',\n\n            /**\n             * Columns hidden state. Specify `true` to hide the column, `false` to show it.\n             * @prp {Boolean} hidden\n             * @category Layout\n             */\n            { name : 'hidden', defaultValue : false },\n\n            /**\n             * Convenient way of putting a column in the \"locked\" region. Same effect as specifying region: 'locked'.\n             * If you have defined your own regions (using {@link Grid.view.Grid#config-subGridConfigs}) you should use\n             * {@link #config-region} instead of this one.\n             * @config {Boolean} locked\n             * @default false\n             * @category Layout\n             */\n            { name : 'locked' },\n\n            /**\n             * Region (part of the grid, it can be configured with multiple) where to display the column. Defaults to\n             * {@link Grid.view.Grid#config-defaultRegion}.\n             *\n             * A column under a grouped header automatically belongs to the same region as the grouped header.\n             *\n             * @config {String} region\n             * @category Layout\n             */\n            { name : 'region' },\n\n            /**\n             * Specify `true` to merge cells within the column whose value match between rows, making the first\n             * occurrence of the value span multiple rows.\n             *\n             * Only applies when using the {@link Grid/feature/MergeCells MergeCells feature}.\n             *\n             * This setting can also be toggled using the column header menu.\n             *\n             * @config {Boolean} mergeCells\n             * @category Merge cells\n             */\n            { name : 'mergeCells', type : 'boolean' },\n\n            /**\n             * Set to `false` to prevent merging cells in this column using the column header menu.\n             *\n             * Only applies when using the {@link Grid/feature/MergeCells MergeCells feature}.\n             *\n             * @config {Boolean} mergeable\n             * @default true\n             * @category Merge cells\n             */\n            { name : 'mergeable', type : 'boolean', defaultValue : true },\n\n            /**\n             * An empty function by default, but provided so that you can override it. This function is called each time\n             * a merged cell is rendered. It allows you to manipulate the DOM config object used before it is synced to\n             * DOM, thus giving you control over styling and contents.\n             *\n             * NOTE: The function is intended for formatting, you should not update records in it since updating records\n             * triggers another round of rendering.\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *   columns : [\n             *     {\n             *       field      : 'project',\n             *       text       : 'Project',\n             *       mergeCells : 'true,\n             *       mergedRenderer({ domConfig, value, fromIndex, toIndex }) {\n             *         domConfig.className.highlight = value === 'Important project';\n             *       }\n             *    }\n             *  ]\n             * });\n             * ```\n             *\n             * @config {Function}\n             * @param {Object} detail An object containing the information needed to render a task.\n             * @param {*} detail.value Value that will be displayed in the merged cell\n             * @param {Number} detail.fromIndex Index in store of the first row of the merged cell\n             * @param {Number} detail.toIndex Index in store of the last row of the merged cell\n             * @param {Core.helper.DomHelper#typedef-DomConfig} detail.domConfig DOM config object for the merged cell\n             * element\n             * @category Merge cells\n             */\n            'mergedRenderer',\n\n            //endregion\n\n            // region Menu\n\n            /**\n             * Show column picker for the column\n             * @config {Boolean} showColumnPicker\n             * @default true\n             * @category Menu\n             */\n            { name : 'showColumnPicker', defaultValue : true },\n\n            /**\n             * false to prevent showing a context menu on the column header element\n             * @config {Boolean} enableHeaderContextMenu\n             * @default true\n             * @category Menu\n             */\n            { name : 'enableHeaderContextMenu', defaultValue : true },\n\n            /**\n             * Set to `false` to prevent showing a context menu on the cell elements in this column\n             * @config {Boolean} enableCellContextMenu\n             * @default true\n             * @category Menu\n             */\n            { name : 'enableCellContextMenu', defaultValue : true },\n\n            /**\n             * Extra items to show in the header context menu for this column.\n             *\n             * ```javascript\n             * headerMenuItems : {\n             *     customItem : { text : 'Custom item' }\n             * }\n             * ```\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} headerMenuItems\n             * @category Menu\n             */\n            'headerMenuItems',\n\n            /**\n             * Extra items to show in the cell context menu for this column, `null` or `false` to not show any menu items\n             * for this column.\n             *\n             * ```javascript\n             * cellMenuItems : {\n             *     customItem : { text : 'Custom item' }\n             * }\n             * ```\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} cellMenuItems\n             * @category Menu\n             */\n            'cellMenuItems',\n\n            //endregion\n\n            //region Summary\n\n            /**\n             * Summary type (when using Summary feature). Valid types are:\n             * <dl class=\"wide\">\n             * <dt>sum <dd>Sum of all values in the column\n             * <dt>add <dd>Alias for sum\n             * <dt>count <dd>Number of rows\n             * <dt>countNotEmpty <dd>Number of rows containing a value\n             * <dt>average <dd>Average of all values in the column\n             * <dt>function <dd>A custom function, used with store.reduce. Should take arguments (sum, record)\n             * </dl>\n             * @config {'sum'|'add'|'count'|'countNotEmpty'|'average'|Function} sum\n             * @category Summary\n             */\n            'sum',\n\n            /**\n             * Summary configs, use if you need multiple summaries per column. Replaces {@link #config-sum} and\n             * {@link #config-summaryRenderer} configs.\n             * @config {ColumnSummaryConfig[]} summaries\n             * @category Summary\n             */\n            'summaries',\n\n            /**\n             * Renderer function for summary (when using Summary feature). The renderer is called with an object having\n             * the calculated summary `sum` as only member.\n             * @config {Function} summaryRenderer\n             * @param {Number} summaryRenderer.sum The sum\n             * @category Summary\n             */\n            'summaryRenderer',\n\n            //endregion\n\n            //region Misc\n\n            /**\n             * Column settings at different responsive levels, see responsive demo under examples/\n             * @config {Object} responsiveLevels\n             * @category Misc\n             */\n            'responsiveLevels',\n\n            /**\n             * Tags, may be used by ColumnPicker feature for grouping columns by tag in the menu\n             * @config {String[]} tags\n             * @category Misc\n             */\n            'tags',\n\n            /**\n             * Column config to apply to normal config if viewed on a touch device\n             * @config {ColumnConfig} touchConfig\n             * @category Misc\n             */\n            'touchConfig',\n\n            /**\n             * When using the tree feature, exactly one column should specify { tree: true }\n             * @config {Boolean} tree\n             * @category Misc\n             */\n            'tree',\n\n            /**\n             * Determines which type of filtering to use for the column. Usually determined by the column type used,\n             * but may be overridden by setting this field.\n             * @config {'text'|'date'|'number'|'duration'} filterType\n             * @category Misc\n             */\n            'filterType',\n\n            /**\n             * By default, any rendered column cell content is HTML-encoded. Set this flag to `false` disable this and\n             * allow rendering html elements\n             * @config {Boolean} htmlEncode\n             * @default true\n             * @category Misc\n             */\n            { name : 'htmlEncode', defaultValue : true },\n\n            /**\n             * By default, the header text is HTML-encoded. Set this flag to `false` disable this and allow html\n             * elements in the column header\n             * @config {Boolean} htmlEncodeHeaderText\n             * @default true\n             * @category Misc\n             */\n            { name : 'htmlEncodeHeaderText', defaultValue : true },\n\n            /**\n             * Set to `true`to automatically call DomHelper.sync for html returned from a renderer. Should in most cases\n             * be more performant than replacing entire innerHTML of cell and also allows CSS transitions to work. Has\n             * no effect unless {@link #config-htmlEncode} is disabled. Returned html must contain a single root element\n             * (that can have multiple children). See PercentColumn for example usage.\n             * @config {Boolean} autoSyncHtml\n             * @default false\n             * @category Misc\n             */\n            { name : 'autoSyncHtml', defaultValue : false },\n\n            /**\n             * Set to `false` to not always clear cell content if the {@link #config-renderer} returns `undefined`\n             * or has no `return` statement. This is useful when you mutate the cellElement, and want to prevent\n             * cell content from being reset during rendering. **This is the default behaviour until 6.0.**\n             *\n             * Set to `true` to always clear cell content regardless of renderer return value. **This will be default\n             * behaviour from 6.0.**\n             * @config {Boolean} alwaysClearCell\n             * @default false\n             * @category Misc\n             */\n            { name : 'alwaysClearCell', defaultValue : false },\n            // TODO: Change to true for 6.0\n\n            /**\n             * An array of the widgets to append to the column header\n             * ```javascript\n             * columns : [\n             * {\n             *     text          : 'Name',\n             *     field         : 'name',\n             *     flex          : 1,\n             *     headerWidgets : [\n             *         {\n             *             type   : 'button',\n             *             text   : 'Add row',\n             *             cls    : 'b-raised b-blue',\n             *             async onAction() {\n             *                 const [newRecord] = grid.store.add({\n             *                     name : 'New user'\n             *                 });\n             *\n             *                 await grid.scrollRowIntoView(newRecord);\n             *\n             *                 await grid.features.cellEdit.startEditing({\n             *                     record : newRecord,\n             *                     field  : 'name'\n             *                 });\n             *             }\n             *         }\n             *     ]\n             * }]\n             * ```\n             * @config {ContainerItemConfig[]} headerWidgets\n             * @private\n             * @category Misc\n             */\n            { name : 'headerWidgets' },\n\n            /**\n             * Set to `true` to have the {@link Grid.feature.CellEdit} feature update the record being edited live upon\n             * field edit instead of when editing is finished by using `TAB` or `ENTER`\n             * @config {Boolean} instantUpdate\n             * @category Misc\n             */\n            { name : 'instantUpdate', defaultValue : false },\n\n            { name : 'repaintOnResize', defaultValue : false },\n\n            /**\n             * An optional query selector to select a sub element within the cell being\n             * edited to align a cell editor's `X` position and `width` to.\n             * @config {String} editTargetSelector\n             * @category Misc\n             */\n            'editTargetSelector',\n\n            //endregion\n\n            //region Export\n\n            /**\n             * Used by the Export feature. Set to `false` to omit a column from an exported dataset\n             * @config {Boolean} exportable\n             * @default true\n             * @category Export\n             */\n            { name : 'exportable', defaultValue : true },\n\n            /**\n             * Column type which will be used by {@link Grid.util.TableExporter}. See list of available types in\n             * TableExporter docs. Returns undefined by default, which means column type should be read from the record\n             * field.\n             * @config {String} exportedType\n             * @category Export\n             */\n            { name : 'exportedType' },\n\n            {\n                name         : 'ariaLabel',\n                defaultValue : 'L{Column.columnLabel}'\n            },\n\n            {\n                name         : 'cellAriaLabel',\n                defaultValue : 'L{cellLabel}'\n            }\n            //endregion\n        ];\n    }\n\n    // prevent undefined fields from being exposed, to simplify spotting errors\n    static get autoExposeFields() {\n        return false;\n    }\n\n    //endregion\n\n    //region Init\n\n    construct(data, store) {\n        const me = this;\n\n        me.masterStore = store;\n\n        // Store might be an array\n        if (store) {\n            me._grid = Array.isArray(store) ? store[0].grid : store.grid;\n        }\n\n        me.localizableProperties = Config.mergeMethods.distinct(data.localizableProperties, ['text', 'ariaLabel', 'cellAriaLabel']);\n\n        if (data.localeClass) {\n            me.localeClass = data.localeClass;\n        }\n\n        super.construct(...arguments);\n\n        // Default value for region is assigned by the ColumnStore in createRecord(), same for `locked`\n\n        // Allow field : null if the column does not rely on a record field.\n        // For example the CheckColumn when used by GridSelection.\n        if (me.isLeaf && !('field' in me.data)) {\n            me.field = '_' + (me.type || '') + (++Column.emptyCount);\n            me.noFieldSpecified = true;\n        }\n\n        // If our field is a dot separated path, we must use ObjectHelper.getPath to extract our value\n        me.hasComplexMapping = me.field?.includes('.');\n\n        if (!me.width && !me.flex && !me.children) {\n            // Set the width silently because we're in construction.\n            me.set({\n                width : Column.defaultWidth,\n                flex  : null\n            }, null, true);\n        }\n\n        me.headerWidgets && me.initHeaderWidgets(me.headerWidgets);\n\n        if (me.isParent) {\n            me.meta.visibleChildren = new Set();\n            // Trigger adding expand/collapse button\n            if (me.collapsible) {\n                me.collapsible = true;\n            }\n        }\n\n    }\n\n    get isCollapsible() {\n        return this.children?.length > 1 && this.collapsible;\n    }\n\n    get collapsed() {\n        return this.get('collapsed');\n    }\n\n    set collapsed(collapsed) {\n        // Avoid triggering redraw\n        this.set('collapsed', collapsed, true);\n        // This triggers redraw\n        this.onCollapseChange(!collapsed);\n        this.trigger('toggleCollapse', { collapsed });\n    }\n\n    onCellFocus(location) {\n        this.location = location;\n        this.updateHeaderAriaLabel(this.localizeProperty('ariaLabel'));\n\n        // Update cell if cell is in the grid\n        if (location.rowIndex !== -1) {\n            this.updateCellAriaLabel(this.localizeProperty('cellAriaLabel'));\n        }\n    }\n\n    updateHeaderAriaLabel(headerAriaLabel) {\n        DomHelper.setAttributes(this.element, {\n            'aria-label' : headerAriaLabel\n        });\n    }\n\n    updateCellAriaLabel(cellAriaLabel) {\n        if (!this.location?.isSpecialRow && this.location?.cell) {\n            if (!cellAriaLabel?.length) {\n                cellAriaLabel = this.location.column.text;\n            }\n            DomHelper.setAttributes(this.location.cell, {\n                'aria-label' : cellAriaLabel\n            });\n        }\n    }\n\n    doDestroy() {\n        this.data?.editor?.destroy?.();\n\n        this.destroyHeaderWidgets();\n\n        super.doDestroy();\n    }\n\n    //endregion\n\n    //region Header widgets\n\n    set headerWidgets(widgets) {\n        this.initHeaderWidgets(widgets);\n\n        this.set('headerWidgets', widgets);\n    }\n\n    get headerWidgets() {\n        return this.get('headerWidgets');\n    }\n\n    initHeaderWidgets(widgets) {\n        this.destroyHeaderWidgets();\n\n        const headerWidgetMap = this.headerWidgetMap = {};\n\n        for (const config of widgets) {\n            const widget = Widget.create({ owner : this, ...config });\n\n            headerWidgetMap[widget.ref || widget.id] = widget;\n        }\n    }\n\n    destroyHeaderWidgets() {\n        // Clean up any headerWidgets used\n        for (const widget of Object.values(this.headerWidgetMap || {})) {\n            widget.destroy?.();\n        }\n    }\n\n    //endregion\n\n    //region Fields\n\n    // Yields the automatic cell tagging class, eg b-number-cell from NumberColumn etc\n    static generateAutoCls() {\n        let columnAutoCls = '';\n\n        // Create the auto class for cells owned by this column class\n        // For example NumberColumn cells get b-number-cell\n        // DurationColumn cells get b-duration-cell b-number-cell\n        for (let c = this; c !== Column; c = c.superclass) {\n            c.type && (columnAutoCls += `b-${c.type.toLowerCase()}-cell `);\n        }\n        (Column.autoClsMap || (Column.autoClsMap = new Map())).set(this, columnAutoCls);\n        return columnAutoCls;\n    }\n\n    /**\n     * Returns the full CSS class set for a cell at the passed {@link Grid.util.Location}\n     * as an object where property keys with truthy values denote a class to be added\n     * to the cell.\n     * @param {Grid.util.Location} cellContext\n     * @returns {Object} An object in which property keys with truthy values are used as\n     * the class names on the cell element.\n     * @internal\n     */\n    getCellClass(cellContext) {\n        const\n            { record, column } = cellContext,\n            {\n                cellCls,\n                internalCellCls,\n                grid,\n                constructor,\n                align\n            }          = column,\n            autoCls    = Column.autoClsMap?.get(constructor) || constructor.generateAutoCls(),\n            isEditing  = cellContext.cell.classList.contains('b-editing'),\n            result     = {\n                [grid.cellCls]                 : grid.cellCls,\n                [autoCls]                      : autoCls,\n                [cellCls]                      : cellCls,\n                [internalCellCls]              : internalCellCls,\n                'b-cell-dirty'                 : record.isFieldModified(column.field) && (column.compositeField || record.fieldMap[column.field]?.persist !== false),\n                [`b-grid-cell-align-${align}`] : align,\n                'b-selected'                   : grid.selectionMode.cell && grid.isCellSelected(cellContext),\n                'b-focused'                    : grid.isFocused(cellContext),\n                'b-auto-height'                : column.autoHeight,\n                'b-editing'                    : isEditing\n            };\n\n        // Check cell CSS should not be applied to group header rows\n        if (record.isSpecialRow && result['b-checkbox-selection']) {\n            result['b-checkbox-selection'] = false;\n        }\n\n        return result;\n    }\n\n    get locked() {\n        return this.data.region === 'locked';\n    }\n\n    set locked(locked) {\n        this.region = locked ? 'locked' : 'normal';\n    }\n\n    // Children of grouped header always uses same region as the group\n    get region() {\n        if (!this.parent.isRoot) {\n            return this.parent.region;\n        }\n\n        return this.get('region');\n    }\n\n    set region(region) {\n        this.set('region', region);\n    }\n\n    // parent headers cannot be sorted by\n    get sortable() {\n        return this.isLeaf && this.data.sortable;\n    }\n\n    set sortable(sortable) {\n        this.set('sortable', sortable);\n    }\n\n    // parent headers cannot be grouped by\n    get groupable() {\n        return this.isLeaf && this.data.groupable;\n    }\n\n    set groupable(groupable) {\n        this.set('groupable', groupable);\n    }\n\n    /**\n     * The Field to use as editor for this column\n     * @private\n     * @readonly\n     */\n    get editor() {\n        const me = this;\n\n        let { editor } = me.data;\n\n        if (editor && !editor.isWidget) {\n            // Give frameworks a shot at injecting their own editor, wrapped as a widget\n            const result = me.grid.processCellEditor({ editor, field : me.field });\n\n            if (result) {\n                // Use framework editor\n                editor = me.data.editor = result.editor;\n            }\n            else {\n                if (typeof editor === 'string') {\n                    editor = {\n                        type : editor\n                    };\n                }\n\n                // The two configs, default and configured must be deep merged.\n                editor = me.data.editor = Widget.create(ObjectHelper.merge(me.defaultEditor, {\n                    owner : me.grid,\n\n                    // Field labels must be present for A11Y purposes, but are clipped out of visibility.\n                    // Screen readers will be able to access them and announce them.\n                    label : StringHelper.encodeHtml(me.text)\n                }, editor));\n            }\n        }\n\n        return editor;\n    }\n\n    set editor(editor) {\n        this.data.editor = editor;\n    }\n\n    /**\n     * A config object specifying the editor to use to edit this column.\n     * @private\n     * @readonly\n     */\n    get defaultEditor() {\n        return {\n            type : 'textfield',\n            name : this.field\n        };\n    }\n\n    //endregion\n\n    //region Grid, SubGrid & Element\n\n    /**\n     * Extracts the value from the record specified by this Column's {@link #config-field} specification\n     * in a format that can be used as a value to match by a {@link Grid.feature.Filter filtering} operation.\n     *\n     * The default implementation returns the {@link #function-getRawValue} value, but this may be\n     * overridden in subclasses.\n     * @param {Core.data.Model} record The record from which to extract the field value.\n     * @returns {*} The value of the referenced field if any.\n     */\n    getFilterableValue(record) {\n        return this.getRawValue(record);\n    }\n\n    // Create an ownership hierarchy which links columns up to their SubGrid if no owner injected.\n    get owner() {\n        return this._owner || this.subGrid;\n    }\n\n    set owner(owner) {\n        this._owner = owner;\n    }\n\n    get grid() {\n        return this._grid || this.parent?.grid;\n    }\n\n    // Private, only used in tests where standalone Headers are created with no grid\n    // from which to lookup the associate SubGrid.\n    set subGrid(subGrid) {\n        this._subGrid = subGrid;\n    }\n\n    /**\n     * Get the SubGrid to which this column belongs\n     * @property {Grid.view.SubGrid}\n     * @readonly\n     */\n    get subGrid() {\n        return this._subGrid || this.grid?.getSubGridFromColumn(this);\n    }\n\n    /**\n     * Get the element for the SubGrid to which this column belongs\n     * @property {HTMLElement}\n     * @readonly\n     * @private\n     */\n    get subGridElement() {\n        return this.subGrid.element;\n    }\n\n    /**\n     * The header element for this Column. *Only available after the grid has been rendered*.\n     *\n     * **Note that column headers are rerendered upon mutation of Column values, so this\n     * value is volatile and should not be cached, but should be read whenever needed.**\n     * @property {HTMLElement}\n     * @readonly\n     */\n    get element() {\n        return this.grid.getHeaderElement(this);\n    }\n\n    get nextVisibleSibling() {\n        // During move from one region to another, nextSibling might not be wired up to the new next sibling in region.\n        // (Because the order in master store did not change)\n        const region = this.region;\n\n        let next = this.nextSibling;\n        while (next && (next.hidden || next.region !== region)) {\n            next = next.nextSibling;\n        }\n        return next;\n    }\n\n    get isLastInSubGrid() {\n        return !this.nextVisibleSibling && (this.parent.isRoot || this.parent.isLastInSubGrid);\n    }\n\n    /**\n     * The text wrapping element for this Column. *Only available after the grid has been rendered*.\n     *\n     * This is the full-width element which *contains* the text-bearing element and any icons.\n     *\n     * **Note that column headers are rerendered upon mutation of Column values, so this\n     * value is volatile and should not be cached, but should be read whenever needed.**\n     * @property {HTMLElement}\n     * @readonly\n     */\n    get textWrapper() {\n        return DomHelper.getChild(this.element, '.b-grid-header-text');\n    }\n\n    /**\n     * The text containing element for this Column. *Only available after the grid has been rendered*.\n     *\n     * **Note that column headers are rerendered upon mutation of Column values, so this\n     * value is volatile and should not be cached, but should be read whenever needed.**\n     * @property {HTMLElement}\n     * @readonly\n     */\n    get textElement() {\n        return DomHelper.down(this.element, '.b-grid-header-text-content');\n    }\n\n    /**\n     * The child element into which content should be placed. This means where any\n     * contained widgets such as filter input fields should be rendered. *Only available after the grid has been\n     * rendered*.\n     *\n     * **Note that column headers are rerendered upon mutation of Column values, so this\n     * value is volatile and should not be cached, but should be read whenever needed.**\n     * @property {HTMLElement}\n     * @readonly\n     */\n    get contentElement() {\n        return DomHelper.down(this.element, '.b-grid-header-children');\n    }\n\n    //endregion\n\n    //region Misc properties\n\n    get isSorted() {\n        return this.grid.store.sorters.some(s => s.field === this.field);\n    }\n\n    get isFocusable() {\n        return this.isLeaf;\n    }\n\n    static get text() {\n        return this.$meta.fields.defaults.text;\n    }\n\n    /**\n     * Returns header text based on {@link #config-htmlEncodeHeaderText} config value.\n     * @returns {String}\n     * @internal\n     */\n    get headerText() {\n        return this.htmlEncodeHeaderText ? StringHelper.encodeHtml(this.text) : this.text;\n    }\n\n    /**\n     * An object which contains a map of the header widgets keyed by their {@link Core.widget.Widget#config-ref ref}.\n     * @property {Object<String,Core.widget.Widget>} headerWidgetMap\n     * @private\n     * @readonly\n     */\n    //endregion\n\n    //region Show/hide\n\n    get isVisible() {\n        return !this.hidden && (!this.parent || this.parent.isVisible);\n    }\n\n    /**\n     * Hides this column.\n     */\n    hide(silent = false, hidingParent = false) {\n        const\n            me         = this,\n            { parent } = me;\n\n        // Reject non-change\n        if (!me.hidden) {\n            me.hidden = true;\n\n            if (parent && !parent.isRoot && !parent.isTogglingAll) {\n                // check if all sub columns are hidden, if so hide parent\n                const anyVisible = parent.children.some(child => child.hidden !== true);\n                if (!anyVisible && !parent.hidden) {\n                    silent = true; // hiding parent will trigger event\n                    parent.hide();\n                }\n            }\n\n            if (me.isParent) {\n                me.children.forEach(child => child.hide(true, true));\n            }\n            // Keep state when hiding parent, to be able to restore when showing\n            else if (!parent.isRoot) {\n                parent.meta.visibleChildren[hidingParent ? 'add' : 'delete'](me);\n            }\n\n            if (!silent) {\n                me.stores.forEach(store => store.trigger('columnHide', { column : me }));\n            }\n        }\n    }\n\n    /**\n     * Shows this column.\n     */\n    show(silent = false) {\n        const\n            me         = this,\n            { parent } = me;\n\n        // Reject non-change\n        if (me.hidden) {\n            me.hidden = false;\n\n            if (parent?.hidden) {\n                parent.show();\n            }\n\n            if (me.isParent) {\n                // Only show children\n                me.meta.visibleChildren?.forEach(child => child.show(true));\n            }\n\n            // event is triggered on chained stores\n            if (!silent) {\n                me.stores.forEach(store => store.trigger('columnShow', { column : me }));\n            }\n        }\n    }\n\n    /**\n     * Toggles the column visibility.\n     * @param {Boolean} [force] Set to true (visible) or false (hidden) to force a certain state\n     */\n    toggle(forceVisible) {\n        if ((this.hidden && forceVisible === undefined) || forceVisible === true) {\n            return this.show();\n        }\n\n        if ((!this.hidden && forceVisible === undefined) || forceVisible === false) {\n            return this.hide();\n        }\n    }\n\n    /**\n     * Toggles the column visibility of all children of a parent column.\n     * @param {Grid.column.Column[]} [columns] The set of child columns to toggle, defaults to all children\n     * @param {Boolean} [force] Set to true (visible) or false (hidden) to force a certain state\n     */\n    toggleChildren(columns = this.children, force = undefined) {\n        const me = this;\n\n        me.grid.columns?.beginBatch();\n        me.isTogglingAll = true;\n        columns.forEach(childColumn => childColumn.toggle(force));\n        me.isTogglingAll = false;\n        me.grid.columns?.endBatch();\n    }\n\n    /**\n     * Toggles the collapsed state of the column. Based on the {@link #config-collapseMode}, this either hides all\n     * but the first child column, or toggles the visibility state of all children (if you want to have a special\n     * column shown in collapsed mode).\n     *\n     * Only applicable for columns with child columns.\n     * @private\n     * @param {Boolean} [force] Set to true (expanded) or false (collapsed) to force a certain state\n     */\n    onCollapseChange(force = undefined) {\n        const me = this;\n\n        if (me.collapseMode === 'toggleAll') {\n            me.toggleChildren();\n        }\n        else {\n            const { firstChild } = me;\n\n            // For flexed child column, stamp a width on it in collapsed state\n            if (firstChild.flex != null && me.collapsed) {\n                firstChild.oldFlex = firstChild.flex;\n                firstChild.width = firstChild.element.offsetWidth;\n            }\n            else if (!me.collapsed && firstChild.oldFlex) {\n                // For previously flexed child column, restore the flex value;\n                firstChild.flex = firstChild.oldFlex;\n                firstChild.oldFlex = null;\n            }\n\n            me.grid.columns?.beginBatch();\n            me.isTogglingAll = true;\n            me.children.slice(1).forEach(childColumn => childColumn.toggle(force));\n            me.isTogglingAll = false;\n            me.grid.columns?.endBatch();\n        }\n\n    }\n\n    set collapsible(collapsible) {\n        const me = this;\n\n        me.set('collapsible', collapsible);\n\n        if (me.isParent) {\n            const { headerWidgets = [] } = me;\n\n            if (collapsible) {\n                headerWidgets.push({\n                    type        : 'button',\n                    ref         : 'collapseExpand',\n                    toggleable  : true,\n                    pressed     : me.collapsed,\n                    icon        : `b-icon-collapse-${me.grid.rtl ? 'right' : 'left'}`,\n                    pressedIcon : `b-icon-collapse-${me.grid.rtl ? 'left' : 'right'}`,\n                    cls         : 'b-grid-header-collapse-button b-transparent',\n                    onToggle    : ({ pressed }) => me.collapsed = pressed\n                });\n            }\n            else {\n                const index = headerWidgets.findIndex(w => w.ref === 'collapseExpand');\n                index > -1 && headerWidgets.splice(index, 1);\n            }\n\n            me.headerWidgets = headerWidgets;\n\n            if (me.collapsed) {\n                me.onCollapseChange(false);\n            }\n        }\n    }\n\n    get collapsible() {\n        return this.get('collapsible');\n    }\n\n    //endregion\n\n    //region Index & id\n\n    /**\n     * Generates an id for the column when none is set. Generated ids are 'col1', 'col2' and so on. If a field is\n     * specified (as it should be in most cases) the field name is used instead: 'name1', 'age2' ...\n     * @private\n     * @returns {String}\n     */\n    generateId() {\n        if (!Column.generatedIdIndex) {\n            Column.generatedIdIndex = 0;\n        }\n\n        return (this.field ? this.field.replace(/\\./g, '-') : 'col') + (++Column.generatedIdIndex);\n    }\n\n    /**\n     * Index among all flattened columns\n     * @property {Number}\n     * @readOnly\n     * @internal\n     */\n    get allIndex() {\n        return this.masterStore.indexOf(this);\n    }\n\n    //endregion\n\n    //region Width\n\n    // Returns size in pixels for measured value\n    measureSize(value) {\n        return DomHelper.measureSize(value, this.subGrid?.element);\n    }\n\n    /**\n     * Returns minimal width in pixels for applying to style according to the current `width` and `minWidth`.\n     * @internal\n     */\n    get calcMinWidth() {\n        const { width, minWidth } = this.data;\n\n        if (validWidth(width) && validWidth(minWidth)) {\n            return Math.max(parseInt(width) || 0, parseInt(minWidth) || 0);\n        }\n        else {\n            return width;\n        }\n    }\n\n    /**\n     * Get/set columns width in px. If column uses flex, width will be undefined.\n     * Setting a width on a flex column cancels out flex.\n     *\n     * **NOTE:** Grid might be configured to always stretch the last column, in which case the columns actual width\n     * might deviate from the configured width.\n     *\n     * ```javascript\n     * let grid = new Grid({\n     *     appendTo : 'container',\n     *     height   : 200,\n     *     width    : 400,\n     *     columns  : [{\n     *         text  : 'First column',\n     *         width : 100\n     *     }, {\n     *         text  : 'Last column',\n     *         width : 100 // last column in the grid is always stretched to fill the free space\n     *     }]\n     * });\n     *\n     * grid.columns.last.element.offsetWidth; // 300 -> this points to the real element width\n     * ```\n     * @property {Number|String}\n     */\n    get width() {\n        return this.data.width;\n    }\n\n    set width(width) {\n        const data = { width };\n        if (width && ('flex' in this.data)) {\n            data.flex = null; // remove flex when setting width to enable resizing flex columns\n        }\n        this.set(data);\n    }\n\n    set flex(flex) {\n        const data = { flex };\n        if (flex && ('width' in this.data)) {\n            data.width = null; // remove width when setting flex\n        }\n        this.set(data);\n    }\n\n    get flex() {\n        return this.data.flex;\n    }\n\n    // This method is used to calculate minimum row width for edge and safari\n    // It calculates minimum width of the row taking column hierarchy into account\n    calculateMinWidth() {\n        const\n            me       = this,\n            width    = me.measureSize(me.width),\n            minWidth = me.measureSize(me.minWidth);\n\n        let minChildWidth = 0;\n\n        if (me.children) {\n            minChildWidth = me.children.reduce((result, column) => {\n                return result + column.calculateMinWidth();\n            }, 0);\n        }\n\n        return Math.max(width, minWidth, minChildWidth);\n    }\n\n    /**\n     * Resizes the column to match the widest string in it. By default it also measures the column header, this\n     * behaviour can be configured by setting {@link Grid.view.Grid#config-resizeToFitIncludesHeader}.\n     *\n     * Called internally when you double click the edge between\n     * column headers, but can also be called programmatically. For performance reasons it is limited to checking 1000\n     * rows surrounding the current viewport.\n     *\n     * @param {Number|Number[]} widthMin Minimum allowed width. If content width is less than this, this width is used\n     * instead. If this parameter is an array, the first element is `widthMin` and the seconds is `widthMax`.\n     * @param {Number} widthMax Maximum allowed width. If the content width is greater than this number, this width\n     * is used instead.\n     */\n    resizeToFitContent(widthMin, widthMax, batch = false) {\n        const\n            me                    = this,\n            {\n                grid,\n                element,\n                fitMode\n            } = me,\n            { rowManager, store } = grid,\n            { count }             = store;\n\n        if (count <= 0 || me.fitMode === 'none' || !me.fitMode) {\n            return;\n        }\n\n        const\n            [row]       = rowManager.rows,\n            {\n                rowElement,\n                cellElement\n            }           = grid.beginGridMeasuring(),\n            cellContext = new Location({\n                grid,\n                column : me,\n                id     : null\n            });\n\n        let maxWidth = 0,\n            start, end, i, record, value, length, longest = { length : 0, record : null };\n\n        // Fake element data to be able to use Row#renderCell()\n        cellElement._domData = {\n            columnId : me.id,\n            row,\n            rowElement\n        };\n\n        cellContext._cell             = cellElement;\n        cellContext.updatingSingleRow = true;\n        cellContext.isMeasuring       = true;\n\n        // Clear cellElement, since it is being reused between columns\n        cellElement.innerHTML = '';\n\n        // Measure header unless configured not to\n        if (grid.resizeToFitIncludesHeader) {\n            // Cache the padding\n            if (!grid.$headerPadding) {\n                const style = globalThis.getComputedStyle(element);\n                grid.$headerPadding = parseInt(style.paddingLeft);\n            }\n            // Grab the header text content element\n            const headerText = element.querySelector('.b-grid-header-text-content');\n            // Restyle it to shrinkwrap its text, measure and then restore\n            headerText.style.cssText = 'flex: none; width: auto';\n            maxWidth = headerText.offsetWidth + grid.$headerPadding * 2 + 2; // +2 to avoid overflow ellipsis\n            headerText.style.cssText = '';\n        }\n\n        // If it's a very large dataset, measure the maxWidth of the field in the 1000 rows\n        // surrounding the rendered block.\n        if (count > 1000) {\n            start = Math.max(Math.min(rowManager.topIndex + Math.round(rowManager.rowCount / 2) - 500, count - 1000), 0);\n            end = start + 1000;\n        }\n        else {\n            start = 0;\n            end = count;\n        }\n\n        for (i = start; i < end; i++) {\n            record = store.getAt(i);\n            value = me.getRawValue(record);\n\n            // In value mode we determine the record with the longest value, no rendering involved\n            if (fitMode === 'value') {\n                length = String(value).length;\n            }\n            // In exact and textContent modes we have to render the records\n            else {\n                cellContext._record   = longest.record;\n                cellContext._id       = record.id;\n                cellContext._rowIndex = i;\n\n                row.renderCell(cellContext);\n\n                // Reading textContent is \"cheap\", it does not require a layout\n                if (fitMode === 'textContent') {\n                    length = cellElement.textContent.length;\n                }\n                // Using exact mode, measure the cell = expensive\n                else {\n                    const width = cellElement.offsetWidth;\n                    if (width > maxWidth) {\n                        maxWidth = width;\n                    }\n                }\n            }\n\n            if (length > longest.length) {\n                longest = { record, length, rowIndex : i };\n            }\n        }\n\n        // value mode and textContent mode both required us to render and measure the record determined to be the\n        // longest above\n        if (longest.length > 0 && (fitMode === 'value' || fitMode === 'textContent')) {\n            cellContext._record = longest.record;\n            cellContext._id = longest.record.id;\n            cellContext._rowIndex = longest.rowIndex;\n            row.renderCell(cellContext);\n            maxWidth = Math.max(maxWidth, cellElement.offsetWidth);\n        }\n\n        if (Array.isArray(widthMin)) {\n            [widthMin, widthMax] = widthMin;\n        }\n\n        maxWidth = Math.max(maxWidth, widthMin || 0);\n        maxWidth = Math.min(maxWidth, widthMax || 1e6);  // 1 million px default max\n\n        // Batch mode saves a little time by not removing the measuring elements between columns\n        if (!batch) {\n            grid.endGridMeasuring();\n        }\n\n        me.width = me.maxWidth ? (maxWidth = Math.min(maxWidth, me.maxWidth)) : maxWidth;\n\n        return maxWidth;\n    }\n\n    //endregion\n\n    //region State\n\n    /**\n     * Get column state, used by State mixin\n     * @private\n     */\n    getState() {\n        const\n            me    = this,\n            state = {\n                id     : me.id,\n                // State should only store column attributes which user can modify via UI (except column index).\n                // User can hide column, resize or move it to neighbor region\n                hidden : me.hidden,\n                region : me.region,\n                locked : me.locked\n            };\n\n        if (!me.children) {\n            state[me.flex ? 'flex' : 'width'] = me.flex || me.width;\n        }\n\n        if (me.isCollapsible) {\n            state.collapsed = me.collapsed;\n        }\n\n        return state;\n    }\n\n    /**\n     * Apply state to column, used by State mixin\n     * @private\n     */\n    applyState(state) {\n        const me = this;\n\n        me.beginBatch();\n\n        if ('locked' in state) {\n            me.locked = state.locked;\n        }\n\n        if ('width' in state) {\n            me.width = state.width;\n        }\n\n        if ('flex' in state) {\n            me.flex = state.flex;\n        }\n\n        if ('width' in state && me.flex) {\n            me.flex = undefined;\n        }\n        else if ('flex' in state && me.width) {\n            me.width = undefined;\n        }\n\n        if ('region' in state) {\n            me.region = state.region;\n        }\n\n        me.endBatch();\n\n        if ('hidden' in state) {\n            me.toggle(state.hidden !== true);\n        }\n        if ('collapsed' in state) {\n            me.collapsed = state.collapsed;\n        }\n    }\n\n    //endregion\n\n    //region Other\n\n    remove() {\n        const\n            { subGrid, grid } = this,\n            focusedCell       = subGrid && grid?.focusedCell;\n\n        // Prevent errors when removing the column that the owning grid has registered as focused.\n        if (focusedCell?.columnId === this.id) {\n\n            // Focus is in the grid, navigate before column is removed\n            if (grid.owns(DomHelper.getActiveElement(grid))) {\n                grid.navigateRight();\n            }\n            // Focus not in the grid, bump the focused cell pointer to the next visible column\n            // for when focus returns so it can go as close as possible.\n            else {\n                grid._focusedCell = new Location({\n                    grid,\n                    rowIndex : focusedCell.rowIndex,\n                    column   : subGrid.columns.getAdjacentVisibleLeafColumn(this.id, true, true)\n                });\n            }\n        }\n        super.remove();\n    }\n\n    /**\n     * Extracts the value from the record specified by this Column's {@link #config-field} specification.\n     *\n     * This will work if the field is a dot-separated path to access fields in associated records, eg\n     *\n     * ```javascript\n     *  field : 'resource.calendar.name'\n     * ```\n     *\n     * **Note:** This is the raw field value, not the value returned by the {@link #config-renderer}.\n     * @param {Core.data.Model} record The record from which to extract the field value.\n     * @returns {*} The value of the referenced field if any.\n     */\n    getRawValue(record) {\n        if (this.hasComplexMapping) {\n            return ObjectHelper.getPath(record, this.field);\n        }\n\n        // Engine can change field value to null, in which case cell will render previous record value,\n        // before project commit\n        return record[this.field];\n    }\n\n    /**\n     * Refresh the cell for supplied record in this column, if that cell is rendered.\n     * @param {Core.data.Model} record Record used to get row to update the cell in\n     */\n    refreshCell(record) {\n        this.grid.rowManager.refreshCell(record, this.id);\n    }\n\n    /**\n     * Clear cell contents. Base implementation which just sets innerHTML to blank string.\n     * Should be overridden in subclasses to clean up for examples widgets.\n     * @param {HTMLElement} cellElement\n     * @internal\n     */\n    clearCell(cellElement) {\n        cellElement.innerHTML = '';\n\n        delete cellElement._content;\n    }\n\n    /**\n     * Override in subclasses to allow/prevent editing of certain rows.\n     * @param {Core.data.Model} record\n     * @internal\n     */\n    canEdit(record) {\n        // the record can decide which column is editable\n        if (record.isEditable) {\n            const isEditable = record.isEditable(this.field);\n            // returns undefined for unknown field\n            if (isEditable !== undefined) {\n                return isEditable;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Insert a child column(s) before an existing child column. Returns `null` if the parent column is\n     * {@link #config-sealed}\n     * @param {Core.data.Model|Core.data.Model[]} childColumn Column or array of columns to insert\n     * @param {Core.data.Model} [before] Optional column to insert before, leave out to append to the end\n     * @param {Boolean} [silent] Pass `true` to not trigger events during insert\n     * @returns {Core.data.Model|Core.data.Model[]|null}\n     * @category Parent & children\n     */\n    insertChild(childColumn, before = null, silent = false) {\n        childColumn = Array.isArray(childColumn) ? childColumn : [childColumn];\n\n        // If user dragged out only visible child of collapsed parent, make next sibling visible\n        childColumn.forEach(col => {\n            const { parent } = col;\n\n            if (parent?.collapsed && col === parent.firstChild && parent.children.length > 1 && parent.children.filter(child => !child.hidden).length === 1) {\n                col.nextSibling.hidden = false;\n            }\n        });\n\n        return (this.sealed && !this.inProcessChildren) ? null : super.insertChild(...arguments);\n    }\n\n    /**\n     * Override in subclasses to prevent this column from being filled with the {@link Grid.feature.FillHandle} feature\n     * @param {Object} data Object containing information about current cell and fill value\n     * @param {Grid.util.Location} data.cell Current cell data\n     * @param {Grid.util.Location[]} data.range Range from where to calculate values\n     * @param {Core.data.Model} data.record Current cell record\n     * @returns {Boolean}\n     * @internal\n     */\n    canFillValue() {\n        return true;\n    }\n\n    //endregion\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs (fields) for the column, with special handling for sortable, editor, renderer and\n    // headerRenderer\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n\n        // Use unbound sort fn\n        if (this.sortable?.originalSortFn) {\n            result.sortable = this.sortable.originalSortFn;\n        }\n\n        // Don't include internalRenderer in current config\n        if (result.renderer === this.internalRenderer) {\n            delete result.renderer;\n        }\n\n        // Same for headerRenderer\n        if (result.headerRenderer === this.internalHeaderRenderer) {\n            delete result.headerRenderer;\n        }\n\n        delete result.ariaLabel;\n        delete result.cellAriaLabel;\n\n        return result;\n    }\n}\n\n// Registered in ColumnStore as we can't have this in Column due to circular dependencies\n\nColumn.emptyCount = 0;\nColumn.defaultWidth = 100;\nColumn.exposeProperties();\n","import Store from '../../Core/data/Store.js';\nimport Column from '../column/Column.js';\nimport Localizable from '../../Core/localization/Localizable.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Objects from '../../Core/helper/util/Objects.js';\n\n/**\n * @module Grid/data/ColumnStore\n */\n\nconst\n    columnDefinitions = {\n        boolean : {\n            type : 'check'\n        },\n        date : {\n            type : 'date'\n        },\n        integer : {\n            type   : 'number',\n            format : {\n                maximumFractionDigits : 0\n            }\n        },\n        number : {\n            type : 'number'\n        }\n    },\n    lockedColumnSorters = [{\n        field : 'region'\n    }];\n\n/**\n * A store specialized in handling columns. Used by the Grid to hold its columns and used as a chained store by each SubGrid\n * to hold theirs. Should not be instanced directly, instead access it through `grid.columns` or `subGrid.columns`\n *\n * ```\n * // resize first column\n * grid.columns.first.width = 200;\n *\n * // remove city column\n * grid.columns.get('city').remove();\n *\n * // add new column\n * grid.columns.add({text : 'New column'});\n *\n * // add new column to specific region (SubGrid)\n * grid.columns.add({text : 'New column', region : 'locked'});\n *\n * // add new column to 'locked' region (SubGrid)\n * grid.columns.add({text : 'New column', locked : true});\n * ```\n *\n * @extends Core/data/Store\n */\nexport default class ColumnStore extends Localizable(Store) {\n\n    //region Events\n\n    /**\n     * Fires when a column is shown.\n     * @event columnShow\n     * @param {Grid.data.ColumnStore} source The store which triggered the event.\n     * @param {Grid.column.Column} column The column which status has been changed.\n     */\n\n    /**\n     * Fires when a column has been hidden.\n     * @event columnHide\n     * @param {Grid.data.ColumnStore} source The store which triggered the event.\n     * @param {Grid.column.Column} column The column which status has been changed.\n     */\n\n    //endregion\n\n    static get defaultConfig() {\n        return {\n            modelClass : Column,\n            tree       : true,\n\n            /**\n             * Automatically adds a field definition to the store used by the Grid when adding a new Column displaying a\n             * non-existing field.\n             *\n             * To enable this behaviour:\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     columns : {\n             *         autoAddField : true,\n             *         data         : [\n             *             // Column definitions here\n             *         ]\n             *     }\n             * }\n             *\n             * @config {Boolean}\n             * @default\n             */\n            autoAddField : false,\n\n            // Locked columns must sort to before non-locked\n            sorters : lockedColumnSorters\n        };\n    }\n\n    construct(config) {\n        const me = this;\n\n        // Consequences of ColumnStore construction can cause reading of grid.columns\n        // so set the property early.\n        if (config.grid) {\n            config.grid._columnStore = me;\n            me.id = `${config.grid.id}-columns`;\n\n            // Visible columns must be invalidated on expand/collapse\n            config.grid.ion({\n                subGridCollapse : 'clearSubGridCaches',\n                subGridExpand   : 'clearSubGridCaches',\n                thisObj         : me\n            });\n        }\n\n        super.construct(config);\n\n        // So that we can invalidate cached collections which take computing so that we compute them\n        // only when necessary. For example when asking for the visible leaf columns, we do not want\n        // to compute that each time.\n        me.ion({\n            change  : me.onStoreChange,\n            sort    : () => me.updateChainedStores(),\n            thisObj : me,\n            prio    : 1\n        });\n    }\n\n    get modelClass() {\n        return this._modelClass;\n    }\n\n    set modelClass(ClassDef) {\n        this._modelClass = ClassDef;\n    }\n\n    doDestroy() {\n        const allColumns = [];\n\n        if (!this.isChained) {\n            this.traverse(column => allColumns.push(column));\n        }\n\n        super.doDestroy();\n\n        // Store's destroy unjoins all records. Destroy all columns *after* that.\n        if (!this.isChained) {\n            allColumns.forEach(column => column.destroy());\n        }\n    }\n\n    // Overridden because the flat collection only contains top level columns,\n    // not leaves - group columns are *not* expanded.\n    /**\n     * Get column by id.\n     * @param {String|Number} id\n     * @returns {Grid.column.Column}\n     */\n    getById(id) {\n        return super.getById(id) || this.idRegister[id];\n    }\n\n    forEach(fn, thisObj = this) {\n        // Override to omit root\n        this.traverseWhile((n, i) => fn.call(thisObj, n, i), true);\n    }\n\n    get totalFixedWidth() {\n        let result = 0;\n\n        for (const col of this) {\n            if (!col.hidden) {\n                // if column has children (grouped header) use they to width increment\n                if (col.children) {\n                    col.children.forEach(childCol => result += this.calculateFixedWidth(childCol));\n                }\n                else {\n                    result += this.calculateFixedWidth(col);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    get hasFlex() {\n        return this.visibleColumns.some(column => column.flex);\n    }\n\n    calculateFixedWidth(column) {\n        if (column.flex) {\n            return column.measureSize(Column.defaultWidth);\n        }\n        else {\n            return Math.max(column.measureSize(column.width), column.measureSize(column.minWidth));\n        }\n    }\n\n    /**\n     * Returns the top level columns. If using grouped columns, this is the top level columns. If no grouped\n     * columns are being used, this is the leaf columns.\n     * @property {Grid.column.Column[]}\n     * @readonly\n     */\n    get topColumns() {\n        return this.isChained ? this.masterStore.rootNode.children.filter(this.chainedFilterFn) : this.rootNode.children;\n    }\n\n    /**\n     * Returns the visible leaf headers which drive the rows' cell content.\n     * @property {Grid.column.Column[]}\n     * @readonly\n     */\n    get visibleColumns() {\n        const me = this;\n\n        if (!me._visibleColumns) {\n            me._visibleColumns = me.leaves.filter(column => column.isVisible && (!column.subGrid || !column.subGrid.collapsed));\n        }\n\n        return me._visibleColumns;\n    }\n\n    onStoreChange({ action, changes }) {\n        // no need to clear cache while resizing, or if column changes name\n        if (action === 'update' && !('hidden' in changes)) {\n            return;\n        }\n        this.clearCaches();\n    }\n\n    clearSubGridCaches({ subGrid }) {\n        subGrid.columns.clearCaches();\n        this.clearCaches();\n    }\n\n    clearCaches() {\n        this._visibleColumns = null;\n        this.masterStore?.clearCaches();\n    }\n\n    onMasterDataChanged(event) {\n        super.onMasterDataChanged(event);\n\n        // If master store has changes we also need to clear cached columns, in case a column was hidden\n        // no need to clear cache while resizing, or if column changes name\n        if (event.action !== 'update' || ('hidden' in event.changes)) {\n            this.clearCaches();\n        }\n    }\n\n    getAdjacentVisibleLeafColumn(columnOrId, next = true, wrap = false) {\n        const\n            columns = this.visibleColumns,\n            column  = (columnOrId instanceof Column) ? columnOrId : this.getById(columnOrId);\n        let idx = columns.indexOf(column) + (next ? 1 : -1);\n\n        // If we walked off either end, wrap if directed to do so,\n        // otherwise, return null;\n        if (!columns[idx]) {\n            if (wrap) {\n                idx = next ? 0 : columns.length - 1;\n            }\n            else {\n                return null;\n            }\n        }\n\n        return columns[idx];\n    }\n\n    /**\n     * Bottom columns are the ones displayed in the bottom row of a grouped header, or all columns if not using a grouped\n     * header. They are the columns that actually display any data.\n     * @property {Grid.column.Column[]}\n     * @readonly\n     */\n    get bottomColumns() {\n        return this.leaves;\n    }\n\n    /**\n     * Get column by field. To be sure that you are getting exactly the intended column, use {@link Core.data.Store#function-getById Store#getById()} with the\n     * columns id instead.\n     * @param {String} field Field name\n     * @returns {Grid.column.Column}\n     */\n    get(field) {\n        return this.findRecord('field', field, true);\n    }\n\n    /**\n     * Used internally to create a new record in the store. Creates a column of the correct type by looking up the\n     * specified type among registered columns.\n     * @private\n     */\n    createRecord(data) {\n        const\n            { grid = {} } = this, // Some ColumnStore tests lacks Grid\n            { store }     = grid,\n            dataField     = store?.modelClass?.fieldMap?.[data.field];\n\n        let columnClass = this.modelClass;\n\n        // Use the DataField's column definition as a default into which the incoming data is merged\n        if (dataField?.column) {\n            data = Objects.merge({}, dataField.column, data);\n        }\n\n        if (data.type) {\n            columnClass = ColumnStore.getColumnClass(data.type);\n            if (!columnClass) {\n                throw new Error(`Column type '${data.type}' not registered`);\n            }\n        }\n\n        if (data.locked) {\n            data.region = 'locked';\n            delete data.locked;\n        }\n\n        const column = new columnClass(data, this);\n\n        // Doing this after construction, in case the columnClass has a default value for region (Schedulers\n        // TimeAxisColumn has)\n        if (!column.data.region) {\n            column.data.region = grid.defaultRegion || 'normal';\n        }\n\n        // Add missing fields to Grids stores model\n        if (this.autoAddField && !column.noFieldSpecified && store && !dataField) {\n            let fieldDefinition = column.field;\n\n            // Some columns define the type to use for new fields (date, number etc)\n            if (column.constructor.fieldType) {\n                fieldDefinition = {\n                    name : column.field,\n                    type : column.constructor.fieldType\n                };\n            }\n\n            store.modelClass.addField(fieldDefinition);\n        }\n\n        return column;\n    }\n\n    /**\n     * indexOf extended to also accept a columns field, for backward compatibility.\n     * ```\n     * grid.columns.indexOf('name');\n     * ```\n     * @param {Core.data.Model|String} recordOrId\n     * @returns {Number}\n     */\n    indexOf(recordOrId) {\n        if (recordOrId == null) {\n            return -1;\n        }\n        // TODO: build the need for field away\n        const index = super.indexOf(recordOrId);\n        if (index > -1) return index;\n        // no record found by id, find by field since old code relies on that instead of id\n        // TODO: replace such cases with columns id\n        return this.records.findIndex(r => r.field === recordOrId);\n    }\n\n    /**\n     * Checks if any column uses autoHeight\n     * @internal\n     * @property {Boolean}\n     * @readonly\n     */\n    get usesAutoHeight() {\n        return this.find(column => column.autoHeight);\n    }\n\n    /**\n     * Checks if any flex column uses autoHeight\n     * @internal\n     * @property {Boolean}\n     * @readonly\n     */\n    get usesFlexAutoHeight() {\n        return this.find(column => column.autoHeight && column.flex != null);\n    }\n\n    //region Column types\n\n    /**\n     * Call from custom column to register it with ColumnStore. Required to be able to specify type in column config.\n     * @param {Function} columnClass The {@link Grid.column.Column} subclass to register.\n     * @param {Boolean} simpleRenderer Pass `true` if its default renderer does *not* use other fields from the passed\n     * record than its configured {@link Grid.column.Column#config-field}. This enables more granular cell updating\n     * upon record mutation.\n     * @example\n     * // create and register custom column\n     * class CustomColumn {\n     *  static get type() {\n     *      return 'custom';\n     *  }\n     * }\n     * ColumnStore.registerColumnType(CustomColumn, true);\n     * // now possible to specify in column config\n     * let grid = new Grid({\n     *   columns: [\n     *     { type: 'custom', field: 'id' }\n     *   ]\n     * });\n     */\n    static registerColumnType(columnClass, simpleRenderer = false) {\n        columnClass.simpleRenderer = simpleRenderer;\n        (ColumnStore.columnTypes || (ColumnStore.columnTypes = {}))[columnClass.type] = columnClass;\n    }\n\n    /**\n     * Returns registered column class for specified type.\n     * @param type Type name\n     * @returns {Grid.column.Column}\n     * @internal\n     */\n    static getColumnClass(type) {\n        return ColumnStore.columnTypes && ColumnStore.columnTypes[type];\n    }\n\n    /**\n     * Generates a <strong>new </strong> {@link Grid.column.Column} instance which may be subsequently added to this\n     * store to represent the passed {@link Core.data.field.DataField} of the owning Grid's store.\n     * @param {Core.data.field.DataField|String} dataField The {@link Core.data.field.DataField field}\n     * instance or field name to generate a new {@link Grid.column.Column} for.\n     * @param {Object} [defaults] Defaults to apply to the new column.\n     * @returns {Grid.column.Column} A new Column which will render and edit the field correctly.\n     * @example\n     * // Add column for the \"team\" field.\n     * grid.columns.add(grid.columns.generateColumnForField('team', {\n     *     width : 200\n     * }));\n     * @internal\n     */\n    generateColumnForField(dataField, defaults) {\n        if (typeof dataField === 'string' && this.grid) {\n            dataField = this.grid.store?.modelClass.fieldMap[dataField];\n        }\n        let column = dataField.column || columnDefinitions[dataField.type] || {};\n\n        // Upgrade string to be the column tyope\n        if (typeof column === 'string') {\n            column = { type : column };\n        }\n\n        // Configure over defaults\n        column = Object.assign({\n            text  : dataField.text || StringHelper.separate(dataField.name),\n            field : dataField.name\n        }, defaults, column);\n\n        // Special formatting for columns which represent number and integer fields.\n        if (dataField.precision != null) {\n            column.format.maximumFractionDigits = dataField.precision;\n        }\n        if (dataField.columnType) {\n            column.type = dataField.columnType;\n        }\n\n        // Upgrade object to a Column instance.\n        return this.createRecord(column);\n    }\n\n    //endregion\n}\n\n/**\n * Custom {@link Grid.data.ColumnStore} event which triggers when a column is resized, i.e. its width has been changed\n *\n * @param {Function} handler\n * @param {Object} [thisObj]\n */\nexport const columnResizeEvent = (handler, thisObj) => ({\n    update : ({ store, record, changes }) => {\n        let result = true;\n\n        if ('width' in changes || 'minWidth' in changes  || 'maxWidth' in changes || 'flex' in changes) {\n            result = handler.call(thisObj, { store, record, changes });\n        }\n\n        return result;\n    }\n});\n// Can't have this in Column due to circular dependencies\nColumnStore.registerColumnType(Column, true);\n","//TODO: Currently widgets reuse elements already in cell, but performance would improve if entire widget was reused\n\n//TODO: Leaking widget on rerender of row, since the old one is not destroyed\n\nimport WidgetHelper from '../../Core/helper/WidgetHelper.js';\nimport Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\n\n/**\n * @module Grid/column/WidgetColumn\n */\n\n/**\n * A column that displays widgets in the grid cells.\n *\n * {@inlineexample Grid/column/WidgetColumn.js}\n *\n * ```javascript\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         {\n *              type: 'widget',\n *              text: 'Name',\n *              widgets: [\n *                  { type: 'textfield', name : 'firstName' },\n *                  { type: 'textfield', name : 'lastName' }\n *               ]\n *         }\n *     ]\n * });\n * ```\n *\n * If you use {@link Core.widget.Field Fields} inside this column, the field widget can optionally bind its value to a\n * field in the data model using the {@link Core/widget/Field#config-name} (as shown in the snippet above). This will\n * provide two-way data binding and update the underlying row record as you make changes in the field.\n *\n * If you use a {@link Core.widget.Button} and want it to display the value from the cell as its text, set its\n * {@link Core/widget/Widget#config-defaultBindProperty} to `'text'`:\n *\n * ```javascript\n * new Grid({\n *     columns : [\n *         {\n *              type: 'widget',\n *              widgets: [\n *                  { type: 'button', name : 'age', defaultBindProperty : 'text' },\n *               ]\n *         }\n *     ]\n * });\n * ```\n *\n * There is no `editor` provided. It is the configured widget's responsibility to provide editing if needed.\n *\n * @extends Grid/column/Column\n * @classType widget\n * @column\n */\nexport default class WidgetColumn extends Column {\n\n    //region Config\n\n    static type = 'widget';\n\n    static fields = [\n        /**\n         * An array of {@link Core.widget.Widget} config objects\n         * @config {ContainerItemConfig[]} widgets\n         * @category Common\n         */\n        'widgets'\n    ];\n\n    /**\n     * A renderer function, which gives you access to render data like the current `record`, `cellElement` and the\n     * {@link #config-widgets} of the column. See {@link #config-renderer}\n     * for more information.\n     *\n     * ```javascript\n     * new Grid({\n     *     columns : [\n     *         {\n     *              type: 'check',\n     *              field: 'allow',\n     *              // In the column renderer, we get access to the record and column widgets\n     *              renderer({ record, widgets }) {\n     *                  // Hide checkboxes in certain rows\n     *                  widgets[0].hidden = record.readOnly;\n     *              }\n     *         }\n     *     ]\n     * });\n     * ```\n     *\n     * @param {Object} renderData Object containing renderer parameters\n     * @param {HTMLElement|null} [renderData.cellElement] Cell element, for adding CSS classes, styling etc.\n     *        Can be `null` in case of export\n     * @param {*} renderData.value Value to be displayed in the cell\n     * @param {Core.data.Model} renderData.record Record for the row\n     * @param {Grid.column.Column} renderData.column This column\n     * @param {Core.widget.Widget[]} renderData.widgets An array of the widgets rendered into this cell\n     * @param {Grid.view.Grid} renderData.grid This grid\n     * @param {Grid.row.Row} [renderData.row] Row object. Can be null in case of export. Use the\n     * {@link Grid.row.Row#function-assignCls row's API} to manipulate CSS class names.\n     * @param {Object} [renderData.size] Set `size.height` to specify the desired row height for the current row.\n     *        Largest specified height is used, falling back to configured {@link Grid/view/Grid#config-rowHeight}\n     *        in case none is specified. Can be null in case of export\n     * @param {Number} [renderData.size.height] Set this to request a certain row height\n     * @param {Number} [renderData.size.configuredHeight] Row height that will be used if none is requested\n     * @param {Boolean} [renderData.isExport] True if record is being exported to allow special handling during export\n     * @param {Boolean} [renderData.isMeasuring] True if the column is being measured for a `resizeToFitContent`\n     *        call. In which case an advanced renderer might need to take different actions.\n     * @config {Function} renderer\n     * @category Rendering\n     */\n\n    static get defaults() {\n        return {\n            filterable      : false,\n            sortable        : false,\n            editor          : false,\n            searchable      : false,\n            fitMode         : false,\n            alwaysClearCell : false\n        };\n    }\n\n    //endregion\n\n    //region Init / Destroy\n\n    construct(config, store) {\n        const me = this;\n\n        me.widgetMap = {};\n\n        super.construct(...arguments);\n\n        me.externalRenderer = me.renderer;\n        me.renderer = me.internalRenderer;\n    }\n\n    doDestroy() {\n        // Destroy all the widgets we created.\n        for (const widget of Object.values(this.widgetMap)) {\n            widget.destroy && widget.destroy();\n        }\n        super.doDestroy();\n    }\n\n    // Called by grid when its read-only state is toggled\n    updateReadOnly(readOnly) {\n        for (const widget of Object.values(this.widgetMap)) {\n            if (!widget.cellInfo.record.readOnly) {\n                widget.readOnly = readOnly;\n            }\n        }\n    }\n\n    //endregion\n\n    //region Render\n\n    /**\n     * Renderer that displays a widget in the cell.\n     * @param {Object} renderData Render data\n     * @param {Grid.column.Column} renderData.column Rendered column\n     * @param {Core.data.Model} renderData.record Rendered record\n     * @private\n     */\n    internalRenderer(renderData) {\n        const\n            me                                        = this,\n            { cellElement, column, record, isExport } = renderData,\n            { widgets }                               = column;\n\n        // This renderer might be called from subclasses by accident\n        // This condition saves us from investigating bug reports\n        if (!isExport && widgets) {\n            // If there is no widgets yet and we're going to add them,\n            // need to make sure there is no content left in the cell after its previous usage\n            // by grid features such as grouping feature or so.\n            if (!cellElement.widgets) {\n                // Reset cell content\n                me.clearCell(cellElement);\n            }\n            cellElement.widgets = renderData.widgets = widgets.map((widgetCfg, i) => {\n                let widget, widgetNextSibling;\n\n                // If cell element already has widgets, check if we need to destroy/remove one\n                if (cellElement.widgets) {\n                    // Current widget\n                    widget = cellElement.widgets[i];\n\n                    // Store next element sibling to insert widget to correct position later\n                    widgetNextSibling = widget.element.nextElementSibling;\n\n                    // If we are not syncing content for present widget, remove it from cell and render again later\n                    if (widgetCfg.recreate && widget) {\n                        // destroy widget and remove reference to it\n                        delete me.widgetMap[widget.id];\n                        widget.destroy();\n                        cellElement.widgets[i] = null;\n                    }\n                }\n\n                // Ensure widget is created if first time through\n                if (!widget) {\n                    me.onBeforeWidgetCreate(widgetCfg, renderData);\n                    widgetCfg.recomposeAsync = false;\n                    widget = WidgetHelper.append(widgetCfg, widgetNextSibling ? { insertBefore : widgetNextSibling } : cellElement)[0];\n                    me.widgetMap[widget.id] = widget;\n                    me.onAfterWidgetCreate(widget, renderData);\n\n                    if (widget.name) {\n                        widget.ion({\n                            change : ({ value }) => {\n                                widget.cellInfo.record[widget.name] = value;\n                            }\n                        });\n                    }\n                }\n\n                widget.cellInfo = {\n                    record,\n                    column\n                };\n\n                if (me.grid && !me.meta.isSelectionColumn) {\n                    widget.readOnly = me.grid.readOnly || record.readOnly;\n                }\n\n                if (me.onBeforeWidgetSetValue?.(widget, renderData) !== false) {\n                    const valueProperty = widgetCfg.valueProperty || ('value' in widget && 'value') || widget.defaultBindProperty;\n\n                    if (valueProperty) {\n                        const value = widget.name ? record[widget.name] : renderData.value;\n                        widget[valueProperty] = value;\n                    }\n                }\n\n                me.onAfterWidgetSetValue?.(widget, renderData);\n\n                return widget;\n            });\n        }\n\n        if (isExport) {\n            return null;\n        }\n\n        return this.externalRenderer?.(renderData);\n    }\n\n    //endregion\n\n    //region Other\n\n    /**\n     * Called before widget is created on rendering\n     * @param {ContainerItemConfig} widgetCfg Widget config\n     * @param {Object} renderData Render data\n     * @private\n     */\n    onBeforeWidgetCreate(widgetCfg, renderData) {}\n\n    /**\n     * Called after widget is created on rendering\n     * @param {Core.widget.Widget} widget Created widget\n     * @param {Object} renderData Render data\n     * @private\n     */\n    onAfterWidgetCreate(widget, renderData) {}\n\n    /**\n     * Called before the widget gets its value on rendering. Pass `false` to skip value setting while rendering\n     * @preventable\n     * @function onBeforeWidgetSetValue\n     * @param {Core.widget.Widget} widget Created widget\n     * @param {Object} renderData Render data\n     * @param {Grid.column.Column} renderData.column Rendered column\n     * @param {Core.data.Model} renderData.record Rendered record\n     */\n\n    /**\n     * Called after the widget gets its value on rendering.\n     * @function onAfterWidgetSetValue\n     * @param {Core.widget.Widget} widget Created widget\n     * @param {Object} renderData Render data\n     * @param {Grid.column.Column} renderData.column Rendered column\n     * @param {Core.data.Model} renderData.record Rendered record\n     */\n\n    // Overrides base implementation to cleanup widgets, for example when a cell is reused as part of group header\n    clearCell(cellElement) {\n        if (cellElement.widgets) {\n            cellElement.widgets.forEach(widget => {\n                // Destroy widget and remove reference to it\n                delete this.widgetMap[widget.id];\n                widget.destroy();\n            });\n            cellElement.widgets = null;\n        }\n\n        // Even if there is no widgets need to make sure there is no content left, for example after a cell has been reused as part of group header\n        super.clearCell(cellElement);\n    }\n\n    // Null implementation because there is no way of ascertaining whether the widgets get their width from\n    // the column, or the column shrinkwraps the Widget.\n    // Remember that the widget could have a width from a CSS rule which we cannot read.\n    // It might have width: 100%, or a flex which would mean it is sized by us, but we cannot read that -\n    // getComputedStyle would return the numeric width.\n    resizeToFitContent() {}\n\n    //endregion\n}\n\nColumnStore.registerColumnType(WidgetColumn);\nWidgetColumn.exposeProperties();\n","import StringHelper from '../../Core/helper/StringHelper.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport WidgetColumn from './WidgetColumn.js';\nimport Checkbox from '../../Core/widget/Checkbox.js';\n\n/**\n * @module Grid/column/CheckColumn\n */\n\n/**\n * A column that displays a checkbox in the cell. The value of the backing field is toggled by the checkbox.\n *\n * Toggling of the checkboxes is disabled if a record is readOnly or if the CellEdit feature is not enabled.\n *\n * This column renders a {@link Core.widget.Checkbox checkbox} into each cell, and it is not intended to be changed.\n * If you want to hide certain checkboxes, you can use the {@link #config-renderer} method to access the checkbox widget\n * as it is being rendered.\n *\n * <div class=\"note\">\n * It is <strong>not valid</strong> to use this column without a {@link #config-field} setting because the\n * checked/unchecked state needs to be backed up in a record because rows are recycled and the state will be lost when a\n * row is reused.\n * </div>\n *\n * @extends Grid/column/WidgetColumn\n *\n * @example\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         {\n *              type: 'check',\n *              field: 'allow',\n *              // In the column renderer, we get access to the record and CheckBox widget\n *              renderer({ record, widgets }) {\n *                  // Hide checkboxes in certain rows\n *                  widgets[0].hidden = record.readOnly;\n *              }\n *         }\n *     ]\n * });\n *\n * @classType check\n * @inlineexample Grid/column/CheckColumn.js\n * @column\n */\nexport default class CheckColumn extends WidgetColumn {\n    //region Config\n\n    static $name = 'CheckColumn';\n\n    static type = 'check';\n\n    static fields = [\n        'checkCls',\n        'showCheckAll',\n        'onAfterWidgetSetValue',\n        'onBeforeWidgetSetValue',\n        'callOnFunctions',\n        'onBeforeToggle',\n        'onToggle',\n        'onToggleAll'\n    ];\n\n    static defaults = {\n        align : 'center',\n\n        /**\n         * CSS class name to add to checkbox\n         * @config {String}\n         * @category Rendering\n         */\n        checkCls : null,\n\n        /**\n         * True to show a checkbox in the column header to be able to select/deselect all rows\n         * @config {Boolean}\n         */\n        showCheckAll : false,\n\n        sortable : true,\n\n        filterable : true,\n\n        widgets : [{\n            type          : 'checkbox',\n            valueProperty : 'checked'\n        }]\n    };\n\n    construct(config, store) {\n        super.construct(...arguments);\n\n        const me = this;\n\n        Object.assign(me, {\n            externalHeaderRenderer         : me.headerRenderer,\n            externalOnBeforeWidgetSetValue : me.onBeforeWidgetSetValue,\n            externalOnAfterWidgetSetValue  : me.onAfterWidgetSetValue,\n\n            onBeforeWidgetSetValue : me.internalOnBeforeWidgetSetValue,\n            onAfterWidgetSetValue  : me.internalOnAfterWidgetSetValue,\n            headerRenderer         : me.internalHeaderRenderer\n        });\n\n        if (!me.meta.isSelectionColumn) {\n            const modelClass = me.grid?.store.modelClass;\n\n            if (!me.field) {\n                console.warn('CheckColumn MUST be configured with a field, otherwise the checked state will not be persistent. Widgets are recycled and reused');\n            }\n            else if (modelClass && !modelClass.fieldMap[me.field] && !me.constructor.suppressNoModelFieldWarning) {\n                console.warn(me.$$name + ' is configured with a field, but this is not part of your Model `fields` collection.');\n                modelClass.addField({ name : me.field, type : 'boolean' });\n            }\n        }\n    }\n\n    doDestroy() {\n        this.headerCheckbox?.destroy();\n        super.doDestroy();\n    }\n\n    internalHeaderRenderer({ headerElement, column }) {\n        let returnValue;\n\n        headerElement.classList.add('b-check-header');\n\n        if (column.showCheckAll) {\n            headerElement.classList.add('b-check-header-with-checkbox');\n\n            if (column.headerCheckbox) {\n                headerElement.appendChild(column.headerCheckbox.element);\n            }\n            else {\n                column.headerCheckbox = new Checkbox({\n                    appendTo          : headerElement,\n                    owner             : this.grid,\n                    ariaLabel         : 'L{Checkbox.toggleSelection}',\n                    internalListeners : {\n                        change  : 'onCheckAllChange',\n                        thisObj : column\n                    }\n                });\n            }\n        }\n        else {\n            returnValue = column.headerText;\n        }\n\n        returnValue = column.externalHeaderRenderer ? column.externalHeaderRenderer.call(this, ...arguments) : returnValue;\n\n        return column.showCheckAll ? undefined : returnValue;\n    }\n\n    updateCheckAllState(value) {\n        if (this.headerCheckbox) {\n            this.suspendEvents();\n            this.headerCheckbox.checked = value;\n            this.resumeEvents();\n        }\n    }\n\n    onCheckAllChange({ checked }) {\n        const me = this;\n\n        // If this column is bound to a field, update all records\n        if (me.field) {\n            const { store } = me.grid;\n\n            store.beginBatch();\n            store.forEach(record => me.updateRecord(record, me.field, checked));\n            store.endBatch();\n        }\n\n        /**\n         * Fired when the header checkbox is clicked to toggle its checked status.\n         * @event toggleAll\n         * @param {Grid.column.CheckColumn} source This Column\n         * @param {Boolean} checked The checked status of the header checkbox.\n         */\n        me.trigger('toggleAll', { checked });\n    }\n\n    //endregion\n\n    internalRenderer({ value, isExport, record, cellElement }) {\n        if (isExport) {\n            return value == null ? '' : value;\n        }\n\n        const result = super.internalRenderer(...arguments);\n\n        if (record.readOnly && !this.meta.isSelectionColumn) {\n            cellElement.widgets[0].readOnly = true;\n        }\n\n        return result;\n    }\n\n    //region Widget rendering\n\n    onBeforeWidgetCreate(widgetCfg, event) {\n        widgetCfg.cls = this.checkCls;\n    }\n\n    onAfterWidgetCreate(widget, event) {\n        event.cellElement.widget = widget;\n\n        widget.ion({\n            beforeChange : 'onBeforeCheckboxChange',\n            change       : 'onCheckboxChange',\n            thisObj      : this\n        });\n    }\n\n    internalOnBeforeWidgetSetValue(widget) {\n        widget.record     = widget.cellInfo.record;\n        this.isInitialSet = true;\n        this.externalOnBeforeWidgetSetValue?.(...arguments);\n    }\n\n    internalOnAfterWidgetSetValue(widget) {\n        this.isInitialSet = false;\n        this.externalOnAfterWidgetSetValue?.(...arguments);\n    }\n\n    //endregion\n\n    //region Events\n\n    onBeforeCheckboxChange({ source, checked, userAction }) {\n        const\n            me         = this,\n            { grid }   = me,\n            { record } = source.cellInfo;\n\n        // If we are bound to a data field, ensure we respect cellEdit setting\n        if ((userAction && me.field && (!grid.features.cellEdit || grid.features.cellEdit.disabled)) || (me.meta.isSelectionColumn && !grid.isSelectable(record) && checked)) {\n            return false;\n        }\n\n        if (!me.isInitialSet) {\n            /**\n             * Fired when a cell is clicked to toggle its checked status. Returning `false` will prevent status change.\n             * @event beforeToggle\n             * @param {Grid.column.Column} source This Column\n             * @param {Core.data.Model} record The record for the row containing the cell.\n             * @param {Boolean} checked The new checked status of the cell.\n             */\n            return me.trigger('beforeToggle', { record, checked });\n        }\n    }\n\n    onCheckboxChange({ source, checked }) {\n        if (!this.isInitialSet) {\n            const\n                me         = this,\n                { record } = source.cellInfo,\n                { field }  = me;\n\n            if (field) {\n                me.updateRecord(record, field, checked);\n\n                // Keep header checkbox in sync with reality.\n                if (checked) {\n                    // We check whether *all* records in the store are checked including filtered out ones.\n                    me.updateCheckAllState(me.grid.store.every(r => r[field], null, true));\n                }\n                else {\n                    me.updateCheckAllState(false);\n                }\n            }\n\n            /**\n             * Fired when a cell is clicked to toggle its checked status.\n             * @event toggle\n             * @param {Grid.column.Column} source This Column\n             * @param {Core.data.Model} record The record for the row containing the cell.\n             * @param {Boolean} checked The new checked status of the cell.\n             */\n            me.trigger('toggle', { record, checked });\n        }\n    }\n\n    updateRecord(record, field, checked) {\n        const setterName = `set${StringHelper.capitalize(field)}`;\n        if (record[setterName]) {\n            record[setterName](checked);\n        }\n        else {\n            record.set(field, checked);\n        }\n    }\n\n    //endregion\n\n    onCellKeyDown({ event, cellElement }) {\n\n        // SPACE key toggles the checkbox\n        if (event.key === ' ') {\n            const checkbox = cellElement.widget;\n\n            checkbox?.toggle();\n\n            // Prevent native browser scrolling\n            event.preventDefault();\n\n            // KeyMap and other features (like context menu) must not process this.\n            event.handled = true;\n        }\n    }\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs (fields) for the column, with special handling for the hooks\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n\n        delete result.onBeforeWidgetSetValue;\n        delete result.onAfterWidgetSetValue;\n\n        if (this.externalOnBeforeWidgetSetValue) {\n            result.onBeforeWidgetSetValue = this.externalOnBeforeWidgetSetValue;\n        }\n\n        if (this.externalOnAfterWidgetSetValue) {\n            result.onAfterWidgetSetValue = this.externalOnAfterWidgetSetValue;\n        }\n\n        return result;\n    }\n}\n\nColumnStore.registerColumnType(CheckColumn, true);\n","import Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n\n/**\n * @module Grid/column/RowNumberColumn\n */\n\n/**\n * A column that displays the row number in each cell.\n *\n * There is no `editor`, since value is read-only.\n *\n * ```javascript\n * const grid = new Grid({\n *   appendTo : targetElement,\n *   width    : 300,\n *   columns  : [\n *     { type : 'rownumber' }\n *   ]\n * });\n *\n * @extends Grid/column/Column\n *\n * @classType rownumber\n * @inlineexample Grid/column/RowNumberColumn.js\n * @column\n */\nexport default class RowNumberColumn extends Column {\n\n    static $name = 'RowNumberColumn';\n\n    static type = 'rownumber';\n\n    static get defaults() {\n        return {\n            /**\n             * @config {Boolean} groupable\n             * @hide\n             */\n            groupable : false,\n\n            /**\n             * @config {Boolean} sortable\n             * @hide\n             */\n            sortable : false,\n\n            /**\n             * @config {Boolean} filterable\n             * @hide\n             */\n            filterable : false,\n\n            /**\n             * @config {Boolean} searchable\n             * @hide\n             */\n            searchable : false,\n\n            /**\n             * @config {Boolean} resizable\n             * @hide\n             */\n            resizable : false,\n\n            /**\n             * @config {Boolean} draggable\n             * @hide\n             */\n            draggable : false,\n\n            minWidth : 50,\n            width    : 50,\n            align    : 'center',\n            text     : '#',\n            editor   : false\n        };\n    }\n\n    construct(config) {\n        super.construct(...arguments);\n\n        const\n            me       = this,\n            { grid } = me;\n\n        me.internalCellCls        = 'b-row-number-cell';\n        me.externalHeaderRenderer = me.headerRenderer;\n        me.headerRenderer         = me.internalHeaderRenderer;\n\n        if (grid) {\n            // Update our width when the store mutates (tests test Columns in isolation with no grid, so we must handle that!)\n            grid.ion({\n                bindStore : 'bindStore',\n                thisObj   : me\n            });\n\n            me.bindStore({ store : grid.store, initial : true });\n\n            if (grid.store.count && !grid.rendered) {\n                grid.ion({\n                    paint   : 'resizeToFitContent',\n                    thisObj : me,\n                    once    : true\n                });\n            }\n        }\n    }\n\n    get groupHeaderReserved() {\n        return true;\n    }\n\n    bindStore({ store, initial }) {\n        const me = this;\n\n        me.detachListeners('grid');\n\n        store.ion({\n            name                                  : 'grid',\n            [`change${me.grid.asyncEventSuffix}`] : 'onStoreChange',\n            thisObj                               : me\n        });\n\n        if (!initial) {\n            me.resizeToFitContent();\n        }\n    }\n\n    onStoreChange({ action }) {\n        if (action === 'dataset' || action === 'add' || action === 'remove' || action === 'removeall') {\n            this.resizeToFitContent();\n        }\n    }\n\n    /**\n     * Renderer that displays the row number in the cell.\n     * @private\n     */\n    renderer({ record, grid }) {\n        return record.isSpecialRow ? '' : grid.store.indexOf(record, true) + 1;\n    }\n\n    /**\n     * Resizes the column to match the widest string in it. Called when you double click the edge between column\n     * headers\n     */\n    resizeToFitContent() {\n        const\n            { grid }  = this,\n            { store } = grid,\n            { count } = store;\n\n        if (count && !this.hidden) {\n            const cellElement = grid.element.querySelector(`.b-grid-cell[data-column-id=\"${this.id}\"]`);\n\n            // cellElement might not exist, e.g. when trial is expired\n            if (cellElement) {\n                const\n                    cellPadding = parseInt(DomHelper.getStyleValue(cellElement, 'padding-left')),\n                    maxWidth    = DomHelper.measureText(count, cellElement);\n\n                this.width = Math.max(this.minWidth, maxWidth + 2 * cellPadding);\n            }\n        }\n    }\n\n    set flex(f) {\n        //<debug>\n        if (f != null) {\n            throw new Error('RowNumberer column may not be flexed');\n        }\n        //</debug>\n    }\n\n    internalHeaderRenderer({ headerElement, column }) {\n        headerElement.classList.add('b-rownumber-header');\n        return column.externalHeaderRenderer?.call(this, ...arguments) || column.headerText;\n    }\n}\n\nColumnStore.registerColumnType(RowNumberColumn, true);\n","import StringHelper from '../../Core/helper/StringHelper.js';\n\n/**\n * @module Grid/feature/GridFeatureManager\n */\n\nconst\n    consumerToFeatureMap        = new Map(),\n    consumerToDefaultFeatureMap = new Map(),\n    DEFAULT_FOR_TYPE            = 'Grid',\n    remapToBase                 = {\n        Grid         : 'GridBase',\n        Scheduler    : 'SchedulerBase',\n        SchedulerPro : 'SchedulerProBase',\n        Gantt        : 'GanttBase'\n    },\n    classNameFix = /\\$\\d+$/;\n\n/**\n * Static class intended to register and query grid features (also applies to Scheduler, Scheduler Pro and Gantt).\n *\n * A feature for Grid, Scheduler, Scheduler Pro or Gantt must extend {@link Core/mixin/InstancePlugin}.\n *\n * <div class=\"note\"> Note that features for Calendar and TaskBoard differ, they should not be registered with\n * GridFeatureManager, and they use different base classes.\n * </div>\n *\n * ## Registering a custom feature\n *\n * First define a new feature, extending InstancePlugin:\n *\n * ```javascript\n * export default class MyFeature extends InstancePlugin {\n *    // Class name, needed since the actual class name might be mangled by the minifier\n *    static $name = 'MyFeature';\n *\n *    construct(client, config) {\n *        // Set things up here\n *    }\n * }\n * ```\n *\n * Then register it with GridFeatureManager:\n *\n * ```javascript\n * GridFeatureManager.registerFeature(MyFeature);\n * ```\n *\n * After that it is ready to use:\n *\n * ```javascript\n * const grid = new Grid({\n *    features : {\n *      myFeature : true\n *    }\n * });\n *\n * @class\n */\nexport default class GridFeatureManager {\n    /**\n     * Register a feature class with the Grid. Enables it to be created and configured using config Grid#features.\n     * @param {Function} featureClass The feature class constructor to register\n     * @param {Boolean} [onByDefault] Specify true to have the feature enabled per default\n     * @param {String|String[]} [forType] Specify a type to let the class applying the feature to determine if it should\n     * use it\n     */\n    static registerFeature(featureClass, onByDefault = false, forType = null, as = null) {\n        // Our built-in features should all define $name to survive minification/obfuscation, but user defined features might not\n        as = StringHelper.uncapitalize(as || (Object.prototype.hasOwnProperty.call(featureClass, '$name') && featureClass.$$name) || featureClass.name);\n\n        // Remove webpack's disambiguation suffix.\n        // For example ExcelExporter in Scheduler will be called ExcelExporter$1\n        // It must be found as ExcelExporter in the Scheduler's feature Map, so correct the name.\n        as = as.replace(classNameFix, '');\n\n        if (!Array.isArray(forType)) {\n            forType = [forType || DEFAULT_FOR_TYPE];\n        }\n\n        forType.forEach(forType => {\n            const\n                type                       = remapToBase[forType] || forType,\n                consumerFeaturesMap        = consumerToFeatureMap.get(type) || new Map(),\n                consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type) || new Map();\n\n            consumerFeaturesMap.set(as, featureClass);\n            consumerDefaultFeaturesMap.set(featureClass, onByDefault);\n\n            consumerToFeatureMap.set(type, consumerFeaturesMap);\n            consumerToDefaultFeatureMap.set(type, consumerDefaultFeaturesMap);\n        });\n    }\n\n    /**\n     * Get all the features registered for the given type name in an object where keys are feature names and values are\n     * feature constructors.\n     *\n     * @param {String} [forType]\n     * @returns {Object}\n     */\n    static getTypeNameFeatures(forType = DEFAULT_FOR_TYPE) {\n        const\n            type                = remapToBase[forType] || forType,\n            consumerFeaturesMap = consumerToFeatureMap.get(type),\n            features            = {};\n\n        if (consumerFeaturesMap) {\n            consumerFeaturesMap.forEach((featureClass, as) => features[as] = featureClass);\n        }\n\n        return features;\n    }\n\n    /**\n     * Get all the default features registered for the given type name in an object where keys are feature names and\n     * values are feature constructors.\n     *\n     * @param {String} [forType]\n     * @returns {Object}\n     */\n    static getTypeNameDefaultFeatures(forType = DEFAULT_FOR_TYPE) {\n        const\n            type                       = remapToBase[forType] || forType,\n            consumerFeaturesMap        = consumerToFeatureMap.get(type),\n            consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type);\n\n        const features = {};\n\n        if (consumerFeaturesMap && consumerDefaultFeaturesMap) {\n            consumerFeaturesMap.forEach((featureClass, as) => {\n                if (consumerDefaultFeaturesMap.get(featureClass)) {\n                    features[as] = featureClass;\n                }\n            });\n        }\n\n        return features;\n    }\n\n    /**\n     * Gets all the features registered for the given instance type name chain. First builds the type name chain then\n     * queries for features for each type name and combines them into one object, see\n     * {@link #function-getTypeNameFeatures-static}() for returned object description.\n     *\n     * If feature is registered for both parent and child type name then feature for child overrides feature for parent.\n     *\n     * @param {Object} instance\n     * @returns {Object}\n     */\n    static getInstanceFeatures(instance) {\n        return instance.$meta.names.reduce(\n            (features, typeName) => Object.assign(features, this.getTypeNameFeatures(typeName)),\n            {}\n        );\n    }\n\n    /**\n     * Gets all the *default* features registered for the given instance type name chain. First builds the type name\n     * chain then queries for features for each type name and combines them into one object, see\n     * {@link #function-getTypeNameFeatures-static}() for returned object description.\n     *\n     * If feature is registered for both parent and child type name then feature for child overrides feature for parent.\n     *\n     * @param {Object} instance\n     * @returns {Object}\n     */\n    static getInstanceDefaultFeatures(instance) {\n        return instance.$meta.names.reduce(\n            (features, typeName) => Object.entries(\n                this.getTypeNameFeatures(typeName)\n            ).reduce(\n                (features, [as, featureClass]) => {\n                    if (this.isDefaultFeatureForTypeName(featureClass, typeName)) {\n                        features[as] = featureClass;\n                    }\n                    else {\n                        delete features[as];\n                    }\n                    return features;\n                },\n                features\n            ),\n            {}\n        );\n    }\n\n    /**\n     * Checks if the given feature class is default for the type name\n     *\n     * @param {Core.mixin.InstancePlugin} featureClass Feature to check\n     * @param {String} [forType]\n     * @returns {Boolean}\n     */\n    static isDefaultFeatureForTypeName(featureClass, forType = DEFAULT_FOR_TYPE) {\n        const\n            type                       = remapToBase[forType] || forType,\n            consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type);\n        return consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.get(featureClass) || false;\n    }\n\n    /**\n     * Checks if the given feature class is default for the given instance type name chain. If the feature is not\n     * default for the parent type name but it is for the child type name, then the child setting overrides the parent\n     * one.\n     *\n     * @param {Core.mixin.InstancePlugin} featureClass Feature to check\n     * @param {String} [forType]\n     * @returns {Boolean}\n     */\n    static isDefaultFeatureForInstance(featureClass, instance) {\n        //const typeChain = ObjectHelper.getTypeNameChain(instance);\n        const typeChain = instance.$meta.names.slice().reverse();\n\n        let result = null;\n\n        for (let i = 0, len = typeChain.length; i < len && result === null; ++i) {\n\n            const consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(typeChain[i]);\n\n            if (consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.has(featureClass)) {\n                result = consumerDefaultFeaturesMap.get(featureClass);\n            }\n        }\n\n        return result || false;\n    }\n\n    /**\n     * Resets feature registration date, used in tests to reset state after test\n     *\n     * @internal\n     */\n    static reset() {\n        consumerToFeatureMap.clear();\n        consumerToDefaultFeatureMap.clear();\n    }\n}\n","//TODO: Maybe some more way to stop editing in touch mode (in case grid fills entire page...)\n\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Editor from '../../Core/widget/Editor.js';\nimport GlobalEvents from '../../Core/GlobalEvents.js';\nimport MessageDialog from '../../Core/widget/MessageDialog.js';\nimport Location from '../util/Location.js';\nimport '../../Core/widget/NumberField.js';\nimport '../../Core/widget/Combo.js';\nimport '../../Core/widget/DateField.js';\nimport '../../Core/widget/TimeField.js';\n\nconst editingActions = {\n    finishAndEditNextRow  : 1,\n    finishAndEditPrevRow  : 1,\n    finishEditing         : 1,\n    cancelEditing         : 1,\n    finishAndEditNextCell : 1,\n    finishAndEditPrevCell : 1\n};\n\n/**\n * @module Grid/feature/CellEdit\n */\n\n/**\n * Adding this feature to the grid and other Bryntum products which are based on the Grid (i.e. Scheduler, SchedulerPro, and Gantt)\n * enables cell editing. Any subclass of {@link Core.widget.Field Field} can be used\n * as editor for the {@link Grid.column.Column Column}. The most popular are:\n *\n * - {@link Core.widget.TextField TextField}\n * - {@link Core.widget.NumberField NumberField}\n * - {@link Core.widget.DateField DateField}\n * - {@link Core.widget.TimeField TimeField}\n * - {@link Core.widget.Combo Combo}\n *\n * Usage instructions:\n * ## Start editing\n * * Double click on a cell\n * * Press [ENTER] or [F2] with a cell selected (see {@link #keyboard-shortcuts Keyboard shortcuts} below)\n * * It is also possible to change double click to single click to start editing, using the {@link #config-triggerEvent} config\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        cellEdit : {\n *            triggerEvent : 'cellclick'\n *        }\n *    }\n * });\n * ```\n *\n * ## Instant update\n * If {@link Grid.column.Column#config-instantUpdate} on the column is set to true, record will be\n * updated instantly as value in the editor is changed. In combination with {@link Core.data.Store#config-autoCommit} it\n * could result in excessive requests to the backend.\n * By default instantUpdate is false, but it is enabled for some special columns, such as Duration column in Scheduler\n * Pro and all date columns in Gantt.\n *\n * ## Keyboard shortcuts\n * ### While not editing\n * | Keys        | Action       | Action description                    |\n * |-------------|------------- |---------------------------------------|\n * | Enter       | startEditing | Starts editing currently focused cell |\n * | F2          | startEditing | Starts editing currently focused cell |\n *\n * ### While editing\n * | Keys        | Action                 | Action description                                                                        |\n * |-------------|------------------------|-------------------------------------------------------------------------------------------|\n * | Enter       | finishAndEditNextRow  | Finish editing and start editing the same cell in next row                                 |\n * | Shift+Enter | finishAndEditPrevRow  | Finish editing and start editing the same cell in previous row                             |\n * | F2          | finishEditing         | Finish editing                                                                             |\n * | Ctrl+Enter  | finishAllSelected     | If {@link #config-multiEdit} is active, this applies new value on all selected rows/cells  |\n * | Ctrl+Enter  | finishEditing         | Finish editing                                                                             |\n * | Escape      | cancelEditing         | By default, first reverts the value back to its original value, next press cancels editing |\n * | Tab         | finishAndEditNextCell | Finish editing and start editing the next cell                                             |\n * | Shift+Tab   | finishAndEditPrevCell | Finish editing and start editing the previous cell                                         |\n *\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md).\n *\n * ## Editor configuration\n * Columns specify editor in their configuration. Editor can also by set by using a column type. Columns\n * may also contain these three configurations which affect how their cells are edited:\n * * {@link Grid.column.Column#config-invalidAction}\n * * {@link Grid.column.Column#config-revertOnEscape}\n * * {@link Grid.column.Column#config-finalizeCellEdit}\n *\n * ## Preventing editing of certain cells\n * You can prevent editing on a column by setting `editor` to false:\n *\n * ```javascript\n * new Grid({\n *    columns : [\n *       {\n *          type   : 'number',\n *          text   : 'Age',\n *          field  : 'age',\n *          editor : false\n *       }\n *    ]\n * });\n * ```\n * To prevent editing in a specific cell, listen to the {@link #event-beforeCellEditStart} and return false:\n *\n * ```javascript\n * grid.on('beforeCellEditStart', ({ editorContext }) => {\n *     return editorContext.column.field !== 'id';\n * });\n * ```\n\n * ## Choosing field on the fly\n * To use an alternative input field to edit a cell, listen to the {@link #event-beforeCellEditStart} and\n * set the `editor` property of the context to the input field you want to use:\n *\n * ```javascript\n * grid.on('beforeCellEditStart', ({ editorContext }) => {\n *     return editorContext.editor = myDateField;\n * });\n * ```\n *\n * ## Loading remote data into a combo box cell editor\n * If you need to prepare or modify the data shown by the cell editor, e.g. load remote data into the store used by a combo,\n * listen to the {@link #event-startCellEdit} event:\n * ```javascript\n * const employeeStore = new AjaxStore({ readUrl : '/cities' }); // A server endpoint returning data like:\n *                                                               // [{ id : 123, name : 'Bob Mc Bob' }, { id : 345, name : 'Lind Mc Foo' }]\n *\n * new Grid({\n *     // Example data including a city field which is an id used to look up entries in the cityStore above\n *     data : [\n *         { id : 1, name : 'Task 1', employeeId : 123 },\n *         { id : 2, name : 'Task 2', employeeId : 345 }\n *     ],\n *     columns : [\n *       {\n *          text   : 'Task',\n *          field  : 'name'\n *       },\n *       {\n *          text   : 'Assigned to',\n *          field  : 'employeeId',\n *          editor : {\n *               type : 'combo',\n *               store : employeeStore,\n *               // specify valueField'/'displayField' to match the data format in the employeeStore store\n *               valueField : 'id',\n *               displayField : 'name'\n *           },\n *           renderer : ({ value }) {\n *                // Use a renderer to show the employee name, which we find by querying employeeStore by the id of the grid record\n *                return employeeStore.getById(value)?.name;\n *           }\n *       }\n *    ],\n *    listeners : {\n *        // When editing, you might want to fetch data for the combo store from a remote resource\n *        startCellEdit({ editorContext }) {\n *            const { record, editor, column } = editorContext;\n *            if (column.field === 'employeeId') {\n *                // Load possible employees to assign to this particular task\n *                editor.inputField.store.load({ task : record.id });\n *            }\n *       }\n *    }\n * });\n * ```\n *\n * ## Editing on touch devices\n *\n * On touch devices, a single tap navigates and tapping an already selected cell after a short delay starts the editing.\n *\n * This feature is **enabled** by default.\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @demo Grid/celledit\n * @classtype cellEdit\n * @inlineexample Grid/feature/CellEdit.js\n * @feature\n */\nexport default class CellEdit extends Delayable(InstancePlugin) {\n    //region Config\n\n    static $name = 'CellEdit';\n\n    // Default configuration\n    static get defaultConfig() {\n        return {\n            /**\n             * Set to true to select the field text when editing starts\n             * @config {Boolean}\n             * @default\n             */\n            autoSelect : true,\n\n            /**\n             * What action should be taken when focus moves leaves the cell editor, for example when clicking outside.\n             * May be `'complete'` or `'cancel`'.\n             * @config {'complete'|'cancel'}\n             * @default\n             */\n            blurAction : 'complete',\n\n            /**\n             * Set to `false` to stop editing when clicking another cell after a cell edit.\n             * @config {Boolean}\n             * @default\n             */\n            continueEditingOnCellClick : true,\n\n            /**\n             * Set to true to have TAB key on the last cell (and ENTER anywhere in the last row) in the data set create\n             * a new record and begin editing it at its first editable cell.\n             *\n             * If a customized {@link #config-keyMap} is used, this setting will affect the customized keys instead of\n             * ENTER and TAB.\n             *\n             * If this is configured as an object, it is used as the default data value set for each new record.\n             * @config {Boolean|Object}\n             */\n            addNewAtEnd : null,\n\n            /**\n             * Set to `true` to start editing when user starts typing text on a focused cell (as in Excel)\n             * @config {Boolean}\n             * @default false\n             */\n            autoEdit : null,\n\n            /**\n             * Set to `false` to not start editing next record when user presses enter inside a cell editor (or previous\n             * record if SHIFT key is pressed). This is set to `false` when {@link #config-autoEdit} is `true`. Please\n             * note that these key combinations could be different if a customized {@link #config-keyMap} is used.\n             * @config {Boolean}\n             * @default\n             */\n            editNextOnEnterPress : true,\n\n            /**\n             * Class to use as an editor. Default value: {@link Core.widget.Editor}\n             * @config {Core.widget.Widget}\n             * @typings {typeof Widget}\n             * @internal\n             */\n            editorClass : Editor,\n\n            /**\n             * The name of the grid event that will trigger cell editing. Defaults to\n             * {@link Grid.view.mixin.GridElementEvents#event-cellDblClick celldblclick} but can be changed to any other event,\n             * such as {@link Grid.view.mixin.GridElementEvents#event-cellClick cellclick}.\n             *\n             * ```javascript\n             * features : {\n             *     cellEdit : {\n             *         triggerEvent : 'cellclick'\n             *     }\n             * }\n             * ```\n             *\n             * @config {String}\n             * @default\n             */\n            triggerEvent : 'celldblclick',\n\n            // To edit a cell using a touch gesture, at least 300ms should have passed since last cell tap\n            touchEditDelay : 300,\n\n            focusCellAnimationDuration : false,\n\n            /**\n             * If set to `true` (which is default) this will make it possible to edit current column in multiple rows\n             * simultaneously.\n             *\n             * This is achieved by:\n             * 1. Select multiple rows or row's cells\n             * 2. Start editing simultaneously as selecting the last row or cell\n             * 3. When finished editing, press Ctrl+Enter to apply the new value to all selected rows.\n             *\n             * If a customized {@link #config-keyMap} is used, the Ctrl+Enter combination could map to something else.\n             *\n             * @config {Boolean}\n             * @default\n             */\n            multiEdit : true,\n\n            /**\n             * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n             * @config {Object<String,String>}\n             */\n            keyMap : {\n                Enter         : ['startEditing', 'finishAndEditNextRow'],\n                'Ctrl+Enter'  : ['finishAllSelected', 'finishEditing'],\n                'Shift+Enter' : 'finishAndEditPrevRow',\n                'Alt+Enter'   : 'finishEditing',\n                F2            : ['startEditing', 'finishEditing'],\n                Escape        : 'cancelEditing',\n                Tab           : 'finishAndEditNextCell',\n                'Shift+Tab'   : 'finishAndEditPrevCell'\n            }\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            assign : ['startEditing', 'finishEditing', 'cancelEditing'],\n            before : ['onElementKeyDown', 'onElementPointerUp'],\n            chain  : ['onElementClick', 'bindStore']\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    construct(grid, config) {\n        super.construct(grid, config);\n\n        const\n            me            = this,\n            gridListeners = {\n                renderRows : 'onGridRefreshed',\n                cellClick  : 'onCellClick',\n                thisObj    : me\n            };\n\n        me.grid = grid;\n\n        if (me.triggerEvent !== 'cellclick') {\n            gridListeners[me.triggerEvent] = 'onTriggerEditEvent';\n        }\n\n        if (me.autoEdit && !('editNextOnEnterPress' in config)) {\n            me.editNextOnEnterPress = false;\n        }\n\n        grid.ion(gridListeners);\n\n        grid.rowManager.ion({\n            changeTotalHeight : 'onGridRefreshed',\n            thisObj           : me\n        });\n        me.bindStore(grid.store);\n    }\n\n    bindStore(store) {\n        this.detachListeners('store');\n\n        store.ion({\n            name       : 'store',\n            update     : 'onStoreUpdate',\n            beforeSort : 'onStoreBeforeSort',\n            thisObj    : this\n        });\n    }\n\n    /**\n     * Displays an OK / Cancel confirmation dialog box owned by the current Editor. This is intended to be\n     * used by {@link Grid.column.Column#config-finalizeCellEdit} implementations. The returned promise resolves passing\n     * `true` if the \"OK\" button is pressed, and `false` if the \"Cancel\" button is pressed. Typing `ESC` rejects.\n     * @param {Object} options An options object for what to show.\n     * @param {String} [options.title] The title to show in the dialog header.\n     * @param {String} [options.message] The message to show in the dialog body.\n     * @param {String|Object} [options.cancelButton] A text or a config object to apply to the Cancel button.\n     * @param {String|Object} [options.okButton] A text or config object to apply to the OK button.\n     */\n    async confirm(options) {\n        let result = true;\n\n        if (this.editorContext) {\n            // The input field must not lose containment of focus during this confirmation\n            // so temporarily make the MessageDialog a descendant widget.\n            MessageDialog.owner = this.editorContext.editor.inputField;\n            options.rootElement = this.grid.rootElement;\n            result = await MessageDialog.confirm(options);\n            MessageDialog.owner = null;\n        }\n\n        return result === MessageDialog.yesButton;\n    }\n\n    doDestroy() {\n        // To kill timeouts\n        this.grid.columns.allRecords.forEach(column => {\n            column._cellEditor?.destroy();\n        });\n\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        if (disable && !this.isConfiguring) {\n            this.cancelEditing(true);\n        }\n\n        super.doDisable(disable);\n    }\n\n    set disabled(disabled) {\n        super.disabled = disabled;\n    }\n\n    get disabled() {\n        const { grid } = this;\n\n        return Boolean(super.disabled || grid.disabled || grid.readOnly);\n    }\n\n    //endregion\n\n    //region Editing\n\n    /**\n     * Is any cell currently being edited?\n     * @readonly\n     * @property {Boolean}\n     */\n    get isEditing() {\n        return Boolean(this.editorContext);\n    }\n\n    /**\n     * Returns the record currently being edited, or `null`\n     * @readonly\n     * @property {Core.data.Model}\n     */\n    get activeRecord() {\n        return this.editorContext?.record || null;\n    }\n\n    /**\n     * Internal function to create or get existing editor for specified cell.\n     * @private\n     * @param cellContext Cell to get or create editor for\n     * @returns {Core.widget.Editor} An Editor container which displays the input field.\n     * @category Internal\n     */\n    getEditorForCell({ id, cell, column, columnId, editor }) {\n        const\n            me = this,\n            {\n                grid,\n                editorClass\n            }  = me;\n\n        // Reuse the Editor by caching it on the column.\n        let cellEditor = column.cellEditor,\n            leftOffset = 0; // Only applicable for tree cells to show editor right of the icons etc\n\n        // Help Editor match size and position\n        if (column.editTargetSelector) {\n            const editorTarget = cell.querySelector(column.editTargetSelector);\n\n            leftOffset = editorTarget.offsetLeft;\n        }\n\n        editor.autoSelect = me.autoSelect;\n\n        // Still a config\n        if (!cellEditor?.isEditor) {\n            cellEditor = column.data.cellEditor = editorClass.create(editorClass.mergeConfigs({\n                type          : editorClass.type,\n                constrainTo   : null,\n                cls           : 'b-cell-editor',\n                inputField    : editor,\n                blurAction    : 'none',\n                invalidAction : column.invalidAction,\n                completeKey   : false,\n                cancelKey     : false,\n                owner         : grid,\n                align         : {\n                    align  : 't0-t0',\n                    offset : [leftOffset, 0]\n                },\n                internalListeners : me.getEditorListeners(),\n\n                // Listen for cell edit control keys from the Editor\n                onInternalKeyDown : me.onEditorKeydown.bind(me),\n\n                // React editor wrapper code uses this flag to enable mouse events pass through to editor\n                allowMouseEvents : editor.allowMouseEvents\n            }, cellEditor));\n        }\n\n        // If matchSize auto heights it, ensure it at least covers the cell.\n        cellEditor.minHeight = grid.rowHeight;\n\n        // If the input field needs changing, change it.\n        if (cellEditor.inputField !== editor) {\n            cellEditor.remove(cellEditor.items[0]);\n            cellEditor.add(editor);\n        }\n\n        // Ensure the X offset is set to clear TreeCell furniture\n        cellEditor.align.offset[0] = leftOffset;\n\n        // Keep the record synced with the value\n        if (column.instantUpdate && !editor.cellEditValueSetter) {\n            ObjectHelper.wrapProperty(editor, 'value', null, value => {\n                const\n                    { editorContext } = me,\n                    inputField = editorContext?.editor.inputField;\n                // Only tickle the record if the value has changed.\n                if (editorContext?.editor.isValid &&\n                    !ObjectHelper.isEqual(editorContext.record[editorContext.column.field], value) &&\n                    // If editor is a dateField, only allow picker input as not to trigger change on each keystroke.\n                    (!inputField?.isDateField || inputField._isPickerInput)) {\n                    editorContext.record[editorContext.column.field] = value;\n                }\n            });\n            editor.cellEditValueSetter = true;\n        }\n\n        Object.assign(cellEditor.element.dataset, {\n            rowId    : id,\n            columnId : columnId,\n            field    : column.field\n        });\n\n        // First ESC press reverts\n        cellEditor.inputField.revertOnEscape = column.revertOnEscape;\n\n        return me.editor = cellEditor;\n    }\n\n    // Turned into function to allow overriding in Gantt, and make more configurable in general\n    getEditorListeners() {\n        return {\n            focusOut       : 'onEditorFocusOut',\n            focusIn        : 'onEditorFocusIn',\n            start          : 'onEditorStart',\n            beforeComplete : 'onEditorBeforeComplete',\n            complete       : 'onEditorComplete',\n            beforeCancel   : 'onEditorBeforeCancel',\n            cancel         : 'onEditorCancel',\n            beforeHide     : 'onBeforeEditorHide',\n            finishEdit     : 'onEditorFinishEdit',\n            thisObj        : this\n        };\n    }\n\n    onEditorStart({ source : editor }) {\n        const\n            me            = this,\n            editorContext = me.editorContext = editor.cellEditorContext;\n\n        if (editorContext) {\n            const { grid } = me;\n\n            // Should move editing to new cell on click, unless click is configured to start editing - in which case it\n            // will move anyway\n            if (me.triggerEvent !== 'cellclick') {\n                me.detachListeners('cellClickWhileEditing');\n                grid.ion({\n                    name      : 'cellClickWhileEditing',\n                    cellclick : 'onCellClickWhileEditing',\n                    thisObj   : me\n                });\n            }\n\n            me.removeEditingListeners?.();\n\n            // Handle tapping outside of the grid element. Use GlobalEvents\n            // because it uses a capture:true listener before any other handlers\n            // might stop propagation.\n            // Cannot use delegate here. A tapped cell will match :not(#body-container)\n            me.removeEditingListeners = GlobalEvents.addListener({\n                globaltap : 'onTapOut',\n                thisObj   : me\n            });\n\n            /**\n             * Fires on the owning Grid when editing starts\n             * @event startCellEdit\n             * @on-owner\n             * @param {Grid.view.Grid} source Owner grid\n             * @param {Grid.util.Location} editorContext Editing context\n             * @param {Core.widget.Editor} editorContext.editor The Editor being used.\n             * Will contain an `inputField` property which is the field being used to perform the editing.\n             * @param {Grid.column.Column} editorContext.column Target column\n             * @param {Core.data.Model} editorContext.record Target record\n             * @param {HTMLElement} editorContext.cell Target cell\n             * @param {*} editorContext.value Cell value\n             */\n            grid.trigger('startCellEdit', { grid, editorContext });\n        }\n    }\n\n    onEditorBeforeComplete(context) {\n        const\n            { grid }      = this,\n            editor        = context.source,\n            editorContext = editor.cellEditorContext;\n\n        context.grid = grid;\n        context.editorContext = editorContext;\n\n        /**\n         * Fires on the owning Grid before the cell editing is finished, return false to signal that the value is invalid and editing should not be finalized.\n         * @on-owner\n         * @event beforeFinishCellEdit\n         * @param {Grid.view.Grid} grid Target grid\n         * @param {Grid.util.Location} editorContext Editing context\n         * @param {Core.widget.Editor} editorContext.editor The Editor being used.\n         * Will contain an `inputField` property which is the field being used to perform the editing.\n         * @param {Grid.column.Column} editorContext.column Target column\n         * @param {Core.data.Model} editorContext.record Target record\n         * @param {HTMLElement} editorContext.cell Target cell\n         * @param {*} editorContext.value Cell value\n         */\n        return grid.trigger('beforeFinishCellEdit', context);\n    }\n\n    onEditorComplete({ source : editor }) {\n        const\n            { grid }      = this,\n            editorContext = editor.cellEditorContext;\n\n        // Ensure the docs below are accurate!\n        editorContext.value = editor.inputField.value;\n\n        /**\n         * Fires on the owning Grid when cell editing is finished\n         * @event finishCellEdit\n         * @on-owner\n         * @param {Grid.view.Grid} grid Target grid\n         * @param {Grid.util.Location} editorContext Editing context\n         * @param {Core.widget.Editor} editorContext.editor The Editor being used.\n         * Will contain an `inputField` property which is the field being used to perform the editing.\n         * @param {Grid.column.Column} editorContext.column Target column\n         * @param {Core.data.Model} editorContext.record Target record\n         * @param {HTMLElement} editorContext.cell Target cell\n         * @param {*} editorContext.value Cell value\n         */\n        grid.trigger('finishCellEdit', { grid, editorContext });\n    }\n\n    onEditorBeforeCancel() {\n        const { editorContext } = this;\n\n        /**\n         * Fires on the owning Grid before the cell editing is canceled, return `false` to prevent cancellation.\n         * @event beforeCancelCellEdit\n         * @preventable\n         * @on-owner\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {Grid.util.Location} editorContext Editing context\n         */\n        return this.grid.trigger('beforeCancelCellEdit', { editorContext });\n    }\n\n    onEditorCancel({ event }) {\n        const { editorContext, muteEvents, grid } = this;\n\n        if (!muteEvents) {\n            /**\n             * Fires on the owning Grid when editing is cancelled\n             * @event cancelCellEdit\n             * @on-owner\n             * @param {Grid.view.Grid} source Owner grid\n             * @param {Grid.util.Location} editorContext Editing context\n             * @param {Event} event Included if the cancellation was triggered by a DOM event\n             */\n            grid.trigger('cancelCellEdit', { grid, editorContext, event });\n        }\n    }\n\n    onBeforeEditorHide({ source }) {\n        const\n            me = this,\n            {\n                row,\n                cell\n            }  = source.cellEditorContext;\n\n        // Clean up and restore cell to full visibility\n        // before we hide and attempt to revert focus to the cell.\n        cell?.classList.remove('b-editing');\n        row?.removeCls('b-editing');\n        me.detachListeners('cellClickWhileEditing');\n        me.removeEditingListeners();\n    }\n\n    onEditorFinishEdit({ source }) {\n        // Clean up context objects so we know we are not editing\n        source.cellEditorContext = this.editorContext = null;\n    }\n\n    /**\n     * Find the next succeeding or preceding cell which is editable (column.editor != false)\n     * @param {Object} cellInfo\n     * @param {Boolean} isForward\n     * @returns {Object}\n     * @private\n     * @category Internal\n     */\n    getAdjacentEditableCell(cellInfo, isForward) {\n        const\n            { grid }           = this,\n            { store, columns } = grid,\n            { visibleColumns } = columns;\n\n        let\n            rowId    = cellInfo.id,\n            column   = columns.getAdjacentVisibleLeafColumn(cellInfo.columnId, isForward);\n\n        while (rowId) {\n            if (column) {\n                if (column.editor && column.canEdit(store.getById(rowId))) {\n                    return { id : rowId, columnId : column.id };\n                }\n\n                column = columns.getAdjacentVisibleLeafColumn(column, isForward);\n            }\n            else {\n                const record = store.getAdjacent(cellInfo.id, isForward, false, true);\n\n                rowId = record?.id;\n\n                if (record) {\n                    column = isForward ? visibleColumns[0] : visibleColumns[visibleColumns.length - 1];\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Adds a new, empty record at the end of the TaskStore with the initial\n     * data specified by the {@link Grid.feature.CellEdit#config-addNewAtEnd} setting.\n     *\n     * @private\n     * @returns {Core.data.Model} Newly added record\n     */\n    doAddNewAtEnd() {\n        const\n            newRecordConfig = typeof this.addNewAtEnd === 'object' ? ObjectHelper.clone(this.addNewAtEnd) : {},\n            { grid }        = this,\n            record          = grid.store.add(newRecordConfig)[0];\n\n        // If the new record was not added due to it being off the end of the rendered block\n        // ensure we force it to be there before we attempt to edit it.\n        if (!grid.rowManager.getRowFor(record)) {\n            grid.rowManager.displayRecordAtBottom();\n        }\n\n        return record;\n    }\n\n    /**\n     * Creates an editing context object for the passed cell context (target cell must be in the DOM).\n     *\n     * If the referenced cell is editable, a {@link Grid.util.Location} will\n     * be returned containing the following extra properties:\n     *\n     *     - editor\n     *     - value\n     *\n     * If the referenced cell is _not_ editable, `false` will be returned.\n     * @param {Object} cellContext an object which encapsulates a cell.\n     * @param {String} cellContext.id The record id of the row to edit\n     * @param {String} cellContext.columnId The column id of the column to edit\n     * @returns {Grid.util.Location}\n     * @private\n     */\n    getEditingContext(cellContext) {\n        cellContext = this.grid.normalizeCellContext(cellContext);\n\n        const { column, record } = cellContext;\n\n        // Cell must be in the DOM to edit.\n        // Cannot edit hidden columns and columns without an editor.\n        // Cannot edit special rows (groups etc).\n        if (column?.isVisible && column.editor && record && !record.isSpecialRow && !record.readOnly && column.canEdit(record)) {\n            // If the field name is a complex mapping (instead of using a field name with a dataSource)\n            // set it correctly. Row#renderCell gets its contentValue in this way.\n            const value = record ? column.getRawValue(record) : record;\n\n            Object.assign(cellContext, {\n                value  : value === undefined ? null : value,\n                editor : column.editor\n            });\n            return cellContext;\n        }\n        else {\n            return false;\n        }\n    }\n\n    /**\n     * Start editing specified cell. If no cellContext is given it starts with the first cell in the first row.\n     * This function is exposed on Grid and can thus be called as `grid.startEditing(...)`\n     * @param {Object} cellContext Cell specified in format { id: 'x', columnId/column/field: 'xxx' }. See\n     * {@link Grid.view.Grid#function-getCell} for details.\n     * @fires startCellEdit\n     * @returns {Promise} Resolved promise returns`true` if editing has been started, `false` if an {@link Core.widget.Editor#event-beforeStart} listener\n     * has vetoed the edit.\n     * @category Editing\n     * @on-owner\n     */\n    async startEditing(cellContext = {}) {\n        const me = this;\n\n        // If disabled no can do.\n        if (!me.disabled) {\n            const { grid } = me;\n\n            // If we got here from keyMap, start editing currently focused cell instead\n            if (cellContext?.fromKeyMap) {\n                cellContext = me.grid.focusedCell;\n            }\n\n            // When cell context is not available add the first cell context\n            if (ObjectHelper.isEmpty(cellContext)) {\n                cellContext.id = grid.firstVisibleRow.id;\n            }\n\n            // Has to expand before normalizing to a Location, since Location only maps to visible rows\n            if (grid.store.isTree && grid.features.tree) {\n                const record = cellContext.id ? grid.store.getById(cellContext.id) : cellContext.record ?? grid.store.getAt(cellContext.row);\n\n                if (record) {\n                    await grid.expandTo(record);\n                }\n                else {\n                    return false;\n                }\n            }\n\n            const editorContext = me.getEditingContext(cellContext);\n\n            // Cannot edit hidden columns and columns without an editor\n            // Cannot edit special rows (groups etc).\n            if (!editorContext) {\n                return false;\n            }\n\n            if (me.editorContext) {\n                me.cancelEditing();\n            }\n\n            // Now that we know we can edit this cell, scroll the record into view and register it as last focusedCell\n            // While any potential scroll may be async, the desired cell will be rendered immediately.\n            if (!grid.focusedCell?.equals(editorContext)) {\n                grid.focusCell(editorContext);\n            }\n\n            /**\n             * Fires on the owning Grid before editing starts, return `false` to prevent editing\n             * @event beforeCellEditStart\n             * @on-owner\n             * @preventable\n             * @param {Grid.view.Grid} source Owner grid\n             * @param {Grid.util.Location} editorContext Editing context\n             * @param {Grid.column.Column} editorContext.column Target column\n             * @param {Core.data.Model} editorContext.record Target record\n             * @param {HTMLElement} editorContext.cell Target cell\n             * @param {Core.widget.Field} editorContext.editor The input field that the column is configured\n             * with (see {@link Grid.column.Column#config-field}). This property mey be replaced\n             * to be a different {@link Core.widget.Field field} in the handler, to take effect\n             * just for the impending edit.\n             * @param {Function} [editorContext.finalize] An async function may be injected into this property\n             * which performs asynchronous finalization tasks such as complex validation of confirmation. The\n             * value `true` or `false` must be returned.\n             * @param {Object} [editorContext.finalize.context] An object describing the editing context upon requested\n             * completion of the edit.\n             * @param {*} editorContext.value Cell value\n             */\n            if (grid.trigger('beforeCellEditStart', { grid, editorContext }) === false) {\n                return false;\n            }\n\n            const\n                editor = editorContext.editor = me.getEditorForCell(editorContext),\n                {\n                    row,\n                    cell,\n                    record\n                }      = editorContext;\n\n            // Prevent highlight when setting the value in the editor\n            editor.inputField.highlightExternalChange = false;\n\n            editor.cellEditorContext = editorContext;\n            editor.render(cell);\n\n            // CSS state must be set before the startEdit causes the Editor to align itself\n            // because if its target is overflow:hidden, it automatically constrains its size.\n            cell.classList.add('b-editing');\n            row.addCls('b-editing');\n\n            // Attempt to start edit.\n            // We will set up our context in onEditorStart *if* the start was successful.\n            if (!(await editor.startEdit({\n                target : cell,\n                field  : editor.inputField.name || editorContext.column.field,\n                value  : editorContext.value,\n                record\n            }))) {\n                // If the editor was vetoed, undo the CSS state.\n                cell.classList.remove('b-editing');\n                row.removeCls('b-editing');\n            }\n\n            me.onCellEditStart?.();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Cancel editing, destroys the editor\n     * This function is exposed on Grid and can thus be called as `grid.cancelEditing(...)`\n     * @param {Boolean} silent Pass true to prevent method from firing event\n     * @fires cancelCellEdit\n     * @category Editing\n     * @on-owner\n     */\n    cancelEditing(silent = false, triggeredByEvent) {\n        const\n            me                              = this,\n            { editorContext, editor } = me;\n\n        // If called from keyMap, first argument is an event, ignore that\n        if (silent.fromKeyMap) {\n            triggeredByEvent = silent;\n            silent = false;\n        }\n\n        if (editorContext) {\n            me.muteEvents = silent;\n            editor.cancelEdit(triggeredByEvent);\n            me.muteEvents = false;\n        }\n\n        // In case editing is canceled while waiting for finishing promise\n        me.finishEditingPromise = false;\n\n        me.afterCellEdit?.();\n    }\n\n    /**\n     * Finish editing, update the underlying record and destroy the editor\n     * This function is exposed on Grid and can thus be called as `grid.finishEditing(...)`\n     * @fires finishCellEdit\n     * @category Editing\n     * @returns {Promise} Resolved promise returns `false` if the edit could not be finished due to the value being invalid or the\n     * Editor's `complete` event was vetoed.\n     * @on-owner\n     */\n    async finishEditing() {\n        const\n            me                      = this,\n            { editorContext, grid } = me;\n\n        let result = false;\n\n        // If already waiting for finishing promise, return that\n        if (me.finishEditingPromise) {\n            return me.finishEditingPromise;\n        }\n\n        if (editorContext) {\n            const { column } = editorContext;\n\n            // If completeEdit finds that the editor context has a finalize method in it,\n            // it will *await* the completion of that method before completing the edit\n            // so we must await completeEdit.\n            // We can override that finalize method by passing the column's own finalizeCellEdit.\n            // Set a flag (promise) indicating that we are in the middle of editing finalization\n            me.finishEditingPromise = editorContext.editor.completeEdit(column.bindCallback(column.finalizeCellEdit));\n            result = await me.finishEditingPromise;\n\n            // If grid is animating, wait for it to finish to not start a follow-up edit when things are moving\n            // (only applies to Scheduler for now, tested in Schedulers CellEdit.t.js)\n            await grid.waitForAnimations();\n\n            // reset the flag\n            me.finishEditingPromise = null;\n\n            me.afterCellEdit?.();\n        }\n\n        return result;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Event handler added when editing is active called when user clicks a cell in the grid during editing.\n     * It finishes editing and moves editor to the selected cell instead.\n     * @private\n     * @category Internal event handling\n     */\n    async onCellClickWhileEditing({ event, cellSelector }) {\n        const me = this;\n\n        if (DomHelper.isTouchEvent) {\n            await me.finishEditing();\n            return;\n        }\n\n        // Ignore clicks if async finalization is running\n        if (me.finishEditingPromise) {\n            return;\n        }\n\n        // Ignore clicks in the editor.\n        if (me.editorContext && !me.editorContext.editor.owns(event.target)) {\n            if (me.getEditingContext(cellSelector)) {\n                // Attempt to finish the current edit.\n                // Will return false if the field is invalid.\n                if (await me.finishEditing()) {\n                    if (me.continueEditingOnCellClick) {\n                        await me.startEditing(cellSelector);\n                    }\n                }\n                // Previous edit was invalid, return to it.\n                else {\n                    me.grid.focusCell(me.editorContext);\n                    me.editor.inputField.focus();\n                }\n            }\n            else {\n                await me.finishEditing();\n            }\n        }\n    }\n\n    /**\n     * Starts editing if user taps selected cell again on touch device. Chained function called when user clicks a cell.\n     * @private\n     * @category Internal event handling\n     */\n    async onCellClick({ source : grid, cellSelector, target, event, column }) {\n        if (column.onCellClick) {\n            // Columns may provide their own handling of cell editing\n            return;\n        }\n\n        const\n            me              = this,\n            { focusedCell } = me.client;\n\n        if (target.closest('.b-tree-expander')) {\n            return false;\n        }\n        else if (DomHelper.isTouchEvent &&\n            me._lastCellClicked === focusedCell?.cell &&\n            event.timeStamp - me.touchEditDelay > me._lastCellClickedTime\n        ) {\n            await me.startEditing(cellSelector);\n        }\n        else if (this.triggerEvent === 'cellclick') {\n            await me.onTriggerEditEvent({ cellSelector, target });\n        }\n\n        me._lastCellClicked     = focusedCell?.cell;\n        me._lastCellClickedTime = event.timeStamp;\n    }\n\n    // onElementPointerUp should be used to cancel editing before toggleCollapse handled\n    // otherwise data collisions may be happened\n    onElementPointerUp(event) {\n        if (event.target.closest('.b-tree-expander')) {\n            this.cancelEditing(undefined, event);\n        }\n    }\n\n    /**\n     * Called when the user triggers the edit action in {@link #config-triggerEvent} config. Starts editing.\n     * @private\n     * @category Internal event handling\n     */\n    async onTriggerEditEvent({ cellSelector, target, event }) {\n        const { editorContext, client } = this;\n\n        if (target.closest('.b-tree-expander') || (DomHelper.isTouchEvent && event.type === 'dblclick')) {\n            return;\n        }\n\n        // Should not start editing if cellMenu configured to be shown on event\n        if (event && client.features.cellMenu?.triggerEvent === event.type) {\n            return;\n        }\n\n        if (editorContext) {\n            // If we are already editing the cellSelector cell, or the editor cannot finish editing\n            // then we must not attempt to start an edit.\n            if (editorContext.equals(this.grid.normalizeCellContext(cellSelector)) || !(await this.finishEditing())) {\n                return;\n            }\n        }\n\n        await this.startEditing(cellSelector);\n    }\n\n    /**\n     * Update the input field if underlying data changes during edit.\n     * @private\n     * @category Internal event handling\n     */\n    onStoreUpdate({ changes, record }) {\n        const { editorContext } = this;\n\n        if (editorContext?.editor.isVisible) {\n            if (record === editorContext.record && editorContext.editor.dataField in changes) {\n                editorContext.editor.refreshEdit();\n            }\n        }\n    }\n\n    onStoreBeforeSort() {\n        const editor = this.editorContext?.editor;\n\n        if (this.isEditing && !editor?.isFinishing && !editor.isValid) {\n            this.cancelEditing();\n        }\n    }\n\n    /**\n     * Realign editor if grid renders rows while editing is ongoing (as a result to autoCommit or WebSocket data received).\n     * @private\n     * @category Internal event handling\n     */\n    onGridRefreshed() {\n        const\n            me = this,\n            {\n                grid,\n                editorContext\n            }  = me;\n\n        if (editorContext && grid.isVisible && grid.focusedCell) {\n            const\n                cell       = grid.getCell(grid.focusedCell),\n                { editor } = editorContext;\n\n            // If refresh was triggered by the data change in onEditComplete\n            // do not re-show the editor.\n            if (cell && DomHelper.isInView(cell) && !editor.isFinishing) {\n                editorContext._cell = cell;\n\n                // Editor is inside the cell for A11Y reasons.\n                // So any refresh will remove its DOM.\n                // We need to silently restore and refocus it.\n                GlobalEvents.suspendFocusEvents();\n                editor.render(cell);\n                editor.showBy(cell);\n                editor.focus();\n                GlobalEvents.resumeFocusEvents();\n            }\n            else {\n                me.cancelEditing();\n            }\n        }\n    }\n\n    // Gets selected records or selected cells records\n    get gridSelection() {\n        return [...this.grid.selectedRecords, ...this.grid.selectedCells];\n    }\n\n    // Tells keyMap what actions is available in certain conditions\n    isActionAvailable(keyCombination, action, event) {\n        const me = this;\n\n        action = action.replace('cellEdit.', '');\n\n        if (!me.disabled && !event.target.closest('.b-grid-header')) {\n            if (me.isEditing) {\n                if (action === 'finishAllSelected') {\n                    return me.multiEdit && me.gridSelection.length > 1;\n                }\n                else if (editingActions[action]) {\n                    return true;\n                }\n            }\n            else if (action === 'startEditing') {\n                return me.grid.focusedCell.cell === event.target;\n            }\n        }\n        return false;\n    }\n\n    // Will copy edited field value to all selected records\n    async finishAllSelected() {\n        const\n            me                    = this,\n            { dataField, record } = me.editor;\n\n        if (await me.finishEditing() && !me.isDestroyed) {\n            for (const selected of me.gridSelection) {\n                if (selected.isModel) {\n                    if (selected !== record) {\n                        selected[dataField] = record[dataField];\n                    }\n                }\n                else {\n                    selected.record.set(selected.column.field, record[dataField]);\n                }\n            }\n        }\n    }\n\n    // Will finish editing and start editing next row (unless it's a touch device)\n    // If addNewAtEnd, it will create a new row and edit that one if currently editing last row\n    async finishAndEditNextRow(event, previous = false) {\n        const\n            me         = this,\n            { grid }   = me,\n            { record } = me.editorContext;\n\n        let nextCell;\n\n        if (await me.finishEditing()) {\n            // Might be destroyed during the async operation\n            if (me.isDestroyed) {\n                return;\n            }\n\n            // Finalizing might have been blocked by an invalid value\n            if (!me.isEditing) {\n                // Move to previous\n                if (previous) {\n                    nextCell = grid.internalNextPrevRow(false, true, event, false);\n                }\n                // Move to next\n                else {\n                    // If we are at the last editable cell, optionally add a new row\n                    if (me.addNewAtEnd && record === grid.store.last) {\n                        await me.doAddNewAtEnd();\n                    }\n\n                    if (!me.isDestroyed) {\n                        nextCell = grid.internalNextPrevRow(true, true, event);\n                    }\n                }\n\n                // If we have moved, and we are configure to edit the next cell on Enter key...\n                if (nextCell && me.editNextOnEnterPress && !grid.touch) {\n                    me.startEditing(nextCell);\n                }\n            }\n        }\n    }\n\n    // Will finish editing and start editing previous row\n    finishAndEditPrevRow(event) {\n        this.finishAndEditNextRow(event, true);\n    }\n\n    // Will finish editing and start editing next cell\n    // If addNewAtEnd, it will create a new row and edit that one if currently editing last row\n    async finishAndEditNextCell(event, previous = false) {\n        const\n            me              = this,\n            { focusedCell } = me.grid;\n\n        if (focusedCell) {\n\n            let cellInfo = me.getAdjacentEditableCell(focusedCell, !previous);\n\n            // If we are at the last editable cell, optionally add a new row\n            if (!cellInfo && !previous && me.addNewAtEnd) {\n                const currentEditableFinalizationResult = await me.finishEditing();\n\n                if (currentEditableFinalizationResult === true) {\n                    await this.doAddNewAtEnd();\n\n                    // Re-grab the next editable cell\n                    cellInfo = !me.isDestroyed && me.getAdjacentEditableCell(focusedCell, !previous);\n                }\n            }\n\n            if (cellInfo) {\n                let finalizationResult = true;\n\n                if (me.isEditing) {\n                    finalizationResult = await me.finishEditing();\n                }\n\n                if (!me.isDestroyed && finalizationResult) {\n                    me.grid.focusCell(cellInfo, {\n                        animate : me.focusCellAnimationDuration\n                    });\n\n                    if (!(await me.startEditing(cellInfo))) {\n                        // if editing a cell was vetoed, move on and try again\n                        await me.finishAndEditNextCell(event, previous);\n                    }\n                }\n                else {\n                    // finishing cell editing was not allowed, current editor value is invalid\n                }\n            }\n        }\n    }\n\n    // Will finish editing and start editing next cell\n    finishAndEditPrevCell(event) {\n        this.finishAndEditNextCell(event, true);\n    }\n\n    // Handles autoedit\n    async onElementKeyDown(event) {\n        const\n            me              = this,\n            { grid }        = me,\n            { focusedCell } = grid,\n            { key }         = event;\n\n        // flagging event with handled = true used to signal that other features should probably not care about it\n        if (event.handled || !me.autoEdit || me.isEditing || !focusedCell || focusedCell.isActionable || event.ctrlKey) {\n            return;\n        }\n\n        // Any character or space starts editing while autoedit is true\n        if (key.length <= 1 && await me.startEditing(focusedCell)) {\n            const\n                { inputField } = me.editor,\n                { input }      = inputField;\n\n            // if editing started with a keypress and the editor has an input field, set its value\n            if (input) {\n                // Simulate a keydown in an input field by setting input value\n                // plus running our internal processing of that event\n                inputField.internalOnKeyEvent(event);\n\n                if (!event.defaultPrevented) {\n                    input.value = key;\n                    inputField.internalOnInput(event);\n                }\n            }\n            event.preventDefault();\n        }\n        else if (event.key === 'Delete' || event.key === 'Backspace') {\n            const { gridSelection } = me;\n\n            if (me.multiEdit && gridSelection.length > 1) {\n                for (const selected of gridSelection) {\n                    if (selected.isModel) {\n                        grid.visibleColumns.forEach(col => {\n                            selected.set(col.field, null);\n                        });\n                    }\n                    else {\n                        selected.record.set(selected.column.field, null);\n                    }\n                }\n            }\n            else {\n                focusedCell.record.set(focusedCell.column.field, null);\n            }\n        }\n    }\n\n    // Prevents arrowkeys from navigating while editing\n    onEditorKeydown(event) {\n        if (event.key.startsWith('Arrow')) {\n            event.handled = true;\n            event.stopPropagation();\n            return false;\n        }\n    }\n\n    /**\n     * Cancel editing on widget focusout\n     * @private\n     */\n    async onEditorFocusOut(event) {\n        const\n            me              = this,\n            {\n                grid,\n                editor,\n                editorContext\n            }                   = me,\n            toCell              = new Location(event.relatedTarget),\n            isEditableCellClick = (toCell.grid === grid) && me.getEditingContext(toCell);\n\n        // If the editor is not losing focus as a result of its tidying up process\n        // And focus is moving to outside of the editor, then explicitly terminate.\n        if (editorContext && !editor.isFinishing && editor.owns(event._target)) {\n            if (me.blurAction === 'cancel') {\n                me.cancelEditing(undefined, event);\n            }\n            // If not already in the middle of editing finalization (that could be async)\n            // and it's not a onCellClickWhileEditing situation, finish the edit.\n            else if (!me.finishEditingPromise && (me.triggerEvent === 'cellclick' || (me.triggerEvent !== 'cellclick' && !isEditableCellClick))) {\n                await me.finishEditing();\n            }\n        }\n    }\n\n    onEditorFocusIn(event) {\n        const widget = event.toWidget;\n\n        if (widget === this.editor.inputField) {\n            if (this.autoSelect && widget.selectAll && !widget.readOnly && !widget.disabled) {\n                widget.selectAll();\n            }\n        }\n    }\n\n    /**\n     * Cancel edit on touch outside of grid for mobile Safari (focusout not triggering unless you touch something focusable)\n     * @private\n     */\n    async onTapOut({ event }) {\n        const me = this;\n\n        if (!me.grid.bodyContainer.contains(event.target) || event.button) {\n            if (!me.editor.owns(event.target)) {\n                me.editingStoppedByTapOutside = true;\n                if (me.blurAction === 'cancel') {\n                    me.cancelEditing(undefined, event);\n                }\n                else {\n                    await me.finishEditing();\n                }\n                delete me.editingStoppedByTapOutside;\n            }\n        }\n    }\n\n    /**\n     * Finish editing if clicking below rows (only applies when grid is higher than rows).\n     * @private\n     * @category Internal event handling\n     */\n    async onElementClick(event) {\n        if (event.target.classList.contains('b-grid-body-container') && this.editorContext) {\n            await this.finishEditing();\n        }\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(CellEdit, true);\n","import ContextMenuBase from '../../Core/feature/base/ContextMenuBase.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Grid/feature/CellMenu\n */\n\n/**\n * Right click to display context menu for cells.\n *\n * To invoke the cell menu in a keyboard-accessible manner, use the `SPACE` key when the cell is focused.\n *\n * ### Default cell menu items\n *\n * The Cell menu feature provides only one item by default:\n *\n * | Reference              | Text   | Weight | Description         |\n * |------------------------|--------|--------|---------------------|\n * | `removeRow`            | Delete | 100    | Delete row record   |\n *\n * And all the other items are populated by the other features:\n *\n * | Reference              | Text             | Weight | Feature                           | Description                                           |\n * |------------------------|------------------|--------|-----------------------------------|-------------------------------------------------------|\n * | `cut`                  | Cut record       | 110    | {@link Grid/feature/RowCopyPaste} | Cut row record                                        |\n * | `copy`                 | Copy record      | 120    | {@link Grid/feature/RowCopyPaste} | Copy row record                                       |\n * | `paste`                | Paste record     | 130    | {@link Grid/feature/RowCopyPaste} | Paste copied row records                              |\n * | `search`               | Search for value | 200    | {@link Grid/feature/Search}       | Search for the selected cell text                     |\n * | `filterDateEquals`     | On               | 300    | {@link Grid/feature/Filter}       | Filters by the column field, equal to the cell value  |\n * | `filterDateBefore`     | Before           | 310    | {@link Grid/feature/Filter}       | Filters by the column field, less than the cell value |\n * | `filterDateAfter`      | After            | 320    | {@link Grid/feature/Filter}       | Filters by the column field, more than the cell value |\n * | `filterNumberEquals`   | Equals           | 300    | {@link Grid/feature/Filter}       | Filters by the column field, equal to the cell value  |\n * | `filterNumberLess`     | Less than        | 310    | {@link Grid/feature/Filter}       | Filters by the column field, less than the cell value |\n * | `filterNumberMore`     | More than        | 320    | {@link Grid/feature/Filter}       | Filters by the column field, more than the cell value |\n * | `filterDurationEquals` | Equals           | 300    | {@link Grid/feature/Filter}       | Filters by the column field, equal to the cell value  |\n * | `filterDurationLess`   | Less than        | 310    | {@link Grid/feature/Filter}       | Filters by the column field, less than the cell value |\n * | `filterDurationMore`   | More than        | 320    | {@link Grid/feature/Filter}       | Filters by the column field, more than the cell value |\n * | `filterStringEquals`   | Equals           | 300    | {@link Grid/feature/Filter}       | Filters by the column field, equal to the cell value  |\n * | `filterRemove`         | Remove filter    | 400    | {@link Grid/feature/Filter}       | Stops filtering by selected column field              |\n *\n * ### Customizing the menu items\n *\n * The menu items in the Cell menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * Add extra items for all columns:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         cellMenu : {\n *             items : {\n *                 extraItem : {\n *                     text   : 'My cell item',\n *                     icon   : 'fa fa-bus',\n *                     weight : 200,\n *                     onItem : () => ...\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * It is also possible to add items using columns config. See examples below.\n *\n * Add extra items for a single column:\n *\n * ```javascript\n * const grid = new Grid({\n *     columns: [\n *         {\n *             field         : 'city',\n *             text          : 'City',\n *             cellMenuItems : {\n *                 columnItem : {\n *                     text   : 'My unique cell item',\n *                     icon   : 'fa fa-beer',\n *                     onItem : () => ...\n *                 }\n *             }\n *         }\n *     ]\n * });\n * ```\n *\n * Remove existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         cellMenu : {\n *             items : {\n *                 removeRow : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Customize existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         cellMenu : {\n *             items : {\n *                 removeRow : {\n *                     text : 'Throw away',\n *                     icon : 'b-fa b-fa-dumpster'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * It is also possible to manipulate the default items and add new items in the processing function:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         cellMenu : {\n *             processItems({items, record}) {\n *                 if (record.cost > 5000) {\n *                     items.myItem = { text : 'Split cost' };\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Full information of the menu customization can be found in the [\"Customizing the Cell menu and the Header menu\"](#Grid/guides/customization/contextmenu.md)\n * guide.\n *\n * This feature is **enabled** by default.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys       | Action               | Action description                            |\n * |------------|----------------------|-----------------------------------------------|\n * | Space      | showContextMenuByKey | Shows context menu for currently focused cell |\n * | Ctrl+Space | showContextMenuByKey | Shows context menu for currently focused cell |\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md).\n *\n * @extends Core/feature/base/ContextMenuBase\n * @demo Grid/contextmenu\n * @classtype cellMenu\n * @inlineexample Grid/feature/CellMenu.js\n * @feature\n */\nexport default class CellMenu extends ContextMenuBase {\n    //region Config\n\n    static get $name() {\n        return 'CellMenu';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             * features : {\n             *     cellMenu : {\n             *         processItems({ items, record, column }) {\n             *             // Add or hide existing items here as needed\n             *             items.myAction = {\n             *                 text   : 'Cool action',\n             *                 icon   : 'b-fa b-fa-fw b-fa-ban',\n             *                 onItem : () => console.log(`Clicked ${record.name}`),\n             *                 weight : 1000 // Move to end\n             *             };\n             *\n             *             if (!record.allowDelete) {\n             *                 items.removeRow.hidden = true;\n             *             }\n             *         }\n             *     }\n             * },\n             * ```\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Core.data.Model} context.record The record representing the current row\n             * @param {Grid.column.Column} context.column The current column\n             * @param {Object<String,MenuItemConfig>} context.items An object containing the\n             * {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @config {Function}\n             * @preventable\n             */\n            processItems : null,\n\n            /**\n             * {@link Core.widget.Menu} items object containing named child menu items to apply to the feature's\n             * provided context menu.\n             *\n             * This may add extra items as below, but you can also configure, or remove any of the default items by\n             * configuring the name of the item as `null`:\n             *\n             * ```javascript\n             * features : {\n             *     cellMenu : {\n             *         // This object is applied to the Feature's predefined default items\n             *         items : {\n             *             switchToDog : {\n             *                 text : 'Dog',\n             *                 icon : 'b-fa b-fa-fw b-fa-dog',\n             *                 onItem({record}) {\n             *                     record.dog = true;\n             *                     record.cat = false;\n             *                 },\n             *                 weight : 500     // Make this second from end\n             *             },\n             *             switchToCat : {\n             *                 text : 'Cat',\n             *                 icon : 'b-fa b-fa-fw b-fa-cat',\n             *                 onItem({record}) {\n             *                     record.dog = false;\n             *                     record.cat = true;\n             *                 },\n             *                 weight : 510     // Make this sink to end\n             *             },\n             *             removeRow : {\n             *                 // Change icon for the delete item\n             *                 icon : 'b-fa b-fa-times'\n             *             },\n             *             secretItem : null\n             *         }\n             *     }\n             * },\n             * ```\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>}\n             */\n            items : null,\n\n            type : 'cell'\n\n            /**\n             * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n             * @config {Object<String,String>} keyMap\n             */\n        };\n    }\n\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n\n        config.chain.push('populateCellMenu');\n\n        return config;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * This event fires on the owning grid before the context menu is shown for a cell.\n     * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.\n     *\n     * Returning `false` from a listener prevents the menu from being shown.\n     *\n     * @event cellMenuBeforeShow\n     * @preventable\n     * @on-owner\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Column\n     * @param {Core.data.Model} record Record\n     */\n\n    /**\n     * This event fires on the owning grid after the context menu is shown for a cell.\n     * @event cellMenuShow\n     * @on-owner\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Column\n     * @param {Core.data.Model} record Record\n     */\n\n    /**\n     * This event fires on the owning grid when an item is selected in the cell context menu.\n     * @event cellMenuItem\n     * @on-owner\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {Grid.column.Column} column Column\n     * @param {Core.data.Model} record Record\n     */\n\n    /**\n     * This event fires on the owning grid when a check item is toggled in the cell context menu.\n     * @event cellMenuToggleItem\n     * @on-owner\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {Grid.column.Column} column Column\n     * @param {Core.data.Model} record Record\n     * @param {Boolean} checked Checked or not\n     */\n\n    //endregion\n\n    //region Menu handlers\n\n    showContextMenu(eventParams) {\n        const\n            me = this,\n            {\n                cellSelector,\n                event\n            }  = eventParams;\n\n        // Process the gesture as navigation so that the use may select/multiselect\n        // the items to include in their context menu operation.\n        // Also select if not already selected.\n        me.client.focusCell(cellSelector, {\n            doSelect : !me.client.isSelected(cellSelector),\n            event\n        });\n\n        super.showContextMenu(eventParams);\n    }\n\n    shouldShowMenu({ column }) {\n        return column && column.enableCellContextMenu !== false;\n    }\n\n    getDataFromEvent(event) {\n        const cellData = this.client.getCellDataFromEvent(event);\n\n        // Only yield data to show a menu if we are on a cell\n        if (cellData) {\n            return ObjectHelper.assign(super.getDataFromEvent(event), cellData);\n        }\n    }\n\n    beforeContextMenuShow({ record, items, column }) {\n        if (column.cellMenuItems === false) {\n            return false;\n        }\n        if (!record || record.isSpecialRow) {\n            items.removeRow = false;\n        }\n    }\n\n    //endregion\n\n    //region Getters/Setters\n\n    populateCellMenu({ items, column, record }) {\n        const { client } = this;\n\n        if (column?.cellMenuItems) {\n            ObjectHelper.merge(items, column.cellMenuItems);\n        }\n\n        if (!client.readOnly) {\n            items.removeRow = {\n                text        : 'L{removeRow}',\n                localeClass : this,\n                icon        : 'b-fw-icon b-icon-trash',\n                cls         : 'b-separator',\n                weight      : 100,\n                disabled    : record.readOnly,\n                onItem      : () => client.store.remove(client.selectedRecords.filter(r => !r.readOnly))\n            };\n        }\n    }\n\n    get showMenu() {\n        return true;\n    }\n\n    //endregion\n}\n\nCellMenu.featureClass = '';\n\nGridFeatureManager.registerFeature(CellMenu, true, ['Grid', 'Scheduler']);\nGridFeatureManager.registerFeature(CellMenu, false, ['Gantt']);\n","import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport TemplateHelper from '../../Core/helper/TemplateHelper.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\n\n/**\n * @module Grid/feature/ColumnDragToolbar\n */\n\n/**\n * Displays a toolbar while dragging column headers. Drop on a button in the toolbar to activate a certain function,\n * for example to group by that column. This feature simplifies certain operations on touch devices.\n *\n * This feature is <strong>disabled</strong> by default, but turned on automatically on touch devices.\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @classtype columnDragToolbar\n * @inlineexample Grid/feature/ColumnDragToolbar.js\n * @demo Grid/columndragtoolbar\n * @feature\n */\nexport default class ColumnDragToolbar extends Delayable(InstancePlugin) {\n    //region Config\n\n    static get $name() {\n        return 'ColumnDragToolbar';\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid\n    static get pluginConfig() {\n        return {\n            after : ['render']\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    construct(grid, config) {\n        grid.features.columnReorder?.ion({ beforeDestroy : 'onColumnReorderBeforeDestroy', thisObj : this });\n\n        this.grid = grid;\n\n        super.construct(grid, config);\n    }\n\n    doDestroy() {\n        const me = this;\n\n        if (me.grid.features.columnReorder && !me.grid.features.columnReorder.isDestroyed) {\n            me.detachFromColumnReorder();\n        }\n\n        me.element && me.element.remove();\n        me.element = null;\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        if (this.initialized) {\n            if (disable) {\n                this.detachFromColumnReorder();\n            }\n            else {\n                this.init();\n            }\n        }\n        super.doDisable(disable);\n    }\n\n    init() {\n        const\n            me   = this,\n            grid = me.grid;\n\n        if (!grid.features.columnReorder) {\n            return;\n        }\n\n        me.reorderDetacher = grid.features.columnReorder.ion({\n            gridheaderdragstart({ context }) {\n                const column = grid.columns.getById(context.element.dataset.columnId);\n                me.showToolbar(column);\n            },\n\n            gridheaderdrag : ({ context }) => me.onDrag(context),\n\n            gridheaderabort : () => {\n                me.hideToolbar();\n            },\n\n            gridheaderdrop : ({ context }) => {\n                if (context.valid) {\n                    me.hideToolbar();\n                }\n                else {\n                    me.onDrop(context);\n                }\n            },\n\n            thisObj : me\n        });\n\n        me.initialized = true;\n    }\n\n    onColumnReorderBeforeDestroy() {\n        this.detachFromColumnReorder();\n    }\n\n    detachFromColumnReorder() {\n        const me = this;\n\n        me.grid.features.columnReorder.un('beforedestroy', me.onColumnReorderBeforeDestroy, me);\n\n        me.reorderDetacher && me.reorderDetacher();\n        me.reorderDetacher = null;\n    }\n\n    /**\n     * Initializes this feature on grid render.\n     * @private\n     */\n    render() {\n        if (!this.initialized) {\n            this.init();\n        }\n    }\n\n    //endregion\n\n    //region Toolbar\n\n    showToolbar(column) {\n        const\n            me      = this,\n            buttons = me.grid.getColumnDragToolbarItems(column, []),\n            groups  = [];\n\n        me.clearTimeout(me.buttonHideTimer);\n\n        buttons.forEach(button => {\n            button.text = button.localeClass.L(button.text);\n\n            let group = groups.find(group => group.text === button.group);\n            if (!group) {\n                group = {\n                    text    : button.localeClass.L(button.group),\n                    buttons : []\n                };\n                groups.push(group);\n            }\n\n            group.buttons.push(button);\n        });\n\n        me.element = DomHelper.append(me.grid.element, me.template(groups));\n\n        me.groups  = groups;\n        me.buttons = buttons;\n        me.column  = column;\n    }\n\n    async hideToolbar() {\n        const\n            me = this,\n            element = me.element;\n\n        if (element) {\n            element.classList.add('b-remove');\n\n            await EventHelper.waitForTransitionEnd({\n                element,\n                mode    : 'animation',\n                thisObj : me.client\n            });\n\n            element.remove();\n            me.element = null;\n        }\n    }\n\n    //endregion\n\n    //region Events\n\n    onDrag(info) {\n        const me = this;\n\n        if (info.dragProxy.getBoundingClientRect().top - me.grid.element.getBoundingClientRect().top > 100) {\n            me.element.classList.add('b-closer');\n        }\n        else {\n            me.element.classList.remove('b-closer');\n        }\n\n        if (me.hoveringButton) {\n            me.hoveringButton.classList.remove('b-hover');\n            me.hoveringButton = null;\n        }\n\n        if (info.targetElement?.closest('.b-columndragtoolbar')) {\n            me.element.classList.add('b-hover');\n\n            const\n                button = info.targetElement.closest('.b-columndragtoolbar  .b-target-button:not([data-disabled=true])');\n            if (button) {\n                button.classList.add('b-hover');\n                me.hoveringButton = button;\n            }\n        }\n        else {\n            me.element.classList.remove('b-hover');\n        }\n    }\n\n    onDrop(info) {\n        const me = this;\n\n        if (info.targetElement && info.targetElement.matches('.b-columndragtoolbar .b-target-button:not([data-disabled=true])')) {\n            const buttonEl = info.targetElement,\n                button   = me.buttons.find(button => button.ref === buttonEl.dataset.ref);\n\n            if (button) {\n                buttonEl.classList.add('b-activate');\n\n                me.buttonHideTimer = me.setTimeout(() => {\n                    me.hideToolbar();\n                    button.onDrop({ column : me.column });\n                }, 100);\n            }\n        }\n        else {\n            me.hideToolbar();\n        }\n    }\n\n    //endregion\n\n    template(groups) {\n        return TemplateHelper.tpl`\n            <div class=\"b-columndragtoolbar\">     \n            <div class=\"b-title\"></div>          \n            ${groups.map(group => TemplateHelper.tpl`\n                <div class=\"b-group\">\n                    <div class=\"b-buttons\">\n                    ${group.buttons.map(btn => TemplateHelper.tpl`\n                        <div class=\"b-target-button\" data-ref=\"${btn.ref}\" data-disabled=\"${btn.disabled}\">\n                            <i class=\"${btn.icon}\"></i>\n                            ${btn.text}\n                        </div>\n                    `)}\n                    </div>\n                    <div class=\"b-title\">${group.text}</div>\n                </div>\n            `)}\n            </div>`;\n    }\n}\n\nColumnDragToolbar.featureClass = 'b-hascolumndragtoolbar';\n\n// used by default on touch devices, can be enabled otherwise\nGridFeatureManager.registerFeature(ColumnDragToolbar, BrowserHelper.isTouchDevice);\n","import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Grid/feature/ColumnPicker\n */\n\n/**\n * Displays a column picker (to show/hide columns) in the header context menu. Columns can be displayed in sub menus\n * by region or tag. Grouped headers are displayed as menu hierarchies.\n *\n * {@inlineexample Grid/feature/ColumnPicker.js}\n *\n * This feature is <strong>enabled</strong> by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/columns\n * @classtype columnPicker\n * @feature\n */\nexport default class ColumnPicker extends InstancePlugin {\n    //region Config\n\n    static $name = 'ColumnPicker';\n\n    static configurable = {\n        /**\n         * Groups columns in the picker by region (each region gets its own sub menu)\n         * @config {Boolean}\n         * @default\n         */\n        groupByRegion : false,\n\n        /**\n         * Groups columns in the picker by tag, each column may be shown under multiple tags. See\n         * {@link Grid.column.Column#config-tags}\n         * @config {Boolean}\n         * @default\n         */\n        groupByTag : false,\n\n        /**\n         * Configure this as `true` to have the fields from the Grid's {@link Core.data.Store}'s\n         * {@link Core.data.Store#config-modelClass} added to the menu to create __new__ columns\n         * to display the fields.\n         *\n         * This may be combined with the {@link Grid.view.mixin.GridState stateful} ability of the grid\n         * to create a self-configuring grid.\n         * @config {Boolean}\n         * @default\n         */\n        createColumnsFromModel : false,\n\n        menuCls : 'b-column-picker-menu b-sub-menu'\n    }\n\n    static get pluginConfig() {\n        return {\n            chain : ['populateHeaderMenu', 'getColumnDragToolbarItems']\n        };\n    }\n\n    get grid() {\n        return this.client;\n    }\n\n    //endregion\n\n    //region Context menu\n\n    /**\n     * Get menu items, either a straight list of columns or sub menus per subgrid\n     * @private\n     * @param columnStore Column store to traverse\n     * @returns {MenuItemConfig[]} Menu item configs\n     */\n    getColumnPickerItems(columnStore) {\n        const\n            me                        = this,\n            { createColumnsFromModel } = me;\n\n        let result;\n\n        if (me.groupByRegion) {\n            // submenus for grids regions\n            result = me.grid.regions.map(region => {\n                const columns = me.grid.getSubGrid(region).columns.topColumns;\n\n                return {\n                    text     : StringHelper.capitalize(region),\n                    menu     : me.buildColumnMenu(columns),\n                    disabled : columns.length === 0,\n                    region\n                };\n            });\n            if (createColumnsFromModel) {\n                result.push({\n                    text : me.L('L{newColumns}'),\n                    menu : me.createAutoColumnItems()\n                });\n            }\n        }\n        else if (me.groupByTag) {\n            // submenus for column tags\n            const tags = {};\n            columnStore.topColumns.forEach(column => {\n                column.tags && Array.isArray(column.tags) && column.hideable !== false && column.tags.forEach(tag => {\n                    if (!tags[tag]) {\n                        tags[tag] = 1;\n                    }\n                });\n            });\n\n            // TODO: as checkitems, but how to handle toggling? hide a column only when all tags for it are unchecked?\n            result = Object.keys(tags).sort().map(tag => ({\n                text            : StringHelper.capitalize(tag),\n                menu            : me.buildColumnMenu(me.getColumnsForTag(tag)),\n                tag,\n                onBeforeSubMenu : ({ item, itemEl }) => {\n                    me.refreshTagMenu(item, itemEl);\n                }\n            }));\n            if (createColumnsFromModel) {\n                result.push({\n                    text : me.L('L{newColumns}'),\n                    menu : me.createAutoColumnItems()\n                });\n            }\n        }\n        else {\n            // all columns in same menu\n            result = me.buildColumnMenu(columnStore.topColumns);\n\n            if (createColumnsFromModel) {\n                result.items.push(...ObjectHelper.transformNamedObjectToArray(me.createAutoColumnItems()));\n            }\n        }\n\n        return result;\n    }\n\n    createAutoColumnItems() {\n        const\n            me             = this,\n            { grid }       = me,\n            {\n                columns,\n                store\n            }              = grid,\n            { modelClass } = store,\n            { allFields }  = modelClass,\n            result         = {};\n\n        for (let i = 0, { length } = allFields; i < length; i++) {\n            const\n                field     = allFields[i],\n                fieldName = field.name;\n\n            if (!columns.get(fieldName)) {\n                // Don't include system-level \"internal\" fields from the base Model classes like rowHeight or cls.\n                if (!field.internal) {\n                    result[fieldName] = {\n                        text     : field.text || StringHelper.separate(field.name),\n                        checked  : false,\n                        onToggle : (event) => {\n                            const column = columns.get(fieldName);\n\n                            if (column) {\n                                column[event.checked ? 'show' : 'hide']();\n                            }\n                            else {\n                                columns.add(columns.generateColumnForField(field, {\n                                    region : me.forColumn.region\n                                }));\n                            }\n                            event.bubbles = false;\n                        }\n                    };\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Get all columns that has the specified tag\n     * TODO: if tags are useful from somewhere else, move to ColumnStore\n     * @private\n     * @param tag\n     * @returns {Grid.column.Column[]}\n     */\n    getColumnsForTag(tag) {\n        // TODO: if tags are useful from somewhere else, move to ColumnStore\n        return this.grid.columns.records.filter(column =>\n            column.tags && Array.isArray(column.tags) && column.tags.includes(tag) && column.hideable !== false\n        );\n    }\n\n    /**\n     * Refreshes checked status for a tag menu. Needed since columns can appear under multiple tags.\n     * @private\n     */\n    refreshTagMenu(item, itemEl) {\n        const columns = this.getColumnsForTag(item.tag);\n        columns.forEach(column => {\n            const subItem = item.items.find(subItem => subItem.column === column);\n            if (subItem) subItem.checked = column.hidden !== true;\n        });\n    }\n\n    /**\n     * Traverses columns to build menu items for the column picker.\n     * @private\n     */\n    buildColumnMenu(columns) {\n        let currentRegion = columns.length > 0 && columns[0].region;\n\n        const\n            { grid } = this,\n            items    = columns.reduce((items, column) => {\n                const visibleInRegion = grid.columns.visibleColumns.filter(col => col.region === column.region);\n\n                if (column.hideable !== false) {\n                    const itemConfig = {\n                        grid,\n                        column,\n                        text     : column.headerText,\n                        checked  : column.hidden !== true,\n                        disabled : column.hidden !== true && visibleInRegion.length === 1,\n                        cls      : column.region !== currentRegion ? 'b-separator' : ''\n                    };\n\n                    currentRegion = column.region;\n\n                    if (column.children && !column.isCollapsible) {\n                        itemConfig.menu = this.buildColumnMenu(column.children);\n                    }\n\n                    items.push(itemConfig);\n                }\n                return items;\n            }, []);\n\n        return {\n            cls : this.menuCls,\n            items\n        };\n    }\n\n    /**\n     * Populates the header context menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateHeaderMenu({ column, items }) {\n        const\n            me          = this,\n            { columns } = me.grid;\n\n        /**\n         * The column on which the context menu was invoked.\n         * @property {Grid.column.Column} forColumn\n         * @readonly\n         * @private\n         */\n        me.forColumn = column;\n\n        if (column.showColumnPicker !== false && columns.some(col => col.hideable)) {\n            // column picker\n            items.columnPicker = {\n                text        : 'L{columnsMenu}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-columns',\n                cls         : 'b-separator',\n                weight      : 200,\n                menu        : me.getColumnPickerItems(columns),\n                onToggle    : me.onColumnToggle,\n                disabled    : me.disabled\n            };\n        }\n\n        // menu item for hiding this column\n        if (column.hideable !== false && !column.parent.isCollapsible) {\n            const visibleInRegion = columns.visibleColumns.filter(col => col.region === column.region);\n\n            items.hideColumn = {\n                text        : 'L{hideColumn}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-hide-column',\n                weight      : 210,\n                disabled    : visibleInRegion.length === 1 || me.disabled,\n                onItem      : () => column.hide()\n            };\n        }\n    }\n\n    /**\n     * Handler for column hide/show menu checkitems.\n     * @private\n     * @param {Object} event The {@link Core.widget.MenuItem#event-toggle} event.\n     */\n    onColumnToggle({ menu, item, checked }) {\n        if (Boolean(item.column.hidden) !== !checked) {\n            item.column[checked ? 'show' : 'hide']();\n\n            const\n                { grid, column }      = item,\n                { columns, features } = grid,\n                // Sibling items, needed to disable other item if it is the last one in region\n                siblingItems          = menu.items,\n                // Columns left visible in same region as this items column\n                visibleInRegion       = columns.visibleColumns.filter(col => col.region === item.column.region),\n                // Needed to access \"hide-column\" item outside of column picker\n                hideItem              = features.headerMenu?.enabled && features.headerMenu.menu.widgetMap.hideColumn;\n\n            // Do not allow user to hide the last column in any region\n            if (visibleInRegion.length === 1) {\n                const lastVisibleItem = siblingItems.find(menuItem => menuItem.column === visibleInRegion[0]);\n                if (lastVisibleItem) {\n                    lastVisibleItem.disabled = true;\n                }\n\n                // Also disable \"Hide column\" item if only one column left in this region\n                if (hideItem && column.region === item.column.region) {\n                    hideItem.disabled = true;\n                }\n            }\n            // Multiple columns visible, enable \"hide-column\" and all items for that region\n            else {\n                visibleInRegion.forEach(col => {\n                    const siblingItem = siblingItems.find(sibling => sibling.column === col);\n                    if (siblingItem) {\n                        siblingItem.disabled = false;\n                    }\n                });\n\n                if (hideItem && column.region === item.column.region) {\n                    hideItem.disabled = false;\n                }\n            }\n\n            // Reflect status in submenu.\n            item.menu?.eachWidget(subItem => {\n                subItem.checked = checked;\n            });\n\n            const parentItem = menu.owner;\n            if (parentItem && parentItem.column === column.parent) {\n                parentItem.checked = siblingItems.some(subItem => subItem.checked === true);\n            }\n        }\n    }\n\n    /**\n     * Supply items to ColumnDragToolbar\n     * @private\n     */\n    getColumnDragToolbarItems(column, items) {\n        const visibleInRegion = this.grid.columns.visibleColumns.filter(col => col.region === column.region);\n\n        if (column.hideable !== false && visibleInRegion.length > 1) {\n            items.push({\n                text        : 'L{hideColumnShort}',\n                ref         : 'hideColumn',\n                group       : 'L{column}',\n                localeClass : this,\n                icon        : 'b-fw-icon b-icon-hide-column',\n                weight      : 101,\n                onDrop      : ({ column }) => column.hide()\n            });\n        }\n        return items;\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(ColumnPicker, true);\n","import DomHelper from '../../Core/helper/DomHelper.js';\nimport DragHelper from '../../Core/helper/DragHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport ScrollManager from '../../Core/util/ScrollManager.js';\n\n/**\n * @module Grid/feature/ColumnReorder\n */\n\n/**\n * Allows user to reorder columns by dragging headers. To get notified about column reorder listen to `change` event\n * on {@link Grid.data.ColumnStore columns} store.\n *\n * {@inlineexample Grid/feature/ColumnReorder.js}\n *\n * This feature is <strong>enabled</strong> by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/columns\n * @classtype columnReorder\n * @feature\n */\nexport default class ColumnReorder extends Delayable(InstancePlugin) {\n    //region Init\n\n    static $name = 'ColumnReorder';\n\n    ignoreSelectors = [\n        '.b-grid-header-resize-handle',\n        '.b-field'\n    ];\n\n    doDestroy() {\n        this.dragHelper?.scrollManager.destroy();\n        this.dragHelper?.destroy();\n\n        super.doDestroy();\n    }\n\n    get grid() {\n        return this.client;\n    }\n\n    /**\n     * Initialize drag & drop (called from render)\n     * @private\n     */\n    init() {\n        const\n            me         = this,\n            { grid }   = me,\n            gridEl     = grid.element,\n            containers = DomHelper.children(gridEl, '.b-grid-headers');\n\n        containers.push(...DomHelper.children(gridEl, '.b-grid-header-children'));\n\n        if (me.dragHelper) {\n            // update the dragHelper with the new set of containers it should operate upon\n            me.dragHelper.containers = containers;\n        }\n        else {\n            me.dragHelper = new DragHelper({\n                name             : 'columnReorder',\n                mode             : 'container',\n                dragThreshold    : 10,\n                targetSelector   : '.b-grid-header',\n                floatRootOwner   : grid,\n                rtlSource        : grid,\n                outerElement     : grid.headerContainer,\n                monitoringConfig : {\n                    scrollables : [{\n                        element : '.b-grid-headers'\n                    }]\n                },\n                scrollManager : ScrollManager.new({\n                    direction : 'horizontal',\n                    element   : grid.headerContainer\n                }),\n                containers,\n                isElementDraggable(element) {\n                    const abort = Boolean(element.closest(me.ignoreSelectors.join(',')));\n\n                    if (abort || me.disabled) {\n                        return false;\n                    }\n\n                    const\n                        columnEl = element.closest(this.targetSelector),\n                        column   = columnEl && grid.columns.getById(columnEl.dataset.columnId),\n                        isLast   = column?.childLevel === 0 && grid.subGrids[column.region].columns.count === 1;\n\n                    // TODO: If we want to prevent dragging last column out of group we can use the code below...\n                    /*isLast = column.level !== 0\n                            // In grouped header, do not allow dragging last remaining child\n                            ? column.parent.children.length === 1\n                            // Not in a grouped header, do not allow dragging last remaining column\n                            : grid.subGrids[column.region].columns.count === 1;*/\n\n                    return Boolean(column) && column.draggable !== false && !isLast;\n                },\n                ignoreSelector    : '.b-filter-icon,.b-grid-header-resize-handle',\n                internalListeners : {\n                    beforeDragStart : me.onBeforeDragStart,\n                    dragstart       : me.onDragStart,\n                    drag            : me.onDrag,\n                    drop            : me.onDrop,\n                    thisObj         : me\n                }\n            });\n\n            me.relayEvents(me.dragHelper, ['dragStart', 'drag', 'drop', 'abort'], 'gridHeader');\n        }\n    }\n\n    //endregion\n\n    //region Plugin config\n\n    // Plugin configuration. This plugin chains some of the functions in Grid\n    static get pluginConfig() {\n        return {\n            after : ['onPaint', 'renderContents']\n        };\n    }\n\n    //endregion\n\n    //region Events (drop)\n\n    onDrag({ context, event }) {\n        const\n            me           = this,\n            targetHeader = Widget.fromElement(event.target, 'gridheader');\n\n        // If SubGrid is configured with a sealed column set, do not allow moving into it\n        if (targetHeader?.subGrid.sealedColumns) {\n            context.valid = false;\n            return;\n        }\n\n        // Require that we drag inside grid header while dragging if we don't have a drag toolbar\n        if (!me.grid.features.columnDragToolbar) {\n            context.valid = Boolean(event.target.closest('.b-grid-headers'));\n        }\n    }\n\n    onBeforeDragStart({ context, event }) {\n        const\n            { element } = context,\n            column      = context.column = this.client.columns.getById(element.dataset.columnId);\n\n        /**\n         * This event is fired prior to starting a column drag gesture. The drag is canceled if a listener returns `false`.\n         * @on-owner\n         * @event beforeColumnDragStart\n         * @param {Grid.view.Grid} source The grid instance.\n         * @param {Grid.column.Column} column The dragged column.\n         * @param {Event} event The browser event.\n         * @preventable\n         */\n        return this.client.trigger('beforeColumnDragStart', { column, event });\n    }\n\n    onDragStart({ context, event }) {\n        const\n            me         = this,\n            { grid }   = me,\n            { column } = context;\n\n        if (!grid.features.columnDragToolbar) {\n            const headerContainerBox = grid.element.querySelector('.b-grid-header-container').getBoundingClientRect();\n\n            me.dragHelper.minY = headerContainerBox.top;\n            me.dragHelper.maxY = headerContainerBox.bottom;\n        }\n\n        grid.headerContainer.classList.add('b-dragging-header');\n\n        context.dragProxy.style.fontSize = DomHelper.getStyleValue(context.element, 'fontSize');\n\n        /**\n         * This event is fired when a column drag gesture has started.\n         * @on-owner\n         * @event columnDragStart\n         * @param {Grid.view.Grid} source The grid instance.\n         * @param {Grid.column.Column} column The dragged column.\n         * @param {Event} event The browser event.\n         */\n        grid.trigger('columnDragStart', { column, event });\n    }\n\n    /**\n     * Handle drop\n     * @private\n     */\n    onDrop({ context, event }) {\n        if (!context.valid) {\n            return this.onInvalidDrop({ context });\n        }\n\n        const\n            me              = this,\n            { grid }        = me,\n            element         = context.dragging,\n            onHeader        = context.target.closest('.b-grid-header'),\n            droppedInRegion = context.draggedTo.dataset.region,\n            // If dropping on right edge of grid-headers element, append to that subgrid\n            onColumn        = onHeader ? grid.columns.get(onHeader.dataset.column) : grid.subGrids[droppedInRegion].columns.last,\n            toRegion        = droppedInRegion || onColumn.region,\n            sibling         = context.insertBefore,\n            column          = grid.columns.getById(element.dataset.columnId),\n            oldParent       = column.parent,\n            insertBefore    = sibling ? grid.columns.getById(sibling.dataset.columnId) : grid.subGrids[toRegion].columns.last.nextSibling;\n\n        let newParent;\n\n        if (insertBefore) {\n            newParent = insertBefore.parent;\n        }\n        else {\n            const groupNode = onHeader?.parentElement.closest('.b-grid-header');\n\n            if (groupNode) {\n                newParent = grid.columns.getById(groupNode.dataset.columnId);\n            }\n            else {\n                newParent = grid.columns.rootNode;\n            }\n        }\n\n        grid.headerContainer.classList.remove('b-dragging-header');\n\n        // Clean up element used during drag drop as it will not be removed by Grid when it refreshes its header elements\n        element.remove();\n\n        // If dropped into its current position in the same SubGrid - abort\n        let vetoed = (toRegion === column.region && oldParent === newParent && (onColumn === column.previousSibling || insertBefore === column.nextSibling));\n\n        /**\n         * This event is fired when a column is dropped, and you can return false from a listener to abort the operation.\n         * @event beforeColumnDropFinalize\n         * @on-owner\n         * @param {Grid.view.Grid} source The grid instance.\n         * @param {Grid.column.Column} column The dragged column.\n         * @param {Grid.column.Column} insertBefore The column before which the dragged column will be inserted.\n         * @param {Grid.column.Column} newParent The new parent column.\n         * @param {Event} event The browser event.\n         * @preventable\n         */\n        vetoed = vetoed || grid.trigger('beforeColumnDropFinalize', {\n            column, newParent, insertBefore, event\n        }) === false;\n\n        if (!vetoed) {\n            // Insert the column into its new place, which might be vetoed if column is sealed\n            vetoed = !newParent.insertChild(column, insertBefore);\n        }\n\n        context.valid = !vetoed;\n\n        if (!vetoed) {\n            column.region = toRegion;\n\n            // Check if we should remove last child\n            if (oldParent.children.length === 0) {\n                oldParent.parent.removeChild(oldParent);\n            }\n        }\n\n        /**\n         * This event is always fired after a column is dropped. The `valid` param is true if the operation was not\n         * vetoed and the column was moved in the column store.\n         * @event columnDrop\n         * @on-owner\n         * @param {Grid.view.Grid} source The grid instance.\n         * @param {Grid.column.Column} column The dragged column.\n         * @param {Grid.column.Column} insertBefore The column before which the the dragged column will be inserted.\n         * @param {Grid.column.Column} newParent The new parent column.\n         * @param {Boolean} valid true if the operation was not vetoed.\n         * @param {Event} event The browser event.\n         * @preventable\n         */\n        grid.trigger('columnDrop', { column, newParent, insertBefore, valid : context.valid, event });\n    }\n\n    /**\n     * Handle invalid drop\n     * @private\n     */\n    onInvalidDrop() {\n        this.grid.headerContainer.classList.remove('b-dragging-header');\n    }\n\n    //endregion\n\n    //region Render\n\n    /**\n     * Updates DragHelper with updated headers when grid contents is rerendered\n     * @private\n     */\n    renderContents() {\n        // columns shown, hidden or reordered\n        this.init();\n    }\n\n    /**\n     * Initializes this feature on grid paint.\n     * @private\n     */\n    onPaint() {\n        // always reinit on paint\n        this.init();\n    }\n\n    //endregion\n}\n\nColumnReorder.featureClass = 'b-column-reorder';\n\nGridFeatureManager.registerFeature(ColumnReorder, true);\n","import ResizeHelper from '../../Core/helper/ResizeHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\n\n/**\n * @module Grid/feature/ColumnResize\n */\n\n/**\n * Enables user to resize columns by dragging a handle on the right hand side of the header. To get notified about column\n * resize listen to `change` event on {@link Grid.data.ColumnStore columns} store.\n *\n * This feature is <strong>enabled</strong> by default.\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @demo Grid/columns\n * @classtype columnResize\n * @inlineexample Grid/feature/ColumnResize.js\n * @feature\n */\nexport default class ColumnResize extends InstancePlugin {\n\n    static get $name() {\n        return 'ColumnResize';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Resize all cells below a resizing header during dragging.\n             * `'auto'` means `true` on non-mobile platforms.\n             * @config {String|Boolean}\n             * @default\n             */\n            liveResize : 'auto'\n        };\n    }\n\n    //region Init\n\n    construct(grid, config) {\n        const me = this;\n\n        me.grid = grid;\n\n        super.construct(grid, config);\n\n        me.resizer = new ResizeHelper({\n            name              : 'columnResize',\n            targetSelector    : '.b-grid-header',\n            handleSelector    : '.b-grid-header-resize-handle',\n            outerElement      : grid.element,\n            rtlSource         : grid,\n            internalListeners : {\n                beforeresizestart : me.onBeforeResizeStart,\n                resizestart       : me.onResizeStart,\n                resizing          : me.onResizing,\n                resize            : me.onResize,\n                cancel            : me.onCancel,\n                thisObj           : me\n            }\n        });\n    }\n\n    doDestroy() {\n        this.resizer?.destroy();\n        super.doDestroy();\n    }\n\n    //endregion\n\n    changeLiveResize(liveResize) {\n        if (liveResize === 'auto') {\n            return !BrowserHelper.isMobileSafari;\n        }\n        return liveResize;\n    }\n\n    //region Events\n\n    onBeforeResizeStart() {\n        return !this.disabled;\n    }\n\n    onResizeStart({ context }) {\n        const\n            { grid, resizer } = this,\n            column            = context.column = grid.columns.getById(context.element.dataset.columnId);\n\n        resizer.minWidth = column.minWidth;\n\n        grid.element.classList.add('b-column-resizing');\n    }\n\n    /**\n     * Handle drag event - resize the column live unless it's a touch gesture\n     * @private\n     */\n    onResizing({ context }) {\n        if (context.valid && this.liveResize) {\n            this.grid.resizingColumns = true;\n            context.column.width = context.newWidth;\n        }\n    }\n\n    /**\n     * Handle drop event (only used for touch)\n     * @private\n     */\n    onResize({ context }) {\n        const\n            { grid } = this,\n            { column } = context;\n\n        grid.element.classList.remove('b-column-resizing');\n\n        if (context.valid) {\n            if (this.liveResize) {\n                grid.resizingColumns = false;\n                grid.afterColumnsResized(column);\n            }\n            else {\n                column.width = context.newWidth;\n            }\n        }\n    }\n\n    /**\n     * Restore column width on cancel (ESC)\n     * @private\n     */\n    onCancel({ context }) {\n        const { grid } = this;\n\n        grid.element.classList.remove('b-column-resizing');\n\n        context.column.width = context.elementWidth;\n        grid.resizingColumns = false;\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(ColumnResize, true);\n","import FieldFilterPicker, { SUPPORTED_FIELD_DATA_TYPES, isSupportedDurationField } from '../../Core/widget/FieldFilterPicker.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Model from '../../Core/data/Model.js';\nimport '../../Core/widget/Combo.js';\nimport '../../Core/widget/Checkbox.js';\nimport '../../Core/widget/NumberField.js';\nimport '../../Core/widget/TextField.js';\nimport '../../Core/widget/DateField.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\n\n/**\n * @module Grid/widget/GridFieldFilterPicker\n */\n\n/**\n * Subclass of {@link Core.widget.FieldFilterPicker} allowing configuration using an\n * existing {@link Grid.view.Grid}.\n *\n * See also {@link Grid.widget.GridFieldFilterPickerGroup}.\n *\n * @extends Core/widget/FieldFilterPicker\n * @classtype gridfieldfilterpicker\n * @demo Grid/fieldfilters\n * @widget\n */\nexport default class GridFieldFilterPicker extends FieldFilterPicker {\n\n    //region Config\n    static get $name() {\n        return 'GridFieldFilterPicker';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'gridfieldfilterpicker';\n    }\n\n    /** @hideconfigs store */\n\n    static configurable = {\n        /**\n         * {@link Grid.view.Grid} from which to read the available field list. In order to\n         * appear as a selectable property for a filter, a column must have a `field` property.\n         * If the column has a `text` property, that will be shown as the displayed text in the\n         * selector; otherwise, the `field` property will be shown as-is.\n         *\n         * The grid's {@link Core.data.Store}'s {@link Core.data.Store#property-modelClass} will be\n         * examined to find field data types.\n         *\n         * You can limit available fields to a subset of the grid's columns using the\n         * {@link #config-allowedFieldNames} configuration property.\n         *\n         * @config {Grid.view.Grid}\n         */\n        grid : null,\n\n        /**\n         * Optional array of field names that are allowed as selectable properties for filters.\n         * This is a subset of the field names found in the {@link #config-grid}'s columns. When supplied, only\n         * the named fields will be shown in the property selector combo.\n         *\n         * Note that field names are case-sensitive and should match the data field name in the store\n         * model.\n         *\n         * @config {String[]}\n         */\n        allowedFieldNames : null\n    };\n\n    //endregion\n\n    afterConstruct() {\n        const\n            me = this;\n        if (!me.grid) {\n            throw new Error(`${me.constructor.$name} requires 'grid' to be configured.`);\n        }\n        me.fields = me.fields ?? {};  // Force `fields` changer if fields is left null, to merge w/ grid fields\n        super.afterConstruct();\n    }\n\n    updateGrid(newGrid) {\n        if (!newGrid.store?.modelClass) {\n            throw new Error(`Grid does not have a store with a modelClass defined.`);\n        }\n        if (!newGrid.columns) {\n            throw new Error(`Grid does not have a column store.`);\n        }\n    }\n\n    /**\n     * Returns a subset of the fields defined on the model class, excluding those considered internal or otherwise not\n     * suitable for user-facing filtering.\n     * @param {Core.data.Model} modelClass The Model subclass whose fields will be read\n     * @returns {Core.data.field.DataField[]}\n     * @private\n     */\n    static getModelClassFields(modelClass) {\n        const ownFieldNames = new Set(modelClass.fields.map(({ name }) => name));\n        return modelClass?.allFields\n            .filter(field =>\n                !field.internal &&\n                (\n                    SUPPORTED_FIELD_DATA_TYPES.includes(field.type) ||\n                    isSupportedDurationField(field)\n                ) &&\n                (field.definedBy !== Model || ownFieldNames.has(field.name))\n            ) || [];\n    }\n\n    /**\n     * Gets the filterable fields backing any of the configured `grid`'s columns, for those columns for which\n     * it is possible to do so.\n     * @private\n     * @returns {Object} Filterable fields dictionary of the form { [fieldName]: { title, type } }\n     */\n    static getColumnFields(columnStore, modelClass, allowedFieldNames) {\n        const\n            modelFields = ArrayHelper.keyBy(GridFieldFilterPicker.getModelClassFields(modelClass), 'name'),\n            allowedNameSet = allowedFieldNames && new Set(allowedFieldNames);\n        return Object.fromEntries(\n            columnStore?.records\n                .filter(({ field }) => field &&\n                    modelFields[field] &&\n                    (!allowedNameSet || allowedNameSet.has(field)))\n                .map(({ field, text }) => [\n                    field,\n                    {\n                        title : text || field,\n                        type  : isSupportedDurationField(modelFields[field]) ? 'duration' : modelFields[field].type\n                    }\n                ]) ??\n            []);\n    }\n\n    changeFields(newFields) {\n        let localFields = newFields;\n        if (Array.isArray(newFields)) {\n            VersionHelper.deprecate('Core', '6.0.0', 'FieldOption[] deprecated, use Object<String, FieldOption[]> keyed by field name instead');\n            // Support old array syntax for `fields` during deprecation\n            localFields = ArrayHelper.keyBy(localFields, 'name');\n        }\n        return ObjectHelper.merge(\n            {},\n            GridFieldFilterPicker.getColumnFields(this.grid.columns,\n                this.grid.store?.modelClass, this.allowedFieldNames),\n            localFields\n        );\n    }\n}\n\nGridFieldFilterPicker.initClass();\n","import FieldFilterPickerGroup from '../../Core/widget/FieldFilterPickerGroup.js';\nimport './GridFieldFilterPicker.js';\nimport '../../Core/widget/Checkbox.js';\nimport '../../Core/widget/Label.js';\n\n/**\n * @module Grid/widget/GridFieldFilterPickerGroup\n */\n\n/**\n * Extends {@link Core.widget.FieldFilterPickerGroup} to allow providing a {@link Grid.view.Grid} from which\n * available fields will be read. This is useful when a grid is already configured with a set of columns\n * containing display names and type information.\n *\n * The grid should have a {@link Grid.data.ColumnStore} configured (see {@link Grid.view.Grid#config-columns})\n * and a {@link Core.data.Store} whose {@link Core.data.Store#property-modelClass} contains fields with\n * specific data types.\n *\n * Optionally, you can also use {@link #config-allowedFieldNames} to restrict the set of fields shown in the\n * widget.\n *\n * For example:\n *\n * ```javascript\n * new GridFieldFilterPickerGroup({\n *     appendTo : domElement,\n *\n *     grid : myGrid,\n *\n *     filters : [{\n *         property : 'startDate',\n *         operator : '<=',\n *         value    : new Date()\n *     }]\n * });\n * ```\n *\n * @classtype gridfieldfilterpickergroup\n * @extends Core/widget/FieldFilterPickerGroup\n * @demo Grid/fieldfilters\n * @widget\n */\nexport default class GridFieldFilterPickerGroup extends FieldFilterPickerGroup {\n    //region Config\n    static get $name() {\n        return 'GridFieldFilterPickerGroup';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'gridfieldfilterpickergroup';\n    }\n\n    /** @hideconfigs fields, store */\n\n    static configurable = {\n        /**\n         * {@link Grid.view.Grid} from which to read the available field list. In order to\n         * appear as a selectable property for a filter, a column must have a `field` property.\n         * If the column has a `text` property, that will be shown as the displayed text in the\n         * selector; otherwise, the `field` property will be shown as-is.\n         *\n         * The grid's {@link Core.data.Store}'s {@link Core.data.Store#property-modelClass} will be\n         * examined to find field data types.\n         *\n         * You can limit available fields to a subset of the grid's columns using the\n         * {@link #config-allowedFieldNames} configuration property.\n         *\n         * @config {Grid.view.Grid}\n         */\n        grid : null,\n\n        /**\n         * Optional array of field names that are allowed as selectable properties for filters.\n         * This should be a subset of the field names found in the {@link #config-grid}'s store. When supplied,\n         * only the named fields will be shown in the property selector combo.\n         *\n         * @config {String[]}\n         */\n        allowedFieldNames : null\n    };\n\n    //endregion\n\n    static childPickerType = 'gridfieldfilterpicker';\n\n    validateConfig() {\n        if (!this.grid) {\n            throw new Error(`${this.constructor.$name} requires the 'grid' config property.`);\n        }\n    }\n\n    getFilterPickerConfig(filter) {\n        const { grid, allowedFieldNames } = this;\n        return {\n            ...super.getFilterPickerConfig(filter),\n            grid,\n            allowedFieldNames\n        };\n    }\n\n    updateGrid(newGrid) {\n        this.store = this.grid.store;\n    }\n\n    /**\n     * @private\n     */\n    canManage(filter) {\n        const me = this;\n        return super.canManage(filter) && (!me.allowedFieldNames || me.allowedFieldNames.includes(filter.property));\n    }\n\n}\n\nGridFieldFilterPickerGroup.initClass();\n","//TODO: Format value in header filter tooltip (see date)\n\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport WidgetHelper from '../../Core/helper/WidgetHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport CollectionFilter from '../../Core/util/CollectionFilter.js';\nimport '../../Core/widget/NumberField.js';\nimport '../../Core/widget/Combo.js';\nimport '../../Core/widget/DateField.js';\nimport '../../Core/widget/TimeField.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport '../widget/GridFieldFilterPickerGroup.js';\n\n/**\n * @module Grid/feature/Filter\n */\n\nexport const fieldTypeMap = {\n    date     : 'date',\n    int      : 'number',\n    integer  : 'number',\n    number   : 'number',\n    string   : 'text',\n    duration : 'duration'\n};\n\n/**\n * Feature that allows filtering of the grid by settings filters on columns. The actual filtering is done by the store.\n * For info on programmatically handling filters, see {@link Core.data.mixin.StoreFilter}.\n *\n * {@inlineexample Grid/feature/Filter.js}\n *\n * ```javascript\n * // Filtering turned on but no default filter\n * const grid = new Grid({\n *   features : {\n *     filter : true\n *   }\n * });\n *\n * // Using default filter\n * const grid = new Grid({\n *   features : {\n *     filter : { property : 'city', value : 'Gavle' }\n *   }\n * });\n * ```\n *\n * A column can supply a custom filtering function as its {@link Grid.column.Column#config-filterable} config. When\n * filtering by that column using the UI that function will be used to determine which records to include. See\n * {@link Grid.column.Column#config-filterable Column#filterable} for more information.\n *\n * ```javascript\n * // Custom filtering function for a column\n * const grid = new Grid({\n *    features : {\n *        filter : true\n *    },\n *\n *    columns: [\n *        {\n *          field      : 'age',\n *          text       : 'Age',\n *          type       : 'number',\n *          // Custom filtering function that checks \"greater than\" no matter\n *          // which field user filled in :)\n *          filterable : ({ record, value, operator }) => record.age > value\n *        }\n *    ]\n * });\n * ```\n *\n * If this feature is configured with `prioritizeColumns : true`, those functions will also be used when filtering\n * programmatically:\n *\n * ```javascript\n * const grid = new Grid({\n *    features : {\n *        filter : {\n *            prioritizeColumns : true\n *        }\n *    },\n *\n *    columns: [\n *        {\n *          field      : 'age',\n *          text       : 'Age',\n *          type       : 'number',\n *          filterable : ({ record, value, operator }) => record.age > value\n *        }\n *    ]\n * });\n *\n * // Because of the prioritizeColumns config above, any custom filterable function\n * // on a column will be used when programmatically filtering by that columns field\n * grid.store.filter({\n *     property : 'age',\n *     value    : 41\n * });\n * ```\n *\n * You can supply a field config to use for the filtering field displayed for string type columns:\n *\n * ```javascript\n * // For string-type columns you can also replace the filter UI with a custom field:\n * columns: [\n *     {\n *         field : 'city',\n *         // Filtering for a value out of a list of values\n *         filterable: {\n *             filterField : {\n *                 type  : 'combo',\n *                 items : [\n *                     'Paris',\n *                     'Dubai',\n *                     'Moscow',\n *                     'London',\n *                     'New York'\n *                 ]\n *             }\n *         }\n *     }\n * ]\n * ```\n *\n * You can also change default fields, for example this will use {@link Core.widget.DateTimeField} in filter popup:\n * ```javascript\n * columns : [\n *     {\n *         type       : 'date',\n *         field      : 'start',\n *         filterable : {\n *             filterField : {\n *                 type : 'datetime'\n *             }\n *         }\n *     }\n * ]\n * ```\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * **Note:** This feature cannot be used together with {@link Grid.feature.FilterBar} feature, they are\n * mutually exclusive.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys   | Action                  | Action description                                                     |\n * |--------|-------------------------|------------------------------------------------------------------------|\n * | F      | showFilterEditorByKey   | When the column header is focused, this shows the filter input field   |\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md).\n *\n * To enable an alternative UI that uses {@link Core.widget.FieldFilterPickerGroup} to allow\n * specifying multiple filters on the column at once, set `isMulti` to `true`.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/filtering\n * @classtype filter\n * @feature\n */\nexport default class Filter extends InstancePlugin {\n    //region Init\n\n    static get $name() {\n        return 'Filter';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Use custom filtering functions defined on columns also when programmatically filtering by the columns\n             * field.\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     columns : [\n             *         {\n             *             field : 'age',\n             *             text : 'Age',\n             *             filterable({ record, value }) {\n             *               // Custom filtering, return true/false\n             *             }\n             *         }\n             *     ],\n             *\n             *     features : {\n             *         filter : {\n             *             prioritizeColumns : true // <--\n             *         }\n             *     }\n             * });\n             *\n             * // Because of the prioritizeColumns config above, any custom\n             * // filterable function on a column will be used when\n             * // programmatically filtering by that columns field\n             * grid.store.filter({\n             *     property : 'age',\n             *     value    : 30\n             * });\n             * ```\n             *\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            prioritizeColumns : false,\n\n            /**\n             * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n             * @config {Object<String,String>}\n             */\n            keyMap : {\n                f : 'showFilterEditorByKey'\n            },\n\n            /**\n             * Use {@link Grid.widget.GridFieldFilterPickerGroup} instead of the normal UI,\n             * enabling multiple filters for the same column. To enable the multi-filter UI,\n             * set `isMulti` to either `true` or a {@link Grid.widget.GridFieldFilterPickerGroup}\n             * configuration object.\n             *\n             * @config {Boolean|GridFieldFilterPickerGroupConfig}\n             * @default\n             * @category Common\n             */\n            isMulti : false\n        };\n    }\n\n    construct(grid, config) {\n        if (grid.features.filterBar) {\n            throw new Error('Grid.feature.Filter feature may not be used together with Grid.feature.FilterBar. These features are mutually exclusive.');\n        }\n\n        const me = this;\n\n        me.grid = grid;\n        me.closeFilterEditor = me.closeFilterEditor.bind(me);\n\n        super.construct(grid, config);\n\n        me.bindStore(grid.store);\n\n        if (config && typeof config === 'object') {\n            const clone = ObjectHelper.clone(config);\n\n            // Feature accepts a filter config object, need to remove this config\n            delete clone.prioritizeColumns;\n            delete clone.isMulti;\n            delete clone.dateFormat;\n\n            if (!ObjectHelper.isEmpty(clone)) {\n                grid.store.filter(clone, null, grid.isConfiguring);\n            }\n        }\n    }\n\n    doDestroy() {\n        this.filterTip?.destroy();\n        this.filterEditorPopup?.destroy();\n\n        super.doDestroy();\n    }\n\n    get store() {\n        return this.grid.store;\n    }\n\n    bindStore(store) {\n        this.detachListeners('store');\n\n        store.ion({\n            name         : 'store',\n            beforeFilter : 'onStoreBeforeFilter',\n            filter       : 'onStoreFilter',\n            thisObj      : this\n        });\n    }\n\n    //endregion\n\n    //region Plugin config\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['renderHeader', 'populateCellMenu', 'populateHeaderMenu', 'onElementClick', 'bindStore']\n        };\n    }\n\n    //endregion\n\n    //region Refresh headers\n\n    /**\n     * Update headers to match stores filters. Called on store load and grid header render.\n     * @param reRenderRows Also refresh rows?\n     * @private\n     */\n    refreshHeaders(reRenderRows) {\n        const\n            me      = this,\n            grid    = me.grid,\n            element = grid.headerContainer;\n\n        if (element) {\n            // remove .latest from all filters, will be applied to actual latest\n            DomHelper.children(element, '.b-filter-icon.b-latest').forEach(iconElement => iconElement.classList.remove('b-latest'));\n\n            if (!me.filterTip) {\n                me.filterTip = new Tooltip({\n                    forElement  : element,\n                    forSelector : '.b-filter-icon',\n                    getHtml({ activeTarget }) {\n                        return activeTarget.dataset.filterText;\n                    }\n                });\n            }\n\n            if (!grid.store.isFiltered) {\n                me.filterTip.hide();\n            }\n\n            grid.columns.visibleColumns.forEach(column => {\n                if (column.filterable !== false) {\n                    const\n                        columnFilters    = me.store.filters.allValues.filter(({ property, disabled, internal }) =>\n                            property === column.field && !disabled && !internal),\n                        isColumnFiltered = columnFilters.length > 0,\n                        headerEl = column.element;\n\n                    if (headerEl) {\n                        const textEl = column.textWrapper;\n\n                        let filterIconEl = textEl?.querySelector('.b-filter-icon'),\n                            filterText;\n\n                        if (isColumnFiltered) {\n                            const bullet = '&#x2022 ';\n                            filterText = `${me.L('L{filter}')}: ` +\n                                (columnFilters.length > 1 ? '<br/><br/>' : '') +\n                                columnFilters.map(columnFilter => {\n                                    let value = columnFilter.value ?? '';\n                                    const\n                                        isArray = Array.isArray(value),\n                                        relation = me.store?.modelRelations?.find(\n                                            ({ foreignKey }) => foreignKey === columnFilter.property);\n\n                                    if (columnFilter.displayValue) {\n                                        value = columnFilter.displayValue;\n                                    }\n                                    else {\n                                        if (me.isMulti && relation) {\n                                            // Look up remote display value per filterable-field config (FieldFilterPicker.js#FieldOption)\n                                            const { relatedDisplayField } = me.isMulti.fields?.[columnFilter.property];\n                                            if (relatedDisplayField) {\n                                                const getDisplayValue = foreignId => relation.foreignStore.getById(foreignId)?.[relatedDisplayField];\n                                                if (isArray) {\n                                                    value = value[relatedDisplayField]\n                                                        .sort((a, b) => (a ?? '').localeCompare(b ?? ''));\n                                                }\n                                                else {\n                                                    value = getDisplayValue(value);\n                                                }\n                                            }\n                                        }\n                                        else if (column.formatValue && value) {\n                                            value = isArray\n                                                ? value.map(val => column.formatValue(val))\n                                                : column.formatValue(value);\n                                        }\n\n                                        if (isArray) {\n                                            value = `[ ${value.join(', ')} ]`;\n                                        }\n                                    }\n\n                                    return (columnFilters.length > 1 ? bullet : '') +\n                                        (typeof columnFilter === 'string'\n                                            ? columnFilter\n                                            : `${columnFilter.operator} ${value}`);\n                                }).join('<br/><br/>');\n                        }\n                        else {\n                            filterText = me.L('L{applyFilter}');\n                        }\n\n                        if (!filterIconEl) {\n                            // putting icon in header text to have more options for positioning it\n                            filterIconEl = DomHelper.createElement({\n                                parent    : textEl,\n                                tag       : 'div',\n                                className : 'b-filter-icon',\n                                dataset   : {\n                                    filterText\n                                }\n                            });\n                        }\n                        else {\n                            filterIconEl.dataset.filterText = filterText;\n                        }\n\n                        // latest applied filter distinguished with class to enable highlighting etc.\n                        if (column.field === me.store.latestFilterField) filterIconEl.classList.add('b-latest');\n\n                        headerEl.classList.add('b-filterable');\n                        headerEl.classList.toggle('b-filter', isColumnFiltered);\n                    }\n\n                    column.meta.isFiltered = isColumnFiltered;\n                }\n            });\n\n            if (reRenderRows) {\n                grid.refreshRows();\n            }\n        }\n    }\n\n    //endregion\n\n    //region Filter\n\n    applyFilter(column, config) {\n        const\n            { store }    = this,\n            { filterFn } = column.filterable;\n\n        // Must add the filter silently, so that the column gets a reference to its $filter\n        // before the filter happens and events are broadcast.\n        column.$filter = store.addFilter({\n            ...column.filterable,\n            ...config,\n            property : column.field,\n\n            // Only inject a filterBy configuration if the column has a custom filterBy\n            [filterFn ? 'filterBy' : '_'] : function(record) {\n                return filterFn({ value : this.value, record, operator : this.operator, property : this.property, column });\n            }\n        }, true);\n\n        // Apply the new set of store filters.\n        store.filter();\n    }\n\n    removeFilter(column) {\n        if (this.isMulti) {\n            for (const filter of this.getCurrentMultiFilters(column)) {\n                this.store.removeFilter(filter);\n            }\n        }\n        else {\n            this.store.removeFilter(column.field);\n        }\n    }\n\n    disableFilter(column) {\n        for (const filter of this.getCurrentMultiFilters(column)) {\n            filter.disabled = true;\n            this.store.filter(filter);\n        }\n        this.store.filter();\n    }\n\n    getCurrentMultiFilters(column) {\n        return this.store.filters.values.filter(filter => filter.property === column.field);\n    }\n\n    // TODO: break out as own views, registering with Filter the same way columns register with ColumnManager\n\n    getPopupDateItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {\n        const\n            me      = this,\n            onClose = changeCallback;\n\n        function onClear() {\n            me.removeFilter(column);\n        }\n\n        function onKeydown({ event }) {\n            if (event.key === 'Enter') {\n                changeCallback();\n            }\n        }\n\n        function onChange({ source, value }) {\n            if (value == null) {\n                onClear();\n            }\n            else {\n                me.clearSiblingsFields(source);\n                me.applyFilter(column, { operator : source.operator, value, displayValue : source._value, type : 'date' });\n            }\n        }\n\n        return [\n            ObjectHelper.assign({\n                type        : 'date',\n                ref         : 'on',\n                placeholder : 'L{on}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-equal\"></i>',\n                value       : filter?.operator === 'sameDay' ? filter.value : initialValue,\n                operator    : 'sameDay',\n                onKeydown,\n                onChange,\n                onClose,\n                onClear\n            }, filterField),\n            ObjectHelper.assign({\n                type        : 'date',\n                ref         : 'before',\n                placeholder : 'L{before}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-before\"></i>',\n                value       : filter?.operator === '<' ? filter.value : null,\n                operator    : '<',\n                onKeydown,\n                onChange,\n                onClose,\n                onClear\n            }, filterField),\n            ObjectHelper.assign({\n                type        : 'date',\n                ref         : 'after',\n                cls         : 'b-last-row',\n                placeholder : 'L{after}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-after\"></i>',\n                value       : filter?.operator === '>' ? filter.value : null,\n                operator    : '>',\n                onKeydown,\n                onChange,\n                onClose,\n                onClear\n            }, filterField)\n        ];\n    }\n\n    getPopupNumberItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {\n        const\n            me    = this,\n            onEsc = changeCallback;\n\n        function onClear() {\n            me.removeFilter(column);\n        }\n\n        function onKeydown({ event }) {\n            if (event.key === 'Enter') {\n                changeCallback();\n            }\n        }\n\n        function onChange({ source, value }) {\n            if (value == null) {\n                onClear();\n            }\n            else {\n                me.clearSiblingsFields(source);\n                me.applyFilter(column, { operator : source.operator, value });\n            }\n        }\n\n        return [\n            ObjectHelper.assign({\n                type        : 'number',\n                placeholder : 'L{Filter.equals}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-equal\"></i>',\n                value       : filter?.operator === '=' ? filter.value : initialValue,\n                operator    : '=',\n                onKeydown,\n                onChange,\n                onEsc,\n                onClear\n            }, filterField),\n            ObjectHelper.assign({\n                type        : 'number',\n                placeholder : 'L{lessThan}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-less\"></i>',\n                value       : filter?.operator === '<' ? filter.value : null,\n                operator    : '<',\n                onKeydown,\n                onChange,\n                onEsc,\n                onClear\n            }, filterField),\n            ObjectHelper.assign({\n                type        : 'number',\n                cls         : 'b-last-row',\n                placeholder : 'L{moreThan}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-more\"></i>',\n                value       : filter?.operator === '>' ? filter.value : null,\n                operator    : '>',\n                onKeydown,\n                onChange,\n                onEsc,\n                onClear\n            }, filterField)\n        ];\n    }\n\n    clearSiblingsFields(sourceField) {\n        // TODO: Store filtering allows multiple filters per field (for example age > 50 and age < 80),\n        // but the Filter feature only handles a single filter per field.\n        // For now, trying to add filter by age > and then for age <,\n        // it should clear the previous field since that filter is replaced\n        this.filterEditorPopup?.items.forEach(field => {\n            field !== sourceField && field?.clear();\n        });\n    }\n\n    getPopupDurationItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {\n        const\n            me      = this,\n            onEsc   = changeCallback,\n            onClear = () => me.removeFilter(column);\n\n        me.removeFilter(column);\n\n        function onChange({ source, value }) {\n            me.clearSiblingsFields(source);\n            me.applyFilter(column, { operator : source.operator, value : value });\n        }\n\n        return [\n            ObjectHelper.assign({\n                type        : 'duration',\n                placeholder : 'L{Filter.equals}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-equal\"></i>',\n                value       : filter?.operator === '=' ? filter.value : initialValue,\n                operator    : '=',\n                onChange,\n                onEsc,\n                onClear\n            }, filterField),\n            ObjectHelper.assign({\n                type        : 'duration',\n                placeholder : 'L{lessThan}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-less\"></i>',\n                value       : filter?.operator === '<' ? filter.value : null,\n                operator    : '<',\n                onChange,\n                onEsc,\n                onClear\n            }, filterField),\n            ObjectHelper.assign({\n                type        : 'duration',\n                cls         : 'b-last-row',\n                placeholder : 'L{moreThan}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-more\"></i>',\n                value       : filter?.operator === '>' ? filter.value : null,\n                operator    : '>',\n                onChange,\n                onEsc,\n                onClear\n            }, filterField)\n        ];\n    }\n\n    getPopupStringItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {\n        const me = this;\n\n        return [ObjectHelper.assign({\n            type        : fieldType,\n            cls         : 'b-last-row',\n            placeholder : 'L{filter}',\n            localeClass : me,\n            clearable   : true,\n            label       : '<i class=\"b-fw-icon b-icon-filter-equal\"></i>',\n            value       : filter ? filter.value || filter : initialValue,\n            operator    : '*',\n            onChange({ source, value }) {\n                if (value === '') {\n                    closeCallback();\n                }\n                else {\n                    me.applyFilter(column, { operator : source.operator, value, displayValue : source.displayField && source.records ? source.records.map(rec => rec[source.displayField]).join(', ') : undefined });\n                    // Leave multiselect filter combo visible to be able to select many items at once\n                    if (!source.multiSelect) {\n                        changeCallback();\n                    }\n                }\n            },\n            onClose : changeCallback,\n            onClear : closeCallback\n        }, filterField)];\n    }\n\n    /**\n     * Get fields to display in filter popup.\n     * @param {Grid.column.Column} column Column\n     * @param fieldType Type of field, number, date etc.\n     * @param filter Current filter filter\n     * @param initialValue\n     * @param store Grid store\n     * @param changeCallback Callback for when filter has changed\n     * @param closeCallback Callback for when editor should be closed\n     * @param filterField filter field\n     * @returns {*}\n     * @private\n     */\n    getPopupItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {\n        const me = this;\n        if (me.isMulti) {\n            return me.getMultiFilterPopupItems(...arguments);\n        }\n        switch (fieldType) {\n            case 'date':\n                return me.getPopupDateItems(...arguments);\n            case 'number':\n                return me.getPopupNumberItems(...arguments);\n            case 'duration':\n                return me.getPopupDurationItems(...arguments);\n            default:\n                return me.getPopupStringItems(...arguments);\n        }\n    }\n\n    getMultiFilterPopupItems(column) {\n        const\n            { grid, isMulti } = this,\n            existingFilter = grid.store?.filters.find(filter => filter.property === column.field);\n        return [{\n            ...(typeof isMulti === 'object' ? isMulti : undefined),\n            type            : 'gridfieldfilterpickergroup',\n            ref             : 'pickerGroup',\n            limitToProperty : column.field,\n            grid,\n            filters         : existingFilter ? [] : [{\n                property : column.field\n            }],\n            propertyFieldCls : 'b-transparent property-field',\n            operatorFieldCls : 'b-transparent operator-field',\n            valueFieldCls    : 'b-transparent value-field',\n            width            : '400px'\n        }];\n    }\n\n    /**\n     * Shows a popup where a filter can be edited.\n     * @param {Grid.column.Column|String} column Column to show filter editor for\n     * @param {*} [value] The initial value of the filter field\n     */\n    showFilterEditor(column, value) {\n        column = this.grid.columns.getById(column);\n\n        const\n            me        = this,\n            { store, isMulti } = me,\n            headerEl  = column.element,\n            filter    = store.filters.getBy('property', column.field),\n            fieldType = me.getFilterType(column);\n\n        if (column.filterable === false) {\n            return;\n        }\n\n        // Destroy previous filter popup\n        me.closeFilterEditor();\n\n        const items = me.getPopupItems(\n            column,\n            fieldType,\n\n            // Only pass filter if it's not an internal filter\n            filter?.internal ? null : filter,\n\n            value,\n            store,\n            me.closeFilterEditor,\n            () => {\n                me.removeFilter(column);\n                me.closeFilterEditor();\n            },\n            column.filterable.filterField,\n            isMulti\n        );\n\n        // Localize placeholders\n        items.forEach(item => item.placeholder = item.placeholder ? this.L(item.placeholder) : item.placeholder);\n\n        me.filterEditorPopup = WidgetHelper.openPopup(headerEl, {\n            owner        : me.grid,\n            cls          : 'b-filter-popup',\n            scrollAction : 'realign',\n            layout       : {\n                type  : 'vbox',\n                align : 'stretch'\n            },\n            items\n        });\n    }\n\n    /**\n     * Close the filter editor.\n     */\n    closeFilterEditor() {\n        // Must defer the destroy because it may be closed by an event like a \"change\" event where\n        // there may be plenty of code left to execute which must not execute on destroyed objects.\n        this.filterEditorPopup?.setTimeout(this.filterEditorPopup.destroy);\n        this.filterEditorPopup = null;\n    }\n\n    //endregion\n\n    //region Context menu\n\n    //TODO: break out together with getPopupXXItems() (see comment above)\n\n    getFilterType(column) {\n        const\n            fieldName = column.field,\n            field     = this.client.store.modelClass.getFieldDefinition(fieldName),\n            type      = column.filterType;\n\n        return type ? fieldTypeMap[type] : (fieldTypeMap[column.type] || field && fieldTypeMap[field.type]) || 'text';\n    }\n\n    populateCellMenuWithDateItems({ column, record, items }) {\n        const\n            property = column.field,\n            type     = this.getFilterType(column);\n\n        if (type === 'date') {\n            const\n                me       = this,\n                value    = record[property],\n                filter   = operator => {\n                    me.applyFilter(column, {\n                        operator,\n                        value,\n                        displayValue : column.formatValue ? column.formatValue(value) : value,\n                        type         : 'date'\n                    });\n                };\n\n            items.filterDateEquals = {\n                text        : 'L{on}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-equal',\n                cls         : 'b-separator',\n                weight      : 300,\n                disabled    : me.disabled,\n                onItem      : () => filter('=')\n            };\n\n            items.filterDateBefore = {\n                text        : 'L{before}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-before',\n                weight      : 310,\n                disabled    : me.disabled,\n                onItem      : () => filter('<')\n            };\n\n            items.filterDateAfter = {\n                text        : 'L{after}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-after',\n                weight      : 320,\n                disabled    : me.disabled,\n                onItem      : () => filter('>')\n            };\n        }\n    }\n\n    populateCellMenuWithNumberItems({ column, record, items }) {\n        const\n            property = column.field,\n            type     = this.getFilterType(column);\n\n        if (type === 'number') {\n            const\n                me       = this,\n                value    = record[property],\n                filter   = operator => {\n                    me.applyFilter(column, { operator, value });\n                };\n\n            items.filterNumberEquals = {\n                text        : 'L{equals}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-equal',\n                cls         : 'b-separator',\n                weight      : 300,\n                disabled    : me.disabled,\n                onItem      : () => filter('=')\n            };\n\n            items.filterNumberLess = {\n                text        : 'L{lessThan}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-less',\n                weight      : 310,\n                disabled    : me.disabled,\n                onItem      : () => filter('<')\n            };\n\n            items.filterNumberMore = {\n                text        : 'L{moreThan}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-more',\n                weight      : 320,\n                disabled    : me.disabled,\n                onItem      : () => filter('>')\n            };\n        }\n    }\n\n    populateCellMenuWithDurationItems({ column, record, items }) {\n        const\n            property = column.field,\n            type     = this.getFilterType(column);\n\n        if (type === 'duration') {\n            const\n                me       = this,\n                value    = record[property],\n                filter   = operator => {\n                    me.applyFilter(column, { operator, value });\n                };\n\n            items.filterDurationEquals = {\n                text        : 'L{equals}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-equal',\n                cls         : 'b-separator',\n                weight      : 300,\n                disabled    : me.disabled,\n                onItem      : () => filter('=')\n            };\n\n            items.filterDurationLess = {\n                text        : 'L{lessThan}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-less',\n                weight      : 310,\n                disabled    : me.disabled,\n                onItem      : () => filter('<')\n            };\n\n            items.filterDurationMore = {\n                text        : 'L{moreThan}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-more',\n                weight      : 320,\n                disabled    : me.disabled,\n                onItem      : () => filter('>')\n            };\n        }\n    }\n\n    populateCellMenuWithStringItems({ column, record, items }) {\n        const type = this.getFilterType(column);\n\n        if (!/(date|number|duration)/.test(type)) {\n            const\n                me       = this,\n                value    = column.getFilterableValue(record),\n                operator = column.filterable.filterField?.operator ?? '*';\n\n            items.filterStringEquals = {\n                text        : 'L{equals}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-equal',\n                cls         : 'b-separator',\n                weight      : 300,\n                disabled    : me.disabled,\n                onItem      : () => me.applyFilter(column, { value, operator })\n            };\n        }\n    }\n\n    /**\n     * Add menu items for filtering.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Core.data.Model} options.record Record for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateCellMenu({ column, record, items }) {\n        const me = this;\n\n        if (column.filterable !== false && !record.isSpecialRow) {\n            me.populateCellMenuWithDateItems(...arguments);\n            me.populateCellMenuWithNumberItems(...arguments);\n            me.populateCellMenuWithDurationItems(...arguments);\n            me.populateCellMenuWithStringItems(...arguments);\n\n            if (column.meta.isFiltered) {\n                items.filterRemove = {\n                    text        : 'L{removeFilter}',\n                    localeClass : me,\n                    icon        : 'b-fw-icon b-icon-remove',\n                    cls         : 'b-separator',\n                    weight      : 400,\n                    disabled    : me.disabled || (me.isMulti && !me.columnHasRemovableFilters(column)),\n                    onItem      : () => me.removeFilter(column)\n                };\n            }\n\n            if (me.isMulti) {\n                items.filterDisable = {\n                    text        : 'L{disableFilter}',\n                    localeClass : me,\n                    icon        : 'b-fw-icon b-icon-filter-disable',\n                    cls         : 'b-separator',\n                    weight      : 400,\n                    disabled    : me.disabled || !me.columnHasEnabledFilters(column),\n                    onItem      : () => me.disableFilter(column)\n                };\n            }\n        }\n    }\n\n    /**\n     * Used by isMulti mode to determine whether the 'remove filters' menu item should be enabled.\n     * @internal\n     */\n    columnHasRemovableFilters(column) {\n        const me = this;\n        return Boolean(me.getCurrentMultiFilters(column).find(filter =>\n            !me.canDeleteFilter || (me.callback(me.canDeleteFilter, me, [filter]) !== false)));\n    }\n\n    /**\n     * Used by isMulti mode to determine whether the 'disable filters' menu item should be enabled.\n     * @internal\n     */\n    columnHasEnabledFilters(column) {\n        return Boolean(this.getCurrentMultiFilters(column).find(filter => !filter.disabled));\n    }\n\n    /**\n     * Add menu item for removing filter if column is filtered.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateHeaderMenu({ column, items }) {\n        const me = this;\n\n        if (column.meta.isFiltered) {\n            items.editFilter = {\n                text        : 'L{editFilter}',\n                localeClass : me,\n                weight      : 100,\n                icon        : 'b-fw-icon b-icon-filter',\n                cls         : 'b-separator',\n                disabled    : me.disabled,\n                onItem      : () => me.showFilterEditor(column)\n            };\n\n            items.removeFilter = {\n                text        : 'L{removeFilter}',\n                localeClass : me,\n                weight      : 110,\n                icon        : 'b-fw-icon b-icon-remove',\n                disabled    : me.disabled || (me.isMulti && !me.columnHasRemovableFilters(column)),\n                onItem      : () => me.removeFilter(column)\n            };\n\n            if (me.isMulti) {\n                items.disableFilter = {\n                    text        : 'L{disableFilter}',\n                    localeClass : me,\n                    icon        : 'b-fw-icon b-icon-filter-disable',\n                    weight      : 115,\n                    disabled    : me.disabled || !me.columnHasEnabledFilters(column),\n                    onItem      : () => me.disableFilter(column)\n                };\n            }\n        }\n        else if (column.filterable !== false) {\n            items.filter = {\n                text        : 'L{filter}',\n                localeClass : me,\n                weight      : 100,\n                icon        : 'b-fw-icon b-icon-filter',\n                cls         : 'b-separator',\n                disabled    : me.disabled,\n                onItem      : () => me.showFilterEditor(column)\n            };\n        }\n    }\n\n    //endregion\n\n    //region Events\n\n    // Intercept filtering by a column that has a custom filtering fn, and inject that fn\n    onStoreBeforeFilter({ filters }) {\n        const { columns } = this.client;\n\n        for (let i = 0; i < filters.count; i++) {\n            const filter = filters.getAt(i);\n\n            // Only take ownership of filters which are not internal\n            if (!filter.internal) {\n                const column = (filter.columnOwned || this.prioritizeColumns) && columns.find(col => col.filterable !== false && col.field === filter.property);\n\n                if (column?.filterable?.filterFn) {\n                    // If the filter was sourced from the store, replace it with a filter which\n                    // uses the column's filterFn\n                    if (!column.$filter) {\n                        column.$filter = new CollectionFilter({\n                            columnOwned : true,\n                            property    : filter.property,\n                            operator    : filter.operator,\n                            value       : filter.value,\n                            filterBy(record) {\n                                return column.filterable.filterFn({ value : this.value, record, operator : this.operator, property : this.property, column });\n                            }\n                        });\n                    }\n\n                    // Update value and operator used by filters filtering fn\n                    column.$filter.value = filter.value;\n                    column.$filter.displayValue = filter.displayValue;\n                    column.$filter.operator = filter.operator;\n\n                    filters.splice(i, 1, column.$filter);\n                }\n            }\n        }\n    }\n\n    /**\n     * Store filtered; refresh headers.\n     * @private\n     */\n    onStoreFilter() {\n        // Pass false to not refresh rows.\n        // Store's refresh event will refresh the rows.\n        this.refreshHeaders(false);\n    }\n\n    /**\n     * Called after headers are rendered, make headers match stores initial sorters\n     * @private\n     */\n    renderHeader() {\n        this.refreshHeaders(false);\n    }\n\n    /**\n     * Called when user clicks on the grid. Only care about clicks on the filter icon.\n     * @param {MouseEvent} event\n     * @private\n     */\n    onElementClick({ target }) {\n        if (this.filterEditorPopup) {\n            this.closeFilterEditor();\n        }\n\n        if (target.classList.contains('b-filter-icon')) {\n            const headerEl = target.closest('.b-grid-header');\n\n            this.showFilterEditor(headerEl.dataset.columnId);\n\n            return false;\n        }\n    }\n\n    /**\n     * Called when user presses F-key grid.\n     * @param {MouseEvent} event\n     * @private\n     */\n    showFilterEditorByKey({ target }) {\n        const headerEl = target.matches('.b-grid-header') && target;\n        // Header must be focused\n        if (headerEl) {\n            this.showFilterEditor(headerEl.dataset.columnId);\n        }\n        return Boolean(headerEl);\n    }\n\n    // Only care about F key when a filterable header is focused\n    isActionAvailable(key, action, event) {\n        const\n            headerElement = event.target.closest('.b-grid-header'),\n            column        = headerElement && this.client.columns.find(col => col.id === headerElement.dataset.columnId);\n\n        return Boolean(column?.filterable);\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(Filter);\n","/* eslint-disable no-unused-expressions */\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport WidgetHelper from '../../Core/helper/WidgetHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport '../../Core/widget/NumberField.js';\nimport '../../Core/widget/Combo.js';\nimport '../../Core/widget/DateField.js';\nimport '../../Core/widget/TimeField.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport CollectionFilter from '../../Core/util/CollectionFilter.js';\n\nconst complexOperators = {\n    '*'          : null,\n    isIncludedIn : null,\n    startsWith   : null,\n    endsWidth    : null\n};\n\n/**\n * @module Grid/feature/FilterBar\n */\n\n/**\n * Feature that allows filtering of the grid by entering filters on column headers.\n * The actual filtering is done by the store.\n * For info on programmatically handling filters, see {@link Core.data.mixin.StoreFilter StoreFilter}.\n *\n * {@inlineexample Grid/feature/FilterBar.js}\n *\n * ```javascript\n * // filtering turned on but no initial filter\n * const grid = new Grid({\n *   features: {\n *     filterBar : true\n *   }\n * });\n *\n * // using initial filter\n * const grid = new Grid({\n *   features : {\n *     filterBar : { filter: { property : 'city', value : 'Gavle' } }\n *   }\n * });\n * ```\n *\n * ## Enabling filtering for a column\n * The individual filterability of columns is defined by a `filterable` property on the column which defaults to `true`.\n * If `false`, that column is not filterable. Note: If you have multiple columns configured with the same `field` value,\n * assign an {@link Core.data.Model#field-id} to the columns to ensure filters work correctly.\n *\n * The property value may also be a custom filter function.\n *\n * The property value may also be an object which may contain the following two properties:\n *  - **filterFn** : `Function` A custom filtering function\n *  - **filterField** : `Object` A config object for the filter value input field. See {@link Core.widget.TextField} or\n *  the other field widgets for reference.\n *\n * ```javascript\n * // Custom filtering function for a column\n * const grid = new Grid({\n *   features : {\n *     filterBar : true\n *   },\n *\n *   columns: [\n *      {\n *        field      : 'age',\n *        text       : 'Age',\n *        type       : 'number',\n *        // Custom filtering function that checks \"greater than\"\n *        filterable : ({ record, value }) => record.age > value\n *      },\n *      {\n *        field : 'name',\n *        // Filterable may specify a filterFn and a config for the filtering input field\n *        filterable : {\n *          filterFn : ({ record, value }) => record.name.toLowerCase().indexOf(value.toLowerCase()) !== -1,\n *          filterField : {\n *            emptyText : 'Filter name'\n *          }\n *        }\n *      },\n *      {\n *        field : 'city',\n *        text : 'Visited',\n *        flex : 1,\n *        // Filterable with multiselect combo to pick several items to filter\n *        filterable : {\n *          filterField : {\n *            type        : 'combo',\n *            multiSelect : true,\n *            items       : ['Barcelona', 'Moscow', 'Stockholm']\n *          }\n *        }\n *      }\n *   ]\n * });\n * ```\n *\n * If this feature is configured with `prioritizeColumns : true`, those functions will also be used when filtering\n * programmatically:\n *\n * ```javascript\n * const grid = new Grid({\n *    features : {\n *        filterBar : {\n *            prioritizeColumns : true\n *        }\n *    },\n *\n *    columns: [\n *        {\n *          field      : 'age',\n *          text       : 'Age',\n *          type       : 'number',\n *          // Custom filtering function that checks \"greater than\" no matter\n *          // which field user filled in :)\n *          filterable : ({ record, value, operator }) => record.age > value\n *        }\n *    ]\n * });\n *\n * // Will be used when filtering programmatically or using the UI\n * grid.store.filter({\n *     property : 'age',\n *     value    : 41\n * });\n * ```\n *\n * ## Filtering using a multiselect combo\n *\n * To filter the grid by choosing values which should match with the store data, use a {@link Core.widget.Combo}, and configure\n * your grid like so:\n *\n * ```javascript\n * const grid = new Grid({\n *    features : {\n *        filterBar : true\n *    },\n *\n *    columns : [\n *        {\n *            id         : 'name',\n *            field      : 'name',\n *            text       : 'Name',\n *            filterable : {\n *                filterField : {\n *                    type         : 'combo',\n *                    multiSelect  : true,\n *                    valueField   : 'name',\n *                    displayField : 'name'\n *                }\n *            }\n *        }\n *    ]\n * });\n * ```\n *\n * You can also filter the {@link Core.widget.Combo} values, for example to filter out empty values. Example:\n *\n * ```javascript\n * const grid = new Grid({\n *    features : {\n *        filterBar : true\n *    },\n *\n *    columns : [\n *        {\n *            text       : 'Airline',\n *            field      : 'airline',\n *            flex       : 1,\n *            filterable : {\n *                filterField : {\n *                    type         : 'combo',\n *                    multiSelect  : true,\n *                    valueField   : 'airline',\n *                    displayField : 'airline',\n *                    store        : {\n *                        filters : {\n *                            // Filter out empty values\n *                            filterBy : record => !!record.airline\n *                        }\n *                    }\n *                }\n *            }\n *        }\n *    ]\n * });\n * ```\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * **Note:** This feature cannot be used together with {@link Grid.feature.Filter filter} feature, they are mutually\n * exclusive.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/filterbar\n * @classtype filterBar\n * @feature\n */\nexport default class FilterBar extends InstancePlugin {\n    //region Config\n\n    static get $name() {\n        return 'FilterBar';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Use custom filtering functions defined on columns also when programmatically filtering by the columns\n             * field.\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     columns : [\n             *         {\n             *             field : 'age',\n             *             text : 'Age',\n             *             filterable({ record, value }) {\n             *               // Custom filtering, return true/false\n             *             }\n             *         }\n             *     ],\n             *\n             *     features : {\n             *         filterBar : {\n             *             prioritizeColumns : true // <--\n             *         }\n             *     }\n             * });\n             *\n             * // Because of the prioritizeColumns config above, any custom\n             * // filterable function on a column will be used when\n             * // programmatically filtering by that columns field\n             * grid.store.filter({\n             *     property : 'age',\n             *     value    : 30\n             * });\n             * ```\n             *\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            prioritizeColumns : false,\n\n            /**\n             * The delay in milliseconds to wait after the last keystroke before applying filters.\n             * Set to 0 to not trigger filtering from keystrokes, requires pressing ENTER instead\n             * @config {Number}\n             * @default\n             * @category Common\n             */\n            keyStrokeFilterDelay : 300,\n\n            /**\n             * Toggle compact mode. In this mode the filtering fields are styled to transparently overlay the headers,\n             * occupying no additional space.\n             * @member {Boolean} compactMode\n             * @category Common\n             */\n            /**\n             * Specify `true` to enable compact mode for the filter bar. In this mode the filtering fields are styled\n             * to transparently overlay the headers, occupying no additional space.\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            compactMode : false,\n\n            // Destroying data level filters when we hiding UI is supposed to be optional someday. So far this flag is private\n            clearStoreFiltersOnHide : true,\n\n            keyMap : {\n                // Private\n                ArrowUp    : { handler : 'disableGridNavigation', preventDefault : false },\n                ArrowRight : { handler : 'disableGridNavigation', preventDefault : false },\n                ArrowDown  : { handler : 'disableGridNavigation', preventDefault : false },\n                ArrowLeft  : { handler : 'disableGridNavigation', preventDefault : false },\n                Enter      : { handler : 'disableGridNavigation', preventDefault : false }\n            }\n        };\n    }\n\n    static get pluginConfig() {\n        return {\n            before : ['renderContents'],\n            chain  : ['afterColumnsChange', 'renderHeader', 'populateHeaderMenu', 'bindStore']\n        };\n    }\n\n    static get properties() {\n        return {\n            filterFieldCls           : 'b-filter-bar-field',\n            filterFieldInputCls      : 'b-filter-bar-field-input',\n            filterableColumnCls      : 'b-filter-bar-enabled',\n            filterFieldInputSelector : '.b-filter-bar-field-input',\n            filterableColumnSelector : '.b-filter-bar-enabled',\n            filterParseRegExp        : /^\\s*([<>=*])?(.*)$/,\n            storeTrackingSuspended   : 0\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    construct(grid, config) {\n        if (grid.features.filter) {\n            throw new Error('Grid.feature.FilterBar feature may not be used together with Grid.feature.Filter, These features are mutually exclusive.');\n        }\n\n        const me = this;\n\n        me.grid = grid;\n\n        me.onColumnFilterFieldChange = me.onColumnFilterFieldChange.bind(me);\n\n        super.construct(grid, Array.isArray(config) ? {\n            filter : config\n        } : config);\n\n        me.bindStore(grid.store);\n\n        if (me.filter) {\n            grid.store.filter(me.filter);\n        }\n\n        me.gridDetacher = grid.ion({ beforeElementClick : 'onBeforeElementClick', thisObj : me });\n    }\n\n    bindStore(store) {\n        this.detachListeners('store');\n\n        store.ion({\n            name         : 'store',\n            beforeFilter : 'onStoreBeforeFilter',\n            filter       : 'onStoreFilter',\n            thisObj      : this\n        });\n    }\n\n    doDestroy() {\n        this.destroyFilterBar();\n        this.gridDetacher?.();\n\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        const { columns } = this.grid;\n\n        // Disable the fields\n        columns?.forEach(column => {\n            const widget = this.getColumnFilterField(column);\n            if (widget) {\n                widget.disabled = disable;\n            }\n        });\n\n        super.doDisable(disable);\n    }\n\n    updateCompactMode(value) {\n        this.client.headerContainer.classList[value ? 'add' : 'remove']('b-filter-bar-compact');\n\n        for (const prop in this._columnFilters) {\n            const field       = this._columnFilters[prop];\n            field.placeholder = value ? field.column.headerText : null;\n        }\n    }\n\n    //endregion\n\n    //region FilterBar\n\n    destroyFilterBar() {\n        this.grid.columns?.forEach(this.destroyColumnFilterField, this);\n    }\n\n    /**\n     * Hides the filtering fields.\n     */\n    hideFilterBar() {\n        const me = this;\n\n        // We don't want to hear back store \"filter\" event while we're resetting store filters\n        me.clearStoreFiltersOnHide && me.suspendStoreTracking();\n\n        // Hide the fields, each silently - no updating of the store's filtered state until the end\n        me.grid.columns?.forEach(col => me.hideColumnFilterField(col, true));\n\n        // Now update the filtered state\n        me.grid.store.filter();\n\n        me.clearStoreFiltersOnHide && me.resumeStoreTracking();\n\n        me.hidden = true;\n    }\n\n    /**\n     * Shows the filtering fields.\n     */\n    showFilterBar() {\n        this.suspendStoreTracking();\n        this.renderFilterBar();\n        this.resumeStoreTracking();\n\n        this.hidden = false;\n    }\n\n    /**\n     * Toggles the filtering fields visibility.\n     */\n    toggleFilterBar() {\n        if (this.hidden) {\n            this.showFilterBar();\n        }\n        else {\n            this.hideFilterBar();\n        }\n    }\n\n    /**\n     * Renders the filtering fields for filterable columns.\n     * @private\n     */\n    renderFilterBar() {\n        if (this.grid.hideHeaders) {\n            return;\n        }\n\n        this.grid.columns.visibleColumns.forEach(column => this.renderColumnFilterField(column));\n        this.rendered = true;\n    }\n\n    //endregion\n\n    //region FilterBar fields\n\n    /**\n     * Renders text field filter in the provided column header.\n     * @param {Grid.column.Column} column Column to render text field filter for.\n     * @private\n     */\n    renderColumnFilterField(column) {\n        const\n            me         = this,\n            { grid  }  = me,\n            filterable = me.getColumnFilterable(column);\n\n        // we render fields for filterable columns only\n        if (filterable && column.isVisible) {\n            const\n                headerEl = column.element,\n                filter   = grid.store.filters.get(column.id) || grid.store.filters.getBy('property', column.field);\n\n            let widget = me.getColumnFilterField(column);\n\n            // if we don't haven't created a field yet\n            // we build it from scratch\n            if (!widget) {\n                const\n                    type            = `${column.filterType || 'text'}field`,\n                    { filterField } = filterable,\n                    externalCls     = filterField?.cls;\n\n                if (externalCls) {\n                    delete filterable.filterField.cls;\n                }\n\n                widget = WidgetHelper.append(ObjectHelper.assign({\n                    type,\n                    cls : {\n                        [me.filterFieldCls] : 1,\n                        [externalCls]       : externalCls\n                    },\n                    // Simplifies debugging / testing\n                    dataset : {\n                        column : column.field\n                    },\n                    column,\n                    owner                : grid,\n                    clearable            : true,\n                    name                 : column.field,\n                    value                : (filter && !filter._filterBy && !filter.internal) ? me.buildFilterValue(filter) : '',\n                    inputCls             : me.filterFieldInputCls,\n                    keyStrokeChangeDelay : me.keyStrokeFilterDelay,\n                    onChange             : me.onColumnFilterFieldChange,\n                    onClear              : me.onColumnFilterFieldChange,\n                    disabled             : me.disabled,\n                    placeholder          : me.compactMode ? column.headerText : null,\n                    // Also copy formats, DateColumn, TimeColumn etc\n                    format               : column.format\n                }, filterField), headerEl)[0];\n\n                if (!filterField?.hasOwnProperty('min')) {\n                    Object.defineProperty(widget, 'min', {\n                        get : () => column.editor?.min,\n                        set : () => null\n                    });\n                }\n\n                if (!filterField?.hasOwnProperty('max')) {\n                    Object.defineProperty(widget, 'max', {\n                        get : () => column.editor?.max,\n                        set : () => null\n                    });\n                }\n\n                if (!filterField?.hasOwnProperty('strictParsing')) {\n                    Object.defineProperty(widget, 'strictParsing', {\n                        get : () => column.editor?.strictParsing,\n                        set : () => null\n                    });\n                }\n\n                // Avoid DomSync cleaning up this widget as it syncs column headers\n                widget.element.retainElement = true;\n\n                me.setColumnFilterField(column, widget);\n\n                const hasFilterFieldStoreData = filterField?.store && (filterField.store.readUrl || filterField.store.data || filterField.store.isChained);\n\n                // If no store is provided for filterable or store is empty, load values lazily from the grid store upon showing the picker list\n                if (widget.isCombo && !hasFilterFieldStoreData && widget.store.count === 0) {\n                    const\n                        configuredValue = widget.value,\n                        refreshData     = () => {\n                            // Might have replaced the widgets store at runtime, make sure we should still force refresh\n                            if (!(widget.store.readUrl || widget.store.isChained)) {\n                                widget.store.data = grid.store.getDistinctValues(column.field, true).map(value => grid.store.modelClass.new({\n                                    id             : value,\n                                    [column.field] : value\n                                }));\n                            }\n                        };\n\n                    widget.value = null;\n\n                    if (!widget.store.isSorted) {\n                        widget.store.sort({\n                            field     : column.field,\n                            ascending : true\n                        });\n                    }\n\n                    widget.picker.ion({ beforeShow : refreshData });\n\n                    refreshData();\n                    widget.value = configuredValue;\n                }\n\n                // If no initial filter exists but a value was provided to the widget, filter by it\n                // unless the store is configured to not autoLoad\n                if (!me.filter && widget.value && grid.store.autoLoad !== false) {\n                    me.onColumnFilterFieldChange({ source : widget, value : widget.value });\n                }\n            }\n            // if we have one...\n            else {\n                // re-apply widget filter\n                me.onColumnFilterFieldChange({ source : widget, value : widget.value });\n                // re-append the widget to its parent node (in case the column header was redrawn (happens when resizing columns))\n                widget.render(headerEl);\n                // show widget in case it was hidden\n                widget.show();\n            }\n\n            headerEl.classList.add(me.filterableColumnCls);\n        }\n    }\n\n    /**\n     * Fills in column filter fields with values from the grid store filters.\n     * @private\n     */\n    updateColumnFilterFields() {\n        const\n            me                 = this,\n            { columns, store } = me.grid;\n\n        let field, filter;\n\n        // During this phase we should not respond to field change events.\n        // See onColumnFilterFieldChange.\n        me._updatingFields = true;\n\n        for (const column of columns.visibleColumns) {\n            field = me.getColumnFilterField(column);\n            if (field) {\n                filter = store.filters.get(column.id) || store.filters.getBy('property', column.field);\n                if (filter && !filter.internal) {\n                    // For filtering functions we keep what user typed into the field, we cannot construct a filter\n                    // string from them\n                    if (!filter._filterBy) {\n                        field.value = me.buildFilterValue(filter);\n                    }\n                    else {\n                        field.value = filter.value;\n                    }\n                }\n                // No filter, clear field\n                else {\n                    field.value = '';\n                }\n            }\n        }\n\n        me._updatingFields = false;\n    }\n\n    getColumnFilterable(column) {\n        if (!column.isRoot && column.filterable !== false && column.field && column.isLeaf) {\n            if (typeof column.filterable === 'function') {\n                column.filterable = {\n                    filterFn : column.filterable\n                };\n            }\n            return column.filterable;\n        }\n    }\n\n    destroyColumnFilterField(column) {\n        const widget = this.getColumnFilterField(column);\n\n        if (widget) {\n            this.hideColumnFilterField(column, true);\n            // destroy filter UI field\n            widget.destroy();\n            // remember there is no field bound anymore\n            this.setColumnFilterField(column, undefined);\n        }\n    }\n\n    hideColumnFilterField(column, silent) {\n        const\n            me        = this,\n            { store } = me.grid,\n            columnEl  = column.element,\n            widget    = me.getColumnFilterField(column);\n\n        if (widget) {\n            if (!me.isDestroying) {\n                // hide field\n                widget.hide();\n            }\n            const { $filter } = column;\n\n            if (!store.isDestroyed && me.clearStoreFiltersOnHide && $filter) {\n                store.removeFilter($filter, silent);\n            }\n\n            columnEl?.classList.remove(me.filterableColumnCls);\n        }\n    }\n\n    /**\n     * Returns column filter field instance.\n     * @param {Grid.column.Column} column Column to get filter field for.\n     * @returns {Core.widget.Widget}\n     */\n    getColumnFilterField(column) {\n        return this._columnFilters?.[column.id];\n    }\n\n    setColumnFilterField(column, widget) {\n        this._columnFilters = this._columnFilters || {};\n\n        this._columnFilters[column.data.id] = widget;\n    }\n\n    //endregion\n\n    //region Filters\n\n    parseFilterValue(column, value, field) {\n        if (Array.isArray(value)) {\n            return {\n                value\n            };\n        }\n        if (ObjectHelper.isDate(value)) {\n            return {\n                operator : field.isDateField ? 'sameDay' : (field.isTimeField ? 'sameTime' : '='),\n                value\n            };\n        }\n\n        const match = String(value).match(this.filterParseRegExp);\n\n        return {\n            operator : match[1] || column.filterable?.operator || '*',\n            value    : match[2]\n        };\n    }\n\n    buildFilterValue({ operator, value }) {\n        return (value instanceof Date || Array.isArray(value)) ? value : (operator in complexOperators ? '' : operator) + value;\n    }\n\n    //endregion\n\n    // region Events\n\n    // Intercept filtering by a column that has a custom filtering fn, and inject that fn\n    onStoreBeforeFilter({ filters }) {\n        const { columns } = this.client;\n\n        for (let i = 0; i < filters.count; i++) {\n            const\n                filter = filters.getAt(i),\n                column = (filter.columnOwned || this.prioritizeColumns) && columns.find(col => col.filterable !== false && col.field === filter.property);\n\n            if (column?.filterable?.filterFn) {\n                // If the filter was sourced from the store, replace it with a filter which\n                // uses the column's filterFn\n                if (!column.$filter) {\n                    column.$filter = new CollectionFilter({\n                        columnOwned : true,\n                        property    : filter.property,\n                        id          : column.id,\n                        filterBy(record) {\n                            return column.filterable.filterFn({\n                                value : this.value, record, property : this.property, column\n                            });\n                        }\n                    });\n                }\n\n                // Update value used by filters filtering fn\n                column.$filter.value = filter.value;\n                filters.splice(i, 1, column.$filter);\n            }\n        }\n    }\n\n    /**\n     * Fires when store gets filtered. Refreshes field values in column headers.\n     * @private\n     */\n    onStoreFilter() {\n        if (!this.storeTrackingSuspended && this.rendered) {\n            this.updateColumnFilterFields();\n        }\n    }\n\n    afterColumnsChange({ changes, column }) {\n        // Ignore if columns change while this filter bar is hidden, or if column changeset does not include hidden\n        // state\n        if (!this.hidden && changes?.hidden) {\n            const hidden = changes.hidden.value;\n\n            if (hidden) {\n                this.destroyColumnFilterField(column);\n            }\n            else {\n                this.renderColumnFilterField(column);\n            }\n        }\n    }\n\n    suspendStoreTracking() {\n        this.storeTrackingSuspended++;\n    }\n\n    resumeStoreTracking() {\n        this.storeTrackingSuspended--;\n    }\n\n    /**\n     * Called after headers are rendered, make headers match stores initial sorters\n     * @private\n     */\n    renderHeader() {\n        if (!this.hidden) {\n            this.renderFilterBar();\n        }\n    }\n\n    renderContents() {\n        // Grid suspends events when restoring state, thus we are not informed about toggled columns and might end up\n        // with wrong fields in headers. To prevent that, we remove all field elements here since they are restored in\n        // renderColumnFilterField() later anyway\n        if (this._columnFilters) {\n            for (const field of Object.values(this._columnFilters)) {\n                field?.element.remove();\n            }\n        }\n    }\n\n    disableGridNavigation(event) {\n        /* If we have navigated (ArrowUp, ArrowLeft, ArrowDown, ArrowRight, Enter) in a filter field, \"catch\" the key\n         * call.\n         */\n        if (event.target.matches(this.filterFieldInputSelector)) {\n            return true;\n        }\n        return false;\n    }\n\n    onBeforeElementClick({ event }) {\n        // prevent other features reacting when clicking a filter field (or any element inside it)\n        if (event.target.closest(`.${this.filterFieldCls}`)) {\n            return false;\n        }\n    }\n\n    /**\n     * Called when a column text filter field value is changed by user.\n     * @param  {Core.widget.TextField} field Filter text field.\n     * @param  {String} value New filtering value.\n     * @private\n     */\n    onColumnFilterFieldChange({ source: field, value }) {\n        const\n            me           = this,\n            { column }   = field,\n            { filterFn } = column.filterable,\n            { store }    = me.grid,\n            filter       = column.$filter || store.filters.find(f => (f.id === column.id || f.property === column.field) && !f.internal);\n\n        // Don't respond if we set the value in response to a filter\n        if (me._updatingFields) {\n            return;\n        }\n\n        const isClearingFilter = value == null || value === '' || Array.isArray(value) && value.length === 0;\n\n        // Remove previous iteration of the column's filter\n        store.removeFilter(filter, true);\n        column.$filter = null;\n\n        if (isClearingFilter) {\n            // This is a no-op if there was no matching filter anyway\n            if (!filter) {\n                return;\n            }\n        }\n        else {\n            // Must add the filter silently, so that the column gets a reference to its $filter\n            // before events are broadcast\n            column.$filter = store.addFilter({\n                property                                                                              : field.name,\n                ...me.parseFilterValue(column, value, field),\n                [typeof column.filterable?.caseSensitive === 'boolean' ? 'caseSensitive' : undefined] : column.filterable?.caseSensitive,\n\n                // Only inject a filterBy configuration if the column has a custom filterBy\n                [filterFn ? 'filterBy' : '_'] : function(record) {\n                    return filterFn({ value : this.value, record, operator : this.operator, property : this.property, column });\n                }\n            }, true);\n        }\n\n        // Apply the new set of store filters.\n        store.filter();\n    }\n\n    //endregion\n\n    //region Menu items\n\n    /**\n     * Adds a menu item to toggle filter bar visibility.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateHeaderMenu({ items }) {\n        items.toggleFilterBar = {\n            text        : this.hidden ? 'L{enableFilterBar}' : 'L{disableFilterBar}',\n            localeClass : this,\n            weight      : 120,\n            icon        : 'b-fw-icon b-icon-filter',\n            cls         : 'b-separator',\n            onItem      : () => this.toggleFilterBar()\n        };\n    }\n\n    //endregion\n}\n\nFilterBar.featureClass = 'b-filter-bar';\n\nGridFeatureManager.registerFeature(FilterBar);\n","//TODO: Expand function?\n//TODO: Collapse function?\n//TODO: Sorting breaks grouping if some groups are collapsed\n//TODO: Grouping via context menu doesn't work\n\nimport DomDataStore from '../../Core/data/DomDataStore.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n\n/**\n * @module Grid/feature/Group\n */\n\n/**\n * Enables rendering and handling of row groups. The actual grouping is done in the store, but triggered by [shift] +\n * clicking headers or by using two finger tap (one on header, one anywhere on grid). Groups can be expanded/collapsed\n * by clicking on the group row or pressing [space] when group row is selected.\n * The actual grouping is done by the store, see {@link Core.data.mixin.StoreGroup#function-group}.\n *\n * Grouping by a field performs sorting by the field automatically. It's not possible to prevent sorting.\n * If you group, the records have to be sorted so that records in a group stick together. You can either control sorting\n * direction, or provide a custom sorting function called {@link #config-groupSortFn} to your feature config object.\n *\n * For info on programmatically handling grouping, see {@link Core.data.mixin.StoreGroup StoreGroup}.\n *\n * Currently grouping is not supported when using pagination, the underlying store cannot group data that is split into pages.\n *\n * **Note:** Custom height for group header rows cannot be set with CSS, should instead be defined in a renderer function using the `size` param. See the {@link #config-renderer} config for details.\n *\n * This feature is **enabled** by default.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys   | Action      | Action description                                                         |\n * |--------|-------------|----------------------------------------------------------------------------|\n * | Space  | toggleGroup | When a group header is focused, this expands or collapses the grouped rows |\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * @example\n * // grouping feature is enabled, no default value though\n * let grid = new Grid({\n *     features : {\n *         group : true\n *     }\n * });\n *\n * // use initial grouping\n * let grid = new Grid({\n *     features : {\n *         group : 'city'\n *     }\n * });\n *\n * // default grouper and custom renderer, which will be applied to each cell except the \"group\" cell\n * let grid = new Grid({\n *     features : {\n *       group : {\n *           field : 'city',\n *           ascending : false,\n *           renderer : ({ isFirstColumn, count, groupRowFor, record }) => isFirstColumn ? `${groupRowFor} (${count})` : ''\n *       }\n *     }\n * });\n *\n * // group using custom sort function\n * let grid = new Grid({\n *     features : {\n *         group       : {\n *             field       : 'city',\n *             groupSortFn : (a, b) => a.city.length < b.city.length ? -1 : 1\n *         }\n *     }\n * });\n *\n * // can also be specified on the store\n * let grid = new Grid({\n *     store : {\n *         groupers : [\n *             { field : 'city', ascending : false }\n *         ]\n *     }\n * });\n *\n * // custom sorting function can also be specified on the store\n * let grid = new Grid({\n *     store : {\n *         groupers : [{\n *             field : 'city',\n *             fn : (recordA, recordB) => {\n *                 // apply custom logic, for example:\n *                 return recordA.city.length < recordB.city.length ? -1 : 1;\n *             }\n *         }]\n *     }\n * });\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @demo Grid/grouping\n * @classtype group\n * @feature\n *\n * @inlineexample Grid/feature/Group.js\n */\nexport default class Group extends InstancePlugin {\n\n    static get $name() {\n        return 'Group';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * The name of the record field to group by.\n             * @config {String}\n             * @default\n             */\n            field : null,\n\n            /**\n             * A function used to sort the groups.\n             * When grouping, the records have to be sorted so that records in a group stick together.\n             * Technically that means that records having the same {@link #config-field} value\n             * should go next to each other.\n             * And this function (if provided) is responsible for applying such grouping order.\n             * ```javascript\n             * const grid = new Grid({\n             *     features : {\n             *         group : {\n             *             // group by category\n             *             field       : 'category',\n             *             groupSortFn : (a, b) => {\n             *                 const\n             *                     aCategory = a.category || '',\n             *                     bCategory = b.category || '';\n             *\n             *                 // 1st sort by \"calegory\" field\n             *                 return aCategory > bCategory ? -1 :\n             *                     aCategory < bCategory ? 1 :\n             *                     // inside calegory groups we sort by \"name\" field\n             *                     (a.name > b.name ? -1 : 1);\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             * @config {Function}\n             */\n            groupSortFn : null,\n\n            /**\n             * A function which produces the HTML for a group header.\n             * The function is called in the context of this Group feature object.\n             * Default group renderer displays the `groupRowFor` and `count`.\n             *\n             * @config {Function}\n             * @property {String} groupRowFor The value of the `field` for the group.\n             * @property {Core.data.Model} record The group record representing the group.\n             * @property {Object} record.meta Meta data with additional info about the grouping.\n             * @property {Array} record.groupChildren The group child records.\n             * @property {Number} count Number of records in the group.\n             * @property {Grid.column.Column} column The column the renderer runs for.\n             * @property {Boolean} isFirstColumn True, if `column` is the first column.\n             * If `RowNumberColumn` is the real first column, it's not taken into account.\n             * @property {Grid.column.Column} [groupColumn] The column under which the `field` is shown.\n             * @property {Object} size Sizing information for the group header row, only `height` is relevant.\n             * @property {Number} size.height The height of the row, set this if you want a custom height for the group header row\n             * That is UI part, so do not rely on its existence.\n             * @default\n             */\n            renderer : null,\n\n            /**\n             * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n             * @config {Object<String,String>}\n             */\n            keyMap : {\n                ' ' : 'toggleGroup'\n            }\n        };\n    }\n\n    //region Init\n\n    construct(grid, config) {\n        const me = this;\n\n        if (grid.features.tree) {\n            return;\n        }\n\n        // groupSummary feature needs to be initialized first, if it is used\n        me._thisIsAUsedExpression(grid.features.groupSummary);\n\n        // process initial config into an actual config object\n        config = me.processConfig(config);\n\n        me.grid = grid;\n\n        super.construct(grid, config);\n\n        me.bindStore(grid.store);\n\n        grid.rowManager.ion({\n            beforeRenderRow : 'onBeforeRenderRow',\n            renderCell      : 'renderCell',\n\n            // The feature gets to see cells being rendered before the GroupSummary feature\n            // because this injects header content into group header rows and adds rendering\n            // info to the cells renderData which GroupSummary must comply with.\n            prio    : 1100,\n            thisObj : me\n        });\n    }\n\n    // Group feature handles special config cases, where user can supply a string or a group config object\n    // instead of a normal config object\n    processConfig(config) {\n        if (typeof config === 'string') {\n            return {\n                field     : config,\n                ascending : null\n            };\n        }\n\n        return config;\n    }\n\n    // override setConfig to process config before applying it (used mainly from ReactGrid)\n    setConfig(config) {\n        if (config === null) {\n            this.store.clearGroupers();\n        }\n        else {\n            super.setConfig(this.processConfig(config));\n        }\n    }\n\n    bindStore(store) {\n        this.detachListeners('store');\n\n        store.ion({\n            name    : 'store',\n            group   : 'onStoreGroup',\n            change  : 'onStoreChange',\n            thisObj : this\n        });\n    }\n\n    updateRenderer(renderer) {\n        this.groupRenderer = renderer;\n    }\n\n    updateField(field) {\n        this.store.group({\n            field,\n            ascending : this.ascending,\n            fn        : this.groupSortFn\n        });\n    }\n\n    updateGroupSortFn(fn) {\n        if (!this.isConfiguring) {\n            this.store.group({\n                field     : this.field,\n                ascending : this.ascending,\n                fn\n            });\n        }\n    }\n\n    doDestroy() {\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        const { store } = this;\n\n        // Grouping mostly happens in store, need to clear groupers there to remove headers.\n        // Use configured groupers as first sorters to somewhat maintain the order\n        if (disable && store.isGrouped) {\n            const { sorters } = store;\n            sorters.unshift(...store.groupers);\n            store.clearGroupers();\n            store.sort(sorters);\n        }\n\n        super.doDisable(disable);\n    }\n\n    get store() {\n        return this.grid.store;\n    }\n\n    //endregion\n\n    //region Plugin config\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            assign : ['collapseAll', 'expandAll'],\n            chain  : ['renderHeader', 'populateHeaderMenu', 'getColumnDragToolbarItems', 'onElementTouchStart',\n                'onElementClick', 'bindStore']\n        };\n    }\n\n    //endregion\n\n    //region Expand/collapse\n\n    /**\n     * Collapses or expands a group depending on its current state\n     * @param {Core.data.Model|String} recordOrId Record or records id for a group row to collapse or expand\n     * @param {Boolean} collapse Force collapse (`true`) or expand (`false`)\n     * @fires togglegroup\n     */\n    toggleCollapse(recordOrId, collapse) {\n        this.internalToggleCollapse(recordOrId, collapse);\n    }\n\n    /**\n     * Collapses or expands a group depending on its current state\n     * @param {Core.data.Model|String} recordOrId Record or records id for a group row to collapse or expand\n     * @param {Boolean} collapse Force collapse (true) or expand (true)\n     * @param {Boolean} skipRender True to not render rows\n     * @internal\n     * @fires togglegroup\n     */\n    internalToggleCollapse(recordOrId, collapse, skipRender = false) {\n        //<debug>\n        if (recordOrId == null) {\n            throw new Error('Group#toggleCollapse must be passed a record');\n        }\n        //</debug>\n\n        const\n            me              = this,\n            { store, grid } = me,\n            groupRecord     = store.getById(recordOrId);\n\n        if (!groupRecord.isGroupHeader) {\n            return;\n        }\n\n        collapse = collapse === undefined ? !groupRecord.meta.collapsed : collapse;\n\n        /**\n         * Fired when a group is going to be expanded or collapsed using the UI.\n         * Returning `false` from a listener prevents the operation\n         * @event beforeToggleGroup\n         * @on-owner\n         * @preventable\n         * @param {Core.data.Model} groupRecord Group record\n         * @param {Boolean} collapse Collapsed (true) or expanded (false)\n         */\n        if (grid.trigger('beforeToggleGroup', { groupRecord, collapse }) === false) {\n            return;\n        }\n\n        if (collapse) {\n            store.collapse(groupRecord);\n        }\n        else {\n            store.expand(groupRecord);\n        }\n\n        if (!skipRender) {\n            // If collapsing the group reduces amount of records below amount of rendered rows, we need to refresh\n            // entire view\n            // https://github.com/bryntum/support/issues/5893\n            if (grid.rowManager.rowCount > grid.store.count) {\n                grid.rowManager.renderFromRow();\n            }\n            else {\n                // render from group record and down, no need to touch those above\n                grid.rowManager.renderFromRecord(groupRecord);\n            }\n        }\n\n        /**\n         * Group expanded or collapsed\n         * @event toggleGroup\n         * @on-owner\n         * @param {Core.data.Model} groupRecord Group record\n         * @param {Boolean} collapse Collapsed (true) or expanded (false)\n         */\n        grid.trigger('toggleGroup', { groupRecord, collapse });\n        grid.afterToggleGroup();\n    }\n\n    /**\n     * Collapse all groups. This function is exposed on Grid and can thus be called as `grid.collapseAll()`\n     * @on-owner\n     */\n    collapseAll() {\n        const me = this;\n        if (me.store.isGrouped && !me.disabled) {\n            me.store.groupRecords.forEach(r => me.internalToggleCollapse(r, true, true));\n            me.grid.refreshRows(true);\n        }\n    }\n\n    /**\n     * Expand all groups. This function is exposed on Grid and can thus be called as `grid.expandAll()`\n     * @on-owner\n     */\n    expandAll() {\n        const me = this;\n        if (me.store.isGrouped && !me.disabled) {\n            me.store.groupRecords.forEach(r => me.internalToggleCollapse(r, false, true));\n            me.grid.refreshRows();\n        }\n    }\n\n    //endregion\n\n    //region Rendering\n\n    /**\n     * Called before rendering row contents, used to reset rows no longer used as group rows\n     * @private\n     */\n    onBeforeRenderRow({ row }) {\n        // row.id contains previous record id on before render\n        const oldRecord    = row.grid.store.getById(row.id);\n        // force update of inner html if this row used for group data\n        row.forceInnerHTML = row.forceInnerHTML || oldRecord?.isGroupHeader;\n    }\n\n    /**\n     * Called when a cell is rendered, styles the group rows first cell.\n     * @private\n     */\n    renderCell(renderData) {\n        const\n            me         = this,\n            {\n                cellElement,\n                row,\n                column\n            }          = renderData,\n            { meta }   = renderData.record,\n            rowClasses = {\n                'b-group-row'            : 0,\n                'b-grid-group-collapsed' : 0\n            };\n\n        if (!me.disabled && me.store.isGrouped && 'groupRowFor' in meta) {\n            // do nothing with action column to make possible using actions for groups\n            if (column.type === 'action') {\n                return;\n            }\n            // let column clear the cell, in case it needs to do some cleanup\n            column.clearCell(cellElement);\n\n            // this is a group row, add css classes\n            rowClasses['b-grid-group-collapsed'] = meta.collapsed;\n            rowClasses['b-group-row']            = 1;\n\n            if (column === me.groupHeaderColumn) {\n                cellElement.classList.add('b-group-title');\n                cellElement.$groupHeader = true;\n            }\n\n            me.buildGroupHeader(renderData);\n        }\n        else if (cellElement.$groupHeader) {\n            cellElement.classList.remove('b-group-title');\n            cellElement.$groupHeader = false;\n        }\n\n        // Still need to sync row classes is disabled or not grouped.\n        // Previous b-group-row and b-grid-group-collapsed classes must be removed.\n        row.assignCls(rowClasses);\n    }\n\n    // renderData.cellElement is required\n    buildGroupHeader(renderData) {\n        const\n            me               = this,\n            {\n                record,\n                cellElement,\n                column,\n                persist\n            }                = renderData,\n            { grid }         = me,\n            meta             = record.meta,\n            { groupRowFor }  = meta,\n            { groupSummary } = grid.features,\n            // Need to adjust count if group summary is used\n            // TODO remove this when grouping has been refactored to not store group headers/footers in the Store\n            count            = meta.childCount - (groupSummary && groupSummary.target !== 'header' ? 1 : 0);\n\n        let html         = null,\n            applyDefault = true;\n\n        if (persist || column) {\n            const\n                groupColumn         = grid.columns.get(meta.groupField),\n                isGroupHeaderColumn = renderData.isFirstColumn = column === me.groupHeaderColumn;\n            // First try using columns groupRenderer (might not even have a column if grouping programmatically)\n            if (groupColumn?.groupRenderer) {\n                if (isGroupHeaderColumn) {\n                    // groupRenderer could return nothing and just apply changes directly to DOM element\n                    html = groupColumn.groupRenderer({\n                        ...renderData,\n                        groupRowFor,\n                        groupRecords : record.groupChildren,\n                        groupColumn,\n                        count\n                    });\n\n                    applyDefault = false;\n                }\n            }\n            // Secondly use features groupRenderer, if configured with one\n            else if (me.groupRenderer) {\n                // groupRenderer could return nothing and just apply changes directly to DOM element\n                html = me.groupRenderer({\n                    ...renderData,\n                    groupRowFor,\n                    groupRecords  : record.groupChildren,\n                    groupColumn,\n                    count,\n                    isFirstColumn : isGroupHeaderColumn\n                });\n            }\n\n            // Third, just display unformatted value and child count (also applied for features groupRenderer that do\n            // not output any html of their own)\n            if (isGroupHeaderColumn && html == null && applyDefault && DomHelper.getChildElementCount(cellElement) === 0) {\n                html = StringHelper.encodeHtml(`${groupRowFor === '__novalue__' ? '' : groupRowFor} (${count})`);\n            }\n        }\n        else if (me.groupRenderer) {\n            // groupRenderer could return nothing and just apply changes directly to DOM element\n            html = me.groupRenderer(renderData);\n        }\n\n        // Renderers could return nothing and just apply changes directly to DOM element\n        if (typeof html === 'string') {\n            cellElement.innerHTML = html;\n        }\n        else if (typeof html === 'object') {\n            DomSync.sync({\n                targetElement : cellElement,\n                domConfig     : {\n                    onlyChildren : true,\n                    children     : ArrayHelper.asArray(html)\n                }\n            });\n        }\n\n        // If groupRenderer added elements to the cell, we need to remember that to clear it on re-usage as a normal cell\n        if (DomHelper.getChildElementCount(cellElement) > 0) {\n            cellElement._hasHtml = true;\n        }\n\n        return cellElement.innerHTML;\n    }\n\n    get groupHeaderColumn() {\n        return this.grid.columns.visibleColumns.find(column => !column.groupHeaderReserved);\n    }\n\n    /**\n     * Called when an header is rendered, adds grouping icon if grouped by that column.\n     * @private\n     * @param headerContainerElement\n     */\n    renderHeader(headerContainerElement) {\n        const { store, grid } = this;\n\n        if (store.isGrouped) {\n            // Sorted from start, reflect in rendering\n            for (const groupInfo of store.groupers) {\n                // Might be grouping by field without column, which is valid\n                const\n                    column = grid.columns.get(groupInfo.field),\n                    header = column && grid.getHeaderElement(column.id);\n\n                header?.classList.add('b-group', groupInfo.ascending ? 'b-asc' : 'b-desc');\n            }\n        }\n    }\n\n    //endregion\n\n    //region Context menu\n\n    /**\n     * Supply items for headers context menu.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateHeaderMenu({ column, items }) {\n        const me = this;\n\n        if (column.groupable !== false) {\n\n            items.groupAsc = {\n                text        : 'L{groupAscending}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-group-asc',\n                cls         : 'b-separator',\n                weight      : 400,\n                disabled    : me.disabled,\n                onItem      : () => me.store.group(column.field, true)\n            };\n\n            items.groupDesc = {\n                text        : 'L{groupDescending}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-group-desc',\n                weight      : 410,\n                disabled    : me.disabled,\n                onItem      : () => me.store.group(column.field, false)\n            };\n        }\n\n        if (me.store.isGrouped) {\n            items.groupRemove = {\n                text        : 'L{stopGrouping}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-clear',\n                cls         : column.groupable ? '' : 'b-separator',\n                weight      : 420,\n                disabled    : me.disabled,\n                onItem      : () => me.store.clearGroupers()\n            };\n        }\n    }\n\n    /**\n     * Supply items to ColumnDragToolbar\n     * @private\n     */\n    getColumnDragToolbarItems(column, items) {\n        const\n            me                  = this,\n            { store, disabled } = me;\n\n        items.push({\n            text        : 'L{groupAscendingShort}',\n            group       : 'L{group}',\n            localeClass : me,\n            icon        : 'b-icon b-icon-group-asc',\n            ref         : 'groupAsc',\n            cls         : 'b-separator',\n            weight      : 110,\n            disabled,\n            onDrop      : ({ column }) => store.group(column.field, true)\n        });\n\n        items.push({\n            text        : 'L{groupDescendingShort}',\n            group       : 'L{group}',\n            localeClass : me,\n            icon        : 'b-icon b-icon-group-desc',\n            ref         : 'groupDesc',\n            weight      : 110,\n            disabled,\n            onDrop      : ({ column }) => store.group(column.field, false)\n        });\n\n        const grouped = store.groupers?.some(col => col.field === column.field) && !disabled;\n        items.push({\n            text        : 'L{stopGroupingShort}',\n            group       : 'L{group}',\n            localeClass : me,\n            icon        : 'b-icon b-icon-clear',\n            ref         : 'groupRemove',\n            disabled    : !grouped,\n            weight      : 110,\n            onDrop      : ({ column }) => store.removeGrouper(column.field)\n        });\n\n        return items;\n    }\n\n    //endregion\n\n    //region Events - Store\n\n    /**\n     * Called when store grouping changes. Reflects on header and rerenders rows.\n     * @private\n     */\n    onStoreGroup({ groupers }) {\n        const\n            { grid }        = this,\n            { element }     = grid,\n            curGroupHeaders = element && DomHelper.children(element, '.b-grid-header.b-group');\n\n        if (element) {\n            for (const header of curGroupHeaders) {\n                header.classList.remove('b-group', 'b-asc', 'b-desc');\n            }\n\n            if (groupers) {\n                for (const groupInfo of groupers) {\n                    const header = grid.getHeaderElementByField(groupInfo.field);\n                    if (header) {\n                        header.classList.add('b-group', groupInfo.ascending ? 'b-asc' : 'b-desc');\n                    }\n                }\n            }\n        }\n    }\n\n    onStoreChange({ action, records }) {\n        const\n            { client }            = this,\n            { rowManager, store } = client;\n\n        if (store.isGrouped && action === 'move') {\n            const\n                { field } = store.groupers[0],\n                fromRow   = Math.min(...records.reduce((result, record) => {\n                    // Get index of the new group\n                    result.push(store.indexOf(record.instanceMeta(store).groupParent));\n\n                    // Get index of the old group\n                    if (field in record.meta.modified) {\n                        const oldGroup = store.groupRecords.find(r => r.meta.groupRowFor === record.meta.modified[field]);\n\n                        if (oldGroup) {\n                            result.push(store.indexOf(oldGroup));\n                        }\n                    }\n\n                    return result;\n                }, []));\n\n            rowManager.renderFromRow(rowManager.getRow(fromRow));\n        }\n    }\n\n    //endregion\n\n    //region Events - Grid\n\n    /**\n     * Store touches when user touches header, used in onElementTouchEnd.\n     * @private\n     */\n    onElementTouchStart(event) {\n        const\n            me         = this,\n            { target } = event,\n            header     = target.closest('.b-grid-header'),\n            column     = header && me.grid.getColumnFromElement(header);\n\n        // If it's a multi touch, group.\n        if (event.touches.length > 1 && column && column.groupable !== false && !me.disabled) {\n            me.store.group(column.field);\n        }\n    }\n\n    /**\n     * React to click on headers (to group by that column if [alt] is pressed) and on group rows (expand/collapse).\n     * @private\n     * @param event\n     * @returns {Boolean}\n     */\n    onElementClick(event) {\n        const\n            me         = this,\n            { store }  = me,\n            { target } = event,\n            row        = target.closest('.b-group-row'),\n            header     = target.closest('.b-grid-header'),\n            field      = header?.dataset.column;\n\n        // prevent expand/collapse if disabled or clicked on item with own handler\n        if (\n            target.classList.contains('b-resizer') ||\n            me.disabled ||\n            target.classList.contains('b-action-item') ||\n            event.handled\n        ) {\n            return;\n        }\n\n        // Header\n        if (header && field) {\n            const columnGrouper = store.groupers?.find(g => g.field === field);\n\n            // Store has a grouper for this column's field; flip grouper order\n            if (columnGrouper && !event.shiftKey) {\n                store.group(field, !columnGrouper.ascending);\n                return false;\n            }\n            // Group or ungroup\n            else if (event.shiftKey) {\n                const column = me.grid.columns.get(field);\n\n                if (column.groupable !== false) {\n                    if (event.altKey) {\n                        store.removeGrouper(field);\n                    }\n                    else {\n                        store.group(field);\n                    }\n                }\n            }\n        }\n\n        // Anywhere on group-row\n        if (row) {\n            me.internalToggleCollapse(DomDataStore.get(row).id);\n            return false;\n        }\n    }\n\n    /**\n     * Toggle groups with [space].\n     * @private\n     * @param event\n     */\n    toggleGroup(event) {\n        const\n            { grid }        = this,\n            { focusedCell } = grid;\n\n        // only catch space when focus is on a group header cell\n        if (!this.disabled && !focusedCell.isActionable && focusedCell.record?.isGroupHeader) {\n            this.internalToggleCollapse(focusedCell.id);\n\n            // Other features (like context menu) must not process this.\n            return true;\n        }\n        return false;\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(Group, true, ['Grid', 'Scheduler']);\nGridFeatureManager.registerFeature(Group, false, ['TreeGrid']);\n","import ContextMenuBase from '../../Core/feature/base/ContextMenuBase.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n\n/**\n * @module Grid/feature/HeaderMenu\n */\n\n/**\n * Right click column header or focus it and press SPACE key to show the context menu for headers.\n *\n * ### Default header menu items\n *\n * The Header menu has no default items provided by the `HeaderMenu` feature, but there are other features\n * that populate the header menu with the following items:\n *\n * | Reference         | Text                              | Weight | Feature                                        | Description                                       |\n * |-------------------|-----------------------------------|--------|------------------------------------------------|---------------------------------------------------|\n * | `filter`          | Filter                            | 100    | {@link Grid.feature.Filter Filter}             | Shows the filter popup to add a filter            |\n * | `editFilter`      | Edit filter                       | 100    | {@link Grid.feature.Filter Filter}             | Shows the filter popup to change/remove a filter  |\n * | `removeFilter`    | Remove filter                     | 110    | {@link Grid.feature.Filter Filter}             | Stops filtering by selected column field          |\n * | `toggleFilterBar` | Hide filter bar / Show filter bar | 120    | {@link Grid.feature.FilterBar FilterBar}       | Toggles filter bar visibility                     |\n * | `columnPicker`    | Columns                           | 200    | {@link Grid.feature.ColumnPicker ColumnPicker} | Shows a submenu to control columns visibility     |\n * | \\>column.id*      | column.text*                      |        | {@link Grid.feature.ColumnPicker ColumnPicker} | Check item to hide/show corresponding column      |\n * | `hideColumn`      | Hide column                       | 210    | {@link Grid.feature.ColumnPicker ColumnPicker} | Hides selected column                             |\n * | `rename`          | Rename column text                | 215    | {@link Grid.feature.ColumnRename ColumnRename} | Edits the header text of the column               |\n * | `toggleCollapse`  | Collapse column / Expand column   | 215    | This feature                                   | Expands or collapses a collapsible column         |\n * | `movePrev  `      | Move previous                     | 220    | This feature                                   | Moves selected column before its previous sibling |\n * | `moveNext`        | Move next                         | 230    | This feature                                   | Moves selected column after its next sibling      |\n * | `sortAsc`         | Sort ascending                    | 300    | {@link Grid.feature.Sort Sort}                 | Sort by the column field in ascending order       |\n * | `sortDesc`        | Sort descending                   | 310    | {@link Grid.feature.Sort Sort}                 | Sort by the column field in descending order      |\n * | `multiSort`       | Multi sort                        | 320    | {@link Grid.feature.Sort Sort}                 | Shows a submenu to control multi-sorting          |\n * | \\>`addSortAsc`    | Add ascending sorting             | 330    | {@link Grid.feature.Sort Sort}                 | Adds ascending sorter using the column field      |\n * | \\>`addSortDesc`   | Add descending sorting            | 340    | {@link Grid.feature.Sort Sort}                 | Adds descending sorter using the column field     |\n * | \\>`removeSorter`  | Remove sorter                     | 350    | {@link Grid.feature.Sort Sort}                 | Stops sorting by selected column field            |\n * | `groupAsc`        | Group ascending                   | 400    | {@link Grid.feature.Group Group}               | Group by the column field in ascending order      |\n * | `groupDesc`       | Group descending                  | 410    | {@link Grid.feature.Group Group}               | Group by the column field in descending order     |\n * | `groupRemove`     | Stop grouping                     | 420    | {@link Grid.feature.Group Group}               | Stops grouping                                    |\n * | `mergeCells`      | Merge cells                       | 500    | {@link Grid.feature.MergeCells}                | Merge cells with same value in a sorted column    |\n *\n * \\* - items that are generated dynamically\n *\n * \\> - first level of submenu\n *\n * ### Customizing the menu items\n *\n * The menu items in the Header menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * Add extra items for all columns:\n *\n * ```javascript\n * const grid = new Grid({\n *   features : {\n *     headerMenu : {\n *       items : {\n *         extraItem : { text: 'My header item', icon: 'fa fa-car', weight: 200, onItem : () => ... }\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * It is also possible to add items using columns config. See examples below.\n *\n * Add extra items for a single column:\n *\n * ```javascript\n * const grid = new Grid({\n *   columns: [\n *     {\n *       field: 'name',\n *       text: 'Name',\n *       headerMenuItems: {\n *         columnItem : { text: 'My unique header item', icon: 'fa fa-flask', onItem : () => ... }\n *       }\n *     }\n *   ]\n * });\n * ```\n *\n * Remove built in item:\n *\n * ```javascript\n * const grid = new Grid({\n *   features : {\n *     headerMenu : {\n *       items : {\n *          // Hide 'Stop grouping'\n *          groupRemove : false\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * Customize built in item:\n *\n * ```javascript\n * const grid = new Grid({\n *   features : {\n *     headerMenu : {\n *       items : {\n *          hideColumn : {\n *              text : 'Bye bye column'\n *          }\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * Remove nested menu item:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         headerMenu : {\n *             items : {\n *                 multiSort : {\n *                     menu : { removeSorter : false }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * It is also possible to manipulate the default items and add new items in the processing function:\n *\n * ```javascript\n * const grid = new Grid({\n *   features : {\n *     headerMenu : {\n *       processItems({items, record}) {\n *           if (record.cost > 5000) {\n *              items.myItem = { text : 'Split cost' };\n *           }\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * Full information of the menu customization can be found in the \"Customizing the Cell menu and the Header menu\" guide.\n *\n * This feature is <strong>enabled</strong> by default.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys       | Action               | Action description                              |\n * |------------|----------------------|-------------------------------------------------|\n * | Space      | showContextMenuByKey | Shows context menu for currently focused header |\n * | Ctrl+Space | showContextMenuByKey | Shows context menu for currently focused header |\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * @extends Core/feature/base/ContextMenuBase\n * @demo Grid/contextmenu\n * @classtype headerMenu\n * @feature\n *\n * @inlineexample Grid/feature/HeaderMenu.js\n */\nexport default class HeaderMenu extends ContextMenuBase {\n    //region Config\n\n    static get $name() {\n        return 'HeaderMenu';\n    }\n\n    static get configurable() {\n        return {\n            type : 'header',\n\n            /**\n             * This is a preconfigured set of items used to create the default context menu.\n             *\n             * The `items` provided by this feature are listed in the intro section of this class. You can\n             * configure existing items by passing a configuration object to the keyed items.\n             *\n             * To remove existing items, set corresponding keys to `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         headerMenu : {\n             *             items : {\n             *                 filter        : null,\n             *                 columnPicker  : null\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * See the feature config in the above example for details.\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} items\n             */\n            items : null,\n\n            /**\n             * Configure as `true` to show two extra menu options to move the selected column to either\n             * before its previous sibling, or after its next sibling.\n             *\n             * This is a keyboard-accessible version of drag/drop column reordering.\n             * @config {Boolean}\n             * @category Accessibility\n             */\n            moveColumns : null\n\n            /**\n             * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n             * @config {Object<String,String>} keyMap\n             */\n\n        };\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             *   features         : {\n             *       headerMenu : {\n             *           processItems({ column, items }) {\n             *               // Add or hide existing items here as needed\n             *               items.myAction = {\n             *                   text   : 'Cool action',\n             *                   icon   : 'b-fa b-fa-fw b-fa-ban',\n             *                   onItem : () => console.log('Some coolness'),\n             *                   weight : 300 // Move to end\n             *               };\n             *\n             *               // Hide column picker\n             *               items.columnPicker.hidden = true;\n             *           }\n             *       }\n             *   },\n             * ```\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Grid.column.Column} context.column The current column\n             * @param {Object<String,MenuItemConfig>} context.items An object containing the\n             * {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @config {Function}\n             * @preventable\n             */\n            processItems : null\n        };\n    }\n\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n\n        config.chain.push('populateHeaderMenu');\n\n        return config;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * This event fires on the owning Grid before the context menu is shown for a header.\n     * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.\n     *\n     * Returning `false` from a listener prevents the menu from being shown.\n     *\n     * @event headerMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Column\n     */\n\n    /**\n     * This event fires on the owning Grid after the context menu is shown for a header\n     * @event headerMenuShow\n     * @on-owner\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Column\n     */\n\n    /**\n     * This event fires on the owning Grid when an item is selected in the header context menu.\n     * @event headerMenuItem\n     * @on-owner\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {Grid.column.Column} column Column\n     */\n\n    /**\n     * This event fires on the owning Grid when a check item is toggled in the header context menu.\n     * @event headerMenuToggleItem\n     * @on-owner\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {Grid.column.Column} column Column\n     * @param {Boolean} checked Checked or not\n     */\n\n    //endregion\n\n    //region Menu handlers\n\n    shouldShowMenu(eventParams) {\n        const { column } = eventParams;\n\n        return column && column.enableHeaderContextMenu !== false && column !== this.client.timeAxisColumn;\n    }\n\n    getDataFromEvent(event) {\n        return ObjectHelper.assign(super.getDataFromEvent(event), this.client.getHeaderDataFromEvent(event));\n    }\n\n    populateHeaderMenu({ items, column }) {\n        const me = this;\n\n        if (column) {\n            if (column.headerMenuItems) {\n                ObjectHelper.merge(items, column.headerMenuItems);\n            }\n            if (column.isCollapsible) {\n                const\n                    { collapsed } = column,\n                    icon          = collapsed\n                        ? me.client.rtl ? 'left' : 'right'\n                        : me.client.rtl ? 'right' : 'left';\n\n                items.toggleCollapse = {\n                    weight : 215,\n                    icon   : `b-fw-icon b-icon-collapse-${icon}`,\n                    text   : me.L(collapsed ? 'L{expandColumn}' : 'L{collapseColumn}'),\n                    onItem : () => column.collapsed = !collapsed\n                };\n            }\n\n            if (me.moveColumns) {\n                const\n                    columnToMoveBefore = me.getColumnToMoveBefore(column),\n                    columnToMoveAfter  = me.getColumnToMoveAfter(column);\n\n                if (columnToMoveBefore) {\n                    items.movePrev = {\n                        weight : 220,\n                        icon   : 'b-fw-icon b-icon-column-move-left',\n                        text   : me.L('L{moveBefore}', StringHelper.encodeHtml(columnToMoveBefore.text)),\n                        onItem : () => {\n                            const { parent : oldParent } = column;\n\n                            // If the operation was successful, postprocess. Check for\n                            // parent being empty and set the new region.\n                            if (columnToMoveBefore.parent.insertChild(column, columnToMoveBefore)) {\n                                column.region = columnToMoveBefore.region;\n\n                                // If we have removed the last child, remove the empty group.\n                                // Column#sealed may have vetoed the operation.\n                                if (!oldParent.children?.length) {\n                                    oldParent.remove();\n                                }\n                            }\n                        }\n                    };\n                }\n                if (columnToMoveAfter) {\n                    items.moveNext = {\n                        weight : 230,\n                        icon   : 'b-fw-icon b-icon-column-move-right',\n                        text   : me.L('L{moveAfter}', StringHelper.encodeHtml(columnToMoveAfter.text)),\n                        onItem : () => {\n                            const { parent : oldParent } = column;\n\n                            // If the operation was successful, postprocess. Check for\n                            // parent being empty and set the new region.\n                            if (columnToMoveAfter.parent.insertChild(column, columnToMoveAfter.nextSibling)) {\n                                column.region = columnToMoveAfter.region;\n\n                                // If we have removed the last child, remove the empty group.\n                                // Column#sealed may have vetoed the operation.\n                                if (!oldParent.children?.length) {\n                                    oldParent.remove();\n                                }\n                            }\n                        }\n                    };\n                }\n            }\n        }\n\n        return items;\n    }\n\n    getColumnToMoveBefore(column) {\n        const { previousSibling, parent } = column;\n\n        if (previousSibling) {\n            return previousSibling.children && !column.children ? previousSibling.children[previousSibling.children.length - 1] : previousSibling;\n        }\n\n        // Move to before parent\n        if (!parent.isRoot) {\n            return parent;\n        }\n    }\n\n    getColumnToMoveAfter(column) {\n        const { nextSibling, parent } = column;\n\n        if (nextSibling) {\n            return nextSibling;\n        }\n\n        // Move to before parent\n        if (!parent.isRoot) {\n            return parent;\n        }\n    }\n}\n\nHeaderMenu.featureClass = '';\n\nGridFeatureManager.registerFeature(HeaderMenu, true);\n","//TODO: Allow multisort using multitouch?\n//TODO: UI sort of broken with grouped headers, take a look at groupedheaders demo\n\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport DomClassList from '../../Core/helper/util/DomClassList.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from './GridFeatureManager.js';\n\n/**\n * @module Grid/feature/Sort\n */\n\n/**\n * Allows sorting of grid by clicking (or tapping) headers, also displays which columns grid is sorted by (numbered if\n * using multisort). Use modifier keys for multisorting: [Ctrl/CMD + click] to add sorter, [Ctrl/CMD + Alt + click] to remove sorter.\n * The actual sorting is done by the store, see {@link Core.data.mixin.StoreSort#function-sort Store.sort()}.\n *\n * {@inlineexample Grid/feature/Sort.js}\n *\n * ```javascript\n * // sorting feature is enabled, no default value though\n * const grid = new Grid({\n *     features : {\n *         sort : true\n *     }\n * });\n *\n * // use initial sorting\n * const grid = new Grid({\n *     features : {\n *         sort : 'name'\n *     }\n * });\n *\n * // can also be specified on the store\n * const grid = new Grid({\n *     store : {\n *         sorters : [\n *             { field : 'name', ascending : false }\n *         ]\n *     }\n * });\n *\n * // custom sorting function can also be specified on the store\n * const grid = new Grid({\n *     store : {\n *         sorters : [{\n *             fn : (recordA, recordB) => {\n *                 // apply custom logic, for example:\n *                 return recordA.name.length < recordB.name.length ? -1 : 1;\n *             }\n *         }]\n *     }\n * });\n * ```\n *\n * For info on programmatically handling sorting, see {@link Core.data.mixin.StoreSort StoreSort}:\n *\n * ```javascript\n * const grid = new Grid({ });\n * // Programmatic sorting of the store, Grids rows and UI will be updated\n * grid.store.sort('age');\n * ```\n *\n * Grid columns can define custom sorting functions (see {@link Grid.column.Column#config-sortable Column.sortable}).\n * If this feature is configured with `prioritizeColumns: true`, those functions will also be used when sorting\n * programmatically:\n *\n * ```javascript\n * const grid = new Grid({\n *     columns : [\n *         {\n *             field : 'age',\n *             text : 'Age',\n *             sortable(lhs, rhs) {\n *               // Custom sorting, see Array#sort\n *             }\n *         }\n *     ],\n *\n *     features : {\n *         sort : {\n *             prioritizeColumns : true\n *         }\n *     }\n * });\n *\n * // Sortable fn will also be used when sorting programmatically\n * grid.store.sort('age');\n * ```\n *\n * This feature is **enabled** by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/sorting\n * @classtype sort\n * @feature\n */\nexport default class Sort extends InstancePlugin {\n    //region Config\n\n    static get $name() {\n        return 'Sort';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Enable multi sort\n             * @config {Boolean}\n             * @default\n             */\n            multiSort : true,\n\n            /**\n             * Use custom sorting functions defined on columns also when programmatically sorting by the columns field.\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     columns : [\n             *         {\n             *             field : 'age',\n             *             text : 'Age',\n             *             sortable(lhs, rhs) {\n             *               // Custom sorting, see Array#sort\n             *             }\n             *         }\n             *     ],\n             *\n             *     features : {\n             *         sort : {\n             *             prioritizeColumns : true\n             *         }\n             *     }\n             * });\n             *\n             * grid.store.sort('age');\n             * ```\n             *\n             * @config {Boolean}\n             * @default\n             */\n            prioritizeColumns : false\n        };\n    }\n\n    static get properties() {\n        return {\n            ignoreRe : new RegExp([\n                // Stop this feature from having to know the internals of two other optional features.\n                'b-grid-header-resize-handle',\n                'b-filter-icon'\n            ].join('|')),\n\n            sortableCls   : 'b-sortable',\n            sortedCls     : 'b-sort',\n            sortedAscCls  : 'b-asc',\n            sortedDescCls : 'b-desc'\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    construct(grid, config) {\n        // process initial config into an actual config object\n        config = this.processConfig(config);\n\n        this.grid = grid;\n\n        this.bindStore(this.store);\n\n        super.construct(grid, config);\n    }\n\n    // Sort feature handles special config cases, where user can supply a string or an array of sorters\n    // instead of a normal config object\n    processConfig(config) {\n        if (typeof config === 'string' || Array.isArray(config)) {\n            return {\n                field     : config,\n                ascending : null\n            };\n        }\n\n        return config;\n    }\n\n    // override setConfig to process config before applying it\n    setConfig(config) {\n        super.setConfig(this.processConfig(config));\n    }\n\n    bindStore(store) {\n        this.detachListeners('store');\n\n        store.ion({\n            name       : 'store',\n            beforeSort : 'onStoreBeforeSort',\n            sort       : 'syncHeaderSortState',\n            thisObj    : this\n        });\n    }\n\n    set field(field) {\n        // Use columns sortable config for initial sorting if it is specified\n        const column = this.grid.columns.get(field);\n\n        if (column && typeof column.sortable === 'object') {\n            // Normalization of Store & CollectionSorter differences\n            column.sortable.field = column.sortable.property || field;\n            field = column.sortable;\n        }\n\n        this.store.sort(field, this.ascending);\n    }\n\n    // Avoid caching store, it might change\n    get store() {\n        return this.grid[this.grid.sortFeatureStore];\n    }\n\n    //endregion\n\n    //region Plugin config\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onElementClick', 'populateHeaderMenu', 'getColumnDragToolbarItems', 'renderHeader', 'onPaint', 'bindStore']\n        };\n    }\n\n    //endregion\n\n    //region Headers\n\n    /**\n     * Update headers to match stores sorters (displays sort icon in correct direction on them)\n     * @private\n     */\n    syncHeaderSortState() {\n        const\n            me       = this,\n            { grid } = me;\n\n        if (!grid.hideHeaders && grid.isPainted) {\n            const\n                storeSorters = me.store.sorters,\n                sorterCount  = storeSorters.length,\n                classList    = new DomClassList();\n            let\n                sorter;\n\n            // Sync the sortable, sorted, and sortIndex state of each leaf header element\n            for (const leafColumn of grid.columns.visibleColumns) {\n                const\n                    leafHeader = leafColumn.element,\n                    // TimeAxisColumn in Scheduler has no textWrapper, since it has custom rendering,\n                    // but since it cannot be sorted by anyway lets just ignore it\n                    dataset    = leafColumn.textWrapper?.dataset;\n\n                let sortDirection = 'none';\n\n                // data-sortIndex is 1-based, and only set if there is > 1 sorter.\n                // iOS Safari throws a JS error if the requested delete property is not present.\n                dataset?.sortIndex && delete dataset.sortIndex;\n\n                classList.value = leafHeader.classList;\n\n                if (leafColumn.sortable !== false) {\n                    classList.add(me.sortableCls);\n\n                    sorter = storeSorters.find(sort =>\n                        sort.field === leafColumn.field ||\n                        (sort.sortFn && sort.sortFn === leafColumn.sortable.sortFn)\n                    );\n\n                    if (sorter) {\n                        if (sorterCount > 1 && dataset) {\n                            dataset.sortIndex = storeSorters.indexOf(sorter) + 1;\n                        }\n                        classList.add(me.sortedCls);\n                        if (sorter.ascending) {\n                            classList.add(me.sortedAscCls);\n                            classList.remove(me.sortedDescCls);\n                            sortDirection = 'ascending';\n                        }\n                        else {\n                            classList.add(me.sortedDescCls);\n                            classList.remove(me.sortedAscCls);\n                            sortDirection = 'descending';\n                        }\n                    }\n                    else {\n                        classList.remove(me.sortedCls);\n                        // Not optimal, but easiest way to make sure sort feature does not remove needed classes.\n                        // Better solution would be to use different names for sorting and grouping\n                        if (!classList['b-group']) {\n                            classList.remove(me.sortedAscCls);\n                            classList.remove(me.sortedDescCls);\n                        }\n                    }\n                }\n                else {\n                    classList.remove(me.sortableCls);\n                }\n\n                // Update the element's classList\n                DomHelper.syncClassList(leafHeader, classList);\n                DomHelper.setAttributes(leafHeader, {\n                    'aria-sort' : sortDirection\n                });\n            }\n        }\n    }\n\n    //endregion\n\n    //region Context menu\n\n    /**\n     * Adds sort menu items to header context menu.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateHeaderMenu({ column, items }) {\n        const\n            me        = this,\n            { store } = me,\n            sortBy    = {  ...column.sortable, field : column.field, columnOwned : true };\n\n        if (column.sortable !== false) {\n            items.sortAsc = {\n                text        : 'L{sortAscending}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-sort-asc',\n                cls         : 'b-separator',\n                weight      : 300,\n                disabled    : me.disabled,\n                onItem      : () => store.sort(sortBy, true)\n            };\n\n            items.sortDesc = {\n                text        : 'L{sortDescending}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-sort-desc',\n                weight      : 310,\n                disabled    : me.disabled,\n                onItem      : () => store.sort(sortBy, false)\n            };\n\n            if (me.multiSort && me.grid.columns.records.some(col => col.sortable)) {\n                const sorter = store.sorters.find(s => s.field === column.field || (column.sortable.sortFn && column.sortable.sortFn === s.sortFn));\n\n                items.multiSort = {\n                    text        : 'L{multiSort}',\n                    localeClass : me,\n                    icon        : 'b-fw-icon b-icon-sort',\n                    weight      : 320,\n                    disabled    : me.disabled,\n                    menu        : {\n                        addSortAsc : {\n                            text        : sorter ? 'L{toggleSortAscending}' : 'L{addSortAscending}',\n                            localeClass : me,\n                            icon        : 'b-fw-icon b-icon-sort-asc',\n                            disabled    : sorter && sorter?.ascending,\n                            weight      : 330,\n                            onItem      : () => store.addSorter(sortBy, true)\n                        },\n                        addSortDesc : {\n                            text        : sorter ? 'L{toggleSortDescending}' : 'L{addSortDescending}',\n                            localeClass : me,\n                            icon        : 'b-fw-icon b-icon-sort-desc',\n                            disabled    : sorter && !sorter.ascending,\n                            weight      : 340,\n                            onItem      : () => store.addSorter(sortBy, false)\n                        },\n                        removeSorter : {\n                            text        : 'L{removeSorter}',\n                            localeClass : me,\n                            icon        : 'b-fw-icon b-icon-remove',\n                            weight      : 350,\n                            disabled    : !sorter,\n                            onItem      : () => {\n                                store.removeSorter(sortBy.field);\n                            }\n                        }\n                    }\n                };\n            }\n        }\n    }\n\n    /**\n     * Supply items to ColumnDragToolbar\n     * @private\n     */\n    getColumnDragToolbarItems(column, items) {\n        const\n            me                  = this,\n            { store, disabled } = me;\n\n        if (column.sortable !== false) {\n            const sorter = store.sorters.find(s => s.field === column.field);\n\n            items.push(\n                {\n                    text        : 'L{sortAscendingShort}',\n                    group       : 'L{sort}',\n                    localeClass : me,\n                    icon        : 'b-icon b-icon-sort-asc',\n                    ref         : 'sortAsc',\n                    cls         : 'b-separator',\n                    weight      : 105,\n                    disabled,\n                    onDrop      : ({ column }) => store.sort(column.field, true)\n                },\n                {\n                    text        : 'L{sortDescendingShort}',\n                    group       : 'L{sort}',\n                    localeClass : me,\n                    icon        : 'b-icon b-icon-sort-desc',\n                    ref         : 'sortDesc',\n                    weight      : 105,\n                    disabled,\n                    onDrop      : ({ column }) => store.sort(column.field, false)\n                },\n                {\n                    text        : 'L{addSortAscendingShort}',\n                    group       : 'L{multiSort}',\n                    localeClass : me,\n                    icon        : 'b-icon b-icon-sort-asc',\n                    ref         : 'multisortAddAsc',\n                    disabled    : disabled || (sorter && sorter.ascending),\n                    weight      : 105,\n                    onDrop      : ({ column }) => store.addSorter(column.field, true)\n                }, {\n                    text        : 'L{addSortDescendingShort}',\n                    group       : 'L{multiSort}',\n                    localeClass : me,\n                    icon        : 'b-icon b-icon-sort-desc',\n                    ref         : 'multisortAddDesc',\n                    disabled    : disabled || (sorter && !sorter.ascending),\n                    weight      : 105,\n                    onDrop      : ({ column }) => store.addSorter(column.field, false)\n                }, {\n                    text        : 'L{removeSorterShort}',\n                    group       : 'L{multiSort}',\n                    localeClass : me,\n                    icon        : 'b-icon b-icon-remove',\n                    ref         : 'multisortRemove',\n                    weight      : 105,\n                    disabled    : disabled || !sorter,\n                    onDrop      : ({ column }) => store.removeSorter(column.field)\n                }\n            );\n        }\n        return items;\n    }\n\n    //endregion\n\n    //region Events\n\n    // Intercept sorting by a column that has a custom sorting fn, and inject that fn\n    onStoreBeforeSort({ sorters }) {\n        const { columns } = this.client;\n\n        for (let i = 0; i < sorters.length; i++) {\n            const\n                sorter = sorters[i],\n                column = (sorter.columnOwned || this.prioritizeColumns) && columns.get(sorter.field);\n\n            if (column?.sortable?.sortFn) {\n                sorters[i] = { ...sorter, ...column.sortable, columnOwned : true };\n            }\n        }\n    }\n\n    /**\n     * Clicked on header, sort Store.\n     * @private\n     */\n    onElementClick(event) {\n        const\n            me         = this,\n            { store }  = me,\n            { target } = event,\n            header     = target.closest('.b-grid-header.b-sortable'),\n            field      = header?.dataset.column;\n\n        if (me.ignoreRe.test(target.className) || me.disabled || event.handled) {\n            return;\n        }\n\n        //Header\n        if (header && field) {\n            const\n                column        = me.grid.columns.getById(header.dataset.columnId),\n                columnGrouper = store.isGrouped && store.groupers.find(g => g.field === field);\n\n            // The Group feature will handle the change of the grouper's direction\n            if (columnGrouper && !event.shiftKey) {\n                return;\n            }\n\n            if (column.sortable && !event.shiftKey) {\n                if (event.ctrlKey && event.altKey) {\n                    store.removeSorter(column.field);\n                }\n                else {\n                    const sortBy = {\n                        columnOwned : true,\n                        field       : column.field\n                    };\n\n                    // sortable as a function is handled by onStoreBeforeSort() above\n\n                    if (typeof column.sortable === 'object') {\n                        ObjectHelper.assign(sortBy, column.sortable);\n                    }\n\n                    store.sort(sortBy, null, event.ctrlKey);\n                }\n            }\n        }\n    }\n\n    /**\n     * Called when grid headers are rendered, make headers match current sorters.\n     * @private\n     */\n    renderHeader() {\n        this.syncHeaderSortState();\n    }\n\n    onPaint() {\n        this.syncHeaderSortState();\n    }\n\n    //endregion\n}\n\nSort.featureClass = 'b-sort';\n\nGridFeatureManager.registerFeature(Sort, true);\n","import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\n\n/**\n * @module Grid/feature/Stripe\n */\n\n/**\n * Stripes rows by adding alternating CSS classes to all row elements (`b-even` and `b-odd`).\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @example\n * let grid = new Grid({\n *   features: {\n *     stripe: true\n *   }\n * });\n *\n * @demo Grid/columns\n * @classtype stripe\n * @inlineexample Grid/feature/Stripe.js\n * @feature\n */\nexport default class Stripe extends InstancePlugin {\n\n    static get $name() {\n        return 'Stripe';\n    }\n\n    construct(grid, config) {\n        super.construct(grid, config);\n\n        grid.ion({\n            renderrow : 'onRenderRow',\n            thisObj   : this\n        });\n    }\n\n    doDisable(disable) {\n        if (!this.isConfiguring) {\n            // Refresh rows to add/remove even/odd classes\n            this.client.refreshRows();\n        }\n\n        super.doDisable(disable);\n    }\n\n    /**\n     * Applies even/odd CSS when row is rendered\n     * @param {Grid.row.Row} rowModel\n     * @private\n     */\n    onRenderRow({ row }) {\n        const\n            { disabled } = this,\n            even         = row.dataIndex % 2 === 0;\n\n        row.assignCls({\n            'b-even' : !disabled && even,\n            'b-odd'  : !disabled && !even\n        });\n    }\n}\n\nGridFeatureManager.registerFeature(Stripe);\n","import Base from '../../Core/Base.js';\nimport DomDataStore from '../../Core/data/DomDataStore.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport DomClassList from '../../Core/helper/util/DomClassList.js';\nimport Location from '../util/Location.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\n\n/**\n * @module Grid/row/Row\n */\n\nconst cellContentRange     = document.createRange();\n\n/**\n * Represents a single rendered row in the grid. Consists of one row element for each SubGrid in use. The grid only\n * creates as many rows as needed to fill the current viewport (and a buffer). As the grid scrolls\n * the rows are repositioned and reused, there is not a one-to-one relation between rows and records.\n *\n * For normal use cases you should not have to use this class directly. Rely on using renderers instead.\n * @extends Core/Base\n */\nexport default class Row extends Base {\n\n    static $name = 'Row';\n\n    static get configurable() {\n        return {\n            /**\n             * When __read__, this a {@link Core.helper.util.DomClassList} of class names to be\n             * applied to this Row's elements.\n             *\n             * It can be __set__ using Object notation where each property name with a truthy value is added as\n             * a class, or as a regular space-separated string.\n             *\n             * @member {Core.helper.util.DomClassList} cls\n             * @accepts {Core.helper.util.DomClassList|Object<String,Boolean|Number>}\n             */\n            /**\n             * The class name to initially add to all row elements\n             * @config {String|Core.helper.util.DomClassList|Object<String,Boolean|Number>}\n             */\n            cls : {\n                $config : {\n                    equal : (c1, c2) => c1?.isDomClassList && c2?.isDomClassList && c1.isEqual(c2)\n                }\n            }\n        };\n    }\n\n    //region Init\n\n    /**\n     * Constructs a Row setting its index.\n     * @param {Object} config A configuration object which must contain the following two properties:\n     * @param {Grid.view.Grid} config.grid The owning Grid.\n     * @param {Grid.row.RowManager} config.rowManager The owning RowManager.\n     * @param {Number} config.index The index of the row within the RowManager's cache.\n     * @function constructor\n     * @internal\n     */\n    construct(config) {\n        // Set up defaults and properties\n        Object.assign(this, {\n            _elements      : {},\n            _elementsArray : [],\n            _cells         : {},\n            _allCells      : [],\n            _regions       : [],\n            lastHeight     : 0,\n            lastTop        : -1,\n            _dataIndex     : 0,\n            _top           : 0,\n            _height        : 0,\n            _id            : null,\n            forceInnerHTML : false,\n            isGroupFooter  : false,\n            // Create our cell rendering context\n            cellContext    : new Location({\n                grid        : config.grid,\n                id          : null,\n                columnIndex : 0\n            })\n        });\n\n        super.construct(config);\n\n        // For performance, the element translation method is set at Row consruct time.\n        // The default uses transform : translate(), it can be overridden if rows need\n        // to be positioned using layout, such as when sticky elements are used in cells.\n        if (this.grid.positionMode === 'position') {\n            this.translateElements = this.positionElements;\n        }\n    }\n\n    doDestroy() {\n        const me = this;\n\n        // No need to clean elements up if the entire thing is being destroyed\n        if (!me.rowManager.isDestroying) {\n            me.removeElements();\n\n            if (me.rowManager.idMap[me.id] === me) {\n                delete me.rowManager.idMap[me.id];\n            }\n\n        }\n\n        super.doDestroy();\n    }\n\n    //endregion\n\n    //region Data getters/setters\n\n    /**\n     * Get index in RowManagers rows array\n     * @property {Number}\n     * @readonly\n     */\n    get index() {\n        return this._index;\n    }\n\n    set index(index) {\n        this._index = index;\n    }\n\n    /**\n     * Get/set this rows current index in grids store\n     * @property {Number}\n     */\n    get dataIndex() {\n        return this._dataIndex;\n    }\n\n    set dataIndex(dataIndex) {\n        if (this._dataIndex !== dataIndex) {\n            this._dataIndex = dataIndex;\n            this.eachElement(element => {\n                element.dataset.index = dataIndex;\n                element.ariaRowIndex  = this.grid.hideHeaders ? dataIndex + 1 : dataIndex + 2;\n            });\n        }\n    }\n\n    /**\n     * Get/set id for currently rendered record\n     * @property {String|Number}\n     */\n    get id() {\n        return this._id;\n    }\n\n    set id(id) {\n        const\n            me    = this,\n            idObj = { id },\n            idMap = me.rowManager.idMap;\n\n        if (me._id !== id || idMap[id] !== me) {\n            if (idMap[me._id] === me) delete idMap[me._id];\n            idMap[id] = me;\n\n            me._id = id;\n            me.eachElement(element => {\n                DomDataStore.assign(element, idObj);\n                element.dataset.id = id;\n            });\n            me.eachCell(cell => DomDataStore.assign(cell, idObj));\n        }\n    }\n\n    //endregion\n\n    //region Row elements\n\n    /**\n     * Add a row element for specified region.\n     * @param {String} region Region to add element for\n     * @param {HTMLElement} element Element\n     * @private\n     */\n    addElement(region, element) {\n        const me = this;\n\n        let cellElement = element.firstElementChild;\n\n        me._elements[region] = element;\n        me._elementsArray.push(element);\n        me._regions.push(region);\n        DomDataStore.assign(element, { index : me.index });\n\n        me._cells[region] = [];\n\n        while (cellElement) {\n            me._cells[region].push(cellElement);\n            me._allCells.push(cellElement);\n\n            DomDataStore.set(cellElement, {\n                column     : cellElement.dataset.column, // TODO: dataset is slow, read from columnstore using index instead\n                columnId   : cellElement.dataset.columnId,\n                rowElement : cellElement.parentNode,\n                row        : me\n            });\n\n            cellElement = cellElement.nextElementSibling;\n        }\n\n        // making css selectors simpler, dataset has bad performance but it is only set once and never read\n        element.dataset.index = me.index;\n        element.ariaRowIndex  = me.grid.hideHeaders ? me.index + 1 : me.index + 2;\n    }\n\n    /**\n     * Get the element for the specified region.\n     * @param {String} region\n     * @returns {HTMLElement}\n     */\n    getElement(region) {\n        return this._elements[region];\n    }\n\n    /**\n     * Get the {@link Core.helper.util.Rectangle element bounds} for the specified region of this Row.\n     * @param {String} region\n     * @returns {Core.helper.util.Rectangle}\n     */\n    getRectangle(region) {\n        return Rectangle.from(this.getElement(region));\n    }\n\n    /**\n     * Execute supplied function for each regions element.\n     * @param {Function} fn\n     */\n    eachElement(fn) {\n        this._elementsArray.forEach(fn);\n    }\n\n    /**\n     * Execute supplied function for each cell.\n     * @param {Function} fn\n     */\n    eachCell(fn) {\n        this._allCells.forEach(fn);\n    }\n\n    /**\n     * An object, keyed by region name (for example `locked` and `normal`) containing the elements which comprise the full row.\n     * @type {Object<String,HTMLElement>}\n     * @readonly\n     */\n    get elements() {\n        return this._elements;\n    }\n\n    /**\n     * The row element, only applicable when not using multiple grid sections (see {@link #property-elements})\n     * @type {HTMLElement}\n     * @readonly\n     */\n    get element() {\n        const region = Object.keys(this._elements)[0];\n\n        return this._elements[region];\n    }\n\n    //endregion\n\n    //region Cell elements\n\n    /**\n     * Row cell elements\n     * @property {HTMLElement[]}\n     * @readonly\n     */\n    get cells() {\n        return this._allCells;\n    }\n\n    /**\n     * Get cell elements for specified region.\n     * @param {String} region Region to get elements for\n     * @returns {HTMLElement[]} Array of cell elements\n     */\n    getCells(region) {\n        return this._cells[region];\n    }\n\n    /**\n     * Get the cell element for the specified column.\n     * @param {String|Number} columnId Column id\n     * @returns {HTMLElement} Cell element\n     */\n    getCell(columnId) {\n        return this._allCells.find(cell => {\n            const cellData = DomDataStore.get(cell);\n            // cellData will always have String type, use == to handle a column with Number type\n            return cellData.columnId == columnId || cellData.column == columnId;\n        });\n    }\n\n    removeElements(onlyRelease = false) {\n        const me = this;\n\n        // Triggered before the actual remove to allow cleaning up elements etc.\n        me.rowManager.trigger('removeRow', { row : me });\n\n        if (!onlyRelease) {\n            me.eachElement(element => element.remove());\n        }\n        me._elements = {};\n        me._cells = {};\n        me._elementsArray.length = me._regions.length = me._allCells.length = me.lastHeight = me.height = 0;\n        me.lastTop = -1;\n    }\n\n    //endregion\n\n    //region Height\n\n    /**\n     * Get/set row height\n     * @property {Number}\n     */\n    get height() {\n        return this._height;\n    }\n\n    set height(height) {\n        this._height = height;\n    }\n\n    /**\n     * Get row height including border\n     * @property {Number}\n     */\n    get offsetHeight() {\n        // me.height is specified height, add border height to it to get cells height to match specified rowHeight\n        // border height is measured in Grid#get rowManager\n        return this.height + this.grid._rowBorderHeight;\n    }\n\n    /**\n     * Sync elements height to rows height\n     * @private\n     */\n    updateElementsHeight(isExport) {\n        const me = this;\n\n        if (!isExport) {\n            me.rowManager.storeKnownHeight(me.id, me.height);\n        }\n\n        // prevent unnecessary style updates\n        if (me.lastHeight !== me.height) {\n            this.eachElement(element => element.style.height = `${me.offsetHeight}px`);\n            me.lastHeight = me.height;\n        }\n    }\n\n    //endregion\n\n    //region CSS\n\n    /**\n     * Add CSS classes to each element.\n     * @param {...String|Object<String,Boolean|Number>|Core.helper.util.DomClassList} classes\n     */\n    addCls(classes) {\n        this.updateCls(this.cls.add(classes));\n    }\n\n    /**\n     * Remove CSS classes from each element.\n     * @param {...String|Object<String,Boolean|Number>|Core.helper.util.DomClassList} classes\n     */\n    removeCls(classes) {\n        this.updateCls(this.cls.remove(classes));\n    }\n\n    /**\n     * Toggle CSS classes for each element.\n     * @param {Object<String,Boolean|Number>|Core.helper.util.DomClassList|...String} classes\n     * @param {Boolean} add\n     * @internal\n     */\n    toggleCls(classes, add) {\n        this.updateCls(this.cls[add ? 'add' : 'remove'](classes));\n    }\n\n    /**\n     * Adds/removes class names according to the passed object's properties.\n     *\n     * Properties with truthy values are added.\n     * Properties with false values are removed.\n     * @param {Object<String,Boolean|Number>} classes Object containing properties to set/clear\n     */\n    assignCls(classes) {\n        this.updateCls(this.cls.assign(classes));\n    }\n\n    changeCls(cls) {\n        return cls?.isDomClassList ? cls : new DomClassList(cls);\n    }\n\n    updateCls(cls) {\n        this.eachElement(element => DomHelper.syncClassList(element, cls));\n    }\n\n    setAttribute(attribute, value) {\n        this.eachElement(element => element.setAttribute(attribute, value));\n    }\n\n    removeAttribute(attribute) {\n        this.eachElement(element => element.removeAttribute(attribute));\n    }\n\n    //endregion\n\n    //region Position\n\n    /**\n     * Is this the very first row?\n     * @property {Boolean}\n     * @readonly\n     */\n    get isFirst() {\n        return this.dataIndex === 0;\n    }\n\n    /**\n     * Row top coordinate\n     * @property {Number}\n     * @readonly\n     */\n    get top() {\n        return this._top;\n    }\n\n    /**\n     * Row bottom coordinate\n     * @property {Number}\n     * @readonly\n     */\n    get bottom() {\n        return this._top + this._height + this.grid._rowBorderHeight;\n    }\n\n    /**\n     * Sets top coordinate, translating elements position.\n     * @param {Number} top Top coordinate\n     * @param {Boolean} [silent] Specify `true` to not trigger translation event\n     * @internal\n     */\n    setTop(top, silent) {\n        if (this._top !== top) {\n            this._top = top;\n            this.translateElements(silent);\n        }\n    }\n\n    /**\n     * Sets bottom coordinate, translating elements position.\n     * @param {Number} bottom Bottom coordinate\n     * @param {Boolean} [silent] Specify `true` to not trigger translation event\n     * @private\n     */\n    setBottom(bottom, silent) {\n        this.setTop(bottom - this.offsetHeight, silent);\n    }\n\n    // Used by export feature to position individual row\n    translate(top, silent = false) {\n        this.setTop(top, silent);\n        return top + this.offsetHeight;\n    }\n\n    /**\n     * Sets css transform to position elements at correct top position (translateY)\n     * @private\n     */\n    translateElements(silent) {\n        const\n            me                      = this,\n            { top, _elementsArray } = me;\n\n        if (me.lastTop !== top) {\n            for (let i = 0, { length } = _elementsArray; i < length; i++) {\n                _elementsArray[i].style.transform = `translate(0,${top}px)`;\n            }\n\n            !silent && me.rowManager.trigger('translateRow', { row : me });\n\n            me.lastTop = top;\n        }\n    }\n\n    /**\n     * Sets css top to position elements at correct top position\n     * @private\n     */\n    positionElements(silent) {\n        const\n            me                      = this,\n            { top, _elementsArray } = me;\n\n        if (me.lastTop !== top) {\n            for (let i = 0, { length } = _elementsArray; i < length; i++) {\n                _elementsArray[i].style.top = `${top}px`;\n            }\n\n            !silent && me.rowManager.trigger('translateRow', { row : me });\n\n            me.lastTop = top;\n        }\n    }\n\n    /**\n     * Moves all row elements up or down and updates model.\n     * @param {Number} offsetTop Pixels to offset the elements\n     * @private\n     */\n    offset(offsetTop) {\n        let newTop = this._top + offsetTop;\n\n        // Not allowed to go below zero (won't be reachable on scroll in that case)\n        if (newTop < 0) {\n            offsetTop -= newTop;\n            newTop = 0;\n        }\n        this.setTop(newTop);\n        return offsetTop;\n    }\n\n    //endregion\n\n    //region Render\n\n    /**\n     * Renders a record into this rows elements (trigger event that subgrids catch to do the actual rendering).\n     * @param {Number} recordIndex\n     * @param {Core.data.Model} record\n     * @param {Boolean} [updatingSingleRow]\n     * @param {Boolean} [batch]\n     * @private\n     */\n    render(recordIndex, record, updatingSingleRow = true, batch = false, isExport = false) {\n        const\n            me        = this,\n            {\n                cellContext,\n                cls,\n                elements,\n                cells,\n                grid,\n                rowManager,\n                height         : oldHeight,\n                _id            : oldId\n            }             = me,\n            rowElData     = DomDataStore.get(me._elementsArray[0]),\n            rowHeight     = rowManager._rowHeight,\n            { store }     = grid,\n            { isTree }    = store;\n\n        let i = 0,\n            size;\n\n        // no record specified, try looking up in store (false indicates empty row, don't do lookup\n        if (!record && record !== false) {\n            record = grid.store.getById(rowElData.id);\n            recordIndex = grid.store.indexOf(record);\n        }\n\n        // Bail out if record is not resolved\n        // TODO this happens when resource changes its id\n        // covered w/ 13_view_update.t.js and 14_crudmanager_sharing.t.js in Scheduler\n        if (!record) {\n            return;\n        }\n\n        // Now we have acquired a record, see what classes it requires on the\n        const\n            rCls          = record?.cls,\n            recordCls     = rCls ? (rCls.isDomClassList ? rCls : new DomClassList(rCls)) : null;\n\n        cls.assign({\n            // do not put updating class if we're exporting the row\n            'b-grid-row-updating' : updatingSingleRow && grid.transitionDuration && !isExport,\n            'b-selected'          : grid.isSelected(record?.id),\n            'b-readonly'          : record.readOnly,\n            'b-linked'            : record.isLinked,\n            'b-original'          : record.hasLinks\n        });\n\n        // These are DomClassLists, so they have to have their properties processed by add/remove\n        if (me.lastRecordCls) {\n            cls.remove(me.lastRecordCls);\n        }\n\n        // Assign our record's cls to the row, and cache the value so it can be removed next time round\n        if (recordCls) {\n            cls.add(recordCls);\n            me.lastRecordCls = Object.assign({}, recordCls);\n        }\n        else {\n            me.lastRecordCls = null;\n        }\n\n        // used by GroupSummary feature to clear row before\n        rowManager.trigger('beforeRenderRow', { row : me, record, recordIndex, oldId });\n\n        grid.beforeRenderRow({ row : me, record, recordIndex, oldId });\n\n        // Flush any changes to our DomClassList to the Row's DOM\n        me.updateCls(cls);\n\n        if (updatingSingleRow && grid.transitionDuration && !isExport) {\n            grid.setTimeout(() => {\n                if (!me.isDestroyed) {\n                    cls.remove('b-grid-row-updating');\n                    me.updateCls(cls);\n                }\n            }, grid.transitionDuration);\n        }\n\n        me.id = record.id;\n        me.dataIndex = recordIndex;\n        //<debug>\n        if (me.dataIndex === -1) {\n            throw new Error(`Row's record, id: ${record.id} not found in store`);\n        }\n        //</debug>\n\n        // Configured height, used as row height if renderers do not specify otherwise\n        const height = (!grid.fixedRowHeight && grid.getRowHeight(record)) || rowHeight;\n\n        // Max height returned by renderers\n        let maxRequestedHeight = me.maxRequestedHeight = null;\n\n        // Keep ARIA ownership up to date\n        if (isTree) {\n            for (const region in elements) {\n                const el = elements[region];\n\n                el.id = `${grid.id}-${region}-${me.id}`;\n                DomHelper.setAttributes(el, {\n                    'aria-level'    : record.childLevel + 1,\n                    'aria-setsize'  : record.parent.children.length,\n                    'aria-posinset' : record.parentIndex + 1\n                });\n\n                if (record.isExpanded(store)) {\n                    DomHelper.setAttributes(el, {\n                        'aria-expanded' : true,\n                        // A branch node may be configured expanded, but yet have no children.\n                        // They may be added dynamically.\n                        'aria-owns'     : record.children?.length ? record.children?.map(r => `${grid.id}-${region}-${r.id}`).join(' ') : null\n                    });\n                }\n                else {\n                    if (record.isLeaf) {\n                        el.removeAttribute('aria-expanded');\n                    }\n                    else {\n                        el.setAttribute('aria-expanded', false);\n                    }\n                    el.removeAttribute('aria-owns');\n                }\n            }\n        }\n\n        cellContext._record   = record;\n        cellContext._id       = record.id;\n        cellContext._rowIndex = recordIndex;\n\n        for (i = 0; i < cells.length; i++) {\n            cellContext._columnId          = cells[i].dataset.columnId;\n            cellContext._column            = grid.columns.getById(cellContext._columnId);\n            cellContext._columnIndex       = i;\n            cellContext._cell              = cells[i];\n            cellContext.height             = height;\n            cellContext.maxRequestedHeight = maxRequestedHeight;\n            cellContext.updatingSingleRow  = updatingSingleRow;\n\n            size = me.renderCell(cellContext);\n\n            if (!rowManager.fixedRowHeight) {\n                // We want to make row in all regions as high as the highest cell\n                if (size.height != null) {\n                    maxRequestedHeight = Math.max(maxRequestedHeight, size.height);\n\n                    // Do not store a max height set by schedulers rendering, it has to base its layouts on the\n                    // original row height / that returned by other cells\n                    if (!size.transient) {\n                        me.maxRequestedHeight = maxRequestedHeight;\n                    }\n                }\n            }\n        }\n        const useHeight = maxRequestedHeight ?? height;\n        me.height = grid.processRowHeight(record, useHeight) ?? useHeight;\n\n        // Height gets set during render, reflect on elements\n        me.updateElementsHeight(isExport);\n\n        // Rerendering a row might change its height, which forces translation of all following rows\n        if (updatingSingleRow && !isExport) {\n            if (oldHeight !== me.height) {\n                rowManager.translateFromRow(me, batch);\n            }\n            rowManager.trigger('updateRow', { row : me, record, recordIndex, oldId });\n            rowManager.trigger('renderDone');\n        }\n\n        grid.afterRenderRow({ row : me, record, recordIndex, oldId, oldHeight, isExport });\n\n        rowManager.trigger('renderRow', { row : me, record, recordIndex, oldId, isExport });\n\n        if (oldHeight && me.height !== oldHeight) {\n            rowManager.trigger('rowRowHeight',  { row : me, record, height : me.height, oldHeight });\n        }\n\n        me.forceInnerHTML = false;\n    }\n\n    /**\n     * Renders a single cell, calling features to allow them to hook\n     * @param {Grid.util.Location|HTMLElement} cellContext A {@link Grid.util.Location} which contains rendering\n     * options, or a cell element which can be used to initialize a {@link Grid.util.Location}\n     * @param {Number} [cellContext.height] Configured row height\n     * @param {Number} [cellContext.maxRequestedHeight] Maximum proposed row height from renderers\n     * @param {Boolean} [cellContext.updatingSingleRow] Rendered as part of updating a single row\n     * @param {Boolean} [cellContext.isMeasuring] Rendered as part of a measuring operation\n     * @internal\n     */\n    renderCell(cellContext) {\n        if (!cellContext.isLocation) {\n            cellContext = new Location(cellContext);\n        }\n\n        let {\n            cell : cellElement,\n            record\n        } = cellContext;\n\n        const\n            me              = this,\n            {\n                grid,\n                column,\n                height,\n                maxRequestedHeight,\n                updatingSingleRow = true,\n                isMeasuring = false\n            }               = cellContext,\n            cellEdit        = grid.features?.cellEdit,\n            cellElementData = DomDataStore.get(cellElement),\n            rowElement      = cellElementData.rowElement,\n            rowElementData  = DomDataStore.get(rowElement);\n\n        if (!record) {\n            record = cellContext.record = grid.store.getById(rowElementData.id);\n\n            if (!record) {\n                return;\n            }\n        }\n\n        let cellContent   = column.getRawValue(record);\n\n        const\n            dataField    = record.fieldMap[column.field],\n            size         = { configuredHeight : height, height : null, maxRequestedHeight },\n            cellCls      = column.getCellClass(cellContext),\n            rendererData = {\n                cellElement,\n                dataField,\n                rowElement,\n                value : cellContent,\n                record,\n                column,\n                size,\n                grid,\n                row   : cellElementData.row,\n                updatingSingleRow,\n                isMeasuring\n            },\n            useRenderer  = column.renderer || column.defaultRenderer;\n\n        // Hook to allow processing cell before render, used by QuickFind & MergeCells\n        grid.beforeRenderCell(rendererData);\n\n        // Allow hook to redirect cell output\n        if (rendererData.cellElement !== cellElement) {\n            // Render to redirected target\n            cellElement = rendererData.cellElement;\n        }\n\n        DomHelper.syncClassList(cellElement, cellCls);\n\n        let shouldSetContent = true;\n\n        // By default, `cellContent` is raw value extracted from Record based on Column field.\n        // Call `renderer` if present, otherwise set innerHTML directly.\n        if (useRenderer) {\n            // `cellContent` could be anything here:\n            // - null\n            // - undefined when nothing is returned, used when column modifies cell content, for example Widget column\n            // - number as cell value, to be converted to string\n            // - string as cell value\n            // - string which contains custom DOM element which is handled by Angular after we render it as cell value\n            // - object with special $$typeof property equals to Symbol(react.element) handled by React when JSX is returned\n            // - object which has no special properties but understood by Vue because the column is marked as \"Vue\" column\n            // - object that should be passed to the `DomSync.sync` to update the cell content\n            cellContent = useRenderer.call(column, rendererData);\n\n            if (cellContent === undefined && column.alwaysClearCell === false) {\n                shouldSetContent = false;\n            }\n        }\n        else if (dataField) {\n            cellContent = dataField.print(cellContent);\n        }\n\n        // Check if the cell content is going to be rendered by framework\n        const hasFrameworkRenderer = grid.hasFrameworkRenderer?.({ cellContent, column });\n\n        // This is exceptional case, using framework rendering while grouping is not supported.\n        // Need to reset the content in case of JSX is returned from the renderer.\n        // Normally, if a renderer returns some content, the Grouping feature will overwrite it with the grouped value.\n        // But useRenderer cannot be ignored completely, since a column might want to render additional content to the\n        // grouped row. For example, Action Column may render an action button the grouped row.\n        if (hasFrameworkRenderer && record.isSpecialRow) {\n            cellContent = '';\n        }\n\n        // If present, framework may decide if it wants our renderer to prerender the cell content or not.\n        // In case of normal cells in flat grids, React and Vue perform the full rendering into the root cell element.\n        // But in case of tree cell in tree grids, React and Vue require our renderer to prerender internals,\n        // and they perform rendering into inner \"b-tree-cell-value\" element. This way we can see our expand controls,\n        // bullets, etc.\n        const frameworkPerformsFullRendering = hasFrameworkRenderer && !column.data.tree && !record.isSpecialRow;\n\n        // `shouldSetContent` false means content is already set by the column (i.e. Widget column).\n        // `frameworkPerformsFullRendering` true means full cell content is set by framework renderer.\n        if (shouldSetContent && !frameworkPerformsFullRendering) {\n            let renderTarget = cellElement;\n\n            // If the cell is being edited, we render to a separate div and carefully\n            // insert the contents into a Range which excludes the editor.\n            if (cellEdit?.editorContext?.equals(cellContext) && !cellEdit.editor.isFinishing) {\n                renderTarget = me.moveContentFromCell(cellElement, cellEdit.editor.element);\n            }\n\n            const\n                hasObjectContent = cellContent != null && typeof cellContent === 'object',\n                hasStringContent = typeof cellContent === 'string',\n                text             = (hasObjectContent || cellContent == null) ? '' : String(cellContent);\n\n            // row might be flagged by GroupSummary to require full \"redraw\"\n            if (me.forceInnerHTML) {\n                // To allow minimal updates below, we must remove custom markup inserted by the GroupSummary feature\n                renderTarget.innerHTML = '';\n                // Delete cached content value\n                delete renderTarget._content;\n\n                cellElement.lastDomConfig = null;\n            }\n\n            // display cell contents as text or use actual html?\n            // (disableHtmlEncode set by features that decorate cell contents)\n            if (!hasObjectContent && column.htmlEncode && !column.disableHtmlEncode) {\n                // Set innerText if cell currently has html content.\n                if (cellElement._hasHtml) {\n                    renderTarget.innerText = text;\n                    cellElement._hasHtml = false;\n                }\n                else {\n                    DomHelper.setInnerText(renderTarget, text);\n                }\n            }\n            else {\n                if (column.autoSyncHtml && (!hasStringContent || DomHelper.getChildElementCount(renderTarget))) {\n                    // String content in html column is handled as a html template string\n                    if (hasStringContent) {\n                        // update cell with only changed attributes etc.\n                        DomHelper.sync(text, renderTarget.firstElementChild);\n                    }\n                    // Other content is considered to be a DomHelper config object\n                    else if (hasObjectContent) {\n                        DomSync.sync({\n                            domConfig     : cellContent,\n                            targetElement : renderTarget\n                        });\n                    }\n                }\n                // Consider all returned plain objects to be DomHelper configs for cell content\n                else if (hasObjectContent) {\n                    DomSync.sync({\n                        targetElement : renderTarget,\n                        domConfig     : {\n                            onlyChildren : true,\n                            children     : ArrayHelper.asArray(cellContent)\n                        }\n                    });\n                }\n                // Apply text as innerHTML only if it has changed\n                else if (renderTarget._content !== text) {\n                    renderTarget.innerHTML = renderTarget._content = text;\n                }\n            }\n\n            // If we had to render to a separate div to avoid the cell editor, insert the result now.\n            if (renderTarget !== cellElement) {\n                const { firstChild } = cellElement;\n                for (const node of renderTarget.childNodes) {\n                    cellElement.insertBefore(node, firstChild);\n                }\n            }\n        }\n\n        // If present, framework renders content into the cell element.\n        // Ignore special rows, like grouping.\n        if (!record.isSpecialRow) {\n            // processCellContent is implemented in the framework wrappers\n            grid.processCellContent?.({\n                cellElementData,\n                rendererData,\n                // In case of TreeColumn we should prerender inner cell content like expand controls, bullets, etc\n                // Then the framework renders the content into the nested \"b-tree-cell-value\" element.\n                // rendererHtml is set in TreeColumn.treeRenderer\n                rendererHtml : rendererData.rendererHtml || cellContent\n            });\n        }\n\n        if (column.autoHeight && size.height == null) {\n            cellElement.classList.add('b-measuring-auto-height');\n\n            // Shrinkwrap autoHeight must not allow a row's height to drop below the configured row height\n            size.height = Math.max(cellElement.offsetHeight, grid.rowHeight);\n\n            cellElement.classList.remove('b-measuring-auto-height');\n        }\n\n        if (!isMeasuring) {\n            // Allow others to affect rendering\n            me.rowManager.trigger('renderCell', rendererData);\n        }\n\n        return size;\n    }\n\n    //#region Hooks for salesforce\n\n    moveContentFromCell(cellElement, editorElement) {\n        cellContentRange.setStart(cellElement, 0);\n        cellContentRange.setEndBefore(editorElement);\n\n        const renderTarget = document.createElement('div');\n\n        renderTarget.appendChild(cellContentRange.extractContents());\n\n        return renderTarget;\n    }\n\n    //#endregion\n\n//endregion\n}\n\nRow.initClass();\n","import Widget from '../../Core/widget/Widget.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n\n/**\n * @module Grid/view/Bar\n */\n\n/**\n * Base class used by Header and Footer. Holds an element for each column. Not intended to be used directly.\n *\n * @extends Core/widget/Widget\n * @internal\n * @abstract\n */\nexport default class Bar extends Widget {\n\n    static get $name() {\n        return 'Bar';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'gridbar';\n    }\n\n    static get defaultConfig() {\n        return {\n            htmlCls : '',\n\n            scrollable : {\n                overflowX : 'hidden-scroll'\n            }\n        };\n    }\n\n    //region Init\n\n    get columns() {\n        return this._columns || this.subGrid.columns;\n    }\n\n    // Only needed for tests which create standalone Headers with no owning SubGrid.\n    set columns(columns) {\n        this._columns = columns;\n    }\n\n    //endregion\n\n    /**\n     * Fix cell widths (flex or fixed width) after rendering.\n     * Not a part of template any longer because of CSP\n     * @private\n     */\n    fixCellWidths() {\n        const\n            me          = this,\n            { hasFlex } = me.columns;\n\n        let flexBasis;\n\n        // single header \"cell\"\n        me.columns.traverse(column => {\n            const\n                cellEl      = me.getBarCellElement(column.id),\n                domWidth    = DomHelper.setLength(column.width),\n                domMinWidth = DomHelper.setLength(column.minWidth),\n                domMaxWidth = DomHelper.setLength(column.maxWidth);\n\n            if (cellEl) {\n                flexBasis = domWidth;\n                cellEl.style.maxWidth = domMaxWidth;\n\n                // Parent column without any specified width and flex should have flex calculated if any child has flex\n                if (column.isParent && column.width == null && column.flex == null) {\n                    const flex = column.children.reduce((result, child) => (result += !child.hidden && child.flex || 0), 0);\n\n                    // Do not want to store this flex value on the column since it is always calculated\n                    cellEl.style.flex = flex > 0 ? `${flex} 0 auto` : '';\n\n                    // minWidth might leak from other column when reordering, reset it\n                    cellEl.style.minWidth = null;\n\n                    if (flex > 0) {\n                        // TODO: Figure out a better way of handling this, minWidth on the columns breaks the flexbox\n                        //  calculation compared to cells, making them misalign\n                        column.traverse(col => col.data.minWidth = null);\n                    }\n                }\n                // Normal case, set flex, width etc.\n                else {\n                    if (parseInt(column.minWidth) >= 0) {\n                        cellEl.style.minWidth = domMinWidth;\n                    }\n\n                    // Clear all the things we might have to set to correct cell widths\n                    cellEl.style.flex = cellEl.style.flexBasis = cellEl.style.width = '';\n\n                    if (column.flex) {\n                        // If column has children we need to give it\n                        // flex-shrink: 0, flex-basis: auto so that it always\n                        // shrinkwraps its children without shrinking\n                        if (!isNaN(parseInt(column.flex)) && column.children) {\n                            cellEl.style.flex = `${column.flex} 0 auto`;\n                        }\n                        else {\n                            cellEl.style.flex = column.flex;\n                        }\n                    }\n                    else if (parseInt(column.width) >= 0) {\n                        const parent = column.parent;\n\n                        // Only grid header bar has a notion of group headers\n                        // Column is a child of an unwidthed group. We have to use width\n                        // to stretch it.\n                        if (me.isHeader && !parent.isRoot && !parent.width) {\n                            cellEl.style.width = domWidth;\n                        }\n                        else {\n                            // https://app.assembla.com/spaces/bryntum/tickets/8041\n                            // Column header widths must be set using flex-basis.\n                            // Using width means that wide widths cause a flexed SubGrid\n                            // to bust the flex rules.\n                            // Note that grid in Grid#onColumnsResized and SubGrid#fixCellWidths,\n                            // cells MUST still be sized using width since rows\n                            // are absolutely positioned and will not cause the busting out\n                            // problem, and rows will not stretch to shrinkwrap the cells\n                            // unless they are widthed with width.\n                            cellEl.style.flexBasis = flexBasis;\n                        }\n                    }\n                }\n\n                if (column.height >= 0) {\n                    cellEl.style.height = DomHelper.setLength(column.height);\n                }\n            }\n        });\n\n        me.scrollable.element.classList.toggle('b-has-flex', hasFlex);\n    }\n\n    getLrPadding(cellEl) {\n        if (!this.cellLrPadding) {\n            const s = cellEl.ownerDocument.defaultView.getComputedStyle(cellEl);\n            this.cellLrPadding = parseInt(s.getPropertyValue('padding-left')) + parseInt(s.getPropertyValue('padding-right')) +\n                parseInt(s.getPropertyValue('border-left-width')) + parseInt(s.getPropertyValue('border-right-width'));\n        }\n        return this.cellLrPadding;\n    }\n\n    /**\n     * Get the header or footer cell element for the specified column.\n     * @param {String} columnId Column id\n     * @returns {HTMLElement} Header or footer element, depending on which subclass is in use.\n     * @private\n     */\n    getBarCellElement(columnId) {\n        return this.element.querySelector(`[data-column-id=\"${columnId}\"]`);\n    }\n}\n\n// Register this widget type with its Factory\nBar.initClass();\n","import TemplateHelper from '../../Core/helper/TemplateHelper.js';\nimport Bar from './Bar.js';\n//import styles from '../../../resources/sass/grid/view/footer.scss';\n\n/**\n * @module Grid/view/Footer\n */\n\n/**\n * Grid footer, used by Summary feature. You should not need to create instances manually.\n *\n * @extends Grid/view/Bar\n * @internal\n */\nexport default class Footer extends Bar {\n\n    static get $name() {\n        return 'Footer';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'gridfooter';\n    }\n\n    get subGrid() {\n        return this._subGrid;\n    }\n\n    set subGrid(subGrid) {\n        this._subGrid = this.owner = subGrid;\n    }\n\n    refreshContent() {\n        this.element.firstElementChild.innerHTML = this.contentTemplate();\n        this.fixFooterWidths();\n    }\n\n    onPaint({ firstPaint }) {\n        if (firstPaint) {\n            this.refreshContent();\n        }\n    }\n\n    template() {\n        const region = this.subGrid.region;\n\n        return TemplateHelper.tpl`\n            <div class=\"b-grid-footer-scroller b-grid-footer-scroller-${region}\" role=\"presentation\">\n                <div data-reference=\"footersElement\" class=\"b-grid-footers b-grid-footers-${region}\" data-region=\"${region}\" role=\"presentation\"></div>\n            </div>\n        `;\n    }\n\n    get overflowElement() {\n        return this.footersElement;\n    }\n\n    //region Getters\n\n    /**\n     * Get the footer cell element for the specified column.\n     * @param {String} columnId Column id\n     * @returns {HTMLElement} Footer cell element\n     */\n    getFooter(columnId) {\n        return this.getBarCellElement(columnId);\n    }\n\n    //endregion\n\n    /**\n     * Footer template. Iterates leaf columns to create content.\n     * Style not included because of CSP. Widths are fixed up in\n     * {@link #function-fixFooterWidths}\n     * @private\n     */\n    contentTemplate() {\n        const me = this;\n\n        return me.columns.visibleColumns.map(column => {\n            return TemplateHelper.tpl`\n                <div\n                    class=\"b-grid-footer ${column.align ? `b-grid-footer-align-${column.align}` : ''} ${column.cls || ''}\"\n                    data-column=\"${column.field || ''}\" data-column-id=\"${column.id}\" data-all-index=\"${column.allIndex}\"\n                    role=\"presentation\">\n                    ${column.footerText || ''}\n                </div>`;\n        }).join('');\n    }\n\n    /**\n     * Fix footer widths (flex or fixed width) after rendering. Not a part of template any longer because of CSP\n     * @private\n     */\n    fixFooterWidths() {\n        this.fixCellWidths();\n    }\n}\n\n// Register this widget type with its Factory\nFooter.initClass();\n","import Rectangle from '../../Core/helper/util/Rectangle.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Row from './Row.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport Location from '../util/Location.js';\n\n/**\n * @module Grid/row/RowManager\n */\n\n/**\n * Virtual representation of the grid, using {@link Grid.row.Row} to represent rows. Plugs into {@link Grid.view.Grid}\n * and exposes the following functions on grid itself:\n * * {@link #function-getRecordCoords()}\n * * {@link #function-getRowById()}\n * * {@link #function-getRow()}\n * * {@link #function-getRowFor()}\n * * {@link #function-getRowFromElement()}\n *\n * @example\n * let row = grid.getRowById(1);\n *\n * @plugin\n * @private\n */\nexport default class RowManager extends InstancePlugin {\n    //region Config\n\n    // Plugin configuration.\n    static get pluginConfig() {\n        return {\n            chain : [\n                'destroy'\n            ],\n            assign : [\n                'rowHeight', 'topRow', 'bottomRow', 'firstVisibleRow', 'lastVisibleRow', 'firstFullyVisibleRow', 'lastFullyVisibleRow',\n                'getRowById', 'getRecordCoords', 'getRow', 'getRowFor', 'getRowFromElement'\n            ]\n        };\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Number of rows to render above current viewport\n             * @config {Number}\n             * @default\n             */\n            prependRowBuffer : 5,\n\n            /**\n             * Number of rows to render below current viewport\n             * @config {Number}\n             * @default\n             */\n            appendRowBuffer : 5,\n\n            /**\n             * Default row height, assigned from Grid at construction (either from config\n             * {@link Grid.view.Grid#config-rowHeight} or CSS). Can be set from renderers\n             * @config {Number}\n             * @default\n             */\n            rowHeight : null,\n\n            /**\n             * Set to `true` to get a small performance boost in applications that uses fixed row height\n             * @config {Boolean}\n             */\n            fixedRowHeight : null,\n\n            autoHeight : false\n        };\n    }\n\n    static get properties() {\n        return {\n            idMap                : {},\n            // TODO: investigate if topIndex can to built away, since topRow is always first in array and has dataIndex??\n            topIndex             : 0,\n            lastScrollTop        : 0,\n            _rows                : [],\n            // Record id -> row height mapping\n            heightMap            : new Map(),\n            // Sum of entries in heightMap\n            totalKnownHeight     : 0,\n            // Will be calculated in `estimateTotalHeight()`, as totalKnownHeight + an estimate for unknown rows\n            _totalHeight         : 0,\n            // Average of the known heights, kept up to date when entries in the heightMap are updated\n            averageRowHeight     : 0,\n            scrollTargetRecordId : null,\n            refreshDetails       : {\n                topRowIndex : 0,\n                topRowTop   : 0\n            }\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    construct(config) {\n        config.grid._rowManager = this;\n\n        super.construct(config.grid, config);\n    }\n\n    // Chained to grids doDestroy\n    doDestroy() {\n        // To remove timeouts\n        this._rows.forEach(row => row.destroy());\n\n        super.doDestroy();\n    }\n\n    /**\n     * Initializes the RowManager with Rows to fit specified height.\n     * @param {Number} height\n     * @param {Boolean} [isRendering]\n     * @private\n     * @category Init\n     */\n    initWithHeight(height, isRendering = false) {\n        const me = this;\n\n        // no valid height, make room for all rows\n        if (me.autoHeight) {\n            height = me.store.allCount * me.preciseRowOffsetHeight;\n        }\n\n        me.viewHeight = height;\n        me.calculateRowCount(isRendering);\n\n        return height;\n    }\n\n    /**\n     * Releases all elements (not from dom), calculates how many are needed, creates those and renders\n     */\n    reinitialize(returnToTop = false) {\n        const me = this;\n\n        // Calculate and correct the amount of rows needed (without triggering render)\n        // Rows which are found to be surplus are destroyed.\n        me.calculateRowCount(false, true, true);\n\n        // If our row range is outside of the store's range, force a return to top\n        if (me.topIndex + me.rowCount - 1 > me.store.count) {\n            returnToTop = true;\n        }\n\n        const top = me.topRow && !returnToTop ? me.topRow.top : 0;\n\n        me.scrollTargetRecordId = null;\n\n        if (returnToTop) {\n            me.topIndex = me.lastScrollTop = 0;\n        }\n\n        const { topRow } = me;\n\n        if (topRow) {\n            // Ensure rendering from the topRow starts at the correct position\n            topRow.dataIndex = me.topIndex;\n            topRow.setTop(top, true);\n        }\n\n        // Need to estimate height in case we have Grid using autoHeight\n        me.estimateTotalHeight();\n\n        me.renderFromRow(topRow);\n    }\n\n    //endregion\n\n    //region Rows\n\n    /**\n     * Add or remove rows to fit row count\n     * @private\n     * @category Rows\n     */\n    matchRowCount(skipRender = false) {\n        const\n            me             = this,\n            { rows, grid } = me,\n            numRows        = rows.length,\n            delta          = numRows - me.rowCount;\n\n        if (delta) {\n            if (delta < 0) {\n                const newRows = [];\n\n                // add rows\n                for (let index = numRows, dataIndex = numRows ? rows[numRows - 1].dataIndex + 1 : 0; index < me.rowCount; index++, dataIndex++) {\n                    newRows.push(new Row({\n                        cls        : grid.rowCls,\n                        rowManager : me,\n                        grid,\n                        index,\n                        dataIndex\n                    }));\n                }\n                rows.push.apply(rows, newRows);\n                // and elements (by triggering event used by SubGrid to add elements)\n                me.trigger('addRows', { rows : newRows });\n\n                if (!skipRender) {\n                    // render\n                    me.renderFromRow(rows[Math.max(0, numRows - 1)]);\n                }\n            }\n            else {\n                // remove rows from bottom\n                const\n                    { focusedCell } = grid,\n                    rowActive       = focusedCell?.id != null && focusedCell?.cell?.contains(DomHelper.getActiveElement(grid)),\n                    removedRows     = rows.splice(numRows - delta, delta);\n\n                if (rowActive) {\n                    // All rows going: move focus up to header to avoid unwanted focusout events.\n                    if (delta === numRows) {\n                        grid.onFocusedRowDerender();\n                    }\n                    // Focus is in the zone that's being removed: move to new last row\n                    else if (me.getRowFor(focusedCell._record)?.index >= rows.length) {\n                        rows[rows.length - 1].cells[focusedCell.columnIndex].focus();\n                    }\n                }\n\n                // trigger event in case some feature needs to cleanup when removing (widget column might be interested)\n                me.trigger('removeRows', { rows : removedRows });\n\n                removedRows.forEach(row => row.destroy());\n                // no need to rerender or such when removing from bottom. all is good :)\n            }\n        }\n    }\n\n    /**\n     * Calculates how many rows fit in the available height (view height)\n     * @private\n     * @category Rows\n     */\n    calculateRowCount(skipMatchRowCount = false, allowRowCountShrink = true, skipRender = false) {\n        // TODO: replace prependRowBuffer, appendXX with bufferSize\n        const\n            me                = this,\n            { store }         = me,\n            visibleRowCount   = Math.ceil(me.viewHeight / me.minRowOffsetHeight), // Want whole rows\n            maxRenderRowCount = visibleRowCount + me.prependRowBuffer + me.appendRowBuffer;\n\n        // If RowManager is reinitialized in a hidden state the view might not have a height\n        if (!me.grid.columns?.count || isNaN(visibleRowCount)) {\n            me.rowCount = 0;\n            return 0;\n        }\n\n        // when for example jumping we do not want to remove excess rows,\n        // since we know they are needed at other scroll locations\n        if (maxRenderRowCount < me.rowCount && !allowRowCountShrink) {\n            return me.rowCount;\n        }\n\n        me.visibleRowCount = visibleRowCount;\n        me.rowCount = Math.min(store.count, maxRenderRowCount); // No need for more rows than data\n\n        // If the row count doesn't match the calculated, ensure it matches,\n        if (!skipMatchRowCount) {\n            if (me.rows && me.rowCount !== me.rows.length) {\n                me.matchRowCount(skipRender);\n                // Rows might be pointing to data indices no longer available (when resetting to top topRow is already\n                // adjusted, we don't need to take action here)\n                if (me.bottomRow?.dataIndex >= store.count && me.topRow.dataIndex !== 0) {\n                    const indexDelta = me.bottomRow.dataIndex - store.count + 1;\n                    for (const row of me.rows) {\n                        row.dataIndex -= indexDelta;\n                    }\n                    me.topIndex -= indexDelta;\n                }\n            }\n            else if (!me.rowCount) {\n                me.trigger('changeTotalHeight', { totalHeight : me.totalHeight });\n            }\n            me.grid.toggleEmptyText();\n        }\n\n        return me.rowCount;\n    }\n\n    removeAllRows() {\n        // remove rows from bottom\n        const\n            me         = this,\n            { topRow } = me,\n            result     = topRow ? (me.refreshDetails = {\n                topRowIndex : topRow.dataIndex,\n                topRowTop   : topRow.top\n            }) : me.refreshDetails,\n            removedRows = me.rows.slice();\n\n        // trigger event in case some feature needs to cleanup when removing (widget column might be interested)\n        me.trigger('removeRows', { rows : removedRows });\n\n        me.rows.forEach(row => row.destroy());\n        me.rows.length = 0;\n        me.idMap = {};\n\n        // We return a descriptor of the last rendered block before the remove.\n        // This is primarily for a full GridBase#renderContents to be able to perform a correct refresh.\n        return result;\n    }\n\n    setPosition(refreshDetails) {\n        // Sets up the rendering position for the next call to reinitialize\n        const\n            { topRow }                 = this,\n            { topRowIndex, topRowTop } = refreshDetails;\n\n        topRow.setTop(topRowTop);\n        topRow.dataIndex = topRowIndex;\n    }\n\n    //endregion\n\n    //region Rows - Getters\n\n    get store() {\n        return this.client.store;\n    }\n\n    /**\n     * Get all Rows\n     * @property {Grid.row.Row[]}\n     * @readonly\n     * @category Rows\n     */\n    get rows() {\n        return this._rows;\n    }\n\n    /**\n     * Get the Row at specified index. Returns `undefined` if the row index is not rendered.\n     * @param {Number} index\n     * @returns {Grid.row.Row}\n     * @category Rows\n     */\n    getRow(index) {\n        if (this.rowCount) {\n            return this.rows[index - this.topIndex];\n        }\n    }\n\n    /**\n     * Get Row for specified record id\n     * @param {Core.data.Model|String|Number} recordOrId Record id (or a record)\n     * @returns {Grid.row.Row|null} Found Row or null if record not rendered\n     * @category Rows\n     */\n    getRowById(recordOrId) {\n        if (recordOrId && recordOrId.isModel) {\n            recordOrId = recordOrId.id;\n        }\n\n        return this.idMap[recordOrId];\n    }\n\n    /**\n     * Get a Row from an HTMLElement\n     * @param {HTMLElement} element\n     * @returns {Grid.row.Row|null} Found Row or null if record not rendered\n     * @category Rows\n     */\n    getRowFromElement(element) {\n        element = element.closest('.b-grid-row');\n        return element && this.getRow(element.dataset.index);\n    }\n\n    /**\n     * Get the row at the specified Y coordinate, which is by default viewport-based.\n     * @param {Number} y The `Y` coordinate to find the Row for.\n     * @param {Boolean} [local=false] Pass `true` if the `Y` coordinate is local to the SubGrid's element.\n     * @returns {Grid.row.Row} Found Row or null if no row is rendered at that point.\n     */\n    getRowAt(y, local = false) {\n        // Make it local.\n        if (!local) {\n            // Because this is used with event Y positions which are integers, we must\n            // round the Rectangle to the closest integer.\n            y -= Rectangle.from(this.grid.bodyContainer, null, true).roundPx(1).top;\n\n            // Adjust for scrolling\n            y += this.grid.scrollable.y;\n        }\n        y = DomHelper.roundPx(y);\n\n        return this.rows.find(r => y >= r.top && y < r.bottom);\n    }\n\n    /**\n     * Get a Row for either a record, a record id or an HTMLElement\n     * @param {HTMLElement|Core.data.Model|String|Number} recordOrId Record or record id or HTMLElement\n     * @returns {Grid.row.Row} Found Row or null if record not rendered\n     * @category Rows\n     */\n    getRowFor(recordOrId) {\n        if (recordOrId instanceof HTMLElement) {\n            return this.getRowFromElement(recordOrId);\n        }\n        return this.getRowById(recordOrId);\n    }\n\n    /**\n     * Gets the Row following the specified Row (by index or object). Wraps around the end.\n     * @param {Number|Grid.row.Row} indexOrRow index or Row\n     * @returns {Grid.row.Row}\n     * @category Rows\n     */\n    getNextRow(indexOrRow) {\n        const index = typeof indexOrRow === 'number' ? indexOrRow : indexOrRow.index;\n        return this.getRow((index + 1) % this.rowCount);\n    }\n\n    /**\n     * Get the Row that is currently displayed at top.\n     * @property {Grid.row.Row}\n     * @readonly\n     * @category Rows\n     */\n    get topRow() {\n        return this.rows[0];\n    }\n\n    /**\n     * Get the Row currently displayed furthest down.\n     * @property {Grid.row.Row}\n     * @readonly\n     * @category Rows\n     */\n    get bottomRow() {\n        // TODO: remove when ticket on making sure rowCount is always up to date is fixed\n        const rowCount = Math.min(this.rowCount, this.store.count);\n\n        return this.rows[rowCount - 1];\n    }\n\n    /**\n     * Get the topmost visible Row\n     * @property {Grid.row.Row}\n     * @readonly\n     * @category Rows\n     */\n    get firstVisibleRow() {\n        // Ceil scroll position to make behavior consistent on a scaled display\n        return this.rows.find(r => r.bottom > Math.ceil(this.grid.scrollable.y));\n    }\n\n    get firstFullyVisibleRow() {\n        // Ceil scroll position to make behavior consistent on a scaled display\n        return this.rows.find(r => r.top >= Math.ceil(this.grid.scrollable.y));\n    }\n\n    /**\n     * Get the last visible Row\n     * @property {Grid.row.Row}\n     * @readonly\n     * @category Rows\n     */\n    get lastVisibleRow() {\n        const { grid } = this;\n\n        // We need the last row who's top is inside the scrolling viewport\n        return ArrayHelper.findLast(this.rows, r => r.top < grid.scrollable.y + grid.bodyHeight);\n    }\n\n    get lastFullyVisibleRow() {\n        const { grid } = this;\n\n        // We need the last row who's bottom is inside the scrolling viewport\n        return ArrayHelper.findLast(this.rows, r => r.bottom < grid.scrollable.y + grid.bodyHeight);\n    }\n\n    /**\n     * Calls offset() for each Row passing along offset parameter\n     * @param {Number} offset Pixels to translate Row elements.\n     * @private\n     * @category Rows\n     */\n    offsetRows(offset) {\n        if (offset !== 0) {\n            const\n                { rows }   = this,\n                { length } = rows;\n\n            for (let i = 0; i < length; i++) {\n                rows[i].offset(offset);\n            }\n        }\n\n        this.trigger('offsetRows', { offset });\n    }\n\n    //endregion\n\n    //region Row height\n\n    get prependBufferHeight() {\n        return this.prependRowBuffer * this.rowOffsetHeight;\n    }\n\n    get appendBufferHeight() {\n        return this.appendRowBuffer * this.rowOffsetHeight;\n    }\n\n    // TODO: should support setting rowHeight in em and then convert internally to pixels. 1em = font-size. Not needed for 1.0\n    /**\n     * Set a fixed row height (can still be overridden by renderers) or get configured row height. Setting refreshes all rows\n     * @type {Number}\n     * @on-owner\n     * @category Rows\n     */\n    get rowHeight() {\n        return this._rowHeight;\n    }\n\n    set rowHeight(height) {\n        const\n            me                       = this,\n            { grid, fixedRowHeight } = me,\n            oldHeight                = me.rowHeight;\n\n        // Do not force redraw if row height has not actually changed. Covered by GridState.t\n        if (oldHeight === height) {\n            return;\n        }\n\n        ObjectHelper.assertNumber(height, 'rowHeight');\n\n        if (height < 10) {\n            //<debug>\n            console.warn(`The rowHeight of ${height} was increased to 10 which is the minimum.`);\n            //</debug>\n            height = 10;\n        }\n\n        me.trigger('beforeRowHeight', { height });\n\n        me.minRowHeight = me._rowHeight = height;\n\n        if (fixedRowHeight) {\n            me.averageRowHeight = height;\n        }\n\n        if (me.rows.length) {\n            const\n                oldY       = grid.scrollable.y,\n                topRow     = me.getRowAt(oldY, true),\n                // When changing rowHeight in a scrolled grid, there might no longer be a row at oldY\n                edgeOffset = topRow ? topRow.top - oldY : 0;\n\n            let average, oldAverage;\n\n            // When using fixedRowHeight there is no need to update an average\n            if (fixedRowHeight) {\n                average = height;\n                oldAverage = oldHeight;\n            }\n            else {\n                oldAverage = average = me.averageRowHeight;\n\n                me.clearKnownHeights();\n\n                // Scale the average height in proportion to the row height change\n                average *= height / oldHeight;\n            }\n\n            // Adjust number of rows, since it is only allowed to shrink in refresh()\n            me.calculateRowCount(false, true, true);\n\n            // Reposition the top row since it is used to position the rest\n            me.topRow.setTop(me.topRow.dataIndex * (average + grid._rowBorderHeight), true);\n\n            me.refresh();\n\n            const newY = oldY * (average / oldAverage);\n\n            // Scroll top row to the same position.\n            if (newY !== oldY) {\n                grid.scrollRowIntoView(topRow.id, {\n                    block : 'start',\n                    edgeOffset\n                });\n            }\n        }\n\n        // Note that `rowRowHeight` below is triggered in Row.js, but it needs to be documented here since it is\n        // triggered on the RowManager\n        /**\n         * Triggered when an individual rendered {@link Grid.row.Row} has its height changed.\n         * @event rowRowHeight\n         * @param {Grid.row.RowManager} source The firing RowManager instance.\n         * @param {Grid.row.Row} row The row which is changing.\n         * @param {Core.data.Model} record The row's record.\n         * @param {Number} height The row's new height.\n         * @param {Number} oldHeight The row's old height.\n         * @private\n         */\n        /**\n         * Triggered when the owning Grid's {@link Grid.view.Grid#property-rowHeight} is changed.\n         * @event rowHeight\n         * @param {Grid.row.RowManager} source The firing RowManager instance.\n         * @param {Number} height The RowManager's new default row height.\n         * @param {Number} oldHeight  The RowManager's old default row height.\n         * @private\n         */\n        me.trigger('rowHeight', { height, oldHeight });\n    }\n\n    /**\n     * Get actually used row height, which includes any border and might be an average if using variable row height.\n     * @property {Number}\n     */\n    get rowOffsetHeight() {\n        return Math.floor(this.preciseRowOffsetHeight);\n    }\n\n    get preciseRowOffsetHeight() {\n        return (this.averageRowHeight || this._rowHeight) + this.grid._rowBorderHeight;\n    }\n\n    get minRowOffsetHeight() {\n        return (this.minRowHeight || this._rowHeight) + this.grid._rowBorderHeight;\n    }\n\n    /*\n    * How store CRUD affects the height map:\n    *\n    * | Operation | Result                            |\n    * |-----------|-----------------------------------|\n    * | add       | No. Appears on render             |\n    * | insert    | No. Appears on render             |\n    * | remove    | Remove entry                      |\n    * | removeAll | Clear                             |\n    * | update    | No                                |\n    * | replace   | Height might differ, remove entry |\n    * | move      | No                                |\n    * | filter    | No                                |\n    * | sort      | No                                |\n    * | group     | No                                |\n    * | dataset   | Clear                             |\n    *\n    * The above is handled in GridBase\n    */\n\n    /**\n     * Returns `true` if all rows have a known height. They do if all rows are visited, or if RowManager is configured\n     * with `fixedRowHeight`. If so, all tops can be calculated exactly, no guessing needed\n     * @property {Boolean}\n     * @private\n     */\n    get allHeightsKnown() {\n        return this.fixedRowHeight || this.heightMap.size >= this.store.count;\n    }\n\n    /**\n     * Store supplied `height` using `id` as key in the height map. Called by `Row` when it gets its height.\n     * Keeps `averageRowHeight` and `totalKnownHeight` up to date. Ignored when configured with `fixedRowHeight`\n     * @param {String|Number} id\n     * @param {Number} height\n     * @internal\n     */\n    storeKnownHeight(id, height) {\n        const\n            me = this,\n            { heightMap } = me;\n\n        if (!me.fixedRowHeight) {\n            // Decrease know height with old value\n            if (heightMap.has(id)) {\n                me.totalKnownHeight -= heightMap.get(id);\n            }\n\n            // Height here is \"clientHeight\"\n            heightMap.set(id, height);\n\n            // And increase with new\n            me.totalKnownHeight += height;\n\n            if (height < me.minRowHeight) {\n                me.minRowHeight = height;\n            }\n\n            me.averageRowHeight = me.totalKnownHeight / heightMap.size;\n        }\n    }\n\n    /**\n     * Get the known or estimated offset height for the specified record id\n     * @param {Core.data.Model} record\n     * @returns {Number}\n     * @private\n     */\n    getOffsetHeight(record) {\n        const me = this;\n        // record may not be there if height gets from row with already removed from the store record\n        return ((record && me.heightMap.get(record.id)) || (record && me.grid.getRowHeight(record)) || me.averageRowHeight || me.rowHeight) + me.grid._rowBorderHeight;\n    }\n\n    /**\n     * Invalidate cached height for a record. Removing it from `totalKnownHeight` and factoring it out of\n     * `averageRowHeight`.\n     * @param {Core.data.Model|Core.data.Model[]} records\n     */\n    invalidateKnownHeight(records) {\n        const me = this;\n\n        if (!me.fixedRowHeight) {\n            const { heightMap } = me;\n\n            records = ArrayHelper.asArray(records);\n\n            records.forEach(record => {\n                if (record) {\n                    if (heightMap.has(record.id)) {\n                        // Known height decreases when invalidating\n                        me.totalKnownHeight -= heightMap.get(record.id);\n\n                        heightMap.delete(record.id);\n                    }\n                }\n            });\n\n            me.averageRowHeight = me.totalKnownHeight / heightMap.size;\n        }\n    }\n\n    /**\n     * Invalidates all cached height and resets `averageRowHeight` and `totalKnownHeight`\n     */\n    clearKnownHeights() {\n        this.heightMap.clear();\n        this.averageRowHeight = this.totalKnownHeight = 0;\n    }\n\n    /**\n     * Calculates a row top from its data index. Uses known values from the height map, unknown are substituted with\n     * the average row height. When configured with `fixedRowHeight`, it will always calculate a correct value\n     * @param {Number} index Index in store\n     * @private\n     */\n    calculateTop(index) {\n        // When using fixed row height, life is easy\n        if (this.fixedRowHeight) {\n            return index * this.rowOffsetHeight;\n        }\n\n        const { store } = this;\n\n        let top = 0;\n\n        // When not using fixed row height, we make an educated guess at the top. The more rows have been visited, the\n        // more correct the guess is (fully correct if all rows visited)\n        for (let i = 0; i < index; i++) {\n            const record = store.getAt(i);\n            top += this.getOffsetHeight(record);\n        }\n\n        return Math.floor(top);\n    }\n\n    //endregion\n\n    //region Calculations\n\n    /**\n     * Returns top and bottom for rendered row or estimated coordinates for unrendered.\n     * @param {Core.data.Model|String|Number} recordOrId Record or record id\n     * @param {Boolean} [local] Pass true to get relative record coordinates\n     * @param {Boolean} [roughly] Pass true to allow a less exact but cheaper estimate\n     * @returns {Core.helper.util.Rectangle} Record bounds with format { x, y, width, height, bottom, right }\n     * @category Calculations\n     */\n    getRecordCoords(recordOrId, local = false, roughly = false) {\n        const\n            me  = this,\n            row = me.getRowById(recordOrId);\n\n        let scrollingViewport = me.client._bodyRectangle;\n\n        // _bodyRectangle is not updated on page/containing element scroll etc. Need to make sure it is correct in case\n        // that has happend. This if-statement should be removed when fixing\n        // https://app.assembla.com/spaces/bryntum/tickets/6587-cached-_bodyrectangle-should-be-updated-on--quot-external-quot--scroll/details\n        if (!local) {\n            scrollingViewport = me.client.refreshBodyRectangle();\n        }\n        // Rendered? Then we know position for certain\n        if (row) {\n            return new Rectangle(\n                scrollingViewport.x,\n                local ? Math.round(row.top) : Math.round(row.top + scrollingViewport.y - me.client.scrollable.y),\n                scrollingViewport.width,\n                row.offsetHeight\n            );\n        }\n\n        return me.getRecordCoordsByIndex(me.store.indexOf(recordOrId), local, roughly);\n    }\n\n    /**\n     * Returns estimated top and bottom coordinates for specified row.\n     * @param {Number} recordIndex Record index\n     * @param {Boolean} [local]\n     * @returns {Core.helper.util.Rectangle} Estimated record bounds with format { x, y, width, height, bottom, right }\n     * @category Calculations\n     */\n    getRecordCoordsByIndex(recordIndex, local = false, roughly = false) {\n        const\n            me                    = this,\n            { topRow, bottomRow } = me,\n            scrollingViewport     = me.client._bodyRectangle,\n            { id }                = me.store.getAt(recordIndex),\n            // Not using rowOffsetHeight since it floors the value and that rounding might give big errors far down\n            height                = me.preciseRowOffsetHeight,\n            currentTopIndex       = topRow.dataIndex,\n            currentBottomIndex    = bottomRow.dataIndex,\n            // Instead of estimating top from the very top, use closest known coordinate. Makes sure a coordinate is not\n            // estimated on wrong side of rendered rows, needed to correctly draw dependencies where one event is located\n            // on a unrendered row\n            calculateFrom         =\n                // bottomRow is closest, calculate from it\n                recordIndex > currentBottomIndex\n                    ? { index : recordIndex - currentBottomIndex - 1, y : bottomRow.bottom, from : 'bottomRow' }\n                    //  closer to topRow than 0, use topRow\n                    : recordIndex > currentTopIndex / 2\n                        ? { index : recordIndex - currentTopIndex, y : topRow.top, from : 'topRow' }\n                        // closer to the very top, use it\n                        : { index : recordIndex, y : 0, from : 'top' },\n            top                   = me.allHeightsKnown && !roughly\n                // All heights are known (all rows visited or fixed row height), get actual top coord\n                ? me.calculateTop(recordIndex)\n                // Otherwise estimate\n                : Math.floor(calculateFrom.y + calculateFrom.index * height),\n            result                = new Rectangle(\n                scrollingViewport.x,\n                local ? top : top + scrollingViewport.y - me.client.scrollable.y,\n                scrollingViewport.width,\n                // Either known height or average\n                Math.floor(me.heightMap.get(id) || height)\n            );\n\n        // Signal that it's not based on an element, so is only approximate.\n        // Grid.scrollRowIntoView will have to go round again using the block options below to ensure it's correct.\n        result.virtual = true;\n\n        // When the block becomes visible, scroll it to the logical position using the scrollIntoView's block\n        // option. If it's above, use block: 'start', if below, use block: 'end'.\n        result.block = result.bottom < scrollingViewport.y ? 'start' : (result.y > scrollingViewport.bottom ? 'end' : 'nearest');\n\n        return result;\n    }\n\n    /**\n     * Total estimated grid height (used for scroller)\n     * @property {Number}\n     * @readonly\n     * @category Calculations\n     */\n    get totalHeight() {\n        return this._totalHeight;\n    }\n\n    //endregion\n\n    //region Iteration etc.\n\n    /**\n     * Calls a function for each Row\n     * @param {Function} fn Function that will be called with Row as first parameter\n     * @category Iteration\n     */\n    forEach(fn) {\n        this.rows.forEach(fn);\n    }\n\n    /**\n     * Iterator that allows you to do for (let row of rowManager)\n     * @category Iteration\n     */\n    [Symbol.iterator]() {\n        return this.rows[Symbol.iterator]();\n    }\n\n    //endregion\n\n    //region Scrolling & rendering\n\n    /**\n     * Refresh a single cell.\n     * @param {Core.data.Model} record Record for row holding the cell that should be updated\n     * @param {String|Number} columnId Column id to identify the cell within the row\n     * @returns {Boolean} Returns `true` if cell was found and refreshed, `false` if not\n     */\n    refreshCell(record, columnId) {\n        const cellContext = new Location({ grid : this.grid, record, columnId });\n\n        return Boolean(cellContext.cell && cellContext.row.renderCell(cellContext));\n    }\n\n    /**\n     * Renders from the top of the grid, also resetting scroll to top. Used for example when collapsing all groups.\n     * @category Scrolling & rendering\n     */\n    returnToTop() {\n        const me = this;\n\n        me.topIndex = 0;\n        me.lastScrollTop = 0;\n\n        if (me.topRow) {\n            me.topRow.dataIndex = 0;\n\n            // Force the top row to the top of the scroll range\n            me.topRow.setTop(0, true);\n        }\n\n        me.refresh();\n\n        // Rows rendered from top, make sure grid is scrolled to top also\n        me.grid.scrollable.y = 0;\n    }\n\n    /**\n     * Renders from specified records row and down (used for example when collapsing a group, does not affect rows above).\n     * @param {Core.data.Model} record Record of first row to render\n     * @category Scrolling & rendering\n     */\n    renderFromRecord(record) {\n        const row = this.getRowById(record.id);\n        if (row) {\n            this.renderFromRow(row);\n        }\n    }\n\n    /**\n     * Renders from specified row and down (used for example when collapsing a group, does not affect rows above).\n     * @param {Grid.row.Row} fromRow First row to render\n     * @category Scrolling & rendering\n     */\n    renderFromRow(fromRow = null) {\n        const\n            me              = this,\n            { rows, store } = me,\n            storeCount      = store.count;\n\n        // Calculate row count, adding rows if needed, but do not rerender - we are going to do that below.\n        // Bail out if no rows. Allow removing rows if we have more than store have rows\n        if (me.calculateRowCount(false, storeCount < rows.length, true) === 0) {\n            // Reestimate total height. Possible if all tasks deleted\n            me.estimateTotalHeight(true);\n            return;\n        }\n\n        // render from this row\n        const fromRowIndex = fromRow ? rows.indexOf(fromRow) : 0;\n        // starting either from its specified dataIndex or from its index (happens on first render, no dataIndex yet)\n        let dataIndex = fromRow ? fromRow.dataIndex : rows[0].dataIndex;\n        const\n            // amount of records after this one in store\n            recordsAfter = storeCount - dataIndex - 1,\n            // render to this row, either the last row or the row which will hold the last record available\n            toRowIndex   = Math.min(rows.length - 1, fromRowIndex + recordsAfter);\n        let\n            // amount of rows which wont be rendered below last record (if we have fewer records than topRow + row count)\n            leftOverCount = rows.length - toRowIndex - 1,\n            // Start with top correctly just below the previous row's bottom\n            top           = fromRowIndex > 0 ? rows[fromRowIndex - 1].bottom : rows[fromRowIndex].top,\n            row;\n\n        // _rows array is ordered in display order, just iterate to the end\n        for (let i = fromRowIndex; i <= toRowIndex; i++) {\n            row = rows[i];\n            // Needed in scheduler when translating events, happens before render\n            row.dataIndex = dataIndex;\n            // Silent translation, render will update contents anyway\n            row.setTop(top, true);\n            row.render(dataIndex, store.getAt(dataIndex++), false);\n            top += row.offsetHeight;\n        }\n\n        // if number for records to display has decreased, for example by collapsing a node, we might get unused rows\n        // below bottom. move those to top to not have unused rows laying around\n        while (leftOverCount-- > 0) {\n            me.displayRecordAtTop();\n        }\n\n        // Renderers might yield a lower row height than the configured, leaving blank space at bottom\n        if (me.bottomRow.bottom < me.viewHeight) {\n            me.calculateRowCount();\n        }\n\n        // Reestimate total height\n        me.estimateTotalHeight(true);\n\n        me.trigger('renderDone');\n    }\n\n    /**\n     * Renders the passed array (or [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)) of {@link Grid.row.Row rows}\n     * @param {Grid.row.Row[]|Set} rows The rows to render\n     * @category Scrolling & rendering\n     */\n    renderRows(rows) {\n        let oldHeight,\n            heightChanged = false;\n\n        rows = Array.from(rows);\n\n        // Sort topmost row first\n        rows.sort((a, b) => a.dataIndex - b.dataIndex);\n\n        // Render the requested rows.\n        for (const row of rows) {\n            oldHeight = row.height;\n\n            // Pass updatingSingleRow as false, so that it does not shuffle following\n            // rows downwards on each render. We do that once here after the rows are all refreshed.\n            row.render(null, null, false);\n            heightChanged |= row.height !== oldHeight;\n        }\n\n        // If this caused a height change, shuffle following rows.\n        if (heightChanged) {\n            this.translateFromRow(rows[0]);\n        }\n\n        this.trigger('renderDone');\n    }\n\n    /**\n     * Translates all rows after the specified row. Used when a single rows height is changed and the others should\n     * rearrange. (Called from Row#render)\n     * @param {Grid.row.Row} fromRow\n     * @private\n     * @category Scrolling & rendering\n     */\n    translateFromRow(fromRow, batch = false) {\n        const me = this;\n\n        let top = fromRow.bottom,\n            row, index;\n\n        for (index = fromRow.dataIndex + 1, row = me.getRow(index); row; row = me.getRow(++index)) {\n            top = row.translate(top);\n        }\n\n        // Reestimate total height\n        if (!batch) {\n            me.estimateTotalHeight(true);\n        }\n    }\n\n    /**\n     * Rerender all rows\n     * @category Scrolling & rendering\n     */\n    refresh() {\n        const\n            me         = this,\n            { topRow } = me;\n\n        // too early\n        if (!topRow || me.grid.refreshSuspended) {\n            return;\n        }\n\n        me.idMap = {};\n\n        me.renderFromRow(topRow);\n\n        me.trigger('refresh');\n    }\n\n    /**\n     * Makes sure that specified record is displayed in view\n     * @param newScrollTop Top of visible section\n     * @param [forceRecordIndex] Index of record to display at center\n     * @private\n     * @category Scrolling & rendering\n     */\n    jumpToPosition(newScrollTop, forceRecordIndex) {\n        // There are two very different requirements here.\n        // If there is a forceRecordIndex, that takes precedence to get it into the center of the\n        // viewport, and wherever we render the calculated row block, we may then *adjust the scrollTop*\n        // to get that row to the center.\n        //\n        // If there's no forceRecordIndex, then the scroll position is the primary objective and\n        // we must render what we calculate to be correct at that viewport position.\n\n        const\n            me                    = this,\n            { store, heightMap }  = me,\n            storeCount            = store.count;\n\n        if (me.allHeightsKnown && !me.fixedRowHeight) {\n            const\n                top    = newScrollTop - me.prependBufferHeight,\n                border = me.grid._rowBorderHeight;\n\n            let accumulated = 0,\n                targetIndex = 0;\n\n            while (accumulated < top) {\n                const record = store.getAt(targetIndex);\n\n                accumulated += heightMap.get(record.id) + border;\n\n                targetIndex++;\n            }\n\n            const startIndex = Math.max(Math.min(targetIndex, storeCount - me.rowCount), 0);\n\n            me.lastScrollTop = newScrollTop;\n            me.topRow.dataIndex = me.topIndex = startIndex;\n\n            me.topRow.setTop(me.calculateTop(startIndex), false);\n\n            // render entire buffer\n            me.refresh();\n        }\n        else {\n            const\n                rowHeight      = me.preciseRowOffsetHeight,\n                // Calculate index of the top of the rendered block.\n                // If we are targeting the scrollTop, this will be the top index at the scrollTop minus prepend count.\n                // If we are targeting a recordIndex, this will attempt to place that in the center of the rendered block.\n                targetIndex    = forceRecordIndex == null ? Math.floor(newScrollTop / rowHeight) - me.prependRowBuffer : forceRecordIndex - Math.floor(me.rowCount / 2),\n                startIndex     = Math.max(Math.min(targetIndex, storeCount - me.rowCount), 0),\n                viewportTop    = me.client.scrollable.y,\n                viewportBottom = Math.min(me.client._bodyRectangle.height + viewportTop + me.appendBufferHeight, me.totalHeight);\n\n            me.lastScrollTop = newScrollTop;\n            me.topRow.dataIndex = me.topIndex = startIndex;\n\n            me.topRow.setTop(Math.floor(startIndex * rowHeight), false);\n\n            // render entire buffer\n            me.refresh();\n\n            // TODO: It is likely the approach below will be needed for scrolling in opposite direction also, although no\n            //   problem encountered yet\n\n            // Not filled all the way down?\n            if (me.bottomRow.bottom < viewportBottom) {\n                // Might have jumped into a section of low heights. Needs to be done after the refresh, since heights\n                // are not known before it\n                me.calculateRowCount(false, false, false);\n\n                // Fill with available rows (might be available above buffer because of var row height), stop if we run out of records :)\n                while (me.bottomRow.bottom < viewportBottom && me._rows[me.prependRowBuffer].top < viewportTop && me.bottomRow.dataIndex < storeCount - 1) {\n                    me.displayRecordAtBottom();\n                }\n\n                // TODO: Block below was not needed for current tests, but if row height in one block is enough smaller\n                //  than average row height then we will need to add more rows\n\n                // Still not filled all the way down? Need more rows\n                // if (me.bottomRow.bottom < viewportBottom) {\n                //     //const localAverage = blockHeight / me.rowCount;\n                //     while (me.bottomRow.bottom < viewportBottom) {\n                //        me.addRecordAtBottom();\n                //     }\n                // }\n            }\n\n            me.estimateTotalHeight();\n        }\n\n        // If the row index is our priority, then scroll it into the center\n        if (forceRecordIndex != null) {\n            const\n                { scrollable } = me.grid,\n                targetRow      = me.getRow(forceRecordIndex),\n                // When coming from a block of high rowHeights to one with much lower we might still miss the target...\n                // TODO: Jump again in these cases?\n                rowCenter      = targetRow && Rectangle.from(targetRow._elementsArray[0]).center.y,\n                viewportCenter = scrollable.viewport.center.y;\n\n            // Scroll the targetRow into the center of the viewport\n            if (targetRow) {\n                scrollable.y = newScrollTop = Math.floor(scrollable.y + (rowCenter - viewportCenter));\n            }\n        }\n\n        return newScrollTop;\n    }\n\n    /**\n     * Jumps to a position if it is far enough from current position. Otherwise does nothing.\n     * @private\n     * @category Scrolling & rendering\n     */\n    warpIfNeeded(newScrollTop) {\n        const\n            me     = this,\n            result = { newScrollTop, deltaTop : newScrollTop - me.lastScrollTop };\n\n        // if gap to fill is large enough, better to jump there than to fill row by row\n        if (Math.abs(result.deltaTop) > (me.rowCount * me.rowOffsetHeight) * 3) {\n            // no specific record targeted\n            let index;\n\n            // Specific record specified as target of scroll?\n            if (me.scrollTargetRecordId) {\n                index = me.store.indexOf(me.scrollTargetRecordId);\n\n                // since scroll is happening async record might have been removed after requesting scroll,\n                // in that case we rely on calculated index (as when scrolling without target)\n            }\n\n            // We are jumping, so the focused row will derender\n            me.grid.onFocusedRowDerender();\n\n            // perform the jump and return results\n            result.newScrollTop = me.jumpToPosition(newScrollTop, index);\n            result.deltaTop = 0; // no extra filling needed\n        }\n\n        return result;\n    }\n\n    /**\n     * Handles virtual rendering (only visible rows + buffer are in dom) for rows\n     * @param {Number} newScrollTop The `Y` scroll position for which to render rows.\n     * @param {Boolean} [force=false] Pass `true` to update the rendered row block even if the scroll position has not changed.\n     * @returns {Number} Adjusted height required to fit rows\n     * @private\n     * @category Scrolling & rendering\n     */\n    updateRenderedRows(newScrollTop, force, ignoreError = false) {\n        const\n            me         = this,\n            clientRect = me.client._bodyRectangle;\n\n        // Might be triggered after removing all records, should not crash\n        if (me.rowCount === 0) {\n            return 0;\n        }\n\n        let result = me.totalHeight;\n\n        if (\n            force ||\n            // Only react if we have scrolled by one row or more\n            Math.abs(newScrollTop - me.lastScrollTop) >= me.rowOffsetHeight ||\n            // or if we have a gap at top/bottom (#9375)\n            me.topRow.top > newScrollTop ||\n            me.bottomRow.bottom < newScrollTop + clientRect.height\n        ) {\n            // If scrolled by a large amount, jump instead of rendering each row\n            const posInfo = me.warpIfNeeded(newScrollTop);\n\n            me.scrollTargetRecordId = null;\n\n            // Cache the last correct render scrollTop before fill.\n            // it can be adjusted to hide row position corrections.\n            me.lastScrollTop = posInfo.newScrollTop;\n\n            if (posInfo.deltaTop > 0) {\n                // Scrolling down\n                me.fillBelow(posInfo.newScrollTop);\n            }\n            else if (posInfo.deltaTop < 0) {\n                // Scrolling up\n                me.fillAbove(posInfo.newScrollTop);\n            }\n\n            if (!me.fixedRowHeight && !ignoreError) {\n                me.correctError(posInfo, clientRect, newScrollTop);\n            }\n\n            // Calculate the new height based on new content\n            result = me.estimateTotalHeight();\n        }\n\n        return result;\n    }\n\n    correctError(posInfo, clientRect, newScrollTop) {\n        const me = this;\n\n        let error = 0;\n\n        // TODO: Merge with else, does the same calculation\n        // When we transition from not knowing all heights to doing so, the old estimate will likely have positioned\n        // rows a bit off. Compensate for that here.\n        if (me.allHeightsKnown) {\n            error = me.topRow.top - me.calculateTop(me.topRow.dataIndex);\n        }\n        // If it's a temporary scroll, we can be told to ignore the drift.\n        // Apart from that, we must correct keep the rendered block position correct.\n        // Otherwise, when rolling upwards after a teleport, we may not be able to reach\n        // the top. Some rows may end up at -ve positions.\n        else {\n            // Only correct the rendered block position if we are in danger of running out of scroll space.\n            // That is if we are getting towards the top or bottom of the scroll range.\n            if (\n                // Scrolling up within top zone\n                (posInfo.deltaTop < 0 && newScrollTop < clientRect.height * 2) ||\n                // Scrolling down within bottom zone\n                (posInfo.deltaTop > 0 && newScrollTop > me.totalHeight - clientRect.height * 2 - 3)\n            ) {\n                // TODO: Calc could be eased more, using distance left to have less effect the further away from top/bottom\n                error = me.topRow.top - me.calculateTop(me.topRow.dataIndex); //me.topIndex * me.rowOffsetHeight;\n            }\n        }\n\n        if (error) {\n            // Correct the rendered block position if it's not at the calculated position.\n            // Keep the visual position correct by adjusting the scrollTop by the same amount.\n            // When variable row heights are used, this will keep the rendered block top correct.\n            me.offsetRows(-error);\n            me.grid.scrollable.y = me.lastScrollTop = me.grid.scrollable.y - error;\n        }\n    }\n\n    /**\n     * Moves as many rows from the bottom to the top that are needed to fill to current scroll pos.\n     * @param newTop Scroll position\n     * @private\n     * @category Scrolling & rendering\n     */\n    fillAbove(newTop) {\n        const\n            me         = this,\n            fillHeight = newTop - me.topRow.top - me.prependBufferHeight;\n\n        let accumulatedHeight = 0;\n\n        while (accumulatedHeight > fillHeight && me.topIndex > 0) {\n            // We want to show prev record at top of rows\n            accumulatedHeight -= me.displayRecordAtTop();\n        }\n\n        me.trigger('renderDone');\n    }\n\n    /**\n     * Moves as many rows from the top to the bottom that are needed to fill to current scroll pos.\n     * @param newTop Scroll position\n     * @private\n     * @category Scrolling & rendering\n     */\n    fillBelow(newTop) {\n        const\n            me          = this,\n            fillHeight  = newTop - me.topRow.top - me.prependBufferHeight,\n            recordCount = me.store.count,\n            rowCount    = me.rowCount;\n\n        let accumulatedHeight = 0;\n\n        // Repeat until we have filled empty height\n        while (\n            accumulatedHeight < fillHeight &&         // fill empty height\n            me.topIndex + rowCount < recordCount &&   // as long as we have records left\n            me.topRow.top + me.topRow.offsetHeight < newTop // and do not move top row fully into view (can happen with var row height)\n        ) {\n            // We want to show next record at bottom of rows\n            accumulatedHeight += me.displayRecordAtBottom();\n        }\n\n        me.trigger('renderDone');\n    }\n\n    /**\n     * Estimates height needed to fit all rows, based on average row height. Also offsets rows if needed to not be above\n     * the reachable area of the view.\n     * @param {Boolean} [immediate] Specify true to pass the `immediate` flag on to any listeners (probably only Grid\n     * cares. Used to bypass buffered element resize)\n     * @returns {Number}\n     * @private\n     * @category Scrolling & rendering\n     */\n    estimateTotalHeight(immediate = false) {\n        const me = this;\n\n        if (me.grid.renderingRows) {\n            return;\n        }\n\n        const\n            recordCount   = me.store.count,\n            unknownCount  = recordCount - me.heightMap.size,\n            { bottomRow } = me;\n\n        let estimate;\n\n        // No need to estimate when using fixed row height\n        if (me.fixedRowHeight) {\n            estimate = recordCount * me.rowOffsetHeight;\n        }\n        else {\n            estimate =\n                // Known height, from entries in heightMap\n                me.totalKnownHeight +\n                // Those heights are \"clientHeights\", estimate needs to include borders\n                me.heightMap.size * me.grid._rowBorderHeight +\n                // Add estimate for rows with unknown height\n                unknownCount * me.preciseRowOffsetHeight;\n\n            // No bottomRow yet if estimating initial height in autoHeight grid\n            if (bottomRow && unknownCount) {\n                const bottom = bottomRow.bottom;\n\n                // Too low estimate or reached the end with scroll left, adjust to fit current bottom\n                if (bottom > estimate || (me.topIndex + me.rowCount >= recordCount && estimate > bottom && bottom > 0)) {\n                    estimate = bottom;\n\n                    // estimate all the way down\n                    if (bottomRow.dataIndex < recordCount - 1) {\n                        estimate += (recordCount - 1 - bottomRow.dataIndex) * me.preciseRowOffsetHeight;\n                    }\n                }\n            }\n\n            estimate = Math.floor(estimate);\n        }\n\n        if (estimate !== me.totalHeight) {\n            if (me.trigger('changeTotalHeight', { totalHeight : estimate, immediate }) !== false) {\n                me._totalHeight = estimate;\n            }\n        }\n\n        return estimate;\n    }\n\n    /**\n     * Moves a row from bottom to top and renders the corresponding record to it.\n     * @returns {Number} New row height\n     * @private\n     * @category Scrolling & rendering\n     */\n    displayRecordAtTop() {\n        const\n            me           = this,\n            { grid }     = me,\n            recordIndex  = me.topIndex - 1,\n            record       = me.store.getAt(recordIndex),\n            // Row currently rendered at the bottom, the row we want to move\n            bottomRow    = me.bottomRow,\n            bottomRowTop = bottomRow.top;\n\n        me.trigger('beforeTranslateRow', {\n            row       : bottomRow,\n            newRecord : record\n        });\n\n        // If focused cell is being scrolled off...\n        if (bottomRow.dataIndex === grid.focusedCell?.rowIndex) {\n            grid.onFocusedRowDerender();\n        }\n\n        // estimated top, for rendering that depends on having top\n        bottomRow._top = me.topRow.top - me.getOffsetHeight(record);\n        // if configured with fixed row height, it will be the correct value\n        bottomRow.estimatedTop = !me.fixedRowHeight;\n\n        // Render row\n        bottomRow.render(recordIndex, record, false);\n\n        // Move it to top. Restore top so that the setter won't reject non-change\n        // if the estimate happened to be correct.\n        bottomRow._top = bottomRowTop;\n        bottomRow.setBottom(me.topRow.top);\n        bottomRow.estimatedTop = false;\n\n        // Prev row is now at top\n        me.topIndex--;\n\n        // move to start of array (bottomRow becomes topRow)\n        me._rows.unshift(me._rows.pop());\n\n        return bottomRow.offsetHeight;\n    }\n\n    /**\n     * Moves a row from top to bottom and renders the corresponding record to it.\n     * @returns {Number} New row height\n     * @private\n     * @category Scrolling & rendering\n     */\n    displayRecordAtBottom() {\n        const\n            me          = this,\n            { grid }    = me,\n            recordIndex = me.topIndex + me.rowCount,\n            record      = me.store.getAt(recordIndex),\n            // Row currently rendered on the top, the row we want to move\n            topRow      = me.topRow;\n\n        me.trigger('beforeTranslateRow', {\n            row       : topRow,\n            newRecord : record\n        });\n\n        // If focused cell is being scrolled off...\n        if (topRow.dataIndex === grid.focusedCell?.rowIndex) {\n            grid.onFocusedRowDerender();\n        }\n\n        topRow.dataIndex = recordIndex;\n\n        // Move it to bottom\n        topRow.setTop(me.bottomRow.bottom);\n        // Render row\n        topRow.render(recordIndex, record, false);\n\n        // Next row is now at top\n        me.topIndex++;\n\n        // move to end of array (topRow becomes bottomRow)\n        me._rows.push(me._rows.shift());\n\n        return topRow.offsetHeight;\n    }\n\n    //endregion\n}\n\nRowManager.featureClass = '';\n","import Scroller from '../../Core/helper/util/Scroller.js';\n\n/**\n * @module Grid/util/GridScroller\n */\n\nconst xAxis = {\n    x : 1\n};\n\n/**\n * A Scroller subclass which handles scrolling in a grid.\n *\n * If the grid has no parallel scrolling grids (No locked columns), then this functions\n * transparently as a Scroller.\n *\n * If there are locked columns, then scrolling to an _element_ will invoke the scroller\n * of the subgrid which contains that element.\n * @internal\n */\nexport default class GridScroller extends Scroller {\n    addScroller(scroller) {\n        (this.xScrollers || (this.xScrollers = [])).push(scroller);\n    }\n\n    addPartner(otherScroller, axes = xAxis) {\n        if (typeof axes === 'string') {\n            axes = {\n                [axes] : 1\n            };\n        }\n\n        // Link up all our X scrollers\n        if (axes.x) {\n            // Ensure the other grid has set up its scrollers. This is done on first paint\n            // so may not have been executed yet.\n            otherScroller.owner.initScroll();\n\n            //<debug>\n            if (otherScroller.xScrollers?.length !== this.xScrollers.length) {\n                throw new Error('Grid scrollers can only be synced in the X axis between grids with the same number of SubGrids');\n            }\n            //</debug>\n            this.xScrollers.forEach((scroller, i) => scroller.addPartner(otherScroller.xScrollers[i], 'x'));\n        }\n        // We are the only Y scroller\n        if (axes.y) {\n            super.addPartner(otherScroller, 'y');\n        }\n    }\n\n    removePartner(otherScroller) {\n        this.xScrollers.forEach((scroller, i) => {\n            if (!scroller.isDestroyed) {\n                scroller.removePartner(otherScroller.xScrollers[i]);\n            }\n        });\n\n        super.removePartner(otherScroller);\n    }\n\n    updateOverflowX(overflowX) {\n        const hideScroll = overflowX === false;\n        this.xScrollers?.forEach(s => s.overflowX = hideScroll ? 'hidden' : 'hidden-scroll');\n        this.widget.virtualScrollers.classList.toggle('b-hide-display', hideScroll);\n    }\n\n    scrollIntoView(element, options) {\n        // If we are after an element, we have to ask the scroller of the SubGrid\n        // that the element is in. It will do the X scrolling and delegate the Y\n        // scrolling up to this GridScroller.\n        if (element.nodeType === Element.ELEMENT_NODE && this.element.contains(element)) {\n            for (const subGridScroller of this.xScrollers) {\n                if (subGridScroller.element.contains(element)) {\n                    return subGridScroller.scrollIntoView(element, options);\n                }\n            }\n        }\n        else {\n            return super.scrollIntoView(element, options);\n        }\n    }\n\n    hasOverflow(axis = 'y') {\n        return axis === 'y' ? this.scrollHeight > this.clientHeight : false;\n    }\n\n    set x(x) {\n        if (this.xScrollers) {\n            this.xScrollers[0].x = x;\n        }\n    }\n\n    get x() {\n        // when trying to scroll grid with no columns xScrollers do not exist\n        return this.xScrollers ? this.xScrollers[0].x : 0;\n    }\n}\n","import Bar from './Bar.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\n\n/**\n * @module Grid/view/Header\n */\n\n/**\n * The Grid header, which contains simple columns but also allows grouped columns. One instance is created and used per SubGrid\n * automatically, you should not need to instantiate this class manually. See {@link Grid.column.Column} for information about\n * column configuration.\n *\n * @extends Grid/view/Bar\n * @internal\n *\n * @inlineexample Grid/view/Header.js\n */\nexport default class Header extends Bar {\n    static get $name() {\n        return 'Header';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'gridheader';\n    }\n\n    get subGrid() {\n        return this._subGrid;\n    }\n\n    set subGrid(subGrid) {\n        this._subGrid = this.owner = subGrid;\n    }\n\n    get region() {\n        return this.subGrid?.region;\n    }\n\n    changeElement(element, was) {\n        const { region } = this;\n\n        // Columns must be examined for maxDepth\n        this.getConfig('columns');\n\n        return super.changeElement({\n            className : {\n                'b-grid-header-scroller'             : 1,\n                [`b-grid-header-scroller-${region}`] : region\n            },\n            children : [{\n                reference : 'headersElement',\n                className : {\n                    'b-grid-headers'             : 1,\n                    [`b-grid-headers-${region}`] : region\n                },\n                dataset : {\n                    region,\n                    reference : 'headersElement',\n                    maxDepth  : this.maxDepth\n                }\n            }]\n        }, was);\n    }\n\n    get overflowElement() {\n        return this.headersElement;\n    }\n\n    /**\n     * Recursive column header config creator.\n     * Style not included because of CSP. Widths are fixed up in\n     * {@link #function-fixHeaderWidths}\n     * @private\n     */\n    getColumnConfig(column) {\n        const\n            {\n                id,\n                align,\n                resizable,\n                isLeaf,\n                isParent,\n                isLastInSubGrid,\n                cls,\n                childLevel,\n                field,\n                tooltip,\n                children,\n                isFocusable,\n                grid\n            } = column,\n            // Headers tested standalone - may be no grid\n            focusedCell = grid?.focusedCell,\n            isFocused   = focusedCell?.rowIndex === -1 && focusedCell?.column === column;\n\n        if (column.isVisible) {\n            return {\n                className : {\n                    'b-grid-header'                  : 1,\n                    'b-grid-header-parent'           : isParent,\n                    [`b-level-${childLevel}`]        : 1,\n                    [`b-depth-${column.meta.depth}`] : 1,\n                    [`b-grid-header-align-${align}`] : align,\n                    'b-grid-header-resizable'        : resizable && isLeaf,\n                    [cls]                            : cls,\n                    'b-collapsible'                  : column.collapsible,\n                    'b-last-parent'                  : isParent && isLastInSubGrid,\n                    'b-last-leaf'                    : isLeaf && isLastInSubGrid\n                },\n                role                            : isFocusable ? 'columnheader' : 'presentation',\n                'aria-sort'                     : 'none',\n                'aria-label'                    : column.ariaLabel,\n                [isFocusable ? 'tabIndex' : ''] : isFocused ? 0 : -1,\n                dataset                         : {\n                    ...Tooltip.encodeConfig(tooltip),\n                    columnId                : id,\n                    [field ? 'column' : ''] : field\n                },\n                children : [{\n                    className : 'b-grid-header-text',\n                    children  : [{\n                        [grid && isFocusable ? 'id' : ''] : `${grid?.id}-column-${column.id}`,\n                        className                         : 'b-grid-header-text-content'\n                    }]\n                }, children ? {\n                    className : 'b-grid-header-children',\n                    children  : children.map(child => this.getColumnConfig(child))\n                } : null,\n                {\n                    className : 'b-grid-header-resize-handle'\n                }]\n            };\n        }\n    }\n\n    // used by safari to fix flex when rows width shrink below this value\n    calculateMinWidthForSafari() {\n        let minWidth = 0;\n\n        this.columns.visibleColumns.forEach(column => {\n            minWidth += column.calculateMinWidth();\n        });\n\n        return minWidth;\n    }\n\n    /**\n     * Fix header widths (flex or fixed width) after rendering. Not a part of template any longer because of CSP\n     * @private\n     */\n    fixHeaderWidths() {\n        this.fixCellWidths();\n    }\n\n    refreshHeaders() {\n        const me = this;\n\n        // run renderers, not done from template to work more like cell rendering\n        me.columns.traverse(column => {\n            const headerElement = me.getBarCellElement(column.id);\n\n            if (headerElement) {\n                let html = column.headerText;\n\n                if (column.headerRenderer) {\n                    html = column.headerRenderer.call(column.thisObj || me, { column, headerElement });\n                }\n\n                if (column.headerWidgetMap) {\n                    Object.values(column.headerWidgetMap).forEach(widget => {\n                        widget.render(column.textWrapper);\n                    });\n                }\n\n                if (column.icon) {\n                    html = `<i class=\"${StringHelper.encodeHtml(column.icon)}\"></i>` + (html || '');\n                }\n\n                const innerEl = headerElement.querySelector('.b-grid-header-text-content');\n                if (innerEl) {\n                    innerEl.innerHTML = html || '';\n                }\n            }\n        });\n\n        me.fixHeaderWidths();\n    }\n\n    get columns() {\n        const\n            me     = this,\n            result = super.columns;\n\n        if (!me.columnsDetacher) {\n            // columns is a chained store, it will be repopulated from master when columns change.\n            // That action always triggers change with action dataset.\n            me.columnsDetacher = result.ion({\n                change() {\n                    me.initDepths();\n                },\n                thisObj : me\n            });\n\n            me.initDepths();\n        }\n\n        return result;\n    }\n\n    set columns(columns) {\n        super.columns = columns;\n    }\n\n    /**\n     * Depths are used for styling of grouped headers. Sets them on meta.\n     * @private\n     */\n    initDepths(columns = this.columns.topColumns, parent = null) {\n        const me = this;\n        let maxDepth = 0;\n\n        if (parent?.meta) {\n            parent.meta.depth++;\n        }\n\n        for (const column of columns) {\n            const { meta } = column;\n            // TODO: this should maybe move\n            meta.depth = 0;\n\n            if (column.children) {\n                me.initDepths(column.children.filter(me.columns.chainedFilterFn), column);\n                if (meta.depth && parent) {\n                    parent.meta.depth += meta.depth;\n                }\n            }\n\n            if (meta.depth > maxDepth) {\n                maxDepth = meta.depth;\n            }\n        }\n\n        if (!parent) {\n            me.maxDepth = maxDepth;\n        }\n\n        return maxDepth;\n    }\n\n    //endregion\n\n    //region Getters\n\n    /**\n     * Get the header cell element for the specified column.\n     * @param {String} columnId Column id\n     * @returns {HTMLElement} Header cell element\n     */\n    getHeader(columnId) {\n        return this.getBarCellElement(columnId);\n    }\n\n    //endregion\n\n    get contentElement() {\n        return this.element.firstElementChild;\n    }\n\n    refreshContent() {\n        const me = this;\n\n        DomSync.sync({\n            domConfig : {\n                children         : me.columns.topColumns.map(col => me.getColumnConfig(col)),\n                onlyChildren     : true,\n                strict           : true,\n                syncIdField      : 'columnId',\n                releaseThreshold : 0\n            },\n            targetElement : me.contentElement\n        });\n\n        me.refreshHeaders();\n    }\n\n    onPaint({ firstPaint }) {\n        if (firstPaint) {\n            this.refreshContent();\n        }\n    }\n}\n\n// Register this widget type with its Factory\nHeader.initClass();\n","// We declare consts inside case blocks in this file.\n/* eslint-disable no-case-declarations */\n\n//TODO: Should it fire more own events instead and rely less on function chaining?\n\nimport Base from '../../../Core/Base.js';\nimport DomDataStore from '../../../Core/data/DomDataStore.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport BrowserHelper from '../../../Core/helper/BrowserHelper.js';\nimport Location from '../../util/Location.js';\n\nconst gridBodyElementEventHandlers = {\n        touchstart  : 'onElementTouchStart',\n        touchmove   : 'onElementTouchMove',\n        touchend    : 'onElementTouchEnd',\n        mouseover   : 'onElementMouseOver',\n        mouseout    : 'onElementMouseOut',\n        mousedown   : 'onElementMouseDown',\n        mousemove   : 'onElementMouseMove',\n        mouseup     : 'onElementMouseUp',\n        click       : 'onHandleElementClick',\n        dblclick    : 'onElementDblClick',\n        keyup       : 'onElementKeyUp',\n        keypress    : 'onElementKeyPress',\n        contextmenu : 'onElementContextMenu',\n        pointerdown : 'onElementPointerDown',\n        pointerup   : 'onElementPointerUp'\n    },\n    eventProps = [\n        'pageX',\n        'pageY',\n        'clientX',\n        'clientY',\n        'screenX',\n        'screenY'\n    ];\n\nfunction toggleHover(element, add = true) {\n    element?.classList.toggle('b-hover', add);\n}\n\nfunction setCellHover(columnId, row, add = true) {\n    row && columnId && toggleHover(row.getCell(columnId), add);\n}\n\n/**\n * @module Grid/view/mixin/GridElementEvents\n */\n\n/**\n * Mixin for Grid that handles dom events. Some listeners fire own events but all can be chained by features. None of\n * the functions in this class are indented to be called directly.\n *\n * See {@link Grid.view.Grid} for more information on grid keyboard interaction.\n *\n * @mixin\n */\nexport default Target => class GridElementEvents extends (Target || Base) {\n    static get $name() {\n        return 'GridElementEvents';\n    }\n\n    //region Config\n\n    static get configurable() {\n        return {\n            /**\n             * Time in ms until a longpress is triggered\n             * @prp {Number}\n             * @default\n             * @category Events\n             */\n            longPressTime : 400,\n\n            /**\n             * Set to true to listen for CTRL-Z (CMD-Z on Mac OS) keyboard event and trigger undo (redo when SHIFT is\n             * pressed). Only applicable when using a {@link Core.data.stm.StateTrackingManager}.\n             * @prp {Boolean}\n             * @default\n             * @category Events\n             */\n            enableUndoRedoKeys : true,\n\n            keyMap : {\n                'Ctrl+z'       : 'undoRedoKeyPress',\n                'Ctrl+Shift+z' : 'undoRedoKeyPress',\n                ' '            : { handler : 'clickCellByKey', weight : 1000 }\n            }\n        };\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Fired when user clicks in a grid cell\n     * @event cellClick\n     * @param {Grid.view.Grid} grid The grid instance\n     * @param {Core.data.Model} record The record representing the row\n     * @param {Grid.column.Column} column The column to which the cell belongs\n     * @param {HTMLElement} cellElement The cell HTML element\n     * @param {HTMLElement} target The target element\n     * @param {MouseEvent} event The native DOM event\n     */\n\n    /**\n     * Fired when user double clicks a grid cell\n     * @event cellDblClick\n     * @param {Grid.view.Grid} grid The grid instance\n     * @param {Core.data.Model} record The record representing the row\n     * @param {Grid.column.Column} column The column to which the cell belongs\n     * @param {HTMLElement} cellElement The cell HTML element\n     * @param {HTMLElement} target The target element\n     * @param {MouseEvent} event The native DOM event\n     */\n\n    /**\n     * Fired when user activates contextmenu in a grid cell\n     * @event cellContextMenu\n     * @param {Grid.view.Grid} grid The grid instance\n     * @param {Core.data.Model} record The record representing the row\n     * @param {Grid.column.Column} column The column to which the cell belongs\n     * @param {HTMLElement} cellElement The cell HTML element\n     * @param {HTMLElement} target The target element\n     * @param {MouseEvent} event The native DOM event\n     */\n\n    /**\n     * Fired when user moves the mouse over a grid cell\n     * @event cellMouseOver\n     * @param {Grid.view.Grid} grid The grid instance\n     * @param {Core.data.Model} record The record representing the row\n     * @param {Grid.column.Column} column The column to which the cell belongs\n     * @param {HTMLElement} cellElement The cell HTML element\n     * @param {HTMLElement} target The target element\n     * @param {MouseEvent} event The native DOM event\n     */\n\n    /**\n     * Fired when a user moves the mouse out of a grid cell\n     * @event cellMouseOut\n     * @param {Grid.view.Grid} grid The grid instance\n     * @param {Core.data.Model} record The record representing the row\n     * @param {Grid.column.Column} column The column to which the cell belongs\n     * @param {HTMLElement} cellElement The cell HTML element\n     * @param {HTMLElement} target The target element\n     * @param {MouseEvent} event The native DOM event\n     */\n\n    //endregion\n\n    //region Event handling\n\n    /**\n     * Init listeners for a bunch of dom events. All events are handled by handleEvent().\n     * @private\n     * @category Events\n     */\n    initInternalEvents() {\n        const\n            handledEvents = Object.keys(gridBodyElementEventHandlers),\n            len           = handledEvents.length,\n            listeners     = {\n                element : this.bodyElement,\n                thisObj : this\n            };\n\n        // Route all events through handleEvent, so that we can capture this.event\n        // before we route to the handlers\n        for (let i = 0; i < len; i++) {\n            const eventName = handledEvents[i];\n\n            listeners[eventName] = {\n                handler : 'handleEvent'\n            };\n            // Override default for touch events.\n            // Other event types already have correct default.\n            if (eventName.startsWith('touch')) {\n                listeners[eventName].passive = false;\n            }\n        }\n\n        EventHelper.on(listeners);\n\n        EventHelper.on({\n            focusin : 'onGridBodyFocusIn',\n            element : this.bodyElement,\n            thisObj : this,\n            capture : true\n        });\n    }\n\n    /**\n     * This method finds the cell location of the passed event. It returns an object describing the cell.\n     * @param {Event} event A Mouse, Pointer or Touch event targeted at part of the grid.\n     * @param {Boolean} [includeSingleAxisMatch] Set to `true` to return a cell from xy either above or below the Grid's\n     * body or to the left or right.\n     * @returns {Object} An object containing the following properties:\n     * - `cellElement` - The cell element clicked on.\n     * - `column` - The {@link Grid.column.Column column} clicked under.\n     * - `columnId` - The `id` of the {@link Grid.column.Column column} clicked under.\n     * - `record` - The {@link Core.data.Model record} clicked on.\n     * - `id` - The `id` of the {@link Core.data.Model record} clicked on.\n     * @internal\n     * @category Events\n     */\n    getCellDataFromEvent(event, includeSingleAxisMatch = false) {\n        const\n            me          = this,\n            { columns } = me,\n            { target }  = event;\n        let cellElement = target.closest('.b-grid-cell');\n        // If event coords outside of cell, this will match a cell so long as either x or y is inside a cell.\n        if (!cellElement && includeSingleAxisMatch && !target.classList.contains('b-grid-row') &&\n            !target.classList.contains('b-grid-subgrid')\n        ) {\n            const {\n                top,\n                left,\n                right,\n                bottom\n            }            = me.bodyContainer.getBoundingClientRect();\n            let match,\n                { x, y } = event;\n\n            // X axis correct\n            if (x >= left && x <= right) {\n                // y will match row either at the top or at the bottom, dependent on what the provided x is\n                y = match = Math.ceil(me[`${y < top ? 'first' : 'last'}FullyVisibleRow`].element.getBoundingClientRect().y);\n            }\n            // Y axis correct\n            else if (y >= top && y <= bottom) {\n                // x will match row either at to the left or to the right, dependent on what the provided y is\n                x = match = Math.ceil(columns.visibleColumns[x < left ? 0 : columns.visibleColumns.length - 1].element.getBoundingClientRect().x);\n            }\n            if (match !== undefined) {\n                cellElement = document.elementFromPoint(x, y)?.closest('.b-grid-cell');\n            }\n        }\n\n        // There is a cell\n        if (cellElement) {\n            const\n                cellData         = DomDataStore.get(cellElement),\n                { id, columnId } = cellData,\n                record           = me.store.getById(id),\n                column           = columns.getById(columnId);\n\n            // Row might not have a record, since we transition record removal\n            // https://app.assembla.com/spaces/bryntum/tickets/6805\n            return record ? {\n                cellElement,\n                cellData,\n                columnId,\n                id,\n                record,\n                column,\n                cellSelector : { id, columnId }\n            } : null;\n        }\n    }\n\n    /**\n     * This method finds the header location of the passed event. It returns an object describing the header.\n     * @param {Event} event A Mouse, Pointer or Touch event targeted at part of the grid.\n     * @returns {Object} An object containing the following properties:\n     * - `headerElement` - The header element clicked on.\n     * - `column` - The {@link Grid.column.Column column} clicked under.\n     * - `columnId` - The `id` of the {@link Grid.column.Column column} clicked under.\n     * @internal\n     * @category Events\n     */\n    getHeaderDataFromEvent(event) {\n        const headerElement = event.target.closest('.b-grid-header');\n\n        // There is a header\n        if (headerElement) {\n            const\n                headerData   = ObjectHelper.assign({}, headerElement.dataset),\n                { columnId } = headerData,\n                column       = this.columns.getById(columnId);\n\n            return column ? {\n                headerElement,\n                headerData,\n                columnId,\n                column\n            } : null;\n        }\n    }\n\n    /**\n     * Handles all dom events, routing them to correct functions (touchstart -> onElementTouchStart)\n     * @param event\n     * @private\n     * @category Events\n     */\n    handleEvent(event) {\n        if (!this.disabled && gridBodyElementEventHandlers[event.type]) {\n            this[gridBodyElementEventHandlers[event.type]](event);\n        }\n    }\n\n    //endregion\n\n    //region Touch events\n\n    /**\n     * Touch start, chain this function in features to handle the event.\n     * @param event\n     * @category Touch events\n     * @internal\n     */\n    onElementTouchStart(event) {\n        const\n            me       = this,\n            cellData = me.getCellDataFromEvent(event);\n\n        DomHelper.isTouchEvent = true;\n\n        if (event.touches.length === 1) {\n            me.longPressTimeout = me.setTimeout(() => {\n                me.onElementLongPress(event);\n                event.preventDefault();\n                me.longPressPerformed = true;\n            }, me.longPressTime);\n        }\n\n        if (cellData && !event.defaultPrevented) {\n            me.onFocusGesture(event);\n        }\n    }\n\n    /**\n     * Touch move, chain this function in features to handle the event.\n     * @param event\n     * @category Touch events\n     * @internal\n     */\n    onElementTouchMove(event) {\n        const\n            me          = this,\n            {\n                lastTouchTarget\n            }           = me,\n            touch       = event.changedTouches[0],\n            {\n                pageX,\n                pageY\n            }           = touch,\n            touchTarget = document.elementFromPoint(pageX, pageY);\n\n        if (me.longPressTimeout) {\n            me.clearTimeout(me.longPressTimeout);\n            me.longPressTimeout = null;\n        }\n\n        // Keep grid informed about mouseover/outs during touch-based dragging\n        if (touchTarget !== lastTouchTarget) {\n            if (lastTouchTarget) {\n                const mouseoutEvent = new MouseEvent('mouseout', ObjectHelper.copyProperties({\n                    relatedTarget : touchTarget,\n                    pointerType   : 'touch',\n                    bubbles       : true\n                }, touch, eventProps));\n\n                mouseoutEvent.preventDefault = () => event.preventDefault();\n                lastTouchTarget?.dispatchEvent(mouseoutEvent);\n            }\n            if (touchTarget) {\n                const mouseoverEvent = new MouseEvent('mouseover', ObjectHelper.copyProperties({\n                    relatedTarget : lastTouchTarget,\n                    pointerType   : 'touch',\n                    bubbles       : true\n                }, touch, eventProps));\n\n                mouseoverEvent.preventDefault = () => event.preventDefault();\n                touchTarget?.dispatchEvent(mouseoverEvent);\n            }\n        }\n\n        me.lastTouchTarget = touchTarget;\n    }\n\n    /**\n     * Touch end, chain this function in features to handle the event.\n     * @param event\n     * @category Touch events\n     * @internal\n     */\n    onElementTouchEnd(event) {\n        const me = this;\n\n        if (me.longPressPerformed) {\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n            me.longPressPerformed = false;\n        }\n\n        if (me.longPressTimeout) {\n            me.clearTimeout(me.longPressTimeout);\n            me.longPressTimeout = null;\n        }\n    }\n\n    onElementLongPress(event) {}\n\n    //endregion\n\n    //region Mouse events\n\n    // Trigger events in same style when clicking, dblclicking and for contextmenu\n    triggerCellMouseEvent(name, event, cellData = this.getCellDataFromEvent(event)) {\n        const me = this;\n\n        // There is a cell\n        if (cellData) {\n            const\n                column    = me.columns.getById(cellData.columnId),\n                eventData = {\n                    grid         : me,\n                    record       : cellData.record,\n                    column,\n                    cellSelector : cellData.cellSelector,\n                    cellElement  : cellData.cellElement,\n                    target       : event.target,\n                    event\n                };\n\n            me.trigger('cell' + StringHelper.capitalize(name), eventData);\n\n            if (name === 'click') {\n                column.onCellClick?.(eventData);\n            }\n        }\n    }\n\n    /**\n     * Mouse down, chain this function in features to handle the event.\n     * @param event\n     * @category Mouse events\n     * @internal\n     */\n    onElementMouseDown(event) {\n        const\n            me       = this,\n            cellData = me.getCellDataFromEvent(event);\n\n        me.skipFocusSelection = true;\n\n        // If click was on a scrollbar or splitter, preventDefault to not steal focus\n        if (me.isScrollbarOrRowBorderOrSplitterClick(event)) {\n            event.preventDefault();\n        }\n        else {\n            me.triggerCellMouseEvent('mousedown', event, cellData);\n\n            // Browser event unification fires a mousedown on touch tap prior to focus.\n            if (cellData && !event.defaultPrevented) {\n                me.onFocusGesture(event);\n            }\n        }\n    }\n\n    isScrollbarOrRowBorderOrSplitterClick({ target, x, y }) {\n        // Normally cells catch the click, directly on row = user clicked border, which we ignore.\n        // Also ignore clicks on the virtual width element used to stretch fake scrollbar\n        if (target.closest('.b-grid-splitter') || target.matches('.b-grid-row, .b-virtual-width')) {\n            return true;\n        }\n        if (target.matches('.b-vertical-overflow')) {\n            const rect = target.getBoundingClientRect();\n            return x > rect.right - DomHelper.scrollBarWidth;\n        }\n        else if (target.matches('.b-horizontal-overflow')) {\n            const rect = target.getBoundingClientRect();\n            return y > rect.bottom - DomHelper.scrollBarWidth - 1; // -1 for height of virtualScrollerWidth element\n        }\n    }\n\n    /**\n     * Mouse move, chain this function in features to handle the event.\n     * @param event\n     * @category Mouse events\n     * @internal\n     */\n    onElementMouseMove(event) {\n        // Keep track of the last mouse position in case, due to OSX sloppy focusing,\n        // focus is moved into the browser before a mousedown is delivered.\n        // The cached mousemove event will provide the correct target in\n        // GridNavigation#onGridElementFocus.\n        this.mouseMoveEvent = event;\n    }\n\n    /**\n     * Mouse up, chain this function in features to handle the event.\n     * @param event\n     * @category Mouse events\n     * @internal\n     */\n    onElementMouseUp(event) {}\n\n    onElementPointerDown(event) {}\n\n    /**\n     * Pointer up, chain this function in features to handle the event.\n     * @param event\n     * @category Mouse events\n     * @internal\n     */\n    onElementPointerUp(event) {}\n\n    /**\n     * Called before {@link #function-onElementClick}.\n     * Fires 'beforeElementClick' event which can return false to cancel further onElementClick actions.\n     * @param event\n     * @fires beforeElementClick\n     * @category Mouse events\n     * @internal\n     */\n\n    onHandleElementClick(event) {\n        if (this.trigger('beforeElementClick', { event }) !== false) {\n            this.onElementClick(event);\n        }\n    }\n\n    /**\n     * Click, select cell on click and also fire 'cellClick' event.\n     * Chain this function in features to handle the dom event.\n     * @param event\n     * @fires cellClick\n     * @category Mouse events\n     * @internal\n     */\n    onElementClick(event) {\n        const\n            me       = this,\n            cellData = me.getCellDataFromEvent(event);\n\n        // There is a cell\n        if (cellData) {\n            me.triggerCellMouseEvent('click', event, cellData);\n        }\n    }\n\n    onFocusGesture(event) {\n        const\n            me                    = this,\n            isContextMenu         = event.button === 2,\n            // Interaction with tree expand/collapse icons doesn't focus\n            isTreeExpander        = !isContextMenu && event.target.matches('.b-icon-tree-expand, .b-icon-tree-collapse'),\n            // Mac OS specific behaviour: when you right click a non-active window, the window does not receive focus, but the context menu is shown.\n            // So for Mac OS we treat the right click as a non-focusable action, if window is not active\n            isUnfocusedRightClick = !document.hasFocus() && BrowserHelper.isMac && isContextMenu;\n\n        // Tree expander clicks and contextmenus on unfocused windows don't focus\n        if (isTreeExpander || isUnfocusedRightClick) {\n            event.preventDefault();\n        }\n        else {\n            // Used by the GridNavigation mixin to detect what interaction event if any caused\n            // the focus to be moved. If it's a programmatic focus, there won't be one.\n            // Grid doesn't use a Navigator which maintains this property, so we need to set it.\n            me.navigationEvent = event;\n\n            // Context menu doesn't focus by default, so that needs to explicitly focus.\n            // If they're re-clicking the current focus, GridNavigation#focusCell\n            // still needs to know. It's a no-op, but it informs the GridSelection of the event.\n            if (isContextMenu || me.focusedCell?.equals(new Location(event.target))) {\n                me.focusCell(new Location(event.target));\n            }\n        }\n    }\n\n    /**\n     * Double click, fires 'cellDblClick' event.\n     * Chain this function in features to handle the dom event.\n     * @param {Event} event\n     * @fires cellDblClick\n     * @category Mouse events\n     * @internal\n     */\n    onElementDblClick(event) {\n        const { target } = event;\n\n        this.triggerCellMouseEvent('dblClick', event);\n\n        if (target.classList.contains('b-grid-header-resize-handle')) {\n            const\n                header = target.closest('.b-grid-header'),\n                column = this.columns.getById(header.dataset.columnId);\n\n            column.resizeToFitContent();\n        }\n    }\n\n    /**\n     * Mouse over, adds 'hover' class to elements.\n     * @param event\n     * @fires mouseOver\n     * @category Mouse events\n     * @internal\n     */\n    onElementMouseOver(event) {\n        // bail out early if scrolling\n        if (!this.scrolling) {\n            const\n                // No hover effect needed if a mouse button is pressed (like when resizing window, region, or resizing something etc).\n                // NOTE: 'buttons' not supported in Safari\n                shouldHover = typeof event.buttons !== 'number' || event.buttons === 0,\n                cellElement = event.target.closest('.b-grid-cell');\n\n            // If we should hover, and we are entering a grid row (which probably is a row border), we should hover\n            // cell/row above so not to get a blinking hovering, especially on column header\n            if (shouldHover && !cellElement && event.target.classList.contains('b-grid-row')) {\n                this.setHovered(document.elementFromPoint(event.x, event.y - 2).closest('.b-grid-cell'));\n            }\n\n            if (cellElement) {\n                if (shouldHover) {\n                    this.setHovered(cellElement);\n                }\n\n                this.triggerCellMouseEvent('mouseOver', event);\n            }\n\n            /**\n             * Mouse moved in over element in grid\n             * @event mouseOver\n             * @param {MouseEvent} event The native browser event\n             */\n            this.trigger('mouseOver', { event });\n        }\n    }\n\n    /**\n     * Mouse out, removes 'hover' class from elements.\n     * @param event\n     * @fires mouseOut\n     * @category Mouse events\n     * @internal\n     */\n    onElementMouseOut(event) {\n        this.setHovered(null);\n        // bail out early if scrolling\n        if (!this.scrolling) {\n            const cellElement = event.target.closest('.b-grid-cell');\n\n            if (cellElement) {\n                this.triggerCellMouseEvent('mouseOut', event);\n            }\n\n            /**\n             * Mouse moved out from element in grid\n             * @event mouseOut\n             * @param {MouseEvent} event The native browser event\n             */\n            this.trigger('mouseOut', { event });\n        }\n    }\n\n    // Not a setter to allow chaining in features\n    setHovered(cellElement) {\n        const\n            me                        = this,\n            { selectionMode }         = me,\n            rowNumberColumnId         = selectionMode.rowNumber && me.columns.find(c => c.type == 'rownumber')?.id,\n            checkboxSelectionColumnId = selectionMode.checkbox && me.checkboxSelectionColumn?.id;\n\n        // Always clears any hovered cell\n        if (me._hoveredCell) {\n            toggleHover(me._hoveredCell, false);\n\n            // Also remove hovered class on checkcol, rownumbercol and column header\n            const\n                prevSelector      = DomDataStore.get(me._hoveredCell),\n                { row : prevRow } = prevSelector;\n\n            if (prevRow && !prevRow.isDestroyed) {\n                setCellHover(rowNumberColumnId, prevRow, false);\n                setCellHover(checkboxSelectionColumnId, prevRow, false);\n            }\n\n            if (prevSelector?.columnId) {\n                toggleHover(me.columns.getById(prevSelector.columnId)?.element, false);\n            }\n\n            me._hoveredCell = null;\n        }\n\n        // Clears hovered row\n        // Only remove cls if row isn't destroyed\n        if (me._hoveredRow && !me._hoveredRow.isDestroyed) {\n            me._hoveredRow.removeCls('b-hover');\n        }\n        me._hoveredRow = null;\n\n        // Set hovered\n        if (cellElement && !me.scrolling) {\n            const\n                selector = DomDataStore.get(cellElement),\n                { row }  = selector;\n\n            if (row) {\n                // Set cell if cell selection mode is on\n                if (selectionMode.cell && selector.columnId !== rowNumberColumnId && selector.columnId !== checkboxSelectionColumnId) {\n                    toggleHover(cellElement);\n                    me._hoveredCell = cellElement;\n\n                    // In cell selection mode:\n                    // Also \"hover\" checkcolumn cell if such exists\n                    setCellHover(checkboxSelectionColumnId, row);\n                    // And also rownumbercolumn cell\n                    setCellHover(rowNumberColumnId, row);\n                    // And also column header\n                    toggleHover(me.columns.getById(selector.columnId)?.element);\n                }\n                // Else row\n                else {\n                    me._hoveredRow = row;\n                    row.addCls('b-hover');\n                }\n            }\n        }\n    }\n\n    //endregion\n\n    //region Keyboard events\n\n    // Hooks on to keyMaps keydown-listener to be able to run before\n    keyMapOnKeyDown(event) {\n        this.onElementKeyDown(event);\n        super.keyMapOnKeyDown(event);\n    }\n\n    /**\n     * To catch all keydowns. For more specific keydown actions, use keyMap.\n     * @param event\n     * @category Keyboard events\n     * @internal\n     */\n    onElementKeyDown(event) {\n        // If some other function flagged the event as handled, we ignore it.\n        if (event.handled) {\n            return;\n        }\n\n        const\n            me          = this,\n            // Read this to refresh cached reference in case this keystroke lead to the removal of current row\n            focusedCell = me.focusedCell;\n\n        if (focusedCell?.isCell && !focusedCell.isActionable) {\n            const\n                cellElement = focusedCell.cell;\n\n            // If a cell is focused and column is interested - call special callback\n            me.columns.getById(cellElement.dataset.columnId).onCellKeyDown?.({ event, cellElement });\n        }\n    }\n\n    undoRedoKeyPress(event) {\n        const { stm } = this.store;\n        if (stm && this.enableUndoRedoKeys && !this.features.cellEdit?.isEditing) {\n            stm.onUndoKeyPress(event);\n            return true;\n        }\n        return false;\n    }\n\n    // Trigger column.onCellClick when space bar is pressed\n    clickCellByKey(event) {\n        const\n            me          = this,\n            // Read this to refresh cached reference in case this keystroke lead to the removal of current row\n            focusedCell = me.focusedCell,\n            cellElement = focusedCell?.cell,\n            column      = me.columns.getById(cellElement.dataset.columnId);\n\n        if (focusedCell?.isCell && !focusedCell.isActionable) {\n            if (column.onCellClick) {\n                column.onCellClick({\n                    grid   : me,\n                    column,\n                    record : me.store.getById(focusedCell.id),\n                    cellElement,\n                    target : event.target,\n                    event\n                });\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Key press, chain this function in features to handle the dom event.\n     * @param event\n     * @category Keyboard events\n     * @internal\n     */\n    onElementKeyPress(event) {}\n\n    /**\n     * Key up, chain this function in features to handle the dom event.\n     * @param event\n     * @category Keyboard events\n     * @internal\n     */\n    onElementKeyUp(event) {}\n\n    //endregion\n\n    //region Other events\n\n    /**\n     * Context menu, chain this function in features to handle the dom event.\n     * In most cases, include ContextMenu feature instead.\n     * @param event\n     * @category Other events\n     * @internal\n     */\n    onElementContextMenu(event) {\n        const\n            me       = this,\n            cellData = me.getCellDataFromEvent(event);\n\n        // There is a cell\n        if (cellData) {\n            me.triggerCellMouseEvent('contextMenu', event, cellData);\n\n            // Focus on tap for touch events.\n            // Selection follows from focus.\n            if (DomHelper.isTouchEvent) {\n                me.onFocusGesture(event);\n            }\n        }\n    }\n\n    /**\n     * Overrides empty base function in View, called when view is resized.\n     * @fires resize\n     * @param element\n     * @param width\n     * @param height\n     * @param oldWidth\n     * @param oldHeight\n     * @category Other events\n     * @internal\n     */\n    onInternalResize(element, width, height, oldWidth, oldHeight) {\n        const me = this;\n\n        if (me._devicePixelRatio && me._devicePixelRatio !== globalThis.devicePixelRatio) {\n            // Pixel ratio changed, likely because of browser zoom. This affects the relative scrollbar width also\n            DomHelper.resetScrollBarWidth();\n        }\n\n        me._devicePixelRatio = globalThis.devicePixelRatio;\n        // cache to avoid recalculations in the middle of rendering code (RowManger#getRecordCoords())\n        me._bodyRectangle    = Rectangle.client(me.bodyContainer);\n\n        super.onInternalResize(...arguments);\n\n        if (height !== oldHeight) {\n            me._bodyHeight = me.bodyContainer.offsetHeight;\n            if (me.isPainted) {\n                // initial height will be set from render(),\n                // it reaches onInternalResize too early when rendering, headers/footers are not sized yet\n                me.rowManager.initWithHeight(me._bodyHeight);\n            }\n        }\n        me.refreshVirtualScrollbars();\n\n        if (width !== oldWidth) {\n            // Slightly delay to avoid resize loops.\n            me.setTimeout(() => {\n                if (!me.isDestroyed) {\n                    me.updateResponsive(width, oldWidth);\n                }\n            }, 0);\n        }\n    }\n\n    //endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport GridFeatureManager from '../../feature/GridFeatureManager.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Grid/view/mixin/GridFeatures\n */\n\nconst validConfigTypes = {\n    string   : 1,\n    object   : 1,\n    function : 1 // used by CellTooltip\n};\n\n/**\n * Mixin for Grid that handles features. Features are plugins that add functionality to the grid. Feature classes should\n * register with Grid by calling {@link Grid.feature.GridFeatureManager#function-registerFeature-static registerFeature}. This\n * enables features to be specified and configured in grid\n * config.\n *\n * Define which features to use:\n *\n * ```javascript\n * // specify which features to use (note that some features are used by default)\n * const grid = new Grid({\n *   features: {\n *      sort: 'name',\n *      search: true\n *   }\n * });\n * ```\n *\n * Access a feature in use:\n *\n * ```javascript\n * grid.features.search.search('cat');\n * ```\n *\n * Basic example of implementing a feature:\n *\n * ```javascript\n * class MyFeature extends InstancePlugin {\n *\n * }\n *\n * GridFeatures.registerFeature(MyFeature);\n *\n * // using the feature\n * const grid = new Grid({\n *   features: {\n *     myFeature: true\n *   }\n * });\n * ```\n *\n * ## Enable and disable features at runtime\n *\n * Each feature is either \"enabled\" (included by default), or \"off\" (excluded completely). You can always check the docs\n * of a specific feature to find out how it is configured by default.\n *\n * Features which are \"off\" completely are not available and cannot be enabled at runtime.\n *\n * For a feature that is **off** by default that you want to enable later during runtime,\n * configure it with `disabled : true`:\n * ```javascript\n * const grid = new Grid({\n *      featureName : {\n *          disabled : true // on and disabled, can be enabled later\n *      }\n * });\n *\n * // enable the feature\n * grid.featureName.disabled = false;\n * ```\n *\n * If the feature is **off** by default, and you want to include and enable the feature, configure it as `true`:\n * ```javascript\n * const grid = new Grid({\n *      featureName : true // on and enabled, can be disabled later\n * });\n *\n * // disable the feature\n * grid.featureName.disabled = true;\n * ```\n *\n * If the feature is **on** by default, but you want to turn it **off**, configure it as `false`:\n * ```javascript\n * const grid = new Grid({\n *      featureName : false // turned off, not included at all\n * });\n * ```\n *\n * If the feature is **enabled** by default and you have no need of reconfiguring it,\n * you can omit the feature configuration.\n *\n * @mixin\n */\nexport default Target => class GridFeatures extends (Target || Base) {\n    static get $name() {\n        return 'GridFeatures';\n    }\n\n    //region Init\n\n    /**\n     * Specify which features to use on the grid. Most features accepts a boolean, some also accepts a config object.\n     * Please note that if you are not using the bundles you might need to import the features you want to use.\n     *\n     * ```javascript\n     * const grid = new Grid({\n     *     features : {\n     *         stripe : true,   // Enable stripe feature\n     *         sort   : 'name', // Configure sort feature\n     *         group  : false   // Disable group feature\n     *     }\n     * }\n     * ```\n     *\n     * @config {Object} features\n     * @category Common\n     */\n\n    /**\n     * Map of the features available on the grid. Use it to access them on your grid object\n     *\n     * ```javascript\n     * grid.features.group.expandAll();\n     * ```\n     *\n     * @readonly\n     * @member {Object} features\n     * @category Common\n     */\n\n    set features(features) {\n        const\n            me              = this,\n            defaultFeatures = GridFeatureManager.getInstanceDefaultFeatures(this);\n\n        features = me._features = ObjectHelper.assign({}, features);\n\n        // default features, enabled unless otherwise specified\n        if (defaultFeatures) {\n            Object.keys(defaultFeatures).forEach(feature => {\n                if (!(feature in features)) {\n                    features[feature] = true;\n                }\n            });\n        }\n\n        // We *prime* the features so that if any configuration code accesses a feature, it\n        // will self initialize, but if not, they will remain in a primed state until afterConfigure.\n        const registeredInstanceFeatures = GridFeatureManager.getInstanceFeatures(this);\n\n        for (const featureName of Object.keys(features)) {\n            const config = features[featureName];\n\n            // Create feature initialization property if config is truthy.\n            // Config must be a valid configuration value for the feature class.\n            if (config) {\n                const throwIfError = !globalThis.__bryntum_code_editor_changed;\n\n                // Feature configs name must start with lowercase letter to be valid\n                if (StringHelper.uncapitalize(featureName) !== featureName) {\n                    const errorMessage = `Invalid feature name '${featureName}', must start with a lowercase letter`;\n\n                    if (throwIfError) {\n                        throw new Error(errorMessage);\n                    }\n                    console.error(errorMessage);\n                    me._errorDuringConfiguration = errorMessage;\n                }\n\n                const featureClass = registeredInstanceFeatures[featureName];\n\n                if (!featureClass) {\n                    const errorMessage = `Feature '${featureName}' not available, make sure you have imported it`;\n                    if (throwIfError) {\n                        throw new Error(errorMessage);\n                    }\n                    console.error(errorMessage);\n                    me._errorDuringConfiguration = errorMessage;\n                    return;\n                }\n\n                // Create a self initializing property on the features object named by the feature name.\n                // when accessed, it will create and return the real feature.\n                // Now, if some Feature initialization code attempt to access a feature which has not yet been initialized\n                // it will be initialized just in time.\n                Reflect.defineProperty(features, featureName, me.createFeatureInitializer(features, featureName,\n                    featureClass, config));\n            }\n        }\n    }\n\n    get features() {\n        return this._features;\n    }\n\n    createFeatureInitializer(features, featureName, featureClass, config) {\n        const\n            constructorArgs = [this],\n            construct       = featureClass.prototype.construct;\n\n        // Config arg must be processed if feature is just requested with true\n        // so that default configurable values are processed.\n        if (config === true) {\n            config = {};\n        }\n\n        // Only pass config if there is one.\n        // The constructor(config = {}) only works for undefined config\n        if (validConfigTypes[typeof config]) {\n            constructorArgs[1] = config;\n        }\n\n        return {\n            configurable : true,\n            get() {\n                // Delete this defined property and replace it with the Feature instance.\n                delete features[featureName];\n\n                // Ensure the feature is injected into the features object before initialization\n                // so that it is available from call chains from its initialization.\n                featureClass.prototype.construct = function(...args) {\n                    features[featureName] = this;\n                    construct.apply(this, args);\n                    featureClass.prototype.construct = construct;\n                };\n\n                // Return the Feature instance\n                return new featureClass(...constructorArgs);\n            }\n        };\n    }\n\n    //endregion\n\n    //region Other stuff\n\n    /**\n     * Check if a feature is included\n     * @param {String} name Feature name, as registered with `GridFeatureManager.registerFeature()`\n     * @returns {Boolean}\n     * @category Misc\n     */\n    hasFeature(name) {\n        const { features } = this;\n\n        if (features) {\n            const featureProp = Object.getOwnPropertyDescriptor(this.features, name);\n\n            if (featureProp) {\n                // Do not actually force creation of the feature\n                return Boolean(featureProp.value || featureProp.get);\n            }\n        }\n        return false;\n    }\n\n    hasActiveFeature(name) {\n        return Boolean(this.features?.[name] && !this.features?.[name].disabled);\n    }\n\n    //endregion\n\n    //region Extract config\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs for the features\n    getConfigValue(name, options) {\n        if (name === 'features') {\n            const result = {};\n\n            for (const feature in this.features) {\n                // Feature might be configured as `false`\n                const featureConfig = this.features[feature]?.getCurrentConfig?.(options);\n                if (featureConfig) {\n                    // Use `true` for empty feature configs `{ stripe : true }`\n                    if (ObjectHelper.isEmpty(featureConfig)) {\n                        // Exclude default features to not spam the config\n                        if (!GridFeatureManager.isDefaultFeatureForInstance(this.features[feature].constructor, this)) {\n                            result[feature] = true;\n                        }\n                    }\n                    else {\n                        result[feature] = featureConfig;\n                    }\n                }\n                else {\n                    result[feature] = false;\n                }\n            }\n\n            return result;\n        }\n\n        return super.getConfigValue(name, options);\n    }\n\n    //endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport Location from '../../util/Location.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport GlobalEvents from '../../../Core/GlobalEvents.js';\nimport VersionHelper from '../../../Core/helper/VersionHelper.js';\n\n/**\n * @module Grid/view/mixin/GridNavigation\n */\n\nconst\n    defaultFocusOptions = Object.freeze({}),\n    disableScrolling = Object.freeze({\n        x : false,\n        y : false\n    }),\n    containedFocusable = function(e) {\n        // When we step outside of the target cell, throw.\n        // The TreeWalker silences the exception and terminates the traverse.\n        if (!this.focusableFinderCell.contains(e)) {\n            return DomHelper.NodeFilter.FILTER_REJECT;\n        }\n        if (DomHelper.isFocusable(e) && !e.disabled) {\n            return DomHelper.NodeFilter.FILTER_ACCEPT;\n        }\n        return DomHelper.NodeFilter.FILTER_SKIP;\n    };\n\n/**\n * Mixin for Grid that handles cell to cell navigation.\n *\n * See {@link Grid.view.Grid} for more information on grid cell keyboard navigation.\n *\n * @mixin\n */\nexport default Target => class GridNavigation extends (Target || Base) {\n    static get $name() {\n        return 'GridNavigation';\n    }\n\n    static configurable =  {\n        focusable : false,\n\n        focusableSelector : '.b-grid-cell,.b-grid-header.b-depth-0',\n\n        // Documented on Grid\n        keyMap : {\n            ArrowUp    : { handler : 'navigateUp', weight : 10 },\n            ArrowRight : { handler : 'navigateRight', weight : 10 },\n            ArrowDown  : { handler : 'navigateDown', weight : 10 },\n            ArrowLeft  : { handler : 'navigateLeft', weight : 10 },\n\n            'Ctrl+Home' : 'navigateFirstCell',\n            Home        : 'navigateFirstColumn',\n            'Ctrl+End'  : 'navigateLastCell',\n            End         : 'navigateLastColumn',\n            PageUp      : 'navigatePrevPage',\n            PageDown    : 'navigateNextPage',\n            Enter       : 'activateHeader',\n\n            // Private\n            Escape      : { handler : 'onEscape', weight : 10 },\n            'Shift+Tab' : { handler : 'onShiftTab', preventDefault : false },\n            Tab         : { handler : 'onTab', preventDefault : false },\n            ' '         : { handler : 'onSpace', preventDefault : false }\n        }\n    }\n\n    onStoreRecordIdChange(event) {\n        super.onStoreRecordIdChange?.(event);\n\n        const\n            { focusedCell }     = this,\n            { oldValue, value } = event;\n\n        // https://github.com/bryntum/support/issues/4935\n        if (focusedCell && focusedCell.id === oldValue) {\n            focusedCell._id = value;\n        }\n    }\n\n    /**\n     * Called by the RowManager when the row which contains the focus location is derendered.\n     *\n     * This keeps focus in a consistent place.\n     * @protected\n     */\n    onFocusedRowDerender() {\n        const\n            me              = this,\n            { focusedCell } = me;\n\n        if (focusedCell?.id != null && focusedCell.cell) {\n            const isActive = focusedCell.cell.contains(DomHelper.getActiveElement(me));\n\n            if (me.hideHeaders) {\n                if (isActive) {\n                    me.revertFocus();\n                }\n            }\n            else {\n                const headerContext = me.normalizeCellContext({\n                    rowIndex    : -1,\n                    columnIndex : isActive ? focusedCell.columnIndex : 0\n                });\n\n                // The row contained focus, focus the corresponding header\n                if (isActive) {\n                    me.focusCell(headerContext);\n                }\n                else {\n                    headerContext.cell.tabIndex = 0;\n                }\n            }\n            focusedCell.cell.tabIndex = -1;\n        }\n    }\n\n    navigateFirstCell() {\n        this.focusCell(Location.FIRST_CELL);\n    }\n\n    navigateFirstColumn() {\n        this.focusCell(Location.FIRST_COLUMN);\n    }\n\n    navigateLastCell() {\n        this.focusCell(Location.LAST_CELL);\n    }\n\n    navigateLastColumn() {\n        this.focusCell(Location.LAST_COLUMN);\n    }\n\n    navigatePrevPage() {\n        this.focusCell(Location.PREV_PAGE);\n    }\n\n    navigateNextPage() {\n        this.focusCell(Location.NEXT_PAGE);\n    }\n\n    activateHeader(keyEvent) {\n        if (keyEvent.target.classList.contains('b-grid-header') && this.focusedCell.isColumnHeader) {\n            const { column } = this.focusedCell;\n\n            column.onKeyDown?.(keyEvent);\n\n            this.getHeaderElement(column.id).click();\n        }\n        return false;\n    }\n\n    onEscape(keyEvent) {\n        const { focusedCell } = this;\n\n        if (!keyEvent.target.closest('.b-dragging') && focusedCell?.isActionable) {\n            // The escape must not be processed by handlers for the cell we are about to focus.\n            // We need to just push focus upwards to the cell, and stop there.\n            keyEvent.stopImmediatePropagation();\n\n            // To prevent the focusCell from being rejected as a no-op\n            this._focusedCell = null;\n\n            // Focus the cell with an explicit request to not jump in\n            this.focusCell({\n                rowIndex : focusedCell.rowIndex,\n                column   : focusedCell.column\n            }, {\n                disableActionable : true\n            });\n        }\n    }\n\n    onTab(keyEvent) {\n        const\n            { target } = keyEvent,\n            {\n                focusedCell,\n                bodyElement\n            }          = this,\n            {\n                isActionable,\n                actionTargets\n            }          = focusedCell,\n            isEditable = isActionable && DomHelper.isEditable(target) && !target.readOnly;\n\n        // If we're on the last editable in a cell, TAB navigates right\n        if (isEditable && target === actionTargets[actionTargets.length - 1]) {\n            keyEvent.preventDefault();\n            this.navigateRight(keyEvent);\n        }\n        // If we're *on* a cell, or on last subtarget, TAB moves off the grid.\n        // Temporarily hide the grid body, and let TAB take effect from there\n        else if (!isActionable || target === actionTargets[actionTargets.length - 1]) {\n            bodyElement.style.display = 'none';\n            this.requestAnimationFrame(() => bodyElement.style.display = '');\n\n            // So that Navigator#onKeyDown does not continue to preventDefault;\n            return false;\n        }\n    }\n\n    onShiftTab(keyEvent) {\n        const\n            me = this,\n            { target } = keyEvent,\n            {\n                focusedCell,\n                bodyElement\n            }   = me,\n            {\n                cell,\n                isActionable,\n                actionTargets\n            } = focusedCell,\n            isEditable  = isActionable && DomHelper.isEditable(target) && !target.readOnly,\n            onFirstCell = focusedCell.columnIndex === 0 && focusedCell.rowIndex === (me.hideHeaders ? 0 : -1);\n\n        // If we're on the first editable in a cell that is not the first cell, SHIFT+TAB navigates left\n        if (!onFirstCell && isEditable && target === actionTargets[0]) {\n            keyEvent.preventDefault();\n            me.navigateLeft(keyEvent);\n        }\n\n        // If we're *on* a cell, or on first subtarget, SHIFT+TAB moves off the grid.\n        else if (!isActionable || target === actionTargets[0]) {\n            // Focus the first header cell and then let the key's default action take its course\n            const f = !onFirstCell && !me.hideHeaders && me.focusCell({\n                rowIndex : -1,\n                column   : 0\n            }, {\n                disableActionable : true\n            });\n\n            // If that was successful then reset the tabIndex\n            if (f) {\n                f.cell.tabIndex = -1;\n                cell.tabIndex = 0;\n                me._focusedCell = focusedCell;\n            }\n            // Otherwise, temporarily hide the grid body, and let TAB take effect from there\n            else {\n                bodyElement.style.display = 'none';\n                me.requestAnimationFrame(() => bodyElement.style.display = '');\n            }\n\n            // So that Navigator#onKeyDown does not continue to preventDefault;\n            return false;\n        }\n    }\n\n    onSpace(keyEvent) {\n        // SPACE scrolls, so disable that\n        if (!this.focusedCell.isActionable) {\n            keyEvent.preventDefault();\n        }\n        // Return false to tell keyMap that any other actions should be called\n        return false;\n    }\n\n    //region Cell\n\n    /**\n     * Triggered when a user navigates to a grid cell\n     * @event navigate\n     * @param {Grid.view.Grid} grid The grid instance\n     * @param {Grid.util.Location} last The previously focused location\n     * @param {Grid.util.Location} location The new focused location\n     * @param {Event} [event] The UI event which caused navigation.\n     */\n\n    /**\n     * Grid Location which encapsulates the currently focused cell.\n     * Set to focus a cell or use {@link #function-focusCell}.\n     * @property {Grid.util.Location}\n     */\n    get focusedCell() {\n        return this._focusedCell;\n    }\n\n    /**\n     * This property is `true` if an element _within_ a cell is focused.\n     * @property {Boolean}\n     * @readonly\n     */\n    get isActionableLocation() {\n        return this._focusedCell?.isActionable;\n    }\n\n    set focusedCell(cellSelector) {\n        this.focusCell(cellSelector);\n    }\n\n    get focusedRecord() {\n        return this._focusedCell?.record;\n    }\n\n    /**\n     * CSS selector for currently focused cell. Format is \"[data-index=index] [data-column-id=columnId]\".\n     * @property {String}\n     * @readonly\n     */\n    get cellCSSSelector() {\n        const cell = this._focusedCell;\n\n        return cell ? `[data-index=${cell.rowIndex}] [data-column-id=${cell.columnId}]` : '';\n    }\n\n    afterHide() {\n        super.afterHide(...arguments);\n\n        // Do not scroll back to the last focused cell/last moused over cell upon reshow\n        this.lastFocusedCell = null;\n    }\n\n    /**\n     * Checks whether a cell is focused.\n     * @param {LocationConfig|String|Number} cellSelector Cell selector { id: x, columnId: xx } or row id\n     * @returns {Boolean} true if cell or row is focused, otherwise false\n     */\n    isFocused(cellSelector) {\n        return Boolean(this._focusedCell?.equals(this.normalizeCellContext(cellSelector)));\n    }\n\n    get focusElement() {\n        if (!this.isDestroying) {\n            let focusCell;\n\n            // If the store is not empty, focusedCell can return the closest cell\n            if (this.store.count && this._focusedCell) {\n                focusCell = this._focusedCell.target;\n            }\n            // If the store is empty, or we have had no focusedCell set, focus a column header.\n            else {\n                focusCell = this.normalizeCellContext({\n                    rowIndex    : -1,\n                    columnIndex : this._focusedCell?.columnIndex || 0\n                }).target;\n            }\n\n            const superFocusEl = super.focusElement;\n\n            // If there's no cell, or the Container's focus element is before the cell\n            // use the Container's focus element.\n            // For example, we may have a top toolbar.\n            if (superFocusEl && (!focusCell || focusCell.compareDocumentPosition(superFocusEl) === Node.DOCUMENT_POSITION_PRECEDING)) {\n                return superFocusEl;\n            }\n\n            return focusCell;\n        }\n    }\n\n    onPaint({ firstPaint }) {\n        const me = this;\n\n        super.onPaint?.(...arguments);\n\n        // Make the grid initally tabbable into.\n        // The first cell has to have the initial roving tabIndex set into it.\n        const defaultFocus = this.normalizeCellContext({\n            rowIndex : me.hideHeaders ? 0 : -1,\n            column   : me.hideHeaders ? 0 : me.columns.find(col => !col.hidden && col.isFocusable)\n        });\n\n        if (defaultFocus.cell) {\n            me._focusedCell = defaultFocus;\n\n            const { target } = defaultFocus;\n\n            // If cell doesn't contain a focusable target, it needs tabIndex 0.\n            if (target === defaultFocus.cell) {\n                defaultFocus.cell.tabIndex = 0;\n            }\n        }\n    }\n\n    /**\n     * This function handles focus moving into, or within the grid.\n     * @param {Event} focusEvent\n     * @private\n     */\n    onGridBodyFocusIn(focusEvent) {\n        const\n            me              = this,\n            { bodyElement } = me,\n            lastFocusedCell = me.focusedCell,\n            lastTarget      = lastFocusedCell?.initialTarget || lastFocusedCell?.target,\n            {\n                target,\n                relatedTarget\n            }               = focusEvent,\n            targetCell      = target.closest(me.focusableSelector);\n\n        // If focus moved into a valid cell...\n        // Only allows mouse left och right clicks (no other mouse buttons)\n        if (targetCell &&\n            (!GlobalEvents.currentMouseDown || GlobalEvents.isMouseDown(0) || GlobalEvents.isMouseDown(2))\n        ) {\n            const\n                cellSelector  = new Location(target),\n                { cell }      = cellSelector,\n                lastCell      = lastFocusedCell?.cell,\n                actionTargets = cellSelector.actionTargets = me.findFocusables(targetCell),\n                // Don't select on focus on a contained actionable location\n                doSelect      = (!me._fromFocusCell || me.selectOnFocus) && (target === cell || me._selectActionCell) && !target?._isRevertingFocus;\n\n            // https://github.com/bryntum/support/issues/4039\n            // Only try focusing cell is current target cell is getting removed\n            if (!me.store.getById(targetCell.parentNode.dataset.id) && cell !== targetCell) {\n                cell.focus({ preventScroll : true });\n                return;\n            }\n\n            if (target.matches(me.focusableSelector)) {\n                if (me.disableActionable) {\n                    cellSelector._target = cell;\n                }\n                // Focus first focusable target if we are configured to.\n                else if (actionTargets.length) {\n                    me._selectActionCell = GlobalEvents.currentMouseDown?.target === target;\n                    actionTargets[0].focus();\n                    delete me._selectActionCell;\n                    return;\n                }\n            }\n            else {\n                // If we have tabbed in and *NOT* mousedowned in, and hit a tabbable element which was not our\n                // last focused cell, go back to last focused cell.\n                if (lastFocusedCell?.target &&\n                    relatedTarget &&\n                    (!GlobalEvents.isMouseDown() || !bodyElement.contains(GlobalEvents.currentMouseDown?.target)) &&\n                    !bodyElement.contains(relatedTarget) &&\n                    !cellSelector.equals(lastFocusedCell)\n                ) {\n                    lastTarget.focus();\n                    return;\n                }\n                cellSelector._target = target;\n            }\n\n            if (lastCell) {\n                lastCell.classList.remove('b-focused');\n                lastCell.tabIndex = -1;\n            }\n            if (cell) {\n                cell.classList.add('b-focused');\n\n                // Column may update DOM on cell focus for A11Y purposes.\n                cellSelector.column.onCellFocus(cellSelector);\n\n                // Only switch the cell to be tabbable if focus was not directed to an inner focusable.\n                if (cell === target) {\n                    cell.tabIndex = 0;\n                }\n\n                // Moving back to a cell from a cell-contained Editor\n                if (cell.contains(focusEvent.relatedTarget)) {\n                    if (lastTarget === target) {\n                        return;\n                    }\n                }\n            }\n\n            //Remember\n            me._focusedCell = cellSelector;\n\n            me.onCellNavigate?.(me, lastFocusedCell, cellSelector, doSelect);\n\n            me.trigger('navigate', { lastFocusedCell, focusedCell : cellSelector, event : focusEvent });\n\n        }\n        // Focus not moved into a valid cell, refocus last cell's target\n        // if there was a previously focused cell.\n        else {\n            lastTarget?.focus();\n        }\n    }\n\n    findFocusables(cell) {\n        const\n            { focusableFinder } = this,\n            result              = [];\n\n        focusableFinder.currentNode = this.focusableFinderCell = cell;\n\n        for (let focusable = focusableFinder.nextNode(); focusable; focusable = focusableFinder.nextNode()) {\n            result.push(focusable);\n        }\n        return result;\n    }\n\n    get focusableFinder() {\n        const me = this;\n\n        if (!me._focusableFinder) {\n            me._focusableFinder = me.setupTreeWalker(me.bodyElement, DomHelper.NodeFilter.SHOW_ELEMENT, {\n                acceptNode : containedFocusable.bind(me)\n            });\n        }\n\n        return me._focusableFinder;\n    }\n\n    /**\n     * Sets the passed record as the current focused record for keyboard navigation and selection purposes.\n     * This API is used by Combo to activate items in its picker.\n     * @param {Core.data.Model|Number|String} activeItem The record, or record index, or record id to highlight as the active (\"focused\") item.\n     * @internal\n     */\n    restoreActiveItem(item = this._focusedCell) {\n        if (this.rowManager.count) {\n            // They sent a row number.\n            if (!isNaN(item)) {\n                item = this.store.getAt(item);\n            }\n            // Still not a record, treat it as a record ID.\n            else if (!item.isModel) {\n                item = this.store.getById(item);\n            }\n            return this.focusCell(item);\n        }\n    }\n\n    /**\n     * Navigates to a cell and/or its row (depending on selectionMode)\n     * @param {LocationConfig} cellSelector Cell location descriptor\n     * @param {Object} options Modifier options for how to deal with focusing the cell. These\n     * are used as the {@link Core.helper.util.Scroller#function-scrollTo} options.\n     * @param {ScrollOptions|Boolean} [options.scroll=true] Pass `false` to not scroll the cell into view, or a\n     * scroll options object to affect the scroll.\n     * @returns {Grid.util.Location} A Location object representing the focused location.\n     * @fires navigate\n     */\n    focusCell(cellSelector, options = defaultFocusOptions) {\n        const\n            me               = this,\n            { _focusedCell } = me,\n            {\n                scroll,\n                disableActionable\n            }                = options;\n\n        // If we're being asked to go to a nonexistent header row, revert focus outwards\n        if (cellSelector?.rowIndex === -1 && me.hideHeaders) {\n            me.revertFocus();\n            return;\n        }\n\n        // Get a Grid Location.\n        // If the cellSelector is a number, it is taken to be a \"relative\" location as defined\n        // in the Location class eg Location.UP, and we move the current focus accordingly.\n        cellSelector = typeof cellSelector === 'number' && _focusedCell?.isLocation ? _focusedCell.move(cellSelector) : me.normalizeCellContext(cellSelector);\n\n        const doSelect = ('doSelect' in options) ? options.doSelect\n            : (!cellSelector.isActionable || cellSelector.initialTarget === cellSelector.cell);\n\n        // Request is a no-op, but it's still a navigate request which selection processing needs to know about\n        if (cellSelector.equals(_focusedCell)) {\n            me.onCellNavigate?.(me, _focusedCell, cellSelector, doSelect);\n            return _focusedCell;\n        }\n\n        const\n            subGrid     = me.getSubGridFromColumn(cellSelector.columnId),\n            { cell }    = cellSelector,\n            testCell    = cell || me.getCell({\n                rowIndex : me.rowManager.topIndex,\n                columnId : cellSelector.columnId\n            }),\n            subGridRect = Rectangle.from(subGrid.element),\n            bodyRect    = Rectangle.from(me.bodyElement),\n            cellRect    = Rectangle.from(testCell).moveTo(null, subGridRect.y);\n\n        // No scrolling possible if we're moving to a column header\n        if (scroll === false || cellSelector.rowIndex === -1) {\n            options = Object.assign({}, options, disableScrolling);\n        }\n        else {\n            options = Object.assign({}, options, scroll);\n\n            // If the test cell is larger than the subGrid, in any dimension, disable scrolling\n            if (cellRect.width > subGridRect.width || cellRect.height > bodyRect.height) {\n                options.x = options.y = false;\n            }\n            // Else ask for the column to be scrolled into view\n            else {\n                options.column = cellSelector.columnId;\n            }\n\n            me.scrollRowIntoView(cellSelector.id, options);\n        }\n\n        // Clear hovering upon navigating so to not have hover style stick around when keyboard navigating away\n        if (me._hoveredRow || me._hoveredCell) {\n            me.setHovered();\n        }\n\n        // Disable auto stepping into the focused cell.\n        me.disableActionable = disableActionable;\n\n        // Go through select pathway upon focus\n        me.selectOnFocus = doSelect;\n\n        // To let onGridBodyFocusIn know where the focus originates\n        me._fromFocusCell = true;\n\n        // Focus the location's target, be it a cell, or an interior element.\n        // The onFocusIn element in this module responds to this.\n        cellSelector[disableActionable ? 'cell' : 'target']?.focus();\n\n        me.disableActionable = me.selectOnFocus = false;\n        delete me._fromFocusCell;\n\n        return cellSelector;\n    }\n\n    blurCell(cellSelector) {\n        const me   = this,\n            cell = me.getCell(cellSelector);\n\n        if (cell) {\n            cell.classList.remove('b-focused');\n        }\n    }\n\n    clearFocus(fullClear) {\n        const me = this;\n\n        if (me._focusedCell) {\n            // set last to have focus return to previous cell when alt tabbing\n            me.lastFocusedCell = fullClear ? null : me._focusedCell;\n\n            me.blurCell(me._focusedCell);\n            me._focusedCell = null;\n        }\n    }\n\n    /**\n     * Selects the cell before or after currently focused cell.\n     * @private\n     * @param next Specify true to select the next cell, false to select the previous\n     * @returns {Object} Used cell selector\n     */\n    internalNextPrevCell(next = true) {\n        const\n            me           = this,\n            cellSelector = me._focusedCell;\n\n        if (cellSelector) {\n            return me.focusCell({\n                id       : cellSelector.id,\n                columnId : me.columns.getAdjacentVisibleLeafColumn(cellSelector.columnId, next, true).id\n            });\n        }\n        return null;\n    }\n\n    /**\n     * Select the cell after the currently focused one.\n     * @param {Event} [event] [DEPRECATED] unused param\n     * @returns {Grid.util.Location} Cell selector\n     */\n    navigateRight() {\n        if (arguments[0]?.fromKeyMap) {\n            return this.focusCell(this.rtl ? Location.PREV_CELL : Location.NEXT_CELL);\n        }\n        if (arguments[0]) {\n            VersionHelper.deprecate('Grid', '6.0.0', 'Event argument removed, unused param');\n        }\n        return this.internalNextPrevCell(!this.rtl);\n    }\n\n    /**\n     * Select the cell before the currently focused one.\n     * @param {Event} [event] [DEPRECATED] unused param\n     * @returns {Grid.util.Location} Cell selector\n     */\n    navigateLeft() {\n        if (arguments[0]?.fromKeyMap) {\n            return this.focusCell(this.rtl ? Location.NEXT_CELL : Location.PREV_CELL);\n        }\n        if (arguments[0]) {\n            VersionHelper.deprecate('Grid', '6.0.0', 'Event argument removed, unused param');\n        }\n        return this.internalNextPrevCell(Boolean(this.rtl));\n    }\n\n    //endregion\n\n    //region Row\n\n    /**\n     * Selects the next or previous record in relation to the current selection. Scrolls into view if outside.\n     * @private\n     * @param next Next record (true) or previous (false)\n     * @param {Boolean} skipSpecialRows True to not return specialRows like headers\n     * @returns {Grid.util.Location|Boolean} Selection context for the focused row (& cell) or false if no selection was made\n     */\n    internalNextPrevRow(next, skipSpecialRows = true, moveToHeader = true) {\n        const\n            me   = this,\n            cell = me._focusedCell;\n\n        if (!cell) return false;\n\n        const record = me.store[`get${next ? 'Next' : 'Prev'}`](cell.id, false, skipSpecialRows);\n\n        if (record) {\n            return me.focusCell({\n                id       : record.id,\n                columnId : cell.columnId,\n                scroll   : {\n                    x : false\n                }\n            });\n        }\n        else if (!next && moveToHeader && !cell.isColumnHeader) {\n            this.clearFocus();\n            return this.getHeaderElement(cell.columnId).focus();\n        }\n    }\n\n    /**\n     * Navigates to the cell below the currently focused cell\n     * @param {Event} [event] [DEPRECATED] unused param\n     * @returns {Grid.util.Location} Selector for focused row (& cell)\n     */\n    navigateDown() {\n        if (arguments[0]?.fromKeyMap) {\n            return this.focusCell(Location.DOWN);\n        }\n        if (arguments[0]) {\n            VersionHelper.deprecate('Grid', '6.0.0', 'Event argument removed, unused param');\n        }\n        return this.internalNextPrevRow(true, false);\n    }\n\n    /**\n     * Navigates to the cell above the currently focused cell\n     * @param {Event} [event] [DEPRECATED] unused param\n     * @returns {Grid.util.Location} Selector for focused row (& cell)\n     */\n    navigateUp() {\n        if (arguments[0]?.fromKeyMap) {\n            return this.focusCell(Location.UP);\n        }\n        if (arguments[0]) {\n            VersionHelper.deprecate('Grid', '6.0.0', 'Event argument removed, unused param');\n        }\n        return this.internalNextPrevRow(false, false);\n    }\n\n    //endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module Grid/view/mixin/GridResponsive\n */\n\n/**\n * Simplifies making grid responsive. Supply levels as {@link #config-responsiveLevels} config, default levels are:\n * <dl>\n * <dt>small <dd>< 400px,\n * <dt>medium <dd>< 600px\n * <dt>large <dd>> 600px\n * </dl>\n *\n * Columns can define configs per level to be resized etc:\n *\n * ```\n * let grid = new Grid({\n *   responsiveLevels: {\n *     small: 300,\n *     medium: 400,\n *     large: '*' // everything above 400\n *   },\n *\n *   columns: [\n *     {\n *       field: 'name',\n *       text: 'Name',\n *       responsiveLevels: {\n *         small: { hidden: true },\n *         '*': { hidden: false } // all other levels\n *       }\n *     },\n *     { field: 'xx', ... }\n *   ]\n * });\n * ```\n *\n * It is also possible to give a [Grid state](#Grid/view/mixin/GridState) object instead of a level width, but in that\n * case the object must contain a `levelWidth` property:\n *\n * ```\n * let grid = new Grid({\n *   responsiveLevels: {\n *     small: {\n *       // Width is required\n *       levelWidth : 400,\n *       // Other configs are optional, see GridState for available options\n *       rowHeight  : 30\n *     },\n *     medium : {\n *       levelWidth : 600,\n *       rowHeight  : 40\n *     },\n *     large: {\n *       levelWidth : '*', // everything above 300\n *       rowHeight  : 45\n *     }\n *   }\n * });\n * ```\n *\n * @demo Grid/responsive\n * @inlineexample Grid/view/mixin/Responsive.js\n * @mixin\n */\nexport default Target => class GridResponsive extends (Target || Base) {\n    static get $name() {\n        return 'GridResponsive';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * \"Break points\" for which responsive config to use for columns and css.\n             * @config {Object<String,Number|String>}\n             * @category Misc\n             * @default { small : 400, medium : 600, large : '*' }\n             */\n            responsiveLevels : Object.freeze({\n                small  : 400,\n                medium : 600,\n                large  : '*'\n            })\n        };\n    }\n\n    /**\n     * Find closes bigger level, aka level we want to use.\n     * @private\n     * @category Misc\n     */\n    getClosestBiggerLevel(width) {\n        const\n            me     = this,\n            levels = Object.keys(ObjectHelper.assign({}, me.responsiveLevels));\n\n        let useLevel     = null,\n            minDelta     = 99995,\n            biggestLevel = null;\n\n        levels.forEach(level => {\n            let levelSize = me.responsiveLevels[level];\n\n            // responsiveLevels can contains config objects, in which case we should use width from it\n            if (!['number', 'string'].includes(typeof levelSize)) {\n                //<debug>\n                if (!('levelWidth' in levelSize)) {\n                    throw new Error('levelWidth required when using state config as responsive level');\n                }\n                //</debug>\n                levelSize = levelSize.levelWidth;\n            }\n\n            if (levelSize === '*') {\n                biggestLevel = level;\n            }\n            else if (width < levelSize) {\n                const delta = levelSize - width;\n                if (delta < minDelta) {\n                    minDelta = delta;\n                    useLevel = level;\n                }\n            }\n        });\n\n        return useLevel || biggestLevel;\n    }\n\n    /**\n     * Get currently used responsive level (as string)\n     * @property {String}\n     * @readonly\n     * @category Misc\n     */\n    get responsiveLevel() {\n        return this.getClosestBiggerLevel(this.width);\n    }\n\n    /**\n     * Check if resize lead to a new responsive level and take appropriate actions\n     * @private\n     * @fires responsive\n     * @param width\n     * @param oldWidth\n     * @category Misc\n     */\n    updateResponsive(width, oldWidth) {\n        const me       = this,\n            oldLevel = me.getClosestBiggerLevel(oldWidth),\n            level    = me.getClosestBiggerLevel(width);\n\n        // On first render oldWidth is 0, in such case we need to apply level anyway\n        if (oldWidth === 0 || oldLevel !== level) {\n            // Level might be a state object\n            const levelConfig = me.responsiveLevels[level];\n            if (!['number', 'string'].includes(typeof levelConfig)) {\n                me.applyState(levelConfig);\n            }\n\n            // check columns for responsive config\n            me.columns.forEach(column => {\n                const levels = column.responsiveLevels;\n                if (levels) {\n                    if (levels[level]) {\n                        // using state to apply responsive config, since it already does what we want...\n                        column.applyState(levels[level]);\n                    }\n                    else if (levels['*']) {\n                        column.applyState(levels['*']);\n                    }\n                }\n            });\n\n            me.element.classList.remove('b-responsive-' + oldLevel);\n            me.element.classList.add('b-responsive-' + level);\n\n            /**\n             * Grid resize lead to a new responsive level being applied\n             * @event responsive\n             * @param {Grid.view.Grid} grid Grid that was resized\n             * @param {String} level New responsive level (small, large, etc)\n             * @param {Number} width New width in px\n             * @param {String} oldLevel Old responsive level\n             * @param {Number} oldWidth Old width in px\n             */\n            me.trigger('responsive', { level, width, oldLevel, oldWidth });\n        }\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\nimport GlobalEvents from '../../../Core/GlobalEvents.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport Collection from '../../../Core/util/Collection.js';\nimport ColumnStore from '../../data/ColumnStore.js';\nimport Location from '../../util/Location.js';\n\nimport '../../column/RowNumberColumn.js';\n\nconst\n    validIdTypes   = {\n        string : 1,\n        number : 1\n    },\n    isDataLoadAction = {\n        dataset : 1,\n        batch   : 1\n    };\n\n/**\n * @module Grid/view/mixin/GridSelection\n */\n\n/**\n * A mixin for Grid that handles row and cell selection. See {@link #config-selectionMode} for details on how to control\n * what should be selected (rows or cells)\n *\n * @example\n * // select a row\n * grid.selectedRow = 7;\n *\n * // select a cell\n * grid.selectedCell = { id: 5, columnId: 'column1' }\n *\n * // select a record\n * grid.selectedRecord = grid.store.last;\n *\n * // select multiple records by ids\n * grid.selectedRecords = [1, 2, 4, 6]\n *\n * @mixin\n */\nexport default Target => class GridSelection extends (Target || Base) {\n    static get $name() {\n        return 'GridSelection';\n    }\n\n    static configurable =  {\n        /**\n         * The selection settings, where you can set these boolean flags to control what is selected. Options below:\n         * @config {Object} selectionMode\n         * @param {Boolean} selectionMode.cell Set to `true` to enable cell selection. This takes precedence over\n         * row selection, but rows can still be selected programmatically or with checkbox or RowNumber selection.\n         * Required for `column` selection\n         * @param {Boolean} selectionMode.multiSelect Allow multiple selection with ctrl and shift+click or with\n         * `checkbox` selection. Required for `dragSelect` and `column` selection\n         * @param {Boolean|CheckColumnConfig} selectionMode.checkbox Set to `true` to add a checkbox selection column to\n         * the grid, or pass a config object for the {@link Grid.column.CheckColumn}\n         * @param {Number|String} selectionMode.checkboxIndex Positions the checkbox column at the provided index or to\n         * the right of a provided column id. Defaults to 0 or to the right of an included `RowNumberColumn`\n         * @param {Boolean} selectionMode.checkboxOnly Select rows only when clicking in the checkbox column. Requires\n         * cell selection config to be `false` and checkbox to be set to `true`. This setting was previously named\n         * `rowCheckboxSelection`\n         * @param {Boolean} selectionMode.showCheckAll Set to `true` to add a checkbox to the selection column header to\n         * select/deselect all rows. Requires checkbox to also be set to `true`\n         * @param {Boolean} selectionMode.deselectFilteredOutRecords Set to `true` to deselect records when they are\n         * filtered out\n         * @param {Boolean|String} selectionMode.includeChildren Set to `true` to also select/deselect child nodes\n         * when a parent node is selected by toggling the checkbox. Set to `always` to always select/deselect child\n         * nodes.\n         * @param {Boolean|'all'|'some'} selectionMode.includeParents Set to `all` or `true` to auto select\n         * parent if all its children gets selected. If one gets deselected, the parent will also be deselected. Set to\n         * 'some' to select parent if one of its children gets selected. The parent will be deselected if all children\n         * gets deselected.\n         * @param {Boolean} selectionMode.preserveSelectionOnPageChange In `row` selection mode, this flag controls\n         * whether the Grid should preserve its selection when loading a new page of a paged data store. Defaults to\n         * `false`\n         * @param {Boolean} selectionMode.preserveSelectionOnDatasetChange In `row` selection mode, this flag\n         * controls whether the Grid should preserve its selection of cells / rows when loading a new dataset\n         * (assuming the selected records are included in the newly loaded dataset)\n         * @param {Boolean} selectionMode.deselectOnClick Toggles whether the Grid should deselect a selected row or\n         * cell when clicking it\n         * @param {Boolean} selectionMode.dragSelect Set to `true` to enable multiple selection by dragging.\n         * Requires `multiSelect` to also be set to `true`. Also requires the {@link Grid.feature.RowReorder} feature\n         * to be set to {@link Grid.feature.RowReorder#config-gripOnly}.\n         * @param {Boolean} selectionMode.selectOnKeyboardNavigation Set to `false` to disable auto-selection by keyboard\n         * navigation. This will activate the `select` keyboard shortcut.\n         * @param {Boolean} column Set to `true` to be able to select whole columns of cells by clicking the header.\n         * Requires cell to be set to `true`\n         * @param {Boolean|RowNumberColumnConfig} rowNumber Set to `true` or a config object to add a RowNumberColumn\n         * which, when clicked, selects the row.\n         * @default\n         * @category Selection\n         */\n        selectionMode : {\n            cell                             : false,\n            multiSelect                      : true,\n            checkboxOnly                     : false,\n            checkbox                         : false,\n            checkboxPosition                 : null,\n            showCheckAll                     : false,\n            deselectFilteredOutRecords       : false,\n            includeChildren                  : false,\n            includeParents                   : false,\n            preserveSelectionOnPageChange    : false,\n            preserveSelectionOnDatasetChange : true,\n            deselectOnClick                  : false,\n            dragSelect                       : false,\n            selectOnKeyboardNavigation       : true,\n            column                           : false,\n            rowNumber                        : false\n        },\n\n        keyMap : {\n            'Shift+ArrowUp'    : 'extendSelectionUp',\n            'Shift+ArrowDown'  : 'extendSelectionDown',\n            'Shift+ArrowLeft'  : 'extendSelectionLeft',\n            'Shift+ArrowRight' : 'extendSelectionRight',\n            ' '                : { handler : 'toggleSelection', weight : 10 }\n        },\n\n        selectedRecordCollection : {}\n    }\n\n    construct(config) {\n        this._selectedCells   = [];\n\n        super.construct(config);\n\n        if (config?.selectedRecords) {\n            this.selectedRecords = config.selectedRecords;\n        }\n    }\n\n    //region Init\n\n    getDefaultGridSelection(clas) {\n        if (clas.$name === 'GridSelection') {\n            return clas.configurable.selectionMode;\n        }\n        else if (clas.superclass) {\n            return this.getDefaultGridSelection(clas.superclass);\n        }\n    }\n\n    changeSelectionMode(mode) {\n        const me = this;\n\n        // If changing the selectionMode config object after creation\n        if (me.selectionMode) {\n            ObjectHelper.assign(me.selectionMode, mode);\n            return me.selectionMode;\n        }\n\n        me.$defaultGridSelection = me.getDefaultGridSelection(me.constructor);\n\n        // Wraps changeSelectionMode object in a proxy to monitor property changes.\n        return new Proxy(mode, {\n            set(obj, prop, value) {\n                const old = ObjectHelper.assign({}, obj);\n                obj[prop] = value;\n                // Calls selectionMode's update method on property change\n                me.updateSelectionMode(obj, old);\n                return true;\n            }\n        });\n    }\n\n    /**\n     * The selectionMode configuration has been changed.\n     * @event selectionModeChange\n     * @param {Object} selectionMode The new {@link #config-selectionMode}\n     */\n\n    // Will be called if selectionMode config object changes or if one of its properties changes\n    updateSelectionMode(mode, oldMode = this.$defaultGridSelection) {\n        const\n            me             = this,\n            {\n                columns,\n                checkboxSelectionColumn\n            }              = me,\n            changed        = {},\n            { rowReorder } = me.features;\n\n        for (const property in mode) {\n            if (mode[property] != oldMode[property]) {\n                changed[property] = mode[property];\n            }\n        }\n\n        // Backwards compatibility. Remove on 7.X?\n        if (mode.rowCheckboxSelection && !mode.checkboxOnly) {\n            mode.checkboxOnly = true;\n            delete mode.rowCheckboxSelection;\n        }\n\n        // If column config has been activated, activate cell and multiSelect\n        if (changed.column) {\n            mode.cell        = true;\n            mode.multiSelect = true;\n        }\n\n        // If cell config has been activated, deactivate checkboxOnly\n        if (changed.cell) {\n            mode.checkboxOnly = false;\n        }\n\n        // If cell config has been deactivated, deactivate column\n        if (changed.cell === false) {\n            mode.column = false;\n        }\n\n        // If checkboxOnly config has been activated, activate checkbox and deactivate cell\n        if (changed.checkboxOnly) {\n            if (!mode.checkbox) {\n                // checkbox can be a CheckboxColumnConfig\n                mode.checkbox = true;\n            }\n            mode.cell = false;\n        }\n\n        // If checkbox config has been deactivated, deactivate checkboxOnly and showCheckAll\n        if (changed.checkbox === false) {\n            changed.checkboxOnly = false;\n            changed.showCheckAll = false;\n        }\n\n        // If showCheckAll has been activated, activate checkbox and multiselect\n        if (changed.showCheckAll) {\n            mode.checkbox    = true;\n            mode.multiSelect = true;\n        }\n\n        // If includeChildren config has been activated, activate multiselect\n        if (changed.includeChildren || changed.includeParents) {\n            mode.multiSelect = true;\n        }\n\n        // If multiSelect has been deactivated, deactivate column, showCheckAll, dragSelect and includeChildren\n        if (changed.multiSelect === false) {\n            mode.column = mode.showCheckAll = mode.dragSelect = mode.includeChildren = mode.includeParents = false;\n        }\n\n        if (changed.dragSelect) {\n            if (rowReorder?.enabled && rowReorder.gripOnly !== true) {\n                rowReorder.showGrip = rowReorder.gripOnly = true;\n            }\n            mode.multiSelect = true;\n            me._selectionListenersDetachers = {};\n        }\n        if (changed.dragSelect === false && me._selectionListenersDetachers) {\n            me._selectionListenersDetachers.selectiondrag?.();\n            delete me._selectionListenersDetachers.selectiondrag;\n        }\n\n        // Deselect all when switching between row or cell selection mode\n        // Deselect all when switching from multiselect to singleselect\n        // Deselect all when changing deselectFilteredOutRecords\n        if (oldMode && (\n            changed.cell !== undefined ||\n                changed.deselectFilteredOutRecords !== undefined ||\n                changed.multiSelect !== undefined\n        )) {\n            me.deselectAll();\n        }\n\n        // Row number selection\n        if (changed.rowNumber) {\n            if (!columns.findRecord('type', 'rownumber')) {\n                columns.insert(0, {\n                    ...(typeof mode.rowNumber == 'object' ? mode.rowNumber : {}),\n                    type : 'rownumber'\n                });\n                me._selectionAddedRowNumberColumn = true;\n            }\n        }\n        else if (changed.rowNumber === false && me._selectionAddedRowNumberColumn) {\n            columns.remove(columns.findRecord('type', 'rownumber'));\n            delete me._selectionAddedRowNumberColumn;\n        }\n\n        // Add or remove checkbox column\n        if (mode.checkbox !== oldMode?.checkbox ||\n            (mode.checkbox && (mode.showCheckAll !== oldMode?.showCheckAll))\n        ) {\n            if (oldMode) {\n                me.deselectAll();\n            }\n            // See to it that were done configuring when initCheckboxSelection is called.\n            if (me.isConfiguring) {\n                me.shouldInitCheckboxSelection = true;\n            }\n            else {\n                me.initCheckboxSelection();\n            }\n        }\n\n        // If only checkboxIndex has changed\n        if (oldMode && mode.checkbox && oldMode.checkbox &&\n            mode.checkboxIndex !== oldMode.checkboxIndex && checkboxSelectionColumn) {\n            checkboxSelectionColumn.parent.insertChild(checkboxSelectionColumn, columns.getAt(me.checkboxSelectionColumnInsertIndex));\n        }\n\n        me.trigger('selectionModeChange', ObjectHelper.clone(mode));\n        me.afterSelectionModeChange(mode);\n    }\n\n    afterConfigure() {\n        // See to it that were done configuring when initCheckboxSelection is called.\n        if (this.shouldInitCheckboxSelection) {\n            this.shouldInitCheckboxSelection = false;\n            this.initCheckboxSelection();\n        }\n        super.afterConfigure();\n    }\n\n    initCheckboxSelection() {\n        const\n            me           = this,\n            {\n                selectionMode,\n                columns,\n                checkboxSelectionColumn\n            }            = me,\n            { checkbox } = selectionMode;\n\n        // Always remove checkbox column when config changes\n        if (checkboxSelectionColumn) {\n            // Need to remove this handle because GridBase restores it if it exists.\n            me.checkboxSelectionColumn = null;\n            columns.remove(checkboxSelectionColumn);\n        }\n\n        // Inject our CheckColumn into the ColumnStore\n        if (checkbox) {\n            const\n                checkColumnClass = ColumnStore.getColumnClass('check'),\n                config           = checkbox === true ? null : checkbox;\n\n            if (!checkColumnClass) {\n                throw new Error('CheckColumn must be imported for checkbox selection mode to work');\n            }\n\n            const col = me.checkboxSelectionColumn = new checkColumnClass(ObjectHelper.assign({\n                id           : `${me.id}-selection-column`,\n                width        : '4em',\n                minWidth     : '4em', // Needed because 4em is below Column's default minWidth\n                field        : null,\n                sortable     : false,\n                filterable   : false,\n                cellCls      : 'b-checkbox-selection',\n                // Always put the checkcolumn in the first region\n                region       : me.items?.[0]?.region,\n                showCheckAll : selectionMode.showCheckAll,\n                draggable    : false,\n                resizable    : false,\n                widgets      : [{\n                    type          : 'checkbox',\n                    valueProperty : 'checked',\n                    ariaLabel     : 'L{Checkbox.toggleRowSelect}'\n                }]\n            }, config), columns, { isSelectionColumn : true });\n\n            col.meta.depth = 0;\n            // This is assigned in Column.js for normal columns\n            col._grid      = me;\n\n            // Override renderer to inject the rendered record's selected status into the value\n            const checkboxRenderer = col.renderer;\n\n            col.renderer = renderData => {\n                renderData.value = me.isSelected(renderData.record);\n                checkboxRenderer.call(col, renderData);\n            };\n\n            col.ion({\n                toggle    : 'onCheckChange',\n                toggleAll : 'onCheckAllChange',\n                thisObj   : me\n            });\n\n            columns.insert(me.checkboxSelectionColumnInsertIndex, col);\n        }\n    }\n\n    // Used internally to get the index where to insert checkboxselectioncolumn\n    // Default : Insert the checkbox after any rownumber column. If not there, -1 means in at 0.\n    // If provided, insert at provided index\n    get checkboxSelectionColumnInsertIndex() {\n        const\n            { columns }       = this;\n        let { checkboxIndex } = this.selectionMode;\n\n        if (!checkboxIndex) {\n            checkboxIndex = columns.indexOf(columns.findRecord('type', 'rownumber')) + 1;\n        }\n        else if (typeof checkboxIndex === 'string') {\n            checkboxIndex = columns.indexOf(columns.getById(checkboxIndex));\n        }\n\n        return checkboxIndex;\n    }\n\n    //endregion\n\n    // region Events docs & Hooks\n\n    /**\n     * The selection has been changed.\n     * @event selectionChange\n     * @param {'select'|'deselect'} action `'select'`/`'deselect'`\n     * @param {'row'|'cell'} mode `'row'`/`'cell'`\n     * @param {Grid.view.Grid} source\n     * @param {Core.data.Model[]|Grid.util.Location[]} deselected The records or cells (depending on the `mode`) deselected in this\n     * operation.\n     * @param {Core.data.Model[]|Grid.util.Location[]} selected The records or cells (depending on the `mode`) selected in this\n     * operation.\n     * @param {Core.data.Model[]|Grid.util.Location[]} selection  The records or cells (depending on the `mode`) in the new selection.\n     */\n\n    /**\n     * Fires before the selection changes. Returning `false` from a listener prevents the change\n     * @event beforeSelectionChange\n     * @preventable\n     * @param {String} action `'select'`/`'deselect'`\n     * @param {'row'|'cell'} mode `'row'`/`'cell'`\n     * @param {Grid.view.Grid} source\n     * @param {Core.data.Model[]|Grid.util.Location[]} deselected The records to be deselected in this operation.\n     * @param {Core.data.Model[]|Grid.util.Location[]} selected The records to be selected in this operation.\n     * @param {Core.data.Model[]|Grid.util.Location[]} selection  The records in the current selection, before applying `selected` and\n     * `deselected`\n     */\n\n    afterSelectionChange() {}\n\n    afterSelectionModeChange() {}\n\n    // endregion\n\n    // region selectedRecordCollection\n\n    changeSelectedRecordCollection(collection) {\n        return collection instanceof Collection ? collection : new Collection(collection);\n    }\n\n    updateSelectedRecordCollection(collection) {\n        collection.ion({\n            change  : 'onSelectedRecordCollectionChange',\n            thisObj : this\n        });\n    }\n\n    onSelectedRecordCollectionChange({ added = [], removed }) {\n        if (!this.selectedRecordCollection._fromSelection) {\n            // Filter out unselectable rows\n            added = added.filter(row => this.isSelectable(row));\n            this.performSelection({\n                selectedCells     : [],\n                deselectedCells   : [],\n                selectedRecords   : added,\n                deselectedRecords : removed\n            });\n        }\n    }\n\n    changeSelectedRecordCollectionSilent(fn) {\n        this.selectedRecordCollection._fromSelection = true;\n        const result = fn(this.selectedRecordCollection);\n        delete this.selectedRecordCollection._fromSelection;\n        return result;\n    }\n    // endregion\n\n    // region Store\n\n    bindStore(store) {\n        this.detachListeners('selectionStoreFilter');\n\n        store.ion({\n            name    : 'selectionStoreFilter',\n            filter  : 'onStoreFilter',\n            thisObj : this\n        });\n        super.bindStore?.(store);\n    }\n\n    unbindStore(oldStore) {\n        this.detachListeners('selectionStoreFilter');\n\n        super.unbindStore(oldStore);\n    }\n\n    onStoreFilter({ source }) {\n        const\n            me       = this,\n            deselect = [];\n\n        // Look for selected records which is not in the store\n        for (const selectedRecord of me.selectedRecords) {\n            if (!source.includes(selectedRecord)) {\n                // Should be deselected\n                deselect.push(selectedRecord);\n            }\n        }\n\n        // Deselects\n        const selectionChange = me.prepareSelection(me.selectionMode.deselectFilteredOutRecords ? deselect : []);\n\n        // If cell mode, always deselect cells\n        if (me.isCellSelectionMode) {\n            const { deselectedCells } = me.prepareSelection(me.getSelectedCellsForRecords(deselect));\n            if (deselectedCells?.length) {\n                selectionChange.deselectedCells = (selectionChange.deselectedCells || []).concat(deselectedCells);\n            }\n        }\n\n        if (selectionChange.deselectedCells.length || selectionChange.deselectedRecords.length) {\n            // Trigger deselect event\n            me.performSelection(selectionChange, false);\n            me.updateCheckboxHeader();\n        }\n    }\n\n    /**\n     * Triggered from Grid view when the id of a record has changed.\n     * Update the collection indices.\n     * @private\n     * @category Selection\n     */\n    onStoreRecordIdChange({ record, oldValue }) {\n        // If the next mixin up the inheritance chain has an implementation, call it\n        super.onStoreRecordIdChange?.(...arguments);\n\n        const item = this.selectedRecordCollection.get(oldValue);\n\n        // having the record registered by the oldValue means we need to rebuild indices\n        if (item === record) {\n            this.selectedRecordCollection.rebuildIndices();\n        }\n    }\n\n    /**\n     * Triggered from Grid view when records get removed from the store.\n     * Deselects all records which have been removed.\n     * @private\n     * @category Selection\n     */\n    onStoreRemove(event) {\n        // If the next mixin up the inheritance chain has an implementation, call it\n        super.onStoreRemove?.(event);\n\n        if (!event.isCollapse) {\n            const\n                me                = this,\n                deselectedRecords = event.records.filter(rec => this.isSelected(rec));\n\n            if (deselectedRecords.length) {\n                const selectionChange = me.prepareSelection(deselectedRecords);\n\n                // If cell selection mode, also deselect cells for removed records\n                // No need to update ui as grid will refresh\n                if (me.isCellSelectionMode) {\n                    const { deselectedCells } = me.prepareSelection(me.getSelectedCellsForRecords(deselectedRecords));\n                    if (deselectedCells?.length) {\n                        selectionChange.deselectedCells = (selectionChange.deselectedCells || []).concat(deselectedCells);\n                    }\n                }\n                me.performSelection(selectionChange);\n            }\n        }\n    }\n\n    /**\n     * Triggered from Grid view when the store changes. This might happen\n     * if store events are batched and then resumed.\n     * Deselects all records which have been removed.\n     * @private\n     * @category Selection\n     */\n\n    onStoreDataChange({ action, source : store }) {\n        const\n            me                 = this,\n            { selectionMode }  = me;\n        let selectionChange;\n\n        // If the next mixin up the inheritance chain has an implementation, call it\n        super.onStoreDataChange?.(...arguments);\n\n        if (action === 'pageLoad') {\n            // on page load, clear selection if not `preserverSelectionOnPageChange` is true\n            if (!selectionMode.preserveSelectionOnPageChange) {\n                selectionChange = me.prepareSelection(null, null, true);\n            }\n\n            // For paged grid scenario, we need to update the check-all checkbox in the checkbox column header\n            // as we move between store pages\n            me.updateCheckboxHeader();\n        }\n        else if (isDataLoadAction[action]) {\n            const deselect = [];\n\n            if (selectionMode.preserveSelectionOnDatasetChange === false) {\n                selectionChange = me.prepareSelection(null, null, true);\n            }\n            else {\n                // Update selected records\n                deselect.push(...me.changeSelectedRecordCollectionSilent(c => c.match(store.storage)));\n\n                for (const selectedCell of me._selectedCells) {\n                    if (!store.getById(selectedCell.id)) {\n                        deselect.push(selectedCell);\n                    }\n                }\n\n                selectionChange = me.prepareSelection(deselect);\n            }\n        }\n        if (selectionChange) {\n            me.performSelection(selectionChange, false);\n            me.updateCheckboxHeader();\n        }\n    }\n\n    /**\n     * Triggered from Grid view when all records get removed from the store.\n     * Deselects all records.\n     * @private\n     * @category Selection\n     */\n    onStoreRemoveAll() {\n        // If the next mixin up the inheritance chain has an implementation, call it\n        super.onStoreRemoveAll?.();\n\n        this.performSelection(this.prepareSelection(null, null, true), false);\n    }\n\n    //endregion\n\n    // region Checkbox selection\n\n    onCheckChange({ checked, record }) {\n        const\n            me          = this,\n            deselectAll = !me.selectionMode.multiSelect && checked,\n            deselect    = !deselectAll && !checked ? [record] : null,\n            select      = checked ? [record] : null;\n\n        // Saves previously non-shift checked checkbox\n        if (checked && !GlobalEvents.shiftKeyDown) {\n            me._lastSelectionChecked = record;\n        }\n        // Shift range select\n        if (checked && me._lastSelectionChecked && GlobalEvents.shiftKeyDown) {\n            me.performSelection(me.internalSelectRange(me._lastSelectionChecked, record, true));\n        }\n        // Regular selection\n        else {\n            // Updates UI and triggers events\n            me.performSelection(me.prepareSelection(deselect, select, deselectAll, true));\n        }\n    }\n\n    // Update header checkbox\n    updateCheckboxHeader() {\n        const { selectionMode, checkboxSelectionColumn, store } = this;\n\n        if (selectionMode.checkbox && selectionMode.showCheckAll && checkboxSelectionColumn?.headerCheckbox) {\n            const allSelected = store.count && !store.some(record => !this.isSelected(record));\n\n            if (checkboxSelectionColumn.headerCheckbox.checked !== allSelected) {\n                checkboxSelectionColumn.suspendEvents();\n                checkboxSelectionColumn.headerCheckbox.checked = allSelected;\n                checkboxSelectionColumn.resumeEvents();\n            }\n        }\n    }\n\n    onCheckAllChange({ checked }) {\n        this[checked ? 'selectAll' : 'deselectAll'](this.store.isPaged && this.selectionMode.preserveSelectionOnPageChange);\n    }\n\n    //endregion\n\n    // region Selection drag\n\n    // Creates new selection range on mouseover. Listener is initiated on mousedown\n    onSelectionDrag(event) {\n        const\n            me                      = this,\n            { _selectionStartCell } = me;\n\n        // If we're here but there's no mouse button down for some reason, cancel\n        if (!GlobalEvents.isMouseDown()) {\n            me.onSelectionEnd();\n        }\n\n        // No start cell, ignore\n        if (!_selectionStartCell) {\n            return;\n        }\n\n        const\n            { items, _lastSelectionDragRegion } = me,\n            cellData                            = me.getCellDataFromEvent(event, true),\n            region                              = cellData?.column.region,\n            cellSelector                        = cellData?.cellSelector && me.normalizeCellContext(cellData.cellSelector);\n\n        // If mouse enters new cell\n        if (cellSelector && !cellSelector.equals(me._lastSelectionDragCell, true)) {\n            if (!me._isSelectionDragging) {\n                // When starting selection, start monitoring for near edge scrolling\n                me.enableScrollingCloseToEdges(items);\n            }\n\n            // If we start a new selection drag on already selected cell, the default (de)selection is delayed until\n            // mouseup. If we detect that a drag range is indeed what the user intends, deselect immediately\n            if (me._clearSelectionOnSelectionDrag && !_selectionStartCell.equals(cellSelector, true)) {\n                me.deselectAll();\n                delete me._clearSelectionOnSelectionDrag;\n            }\n\n            // A grid with multiple regions need to handle selection and scrolling moving between regions\n            if (_lastSelectionDragRegion && region !== _lastSelectionDragRegion) {\n                const\n                    leavingSubGrid     = me.subGrids[_lastSelectionDragRegion],\n                    enteringSubGrid    = me.subGrids[region],\n                    leavingScrollable  = leavingSubGrid.scrollable,\n                    enteringScrollable = enteringSubGrid.scrollable,\n                    goingForward       = items.indexOf(leavingSubGrid) - items.indexOf(enteringSubGrid) < 0;\n\n                // Immediately scrolls an entering subgrid to either start or end depending on direction\n                enteringScrollable.x = goingForward ? 0 : enteringScrollable.maxX;\n\n                // Waiting for grid to scroll to start/end (handled by scrollmanager)\n                if (goingForward ? leavingScrollable.x < leavingScrollable.maxX - 1 : leavingScrollable.x > 1) {\n                    return;\n                }\n\n                // Forces the previous subgrid to stop reserving horizontal scroll\n                me.scrollManager._activeScroll?.horizontal?.stopScroll();\n            }\n\n            me._lastSelectionDragRegion = region;\n            me._lastSelectionDragCell   = cellSelector;\n            me._isSelectionDragging     = true;\n\n            const selectionChange = me._lastSelectionDragChange = me.internalSelectRange(\n                _selectionStartCell,\n                cellSelector,\n                me.isRowNumberSelecting(cellSelector) || me.isRowNumberSelecting(_selectionStartCell));\n\n            // As selection at this point is UI only, we don't want to affect already selected records\n            selectionChange.deselectedCells   = selectionChange.deselectedCells.filter(cell => !me.isCellSelected(cell));\n            selectionChange.deselectedRecords = selectionChange.deselectedRecords.filter(record => !me.isSelected(record));\n\n            // selectionChange event fires onSelectionEnd\n            me.refreshGridSelectionUI(selectionChange);\n\n            /**\n             * Fires while drag selecting. UI will update with current range, but the cells will not be selected until\n             * mouse up. This event can be listened for to perform actions while drag selecting.\n             * @event dragSelecting\n             * @param {Grid.view.Grid} source\n             * @param {Core.data.Model[]|Object} selectedCells The cells that is currently being dragged over\n             */\n            me.trigger('dragSelecting', selectionChange);\n        }\n    }\n\n    // Tells onSelectionDrag that it's not dragging any longer\n    onSelectionEnd() {\n        const\n            me        = this,\n            lastChange = me._lastSelectionDragChange;\n\n        if (me._isSelectionDragging && !me._selectionStartCell.equals(me._lastSelectionDragCell, true) && lastChange) {\n            me.performSelection(lastChange, false);\n        }\n\n        me.disableScrollingCloseToEdges(me.items);\n\n        me._isSelectionDragging     = false;\n        me._lastSelectionDragChange = null;\n        me._lastSelectionDragCell   = null;\n\n        // Remove listeners\n        me._selectionListenersDetachers.selectiondrag?.();\n        delete me._selectionListenersDetachers.selectiondrag;\n    }\n\n    // endregion\n\n    // region Column selection\n\n    onHandleElementClick(event) {\n        const me = this;\n\n        // If rownumber column is clicked, toggle selectAll\n        if (me.selectionMode.rowNumber && event.target.closest('.b-rownumber-header')) {\n            event.handled = true;\n            if (me.store.count && me.store.some(record => !me.isSelected(record))) {\n                me.selectAll();\n            }\n            else {\n                me.deselectAll();\n            }\n\n        }\n        // In column selection mode, and we clicked a header, the column should be selected\n        else if (me.selectionMode.column && event.target.closest('.b-grid-header')) {\n            event.handled = true;\n            me.selectColumn(event, event.ctrlKey);\n        }\n\n        super.onHandleElementClick(event);\n    }\n\n    selectColumn(event, addToSelection = false) {\n        const\n            me           = this,\n            { store }    = me,\n            { columnId } = me.getHeaderDataFromEvent(event);\n\n        // internalSelectRange uses this to remember last range, we have no need for that here\n        me._shiftSelectRange = null;\n\n        if (!event.shiftKey) {\n            me._shiftSelectColumn = columnId;\n        }\n        const\n            fromColumnId    = (event.shiftKey && me._shiftSelectColumn) || columnId,\n            selectionChange = me.internalSelectRange(\n                me.normalizeCellContext({ id : store.first.id, columnId : fromColumnId }),\n                me.normalizeCellContext({ id : store.last.id, columnId })\n            );\n\n        // If we are selecting a column that is already selected, deselect it\n        if (addToSelection && !selectionChange.selectedCells.some(sc => !me.isCellSelected(sc))) {\n            selectionChange.deselectedCells = selectionChange.selectedCells;\n            selectionChange.selectedCells   = [];\n        }\n\n        if (!addToSelection) {\n            selectionChange.deselectedCells = me._selectedCells;\n        }\n        me.cleanSelectionChange(selectionChange);\n        me.performSelection(selectionChange);\n    }\n\n    // endregion\n\n    // region Public row/record selection\n\n    /**\n     * Checks whether a row is selected.\n     * @param {LocationConfig|String|Number|Core.data.Model} cellSelectorOrId Cell selector { id: x, column: xx } or row id, or record\n     * @returns {Boolean} true if row is selected, otherwise false\n     * @category Selection\n     */\n    isSelected(cellSelectorOrId) {\n        // Not a selected cell, check recoWds\n        if (cellSelectorOrId?.id) {\n            cellSelectorOrId = cellSelectorOrId.id;\n        }\n\n        if (validIdTypes[typeof cellSelectorOrId]) {\n            return Boolean(this.selectedRecordCollection.get(cellSelectorOrId));\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether a cell is selected.\n     * @param {LocationConfig|Location} cellSelector Cell selector { id: x, column: xx }\n     * @param {Boolean} includeRow to also check if row is selected\n     * @returns {Boolean} true if cell is selected, otherwise false\n     * @category Selection\n     */\n    isCellSelected(cellSelector, includeRow) {\n        cellSelector = this.normalizeCellContext(cellSelector);\n        return (this.isCellSelectionMode && this._selectedCells.some(cell => cellSelector.equals(cell, true))) ||\n            (includeRow && this.isSelected(cellSelector));\n    }\n\n    /**\n     * Checks whether a cell or row can be selected.\n     * @param {Core.data.Model|LocationConfig|String|Number} recordCellOrId Record or cell or record id\n     * @returns {Boolean} true if cell or row can be selected, otherwise false\n     * @category Selection\n     */\n    isSelectable(recordCellOrId) {\n        return this.normalizeCellContext({ id : recordCellOrId.id || recordCellOrId }).isSelectable;\n    }\n\n    /**\n     * The last selected record. Set to select a row or use Grid#selectRow. Set to null to\n     * deselect all\n     * @property {Core.data.Model}\n     * @category Selection\n     */\n    get selectedRecord() {\n        return this.selectedRecords[this.selectedRecords.length - 1] || null;\n    }\n\n    set selectedRecord(record) {\n        this.selectRow({ record });\n    }\n\n    /**\n     * Selected records.\n     *\n     * If {@link #config-selectionMode deselectFilteredOutRecords} is `false` (default) this will include selected\n     * records which has been filtered out.\n     *\n     * If {@link #config-selectionMode preserveSelectionOnPageChange} is `true` (defaults to `false`) this will include\n     * selected records on all pages.\n     *\n     * Can be set as array of ids:\n     *\n     * ```javascript\n     * grid.selectedRecords = [1, 2, 4, 6]\n     * ```\n     *\n     * @property {Core.data.Model[]}\n     * @accepts {Core.data.Model[]|Number[]}\n     * @category Selection\n     */\n    get selectedRecords() {\n        return this.selectedRecordCollection.values;\n    }\n\n    set selectedRecords(selectedRecords) {\n        this.selectRows(selectedRecords);\n    }\n\n    /**\n     * Removes and adds records to/from the selection at the same time. Analogous\n     * to the `Array` `splice` method.\n     *\n     * Note that if items that are specified for removal are also in the `toAdd` array,\n     * then those items are *not* removed then appended. They remain in the same position\n     * relative to all remaining items.\n     *\n     * @param {Number} index Index at which to remove a block of items. Only valid if the\n     * second, `toRemove` argument is a number.\n     * @param {Object[]|Number} toRemove Either the number of items to remove starting\n     * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).\n     * @param  {Object[]|Object} toAdd An item, or an array of items to add.\n     */\n    spliceSelectedRecords(index, toRemove, toAdd) {\n        const me = this;\n\n        if (typeof toRemove == 'number') {\n            const select = [...me.selectedRecords];\n            select.splice(index, toRemove, ...ArrayHelper.asArray(toAdd));\n            me.performSelection(me.prepareSelection(null, select, true, true));\n        }\n        else {\n            // Just add and remove\n            me.performSelection(me.prepareSelection(toRemove, toAdd, false, true));\n        }\n    }\n\n    /**\n     * Select one row\n     * @param {Object|Core.data.Model|String|Number} options A record or id to select or a config object describing the\n     * selection\n     * @param {Core.data.Model|String|Number} options.record Record or record id, specifying null will deselect all\n     * @param {Grid.column.Column} [options.column] The column to scroll into view if `scrollIntoView` is not specified as\n     * `false`. Defaults to the grid's first column.\n     * @param {Boolean} [options.scrollIntoView] Specify `false` to prevent row from being scrolled into view\n     * @param {Boolean} [options.addToSelection] Specify `true` to add to selection, defaults to `false` which replaces\n     * @fires selectionChange\n     * @category Selection\n     */\n    selectRow(options) {\n        // Make sure we have an object\n        if (typeof options === 'number' || options.isModel || !('record' in options)) {\n            options = {\n                records : [options]\n            };\n        }\n\n        // scrollIntoView is default here\n        ObjectHelper.assignIf(options, {\n            scrollIntoView : true\n        });\n\n        this.selectRows(options);\n    }\n\n    /**\n     * Select one or more rows\n     * @param {Object|Core.data.Model[]|String[]|Number[]} options An array of records or ids for a record or a\n     * config object describing the selection\n     * @param {Core.data.Model[]|String[]|Number[]} records An array of records or ids for a record\n     * @param {Grid.column.Column} options.column The column to scroll into view if `scrollIntoView` is not specified as\n     * `false`. Defaults to the grid's first column.\n     * @param {Boolean} [options.scrollIntoView] Specify `false` to prevent row from being scrolled into view\n     * @param {Boolean} [options.addToSelection] Specify `true` to add to selection, defaults to `false` which replaces\n     * @category Selection\n     */\n    selectRows(options) {\n        // Got a single or an array of records/ids, convert it to an object\n        if (!options || Array.isArray(options) || options.isModel || typeof options === 'number' ||\n            (!('records' in options) && !('record' in options))\n        ) {\n            options = {\n                records : ArrayHelper.asArray(options) || []\n            };\n        }\n\n        const\n            me                 = this,\n            { store }          = me,\n            toSelect           = [],\n            {\n                records        = options.record ? [options.record] : [], // Got a record instead of records\n                column         = me.columns.visibleColumns[0], // Default\n                scrollIntoView,\n                addToSelection = arguments[1] // Backwards compatibility\n            }                  = options;\n\n        for (let record of records) {\n            record = store.getById(record);\n            if (record) {\n                toSelect.push(record);\n            }\n        }\n\n        if (!addToSelection) {\n            me._shiftSelectRange = null;\n        }\n\n        me.performSelection(me.prepareSelection(null, toSelect, !addToSelection, true));\n\n        if (toSelect.length && scrollIntoView) {\n            me.scrollRowIntoView(toSelect[0].id, {\n                column\n            });\n        }\n    }\n\n    /**\n     * This selects all rows. If store is filtered, this will merge the selection of all visible rows with any selection\n     * made prior to filtering.\n     * @privateparam {Boolean} [silent] Pass `true` not to fire any event upon selection change\n     * @category Selection\n     */\n    selectAll(silent = false) {\n        const\n            { store } = this,\n            records   = (store.isGrouped ? store.allRecords : store.records).filter(r => !r.isSpecialRow);\n        // If store is grouped, store.records excludes collapsed records and allRecords excludes filtered out records\n        // Else, store records holds what we're after\n        this.performSelection(this.prepareSelection(null, records, false, true), true, silent);\n    }\n\n    /**\n     * Deselects all selected rows and cells. If store is filtered, this will unselect all visible rows only. Any\n     * selections made prior to filtering remains.\n     * @param {Boolean} [removeCurrentRecordsOnly] Pass `false` to clear all selected records, and `true` to only\n     * clear selected records in the current set of records\n     * @param {Boolean} [silent] Pass `true` not to fire any event upon selection change\n     * @category Selection\n     */\n    deselectAll(removeCurrentRecordsOnly = false, silent = false) {\n        const\n            { store } = this,\n            records   = removeCurrentRecordsOnly\n                ? (store.isGrouped ? store.allRecords : store.records).filter(r => !r.isSpecialRow) : null;\n\n        this.performSelection(this.prepareSelection(records, null, !removeCurrentRecordsOnly), true, silent);\n    }\n\n    /**\n     * Deselect one row\n     * @param {Core.data.Model|String|Number} recordOrId Record or an id for a record\n     * @category Selection\n     */\n    deselectRow(record) {\n        this.deselectRows(record);\n    }\n\n    /**\n     * Deselect one or more rows\n     * @param {Core.data.Model|String|Number|Core.data.Model[]|String[]|Number[]} recordOrIds An array of records or ids\n     * for a record\n     * @category Selection\n     */\n    deselectRows(recordsOrIds) {\n        // Ignore any non-existing row records passed\n        const\n            { store } = this,\n            records   = ArrayHelper.asArray(recordsOrIds).map(recordOrId => store.getById(recordOrId)).filter(rec => rec);\n\n        this.performSelection(this.prepareSelection(records));\n    }\n\n    /**\n     * Selects rows corresponding to a range of records (from fromId to toId)\n     * @param {String|Number} fromId\n     * @param {String|Number} toId\n     * @category Selection\n     */\n    selectRange(fromId, toId, addToSelection = false) {\n        const\n            me        = this,\n            { store } = me,\n            selection = me.internalSelectRange(store.getById(fromId), store.getById(toId), true);\n\n        me._shiftSelectRange = null; // For below function to not replace last range with new one\n        me.performSelection(selection);\n    }\n\n    // endregion\n\n    // region Public cell selection\n\n    /**\n     * In cell selection mode, this will get the cell selector for the (last) selected cell. Set to an available cell\n     * selector to select only that cell. Or use {@link #function-selectCell()} instead.\n     * @property {Grid.util.Location}\n     * @category Selection\n     */\n    get selectedCell() {\n        return this._selectedCells[this._selectedCells.length - 1];\n    }\n\n    set selectedCell(cellSelector) {\n        this.selectCells([cellSelector]);\n    }\n\n    /**\n     * In cell selection mode, this will get the cell selectors for all selected cells. Set to an array of available\n     * cell selectors. Or use {@link #function-selectCells()} instead.\n     * @property {Grid.util.Location[]}\n     * @category Selection\n     */\n    get selectedCells() {\n        return [...this._selectedCells];\n    }\n\n    set selectedCells(cellSelectors) {\n        this.selectCells(cellSelectors);\n    }\n\n    /**\n     * CSS selector for the currently selected cell. Format is \"[data-index=index] [data-column-id=column]\".\n     * @type {String}\n     * @category Selection\n     * @readonly\n     */\n    get selectedCellCSSSelector() {\n        const\n            cell = this.selectedCell,\n            row  = cell && this.getRowById(cell.id);\n\n        if (!cell || !row) return '';\n\n        return `[data-index=${row.dataIndex}] [data-column-id=${cell.columnId}]`;\n    }\n\n    /**\n     * If in cell selection mode, this selects one cell. If not, this selects the cell's record.\n     * @param {LocationConfig|Object} options A cell selector ({ id: rowId, columnId: 'columnId' }) or a config object\n     * @param {LocationConfig} options.cell  A cell selector ({ id: rowId, columnId: 'columnId' })\n     * @param {Boolean} [options.scrollIntoView] Specify `false` to prevent row from being scrolled into view\n     * @param {Boolean} [options.addToSelection] Specify `true` to add to selection, defaults to `false` which replaces\n     * @param {Boolean} [options.silent] Specify `true` to not trigger any events when selecting the cell\n     * @returns {Grid.util.Location} Cell selector\n     * @fires selectionChange\n     * @category Selection\n     */\n    selectCell(options) {\n        // Got a cell selector as first argument\n        if ('id' in options) {\n            options = {\n                cell : options\n            };\n\n            // Arguments backward's compability\n            options = Object.assign({\n                scrollIntoView : arguments[1],\n                addToSelection : arguments[2],\n                silent         : arguments[3]\n            }, options);\n        }\n\n        return this.selectCells(options)?.[0];\n    }\n\n    /**\n     * If in cell selection mode, this selects a number of cells. If not, this selects corresponding records.\n     * @param {Object|LocationConfig[]} options An array of cell selectors ({ id: rowId, columnId: 'columnId' }) or a config\n     * object\n     * @param {LocationConfig[]} options.cells An array of cell selectors { id: rowId, columnId: 'columnId' }\n     * @param {Boolean} [options.scrollIntoView] Specify `false` to prevent row from being scrolled into view\n     * @param {Boolean} [options.addToSelection] Specify `true` to add to selection, defaults to `false` which replaces\n     * @param {Boolean} [options.silent] Specify `true` to not trigger any events when selecting the cell\n     * @returns {Grid.util.Location[]} Cell selectors\n     * @returns {Grid.util.Location[]} Cell selectors\n     * @fires selectionChange\n     * @category Selection\n     */\n    selectCells(options) {\n        // Got a cell selector array as first argument\n        if (Array.isArray(options)) {\n            options = {\n                cells : options\n            };\n        }\n\n        const\n            me                 = this,\n            {\n                cells          = options.cell ? [options.cell] : [], // Got a cell instead of cells\n                scrollIntoView = true,\n                addToSelection = false,\n                silent         = false\n            }                  = options,\n            selectionChange    = me.prepareSelection(null, cells, !addToSelection);\n\n        if (!addToSelection) {\n            me._shiftSelectRange = null;\n        }\n\n        me.performSelection(selectionChange, true, silent);\n\n        if (scrollIntoView) {\n            me.scrollRowIntoView(cells[0].id, {\n                column : cells[0].columnId\n            });\n        }\n\n        return me.isCellSelectionMode ? selectionChange.selectedCells : selectionChange.selectedRecords;\n    }\n\n    /**\n     * If in cell selection mode, this deselects one cell. If not, this deselects the cell's record.\n     * @param {LocationConfig} cellSelector\n     * @returns {Grid.util.Location} Normalized cell selector\n     * @category Selection\n     */\n    deselectCell(cellSelector) {\n        return this.deselectCells([cellSelector])?.[0];\n    }\n\n    /**\n     * If in cell selection mode, this deselects a number of cells. If not, this deselects corresponding records.\n     * @param {LocationConfig[]} cellSelectors\n     * @returns {Grid.util.Location[]} Normalized cell selectors\n     * @category Selection\n     */\n    deselectCells(cellSelectors) {\n        const selectionChange = this.prepareSelection(cellSelectors);\n        this.performSelection(selectionChange);\n        return this.isCellSelectionMode ? selectionChange.deselectedCells : selectionChange.deselectedRecords;\n    }\n\n    // Used by keymap to toggle selection of currently focused cell.\n    toggleSelection(keyEvent) {\n        const\n            me          = this,\n            {\n                _focusedCell,\n                selectionMode\n            }           = me,\n            isRowNumber = me.isRowNumberSelecting(_focusedCell),\n            isSelected  = me.isCellSelected(_focusedCell, true);\n\n        // Only if keyboardNavigation selection is deactivated and were not focusing an actionable cell\n        if (selectionMode.selectOnKeyboardNavigation === true || _focusedCell.isActionable) {\n            // Return false to ley keyMap know we didn't handle this event\n            return false;\n        }\n\n        me.performSelection(\n            me.prepareSelection(\n                isSelected ? _focusedCell : null,\n                isSelected ? null : _focusedCell,\n                !selectionMode.multiSelect,\n                isRowNumber\n            ));\n\n        // Space key has preventDefault = false somewhere\n        keyEvent.preventDefault();\n    }\n\n    /**\n     * Selects a range of cells, from a cell selector (Location) to another\n     * @param {Grid.util.Location|LocationConfig} from\n     * @param {Grid.util.Location|LocationConfig} to\n     * @category Selection\n     */\n    selectCellRange(from, to) {\n        this.performSelection(this.internalSelectRange(from, to));\n    }\n\n    // endregion\n\n    // region Private convenience functions & properties\n    getSelection() {\n        if (this.isRowSelectionMode) {\n            return this.selectedRecords;\n        }\n        else {\n            return this.selectedCells;\n        }\n    }\n\n    // Makes sure the same record or cell isn't deselected and selected at the same time. Selection will take precedence\n    cleanSelectionChange(selectionChange) {\n        const\n            {\n                deselectedRecords,\n                selectedRecords,\n                deselectedCells,\n                selectedCells\n            } = selectionChange;\n\n        // Filter out records which is both selected and deselected\n        if (deselectedRecords?.length && selectedRecords?.length) {\n            selectionChange.deselectedRecords = deselectedRecords.filter(dr => !selectedRecords.some(sr => dr === sr));\n        }\n\n        // Filter out cells which is both selected and deselected\n        if (deselectedCells?.length && selectedCells?.length) {\n            selectionChange.deselectedCells = deselectedCells.filter(dc => !selectedCells.some(sc => dc.equals(sc, true)));\n        }\n\n        return selectionChange;\n    }\n\n    getSelectedCellsForRecords(records) {\n        return this._selectedCells.filter(cell => cell.id && records.some(record => record.id === cell.id));\n    }\n\n    delayUntilMouseUp(fn) {\n        const detacher = EventHelper.on({\n            element : globalThis,\n            blur    : (ev) => fn(ev, detacher),\n            mouseup : (ev) => fn(ev, detacher),\n            thisObj : this,\n            once    : true\n        });\n    }\n\n    get isRowSelectionMode() {\n        return !this.isCellSelectionMode;\n    }\n\n    get isCellSelectionMode() {\n        return this.selectionMode.cell === true;\n    }\n\n    // Checks if rowNumber is activated and that all arguments (cellselectors) is of type rownumber\n    isRowNumberSelecting(...selectors) {\n        return this.selectionMode.rowNumber && !selectors.some(cs => cs.column.type !== 'rownumber');\n    }\n\n    // endregion\n\n    //region Navigation\n\n    // Used by keyMap to extend selection range\n    extendSelectionLeft() {\n        this.extendSelection('Left');\n    }\n\n    // Used by keyMap to extend selection range\n    extendSelectionRight() {\n        this.extendSelection('Right');\n    }\n\n    // Used by keyMap to extend selection range\n    extendSelectionUp() {\n        this.extendSelection('Up');\n    }\n\n    // Used by keyMap to extend selection range\n    extendSelectionDown() {\n        this.extendSelection('Down');\n    }\n\n    // Used by keyMap to extend selection range\n    extendSelection(dir) {\n        this._isKeyboardRangeSelecting = true;\n        this['navigate' + dir]();\n        this._isKeyboardRangeSelecting = false;\n    }\n\n    // Called from GridNavigation on mouse or keyboard events\n    // Single entry point for all default user selection actions\n    onCellNavigate(me, fromCellSelector, toCellSelector, doSelect) {\n        const\n            {\n                selectionMode,\n                _selectionListenersDetachers\n            }                                            = me,\n            { rowReorder }                                = me.features,\n            { multiSelect, deselectOnClick, dragSelect } = selectionMode,\n            { ctrlKeyDown, shiftKeyDown }                = GlobalEvents,\n            isMouseLeft                                  = GlobalEvents.isMouseDown(),\n            isMouseRight                                 = GlobalEvents.isMouseDown(2),\n            currentEvent                                 = GlobalEvents.currentMouseDown || GlobalEvents.currentKeyDown,\n            currentTarget                                = currentEvent?.target;\n\n        // To be sure we got Locations\n        toCellSelector = me.normalizeCellContext(toCellSelector);\n\n        if (\n            !doSelect ||\n            // Do not affect selection if navigating into header row.\n            toCellSelector.rowIndex === -1 ||\n            toCellSelector.record?.isGroupHeader ||\n            // Don't allow keyboard selection if keyboardNavigation is deactivated\n            (currentEvent?.fromKeyMap && !selectionMode.selectOnKeyboardNavigation) ||\n            // CheckColumn events are handled by the CheckColumn itself.\n            me.columns.getById(toCellSelector.columnId) === me.checkboxSelectionColumn ||\n            selectionMode.checkboxOnly ||\n            // Don't select on the row reorder gripper\n            (currentTarget && rowReorder?.gripOnly && rowReorder.isElementDraggable(currentTarget, currentEvent)) ||\n            currentEvent?.handled === true\n        ) {\n            return;\n        }\n\n        // Save adding state unless shift key\n        if (!shiftKeyDown) {\n            me._isAddingToSelection = ctrlKeyDown && multiSelect;\n            me._selectionStartCell  = toCellSelector; // To be able to begin a new range\n        }\n\n        // Flags that it's possible for onSelectDrag to apply its logic if the right conditions are met\n        if (multiSelect && dragSelect && isMouseLeft && !_selectionListenersDetachers.selectiondrag) {\n            _selectionListenersDetachers.selectiondrag = EventHelper.on({\n                name      : 'selectiondrag',\n                element   : globalThis,\n                blur      : 'onSelectionEnd',\n                mouseup   : 'onSelectionEnd',\n                mousemove : 'onSelectionDrag',\n                thisObj   : me\n            });\n        }\n\n        const\n            startCell = me._selectionStartCell,\n            adding    = me._isAddingToSelection;\n\n        // Select range on shiftKey\n        if (((shiftKeyDown && isMouseLeft) || me._isKeyboardRangeSelecting) && startCell && multiSelect) {\n            me.performSelection(\n                me.internalSelectRange(\n                    startCell,\n                    toCellSelector,\n                    me.isRowNumberSelecting(startCell, toCellSelector)\n                )\n            );\n        }\n        else {\n            let delay             = false,\n                continueSelecting = true,\n                deselect;\n\n            // If current is already selected\n            if (me.isCellSelected(toCellSelector, true)) {\n                // Do nothing if we right-clicked already selected row/cell\n                if (isMouseRight) {\n                    return;\n                }\n                // Deselect current if selected and multiselecting or deselect all if deselectOnClick is true\n                if ((adding || deselectOnClick)) {\n                    deselect = deselectOnClick ? null : [toCellSelector];\n                    continueSelecting = false; // Only deselect at this code path\n                }\n                // If this is only row or cell that's selected\n                else if (me.selectedRecords.length + (me.isCellSelectionMode ? me._selectedCells.length : 0) <= 1) {\n                    // Should stay selected, do no more\n                    return;\n                }\n                // Delay if click a selected cell which will be deselected (for dragging)\n                delay = deselectOnClick || multiSelect;\n            }\n            // deselect all if not multiselecting\n            if (!deselect && !adding) {\n                deselect = null;\n                // Set flag so that dragselection functionality know to clear selection if needed\n                if (dragSelect && delay && _selectionListenersDetachers.selectiondrag) {\n                    me._clearSelectionOnSelectionDrag = true;\n                }\n            }\n\n            // Wrapping selection in a function to be called either directly or on mouse up\n            const finishSelection = (mouseUpEvent, detacher) => {\n                detacher?.();\n                if (mouseUpEvent?.target?.nodeType === Node.ELEMENT_NODE) {\n                    // If we are waiting for mouseUp and have moved to a different cell, abort selection change\n                    const mouseUpSelector = new Location(mouseUpEvent.target);\n                    if (mouseUpSelector?.grid && !mouseUpSelector.equals(toCellSelector, true)) {\n                        return;\n                    };\n                }\n\n                if (!shiftKeyDown) {\n                    me._shiftSelectRange = null; // Clear any previous range selected\n                }\n\n                me.performSelection(\n                    me.prepareSelection(\n                        deselect,\n                        continueSelecting && [toCellSelector],\n                        deselect === null,\n                        continueSelecting && me.isRowNumberSelecting(toCellSelector)\n                    )\n                );\n            };\n\n            // Delay doing the selection until mouse up for allowing drag of row in certain cases\n            if (delay) {\n                me.delayUntilMouseUp(finishSelection);\n            }\n            else {\n                finishSelection();\n            }\n        }\n    }\n\n    // endregion\n\n    // region Internal selection & deselection functions\n\n    /**\n     * Used internally to prepare a number of cells or records for selection/deselection depending on if cell\n     * selectionMode is activated. This function will not select/deselect anything by itself\n     * (that's done in performSelection).\n     * @param {LocationConfig[]|Core.data.Model[]} cellSelectorsToDeselect Array of cell selectors or records.\n     * @param {LocationConfig[]|Core.data.Model[]} cellSelectorsToSelect Array of cell selectors or records.\n     * @param {Boolean} deselectAll Set to `true` to clear all selected records and cells.\n     * @param {Boolean} forceRecordSelection Set to `true` to force record selection even if cell selection is active.\n     * @returns {Object} selectionChange object to use for UI update\n     * @private\n     * @category Selection\n     */\n    prepareSelection(cellSelectorsToDeselect, cellSelectorsToSelect, deselectAll = false, forceRecordSelection = false) {\n        const\n            me                 = this,\n            isDragging         = me._isSelectionDragging,\n            { includeParents } = me.selectionMode,\n            selectedRecords    = [],\n            selectedCells      = [];\n        let deselectedCells    = [],\n            deselectedRecords  = [];\n\n        if (deselectAll) {\n            deselectedCells = me._selectedCells;\n            deselectedRecords = me.selectedRecords;\n        }\n        else if (cellSelectorsToDeselect) {\n            for (const selector of ArrayHelper.asArray(cellSelectorsToDeselect)) {\n                const\n                    cellSelector = me.normalizeCellContext(selector),\n                    record = cellSelector?.record || (selector.isModel ? selector : me.store.getById(cellSelector.id));\n\n                if (!cellSelector.isSpecialRow) {\n                    deselectedCells.push(cellSelector);\n                    if (record && !deselectedRecords.some(r => r.id === record.id)) {\n                        // When dragging, this path is taken but nothing is actually selected until mouseup\n                        // So should check if selected for dragselection (until mouseup)\n                        if (isDragging || me.isSelected(record)) {\n                            deselectedRecords.push(record);\n                        }\n                        // If configured, also deselect children\n                        if (me.selectionMode.includeChildren && me.selectionMode.multiSelect && !record.isLeaf && record.allChildren?.length) {\n                            for (const child of record.allChildren) {\n                                if (!deselectedRecords.some(r => r.id === child.id) && (isDragging || me.isSelected(child))) {\n                                    deselectedRecords.push(child);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (cellSelectorsToSelect) {\n            for (const selector of ArrayHelper.asArray(cellSelectorsToSelect)) {\n                const\n                    cellSelector = me.normalizeCellContext(selector),\n                    record = cellSelector?.record || (selector.isModel ? selector : me.store.getById(cellSelector.id));\n\n                if (record && !cellSelector.isSpecialRow) {\n                    // Only select cells if in cell selection mode and not forcing record selection\n                    if (me.isCellSelectionMode && !forceRecordSelection) {\n                        selectedCells.push(cellSelector);\n                    }\n                    if ((me.isRowSelectionMode || forceRecordSelection) && !selectedRecords.some(r => r.id === record.id)) {\n                        selectedRecords.push(record);\n                        // If configured, also select children\n                        if (me.selectionMode.includeChildren && me.selectionMode.multiSelect && !record.isLeaf && record.allChildren?.length) {\n                            for (const child of record.allChildren) {\n                                if (!selectedRecords.some(r => r.id === child.id)) {\n                                    selectedRecords.push(child);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // This setting could be either off, or true/'all' or 'some'\n        if (includeParents && (deselectedRecords.length || selectedRecords.length)) {\n            const\n                allChanges         = [...deselectedRecords, ...selectedRecords],\n                lowestLevelParents = ArrayHelper.unique(\n                    allChanges.filter(rec =>\n                        rec.parent && !rec.allChildren.some(child =>\n                            allChanges.includes(child))).map(rec => rec.parent));\n\n            lowestLevelParents.forEach(parent => me.toggleParentSelection(parent, selectedRecords, deselectedRecords));\n\n        }\n\n        return me.cleanSelectionChange({\n            selectedCells,\n            selectedRecords,\n            deselectedCells,\n            deselectedRecords,\n            deselectAll,\n            action : selectedRecords?.length || selectedCells?.length ? 'select' : 'deselect'\n        });\n    }\n\n    toggleParentSelection(parent, toSelect, toDeselect) {\n        if (!parent || parent.isRoot) {\n            return;\n        }\n\n        const\n            isSelected      = this.isSelected(parent),\n            inToSelect      = toSelect.includes(parent),\n            inToDeselect    = toDeselect.includes(parent),\n            childIsSelected = child => (this.isSelected(child) && !toDeselect.includes(child)) || toSelect.includes(child);\n\n        if (this.selectionMode.includeParents === 'some') {\n            // If any children are selected\n            if (parent.allChildren.some(childIsSelected)) {\n                // And parent is not being deselected => select\n                if ((!isSelected || inToDeselect) && !inToSelect) {\n                    toSelect.push(parent);\n                }\n            }\n            // No children are selected and parent is selected => deselect\n            else if (isSelected && !inToDeselect) {\n                toDeselect.push(parent);\n            }\n        }\n        else { // includeParents = true/'all'\n            if (isSelected) {\n                // If previously selected, and some child is to be deselected => deselect\n                if (!inToDeselect && !inToSelect && parent.allChildren.some(child => toDeselect.includes(child))) {\n                    toDeselect.push(parent);\n                }\n            }\n            else if (!inToSelect) {\n                // If not previously selected, select if all children are selected\n                if (parent.allChildren.every(childIsSelected)) {\n                    toSelect.push(parent);\n                }\n            }\n        }\n\n        // Go up one level if it exists\n        if (parent.parent) {\n            this.toggleParentSelection(parent.parent, toSelect, toDeselect);\n        }\n    }\n\n    /**\n     * Used internally to select a range of cells or records depending on selectionMode. Used in both shift-selection\n     * and for drag selection. Will remember current selection range and replace it with new one when it changes. But a\n     * range which is completed (drag select mouse up or a new shift range starting point has been set) will remain.\n     * This function will not update UI (that's done in refreshGridSelectionUI).\n     * @param {LocationConfig} fromSelector\n     * @param {LocationConfig} toSelector\n     * @returns {Object} selectionChange object to use for UI update\n     * @private\n     * @category Selection\n     */\n    internalSelectRange(fromSelector, toSelector, forceRecordSelection = false) {\n        const\n            me              = this,\n            selectRecords   = me.isRowSelectionMode || forceRecordSelection,\n            selectionChange = me.prepareSelection(me._shiftSelectRange,\n                me.getRange(fromSelector, toSelector, selectRecords), false, forceRecordSelection);\n\n        me._shiftSelectRange = selectionChange[`selected${selectRecords ? 'Records' : 'Cells'}`];\n\n        return selectionChange;\n    }\n\n    /**\n     * Used internally to get a range of cell selectors from a start selector to an end selector.\n     * @private\n     */\n    getRange(fromSelector, toSelector, selectRecords = false) {\n        const\n            me            = this,\n            { store }     = me,\n            fromCell      = me.normalizeCellContext(fromSelector),\n            toCell        = me.normalizeCellContext(toSelector),\n            startRowIndex = Math.min(fromCell.rowIndex, toCell.rowIndex),\n            endRowIndex   = Math.max(fromCell.rowIndex, toCell.rowIndex),\n            toSelect      = [],\n            startColIndex = Math.min(fromCell.columnIndex, toCell.columnIndex),\n            endColIndex   = Math.max(fromCell.columnIndex, toCell.columnIndex);\n\n        if (startRowIndex === -1 || endRowIndex === -1) {\n            throw new Error('Record not found in selectRange');\n        }\n\n        // Row selection\n        if (selectRecords) {\n            const range = store.getRange(startRowIndex, endRowIndex + 1, false);\n            // To make selectedRecords in correct order when range selecting upwards\n            if (toCell.rowIndex < fromCell.rowIndex) {\n                range.reverse();\n            }\n            toSelect.push(...range);\n        }\n        // Cell selection\n        else {\n            // Loops from start cell to end cell and creates selectors for all containing cells\n            for (let rIx = startRowIndex; rIx <= endRowIndex; rIx++) {\n                for (let cIx = startColIndex; cIx <= endColIndex; cIx++) {\n                    toSelect.push({ rowIndex : rIx, columnIndex : cIx });\n                }\n            }\n        }\n\n        return toSelect.map(s => me.normalizeCellContext(s));\n    }\n\n    // endregion\n\n    // region Update UI & trigger events\n\n    performSelection(selectionChange, updateUI = true, silent = false) {\n        const\n            me      = this,\n            {\n                selectedRecords,\n                selectedCells,\n                deselectedRecords,\n                deselectedCells,\n                action\n            }       = selectionChange,\n            rowMode = me.isRowSelectionMode;\n\n        // Fire event to be able to prevent selection\n        if (me.trigger('beforeSelectionChange', {\n            mode       : rowMode ? 'row' : 'cell',\n            action,\n            selected   : (rowMode ? selectedRecords : selectedCells) || [],\n            deselected : (rowMode ? deselectedRecords : deselectedCells) || [],\n            selection  : (rowMode ? me.selectedRecords : me.selectedCells) || []\n        }) === false) {\n            return;\n        }\n\n        // If deselecting all cells\n        if (me._selectedCells === deselectedCells) {\n            me._selectedCells   = [];\n        }\n        // Not deselecting all cells\n        else {\n            const keepCells = [];\n\n            for (const selectedCell of me._selectedCells) {\n                if (!deselectedCells.some(cellSelector => selectedCell.equals(cellSelector, true))) {\n                    keepCells.push(selectedCell);\n                }\n            }\n\n            me._selectedCells   = keepCells;\n        }\n\n        selectionChange.deselectedRecords = [...selectionChange.deselectedRecords];\n        // If deselecting all rows\n        if (deselectedRecords === me.selectedRecords) {\n            me.changeSelectedRecordCollectionSilent(c => c.clear());\n        }\n        // Not deselecting all rows\n        else {\n            const keepRecords = [];\n\n            for (const selectedRecord of me.selectedRecords) {\n                if (!deselectedRecords.some(record => selectedRecord.id === record.id)) {\n                    keepRecords.push(selectedRecord);\n                }\n            }\n\n            me.changeSelectedRecordCollectionSilent(c => c.values = keepRecords);\n        }\n\n        // New selection\n        if (selectedCells.length) {\n            for (const selectedCell of selectedCells) {\n                if (!me._selectedCells.some(cellSelector => cellSelector.equals(selectedCell, true))) {\n                    me._selectedCells.push(selectedCell);\n                }\n            }\n        }\n        if (selectedRecords.length) {\n            me.changeSelectedRecordCollectionSilent(c => c.add(...selectedRecords));\n        }\n\n        if (updateUI) {\n            me.refreshGridSelectionUI(selectionChange);\n        }\n\n        me.afterSelectionChange(selectionChange);\n\n        if (!silent) {\n            me.triggerSelectionChangeEvent(selectionChange);\n        }\n    }\n\n    // Makes sure the DOM is up-to-date with current selection.\n    refreshGridSelectionUI({ selectedRecords, selectedCells, deselectedRecords, deselectedCells }) {\n        const\n            me                          = this,\n            { checkboxSelectionColumn } = me;\n\n        // Row selection\n        checkboxSelectionColumn?.suspendEvents();\n        me.updateGridSelectionRecords(selectedRecords, true);\n        me.updateGridSelectionRecords(deselectedRecords, false);\n        me.updateCheckboxHeader();\n        checkboxSelectionColumn?.resumeEvents();\n\n        // Cell selection\n        if (me.isCellSelectionMode) {\n            me.updateGridSelectionCells(selectedCells, true);\n            if (me.selectionMode.column) {\n                me.updateGridSelectionColumns(selectedCells);\n            }\n        }\n        me.updateGridSelectionCells(deselectedCells, false);\n    }\n\n    // Loops through records and updates Grid rows\n    updateGridSelectionRecords(records, selected) {\n        const { checkboxSelectionColumn } = this;\n        if (records?.length) {\n            for (let i = 0; i < records.length; i++) {\n                const row = this.getRowFor(records[i]);\n                if (row) {\n                    row.toggleCls('b-selected', selected);\n                    row.setAttribute('aria-selected', selected);\n                    if (checkboxSelectionColumn && !checkboxSelectionColumn.hidden && !records[i].isSpecialRow) {\n                        row.getCell(checkboxSelectionColumn.id).widget.checked = selected;\n                    }\n                }\n            }\n        }\n    }\n\n    // Loops through cell selectors and updates Grid cell's\n    updateGridSelectionCells(cells, selected) {\n        if (cells?.length) {\n            for (let i = 0; i < cells.length; i++) {\n                const cell = this.getCell(cells[i]);\n                if (cell) {\n                    cell.setAttribute('aria-selected', selected);\n                    cell.classList.toggle('b-selected', selected);\n                }\n            }\n        }\n    }\n\n    // Loops through columns to toggle their selected state\n    updateGridSelectionColumns(selectedCells) {\n        const { count } = this.store;\n        for (const column of this.columns.visibleColumns) {\n            column.element?.classList.toggle(\n                'b-selected',\n                selectedCells?.filter(s => s.columnId === column.id).length === count\n            );\n        }\n    }\n\n    triggerSelectionChangeEvent(selectionChange) {\n        const rowMode = this.isRowSelectionMode;\n\n        this.trigger('selectionChange', {\n            mode       : rowMode ? 'row' : 'cell',\n            action     : selectionChange.action,\n            selected   : (rowMode ? selectionChange.selectedRecords : selectionChange.selectedCells) || [],\n            deselected : (rowMode ? selectionChange.deselectedRecords : selectionChange.deselectedCells) || [],\n            selection  : (rowMode ? this.selectedRecords : this.selectedCells) || []\n        });\n    }\n\n    //endregion\n\n    doDestroy() {\n        this.selectedRecordCollection?.destroy();\n        this._selectedCells.length = 0;\n        for (const detacher in this._selectionListenersDetachers) {\n            this._selectionListenersDetachers[detacher]();\n        }\n        super.doDestroy();\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n\n};\n","import Base from '../../../Core/Base.js';\nimport WidgetHelper from '../../../Core/helper/WidgetHelper.js';\n// TODO: prevent multiple rerenders\n\n/**\n * @module Grid/view/mixin/GridState\n */\nconst\n    suspendStoreEvents = subGrid => subGrid.columns.suspendEvents(),\n    resumeStoreEvents = subGrid => subGrid.columns.resumeEvents(),\n    fillSubGridColumns = subGrid => {\n        subGrid.columns.clearCaches();\n        subGrid.columns.fillFromMaster();\n    },\n    compareStateSortIndex = (a, b) => a.stateSortIndex - b.stateSortIndex;\n\n/**\n * Mixin for Grid that handles state. It serializes the following grid properties:\n *\n * * rowHeight\n * * selectedCell\n * * selectedRecords\n * * columns (order, widths, visibility)\n * * store (sorters, groupers, filters)\n * * scroll position\n *\n * See {@link Core.mixin.State} for more information on state.\n *\n * @demo Grid/state\n * @inlineexample Grid/view/mixin/GridState.js\n * @mixin\n */\nexport default Target => class GridState extends (Target || Base) {\n    static get $name() {\n        return 'GridState';\n    }\n\n    static get configurable() {\n        return {\n            statefulEvents : ['subGridCollapse', 'subGridExpand', 'horizontalScroll', 'stateChange']\n        };\n    }\n\n    /**\n     * Gets or sets grid's state. Check out {@link Grid.view.mixin.GridState} mixin for details.\n     * @member {Object} state\n     * @property {Object[]} state.columns\n     * @property {Number} state.rowHeight\n     * @property {Object} state.scroll\n     * @property {Number} state.scroll.scrollLeft\n     * @property {Number} state.scroll.scrollTop\n     * @property {Array} state.selectedRecords\n     * @property {String} state.style\n     * @property {String} state.selectedCell\n     * @property {Object} state.store\n     * @property {Object} state.store.sorters\n     * @property {Object} state.store.groupers\n     * @property {Object} state.store.filters\n     * @property {Object} state.subGrids\n     * @category State\n     */\n\n    updateStore(store, was) {\n        super.updateStore?.(store, was);\n\n        this.detachListeners('stateStoreListeners');\n\n        store?.ion({\n            name    : 'stateStoreListeners',\n            filter  : 'triggerUpdate',\n            group   : 'triggerUpdate',\n            sort    : 'triggerUpdate',\n            thisObj : this\n        });\n    }\n\n    updateColumns(columns, was) {\n        super.updateColumns?.(columns, was);\n\n        this.detachListeners('stateColumnListeners');\n\n        columns.ion({\n            name    : 'stateColumnListeners',\n            change  : 'triggerUpdate',\n            thisObj : this\n        });\n    }\n\n    updateRowManager(manager, was) {\n        super.updateRowManager?.(manager, was);\n\n        this.detachListeners('stateRowManagerListeners');\n\n        manager.ion({\n            name      : 'stateRowManagerListeners',\n            rowHeight : 'triggerUpdate',\n            thisObj   : this\n        });\n    }\n\n    triggerUpdate() {\n        this.trigger('stateChange');\n    }\n\n    finalizeInit() {\n        super.finalizeInit();\n\n        this.ion({\n            selectionChange : 'triggerUpdate',\n            thisObj         : this\n        });\n    }\n\n    /**\n     * Get grid's current state for serialization. State includes rowHeight, headerHeight, selectedCell,\n     * selectedRecordId, column states and store state etc.\n     * @returns {Object} State object to be serialized\n     * @private\n     */\n    getState() {\n        const\n            me    = this,\n            style = me.element.style.cssText,\n            state = {\n                rowHeight : me.rowHeight\n            };\n\n        if (style) {\n            state.style = style;\n        }\n\n        if (me.selectedCell) {\n            // TODO: Create wrapper class to avoid JSON.stringify recursion in state.selectedCell.\n            const { id, columnId } = me.selectedCell;\n            state.selectedCell = { id, columnId };\n        }\n\n        state.selectedRecords = me.selectedRecords.map(entry => entry.id);\n        state.columns = me.columns.allRecords.map(column => column.getState());\n        state.store = me.store.state;\n        state.scroll = me.storeScroll();\n\n        state.subGrids = {};\n\n        me.eachSubGrid(subGrid => {\n            const config = state.subGrids[subGrid.region] = state.subGrids[subGrid.region] || {};\n\n            if (subGrid.isPainted) {\n                if (subGrid.flex == null) {\n                    config.width = subGrid.width;\n                }\n            }\n            else {\n                if (subGrid.config.width != null) {\n                    config.width = subGrid.config.width;\n                }\n                else {\n                    config.flex = subGrid.config.flex;\n                }\n            }\n\n            config.collapsed = subGrid.collapsed ?? false;\n\n            // Part of a collapsed SubGrid's state is the state to restore to when expanding again.\n            if (config.collapsed) {\n                config._beforeCollapseState = subGrid._beforeCollapseState;\n            }\n        });\n\n        return state;\n    }\n\n    /**\n     * Apply previously stored state.\n     * @param {Object} state\n     * @private\n     */\n    applyState(state) {\n        const me = this;\n\n        // Applying state will call row renderer at least 7 times. Suspending refresh helps to save some time.\n        // Roughly on default testing grid apply state takes 26ms without suspend and 16ms with it.\n        me.suspendRefresh();\n\n        // Do this first since it might perform full rendering of contents, recreating filterbar header fields\n        if ('columns' in state) {\n            let columnsChanged = false,\n                needSort = false;\n\n            // We're going to renderContents anyway, so stop the ColumnStores from updating the UI\n            me.columns.suspendEvents();\n            me.eachSubGrid(suspendStoreEvents);\n\n            // each column triggers rerender at least once...\n            state.columns.forEach((columnState, index) => {\n                const column = me.columns.getById(columnState.id);\n\n                if (column) {\n                    const columnGeneration = column.generation;\n\n                    column.applyState(columnState);\n                    columnsChanged = columnsChanged || (column.generation !== columnGeneration);\n\n                    // In case a sort is needed, stamp in the ordinal position.\n                    column.stateSortIndex = index;\n\n                    // If we find one out of order, only then do we need to sort\n                    if (column.allIndex !== index) {\n                        needSort = columnsChanged = true;\n                    }\n                }\n            });\n\n            if (columnsChanged) {\n                me.eachSubGrid(fillSubGridColumns);\n            }\n            if (needSort) {\n                me.eachSubGrid(subGrid => {\n                    subGrid.columns.records.sort(compareStateSortIndex);\n                    subGrid.columns.allRecords.sort(compareStateSortIndex);\n                });\n                me.columns.sort({\n                    fn        : compareStateSortIndex,\n                    // always sort ascending\n                    ascending : true\n                });\n            }\n\n            // If we have been painted, and column restoration changed the column layout, refresh contents\n            if (me.isPainted && columnsChanged) {\n                me.renderContents();\n            }\n\n            // Allow ColumnStores to update the UI again\n            me.columns.resumeEvents();\n            me.eachSubGrid(resumeStoreEvents);\n        }\n\n        if ('subGrids' in state) {\n            me.eachSubGrid(subGrid => {\n                if (subGrid.region in state.subGrids) {\n                    const subGridState = state.subGrids[subGrid.region];\n\n                    if ('width' in subGridState) {\n                        subGrid.width = subGridState.width;\n                    }\n                    else if ('flex' in subGridState) {\n                        subGrid.flex = subGridState.flex;\n                    }\n\n                    if ('collapsed' in subGridState) {\n                        subGrid.collapsed = subGridState.collapsed;\n                        subGrid._beforeCollapseState = subGridState._beforeCollapseState;\n                    }\n                }\n\n                subGrid.clearWidthCache();\n            });\n        }\n\n        if ('rowHeight' in state) {\n            me.rowHeight = state.rowHeight;\n        }\n\n        if ('style' in state) {\n            me.style = state.style;\n        }\n\n        if ('selectedCell' in state) {\n            me.selectedCell = state.selectedCell;\n        }\n\n        if ('store' in state) {\n            me.store.state = state.store;\n        }\n\n        if ('selectedRecords' in state) {\n            me.selectedRecords = state.selectedRecords;\n        }\n\n        me.resumeRefresh(true);\n\n        // Update scroll state\n        me.eachSubGrid(s => s.refreshFakeScroll());\n\n        if ('scroll' in state) {\n            me.restoreScroll(state.scroll);\n\n            // We need to force resize handler on all observable elements, because vertical scroll triggered by the\n            // previous method will suspend the listener. So by the time ResizeObserver triggers mutation handler\n            // listener won't actually update widget size.\n            // Handler works here because we haven't _yet_ suspended it, it will happen one animation frame after\n            // scroll event is triggered\n            if (state.scroll.scrollTop) {\n                me.element.querySelectorAll('.b-resize-monitored').forEach(element => {\n                    const widget = WidgetHelper.fromElement(element);\n\n                    if (widget) {\n                        widget.onElementResize(element);\n                    }\n                });\n            }\n        }\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {\n    }\n};\n","/**\n * @module Grid/util/SubGridScroller\n */\n\nimport Scroller from '../../Core/helper/util/Scroller.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n\nconst\n    immediatePromise     = Promise.resolve(),\n    defaultScrollOptions = {\n        block : 'nearest'\n    };\n\n/**\n * A Scroller subclass which handles scrolling in a SubGrid. Needs special treatment since the SubGrid itself only\n * allows horizontal scrolling, while the vertical scrolling is done by an outer element containing all subgrids.\n *\n * @internal\n */\nexport default class SubGridScroller extends Scroller {\n    // SubGrids do not drive the scrollWidth of their partners (Header and Footer)\n    // SubGrids scrollWidth is propagated from the Header by SubGrid.refreshFakeScroll.\n    static get configurable() {\n        return {\n            propagate : false,\n            overflowX : 'hidden-scroll'\n        };\n    }\n\n    scrollIntoView(element, options = defaultScrollOptions) {\n        const me = this,\n            { xDelta, yDelta } = me.getDeltaTo(element, options),\n            result = (xDelta || yDelta) ? me.scrollBy(xDelta, yDelta, options) : immediatePromise;\n\n        if (options.highlight || options.focus) {\n            result.then(() => {\n                if (options.highlight) {\n                    if (element instanceof Rectangle) {\n                        element.translate(-xDelta, -yDelta).highlight();\n                    }\n                    else {\n                        DomHelper.highlight(element);\n                    }\n                }\n                options.focus && element.focus && element.focus();\n            });\n        }\n        return result;\n    }\n\n    scrollBy(xDelta, yDelta, options) {\n        const yPromise = yDelta && this.yScroller.scrollBy(0, yDelta, options),\n            xPromise = xDelta && super.scrollBy(xDelta, 0, options);\n\n        if (xPromise && xPromise.cancel && yPromise && yPromise.cancel) {\n            const cancelX = xPromise.cancel,\n                cancelY = yPromise.cancel;\n\n            // Set up cross canceling\n            xPromise.cancel = yPromise.cancel = () => {\n                cancelX();\n                cancelY();\n            };\n            return Promise.all([xPromise, yPromise]);\n        }\n\n        return xPromise || yPromise || immediatePromise;\n    }\n\n    scrollTo(toX, toY, options) {\n        const\n            yPromise = (toY != null) && this.yScroller.scrollTo(null, toY, options),\n            xPromise = (toX != null) && super.scrollTo(toX, null, options);\n\n        // Keep partners in sync immediately unless we are going to animate our position.\n        // There are potentially three: The header, the footer and the docked fake horizontal scroller.\n        // It will be more efficient and maintain correct state doing it now.\n        if (!(options && options.animate)) {\n            this.syncPartners();\n        }\n\n        if (xPromise && xPromise.cancel && yPromise && yPromise.cancel) {\n            const cancelX = xPromise.cancel,\n                cancelY = yPromise.cancel;\n\n            // Set up cross canceling\n            xPromise.cancel = yPromise.cancel = () => {\n                cancelX();\n                cancelY();\n            };\n            return Promise.all([xPromise, yPromise]);\n        }\n\n        return xPromise || yPromise || immediatePromise;\n    }\n\n    get viewport() {\n        const\n            elementBounds = Rectangle.from(this.element),\n            viewport      = elementBounds.intersect(Rectangle.from(this.yScroller.element));\n        // For 0 height subgrids, viewport will be `false` but we still expect a Rectangle to be returned\n        return viewport || new Rectangle(elementBounds.x, elementBounds.y, elementBounds.width, 0);\n    }\n\n    set y(y) {\n        if (this.yScroller) {\n            this.yScroller.y = y;\n        }\n    }\n\n    get y() {\n        return this.yScroller ? this.yScroller.y : 0;\n    }\n\n    get maxY() {\n        return this.yScroller ? this.yScroller.maxY : 0;\n    }\n\n    get scrollHeight() {\n        return this.yScroller ? this.yScroller.scrollHeight : 0;\n    }\n\n    get clientHeight() {\n        return this.yScroller ? this.yScroller.clientHeight : 0;\n    }\n}\n","import BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport Column from '../column/Column.js';\nimport SubGridScroller from '../util/SubGridScroller.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Scroller from '../../Core/helper/util/Scroller.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\n\n/**\n * @module Grid/view/SubGrid\n */\nconst sumWidths = (t, e) => t + e.getBoundingClientRect().width;\n\n/**\n * A SubGrid is a part of the grid (it has at least one and normally no more than two, called locked and normal). It\n * has its own header, which holds the columns to display rows for in the SubGrid. SubGrids are created by Grid, you\n * should not need to create instances directly.\n *\n * If not configured with a width or flex, the SubGrid will be sized to fit its columns. In this case, if all columns\n * have a fixed width (not using flex) then toggling columns will also affect the width of the SubGrid.\n *\n * @extends Core/widget/Widget\n */\nexport default class SubGrid extends Widget {\n    //region Config\n\n    static get $name() {\n        return 'SubGrid';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'subgrid';\n    }\n\n    /**\n     * Region (name) for this SubGrid\n     * @config {String} region\n     */\n\n    /**\n     * Column store, a store containing the columns for this SubGrid\n     * @config {Grid.data.ColumnStore} columns\n     */\n\n    static get defaultConfig() {\n        return {\n            insertRowsBefore : null,\n            appendTo         : null,\n            monitorResize    : true,\n            headerClass      : null,\n            footerClass      : null,\n\n            /**\n             * The subgrid \"weight\" determines its position among its SubGrid siblings.\n             * Higher weights go further right.\n             * @config {Number}\n             * @category Layout\n             */\n            weight : null,\n\n            /**\n             * Set `true` to start subgrid collapsed. To operate collapsed state on subgrid use\n             * {@link #function-collapse}/{@link #function-expand} methods.\n             * @config {Boolean}\n             * @default false\n             */\n            collapsed : null,\n\n            scrollable : {\n                // Each SubGrid only handles scrolling in the X axis.\n                // The owning Grid handles the Y axis.\n                overflowX : 'hidden-scroll'\n            },\n\n            scrollerClass : SubGridScroller,\n\n            // Will be set to true by GridSubGrids if it calculates the subgrids width based on its columns.\n            // Used to determine if hiding a column should affect subgrids width\n            hasCalculatedWidth : null,\n\n            /**\n             * Set `true` to disable moving columns into or out of this SubGrid.\n             * @config {Boolean}\n             * @default false\n             * @private\n             */\n            sealedColumns : null\n        };\n    }\n\n    static get configurable() {\n        return {\n            element                : true,\n            header                 : {},\n            footer                 : {},\n            virtualScrollerElement : true,\n            splitterElement        : true,\n            headerSplitter         : true,\n            scrollerSplitter       : true,\n            footerSplitter         : true,\n\n            /**\n             * Set to `false` to prevent this subgrid being resized with the {@link Grid.feature.RegionResize} feature\n             * @config {Boolean}\n             * @default true\n             */\n            resizable : null,\n\n            role : 'presentation'\n        };\n    }\n\n    static delayable = {\n        hideOverlayScroller : 1000\n    }\n\n    //endregion\n\n    //region Init\n\n    /**\n     * SubGrid constructor\n     * @param config\n     * @private\n     */\n    construct(config) {\n        const me = this;\n\n        super.construct(config);\n\n        this.rowManager.ion({ addRows : 'onAddRow', thisObj : this });\n\n        if (BrowserHelper.isFirefox) {\n            const\n                { element }      = me,\n                verticalScroller = me.grid.scrollable;\n\n            // Firefox cannot scroll vertically smoothly when using touch pad. Even a microscopic horizontal touch will\n            // abort the vertical scrolling. To counter this we ignore pointer events on the subgrid element temporarily\n            // until scroll stops. No test coverage.\n            // https://github.com/bryntum/support/issues/3000\n            let lastScrollTop = 0;\n            element.addEventListener('wheel', ({ ctrlKey, deltaY, deltaX }) => {\n                const isVerticalScroll = Math.abs(deltaY) > Math.abs(deltaX);\n\n                // Ignore wheel event with Control key pressed - it doesn't scroll, it either zooms scheduler or zooms\n                // the page.\n                if (!ctrlKey && isVerticalScroll && !me.scrollEndDetacher && verticalScroller.y !== lastScrollTop) {\n                    element.style.pointerEvents = 'none';\n                    lastScrollTop               = verticalScroller.y;\n\n                    me.scrollEndDetacher = verticalScroller.ion({\n                        scrollEnd : async() => {\n                            lastScrollTop               = verticalScroller.y;\n                            element.style.pointerEvents = '';\n\n                            me.scrollEndDetacher = null;\n                        },\n                        once : true\n                    });\n                }\n            });\n        }\n    }\n\n    doDestroy() {\n        const me = this;\n\n        me.header.destroy();\n        me.footer.destroy();\n        me.fakeScroller?.destroy();\n\n        me.virtualScrollerElement.remove();\n        me.splitterElements.forEach(element => element.remove());\n\n        super.doDestroy();\n    }\n\n    get barConfig() {\n        const\n            me              = this,\n            { width, flex } = me.element.style,\n            config          = {\n                subGrid  : me,\n                parent   : me,  // Contained widgets need to know their parents\n                maxWidth : me.maxWidth || undefined,\n                minWidth : me.minWidth || undefined\n            };\n\n        // If we have been configured with sizing, construct the Bar in sync.\n        if (flex) {\n            config.flex = flex;\n        }\n        else if (width) {\n            config.width = width;\n        }\n\n        return config;\n    }\n\n    changeHeader(header) {\n        return new this.headerClass(ObjectHelper.assign({\n            id : this.id + '-header'\n        }, this.barConfig, header));\n    }\n\n    changeFooter(footer) {\n        return new this.footerClass(ObjectHelper.assign({\n            id : this.id + '-footer'\n        }, this.barConfig, footer));\n    }\n\n    //endregion\n\n    //region Splitters\n\n    get splitterElements() {\n        return [this.splitterElement, this.headerSplitter, this.scrollerSplitter, this.footerSplitter];\n    }\n\n    /**\n     * Toggle (add/remove) class for splitters\n     * @param {String} cls class name\n     * @param {Boolean} [add] actions. Set to `true` to add class, `false` to remove\n     * @private\n     */\n    toggleSplitterCls(cls, add = true) {\n        this.splitterElements.forEach(el => el?.classList[add ? 'add' : 'remove'](cls));\n    }\n\n    hideSplitter() {\n        this.splitterElements.forEach(el => el.classList.add('b-hide-display'));\n        this.$showingSplitter = false;\n    }\n\n    showSplitter() {\n        this.splitterElements.forEach(el => el.classList.remove('b-hide-display'));\n        this.$showingSplitter = true;\n    }\n\n    //endregion\n\n    //region Template\n\n    changeElement(element, was) {\n        const { region } = this;\n\n        return super.changeElement({\n            'aria-label' : region,\n            className    : {\n                'b-grid-subgrid'             : 1,\n                [`b-grid-subgrid-${region}`] : region,\n                'b-grid-subgrid-collapsed'   : this.collapsed\n            },\n            dataset : {\n                region\n            }\n        }, was);\n    }\n\n    get rowElementConfig() {\n        const { grid } = this;\n\n        return {\n            role      : 'row',\n            className : grid.rowCls,\n            children  : this.columns.visibleColumns.map((column, columnIndex) => ({\n                role            : 'gridcell',\n                'aria-colindex' : columnIndex + 1,\n                tabIndex        : grid.cellTabIndex,\n                className       : 'b-grid-cell',\n                dataset         : {\n                    column   : column.field || '',\n                    columnId : column.id\n                }\n            }))\n        };\n    }\n\n    // Added to DOM in Grid `get bodyConfig`\n    changeVirtualScrollerElement() {\n        const references = DomHelper.createElement({\n            role      : 'presentation',\n            reference : 'virtualScrollerElement',\n            className : 'b-virtual-scroller',\n            tabIndex  : -1,\n            dataset   : {\n                region : this.region\n            },\n            children : [\n                {\n                    reference : 'virtualScrollerWidth',\n                    className : 'b-virtual-width'\n                }\n            ]\n        });\n\n        this.virtualScrollerWidth = references.virtualScrollerWidth;\n\n        return references.virtualScrollerElement;\n    }\n\n    changeSplitterElement() {\n        const references = DomHelper.createElement({\n            reference : 'splitterElement',\n            className : {\n                'b-grid-splitter'           : 1,\n                'b-grid-splitter-collapsed' : this.collapsed,\n                'b-hide-display'            : 1 // GridSubGrids determines visibility\n            },\n            dataset : {\n                region : this.region\n            },\n            children : [\n                BrowserHelper.isTouchDevice ? { className : 'b-splitter-touch-area' } : null,\n                {\n                    className : 'b-grid-splitter-inner b-grid-splitter-main',\n                    children  : [\n                        {\n                            className : 'b-grid-splitter-buttons',\n                            reference : 'splitterButtons',\n                            children  : [\n                                {\n                                    className : 'b-grid-splitter-button-collapse',\n                                    children  : [\n                                        BrowserHelper.isTouchDevice ? { className : 'b-splitter-button-touch-area' } : null,\n                                        {\n                                            tag       : 'svg',\n                                            ns        : 'http://www.w3.org/2000/svg',\n                                            version   : '1.1',\n                                            className : 'b-grid-splitter-button-icon b-gridregion-collapse-arrow',\n                                            viewBox   : '0 0 256 512',\n                                            children  : [\n                                                {\n                                                    tag : 'path',\n                                                    d   : 'M192 448c-8.188 0-16.38-3.125-22.62-9.375l-160-160c-12.5-1' +\n                                                        '2.5-12.5-32.75 0-45.25l160-160c12.5-12.5 32.75-12.5 45.25 0s' +\n                                                        '12.5 32.75 0 45.25L77.25 256l137.4 137.4c12.5 12.5 12.5 32.7' +\n                                                        '5 0 45.25C208.4 444.9 200.2 448 192 448z'\n                                                }\n                                            ]\n                                        }\n                                    ]\n                                },\n                                {\n                                    className : 'b-grid-splitter-button-expand',\n                                    children  : [\n                                        BrowserHelper.isTouchDevice ? { className : 'b-splitter-button-touch-area' } : null,\n                                        {\n                                            tag       : 'svg',\n                                            ns        : 'http://www.w3.org/2000/svg',\n                                            version   : '1.1',\n                                            className : 'b-grid-splitter-button-icon b-gridregion-expand-arrow',\n                                            viewBox   : '0 0 256 512',\n                                            children  : [\n                                                {\n                                                    tag : 'path',\n                                                    d   : 'M64 448c-8.188 0-16.38-3.125-22.62-9.375c-12.5-12.5-12.5-3' +\n                                                        '2.75 0-45.25L178.8 256L41.38 118.6c-12.5-12.5-12.5-32.75 0-4' +\n                                                        '5.25s32.75-12.5 45.25 0l160 160c12.5 12.5 12.5 32.75 0 45.25' +\n                                                        'l-160 160C80.38 444.9 72.19 448 64 448z'\n                                                }\n                                            ]\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        });\n\n        this.splitterButtons = references.splitterButtons;\n\n        return references.splitterElement;\n    }\n\n    get splitterConfig() {\n        return {\n            className : this.splitterElement.className.trim(),\n            children  : [\n                BrowserHelper.isTouchDevice ? { className : 'b-splitter-touch-area' } : null,\n                {\n                    className : 'b-grid-splitter-inner'\n                }\n            ],\n            dataset : {\n                region : this.region\n            }\n        };\n    }\n\n    changeHeaderSplitter() {\n        return DomHelper.createElement(this.splitterConfig);\n    }\n\n    changeScrollerSplitter() {\n        return DomHelper.createElement(this.splitterConfig);\n    }\n\n    changeFooterSplitter() {\n        return DomHelper.createElement(this.splitterConfig);\n    }\n\n    //endregion\n\n    //region Render\n\n    render(...args) {\n        const me = this;\n\n        super.render(...args);\n\n        // Unit tests create naked SubGrids so we have to do this.\n        if (me.grid) {\n            me.updateHasFlex();\n\n            me.element.parentNode.insertBefore(me.splitterElement, me.element.nextElementSibling);\n\n            // Cant use \"global\" listener with delegate for mouseenter, since mouseenter only fires on target\n            me.splitterElements.forEach(element =>\n                EventHelper.on({\n                    element,\n                    mouseenter : 'onSplitterMouseEnter',\n                    mouseleave : 'onSplitterMouseLeave',\n                    thisObj    : me\n                })\n            );\n\n            me._collapsed && me.collapse();\n        }\n    }\n\n    refreshHeader() {\n        this.header.refreshContent();\n    }\n\n    refreshFooter() {\n        this.footer?.refreshContent();\n    }\n\n    // Override to iterate header and footer.\n    eachWidget(fn, deep = true) {\n        const\n            me      = this,\n            widgets = [me.header, me.footer];\n\n        for (let i = 0; i < widgets.length; i++) {\n            const widget = widgets[i];\n\n            if (fn(widget) === false) {\n                return;\n            }\n\n            if (deep && widget.eachWidget) {\n                widget.eachWidget(fn, deep);\n            }\n        }\n    }\n\n    //endregion\n\n    //region Size & resize\n\n    /**\n     * Sets cell widths. Cannot be done in template because of CSP\n     * @private\n     */\n    fixCellWidths(rowElement) {\n        const { visibleColumns } = this.columns;\n\n        // fix cell widths, no longer allowed in template because of CSP\n        let cell = rowElement.firstElementChild,\n            i    = 0;\n\n        while (cell) {\n            const\n                column      = visibleColumns[i],\n                { element } = column;\n\n            if (column.minWidth) {\n                cell.style.minWidth = DomHelper.setLength(column.minWidth);\n            }\n            if (column.maxWidth) {\n                cell.style.maxWidth = DomHelper.setLength(column.maxWidth);\n            }\n\n            // either flex or width, flex has precedence\n            if (column.flex) {\n                // Nested flex - we have to match the column's header width because it's flexing\n                // a different available space - the space in its owning column header.\n                if (column.childLevel && element) {\n                    cell.style.flex = `0 0 ${element.getBoundingClientRect().width}px`;\n                    cell.style.width = '';\n                }\n                else {\n                    cell.style.flex = column.flex;\n                    cell.style.width = '';\n                }\n            }\n            else if (column.width) {\n                // https://app.assembla.com/spaces/bryntum/tickets/8041\n                // Although header and footer elements must be sized using flex-basis to avoid the busting out problem,\n                // grid cells MUST be sized using width since rows are absolutely positioned and will not cause the\n                // busting out problem, and rows will not stretch to shrinkwrap the cells unless they are widthed with\n                // width.\n                cell.style.width = DomHelper.setLength(column.width);\n            }\n            else {\n                cell.style.flex = cell.style.width = cell.style.minWidth = '';\n            }\n\n            cell = cell.nextElementSibling;\n            i++;\n        }\n    }\n\n    get totalFixedWidth() {\n        return this.columns.totalFixedWidth;\n    }\n\n    /**\n     * Sets header width and scroller width (if needed, depending on if using flex). Might also change the subgrids\n     * width, if it uses a width calculated from its columns.\n     * @private\n     */\n    fixWidths() {\n        const\n            me = this,\n            {\n                element,\n                header,\n                footer\n            }  = me;\n\n        if (!me.collapsed) {\n            if (me.flex) {\n                header.flex = me.flex;\n                if (footer) {\n                    footer.flex = me.flex;\n                }\n                element.style.flex = me.flex;\n            }\n            else {\n                // If width is calculated and no column is using flex, check if total width is less than width. If so,\n                // recalculate width and bail out of further processing (since setting width will trigger again)\n                if (\n                    me.hasCalculatedWidth &&\n                    !me.columns.some(col => !col.hidden && col.flex) &&\n                    me.totalFixedWidth !== me.width\n                ) {\n                    me.width = me.totalFixedWidth;\n                    // Setting width above clears the hasCalculatedWidth flag, but we want to keep it set to react\n                    // correctly next time\n                    me.hasCalculatedWidth = true;\n                    return;\n                }\n\n                let totalWidth = me.width;\n\n                // Calculate width from our total column width if we are supposed to have a calculated width\n                if (!totalWidth && me.hasCalculatedWidth) {\n                    totalWidth = 0;\n\n                    // summarize column widths, needed as container width when not using flex widths.\n                    for (const col of me.columns) {\n                        if (!col.flex && !col.hidden) totalWidth += col.width;\n                    }\n                }\n\n                // rows are absolutely positioned, meaning that their width won't affect container width\n                // hence we must set it, if not using flex\n                element.style.width = `${totalWidth}px`;\n\n                header.width = totalWidth;\n                if (footer) {\n                    footer.width = totalWidth;\n                }\n            }\n\n            me.syncScrollingPartners(false);\n        }\n    }\n\n    // Safari does not shrink cells the same way as chrome & ff does without having a width set on the row\n    fixRowWidthsInSafariEdge() {\n        if (BrowserHelper.isSafari) {\n            const\n                me                 = this,\n                { region, header } = me,\n                minWidth           = header.calculateMinWidthForSafari();\n\n            // fix row widths for safari, it does not size flex cells correctly at small widths otherwise.\n            // there should be a css solution, but I have failed to find it\n            me.rowManager.forEach(row => {\n                // This function runs on resize and rendering a SubGrid triggers a resize. When adding a new SubGrid\n                // on the fly elements wont exists for it yet, so ignore...\n                const element = row.getElement(region);\n                // it is worth noting that setting a width does not prevent the row from growing beyond that with\n                // when making view wider, it is used in flex calculation more like a min-width\n                if (element) {\n                    element.style.width = `${minWidth}px`;\n                }\n            });\n\n            header.headersElement.style.width = `${minWidth}px`;\n        }\n    }\n\n    /**\n     * Get/set SubGrid width, which also sets header and footer width (if available).\n     * @property {Number}\n     */\n    set width(width) {\n        const me = this;\n\n        // Width explicitly set, remember that\n        me.hasCalculatedWidth = false;\n\n        super.width = width;\n\n        me.header.width = width;\n        me.footer.width = width;\n\n        // When we're live, we can't wait until the  throttled resize occurs - it looks bad.\n        if (me.isPainted) {\n            me.onElementResize();\n        }\n    }\n\n    get width() {\n        return super.width;\n    }\n\n    /**\n     * Get/set SubGrid flex, which also sets header and footer flex (if available).\n     * @property {Number|String}\n     */\n    set flex(flex) {\n        const me = this;\n\n        // Width explicitly set, remember that\n        me.hasCalculatedWidth = false;\n\n        me.header.flex = flex;\n        me.footer.flex = flex;\n\n        super.flex = flex;\n\n        // When we're live, we can't wait until the  throttled resize occurs - it looks bad.\n        if (me.isPainted) {\n            me.onElementResize();\n        }\n    }\n\n    get flex() {\n        return super.flex;\n    }\n\n    /**\n     * Called when grid changes size. SubGrid determines if it has changed size and triggers scroll (for virtual\n     * rendering in cells to work when resizing etc.)\n     * @private\n     */\n    onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {\n        const\n            me       = this,\n            { grid } = me;\n\n        // Widget caches dimensions\n        super.onInternalResize(...arguments);\n\n        // Unit tests create naked SubGrids so we have to do this.\n        if (grid?.isPainted) {\n            me.syncSplitterButtonPosition();\n\n            if (newWidth !== oldWidth) {\n                // trigger scroll, in case anything is done on scroll it needs to be done now also\n                grid.trigger('horizontalScroll', {\n                    grid,\n                    subGrid    : me,\n                    scrollLeft : me.scrollable.element.scrollLeft,\n                    scrollX    : me.scrollable.x\n                });\n\n                // Update virtual scrollers, if they are ready\n                me.fakeScroller && me.refreshFakeScroll();\n\n                // Columns which are flexed, but as part of a grouped column cannot just have their flex\n                // value reflected in the flex value of its cells. They are flexing a different available space.\n                // These have to be set to the exact width and kept synced.\n                grid.syncFlexedSubCols();\n\n                me.fixRowWidthsInSafariEdge();\n            }\n\n            if (newHeight !== oldHeight) {\n                // Call this to update cached _bodyHeight\n                grid.onHeightChange();\n            }\n\n            me.trigger('afterInternalResize', me);\n        }\n    }\n\n    /**\n     * Keeps the parallel splitters in the header, footer and fake scroller synced in terms\n     * of being collapsed or not.\n     * @private\n     */\n    syncParallelSplitters(collapsed) {\n        const\n            me       = this,\n            { grid } = me;\n\n        if (me.splitterElement && me.$showingSplitter) {\n            me.toggleSplitterCls('b-grid-splitter-collapsed', collapsed);\n        }\n        else {\n            // If we're the last, we don't own a splitter, we use the previous region's splitter\n            const prevGrid = grid.getSubGrid(grid.getPreviousRegion(me.region));\n\n            // If there's a splitter before us, sync it with our state.\n            if (prevGrid && prevGrid.splitterElement) {\n                prevGrid.syncParallelSplitters(collapsed);\n            }\n        }\n    }\n\n    onSplitterMouseEnter() {\n        const\n            me              = this,\n            { nextSibling } = me;\n\n        // No hover effect when collapsed\n        if (!me.collapsed && (!nextSibling || !nextSibling.collapsed)) {\n            me.toggleSplitterCls('b-hover');\n        }\n\n        me.startSplitterButtonSyncing();\n    }\n\n    onSplitterMouseLeave() {\n        const\n            me              = this,\n            { nextSibling } = me;\n\n        me.toggleSplitterCls('b-hover', false);\n        if (!me.collapsed && (!nextSibling || !nextSibling.collapsed)) {\n            me.stopSplitterButtonSyncing();\n        }\n    }\n\n    startSplitterButtonSyncing() {\n        const me = this;\n\n        if (me.splitterElement) {\n            me.syncSplitterButtonPosition();\n            if (!me.splitterSyncScrollListener) {\n                me.splitterSyncScrollListener = me.grid.scrollable.ion({\n                    scroll  : 'syncSplitterButtonPosition',\n                    thisObj : me\n                });\n            }\n        }\n    }\n\n    stopSplitterButtonSyncing() {\n        if (this.splitterSyncScrollListener) {\n            this.splitterSyncScrollListener();\n            this.splitterSyncScrollListener = null;\n        }\n    }\n\n    syncSplitterButtonPosition() {\n        const { grid } = this;\n\n        this.splitterButtons.style.top = `${grid.scrollable.y + ((grid.bodyHeight - (this.headerSplitter ? grid.headerHeight : 0)) / 2)}px`;\n    }\n\n    /**\n     * Get the \"viewport\" for the SubGrid as a Rectangle\n     * @property {Core.helper.util.Rectangle}\n     * @readonly\n     */\n    get viewRectangle() {\n        const { scrollable } = this;\n\n        return new Rectangle(scrollable.x, scrollable.y, this.width || 0, this.rowManager.viewHeight);\n    }\n\n    /**\n     * Called when updating column widths to apply 'b-has-flex' which is used when fillLastColumn is configured.\n     * @internal\n     */\n    updateHasFlex() {\n        this.scrollable.element.classList.toggle('b-has-flex', this.columns.hasFlex);\n    }\n\n    updateResizable(resizable) {\n        this.splitterElements.forEach(splitter => DomHelper.toggleClasses(splitter, ['b-disabled'], !resizable));\n    }\n\n    /**\n     * Resize all columns in the SubGrid to fit their width, according to their configured\n     * {@link Grid.column.Column#config-fitMode}\n     */\n    resizeColumnsToFitContent() {\n        this.grid.beginGridMeasuring();\n\n        this.columns.visibleColumns.forEach(column => {\n            column.resizeToFitContent(null, null, true);\n        });\n\n        this.grid.endGridMeasuring();\n    }\n\n    //endregion\n\n    //region Scroll\n\n    get overflowingHorizontally() {\n        // We are not overflowing if collapsed\n        return !this.collapsed && this.scrollable.hasOverflow('x');\n    }\n\n    get overflowingVertically() {\n        // SubGrids never overflow vertically. They are full calculated content height.\n        // The owning Grid scrolls all SubGrids vertically in its own overflowElement.\n        return false;\n    }\n\n    /**\n     * Fixes widths of fake scrollers\n     * @private\n     */\n    refreshFakeScroll() {\n        const\n            me = this,\n            {\n                element,\n                virtualScrollerElement,\n                virtualScrollerWidth,\n                header,\n                footer,\n                scrollable\n            }  = me,\n            // Cannot use scrollWidth because its an integer and we need exact content size\n            totalFixedWidth = [...header.contentElement.children].reduce(sumWidths, 0);\n\n        // Use a fixed scroll width so that when grid is empty (e.g after filtering with no matches),\n        // it is able to it maintain its scroll-x position and magic mouse swiping\n        // in the grid area will produce horizontal scrolling.\n        // https://github.com/bryntum/support/issues/3247\n        scrollable.scrollWidth = totalFixedWidth;\n\n        // Scroller lays out in the same way as subgrid.\n        // If we are flexed, the scroller is flexed etc.\n        virtualScrollerElement.style.width = element.style.width;\n        virtualScrollerElement.style.flex = element.style.flex;\n        virtualScrollerElement.style.minWidth = element.style.minWidth;\n        virtualScrollerElement.style.maxWidth = element.style.maxWidth;\n        header.scrollable.syncOverflowState();\n        footer.scrollable.syncOverflowState();\n\n        if (!me.collapsed) {\n            if (me.overflowingHorizontally) {\n                virtualScrollerWidth.style.width = `${scrollable.scrollWidth || 0}px`;\n                // If *any* SubGrids have horizontal overflow, the main grid\n                // has to show its virtual horizontal scrollbar.\n                me.grid.virtualScrollers.classList.remove('b-hide-display');\n            }\n            else {\n                virtualScrollerWidth.style.width = 0;\n            }\n        }\n    }\n\n    /**\n     * Init scroll syncing for header and footer (if available).\n     * @private\n     */\n    initScroll() {\n        const\n            me = this,\n            {\n                scrollable,\n                virtualScrollerElement\n            }  = me;\n\n        me.syncPartnersOnFrame = me.createOnFrame(me.syncScrollingPartners);\n\n        if (BrowserHelper.isFirefox) {\n            scrollable.element.addEventListener('wheel', event => {\n                if (event.deltaX) {\n                    scrollable.x += event.deltaX;\n                    event.preventDefault();\n                }\n            });\n        }\n\n        scrollable.yScroller = me.grid.scrollable;\n\n        // Add our Scroller to the controlling GridScroller\n        scrollable.yScroller.addScroller(scrollable);\n\n        // Create a Scroller for the fake horizontal scrollbar so that it can partner\n        me.fakeScroller = new Scroller({\n            element   : virtualScrollerElement,\n            overflowX : true,\n            widget    : me // To avoid more expensive style lookup for RTL\n        });\n\n        // Sync scrolling partners (header, footer) when our xScroller reports a scroll.\n        // Also fires horizontalscroll\n        scrollable.ion({\n            scroll    : 'onSubGridScroll',\n            scrollend : 'onSubGridScrollEnd',\n            thisObj   : me\n        });\n\n        scrollable.addPartner(me.fakeScroller, 'x');\n        scrollable.addPartner(me.header.scrollable, 'x');\n        scrollable.addPartner(me.footer.scrollable, 'x');\n\n        // Update virtual scrollers (previously updated too early from onInternalResize)\n        me.refreshFakeScroll();\n    }\n\n    onSubGridScrollEnd() {\n        const me = this;\n\n        // If we do not have the direct update flag set which would ensure a sync in each scroll event\n        // then ensure syncing happens on scroll end. This is for animated scrolls where the scroll\n        // impulses come through animation frames.\n        if (!me.forceScrollUpdate) {\n            me.syncScrollingPartners();\n        }\n        me.scrolling = false;\n\n        if (!DomHelper.scrollBarWidth) {\n            me.grid.virtualScrollers.classList.remove('b-scrolling');\n            // Remove interactivity a while after scrolling ended\n            me.hideOverlayScroller();\n        }\n    }\n\n    onSubGridScroll() {\n        // Force direct update, without waiting for next animation frame\n        // TODO: Only used in Scheduler, could perhaps live in Scheduler specific SubGrid in the future\n        if (this.forceScrollUpdate) {\n            this.syncScrollingPartners();\n            this.forceScrollUpdate = false;\n        }\n        else {\n            this.syncPartnersOnFrame();\n        }\n    }\n\n    showOverlayScroller() {\n        this.hideOverlayScroller.cancel();\n\n        this.virtualScrollerElement.classList.add('b-show-virtual-scroller');\n    }\n\n    // Buffered 1500ms, hides virtual scrollers after scrolling has ended\n    hideOverlayScroller() {\n        this.virtualScrollerElement.classList.remove('b-show-virtual-scroller');\n    }\n\n    set scrolling(scrolling) {\n        this._scrolling = scrolling;\n    }\n\n    get scrolling() {\n        return this._scrolling;\n    }\n\n    /**\n     * This syncs the horizontal scroll position of the header and the footer with\n     * the horizontal scroll position of the grid. Usually, this will be called automatically\n     * when the grid scrolls. In some cases, such as a refresh caused by column changes\n     * it will need to be called from elsewhere.\n     * @internal\n     */\n    syncScrollingPartners(addCls = true) {\n        const\n            subGrid  = this,\n            { grid } = subGrid;\n\n        if (!subGrid.scrolling && addCls) {\n            subGrid.scrolling = true;\n            // Allow interacting with overlaid scrollbar after scrolling starts\n            if (!DomHelper.scrollBarWidth) {\n                // Cls indicating that we are actively scrolling\n                grid.virtualScrollers.classList.add('b-scrolling');\n                // Cls sticking around longer to keep overlay scrollbar visible longer, allowing users to more easily\n                // grab it to drag more\n                subGrid.showOverlayScroller();\n            }\n        }\n\n        grid.trigger('horizontalScroll', {\n            subGrid,\n            grid,\n            scrollLeft : subGrid.scrollable.element.scrollLeft,\n            scrollX    : subGrid.scrollable.x\n        });\n    }\n\n    /**\n     * Scrolls a column into view (if it is not already). Called by Grid#scrollColumnIntoView, use it instead to not\n     * have to care about which SubGrid contains a column.\n     * @param {Grid.column.Column|String|Number} column Column name (data) or column index or actual column object.\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} If the column exists, a promise which is resolved when the column header element has been\n     * scrolled into view.\n     */\n    scrollColumnIntoView(column, options) {\n        const\n            { columns, header } = this,\n            scroller            = header.scrollable;\n\n        // Allow column,column id,or column index to be passed\n        column = (column instanceof Column) ? column : columns.get(column) || columns.getById(column) || columns.getAt(column);\n\n        if (column) {\n            // Get the current column header element.\n            const columnHeaderElement = header.getHeader(column.id);\n\n            if (columnHeaderElement) {\n                return scroller.scrollIntoView(Rectangle.from(columnHeaderElement, null, true), options);\n            }\n        }\n    }\n\n    //endregion\n\n    //region Rows\n\n    /**\n     * Creates elements for the new rows when RowManager has determined that more rows are needed\n     * @private\n     */\n    onAddRow({ rows, isExport }) {\n        const\n            me             = this,\n            config         = me.rowElementConfig,\n            frag           = document.createDocumentFragment();\n\n        rows.forEach(row => {\n            const rowElement = DomHelper.createElement(config);\n\n            frag.appendChild(rowElement);\n            row.addElement(me.region, rowElement);\n\n            // TODO: Stamp the correct width into the cells on creation\n            me.fixCellWidths(rowElement);\n        });\n\n        // Do not insert elements to DOM if we're exporting them\n        if (!isExport) {\n            me.fixRowWidthsInSafariEdge();\n\n            // Put the row elements into the SubGrid en masse.\n            // If 2nd param is null, insertBefore appends.\n            me.element.insertBefore(frag, me.insertRowsBefore);\n        }\n    }\n\n    /**\n     * Get all row elements for this SubGrid.\n     * @property {HTMLElement[]}\n     * @readonly\n     */\n    get rowElements() {\n        return this.fromCache('.b-grid-row', true);\n    }\n\n    /**\n     * Removes all row elements from the subgrids body and empties cache\n     * @private\n     */\n    clearRows() {\n        this.emptyCache();\n\n        const\n            all   = this.element.querySelectorAll('.b-grid-row'),\n            range = document.createRange();\n\n        if (all.length) {\n            range.setStartBefore(all[0]);\n            range.setEndAfter(all[all.length - 1]);\n            range.deleteContents();\n        }\n    }\n\n    // only called when RowManager.rowScrollMode = 'dom', which is not intended to be used\n    addNewRowElement() {\n        const rowElement = DomHelper.append(this.element, this.rowElementConfig);\n\n        this.fixCellWidths(rowElement);\n\n        return rowElement;\n    }\n\n    get store() {\n        return this.grid.store;\n    }\n\n    get rowManager() {\n        return this.grid?.rowManager;\n    }\n\n    //endregion\n\n    // region Expand/collapse\n\n    // All usages are commented, uncomment when this is resolved: https://app.assembla.com/spaces/bryntum/tickets/5472\n    toggleTransitionClasses(doRemove = false) {\n        const\n            me         = this,\n            grid       = me.grid,\n            nextRegion = grid.getSubGrid(grid.getNextRegion(me.region)),\n            splitter   = grid.resolveSplitter(nextRegion);\n\n        nextRegion.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');\n        nextRegion.header.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');\n\n        me.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');\n        me.header.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');\n\n        splitter.classList[doRemove ? 'remove' : 'add']('b-grid-splitter-animate');\n    }\n\n    /**\n     * Get/set collapsed state\n     * @property {Boolean}\n     */\n    get collapsed() {\n        return this._collapsed;\n    }\n\n    set collapsed(collapsed) {\n        if (this.isConfiguring) {\n            this._collapsed = collapsed;\n        }\n        else {\n            if (collapsed) {\n                this.collapse();\n            }\n            else {\n                this.expand();\n            }\n        }\n    }\n\n    /**\n     * Collapses subgrid. If collapsing subgrid is the only one expanded, next subgrid to the right (or previous) will\n     * be expanded.\n     *\n     * @example\n     * let locked = grid.getSubGrid('locked');\n     * locked.collapse().then(() => {\n     *     console.log(locked.collapsed); // Logs 'True'\n     * });\n     *\n     * let normal = grid.getSubGrid('normal');\n     * normal.collapse().then(() => {\n     *     console.log(locked.collapsed); // Logs 'False'\n     *     console.log(normal.collapsed); // Logs 'True'\n     * });\n     *\n     * @returns {Promise} A Promise which resolves when this SubGrid is fully collapsed.\n     */\n    async collapse() {\n        const\n            me                       = this,\n            { grid, element }        = me,\n            nextRegion               = grid.getSubGrid(grid.getNextRegion(me.region)),\n            splitterOwner            = me.splitterElement ? me : me.previousSibling;\n        let { _beforeCollapseState } = me,\n            // Count all expanded regions. Grid must always have at least one expanded region\n            expandedRegions          = 0;\n\n        if (grid.rendered && me._collapsed === true) {\n            return;\n        }\n\n        grid.eachSubGrid(subGrid => {\n            subGrid !== me && !subGrid._collapsed && ++expandedRegions;\n        });\n\n        // Current region is the only one expanded, expand next region\n        if (expandedRegions === 0) {\n            // expandPromise = nextRegion.expand();\n            await nextRegion.expand();\n        }\n\n        return new Promise((resolve) => {\n            if (!_beforeCollapseState) {\n                _beforeCollapseState = me._beforeCollapseState = {};\n\n                let widthChanged = false;\n\n                // If current width is zero, the resize event will not be fired. In such case we want to trigger callback immediately\n                if (me.width) {\n                    widthChanged = true;\n\n                    // Toggle transition classes here, we will actually change width below\n                    // me.toggleTransitionClasses();\n\n                    // afterinternalresize event is buffered, it will be fired only once after animation is finished\n                    // and element size is final\n                    me.ion({\n                        afterinternalresize : () => {\n                            // me.toggleTransitionClasses(true);\n                            resolve(me);\n                        },\n                        thisObj : me,\n                        once    : true\n                    });\n                }\n\n                // When trying to collapse region we need its partner to occupy free space. Considering multiple\n                // regions, several cases are possible:\n                // 1) Both left and right regions have fixed width\n                // 2) Left region has fixed width, right region is flexed\n                // 3) Left region is flexed, right region has fixed width\n                // 4) Both regions are flexed\n                //\n                // To collapse flexed region we need to remove flex style, remember it somehow and set fixed width.\n                // If another region is flexed, it will fill the space. If it has fixed width, we need to increase\n                // its width by collapsing region width. Same logic should be applied to headers.\n                //\n                // Save region width first\n                _beforeCollapseState.width = me.width;\n                _beforeCollapseState.elementWidth = element.style.width;\n\n                // Next region is not flexed, need to make it fill the space\n                if (nextRegion.element.style.flex === '') {\n                    _beforeCollapseState.nextRegionWidth = nextRegion.width;\n                    nextRegion.width = '';\n                    nextRegion.flex = '1';\n                }\n\n                // Current region is flexed, store style to restore on expand\n                if (element.style.flex !== '') {\n                    _beforeCollapseState.flex = element.style.flex;\n                    // remove flex state to reduce width later\n                    me.header.element.style.flex = element.style.flex = '';\n                }\n\n                // Sets the grid to its collapsed width as defined in SASS: zero\n                element.classList.add('b-grid-subgrid-collapsed');\n\n                // The parallel elements which must be in sync width-wise must know about collapsing\n                me.virtualScrollerElement.classList.add('b-collapsed');\n                me.header.element.classList.add('b-collapsed');\n                me.footer.element.classList.add('b-collapsed');\n\n                me._collapsed = true;\n                me.width = '';\n\n                if (!widthChanged) {\n                    // sync splitters in case subGrid was collapsed by state (https://github.com/bryntum/support/issues/1857)\n                    me.syncParallelSplitters(true);\n\n                    resolve(false);\n                }\n            }\n            else {\n                resolve();\n            }\n        }).then(value => {\n            if (!me.isDestroyed) {\n                if (value !== false) {\n\n                    grid.refreshVirtualScrollbars();\n\n                    me.syncParallelSplitters(true);\n\n                    // Our splitter is permanently visible when collapsed, so keep splitter button set\n                    // synced in the vertical centre of the view just in time for paint.\n                    // Uses translateY so will not cause a further layout.\n                    splitterOwner.startSplitterButtonSyncing?.();\n                }\n\n                grid.trigger('subGridCollapse', { subGrid : me });\n                grid.afterToggleSubGrid({ subGrid : me, collapsed : true });\n            }\n        });\n    }\n\n    /**\n     * Expands subgrid.\n     *\n     * @example\n     * grid.getSubGrid('locked').expand().then(() => console.log('locked grid expanded'));\n     *\n     * @returns {Promise} A Promise which resolves when this SubGrid is fully expanded.\n     */\n    async expand() {\n        const\n            me            = this,\n            {\n                grid,\n                _beforeCollapseState\n            }             = me,\n            nextRegion    = grid.getSubGrid(grid.getNextRegion(me.region)),\n            splitterOwner = me.splitterElement ? me : me.previousSibling;\n\n        if (grid.rendered && me._collapsed !== true) {\n            return;\n        }\n\n        return new Promise((resolve) => {\n            if (_beforeCollapseState != null) {\n                // If current width matches width expected after expand resize event will not be fired. In such case\n                // we want to trigger callback immediately\n                let widthChanged = false;\n\n                // See similar clause in collapse method above\n                if (me.width !== _beforeCollapseState.elementWidth) {\n                    widthChanged = true;\n\n                    // Toggle transition classes here, we will actually change width below\n                    // me.toggleTransitionClasses();\n\n                    me.ion({\n                        afterinternalresize() {\n                            // me.toggleTransitionClasses(true);\n\n                            // Delay the resolve to avoid \"ResizeObserver loop limit exceeded\" errors\n                            // collapsing the only expanded region and it has to expand its nextRegion\n                            // before it can collapse.\n                            me.setTimeout(() => resolve(me), 10);\n                        },\n                        thisObj : me,\n                        once    : true\n                    });\n                }\n\n                // previous region is not flexed, reduce its width as it was increased in collapse\n                if (_beforeCollapseState.nextRegionWidth) {\n                    nextRegion.width = _beforeCollapseState.nextRegionWidth;\n                    nextRegion.flex = null;\n                }\n\n                me.element.classList.remove('b-grid-subgrid-collapsed');\n                me._collapsed = false;\n\n                // The parallel elements which must be in sync width-wise must know about collapsing\n                me.virtualScrollerElement.classList.remove('b-collapsed');\n                me.header.element.classList.remove('b-collapsed');\n                me.footer.element.classList.remove('b-collapsed');\n\n                // This region used to be flex, let's restore it\n                if (_beforeCollapseState.flex) {\n                    // Always restore width, restoring flex wont trigger resize otherwise\n                    me.width = _beforeCollapseState.width;\n\n                    // Widget flex setting clears style width\n                    me.header.flex = me.flex = _beforeCollapseState.flex;\n                    me.footer.flex = _beforeCollapseState.flex;\n                    me._width = null;\n                }\n                else {\n                    me.width = _beforeCollapseState.elementWidth;\n                }\n\n                me.element.classList.remove('b-grid-subgrid-collapsed');\n                me._collapsed = false;\n\n                if (!widthChanged) {\n                    resolve(false);\n                }\n                else {\n                    // Our splitter buttons are hidden when expanded, so we no longer need to keep splitter button set\n                    // synced in the vertical centre of the view.\n                    splitterOwner.stopSplitterButtonSyncing();\n\n                    me.syncParallelSplitters(false);\n                }\n\n                delete me._beforeCollapseState;\n            }\n            else {\n                resolve();\n            }\n        }).then(value => {\n            if (value !== false && !me.isDestroyed) {\n                grid.trigger('subGridExpand', { subGrid : me });\n                grid.afterToggleSubGrid({ subGrid : me, collapsed : false });\n            }\n        });\n    }\n\n    //endregion\n}\n\n// Register this widget type with its Factory\nSubGrid.initClass();\n","import Base from '../../../Core/Base.js';\nimport Column from '../../column/Column.js';\nimport GridBase from '../GridBase.js';\nimport SubGrid from '../SubGrid.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Grid/view/mixin/GridSubGrids\n */\n\n/**\n * Mixin for grid that handles SubGrids. Each SubGrid is scrollable horizontally separately from the other SubGrids.\n * Having two SubGrids allows you to achieve what is usually called locked or frozen columns.\n *\n * By default a Grid has two SubGrids, one named 'locked' and one 'normal'. The `locked` region has fixed width, while\n * the `normal` region grows to fill all available width (flex).\n *\n * Which SubGrid a column belongs to is determined using its {@link Grid.column.Column#config-region} config. For\n * example to put a column into the locked region, specify `{ region: 'locked' }`. For convenience, a column can be put\n * in the locked region using `{ locked: true }`.\n *\n * ```javascript\n * new Grid({\n *   columns : [\n *     // These two columns both end up in the \"locked\" region\n *     { field: 'name', text: 'Name', locked: true }\n *     { field: 'age', text: 'Age', region: 'locked' }\n *   ]\n * });\n * ```\n *\n * To customize the SubGrids, use {@link Grid.view.Grid#config-subGridConfigs}:\n *\n * ```javascript\n * // change the predefined subgrids\n * new Grid({\n *   subGridConfigs : {\n *       locked : { flex : 1 } ,\n *       normal : { flex : 3 }\n *   }\n * })\n *\n * // or define your own entirely\n * new Grid({\n *   subGridConfigs : {\n *       a : { width : 150 } ,\n *       b : { flex  : 1 },\n *       c : { width : 150 }\n *   },\n *\n *   columns : [\n *       { field : 'name', text : 'Name', region : 'a' },\n *       ...\n *   ]\n * })\n * ```\n *\n * @demo Grid/lockedcolumns\n * @mixin\n */\nexport default Target => class GridSubGrids extends (Target || Base) {\n    static get $name() {\n        return 'GridSubGrids';\n    }\n\n    static get properties() {\n        return {\n            /**\n             * An object containing the {@link Grid.view.SubGrid} region instances, indexed by subGrid id ('locked', normal'...)\n             * @member {Object<String,Grid.view.SubGrid>} subGrids\n             * @readonly\n             * @category Common\n             */\n            subGrids : {}\n        };\n    }\n\n    //region Init\n\n    changeSubGridConfigs(configs) {\n        const\n            me          = this,\n            usedRegions = new Set();\n\n        for (const column of me.columns) {\n            const { region } = column;\n\n            // Allow specifying regions for undefined subgrids\n            if (region) {\n                if (!configs[region]) {\n                    configs[region] = {};\n                }\n                usedRegions.add(region);\n            }\n        }\n\n        // Implementer has provided configs for other subGrids but not normal, put defaults in place\n        if (configs.normal && ObjectHelper.isEmpty(configs.normal)) {\n            configs.normal = GridBase.defaultConfig.subGridConfigs.normal;\n        }\n\n        for (const region of usedRegions) {\n            me.createSubGrid(region, configs[region]);\n        }\n\n        // Add them to Grid\n        me.items = me.subGrids;\n\n        return configs;\n    }\n\n    createSubGrid(region, config = null) {\n        const\n            me             = this,\n            subGridColumns = me.columns.makeChained(column => column.region === region, ['region']),\n            subGridConfig  = ObjectHelper.assign({\n                type        : 'subgrid',\n                id          : `${me.id}-${region}Subgrid`,\n                parent      : me,\n                grid        : me,\n                region      : region,\n                headerClass : me.headerClass,\n                footerClass : me.footerClass,\n                columns     : subGridColumns,\n                // Sort by region unless weight is explicitly defined\n                weight      : region\n            }, config || me.subGridConfigs[region]);\n\n        let hasCalculatedWidth = false;\n\n        if (!subGridConfig.flex && !subGridConfig.width) {\n            subGridConfig.width = subGridColumns.totalFixedWidth;\n            hasCalculatedWidth = true;\n        }\n\n        // Subclasses may inject a type property to create custom SubGrids\n        const subGrid = me.subGrids[region] = SubGrid.create(subGridConfig);\n\n        // Must be set after creation, otherwise reset in SubGrid#set width\n        subGrid.hasCalculatedWidth = hasCalculatedWidth;\n\n        if (region === me.regions[0]) {\n            // Have already done lookups for this in a couple of places, might as well store it...\n            subGrid.isFirstRegion = true;\n        }\n\n        return subGrid;\n    }\n\n    // A SubGrid is added to Grid, add its header etc too\n    onChildAdd(subGrid) {\n        if (subGrid.isSubGrid) {\n            const\n                me    = this,\n                {\n                    items,\n                    headerContainer,\n                    virtualScrollers,\n                    footerContainer\n                }     = me,\n                // 2 elements per index, actual element + splitter\n                index = items.indexOf(subGrid) * 2;\n\n            if (!me.hideHeaders) {\n                DomHelper.insertAt(headerContainer, subGrid.headerSplitter, index);\n                DomHelper.insertAt(headerContainer, subGrid.header.element, index);\n            }\n\n            DomHelper.insertAt(virtualScrollers, subGrid.scrollerSplitter, index);\n            DomHelper.insertAt(virtualScrollers, subGrid.virtualScrollerElement, index);\n\n            DomHelper.insertAt(footerContainer, subGrid.footerSplitter, index);\n            DomHelper.insertAt(footerContainer, subGrid.footer.element, index);\n\n            // Show splitter for all except last (new might not sort last, depending on weight)\n            items.forEach((subGrid, i) => {\n                if (i < items.length - 1) {\n                    subGrid.showSplitter();\n                }\n            });\n\n            // Empty text should be displayed in the first subgrid\n            if (index === 0 && me.emptyTextEl) {\n                subGrid.element.appendChild(me.emptyTextEl);\n            }\n        }\n\n        return super.onChildAdd(subGrid);\n    }\n\n    // A SubGrid is remove from grid, remove its header etc too\n    onChildRemove(subGrid) {\n        super.onChildRemove(subGrid);\n\n        if (subGrid.isSubGrid) {\n            const { items } = this;\n\n            delete this.subGrids[subGrid.region];\n            ArrayHelper.remove(this.regions, subGrid.region);\n            subGrid.destroy();\n\n            // Make sure the new last splitter is hidden\n            if (items.length) {\n                items[items.length - 1].hideSplitter();\n            }\n        }\n    }\n\n    doDestroy() {\n        this.eachSubGrid(subGrid => subGrid.destroy());\n        super.doDestroy();\n    }\n\n    //endregion\n\n    //region Iteration & calling\n\n    /**\n     * Iterate over all subGrids, calling the supplied function for each.\n     * @param {Function} fn Function to call for each instance\n     * @param {Object} thisObj `this` reference to call the function in, defaults to the subGrid itself\n     * @category SubGrid\n     * @internal\n     */\n    eachSubGrid(fn, thisObj = null) {\n        this.items.forEach((subGrid, i) => {\n            subGrid.isSubGrid && fn.call(thisObj || subGrid, subGrid, i++);\n        });\n    }\n\n    /**\n     * Call a function by name for all subGrids (that have the function).\n     * @param {String} fnName Name of function to call, uses the subGrid itself as `this` reference\n     * @param params Parameters to call the function with\n     * @returns {*} Return value from first SubGrid is returned\n     * @category SubGrid\n     * @internal\n     */\n    callEachSubGrid(fnName, ...params) {\n        // TODO: make object { normal: retval, locked: retval } to return? or store. revisit when needed\n        let returnValue = null;\n        this.items.forEach((subGrid, i) => {\n            if (subGrid.isSubGrid && subGrid[fnName]) {\n                const partialReturnValue = subGrid[fnName](...params);\n                if (i === 0) returnValue = partialReturnValue;\n            }\n        });\n        return returnValue;\n    }\n\n    //endregion\n\n    //region Getters\n\n    get regions() {\n        return this.items.map(item => item.region);\n    }\n\n    /**\n     * This method should return names of the two last regions in the grid as they are visible in the UI. In case\n     * `regions` property cannot be trusted, use different approach. Used by SubGrid and RegionResize to figure out\n     * which region should collapse or expand.\n     * @returns {String[]}\n     * @private\n     * @category SubGrid\n     */\n    getLastRegions() {\n        const result = this.regions.slice(-2);\n        // ALWAYS return array of length 2 in order to avoid extra conditions. Normally should not be called with 1 region\n        return result.length === 2 ? result : [result[0], result[0]];\n    }\n\n    /**\n     * This method should return right neighbour for passed region, or left neighbour in case last visible region is passed.\n     * This method is used to decide which subgrid should take space of the collapsed one.\n     * @param {String} region\n     * @returns {String}\n     * @private\n     * @category SubGrid\n     */\n    getNextRegion(region) {\n        const regions = this.regions;\n\n        // return next region or next to last\n        return regions[regions.indexOf(region) + 1] || regions[regions.length - 2];\n    }\n\n    getPreviousRegion(region) {\n        return this.regions[this.regions.indexOf(region) - 1];\n    }\n\n    /**\n     * Returns the subGrid for the specified region.\n     * @param {String} region Region, eg. locked or normal (per default)\n     * @returns {Grid.view.SubGrid} A subGrid\n     * @category SubGrid\n     */\n    getSubGrid(region) {\n        return this.subGrids[region];\n    }\n\n    /**\n     * Get the SubGrid that contains specified column\n     * @param {String|Grid.column.Column} column Column \"name\" or column object\n     * @returns {Grid.view.SubGrid}\n     * @category SubGrid\n     */\n    getSubGridFromColumn(column) {\n        column = column instanceof Column ? column : this.columns.getById(column) || this.columns.get(column);\n\n        return this.getSubGrid(column.region);\n    }\n\n    //endregion\n\n    /**\n     * Returns splitter element for subgrid\n     * @param {Grid.view.SubGrid|String} subGrid\n     * @returns {HTMLElement}\n     * @private\n     * @category SubGrid\n     */\n    resolveSplitter(subGrid) {\n        const regions = this.getLastRegions();\n\n        let region = subGrid instanceof SubGrid ? subGrid.region : subGrid;\n\n        if (regions[1] === region) {\n            region = regions[0];\n        }\n\n        return this.subGrids[region].splitterElement;\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import LocaleHelper from '../../Core/localization/LocaleHelper.js';\nimport '../../Core/localization/En.js';\n\nconst emptyString = new String();\n\nconst locale = {\n\n    localeName : 'En',\n    localeDesc : 'English (US)',\n    localeCode : 'en-US',\n\n    ColumnPicker : {\n        column          : 'Column',\n        columnsMenu     : 'Columns',\n        hideColumn      : 'Hide column',\n        hideColumnShort : 'Hide',\n        newColumns      : 'New columns'\n    },\n\n    Filter : {\n        applyFilter   : 'Apply filter',\n        filter        : 'Filter',\n        editFilter    : 'Edit filter',\n        on            : 'On',\n        before        : 'Before',\n        after         : 'After',\n        equals        : 'Equals',\n        lessThan      : 'Less than',\n        moreThan      : 'More than',\n        removeFilter  : 'Remove filter',\n        disableFilter : 'Disable filter'\n    },\n\n    FilterBar : {\n        enableFilterBar  : 'Show filter bar',\n        disableFilterBar : 'Hide filter bar'\n    },\n\n    Group : {\n        group                : 'Group',\n        groupAscending       : 'Group ascending',\n        groupDescending      : 'Group descending',\n        groupAscendingShort  : 'Ascending',\n        groupDescendingShort : 'Descending',\n        stopGrouping         : 'Stop grouping',\n        stopGroupingShort    : 'Stop'\n    },\n\n    HeaderMenu : {\n        moveBefore     : text => `Move before \"${text}\"`,\n        moveAfter      : text => `Move after \"${text}\"`,\n        collapseColumn : 'Collapse column',\n        expandColumn   : 'Expand column'\n    },\n\n    ColumnRename : {\n        rename : 'Rename'\n    },\n\n    MergeCells : {\n        mergeCells  : 'Merge cells',\n        menuTooltip : 'Merge cells with same value when sorted by this column'\n    },\n\n    Search : {\n        searchForValue : 'Search for value'\n    },\n\n    Sort : {\n        sort                   : 'Sort',\n        sortAscending          : 'Sort ascending',\n        sortDescending         : 'Sort descending',\n        multiSort              : 'Multi sort',\n        removeSorter           : 'Remove sorter',\n        addSortAscending       : 'Add ascending sorter',\n        addSortDescending      : 'Add descending sorter',\n        toggleSortAscending    : 'Change to ascending',\n        toggleSortDescending   : 'Change to descending',\n        sortAscendingShort     : 'Ascending',\n        sortDescendingShort    : 'Descending',\n        removeSorterShort      : 'Remove',\n        addSortAscendingShort  : '+ Ascending',\n        addSortDescendingShort : '+ Descending'\n    },\n\n    Column : {\n        columnLabel : column => `${column.text ? `${column.text} column. ` : ''}SPACE for context menu${column.sortable ? ', ENTER to sort' : ''}`,\n        cellLabel   : emptyString\n    },\n\n    Checkbox : {\n        toggleRowSelect : 'Toggle row selection',\n        toggleSelection : 'Toggle selection of entire dataset'\n    },\n\n    RatingColumn : {\n        cellLabel : column => `${column.text ? column.text : ''} ${column.location?.record ? `rating : ${column.location.record[column.field] || 0}` : ''}`\n    },\n\n    GridBase : {\n        loadFailedMessage  : 'Data loading failed!',\n        syncFailedMessage  : 'Data synchronization failed!',\n        unspecifiedFailure : 'Unspecified failure',\n        networkFailure     : 'Network error',\n        parseFailure       : 'Failed to parse server response',\n        serverResponse     : 'Server response:',\n        noRows             : 'No records to display',\n        moveColumnLeft     : 'Move to left section',\n        moveColumnRight    : 'Move to right section',\n        moveColumnTo       : region => `Move column to ${region}`\n    },\n\n    CellMenu : {\n        removeRow : 'Delete'\n    },\n\n    RowCopyPaste : {\n        copyRecord  : 'Copy',\n        cutRecord   : 'Cut',\n        pasteRecord : 'Paste',\n        rows        : 'rows',\n        row         : 'row'\n    },\n\n    CellCopyPaste : {\n        copy  : 'Copy',\n        cut   : 'Cut',\n        paste : 'Paste'\n    },\n\n    PdfExport : {\n        'Waiting for response from server' : 'Waiting for response from server...',\n        'Export failed'                    : 'Export failed',\n        'Server error'                     : 'Server error',\n        'Generating pages'                 : 'Generating pages...',\n        'Click to abort'                   : 'Cancel'\n    },\n\n    ExportDialog : {\n        width          : '40em',\n        labelWidth     : '12em',\n        exportSettings : 'Export settings',\n        export         : 'Export',\n        exporterType   : 'Control pagination',\n        cancel         : 'Cancel',\n        fileFormat     : 'File format',\n        rows           : 'Rows',\n        alignRows      : 'Align rows',\n        columns        : 'Columns',\n        paperFormat    : 'Paper format',\n        orientation    : 'Orientation',\n        repeatHeader   : 'Repeat header'\n    },\n\n    ExportRowsCombo : {\n        all     : 'All rows',\n        visible : 'Visible rows'\n    },\n\n    ExportOrientationCombo : {\n        portrait  : 'Portrait',\n        landscape : 'Landscape'\n    },\n\n    SinglePageExporter : {\n        singlepage : 'Single page'\n    },\n\n    MultiPageExporter : {\n        multipage     : 'Multiple pages',\n        exportingPage : ({ currentPage, totalPages }) => `Exporting page ${currentPage}/${totalPages}`\n    },\n\n    MultiPageVerticalExporter : {\n        multipagevertical : 'Multiple pages (vertical)',\n        exportingPage     : ({ currentPage, totalPages }) => `Exporting page ${currentPage}/${totalPages}`\n    },\n\n    RowExpander : {\n        loading  : 'Loading',\n        expand   : 'Expand',\n        collapse : 'Collapse'\n    }\n};\n\nexport default LocaleHelper.publishLocale(locale);\n","//region Import\n\nimport Base from '../../Core/Base.js';\n\nimport AjaxStore from '../../Core/data/AjaxStore.js';\nimport DomDataStore from '../../Core/data/DomDataStore.js';\nimport Store from '../../Core/data/Store.js';\n\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport ScrollManager from '../../Core/util/ScrollManager.js';\n\nimport Mask from '../../Core/widget/Mask.js';\nimport Panel from '../../Core/widget/Panel.js';\nimport GlobalEvents from '../../Core/GlobalEvents.js';\n\nimport LocaleManager from '../../Core/localization/LocaleManager.js';\nimport Pluggable from '../../Core/mixin/Pluggable.js';\nimport State from '../../Core/mixin/State.js';\nimport ColumnStore, { columnResizeEvent } from '../data/ColumnStore.js';\nimport GridRowModel from '../data/GridRowModel.js';\nimport RowManager from '../row/RowManager.js';\nimport GridScroller from '../util/GridScroller.js';\nimport Location from '../util/Location.js';\nimport Header from './Header.js';\nimport Footer from './Footer.js';\n\nimport GridElementEvents from './mixin/GridElementEvents.js';\nimport GridFeatures from './mixin/GridFeatures.js';\nimport GridNavigation from './mixin/GridNavigation.js';\nimport GridResponsive from './mixin/GridResponsive.js';\nimport GridSelection from './mixin/GridSelection.js';\nimport GridState from './mixin/GridState.js';\nimport GridSubGrids from './mixin/GridSubGrids.js';\nimport LoadMaskable from '../../Core/mixin/LoadMaskable.js';\n\nimport Column from '../column/Column.js';\n\n// Needed since Grid now has its own localization\nimport '../localization/En.js';\n\n//endregion\n\n/**\n * @module Grid/view/GridBase\n */\n\nconst\n    resolvedPromise       = new Promise(resolve => resolve()),\n    storeListenerName     = 'GridBase:store',\n    defaultScrollOptions  = {\n        block  : 'nearest',\n        inline : 'nearest'\n    },\n    datasetReplaceActions = {\n        dataset  : 1,\n        pageLoad : 1,\n        filter   : 1\n    };\n\n/**\n * A thin base class for {@link Grid.view.Grid}. Does not include any features by default, allowing smaller custom built\n * bundles if used in place of {@link Grid.view.Grid}.\n *\n * **NOTE:** In most scenarios you probably want to use Grid instead of GridBase.\n\n * @extends Core/widget/Panel\n *\n * @mixes Core/mixin/Pluggable\n * @mixes Core/mixin/State\n * @mixes Grid/view/mixin/GridElementEvents\n * @mixes Grid/view/mixin/GridFeatures\n * @mixes Grid/view/mixin/GridResponsive\n * @mixes Grid/view/mixin/GridSelection\n * @mixes Grid/view/mixin/GridState\n * @mixes Grid/view/mixin/GridSubGrids\n * @mixes Core/mixin/LoadMaskable\n *\n * @features Grid/feature/CellCopyPaste\n * @features Grid/feature/CellEdit\n * @features Grid/feature/CellMenu\n * @features Grid/feature/CellTooltip\n * @features Grid/feature/ColumnAutoWidth\n * @features Grid/feature/ColumnDragToolbar\n * @features Grid/feature/ColumnPicker\n * @features Grid/feature/ColumnRename\n * @features Grid/feature/ColumnReorder\n * @features Grid/feature/ColumnResize\n * @features Grid/feature/FillHandle\n * @features Grid/feature/Filter\n * @features Grid/feature/FilterBar\n * @features Grid/feature/Group\n * @features Grid/feature/GroupSummary\n * @features Grid/feature/HeaderMenu\n * @features Grid/feature/MergeCells\n * @features Grid/feature/QuickFind\n * @features Grid/feature/RegionResize\n * @features Grid/feature/RowCopyPaste\n * @features Grid/feature/RowExpander\n * @features Grid/feature/RowReorder\n * @features Grid/feature/Search\n * @features Grid/feature/Sort\n * @features Grid/feature/StickyCells\n * @features Grid/feature/Stripe\n * @features Grid/feature/Summary\n * @features Grid/feature/Tree\n * @features Grid/feature/TreeGroup\n *\n * @features Grid/feature/experimental/ExcelExporter\n *\n * @features Grid/feature/export/PdfExport\n * @features Grid/feature/export/exporter/MultiPageExporter\n * @features Grid/feature/export/exporter/MultiPageVerticalExporter\n * @features Grid/feature/export/exporter/SinglePageExporter\n *\n * @plugins Grid/row/RowManager\n * @widget\n */\nexport default class GridBase extends Panel.mixin(\n    Pluggable,\n    State,\n    GridElementEvents,\n    GridFeatures,\n    GridNavigation,\n    GridResponsive,\n    GridSelection,\n    GridState,\n    GridSubGrids,\n    LoadMaskable\n) {\n    //region Config\n\n    static get $name() {\n        return 'GridBase';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'gridbase';\n    }\n\n    static get delayable() {\n        return {\n            onGridVerticalScroll : {\n                type : 'raf'\n            },\n\n            bufferedAfterColumnsResized : 250,\n\n            bufferedElementResize : 250\n        };\n    }\n\n    static get configurable() {\n        return {\n            //region Hidden configs\n\n            /**\n             * @hideconfigs autoUpdateRecord, defaults, hideWhenEmpty, itemCls, items, layout, layoutStyle, lazyItems, namedItems, record, textContent, defaultAction, html, htmlCls, tag, textAlign, trapFocus, content, defaultBindProperty, ripple\n             */\n\n            /**\n             * @hideproperties html, isSettingValues, isValid, items, record, values, content, layoutStyle\n             */\n\n            /**\n             * @hidefunctions attachTooltip, add, getWidgetById, insert, processWidgetConfig, remove, removeAll, getAt\n             */\n\n            //endregion\n\n            /**\n             * Set to `true` to make the grid read-only, by disabling any UIs for modifying data.\n             *\n             * __Note that checks MUST always also be applied at the server side.__\n             * @prp {Boolean} readOnly\n             * @default false\n             * @category Misc\n             */\n\n            /**\n             * Automatically set grids height to fit all rows (no scrolling in the grid). In general you should avoid\n             * using `autoHeight: true`, since it will bypass Grids virtual rendering and render all rows at once, which\n             * in a larger grid is really bad for performance.\n             * @config {Boolean}\n             * @default false\n             * @category Layout\n             */\n            autoHeight : null,\n\n            /**\n             * Configure this as `true` to allow elements within cells to be styled as `position: sticky`.\n             *\n             * Columns which contain sticky content will need to be configured with\n             *\n             * ```javascript\n             *    cellCls : 'b-sticky-cell',\n             * ```\n             *\n             * Or a custom renderer can add the class to the passed cell element.\n             *\n             * It is up to the application author how to style the cell content. It is recommended that\n             * a custom renderer create content with CSS class names which the application author\n             * will use to apply the `position`, and matching `margin-top` and `top` styles to keep the\n             * content stuck at the grid's top.\n             *\n             * Note that not all browsers support this CSS feature. A cross browser alternative\n             * is to use the {link Grid.feature.StickyCells StickyCells} Feature.\n             * @config {Boolean}\n             * @category Misc\n             */\n            enableSticky : null,\n\n            /**\n             * Set to true to allow text selection in the grid cells. Note, this cannot be used simultaneously with the\n             * `RowReorder` feature.\n             * @config {Boolean}\n             * @default false\n             * @category Selection\n             */\n            enableTextSelection : null,\n\n            /**\n             * Set to `true` to stretch the last column in a grid with all fixed width columns\n             * to fill extra available space if the grid's width is wider than the sum of all\n             * configured column widths.\n             * @config {Boolean}\n             * @default\n             * @category Layout\n             */\n            fillLastColumn : true,\n\n            /**\n             * See {@link Grid.view.Grid#keyboard-shortcuts Keyboard shortcuts} for details\n             * @config {Object<String,String>} keyMap\n             * @category Common\n             */\n\n            // TODO: break out as strategies\n            positionMode : 'translate', // translate, translate3d, position\n\n            /**\n             * Configure as `true` to have the grid show a red \"changed\" tag in cells who's\n             * field value has changed and not yet been committed.\n             * @config {Boolean}\n             * @default false\n             * @category Misc\n             */\n            showDirty : null,\n\n            /**\n             * An object containing sub grid configuration objects keyed by a `region` property.\n             * By default, grid has a 'locked' region (if configured with locked columns) and a 'normal' region.\n             * The 'normal' region defaults to use `flex: 1`.\n             *\n             * This config can be used to reconfigure the \"built in\" sub grids or to define your own.\n             *\n             * Redefining the default regions:\n             *\n             * {@frameworktabs}\n             * {@js}\n             * ```javascript\n             * new Grid({\n             *   subGridConfigs : {\n             *     locked : { flex : 1 },\n             *     normal : { width : 100 }\n             *   }\n             * });\n             * ```\n             * {@endjs}\n             * {@react}\n             * ```jsx\n             * const App = props => {\n             *     const subGridConfigs = {\n             *         locked : { flex : 1 },\n             *         normal : { width : 100 }\n             *     };\n             *\n             *     return <bryntum-grid subGridConfigs={subGridConfigs} />\n             * }\n             * ```\n             * {@endreact}\n             * {@vue}\n             * ```html\n             * <bryntum-grid :sub-grid-configs=\"subGridConfigs\" />\n             * ```\n             * ```javascript\n             * export default {\n             *     setup() {\n             *         return {\n             *             subGridConfigs : [\n             *                 locked : { flex : 1 },\n             *                 normal : { width : 100 }\n             *             ]\n             *         };\n             *     }\n             * }\n             * ```\n             * {@endvue}\n             * {@angular}\n             * ```html\n             * <bryntum-grid [subGridConfigs]=\"subGridConfigs\"></bryntum-grid>\n             * ```\n             * ```typescript\n             * export class AppComponent {\n             *      subGridConfigs = [\n             *          locked : { flex : 1 },\n             *          normal : { width : 100 }\n             *      ]\n             *  }\n             * ```\n             * {@endangular}\n             * {@endframeworktabs}\n             *\n             * Defining your own multi region grid:\n             *\n             * ```javascript\n             * new Grid({\n             *   subGridConfigs : {\n             *     left   : { width : 100 },\n             *     middle : { flex : 1 },\n             *     right  : { width  : 100 }\n             *   },\n             *\n             *   columns : [\n             *     { field : 'manufacturer', text: 'Manufacturer', region : 'left' },\n             *     { field : 'model', text: 'Model', region : 'middle' },\n             *     { field : 'year', text: 'Year', region : 'middle' },\n             *     { field : 'sales', text: 'Sales', region : 'right' }\n             *   ]\n             * });\n             * ```\n             * @config {Object<String,SubGridConfig>}\n             * @category Misc\n             */\n            subGridConfigs : {\n                normal : { flex : 1 }\n            },\n\n            /**\n             * Store that holds records to display in the grid, or a store config object. If the configuration contains\n             * a `readUrl`, an `AjaxStore` will be created.\n             *\n             * Note that a store will be created during initialization if none is specified.\n             *\n             * Supplying a store config object at initialization time:\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     store : {\n             *         fields : ['name', 'powers'],\n             *         data   : [\n             *             { id : 1, name : 'Aquaman', powers : 'Decent swimmer' },\n             *             { id : 2, name : 'Flash', powers : 'Pretty fast' },\n             *         ]\n             *     }\n             * });\n             * ```\n             *\n             * Accessing the store at runtime:\n             *\n             * ```javascript\n             * grid.store.sort('powers');\n             * ```\n             *\n             * @prp {Core.data.Store}\n             * @accepts {Core.data.Store|StoreConfig}\n             * @category Common\n             */\n            store : {\n                value : {},\n\n                $config : 'nullify'\n            },\n\n            rowManager : {\n                value : {},\n\n                $config : ['nullify', 'lazy']\n            },\n\n            /**\n             * Configuration values for the {@link Core.util.ScrollManager} class on initialization. Returns the\n             * {@link Core.util.ScrollManager} at runtime.\n             *\n             * @prp {Core.util.ScrollManager}\n             * @accepts {ScrollManagerConfig|Core.util.ScrollManager}\n             * @readonly\n             * @category Scrolling\n             */\n            scrollManager : {\n                value : {},\n\n                $config : ['nullify', 'lazy']\n            },\n\n            /**\n             * Accepts column definitions for the grid during initialization. They will be used to create\n             * {@link Grid/column/Column} instances that are added to a {@link Grid/data/ColumnStore}.\n             *\n             * At runtime it is read-only and returns the {@link Grid/data/ColumnStore}.\n             *\n             * Initialization using column config objects:\n             *\n             * ```javascript\n             * new Grid({\n             *   columns : [\n             *     { text : 'Alias', field : 'alias' },\n             *     { text : 'Superpower', field : 'power' }\n             *   ]\n             * });\n             * ```\n             *\n             * Also accepts a store config object:\n             *\n             * ```javascript\n             * new Grid({\n             *   columns : {\n             *     data : [\n             *       { text : 'Alias', field : 'alias' },\n             *       { text : 'Superpower', field : 'power' }\n             *     ],\n             *     listeners : {\n             *       update() {\n             *         // Some update happened\n             *       }\n             *     }\n             *   }\n             * });\n             * ```\n             *\n             * Access the {@link Grid/data/ColumnStore} at runtime to manipulate columns:\n             *\n             * ```javascript\n             * grid.columns.add({ field : 'column', text : 'New column' });\n             * ```\n             * @prp {Grid.data.ColumnStore}\n             * @accepts {Grid.data.ColumnStore|GridColumnConfig[]|ColumnStoreConfig}\n             * @readonly\n             * @category Common\n             */\n            columns : {\n                value : [],\n\n                $config : 'nullify'\n            },\n\n            /**\n             * Grid's `min-height`. Defaults to `10em` to be sure that the Grid always has a height wherever it is\n             * inserted.\n             *\n             * Can be either a String or a Number (which will have 'px' appended).\n             *\n             * Note that _reading_ the value will return the numeric value in pixels.\n             *\n             * @config {String|Number}\n             * @category Layout\n             */\n            minHeight : '10em',\n\n            hideFooters : true,\n\n            contentElMutationObserver : false,\n            trapFocus                 : false,\n\n            ariaElement : 'bodyElement',\n\n            cellTabIndex : -1,\n\n            rowCls : {\n                value   : 'b-grid-row',\n                $config : {\n                    merge : this.mergeCls\n                }\n            },\n\n            cellCls : {\n                value   : 'b-grid-cell',\n                $config : {\n                    merge : this.mergeCls\n                }\n            },\n\n            /**\n             * Text or HTML to display when there is no data to display in the grid\n             * @prp {String}\n             * @default\n             * @category Common\n             */\n            emptyText        : 'L{noRows}',\n            sortFeatureStore : 'store'\n        };\n    }\n\n    // Default settings, applied in grids constructor.\n    static get defaultConfig() {\n        return {\n            /**\n             * Row height in pixels. This allows the default height for rows to be controlled. Note that it may be\n             * overriden by specifying a {@link Grid/data/GridRowModel#field-rowHeight} on a per record basis, or from\n             * a column {@link Grid/column/Column#config-renderer}.\n             *\n             * When initially configured as `null`, an empty row will be measured and its height will be used as default\n             * row height, enabling it to be controlled using CSS\n             *\n             * @prp {Number}\n             * @category Common\n             */\n            rowHeight : null,\n\n            /**\n             * Use fixed row height. Setting this to `true` will configure the underlying RowManager to use fixed row\n             * height, which sacrifices the ability to use rows with variable height to gain a fraction better\n             * performance.\n             *\n             * Using this setting also ignores the {@link Grid.view.GridBase#config-getRowHeight} function, and thus any\n             * row height set in data. Only Grids configured {@link Grid.view.GridBase#config-rowHeight} is used.\n             *\n             * @config {Boolean}\n             * @category Layout\n             */\n            fixedRowHeight : null,\n\n            /**\n             * A function called for each row to determine its height. It is passed a {@link Core.data.Model record} and\n             * expected to return the desired height of that records row. If the function returns a falsy value, Grids\n             * configured {@link Grid.view.GridBase#config-rowHeight} is used.\n             *\n             * The default implementation of this function returns the row height from the records\n             * {@link Grid.data.GridRowModel#field-rowHeight rowHeight field}.\n             *\n             * Override this function to take control over how row heights are determined:\n             *\n             * ```javascript\n             * new Grid({\n             *    getRowHeight(record) {\n             *        if (record.low) {\n             *            return 20;\n             *        }\n             *        else if (record.high) {\n             *            return 60;\n             *        }\n             *\n             *        // Will use grids configured rowHeight\n             *        return null;\n             *    }\n             * });\n             * ```\n             *\n             * NOTE: Height set in a Column renderer takes precedence over the height returned by this function.\n             *\n             * @config {Function} getRowHeight\n             * @param {Core.data.Model} getRowHeight.record Record to determine row height for\n             * @returns {Number} Desired row height\n             * @category Layout\n             */\n\n            // used if no rowHeight specified and none found in CSS. not public since our themes have row height\n            // specified and this is more of an internal failsafe\n            defaultRowHeight : 45,\n\n            /**\n             * Refresh entire row when a record changes (`true`) or, if possible, only the cells affected (`false`).\n             *\n             * When this is set to `false`, then if a column uses a renderer, cells in that column will still\n             * be updated because it is impossible to know whether the cells value will be affected.\n             *\n             * If a standard, provided Column class is used with no custom renderer, its cells will only be updated\n             * if the column's {@link Grid.column.Column#config-field} is changed.\n             * @config {Boolean}\n             * @default\n             * @category Misc\n             */\n            fullRowRefresh : true,\n\n            /**\n             * True to not create any grid column headers\n             * @config {Boolean}\n             * @default false\n             * @category Misc\n             */\n            hideHeaders : null,\n\n            /**\n             * Specify `true` to preserve vertical scroll position after store actions that trigger a `refresh` event,\n             * such as loading new data and filtering.\n             * @config {Boolean}\n             * @default false\n             * @category Misc\n             */\n            preserveScrollOnDatasetChange : null,\n\n            /**\n             * True to preserve focused cell after loading new data\n             * @config {Boolean}\n             * @default\n             * @category Misc\n             */\n            preserveFocusOnDatasetChange : true,\n\n            /**\n             * Convenient shortcut to set data in grids store both during initialization and at runtime. Can also be\n             * used to retrieve data at runtime, although we do recommend interacting with Grids store instead using\n             * the {@link #property-store} property.\n             *\n             * Setting initial data during initialization:\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     data : [\n             *       { id : 1, name : 'Batman' },\n             *       { id : 2, name : 'Robin' },\n             *       ...\n             *     ]\n             * });\n             * ```\n             *\n             * Setting data at runtime:\n             *\n             * ```javascript\n             * grid.data = [\n             *     { id : 3, name : 'Joker' },\n             *     ...\n             * ];\n             * ```\n             *\n             * Getting data at runtime:\n             *\n             * ```javascript\n             * const records = store.data;\n             * ```\n             *\n             * Note that a Store will be created during initialization if none is specified.\n             *\n             * @prp {Core.data.Model[]}\n             * @accepts {Object[]|Core.data.Model[]}\n             * @category Common\n             */\n            data : null,\n\n            /**\n             * Region to which columns are added when they have none specified\n             * @config {String}\n             * @default\n             * @category Misc\n             */\n            defaultRegion : 'normal',\n\n            /**\n             * true to destroy the store when the grid is destroyed\n             * @config {Boolean}\n             * @default false\n             * @category Misc\n             */\n            destroyStore : null,\n\n            /**\n             * Grids change the `maskDefaults` to cover only their `body` element.\n             * @config {MaskConfig|Core.widget.Mask}\n             * @category Misc\n             */\n            maskDefaults : {\n                cover  : 'body',\n                target : 'element'\n            },\n\n            /**\n             * Set to `false` to inhibit column lines during initialization or assign to it at runtime to toggle column\n             * line visibility.\n             *\n             * End result might be overruled by/differ between themes.\n             *\n             * @prp {Boolean}\n             * @default\n             * @category Misc\n             */\n            columnLines : true,\n\n            /**\n             * Set to `false` to only measure cell contents when double clicking the edge between column headers.\n             * @config {Boolean}\n             * @default\n             * @category Layout\n             */\n            resizeToFitIncludesHeader : true,\n\n            /**\n             * Set to `false` to prevent remove row animation and remove the delay related to that.\n             * @config {Boolean}\n             * @default\n             * @category Misc\n             */\n            animateRemovingRows : true,\n\n            /**\n             * Set to `true` to not get a warning when using another base class than GridRowModel for your grid data. If\n             * you do, and would like to use the full feature set of the grid then include the fields from GridRowModel\n             * in your model definition.\n             * @config {Boolean}\n             * @default false\n             * @category Misc\n             */\n            disableGridRowModelWarning : null,\n\n            headerClass : Header,\n            footerClass : Footer,\n\n            testPerformance : false,\n            rowScrollMode   : 'move', // move, dom, all\n\n            /**\n             * Grid monitors window resize by default.\n             * @config {Boolean}\n             * @default true\n             * @category Misc\n             */\n            monitorResize : true,\n\n            /**\n             * An object containing Feature configuration objects (or `true` if no configuration is required)\n             * keyed by the Feature class name in all lowercase.\n             * @config {Object}\n             * @category Common\n             */\n            features : true,\n\n            /**\n             * Configures whether the grid is scrollable in the `Y` axis. This is used to configure a {@link Grid.util.GridScroller}.\n             * See the {@link #config-scrollerClass} config option.\n             * @config {Boolean|ScrollerConfig|Core.helper.util.Scroller}\n             * @category Scrolling\n             */\n            scrollable : {\n                // Just Y for now until we implement a special grid.view.Scroller subclass\n                // Which handles the X scrolling of subgrids.\n                overflowY : true\n            },\n\n            /**\n             * The class to instantiate to use as the {@link #config-scrollable}. Defaults to {@link Grid.util.GridScroller}.\n             * @config {Core.helper.util.Scroller}\n             * @typings {typeof Scroller}\n             * @category Scrolling\n             */\n            scrollerClass : GridScroller,\n\n            refreshSuspended : 0,\n\n            /**\n             * Animation transition duration in milliseconds.\n             * @prp {Number}\n             * @default\n             * @category Misc\n             */\n            transitionDuration : 500,\n\n            /**\n             * Event which is used to show context menus.\n             * Available options are: 'contextmenu', 'click', 'dblclick'.\n             * @config {'contextmenu'|'click'|'dblclick'}\n             * @category Misc\n             * @default\n             */\n            contextMenuTriggerEvent : 'contextmenu',\n\n            localizableProperties : ['emptyText'],\n\n            asyncEventSuffix : '',\n\n            testConfig : {\n                transitionDuration : 50\n            }\n        };\n    }\n\n    static get properties() {\n        return {\n            _selectedRecords      : [],\n            _verticalScrollHeight : 0,\n            virtualScrollHeight   : 0,\n            _scrollTop            : null\n        };\n    }\n\n    // Keep this commented out to have easy access to the syntax next time we need to use it\n    // static get deprecatedEvents() {\n    //     return {\n    //         cellContextMenuBeforeShow : {\n    //             product            : 'Grid',\n    //             invalidAsOfVersion : '5.0.0',\n    //             message            : '`cellContextMenuBeforeShow` event is deprecated, in favor of `cellMenuBeforeShow` event. Please see https://bryntum.com/products/grid/docs/guide/Grid/upgrades/4.0.0 for more information.'\n    //         }\n    //     };\n    // }\n\n    //endregion\n\n    //region Init-destroy\n\n    finishConfigure(config) {\n        const\n            me             = this,\n            { initScroll } = me;\n\n        // Make initScroll a one time only call\n        me.initScroll = () => !me.scrollInitialized && initScroll.call(me);\n\n        super.finishConfigure(config);\n\n        // When locale is applied columns react and change, which triggers `change` event on columns store for each\n        // changed column, and every change normally triggers rendering view. This overhead becomes noticeable with\n        // larger amount of columns. So we set two listeners to locale events: prioritized listener to be executed first\n        // and suspend renderContents method and unprioritized one to resume method and call it immediately.\n        LocaleManager.ion({\n            locale  : 'onBeforeLocaleChange',\n            prio    : 1,\n            thisObj : me\n        });\n\n        LocaleManager.ion({\n            locale  : 'onLocaleChange',\n            prio    : -1,\n            thisObj : me\n        });\n\n        GlobalEvents.ion({\n            theme   : 'onThemeChange',\n            thisObj : me\n        });\n\n        me.ion({\n            subGridExpand : 'onSubGridExpand',\n            prio          : -1,\n            thisObj       : me\n        });\n\n        // Buffered for scrolling, to be called\n        me.bufferedFixElementHeights = me.buffer('fixElementHeights', 350, me);\n\n        // Add the extra grid classes to the element\n        me.setGridClassList(me.element.classList);\n    }\n\n    onSubGridExpand() {\n        // Need to rerender all rows, because if the rows were rerendered (by adding a new column to another region for example)\n        // while the region was collapsed, cells in the region will be empty.\n        this.renderContents();\n    }\n\n    onBeforeLocaleChange() {\n        this._suspendRenderContentsOnColumnsChanged = true;\n    }\n\n    onLocaleChange() {\n        this._suspendRenderContentsOnColumnsChanged = false;\n        if (this.isPainted) {\n            this.renderContents();\n        }\n    }\n\n    finalizeInit() {\n        super.finalizeInit();\n\n        if (this.store.isLoading) {\n            // Maybe show loadmask if store is already loading when grid is constructed\n            this.onStoreBeforeRequest();\n        }\n    }\n\n    changeScrollManager(scrollManager, oldScrollManager) {\n        oldScrollManager?.destroy();\n\n        if (scrollManager) {\n            return ScrollManager.new({\n                element : this.element,\n                owner   : this\n            }, scrollManager);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Cleanup\n     * @private\n     */\n    doDestroy() {\n        const me = this;\n\n        me.detachListeners(storeListenerName);\n\n        me.scrollManager?.destroy();\n\n        for (const feature of Object.values(me.features)) {\n            feature.destroy?.();\n        }\n\n        me._focusedCell = null;\n        me.columns.destroy();\n\n        super.doDestroy();\n    }\n\n    /**\n     * Adds extra classes to the Grid element after it's been configured.\n     * Also iterates through features, thus ensuring they have been initialized.\n     * @private\n     */\n    setGridClassList(classList) {\n        const me = this;\n\n        Object.values(me.features).forEach(feature => {\n            if (feature.disabled) {\n                return;\n            }\n\n            let featureClass;\n\n            if (Object.prototype.hasOwnProperty.call(feature.constructor, 'featureClass')) {\n                featureClass = feature.constructor.featureClass;\n            }\n            else {\n                featureClass = `b-${(feature instanceof Base ? feature.$$name : feature.constructor.name)}`;\n            }\n\n            if (featureClass) {\n                classList.add(featureClass.toLowerCase());\n            }\n        });\n    }\n\n    //endregion\n\n    // region Feature events\n\n    // For documentation & typings purposes\n\n    /**\n     * Fires after a sub grid is collapsed.\n     * @event subGridCollapse\n     * @param {Grid.view.Grid} source The firing Grid instance\n     * @param {Grid.view.SubGrid} subGrid The sub grid instance\n     */\n\n    /**\n     * Fires after a sub grid is expanded.\n     * @event subGridExpand\n     * @param {Grid.view.Grid} source The firing Grid instance\n     * @param {Grid.view.SubGrid} subGrid The sub grid instance\n     */\n\n    /**\n     * Fires before a row is rendered.\n     * @event beforeRenderRow\n     * @param {Grid.view.Grid} source The firing Grid instance.\n     * @param {Grid.row.Row} row The row about to be rendered.\n     * @param {Core.data.Model} record The record for the row.\n     * @param {Number} recordIndex The zero-based index of the record.\n     */\n    /**\n     * Fires after a row is rendered.\n     * @event renderRow\n     * @param {Grid.view.Grid} source The firing Grid instance.\n     * @param {Grid.row.Row} row The row that has been rendered.\n     * @param {Core.data.Model} record The record for the row.\n     * @param {Number} recordIndex The zero-based index of the record.\n     */\n\n    //endregion\n\n    //region Grid template & elements\n\n    compose() {\n        const { autoHeight, enableSticky, enableTextSelection, fillLastColumn, positionMode, showDirty } = this;\n\n        return {\n            class : {\n                [`b-grid-${positionMode}`] : 1,\n                'b-enable-sticky'          : enableSticky,\n                'b-grid-notextselection'   : !enableTextSelection,\n                'b-autoheight'             : autoHeight,\n                'b-fill-last-column'       : fillLastColumn,\n                'b-show-dirty'             : showDirty\n            }\n        };\n    }\n\n    get cellCls() {\n        const { _cellCls } = this;\n\n        // It may have been merged to create a DomClassList, but 90% of the time will be a simple string.\n        return _cellCls.value || _cellCls;\n    }\n\n    get bodyConfig() {\n        const { autoHeight, hideFooters, hideHeaders } = this;\n\n        return {\n            reference : 'bodyElement',\n            className : {\n                'b-autoheight'      : autoHeight,\n                'b-grid-panel-body' : 1\n            },\n\n            // Only include aria-labelled-by if we have a header\n            [this.hasHeader ? 'ariaLabelledBy' : ''] : `${this.id}-panel-title`,\n\n            children : {\n                headerContainer : {\n                    tag             : 'header',\n                    role            : 'row',\n                    'aria-rowindex' : 1,\n                    className       : {\n                        'b-grid-header-container' : 1,\n                        'b-hidden'                : hideHeaders\n                    }\n                },\n                bodyContainer : {\n                    className : 'b-grid-body-container',\n                    tabIndex  : -1,\n\n                    // Explicitly needs this because it's in theory focusable\n                    // and DomSync won't add a default role\n                    role     : 'presentation',\n                    children : {\n                        verticalScroller : {\n                            className : 'b-grid-vertical-scroller'\n                        }\n                    }\n                },\n                virtualScrollers : {\n                    className : 'b-virtual-scrollers b-hide-display',\n                    style     : BrowserHelper.isFirefox && DomHelper.scrollBarWidth ? {\n                        height : `${DomHelper.scrollBarWidth}px`\n                    } : undefined\n                },\n                footerContainer : {\n                    tag       : 'footer',\n                    className : {\n                        'b-grid-footer-container' : 1,\n                        'b-hidden'                : hideFooters\n                    }\n                }\n            }\n        };\n    }\n\n    get contentElement() {\n        return this.verticalScroller;\n    }\n\n    get overflowElement() {\n        return this.bodyContainer;\n    }\n\n    updateHideFooters(hide) {\n        this.footerContainer?.classList[hide ? 'add' : 'remove']('b-hidden');\n    }\n\n    //endregion\n\n    //region Columns\n\n    changeColumns(columns, currentStore) {\n        const me = this;\n\n        // TODO: @johan: reconfiguring, ie changing whole column set should work.\n        // Empty, clear or destroy store\n        if (!columns && currentStore) {\n            // Destroy when Grid is destroyed, if we created the ColumnStore\n            if (me.isDestroying) {\n                currentStore.owner === me && currentStore.destroy();\n            }\n            // Clear if set to falsy value at some other point\n            else {\n                currentStore.removeAll();\n            }\n\n            return currentStore;\n        }\n\n        // Keep store if configured with one\n        if (columns.isStore) {\n            currentStore?.owner === me && currentStore.destroy();\n\n            columns.grid = me;\n\n            return columns;\n        }\n\n        // Given an array of columns\n        if (Array.isArray(columns)) {\n            // If we have a store, plug them in\n            if (currentStore) {\n\n                // Remove and destroy existing columns\n                // Filter columns to be destroyed for ability to reassign existing ones and not destroy them\n                me._suspendRenderContentsOnColumnsChanged = true;\n                const columnsToDestroy                    = currentStore.allRecords.filter(column => !columns.includes(column) && column !== me.checkboxSelectionColumn);\n                currentStore.remove(currentStore.allRecords, true);\n                columnsToDestroy.forEach(column => column.destroy?.());\n\n                currentStore.data                         = columns;\n                me._suspendRenderContentsOnColumnsChanged = false;\n\n                return currentStore;\n            }\n\n            // No store, use as data for a new store below\n            columns = { data : columns };\n        }\n\n        if (currentStore) {\n            throw new Error('Replacing ColumnStore is not supported');\n        }\n\n        // Assuming a store config object\n        return ColumnStore.new({\n            grid  : me,\n            owner : me\n        }, columns);\n    }\n\n    updateColumns(columns, was) {\n        const me = this;\n\n        super.updateColumns?.(columns, was);\n\n        // changes might be triggered when applying state, before grid is rendered\n        // TODO: have this run a lighter weight, non-destructive response.\n        // onColumnsChanged is a start, but lots of machinery is hooked to render.\n        columns.ion({\n            refresh : me.onColumnsChanged,\n            change  : me.onColumnsChanged,\n            sort    : me.onColumnsChanged,\n            thisObj : me\n        });\n        columns.ion(columnResizeEvent(me.onColumnsResized, me));\n\n        // Add touch class for touch devices\n        if (BrowserHelper.isTouchDevice) {\n            me.touch = true;\n\n            // apply touchConfig for columns that defines it\n            columns.forEach(column => {\n                const { touchConfig } = column;\n                if (touchConfig) {\n                    column.applyState(touchConfig);\n                }\n            });\n        }\n\n        me.bodyElement?.setAttribute('aria-colcount', columns.visibleColumns.length);\n    }\n\n    onColumnsChanged({ type, action, changes, record : column, records : addedColumns, isMove }) {\n        const isSingleFieldChange = changes && Object.keys(changes).length === 1;\n\n        if ((type === 'refresh' && action !== 'batch') ||\n            // Ignore the update of parentIndex following a column move (we redraw on the insert)\n            (action === 'update' && isSingleFieldChange && 'parentIndex' in changes)) {\n            return;\n        }\n\n        const\n            me = this,\n            {\n                columns,\n                checkboxSelectionColumn\n            }  = me;\n\n        // this.onPaint will handle changes caused by updateResponsive\n        if (!me.isPainted || (isMove && action === 'remove')) {\n            return;\n        }\n\n        // See if we have to create and add new SubGrids to accommodate new columns.\n        if (action === 'add') {\n            for (const column of addedColumns) {\n                const { region } = column;\n\n                // See if there's a home for this column, if not, add one\n                if (!me.subGrids[region]) {\n                    me.add(me.createSubGrid(region, me.subGridConfigs[region]));\n                }\n            }\n        }\n\n        if (action === 'update') {\n            // Just updating width is already handled in a minimal way.\n            if ('width' in changes || 'minWidth' in changes || 'maxWidth' in changes || 'flex' in changes) {\n                // Update any leaf columns that want to be repainted on size change\n                const region = column.region;\n\n                // We must not capture visibleColumns from the columns var\n                // at the top. It's a cached/recalculated value that we\n                // are invalidating in the body of this function.\n                columns.visibleColumns.forEach(col => {\n                    if (col.region === region && col.repaintOnResize) {\n                        me.refreshColumn(col);\n                    }\n                });\n\n                me.afterColumnsChange({ action, changes, column });\n                return;\n            }\n\n            // No repaint if only changing column text\n            if ('text' in changes && isSingleFieldChange) {\n                column.subGrid.refreshHeader();\n                return;\n            }\n\n            // Column toggled, need to recheck if any visible column has flex\n            if ('hidden' in changes) {\n                const subGrid = me.getSubGridFromColumn(column.id);\n                subGrid.header.fixHeaderWidths();\n                subGrid.footer.fixFooterWidths();\n                subGrid.updateHasFlex();\n            }\n        }\n\n        // Might have to add or remove subgrids when assigning a new set of columns or when changing region\n        if (action === 'dataset' || action === 'batch' || (action === 'update' && 'region' in changes)) {\n            const\n                regions             = columns.getDistinctValues('region'),\n                { toRemove, toAdd } = ArrayHelper.delta(regions, me.regions, true);\n\n            me.remove(toRemove.map(region => me.getSubGrid(region)));\n            me.add(toAdd.map(region => me.createSubGrid(region)));\n        }\n\n        // Check if checkbox selection column was removed, if so insert it back as the first column\n        if (checkboxSelectionColumn && !columns.includes(checkboxSelectionColumn)) {\n            // Insert the checkbox after any rownumber column. If not there, -1 means in at 0.\n            const insertIndex = columns.indexOf(columns.findRecord('type', 'rownumber')) + 1;\n\n            columns.insert(insertIndex, checkboxSelectionColumn, true);\n        }\n\n        if (!me._suspendRenderContentsOnColumnsChanged) {\n            me.renderContents();\n        }\n\n        // Columns which are flexed, but as part of a grouped column cannot just have their flex\n        // value reflected in the flex value of its cells. They are flexing a different available space.\n        // These have to be set to the exact width and kept synced.\n        me.syncFlexedSubCols();\n\n        // We must not capture visibleColumns from the columns var\n        // at the top. It's a cached/recalculated value that we must\n        // are invalidating in the body of this function.\n        me.bodyElement.setAttribute('aria-colcount', columns.visibleColumns.length);\n\n        me.afterColumnsChange({ action, changes, column });\n    }\n\n    onColumnsResized({ changes, record : column }) {\n        const me = this;\n\n        if (me.isConfiguring) {\n            return;\n        }\n\n        const\n            domWidth    = DomHelper.setLength(column.width),\n            domMinWidth = DomHelper.setLength(column.minWidth),\n            domMaxWidth = DomHelper.setLength(column.maxWidth),\n            subGrid     = me.getSubGridFromColumn(column.id);\n\n        // Let header and footer fix their own widths\n        subGrid.header.fixHeaderWidths();\n        subGrid.footer.fixFooterWidths();\n        subGrid.updateHasFlex();\n\n        // We can't apply flex from flexed subColums - they are flexing inside a different available width.\n        if (!(column.flex && column.childLevel)) {\n            if (!me.cellEls || column !== me.lastColumnResized) {\n                me.cellEls           = DomHelper.children(\n                    me.element,\n                    `.b-grid-cell[data-column-id=\"${column.id}\"]`\n                );\n                me.lastColumnResized = column;\n            }\n\n            for (const cell of me.cellEls) {\n                if ('width' in changes) {\n                    // https://app.assembla.com/spaces/bryntum/tickets/8041\n                    // Although header and footer elements must be sized using flex-basis to avoid the busting out problem,\n                    // grid cells MUST be sized using width since rows are absolutely positioned and will not cause the\n                    // busting out problem, and rows will not stretch to shrinkwrap the cells unless they are widthed with\n                    // width.\n                    cell.style.width = domWidth;\n                }\n\n                if ('minWidth' in changes) {\n                    cell.style.minWidth = domMinWidth;\n                }\n                if ('maxWidth' in changes) {\n                    cell.style.maxWidth = domMaxWidth;\n                }\n\n                if ('flex' in changes) {\n                    cell.style.flex = column.flex ?? null;\n                }\n            }\n        }\n\n        // If we're being driven by the ColumnResizer or other bulk column resizer (like\n        // ColumnAutoWidth), they will finish up with a call to afterColumnsResized.\n        if (!me.resizingColumns) {\n            me.afterColumnsResized(column);\n        }\n\n        // Columns which are flexed, but as part of a grouped column cannot just have their flex\n        // value reflected in the flex value of its cells. They are flexing a different available space.\n        // These have to be set to the exact width and kept synced.\n        me.syncFlexedSubCols();\n    }\n\n    afterColumnsResized(column) {\n        const me = this;\n\n        me.eachSubGrid(subGrid => {\n            // Only needed if the changed column is owned by the SubGrid\n            if (!subGrid.collapsed && (!column || column.region === subGrid.region)) {\n                subGrid.fixWidths();\n                subGrid.fixRowWidthsInSafariEdge();\n            }\n        });\n\n        me.lastColumnResized = me.cellEls = null;\n\n        // Buffer some expensive operations, like updating the fake scrollers\n        me.bufferedAfterColumnsResized(column);\n\n        // Must happen immediately, not inside the bufferedAfterColumnsResized\n        me.onHeightChange();\n    }\n\n    syncFlexedSubCols() {\n        const flexedSubCols = this.columns.query(c => c.flex && c.childLevel && c.element);\n\n        // Columns which are flexed, but as part of a grouped column cannot just have their flex\n        // value reflected in the flex value of its cells. They are flexing a different available space.\n        // These have to be set to the exact width and kept synced.\n        if (flexedSubCols) {\n            for (const column of flexedSubCols) {\n                const\n                    width   = column.element.getBoundingClientRect().width,\n                    cellEls = DomHelper.children(\n                        this.element,\n                        `.b-grid-cell[data-column-id=\"${column.id}\"]`\n                    );\n\n                for (const cell of cellEls) {\n                    cell.style.flex = `0 0 ${width}px`;\n                }\n            }\n        }\n    }\n\n    bufferedAfterColumnsResized(column) {\n        // Columns that allow their cell content to drive the row height requires a rerender after resize\n        if (this.columns.usesAutoHeight) {\n            this.refreshRows();\n        }\n\n        this.refreshVirtualScrollbars();\n        this.eachSubGrid(subGrid => {\n            // Only needed if the changed column is owned by the SubGrid\n            if (!subGrid.collapsed && (!column || column.region === subGrid.region)) {\n                subGrid.refreshFakeScroll();\n            }\n        });\n    }\n\n    bufferedElementResize() {\n        this.refreshRows();\n    }\n\n    onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {\n        // If a flexed subGrid would be flexed *down* by a width reduction, allow it\n        // to lay itself out before the refreshVirtualScrollbars called by GridElementEvents\n        // asks them whether they are overflowingHorizontally.\n        // This is to avoid an unecessary extra layout with a horizontal\n        // scrollbar which may be hidden when the subgrid adjusts itself when its ResizeMonitor\n        // notification arrives - they are delivered outermost->innermost, we we find out first here.\n        // When the actualResizeMonitor notification arrives, it will be a no-op.\n        if (DomHelper.scrollBarWidth && newWidth < oldWidth) {\n            this.eachSubGrid(subGrid => {\n                if (subGrid.flex) {\n                    subGrid.onElementResize(subGrid.element);\n                }\n            });\n        }\n\n        super.onInternalResize(...arguments);\n\n        // Columns that allow their cell content to drive the row height requires a rerender after element resize\n        if (this.isPainted && newWidth !== oldWidth && this.columns.usesFlexAutoHeight) {\n            this.bufferedElementResize();\n        }\n    }\n\n    //endregion\n\n    //region Rows\n\n    /**\n     * Get the topmost visible grid row\n     * @member {Grid.row.Row} firstVisibleRow\n     * @readonly\n     * @category Rows\n     */\n\n    /**\n     * Get the last visible grid row\n     * @member {Grid.row.Row} lastVisibleRow\n     * @readonly\n     * @category Rows\n     */\n\n    /**\n     * Get the Row that is currently displayed at top.\n     * @member {Grid.row.Row} topRow\n     * @readonly\n     * @category Rows\n     * @private\n     */\n\n    /**\n     * Get the Row currently displayed furthest down.\n     * @member {Grid.row.Row} bottomRow\n     * @readonly\n     * @category Rows\n     * @private\n     */\n\n    /**\n     * Get Row for specified record id.\n     * @function getRowById\n     * @param {Core.data.Model|String|Number} recordOrId Record id (or a record)\n     * @returns {Grid.row.Row} Found Row or null if record not rendered\n     * @category Rows\n     * @private\n     */\n\n    /**\n     * Returns top and bottom for rendered row or estimated coordinates for unrendered.\n     * @function getRecordCoords\n     * @param {Core.data.Model|String|Number} recordOrId Record or record id\n     * @returns {Object} Record bounds with format { top, height, bottom }\n     * @category Calculations\n     * @private\n     */\n\n    /**\n     * Get the Row at specified index. \"Wraps\" index if larger than available rows.\n     * @function getRow\n     * @param {Number} index\n     * @returns {Grid.row.Row}\n     * @category Rows\n     * @private\n     */\n\n    /**\n     * Get a Row for either a record, a record id or an HTMLElement\n     * @function getRowFor\n     * @param {HTMLElement|Core.data.Model|String|Number} recordOrId Record or record id or HTMLElement\n     * @returns {Grid.row.Row} Found Row or `null` if record not rendered\n     * @category Rows\n     */\n\n    /**\n     * Get a Row from an HTMLElement\n     * @function getRowFromElement\n     * @param {HTMLElement} element\n     * @returns {Grid.row.Row} Found Row or `null` if record not rendered\n     * @category Rows\n     * @private\n     */\n\n    changeRowManager(rowManager, oldRowManager) {\n        const me = this;\n\n        // Use row height from CSS if not specified in config. Did not want to turn this into a getter/setter for\n        // rowHeight since RowManager will plug its implementation into Grid when created below, and after initial\n        // configuration that is what should be used\n        if (!me._isRowMeasured) {\n            me.measureRowHeight();\n        }\n\n        oldRowManager?.destroy();\n\n        if (rowManager) {\n            // RowManager is a plugin, it is configured with its grid as its \"client\".\n            // It uses client.store as its record source.\n            const result = RowManager.new({\n                grid              : me,\n                rowHeight         : me.rowHeight,\n                rowScrollMode     : me.rowScrollMode || 'move',\n                autoHeight        : me.autoHeight,\n                fixedRowHeight    : me.fixedRowHeight,\n                internalListeners : {\n                    changeTotalHeight   : 'onRowManagerChangeTotalHeight',\n                    requestScrollChange : 'onRowManagerRequestScrollChange',\n                    thisObj             : me\n                }\n            }, rowManager);\n\n            // The grid announces row rendering to allow customization of rows.\n            me.relayEvents(result, ['beforeRenderRow', 'renderRow']);\n\n            // RowManager injects itself as a property into the grid so that the grid\n            // can reference it during RowManager's spin-up. We need to undo that now\n            // otherwise updaters will not run.\n            me._rowManager = null;\n            return result;\n        }\n    }\n\n    // Default implementation, documented in `defaultConfig`\n    getRowHeight(record) {\n        return record.rowHeight;\n    }\n\n    // Hook for features that need to alter the row height\n    processRowHeight(record, height) {}\n\n    //endregion\n\n    //region Store\n\n    /**\n     * Hooks up data store listeners\n     * @private\n     * @category Store\n     */\n    bindStore(store) {\n        const suffix = this.asyncEventSuffix;\n\n        store.ion({\n            name : storeListenerName,\n\n            [`refresh${suffix}`]   : 'onStoreDataChange',\n            [`add${suffix}`]       : 'onStoreAdd',\n            [`remove${suffix}`]    : 'onStoreRemove',\n            [`replace${suffix}`]   : 'onStoreReplace',\n            [`removeAll${suffix}`] : 'onStoreRemoveAll',\n            [`move${suffix}`]      : store.tree ? null : 'onFlatStoreMove',\n            change                 : 'relayStoreDataChange',\n\n            idChange      : 'onStoreRecordIdChange',\n            update        : 'onStoreUpdateRecord',\n            beforeRequest : 'onStoreBeforeRequest',\n            afterRequest  : 'onStoreAfterRequest',\n            exception     : 'onStoreException',\n            commit        : 'onStoreCommit',\n            thisObj       : this\n        });\n\n        super.bindStore(store);\n    }\n\n    unbindStore(oldStore) {\n        this.detachListeners(storeListenerName);\n\n        if (this.destroyStore) {\n            oldStore.destroy();\n        }\n    }\n\n    changeStore(store) {\n        if (store == null) {\n            return null;\n        }\n\n        if (typeof store === 'string') {\n            store = Store.getStore(store);\n        }\n\n        if (!store.isStore) {\n            store = ObjectHelper.assign({\n                data : this.data,\n                tree : Boolean(this.initialConfig.features?.tree)\n            }, store);\n\n            if (!store.data) {\n                delete store.data;\n            }\n\n            if (!store.modelClass) {\n                store.modelClass = GridRowModel;\n            }\n\n            store = new (store.readUrl ? AjaxStore : Store)(store);\n        }\n        //<debug>\n        else if (store.modelClass !== GridRowModel &&\n            !Object.prototype.isPrototypeOf.call(GridRowModel, store.modelClass) &&\n            !this.disableGridRowModelWarning) {\n            console.warn('It is recommended to use a subclass of GridRowModel for data in Grids store, for better feature support');\n        }\n        //</debug>\n\n        return store;\n    }\n\n    updateStore(store, was) {\n        const me = this;\n\n        super.updateStore?.(store, was);\n\n        if (was) {\n            me.unbindStore(was);\n        }\n\n        if (store) {\n            // Deselect all rows when replacing the store, otherwise selection retains old store\n            if (was) {\n                me.deselectAll();\n            }\n            me.bindStore(store);\n        }\n\n        me.trigger('bindStore', { store, oldStore : was });\n\n        // Changing store when painted -> refresh rows to reflect new data\n        if (!me.isDestroying && me.isPainted && !me.refreshSuspended) {\n            me._rowManager?.reinitialize();\n        }\n    }\n\n    /**\n     * Rerenders a cell if a record is updated in the store\n     * @private\n     * @category Store\n     */\n    onStoreUpdateRecord({ source : store, record, changes }) {\n        const me = this;\n\n        if (me.refreshSuspended) {\n            return;\n        }\n\n        if (me.forceFullRefresh) {\n            // flagged to need full refresh (probably from using GroupSummary)\n            me.rowManager.refresh();\n\n            me.forceFullRefresh = false;\n        }\n        else {\n            let row;\n            // Search for old row if id was changed\n            if (record.isFieldModified('id')) {\n                row = me.getRowFor(record.meta.modified.id);\n            }\n\n            row = row || me.getRowFor(record);\n            // not rendered, bail out\n            if (!row) {\n                return;\n            }\n\n            // We must refresh the full row if it's a special row which has signalled\n            // an update because it has no cells.\n            if (me.fullRowRefresh || record.isSpecialRow) {\n                const index = store.indexOf(record);\n                if (index !== -1) {\n                    row.render(index, record);\n                }\n            }\n            else {\n                me.columns.visibleColumns.forEach(column => {\n                    const\n                        field  = column.field,\n                        isSafe = column.constructor.simpleRenderer && !(Object.prototype.hasOwnProperty.call(column.data, 'renderer'));\n\n                    // If there's a  non-safe renderer, that is a renderer which draws values from elsewhere\n                    // than just its configured field, that column must be refreshed on every record update.\n                    // Obviously, if the column's configured field is changed that also means it's refreshed.\n                    if (!isSafe || changes[field]) {\n                        const cellElement = row.getCell(field);\n                        if (cellElement) {\n                            row.renderCell(cellElement);\n                        }\n                    }\n                });\n            }\n        }\n    }\n\n    refreshFromRowOnStoreAdd(row, context) {\n        const\n            me             = this,\n            { rowManager } = me;\n\n        rowManager.renderFromRow(row);\n        rowManager.trigger('changeTotalHeight', { totalHeight : rowManager.totalHeight });\n\n        // First record? Also update fake scrollers\n        // TODO: Consider making empty grid scrollable to not have to do this\n        if (me.store.count === 1) {\n            me.callEachSubGrid('refreshFakeScroll');\n        }\n    }\n\n    onMaskAutoClose(mask) {\n        super.onMaskAutoClose(mask);\n\n        this.toggleEmptyText();\n    }\n\n    /**\n     * Refreshes rows when data is added to the store\n     * @private\n     * @category Store\n     */\n    onStoreAdd({ source : store, records, index, oldIndex, isChild, oldParent, parent, isMove, isExpandAll }) {\n        // Do not react if the content has not been rendered\n        if (!this.isPainted || isExpandAll || this.refreshSuspended) {\n            return;\n        }\n\n        // If we move records check if some of their old parents is expanded\n        const hasExpandedOldParent = isMove && records.some(record => {\n            if (isMove[record.id]) {\n                // When using TreeGroup there won't be an old parent\n                const oldParent = store.getById(record.meta.modified.parentId);\n\n                return oldParent?.isExpanded(store) && oldParent?.ancestorsExpanded(store);\n            }\n        });\n\n        // If it's the addition of a child to a collapsed zone (and old parents are also collapsed), the UI does not change.\n        if (isChild && !records[0].ancestorsExpanded(store) && !hasExpandedOldParent) {\n            // BUT it might change if parent had no children (expander made invisible) and it gets children added\n            if (!parent.isLeaf) {\n                const parentRow = this.rowManager.getRowById(parent);\n                if (parentRow) {\n                    this.rowManager.renderRows([parentRow]);\n                }\n            }\n\n            return;\n        }\n\n        this.rowManager.calculateRowCount(false, true, true);\n\n        // When store is filtered need to update the index value\n        if (store.isFiltered) {\n            index = store.indexOf(records[0]);\n        }\n\n        const\n            me             = this,\n            { rowManager } = me,\n            {\n                topIndex,\n                rows,\n                rowCount\n            }              = rowManager,\n            bottomIndex    = rowManager.topIndex + rowManager.rowCount - 1,\n            dataStart      = index,\n            dataEnd        = index + records.length - 1,\n            atEnd          = bottomIndex >= store.count - records.length - 1;\n\n        // When moving a node within a tree we might need the redraw to include its old parent and its children. Not worth\n        // the complexity of trying to do a partial render for this, rerender all rows to be safe.\n        // Moving records within a flat store is handled elsewhere, in onFlatStoreMove\n        // TODO: Moving within a tree should also trigger 'move' (https://app.assembla.com/spaces/bryntum/tickets/7270)\n        if (oldParent || oldIndex > -1 || (isChild && isMove)) {\n            rowManager.refresh();\n        }\n        // Added block starts in our visible block. Render from there downwards.\n        else if (dataStart >= topIndex && dataStart < topIndex + rowCount) {\n            me.refreshFromRowOnStoreAdd(rows[dataStart - topIndex], ...arguments);\n        }\n        // Added block ends in our visible block, render block\n        else if (dataEnd >= topIndex && dataEnd < topIndex + rowCount) {\n            rowManager.refresh();\n        }\n        // If added block is outside of the visible area, no visible change\n        // but potentially a change in total dataset height.\n        else {\n            // If we are against the end of the dataset, and have appended records\n            // ensure they are rendered below\n            if (atEnd && index > bottomIndex) {\n                rowManager.fillBelow(me._scrollTop || 0);\n            }\n\n            rowManager.estimateTotalHeight(true);\n        }\n    }\n\n    /**\n     * Responds to exceptions signalled by the store\n     * @private\n     * @category Store\n     */\n    onStoreException({ action, type, response, exceptionType, error }) {\n        const me = this;\n\n        let message;\n\n        switch (type) {\n            case 'server':\n                message = response.message || me.L('L{unspecifiedFailure}');\n                break;\n            case 'exception':\n                message = exceptionType === 'network' ? me.L('L{networkFailure}') : (error?.message || response?.parsedJson?.message || me.L('L{parseFailure}'));\n                break;\n        }\n\n        // eslint-disable-next-line\n        me.applyMaskError(\n            `<div class=\"b-grid-load-failure\">\n                <div class=\"b-grid-load-fail\">${me.L(action === 'read' ? 'L{loadFailedMessage}' : 'L{syncFailedMessage}')}</div>\n                ${response?.url ? `<div class=\"b-grid-load-fail\">${response.url}</div>` : ''}\n                <div class=\"b-grid-load-fail\">${me.L('L{serverResponse}')}</div>\n                <div class=\"b-grid-load-fail\">${message}</div>\n            </div>`);\n    }\n\n    /**\n     * Refreshes rows when data is changed in the store\n     * @private\n     * @category Store\n     */\n    onStoreDataChange({ action, changes, source : store, syncInfo }) {\n        if (this.refreshSuspended || !this.rowManager) {\n            return;\n        }\n\n        const\n            me                 = this,\n            isGroupFieldChange = store.isGrouped && changes && store.groupers.some(grouper => grouper.field in changes);\n\n        // If the next mixin up the inheritance chain has an implementation, call it\n        super.onStoreDataChange?.(...arguments);\n\n        // Re-render what's in view when sync removing above the threshold, to maintain scroll position\n        if (action === 'batch' && syncInfo?.removed?.length) {\n            me.rowManager.renderFromRow(me.topRow);\n        }\n        else {\n            // If it's new data, the old calculation is invalidated.\n            if (action === 'dataset') {\n                me.rowManager.clearKnownHeights();\n            }\n            // No need to rerender if it's a change of the value of the group field which\n            // will be responded to by StoreGroup\n            if (me.isPainted && !isGroupFieldChange) {\n                // Optionally scroll to top if setting new data or is filtering based on preserveScrollOnDatasetChange setting\n                me.renderRows(Boolean(!(action in datasetReplaceActions) || me.preserveScrollOnDatasetChange));\n            }\n        }\n\n        me.toggleEmptyText();\n    }\n\n    /**\n     * The hook is called when the id of a record has changed.\n     * @private\n     * @category Store\n     */\n    onStoreRecordIdChange() {\n        // If the next mixin up the inheritance chain has an implementation, call it\n        super.onStoreRecordIdChange && super.onStoreRecordIdChange(...arguments);\n    }\n\n    /**\n     * Shows a load mask while the connected store is loading\n     * @private\n     * @category Store\n     */\n    onStoreBeforeRequest() {\n        this.applyLoadMask();\n    }\n\n    /**\n     * Hides load mask after a load request ends either in success or failure\n     * @private\n     * @category Store\n     */\n    onStoreAfterRequest(event) {\n        if (this.loadMask && !event.exception) {\n            this.masked = null;\n            this.toggleEmptyText();\n        }\n    }\n\n    needsFullRefreshOnStoreRemove({ isCollapse }) {\n        const features = this._features;\n\n        return (features?.group && !features.group.disabled) ||\n            (features?.groupSummary && !features.groupSummary.disabled) ||\n            // Need to redraw parents when children are removed since they might be converted to leaves\n            (this.store.tree && !isCollapse && this.store.modelClass.convertEmptyParentToLeaf);\n    }\n\n    /**\n     * Animates removal of record.\n     * @private\n     * @category Store\n     */\n    onStoreRemove({ records, isCollapse, isChild, isMove, isCollapseAll }) {\n        // Do not react if the content has not been rendered,\n        // or if it is a move, which will be handled by onStoreAdd\n        if (!this.isPainted || isMove || isCollapseAll) {\n            return;\n        }\n\n        // GridSelection mixin does its job on records removing\n        super.onStoreRemove && super.onStoreRemove(...arguments);\n\n        const\n            me             = this,\n            { rowManager } = me;\n\n        // Remove cached heights\n        rowManager.invalidateKnownHeight(records);\n\n        if (me.animateRemovingRows && !isCollapse && !isChild) {\n            // Gather all visible rows which need to be removed.\n            const rowsToRemove = records.reduce((result, record) => {\n                const row = rowManager.getRowById(record.id);\n                row && result.push(row);\n                return result;\n            }, []);\n\n            if (rowsToRemove.length) {\n                const topRow = rowsToRemove[0];\n\n                me.isAnimating = true;\n\n                // As soon as first row has disappeared, rerender the view\n                EventHelper.onTransitionEnd({\n                    element  : topRow._elementsArray[0],\n                    property : 'left',\n\n                    // Detach listener after timeout even if event wasn't fired\n                    duration : me.transitionDuration,\n                    thisObj  : me,\n                    handler  : () => {\n                        me.isAnimating = false;\n\n                        rowsToRemove.forEach(row => !row.isDestroyed && row.removeCls('b-removing'));\n                        rowManager.refresh();\n\n                        // undocumented internal event for scheduler\n                        me.trigger('rowRemove');\n                        me.afterRemove(arguments[0]);\n                    }\n                });\n\n                rowsToRemove.forEach(row => row.addCls('b-removing'));\n                return;\n            }\n        }\n\n        // Cannot do an update from the affected row and down here. Since group headers might be affected by\n        // removing rows we need a full refresh\n        if (me.needsFullRefreshOnStoreRemove(...arguments)) {\n            rowManager.refresh();\n            me.afterRemove(arguments[0]);\n        }\n        else {\n            const oldTopIndex = rowManager.topIndex;\n\n            // Potentially remove rows and change dataset height\n            rowManager.calculateRowCount(false, true, true);\n\n            // If collapsing lead to rows \"shifting up\" to fit in available rows, we have to rerender from top\n            if (rowManager.topIndex !== oldTopIndex) {\n                rowManager.renderFromRow(rowManager.topRow);\n            }\n            else {\n                const { rows } = rowManager, topRowIndex = records.reduce((result, record) => {\n                    const row = rowManager.getRowById(record.id);\n                    if (row) {\n                        // Rows are repositioned in the array, it matches visual order. Need to find actual index in it\n                        result = Math.min(result, rows.indexOf(row));\n                    }\n                    return result;\n                }, rows.length);\n\n                // If there were rows below which have moved up into place\n                // then repurpose them with their new records\n                if (rows[topRowIndex]) {\n                    !me.refreshSuspended && rowManager.renderFromRow(rows[topRowIndex]);\n                }\n                // If nothing to render below, just update dataset height\n                else {\n                    rowManager.trigger('changeTotalHeight', { totalHeight : rowManager.totalHeight });\n                }\n            }\n            me.trigger('rowRemove', { isCollapse });\n            me.afterRemove(arguments[0]);\n        }\n    }\n\n    onFlatStoreMove({ from, to }) {\n        const\n            { rowManager }       = this,\n            {\n                topIndex,\n                rowCount\n            }                    = rowManager,\n            [dataStart, dataEnd] = [from, to].sort((a, b) => a - b);\n\n        // Changed block starts in our visible block. Render from there downwards.\n        if (dataStart >= topIndex && dataStart < topIndex + rowCount) {\n            rowManager.renderFromRow(rowManager.rows[dataStart - topIndex]);\n        }\n        // Changed block ends in our visible block, render block\n        else if (dataEnd >= topIndex && dataEnd < topIndex + rowCount) {\n            rowManager.refresh();\n        }\n        // If changed block is outside of the visible area, this is a no-op\n    }\n\n    onStoreReplace({ records, all }) {\n        const { rowManager } = this;\n\n        if (all) {\n            rowManager.clearKnownHeights();\n            rowManager.refresh();\n        }\n        else {\n            const rows = records.reduce((rows, [, record]) => {\n                const row = this.getRowFor(record);\n                if (row) {\n                    rows.push(row);\n                }\n                return rows;\n            }, []);\n\n            // Heights will be stored on render, but some records might be out of view -> have to invalidate separately\n            rowManager.invalidateKnownHeight(records);\n\n            rowManager.renderRows(rows);\n        }\n    }\n\n    relayStoreDataChange(event) {\n        this.ariaElement.setAttribute('aria-rowcount', this.store.count + 1);\n\n        /**\n         * Fired when data in the store changes.\n         *\n         * Basically a relayed version of the store's own change event, decorated with a `store` property.\n         * See the {@link Core.data.Store#event-change store change event} documentation for more information.\n         *\n         * @event dataChange\n         * @param {Grid.view.Grid} source Owning grid\n         * @param {Core.data.Store} store The originating store\n         * @param {'remove'|'removeAll'|'add'|'updatemultiple'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action\n         * Name of action which triggered the change. May be one of:\n         * * `'remove'`\n         * * `'removeAll'`\n         * * `'add'`\n         * * `'updatemultiple'`\n         * * `'clearchanges'`\n         * * `'filter'`\n         * * `'update'`\n         * * `'dataset'`\n         * * `'replace'`\n         * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)\n         * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`\n         * @param {Object} changes Passed for the `'update'` action, info on which record fields changed\n         */\n        if (!this.project) {\n            return this.trigger('dataChange', { ...event, store : event.source, source : this });\n        }\n    }\n\n    /**\n     * Rerenders grid when all records have been removed\n     * @private\n     * @category Store\n     */\n    onStoreRemoveAll() {\n        // GridSelection mixin does its job on records removing\n        super.onStoreRemoveAll && super.onStoreRemoveAll(...arguments);\n\n        if (this.isPainted) {\n            this.rowManager.clearKnownHeights();\n            this.renderRows(false);\n            this.toggleEmptyText();\n        }\n    }\n\n    // Refresh dirty cells on commit\n    onStoreCommit({ changes }) {\n        if (this.showDirty && changes.modified.length) {\n            const rows = [];\n\n            changes.modified.forEach(record => {\n                const row = this.rowManager.getRowFor(record);\n                row && rows.push(row);\n            });\n\n            this.rowManager.renderRows(rows);\n        }\n    }\n\n    // Documented with config\n    get data() {\n        if (this._store) {\n            return this._store.records;\n        }\n        else {\n            return this._data;\n        }\n    }\n\n    set data(data) {\n        if (this._store) {\n            this._store.data = data;\n        }\n        else {\n            this._data = data;\n        }\n    }\n\n    //endregion\n\n    //region Context menu items\n\n    /**\n     * Populates the header context menu. Chained in features to add menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateHeaderMenu({ column, items }) {\n        const\n            me                    = this,\n            { subGrids, regions } = me,\n            { parent }            = column;\n\n        let first = true;\n\n        Object.entries(subGrids).forEach(([region, subGrid]) => {\n            // If SubGrid is configured with a sealed column set, do not allow moving into it\n            if (subGrid.sealedColumns) {\n                return;\n            }\n\n            if (\n                column.draggable &&\n                region !== column.region &&\n                (!parent && subGrids[column.region].columns.count > 1 || parent && parent.children.length > 1)\n            ) {\n                const\n                    preceding = subGrid.element.compareDocumentPosition(subGrids[column.region].element) === document.DOCUMENT_POSITION_PRECEDING,\n                    moveRight = me.rtl ? !preceding : preceding,\n                    // With 2 regions, use Move left, Move right. With multiple, include region name\n                    text      = regions.length > 2\n                        ? me.L('L{moveColumnTo}', me.optionalL(region))\n                        : me.L(moveRight ? 'L{moveColumnRight}' : 'L{moveColumnLeft}');\n\n                items[`${region}Region`] = {\n                    targetSubGrid : region,\n                    text,\n                    icon          : 'b-fw-icon b-icon-column-move-' + (moveRight ? 'right' : 'left'),\n                    separator     : first,\n                    onItem        : ({ item }) => {\n                        column.traverse(col => col.region = region);\n\n                        // Changing region will move the column to the correct SubGrid, but we want it to go last\n                        me.columns.insert(me.columns.indexOf(subGrids[item.targetSubGrid].columns.last) + 1, column);\n\n                        me.scrollColumnIntoView(column);\n                    }\n                };\n\n                first = false;\n            }\n        });\n    }\n\n    /**\n     * Populates the cell context menu. Chained in features to add menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Core.data.Model} options.record Record for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateCellMenu({ record, items }) {}\n\n    getColumnDragToolbarItems(column, items) {\n        return items;\n    }\n\n    //endregion\n\n    //region Getters\n\n    normalizeCellContext(cellContext) {\n        const\n            grid        = this,\n            { columns } = grid;\n\n        // Already have a Location\n        if (cellContext.isLocation) {\n            return cellContext;\n        }\n\n        // Create immutable Location object encapsulating the passed object.\n        if (cellContext.isModel) {\n            return new Location({\n                grid,\n                id       : cellContext.id,\n                columnId : columns.visibleColumns[0].id\n            });\n        }\n        return new Location(ObjectHelper.assign({ grid }, cellContext));\n    }\n\n    // TODO: move to RowManager? Or create a CellManager?\n    /**\n     * Returns a cell if rendered or null if not found.\n     * @param {LocationConfig} cellContext A cell location descriptor\n     * @returns {HTMLElement|null}\n     * @category Getters\n     */\n    getCell(cellContext) {\n        const\n            { store, columns } = this,\n            { visibleColumns } = this.columns,\n            rowIndex           = !isNaN(cellContext.row) ? cellContext.row : !isNaN(cellContext.rowIndex) ? cellContext.rowIndex : store.indexOf(cellContext.record || cellContext.id),\n            columnIndex        = !isNaN(cellContext.column) ? cellContext.column : !isNaN(cellContext.columnIndex) ? cellContext.columnIndex : visibleColumns.indexOf(cellContext.column || columns.getById(cellContext.columnId) || columns.get(cellContext.field) || visibleColumns[0]);\n\n        // Only return cell for valid address.\n        // This code is more strict than Location which attempts to find the closest existing cell.\n        // Here we MUST only return a cell if the passed context is fully valid.\n        return rowIndex > -1 && rowIndex < store.count && columnIndex > -1 && columnIndex < visibleColumns.length && this.normalizeCellContext(cellContext).cell || null;\n    }\n\n    //TODO: Should move to ColumnManager? Or Header?\n    /**\n     * Returns the header element for the column\n     * @param {String|Number|Grid.column.Column} columnId or Column instance\n     * @returns {HTMLElement} Header element\n     * @category Getters\n     */\n    getHeaderElement(columnId) {\n        if (columnId.isModel) {\n            columnId = columnId.id;\n        }\n\n        return this.fromCache(`.b-grid-header[data-column-id=\"${columnId}\"]`);\n    }\n\n    getHeaderElementByField(field) {\n        const column = this.columns.get(field);\n\n        return column ? this.getHeaderElement(column) : null;\n    }\n\n    /**\n     * Body height\n     * @member {Number}\n     * @readonly\n     * @category Layout\n     */\n    get bodyHeight() {\n        return this._bodyHeight;\n    }\n\n    /**\n     * Header height\n     * @member {Number}\n     * @readonly\n     * @category Layout\n     */\n    get headerHeight() {\n        const me = this;\n        // measure header if rendered and not stored\n        if (me.isPainted && !me._headerHeight) {\n            me._headerHeight = me.headerContainer.offsetHeight;\n        }\n\n        return me._headerHeight;\n    }\n\n    /**\n     * Footer height\n     * @member {Number}\n     * @readonly\n     * @category Layout\n     */\n    get footerHeight() {\n        const me = this;\n\n        // measure footer if rendered and not stored\n        if (me.isPainted && !me._footerHeight) {\n            me._footerHeight = me.footerContainer.offsetHeight;\n        }\n\n        return me._footerHeight;\n    }\n\n    get isTreeGrouped() {\n        return Boolean(this.features.treeGroup?.isGrouped);\n    }\n\n    /**\n     * Searches up from the specified element for a grid row and returns the record associated with that row.\n     * @param {HTMLElement} element Element somewhere within a row or the row container element\n     * @returns {Core.data.Model} Record for the row\n     * @category Getters\n     */\n    getRecordFromElement(element) {\n        const el = element.closest('.b-grid-row');\n\n        if (!el) return null;\n\n        return this.store.getAt(el.dataset.index);\n    }\n\n    /**\n     * Searches up from specified element for a grid cell or an header and returns the column which the cell belongs to\n     * @param {HTMLElement} element Element somewhere in a cell\n     * @returns {Grid.column.Column} Column to which the cell belongs\n     * @category Getters\n     */\n    getColumnFromElement(element) {\n        const cell = element.closest('.b-grid-cell, .b-grid-header');\n        if (!cell) return null;\n\n        if (cell.matches('.b-grid-header')) {\n            return this.columns.getById(cell.dataset.columnId);\n        }\n\n        const cellData = DomDataStore.get(cell);\n        return this.columns.getById(cellData.columnId);\n    }\n\n    // Only added for type checking, since it seems common to get it wrong in react/angular\n    updateAutoHeight(autoHeight) {\n        ObjectHelper.assertBoolean(autoHeight, 'autoHeight');\n    }\n\n    // Documented under configs\n    get columnLines() {\n        return this._columnLines;\n    }\n\n    set columnLines(columnLines) {\n        ObjectHelper.assertBoolean(columnLines, 'columnLines');\n\n        DomHelper.toggleClasses(this.element, 'b-no-column-lines', !columnLines);\n\n        this._columnLines = columnLines;\n    }\n\n    get keyMapElement() {\n        return this.bodyElement;\n    }\n\n    //endregion\n\n    //region Fix width & height\n\n    /**\n     * Sets widths and heights for headers, rows and other parts of the grid as needed\n     * @private\n     * @category Width & height\n     */\n    fixSizes() {\n        // subGrid width\n        this.callEachSubGrid('fixWidths');\n\n        // Get leaf headers.\n        const colHeaders = this.headerContainer.querySelectorAll('.b-grid-header.b-depth-0');\n\n        // Update leaf headers' ariaColIndex\n        for (let i = 0, { length } = colHeaders; i < length; i++) {\n            colHeaders[i].setAttribute('aria-colindex', i + 1);\n        }\n    }\n\n    onRowManagerChangeTotalHeight({ totalHeight, immediate }) {\n        return this.refreshTotalHeight(totalHeight, immediate);\n    }\n\n    /**\n     * Makes height of vertical scroller match estimated total height of grid. Called when scrolling vertically and\n     * when showing/hiding rows.\n     * @param {Number} [height] Total height supplied by RowManager\n     * @param {Boolean} [immediate] Flag indicating if buffered element sizing should be bypassed\n     * @private\n     * @category Width & height\n     */\n    refreshTotalHeight(height = this.rowManager.totalHeight, immediate = false) {\n        const me = this;\n\n        // Veto change of estimated total height while rendering rows or if triggered while in a hidden state\n        if (me.renderingRows || !me.isVisible) {\n            return false;\n        }\n\n        const\n            scroller     = me.scrollable,\n            delta        = Math.abs(me.virtualScrollHeight - height),\n            clientHeight = me._bodyRectangle.height,\n            newMaxY      = height - clientHeight;\n\n        if (delta) {\n            const\n                // We must update immediately if we are nearing the end of the scroll range.\n                isCritical = (newMaxY - me._scrollTop < clientHeight * 2) ||\n                    // Or if we have scrolled pass visual height\n                    (me._verticalScrollHeight && (me._verticalScrollHeight - clientHeight < me._scrollTop));\n\n            // Update the true scroll range using the scroller. This will not cause a repaint.\n            scroller.scrollHeight = me.virtualScrollHeight = height;\n\n            // If we are scrolling, put this off because it causes\n            // a full document layout and paint.\n            // Do not buffer calls for not yet painted grid\n            if (me.isPainted && (me.scrolling && !isCritical || delta < 100) && !immediate) {\n                me.bufferedFixElementHeights();\n            }\n            else {\n                me.virtualScrollHeightDirty && me.virtualScrollHeightDirty();\n                me.bufferedFixElementHeights.cancel();\n                me.fixElementHeights();\n            }\n        }\n    }\n\n    fixElementHeights() {\n        const\n            me         = this,\n            height     = me.virtualScrollHeight,\n            heightInPx = `${height}px`;\n\n        me._verticalScrollHeight         = height;\n        me.verticalScroller.style.height = heightInPx;\n        me.virtualScrollHeightDirty      = false;\n\n        if (me.autoHeight) {\n            me.bodyContainer.style.height = heightInPx;\n            me._bodyHeight                = height;\n            me.refreshBodyRectangle();\n        }\n\n        me.refreshVirtualScrollbars();\n    }\n\n    refreshBodyRectangle() {\n        return this._bodyRectangle = Rectangle.client(this.bodyContainer);\n    }\n\n    //endregion\n\n    //region Scroll & virtual rendering\n\n    set scrolling(scrolling) {\n        this._scrolling = scrolling;\n    }\n\n    get scrolling() {\n        return this._scrolling;\n    }\n\n    /**\n     * Activates automatic scrolling of a subGrid when mouse is moved closed to the edges. Useful when dragging DOM\n     * nodes from outside this grid and dropping on the grid.\n     * @param {Grid.view.SubGrid|String|Grid.view.SubGrid[]|String[]} subGrid A subGrid instance or its region name or\n     * an array of either\n     * @category Scrolling\n     */\n    enableScrollingCloseToEdges(subGrids) {\n        this.scrollManager.startMonitoring({\n            scrollables : [\n                {\n                    element   : this.scrollable.element,\n                    direction : 'vertical'\n                },\n                ...ArrayHelper.asArray(subGrids || []).map(subGrid => (\n                    { element : (typeof subGrid === 'string' ? this.subGrids[subGrid] : subGrid).scrollable.element }\n                ))\n            ],\n            direction : 'horizontal'\n        });\n    }\n\n    /**\n     * Deactivates automatic scrolling of a subGrid when mouse is moved closed to the edges\n     * @param {Grid.view.SubGrid|String|Grid.view.SubGrid[]|String[]} subGrid A subGrid instance or its region name or\n     * an array of either\n     * @category Scrolling\n     */\n    disableScrollingCloseToEdges(subGrids) {\n        this.scrollManager.stopMonitoring([\n            this.scrollable.element,\n            ...ArrayHelper.asArray(subGrids || []).map(subGrid => (typeof subGrid === 'string' ? this.subGrids[subGrid] : subGrid).element)\n        ]);\n    }\n\n    /**\n     * Responds to request from RowManager to adjust scroll position. Happens when jumping to a scroll position with\n     * variable row height.\n     * @param {Number} bottomMostRowY\n     * @private\n     * @category Scrolling\n     */\n    onRowManagerRequestScrollChange({ bottom }) {\n        this.scrollable.y = bottom - this.bodyHeight;\n    }\n\n    /* <remove-on-release> */\n    runPerformanceTest(count = 5, direction = 'vertical') {\n        const\n            me      = this,\n            body    = me.bodyContainer,\n            fpsList = me.fpsList || (me.fpsList = []);\n\n        me.frameCount = 0;\n\n        if (!me.testPerformance) {\n            me.testPerformance = direction;\n        }\n\n        me.setTimeout(() => {\n            const start = performance.now();\n\n            let scrollSpeed = 5,\n                direction   = 1;\n\n            const scrollInterval = me.setInterval(() => {\n                scrollSpeed = scrollSpeed + 5;\n                //if (scrollSpeed > 30) scrollSpeed = 0;\n\n                body.scrollTop += (10 + Math.floor(scrollSpeed)) * direction;\n\n                if (direction === 1 && body.scrollTop > 30000) {\n                    direction   = -1;\n                    scrollSpeed = 5;\n                }\n\n                if (direction === -1 && body.scrollTop <= 0) {\n                    const\n                        done         = performance.now(),\n                        elapsed      = done - start,\n                        timePerFrame = elapsed / me.frameCount;\n\n                    let fps = 1000 / timePerFrame;\n\n                    fps = Math.round(fps * 10) / 10;\n\n                    clearInterval(scrollInterval);\n\n                    //console.log(me.positionMode, me.rowScrollMode, fps + 'fps');\n                    fpsList.push(fps);\n\n                    if (fpsList.length < count) {\n                        me.runPerformanceTest(count);\n                    }\n                    else {\n                        console.log(fpsList, fpsList.reduce((result, fps) => result += fps / fpsList.length, 0));\n                        me.fpsList.length = 0;\n                    }\n                }\n            }, 0);\n        }, fpsList.length ? 0 : 2500);\n    }\n\n    /* </remove-on-release> */\n\n    /**\n     * Scroll syncing for normal headers & grid + triggers virtual rendering for vertical scroll\n     * @private\n     * @fires scroll\n     * @category Scrolling\n     */\n    initScroll() {\n        const\n            me             = this,\n            { scrollable } = me;\n\n        // This method may be called early, before render calls it, so ensure that it's\n        // only executed once.\n        if (!me.scrollInitialized) {\n            me.scrollInitialized = true;\n\n            // Allows FF to dynamically track scrollbar state change by reacting to content height changes.\n            // Remove when https://bugzilla.mozilla.org/show_bug.cgi?id=1733042 is fixed\n            scrollable.contentElement = me.contentElement;\n\n            scrollable.ion({\n                scroll    : 'onGridVerticalScroll',\n                scrollend : 'onGridVerticalScrollEnd',\n                thisObj   : me\n            });\n\n            me.callEachSubGrid('initScroll');\n\n            //<debug>\n            if (me.testPerformance === 'vertical') {\n                me.runPerformanceTest();\n            }\n            //</debug>\n\n            // Fixes scroll freezing bug on iPad by putting scroller in its own layer\n            if (BrowserHelper.isMobileSafari) {\n                scrollable.element.style.transform = 'translate3d(0, 0, 0)';\n            }\n        }\n    }\n\n    onGridVerticalScroll({ source : scrollable }) {\n        const\n            me                = this,\n            { y : scrollTop } = scrollable;\n\n        // Was getting scroll events in FF where scrollTop was unchanged, ignore those\n        if (scrollTop !== me._scrollTop) {\n            me._scrollTop = scrollTop;\n\n            if (!me.scrolling) {\n                me.scrolling = true;\n                // Vertical scroll may trigger resize if row height is variable\n                me.eachSubGrid(s => s.suspendResizeMonitor = true);\n            }\n\n            /* <remove-on-release> */\n            if (me.testPerformance === 'vertical') {\n                me.frameCount++;\n            }\n            /* </remove-on-release> */\n\n            me.rowManager.updateRenderedRows(scrollTop);\n\n            // Hook for features that need to react to scroll\n            me.afterScroll({ scrollTop });\n\n            /**\n             * Grid has scrolled vertically\n             * @event scroll\n             * @param {Grid.view.Grid} source The firing Grid instance.\n             * @param {Number} scrollTop The vertical scroll position.\n             */\n            me.trigger('scroll', { scrollTop });\n        }\n    }\n\n    onGridVerticalScrollEnd() {\n        this.scrolling = false;\n        this.eachSubGrid(s => s.suspendResizeMonitor = false);\n    }\n\n    // TODO: rename to scrollRecordIntoView? Or have an alias?\n    /**\n     * Scrolls a row into view. If row isn't rendered it tries to calculate position. Accepts the {@link ScrollOptions}\n     * `column` property\n     * @param {Core.data.Model|String|Number} recordOrId Record or record id\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} A promise which resolves when the specified row has been scrolled into view.\n     * @category Scrolling\n     */\n    async scrollRowIntoView(recordOrId, options = defaultScrollOptions) {\n        const\n            me             = this,\n            blockPosition  = options.block || 'nearest',\n            { rowManager } = me,\n            record         = me.store.getById(recordOrId);\n\n        if (record) {\n            let scrollPromise;\n\n            // check that record is \"displayable\", not filtered out or hidden by collapse\n            if (me.store.indexOf(record) === -1) {\n                return resolvedPromise;\n            }\n\n            let scroller   = me.scrollable,\n                recordRect = me.getRecordCoords(record);\n\n            const scrollerRect = Rectangle.from(scroller.element);\n\n            // If it was calculated from the index, update the rendered rowScrollMode\n            // and scroll to the actual element. Note that this should only be necessary\n            // for variableRowHeight.\n            // But to \"make the tests green\", this is a workaround for a buffered rendering\n            // bug when teleporting scroll. It does not render the rows at their correct\n            // positions. Please do not try to \"fix\" this. I will do it. NGW\n            if (recordRect.virtual) {\n                const\n                    virtualBlock = recordRect.block,\n                    innerOptions = blockPosition !== 'nearest' ? options : {\n                        block : virtualBlock\n                    };\n\n                // Scroll the calculated position **synchronously** to the center of the scrollingViewport\n                // and then update the rendered block while asking the RowManager to\n                // display the required recordOrId.\n                scrollPromise = scroller.scrollIntoView(recordRect, {\n                    block : 'center'\n                });\n\n                rowManager.scrollTargetRecordId = record;\n                rowManager.updateRenderedRows(scroller.y, true);\n                recordRect               = me.getRecordCoords(record);\n                rowManager.lastScrollTop = scroller.y;\n\n                if (recordRect.virtual) {\n                    //<debug>\n                    throw new Error(`Unable to scroll ${record.id} into view`);\n                    //</debug>\n                    // bail out to not get caught in infinite loop, since code above is cut out of bundle\n                    // eslint-disable-next-line no-useless-return,no-unreachable\n                    return resolvedPromise;\n                }\n\n                // Scroll the target just less than append/prepend buffer height out of view so that the animation looks good\n                if (options.animate) {\n                    // Do not fire scroll events during this scroll sequence - it's a purely cosmetic operation.\n                    // We are scrolling the desired row out of view merely to *animate scroll* it to the requested position.\n                    scroller.suspendEvents();\n\n                    // Scroll to its final position\n                    if (blockPosition === 'end' || blockPosition === 'nearest' && virtualBlock === 'end') {\n                        scroller.y -= (scrollerRect.bottom - recordRect.bottom);\n                    }\n                    else if (blockPosition === 'start' || blockPosition === 'nearest' && virtualBlock === 'start') {\n                        scroller.y += (recordRect.y - scrollerRect.y);\n                    }\n\n                    // Ensure rendered block is correct at that position\n                    rowManager.updateRenderedRows(scroller.y, false, true);\n\n                    // Scroll away from final position to enable a cosmetic scroll to final position\n                    if (virtualBlock === 'end') {\n                        scroller.y -= (rowManager.appendRowBuffer * rowManager.rowHeight - 1);\n                    }\n                    else {\n                        scroller.y += (rowManager.prependRowBuffer * rowManager.rowHeight - 1);\n                    }\n\n                    // The row will still be rendered, so scroll it using the scroller directly\n                    scroller.scrollIntoView(me.getRecordCoords(record), Object.assign({}, options, innerOptions));\n\n                    // Now we're at the required position, resume events\n                    scroller.resumeEvents();\n                }\n                else {\n                    if (!options.recursive) {\n                        await scrollPromise;\n                    }\n                    // May already be destroyed at this point, hence ?.\n                    await me.scrollRowIntoView?.(record, Object.assign({ recursive : true }, options, innerOptions));\n                }\n            }\n            else {\n                let { column } = options;\n\n                if (column) {\n                    if (!column.isModel) {\n                        column = me.columns.getById(column) || me.columns.get(column);\n                    }\n\n                    // If we are targeting a column, we must use the scroller of that column's SubGrid\n                    if (column) {\n                        scroller = me.getSubGridFromColumn(column).scrollable;\n\n                        const cellRect = Rectangle.from(rowManager.getRowFor(record).getCell(column.id));\n\n                        recordRect.x     = cellRect.x;\n                        recordRect.width = cellRect.width;\n                    }\n                }\n                // No column, then tell the scroller not to scroll in the X axis\n                else {\n                    options.x = false;\n                }\n                return scroller.scrollIntoView(recordRect, options);\n            }\n        }\n    }\n\n    /**\n     * Scrolls a column into view (if it is not already)\n     * @param {Grid.column.Column|String|Number} column Column name (data) or column index or actual column object.\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} If the column exists, a promise which is resolved when the column header element has been\n     * scrolled into view.\n     * @category Scrolling\n     */\n    scrollColumnIntoView(column, options) {\n        column = (column instanceof Column) ? column : this.columns.get(column) || this.columns.getById(column) || this.columns.getAt(column);\n\n        return this.getSubGridFromColumn(column).scrollColumnIntoView(column, options);\n    }\n\n    // TODO The API { id: recordId, column: 'columnName' } is not clear: id has to be renamed to `record` or `recordId` to be self-explanatory;\n    /**\n     * Scrolls a cell into view (if it is not already)\n     * @param {Object} cellContext Cell selector { id: recordId, column: 'columnName' }\n     * @category Scrolling\n     */\n    scrollCellIntoView(cellContext, options) {\n        return this.scrollRowIntoView(cellContext.id, Object.assign({\n            column : cellContext.columnId\n        }, typeof options === 'boolean' ? { animate : options } : options));\n    }\n\n    /**\n     * Scroll all the way down\n     * @returns {Promise} A promise which resolves when the bottom is reached.\n     * @category Scrolling\n     */\n    scrollToBottom(options) {\n        // triggers scroll to last record. not using current scroller height because we do not know if it is correct\n        return this.scrollRowIntoView(this.store.last, options);\n    }\n\n    /**\n     * Scroll all the way up\n     * @returns {Promise} A promise which resolves when the top is reached.\n     * @category Scrolling\n     */\n    scrollToTop(options) {\n        return this.scrollable.scrollBy(0, -this.scrollable.y, options);\n    }\n\n    /**\n     * Stores the scroll state. Returns an objects with a `scrollTop` number value for the entire grid and a `scrollLeft`\n     * object containing a left position scroll value per sub grid.\n     * @returns {Object}\n     * @category Scrolling\n     */\n    storeScroll() {\n        const\n            me    = this,\n            state = me.storedScrollState = {\n                scrollTop  : me.scrollable.y,\n                scrollLeft : {}\n            };\n\n        // TODO: Implement special multi-element Scroller subclass for Grids which\n        // encapsulates the x axis only Scrollers of all its SubGrids.\n        me.eachSubGrid(subGrid => {\n            state.scrollLeft[subGrid.region] = subGrid.scrollable.x;\n        });\n\n        return state;\n    }\n\n    /**\n     * Restore scroll state. If state is not specified, restores the last stored state.\n     * @param {Object} [state] Scroll state, optional\n     * @category Scrolling\n     */\n    restoreScroll(state = this.storedScrollState) {\n        const me = this;\n\n        // TODO: Implement special multi-element Scroller subclass for Grids which\n        // encapsulates the x axis only Scrollers of all its SubGrids.\n        me.eachSubGrid(subGrid => {\n            const x = state.scrollLeft[subGrid.region];\n\n            // Force scrollable to set its position to the underlying element in case it was removed and added back to\n            // the DOM prior to restoring state\n            if (x != null) {\n                subGrid.scrollable.updateX(x);\n                subGrid.header.scrollable.updateX(x);\n                subGrid.footer.scrollable.updateX(x);\n                subGrid.fakeScroller?.updateX(x);\n            }\n        });\n\n        me.scrollable.updateY(state.scrollTop);\n    }\n\n    //endregion\n\n    //region Theme & measuring\n\n    beginGridMeasuring() {\n        const me = this;\n\n        if (!me.$measureCellElements) {\n            me.$measureCellElements = DomHelper.createElement({\n                // For row height measuring, features are not yet there. Work around that for the stripe feature,\n                // which removes borders\n                className : 'b-grid-subgrid ' + (!me._isRowMeasured && me.hasFeature('stripe') ? 'b-stripe' : ''),\n                reference : 'subGridElement',\n                style     : {\n                    position   : 'absolute',\n                    top        : '-10000px',\n                    left       : '-100000px',\n                    visibility : 'hidden',\n                    contain    : 'strict'\n                },\n                children : [\n                    {\n                        className : 'b-grid-row',\n                        reference : 'rowElement',\n                        children  : [\n                            {\n                                className : 'b-grid-cell',\n                                reference : 'cellElement',\n                                style     : {\n                                    width   : 'auto',\n                                    contain : BrowserHelper.isFirefox ? 'layout paint' : 'layout style paint'\n                                }\n                            }\n                        ]\n                    }\n                ]\n            });\n        }\n\n        // Bring element into life if we get here early, to be able to access verticalScroller below\n        me.getConfig('element');\n\n        // Temporarily add to where subgrids live, to get have all CSS classes in play\n        me.verticalScroller.appendChild(me.$measureCellElements.subGridElement);\n\n        // Not yet on page, which prevents us from getting style values. Add it to the DOM temporarily\n        if (!me.rendered) {\n            const\n                targetEl    = me.appendTo || me.insertBefore || document.body,\n                rootElement = DomHelper.getRootElement(typeof targetEl === 'string' ? document.getElementById(targetEl) : targetEl);\n\n            if (!me.adopt || !rootElement.contains(me.element)) {\n                rootElement.appendChild(me.element);\n                me.$removeAfterMeasuring = true;\n            }\n        }\n        return me.$measureCellElements;\n    }\n\n    endGridMeasuring() {\n        // Remove grid from DOM if it was added for measuring\n        if (this.$removeAfterMeasuring) {\n            this.element.remove();\n            this.$removeAfterMeasuring = false;\n        }\n\n        // Remove measuring elements from grid\n        this.$measureCellElements.subGridElement.remove();\n    }\n\n    /**\n     * Creates a fake subgrid with one row and measures its height. Result is used as rowHeight.\n     * @private\n     */\n    measureRowHeight() {\n        const\n            me             = this,\n            // Create a fake subgrid with one row, since styling for row is specified on .b-grid-subgrid .b-grid-row\n            { rowElement } = me.beginGridMeasuring(),\n            // Use style height or default height from config.\n            // Not using clientHeight since it will have some value even if no height specified in CSS\n            styles         = DomHelper.getStyleValue(rowElement, ['height', 'border-top-width', 'border-bottom-width']),\n            styleHeight    = parseInt(styles.height),\n            // FF reports border width adjusted to device pixel ration, e.g. on a 150% scaling it would tell 0.6667px width\n            // for a 1px border. Dividing by the integer part to take base devicePixelRatio into account\n            multiplier     = BrowserHelper.isFirefox ? globalThis.devicePixelRatio / Math.max(Math.trunc(globalThis.devicePixelRatio), 1) : 1,\n            borderTop      = styles['border-top-width'] ? Math.round(multiplier * parseFloat(styles['border-top-width'])) : 0,\n            borderBottom   = styles['border-bottom-width'] ? Math.round(multiplier * parseFloat(styles['border-bottom-width'])) : 0;\n\n        // Change rowHeight if specified in styling, also remember that value to replace later if theme changes and\n        // user has not explicitly set some other height\n        if (me.rowHeight == null || me.rowHeight === me._rowHeightFromStyle) {\n            me.rowHeight           = !isNaN(styleHeight) && styleHeight ? styleHeight : me.defaultRowHeight;\n            me._rowHeightFromStyle = me.rowHeight;\n        }\n\n        // this measurement will be added to rowHeight during rendering, to get correct cell height\n        me._rowBorderHeight = borderTop + borderBottom;\n\n        me._isRowMeasured = true;\n\n        me.endGridMeasuring();\n\n        // There is a ticket about measuring the actual first row instead:\n        // https://app.assembla.com/spaces/bryntum/tickets/5735-measure-first-real-rendered-row-for-rowheight/details\n    }\n\n    /**\n     * Handler for global theme change event (triggered by shared.js). Remeasures row height.\n     * @private\n     */\n    onThemeChange({ theme }) {\n        // Can only measure when we are visible, so do it next time we are.\n        this.whenVisible('measureRowHeight');\n\n        this.trigger('theme', { theme });\n    }\n\n    //endregion\n\n    //region Rendering of rows\n\n    /**\n     * Triggers a render of records to all row elements. Call after changing order, grouping etc to reflect changes\n     * visually. Preserves scroll.\n     * @category Rendering\n     */\n    refreshRows(returnToTop = false) {\n        const { element, rowManager } = this;\n\n        element.classList.add('b-notransition');\n\n        if (returnToTop) {\n            rowManager.returnToTop();\n        }\n        else {\n            rowManager.refresh();\n        }\n\n        element.classList.remove('b-notransition');\n    }\n\n    /**\n     * Triggers a render of all the cells in a column.\n     * @param {Grid.column.Column} column\n     * @category Rendering\n     */\n    refreshColumn(column) {\n        if (column.isVisible) {\n            if (column.isLeaf) {\n                this.rowManager.forEach(row => row.renderCell(row.getCell(column.id)));\n            }\n            else {\n                column.children.forEach(child => this.refreshColumn(child));\n            }\n        }\n    }\n\n    //endregion\n\n    //region Render the grid\n\n    /**\n     * Recalculates virtual scrollbars widths and scrollWidth\n     * @private\n     */\n    refreshVirtualScrollbars() {\n        // NOTE: This was at some point changed to only run on platforms with width-occupying scrollbars, but it needs\n        // to run with overlayed scrollbars also to make them show/hide as they should.\n\n        const\n            me                        = this,\n            {\n                headerContainer,\n                footerContainer,\n                virtualScrollers,\n                scrollable,\n                hasVerticalOverflow\n            }                         = me,\n            { classList }             = virtualScrollers,\n            hadHorizontalOverflow     = !classList.contains('b-hide-display'),\n            // We need to ask each subGrid if it has horizontal overflow.\n            // If any do, we show the virtual scroller, otherwise we hide it.\n            hasHorizontalOverflow     = Object.values(me.subGrids).some(subGrid => subGrid.overflowingHorizontally),\n            horizontalOverflowChanged = hasHorizontalOverflow !== hadHorizontalOverflow;\n\n        // If horizontal overflow state changed, the docked horizontal scrollbar's visibility\n        //  must be synced to match, and this may cause a height change;\n        if (horizontalOverflowChanged) {\n            virtualScrollers.classList.toggle('b-hide-display', !hasHorizontalOverflow);\n        }\n\n        // Auto-widthed padding element at end hides or shows to create matching margin.\n        if (DomHelper.scrollBarWidth) {\n            // Header will need its extra padding if we have overflow, *OR* if we are overflowY : scroll\n            const needsPadding = hasVerticalOverflow || scrollable.overflowY === 'scroll';\n\n            headerContainer.classList.toggle('b-show-yscroll-padding', needsPadding);\n            footerContainer.classList.toggle('b-show-yscroll-padding', needsPadding);\n            virtualScrollers.classList.toggle('b-show-yscroll-padding', needsPadding);\n\n            // Do any measuring necessitated by show/hide of the docked horizontal scrollbar\n            /// *after* mutating DOM classnames.\n            if (horizontalOverflowChanged) {\n                // If any subgrids reported they have horizontal overflow, then we have to ask them\n                // to sync the widths of the scroll elements inside the docked horizontal scrollbar\n                // so that it takes up the required scrollbar width at the bottom of our body element.\n                if (hasHorizontalOverflow) {\n                    me.callEachSubGrid('refreshFakeScroll');\n                }\n                me.onHeightChange();\n            }\n        }\n    }\n\n    get hasVerticalOverflow() {\n        return this.scrollable.hasOverflow('y');\n    }\n\n    /**\n     * Returns content height calculated from row manager\n     * @private\n     */\n    get contentHeight() {\n        const rowManager = this.rowManager;\n        return Math.max(rowManager.totalHeight, rowManager.bottomRow ? rowManager.bottomRow.bottom : 0);\n    }\n\n    onContentChange() {\n        const\n            me         = this,\n            rowManager = me.rowManager;\n\n        if (me.isVisible) {\n            rowManager.estimateTotalHeight();\n            me.paintListener = null;\n            me.refreshTotalHeight(me.contentHeight);\n            me.callEachSubGrid('refreshFakeScroll');\n            me.onHeightChange();\n        }\n        // If not visible, this operation MUST be done when we become visible.\n        // This is announced by the paint event which is triggered when a Widget\n        // really gains visibility, ie is shown or rendered, or it's not hidden,\n        // and a hidden/non-rendered ancestor is shown or rendered.\n        // See Widget#triggerPaint.\n        else if (!me.paintListener) {\n            me.paintListener = me.ion({\n                paint   : 'onContentChange',\n                once    : true,\n                thisObj : me\n            });\n        }\n    }\n\n    triggerPaint() {\n        if (!this.isPainted) {\n            this.refreshBodyRectangle();\n        }\n\n        super.triggerPaint();\n    }\n\n    onHeightChange() {\n        const me = this;\n\n        // cache to avoid recalculations in the middle of rendering code (RowManger#getRecordCoords())\n        me.refreshBodyRectangle();\n        me._bodyHeight = me.autoHeight ? me.contentHeight : me.bodyContainer.offsetHeight;\n    }\n\n    suspendRefresh() {\n        this.refreshSuspended++;\n    }\n\n    resumeRefresh(trigger) {\n        if (this.refreshSuspended && !--this.refreshSuspended) {\n            if (trigger) {\n                this.refreshRows();\n            }\n\n            this.trigger('resumeRefresh', { trigger });\n        }\n    }\n\n    /**\n     * Rerenders all grid rows, completely replacing all row elements with new ones\n     * @category Rendering\n     */\n    renderRows(keepScroll = true) {\n        const\n            me          = this,\n            scrollState = keepScroll && me.storeScroll();\n\n        if (me.refreshSuspended) {\n            return;\n        }\n\n        /**\n         * Grid rows are about to be rendered\n         * @event beforeRenderRows\n         * @param {Grid.view.Grid} source This grid.\n         */\n        me.trigger('beforeRenderRows');\n        me.renderingRows = true;\n\n        // This allows us to do things like disable animations on a refresh\n        me.element.classList.add('b-grid-refreshing');\n\n        if (!keepScroll) {\n            me.scrollable.y = me._scrollTop = 0;\n        }\n        me.rowManager.reinitialize(!keepScroll);\n\n        /**\n         * Grid rows have been rendered\n         * @event renderRows\n         * @param {Grid.view.Grid} source This grid.\n         */\n        me.trigger('renderRows');\n\n        me.renderingRows = false;\n        me.onContentChange();\n\n        if (keepScroll) {\n            me.restoreScroll(scrollState);\n        }\n\n        me.element.classList.remove('b-grid-refreshing');\n    }\n\n    /**\n     * Rerenders the grids rows, headers and footers, completely replacing all row elements with new ones\n     * @category Rendering\n     */\n    renderContents() {\n        const\n            me                                                        = this,\n            { element, headerContainer, footerContainer, rowManager } = me;\n\n        me.emptyCache();\n\n        // columns will be \"drawn\" on render anyway, bail out\n        if (me.isPainted) {\n            // reset measured header height, to make next call to get headerHeight measure it\n            me._headerHeight = null;\n\n            me.callEachSubGrid('refreshHeader', headerContainer);\n            me.callEachSubGrid('refreshFooter', footerContainer);\n\n            // Note that these are hook methods for features to plug in to. They do not do anything.\n            me.renderHeader(headerContainer, element);\n            me.renderFooter(footerContainer, element);\n\n            me.fixSizes();\n\n            // any elements currently used for rows should be released.\n            // actual removal of elements is done in SubGrid#clearRows\n            const refreshContext = rowManager.removeAllRows();\n\n            rowManager.calculateRowCount(false, true, true);\n\n            if (rowManager.rowCount) {\n                // Sets up the RowManager's position for when renderRows calls RowManager#reinitialize\n                // so that it renders the correct data block at the correct position.\n                rowManager.setPosition(refreshContext);\n\n                me.renderRows();\n            }\n        }\n    }\n\n    onPaintOverride() {\n        // Internal procedure used for paint method overrides\n        // Not used in onPaint() because it may be chained on instance and Override won't be applied\n    }\n\n    // Render rows etc. on first paint, to make sure Grids element has been laid out\n    onPaint({ firstPaint }) {\n        const me = this;\n\n        me.ariaElement.setAttribute('aria-rowcount', me.store.count + 1);\n\n        super.onPaint?.(...arguments);\n\n        if (me.onPaintOverride() || !firstPaint) {\n            return;\n        }\n\n        const\n            {\n                rowManager,\n                store,\n                element,\n                headerContainer,\n                bodyContainer,\n                footerContainer\n            }         = me,\n            scrollPad = DomHelper.scrollBarPadElement;\n\n        let columnsChanged,\n            maxDepth = 0;\n\n        // ARIA. Update our ariaElement that encapsulates all rows.\n        // The header is counted as a row, and column headers are cells.\n        me.role = store?.isTree ? 'treegrid' : 'grid';\n\n        // See if updateResponsive changed any columns.\n        me.columns.ion({\n            change : () => columnsChanged = true,\n            once   : true\n        });\n\n        // Apply any responsive configs before rendering rows.\n        me.updateResponsive(me.width, 0);\n\n        // If there were any column changes, apply them\n        if (columnsChanged) {\n            me.callEachSubGrid('refreshHeader', headerContainer);\n            me.callEachSubGrid('refreshFooter', footerContainer);\n        }\n\n        // Note that these are hook methods for features to plug in to. They do not do anything.\n        // SubGrids take care of their own rendering.\n        me.renderHeader(headerContainer, element);\n        me.renderFooter(footerContainer, element);\n\n        // These padding elements are only visible on scrollbar showing platforms.\n        // And then, only when the owning element as the b-show-yscroll-padding class added.\n        // See refreshVirtualScrollbars where this is synced on the header, footer and scroller elements.\n        DomHelper.append(headerContainer, scrollPad);\n        DomHelper.append(footerContainer, scrollPad);\n        DomHelper.append(me.virtualScrollers, scrollPad);\n\n        // Cached, updated on resize. Used by RowManager and by the subgrids upon their render.\n        // Measure after header and footer have been rendered and taken their height share.\n        me.refreshBodyRectangle();\n        const bodyOffsetHeight = me.bodyContainer.offsetHeight;\n\n        if (me.autoHeight) {\n            me._bodyHeight             = rowManager.initWithHeight(element.offsetHeight - headerContainer.offsetHeight - footerContainer.offsetHeight, true);\n            bodyContainer.style.height = me.bodyHeight + 'px';\n        }\n        else {\n            me._bodyHeight = bodyOffsetHeight;\n            rowManager.initWithHeight(me._bodyHeight, true);\n        }\n\n        me.eachSubGrid(subGrid => {\n            if (subGrid.header.maxDepth > maxDepth) {\n                maxDepth = subGrid.header.maxDepth;\n            }\n        });\n\n        headerContainer.dataset.maxDepth = maxDepth;\n\n        me.fixSizes();\n\n        if (store.count || !store.isLoading) {\n            me.renderRows();\n        }\n\n        // With autoHeight cells we need to refresh rows when fonts are loaded, to get correct measurements\n        if (me.columns.usesAutoHeight) {\n            const { fonts } = document;\n            if (fonts?.status !== 'loaded') {\n                fonts.ready.then(() => !me.isDestroyed && me.refreshRows());\n            }\n        }\n\n        me.initScroll();\n\n        me.initInternalEvents();\n    }\n\n    render() {\n        const me = this;\n\n        // When displayed inside one of our containers, require a size to be considered visible. Ensures it is painted\n        // on display when for example in a tab\n        me.requireSize = Boolean(me.owner);\n\n        // Render as a container. This renders the child SubGrids\n        super.render(...arguments);\n\n        if (!me.autoHeight) {\n            // Sanity check that main element has been given some sizing styles, unless autoHeight is used in which case\n            // it will be sized programmatically instead\n            if (me.headerContainer.offsetHeight && !me.bodyContainer.offsetHeight) {\n                console.warn('Grid element not sized correctly, please check your CSS styles and review how you size the widget');\n            }\n\n            // Warn if height equals the predefined minHeight, likely that is not what the dev intended\n            if (\n                !('minHeight' in me.initialConfig) &&\n                !('height' in me.initialConfig) &&\n                parseInt(globalThis.getComputedStyle(me.element).minHeight) === me.height\n            ) {\n                console.warn(\n                    `The ${me.$$name} is sized by its predefined minHeight, likely this is not intended. ` +\n                    `Please check your CSS and review how you size the widget, or assign a fixed height in the config. ` +\n                    `For more information, see the \"Basics/Sizing the component\" guide in docs.`\n                );\n            }\n        }\n    }\n\n    //endregion\n\n    //region Hooks\n\n    /**\n     * Called after headers have been rendered to the headerContainer.\n     * This does not do anything, it's just for Features to hook in to.\n     * @param {HTMLElement} headerContainer DOM element which contains the headers.\n     * @param {HTMLElement} element Grid element\n     * @private\n     * @category Rendering\n     */\n    renderHeader(headerContainer, element) {}\n\n    /**\n     * Called after footers have been rendered to the footerContainer.\n     * This does not do anything, it's just for Features to hook in to.\n     * @param {HTMLElement} footerContainer DOM element which contains the footers.\n     * @param {HTMLElement} element Grid element\n     * @private\n     * @category Rendering\n     */\n    renderFooter(footerContainer, element) {}\n\n    // Hook for features to affect cell rendering before renderers are run\n    beforeRenderCell() {}\n\n    // Hooks for features to react to a row being rendered\n    beforeRenderRow() {}\n\n    afterRenderRow() {}\n\n    // Hook for features to react to scroll\n    afterScroll() {}\n\n    // Hook that can be overridden to prepare custom editors, can be used by framework wrappers\n    processCellEditor(editorConfig) {}\n\n    // Hook for features to react to column changes\n    afterColumnsChange() {}\n\n    // Hook for features to react to record removal (which might be transitioned)\n    afterRemove(removeEvent) {}\n\n    // Hook for features to react to groups being collapsed/expanded\n    afterToggleGroup() {}\n\n    // Hook for features to react to subgrid being collapsed\n    afterToggleSubGrid() {}\n\n    //endregion\n\n    //region Masking and Appearance\n\n    syncMaskCover(mask = this.masked) {\n        if (mask) {\n            const\n                bodyRect     = (mask.cover === 'body') && this.rectangleOf('bodyContainer'),\n                scrollerRect = bodyRect && this.rectangleOf('virtualScrollers'),\n                { style }    = mask.element;\n\n            // the width of the bodyCt covers the vscroll but the height does not cover the hscroll:\n            style.marginTop = bodyRect ? `${bodyRect.y}px` : '';\n            style.height    = bodyRect ? `${bodyRect.height + (scrollerRect?.height || 0)}px` : '';\n        }\n    }\n\n    /**\n     * Show a load mask with a spinner and the specified message. When using an AjaxStore masking and unmasking is\n     * handled automatically, but if you are loading data in other ways you can call this function manually when your\n     * load starts.\n     * ```\n     * myLoadFunction() {\n     *   // Show mask before initiating loading\n     *   grid.maskBody('Loading data');\n     *   // Your custom loading code\n     *   load.then(() => {\n     *      // Hide the mask when loading is finished\n     *      grid.unmaskBody();\n     *   });\n     * }\n     * ```\n     * @param {String|MaskConfig} loadMask The message to show in the load mask (next to the spinner) or a config object\n     * for a {@link Core.widget.Mask}.\n     * @returns {Core.widget.Mask}\n     * @category Misc\n     */\n    maskBody(loadMask) {\n        let ret;\n\n        if (this.bodyContainer) {\n            this.masked = Mask.mergeConfigs(this.loadMaskDefaults, loadMask);  // smart setter\n            ret         = this.masked;  // read back\n        }\n\n        return ret;\n    }\n\n    /**\n     * Hide the load mask.\n     * @category Misc\n     */\n    unmaskBody() {\n        this.masked = null;\n    }\n\n    updateEmptyText(emptyText) {\n        this.emptyTextEl?.remove();\n\n        // Grid might be created without subgrids, will add element to first when it is added\n        this.emptyTextEl = DomHelper.createElement({\n            parent                                       : this.firstItem?.element,\n            className                                    : 'b-empty-text',\n            [emptyText?.includes('<') ? 'html' : 'text'] : emptyText\n        });\n    }\n\n    toggleEmptyText() {\n        const { bodyContainer, store } = this;\n        bodyContainer?.classList.toggle('b-grid-empty', !(store.count > 0 || store.isLoading || store.isCommitting));\n    }\n\n    // Notify columns when our read-only state is toggled\n    updateReadOnly(readOnly, old) {\n        super.updateReadOnly(readOnly, old);\n\n        if (!this.isConfiguring) {\n            for (const column of this.columns.bottomColumns) {\n                column.updateReadOnly?.(readOnly);\n            }\n        }\n    }\n\n    //endregion\n\n    //region Extract config\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs for the grid, with special handling for inline data\n    getCurrentConfig(options) {\n        const\n            result     = super.getCurrentConfig(options),\n            { store }  = this,\n            // Clean up inline data to not have group records in it\n            data       = store.getInlineData(options),\n            // Get stores current state, in case it has filters etc added at runtime\n            storeState = store.getCurrentConfig(options) || result.store;\n\n        if (data.length) {\n            result.data = data;\n        }\n\n        // Dont include the default model class\n        if (storeState && store.originalModelClass === GridRowModel) {\n            delete storeState.modelClass;\n        }\n\n        if (!ObjectHelper.isEmpty(storeState)) {\n            result.store = storeState;\n        }\n\n        if (result.store) {\n            delete result.store.data;\n        }\n\n        return result;\n    }\n\n    //endregion\n}\n\n// Register this widget type with its Factory\nGridBase.initClass();\n\nVersionHelper.setVersion('grid', '5.3.0');\n"],"names":["Location","constructor","location","isLocation","nodeType","Node","ELEMENT_NODE","grid","Widget","fromElement","cell","closest","focusableSelector","dataset","parentNode","this","init","rowIndex","store","includes","id","indexOf","index","columnId","initialTarget","config","_me$record","me","columns","visibleColumns","target","actionTargets","_target","record","_id","_rowIndex","_store$getAt","isNaN","row","NaN","Math","max","min","Number","count","hideHeaders","getAt","isSpecialRow","_column","getById","get","field","columnIndex","column","_columnIndex","length","equals","other","shallow","visibleRowIndex","rowManager","lastFullyVisibleTow","dataIndex","firstFullyVisibleTow","isSelectable","_this$column","_this$grid$columns$vi","move","where","result","rowMin","rowMax","colMax","atFirstRow","atLastRow","atFirstColumn","atLastColumn","PREV_CELL","NEXT_CELL","UP","DOWN","firstFullyVisibleRow","FIRST_COLUMN","LAST_COLUMN","FIRST_CELL","LAST_CELL","PREV_PAGE","floor","scrollable","clientHeight","rowHeight","NEXT_PAGE","_cell","_grid$columns$getById","element","_grid$columns$getAt","getCell","getRowById","getRow","focusableFinder","currentNode","focusableFinderCell","nextNode","isActionable","containsFocus","compareDocumentPosition","DomHelper","getActiveElement","DOCUMENT_POSITION_CONTAINED_BY","Boolean","isColumnHeader","isCell","_$name","validWidth","value","endsWith","Column","Model","mixin","Events","Localizable","$name","type","fields","name","defaultValue","convert","sorter","originalSortFn","sortFn","bind","Object","assign","fn","filter","columnOwned","filterFn","autoExposeFields","construct","data","_me$field","masterStore","_grid","Array","isArray","localizableProperties","Config","mergeMethods","distinct","localeClass","super","arguments","isLeaf","emptyCount","noFieldSpecified","hasComplexMapping","width","flex","children","set","defaultWidth","headerWidgets","initHeaderWidgets","isParent","meta","visibleChildren","Set","collapsible","isCollapsible","_this$children","collapsed","onCollapseChange","trigger","onCellFocus","updateHeaderAriaLabel","localizeProperty","updateCellAriaLabel","headerAriaLabel","setAttributes","cellAriaLabel","_this$location","_this$location2","_cellAriaLabel","text","doDestroy","_this$data","_this$data$editor","_this$data$editor$des","editor","destroy","call","destroyHeaderWidgets","widgets","headerWidgetMap","widget","create","_objectSpread","owner","ref","values","_widget$destroy","generateAutoCls","columnAutoCls","c","superclass","toLowerCase","autoClsMap","Map","getCellClass","cellContext","_Column$autoClsMap","_record$fieldMap$colu","cellCls","internalCellCls","align","autoCls","isEditing","classList","contains","isFieldModified","compositeField","fieldMap","persist","selectionMode","isCellSelected","isFocused","autoHeight","locked","region","parent","isRoot","sortable","groupable","isWidget","processCellEditor","ObjectHelper","merge","defaultEditor","label","StringHelper","encodeHtml","getFilterableValue","getRawValue","_owner","subGrid","_this$parent","_subGrid","_this$grid","getSubGridFromColumn","subGridElement","getHeaderElement","nextVisibleSibling","next","nextSibling","hidden","isLastInSubGrid","textWrapper","getChild","textElement","down","contentElement","isSorted","sorters","some","s","isFocusable","$meta","defaults","headerText","htmlEncodeHeaderText","isVisible","hide","silent","hidingParent","isTogglingAll","child","forEach","stores","show","_me$meta$visibleChild","toggle","forceVisible","undefined","toggleChildren","force","_me$grid$columns","_me$grid$columns2","beginBatch","childColumn","endBatch","collapseMode","_me$grid$columns3","_me$grid$columns4","firstChild","oldFlex","offsetWidth","slice","push","toggleable","pressed","icon","rtl","pressedIcon","cls","onToggle","findIndex","w","splice","generateId","generatedIdIndex","replace","allIndex","measureSize","_this$subGrid","calcMinWidth","minWidth","parseInt","calculateMinWidth","minChildWidth","reduce","resizeToFitContent","widthMin","widthMax","batch","fitMode","rows","rowElement","cellElement","beginGridMeasuring","start","end","i","maxWidth","longest","_domData","updatingSingleRow","isMeasuring","innerHTML","resizeToFitIncludesHeader","$headerPadding","style","globalThis","getComputedStyle","paddingLeft","querySelector","cssText","topIndex","round","rowCount","String","_record","renderCell","textContent","endGridMeasuring","getState","state","applyState","remove","focusedCell","owns","navigateRight","_focusedCell","getAdjacentVisibleLeafColumn","getPath","refreshCell","clearCell","_content","canEdit","isEditable","insertChild","before","col","sealed","inProcessChildren","canFillValue","getCurrentConfig","options","_this$sortable","renderer","internalRenderer","headerRenderer","internalHeaderRenderer","ariaLabel","exposeProperties","columnDefinitions","boolean","date","integer","format","maximumFractionDigits","number","lockedColumnSorters","ColumnStore","Store","defaultConfig","modelClass","tree","autoAddField","_columnStore","ion","subGridCollapse","subGridExpand","thisObj","change","onStoreChange","sort","updateChainedStores","prio","_modelClass","ClassDef","allColumns","isChained","traverse","idRegister","traverseWhile","n","totalFixedWidth","childCol","calculateFixedWidth","hasFlex","topColumns","rootNode","chainedFilterFn","_visibleColumns","leaves","action","changes","clearCaches","clearSubGridCaches","_this$masterStore","onMasterDataChanged","event","columnOrId","wrap","idx","bottomColumns","findRecord","createRecord","_store$modelClass","_store$modelClass$fie","dataField","columnClass","Objects","getColumnClass","Error","defaultRegion","fieldDefinition","fieldType","addField","recordOrId","records","r","usesAutoHeight","find","usesFlexAutoHeight","registerColumnType","simpleRenderer","columnTypes","generateColumnForField","_this$grid$store","separate","precision","columnType","WidgetColumn","filterable","searchable","alwaysClearCell","widgetMap","externalRenderer","updateReadOnly","readOnly","cellInfo","renderData","_this$externalRendere","isExport","map","widgetCfg","_me$onBeforeWidgetSet","_me$onAfterWidgetSetV","widgetNextSibling","nextElementSibling","recreate","onBeforeWidgetCreate","recomposeAsync","WidgetHelper","append","insertBefore","onAfterWidgetCreate","isSelectionColumn","onBeforeWidgetSetValue","valueProperty","defaultBindProperty","onAfterWidgetSetValue","_defineProperty","CheckColumn","externalHeaderRenderer","externalOnBeforeWidgetSetValue","externalOnAfterWidgetSetValue","internalOnBeforeWidgetSetValue","internalOnAfterWidgetSetValue","_me$grid","suppressNoModelFieldWarning","console","warn","$$name","_this$headerCheckbox","headerCheckbox","headerElement","returnValue","add","showCheckAll","appendChild","Checkbox","appendTo","internalListeners","updateCheckAllState","suspendEvents","checked","resumeEvents","onCheckAllChange","updateRecord","checkCls","beforeChange","_this$externalOnBefor","isInitialSet","_this$externalOnAfter","onBeforeCheckboxChange","source","userAction","features","cellEdit","disabled","onCheckboxChange","every","setterName","capitalize","onCellKeyDown","key","checkbox","preventDefault","handled","RowNumberColumn","resizable","draggable","bindStore","initial","rendered","paint","once","groupHeaderReserved","detachListeners","asyncEventSuffix","cellPadding","getStyleValue","measureText","f","_column$externalHeade","consumerToFeatureMap","consumerToDefaultFeatureMap","remapToBase","Grid","Scheduler","SchedulerPro","Gantt","classNameFix","GridFeatureManager","registerFeature","featureClass","onByDefault","forType","as","uncapitalize","prototype","hasOwnProperty","consumerFeaturesMap","consumerDefaultFeaturesMap","getTypeNameFeatures","getTypeNameDefaultFeatures","getInstanceFeatures","instance","names","typeName","getInstanceDefaultFeatures","entries","isDefaultFeatureForTypeName","isDefaultFeatureForInstance","typeChain","reverse","len","has","reset","clear","editingActions","finishAndEditNextRow","finishAndEditPrevRow","finishEditing","cancelEditing","finishAndEditNextCell","finishAndEditPrevCell","CellEdit","Delayable","InstancePlugin","autoSelect","blurAction","continueEditingOnCellClick","addNewAtEnd","autoEdit","editNextOnEnterPress","editorClass","Editor","triggerEvent","touchEditDelay","focusCellAnimationDuration","multiEdit","keyMap","Enter","F2","Escape","Tab","pluginConfig","chain","gridListeners","renderRows","cellClick","changeTotalHeight","update","beforeSort","confirm","editorContext","MessageDialog","inputField","rootElement","yesButton","allRecords","_column$_cellEditor","_cellEditor","doDisable","disable","isConfiguring","activeRecord","_this$editorContext","getEditorForCell","cellEditor","leftOffset","editTargetSelector","offsetLeft","isEditor","mergeConfigs","constrainTo","invalidAction","completeKey","cancelKey","offset","getEditorListeners","onInternalKeyDown","onEditorKeydown","allowMouseEvents","minHeight","items","instantUpdate","cellEditValueSetter","wrapProperty","isValid","isEqual","isDateField","_isPickerInput","rowId","revertOnEscape","focusOut","focusIn","beforeComplete","complete","beforeCancel","cancel","beforeHide","finishEdit","onEditorStart","cellEditorContext","_me$removeEditingList","cellclick","removeEditingListeners","GlobalEvents","addListener","globaltap","onEditorBeforeComplete","context","onEditorComplete","onEditorBeforeCancel","onEditorCancel","muteEvents","onBeforeEditorHide","removeCls","onEditorFinishEdit","getAdjacentEditableCell","isForward","getAdjacent","doAddNewAtEnd","newRecordConfig","clone","getRowFor","displayRecordAtBottom","getEditingContext","normalizeCellContext","startEditing","_cellContext","_grid$focusedCell","_me$onCellEditStart","fromKeyMap","isEmpty","firstVisibleRow","isTree","_cellContext$record","expandTo","focusCell","highlightExternalChange","render","addCls","startEdit","onCellEditStart","triggeredByEvent","_me$afterCellEdit","cancelEdit","finishEditingPromise","afterCellEdit","_me$afterCellEdit2","completeEdit","bindCallback","finalizeCellEdit","waitForAnimations","onCellClickWhileEditing","cellSelector","isTouchEvent","focus","onCellClick","client","_lastCellClicked","timeStamp","_lastCellClickedTime","onTriggerEditEvent","onElementPointerUp","_client$features$cell","cellMenu","onStoreUpdate","refreshEdit","onStoreBeforeSort","_this$editorContext2","isFinishing","onGridRefreshed","isInView","suspendFocusEvents","showBy","resumeFocusEvents","gridSelection","selectedRecords","selectedCells","isActionAvailable","keyCombination","finishAllSelected","isDestroyed","selected","isModel","previous","nextCell","internalNextPrevRow","last","touch","finalizationResult","animate","onElementKeyDown","ctrlKey","input","internalOnKeyEvent","defaultPrevented","internalOnInput","startsWith","stopPropagation","onEditorFocusOut","toCell","relatedTarget","isEditableCellClick","onEditorFocusIn","toWidget","selectAll","onTapOut","bodyContainer","button","editingStoppedByTapOutside","onElementClick","CellMenu","ContextMenuBase","processItems","showContextMenu","eventParams","doSelect","isSelected","shouldShowMenu","enableCellContextMenu","getDataFromEvent","cellData","getCellDataFromEvent","beforeContextMenuShow","cellMenuItems","removeRow","populateCellMenu","weight","onItem","showMenu","ColumnDragToolbar","after","_grid$features$column","columnReorder","beforeDestroy","detachFromColumnReorder","initialized","reorderDetacher","gridheaderdragstart","showToolbar","gridheaderdrag","onDrag","gridheaderabort","hideToolbar","gridheaderdrop","valid","onDrop","onColumnReorderBeforeDestroy","un","buttons","getColumnDragToolbarItems","groups","clearTimeout","buttonHideTimer","L","group","template","EventHelper","waitForTransitionEnd","mode","info","_info$targetElement","dragProxy","getBoundingClientRect","top","hoveringButton","targetElement","matches","buttonEl","setTimeout","TemplateHelper","tpl","btn","BrowserHelper","isTouchDevice","ColumnPicker","getColumnPickerItems","columnStore","createColumnsFromModel","groupByRegion","regions","getSubGrid","menu","buildColumnMenu","createAutoColumnItems","groupByTag","tags","hideable","tag","keys","getColumnsForTag","onBeforeSubMenu","item","itemEl","refreshTagMenu","transformNamedObjectToArray","allFields","fieldName","internal","forColumn","bubbles","subItem","currentRegion","visibleInRegion","itemConfig","menuCls","populateHeaderMenu","showColumnPicker","columnPicker","onColumnToggle","hideColumn","_features$headerMenu","_item$menu","siblingItems","hideItem","headerMenu","enabled","lastVisibleItem","menuItem","siblingItem","sibling","eachWidget","parentItem","ColumnReorder","args","_this$dragHelper","_this$dragHelper2","dragHelper","scrollManager","gridEl","containers","DragHelper","dragThreshold","targetSelector","floatRootOwner","rtlSource","outerElement","headerContainer","monitoringConfig","scrollables","ScrollManager","new","direction","isElementDraggable","ignoreSelectors","join","columnEl","isLast","childLevel","subGrids","ignoreSelector","beforeDragStart","onBeforeDragStart","dragstart","onDragStart","drag","drop","relayEvents","targetHeader","sealedColumns","columnDragToolbar","headerContainerBox","minY","maxY","bottom","fontSize","onInvalidDrop","dragging","onHeader","droppedInRegion","draggedTo","onColumn","toRegion","oldParent","newParent","groupNode","parentElement","vetoed","previousSibling","removeChild","renderContents","onPaint","ColumnResize","configurable","liveResize","resizer","ResizeHelper","handleSelector","beforeresizestart","onBeforeResizeStart","resizestart","onResizeStart","resizing","onResizing","resize","onResize","onCancel","_this$resizer","changeLiveResize","isMobileSafari","resizingColumns","newWidth","afterColumnsResized","elementWidth","GridFieldFilterPicker","FieldFilterPicker","afterConstruct","_me$fields","updateGrid","newGrid","_newGrid$store","getModelClassFields","ownFieldNames","SUPPORTED_FIELD_DATA_TYPES","isSupportedDurationField","definedBy","getColumnFields","allowedFieldNames","_columnStore$records$","modelFields","ArrayHelper","keyBy","allowedNameSet","fromEntries","title","changeFields","newFields","localFields","VersionHelper","deprecate","initClass","GridFieldFilterPickerGroup","FieldFilterPickerGroup","validateConfig","getFilterPickerConfig","canManage","property","fieldTypeMap","int","string","duration","Filter","prioritizeColumns","isMulti","filterBar","closeFilterEditor","dateFormat","_this$filterTip","_this$filterEditorPop","filterTip","filterEditorPopup","beforeFilter","refreshHeaders","reRenderRows","iconElement","Tooltip","forElement","forSelector","getHtml","activeTarget","filterText","isFiltered","columnFilters","filters","allValues","isColumnFiltered","headerEl","textEl","filterIconEl","bullet","columnFilter","_columnFilter$value","_me$store","_me$store$modelRelati","relation","modelRelations","foreignKey","displayValue","_me$isMulti$fields","relatedDisplayField","getDisplayValue","foreignId","_relation$foreignStor","foreignStore","a","b","localeCompare","formatValue","val","operator","createElement","className","latestFilterField","refreshRows","applyFilter","$filter","addFilter","removeFilter","getCurrentMultiFilters","disableFilter","getPopupDateItems","initialValue","changeCallback","closeCallback","filterField","onClose","onClear","onKeydown","onChange","clearSiblingsFields","_value","placeholder","clearable","getPopupNumberItems","onEsc","sourceField","_this$filterEditorPop2","getPopupDurationItems","getPopupStringItems","displayField","rec","multiSelect","getPopupItems","getMultiFilterPopupItems","_grid$store","existingFilter","limitToProperty","propertyFieldCls","operatorFieldCls","valueFieldCls","showFilterEditor","getBy","getFilterType","openPopup","scrollAction","layout","_this$filterEditorPop3","getFieldDefinition","filterType","populateCellMenuWithDateItems","filterDateEquals","filterDateBefore","filterDateAfter","populateCellMenuWithNumberItems","filterNumberEquals","filterNumberLess","filterNumberMore","populateCellMenuWithDurationItems","filterDurationEquals","filterDurationLess","filterDurationMore","populateCellMenuWithStringItems","test","_column$filterable$fi","_column$filterable$fi2","filterStringEquals","filterRemove","columnHasRemovableFilters","filterDisable","columnHasEnabledFilters","canDeleteFilter","callback","editFilter","onStoreBeforeFilter","_column$filterable","CollectionFilter","filterBy","onStoreFilter","renderHeader","showFilterEditorByKey","complexOperators","isIncludedIn","endsWidth","FilterBar","keyStrokeFilterDelay","compactMode","clearStoreFiltersOnHide","ArrowUp","handler","ArrowRight","ArrowDown","ArrowLeft","properties","filterFieldCls","filterFieldInputCls","filterableColumnCls","filterFieldInputSelector","filterableColumnSelector","filterParseRegExp","storeTrackingSuspended","onColumnFilterFieldChange","gridDetacher","beforeElementClick","_this$gridDetacher","destroyFilterBar","getColumnFilterField","updateCompactMode","prop","_columnFilters","_this$grid$columns","destroyColumnFilterField","hideFilterBar","suspendStoreTracking","hideColumnFilterField","resumeStoreTracking","showFilterBar","renderFilterBar","toggleFilterBar","renderColumnFilterField","getColumnFilterable","externalCls","_filterBy","buildFilterValue","inputCls","keyStrokeChangeDelay","defineProperty","_column$editor","_column$editor2","_column$editor3","strictParsing","retainElement","setColumnFilterField","hasFilterFieldStoreData","readUrl","isCombo","configuredValue","refreshData","getDistinctValues","ascending","picker","beforeShow","autoLoad","updateColumnFilterFields","_updatingFields","isDestroying","_this$_columnFilters","parseFilterValue","isDate","isTimeField","match","Date","_column$filterable2","afterColumnsChange","disableGridNavigation","onBeforeElementClick","isClearingFilter","_column$filterable3","_column$filterable4","caseSensitive","Group","groupSortFn","_thisIsAUsedExpression","groupSummary","processConfig","beforeRenderRow","setConfig","clearGroupers","updateRenderer","groupRenderer","updateField","updateGroupSortFn","isGrouped","unshift","groupers","toggleCollapse","collapse","internalToggleCollapse","skipRender","groupRecord","isGroupHeader","expand","renderFromRow","renderFromRecord","afterToggleGroup","collapseAll","groupRecords","expandAll","onBeforeRenderRow","oldRecord","forceInnerHTML","rowClasses","groupHeaderColumn","$groupHeader","buildGroupHeader","assignCls","groupRowFor","childCount","html","applyDefault","groupColumn","groupField","isGroupHeaderColumn","isFirstColumn","groupChildren","getChildElementCount","DomSync","sync","domConfig","onlyChildren","asArray","_hasHtml","headerContainerElement","groupInfo","header","groupAsc","groupDesc","groupRemove","_store$groupers","grouped","removeGrouper","onStoreGroup","curGroupHeaders","getHeaderElementByField","fromRow","instanceMeta","groupParent","modified","oldGroup","onElementTouchStart","getColumnFromElement","touches","_store$groupers2","columnGrouper","g","shiftKey","altKey","DomDataStore","toggleGroup","_focusedCell$record","HeaderMenu","moveColumns","enableHeaderContextMenu","timeAxisColumn","getHeaderDataFromEvent","headerMenuItems","columnToMoveBefore","getColumnToMoveBefore","columnToMoveAfter","getColumnToMoveAfter","movePrev","_oldParent$children","moveNext","_oldParent$children2","Sort","multiSort","ignoreRe","RegExp","sortableCls","sortedCls","sortedAscCls","sortedDescCls","sortFeatureStore","syncHeaderSortState","isPainted","storeSorters","sorterCount","DomClassList","leafColumn","_leafColumn$textWrapp","leafHeader","sortDirection","sortIndex","syncClassList","sortBy","sortAsc","sortDesc","addSortAsc","addSorter","addSortDesc","removeSorter","_column$sortable","Stripe","renderrow","onRenderRow","even","cellContentRange","document","createRange","Row","Base","$config","equal","c1","c2","isDomClassList","_elements","_elementsArray","_cells","_allCells","_regions","lastHeight","lastTop","_dataIndex","_top","_height","isGroupFooter","positionMode","translateElements","positionElements","removeElements","idMap","_index","eachElement","ariaRowIndex","idObj","eachCell","addElement","firstElementChild","getElement","getRectangle","Rectangle","from","elements","cells","getCells","onlyRelease","height","offsetHeight","_rowBorderHeight","updateElementsHeight","storeKnownHeight","classes","updateCls","toggleCls","changeCls","setAttribute","attribute","removeAttribute","isFirst","setTop","setBottom","translate","transform","offsetTop","newTop","recordIndex","_record2","_maxRequestedHeight","_grid$processRowHeigh","oldHeight","oldId","rowElData","_rowHeight","size","rCls","recordCls","transitionDuration","isLinked","hasLinks","lastRecordCls","fixedRowHeight","getRowHeight","maxRequestedHeight","el","_record$children","_record$children2","parentIndex","isExpanded","_columnId","transient","useHeight","processRowHeight","translateFromRow","afterRenderRow","_grid$features","_grid$hasFrameworkRen","cellElementData","rowElementData","cellContent","configuredHeight","rendererData","useRenderer","defaultRenderer","beforeRenderCell","shouldSetContent","print","hasFrameworkRenderer","frameworkPerformsFullRendering","_cellEdit$editorConte","renderTarget","moveContentFromCell","hasObjectContent","hasStringContent","lastDomConfig","htmlEncode","disableHtmlEncode","autoSyncHtml","innerText","setInnerText","node","childNodes","_grid$processCellCont","processCellContent","rendererHtml","editorElement","setStart","setEndBefore","extractContents","Bar","htmlCls","overflowX","_columns","fixCellWidths","flexBasis","cellEl","getBarCellElement","domWidth","setLength","domMinWidth","domMaxWidth","isHeader","getLrPadding","cellLrPadding","ownerDocument","defaultView","getPropertyValue","Footer","refreshContent","contentTemplate","fixFooterWidths","firstPaint","overflowElement","footersElement","getFooter","footerText","RowManager","prependRowBuffer","appendRowBuffer","lastScrollTop","_rows","heightMap","totalKnownHeight","_totalHeight","averageRowHeight","scrollTargetRecordId","refreshDetails","topRowIndex","topRowTop","_rowManager","initWithHeight","isRendering","allCount","preciseRowOffsetHeight","viewHeight","calculateRowCount","reinitialize","returnToTop","topRow","estimateTotalHeight","matchRowCount","numRows","delta","newRows","rowCls","apply","_focusedCell$cell","rowActive","removedRows","_me$getRowFor","onFocusedRowDerender","skipMatchRowCount","allowRowCountShrink","visibleRowCount","ceil","minRowOffsetHeight","maxRenderRowCount","_me$bottomRow","bottomRow","indexDelta","totalHeight","toggleEmptyText","removeAllRows","setPosition","getRowFromElement","getRowAt","y","local","roundPx","HTMLElement","getNextRow","indexOrRow","lastVisibleRow","findLast","bodyHeight","lastFullyVisibleRow","offsetRows","prependBufferHeight","rowOffsetHeight","appendBufferHeight","assertNumber","minRowHeight","oldY","edgeOffset","average","oldAverage","clearKnownHeights","refresh","scrollRowIntoView","block","allHeightsKnown","getOffsetHeight","invalidateKnownHeight","delete","calculateTop","getRecordCoords","roughly","scrollingViewport","_bodyRectangle","refreshBodyRectangle","x","getRecordCoordsByIndex","currentTopIndex","currentBottomIndex","calculateFrom","virtual","Symbol","iterator","storeCount","fromRowIndex","recordsAfter","toRowIndex","leftOverCount","displayRecordAtTop","heightChanged","refreshSuspended","jumpToPosition","newScrollTop","forceRecordIndex","border","accumulated","targetIndex","startIndex","viewportTop","viewportBottom","targetRow","rowCenter","center","viewportCenter","viewport","warpIfNeeded","deltaTop","abs","updateRenderedRows","ignoreError","clientRect","posInfo","fillBelow","fillAbove","correctError","error","fillHeight","accumulatedHeight","recordCount","immediate","renderingRows","unknownCount","estimate","bottomRowTop","newRecord","estimatedTop","pop","_grid$focusedCell2","shift","xAxis","GridScroller","Scroller","addScroller","scroller","xScrollers","addPartner","otherScroller","axes","initScroll","removePartner","updateOverflowX","_this$xScrollers","hideScroll","virtualScrollers","scrollIntoView","Element","subGridScroller","hasOverflow","axis","scrollHeight","Header","changeElement","was","getConfig","reference","maxDepth","headersElement","getColumnConfig","tooltip","depth","role","encodeConfig","calculateMinWidthForSafari","fixHeaderWidths","innerEl","columnsDetacher","initDepths","getHeader","strict","syncIdField","releaseThreshold","gridBodyElementEventHandlers","touchstart","touchmove","touchend","mouseover","mouseout","mousedown","mousemove","mouseup","click","dblclick","keyup","keypress","contextmenu","pointerdown","pointerup","eventProps","toggleHover","setCellHover","Target","longPressTime","enableUndoRedoKeys","initInternalEvents","handledEvents","listeners","bodyElement","eventName","passive","on","focusin","capture","includeSingleAxisMatch","left","right","_document$elementFrom","elementFromPoint","headerData","handleEvent","longPressTimeout","onElementLongPress","longPressPerformed","onFocusGesture","onElementTouchMove","lastTouchTarget","changedTouches","pageX","pageY","touchTarget","mouseoutEvent","MouseEvent","copyProperties","pointerType","dispatchEvent","mouseoverEvent","onElementTouchEnd","cancelable","triggerCellMouseEvent","eventData","_column$onCellClick","onElementMouseDown","skipFocusSelection","isScrollbarOrRowBorderOrSplitterClick","scrollBarWidth","onElementMouseMove","mouseMoveEvent","onElementMouseUp","onElementPointerDown","onHandleElementClick","isContextMenu","isTreeExpander","isUnfocusedRightClick","hasFocus","isMac","_me$focusedCell","navigationEvent","onElementDblClick","onElementMouseOver","scrolling","shouldHover","setHovered","onElementMouseOut","_me$columns$find","_me$checkboxSelection","rowNumberColumnId","rowNumber","checkboxSelectionColumnId","checkboxSelectionColumn","_hoveredCell","prevSelector","prevRow","_me$columns$getById","_hoveredRow","selector","_me$columns$getById2","keyMapOnKeyDown","_me$columns$getById$o","_me$columns$getById3","undoRedoKeyPress","_this$features$cellEd","stm","onUndoKeyPress","clickCellByKey","onElementKeyPress","onElementKeyUp","onElementContextMenu","onInternalResize","oldWidth","_devicePixelRatio","devicePixelRatio","resetScrollBarWidth","_bodyHeight","refreshVirtualScrollbars","updateResponsive","widgetClass","validConfigTypes","object","function","defaultFeatures","_features","feature","registeredInstanceFeatures","featureName","throwIfError","__bryntum_code_editor_changed","errorMessage","_errorDuringConfiguration","Reflect","createFeatureInitializer","constructorArgs","hasFeature","featureProp","getOwnPropertyDescriptor","hasActiveFeature","_this$features","_this$features2","getConfigValue","_this$features$featur","_this$features$featur2","_this$features$featur3","featureConfig","defaultFocusOptions","freeze","disableScrolling","containedFocusable","e","NodeFilter","FILTER_ACCEPT","FILTER_SKIP","FILTER_REJECT","_class","onStoreRecordIdChange","_super$onStoreRecordI","oldValue","isActive","revertFocus","headerContext","tabIndex","navigateFirstCell","navigateFirstColumn","navigateLastCell","navigateLastColumn","navigatePrevPage","navigateNextPage","activateHeader","keyEvent","_column$onKeyDown","onKeyDown","onEscape","stopImmediatePropagation","disableActionable","onTab","display","requestAnimationFrame","onShiftTab","onFirstCell","navigateLeft","onSpace","isActionableLocation","_this$_focusedCell","focusedRecord","_this$_focusedCell2","cellCSSSelector","afterHide","lastFocusedCell","_this$_focusedCell3","focusElement","_this$_focusedCell4","superFocusEl","DOCUMENT_POSITION_PRECEDING","_super$onPaint","defaultFocus","onGridBodyFocusIn","focusEvent","lastTarget","targetCell","currentMouseDown","isMouseDown","_me$onCellNavigate","lastCell","findFocusables","_fromFocusCell","selectOnFocus","_selectActionCell","_isRevertingFocus","preventScroll","_GlobalEvents$current","_GlobalEvents$current2","onCellNavigate","focusable","_focusableFinder","setupTreeWalker","SHOW_ELEMENT","acceptNode","restoreActiveItem","_cellSelector","_cellSelector2","scroll","_me$onCellNavigate2","testCell","subGridRect","bodyRect","cellRect","moveTo","blurCell","clearFocus","fullClear","internalNextPrevCell","_arguments$","_arguments$2","skipSpecialRows","moveToHeader","navigateDown","_arguments$3","navigateUp","_arguments$4","Home","End","PageUp","PageDown","responsiveLevels","small","medium","large","getClosestBiggerLevel","levels","useLevel","minDelta","biggestLevel","level","levelSize","levelWidth","responsiveLevel","oldLevel","levelConfig","validIdTypes","isDataLoadAction","_selectedCells","getDefaultGridSelection","clas","changeSelectionMode","$defaultGridSelection","Proxy","obj","old","updateSelectionMode","oldMode","changed","rowReorder","_me$_selectionListene","_me$_selectionListene2","rowCheckboxSelection","checkboxOnly","includeChildren","includeParents","dragSelect","gripOnly","showGrip","_selectionListenersDetachers","selectiondrag","deselectFilteredOutRecords","deselectAll","insert","_selectionAddedRowNumberColumn","shouldInitCheckboxSelection","initCheckboxSelection","checkboxIndex","checkboxSelectionColumnInsertIndex","afterSelectionModeChange","afterConfigure","_me$items","_me$items$","checkColumnClass","checkboxRenderer","toggleAll","afterSelectionChange","changeSelectedRecordCollection","collection","Collection","updateSelectedRecordCollection","onSelectedRecordCollectionChange","added","removed","selectedRecordCollection","_fromSelection","performSelection","deselectedCells","deselectedRecords","changeSelectedRecordCollectionSilent","_super$bindStore","unbindStore","oldStore","deselect","selectedRecord","selectionChange","prepareSelection","isCellSelectionMode","getSelectedCellsForRecords","concat","updateCheckboxHeader","rebuildIndices","onStoreRemove","_super$onStoreRemove","isCollapse","onStoreDataChange","_super$onStoreDataCha","preserveSelectionOnPageChange","preserveSelectionOnDatasetChange","storage","selectedCell","onStoreRemoveAll","_super$onStoreRemoveA","onCheckChange","select","shiftKeyDown","_lastSelectionChecked","internalSelectRange","allSelected","isPaged","onSelectionDrag","_selectionStartCell","onSelectionEnd","_lastSelectionDragRegion","_lastSelectionDragCell","_isSelectionDragging","enableScrollingCloseToEdges","_clearSelectionOnSelectionDrag","_me$scrollManager$_ac","_me$scrollManager$_ac2","leavingSubGrid","enteringSubGrid","leavingScrollable","enteringScrollable","goingForward","maxX","_activeScroll","horizontal","stopScroll","_lastSelectionDragChange","isRowNumberSelecting","refreshGridSelectionUI","_me$_selectionListene3","_me$_selectionListene4","lastChange","disableScrollingCloseToEdges","selectColumn","addToSelection","_shiftSelectRange","_shiftSelectColumn","fromColumnId","first","sc","cleanSelectionChange","cellSelectorOrId","_cellSelectorOrId","includeRow","recordCellOrId","selectRow","selectRows","spliceSelectedRecords","toRemove","toAdd","assignIf","toSelect","removeCurrentRecordsOnly","deselectRow","deselectRows","recordsOrIds","selectRange","fromId","toId","selection","selectCells","cellSelectors","selectedCellCSSSelector","selectCell","_this$selectCells","deselectCell","_this$deselectCells","deselectCells","toggleSelection","isRowNumber","selectOnKeyboardNavigation","selectCellRange","to","getSelection","isRowSelectionMode","dr","sr","dc","delayUntilMouseUp","detacher","blur","ev","selectors","cs","extendSelectionLeft","extendSelection","extendSelectionRight","extendSelectionUp","extendSelectionDown","dir","_isKeyboardRangeSelecting","fromCellSelector","toCellSelector","_toCellSelector$recor","deselectOnClick","ctrlKeyDown","isMouseLeft","isMouseRight","currentEvent","currentKeyDown","currentTarget","_isAddingToSelection","startCell","adding","delay","continueSelecting","finishSelection","mouseUpEvent","_mouseUpEvent$target","mouseUpSelector","cellSelectorsToDeselect","cellSelectorsToSelect","forceRecordSelection","isDragging","_record$allChildren","allChildren","_record$allChildren2","allChanges","unique","toggleParentSelection","toDeselect","inToSelect","inToDeselect","childIsSelected","fromSelector","toSelector","selectRecords","getRange","fromCell","startRowIndex","endRowIndex","startColIndex","endColIndex","range","rIx","cIx","updateUI","rowMode","deselected","keepCells","keepRecords","triggerSelectionChangeEvent","updateGridSelectionRecords","updateGridSelectionCells","updateGridSelectionColumns","_column$element","_this$selectedRecordC","checkboxPosition","suspendStoreEvents","resumeStoreEvents","fillSubGridColumns","fillFromMaster","compareStateSortIndex","stateSortIndex","statefulEvents","updateStore","_super$updateStore","updateColumns","_super$updateColumns","updateRowManager","manager","_super$updateRowManag","triggerUpdate","finalizeInit","entry","storeScroll","eachSubGrid","_subGrid$collapsed","_beforeCollapseState","suspendRefresh","columnsChanged","needSort","columnState","columnGeneration","generation","subGridState","clearWidthCache","resumeRefresh","refreshFakeScroll","restoreScroll","scrollTop","querySelectorAll","onElementResize","immediatePromise","Promise","resolve","defaultScrollOptions","SubGridScroller","propagate","xDelta","yDelta","getDeltaTo","scrollBy","highlight","then","yPromise","yScroller","xPromise","cancelX","cancelY","all","scrollTo","toX","toY","syncPartners","elementBounds","intersect","sumWidths","t","SubGrid","insertRowsBefore","monitorResize","headerClass","footerClass","scrollerClass","hasCalculatedWidth","footer","virtualScrollerElement","splitterElement","headerSplitter","scrollerSplitter","footerSplitter","addRows","isFirefox","verticalScroller","addEventListener","deltaY","deltaX","isVerticalScroll","scrollEndDetacher","pointerEvents","scrollEnd","async","_me$fakeScroller","fakeScroller","splitterElements","barConfig","changeHeader","changeFooter","toggleSplitterCls","hideSplitter","$showingSplitter","showSplitter","rowElementConfig","cellTabIndex","changeVirtualScrollerElement","references","virtualScrollerWidth","changeSplitterElement","ns","version","viewBox","d","splitterButtons","splitterConfig","trim","changeHeaderSplitter","changeScrollerSplitter","changeFooterSplitter","updateHasFlex","mouseenter","mouseleave","_collapsed","refreshHeader","refreshFooter","_this$footer","deep","fixWidths","totalWidth","syncScrollingPartners","fixRowWidthsInSafariEdge","isSafari","newHeight","syncSplitterButtonPosition","scrollLeft","scrollX","syncFlexedSubCols","onHeightChange","syncParallelSplitters","prevGrid","getPreviousRegion","onSplitterMouseEnter","startSplitterButtonSyncing","onSplitterMouseLeave","stopSplitterButtonSyncing","splitterSyncScrollListener","headerHeight","viewRectangle","updateResizable","splitter","toggleClasses","resizeColumnsToFitContent","overflowingHorizontally","overflowingVertically","scrollWidth","syncOverflowState","syncPartnersOnFrame","createOnFrame","scrollend","onSubGridScrollEnd","forceScrollUpdate","hideOverlayScroller","onSubGridScroll","showOverlayScroller","_scrolling","scrollColumnIntoView","columnHeaderElement","onAddRow","frag","createDocumentFragment","rowElements","fromCache","clearRows","emptyCache","setStartBefore","setEndAfter","deleteContents","addNewRowElement","toggleTransitionClasses","doRemove","nextRegion","getNextRegion","resolveSplitter","splitterOwner","expandedRegions","widthChanged","afterinternalresize","nextRegionWidth","_splitterOwner$startS","afterToggleSubGrid","_width","changeSubGridConfigs","configs","usedRegions","normal","GridBase","subGridConfigs","createSubGrid","subGridColumns","makeChained","subGridConfig","isFirstRegion","onChildAdd","isSubGrid","footerContainer","insertAt","emptyTextEl","onChildRemove","callEachSubGrid","fnName","params","partialReturnValue","getLastRegions","locale","localeName","localeDesc","localeCode","columnsMenu","hideColumnShort","newColumns","lessThan","moreThan","enableFilterBar","disableFilterBar","groupAscending","groupDescending","groupAscendingShort","groupDescendingShort","stopGrouping","stopGroupingShort","moveBefore","moveAfter","collapseColumn","expandColumn","ColumnRename","rename","MergeCells","mergeCells","menuTooltip","Search","searchForValue","sortAscending","sortDescending","addSortAscending","addSortDescending","toggleSortAscending","toggleSortDescending","sortAscendingShort","sortDescendingShort","removeSorterShort","addSortAscendingShort","addSortDescendingShort","columnLabel","cellLabel","toggleRowSelect","RatingColumn","_column$location","loadFailedMessage","syncFailedMessage","unspecifiedFailure","networkFailure","parseFailure","serverResponse","noRows","moveColumnLeft","moveColumnRight","moveColumnTo","RowCopyPaste","copyRecord","cutRecord","pasteRecord","CellCopyPaste","copy","cut","paste","PdfExport","ExportDialog","labelWidth","exportSettings","export","exporterType","fileFormat","alignRows","paperFormat","orientation","repeatHeader","ExportRowsCombo","visible","ExportOrientationCombo","portrait","landscape","SinglePageExporter","singlepage","MultiPageExporter","multipage","exportingPage","currentPage","totalPages","MultiPageVerticalExporter","multipagevertical","RowExpander","loading","LocaleHelper","publishLocale","resolvedPromise","inline","datasetReplaceActions","pageLoad","Panel","Pluggable","State","GridElementEvents","GridFeatures","GridNavigation","GridResponsive","GridSelection","GridState","GridSubGrids","LoadMaskable","delayable","onGridVerticalScroll","bufferedAfterColumnsResized","bufferedElementResize","enableSticky","enableTextSelection","fillLastColumn","showDirty","hideFooters","contentElMutationObserver","trapFocus","ariaElement","mergeCls","emptyText","defaultRowHeight","fullRowRefresh","preserveScrollOnDatasetChange","preserveFocusOnDatasetChange","destroyStore","maskDefaults","cover","columnLines","animateRemovingRows","disableGridRowModelWarning","testPerformance","rowScrollMode","overflowY","contextMenuTriggerEvent","testConfig","_selectedRecords","_verticalScrollHeight","virtualScrollHeight","_scrollTop","finishConfigure","scrollInitialized","LocaleManager","theme","bufferedFixElementHeights","buffer","setGridClassList","onSubGridExpand","onBeforeLocaleChange","_suspendRenderContentsOnColumnsChanged","onLocaleChange","isLoading","onStoreBeforeRequest","changeScrollManager","oldScrollManager","_me$scrollManager","_feature$destroy","compose","class","_cellCls","bodyConfig","hasHeader","updateHideFooters","_this$footerContainer","changeColumns","currentStore","removeAll","isStore","columnsToDestroy","_column$destroy","_me$bodyElement","columnResizeEvent","onColumnsChanged","onColumnsResized","touchConfig","addedColumns","isMove","isSingleFieldChange","repaintOnResize","refreshColumn","insertIndex","cellEls","lastColumnResized","_column$flex","flexedSubCols","query","changeRowManager","oldRowManager","_isRowMeasured","measureRowHeight","requestScrollChange","suffix","idChange","beforeRequest","afterRequest","exception","commit","changeStore","_this$initialConfig$f","getStore","initialConfig","GridRowModel","AjaxStore","_me$_rowManager","onStoreUpdateRecord","forceFullRefresh","refreshFromRowOnStoreAdd","onMaskAutoClose","mask","onStoreAdd","oldIndex","isChild","isExpandAll","hasExpandedOldParent","parentId","ancestorsExpanded","parentRow","bottomIndex","dataStart","dataEnd","atEnd","onStoreException","response","exceptionType","_response$parsedJson","message","parsedJson","applyMaskError","url","syncInfo","_syncInfo$removed","isGroupFieldChange","grouper","applyLoadMask","onStoreAfterRequest","loadMask","masked","needsFullRefreshOnStoreRemove","convertEmptyParentToLeaf","isCollapseAll","rowsToRemove","isAnimating","onTransitionEnd","afterRemove","oldTopIndex","onFlatStoreMove","onStoreReplace","relayStoreDataChange","project","onStoreCommit","_store","_data","preceding","moveRight","optionalL","targetSubGrid","separator","_headerHeight","footerHeight","_footerHeight","isTreeGrouped","_this$features$treeGr","treeGroup","getRecordFromElement","updateAutoHeight","assertBoolean","_columnLines","keyMapElement","fixSizes","colHeaders","onRowManagerChangeTotalHeight","refreshTotalHeight","isCritical","virtualScrollHeightDirty","fixElementHeights","heightInPx","startMonitoring","stopMonitoring","onRowManagerRequestScrollChange","suspendResizeMonitor","afterScroll","onGridVerticalScrollEnd","blockPosition","scrollPromise","recordRect","scrollerRect","virtualBlock","innerOptions","_me$scrollRowIntoView","recursive","scrollCellIntoView","scrollToBottom","scrollToTop","storedScrollState","_subGrid$fakeScroller","updateX","updateY","$measureCellElements","position","visibility","contain","targetEl","body","getRootElement","getElementById","adopt","$removeAfterMeasuring","styles","styleHeight","multiplier","trunc","borderTop","parseFloat","borderBottom","_rowHeightFromStyle","onThemeChange","whenVisible","hasVerticalOverflow","hadHorizontalOverflow","hasHorizontalOverflow","horizontalOverflowChanged","needsPadding","contentHeight","onContentChange","paintListener","triggerPaint","keepScroll","scrollState","renderFooter","refreshContext","onPaintOverride","scrollPad","scrollBarPadElement","bodyOffsetHeight","fonts","status","ready","requireSize","editorConfig","removeEvent","syncMaskCover","rectangleOf","marginTop","maskBody","ret","Mask","loadMaskDefaults","unmaskBody","updateEmptyText","_this$emptyTextEl","_this$firstItem","firstItem","isCommitting","_column$updateReadOnl","getInlineData","storeState","originalModelClass","setVersion"],"mappings":"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"}