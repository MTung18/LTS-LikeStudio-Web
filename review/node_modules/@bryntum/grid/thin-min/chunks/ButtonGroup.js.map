{"version":3,"file":"ButtonGroup.js","sources":["../../../../Core/lib/Core/widget/ButtonGroup.js"],"sourcesContent":["import Container from './Container.js';\nimport Rotatable from './mixin/Rotatable.js';\n\nimport './Button.js';\n\n/**\n * @module Core/widget/ButtonGroup\n */\n\n/**\n * A specialized container that holds buttons, displaying them in a horizontal group with borders adjusted to make them\n * stick together.\n *\n * Trying to add other widgets than buttons will throw an exception.\n *\n * ```javascript\n * new ButtonGroup({\n *     items : [\n *         { icon : 'b-fa b-fa-kiwi-bird' },\n *         { icon : 'b-fa b-fa-kiwi-otter' },\n *         { icon : 'b-fa b-fa-kiwi-rabbit' },\n *         ...\n *     ]\n * });\n * ```\n *\n * @inlineexample Core/widget/ButtonGroup.js\n * @classType buttonGroup\n * @extends Core/widget/Container\n * @widget\n */\nexport default class ButtonGroup extends Container.mixin(Rotatable) {\n\n    /**\n     * Fires when a button in the group is clicked\n     * @event click\n     * @param {Core.widget.Button} source Clicked button\n     * @param {Event} event DOM event\n     */\n\n    /**\n     * Fires when the default action is performed on a button in the group (the button is clicked)\n     * @event action\n     * @param {Core.widget.Button} source Clicked button\n     * @param {Event} event DOM event\n     */\n\n    /**\n     * Fires when a button in the group is toggled (the {@link Core.widget.Button#property-pressed} state is changed).\n     * If you need to process the pressed button only, consider using {@link #event-click} event or {@link #event-action} event.\n     * @event toggle\n     * @param {Core.widget.Button} source Toggled button\n     * @param {Boolean} pressed New pressed state\n     * @param {Event} event DOM event\n     */\n\n    static $name = 'ButtonGroup';\n\n    static type = 'buttongroup';\n\n    static configurable = {\n        defaultType : 'button',\n\n        /**\n         * Custom CSS class to add to element. When using raised buttons (cls 'b-raised' on the buttons), the group\n         * will look nicer if you also set that cls on the group.\n         *\n         * ```\n         * new ButtonGroup({\n         *   cls : 'b-raised,\n         *   items : [\n         *       { icon : 'b-fa b-fa-unicorn', cls : 'b-raised' },\n         *       ...\n         *   ]\n         * });\n         * ```\n         *\n         * @config {String}\n         * @category CSS\n         */\n        cls : null,\n\n        /**\n         * An array of Buttons or typed Button config objects.\n         * @config {ButtonConfig[]|Core.widget.Button[]}\n         */\n        items : null,\n\n        /**\n         * Default color to apply to all contained buttons, see {@link Core.widget.Button#config-color Button#color}.\n         * Individual buttons can override the default.\n         * @config {String}\n         */\n        color : null,\n\n        /**\n         * Set to `true` to turn the ButtonGroup into a toggle group, assigning a generated value to each contained\n         * buttons {@link Core.widget.Button#config-toggleGroup toggleGroup config}. Individual buttons can\n         * override the default.\n         * @config {Boolean}\n         */\n        toggleGroup : null,\n\n        valueSeparator : ',',\n\n        columns : null,\n\n        hideWhenEmpty : true,\n\n        defaultBindProperty : 'value'\n    };\n\n    onChildAdd(item) {\n        super.onChildAdd(item);\n\n        item.ion({\n            click   : 'resetValueCache',\n            toggle  : 'onItemToggle',\n            thisObj : this,\n            // This needs to run before the 'click' event is relayed by this button group, in such listener\n            // the `value` must already be updated\n            prio    : 10000\n        });\n    }\n\n    onChildRemove(item) {\n        item.un({\n            toggle  : 'resetValueCache',\n            click   : 'resetValueCache',\n            thisObj : this\n        });\n        super.onChildRemove(item);\n    }\n\n    onItemToggle(event) {\n        const me = this;\n\n        me.resetValueCache();\n\n        if (!me.isSettingValue && (!me.toggleGroup || event.pressed)) {\n            me.triggerFieldChange({ value : me.value, userAction : true, event });\n        }\n    }\n\n    resetValueCache() {\n        // reset cached value to revalidate next time it's requested\n        this._value = null;\n    }\n\n    createWidget(widget) {\n        const\n            me   = this,\n            type = me.constructor.resolveType(widget.type || 'button');\n\n        if (type.isButton) {\n            if (me.color && !widget.color) {\n                widget.color = me.color;\n            }\n\n            if (me.toggleGroup && !widget.toggleGroup) {\n                if (typeof me.toggleGroup === 'boolean') {\n                    me.toggleGroup = ButtonGroup.generateId('toggleGroup');\n                }\n\n                widget.toggleGroup = me.toggleGroup;\n            }\n        }\n\n        if (me.columns) {\n            widget.width = `${100 / me.columns}%`;\n        }\n\n        widget = super.createWidget(widget);\n\n        me.relayEvents(widget, ['click', 'action', 'toggle']);\n\n        return widget;\n    }\n\n    updateRotate(rotate) {\n        this.eachWidget(btn => {\n            if (btn.rotate !== false) {\n                btn.rotate = rotate;\n            }\n        });\n    }\n\n    get value() {\n        // if we don't have cached value\n        // let's calculate it based on item values\n        if (!this._value) {\n            const values = [];\n\n            // collect pressed item values\n            this.items.forEach(w => {\n                if (w.pressed && w.value !== undefined) {\n                    values.push(w.value);\n                }\n            });\n\n            // build a string\n            this._value = values.join(this.valueSeparator);\n        }\n\n        return this._value;\n    }\n\n    set value(value) {\n        const\n            me       = this,\n            oldValue = me.value;\n\n        if (!Array.isArray(value)) {\n            if (value === undefined || value === null) {\n                value = [];\n            }\n            else if (typeof value == 'string') {\n                value = value.split(me.valueSeparator);\n            }\n            else {\n                value = [value];\n            }\n        }\n\n        me._value = value.join(me.valueSeparator);\n\n        me.isSettingValue = true;\n\n        // Reflect value on items\n        me.items.forEach(w => {\n            if (w.value !== undefined) {\n                w.pressed = value.includes(w.value);\n            }\n        });\n\n        me.isSettingValue = false;\n\n        if (!me.isConfiguring && oldValue !== me.value) {\n            me.triggerFieldChange({ value : me.value, userAction : false });\n        }\n    }\n\n    updateDisabled(disabled) {\n        this.items.forEach(button => button.disabled = disabled || (!button.ignoreParentReadOnly && this.readOnly));\n    }\n\n    updateReadOnly(readOnly) {\n        super.updateReadOnly(readOnly);\n\n        this.updateDisabled(this.disabled);\n    }\n\n    get widgetClassList() {\n        const classList = super.widgetClassList;\n        // if the buttons should be shown in rows\n        this.columns && classList.push('b-columned');\n        return classList;\n    }\n}\n\n// Register this widget type with its Factory\nButtonGroup.initClass();\n"],"names":["ButtonGroup","Container","mixin","Rotatable","onChildAdd","item","super","ion","click","toggle","thisObj","this","prio","onChildRemove","un","onItemToggle","event","me","resetValueCache","isSettingValue","toggleGroup","pressed","triggerFieldChange","value","userAction","_value","createWidget","widget","constructor","resolveType","type","isButton","color","generateId","columns","width","relayEvents","updateRotate","rotate","eachWidget","btn","values","items","forEach","w","undefined","push","join","valueSeparator","oldValue","Array","isArray","split","includes","isConfiguring","updateDisabled","disabled","button","ignoreParentReadOnly","readOnly","updateReadOnly","widgetClassList","classList","_defineProperty","defaultType","cls","hideWhenEmpty","defaultBindProperty","initClass","_$name"],"mappings":"4EA4Be,MAAMA,UAAoBC,EAAUC,MAAMC,IAkErDC,WAAWC,GACPC,MAAMF,WAAWC,GACjBA,EAAKE,IAAI,CACLC,MAAU,kBACVC,OAAU,eACVC,QAAUC,KAGVC,KAAU,MAGlBC,cAAcR,GACVA,EAAKS,GAAG,CACJL,OAAU,kBACVD,MAAU,kBACVE,QAAUC,OAEdL,MAAMO,cAAcR,GAExBU,aAAaC,GACT,MAAMC,EAAKN,KACXM,EAAGC,kBACED,EAAGE,gBAAoBF,EAAGG,cAAeJ,EAAMK,SAChDJ,EAAGK,mBAAmB,CAAEC,MAAQN,EAAGM,MAAOC,YAAa,EAAMR,MAAAA,IAGrEE,kBAEIP,KAAKc,OAAS,KAElBC,aAAaC,GACT,MACIV,EAAON,KAkBX,OAjBWM,EAAGW,YAAYC,YAAYF,EAAOG,MAAQ,UAC5CC,WACDd,EAAGe,QAAUL,EAAOK,QACpBL,EAAOK,MAAQf,EAAGe,OAElBf,EAAGG,cAAgBO,EAAOP,cACI,kBAAnBH,EAAGG,cACVH,EAAGG,YAAcpB,EAAYiC,WAAW,gBAE5CN,EAAOP,YAAcH,EAAGG,cAG5BH,EAAGiB,UACHP,EAAOQ,MAAW,IAAMlB,EAAGiB,QAAX,KAEpBP,EAASrB,MAAMoB,aAAaC,GAC5BV,EAAGmB,YAAYT,EAAQ,CAAC,QAAS,SAAU,WACpCA,EAEXU,aAAaC,GACT3B,KAAK4B,YAAWC,KACO,IAAfA,EAAIF,SACJE,EAAIF,OAASA,MAIzBf,YAGI,IAAKZ,KAAKc,OAAQ,CACd,MAAMgB,EAAS,GAEf9B,KAAK+B,MAAMC,SAAQC,IACXA,EAAEvB,cAAuBwB,IAAZD,EAAErB,OACfkB,EAAOK,KAAKF,EAAErB,UAItBZ,KAAKc,OAASgB,EAAOM,KAAKpC,KAAKqC,gBAEnC,OAAOrC,KAAKc,OAEhBF,UAAUA,GACN,MACIN,EAAWN,KACXsC,EAAWhC,EAAGM,MACb2B,MAAMC,QAAQ5B,KAEXA,EADAA,MAAAA,EACQ,GAEa,iBAATA,EACJA,EAAM6B,MAAMnC,EAAG+B,gBAGf,CAACzB,IAGjBN,EAAGQ,OAASF,EAAMwB,KAAK9B,EAAG+B,gBAC1B/B,EAAGE,gBAAiB,EAEpBF,EAAGyB,MAAMC,SAAQC,SACGC,IAAZD,EAAErB,QACFqB,EAAEvB,QAAUE,EAAM8B,SAAST,EAAErB,WAGrCN,EAAGE,gBAAiB,EACfF,EAAGqC,eAAiBL,IAAahC,EAAGM,OACrCN,EAAGK,mBAAmB,CAAEC,MAAQN,EAAGM,MAAOC,YAAa,IAG/D+B,eAAeC,GACX7C,KAAK+B,MAAMC,SAAQc,GAAUA,EAAOD,SAAWA,IAAcC,EAAOC,sBAAwB/C,KAAKgD,WAErGC,eAAeD,GACXrD,MAAMsD,eAAeD,GACrBhD,KAAK4C,eAAe5C,KAAK6C,UAE7BK,sBACI,MAAMC,EAAYxD,MAAMuD,gBAGxB,OADAlD,KAAKuB,SAAW4B,EAAUhB,KAAK,cACxBgB,GAGfC,EAvLqB/D,UAqBF,eAAa+D,EArBX/D,SAsBH,eAAa+D,EAtBV/D,iBAuBK,CAClBgE,YAAc,SAkBdC,IAAM,KAKNvB,MAAQ,KAMRV,MAAQ,KAORZ,YAAc,KACd4B,eAAiB,IACjBd,QAAU,KACVgC,eAAgB,EAChBC,oBAAsB,UAwH9BnE,EAAYoE,YACZpE,EAAYqE,OAAS"}