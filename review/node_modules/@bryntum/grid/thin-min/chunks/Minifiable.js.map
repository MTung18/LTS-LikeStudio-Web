{"version":3,"file":"Minifiable.js","sources":["../../../../Core/lib/Core/mixin/Hoverable.js","../../../../Core/lib/Core/util/drag/DragTipProxy.js","../../../../Core/lib/Core/widget/panel/PanelCollapserOverlay.js","../../../../Core/lib/Core/widget/mixin/Minifiable.js"],"sourcesContent":["import Delayable from './Delayable.js';\nimport DomClassList from '../helper/util/DomClassList.js';\nimport EventHelper from '../helper/EventHelper.js';\n\n/**\n * @module Core/mixin/Hoverable\n */\n\nconst\n    EDGES = {\n        e : 'b-hover-edge',\n        t : 'b-hover-top',\n        r : 'b-hover-right',\n        b : 'b-hover-bottom',\n        l : 'b-hover-left'\n    },\n    EDGE_CLASSES = {\n        [EDGES.e] : 1,\n        [EDGES.t] : 1,\n        [EDGES.r] : 1,\n        [EDGES.b] : 1,\n        [EDGES.l] : 1\n    },\n    ZONES = {\n        t  : [EDGES.e, EDGES.t],\n        r  : [EDGES.e, EDGES.r],\n        b  : [EDGES.e, EDGES.b],\n        l  : [EDGES.e, EDGES.l],\n        tr : [EDGES.e, EDGES.t, EDGES.r],\n        bl : [EDGES.e, EDGES.b, EDGES.l],\n        tl : [EDGES.e, EDGES.t, EDGES.l],\n        br : [EDGES.e, EDGES.b, EDGES.r]\n    };\n\n/**\n * This mixin provides mouse hover tracking.\n * ```\n *  class Tracker extends Base.mixin(Hoverable) {\n *      hoverEnter(leaving) {\n *          // this.hoverTarget has been entered from \"leaving\"\n *          // this.hoverTarget will never be null, but leaving may be null\n *      }\n *\n *      hoverLeave(leaving) {\n *          // this.hoverTarget has been entered from \"leaving\"\n *          // this.hoverTarget may be null, but leaving will never be null\n *      }\n *\n *      hoverMove(event) {\n *          // called when a mousemove is made within a hover target\n *          // this.hoverTarget will never be null\n *      }\n *  }\n *\n *  let tracker = new Tracker({\n *      hoverRootElement : document.body,\n *      hoverSelector    : '.hoverable'\n *  });\n * ```\n * @mixin\n * @internal\n */\nexport default Target => class Hoverable extends Target.mixin(Delayable) {\n    static get $name() {\n        return 'Hoverable';\n    }\n\n    //region Configs\n\n    static get configurable() {\n        return {\n            /**\n             * A CSS class to add to the {@link #config-hoverTarget target} element.\n             * @config {String}\n             */\n            hoverCls : null,\n\n            /**\n             * A CSS class to add to the {@link #config-hoverTarget target} element to enable CSS animations. This class\n             * is added after calling {@link #function-hoverEnter}.\n             * @config {String}\n             */\n            hoverAnimationCls : null,\n\n            /**\n             * A CSS class to add to the {@link #config-hoverRootElement root} element.\n             * @config {String}\n             */\n            hoverRootCls : null,\n\n            /**\n             * A CSS class to add to the {@link #config-hoverRootElement root} element when there is an active\n             * {@link #config-hoverTarget target}.\n             * @config {String}\n             */\n            hoverRootActiveCls : null,\n\n            /**\n             * The number of milliseconds to delay notification of changes in the {@link #config-hoverTarget}.\n             * @config {Number}\n             */\n            hoverDelay : null,\n\n            /**\n             * The current element that the cursor is inside as determined by `mouseover` and `mouseout`. Changes in\n             * this config trigger re-evaluation of the {@link #config-hoverSelector} to determine if there is a\n             * {@link #config-hoverTarget}.\n             * @config {HTMLElement}\n             * @private\n             */\n            hoverElement : null,\n\n            /**\n             * An element to ignore. Mouse entry into this element will not trigger a change in either of the\n             * {@link #config-hoverElement} or {@link #config-hoverTarget} values.\n             * @config {HTMLElement}\n             */\n            hoverIgnoreElement : null,\n\n            /**\n             * This property is a string containing one character for each edge that is hoverable. For example, a\n             * value of \"tb\" indicates that the top and bottom edges are hoverable.\n             * @config {String}\n             */\n            hoverEdges : null,\n\n            /**\n             * When {@link #config-hoverEdges} is used, this value determines the size (in pixels) of the edge. When\n             * the cursor is within this number of pixels of an edge listed in `hoverEdges`, the appropriate CSS class\n             * is added to the {@link #config-hoverTarget}:\n             *\n             *  - `b-hover-top`\n             *  - `b-hover-right`\n             *  - `b-hover-bottom`\n             *  - `b-hover-left`\n             *\n             * Depending on the values of `hoverEdges`, it is possible to have at most two of these classes present at\n             * any one time (when the cursor is in a corner).\n             * @config {Number}\n             * @default\n             */\n            hoverEdgeSize : 10,\n\n            /**\n             * The outer element where hover tracking will operate (attach events to it and use as root limit when\n             * looking for ancestors).\n             *\n             * A common choice for this will be `document.body`.\n             * @config {HTMLElement}\n             */\n            hoverRootElement : {\n                $config : 'nullify',\n\n                value : null\n            },\n\n            /**\n             * A selector for the [closest](https://developer.mozilla.org/en-US/docs/Web/API/Element/closest) API to\n             * determine the actual element of interest. This selector is used to process changes to the\n             * {@link #config-hoverElement} to determine the {@link #config-hoverTarget}.\n             * @config {String}\n             */\n            hoverSelector : null,\n\n            /**\n             * The currently active hover target. This will be the same as {@link #config-hoverElement} unless there is\n             * a {@link #config-hoverSelector}.\n             * @config {HTMLElement}\n             */\n            hoverTarget : {\n                $config : 'nullify',\n\n                value : null\n            },\n\n            /**\n             * Set to `true` to include tracking of `mousemove` events for the active {@link #config-hoverTarget}. This\n             * is required for the {@link #function-hoverMove} method to be called.\n             * @config {Boolean}\n             * @default false\n             */\n            hoverTrack : null,\n\n            /**\n             * A string value containing one character per active edge (e.g., \"tr\").\n             * @config {String}\n             * @private\n             */\n            hoverZone : null\n        };\n    }\n\n    static get delayable() {\n        return {\n            setHoverTarget : 0\n        };\n    }\n\n    //endregion\n    //region State Handling\n\n    /**\n     * This method is called when the cursor enters the {@link #config-hoverTarget}. The `hoverTarget` will not be\n     * `null`.\n     * @param {HTMLElement} leaving The element that was previously the `hoverTarget`. This value may be null.\n     */\n    hoverEnter(leaving) {\n        // template\n    }\n\n    /**\n     * This method should return true if the given `element` should be ignored. By default, this is `true` if the\n     * `element` is contained inside the {@link #config-hoverIgnoreElement}.\n     * @param {HTMLElement} element\n     * @returns {Boolean}\n     * @protected\n     */\n    hoverIgnore(element) {\n        return this.hoverIgnoreElement?.contains(element);\n    }\n\n    /**\n     * This method is called when the cursor leaves the {@link #config-hoverTarget}. The `hoverTarget` may be `null`\n     * or refer to the new `hoverTarget`\n     * @param {HTMLElement} leaving The element that was previously the `hoverTarget`. This value will not be null.\n     */\n    hoverLeave(leaving) {\n        // template\n    }\n\n    /**\n     * This method is called when the mouse moves within a {@link #config-hoverTarget}, but only if enabled by the\n     * {@link #config-hoverTrack} config.\n     * @param {Event} event\n     */\n    hoverMove(event) {\n        // template\n    }\n\n    //endregion\n    //region Events\n\n    onHoverMouseMove(event) {\n        const\n            me = this,\n            { hoverEdges, hoverEdgeSize, hoverTarget } = me;\n\n        if (hoverTarget) {\n            if (hoverEdges) {\n                const\n                    { top, left, width, height, right, bottom } = hoverTarget.getBoundingClientRect(),\n                    { clientX, clientY } = event,\n                    centerX = left + width / 2,\n                    centerY = top + height / 2,\n                    t = clientY <  (hoverEdgeSize ? top    + hoverEdgeSize : centerY),\n                    r = clientX >= (hoverEdgeSize ? right  - hoverEdgeSize : centerX),\n                    b = clientY >= (hoverEdgeSize ? bottom - hoverEdgeSize : centerY),\n                    l = clientX <  (hoverEdgeSize ? left   + hoverEdgeSize : centerX),\n                    tb = ((t || b) ? (t ? 't' : 'b') : ''),\n                    rl = ((r || l) ? (r ? 'r' : 'l') : '');\n\n                me.hoverZone = (hoverEdges.includes(tb) ? tb : '') + (hoverEdges.includes(rl) ? rl : '');\n            }\n\n            me.hoverEvent = event;\n            me.hoverTrack && me.hoverMove(event);\n        }\n    }\n\n    onHoverMouseOver(event) {\n        this.hoverEvent = event;\n        this.hoverElement = event.target;\n    }\n\n    onHoverMouseOut(event) {\n        this.hoverEvent = event;\n        this.hoverElement = event.relatedTarget;\n    }\n\n    //endregion\n    //region Configs\n\n    // hoverDelay\n\n    updateHoverDelay(delay) {\n        this.setHoverTarget.delay = delay;\n    }\n\n    // hoverEdges\n\n    changeHoverEdges(edges) {\n        return (edges === true) ? 'trbl' : (edges || '').replace('v', 'tb').replace('h', 'lr');\n    }\n\n    updateHoverEdges() {\n        this.syncHoverListeners();\n    }\n\n    // hoverElement\n\n    changeHoverElement(element) {\n        if (!this.hoverIgnore(element)) {\n            return element;\n        }\n    }\n\n    updateHoverElement(hoverEl) {\n        const { hoverSelector } = this;\n\n        if (hoverSelector) {\n            hoverEl = hoverEl?.closest(hoverSelector);\n        }\n\n        this.setHoverTarget(hoverEl);  // this may be delayed\n    }\n\n    // hoverRootElement\n\n    updateHoverRootElement(rootEl, was) {\n        const { hoverRootCls } = this;\n\n        if (hoverRootCls) {\n            was?.classList.remove(hoverRootCls);\n            rootEl?.classList.add(hoverRootCls);\n        }\n\n        this.syncHoverListeners();\n    }\n\n    // hoverTarget\n\n    changeHoverTarget(hoverEl, was) {\n        if (was) {\n            this.hoverZone = null;\n        }\n\n        return hoverEl;\n    }\n\n    updateHoverTarget(hoverEl, was) {\n        const\n            me = this,\n            { hoverCls, hoverAnimationCls, hoverRootActiveCls, hoverRootElement } = me;\n\n        if (hoverRootActiveCls) {\n            hoverRootElement?.classList[hoverEl ? 'add' : 'remove'](hoverRootActiveCls);\n        }\n\n        if (was) {\n            hoverCls && was.classList.remove(hoverCls);\n            hoverAnimationCls && was.classList.remove(hoverAnimationCls);\n\n            me.hoverLeave(was);\n        }\n\n        if (hoverEl) {\n            hoverCls && hoverEl.classList.add(hoverCls);\n\n            me.hoverEnter(was);\n\n            if (me.hoverTrack) {\n                me.hoverMove(me.hoverEvent);\n            }\n\n            if (hoverAnimationCls) {\n                hoverEl.getBoundingClientRect();   // force layout so next change starts animation\n                hoverEl.classList.add(hoverAnimationCls);\n            }\n        }\n    }\n\n    // hoverTrack\n\n    updateHoverTrack() {\n        this.syncHoverListeners();\n    }\n\n    // hoverZone\n\n    updateHoverZone(zone) {\n        const { hoverAnimationCls, hoverTarget } = this;\n\n        if (hoverTarget) {\n            const\n                { className } = hoverTarget,\n                cls = DomClassList.change(className, /* add= */zone ? ZONES[zone] : null, /* remove= */EDGE_CLASSES);\n\n            if (className !== cls) {\n                hoverTarget.className = cls;\n\n                if (zone && hoverAnimationCls) {\n                    hoverTarget.classList.remove(hoverAnimationCls);\n                    hoverTarget.getBoundingClientRect();   // force layout so next change starts animation\n                    hoverTarget.classList.add(hoverAnimationCls);\n                }\n            }\n        }\n    }\n\n    //endregion\n\n    //region Misc\n\n    setHoverTarget(target) {\n        // this method runs later based on the hoverDelay\n        this.hoverTarget = target;\n    }\n\n    syncHoverListeners() {\n        const\n            me = this,\n            element = me.hoverRootElement,\n            listeners = {\n                element,\n                thisObj   : me,\n                mouseover : 'onHoverMouseOver',\n                mouseout  : 'onHoverMouseOut'\n            };\n\n        if (me.hoverTrack || me.hoverEdges) {\n            listeners.mousemove = 'onHoverMouseMove';\n        }\n\n        me._hoverRootDetacher?.();\n        me._hoverRootDetacher = element && EventHelper.on(listeners);\n    }\n\n    //endregion\n};\n","import DragProxy from './DragProxy.js';\nimport Widget from '../../widget/Widget.js';\nimport Rectangle from '../../helper/util/Rectangle.js';\n\nimport '../../widget/Tooltip.js';\n\n/**\n * @module Core/util/drag/DragTipProxy\n */\n\n/**\n * This drag proxy manages a {@link #config-tooltip} (or derived class) and aligns the tooltip to the current drag\n * position adjusted by the {@link #config-align} config.\n * @extends Core/util/drag/DragProxy\n * @classtype tip\n * @internal\n */\nexport default class DragTipProxy extends DragProxy {\n    static get type() {\n        return 'tip';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Controls how the tooltip will be aligned to the current drag position.\n             *\n             * See {@link Core.helper.util.Rectangle#function-alignTo} for details.\n             * @config {String}\n             * @default\n             */\n            align : 't10-b50',\n\n            /**\n             * The number of pixels to offset from the drag position.\n             * @config {Number}\n             * @default\n             */\n            offset : 20,\n\n            /**\n             * The tooltip to be shown, hidden and repositioned to track the drag position.\n             * @config {Core.widget.Tooltip}\n             */\n            tooltip : {\n                $config : ['lazy', 'nullify'],\n\n                value : {\n                    type : 'tooltip'\n                }\n            }\n        };\n    }\n\n    open() {\n        this.getConfig('tooltip');  // trigger creation\n    }\n\n    close() {\n        this.tooltip?.hide();\n    }\n\n    dragMove(drag) {\n        const\n            { offset, tooltip } = this,\n            { event } = drag;\n\n        if (tooltip) {\n            if (!tooltip.isVisible) {\n                tooltip.show();\n            }\n\n            tooltip.alignTo({\n                align  : this.align,\n                target : new Rectangle(event.clientX - offset, event.clientY - offset, offset * 2, offset * 2)\n            });\n        }\n    }\n\n    changeTooltip(config, existing) {\n        return Widget.reconfigure(existing, config, /* owner = */ this);\n    }\n}\n\nDragTipProxy.initClass();\n","import Animator from '../../util/Animator.js';\nimport PanelCollapser from './PanelCollapser.js';\nimport Delayable from '../../mixin/Delayable.js';\nimport ObjectHelper from '../../helper/ObjectHelper.js';\nimport EventHelper from '../../helper/EventHelper.js';\nimport DomHelper from '../../helper/DomHelper.js';\nimport DomClassList from '../../helper/util/DomClassList.js';\n\n/**\n * @module Core/widget/panel/PanelCollapserOverlay\n */\n\nconst\n    { dockIsHorz } = PanelCollapser.maps,\n    collapseExposeEdge = {\n        top    : 0,\n        down   : 0,\n        left   : 1,\n        bottom : 2,\n        up     : 2,\n        right  : 3\n    },\n    emptyObject = {},\n    translateByDir = {\n        up : {\n            from : `translate(0,0)`,\n            to   : 'translate(0,-100%)'\n        },\n        down : {\n            from : `translate(0,0)`,\n            to   : 'translate(0,100%)'\n        },\n        left : {\n            from : `translate(0,0)`,\n            to   : 'translate(-100%,0)'\n        },\n        right : {\n            from : `translate(0,0)`,\n            to   : 'translate(100%,0)'\n        }\n    };\n\n/**\n * A panel collapse implementation that adds the ability to reveal the collapsed panel as a floating overlay.\n * @extends Core/widget/panel/PanelCollapser\n * @classtype overlay\n */\nexport default class PanelCollapserOverlay extends PanelCollapser.mixin(Delayable) {\n    static get $name() {\n        return 'PanelCollapserOverlay';\n    }\n\n    static get type() {\n        return 'overlay';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * The number of milliseconds to wait once the mouse leaves a {@link Core.widget.Panel#config-revealed}\n             * panel before returning to an unrevealed state. Clicking outside the revealed panel will immediately\n             * return the panel to its collapsed state.\n             *\n             * This may be disabled by configuring {@link #config-autoClose} as `null`.\n             *\n             * If this value is negative, the panel will not automatically recollapse due to the mouse leaving, however,\n             * clicks outside the panel will still recollapse it.\n             *\n             * If this value is `null`, the panel will not automatically recollapse for either outside clicks or if\n             * the mouse leaves the panel.\n             * @config {Number}\n             * @default\n             */\n            autoCloseDelay : 1000,\n\n            /**\n             * By default, clicking outside the revealed overlay hides the revealed overlay.\n             *\n             * If the revealed overlay was shown using the {@link #property-recollapseTool}\n             * then moving the mouse outside of the revealed overlay hides the revealed overlay.\n             *\n             * Configure this as `false` to disable auto hiding, making overlayed\n             * state permanent, and changeable using the {@link #function-toggleReveal} method.\n             * @config {Boolean}\n             * @default\n             */\n            autoClose : true,\n\n            revealing : {\n                value   : null,\n                $config : null,\n                default : false\n            },\n\n            /**\n             * The reveal/hide tool which slides the collapsed panel over the top of the UI.\n             * @member {Core.widget.Tool} recollapseTool\n             */\n            /**\n             * The reveal/hide tool which slides the collapsed panel over the top of the UI.\n             *\n             * The `type` of this instance should not be changed but the tool instance can be\n             * configured in other ways via this config property.\n             * @config {ToolConfig|Core.widget.Tool}\n             */\n            recollapseTool : {\n                type       : 'collapsetool',\n                cls        : 'b-recollapse',\n                collapsify : 'overlay',\n\n                handler() {\n                    // NOTE: As a tool, our this pointer is the Panel so we use it to access the current collapser\n                    this.collapsible?.toggleReveal();\n                }\n            }\n        };\n    }\n\n    static get delayable() {\n        return {\n            doAutoClose : 0\n        };\n    }\n\n    doAutoClose() {\n        this.toggleReveal(false);\n    }\n\n    updateAutoCloseDelay(delay) {\n        const { doAutoClose } = this;\n\n        if (!(doAutoClose.suspended = delay == null || delay < 0)) {\n            doAutoClose.delay = delay;\n            doAutoClose.immediate = !delay;\n        }\n    }\n\n    changeRecollapseTool(tool) {\n        const\n            me = this,\n            { panel } = me;\n\n        if (me.isConfiguring || me.isDestroying || !panel || panel.isDestroying) {\n            return tool;\n        }\n\n        panel.tools = {\n            recollapse : tool\n        };\n    }\n\n    beforeCollapse(operation) {\n        if (super.beforeCollapse(operation) === false) {\n            return false;\n        }\n\n        if (this.panel.revealed) {\n            operation.animation = null;\n        }\n    }\n\n    applyHeaderDock(collapsed, flush = true) {\n        this.panel?.recompose();\n\n        super.applyHeaderDock(collapsed, flush);\n    }\n\n    collapseBegin(operation) {\n        const\n            me = this,\n            { collapseDir, innerElement } = me,\n            { animation } = operation,\n            { collapseTool, panel } = me;\n\n        me.configuredWidth = panel._lastWidth;\n        me.configuredHeight = panel._lastHeight;\n\n        me.applyHeaderDock(true);\n\n        // const innerElementRect = me.lockInnerSize();\n        me.lockInnerSize();\n\n        collapseTool?.element.classList.add('b-collapsed');\n\n        if (animation) {\n            panel.element.classList.add('b-collapsing');\n\n            animation.element = innerElement;\n            animation.transform = translateByDir[collapseDir];\n            operation.animation = Animator.run(animation);\n        }\n    }\n\n    onComplete(action) {\n        super.onComplete(action);\n\n        const\n            me          = this,\n            { panel }   = me,\n            { element } = panel;\n\n        me.autoCloseLeaveDetacher = me.autoCloseLeaveDetacher?.();\n        me.autoCloseClickDetacher = me.autoCloseClickDetacher?.();\n\n        // The act of hiding the revealed panel (\"unrevealing\") causes a mouseleave event (once the panel slides out\n        // from under the cursor) and that starts the autoClose timer. If the user then reveals the panel again within\n        // the 1sec delay (by default), the autoClose timer will still fire and unreveal the panel.\n        me.doAutoClose.cancel();\n\n        if (action === 'reveal' && me.autoClose) {\n            // Only listen for mouseleave to close if we contain focus.\n            // If we do not, then we have been revealed using the API from some other\n            // part of the UI, so mouseleave closing would not be appropriate.\n            if (panel.containsFocus) {\n                me.autoCloseLeaveDetacher = EventHelper.on({\n                    element,\n\n                    mouseenter : ev => {\n                        me.doAutoClose.cancel();\n                    },\n\n                    mouseleave : ev => {\n                        me.doAutoClose();\n                    }\n                });\n            }\n\n            me.autoCloseClickDetacher = EventHelper.on({\n                element   : document.body,\n                thisObj   : panel,\n                mousedown : ev => {\n                    if (ev.target !== element && !element.contains(ev.target) && me.autoCloseDelay != null) {\n                        // Detect the UI element which invoked the reveal.\n                        // If the panel contains focus, use the \"from\" element.\n                        // If not, then the focus is still on the invoking element.\n                        const el = panel.containsFocus && panel.focusInEvent?.relatedTarget ||\n                            DomHelper.getActiveElement(element);\n\n                        if (!el?.contains(ev.target)) {\n                            me.doAutoClose.now();\n                        }\n                    }\n                }\n            });\n        }\n    }\n\n    expandBegin(operation) {\n        const\n            me = this,\n            { animation } = operation,\n            { collapseDir, collapseTool, innerElement, panel } = me,\n            { element } = panel;\n\n        element.classList.remove('b-collapsed', 'b-collapsing');\n        me.restoreConfiguredSize();\n        me.lockInnerSize(false);\n        me.lockInnerSize();\n\n        collapseTool?.element.classList.remove('b-collapsed');\n\n        if (animation) {\n            element.classList.add('b-collapsed', 'b-expanding');\n\n            animation.element = innerElement;\n            animation.transform = {\n                from : translateByDir[collapseDir].to,\n                to   : translateByDir[collapseDir].from\n            };\n\n            operation.animation = Animator.run(animation);\n        }\n    }\n\n    expandEnd(operation) {\n        super.expandEnd(operation);\n\n        const { panel } = this;\n\n        if (operation.completed) {\n            panel.revealed = false;\n        }\n\n        panel.element.classList.remove('b-expanding');\n    }\n\n    expandRevert(operation) {\n        super.expandRevert(operation);\n\n        this.panel.element.classList.add('b-expanding');\n    }\n\n    get innerElement() {\n        return this.panel.overlayElement;\n    }\n\n    get innerSizeElement() {\n        return this.panel.element;\n    }\n\n    get toolsConfig() {\n        const\n            me = this,\n            { direction } = me,\n            config = super.toolsConfig,\n            tool = me.recollapseTool;\n\n        if (tool) {\n            return {\n                ...config,\n\n                recollapse : tool && ObjectHelper.assign({\n                    direction : direction.toLowerCase()\n                }, tool)\n            };\n        }\n\n        return config;\n    }\n\n    lockInnerSize(lock = true) {\n        const\n            me = this,\n            { panel } = me,\n            panelRect = lock && panel.rectangle(),  // must read this before we call super\n            inset = lock ? [0, 0, 0, 0] : '',\n            // now we can call super:\n            innerRect = super.lockInnerSize(lock);\n\n        // The panel overlay is visible because we switch to \"overflow:visible\" in collapsed state. By doing this,\n        // however, the header animation undesirably escapes as well. Fortunately, we can use the clip-path to hide\n        // this by only allowing the desired side to escape while all other sides remain clipped. Even more fortunate\n        // for us is that clip-path is expressed as an inset from the normal rectangle of the element (so we don't\n        // need to adjust it if the collapsed panel is resized), and further, unlike CSS path style, clip-path works\n        // for all elements not only absolutely positioned ones.\n        if (lock) {\n            // TODO see if there's a way to read the box-shadow style to pick up the right value (10 is the default)\n            inset[collapseExposeEdge[me.collapseDir]] = `-${panelRect[me.collapseDim] + 10}px`;\n        }\n\n        panel.element.style.clipPath = lock ? `inset(${inset.join(' ')})` : '';\n\n        return innerRect;\n    }\n\n    onOverlayTransitionDone(ev) {\n        const\n            me = this,\n            { panel } = me;\n\n        if (ev.srcElement === panel.overlayElement && me.revealing) {\n            me.revealing = false;\n\n            me.onComplete(panel.revealed ? 'reveal' : 'unreveal');\n        }\n    }\n\n    onRevealerClick() {\n        this.toggleReveal();\n    }\n\n    splitHeaderItems({ as, dock } = emptyObject) {\n        return this.panel?.splitHeaderItems({ as, dock, overlay : true });\n    }\n\n    /**\n     * Toggles the revealed state of the Panel to match the passed boolean flag.\n     * @param {Boolean} [state]  If not specified, this method toggles current state. Otherwise, pass `true` to reveal\n     * the overlay, or `false` to hide it.\n     */\n    toggleReveal(state) {\n        const\n            { panel }   = this,\n            { element } = panel;\n\n        if (panel.collapsed) {\n            if (state == null) {\n                state = !panel.revealed;\n            }\n\n            if (panel.revealed !== state && panel.trigger('beforeToggleReveal', { reveal : state }) !== false) {\n                // This is essentially a hide, so move focus back to whence it came\n                if (!state && element.contains(DomHelper.getActiveElement(element))) {\n                    panel.revertFocus(true);\n                }\n                this.revealing = true;\n                panel.revealed = state;\n            }\n        }\n    }\n\n    updateRevealing(value) {\n        const\n            me = this,\n            horzDirRe = /left|right/i,\n            { panel } = me,\n            dim = horzDirRe.test(me.collapseDir) ? 'height' : 'width';\n\n        if (panel) {\n            me.innerElement.style[dim] = '0px';\n            me.innerElement.style[`min-${dim}`] = '100%';\n\n            panel.element.classList[value ? 'add' : 'remove']('b-panel-overlay-revealing');\n        }\n    }\n\n    wrapCollapser(key, body) {\n        const\n            me = this,\n            { collapseDir, panel } = me,\n            { expandedHeaderDock, header, uiClassList } = panel,\n            recollapse = panel.tools?.recollapse,\n            [before, after] = me.splitHeaderItems({ dock : me.collapseDock, as : 'element' }),\n            horz = dockIsHorz[expandedHeaderDock],\n            title = panel.hasHeader ? (panel.title || header?.title || '\\xA0') : null;\n\n        if (recollapse) {\n            recollapse.direction = collapseDir;\n        }\n\n        return [\n            'overlayElement',\n            {\n                class : {\n                    ...uiClassList,\n                    [`b-panel-overlay-header-${expandedHeaderDock}`] : 1,\n                    [`b-panel-overlay-${collapseDir}`]               : 1,\n                    [`b-${horz ? 'h' : 'v'}box`]                     : 1,\n                    'b-panel-overlay'                                : 1,\n                    'b-box-center'                                   : 1\n                },\n\n                listeners : {\n                    transitionend : ev => me.onOverlayTransitionDone(ev)\n                },\n\n                children : {\n                    overlayHeaderElement : title && {\n                        tag   : 'header',\n                        class : new DomClassList({\n                            ...uiClassList,\n                            [`b-dock-${expandedHeaderDock}`] : 1,\n                            'b-panel-header'                 : 1,\n                            'b-panel-overlay-header'         : 1\n                        }, header?.cls),\n\n                        children : [\n                            ...before,\n                            {\n                                reference : 'overlayTitleElement',\n                                html      : title,\n                                class     : {\n                                    ...uiClassList,\n                                    [`b-align-${header?.titleAlign || 'start'}`] : 1,\n                                    'b-header-title'                             : 1\n                                }\n                            },\n                            ...after\n                        ]\n                    },\n\n                    [key] : body\n                }\n            }\n        ];\n    }\n}\n\n// Register this widget type with its Factory\nPanelCollapserOverlay.initClass();\n","import Base from '../../Base.js';\n\n/**\n * @module Core/widget/mixin/Minifiable\n */\n\n/**\n * Mixin for widgets that can present in a full and minified form. This behavior is used in\n * {@link Core.widget.Toolbar#config-overflow} handling.\n *\n * @mixin\n * @internal\n */\nexport default Target => class Minifiable extends (Target || Base) {\n    static $name = 'Minifiable';\n\n    static configurable = {\n        /**\n         * Set to `false` to prevent this widget from assuming its {@link #config-minified} form automatically (for\n         * example, due to {@link Core.widget.Toolbar#config-overflow} handling.\n         *\n         * When this value is `true` (the default), the minifiable widget's {@link #config-minified} config may be\n         * set to `true` to reduce toolbar overflow.\n         *\n         * @config {Boolean}\n         * @default\n         */\n        minifiable : true,\n\n        /**\n         * Set to `true` to present this widget in its minimal form.\n         * @config {Boolean}\n         * @default false\n         */\n        minified : null\n    };\n\n    compose() {\n        const { minified } = this;\n\n        return {\n            class : {\n                'b-minified' : minified\n            }\n        };\n    }\n\n    get widgetClass() {}\n};\n"],"names":["EDGES","EDGE_CLASSES","EDGES_e","EDGES_t","EDGES_r","EDGES_b","EDGES_l","ZONES","t","r","b","l","tr","bl","tl","br","Target","mixin","Delayable","$name","configurable","hoverCls","hoverAnimationCls","hoverRootCls","hoverRootActiveCls","hoverDelay","hoverElement","hoverIgnoreElement","hoverEdges","hoverEdgeSize","hoverRootElement","$config","value","hoverSelector","hoverTarget","hoverTrack","hoverZone","delayable","setHoverTarget","hoverEnter","leaving","hoverIgnore","element","_this$hoverIgnoreElem","this","contains","hoverLeave","hoverMove","event","onHoverMouseMove","me","top","left","width","height","right","bottom","getBoundingClientRect","clientX","clientY","centerX","centerY","tb","rl","includes","hoverEvent","onHoverMouseOver","target","onHoverMouseOut","relatedTarget","updateHoverDelay","delay","changeHoverEdges","edges","replace","updateHoverEdges","syncHoverListeners","changeHoverElement","updateHoverElement","hoverEl","_hoverEl","closest","updateHoverRootElement","rootEl","was","classList","remove","add","changeHoverTarget","updateHoverTarget","updateHoverTrack","updateHoverZone","zone","className","cls","DomClassList","change","_me$_hoverRootDetache","listeners","thisObj","mouseover","mouseout","mousemove","_hoverRootDetacher","call","EventHelper","on","DragTipProxy","DragProxy","type","align","offset","tooltip","open","getConfig","close","_this$tooltip","hide","dragMove","drag","isVisible","show","alignTo","Rectangle","changeTooltip","config","existing","Widget","reconfigure","initClass","_$name","dockIsHorz","PanelCollapser","maps","collapseExposeEdge","down","up","emptyObject","translateByDir","from","to","PanelCollapserOverlay","autoCloseDelay","autoClose","revealing","default","recollapseTool","collapsify","handler","_this$collapsible","collapsible","toggleReveal","doAutoClose","updateAutoCloseDelay","suspended","immediate","changeRecollapseTool","tool","panel","isConfiguring","isDestroying","tools","recollapse","beforeCollapse","operation","super","revealed","animation","applyHeaderDock","collapsed","flush","_this$panel","recompose","collapseBegin","collapseDir","innerElement","collapseTool","configuredWidth","_lastWidth","configuredHeight","_lastHeight","lockInnerSize","transform","Animator","run","onComplete","action","_me$autoCloseLeaveDet","_me$autoCloseClickDet","autoCloseLeaveDetacher","autoCloseClickDetacher","cancel","containsFocus","mouseenter","ev","mouseleave","document","body","mousedown","_panel$focusInEvent","el","focusInEvent","DomHelper","getActiveElement","now","expandBegin","restoreConfiguredSize","expandEnd","completed","expandRevert","overlayElement","innerSizeElement","toolsConfig","direction","_objectSpread","ObjectHelper","assign","toLowerCase","lock","panelRect","rectangle","inset","innerRect","collapseDim","style","clipPath","join","onOverlayTransitionDone","srcElement","onRevealerClick","splitHeaderItems","as","dock","_this$panel2","overlay","state","trigger","reveal","revertFocus","updateRevealing","dim","test","wrapCollapser","key","_panel$tools","expandedHeaderDock","header","uiClassList","before","after","collapseDock","horz","title","hasHeader","class","transitionend","children","overlayHeaderElement","tag","reference","html","titleAlign","_class","_defineProperty","Base","compose","minified","widgetClass","minifiable"],"mappings":"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"}