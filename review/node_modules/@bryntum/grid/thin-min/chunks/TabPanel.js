/*!
 *
 * Bryntum Grid 5.3.0
 *
 * Copyright(c) 2023 Bryntum AB
 * https://bryntum.com/contact
 * https://bryntum.com/license
 *
 */
import{_defineProperty as e,Events as t,Base as i,_objectSpread2 as n,Panel as a,Labelable as s,DomHelper as r,ObjectHelper as o,Widget as l,Button as c,FunctionHelper as d,DomClassList as h,Toolbar as u,ArrayHelper as b,GlobalEvents as g}from"./Editor.js";import{Checkbox as m}from"./MessageDialog.js";import"./Card.js";class v extends(t(i)){construct(e={}){const t=this;super.construct(e),t.onWsOpen=t.onWsOpen.bind(t),t.onWsClose=t.onWsClose.bind(t),t.onWsMessage=t.onWsMessage.bind(t),t.onWsError=t.onWsError.bind(t),t.autoConnect&&t.address&&t.open()}doDestroy(){const e=this;e.connector&&(e.detachSocketListeners(e.connector),e.connector.close(),e.connector=null),super.doDestroy()}get isConnecting(){var e;return(null===(e=this.connector)||void 0===e?void 0:e.readyState)===this.constructor.webSocketImplementation.CONNECTING}get isOpened(){var e;return(null===(e=this.connector)||void 0===e?void 0:e.readyState)===this.constructor.webSocketImplementation.OPEN}get isClosing(){var e;return(null===(e=this.connector)||void 0===e?void 0:e.readyState)===this.constructor.webSocketImplementation.CLOSING}get isClosed(){var e;return(null===(e=this.connector)||void 0===e?void 0:e.readyState)===this.constructor.webSocketImplementation.CLOSED}createWebSocketConnector(){const e=this.connector=new this.constructor.webSocketImplementation(this.address);this.attachSocketListeners(e)}destroyWebSocketConnector(){this.detachSocketListeners(this.connector),this.connector.close(),this.connector=null}attachSocketListeners(e){const t=this;e.addEventListener("open",t.onWsOpen),e.addEventListener("close",t.onWsClose),e.addEventListener("message",t.onWsMessage),e.addEventListener("error",t.onWsError)}detachSocketListeners(e){const t=this;e.removeEventListener("open",t.onWsOpen),e.removeEventListener("close",t.onWsClose),e.removeEventListener("message",t.onWsMessage),e.removeEventListener("error",t.onWsError)}async open(){const e=this;if(e._openPromise)return e._openPromise;if(!e.address)return void console.warn("Server me.address cannot be empty");if(e.isOpened)return!0;let t;return e.createWebSocketConnector(),e._openPromise=new Promise((i=>{t=e.ion({open(){i(!0)},error(){i(!1)}})})).then((i=>(t(),e._openPromise=null,i||e.destroyWebSocketConnector(),i))).catch((()=>{e._openPromise=null,e.destroyWebSocketConnector()})),e._openPromise}close(){this.connector&&(this.destroyWebSocketConnector(),this.trigger("close"))}send(e,t={}){var i;null===(i=this.connector)||void 0===i||i.send(JSON.stringify(n({command:e},t)))}onWsOpen(e){this.trigger("open",{event:e})}onWsClose(e){this.trigger("close",{event:e})}onWsMessage(e){try{const t=JSON.parse(e.data);this.trigger("message",{data:t})}catch(e){this.trigger("error",{error:e})}}onWsError(e){this.trigger("error",{error:e})}}e(v,"webSocketImplementation","undefined"==typeof WebSocket?null:WebSocket),e(v,"configurable",{address:"",userName:"User",autoConnect:!0}),v._$name="WebSocketManager";class p extends(a.mixin(s)){static get $name(){return"FieldSet"}static get type(){return"fieldset"}static get configurable(){return{bodyTag:"fieldset",focusable:!1,inline:null,inlineInternal:null,layout:{type:"box",horizontal:!1}}}static get prototypeProperties(){return{flexRowCls:"b-hbox",flexColCls:"b-vbox"}}get bodyConfig(){const e=super.bodyConfig,{className:t}=e,{inlineInternal:i,hasLabel:n,title:a}=this;return delete e.html,t["b-inline"]=i,t["b-fieldset-has-label"]=n,a&&(e.children={legendElement:{tag:"legend",text:a,class:{"b-fieldset-legend":1}}}),e}compose(){const{inlineInternal:e,label:t,labelCls:i,labelWidth:n}=this;return{class:{"b-field":t,"b-vbox":!e},children:{"labelElement > headerElement":t?{tag:"label",html:t,class:{"b-label":1,"b-align-start":1,[i]:i},style:{width:r.unitize("width",n)[1]}}:null}}}syncInlineInternal(){var e;this.inlineInternal=null!==(e=this.inline)&&void 0!==e?e:null!=this.label&&"before"===this.labelPosition}updateDisabled(e,t){super.updateDisabled(e,t),this.eachWidget((t=>{t.disabled=e}),!1)}updateInline(){this.syncInlineInternal()}updateInlineInternal(e){this.layout.horizontal=e}updateLabel(){this.syncInlineInternal()}updateLabelPosition(){this.syncInlineInternal()}}p.initClass(),p._$name="FieldSet";class f extends m{static get $name(){return"Radio"}static get type(){return"radio"}static get alias(){return"radiobutton"}static get configurable(){return{inputType:"radio",clearable:null,uncheckedValue:void 0}}get textLabelCls(){return super.textLabelCls+" b-radio-label"}internalOnClick(e){!1!==super.internalOnClick(e)&&this.checked&&this.clearable&&(this.checked=!1)}updateName(e){this.toggleGroup=e}updateClearable(){}}f.initClass(),f._$name="Radio";class C extends p{static get $name(){return"RadioGroup"}static get type(){return"radiogroup"}static get configurable(){return{defaultType:"radio",clearable:null,name:null,options:{value:null,$config:{merge:"items"}},defaultBindProperty:"value"}}get existingOptions(){const{name:e}=this;return this.ensureItems().filter((t=>t.name===e))}get refPrefix(){return`${this.name||this.ref||this.id}_`}get selected(){return this.existingOptions.filter((e=>e.input.checked))[0]||null}get value(){const{selected:e}=this;return e?e.checkedValue:null}set value(e){this.existingOptions.forEach((t=>{t.isConfiguring=this.isConfiguring,t.checked=t.checkedValue===e,t.isConfiguring=!1}))}ensureItems(){return this.getConfig("options"),super.ensureItems()}changeOptions(e,t){if(!(e&&t&&o.isDeeplyEqual(t,e)))return e}convertOption(e,t,i){const n=this,{name:a}=n,s={name:a,type:"radio",value:e===n.value,ref:`${n.refPrefix}${e}`,checkedValue:e};return"string"==typeof t?s.text=t:o.assign(s,t),i?l.reconfigure(i,s):s}isOurRadio(e){return e.isRadio&&e.name===this.name}isolateFieldChange(e){return this.isOurRadio(e)}onChildAdd(e){super.onChildAdd(e),this.isOurRadio(e)&&e.ion({name:e.id,beforeChange:"onRadioItemBeforeChange",change:"onRadioItemChange",click:"onRadioClick",thisObj:this})}onChildRemove(e){this.isOurRadio(e)&&this.detachListeners(e.id),super.onChildRemove(e)}onRadioClick(e){const{source:t}=e;t.checked&&this.clearable&&null==t.clearable&&(t.checked=!1)}onRadioItemBeforeChange(e){if(e.checked){const t=this,{lastValue:i}=t;if(!t.reverting&&!1===t.trigger("beforeChange",t.wrapRadioEvent(e))&&null!=i&&i!==t.value)return t.reverting=!0,e.source.uncheckToggleGroupMembers(),t.value=i,t.lastValue=i,t.reverting=!1,!1}}onRadioItemChange(e){const t=this;e.checked&&!t.reverting&&(t.triggerFieldChange(t.wrapRadioEvent(e)),t.lastValue=t.value)}wrapRadioEvent(e){return{from:e,item:e.source,userAction:e.userAction,lastValue:this.lastValue,value:this.value}}updateOptions(){const e=this,{options:t,refPrefix:i}=e,n=e.existingOptions.reduce(((e,t)=>(e[t.ref.substring(i.length)]=t,e)),{});let a,s,r=0;if(t)for(a in t)s=e.convertOption(a,t[a],n[a]),delete n[a],e.insert(s,r++);const o=Object.values(n);null!=o&&o.length&&(e.remove(o),o.forEach((e=>e.destroy())))}}C.initClass(),C._$name="RadioGroup";class I extends c{static get $name(){return"Tab"}static get type(){return"tab"}static get configurable(){return{active:null,index:null,isFirst:null,isLast:null,item:{value:null,$config:"nullify"},itemCls:null,tabPanel:null,titleProperty:"text",titleSource:"title",role:"tab"}}compose(){const{active:e,cls:t,index:i,isFirst:a,isLast:s}=this;return{tabindex:0,"aria-selected":e,"aria-setsize":this.owner.visibleChildCount,"aria-posinset":i+1,class:n({"b-tabpanel-tab":1,"b-active":e,"b-tab-first":a,"b-tab-last":s},t),dataset:{index:i}}}updateIndex(e){this.isFirst=!e}updateItem(e,t){var i,n;const a=this;(null==t?void 0:t.tab)===a&&(t.tab=null),e&&(e.tab=a,a[a.titleProperty]=e[a.titleSource],a.itemCls=e.cls,a.ariaElement.setAttribute("aria-controls",e.id),e.role="tabpanel"),null===(i=a.itemChangeDetacher)||void 0===i||i.call(a),a.itemChangeDetacher=e&&d.after(e,"onConfigChange","onItemConfigChange",a,{return:!1}),null===(n=a.itemHideDetacher)||void 0===n||n.call(a),a.itemHideDetacher=null==e?void 0:e.ion({beforeChangeHidden:"onItemBeforeChangeHidden",beforeHide:"onItemBeforeHide",beforeUpdateDisabled:"onItemBeforeUpdateDisabled",thisObj:a,prio:1e3}),a.syncMinMax()}updateItemCls(e,t){const{element:i}=this,n=i&&h.from(null==i?void 0:i.classList,!0);i&&(n.remove(t).add(e),i.className=n.value)}updateRotate(e,t){!e!=!t&&this.syncMinMax()}syncMinMax(){const e=this,{rotate:t,tabPanel:i}=e;let{_minWidth:n,_minHeight:a,_maxWidth:s,_maxHeight:r}=e;if(i){const{tabMinWidth:o,tabMaxWidth:l}=i;null!=o&&(t?(n===o&&(n=null),a=o):(a===o&&(a=null),n=o)),null!=l&&(t?(s===l&&(s=null),r=l):(r===l&&(r=null),s=l)),e.minWidth=n,e.minHeight=a,e.maxWidth=s,e.maxHeight=r}}onItemBeforeChangeHidden({source:e,hidden:t}){if(!e.$isDeactivating&&!e.$isActivating){const{tabPanel:i}=this;this.hidden=t,t&&e===i.activeItem&&i.activateAvailableTab(e)}}onItemBeforeHide(){this.item.$isDeactivating||this.hide()}onItemBeforeUpdateDisabled({source:e,disabled:t}){const{tabPanel:i}=this;this.disabled=t,e===i.activeItem&&i.activateAvailableTab(e)}onItemConfigChange({name:e,value:t}){e===this.titleSource&&(this[this.titleProperty]=t)}}I.initClass(),I._$name="Tab";const y=e=>e.isTab;class T extends u{static get $name(){return"TabBar"}static get type(){return"tabbar"}static get configurable(){return{defaultType:"tab",overflow:"scroll",role:"tablist",ignoreParentReadOnly:!0}}get firstTab(){return this.tabAt(0)}get lastTab(){return this.tabAt(-1)}get tabCount(){return this._items.countOf(y)}get tabs(){return b.from(this._items,y)}compose(){return{children:{toolbarContent:{class:{"b-tabpanel-tabs":1}}}}}indexOfTab(e){return this._items.indexOf(e,y)}onChildAdd(e){super.onChildAdd(e),null==e.index&&this.syncTabs()}onChildRemove(e){super.onChildRemove(e),this.syncTabs()}onFocusIn(){const{activeIndex:e}=this.owner;isNaN(e)||this.tabs[e].focus()}syncTabs(){const{tabs:e}=this;for(let t=0,i=e.length;t<i;++t)e[t].index=t,e[t].isFirst=!t,e[t].isLast=t===i-1}tabAt(e){return this._items.find(y,e)||null}}T.initClass(),T._$name="TabBar";class x extends a{static get $name(){return"TabPanel"}static get type(){return"tabpanel"}static get alias(){return"tabs"}static get configurable(){return{activeTab:0,animateTabChange:!0,autoHeight:!1,defaultType:"container",focusable:!1,itemCls:"b-tabpanel-item",layout:{type:"card"},suppressChildHeaders:!0,tabBar:{type:"tabbar",weight:-2e3},tabMinWidth:null,tabMaxWidth:null}}get activeIndex(){return this.layout.activeIndex}get activeItem(){return this.layout.activeItem}get activeTabItemIndex(){var e;const{activeTab:t,items:i,tabBar:n}=this;return i.indexOf(null===(e=n.tabs[t])||void 0===e?void 0:e.item)}get bodyConfig(){return o.merge({className:{"b-tabpanel-body":1}},super.bodyConfig)}get focusElement(){var e;const t=this.items[this.activeTab||0];return(null==t?void 0:t.focusElement)||(null==t||null===(e=t.tab)||void 0===e?void 0:e.focusElement)}get tabPanelBody(){return this.bodyElement}finalizeInit(){super.finalizeInit();const e=this,{activeTab:t,layout:i}=e,{activeIndex:n}=i,{tabs:a}=e.tabBar,s=t>=0&&t<a.length&&e.items.indexOf(a[t].item);if(a.length>0&&(!1===s||s<0))throw new Error(`Invalid activeTab ${t} (${a.length} tabs)`);s!==n&&i.setActiveItem(s,n,{animation:!1,silent:!0}),i.animateCardChange=e.animateTabChange}onChildAdd(e){if(super.onChildAdd(e),!this.initialItems){const t=this,{tabBar:i}=t,n=t.makeTabConfig(e),a=n&&(null==i?void 0:i.firstTab),s=a&&i._items,r=a&&b.from(t._items,(t=>t.tab||t===e)),o=a?r.indexOf(e)+s.indexOf(a):0;n&&i&&(a&&null==e.weight&&o<s.count-1?i.insert(n,o):i.add(n))}}onChildRemove(e){const{tab:t}=e,{items:i}=this;t&&(this.tabBar.remove(t),t.destroy()),e===this.activeItem&&(this._activeTab=null,i.length&&(this.activeTab=i[Math.min(this.activeIndex,i.length-1)])),super.onChildRemove(e)}isDisabledOrHiddenTab(e){const{tabs:t}=this.tabBar,i=null==t?void 0:t[e];return i&&(i.disabled||i.hidden)}findAvailableTab(e,t=1){const{tabs:i}=this.tabBar,n=i.length,a=Math.max(0,i.indexOf(e.tab));let s;a&&(t=-t);for(let e=1;e<=n&&(s=(a+(t<0?n:0)+e*t)%n,this.isDisabledOrHiddenTab(s));++e);return s}activateAvailableTab(e,t=1){this.activeTab=this.findAvailableTab(e,t)}changeActiveTab(e,t){const i=this,{tabBar:n,layout:a}=i,{tabCount:s}=n;if(e.isWidget||o.isObject(e)?(-1===i.items.indexOf(e)&&(e=i.add(e)),e=n.indexOfTab(e.tab)):e=parseInt(e,10),!i.initialItems&&s>0&&(e<-1||e>=s))throw new Error(`Invalid activeTab ${e} (${s} tabs)`);if(i.isDisabledOrHiddenTab(e)&&(e=i.findAvailableTab(e)),!a.animateCardChange||!a.cardChangeAnimation)return e;a.cardChangeAnimation.then((n=>{(null==n?void 0:n.activeIndex)!==e&&(i._activeTab=e,i.updateActiveTab(e,t))}))}async updateActiveTab(){if(!this.initialItems){const{activeTabItemIndex:t,layout:i}=this;var e;if(t>-1)i.animateCardChange&&await this.tabSelectionPromise,this.tabSelectionPromise=null===(e=i.setActiveItem(this.items[t]))||void 0===e?void 0:e.promise}}changeTabBar(e){return this.getConfig("strips"),this.strips={tabBar:e},this.strips.tabBar}makeTabConfig(e){const{tab:t}=e,i={item:e,type:"tab",tabPanel:this,disabled:Boolean(e.disabled),hidden:e.initialConfig.hidden,weight:e.weight||0,internalListeners:{click:"onTabClick",thisObj:this},localizableProperties:{text:!1}};return!1===t?null:o.isObject(t)?I.mergeConfigs(i,t):i}updateItems(e,t){const i=this,{activeTab:n,initialItems:a}=i;let s,r=0;super.updateItems(e,t),a&&(s=Array.from(e,(e=>i.makeTabConfig(e))).filter((e=>{if(e)return e.index=r++,!0})),r&&(s[0].isFirst=!0,s[r-1].isLast=!0,s[n].active=!0,i.tabBar.add(s),i.activeTab=n))}updateTabMinWidth(e){var t;null===(t=this.tabBar)||void 0===t||t.items.forEach((t=>{t.isTab&&(t.minWidth=e)}))}updateTabMaxWidth(e){var t;null===(t=this.tabBar)||void 0===t||t.items.forEach((t=>{t.isTab&&(t.maxWidth=e)}))}updateAutoHeight(e){this.detachListeners("themeAutoHeight"),e&&g.ion({name:"themeAutoHeight",theme:"internalOnThemeChange",thisObj:this}),this.$measureHeight=e}applyAutoHeight(){const e=this,{layout:t,activeTab:i,element:n}=e,{animateCardChange:a}=t;t.animateCardChange=!1,e.height=null,e.height=Math.max(...e.items.map((t=>(e.activeTab=t,n.clientHeight))))+1,e.activeTab=i,t.animateCardChange=a,e.$measureHeight=!1}internalOnThemeChange(){this.isVisible?this.applyAutoHeight():this.$measureHeight=!0}onBeginActiveItemChange(e){const t=this.tabBar.tabs,{activeItem:i,prevActiveItem:n}=e;this.activeTab=t.indexOf(null==i?void 0:i.tab),null!=n&&n.tab&&(n.tab.active=!1),null!=i&&i.tab&&(i.tab.active=!0,i.tab.show())}onBeforeActiveItemChange(e){return this.trigger("beforeTabChange",e)}onActiveItemChange(e){this.trigger("tabChange",e)}onTabClick(e){this.activeTab=e.source.item}onPaint(){super.onPaint(...arguments),this.$measureHeight&&this.applyAutoHeight()}}x.initClass(),x._$name="TabPanel";export{p as FieldSet,f as Radio,C as RadioGroup,I as Tab,T as TabBar,x as TabPanel,v as WebSocketManager};
//# sourceMappingURL=TabPanel.js.map
