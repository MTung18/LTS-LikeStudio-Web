import InstancePlugin from '../../Core/mixin/InstancePlugin.js';
import GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';

/**
 * @module Grid/feature/RowCopyPaste
 */

/**
 * Allow using [Ctrl/CMD + C/X] and [Ctrl/CMD + V] to copy/cut and paste rows. Also makes cut, copy and paste actions
 * available via the cell context menu.
 *
 * You can configure how a newly pasted record is named using {@link #function-generateNewName}
 *
 * This feature is **enabled** by default
 *
 * ```javascript
 * const grid = new Grid({
 *     features : {
 *         rowCopyPaste : true
 *     }
 * });
 * ```
 *
 * {@inlineexample Grid/feature/RowCopyPaste.js}
 *
 * This feature will work alongside with CellCopyPaste but there is differences on functionality.
 * * When used together, context menu options will be detailed so the user will know to copy the cell or the row.
 * * They will also detect what type of selection is present at the moment. If there is only rows selected, only row
 *   alternatives are shown in the context menu and the keyboard shortcuts will be processed by RowCopyPaste.
 * * If there is only cells selected, there will be context menu options for both row and cell but keyboard shortcuts
 *   will be handled by CellCopyPaste.
 * * They do not share clipboard, so it is possible to have rows and cells copied or cut at the same time.
 *
 * ## Keyboard shortcuts
 * The feature has the following default keyboard shortcuts:
 *
 * | Keys   | Action | Action description                                                                      |
 * |--------|--------|-----------------------------------------------------------------------------------------|
 * | Ctrl+C | copy   | Calls {@link #function-copyRows} which copies selected row(s) into the clipboard.       |
 * | Ctrl+X | cut    | Calls {@link #function-copyRows} which cuts out selected row(s) and saves in clipboard. |
 * | Ctrl+V | paste  | Calls {@link #function-pasteRows} which inserts copied or cut row(s) from the clipboard.|
 *
 * For more information on how to customize keyboard shortcuts, please see
 * [our guide](#Grid/guides/customization/keymap.md).
 *
 * @extends Core/mixin/InstancePlugin
 * @classtype rowCopyPaste
 * @feature
 */
export default class RowCopyPaste extends InstancePlugin {

    static $name = 'RowCopyPaste';
    static type  = 'rowCopyPaste';

    static pluginConfig = {
        assign : [
            'copyRows',
            'pasteRows'
        ],
        chain : [
            'populateCellMenu'
        ]
    };

    static properties = {
        clipboardRecords : []
    };

    static configurable = {
        /**
         * The field to use as the name field when updating the name of copied records
         * @config {String}
         * @default
         */
        nameField : 'name',

        /**
         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
         * @config {Object<String,String>}
         */
        keyMap : {
            'Ctrl+C' : 'copy',
            'Ctrl+X' : 'cut',
            'Ctrl+V' : 'paste'
        },

        copyRecordText         : 'L{copyRecord}',
        cutRecordText          : 'L{cutRecord}',
        pasteRecordText        : 'L{pasteRecord}',
        rowSpecifierText       : 'L{row}',
        rowSpecifierTextPlural : 'L{rows}',
        localizableProperties  : [
            'copyRecordText',
            'cutRecordText',
            'pasteRecordText',
            'rowSpecifierText',
            'rowSpecifierTextPlural'
        ]

    };

    construct(grid, config) {
        super.construct(grid, config);

        grid.rowManager.ion({
            beforeRenderRow : 'onBeforeRenderRow',
            thisObj         : this
        });

        this.grid = grid;
    }

    // Used in events to separate events from different features from each other
    entityName = 'row';

    onBeforeRenderRow({ row, record }) {
        row.cls['b-cut-row'] = this._isCut && this.clipboardRecords.includes(record);
    }

    isActionAvailable(key, action, event) {
        const
            { grid }     = this,
            { cellEdit } = grid.features,
            { target }   = event;
        // No action if
        // 1. there is selected text on the page
        // 2. cell editing is active
        // 3. cursor is not in the grid (filter bar etc)
        return !this.disabled &&
            globalThis.getSelection().toString().length === 0 &&
            (!cellEdit || !cellEdit.isEditing) &&
            grid.selectedRecords?.length > 0 && // No key action when no selected records
            (!target || Boolean(target.closest('.b-gridbase:not(.b-schedulerbase) .b-grid-subgrid,.b-grid-subgrid:not(.b-timeaxissubgrid)')));
    }

    copy() {
        this.copyRows();
    }

    cut() {
        this.copyRows(true);
    }

    paste(referenceRecord) {
        this.pasteRows(referenceRecord?.isModel ? referenceRecord : null);
    }

    /**
     * Copy or cut rows to clipboard to paste later
     *
     * @fires beforeCopy
     * @param {Boolean} [isCut] Copies by default, pass `true` to cut
     * @category Common
     * @on-owner
     */
    copyRows(isCut = false) {
        const
            me                     = this,
            { client, entityName } = me,
            // Dont cut readOnly records
            records                = me.selectedRecords.filter(r => !r.readOnly || !isCut);

        /**
         * Fires on the owning Grid before a copy action is performed, return `false` to prevent the action
         * @event beforeCopy
         * @preventable
         * @on-owner
         * @param {Grid.view.Grid} source Owner grid
         * @param {Core.data.Model[]} records The records about to be copied
         * @param {Boolean} isCut `true` if this is a cut action
         * @param {String} entityName 'row' to distinguish this event from other beforeCopy events
         */
        if (!records.length || client.readOnly ||
            client.trigger('beforeCopy', { records, isCut, entityName }) === false
        ) {
            return;
        }

        me._isCut = isCut;

        me.clipboardRecords.forEach(rec => client.rowManager.getRowById(rec)?.removeCls('b-cut-row'));

        me.clipboardRecords = records.slice();

        client.store.forEach(rec => {
            rec.meta.isCut = me._isCut && me.clipboardRecords.includes(rec);
        });

        // refresh to call reapply the cls for records where the cut was canceled
        records.forEach(record => this.onRowCutOrCopy(record, isCut));
        /**
         * Fires on the owning Grid after a copy action is performed.
         * @event copy
         * @on-owner
         * @param {Grid.view.Grid} source Owner grid
         * @param {Core.data.Model[]} records The records that were copied
         * @param {Boolean} isCut `true` if this is a cut action
         * @param {String} entityName 'row' to distinguish this event from other copy events
         */
        client.trigger('copy', { records, isCut, entityName });
    }

    onRowCutOrCopy(record, isCut) {
        this.client.rowManager.getRowById(record)?.toggleCls('b-cut-row', isCut);
    }

    /**
     * Paste rows below selected or passed record
     *
     * @fires beforePaste
     * @param {Core.data.Model} [record] Paste below this record, or currently selected record if left out
     * @category Common
     * @on-owner
     */
    pasteRows(record) {
        const
            me                     = this,
            records                = me.clipboardRecords,
            { client, entityName } = me, { store }       = client,
            referenceRecord        = record || client.selectedRecord;

        /**
         * Fires on the owning Grid before a paste action is performed, return `false` to prevent the action
         * @event beforePaste
         * @preventable
         * @on-owner
         * @param {Grid.view.Grid} source Owner grid
         * @param {Core.data.Model} referenceRecord The reference record, the clipboard records will be pasted below
         * this record
         * @param {Core.data.Model[]} records The records about to be pasted
         * @param {Boolean} isCut `true` if this is a cut action
         * @param {String} entityName 'row' to distinguish this event from other beforePaste events
         */
        if (client.readOnly || client.isTreeGrouped || !records.length ||
            (store.tree && me._isCut && records.some(rec => rec.contains(referenceRecord, true))) || client.trigger('beforePaste', {
            records, referenceRecord, isCut : me._isCut, entityName
        }) === false) {
            return [];
        }

        // sort selected to move records to make sure it will be added in correct order independent of how it was selected.
        // Should be done with real records in the clipboard, after records are copied, all indexes will be changed
        me.sortByIndex(records);

        const
            idMap            = {},
            // We need to go over selected records, find all top level nodes and reassemble the tree
            recordsToProcess = me.extractParents(records, idMap);

        me.insertCopiedRecords(recordsToProcess, referenceRecord);

        if (me._isCut) {
            // reset clipboard
            me.clearClipboard();
        }
        else {
            client.selectedRecords = recordsToProcess;
        }

        /**
         * Fires on the owning Grid after a paste action is performed.
         * @event paste
         * @on-owner
         * @param {Grid.view.Grid} source Owner grid
         * @param {Core.data.Model} referenceRecord The reference record, below which the records were pasted
         * @param {Core.data.Model[]} records Pasted records
         * @param {Core.data.Model[]} originalRecords For a copy action, these are the records that were copied.
         * For cut action, this is same as the `records` param.
         * @param {Boolean} isCut `true` if this is a cut action
         * @param {String} entityName 'row' to distinguish this event from other paste events
         */
        client.trigger('paste', {
            records         : recordsToProcess,
            originalRecords : records,
            isCut           : me._isCut,
            referenceRecord,
            entityName
        });

        // Focus first cell of last copied or cut row
        client.getRowFor(recordsToProcess[recordsToProcess.length - 1])?.cells?.[0].focus();

        return recordsToProcess;
    }

    /**
     * Clears the clipboard and refreshes the UI
     *
     * @category Common
     */
    clearClipboard() {
        if (this._isCut) {
            this.clipboardRecords.forEach(rec => this.client.rowManager.getRowById(rec)?.removeCls('b-cut-row'));
        }
        this._isCut           = false;
        this.clipboardRecords = [];
    }

    /**
     * A method used to generate the name for a copy-pasted record. By defaults appends "- 2", "- 3" as a suffix. Override
     * it to provide your own naming of pasted records.
     *
     * @param {Core.data.Model} record The new record being pasted
     * @returns {String}
     */
    generateNewName(record) {
        const originalName = record[this.nameField];

        let counter = 2;

        while (this.client.store.findRecord(this.nameField, `${originalName} - ${counter}`)) {
            counter++;
        }

        return `${originalName} - ${counter}`;
    }

    insertCopiedRecords(toInsert, recordReference) {
        const
            { store } = this.client,
            insertAt  = store.indexOf(recordReference) + 1;

        if (store.tree) {
            return recordReference.parent.insertChild(toInsert, recordReference.nextSibling, false, {
                // Specify node to insert before in the ordered tree. It allows to paste to a
                // correct place both ordered and visual.
                // Covered by TaskOrderedWbs.t.js
                orderedBeforeNode : recordReference.nextOrderedSibling
            });
        }
        else if (this._isCut) {
            store.move(toInsert, store.getAt(insertAt));
        }
        else {
            return store.insert(insertAt, toInsert);
        }
    }

    get selectedRecords() {
        const records = [...this.client.selectedRecords];

        // Add eventual selected cells records
        this.client.selectedCells.forEach(cell => {
            if (!records.includes(cell.record)) {
                records.push(cell.record);
            }
        });

        return records;
    }

    getMenuItemText(action) {
        const me = this;
        let text = me[action + 'RecordText'];

        // If cellCopyPaste is enabled and there is selected cells, add a row specifier text to menu options
        if (me.client.features.cellCopyPaste?.enabled === true && me.client.selectedCells.length) {
            text += ` (${me.selectedRecords.length > 1 ? me.rowSpecifierTextPlural : me.rowSpecifierText})`;
        }

        return text;
    }

    populateCellMenu({ record, items }) {
        const
            me         = this,
            { client } = me;

        if (!client.readOnly &&
            !client.isTreeGrouped &&
            record?.isSpecialRow === false &&
            me.selectedRecords.length
        ) {
            items.cut = {
                text        : me.getMenuItemText('cut'),
                localeClass : me,
                icon        : 'b-icon b-icon-cut',
                weight      : 135,
                disabled    : record.readOnly,
                onItem      : () => me.cut()
            };

            items.copy = {
                text        : me.getMenuItemText('copy'),
                localeClass : me,
                cls         : 'b-separator',
                icon        : 'b-icon b-icon-copy',
                weight      : 120,
                onItem      : () => me.copy()
            };

            items.paste = {
                text        : me.getMenuItemText('paste'),
                localeClass : me,
                icon        : 'b-icon b-icon-paste',
                weight      : 140,
                disabled    : !me.clipboardRecords.length,
                onItem      : () => me.paste(record)
            };
        }
    }

    /**
     * Sort array of records ASC by its indexes stored in indexPath
     * @param {Core.data.Model[]} array array to sort
     * @private
     */
    sortByIndex(array) {
        const { store } = this.client;

        return array.sort((rec1, rec2) => {
            const
                idx1 = rec1.indexPath,
                idx2 = rec2.indexPath;

            // When a record is copied without its parent, its index in the visible tree should be used
            if (!array.includes(rec1.parent) && !array.includes(rec2.parent)) {
                // For row copy-paste feature both records are normally in store. Unless someone wants
                // to include invisible records. Which does not happen yet.
                return store.indexOf(rec1) - store.indexOf(rec2);
            }

            if (idx1.length === idx2.length) {
                for (let i = 0; i < idx1.length; i++) {
                    if (idx1[i] < idx2[i]) {
                        return -1;
                    }
                    if (idx1[i] > idx2[i]) {
                        return 1;
                    }
                }
                return 0;
            }
            else {
                return idx1.length - idx2.length;
            }
        });
    }

    /**
     * Iterates over passed pre-sorted list of records and reassembles hierarchy of records.
     * @param {Core.data.Model[]} taskRecords array of records to extract parents from
     * @param {Object} idMap Empty object which will contain map linking original id with copied record
     * @returns {Core.data.Model[]} Returns array of new top-level nodes with children filled
     * @private
     */
    extractParents(taskRecords, idMap) {
        const
            me                         = this,
            { client, _isCut : isCut } = me;

        // Unwrap children to pass them all through `generateNewName` function
        if (client.store.tree) {
            taskRecords.forEach(node => {
                node.traverse(n => {
                    const parents = n.getTopParent(true);
                    if (!taskRecords.includes(n) && (!isCut || !taskRecords.some(rec => parents.includes(rec)))) {
                        taskRecords.push(n);
                    }
                });
            });
        }

        const result = taskRecords.reduce((parents, node) => {
            let copy;
            // Fallback is for when the node was removed from the tree
            const parentId = node.parentId || node.meta.modified;

            if (isCut) {
                copy = node;

                // reset record cut state
                copy.meta.isCut = false;
            }
            else {
                copy               = node.copy();
                copy[me.nameField] = me.generateNewName(copy);

                if (node.expanded) {
                    copy.data.expanded = node.expanded;
                }
            }

            idMap[node.id] = copy;

            // If we're copying top level node, add it directly
            if (node.parent === client.store.rootNode) {
                parents.push(copy);
            }
            // If node parent is also copied, append copy to the copied parent. Parents
            // are always at the beginning of the array, so we know if there is a parent
            // it was already copied
            else if (parentId in idMap) {
                idMap[parentId].appendChild(copy);
            }
            // If parent is not copied and record is not top level, then append it as a
            // sibling.
            else {
                parents.push(copy);
            }
            return parents;
        }, []);

        // Now when tree is assembled we want to restore ordered tree. Traverse the tree, sort children
        // by previous value of `orderedParentIndex`
        result.forEach(parent => {
            parent.sortOrderedChildren(true, true);
        });

        return result;
    }

}

RowCopyPaste.featureClass = 'b-row-copypaste';

GridFeatureManager.registerFeature(RowCopyPaste, true, 'Grid');
GridFeatureManager.registerFeature(RowCopyPaste, false, 'Gantt');
GridFeatureManager.registerFeature(RowCopyPaste, false, 'SchedulerPro');
GridFeatureManager.registerFeature(RowCopyPaste, false, 'ResourceHistogram');
