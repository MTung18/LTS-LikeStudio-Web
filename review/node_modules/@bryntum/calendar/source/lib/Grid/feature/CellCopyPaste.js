import InstancePlugin from '../../Core/mixin/InstancePlugin.js';
import BrowserHelper from '../../Core/helper/BrowserHelper.js';
import VersionHelper from '../../Core/helper/VersionHelper.js';
import GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';

/**
 * @module Grid/feature/CellCopyPaste
 */

/**
 * Allows using `[Ctrl/CMD + C]`, `[Ctrl/CMD + X]` and `[Ctrl/CMD + V]` to cut, copy and paste cell or cell ranges. Also
 * makes cut, copy and paste actions available via the cell context menu.
 *
 * Requires {@link Grid/view/Grid#config-selectionMode selectionMode.cell} to be activated.
 *
 * This feature will work alongside with {@link Grid/feature/RowCopyPaste} but there is differences on functionality.
 * * When used together, context menu options will be detailed so the user will know to copy the cell or the row.
 * * They will also detect what type of selection is present at the moment. If there are only rows selected, only row
 *   alternatives are shown in the context menu and the keyboard shortcuts will be processed by RowCopyPaste.
 * * If there are only cells selected, there will be context menu options for both row and cell but keyboard shortcuts
 *   will be handled by CellCopyPaste.
 * * They do not share clipboard, so it is possible to have rows and cells copied or cut at the same time.
 *
 * If the {@link https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API Clipboard API} is available, that will
 * be used. This enables copying and pasting between different Bryntum products or completely different applications.
 * Please note that only string values are supported.
 *
 * This feature is **disabled** by default
 *
 * ```javascript
 * const grid = new Grid({
 *     features : {
 *         cellCopyPaste : true
 *     }
 * });
 * ```
 *
 * {@inlineexample Grid/feature/CellCopyPaste.js}
 *
 * ## Keyboard shortcuts
 * The feature has the following default keyboard shortcuts:
 *
 * | Keys   | Action | Action description                                                                      |
 * |--------|--------|-----------------------------------------------------------------------------------------|
 * | Ctrl+C | copy   | Calls {@link #function-copy} which copies selected cell values into the clipboard.      |
 * | Ctrl+X | cut    | Calls {@link #function-cut} which cuts out selected cell values and saves in clipboard. |
 * | Ctrl+V | paste  | Calls {@link #function-paste} which inserts string values from the clipboard.           |
 *
 * For more information on how to customize keyboard shortcuts, please see
 * [this guide](#Grid/guides/customization/keymap.md).
 *
 * @extends Core/mixin/InstancePlugin
 * @classtype cellCopyPaste
 * @feature
 */
export default class CellCopyPaste extends InstancePlugin {
    static $name = 'CellCopyPaste';

    static pluginConfig = {
        chain : [
            'populateCellMenu', 'afterSelectionModeChange'
        ]
    }

    static configurable = {

        /**
         * If `true` this prevents cutting and pasting. Will default to `true` if {@link Grid/feature/CellEdit} feature is disabled.
         * Set to `false` to prevent this behaviour.
         * @config {Boolean}
         */
        copyOnly : null,

        /**
         * If an empty value (null or empty string) is copied or cut, this config will replace that value.
         * This allows for clipboard data to skip columns.
         *
         * For example, look at these two selections
         * |  ROW  |   0  |      1       |       2      |   3  |
         * |-------|------|--------------|--------------|------|
         * | ROW 1 | SEL1 | not selected | not selected | SEL2 |
         * | ROW 2 | SEL3 | SEL4 (empty) | SEL5 (empty) | SEL6 |
         *
         * The clipboardData for `ROW 1` will look like this:
         `* SEL1\t\t\SEl2\nSEL3\t\t\SEL4`
         *
         * And `ROW 2` will look like this:
         * `SEL3\t\u{0020}\t\u{0020}\tSEL6`
         *
         * `ROW 1` will set value `SEL1` at column index 0 and `SEL2` at column index 3. This leaves column index 1 and
         * 2 untouched.
         *
         * `ROW 2` will set value `SEL3` at column index 0, `u{0020}` at column index 1 and 2, and `SEL`6 at column
         * index 3.
         *
         * The default `u{0020}` is a blank space.
         *
         * @config {String}
         * @default
         */
        emptyValueChar : '\u{0020}',

        /**
         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
         * @config {Object<String,String>}
         */
        keyMap : {
            'Ctrl+C' : 'copy',
            'Ctrl+X' : 'cut',
            'Ctrl+V' : 'paste'
        },

        /**
         * Set this to `false` to not use native Clipboard API even if it is available
         * @config {Boolean}
         * @default true
         */
        useNativeClipboard : !VersionHelper.isTestEnv,

        /**
         * Provide a function to be able to customize the string value which is copied.
         *
         * ````javascript
         * new Grid({
         *     features : {
         *         cellCopyPaste : {
         *             toCopyString({currentValue, column, record}) {
         *                 if(record.isAvatar){
         *                     return record.fullName;
         *                 }
         *                 return currentValue;
         *             }
         *         }
         *     }
         * });
         * ````
         *
         * @param {Object} data
         * @param {String} data.currentValue
         * @param {Grid.column.Column} data.column
         * @param {Core.data.Model} data.record
         * @config {Function}
         */
        toCopyString : null,

        /**
         * Provide a function to be able to customize the value which will be set onto the record
         *
         * ````javascript
         * new Grid({
         *     features : {
         *         cellCopyPaste : {
         *             toPasteValue({currentValue, column, record, field}) {
         *                 if(typeof currentValue === 'string'){
         *                     return currentValue.replace('$', '');
         *                 }
         *                 return currentValue;
         *             }
         *         }
         *     }
         * });
         * ````
         *
         * @param {Object} data
         * @param {String} data.currentValue
         * @param {Grid.column.Column} data.column
         * @param {Core.data.Model} data.record
         * @config {Function}
         */
        toPasteValue : null,

        copyText  : 'L{copy}',
        cutText   : 'L{cut}',
        pasteText : 'L{paste}'
    }

    afterConstruct() {
        super.afterConstruct();
        this.afterSelectionModeChange();
    }

    afterSelectionModeChange() {
        const me = this;

        if (!me.client.selectionMode.cell) {
            me.disabled = true;
        }
        else if (me._disabledBySelectionMode) {
            me.disabled = false;
            delete me._disabledBySelectionMode;
        }
    }

    // Used in events to separate events from different features from each other
    entityName = 'cell';

    get copyOnly() {
        // If celledit is disabled, cut and paste actions are disabled by default
        return this._copyOnly || !this.client.features.cellEdit?.enabled;
    }

    get canCopy() {
        return !this.disabled && !this.client.selectedRecords.length && this.client.selectedCells.length;
    }

    get canCutPaste() {
        return this.canCopy && !this.copyOnly && !this.client.features.cellEdit?.isEditing && !this.client.readOnly;
    }

    // Called from keyMap. Also used internally here
    isActionAvailable(key, action) {
        return this.canCopy && (action === 'copy' || this.canCutPaste);
    }

    // Takes cell locations and converts them to tab and new-line separated string values.
    // Then stores them in native clipboard or the internal clipboard
    async sendToClipboard(cells) {
        const
            me           = this;
        let lastRowIndex = 0,
            lastColIndex = 0,
            stringData   = '';

        // Sorted by rowIndex then by columnIndex
        cells.sort((c1, c2) => c1.rowIndex === c2.rowIndex ? c1.columnIndex - c2.columnIndex : c1.rowIndex - c2.rowIndex);

        for (const cell of cells) {
            const { record, column, rowIndex, columnIndex } = cell;

            // Separate with \n if new row
            if (rowIndex > lastRowIndex) {
                if (stringData.length > 0) {
                    stringData += '\n'.repeat(rowIndex - lastRowIndex);
                }
                lastRowIndex = rowIndex;
                lastColIndex = columnIndex;
            }
            // Separate with \t if new column
            else if (columnIndex > lastColIndex) {
                if (stringData.length > 0) {
                    stringData += '\t'.repeat(columnIndex - lastColIndex);
                }
                lastColIndex = columnIndex;
            }

            // The column can provide its own toClipboardString
            let cellValue = column.toClipboardString?.(cell);

            // Or we use the raw value from the record
            if (cellValue === undefined) {
                cellValue = record.get(column.field)?.toString();
            }

            // The client can provide its own as well.
            if (me.toCopyString) {
                cellValue = me.toCopyString({ currentValue : cellValue, column, record });
            }

            cellValue = cellValue?.replace(/[\n\t]/, ' ');

            stringData += cellValue || me.emptyValueChar;
        }

        await BrowserHelper.writeToClipboard(stringData, this.useNativeClipboard);

        return stringData;
    }

    /**
     * Cuts selected cells to clipboard (native if accessible) to paste later
     * @async
     */
    async cut() {
        await this.copy(true);
    }

    /**
     * Copies selected cells to clipboard (native if accessible) to paste later
     * @async
     */
    async copy(cut) {
        const
            me    = this,
            {
                client,
                entityName
            }     = me,
            isCut = typeof cut === 'boolean' ? cut : false, // If called by keymap, arguments[0] will be an event
            cells = isCut ? client.selectedCells.filter(r => !r.record?.readOnly) : client.selectedCells;

        if (cells) {

            /**
             * Fires on the owning Grid before a copy action is performed, return `false` to prevent the action
             * @event beforeCopy
             * @preventable
             * @on-owner
             * @param {Grid.view.Grid} source Owner grid
             * @param {Grid.util.Location[]} cells The cells about to be copied or cut
             * @param {Boolean} isCut `true` if this is a cut action
             * @param {String} entityName 'cell' to distinguish this event from other beforeCopy events
             */
            if ((isCut ? !me.canCutPaste : !me.canCopy) ||
                client.trigger('beforeCopy', { cells, isCut, entityName }) === false
            ) {
                return;
            }

            const copiedDataString = await me.sendToClipboard(cells);

            if (isCut === true) {
                for (const cell of cells) {
                    if (!cell.column.readOnly) {
                        cell.record.set(cell.column.field, null);
                    }
                }
            }

            /**
             * Fires on the owning Grid after a copy action is performed.
             * @event copy
             * @on-owner
             * @param {Grid.view.Grid} source Owner grid
             * @param {Grid.util.Location[]} cells The cells about to be copied or cut
             * @param {String} copiedDataString The concatenated data string that was copied or cut
             * @param {Boolean} isCut `true` if this was a cut action
             * @param {String} entityName 'cell' to distinguish this event from other copy events
             */
            client.trigger('copy', { cells, copiedDataString, isCut, entityName });

        }
    }

    /**
     * Pastes string data into a cell or a range of cells. Either from native clipboard if that is accessible or from a
     * fallback clipboard that is only available to the owner Grid.
     *
     * The string data will be split on `\n` and `\t` and put in different rows and columns accordingly.
     *
     * Note that there must be a selected cell to paste the data into.
     * @async
     */
    async paste() {
        const
            me            = this,
            {
                client,
                entityName
            }             = me,
            clipboardData = await BrowserHelper.readFromClipboard(me.useNativeClipboard),
            targetCell    = client.selectedCells[0];

        /**
         * Fires on the owning Grid before a paste action is performed, return `false` to prevent the action
         * @event beforePaste
         * @preventable
         * @on-owner
         * @param {Grid.view.Grid} source Owner grid
         * @param {String} clipboardData The clipboardData about to be pasted
         * @param {Grid.util.Location} targetCell The cell from which the paste will be started
         * @param {String} entityName 'cell' to distinguish this event from other beforePaste events
         */
        if (
            !me.canCutPaste ||
            !clipboardData?.length ||
            !targetCell ||
            client.trigger('beforePaste', { clipboardData, targetCell, entityName }) === false
        ) {
            return;
        }

        const
            modifiedRecords       = new Set(),
            // Converts the clipboard data into a 2-dimensional array of string values.
            rows                  = me.stringAs2dArray(clipboardData),
            targetCells           = [],
            { _shiftSelectRange } = client;

        // No valid clipboard data, break
        if (!rows?.length) {
            return;
        }

        // If there is a selected range, pasting should be repeated into that range
        if (_shiftSelectRange?.some(cell => cell.equals(targetCell))) {
            const cellRows = me.cellSelectorsAs2dArray(_shiftSelectRange);

            // The selection must fit the whole paste content. If pasting 2 rows for example, a number of rows that is
            // divisible by 2 is required. Same for columns.
            if (cellRows?.length % rows.length === 0 && cellRows.columnCount % rows.columnCount === 0) {
                // This code will calculate each cell target to repeat the pasting on
                for (let curI = 0; curI < cellRows.length; curI += rows.length) {
                    for (let curX = 0; curX < cellRows.columnCount; curX += rows.columnCount) {
                        targetCells.push(cellRows[curI][curX]);
                    }
                }
            }
        }

        // No valid range, just use one target
        if (!targetCells.length) {
            targetCells.push(targetCell);
        }

        for (const targetCell of targetCells) {
            for (let rI = 0; rI < rows.length; rI++) {
                const
                    row          = rows[rI],
                    targetRecord = client.store.getAt(targetCell.rowIndex + rI);

                // Starts with targetCell rowIndex and columnIndex and applies values from the clipboard string.
                if (targetRecord && !targetRecord.readOnly) {
                    for (let cI = 0; cI < row.length; cI++) {
                        const
                            targetColumn = client.columns.getAt(targetCell.columnIndex + cI),
                            targetField  = targetColumn?.field;
                        let value        = row[cI];

                        // If no value, this column is skipped
                        if (targetField && value && !targetColumn.readOnly) {
                            if (value === me.emptyValueChar) {
                                value = null;
                            }

                            // Column provided paste conversion function
                            if (targetColumn.fromClipboardString) {
                                value = targetColumn.fromClipboardString({
                                    string : value,
                                    record : targetRecord
                                });
                            }

                            // Client provided paste customization function
                            if (me.toPasteValue) {
                                value = me.toPasteValue({
                                    currentValue : value,
                                    record       : targetRecord,
                                    column       : targetColumn,
                                    field        : targetField
                                });
                            }

                            targetRecord.set(targetField, value, false, false, false, true);
                            modifiedRecords.add(targetRecord);
                        }
                    }
                }
            }
        }

        /**
         * Fires on the owning Grid after a paste action is performed.
         * @event paste
         * @on-owner
         * @param {Grid.view.Grid} source Owner grid
         * @param {String} clipboardData The clipboardData that was pasted
         * @param {Core.data.Model[]} modifiedRecords The records which have been modified due to the paste action
         * @param {Grid.util.Location} targetCell The cell from which the paste will be started
         * @param {String} entityName 'cell' to distinguish this event from other paste events
         */
        client.trigger('paste', { clipboardData, targetCell, modifiedRecords : [...modifiedRecords], entityName });
    }

    /**
     * Converts an array of Location objects to a two-dimensional array where first level is rows and second level is
     * columns. If the array is inconsistent in the number of columns present for each row, the function will return
     * false.
     * @param {Grid.util.Location[]} locations
     * @private
     */
    cellSelectorsAs2dArray(locations) {
        const
            rows = [];
        let rId  = null,
            columns;

        for (const location of locations) {
            // If new id (new record) create new "row"
            if (location.id !== rId) {
                rId = location.id;
                columns = [];
                rows.push(columns);
            }
            columns.push(location);
        }

        // Save number of "columns" for easier access
        rows.columnCount = rows[0].length;

        // All "rows" must have the same number of columns
        if (rows.some(row => row.length !== rows.columnCount)) {
            return false;
        }

        return rows;
    }

    /**
     * Converts a new-line- and tab-separated string to a two-dimensional array where first level is rows and second
     * level is columns. If the string is inconsistent in the number of columns present for each row, the function will
     * return false.
     * @param {String} string String values separated with new-line(\n,\r or similar) and tabs (\t)
     * @private
     */
    stringAs2dArray(string) {
        const
            rows       = [],
            stringRows = string.split(/\r\n|(?!\r\n)[\n-\r\x85\u2028\u2029]/);

        for (const row of stringRows) {
            const columns = row.split('\t');

            // All "rows" must have the same number of columns
            if (rows.columnCount && columns.length !== rows.columnCount) {
                return false;
            }
            // Save number of "columns" for easier access
            rows.columnCount = columns.length;
            rows.push(columns);
        }
        return rows;
    }

    populateCellMenu({ record, items }) {
        const me = this;

        if (me.canCopy) {
            items.cutCell = {
                text        : me.cutText,
                localeClass : me,
                icon        : 'b-icon b-icon-cut',
                weight      : 115,
                disabled    : record.readOnly || !me.canCutPaste,
                onItem      : () => me.cut()
            };

            items.pasteCell = {
                text        : me.pasteText,
                localeClass : me,
                icon        : 'b-icon b-icon-paste',
                weight      : 120,
                disabled    : record.readOnly || !me.canCutPaste,
                onItem      : () => me.paste()
            };

            items.copyCell = {
                text        : me.copyText,
                localeClass : me,
                cls         : 'b-separator',
                icon        : 'b-icon b-icon-copy',
                weight      : 110,
                onItem      : () => me.copy()
            };
        }
    }
}

GridFeatureManager.registerFeature(CellCopyPaste);
