import TreeColumn from '../column/TreeColumn.js';
import InstancePlugin from '../../Core/mixin/InstancePlugin.js';
import GridFeatureManager from './GridFeatureManager.js';
import ObjectHelper from '../../Core/helper/ObjectHelper.js';

/**
 * @module Grid/feature/TreeGroup
 */

/**
 * A feature that allows transforming a flat dataset (or the leaves of a hierarchical) into a tree by specifying a
 * record field per parent level. Parents are generated based on each leaf's value for those fields.
 *
 * {@inlineexample Grid/feature/TreeGroup.js}
 *
 * This feature can be used to mimic multi grouping or to generate another view for hierarchical data. The actual
 * transformation happens in a new store, that contains links to the original records. The original stores structure is
 * kept intact and will be plugged back in when calling {@link #function-clearGroups}.
 *
 * Any modification of the links is relayed to the original store. So cell editing etc. will work as expected and the
 * original data will be updated.
 *
 * <div class="note">
 * Please note that this feature requires using a {@link Grid.view.TreeGrid} or having the {@link Grid.feature.Tree}
 * feature enabled.
 * </div>
 *
 * This snippet shows how the sample dataset used in the demo above is transformed:
 *
 * ```javascript
 * const grid = new TreeGrid({
 *     // Original data
 *     data : [
 *         { id : 1, name : 'Project 1', children : [
 *             { id : 11, name : 'Task 11', status : 'wip', prio : 'high' },
 *             { id : 12, name : 'Task 12', status : 'done', prio : 'low' },
 *             { id : 13, name : 'Task 13', status : 'done', prio : 'high' }
 *         ]},
 *         { id : 2, name : 'Project 2', children : [
 *             { id : 21, name : 'Task 21', status : 'wip', prio : 'high' },
 *         ]}
 *     ],
 *
 *     features : {
 *         treeGroup : {
 *             // Fields to build a new tree from
 *             levels : [ 'prio', 'status' ]
 *         }
 *     }
 * });
 *
 * // Resulting data
 * [
 *     { name : 'low', children : [
 *         { name : 'done', children : [
 *             { id : 12, name : 'Task 12', status : 'done', prio : 'low' }
 *         ]}
 *     ]},
 *     { name : 'high', children : [
 *         { name : 'done', children : [
 *             { id : 13, name : 'Task 13', status : 'done', prio : 'high' }
 *         ]},
 *         { name : 'wip', children : [
 *             { id : 11, name : 'Task 11', status : 'wip', prio : 'high' },
 *             { id : 21, name : 'Task 21', status : 'wip', prio : 'low' }
 *         ]}
 *     ]}
 * ]
 * ```
 *
 * ## Important information
 *
 * Using the TreeGroup feature comes with some caveats:
 *
 * * Generated parents are read-only, they cannot be edited using the default UI.
 * * Moving nodes manually in the tree is not supported while it is grouped. The linked records have their own
 *   `parentId` fields, not linked to the original records value.
 * * The generated structure is not meant to be persisted.
 *
 * <div class="note">
 * Please note that this feature is not supported in vertical mode in Scheduler.
 * </div>
 *
 * This feature is <strong>disabled</strong> by default.
 *
 * @extends Core/mixin/InstancePlugin
 *
 * @classtype treeGroup
 * @feature
 */
export default class TreeGroup extends InstancePlugin {
    static $name = 'TreeGroup';

    static configurable = {
        /**
         * An array of model field names or functions used to determine the levels in the resulting tree.
         *
         * When supplying a function, it will be called for each leaf in the original data, and it is expected to return
         * an atomic value used to determine which parent the leaf will be added to at that level.
         *
         * ```javascript
         * const grid = new TreeGrid({
         *     features : {
         *         treeGroup : {
         *             levels : [
         *                 // First level is determined by the value of the status field
         *                 'status',
         *                 // Second level by the result of this function
         *                 // (which puts percentdone 0-9 in one group, 10-19 into another and so on)
         *                 record => (record.percentDone % 10) * 10
         *             ]
         *         }
         *     }
         * });
         * ```
         *
         * The function form can also be used as a formatter/renderer of sorts, simply by returning a string:
         *
         * ```javascript
         * const grid = new TreeGrid({
         *     features : {
         *         treeGroup : {
         *             levels : [
         *                 record => `Status: ${record.status}`
         *             ]
         *         }
         *     }
         * });
         * ```
         *
         * Assigning `null` restores data to its original state.
         *
         * @prp {Array<String|Function(Core.data.Model) : any>} levels
         */
        levels : null,

        /**
         * CSS class to apply to the generated parents.
         *
         * @config {String}
         * @default
         */
        parentCls : 'b-generated-parent'
    };

    static pluginConfig = {
        assign : ['group', 'clearGroups']
    }

    static properties = {
        isApplying    : 0,
        originalStore : null
    }

    construct(grid, config) {
        super.construct(grid, config);

        if (!grid.hasFeature('tree')) {
            throw new Error('The TreeGroup feature requires the Tree feature to be enabled');
        }
    }

    processParentData(parentData) {
        // Apply cls to allow custom styling of generated parents
        if (this.parentCls) {
            parentData.cls = this.parentCls;
        }
    }

    processTransformedData(transformedData) {}

    async waitForReadiness() {
        // Wait for store to finish loading before transforming the data
        if (this.originalStore.isLoading) {
            await this.originalStore.await('load', false);

            if (this.isDestroyed) {
                return;
            }
        }

        // For Scheduler, Pro & Gantt, to not have to implement a TreeGroup in Scheduler just to add this
        const { crudManager } = this.client;

        if (crudManager) {
            if (crudManager.isLoadingOrSyncing) {
                await crudManager.await('requestDone');

                if (this.isDestroyed) {
                    return;
                }
            }

            await this.client.project.commitAsync();
        }
    }

    async applyLevels(levels) {
        const
            me         = this,
            { client } = me,
            treeColumn = client.columns.find(col => col instanceof TreeColumn);

        let { store } = client,
            result    = null;

        me._levels = levels;

        me.isApplying++;

        client.suspendRefresh();

        if (levels && !me.originalStore) {
            me.originalStore = store;
            store = new store.constructor({
                tree       : true,
                modelClass : store.modelClass
            });
            client.store = store;
        }

        await me.waitForReadiness();

        if (me.isDestroyed) {
            return;
        }

        // Applying custom levels
        if (levels) {
            // Plug links in to allow transforming them below
            store.data = me.originalStore.allRecords.flatMap(record => record.isLeaf ? [record.link()] : []);

            // Transform it according to levels
            result = store.treeify(levels, parentData => {
                // Use group key as tree columns content
                ObjectHelper.setPath(parentData, store.modelClass.getFieldDataSource(treeColumn.field), parentData.key);

                // Let the outside world manipulate generated parents data before turning it into a record
                me.processParentData(parentData);
            });

            me.processTransformedData(result);

            // Load the transformed result into the "display store"
            store.data = result.children;
        }
        // Clearing custom levels
        else {
            client.store = me.originalStore;
            me.originalStore = null;
        }

        me.isApplying--;

        client.resumeRefresh();
        client.rowManager.reinitialize();

        return result;
    }

    updateLevels(levels) {
        if (levels || !this.isConfiguring) {
            this.applyLevels(levels);
        }
    }

    /**
     * Transforms the data according to the supplied levels.
     *
     * Yields the same result as assigning to {@link #property-levels}.
     *
     * ```javascript
     * // Transform into a tree with two parent levels
     * grid.group('status', record => (record.percentDone % 10) * 10);
     * ```
     *
     * @param {Array<String|Function(Core.data.Model) : any>} levels Field names or functions use to generate parents in resulting tree.
     * @on-owner
     * @category Common
     */
    async group(levels) {
        ObjectHelper.assertArray(levels, 'group()');

        await this.applyLevels(levels);
    }

    /**
     * Clears the previously applied transformation, restoring data to its initial state.
     *
     * Yields the same result as assigning `null` to {@link #property-levels}.
     *
     * ```javascript
     * // Restore original data
     * grid.clearGroupers();
     * ```
     * @on-owner
     * @category Common
     */
    async clearGroups() {
        if (this.isGrouped) {
            await this.applyLevels(null);
        }
    }

    get isGrouped() {
        return Boolean(this._levels);
    }
}

GridFeatureManager.registerFeature(TreeGroup);
