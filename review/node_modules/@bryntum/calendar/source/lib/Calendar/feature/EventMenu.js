import CalendarFeature from './CalendarFeature.js';
import SchedulerEventMenu from '../../Scheduler/feature/EventMenu.js';

/**
 * @module Calendar/feature/EventMenu
 */
const hasEventStore = w => w.eventStore;

/**
 * A feature which adds a context menu to the events in the calendar.
 *
 * There are three predefined {@link #config-items} provided by default:
 *
 * - `deleteEvent` Delete the event clicked upon.
 * - `editEvent` Edit the event clicked upon __Only present if the {@link Calendar.feature.EventEdit}
 * feature is present__ (which it is by default).
 * - `duplicate` Duplicate the event clicked upon with the same time and duration, the same
 * resource(s) assigned and a slightly edited name - `"<old name> (copy)"`.
 *
 * The {@link #config-items} set can be reconfigured by providing an `items` property to this feature:
 *
 *```javascript
 * features : {
 *     eventMenu : {
 *         items : {
 *             // Knocks out the predefined deleteEvent item
 *             deleteEvent : null,
 *
 *             // Add our own custom item
 *             myMenuItem : {
 *                  icon    : 'b-fa b-fa-clone',
 *                  text    : 'Duplicate event',
 *
 *                  // Will look up ownership chain and find the Calendar
 *                  handler : 'up.duplicateEvent'
 *             }
 *         }
 *     }
 * },
 * duplicateEvent({ eventRecord }) {
 *     const dupe = eventRecord.copy();
 *
 *     // In case it was a recurring event, the dupe will be a one-off.
 *     dupe.recurrence = null;
 *     this.eventStore.add(dupe);
 * }
 *```
 *
 * This feature is enabled by default.
 *
 * @demo Calendar/custom-menus
 * @extends Scheduler/feature/EventMenu
 * @classType eventMenu
 * @feature
 *
 * @typings Scheduler/feature/EventMenu -> Scheduler/feature/SchedulerEventMenu
 */
export default class EventMenu extends SchedulerEventMenu {
    // Do not remove. Assertion strings for Localization sanity check.
    // 'L{copy}'
    // 'L{duplicateEvent}'

    static get $name() {
        return 'EventMenu';
    }

    static get type() {
        return 'eventMenu';
    }

    static configurable = {
        items : {
            duplicate : {
                text   : 'L{EventMenu.duplicateEvent}',
                icon   : 'b-icon b-icon-copy',
                weight : 400,
                onItem({ eventRecord }) {
                    const
                        dupe           = eventRecord.copy(null, { skipFieldIdentifiers : true }),
                        { eventStore } = this.up(hasEventStore),
                        { resources }  = eventRecord;

                    // Make a new name
                    dupe.name = `${eventRecord.name} (${this.L('copy')})`;
                    // In case it was a recurring event, the dupe will be a one-off.
                    dupe.recurrence = null;
                    // Dupe has same assignments initially handle usesSingleAssign as well as multiassign.
                    // If an event without a resource is duplicated
                    if (resources?.length) {
                        eventStore.assignmentStore.assignEventToResource(dupe, resources);
                    }
                    eventStore.add(dupe);
                }
            }
        }
    }

    // Superclass registers this as a chained function.
    populateEventMenu({ items, eventRecord, assignmentRecord }) {
        super.populateEventMenu(...arguments);

        const { client } = this;

        // Hide the duplicate
        items.duplicate = {
            disabled : eventRecord.readOnly || assignmentRecord?.readOnly,
            hidden   : client.readOnly
        };
    }

    getDataFromEvent(event) {
        const
            { client }     = this,
            { activeView } = client;

        // Base class is SchedulerEventMenu
        if (activeView.isScheduler) {
            this.client = activeView;
        }
        const result = super.getDataFromEvent(event);
        this.client = client;
        return result;
    }

    changeMenu() {
        const
            me     = this,
            result = super.changeMenu(...arguments);

        // Set the owner to be the currently active view (or its active OverflowPopup)
        // so that focus stays in that view's ownership tree.
        result?.ion({
            beforeShow({ source }) {
                const
                    { activeSubView }  = me.client,
                    { _overflowPopup } = activeSubView;

                source.owner = _overflowPopup?.containsFocus ? _overflowPopup : activeSubView;
            }
        });

        return result;
    }

    changeItems(items) {
        items = super.changeItems(...arguments);

        // UnassignEvent is not valid where there is no contextual resource as there is in Scheduler where
        // the row denotes the contextual resource
        items.unassignEvent = null;
        return items;
    }
}

// Register this feature type with its Factory
CalendarFeature.register(EventMenu.type, EventMenu);
