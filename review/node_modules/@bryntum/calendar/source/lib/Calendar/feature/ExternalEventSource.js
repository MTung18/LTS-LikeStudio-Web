import Base from '../../Core/Base.js';
import CalendarFeature from './CalendarFeature.js';
import Draggable from '../../Core/mixin/Draggable.js';
import DateHelper from '../../Core/helper/DateHelper.js';
import DomHelper from '../../Core/helper/DomHelper.js';
import EventHelper from '../../Core/helper/EventHelper.js';
import Rectangle from '../../Core/helper/util/Rectangle.js';
import Delayable from '../../Core/mixin/Delayable.js';
import Widget from '../../Core/widget/Widget.js';

/**
 * @module Calendar/feature/ExternalEventSource
 */
const oneHour = {
    magnitude : 1,
    unit      : 'hour'
};

class ExternalZone extends Base.mixin(Draggable) {
    static get configurable() {
        return {
            // Default to dragging grid rows
            dragItemSelector : '.b-grid-row',

            droppable : false,

            dragProxy : {
                type : 'default',

                open(drag) {
                    // Use the Feature's openProxy
                    return this.owner.owner.openProxy(drag);
                },

                dragMove(drag) {
                    // Use the Feature's moveProxy
                    return this.owner.owner.moveProxy(drag);
                },

                close() {
                    this.owner.owner.proxyEl?.remove();
                }
            }
        };
    }

    beforeDrag(drag) {
        return this.owner.onDragStart(drag);
    }
}

/**
 * A Calendar feature which allows new events to be dragged into the Calendar from an external source.
 *
 * The default source type is a Bryntum {@link Grid.view.Grid grid} which is loaded with
 * {@link Scheduler.model.EventModel event records}.
 *
 * Optionally, the source can be specified by configuring a {@link #config-dragRootElement}
 * and a {@link #config-dragItemSelector} which together, identify elements which represent
 * draggable events.
 *
 * In this case, a {@link #config-getRecordFromElement} may be specified to yield the details of
 * the record to be dragged.
 *
 * In the simplest case the `textContent` of the identified element is used as the event name and
 * {@link #config-getRecordFromElement} is not required. The event duration in this case will be
 * that specified in the receiving Calendar's {@link Calendar.view.Calendar#config-autoCreate} setting.
 *
 * When dropping an unscheduled event (An event that has no start and end date specified) into
 * a day cell (For example a MonthView or YearView), the start *time* set within the day cell
 * will default to the `startHour` property of the receiving Calendar's {@link Calendar.view.Calendar#config-autoCreate} setting.
 *
 * @demo Calendar/dragfromgrid
 * @inlineexample Calendar/feature/ExternalEventSource.js
 * @extends Calendar/feature/CalendarFeature
 * @classType externalEventSource
 * @feature
 */
export default class ExternalEventSource extends CalendarFeature.mixin(Delayable) {
    static get $name() {
        return 'ExternalEventSource';
    }

    static get delayable() {
        return {
            onCalendarPaint : 'raf'
        };
    }

    static get type() {
        return 'externalEventSource';
    }

    static get configurable() {
        return {
            /**
             * The grid, or `id` of a grid from which events are to be dragged.
             * @config {Grid.view.Grid|String}
             */
            grid : {
                $config : ['lazy'],
                value   : null
            },

            /**
             * If not dragging from a grid, which is the default mode, then an element from which
             * dragging can take place must be supplied in the `dragRootElement` config.
             *
             * May also be specified as a selector which matches a unique element, or a simple element id.
             *
             * In this case a {@link #config-dragItemSelector} string, and {@link #config-getRecordFromElement}
             * function must be supplied to allow event records to be sourced from the element, for example:
             *
             * ```javascript
             * features : {
             *     externalEventSource : {
             *         dragRootElement  : '#mySourceElementId',
             *         dragItemSelector : '.my-item-class'
             *     }
             * }```
             * @config {HTMLElement|String}
             */
            dragRootElement : null,

            /**
             * If not dragging from a grid, which is the default mode, then a selector which identifies
             * draggable elements within the {@link #config-dragRootElement}.
             *
             * In the simplest case, the identified element may contain simply a string which is used
             * as the event name, for example:
             *
             * ```javascript
             * features : {
             *     externalEventSource : {
             *         dragRootElement  : '#mySourceElementId',
             *         dragItemSelector : '.my-item-class'
             *     }
             * }```
             * @config {String}
             */
            dragItemSelector : null,

            /**
             * If not dragging from a grid, which is the default mode, then a function which returns
             * an event record to drag from a passed element must be supplied.
             *
             * In this case a {@link #config-dragRootElement} and a {@link #config-dragItemSelector} string
             * may be supplied to allow event records to be sourced from the element.
             *
             * If the element identified by the {@link #config-dragItemSelector} just contains an event
             * name to create, this configuration is optional. A new event will be created by that name, for example:
             *
             * ```javascript
             * features : {
             *     externalEventSource : {
             *         dragRootElement  : '#mySourceElementId',
             *         dragItemSelector : '.my-item-class',
             *         getRecordFromElement(element) {
             *             // Return an object from which an EventModel can be created.
             *             // Same format as loading an EventStore. { name : 'name', startDate: ''} etc
             *             return myController.createRecordFromElement(element);
             *         }
             *     }
             * }```
             * @config {Function|String}
             */
            getRecordFromElement : function(element) {
                const grid = this.grid || (this.grid = Widget.fromElement(element, 'grid'));

                if (grid) {
                    return grid.getRecordFromElement(element);
                }

                // The simplest implementation is that the elements identified by
                // the selector yield the event name.
                return element.innerText;
            },

            /**
             * By default, the proxy shown when "picking up" the grid row is hidden
             * when dragging over the calendar because the {@link Calendar.feature.CalendarDrag}
             * feature automatically shows a drop position indicator which shows where the
             * proposed new event will be.
             * @config {Boolean}
             * @default
             */
            hideExternalProxy : true,

            /**
             * An object which overrides or augments the default configuration for the
             * {@link Core.mixin.Draggable} which handles picking up events.
             *
             * This is only necessary if there is no {@link #config-grid} specified.
             * @config {Object} [draggable]
             * @default
             */
            draggable : {
                $config : ['lazy'],
                value   : {}
            }
        };
    }

    // This is deferred to the next AF to allow the configured grid ID to be available
    onCalendarPaint({ firstPaint }) {
        // Ingestion of Draggable, and within that, grid is deferred until the host Calendar is painted
        if (firstPaint) {
            this.getConfig('draggable');
        }
    }

    onDragStart(drag) {
        const
            me             = this,
            { client }     = me,
            { eventStore } = client,
            { modelClass } = eventStore;

        // If mousedown was not on our Draggable's dragItemSelector, veto drag start
        if (!drag.itemElement) {
            return false;
        }

        let eventRecord = me.callback(me.getRecordFromElement, me, [drag.itemElement]);

        if (eventRecord.isModel) {
            if (!eventRecord.isEventModel) {
                eventRecord = eventStore.createRecord(eventRecord.data);
            }
        }
        else {
            if (typeof eventRecord === 'string') {
                const
                    autoCreate = client.activeView.autoCreate || client.autoCreate,
                    duration   = DateHelper.parseDuration(autoCreate?.duration || oneHour);

                eventRecord = {
                    [modelClass.getFieldDataSource('name')]         : eventRecord,
                    [modelClass.getFieldDataSource('duration')]     : duration.magnitude,
                    [modelClass.getFieldDataSource('durationUnit')] : duration.unit
                };
            }

            eventRecord = eventStore.createRecord(eventRecord);
        }

        drag.set('sourceStore', me.grid?.store);
        drag.set('eventRecord', eventRecord);
    }

    openProxy(drag) {
        const
            { grid } = this,
            sourceEl = drag.element.closest(this.draggable.dragItemSelector),
            nameCell = sourceEl.querySelector('[data-column="name"]'),
            proxyEl  = this.proxyEl = DomHelper.createElement({
                className : 'b-grid-to-cal-drag-proxy'
            });

        proxyEl.innerHTML = nameCell ? nameCell.innerHTML : drag.peek('eventRecord').name;

        this.proxyOffset = EventHelper.getClientPoint(drag.startEvent).getDelta(Rectangle.from(sourceEl));

        (grid?.element || this.dragRootElement).parentNode.appendChild(proxyEl);
    }

    moveProxy(drag) {
        const { proxyEl } = this;

        if (proxyEl) {
            // Hide the proxy if the target droppable is a Calendar and we are configured to do so
            if (this.client.owns(drag.targetElement) && this.hideExternalProxy) {
                proxyEl.classList.add('b-hide-display');
            }
            else {
                // Align the proxy to [10, 10] from the pointer
                proxyEl.classList.remove('b-hide-display');
                DomHelper.alignTo(proxyEl, EventHelper.getClientPoint(drag.event).translate(10, 10), {
                    align : 't0-t0'
                });
            }
        }
    }

    changeDragRootElement(dragRootElement) {
        if (typeof dragRootElement === 'string') {
            dragRootElement = document.querySelector(dragRootElement) || document.getElementById(dragRootElement);
        }
        return dragRootElement;
    }

    changeDraggable(draggable) {
        const
            { grid }             = this,
            dragRootElement      = grid?.contentElement || this.dragRootElement,
            { dragItemSelector } = this;

        draggable = ExternalEventSource.mergeConfigs({
            owner : this,
            grid
        }, draggable);
        if (dragRootElement) {
            draggable.dragRootElement = dragRootElement;
        }
        if (dragItemSelector) {
            draggable.dragItemSelector = dragItemSelector;
        }

        return new ExternalZone(draggable);
    }

    changeGrid(grid) {
        if (typeof grid === 'string') {
            grid = Widget.getById(grid);
        }
        return grid;
    }
}

ExternalEventSource.initClass();
