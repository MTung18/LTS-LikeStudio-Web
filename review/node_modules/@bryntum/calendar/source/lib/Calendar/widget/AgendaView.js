import EventList from '../../Calendar/widget/EventList.js';
import DH from '../../Core/helper/DateHelper.js';
import ArrayHelper from '../../Core/helper/ArrayHelper.js';
import Responsive from '../../Core/widget/mixin/Responsive.js';
import GridRowModel from '../../Grid/data/GridRowModel.js';
import EventSorter from '../util/EventSorter.js';
import DomHelper from '../../Core/helper/DomHelper.js';

import '../column/AgendaColumn.js';

/**
 * @module Calendar/widget/AgendaView
 */

const
    isMouseOverOut = {
        mouseover : 1,
        mouseout  : 1
    },
    isMouseInteraction = {
        mousedown   : 1,
        mouseup     : 1,
        click       : 1,
        dblclick    : 1,
        contextmenu : 1
    };

/**
 * This is normally used as a {@link Calendar.view.Calendar#config-modes mode} of a Calendar
 * but may be used standalone as a regular Widget.
 *
 * As a standalone widget, it will lack the capabilities of the {@link Calendar.view.Calendar Calendar}
 * class, such as keyboard-based event to event navigation and drag/drop features.
 *
 * A Grid which displays an agenda view of the events in an EventStore.
 *
 * When used as a {@link Calendar.view.Calendar#config-modes mode} of a Calendar, the configured
 * {@link #config-range} is snapped to encapsulate the Calendar's current
 * {@link Calendar.view.Calendar#config-date}.
 *
 * The AgendaView offers a floating settings button to allow the user to change the range type.
 *
 * @extends Calendar/widget/EventList
 * @classType agendaview
 * @inlineexample Calendar/widget/AgendaView.js
 */
export default class AgendaView extends EventList.mixin(Responsive) {
    static get $name() {
        return 'AgendaView';
    }

    // Factoryable type name
    static get type() {
        return 'agendaview';
    }

    static get configurable() {
        return {
            features : null,

            eventSorter : EventSorter.interDaySorterFn,

            /**
             * The spacing between event bars in the default rendering of a day cell.
             * @config {Number|String}
             * @default
             */
            eventRowSpacing : 8,

            title : 'L{Agenda}',

            range : 'year',

            /**
             * By default, long running events are repeated in all rows that the event covers.
             *
             * Configure this as `true` to only see the start of a long running event in its
             * start day.
             * @config {Boolean}
             */
            hideEventOverflow : null,

            /**
             * This view lines up the textual content of event bars by shifting event bars of
             * events which start before the bar's cell leftwards by the arrow width.
             *
             * Set this config to `false` to prevent this.
             * @prp {Boolean}
             * @default
             */
            offsetStartsBeforeEvents : true,

            // We handle this internally using the notifications from the GridElementEvents mixin
            handlePointerInteraction : false,

            /**
             * An empty function by default, but provided so that you can override it.
             *
             * This function is called for each cell rendered to allow developers to mutate the cell metadata, or
             * the CSS classes to be applied to the cell.
             *
             * The cellData (a {@link Core.helper.DomHelper#typedef-DomConfig}) object parameter may be mutated to
             * customize the cell appearance via `style` and `className` properties.
             *
             * ```javascript
             * dayCellRenderer : function(cellData) {
             *     // I don't like Mondays!
             *     if (cellData.day === 1) {
             *         cellData.cls['hackathon-dayoff'] = true;
             *         cellData.style.fontWeight = 'bold';
             *
             *         cellData.isNonWorking = true;
             *
             *         return `${cellData.date.getDate()} Day off yay!`;
             *     }
             * }
             *
             *```
             * A non-null return value from the renderer is used as the content of the day number element.
             *
             * @config {Function} dayCellRenderer
             * @param {DayCell} cellData An object that contains data about the cell.
             */
            dayCellRenderer : null,

            /**
             * An empty function by default, but provided so that you can override it.
             *
             * This function is called each time an event is rendered to to allow developers to mutate
             * the cell metadata, or the CSS classes to be applied to the event element.
             *
             * It's called with the event record, and a eventData object which allows you to mutate event metadata
             * such as 'cls', 'style'.
             *
             * The cls property is an object whose property names will be added to the event element if the property value is truthy.
             *
             * The style property is an object containing style properties for the event element.
             *
             * A non-null return value from the renderer is used as the event body content. A nullish
             * return value causes the default renderer to be used which just uses the event name.
             *
             * If a string is returned, it is used as the HTML content of the event body element.
             *
             * If an object is returned, it is used as a {@link Core.helper.DomHelper#typedef-DomConfig} object to
             * create complex content in the event body element.
             *
             * ```javascript
             *  eventRenderer(eventRecord, eventData) {
             *      if (eventRecord.name === 'Doctors appointment') {
             *          eventData.style.fontWeight = 'bold';
             *          eventData.cls['custom-cls'] = 1;
             *
             *          return 'Special doctors appointment';
             *      }
             *  }
             * ```
             * IMPORTANT: When returning content, be sure to consider how that content should be encoded to avoid XSS
             * (Cross-Site Scripting) attacks. This is especially important when including user-controlled data such as
             * the event's `name`. The function {@link Core.helper.StringHelper#function-encodeHtml-static} as well as
             * {@link Core.helper.StringHelper#function-xss-static} can be helpful in these cases.
             *
             * For example:
             * ```javascript
             *  eventRenderer(eventRecord, eventData) {
             *      return StringHelper.xss`Event: ${eventRecord.name}`;
             *  }
             * ```
             * @config {Function} eventRenderer
             * @param {Object} detail An object that contains data about the event being rendered.
             * @param {Scheduler.model.EventModel} detail.eventRecord The event record
             * @param {Scheduler.model.ResourceModel} detail.resourceRecord The event record
             * @param {Object} detail.renderData A data object containing properties that will be used to create the event element.
             * @param {Object} detail.renderData.style The style property is an object containing style properties for
             * the event element.
             * @param {Object} detail.renderData.cls The cls property is an object whose property names will be added to
             * the event element if the property value is truthy.
             * @param {String} detail.renderData.eventColor Color to be applied to the event
             * @param {Number} detail.renderData.eventHeight The current view's configured {@link Calendar.widget.mixin.CalendarMixin#config-eventHeight eventHeight}.
             * For the AgendaView, the renderer may modify this to a different value. `'auto'` means that the
             * content returned by the renderer will determine the height.
             */
            eventRenderer : null,

            /**
             * Specify `false` to display column headers
             * @config {Boolean}
             * @default
             * @category Misc
             */
            hideHeaders : true,

            /**
             * Column definitions.
             *
             * By default, a single {@link Calendar.column.AgendaColumn} is configured which creates
             * the default cell content for one day's events.
             *
             * You may configure the default agenda column away, and provide a custom column type
             * to produce the day's content where the `record` passed is a
             * {@link Calendar.widget.mixin.DayCellCollecter#typedef-DayCell}.
             *
             * Because cells may contain varying numbers of events, all columns in an AgendaView are
             * set to {@link Grid.column.Column#config-autoHeight}
             *
             * ```javascript
             * class MyAgendaColumn extends Column {
             *     // So we automatically get b-myagenda-cell class on the cells
             *     static get type() {
             *         return 'myagenda';
             *     }
             *
             *     renderer({ cellElement, record : cellData }) {
             *         // Create a DomHelper element configuration object here using cellData
             *         // cellData contains date contextual info and an events array.
             *     }
             * }
             *
             * ...
             *
             * {
             *     columns : {
             *         agenda : null,
             *         {
             *             type : 'mycolumntype'
             *         }
             *     }
             * }
             *
             * // Register this Column type so that in the app we can use type : 'myagendacolumn'
             * ColumnStore.registerColumnType(MyAgendaColumn);
             *```
             * @config {Object|Object[]}
             * @default { agenda : { type : 'agendacolumn' } }
             */
            columns : {
                // We knock out the columns we inherit from EventList.
                name      : null,
                startDate : null,
                endDate   : null,
                resources : null,
                agenda    : {
                    type : 'agendacolumn'
                }
            },

            /**
             * A function, or name of a function in the ownership hierarchy which is used to create
             * the time output next to event bars in an agenda cell.
             * @config {Function|String}
             * @param {Scheduler.model.EventModel} eventRecord The event record for which to create a time string.
             * @param {Date} date The date of the cell in which the event is being rendered.
             */
            eventTimeRenderer : null,

            enableSticky                  : true,
            preserveScrollOnDatasetChange : true,
            positionMode                  : 'position',

            settings : {},

            cellTabIndex : null,

            rowCls : {
                'b-cal-agenda-grid-row' : 1
            },

            cellCls : {
                'b-calendar-cell' : 1
            },

            eventBarContainerCls : 'b-cal-event-bar-container',

            // No GridNavigation key events in an AgendaView. It is natural, event-to-event navigation.
            keyMap : null
        };
    }

    /**
     * Returns the resource associated with this agenda view when used inside a {@link Calendar.widget.ResourceView}
     * @readonly
     * @member {Scheduler.model.ResourceModel} resource
     */

    construct(config) {
        const me = this;

        // Disable GridFeatures in AgendaView.
        // This is necessary in the built version where the features are all included
        // because of the needs of the docs app to use Grid for its own UI and because
        // many documentation examples run Grid examples.
        // This should change when https://github.com/bryntum/bryntum-suite/issues/1475 is addressed
        Object.defineProperty(me, 'features', {
            get : () => {
                return {};
            },
            set : () => {}
        });
        super.construct(config);

        // CalendarNavigation focuses event bars
        me.bodyContainer.removeAttribute('tabIndex');
    }

    onResponsiveStateChange({ state, oldState }) {
        super.onResponsiveStateChange?.(...arguments);

        // Moving between small and non-small state requires a refresh because the cell
        // layout changes and the rows need remeasuring and repositioning.
        if (oldState && (oldState === 'small' || state === 'small')) {
            this.refresh();
        }
    }

    changeColumns() {
        const result = super.changeColumns(...arguments);

        // Custom columns and AgendaColumns with custom renderer will be autoHeight
        result?.forEach?.(c => {
            c.autoHeight = Boolean(!c.isAgendaColumn || (c.renderer || this.eventRenderer));
        });
        return result;
    }

    // Override these because CalendarNavigation focuses and navigates *events*, not grid cells.
    onFocusGesture() {}
    onGridElementFocus() {}
    onGridBodyFocusIn() {}
    focusCell() {}
    setHoveredRow() {}
    onElementKeyDown() {}
    onElementMouseDown() {}

    editAutoCreatedEvent(event, eventRecord) {
        // Uniquely, AgendaView has to regenerate its Grid store on event add so that
        // there is an event element to edit by.
        this.populateStoreSoon.now();

        super.editAutoCreatedEvent(event, eventRecord);
    }

    handleEvent(event) {
        const { type } = event;

        super.handleEvent(event);

        // Implement eventMouseover/eventMouseout.
        // All else is handled at the EventList level.
        if (isMouseOverOut[event.type]) {
            this.onEventMouseOverOut(event);
        }
        else if (isMouseInteraction[type]) {
            this.onCalendarPointerInteraction(event);
        }
    }

    getCellDataFromEvent(domEvent) {
        if (domEvent.target.closest('.b-grid-cell')) {
            const result = super.getCellDataFromEvent(domEvent);

            result && (result.record = this.getEventRecord(domEvent.target));

            return result;
        }
    }

    updateOffsetStartsBeforeEvents(offsetStartsBeforeEvents) {
        // Must case to Boolean because undefined defaults to true
        this.element.classList.toggle('b-offset-continues-past', Boolean(offsetStartsBeforeEvents));
    }

    updateEventRowSpacing(eventRowSpacing) {
        this.contentElement.style.setProperty('--event-row-spacing', DomHelper.setLength(eventRowSpacing));
    }

    updateSuppressLongEvents() {
        this.fillFromMaster();
    }

    onCalendarStoreChange({ action, oldCount, records, removed, added }) {
        const me = this;

        if (me.isPainted) {
            // A filter which resulted in no filtering. Ignore it.
            if (action === 'filter' && !removed?.length && !added?.length) {
                return;
            }

            // Draw on project refresh instead of on dataset
            if (action === 'dataset') {
                return;
            }

            // Single record remove just updates the generated records that the event covers
            if (action === 'remove' && records.length === 1 && records[0].isEventModel) {
                const
                    { store }    = me,
                    eventRecord  = records[0],
                    date         = DH.clearTime(eventRecord.startDate),
                    endDate      = DH.clearTime(eventRecord.endDate);

                do {
                    const
                        key          = DH.makeKey(date),
                        cellData     = me.cellMap.get(key);

                    if (cellData) {
                        ArrayHelper.remove(cellData.events, eventRecord);

                        // Update the row for this date
                        if (cellData.events.length) {
                            me.onStoreUpdateRecord({
                                source  : store,
                                record  : me.store.getById(key),
                                changes : {}
                            });
                        }
                        // No events on this date
                        else {
                            me.cellMap.delete(key);
                            delete me.dateIndex[key];
                            store.remove(key, true);
                        }
                    }

                    date.setDate(date.getDate() + 1);
                } while (date < endDate);

                return;
            }
        }

        me.populateStoreSoon();
    }

    get cellMap() {
        // If the cellMap has not been populated, create it.
        return this._cellMap?.populated ? this._cellMap : this.createCellMap({
            rawEvents     : true,
            skipPropagate : true
        });
    }

    populateStore() {
        this._cellMap?.clear();

        const
            me = this,
            {
                store,
                eventStore,
                rowManager
            }             = me,
            { rowHeight } = rowManager,
            rowCount      = rowManager.rows?.length,
            eventHeight   = isNaN(me.eventHeight) ? 25 : me.eventHeight;

        me.eventCount = 0;

        if (!me.date) {
            // Avoid recursion into populateStore
            me.isConfiguring = true;
            me.date = eventStore.map(r => r.startDate).sort((lhs, rhs) => lhs.valueOf() - rhs.valueOf())[0];
            me.isConfiguring = false;
        }

        const
            { cellMap }    = me,
            cellMapEntries = [...cellMap.values()];

        me.dateIndex = {};

        for (let i = 0, { length } = cellMapEntries; i < length; i++) {
            const
                cellData         = cellMapEntries[i],
                { events, date } = cellData;

            // Count unique events
            for (let j = 0, { length } = events; j < length; j++) {
                const event = events[j];

                if (!me.isAllDayEvent(event) || !i || DH.clearTime(event.startDate).valueOf() === date.valueOf()) {
                    me.eventCount++;
                }
            }

            // build date index
            me.dateIndex[cellData.id] = cellMapEntries[i] = store.createRecord(cellData);
        }
        const avgEventsPerCell = me.eventCount ? cellMapEntries.map(e => e.events.length).reduce((a, b) => a + b, 0) / cellMapEntries.length : 0;

        store.suspendEvents();
        store.loadData(cellMapEntries);
        store.resumeEvents();

        // Give RowManager a clue so that it can calculate an appropriate rowCount.
        // If the rows are tall, we do not need many to cover the viewport.
        rowManager._rowHeight = 20;
        // RowManager#set rowHeight does not tolerate no rows.
        if (store.count) {
            rowManager.rowHeight = Math.max(avgEventsPerCell * (eventHeight + me.eventSpacing), 70);
        }

        // Setting the rowHeight does a refresh if there are existing rows and the height actually changed.
        // Otherwise, we explicitly refresh now.
        if (!rowCount || !store.count || rowManager.rowHeight === rowHeight) {
            rowManager.calculateRowCount();
            rowManager.estimateTotalHeight(true);
        }

        me.refreshCount = (me.refreshCount || 0) + 1;

        /**
         * Fires when this AgendaView refreshes.
         * @param {Calendar.widget.AgendaView} source The triggering instance.
         * @event refresh
         */
        me.trigger('refresh');

        // The owning Calendar's UI may need to sync with the new state
        me.calendar?.syncUIWithActiveView(me);

        me.columns.forEach(c => c.constructor.exposeProperties?.());

        // Evaluate this late so that it doesn't change the order of date config evaluation
        // Ensure that the menu stays aligned if scrollbar causes button movement.
        me.settings?._menu?.realign();
    }

    get count() {
        return this.eventCount;
    }

    collectEvents(options) {
        // Only the first cell, or !hideEventOverflow needs overflows flowing into it.
        options.getDateIndex = date => date > this.startDate && this.hideEventOverflow ? 'startDate' : 'date';

        return this.eventStore.getEvents(options);
    }

    changeStore(store) {
        store = super.changeStore(store);

        if (store) {
            this.nonWorkingDaysFilter = store.addFilter({
                id       : `${this.id}-nonworkingday-filter`,
                filterBy : rec => !rec.isNonWorking,
                disabled : !this.hideNonWorkingDays
            }, true);

            this.detachListeners('agendaStoreFilter');
            store.on({
                name    : 'agendaStoreFilter',
                filter  : 'onAgendaStoreFilter',
                thisObj : this
            });
        }

        return store;
    }

    get modelClass() {
        return GridRowModel;
    }

    onAgendaStoreFilter() {
        const me = this;

        // Count unique events
        me.eventCount = me.store.reduce((result, rec, i) => {
            const { events, date } = rec;

            for (let j = 0, { length } = events; j < length; j++) {
                const event = events[j];

                if (!me.isAllDayEvent(event) || !i || DH.clearTime(event.startDate).valueOf() === date.valueOf()) {
                    result++;
                }
            }
            return result;
        }, 0);
    }

    updateHideEventOverflow() {
        this.populateStore();
    }

    // We must implement the CalendarMixin interface.
    // All views must expose a doRefresh method.
    // Override from EventList. We need to repopulate our store to create day cells.
    doRefresh() {
        this.populateStore();
    }

    createCellData(date) {
        return Object.assign(this.cellMonth.getCellData(date, this.month), {
            id     : DH.makeKey(date),
            events : []
        });
    }

    set cellRenderer(cellRenderer) {
        this._cellRenderer = cellRenderer;
    }

    changeSettings(settings) {
        return settings && super.changeSettings({
            menu : {
                align : {
                    align : 't100-b100'
                },
                ...this.listRangeMenu
            }
        });
    }
}

AgendaView.initClass();
