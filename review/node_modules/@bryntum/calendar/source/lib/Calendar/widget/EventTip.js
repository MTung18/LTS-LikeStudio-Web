import Tooltip from '../../Core/widget/Tooltip.js';
import ClockTemplate from '../../Scheduler/tooltip/ClockTemplate.js';
import DH from '../../Core/helper/DateHelper.js';
import FunctionHelper from '../../Core/helper/FunctionHelper.js';
import RecurrenceLegend from '../../Scheduler/data/util/recurrence/RecurrenceLegend.js';
import DomHelper from '../../Core/helper/DomHelper.js';
import StringHelper from '../../Core/helper/StringHelper.js';

/**
 * @module Calendar/widget/EventTip
 */

const hasEventStore = w => w.eventStore;

/**
 * Displays a tooltip containing extra info and options on either event click or event hover.
 *
 * See the {@link Calendar.feature.EventTooltip} feature for more information and an example of
 * customizing the displayed event tooltip.
 *
 * The EventTip is provided with two standard {@link #config-tools}:
 *
 * * `edit` - A tool which is linked to the {@link Calendar.feature.EventEdit EventEdit} feature
 * to initiate editing when clicked.
 * * `delete` - A tool which removes the current event record
 * function of the active view to enable event deletion.
 *
 * New tools may be added, or properties of existing tools may be changed by configuring the
 * {@link Calendar.feature.EventTooltip} feature:
 *
 * ```javascript
 *     features : {
 *         eventTooltip : {
 *             tools : {
 *                 // Just override handler of existing tool - all else is OK
 *                 edit : {
 *                     handler : () => console.log(`Handle editing ${this.eventRecord.name} our way`);
 *                 },
 *                 // Add a new tool for our own operation
 *                 newTool : {
 *                     cls     : 'b-icon-add',
 *                     tooltip : 'Test',
 *                     handler() {
 *                         console.log(`Test ${this.eventRecord.name}`);
 *                     }
 *                 }
 *             }
 *         }
 *     }
 * ```
 *
 * @extends Core/widget/Tooltip
 * @classType eventTooltip
 */
export default class EventTip extends Tooltip {

    //region Config

    static get $name() {
        return 'EventTip';
    }

    static get type() {
        return 'eventtip';
    }

    static get configurable() {
        return {
            align : {
                monitorResize : true // Needed because DayView events change size
            },

            dateFormat : 'll',

            /**
             * The event which the tooltip feature has been shown for.
             * @member {Scheduler.model.EventModel} eventRecord
             * @readonly
             */
            /**
             * The event record for this tip to display
             * @config {Scheduler.model.EventModel} eventRecord
             */
            eventRecord : {
                $config : 'nullify',  // ensure we remove our afterChange hook

                value : null
            },

            recurrenceHint : '',

            // Do not remove. Assertion strings for Localization sanity check.
            // 'L{timeFormat}'

            /**
             * A {@link Core.helper.DateHelper} format string used to format the time displayed in this tooltip.
             *
             * @config {String}
             * @default
             */
            timeFormat : 'LST',

            // Allow it to fall back from its initial alignment axis to the cross axis.
            // So if aligned l-r or r-l and shown by a long multiday event, it allows
            // itself to be fall back to being aligned t-b
            axisLock : 'flexible',

            closable     : null,
            forSelector  : '.b-cal-event-wrap',
            maxWidth     : '30em',
            minWidth     : '14em',
            scrollAction : 'realign',

            cls : {
                'b-sch-event-tooltip' : 1
            },

            tools : {
                edit : {
                    cls     : 'b-icon-edit',
                    handler : 'up.onEditClick',
                    tooltip : 'L{EventEdit.Edit event}',
                    weight  : 100
                },
                delete : {
                    cls     : 'b-icon-trash',
                    handler : 'up.onDeleteClick',
                    tooltip : 'L{SchedulerBase.Delete event}',
                    weight  : 0
                },
                maximize : null
            },

            titleRenderer : eventRecord => StringHelper.encodeHtml(eventRecord.name),

            /**
             * By default, the end date of an all day event is displayed in the tooltip UI as
             * the last calendar date on which the event falls. For most end users, this is the
             * expected value.
             *
             * Technically, the {@link Scheduler.model.EventModel#field-endDate} is a timestamp
             * which represents the exact point in time at which an event ends. To use this instead,
             * configure `extendAllDayEndDay` as `true`.
             *
             * To be clear, this would mean that an {@link Scheduler.model.EventModel#field-allDay}
             * event starting and ending on the 7th of February 2020, would show the end date in the
             * tooltip as 8th of February 2020.
             * @config {Boolean}
             * @default false
             */
            extendAllDayEndDay : null,

            activeClient : null
        };
    }

    static get delayable() {
        return {
            refreshContent : 20
        };
    }

    clockTemplate = new ClockTemplate({})

    //endregion

    get owner() {
        return Tooltip.fromElement(this.activeTarget) || this.ownerFeature.client;
    }

    onEditClick() {
        this.trigger('edit');
    }

    onDeleteClick() {
        this.trigger('delete');
    }

    getHtml(data) {
        const
            me              = this,
            { eventRecord } = me;

        if (eventRecord) {
            data.eventRecord = eventRecord;

            me.title = me.titleRenderer ? me.callback(me.titleRenderer, me, [eventRecord]) : '';

            return me.callback(me.renderer || me.internalRenderer, me, [{
                ...data,
                eventRecord
            }]);
        }
    }

    internalRenderer({ eventRecord }) {
        const
            {
                clockTemplate,
                dateFormat,
                recurrenceHint,
                timeFormat
            }                = this,
            {
                allDay,
                endDate,
                startDate,
                recurrence
            }                = eventRecord,

            // For allDay events round eg 2020-10-18T12:00 up to 2020-10-19T00:00:00.000
            lastDay          = allDay ? (this.extendAllDayEndDay ? DH.ceil(endDate, '1 day') : DH.add(endDate, -1, 'day')) : endDate,
            startMidnight    = DH.clearTime(startDate),
            lastMidnight     = DH.clearTime(lastDay),
            multiDay         = startMidnight < lastMidnight,
            hasTime          = !allDay && startMidnight < startDate || lastMidnight < lastDay,
            format           = hasTime ? (multiDay ? `${dateFormat} ${timeFormat}` : timeFormat) : dateFormat,
            recurrenceLegend = recurrence ? RecurrenceLegend.getLegend(recurrence) : recurrenceHint,
            duration         = DH.formatDelta(DH.diff(startDate, endDate), allDay ? { precision : 'd' } : null),
            onlyStartDate    = eventRecord.isMilestone || (allDay && !multiDay);

        clockTemplate.mode = multiDay ? 'day' : 'hour';

        return (
            clockTemplate.template({
                date : startDate,
                text : DH.format(startDate, format),
                cls  : 'b-sch-tooltip-startdate'
            }) +
            (onlyStartDate ? '' : clockTemplate.template({
                date : lastDay,
                text : DH.format(lastDay, format),
                cls  : 'b-sch-tooltip-enddate'
            })) +
            (eventRecord.isMilestone ? '' : `<div class="b-cal-tooltip-duration b-icon b-icon-duration">${duration}</div>`) +
            (recurrenceLegend ? `<div class="b-cal-tooltip-recurrence b-icon b-icon-recurring">${recurrenceLegend}</div>` : '')
        );
    }

    showByEvent(event, element = event.target) {
        const me = this;

        me.activeTarget = element;
        me.pointerEvent = event;

        me.updateContent();

        if (event.type === 'contextmenu') {
            return me.showBy({
                position : { x : event.clientX, y : event.clientY },
                anchor   : false
            });
        }

        return me.showBy(element);
    }

    afterShowByTarget() {
        const { delete : deleteTool } = this.tools;

        // Capture the active client only when we are visible.
        this.activeClient = Tooltip.fromElement(this.activeTarget)?.closest(hasEventStore);

        super.afterShowByTarget();

        // The delete tool is disabled if the Calendar is readOnly
        deleteTool && (deleteTool.disabled = this.ownerFeature.client.readOnly);
    }

    afterHide() {
        super.afterHide(...arguments);
        this.activeClient = null;
    }

    updateActiveTarget(element, was) {
        super.updateActiveTarget(...arguments);
        was?.classList.remove('b-cal-event-reveal');

        // The activating event element is lifted to the top of the z-index stack while
        // it is the target of the tooltip.
        if (element?.classList.contains('b-cal-in-cluster')) {
            element.classList.add('b-cal-event-reveal');
        }
    }

    refreshContent() {
        // this method is just a buffered wrapper of updateContent
        this.updateContent();
    }

    updateEventRecord(eventRecord) {
        const me = this;

        me._changeHook?.();
        me._changeHook = eventRecord && FunctionHelper.after(eventRecord, 'afterChange', me.refreshContent, me);

        if (eventRecord) {
            if (me.tools.delete) {
                me.tools.delete.hidden = eventRecord.readOnly;
            }

            if (me.tools.edit) {
                me.tools.edit.hidden = eventRecord.readOnly;
            }

            me.updateContent();
        }
    }

    updateContent() {
        const
            { clockTemplate, element, eventRecord } = this,
            result                                 = super.updateContent(),
            startElement                           = element.querySelector('.b-sch-tooltip-startdate'),
            endElement                             = element.querySelector('.b-sch-tooltip-enddate'),
            { edit, delete : del }                 = this.tools,
            { client }                             = this.ownerFeature,
            { eventEdit }                          = client.features,
            readOnly                               = client.readOnly || eventRecord.readOnly;

        startElement && clockTemplate.updateDateIndicator(startElement, eventRecord.startDate);
        endElement && clockTemplate.updateDateIndicator(endElement, eventRecord.endDate);

        // Hide the edit tool if the Calendar or event is readOnly or there is no editFeature or it's disabled
        edit && (edit.hidden = readOnly || !eventEdit?.enabled);

        // Hide delete tool if the Calendar or event is readOnly
        del && (del.hidden = readOnly);

        return result;
    }

    updateActiveClient(activeClient) {
        this.detachListeners('clientOverflowChange');

        // We may have to hide when the active client changes its possible overflow threshold
        if (activeClient) {
            activeClient.ion({
                name                : 'clientOverflowChange',
                eventsPerCellChange : 'onClientOverflowChange',
                thisObj             : this
            });
        }
    }

    onClientOverflowChange() {
        // If that caused the target to no longer be visible, we must hide.
        // For example aligned to an event which is now in overflow.
        // Or aligned to an event in the overflow popup which has now hidden.
        if (!DomHelper.isVisible(this.lastAlignSpec.target)) {
            this.hide();
        }
    }

    onDocumentMouseDown({ event }) {
        // Ignore mousedown on active element if we show on a click.
        if (!event.button && this.ownerFeature.showOn === 'click' && this.activeTarget.contains(event.target)) {
            return;
        }
        return super.onDocumentMouseDown(...arguments);
    }
}

// Register this feature type with its Factory
EventTip.initClass();
