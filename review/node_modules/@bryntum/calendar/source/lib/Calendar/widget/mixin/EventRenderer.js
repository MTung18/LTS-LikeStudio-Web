import Base from '../../../Core/Base.js';
import ArrayHelper from '../../../Core/helper/ArrayHelper.js';
import DomClassList from '../../../Core/helper/util/DomClassList.js';
import DomHelper from '../../../Core/helper/DomHelper.js';
import StringHelper from '../../../Core/helper/StringHelper.js';
import DH from '../../../Core/helper/DateHelper.js';

/**
 * @module Calendar/widget/mixin/EventRenderer
 */

const emptyString = new String('');  // eslint-disable-line no-new-wrappers

/**
 * Mixin that can be used to generate DomConfig blocks for events.
 *
 * @mixin
 */
export default Target => class EventRenderer extends (Target || Base) {
    static $name = 'EventRenderer';

    static configurable = {
        /**
         * An empty function by default, but provided so that you can override it.
         *
         * This function is called each time an event is rendered to allow developers to mutate
         * the cell metadata, or the CSS classes to be applied to the event element.
         *
         * It's called with the event record, and a eventData object which allows you to mutate event metadata
         * such as `cls`, `style`.
         *
         * The `cls` property is an object whose property names will be added to the event element if the property
         * value is truthy.
         *
         * The `style` property is an object containing style properties for the event element.
         *
         * A non-null return value from the renderer is used as the event body content. A nullish
         * return value causes the default renderer to be used which just uses the event name.
         *
         * If a string is returned, it is used as the HTML content of the event body element.
         *
         * If an object is returned, it is used as a {@link Core.helper.DomHelper#typedef-DomConfig} object to
         * create complex content in the event body element.
         *
         * ```javascript
         *  eventRenderer({ eventRecord, renderData }) {
         *      if (eventRecord.name === 'Doctors appointment') {
         *          eventData.style.fontWeight = 'bold';
         *          eventData.cls['custom-cls'] = 1;
         *
         *          return 'Special doctors appointment';
         *      }
         *  }
         * ```
         * IMPORTANT: When returning content, be sure to consider how that content should be encoded to avoid XSS
         * (Cross-Site Scripting) attacks. This is especially important when including user-controlled data such as
         * the event's `name`. The function {@link Core.helper.StringHelper#function-encodeHtml-static} as well as
         * {@link Core.helper.StringHelper#function-xss-static} can be helpful in these cases.
         *
         * For example:
         * ```javascript
         *  eventRenderer({ eventRecord }) {
         *      return StringHelper.xss`Event: ${eventRecord.name}`;
         *  }
         * ```
         * @config {Function} eventRenderer
         * @param {Object} detail An object that contains data about the event being rendered.
         * @param {Scheduler.model.EventModel} detail.eventRecord The event record
         * @param {Scheduler.model.ResourceModel} detail.resourceRecord The event record
         * @param {Object} detail.renderData A data object containing properties that will be used to create the event element.
         * @param {Object} detail.renderData.style The style property is an object containing style properties for
         * the event element.
         * @param {Object} detail.renderData.cls The cls property is an object whose property names will be added to
         * the event element if the property value is truthy.
         * @param {Object} detail.renderData.iconStyle The iconStyle property is an object containing style properties for
         * the icon element if an icon element is to be used.
         * @param {Object} detail.renderData.iconCls The iconCls property is an object whose property names will be added to
         * the icon element. Initially set from the event record's {@link Scheduler.model.EventModel#field-iconCls}.
         * Can be mutated by the renderer. If null, or no properties are set, no icon will be rendered.
         * @param {String} detail.renderData.eventColor Color to be applied to the event
         * @param {Object} detail.renderData.dataset An object which produces the `dataset` of the resulting event bar.
         * @param {Boolean} detail.renderData.solidBar This is valid for views which create event bars
         * such as the MonthView, the CalendarRow (all day events in a DayView), and OverflowPopups.
         *
         * This is set to `true` by default for all day and interday events so that these appear as a
         * solid block of background colour.
         *
         * An eventRenderer may mutate this flag to change in what manner the event bar is coloured - as
         * a solid bar of colour, or using the foreground colour (text and icons).
         */
        eventRenderer : null
    };

    /**
     * This is the standard way to create a {@link Core.helper.DomHelper#typedef-DomConfig}
     * element definition object for creating event bars in all view types.
     *
     * This may be used by application code which needs to create DOM structure for event bars, such
     * as in custom cell renderers in an {@link Calendar.widget.AgendaView}.
     *
     * @param {Object} renderData Context for the event bar config creation.
     * @param {Scheduler.model.EventModel} renderData.eventRecord The event record to create a {@link DomConfig} block for.
     * @param {Boolean} renderData.minimal If this is set, no inner content is rendered, only
     * the wrap and body element. This is to enable rendering placeholders such as bullets
     * to represent the presence of events.
     * @param {Date} renderData.date The date to create th DOM config for.
     * @param {Date} [renderData.eventEndDate] An optional override to the event's ending date.
     * @param {Function} [eventRenderer] Optionally a function which created content HTML for the
     * event body. Defaults to any {@link #config-eventRenderer} configured into this view.
     * @returns {DomConfig} A {@link Core.helper.DomHelper#typedef-DomConfig} element definition object
     */
    createEventDomConfig(renderData, eventRenderer = this.eventRenderer) {
        const
            me = this,
            {
                eventHeight,
                intradayCls,
                alldayCls,
                solidBarCls,
                pastEventCls,
                showTime,
                timeFormat,
                rtl
            }               = me,
            calendar        = me.up('calendar'),
            {
                eventRecord,
                minimal
            }               = renderData,
            eventEndDate    = renderData.eventEndDate || eventRecord.endingDate,
            resourceRecord  = eventRecord.isOccurrence ? eventRecord.recurringEvent.resource : eventRecord.resource,
            isRecurring     = eventRecord.isRecurring || eventRecord.isOccurrence,
            isAllDay        = ('isAllDay' in renderData) ? renderData.isAllDay : me.isAllDayEvent?.(eventRecord),
            eventInnerStyle = {
                height : eventHeight !== 'auto' ? DomHelper.setLength(eventHeight) : null
            },
            eventSelectedCls = calendar?.eventSelectedCls,
            dataset          = renderData.dataset = {
                eventId : eventRecord.id
            };

        // Allow subclasses to create body content differently.
        // DayView will create different content layout.
        let
            bodyContent     = me.internalBodyContentRenderer(eventRecord),
            complexContent  = typeof bodyContent !== 'string',
            bodyContentType = complexContent ? 'children' : 'html',
            color           = eventRecord.color || eventRecord.eventColor || resourceRecord?.eventColor || emptyString;

        // Make DomClassList copies for renderers to mutate.
        // We add our essential classes in after the renderer has run
        // then use these in the DomConfig object
        renderData.cls = eventRecord.cls.clone();
        renderData.solidBar = isAllDay || minimal;
        renderData.iconStyle = me.iconTarget === 'header' && me.showTime && !DomHelper.isNamedColor(color) ? { color } : {};
        renderData.iconCls = new DomClassList(eventRecord.iconCls); // Not a DomClassList, so not cloneable
        renderData.style = Object.assign(DomHelper.parseStyle(resourceRecord?.eventStyle), DomHelper.parseStyle(eventRecord.style));
        renderData.eventColor = color;
        renderData.eventHeight = eventHeight;
        renderData.cls[me.shortEventCls] = eventRecord.durationMS <= me.shortEventDuration;

        if (resourceRecord?.cls) {
            renderData.cls.add(resourceRecord.cls);
        }

        if (eventRenderer && !minimal) {
            // Renderer may set renderedEvent style and cls
            const rendererValue = me.callback(eventRenderer, me, [{
                eventRecord,
                resourceRecord,
                renderData
            }]);

            // Allow renderer to change the event height
            if (renderData.eventHeight !== eventHeight) {
                eventInnerStyle.height = DomHelper.setLength(renderData.eventHeight);
            }

            if (rendererValue != null) {
                // We don't know what the renderer returned. A string value
                // may yield multiple elements so switch to complex desc content mode
                // which makes the .b-cal-event-desc flexbox to lay content out.
                complexContent = true;

                bodyContent = rendererValue;

                // If the renderer returns a DomSync object, use it as the child(ren).
                if (typeof bodyContent !== 'string') {
                    bodyContent = ArrayHelper.asArray(bodyContent);
                    bodyContentType = 'children';
                }
            }

            // If the renderer has replaced the DomClassList with a string, promote back to a DomClassList
            if (typeof renderData.cls === 'string') {
                renderData.cls = new DomClassList(renderData.cls);
            }

            // Same goes for iconCls
            if (typeof renderData.iconCls === 'string') {
                renderData.iconCls = new DomClassList(renderData.iconCls);
            }

            // If the renderer set it to be a string, reinstate it as an object so we can add our essential styles
            if (typeof renderData.style === 'string') {
                renderData.style = DomHelper.parseStyle(renderData.style);
            }
        }
        bodyContent = [{
            className : {
                'b-cal-event-desc'         : 1,
                'b-cal-event-desc-complex' : complexContent
            },
            [bodyContentType] : bodyContent
        }];

        // Add essential classes for eventWrap *after* the renderer has run
        Object.assign(renderData.cls, {
            'b-cal-event-wrap' : 1,
            'b-iscreating'     : eventRecord.isCreating,
            'b-readonly'       : eventRecord.readOnly,
            'b-minimal'        : minimal,
            [alldayCls]        : alldayCls && isAllDay,
            [solidBarCls]      : solidBarCls && renderData.solidBar,
            [intradayCls]      : intradayCls  && !isAllDay,
            [pastEventCls]     : pastEventCls && eventEndDate < new Date(),
            [eventSelectedCls] : eventSelectedCls && calendar?.isEventSelected(eventRecord),
            'b-rtl'            : rtl
        });

        color = renderData.eventColor;

        if (color?.length) {
            // Non-CSS colors are take to be one of the predefined colors
            if (DomHelper.isNamedColor(color)) {
                renderData.cls[`b-cal-color-${color}`] = 1;
            }
            else {
                // Always set the color styles in case a previously set colour has been unset. In this case, we
                // set the value to an empty String object in order to avoid any falsy traps in called code.
                // The style value will always be set to ''
                if (renderData.solidBar) {
                    eventInnerStyle['background-color'] = color;
                }
                else {
                    eventInnerStyle[me.eventColourStyleProperty] = color;
                }
            }
        }

        // All day event *bars* don't have a header.
        // But DayView can now be configured to not show the allDayHeader which means allDay events
        // go into tye day schedule as normal intraday event elements which *do* have a header.
        if (showTime && !(isAllDay && this.showAllDayHeader)) {
            bodyContent.unshift({
                className : 'b-event-header',
                children  : [
                    {
                        className : 'b-event-time',
                        html      : DH.format(eventRecord.startDate, timeFormat)
                    }
                ]
            });
        }

        const
            // Presence of icon classes triggers inclusion of an icon
            hasIcon             = Boolean(renderData.iconCls?.length),
            useIconAsRecurrIcon = !hasIcon && isRecurring,
            showCircle          = me.showCircle && !hasIcon && !isRecurring,
            iconElement         = {
                tag       : 'i',
                className : Object.assign({
                    'b-cal-event-icon'      : !useIconAsRecurrIcon,
                    'b-cal-recurrence-icon' : useIconAsRecurrIcon,
                    'b-icon'                : 1,
                    'b-fw-icon'             : 1,
                    'b-icon-circle'         : showCircle,
                    'b-icon-recurring'      : useIconAsRecurrIcon
                }, renderData.iconCls),
                style : renderData.iconStyle
            },
            eventInnerContent   = [{
                className : 'b-cal-event-body',
                children  : bodyContent
            }],
            iconParent          =
                me.iconTarget === 'header' && me.showTime
                    ? (bodyContent[0].children.length > 0 ? bodyContent[0].children : bodyContent)
                    : eventInnerContent;

        // Only insert the icon DOM if we are showing any kind of icon, either
        // from an iconCls spec, or a recurrence icon, or showing a bullet via the showCircle config.
        if (hasIcon || useIconAsRecurrIcon || showCircle) {
            if (me.iconTarget === 'header' && me.showTime) {
                iconParent.push(iconElement);
            }
            else {
                iconParent.unshift(iconElement);
            }
        }

        // If the event had its own icon and is recurring, the recurrence icon is extra
        if (hasIcon && isRecurring) {
            iconParent.push({
                tag       : 'i',
                className : {
                    'b-cal-recurrence-icon' : 1,
                    'b-icon'                : 1,
                    'b-fw-icon'             : 1,
                    'b-icon-recurring'      : 1
                },
                style : renderData.iconStyle
            });
        }

        return {
            // Events are tabbable unless minimally rendered (dots)
            tabIndex : minimal ? null : 0,

            dataset,
            className : renderData.cls,
            style     : renderData.style,
            children  : [{
                className : 'b-cal-event',
                style     : eventInnerStyle,
                children  : minimal ? null : eventInnerContent
            }]
        };
    }

    internalBodyContentRenderer(eventRecord) {
        const
            eventNameHtml           = StringHelper.encodeHtmlBR(eventRecord.name),
            { showResourceAvatars } = this;

        // Only attempt to show avatars if there is an assignment Set.
        if (showResourceAvatars && eventRecord.assigned?.size) {
            const content = [{
                class    : 'b-cal-event-resource-avatars',
                children : eventRecord.resources.map(resource => this.getResourceAvatar(resource))
            }, {
                tag   : 'span',
                class : 'b-cal-event-name',
                html  : eventNameHtml
            }];
            return showResourceAvatars === 'last' ? content.reverse() : content;
        }
        else {
            return eventNameHtml;
        }
    }
};
