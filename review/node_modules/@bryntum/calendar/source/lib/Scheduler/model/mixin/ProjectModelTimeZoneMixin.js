import Model from '../../../Core/data/Model.js';
import TimeZoneHelper from '../../../Core/helper/TimeZoneHelper.js';

/**
 * @module Scheduler/model/mixin/ProjectModelTimeZoneMixin
 */

/**
 * Mixin that holds TimeZone functionality shared between projects in Scheduler, Scheduler Pro, Gantt and Calendar
 * @mixin
 */
export default Target => class ProjectModelTimeZoneMixin extends (Target || Model) {
    static $name = 'ProjectModelTimeZoneMixin';

    static configurable = {
        /**
         * Set to a IANA time zone (i.e. `Europe/Stockholm`) or a UTC offset in minutes (i.e. `-120`). This will
         * convert all events, tasks and time ranges to the specified time zone or offset. It will also affect the
         * displayed timeline's headers as well at the start and end date of it.
         *
         * There is currently no built-in time zone support in JavaScript which means that the converted dates
         * technically still are in the local system time zone, but adjusted to match the configured time zone.
         *
         * ### DST
         * If a IANA time zone is provided, there will be support for DST. But if local system time zone has DST that
         * will affect the time zone conversion at the exact hour when the local system time zone switches DST on and
         * off.
         *
         * *For example:*
         * 1. The local system time zone is `Europe/Stockholm` (which is UTC+1 or UTC+2 when DST).
         * 2. The date `2022-03-27T07:00:00Z` (which is UTC) is converted to `America/Chicago` (which is UTC-6 or UTC-5
         *    when DST).
         * 3. The converted JS date will be created from `2022-03-27T02:00:00` which is exactly the hour when
         *    `Europe/Stockholm` adds an DST hour. This has the effect that the converted date shows up incorrectly as
         *    `2022-03-27T03:00` instead.
         *
         * If a UTC offset is provided, there is no DST support at all.
         *
         * ### Editing
         * If creating new records or editing existing record dates, the dates will be interpreted as in the selected
         * time zone.
         *
         * ### Saving
         * When saving or syncing data, the dates will be restored to local system time and converted to JSON
         * ISO formatted.
         *
         * @prp {String|Number} [timeZone]
         * @category Advanced
         */
        timeZone : {
            // Don't ingest the config eagerly because it relies on project being present.
            // Lazy means it waits for ingestion until timeZone property is referenced.
            $config : 'lazy',
            value   : null
        }
    }

    afterConstruct() {
        super.afterConstruct(...arguments);

        this._storesWithDates =  [this.taskStore, this.timeRangeStore, this.resourceTimeRangeStore];
    }

    relayStoreChange({ source, action, records, replaced }) {
        const me = this;

        if (me.timeZone && me._storesWithDates.includes(source)) {
            // When loading or changing dataset, de data is treated as local dates and need to be converted
            if (action === 'dataset') {
                me.convertStoresToTimeZone([source]);
                me.ignoreRecordChanges = true;
                me.commitAsync();
            }
            // New added records are treated as in current timezone
            else if (['add', 'replace'].includes(action)) {
                if (!records?.length && replaced?.length) {
                    records = replaced;
                }
                if (records.length) {
                    records.forEach(record => record._inTimeZone = me.timeZone);
                }
            }
        }
    }

    convertStoresToTimeZone(stores) {
        const
            me            = this,
            { timeZone }  = me,
            stmAutoRecord = me.stm?.autoRecord;

        // Disable STM while updating timezone values
        if (stmAutoRecord) {
            me.stm.autoRecord = false;
        }

        for (const store of stores) {
            if (store) {

                store.forEach(r => {
                    r.$ignoreChange = true; // Used to ignore changes in NestedEvents feature
                    // Convert baselines if exists
                    if (r.baselines?.count) {
                        for (const bl of r.baselines) {
                            // The baseline records is not marked with a timezone when they are created
                            if (r._inTimeZone !== bl._inTimeZone) {
                                bl._inTimeZone = r._inTimeZone;
                            }
                            bl.convertToTimeZone(timeZone);
                        }
                    }

                    r.convertToTimeZone(timeZone);

                    delete r.$ignoreChange;
                });
            }
        }

        if (stmAutoRecord) {
            // Restore original value
            me.stmAutoRecord = stmAutoRecord;
        }
    }

    updateTimeZone(timeZone, oldTimeZone) {
        const
            me            = this,
            isConfiguring = me._isConfiguringTimeZone || me.isConfiguring;

        me.calendarManagerStore.forEach(calendar => calendar.bumpVersion());

        // Convert data to time zone
        me.convertStoresToTimeZone(me._storesWithDates);

        // Convert project startdate
        if (me.startDate) {
            const startDate = oldTimeZone ? TimeZoneHelper.fromTimeZone(me.startDate, oldTimeZone) : me.startDate;
            me.startDate = timeZone ? TimeZoneHelper.toTimeZone(startDate, timeZone) : startDate;
        }

        me.ignoreRecordChanges = true;
        me.commitAsync().then(() => {
            if (!me.isDestroyed) {
                me.trigger('timeZoneChange', {
                    timeZone,
                    oldTimeZone,
                    isConfiguring
                });
            }
            delete me._isConfiguringTimeZone;
        });
    }

};
