import TimeSpan from '../TimeSpan.js';
import TimeZoneHelper from '../../../Core/helper/TimeZoneHelper.js';
import ObjectHelper from '../../../Core/helper/ObjectHelper.js';

/**
 * @module Scheduler/model/mixin/TimeZoneDatesMixin
 */

const dateFieldsToConvert = {
    startDate      : 1,
    endDate        : 1,
    constraintDate : 1,
    deadlineDate   : 1
};

/**
 * This mixin class overrides default Model functionality to provide support for time zone converted dates
 * @private
 * @mixin
 * @mixinbase TimeSpan
 */
export default Target => class TimeZonedDatesMixin extends (Target || TimeSpan) {

    static $name = 'TimeZonedDatesMixin';

    setLocalDate(field, date) {
        this.set(field, this._inTimeZone ? TimeZoneHelper.toTimeZone(date, this._inTimeZone) : date, true);
        // Need to set data to fool engine that the dates havn't changed
        this.data[field] = this[field];
    }

    getLocalDate(field) {
        if (this._inTimeZone && this[field]) {
            return TimeZoneHelper.fromTimeZone(this[field], this._inTimeZone);
        }
        return this[field];
    }

    applyChangeset(rawChanges) {
        const { _inTimeZone } = this;

        // When a sync response arrives from backend, the data will need to be converted to time zone before applied.
        if (_inTimeZone != null) {
            for (const field in dateFieldsToConvert) {
                if (rawChanges[field]) {
                    this.setLocalDate(field, new Date(rawChanges[field]));
                    delete rawChanges[field];
                }
            }
        }
        return super.applyChangeset(...arguments);
    }

    getFieldPersistentValue(field) {
        if (this._inTimeZone) {
            const fieldName = field?.field ?? field?.name ?? field;

            // Used when saving/syncing. Returns local system dates
            if (dateFieldsToConvert[fieldName]) {
                return this.getLocalDate(fieldName);
            }
        }

        return super.getFieldPersistentValue(field);
    }

    // Converts current record into a timeZone
    convertToTimeZone(timeZone) {
        const
            me            = this,
            metaModified  = { ...me.meta.modified },
            convertFields = { ...dateFieldsToConvert };

        // Do not convert start and end dates on task unless manually scheduled
        if (me.isTask && !me.manuallyScheduled) {
            delete convertFields.startDate;
            delete convertFields.endDate;
        }

        // Collect values
        for (const field in convertFields) {
            // Only convert if field has value
            if (me[field] != null) {
                convertFields[field] = me[field];

                // If already converted, restore to local system time zone
                if (me._inTimeZone) {
                    convertFields[field] = me.getLocalDate(field);

                    // Restore value in meta modified as well
                    if (metaModified[field]) {
                        metaModified[field] = TimeZoneHelper.fromTimeZone(metaModified[field], me._inTimeZone);
                    }
                }
            }
            else {
                delete convertFields[field];
            }
        }

        // Change time zone
        me._inTimeZone = timeZone;

        // Set values
        for (const field in convertFields) {
            // Convert and set field date silently
            me.setLocalDate(field, convertFields[field], false);
            convertFields[field] = 1; // For clearing changes below

            // Convert value in meta modified as well
            if (me._inTimeZone && metaModified[field]) {
                metaModified[field] = TimeZoneHelper.toTimeZone(metaModified[field], me._inTimeZone);
            }
        }

        // Clear modification metadata
        me.clearChanges(true, true, convertFields);

        // If old modification metadata, restore them to record and store
        if (!ObjectHelper.isEmpty(metaModified)) {
            me.meta.modified = metaModified;
            me.stores.forEach(store => store.modified.add(me));
        }
    }
};
