{"version":3,"file":"Responsive.js","sources":["../../../../Core/lib/Core/mixin/Featureable.js","../../../../Core/lib/Core/mixin/Fencible.js","../../../../Core/lib/Core/widget/FilterField.js","../../../../Core/lib/Core/widget/mixin/Responsive.js"],"sourcesContent":["import Base from '../Base.js';\nimport DynamicObject from '../util/DynamicObject.js';\n\n/**\n * @module Core/mixin/Featureable\n */\n\n/**\n * This mixin provides management of a set of features that can be manipulated via the `features` config.\n *\n * The first step in using `Featureable` is to define the family of features using `Factoryable` to declare a base\n * class for features to extend:\n * ```\n *  class SuperWidgetFeature extends InstancePlugin.mixin(Factoryable) {\n *      static get factoryable() {\n *          //\n *      }\n *  }\n * ```\n *\n * The various feature classes extend the `SuperWidgetFeature` base class and call `initClass()` to register themselves:\n * ```\n *  export default class AmazingSuperWidgetFeature extends SuperWidgetFeature {\n *      static get type() {\n *          return 'amazing';\n *      }\n *  }\n *\n *  AmazingSuperWidgetFeature.initClass();\n * ```\n *\n * A class that supports these features via `Featureable` is declared like so:\n * ```\n *  class SuperWidget extends Widget.mixin(Featureable) {\n *      static get featureable() {\n *          return {\n *              factory : SuperWidgetFeature\n *          };\n *      }\n *\n *      static get configurable() {\n *          return {\n *              // Declare the default features. These can be disabled by setting them to a falsy value. Using\n *              // configurable(), the value defined by this class is merged with values defined by derived classes\n *              // and ultimately the instance.\n *              features : {\n *                  amazing : {\n *                      ...\n *                  }\n *              }\n *          };\n *      }\n *  }\n *```\n * @mixin\n * @internal\n */\nexport default Target => class Featureable extends (Target || Base) {\n    static get $name() {\n        return 'Featureable';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Specifies the features to create and associated with the instance. The keys of this object are the names\n             * of features. The values are config objects for those feature instances.\n             *\n             * After construction, this property can be used to access the feature instances and even reconfigure them.\n             *\n             * For example:\n             * ```\n             *  instance.features.amazing = {\n             *      // reconfigure this feature\n             *  }\n             * ```\n             * This can also be done in bulk:\n             * ```\n             *  instance.features = {\n             *      amazing : {\n             *          // reconfigure this feature\n             *      },\n             *      // reconfigure other features\n             *  }\n             * ```\n             * @config {Object}\n             */\n            features : null\n        };\n    }\n\n    static get declarable() {\n        return [\n            /**\n             * This property getter returns options that control feature management for the derived class. This\n             * property getter must be defined by the class that mixes in `Featureable` in order to initialize the\n             * class properly.\n             * ```\n             *  class SuperWidget extends Widget.mixin(Featureable) {\n             *      static get featureable() {\n             *          return {\n             *              factory : SuperWidgetFeature\n             *          };\n             *      }\n             *      ...\n             *  }\n             * ```\n             * @static\n             * @member {Object} featureable\n             * @property {Core.mixin.Factoryable} featureable.factory The factoryable class (not one of its instances)\n             * that will be used to create feature instances.\n             * @property {String} [featureable.ownerName='client'] The config or property to assign on each feature as\n             * a reference to its creator, the `Featureable` instance.\n             * @internal\n             */\n            'featureable'\n        ];\n    }\n\n    static setupFeatureable(cls) {\n        const featureable = {\n            ownerName : 'client',\n            ...cls.featureable\n        };\n\n        featureable.factory.initClass();\n\n        // Replace the class/static getter with a new one that returns the complete featureable object:\n        Reflect.defineProperty(cls, 'featureable', {\n            get() {\n                return featureable;\n            }\n        });\n    }\n\n    doDestroy() {\n        const features = this.features;\n\n        super.doDestroy();\n\n        for (const name in features) {\n            const feature = features[name];\n            // Feature might be false or destroyed already by Grid (EventList mixes in CalendarMixin which has this mixin)\n            feature.destroy?.();\n        }\n    }\n\n    /**\n     * Returns `true` if the specified feature is active for this instance and `false` otherwise.\n     * @param {String} name The feature name\n     * @returns {Boolean}\n     */\n    hasFeature(name) {\n        return Boolean(this.features?.[name]);\n    }\n\n    changeFeatures(features, was) {\n        if (this.isDestroying) {\n            return;\n        }\n\n        const\n            me = this,\n            { featureable } = me.constructor,\n            manager = me.$features || (me.$features = new DynamicObject({\n                configName : 'features',\n                factory    : featureable.factory,\n                owner      : me,\n                ownerName  : featureable.ownerName\n            }));\n\n        manager.update(features);\n\n        if (!was) {\n            // Only return the target once. Further calls are processed above so we need to return undefined to ensure\n            // onConfigChange is called. By returning the same target on 2nd+ call, it passes the === test and won't\n            // trigger onConfigChange.\n            return manager.target;\n        }\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n\n    getCurrentConfig(options) {\n        const\n            result       = super.getCurrentConfig(options),\n            { features } = result;\n\n        if (features) {\n            // Replace empty configs with `true`\n            for (const featureName in features) {\n                if (Object.keys(features[featureName]).length === 0) {\n                    features[featureName] = true;\n                }\n            }\n        }\n\n        return result;\n    }\n};\n","import ObjectHelper from '../helper/ObjectHelper.js';\nimport StringHelper from '../helper/StringHelper.js';\nimport Base from '../Base.js';\n\n/**\n * @module Core/mixin/Fencible\n */\n\nconst\n    { defineProperty } = Object,\n    { hasOwn }         = ObjectHelper,\n    fencibleSymbol     = Symbol('fencible'),\n    NONE               = [],\n    distinct           = array => Array.from(new Set(array)),\n    parseNames         = names => names ? distinct(StringHelper.split(names)) : NONE,\n\n    fenceMethod = (target, name, options) => {\n        if (options === true) {\n            options = name;\n        }\n\n        if (!ObjectHelper.isObject(options)) {\n            options = {\n                all : options\n            };\n        }\n\n        let any = parseNames(options.any);\n\n        const\n            all      = parseNames(options.all),\n            lock     = options.lock ? parseNames(options.lock) : distinct(all.concat(any)),\n            implName = name + 'Impl',\n            fence    = function(...params) {  // cannot use => since we need to receive \"this\" from the caller\n                const\n                    me = this,\n                    // For static methods we have to be careful to use hasOwn to check the \"point of entry\" (i.e., the\n                    // class reference used to call the method) since \".\" will climb the constructor's __proto__ chain\n                    // to find properties from a super class. This does not happen to instances since we never put our\n                    // fences object on the prototype chain.\n                    fences = hasOwn(me, fencibleSymbol) ? me[fencibleSymbol] : (me[fencibleSymbol] = {}),\n                    isFree = key => !fences[key];\n\n                if (all.every(isFree) && (!any || any.some(isFree))) {\n                    try {\n                        lock.forEach(key => (fences[key] = (fences[key] || 0) + 1));\n\n                        return me[implName](...params);\n                    }\n                    finally {\n                        lock.forEach(key => --fences[key]);\n                    }\n                }\n            };\n\n        any = any.length ? any : null;  // [].some(f) is always false, but [].every(f) is always true\n\n        !target[implName] && defineProperty(target, implName, {\n            configurable : true,\n            value        : target[name]\n        });\n\n        defineProperty(target, name, {\n            configurable : true,\n            value        : fence\n        });\n    };\n\n/**\n * A description of how to protect a method from reentry.\n *\n * A value of `true` is transformed using the key as the `all` value. For example, this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : true\n *      };\n * ```\n *\n * Is equivalent to this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : {\n *              all : ['foo']\n *          }\n *      };\n * ```\n *\n * Strings are split on spaces to produce the `all` array. For example, this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : 'foo bar'\n *      };\n * ```\n *\n * Is equivalent to this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : {\n *              all : ['foo', 'bar']\n *          }\n *      };\n * ```\n * This indicates that `foo()` cannot be reentered if `foo()` or `bar()` are already executing. On entry to `foo()`,\n * both `foo()` and `bar()` will be fenced (prevented from entering).\n *\n * @typedef {Object} MethodFence\n * @property {String|String[]} [all] One or more keys that must all be currently unlocked to allow entry to the fenced\n * method. String values are converted to an array by splitting on spaces.\n * @property {String|String[]} [any] One or more keys of which at least one must be currently unlocked to allow entry\n * to the fenced method. String values are converted to an array by splitting on spaces.\n * @property {String|String[]} [lock] One or more keys that will be locked on entry to the fenced method and released\n * on exit. String values are converted to an array by splitting on spaces. By default, this array includes all keys\n * in `all` and `any`.\n */\n\n/**\n * This mixin is used to apply reentrancy barriers to methods. For details, see\n * {@link Core.mixin.Fencible#property-fenced-static}.\n * @mixin\n * @internal\n */\nexport default Target => class Fencible extends (Target || Base) {\n    static $name = 'Fencible';\n\n    static declarable = [\n        /**\n         * This class property returns an object that specifies methods to be wrapped to prevent reentrancy.\n         *\n         * It is used like so:\n         * ```javascript\n         *  class Foo extends Base.mixin(Fencible) {\n         *      static fenced = {\n         *          reentrantMethod : true\n         *      };\n         *\n         *      reentrantMethod() {\n         *          // things() may cause reentrantMethod() to be called...\n         *          // but we won't be allowed to reenter this method since we are already inside it\n         *          this.things();\n         *      }\n         *  }\n         * ```\n         *\n         * This can also be used to protect mutually reentrant method groups:\n         *\n         * ```javascript\n         *  class Foo extends Base.mixin(Fencible) {\n         *      static fenced = {\n         *          foo : 'foobar'\n         *          bar : 'foobar'\n         *      };\n         *\n         *      foo() {\n         *          console.log('foo');\n         *          this.bar();\n         *      }\n         *\n         *      bar() {\n         *          console.log('bar');\n         *          this.foo();\n         *      }\n         *  }\n         *\n         *  instance = new Foo();\n         *  instance.foo();\n         *  >> foo\n         *  instance.bar();\n         *  >> bar\n         * ```\n         *\n         * The value for a fenced method value can be `true`, a string, an array of strings, or a\n         * {@link #typedef-MethodFence} options object.\n         *\n         * Internally these methods are protected by assigning a wrapper function in their place. The original function\n         * is moved to a new named property by appending 'Impl' to the original name. For example, in the above code,\n         * `foo` and `bar` are wrapper functions that apply reentrancy protection and call `fooImpl` and `barImpl`,\n         * respectively. This is important for inheritance and `super` calling because the new name must be used in\n         * order to retain the guard function implementations.\n         *\n         * @static\n         * @member {Object} fenced\n         * @internal\n         */\n        'fenced'\n    ];\n\n    static setupFenced(cls) {\n        let { fenced } = cls;\n        const\n            statics = fenced.static,\n            pairs = [];\n\n        if (statics) {\n            fenced = { ...fenced };\n            delete fenced.static;\n\n            pairs.push([statics, cls]);\n        }\n\n        pairs.push([fenced, cls.prototype]);\n\n        for (const [methods, target] of pairs) {\n            for (const methodName in methods) {\n                fenceMethod(target, methodName, methods[methodName]);\n            }\n        }\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import TextField from '../../Core/widget/TextField.js';\n\n/**\n * @module Core/widget/FilterField\n */\n\n/**\n * A simple text field for filtering a store.\n *\n * Allows filtering by {@link #config-field field}:\n *\n * ```javascript\n * const filterField = new FilterField({\n *    store : eventStore,\n *    field : 'name'\n * });\n * ```\n *\n * Or by using a {@link #config-filterFunction filter function} for greater control/custom logic:\n *\n * ```javascript\n * const filterField = new FilterField({\n *    store          : eventStore,\n *    filterFunction : (record, value) => record.name.includes(value)\n * });\n * ```\n *\n * @extends Core/widget/TextField\n * @classType filterfield\n * @widget\n */\nexport default class FilterField extends TextField {\n    static get $name() {\n        return 'FilterField';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'filterfield';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * The model field name to filter by. Can optionally be replaced by {@link #config-filterFunction}\n             * @config {String}\n             * @category Filtering\n             */\n            field : null,\n\n            /**\n             * The store to filter.\n             * @config {Core.data.Store}\n             * @category Filtering\n             */\n            store : null,\n\n            /**\n             * Optional filter function to be called with record and value as parameters for store filtering.\n             * ```javascript\n             * {\n             *     type           : 'filterfield',\n             *     store          : myStore,\n             *     filterFunction : (record, value)  => {\n             *        return record.text.includes(value);\n             *     }\n             * }\n             * ```\n             * @param {Core.data.Model} record Record for comparison\n             * @param {String} value Value to compare with\n             * @returns {Boolean} Return true if record matches comparison requirements\n             * @config {Function}\n             * @category Filtering\n             */\n            filterFunction : null,\n\n            clearable : true,\n\n            keyStrokeChangeDelay : 100,\n\n            onChange({ value }) {\n                const { store, field, filterFunction } = this;\n\n                if (store) {\n                    const filterId = `${field || this.id}-Filter`;\n\n                    if (value.length === 0) {\n                        store.removeFilter(filterId);\n                    }\n                    else {\n                        let filterBy;\n\n                        if (filterFunction) {\n                            filterBy = record => filterFunction(record, value);\n                        }\n                        else {\n                            // We filter using a RegExp, so quote significant characters\n                            value = value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n                            filterBy = record => record.get(field).match(new RegExp(value, 'i'));\n                        }\n\n                        // A filter with an id replaces any previous filter with that id.\n                        // Leave any other filters which may be in use in place.\n                        store.filter({\n                            id : filterId,\n                            filterBy\n                        });\n                    }\n                }\n            }\n        };\n    }\n\n    updateValue(value, old) {\n        super.updateValue(value, old);\n\n        // Initial value, apply it\n        if (value && this.isConfiguring) {\n            this.onChange({ value });\n        }\n    }\n};\n\nFilterField.initClass();\n","import Base from '../../Base.js';\nimport BrowserHelper from '../../helper/BrowserHelper.js';\nimport FunctionHelper from '../../helper/FunctionHelper.js';\nimport ObjectHelper from '../../helper/ObjectHelper.js';\nimport Delayable from '../../mixin/Delayable.js';\nimport Fencible from '../../mixin/Fencible.js';\n\n/**\n * @module Core/widget/mixin/Responsive\n */\n\nconst\n    EMPTY = [],\n    isStateName = name => name[0] !== '*',\n    pop = (object, key) => {\n        const ret = object[key] || null;\n        delete object[key];\n        return ret;\n    },\n    responsiveRootFn = widget => widget.responsiveRoot,\n    scoring = {\n        number : threshold => ({ width }) => width <= threshold && threshold\n    },\n    splitConfigs = configs => {\n        delete configs.once;\n\n        return {\n            callback : pop(configs, 'callback'),\n            configs  : configs,\n            when     : pop(configs, 'when')\n        };\n    },\n    // We cheat a bit and leave \"once\", \"when\" and \"callback\" in the config object for the merge.\n    splitMergedConfigs = (cls, ...parts) => {\n        const\n            once = parts.flatMap(p => p?.once || EMPTY), // onces are not arrays, so are unchanged; ==> filter().map()\n            configs = cls.mergeConfigs(...parts),\n            ret = splitConfigs(configs);\n\n        ret.once = once.length ? splitConfigs(cls.mergeConfigs(...once)) : null;\n\n        return ret;\n    },\n    // Allow responsiveTarget to be a DOM element? (see git history for wrapElement impl)\n    wrapWidget = (widget, handler) => {\n        let triggers,\n            desc = Proxy.revocable(widget, {\n                get(o, name) {\n                    if (triggers) {\n                        triggers[name] = true;\n                    }\n\n                    return widget[name];\n                }\n            }),\n            detacher = FunctionHelper.after(widget, 'onConfigChange', (ignore, { name }) => {\n                if (triggers?.[name]) {\n                    handler();\n                }\n            }),\n            resizer = widget.ion({\n                resize : () => {\n                    handler();\n                }\n            });\n\n        widget.monitorResize = true;\n\n        return {\n            widget,\n\n            get object() {\n                return desc?.proxy;\n            },\n\n            destroy() {\n                if (desc) {\n                    desc.revoke();\n                    detacher();\n                    resizer();\n\n                    desc = detacher = resizer = null;\n                }\n            },\n\n            reset() {\n                triggers = Object.create(null);\n            }\n        };\n    };\n\n/**\n * A state definition object used by the {@link Core.widget.mixin.Responsive#config-responsive} config property.\n *\n * ```javascript\n *  {\n *      responsive : {\n *          small : {\n *              // a ResponsiveState object\n *              when : 400,\n *\n *              callback() {\n *                  console.log('Applied small not first time');\n *              },\n *\n *              once : {\n *                  mode : 'full',\n *\n *                  callback() {\n *                      console.log('Applied small first time');\n *                  }\n *              }\n *\n *              // All other properties are configs to apply when\n *              // the state is active\n *              text  : null,\n *              color : 'b-blue'\n *          }\n *      }\n *  }\n * ```\n *\n * See {@link Core.widget.mixin.Responsive} for more details.\n *\n * @typedef ResponsiveState\n * @property {ResponsiveState} once A `ResponsiveState` object applied only one time when a state is first activated. It\n * is not valid to specify a `when` or `once` property on these `ResponsiveState` objects. It is valid to supply a\n * `callback`, and if done, this callback will be called instead of the `callback` on the parent `ResponsiveState`\n * object on first activation.\n * @property {Function|Number} when A two argument function to return the score for the state, or a number for both the\n * width threshold and score. The arguments passed are as follows:\n *  - `widget` The {@link Core.widget.mixin.Responsive#config-responsiveTarget widget} whose properties should determine\n *  the state's score\n *  - `browserHelper` The {@link Core.helper.BrowserHelper} singleton object\n * @property {Function} [callback] An optional callback, called when the state is activated. This function receives an\n * object with the following properties:\n *  - `source` The instance whose state is being activated (typically a {@link Core.widget.Widget})\n *  - `target` The {@link Core.widget.Widget} identified as the {@link Core.widget.mixin.Responsive#config-responsiveTarget}\n *  - `state` The name of the newly active responsive state\n *  - `oldState` The name of the previously active responsive state\n */\n\n/**\n * A breakpoint definition. Used when defining breakpoints, see {@link #config-breakpoints}.\n *\n * ```javascript\n * {\n *     name    : 'Small',\n *     configs : {\n *         text  : null,\n *         color : 'b-blue'\n *     },\n *     callback() {\n *         console.log('Applied small');\n *     }\n * }\n * ```\n *\n * @typedef Breakpoint\n * @property {String} name Name of the breakpoint\n * @property {Object} [configs] An optional configuration object to apply to the widget when the breakpoint is activated\n * @property {Function} [callback] An optional callback, called when the breakpoint is activated\n * @deprecated 5.0 Breakpoints have been replaced by {@link Core.widget.mixin.Responsive#config-responsive}.\n */\n\n/**\n * This mixin provides management of a named set of {@link #typedef-ResponsiveState} objects that are conditionally\n * applied in response to the widget's size or other platform details. The names of the {@link #typedef-ResponsiveState}\n * objects are the keys of the {@link #config-responsive} config object. For example:\n *\n * ```javascript\n *  class ResponsiveButton extends Button.mixin(Responsive) {\n *      static configurable = {\n *          responsive : {\n *              small : {\n *                  // this is a ResponsiveState object named \"small\"\n *                  text : 'S'\n *              },\n *              medium : {\n *                  text : 'M'\n *              }\n *              large : {\n *                  text : 'L'\n *              }\n *          }\n *      };\n *  }\n * ```\n * When the conditions are right for the button to be in the `'small'` responsive state, the `text` config will be set\n * to `'S'`.\n *\n * Any desired configs can be present in a {@link #typedef-ResponsiveState} object, however, the `when` and `callback`\n * properties have special meaning to this mixin and are reserved.\n *\n * ## Selecting the Responsive State\n *\n * To determine the current responsive state, the `when` property is consulted for each candidate state.\n *\n * If `when` is a number, it is understood to be a width threshold and, if the widget's `width` is equal or less than\n * that value, the score is that value. For example, a value of 400 would produce a score of 400 if the widget's width\n * were less than or equal to 400. If the widget's width is greater than 400, the state would be skipped.\n *\n * If `when` is a function, it is called with two parameters: a readonly reference to the widget and the\n * {@link Core.helper.BrowserHelper} singleton object. The function should return the numeric score if the state is\n * applicable, or `null` or `false` if the state should be skipped.\n *\n * The state that has the minimum score is selected as the responsive state for the widget.\n *\n * Consider the default responsive states and their `when` values:\n *\n * ```javascript\n *  responsive : {\n *      small : {\n *          when : 400\n *      },\n *\n *      medium : {\n *          when : 800\n *      },\n *\n *      large : {\n *          when : () => Infinity\n *      },\n *\n *      '*' : {}\n *  },\n * ```\n *\n * For example, if the width of the widget is 300: the score for the `small` responsive state is 400, the score for\n * the `medium` responsive state is 800, and the score for `large` is infinity. In effect, the `large` state is always\n * a candidate, but will also always lose to other candidate states. In this case, the `small` state has the minimum\n * score and is selected as the responsive state.\n *\n * If the width of the widget is 600: the `small` state would be skipped, while the `medium` and `large` states would\n * produce the same scores resulting in `medium` being the responsive state.\n *\n * The `when` functions have access to any properties of the widget instance in the first argument, but are also passed\n * the {@link Core.helper.BrowserHelper} singleton as a second argument. This can be used as shown in the following,\n * over-simplified example:\n *\n * ```javascript\n *  class ResponsiveWidget extends Widget.mixin(Responsive) {\n *      static configurable = {\n *          responsive : {\n *              small : {\n *                  when : ({ width }, { isMobileSafari }) => isMobileSafari && width <= 600 && 10\n *                  text : 'iPhone'\n *              },\n *              medium : {\n *                  when : ({ width }, { isMobileSafari }) => isMobileSafari && width <= 1024 && 20\n *                  text : 'iPad'\n *              }\n *              large : {\n *                  text : 'Desktop'\n *              }\n *          }\n *      };\n *  }\n * ```\n * It is best to avoid mixing `when` threshold values and `when` functions as the resulting scores can be confusing.\n * @mixin\n */\nexport default Target => class Responsive extends (Target || Base).mixin(Delayable, Fencible) {\n    static $name = 'Responsive';\n\n    static configurable = {\n        /**\n         * Specifies the various responsive state objects keyed by their name. Each key (except `'*'`, see below) in\n         * this object is a state name (see {@link #config-responsiveState}) and its corresponding value is the\n         * associated {@link #typedef-ResponsiveState} object.\n         *\n         * Some properties of a `ResponsiveState` object are special, for example `when` and `callback`. All other\n         * properties of the state object are config properties to apply when that state is active.\n         *\n         * The `when` property can be a function that computes the score for the state. The state whose `when` function\n         * returns the lowest score is selected and its non-special properties will be assigned to the instance. If\n         * `when` is a number, it will be converted into a scoring function (see below).\n         *\n         * A `when` function accepts two readonly parameters and returns either a numeric score if the state should be\n         * considered, or `false` or `null` if the state should be ignored (i.e., it does match with the current state).\n         *\n         * The first parameter is a readonly proxy for the {@link #config-responsiveTarget widget} whose size and other\n         * properties determine the state's score. The proxy tracks property access to that widget in order to update\n         * the responsive state should any of those properties change.\n         *\n         * The second argument to a `when` function is the {@link Core.helper.BrowserHelper} singleton. This allows\n         * a `when` function to conveniently test platform and browser information.\n         *\n         * The state whose `when` function returns the lowest score is selected as the new\n         * {@link #config-responsiveState} and its config object (minus the `when` function and other special\n         * properties) is applied to the instance.\n         *\n         * If `when` is a number, it is converted to function. The following two snippets produce the same `when`\n         * scoring:\n         *\n         * ```javascript\n         *      small : {\n         *          when : 400,\n         *          ...\n         *      }\n         * ```\n         *\n         * The above converted to:\n         *\n         * ```javascript\n         *      small : {\n         *          when : ({ width }) => width <= 400 && 400,\n         *          ...\n         *      }\n         * ```\n         * Selecting the lowest score as the winner allows for the simple conversion of width threshold to score value,\n         * such that the state with the smallest matching width is selected.\n         *\n         * If the `responsive` config object has an asterisk key (`'*'`), its value is used as the default set of config\n         * properties to apply all other states. This will be the only config properties to apply if no `when` function\n         * returns a score. In this way, this special state object acts as a default state as well as a set of\n         * default values for other states to share. This state object has no `when` function.\n         *\n         * The default for this config is:\n         * ```javascript\n         *  {\n         *      small : {\n         *          when : 400\n         *      },\n         *\n         *      medium : {\n         *          when : 800\n         *      },\n         *\n         *      large : {\n         *          when : () => Infinity\n         *      },\n         *\n         *      '*' : {}\n         *  }\n         * ```\n         *\n         * A derived class (or instance) can use these states by populating other config properties, define\n         * additional states, and/or adjust the `when` properties to use different size thresholds.\n         *\n         * @config {Object}\n         */\n        responsive : {\n            $config : {\n                lazy : 'paint'\n            },\n\n            value : null\n        },\n\n        /**\n         * The defaults for the {@link #config-responsive} config. These are separated so that the act of setting the\n         * {@link #config-responsive} config is what triggers additional processing.\n         * @config {Object}\n         * @internal\n         * @default\n         */\n        responsiveDefaults : {\n            small : {\n                when : 400\n            },\n\n            medium : {\n                when : 800\n            },\n\n            large : {\n                when : () => Infinity\n            },\n\n            '*' : {}\n        },\n\n        /**\n         * Set to `true` to mark this instance as the default {@link #config-responsiveTarget} for descendants that do\n         * not specify an explicit {@link #config-responsiveTarget} of their own.\n         * @config {Boolean}\n         * @default false\n         */\n        responsiveRoot : null,\n\n        /**\n         * The name of the active state of the {@link #config-responsive} config. This is assigned internally\n         * and should not be assigned directly.\n         *\n         * @config {String}\n         * @readonly\n         */\n        responsiveState : null,\n\n        /**\n         * The widget whose size and other properties drive this object's responsive behavior. If this config is not\n         * specified, the closest ancestor that specified {@link #config-responsiveRoot responsiveRoot=true} will be\n         * used. If there is no such ancestor, then the instance using this mixin is used.\n         *\n         * If this value is set to `'@'`, then this instance is used even if there is a {@link #config-responsiveRoot}\n         * ancestor.\n         *\n         * If this config is a string that starts with `'@'`, the text following the first character is the name of the\n         * property on this instance that holds the target to use. For example, `'@owner'` to use the value of the\n         * `owner` property as the responsive target.\n         *\n         * If this config is a string that does not start with `'@'`, that string is passed to\n         * {@link Core.widget.Widget#function-up} to find the closest matching ancestor.\n         *\n         * If another widget is used as the `responsiveTarget` and if this instance does not specify any explicit `when`\n         * properties in its {@link #config-responsive} config, then the `when` definitions of the `responsiveTarget`\n         * will be used for this instance.\n         * @config {String|Core.widget.Widget}\n         */\n        responsiveTarget : {\n            value   : null,\n            $config : {\n                lazy : 'paint'\n            }\n        },\n\n        responsiveWidget : {\n            value   : null,\n            $config : {\n                nullify : true\n            }\n        },\n\n        /**\n         * Defines responsive breakpoints, based on max-width or max-height.\n         *\n         * When the widget is resized, the defined breakpoints are queried to find the closest larger or equal\n         * breakpoint for both width and height. If the found breakpoint differs from the currently applied, it is\n         * applied.\n         *\n         * Applying a breakpoint triggers an event that applications can catch to react to the change. It also\n         * optionally applies a set of configs and calls a configured callback.\n         *\n         * ```javascript\n         * breakpoints : {\n         *     width : {\n         *         50 : { name : 'small', configs : { text : 'Small', ... } }\n         *         100 : { name : 'medium', configs : { text : 'Medium', ... } },\n         *         '*' : { name : 'large', configs : { text : 'Large', ... } }\n         *     }\n         * }\n         * ```\n         *\n         * @config {Object}\n         * @param {Object} width Max-width breakpoints, with keys as numerical widths (or '*' for larger widths than the\n         * largest defined one) and the value as a {@link #typedef-Breakpoint breakpoint definition}\n         * @param {Object} height Max-height breakpoints, with keys as numerical heights (or '*' for larger widths than\n         * the largest defined one) and the value as a {@link #typedef-Breakpoint breakpoint definition}\n         * @deprecated 5.0 Use {@link #config-responsive} instead.\n         */\n        breakpoints : null\n    };\n\n    static delayable = {\n        responsiveUpdate : 'raf'\n    };\n\n    static fenced = {\n        syncResponsiveWidget : true\n    };\n\n    static prototypeProperties = {\n        responsiveStateChanges : 0,\n        responsiveUpdateCount  : 0\n    };\n\n    get isResponsivePending() {\n        return this.responsiveUpdateCount === 0 && this.hasConfig('responsive');\n    }\n\n    get isResponsiveUpdating() {\n        return this._responsiveUpdating || this.responsiveWidget?._responsiveUpdating;\n    }\n\n    // responsive\n\n    updateResponsive(responsive) {\n        const\n            me  = this,\n            cls = me.constructor,\n            { responsiveDefaults } = me,\n            stateNames = Array.from(\n                new Set(ObjectHelper.keys(responsive).concat(ObjectHelper.keys(responsiveDefaults)))).filter(isStateName);\n\n        let states = null,\n            hasWhen, name, state, when;\n\n        if (responsive) {\n            states = {\n                '*' : splitMergedConfigs(cls, responsiveDefaults['*'], responsive['*'])\n            };\n\n            for (name of stateNames) {\n                state = responsive[name];\n\n                if (state !== null && state !== false) {\n                    // Track whether any state has an explicit \"when\" property\n                    hasWhen = hasWhen || (state && 'when' in state);\n\n                    states[name] = splitMergedConfigs(cls,\n                        responsiveDefaults['*'], responsiveDefaults[name], responsive['*'], state);\n\n                    when = states[name].when;\n                    states[name].when = scoring[typeof when]?.(when) || when;  // convert numbers to fns based on width\n                }\n            }\n        }\n\n        me.$responsiveStates = states;\n        me.$responsiveWhen = hasWhen;\n        me.syncResponsiveWidget();\n    }\n\n    // responsiveState\n\n    updateResponsiveState(state, oldState) {\n        const\n            me = this,\n            { $responsiveStates : states } = me,\n            initial = ++me.responsiveStateChanges === 1,\n            classList = me.element?.classList,\n            defaults = states['*'],\n            def = states[state] || defaults,\n            once = initial && (def.once || defaults.once),\n            isStateful = initial && me.isStateful,\n            target = me.responsiveWidget;\n\n        let config = def.configs,\n            otherConfigs = once?.configs;\n\n        if (otherConfigs) {\n            // overlay \":once\" configs on normal configs (the mergeConfigs method clones the first parameter before\n            // merging it with other values)\n            config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;\n        }\n\n        oldState && classList?.remove(`b-responsive-${oldState.toLowerCase()}`);\n        state && classList?.add(`b-responsive-${state.toLowerCase()}`);\n\n        if (isStateful) {\n            // our responsiveState is munged with the stateId to retrieve state info for this responsiveState (to track\n            // state by small/medium/large/etc). If we don't load the state on each call here we would end up smashing\n            // the values saved in state with those defined by the developer in the responsive config.\n            otherConfigs = me.loadStatefulData();\n\n            if (otherConfigs) {\n                // if there is stateful data for this responsiveState, it takes priority over our config object\n                config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;\n            }\n\n            // We don't want responsive changes to configs to trigger state save:\n            me.suspendStateful();\n        }\n\n        me._responsiveUpdating = true;\n\n        try {\n            /**\n             * Triggered before a new {@link #config-responsiveState} is applied.\n             * @event beforeResponsiveStateChange\n             * @param {Core.widget.Widget} source The widget whose `responsiveState` is to be changed\n             * @param {String} state The new value for the widget's `responsiveState`\n             * @param {String} oldState The previous value for the widget's `responsiveState`\n             */\n            me.trigger?.('beforeResponsiveStateChange', { state, oldState, target });\n\n            config && me.setConfig(config);\n\n            def.callback?.({ source : me, state, oldState, target, initial });\n            once?.callback?.({ source : me, state, oldState, target, initial });\n\n            /**\n             * Triggered when a new {@link #config-responsiveState} is applied.\n             * @event responsiveStateChange\n             * @param {Core.widget.Widget} source The widget whose `responsiveState` has changed\n             * @param {String} state The new value for the widget's `responsiveState`\n             * @param {String} oldState The previous value for the widget's `responsiveState`\n             */\n            me.trigger?.('responsiveStateChange', { state, oldState, target });\n            // we normally would check for !me.isConstructing or !me.isConfiguring but this event needs to be fired\n            // during that time to allow the app to receive the initial responsive state since it is dynamic (i.e.,\n            // not something the app has configured into the widget)\n        }\n        finally {\n            // Be sure to reset these even if an exception occurs\n            me._responsiveUpdating = false;\n            isStateful && me.resumeStateful();\n        }\n    }\n\n    // responsiveTarget\n\n    get responsiveTarget() {\n        return this.responsiveWidget || this._responsiveTarget;\n    }\n\n    updateResponsiveTarget() {\n        this.syncResponsiveWidget();\n    }\n\n    // responsiveWidget\n\n    updateResponsiveWidget(target) {\n        const\n            me = this,\n            // being a delayable raf method effectively auto-bind's our this pointer\n            responsiveUpdate = target && me.responsiveUpdate;\n\n        me.$responsiveWrapper?.destroy();\n        me.$responsiveWrapper = target && wrapWidget(target, responsiveUpdate);\n\n        responsiveUpdate?.now();\n    }\n\n    // Support methods\n\n    responsiveUpdate() {\n        const\n            me = this,\n            { $responsiveStates : states, $responsiveWrapper : wrapper } = me,\n            responsiveTarget = wrapper?.widget;\n\n        if (states && wrapper) {\n            let best = null,\n                bestScore = 0,  // 0 doesn't get used (since !best) but data flow warnings arise w/o assignment\n                fromWhen = states,\n                score, state;\n\n            // If this instance has a responsiveWidget (via responsiveTarget being set to a widget), and that widget\n            // is not this instance, and if this instance did not specify any explicit \"when\" properties in its own\n            // \"responsive\" config, use those of the target\n            if (responsiveTarget && responsiveTarget !== me && !me.$responsiveWhen) {\n                responsiveTarget.getConfig('responsive');  // make sure the config has been evaluated\n                fromWhen = responsiveTarget.$responsiveStates || fromWhen;\n            }\n\n            wrapper.reset();\n\n            for (state in states) {\n                if (state !== '*') {\n                    score = fromWhen[state].when(wrapper.object, BrowserHelper);\n\n                    if (score != null && score !== false && (!best || score < bestScore)) {\n                        best = state;\n                        bestScore = score;\n                    }\n                }\n            }\n\n            ++me.responsiveUpdateCount; // this unlocks statefulId() getter in State mixin\n\n            me.responsiveState = best;\n        }\n    }\n\n    syncResponsiveWidget() {\n        const me = this;\n\n        let widget = null,\n            responsiveTarget;\n\n        if (!me.isDestroying && me.responsive) {\n            responsiveTarget = me.responsiveTarget;\n\n            if (!(widget = responsiveTarget)) {\n                widget = (!me.responsiveRoot && me.up?.(responsiveRootFn)) || me;\n            }\n            else if (typeof responsiveTarget === 'string') {\n                widget = responsiveTarget === '@' ? me : (\n                    responsiveTarget[0] === '@' ? me[responsiveTarget.substring(1)] : me.up(responsiveTarget)\n                );\n\n                if (!widget) {\n                    throw new Error(`No match for responsiveTarget=\"${responsiveTarget}\"`);\n                }\n            }\n\n            if (!widget.isWidget) {\n                throw new Error(`${widget.constructor.$$name} is not a widget and cannot be a responsiveTarget`);\n            }\n        }\n\n        me.responsiveWidget = widget;\n\n        return widget;\n    }\n\n    //----------------------------------------------------------------------------------------------------\n    // breakpoints -- TODO remove in 6.0\n\n    changeBreakpoints(breakpoints) {\n        ObjectHelper.assertObject(breakpoints, 'breakpoints');\n\n        // Normalize breakpoints\n        if (breakpoints?.width) {\n            Object.keys(breakpoints.width).forEach(key => {\n                breakpoints.width[key].maxWidth = key;\n            });\n        }\n\n        if (breakpoints?.height) {\n            Object.keys(breakpoints.height).forEach(key => {\n                breakpoints.height[key].maxHeight = key;\n            });\n        }\n\n        return breakpoints;\n    }\n\n    updateBreakpoints(breakpoints) {\n        if (breakpoints) {\n            this.monitorResize = true;\n        }\n    }\n\n    // Get a width/height breakpoint for the supplied dimension\n    getBreakpoint(levels, dimension) {\n        const\n            // Breakpoints as reverse sorted array of numerical widths [NaN for *, 50, 100]\n            ascendingLevels = Object.keys(levels).map(l => parseInt(l)).sort(),\n            // Find first one larger than current width\n            breakpoint     = ascendingLevels.find(bp => dimension <= bp);\n\n        // Return matched breakpoint or * if available and none matched\n        return levels[breakpoint ?? (levels['*'] && '*')];\n    }\n\n    // Apply a breakpoints configs, trigger event and call any callback\n    activateBreakpoint(orientation, breakpoint) {\n        const\n            me             = this,\n            prevBreakpoint = me[`current${orientation}Breakpoint`];\n\n        if (breakpoint !== prevBreakpoint) {\n            me[`current${orientation}Breakpoint`] = breakpoint;\n\n            me.setConfig(breakpoint.configs);\n\n            prevBreakpoint && me.element.classList.remove(`b-breakpoint-${prevBreakpoint.name.toLowerCase()}`);\n            me.element.classList.add(`b-breakpoint-${breakpoint.name.toLowerCase()}`);\n\n            /**\n             * Triggered when a new max-width based breakpoint is applied.\n             * @event responsiveWidthChange\n             * @param {Core.widget.Widget} source The widget\n             * @param {Breakpoint} breakpoint The applied breakpoint\n             * @param {Breakpoint} prevBreakpoint The previously applied breakpoint\n             * @deprecated 5.0 This event is associated with {@link #config-breakpoints} which is deprecated in favor of\n             * {@link #config-responsive}.\n             */\n            /**\n             * Triggered when a new max-height based breakpoint is applied.\n             * @event responsiveHeightChange\n             * @param {Core.widget.Widget} source The widget\n             * @param {Breakpoint} breakpoint The applied breakpoint\n             * @param {Breakpoint} prevBreakpoint The previously applied breakpoint\n             * @deprecated 5.0 This event is associated with {@link #config-breakpoints} which is deprecated in favor of\n             * {@link #config-responsive}.\n             */\n\n            me.trigger(`responsive${orientation}Change`, { breakpoint, prevBreakpoint });\n\n            breakpoint.callback?.({ source : me, breakpoint, prevBreakpoint });\n\n            me.recompose?.();\n        }\n    }\n\n    // Called on resize to pick and apply a breakpoint, if size changed enough\n    applyResponsiveBreakpoints(width, height) {\n        const\n            me = this,\n            {\n                width  : widths,\n                height : heights\n            }  = me.breakpoints ?? {};\n\n        if (widths) {\n            const breakpoint = me.getBreakpoint(widths, width);\n            me.activateBreakpoint('Width', breakpoint);\n        }\n\n        if (heights) {\n            const breakpoint = me.getBreakpoint(heights, height);\n            me.activateBreakpoint('Height', breakpoint);\n        }\n    }\n\n    onInternalResize(element, width, height, oldWidth, oldHeight) {\n        super.onInternalResize(element, width, height, oldWidth, oldHeight);\n\n        this.applyResponsiveBreakpoints(width, height);\n    }\n};\n"],"names":["Target","Featureable","Base","$name","configurable","features","declarable","setupFeatureable","cls","featureable","_objectSpread","ownerName","factory","initClass","Reflect","defineProperty","get","doDestroy","name","_feature$destroy","feature","destroy","call","hasFeature","_this$features","Boolean","changeFeatures","was","isDestroying","me","constructor","manager","$features","DynamicObject","configName","owner","update","target","widgetClass","getCurrentConfig","options","result","featureName","Object","keys","length","hasOwn","ObjectHelper","fencibleSymbol","Symbol","NONE","distinct","array","Array","from","Set","parseNames","names","StringHelper","split","fenceMethod","isObject","all","any","lock","concat","implName","fence","params","fences","isFree","key","every","some","forEach","value","_class","Fencible","setupFenced","fenced","statics","static","pairs","push","prototype","methods","methodName","_defineProperty","FilterField","TextField","type","field","store","filterFunction","clearable","keyStrokeChangeDelay","onChange","filterId","id","removeFilter","filterBy","record","replace","match","RegExp","filter","updateValue","old","isConfiguring","_$name","EMPTY","isStateName","pop","object","ret","responsiveRootFn","widget","responsiveRoot","scoring","number","threshold","width","splitConfigs","configs","once","callback","when","splitMergedConfigs","parts","flatMap","p","mergeConfigs","wrapWidget","handler","triggers","desc","Proxy","revocable","o","detacher","FunctionHelper","after","ignore","_triggers","resizer","ion","resize","monitorResize","_desc","proxy","revoke","reset","create","Responsive","mixin","Delayable","isResponsivePending","responsiveUpdateCount","hasConfig","isResponsiveUpdating","_this$responsiveWidge","_responsiveUpdating","responsiveWidget","updateResponsive","responsive","responsiveDefaults","stateNames","states","hasWhen","state","_scoring$when","$responsiveStates","$responsiveWhen","syncResponsiveWidget","updateResponsiveState","oldState","_me$element","initial","responsiveStateChanges","classList","element","defaults","def","isStateful","config","otherConfigs","remove","toLowerCase","add","loadStatefulData","suspendStateful","_me$trigger","_def$callback","_once$callback","_me$trigger2","trigger","setConfig","source","resumeStateful","responsiveTarget","_responsiveTarget","updateResponsiveTarget","updateResponsiveWidget","_me$$responsiveWrappe","responsiveUpdate","$responsiveWrapper","now","wrapper","best","bestScore","fromWhen","score","getConfig","BrowserHelper","responsiveState","_me$up","up","substring","Error","isWidget","$$name","changeBreakpoints","breakpoints","assertObject","maxWidth","height","maxHeight","updateBreakpoints","getBreakpoint","levels","dimension","ascendingLevels","map","l","parseInt","sort","breakpoint","find","bp","activateBreakpoint","orientation","prevBreakpoint","_breakpoint$callback","_me$recompose","recompose","applyResponsiveBreakpoints","_me$breakpoints","widths","heights","onInternalResize","oldWidth","oldHeight","$config","lazy","small","medium","large","Infinity","nullify"],"mappings":";;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAeA,MAAM,IAAI,MAAMC,WAAW,UAAUD,MAAM,IAAIE,IAAI,EAAE;EAChE,WAAWC,KAAKA,GAAG;IACf,OAAO,aAAa;;EAExB,WAAWC,YAAYA,GAAG;IACtB,OAAO;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACYC,QAAQ,EAAG;KACd;;EAEL,WAAWC,UAAUA,GAAG;IACpB,OAAO;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACY,aAAa,CAChB;;EAEL,OAAOC,gBAAgBA,CAACC,GAAG,EAAE;IACzB,MAAMC,WAAW,GAAAC,cAAA;MACbC,SAAS,EAAG;OACTH,GAAG,CAACC,WAAW,CACrB;IACDA,WAAW,CAACG,OAAO,CAACC,SAAS,EAAE;;IAE/BC,OAAO,CAACC,cAAc,CAACP,GAAG,EAAE,aAAa,EAAE;MACvCQ,GAAGA,GAAG;QACF,OAAOP,WAAW;;KAEzB,CAAC;;EAENQ,SAASA,GAAG;IACR,MAAMZ,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,KAAK,CAACY,SAAS,EAAE;IACjB,KAAK,MAAMC,IAAI,IAAIb,QAAQ,EAAE;MAAA,IAAAc,gBAAA;MACzB,MAAMC,OAAO,GAAGf,QAAQ,CAACa,IAAI,CAAC;;MAE9B,CAAAC,gBAAA,GAAAC,OAAO,CAACC,OAAO,cAAAF,gBAAA,uBAAfA,gBAAA,CAAAG,IAAA,CAAAF,OAAO,C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CAACvB,MAAM,EAAEiD,UAAU,EAAED,OAAO,CAACC,UAAU,CAAC,CAAC;;;;;;;IAOhE,IAAIhD,WAAWA,GAAG;GACrB,EAAAiD,eAAA,CAAAX,MAAA,WAnFkB,UAAU,GAAAW,eAAA,CAAAX,MAAA,gBACL;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACQ,QAAQ,CACX,GAAAA,MAAA;AAAA,CAsBJ;;ACvMD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,MAAMY,WAAW,SAASC,SAAS,CAAC;EAC/C,WAAWtF,KAAKA,GAAG;IACf,OAAO,aAAa;;;EAGxB,WAAWuF,IAAIA,GAAG;IACd,OAAO,aAAa;;EAExB,WAAWtF,YAAYA,GAAG;IACtB,OAAO;;AAEf;AACA;AACA;AACA;MACYuF,KAAK,EAAG,IAAI;;AAExB;AACA;AACA;AACA;MACYC,KAAK,EAAG,IAAI;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACYC,cAAc,EAAG,IAAI;MACrBC,SAAS,EAAG,IAAI;MAChBC,oBAAoB,EAAG,GAAG;MAC1BC,QAAQA,CAAC;QAAErB;OAAO,EAAE;QAChB,MAAM;UAAEiB,KAAK;UAAED,KAAK;UAAEE;SAAgB,GAAG,IAAI;QAC7C,IAAID,KAAK,EAAE;UACP,MAAMK,QAAQ,GAAI,GAAEN,KAAK,IAAI,IAAI,CAACO,EAAG,SAAQ;UAC7C,IAAIvB,KAAK,CAAC9B,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Aa,KAAA,uBAAJA,KAAA,CAAMC,KAAK;OACrB;MACDhI,OAAOA,GAAG;QACN,IAAIkH,IAAI,EAAE;UACNA,IAAI,CAACe,MAAM,EAAE;UACbX,QAAQ,EAAE;UACVK,OAAO,EAAE;UACTT,IAAI,GAAGI,QAAQ,GAAGK,OAAO,GAAG,IAAI;;OAEvC;MACDO,KAAKA,GAAG;QACJjB,QAAQ,GAAG3F,MAAM,CAAC6G,MAAM,CAAC,IAAI,CAAC;;KAErC;GACJ;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAexJ,MAAM;EAAA,IAAA4E,MAAA;EAAA,OAAAA,MAAA,GAAI,MAAM6E,UAAU,SAAS,CAACzJ,MAAM,IAAI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gB,CAACrE,OAAO,EAAE3D,KAAK,EAAEwG,MAAM,EAAEyB,QAAQ,EAAEC,SAAS,CAAC;MACnE,IAAI,CAACN,0BAA0B,CAAC5H,KAAK,EAAEwG,MAAM,CAAC;;GAErD,EAAA1I,eAAA,CAAAX,MAAA,WAhckB,YAAY,GAAAW,eAAA,CAAAX,MAAA,kBACL;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQwF,UAAU,EAAG;MACTwF,OAAO,EAAG;QACNC,IAAI,EAAG;OACV;MACDlL,KAAK,EAAG;KACX;;AAET;AACA;AACA;AACA;AACA;AACA;IACQ0F,kBAAkB,EAAG;MACjByF,KAAK,EAAG;QACJhI,IAAI,EAAG;OACV;MACDiI,MAAM,EAAG;QACLjI,IAAI,EAAG;OACV;MACDkI,KAAK,EAAG;QACJlI,IAAI,EAAGA,MAAMmI;OAChB;MACD,GAAG,EAAG;KACT;;AAET;AACA;AACA;AACA;AACA;IACQ5I,cAAc,EAAG,IAAI;;AAE7B;AACA;AACA;AACA;AACA;AACA;IACQiG,eAAe,EAAG,IAAI;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQf,gBAAgB,EAAG;MACf5H,KAAK,EAAK,IAAI;MACdiL,OAAO,EAAG;QACNC,IAAI,EAAG;;KAEd;IACD3F,gBAAgB,EAAG;MACfvF,KAAK,EAAK,IAAI;MACdiL,OAAO,EAAG;QACNM,OAAO,EAAG;;KAEjB;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQpC,WAAW,EAAG;GACjB,GAAAvI,eAAA,CAAAX,MAAA,eACkB;IACfgI,gBAAgB,EAAG;GACtB,GAAArH,eAAA,CAAAX,MAAA,YACe;IACZiG,oBAAoB,EAAG;GAC1B,GAAAtF,eAAA,CAAAX,MAAA,yBAC4B;IACzBsG,sBAAsB,EAAG,CAAC;IAC1BrB,qBAAqB,EAAI;GAC5B,GAAAjF,MAAA;AAAA,CAoQJ;;;;"}