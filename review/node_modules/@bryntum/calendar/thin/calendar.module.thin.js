/*!
 *
 * Bryntum Calendar 5.3.0
 *
 * Copyright(c) 2023 Bryntum AB
 * https://bryntum.com/contact
 * https://bryntum.com/license
 *
 */
import { _defineProperty, DateHelper, DomSync, DomHelper, Rectangle, Store, ObjectHelper, InstancePlugin, Factoryable, _objectSpread2, Base, Tooltip, StringHelper, FunctionHelper, DomClassList, EventHelper, Widget, parseAlign, Delayable, BrowserHelper, TemplateHelper, TimeZoneHelper, ArrayHelper, LocaleHelper, Config, DayTime, Popup, Scroller, Objects, Toast, Button, Collection, Panel, GlobalEvents, ResizeMonitor, Container, MenuItem, Bag, State, DynamicObject, ScrollManager, VersionHelper } from './chunks/Editor.js';
import { ColumnStore, Column } from './chunks/GridBase.js';
import { CrudManager as CrudManager$1, PackMixin, Describable, SchedulerEventSelection } from './chunks/EventSelection.js';
import { TimeSpan, ProjectModel as ProjectModel$1, ResourceTimeRangeModel, CrudManagerView } from './chunks/ProjectModel.js';
import { Draggable, Droppable, AvatarRendering } from './chunks/AvatarRendering.js';
import { Hoverable, Minifiable } from './chunks/Minifiable.js';
import { ClockTemplate, RecurrenceConfirmationPopup, EventMenu as EventMenu$1, ScheduleMenu as ScheduleMenu$1, AttachToProjectMixin, ProjectConsumer, SchedulerEventNavigation, CurrentConfig, RecurringEvents } from './chunks/EventNavigation.js';
import { RecurrenceLegend, EventEditor as EventEditor$1, EventEdit as EventEdit$1, SchedulerDatePicker } from './chunks/SchedulerDatePicker.js';
import { MessageDialog, Month, CalendarPanel } from './chunks/MessageDialog.js';
import { Exporter, PaperFormat } from './chunks/Exporter.js';
import { Grid } from './chunks/Grid.js';
import { Featureable, Responsive, Fencible } from './chunks/Responsive.js';
import './chunks/DateColumn.js';
import './chunks/Card.js';
import { GridRowModel } from './chunks/GridRowModel.js';
import { ButtonGroup } from './chunks/ButtonGroup.js';

/**
 * @module Calendar/column/AgendaColumn
 */
/**
 * A column that displays events for a day.
 *
 * This is not intended to be used directly, it is used by the {@link Calendar.widget.AgendaView} which
 * is a specialized {@link Grid.view.Grid} subclass.
 *
 * @extends Grid/column/Column
 *
 * @classType agendacolumn
 * @column
 */
class AgendaColumn extends Column {
  //region Config

  static get type() {
    return 'agendacolumn';
  }
  static get defaults() {
    return {
      // Quoted to avoid commit-hook check:
      'id': 'agenda',
      // eslint-disable-line quote-props
      text: 'Agenda',
      filterable: false,
      sortable: false,
      editor: false,
      searchable: false,
      // With its defaultRenderer, and no eventRenderer, AgendaColumn measures
      // once then is able to calculate row heights from the cell's event count.
      // This field is automatically set to true if a column renderer or eventRenderer
      // is found.
      autoHeight: false,
      alwaysClearCell: false
    };
  }
  //endregion
  construct() {
    super.construct(...arguments);
    this.grid.ion({
      beforeResponsiveStateChange: 'onBeforeGridResponsiveStateChange',
      thisObj: this
    });
  }
  //region Render
  /**
   * Renderer that shows a list of events for a single date.
   *
   * Note that all {@link Calendar.widget.AgendaView} columns are automatically set to
   * {@link Grid.column.Column#config-autoHeight} because an unpredictable number of events may appear in
   * any cell.
   *
   * @param {Object} renderData Object containing renderer parameters
   * @param {HTMLElement} [renderData.cellElement] Cell element, for adding CSS classes, styling etc.
   *        Can be `null` in case of export
   * @param {*} renderData.value Value to be displayed in the cell
   * @param {DayCell} renderData.record A {@link Calendar.widget.mixin.DayCellCollecter#typedef-DayCell} context object
   * which contains contextual information about the date being rendered and an `events` property encapsulating
   * all the events which coincide with the date.
   * @param {Grid.column.Column} renderData.column This column
   * @param {Grid.view.Grid} renderData.grid This grid
   * @param {Grid.row.Row} [renderData.row] Row object. Can be null in case of export. Use the
   * {@link Grid.row.Row#function-assignCls row's API} to manipulate CSS class names.
   * @param {Boolean} [renderData.isExport] True if record is being exported to allow special handling during export
   * @param {Boolean} [renderData.isMeasuring] True if the column is being measured for a `resizeToFitContent`
   *        call. In which case an advanced renderer might need to take different actions.
   * @config {Function} defaultRenderer
   * @private
   */
  defaultRenderer({
    cellElement: targetElement,
    record,
    grid,
    size
  }) {
    var _grid$_cellRenderer;
    const me = this,
      {
        events,
        date
      } = record,
      children = [];
    for (let i = 0; i < events.length; i++) {
      const eventRecord = events[i],
        eventEndDate = eventRecord.endDate || DateHelper.add(eventRecord.startDate, eventRecord.duration, eventRecord.durationUnit),
        isOverflow = eventRecord.startDate < date,
        overflows = eventEndDate > record.tomorrow,
        eventDomConfig = grid.createEventDomConfig({
          date: record.date,
          isAllDay: eventRecord.allDay || overflows || isOverflow,
          eventRecord
        });
      // Arrow shows that it continues
      eventDomConfig.className['b-continues-future'] = overflows;
      eventDomConfig.className['b-continues-past'] = isOverflow;
      children.push({
        className: {
          'b-cal-agenda-event-row': 1
        },
        dataset: {
          rowId: eventRecord.id
        },
        children: [grid.eventListEventTimeRenderer(eventRecord, date), eventDomConfig],
        // Match existing data-rowId elements first and ensure DOM order matches
        // children order.
        syncOptions: {
          syncIdField: 'rowId',
          releaseThreshold: 0,
          strict: true
        }
      });
    }
    (_grid$_cellRenderer = grid._cellRenderer) === null || _grid$_cellRenderer === void 0 ? void 0 : _grid$_cellRenderer.call(grid, ...arguments);
    // cellRenderer may update the cellData record, so test after.
    targetElement.classList[record.isNonWorking ? 'add' : 'remove'](grid.nonWorkingDayCls);
    DomSync.sync({
      domConfig: {
        onlyChildren: true,
        children: [grid.agendaEventDateRenderer(date), {
          className: {
            'b-cal-event-bar-container': 1
          },
          children
        }],
        // Match existing data-row-id elements first and ensure DOM order matches
        // children order.
        syncOptions: {
          syncIdField: 'date',
          releaseThreshold: 0,
          strict: true
        }
      },
      targetElement
    });
    targetElement.dataset.date = record.id;
    if (!me.autoHeight) {
      const dateBlock = targetElement.querySelector('.b-cal-agenda-date'),
        cellTbPadding = me._cellTbPadding != null ? me._cellTbPadding : me._cellTbPadding = DomHelper.getEdgeSize(targetElement, 'padding', 'tb').height,
        containerPadding = me._containerPadding != null ? me._containerPadding : me._containerPadding = DomHelper.getEdgeSize(targetElement.querySelector('.b-cal-event-bar-container'), 'margin', 'tb').height,
        dateBlockHeight = me._dateBlockHeight != null ? me._dateBlockHeight : me._dateBlockHeight = Rectangle.outer(dateBlock).height;
      size.height = Math.max(record.events.length * (grid.eventHeightInPixels + grid.eventRowSpacing) - grid.eventRowSpacing + cellTbPadding + containerPadding + (grid.responsiveState === 'small' ? dateBlockHeight : 0), 86);
    }
  }
  onBeforeGridResponsiveStateChange() {
    // Invalidate cached measurements
    this._cellTbPadding = this._containerPadding = this._dateBlockHeight = this._dateBlockHeight = null;
  }
  getCellClass(cellContext) {
    const result = super.getCellClass(cellContext);
    result['b-sticky-cell'] = result[`b-day-of-week-${cellContext.record.day}`] = 1;
    return result;
  }
  //endregion
  //region Other
  headerRenderer({
    headerElement: targetElement
  }) {
    targetElement.innerHTML = '';
    DomSync.sync({
      domConfig: {
        className: {
          'b-cal-agenda-header': 1,
          'b-grid-header': 1,
          'b-last-leaf': 1
        },
        children: [{
          className: {
            'b-cal-agenda-header-date': 1
          },
          text: 'Date'
        }, {
          className: {
            'b-cal-agenda-header-time': 1
          },
          text: 'Time'
        }, {
          className: {
            'b-cal-agenda-header-event': 1
          },
          text: 'Event'
        }]
      },
      targetElement
    });
  }
  //endregion
}
_defineProperty(AgendaColumn, "$name", 'AgendaColumn');
ColumnStore.registerColumnType(AgendaColumn);
AgendaColumn._$name = 'AgendaColumn';

/**
 * @module Calendar/column/EventColumn
 */
/**
 * A column that displays a formatted event with details of name, times, and assigned resources in a
 * grid cell.
 *
 * This is not intended to be used directly, it is used by the {@link Calendar.widget.EventList} which
 * is a specialized {@link Grid.view.Grid} subclass.
 *
 * @extends Grid/column/Column
 *
 * @classType calendarevents
 * @column
 */
class EventColumn extends Column {
  //region Config
  static get type() {
    return 'calendarevents';
  }
  static get defaults() {
    return {
      // Quoted to avoid commit-hook check:
      'id': 'calendarevents',
      // eslint-disable-line quote-props
      text: 'Event Details',
      filterable: false,
      sortable: false,
      editor: false,
      searchable: false,
      autoHeight: true,
      alwaysClearCell: false
    };
  }
  //endregion
  //region Render
  /**
   * Renderer that shows resource avatars of assigned resources next to event names for a single date.
   *
   * Note that all {@link Calendar.widget.AgendaView} columns are automatically set to
   * {@link Grid.column.Column#config-autoHeight} because an unpredictable number of events may appear in
   * any cell.
   *
   * @param {Object} renderData Object containing renderer parameters
   * @param {HTMLElement} [renderData.cellElement] Cell element, for adding CSS classes, styling etc.
   *        Can be `null` in case of export
   * @param {*} renderData.value Value to be displayed in the cell
   * @param {DayCell} renderData.record A {@link Calendar.widget.mixin.DayCellCollecter#typedef-DayCell} context object
   * which contains contextual information about the date being rendered and an `events` property encapsulating
   * all the events which coincide with the date.
   * @param {Grid.column.Column} renderData.column This column
   * @param {Grid.view.Grid} renderData.grid This grid
   * @param {Grid.row.Row} [renderData.row] Row object. Can be null in case of export. Use the
   * {@link Grid.row.Row#function-assignCls row's API} to manipulate CSS class names.
   * @param {Boolean} [renderData.isExport] True if record is being exported to allow special handling during export
   * @param {Boolean} [renderData.isMeasuring] True if the column is being measured for a `resizeToFitContent`
   *        call. In which case an advanced renderer might need to take different actions.
   * @config {Function} renderer
   */
  renderer({
    cellElement: targetElement,
    record,
    grid
  }) {
    var _grid$calendar, _grid$_cellRenderer;
    const resourceFilter = (_grid$calendar = grid.calendar) === null || _grid$calendar === void 0 ? void 0 : _grid$calendar.widgetMap.resourceFilter,
      resources = resourceFilter ? record.resources.filter(r => resourceFilter.selected.includes(r)) : record.resources;
    (_grid$_cellRenderer = grid._cellRenderer) === null || _grid$_cellRenderer === void 0 ? void 0 : _grid$_cellRenderer.call(grid, ...arguments);
    grid.showResourceAvatars = true;
    DomSync.sync({
      domConfig: {
        onlyChildren: true,
        children: [{
          class: 'b-cal-event-resource-avatars',
          children: resources.map(resource => {
            return {
              class: 'b-cal-event-resource-avatar-row',
              children: [grid.getResourceAvatar(resource), {
                class: 'b-cal-event-resource-avatar-desc',
                children: [{
                  class: 'b-event-column-resource-name',
                  text: resource.name
                }, {
                  class: 'b-event-column-resource-role',
                  text: resource.role
                }]
              }]
            };
          })
        }, {
          class: 'b-cal-event-column-event-desc',
          children: [{
            class: 'b-cal-event-column-event-name',
            text: record.name
          }]
        }, {
          class: 'b-cal-event-column-times',
          children: [grid.eventListEventTimeRenderer(record)]
        }],
        // Match existing data-row-id elements first and ensure DOM order matches
        // children order.
        syncOptions: {
          syncIdField: 'date',
          releaseThreshold: 0,
          strict: true
        }
      },
      targetElement
    });
  }
  //endregion
}

ColumnStore.registerColumnType(EventColumn);
EventColumn.exposeProperties();
EventColumn._$name = 'EventColumn';

/**
 * @module Calendar/model/TimeRangeModel
 */
/**
 * This class represent a simple date range with additional, Calendar-specific fields. It is used by the
 * {@link Calendar.feature.TimeRanges} feature.
 *
 * This class inherits most of its fields from {@link Scheduler.model.TimeSpan}. The most important of these fields are
 * the following:
 *
 * - {@link #field-name}
 * - {@link #field-startDate}
 * - {@link #field-endDate}
 * - {@link #field-iconCls}
 *
 * It's an indirect subclass of {@link Core.data.Model}. Please refer to documentation of those classes to become
 * familiar with the base interface of this class.
 *
 * This class defines the following fields:
 *
 * - {@link #field-alignment}
 * - {@link #field-color}
 * - {@link #field-footer}
 * - {@link #field-rotation}
 *
 * The data source of any field can be customized in the subclass. Please refer to {@link Core.data.Model} for details.
 *
 * @extends Scheduler/model/TimeSpan
 * @uninherit Core/data/mixin/TreeNode
 */
class TimeRangeModel extends TimeSpan {
  /**
   * @hidefields children, parentId, parentIndex
   */
  //region Fields

  //endregion
  afterConstruct() {
    if (!this.endDate) {
      this.endDate = this.startDate;
    }
  }
}
_defineProperty(TimeRangeModel, "fields", [
/**
 * The side of the time range on which the header will be displayed The default value is `'start'`.
 *
 * This value determines where to place the time range header relative to events. A value of `'start'` will
 * place the header on the left side, while `'end'` will place the time range on the right side (these will
 * be reversed in RTL mode).
 *
 * @field {'start'|'end'} alignment
 * @category Styling
 * @default 'start'
 */
{
  name: 'alignment',
  defaultValue: 'start',
  internal: true
},
/**
 * The primary color of the header element.
 * @field {'red'|'pink'|'purple'|'violet'|'indigo'|'blue'|'cyan'|'teal'|'green'|'lime'|'yellow'|'orange'|'deep-orange'|'gray'|'gantt-green'} color
 * @category Styling
 */
{
  name: 'color',
  internal: true
},
/**
 * The text for the footer.
 * @field {String} footer
 * @category Styling
 */
{
  name: 'footer',
  internal: true
},
/**
 * The direction to rotate header/footer text.
 * @field {'neg'|'pos'} rotation
 * @category Styling
 */
{
  name: 'rotation',
  internal: true
}]);
TimeRangeModel._$name = 'TimeRangeModel';

/**
 * @module Calendar/data/TimeRangeStore
 */
/**
 * A store representing a collection of time ranges.
 *
 * @extends Core/data/Store
 */
class TimeRangeStore extends Store {}
_defineProperty(TimeRangeStore, "$name", 'TimeRangeStore');
_defineProperty(TimeRangeStore, "defaultConfig", {
  modelClass: TimeRangeModel
});
TimeRangeStore.initClass();
TimeRangeStore._$name = 'TimeRangeStore';

/**
 * @module Calendar/model/ProjectModel
 */
// noinspection JSClosureCompilerSyntax
/**
 * This class represents a global project of your Calendar - a central place for all data.
 *
 * For more information, see {@link Scheduler.model.ProjectModel}.
 *
 * @typings Scheduler/model/ProjectModel -> Scheduler/model/SchedulerProjectModel
 * @extends Scheduler/model/ProjectModel
 */
class ProjectModel extends ProjectModel$1 {}
_defineProperty(ProjectModel, "$name", 'ProjectModel');
//region Configs
_defineProperty(ProjectModel, "configurable", {
  timeRangeStore: {
    modelClass: TimeRangeModel
  }
});
_defineProperty(ProjectModel, "defaultConfig", {
  /**
   * The constructor of the time range model class, to be used in the project. Will be set as the
   * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-timeRangeStore}
   *
   * @config {Calendar.model.TimeRangeModel}
   * @typings {typeof TimeRangeModel}
   * @category Models & Stores
   */
  timeRangeModelClass: TimeRangeModel,
  /**
   * The constructor to create an timeRange store instance with. Should be a class, subclassing the
   * {@link Core.data.Store}
   * @config {Core.data.Store|Object}
   * @typings {typeof Store|object}
   * @category Models & Stores
   */
  timeRangeStoreClass: TimeRangeStore
});
ProjectModel.applyConfigs = true;
ProjectModel.initClass();
ProjectModel._$name = 'ProjectModel';

/**
 * @module Calendar/data/CrudManager
 */
// noinspection JSClosureCompilerSyntax
/**
 * A Calendar-specific implementation of a `CrudManager`.
 *
 * For more information, see {@link Scheduler.data.CrudManager}.
 *
 * @typings Scheduler/data/CrudManager -> Scheduler/data/SchedulerCrudManager
 * @extends Scheduler/data/CrudManager
 */
class CrudManager extends CrudManager$1 {
  //region Config

  //endregion
  buildProjectConfig() {
    const ret = super.buildProjectConfig(),
      {
        timeRangeStore
      } = this;
    if (timeRangeStore) {
      ret.timeRangeStore = timeRangeStore;
    }
    return ret;
  }
  //region Stores
  get timeRangeStore() {
    return super.timeRangeStore;
  }
  set timeRangeStore(store) {
    var _this$project;
    if (store && ObjectHelper.isObject(store)) {
      store = ObjectHelper.assign({
        modelClass: this.timeRangeClass
      }, store);
    }
    this.setFeaturedStore('_timeRangeStore', store, (_this$project = this.project) === null || _this$project === void 0 ? void 0 : _this$project.timeRangeStoreClass);
  }
  //endregion
}
_defineProperty(CrudManager, "$name", 'CrudManager');
_defineProperty(CrudManager, "configurable", {
  projectClass: ProjectModel,
  timeRangeClass: TimeRangeModel
});
CrudManager.initClass();
CrudManager._$name = 'CrudManager';

/**
 * @module Calendar/feature/CalendarFeature
 */
/**
 * The base abstract class for Calendar features.
 *
 * @extends Core/mixin/InstancePlugin
 * @abstract
 */
class CalendarFeature extends InstancePlugin.mixin(Factoryable) {
  static get factoryable() {
    return {
      // establish this class as the Factoryable base
    };
  }
  static get configurable() {
    return {
      clientListeners: {
        paint: 'onCalendarPaint'
      },
      disableOnReadOnly: null,
      zoneTypes: null
    };
  }
  getViewZoneType(view) {
    const {
      zoneTypes
    } = this;
    let ret;
    if (zoneTypes && (ret = zoneTypes[view.type]) === undefined) {
      if (view.isWeekView && zoneTypes.week !== undefined) {
        ret = zoneTypes.week;
      } else if (view.isDayView) {
        // also covers WeekView
        ret = zoneTypes.day;
      } else if (view.isMonthView) {
        ret = zoneTypes.month;
      } else if (view.isYearView) {
        ret = zoneTypes.year;
      } else if (view.isResourceView) {
        ret = zoneTypes.resource;
      } else if (view.isAgendaView) {
        ret = zoneTypes.agenda;
      }
    }
    return ret;
  }
  updateDisableOnReadOnly(disable) {
    const me = this,
      {
        client
      } = me,
      name = 'readonlyToggle',
      handler = 'onClientReadOnlyToggle';
    if (disable) {
      me[handler]({
        readOnly: client.readOnly
      });
      client.ion({
        name,
        readOnly: handler,
        thisObj: me
      });
    } else {
      me.detachListeners(name);
    }
  }
  doDestroy() {
    this.syncModes();
    super.doDestroy();
  }
  createZone(type, config) {
    return new type(_objectSpread2({
      owner: this
    }, config));
  }
  onClientReadOnlyToggle({
    readOnly
  }) {
    this.disabled = readOnly;
  }
  updateDisabled(disabled, was) {
    super.updateDisabled(disabled, was);
    if (this.client.isPainted) {
      this.syncModes();
    }
  }
  onCalendarPaint({
    firstPaint
  }) {
    if (firstPaint) {
      this.syncModes();
    }
  }
  syncModes() {
    const me = this,
      {
        client,
        _modeDetacher,
        zones
      } = me;
    let newZones = null,
      modes,
      name,
      view,
      type,
      zone;
    // Tear down the modes when the feature is disabled... that's not worth optimizing for nor writing special
    // code in the zone helpers and since they need to be destroyable, just destroy them.
    if (me.disabled || me.isDestroying || !me.zoneTypes) {
      _modeDetacher === null || _modeDetacher === void 0 ? void 0 : _modeDetacher();
    } else {
      if (client.isCalendar) {
        if (!_modeDetacher) {
          me._modeDetacher = client.ion({
            addMode: () => me.syncModes()
          });
        }
        modes = client.modes;
      } else {
        modes = {
          view: client
        };
      }
      for (name in modes) {
        zone = zones === null || zones === void 0 ? void 0 : zones[name];
        view = modes[name];
        type = me.getViewZoneType(view);
        if (type) {
          var _zone;
          if ((ObjectHelper.isObject(zone) ? zone.type : (_zone = zone) === null || _zone === void 0 ? void 0 : _zone.constructor) === type) {
            delete zones[name]; // keep this zone around...
          } else if (view.isPainted) {
            zone = me.createZone(type, {
              view
            });
          } else {
            // Unpainted calendar views are not fully initialized, so we wait for them to paint before
            // creating the zone helper instance.
            zone = me.whenPainted(name, view, type);
          }
          (newZones || (newZones = {}))[name] = zone;
        }
      }
    }
    me.zones = newZones;
    if (zones) {
      for (name in zones) {
        zones[name].destroy();
      }
    }
  }
  whenPainted(name, view, type) {
    const me = this,
      proxy = {
        type,
        destroy: view.ion({
          once: true,
          // Must create zone first
          prio: 10000,
          paint() {
            if (me.zones[name] === proxy) {
              me.zones[name] = me.createZone(type, {
                view
              });
            }
          }
        })
      };
    return proxy;
  }
}
CalendarFeature._$name = 'CalendarFeature';

/**
 * @module Calendar/feature/CalendarZone
 */
/**
 * Base class for calendar feature helper classes that track per-mode state.
 * @internal
 */
class CalendarZone extends Base {
  updateView(view) {
    const me = this,
      listeners = view && me.viewListeners;
    me.detachListeners('viewListeners');
    // Not all views have an overflowPopup, but if they don't then they simply will never fire the event...
    listeners && (view === null || view === void 0 ? void 0 : view.ion(ObjectHelper.merge({
      thisObj: me,
      name: 'viewListeners'
    }, listeners)));
  }
}
_defineProperty(CalendarZone, "$name", 'CalendarZone');
_defineProperty(CalendarZone, "configurable", {
  /**
   * The owning feature of this zone instance.
   * @config {Calendar.feature.CalendarFeature}
   * @readonly
   */
  owner: null,
  /**
   * The associated view of this zone instance.
   * @config {Calendar.widget.mixin.CalendarMixin}
   * @readonly
   */
  view: {
    $config: 'nullify',
    value: null
  },
  /**
   * A listener config object to attach to this object's {@link #config-view}
   * @config {Object}
   */
  viewListeners: null
});
CalendarZone.initClass();
CalendarZone._$name = 'CalendarZone';

/**
 * @module Calendar/widget/EventTip
 */
const hasEventStore$3 = w => w.eventStore;
/**
 * Displays a tooltip containing extra info and options on either event click or event hover.
 *
 * See the {@link Calendar.feature.EventTooltip} feature for more information and an example of
 * customizing the displayed event tooltip.
 *
 * The EventTip is provided with two standard {@link #config-tools}:
 *
 * * `edit` - A tool which is linked to the {@link Calendar.feature.EventEdit EventEdit} feature
 * to initiate editing when clicked.
 * * `delete` - A tool which removes the current event record
 * function of the active view to enable event deletion.
 *
 * New tools may be added, or properties of existing tools may be changed by configuring the
 * {@link Calendar.feature.EventTooltip} feature:
 *
 * ```javascript
 *     features : {
 *         eventTooltip : {
 *             tools : {
 *                 // Just override handler of existing tool - all else is OK
 *                 edit : {
 *                     handler : () => console.log(`Handle editing ${this.eventRecord.name} our way`);
 *                 },
 *                 // Add a new tool for our own operation
 *                 newTool : {
 *                     cls     : 'b-icon-add',
 *                     tooltip : 'Test',
 *                     handler() {
 *                         console.log(`Test ${this.eventRecord.name}`);
 *                     }
 *                 }
 *             }
 *         }
 *     }
 * ```
 *
 * @extends Core/widget/Tooltip
 * @classType eventTooltip
 */
class EventTip extends Tooltip {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "clockTemplate", new ClockTemplate({}));
  }
  //region Config
  static get $name() {
    return 'EventTip';
  }
  static get type() {
    return 'eventtip';
  }
  static get configurable() {
    return {
      align: {
        monitorResize: true // Needed because DayView events change size
      },

      dateFormat: 'll',
      /**
       * The event which the tooltip feature has been shown for.
       * @member {Scheduler.model.EventModel} eventRecord
       * @readonly
       */
      /**
       * The event record for this tip to display
       * @config {Scheduler.model.EventModel} eventRecord
       */
      eventRecord: {
        $config: 'nullify',
        // ensure we remove our afterChange hook
        value: null
      },
      recurrenceHint: '',
      // Do not remove. Assertion strings for Localization sanity check.
      // 'L{timeFormat}'
      /**
       * A {@link Core.helper.DateHelper} format string used to format the time displayed in this tooltip.
       *
       * @config {String}
       * @default
       */
      timeFormat: 'LST',
      // Allow it to fall back from its initial alignment axis to the cross axis.
      // So if aligned l-r or r-l and shown by a long multiday event, it allows
      // itself to be fall back to being aligned t-b
      axisLock: 'flexible',
      closable: null,
      forSelector: '.b-cal-event-wrap',
      maxWidth: '30em',
      minWidth: '14em',
      scrollAction: 'realign',
      cls: {
        'b-sch-event-tooltip': 1
      },
      tools: {
        edit: {
          cls: 'b-icon-edit',
          handler: 'up.onEditClick',
          tooltip: 'L{EventEdit.Edit event}',
          weight: 100
        },
        delete: {
          cls: 'b-icon-trash',
          handler: 'up.onDeleteClick',
          tooltip: 'L{SchedulerBase.Delete event}',
          weight: 0
        },
        maximize: null
      },
      titleRenderer: eventRecord => StringHelper.encodeHtml(eventRecord.name),
      /**
       * By default, the end date of an all day event is displayed in the tooltip UI as
       * the last calendar date on which the event falls. For most end users, this is the
       * expected value.
       *
       * Technically, the {@link Scheduler.model.EventModel#field-endDate} is a timestamp
       * which represents the exact point in time at which an event ends. To use this instead,
       * configure `extendAllDayEndDay` as `true`.
       *
       * To be clear, this would mean that an {@link Scheduler.model.EventModel#field-allDay}
       * event starting and ending on the 7th of February 2020, would show the end date in the
       * tooltip as 8th of February 2020.
       * @config {Boolean}
       * @default false
       */
      extendAllDayEndDay: null,
      activeClient: null
    };
  }
  static get delayable() {
    return {
      refreshContent: 20
    };
  }
  //endregion
  get owner() {
    return Tooltip.fromElement(this.activeTarget) || this.ownerFeature.client;
  }
  onEditClick() {
    this.trigger('edit');
  }
  onDeleteClick() {
    this.trigger('delete');
  }
  getHtml(data) {
    const me = this,
      {
        eventRecord
      } = me;
    if (eventRecord) {
      data.eventRecord = eventRecord;
      me.title = me.titleRenderer ? me.callback(me.titleRenderer, me, [eventRecord]) : '';
      return me.callback(me.renderer || me.internalRenderer, me, [_objectSpread2(_objectSpread2({}, data), {}, {
        eventRecord
      })]);
    }
  }
  internalRenderer({
    eventRecord
  }) {
    const {
        clockTemplate,
        dateFormat,
        recurrenceHint,
        timeFormat
      } = this,
      {
        allDay,
        endDate,
        startDate,
        recurrence
      } = eventRecord,
      // For allDay events round eg 2020-10-18T12:00 up to 2020-10-19T00:00:00.000
      lastDay = allDay ? this.extendAllDayEndDay ? DateHelper.ceil(endDate, '1 day') : DateHelper.add(endDate, -1, 'day') : endDate,
      startMidnight = DateHelper.clearTime(startDate),
      lastMidnight = DateHelper.clearTime(lastDay),
      multiDay = startMidnight < lastMidnight,
      hasTime = !allDay && startMidnight < startDate || lastMidnight < lastDay,
      format = hasTime ? multiDay ? `${dateFormat} ${timeFormat}` : timeFormat : dateFormat,
      recurrenceLegend = recurrence ? RecurrenceLegend.getLegend(recurrence) : recurrenceHint,
      duration = DateHelper.formatDelta(DateHelper.diff(startDate, endDate), allDay ? {
        precision: 'd'
      } : null),
      onlyStartDate = eventRecord.isMilestone || allDay && !multiDay;
    clockTemplate.mode = multiDay ? 'day' : 'hour';
    return clockTemplate.template({
      date: startDate,
      text: DateHelper.format(startDate, format),
      cls: 'b-sch-tooltip-startdate'
    }) + (onlyStartDate ? '' : clockTemplate.template({
      date: lastDay,
      text: DateHelper.format(lastDay, format),
      cls: 'b-sch-tooltip-enddate'
    })) + (eventRecord.isMilestone ? '' : `<div class="b-cal-tooltip-duration b-icon b-icon-duration">${duration}</div>`) + (recurrenceLegend ? `<div class="b-cal-tooltip-recurrence b-icon b-icon-recurring">${recurrenceLegend}</div>` : '');
  }
  showByEvent(event, element = event.target) {
    const me = this;
    me.activeTarget = element;
    me.pointerEvent = event;
    me.updateContent();
    if (event.type === 'contextmenu') {
      return me.showBy({
        position: {
          x: event.clientX,
          y: event.clientY
        },
        anchor: false
      });
    }
    return me.showBy(element);
  }
  afterShowByTarget() {
    var _Tooltip$fromElement;
    const {
      delete: deleteTool
    } = this.tools;
    // Capture the active client only when we are visible.
    this.activeClient = (_Tooltip$fromElement = Tooltip.fromElement(this.activeTarget)) === null || _Tooltip$fromElement === void 0 ? void 0 : _Tooltip$fromElement.closest(hasEventStore$3);
    super.afterShowByTarget();
    // The delete tool is disabled if the Calendar is readOnly
    deleteTool && (deleteTool.disabled = this.ownerFeature.client.readOnly);
  }
  afterHide() {
    super.afterHide(...arguments);
    this.activeClient = null;
  }
  updateActiveTarget(element, was) {
    super.updateActiveTarget(...arguments);
    was === null || was === void 0 ? void 0 : was.classList.remove('b-cal-event-reveal');
    // The activating event element is lifted to the top of the z-index stack while
    // it is the target of the tooltip.
    if (element !== null && element !== void 0 && element.classList.contains('b-cal-in-cluster')) {
      element.classList.add('b-cal-event-reveal');
    }
  }
  refreshContent() {
    // this method is just a buffered wrapper of updateContent
    this.updateContent();
  }
  updateEventRecord(eventRecord) {
    var _me$_changeHook;
    const me = this;
    (_me$_changeHook = me._changeHook) === null || _me$_changeHook === void 0 ? void 0 : _me$_changeHook.call(me);
    me._changeHook = eventRecord && FunctionHelper.after(eventRecord, 'afterChange', me.refreshContent, me);
    if (eventRecord) {
      if (me.tools.delete) {
        me.tools.delete.hidden = eventRecord.readOnly;
      }
      if (me.tools.edit) {
        me.tools.edit.hidden = eventRecord.readOnly;
      }
      me.updateContent();
    }
  }
  updateContent() {
    const {
        clockTemplate,
        element,
        eventRecord
      } = this,
      result = super.updateContent(),
      startElement = element.querySelector('.b-sch-tooltip-startdate'),
      endElement = element.querySelector('.b-sch-tooltip-enddate'),
      {
        edit,
        delete: del
      } = this.tools,
      {
        client
      } = this.ownerFeature,
      {
        eventEdit
      } = client.features,
      readOnly = client.readOnly || eventRecord.readOnly;
    startElement && clockTemplate.updateDateIndicator(startElement, eventRecord.startDate);
    endElement && clockTemplate.updateDateIndicator(endElement, eventRecord.endDate);
    // Hide the edit tool if the Calendar or event is readOnly or there is no editFeature or it's disabled
    edit && (edit.hidden = readOnly || !(eventEdit !== null && eventEdit !== void 0 && eventEdit.enabled));
    // Hide delete tool if the Calendar or event is readOnly
    del && (del.hidden = readOnly);
    return result;
  }
  updateActiveClient(activeClient) {
    this.detachListeners('clientOverflowChange');
    // We may have to hide when the active client changes its possible overflow threshold
    if (activeClient) {
      activeClient.ion({
        name: 'clientOverflowChange',
        eventsPerCellChange: 'onClientOverflowChange',
        thisObj: this
      });
    }
  }
  onClientOverflowChange() {
    // If that caused the target to no longer be visible, we must hide.
    // For example aligned to an event which is now in overflow.
    // Or aligned to an event in the overflow popup which has now hidden.
    if (!DomHelper.isVisible(this.lastAlignSpec.target)) {
      this.hide();
    }
  }
  onDocumentMouseDown({
    event
  }) {
    // Ignore mousedown on active element if we show on a click.
    if (!event.button && this.ownerFeature.showOn === 'click' && this.activeTarget.contains(event.target)) {
      return;
    }
    return super.onDocumentMouseDown(...arguments);
  }
}
// Register this feature type with its Factory
EventTip.initClass();
EventTip._$name = 'EventTip';

/**
 * @module Calendar/feature/CalendarDrag
 */
/**
 * An immutable object that describes a calendar drag mode. These objects are used to simplify detecting the drag mode
 * to apply appropriate actions.
 *
 * @typedef {Object} CalendarDragMode
 * @property {'create'|'move'|'resize'} type The value `'create'`, `'move'`, or `'resize'`.
 * @property {Boolean} create The value `true` if `type === 'create'`, otherwise `false`.
 * @property {Boolean} move The value `true` if `type === 'move'`, otherwise `false`.
 * @property {Boolean} resize The value `true` if `type === 'resize'`, otherwise `false`.
 */
const tentativeCls = 'b-cal-tentative-event',
  SECONDS = 1000,
  MINUTES = 60 * SECONDS,
  YYYY_MM_DD = 'YYYY-MM-DD',
  edgeRe = /^b-hover-(top|right|bottom|left)$/,
  eventDragSym = Symbol('eventDragMode'),
  appendEventFooter = (domConfig, footer) => {
    let ret;
    if (domConfig.className === 'b-cal-event-body') {
      domConfig.children.push(ret = footer);
    } else if (Array.isArray(domConfig.children)) {
      // TODO support children: {ref: config} form as needed
      domConfig.children.forEach(c => {
        if (!ret && c) {
          ret = appendEventFooter(c, footer);
        }
      });
    }
    return ret;
  },
  makeMode = type => Object.freeze({
    type,
    create: false,
    move: false,
    resize: false,
    [type]: true
  }),
  modeDescriptor = {
    create: {
      finisher: 'finishDropCreate',
      mode: makeMode('create'),
      validatorFn: 'validateCreateFn'
    },
    move: {
      finisher: 'finishDropMove',
      mode: makeMode('move'),
      validatorFn: 'validateMoveFn'
    },
    resize: {
      finisher: 'finishDropResize',
      mode: makeMode('resize'),
      validatorFn: 'validateResizeFn'
    }
  },
  isAllDayView = {
    calendarrow: true,
    monthview: true
  };
/*
 Base class for all zones, however, not all zones support all capabilities. DayView and WeekView are all of these
 things. Their events can be dragged between days, resized to change times of day, and an event can be dropped on
 to the calendar cells. While the YearView does not have events presented for dragging and so is not actually
 draggable, it is droppable since an event can be dropped on a day cell. MonthView is draggable and droppable,
 however, it is not hoverable since its events cannot be "resized". Finally, events in the OverflowPopup can only
 be dragged.
 */
class Zone extends CalendarZone.mixin(Draggable, Droppable, Hoverable) {
  static get $name() {
    return 'Zone';
  }
  static get configurable() {
    return {
      // We limit dropping to all *children* of the Droppable, not the Droppable element itself.
      // So that we avoid triggering "over" or "drop" on borders which would give incorrect
      // positional calculations.
      droppableSelector: '*',
      droppable: true,
      hoverable: null,
      hoverAnimationCls: 'b-hover-anim',
      days: {
        $config: {
          equal: 'array'
        },
        value: null
      },
      dragProxy: {
        type: 'tip',
        tooltip: null // borrowed from the Feature instance's tooltip config
      },

      eventRecord: null,
      hit: null,
      dragItemSelector: '.b-cal-event-wrap',
      overflow: {
        $config: 'nullify',
        value: null
      },
      rootElement: null
    };
  }
  get dayTime() {
    var _this$view;
    return (_this$view = this.view) === null || _this$view === void 0 ? void 0 : _this$view.dayTime;
  }
  clearTime(date) {
    return this.dayTime.startOfDay(date);
  }
  findRootElement(view) {
    return view.contentElement;
  }
  getDateFromPosition(clientX, clientY) {
    return this.view.getDateFromPosition(clientX, clientY);
  }
  // Draggable behaviors
  get dragEventer() {
    return this.owner;
  }
  beforeDrag(drag) {
    const me = this,
      {
        owner
      } = me,
      hit = me.hitTest(drag),
      eventRecord = hit === null || hit === void 0 ? void 0 : hit.eventRecord,
      insetProp = me.view.rtl ? 'right' : 'left';
    if (!hit || eventRecord !== null && eventRecord !== void 0 && eventRecord.readOnly || eventRecord !== null && eventRecord !== void 0 && eventRecord.isCreating) {
      return false;
    }
    if (hit.date) {
      drag.set('date', hit.date);
    }
    let mode, veto;
    switch (hit.type) {
      case 'event':
        drag.set('eventRecord', eventRecord);
        drag.set('eventSourceHit', hit);
        drag.set('eventInset', hit.eventElement.style[insetProp]);
        drag.set('eventWidth', hit.eventElement.offsetWidth);
        mode = 'move';
        veto = !owner.draggable || !eventRecord.isDraggable;
        if (!veto) {
          me.captureDragOffset(eventRecord, hit, drag);
        }
        break;
      case 'resize':
        drag.set('eventRecord', eventRecord);
        drag.set('eventSourceHit', hit);
        drag.set('eventInset', hit.eventWrap.style[insetProp]);
        drag.set('eventWidth', hit.eventWrap.offsetWidth);
        mode = 'resize';
        veto = !owner.resizable || !eventRecord.resizable;
        break;
      case 'schedule':
      case 'dayNumber':
        drag.set('eventCreate', hit);
        mode = 'create';
        veto = !owner.creatable;
        break;
      default:
        return false;
    }
    if (veto) {
      return false;
    }
    drag.set('eventDragMode', drag[eventDragSym] = modeDescriptor[mode].mode);
  }
  dragStart() {
    var _client$scrollManager;
    const me = this,
      {
        dragging: drag,
        owner,
        view
      } = me,
      {
        client
      } = owner,
      callback = () => {
        drag.lastMoveEvent && drag.move(drag.lastMoveEvent);
      },
      config = {
        scrollables: client.scrollManager ? [{
          element: client.viewContainer.element,
          callback
        }] : []
      };
    // NOTE: Adding b-resizing kicks in display:none which focuses the <body>, so capture it first:
    if (me.isResizing || me.isMoving) {
      me.refocus = owner.client.captureFocus();
    }
    if (me.isResizing) {
      var _drag$itemElement;
      (_drag$itemElement = drag.itemElement) === null || _drag$itemElement === void 0 ? void 0 : _drag$itemElement.classList.add('b-resizing');
    }
    if (view.scrollable) {
      config.scrollables.push({
        element: view.scrollable.element,
        callback
      });
    }
    // DayViews may have an extra scroller
    if (view.horizontalScroller) {
      config.scrollables.push({
        element: view.horizontalScroller.element,
        callback
      });
    }
    (_client$scrollManager = client.scrollManager) === null || _client$scrollManager === void 0 ? void 0 : _client$scrollManager.startMonitoring(config);
  }
  captureDragOffset() {
    // empty by default
  }
  cleanupDrag() {
    var _dragging$itemElement;
    const me = this,
      {
        dragProxy,
        dragging
      } = me,
      {
        tooltip
      } = dragProxy,
      view = me.view.isOverflowPopup ? me.view.owner : me.view;
    dragging === null || dragging === void 0 ? void 0 : (_dragging$itemElement = dragging.itemElement) === null || _dragging$itemElement === void 0 ? void 0 : _dragging$itemElement.classList.remove('b-resizing');
    // Do not refocus immediately. The UI will not be in its new state.
    // Refocus after the impending refresh.
    view.ion({
      refresh() {
        var _me$refocus;
        // Try to refocus element without scrolling. In case we scrolled the view while dragging the event.
        (_me$refocus = me.refocus) === null || _me$refocus === void 0 ? void 0 : _me$refocus.call(me, false, true);
        me.refocus = null;
      },
      once: true
    });
    me.days = null; // day view resize uses days/times as drag feedback
    if (tooltip) {
      tooltip.hide();
      dragProxy.tooltip = null;
    }
  }
  dragEnd() {
    var _this$owner$client, _this$owner$client$sc;
    (_this$owner$client = this.owner.client) === null || _this$owner$client === void 0 ? void 0 : (_this$owner$client$sc = _this$owner$client.scrollManager) === null || _this$owner$client$sc === void 0 ? void 0 : _this$owner$client$sc.stopMonitoring();
    this.cleanupDrag();
  }
  makeDays(startDate, endDate) {
    const {
        dayTime,
        startDate: minDate,
        endDate: maxDate
      } = this.view,
      days = [];
    startDate = DateHelper.constrain(startDate, minDate, maxDate);
    endDate = DateHelper.constrain(endDate, minDate, maxDate);
    let date = dayTime.startOfDay(startDate);
    // We do ceil(endDate) to handle events that start/end on the same day
    for (const end = dayTime.ceil(endDate); date < end; date = DateHelper.add(date, 1, 'day')) {
      days.push(dayTime.dateKey(date));
    }
    return days;
  }
  onShowOverflowPopup({
    overflowPopup
  }) {
    if (!this.overflow) {
      this.overflow = new OverflowZone({
        owner: this.owner,
        view: overflowPopup
      });
    }
  }
  // Droppable behaviors
  get calendarCellSelector() {
    const {
      hideNonWorkingDays
    } = this.view;
    return `${this.view.visibleCellSelector}${hideNonWorkingDays ? ':not(.b-nonworking-day)' : ''}`;
  }
  get calendarCells() {
    const container = this.dropRootElement;
    return container && DomHelper.children(container, this.calendarCellSelector);
  }
  get isCreating() {
    var _this$dropping, _this$dropping$eventD;
    return (_this$dropping = this.dropping) === null || _this$dropping === void 0 ? void 0 : (_this$dropping$eventD = _this$dropping[eventDragSym]) === null || _this$dropping$eventD === void 0 ? void 0 : _this$dropping$eventD.create;
  }
  get isMoving() {
    var _this$dropping2, _this$dragging, _this$dropping3;
    const mode = ((_this$dropping2 = this.dropping) === null || _this$dropping2 === void 0 ? void 0 : _this$dropping2[eventDragSym]) || ((_this$dragging = this.dragging) === null || _this$dragging === void 0 ? void 0 : _this$dragging[eventDragSym]);
    return mode ? mode.move : Boolean((_this$dropping3 = this.dropping) === null || _this$dropping3 === void 0 ? void 0 : _this$dropping3.peek('eventRecord'));
  }
  get isResizing() {
    var _this$dragging2, _this$dragging2$event;
    return (_this$dragging2 = this.dragging) === null || _this$dragging2 === void 0 ? void 0 : (_this$dragging2$event = _this$dragging2[eventDragSym]) === null || _this$dragging2$event === void 0 ? void 0 : _this$dragging2$event.resize;
  }
  get recurrable() {
    return this.isDayZone || this.isMonthZone;
  }
  cleanupDrop() {
    this.eventRecord = this.eventDom = this.days = null;
    this.noTip = false;
  }
  createEvent(data) {
    var _this$dropping4;
    // We can get here for an AllDay zone when the day detail zone is creating a multi-day event, but that's the
    // only time we won't be processing our own drop.
    const mode = ((_this$dropping4 = this.dropping) === null || _this$dropping4 === void 0 ? void 0 : _this$dropping4[eventDragSym]) || modeDescriptor.create;
    this.setupEvent(data, mode.create);
  }
  async dragDrop(drag) {
    if (this.isResizing || drag.target === this) {
      // finalizer is a Promise that the DragContext (which is a Finalizable) awaits in its finalize() method.
      return drag.finalizer = this.finishDrop(drag);
    }
  }
  dragEnter(drag) {
    const me = this,
      mode = drag[eventDragSym];
    if (me.isMoving) {
      me.startMove(drag.peek('eventRecord'));
    } else if (!mode || drag.source !== me) {
      return false;
    } else if (mode.resize) {
      me.startResize(drag.peek('eventSourceHit'));
    } else if (mode.create) {
      me.startCreate(drag.peek('date'), drag.peek('eventCreate'));
    } else {
      return false;
    }
  }
  dragLeave() {
    if (!this.isResizing) {
      this.cleanupDrop();
    }
  }
  dragMove(drag) {
    this.hit = this.pickDropTarget(drag);
  }
  dropHitMove(drag, hit, eventRecord) {
    const me = this,
      {
        endDate,
        startDate
      } = eventRecord.isScheduled ? eventRecord : me.eventRecord,
      durationSec = DateHelper.diff(startDate, endDate, 's');
    let {
      date
    } = hit;
    date = me.clearTime(date);
    if (!eventRecord.allDay) {
      date = DateHelper.add(date, DateHelper.diff(me.clearTime(startDate), startDate, 's'), 's');
    }
    date = me.applyDragOffset(date, drag);
    me.setEventData({
      startDate: date,
      endDate: DateHelper.add(date, durationSec, 's')
    });
  }
  dropHitNowhere() {
    this.days = null;
  }
  dropHitResize(drag, hit, eventHit) {
    const me = this,
      {
        eventRecord
      } = me,
      {
        startDate,
        endDate
      } = eventRecord,
      date = me.clearTime(hit.date);
    let changes, end;
    if (eventHit.atEnd) {
      end = DateHelper.add(date, 1, 'd');
      changes = {
        startDate,
        endDate: startDate < end ? end : DateHelper.add(startDate, 1, 'd')
      };
    } else {
      changes = {
        startDate: date < endDate ? date : DateHelper.add(endDate, -1, 'd'),
        endDate
      };
    }
    changes.duration = DateHelper.diff(changes.startDate, changes.endDate, eventRecord.durationUnit);
    me.setEventData(changes);
  }
  async finishDrop(drag) {
    const me = this,
      {
        eventRecord,
        owner,
        view
      } = me,
      {
        eventStore
      } = view,
      mode = drag[eventDragSym],
      descriptor = modeDescriptor[(mode === null || mode === void 0 ? void 0 : mode.type) || 'move'];
    if (descriptor && me.hit) {
      const validation = descriptor.validatorFn ? await owner.callback(owner[descriptor.validatorFn], owner, [{
        drag,
        eventRecord,
        event: drag.event
      }]) : true;
      if (validation !== false) {
        await me[descriptor.finisher](drag, owner, eventRecord, eventStore, validation, async eventName => {
          let info = {
            drag,
            eventRecord,
            validation,
            event: drag.event,
            feature: owner,
            view: drag[me.isResizing ? 'source' : 'target'].view
          };
          // First trigger a preventable beforeXXX event to allow outside world to veto this operation
          const result = await owner.client.trigger('before' + StringHelper.capitalize(eventName), info);
          if (result === false) {
            info = false;
          } else {
            owner.client.trigger(eventName, info);
          }
          // return the event info object to allow event handlers to return data by poking on to that
          // object.
          return info;
        });
      }
    }
    me.cleanupDrop();
  }
  async finishDropCreate(drag, owner, eventRecord, eventStore, validation, triggerFn) {
    const add = (validation === null || validation === void 0 ? void 0 : validation.add) !== false;
    /**
     * This event fires on the owning Calendar before a drag creation gesture is completed. Return `false` to
     * immediately veto the operation or a Promise yielding `true` or `false` for async vetoing.
     * @event beforeDragCreateEnd
     * @preventable
     * @on-owner
     * @async
     * @param {Calendar.view.Calendar} source The Calendar instance that fired the event.
     * @param {Core.util.drag.DragContext} drag The drag create context.
     * @param {Event} event The browser event.
     * @param {Scheduler.model.EventModel} eventRecord The new `EventModel` record.
     * @param {Calendar.feature.CalendarDrag} feature The Calendar drag feature instance.
     * @param {Boolean|ValidateCreateResult} validation The result of the {@link #config-validateCreateFn} if one
     * was provided.
     * @param {Core.widget.Widget} view The Calendar widget in which the drag completed.
     */
    /**
     * This event fires on the owning Calendar when a drag creation gesture is completed.
     * @event dragCreateEnd
     * @on-owner
     * @param {Calendar.view.Calendar} source The Calendar instance that fired the event.
     * @param {Core.util.drag.DragContext} drag The drag create context.
     * @param {Event} event The browser event.
     * @param {Scheduler.model.EventModel} eventRecord The new `EventModel` record.
     * @param {Calendar.feature.CalendarDrag} feature The Calendar drag feature instance.
     * @param {Boolean|ValidateCreateResult} validation The result of the {@link #config-validateCreateFn} if one
     * was provided.
     * @param {Core.widget.Widget} view The Calendar widget in which the drag completed.
     */
    // If any handler was async, the promise will be returned.
    // If not presented with a Promise, await yields the immediate value.
    const result = await triggerFn('dragCreateEnd');
    if (result === false) {
      if (add) {
        eventStore.remove(eventRecord);
      }
    } else if (add && !eventStore.includes(eventRecord)) {
      eventStore.add(eventRecord);
    }
  }
  async finishDropMove(drag, owner, eventRecord, eventStore, validation, triggerFn) {
    let dropRec = await drag.get('eventRecord');
    const me = this,
      {
        view
      } = me,
      storeRec = dropRec.isOccurrence ? dropRec.recurringTimeSpan : dropRec,
      {
        source
      } = drag,
      interView = source !== me,
      isReassign = interView && source.resource !== me.resource;
    // Return if we detect that it's a no-op.
    if (!isReassign && drag.source === drag.target && DateHelper.isEqual(eventRecord.startDate, dropRec.startDate) && DateHelper.isEqual(eventRecord.endDate, dropRec.endDate)) {
      if (dropRec.eventStore === eventStore) {
        return;
      }
    }
    /**
     * This event fires on the owning Calendar before a drag move gesture is completed. Return `false` to immediately veto the operation
     * or a Promise yielding `true` or `false` for async vetoing.
     * @event beforeDragMoveEnd
     * @preventable
     * @on-owner
     * @async
     * @param {Calendar.view.Calendar} source The Calendar instance that fired the event.
     * @param {Core.util.drag.DragContext} drag The drag create context.
     * @param {Event} event The browser event.
     * @param {Scheduler.model.EventModel} eventRecord The new `EventModel` record.
     * @param {Calendar.feature.CalendarDrag} feature The Calendar drag feature instance.
     * @param {Boolean|ValidateCreateResult} validation The result of the {@link #config-validateMoveFn} if one was
     * provided.
     * @param {Core.widget.Widget} view The Calendar widget in which the drag completed.
     */
    /**
     * This event fires on the owning Calendar when a drag move gesture is completed. The `eventRecord` has already been added
     * to the `eventStore` of the owning calendar.
     * @event dragMoveEnd
     * @on-owner
     * @param {Calendar.view.Calendar} source The Calendar instance that fired the event.
     * @param {Core.util.drag.DragContext} drag The drag create context.
     * @param {Event} event The browser event.
     * @param {Scheduler.model.EventModel} eventRecord The new `EventModel` record.
     * @param {Calendar.feature.CalendarDrag} feature The Calendar drag feature instance.
     * @param {Boolean|ValidateCreateResult} validation The result of the {@link #config-validateMoveFn} if one was
     * provided.
     * @param {Core.widget.Widget} view The Calendar widget in which the drag completed.
     */
    const result = await triggerFn('dragMoveEnd');
    if (result === false) {
      return;
    }
    // It's a drag from an external EventStore.
    // If a handler sets isCopy in the data, we add the
    // tentative event as a copy of the original.
    if (!eventStore.getByInternalId(storeRec.internalId)) {
      var _ref, _dropRec$resourceId;
      // If the Draggable has provided us with a sourceStore, it indicates that
      // they would like the record to be removed on successful drop.
      const sourceStore = await drag.get('sourceStore');
      if (sourceStore) {
        // Remove from the source store
        sourceStore.remove(dropRec);
        // Move to the dropped at date and time
        await me.moveEventTo(drag, dropRec);
      } else {
        // Use the tentative event which is being used as the drop indicator.
        // As long as it has a duration, its start and end will be correct.
        dropRec = eventRecord;
      }
      const resource = (_ref = (_dropRec$resourceId = dropRec.resourceId) !== null && _dropRec$resourceId !== void 0 ? _dropRec$resourceId : me.resource) !== null && _ref !== void 0 ? _ref : this.owner.client.defaultCalendarId;
      delete dropRec.resourceId;
      eventStore.add(dropRec);
      dropRec.assign(isReassign ? me.resource : resource);
    } else {
      // Await any decision on converting recurring base/occurrence
      // to an exception of a new recurring base.
      dropRec = await me.finishDropConfirm(dropRec);
      if (dropRec) {
        await me.moveEventTo(drag, dropRec);
        // If dragging between zones, and the zones have been configured with specific, different
        // resources, then this drag is also a reallocation of resource.
        if (isReassign) {
          // Assign to new resource first, so that it never drops to zero assignments
          // because that can cause the eventRecord to exit the Project.
          dropRec.assign(me.resource);
          dropRec.unassign(source.resource);
        }
        // Dragging between different views, ensure dropped event is focused
        if (interView && me.owner.client.activeView.eachView) {
          var _view$getEventElement;
          view.refresh();
          (_view$getEventElement = view.getEventElement(dropRec, dropRec.startDate)) === null || _view$getEventElement === void 0 ? void 0 : _view$getEventElement.focus();
        }
      }
    }
  }
  async finishDropResize(drag, owner, eventRecord, eventStore, validation, triggerFn) {
    /**
     * This event fires on the owning Calendar before a drag resize gesture is completed. Return `false` to immediately veto the operation
     * or a Promise yielding `true` or `false` for async vetoing.
     * @event beforeDragResizeEnd
     * @preventable
     * @on-owner
     * @async
     * @param {Calendar.view.Calendar} source The Calendar instance that fired the event.
     * @param {Core.util.drag.DragContext} drag The drag create context.
     * @param {Event} event The browser event.
     * @param {Scheduler.model.EventModel} eventRecord The new `EventModel` record.
     * @param {Calendar.feature.CalendarDrag} feature The Calendar drag feature instance.
     * @param {Boolean|ValidateCreateResult} validation The result of the {@link #config-validateResizeFn} if one
     * was provided.
     * @param {Core.widget.Widget} view The Calendar widget in which the drag completed.
     */
    /**
     * This event fires on the owning Calendar when a drag resize gesture is completed.
     * @event dragResizeEnd
     * @on-owner
     * @param {Calendar.view.Calendar} source The Calendar instance that fired the event.
     * @param {Core.util.drag.DragContext} drag The drag create context.
     * @param {Event} event The browser event.
     * @param {Scheduler.model.EventModel} eventRecord The new `EventModel` record.
     * @param {Calendar.feature.CalendarDrag} feature The Calendar drag feature instance.
     * @param {Boolean|ValidateCreateResult} validation The result of the {@link #config-validateResizeFn} if one
     * was provided.
     * @param {Core.widget.Widget} view The Calendar widget in which the drag completed.
     */
    const result = await triggerFn('dragResizeEnd');
    if (result === false) {
      return;
    }
    let {
      eventRecord: editRec
    } = await drag.get('eventSourceHit');
    editRec = await this.finishDropConfirm(editRec);
    editRec && editRec.set({
      startDate: eventRecord.startDate,
      endDate: eventRecord.endDate,
      duration: DateHelper.diff(eventRecord.startDate, eventRecord.endDate, editRec.durationUnit)
    });
  }
  async finishDropConfirm(eventRecord) {
    if (eventRecord.isOccurrence || eventRecord.isRecurring) {
      return new Promise(resolve => {
        const dialog = new RecurrenceConfirmationPopup({
          owner: this.owner
        });
        dialog.confirm({
          actionType: 'update',
          eventRecord,
          cancelFn() {
            resolve(null);
          },
          changerFn(eventRec) {
            resolve(eventRec);
          }
        });
      });
    }
    return eventRecord;
  }
  async moveEventTo(drag, eventRecord) {
    const me = this;
    let date = me.view.getDateFromElement(drag.targetElement);
    // If we were not dragging an unscheduled event (for example from an external source)
    // then copy in its time values.
    if (eventRecord.startDate) {
      date = DateHelper.copyTimeValues(me.clearTime(date), eventRecord.startDate);
    }
    date = me.applyDragOffset(date, drag);
    // If it's being movedTo from another store, and it was unscheduled originally...
    if (!me.view.eventStore.getByInternalId(eventRecord.internalId) && !eventRecord.startDate) {
      const autoCreate = drag.target.view.autoCreate || me.owner.client.autoCreate;
      // Move to the autoCreate time if we can find an autoCreate config to give us a hint.
      date.setHours((autoCreate === null || autoCreate === void 0 ? void 0 : autoCreate.startHour) || 8);
    }
    await me.setStartDate(eventRecord, date);
  }
  pickDropTarget(drag) {
    var _hit;
    const me = this;
    let hit = me.hitTest(drag);
    if (!hit && me.isResizing) {
      hit = me.hit;
    }
    return (_hit = hit) !== null && _hit !== void 0 && _hit.date ? hit : null;
  }
  setStartDate(eventRecord, date) {
    return eventRecord.set({
      startDate: date,
      endDate: DateHelper.add(date, this.eventRecord.duration, this.eventRecord.durationUnit)
    });
  }
  // Hoverable
  getHoverHandleCls(other) {
    return other ? '' : 'b-gripper-vert';
  }
  hoverEnter() {
    var _hit$eventRecord, _hit$eventRecord2;
    const me = this,
      hit = me.hitTest(me.hoverTarget),
      {
        gripper
      } = me.owner,
      cls = me.getHoverHandleCls(),
      otherCls = me.getHoverHandleCls(true);
    otherCls && gripper.classList.remove(otherCls);
    if ((hit === null || hit === void 0 ? void 0 : (_hit$eventRecord = hit.eventRecord) === null || _hit$eventRecord === void 0 ? void 0 : _hit$eventRecord.resizable) !== false && !(hit !== null && hit !== void 0 && (_hit$eventRecord2 = hit.eventRecord) !== null && _hit$eventRecord2 !== void 0 && _hit$eventRecord2.readOnly)) {
      cls && gripper.classList.add(cls);
      me.hoverTarget.appendChild(gripper);
    }
  }
  hoverLeave(leaving) {
    const me = this,
      {
        gripper
      } = me.owner,
      cls = me.getHoverHandleCls();
    // We may have 2 hoverable zones each grabbing our shared gripper element, so check if we are the current
    // owner and only cleanup if we are:
    if (gripper.parentNode === leaving) {
      cls && gripper.classList.remove(cls);
      leaving.removeChild(gripper);
    }
  }
  // Misc
  applyDragOffset(date, drag) {
    const eventOffset = drag.peek('eventOffset');
    if (date && eventOffset !== null && eventOffset !== void 0 && eventOffset[0]) {
      var _drag$target;
      if (drag.source.constructor === ((_drag$target = drag.target) === null || _drag$target === void 0 ? void 0 : _drag$target.constructor)) {
        date = DateHelper.add(date, -eventOffset[0], eventOffset[1]);
      }
    }
    return date;
  }
  hitTest(at) {
    const me = this,
      isDragContext = at === null || at === void 0 ? void 0 : at.isDragContext,
      event = isDragContext ? at.event : at,
      target = isDragContext && at.targetElement || DomHelper.getEventElement(event);
    let src = me.view,
      hit = null,
      edge,
      wrapEl;
    if (target) {
      if (!src.calendarHitTest) {
        src = me.owner.client;
      }
      const horizontalStartEdge = src.rtl ? 'right' : 'left';
      hit = src.calendarHitTest(target);
      if (hit) {
        hit.eventWrap = wrapEl = target.closest('.b-cal-event-wrap');
        if (target.classList.contains('b-gripper')) {
          hit = {
            type: 'resize',
            cell: hit.cell,
            date: hit.date,
            edge: edge = {},
            eventRecord: hit.eventRecord,
            eventWrap: wrapEl,
            gripper: target,
            view: hit.view
          };
          DomClassList.normalize(wrapEl.className, 'array').forEach(c => {
            c = edgeRe.exec(c);
            c && (edge[c[1]] = true);
          });
          hit.atEnd = !(edge.top || edge[horizontalStartEdge]);
        } else if (!hit.eventRecord) {
          wrapEl = null;
        }
        if (wrapEl) {
          hit.eventTop = wrapEl.style.top;
        }
        if (target !== event) {
          hit.date = me.getDateFromPosition(event.clientX, event.clientY) || hit.date;
        }
      }
    }
    return hit;
  }
  renderEvent(eventRecord, first, last) {
    const {
      view
    } = this;
    // Make the DOM reflect the view's defaultCalendar.
    // We cannot assign in the normal way when the event is not part of a project
    // so we need to override the resource property just while we create the DOM.
    Object.defineProperty(eventRecord, 'resource', {
      configurable: true,
      get: () => view.defaultCalendar
    });
    // If we are moving into a view which only renders interday events
    // Set the cell info block's isAllDay flag.
    const dom = view.createEventDomConfig({
      eventRecord,
      isAllDay: isAllDayView[view.type]
    });
    dom.className['b-cal-tentative-event'] = 1;
    dom.className['b-cal-tentative-event-first'] = first;
    dom.className['b-cal-tentative-event-last'] = last;
    // Remove resource property
    delete eventRecord.resource;
    if (last) {
      const {
        footer
      } = this.owner;
      if (footer) {
        appendEventFooter(dom, ObjectHelper.assign({
          html: DateHelper.format(eventRecord.endDate, view.timeFormat)
        }, footer));
      }
    }
    return dom;
  }
  setEventData(data, creating) {
    const me = this,
      {
        eventRecord,
        view
      } = me,
      {
        duration,
        startDate
      } = data;
    if (startDate && duration != null && !data.endDate) {
      data = _objectSpread2(_objectSpread2({}, data), {}, {
        endDate: DateHelper.add(startDate, duration, eventRecord.durationUnit)
      });
    }
    eventRecord.set(data);
    // Honour the view's view on what constitutes a short event
    if (me.eventDom) {
      me.eventDom.className[view.shortEventCls] = eventRecord.durationMS <= view.shortEventDuration;
    } else {
      if (creating) {
        let {
          newName
        } = me.owner;
        if (typeof newName === 'function') {
          newName = newName(eventRecord);
        }
        eventRecord.set('name', newName);
      }
      me.eventDom = me.renderEvent(eventRecord);
    }
  }
  setupEvent(data, creating) {
    var _me$dragging;
    const me = this,
      {
        owner
      } = me,
      {
        defaultCalendar,
        eventStore
      } = me.view,
      {
        tooltip
      } = owner,
      eventRecord = me.eventRecord = owner.eventRecord = eventStore.createRecord({
        // must pass empty object for CalendarStores hook of createRecord() to set resourceId
        // and because the data passed is field *names*, not dataSources
      }),
      assigned = creating ? new Set([new eventStore.assignmentStore.modelClass({
        event: eventRecord,
        resource: defaultCalendar
      })]) : data.assigned;
    // Just set the assigned Set while we create the DOM so that it has all assignment info.
    Object.defineProperty(eventRecord, 'assigned', {
      configurable: true,
      get: () => assigned
    });
    me.setEventData(data, creating);
    delete eventRecord.assigned;
    // Assign the new event to the EventStore's default calendar
    if (me.isCreating && defaultCalendar) {
      eventStore.assignmentStore.assignEventToResource(eventRecord, defaultCalendar);
    }
    const {
      eventDom
    } = me;
    eventDom.className[tentativeCls] = 1;
    if (!me.noTip && !tooltip.disabled && (_me$dragging = me.dragging) !== null && _me$dragging !== void 0 && _me$dragging.has('eventCreate')) {
      tooltip.eventRecord = eventRecord;
      tooltip.recurrenceHint = creating && me.recurrable ? owner.recurrenceTip : '';
      me.dragProxy.tooltip = tooltip;
    }
    return eventDom;
  }
  startCreate(date) {
    this.createEvent({
      allDay: true,
      startDate: date,
      endDate: DateHelper.add(date, 1, 'd')
    });
  }
  startMove(eventRecord) {
    var _eventRecord$resource;
    const me = this,
      data = ObjectHelper.clone(eventRecord.data),
      color = (_eventRecord$resource = eventRecord.resource) === null || _eventRecord$resource === void 0 ? void 0 : _eventRecord$resource.eventColor;
    // Pass along resources color as eventColor during drag
    if (!data.eventColor && color) {
      data.eventColor = color;
    }
    // Include the Set of assignments in the data for the tentative event
    data.assigned = eventRecord.assigned;
    // If an unscheduled event is grabbed (for example from an external source),
    // we have to normalize it according to current pointer context in order
    // for the view's createEventDomConfig to be able to process it to create
    // our drop indicator.
    if (!data.startDate) {
      const hit = me.pickDropTarget(me.dropping);
      data.startDate = (hit === null || hit === void 0 ? void 0 : hit.date) || new Date();
      data.endDate = DateHelper.add(data.startDate, eventRecord.duration || 1, eventRecord.durationUnit || 'h');
    }
    if (!data.resourceId) {
      var _me$owner$client;
      data.resourceId = me.dropping.peek('resourceId') || ((_me$owner$client = me.owner.client) === null || _me$owner$client === void 0 ? void 0 : _me$owner$client.defaultCalendarId);
    }
    // So as not to have duplicate data-event-id="eventId" nodes in the DOM.
    delete data.id;
    me.setupEvent(data);
  }
  startResize(eventHit) {
    var _eventRecord$resource2;
    const {
        eventRecord
      } = eventHit,
      data = eventRecord.data;
    this.createEvent(_objectSpread2(_objectSpread2({}, data), {}, {
      id: `dragResize-event-${data.id}`,
      eventColor: data.eventColor || ((_eventRecord$resource2 = eventRecord.resource) === null || _eventRecord$resource2 === void 0 ? void 0 : _eventRecord$resource2.eventColor),
      recurrenceRule: null,
      realEventId: data.id
    }));
  }
  // Configs
  configureListeners(drag) {
    const listeners = super.configureListeners(drag);
    // Listen to the events on the root element
    listeners.element = this.view.rootElement;
    return listeners;
  }
  updateHit(hit) {
    const me = this,
      drag = me.dropping,
      mode = hit && drag[eventDragSym];
    if (hit) {
      if (me.isMoving) {
        me.dropHitMove(drag, hit, drag.peek('eventRecord'));
      } else if (mode !== null && mode !== void 0 && mode.create) {
        me.dropHitCreate(drag, hit, drag.peek('eventCreate'));
      } else if (mode !== null && mode !== void 0 && mode.resize) {
        me.dropHitResize(drag, hit, drag.peek('eventSourceHit'));
      }
    } else {
      me.dropHitNowhere(drag);
    }
  }
  updateDays(days) {
    const me = this,
      {
        calendarCells,
        eventDom,
        dayValues
      } = me,
      newDayValues = calendarCells && {};
    let first = true,
      cell,
      date,
      dayValue,
      i,
      lastCell;
    me.dayValues = newDayValues;
    if (calendarCells && eventDom) {
      for (i = 0; i < calendarCells.length; ++i) {
        cell = calendarCells[i];
        if (days !== null && days !== void 0 && days.includes(cell.dataset.date)) {
          lastCell = cell;
        }
      }
      for (i = 0; i < calendarCells.length; ++i) {
        cell = calendarCells[i];
        date = cell.dataset.date;
        if (days !== null && days !== void 0 && days.includes(date)) {
          if (!(dayValue = dayValues === null || dayValues === void 0 ? void 0 : dayValues[date])) {
            dayValue = me.includeDay(date, cell, first, cell === lastCell) || true;
            first = false;
          } else {
            delete dayValues[date];
          }
          newDayValues[date] = dayValue;
        }
      }
      if (dayValues) {
        for (i in dayValues) {
          me.removeDay(i, dayValues[i]);
        }
      }
    }
  }
  updateEventRecord(record) {
    this.owner.eventRecord = record;
  }
  updateOverflow(value, instance) {
    if (!value && instance) {
      instance.destroy();
    }
    return value;
  }
  updateOwner(owner) {
    this.hoverIgnoreElement = owner === null || owner === void 0 ? void 0 : owner.gripper;
  }
  updateRootElement(rootEl) {
    const me = this;
    me.dragRootElement = rootEl;
    me.dropRootElement = me.droppable ? rootEl : null;
    me.hoverRootElement = me.hoverable ? rootEl : null;
  }
  updateView(view, was) {
    var _me$_overflowDetacher;
    super.updateView(view, was);
    const me = this;
    me.rootElement = view ? me.findRootElement(view) : null;
    (_me$_overflowDetacher = me._overflowDetacher) === null || _me$_overflowDetacher === void 0 ? void 0 : _me$_overflowDetacher.call(me);
    // Only listen for overflow popup being shown if the view itself offers the event.
    // We must not listen to the relayed version from the owning DayView of a CalendarRow
    // otherwise we'd end up with a DayZone owning a duplicate OverflowZone in addition
    // to the AllDayZone.
    if (view !== null && view !== void 0 && view.isDayCellRenderer) {
      me._overflowDetacher = view.ion({
        thisObj: me,
        showOverflowPopup: 'onShowOverflowPopup'
      });
    }
  }
}
Zone.prototype._eventRecord = null;
//====================================================================================================
// Code for DayView
class BaseDayZone extends Zone {
  static get $name() {
    return 'BaseDayZone';
  }
  static get configurable() {
    return {
      hoverSelector: '.b-cal-event-wrap',
      draggingClsSelector: '.b-dayview-content'
    };
  }
  getHoverHandleCls(other) {
    let vert = this.isAllDayZone;
    if (other) {
      vert = !vert;
    }
    return `b-gripper-${vert ? 'vert' : 'horz'}`;
  }
}
//-------------------------------------------------------------------------
class AllDayZone extends BaseDayZone {
  static get $name() {
    return 'AllDayZone';
  }
  static get configurable() {
    return {
      hoverEdges: 'lr'
    };
  }
  // Drag handling
  beforeDrag(drag) {
    const ret = super.beforeDrag(drag);
    if (ret !== false && !this.draggable) {
      // Cannot use this.isMoving here because this is at the mousedown time
      // and nothing has been picked up yet which would indicate a dragmove.
      if (drag[eventDragSym].move) {
        return false;
      }
    }
    return ret;
  }
  dragEnter(drag) {
    // If there's no space in which to display the drop indicator,
    // temporarily expand the gutter to allow for appearance of the drop indicator.
    if (!this.view.eventsPerCell) {
      this.view.expandGutter();
    }
    return super.dragEnter(drag);
  }
  dragLeave(drag) {
    this.view.collapseGutter();
    super.dragLeave(drag);
  }
  captureDragOffset(eventRecord, hit, drag) {
    drag.set('eventOffset', [Math.max(Math.floor(DateHelper.diff(eventRecord.startDate, hit.date, 'd')), 0), 'd']);
  }
  // Drop handling
  dropHitCreate(drag, hit, dragFrom) {
    let endDate = this.clearTime(hit.date),
      startDate = this.clearTime(dragFrom.date);
    if (endDate < startDate) {
      [startDate, endDate] = [endDate, startDate];
    }
    this.setEventData({
      startDate,
      duration: DateHelper.diff(startDate, endDate, 'd') + 1,
      durationUnit: 'd'
    });
  }
  async moveEventTo(drag, dropRec) {
    const me = this,
      hit = me.hitTest(drag),
      date = me.applyDragOffset(hit === null || hit === void 0 ? void 0 : hit.date, drag),
      newDate = new Date(dropRec.startDate);
    if (date) {
      // We're only changing the date component of the time.
      // Not the time of day that the event started at.
      newDate.setFullYear(date.getFullYear());
      newDate.setMonth(date.getMonth());
      newDate.setDate(date.getDate());
      // If the event does not belong in the all day zone, i.e. it's not day-spanning
      // and does not have the allDay flag set, then set the allDay flag
      if (me.view.dayTime.startShift) {
        newDate.setHours(date.getHours());
        newDate.setMinutes(date.getMinutes());
        newDate.setSeconds(date.getSeconds());
        dropRec.duration = 1;
      } else {
        if (!me.view.isAllDayEvent(dropRec)) {
          dropRec.allDay = true;
        }
      }
      await me.setStartDate(dropRec, newDate);
    }
  }
  // Misc
  setEventData(data, creating) {
    super.setEventData(data, creating);
    const me = this,
      {
        eventRecord
      } = me;
    const {
      startDate,
      endDate
    } = eventRecord;
    if (creating && !me.view.dayTime.startShift) {
      eventRecord.allDay = true;
    }
    me.days = me.makeDays(startDate, endDate);
  }
  // Configs
  updateDays(days) {
    const me = this;
    let {
      eventEl
    } = me;
    if (days !== null && days !== void 0 && days.length) {
      var _me$dragging2, _me$dragging2$peek;
      if (!eventEl) {
        me.eventEl = eventEl = DomHelper.createElement(_objectSpread2({}, me.eventDom));
        eventEl.classList.add('b-allday');
      }
      const {
          dropRootElement
        } = me,
        {
          hideNonWorkingDays,
          visibleCellSelector,
          weekLength
        } = me.view,
        eventTop = (_me$dragging2 = me.dragging) === null || _me$dragging2 === void 0 ? void 0 : (_me$dragging2$peek = _me$dragging2.peek('eventSourceHit')) === null || _me$dragging2$peek === void 0 ? void 0 : _me$dragging2$peek.eventTop,
        cells = DomHelper.children(dropRootElement, `${visibleCellSelector}${hideNonWorkingDays ? ':not(.b-nonworking-day)' : ''}`),
        cell = DomHelper.down(dropRootElement, `${visibleCellSelector}${hideNonWorkingDays ? ':not(.b-nonworking-day)' : ''}[data-date='${days[days.length - 1]}']`);
      // The one event element lives in the startDate cell
      DomHelper.down(cell, '.b-cal-event-bar-container').appendChild(eventEl);
      eventEl.style[me.view.rtl ? 'right' : 'left'] = DomHelper.percentify(100 * (cells.indexOf(cell) - days.length + 1) / weekLength);
      eventEl.style.width = DomHelper.percentify(100 * days.length / weekLength);
      if (eventTop) {
        eventEl.style.top = eventTop;
      }
      // Ensure element is in view in case it's scrolled, and we are dragging
      // an interday event in the main day part.
      me.view.scrollable.scrollIntoView(eventEl, true);
    } else if (eventEl) {
      if (eventEl.classList.contains('b-cal-tentative-event')) {
        eventEl.remove();
      }
      me.eventEl = null;
    }
  }
  updateView(view, was) {
    if (view) {
      const multiDay = DateHelper.diff(view.startDate, view.endDate, 'd') > 1;
      this.hoverable = this.draggable = multiDay;
    }
    super.updateView(view, was);
  }
}
//-------------------------------------------------------------------------
class DayZone$1 extends BaseDayZone {
  static get $name() {
    return 'DayZone';
  }
  static get configurable() {
    return {
      dragEventId: null,
      hoverable: true,
      hoverEdges: 'tb',
      times: {
        $config: {
          equal: 'array'
        },
        value: null
      }
    };
  }
  construct(...args) {
    const me = this;
    super.construct(...args);
    me.allDayZone = new AllDayZone({
      active: me.active,
      owner: me.owner,
      view: me.view.allDayEvents,
      resource: me.resource
    });
  }
  syncDraggingElements(eventId, active) {
    const {
        dragging: drag
      } = this,
      {
        draggingItemCls
      } = drag.source,
      containerEl = drag.itemElement.closest('.b-dayview-day-container'),
      elements = containerEl.querySelectorAll(`[data-event-id="${eventId}"]`);
    for (const el of elements) {
      el.classList.toggle(draggingItemCls, active);
    }
  }
  updateDragEventId(eventId, previousEventId) {
    previousEventId && this.syncDraggingElements(previousEventId, false);
    eventId && this.syncDraggingElements(eventId, true);
  }
  get eventRecord() {
    var _this$allDayZone;
    return super.eventRecord || ((_this$allDayZone = this.allDayZone) === null || _this$allDayZone === void 0 ? void 0 : _this$allDayZone.eventRecord);
  }
  set eventRecord(value) {
    super.eventRecord = value;
  }
  get recurring() {
    var _this$eventRecord;
    return this.isCreating && ((_this$eventRecord = this.eventRecord) === null || _this$eventRecord === void 0 ? void 0 : _this$eventRecord.recurrenceRule) != null;
  }
  get droppingAllDay() {
    var _this$dropping5, _this$view2;
    const eventRecord = (_this$dropping5 = this.dropping) === null || _this$dropping5 === void 0 ? void 0 : _this$dropping5.peek('eventRecord');
    return (eventRecord === null || eventRecord === void 0 ? void 0 : eventRecord.startDate) && ((_this$view2 = this.view) === null || _this$view2 === void 0 ? void 0 : _this$view2.isAllDayEvent(eventRecord)) || false;
  }
  get useAllDay() {
    // when an allDay event is being dropping on the hourly part of the day view, relay that to the allDayZone
    // if it is from an outsider (we want to retain the allDay nature of the event). If it is from _our_ allDayZone,
    // then the goal is to move it from allDay to not allDay.
    return this.droppingAllDay && this.view.showAllDayHeader && this.dropping.source !== this.allDayZone;
  }
  get wasAllDay() {
    // when an allDay event is being dropping on the hourly part of the day view, relay that to the allDayZone
    // if it is from an outsider (we want to retain the allDay nature of the event). If it is from _our_ allDayZone,
    // then the goal is to move it from allDay to not allDay.
    return this.droppingAllDay && this.dropping.source === this.allDayZone;
  }
  doDestroy() {
    var _this$allDayZone2;
    (_this$allDayZone2 = this.allDayZone) === null || _this$allDayZone2 === void 0 ? void 0 : _this$allDayZone2.destroy();
    super.doDestroy();
  }
  dragStart() {
    var _this$dragging$peek$i, _this$dragging$peek;
    super.dragStart();
    this.dragEventId = (_this$dragging$peek$i = (_this$dragging$peek = this.dragging.peek('eventRecord')) === null || _this$dragging$peek === void 0 ? void 0 : _this$dragging$peek.id) !== null && _this$dragging$peek$i !== void 0 ? _this$dragging$peek$i : null;
  }
  findRootElement(view) {
    return view.eventContentElement;
  }
  // Drag handling
  captureDragOffset(eventRecord, hit, drag) {
    drag.set('eventOffset', [Math.floor(DateHelper.diff(eventRecord.startDate, hit.date, 'm')), 'm']);
  }
  cleanupDrag() {
    var _this$allDayZone3;
    this.dragEventId = null;
    super.cleanupDrag();
    (_this$allDayZone3 = this.allDayZone) === null || _this$allDayZone3 === void 0 ? void 0 : _this$allDayZone3.cleanupDrag();
  }
  // Drop handling
  cleanupDrop() {
    var _this$owner$client2, _this$owner$client2$s, _this$allDayZone4;
    super.cleanupDrop();
    // Stop monitoring early. With polyfilled resize monitor scroll event
    // will fire too soon when eventRecord is nullified but monitor is not stopped
    (_this$owner$client2 = this.owner.client) === null || _this$owner$client2 === void 0 ? void 0 : (_this$owner$client2$s = _this$owner$client2.scrollManager) === null || _this$owner$client2$s === void 0 ? void 0 : _this$owner$client2$s.stopMonitoring();
    (_this$allDayZone4 = this.allDayZone) === null || _this$allDayZone4 === void 0 ? void 0 : _this$allDayZone4.cleanupDrop();
  }
  dropHitCreate(drag, hit) {
    const me = this,
      dragFrom = drag.peek('eventCreate');
    let endTime = hit.date,
      startTime = dragFrom.date,
      endDate = endTime,
      startDate = startTime,
      duration,
      recurrenceCount;
    const sameDay = !(me.clearTime(startTime) - me.clearTime(endTime)),
      recurring = drag.ctrlKey && !sameDay;
    if (recurring || sameDay) {
      endDate = me.clearTime(endTime);
      startDate = me.clearTime(startTime);
      // Now these are just milliseconds from midnight (note: Date - Date = millis):
      startTime = startTime - startDate;
      endTime = endTime - endDate;
      if (endDate < startDate) {
        [startDate, endDate] = [endDate, startDate];
      }
      if (endTime < startTime) {
        [startTime, endTime] = [endTime, startTime];
      }
      startDate.setTime(startDate.getTime() + startTime);
      duration = Math.max(me.view.increment, Math.floor(endTime - startTime)) / MINUTES;
      if (recurring) {
        recurrenceCount = DateHelper.diff(me.clearTime(startDate), me.clearTime(endDate), 'd') + 1;
      }
    } else {
      if (endDate < startDate) {
        [startDate, endDate] = [endDate, startDate];
      }
      duration = Math.floor((endDate - startDate) / MINUTES);
    }
    me.setEventData({
      startDate,
      duration,
      recurrenceRule: recurring ? `FREQ=DAILY;COUNT=${recurrenceCount}` : null
    });
  }
  dropHitMove(drag, hit, eventRecord) {
    let startDate = hit.date;
    const me = this,
      {
        view
      } = me,
      dayStart = view.dayTime.startOfDay(startDate);
    if (me.useAllDay) {
      me.allDayZone.dropHitMove(drag, hit, eventRecord);
    } else {
      // use the internal eventRecord since it may have a different durationUnit when dragging between allDay
      // and non-allDay:
      eventRecord = me.eventRecord;
      startDate = me.applyDragOffset(startDate, drag);
      // Dragging in a DayView must not allow dragging above "midnight", otherwise the drop indicator will
      // become what looks like a 2 day event in the all day header.
      if (view.showAllDayHeader && startDate < dayStart) {
        startDate = dayStart;
      }
      me.setEventData({
        startDate,
        endDate: DateHelper.add(startDate, eventRecord.duration, eventRecord.durationUnit),
        duration: eventRecord.duration
      });
    }
  }
  dropHitResize(drag, hit, eventHit) {
    const me = this,
      {
        eventRecord
      } = me,
      date = hit.date;
    if (eventHit.atEnd) {
      if (eventRecord.startDate < date) {
        me.setEventData({
          endDate: date
        });
      }
    } else if (date < eventRecord.endDate) {
      me.setEventData({
        startDate: date
      });
    }
  }
  async moveEventTo(drag, dropRec) {
    const me = this,
      hit = me.hitTest(drag),
      date = hit === null || hit === void 0 ? void 0 : hit.date;
    if (date) {
      if (me.useAllDay) {
        await me.allDayZone.moveEventTo(drag, dropRec);
      } else {
        if (me.wasAllDay) {
          dropRec.allDay = false;
        }
        await me.setStartDate(dropRec, me.applyDragOffset(date, drag));
      }
    }
  }
  startCreate(date) {
    this.createEvent({
      duration: 0,
      durationUnit: 'm',
      startDate: date
    });
  }
  // Misc
  includeDay(date, cell, first, last) {
    return DomHelper.createElement(_objectSpread2({
      parent: cell.querySelector('.b-dayview-event-container')
    }, this.renderEvent(this.eventRecord, first, last)));
  }
  removeDay(date, value) {
    if (value.classList.contains('b-cal-tentative-event')) {
      value.remove();
    }
  }
  setEventData(data, creating) {
    const me = this;
    if (me.useAllDay) {
      me.allDayZone.setEventData(data, creating);
      return;
    }
    super.setEventData(data, creating);
    const {
        eventRecord
      } = me,
      {
        endDate,
        startDate
      } = eventRecord,
      {
        dayTime
      } = me.view;
    let lastDate = endDate;
    if (me.recurring) {
      // odd thing here... the way "days" works is inclusive endDate (because of events that start/stop in the
      // same day), so we need the "-1":
      lastDate = DateHelper.add(lastDate, eventRecord.recurrence.count - 1, 'd');
    }
    me.days = me.makeDays(startDate, lastDate); // updates rendered events for these days
    me.times = [dayTime.delta(startDate, 's'), dayTime.delta(endDate, 's')];
  }
  setupEvent(data, creating) {
    const me = this;
    if (me.useAllDay) {
      me.allDayZone.setupEvent(data, creating);
    } else {
      if (this.wasAllDay) {
        data.allDay = false;
        data.endDate = DateHelper.add(data.startDate, data.duration = 1, data.durationUnit = 'hour');
      }
      super.setupEvent(data, creating);
    }
  }
  // Configs
  updateDays(days, was) {
    super.updateDays(days, was);
    this.updateTimes(this.times, null);
  }
  updateTimes(times) {
    if (!times) {
      return;
    }
    const me = this,
      {
        allDayZone,
        dayValues,
        dragging,
        eventRecord,
        recurring,
        view
      } = me,
      {
        dayTime,
        eventSpacing
      } = view,
      insetProp = view.rtl ? 'right' : 'left',
      {
        endDate,
        startDate
      } = eventRecord,
      [startOffset, endOffset] = times,
      // drag move can come from outside our calendar, so only consider the eventWidth if we are the one doing
      // the dragging:
      eventInset = !(dragging !== null && dragging !== void 0 && dragging.aborted) && (dragging === null || dragging === void 0 ? void 0 : dragging.peek('eventInset')),
      eventWidth = !(dragging !== null && dragging !== void 0 && dragging.aborted) && (dragging === null || dragging === void 0 ? void 0 : dragging.peek('eventWidth')),
      firstDay = dayTime.dateKey(startDate),
      lastDay = dayTime.dateKey(endDate),
      multiDay = dayTime.startOfDay(startDate) < dayTime.startOfDay(endDate),
      heightScale = 100 / dayTime.duration('s'); // to give us percent when we multiply by this value
    let {
        days
      } = me,
      date,
      first,
      height,
      style,
      top;
    if (!days) {
      return;
    }
    // Since we may not have changed me.days (time of day only changes), we now need to update the vertical
    // aspect
    for (date in dayValues) {
      first = date === firstDay;
      style = dayValues[date].style;
      top = startOffset * heightScale;
      height = (endOffset - startOffset) * heightScale;
      DomSync.sync({
        targetElement: dayValues[date],
        domConfig: me.renderEvent(me.eventRecord, first, date === days[days.length - 1])
      });
      if (!recurring && multiDay) {
        if (first) {
          height = 100 - top;
        } else if (date === lastDay) {
          height = top + height;
        } else {
          height = 100;
        }
      }
      style.top = recurring || first ? DomHelper.percentify(top) : 0;
      style.height = DomHelper.percentify(height);
      style.paddingBottom = DomHelper.setLength(eventSpacing);
      if (eventInset) {
        style[insetProp] = eventInset;
      }
      if (eventWidth) {
        style.width = `${eventWidth}px`;
      }
    }
    // Now sync "days" for the allDayZone:
    if (!days || days.length < 2 || recurring) {
      allDayZone === null || allDayZone === void 0 ? void 0 : allDayZone.cleanupDrop();
      days = null;
    } else if (allDayZone && view.showAllDayHeader) {
      if (!allDayZone.eventRecord) {
        allDayZone.noTip = true;
        allDayZone.createEvent({
          startDate: eventRecord.startDate,
          endDate: eventRecord.endDate
        });
      }
      allDayZone.eventRecord.set({
        startDate: eventRecord.startDate,
        endDate: DateHelper.add(eventRecord.startDate, days.length - 1, 'd')
      });
      allDayZone.days = days;
    }
  }
}
//====================================================================================================
// Code for MonthView
class MonthZone extends Zone {
  static get $name() {
    return 'MonthZone';
  }
  static get configurable() {
    return {
      coverage: {
        $config: {
          equal: ObjectHelper.isEqual
        },
        value: null
      },
      hoverable: true,
      hoverEdges: 'lr',
      hoverSelector: '.b-cal-event-wrap.b-allday'
    };
  }
  findRootElement(view) {
    return view.weeksElement;
  }
  // Drag handling
  captureDragOffset(eventRecord, hit, drag) {
    drag.set('eventOffset', [Math.floor(DateHelper.diff(this.clearTime(eventRecord.startDate), hit.date, 'd')), 'd']);
  }
  cleanupDrag() {
    super.cleanupDrag();
    this.coverage = null; // resize mode acts as a drag not drop
  }
  // Drop handling
  cleanupDrop() {
    var _this$owner$client3, _this$owner$client3$s;
    super.cleanupDrop();
    // Stop monitoring early. With polyfilled resize monitor scroll event
    // will fire too soon when eventRecord is nullified but monitor is not stopped
    (_this$owner$client3 = this.owner.client) === null || _this$owner$client3 === void 0 ? void 0 : (_this$owner$client3$s = _this$owner$client3.scrollManager) === null || _this$owner$client3$s === void 0 ? void 0 : _this$owner$client3$s.stopMonitoring();
    this.coverage = null;
  }
  dropHitCreate(drag, hit) {
    const me = this,
      recurring = drag.ctrlKey,
      dragFrom = drag.peek('eventCreate');
    let recurrence = null,
      count,
      day1,
      day2,
      endDate,
      startDate,
      week1,
      week2;
    endDate = me.clearTime(hit.date);
    startDate = me.clearTime(dragFrom.date);
    day1 = dragFrom.dayNumber;
    day2 = hit.dayNumber;
    week1 = dragFrom.weekOffset;
    week2 = hit.weekOffset;
    if (week2 < week1) {
      [week1, week2] = [week2, week1];
    }
    /*
     +-----+-----+-----+-----+-----+-----+-----+
     |  S  |  M  |  Tu |  W  |  Th |  F  |  S  |
     +-----+-----+-----+-----+-----+-----+-----+
     |     |  B  |     |  A  |     |  C  |     |
     +-----+-----+-----+-----+-----+-----+-----+
     |     |     |     |     |     |     |     |
     +-----+-----+-----+-----+-----+-----+-----+
     |     |  D  |     |  x  |     |  E  |     |
     +-----+-----+-----+-----+-----+-----+-----+
     |     |     |     |     |     |     |     |
     +-----+-----+-----+-----+-----+-----+-----+
     |     |  F  |     |  G  |     |  H  |     |
     +-----+-----+-----+-----+-----+-----+-----+
     startDate   day1
     A   > endDate   = day2
     B   > endDate   > day2
     C   > endDate   < day2
     D   > endDate   > day2
     E   < endDate   < day2
     F   < endDate   > day2
     G   < endDate   = day2
     H   < endDate   < day2
     */
    if (recurring) {
      // In this mode, the interval [day1, day2] is used to draw the days of the week for each week, so it
      // must be that day1 <= day2.
      count = week2 - week1 + 1;
      recurrence = count > 1 ? `FREQ=WEEKLY;COUNT=${count}` : null;
      if (endDate < startDate) {
        // if (A, B, C or D)
        startDate = endDate; // only startDate matters for recurrence...
        if (day1 < day2) {
          // if (C)
          startDate = DateHelper.add(startDate, day1 - day2, 'd');
        }
      } else if (day2 < day1) {
        // if (F)
        startDate = DateHelper.add(startDate, day2 - day1, 'd');
      }
      if (day2 < day1) {
        // if (B, D or F)
        [day1, day2] = [day2, day1];
      }
    }
    // In this mode, day1 is the day of week the event starts and day2 is the day of week for the end of the
    // event, so they must adhere to startDate/endDate.
    else if (endDate < startDate) {
      [startDate, endDate] = [endDate, startDate];
      [day1, day2] = [day2, day1];
    }
    me.setEventData({
      startDate,
      duration: (recurring ? day2 - day1 : DateHelper.diff(startDate, endDate, 'd')) + 1,
      durationUnit: 'd',
      recurrenceRule: recurrence
    });
  }
  dropHitNowhere(drag) {
    super.dropHitNowhere(drag);
    this.coverage = null;
  }
  // Misc
  setEventData(data, creating) {
    super.setEventData(data, creating);
    const {
        dropping,
        eventRecord,
        view
      } = this,
      {
        visibleCellSelector,
        hideNonWorkingDays
      } = view,
      weekEls = DomHelper.children(view.weeksElement, '> .b-calendar-week'),
      coverage = {
        // weekNumber : String[] describing the days for a weekEl (in order of weekEls)
      },
      add = event => {
        const {
          startDate,
          endDate
        } = event;
        for (let cells, cover, k, n, i = 0; i < weekEls.length; ++i) {
          cells = DomHelper.children(weekEls[i], `${visibleCellSelector}${hideNonWorkingDays ? ':not(.b-nonworking-day)' : ''}`); // not immediate descendants
          n = cells.length;
          // cover is a string w/day numbers for every day that intersects the event 0 to N-1 where N is
          // the number of days in the week. Day number 0 is preceded by '<' if the event started before
          // the week. Day number N-1 is followed by '>' if the event extends beyond the end of the week.
          // Ex: '0123' means the event occurs on the first 4 days of the week.
          // Ex: '<012' means the event started in the prior week and occurs on the first 3 days.
          cover = '';
          for (k = 0; k < n; ++k) {
            const dayStart = view.getDateFromElement(cells[k]),
              dayEnd = DateHelper.add(dayStart, 1, 'd');
            if (startDate < dayEnd && dayStart < endDate) {
              // if (day intersects event)
              if (!k && startDate < dayStart) {
                cover = '<';
              }
              cover += k; // k is converted to a string since cov is a string
              if (k === n - 1 && dayEnd < endDate) {
                cover += '>';
              }
            }
          }
          if (cover) {
            (coverage[i] || (coverage[i] = [])).push(cover);
          }
        }
      };
    if (dropping !== null && dropping !== void 0 && dropping.has('eventRecord') || !eventRecord.recurrence) {
      add(eventRecord);
    } else {
      eventRecord.recurrence.forEachOccurrence(view.startDate, view.endDate, add);
    }
    this.coverage = coverage;
  }
  // Configs
  updateCoverage(coverage) {
    const me = this,
      {
        dragging,
        weekValues,
        view
      } = me,
      {
        rtl
      } = view,
      {
        visibleCellSelector,
        hideNonWorkingDays
      } = view,
      eventSourceHit = coverage && (dragging === null || dragging === void 0 ? void 0 : dragging.peek('eventSourceHit')),
      eventTop = eventSourceHit === null || eventSourceHit === void 0 ? void 0 : eventSourceHit.eventTop,
      newWeekValues = {},
      eventRow = view.getWeekElementFor(eventSourceHit === null || eventSourceHit === void 0 ? void 0 : eventSourceHit.eventElement),
      {
        weekElements
      } = view;
    let cell, cells, cov, cover, el, eventEl, extL, extR, i, k, weekEl;
    me.weekValues = newWeekValues;
    for (i = 0; i < weekElements.length; ++i) {
      if (!(cover = coverage === null || coverage === void 0 ? void 0 : coverage[i])) {
        continue;
      }
      weekEl = weekElements[i];
      cells = DomHelper.children(weekEl, `${visibleCellSelector}${hideNonWorkingDays ? ':not(.b-nonworking-day)' : ''}`); // not immediate descendants
      for (k = 0; k < cover.length; ++k) {
        var _weekValues$i;
        // we keep an array of elements for each week in case we need to render some sort of recurrence
        if (!(eventEl = weekValues === null || weekValues === void 0 ? void 0 : (_weekValues$i = weekValues[i]) === null || _weekValues$i === void 0 ? void 0 : _weekValues$i.shift())) {
          eventEl = DomHelper.createElement(me.eventDom);
        }
        (newWeekValues[i] || (newWeekValues[i] = [])).push(eventEl);
        cov = cover[k];
        extL = cov.includes('<') ? 1 : 0;
        extR = cov.includes('>') ? 1 : 0;
        cov = cov.substr(extL, cov.length - extR - extL); // remove the < > chars if any
        eventEl.classList[extL ? 'add' : 'remove']('b-continues-past');
        eventEl.classList[extR ? 'add' : 'remove']('b-continues-future');
        eventEl.style[rtl ? 'right' : 'left'] = DomHelper.percentify(100 * Number(cov[0]) / cells.length);
        eventEl.style.width = DomHelper.percentify(100 * cov.length / cells.length);
        if (eventTop && weekEl === eventRow) {
          eventEl.style.top = eventTop;
        }
        // We put the el in the last cell so that it is on top of events for that day and all events on prior
        // days as well
        cell = cells[Number(cov[cov.length - 1])];
        el = DomHelper.down(cell, '.b-cal-event-bar-container');
        if (el !== eventEl.parentNode) {
          el.appendChild(eventEl);
        }
      }
    }
    if (weekValues) {
      for (i in weekValues) {
        weekValues[i].forEach(el => {
          if (el.classList.contains('b-cal-tentative-event')) {
            el.remove();
          }
        });
      }
    }
  }
}
//====================================================================================================
// Code for OverflowZone
class OverflowZone extends Zone {
  static get $name() {
    return 'OverflowZone';
  }
  static get configurable() {
    return {
      droppable: false,
      dragProxy: {
        type: 'default',
        open(drag) {
          const me = this,
            {
              owner
            } = drag.source.view,
            sourceEl = drag.element.closest('.b-cal-event-wrap');
          if (owner.isYearView) {
            me.proxyEl = sourceEl.cloneNode(true);
            me.proxyEl.classList.add('b-cal-drag-proxy');
            me.proxyEl.style.width = `${sourceEl.offsetWidth}px`;
            me.proxyOffset = EventHelper.getClientPoint(drag.startEvent).getDelta(Rectangle.from(sourceEl));
            owner.contentElement.appendChild(me.proxyEl);
          }
        },
        dragMove(drag) {
          if (this.proxyEl) {
            // Align the proxy to [10, 10] from the pointer
            DomHelper.alignTo(this.proxyEl, EventHelper.getClientPoint(drag.event).translate(10, 10), {
              align: 't0-t0'
            });
          }
        },
        close() {
          var _this$proxyEl;
          (_this$proxyEl = this.proxyEl) === null || _this$proxyEl === void 0 ? void 0 : _this$proxyEl.remove();
        }
      }
    };
  }
  findRootElement(view) {
    return view.contentElement;
  }
  beforeDrag(drag) {
    const hit = this.hitTest(drag);
    if ((hit === null || hit === void 0 ? void 0 : hit.type) !== 'event' || !this.owner.draggable || !hit.eventRecord.isDraggable) {
      return false;
    }
    drag.set('eventRecord', hit.eventRecord);
    drag.set('eventDragMode', drag[eventDragSym] = modeDescriptor.move.mode);
  }
  dragStart() {
    this.view.hide();
  }
}
//====================================================================================================
// Code for YearView
class YearZone extends Zone {
  static get $name() {
    return 'YearZone';
  }
  startCreate() {
    var _this$view$_overflowP;
    // Overflow popup must hide during YearView drag create.
    (_this$view$_overflowP = this.view._overflowPopup) === null || _this$view$_overflowP === void 0 ? void 0 : _this$view$_overflowP.hide();
    super.startCreate(...arguments);
  }
  // Drop handling
  dragEnter(drag) {
    const result = super.dragEnter(drag);
    if (result !== false) {
      this.view.contentElement.classList.add(this.draggingCls);
    }
    return result;
  }
  dragLeave(drag) {
    super.dragLeave(drag);
    this.view.contentElement.classList.remove(this.draggingCls);
  }
  dropHitCreate(drag, hit, dragFrom) {
    const me = this;
    let endDate = me.clearTime(hit.date),
      startDate = me.clearTime(dragFrom.date);
    if (endDate < startDate) {
      [startDate, endDate] = [endDate, startDate];
    }
    // Helpful to use the dates because of changing DST across large date ranges
    me.setEventData({
      startDate,
      endDate: DateHelper.add(endDate, 1, 'd')
    });
    me.days = me.makeDayRange(startDate, endDate); // updates cell styles for these days
  }

  dropHitMove(drag, hit, eventRecord) {
    super.dropHitMove(drag, hit, eventRecord);
    const me = this,
      tempRec = me.eventRecord;
    let {
      endDate
    } = tempRec;
    if (tempRec.allDay) {
      endDate = DateHelper.add(endDate, -1, 'd'); // switch to inclusive
    }

    me.days = me.makeDayRange(tempRec.startDate, endDate);
  }
  // Misc
  includeDay(date) {
    const els = DomHelper.children(this.view.bodyElement, `[data-date='${date}']`);
    els.forEach(e => e.classList.add(`b-cal-tentative-event${this.view.hideNonWorkingDays ? ':not(.b-nonworking-day)' : ''}`));
    return els;
  }
  makeDayRange(startDate, endDate) {
    const days = [];
    for (let date = startDate; date <= endDate; date = DateHelper.add(date, 1, 'd')) {
      days.push(DateHelper.format(date, YYYY_MM_DD));
    }
    return days;
  }
  removeDay(date, els) {
    els.forEach(e => e.classList.remove('b-cal-tentative-event'));
  }
}
class ResourceViewZone extends Base {
  static get configurable() {
    return {
      view: null,
      zones: {
        $config: ['nullify'],
        value: []
      }
    };
  }
  updateView(view) {
    // Create sub zones for any already existent views.
    // If project had static data, they will be generated at config time.
    view.eachView(view => {
      this.onResourceViewViewCreate({
        view
      });
    });
    // If data is loaded async, they will be created when Resources arrive.
    view.ion({
      viewCreate: 'onResourceViewViewCreate',
      thisObj: this
    });
  }
  onResourceViewViewCreate({
    view
  }) {
    const me = this,
      {
        zones,
        owner
      } = me,
      modes = owner.client.constructor.Modes,
      type = owner.getViewZoneType(modes.resolveType(view.type));
    type && zones.push(owner.createZone(type, {
      view,
      resource: view.defaultCalendar
    }));
  }
  changeZones(zones, oldZones) {
    if (oldZones !== null && oldZones !== void 0 && oldZones.length && !zones) {
      for (let i = 0, {
          length
        } = oldZones; i < length; i++) {
        oldZones[i].destroy();
      }
    }
    return zones;
  }
}
//----------------------------------------------------------------------------------------------------
/**
 * Format expected to be returned in a `validateCreateFn`
 *
 * @typedef {Object} ValidateCreateResult
 * @property {Boolean} add Allow adding to store
 * @property {Boolean} edit Allow editor to open
 */
/**
 * This feature provides drag-based event creation and modification for Calendars. When enabled (which is the default
 * for calendars), the user can do the following via the mouse or touch screen:
 *
 *  - Create events by touching (or pressing the mouse button in) an the empty space and dragging. As the drag
 *    progresses, a tentative event is rendered. On release, the {@link Calendar.feature.EventEdit} feature displays
 *    the event edit dialog to complete the process. This can be disabled via the {@link #config-creatable} config.
 *  - Adjust the start or end times of an event in the day or week views by dragging the top or bottom of an event.
 *    This can be disabled via the {@link #config-resizable} config or the {@link Scheduler.model.mixin.EventModelMixin#field-resizable}
 *    field on a per-event basis.
 *  - Adjust the start or end date of an all-day event in the month view by dragging the left-most or right-most end
 *    of an event. This can be disabled via the {@link #config-resizable} config or the
 *    {@link Scheduler.model.mixin.EventModelMixin#field-resizable} field on a per-event basis.
 *  - Move an event from its current time (in day or week views) or date (in all views except agenda) by dragging the
 *    body of an event. This can be disabled via the {@link #config-draggable} config or via the
 *    {@link Scheduler.model.mixin.EventModelMixin#field-draggable} field on a per-event basis.
 *
 * ```javascript
 *  // change name for events created by drag to "Event":
 *  let calendar = new Calendar({
 *      features : {
 *          drag : {
 *              newName : 'Event'
 *          }
 *      }
 *  });
 * ```
 *
 * ## Asynchronous validation of resize, move and create operations
 *
 * You can easily add a confirmation step after an operation to show a dialog to the end user. This is done using the
 * {@link #event-beforeDragMoveEnd}, {@link #event-beforeDragCreateEnd} and {@link #event-beforeDragResizeEnd} events.
 *
 * ```javascript
 *  let calendar = new Calendar({
 *      listeners : {
 *          // Async event listeners allowing you to veto drag operations
 *          beforeDragMoveEnd : async({ eventRecord }) => {
 *               const result = await MessageDialog.confirm({
 *                   title   : 'Please confirm',
 *                   message : 'Is this the start time you wanted?'
 *               });
 *
 *               // Return true to accept the drop or false to reject it
 *               return result === MessageDialog.yesButton;
 *           },
 *           beforeDragResizeEnd : async({ eventRecord }) => {
 *               const result = await MessageDialog.confirm({
 *                   title   : 'Please confirm',
 *                   message : 'Is this the duration you wanted?'
 *               });
 *
 *               // Return true to accept the drop or false to reject it
 *               return result === MessageDialog.yesButton;
 *           },
 *           beforeDragCreateEnd : async({ eventRecord }) => {
 *               const result = await MessageDialog.confirm({
 *                   title   : 'Please confirm',
 *                   message : 'Want to create this event?'
 *               });
 *
 *               // Return true to accept the drop or false to reject it
 *               return result === MessageDialog.yesButton;
 *           }
 *       }
 *  });
 * ```
 *
 * This feature is **enabled** by default.
 *
 * The example below demonstrates configuration of the EventEdit feature and implements validation of
 * drag gestures so that no event interrupts fika from 9:30am to 10:30am.
 * @inlineexample Calendar/feature/CalendarDrag.js
 * @extends Calendar/feature/CalendarFeature
 * @classtype drag
 * @feature
 */
class CalendarDrag extends CalendarFeature {
  static get $name() {
    return 'CalendarDrag';
  }
  static get type() {
    return 'drag';
  }
  static get configurable() {
    return {
      disableOnReadOnly: true,
      localizableProperties: ['newName', 'recurrenceTip'],
      /**
       * Specify `false` to disallow creating events by drag gestures.
       * @config {Boolean}
       */
      creatable: true,
      /**
       * Specify `false` to disallow dragging events to new times or days.
       * @config {Boolean}
       */
      draggable: true,
      /**
       * A {@link Core.helper.DomHelper#typedef-DomConfig DOM config} object used to create an extra element
       * during event drag to contain the end time of the tentative event. This element contains the CSS class
       * `'b-cal-event-footer'` which can be used for styling.
       *
       * Set this to `null` to remove the end time rendering during drag operations.
       * @config {DomConfig}
       * @default
       */
      footer: {
        className: 'b-cal-event-footer'
      },
      /**
       * This is configured as a {@link Core.helper.DomHelper#function-createElement-static DomHelper}
       * specification and is promoted to an `HTMLElement` during initialization. This element is moved between
       * calendar event elements on hover in order to show drag handles on the event under the mouse.
       * @config {HTMLElement|DomConfig}
       * @private
       */
      gripper: {
        class: 'b-gripper'
      },
      /**
       * The name of new events or a function to call with the event record that will return the event name.
       * @config {String|Function}
       */
      newName: 'L{newEvent}',
      /**
       * The text to display as a hint for creating recurring events during drag. This tip is displayed in the
       * {@link #config-tooltip} in the same place as the recurrence summary (when there is no recurrence to
       * display).
       * @config {String}
       */
      recurrenceTip: '(L{holdCtrlForRecurrence})',
      /**
       * Specify `false` to disallow dragging the edges of events to change their start or end.
       * @config {Boolean}
       */
      resizable: true,
      /**
       * The tooltip to display during a drag create process. Disabled by
       * default, set to `true`, or provide a tooltip / config object, to enable it.
       * @config {Boolean|EventTipConfig|Calendar.widget.EventTip}
       */
      tooltip: {
        $config: ['lazy', 'nullify'],
        value: {
          type: 'eventTip',
          disabled: true,
          forSelector: null,
          tools: null
        }
      },
      /**
       * An empty function by default that allows you to perform custom validation on an event being created by
       * a drag gesture.
       *
       * The `drag` context contains the following data items (see {@link Core.util.drag.DragContext#function-get}):
       *
       *  - `eventDragMode` : The {@link #typedef-CalendarDragMode} object describing the drag operation.
       *  - `eventCreate` : The {@link Calendar.view.Calendar#typedef-CalendarHit} object that describes the target of the drag operation.
       *
       * Return `false` to cancel the create operation.
       *
       * This function can return a `Promise` (i.e., it can be `async`).
       *
       * Example:
       * ```javascript
       *  let calendar = new Calendar({
       *      features : {
       *          drag : {
       *              async validateCreateFn({ eventRecord, drag }) {
       *                  // This method can be async so it can make ajax requests or interact
       *                  // with the user...
       *
       *                  // if we return false, the event will be discarded
       *
       *                  // The following is equivalent to returning false:
       *                  //
       *                  // return {
       *                  //     // Do not add the event to the store
       *                  //     add  : false,
       *                  //     // Do not display the edit dialog (in the eventEdit feature):
       *                  //     edit : false
       *                  // };
       *                  //
       *                  // This simply adds the event and does not display the editor:
       *                  //
       *                  return {
       *                      edit : false
       *                  };
       *
       *                  // To do delay adding the event until the editor is done (and
       *                  // not via Cancel):
       *                  // return {
       *                  //     add : false
       *                  // };
       *              }
       *          }
       *      }
       *  });
       * ```
       * or:
       * ```javascript
       *  let calendar = new Calendar({
       *      features : {
       *          drag : {
       *              // Will resolve on the Calendar
       *              validateCreateFn : 'up.validateCreate'
       *          }
       *      },
       *      validateCreate{ eventRecord, drag } {
       *          ...
       *      }
       *  });
       * ```
       * @param {Object} info
       * @param {Core.util.drag.DragContext} info.drag The drag create context.
       * @param {Event} info.event The browser event object.
       * @param {Scheduler.model.EventModel} info.eventRecord The Event record.
       * @returns {Boolean|ValidateCreateResult} Return `false` if this event should be rejected.
       *
       * Return `true` if the event should be added to the event store and to inform the
       * {@link Calendar.feature.EventEdit eventEdit} feature to display the edit dialog.
       *
       * If this function returns an object, the `add` property can be set to `false`
       * to prevent adding to the event store, and the `edit` property can be set to `false` to inform the
       * `eventEdit` feature not to display the edit dialog.
       * @config {Function|String}
       */
      validateCreateFn: () => {},
      /**
       * An empty function by default that allows you to perform custom validation on the event being moved to a
       * new date or time via a drag gesture.
       *
       * The `drag` context contains the following data items (see {@link Core.util.drag.DragContext#function-get}):
       *
       *  - `eventDragMode` : The {@link #typedef-CalendarDragMode} object describing the drag operation.
       *  - `eventRecord` : The {@link Scheduler.model.EventModel event record} being moved.
       *  - `eventSourceHit` : The {@link Calendar.view.Calendar#typedef-CalendarHit} object that describes the source of the drag operation.
       *
       * Return `false` to cancel the operation.
       *
       * This function can return a `Promise` (i.e., it can be `async`).
       *
       * Example:
       * ```javascript
       *  let calendar = new Calendar({
       *      features : {
       *          drag : {
       *              async validateMoveFn({ eventRecord, drag }) {
       *                  // This method can be async so it can make ajax requests or interact
       *                  // with the user...
       *
       *                  // if we return false, the event move will be discarded
       *              }
       *          }
       *      }
       *  });
       * ```
       * or:
       * ```javascript
       *  let calendar = new Calendar({
       *      features : {
       *          drag : {
       *              // Will resolve on the Calendar
       *              validateMoveFn : 'up.validateMove'
       *          }
       *      },
       *      validateMove{ eventRecord, drag } {
       *          ...
       *      }
       *  });
       * ```
       * @param {Object} info
       * @param {Core.util.drag.DragContext} info.drag The drag create context.
       * @param {Event} info.event The browser event object.
       * @param {Scheduler.model.EventModel} info.eventRecord The Event record.
       * @returns {Boolean} Return `false` if this event change should be rejected.
       * @config {Function|String}
       */
      validateMoveFn: () => {},
      /**
       * An empty function by default that allows you to perform custom validation on the event whose `startDate`
       * or `endDate` is being modified via drag gesture.
       *
       * The `drag` context contains the following data items (see {@link Core.util.drag.DragContext#function-get}):
       *
       *  - `eventDragMode` : The {@link #typedef-CalendarDragMode} object describing the drag operation.
       *  - `eventSourceHit` : The {@link Calendar.view.Calendar#typedef-CalendarHit} object that describes the source of the drag operation.
       *
       * Return `false` to cancel the operation.
       *
       * This function can return a `Promise` (i.e., it can be `async`).
       *
       * Example:
       * ```javascript
       *  let calendar = new Calendar({
       *      features : {
       *          drag : {
       *              async validateResizeFn({ eventRecord, drag }) {
       *                  // This method can be async so it can make ajax requests or interact
       *                  // with the user...
       *
       *                  // if we return false, the event change will be discarded
       *              }
       *          }
       *      }
       *  });
       * ```
       * or:
       * ```javascript
       *  let calendar = new Calendar({
       *      features : {
       *          drag : {
       *              // Will resolve on the Calendar
       *              validateResizeFn : 'up.validateResize'
       *          }
       *      },
       *      validateResize{ eventRecord, drag } {
       *          ...
       *      }
       *  });
       * ```
       * @param {Object} info
       * @param {Core.util.drag.DragContext} info.drag The drag create context.
       * @param {Event} info.event The browser event object.
       * @param {Scheduler.model.EventModel} info.eventRecord The Event record.
       * @returns {Boolean|Promise} Return `false` if this event change should be rejected.
       * @config {Function|String}
       */
      validateResizeFn: () => {},
      zoneTypes: {
        day: DayZone$1,
        // also covers WeekView
        month: MonthZone,
        year: YearZone,
        resource: ResourceViewZone
        // AgendaView is not supported (though it could be a Draggable just not a Droppable)
      }
    };
  }

  changeGripper(gripper, was) {
    was === null || was === void 0 ? void 0 : was.remove();
    return gripper && DomHelper.createElement(gripper);
  }
  changeTooltip(config, existing) {
    if (config) {
      config = config === true ? this.constructor.configurable.tooltip.value : config;
      if (this.initialConfig.tooltip) {
        config.disabled = false;
      }
      config.ownerFeature = this;
    }
    return Widget.reconfigure(existing, config, /* owner = */this);
  }
}
CalendarDrag.initClass();
CalendarDrag._$name = 'CalendarDrag';

/**
 * @module Calendar/widget/EventEditor
 */
/**
 * Provided event editor dialog. This is not supposed to be used directly.
 *
 * Using the {@link Scheduler.feature.EventEdit#config-items items} config of the EventEdit feature
 * it is possible to reconfigure the layout of the event editor. See the {@link Calendar.feature.EventEdit}
 * for more information and an example of doing this.
 *
 * @extends Scheduler/view/EventEditor
 * @typings Scheduler/view/EventEditor -> Scheduler/view/SchedulerEventEditor
 * @private
 */
class EventEditor extends EventEditor$1 {
  //region Config
  static get $name() {
    return 'EventEditor';
  }
  // Factoryable type name
  static get type() {
    return 'calendareventeditor';
  }
  static get configurable() {
    return {
      align: {
        monitorResize: true // Needed because DayView events change size
      }
    };
  }
  //endregion
  updateRecord(record) {
    this.fixTimeFieldVisibility(record.allDay);
    super.updateRecord(record);
  }
  onAllDayChange({
    value,
    userAction
  }) {
    this.fixTimeFieldVisibility(value, userAction);
  }
  fixTimeFieldVisibility(allDay, fromUI) {
    const hideShowMethod = allDay ? 'hide' : 'show',
      addRemoveMethod = allDay ? 'remove' : 'add',
      {
        startDateField,
        startTimeField,
        endDateField,
        endTimeField
      } = this.widgetMap;
    // Times hidden for allDay events
    startTimeField && startTimeField[hideShowMethod]();
    endTimeField && endTimeField[hideShowMethod]();
    // Correct the inline layout to add or remove the margin after the date fields.
    startDateField === null || startDateField === void 0 ? void 0 : startDateField.element.classList[addRemoveMethod]('b-inline');
    endDateField === null || endDateField === void 0 ? void 0 : endDateField.element.classList[addRemoveMethod]('b-inline');
    // Restore the time fields from the underlying data if the UI checkbox is cleared.
    // If the record was promoted to being allDay, the time portion does not get cleared,
    // just the date getters return snapped values. So the underlying data restores the fields
    // to the originally set start and end times so that the save operation will work as expected.
    if (!allDay && fromUI) {
      startDateField && (startDateField.value = startTimeField.value = this.record.getData('startDate'));
      endDateField && (endDateField.value = endTimeField.value = this.record.getData('endDate'));
    }
  }
  onBeforeShow() {
    const {
      deleteButton
    } = this.widgetMap;
    // Superclass has opinions at this time.
    super.onBeforeShow(...arguments);
    // If superclass has not already hidden it for its owm reasons
    // We hide the delete button for newly created events.
    // The cancel button removes it.
    if (deleteButton && !deleteButton.hidden) {
      if (this.record.isCreating) {
        deleteButton.hide();
      }
    }
  }
  onFocusOut() {
    super.onFocusOut(...arguments);
    this.owner = this.initialConfig.owner;
  }
}
// Register this widget type with its Factory
EventEditor.initClass();
EventEditor._$name = 'EventEditor';

/**
 * @module Calendar/feature/EventEdit
 */
/**
 * Feature that displays a popup containing fields for editing event data.
 *
 * To customize its contents you can:
 *
 * * Reconfigure built in widgets by providing override configs in the {@link Scheduler.feature.base.EditBase#config-items} config.
 * * Change the date format of the date & time fields: {@link Scheduler.feature.base.EditBase#config-dateFormat} and {@link Scheduler.feature.base.EditBase#config-timeFormat}
 * * Configure provided fields in the editor and add your own in the {@link Scheduler.feature.base.EditBase#config-items} config.
 * * Remove fields related to recurring events configuration (such as `recurrenceCombo`) by setting {@link Scheduler.feature.mixin.RecurringEventEdit#config-showRecurringUI} config to `false`.
 * * Advanced: Reconfigure the whole editor widget using {@link Scheduler.feature.EventEdit#config-editorConfig}
 *
 * For more info on customizing the event editor, please see [Customize event editor](#Calendar/guides/customization/eventedit.md) guide.
 *
 * @demo Calendar/eventedit
 * @inlineexample Calendar/feature/EventEdit.js
 * @extends Scheduler/feature/EventEdit
 * @classType eventEdit
 * @feature
 *
 * @typings Scheduler/feature/EventEdit -> Scheduler/feature/SchedulerEventEdit
 */
class EventEdit extends EventEdit$1 {
  static get $name() {
    return 'EventEdit';
  }
  static get type() {
    return 'eventEdit';
  }
  static get configurable() {
    return {
      editorConfig: {
        type: 'calendareventeditor',
        items: {
          resourceField: {
            label: 'L{Calendar}',
            showEventColor: true
          },
          allDay: {
            type: 'checkbox',
            cls: 'b-match-label',
            name: 'allDay',
            weight: 250,
            label: 'L{All day}',
            internalListeners: {
              change: 'up.onAllDayChange'
            }
          }
        }
      }
    };
  }
  construct(config) {
    // Legacy constructor signature
    super.construct(config.client, config);
  }
  onDragCreateEnd({
    eventRecord
  }) {
    this.editNewlyCreatedEvent(eventRecord);
  }
  onEventAutoCreated({
    eventRecord
  }) {
    this.editNewlyCreatedEvent(eventRecord);
  }
  editNewlyCreatedEvent(eventRecord) {
    if (!this.disabled) {
      // The Drag feature adds the record so we must set the flag here.
      eventRecord.isCreating = true;
      // Implementations may be async, so the return value must always be propagated.
      return this.editEvent(eventRecord);
    }
  }
  /**
   * Opens an editor for the passed event. This function is exposed on Calendar and can be called as
   * `calendar.editEvent()`.
   *
   * If the event is not present in the `eventStore`, the event will be added so that it becomes
   * visible in the UI. The editor will then shows a "Cancel" button which removes the event when
   * clicked to abort a "New Event" operation.
   * @method editEvent
   * @param {Scheduler.model.EventModel} eventRecord Event to edit
   * @param {Scheduler.model.ResourceModel} [resourceRecord] Not used. Inherited from Scheduler.
   * @param {HTMLElement} [element] Element to anchor editor to (defaults to events element)
   * @async
   * @on-owner
   */
  // editEvent is the single entry point in the base class.
  // Subclass implementations of the action may differ, so are implemented in doEditEvent
  async doEditEvent(eventRecord, resourceRecord, element) {
    var _view$features, _view$features$cellEd, _me$editor;
    const me = this,
      {
        client
      } = me,
      {
        eventStore
      } = client;
    // eventSource is the descendant view that is being interacted with.
    // See Calendar#onViewCatchAll
    // activeSubView is the lowest level active view in the currently visible view in the
    // card layout of the viewContainer.
    // eventSource might be a descendant of the activeView.
    let view = client.eventSource || client.activeSubView,
      // This flag is true if event was created by this feature
      eventAdded = false;
    // If we get this event from a Scheduler view, use superclass's edit process.
    if (view.isScheduler) {
      me.client = view;
      await super.doEditEvent(...arguments);
      me.client = client;
      return;
    }
    // If we get this event from a non-Calendar view, or the view is cell editing, ignore it.
    if (!view.isCalendarMixin || (_view$features = view.features) !== null && _view$features !== void 0 && (_view$features$cellEd = _view$features.cellEdit) !== null && _view$features$cellEd !== void 0 && _view$features$cellEd.isEditing) {
      return;
    }
    if (!DateHelper.intersectSpans(eventRecord.startDate, eventRecord.endDate, view.startDate, view.endDate)) {
      client.date = eventRecord.startDate;
    }
    // Occurrences are *never* added to the eventStore, but any other event being edited,
    // make sure it's in and set the `isCreating` flag to show the Cancel UI.
    if (!eventRecord.isOccurrence && !eventStore.includes(eventRecord)) {
      eventAdded = eventRecord.isCreating = true;
      await eventStore.addAsync(eventRecord);
    }
    // If we've created in a DayView, and we are editing an inter day event, the responsible
    // view is the DayView's alldayEvents row **if there is one, and it's being used**.
    if (view.isAllDayEvent(eventRecord) && view.allDayEvents && view.showAllDayHeader) {
      view = view.allDayEvents;
    }
    // Special handling if editing from an overflow popup
    const {
        _overflowPopup
      } = view,
      activeDate = view.getDateFromElement(element);
    // Get the element for the date into which the element was rendered.
    // AgendaView can render multiple elements for day-spanning events
    // so we must attach to the correct one.
    let fromOverflow = _overflowPopup === null || _overflowPopup === void 0 ? void 0 : _overflowPopup.isVisible,
      eventElement = fromOverflow ? _overflowPopup.getEventElement(eventRecord) : view.getEventElement(eventRecord, activeDate);
    if (fromOverflow) {
      if (eventElement) {
        fromOverflow = false;
      } else {
        eventElement = _overflowPopup.getEventElement(eventRecord);
      }
    }
    // Call Calendar template method
    if (eventRecord.isCreating) {
      var _client$onEventCreate;
      (_client$onEventCreate = client.onEventCreated) === null || _client$onEventCreate === void 0 ? void 0 : _client$onEventCreate.call(client, eventRecord);
    }
    // If called from eventlist
    if (!eventElement && view.isEventList) {
      var _view, _view$rowManager, _view$rowManager$getR;
      eventElement = (_view = view) === null || _view === void 0 ? void 0 : (_view$rowManager = _view.rowManager) === null || _view$rowManager === void 0 ? void 0 : (_view$rowManager$getR = _view$rowManager.getRowFor(eventRecord)) === null || _view$rowManager$getR === void 0 ? void 0 : _view$rowManager$getR.element;
    }
    // This flag is meant to prevent scrolling the element into the view if we dragcreate event and scroll the
    // view in the process. If we're creating event, then check if event was already added. If event was not
    // created allow scrolling - we haven't dragcreated event and should try to scroll to the element
    const scrollingAllowed = eventElement && !DomHelper.isInView(eventElement) || !eventRecord.isCreating || !eventAdded;
    // If editing triggered from overflow popup, ensure that the eventElement is focused.
    if (fromOverflow) {
      eventElement.focus();
    } else if (eventElement) {
      var _view$scrollable;
      if (scrollingAllowed && (_view$scrollable = view.scrollable) !== null && _view$scrollable !== void 0 && _view$scrollable.hasOverflow()) {
        var _view$scrollable2;
        // If we found a rendered element, just ensure it is visible in the scroll viewport
        await ((_view$scrollable2 = view.scrollable) === null || _view$scrollable2 === void 0 ? void 0 : _view$scrollable2.scrollIntoView(eventElement, {
          animate: true,
          focus: true
        }));
      } else {
        DomHelper.focusWithoutScrolling(eventElement);
      }
    }
    // If no element found, then we have to ask the view to navigate in time to encompass that event
    else {
      // If it's a single day event on a hidden, non working day, show it centered.
      // align : { target : true } means centered.
      if (!view.isAllDayEvent(eventRecord) && view.hiddenNonWorkingDays[eventRecord.startDate.getDay()]) {
        me.internalShowEditor(eventRecord, null, {
          target: true
        });
        return;
      }
      if (scrollingAllowed) {
        // Ensure we have an in-view element to align to - data change response is async.
        // scrollTo refreshes if the element is not present
        await view.scrollTo(eventRecord);
      } else {
        // If eventElement does not exist and we don't wait for view to scroll to the event record, we
        // should wait for the next refresh to make sure event element will appear
        await view.await('refresh', false);
      }
      // scrollTo might have to refresh to create the target.
      eventElement = view.getEventElement(eventRecord);
    }
    // If event element is missing and we render days (month, year), try to align editor to the date
    if (!eventElement && !element && view.isDayCellRenderer) {
      eventElement = view.getCell(eventRecord.startDate);
    }
    me.internalShowEditor(eventRecord, null, {
      target: eventElement || element,
      allowTargetOut: view.isAnimating
    });
    // Only on first show do we ignore clipping.
    // If target is scrolled out of view, editor must hide.
    if ((_me$editor = me.editor) !== null && _me$editor !== void 0 && _me$editor.lastAlignSpec) {
      me.editor.lastAlignSpec.allowTargetOut = false;
    }
  }
  async onSaveClick() {
    const me = this,
      {
        eventRecord
      } = me,
      {
        isCreating
      } = eventRecord.meta;
    if (me.isValid) {
      eventRecord.isCreating = false;
    }
    // So that resetting editing context doesn't remove the record
    const saved = await super.onSaveClick(...arguments);
    if (isCreating && saved) {
      var _me$client$crudManage;
      me.eventStore.added.add(eventRecord);
      if (!me.eventStore.usesSingleAssignment) {
        me.assignmentStore.added.add(eventRecord.assignments);
      }
      if ((_me$client$crudManage = me.client.crudManager) !== null && _me$client$crudManage !== void 0 && _me$client$crudManage.autoSync) {
        me.client.crudManager.scheduleAutoSync();
      }
    }
  }
  internalShowEditor() {
    var _client$activeView$au, _client$activeView, _client$features$even, _client$features$even2;
    const {
        client,
        startTimeField,
        endTimeField,
        editor
      } = this,
      autoCreate = (_client$activeView$au = (_client$activeView = client.activeView) === null || _client$activeView === void 0 ? void 0 : _client$activeView.autoCreate) !== null && _client$activeView$au !== void 0 ? _client$activeView$au : client.autoCreate || client.constructor.configurable.autoCreate,
      step = autoCreate === null || autoCreate === void 0 ? void 0 : autoCreate.step,
      {
        activeSubView
      } = client,
      _overflowPopup = activeSubView === null || activeSubView === void 0 ? void 0 : activeSubView._overflowPopup;
    // In case the tooltip is visible, we must hide it.
    // This reverts focus so that we pick up focusIn from the event.
    (_client$features$even = client.features.eventTooltip) === null || _client$features$even === void 0 ? void 0 : (_client$features$even2 = _client$features$even._tooltip) === null || _client$features$even2 === void 0 ? void 0 : _client$features$even2.hide();
    // Always hook the closest owning widget as our owner because there may be intervening
    // focused widgets between the Calendar (our default), and us.
    // For example, the all day row of a DayView may show an OverflowPopup. We have
    // to be owned by the OverflowPopup so that our owner chain is correct.
    editor.owner = _overflowPopup !== null && _overflowPopup !== void 0 && _overflowPopup.isVisible ? _overflowPopup : activeSubView;
    if (super.internalShowEditor(...arguments) === false) {
      // Editing was vetoed
      editor.owner = editor.initialConfig.owner;
      return;
    }
    if (step) {
      startTimeField && (startTimeField.step = step);
      endTimeField && (endTimeField.step = step);
    }
  }
}
// Register this feature type with its Factory
CalendarFeature.register(EventEdit.type, EventEdit);
EventEdit._$name = 'EventEdit';

/**
 * @module Calendar/feature/EventMenu
 */
const hasEventStore$2 = w => w.eventStore;
/**
 * A feature which adds a context menu to the events in the calendar.
 *
 * There are three predefined {@link #config-items} provided by default:
 *
 * - `deleteEvent` Delete the event clicked upon.
 * - `editEvent` Edit the event clicked upon __Only present if the {@link Calendar.feature.EventEdit}
 * feature is present__ (which it is by default).
 * - `duplicate` Duplicate the event clicked upon with the same time and duration, the same
 * resource(s) assigned and a slightly edited name - `"<old name> (copy)"`.
 *
 * The {@link #config-items} set can be reconfigured by providing an `items` property to this feature:
 *
 *```javascript
 * features : {
 *     eventMenu : {
 *         items : {
 *             // Knocks out the predefined deleteEvent item
 *             deleteEvent : null,
 *
 *             // Add our own custom item
 *             myMenuItem : {
 *                  icon    : 'b-fa b-fa-clone',
 *                  text    : 'Duplicate event',
 *
 *                  // Will look up ownership chain and find the Calendar
 *                  handler : 'up.duplicateEvent'
 *             }
 *         }
 *     }
 * },
 * duplicateEvent({ eventRecord }) {
 *     const dupe = eventRecord.copy();
 *
 *     // In case it was a recurring event, the dupe will be a one-off.
 *     dupe.recurrence = null;
 *     this.eventStore.add(dupe);
 * }
 *```
 *
 * This feature is enabled by default.
 *
 * @demo Calendar/custom-menus
 * @extends Scheduler/feature/EventMenu
 * @classType eventMenu
 * @feature
 *
 * @typings Scheduler/feature/EventMenu -> Scheduler/feature/SchedulerEventMenu
 */
class EventMenu extends EventMenu$1 {
  // Do not remove. Assertion strings for Localization sanity check.
  // 'L{copy}'
  // 'L{duplicateEvent}'
  static get $name() {
    return 'EventMenu';
  }
  static get type() {
    return 'eventMenu';
  }
  // Superclass registers this as a chained function.
  populateEventMenu({
    items,
    eventRecord,
    assignmentRecord
  }) {
    super.populateEventMenu(...arguments);
    const {
      client
    } = this;
    // Hide the duplicate
    items.duplicate = {
      disabled: eventRecord.readOnly || (assignmentRecord === null || assignmentRecord === void 0 ? void 0 : assignmentRecord.readOnly),
      hidden: client.readOnly
    };
  }
  getDataFromEvent(event) {
    const {
        client
      } = this,
      {
        activeView
      } = client;
    // Base class is SchedulerEventMenu
    if (activeView.isScheduler) {
      this.client = activeView;
    }
    const result = super.getDataFromEvent(event);
    this.client = client;
    return result;
  }
  changeMenu() {
    const me = this,
      result = super.changeMenu(...arguments);
    // Set the owner to be the currently active view (or its active OverflowPopup)
    // so that focus stays in that view's ownership tree.
    result === null || result === void 0 ? void 0 : result.ion({
      beforeShow({
        source
      }) {
        const {
            activeSubView
          } = me.client,
          {
            _overflowPopup
          } = activeSubView;
        source.owner = _overflowPopup !== null && _overflowPopup !== void 0 && _overflowPopup.containsFocus ? _overflowPopup : activeSubView;
      }
    });
    return result;
  }
  changeItems(items) {
    items = super.changeItems(...arguments);
    // UnassignEvent is not valid where there is no contextual resource as there is in Scheduler where
    // the row denotes the contextual resource
    items.unassignEvent = null;
    return items;
  }
}
// Register this feature type with its Factory
_defineProperty(EventMenu, "configurable", {
  items: {
    duplicate: {
      text: 'L{EventMenu.duplicateEvent}',
      icon: 'b-icon b-icon-copy',
      weight: 400,
      onItem({
        eventRecord
      }) {
        const dupe = eventRecord.copy(null, {
            skipFieldIdentifiers: true
          }),
          {
            eventStore
          } = this.up(hasEventStore$2),
          {
            resources
          } = eventRecord;
        // Make a new name
        dupe.name = `${eventRecord.name} (${this.L('copy')})`;
        // In case it was a recurring event, the dupe will be a one-off.
        dupe.recurrence = null;
        // Dupe has same assignments initially handle usesSingleAssign as well as multiassign.
        // If an event without a resource is duplicated
        if (resources !== null && resources !== void 0 && resources.length) {
          eventStore.assignmentStore.assignEventToResource(dupe, resources);
        }
        eventStore.add(dupe);
      }
    }
  }
});
CalendarFeature.register(EventMenu.type, EventMenu);
EventMenu._$name = 'EventMenu';

/**
 * @module Calendar/feature/EventTooltip
 */
const hasEventStore$1 = w => w.eventStore,
  ownConfigs = ['activeElement', 'client', 'clientListeners', 'disabled', 'showOn', 'tooltip'];
/**
 * A feature which displays a {@link #config-tooltip} containing extra information. The tooltip can
 * be triggered by clicking or hovering an event bar element (see {@link #config-showOn}).
 *
 * ```javascript
 * new Calendar({
 *    features : {
 *        eventTooltip : {
 *            tooltip : {
 *                tools : {
 *                    // Do not show the Delete tool in the tooltip header
 *                    delete : false,
 *                    // Add a new tool for our own operation
 *                    newTool : {
 *                        cls     : 'b-icon-add',
 *                        tooltip : 'Test',
 *                        handler() {
 *                            console.log(`Test ${this.eventRecord.name}`);
 *                        }
 *                    }
 *                }
 *            }
 *        }
 *    }
 * })
 * ```
 *
 * You can hide tools conditionally:
 * ```javascript
 * new Calendar({
 *     features : {
 *         eventTooltip : {
 *             listeners : {
 *                 beforeShow({ source }) {
 *                     source.tools.delete = false;
 *                 }
 *             }
 *         }
 *     }
 * })
 * ```
 *
 * @demo Calendar/tooltips
 * @inlineexample Calendar/feature/EventTooltip.js
 * @extends Calendar/feature/CalendarFeature
 * @classType eventTooltip
 * @feature
 *
 * @typings Scheduler/feature/EventTooltip -> Scheduler/feature/SchedulerEventTooltip
 */
class EventTooltip extends CalendarFeature {
  static get $name() {
    return 'EventTooltip';
  }
  static get type() {
    return 'eventTooltip';
  }
  static get configurable() {
    return {
      /**
       * The gesture which activates the event tooltip. Defaults to `'click'`, but may be set to
       * `'contextmenu'` or `'mouseover`'. The tip persists until closed.
       *
       * If set to `'hover'`, the tip shows on mouseover and hides on mouseout.
       *
       * If set to `'contextmenu'`, the tip shows at the mouse/touch contact point, otherwise
       * it aligns to the target event bar.
       * @config {'click'|'contextmenu'|'mouseover'|'hover'}
       * @default
       */
      showOn: 'click',
      closable: true,
      // Allow it to fall back from its initial alignment axis to the cross axis.
      // So if aligned l-r or r-l and shown by a long multiday event, it allows
      // itself to be fall back to being aligned t-b
      axisLock: 'flexible',
      /**
       * Gets the Tooltip instance that this feature is using.
       * @member {Calendar.widget.EventTip} tooltip
       * @readonly
       */
      /**
       * This config is used to directly configure the associated {@link Calendar.widget.EventTip tooltip}.
       * @config {Calendar.widget.EventTip}
       */
      tooltip: {
        $config: ['lazy', 'nullify'],
        value: {
          type: 'eventTip',
          // Event elements may dynamically change width in DayView. Must maintain alignment.
          align: {
            monitorResize: true
          }
        }
      },
      /**
       * A function, or the *name* of a function which, when passed the active
       * {@link Scheduler.model.EventModel}, returns a value to use as the tooltip's
       * {@link Core.widget.Panel#config-title}.
       *
       * The function may return either an HTML string, or a {@link DomConfig} object.
       * _Defaults to using the event `name`_
       * @config {Function|String}
       */
      titleRenderer: eventRecord => StringHelper.encodeHtml(eventRecord.name),
      /**
       * A function, or the *name* of a function called to update the tooltip's content when the
       * cursor is moved over a target.
       *
       * It receives one argument containing context about the tooltip and show operation.
       * The function may return either an HTML string, or a {@link DomConfig} object, or
       * a Promise yielding one of these.
       *
       * ```javascript
       * new Calendar({
       *     features : {
       *         eventTooltip : {
       *             renderer : 'up.getEventTip'
       *         }
       *     },
       *     getEventTip({ eventRecord }) {
       *         return {
       *             className : 'tooltip-content',
       *             text      : eventRecord.name
       *         }
       *     }
       * });
       * ```
       *
       * or
       *
       * ```javascript
       * new Calendar({
       *     features : {
       *         eventTooltip : {
       *             renderer : 'up.getEventTip'
       *         }
       *     },
       *     getEventTip({ eventRecord }) {
       *         return '<div class="tooltip-content> + eventRecord.name + '</div>';
       *     }
       * });
       * ```
       *
       * or
       *
       * ```javascript
       * new Calendar({
       *     features : {
       *         eventTooltip : {
       *             renderer : 'up.getEventTip'
       *         }
       *     },
       *     getEventTip : async function({ eventRecord }) {
       *         // Use a web service which returns a JSON DomConfig block
       *         const response = await fetch(`getEventTipContent?event=${eventRecord.id}`);
       *         return response.json();
       *     }
       * });
       * ```
       * @param {Object} context
       * @param {Scheduler.model.EventModel} context.eventRecord The event record which the tooltip is being shown for.
       * @param {Core.widget.Tooltip} context.tip The tooltip instance
       * @param {HTMLElement} context.element The Element for which the Tooltip is monitoring mouse movement
       * @param {HTMLElement} context.activeTarget The target element that triggered the show
       * @param {Event} context.event The raw DOM event
       * @returns {String|Promise|DomConfig}
       * @config {Function|String}
       */
      renderer: null,
      /**
       * This config is used to directly configure the associated recurrence confirmation popup used
       * when a delete is requested.
       * @config {RecurrenceConfirmationPopupConfig}
       * @private
       */
      recurrenceConfirmation: {
        $config: ['lazy', 'nullify'],
        value: {
          type: 'recurrenceconfirmation'
        }
      },
      /**
       * By default, the end date of an all day event is displayed in the tooltip UI as
       * the last calendar date on which the event falls. For most end users, this is the
       * expected value.
       *
       * Technically, the {@link Scheduler.model.EventModel#field-endDate} is a timestamp
       * which represents the exact point in time at which an event ends. To use this instead,
       * configure `extendAllDayEndDay` as `true`.
       *
       * To be clear, this would mean that an {@link Scheduler.model.EventModel#field-allDay}
       * event starting and ending on the 7th of February 2020, would show the end date in the
       * tooltip as 8th of February 2020.
       * @config {Boolean}
       * @default false
       */
      extendAllDayEndDay: null,
      /**
       * Defines how to align the EventTooltip to its event.
       *
       * The value can be either a simple string or a full configuration object.
       *
       * When using a simple string, the format is `'[trblc]n-[trblc]n'` and it specifies tooltip edge and
       * the event edge plus optional offsets from 0 to 100 along the edges to align to. Also supports direction
       * independent edges horizontally, `s` for start and `e` for end (maps to `l` and `r` for LTR, `r` and `l`
       * for RTL).
       *
       * For more details about using the object form, see {@link Core.widget.Widget#function-showBy}.
       *
       * Once set, this is stored internally in object form.
       * @config {AlignSpec|String} align
       * @default 't-b'
       */
      align: null
    };
  }
  static get pluginConfig() {
    return {
      chain: ['render']
    };
  }
  // Because we insert ourself into the owner hierarchy, isVisible consults us
  get isVisible() {
    return true;
  }
  changeRecurrenceConfirmation(recurrenceConfirmation, existingInstance) {
    if (recurrenceConfirmation) {
      recurrenceConfirmation.rootElement = this.owner.rootElement;
    }
    return Widget.reconfigure(existingInstance, recurrenceConfirmation, {
      owner: this
    });
  }
  changeTooltip(config, existingInstance) {
    return Widget.reconfigure(existingInstance, config, {
      owner: this,
      setup: 'setupTooltip'
    });
  }
  setupTooltip(config) {
    const me = this,
      ret = me.config;
    ownConfigs.forEach(c => delete ret[c]);
    return EventTip.mergeConfigs(ret, {
      ownerFeature: me,
      id: `${me.client.id}-event-tip`,
      forSelector: me.showOn === 'hover' && '.b-cal-event-wrap:not(.b-editing)',
      cls: {
        'b-eventedit': me.client.features.eventEdit
      },
      disabled: me.disabled,
      internalListeners: {
        thisObj: me,
        delete: 'onDeleteClick',
        edit: 'onEditClick',
        pointerOver: 'onTipPointerOver'
      }
    }, config);
  }
  render() {
    const me = this,
      clientListeners = {
        eventsPerCellChange: 'onClientEventsPerCellChange',
        navigate: 'onClientNavigate',
        thisObj: me
      };
    if (me.showOn === 'hover') {
      // The tooltip needs to exist to take care of its own show/hide lifecycle if
      // we are configured to use the hover gesture.
      me.getConfig('tooltip');
    } else {
      clientListeners[`event${me.showOn}`] = 'onClientTooltipGesture';
    }
    me.client.ion(clientListeners);
  }
  get owner() {
    var _this$client$activeVi;
    if ((_this$client$activeVi = this.client.activeView._overflowPopup) !== null && _this$client$activeVi !== void 0 && _this$client$activeVi.containsFocus) {
      return this.client.activeView.overflowPopup;
    } else {
      return this.client;
    }
  }
  //region Events
  addListener(...args) {
    var _this$tooltip;
    // Add listener to the `tooltip` instance
    (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.addListener(...args);
  }
  removeListener(...args) {
    var _this$tooltip2;
    // Remove listener from the `tooltip` instance
    (_this$tooltip2 = this.tooltip) === null || _this$tooltip2 === void 0 ? void 0 : _this$tooltip2.removeListener(...args);
  }
  onEditClick() {
    var _activeClient$feature, _overflowPopup$elemen;
    const {
        client,
        activeClient,
        tooltip
      } = this,
      {
        overflowPopup
      } = activeClient,
      eventEdit = (activeClient === null || activeClient === void 0 ? void 0 : (_activeClient$feature = activeClient.features) === null || _activeClient$feature === void 0 ? void 0 : _activeClient$feature.eventEdit) || client.features.eventEdit,
      fromPopup = overflowPopup === null || overflowPopup === void 0 ? void 0 : (_overflowPopup$elemen = overflowPopup.element) === null || _overflowPopup$elemen === void 0 ? void 0 : _overflowPopup$elemen.contains(tooltip.activeTarget),
      target = fromPopup ? overflowPopup.targetCell : tooltip.activeTarget;
    if (eventEdit && !eventEdit.disabled) {
      eventEdit.editEvent(this.eventRecord, null, target);
      tooltip.hide();
    }
  }
  onDeleteClick() {
    this.activeClient.calendar.removeEvents([this.eventRecord], () => {
      var _this$tooltip3;
      return (_this$tooltip3 = this.tooltip) === null || _this$tooltip3 === void 0 ? void 0 : _this$tooltip3.hide();
    }, this.tooltip);
  }
  onClientEventsPerCellChange() {
    var _this$_tooltip, _this$_tooltip2;
    // Overflow popup hides on this, so we must hide too.
    // Access the property directly so as not to create the tooltip.
    // We got here through a ResizeObserver so we must allow the notification to reach the
    // overflow popup before it hides to avoid the nonsensically fatal
    // "ResizeObserver loop completed with undelivered notifications" on FF.
    // Delayable.requestAnimationFrame uses itself as the thisObj,
    // so using the function reference will work.
    (_this$_tooltip = this._tooltip) === null || _this$_tooltip === void 0 ? void 0 : _this$_tooltip.requestAnimationFrame((_this$_tooltip2 = this._tooltip) === null || _this$_tooltip2 === void 0 ? void 0 : _this$_tooltip2.hide);
  }
  onClientNavigate(navEvent) {
    var _navEvent$event;
    // Access the property directly so as not to create the tooltip
    const {
      _tooltip
    } = this;
    // If we are exiting the calendar or navigating to a new item that is not in the tooltip, hide the tooltip
    if (_tooltip !== null && _tooltip !== void 0 && _tooltip.activeTarget && (!this.owner.owns(navEvent.event) || navEvent.item !== _tooltip.activeTarget) && !_tooltip.owns((_navEvent$event = navEvent.event) === null || _navEvent$event === void 0 ? void 0 : _navEvent$event.relatedTarget)) {
      _tooltip.hide();
    }
  }
  onClientTooltipGesture({
    domEvent,
    event,
    eventElement,
    eventRecord,
    source: owningCalendarWidget
  }) {
    const {
      tooltip
    } = this;
    // Foreign objects (like a Scheduler) may not use "domEvent", so fallback to "event" if necessary:
    domEvent = domEvent || event;
    // Pass already known parts from the Widget gesture into onTipPointerOver
    if (this.onTipPointerOver({
      event: domEvent,
      target: eventElement,
      eventRecord,
      owningCalendarWidget
    }) !== false) {
      // If the event is part of a cluster (overlaps others, and will expand)
      // and tooltip is aligned to the side, then delay the show to avoid a realign after expand.
      if (eventElement.classList.contains('b-cal-in-cluster') && parseAlign(tooltip.align.align).edgeAligned === 2) {
        tooltip.setTimeout({
          fn: 'showByEvent',
          args: [domEvent, eventElement],
          delay: 130
        });
      } else {
        tooltip.showByEvent(domEvent, eventElement);
      }
    }
  }
  onTipPointerOver({
    target,
    owningCalendarWidget,
    eventRecord
  }) {
    var _this$client$features, _this$client$features2;
    if (!owningCalendarWidget) {
      var _Widget$fromElement;
      owningCalendarWidget = (_Widget$fromElement = Widget.fromElement(target)) === null || _Widget$fromElement === void 0 ? void 0 : _Widget$fromElement.closest(hasEventStore$1);
    }
    if (!eventRecord) {
      eventRecord = owningCalendarWidget.getEventRecord(target);
    }
    if ((_this$client$features = this.client.features) !== null && _this$client$features !== void 0 && (_this$client$features2 = _this$client$features.eventEdit) !== null && _this$client$features2 !== void 0 && _this$client$features2.isEditing) {
      return false;
    }
    if (owningCalendarWidget) {
      this.tooltip.activeTarget = target;
      this.activeClient = owningCalendarWidget;
      eventRecord = owningCalendarWidget.getEventRecord(target);
      /**
       * The event which the tooltip feature has been activated for.
       * @member {Scheduler.model.EventModel} eventRecord
       * @readonly
       */
      this.tooltip.eventRecord = this.eventRecord = eventRecord;
    }
    return eventRecord != null;
  }
  //endregion
  //region Internal
  updateDisabled(disabled, was) {
    super.updateDisabled(disabled, was);
    if (this._tooltip) {
      this._tooltip.disabled = disabled;
    }
  }
  //endregion
}
// Register this feature type with its Factory
EventTooltip.initClass();
EventTooltip._$name = 'EventTooltip';

/**
 * @module Calendar/feature/ExternalEventSource
 */
const oneHour = {
  magnitude: 1,
  unit: 'hour'
};
class ExternalZone extends Base.mixin(Draggable) {
  static get configurable() {
    return {
      // Default to dragging grid rows
      dragItemSelector: '.b-grid-row',
      droppable: false,
      dragProxy: {
        type: 'default',
        open(drag) {
          // Use the Feature's openProxy
          return this.owner.owner.openProxy(drag);
        },
        dragMove(drag) {
          // Use the Feature's moveProxy
          return this.owner.owner.moveProxy(drag);
        },
        close() {
          var _this$owner$owner$pro;
          (_this$owner$owner$pro = this.owner.owner.proxyEl) === null || _this$owner$owner$pro === void 0 ? void 0 : _this$owner$owner$pro.remove();
        }
      }
    };
  }
  beforeDrag(drag) {
    return this.owner.onDragStart(drag);
  }
}
/**
 * A Calendar feature which allows new events to be dragged into the Calendar from an external source.
 *
 * The default source type is a Bryntum {@link Grid.view.Grid grid} which is loaded with
 * {@link Scheduler.model.EventModel event records}.
 *
 * Optionally, the source can be specified by configuring a {@link #config-dragRootElement}
 * and a {@link #config-dragItemSelector} which together, identify elements which represent
 * draggable events.
 *
 * In this case, a {@link #config-getRecordFromElement} may be specified to yield the details of
 * the record to be dragged.
 *
 * In the simplest case the `textContent` of the identified element is used as the event name and
 * {@link #config-getRecordFromElement} is not required. The event duration in this case will be
 * that specified in the receiving Calendar's {@link Calendar.view.Calendar#config-autoCreate} setting.
 *
 * When dropping an unscheduled event (An event that has no start and end date specified) into
 * a day cell (For example a MonthView or YearView), the start *time* set within the day cell
 * will default to the `startHour` property of the receiving Calendar's {@link Calendar.view.Calendar#config-autoCreate} setting.
 *
 * @demo Calendar/dragfromgrid
 * @inlineexample Calendar/feature/ExternalEventSource.js
 * @extends Calendar/feature/CalendarFeature
 * @classType externalEventSource
 * @feature
 */
class ExternalEventSource extends CalendarFeature.mixin(Delayable) {
  static get $name() {
    return 'ExternalEventSource';
  }
  static get delayable() {
    return {
      onCalendarPaint: 'raf'
    };
  }
  static get type() {
    return 'externalEventSource';
  }
  static get configurable() {
    return {
      /**
       * The grid, or `id` of a grid from which events are to be dragged.
       * @config {Grid.view.Grid|String}
       */
      grid: {
        $config: ['lazy'],
        value: null
      },
      /**
       * If not dragging from a grid, which is the default mode, then an element from which
       * dragging can take place must be supplied in the `dragRootElement` config.
       *
       * May also be specified as a selector which matches a unique element, or a simple element id.
       *
       * In this case a {@link #config-dragItemSelector} string, and {@link #config-getRecordFromElement}
       * function must be supplied to allow event records to be sourced from the element, for example:
       *
       * ```javascript
       * features : {
       *     externalEventSource : {
       *         dragRootElement  : '#mySourceElementId',
       *         dragItemSelector : '.my-item-class'
       *     }
       * }```
       * @config {HTMLElement|String}
       */
      dragRootElement: null,
      /**
       * If not dragging from a grid, which is the default mode, then a selector which identifies
       * draggable elements within the {@link #config-dragRootElement}.
       *
       * In the simplest case, the identified element may contain simply a string which is used
       * as the event name, for example:
       *
       * ```javascript
       * features : {
       *     externalEventSource : {
       *         dragRootElement  : '#mySourceElementId',
       *         dragItemSelector : '.my-item-class'
       *     }
       * }```
       * @config {String}
       */
      dragItemSelector: null,
      /**
       * If not dragging from a grid, which is the default mode, then a function which returns
       * an event record to drag from a passed element must be supplied.
       *
       * In this case a {@link #config-dragRootElement} and a {@link #config-dragItemSelector} string
       * may be supplied to allow event records to be sourced from the element.
       *
       * If the element identified by the {@link #config-dragItemSelector} just contains an event
       * name to create, this configuration is optional. A new event will be created by that name, for example:
       *
       * ```javascript
       * features : {
       *     externalEventSource : {
       *         dragRootElement  : '#mySourceElementId',
       *         dragItemSelector : '.my-item-class',
       *         getRecordFromElement(element) {
       *             // Return an object from which an EventModel can be created.
       *             // Same format as loading an EventStore. { name : 'name', startDate: ''} etc
       *             return myController.createRecordFromElement(element);
       *         }
       *     }
       * }```
       * @config {Function|String}
       */
      getRecordFromElement: function (element) {
        const grid = this.grid || (this.grid = Widget.fromElement(element, 'grid'));
        if (grid) {
          return grid.getRecordFromElement(element);
        }
        // The simplest implementation is that the elements identified by
        // the selector yield the event name.
        return element.innerText;
      },
      /**
       * By default, the proxy shown when "picking up" the grid row is hidden
       * when dragging over the calendar because the {@link Calendar.feature.CalendarDrag}
       * feature automatically shows a drop position indicator which shows where the
       * proposed new event will be.
       * @config {Boolean}
       * @default
       */
      hideExternalProxy: true,
      /**
       * An object which overrides or augments the default configuration for the
       * {@link Core.mixin.Draggable} which handles picking up events.
       *
       * This is only necessary if there is no {@link #config-grid} specified.
       * @config {Object} [draggable]
       * @default
       */
      draggable: {
        $config: ['lazy'],
        value: {}
      }
    };
  }
  // This is deferred to the next AF to allow the configured grid ID to be available
  onCalendarPaint({
    firstPaint
  }) {
    // Ingestion of Draggable, and within that, grid is deferred until the host Calendar is painted
    if (firstPaint) {
      this.getConfig('draggable');
    }
  }
  onDragStart(drag) {
    var _me$grid;
    const me = this,
      {
        client
      } = me,
      {
        eventStore
      } = client,
      {
        modelClass
      } = eventStore;
    // If mousedown was not on our Draggable's dragItemSelector, veto drag start
    if (!drag.itemElement) {
      return false;
    }
    let eventRecord = me.callback(me.getRecordFromElement, me, [drag.itemElement]);
    if (eventRecord.isModel) {
      if (!eventRecord.isEventModel) {
        eventRecord = eventStore.createRecord(eventRecord.data);
      }
    } else {
      if (typeof eventRecord === 'string') {
        const autoCreate = client.activeView.autoCreate || client.autoCreate,
          duration = DateHelper.parseDuration((autoCreate === null || autoCreate === void 0 ? void 0 : autoCreate.duration) || oneHour);
        eventRecord = {
          [modelClass.getFieldDataSource('name')]: eventRecord,
          [modelClass.getFieldDataSource('duration')]: duration.magnitude,
          [modelClass.getFieldDataSource('durationUnit')]: duration.unit
        };
      }
      eventRecord = eventStore.createRecord(eventRecord);
    }
    drag.set('sourceStore', (_me$grid = me.grid) === null || _me$grid === void 0 ? void 0 : _me$grid.store);
    drag.set('eventRecord', eventRecord);
  }
  openProxy(drag) {
    const {
        grid
      } = this,
      sourceEl = drag.element.closest(this.draggable.dragItemSelector),
      nameCell = sourceEl.querySelector('[data-column="name"]'),
      proxyEl = this.proxyEl = DomHelper.createElement({
        className: 'b-grid-to-cal-drag-proxy'
      });
    proxyEl.innerHTML = nameCell ? nameCell.innerHTML : drag.peek('eventRecord').name;
    this.proxyOffset = EventHelper.getClientPoint(drag.startEvent).getDelta(Rectangle.from(sourceEl));
    ((grid === null || grid === void 0 ? void 0 : grid.element) || this.dragRootElement).parentNode.appendChild(proxyEl);
  }
  moveProxy(drag) {
    const {
      proxyEl
    } = this;
    if (proxyEl) {
      // Hide the proxy if the target droppable is a Calendar and we are configured to do so
      if (this.client.owns(drag.targetElement) && this.hideExternalProxy) {
        proxyEl.classList.add('b-hide-display');
      } else {
        // Align the proxy to [10, 10] from the pointer
        proxyEl.classList.remove('b-hide-display');
        DomHelper.alignTo(proxyEl, EventHelper.getClientPoint(drag.event).translate(10, 10), {
          align: 't0-t0'
        });
      }
    }
  }
  changeDragRootElement(dragRootElement) {
    if (typeof dragRootElement === 'string') {
      dragRootElement = document.querySelector(dragRootElement) || document.getElementById(dragRootElement);
    }
    return dragRootElement;
  }
  changeDraggable(draggable) {
    const {
        grid
      } = this,
      dragRootElement = (grid === null || grid === void 0 ? void 0 : grid.contentElement) || this.dragRootElement,
      {
        dragItemSelector
      } = this;
    draggable = ExternalEventSource.mergeConfigs({
      owner: this,
      grid
    }, draggable);
    if (dragRootElement) {
      draggable.dragRootElement = dragRootElement;
    }
    if (dragItemSelector) {
      draggable.dragItemSelector = dragItemSelector;
    }
    return new ExternalZone(draggable);
  }
  changeGrid(grid) {
    if (typeof grid === 'string') {
      grid = Widget.getById(grid);
    }
    return grid;
  }
}
ExternalEventSource.initClass();
ExternalEventSource._$name = 'ExternalEventSource';

/**
 * @module Calendar/feature/LoadOnDemand
 */
/**
 * Loads the host Calendar's {@link Scheduler.view.mixin.SchedulerStores#config-crudManager CrudManager} on demand
 * as the date range required to produce the UI changes.
 *
 * Passes the requested `startDate` and `endDate` as extra HTTP parameters along with the load request.
 *
 * By default, the HTTP parameters are called `'startDate'` and `'endDate'`. This is configurable using the
 * {@link #config-startDateParamName} and {@link #config-endDateParamName} configs.
 *
 * The date values are formatted according to the {@link #config-dateFormat} config.
 *
 * Usage:
 *
 * ```javascript
 * new Calendar({
 *     features : {
 *         loadOnDemand : true
 *     }
 * });
 * ```
 *
 * ## Using recurring events
 * When using this feature when recurring events are in the database, *all recurring events* which
 * started before the requested start date, and have not yet finished recurring MUST be sent as part
 * of the return packet so that the Calendar is able to populate its UI.
 *
 * Only the base recurring event *definition* is stored in the Calendar's EventStore.
 *
 * When asked to yield a set of events for a certain date range for creating a UI, the EventStore
 * *automatically* interpolates any occurrences of recurring events into the results. They do not
 * occupy slots in the EventStore for every date in their repetition range (that would be very
 * inefficient, and *might* be infinite).
 *
 * ## Handling data load failures
 * If a network or server error is detected, the {@link Calendar.view.Calendar} will fire a
 * {@link #event-loadOnDemandFail} event so that an application can produce an error UI and
 * handle the situation.
 *
 * A handler should return `false` to prevent the default provided error UI from showing.
 *
 * If there is no handler, or the handler __does not__ return `false`, a default error UI is
 * shown using `{@link Core.widget.MessageDialog#function-alert MessageDialog}`.
 *
 * @extends Calendar/feature/CalendarFeature
 * @classType loadOnDemand
 * @feature
 */
class LoadOnDemand extends CalendarFeature {
  static get configurable() {
    return {
      /**
       * The name of the HTTP parameter which contains the start date of the view requiring new data.
       * @config {String}
       * @default
       */
      startDateParamName: 'startDate',
      /**
       * The name of the HTTP parameter which contains the end date of the view requiring new data.
       * @config {String}
       * @default
       */
      endDateParamName: 'endDate',
      /**
       * The {@link Core.helper.DateHelper#function-format-static DateHelper} format string to use to
       * encode the start date end end date of the events to load when the view requires a new date range.
       * @config {String}
       * @default
       */
      dateFormat: 'YYYY-MM-DD',
      /**
       * A function, or name of a function in the ownership hierarchy which may be called
       * to mutate the `options` packet that is passed to the {@link Scheduler.data.CrudManager}
       * {@link Scheduler.crud.AbstractCrudManagerMixin#function-load} method.
       * @config {Function|String}
       * @param {Object} options The `options` parameter to be sent to the {@link Scheduler.data.CrudManager}
       * {@link Scheduler.crud.AbstractCrudManagerMixin#function-load} method.
       * One possible use of this function is to mutate the `options.request.params` object to add extra
       * parameters for the server.
       */
      beforeRequest: null,
      /**
       * By default, if a view requests a date range that we have already loaded, no
       * network request is made, and the events will be loaded from the current content
       * of the event store.
       *
       * To make the feature load a new event block on every request for a __new__ date range,
       * configure this as `true`.
       * @config {Boolean}
       * @default false
       */
      alwaysLoadNewRange: null,
      /**
       * Configure this as `true` to clear the event store when a new date range has been requested
       * instead of leaving it until the load of the new data to correct the store contents,
       *
       * Setting this to true clears the event store prior to requesting the data load.
       * @config {Boolean}
       * @default false
       */
      clearOnNewRange: null
    };
  }
  construct(config) {
    const {
      client
    } = config;
    // When the client requests a range of dates from its eventStore, we get notified.
    // If the eventStore has not successfully loaded that range, we load that range.
    client.ion({
      dateRangeRequested: 'onClientDateRangeRequested',
      thisObj: this
    });
    // This to register the date range that the operation just successfully loaded.
    // We register the loaded date range *before* the response is applied so that
    // when UI requests which emanate from the impending application of the new dataset
    // ask for date ranges requests, the range will be detected as already present.
    client.crudManager.ion({
      beforeLoadApply: 'onCrudManagerBeforeApply',
      thisObj: this,
      prio: 9999
    });
    super.construct(...arguments);
  }
  // Tests if the CrudManager has an outstanding load request which would satisfy the passed date range
  hasOutstandingLoadFor(startDate, endDate) {
    const {
      load
    } = this.client.crudManager.activeRequests;
    if (load) {
      var _load$options;
      const otherDateRangeRequested = (_load$options = load.options) === null || _load$options === void 0 ? void 0 : _load$options.dateRangeRequested;
      // If the outstanding load request encompasses ours, allow it to go through
      // We do not need to do anything.
      if (otherDateRangeRequested && DateHelper.timeSpanContains(otherDateRangeRequested.startDate, otherDateRangeRequested.endDate, startDate, endDate)) {
        return true;
      }
    }
  }
  // We observe our CrudManager's successful loads and register the date range requested.
  // This is so that when a client dateRangeChange event is encountered, we can only
  // trigger a load if the date range is not already loaded unless alwaysLoadNewRange is set..
  onCrudManagerBeforeApply({
    response,
    options
  }) {
    // If it was a full load from a mode which doesn't know about this feature such as
    // a Scheduler, that will have requested an unranged load and the last range loaded
    // will be unknown. In this case the next request will *always* trigger a load.
    this.lastRangeLoaded = response.success && (options === null || options === void 0 ? void 0 : options.dateRangeRequested);
  }
  onClientDateRangeRequested({
    new: {
      startDate,
      endDate
    },
    changed
  }) {
    const me = this,
      {
        client
      } = me;
    // alwaysLoadNewRange is only valid for responding to *new* date range requests.
    // Otherwise it responds even if the request was satisfied, and an infinite
    // load->refresh->getEvents->rangeRequested->load loop would occur.
    if (!changed && me.alwaysLoadNewRange) {
      return;
    }
    // Setting to clear the store down on range change.
    // Long running events from one month will show up in the next month.
    // Set this to clear the store. Of course the same events will only get loaded again
    // because they are long running and intrude into the new month but
    // this is a cosmetic issue for app developers to choose.
    if (changed) {
      DomHelper.addTemporaryClass(client.element, 'b-notransition', 100, client);
      if (me.clearOnNewRange) {
        client.eventStore.clear(true);
        me.lastRangeLoaded = null;
      }
    }
    const {
      lastRangeLoaded
    } = me;
    // Check for whether we have already loaded the requested range unless we are configured to always load.
    if (lastRangeLoaded && !me.alwaysLoadNewRange) {
      const {
        startDate: lastStartDate,
        endDate: lastEndDate
      } = me.lastRangeLoaded;
      // Our loaded range already contains this range
      if (DateHelper.timeSpanContains(lastStartDate, lastEndDate, startDate, endDate)) {
        return;
      }
    }
    if (!me.disabled && !me.hasOutstandingLoadFor(startDate, endDate)) {
      // Register the range that the view needs.
      // All requested date ranged will be merged into one load
      me.loadDateRange(startDate, endDate);
    }
  }
  /**
   * Reloads the currently loaded date range.
   *
   * If your app detects that the data may be stale, or needs to periodically refresh the data,
   * this method may be used to issue a server request to reload the currently loaded date range.
   */
  refresh() {
    const {
      lastRangeLoaded
    } = this;
    if (lastRangeLoaded) {
      this.loadDateRange(lastRangeLoaded.startDate, lastRangeLoaded.endDate);
    }
  }
  loadDateRange(startDate, endDate) {
    const me = this,
      {
        pendingLoad
      } = me;
    // We gather the widest date range that is asked for, and the final range
    // is requested in the next time frame.
    if (pendingLoad) {
      pendingLoad.startDate = DateHelper.min(startDate, pendingLoad.startDate);
      pendingLoad.endDate = DateHelper.max(endDate, pendingLoad.endDate);
    } else {
      me.pendingLoad = {
        startDate,
        endDate
      };
      me.client.requestAnimationFrame(() => me.load());
    }
  }
  async load() {
    const me = this,
      {
        client,
        beforeRequest,
        dateFormat
      } = me,
      {
        crudManager
      } = client,
      {
        load
      } = crudManager.activeRequests,
      {
        startDate,
        endDate
      } = me.pendingLoad;
    const options = {
      dateRangeRequested: me.pendingLoad,
      request: {
        params: {
          [me.startDateParamName]: DateHelper.format(startDate, dateFormat),
          [me.endDateParamName]: DateHelper.format(endDate, dateFormat)
        }
      }
    };
    // Ensure that subsequent loadDateRange requests queue up.
    me.pendingLoad = null;
    // allow app developers to mutate the request
    if (beforeRequest) {
      me.callback(beforeRequest, client, [options]);
    }
    if (load) {
      // If there is already a load request in flight which would satisfy the date range
      // Alow it to go through.
      if (me.hasOutstandingLoadFor(startDate, endDate)) {
        return;
      }
      try {
        await crudManager.cancelRequest(load.desc, load.reject);
      } catch (e) {
        // swallow rejected load Promise exception
      }
    }
    try {
      await crudManager.load(options);
    } catch (e) {
      /**
       * __Note that this event fires on the owning {@link Calendar.view.Calendar}.__
       *
       * Fires when the {@link Calendar.feature.LoadOnDemand} feature detects that a request
       * for data from the server has failed.
       *
       * An event listener handler may produce an error UI.
       *
       * If no handler returns `false`, then a default error UI is shown
       * using `{@link Core.widget.MessageDialog#function-alert MessageDialog}`.
       * @event loadOnDemandFail
       * @param {Response} rawResponse The HTTP `fetch` response object.
       * @param {Object} request The CrudManager load data block.
       * @param {Object} response The decoded JSON response.
       * @on-owner
       */
      if (!client.isDestroyed && client.trigger('loadOnDemandFail', e) !== false) {
        MessageDialog.alert({
          title: client.L('L{Calendar.loadFail}'),
          message: e.message
        });
      }
    }
    !client.isDestroyed && client.trigger('dateRangeLoad', {
      startDate,
      endDate
    });
  }
}
// Register this feature type with its Factory
_defineProperty(LoadOnDemand, "$name", 'LoadOnDemand');
_defineProperty(LoadOnDemand, "type", 'loadOnDemand');
LoadOnDemand.initClass();
LoadOnDemand._$name = 'LoadOnDemand';

/**
 * @module Calendar/feature/print/printer/Printer
 */
/**
 * Base class for all printers
 * @extends Grid/feature/export/exporter/Exporter
 * @internal
 */
class Printer extends Exporter {
  restoreState({
    client
  }) {}
  saveState({
    client
  }) {}
  cloneElement(element, target = this.element, clear = true) {
    if (clear) {
      target.innerHTML = '';
    }
    target.appendChild(element.cloneNode(true));
  }
  /**
   * Template of an extracted page.
   * @param {Object} data Data for the page template
   * @returns {String}
   */
  pageTpl(data) {
    const {
        config,
        title,
        header,
        footer,
        styles,
        htmlClasses,
        bodyStyle,
        bodyClasses = [`b-${this.constructor.type}`, ...this.owner.bodyClasses, ...Widget.outerCls],
        paperHeight,
        paperWidth,
        html
      } = data,
      // Safari's print returns immediately, so we can't immediately remove the window.
      // It is removed if ever needed again.
      afterPrint = BrowserHelper.isSafari ? '' : 'window.removeElement && window.removeElement();',
      // Don't run print script in debug mode
      script = !(config !== null && config !== void 0 && config.debug) ? `<script type="text/javascript">window.addEventListener('load', function() { window.print(); ${afterPrint} });</script>` : '';
    return TemplateHelper.tpl`
            <!DOCTYPE html>
            <html class="${htmlClasses}" style="width: ${paperWidth}in; height: ${paperHeight}in;">
                <head>
                    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
                    <title>${title}</title>
                    ${styles.join('')}
                </head>
                <body class="b-print ${bodyClasses.join(' ')}" style="width: ${paperWidth}in; height: ${paperHeight}in; ${bodyStyle}">
                    <div class="b-print-content">
                        ${header && `<div class="b-print-header" style="width: 100%">${header}</div>`}
                        <div class="b-print-body"><div class="b-print-viewport">${html}</div></div>
                        ${footer && `<div class="b-print-footer" style="width: 100%">${footer}</div>`}
                    </div>
                    ${script}
                </body>
            </html>`;
  }
}
Printer._$name = 'Printer';

/**
 * @module Calendar/feature/print/printer/CalendarPrinter
 */
const bigNumberProperty = {
  configurable: true,
  get: () => Number.MAX_SAFE_INTEGER
};
/**
 * Helper class for the Calendar print feature.
 * @private
 */
class CalendarPrinter extends Printer {
  static get $name() {
    return 'CalendarPrinter';
  }
  static get type() {
    return 'calendar';
  }
  getTotalHeight(client) {
    const {
      activeView
    } = client;
    switch (client.mode) {
      case 'agenda':
        return activeView.virtualScrollHeight;
      case 'day':
        return activeView.dayContentElement.scrollHeight + activeView.alldayRowElement.offsetHeight;
      case 'week':
        return activeView.dayContentElement.scrollHeight + activeView.alldayRowElement.offsetHeight;
      case 'month':
        // Duplicating screen week row heights exactly.
        if (this.owner.wysiwyg) {
          return activeView.weeksElement.scrollHeight + activeView.weekdaysHeader.offsetHeight + 10;
        }
        // If we're not doing wysiwyg, total height is set during content cloning.
        break;
      case 'year':
        return this.inchToPx(PaperFormat.A4.width);
    }
  }
  getTotalWidth(client) {
    switch (client.mode) {
      case 'year':
        return this.inchToPx(PaperFormat.A4.height);
      default:
        return this.inchToPx(PaperFormat.A4.width);
    }
  }
  async prepareComponent(config) {
    const me = this,
      {
        owner
      } = me,
      {
        wysiwyg
      } = owner,
      shrinkwrapRowHeights = !wysiwyg,
      {
        client
      } = config,
      {
        activeView
      } = client;
    me.exportMeta = {
      title: owner.callback(owner.titleRenderer, owner, [activeView]),
      totalWidth: me.getTotalWidth(client),
      totalHeight: me.getTotalHeight(client),
      subGrids: {}
    };
    if (client.mode === 'month' && shrinkwrapRowHeights) {
      Object.defineProperty(activeView, 'eventsPerCell', bigNumberProperty);
      // Refresh with eventsPerCell at a Very Large Number so that all are rendered
      // since we are shrinkwrapping the week rows.
      activeView.doRefresh();
    }
    me.cloneElement(activeView.currentElement);
    if (client.mode === 'month') {
      let rowHeights;
      // Measure the row heights based upon the number of rendered events (which will be all for that day)
      // and the event height.
      if (shrinkwrapRowHeights) {
        rowHeights = activeView.shrinkwrapRowHeights;
        delete activeView.eventsPerCell;
        activeView.doRefresh();
        // Total exported height must be all calculated heights
        me.exportMeta.totalHeight = activeView.weekdaysHeader.offsetHeight + rowHeights.reduce((sum, r) => {
          return sum + r;
        }, 5);
      }
      activeView.weekElements.forEach((el, i) => {
        const clonedElement = me.element.querySelector(`[data-week="${el.dataset.week}"]`);
        clonedElement.style.minHeight = '';
        if (shrinkwrapRowHeights) {
          clonedElement.style.flex = `0 0 ${rowHeights[i]}px`;
        } else if (wysiwyg) {
          clonedElement.style.flex = `1 0 ${el.offsetHeight}px`;
        } else {
          clonedElement.style.flex = `1 0 ${250 / 6}mm`;
        }
      });
    }
  }
  pxToInch(value) {
    return (value / 96).toFixed(2);
  }
}
// HACK: terser/obfuscator doesn't yet support async generators, when processing code it converts async generator to regular async
// function.
CalendarPrinter.prototype.pagesExtractor = async function* pagesExtractor(config) {
  const me = this,
    {
      totalHeight,
      totalWidth,
      title
    } = me.exportMeta;
  yield {
    html: me.pageTpl({
      config,
      title,
      html: me.prepareExportElement(),
      styles: me.stylesheets,
      paperWidth: me.pxToInch(totalWidth),
      paperHeight: me.pxToInch(totalHeight)
    })
  };
};
CalendarPrinter._$name = 'CalendarPrinter';

/**
 * @module Calendar/feature/print/Print
 */
const emptyArray = Object.freeze([]);
/**
 * This feature enables printing of the current Calendar mode.
 *
 *
 * ## Usage
 *
 * ```javascript
 * const calendar = new Calendar({
 *     features : {
 *         print : true
 *     }
 * });
 *
 *
 * // Simple print
 * calendar.print();
 * ```
 *
 * @demo Calendar/basic
 * @classType print
 * @feature
 */
class Print extends CalendarFeature {
  static get $name() {
    return 'Print';
  }
  static get type() {
    return 'print';
  }
  static get configurable() {
    return {
      /**
       * Config for printer.
       * @config {Object}
       * @private
       */
      printer: {
        $config: ['lazy', 'nullify'],
        value: {
          type: 'calendar'
        }
      },
      /**
       * By default, a {@link Calendar.widget.MonthView} is rendered with the week rows
       * shrinkwrapping their event content. That is, rows with no events are small, and rows
       * containing events are expanded to make all events visible.
       *
       * To duplicate the on-screen appearance in terms of week row heights where empty rows
       * are flexed to consume an equal amount of height, configure this as `true`.
       * @config {Boolean}
       * @default
       */
      wysiwyg: false,
      /**
       * The function to use to create the [&lt;title&gt;](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title) element for the print document.
       * Defaults to using the {@link Scheduler.view.mixin.Describable#config-descriptionRenderer}
       * of the active view. Note that this does not process HTML source.
       * @config {Function|String}
       * @default
       */
      titleRenderer: activeView => activeView.description,
      /**
       * Map of printer classes to use in print feature
       * @config {Map}
       * @private
       * @default
       */
      printers: new Map([[CalendarPrinter.type, CalendarPrinter]])
    };
  }
  construct() {
    super.construct(...arguments);
    this.client.print = this.print.bind(this);
  }
  changePrinter(config) {
    const me = this,
      printersMap = me.printersMap || (me.printersMap = new Map());
    if (config) {
      let printer;
      const {
        type
      } = config;
      if (printersMap.has(type)) {
        printer = printersMap.get(type);
        printer.setConfig(config);
      } else {
        const printerClass = me.printers.get(type);
        if (!printerClass) {
          throw new Error(`Printer type ${type} is not found. Make sure you've configured it`);
        }
        config = ObjectHelper.clone(config);
        config.owner = me;
        printer = new printerClass(config);
        printer.relayAll(me);
        printersMap.set(type, printer);
      }
      return printer;
    } else {
      printersMap.forEach(printer => printer.destroy());
    }
  }
  get bodyClasses() {
    if (this.shrinkwrapRowHeights) {
      return ['b-shrinkwrap-row-heights'];
    }
    return emptyArray;
  }
  /**
   * Prints the current active view of the Calendar
   * @privateparam config A config object for the Printer
   */
  async print(config = {}) {
    const me = this,
      {
        client,
        printer
      } = me,
      iframeId = `${client.id}-print-iframe`;
    /**
     * Fires on the owning Calendar before print starts. Return `false` to cancel the print.
     * @event beforePrint
     * @on-owner
     * @preventable
     * @param {Object} config Print config
     * @param {Calendar.feature.print.printer.Printer} printer The Printer object which will handle the printing.
     */
    if (client.trigger('beforePrint', {
      config,
      printer
    }) !== false) {
      config.client = client;
      const pages = await me.printer.export(config);
      if (config.debug) {
        client.trigger('print', pages);
      } else {
        var _document$getElementB;
        // Remove existing iframe if it's there.
        // Safari can't wait until after print has finished, so it does not remove iframe after print
        (_document$getElementB = document.getElementById(iframeId)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.remove();
        const iframe = DomHelper.createElement({
          id: iframeId,
          class: 'b-calendar-print-iframe',
          tag: 'iframe',
          parent: document.body
        });
        iframe.contentWindow.removeElement = () => {
          iframe.remove();
          /**
           * Fires when print has finished
           * @event print
           */
          client.trigger('print', pages);
        };
        iframe.contentWindow.document.write(pages[0].html);
        iframe.contentWindow.document.close();
        return pages;
      }
    }
  }
}
Print.initClass();
Print._$name = 'Print';

/**
 * @module Calendar/feature/ScheduleMenu
 */
/**
 * A feature which adds a context menu to the unoccupied parts of calendar views.
 *
 * There is one predefined {@link #config-items item} provided by default:
 *
 * - `addEvent` Adds an event at the time point indicated by the click
 *
 * If the timepoint has only date-level granularity (Such as when clicking in in a MonthView or
 * AgendaView, or YearView), the start time of the event will default to the configured
 * {@link Calendar.view.Calendar#config-autoCreate}'s `startHour` property.
 *
 * If the {@link Calendar.feature.EventEdit EventEdit} feature is enabled, the new event is passed for editing.
 *
 * The {@link #config-items} set can be reconfigured by providing an `items` property to this feature:
 *
 *```javascript
 * features : {
 *     scheduleMenu : {
 *         items : {
 *             // Knocks out the predefined addEvent item
 *             addEvent : null,
 *
 *             // Add our own custom item
 *             disableDate : {
 *                  icon    : 'b-fa b-fa-calendar-times',
 *                  text    : 'Mark date unavailable',
 *
 *                  // Will look up ownership chain and find the Calendar
 *                  handler : 'up.makeDateUnavailable'
 *             }
 *         }
 *     }
 * },
 * makeDateUnavailable({ date }) {
 *     // Pass to our own app logic
 *     this.disableDate(date);
 * }
 *```
 *
 * This feature is **not** enabled by default. In order to use it, you must include it in your
 * `features` configuration.
 *
 * @demo Calendar/custom-menus
 * @extends Scheduler/feature/ScheduleMenu
 * @classType scheduleMenu
 * @feature
 *
 * @typings Scheduler/feature/ScheduleMenu -> Scheduler/feature/SchedulerScheduleMenu
 */
class ScheduleMenu extends ScheduleMenu$1 {
  static get $name() {
    return 'ScheduleMenu';
  }
  static get type() {
    return 'scheduleMenu';
  }
  getDataFromEvent(event) {
    const {
        client
      } = this,
      {
        activeView
      } = client,
      // Calendar has a defaultCalendar property for defaulting the resource
      resourceRecord = client.resolveResourceRecord(event) || client.defaultCalendar;
    // Base class is SchedulerScheduleMenu
    if (activeView.isScheduler) {
      this.client = activeView;
    }
    const result = super.getDataFromEvent(event);
    // Only inject the resourceRecord as the Calendar's detected version if the superclass didn't find one.
    // We may be hosting a Scheduler as a view which has its own opinions on this.
    if (!result.resourceRecord) {
      result.resourceRecord = resourceRecord;
    }
    this.client = client;
    return result;
  }
  shouldShowMenu({
    date,
    targetElement
  }) {
    const {
        client
      } = this,
      {
        activeView
      } = client;
    // Base class is SchedulerScheduleMenu
    if (activeView.isScheduler) {
      this.client = activeView;
      const result = super.shouldShowMenu(...arguments);
      this.client = client;
      return result;
    }
    // We need a date and *not* an event element.
    return Boolean(date && !targetElement.closest(client.eventSelector));
  }
}
// Register this feature type with its Factory
CalendarFeature.register(ScheduleMenu.type, ScheduleMenu);
ScheduleMenu._$name = 'ScheduleMenu';

/**
 * @module Calendar/layout/LayoutDim
 */
const noCalcRe = /^[+-]?\d+(?:\.\d+)?(?:%|px)?$/;
/**
 * Helper class for layout size pairs.
 * @internal
 */
class LayoutDim {
  static from(value) {
    if (value == null) {
      return null;
    }
    if (value instanceof LayoutDim) {
      return value;
    }
    // isNaN('4')=false, isNaN('4%')=true (preserve strings like "5% + 10px")
    if (!(Array.isArray(value) || typeof value === 'string' && isNaN(value))) {
      value = Number(value);
      value = value < 1 ? [value, 0] : [0, value];
    }
    return new LayoutDim(...value);
  }
  static get(value) {
    return LayoutDim.from(value) || LayoutDim.ZERO;
  }
  constructor(ratio, delta) {
    this.r = ratio;
    this.d = delta;
  }
  add(v) {
    v = LayoutDim.from(v);
    return v ? new LayoutDim(this.r + v.r, this.d + v.d) : this;
  }
  adjust(r, d) {
    this.r += r || 0;
    this.d += d || 0;
    return this;
  }
  freeze() {
    return Object.freeze(this);
  }
  px(range) {
    return this.r * (range || 100) + this.d;
  }
  sub(v) {
    v = LayoutDim.from(v);
    return v ? new LayoutDim(this.r - v.r, this.d - v.d) : this;
  }
  *[Symbol.iterator]() {
    yield 'r';
    yield 'd';
  }
  stringify() {
    const str = this.toString();
    return noCalcRe.test(str) ? str : `calc(${str})`;
  }
  toString() {
    const {
      r,
      d
    } = this;
    let str;
    if (r) {
      str = DomHelper.percentify(r * 100);
      if (d) {
        str = `${str} + ${d}px`.replace('+ -', '- ');
      }
    } else {
      str = d ? `${d}px` : '0';
    }
    return str;
  }
}
LayoutDim.ZERO = new LayoutDim(0, 0).freeze();
LayoutDim._$name = 'LayoutDim';

/**
 * @module Calendar/feature/TimeRanges
 */
/**
 * A mutable object used to render an element of the time range.
 *
 * @typedef {Object} TimeRangeRenderData
 * @property {Calendar.model.TimeRangeModel} record The record being rendered
 * @property {String} color The color to be applied to the element
 * @property {Object} cls An object whose truthy property names will be added to the element's CSS `classList`
 * @property {Object} style An object containing style properties for the element
 * @property {TimeRangeRenderData} [outer] The render data for the outermost element. This property is present when
 * rendering any of the inner elements. The outer element is rendered after all inner elements, meaning this object
 * can be modified by an inner element renderer function.
 * @property {TimeRangeRenderData} [header] The render data for the header element. This property is present when
 * rendering the outermost element. The corresponding element has already been rendered, meaning that this object
 * should be considered read only.
 * @property {TimeRangeRenderData} [body] The render data for the body element. This property is present when
 * rendering the outermost element. The corresponding element has already been rendered, meaning that this object
 * should be considered read only.
 * @property {TimeRangeRenderData} [footer] The render data for the footer element. This property is present when
 * rendering the outermost element. The corresponding element has already been rendered, meaning that this object
 * should be considered read only.
 */
/**
 * The object passed to a {@link Calendar.feature.TimeRanges#config-renderer} function.
 * @typedef {Object} TimeRangeRenderInfo
 * @property {TimeRangeRenderData} renderData The render data object to modify
 * @property {Calendar.model.TimeRangeModel} timeRange The record being rendered
 * @property {DomConfig} [domConfig] The default DOM config. This is only passed to the `outer` renderer and represents
 * the DOM config that will be used for the element. The `className` and `style` properties are applied after the
 * renderer returns.
 */
/**
 * An object containing rendering methods for the various elements of a time range. All functions are optional. The
 * `footer` function is special in that there is no footer element by default. If a footer is desired, a `footer`
 * renderer function must be provided.
 *
 * @typedef {Object} TimeRangeRenderer
 * @property {Function} [outer] An optional function to be called to render the outermost element. This function is
 * passed a {@link Calendar.feature.TimeRanges#typedef-TimeRangeRenderInfo} object.
 * @property {Function} [body] An optional function to be called to render the body element. This function is passed
 * a {@link Calendar.feature.TimeRanges#typedef-TimeRangeRenderInfo} object.
 * @property {Function} [header] An optional function to be called to render the header element. This function is passed
 * a {@link Calendar.feature.TimeRanges#typedef-TimeRangeRenderInfo} object.
 * @property {Function} [footer] An optional function to be called to render the footer element. This function is passed
 * a {@link Calendar.feature.TimeRanges#typedef-TimeRangeRenderInfo} object.
 */
const genericRenderer = renderData => ({
    className: renderData.cls,
    style: renderData.style
  }),
  defaultRotation = {
    end: 'pos',
    start: 'neg'
  },
  oppositeAlign = {
    end: 'start',
    start: 'end'
  },
  valueFields = Object.entries({
    alignment: 'alignment',
    color: 'color',
    footer: 'footer',
    header: 'name',
    rotation: 'rotation'
  });
/*
    This class manages rendering time ranges in a Day/WeekView. Instances of this class are created by the
    CalendarFeature via zoneTypes map.
 */
class DayZone extends CalendarZone {
  onBeforeLayoutEvents({
    source,
    context
  }) {
    // This event is fired by DayView.renderEvents
    // We hook into that event which fires for each day even if there are no events so we can decorate the day
    // with appropriate time ranges
    const ranges = source.getTimeRanges(context.cellData.date, context.cellData.tomorrow);
    if (ranges.length) {
      const {
          layout
        } = context,
        footers = {},
        headers = {},
        clusters = [],
        items = [];
      let children, item;
      context.timeRangeHeaders = headers;
      context.timeRanges = ranges;
      for (const timeRange of ranges) {
        item = layout.createLayoutItem(timeRange, context);
        item.values = Object.fromEntries(valueFields.map(([name, fieldName]) => [name, timeRange[fieldName]]));
        item.values.rotation = item.values.rotation || defaultRotation[item.values.alignment];
        layout.clusterize(clusters, items, item, context);
        children = context.dayDomConfig.children.inset;
        children = children.children || (children.children = []);
        children.push(this.renderTimeSpan(context, item, headers, footers));
      }
      if (headers.end || footers.end) {
        context.dayDomConfig.className['b-dayview-inset-after'] = 1;
      }
      if (headers.start || footers.start) {
        context.dayDomConfig.className['b-dayview-inset-before'] = 1;
      }
    }
  }
  renderPart(defaultRenderer, renderer, renderData, part, headerFooter, align, extraData) {
    var _defaultRenderer, _renderer, _defaultRenderer2;
    const isFooter = part === 'footer',
      {
        record
      } = renderData,
      renderInfo = {
        timeRange: record
      };
    let data = renderData,
      domConfig,
      extraDom,
      value;
    if (typeof part === 'string') {
      renderData[part] = data = ObjectHelper.merge({
        part,
        record,
        outer: renderData,
        cls: {
          [`b-cal-timerange-${part}`]: 1
        }
      }, extraData);
      value = renderData.values[part];
      if (value != null) {
        renderInfo.value = data.value = value;
      }
    } else {
      extraDom = part;
      part = 'outer';
    }
    defaultRenderer = (_defaultRenderer = defaultRenderer) === null || _defaultRenderer === void 0 ? void 0 : _defaultRenderer[part];
    renderer = (_renderer = renderer) === null || _renderer === void 0 ? void 0 : _renderer[part];
    renderInfo.renderData = data;
    renderInfo.domConfig = extraDom;
    if (renderer) {
      data.style = {};
      const ret = renderer(renderInfo);
      if (typeof ret === 'string') {
        extraDom = Object.assign({
          html: ret
        }, extraDom);
      } else if (ObjectHelper.isObject(ret)) {
        domConfig = ret;
      }
    }
    domConfig = domConfig || ((_defaultRenderer2 = defaultRenderer) === null || _defaultRenderer2 === void 0 ? void 0 : _defaultRenderer2(renderInfo));
    if (extraDom) {
      domConfig = ObjectHelper.merge(domConfig || {}, extraDom);
    }
    if (headerFooter && domConfig) {
      align = isFooter && oppositeAlign[align] || align;
      headerFooter[align] = (headerFooter[align] || 0) + 1;
    }
    data.domConfig = domConfig;
    return domConfig;
  }
  renderTimeSpan(context, item, headers, footers) {
    const me = this,
      {
        owner
      } = me,
      // our feature
      {
        defaultRenderer,
        renderer
      } = owner,
      timeRange = item.eventRecord,
      sizeSeconds = Math.abs(item.end - item.start),
      // seconds
      isRange = sizeSeconds > 1,
      isLine = !isRange,
      {
        rtl
      } = context.layout.owner,
      {
        values
      } = item,
      {
        alignment: align,
        color,
        rotation
      } = values,
      renderData = {
        color,
        values,
        record: timeRange,
        layoutContext: context,
        cls: {
          'b-readonly': timeRange.readOnly,
          'b-rtl': rtl,
          'b-cal-timerange': 1,
          'b-cal-timerange-line': isLine,
          'b-cal-timerange-narrow': isRange && sizeSeconds <= owner.narrowThreshold * 60,
          [`b-cal-timerange-align-${align}`]: align,
          [`b-cal-timerange-rotate-${rotation}`]: isRange && rotation
        }
      };
    // This minor fudge allows the background grid lines to show through (better aesthetically)
    isRange && item.height.adjust(0, -1);
    const styles = item.getStyles(rtl);
    return DomHelper.normalizeChildren(me.renderPart(defaultRenderer, renderer, renderData, {
      dataset: {
        'timerange-id': timeRange.id,
        btip: isLine && values.header || null
      },
      className: {
        [timeRange.cls]: timeRange.cls
      },
      elementData: {
        timeRange
      },
      style: {
        top: styles.top,
        height: styles.height
      },
      children: isRange && {
        header: me.renderPart(defaultRenderer, renderer, renderData, 'header', headers, align, {
          cls: {
            [timeRange.iconCls]: timeRange.iconCls
          }
        }),
        body: me.renderPart(defaultRenderer, renderer, renderData, 'body'),
        footer: me.renderPart(defaultRenderer, renderer, renderData, 'footer', footers, align)
      }
    }));
  }
}
/**
 * This feature provides an easy way to highlight ranges of time in a calendar's day and week views. Each time range is
 * represented using the {@link Calendar.model.TimeRangeModel}.
 *
 * {@inlineexample Calendar/feature/TimeRanges.js}
 *
 * Time ranges can take a few different forms:
 *
 * - A line at the {@link Calendar.model.TimeRangeModel#field-startDate} with optional tooltip based on the
 *  {@link Calendar.model.TimeRangeModel#field-name}.
 * - A styled region between the {@link Calendar.model.TimeRangeModel#field-startDate} and
 *   {@link Calendar.model.TimeRangeModel#field-endDate}. The {@link Calendar.model.TimeRangeModel#field-cls} field is
 *   used to apply the desired style to the time range element.
 * - A titled region based on the {@link Calendar.model.TimeRangeModel#field-name} field, between the
 *   {@link Calendar.model.TimeRangeModel#field-startDate} and {@link Calendar.model.TimeRangeModel#field-endDate}. The
 *   {@link Calendar.model.TimeRangeModel#field-cls} field can be used to apply the styling to the time range element.
 *   The {@link Calendar.model.TimeRangeModel#field-color} and {@link Calendar.model.TimeRangeModel#field-iconCls}
 *   fields can be used to apply a background color and icon to the header element. An optional
 *   {@link Calendar.model.TimeRangeModel#field-footer} can also be added.
 *
 * ## ResourceTimeRanges
 *
 * If `resourceTimeRanges` are included in the loaded data, the results are only applied to views
 * which display that resource. This means subviews of a {@link Calendar.widget.ResourceView}.
 *
 * Be sure to see additional examples on Mar 4 (Wed) in the Live Demo.
 *
 * @demo Calendar/timeranges
 * @extends Scheduler/feature/TimeRanges
 * @classType timeRanges
 * @feature
 *
 * @typings Scheduler/feature/TimeRanges -> Scheduler/feature/SchedulerTimeRanges
 */
_defineProperty(DayZone, "$name", 'DayZone');
_defineProperty(DayZone, "configurable", {
  viewListeners: {
    beforeLayoutEvents: 'onBeforeLayoutEvents'
    // renderEvents       : 'onRenderEvents'
  }
});

class TimeRanges extends CalendarFeature.mixin(AttachToProjectMixin) {
  attachToProject(project) {
    var _project$timeRangeSto, _project$resourceTime;
    super.attachToProject(project);
    this.detachListeners('project');
    (_project$timeRangeSto = project.timeRangeStore) === null || _project$timeRangeSto === void 0 ? void 0 : _project$timeRangeSto.ion({
      name: 'project',
      change: 'refresh',
      thisObj: this
    });
    (_project$resourceTime = project.resourceTimeRangeStore) === null || _project$resourceTime === void 0 ? void 0 : _project$resourceTime.ion({
      name: 'project',
      change: 'refresh',
      thisObj: this
    });
  }
  changeRenderer(renderer) {
    if (typeof renderer === 'function') {
      renderer = {
        header: renderer
      };
    }
    return renderer;
  }
  updateHeaderWidth(width) {
    var _this$owner;
    const el = (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.element;
    if (el) {
      var _LayoutDim$from;
      el.style.setProperty('--timerange-header-width', (_LayoutDim$from = LayoutDim.from(width)) === null || _LayoutDim$from === void 0 ? void 0 : _LayoutDim$from.toString());
    }
  }
  refresh() {
    this.client.queryAll(v => v.isResourceView).forEach(v => v.eachView('refresh'));
  }
}
// Register this feature type with its Factory
_defineProperty(TimeRanges, "$name", 'TimeRanges');
_defineProperty(TimeRanges, "type", 'timeRanges');
_defineProperty(TimeRanges, "configurable", {
  defaultRenderer: {
    outer({
      renderData
    }) {
      var _renderData$header;
      const ret = genericRenderer(renderData),
        {
          color
        } = renderData;
      if (color) {
        if (DomHelper.isNamedColor(color)) {
          ret.className[`b-cal-color-${color}`] = 1;
        } else {
          // Background color is in a pseudo element whose styles
          // come from CSS vars, so set the var locally to the element.
          (ret.style || (ret.style = {}))['--timerange-color'] = color;
        }
      }
      ret.className['b-cal-timerange-has-header'] = (_renderData$header = renderData.header) === null || _renderData$header === void 0 ? void 0 : _renderData$header.domConfig;
      return ret;
    },
    body: ({
      renderData
    }) => genericRenderer(renderData),
    header: ({
      renderData,
      value
    }) => value ? _objectSpread2(_objectSpread2({}, genericRenderer(renderData)), {}, {
      children: [{
        className: {
          'b-cal-timerange-header-text': 1
        },
        text: value
      }]
    }) : null,
    footer: ({
      renderData,
      value
    }) => value ? _objectSpread2(_objectSpread2({}, genericRenderer(renderData)), {}, {
      children: [{
        className: {
          'b-cal-timerange-footer-text': 1
        },
        text: value
      }]
    }) : null
  },
  /**
   * The number of pixels or proportion of the overall width to allocate for time range headers.
   *
   * Values less than 1 are the fractional proportion of the width (for example, 0.04 is 4% of the width),
   * while values greater than or equal to 1 are a number of pixels.
   * @config {Number}
   * @default
   */
  headerWidth: 40,
  narrowThreshold: 60,
  /**
   * An empty function by default, but provided so that you can override it.
   *
   * This function is called each time a time range is rendered to allow developers to mutate the element metadata,
   * or the CSS classes to be applied to the rendered element.
   *
   * It's called with a {@link #typedef-TimeRangeRenderInfo} object containing the time span record, and a
   * {@link #typedef-TimeRangeRenderData renderData} object which allows you to mutate event metadata such as
   * `cls` and `style`.
   *
   * A non-null return value from the renderer is used as the element body content. A nullish return value results
   * in the default renderer for the element.
   *
   * ```javascript
   *  timeRanges : {
   *      renderer ({ timeRange, renderData }) {
   *          if (timeRange.name === 'Doctors appointment') {
   *              renderData.style.fontWeight = 'bold';
   *              renderData.cls['custom-cls'] = 1;
   *
   *              return 'Special doctors appointment';
   *          }
   *      }
   *  }
   * ```
   * <div class="note">When returning content, be sure to consider how that content should be encoded to avoid XSS
   * (Cross-Site Scripting) attacks. This is especially important when including user-controlled data such as
   * the event's `name`. The function {@link Core.helper.StringHelper#function-encodeHtml-static} as well as
   * {@link Core.helper.StringHelper#function-xss-static} can be helpful in these cases.</div>
   *
   * For example:
   * ```javascript
   *  timeRanges : {
   *      renderer ({ timeRange, renderData }) {
   *          return StringHelper.xss`Special ${timeRange.name}`;
   *      }
   *  }
   * ```
   *
   * For advanced rendering, this config can be a {@link #typedef-TimeRangeRenderer} object with rendering
   * functions for individual elements: `header`, `body`, `footer`, and `outer`. When a function is provided,
   * that is equivalent to passing the `header` renderer. In other words, the above example is equivalent to
   * the following:
   *
   * ```javascript
   *  timeRanges : {
   *      renderer : {
   *          header({ timeRange, renderData }) {
   *              return StringHelper.xss`Special ${timeRange.name}`;
   *          }
   *      }
   *  }
   * ```
   *
   * @config {Function|TimeRangeRenderer} renderer
   * @param {TimeRangeRenderInfo} info An object that contains data about the time span being rendered.
   * @default
   */
  renderer: null,
  zoneTypes: {
    day: DayZone,
    // also covers WeekView
    resource: DayZone
  }
});
CalendarFeature.register(TimeRanges.type, TimeRanges);
TimeRanges._$name = 'TimeRanges';

/**
 * @module Calendar/feature/WeekExpander
 */
/**
 *
 * A Feature which, when present, adds a week row expansion tool to week rows in
 * {@link Calendar.widget.MonthView MonthView}s so that a row which contains overflowing cells
 * can be expanded to show all events with no overflow.
 *
 * ```javascript
 * const calendar = new Calendar({
 *     appendTo : 'container',
 *
 *     // Start life looking at this date
 *     date : new Date(2020, 9, 12),
 *
 *     features : {
 *         weekExpander : true
 *     },
 *
 *     // CrudManager arranges loading and syncing of data in JSON form from/to a web service
 *     crudManager : {
 *         transport : {
 *             load : {
 *                 url : 'data/data.json'
 *             }
 *         },
 *         autoLoad : true
 *     }
 * });```
 *
 * Note that doing this may cause the MonthView itself to have vertical overflow.
 * @extends Calendar/feature/CalendarFeature
 * @classType weekExpander
 * @feature
 */
class WeekExpander extends CalendarFeature {
  static get $name() {
    return 'WeekExpander';
  }
  static get type() {
    return 'weekExpander';
  }
  static get pluginConfig() {
    return {
      chain: ['render']
    };
  }
  render() {
    const {
        client
      } = this,
      monthView = this.monthView = client.isMonthView ? client : client.modes.month;
    if (monthView) {
      const {
        weekRenderer
      } = this;
      monthView.showWeekColumn = true;
      monthView.weekRenderer = monthView.weekRenderer ? FunctionHelper.createSequence(monthView.weekRenderer, weekRenderer) : weekRenderer;
      monthView.ion({
        weeknumberclick: 'onWeekNumberClick',
        thisObj: this,
        // We must get in first so we can veto the switch to week view if we toggle a row.
        prio: 10000
      });
    }
  }
  weekRenderer(parent, [year, week]) {
    if (!parent.querySelector('.b-week-toggle-tool-wrap')) {
      DomHelper.createElement({
        parent,
        className: 'b-week-toggle-tool-wrap',
        children: [{
          className: 'b-icon b-week-toggle-tool',
          dataset: {
            btip: this.L('L{WeekExpander.expandTip}')
          }
        }]
      });
    }
  }
  onWeekNumberClick({
    domEvent,
    date
  }) {
    const toggleTool = domEvent.target.closest('.b-week-toggle-tool');
    if (toggleTool && !this.disabled) {
      const weekRow = domEvent.target.closest('.b-calendar-row');
      // Shrinkwrapped means the row is expanded, toggle it to collapsed
      if (weekRow.classList.contains('b-shrinkwrapped')) {
        this.monthView.flexWeekRow(date);
        toggleTool.dataset.btip = this.L('L{expandTip}');
      }
      // And if it's collapsed, toggle it to expanded
      else if (weekRow.classList.contains('b-has-overflow')) {
        this.monthView.shrinkwrapWeekRow(date);
        toggleTool.dataset.btip = this.L('L{collapseTip}');
      }
      return false;
    }
  }
  updateDisabled(disabled, was) {
    super.updateDisabled(disabled, was);
    // Remove class when disabled. Eliminates toggling UI.
    this.client.element.classList.toggle('b-weekexpander', !disabled);
  }
}
// Register this feature type with its Factory
WeekExpander.initClass();
WeekExpander._$name = 'WeekExpander';

/**
 * @module Calendar/layout/day/DayLayout
 */
const getStyles = function (rtl) {
  var _me$left, _me$width;
  const me = this; // a DayLayoutItem (also why we cannot use => fn here)
  return {
    [rtl ? 'right' : 'left']: (_me$left = me.left) === null || _me$left === void 0 ? void 0 : _me$left.stringify(),
    top: me.top.stringify(),
    width: (_me$width = me.width) === null || _me$width === void 0 ? void 0 : _me$width.stringify(),
    height: me.height.stringify(),
    minWidth: me.minWidth
  };
};
/**
 * The item returned by the `layoutEvents` method.
 *
 * @typedef {Object} DayLayoutItem
 * @property {Scheduler.model.EventModel} eventRecord The `event` being displayed.
 * @property {DayLayoutCluster} cluster The cluster of events with overlapping times.
 * @property {Number} start The start time (as the number seconds since midnight) of the item.
 * @property {Number} end The end time (as the number seconds since midnight) of the item.
 * @property {Calendar.layout.LayoutDim} left The left position of the item.
 * @property {Calendar.layout.LayoutDim} top The top position of the item.
 * @property {Calendar.layout.LayoutDim} width The width of the item.
 * @property {Calendar.layout.LayoutDim} height The height of the item.
 * @property {Boolean} startsBefore Set to `true` if the event started in a previous day.
 * @property {Boolean} endsAfter Set to `true` if the event end in a future day.
 * @internal
 */
/**
 * A set of `items` that overlap. This object is passed to the `layoutCluster` method.
 *
 * @typedef {Object} DayLayoutCluster
 * @property {DayLayoutContext} context The layout context
 * @property {DayLayoutItem[]} items The items in this event cluster.
 * @property {Number} start The start time (as the number seconds since midnight) of the item.
 * @property {Number} end The end time (as the number seconds since midnight) of the item.
 * @internal
 */
/**
 * The object returned by `createLayoutContext`.
 *
 * @typedef {Object} DayLayoutContext
 * @property {DayCell} cellData An object containing information about the day cell being created.
 * @property {DayLayoutCluster[]} clusters The item clusters produced by `layoutEvents`.
 * @property {DayLayoutItem[]} items The items created by the `layoutEvents` method.
 * @property {Calendar.layout.day.DayLayout} layout The owing layout instance.
 * @internal
 */
/**
 * The base class for {@link Calendar.widget.DayView} layout algorithms.
 * @extends Core/Base
 * @abstract
 */
class DayLayout extends Base.mixin(Factoryable) {
  /**
   * This method is called prior to performing the layout in {@link #function-layoutEvents}.
   * @param {DayLayoutContext} context The layout context
   * @returns {DayLayoutContext}
   * @internal
   */
  beforeLayoutEvents(context) {
    this.owner.trigger('beforeLayoutEvents', {
      context
    });
    return context;
  }
  /**
   * This method packages items into clusters of overlapping items.
   * @param {DayLayoutCluster[]} clusters The cluster array being produced. This method adds to this array.
   * @param {DayLayoutItem[]} items The items array being produced. This method adds `item` to this array.
   * @param {DayLayoutItem} item The item to add and pack into a cluster.
   * @param {DayLayoutContext} context The layout context
   * @internal
   */
  clusterize(clusters, items, item, context) {
    const cluster = clusters[clusters.length - 1] || null; // undefined => null when clusters.length=0
    items.push(item);
    // Because items are in order of increasing start times, we don't have to worry about coalescing clusters.
    if (cluster && this.overlaps(cluster, item)) {
      item.cluster = cluster;
      cluster.end = Math.max(cluster.end, item.end);
      cluster.items.push(item);
      // If the item overlaps a cluster, we simply add it there and return. No other items can overlap
      // since items are added in order of start time.
    } else {
      // Item does not overlap, so make a new cluster.
      clusters.push(item.cluster = {
        context,
        start: item.start,
        end: item.end,
        items: [item]
      });
    }
  }
  /**
   * Populates and returns a layout context used for the layout process.
   * @param {DayCell} cellData An object containing information about the day cell being created.
   * @param {DomConfig} [dayDomConfig] The DomConfig element definition for the day cell into which events are being
   * rendered.
   * @returns {DayLayoutContext}
   * @internal
   */
  createLayoutContext(cellData, dayDomConfig) {
    const events = cellData === null || cellData === void 0 ? void 0 : cellData.events;
    return {
      cellData,
      dayDomConfig,
      // We need the events for the day to be sorted by startDate but limited to the start of the day. In
      // other words, all events that start before "midnight" are equally considered as starting at midnight.
      // This order of events is an assumption that runs deep in FluidDayLayout but also in clusterization.
      events: (events === null || events === void 0 ? void 0 : events.length) > 1 ? cellData.dayTime.sortEvents(cellData.date, events.slice()) : events || [],
      clusters: [],
      items: [],
      layout: this
    };
  }
  /**
   * Calculate the placements for the given events within the specified time range.
   * @param {DayCell} cellData An object containing information about the day cell being created.
   * @param {DomConfig} [dayDomConfig] The DomConfig element definition for the day cell into which events are being
   * rendered.
   * @returns {DayLayoutContext}
   * @internal
   */
  layoutEvents(cellData, dayDomConfig) {
    const me = this,
      context = me.beforeLayoutEvents(me.createLayoutContext(cellData, dayDomConfig)),
      {
        clusters,
        events,
        items
      } = context;
    let event, i, item, n;
    // As the base class, we simply pick up the events and wrap them in a layout item to contain their positions:
    for (event of events) {
      item = me.createLayoutItem(event, context);
      me.clusterize(clusters, items, item, context);
    }
    // cluster layouts are done in seconds:
    for (i = 0, n = clusters.length; i < n; ++i) {
      me.layoutCluster(clusters[i]);
    }
    me.owner.trigger('layoutEvents', {
      context
    });
    return context;
  }
  /**
   * Returns the base of a {@link Calendar.layout.day.DayLayout#typedef-DayLayoutItem} for the passed
   * event record.
   * @param {Scheduler.model.EventModel} eventRecord The event record for which to create a layout item.
   * @param {DayLayoutContext} context The layout context
   * @returns {DayLayoutItem}
   * @internal
   */
  createLayoutItem(eventRecord, context) {
    // Note: DH.diff() does not produce the correct layout position if DST adjustment lands on "date"
    const {
        date,
        tomorrow,
        dayEnd,
        dayTime
      } = context.cellData,
      {
        allDay,
        startDate,
        endingDate
      } = eventRecord,
      startSec = allDay || startDate < date ? 0 : dayTime.delta(startDate, 's'),
      endSec = allDay || endingDate >= tomorrow ? dayEnd : dayTime.delta(endingDate, 's'),
      start = Math.max(startSec, 0),
      end = Math.min(endSec, dayEnd),
      top = LayoutDim.from(start / dayEnd);
    return {
      eventRecord,
      getStyles,
      start,
      end,
      top,
      id: eventRecord.id,
      height: new LayoutDim(end / dayEnd, 0).sub(top),
      startsBefore: startDate < date || startSec < 0,
      endsAfter: tomorrow < endingDate || endSec > dayEnd
    };
  }
  overlaps(a, b, tolerance, end) {
    var _tolerance;
    // minutes => seconds
    if (typeof tolerance === 'string') {
      end = tolerance;
      tolerance = null;
    }
    end = end || 'end';
    tolerance = (_tolerance = tolerance) !== null && _tolerance !== void 0 ? _tolerance : this.overlapTolerance * 60 || 0; // avoid NaN
    return a.start < b[end] - tolerance && b.start < a[end] - tolerance;
  }
  syncGutter() {
    this.owner.setStyle('--dayview-cell-gutter', String(LayoutDim.get(this.gutter && this.gutterWidth)));
  }
  updateGutter() {
    this.syncGutter();
  }
  updateGutterWidth() {
    this.syncGutter();
  }
  updateInset(inset) {
    this.owner.setStyle('--dayview-cell-inset-size', String(LayoutDim.get(inset)));
  }
}
_defineProperty(DayLayout, "factoryable", {
  // establish this class as the Factoryable base
});
_defineProperty(DayLayout, "configurable", {
  /**
   * Set to `false` to disable the gap on the right-most edge of events. See {@link #config-gutterWidth} to
   * control the size of the gutter.
   *
   * The gutter allows the user to select the times overlapped by events, for example, to create new events.
   * @config {Boolean}
   * @default
   */
  gutter: true,
  /**
   * The number of pixels or proportion of the overall width to allocate to the {@link #config-gutter}.
   *
   * Values less than 1 are the fractional proportion of the width (for example, 0.04 is 4% of the width),
   * while values greater than or equal to 1 are a number of pixels.
   * @config {Number}
   * @default
   */
  gutterWidth: 5,
  /**
   * The number of pixels or proportion of the overall width to allocate for rendering on outside the area where
   * events are displayed. This space is used by {@link Calendar.feature.TimeRanges} to render arbitrary spans of
   * time on either side of the day's events.
   *
   * Values less than 1 are the fractional proportion of the width (for example, 0.04 is 4% of the width),
   * while values greater than or equal to 1 are a number of pixels.
   * @config {Number}
   * @default
   */
  inset: 40,
  /**
   * The minimum number of minutes an event must overlap another event before it is considered an overlap
   * for layout purposes.
   *
   * The default value of 0 treats any overlap in time as an overlap in the layout.
   * @config {Number}
   * @default 0
   * @internal
   */
  overlapTolerance: null,
  owner: null
});
DayLayout._$name = 'DayLayout';

/**
 * @module Calendar/layout/day/FluidDayLayout
 */
class Packer extends PackMixin() {
  static get defaultConfig() {
    return {
      coordProp: 'left',
      sizeProp: 'width'
    };
  }
  pack(items) {
    const wrappedItems = items.map(item => {
      const {
          startDate
        } = item.eventRecord,
        endDate = new Date(startDate);
      endDate.setSeconds(endDate.getSeconds() + item.maxEnd - item.start);
      return {
        item,
        start: startDate,
        end: endDate,
        x: 0
      };
    });
    this.packEventsInBands(wrappedItems, (itemData, clusterIndex, slot, slotSize) => {
      // This logic was extracted from Scheduler/eventlayout/VerticalLayout#applyLayout
      itemData.width = slotSize;
      itemData.w = slotSize * COLUMN_WIDTH;
      itemData.x += (itemData.left = slot.start + clusterIndex * slotSize) * COLUMN_WIDTH;
      itemData.item.x = itemData.x;
      itemData.item.w = itemData.w;
    });
  }
}
const COLUMN_WIDTH = 10000,
  EMPTY = Object.freeze([]),
  packer = new Packer();
/**
 * This class positions events for a `DayView` by maximizing the visible area of each event. When events overlap, this
 * class determines the minimum amount of horizontal indent required for the overlapping events so that as much of
 * their content as possible is unobstructed.
 *
 * @extends Calendar/layout/day/DayLayout
 */
class FluidDayLayout extends DayLayout {
  createLayoutContext(cellData, dayDomConfig) {
    const me = this,
      context = super.createLayoutContext(cellData, dayDomConfig),
      {
        staggerWidth
      } = me;
    // These values are consistent for all clusters in a given day, so cache them on the layout context (also
    // allows for event listeners to tweak these prior to our using them - lookin' at you timeRanges):
    return Object.assign(context, {
      indentWidth: LayoutDim.get(me.indentWidth),
      stagger: new LayoutDim(),
      // just a reused instance
      staggerMaximum: LayoutDim.from(me.staggerMaximum),
      // can be null
      staggerMinimum: me.staggerMinimum,
      staggerWidth: LayoutDim.from(staggerWidth === true ? me.gutterWidth : staggerWidth),
      stretch: me.stretch
    });
  }
  layoutCluster(cluster /* , parentItem */) {
    const me = this,
      {
        context,
        items
      } = cluster,
      {
        indentWidth,
        stagger,
        staggerMaximum,
        staggerMinimum,
        staggerWidth,
        stretch
      } = context,
      treeLevels = me.treeify(items);
    me._assignSizes(items, treeLevels);
    for (const item of items) {
      /*
              +---------------------------------------+                          :
              |                                       |                          :
              |      +-----------------------------------------+                 :
              |      |                                         |                 :
              |      |                                         |                 :
              |      |      +-------------------------------------------+        :
              +------|      |                                           |        :
                     |      |                                           |        :
                     |      |                                           |        :
                     |      +-------------------------------------------+        :
                     |                                         |                 :
                     +-----------------------------------------+        ^        :
                                                                        |        :
                     ^                                         ^        |
              ^      |                                         |        |        ^
              |<---->|                                         |<------>|<------>|
              |indent|                                         | stagger  gutter |
              |      |<--------------------------------------->|                 |
              |               width                                              |
              |<---------------------------------------------------------------->|
                              root.w
       */
      const
        // { children } = item.eventRecord,
        depth = item.depth,
        left = new LayoutDim(),
        width = new LayoutDim(),
        root = item.majorParent || item;
      for (const k of stagger) {
        stagger[k] = staggerWidth[k] * (depth.height + depth.overlap);
        stagger[k] = staggerMaximum !== null && staggerMaximum !== void 0 && staggerMaximum[k] ? Math.min(staggerMaximum[k], stagger[k]) : stagger[k];
      }
      left.r = root.x + depth.minor * indentWidth.r * root.w;
      left.d = depth.minor * indentWidth.d;
      width.r = stretch ? 1 - left.r : root.w - left.r + root.x;
      width.d = -left.d;
      // if (parentItem) {
      //     left.r += parentItem.left.r;
      //     left.d += parentItem.left.d + parentItem.width.d;
      //
      //     width.r *= parentItem.blockWidth.r;
      //     width.d += parentItem.blockWidth.d - parentItem.width.d;
      // }
      if (staggerMinimum) {
        // The staggerMinimum is a proportion of the ideal width, which is the column's width minus the left
        // edge (i.e., the width w/o accounting for stagger).
        item.minWidth = `calc(${staggerMinimum} * (${width}))`;
      }
      width.r -= stagger.r * root.w;
      width.d -= stagger.d;
      item.left = left;
      item.width = width;
      // TODO remove "&& !newEvent.isParent" from EventDayIndex to get parent events in the layout
      // if (children) {
      //     item.blockWidth = width;
      //     item.width = new LayoutDim(0, 42);
      //     item.minWidth = null;
      //
      //     const childCluster = {
      //         ...cluster,
      //         items : children.map(c => me.createLayoutItem(c, context))
      //     };
      //
      //     context.items.splice(context.items.indexOf(item) + 1, 0, ...childCluster.items);
      //     // NOTE: we do NOT add these to cluster.items since we are currently looping over these (fortunately,
      //     // we do not need to do so either)
      //
      //     childCluster.items.forEach(ci => ci.cluster = childCluster);  // normally done by clusterize()
      //
      //     me.layoutCluster(childCluster, item);
      // }
    }
  }

  treeify(items) {
    const treeLevels = [];
    // Organize items as a tree where parents can have two kinds of children: minor overlap and major overlap.
    // The tree starts as a sorted list which can be seen as each parent having one child.
    for (let i = 0; i < items.length; i++) {
      this._addChild(items[i], i, treeLevels);
    }
    return treeLevels;
  }
  _addChild(item, order, treeLevels) {
    const me = this,
      {
        clearanceMinutes,
        escapeMinutes,
        stretch
      } = me,
      clearanceSeconds = clearanceMinutes * 60,
      escapeSeconds = clearanceSeconds + escapeMinutes * 60,
      overlapTolerance = (me.overlapTolerance || 0) * 60,
      // minutes => seconds
      isMinor = (a, b) => Math.abs(b.start - a.start) >= clearanceSeconds,
      scoreFn = item => item.depth.minor * 10 + item.depth.major * (stretch ? 1 : 0),
      depth = {
        // The true depth from the root of the tree, regardless of major/minor distinctions.
        depth: 0,
        // The number of steps up from the deepest minor child to this node.
        height: 0,
        // The number of steps up from the deepest major child to this node.
        heightMajor: 0,
        // The number of items this item overlaps. This happens when a node clears the end time of a higher
        // level node and is elevated. This ensures that the bottom of these overlapped events are exposed
        // by the staggered width of this item. See item 2 in example C below.
        overlap: 0,
        // The number of major overlaps for this item and its ancestry. More space is allocated in this case
        // then for minor overlaps. The number of minor overlaps per major overlap is held in "clearanceScale".
        major: 0,
        // The number of minor overlaps for this item and its ancestry. When there is sufficient content shown
        // for a parent, a child can be indented by much less without hiding those details. This minimal amount
        // of overlap is specified in seconds via "clearanceSeconds".
        minor: 0
      };
    // Each item's parent is determined below, but initially we assign items as root (left-most).
    item.parent = null;
    item.maxEnd = item.maxEndMajor = item.end;
    item.depth = depth;
    item.order = order;
    if (!treeLevels.length) {
      // Nothing much to do with the first item...
      treeLevels[0] = item;
      item.barriers = EMPTY;
      return;
    }
    let best = 0,
      // actual value isn't important when !parent, however we get warnings w/o assigning a value
      child,
      major,
      minor,
      p,
      parent,
      score;
    // The goal of this loop is to determine the best parent for item
    for (p of treeLevels) {
      child = p.lastItem || p;
      if (!me.overlaps(item, p, overlapTolerance, 'maxEnd')) {
        /*
            treeLevels
                   [0]             [1]             [2]             [3]
            +---------------+---------------+---------------+---------------+
            : +-----------+ : +-----------+ :               :               :
            : |           | : |           | : +-----------+ : +-----------+ :
            : |           | : |           | : |           | : |           | :
            : |           | : +-----------+ : |           | : |           | :
            : |           | :               : |           | : |           | :
            : |           | : +-----------+ : |           | : +-----------+ :
            : +-----------+ : |    item   | : +-----------+ :               :
            :               : +-----------+ :               :               :
            If there is a tree level that item does not overlap, attach item there. We want to put item at the
            highest level of the tree (aka left-most) so we break the loop now.
        */
        parent = p.parent;
        major = true;
        break;
      }
      if (isMinor(item, child)) {
        /*
            treeLevels
                   [0]             [1]             [2]             [3]
            +---------------+---------------+---------------+---------------+
            : +-----------+ : +----------+  :               :               :
            : |           | : |          |  : +----------+  : +----------+  :
            : |           | : |          |  : |          |  : |          |  :
            : |           | : |          |  : | +---------+ : | +---------+ :
            : |           | : |          |  : | |         | : | |         | :
            : |           | : | +---------+ : | |         | : | |         | :
            : |           | : | |         | : | |         | : | |         | :
            : |           | : +-|   item  | : | |         | : | |         | :
            : |           | :   +---------+ : | |         | : | |         | :
            : |           | :               : | +---------+ : | +---------+ :
            : |           | :               : |          |  : |          |  :
            : |           | :               : |          |  : +----------+  :
            : +-----------+ :               : +----------+  :               :
            :               :               :               :               :
            If we have a minor overlap with a level, we want to attach item where we minimize the depth of the
            minor overlap. Set the minor flag to note that we should no longer consider major overlaps.
        */
        minor = true;
        if (major) {
          // The current candidate is a major overlap, so clear the major flag and reset parent so that we
          // pick this level as the initial best choice.
          major = false;
          parent = null;
        }
        for /* empty */
        (; child !== p; child = child.parent) {
          // For scoring purposes, we don't include "escape" climbing, just overlapping.
          if (me.overlaps(child, item, overlapTolerance)) {
            break;
          }
        }
        score = scoreFn(child);
        if (!parent || score < best) {
          // either we had no current winner (!parent) or this child has a better score (lower, like golf).
          parent = child;
          best = score;
        }
      } else if (!minor) {
        /*
            treeLevels
                   [0]             [1]             [2]             [3]
            +---------------+---------------+---------------+---------------+
            : +-----------+ : +-----------+ :               :               :
            : |           | : |           | : +-----------+ : +-----------+ : +-----------+
            : |           | : |           | : |           | : |           | : |           |
            : |           | : +-----------+ : |           | : |  parent <--------  item   |
            : |           | :               : |           | : |           | : |           |
            : |           | :               : |           | : |           | : +-----------+
            : |           | :               : |           | : +-----------+ :
            : +-----------+ :               : +-----------+ :               :
            :               :               :               :               :
            If we have no minor overlaps (yet), the deepest (right-most) major overlap will be the parent
        */
        major = true;
        parent = p;
      }
    }
    // Since we have at least one item in treeLevels, the above loop will always end with the major or minor flag
    // set to true.
    if (major) {
      // In a major overlap parent could be null (if item does not overlap treeLevels[0])
      minor = 0;
      major = parent ? parent.depth.major + 1 : 0;
      p = parent = treeLevels[major - 1] || null;
    } else {
      // In a minor overlap parent will be the child item that we overlapped.
      p = parent.majorParent || parent;
      // Now account for escaping
      for /* empty */
      (; escapeSeconds && parent !== p; parent = parent.parent) {
        if (me.overlaps(parent, item, overlapTolerance) && item.start - parent.start < escapeSeconds) {
          break;
        }
      }
      minor = parent.depth.minor + 1;
      major = parent.depth.major;
    }
    // major is the number of major parent items (i.e., the depth including only major parents)
    // minor is the depth of the item below its major parent (!minor indicates that item is a major overlap)
    // p is the major parent (the parent that is not a minor overlap of another item)
    // parent is the immediate parent (maybe the major parent or a child)
    // p and parent may be null (when major = 0 and !minor)
    item.parent = parent;
    depth.major = major;
    depth.minor = minor;
    depth.depth = parent ? parent.depth.depth + 1 : 0;
    if (minor) {
      // now that major and minor are depths, only minor can be treated as a boolean
      item.majorParent = p;
      item.previousItem = p.lastItem;
      p.lastItem = item;
    } else {
      me._addMajor(item, treeLevels);
    }
    me._adjustOverlap(item);
    me._adjustParents(item);
  }
  _addMajor(item, treeLevels) {
    const me = this,
      {
        stretch
      } = me,
      level = item.depth.major;
    treeLevels[level] = item;
    item.barriers = me._getOverlaps(treeLevels, item, 1);
    if (stretch || item.barriers.length) {
      // Barriers are prior overlapping events that are deeper in the tree which restrict the width of item. If
      // these barrier events are in the list of barriers for items higher in the tree, replace them with this
      // item.
      //
      // To calculate stretch overlap we need to track all paths. For non-stretch mode, we can skip this for
      // items that have no barriers (in essence, these provide their contribution in heightMajor of the item's
      // depth). Further, this optimization is important for use cases with lots of overlapping events (see
      // https://github.com/bryntum/support/issues/3140)
      for (const prior of me._getOverlaps(treeLevels, item, -1)) {
        // Remove common barriers:
        const barriers = prior.barriers.filter(b => !item.barriers.includes(b));
        if (stretch || barriers.length < prior.barriers.length) {
          // if (we have common barriers)
          prior.barriers = barriers;
          barriers.push(item);
        }
      }
    }
  }
  _adjustOverlap(item) {
    if (item.depth.minor) {
      let overlap, p;
      for (p = item; p.depth.minor > 1; p = p.parent) {
        // empty
      }
      // p is the top-most minor child of item in our parent
      for /* empty */
      (overlap = 0; p = p.previousItem;) {
        if (this.overlaps(p, item)) {
          overlap = Math.max(overlap, p.depth.height + p.depth.overlap + 1);
        }
      }
      item.depth.overlap = overlap;
    }
  }
  _adjustParents(item) {
    const {
        depth,
        end
      } = item,
      level = depth.minor + depth.overlap;
    for /* empty */
    (let parentDepth, p = item; p = p.parent;) {
      parentDepth = p.depth;
      if (parentDepth.major !== depth.major) {
        parentDepth.heightMajor = Math.max(parentDepth.heightMajor, depth.major - parentDepth.major);
        continue;
      }
      // Update the parent's maxEnd to include the new child
      p.maxEnd = Math.max(p.maxEnd, end);
      // Also update the height of all parent nodes to account for the new child
      while (parentDepth.height < level - parentDepth.minor) {
        // may be > 1 loop w/overlap
        ++parentDepth.height;
        if (parentDepth.overlap) {
          --parentDepth.overlap;
        }
      }
    }
  }
  _assignSizes(items, treeLevels) {
    const {
        complexityLimit,
        stretch
      } = this,
      topLevelItems = items.filter(it => !it.depth.minor);
    if (!complexityLimit) {
      packer.pack(topLevelItems);
      for (const item of topLevelItems) {
        item.x /= COLUMN_WIDTH;
        item.w /= COLUMN_WIDTH;
      }
    } else {
      for (const item of topLevelItems) {
        const paths = item.barriers.map(b => [b]),
          {
            parent
          } = item,
          height = item.depth.heightMajor + 1; // the height of this subtree; +1 to include item
        item.x = parent ? parent.x + parent.w : 0;
        let w = (1 - item.x) / height,
          // best-case width (excluding prior overlapping events)
          i,
          include,
          longest,
          path,
          tail,
          v,
          x;
        if (paths.length) {
          // Here we are treating the prior overlapping events as children of a sort, which converts our
          // tree into a DAG (directed, acyclic graph). We want to consider all paths from item to terminal
          // items in the DAG (items with no children). Each path provides a possible space allocation. It
          // is the minimum space allocation we are after.
          for (i = 0; i < paths.length;) {
            path = paths[i];
            longest = longest || path; // may hit complexityLimit or never improve on best case
            if (i > complexityLimit) {
              w = 1 / treeLevels.length; // worst-case width
              break;
            }
            tail = path[path.length - 1];
            if (tail.order < item.order) {
              // A path is a terminal path if the tail item is a prior event (order is just a number like
              // 1, 2, 3, etc. that we set on each event as we process it).
              ++i;
              x = tail.x; // that prior event has an x coordinate, so we must not overlap it
              include = 0; // do not include the tail event as we divvy up the space
            } else if (!tail.barriers.length) {
              // The tail event has no barriers, but because item is prior to tail, tail has no x value
              // determined yet.
              ++i;
              x = 1; // divvy up all remaining space
              include = 1; // but include the tail item in the split
            } else {
              // There could be too many levels to the tree to directly recurse, so we just replace this
              // non-terminal path with the set of paths that include the next layer. These may be either
              // terminal, non-terminal or both, but we'll explore them by not incrementing "i".
              paths.splice(i, 1, ...tail.barriers.map(b => path.concat(b)));
              if (longest === path) {
                longest = null; // non-terminal path cannot be the longest path
              }

              continue;
            }
            v = (x - item.x) / (include + path.length); // the width of item for this path
            if (v < w) {
              w = v;
              longest = path;
            }
          }
          if (stretch) {
            // In stretch mode, the idea is to expand the width of columns to cover the width of the view,
            // but we need to account for overlapping items in the way. We use the longest path (the path
            // that determined the item's width) to calculate additional overlaps for this item and its
            // minor children:
            v = longest.reduce((s, it) => s + it.depth.height + 1, 0); // sum of minor stacking depths
            for (i = item.lastItem; i; i = i.previousItem) {
              i.depth.overlap += v;
            }
            item.depth.overlap += v;
          }
        }
        item.w = w;
      }
    }
  }
  _getOverlaps(treeLevels, item, step) {
    const {
        end
      } = item,
      // item has no minor children yet, so end === maxEnd for item...
      stop = step < 0 ? -1 : treeLevels.length;
    let {
        start
      } = item,
      i,
      other,
      ret;
    for (i = item.depth.major + step; i !== stop && start < end; i += step) {
      other = treeLevels[i];
      /*
          Consider (step = 1):
                                other[1]            other[2]    other[3]
                                 -+- other.start
                                  |                  -+-
                                  |                   |          -+-
                      item        |                   |           |
               start  -+-         |                   |           |
                       |         -+- other.end        |           |
                       |                             -+-         -+-
                       |
                 end  -+-
          item overlaps other[1] and other[2] but not other[2] because you cannot draw a horizontal line that
          intersects item and other[3] w/o crossing through other[0] or other[1].
          Consider (step = -1):
                     other[-3]           other[-2]   other[-1]
                      -+- other.start
                       |                  -+-
                       |                   |          -+-            item
                       |                   |           |             -+-  start
                       |                   |           |              |
                       |                  -+-         -+-             |
                       |                                             -+-  end
                      -+- other.end
          In the reverse case, we are likewise looking for items that pass the horizontal line test. So the
          overlaps are other[-1] and other[-3].
       */
      if (start < other.maxEnd && other.start < end) {
        (ret || (ret = [])).push(other);
        start = other.maxEnd;
      }
    }
    return ret || EMPTY;
  }
}
_defineProperty(FluidDayLayout, "type", 'fluid');
_defineProperty(FluidDayLayout, "configurable", {
  /**
   * The number of minutes of an event that must be (vertically) cleared by another event before it is
   * allowed to be significantly overlapped by it (horizontally).
   *
   * For example:
   * ```
   *       >= clearanceMinutes          < clearanceMinutes
   *      +--------------+            +----------------+
   *      | Event 1      |            | Event 3        |
   *      | 9am-11am     |            | 9am-11am +-------------+
   *      |  +----------------+       |          | Event 4     |
   *      |  | Event 2        |       |          | 9:30am-12pm |
   *      |  | 10am-12pm      |       |          |             |
   *      |  |                |       |          |             |
   *      +--|                |       +----------|             |
   *         |                |                  |             |
   *         +----------------+                  +-------------+
   * ```
   * In the example above, the start time of Event 2 is more than `clearanceMinutes` after the start time of
   * Event 1, therefore it is displayed with a minimal indent from the left of Event 1. The start time of
   * Event 4, however, is less than `clearanceMinutes` after Event 3 and so they both share the space evenly.
   * @config {Number}
   * @default
   */
  clearanceMinutes: 45,
  /**
   * The maximum number of possible solutions to evaluate when calculating an event's width.
   * @config {Number}
   * @internal
   * @default
   */
  complexityLimit: 2000,
  /**
   * The number of minutes of an overlapping event that must be (vertically) cleared by another event before
   * it is allowed to be fully overlapped by it (horizontally). THis value is a number of minutes _beyond_
   * {@link #config-clearanceMinutes}. In other words, if `clearanceMinutes` is 45 and this config is set to
   * 75, the start time of an event must be two hours (45+75 = 120 minutes) after the prior event to fully
   * overlap it.
   *
   * For example:
   * ```
   *       >= escapeMinutes                    < escapeMinutes
   *      +----------------+                 +----------------+
   *      | Event 1        |                 | Event 5        |
   *      | 9am-11am +-------------+         | 9am-11am +-------------+
   *      |          | Event 2     |         |          | Event 6     |
   *      |          | 9:30am-12pm |         |          | 9:30am-12pm |
   *      |          |             |         |          |  +-------------+
   *      |  + --------------------+         |          |  | Event 7     |
   *      +--| Event 3             |         +----------|  | 10:15am     |
   *         | 10:30am             |                    |  |             |
   *         |                     |                    +--|             |
   *         +---------------------+                       +-------------+
   * ```
   * In the example above, the start time of Event 3 is more than `escapeMinutes` after the start time of
   * Event 2, therefore it is allowed to fully overlap the bottom of Event 2. As can be seen above, this does
   * not allow Event 3 to overlap the top-most overlapping event (Event 1). In the case of Event 7, the event
   * starts less than `escapeMinutes` after Event 6 and so the left edge of Event 6 remains exposed. The
   * positioning of Event 7 is determined by {@link #config-clearanceMinutes}.
   * @config {Number}
   * @default
   * @internal
   */
  escapeMinutes: null,
  // TODO make public once adequately tested
  /**
   * The number of pixels or proportion of the overall width to indent overlapping events that overlap by at
   * least {@link #config-clearanceMinutes}. Events that overlap by less than `clearanceMinutes` will split
   * the available space.
   *
   * Values less than 1 are the fractional proportion of the width (for example, 0.04 is 4% of the width),
   * while values greater than or equal to 1 are a number of pixels.
   * @config {Number}
   * @default
   * @internal
   */
  indentWidth: 10,
  /**
   * The maximum amount of width reduction due to overlapping items. If {@link #config-gutterWidth} is a
   * number of pixels, this value must also be in pixels (i.e., >= 1). Otherwise, this value is a proportional
   * value between 0 and 1.
   *
   * Even though this value limits the width reduction from overlapping items, it is possible that this
   * value exceeds the event width due to its nesting level (the number of prior events this event overlaps).
   * In this case, the {@link #config-staggerMinimum} value will prevent the width from becoming too small.
   * @config {Number}
   * @default
   * @internal
   */
  staggerMaximum: null,
  /**
   * This is the minimum width to which `staggerWidth` will size an event. For example, if an event has many
   * overlapping events, its width may be reduced a number of steps due to `staggerWidth`. This value limits
   * how much the event's width will be reduced.
   *
   * This value is expressed as a decimal proportion of the width of 1. For example, the value 0.4 is 40% of
   * the actual width. With this setting, the `staggerWidth` calculation will not reduce an event's width
   * below 40%.
   * @config {Number}
   * @default
   */
  staggerMinimum: 0.4,
  /**
   * When enabled, the width of an event is reduced in steps based on the number of events that overlap it.
   * Set this config to `false` or 0 to disable this effect.
   *
   * If this value is a boolean, the `gutterWidth` is used for the size of the reduction. If this value is a
   * number, it is the size of the reduction. For example, a value of 0.05 would cause an event to reduce in
   * steps of 5% width based on the number of events that overlap it. A number >= 1 is a number of pixels,
   * however, this is only valid if `gutterWidth` is also a number of pixels.
   *
   * By default, events are reduced by the `gutterWidth` based on the number of events that overlap them.
   * @config {Boolean|Number}
   * @default
   */
  staggerWidth: true,
  /**
   * Set this to `true` to use the full day width for events. By default, overlapping events equally split the
   * width.
   * @config {Boolean}
   * @default false
   */
  stretch: null
});
FluidDayLayout.initClass();
FluidDayLayout._$name = 'FluidDayLayout';

/**
 * @module Calendar/mixin/CalendarStores
 */
/**
 * Functions for store assignment and store event listeners.
 *
 * @mixin
 * @extends Scheduler/data/mixin/ProjectConsumer
 */
var CalendarStores = (Target => {
  var _class;
  return _class = class CalendarStores extends ProjectConsumer(Target || Base) {
    //region Default config
    // This is the static definition of the Stores we consume from the project, and
    // which we must provide *TO* the project if we or our CrudManager is configured
    // with them.
    // The property name is the store name, and within that there is the dataName which
    // is the property which provides static data definition. And there is a listeners
    // definition which specifies the listeners *on this object* for each store.
    //
    // To process incoming stores, implement an updateXxxxxStore method such
    // as `updateEventStore(eventStore)`.
    //
    // To process an incoming Project implement `updateProject`. __Note that
    // `super.updateProject(...arguments)` must be called first.__
    static get projectStores() {
      return {
        resourceStore: {
          dataName: 'resources',
          listeners: {
            changePreCommit: 'onCalendarStoreChange'
          }
        },
        eventStore: {
          dataName: 'events',
          listeners: {
            changePreCommit: 'onCalendarStoreChange'
          }
        },
        assignmentStore: {
          dataName: 'assignments'
        },
        timeRangeStore: {
          dataName: 'timeRanges',
          modelClass: TimeRangeModel
        },
        resourceTimeRangeStore: {
          dataName: 'resourceTimeRanges',
          modelClass: ResourceTimeRangeModel
        }
      };
    }
    /**
     * Inline events, will be loaded into an internally created EventStore.
     * @config {Scheduler.model.EventModel[]|EventModelConfig[]} events
     * @category Data
     */
    /**
     * The {@link Scheduler.data.EventStore} holding the events to be rendered into the Calendar (required).
     * @config {Scheduler.data.EventStore} eventStore
     * @category Data
     */
    /**
     * Inline resources, will be loaded into an internally created ResourceStore.
     * @config {Scheduler.model.ResourceModel[]|ResourceModelConfig[]} resources
     * @category Data
     */
    /**
     * The {@link Scheduler.data.ResourceStore} holding the resources to be rendered into the Calendar (required).
     * @config {Scheduler.data.ResourceStore} resourceStore
     * @category Data
     */
    /**
     * Inline assignments, will be loaded into an internally created AssignmentStore.
     * @config {Scheduler.model.AssignmentModel[]|AssignmentModelConfig[]} assignments
     * @category Data
     */
    /**
     * The {@link Scheduler.data.AssignmentStore} holding assignments linking resources to events.
     * @config {Scheduler.data.AssignmentStore} assignmentStore
     * @category Data
     */
    //endregion
    //region CrudManager
    changeCrudManager(crudManager) {
      var _me$bindCrudManager;
      const me = this;
      if (crudManager && !crudManager.isCrudManager) {
        const type = crudManager.type || me.crudManagerClass;
        // CrudManager injects itself into is Scheduler's _crudManager property
        // because code it triggers needs to access it through its getter.
        crudManager = type.new({
          scheduler: me
        }, crudManager);
      }
      // config setter will veto because of above described behaviour
      // of setting the property early on creation
      me._crudManager = crudManager;
      (_me$bindCrudManager = me.bindCrudManager) === null || _me$bindCrudManager === void 0 ? void 0 : _me$bindCrudManager.call(me, crudManager);
    }
    //endregion
    updateTimeZone(timeZone) {
      this.project.timeZone = timeZone;
    }
    // When project changes time zone, change Calendar date.
    // This is an override from ProjectConsumer.
    onTimeZoneChange({
      timeZone,
      oldTimeZone
    }) {
      const me = this,
        // Only one receiver of this event should change Calendar date.
        // The Calendar's activeView if we are inside a Calendar, or this view if not
        target = me.isCalendar ? me.activeView : !me.calendar && me;
      if (target) {
        const date = oldTimeZone ? TimeZoneHelper.fromTimeZone(target.date, oldTimeZone) : target.date;
        (target.calendar || target).date = timeZone ? TimeZoneHelper.toTimeZone(date, timeZone) : date;
      }
    }
    /**
     * The default Calendar to be used when creating new events which do not initially have a resource.
     *
     * This includes {@link Calendar.view.Calendar#config-autoCreate dblclick-created} events and
     * {@link Calendar.feature.CalendarDrag drag-created} events and
     * {@link Calendar.feature.ExternalEventSource dragged in} events.
     * @property {Scheduler.model.ResourceModel}
     */
    get defaultCalendar() {
      const {
          eventStore
        } = this,
        defaultCalendar = ObjectHelper.hasOwn(this, '_defaultCalendar') ? this._defaultCalendar : eventStore.defaultCalendarId;
      if (defaultCalendar !== null) {
        return defaultCalendar != undefined ? defaultCalendar.isResourceModel ? defaultCalendar : eventStore.resourceStore.getById(defaultCalendar) : eventStore.resourceStore.first;
      }
    }
    get defaultCalendarId() {
      return this.eventStore.modelClass.asId(this.defaultCalendar);
    }
    //region Project
    updateProject(project, oldProject) {
      super.updateProject(project, oldProject);
      // Now is the time to force timeZone ingestion. When we have all our stores.
      this.getConfig('timeZone');
      this.detachListeners('CalendarStores');
      project.ion({
        name: 'CalendarStores',
        dataReady: 'onCalendarStoreChange',
        refresh: 'onProjectRefresh',
        thisObj: this
      });
    }
    onProjectRefresh({
      source: project,
      isInitialCommit
    }) {
      // Force reevaluation of date indices next time requested because the
      // initial project commit may have rescheduled the events.
      if (isInitialCommit) {
        project.eventStore.invalidateDayIndices();
      }
    }
    updateEventStore(eventStore, oldEventStore) {
      if (oldEventStore) {
        delete oldEventStore.createRecord;
      }
      // Decorate the eventStore's createRecord method to inject our defaultCalendar into new
      // events as the default resource.
      if (eventStore && !eventStore.isCalendarEventStore) {
        const storeOwner = this;
        Object.defineProperty(eventStore, 'defaultCalendar', {
          get: () => storeOwner.defaultCalendar
        });
        eventStore.isCalendarEventStore = true;
      }
    }
    //endregion
    //region AssignmentStore
    /**
     * Get/set assignments, applies to the backing project's AssignmentStore.
     * @member {Scheduler.model.AssignmentModel[]} assignments
     * @accepts {Scheduler.model.AssignmentModel[]|AssignmentModelConfig[]}
     * @category Data
     */
    /**
     * Get/set the assignment store instance of the backing project.
     * @member {Scheduler.data.AssignmentStore} assignmentStore
     * @category Data
     */
    //endregion
    //region EventStore
    /**
     * Get/set events, applies to the backing project's EventStore.
     * @member {Scheduler.model.EventModel[]} events
     * @accepts {Scheduler.model.EventModel[]|EventModelConfig[]}
     * @category Data
     */
    /**
     * Get/set the event store instance of the backing project.
     * @member {Scheduler.data.EventStore} eventStore
     * @category Data
     */
    //endregion
    //region ResourceStore
    /**
     * Get/set resources, applies to the backing project's ResourceStore.
     * @member {Scheduler.model.ResourceModel[]} resources
     * @accepts {Scheduler.model.ResourceModel[]|ResourceModelConfig[]}
     * @category Data
     */
    /**
     * Get/set the resource store instance of the backing project
     * @member {Scheduler.data.ResourceStore} resourceStore
     * @category Data
     */
    //endregion
    //region WidgetClass
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {}
    //endregion
  }, _defineProperty(_class, "$name", 'CalendarStores'), _defineProperty(_class, "configurable", {
    /**
     * The calendar ({@link Scheduler.model.ResourceModel Resource}), (or its `id`) to use as the
     * default calendar for new events created using {@link Calendar.view.Calendar#config-autoCreate dblclick}
     * or {@link Calendar.feature.CalendarDrag drag-create}, or {@link Calendar.feature.ExternalEventSource dragging in}.
     *
     * May be specified as the `id` of an existing resource, or a resource record that is present in the project.
     *
     * If not specified, the first record in the {@link #property-resourceStore} will be used.
     *
     * If specified as `null`, then new events created using {@link Calendar.view.Calendar#config-autoCreate dblclick}
     * or {@link Calendar.feature.CalendarDrag drag-create}, or {@link Calendar.feature.ExternalEventSource dragging in}
     * will not be automatically assigned a calendar.
     * @config {String|Scheduler.model.ResourceModel}
     */
    defaultCalendar: null,
    /**
     * Class that should be used to instantiate a CrudManager in case it's provided as a simple object to
     * {@link #config-crudManager} config.
     * @config {Scheduler.data.CrudManager}
     * @category Data
     */
    crudManagerClass: CrudManager,
    /**
     * Get/set the CrudManager instance
     * @member {Scheduler.data.CrudManager} crudManager
     * @category Data
     */
    /**
     * Supply a {@link Scheduler.data.CrudManager} instance or a config object if you want to use
     * CrudManager for handling data.
     * @config {CrudManagerConfig|Scheduler.data.CrudManager}
     * @category Data
     */
    crudManager: null,
    /**
     * Set to a time zone or a UTC offset. This will set the projects
     * {@link Scheduler.model.ProjectModel#config-timeZone} config accordingly. As this config is only a referer,
     * please se project's config {@link Scheduler.model.ProjectModel#config-timeZone documentation} for more
     * information.
     *
     * ```javascript
     * new Calendar(){
     *   timeZone : 'America/Chicago'
     * }
     * ```
     * @config {String|Number} timeZone
     * @category Misc
     */
    timeZone: {
      // Don't ingest the config eagerly because it relies on project being present.
      // Lazy means it waits for ingestion until timeZone property is referenced.
      $config: 'lazy',
      value: null
    }
  }), _defineProperty(_class, "defaultConfig", {
    projectModelClass: ProjectModel
  }), _class;
});

/**
 * @module Calendar/util/EventSlots
 */
/**
 * An Array which allows prefilling of some slots and automatic filling
 * of vacant slots.
 *
 * Used by the Calendar to fill event slots in day cells in the MonthView
 * @internal
 */
class EventSlots extends Array {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "firstFreeSlot", 0);
  }
  set(index, event) {
    const me = this;
    if (index == null) {
      return me.add(event);
    } else {
      me[index] = event;
    }
    // Stepped on the first free slot pointer, move it on.
    if (me.firstFreeSlot === index) {
      // Move onwards while the pointer references an occupied slot
      while (me[me.firstFreeSlot]) {
        me.firstFreeSlot++;
      }
    }
  }
  add(event) {
    const result = this.firstFreeSlot;
    this[result] = event;
    // Move onwards while the pointer references an occupied slot
    while (this[this.firstFreeSlot]) {
      this.firstFreeSlot++;
    }
    return result;
  }
  setEvents(events) {
    const length = this.length = this.firstFreeSlot = events.length;
    for (let i = 0; i < length; i++) {
      this[i] = events[i];
    }
  }
}
EventSlots._$name = 'EventSlots';

/**
 * @module Calendar/util/EventSorter
 */
/**
 * This class contains methods to sort events into appropriate order within a day for display
 * in all contexts.
 *
 * Whenever a day's events are rendered, those events are sorted with {@link #function-defaultSorterFn-static} method.
 */
class EventSorter extends Base {
  /**
   * This sorting method implement following rules:
   *
   *  0. Unscheduled events go before scheduled ones
   *  1. Compare by floored start date
   *  2. If equal, compare by floored duration
   *  3. If equal, compare by start date
   *  4. If equal, compare by duration
   * @param {Scheduler.model.EventModel} event1
   * @param {Scheduler.model.EventModel} event2
   * @returns {Number}
   */
  static defaultSorterFn(event1, event2) {
    // Handle event wrapping which is what MonthView does.
    event1 = event1.eventRecord || event1;
    event2 = event2.eventRecord || event2;
    const {
        startDate: start1
      } = event1,
      {
        startDate: start2
      } = event2;
    // Unscheduled events sort to the top.
    if (!start1) {
      return -1;
    }
    if (!start2) {
      return 1;
    }
    // Sort by start timestamp first, then duration.
    // This is *in-cell* sorting.
    return start1 - start2 || event2.durationMS - event1.durationMS;
  }
  /**
   * This sorting method implement following rules:
   *
   *  0. Unscheduled events go before scheduled ones
   *  1. An {@link Scheduler.model.EventModel#property-isInterDay} event sorts before events that are not.
   *  2. Compare floored start date, if the events have different values
   *  3. Compare floored duration, if the events have different values
   *  4. Compare start date, if the events have different values
   *  5. Compare duration
   *
   * This is used by {@link Calendar.widget.MonthView} and {@link Calendar.widget.AgendaView} since these views mix
   * both interday and intraday events in the same view but render them differently.
   * @param {Scheduler.model.EventModel} event1
   * @param {Scheduler.model.EventModel} event2
   * @returns {Number}
   * @internal
   */
  static interDaySorterFn(event1, event2) {
    // Handle event wrapping which is what MonthView does.
    event1 = event1.eventRecord || event1;
    event2 = event2.eventRecord || event2;
    const {
        startDate: start1,
        isInterDay: event1InterDay
      } = event1,
      {
        startDate: start2,
        isInterDay: event2InterDay
      } = event2;
    // Unscheduled events sort to the top.
    if (!start1) {
      return -1;
    }
    if (!start2) {
      return 1;
    }
    // InterDay events sort to the top (https://github.com/bryntum/support/issues/1693).
    if (event1InterDay !== event2InterDay) {
      return Number(event2InterDay) - Number(event1InterDay);
    }
    // Sort by start timestamp first, then duration.
    // This is *in-cell* sorting.
    return start1 - start2 || event2.durationMS - event1.durationMS;
  }
}
EventSorter._$name = 'EventSorter';

/**
 * @module Calendar/mixin/SchedulerInterface
 */
const hasEventStore = w => w.isCalendarMixin && w.eventStore,
  eventNameSplitter = /(touch|mouse|pointer|key|context|dbl)(.*)/,
  eventPartReplacer = (match, prefix, remainder) => `${StringHelper.capitalize(prefix)}${StringHelper.capitalize(remainder)}`,
  capitalizeEvent = domEvent => domEvent.type.replace(eventNameSplitter, eventPartReplacer);
/**
 * Exposes an interface similar to a {@link Scheduler.view.Scheduler} so that Calendar Features which
 * extend Scheduler Features can treat their client in a standard manner.
 * @private
 * @mixin
 */
var SchedulerInterface = (Target => class SchedulerInterface extends (Target || Base) {
  static get $name() {
    return 'SchedulerInterface';
  }
  /**
   * Determines what is under the cursor of the specified event or what is described by the given element.
   * @param {Event|Element} domEvent The event or element
   * @returns {CalendarHit}
   */
  calendarHitTest(domEvent) {
    const {
        activeView
      } = this,
      target = DomHelper.getEventElement(domEvent);
    return activeView !== null && activeView !== void 0 && activeView.element.contains(target) ? activeView.calendarHitTest(domEvent) : null;
    // TODO handle type=sidebar etc?
  }
  // Hack to expose part of the Scheduler API that features and mixins inherited from Scheduler use.
  get timeAxis() {
    const me = this;
    if (!me._timeAxis) {
      me._timeAxis = {
        get startDate() {
          return me.activeView.startDate;
        },
        get endDateDate() {
          return me.activeView.endDate;
        },
        isTimeSpanInAxis(event) {
          return DateHelper.intersectSpans(event.startDate, event.endDate, this.startDate, this.endDate);
        }
      };
    }
    return this._timeAxis;
  }
  // Hack to expose part of the Scheduler API that features use.
  get timeAxisViewModel() {
    const me = this;
    if (!me._timeAxisViewModel) {
      me._timeAxisViewModel = {
        get timeResolution() {
          return me.activeView.timeResolution || {};
        }
      };
    }
    return this._timeAxisViewModel;
  }
  /**
   * Interface method required for navigation/selection.
   * Returns the event record for a DOM element.
   * @param {HTMLElement|Event} elementOrEvent The DOM node to lookup, or a DOM event whose target to lookup.
   * @returns {Scheduler.model.EventModel} The event record
   */
  resolveEventRecord(elementOrEvent) {
    var _this$constructor$fro;
    if (elementOrEvent instanceof Event) {
      elementOrEvent = elementOrEvent.target;
    }
    const activeClient = (_this$constructor$fro = this.constructor.fromElement(elementOrEvent)) === null || _this$constructor$fro === void 0 ? void 0 : _this$constructor$fro.closest(hasEventStore);
    return activeClient === null || activeClient === void 0 ? void 0 : activeClient.getEventRecord(elementOrEvent);
  }
  /**
   * Interface method required for navigation/selection
   * Assignment not supported in Calendar.
   * @private
   */
  resolveAssignmentRecord() {}
  /**
   * Interface method required for navigation/selection.
   * Returns the resource (calendar) record for a DOM element.
   * @param {HTMLElement|Event} elementOrEvent The DOM node to lookup, or a DOM event whose target to lookup.
   * @returns {Scheduler.model.ResourceModel} Any corresponding event record's resource if any.
   */
  resolveResourceRecord(elementOrEvent) {
    var _this$resolveEventRec;
    const {
      activeView
    } = this;
    // For a resource view, return the subView's configured resource.
    // If the target element is within an overflow popup, the subView is the popup's owner.
    // Otherwise, just look up the DOM parentNode axis to find an instance of the view type.
    if (activeView.isResourceView) {
      const element = elementOrEvent.nodeType === Node.ELEMENT_NODE ? elementOrEvent : elementOrEvent.target,
        sourcePopup = element.closest('.b-overflowpopup'),
        subView = sourcePopup ? bryntum.fromElement(sourcePopup, 'overflowpopup').owner : bryntum.fromElement(elementOrEvent, activeView.viewType.type);
      if (subView) {
        return subView.resource;
      }
    }
    return (_this$resolveEventRec = this.resolveEventRecord(elementOrEvent)) === null || _this$resolveEventRec === void 0 ? void 0 : _this$resolveEventRec.resource;
  }
  handleEvent(domEvent) {
    // Map event names, eg: contextmenu -> ContextMenu
    const eventName = capitalizeEvent(domEvent);
    // We are a Grid. Our superclass handleEvent distributes to onElementXxxx
    // This is called directly as part of the GridElementEvents mixin
    if (super.handleEvent) {
      super.handleEvent(domEvent);
    }
    // We are a regular CalendarMixin. We implement the interface of the Feature host as defined
    // in GridElementEvents.
    // We get here via Calendar's onViewCatchAll which directs allDomEvents through here
    // so ensure we only process each domEvent once.
    // For example, contextmenu in a Scheduler causes schedulecontextmenu
    // and cellcontextmenu both from the same initial DOM event.
    else if (!domEvent.handled && !domEvent.schedulerRedirected) {
      if (this.trigger(`beforeElement${eventName}`, {
        event: domEvent
      }) !== false) {
        var _this;
        (_this = this[`onElement${eventName}`]) === null || _this === void 0 ? void 0 : _this.call(this, domEvent);
      }
      // Sets this flag to avoid double invocation
      domEvent.schedulerRedirected = true;
    }
  }
  onInternalKeyDown(domEvent) {
    var _this$onCalendarPoint;
    (_this$onCalendarPoint = this.onCalendarPointerInteraction) === null || _this$onCalendarPoint === void 0 ? void 0 : _this$onCalendarPoint.call(this, domEvent);
  }
  getCellDataFromEvent(domEvent) {
    var _super$getCellDataFro;
    return (_super$getCellDataFro = super.getCellDataFromEvent) === null || _super$getCellDataFro === void 0 ? void 0 : _super$getCellDataFro.call(this, domEvent);
  }
  getDateFromDomEvent(domEvent) {
    var _this$constructor$fro2;
    const activeClient = (_this$constructor$fro2 = this.constructor.fromElement(domEvent)) === null || _this$constructor$fro2 === void 0 ? void 0 : _this$constructor$fro2.closest(hasEventStore);
    if (activeClient) {
      return activeClient.getDateFromDomEvent(domEvent);
    }
  }
  // Used by shared feature code.
  // Route to view's create implementation.
  createEvent() {
    this.activeView.createEvent(...arguments);
  }
  // It's fixed to be enabled for now
  get enableRecurringEvents() {
    return true;
  }
  // Used by shared feature code. Not relevant in Calendar
  getRowFor() {}
  // Used by shared feature code. Could implement if needed.
  suspendRefresh() {}
  // Used by shared feature code. Could implement if needed.
  resumeRefresh() {}
  get widgetClass() {}
});

/**
 * @module Calendar/widget/mixin/EventRenderer
 */
const emptyString = new String(''); // eslint-disable-line no-new-wrappers
/**
 * Mixin that can be used to generate DomConfig blocks for events.
 *
 * @mixin
 */
var EventRenderer = (Target => {
  var _class;
  return _class = class EventRenderer extends (Target || Base) {
    /**
     * This is the standard way to create a {@link Core.helper.DomHelper#typedef-DomConfig}
     * element definition object for creating event bars in all view types.
     *
     * This may be used by application code which needs to create DOM structure for event bars, such
     * as in custom cell renderers in an {@link Calendar.widget.AgendaView}.
     *
     * @param {Object} renderData Context for the event bar config creation.
     * @param {Scheduler.model.EventModel} renderData.eventRecord The event record to create a {@link DomConfig} block for.
     * @param {Boolean} renderData.minimal If this is set, no inner content is rendered, only
     * the wrap and body element. This is to enable rendering placeholders such as bullets
     * to represent the presence of events.
     * @param {Date} renderData.date The date to create th DOM config for.
     * @param {Date} [renderData.eventEndDate] An optional override to the event's ending date.
     * @param {Function} [eventRenderer] Optionally a function which created content HTML for the
     * event body. Defaults to any {@link #config-eventRenderer} configured into this view.
     * @returns {DomConfig} A {@link Core.helper.DomHelper#typedef-DomConfig} element definition object
     */
    createEventDomConfig(renderData, eventRenderer = this.eventRenderer) {
      var _me$isAllDayEvent, _color, _renderData$iconCls;
      const me = this,
        {
          eventHeight,
          intradayCls,
          alldayCls,
          solidBarCls,
          pastEventCls,
          showTime,
          timeFormat,
          rtl
        } = me,
        calendar = me.up('calendar'),
        {
          eventRecord,
          minimal
        } = renderData,
        eventEndDate = renderData.eventEndDate || eventRecord.endingDate,
        resourceRecord = eventRecord.isOccurrence ? eventRecord.recurringEvent.resource : eventRecord.resource,
        isRecurring = eventRecord.isRecurring || eventRecord.isOccurrence,
        isAllDay = 'isAllDay' in renderData ? renderData.isAllDay : (_me$isAllDayEvent = me.isAllDayEvent) === null || _me$isAllDayEvent === void 0 ? void 0 : _me$isAllDayEvent.call(me, eventRecord),
        eventInnerStyle = {
          height: eventHeight !== 'auto' ? DomHelper.setLength(eventHeight) : null
        },
        eventSelectedCls = calendar === null || calendar === void 0 ? void 0 : calendar.eventSelectedCls,
        dataset = renderData.dataset = {
          eventId: eventRecord.id
        };
      // Allow subclasses to create body content differently.
      // DayView will create different content layout.
      let bodyContent = me.internalBodyContentRenderer(eventRecord),
        complexContent = typeof bodyContent !== 'string',
        bodyContentType = complexContent ? 'children' : 'html',
        color = eventRecord.color || eventRecord.eventColor || (resourceRecord === null || resourceRecord === void 0 ? void 0 : resourceRecord.eventColor) || emptyString;
      // Make DomClassList copies for renderers to mutate.
      // We add our essential classes in after the renderer has run
      // then use these in the DomConfig object
      renderData.cls = eventRecord.cls.clone();
      renderData.solidBar = isAllDay || minimal;
      renderData.iconStyle = me.iconTarget === 'header' && me.showTime && !DomHelper.isNamedColor(color) ? {
        color
      } : {};
      renderData.iconCls = new DomClassList(eventRecord.iconCls); // Not a DomClassList, so not cloneable
      renderData.style = Object.assign(DomHelper.parseStyle(resourceRecord === null || resourceRecord === void 0 ? void 0 : resourceRecord.eventStyle), DomHelper.parseStyle(eventRecord.style));
      renderData.eventColor = color;
      renderData.eventHeight = eventHeight;
      renderData.cls[me.shortEventCls] = eventRecord.durationMS <= me.shortEventDuration;
      if (resourceRecord !== null && resourceRecord !== void 0 && resourceRecord.cls) {
        renderData.cls.add(resourceRecord.cls);
      }
      if (eventRenderer && !minimal) {
        // Renderer may set renderedEvent style and cls
        const rendererValue = me.callback(eventRenderer, me, [{
          eventRecord,
          resourceRecord,
          renderData
        }]);
        // Allow renderer to change the event height
        if (renderData.eventHeight !== eventHeight) {
          eventInnerStyle.height = DomHelper.setLength(renderData.eventHeight);
        }
        if (rendererValue != null) {
          // We don't know what the renderer returned. A string value
          // may yield multiple elements so switch to complex desc content mode
          // which makes the .b-cal-event-desc flexbox to lay content out.
          complexContent = true;
          bodyContent = rendererValue;
          // If the renderer returns a DomSync object, use it as the child(ren).
          if (typeof bodyContent !== 'string') {
            bodyContent = ArrayHelper.asArray(bodyContent);
            bodyContentType = 'children';
          }
        }
        // If the renderer has replaced the DomClassList with a string, promote back to a DomClassList
        if (typeof renderData.cls === 'string') {
          renderData.cls = new DomClassList(renderData.cls);
        }
        // Same goes for iconCls
        if (typeof renderData.iconCls === 'string') {
          renderData.iconCls = new DomClassList(renderData.iconCls);
        }
        // If the renderer set it to be a string, reinstate it as an object so we can add our essential styles
        if (typeof renderData.style === 'string') {
          renderData.style = DomHelper.parseStyle(renderData.style);
        }
      }
      bodyContent = [{
        className: {
          'b-cal-event-desc': 1,
          'b-cal-event-desc-complex': complexContent
        },
        [bodyContentType]: bodyContent
      }];
      // Add essential classes for eventWrap *after* the renderer has run
      Object.assign(renderData.cls, {
        'b-cal-event-wrap': 1,
        'b-iscreating': eventRecord.isCreating,
        'b-readonly': eventRecord.readOnly,
        'b-minimal': minimal,
        [alldayCls]: alldayCls && isAllDay,
        [solidBarCls]: solidBarCls && renderData.solidBar,
        [intradayCls]: intradayCls && !isAllDay,
        [pastEventCls]: pastEventCls && eventEndDate < new Date(),
        [eventSelectedCls]: eventSelectedCls && (calendar === null || calendar === void 0 ? void 0 : calendar.isEventSelected(eventRecord)),
        'b-rtl': rtl
      });
      color = renderData.eventColor;
      if ((_color = color) !== null && _color !== void 0 && _color.length) {
        // Non-CSS colors are take to be one of the predefined colors
        if (DomHelper.isNamedColor(color)) {
          renderData.cls[`b-cal-color-${color}`] = 1;
        } else {
          // Always set the color styles in case a previously set colour has been unset. In this case, we
          // set the value to an empty String object in order to avoid any falsy traps in called code.
          // The style value will always be set to ''
          if (renderData.solidBar) {
            eventInnerStyle['background-color'] = color;
          } else {
            eventInnerStyle[me.eventColourStyleProperty] = color;
          }
        }
      }
      // All day event *bars* don't have a header.
      // But DayView can now be configured to not show the allDayHeader which means allDay events
      // go into tye day schedule as normal intraday event elements which *do* have a header.
      if (showTime && !(isAllDay && this.showAllDayHeader)) {
        bodyContent.unshift({
          className: 'b-event-header',
          children: [{
            className: 'b-event-time',
            html: DateHelper.format(eventRecord.startDate, timeFormat)
          }]
        });
      }
      const
        // Presence of icon classes triggers inclusion of an icon
        hasIcon = Boolean((_renderData$iconCls = renderData.iconCls) === null || _renderData$iconCls === void 0 ? void 0 : _renderData$iconCls.length),
        useIconAsRecurrIcon = !hasIcon && isRecurring,
        showCircle = me.showCircle && !hasIcon && !isRecurring,
        iconElement = {
          tag: 'i',
          className: Object.assign({
            'b-cal-event-icon': !useIconAsRecurrIcon,
            'b-cal-recurrence-icon': useIconAsRecurrIcon,
            'b-icon': 1,
            'b-fw-icon': 1,
            'b-icon-circle': showCircle,
            'b-icon-recurring': useIconAsRecurrIcon
          }, renderData.iconCls),
          style: renderData.iconStyle
        },
        eventInnerContent = [{
          className: 'b-cal-event-body',
          children: bodyContent
        }],
        iconParent = me.iconTarget === 'header' && me.showTime ? bodyContent[0].children.length > 0 ? bodyContent[0].children : bodyContent : eventInnerContent;
      // Only insert the icon DOM if we are showing any kind of icon, either
      // from an iconCls spec, or a recurrence icon, or showing a bullet via the showCircle config.
      if (hasIcon || useIconAsRecurrIcon || showCircle) {
        if (me.iconTarget === 'header' && me.showTime) {
          iconParent.push(iconElement);
        } else {
          iconParent.unshift(iconElement);
        }
      }
      // If the event had its own icon and is recurring, the recurrence icon is extra
      if (hasIcon && isRecurring) {
        iconParent.push({
          tag: 'i',
          className: {
            'b-cal-recurrence-icon': 1,
            'b-icon': 1,
            'b-fw-icon': 1,
            'b-icon-recurring': 1
          },
          style: renderData.iconStyle
        });
      }
      return {
        // Events are tabbable unless minimally rendered (dots)
        tabIndex: minimal ? null : 0,
        dataset,
        className: renderData.cls,
        style: renderData.style,
        children: [{
          className: 'b-cal-event',
          style: eventInnerStyle,
          children: minimal ? null : eventInnerContent
        }]
      };
    }
    internalBodyContentRenderer(eventRecord) {
      var _eventRecord$assigned;
      const eventNameHtml = StringHelper.encodeHtmlBR(eventRecord.name),
        {
          showResourceAvatars
        } = this;
      // Only attempt to show avatars if there is an assignment Set.
      if (showResourceAvatars && (_eventRecord$assigned = eventRecord.assigned) !== null && _eventRecord$assigned !== void 0 && _eventRecord$assigned.size) {
        const content = [{
          class: 'b-cal-event-resource-avatars',
          children: eventRecord.resources.map(resource => this.getResourceAvatar(resource))
        }, {
          tag: 'span',
          class: 'b-cal-event-name',
          html: eventNameHtml
        }];
        return showResourceAvatars === 'last' ? content.reverse() : content;
      } else {
        return eventNameHtml;
      }
    }
  }, _defineProperty(_class, "$name", 'EventRenderer'), _defineProperty(_class, "configurable", {
    /**
     * An empty function by default, but provided so that you can override it.
     *
     * This function is called each time an event is rendered to allow developers to mutate
     * the cell metadata, or the CSS classes to be applied to the event element.
     *
     * It's called with the event record, and a eventData object which allows you to mutate event metadata
     * such as `cls`, `style`.
     *
     * The `cls` property is an object whose property names will be added to the event element if the property
     * value is truthy.
     *
     * The `style` property is an object containing style properties for the event element.
     *
     * A non-null return value from the renderer is used as the event body content. A nullish
     * return value causes the default renderer to be used which just uses the event name.
     *
     * If a string is returned, it is used as the HTML content of the event body element.
     *
     * If an object is returned, it is used as a {@link Core.helper.DomHelper#typedef-DomConfig} object to
     * create complex content in the event body element.
     *
     * ```javascript
     *  eventRenderer({ eventRecord, renderData }) {
     *      if (eventRecord.name === 'Doctors appointment') {
     *          eventData.style.fontWeight = 'bold';
     *          eventData.cls['custom-cls'] = 1;
     *
     *          return 'Special doctors appointment';
     *      }
     *  }
     * ```
     * IMPORTANT: When returning content, be sure to consider how that content should be encoded to avoid XSS
     * (Cross-Site Scripting) attacks. This is especially important when including user-controlled data such as
     * the event's `name`. The function {@link Core.helper.StringHelper#function-encodeHtml-static} as well as
     * {@link Core.helper.StringHelper#function-xss-static} can be helpful in these cases.
     *
     * For example:
     * ```javascript
     *  eventRenderer({ eventRecord }) {
     *      return StringHelper.xss`Event: ${eventRecord.name}`;
     *  }
     * ```
     * @config {Function} eventRenderer
     * @param {Object} detail An object that contains data about the event being rendered.
     * @param {Scheduler.model.EventModel} detail.eventRecord The event record
     * @param {Scheduler.model.ResourceModel} detail.resourceRecord The event record
     * @param {Object} detail.renderData A data object containing properties that will be used to create the event element.
     * @param {Object} detail.renderData.style The style property is an object containing style properties for
     * the event element.
     * @param {Object} detail.renderData.cls The cls property is an object whose property names will be added to
     * the event element if the property value is truthy.
     * @param {Object} detail.renderData.iconStyle The iconStyle property is an object containing style properties for
     * the icon element if an icon element is to be used.
     * @param {Object} detail.renderData.iconCls The iconCls property is an object whose property names will be added to
     * the icon element. Initially set from the event record's {@link Scheduler.model.EventModel#field-iconCls}.
     * Can be mutated by the renderer. If null, or no properties are set, no icon will be rendered.
     * @param {String} detail.renderData.eventColor Color to be applied to the event
     * @param {Object} detail.renderData.dataset An object which produces the `dataset` of the resulting event bar.
     * @param {Boolean} detail.renderData.solidBar This is valid for views which create event bars
     * such as the MonthView, the CalendarRow (all day events in a DayView), and OverflowPopups.
     *
     * This is set to `true` by default for all day and interday events so that these appear as a
     * solid block of background colour.
     *
     * An eventRenderer may mutate this flag to change in what manner the event bar is coloured - as
     * a solid bar of colour, or using the foreground colour (text and icons).
     */
    eventRenderer: null
  }), _class;
});

const locale = {
  localeName: 'En',
  localeDesc: 'English (US)',
  localeCode: 'en-US',
  EventEdit: {
    Calendar: 'Calendar',
    'All day': 'All day',
    day: 'Day',
    week: 'Week',
    month: 'Month',
    year: 'Year',
    decade: 'Decade'
  },
  EventMenu: {
    duplicateEvent: 'Duplicate event',
    copy: 'copy'
  },
  Calendar: {
    Today: 'Today',
    next: range => `Next ${range}`,
    previous: range => `Previous ${range}`,
    plusMore: value => `+${value} more`,
    allDay: 'All day',
    endsOn: d => `Ends ${d}`,
    weekOfYear: ([y, w]) => `Week ${w}, ${y}`,
    loadFail: 'Calendar data load failed. Please contact your system administrator'
  },
  CalendarDrag: {
    holdCtrlForRecurrence: 'Hold CTRL for a recurring event'
  },
  CalendarMixin: {
    eventCount: count => `${count || 'No'} event${count === 1 ? '' : 's'}`
  },
  EventTip: {
    'Edit event': 'Edit event',
    timeFormat: 'LST'
  },
  ModeSelector: {
    includeWeekends: 'Include weekends',
    weekends: 'Weekends'
  },
  AgendaView: {
    Agenda: 'Agenda'
  },
  MonthView: {
    Month: 'Month',
    monthUnit: 'month'
  },
  WeekView: {
    weekUnit: 'week'
  },
  YearView: {
    Year: 'Year',
    yearUnit: 'year'
  },
  EventList: {
    List: 'List',
    Start: 'Start',
    Finish: 'End'
  },
  DayView: {
    Day: 'Day',
    dayUnit: 'day',
    daysUnit: 'days',
    expandAllDayRow: 'Expand all-day section',
    collapseAllDayRow: 'Collapse all-day section',
    timeFormat: 'LST'
  },
  Sidebar: {
    'Filter events': 'Filter events'
  },
  WeekExpander: {
    expandTip: 'Click to expand row',
    collapseTip: 'Click to collapse row'
  }
};
LocaleHelper.publishLocale(locale);

/**
 * @module Calendar/widget/mixin/CalendarMixin
 */
const immediatePromise = Promise.resolve(),
  emptyObject$1 = Object.freeze({}),
  {
    eventNameMap: eventNameMap$1
  } = EventHelper,
  isFocusedCalendarMixin$1 = w => w.isCalendarMixin && w.containsFocus;
/**
 * Mixin that provides common handling methods and configs for Calendar widgets.
 *
 * This mixin also brings in the {@link Core.mixin.Featureable} mixin.
 *
 * @mixin
 */
var CalendarMixin = (Target => {
  var _class;
  return _class = class CalendarMixin extends (Target || Base).mixin(Describable, SchedulerInterface, Featureable, CalendarStores, EventRenderer, Responsive) {
    // Do not remove. Assertion strings for Localization sanity check.
    // 'L{eventCount}'

    static get configurable() {
      return {
        //region Hidden configs
        /**
         * @event eventSelectionChange
         * @hide
         */
        /**
         * @hideconfigs htmlCls, autoUpdateRecord, record, textContent, content, html
         */
        /**
         * @hideproperties  content, html
         */
        /**
         * A String which describes how much the {@link #function-next} and {@link #function-previous}
         * methods will move this view forwards or backwards in time.
         *
         * This is used to create the tooltip hints for the `nextButton` and `prevButton` in the
         * {@link Calendar.view.Calendar#property-tbar Calendar's toolbar}. If this property
         * is not defined, the `nextButton` and `prevButton` will be disabled when this view is active.
         *
         * Note that {@link Calendar.widget.WeekView} and {@link Calendar.widget.YearView} use a localized
         * string property to yield this value. Other view types implement a `get stepUnit` getter because
         * their step increments are variable.
         * @member {String} stepUnit
         * @readonly
         */
        //endregion
        localizableProperties: ['autoCreate.newName'],
        eventStore: null,
        resourceStore: null,
        /**
         * A function which compares events which some views use to decide upon rendering order.
         *
         * Default sorter function are provided from the {@link Calendar.util.EventSorter} class.
         *
         * A custom sort function may be configured.
         *
         * Note that the two objects to compare may either be {@link Scheduler.model.EventModel}s
         * or an object which contains an `eventRecord` property which is the {@link Scheduler.model.EventModel}.
         * @config {Function}
         */
        eventSorter: EventSorter.defaultSorterFn,
        responsive: {},
        // brand as responsive so b-responsive-xxx CSS classes get added
        /**
         * Configure as `true` to hide {@link #config-nonWorkingDays}
         * @config {Boolean}
         */
        hideNonWorkingDays: null,
        hideNonWorkingDaysCls: 'b-hide-nonworking-days',
        /**
         * The week start day, 0 meaning Sunday, 6 meaning Saturday.
         * Defaults to {@link Core.helper.DateHelper#property-weekStartDay-static}.
         * @config {Number}
         */
        weekStartDay: DateHelper.weekStartDay,
        /**
         * Non-working days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
         * Defaults to {@link Core.helper.DateHelper#property-nonWorkingDays-static}.
         * @config {Object}
         */
        nonWorkingDays: {
          value: DateHelper.nonWorkingDays,
          $config: {
            merge: 'replace'
          }
        },
        /**
         * The class name to add to calendar cells which are non working days.
         * @config {String}
         * @private
         */
        nonWorkingDayCls: 'b-nonworking-day',
        /**
         * The class name to add to calendar cells.
         * @member {String} dayCellCls
         */
        /**
         * The class name to add to calendar cells.
         * @config {String}
         * @private
         */
        dayCellCls: 'b-calendar-cell',
        /**
         * The class name to add to calendar cells which are weekend days.
         * @config {String}
         * @private
         */
        weekendCls: 'b-weekend',
        todayCls: 'b-today',
        pastEventCls: 'b-past-event',
        /**
         * The class name to add to events which have duration less than or equal to
         * {@link #config-shortEventDuration}.
         * @config {String}
         */
        shortEventCls: 'b-short-event',
        /**
         * The duration at which below and equal to this value, an event's encapsulating element gets
         * the {@link #config-shortEventCls} added to it so that small event bars can have style rearrangements.
         *
         * In {@link Calendar.widget.DayView}s, short events have compressed layout so that the event name is
         * visible on the top line next to the start time.
         *
         * This may be a string in the format required by {@link Core.helper.DateHelper#function-parseDuration-static}.
         *
         * It may also be configured as a millisecond value.
         * @config {String|Number}
         * @default
         */
        shortEventDuration: '30 minutes',
        /**
         * The height of event bars if this view creates event bars.
         *
         * {@link Calendar.widget.MonthView MonthView}, {@link Calendar.widget.MonthView CalendarRow}
         * (the {@link Calendar.widget.DayView#config-allDayEvents all day row} in a
         * {@link Calendar.widget.WeekView WeekView}) and {@link Calendar.widget.AgendaView AgendaView}
         * use this config.
         *
         * In {@link Calendar.widget.DayView DayView} and {@link Calendar.widget.WeekView WeekView},
         * the event element's height is part of the widget's layout and signifies the event's duration,
         * so these use a default value of `'auto'`.
         * @config {Number|String}
         * @default
         */
        eventHeight: 25,
        eventSpacing: 2,
        intradayCls: 'b-intraday',
        alldayCls: 'b-allday',
        solidBarCls: 'b-solid-bar',
        dayNameSelector: '.b-day-name',
        // MonthView widens this to be the whole cell header
        // if it's showing a separate week number column.
        // CalendarRow always widens this to the cell header.
        showTime: false,
        /**
         * A {@link Core.helper.DateHelper} format string used to format the time displayed in events
         *
         * @config {String}
         * @default
         */
        timeFormat: 'LT',
        showCircle: true,
        eventColourStyleProperty: 'color',
        // By default the event color becomes the colour
        // DayView uses backgroundColor
        handlePointerInteraction: true,
        /**
         * A {@link Core.helper.DateHelper} format string to use to create date output for
         * abbreviated view descriptions.
         * @config {String}
         * @default
         */
        shortDateFormat: 'll',
        /**
         * A {@link Core.helper.DateHelper} format string to use to create date and time output for
         * abbreviated view descriptions.
         * @config {String}
         * @default
         */
        shortDateTimeFormat: 'll LT',
        /**
         * Configure as `true` to make the view read-only, by disabling any UIs for modifying data.
         *
         * __Note that checks MUST always also be applied at the server side.__
         * @config {Boolean}
         */
        readOnly: null,
        /**
         * If this config is set, then the `gesture` configured (which defaults to `dblclick`) creates a
         * new event at the mouse or touch event's time point.
         *
         * The exact time is rounded to the closest specified `step` value.
         *
         * The duration of the created event is the specified `duration` value.
         *
         * If this is specified as `true`, the `gesture` becomes `dblclick`, and the other properties
         * are the default values listed below.
         *
         * If this is specified as a string, the string becomes the `gesture`, and the other properties
         * are the default values listed below.
         *
         * @property {String} [autoCreate.gesture='dblclick'] The event name which should trigger event creation at the event's position.
         * @property {String} [autoCreate.newName='New Event'] The name of an event created using `autoCreate` or a function to call which yields the name.
         * @property {String} [autoCreate.step='15 minutes'] The time unit by which to round the start click point of auto created events.
         * _Only for views which have a granularity of less than one day such as `WeekView` and `DayView'_.
         *
         * For views which show whole days, the start defaults to 8am.
         *
         * This is a string in the format required by {@link Core.helper.DateHelper#function-parseDuration-static}.
         * @property {String} [autoCreate.duration='1 hour'] The default duration for auto created events.
         * @property {Number} [autoCreate.startHour=8] The default start hour for auto created events
         * in views where the time granularity is one day. In a DayView or WeekView where a mouse event position
         * will translate to a time of day, this is not used.
         *
         * This is the hour of the day to start the event at. It may be fractional.
         * @config {Object|String|Boolean}
         * @default
         */
        autoCreate: {
          gesture: 'dblclick',
          newName: 'L{Object.newEvent}',
          step: '15 minutes',
          duration: '1 hour',
          startHour: 8
        },
        autoRefresh: {
          $config: {
            merge: 'classList'
          },
          value: null
        },
        /**
         * Set to false if you don't want to allow events overlapping times for any one resource (defaults to true).
         * @config {Boolean}
         * @default
         * @private
         */
        allowOverlap: true,
        /**
         * When used as a {@link Calendar.view.Calendar#config-modes mode} of a Calendar, the
         * date will automatically be kept synced with the Calendar's
         * {@link Calendar.view.Calendar#property-date}.
         *
         * Configure this as `false` to opt out of this.
         *
         * __Note that this places the onus on the application developer to control the
         * viewed date range in this widget.__
         * @config {Boolean} syncViewDate
         * @default
         */
        syncViewDate: true,
        // For views which are Panels, make them not include a tabIndex
        focusable: false,
        // Allow an AvatarRendering instance to be specified
        avatarRendering: {
          $config: 'lazy',
          value: null
        },
        /**
         * Configure as `true` to show avatars of the assigned resources (calendars) at the
         * start of the event bar.
         *
         * Configure as `'last'` to show avatars of the assigned resources (calendars) at the
         * end of the event bar.
         *
         * Note that the avatars are `2.22em` diameter circles, and this may not be suitable
         * for rendering in short events inside a DayView.
         *
         * In a view which renders event bars, the {@link #config-eventHeight} should be
         * increased from the default to accommodate the extra information.
         *
         * Note that you must set {@link #config-resourceImagePath} in order that the system
         * knows where to access the resource's image file from.
         *
         * If no image is set, or the image is not found, the resource's initials are shown instead.
         *
         * By default it is inherited from the owning Calendar:
         * ```javascript
         * new Calendar({
         *     resourceImagePath   : 'images/resources/'
         *     modes : {
         *         month : {
         *             showResourceAvatars : true,
         *         },
         *         week : {
         *             // Images go at the end of the body with name first
         *             showResourceAvatars : 'last,
         *         }
         *     }
         * });
         * ```
         * @config {Boolean|String}
         * @default false
         */
        showResourceAvatars: null,
        /**
         * Path to load resource images from. Used by the {@link #config-showResourceAvatars} config
         * to create URLs using the resource's
         * {@link Scheduler/model/ResourceModel#field-image} or
         * {@link Scheduler/model/ResourceModel#field-imageUrl} fields:
         *
         * * `image` represents image name inside the specified `resourceImagePath`,
         * * `imageUrl` represents fully qualified image URL.
         *
         * **NOTE**: The path should end with a `/`:
         *
         * ```javascript
         * new Calendar({
         *     modeDefaults : {
         *         showResourceAvatars : true,
         *         resourceImagePath   : 'images/resources/'
         *     }
         * });
         * ```
         * @config {String}
         */
        resourceImagePath: null,
        /**
         * The minimum date to which the `startDate` of this view may be navigated.
         * @member {Date} minDate
         */
        /**
         * The minimum date to which the `startDate` of this view may be navigated.
         * @config {Date|String}
         */
        minDate: null,
        /**
         * The maximum date to which the `endDate` of this view may be navigated.
         * @member {Date} maxDate
         */
        /**
         * The maximum date to which the `endDate` of this view may be navigated.
         * @config {Date|String}
         */
        maxDate: null,
        /**
         * By default, when navigating through time, the next time
         * block will be animated in from the appropriate direction.
         *
         * Configure this as `false` to disable this.
         * @prp {Boolean} animateTimeShift
         * @default
         */
        animateTimeShift: true,
        // Private at this level, it's only processed for a ResourceView
        includeTimeRanges: null,
        testConfig: {
          animateTimeShift: false
        }
      };
    }
    static get delayable() {
      return {
        refreshSoon: {
          type: 'raf',
          cancelOutstanding: true
        }
      };
    }
    static get featureable() {
      return {
        factory: CalendarFeature
      };
    }
    construct(config) {
      var _me$contentElement;
      const me = this;
      super.construct(config);
      // Not tabbable, but conducts focus.
      // We have not implemented Calendar Cell navigation which is external
      // to event-to-event navigation, so YearView does not receive focus yet.
      // Only add tabIndex if we don't already have it
      if (!me.isYearView && me.element.tabIndex !== -1 && ((_me$contentElement = me.contentElement) === null || _me$contentElement === void 0 ? void 0 : _me$contentElement.tabIndex) !== -1) {
        (me.contentElement || me.element).tabIndex = -1;
      }
      // Pull any the AvatarRendering instance through
      me.getConfig('avatarRendering');
      EventHelper.on({
        element: me.element,
        keydown: 'onCalendarKeyDown',
        thisObj: me
      });
      if (me.handlePointerInteraction) {
        EventHelper.on({
          element: me.element,
          mouseover: 'onEventMouseOverOut',
          mouseout: 'onEventMouseOverOut',
          mousedown: 'onCalendarPointerInteraction',
          mouseup: 'onCalendarPointerInteraction',
          // Block subsequent clicks before 300ms has elapsed
          click: {
            handler: 'onCalendarPointerInteraction',
            block: 300
          },
          dblclick: 'onCalendarPointerInteraction',
          contextmenu: 'onCalendarPointerInteraction',
          thisObj: me
        });
      }
    }
    /**
     * For use by the {@link Calendar.feature.TimeRanges} feature. This yields the set of
     * {@link Calendar.model.TimeRangeModel}s and {@link Scheduler.model.ResourceTimeRangeModel}s
     * to be rendered in the passed date range.
     * @param {Date} startDate The start date of the range to be returned
     * @param {Date} endDate The end date of the range to be returned.
     * @returns {Calendar.model.TimeRangeModel[]}
     * @private
     */
    getTimeRanges(startDate, endDate) {
      const {
          resourceId,
          project
        } = this,
        includeTimeRanges = resourceId ? this.owner.includeTimeRanges : true,
        ranges = resourceId == null || includeTimeRanges ? project === null || project === void 0 ? void 0 : project.getTimeRanges(startDate, endDate) : [];
      // Add in resourceTimeRanges for this view if this view is for a certain resource
      if (resourceId != null) {
        const resourceRanges = project === null || project === void 0 ? void 0 : project.getResourceTimeRanges(startDate, endDate).filter(r => r.resourceId == resourceId);
        // Default color to event color for resource
        resourceRanges.forEach(r => {
          if (!r.color) {
            r.color = this.resource.eventColor;
          }
        });
        ranges.push(...resourceRanges);
      }
      return ranges;
    }
    updateIncludeTimeRanges() {
      if (!this.isConfiguring) {
        this.refresh();
      }
    }
    onConfigChange(info) {
      var _this$autoRefresh;
      if ((_this$autoRefresh = this.autoRefresh) !== null && _this$autoRefresh !== void 0 && _this$autoRefresh[info === null || info === void 0 ? void 0 : info.name]) {
        this.refreshSoon();
      }
      super.onConfigChange(info);
    }
    changeAvatarRendering(avatarRendering) {
      return AvatarRendering.new({
        element: this.element
      }, avatarRendering);
    }
    updateShowResourceAvatars(showResourceAvatars) {
      if (showResourceAvatars) {
        // We need the AvatarRendering utility if we are showing avatars.
        this.avatarRendering || (this.avatarRendering = true);
      }
    }
    getResourceAvatar(resourceRecord) {
      return this.avatarRendering.getResourceAvatar({
        resourceRecord,
        imageUrl: resourceRecord.image === false ? null : resourceRecord.imageUrl || resourceRecord.image && this.resourceImagePath + resourceRecord.image,
        color: resourceRecord.eventColor,
        initials: resourceRecord.initials,
        dataset: {
          btip: StringHelper.encodeHtml(resourceRecord.name),
          resourceId: resourceRecord.id
        }
      });
    }
    updateEventHeight(eventHeight) {
      const {
        style
      } = this.element;
      // Force a recalculate on next access
      this._eventHeightInPixels = null;
      style.setProperty('--event-height', DomHelper.setLength(eventHeight));
      style.setProperty('--arrow-width', 'calc(var(--event-height) / 3)');
      style.setProperty('--arrow-margin', 'calc(var(--event-height) / -3)');
      // Schedule a refresh
      if (!this.isConfiguring) {
        this.refreshSoon();
      }
    }
    /**
     * Returns the pixel value of the {@link #config-eventHeight} in case it was configured as a
     * CSS measurement in other units.
     * @private
     */
    get eventHeightInPixels() {
      const me = this,
        {
          eventHeight
        } = me;
      let eventHeightInPixels = me._eventHeightInPixels;
      // Some views, like DayView don't have a defined event height.
      if (eventHeight !== 'auto') {
        if (!eventHeightInPixels) {
          eventHeightInPixels = me._eventHeight;
          // Measure the height if it's a string value.
          // Value is cached until eventHeight is changed again.
          if (typeof eventHeightInPixels === 'string') {
            eventHeightInPixels = DomHelper.measureSize(eventHeightInPixels, me.contentElement.querySelector(`.${me.eventBarContainerCls}`), false);
          }
          me._eventHeightInPixels = eventHeightInPixels;
        }
      }
      return eventHeightInPixels;
    }
    /**
     * This property yields the base selector to use to find visible cell elements in this view.
     *
     * It's based upon the {@link #property-dayCellCls}, but also takes into account the
     * {@link #config-hideNonWorkingDays} setting.
     *
     * If this is a MonthView, it also takes into account the the
     * {@link Calendar.widget.MonthView#config-hideOtherMonthCells} setting.
     * @property {String}
     * @readonly
     */
    get visibleCellSelector() {
      const excludes = [];
      if (this.hideOtherMonthCells) {
        excludes.push(`.${this.otherMonthCls}`);
      }
      if (this.hideNonWorkingDays) {
        excludes.push(`.${this.nonWorkingDayCls}`);
      }
      return `.${this.dayCellCls}${excludes.length ? `:not(${excludes.join(',')})` : ''}`;
    }
    /**
     * This property yields this widget. This is to enable Calendar Features to be able to attach
     * to standalone Calendar widgets as their owning client, and to access a currently active view
     * in a standard way.
     * @property {Calendar.widget.mixin.CalendarMixin}
     * @readonly
     * @internal
     */
    get activeView() {
      return this;
    }
    /**
     * This property yields this widget. This is to enable Calendar Features to be able to attach
     * to standalone Calendar widgets as their owning client, and to access a currently active view
     * in a standard way.
     * @property {Calendar.widget.mixin.CalendarMixin}
     * @readonly
     * @internal
     */
    get activeSubView() {
      var _items$filter;
      const {
          items
        } = this,
        // If we're a multi-CalendarWidget view (Such as a ResourceView), narrow down activeView
        // to the active subView which contains focus.
        activeSubView = (_items$filter = items.filter(isFocusedCalendarMixin$1)) === null || _items$filter === void 0 ? void 0 : _items$filter[0];
      return activeSubView || this;
    }
    /**
     * Calendar mode that this view represents (eg. "day", "month" etc). Only accessible when used within a Calendar.
     * @member {String} modeName
     * @readonly
     */
    /**
     * This function allows a Calendar widget to act as a Feature host by exposing the same interface
     * as a {@link Calendar.view.Calendar}. It executes the passed function on this widget.
     * @internal
     * @param {Function} fn The function to call.
     * @param {Object[]} [args] The arguments to pass. Defaults to this view.
     * @param {Object} [thisObj] The `this` reference for the function. Defaults to this view.
     */
    eachView(fn, args, thisObj = null) {
      this.callback(fn, thisObj || this, args || [this]);
    }
    get focusElement() {
      const {
        calendar
      } = this;
      if (calendar) {
        const {
          navigator
        } = calendar;
        return navigator.activeItem || navigator.previousActiveItem || this.element.querySelector(navigator.itemSelector) || super.focusElement;
      }
    }
    captureFocusItem(activeElement) {
      const activeEvent = this.getEventRecord(activeElement),
        base = super.captureFocusItem(activeElement);
      return (scrollIntoView = true) => {
        const newEl = activeEvent && this.getEventElement(activeEvent);
        if (newEl) {
          scrollIntoView ? newEl.focus() : DomHelper.focusWithoutScrolling(newEl);
        } else {
          base === null || base === void 0 ? void 0 : base(scrollIntoView);
        }
      };
    }
    /**
     * Refreshes the UI after a change to the EventStore, or to a configuration that requires
     * the UI to change.
     *
     * Only updates the UI if this widget is visible. If it is not visible, the refresh is
     * deferred until it next becomes visible.
     */
    refresh() {
      // If we're being called programmatically, cancel upcoming delayed refreshes.
      this.refreshSoon.cancel();
      this.month && this.element.style.setProperty('--week-length', this.month.weekLength);
      // Only refresh immediately if we are visible.
      this.whenVisible('refreshNow');
    }
    refreshNow() {
      const refocus = this.captureFocus();
      this.doRefresh();
      refocus();
    }
    get displayName() {
      return StringHelper.capitalize(this.title || this.type);
    }
    get hiddenNonWorkingDays() {
      return this.hideNonWorkingDays ? this.nonWorkingDays || this.month.nonWorkingDays : emptyObject$1;
    }
    changeAutoCreate(autoCreate) {
      const defaults = CalendarMixin.$meta.config.autoCreate;
      if (autoCreate === true) {
        return defaults;
      }
      if (typeof autoCreate === 'string') {
        autoCreate = {
          gesture: autoCreate
        };
      }
      return Config.merge(autoCreate, defaults);
    }
    updateDateSeparator() {
      this.refreshCalendarDescription();
    }
    updateDescriptionFormat() {
      this.refreshCalendarDescription();
    }
    refreshCalendarDescription() {
      const {
        calendar
      } = this;
      if (calendar !== null && calendar !== void 0 && calendar.isPainted && calendar.activeView === this) {
        calendar.updateViewDescription();
      }
    }
    changeShortEventDuration(shortEventDuration) {
      return isNaN(shortEventDuration) ? DateHelper.as('ms', shortEventDuration) : Number(shortEventDuration);
    }
    updateShortEventDuration() {
      if (!this.isConfiguring) {
        this.refresh();
      }
    }
    updateLocalization() {
      // If user configured calendar with specific config, then prefer it to the localized value
      if (!('weekStartDay' in this.initialConfig)) {
        this.weekStartDay = DateHelper.weekStartDay;
      }
      if (!('nonWorkingDays' in this.initialConfig)) {
        this.nonWorkingDays = DateHelper.nonWorkingDays;
      }
      super.updateLocalization();
      this.refreshCalendarDescription();
    }
    updateAutoCreate(autoCreate) {
      // The autocreate.newEvent property must be processed
      this.updateLocalization();
    }
    updateWeekStartDay(weekStartDay) {
      var _super$updateWeekStar;
      const {
        refreshCount,
        month
      } = this;
      (_super$updateWeekStar = super.updateWeekStartDay) === null || _super$updateWeekStar === void 0 ? void 0 : _super$updateWeekStar.call(this, weekStartDay);
      // This can be called from changeMonth during initialization of the Month object
      // and at that time, obviously the property will not be present.
      if (month) {
        month.weekStartDay = weekStartDay;
      }
      if (this.isPainted && this.refreshCount === refreshCount) {
        this.refresh();
      }
    }
    changeNonWorkingDays(nonWorkingDays) {
      const me = this,
        result = new Proxy(ObjectHelper.assign({}, nonWorkingDays), {
          set(target) {
            const result = Reflect.set(...arguments);
            me.updateNonWorkingDays(target);
            return result;
          },
          deleteProperty(target) {
            const result = Reflect.deleteProperty(...arguments);
            me.updateNonWorkingDays(target);
            return result;
          }
        });
      return result;
    }
    updateNonWorkingDays(nonWorkingDays) {
      var _super$updateNonWorki;
      const {
        refreshCount,
        month
      } = this;
      (_super$updateNonWorki = super.updateNonWorkingDays) === null || _super$updateNonWorki === void 0 ? void 0 : _super$updateNonWorki.call(this, nonWorkingDays);
      // This can be called from changeMonth during initialization of the Month object
      // and at that time, obviously the property will not be present.
      if (month) {
        month.nonWorkingDays = nonWorkingDays;
      }
      if (this.isPainted && this.refreshCount === refreshCount) {
        this.refresh();
      }
    }
    dayOfDate(date) {
      return DateHelper.clearTime(date);
    }
    ingestDate(date) {
      date = typeof date === 'string' ? DateHelper.parse(date) : new Date(date);
      if (isNaN(date)) {
        throw new Error('Calendar widget date ingestion must be passed a Date, or a YYYY-MM-DD date string');
      }
      return this.dayOfDate(date);
    }
    changeDate(date, oldDate) {
      date = this.ingestDate(date);
      // Honour minDate and maxDate
      // isValidTargetDate always needs the answer.
      if (!this.isInIsValidTargetDate && !this.isValidTargetDate(date)) {
        return;
      }
      // Don't fire the beforeDateChange event for a no-change.
      if (!oldDate || date - oldDate) {
        /**
         * Triggered before a view's orientating date changes.
         *
         * return `false` from an event handler to veto the temporal navigation.
         * @preventable
         * @event beforeChangeDate
         * @param {Date} oldDate The current orientating date of this view.
         * @param {Date} date The new date to which this view is to be orientated.
         */
        if (this.trigger('beforeDateChange', {
          date,
          oldDate
        }) !== false) {
          return date;
        }
      }
    }
    isValidTargetDate(date, end) {
      var _me$calendar, _me$calendar2;
      const me = this,
        minDate = me.minDate || ((_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.minDate),
        maxDate = me.maxDate || ((_me$calendar2 = me.calendar) === null || _me$calendar2 === void 0 ? void 0 : _me$calendar2.maxDate);
      if (!isNaN(minDate) || !isNaN(maxDate)) {
        // flag so that changers don't ask for validation.
        this.isInIsValidTargetDate = true;
        // We need to call changer here so that subclasses can snap to their range start.
        // But the base changer above must not ask for validation.
        const newDate = end ? me[`change${StringHelper.capitalize(end)}Date`](date, null) : date;
        me.isInIsValidTargetDate = false;
        // Veto navigation to before minDate.
        if (!isNaN(minDate) && newDate < minDate) {
          return false;
        }
        // Veto navigation to after maxDate.
        if (!isNaN(maxDate)) {
          return !(end === 'end' ? newDate > maxDate : newDate >= maxDate);
        }
      }
      return true;
    }
    changeStartDate(startDate) {
      // Subclass may already have vetoed the change
      if (startDate) {
        startDate = this.ingestDate(startDate);
        // Honour minDate and maxDate
        // isValidTargetDate always needs the answer.
        if (this.isInIsValidTargetDate || this.isValidTargetDate(startDate, 'start')) {
          return startDate;
        }
      }
    }
    changeEndDate(endDate) {
      // Subclass may already have vetoed the change
      if (endDate) {
        endDate = this.ingestDate(endDate);
        // Honour minDate and maxDate
        // isValidTargetDate always needs the answer.
        if (this.isInIsValidTargetDate || this.isValidTargetDate(endDate, 'end')) {
          return endDate;
        }
      }
    }
    /**
     * Brings an event or a time into view. Optionally visually highlights the target.
     *
     * __This may change the date range encompassed by this view to bring the date or event into its
     * ownership__.
     *
     * Scrolling may or may not be required, depending on the type and size constraints of the view.
     * @param {Scheduler.model.EventModel|Date} target The event or Date to scroll to.
     * @param {Object} [options] How to scroll.
     * @param {'start'|'end'|'center'|'nearest'} [options.block] How far to scroll the target.
     * @param {Number} [options.edgeOffset] edgeOffset A margin around the target to bring into view.
     * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
     * or the number of milliseconds to animate over, or an animation config object.
     * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
     * @param {String} [options.animate.easing] The name of an easing function.
     * @param {Boolean|Function} [options.highlight] Set to `true` to highlight the resulting element
     * when it is in view. May be a function which is called passing the resulting element
     * to provide customized highlighting.
     * @param {Boolean} [options.focus] Set to `true` to focus the element when it is in view.
     * @param {Boolean} [options.x] Pass as `false` to disable scrolling in the `X` axis.
     * @param {Boolean} [options.y] Pass as `false` to disable scrolling in the `Y` axis.
     * @returns {Promise} A promise which is resolved when the target has been scrolled into view.
     */
    async scrollTo(target, options = {
      animate: true
    }) {
      const me = this,
        {
          scrollable
        } = me;
      let promise = immediatePromise;
      if (me.scrollPromise) {
        await me.scrollPromise;
      }
      // Scrolling to an event. Make sure it's in our date range first
      if (target.isEvent) {
        const eventRecord = target;
        // If we do not encompass the event, move to the event's startDate.
        if (!DateHelper.intersectSpans(me.startDate, me.endDate, target.startDate, target.endDate)) {
          me.date = target.startDate;
        }
        target = me.getEventElement(target);
        if (!target) {
          me.refresh();
          target = me.getEventElement(eventRecord);
        }
      }
      // The only other option is scrolling to a Date
      else {
        target = me.changeDate(target);
        // If we do not own the date, move to that date.
        if (!DateHelper.betweenLesser(target, me.startDate, me.endDate) || !me.getDayElement(target, true)) {
          me.date = target;
        }
        target = me.getDayElement(target);
      }
      // If this view does scrolling, scroll the target into view
      if (scrollable) {
        promise = scrollable.scrollIntoView(target, options);
      }
      // Otherwise, we are responsible for any highlight
      else if (options.highlight) {
        if (typeof options.highlight === 'boolean') {
          DomHelper.highlight(Rectangle.from(target));
        } else {
          me.callback(options.highlight, me, [target, me]);
        }
      }
      return me.scrollPromise = promise;
    }
    async checkAutoCreateGesture(domEvent, date) {
      var _this$autoCreate, _this$autoCreate$gest;
      // If the gesture is on a known date, and we are visible, and not readOnly and it's an autoCreate.gesture...
      if (date && this.isVisible && !this.readOnly && domEvent.type === ((_this$autoCreate = this.autoCreate) === null || _this$autoCreate === void 0 ? void 0 : (_this$autoCreate$gest = _this$autoCreate.gesture) === null || _this$autoCreate$gest === void 0 ? void 0 : _this$autoCreate$gest.toLowerCase())) {
        return this.createEvent(date);
      }
    }
    /**
     * Creates an event on the specified date which conforms to this view's {@link #config-autoCreate}
     * setting.
     *
     * This method may be called programmatically by application code if the `autoCreate` setting
     * is `false`, in which case the default values for `autoCreate` will be used.
     *
     * If the {@link Calendar.feature.EventEdit EventEdit} feature is active, the new event
     * will be displayed in the event editor.
     * @param {Date} date The date to add the event at. If there's no time component, the
     * {@link #config-autoCreate}'s `startHour` will be used.
     */
    createEvent(date) {
      var _this$owner;
      const handler = this.calendar || ((_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.calendar) || this;
      // If contained by a Calendar the Calendar may have opinions about which view
      // to pass to doCreateEvent as the editing view.
      handler.doCreateEvent(date, this);
    }
    async doCreateEvent(date, editingView = this) {
      var _me$owner;
      const wasAutoCreate = this.autoCreate;
      // Turn it on temporarily if needed, so that we get the default, localized values
      if (!wasAutoCreate) {
        this.autoCreate = true;
      }
      const me = this,
        // We are either a mode or a CalendarRow
        calendar = me.calendar || ((_me$owner = me.owner) === null || _me$owner === void 0 ? void 0 : _me$owner.calendar),
        // Some views may be created with a chained EventStore.
        // We must use the Calendar's EventStore.
        {
          eventStore
        } = calendar,
        {
          autoCreate,
          defaultCalendar
        } = me,
        {
          modelClass
        } = eventStore,
        {
          newName
        } = autoCreate,
        dateStart = DateHelper.startOf(date, undefined, undefined, me.weekStartDay),
        startHourMS = isNaN(autoCreate.startHour) ? DateHelper.getTimeOfDay(DateHelper.parse(autoCreate.startHour, 'HH:mm:ss')) : autoCreate.startHour * 1000 * 60 * 60,
        // If this view has high definition time granularity (isa DayView), then round the precise date
        // passed to this view's autoCreate.step.
        // Otherwise default to an event starting at autoCreate.startHour.
        startDate = me.isDayView ? DateHelper.round(date, autoCreate.step) : DateHelper.add(dateStart, startHourMS),
        duration = DateHelper.parseDuration(autoCreate.duration),
        durationMs = DateHelper.as('ms', duration),
        endDate = DateHelper.add(startDate, durationMs),
        name = me.resolveCallback(newName, me, false) ? me.callback(newName, me, [me, startDate]) : newName,
        recordData = {
          [modelClass.getFieldDataSource('name')]: name,
          [modelClass.getFieldDataSource('startDate')]: startDate,
          [modelClass.getFieldDataSource('endDate')]: endDate,
          [modelClass.getFieldDataSource('duration')]: duration.magnitude,
          [modelClass.getFieldDataSource('durationUnit')]: duration.unit,
          // If the view's settings resulted in a midnight to midnight event, flag it as allDay
          allDay: DateHelper.diff(startDate, endDate, 'day') === 1
        };
      const newRecord = eventStore.createRecord(recordData);
      // If an editor is available, mark the event as non-persistable while it is being edited
      if (calendar !== null && calendar !== void 0 && calendar.features.eventEdit && !calendar.features.eventEdit.disabled) {
        newRecord.isCreating = true;
      }
      if (defaultCalendar) {
        eventStore.assignmentStore.assignEventToResource(newRecord, defaultCalendar);
      }
      await eventStore.addAsync(newRecord);
      editingView.editAutoCreatedEvent(newRecord);
      // Turn back off if it was not set.
      if (!wasAutoCreate) {
        me.autoCreate = false;
      }
    }
    editAutoCreatedEvent(eventRecord) {
      /**
       * Fired when an {@link #config-autoCreate} gesture has created a new event
       * and added it to the event store.
       *
       * If the {@link Calendar.feature.EventEdit} feature is present, it listens for
       * this event and initiates an edit operation. Adding a high `prio` listener which
       * returns `false` can prevent this event from reaching the `eventEdit` processing.
       * @event eventAutoCreated
       * @param {Calendar.widget.mixin.CalendarMixin} source This Calendar view instance.
       * @param {Scheduler.model.EventModel} eventRecord The new event record.
       */
      this.trigger('eventAutoCreated', {
        eventRecord
      });
    }
    get duration() {
      // All views have a startDate and endDate property, so duration can be calculated.
      // The endDate is "exclusive" because it means 00:00:00 of that day.
      return this.endDate ? this.calculateDuration(this.startDate, this.endDate) : 1;
    }
    calculateDuration(startDate, endDate) {
      // This is overridden in WeekView to enforce the correct duration.
      // This enables updaters to "calculate" the duration and therefore share code.
      return DateHelper.diff(startDate, endDate, 'day');
    }
    /**
     * Moves this view forwards in time by its configured (or intrinsic if it's a
     * {@link Calendar.widget.WeekView} or a {@link Calendar.widget.YearView}) duration.
     */
    next() {
      this.date = DateHelper.add(this.date, this.duration, 'day');
    }
    /**
     * Moves this view backwards in time by its configured (or intrinsic if it's a
     * {@link Calendar.widget.WeekView} or a {@link Calendar.widget.YearView}) duration.
     */
    previous() {
      this.date = DateHelper.add(this.date, -this.duration, 'day');
    }
    get eventContentElement() {
      return this.contentElement;
    }
    /**
     * The first *visible* event-bearing element in this view. So if the first day defined in the
     * range is a Sunday, and {@link #config-hideNonWorkingDays} is set, then the first visible
     * cell will be for the Monday.
     * @property {HTMLElement}
     */
    get firstVisibleCell() {
      return this.eventContentElement.querySelector(this.visibleCellSelector);
    }
    /**
     * The last *visible* event-bearing element in this view. So if the last day defined in the
     * range is a Sunday, and {@link #config-hideNonWorkingDays} is set, then the last visible
     * cell will be for the Friday.
     * @property {HTMLElement}
     */
    get lastVisibleCell() {
      const visibleCells = this.contentElement.querySelectorAll(this.visibleCellSelector);
      return visibleCells[visibleCells.length - 1];
    }
    /**
     * The date of the first *visible* event-bearing element in this view. So if the first day defined
     * in the range is a Sunday, and {@link #config-hideNonWorkingDays} is set, then the first visible
     * date will be the date of the Monday.
     * @property {Date}
     */
    get firstVisibleDate() {
      const date = new Date(this.startDate),
        // Extracting the month index from our instance of the Month helper class
        {
          month
        } = this.month;
      while (this.hideOtherMonthCells && date.getMonth() !== month || this.hiddenNonWorkingDays[date.getDay()]) {
        date.setDate(date.getDate() + 1);
      }
      return date;
    }
    /**
     * The date of the last *visible* event-bearing element in this view. So if the last day defined
     * in the range is a Sunday, and {@link #config-hideNonWorkingDays} is set, then the last visible
     * date will be the date of the Friday.
     * @property {Date}
     */
    get lastVisibleDate() {
      const date = DateHelper.add(this.endDate, -1, 'd'),
        // Extracting the month index from our instance of the Month helper class
        {
          month
        } = this.month;
      while (this.hideOtherMonthCells && date.getMonth() !== month || this.hiddenNonWorkingDays[date.getDay()]) {
        date.setDate(date.getDate() - 1);
      }
      return date;
    }
    updateHideNonWorkingDays(hideNonWorkingDays) {
      var _me$contentElement2, _super$updateHideNonW;
      const me = this,
        {
          month,
          calendar
        } = me;
      (_me$contentElement2 = me.contentElement) === null || _me$contentElement2 === void 0 ? void 0 : _me$contentElement2.classList[hideNonWorkingDays ? 'add' : 'remove'](me.hideNonWorkingDaysCls);
      // Bail out for view types not supporting this (ResourceView)
      if (month == null) {
        return;
      }
      let activeColumnIndex, date, activeDay;
      // Our active date is going to be hidden
      if (!me.isConfiguring && hideNonWorkingDays) {
        var _date;
        date = me.date;
        activeDay = (_date = date) === null || _date === void 0 ? void 0 : _date.getDay();
        if (date && me.nonWorkingDays[activeDay] && me.getDayElement(date)) {
          activeColumnIndex = month.visibleDayColumnIndex[activeDay];
        }
      }
      month.hideNonWorkingDays = hideNonWorkingDays;
      (_super$updateHideNonW = super.updateHideNonWorkingDays) === null || _super$updateHideNonW === void 0 ? void 0 : _super$updateHideNonW.call(this, hideNonWorkingDays);
      // Active date has been hidden by hiding nonworking days, we must move it.
      if (typeof activeColumnIndex === 'number') {
        const weekStart = month.getWeekStart(month.getWeekNumber(date)),
          newActiveColumnIndex = Math.min(activeColumnIndex, month.visibleColumnCount - 1);
        // Find the date for the new visible column index
        for (let i = -1;; weekStart.setDate(weekStart.getDate() + 1)) {
          // Entry may be zero, cannot use truthiness test
          if (typeof month.visibleDayColumnIndex[weekStart.getDay()] === 'number') {
            if (++i === newActiveColumnIndex) {
              break;
            }
          }
        }
        me.date = weekStart;
        // Owning active date should change
        calendar && (calendar.date = date);
      }
    }
    onCalendarStoreChange({
      source,
      action
    }) {
      const me = this;
      // Draw on project refresh instead of on dataset.
      // Unless it's a chained store; they change dataset upon master store change
      if (action === 'dataset' && !source.isChained) {
        return;
      }
      // Only refresh once initial commit is performed and change is not cause by project writing back data
      if (me.project.isInitialCommitPerformed && !me.project.isWritingData) {
        var _me$_cellMap;
        // CellMap must be rebuilt when data changes
        (_me$_cellMap = me._cellMap) === null || _me$_cellMap === void 0 ? void 0 : _me$_cellMap.clear();
        me.refreshSoon();
      }
    }
    /**
     * Schedules a refresh of the UI for the next animation frame. This is a useful method to call when
     * making multiple data changes, so that each change merely *schedules* a refresh for the next AF and
     * DOM churn is kept to a minimum.
     *
     * Calling {@link #function-refresh} directly cancels any scheduled refresh operation and updates
     * the UI immediately
     */
    refreshSoon() {
      this.refresh();
    }
    /**
     * Called when new event is created.
     * an be overridden to supply default record values etc.
     * @param {Scheduler.model.EventModel} eventRecord Newly created event
     */
    onEventCreated(eventRecord) {
      // template method
    }
    /**
     * Returns the event record for a DOM element or DOM event.
     * @param {HTMLElement|Event} elementOrEvent The DOM node to lookup, or a DOM event whose target to lookup.
     * @returns {Scheduler.model.EventModel} The event record
     */
    getEventRecord(elementOrEvent) {
      var _element;
      let element = elementOrEvent instanceof Event ? elementOrEvent.target : elementOrEvent;
      element = ((_element = element) === null || _element === void 0 ? void 0 : _element.closest('[data-event-id]')) || null;
      return element && this.eventStore.getById(element.dataset.eventId);
    }
    /**
     * Returns the event record for a DOM element or DOM event.
     * @param {HTMLElement|Event} elementOrEvent The DOM node to lookup, or a DOM event whose target to lookup.
     * @returns {Scheduler.model.EventModel} The event record
     */
    resolveEventRecord(elementOrEvent) {
      // this method is added for symmetry w/SchedulerInterface
      return this.getEventRecord(elementOrEvent);
    }
    getDateFromElement(element) {
      // Month headers also yield the start date for that month
      let dateElement = element === null || element === void 0 ? void 0 : element.closest('[data-date],[data-header-date],[data-month-date]');
      // Clicked on an element with a data-date or data-header-date, or data-month-date value.
      if (dateElement) {
        return this.dayTime.parseKey(dateElement.dataset.date || dateElement.dataset.headerDate || dateElement.dataset.monthDate);
      }
      dateElement = element === null || element === void 0 ? void 0 : element.closest('[data-week]');
      // Clicked on an element with a data-week value, that should yield the week start date.
      if (dateElement) {
        var _this$month;
        return (_this$month = this.month) === null || _this$month === void 0 ? void 0 : _this$month.getWeekStart(dateElement.dataset.week.split(',').map(Number));
      }
    }
    getDateFromDomEvent(domEvent) {
      return this.getDateFromElement(DomHelper.getEventElement(domEvent));
    }
    getDateFromPosition() {
      return null;
    }
    dateKey(date) {
      return DateHelper.makeKey(date);
    }
    /**
     * Returns the cell associated with the passed date.
     *
     * In certain views, the strict definition if whether the view owns the date may be optionally enforced.
     *
     * For example, in a YearView or MonthView, dates outside the configured year or month may be displayed.
     *
     * To exclude these, pass the `strict` parameter as `true`
     * @param {Date|String} date The date to find the element for or a key in the format `YYYY-MM-DD`
     * @param {Boolean} strict Only return the element if this view *owns* the date. (MonthView and YearView)
     */
    getDayElement(date, strict) {
      if (typeof date !== 'string') {
        date = this.dateKey(date);
      }
      return this.eventContentElement.querySelector(`[data-date="${date}"]`);
    }
    /**
     * Returns the outermost element which represents the first block of the passed event in the view. *If the
     * event is represented within the view*.
     *
     * *Note* if the event covers multiple weeks, this will only return the first element.
     *
     * To return all elements use {@link #function-getEventElements}.
     *
     * To return an event element at a particular date, pass the date as the second parameter.
     * @param {Scheduler.model.EventModel|String|Number} eventRecord The event, or event ID to find the element for.
     * @param {Date} [date] Optionally, the event element at the specified date.
     * @returns {HTMLElement} The first element which corresponds to the event. Note that *some* views,
     * such as {@link Calendar.widget.MonthView MonthView} and {@link Calendar.widget.CalendarRow CalendarRow}
     * may render multiple elements for long events.
     */
    getEventElement(eventRecord, date = Math.max(eventRecord.startDate, this.firstVisibleDate || this.startDate)) {
      var _me$calendar3;
      const me = this,
        activeEventElement = (_me$calendar3 = me.calendar) === null || _me$calendar3 === void 0 ? void 0 : _me$calendar3.navigator.activeItem,
        activeDate = me.getDateFromElement(activeEventElement),
        eventId = me.eventStore.modelClass.asId(eventRecord);
      // If the navigated to event is still in the document and is the event being asked for,
      // and on the active date, then use that element.
      // Some views have multiple elements representing one event.
      if (document.contains(activeEventElement) && (activeEventElement === null || activeEventElement === void 0 ? void 0 : activeEventElement.dataset.eventId) === String(eventId) && activeDate && !(date - activeDate)) {
        return activeEventElement;
      }
      if (date) {
        const dayCell = me.getDayElement(date);
        if (dayCell) {
          // In EventList, the day cell is the event el.
          // In all other views the day cell *contains* the event el.
          return DomHelper.down(dayCell, `[data-event-id="${eventId}"]`);
        }
      }
      return me.getEventElements(eventRecord)[0];
    }
    /**
     * Returns all outermost elements which represents the passed event in the view. *If the
     * event is represented within the view*
     * @param {Scheduler.model.EventModel|String|Number} eventRecord The event, or event ID to find the elements for.
     * @returns {HTMLElement[]} The elements which corresponds to the event. Note that *some* views,
     * such as {@link Calendar.widget.MonthView MonthView} and {@link Calendar.widget.CalendarRow CalendarRow}
     * may render multiple elements for long events.
     */
    getEventElements(eventRecord) {
      const eventId = this.eventStore.modelClass.asId(eventRecord);
      return this.eventContentElement.querySelectorAll(`[data-event-id="${eventId}"]`);
    }
    onEventMouseOverOut(domEvent) {
      const me = this,
        {
          currentOverEventEl
        } = me,
        isOut = domEvent.type === 'mouseout',
        toElement = domEvent[isOut ? 'relatedTarget' : 'target'],
        toEventEl = (toElement === null || toElement === void 0 ? void 0 : toElement.closest('.b-cal-event-wrap')) || null,
        isChange = toEventEl !== (currentOverEventEl || null);
      if (isChange) {
        if (isOut) {
          me.currentOverEventEl = null;
          if (currentOverEventEl) {
            Object.defineProperty(domEvent, 'target', {
              configurable: true,
              get: () => currentOverEventEl
            });
          }
          return me.onCalendarPointerInteraction(domEvent);
        } else {
          me.currentOverEventEl = toEventEl;
          return me.onCalendarPointerInteraction(domEvent);
        }
      }
    }
    /**
     * Determines what is under the cursor of the specified event or what is described by the given element.
     * @param {Event|Element} domEvent The event or element
     * @returns {CalendarHit}
     */
    calendarHitTest(domEvent) {
      const me = this,
        {
          monthSelector
        } = me,
        date = me.getDateFromDomEvent(domEvent),
        target = DomHelper.getEventElement(domEvent);
      let ret = null,
        closest;
      if (closest /* assignment */ = target.closest('.b-cal-event-wrap')) {
        ret = {
          type: 'event',
          eventElement: closest,
          eventRecord: me.eventStore.getById(closest.dataset.eventId)
        };
      }
      // If we are showing week number in its own column, then the whole cell header represents the day.
      // Otherwise just the .b-day-name represents it.
      else if (closest /* assignment */ = target.closest(me.dayNameSelector)) {
        ret = {
          type: 'dayNumber',
          dayNumberElement: closest
        };
      } else if (closest /* assignment */ = target.closest('.b-week-num,.b-week-number-cell')) {
        const weekElement = target.closest('.b-calendar-week');
        // Week number cell in the day name row has no week.
        if (weekElement && weekElement.dataset.week) {
          ret = {
            type: 'weekNumber',
            week: weekElement.dataset.week.split(',').map(Number),
            weekNumberElement: closest,
            weekElement
          };
        }
      } else if (monthSelector && target.closest(monthSelector)) {
        ret = {
          type: 'monthName',
          month: date.getMonth(),
          date
        };
      }
      if (!ret) {
        if (closest /* assignment */ = target.closest('.b-cal-cell-overflow')) {
          ret = {
            type: 'cellOverflow',
            cellOverflowElement: closest
          };
        } else if (date) {
          ret = {
            type: 'schedule'
          };
        }
      }
      if (ret) {
        ret.cell = target.closest('.b-calendar-cell');
        ret.date = date;
        ret.view = me;
      }
      return ret;
    }
    onCalendarPointerInteraction(domEvent) {
      const me = this,
        {
          monthSelector
        } = me,
        {
          target
        } = domEvent,
        fromOverflowPopup = Boolean(target.closest('.b-overflowpopup')),
        domEventName = eventNameMap$1[domEvent.type],
        date = me.getDateFromDomEvent(domEvent),
        eventWrap = target.closest('.b-cal-event-wrap'),
        eventRecord = eventWrap ? me.eventStore.getById(eventWrap.dataset.eventId) : me.getEventRecord(target),
        eventElement = eventWrap || eventRecord && me.getEventElement(eventRecord, date),
        resourceElement = target.closest('[data-resource-id]'),
        resourceRecord = resourceElement && me.resourceStore.getById(resourceElement.dataset.resourceId);
      let result;
      // Mouse interaction was on a resource.
      // These can be outside of the eventContentElement.
      // Resource is a property of an event, so it triggers first.
      if (resourceRecord) {
        result = me.trigger(`resource${domEventName}`, {
          domEvent,
          date,
          eventElement,
          eventRecord,
          resourceRecord,
          fromOverflowPopup
        });
      }
      // All other interaction must be in content element or our overflow popup.
      if (!fromOverflowPopup && !me.eventContentElement.contains(target)) {
        return;
      }
      // Mouse interaction was on an event
      if (result !== false && eventRecord) {
        const eventResult = me.trigger(`event${domEventName}`, {
          domEvent,
          date,
          eventElement,
          eventRecord,
          resourceRecord,
          fromOverflowPopup
        });
        if (eventResult) {
          result = eventResult;
        }
      }
      // Interacted with a fundamental data item. No further interaction.
      if (eventRecord || resourceRecord) {
        return result;
      }
      // If we are showing week number in its own column, then the whole cell header represents the day.
      // Otherwise just the .b-day-name represents it.
      if (target.closest(me.dayNameSelector)) {
        result = me.trigger(`dayNumber${domEventName}`, {
          domEvent,
          date,
          cellData: me.cellMap.get(date) || me.createCellData(date),
          fromOverflowPopup
        });
        if (result === false) {
          return result;
        }
      }
      // Interaction was with a week number
      if (target.closest('.b-week-num,.b-week-number-cell')) {
        const weekElement = domEvent.target.closest('[data-week]');
        // If we find an element we can ask the week.
        if (weekElement) {
          return me.trigger(`weekNumber${domEventName}`, {
            domEvent,
            week: weekElement.dataset.week.split(',').map(Number),
            date: me.getDateFromElement(weekElement.querySelector('.b-calendar-cell')),
            fromOverflowPopup
          });
        }
      }
      // Interaction was with a month in the YearView.
      if (monthSelector && target.closest(monthSelector)) {
        return me.trigger(`monthName${domEventName}`, {
          domEvent,
          month: date.getMonth(),
          date,
          fromOverflowPopup
        });
      }
      // Interacting with a cell overflow indicator
      if (target.closest('.b-cal-cell-overflow')) {
        if (me.trigger(`cellOverflow${domEventName}`, {
          domEvent,
          date,
          fromOverflowPopup
        }) !== false) {
          return;
        }
      }
      // It's only a schedule{event} if the event is in a day cell.
      // Pure Grid views like ListView don't have a schedule area - it's all events.
      if (date && me.dayCellCls && domEvent.target.closest(`.${me.dayCellCls}`)) {
        result = me.trigger(`schedule${domEventName}`, {
          domEvent,
          date,
          fromOverflowPopup
        });
        if (result === false) {
          return result;
        }
      }
      // Finally check if the gesture matches the autoCreate gesture
      me.checkAutoCreateGesture(domEvent, date);
      return result;
    }
    onCalendarKeyDown(keyEvent) {
      var _this$calendar;
      if (keyEvent.ctrlKey && keyEvent.key.toLowerCase() === 'z' && (_this$calendar = this.calendar) !== null && _this$calendar !== void 0 && _this$calendar.enableUndoRedoKeys) {
        var _this$project, _this$project$stm;
        (_this$project = this.project) === null || _this$project === void 0 ? void 0 : (_this$project$stm = _this$project.stm) === null || _this$project$stm === void 0 ? void 0 : _this$project$stm.onUndoKeyPress(keyEvent);
      } else {
        this.onCalendarPointerInteraction(keyEvent);
      }
    }
    isAllDayEvent(eventRecord) {
      return eventRecord.allDay || (eventRecord.isScheduled && this.dayTime ? this.dayTime.isInterDay(eventRecord) : eventRecord.isInterDay);
    }
    /**
     * Sort the given array of `events` in the desired order for this view.
     * @param {Scheduler.model.EventModel[]} events
     * @internal
     */
    sortEvents(events) {
      events.sort(this.eventSorter);
    }
    //region Extract configs
    // These functions are not meant to be called by any code other than Base#getCurrentConfig().
    // This excludes project and calendar from being serialized,
    // they are always assigned on creation not actually configurable
    preProcessCurrentConfigs(configs) {
      super.preProcessCurrentConfigs(configs);
      delete configs.calendar;
      delete configs.project;
    }
    // Extracts the current configs for the calendar view, with special handling to exclude project
    getCurrentConfig(options) {
      const result = super.getCurrentConfig(options);
      delete result.project;
      return result;
    }
    //endregion
  }, _defineProperty(_class, "$name", 'CalendarMixin'), _class;
});

/**
 * @module Calendar/widget/mixin/DayCellCollecter
 */
const byKey = ({
    key: lhs
  }, {
    key: rhs
  }) => {
    return lhs < rhs ? -1 : rhs < lhs ? 1 : 0;
  },
  extractEndDate = e => e.endDate || DateHelper.add(e.startDate, e.duration, e.durationUnit);
/**
 * A data block created by all {@link Calendar.widget.mixin.DayCellCollecter} Calendar views to
 * encapsulate occupied day cells and the events which intersect with each date to be shown in the UI.
 * All useful data about the date and the shape of the UI is included.
 * @typedef {Object} DayCell
 * @property {Date} date The date of the cell.
 * @property {String} key a `YYYY-MM-DD` formatted date key for the cell.
 * @property {Number} cellIndex The overall cell index in the cell-based UI being created.
 * @property {Number} day The day of week for the cell: 0=Sunday, 6=Saturday
 * @property {Number} columnIndex The column index in the cell-based UI being created.
 * @property {Number} visibleColumnIndex The visible column index (eg 0 for a Monday if Sunday is the week start day, but was hidden)
 * @property {Boolean} isNonWorking `true` if the owning view considers the date a non-working day.
 * @property {Number[]} week The `[year, week]` encapsulating the cell.
 * @property {Boolean} isOtherMonth The cell is outside the view's primary time range. Only significant
 * when used by a CalendarPanel which encapsulates a single month.
 * @property {Boolean} visible `true` if the date cell is not for a hidden day.
 * @property {Date} tomorrow The date of the following cell.
 * @property {Boolean} isRowStart `true` if the cell is at the start of a visible row.
 * @property {Boolean} isRowEnd `true` if the cell is at the end of a visible row.
 * @property {Boolean} hasOverflow `true` if the `renderedEvents` overflow the cell height and
 * require a `+n more` button.
 * @property {Scheduler.model.EventModel[]} events The events which are to be shown for this date.
 * @property {EventBar[]} renderedEvents If this view renders event bars ({@link Calendar.widget.MonthView},
 * {@Link Calendar.widget.CalendarRow}, {@link Calendar.widget.AgendaView}), then this is an array of
 * {@link EventBar event bar} definitions which belong in the cell. Whether all can be rendered depends
 * upon the view's configured {@link Calendar.widget.mixin.CalendarMixin#config-eventHeight} and whether
 * the cell is of fixed height. The `hasOverflow` property is set if the the rendered events overflow
 * a cell's fixed capacity.
 */
/**
 * A data block which describes how an event bar is to be rendered into a day cell.
 * @typedef {Object} EventBar
 * @property {Scheduler.model.EventModel} eventRecord The event record for which the event bar is being rendered.
 * @property {Date} propagateEndDate The date of the last cell into which the event bar will extend.
 * @property {Core.helper.util.DomClassList} cls The CSS classes to apply to the event bar.
 * @property {Core.helper.util.DomClassList} iconCls The CSS classes to apply to an event icon.
 * @property {Object} dataset Property names and values to be applied to the Event bar's DOM `dataset`
 * @property {String} eventColor Either a predefined colour name, or a DOM colour value to apply to the event bar.
 * @property {Boolean} isAllDay `true` if the event is flagged as an all day event in its data, or
 * if it spans a day boundary and occupies more than one cell.
 * @property {Boolean} isOverflow `true` if this event bar is a continuation from a previous cell.
 * @property {Boolean} overflows `true` if this event bar flows into the next cell.
 * @property {Boolean} solidBar `true` if the event bar is to be rendered with a solid background of
 * its defined colour. All day events are solid by default.
 */
/**
 * Mixin that provides the ability to collect {@link DayCell day cell} data containing the events
 * of interest to a Calendar widget.
 *
 * This is used by all implemented Calendar widgets Except {@link Calendar.widget.AgendaView}
 * which creates its cellMap from the events it finds in the eventStore.
 *
 * @mixin
 */
var DayCellCollecter = (Target => class DayCellCollecter extends (Target || Base) {
  static get $name() {
    return 'DayCellCollecter';
  }
  static get configurable() {
    return {
      /**
       * A function to filter which events are collected into the day cell data blocks.
       * Return `true` to include the passed event, or a *falsy* value to exclude the event.
       * @config {Function}
       */
      eventFilter: null
    };
  }
  get dayTime() {
    return DayTime.MIDNIGHT;
  }
  get cellMonth() {
    return this._cellMonth || (this._cellMonth = new Month({}));
  }
  createCellMap(getEventsOptions = {}) {
    const me = this,
      {
        filter,
        skipPropagate
      } = getEventsOptions,
      {
        eventFilter,
        cellMonth,
        lastVisibleDate
      } = me,
      cellMap = getEventsOptions.cellMap || me._cellMap || (me._cellMap = new CellMap());
    // For data purposes, last visible Date is 00:00 on the following day
    if (lastVisibleDate) {
      lastVisibleDate.setDate(lastVisibleDate.getDate() + 1);
    }
    let startDate = getEventsOptions.startDate || me.firstVisibleDate || me.startDate,
      endDate = getEventsOptions.endDate || lastVisibleDate || me.endDate;
    // We need a separate Month object to iterate through the cells to create cell context objects
    cellMonth.configure({
      weekBase: null,
      weekStartDay: me.weekStartDay,
      nonWorkingDays: me.nonWorkingDays,
      hideNonWorkingDays: me.hideNonWorkingDays,
      sixWeeks: me.sixWeeks,
      date: startDate
    });
    if (me.eventStore) {
      // Create  mutable copy so that collectEvents implementations may intervene
      getEventsOptions = ObjectHelper.assign({
        dayTime: DayTime.MIDNIGHT
      }, getEventsOptions, {
        filter: filter && eventFilter ? e => filter(e) && eventFilter(e) : filter || eventFilter,
        dateMap: cellMap,
        startDate,
        endDate
      });
      me.collectEvents(getEventsOptions);
      // collectEvents may manipulate the exact view start and end.
      // For example MonthView.hideOtherMonthCells
      startDate = getEventsOptions.startDate;
      endDate = getEventsOptions.endDate;
      // Create a cell entry for every date which this view encapsulates which intersects
      // with an event.
      // To be completely clear: depending upon the requirements of the widget that
      // mixes there will likely be some cell entries created
      // here which may never have any events *STARTING* in them.
      // But they may exist because they have events from previous days
      // flowing into them.
      // These must exist because they still need to propagate their overflowing
      // events forward into visible cells.
      // All cells which require visible event bars will be represented here.
      // Multi day events will be propagated forward into their following cells
      // further down.
      for (const [key, events] of cellMap) {
        let lastEventEndDate = 0;
        me.sortEvents(events);
        const dayTime = getEventsOptions.dayTime,
          date = dayTime.dayOfDate(DateHelper.parseKey(key)),
          cellData = me.createCellData(date);
        if (getEventsOptions.rawEvents) {
          lastEventEndDate = Math.min(endDate, Math.max.apply(Math, events.map(extractEndDate)));
          cellData.events = events;
        } else {
          cellData.events = events.map(eventRecord => {
            const eventEndDate = eventRecord.endingDate,
              overflows = eventEndDate > cellData.tomorrow,
              eventData = {
                isAllDay: me.isAllDayEvent(eventRecord),
                isOverflow: eventRecord.startDate < cellData.date && date - startDate,
                eventRecord,
                eventEndDate,
                overflows,
                date
              };
            if (!skipPropagate) {
              lastEventEndDate = Math.min(endDate, Math.max(lastEventEndDate, eventEndDate));
              if (overflows) {
                eventData.propagateEndDate = me.calculatePropagateEndDate(eventData, endDate);
              }
            }
            return eventData;
          });
        }
        // Create the cells to propagate into based on the latest ending of the events just found.
        // Cells after the first cell are collected on a startDate only basis, so the cells they
        // will extend into will need to be created.
        if (!skipPropagate) {
          for (; date < lastEventEndDate; date.setDate(date.getDate() + 1)) {
            const key = dayTime.dateKey(date);
            cellMap.has(key) || cellMap.set(key, []);
          }
        }
        // Change the raw event array to a cellData object
        cellMap.set(key, cellData);
      }
      // Pre-fill slots for all days that the events for this day cover
      if (cellMap.size) {
        // Sort the day entries into ascending date order.
        // The creation of the cells to propagate into may create some out of order
        const cellMapEntries = [...cellMap.values()].sort(byKey);
        let previousEvents;
        // Replace entries in order while linking them up to form a linked list.
        cellMap.clear();
        cellMapEntries.forEach(entry => {
          cellMap.set(entry.key, entry);
          if (previousEvents) {
            previousEvents.nextEvents = entry;
            entry.previousEvents = previousEvents;
          }
          previousEvents = entry;
        });
        // Pre-fill slots for all days that the events for this day cover
        if (!skipPropagate) {
          me.propagateCellEvents(cellMapEntries[0], cellMap);
        }
      }
    }
    // The getter kicks off a new create for cellMaps which are not populated.
    // A cellMap with zero size may still have been populated.
    cellMap.populated = true;
    return cellMap;
  }
  /**
   * Calculates the end date (EXCLUSIVE) to which an event must be propagated based upon the
   * event's data in order to create a day-spanning event bar.
   *
   * If an event overflows into 2011-01-02T01:00, then the exclusive propagateEndDate
   * is 2011-01-03T00:00:00 so the event will be propagated into 2011-01-02.
   *
   * But if an event ends on 2011-01-02T00:00:00, its propagateEndDate will be 2011-01-02T00:00:00
   * so it will be propagated as far as 2011-01-01
   *
   * This may be overridden in subclasses to customize how events are propagated forwards.
   *
   * example:
   * ```javascript
   * class OvernightEventMonthView extends MonthView {
   *     static get name() {
   *         return 'OvernightEventMonthView';
   *     }
   *
   *     static get type() {
   *         return 'overnighteventmonthview';
   *     }
   *
   *     calculatePropagateEndDate(eventData) {
   *         // If the event only spills into the next day but not further
   *         // then we do not want an extended event bar.
   *         // It will still get an arrow indicating that it continues rightwards.
   *         if (eventData.eventEndDate < DateHelper.add(eventData.date, 1, 'd')) {
   *             return DateHelper.add(DateHelper.clearTime(eventData.eventRecord.startDate), 1, 'd');
   *         }
   *         // Default case, propagate event into the future as usual
   *         return super.calculatePropagateEndDate(eventData);
   *     }
   * }
   * // Register the type name
   * OvernightEventMonthView.initClass();
   *
   * new Calendar({
   *     modes : {
   *         // Use our MonthView subclass as the month mode.
   *         month : {
   *             type :'overnighteventmonthview'
   *         }
   *     }
   * })
   * ```
   *
   * Note that this is implemented by both {@link Calendar.widget.MonthView} and {Calendar.widget.CalendarRow}
   * which is the "all day" row in a week or day view.
   *
   * @param {Object} eventData A data block describing the time context of an event.
   * @param {Date} eventData.eventEndDate The end date for which to calculate the propagate end date.
   * @param {Boolean} eventData.isAllDay `true` if the event is an all day event, or spans multiple days.
   * @param {Boolean} eventData.isOverflow `true` if this is being called as part of further propagation.
   * @param {Boolean} eventData.overflows `true` if the event extends into future cells.
   * @param {Scheduler.model.EventModel} eventData.eventRecord The event record being propagated.
   * @param {Date} eventData.date The date from which the event is being propagated.
   * @returns {Date} The date (as a timepoint, *not* a reference to a 24 hour time block)
   * to which the event bar should be propagated
   * @internal
   */
  calculatePropagateEndDate(eventData, viewEndDate = this.endDate) {
    const {
        eventEndDate: endDate
      } = eventData,
      startOfDay = this.dayTime.startOfDay(endDate);
    // Round a timeStamp after midnight to the next midnight.
    // Then minimize with our end date. No point collecting cells after the view's last cell
    eventData.propagateEndDate = new Date(Math.min(endDate > startOfDay ? DateHelper.add(startOfDay, 1, 'day') : endDate, viewEndDate));
    /**
     * Fires when a day spanning event is found, and the date to which its encapsulating event bar
     * extends has been calculated.
     *
     * The default result in the event's `propagateEndDate` property may be mutated by a listener.
     *
     * Note that this is an ending point in time, it does *not* refer to a 24 hour block. So setting
     * the `propagateEndDate` to `new Date(2022, 1, 10)` means that the event bar will occupy cells
     * up to and including February 9 2022 and no further.
     *
     * This is relayed through the owning {@link Calendar.view.Calendar}, so a single listener
     * may be used, for example:
     *
     * ```javascript
     * new Calendar({
     *     listeners : {
     *         eventPropagate(eventData) {
     *             // If the event only spills into the next day but not further
     *             // then we do not want an extended event bar.
     *             // An arrow will indicate that it continues rightwards.
     *             if (eventData.eventEndDate < DateHelper.add(eventData.date, 2, 'd')) {
     *                 eventData.propagateEndDate = DateHelper.add(DateHelper.clearTime(eventData.eventRecord.startDate), 1, 'd');
     *             }
     *         }
     *     }
     * })
     * ```
     *
     * The `eventEndDate` in the data block may also be changed to override the event's real end date.
     * This will mean that there will be no arrow indicating that the event continues:
     *
     * ```javascript
     * new Calendar({
     *     listeners : {
     *         eventPropagate(eventData) {
     *             // If the event spills into the next day but not further
     *             // then we do not want an extended event bar.
     *             // Because we override the eventEndDate, no arrow will be present
     *             // to indicate any continuation.
     *             if (eventData.eventEndDate < DateHelper.add(eventData.date, 2, 'd')) {
     *                 eventData.propagateEndDate = eventData.eventEndDate = DateHelper.add(DateHelper.clearTime(eventData.eventRecord.startDate), 1, 'd');
     *             }
     *         }
     *     }
     * });
     * ```
     *
     * @event eventPropagate
     * @param {Date} eventEndDate The end date for which to calculate the propagate end date.
     * @param {Date} propagateEndDate The system-calculated end point of the event bar.
     * @param {Boolean} isAllDay `true` if the event is an all day event, or spans multiple days.
     * @param {Boolean} isOverflow `true` if this is being called as part of further propagation.
     * @param {Boolean} overflows `true` if the event extends into future cells.
     * @param {Scheduler.model.EventModel} eventRecord The event record being propagated.
     * @param {Date} date The date from which the event is being propagated.
     */
    this.trigger('eventPropagate', eventData);
    return eventData.propagateEndDate;
  }
  // Overrideable in subclasses.
  collectEvents(options) {
    return this.eventStore.getEvents(options);
  }
  propagateCellEvents(cellData, cellMap) {
    const {
        events,
        renderedEvents,
        previousEvents,
        nextEvents,
        date
      } = cellData,
      eventsPerCell = this.getEventsPerCell(date),
      {
        length
      } = events;
    for (let i = 0; i < length; i++) {
      const event = events[i],
        {
          eventRecord,
          propagateEndDate,
          eventEndDate
        } = event;
      // This is its start slot in its starting cell.
      // For the rest of the week, it must occupy the same slot in cells
      // that iot flow into.
      // Once wrapped to a new week, it just stacks up in available space.
      let renderedSlot = renderedEvents.add(event);
      // The event overflows into future cells.
      // We need to claim the event's slot in any future cells which it covers.
      if (event.overflows) {
        // It's only overflow in cells which come *after* it has become visible
        let isVisible = cellData.visible,
          lastEvent;
        // Walk forwards until we are on a cell which is not covered by this event.
        for (let nextDay = nextEvents; nextDay && nextDay.date < propagateEndDate; nextDay = nextDay.nextEvents) {
          // On move to a new week, we no longer have to maintain the same event slot
          if (!nextDay.columnIndex) {
            renderedSlot = nextDay.renderedEvents.firstFreeSlot;
          }
          // For each day into which the event extends, occupy its slot
          nextDay.renderedEvents.set(renderedSlot, lastEvent = {
            eventRecord,
            eventEndDate,
            propagateEndDate,
            isAllDay: event.isAllDay,
            isOverflow: isVisible,
            overflows: true
          });
          // Once it's visible, all future cell slots have isOverflow: true
          isVisible = isVisible || nextDay.visible;
        }
        // Obviously the last one we propagated to does not overflow
        lastEvent && (lastEvent.overflows = false);
      }
    }
    // The loop end when rendering
    cellData.maxRow = renderedEvents.length;
    const lastEvent = renderedEvents[eventsPerCell - 1];
    // If we're just filling our cell, but the last one is an overflow from the previous cell
    // AND the previous cell vertically overflowed, we must show the +1 more indicator to match.
    // This is the *ONLY* case where we ever show a "+1 more" indicator.
    // We show "+2 more" at least because an overflow indicator is the same height as an event bar.
    if (renderedEvents.length === eventsPerCell) {
      if (lastEvent !== null && lastEvent !== void 0 && lastEvent.isOverflow && previousEvents !== null && previousEvents !== void 0 && previousEvents.hasOverflow) {
        cellData.maxRow--;
        cellData.hasOverflow = true;
      }
    }
    // Decide whether the cell's rendered events overflow its height.
    else if (renderedEvents.length > eventsPerCell) {
      cellData.maxRow = eventsPerCell - 1;
      cellData.hasOverflow = true;
      // If the last slot is an overflow, its originating cell and all intervening ones
      // must be flagged as overflowing so that they get a +"1 more" indicator.
      // The originating cell and all intervening cells must display the overflow indicator
      // if its last visible slot overflows and any future cells that it flows into overflow.
      // See below. We are processing that 3rd cell.
      // If the 3rd cell was not overflowing, it would be fine.
      // But because it needs its own "+2 More" indicator, that originating
      // cell and all intervening ones must also get a "+1 More" indicator even
      // if they're not overflowing because there must be no long event bar to
      // obscure Oct 12's "+2 More indicator".
      // +----------+----------+----------+----------+
      // |  Oct 10  |  Oct 11  |  Oct 12  |          |
      // +----------+----------+----------+----------+
      // |  Event   |  Event   |  Event   |          |
      // |  Event   |  Event   |  Event   |          |
      // |  Event   |  Event   |  Event   |          |
      // |  EventWhichIsExtremelyLong     |          |
      // +----------+----------+----------+----------+
      //                          Event
      if (lastEvent !== null && lastEvent !== void 0 && lastEvent.isOverflow) {
        const
          // Jump back to view's start cell.
          weekStartValue = this.firstVisibleDate,
          eventStartValue = DateHelper.clearTime(lastEvent.eventRecord.startDate).valueOf();
        // Only go back as far as the start of the current week.
        let originatingCell = cellMap.get(DateHelper.makeKey(new Date(Math.max(weekStartValue, eventStartValue))));
        // So if Oct 12's lastEvent isOverflow, we loop through Oct 10 and 11th's cells
        // and reduce the number of available visual slots
        while (originatingCell.key !== cellData.key) {
          originatingCell.hasOverflow = true;
          originatingCell.maxRow = eventsPerCell - 1;
          originatingCell = originatingCell.nextEvents;
        }
      }
    }
    // Walk on to the next one
    nextEvents && this.propagateCellEvents(nextEvents, cellMap);
  }
  createCellData(date) {
    return Object.assign(this.cellMonth.getCellData(date, this.month, this.dayTime), {
      events: [],
      // Events can forward-occupy slots if they
      // overrun their start day.
      // So the next step is to propagate forward
      // multi day events into future cells they cover.
      renderedEvents: new EventSlots()
    });
  }
});
// We need a cell map which can be flagged as being populated even if it is empty
// so that the cellMap getter can only actually refill the cell map if it is not populated.
// A cell map may be empty but populated if there are no eligible events in the date range.
class CellMap extends Map {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "populated", false);
  }
  get(d, value) {
    return super.get(DateHelper.makeKey(d), value);
  }
  set(d, value) {
    d = DateHelper.makeKey(d);
    if (!this.has(d)) {
      this.generation = (this.generation || 0) + 1;
    }
    return super.set(d, value);
  }
  delete(d, value) {
    d = DateHelper.makeKey(d);
    if (this.has(d)) {
      this.generation++;
    }
    return super.delete(d, value);
  }
  has(d) {
    return super.has(DateHelper.makeKey(d));
  }
  clear() {
    this.populated = false;
    this.generation = (this.generation || 0) + 1;
    return super.clear();
  }
}

/**
 * @module Calendar/widget/OverflowPopup
 */
/**
 * This class is not supposed to be used directly. It is used by Calendar views which need to show
 * more events than will fit into a day cell.
 *
 * A Popup which displays events which will not fit into their container in a View
 *
 * @extends Core/widget/Popup
 * @classType overflowpopup
 */
class OverflowPopup extends Popup {
  static get $name() {
    return 'OverflowPopup';
  }
  // Factoryable type name
  static get type() {
    return 'overflowpopup';
  }
  static get configurable() {
    return {
      textContent: false,
      autoShow: false,
      floating: false,
      cls: 'b-cal-event-list',
      closable: true,
      draggable: {
        handleSelector: ':not(.b-cal-event-wrap)'
      },
      anchor: true,
      layout: 'vbox',
      /**
       * An empty function by default, but provided so that you can override it.
       *
       * This function is called each time an event is rendered to to allow developers to mutate
       * the cell metadata, or the CSS classes to be applied to the event element.
       *
       * It's called with the event record, and a eventData object which allows you to mutate event metadata
       * such as 'cls', 'style'.
       *
       * The cls property is an object whose property names will be added to the event element if the property
       * value is truthy.
       *
       * The style property is an object containing style properties for the event element.
       *
       * A non-null return value from the renderer is used as the event body content. A nullish
       * return value causes the default renderer to be used which just uses the event name.
       *
       * If a string is returned, it is used as the HTML content of the event body element.
       *
       * If an object is returned, it is used as a {@link Core.helper.DomHelper#typedef-DomConfig} object to
       * create complex content in the event body element.
       *
       * ```javascript
       *  eventRenderer({ eventRecord, renderData }) {
       *      if (eventRecord.name === 'Doctors appointment') {
       *          eventData.style.fontWeight = 'bold';
       *          eventData.cls['custom-cls'] = 1;
       *
       *          return 'Special doctors appointment';
       *      }
       *  }
       * ```
       * IMPORTANT: When returning content, be sure to consider how that content should be encoded to avoid XSS
       * (Cross-Site Scripting) attacks. This is especially important when including user-controlled data such as
       * the event's `name`. The function {@link Core.helper.StringHelper#function-encodeHtml-static} as well as
       * {@link Core.helper.StringHelper#function-xss-static} can be helpful in these cases.
       *
       * For example:
       * ```javascript
       *  eventRenderer({ eventRecord }) {
       *      return StringHelper.xss`Event: ${eventRecord.name}`;
       *  }
       * ```
       * @config {Function} eventRenderer
       * @param {Object} detail An object that contains data about the event being rendered.
       * @param {Scheduler.model.EventModel} detail.eventRecord The event record
       * @param {Scheduler.model.ResourceModel} detail.resourceRecord The event record
       * @param {Object} detail.renderData A data object containing properties that will be used to create the event element.
       * @param {Object} detail.renderData.style The style property is an object containing style properties for
       * the event element.
       * @param {Object} detail.renderData.cls The cls property is an object whose property names will be added to
       * the event element if the property value is truthy.
       * @param {String} detail.renderData.eventColor Color to be applied to the event
       */
      eventRenderer: null,
      /**
       * A function which compares events to decide upon rendering order.
       *
       * By default, this class uses {@link Calendar.util.EventSorter#function-interDaySorterFn-static}.
       *
       * A custom sort function may be configured.
       *
       * Note that the two objects to compare may either be {@link Scheduler.model.EventModel}s
       * or an object which __contains__ an `eventRecord` property which is the {@link Scheduler.model.EventModel}.
       * @config {Function}
       */
      eventSorter: EventSorter.interDaySorterFn,
      /**
       * A {@link Core.widget.Widget} config object used to show the inner list of overflowing events
       * shown in this popup.
       *
       * This widget has a {@link Core.widget.Widget#config-weight} of `500`, so to insert widgets above
       * this, use `weight` less than 500, and to insert widgets below it use `weight` greater than 500.
       * @config {Object}
       * @default
       */
      eventList: {
        type: 'widget',
        cls: 'b-cal-event-bar-container',
        weight: 500
      },
      items: {},
      tools: {
        maximize: null
      },
      /**
       * The {@link Core.helper.DateHelper#function-format-static DateHelper} format string to use to
       * create the {@link #config-title} of this dialog.
       * @config {String}
       * @default
       */
      dateFormat: 'dddd, MMM DD',
      activeDate: {
        $config: {
          equal: 'date'
        },
        value: null
      },
      scrollAction: 'hide',
      align: {
        axisLock: 'flexible',
        constrainPadding: 20,
        minHeight: 400
      },
      scrollable: {
        overflowY: 'auto'
      },
      /**
       * By default an event overflow popup shows all the events for the activated date.
       *
       * Configure this as `true` to only display the events which were hidden due to overflow.
       * @config {Boolean}
       */
      onlyShowOverflow: null
    };
  }
  calendarHitTest(domEvent) {
    const target = DomHelper.getEventElement(domEvent),
      closest = target.closest('.b-cal-event-wrap');
    if (closest) {
      return {
        type: 'event',
        eventElement: closest,
        eventRecord: this.owner.eventStore.getById(closest.dataset.eventId),
        view: this
      };
    }
    return null;
  }
  onHeaderClick({
    event: domEvent
  }) {
    if (domEvent.target.closest('.b-header-title')) {
      var _this$owner;
      (_this$owner = this.owner) === null || _this$owner === void 0 ? void 0 : _this$owner.trigger('dayNumberClick', {
        domEvent,
        date: this.activeDate,
        cellData: this.cellData,
        source: this.owner,
        fromOverflowPopup: true
      });
    } else {
      super.onHeaderClick(...arguments);
    }
  }
  get focusElement() {
    var _this$eventList, _this$eventList$eleme;
    const activeElement = DomHelper.getActiveElement(this);
    return this.element.contains(activeElement) ? activeElement : ((_this$eventList = this.eventList) === null || _this$eventList === void 0 ? void 0 : (_this$eventList$eleme = _this$eventList.element) === null || _this$eventList$eleme === void 0 ? void 0 : _this$eventList$eleme.firstElementChild) || super.focusElement;
  }
  getDateFromPosition() {
    // This View only shows one date, so the answer is easy.
    return this.activeDate;
  }
  getEventElement(eventRecord) {
    return this.contentElement.querySelector(`[data-event-id="${eventRecord.id}"]`);
  }
  showOverflow(cell, cellData) {
    /**
     * The date for which overflow is being shown.
     * @readonly
     * @member {Date} activeDate
     */
    const date = this.activeDate = cellData.date;
    /**
     * A data block containing information about the day for which overflow is being shown.
     * @readonly
     * @member {DayCell} cellData
     */
    this.cellData = cellData;
    this.targetCell = cell;
    this.refresh(cellData);
    this.showBy(cell);
    if (this.isVisible) {
      var _this$owner2;
      // Fired on the owning view. Documented in DayCellRenderer
      (_this$owner2 = this.owner) === null || _this$owner2 === void 0 ? void 0 : _this$owner2.trigger('showOverflowPopup', {
        cell,
        cellData,
        date,
        overflowPopup: this
      });
    }
  }
  // Owning view calls this from its own onCalendarStoreChange implementation
  onCalendarStoreChange() {
    const me = this;
    if (me.isVisible) {
      me.cellData = me.owner.cellMap.get(DateHelper.makeKey(me.activeDate));
      me.refresh(me.cellData);
    }
  }
  refresh(cellData) {
    var _cellData, _cellData2;
    // eventList might be configured away
    if (!this.eventList) {
      return;
    }
    // Allow the caller to update the overflow state
    if (cellData) {
      this.cellData = cellData;
    } else {
      cellData = this.cellData;
    }
    const me = this,
      {
        owner,
        eventRenderer
      } = me,
      {
        element
      } = me.eventList,
      // Slice using eventsPerCell - 1 because if there's one event that won't fit,
      // the last event fitting will be evicted to make room for the overflow indicator.
      // If there's no overflow indicator (like in YearView), eventsPerCell will be
      // zero, so sanitize value up to 0.
      slicePoint = me.onlyShowOverflow ? Math.max(owner.eventsPerCell - 1, 0) : 0,
      // Because of long running events overflowing, allDay events and intraday
      // events could be interleaved in the cells slots.
      // In the event list, we sort them into the required order with
      // oldest and longest at the top.
      events = (_cellData = cellData) === null || _cellData === void 0 ? void 0 : _cellData.renderedEvents.slice(slicePoint).sort(me.eventSorter),
      children = [];
    // We can delete events from the Popup, so when we've exhausted the events, we must hide.
    // Also, if a refresh was called from the owner's resize handling, that may have caused
    // the overflow state to have changed to not overflowing.
    // YearView can't not overflow. It's just a heat map.
    if (!(events !== null && events !== void 0 && events.length) || !((_cellData2 = cellData) !== null && _cellData2 !== void 0 && _cellData2.hasOverflow) && !owner.isYearView) {
      return me.hide();
    }
    for (let i = 0, eventRow = 0, {
        length
      } = events; i < length; i++, eventRow++) {
      const renderedEvent = events[i];
      // If the slot is occupied, add a child event element.
      // These just flow down the Popup's bodyElement
      if (renderedEvent) {
        const eventDomConfig = owner.createEventDomConfig(renderedEvent, eventRenderer);
        Object.assign(eventDomConfig.className, {
          // The event started in a previous day
          'b-continues-past': renderedEvent.eventRecord.startDate < cellData.date,
          // The event ends in a future day
          'b-continues-future': renderedEvent.eventRecord.endDate > cellData.tomorrow
        });
        eventDomConfig.style.marginBottom = `${owner.eventSpacing}px`;
        children.push(eventDomConfig);
      }
    }
    DomSync.sync({
      domConfig: {
        children
      },
      targetElement: element
    });
    // Fix up cell's time info.
    element.dataset.date = cellData.key;
    element.classList.add(`b-day-of-week-${cellData.day}`);
    element.classList.remove(`b-day-of-week-${me.lastRefreshDay}`);
    me.lastRefreshDay = cellData.day;
    me.realign();
  }
  changeItems(items) {
    const {
      eventList
    } = this;
    if (eventList) {
      items.eventList = eventList;
    }
    const result = super.changeItems(items);
    if (eventList) {
      this.eventList = this.widgetMap.eventList;
    }
    return result;
  }
  changeActiveDate(activeDate, oldActiveDate) {
    activeDate = typeof date === 'string' ? DateHelper.parse(activeDate) : new Date(activeDate);
    if (isNaN(activeDate)) {
      throw new Error('OverflowPopup date ingestion must be passed a Date, or a YYYY-MM-DD date string');
    }
    return activeDate;
  }
  updateActiveDate(activeDate) {
    this.element.dataset.date = DateHelper.makeKey(activeDate);
    this.title = DateHelper.format(activeDate, this.dateFormat);
  }
  onDocumentMouseDown({
    event
  }) {
    var _this$lastAlignSpec;
    const alignedTo = (_this$lastAlignSpec = this.lastAlignSpec) === null || _this$lastAlignSpec === void 0 ? void 0 : _this$lastAlignSpec.target,
      {
        target
      } = event;
    // On mousedown of our own activating element, do not focusout
    if (alignedTo !== null && alignedTo !== void 0 && alignedTo.contains(target)) {
      const cellOverflowButton = target.closest('.b-cal-cell-overflow');
      // If it's a click inside the overflowing cell, or inside the overflow button
      // then ignore it, we're clicking on our own data or overflow button.
      if (target.closest('.b-cal-event-bar-container') || target.matches('.b-cal-cell-overflow') || (cellOverflowButton === null || cellOverflowButton === void 0 ? void 0 : cellOverflowButton.children.length) === 1) {
        return event.preventDefault();
      }
    }
    super.onDocumentMouseDown(...arguments);
  }
}
OverflowPopup.initClass();
OverflowPopup._$name = 'OverflowPopup';

/**
 * @module Calendar/widget/mixin/DayCellRenderer
 */
const emptyFn = () => {},
  {
    eventNameMap
  } = EventHelper;
/**
 * Mixin that provides the ability to render a calendar cell.
 *
 * This is used by the MonthView and also CalendarRow. It expects its
 * host class to include the {@link Calendar.widget.mixin.CalendarMixin} mixin.
 *
 * @mixin
 */
var DayCellRenderer = (Target => class DayCellRenderer extends (Target || Base) {
  static get $name() {
    return 'DayCellRenderer';
  }
  static get configurable() {
    return {
      monitorResize: true,
      // we need to adjust the "+ 2 more" overflow indicator
      /**
       * This may be specified to create the content for the date and day name section of calendar cells.
       *
       * This function is called for each cell rendered. It can return an HTML string which will become the
       * content of the header section of the cell above any events.
       *
       * It can also return a {@link Core.helper.DomHelper#typedef-DomConfig} element creation object (or array of
       * same) to specify content to create in the header section of the cell.
       *
       * It also allows developers to mutate the cell metadata, or the CSS classes to be applied to the cell.
       *
       * The {@link Core.helper.DomHelper#typedef-DomConfig} definition passed as the first parameter may be
       * mutated to create a different cell header.
       *
       * ```javascript
       * dayCellRenderer : function(cellData, dayCellDomConfig) {
       *     // I don't like Mondays!
       *     if (cellData.day === 1) {
       *         dayCellDomConfig.className['hackathon-dayoff'] = true;
       *         dayCellDomConfig.style.fontWeight = 'bold';
       *
       *         cellData.isNonWorking = true;
       *
       *         return `${cellData.date.getDate()} Day off yay!`;
       *     }
       * }
       *```
       *
       * A non-null return value from the renderer is used as the content of the day number element.
       *
       * @config {Function} dayCellRenderer
       * @param {DayCell} dayCellRenderer.cellData An object that contains data about the cell.
       * @param {DomConfig} dayCellDomConfig An object to sync the day cell element.
       * @param {Object} dayCellDomConfig.className An object who's truthy property names will be applied as class
       * names.
       * @param {Object} dayCellDomConfig.style A CSS style definition object.
       * @param {Object} dayCellDomConfig.dataset The DOM data properties to set.
       * @param {DomConfig[]} dayCellDomConfig.children The {@link DomConfig} definitions for the content of the
       * cell.
       * @returns {String|Object|Object[]} The definition of the cell header content.
       */
      dayCellRenderer: null,
      // Must still be visible if dynamically set to non working to keep
      // column arrangement correct.
      dynamicHideNonWorkingdayCls: 'b-dynamic-nonworking-day',
      /**
       * The {@link Calendar.widget.OverflowPopup} instance that this view may show when events
       * for one day overflow the available space.
       * @member {Calendar.widget.OverflowPopup} overflowPopup
       * @readonly
       */
      /**
       * A config object used to create the {@link Calendar.widget.OverflowPopup} that this view
       * may show when events for one day overflow the available space.
       *
       * For example
       *
       *```javascript
       *     modes : {
       *         month : {
       *             overflowPopup : {
       *                 closable   : false,
       *                 dateFormat : 'dddd, MMM M',
       *                 eventRenderer({ eventRecord, renderData }) {
       *                     if (calendarUtils.isImportantEvent(eventRecord)) {
       *                         // Add CSS class to important events
       *                         renderData.cls['b-important'] = 1;
       *                     }
       *                 }
       *             }
       *         }
       *     }
       *```
       * @config {OverflowPopupConfig}
       */
      overflowPopup: {
        $config: ['lazy', 'nullify'],
        value: {
          type: 'overflowpopup'
        }
      },
      /**
       * The pointer gesture which shows the popup containing any overflowing events
       * in the current view.
       *
       * This means events which will not fit into a `MonthView` day cell, or *all* events
       * for a `YearView` cell.
       *
       * Useful values are `'click'` (the default), and `'mouseover'`
       * @config {'click'|'mouseover'|'hover'}
       * @default
       */
      overflowPopupTrigger: 'click',
      eventBarContainerCls: 'b-cal-event-bar-container',
      /**
       * A function, or name of a function which is passed the {@link DomConfig} object which
       * will be used to create the "+n more" button which indicates that a day cell has
       * overflowing events.
       *
       * ```javascript
       * overflowButtonRenderer : function(domConfig) {
       *     domConfig.className['b-fa'] = domConfig.className['b-fa-list'] = 1;
       *     return domConfig;
       * }
       *```
       *
       * The result is used to create the overflow button element.
       *
       * To target the element using custom CSS, use the class name `b-cal-cell-overflow`.
       *
       * @config {Function} overflowButtonRenderer
       * @param {DomConfig} domConfig A {@link DomConfig} config object which is used to
       * create the overflow button.
       * @param {String} domConfig.tag=button The tag name of the element to create.
       * @param {Object} domConfig.className An object who's truthy property names will be applied as class names.
       * @param {String} domConfig.text The inner content of the element. **Note that this
       * will be HTML encoded for XSS safety**
       * @param {Object} domConfig.style A CSS style definition object.
       * @param {Object} domConfig.dataset The DOM data properties to set.
       * @param {Number} overflowCount The number of overflowing events.
       */
      overflowButtonRenderer: null,
      /**
       * The {@link Core.helper.DateHelper} format string to format the day names
       * in the header part of each calendar cell.
       * @config {String}
       */
      dayCellNameFormat: null,
      /**
       * How much vertical space in pixels to leave between event bars in a cell.
       * @member {Number} eventSpacing
       */
      /**
       * How much vertical space in pixels to leave between event bars in a cell.
       * @config {Number}
       * @default
       */
      eventSpacing: 2,
      emptyCellCls: 'b-cal-empty-cell',
      /**
       * A {@link DomConfig} object which will be used to create the content of a clickable
       * element which is present when no events are in a cell.
       *
       * Or a function, or name of a function which returns a {@link DomConfig} object.
       *
       * See the {@link Calendar.view.Calendar#event-emptyCellClick} event.
       * @config {Function|Object|String} emptyCellRenderer
       * @param {DayCell} dayCellRenderer.cellData An object that contains data about the cell.
       */
      emptyCellRenderer: null
    };
  }
  onCalendarStoreChange() {
    var _this$_overflowPopup;
    super.onCalendarStoreChange(...arguments);
    // Ensure any overflow popup is informed immediately after its owning View has been informed.
    if ((_this$_overflowPopup = this._overflowPopup) !== null && _this$_overflowPopup !== void 0 && _this$_overflowPopup.isVisible) {
      this._overflowPopup.onCalendarStoreChange(...arguments);
    }
  }
  // Called automatically on the CellOverflow${overflowPopupTrigger} event because of callOnFunctions
  onCellOverflowGesture({
    domEvent,
    date
  }) {
    const me = this,
      cellData = me.cellMap.get(DateHelper.makeKey(date));
    if (cellData) {
      const {
          overflowPopup
        } = me,
        cell = me.getCellFromEvent(domEvent);
      /**
       * Fired after an {@link Calendar.widget.OverflowPopup} has been shown when an a
       * "+ n more" overflow button is activated by an {@link #config-overflowPopupTrigger} event.
       * @event showOverflowPopup
       * @param {HTMLElement} cell The day cell for which the overflow popup is going to be shown.
       * @param {DayCell} cellData An object that contains data about the cell.
       * @param {Date} date The date which has overflowing events
       * @param {Calendar.widget.OverflowPopup} overflowPopup The overflow `Popup`.
       */
      /**
       * Fired before an {@link Calendar.widget.OverflowPopup} is shown when an a
       * "+ n more" overflow button is activated by an {@link #config-overflowPopupTrigger} event.
       * @event beforeShowOverflowPopup
       * @param {HTMLElement} cell The day cell for which the overflow popup is going to be shown.
       * @param {DayCell} cellData An object that contains data about the cell.
       * @param {Date} date The date which has overflowing events
       * @param {Calendar.widget.OverflowPopup} overflowPopup The overflow `Popup`.
       * @preventable
       */
      if (overflowPopup && me.trigger('beforeShowOverflowPopup', {
        cell,
        cellData,
        date,
        overflowPopup
      })) {
        overflowPopup.showOverflow(cell, cellData);
      }
    }
  }
  getCellFromEvent(domEvent) {
    return domEvent.target.closest('.b-calendar-cell[data-date]');
  }
  updateOverflowPopupTrigger(overflowPopupTrigger) {
    this.onCellOverflowClick = this.onCellOverflowMouseOver = emptyFn;
    // Must be correctly camel cased so the we can create the `onCellOverflow${gesture}` method name.
    // So mouseover => mouseOver so that we inject an onCellOverflowMouseOver method.
    overflowPopupTrigger = overflowPopupTrigger.toLowerCase();
    if (overflowPopupTrigger === 'mouseover' || overflowPopupTrigger === 'hover') {
      overflowPopupTrigger = 'mouseOver';
    }
    this[`onCellOverflow${StringHelper.capitalize(overflowPopupTrigger)}`] = this.onCellOverflowGesture;
  }
  changeOverflowPopup(config, instance) {
    const me = this,
      popupOwner = me.up('calendar') || me.owner || me,
      // We use OverflowPopup instead of Widget since that will have any additional configs and will use the
      // correct merge procedure for them (if any were customized). The actual type can be derived and if so,
      // those config merge fns will not be consulted but that's very unlikely and not worth solving for in
      // general (though it could be).
      ret = OverflowPopup.reconfigure(instance, config, {
        owner: me,
        // so that we'll destroy our instances on reconfigure to null
        defaults: {
          owner: me,
          align: {
            constrainTo: globalThis
          }
        }
      });
    if (ret) {
      const {
          element
        } = ret,
        {
          eventHeightInPixels
        } = me;
      // Make popup selectable
      ret.element.classList.add(`b-${me.type}-overflowpopup`);
      // OverflowPopup is not a global floater by default. It's rendered inside of the Calendar
      // element so that focus stays within, and the Navigator can follow focus.
      // If that has not been overridden by configuration, render inside calendar content.
      if (!ret.floating) {
        ret.positioned = true;
        ret.render(popupOwner.isCalendar ? popupOwner.element : popupOwner.contentElement);
      }
      // Some views, like DayView don't have a pixel event height.
      if (eventHeightInPixels) {
        element.style.setProperty('--event-height', `${eventHeightInPixels}px`);
        element.style.setProperty('--arrow-width', `${eventHeightInPixels / 3}px`);
      }
      // We have to relay interaction events upwards from the overflow popup if it's
      // not rendered into this view. If it is, then the events will bubble.
      if (ret !== instance && popupOwner !== me) {
        EventHelper.on({
          thisObj: me,
          element: ret.bodyElement,
          delegate: '.b-cal-event-wrap',
          mouseover: 'onEventMouseOverOut',
          mouseout: 'onEventMouseOverOut',
          mousedown: 'onCalendarPointerInteraction',
          mouseup: 'onCalendarPointerInteraction',
          click: 'onCalendarPointerInteraction',
          dblclick: 'onCalendarPointerInteraction',
          contextmenu: 'onCalendarPointerInteraction'
        });
        // Header may have been configured away.
        if (ret.headerElement) {
          EventHelper.on({
            thisObj: me,
            element: ret.headerElement,
            mousedown: 'onCalendarPointerInteraction',
            mouseup: 'onCalendarPointerInteraction',
            click: 'onCalendarPointerInteraction',
            dblclick: 'onCalendarPointerInteraction',
            contextmenu: 'onCalendarPointerInteraction'
          });
        }
      }
    }
    return ret;
  }
  onInternalResize(element, width, height, oldWidth, oldHeight) {
    const {
      _eventsPerCell,
      _eventContainerTop
    } = this;
    super.onInternalResize(element, width, height, oldWidth, oldHeight);
    if (this.rendered && height !== oldHeight) {
      // Calculates new values for eventsPerCell and eventContainerTop
      // and handles changes to either.
      this.performResizeRefresh(_eventsPerCell, _eventContainerTop);
    }
  }
  performResizeRefresh(prevEventsPerCell, prevEventContainerTop, now) {
    // Invalidate the values so that they are recalculated
    this._eventsPerCell = this._eventContainerTop = this._eventContainerHeight = null;
    const me = this,
      {
        eventsPerCell,
        _overflowPopup
      } = me;
    if (eventsPerCell !== prevEventsPerCell) {
      /**
       * Fires when number of events which could be placed in one cell is changed.
       * Has place when the height of the Month view is changed.
       * @event eventsPerCellChange
       * @param {Calendar.widget.MonthView} source This `MonthView` instance.
       * @param {Number} value New number of events per cell.
       * @param {Number} oldValue Previous number of events per cell.
       * @private
       */
      me.trigger('eventsPerCellChange', {
        value: eventsPerCell,
        oldValue: prevEventsPerCell
      });
    }
    // If the component height change caused the event start position to change
    // or the eventsPerCell to change, refresh.
    if (me.eventContainerTop !== prevEventContainerTop || eventsPerCell !== prevEventsPerCell) {
      // If now passed as true, use doRefresh rather than refresh which waits until visible.
      now ? me.doRefresh() : me.refresh();
      // The overflow state may have changed. If we are visible, refresh will have happened.
      // OverflowPopup will hide itself if the ext cellData block has no overflow
      if (_overflowPopup !== null && _overflowPopup !== void 0 && _overflowPopup.isVisible) {
        _overflowPopup.refresh(me._cellMap.get(DateHelper.makeKey(_overflowPopup.activeDate)));
      }
    }
  }
  updateEventHeight() {
    // CalendarMixin class needs to know
    super.updateEventHeight(...arguments);
    // Force a recalculate on next access
    this._eventsPerCell = null;
  }
  updateEventSpacing() {
    // Force a recalculate on next access
    this._eventsPerCell = null;
    // Schedule a refresh
    if (!this.isConfiguring) {
      this.refreshSoon();
    }
  }
  get weeksElement() {
    return this.contentElement;
  }
  get eventContainerHeight() {
    // Must not bake the property in as zero if called during configuration.
    if (this._eventContainerHeight == null && this.isVisible && !this.isConfiguring) {
      const {
        firstVisibleCell
      } = this;
      this._eventContainerHeight = firstVisibleCell ? firstVisibleCell.offsetHeight - this.eventContainerTop : NaN;
    }
    return this._eventContainerHeight;
  }
  get eventContainerTop() {
    const me = this;
    // Must not bake the property in as zero if called during configuration.
    if (me._eventContainerTop == null && me.isVisible && !me.isConfiguring) {
      const {
          firstVisibleCell
        } = me,
        c = firstVisibleCell && firstVisibleCell.querySelector(`.${me.eventBarContainerCls}`),
        top = c ? c.getBoundingClientRect().top - c.offsetParent.getBoundingClientRect().top : 0;
      // We must use accurate rectangles to calculate the layout.
      // TODO: Nige should check, it still becomes 0 without this change
      me._eventContainerTop = top === 0 ? null : top;
    }
    return me._eventContainerTop || 0;
  }
  /**
   * Returns the number of complete event bars which will fit inside the referenced cell.
   *
   * The base implementation assumes all cells are the same height. In most views, most of the time,
   * this is true.
   *
   * It's only in MonthView when some rows are shrinkwrapped round their event content (meaning
   * either expanded or contracted away from the 1/6 height default) that there may be a customized
   * eventsPerCell for a certain date. So only MonthView has an overriding implementation.
   * @internal
   */
  getEventsPerCell(date) {
    return this.eventsPerCell;
  }
  get eventsPerCell() {
    const me = this;
    if (me._eventsPerCell == null) {
      me._eventsPerCell = Math.floor((me.eventContainerHeight + me.eventSpacing) / (me.eventHeightInPixels + me.eventSpacing));
    }
    return me._eventsPerCell;
  }
  get cellMap() {
    var _this$_cellMap;
    // If the cellMap has not been populated, create it.
    return (_this$_cellMap = this._cellMap) !== null && _this$_cellMap !== void 0 && _this$_cellMap.populated ? this._cellMap : this.createCellMap();
  }
  cellRenderer({
    cell
  }) {
    const domConfig = this.getCellDomConfig(...arguments);
    DomSync.sync({
      domConfig,
      targetElement: cell
    });
  }
  getCellDomConfig({
    cell,
    columnIndex,
    row,
    date,
    day,
    dayTime = DayTime.MIDNIGHT,
    visibleColumnIndex,
    key
  }) {
    var _me$calendar;
    const me = this,
      {
        eventHeightInPixels,
        eventSpacing,
        weekLength,
        todayCls,
        emptyCellRenderer
      } = me,
      today = me.dayTime.startOfDay(((_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.dateTimeNow) || new Date()),
      isToday = date.getTime() === today.getTime(),
      dayNumber = date.getDate(),
      eventContainer = {
        className: me.eventBarContainerCls,
        role: 'presentation',
        children: [],
        // Match existing data-event-id elements first and ensure DOM order matches
        // children order.
        syncOptions: {
          syncIdField: 'eventId',
          releaseThreshold: 0,
          strict: true
        }
      },
      cellHeader = {
        style: {},
        className: new DomClassList({
          'b-cal-cell-header': true,
          [todayCls]: isToday
        })
      },
      domConfig = {
        dataset: {},
        style: {},
        className: new DomClassList(cell === null || cell === void 0 ? void 0 : cell.className),
        children: [cellHeader, eventContainer]
      },
      isFirstVisibleCell = !(date - (me.firstVisibleDate || -1));
    domConfig.className[todayCls] = isToday;
    // Some views may create a day name element into which a dayCellRenderer may add content.
    // MonthView does this. CalendarRow does not. It has a separate concept of dayHeaderRenderer
    let dayName,
      dayEvents = !me.isConfiguring && me.cellMap.get(DateHelper.makeKey(date));
    if (me.addCellHeaderContent) {
      // addCellHeaderContent mutates the cellHeader DomConfig block.
      // And if we are to have a day name element, returns the DomConfig for it.
      dayName = me.addCellHeaderContent(cellHeader, dayEvents || (dayEvents = me.createCellData(date)));
    } else {
      cellHeader.children = [dayName = {
        className: {
          'b-day-name': true
        }
      }];
    }
    let dynamicallySetToNonWorking;
    // Give the dayCellRenderer access to the configuration object for the cell header
    if (me.dayCellRenderer && !me.isConfiguring) {
      // If they have a cell renderer, there must be cell info to give it.
      if (!dayEvents) {
        dayEvents = me.createCellData(date);
      }
      // Allow dayCellRenderer to access cell style and classes
      dayEvents.style = domConfig.style;
      dayEvents.cls = domConfig.className;
      // Allow dayCellRenderer to access cell header style and classes
      dayEvents.headerStyle = cellHeader.style;
      dayEvents.headerCls = cellHeader.className;
      const wasNonWorking = dayEvents && dayEvents.isNonWorking,
        dayNameContent = me.callback(me.dayCellRenderer, me, [dayEvents, domConfig]);
      // If renderer changed the cls or style properties, propagate the values back into place
      if (typeof dayEvents.cls == 'string') {
        domConfig.className = new DomClassList(dayEvents.cls);
      }
      if (typeof dayEvents.style === 'string') {
        domConfig.style = DomHelper.parseStyle(dayEvents.style);
      }
      if (typeof dayEvents.headerCls == 'string') {
        cellHeader.className = new DomClassList(dayEvents.headerCls);
      }
      if (typeof dayEvents.headerStyle === 'string') {
        cellHeader.style = DomHelper.parseStyle(dayEvents.headerStyle);
      }
      if (dayNameContent != null) {
        if (typeof dayNameContent === 'string') {
          dayName.html = dayNameContent;
        }
        // Assuming Object or Object Array.
        else {
          dayName.text = null;
          dayName.children = ArrayHelper.asArray(dayNameContent);
        }
      }
      dynamicallySetToNonWorking = !wasNonWorking && dayEvents.isNonWorking;
    }
    if (dayName) {
      // If there was no renderer, use the date as the textContent
      if (!(dayName.text || dayName.html)) {
        dayName.text = me.dayCellNameFormat ? DateHelper.format(date, me.dayCellNameFormat) : dayNumber;
      }
      // If all there is in there is the date, give it the day number CSS rendition
      // This makes it a 2emX2em circular element.
      if ((dayName.text || dayName.html) == dayNumber) {
        dayName.className['b-day-num'] = true;
      }
    }
    // If there's a cell entry which is visible (within this month and not a hidden nonworking day)
    // then we add the child entries to the eventContainer's children array.
    if (dayEvents.visible) {
      const {
          hasOverflow,
          renderedEvents,
          maxRow
        } = dayEvents,
        events = renderedEvents,
        {
          length
        } = events,
        children = eventContainer.children;
      // Sync the non working day CSS class.
      // But if a dayCellRenderer changed isNonWorking to true, the cell must remain
      // visible in certain views, to maintain cell arrangement, so add extra CSS class
      // to enable views to override the rule from Core/calendarpanel.scss.
      domConfig.className[me.nonWorkingDayCls] = dayEvents.isNonWorking;
      domConfig.className[me.dynamicHideNonWorkingdayCls] = dynamicallySetToNonWorking;
      domConfig.className[me.weekendCls] = DateHelper.weekends[day];
      for (let i = 0, eventRow = 0; i < maxRow; i++, eventRow++) {
        const renderedEvent = events[i];
        // If the slot is occupied, add a child event element.
        // The event's .b-cal-event-wrap is position:absolute, so its offsetParent is the closest
        // position:relative element which is the .b-calendar-days row.
        // This is so that the events can use %age widths and need no intervention
        // for width changes. The left position is the .b-cal-event-bar-container's left.
        // Only height changes which result in a change to this.eventsPerCell require
        // a refresh.
        if (renderedEvent) {
          const {
              eventRecord,
              isOverflow,
              propagateEndDate
            } = renderedEvent,
            eventEndDate = renderedEvent.eventEndDate || eventRecord.endingDate,
            renderedDaySpan = me.getDaySpan(date, propagateEndDate || eventEndDate, dayTime),
            daySpan = me.getDaySpan(date, eventEndDate, dayTime, true),
            remainingColumns = weekLength - visibleColumnIndex,
            isHiddenOverflow = visibleColumnIndex && isOverflow,
            width = DomHelper.percentify(ObjectHelper.round((isHiddenOverflow ? 1 : Math.min(renderedDaySpan, remainingColumns)) / weekLength * 100, 4)),
            eventDomConfig = me.createEventDomConfig(renderedEvent);
          Object.assign(eventDomConfig.style, {
            width,
            top: `${eventRow * eventHeightInPixels + eventRow * eventSpacing + me.eventContainerTop}px`
          });
          Object.assign(eventDomConfig.className, {
            // If flowing in from a previous cell
            'b-overflow': isHiddenOverflow,
            // We're in the first cell, and it was from a previous week
            'b-continues-past': !isHiddenOverflow && (!visibleColumnIndex || isFirstVisibleCell) && eventRecord.startDate < date,
            // The event ends in a future week
            'b-continues-future': !isHiddenOverflow && (daySpan > remainingColumns || daySpan > renderedDaySpan)
          });
          children.push(eventDomConfig);
        }
      }
      // The cell was found to need an overflow link by propagateCellEvents.
      // This could be because it has more renderedEvents than me.eventsPerCell
      // Or it could be because its last visible event flowed forwards into a cell
      // whose own events only *filled*
      if (hasOverflow) {
        row.classList.add('b-has-overflow');
        domConfig.children.push(me.getOverflowButtonDomConfig(length - Math.max(0, maxRow)));
      } else if (!columnIndex) {
        row.classList.remove('b-has-overflow');
      }
      // Flag the event container element as empty if necessary
      const emptyCell = domConfig.className[me.emptyCellCls] = !events.length;
      if (emptyCell && emptyCellRenderer) {
        const rType = typeof emptyCellRenderer,
          rCallback = rType === 'function' || rType === 'string' ? me.resolveCallback(emptyCellRenderer, me, false) : null,
          noEvents = rCallback !== null && rCallback !== void 0 && rCallback.handler ? rCallback.handler.call(rCallback.thisObj, dayEvents) : emptyCellRenderer;
        // By default, a single line no events button will appear similar to
        // a "+n more" overflow button. It will be the size and shape of an event pill.
        if (noEvents) {
          eventContainer.children[0] = {
            tag: 'button',
            class: 'b-cal-cell-no-content',
            children: [rCallback !== null && rCallback !== void 0 && rCallback.handler ? rCallback.handler.call(rCallback.thisObj, dayEvents) : emptyCellRenderer]
          };
        }
      }
    }
    return domConfig;
  }
  onCalendarPointerInteraction(domEvent) {
    const me = this,
      {
        target
      } = domEvent;
    // Broadcast a click on content in an empty cell.
    if (target.closest(`.${me.emptyCellCls} .${me.eventBarContainerCls}`)) {
      // If they have an emptyCellRenderer, then that must be the click target
      if (!me.emptyCellRenderer || target.closest('.b-cal-cell-no-content')) {
        /**
         * Fired when an empty cell content area is clicked on. If the handler returns
         * `false` the current pointer event is not processed further.
         * @event emptyCellClick
         * @param {Event} domEvent The triggering DOM event.
         * @param {Date} date The date which has no visible events
         */
        if (me.trigger(`emptyCell${eventNameMap[domEvent.type]}`, {
          date: me.getDateFromDomEvent(domEvent),
          domEvent
        }) === false) {
          return false;
        }
      }
    }
    return super.onCalendarPointerInteraction(domEvent);
  }
  getDaySpan(startDate, endDate, dayTime, ignoreNonWorkingDays) {
    if (this.hideNonWorkingDays && !ignoreNonWorkingDays) {
      let result = 0;
      for (const date = new Date(startDate), spanEnd = dayTime.ceil(endDate, '1 day'); date < spanEnd; date.setDate(date.getDate() + 1)) {
        if (!this.nonWorkingDays[date.getDay()]) {
          result++;
        }
      }
      return result;
    } else {
      return Math.max(DateHelper.diff(startDate, dayTime.ceil(endDate, '1 day'), 'day'), 1);
    }
  }
  getOverflowButtonDomConfig(overflowCount) {
    const {
        overflowButtonRenderer
      } = this,
      domConfig = {
        tag: 'button',
        className: {
          'b-cal-cell-overflow': 1
        },
        text: this.L('L{Calendar.plusMore}', overflowCount),
        style: {
          lineHeight: `${this.eventHeightInPixels}px`,
          marginBottom: `${this.eventSpacing}px`
        },
        dataset: {
          eventId: 'overflow'
        }
      };
    return overflowButtonRenderer ? this.callback(overflowButtonRenderer, this, [domConfig, overflowCount]) : domConfig;
  }
  getCell(date) {
    if (typeof date !== 'string') {
      date = this.dayTime.dateKey(date);
    }
    return this.contentElement.querySelector(`[data-date="${date}"]`);
  }
  getCellOverflowButton(date) {
    var _this$getCell;
    return (_this$getCell = this.getCell(date)) === null || _this$getCell === void 0 ? void 0 : _this$getCell.querySelector('.b-cal-cell-overflow');
  }
});

/**
 * @module Calendar/widget/mixin/DateRangeOwner
 */
const validRangeUnits = {
    day: 1,
    week: 1,
    month: 1,
    year: 1,
    decade: 1
  },
  compareRange = (r1, r2) => (r1 === null || r1 === void 0 ? void 0 : r1.unit) === (r2 === null || r2 === void 0 ? void 0 : r2.unit) && (r1 === null || r1 === void 0 ? void 0 : r1.magnitude) === (r2 === null || r2 === void 0 ? void 0 : r2.magnitude);
/**
 * Mixin that provides the ability to collect encapsulate a range of dates specified by a
 * {@link #config-startDate} and a {@link #config-range}.
 *
 * @mixin
 */
var DateRangeOwner = (Target => {
  var _class;
  return _class = class DateRangeOwner extends (Target || Base) {
    /**
     * Interface method used by an encapsulating Calendar view to implement the "prev" button.
     */
    previous() {
      const {
        range
      } = this;
      this.date = range ? DateHelper.add(this.date, -range.magnitude, range.unit) : DateHelper.add(this.date, -this.duration, 'day');
    }
    /**
     * Interface method used by an encapsulating Calendar view to implement the "next" button.
     */
    next() {
      const {
        range
      } = this;
      this.date = range ? DateHelper.add(this.date, range.magnitude, range.unit) : DateHelper.add(this.date, this.duration, 'day');
    }
    changeDate(date) {
      date = super.changeDate(date || this.startDate);
      if (this.isConfiguring || this.isValidRange(this.range, date)) {
        return date;
      }
    }
    updateDate(date) {
      var _super$updateDate;
      const me = this,
        {
          startDate,
          endDate,
          _month
        } = me,
        newStartDate = me.changeStartDate(date),
        generation = _month === null || _month === void 0 ? void 0 : _month.generation;
      // Move range so that it encapsulates the target date if necessary
      if (!startDate || newStartDate - startDate) {
        // Having an endDate configured takes precedence over a range.
        // Shift the range forward or back so that the target date is in
        if (me.hasConfig('endDate')) {
          const duration = DateHelper.diff(startDate, endDate, 'd');
          // Need to scroll left
          if (!startDate || !endDate || date < startDate) {
            me.startDate = date;
          }
          // Need to scroll right
          else if (date >= endDate) {
            me.startDate = DateHelper.add(date, -(duration - 1), 'day');
          }
        }
        // If there's no endDate, we MUST be configured with a range, so snap
        // the date to the closest range start.
        else {
          me.startDate = DateHelper.floor(date, me.range, undefined, me.weekStartDay);
        }
      }
      // If we have not already updated our month by setting startDate above
      // then update the month now.
      // We must only update it once because we react to month mutation to refresh the UI.
      if (_month && _month.generation === generation) {
        me._month.date = date;
      }
      (_super$updateDate = super.updateDate) === null || _super$updateDate === void 0 ? void 0 : _super$updateDate.call(this, ...arguments);
    }
    changeStartDate(startDate, oldStartDate) {
      return super.changeStartDate(this.snapDate(this.ingestDate(startDate)), oldStartDate);
    }
    updateStartDate(startDate, oldStartDate) {
      var _super$updateStartDat;
      const me = this,
        {
          refreshCount,
          _month
        } = me;
      if (!me.date) {
        me.date = startDate;
      }
      if (_month) {
        _month.date = startDate;
      }
      // Some views inherit startDate
      (_super$updateStartDat = super.updateStartDate) === null || _super$updateStartDat === void 0 ? void 0 : _super$updateStartDat.call(this, ...arguments);
      // If we are bounded by an endDate configuration, keep that synced.
      if (me.hasConfig('endDate')) {
        const duration = DateHelper.diff(oldStartDate || startDate, me.endDate, 'day');
        me.endDate = DateHelper.add(startDate, duration, 'day');
      }
      if (!me.isConfiguring) {
        // If that changed the end date, the updater will have done a refresh.
        // If there was no change to the endDate, so no refresh, we have to refresh here.
        if (me.refreshCount === refreshCount) {
          var _me$_cellMap;
          (_me$_cellMap = me._cellMap) === null || _me$_cellMap === void 0 ? void 0 : _me$_cellMap.clear();
          me.refresh();
        }
      }
    }
    changeEndDate(endDate, oldEndDate) {
      return super.changeEndDate(this.snapDate(this.ingestDate(endDate), true), oldEndDate);
    }
    get range() {
      return this.hasConfig('endDate') ? null : this._range;
    }
    get endDate() {
      return this.hasConfig('endDate') ? this._endDate : this.startDate && DateHelper.add(this.startDate, this.range.magnitude, this.range.unit);
    }
    // Snap the passed date to the start or end of our configured range block if we have one.
    snapDate(date, end) {
      const range = this.hasConfig('endDate') ? null : this.range;
      // If we have been configured with a range which needs snapping, snap the date to the required end
      return range && range.unit !== 'day' && date ? DateHelper[end ? 'ceil' : 'floor'](date, range, undefined, this.weekStartDay) : date;
    }
    changeRange(range) {
      if (range) {
        // '1d' or '1 day' or '4 weeks', '1' etc.
        // We parse to an object.
        if (typeof range === 'string') {
          if (DateHelper.parseTimeUnit(range)) {
            range = {
              magnitude: 1,
              unit: range
            };
          } else {
            range = DateHelper.parseDuration(range);
          }
        } else if (typeof range === 'number') {
          return {
            magnitude: range,
            unit: 'day'
          };
        }
        // range : '100ms' would be invalid.
        if (!validRangeUnits[range.unit]) {
          throw new Error('Range must be in days, weeks, months, years or decades');
        }
        // Veto invalid navigation
        if (this._date && !this.isValidRange(range)) {
          return;
        }
      }
      return range;
    }
    isValidRange(range, date = this.date) {
      var _this$calendar, _this$calendar2;
      const minDate = this.minDate || ((_this$calendar = this.calendar) === null || _this$calendar === void 0 ? void 0 : _this$calendar.minDate),
        maxDate = this.maxDate || ((_this$calendar2 = this.calendar) === null || _this$calendar2 === void 0 ? void 0 : _this$calendar2.maxDate);
      // Only do date arithmetic if we need to.
      if (range && !isNaN(minDate) || !isNaN(maxDate)) {
        const newRange = this.calculateDateRange(range, date);
        if (!isNaN(minDate)) {
          // Veto navigation to before minDate.
          if (newRange.startDate < minDate) {
            return false;
          }
        }
        if (!isNaN(maxDate)) {
          // Veto navigation to after maxDate.
          if (newRange.endDate > maxDate) {
            return false;
          }
        }
      }
      return true;
    }
    updateRange(range) {
      const me = this,
        {
          date
        } = me;
      // Change the start and end dates depending on the range size around the current date
      if (range && date && !me.hasConfig('endDate')) {
        // If we have a range, then endDate is derived
        me.startDate = date;
      }
    }
    calculateDateRange(range, date) {
      // Calculate the start and end dates depending on the range size around the requested date
      if (date) {
        // Only snap for units with definite start points
        if (range.unit !== 'day') {
          return {
            startDate: DateHelper.floor(date, range, undefined, this.weekStartDay),
            endDate: DateHelper.ceil(DateHelper.add(date, 1, 'day'), range, undefined, this.weekStartDay)
          };
        }
        return {
          startDate: date,
          endDate: DateHelper.add(date, range.magnitude, 'day')
        };
      }
    }
    changeMonth(month) {
      var _month2;
      const me = this,
        {
          date
        } = me;
      // MonthView, based on CalendarPanel has its own opinions
      if (super.changeMonth) {
        return super.changeMonth(...arguments);
      }
      if (!((_month2 = month) !== null && _month2 !== void 0 && _month2.isMonth)) {
        month = new Month({
          date,
          weekStartDay: me.weekStartDay,
          hideNonWorkingDays: me.hideNonWorkingDays,
          nonWorkingDays: me.nonWorkingDays
        });
        if (me.nonWorkingDays == null) {
          me.nonWorkingDays = month.nonWorkingDays;
        }
        if (me.weekStartDay == null) {
          me.weekStartDay = month.weekStartDay;
        }
      }
      return month;
    }
    /**
     * Returns the range of included dates in the range as a two-element array, i.e., `[0]` is {@link #config-startDate}
     * and `[1]` is {@link #property-lastDate}.
     * @member {Date[]}
     * @internal
     */
    get dateBounds() {
      return [this.startDate, this.lastDate];
    }
    get duration() {
      const {
        range
      } = this;
      return range ? DateHelper.as('d', range.magnitude, range.unit) : super.duration;
    }
    /**
     * The last day that is included in the date range. This is different than {@link #config-endDate} since that date
     * is not inclusive. For example, an `endDate` of 2022-07-21 00:00:00 indicates that the time range ends at that
     * time, and so 2022-07-21 is _not_ in the range. In this example, `lastDate` would be 2022-07-20 since that is the
     * last day included in the range.
     * @member {Date}
     * @internal
     */
    get lastDate() {
      const lastDate = this.endDate;
      // endDate is "exclusive" because it means 00:00:00 of that day, so subtract 1
      // to keep description consistent with human expectations.
      return lastDate && DateHelper.add(lastDate, -1, 'day');
    }
  }, _defineProperty(_class, "$name", 'DateRangeOwner'), _defineProperty(_class, "configurable", {
    month: true,
    /**
     * Setting this property may change the encapsulated range if the date is outside the current
     * range.
     *
     * It also causes this view to scroll the view to the passed date, or closest date.
     * See {@link Calendar.widget.mixin.CalendarMixin#function-scrollTo}
     * @member {Date} date
     */
    /**
     * The date to orient this view's {@link #config-range} around.
     *
     * When using a {@link #config-range} of weeks, months, years or decades, the {@link #config-startDate} snaps
     * to the closest lower range boundary, and the end date snaps to the closest larger
     * range boundary.
     *
     * When using a {@link #config-range} of days, the {@link #config-startDate} is set to the passed date.
     * @config {Date}
     */
    date: {
      $config: {
        equal: 'date'
      },
      value: null
    },
    /**
     * The time range encapsulated by the current {@link #property-date}.
     *
     * When a range is used, changing the {@link #config-date} snaps the {@link #config-startDate}
     * to the closest starting date of the range. For Example if the range was configured as `'1 week'`
     * then setting the date to the date of next Wednesday would mean that the {@link #property-startDate}
     * would be the __start__ of next week, and an entire week would be encapsulated by this view.
     * @member {Object} range
     */
    /**
     * The time range around the {@link #config-date} to display events for.
     *
     * Valid values are:
     * - day
     * - week
     * - month
     * - year
     * - decade
     *
     * This may also be specified as a duration with a magnitude part and a unit part. For
     * example `'1m'` would mean one month, and `'4w'` would mean four weeks.
     * See {@link Core.helper.DateHelper#function-parseDuration-static} for details
     * of syntax.
     *
     * When using a range of weeks, months, years or decades, then when this widget's
     * {@link #config-date} is synced with its owning {@link Calendar.view.Calendar}'s
     * {@link Calendar.view.Calendar#property-date}, this widget's {@link #config-startDate}
     * is snapped to the closest start point of the range which encompasses that date.
     *
     * So if using `range : '1w'`, then setting the date to Thursday, 28th October 2021
     * Would mean that the `startDate` snaps to Sunday 24th October 2021 (assuming the locale
     * uses Sunday as the week start day).
     *
     * If configured to use a range of *days*, no snapping is done. There's no defined start point
     * so the {@link #config-startDate} is set to the incoming Calendar date.
     *
     * __Note:__ If an {@link #config-endDate} is specified, any range is ignored. The encompassed range
     * will be specified by the {@link #config-startDate} and {@link #config-endDate}, and when the
     * {@link #config-startDate} changes, the {@link #config-endDate} is changed to keep the duration
     * the same.
     * @config {String|Object}
     */
    range: {
      $config: {
        lazy: true,
        equal: compareRange
      },
      value: null
    },
    /**
     * Gets the start date of the {@link #config-range} that this view covers.
     * @member {Date} startDate
     * @readonly
     */
    /**
     * The start date (Time component is zeroed) of this view.
     * @config {Date}
     */
    startDate: {
      $config: {
        equal: 'date'
      }
    },
    /**
     * Gets the end date of the {@link #config-range} that this view covers.
     * Note that Date objects are time points, not a representation of a 24 hour period,
     * So `{startDate : '2020-10-24', endDate : '2020-10-25' }` spans the __single__ day
     * 24th October 2020. The end point is `2020-10-25T00:00:00`
     * @member {Date} endDate
     * @readonly
     */
    /**
     * The end date (Time component is zeroed) of this view. Note that in terms of full days,
     * this is exclusive, ie: 2020-01-012 to 2020-01-08 is *seven* days. The end is 00:00:00 on
     * the 8th.
     *
     * __Note:__ This configuration takes precedence over any {@link #config-range} specified.
     * If used, the {@link #config-range} is ignored, and after configuration, the `endDate` is
     * locked to the {@link #config-startDate} when the {@link #config-startDate} is changed.
     * @config {Date}
     */
    endDate: {
      $config: {
        equal: 'date'
      }
    }
  }), _class;
});

/**
 * @module Calendar/widget/CalendarRow
 */
const emptyObject = Object.freeze({}),
  expandGestures$1 = {
    shrinkwrap: 1,
    expand: 1
  },
  formatDayPart = (format, sep, d1, d2, compress) => {
    const s1 = DateHelper.format(d1, format);
    return d2 ? `${s1}${compress ? sep.trim() : sep}${DateHelper.format(d2, format).slice(compress ? -1 : 0)}` : s1;
  };
/**
 * This is normally used as the "All day events" section of a {@link Calendar.widget.DayView} or
 * {@link Calendar.widget.WeekView}. But it may be used standalone as a regular Widget.
 *
 * As a standalone widget, it will lack the capabilities of the {@link Calendar.view.Calendar Calendar}
 * class, such as keyboard-based event to event navigation and drag/drop features.
 *
 * A Widget which displays a single row of calendar cells for a configured range of dates.
 *
 * Cell rendering can be customized using the {@link #config-dayCellRenderer} method.
 *
 * Event rendering can be customized using the {@link #config-eventRenderer} method.
 *
 * @extends Core/widget/Widget
 * @mixes Core/widget/mixin/Responsive
 * @mixes Calendar/widget/mixin/DayCellRenderer
 * @mixes Calendar/widget/mixin/CalendarMixin
 * @mixes Calendar/widget/mixin/DateRangeOwner
 * @classType calendarrow
 */
class CalendarRow extends Widget.mixin(CalendarMixin, DayCellCollecter, DayCellRenderer, DateRangeOwner) {
  constructor(...args) {
    super(...args);
    /**
     * A Promise which will be in _Pending_ state only when the `minHeight` is animating to a new value.
     * @property {Promise}
     */
    _defineProperty(this, "heightAnimation", Promise.resolve);
  }
  static get $name() {
    return 'CalendarRow';
  }
  // Factoryable type name
  static get type() {
    return 'calendarrow';
  }
  static get configurable() {
    return {
      // region Hidden configs
      /**
       * @config dayCellRenderer
       * @hide
       */
      // endRegion
      cls: 'b-calendar-days',
      /**
       * Set this to `false` to not use transition for this Widget as it changes height
       *
       * @config {Boolean}
       * @default
       */
      animate: true,
      /**
       * By default, this widget displays a maximum of {@link #config-defaultEventRowCount} events
       * before showing overflow indicators, and becoming {@link #function-toggleExpandCollapse expandable}.
       *
       * Configuring this as `true` makes this widget accommodate all events with no overflow.
       * @config {Boolean}
       */
      autoHeight: null,
      autoRefresh: ['dayNameFormat', 'dayNumberCompress', 'dayNumberFormat', 'daySeparator'],
      descriptionFormat: [true, true],
      /**
       * Either the start hour of the day, or a *24 hour* `HH:MM` string denoting the start of the first rendered
       * daily time block.
       *
       * @config {String|Number}
       * @default 0
       */
      dayStartShift: null,
      dayTime: 0,
      /**
       * The number of events to show to define the height of this widget by default if this widget
       * {@link #config-autoHeight} is *not* defined as `true`. The widget may be expanded to accommodate all
       * the events if there are overflowing events.
       * @config {Number}
       * @default
       */
      defaultEventRowCount: 3,
      /**
       * When `true`, a full week of dates is rendered for a single day range. This should not be applied when
       * the `duration` spans multiple days.
       * @config {Boolean}
       * @internal
       */
      fullWeek: null,
      /**
       * By default, the day columns flex to all fit within the width of this widget.
       *
       * configuring a `minDayWidth` means that if the day columns do not fit within this
       * widget's width, it becomes horizontally scrollable.
       * @config {Number}
       */
      minDayWidth: null,
      scrollable: {
        overflowX: 'hidden',
        overflowY: 'hidden'
      },
      headerScroller: {
        $config: ['lazy', 'nullify'],
        value: {
          overflowX: 'hidden',
          overflowY: 'hidden'
        }
      },
      /**
       * The {@link Core.helper.DateHelper} format string for day names (e.g., "ddd" for "Mon", "Tue", ...)
       * @config {String}
       * @default
       */
      dayNameFormat: 'ddd',
      /**
       * Specify `true` to textually compress day number pairs. For example, compress "11/12" to "11/2". Also
       * when `true`, the {@link #config-daySeparator} is trimmed of any whitespace.
       * @config {Boolean}
       * @default false
       */
      dayNumberCompress: null,
      /**
       * The {@link Core.helper.DateHelper} format string for day numbers (e.g., "D" for "9", "10", ...)
       * @config {String}
       * @default
       */
      dayNumberFormat: 'D',
      /**
       * The separator between day names and numbers. If a single string is provided, it applies to both day
       * names and day numbers. If an array of 2 strings is provided, the [0] element is the separator for day
       * names and [1] element is the separator for day numbers.
       * @config {String|String[]}
       */
      daySeparator: '-',
      responsive: {
        small: {
          // dayNameFormat     : 'd1/d1',
          // dayNumberFormat   : 'D/D',
          dayNameFormat: 'd1',
          dayNumberCompress: true,
          daySeparator: '/'
        },
        '*': {
          // dayNameFormat     : 'ddd-ddd',
          // dayNumberFormat   : 'D-D',
          dayNameFormat: 'ddd',
          dayNumberCompress: false,
          daySeparator: '-'
        }
      },
      dayNameSelector: '.b-cal-cell-header',
      // We are in control of our size. Once we can calculate our maxEventCount, then from
      // that and the eventContainerTop and the defaultEventRowCount and the autoHeight and
      // expanded settings we calculate our height.
      // We have to have been through one initial refresh cycle to measure eventContainerTop
      // which is handled in onPaint.
      monitorResize: false,
      /**
       * An empty function by default, but provided so that you can override it.
       *
       * This function is called each time an event is rendered to allow developers to mutate
       * the cell metadata, or the CSS classes to be applied to the event element.
       *
       * It's called with the event record, and a eventData object which allows you to mutate event metadata
       * such as 'cls', 'style'.
       *
       * The cls property is an object whose property names will be added to the event element if the property value is truthy.
       *
       * The style property is an object containing style properties for the event element.
       *
       * A non-null return value from the renderer is used as the event body content. A nullish
       * return value causes the default renderer to be used which just uses the event name.
       *
       * ```javascript
       *  eventRenderer({ eventRecord, eventData }) {
       *      if (eventRecord.name === 'Doctors appointment') {
       *          eventData.style.fontWeight = 'bold';
       *          eventData.cls['custom-cls'] = 1;
       *
       *          return 'Special doctors appointment';
       *      }
       *  }
       * ```
       * IMPORTANT: When returning content, be sure to consider how that content should be encoded to avoid XSS
       * (Cross-Site Scripting) attacks. This is especially important when including user-controlled data such as
       * the event's `name`. The function {@link Core.helper.StringHelper#function-encodeHtml-static} as well as
       * {@link Core.helper.StringHelper#function-xss-static} can be helpful in these cases.
       *
       * For example:
       * ```javascript
       *  eventRenderer({ eventRecord, eventData }) {
       *      return StringHelper.xss`Event: ${eventRecord.name}`;
       *  }
       * ```
       * @config {Function} eventRenderer
       * @param {Object} detail An object that contains data about the event being rendered.
       * @param {Scheduler.model.EventModel} detail.eventRecord The event record
       * @param {Scheduler.model.ResourceModel} detail.resourceRecord The event record
       * @param {Object} detail.renderData A data object containing properties that will be used to create the event element.
       * @param {Object} detail.renderData.style The style property is an object containing style properties for
       * the event element.
       * @param {Object} detail.renderData.cls The cls property is an object whose property names will be added to
       * the event element if the property value is truthy.
       * @param {String} detail.renderData.eventColor Color to be applied to the event
       */
      eventRenderer: null,
      /**
       * How much extra space in pixels or other DOM units to allow below the event bars to
       * facilitate drag-create gestures.
       * @config {Number|String}
       * @default
       */
      gutterHeight: null,
      expanded: null,
      /**
       * How the view responds to clicking on a `+n more` button in an overflowing day cell.
       *
       * The default value, `'popup'`, means that a small dialog box showing the full complement
       * of events for that cell is shown aligned to the cell.
       *
       * When set to `'expand'`, then clicking the `+n more` button causes the encapsulating
       * row to expand to accommodate all events in that row with no overflow.
       *
       * Navigating to a new month resets the row to its default, flexed height.
       * @config {'popup'|'expand'} overflowClickAction
       * @default
       */
      overflowClickAction: 'popup',
      /**
       * A function, or name of a function which is passed the {@link DomConfig} object which
       * will be used to sync with a day cell header.
       *
       * ```javascript
       * dayHeaderRenderer : function(headerDomConfig, cellData) {
       *     if (this.isSpecialDate(cellData.date)) {
       *         headerDomConfig.className['b-is-special-date'] = 1;
       *
       *         // Add to the content element's children
       *         headerDomConfig.children.push({
       *             text : 'Special day',
       *             className : 'b-special-day
       *         });
       *     }
       * }
       *```
       *
       * The result is used to sync the DOM of the day column.
       *
       * @config {Function|String} dayHeaderRenderer
       * @param {DomConfig} headerDomConfig A {@link DomConfig} config object which is used to sync the day header element.
       * @param {Object} headerDomConfig.className An object who's truthy property names will be applied as class names.
       * @param {Object} headerDomConfig.style A CSS style definition object.
       * @param {Object} headerDomConfig.dataset The DOM data properties to set.
       * @param {DomConfig[]} headerDomConfig.children The {@link DomConfig} definitions the header content.
       * There will be 2 `children` encapsulating the day name and the date.
       * @param {DayCell} cellData An object that contains data about the cell.
       */
      dayHeaderRenderer: null
    };
  }
  compose() {
    return {
      children: {
        headerElement: {
          className: 'b-calendarrow-header',
          children: {
            headerCellContainer: {
              className: 'b-calendarrow-header-container'
            },
            scrollPadElement: _objectSpread2({}, DomHelper.scrollBarPadElement)
          }
        },
        bodyElement: {
          className: 'b-calendarrow-body',
          children: {
            cellContainer: {
              reference: 'cellContainer',
              className: 'b-calendarrow-cell-container'
            }
          }
        }
      }
    };
  }
  onPaint({
    firstPaint
  }) {
    // On first paint, create measurable elements, the refresh measures and caches uninitialized
    // heights, so delete the cached values so that they get measured again
    if (firstPaint) {
      const me = this,
        {
          fonts
        } = document,
        onFirstPaint = () => {
          // In case we are arriving here after the font load. Need to remeasure
          // elements that are sized by text.
          me._eventContainerTop = me._eventContainerHeight = null;
          if (me.eventStore.count) {
            me.performResizeRefresh(null, null, true);
          }
        };
      // If the API is available, we need to remeasure when fonts become ready
      if ((fonts === null || fonts === void 0 ? void 0 : fonts.status) !== 'loaded') {
        fonts.ready.then(() => !me.isDestroyed && onFirstPaint());
      }
      onFirstPaint();
    }
  }
  changeDaySeparator(daySeparator) {
    return Array.isArray(daySeparator) ? daySeparator : [daySeparator, daySeparator];
  }
  changeElement() {
    const result = super.changeElement(...arguments);
    // Ensure header scroller is in sync in the X axis with the main scroller
    this.scrollable.addPartner(this.headerScroller, 'x');
    return result;
  }
  changeHeaderScroller(headerScroller, oldHeaderScroller) {
    if (headerScroller) {
      headerScroller = Scroller.new({
        element: this.headerCellContainer,
        widget: this
      }, headerScroller);
    } else {
      oldHeaderScroller === null || oldHeaderScroller === void 0 ? void 0 : oldHeaderScroller.destroy();
    }
    return headerScroller;
  }
  /**
   * Brings an event or a time into view.
   * @param {Scheduler.model.EventModel|Date|Number} target The event to scroll to or
   * a `Date` to read the hour value from, or an hour number.
   * @param {ScrollOptions} [options] How to scroll.
   * @returns {Promise} A promise which is resolved when the target has been scrolled into view.
   */
  async scrollTo(target) {
    const me = this,
      {
        eventFilter
      } = me;
    // If it's an event and filtered in, and intersects our date range, but we don't have an element
    // for it, then it must be because we are collapsed. Expand so it is rendered.
    if (target.isEvent && (!eventFilter || eventFilter(target)) && DateHelper.intersectSpans(me.startDate, me.endDate, target.startDate, target.endDate)) {
      if (!me.getEventElement(target)) {
        if (!(me.expanded || me.autoHeight)) {
          me.toggleExpandCollapse();
        }
      }
    }
    return super.scrollTo(...arguments);
  }
  updateDate(date, oldDate) {
    var _el, _super$updateDate, _el2;
    const me = this;
    let el = oldDate && me.getDayHeader(oldDate);
    (_el = el) === null || _el === void 0 ? void 0 : _el.classList.remove('b-selected-date');
    // Base class may move our range if new date is outside of current range.
    (_super$updateDate = super.updateDate) === null || _super$updateDate === void 0 ? void 0 : _super$updateDate.call(this, date, oldDate);
    el = date && me.getDayHeader(date);
    (_el2 = el) === null || _el2 === void 0 ? void 0 : _el2.classList.add('b-selected-date');
  }
  getDayHeader(date) {
    if (typeof date !== 'string') {
      date = this.dateKey(date);
    }
    return this.headerCellContainer.querySelector(`.b-cal-cell-header[data-header-date="${date}"]`);
  }
  get overflowElement() {
    return this.bodyElement;
  }
  createCellMap(getEventsOptions = {}) {
    const me = this,
      hiddenDays = me.hideNonWorkingDays ? me.nonWorkingDays : emptyObject,
      {
        maxEventCount
      } = me,
      options = ObjectHelper.assign({
        dayTime: me.dayTime
      }, getEventsOptions),
      cellMap = super.createCellMap(options);
    let newMaxEventCount = 0,
      lastVisibleCellData;
    cellMap.forEach(cellData => {
      if (!hiddenDays[cellData.day]) {
        lastVisibleCellData = cellData;
      }
      newMaxEventCount = Math.max(newMaxEventCount, cellData.renderedEvents.length);
    });
    me.maxEventCount = newMaxEventCount;
    // If we changed maxEventCount, recreate the data
    if (newMaxEventCount !== maxEventCount) {
      cellMap.clear();
      return me.createCellMap(options);
    }
    // Have to set this on the last cellData entry which is visible
    lastVisibleCellData && (lastVisibleCellData.isRowEnd = true);
    return cellMap;
  }
  collectEvents(options) {
    // Only the first cell needs overflows flowing into it.
    // from after that, propagateCellEvents copies events forward
    options = ObjectHelper.assign({
      dayTime: this.dayTime
    }, options, {
      // Only the first *visible* cell needs overflows flowing into it.
      // from after that, propagateCellEvents copies events forward, so
      // the getEvents will use the "startDate" index to extract events for a date.
      getDateIndex: date => date > (this.firstVisibleDate || this.startDate) ? 'startDate' : 'date'
    });
    return this.eventStore.getEvents(options);
  }
  createCellData(date) {
    const me = this,
      columnIndex = DateHelper.diff(me.startDate, date, 'day'),
      visibleColumnIndex = columnIndex;
    return Object.assign(me.cellMonth.getCellData(date, me.month, me.dayTime), {
      visibleColumnIndex,
      columnIndex,
      isRowStart: visibleColumnIndex === 0,
      isRowEnd: false,
      // Events can forward-occupy slots if they
      // overrun their start day.
      // So the next step is to propagate forward
      // multi day events into future cells they cover.
      renderedEvents: new EventSlots()
    });
  }
  get dayStartShift() {
    var _this$dayTime$startSh, _this$dayTime;
    return (_this$dayTime$startSh = (_this$dayTime = this.dayTime) === null || _this$dayTime === void 0 ? void 0 : _this$dayTime.startShift) !== null && _this$dayTime$startSh !== void 0 ? _this$dayTime$startSh : this._dayStartShift;
  }
  updateDayStartShift(dayStartShift) {
    // Day number circle needs to be oval to accommodate 00-00
    this.element.classList.toggle('b-shifted-day', Boolean(dayStartShift));
    this.dayTime = new DayTime(dayStartShift);
  }
  changeDayTime(dayTime) {
    var _this$_dayTime;
    if (!dayTime) {
      dayTime = new DayTime(this.dayStartShift);
    }
    // Allow DayTime config object to be passed
    if (!dayTime.isDayTime) {
      dayTime = new DayTime(dayTime);
    }
    if (!((_this$_dayTime = this._dayTime) !== null && _this$_dayTime !== void 0 && _this$_dayTime.equals(dayTime))) {
      return dayTime;
    }
  }
  dayOfDate(date) {
    return this.dayTime.dayOfDate(date);
  }
  updateMinDayWidth(minDayWidth) {
    const {
        scrollable,
        headerScroller
      } = this,
      {
        element
      } = scrollable;
    // Need min-width : 0 to allow the element to shrink
    this.contentElement.style.setProperty('--min-day-width', minDayWidth ? DomHelper.setLength(minDayWidth) : 0);
    // Forced synchronous layout here, but we need to ascertain horizontal overflow state
    if (minDayWidth && element.scrollWidth > element.clientWidth) {
      // Overflow 'hidden-scroll' is a special Scroller setting.
      // With overlayed scrollbars it just means 'auto'
      // With space-consuming scrollbars, it hides scrollbars using CSS while using auto.
      // But if the two axes scroll, then both scrollbars should not be hidden so it will
      // fall back to using overflow:hidden and a `wheel` listener.
      scrollable.overflowX = headerScroller.overflowX = 'hidden-scroll';
    } else {
      scrollable.overflowX = headerScroller.overflowX = false;
    }
  }
  updateEventHeight() {
    // CalendarMixin needs to know first
    super.updateEventHeight(...arguments);
    if (!this.autoHeight && !this.isConfiguring && !this.expanded) {
      this.setEventContentHeight(this.cellContentHeight);
    }
  }
  updateGutterHeight() {
    if (!this.isConfiguring) {
      this.setEventContentHeight(this.cellContentHeight);
    }
  }
  get stepUnit() {
    return this.duration > 1 ? `${this.duration} ${this.L('L{DayView.daysUnit}')}` : this.L('L{DayView.dayUnit}');
  }
  updateNonWorkingDays() {
    this.onVisibleDateRangeChange();
  }
  updateHideNonWorkingDays() {
    super.updateHideNonWorkingDays(...arguments);
    this.onVisibleDateRangeChange();
  }
  // Override from DayCellRenderer
  // Called automatically on the CellOverflow${overflowPopupTrigger} event because of callOnFunctions
  onCellOverflowGesture({
    date
  }) {
    if (expandGestures$1[this.overflowClickAction.toLowerCase()]) {
      this.expanded = true;
    } else {
      super.onCellOverflowGesture(...arguments);
    }
  }
  onVisibleDateRangeChange() {
    if (!this.isConfiguring) {
      var _this$_cellMap;
      (_this$_cellMap = this._cellMap) === null || _this$_cellMap === void 0 ? void 0 : _this$_cellMap.clear();
      this.refresh();
    }
  }
  changeAutoHeight(autoHeight) {
    const me = this,
      // Must be cached before property changes. This is calculated in this class
      {
        eventsPerCell
      } = me;
    // We need to update in the changer because we need to cache conditions that
    // applied before the change: eventsPerCell
    me._autoHeight = autoHeight;
    me.setEventContentHeight(me.cellContentHeight);
    // Calculates new values for eventsPerCell and eventContainerTop
    // and handles changes to either.
    me.performResizeRefresh(eventsPerCell, me.eventContainerTop, true);
  }
  async setEventContentHeight(eventContentHeight, syncingSiblings) {
    const me = this,
      {
        cellContainer: element,
        parent
      } = me;
    // Reject non-changes.
    // This isn't a config because setting it is an async awaitable method.
    if (me._eventContentHeight !== eventContentHeight) {
      var _parent$parent;
      // Update any smaller sibling rows unless that is what is being done to us
      if (!syncingSiblings && parent !== null && parent !== void 0 && parent.isDayView && (_parent$parent = parent.parent) !== null && _parent$parent !== void 0 && _parent$parent.isResourceView) {
        const siblings = parent.parent.items.map(v => v.allDayEvents).filter(v => v && v !== me);
        // If we are the allDayEvents of a DayView which has siblings, we must consult
        // all siblings which are not time axes/scrollers and find the max so that we all
        // stay in sync.
        // This may be the case in a ResourceView of several DayViews side-by-side.
        eventContentHeight = Math.max(eventContentHeight || 0, ...siblings.filter(v => !v.owner.isResourceDayViewTimeAxis).map(v => v.calculateCellContentHeight() || 0));
        siblings === null || siblings === void 0 ? void 0 : siblings.forEach(v => {
          v.setEventContentHeight(eventContentHeight, true);
        });
      }
      const {
        height: oldHeight
      } = me;
      let {
        animate
      } = me;
      // Set this widget to the animating state if we are configured to animate the height
      me.isAnimating = animate;
      // Once we have set the animating flag which sets the CSS class, we can detect any duration
      const duration = DomHelper.getPropertyTransitionDuration(element, 'height');
      if (!duration) {
        me.isAnimating = animate = false;
      }
      // Only show the scrollbar when we need to - if there's a space-consuming scrollbar shown.
      // We pre-change the cell heights in unanimated mode and see if there's overflow so that
      // we can set overflowY appropriately before the animation is kicked off.
      element.style.height = `${eventContentHeight}px`;
      // If it's zero height, the top border will not be shown because this border would collide
      // with the border-top of the day content element below.
      me.bodyElement.classList.toggle('b-zero-height', !Boolean(eventContentHeight));
      if (animate) {
        await (me.heightAnimation = EventHelper.waitForTransitionEnd({
          property: 'height',
          element,
          duration
        }));
      }
      if (!me.isDestroyed) {
        var _me$owner, _me$owner$syncScrollb;
        const {
          height
        } = me;
        me.isAnimating = false;
        me._eventContentHeight = eventContentHeight;
        (_me$owner = me.owner) === null || _me$owner === void 0 ? void 0 : (_me$owner$syncScrollb = _me$owner.syncScrollbarPadding) === null || _me$owner$syncScrollb === void 0 ? void 0 : _me$owner$syncScrollb.call(_me$owner);
        /**
         * Fires when this CalendarRow has completely changed its height.
         * This fires *after* the animation has finished.
         * @param {Calendar.widget.CalendarRow} source The triggering instance.
         * @param {Number} oldHeight The old height.
         * @param {Number} height The new height.
         * @event heightChange
         */
        if (height !== oldHeight) {
          me.trigger('heightChange', {
            height,
            oldHeight
          });
        }
      }
    }
  }
  get hasOverflow() {
    return !this.autoHeight && this.maxEventCount > this.defaultEventRowCount;
  }
  get eventsPerCell() {
    const me = this,
      {
        maxEventCount
      } = me;
    return me.expanded || me.autoHeight ? maxEventCount : Math.min(maxEventCount, me.defaultEventRowCount);
  }
  get cellContentHeight() {
    return this.calculateCellContentHeight();
  }
  calculateCellContentHeight() {
    // The minHeight must accommodate at least one row, but by default, defaultEventRowCount rows of events.
    // The all day section is expandable. If autoHeight, the minHeight must accommodate all events.
    const me = this,
      {
        gutterHeight
      } = me;
    let result = Math.ceil(me.eventContainerTop + me.eventsPerCell * (me.eventHeightInPixels + me.eventSpacing));
    // Allow gutterHeight : 1em to result in a 'calc(100px + 5em)' type value
    if (gutterHeight) {
      // The gutter is *instead of* the ${eventSpacing}px below the last event
      if (me.eventsPerCell) {
        result -= me.eventSpacing;
      }
      if (isNaN(gutterHeight)) {
        result = `calc(${result}px + ${gutterHeight})`;
      } else {
        result += Number(gutterHeight);
      }
    }
    return result;
  }
  getDateFromPosition(clientX, clientY) {
    const me = this,
      {
        hideNonWorkingDays,
        contentElement
      } = me,
      dayCells = contentElement.querySelectorAll(`${me.visibleCellSelector}${hideNonWorkingDays ? ':not(.b-nonworking-day' : ''}`),
      rowRect = contentElement.getBoundingClientRect(),
      dx = me.rtl ? rowRect.right - clientX : clientX - rowRect.left,
      weekLength = dayCells.length,
      {
        width
      } = rowRect,
      column = Math.floor(dx * weekLength / width);
    if (dx < 0 || width < dx || clientY < rowRect.top || rowRect.bottom < clientY) {
      return null;
    }
    // Some days may be hidden.
    if (me.hideNonWorkingDays) {
      const cellDates = Array.from(dayCells).map(e => me.getDateFromElement(e));
      return cellDates[column];
    } else {
      const date = me.getDateFromElement(dayCells[0]);
      date.setDate(date.getDate() + column);
      return date;
    }
  }
  /**
   * If not {@link #config-autoHeight}, this toggles between the collapsed state where it shows
   * the {@link #config-defaultEventRowCount} even if more event rows exist, and the expanded state
   * (which is equivalent to {@link #config-autoHeight}) where all event rows are shown.
   */
  async toggleExpandCollapse() {
    const {
      expanded
    } = this;
    // Do not go through the setter because this method is async and needs to be awaited
    await this.updateExpanded(!Boolean(expanded), expanded);
  }
  async updateExpanded(expanded, wasExpanded) {
    const me = this;
    // Temporarily set the property so that eventsPerCell yields the "from" count.
    me._expanded = wasExpanded;
    const {
      eventsPerCell
    } = me;
    me._expanded = expanded;
    // If we are expanding, a refresh will update the height *after* the refresh
    // which is what we want: it will "reveal" existing event bars
    if (me.expanded) {
      me.performResizeRefresh(eventsPerCell, me.eventContainerTop, true);
      await me.heightAnimation;
    }
    // If we are collapsing however, we want to hide the overflowing event bars
    // and *only then* refresh to cut the event bars back.
    else {
      me.scrollable.overflowY = 'hidden';
      await me.setEventContentHeight(me.cellContentHeight);
      // Calculates new values for eventsPerCell and eventContainerTop
      // and handles changes to either.
      if (wasExpanded && !me.isDestroyed) {
        me.performResizeRefresh(eventsPerCell, me.eventContainerTop, true);
      }
    }
  }
  // We must implement the CalendarMixin interface.
  // All views must expose a doRefresh method.
  doRefresh() {
    var _this$_cellMap2, _me$nonWorkingDays;
    (_this$_cellMap2 = this._cellMap) === null || _this$_cellMap2 === void 0 ? void 0 : _this$_cellMap2.clear();
    const me = this,
      {
        dayTime,
        fullWeek,
        startDate,
        endDate,
        headerCellContainer,
        cellContainer,
        dayHeaderRenderer
      } = me,
      cellMap = (startDate || endDate) && me.cellMap,
      nonWorkingDays = (_me$nonWorkingDays = me.nonWorkingDays) !== null && _me$nonWorkingDays !== void 0 ? _me$nonWorkingDays : me.month.nonWorkingDays,
      hiddenDays = me.hideNonWorkingDays ? nonWorkingDays : emptyObject,
      cellDataBlocks = [],
      eventCells = [],
      headerCells = [];
    if (!cellMap) {
      return;
    }
    let columnIndex = 0,
      visibleColumnIndex = 0,
      from = new Date(startDate),
      to = endDate,
      currentDay,
      i,
      lastWorkingDayCell;
    if (fullWeek) {
      from = me.month.getWeekStart(me.month.getWeekNumber(from));
      to = DateHelper.add(from, 7, 'd');
    }
    // Collect all our cell data blocks and measure our week length
    for (const date = from; date < to; date.setDate(date.getDate() + 1), columnIndex++) {
      const cellData = cellMap.get(dayTime.dateKey(date)) || me.createCellData(date);
      cellData.columnIndex = cellData.cellIndex = columnIndex;
      if (hiddenDays[cellData.day]) {
        cellData.visibleColumnIndex = undefined;
      } else {
        cellData.isRowStart = visibleColumnIndex === 0;
        cellData.visibleColumnIndex = visibleColumnIndex;
        if (!fullWeek) {
          visibleColumnIndex++;
        }
      }
      cellDataBlocks.push(cellData);
    }
    // Needed for event bar %age width calculation in getCellDomConfig
    me.weekLength = fullWeek ? 1 : visibleColumnIndex;
    const length = cellDataBlocks.length;
    for (i = 0; i < length; i++) {
      const cellData = cellDataBlocks[i],
        {
          day,
          key
        } = cellData;
      // There'll be no cell if it's a hidden, nonworking day
      if (!hiddenDays[day]) {
        const isNonWorking = nonWorkingDays[day],
          dayCls = `b-day-of-week-${day}`;
        currentDay = !(cellData.date - me.date);
        cellData.cell = me.getCell(key);
        // The contract of DayCellRenderer is defined in Core/widget/CalendarPanel.
        cellData.row = me.cellContainer;
        const cellDomConfig = me.getCellDomConfig(cellData),
          headerDomConfig = Objects.merge({
            dataset: {
              // The [data-date] property marks an event content cell.
              headerDate: key
            }
          }, cellDomConfig.children[0]);
        headerDomConfig.className['b-selected-date'] = currentDay;
        headerDomConfig.className['b-current-date'] = fullWeek && currentDay;
        headerDomConfig.className[dayCls] = 1;
        // Show the dayHeaderRenderer the day header domConfig
        dayHeaderRenderer && me.callback(dayHeaderRenderer, me, [headerDomConfig, cellData]);
        cellDomConfig.dataset.date = key;
        Object.assign(cellDomConfig.className, {
          'b-dayview-allday': 1,
          [me.nonWorkingDayCls]: isNonWorking,
          [me.weekendCls]: DateHelper.weekends[day],
          [me.dayCellCls]: 1,
          [dayCls]: 1
        });
        // Remove header child from cell config
        cellDomConfig.children.shift();
        headerCells.push(headerDomConfig);
        if (!fullWeek || currentDay) {
          eventCells.push(cellDomConfig);
          if (!isNonWorking) {
            lastWorkingDayCell = cellDomConfig;
          }
        }
      }
    }
    // Identify last working day in row if there were any.
    lastWorkingDayCell && (lastWorkingDayCell.className['b-last-working-day'] = 1);
    DomSync.sync({
      targetElement: headerCellContainer,
      domConfig: {
        children: headerCells,
        // Ensure DOM order matches children order.
        syncOptions: {
          releaseThreshold: 0,
          strict: true
        }
      }
    });
    DomSync.sync({
      targetElement: cellContainer,
      domConfig: {
        children: eventCells,
        // Ensure DOM order matches children order.
        syncOptions: {
          releaseThreshold: 0,
          strict: true
        }
      }
    });
    me.refreshCount = (me.refreshCount || 0) + 1;
    // Must only ever be a temporary state to accommodate dropping into an empty row.
    // As soon as a refresh happens, the state must be revoked.
    me.collapseGutter();
    // Needs day elements to be in place before this can be measured and fixed.
    me.setEventContentHeight(me.cellContentHeight);
    /**
     * Fires when this CalendarRow refreshes.
     * @param {Calendar.widget.CalendarRow} source The triggering instance.
     * @event refresh
     */
    me.trigger('refresh');
  }
  get eventContainerTop() {
    return 0;
  }
  async expandGutter() {
    const me = this;
    if (!me._isTemporarilyExpanded) {
      me.gutterHeight = (me.gutterHeight || 0) + me.eventHeightInPixels + me.eventSpacing;
      await me.setEventContentHeight(me.cellContentHeight);
      me._isTemporarilyExpanded = true;
    }
  }
  async collapseGutter() {
    const me = this;
    if (me._isTemporarilyExpanded) {
      me.gutterHeight = me.gutterHeight - (me.eventHeightInPixels + me.eventSpacing);
      await me.setEventContentHeight(me.cellContentHeight);
      me._isTemporarilyExpanded = false;
    }
  }
  // addCellHeaderContent mutates the cellHeader DomConfig block.
  // And if we are to have a day name element, returns the DomConfig for it.
  // It's called from DayCellRenderer#getCellDomConfig
  addCellHeaderContent(cellHeader, cellData) {
    var _me$dayTime;
    const me = this,
      {
        date,
        day,
        tomorrow
      } = cellData,
      {
        dayNameFormat,
        dayNumberCompress,
        daySeparator
      } = me,
      shifted = me === null || me === void 0 ? void 0 : (_me$dayTime = me.dayTime) === null || _me$dayTime === void 0 ? void 0 : _me$dayTime.startShift;
    cellHeader.children = [{
      className: `b-day-name-part b-day-name-day${dayNumberCompress ? ' b-day-name-short' : ''}`,
      html: formatDayPart(dayNameFormat, daySeparator[0], date, shifted && tomorrow)
    }, {
      className: `b-day-name-part b-day-name-date`,
      html: formatDayPart(me.dayNumberFormat, daySeparator[1], date, shifted && tomorrow, dayNumberCompress)
    }];
    cellHeader.className[me.nonWorkingDayCls] = cellData.isNonWorking;
    cellHeader.className[me.weekendCls] = DateHelper.weekends[day];
  }
  updateLocalization() {
    if (!this.isConfiguring) {
      this.refresh();
    }
    super.updateLocalization();
  }
}
CalendarRow.initClass();
CalendarRow._$name = 'CalendarRow';

/**
 * @module Calendar/widget/DaySelector
 */
/**
 * This is used as the day selector header in an {@link Calendar.widget.EventList}
 * or {@link Calendar.widget.DayView}. It should not be used standalone as a regular Widget.
 *
 * @internal
 * @extends Calendar/widget/CalendarRow
 * @classType dayselector
 */
class DaySelector extends CalendarRow {
  // Factoryable type name

  afterConfigure() {
    var _owner$scrollable;
    const me = this,
      {
        owner
      } = me;
    super.afterConfigure();
    (_owner$scrollable = owner.scrollable) === null || _owner$scrollable === void 0 ? void 0 : _owner$scrollable.ion({
      overflowChange: 'onOwnerOverflowChange',
      thisObj: me
    });
    // We take over our owner's descriptionRenderer
    owner.descriptionRenderer = me.descriptionRenderer.bind(me);
    // We take over control over our owner's next and previous methods.
    // "this" within these functions will refer to the owner widget
    owner.previous = function () {
      this.date = DateHelper.add(owner.date, -owner.duration, 'd');
    };
    owner.next = function () {
      this.date = DateHelper.add(owner.date, owner.duration, 'd');
    };
    // We need to update ourselves in sync with our owner's date
    FunctionHelper.before(owner, 'updateDate', this.beforeOwnerDateUpdate, this);
  }
  beforeOwnerDateUpdate(date) {
    this.date = date;
  }
  onOwnerOverflowChange({
    y
  }) {
    this.headerElement.classList.toggle('b-show-yscroll-padding', Boolean(y));
  }
  onDayNumberClick({
    date
  }) {
    if (this.owner) {
      this.owner.date = date;
    }
    // No further navigation must take place. Note that this is not a scheduleClick - this
    // widget is merely a slave of its owning Calendar widget. This is an internal gesture
    // which sets the owning Calendar widget's date.
    return false;
  }
  descriptionRenderer() {
    const {
        startDate,
        endDate,
        owner
      } = this,
      startMonth = startDate.getMonth(),
      endMonth = endDate.getMonth(),
      monthDesc = startMonth === endMonth ? DateHelper.format(startDate, 'MMMM') : `${DateHelper.format(startDate, 'MMM')} - ${DateHelper.format(endDate, 'MMM')}`,
      week = owner.month.getWeekNumber(startDate);
    return `${this.L('L{Object.Week}')} ${week[1]}, ${monthDesc} ${week[0]}`;
  }
}
_defineProperty(DaySelector, "$name", 'DaySelector');
_defineProperty(DaySelector, "type", 'dayselector');
_defineProperty(DaySelector, "configurable", {
  readOnly: true,
  autoCreate: false,
  flex: '0 0 auto',
  dock: 'top'
});
DaySelector.initClass();
DaySelector._$name = 'DaySelector';

/**
 * @module Calendar/widget/mixin/DaySelectable
 */
/**
 * Mixin that provides the ability to add a {@link Calendar.widget.DaySelector} as a
 * {@link Core.widget.Panel#config-tbar}.
 *
 * This is used by the {@link Calendar.widget.EventList} and also {@link Calendar.widget.DayView} to
 * optionally be able to show a day selector row docked at the top.
 *
 * @mixin
 */
var DaySelectable = (Target => class DaySelectable extends (Target || Base) {
  static get $name() {
    return 'CalendarMixin';
  }
  static get configurable() {
    return {
      /**
       * If {@link #config-daySelector} is set, then this will be an instance
       * of {@link Calendar.widget.DaySelector} which encapsulates the day selector at the top
       * of this view.
       * @member {Calendar.widget.DaySelector} daySelector
       * @readonly
       * @internal
       */
      /**
       * A Configure this as `true` to show a {@link Calendar.widget.DaySelector} docked at the top to
       * act as a day selector. By default, the DaySelector will be seven days in duration and locked
       * to start a the `weekStartDay`
       * @config {Boolean|Object}
       * @internal
       */
      daySelector: null
    };
  }
  changeDaySelector(daySelector, oldDaySelector) {
    const me = this;
    if (daySelector) {
      // Whatever we are mixed into, it's because it is showing only one day.
      me.range = '1 day';
      // In case we are mixed into an EventList.
      me.settings = null;
      me.hideHeaders = true;
      const startDate = me.dayTime.shiftDate(me.month.getWeekStart(me.month.getWeekNumber(me.startDate))),
        result = DaySelector.reconfigure(oldDaySelector, daySelector, {
          owner: me,
          defaults: {
            type: 'dayselector',
            calendar: me.calendar,
            parent: me,
            cls: {
              [`b-${me.type}-dayselector`]: 1
            },
            dayStartShift: me.dayStartShift,
            dayTime: me.dayTime,
            month: me.month,
            date: me.date,
            startDate,
            range: {
              magnitude: 1,
              unit: 'week'
            },
            hideNonWorkingDays: me.hideNonWorkingDays,
            nonWorkingDays: me.nonWorkingDays,
            nonWorkingDayCls: me.nonWorkingDayCls,
            weekendCls: me.weekendCls,
            weekStartDay: me.weekStartDay
          }
        });
      me.element.classList.add(`b-${me.type}-with-dayselector`);
      me.tbar = result;
      return result;
    } else {
      oldDaySelector === null || oldDaySelector === void 0 ? void 0 : oldDaySelector.destroy();
    }
  }
  //region Current config
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    // Internal matter
    delete result.daySelector;
    return result;
  }
  //endregion
});

/**
 * @module Calendar/widget/EventList
 */
const byStartDate = (lhs, rhs) => lhs.startDate.valueOf() - rhs.startDate.valueOf(),
  mergeColumns = (configuredColumns, defaultColumns) => {
    if (defaultColumns) {
      // Support  columns : { data : { name : { field : 'name', text : 'Name' }}}
      // or       columns : { data : [{ field : 'name', text : 'Name' }] }
      configuredColumns = configuredColumns.data || configuredColumns;
      // Object form { name : { field : 'name', text : 'Name' }}
      if (ObjectHelper.isObject(configuredColumns)) {
        const result = defaultColumns.slice();
        for (const id in configuredColumns) {
          const newColumn = configuredColumns[id],
            // Match incoming column with existing by field name if there, or, if not, by name
            matchIndex = result.findIndex(c => c.id === id || c.field === id);
          // Configuration wants to add or override matched column
          if (newColumn) {
            const v = Config.merge(newColumn, result[matchIndex]);
            // So that it can be looked up in future merges
            v.id = id;
            result[matchIndex === -1 ? result.length : matchIndex] = v;
          }
          // Configuration wants to remove matched column
          else if (matchIndex > -1) {
            result.splice(matchIndex, 1);
          }
        }
        return result;
      }
      // Array form  [{ field : 'name', text : 'Name' }]
      else {
        defaultColumns = new Collection({
          values: defaultColumns,
          idProperty: 'field'
        });
        // Iterate the configured column set
        for (let i = 0, {
            length
          } = configuredColumns; i < length; i++) {
          const newColumn = configuredColumns[i],
            matchedExistingColumn = defaultColumns.get(newColumn.field);
          // Configuration wants to override matched column
          if (matchedExistingColumn) {
            configuredColumns[i] = Config.merge(newColumn, matchedExistingColumn);
            defaultColumns.remove(matchedExistingColumn);
          }
        }
        // Now append the remaining default columns
        configuredColumns.push(...defaultColumns.values);
        return configuredColumns;
      }
    } else {
      return configuredColumns;
    }
  };
/**
 * A Grid view of the EventStore.
 *
 * This shows a configured range of events from the event store.
 *
 * When used as a {@link Calendar.view.Calendar#config-modes mode} of a Calendar, the configured
 * {@link #config-range} is snapped to encapsulate the Calendar's current
 * {@link Calendar.view.Calendar#config-date}.
 *
 * The EventList's header context menu is extended to allow the user to change the range type.
 *
 * @extends Grid/view/Grid
 * @mixes Core/widget/mixin/Responsive
 * @mixes Calendar/widget/mixin/CalendarMixin
 * @mixes Calendar/widget/mixin/DayCellCollecter
 * @mixes Calendar/widget/mixin/DateRangeOwner
 * @demo Calendar/listview
 * @classtype eventlist
 * @inlineexample Calendar/widget/ListView.js
 */
class EventList extends Grid.mixin(CalendarMixin, DayCellCollecter, DaySelectable, DateRangeOwner) {
  static get $name() {
    return 'EventList';
  }
  static get type() {
    return 'eventlist';
  }
  static get configurable() {
    return {
      cls: 'b-slide-vertical',
      /**
       * A function to filter which events are collected into the day cell data blocks.
       * Return `true` to include the passed event, or a *falsy* value to exclude the event.
       * @config {Function}
       */
      eventFilter: null,
      localizableProperties: ['title', 'text'],
      title: 'L{List}',
      range: '1 month',
      // We have a Month utility object.
      // It helps us with week values and week change events
      month: true,
      /**
       * Column definitions to add to the default columns, or column definitions which override
       * the provided, default columns.
       *
       * By default, the `EventList` shows three columns:
       *
       * ```javascript:
       * columns : [{
       *     text  : 'Name',
       *     field : 'name'
       * }, {
       *     text  : 'Start',
       *     field : 'startDate'
       * }, {
       *     text  : 'End',
       *     field : 'endDate'
       * }]
       * ```
       *
       * Your `columns` config is appended to the default columns *unless you provide
       * columns for the `name`, `startDate` and `endDate` fields*, in which case your
       * column definitions are merged into the default column definitions.
       *
       * In this way you can provide a `renderer` for the default columns, or otherwise
       * configure them in a customizable way.
       * @config {Object|Object[]}
       */
      columns: {
        $config: {
          // Columns with matching field names are merged.
          // Non-matching columns are added
          merge: mergeColumns
        },
        value: [{
          text: 'L{EventEdit.Name}',
          field: 'name',
          flex: 1
        }, {
          text: 'L{EventList.Start}',
          //type       : 'startDate', // When column is hoisted from Gantt to Scheduler
          type: 'date',
          editor: {
            type: 'datetime',
            dateField: {
              step: null
            },
            timeField: {
              step: null
            }
          },
          field: 'startDate',
          width: '16.5em',
          format: 'L LT',
          renderer({
            record,
            value
          }) {
            return record.allDay ? DateHelper.format(value, 'L') : this.defaultRenderer(...arguments);
          }
        }, {
          text: 'L{EventList.Finish}',
          //type       : 'endDate', // When column is hoisted from Gantt to Scheduler
          type: 'date',
          editor: {
            type: 'datetime',
            dateField: {
              step: null
            },
            timeField: {
              step: null
            }
          },
          field: 'endDate',
          width: '16.5em',
          format: 'L LT',
          renderer({
            record,
            value
          }) {
            return record.allDay ? DateHelper.format(value, 'L') : this.defaultRenderer(...arguments);
          }
        }, {
          type: 'widget',
          text: 'Resources',
          field: 'resources',
          minWidth: 250,
          autoHeight: true,
          widgets: [{
            type: 'chipview',
            valueProperty: 'items',
            displayField: 'name',
            itemsFocusable: false,
            navigator: null,
            closable: false,
            style: {
              flexFlow: 'row nowrap',
              display: 'flex',
              padding: '5px 0 3px 0'
            },
            scrollable: {
              overflowX: 'hidden-scroll',
              overflowY: false
            },
            getItemCls: r => DomHelper.isNamedColor(r.eventColor) ? ` b-sch-${r.eventColor}` : '',
            getItemStyle: r => `color:#fff;${r.eventColor && !DomHelper.isNamedColor(r.eventColor) ? `background-color:${r.eventColor}` : ''}`
          }],
          editor: false
        }]
      },
      features: {
        group: false,
        rowCopyPaste: false,
        columnPicker: {
          createColumnsFromModel: true
        }
      },
      internalListeners: {
        beforeCellEditStart({
          editorContext
        }) {
          var _this$calendar, _this$calendar$featur, _this$calendar$featur2, _editor$timeField;
          const {
            editor,
            record
          } = editorContext;
          // TODO: Editing recurring events: https://github.com/bryntum/support/issues/2259
          if (record.isRecurring || record.isOccurrence) {
            Toast.show({
              html: 'Please use EventEdit to edit recurring events'
            });
            return false;
          }
          // Hide event tooltip if present.
          (_this$calendar = this.calendar) === null || _this$calendar === void 0 ? void 0 : (_this$calendar$featur = _this$calendar.features.eventTooltip) === null || _this$calendar$featur === void 0 ? void 0 : (_this$calendar$featur2 = _this$calendar$featur._tooltip) === null || _this$calendar$featur2 === void 0 ? void 0 : _this$calendar$featur2.hide();
          (_editor$timeField = editor.timeField) === null || _editor$timeField === void 0 ? void 0 : _editor$timeField[record.allDay ? 'hide' : 'show']();
        }
      },
      settings: {
        $config: 'lazy',
        value: null
      },
      /**
       * A {@link Core.helper.DateHelper} format string used to format the time displayed
       * next to event bars in the custom columns which {@link Calendar.widget.EventList}
       * based views use - {@link Calendar.widget.EventList} and {@link Calendar.widget.AgendaView}.
       * @config {String}
       * @default
       */
      eventListTimeFormat: 'HH:mm'
    };
  }
  /**
   * Returns the resource associated with this event list when used inside a {@link Calendar.widget.ResourceView}
   * @readonly
   * @member {Scheduler.model.ResourceModel} resource
   */
  static get delayable() {
    return {
      populateStoreSoon: {
        type: 'raf',
        cancelOutstanding: true
      }
    };
  }
  // We must implement the CalendarMixin interface.
  // All views must expose a doRefresh method.
  doRefresh() {
    this.refreshRows();
  }
  /**
   * This method produces the event time details next to the event bar in
   * {@link Calendar.widget.EventList} and {@link Calendar.widget.AgendaView}
   * as a {@link DomConfig} object.
   *
   * The content is encapsulated in an element with CSS class `b-cal-eventlist-event-time`.
   * For multi day events, the ending date is shown. For intra-day events, the start and end
   * times are shown.
   * @param {Scheduler.model.EventModel} eventRecord
   * @returns {DomConfig}
   */
  eventListEventTimeRenderer(eventRecord) {
    const me = this,
      daySpan = DateHelper.diff(DateHelper.clearTime(eventRecord.startDate), DateHelper.clearTime(eventRecord.endDate), 'day'),
      timeString = me.eventTimeRenderer ? me.callback(me.eventTimeRenderer, me, arguments) : daySpan > 1 ? me.L('L{Calendar.endsOn}', DateHelper.format(eventRecord.endDate, 'DD MMM')) : eventRecord.allDay ? me.L('L{Calendar.allDay}') : `${DateHelper.format(eventRecord.startDate, me.eventListTimeFormat)} - ${DateHelper.format(eventRecord.endDate, me.eventListTimeFormat)}`;
    return {
      className: {
        'b-cal-eventlist-event-time': 1
      },
      text: timeString
    };
  }
  /**
   * This method produces the date details block in {@link Calendar.widget.AgendaView} cells
   * as a {@link DomConfig} object.
   *
   * The content is encapsulated in an element with CSS class `b-cal-agenda-date`.
   * @param {Date} date
   * @returns {DomConfig}
   */
  agendaEventDateRenderer(date) {
    return {
      className: {
        'b-day-name': 1,
        'b-cal-agenda-date': 1,
        'b-today': !Boolean(DateHelper.clearTime(new Date()) - DateHelper.clearTime(date))
      },
      children: [{
        className: {
          'b-cal-agenda-date-date-number': 1
        },
        text: date.getDate()
      }, {
        className: {
          'b-cal-agenda-date-date-text': 1
        },
        children: [{
          text: DateHelper.format(date, 'dddd')
        }, {
          text: DateHelper.format(date, 'MMM YYYY')
        }]
      }]
    };
  }
  // Override because our Featurable mixin which comes before GridBase sets features to null
  // to destroy them, so we must ensure the inherited Grid features are cleaned up.
  destroy() {
    for (const feature of Object.values(this.features)) {
      var _feature$destroy;
      (_feature$destroy = feature.destroy) === null || _feature$destroy === void 0 ? void 0 : _feature$destroy.call(feature);
    }
    super.destroy();
  }
  populateHeaderMenu({
    items
  }) {
    items.listRangeItem = {
      weight: -1000,
      icon: 'b-icon-calendar-week',
      text: 'List Range',
      menu: this.listRangeMenu
    };
    super.populateHeaderMenu(...arguments);
  }
  refreshVirtualScrollbars() {
    super.refreshVirtualScrollbars();
    // Our floating settings button needs to be inset a little more if there is a visible scrollbar
    this.bodyElement.classList[DomHelper.scrollBarWidth && this.hasVerticalOverflow ? 'add' : 'remove']('b-has-scrollbar');
  }
  /**
   * This property yields a {@link Core.widget.Menu} config object which encapsulates the range choices
   * which this widget may be set to encapsulate:
   * - day
   * - week
   * - month
   * - year
   * - decade
   *
   * By default a `list` view adds these choices to the header context menu.
   * An `agenda` view creates a floating settings button which offers this menu.
   * The property may be used to create a custom UI for changing the range.
   * The value yielded by the default `get listRangeMenu()` implementation looks like this:
   *
   *```javascript
   * {
   *     items : {
   *         listRangeDayItem    : {config for DAY range menu item },
   *         listRangWeekItem    : {config for WEEK range menu item },
   *         listRangMonthItem   : {config for MONTH range menu item },
   *         listRangeYearItem   : {config for YEAR range menu item },
   *         listRangeDecadeItem : {config for DECADE range menu item }
   *     }
   * }
   *```
   *
   * A subclass can override `get listRangeMenu()` and mutate the object returned by the `super` call.
   *
   * For example, it could `delete` properties of the `items` block to limit which ranges may be selected.
   *
   * @member {MenuConfig} listRangeMenu
   * @readonly
   */
  get listRangeMenu() {
    const me = this,
      {
        unit
      } = me.range;
    if (!me._listRangeMenu) {
      const toggleGroup = `${me.id}-range-items`;
      me._listRangeMenu = {
        anchor: true,
        onToggle: e => {
          if (e.checked) {
            me.range = e.item.range;
            e.bubbles = false;
          }
          // We may lose or gain a scrollbar which will move the button
          if (DomHelper.scrollBarWidth) {
            e.menu.realign();
          }
        },
        items: {
          listRangeDayItem: {
            toggleGroup,
            range: 'day',
            text: 'L{EventEdit.day}',
            _unit: 'day'
          },
          listRangeWeekItem: {
            toggleGroup,
            range: 'week',
            text: 'L{EventEdit.week}',
            _unit: 'week'
          },
          listRangeMonthItem: {
            toggleGroup,
            range: 'month',
            text: 'L{EventEdit.month}',
            _unit: 'month'
          },
          listRangeYearItem: {
            toggleGroup,
            range: 'year',
            text: 'L{EventEdit.year}',
            _unit: 'year'
          },
          listRangeDecadeItem: {
            toggleGroup,
            range: 'decade',
            text: 'L{EventEdit.decade}',
            _unit: 'decade'
          }
        }
      };
    }
    for (const i of Object.values(me._listRangeMenu.items)) {
      i.checked = i._unit === unit;
    }
    return me._listRangeMenu;
  }
  updateRowManager(rowManager) {
    var _super$updateRowManag;
    (_super$updateRowManag = super.updateRowManager) === null || _super$updateRowManag === void 0 ? void 0 : _super$updateRowManag.call(this, ...arguments);
    // Make sure rows which represent EventModels have [data-event-id="?"] stamped into them.
    rowManager.ion({
      beforeRenderRow: 'onBeforeRenderRow',
      thisObj: this
    });
  }
  onBeforeRenderRow({
    row,
    record
  }) {
    const {
        _elementsArray
      } = row,
      {
        id,
        startDate
      } = record;
    // Only if it represents an EventModel.
    // In AgendaView, there are event bars with the event id, and the cells encapsulate dates.
    if (record.isEventModel) {
      for (let i = 0, {
          length
        } = _elementsArray; i < length; i++) {
        _elementsArray[i].dataset.eventId = id;
        _elementsArray[i].dataset.date = DateHelper.makeKey(startDate);
      }
      row.cls[`b-day-of-week-${startDate.getDay()}`] = 1;
    }
  }
  // Scheduler interface usually routes this to handleEvent.
  // If we're a Grid, GridElementEvents routes events to handleEvent, so override it to do nothing.
  // Otherwise keydown events would be handled twice
  onInternalKeyDown(domEvent) {}
  handleEvent(domEvent) {
    // Don't cause scroll when clicking in event list
    this.preventScroll = true;
    super.handleEvent(domEvent);
    this.preventScroll = false;
  }
  get displayName() {
    let s = this.title;
    if (typeof s !== 'string') {
      s = this.type;
    }
    return StringHelper.capitalize(s);
  }
  /**
   * Scrolls vertically to bring an event or a time into view.
   * @param {Scheduler.model.EventModel|Date} target The event to scroll to or a `Date` to scroll to.
   * @param {Object} [options] How to scroll.
   * @param {String} [options.block] How far to scroll the target: `start/end/center/nearest`.
   * @param {Number} [options.edgeOffset] edgeOffset A margin around the target to bring into view.
   * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
   * or the number of milliseconds to animate over, or an animation config object.
   * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
   * @param {String} [options.animate.easing] The name of an easing function.
   * @param {Boolean|Function} [options.highlight] Set to `true` to highlight the resulting element
   * when it is in view. May be a function which is called passing the resulting element
   * to provide customized highlighting.
   * @param {Boolean} [options.focus] Set to `true` to focus the element when it is in view.
   * @param {Boolean} [options.y] Pass as `false` to disable scrolling in the `Y` axis.
   * @returns {Promise} A promise which is resolved when the target has been scrolled into view.
   */
  async scrollTo(target, options = {
    animate: true
  }) {
    const me = this;
    if (target instanceof me.store.modelClass) {
      // Scroll the passed record into view
      await me.scrollRowIntoView(target, Object.assign({}, options, {
        highlight: false
      }));
      if (options.highlight) {
        target = me.getEventElement(target, target.startDate);
        if (typeof options.highlight === 'boolean') {
          DomHelper.highlight(target, me);
        } else {
          (me.widget || me).callback(options.highlight, null, [target]);
        }
      }
    } else if (ObjectHelper.isDate(target) && me.store.count) {
      const index = me.dateIndex,
        key = DateHelper.makeKey(target);
      // We have a row for this date...
      if (index[key]) {
        await me.scrollRowIntoView(index[key], options);
        me.scrolledToDate = target;
      }
      // Otherwise, find the closest in time
      else {
        let closest = Number.MAX_SAFE_INTEGER;
        const keys = Object.keys(index);
        for (let i = 0, {
            length
          } = keys; i < length; i++) {
          const d = DateHelper.parseKey(keys[i]);
          if (Math.abs(d - target) < Math.abs(closest - target)) {
            closest = d;
          }
        }
        // Recurse with a known-to-exist date
        await me.scrollTo(closest);
      }
    }
  }
  updateStartDate() {
    const {
      refreshCount
    } = this;
    // Prevent this.onMonthChange from trying to scroll when we update our month's active date
    this.preventScroll = true;
    super.updateStartDate(...arguments);
    this.preventScroll = false;
    // Superclass's updateStartDate will most likely cause a refresh due to changing the date.
    // But if we're moving to a larger encapsulating range (eg 1w to 1y), the date may
    // not be forced to change, so kick off a refresh if it has not been done.
    if (!this.isConfiguring && this.refreshCount === refreshCount) {
      this.populateStoreSoon();
    }
  }
  updateEndDate() {
    var _super$updateEndDate;
    const {
      refreshCount
    } = this;
    (_super$updateEndDate = super.updateEndDate) === null || _super$updateEndDate === void 0 ? void 0 : _super$updateEndDate.call(this, ...arguments);
    // Superclass's updateEndDate will most likely cause a refresh due to changing the date.
    // But if we're moving to a larger encapsulating range (eg 1w to 1y), the date may
    // not be forced to change, so kick off a refresh if it has not been done.
    if (!this.isConfiguring && this.refreshCount === refreshCount) {
      this.populateStoreSoon();
    }
  }
  updateRange() {
    var _super$updateRange;
    const {
      refreshCount
    } = this;
    (_super$updateRange = super.updateRange) === null || _super$updateRange === void 0 ? void 0 : _super$updateRange.call(this, ...arguments);
    // Superclass's updateRange will most likely cause a refresh due to changing the date.
    // But if we're moving to a larger encapsulating range (eg 1w to 1y), the date may
    // not be forced to change, so kick off a refresh if it has not been done.
    if (!this.isConfiguring && this.refreshCount === refreshCount) {
      this.populateStoreSoon();
    }
  }
  descriptionRenderer() {
    const me = this,
      {
        date,
        startDate,
        endDate,
        range,
        count
      } = me;
    let rangeDesc;
    if (range.magnitude === 1) {
      switch (range.unit) {
        case 'day':
          rangeDesc = DateHelper.format(date, 'L');
          break;
        case 'week':
          {
            const startMonth = startDate.getMonth(),
              endMonth = endDate.getMonth(),
              monthDesc = startMonth === endMonth ? DateHelper.format(startDate, 'MMMM') : `${DateHelper.format(startDate, 'MMM')} - ${DateHelper.format(endDate, 'MMM')}`,
              week = me.month.getWeekNumber(startDate);
            rangeDesc = `${me.L('L{Object.Week}')} ${week[1]}, ${monthDesc} ${week[0]}`;
            break;
          }
        case 'month':
          rangeDesc = DateHelper.format(date, 'MMMM, YYYY');
          break;
        case 'year':
          rangeDesc = DateHelper.format(date, 'YYYY');
          break;
        case 'decade':
          rangeDesc = `${DateHelper.format(startDate, 'YYYY')}s`;
      }
    } else {
      rangeDesc = `${DateHelper.format(me.startDate, 'L')} - ${DateHelper.format(me.endDate, 'L')}`;
    }
    return `${rangeDesc}. ${me.L('eventCount', count)}`;
  }
  /**
   * The number of events that this View currently encapsulates in its {@link #config-range date range}.
   * @member {Number}
   * @readonly
   */
  get count() {
    return this.store.count;
  }
  get stepUnit() {
    const {
      range
    } = this;
    // If just one unit, return the unit name
    return range.magnitude === 1 ? range.unit : this.range;
  }
  /**
   * When an EventStore arrives, chain off a slave store from that which we can then
   * filter to only show the week we are focused upon.
   */
  updateEventStore(eventStore) {
    var _super$updateEventSto;
    (_super$updateEventSto = super.updateEventStore) === null || _super$updateEventSto === void 0 ? void 0 : _super$updateEventSto.call(this, eventStore);
    // We monitor changes to the EventStore and repopulate our store if it needs it.
    eventStore.ion({
      refresh: 'onCalendarStoreChange',
      thisObj: this
    });
    this.populateStoreSoon();
  }
  changeStore(store) {
    var _store;
    const me = this;
    if (store) {
      store = Store.mergeConfigs({
        useRawData: {
          ignoreDefaults: true,
          disableDefaultValue: true,
          disableTypeConversion: true,
          enabled: true
        },
        modelClass: me.modelClass
      }, store);
    }
    store = super.changeStore(store);
    // Ensure our subclass, AgendaView is able to use its own filter
    if ((_store = store) !== null && _store !== void 0 && _store.modelClass.isEventModel) {
      me.nonWorkingDaysFilter = store.addFilter({
        id: `${me.id}-nonworkingday-filter`,
        filterBy: event => !me.dayTime.isIntraDay(event) || !me.hiddenNonWorkingDays[event.startDate.getDay()],
        disabled: !me.hideNonWorkingDays
      }, true);
    }
    return store;
  }
  updateHideNonWorkingDays(hideNonWorkingDays) {
    const me = this,
      {
        store
      } = me;
    super.updateHideNonWorkingDays(hideNonWorkingDays);
    // We do it by filtering the generated day records by the isNonWorking flag
    if (store) {
      me.nonWorkingDaysFilter.disabled = !hideNonWorkingDays;
      store.filter();
    }
    me.trigger('refresh');
  }
  afterRemove({
    records
  }) {
    // If they remove records from the Grid Store, assume they want to remove the underlying
    // events from the eventStore.
    this.eventStore.remove(records);
    super.afterRemove(...arguments);
  }
  get modelClass() {
    return this.eventStore.modelClass;
  }
  /**
   * This is called when our store needs to be repopulated from the eventStore
   * @private
   */
  populateStoreSoon() {
    const me = this,
      {
        project
      } = me;
    // Only refresh immediately if we are visible.
    if (me.isVisible) {
      // TODO: Should not draw anything before projects initial refresh. Unless there's no data.
      // Only populate if initial commit is performed and change is not triggered by project writing back data
      if (project.isInitialCommitPerformed && !project.isWritingData || !project.eventStore.count) {
        me.populateStore();
      }
    }
    // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)
    else {
      me.whenVisible('populateStore');
    }
  }
  populateStore() {
    var _me$calendar;
    const me = this,
      events = me.eventStore.getEvents({
        startDate: me.startDate,
        endDate: me.endDate,
        filter: me.eventFilter
      }).sort(byStartDate);
    // Create our date index by which we can scroll to dates.
    me.dateIndex = events.reduce((result, event) => {
      const key = DateHelper.makeKey(event.startDate);
      if (!result[key]) {
        result[key] = event;
      }
      return result;
    }, {});
    me.store.data = events;
    me.trigger('refresh');
    // The owning Calendar's UI may need to sync with the new state
    (_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.syncUIWithActiveView(this);
  }
  /**
   * Creates the Month utility object. We use it to track what week we are looking at.
   */
  changeMonth() {
    const result = super.changeMonth(...arguments);
    // Update when the month changes.
    result.ion({
      dateChange: 'onMonthChange',
      thisObj: this
    });
    return result;
  }
  /**
   * When the date we have been told to look at changes, recalculate the date range.
   * If the date range changes, this will cause a refill of our grid store from the
   * master event store.
   */
  onMonthChange({
    newDate
  }) {
    const me = this,
      {
        startDate
      } = me,
      newStartDate = me.changeStartDate(newDate);
    // Move range so that it encapsulates the target date if necessary
    if (!startDate || newStartDate - startDate) {
      me.updateRange(me.range);
    }
    // Only attempt if the store got populated and we are visible.
    if (!me.preventScroll && me.isVisible && me.store.count) {
      // Ensure any store rebuild triggered by reconfiguring is flushed before
      // we attempt to scroll to that date
      me.populateStoreSoon.flush();
      me.scrollTo(newDate);
    }
  }
  /**
   * This is added as a listener by the CalendarStores mixin.
   *
   * Our store is chained off of the EventStore; refill it if the EventStore changes.
   * The store will fire events which cause UI update.
   * We must fire a refresh event so that the encapsulating Calendar view knows about this.
   */
  onCalendarStoreChange({
    source: eventStore
  }) {
    if (!this.date) {
      this.date = eventStore.map(r => r.startDate).sort((lhs, rhs) => lhs.valueOf() - rhs.valueOf())[0];
    }
    // Only refresh immediately if we are visible.
    this.populateStoreSoon();
  }
  changeSettings(settings, oldSettings) {
    return settings && Button.reconfigure(oldSettings, Button.mergeConfigs({
      type: 'button',
      positioned: true,
      icon: 'b-icon-cog',
      menuIcon: null,
      cls: 'b-blue b-cal-widget-settings-button',
      appendTo: this.bodyElement
    }, settings), this);
  }
  //region Current config
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    // Internally assigned
    delete result.store;
    delete result.data;
    return result;
  }
  //endregion
}

EventList.initClass();
EventList._$name = 'EventList';

/**
 * @module Calendar/widget/AgendaView
 */
const isMouseOverOut = {
    mouseover: 1,
    mouseout: 1
  },
  isMouseInteraction = {
    mousedown: 1,
    mouseup: 1,
    click: 1,
    dblclick: 1,
    contextmenu: 1
  };
/**
 * This is normally used as a {@link Calendar.view.Calendar#config-modes mode} of a Calendar
 * but may be used standalone as a regular Widget.
 *
 * As a standalone widget, it will lack the capabilities of the {@link Calendar.view.Calendar Calendar}
 * class, such as keyboard-based event to event navigation and drag/drop features.
 *
 * A Grid which displays an agenda view of the events in an EventStore.
 *
 * When used as a {@link Calendar.view.Calendar#config-modes mode} of a Calendar, the configured
 * {@link #config-range} is snapped to encapsulate the Calendar's current
 * {@link Calendar.view.Calendar#config-date}.
 *
 * The AgendaView offers a floating settings button to allow the user to change the range type.
 *
 * @extends Calendar/widget/EventList
 * @classType agendaview
 * @inlineexample Calendar/widget/AgendaView.js
 */
class AgendaView extends EventList.mixin(Responsive) {
  static get $name() {
    return 'AgendaView';
  }
  // Factoryable type name
  static get type() {
    return 'agendaview';
  }
  static get configurable() {
    return {
      features: null,
      eventSorter: EventSorter.interDaySorterFn,
      /**
       * The spacing between event bars in the default rendering of a day cell.
       * @config {Number|String}
       * @default
       */
      eventRowSpacing: 8,
      title: 'L{Agenda}',
      range: 'year',
      /**
       * By default, long running events are repeated in all rows that the event covers.
       *
       * Configure this as `true` to only see the start of a long running event in its
       * start day.
       * @config {Boolean}
       */
      hideEventOverflow: null,
      /**
       * This view lines up the textual content of event bars by shifting event bars of
       * events which start before the bar's cell leftwards by the arrow width.
       *
       * Set this config to `false` to prevent this.
       * @prp {Boolean}
       * @default
       */
      offsetStartsBeforeEvents: true,
      // We handle this internally using the notifications from the GridElementEvents mixin
      handlePointerInteraction: false,
      /**
       * An empty function by default, but provided so that you can override it.
       *
       * This function is called for each cell rendered to allow developers to mutate the cell metadata, or
       * the CSS classes to be applied to the cell.
       *
       * The cellData (a {@link Core.helper.DomHelper#typedef-DomConfig}) object parameter may be mutated to
       * customize the cell appearance via `style` and `className` properties.
       *
       * ```javascript
       * dayCellRenderer : function(cellData) {
       *     // I don't like Mondays!
       *     if (cellData.day === 1) {
       *         cellData.cls['hackathon-dayoff'] = true;
       *         cellData.style.fontWeight = 'bold';
       *
       *         cellData.isNonWorking = true;
       *
       *         return `${cellData.date.getDate()} Day off yay!`;
       *     }
       * }
       *
       *```
       * A non-null return value from the renderer is used as the content of the day number element.
       *
       * @config {Function} dayCellRenderer
       * @param {DayCell} cellData An object that contains data about the cell.
       */
      dayCellRenderer: null,
      /**
       * An empty function by default, but provided so that you can override it.
       *
       * This function is called each time an event is rendered to to allow developers to mutate
       * the cell metadata, or the CSS classes to be applied to the event element.
       *
       * It's called with the event record, and a eventData object which allows you to mutate event metadata
       * such as 'cls', 'style'.
       *
       * The cls property is an object whose property names will be added to the event element if the property value is truthy.
       *
       * The style property is an object containing style properties for the event element.
       *
       * A non-null return value from the renderer is used as the event body content. A nullish
       * return value causes the default renderer to be used which just uses the event name.
       *
       * If a string is returned, it is used as the HTML content of the event body element.
       *
       * If an object is returned, it is used as a {@link Core.helper.DomHelper#typedef-DomConfig} object to
       * create complex content in the event body element.
       *
       * ```javascript
       *  eventRenderer(eventRecord, eventData) {
       *      if (eventRecord.name === 'Doctors appointment') {
       *          eventData.style.fontWeight = 'bold';
       *          eventData.cls['custom-cls'] = 1;
       *
       *          return 'Special doctors appointment';
       *      }
       *  }
       * ```
       * IMPORTANT: When returning content, be sure to consider how that content should be encoded to avoid XSS
       * (Cross-Site Scripting) attacks. This is especially important when including user-controlled data such as
       * the event's `name`. The function {@link Core.helper.StringHelper#function-encodeHtml-static} as well as
       * {@link Core.helper.StringHelper#function-xss-static} can be helpful in these cases.
       *
       * For example:
       * ```javascript
       *  eventRenderer(eventRecord, eventData) {
       *      return StringHelper.xss`Event: ${eventRecord.name}`;
       *  }
       * ```
       * @config {Function} eventRenderer
       * @param {Object} detail An object that contains data about the event being rendered.
       * @param {Scheduler.model.EventModel} detail.eventRecord The event record
       * @param {Scheduler.model.ResourceModel} detail.resourceRecord The event record
       * @param {Object} detail.renderData A data object containing properties that will be used to create the event element.
       * @param {Object} detail.renderData.style The style property is an object containing style properties for
       * the event element.
       * @param {Object} detail.renderData.cls The cls property is an object whose property names will be added to
       * the event element if the property value is truthy.
       * @param {String} detail.renderData.eventColor Color to be applied to the event
       * @param {Number} detail.renderData.eventHeight The current view's configured {@link Calendar.widget.mixin.CalendarMixin#config-eventHeight eventHeight}.
       * For the AgendaView, the renderer may modify this to a different value. `'auto'` means that the
       * content returned by the renderer will determine the height.
       */
      eventRenderer: null,
      /**
       * Specify `false` to display column headers
       * @config {Boolean}
       * @default
       * @category Misc
       */
      hideHeaders: true,
      /**
       * Column definitions.
       *
       * By default, a single {@link Calendar.column.AgendaColumn} is configured which creates
       * the default cell content for one day's events.
       *
       * You may configure the default agenda column away, and provide a custom column type
       * to produce the day's content where the `record` passed is a
       * {@link Calendar.widget.mixin.DayCellCollecter#typedef-DayCell}.
       *
       * Because cells may contain varying numbers of events, all columns in an AgendaView are
       * set to {@link Grid.column.Column#config-autoHeight}
       *
       * ```javascript
       * class MyAgendaColumn extends Column {
       *     // So we automatically get b-myagenda-cell class on the cells
       *     static get type() {
       *         return 'myagenda';
       *     }
       *
       *     renderer({ cellElement, record : cellData }) {
       *         // Create a DomHelper element configuration object here using cellData
       *         // cellData contains date contextual info and an events array.
       *     }
       * }
       *
       * ...
       *
       * {
       *     columns : {
       *         agenda : null,
       *         {
       *             type : 'mycolumntype'
       *         }
       *     }
       * }
       *
       * // Register this Column type so that in the app we can use type : 'myagendacolumn'
       * ColumnStore.registerColumnType(MyAgendaColumn);
       *```
       * @config {Object|Object[]}
       * @default { agenda : { type : 'agendacolumn' } }
       */
      columns: {
        // We knock out the columns we inherit from EventList.
        name: null,
        startDate: null,
        endDate: null,
        resources: null,
        agenda: {
          type: 'agendacolumn'
        }
      },
      /**
       * A function, or name of a function in the ownership hierarchy which is used to create
       * the time output next to event bars in an agenda cell.
       * @config {Function|String}
       * @param {Scheduler.model.EventModel} eventRecord The event record for which to create a time string.
       * @param {Date} date The date of the cell in which the event is being rendered.
       */
      eventTimeRenderer: null,
      enableSticky: true,
      preserveScrollOnDatasetChange: true,
      positionMode: 'position',
      settings: {},
      cellTabIndex: null,
      rowCls: {
        'b-cal-agenda-grid-row': 1
      },
      cellCls: {
        'b-calendar-cell': 1
      },
      eventBarContainerCls: 'b-cal-event-bar-container',
      // No GridNavigation key events in an AgendaView. It is natural, event-to-event navigation.
      keyMap: null
    };
  }
  /**
   * Returns the resource associated with this agenda view when used inside a {@link Calendar.widget.ResourceView}
   * @readonly
   * @member {Scheduler.model.ResourceModel} resource
   */
  construct(config) {
    const me = this;
    // Disable GridFeatures in AgendaView.
    // This is necessary in the built version where the features are all included
    // because of the needs of the docs app to use Grid for its own UI and because
    // many documentation examples run Grid examples.
    // This should change when https://github.com/bryntum/bryntum-suite/issues/1475 is addressed
    Object.defineProperty(me, 'features', {
      get: () => {
        return {};
      },
      set: () => {}
    });
    super.construct(config);
    // CalendarNavigation focuses event bars
    me.bodyContainer.removeAttribute('tabIndex');
  }
  onResponsiveStateChange({
    state,
    oldState
  }) {
    var _super$onResponsiveSt;
    (_super$onResponsiveSt = super.onResponsiveStateChange) === null || _super$onResponsiveSt === void 0 ? void 0 : _super$onResponsiveSt.call(this, ...arguments);
    // Moving between small and non-small state requires a refresh because the cell
    // layout changes and the rows need remeasuring and repositioning.
    if (oldState && (oldState === 'small' || state === 'small')) {
      this.refresh();
    }
  }
  changeColumns() {
    var _result$forEach;
    const result = super.changeColumns(...arguments);
    // Custom columns and AgendaColumns with custom renderer will be autoHeight
    result === null || result === void 0 ? void 0 : (_result$forEach = result.forEach) === null || _result$forEach === void 0 ? void 0 : _result$forEach.call(result, c => {
      c.autoHeight = Boolean(!c.isAgendaColumn || c.renderer || this.eventRenderer);
    });
    return result;
  }
  // Override these because CalendarNavigation focuses and navigates *events*, not grid cells.
  onFocusGesture() {}
  onGridElementFocus() {}
  onGridBodyFocusIn() {}
  focusCell() {}
  setHoveredRow() {}
  onElementKeyDown() {}
  onElementMouseDown() {}
  editAutoCreatedEvent(event, eventRecord) {
    // Uniquely, AgendaView has to regenerate its Grid store on event add so that
    // there is an event element to edit by.
    this.populateStoreSoon.now();
    super.editAutoCreatedEvent(event, eventRecord);
  }
  handleEvent(event) {
    const {
      type
    } = event;
    super.handleEvent(event);
    // Implement eventMouseover/eventMouseout.
    // All else is handled at the EventList level.
    if (isMouseOverOut[event.type]) {
      this.onEventMouseOverOut(event);
    } else if (isMouseInteraction[type]) {
      this.onCalendarPointerInteraction(event);
    }
  }
  getCellDataFromEvent(domEvent) {
    if (domEvent.target.closest('.b-grid-cell')) {
      const result = super.getCellDataFromEvent(domEvent);
      result && (result.record = this.getEventRecord(domEvent.target));
      return result;
    }
  }
  updateOffsetStartsBeforeEvents(offsetStartsBeforeEvents) {
    // Must case to Boolean because undefined defaults to true
    this.element.classList.toggle('b-offset-continues-past', Boolean(offsetStartsBeforeEvents));
  }
  updateEventRowSpacing(eventRowSpacing) {
    this.contentElement.style.setProperty('--event-row-spacing', DomHelper.setLength(eventRowSpacing));
  }
  updateSuppressLongEvents() {
    this.fillFromMaster();
  }
  onCalendarStoreChange({
    action,
    oldCount,
    records,
    removed,
    added
  }) {
    const me = this;
    if (me.isPainted) {
      // A filter which resulted in no filtering. Ignore it.
      if (action === 'filter' && !(removed !== null && removed !== void 0 && removed.length) && !(added !== null && added !== void 0 && added.length)) {
        return;
      }
      // Draw on project refresh instead of on dataset
      if (action === 'dataset') {
        return;
      }
      // Single record remove just updates the generated records that the event covers
      if (action === 'remove' && records.length === 1 && records[0].isEventModel) {
        const {
            store
          } = me,
          eventRecord = records[0],
          date = DateHelper.clearTime(eventRecord.startDate),
          endDate = DateHelper.clearTime(eventRecord.endDate);
        do {
          const key = DateHelper.makeKey(date),
            cellData = me.cellMap.get(key);
          if (cellData) {
            ArrayHelper.remove(cellData.events, eventRecord);
            // Update the row for this date
            if (cellData.events.length) {
              me.onStoreUpdateRecord({
                source: store,
                record: me.store.getById(key),
                changes: {}
              });
            }
            // No events on this date
            else {
              me.cellMap.delete(key);
              delete me.dateIndex[key];
              store.remove(key, true);
            }
          }
          date.setDate(date.getDate() + 1);
        } while (date < endDate);
        return;
      }
    }
    me.populateStoreSoon();
  }
  get cellMap() {
    var _this$_cellMap;
    // If the cellMap has not been populated, create it.
    return (_this$_cellMap = this._cellMap) !== null && _this$_cellMap !== void 0 && _this$_cellMap.populated ? this._cellMap : this.createCellMap({
      rawEvents: true,
      skipPropagate: true
    });
  }
  populateStore() {
    var _this$_cellMap2, _rowManager$rows, _me$calendar, _me$settings, _me$settings$_menu;
    (_this$_cellMap2 = this._cellMap) === null || _this$_cellMap2 === void 0 ? void 0 : _this$_cellMap2.clear();
    const me = this,
      {
        store,
        eventStore,
        rowManager
      } = me,
      {
        rowHeight
      } = rowManager,
      rowCount = (_rowManager$rows = rowManager.rows) === null || _rowManager$rows === void 0 ? void 0 : _rowManager$rows.length,
      eventHeight = isNaN(me.eventHeight) ? 25 : me.eventHeight;
    me.eventCount = 0;
    if (!me.date) {
      // Avoid recursion into populateStore
      me.isConfiguring = true;
      me.date = eventStore.map(r => r.startDate).sort((lhs, rhs) => lhs.valueOf() - rhs.valueOf())[0];
      me.isConfiguring = false;
    }
    const {
        cellMap
      } = me,
      cellMapEntries = [...cellMap.values()];
    me.dateIndex = {};
    for (let i = 0, {
        length
      } = cellMapEntries; i < length; i++) {
      const cellData = cellMapEntries[i],
        {
          events,
          date
        } = cellData;
      // Count unique events
      for (let j = 0, {
          length
        } = events; j < length; j++) {
        const event = events[j];
        if (!me.isAllDayEvent(event) || !i || DateHelper.clearTime(event.startDate).valueOf() === date.valueOf()) {
          me.eventCount++;
        }
      }
      // build date index
      me.dateIndex[cellData.id] = cellMapEntries[i] = store.createRecord(cellData);
    }
    const avgEventsPerCell = me.eventCount ? cellMapEntries.map(e => e.events.length).reduce((a, b) => a + b, 0) / cellMapEntries.length : 0;
    store.suspendEvents();
    store.loadData(cellMapEntries);
    store.resumeEvents();
    // Give RowManager a clue so that it can calculate an appropriate rowCount.
    // If the rows are tall, we do not need many to cover the viewport.
    rowManager._rowHeight = 20;
    // RowManager#set rowHeight does not tolerate no rows.
    if (store.count) {
      rowManager.rowHeight = Math.max(avgEventsPerCell * (eventHeight + me.eventSpacing), 70);
    }
    // Setting the rowHeight does a refresh if there are existing rows and the height actually changed.
    // Otherwise, we explicitly refresh now.
    if (!rowCount || !store.count || rowManager.rowHeight === rowHeight) {
      rowManager.calculateRowCount();
      rowManager.estimateTotalHeight(true);
    }
    me.refreshCount = (me.refreshCount || 0) + 1;
    /**
     * Fires when this AgendaView refreshes.
     * @param {Calendar.widget.AgendaView} source The triggering instance.
     * @event refresh
     */
    me.trigger('refresh');
    // The owning Calendar's UI may need to sync with the new state
    (_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.syncUIWithActiveView(me);
    me.columns.forEach(c => {
      var _c$constructor$expose, _c$constructor;
      return (_c$constructor$expose = (_c$constructor = c.constructor).exposeProperties) === null || _c$constructor$expose === void 0 ? void 0 : _c$constructor$expose.call(_c$constructor);
    });
    // Evaluate this late so that it doesn't change the order of date config evaluation
    // Ensure that the menu stays aligned if scrollbar causes button movement.
    (_me$settings = me.settings) === null || _me$settings === void 0 ? void 0 : (_me$settings$_menu = _me$settings._menu) === null || _me$settings$_menu === void 0 ? void 0 : _me$settings$_menu.realign();
  }
  get count() {
    return this.eventCount;
  }
  collectEvents(options) {
    // Only the first cell, or !hideEventOverflow needs overflows flowing into it.
    options.getDateIndex = date => date > this.startDate && this.hideEventOverflow ? 'startDate' : 'date';
    return this.eventStore.getEvents(options);
  }
  changeStore(store) {
    store = super.changeStore(store);
    if (store) {
      this.nonWorkingDaysFilter = store.addFilter({
        id: `${this.id}-nonworkingday-filter`,
        filterBy: rec => !rec.isNonWorking,
        disabled: !this.hideNonWorkingDays
      }, true);
      this.detachListeners('agendaStoreFilter');
      store.on({
        name: 'agendaStoreFilter',
        filter: 'onAgendaStoreFilter',
        thisObj: this
      });
    }
    return store;
  }
  get modelClass() {
    return GridRowModel;
  }
  onAgendaStoreFilter() {
    const me = this;
    // Count unique events
    me.eventCount = me.store.reduce((result, rec, i) => {
      const {
        events,
        date
      } = rec;
      for (let j = 0, {
          length
        } = events; j < length; j++) {
        const event = events[j];
        if (!me.isAllDayEvent(event) || !i || DateHelper.clearTime(event.startDate).valueOf() === date.valueOf()) {
          result++;
        }
      }
      return result;
    }, 0);
  }
  updateHideEventOverflow() {
    this.populateStore();
  }
  // We must implement the CalendarMixin interface.
  // All views must expose a doRefresh method.
  // Override from EventList. We need to repopulate our store to create day cells.
  doRefresh() {
    this.populateStore();
  }
  createCellData(date) {
    return Object.assign(this.cellMonth.getCellData(date, this.month), {
      id: DateHelper.makeKey(date),
      events: []
    });
  }
  set cellRenderer(cellRenderer) {
    this._cellRenderer = cellRenderer;
  }
  changeSettings(settings) {
    return settings && super.changeSettings({
      menu: _objectSpread2({
        align: {
          align: 't100-b100'
        }
      }, this.listRangeMenu)
    });
  }
}
AgendaView.initClass();
AgendaView._$name = 'AgendaView';

/**
 * @module Calendar/widget/CalendarDatePicker
 */
/**
 * A subclass of {@link Core.widget.DatePicker} which is able to show the presence of
 * events in its cells if contained in a Calendar, and {@link #config-showEvents} is set
 * to a truthy value.
 *
 * The `datepicker` Widget type is implemented by this class when this class is imported, or built
 * into a bundle, and so any {@link Core.widget.DateField} may have its
 * {@link Core.widget.PickerField#config-picker} configured to use its capabilities of showing
 * the presence of events in its date cells.
 *
 * @extends Scheduler/widget/SchedulerDatePicker
 * @mixes Calendar/widget/mixin/EventRenderer
 * @classType datepicker
 * @widget
 */
class CalendarDatePicker extends SchedulerDatePicker.mixin(EventRenderer) {
  // Factoryable type name

  construct(config) {
    if (!config.eventStore) {
      var _ref;
      const calendar = (_ref = config.owner || config.parent) === null || _ref === void 0 ? void 0 : _ref.up('calendar');
      calendar && (config.eventStore = calendar.eventStore);
    }
    super.construct(...arguments);
  }
  updateMaxDots() {
    this.refresh();
  }
  refreshEventsMap() {
    const me = this;
    if (me.showEvents) {
      me.eventsMap = me.eventStore[me.showEvents === 'dots' ? 'getEvents' : 'getEventCounts']({
        startDate: me.startDate,
        endDate: me.endDate,
        dateMap: me.eventsMap || (me.eventsMap = new Map())
      });
    }
  }
  cellRenderer({
    cell,
    date
  }) {
    var _this$eventsMap, _this$eventsMap$get;
    const {
        showEvents
      } = this,
      isCount = showEvents === 'count',
      isDots = showEvents === 'dots',
      eventInfo = (_this$eventsMap = this.eventsMap) === null || _this$eventsMap === void 0 ? void 0 : (_this$eventsMap$get = _this$eventsMap.get) === null || _this$eventsMap$get === void 0 ? void 0 : _this$eventsMap$get.call(_this$eventsMap, DateHelper.makeKey(date)),
      count = isDots ? eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.length : eventInfo,
      countCls = isCount ? 'b-cell-events-badge' : isDots ? 'b-cal-minimal-event-container' : 'b-icon b-icon-circle';
    if (isDots) {
      // We replace the text-only date with an element so it can carry the background
      // and the background will not obscure the dots.
      cell.innerHTML = '';
      DomHelper.createElement({
        class: 'b-date-cell-inner',
        text: date.getDate(),
        parent: cell
      });
    }
    delete cell.parentNode.dataset.btip;
    if (count) {
      if (!isCount && this.eventCountTip) {
        cell.parentNode.dataset.btip = this.L('L{ResourceInfoColumn.eventCountText}', count);
      }
      const cellContent = {
        dataset: {
          count
        },
        class: {
          [countCls]: 1,
          [SchedulerDatePicker.getEventCountClass(count)]: 1
        },
        parent: cell,
        [isCount ? 'text' : '']: count
      };
      if (isDots) {
        const children = cellContent.children = [];
        for (let i = 0; i < Math.min((eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.length) || 0, this.maxDots); i++) {
          const eventDomConfig = this.createEventDomConfig({
            eventRecord: eventInfo[i],
            // renders without content with just background colour
            minimal: true
          });
          children.push(eventDomConfig);
        }
      }
      DomHelper.createElement(cellContent);
    }
  }
  static setupClass(meta) {
    // We take over the type name 'datepicker' when we are in the app
    meta.replaceType = true;
    super.setupClass(meta);
  }
}
_defineProperty(CalendarDatePicker, "$name", 'CalendarDatePicker');
_defineProperty(CalendarDatePicker, "type", 'datepicker');
_defineProperty(CalendarDatePicker, "configurable", {
  /**
   * How to show presence of events in the configured {@link #config-eventStore} in the
   * day cells. Values may be:
   *
   * * `false` - Do not show events in cells.
   * * `true` - Show a themeable bullet to indicate the presence of events for a date.
   * * `'count'` - Show a themeable badge containing the event count for a date.
   * * `'dots'` - Show small event-coloured bullets up to a maximum of {@link #config-maxDots} to indicate event presence.
   * @prp {Boolean|'count'|'dots'}
   * @default false
   */
  showEvents: null,
  /**
   * When {@link #config-showEvents} is `'dots'`, this is the maximum number of dots to show
   * below the date number in the cell.
   *
   * The default is four. Note that increasing this may lead to a cluttered UI in which the dots
   * obscure the date figure in the cell.
   *
   * @prp {Number}
   * @default
   */
  maxDots: 4,
  /**
   * When {@link #config-showEvents} is __not__ `'count'`, setting this to
   * `true` means that a tooltip containing the event count will be shown on hover of
   * a day cell.
   *
   * @prp {Boolean}
   * @default
   */
  eventCountTip: null,
  alwaysRefreshOnMonthChange: true
});
CalendarDatePicker.initClass();
CalendarDatePicker._$name = 'CalendarDatePicker';

/**
 * @module Calendar/widget/DayView
 */
const {
    MILLIS_PER_HOUR
  } = DayTime,
  // We need the full longest date because intervening ticks may now be shown.
  widestDate = new Date(2020, 10, 22, 22, 59, 59),
  blockedAllDayEvents = {
    paint: 1,
    refresh: 1,
    resize: 1,
    eventspercellchange: 1
  },
  stopEvent = e => {
    e.stopImmediatePropagation();
    e.cancelBubble = true;
  },
  preventDefault = e => e.ctrlKey && e.preventDefault(),
  hourHeightLevelZero = {
    level: 0,
    step: '1 hour'
  },
  zeroRect = new Rectangle(0, 0, 0, 0),
  fiveMinuteSteps = ['30 minutes', '15 minutes', '10 minutes', '5 minutes'],
  sixMinuteSteps = ['30 minutes', '12 minutes', '6 minutes'];
/**
 * An object which contains properties which encapsulate hour height breakpoints which dictate
 * when intervening time indicators are introduced into the DayView's time axis.
 *
 * @typedef {Object} HourHeightBreakPoints
 * @property {Number} thirty The height at which half hour time is displayed.
 * @property {Number} fifteen The height at which all fifteen minute times are displayed.
 * @property {Number} ten The height at which all ten minute times are displayed.
 * @property {Number} five The height at which all five minute times are displayed.
 */
/**
 * This is normally used as a {@link Calendar.view.Calendar#config-modes mode} of a Calendar
 * but may be used standalone as a regular Widget.
 *
 * As a standalone widget, it will lack the capabilities of the {@link Calendar.view.Calendar Calendar}
 * class, such as keyboard-based event to event navigation and drag/drop features.
 *
 * A Panel which displays one or more columns of days with events for each day arranged in ascending
 * time order in each column.
 *
 * This view is *not* limited to showing weeks. The {@link #config-startDate} and {@link #config-endDate}
 * may be configured to any date value. When the {@link #config-startDate} is changed dynamically,
 * the duration remains the same.
 *
 * This view can be configured to scroll to the specific time on first render, which defaults to 7 AM. This behavior
 * is controlled by the {@link #config-visibleStartTime} config.
 *
 * A {@link Calendar.widget.WeekView WeekView} is a subclass of this view which is tied to showing
 * weeks as defined by the {@link Calendar.widget.mixin.CalendarMixin#config-weekStartDay}.
 *
 * ## Multi day events.
 *
 * All day events, and multi day events are displayed in a {@link #config-allDayEvents row at the top}.
 *
 * Intraday events are arranged in ascending time order down day columns from the {@link #config-dayStartTime} to
 * the {@link #config-dayEndTime}.
 *
 * The {@link #config-showAllDayHeader} config option can be used to *not* show multi day events at
 * the top, but have them wrap across multiple day columns.
 *
 * The following configs which apply to the all day row are passed into the configuration of the
 * {@link #config-allDayEvents} widget:
 * - {@link Calendar.widget.CalendarRow#config-overflowPopup}
 * - {@link Calendar.widget.CalendarRow#config-overflowButtonRenderer}
 * - {@link Calendar.widget.CalendarRow#config-overflowClickAction}
 * - {@link Calendar.widget.CalendarRow#config-dayHeaderRenderer}
 *
 * Event rendering can be customized using the {@link #config-eventRenderer} method.
 *
 * @extends Core/widget/Panel
 * @mixes Core/widget/mixin/Responsive
 * @mixes Calendar/widget/mixin/CalendarMixin
 * @mixes Calendar/widget/mixin/DayCellCollecter
 * @mixes Calendar/widget/mixin/DateRangeOwner
 * @classType dayview
 * @inlineexample Calendar/widget/DayView.js
 */
class DayView extends Panel.mixin(CalendarMixin, DayCellCollecter, DaySelectable, DateRangeOwner) {
  static get $name() {
    return 'DayView';
  }
  // Factoryable type name
  static get type() {
    return 'dayview';
  }
  static get delayable() {
    return {
      updateElementLayout: {
        type: 'raf',
        cancelOutstanding: true
      },
      refreshDayBackground: {
        type: 'raf',
        cancelOutstanding: true
      }
    };
  }
  static get configurable() {
    // region Hidden configs
    /**
     * @event shortEventDuration
     * @hide
     */
    // endRegion
    return {
      textContent: false,
      scrollable: {
        overflowY: true
      },
      title: 'L{Day}',
      /**
       * An empty function by default, but provided so that you can override it.
       *
       * This function is called each time an event is rendered to to allow developers to mutate
       * the cell metadata, or the CSS classes to be applied to the event element.
       *
       * It's called with the event record, and a eventData object which allows you to mutate event metadata
       * such as 'cls', 'style'.
       *
       * The cls property is an object whose property names will be added to the event element if the property value is truthy.
       *
       * The style property is an object containing style properties for the event element.
       *
       * A non-null return value from the renderer is used as the event body content. A nullish
       * return value causes the default renderer to be used which just uses the event name.
       *
       * ```javascript
       *  eventRenderer(eventRecord, eventData) {
       *      if (eventRecord.name === 'Doctors appointment') {
       *          eventData.style.fontWeight = 'bold';
       *          eventData.cls['custom-cls'] = 1;
       *
       *          return 'Special doctors appointment';
       *      }
       *  }
       * ```
       * IMPORTANT: When returning content, be sure to consider how that content should be encoded to avoid XSS
       * (Cross-Site Scripting) attacks. This is especially important when including user-controlled data such as
       * the event's `name`. The function {@link Core.helper.StringHelper#function-encodeHtml-static} as well as
       * {@link Core.helper.StringHelper#function-xss-static} can be helpful in these cases.
       *
       * For example:
       * ```javascript
       *  eventRenderer(eventRecord, eventData) {
       *      return StringHelper.xss`Event: ${eventRecord.name}`;
       *  }
       * ```
       * @config {Function} eventRenderer
       * @param {Object} detail An object that contains data about the event being rendered.
       * @param {Scheduler.model.EventModel} detail.eventRecord The event record
       * @param {Scheduler.model.ResourceModel} detail.resourceRecord The resource record
       * @param {Object} detail.renderData A data object containing properties that will be used to create the event element.
       * @param {Object} detail.renderData.style The style property is an object containing style properties for
       * the event element.
       * @param {Object} detail.renderData.cls The cls property is an object whose property names will be added to
       * the event element if the property value is truthy.
       * @param {String} detail.renderData.eventColor Color to be applied to the event
       */
      eventRenderer: null,
      eventHeight: 'auto',
      /**
       * The height __in pixels__ of one hour cell in a day column.
       *
       * Hour cells are bounded by lines, and there is a fainter half hour line in the middle.
       * @prp {Number}
       * @default
       */
      hourHeight: 42,
      range: {
        magnitude: 1,
        unit: 'day'
      },
      /**
       * By default, reconfiguring the {@link #config-startDate} maintains the current duration
       * of the view and moves the {@link #config-endDate}.
       *
       * But for flexibility, reconfiguring the {@link #config-endDate} changes the duration.
       *
       * Setting `fixedDuration` to `true` locks this down to changing either end just moves
       * the view.
       * @config {Boolean}
       */
      fixedDuration: null,
      /**
       * Either the start hour of the day, or a *24 hour * `HH:MM` string denoting the initially visible start
       * time of the day. Configure this as `null` to not have the view scroll to an initial position.
       * @default
       * @config {String|Number} [visibleStartTime]
       */
      visibleStartTime: 7,
      /**
       * Either the start hour of the day, or a *24 hour* `HH:MM` string denoting the start time for days. This
       * is midnight by default.
       *
       * Setting this value to 12, for example, indicates that the 24 hour "day" runs from noon on one day, to
       * noon on the following day. This causes events in this span of time to layout in the same day column. In
       * this example, a two hour event that spanned midnight would be rendered in the same way a normal, 2 hour
       * event spanning noon would be rendered without this option.
       *
       * When this config is non-zero, the headings that display the day name and number are adjusted to indicate
       * the range of days for the column. For example, the "Wed" column for the 12th of the month will now show
       * "Wed-Thu" for the day name and "12-13" for the day number.
       *
       * @config {String|Number}
       * @default 0
       */
      dayStartShift: null,
      /**
       * The **configured** start time of the day, expressed in ms (8am would be represented as 8 * 60 * 60 * 1000).
       * You can set this value to either an hour value (0-23), a *24 hour* `HH:MM` string denoting the start of
       * the first rendered daily time block or to a ms timestamp representing time from midnight.
       * @member {Number} dayStartTime
       */
      /**
       * Either the start hour of the day, or a *24 hour* `HH:MM` string denoting the start of the first rendered
       * daily time block. You can also set this value to a ms timestamp representing time from midnight.
       *
       * This config, along with {@link #config-dayEndTime} determines which hours are displayed in a day column.
       * @config {String|Number}
       * @default 0
       */
      dayStartTime: null,
      /**
       * The **configured** end time of the day, expressed in ms (6pm would be represented as 18 * 60 * 60 * 1000).
       * You can set this value to either an hour value (1-24), a *24 hour* `HH:MM` string denoting the end of
       * the last rendered daily time block or to a ms timestamp representing time from midnight.
       * @member {String|Number} dayEndTime
       */
      /**
       * Either the end hour of the day, or a *24 hour* `HH:MM` string denoting the end date of the last rendered time block.
       * You can also set this value to a ms timestamp representing time from midnight.
       *
       * This config, along with {@link #config-dayStartTime} determines which hours are displayed in a day column.
       * @config {String|Number}
       * @default 24
       */
      dayEndTime: null,
      dayTime: 0,
      // ensure the change/update cycle runs using dayStart/EndTime and dayStartShift
      /**
       * A millisecond value by which to round times when clicking or dragging within a day column.
       *
       * May be specified in string form eg: `'15 minutes'`
       * @config {String|Number}
       */
      increment: '15 min',
      intradayCls: null,
      /**
       * Configure as `false` to hide the start time normally shown at the top of the events.
       *
       * @config {Boolean}
       * @default
       */
      showTime: true,
      showCircle: false,
      iconTarget: 'header',
      /**
       * Configuration to manage event layout class.
       * See {@link Calendar.layout.day.FluidDayLayout} class docs to see all possible configurations.
       *
       * Defaults to `{ type : 'fluid' }`.
       *
       * @config {FluidDayLayoutConfig}
       */
      eventLayout: {
        type: 'fluid'
      },
      /**
       * The minimum width of a day column.
       *
       * If this is set, and the day columns overflow the horizontal space available, the columns
       * will be scrollable horizontally in the normal way.
       *
       * There is a {@link #property-horizontalScroller} property which handles scrolling in this
       * dimension.
       * @prp {Number|String}
       */
      minDayWidth: null,
      // In days, event colour means background color
      eventColourStyleProperty: 'backgroundColor',
      monitorResize: Boolean(DomHelper.scrollBarWidth),
      // Need to adjust the width of the header
      eventFilter: undefined,
      // Do not remove. Assertion strings for Localization sanity check.
      // 'L{timeFormat}'
      timeFormat: 'LST',
      /**
       * If {@link #config-showAllDayHeader} is not set to `false`, then this will be an instance
       * of {@link Calendar.widget.CalendarRow} which encapsulates the all day events at the top
       * of this view.
       * @member {Calendar.widget.CalendarRow} allDayEvents
       * @readonly
       */
      /**
       * A {@link Calendar.widget.CalendarRow} widget containing the horizontal series of calendar cells with the
       * day headers and any all-day, or day-spanning events which fall inside this view's time range.
       *
       * Note that this component calculates its height depending on its
       * {@link Calendar.widget.CalendarRow#config-eventHeight},
       * {@link Calendar.widget.CalendarRow#config-defaultEventRowCount} and
       * {@link Calendar.widget.CalendarRow#config-autoHeight} settings, therefore any configured `height`
       * and `flex` values will be ignored.
       * @config {Calendar.widget.CalendarRow|Object}
       */
      allDayEvents: {
        $config: ['lazy', 'nullify'],
        value: {}
      },
      /**
       * A config object used to create the {@link Calendar.widget.OverflowPopup} that the
       * {@link #property-allDayEvents} may show when events for one day overflow the available space.
       *
       * For example
       *
       *```javascript
       *     modes : {
       *         week : {
       *             overflowPopup : {
       *                 closable   : false,
       *                 dateFormat : 'dddd, MMM M',
       *                 eventRenderer({ eventRecord, renderData }) {
       *                     if (calendarUtils.isImportantEvent(eventRecord)) {
       *                         // Add CSS class to important events
       *                         renderData.cls['b-important'] = 1;
       *                     }
       *                 }
       *             }
       *         }
       *     }
       *```
       * @config {OverflowPopupConfig}
       */
      overflowPopup: null,
      /**
       * Shows an all day header above the main schedule for All Day events.
       * Set to `false` to not show all day, or multi-day events in an all day header, but
       * to have them showing wrapping through the day cells.
       * @config {Boolean}
       * @default true
       */
      showAllDayHeader: {
        value: null,
        $config: null,
        default: true
      },
      /**
       * Number of pixels to reduce the height of events by, to leave a gap between them.
       * @config {Number}
       * @default
       */
      eventSpacing: 1,
      responsive: {
        small: {
          descriptionFormat: 'MMMM YYYY'
        },
        '*': {
          descriptionFormat: null
        }
      },
      /**
       * The maximum height the all day event row is allowed to grow within this view
       * when it is expanded to show all its "all day" events.
       *
       * This defaults to `50%`, but can also be set to any CSS size value. A numeric
       * value will be taken as pixels.
       * @config {Number|String}
       * @default 50%
       */
      maxAllDayHeight: null,
      /**
       * When set to `true`, the hours in the day will be sized so that they fit in the available
       * height.
       *
       * In the Object form, the value may contain `minHeight` as the minimum hour height to which
       * the hour cells may shrink:
       *
       * ```javascript
       * fitHours : {
       *     minHeight : 31
       * }
       * ```
       *
       * Note that if the all day events row at the top changes size, the space available for the
       * hours will change too, and the hour cell height will change.
       * @prp {Boolean|Object}
       * @default false
       */
      fitHours: null,
      /**
       * A function, or name of a function which is passed the {@link DomConfig} object which
       * will be used to sync with a day column.
       *
       * ```javascript
       * dayCellRenderer : function(domConfig, cellData) {
       *     if (this.isSpecialDate(cellData.date)) {
       *         domConfig.className['b-fa'] =
       *         domConfig.className['b-fa-birthday-cake'] = 1;
       *     }
       *     return domConfig;
       * }
       *```
       *
       * The result is used to sync the DOM of the day column.
       *
       * @config {Function|String} dayCellRenderer
       * @param {DomConfig} domConfig A {@link DomConfig} config object which is used to sync the day column element.
       * @param {Object} domConfig.className An object who's truthy property names will be applied as class names.
       * @param {Object} domConfig.style A CSS style definition object.
       * @param {Object} domConfig.dataset The DOM data properties to set.
       * @param {DomConfig[]} children The {@link DomConfig} definitions for the events in the day.
       * @param {DayCell} cellData An object that contains data about the cell.
       */
      dayCellRenderer: null,
      /**
       * An object containing two properties, `start` and `end` representing the start and
       * end of core working hours.
       *
       * This causes the non core hours to be covered by a themeable translucent grey mask
       * in the time axis.
       *
       * This may be configured to also mask the non core hours in the day part of the view
       * by setting the `overlayDay` property.
       *
       * ```javascript
       * {
       *     coreHours : {
       *         start      : 9,
       *         end        : 17,
       *         overlayDay : true
       *     }
       * }
       * ```
       *
       * If this is configured as an array of less than seven elements, it is taken to be
       * describing __multiple__ core hours blocks within one day, so it could be
       *
       * ```javascript
       * {
       *     coreHours : [{
       *         start      : 8,
       *         end        : 12,
       *     }, {
       *         start      : 14,
       *         end        : 18
       *     }
       * }
       * ```
       *
       * This may also be a __seven element__ array so as to have different core hours for
       * each JavaScript day of the week (Meaning `0` for Sunday to `6` for Saturday).
       * This causes only the hours in the day columns to be masked:
       *
       * ```javascript
       * {
       *     coreHours : [{
       *         start : 10,
       *         end   : 15
       *     },{
       *         start : 9,
       *         end   : 17
       *     },{
       *         start : 9,
       *         end   : 17
       *     },{
       *         start : 9,
       *         end   : 17
       *     },{
       *         start : 9,
       *         end   : 17
       *     },{
       *         start : 9,
       *         end   : 17
       *     },{
       *         start : 10,
       *         end   : 15
       *     }]
       * }
       * ```
       *
       * This may also be a function to return calculated core hours for every date.
       * This causes only the hours in the day columns to be masked:
       *
       * ```javascript
       * {
       *     coreHours : function(date) {
       *         // Shorter core hours at weekends
       *         if (date.getDay() === 0 || date.getDay() === 6) {
       *             return {
       *                 start : '10:00',
       *                 end   : '15:00'
       *             };
       *         }
       *         // Pre-lunch and post-lunch working blocks in the week
       *         return [{
       *             start : '08:00',
       *             end   : '12:00'
       *         }, {
       *             start : '14:00',
       *             end   : '18:00'
       *         };
       *     }
       * }
       * ```
       *
       * @prp {Object|Function|String} coreHours In the simplest case an object containing two
       * properties, `start` and `end`.
       *
       * This may also be a __seven element__ array which contains s seperate core hours
       * specification for each day of the week as returned from the `Date` class.
       *
       * This may also be a function, which, when passed a `Date`, returns a core hours
       * specification for that date.
       * @param {Number|String} coreHours.start The start hour or start time string `HH:MM` of the core working hours.
       * @param {Number|String} coreHours.end The end hour or start time string `HH:MM` of the core working hours.
       * @param {Boolean} [coreHours.overlayDay] Set to `true` to have the greyed zone
       * cover the day part of the view. __Only valid when this config is specified as a
       * simple Object__.
       */
      coreHours: null,
      /**
       * You can zoom in and out on the time axis using CTRL-key + mouse wheel.
       * See also the {@link #config-hourHeightBreakpoints} config option.
       *
       * You cannot zoom so far out that the day height falls below the available height.
       *
       * __Note that zooming necessarily sets {@link #config-fitHours} to `false`.__
       *
       * Configure this as `false` to disable this behaviour.
       * @config {Boolean}
       * @default
       */
      zoomOnMouseWheel: !BrowserHelper.isTouchDevice,
      /**
       * An array which encapsulates a set of {@link #config-hourHeight} breakpoints which
       * dictate when subticks - intervening time indicators - are introduced into the DayView's
       * time axis.
       *
       * Entries are in ascending granularity order, so the values must ascend.
       *
       * Subtick visibility is updated dynamically during {@link #config-zoomOnMouseWheel zooming}.
       *
       * When an {@link #property-hourHeight} change causes a change of sub tick granularity, a
       * {@link #event-tickChange} event is fired.
       *
       * @prp {Number[]}
       * @default
       */
      hourHeightBreakpoints: [70, 140, 300, 500],
      /**
       * By default, the most granular time tick level in the DayView's time axis is five minutes.
       *
       * Set this property to `true` to have the hour split into six minute ticks.
       * @prp {Boolean}
       * @default false
       */
      sixMinuteTicks: null,
      /**
       * The minimum height to which event blocks in a day cell may shrink. If an event has very
       * short duration, whatever the {@link #config-hourHeight}, and regardless of
       * {@link #function-zoomTo timeline zooming}, the event block will never drop below this height.
       * @prp {Number|String}
       * @default
       */
      minEventHeight: '1em',
      /**
       * The event block height at which the event display rendition switches to "compact"
       * mode with the name, then start time both on the top line with a slightly smaller font.
       * @prp {Number}
       * @private
       * @default
       * @private
       */
      shortEventHeight: 32,
      /**
       * A function, or name of a function which produces a {@link DomConfig} block to create the current time indicator
       * which is displayed in a day column which represents the current date. It is the developer's responsibility
       * to add CSS classes and the appropriate CSS rules to produce the desire appearance.
       *
       * ```javascript
       * currentTimeIndicatorRenderer : function() {
       *     return {
       *         className : 'my-current-time',
       *         text      : 'NOW'
       *     };
       * }
       *```
       *
       * The result is used to sync the DOM of the day column.
       *
       * @config {Function|String} currentTimeIndicatorRenderer
       * @returns {@link DomConfig} An object which describes the DOM structure of the today indicator element.
       */
      currentTimeIndicatorRenderer: () => {
        return {
          className: 'b-current-time-indicator',
          retainElement: true
        };
      }
    };
  }
  /**
   * Returns the resource associated with this day view when used inside a {@link Calendar.widget.ResourceView}
   * @readonly
   * @member {Scheduler.model.ResourceModel} resource
   */
  construct(config) {
    var _config$scrollable;
    const me = this;
    // If we are configured to not show vertical scrolling, we must know this so that
    // scrollbar equalization can adjust to this.
    me.configuredHiddenVerticalScroll = ((_config$scrollable = config.scrollable) === null || _config$scrollable === void 0 ? void 0 : _config$scrollable.overflowY) === 'hidden-scroll';
    // Needs scope
    me.cellMapEventFilter = me.cellMapEventFilter.bind(me);
    super.construct(...arguments);
    if (!me.startDate) {
      me.startDate = me.month.date;
    }
    GlobalEvents.ion({
      theme: 'onThemeChange',
      thisObj: me
    });
  }
  get hasNonWorkingDays() {
    return true;
  }
  updateZoomOnMouseWheel(zoomOnMouseWheel) {
    if (zoomOnMouseWheel) {
      // Only respond every 50ms to keep zooming response sane to a user.
      this.zoomListener = EventHelper.on({
        element: this.dayContentElement,
        wheel: 'onDayContentMousewheel',
        thisObj: this,
        throttled: {
          buffer: 100,
          alt: preventDefault
        }
      });
    } else {
      var _this$zoomListener;
      (_this$zoomListener = this.zoomListener) === null || _this$zoomListener === void 0 ? void 0 : _this$zoomListener.call(this);
    }
  }
  get childItems() {
    const {
        allDayEvents
      } = this,
      result = super.childItems;
    if (allDayEvents) {
      result.push(allDayEvents);
    }
    return result;
  }
  get dayEndTime() {
    var _this$dayTime$timeEnd, _this$dayTime;
    return (_this$dayTime$timeEnd = (_this$dayTime = this.dayTime) === null || _this$dayTime === void 0 ? void 0 : _this$dayTime.timeEnd) !== null && _this$dayTime$timeEnd !== void 0 ? _this$dayTime$timeEnd : this._dayEndTime;
  }
  get dayStartTime() {
    var _this$dayTime$timeSta, _this$dayTime2;
    return (_this$dayTime$timeSta = (_this$dayTime2 = this.dayTime) === null || _this$dayTime2 === void 0 ? void 0 : _this$dayTime2.timeStart) !== null && _this$dayTime$timeSta !== void 0 ? _this$dayTime$timeSta : this._dayStartTime;
  }
  get dayStartShift() {
    var _this$dayTime$startSh, _this$dayTime3;
    return (_this$dayTime$startSh = (_this$dayTime3 = this.dayTime) === null || _this$dayTime3 === void 0 ? void 0 : _this$dayTime3.startShift) !== null && _this$dayTime$startSh !== void 0 ? _this$dayTime$startSh : this._dayStartShift;
  }
  updateDayEndTime(dayEndTime) {
    // When more than one of these 3 configs changes at the same time, the following will trigger the yet to be
    // realized configs, which will in turn call their updaters until the last of the batch runs its updater. In
    // that updater call, the dayTime config will be set to the new DayTime instance that has all of the correct
    // config values. The changeDayTime() method will detect a not-equals() DayTime and return it, which will run
    // updateDayTime(). The updates for the non-final configs will also call changeDayTime() but their DayTime
    // instances will all have the same properties and will not result in a call of updateDayTime().
    //
    // We also clear _dayTime so that the getters won't use the old value in our getter calls.
    this._dayTime = null;
    this.dayTime = new DayTime({
      startShift: this.dayStartShift,
      timeStart: this.dayStartTime,
      timeEnd: dayEndTime
    });
  }
  updateDayStartTime(dayStartTime) {
    this._dayTime = null;
    this.dayTime = new DayTime({
      startShift: this.dayStartShift,
      timeStart: dayStartTime,
      timeEnd: this.dayEndTime
    });
  }
  updateDayStartShift(dayStartShift) {
    this._dayTime = null;
    this.dayTime = new DayTime({
      startShift: dayStartShift,
      timeStart: this.dayStartTime,
      timeEnd: this.dayEndTime
    });
  }
  // dayTime
  changeDayTime(dayTime) {
    var _this$_dayTime;
    if (!dayTime) {
      dayTime = new DayTime(this);
    }
    if (!((_this$_dayTime = this._dayTime) !== null && _this$_dayTime !== void 0 && _this$_dayTime.equals(dayTime))) {
      return dayTime;
    }
  }
  updateDayTime(dayTime, was) {
    const me = this,
      {
        eventStore
      } = me;
    if (eventStore) {
      eventStore.registerDayIndex(dayTime);
      was && eventStore.unregisterDayIndex(was);
    }
    if (!me.isConfiguring) {
      var _me$allDayEvents;
      const {
        startDate
      } = me;
      me.syncHours();
      me.setConfig({
        date: startDate,
        startDate
      });
      (_me$allDayEvents = me.allDayEvents) === null || _me$allDayEvents === void 0 ? void 0 : _me$allDayEvents.setConfig({
        date: startDate,
        dayTime,
        startDate
      });
    }
  }
  dateKey(date) {
    return this.dayTime.dateKey(date);
  }
  dayOfDate(date) {
    return date && this.dayTime.dayOfDate(date);
  }
  /**
   * Scrolls vertically to bring an event or a time into view.
   * @param {Scheduler.model.EventModel|Date|Number} target The event to scroll to or
   * a `Date` to read the hour value from, or an hour number.
   * @param {Object} [options] How to scroll.
   * @param {'start'|'end'|'center'|'nearest'} [options.block] How far to scroll the target.
   * @param {Number} [options.edgeOffset] edgeOffset A margin around the target to bring into view.
   * @param {Object|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
   * or the number of milliseconds to animate over, or an animation config object.
   * @param {Number} [options.animate.duration] The number of milliseconds to animate over.
   * @param {String} [options.animate.easing] The name of an easing function.
   * @param {Boolean} [options.highlight] Set to `true` to highlight the target when it is in view, _if the target is an `EventModel`_.
   * @param {Boolean} [options.focus] Set to `true` to focus the target when it is in view.
   * @param {Boolean} [options.x] Pass as `false` to disable scrolling in the `X` axis.
   * @param {Boolean} [options.y] Pass as `false` to disable scrolling in the `Y` axis.
   * @returns {Promise} A promise which is resolved when the target has been scrolled into view.
   */
  async scrollTo(target, options = {
    animate: true
  }) {
    const me = this,
      {
        allDayEvents
      } = me;
    if (me.scrollPromise) {
      await me.scrollPromise;
    }
    // If the all day event row is in transition, wait until it's done
    await (allDayEvents === null || allDayEvents === void 0 ? void 0 : allDayEvents.heightAnimation);
    // Component might get destroyed by the time promises above get resolved
    if (me.isDestroyed) {
      return;
    }
    // Convert hour number to a time in our start date
    if (typeof target === 'number') {
      target = DateHelper.add(me.startDate, target, 'hour');
    }
    const targetIsDate = Boolean(target.getHours);
    // CalendarMixin knows how to do this.
    // If it's a Date It must not scroll vertically; we do that below.
    await super.scrollTo(target, Object.assign({}, options, {
      y: !targetIsDate
    }));
    // Scrolling to a Date is more granular in this view
    if (targetIsDate) {
      target = target.getHours() + target.getMinutes() / 60;
      return me.scrollable.scrollTo(null, me.getPositionFromTime(target), options);
    }
  }
  getEventElement(event, date) {
    var _this$allDayEvents;
    return super.getEventElement(event, date) || ((_this$allDayEvents = this.allDayEvents) === null || _this$allDayEvents === void 0 ? void 0 : _this$allDayEvents.getEventElement(event, date));
  }
  getEventElements(event) {
    var _this$allDayEvents2;
    return super.getEventElements(event) || ((_this$allDayEvents2 = this.allDayEvents) === null || _this$allDayEvents2 === void 0 ? void 0 : _this$allDayEvents2.getEventElements(event));
  }
  /**
   * Returns the pixel coordinate on the time axis for the passed time of day.
   * @param {Date|Number|String} time The hour number, 'HH:MM' time or a `Date` instance.
   * @internal
   * @returns {Number}
   */
  getPositionFromTime(time) {
    // If it's not possible, return 0. DayTime returns the positive delta.
    if (DayTime.parse(time) < DayTime.parse(this.dayStartTime) - this.dayStartShift) {
      return 0;
    }
    return this.dayTime.delta(time, 'h') * this.hourHeight;
  }
  updateShowAllDayHeader(showAllDayHeader) {
    var _me$_cellMap, _allDayEvents$_cellMa;
    const me = this,
      {
        _allDayEvents
      } = me;
    (_me$_cellMap = me._cellMap) === null || _me$_cellMap === void 0 ? void 0 : _me$_cellMap.clear();
    _allDayEvents === null || _allDayEvents === void 0 ? void 0 : (_allDayEvents$_cellMa = _allDayEvents._cellMap) === null || _allDayEvents$_cellMa === void 0 ? void 0 : _allDayEvents$_cellMa.clear();
    if (_allDayEvents) {
      _allDayEvents.element.classList.toggle('b-hide-allday-header', !showAllDayHeader);
      _allDayEvents.refresh();
    }
    me.refresh();
  }
  changeAllDayEvents(alldayEvents, oldAlldayEvents) {
    // Shortcut nullifying the allDayEvents property
    if (!alldayEvents) {
      return oldAlldayEvents === null || oldAlldayEvents === void 0 ? void 0 : oldAlldayEvents.destroy();
    }
    this.getConfig('date'); // ensure we have startDate/endDate setup if we were given a date
    const me = this,
      {
        autoCreate,
        dayHeaderRenderer,
        overflowButtonRenderer,
        overflowClickAction,
        overflowPopup,
        avatarRendering,
        range
      } = me,
      result = CalendarRow.reconfigure(oldAlldayEvents, alldayEvents, {
        owner: me,
        defaults: {
          type: 'calendarrow',
          calendar: me.calendar,
          parent: me,
          rtl: me.rtl,
          cls: {
            'b-dayview-schedule-container': 1,
            'b-dayview-initializing': 1
          },
          // If we were configured with any of the following, they were obviously intended for use
          // by the all day row
          [overflowPopup !== undefined ? 'overflowPopup' : '_']: overflowPopup,
          [overflowButtonRenderer ? 'overflowButtonRenderer' : '_']: overflowButtonRenderer,
          [overflowClickAction ? 'overflowClickAction' : '_']: overflowClickAction,
          [dayHeaderRenderer ? 'dayHeaderRenderer' : '_']: dayHeaderRenderer,
          [avatarRendering ? 'avatarRendering' : '_']: avatarRendering,
          // This view always autoCreates allDay events starting at midnight
          autoCreate: autoCreate ? {
            newName: autoCreate.newName,
            gesture: autoCreate.gesture,
            startHour: 0,
            duration: '1 day'
          } : null,
          // Only signal a dayNumberClick on a click on the day number element.
          // Allow clicks in the surrounding header to be used to create new events.
          dayNameSelector: '.b-day-name-date',
          // Must use the same configured event filter as us in addition to only showing
          // the all day and interDay events
          eventFilter: e => me.showAllDayHeader && me.isAllDayEvent(e) && (!me.eventFilter || me.eventFilter(e)),
          dayStartTime: me.dayStartTime,
          dayEndTime: me.dayEndTime,
          dayStartShift: me.dayStartShift,
          eventRenderer: me.eventRenderer,
          eventStore: me.eventStore,
          month: me.month,
          fullWeek: me.duration === 1,
          startDate: me.startDate,
          [range ? 'range' : '_']: range,
          [range ? '_' : 'endDate']: me.endDate,
          nonWorkingDays: me.nonWorkingDays,
          nonWorkingDayCls: me.nonWorkingDayCls,
          weekendCls: me.weekendCls,
          weekStartDay: me.weekStartDay,
          defaultCalendar: me.defaultCalendar,
          emptyCellRenderer: me.emptyCellRenderer,
          internalListeners: {
            heightChange: 'updateElementLayout',
            refresh: 'updateElementLayout',
            catchall: 'relayAllDayEvents',
            showoverflowpopup: 'onAllDayOverflowPopupShown',
            thisObj: me
          },
          // If all day row does not render events, the day part must fire
          // the creation signal so that responders such as EventEdit can do right things.
          editAutoCreatedEvent(eventRecord) {
            (me.showAllDayHeader ? this : me).trigger('eventAutoCreated', {
              eventRecord
            });
          },
          // If we are not showing all day events, always return an empty Map
          createCellMap() {
            return me.showAllDayHeader ? this.constructor.prototype.createCellMap.call(this, ...arguments) : me.emptyMap || (me.emptyMap = new Map());
          }
        },
        setup(config) {
          // We need to postprocess the inheriting of hideNonWorkingDays after
          // we know how external configurations have played into the full config.
          // If we are showing only one day, then hiding non working days is invalid
          config.hideNonWorkingDays = me.duration === 1 && !config.fullWeek ? false : me._hideNonWorkingDays;
        }
      });
    // It's null on destroy
    if (result) {
      // The all day row must control its own height.
      // These configs must be ignored.
      result.height = result.flex = null;
      // The all day row is not in control of its date range.
      // If we ever have to scroll to another date, this entire view does that
      // before handing control on to the all day row widget.
      me.originalAllDayEventsScrollTo = result.scrollTo;
      result.scrollTo = me.allDayEventsScrollTo.bind(me);
    }
    return result;
  }
  // We have to be able to yield the underbar property so that Calendar can ask if there is an
  // overflowPopup for a child view without triggering its creation.
  onAllDayOverflowPopupShown({
    overflowPopup
  }) {
    this._overflowPopup = overflowPopup;
  }
  // This is what gets called when the all day row is asked to scrollTo
  // We have control of what it does. It does not have control of its date range.
  allDayEventsScrollTo(target) {
    const me = this,
      newDate = target.isEvent ? target.startDate : me.changeEndDate(target),
      dateIntersects = target.isEvent ? DateHelper.intersectSpans(me.startDate, me.endDate, target.startDate, target.endDate) : DateHelper.betweenLesser(newDate, me.startDate, me.endDate);
    // If we do not encompass the date, move to the date.
    if (!dateIntersects) {
      me.date = newDate;
    }
    // Now CalendarRow can have at it.
    return me.originalAllDayEventsScrollTo.call(me.allDayEvents, ...arguments);
  }
  updateAutoCreate(autoCreate) {
    var _super$updateAutoCrea;
    // Use the property name so as not to ingest the lazy config at configure time
    const {
      _allDayEvents
    } = this;
    (_super$updateAutoCrea = super.updateAutoCreate) === null || _super$updateAutoCrea === void 0 ? void 0 : _super$updateAutoCrea.call(this, autoCreate);
    if (_allDayEvents) {
      _allDayEvents.autoCreate = autoCreate ? {
        newName: autoCreate.newName,
        gesture: autoCreate.gesture,
        startHour: 0,
        duration: '1 day'
      } : false;
    }
  }
  updateWeekStartDay(weekStartDay, oldWeekStartDay) {
    var _super$updateWeekStar;
    (_super$updateWeekStar = super.updateWeekStartDay) === null || _super$updateWeekStar === void 0 ? void 0 : _super$updateWeekStar.call(this, weekStartDay);
    if (!this.isConfiguring && this.allDayEvents) {
      this.allDayEvents.weekStartDay = weekStartDay;
    }
  }
  updateEventStore(eventStore, was) {
    super.updateEventStore(eventStore, was);
    const {
      dayTime
    } = this;
    if (dayTime) {
      eventStore === null || eventStore === void 0 ? void 0 : eventStore.registerDayIndex(dayTime);
      was === null || was === void 0 ? void 0 : was.unregisterDayIndex(dayTime);
    }
  }
  /**
   * The {@link Calendar.widget.OverflowPopup} instance that the {@link #property-allDayEvents}
   * may show when events for one day overflow the available space.
   * @member {Calendar.widget.OverflowPopup} overflowPopup
   * @readonly
   */
  get overflowPopup() {
    var _this$_allDayEvents;
    // If we don't have _allDayEvents yet, return the underlying config.
    return ((_this$_allDayEvents = this._allDayEvents) === null || _this$_allDayEvents === void 0 ? void 0 : _this$_allDayEvents.overflowPopup) || this._overflowPopup;
  }
  get stepUnit() {
    return this.duration > 1 ? `${this.duration} ${this.L('L{daysUnit}')}` : this.L('L{dayUnit}');
  }
  get eventContentElement() {
    return this.dayContainerElement;
  }
  getDateFromDomEvent(domEvent, precise = false) {
    let date = super.getDateFromDomEvent(domEvent);
    const me = this,
      el = DomHelper.getEventElement(domEvent);
    // Override to add a time component to the DOM event's date if we receive and event (not an element) and
    // the event was in the day container.
    if (date && el !== domEvent && me.dayContainerElement.contains(el)) {
      date = DateHelper.add(date, me.dayStartHour - me.dayStartShift / 3600000 + (domEvent.clientY - me.scrollable.element.getBoundingClientRect().y + me.scrollable.y) / me.hourHeight, 'hour');
      if (!precise) {
        date = DateHelper.round(date, me.increment);
      }
    }
    return date;
  }
  getDateFromPosition(clientX, clientY, local = false) {
    const me = this,
      {
        eventContentElement,
        allDayEvents
      } = me,
      dayElements = me.dayContainerElement.querySelectorAll(`.${me.dayCellCls}`),
      rect = local ? zeroRect : Rectangle.fromScreen(eventContentElement).roundPx().translate(-eventContentElement.scrollLeft),
      width = eventContentElement.scrollWidth,
      {
        height
      } = Rectangle.fromScreen(dayElements[0]).roundPx(),
      localX = local ? clientX : clientX - rect.x,
      dx = me.rtl ? me.eventContentElement.offsetWidth - localX : localX,
      dy = clientY - rect.y,
      weekLength = dayElements.length,
      col = Math.min(Math.floor(dx / width * weekLength), dayElements.length - 1);
    if (allDayEvents && (dx < 0 || width < dx || dy < 0 || height < dy)) {
      return allDayEvents.getDateFromPosition(clientX, clientY);
    }
    let date = me.getDateFromElement(dayElements[0]);
    // Some days may be hidden.
    if (me.hideNonWorkingDays) {
      const cellDates = Array.from(dayElements).map(e => me.getDateFromElement(e));
      date = cellDates[col];
    } else if (col) {
      date.setDate(date.getDate() + col);
    }
    // DateHelper.add() operates in UTC and therefore does not respect DST, so we cannot do this:
    //   DH.add(DH.clearTime(date), me.dayStartMs + Math.floor(dy / height * me.getDayLength()), 'ms')
    // Instead, we leverage setMilliseconds()'s ability to handle denormalized values:
    DateHelper.clearTime(date, /*clone = */false);
    date.setMilliseconds(date.getMilliseconds() + me.dayStartMs + Math.floor(dy / height * me.getDayLength()));
    return DateHelper.round(date, me.increment);
  }
  // We must implement the CalendarMixin interface.
  // All views must expose a doRefresh method.
  doRefresh() {
    const me = this;
    if (me.isVisible) {
      var _me$calendar;
      // Opt out of animations while we refresh to avoid reused elements resizing
      DomHelper.addTemporaryClass(me.element, 'b-no-transitions', 200, me);
      const children = [];
      // Calculate this for getDayDomConfig only once per refresh.
      me.today = me.dayTime.startOfDay(((_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.dateTimeNow) || new Date());
      // Create day cell child array. DomSync ignores null array entries which is what
      // getDayDomConfig returns for hidden days.
      for (const date = new Date(me.startDate); date < me.endDate; date.setDate(date.getDate() + 1)) {
        children.push(me.getDayDomConfig(date));
      }
      DomSync.sync({
        targetElement: me.dayContainerElement,
        domConfig: {
          onlyChildren: true,
          children,
          // Match existing data-date elements first and ensure DOM order matches
          // children order.
          syncOptions: {
            syncIdField: 'date',
            releaseThreshold: 0,
            strict: true
          }
        }
      });
      // In case height has changed since last refresh.
      me.refreshDayBackground();
      me.refreshCount = (me.refreshCount || 0) + 1;
      me.syncCurrentTimeIndicator();
      /**
       * Fires when this DayView refreshes.
       * @param {Calendar.widget.DayView} source The triggering instance.
       * @event refresh
       */
      me.trigger('refresh');
    }
  }
  getBaseDayDomConfig(date) {
    const me = this,
      key = me.dayTime.dateKey(date),
      cellData = me.cellMap.get(key) || me.createCellData(date),
      // dayCellRenderer & timeRanges need one
      day = cellData.day,
      nonWorkingDays = me.nonWorkingDays || me.month.nonWorkingDays;
    // Return nullish for hidden days unless it's a single day view.
    // Hiding non working days is only for multi day views.
    return (!me.hiddenNonWorkingDays[date.getDay()] || me.duration === 1) && [cellData, {
      dataset: {
        date: key
      },
      className: {
        'b-dayview-day-detail': 1,
        [me.dayCellCls]: 1,
        [me.nonWorkingDayCls]: nonWorkingDays[day] || false,
        [me.weekendCls]: DateHelper.weekends[day],
        [me.todayCls]: !(date - me.today),
        'b-last-cell': !(date - me.lastVisibleDate),
        [`b-day-of-week-${day}`]: 1
      },
      style: {},
      children: {
        inset: {
          className: {
            'b-dayview-inset': 1
          }
        },
        events: {
          className: {
            'b-dayview-event-container': 1
          },
          children: []
        }
      },
      // Match existing data-event-id elements first and ensure DOM order matches
      // children order.
      syncOptions: {
        syncIdField: 'eventId',
        releaseThreshold: 0,
        strict: true
      }
    }];
  }
  getDayDomConfig(date) {
    const me = this,
      base = me.getBaseDayDomConfig(date);
    if (base) {
      const {
          dayCellRenderer
        } = me,
        [cellData, dayDomConfig] = base;
      if (me.coreHours) {
        // If our coreHours yields a callable function, ask it the coreHours for this date.
        // If it is an array, extract the coreHours for the day.
        // Set up the background image to create the effect.
        dayDomConfig.style.backgroundImage = me.getCoreHoursGradient(me.getCoreHoursForDate(date));
      }
      // Render events if any. Call even if we have no events to allow beforeLayoutEvents event to fire and
      // listeners to act (e.g., timeRanges)
      me.renderEvents(cellData, dayDomConfig);
      return DomHelper.normalizeChildren(dayCellRenderer ? me.callback(dayCellRenderer, me, [dayDomConfig, cellData]) : dayDomConfig);
    }
  }
  /**
   * Calculates A CSS `linear-gradient` specification from a {@link #config-coreHours} definition object.
   *
   * A core hours object consists ot two properties, `start` and `end`. It may also be an array containing
   * multiple core hours definitions.
   * @param {Object} coreHours
   * @param {Number|String} coreHours.start The start hour or start time string `HH:MM` of the core working hours.
   * @param {Number|String} coreHours.end The start hour or end time string `HH:MM` of the core working hours.
   * @returns A String containing a `linear-gradient` style which shades non-working times using the
   * `--dayview-outside-core-hours-color` CSS variable.
   * @internal
   */
  getCoreHoursGradient(coreHours) {
    // No background image gradient if no core hours specified.
    if (!coreHours) {
      return '';
    }
    const me = this,
      {
        dayTime
      } = me,
      dayEnd = dayTime.duration('h'),
      result = ['linear-gradient(to bottom'];
    // Convert a single time block into an array, we need to handle multiple
    // time blocks.
    coreHours = ArrayHelper.asArray(coreHours);
    let lastEnd = 0;
    for (let i = 0, {
        length
      } = coreHours; i < length; i++) {
      const c = coreHours[i],
        start = Math.max(dayTime.delta(c.start, 'h'), 0) / dayEnd * 100,
        end = Math.min(dayTime.delta(c.end, 'h'), dayEnd) / dayEnd * 100;
      // If the working block for the day is the whole day, we don't need a background
      if (length === 1 && start === 0 && end === 100) {
        return '';
      }
      // Blocked hours prior to this working block
      if (lastEnd < start) {
        result.push(`var(--dayview-outside-core-hours-color) ${DomHelper.percentify(lastEnd)}, var(--dayview-outside-core-hours-color) ${DomHelper.percentify(start)}`);
      }
      result.push(`transparent ${DomHelper.percentify(start)}, transparent ${DomHelper.percentify(end)}`);
      lastEnd = end;
    }
    // Closing blocked out hours if any
    if (lastEnd < 100) {
      result.push(`var(--dayview-outside-core-hours-color) ${DomHelper.percentify(lastEnd)}, var(--dayview-outside-core-hours-color) 100%`);
    }
    return result.join(',') + ')';
  }
  getCoreHoursForDate(date) {
    const {
      coreHours
    } = this;
    // It's an array for each day
    if (coreHours.length === 7) {
      return coreHours[date.getDay()];
    }
    // Object or array of objects
    if (typeof coreHours === 'object') {
      // Core hours as a simple object only applies to dates if overlayDay set.
      return coreHours.overlayDay ? coreHours : null;
    }
    // Must be a callback
    return this.callback(coreHours, this, [date]);
  }
  /**
   * Refreshes the event layout inside a day column in case the stacking order becomes incorrect.
   * @param {Date} date
   * @internal
   */
  refreshDayEvents(date) {
    const me = this;
    // Promote YYYY-MM-DD keys to Dates
    date = me.changeEndDate(date);
    // getDayDomConfig reads this.
    me.today = me.dayTime.startOfDay(new Date());
    const domConfig = me.getDayDomConfig(date);
    // Opt out of animations while we refresh to avoid reused elements resizing
    DomHelper.addTemporaryClass(me.element, 'b-no-transitions', 200, me);
    domConfig.onlyChildren = true;
    DomSync.sync({
      targetElement: me.getDayElement(date),
      domConfig
    });
  }
  /**
   * Pushes event bar DomConfig definitions into the `children` property of the passed
   * `dayDomConfig` object
   * @param {DayCell} cellData An object containing information about the day cell being created.
   * @param {DomConfig} dayDomConfig The DomConfig element definition for the day cell.
   * @internal
   */
  renderEvents(cellData, dayDomConfig) {
    const me = this,
      context = me.eventLayout.layoutEvents(cellData, dayDomConfig),
      {
        items
      } = context,
      {
        eventSpacing,
        rtl
      } = me;
    for (const item of items) {
      const eventDomConfig = me.createEventDomConfig({
        eventRecord: item.eventRecord
      });
      // Set the classes for the event overflowing the *visible* day if it's cropped.
      eventDomConfig.className['b-starts-above'] = item.startsBefore;
      eventDomConfig.className['b-ends-below'] = item.endsAfter;
      if (item.cluster.items.length > 1) {
        eventDomConfig.className['b-cal-in-cluster'] = 1;
      }
      Object.assign(eventDomConfig.style, _objectSpread2({
        // Leave eventSpacing pixels at the bottom by reducing the available content height.
        // The event-wrap's default background-color is transparent.
        // This is to create the appearance of the event-spacing config.
        [eventSpacing ? 'padding-bottom' : '']: `${eventSpacing}px`
      }, item.getStyles(rtl)));
      dayDomConfig.children.events.children.push(eventDomConfig);
    }
    me.trigger('renderEvents', {
      context
    });
  }
  get overflowElement() {
    // The vertical scrolling element
    return this.dayContentElement;
  }
  get cellMap() {
    var _this$_cellMap;
    // If the cellMap has not been populated, create it.
    return (_this$_cellMap = this._cellMap) !== null && _this$_cellMap !== void 0 && _this$_cellMap.populated ? this._cellMap : this.createCellMap();
  }
  get bodyConfig() {
    const me = this,
      {
        allDayEvents,
        maxAllDayHeight
      } = me;
    return Object.assign(super.bodyConfig, {
      children: {
        alldayRowElement: allDayEvents ? {
          className: {
            'b-dayview-allday-row': 1
          },
          style: {
            [maxAllDayHeight ? 'maxHeight' : '']: DomHelper.setLength(maxAllDayHeight)
          },
          children: {
            cornerElement: {
              className: {
                'b-dayview-allday-row-start': 1,
                'b-dayview-allday-autoheight': allDayEvents.autoHeight
              },
              children: {
                allDayTextElement: {
                  className: 'b-dayview-allday-text',
                  html: me.L('L{EventEdit.All day}')
                },
                allDayToggleIcon: {
                  tag: 'button',
                  className: 'b-expand-allday-button b-icon b-icon-expand-row',
                  dataset: {
                    btip: 'L{DayView.expandAllDayRow}'
                  }
                }
              }
            },
            allDayEvents: allDayEvents === null || allDayEvents === void 0 ? void 0 : allDayEvents.element,
            // May have been configured away
            $scrollerPad: DomHelper.scrollBarPadElement // $ prefix -> not a reference
          }
        } : null,
        dayContentElement: {
          tabIndex: -1,
          className: {
            'b-dayview-day-content': 1
          },
          children: {
            timeAxisElement: {
              children: me.getTimeElementConfigs(),
              className: {
                'b-timeaxis-container': 1
              }
            },
            dayContainerElement: {
              className: {
                'b-dayview-day-container': 1
              }
            }
          }
        },
        horizontalScrollerElement: {
          className: 'b-virtual-scrollers b-hide-display',
          children: [{
            className: 'b-virtual-scroller'
          }, DomHelper.scrollBarPadElement]
        }
      }
    });
  }
  onDayContentMousewheel(e) {
    if (e.ctrlKey) {
      e.preventDefault();
      const pointerOffsetY = e.clientY - this.scrollable.element.getBoundingClientRect().y,
        reqDelta = -Math.min(Math.abs(e.deltaY), 10) * Math.sign(e.deltaY);
      this.zoomBy(reqDelta, pointerOffsetY);
    }
  }
  /**
   * Zooms the timeline by incrementing the {@link #property-hourHeight} by the requested pixel delta.
   * @param {Number} reqDelta The number of pixels by which to increment the {@link #property-hourHeight}
   * @param {Number|String} [zoomCenter] The center time to zoom in to. This may be a number of pixels
   * down the DayView viewport, or it may be a time to use as the center in the format `HH:MM:ss`.
   * __If omitted, the visual central time in the viewport is used__.
   */
  zoomBy(reqDelta, zoomCenter = Math.min(this.scrollable.scrollHeight, this.scrollable.clientHeight) / 2 - 1) {
    // Ensure the layout is up to date before we measure things
    this.updateElementLayout.cancel();
    const me = this,
      {
        scrollable,
        hourHeight: oldHourHeight
      } = me,
      // Round the zoom center date to our configured snap point so that the view stays steady.
      // Use x as center to 99% likely avoid Sundays which are DST switch days which break fixed timepoint
      zoomCenterTime = DateHelper.round(typeof zoomCenter === 'number' ? me.getDateFromPosition(me.dayContainerElement.offsetWidth / 2, zoomCenter + scrollable.y, true) : DateHelper.parse(zoomCenter, 'HH:mm:ss'), me.increment),
      hoursInDay = me.getDayLength('h'),
      newHourHeight = Math.max(oldHourHeight + reqDelta, me.dayContentClientHeight / hoursInDay),
      pointerOffsetY = me.getPositionFromTime(zoomCenterTime) - scrollable.y;
    // When the day layout has been done, keep the zoom center time still.
    me.ion({
      layoutUpdate: () => {
        scrollable.scrollTo(null, me.getPositionFromTime(zoomCenterTime) - pointerOffsetY);
        // Sync partners synchronously so there's no delay in a multi-view mode like ResourceView
        scrollable.syncPartners(false, true);
      },
      once: true,
      prio: 1000
    });
    // Zooming obviously breaks fitting the hours into the space.
    me.fitHours = false;
    // Invalidate the day layout
    me.hourHeight = newHourHeight;
  }
  /**
   * Zooms the timeline by setting the {@link #property-hourHeight} to the requested pixel value.
   * @param {Number} newHourHeight The new {@link #property-hourHeight} in pixels.
   * @param {Number|String} [zoomCenter] The center time to zoom in to. This may be a number of pixels
   * down the DayView viewport, or it may be a time to use as the center in the format `HH:MM:ss`.
   * __If omitted, the visual center of the viewport is used__.
   */
  zoomTo(newHourHeight, zoomCenter) {
    this.zoomBy(newHourHeight - this.hourHeight, zoomCenter);
  }
  createCellMap() {
    const {
      showAllDayHeader
    } = this;
    // We only want events which start and end *in* each date.
    // These will not propagate forwards anyway, so skip propagation.
    // By default filter by our dayFilter which skips events in non working days
    // and events outside of our configured start/end time range.
    // We must also honour any configured eventFilter
    return super.createCellMap({
      dayTime: this.dayTime,
      // Normally, DayView only displays intraday events, so only those which start *on*
      // the cell's date and only those which fit completely *inside* the cell's date.
      // showDayHeader flips those assumptions because all intersecting events need to
      // be collected because we have nowhere else to show interday events.
      startOnly: showAllDayHeader,
      allowPartial: !showAllDayHeader,
      skipPropagate: true,
      rawEvents: true,
      filter: this.cellMapEventFilter
    });
  }
  cellMapEventFilter(eventRecord) {
    const {
      dayTime,
      hiddenNonWorkingDays,
      showAllDayHeader
    } = this;
    // DayView rejects events which span days unless showAllDayHeader is false.
    // In which case we have to show them across multiple day cells.
    return (!showAllDayHeader || dayTime.isIntraDay(eventRecord) && !eventRecord.allDay) &&
    // Event is eligible if it's within our view's day start/end range
    dayTime.intersects(eventRecord) &&
    // AND it's not in a hidden nonworking day
    !hiddenNonWorkingDays[dayTime.dayOfWeek(eventRecord.startDate)];
  }
  getDayLength(as = 'ms') {
    return this.dayTime.duration(as);
  }
  changeIncrement(increment) {
    if (typeof increment === 'string') {
      increment = DateHelper.parseDuration(increment);
      return DateHelper.as('ms', increment.magnitude, increment.unit);
    }
    return increment;
  }
  get dayStartHour() {
    return this.dayStartTime == null ? 0 : Math.floor(this.dayStartTime / MILLIS_PER_HOUR);
  }
  get dayEndHour() {
    return this.dayEndTime == null ? 24 : Math.ceil(this.dayEndTime / MILLIS_PER_HOUR);
  }
  get dayStartMs() {
    return this.dayStartTime == null ? 0 : this.dayStartTime;
  }
  get dayEndMs() {
    return this.dayEndTime == null ? 24 * MILLIS_PER_HOUR : this.dayEndTime;
  }
  /**
   * This is the increment in milliseconds from the floored day start hour to the configured day start time.
   *
   * This is used to calculate the offset by which to move the timeAxis ticks when the start is not on an hour boundary.
   * @internal
   */
  get dayStartOffset() {
    return this.dayTime.startTimeOffsetMs / MILLIS_PER_HOUR * this.hourHeight;
  }
  changeEventFilter(filter) {
    if (filter === undefined) {
      filter = event => !this.isAllDayEvent(event);
    }
    return filter;
  }
  changeEventLayout(config, existing) {
    return DayLayout.reconfigure(existing, config, {
      owner: this,
      defaults: {
        owner: this
      }
    });
  }
  updateNonWorkingDays(nonWorkingDays) {
    var _super$updateNonWorki;
    const me = this;
    (_super$updateNonWorki = super.updateNonWorkingDays) === null || _super$updateNonWorki === void 0 ? void 0 : _super$updateNonWorki.call(this, nonWorkingDays);
    me._allDayEvents && (me._allDayEvents.nonWorkingDays = nonWorkingDays);
    if (!me.isConfiguring) {
      var _me$_cellMap2;
      (_me$_cellMap2 = me._cellMap) === null || _me$_cellMap2 === void 0 ? void 0 : _me$_cellMap2.clear();
      me.refresh();
    }
  }
  updateMaxAllDayHeight(maxAllDayHeight) {
    DomHelper.setLength(this.alldayRowElement, 'max-height', maxAllDayHeight);
  }
  get hideNonWorkingDays() {
    // Hiding non working days is only valid for multi day views
    return this._hideNonWorkingDays === true && this.duration === 1 ? false : this._hideNonWorkingDays;
  }
  set hideNonWorkingDays(hideNonWorkingDays) {
    super.hideNonWorkingDays = hideNonWorkingDays;
  }
  updateHideNonWorkingDays(hideNonWorkingDays) {
    const me = this,
      {
        _allDayEvents
      } = me;
    super.updateHideNonWorkingDays(hideNonWorkingDays);
    // Pass out *property* here, because if we're a single day view, hideNonWorkingDays
    // always yields false. Hiding non working days is only valid for multi day views
    _allDayEvents && (_allDayEvents.hideNonWorkingDays = me.duration === 1 && !_allDayEvents.fullWeek ? false : me._hideNonWorkingDays);
    if (!me.isConfiguring) {
      var _me$_cellMap3;
      (_me$_cellMap3 = me._cellMap) === null || _me$_cellMap3 === void 0 ? void 0 : _me$_cellMap3.clear();
      me.refresh();
    }
  }
  syncHours() {
    var _me$_cellMap4;
    const me = this;
    (_me$_cellMap4 = me._cellMap) === null || _me$_cellMap4 === void 0 ? void 0 : _me$_cellMap4.clear();
    DomSync.sync({
      targetElement: me.timeAxisElement,
      childrenOnly: true,
      domConfig: {
        children: me.getTimeElementConfigs()
      }
    });
    // We need to update and measure immediately, before the refresh
    me.updateElementLayout.now();
    me.refresh();
  }
  syncCurrentTimeIndicator() {
    var _me$calendar2;
    const me = this,
      now = ((_me$calendar2 = me.calendar) === null || _me$calendar2 === void 0 ? void 0 : _me$calendar2.dateTimeNow) || new Date(),
      dayElement = me.getDayElement(now),
      {
        currentTimeIndicator,
        dayTime,
        endDate,
        startDate
      } = me;
    if (startDate && endDate) {
      if (dayElement && DateHelper.betweenLesser(now, startDate, endDate) && dayTime.contains(now)) {
        const dayLengthMs = me.getDayLength('ms'),
          nowMS = dayTime.delta(now, 'ms');
        if (currentTimeIndicator.parentNode !== dayElement) {
          dayElement === null || dayElement === void 0 ? void 0 : dayElement.appendChild(currentTimeIndicator);
        }
        currentTimeIndicator.style.top = DomHelper.percentify(nowMS / dayLengthMs * 100);
      } else {
        currentTimeIndicator.remove();
      }
    }
  }
  get currentTimeIndicator() {
    return this._currentTimeIndicator || (this._currentTimeIndicator = DomHelper.createElement(this.callback(this.currentTimeIndicatorRenderer, this)));
  }
  getTimeElementConfigs() {
    const me = this,
      result = [],
      {
        dayTime
      } = me,
      {
        startHour
      } = dayTime,
      date = new Date(2000, 5, 15, startHour, 0, 0),
      hours = dayTime.duration('h');
    for (let h, i = 1; i <= hours; i++) {
      // Ticks come from the previous hour.
      // The hour value is the ending tick of the hour cell
      const ticks = me.createLeafTicks(date);
      // Move to the ending hour
      date.setHours(h = date.getHours() + 1);
      date.setMinutes(0);
      result.push({
        className: `b-dayview-timeaxis-time b-dayview-timeaxis-time-${h < 10 ? '0' : ''}${h}`,
        children: ticks.concat([{
          className: 'b-dayview-timeaxis-tick b-dayview-hour-tick',
          text: DateHelper.format(date, me.timeFormat)
        }])
      });
    }
    // TimeAxis can only show the core hours if they are the same for every day
    if (me.coreHours && me._simpleCoreHours) {
      result.unshift({
        className: 'b-dayview-timeaxis-background',
        style: {
          backgroundImage: me.getCoreHoursGradient(me.coreHours)
        }
      });
    }
    return result;
  }
  createLeafTicks(date) {
    return this[this.sixMinuteTicks ? 'createSixMinuteTicks' : 'createFiveMinuteTicks'](date);
  }
  createFiveMinuteTicks(date) {
    const result = [];
    for (let i = 1; i < 12; i++) {
      date.setMinutes(i * 5);
      result.push({
        className: {
          'b-dayview-timeaxis-tick': 1,
          'b-dayview-tick-level-4': 1,
          // Five minutes
          'b-dayview-tick-level-3': !(i & 1),
          // Ten minutes
          'b-dayview-tick-level-2': !(i % 3),
          // Fifteen minutes
          'b-dayview-tick-level-1': i === 6 // Half hour
        },

        text: DateHelper.format(date, this.timeFormat)
      });
    }
    return result;
  }
  createSixMinuteTicks(date) {
    const result = [];
    for (let i = 1; i < 10; i++) {
      date.setMinutes(i * 6);
      result.push({
        className: {
          'b-dayview-timeaxis-tick': 1,
          'b-dayview-tick-level-3': 1,
          // Six minutes
          'b-dayview-tick-level-2': !(i & 1),
          // Twelve minutes
          'b-dayview-tick-level-1': i === 5 // Half hour
        },

        text: DateHelper.format(date, this.timeFormat)
      });
    }
    return result;
  }
  changeCoreHours(coreHours) {
    const me = this;
    // Same core hours for every day
    me._simpleCoreHours = ObjectHelper.isObject(coreHours) || Array.isArray(coreHours) && coreHours.length !== 7;
    if (me._simpleCoreHours) {
      // In case we are sharing this via modeDefaults. We must own a copy
      coreHours = ObjectHelper.clone(coreHours);
      coreHours._overlayDay = coreHours.overlayDay;
      Object.defineProperty(coreHours, 'overlayDay', {
        set(v) {
          this._overlayDay = v;
          me.updateCoreHours();
        },
        get(v) {
          return this._overlayDay;
        }
      });
    }
    return coreHours;
  }
  updateCoreHours() {
    if (!this.isConfiguring) {
      this.syncHours();
    }
  }
  changeStartDate() {
    // Base class gets a chance to veto the change
    return this.dayOfDate(super.changeStartDate(...arguments));
  }
  updateStartDate(startDate) {
    const {
      _allDayEvents
    } = this;
    // Keep all day row in time sync
    if (_allDayEvents) {
      this._allDayEvents.setConfig({
        date: this.date,
        startDate
      });
    }
    super.updateStartDate(...arguments);
  }
  changeEndDate() {
    // Base class gets a chance to veto the change
    return this.dayOfDate(super.changeEndDate(...arguments));
  }
  updateEndDate(endDate) {
    var _super$updateEndDate;
    const {
      _allDayEvents
    } = this;
    (_super$updateEndDate = super.updateEndDate) === null || _super$updateEndDate === void 0 ? void 0 : _super$updateEndDate.call(this, ...arguments);
    // Keep all day row in time sync
    if (_allDayEvents && !this.updatingRange) {
      this._allDayEvents.setConfig({
        date: this.date,
        endDate
      });
    }
  }
  changeMinDayWidth(minDayWidth) {
    // null must be returned to mean no minWidth because undefined signals no change.
    return typeof minDayWidth === 'number' ? Math.max(minDayWidth, 50) : null;
  }
  updateMinDayWidth(minDayWidth) {
    this.contentElement.style.setProperty('--min-day-width', DomHelper.setLength(minDayWidth));
    this._allDayEvents && (this._allDayEvents.minDayWidth = minDayWidth);
    this.updateElementLayout();
  }
  updateHourHeight(hourHeight) {
    this.shortEventDuration = 3600000 / (hourHeight / this.shortEventHeight);
    if (!this.isConfiguring) {
      // All we need to do is recalculate our CSS properties and hour height class indicator
      this.updateElementLayout();
      // hourHeight may have changed, some events may change their b-short-event state
      if (this.fitHours) {
        this.refresh();
      }
    }
  }
  updateShortEventHeight(shortEventHeight) {
    this.updateHourHeight(this.hourHeight);
  }
  updateMinEventHeight(minEventHeight) {
    this.contentElement.style.setProperty('--dayview-min-event-height', DomHelper.setLength(minEventHeight));
  }
  get hourHeight() {
    // Order of the boolean expression is important:
    // We do not want to interrogate this.fitHours if we are configuring.
    return !this.isConfiguring && this.fitHours ? Math.max(this.dayContentClientHeight / this.getDayLength('hour'), this.minHourHeight) : this._hourHeight;
  }
  changeFitHours(fitHours) {
    if (fitHours !== null && fitHours !== void 0 && fitHours.minHeight) {
      // Set a hard minimum. Even a phone in portrait mode could show a schedule at 9px per hour
      this.minHourHeight = Math.max(fitHours.minHeight, 9);
    } else {
      // If they don't specify a minimum, we use 17.
      // Odd numbers are better. Avoids fractional pixels in background line generation.
      this.minHourHeight = 17;
    }
    return fitHours;
  }
  get dayContentClientHeight() {
    return DomHelper.floorPx(Rectangle.client(this.dayContentElement).height);
  }
  updateFitHours(fitHours) {
    const me = this;
    if (!me.isConfiguring) {
      // We only need to change the hourHeight if we are moving *to* fitting
      fitHours && (me.hourHeight = Math.max(me.dayContentClientHeight / me.getDayLength('hour'), me.minHourHeight));
    }
    me.element.classList.toggle('b-fit-hours', Boolean(fitHours));
    me.monitorResize = DomHelper.scrollBarWidth || fitHours;
  }
  updateEventSpacing() {
    if (!this.isConfiguring) {
      var _this$_cellMap2;
      (_this$_cellMap2 = this._cellMap) === null || _this$_cellMap2 === void 0 ? void 0 : _this$_cellMap2.clear();
      this.refresh();
    }
  }
  onPaint({
    firstPaint
  }) {
    const me = this,
      {
        dayContainerElement,
        horizontalScrollerElement
      } = me,
      {
        scrollBarWidth
      } = DomHelper;
    if (firstPaint) {
      // This will be the first read of the allDayEvents property and will
      // trigger ingestion of allDayEvents and its upgrade into an instance of CalendarRow
      const {
        allDayEvents
      } = me;
      /**
       * A Scroller which encapsulates horizontal scrolling of the view in case a {@link #config-minDayWidth}
       * setting causes the days to overflow the available width.
       * @member {Core.helper.util.Scroller} horizontalScroller
       */
      me.horizontalScroller = new Scroller({
        widget: me,
        element: dayContainerElement,
        overflowX: scrollBarWidth ? 'hidden-scroll' : true,
        overflowY: 'clip'
      });
      if (allDayEvents) {
        allDayEvents.element.classList.remove('b-dayview-initializing');
        me.horizontalScroller.addPartner(allDayEvents.headerScroller);
      }
      ResizeMonitor.addResizeListener(me.dayContainerElement, me.onDayContainerResize.bind(me));
      // We need the scroller even if the UI is overlay scrollbars.
      // Because the scrollbar needs to be docked at the bottom while content scrolls.
      me.scrollbarScroller = new Scroller({
        widget: me,
        element: horizontalScrollerElement.firstChild,
        scrollWidth: dayContainerElement.scrollWidth - scrollBarWidth,
        overflowX: true,
        overflowY: false
      });
      me.horizontalScroller.addPartner(me.scrollbarScroller);
      me.refresh();
      me.updateElementLayout.now();
      me.setInterval(me.syncCurrentTimeIndicator.bind(me), 30 * 1000, 'syncCurrentTimeIndicator');
      if (allDayEvents) {
        EventHelper.on({
          click: {
            element: me.cornerElement,
            handler: 'onCornerClick'
          },
          // The scrollbar padding must not bubble any mousemove events to dragdrop.
          // This is because a mouseover of the allDay row *may*, if there are no
          // all day events, cause expansion of the allDay row, which *may* cause
          // vertical overflow, which *may* on some platforms cause this padding element
          // to pop into visibility below the cursor which would then cause
          // a dragleave.
          mousemove: {
            element: me.allDayEvents.element.nextSibling,
            handler: stopEvent,
            capture: true
          },
          thisObj: me
        });
        // If, through window resizing, or changing hourHeight, the scrollbar status flips
        // we have to run the scrollbar syncing.
        me.scrollable.ion({
          overflowChange: 'syncScrollbarPadding',
          thisObj: me
        });
      }
      me.scrollToVisibleStartTime();
    }
  }
  scrollToVisibleStartTime() {
    if (this.visibleStartTime != null) {
      const me = this,
        {
          scrollable
        } = me,
        startScrollPos = me.getPositionFromTime(me.visibleStartTime),
        doScroll = () => {
          scrollable.scrollTo(null, startScrollPos, {
            animate: false,
            block: 'start'
          });
        };
      // If at this startup phase, the scroll was not possible due to the clientHeight
      // being too high, it *may* become possible after the allDayEvents animates to
      // a new height because of its events, so wait a short time for that scenario.
      if (startScrollPos > scrollable.maxY && !me.scrollToStartTimer && me.allDayEvents) {
        me.scrollToStartTimer = me.allDayEvents.ion({
          heightChange: doScroll,
          once: true,
          expires: {
            delay: 5000,
            alt: doScroll
          },
          name: 'scrollToVisibleStartTime'
        });
      } else {
        doScroll();
      }
    }
  }
  relayAllDayEvents(event) {
    const {
      type
    } = event;
    // Don't relay every type of event
    if (!blockedAllDayEvents[type]) {
      return this.trigger(type, event);
    }
  }
  async onCornerClick() {
    const {
      allDayEvents
    } = this;
    if (!allDayEvents.isAnimating) {
      await allDayEvents.toggleExpandCollapse();
      if (!this.isDestroyed) {
        this.allDayToggleIcon.dataset.btip = allDayEvents.expanded ? this.L('L{collapseAllDayRow}') : this.L('L{expandAllDayRow}');
      }
    }
  }
  syncScrollbarPadding() {
    // configuredHiddenVerticalScroll means that we must not show a scrollbar, so none of this
    // must execute. ResourceView uses this and docks a fake scroller at its trailing edge.
    // We only have anything to sync if we have an allDayEvents widget.
    if (!this.configuredHiddenVerticalScroll && this.allDayEvents) {
      if (DomHelper.scrollBarWidth) {
        if (!this.allDayEvents.isAnimating) {
          const {
              allDayEvents,
              alldayRowElement,
              scrollable
            } = this,
            fitHours = this.fitHours && scrollable.clientHeight / this.getDayLength('hour') >= this.minHourHeight,
            // fitHours means we'll never overflow
            hasOverflow = !fitHours && scrollable.hasOverflow(),
            {
              headerElement,
              scrollable: verticalScroller
            } = allDayEvents,
            expanded = allDayEvents.expanded || allDayEvents.autoHeight,
            // Will only have overflow if it's expanded
            allDayHasOverflow = Boolean(expanded && verticalScroller.hasOverflow());
          // Day view AND all day view both have vertical overflow.
          // Only the all day view *header* has to fake one to match.
          if (hasOverflow && allDayHasOverflow) {
            headerElement.classList.add('b-show-yscroll-padding');
            alldayRowElement.classList.remove('b-show-yscroll-padding');
            scrollable.overflowY = verticalScroller.overflowY = 'auto';
          }
          // Both in different overflowY states.
          else if (allDayHasOverflow !== hasOverflow) {
            // ONLY the all day view overflows, so allday *header* must show padding
            // and the day view must show a scrollbar
            if (allDayHasOverflow) {
              headerElement.classList.add('b-show-yscroll-padding');
              verticalScroller.overflowY = 'auto';
              scrollable.overflowY = 'scroll';
            }
            // ONLY the day view overflows, so that all day must show its scrollbar padding
            // But the all day header must not.
            else {
              headerElement.classList.remove('b-show-yscroll-padding');
              alldayRowElement.classList.add('b-show-yscroll-padding');
              verticalScroller.overflowY = 'hidden';
              scrollable.overflowY = !fitHours && 'auto';
            }
          }
          // Neither of the two views overflow
          else {
            alldayRowElement.classList.remove('b-show-yscroll-padding');
            headerElement.classList.remove('b-show-yscroll-padding');
            scrollable.overflowY = !fitHours && 'auto';
            verticalScroller.overflowY = 'hidden';
          }
        }
      }
      // If scrollbars are overlayed when scrolling we can always have the two views scrollable
      else {
        this.scrollable.overflowY = this.allDayEvents.scrollable.overflowY = 'auto';
      }
    }
  }
  onInternalResize(element, width, height, oldWidth, oldHeight) {
    const {
      _allDayEvents: allDayEvents
    } = this;
    super.onInternalResize(element, width, height, oldWidth, oldHeight);
    // Don't update on the initial render resize from no dimensions.
    // That is handled by onPaint({ firstPaint })
    if (oldHeight) {
      allDayEvents === null || allDayEvents === void 0 ? void 0 : allDayEvents.performResizeRefresh(allDayEvents.eventsPerCell, allDayEvents.eventContainerTop);
      if (height !== oldHeight) {
        this.updateElementLayout();
        this.syncScrollbarPadding();
      }
    }
  }
  onThemeChange() {
    this.updateElementLayout();
  }
  // Only the day container *height* is of interest generally.
  // Unless we have had a minDayWidth set and we show scrollbars, in which case horizontal scrolling
  // may come and go and the horizontalScrollerElement which shows a scrollbar might need toggling.
  onDayContainerResize(el, {
    height: oldHeight
  } = {}, {
    height
  }) {
    if (oldHeight && (height !== oldHeight || DomHelper.scrollBarWidth && this.minDayWidth)) {
      this.updateElementLayout();
      // Must recalculate the hour height if fitHours is set.
      if (this.fitHours) {
        this.updateFitHours(this.fitHours);
      }
    }
  }
  async updateElementLayout() {
    var _this$owner;
    if (!this.refreshCount || (_this$owner = this.owner) !== null && _this$owner !== void 0 && _this$owner.isDestroyed) {
      return;
    }
    const me = this,
      {
        dayContainerElement,
        horizontalScrollerElement,
        horizontalScroller,
        allDayEvents
      } = me,
      dayElements = dayContainerElement.querySelectorAll(`.${me.dayCellCls}`),
      {
        scrollBarWidth
      } = DomHelper;
    let i, end;
    // AllDayEVents expander needs to know whether there's overflow
    if (allDayEvents) {
      const cornerElementClassList = me.cornerElement.classList;
      if (allDayEvents.hasOverflow) {
        cornerElementClassList.add('b-has-cell-overflow');
        cornerElementClassList.toggle('b-expanded', Boolean(allDayEvents.expanded));
      } else {
        cornerElementClassList.remove('b-has-cell-overflow');
      }
    }
    // Hour lines now. We are in an AF.
    me.refreshDayBackground.now();
    for (i = 0, end = dayElements.length - 1; i <= end; i++) {
      dayElements[i].classList.toggle('b-last-cell', i === end);
    }
    // Hide/show the pseudo horizontal scrollbar that we show on scrollbar displaying platforms.
    if (allDayEvents) {
      me.syncScrollbarPadding();
    }
    if (scrollBarWidth) {
      horizontalScrollerElement.classList.toggle('b-show-yscroll-padding', me.scrollable.hasOverflow());
    }
    // Handle DayViews with zero days. These can be used as standalone TimeAxes.
    // Horizontal scrollbar has to be present if there's overflow even if scrollbars overlayed
    // in this case they are position:absolute.
    if (dayElements.length) {
      // Forced synchronous layout here, but we need to ascertain horizontal overflow state
      if (me.minDayWidth && dayContainerElement.scrollWidth > dayContainerElement.clientWidth) {
        const dayWidth = me.minDayWidth || (dayElements.length ? dayElements[0].offsetWidth : 0),
          totalDayWidth = dayWidth * dayElements.length;
        horizontalScrollerElement.classList.remove('b-hide-display');
        me.scrollbarScroller.scrollWidth = totalDayWidth;
        horizontalScroller.overflowX = 'hidden-scroll';
      } else {
        horizontalScrollerElement.classList.add('b-hide-display');
        horizontalScroller.overflowX = false;
      }
    }
    /**
     * Fires when this DayView changes an aspect of its layout. This happens when changing
     * {@link #property-hourHeight}, {@link #property-minDayWidth}, and when the available
     * day container height changes.
     * @event layoutUpdate
     * @param {Calendar.widget.DayView} source The triggering instance.
     */
    me.trigger('layoutUpdate');
  }
  refreshDayBackground() {
    const me = this,
      {
        contentElement,
        hourHeight,
        dayStartOffset,
        _hourHeightLevel,
        hourHeightLevel
      } = me,
      dayContentCls = me.dayContentElement.classList,
      dayLength = me.getDayLength('hour'),
      dayHeight = hourHeight * dayLength,
      halfHourHeight = (hourHeight - 1) / 2,
      fiveMinuteHeight = (hourHeight - 1) / 12,
      sixMinuteHeight = (hourHeight - 1) / 10,
      contentElementStyle = contentElement.style,
      // Take the longest possible date and format it with the `timeFormat`, then estimate approximate space
      // required for the time.
      timeAxisWidth = Math.ceil(DateHelper.format(widestDate, me.timeFormat).length / 2);
    dayContentCls.remove('b-dayview-hourheight-level-1', 'b-dayview-hourheight-level-2', 'b-dayview-hourheight-level-3', 'b-dayview-hourheight-level-4');
    dayContentCls.add(`b-dayview-hourheight-level-${hourHeightLevel.level}`);
    contentElementStyle.setProperty('--time-axis-width', `${timeAxisWidth}em`);
    contentElementStyle.setProperty('--day-length', dayLength);
    contentElementStyle.setProperty('--day-height', `${dayHeight}px`);
    contentElementStyle.setProperty('--hour-height', `${hourHeight}px`);
    contentElementStyle.setProperty('--half-hour-height', `${halfHourHeight}px`);
    contentElementStyle.setProperty('--five-minute-height', `${fiveMinuteHeight}px`);
    contentElementStyle.setProperty('--leaf-tick-height', `${me.sixMinuteTicks ? sixMinuteHeight : fiveMinuteHeight}px`);
    contentElementStyle.setProperty('--day-start-offset', `${dayStartOffset}px`);
    if (hourHeightLevel.level !== (_hourHeightLevel === null || _hourHeightLevel === void 0 ? void 0 : _hourHeightLevel.level)) {
      /**
       * Triggered when changing the {@link #property-hourHeight} causes an
       * {@link #config-hourHeightBreakpoints hour height breakpoint} to be crossed
       * and the displayed subTick intervals in the time axis change.
       *
       * @event tickChange
       * @param {Object} old The old hour height tick resolution object.
       * @param {Number} old.level The level `0` to `4` where `0` is the default with no
       * subTick times displayed, and `4` means every 5 minute time is displayed.
       * @param {String} old.step The time duration of visible subTicks. This is a string in the format
       * required by {@link Core.helper.DateHelper#function-parseDuration-static}
       * @param {Object} new The new hour height tick resolution object.
       * @param {Number} new.level The level `0` to `4` where `0` is the default with no
       * subTick times displayed, and `4` means every 5 minute time is displayed.
       * @param {String} new.step The time duration of visible subTicks. This is a string in the format
       * required by {@link Core.helper.DateHelper#function-parseDuration-static}
       */
      me.trigger('tickChange', {
        old: _hourHeightLevel || hourHeightLevelZero,
        new: hourHeightLevel
      });
    }
  }
  updateSixMinuteTicks() {
    if (!this.isConfiguring) {
      this.updateElementLayout();
    }
  }
  changeHourHeightBreakpoints(hourHeightBreakpoints) {
    // Convert from 5.2.x object format
    if (!Array.isArray(hourHeightBreakpoints)) {
      return Object.values(hourHeightBreakpoints);
    }
    return hourHeightBreakpoints;
  }
  updateHourHeightBreakpoints() {
    if (!this.isConfiguring) {
      this.updateElementLayout();
    }
  }
  get hourHeightLevel() {
    const me = this,
      {
        hourHeight,
        hourHeightBreakpoints,
        sixMinuteTicks
      } = me,
      steps = sixMinuteTicks ? sixMinuteSteps : fiveMinuteSteps;
    // Convert object format
    for (let i = sixMinuteTicks ? 2 : 3; i >= 0; i--) {
      if (hourHeight >= hourHeightBreakpoints[i]) {
        return me._hourHeightLevel = {
          level: i + 1,
          step: steps[i]
        };
      }
    }
    return me._hourHeightLevel = hourHeightLevelZero;
  }
  updateLocalization() {
    if (!this.isConfiguring && this.allDayTextElement) {
      DomSync.sync({
        targetElement: this.allDayTextElement,
        domConfig: {
          html: this.L('L{EventEdit.All day}')
        }
      });
    }
    super.updateLocalization();
  }
}
DayView.initClass();
DayView._$name = 'DayView';

/**
 * @module Calendar/widget/ModeSelector
 */
/**
 * Displays the set of calendar modes. The modes can be displayed as a {@link Core.widget.ButtonGroup} or a single
 * {@link Core.widget.Button} with a {@link Core.widget.Button#config-menu}. Which presentation is used depends on
 * the {@link #config-minified} config property. By default, this is set
 * {@link Core.widget.mixin.Responsive#config-responsive responsively} in order to present the best UI for different
 * screen sizes.
 *
 * @extends Core/widget/Container
 * @classType calendarModeSelector
 * @widget
 */
class ModeSelector extends Container.mixin(Fencible, Minifiable, Responsive) {
  //region Config

  get hideNonWorkingDays() {
    var _this$calendar;
    return (_this$calendar = this.calendar) === null || _this$calendar === void 0 ? void 0 : _this$calendar.hideNonWorkingDays;
  }
  set hideNonWorkingDays(value) {
    const {
      calendar
    } = this;
    // If the current value of calendar.hideNonWorkingDays is null, it is acting as false, so don't bother to
    // set it if value is also false. If we do, that would push the value down to each mode which would mask a
    // value that may be set directly on the child view.
    if (calendar && !(!value && calendar.hideNonWorkingDays == null)) {
      calendar.hideNonWorkingDays = value;
    }
  }
  changeIncludeWeekendsButton(config, existing) {
    var _me$calendar;
    const me = this,
      includeWeekendsButton = config && ((_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.includeWeekendsButton);
    if (includeWeekendsButton) {
      // Calendar may have false/null for its config but we ignore such values. In that case, the button will be
      // hidden by CSS rules (not destroyed)
      config = Button.mergeConfigs(config, includeWeekendsButton);
    }
    if (config && !existing) {
      return me.add(config);
    }
    return Button.reconfigure(existing, config, /* owner = */me);
  }
  updateIncludeWeekendsButton(includeWeekendsButton) {
    if (includeWeekendsButton) {
      includeWeekendsButton.toggleGroup = null;
    }
    this.syncFullWeek();
  }
  changeIncludeWeekendsMenuItem(config, existing) {
    var _this$button;
    const menu = this === null || this === void 0 ? void 0 : (_this$button = this.button) === null || _this$button === void 0 ? void 0 : _this$button.menu;
    if (config && !existing) {
      return menu === null || menu === void 0 ? void 0 : menu.add(config);
    }
    return MenuItem.reconfigure(existing, config, /* owner = */menu);
  }
  updateIncludeWeekendsMenuItem() {
    this.syncFullWeek();
  }
  onBeforeFirstShowModeMenu({
    menu
  }) {
    const me = this,
      {
        calendar
      } = me,
      {
        activeView
      } = calendar,
      modes = Object.values(calendar.modes);
    let menuItem, mode;
    for (mode of modes) {
      menuItem = mode.$modeMenuItem;
      menu.add(menuItem);
      // We cannot set the check state until after adding to the menu or else we will fail to find the correct
      // rootElement and toggle group
      menuItem.checked = mode === activeView;
      // Wire up handler after setting "checked" (we don't want to be called as we set things up)
      menuItem.onToggle = 'up.onToggleMenuItem';
    }
    me.getConfig('includeWeekendsMenuItem');
    me.syncFullWeek();
    me.menuReady = true;
  }
  addMode(name, view, options) {
    const me = this,
      {
        buttonBar
      } = me,
      // We cannot add items to the menu at this time because the menu will not be assigned to a rootElement
      // as yet which is problematic for floated widgets. So, instead we create the MenuItem widgets and attach
      // them to their view and add them to the button's menu just before it is shown.
      //  NOPE - menuItem = me.button.menu.add(MenuItem.mergeConfigs({
      menuItem = view.$modeMenuItem = MenuItem.reconfigure(view.$modeMenuItem, MenuItem.mergeConfigs({
        type: MenuItem,
        view: view,
        // Button carries a reference to the view it shows
        ref: `${name}ShowMenuItem`,
        checked: false,
        closeParent: true,
        toggleGroup: `${me.id}-modeSelectorMenuItem`,
        localizable: false,
        text: view.displayName,
        weight: 0
      }, options)),
      button = buttonBar.add(Button.mergeConfigs({
        view: view,
        // Button carries a reference to the view it shows
        ref: `${name}ShowButton`,
        toggleGroup: `${me.id}-modeSelectorButton`,
        text: view.displayName,
        localizable: false,
        onBeforeToggle: 'up.onBeforeToggleButton',
        onToggle: 'up.onToggleButton',
        weight: 0
      }, options));
    me.getConfig('includeWeekendsButton');
    view.ion({
      thisObj: me,
      localized() {
        button.text = view.displayName;
        menuItem.text = view.displayName;
      }
    });
  }
  onBeforeToggleButton({
    pressed
  }) {
    // Effectively disable button toggling during animated card change
    if (pressed && this.calendar.viewContainer.layout.isChangingCard) {
      return false;
    }
  }
  onToggleButton({
    source,
    pressed
  }) {
    if (pressed) {
      this.calendar.mode = source.view;
    }
  }
  updateDisabled(disabled) {
    // When disabling, disable all buttons except the one that just got pressed - the focused one.
    this.buttonBar.items.forEach(button => {
      if (!disabled || !button.containsFocus) {
        button.disabled = disabled;
      }
    });
  }
  onToggleMenuItem({
    source,
    checked
  }) {
    if (checked) {
      this.calendar.mode = source.view;
    }
  }
  onToggleWorkingDaysButton({
    pressed
  }) {
    this.hideNonWorkingDays = !pressed;
  }
  onToggleWorkingDaysMenu({
    checked
  }) {
    this.hideNonWorkingDays = !checked;
  }
  syncActiveMode(activeView) {
    const me = this,
      buttons = me.buttonBar.items;
    let item;
    me.button.text = activeView.displayName;
    me.includeWeekendsButton.hidden = !activeView.hasNonWorkingDays;
    me.syncFullWeek();
    // These loops would call onToggleButton/MenuItem if it weren't for Fencible
    for (item of buttons) {
      if (item.view) {
        item.pressed = item.view === activeView;
      }
    }
    if (me.menuReady) {
      for (item of me.button.menu.items) {
        var _item$view;
        if (((_item$view = item.view) === null || _item$view === void 0 ? void 0 : _item$view.$modeMenuItem) === item) {
          // if (a calendar mode item)
          item.checked = item.view === activeView;
        }
      }
    }
    // Don't show the mode selector if there's only one view
    me[buttons.length > 1 ? 'show' : 'hide']();
  }
  syncFullWeek() {
    const {
        calendar,
        hideNonWorkingDays,
        _includeWeekendsButton: includeWeekendsButton,
        _includeWeekendsMenuItem: includeWeekendsMenuItem
      } = this,
      fullWeek = !hideNonWorkingDays;
    if (!calendar.isConfiguring) {
      if (includeWeekendsButton) {
        includeWeekendsButton.pressed = fullWeek;
      }
      if (includeWeekendsMenuItem) {
        includeWeekendsMenuItem.checked = fullWeek;
      }
    }
  }
  changeButton(config, existing) {
    return Button.reconfigure(existing, config);
  }
  updateButton(button) {
    button && this.add(button);
  }
  changeButtonBar(config, existing) {
    return ButtonGroup.reconfigure(existing, config);
  }
  updateButtonBar(buttonBar) {
    buttonBar && this.add(buttonBar);
  }
  changeCalendar(calendar) {
    if (calendar && !calendar.isWidget) {
      calendar = this.up(calendar);
    }
    return calendar;
  }
  updateCalendar(calendar) {
    this.detachListeners('cal');
    this.syncFullWeek();
    calendar === null || calendar === void 0 ? void 0 : calendar.ion({
      name: 'cal',
      changeHideNonWorkingDays: 'syncFullWeek',
      thisObj: this
    });
  }
}
// Register this feature type with its Factory
_defineProperty(ModeSelector, "$name", 'ModeSelector');
_defineProperty(ModeSelector, "type", 'calendarmodeselector');
_defineProperty(ModeSelector, "configurable", {
  // Since Minifiable is @internal for now
  /**
   * Set to `false` to prevent this widget from assuming is {@link #config-minified} form automatically (for
   * example, due to {@link Core.widget.Toolbar#config-overflow} handling.
   *
   * When this value is `true` (the default), the minifiable widget's {@link #config-minified} config may be
   * set to `true` to reduce toolbar overflow.
   *
   * @config {Boolean}
   * @default
   */
  minifiable: true,
  /**
   * Set to `true` to present this widget in its minimal form.
   * @config {Boolean}
   * @default false
   */
  minified: null,
  /**
   * The button or button config object that will display a popup menu to select the calendar mode.
   * @config {Core.widget.Button}
   */
  button: {
    type: 'button',
    icon: 'b-icon-calendar-days',
    // avoid b-icon-menu since toolbar overflow also uses that icon
    cls: 'b-calendar-mode-button',
    menuIcon: null,
    menu: [],
    internalListeners: {
      beforeShowMenu: 'up.onBeforeFirstShowModeMenu',
      once: true
    }
  },
  /**
   * The button group or button group config object that will display the calendar modes, one per button.
   * @config {Core.widget.ButtonGroup}
   */
  buttonBar: {
    type: 'buttongroup',
    ignoreParentReadOnly: true
  },
  calendar: {
    value: 'calendar',
    $config: 'lazy'
  },
  includeWeekendsButton: {
    $config: 'lazy',
    value: {
      type: 'button',
      cls: 'b-calendar-fullweek-button',
      toggleGroup: `no`,
      // so ButtonGroup does not take over
      text: 'L{ModeSelector.weekends}',
      tooltip: 'L{ModeSelector.includeWeekends}',
      onToggle: 'up.onToggleWorkingDaysButton',
      weight: -1
    }
  },
  includeWeekendsMenuItem: {
    $config: 'lazy',
    value: {
      separator: true,
      text: 'L{ModeSelector.includeWeekends}',
      checked: false,
      onToggle: 'up.onToggleWorkingDaysMenu',
      weight: 10
    }
  },
  layout: {
    type: 'box',
    wrap: false
  },
  overflowable: 'none',
  responsive: {
    large: {
      // Allow toolbar overflow to kick us into minified state
      minifiable: true,
      minified: null
    },
    '*': {
      // Don't allow toolbar overflow to kick us out of minified state
      minifiable: false,
      minified: true
    }
  },
  responsiveTarget: '@calendar'
});
_defineProperty(ModeSelector, "fenced", {
  onToggleButton: true,
  onToggleMenuItem: true,
  syncFullWeek: true,
  syncActiveMode: {
    all: 'syncActiveMode',
    lock: ['onToggleButton', 'onToggleMenuItem', 'syncActiveMode']
  }
});
ModeSelector.initClass();
ModeSelector._$name = 'ModeSelector';

/**
 * @module Calendar/widget/MonthView
 */
const evRegexp = /^(\d+)ev$/,
  expandGestures = {
    shrinkwrap: 1,
    expand: 1
  };
/**
 * This is normally used as a {@link Calendar.view.Calendar#config-modes mode} of a Calendar
 * but may be used standalone as a regular Widget.
 *
 * As a standalone widget, it will lack the capabilities of the {@link Calendar.view.Calendar Calendar}
 * class, such as keyboard-based event to event navigation and drag/drop features.
 *
 * A Panel which displays a single month in a calendar like view.
 *
 * Cell rendering can be customized using the {@link #config-dayCellRenderer} method.
 *
 * Event rendering can be customized using the {@link Calendar.widget.mixin.EventRenderer#config-eventRenderer} method.
 *
 * @extends Core/widget/CalendarPanel
 * @mixes Core/widget/mixin/Responsive
 * @mixes Calendar/widget/mixin/DayCellCollecter
 * @mixes Calendar/widget/mixin/DayCellRenderer
 * @mixes Calendar/widget/mixin/CalendarMixin
 * @classType monthview
 * @inlineexample Calendar/widget/MonthView.js
 */
class MonthView extends CalendarPanel.mixin(CalendarMixin, DayCellCollecter, DayCellRenderer) {
  static get $name() {
    return 'MonthView';
  }
  // Factoryable type name
  static get type() {
    return 'monthview';
  }
  static get configurable() {
    return {
      eventSorter: EventSorter.interDaySorterFn,
      localizableProperties: ['title', 'stepUnit'],
      title: 'L{Month}',
      stepUnit: 'L{monthUnit}',
      localeClass: this,
      descriptionFormat: 'MMMM, YYYY',
      dayNumberCentered: null,
      /**
       * The height of event bars in this view. This can be a numeric value in pixels or a CSS unit measure such
       * as `'2em'`.
       * @config {Number|String}
       * @default
       */
      eventHeight: 20,
      minHeight: 485,
      /**
       * By default, weeks rows all flex to share the available height equally.
       *
       * To make them shrinkwrap their events to show all events in every row, configure this as `true`
       *
       * __Note:__ When rows shrinkwrap their events, rows with no events will shrink in size to
       * only show their header and a small, clickable area. Use the {@link #config-minRowHeight}
       * config if you want to avoid this:
       *
       * ```javascript
       * // 1/6 as a percentage - the default height of a calendar row
       * minRowHeight : `${1/6*100}%`
       * ```
       * @prp {Boolean}
       * @default false
       */
      autoRowHeight: {
        $config: 'lazy',
        value: false
      },
      /**
       * The maximum number of events to show in a cell when the row is shrinkwrapped.
       * Use this to keep rows to a sane size when using {@link #config-autoRowHeight},
       * or the {@link Calendar.feature.WeekExpander} feature.
       * @config {Number}
       * @default
       */
      maxEventsPerCell: 100,
      /**
       * By default, week rows flex to share available Panel height equally.
       *
       * This may be configured as a number, in which case it means pixels, or a CSS length.
       *
       * The non-standard unit `ev` may also be specified to mean "events". For example
       * `'3ev'` means rows will always be three events bars (plus the day header)
       * tall.
       *
       * This is a useful config when using {@link #config-autoRowHeight}, or using
       * {@link #config-overflowClickAction} when rows may be switched to shrinkwrapping
       * their event content and may shrink in height.
       *
       * Setting this config causes the month grid to become scrollable in the `Y` axis.
       * @config {Number|String}
       */
      minRowHeight: null,
      /**
       * How the view responds to clicking on a `+n more` button in an overflowing day cell.
       *
       * The default value, `'popup'`, means that a small dialog box showing the full complement
       * of events for that cell is shown aligned to the cell.
       *
       * When set to `'expand'`, then clicking the `+n more` button causes the encapsulating
       * row to expand to accommodate all events in that row with no overflow.
       *
       * Navigating to a new month resets the row to its default, flexed height.
       * @config {'popup'|'expand'} overflowClickAction
       * @default
       */
      overflowClickAction: 'popup',
      // So that when clicking the prev and next buttons, the UI will change
      // even if a cell for the new date is present.
      alwaysRefreshOnMonthChange: true
    };
  }
  static get delayable() {
    return {
      syncCalendarWeekDaysWithScrollable: {
        type: 'raf',
        cancelOutstanding: true
      },
      // Need to handle cleanup after the row collapse animation
      // in the next AF so that all scrolling has been recalculated
      // and the overflowY can be set accurately
      onAllWeekElementsCollapsed: {
        type: 'raf',
        cancelOutstanding: true
      }
    };
  }
  onCalendarStoreChange() {
    super.onCalendarStoreChange(...arguments);
    // Keep any shrinkwrapped rows in the correct shape
    this.syncShrinkwrappedRows();
  }
  onDateChange({
    changes
  }) {
    // When month changes, keep any shrinkwrapped rows in the correct shape
    if (changes.m) {
      this.syncShrinkwrappedRows();
    }
  }
  /**
   * Returns the resource associated with this month view when used inside a {@link Calendar.widget.ResourceView}
   * @readonly
   * @member {Scheduler.model.ResourceModel} resource
   */
  // Override from DayCellRenderer
  // Called automatically on the CellOverflow${overflowPopupTrigger} event because of callOnFunctions
  onCellOverflowGesture({
    date
  }) {
    if (expandGestures[this.overflowClickAction.toLowerCase()]) {
      this.shrinkwrapWeekRow(date);
    } else {
      super.onCellOverflowGesture(...arguments);
    }
  }
  // addCellHeaderContent mutates the cellHeader DomConfig block.
  // And if we are to have a day name element, returns the DomConfig for it.
  // It's called from DayCellRenderer#getCellDomConfig
  addCellHeaderContent(cellHeader, cellData) {
    const dayName = {
      className: {
        'b-day-name': true
      }
    };
    // showWeekColumn refers to the extra week number cell.
    // MonthView shows the week in the first day cell if that's *false*
    cellHeader.children = [cellData.visibleColumnIndex || this.showWeekColumn ? null : {
      className: 'b-week-num',
      text: cellData.week[1]
    }, dayName];
    return dayName;
  }
  get shrinkwrappedRows() {
    return this.weeksElement.querySelectorAll('.b-shrinkwrapped');
  }
  get shrinkwrapRowHeights() {
    const me = this,
      rowHeights = [],
      {
        cellMap
      } = me;
    me.month.eachWeek((week, [date]) => {
      let eventCount = 0;
      for (let i = 0; i < 7; i++, date.setDate(date.getDate() + 1)) {
        const cellData = cellMap.get(DateHelper.makeKey(date));
        if (cellData) {
          eventCount = Math.max(eventCount, cellData.renderedEvents.length);
        }
      }
      rowHeights.push(eventCount);
    });
    return rowHeights.map(maxEventCount => me.eventHeightInPixels * maxEventCount + me.eventSpacing * (maxEventCount + 1) + Math.ceil(me._eventContainerTop));
  }
  /**
   * Returns the number of complete event bars which will fit inside the referenced cell.
   *
   * It's only in MonthView when some rows are shrinkwrapped round their event content (meaning
   * either expanded or contracted away from the 1/6 height default) that there may be a customized
   * eventsPerCell for a certain date.
   * @internal
   */
  getEventsPerCell(date) {
    const me = this;
    if (me.hasShrinkwrappedRows) {
      const rowIndex = Math.floor(DateHelper.diff(me.startDate, date, 'd') / 7);
      // For a shrinkwrapped row, all events are rendered, so use the configured upper limit
      if (me.weekElements[rowIndex].classList.contains('b-shrinkwrapped')) {
        return me.maxEventsPerCell;
      }
      // If there are shrinkwrapped rows, other row heights are unpredictable.
      // Some may be flexed, but they also have a minRowHeight.
      else {
        const firstCell = me.weekElements[rowIndex].querySelector(me.visibleCellSelector),
          eventContainerHeight = firstCell.offsetHeight - me.eventContainerTop;
        return Math.floor((eventContainerHeight + me.eventSpacing) / (me.eventHeightInPixels + me.eventSpacing));
      }
    } else {
      return me.eventsPerCell;
    }
  }
  getMaxEventsForWeek(week) {
    const {
      row
    } = this.getWeekContext(week);
    return Math.max(...Array.from(row.querySelectorAll(this.visibleCellSelector)).map(c => {
      const cellData = this.cellMap.get(c.dataset.date);
      return (cellData === null || cellData === void 0 ? void 0 : cellData.renderedEvents.length) || 0;
    }));
  }
  getWeekContext(week) {
    let weekStart, rowIndex;
    // Zero-based row index used. Extract the date of its first cell
    if (typeof week === 'number') {
      rowIndex = week;
      weekStart = DateHelper.parseKey(this.weekElements[week].querySelector(this.visibleCellSelector).dataset.date);
    }
    // Element passed
    else if (week.nodeType === 1) {
      weekStart = DateHelper.parseKey(week.closest('.b-calendar-row').querySelector('[data-date]').dataset.date);
      rowIndex = Math.floor(DateHelper.diff(this.startDate, weekStart, 'd') / 7);
    }
    // Date passed
    else {
      const incr = (week.getDay(week) - DateHelper.weekStartDay + 7) % 7;
      weekStart = DateHelper.add(DateHelper.clearTime(week), -incr, 'd');
      rowIndex = Math.floor(DateHelper.diff(this.startDate, week, 'd') / 7);
    }
    return {
      rowIndex,
      weekStart,
      row: this.weekElements[rowIndex]
    };
  }
  /**
   * Causes the week row referenced by the parameter (Either a Date, or the **zero based** row index)
   * to size itself to exactly wrap the maximum number of events for any day of that week.
   *
   * If there are a *lot* of events, the row may grow in height. If few, or none, the row will shrink
   * in height. The day name header along the top will always be visible by default.
   *
   * The row has the CSS class `'b-shrinkwrapped'` added when it is in the shrinkwrapped state
   * to allow querying, and custom styling.
   *
   * See {@link #function-flexWeekRow} for the converse operation.
   *
   * @param {Date|Number} week Either the date of a day within the week, or the **zero based** week row
   * to shrinkwrap.
   */
  shrinkwrapWeekRow(week, /* private */isLastCall = true) {
    const me = this,
      {
        weekStart,
        row
      } = me.getWeekContext(week),
      {
        weekElements
      } = me,
      wasShrinkwrapped = row.classList.contains('b-shrinkwrapped'),
      maxEventCount = me.getMaxEventsForWeek(week),
      shrinkwrapHeight = me.eventHeightInPixels * maxEventCount + me.eventSpacing * (maxEventCount + 1) + Math.ceil(me._eventContainerTop);
    for (let i = 0, {
        length
      } = weekElements; i < length; i++) {
      const weekElement = weekElements[i];
      // Fix non-expanded rows to be the correct flexed height if possible.
      // So for a standard sixWeeks: true CalendarPanel, that will be
      // 1/6th of the view height using percentage.
      if (!weekElement.classList.contains('b-shrinkwrapped')) {
        weekElement.style.flex = `0 0 ${DomHelper.percentify(1 / me.visibleWeekCount * 100)}`;
      }
    }
    // Create, or reconfigure any existing scrollable in the read phase
    if (isLastCall) {
      me.scrollable = {
        overflowY: 'auto'
      };
    }
    // Force a synchronous layout to begin the expansion immediately from the state we
    // just calculated above with all flexed rows flexed to a calculated fraction of the height.
    const oldRect = row.getBoundingClientRect();
    row.classList.add('b-shrinkwrapped');
    // We need to know if it's expanded
    if (shrinkwrapHeight > oldRect.height) {
      row.classList.add('b-expanded');
    }
    // Keep a flag so that our getEventsPerCell(date) can shortcut is answer
    // if all rows are evenly flexed without having to query.
    me.hasShrinkwrappedRows = true;
    row.style.flex = `0 0 ${shrinkwrapHeight}px`;
    // Refresh content before it achieves its new height.
    // Content will be revealed by the transition.
    if (isLastCall) {
      me.refresh();
    }
    /**
     * This event is fired as soon as a week row is requested to be shrinkwrapped.
     *
     * It's not called if we are just re-synching the height of shrinkwrapped rows
     * which needs to be done if the shape of the data changes.
     *
     * The animated transition to the new height will still be in progress, but the row's
     * flex style is set to its calculated height.
     *
     * To wait until the animated transition is finished, use the Promise returned
     * from {@link #function-shrinkwrapWeekRow}
     *
     * ```javascript
     *     monthView.shrinkwrapWeekRow(0).then() => Toast.show('Row zero shrinkwraps event content);
     * ```
     * @event weekShrinkwrap
     * @param {Date} weekStart The start date of the week being shrinkwrapped.
     * @param {HTMLElement} element The week row being shrinkwrapped.
     */
    if (!wasShrinkwrapped) {
      me.trigger('weekShrinkwrap', {
        weekStart,
        element: row
      });
    }
    // Sets the flag class on the widget which warns all and sundry that styles may be in flux.
    if (isLastCall) {
      if (!me.isAnimating) {
        me.isAnimating = true;
      }
      return new Promise(resolve => {
        EventHelper.onTransitionEnd({
          element: row,
          property: 'flex-basis',
          handler: 'onAllWeekElementsExpanded',
          thisObj: me,
          args: [resolve]
        });
      });
    }
  }
  onAllWeekElementsExpanded(element, property, resolve) {
    this.isAnimating = false;
    // Account for any scrollbar.
    // The call from the refresh in shrinkwrapWeekRow will find that there is no overflow yet
    // due to animated nature of expansion. We must check when expansion has finished.
    this.syncCalendarWeekDaysWithScrollable();
    resolve();
  }
  /**
   * Causes the week row referenced by the parameter (Either a Date, or the **zero-based** row index)
   * to become flexed in height to share the available height of the Calendar equally with other
   * flexed rows.
   *
   * See {@link #function-shrinkwrapWeekRow} for the converse operation.
   *
   * @param {Date|Number} date Either the date of a day within the week, or the **zero based** week row
   * to flex.
   */
  flexWeekRow(date, /* private */isLastCall = true) {
    const me = this,
      {
        weekStart,
        row
      } = me.getWeekContext(date);
    if (row.classList.contains('b-shrinkwrapped')) {
      // Week will transition back to flex-basis : 16.666%
      row.style.flex = `0 0 ${DomHelper.percentify(1 / me.visibleWeekCount * 100)}`;
      row.classList.add('b-flexing');
      // We just restored a row to flexedness.
      // The autoRowHeight state is no longer in force.
      // Set before we publish events.
      me._autoRowHeight = false;
      /**
       * This event is fired as soon as a week row is requested to be flexed. The animated
       * transition to the new height will still be in progress, but the row's flex style is
       * set to its evenly shared flex value.
       *
       * To wait until the animated transition is finished, use the Promise returned
       * from {@link #function-flexWeekRow}
       *
       * ```javascript
       *     monthView.flexWeekRow(0).then() => Toast.show('Row zero flexed);
       * ```
       * @event weekFlex
       * @param {Date} weekStart The start date of the week being reverted to a flexed height.
       * @param {HTMLElement} element The week row being reverted to a flexed height.
       */
      me.trigger('weekFlex', {
        weekStart,
        element: row
      });
      // Sets the flag class on the widget which warns all and sundry that styles may be in flux.
      if (isLastCall && !me.isAnimating) {
        me.isAnimating = true;
      }
      const result = new Promise(resolve => {
        EventHelper.onTransitionEnd({
          element: row,
          property: 'flex-basis',
          handler: isLastCall ? 'onAllWeekElementsCollapsed' : 'onWeekElementCollapsed',
          thisObj: me,
          args: [resolve]
        });
      });
      return result;
    }
  }
  onWeekElementCollapsed(weekElement, property, resolve) {
    weekElement.classList.remove('b-shrinkwrapped', 'b-flexing', 'b-expanded');
    resolve();
  }
  onAllWeekElementsCollapsed(weekElement, property, resolve) {
    const me = this,
      {
        weekElements
      } = me;
    // Reconfigure any existing scrollable.
    me.scrollable.overflowY = me.scrollable.hasOverflow('y');
    weekElement.classList.remove('b-shrinkwrapped', 'b-flexing', 'b-expanded');
    // If there are now no expanded week rows, restore all rows to flexing
    // using the theme's rules, ie: no flex-basis to aim for.
    if (!me.contentElement.querySelector('.b-calendar-week.b-shrinkwrapped')) {
      for (let i = 0, {
          length
        } = weekElements; i < length; i++) {
        const weekElement = weekElements[i];
        if (!weekElement.classList.contains('b-shrinkwrapped')) {
          weekElement.style.flex = '';
        }
      }
    }
    // Fire animationEnd event after element classes have been fixed up.
    me.isAnimating = false;
    // Keep a flag so that our getEventsPerCell(date) can shortcut is answer
    // if all rows are evenly flexed without having to query.
    me.hasShrinkwrappedRows = me.shrinkwrappedRows.length;
    // Refresh after the height shrink animation has ended.
    // Old, overflowing data will be clipped. The visual effect will just be
    // the +n more appearing
    me.refresh();
    // Account for any scrollbar.
    // The call from the refresh in flexWeekRow will find that there is still overflow
    // due to animated nature of collapse. We must check when collapse has finished.
    me.syncCalendarWeekDaysWithScrollable();
    resolve();
  }
  // The header must allow a scrollbar width if the platform displays scrollbars
  syncCalendarWeekDaysWithScrollable() {
    var _this$scrollable;
    this.weekdaysHeader.classList[(_this$scrollable = this.scrollable) !== null && _this$scrollable !== void 0 && _this$scrollable.hasScrollbar() ? 'add' : 'remove']('b-show-yscroll-padding');
  }
  updateHideOtherMonthCells() {
    super.updateHideOtherMonthCells(...arguments);
    this.refresh();
  }
  updateEventHeight(height, oldHeight) {
    const me = this;
    super.updateEventHeight(height, oldHeight);
    if (!me.isConfiguring) {
      var _me$minRowHeight;
      // If the minRowHeight is expressed in evs, it has to be reavaluated.
      if ((_me$minRowHeight = me.minRowHeight) !== null && _me$minRowHeight !== void 0 && _me$minRowHeight.match(evRegexp)) {
        me.updateMinRowHeight(me._minRowHeight);
      }
      // Keep any shrinkwrapped rows in the correct shape
      me.syncShrinkwrappedRows();
      const padding = DomHelper.getEdgeSize(me.element, 'padding', 'tb');
      // Always leave room for at least two events
      me.minHeight =
      // Month is usually 6 weeks
      ((me.eventHeightInPixels + 1) * 2 + me.eventSpacing * 3 + Math.ceil(me.eventContainerTop)) * 6 +
      // Add header height with borders
      me.weekdaysHeader.offsetHeight + 7 +
      // And view padding
      padding.height;
    }
  }
  updateMinRowHeight(minRowHeight) {
    var _minRowHeight, _minRowHeight$match, _minRowHeight$match$c;
    const me = this,
      eventCount = parseInt((_minRowHeight = minRowHeight) === null || _minRowHeight === void 0 ? void 0 : (_minRowHeight$match = _minRowHeight.match) === null || _minRowHeight$match === void 0 ? void 0 : (_minRowHeight$match$c = _minRowHeight$match.call(_minRowHeight, evRegexp)) === null || _minRowHeight$match$c === void 0 ? void 0 : _minRowHeight$match$c[1]);
    // See if they configured it in evs which is our own "CSS" units meaning events
    if (!isNaN(eventCount)) {
      if (me.isConfiguring) {
        return me.ion({
          paint: 'updateMinRowHeight',
          args: [minRowHeight],
          once: true
        });
      }
      minRowHeight = me.eventHeightInPixels * eventCount + me.eventSpacing * (eventCount + 1) + Math.ceil(me.eventContainerTop);
    }
    // We need to know the actual CSS value for restoring it
    me.cssMinRowHeight = DomHelper.setLength(minRowHeight);
    super.updateMinRowHeight(minRowHeight);
    // If we are in the middle of a flexWeekRow or shrinkwrapWeekRow animation
    // We cannot do this as it needs to measure a final value
    if (me.isAnimating) {
      me.ion({
        animationEnd: 'performResizeRefresh',
        thisObj: me,
        args: [me._eventsPerCell, me._eventContainerTop],
        once: true
      });
    } else {
      // Calculates new values for eventsPerCell and eventContainerTop
      // and handles changes to either.
      me.performResizeRefresh(me._eventsPerCell, me._eventContainerTop);
    }
  }
  async updateAutoRowHeight(autoRowHeight, wasAutoRowHeight) {
    var _ref, _me$calendar;
    // The change from undefined to false during initialization is a noop.
    if (this.initializingAutoRowHeight && autoRowHeight === Boolean(wasAutoRowHeight)) {
      return;
    }
    const me = this,
      {
        weekElements
      } = me,
      {
        length
      } = weekElements,
      weekExpander = (_ref = me.features || ((_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.features)) === null || _ref === void 0 ? void 0 : _ref.weekExpander;
    let finalPromise;
    // Disable WeekExpander *before*() we shrinkwrap so that the WeekExpander's
    // UI disappears immediately.
    if (weekExpander && autoRowHeight) {
      weekExpander.disabled = weekExpander.disabledByAutoRowHeight = true;
    }
    // Either shrinkwrap or reset to flex all week rows.
    // autoRowHeight disables weekExpander and decides row heights.
    if (autoRowHeight) {
      for (let i = 0; i < length; i++) {
        finalPromise = me.shrinkwrapWeekRow(i, i === length - 1);
      }
    } else {
      for (let i = 0; i < length; i++) {
        finalPromise = me.flexWeekRow(i, i === length - 1);
      }
    }
    // Wait for the last row to finish.
    await finalPromise;
    // Re-enable *after* collapsing so that WeekExpander UI only
    // appears if needed.
    if (weekExpander && !autoRowHeight && weekExpander.disabledByAutoRowHeight) {
      weekExpander.disabled = weekExpander.disabledByAutoRowHeight = false;
    }
    // Will need to redraw when we reach all flexed row heights because
    // the eventsPerCell will need to be recalculated
    if (!autoRowHeight) {
      me._eventContainerHeight = me._eventsPerCell = null;
      me.refresh();
    }
  }
  // When data changes or eventHeight changes, any shrinkwrapped rows need to be
  // kept in the correct shape;
  syncShrinkwrappedRows() {
    if (this.isVisible) {
      const {
        shrinkwrappedRows
      } = this;
      for (let i = 0, {
          length
        } = shrinkwrappedRows; i < length; i++) {
        this.shrinkwrapWeekRow(shrinkwrappedRows[i], i === length - 1);
      }
    }
  }
  changeScrollable(scrollable, oldScrollable) {
    var _scrollable;
    scrollable = super.changeScrollable(scrollable, oldScrollable);
    if ((_scrollable = scrollable) !== null && _scrollable !== void 0 && _scrollable.overflowX) {
      // Create a Scroller to scroll the day header's X axis in sync with the month grid
      this.weekdaysScrollable || (this.weekdaysScrollable = new Scroller({
        widget: this,
        element: this.weekdaysHeader,
        overflowX: 'hidden-scroll'
      }));
      scrollable.addPartner(this.weekdaysScrollable, 'x');
    }
    return scrollable;
  }
  collectEvents(options) {
    if (this.hideOtherMonthCells) {
      const {
        year,
        month
      } = this.month;
      // use strict bounds of the month, not of the cells in the UI.
      // The "other month" cells in the UI are not visible in this mode.
      options.startDate = new Date(year, month, 1);
      options.endDate = new Date(year, month + 1, 1);
    }
    // Only the first *visible* cell needs overflows flowing into it.
    // from after that, propagateCellEvents copies events forward, so
    // the getEvents will use the "startDate" index to extract events for a date.
    options.getDateIndex = date => date > (this.firstVisibleDate || this.startDate) ? 'startDate' : 'date';
    return this.eventStore.getEvents(options);
  }
  getDayElement(date, strict) {
    if (typeof date !== 'string') {
      date = DateHelper.makeKey(date);
    }
    // Enforce strict meaning this view must own that date.
    // month.month is the *zero based* index that the Date class uses.
    if (strict && parseInt(date.substr(5, 2)) !== this.month.month + 1) {
      return;
    }
    return super.getDayElement(date);
  }
  /**
   * Determines what is under the cursor of the specified event or what is described by the given element.
   * @param {Event|Element} domEvent The event or element
   * @returns {CalendarHit}
   */
  calendarHitTest(domEvent) {
    const hit = super.calendarHitTest(domEvent),
      target = DomHelper.getEventElement(domEvent);
    if (hit) {
      var _weekElement$dataset$;
      // Two levels of disabling other month cells.
      // Disabled means they are visible but unresponsive.
      // hidden means they are invisible
      if (hit.date.getMonth() !== this.month.month && (this.disableOtherMonthCells || this.hideOtherMonthCells)) {
        return;
      }
      const weekElement = target.closest('.b-calendar-week'),
        week = weekElement === null || weekElement === void 0 ? void 0 : (_weekElement$dataset$ = weekElement.dataset.week) === null || _weekElement$dataset$ === void 0 ? void 0 : _weekElement$dataset$.split(',').map(Number);
      if (week) {
        var _hit$cell;
        hit.cell = hit.cell || target.closest('.b-calendar-cell');
        hit.dayNumber = Number((_hit$cell = hit.cell) === null || _hit$cell === void 0 ? void 0 : _hit$cell.dataset.columnIndex);
        hit.week = week;
        hit.weekElement = weekElement;
        hit.weekNumber = week[1];
        hit.weekOffset = week[1] - Number(this.weeksElement.firstElementChild.dataset.week.split(',')[1]);
      }
    }
    return hit;
  }
  getDateFromPosition(clientX, clientY) {
    const me = this,
      weekEls = me.weeksElement.childNodes;
    for (let rect, i = 0; i < weekEls.length; ++i) {
      rect = weekEls[i].getBoundingClientRect();
      if (rect.top <= clientY && clientY < rect.bottom) {
        if (rect.left <= clientX && clientX < rect.right) {
          const dx = me.rtl ? rect.right - clientX : clientX - rect.x,
            column = Math.floor(dx * me.weekLength / rect.width);
          // Some days may be hidden.
          if (me.hideNonWorkingDays) {
            const cellDates = Array.from(weekEls[i].querySelectorAll(me.visibleCellSelector)).map(e => me.getDateFromElement(e));
            return cellDates[column];
          } else {
            const date = me.getDateFromElement(weekEls[i].querySelector(me.visibleCellSelector));
            date.setDate(date.getDate() + column);
            return date;
          }
        }
      }
    }
    return null;
  }
  /**
   * Determines the week container element of the specified event or the given element.
   * @param {Event|Element} domEvent The event or element
   * @returns {Element}
   * @internal
   */
  getWeekElementFor(domEvent) {
    const target = DomHelper.getEventElement(domEvent);
    return (target === null || target === void 0 ? void 0 : target.closest('.b-calendar-week')) || null;
  }
  updateEventStore(eventStore, was) {
    var _super$updateEventSto;
    (_super$updateEventSto = super.updateEventStore) === null || _super$updateEventSto === void 0 ? void 0 : _super$updateEventSto.call(this, eventStore, was);
    // Create the empty cell structure before the first refresh with data
    // so that boilerplate elements may be measured.
    CalendarPanel.prototype.doRefresh.call(this);
  }
  updateOverflowClickAction() {
    this.refresh();
  }
  updateSixWeeks() {
    // Invalidate the values so that they are recalculated in the superclass's refresh
    this._eventsPerCell = this._eventContainerTop = this._eventContainerHeight = null;
    super.updateSixWeeks(...arguments);
  }
  onMonthDateChange({
    changes
  }) {
    // Month's row count with respect to the sixWeeks setting has changed...
    if (changes.r && !this.sixWeeks) {
      // Invalidate the values so that they are recalculated in the superclass's refresh
      this._eventsPerCell = this._eventContainerTop = this._eventContainerHeight = null;
    }
    super.onMonthDateChange(...arguments);
  }
  doRefresh() {
    // Only ingest and process autoRowHeight when we have visibility
    if (!this.isConfiguring) {
      var _this$_cellMap;
      this.getConfig('autoRowHeight');
      (_this$_cellMap = this._cellMap) === null || _this$_cellMap === void 0 ? void 0 : _this$_cellMap.clear();
    }
    const result = super.doRefresh();
    // Account for any scrollbar
    this.syncCalendarWeekDaysWithScrollable();
    return result;
  }
  showEvent(eventRecord) {
    this.setDate(eventRecord.startDate);
  }
  changeDayNumberCentered(dayNumberCentered) {
    return Boolean(dayNumberCentered);
  }
  updateShowWeekColumn(showWeekColumn) {
    // If we are hiding the week column and we never created any in-cell week number
    // elements (They are not rendered if not required), we have to refresh to get them.
    if (!showWeekColumn && !this.element.querySelector('.b-week-num')) {
      this.doRefresh();
    }
    super.updateShowWeekColumn(showWeekColumn);
  }
  updateHideNonWorkingDays(hideNonWorkingDays) {
    var _super$updateHideNonW;
    (_super$updateHideNonW = super.updateHideNonWorkingDays) === null || _super$updateHideNonW === void 0 ? void 0 : _super$updateHideNonW.call(this, hideNonWorkingDays);
    // Widths will change, so a refresh is needed.
    if (!this.isConfiguring) {
      this.refresh();
    }
  }
  updateDayNumberCentered(dayNumberCentered) {
    const me = this;
    // First time we flip to center, cache was the week number showing was
    // so that we can restore it.
    if (!me._dayNumberCentered && !('nonCenteredDayNumShowWeekColumn' in me)) {
      me.nonCenteredDayNumShowWeekColumn = me.showWeekColumn;
    }
    me._dayNumberCentered = dayNumberCentered;
    me.element.classList[dayNumberCentered ? 'add' : 'remove']('day-number-center');
    // Centered day number with week number inside the cell header looks bad.
    me.showWeekColumn = dayNumberCentered ? true : me.nonCenteredDayNumShowWeekColumn;
  }
  get dayNameSelector() {
    return this.showWeekColumn ? '.b-cal-cell-header' : super.dayNameSelector;
  }
  set dayNameSelector(dayNameSelector) {
    this._dayNameSelector = dayNameSelector;
  }
  isValidTargetDate(date) {
    const newMonth = date.getMonth();
    if (newMonth !== this.month.month) {
      var _this$calendar, _this$calendar2;
      const minDate = this.minDate || ((_this$calendar = this.calendar) === null || _this$calendar === void 0 ? void 0 : _this$calendar.minDate),
        maxDate = this.maxDate || ((_this$calendar2 = this.calendar) === null || _this$calendar2 === void 0 ? void 0 : _this$calendar2.maxDate);
      // Only do date arithmetic if we need to.
      if (!isNaN(minDate) || !isNaN(maxDate)) {
        const {
          cellMonth
        } = this;
        cellMonth.date = date;
        if (!isNaN(minDate)) {
          // Veto navigation to before minDate.
          if (cellMonth.startDate < minDate) {
            return false;
          }
        }
        if (!isNaN(maxDate)) {
          // Veto navigation to after maxDate.
          // Month class's concept of date is inclusive. Its dates
          // refer to a 24 hour block unlike scheduling UIs so increment it.
          if (DateHelper.add(cellMonth.endDate, 1, 'd') > maxDate) {
            return false;
          }
        }
      }
    }
    return true;
  }
  set startDate(date) {
    this.date = date;
  }
  get startDate() {
    return super.startDate;
  }
  next() {
    this.date = DateHelper.add(this.date || this.startDate, 1, 'month');
  }
  previous() {
    this.date = DateHelper.add(this.date || this.startDate, -1, 'month');
  }
}
MonthView.initClass();
MonthView._$name = 'MonthView';

/**
 * @module Calendar/widget/ResourceView
 */
const day0 = new Date(0),
  day1 = DateHelper.add(day0, 1, 'day'),
  emptyMap = Object.freeze(new Map()),
  scrollAxesConfigs = {
    hourHeight: 1,
    showAllDayHeader: 1
  };
/**
 * A Calendar view which encapsulates a series of child Calendar views, one for each resource (often
 * referred to as "calendar") in the project.
 *
 * The type of view displayed defaults to `'week'`, but this can be changed using the {@link #config-view}
 * config object.
 *
 * Usage :
 *
 * ```javascript
 * new Calendar({
 *     appendTo : domElement,
 *
 *     // Resource avatar images are loaded from this path
 *     resourceImagePath : '../_shared/images/users/',
 *
 *     modes : {
 *         // Let's not show the default views
 *         day    : null,
 *         week   : null,
 *         month  : null,
 *         year   : null,
 *         agenda : null,
 *
 *         // Mode name can be anything if it contains a "type" property.
 *         monthResourceview : {
 *             // Type has the final say over which view type is created
 *             type : 'resource',
 *
 *             // This is a config object for the subviews; one for each resource
 *             view : {
 *                 // We show a month view for each resource in the project
 *                 type : 'month'
 *             }
 *         }
 *     }
 * });
 * ```
 * @extends Core/widget/Panel
 * @mixes Core/widget/mixin/Responsive
 * @mixes Calendar/widget/mixin/CalendarMixin
 * @classType resourceview
 */
class ResourceView extends Panel.mixin(CalendarMixin) {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "sharedConfigs", ['allowOverlap', 'timeFormat', 'fitHours', 'hourHeight', 'visibleStartTime', 'dateFormat', 'dayStartTime', 'dayEndTime', 'hideNonWorkingDays', 'readOnly', 'zoomOnMouseWheel']);
    _defineProperty(this, "timeAxisConfigs", ['allDayEvents'].concat(this.sharedConfigs));
  }
  static get $name() {
    return 'ResourceView';
  }
  // Factoryable type name
  static get type() {
    return 'resourceview';
  }
  static get configurable() {
    return {
      textContent: false,
      scrollable: {
        overflowX: true
      },
      date: {
        $config: {
          equal: 'date'
        },
        value: null
      },
      /**
       * After instantiation, while in use, changes to the `view` property, will be propagated
       * to all child {@link #config-view views}.
       *
       * This property may be used to adjust properties of every child view of the resource
       * view in one statement.
       * @member {Object} view
       */
      /**
       * A config object used to configure the sub views. The default `type` used is `'weekview'`
       * @config {Object}
       */
      view: {
        type: 'weekview'
      },
      /**
       * By default, the resource views are displayed in the order that the resources appear
       * in the project's `resourceStore`, so they will appear in a stable position, meaning
       * when a view is filtered out, then filtering it in will replace it in the same position.
       *
       * If this config is `false`, re-adding a view will place it at the end.
       * @config {Boolean}
       * @default
       */
      stableResourceOrder: true,
      /**
       * The width of a resource calendar panel (view always stretches to fill window)
       * @member {Number|String} resourceWidth
       */
      /**
       * The width of a resource calendar panel (view always stretches to fill window)
       * @config {Number|String}
       */
      resourceWidth: null,
      /**
       * Set to true to hide non-working days
       * @member {Boolean} hideNonWorkingDays
       */
      /**
       * Set to true to hide non-working days
       * @config {Boolean}
       */
      hideNonWorkingDays: null,
      viewCache: {
        $config: ['lazy', 'nullify'],
        value: true
      },
      avatarRendering: {},
      /**
       * A field name or a function returning a string to be displayed below resource name in the resource view
       * headers.
       *
       * ```javascript
       * const calendar = new Calendar({
       *     modes : {
       *         // Mode name can be anything if it contains a "type" property.
       *         weekResources : {
       *             type  : 'resource',
       *             // Get meta string to display
       *             meta : resource => resource.title
       *         }
       *     }
       * });
       * ```
       *
       * @config {String|Function}
       */
      meta: null,
      /**
       * Display an avatar in the resource view headers, either as an image or using resource initials.
       *
       * Looks for an image name in the {@link Scheduler/model/ResourceModel#field-imageUrl} and
       * {@link Scheduler/model/ResourceModel#field-image} fields on the resource. Set
       * {@link Calendar/view/Calendar#config-resourceImagePath} on Calendar to specify where to load images from.
       * If no image is found, resource initials are displayed.
       *
       * @config {Boolean}
       * @default
       */
      showAvatars: true,
      /**
       * When {@link Scheduler.model.ResourceTimeRangeModel}s are included in the data, they
       * are only rendered in subviews of {@link Calendar.widget.ResourceView}s and normal
       * {@link Calendar.model.TimeRangeModel}s are __not__ rendered in subviews of
       * {@link Calendar.widget.ResourceView}s.
       *
       * Set this to `true` to render normal {@link Calendar.model.TimeRangeModel}s in subviews of
       * this view.
       * @config {Boolean}
       * @default false
       */
      includeTimeRanges: null
    };
  }
  construct() {
    var _this$calendar$sideba, _this$calendar$sideba2;
    super.construct(...arguments);
    // If the built in resource filter changes the resources visible, we have to react
    // to that by refreshing which may add/remove some child views.
    // Note this this is a filter operation on the eventStore.
    // We don't subscribe to the filter operation on the eventStore because that may happen
    // often for other reasons (filtering based on other criteria), and we do not want to
    // invoke this expensive refresh unnecessarily.
    (_this$calendar$sideba = this.calendar.sidebar) === null || _this$calendar$sideba === void 0 ? void 0 : (_this$calendar$sideba2 = _this$calendar$sideba.widgetMap.resourceFilter) === null || _this$calendar$sideba2 === void 0 ? void 0 : _this$calendar$sideba2.ion({
      change: 'onResourceFilterSelectionChange',
      thisObj: this
    });
  }
  // This view is animating if any of its child views are animating
  get isAnimating() {
    return super.isAnimating || this.items.some(v => v.isAnimating);
  }
  get hasNonWorkingDays() {
    return true;
  }
  changeView(view) {
    const me = this,
      result = new Proxy(ObjectHelper.assign({}, view), {
        set(target, prop, value) {
          const result = Reflect.set(...arguments);
          // Pass new property setting in to child views
          me.syncViewConfig(prop, value);
          return result;
        },
        deleteProperty(target, prop) {
          const result = Reflect.deleteProperty(...arguments);
          // Pass new property setting in to child views
          me.syncViewConfig(prop, null);
          return result;
        }
      });
    me.viewType = bryntum.Calendar.Modes.resolveType(view.type);
    return result;
  }
  /**
   * Executes the passed function for each child calendar view in {@link Calendar.view.Calendar#config-modes}
   * @param {Function} fn The function to call.
   * @param {Object[]} [args] The arguments to pass. Defaults to the view being called followed by its index.
   * @param {Object} [thisObj] The `this` reference for the function. Defaults to the view being called.
   */
  eachView(fn, args, thisObj = null) {
    const passView = args == null,
      items = [...this.viewCache];
    for (let i = 0, {
        length
      } = items; i < length; i++) {
      const view = items[i];
      if (passView) {
        args = [view, i];
      }
      if (view.callback(fn, thisObj || view, args) === false) {
        return;
      }
    }
  }
  /**
   * Yields the views which this ResourceView owns.
   * @property {Calendar.widget.mixin.CalendarMixin[]}
   * @readonly
   */
  get views() {
    return [...this.viewCache];
  }
  updateResourceStore(resourceStore) {
    var _super$updateResource;
    this.detachListeners('resourceViewResourceChange');
    (_super$updateResource = super.updateResourceStore) === null || _super$updateResource === void 0 ? void 0 : _super$updateResource.call(this, resourceStore);
    resourceStore.ion({
      name: 'resourceViewResourceChange',
      change: 'onResourceStoreChange',
      sort: 'onResourceStoreSort',
      thisObj: this
    });
    this.refreshSoon();
  }
  onResourceStoreChange() {
    this.refreshSoon();
  }
  onResourceStoreSort({
    source
  }) {
    const visibleViews = this.items.filter(v => v.isVisible && !v.isResourceDayViewTimeAxis),
      resourceIdOrder = source.map(r => this.createViewId(r)),
      viewIdOrder = visibleViews.map(v => v.id);
    // If the visible views are out of order, remove them then refresh
    if (!ObjectHelper.isEqual(resourceIdOrder, viewIdOrder)) {
      // Remove the views (not the timeaxis and scroller).
      // refresh will add them in the right order
      this.remove(...visibleViews);
      this.refreshSoon();
    }
  }
  onResourceFilterSelectionChange() {
    this.refreshSoon();
  }
  changeViewCache(viewCache, oldViewCache) {
    if (viewCache) {
      return new Bag();
    } else if (oldViewCache) {
      oldViewCache.forEach(v => v.destroy());
      oldViewCache.clear();
    }
  }
  getResourceView(resource) {
    return this.viewCache.get(this.createViewId(resource)) || this.createView(resource);
  }
  doRefresh() {
    var _me$items$, _me$items$$scrollable;
    const me = this,
      {
        scrollBarWidth
      } = DomHelper,
      {
        calendar,
        _items,
        resourceStore
      } = me,
      {
        resourceFilter
      } = calendar === null || calendar === void 0 ? void 0 : calendar.widgetMap,
      // Filter available resources by the owning Calendar's ResourceFilter
      calendars = resourceFilter ? me.resourceStore.records.filter(c => resourceFilter.value.includes(c)) : me.resourceStore.records,
      {
        length
      } = calendars,
      toAdd = [],
      toRemove = [],
      usedIds = {};
    // We need to have some resources loaded for us to know what resources we have to create views for.
    // If the Calendar is using the loadOnDemand feature, we need to "prime the pump"
    // by kicking off a load to get this information. We load a month's worth of
    // events under the assumption that yearViews will not be used.
    if (!resourceStore.count) {
      const {
          weekStartDay
        } = me,
        monthStart = DateHelper.getFirstDateOfMonth(me.date),
        nextMonthStart = DateHelper.add(monthStart, 1, 'month');
      // Load a whole visible month block as displayed in a MonthView.
      // Note that these are snapped to week starts as in a Calendar.
      me.eventStore.getEvents({
        startDate: DateHelper.add(monthStart, -(monthStart.getDay() - weekStartDay + 7) % 7, 'd'),
        endDate: DateHelper.add(nextMonthStart, 7 - (nextMonthStart.getDay() - weekStartDay + 7) % 7, 'd')
      });
    }
    // If this was called directly, cancel any queued call.
    me.refreshSoon.cancel();
    let hitCount = 0;
    for (let i = 0; i < length; i++) {
      const view = me.getResourceView(calendars[i]),
        isShown = _items.includes(view);
      // If the ResourceStore was updated and the view is orphaned
      // by the resource no longer being in there, we have to remove the view.
      if (resourceStore.getById(view.resourceId)) {
        view.title = me.titleTemplate(view.resource);
        // View is present in our items..
        if (isShown) {
          hitCount++;
        }
        // Not in our items; add
        else {
          toAdd.push(view);
        }
        usedIds[view.id] = 1;
      } else if (isShown) {
        toRemove.push(view);
      }
    }
    // Check removals, unless all records were visited above
    if (hitCount < _items.count) {
      me.eachView(view => {
        if (!usedIds[view.id]) {
          toRemove.push(view);
        }
      });
      me.remove(toRemove);
    }
    // Ensure the docked left and right axes are present in correct positions for DayViews
    if (me.viewType.isDayView) {
      if (!_items.includes(me.dayViewTimeAxis)) {
        toAdd.unshift(me.dayViewTimeAxis);
      }
      if (scrollBarWidth && !_items.includes(me.dayViewScroller)) {
        toAdd.push(me.dayViewScroller);
      }
    }
    const y = (_me$items$ = me.items[0]) === null || _me$items$ === void 0 ? void 0 : (_me$items$$scrollable = _me$items$.scrollable) === null || _me$items$$scrollable === void 0 ? void 0 : _me$items$$scrollable.y;
    me.add(...toAdd);
    // Sync incoming view with the common scroll position
    if (y != null) {
      toAdd.forEach(v => {
        // Must go directly to DOM because the config value will be equal on a re-show
        v.scrollable.element.scrollTop = y;
      });
    }
    // If we have added or removed any views, we need to sync some things.
    if (toAdd.length || toRemove.length) {
      let lastView;
      for (let i = 0, {
          items
        } = me, {
          length
        } = items; i < length; i++) {
        var _view$allDayEvents;
        const view = items[i],
          {
            scrollable
          } = view;
        // Border collisions mean that a view's CSS may need to know whether
        // it is first, last, or in between.
        view.element.classList.remove('b-last-resource-view');
        // isResourceDayViewTimeAxis is set in the dayViewTimeAxis, and the dayViewScroller
        if (!view.isResourceDayViewTimeAxis) {
          view.element.classList[i > 1 ? 'remove' : 'add']('b-first-resource-view');
          lastView = view;
        }
        // Keep the Y axis of any scrollers synced.
        if (scrollable) {
          scrollable.clearPartners();
          if (i) {
            view.scrollable.addPartner(items[i - 1].scrollable, 'y');
          }
        }
        // In case the view add/remove caused differences in the heights of the all day rows.
        // All views must be in sync WRT the height of their all day rows.
        (_view$allDayEvents = view.allDayEvents) === null || _view$allDayEvents === void 0 ? void 0 : _view$allDayEvents.refresh();
      }
      if (lastView) {
        lastView.element.classList.add('b-last-resource-view');
      }
      // If some views have been added or removed, we need to resync the all day row heights
      // because until all views are present, the sync cannot be valid.
      if (me.viewType.isDayView) {
        const allDayRows = me.views.filter(v => v.allDayEvents && v.isVisible),
          maxHeight = allDayRows.length && Math.max(...allDayRows.map(v => v.allDayEvents.cellContentHeight));
        // The allDayEvents refreshes might have caused one of them to be taller
        // than any others. We have to resync them after their refresh.
        if (maxHeight) {
          _items.forEach(v => {
            var _v$allDayEvents;
            (_v$allDayEvents = v.allDayEvents) === null || _v$allDayEvents === void 0 ? void 0 : _v$allDayEvents.setEventContentHeight(maxHeight, false, true);
          });
        }
      }
    }
    if (me.viewType.isDayView) {
      // Show/hide our fake scroller
      me.syncDayViewScrollerVisibility();
    }
    me.refreshCount = (me.refreshCount || 0) + 1;
    /**
     * Fires when this ResourceView refreshes.
     * @param {Calendar.widget.ResourceView} source The triggering instance.
     * @event refresh
     */
    me.trigger('refresh');
  }
  // Override at this level. Child views process events
  onCalendarPointerInteraction() {}
  // Override at this level. Child views process data mutations
  onCalendarStoreChange() {}
  onChildAdd(child) {
    super.onChildAdd(child);
    // We get a look at child view config changes to see if we need to propagate them to their siblings
    FunctionHelper.before(child, 'onConfigChange', 'onChildViewConfigChange', this, {
      return: false
    });
  }
  onChildViewConfigChange({
    name,
    value
  }) {
    // Propagate timeAxisConfig settings between all siblings
    if (!this.syncingChildViewConfigs && this.timeAxisConfigs.includes(name)) {
      // We need *all* sub views. Hidden (filtered out) subviews
      // from the view cache have to be included. Use Set to uniquify them.
      const items = new Set(this.items.concat([...this.viewCache]));
      this.syncingChildViewConfigs = true;
      items.forEach(i => {
        if (name in i) {
          i[name] = value;
        }
      });
      this.syncingChildViewConfigs = false;
    }
  }
  createView(resource) {
    var _result$contentElemen;
    const me = this,
      {
        id: resourceId
      } = resource,
      {
        resourceStore,
        viewCache
      } = me,
      {
        project
      } = resourceStore,
      config = Objects.merge({
        project,
        // All views must have a reference to the Calendar
        calendar: me.calendar,
        // IDs are matched so that a minimal Container update can be done
        id: me.createViewId(resource),
        cls: 'b-resourceview-resource',
        // The view must know which resource it is showing.
        defaultCalendar: resourceId,
        // Resource is configured in initially because it may be needed during
        // configuration before we set a getter for it.
        resource,
        resourceId,
        includeTimeRanges: me.includeTimeRanges,
        hideNonWorkingDays: me.hideNonWorkingDays,
        parent: me,
        date: me.date,
        dateFormat: me.dateFormat,
        title: me.titleTemplate(resource)
      }, me.view);
    // Copy in shared configs like hourHeight, dateFormat, dayStartTime, readOnly etc
    ObjectHelper.copyProperties(config, [...viewCache][0] || me, me.sharedConfigs);
    // DayViews must not show scrollers
    if (DomHelper.scrollBarWidth && me.viewType.isDayView) {
      config.scrollable = {
        overflowX: false,
        overflowY: 'hidden-scroll'
      };
    }
    const result = bryntum.Calendar.Modes.create(config);
    result.ion({
      catchAll: 'onChildViewCatchAll',
      thisObj: me
    });
    result.element.removeAttribute('tabIndex');
    result.element.dataset.viewResourceId = resource.id;
    (_result$contentElemen = result.contentElement) === null || _result$contentElemen === void 0 ? void 0 : _result$contentElemen.removeAttribute('tabIndex');
    // The item's weight is its store index if we are using stableResourceOrder
    Object.defineProperty(result, 'weight', {
      get() {
        return me.stableResourceOrder ? resourceStore.allIndexOf(resourceId) : 0;
      }
    });
    // The item's resource should be dynamically accessed from the resourceStore
    Object.defineProperty(result, 'resource', {
      get() {
        return resourceStore.getById(resourceId);
      }
    });
    // The item's eventFilter filters in events assigned to its resource
    Object.defineProperty(result, 'eventFilter', {
      get() {
        return e => e.resources.includes(this.resource);
      }
    });
    viewCache.add(result);
    /**
     * Fires when a new sub view is created.
     * @param {Calendar.widget.ResourceView} source The triggering instance.
     * @param {Calendar.widget.mixin.CalendarMixin} view The newly created sub view.
     * @event viewCreate
     */
    me.trigger('viewCreate', {
      view: result
    });
    return result;
  }
  onChildViewCatchAll(e) {
    // Inject the child view's resource into the event as the resourceRecord
    e.resourceRecord = e.source.resource;
    if (e.type !== 'paint') {
      this.trigger(e.type, e);
    }
    if (e.type === 'heightchange') {
      this.syncDayViewScrollerVisibility();
    }
  }
  //region Title
  changeAvatarRendering(config) {
    if (config) {
      return AvatarRendering.new({
        element: this.element
      }, config);
    }
  }
  titleTemplate(resource) {
    const me = this,
      {
        meta
      } = me,
      metaValue = typeof meta === 'string' ? resource[meta] : meta === null || meta === void 0 ? void 0 : meta(resource),
      // eventColor = #FF5555, apply as background-color
      namedColor = DomHelper.isNamedColor(resource.eventColor) && resource.eventColor,
      // eventColor = red, add b-sch-red cls
      hexColor = !namedColor && resource.eventColor;
    return {
      class: {
        'b-resourceview-title': 1,
        'b-has-meta': metaValue
      },
      children: [me.showAvatars && {
        class: {
          'b-resource-avatar-container': 1,
          [`b-sch-foreground-${namedColor}`]: namedColor
        },
        style: {
          color: hexColor || null
        },
        children: [me.getResourceAvatar(resource)]
      }, {
        class: 'b-resource-name',
        text: resource.name
      }, metaValue && {
        class: 'b-resource-meta',
        text: metaValue
      }]
    };
  }
  //endregion
  // Override here because we need to delegate the request to the subview for the
  // event's resource
  getEventElement(eventRecord, date = eventRecord.startDate) {
    var _this$getResourceView;
    return (_this$getResourceView = this.getResourceView(eventRecord.resource)) === null || _this$getResourceView === void 0 ? void 0 : _this$getResourceView.getEventElement(eventRecord, date);
  }
  /**
   * This creates a specially styled DayView which matches the view config (so that
   * dayStartTime, hourHeight etc is synced) which shows nothing but its time axis.
   * This acts as the single visible time axis on the left.
   * @private
   */
  get dayViewTimeAxis() {
    const me = this;
    if (!me._dayViewTimeAxis) {
      const viewConfig = ObjectHelper.copyProperties({}, me.view, me.timeAxisConfigs);
      me._dayViewTimeAxis = ResourceDayViewTimeAxis.create(_objectSpread2(_objectSpread2({}, viewConfig), {}, {
        // Must always be at the beginning
        weight: -1,
        // This view must update its shape on data change but it won't contain any events.
        // All it has to do is keep its allDayEventsHeight in sync with all its siblings
        // which happens on refresh.
        project: me.project,
        type: 'resourcedayviewtimeaxis',
        minWidth: 0,
        cls: 'b-resource-dayview-timeaxis',
        startDate: day0,
        endDate: day1,
        scrollable: {
          overflowX: false,
          overflowY: 'hidden-scroll'
        },
        // This toggles all the allDayEvents rows in synchrony
        onCornerClick() {
          const {
              expanded
            } = me.firstChild.allDayEvents,
            toRefresh = [];
          let drivingView = null;
          me.eachView(({
            allDayEvents
          }) => {
            // Collapsing, do the one with least overflow first
            if (expanded) {
              if (!drivingView || allDayEvents.maxEventCount < drivingView.maxEventCount) {
                drivingView = allDayEvents;
              }
            }
            // Expanding, we have to do the one with most overflow first
            else {
              if (!drivingView || allDayEvents.maxEventCount > drivingView.maxEventCount) {
                drivingView = allDayEvents;
              }
            }
          });
          // Toggle the driving one
          const r = drivingView.refreshCount;
          drivingView.expanded = !expanded;
          // If it found nothing to do, it will not have refreshed. They all must refresh eventually.
          if (drivingView.refreshCount === r) {
            toRefresh.push(drivingView);
          }
          // Now do the rest
          me.items.forEach(v => {
            if (v !== drivingView) {
              const {
                  allDayEvents
                } = v,
                r = allDayEvents.refreshCount;
              // Don't recurse into this, call the real one.
              v.allDayEvents.expanded = !expanded;
              // If it found nothing to do, it will not have refreshed. They all must refresh eventually.
              if (allDayEvents.refreshCount === r) {
                toRefresh.push(allDayEvents);
              }
            }
          });
          // Some will not have found that they needed to refresh.
          // Force the issue so that they too correct their cellContentHeights
          for (let i = 0, {
              length
            } = toRefresh; i < length; i++) {
            toRefresh[i].doRefresh();
          }
        }
      }), me);
      // If the time axis changes size, we may acquire or lose overflow
      ResizeMonitor.addResizeListener(me._dayViewTimeAxis.timeAxisElement, me.syncDayViewScrollerVisibility.bind(me));
    }
    return me._dayViewTimeAxis;
  }
  /**
   * This creates a specially styled DayView which matches the view config (so that
   * dayStartTime, hourHeight etc is synced) which shows nothing but its scrollbar.
   * This acts as the single visible scrollbar on the right of the ResourceView.
   * We cannot have the last DayView `overflowY : true` because then its flexed width
   * being equal to the others, its content area would be <scrollBarWidth> narrower
   * than the others.
   * @private
   */
  get dayViewScroller() {
    const me = this;
    if (!me._dayViewScroller) {
      const viewConfig = ObjectHelper.copyProperties({}, me.view, me.timeAxisConfigs);
      me._dayViewScroller = ResourceDayViewTimeAxis.create(_objectSpread2(_objectSpread2({}, viewConfig), {}, {
        // Must always be at the end
        weight: 999,
        // This view must update its shape on data change but it won't contain any events.
        // All it has to do is keep its allDayEventsHeight in sync with all its siblings
        // which happens on refresh.
        project: me.project,
        type: 'resourcedayviewtimeaxis',
        flex: `0 0 ${DomHelper.scrollBarWidth}px`,
        minWidth: DomHelper.scrollBarWidth,
        cls: 'b-resource-dayview-scroller',
        startDate: day0,
        endDate: day1,
        scrollable: {
          overflowX: false,
          overflowY: 'scroll'
        }
      }), me);
      me._dayViewScroller.scrollable.addPartner(me.dayViewTimeAxis.scrollable, 'y');
      // This may have to show/hide as we need/don't need a scrollbar
      me.monitorResize = true;
    }
    return me._dayViewScroller;
  }
  onElementResize() {
    super.onElementResize();
    this.syncDayViewScrollerVisibility();
  }
  syncDayViewScrollerVisibility() {
    // Show/hide our fake scroller if we have one
    if (this.dayViewScroller) {
      const needsScroller = this.dayViewTimeAxis.scrollable.hasOverflow('y');
      if (this.dayViewScroller.isVisible !== needsScroller) {
        this.dayViewScroller[needsScroller ? 'show' : 'hide']();
      }
    }
  }
  scrollTo(target) {
    const {
      items
    } = this;
    if (target.isEventModel) {
      const owningView = items.find(v => v.eventStore.includes(target));
      return owningView === null || owningView === void 0 ? void 0 : owningView.scrollTo(target);
    }
    return items[0].scrollTo(target);
  }
  createViewId(resource) {
    return `${this.id}-resource${this.config.view.type}-${resource.id}`;
  }
  updateDate(date) {
    // Inhibit any refreshes during multiple subview updates
    this.suspendVisibility();
    // Keep *all* views in sync, not just visible ones.
    // Hidden ones will not refresh immediately. If a view is not currently visible,
    // CalendarMixin's refresh schedules a refresh for the next time the view is painted.
    this.viewCache.forEach(v => {
      // We must skip the time axis and scroller that are added to handle Day/Week view scrolling
      if (!v.isResourceDayViewTimeAxis) {
        v.date = date;
      }
    });
    // Trigger one round of refreshes.
    this.resumeVisibility();
    if (this.viewType.isDayView) {
      // The allDayEvents refreshes might have caused one of them to be taller
      // than any others. We have to resync them after their refresh.
      this.items.forEach(v => {
        var _v$allDayEvents2, _v$allDayEvents3;
        (_v$allDayEvents2 = v.allDayEvents) === null || _v$allDayEvents2 === void 0 ? void 0 : _v$allDayEvents2.setEventContentHeight((_v$allDayEvents3 = v.allDayEvents) === null || _v$allDayEvents3 === void 0 ? void 0 : _v$allDayEvents3.cellContentHeight);
      });
    }
  }
  updateResourceWidth(value) {
    this.contentElement.style.setProperty('--resource-width', DomHelper.setLength(value));
  }
  updateHideNonWorkingDays(value) {
    if (!this.isConfiguring) {
      this.syncViewConfig('hideNonWorkingDays', value);
    }
  }
  updateNonWorkingDays(value) {
    if (!this.isConfiguring) {
      this.syncViewConfig('nonWorkingDays', value);
    }
  }
  updateIncludeTimeRanges(value) {
    if (!this.isConfiguring) {
      this.syncViewConfig('includeTimeRanges', value);
    }
  }
  syncViewConfig(configName, value) {
    const update = view => {
      view[configName] = value;
    };
    // Some configs must affect the DayVew scroller axes.
    if (scrollAxesConfigs[configName]) {
      this.items.forEach(update);
    }
    // Most only go to the real child views.
    else {
      this.eachView(update);
    }
  }
  descriptionRenderer() {
    var _;
    return ((_ = [...this.viewCache.items][0]) === null || _ === void 0 ? void 0 : _.description) || 'No resources';
  }
  get startDate() {
    return new Date(Math.min(...this.items.reduce((result, v) => {
      if (!v.isResourceDayViewTimeAxis) {
        result.push(v.startDate);
      }
      return result;
    }, [])));
  }
  get endDate() {
    return new Date(Math.max(...this.items.reduce((result, v) => {
      if (!v.isResourceDayViewTimeAxis) {
        result.push(v.endDate);
      }
      return result;
    }, [])));
  }
  get stepUnit() {
    const firstItem = [...this.viewCache][0];
    return firstItem === null || firstItem === void 0 ? void 0 : firstItem.stepUnit;
  }
  get firstChild() {
    return this.items.filter(w => !w.isResourceDayViewTimeAxis)[0];
  }
  previous() {
    const firstItem = [...this.viewCache][0];
    // We may never have created a child view.
    if (firstItem) {
      this.date = DateHelper.add(this.date, -firstItem.duration, 'day');
    }
  }
  next() {
    const firstItem = [...this.viewCache][0];
    // We may never have created a child view.
    if (firstItem) {
      this.date = DateHelper.add(this.date, firstItem.duration, 'day');
    }
  }
}
// Special non-data reading classes to create the scrollers
// either side of a series of DayViews.
class ResourceDayViewAllDayEvents extends CalendarRow {
  static get $name() {
    return 'ResourceDayViewAllDayEvents';
  }
  // Factoryable type name
  static get type() {
    return 'resourcedayviewalldayevents';
  }
  // The timeAxis's allDayEvents has overflow if any of the
  // real sibling DayView allDayEvents has overflow
  get hasOverflow() {
    return this.up('resourceview').views.some(v => {
      var _v$allDayEvents4;
      return (_v$allDayEvents4 = v.allDayEvents) === null || _v$allDayEvents4 === void 0 ? void 0 : _v$allDayEvents4.hasOverflow;
    });
  }
  createCellMap() {
    return emptyMap;
  }
}
class ResourceDayViewTimeAxis extends DayView {
  static get $name() {
    return 'ResourceDayViewTimeAxis';
  }
  // Factoryable type name
  static get type() {
    return 'resourcedayviewtimeaxis';
  }
  static get configurable() {
    return {
      allDayEvents: {
        type: 'resourcedayviewalldayevents'
      }
    };
  }
  compose() {
    const result = super.compose();
    result['aria-hidden'] = true;
    return result;
  }
  // These axes have no say in this
  scrollToVisibleStartTime() {}
  createCellMap() {
    return emptyMap;
  }
  calculateCellContentHeight() {
    return 0;
  }
  getDateFromPosition(clientX, clientY, local = false) {
    const me = this,
      date = me.startDate,
      top = local ? 0 : me.dayContentElement.getBoundingClientRect().y,
      height = me.timeAxisElement.offsetHeight,
      dy = clientY - top;
    return DateHelper.round(DateHelper.add(DateHelper.clearTime(date), me.dayStartMs + Math.floor(dy / height * me.getDayLength()), 'ms'), me.increment);
  }
}
ResourceDayViewAllDayEvents.initClass();
ResourceDayViewTimeAxis.initClass();
ResourceView.initClass();
ResourceView._$name = 'ResourceView';

/**
 * @module Calendar/widget/Sidebar
 */
/**
 * This class is not supposed to be used directly. This widget provides the utility UI as the
 * {@link Calendar.view.Calendar#config-sidebar} of a {@link Calendar.view.Calendar Calendar} widget.
 *
 * Sidebar items provided by default:
 *
 * | Widget ref       | Type                                         | Weight | Description                                 |
 * |------------------|----------------------------------------------|--------|---------------------------------------------|
 * | `datePicker`     | {@link Calendar.widget.CalendarDatePicker}   | 100    | Used to pick Calendar's active date         |
 * | `eventFilter`    | {@link Core.widget.FilterField}              | 150    | Used to filter events by name               |
 * | `resourceFilter` | {@link Scheduler.widget.ResourceFilter}      | 200    | Used to select resources to show events for |
 *
 * The configuration of these items may be overridden:
 *
 * ```javascript
 * new Calendar({
 *     sidebar : {
 *         items : {
 *             datePicker : {
 *                 // Never go to dates in the past
 *                 minDate : new Date()
 *             },
 *             eventFilter : {
 *                 // Let's have this at the top
 *                 weight : 50
 *             },
 *             resourceFilter : {
 *                 store : {
 *                     sorters : [{
 *                         field     : 'name',
 *                         // By default this is in ascending name order
 *                         // Let's change that round.
 *                         ascending : false
 *                     }]
 *                 }
 *             }
 *         }
 *     }
 * });
 * ```
 *
 * The {@link #config-bbar} is used to hold the navigation buttons ("Today" and next/previous) when the owning
 * `Calendar` is configured with {@link Calendar.view.Calendar#config-navigatorPlacement} set to `'sidebar'`. The
 * location of the `bbar`, as well as other options, can be changed via the `bbar` config, like so:
 *
 * ```javascript
 *  new Calendar({
 *      sidebar : {
 *          bbar : {
 *              dock : 'top'
 *          }
 *      }
 *  });
 * ```
 *
 * @extends Core/widget/Panel
 * @mixes Core/widget/mixin/Responsive
 * @classType sidebar
 * @inlineexample Calendar/widget/Sidebar.js
 */
class Sidebar extends Panel.mixin(Responsive) {
  static get $name() {
    return 'Sidebar';
  }
  // Factoryable type name
  static get type() {
    return 'sidebar';
  }
  static get configurable() {
    return {
      focusable: false,
      bbar: {
        cls: 'b-cal-nav-item',
        layout: {
          justify: 'center'
        },
        items: {
          todayButtonSidebar: {
            text: 'L{Calendar.Today}',
            onClick: 'up.shiftToNow',
            weight: 200
          },
          prevButtonSidebar: {
            onClick: 'up.shiftPrevious',
            cls: 'b-borderless',
            icon: 'b-icon-previous',
            weight: 300
          },
          nextButtonSidebar: {
            onClick: 'up.shiftNext',
            cls: 'b-borderless',
            icon: 'b-icon-next',
            weight: 400
          }
        }
      },
      items: {
        datePicker: {
          type: 'datepicker',
          weight: 100,
          internalListeners: {
            selectionChange: 'up.onMonthSelectionChange'
          }
        },
        eventFilter: {
          type: 'filterfield',
          field: 'name',
          // We want this in second position
          weight: 150,
          placeholder: 'L{Filter events}',
          localeClass: this
        },
        resourceFilter: {
          ignoreParentReadOnly: true
        }
      },
      date: {
        $config: {
          equal: 'date'
        },
        value: null
      },
      eventStore: null,
      responsive: {},
      // brand us as responsive so "collapsed" is tracked per responsive state
      stepUnitText: null,
      /**
       * May be configured with `'left'` or `'right'` to dock the Sidebar to either side.
       *
       * Defaults to `'left'`.
       * @config {'left'|'right'}
       * @default
       */
      side: 'left',
      collapsible: {
        tool: null
      },
      resourceFilter: {
        type: 'resourcefilter',
        flex: '1 1 auto',
        weight: 200,
        minHeight: 110,
        scrollable: {
          overflowY: 'auto'
        },
        store: {
          sorters: [{
            field: 'name',
            ascending: true
          }]
        },
        // We must only see the resources that are filtered in
        masterFilter(r) {
          return this.eventStore.resourceStore.isAvailable(r);
        }
      }
    };
  }
  setupWidgetConfig(widgetConfig, type) {
    let result = super.setupWidgetConfig(...arguments);
    // A string becomes the defaultType (see below) with the html set to the string.
    if (result.ref === 'eventFilter') {
      result.store = this.initialConfig.eventStore;
    }
    // Apply our configuration to the resourceFilter if it has not been configured to be
    // a completely different type of widget
    if (result.ref === 'resourceFilter') {
      if (!result.type || result.type === this.resourceFilter.type) {
        result = Sidebar.mergeConfigs(this.resourceFilter, result);
      }
    }
    // Sidebar has to know these so it can set an optimum minWidth to prevent
    // the DatePicker from being crushed into a bad UX.
    if (result.type === 'datepicker') {
      this.element.classList.add('b-has-datepicker');
      this.element.classList.toggle('b-datepicker-with-events', Boolean(result.events));
    }
    return result;
  }
  updateSide(side, oldSide) {
    const {
      classList
    } = this.element;
    classList.remove(`b-sidebar-${oldSide}`);
    classList.add(`b-sidebar-${side}`);
    if (this.collapsible) {
      this.collapsible.direction = side;
    }
  }
  updateStepUnitText(stepUnitText) {
    const me = this,
      {
        prevButtonSidebar,
        nextButtonSidebar
      } = me.widgetMap;
    if (prevButtonSidebar) {
      prevButtonSidebar.tooltip = stepUnitText ? me.L('L{Calendar.previous}', stepUnitText) : '';
      prevButtonSidebar.disabled = !stepUnitText;
    }
    if (nextButtonSidebar) {
      nextButtonSidebar.tooltip = stepUnitText ? me.L('L{Calendar.next}', stepUnitText) : '';
      nextButtonSidebar.disabled = !stepUnitText;
    }
  }
  updateEventStore(eventStore) {
    const {
      resourceFilter,
      datePicker
    } = this.widgetMap;
    if (resourceFilter) {
      resourceFilter.eventStore = eventStore;
    }
    if (datePicker) {
      datePicker.eventStore = eventStore;
    }
  }
  onMonthSelectionChange({
    selection,
    userAction
  }) {
    this.UIdateChange = userAction;
    this.date = selection[0];
    this.UIdateChange = false;
  }
  changeDate(date, oldDate) {
    date = typeof date === 'string' ? DateHelper.parse(date) : new Date(date);
    if (isNaN(date)) {
      throw new Error('Calendar widget date ingestion must be passed a Date, or a YYYY-MM-DD date string');
    }
    date = DateHelper.clearTime(date);
    // Protect the setter from processing a no-change.
    if (!oldDate || date - oldDate) {
      return date;
    }
  }
  updateDate(date) {
    const {
      datePicker
    } = this.widgetMap;
    datePicker && (datePicker.value = date);
    this.trigger('dateChange', {
      date,
      userAction: Boolean(this.UIdateChange)
    });
  }
}
Sidebar.initClass();
Sidebar._$name = 'Sidebar';

/**
 * @module Calendar/widget/WeekView
 */
/**
 * This is normally used as a {@link Calendar.view.Calendar#config-modes mode} of a Calendar
 * but may be used standalone as a regular Widget.
 *
 * As a standalone widget, it will lack the capabilities of the {@link Calendar.view.Calendar Calendar}
 * class, such as keyboard-based event to event navigation and drag/drop features.
 *
 * A Panel which displays up to 7 columns of days with events for each day arranged in ascending
 * time order in each column.
 *
 * All day events, and multi day events which intersect that day are displayed in a row at the top.
 *
 * Intra day events are arranged in ascending time order down the column from the {@link Calendar.widget.DayView#config-dayStartTime} to
 * the {@link Calendar.widget.DayView#config-dayEndTime}
 *
 * Event rendering can be customized using the {@link #config-eventRenderer} method.
 *
 * @extends Calendar/widget/DayView
 * @classType weekview
 * @inlineexample Calendar/widget/WeekView.js
 */
class WeekView extends DayView {
  static get $name() {
    return 'WeekView';
  }
  // Factoryable type name
  static get type() {
    return 'weekview';
  }
  static get configurable() {
    return {
      localizableProperties: ['title', 'stepUnit'],
      title: 'L{Week}',
      stepUnit: 'L{weekUnit}',
      range: {
        magnitude: 1,
        unit: 'week'
      },
      responsive: {
        small: {
          descriptionFormat: 'MMMM YYYY'
        },
        large: {
          descriptionFormat: ['MMMM YYYY (Wp)', 'S{MMM} - E{MMM YYYY} (S{Wp})']
        },
        '*': {
          descriptionFormat: ['MMMM YYYY', 'S{MMM} - E{MMM YYYY}']
        }
      },
      week: null,
      // Override from DayView. This means that in addition to endDate being
      // locked to startDate, and being changed when startDate changes, startDate
      // is also locked to endDate and is changed when the endDate changes.
      fixedDuration: true
    };
  }
  /**
   * Returns the resource associated with this week view when used inside a {@link Calendar.widget.ResourceView}
   * @readonly
   * @member {Scheduler.model.ResourceModel} resource
   */
  calculateDuration() {
    // Override from CalendarMixin where the value is calculated from two passed dates.
    return 7;
  }
  updateWeekStartDay(weekStartDay, oldWeekStartDay) {
    var _super$updateWeekStar;
    (_super$updateWeekStar = super.updateWeekStartDay) === null || _super$updateWeekStar === void 0 ? void 0 : _super$updateWeekStar.call(this, weekStartDay);
    if (!this.isConfiguring) {
      const startDate = new Date(this.startDate);
      startDate.setDate(startDate.getDate() + weekStartDay - oldWeekStartDay);
      this.startDate = startDate;
    }
  }
  changeMonth() {
    const result = super.changeMonth(...arguments);
    result.ion({
      weekChange: 'onMonthWeekChange',
      thisObj: this
    });
    return result;
  }
  onMonthWeekChange({
    source,
    newDate
  }) {
    // We have to keep the week number in sync
    this.week = source.getWeekNumber(newDate);
  }
  changeWeek(week, oldWeek) {
    const me = this;
    // If not an array, assume it's the week number
    week = Array.isArray(week) ? week : [me.month.year, week];
    // Only return a value if a change has been requested
    if (!ObjectHelper.isEqual(week, oldWeek)) {
      var _me$calendar, _me$calendar2;
      const minDate = me.minDate || ((_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.minDate),
        maxDate = me.maxDate || ((_me$calendar2 = me.calendar) === null || _me$calendar2 === void 0 ? void 0 : _me$calendar2.maxDate);
      // Only do date arithmetic if we need to validate.
      if (!isNaN(minDate) || !isNaN(maxDate)) {
        const weekStart = me.month.getWeekStart(week),
          weekEnd = DateHelper.add(weekStart, me.duration, 'd');
        if (!isNaN(minDate) && weekStart < minDate) {
          return;
        }
        if (!isNaN(maxDate) && weekEnd > maxDate) {
          return;
        }
      }
      return week;
    }
  }
  updateWeek(week) {
    const me = this,
      {
        month,
        date,
        dayTime
      } = me,
      weekStartDate = dayTime.shiftDate(month.getWeekStart(week));
    // If our current date is outside of the requested week, move it
    // to the week start which will set the startDate
    if (!date || !ObjectHelper.isEqual(month.getWeekNumber(date), week)) {
      me.date = weekStartDate;
    } else {
      me.startDate = weekStartDate;
    }
    // In case a beforeDateChange handler.
    // vetoed the date change - we have to sync the week to our date.
    me.week = month.getWeekNumber(me.date);
  }
}
WeekView.initClass();
WeekView._$name = 'WeekView';

/**
 * @module Calendar/widget/YearView
 */
const isHoverGesture = {
  hover: 1,
  mouseover: 1
};
/**
 * This is normally used as a {@link Calendar.view.Calendar#config-modes mode} of a Calendar
 * but may be used standalone as a regular Widget.
 *
 * As a standalone widget, it will lack the capabilities of the {@link Calendar.view.Calendar Calendar}
 * class, such as keyboard-based event to event navigation and drag/drop features.
 *
 * A Panel which displays a year's worth of months with days which have events highlighted.
 *
 * @extends Core/widget/Panel
 * @mixes Core/widget/mixin/Responsive
 * @mixes Calendar/widget/mixin/CalendarMixin
 * @mixes Calendar/widget/mixin/DayCellCollecter
 * @mixes Calendar/widget/mixin/DayCellRenderer
 * @classType yearview
 * @inlineexample Calendar/widget/YearView.js
 */
class YearView extends Panel.mixin(CalendarMixin, DayCellCollecter, DayCellRenderer) {
  static get $name() {
    return 'YearView';
  }
  // Factoryable type name
  static get type() {
    return 'yearview';
  }
  static get configurable() {
    return {
      textContent: false,
      localizableProperties: ['title', 'stepUnit'],
      title: 'L{Year}',
      scrollable: {
        overflowY: true
      },
      stepUnit: 'L{yearUnit}',
      month: true,
      /**
       * A date which specifies the year to display. All types of calendar view have a `date`
       * config which they use to set their visible date range according to their configuration
       * and type.
       * @config {Date}
       */
      date: {
        $config: {
          equal: 'date'
        },
        value: null
      },
      descriptionFormat: 'YYYY',
      /**
       * The year to display
       * @config {Number}
       */
      year: null,
      monitorResize: false,
      showWeekColumn: true,
      hideWeekColumnCls: 'b-hide-week-numbers',
      /**
       * The class name to add to calendar cells which are in the previous or next month.
       * @config {String}
       * @private
       */
      otherMonthCls: 'b-other-month',
      /**
       * By default, all months show six week rows. Pass `false` to only render as many rows
       * as needed.
       * @config {Boolean}
       */
      sixWeeks: true,
      /**
       * An empty function by default, but provided so that you can override it.
       *
       * This function is called for each cell rendered to allow developers to mutate the cell metadata, or
       * the CSS classes to be applied to the cell.
       *
       * The cellConfig (a {@link Core.helper.DomHelper#typedef-DomConfig}) definition passed as part of the
       * single parameter may be mutated to add `style` and `className`.
       *
       * ```javascript
       * dayCellRenderer : function(cellData) {
       *     // I don't like Mondays!
       *     if (cellData.date === 1) {
       *         cellData.cls['dayoff'] = true;
       *     }
       * }
       *
       *```
       * A non-null return value from the renderer is used as the content of the day cell element.
       *
       * @config {Function} dayCellRenderer
       * @param {Object} dayCellRenderer.cellData An object that contains data about the cell.
       * @param {Date} dayCellRenderer.cellData.date The Date of this cell
       * @param {Scheduler.model.EventModel[]} dayCellRenderer.cellData.events The array of events in this cell
       * @param {DomConfig} dayCellRenderer.cellData.cellConfig A {@link Core.helper.DomHelper#typedef-DomConfig}
       * object that contains data about the cell.
       * @param {String} dayCellRenderer.cellData.cellConfig.style The style property is an object containing
       * style properties for the cell header element.
       * @param {String} dayCellRenderer.cellData.cellConfig.cls The cls property is an object whose property
       * names will be added to the cell element if the property value is truthy.
       */
      dayCellRenderer: null,
      monthSelector: '.b-yearview-month-name',
      focusable: false,
      /**
       * How to indicate the presence of events for a date. The default is `heatmap` which adds
       * classes depending on how many events intersect the date.Values may be:
       *
       * * `false` - Do not show events in cells.
       * * `true` - Show a heatmap of colours the intensity of which indicates event load.
       * * `'heatmap'` - Show a heatmap of colours the intensity of which indicates event load.
       * * `'count'` - Show a themeable badge containing the event count for a date.
       * * `'dots'` - Show small event-coloured bullets up to a maximum of {@link #config-maxDots}
       * to indicate event presence.
       * @prp {Boolean|'heatmap'|'dots'}
       * @default
       */
      showEvents: 'heatmap',
      /**
       * When {@link #config-showEvents} is `'dots'`, this is the maximum number of dots to show
       * below the date number in the cell.
       *
       * The default is four. Note that increasing this may lead to a cluttered UI in which the dots
       * obscure the date figure in the cell.
       *
       * @prp {Number}
       * @default
       */
      maxDots: 4,
      /**
       * When {@link #config-overflowPopupTrigger} is not a mouseover gesture, setting this to
       * `true` means that a tooltip containing the event count will be shown on hover of
       * a day cell.
       *
       * @prp {Boolean}
       * @default
       */
      eventCountTip: null
    };
  }
  /**
   * Returns the resource associated with this year view when used inside a {@link Calendar.widget.ResourceView}
   * @readonly
   * @member {Scheduler.model.ResourceModel} resource
   */
  // Override from DayCellCollecter
  // We don't propagate. We copy all events into renderedEvents.
  createCellMap(options) {
    // We use the dateIndex, so gather all events which intersect. No need for propagation.
    const result = super.createCellMap(options = _objectSpread2({
      skipPropagate: true
    }, options));
    // YearView always places all its events as rendered events because we use skipPropagate
    // when creating the cell map, and just copy them all in so that the overflowPopup uses
    // them all. Any number of events is overflow for a YearView
    for (const cellData of result.values()) {
      cellData.renderedEvents.setEvents(cellData.events);
    }
    return result;
  }
  get date() {
    // If we have been injected with a specific date (Such from the Calendar Sidebar)
    // then use that as our anchor point. Fall back to the first visible event. If we are
    // without orientation use 1st January
    return this._date || !this.isConfiguring && this.firstEventDate || this.startDate;
  }
  next() {
    this.date = new Date(this.year + 1, this.date.getMonth(), this.date.getDate());
  }
  previous() {
    this.date = new Date(this.year - 1, this.date.getMonth(), this.date.getDate());
  }
  get firstEventDate() {
    const entries = [...this.cellMap.values()];
    if (entries.length) {
      return entries[0].date;
    }
  }
  get lastEventDate() {
    const entries = [...this.cellMap.values()];
    if (entries.length) {
      return entries[entries.length - 1].date;
    }
  }
  onCalendarPointerInteraction(domEvent) {
    var _me$_overflowPopup, _me$autoCreate;
    const me = this,
      superCall = super.onCalendarPointerInteraction,
      {
        target,
        type
      } = domEvent;
    if (type === 'mousedown' || type.endsWith('click')) {
      // Any clicking after kicking off the overflow timer cancels it
      me.clearTimeout(me.cellOverflowTimer);
    }
    // Veto focusing out of the overflowPopup when mousedowning overflow button
    // (which is a cell which contains elements) so that the overflow popup doesn't flicker.
    if (type === 'mousedown' && (_me$_overflowPopup = me._overflowPopup) !== null && _me$_overflowPopup !== void 0 && _me$_overflowPopup.isVisible && target.closest('.b-cal-cell-overflow')) {
      domEvent.preventDefault();
    }
    // If we're showing the overflow popup on click, and they clicked on an empty
    // cell, then they *might* be intending a dblclick, so we need to pause the
    // propagation of the click event into the processing
    if (me.overflowPopupTrigger === 'click' && ((_me$autoCreate = me.autoCreate) === null || _me$autoCreate === void 0 ? void 0 : _me$autoCreate.gesture) === 'dblclick' && type === 'click' && target.closest(`.${me.emptyCellCls}`) && !me.emptyCellRenderer) {
      me.cellOverflowTimer = me.setTimeout({
        fn: superCall,
        delay: 300,
        args: [domEvent]
      });
    } else {
      return superCall.apply(me, arguments);
    }
  }
  changeMonth(month, oldMonth) {
    const me = this,
      listeners = {
        name: 'yearChangeListener',
        yearChange: 'onMonthYearChange',
        thisObj: me
      };
    me.detachListeners('yearChangeListener');
    if (month instanceof Month) {
      month.ion(listeners);
      me._year = month.year;
    } else {
      month = new Month({
        date: new Date(me.year || new Date().getFullYear(), 0, 1),
        weekStartDay: me.weekStartDay,
        hideNonWorkingDays: me.hideNonWorkingDays,
        nonWorkingDays: me.nonWorkingDays,
        sixWeeks: me.sixWeeks,
        listeners
      });
    }
    if (me.nonWorkingDays == null) {
      me.nonWorkingDays = me._month.nonWorkingDays;
    }
    // Keep our property in line with reality
    me._year = month.year;
    return month;
  }
  onMonthYearChange({
    source: month
  }) {
    const me = this;
    // Keep our property in line with reality
    me._year = month.year;
    if (!me.isConfiguring) {
      me._cellMap && me._cellMap.clear();
      me.date = month.date;
      me.refresh();
    }
  }
  get eventsPerCell() {
    return 0;
  }
  get startDate() {
    return this.month.getOtherMonth(new Date(this.year, 0, 1)).startDate;
  }
  get endDate() {
    // It's exclusive of the day itself - this is a timepoint; 00:00 on the day after
    return DateHelper.add(this.month.getOtherMonth(new Date(this.year, 11, 1)).endDate, 1, 'day');
  }
  /**
   * For a consistent API, allow startDate to set the year
   * @internal
   */
  set startDate(startDate) {
    this.date = startDate;
  }
  isValidTargetDate(date) {
    const newYear = date.getFullYear();
    if (newYear !== this.year) {
      var _this$calendar, _this$calendar2;
      const minDate = this.minDate || ((_this$calendar = this.calendar) === null || _this$calendar === void 0 ? void 0 : _this$calendar.minDate),
        maxDate = this.maxDate || ((_this$calendar2 = this.calendar) === null || _this$calendar2 === void 0 ? void 0 : _this$calendar2.maxDate);
      // Only do date arithmetic if we need to.
      if (!isNaN(minDate) || !isNaN(maxDate)) {
        const {
          cellMonth
        } = this;
        if (!isNaN(minDate)) {
          // Work out what our new startDate would be.
          // eg startDate of Jan 2021 as a Calendar view is 27th Dec 20221.
          const newStartDate = cellMonth.getWeekStart(cellMonth.getWeekNumber(new Date(newYear, 0, 1)));
          // Veto navigation to before minDate.
          if (newStartDate < minDate) {
            return false;
          }
        }
        if (!isNaN(maxDate)) {
          // Move month to December to see what our new end date would be.
          // eg endDate of Dec 2021 as a Calendar view is 8th Jan 2022.
          cellMonth.date = new Date(newYear, 11, 31);
          // Veto navigation to after maxDate.
          // Month class's concept of date is inclusive. Its dates
          // refer to a 24 hour block unlike scheduling UIs so increment it.
          if (DateHelper.add(cellMonth.endDate, 1, 'd') > maxDate) {
            return false;
          }
        }
      }
    }
    return true;
  }
  updateDate(date) {
    this.month.date = date;
  }
  changeYear(year) {
    if (this.isConfiguring) {
      return year;
    }
    this.month.year = year;
    return this.month.year;
  }
  changeShowEvents(showEvents, oldShowEvents) {
    return showEvents === true ? 'heatmap' : showEvents;
  }
  updateShowEvents(showEvents, oldShowEvents) {
    const {
      classList
    } = this.contentElement;
    showEvents && classList.add(`b-show-events-${showEvents}`);
    classList.remove(`b-show-events-${oldShowEvents}`);
    if (!this.isConfiguring) {
      this.doRefresh();
    }
  }
  updateShowWeekNumber() {
    this.bodyElement.classList[this.showWeekColumn ? 'remove' : 'add'](this.hideWeekColumnCls);
  }
  // We must implement the CalendarMixin interface.
  // All views must expose a doRefresh method.
  doRefresh() {
    var _me$calendar;
    const me = this,
      {
        bodyElement: targetElement,
        month,
        dayCellCls,
        otherMonthCls,
        weekendCls,
        todayCls,
        nonWorkingDayCls,
        emptyCellCls,
        cellMap,
        showEvents
      } = me,
      children = [],
      today = ((_me$calendar = me.calendar) === null || _me$calendar === void 0 ? void 0 : _me$calendar.today) || new Date(),
      todayKey = DateHelper.makeKey(today);
    for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
      month.month = monthIndex;
      const monthHeader = {
          tag: 'button',
          className: 'b-yearview-month-name',
          html: DateHelper.getMonthName(monthIndex),
          dataset: {
            // Month names must not look like day cells which have data-date="YYYY-MM-DD"
            monthDate: DateHelper.makeKey(new Date(me.year, monthIndex, 1))
          }
        },
        weeknameCells = [{
          className: 'b-week-number-cell'
        }],
        weekNameRow = {
          className: 'b-calendar-week b-calendar-weekdays',
          children: weeknameCells
        },
        monthElement = {
          className: 'b-yearview-month',
          children: [monthHeader, weekNameRow]
        },
        weeks = monthElement.children;
      children.push(monthElement);
      let cellIndex = 0;
      month.eachWeek((week, dates) => {
        // Populate week day cells when processing first week of month.
        if (weeknameCells.length === 1) {
          for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
            weeknameCells.push({
              className: {
                'b-yearview-weekday-cell': 1,
                [nonWorkingDayCls]: me.nonWorkingDays[month.canonicalDayNumbers[columnIndex]]
              },
              text: DateHelper.format(dates[columnIndex], 'd1')
            });
          }
        }
        const weekElement = {
            className: 'b-calendar-week',
            dataset: {
              week: `${week[0]},${week[1]}`
            }
          },
          dayCells = weekElement.children = [{
            tag: 'button',
            ariaLabel: me.L('L{Calendar.weekOfYear}', week),
            className: 'b-week-number-cell',
            html: week[1]
          }];
        weeks.push(weekElement);
        for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
          const date = dates[columnIndex],
            isOtherMonth = date.getMonth() !== month.month,
            key = DateHelper.makeKey(date),
            day = date.getDay(),
            cellData = !me.isConfiguring && cellMap.get(key),
            events = cellData === null || cellData === void 0 ? void 0 : cellData.events,
            eventCount = (events === null || events === void 0 ? void 0 : events.length) || 0,
            showOverflow = !isOtherMonth && eventCount,
            cell = {
              // tabIndex  : -1, When we implement Calendar Cell navigation
              style: {},
              className: {
                'b-day-name': 1,
                [dayCellCls]: 1,
                [emptyCellCls]: !eventCount
              },
              dataset: {
                date: key,
                cellIndex,
                columnIndex
              }
            };
          let content = String(date.getDate());
          Object.assign(cell.className, {
            [weekendCls]: DateHelper.weekends[day],
            [todayCls]: key === todayKey && !isOtherMonth,
            [nonWorkingDayCls]: me.nonWorkingDays[day],
            [otherMonthCls]: isOtherMonth,
            'b-cal-cell-overflow': showOverflow,
            [SchedulerDatePicker.getEventCountClass(eventCount)]: showOverflow,
            [`b-day-of-week-${day}`]: 1
          });
          if (me.dayCellRenderer) {
            var _cellData$events;
            const result = me.callback(me.dayCellRenderer, me, [{
              cellConfig: cell,
              date,
              events: (cellData === null || cellData === void 0 ? void 0 : (_cellData$events = cellData.events) === null || _cellData$events === void 0 ? void 0 : _cellData$events.map(data => data.eventRecord)) || []
            }]);
            if (result != null) {
              content = result;
            }
          }
          // Event count tooltip to show only if the overflow popup is not shown on hover.
          if (eventCount && me.eventCountTip && !isHoverGesture[me.overflowPopupTrigger]) {
            cell.dataset.btip = me.L('L{ResourceInfoColumn.eventCountText}', eventCount);
          }
          if (showEvents === 'dots') {
            const children = [];
            for (let i = 0; i < Math.min((events === null || events === void 0 ? void 0 : events.length) || 0, me.maxDots); i++) {
              const eventDomConfig = me.createEventDomConfig({
                eventRecord: events[i].eventRecord,
                // renders without content with just background colour
                minimal: true
              });
              children.push(eventDomConfig);
            }
            content = [typeof content === 'object' ? content : {
              tag: 'span',
              html: content
            }, {
              className: 'b-cal-minimal-event-container',
              children
            }];
          }
          // Cell content
          cell.children = [{
            className: 'b-calendar-cell-inner',
            [typeof content === 'string' ? 'html' : 'children']: content
          }];
          dayCells.push(cell);
          cellIndex++;
        }
      });
    }
    DomSync.sync({
      targetElement,
      domConfig: {
        children
      }
    });
    me.refreshCount = (me.refreshCount || 0) + 1;
    /**
     * Fires when this YearView refreshes.
     * @param {Calendar.widget.YearView} source The triggering instance.
     * @event refresh
     */
    me.trigger('refresh');
  }
  getDayElement(date, strict) {
    if (typeof date !== 'string') {
      date = DateHelper.makeKey(date);
    }
    // Enforce strict meaning this view must own that date
    if (strict && parseInt(date.substr(0, 4)) !== this.year) {
      return;
    }
    // In a multi month view, we must filter out dates which are in the "other month" category.
    return this.contentElement.querySelector(`.b-calendar-cell[data-date="${date}"]:not(.b-other-month)`);
  }
  // Override in this class to eliminate "other" month cells.
  getCell() {
    return this.getDayElement(...arguments);
  }
  onPaint({
    firstPaint
  }) {
    if (firstPaint) {
      this.refresh();
    }
  }
}
YearView.initClass();
YearView._$name = 'YearView';

/**
 * @module Calendar/view/mixin/EventNavigation
 */
const isCalendarMixin = w => w.isCalendarMixin;
/**
 * Mixin that tracks event selection by clicking on one or more events in the calendar.
 * @mixin
 * @extends Scheduler/view/mixin/EventNavigation
 * @typings Scheduler/view/mixin/EventNavigation -> Scheduler/view/mixin/SchedulerEventNavigation
 */
var EventNavigation = (Target => class EventNavigation extends SchedulerEventNavigation(Target || Base) {
  // region Hidden configs
  /**
   * @method beforeAssignmentDelete
   * @hide
   */
  // endRegion
  static get configurable() {
    return {
      /**
       * A config object to use when creating the {@link Core.helper.util.Navigator}
       * to use to perform keyboard navigation in the timeline.
       * @config {NavigatorConfig}
       * @default
       * @category Misc
       * @internal
       */
      navigator: {
        allowCtrlKey: true,
        scrollSilently: true,
        datasetIdProperty: 'eventId',
        // TAB navigation is used, so the Navigator *reacts* to navigation rather than
        // listens for keystrokes and moves focus.
        itemsTabbable: true,
        // Override inherited SchedulerEventNavigation handlers
        keys: {
          ArrowUp: null,
          ArrowDown: null,
          Escape: null,
          Tab: null,
          'SHIFT+Tab': null
        }
      }
    };
  }
  normalizeTarget(event) {
    return event.eventRecord;
  }
  changeNavigator(navigator) {
    const me = this;
    // Force evaluation to create the eventSelector
    me.getConfig('eventCls');
    return super.changeNavigator(me.constructor.mergeConfigs({
      target: me.element,
      itemSelector: `.b-cal-cell-overflow,.b-cal-cell-no-content,${me.eventSelector}`,
      // Calendar doesn't have a scrollable.
      skipScrollIntoView: true
    }, navigator));
  }
  onViewRefresh() {
    var _super$onViewRefresh, _this$activeView$over;
    (_super$onViewRefresh = super.onViewRefresh) === null || _super$onViewRefresh === void 0 ? void 0 : _super$onViewRefresh.call(this, ...arguments);
    // If the view refreshed while active, correct the active element
    if (this.navigator.activeItem && !((_this$activeView$over = this.activeView.overflowPopup) !== null && _this$activeView$over !== void 0 && _this$activeView$over.containsFocus)) {
      const activeEvent = this.getEventRecord(this.navigator.activeItem);
      if (activeEvent) {
        this.navigator.updateActiveItem(this.getElementFromEventRecord(activeEvent));
      }
    }
  }
  onCalendarStoreChange({
    action,
    records
  }) {
    var _super$onCalendarStor;
    const me = this,
      {
        navigator
      } = me,
      activeItem = navigator === null || navigator === void 0 ? void 0 : navigator.activeItem;
    // Handle keeping a close activeItem if the activeItem ever leaves the store
    if (activeItem && !me.eventStore.includes(activeItem.dataset.eventId)) {
      const activeView = me.constructor.fromElement(activeItem, isCalendarMixin) || me.activeView,
        {
          _overflowPopup
        } = activeView,
        nextItem = navigator.next;
      // If we're in a contiguous range of event bars and not using syncId to map
      // events to the same element, then then the following events will just "move up".
      // Only the last element will be removed, so we "navigate" to the same element.
      if (nextItem === activeItem.nextSibling && !nextItem.parentNode.syncIdMap) {
        // Trigger a navigation event because focus will remain in the document
        // so we are silently navigating to the next item.
        navigator.triggerNavigate({
          eventPhase: Event.BUBBLING_PHASE,
          target: nextItem
        }, nextItem);
      } else {
        // First, navigate forwards or back
        let fallback = nextItem || navigator.previous;
        // But if we are in the overflow popup and that took us out because it was empty,
        // navigate forwards or back from the popup's source cell.
        if (_overflowPopup !== null && _overflowPopup !== void 0 && _overflowPopup.containsFocus && !_overflowPopup.contentElement.contains(fallback)) {
          const {
            target
          } = _overflowPopup.lastAlignSpec;
          // Move forward or backward from the cell.
          fallback = navigator.getAdjacent(1, target.nextSibling) || navigator.getAdjacent(-1, target);
        }
        // If a previous or next event element was not found, push focus
        // to where it came in from with a forced outward focus reversion if they clicked straight
        // in and there was no relatedTarget.
        if (!fallback) {
          me.widgetMap.viewContainer.revertFocus(true);
        } else {
          // Capture the full context of the soon-to-be-active fallback event.
          // We will need to recapture the corresponding element after the refresh.
          const nextActiveDate = activeView.getDateFromElement(fallback),
            nextActiveEventId = fallback.dataset.eventId,
            nextActiveView = me.constructor.fromElement(fallback).closest(isCalendarMixin);
          // Must keep focus in the Calendar if possible.
          // This item *should* remain undisturbed by a DomSync refresh
          fallback.focus();
          // After the impending refresh, restore focus
          nextActiveView.ion({
            refresh: () => {
              // Recapture the matching element after the refresh
              fallback = nextActiveView.getEventElement(nextActiveEventId, nextActiveDate);
              // May not always be one. YearView is not yet keyboard-navigable.
              if (fallback) {
                if (fallback === DomHelper.getActiveElement(fallback)) {
                  // Trigger a navigation event because focus has remained in the document
                  // so it was a silent navigate to the next item.
                  navigator.triggerNavigate({
                    eventPhase: Event.BUBBLING_PHASE,
                    target: fallback
                  }, fallback);
                } else {
                  fallback.focus();
                }
              }
              navigator.updateActiveItem(fallback, activeItem);
            },
            once: true
          });
        }
      }
    }
    (_super$onCalendarStor = super.onCalendarStoreChange) === null || _super$onCalendarStor === void 0 ? void 0 : _super$onCalendarStor.call(this, ...arguments);
  }
  onElementKeyDown(keyEvent) {
    if (keyEvent.target.closest(this.navigator.itemSelector)) {
      var _super$onElementKeyDo;
      (_super$onElementKeyDo = super.onElementKeyDown) === null || _super$onElementKeyDo === void 0 ? void 0 : _super$onElementKeyDo.call(this, keyEvent);
    }
  }
  /**
   * The currently focused event record.
   * @property {Scheduler.model.EventModel}
   * @readonly
   */
  get activeEvent() {
    const {
      activeItem
    } = this.navigator;
    if (activeItem) {
      return this.resolveEventRecord(activeItem);
    }
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement thus.
  get widgetClass() {}
});

/**
 * @module Calendar/view/mixin/EventSelection
 */
/**
 * Mixin that tracks event selection by clicking on one or more events in the calendar.
 * @mixin
 * @extends Scheduler/view/mixin/EventSelection
 * @typings Scheduler/view/mixin/EventSelection -> Scheduler/view/mixin/SchedulerEventSelection
 */
var EventSelection = (Target => class EventSelection extends SchedulerEventSelection(Target || Base) {
  //region Hidden configs
  /**
   * @event eventSelectionChange
   * @hide
   */
  /**
   * @event assignmentSelectionChange
   * @hide
   */
  /**
   * @member {Scheduler.model.AssignmentModel[]} selectedAssignments
   * @hide
   */
  /**
   * @config {String} eventAssignHighlightCls
   * @hide
   */
  /**
   * @method deselectAssignment
   * @param {Scheduler.model.AssignmentModel} assignment The assignment to deselect
   * @hide
   */
  /**
   * @method deselectAssignments
   * @param {Scheduler.model.AssignmentModel[]} assignments Assignments  to be deselected
   * @hide
   */
  /**
   * @method isAssignmentSelected
   * @param {Scheduler.model.AssignmentModel} assignment The assignment
   * @hide
   */
  /**
   * @method selectAssignment
   * @param {Scheduler.model.AssignmentModel} assignment The assignment to select
   * @param {Boolean} [preserveSelection] Pass `true` to preserve any other selected assignments
   * @hide
   */
  /**
   * @method selectAssignments
   * @param {Scheduler.model.AssignmentModel[]} assignments Assignments to be selected
   * @hide
   */
  //endregion
  //region Events
  /**
   * Fired any time there is a change to the events selected in the Calendar.
   * @event selectionChange
   * @param {Calendar.view.Calendar} source The Calendar instance.
   * @param {'select'|'deselect'|'update'|'clear'} action One of the actions 'select', 'deselect', 'update',
   * 'clear'
   * @param {Scheduler.model.EventModel[]} selected An array of the Events added to the selection.
   * @param {Scheduler.model.EventModel[]} deselected An array of the Event removed from the selection.
   * @param {Scheduler.model.EventModel[]} selection The new selection.
   */
  //endregion
  normalizeTarget(event) {
    return event.eventRecord;
  }
  /**
   * Responds to mutations of the underlying selection Collection.
   * Keeps the UI synced, selectionChange event is fired when `me.silent` is falsy.
   * @private
   */
  onSelectedCollectionChange({
    added,
    removed
  }) {
    const me = this,
      selection = me.selectedCollection,
      selected = added || [],
      deselected = removed || [];
    me.updateSelected();
    if (!me.silent) {
      const action = selection.count > 0 ? selected.length > 0 && deselected.length > 0 ? 'update' : selected.length > 0 ? 'select' : 'deselect' : 'clear';
      me.trigger('selectionChange', {
        action,
        selection: selection.values,
        selected,
        deselected
      });
    }
  }
  onCalendarStoreChange({
    action,
    records
  }) {
    var _super$onCalendarStor;
    // Deselect on remove, not load.
    // Calendar can load and discard many time periods during navigation.
    // Only events which are actually removed become unselected.
    if (action === 'remove') {
      this.selectedCollection.remove(...records);
    }
    (_super$onCalendarStor = super.onCalendarStoreChange) === null || _super$onCalendarStor === void 0 ? void 0 : _super$onCalendarStor.call(this, ...arguments);
  }
  /**
   * Deselects all {@link Scheduler.model.EventModel events}.
   * @category Selection
   */
  clearEventSelection() {
    this.selectedCollection.clear();
  }
  /**
   * The {@link Scheduler.model.EventModel events} which are selected.
   * @property {Scheduler.model.EventModel[]}
   * @category Selection
   */
  get selectedEvents() {
    return this.selectedCollection.values;
  }
  set selectedEvents(events) {
    events = ArrayHelper.asArray(events);
    // Replace the entire selected collection with the new record set
    this.selectedCollection.splice(0, this.selectedCollection.count, events);
  }
  /**
   * Returns `true` if the {@link Scheduler.model.EventModel event} is selected.
   * @param {Scheduler.model.EventModel} event The event
   * @returns {Boolean} Returns `true` if the event is selected
   * @category Selection
   */
  isEventSelected(event) {
    return this.selectedCollection.includes(event);
  }
  /**
   * Selects the passed {@link Scheduler.model.EventModel event} *if it is not selected*.
   * @param {Scheduler.model.EventModel} event The event to select
   * @param {Boolean} [preserveSelection] Pass `true` to preserve any other selected events
   * @category Selection
   */
  select(event, preserveSelection = false) {
    this.selectEvent(event, preserveSelection);
  }
  /**
   * Selects the passed {@link Scheduler.model.EventModel event} *if it is not selected*.
   * @param {Scheduler.model.EventModel} event The event select
   * @param {Boolean} [preserveSelection] Pass `true` to preserve any other selected events
   * @category Selection
   */
  selectEvent(event, preserveSelection = false) {
    const {
      selectedCollection
    } = this;
    // If the event is already selected, this is a no-op.
    // In this case, selection must not be cleared even in the absence of preserveSelection
    if (!this.isEventSelected(event) && this.isEventSelectable(event) !== false) {
      preserveSelection ? selectedCollection.add(event) : selectedCollection.splice(0, selectedCollection.count, event);
    }
  }
  /**
   * Deselects the passed {@link Scheduler.model.EventModel event}*if it is selected*.
   * @param {Scheduler.model.EventModel} event The event to deselect.
   * @category Selection
   */
  deselect(event) {
    this.deselectEvent(event);
  }
  /**
   * Deselects the passed {@link Scheduler.model.EventModel event} *if it is selected*.
   * @param {Scheduler.model.EventModel} event The event to deselect.
   * @category Selection
   */
  deselectEvent(event) {
    if (this.isEventSelected(event)) {
      this.selectedCollection.remove(event);
    }
  }
  /**
   * Adds {@link Scheduler.model.EventModel events} to the selection.
   * @param {Scheduler.model.EventModel[]} events Events to be selected
   * @category Selection
   */
  selectEvents(events) {
    this.selectedCollection.add(events.filter(event => this.isEventSelectable(event) !== false));
  }
  /**
   * Removes {@link Scheduler.model.EventModel events} from the selection.
   * @param {Scheduler.model.EventModel[]} events Events to be deselected
   * @category Selection
   */
  deselectEvents(events) {
    this.selectedCollection.remove(events);
  }
  /**
   * Mouse listener to update selection.
   * @private
   */
  onEventSelectionClick(clickedRecord) {
    // Multi selection: CTRL means preserve selection, just add or remove the event.
    // Single selection: CTRL deselects already selected event
    if (this.isEventSelected(clickedRecord)) {
      if (GlobalEvents.ctrlKeyDown) {
        this.deselectEvent(clickedRecord);
      }
    } else {
      this.selectEvent(clickedRecord, this.multiEventSelect && GlobalEvents.ctrlKeyDown);
    }
  }
  /**
   * Navigation listener to update selection.
   * @private
   */
  onEventNavigate({
    event,
    item
  }) {
    // Navigating out of the navigation domain leaves selection unchanged.
    if (item) {
      const eventRecord = this.activeView.getEventRecord(item);
      if (eventRecord) {
        // Normally, mousedown on a selected record with no modifier deselects.
        // Context menu should never deselect.
        if (event.button === 2 && this.isEventSelected(eventRecord)) {
          return;
        }
        this.onEventSelectionClick(eventRecord);
      }
      // Click outside of an event;
      else {
        this.clearEventSelection();
      }
    }
  }
  // we do not need this class to participate in widget CSS classes
  get widgetClass() {}
});

/**
 * @module Calendar/view/Calendar
 */
const byWeight = (l, r) => (l.weight || 0) - (r.weight || 0),
  capitalizeRegExp = /(?:.)cell|number|name|overflow|mouse|down|up|dbl|click|over|out|context|menu|date|change|element|popup/g,
  relayedEvents = /^.*event.*|.*resource.*|.*cell.*|.*row.*|.*schedule.*|daynumber.*|weeknumber.*|monthname.*|weekname.*$|beforedatechange|tickchange|.*showoverflowpopup/,
  capitalizeWord = m => StringHelper.capitalize(m),
  isFocusedCalendarMixin = w => w.isCalendarMixin && w.containsFocus;
/**
 * @typedef {Object} CalendarHit
 * @property {'event'|'dayNumber'|'weekNumber'|'cellOverflow'|'schedule'} type The type of the target:
 * `'event'`, `'dayNumber'`, `'weekNumber'`, `'cellOverflow'`, or `'schedule'`.
 * @property {Date} date The date of the target.
 * @property {Scheduler.model.EventModel} eventRecord The target event record.
 */
/**
 * A configurable, aggregated view of a {@link Scheduler.data.EventStore} which may comprise several
 * view types to display the events in different ways.
 *
 * This is the primary way of creating a calendar UI.
 *
 * ## Calendar modes
 * A Calendar may be configured with {@link #config-modes} which describe the types of views of the
 * calendar data which should be shown.
 *
 * These are:
 *  - `'agenda'`
 *  - `'year'`
 *  - `'month'`
 *  - `'week'`
 *  - `'day'`
 *  - `'list'`
 *  - `'resource'`
 *
 * All except `'list'` and `'resource'` are included by default.
 *
 * The modes are instances of the following classes:
 *
 * - {@link Calendar.widget.AgendaView}
 * - {@link Calendar.widget.YearView}
 * - {@link Calendar.widget.MonthView}
 * - {@link Calendar.widget.WeekView}
 * - {@link Calendar.widget.DayView}
 * - {@link Calendar.widget.EventList}
 * - {@link Calendar.widget.ResourceView}
 *
 * Each may be reconfigured from its default configuration by specifying its mode value as an object:
 *
 * ```javascript
 * new Calendar({
 *     appendTo : domElement,
 *     modes : {
 *         month : {
 *             // Week number in a separate, clickable column
 *             showWeekColumn : true
 *         },
 *         week : {
 *             // Day columns start at 8am. No events shown before this
 *             dayStartTime : 8
 *         }
 *     }
 * });
 * ```
 *
 * Modes may be omitted from the view by specifying its mode value as `null`.
 * To specify the initial active mode, {@link #config-mode} config should be used, to manage mode at runtime, {@link #property-mode} property is available.
 *
 * ```javascript
 * new Calendar({
 *     appendTo : domElement,
 *     mode  : 'week',
 *     modes : {
 *         agenda : null,
 *         year   : null
 *     }
 * });
 * ```
 *
 *
 * Other provided UI elements may be omitted from the view by specifying their configuration values as `null`:
 *
 * ```javascript
 * new Calendar({
 *     appendTo : domElement,
 *
 *     // Do not show the top toolbar
 *     tbar : null,
 *
 *     // Do not show the sidebar
 *     sidebar : null
 * });
 * ```
 *
 * Or, for more granularity:
 *
 * ```javascript
 * new Calendar({
 *     appendTo : domElement,
 *
 *     tbar : {
 *         items : {
 *             // Do not show the "Today" button in the top toolbar
 *             todayButton : null
 *         }
 *     },
 *
 *     sidebar : {
 *         items : {
 *             // Do not show the mini calendar in the sidebar
 *             datePicker : null
 *         }
 *     }
 * });
 * ```
 *
 * ## Toolbar & sidebar
 * A Calendar is basically a {@link Core.widget.Panel} which contains nested widgets which implement
 * the complex UI. By default it has three immediate child widgets which may be accessed through the
 * following properties:
 *
 * - {@link #property-tbar} references the top toolbar, which is an instance of {@link Core.widget.Toolbar}.
 * - {@link #property-sidebar} references the sidebar, which is an instance of {@link Calendar.widget.Sidebar}.
 * - {@link #property-viewContainer} references the subordinate {@link Core.widget.Container} which manages the modes
 * and changes which mode is active through its {@link Core.widget.Container#property-layout}.
 *
 * ## Loading data
 * A Calendar loads its data into an {@link Scheduler.data.EventStore}.
 *
 * The recommended way to load and sync data is to use a {@link Scheduler.data.CrudManager} configured with
 * the URL of web services:
 *
 * ```javascript
 * new Calendar({
 *     appendTo : domElement,
 *     crudManager : {
 *         transport : {
 *             load : {
 *                 url : '/data-providing-url'
 *             }
 *             sync : {
 *                 url : '/data-update-url'
 *             }
 *         },
 *         autoLoad : true,
 *         autoSync : true
 *     }
 * });
 * ```
 *
 * JSON data should use this format:
 *
 * ```json
 * {
 *     "success" : true,
 *     "resources" : {
 *         "rows" : [
 *             {
 *                 "id" : 1,
 *                 "name" : 'Default Calendar',
 *                 "eventColor" : 'green'
 *             }
 *         ]
 *     },
 *     "events" : {
 *         "rows" : [
 *             {
 *                 "id" : 1,
 *                 "name" : 'Meeting',
 *                 "startDate" : '2020-10-01T10:00:00',
 *                 "endDate" : '2020-10-01T11:00:00',
 *                 "resourceId" : 1
 *             }
 *         ]
 *     }
 * }
 * ```
 *
 * ### Multiple assignment
 *
 * When multiple resource assignment is required, data should look as below. Assignments
 * are seperate records which link events to resources by connecting the ids of each.
 *
 * In this example, event id `1` is assigned to resources `1` and `2`
 *
 * Note that there is __no__ `resourceId` field in the event data:
 *
 * ```json
 * {
 *     "success" : true,
 *     "resources" : {
 *         "rows" : [
 *             {
 *                 "id" : 1,
 *                 "name" : 'Default Calendar',
 *                 "eventColor" : 'green'
 *             }, {
 *                 "id" : 2,
 *                 "name" : 'Alternative Calendar',
 *                 "eventColor" : 'red'
 *             }
 *         ]
 *     },
 *     "events" : {
 *         "rows" : [
 *             {
 *                 "id" : 1,
 *                 "name" : 'Meeting',
 *                 "startDate" : '2020-10-01T10:00:00',
 *                 "endDate" : '2020-10-01T11:00:00'
 *             }
 *         ]
 *     },
 *     "assignments" : {
 *         "rows" : [
 *             {
 *                 id         : 1,
 *                 eventId    : 1,
 *                 resourceId : 1
 *             }, {
 *                 id         : 2,
 *                 eventId    : 1,
 *                 resourceId : 2
 *             }
 *         ]
 *     }
 * }
 * ```
 *
 * ### Loading time ranges
 *
 * When using the {@link Calendar.feature.TimeRanges} feature, the time ranges are included in
 * named data blocks:
 *
 * ```json
 * {
 *     success : true,
 *     events : {...},
 *     resources : {...},
 *     timeRanges : {
 *         rows : [
 *             {
 *                 "id"        : 1,
 *                 "name"      : "Post-conference",
 *                 "alignment" : "end",
 *                 "startDate" : "2020-10-15 15:00",
 *                 "endDate"   : "2020-10-15 20:00",
 *                 "color"     : "red"
 *             }
 *         ]
 *     }
 * }
 * ```
 *
 * When using a {@link Calendar.widget.ResourceView}, resource-specific time ranges may
 * also be included in the data. These are only rendered in subviews of the resource view
 * with matching resource ids:
 *
 * ```json
 * {
 *     success : true,
 *     events : {...},
 *     resources : {...},
 *     resourceTimeRanges : {
 *         rows : [
 *             {
 *                 "id"         : 1,
 *                 "resourceId" : 1
 *                 "name"       : "Post-conference",
 *                 "alignment"  : "end",
 *                 "startDate"  : "2020-10-15 15:00",
 *                 "endDate"    : "2020-10-15 20:00",
 *                 "color"      : "red"
 *             }
 *         ]
 *     }
 * }
 * ```
 *
 * For more information on loading events and resources, see the {@link Scheduler.view.Scheduler}
 * documentation. Calendar uses the same data classes.
 *
 * ## Listening to events
 * The events emitted by the Calendar are documented {@link #event-eventClick here}. Note that in
 * addition to `click`, all other mouse events are also covered and all significant UI elements
 * are active, and follow the same naming convention.
 *
 * So there is a `dayNumberClick` event and a `weekNumberClick` event and a
 * `monthNameClick` event and so on.
 *
 * ## Specifying a default calendar
 *
 * To set the default calendar for your events, please use the {@link #config-defaultCalendar} config.
 *
 * ```javascript
 * new Calendar({
 *     defaultCalendar : 123 // the id of your default calendar
 * });
 * ```
 *
 * You may specify {@link #config-defaultCalendar} as `null` to specify that when an event is
 * {@link #config-autoCreate auto created}, it is not automatically assigned to a calendar.
 *
 * @extends Core/widget/Panel
 *
 * @mixes Core/widget/mixin/Responsive
 * @mixes Calendar/mixin/CalendarStores
 * @mixes Scheduler/crud/mixin/CrudManagerView
 * @mixes Scheduler/view/mixin/RecurringEvents
 * @mixes Calendar/view/mixin/EventNavigation
 * @mixes Calendar/view/mixin/EventSelection
 *
 * @features Calendar/feature/CalendarDrag
 * @features Calendar/feature/EventEdit
 * @features Calendar/feature/EventMenu
 * @features Calendar/feature/EventTooltip
 * @features Calendar/feature/ExternalEventSource
 * @features Calendar/feature/LoadOnDemand
 * @features Calendar/feature/ScheduleMenu
 * @features Calendar/feature/TimeRanges
 * @features Calendar/feature/WeekExpander
 *
 * @features Calendar/feature/print/Print
 *
 * @classType calendar
 * @inlineexample Calendar/view/Calendar.js
 * @widget
 */
class Calendar extends Panel.mixin(SchedulerInterface, CalendarStores, Featureable, CrudManagerView, EventNavigation, EventSelection, CurrentConfig, Responsive, State, RecurringEvents) {
  // Do not remove. Assertion strings for Localization sanity check.
  // 'L{loadFail}'
  //region Config
  static get $name() {
    return 'Calendar';
  }
  // Factoryable type name
  static get type() {
    return 'calendar';
  }
  static get configurable() {
    return {
      // region Hidden configs
      /**
       * @event eventSelectionChange
       * @hide
       */
      /**
       * @hideconfigs htmlCls, autoUpdateRecord, record, textContent, content, html
       */
      /**
       * @hideproperties content, html
       */
      // endRegion
      /**
       * Enables events being recurring and also adds extra recurrence UI fields in the built-in event editor.
       * @config {Boolean}
       * @default true
       * @category Scheduled events
       */
      enableRecurringEvents: true,
      localizableProperties: ['autoCreate.newName'],
      crudManager: null,
      features: {
        drag: {},
        eventEdit: {},
        eventTooltip: {},
        eventMenu: {}
      },
      /**
       * Indicates where the Next/Previous/Today buttons should be placed.
       * @config {'toolbar'|'sidebar'}
       * @default 'toolbar'
       */
      navigatorPlacement: null,
      responsive: {
        small: {
          when: 600,
          once: {
            mode: 'day'
          }
        },
        medium: {
          when: 800
        },
        large: {
          overlaySidebar: false
        },
        '*': {
          overlaySidebar: true,
          once: {
            mode: 'week'
          }
        }
      },
      responsiveRoot: true,
      stateful: ['hideNonWorkingDays', 'mode'],
      /**
       * A {@link Core.widget.Toolbar} which displays and manages the calendar title
       * and the buttons which manipulate the Calendar's temporal navigation and
       * active mode.
       *
       * Provided widgets include:
       *
       * - `toggleSidebar` A button to collapse and expand the {@link #config-sidebar}
       * - `todayButton` A button which moves the active view to include today's date.
       * - `prevButton` A button which moves the active view to its previous time span.
       * <br>__Note:__ The active view must yield a {@link Calendar.widget.mixin.CalendarMixin#property-stepUnit}
       * to use as the tooltip hint for this button, otherwise it will be disabled.
       * - `nextButton` A button which moves the active view to its next time span.
       * <br>__Note:__ The active view must yield a {@link Calendar.widget.mixin.CalendarMixin#property-stepUnit}
       * to use as the tooltip hint for this button, otherwise it will be disabled.
       * - `viewDescription` A widget which is used to display the `description` property of the active view.
       * - `spacer` A spacer widget which pushes following items to be aligned to the right.
       * - `modeSelector` A {@link Calendar.widget.ModeSelector} which contains buttons for selecting which
       *   view is active. This is hidden if only one {@link #config-modes mode} is enabled in the Calendar.
       *
       * These have `weight` values 100 to 800. New items can be inserted at any position by
       * configuring them with an appropriate `weight`.
       *
       * @member {Core.widget.Toolbar} tbar
       * @readonly
       * @category Content
       */
      /**
       * A config object containing definitions of the toolbar of the Calendar.
       *
       * Its `items` property defines the buttons and informational widgets
       * provided by default.
       *
       * There are several provided widgets, each of which may be reconfigured using
       * an object, or disabled by configuring them as `null`.
       *
       * ```javascript
       * tbar : {
       *     items : {
       *         prevButton    : null,
       *         toggleSidebar : null
       *     }
       * }
       * ```
       *
       * Provided widgets include:
       *
       * - `toggleSidebar` A button to collapse and expand the {@link #config-sidebar}
       * - `todayButton` A button which moves the active view to include today's date.
       * - `prevButton` A button which moves the active view to its previous time span.
       * <br>__Note:__ The active view must yield a {@link Calendar.widget.mixin.CalendarMixin#property-stepUnit}
       * to use as the tooltip hint for this button, otherwise it will be disabled.
       * - `nextButton` A button which moves the active view to its next time span.
       * <br>__Note:__ The active view must yield a {@link Calendar.widget.mixin.CalendarMixin#property-stepUnit}
       * to use as the tooltip hint for this button, otherwise it will be disabled.
       * - `viewDescription` A widget which is used to display the `description` property of the active view.
       * - `spacer` A spacer widget which pushes following items to be aligned to the right.
       * - `modeSelector` A {@link Calendar.widget.ModeSelector} which contains buttons for selecting which
       *   view is active. This is hidden if only one {@link #config-modes mode} is enabled in the Calendar.
       *
       * These have `weight` values 100 to 800. New items can be inserted at any position by
       * configuring them with an appropriate `weight`.
       *
       * Configure this as `null` to remove the toolbar entirely.
       * @config {ToolbarConfig}
       */
      tbar: {
        cls: 'b-calendar-toolbar',
        items: {
          toggleSideBar: {
            icon: 'b-icon-menu-vertical',
            cls: 'b-sidebar-toggle b-borderless b-transparent',
            onClick: 'up.onToggleSidebarClick',
            weight: 100
          },
          todayButton: {
            text: 'L{Calendar.Today}',
            cls: 'b-cal-nav-item b-calendar-today-button',
            icon: 'b-icon-calendar-day',
            onClick: 'up.shiftToNow',
            weight: 200
          },
          prevButton: {
            onClick: 'up.shiftPrevious',
            cls: 'b-cal-nav-item b-borderless b-transparent',
            icon: 'b-icon-previous',
            weight: 300
          },
          nextButton: {
            onClick: 'up.shiftNext',
            cls: 'b-cal-nav-item b-borderless b-transparent',
            icon: 'b-icon-next',
            weight: 400
          },
          viewDescription: {
            cls: 'b-calendar-view-desc',
            type: 'widget',
            flex: '',
            html: '\xa0',
            overflowable: 'none',
            weight: 500
          },
          spacer: {
            type: 'widget',
            cls: 'b-toolbar-fill',
            weight: 600
          },
          modeSelector: {
            type: 'calendarModeSelector',
            weight: 700
          }
        }
      },
      /**
       * The child items of the Calendar view.
       *
       * The Calendar contains two child items:
       *
       * - `sidebar` The sidebar which by default contains a clickable date picker to show and/or select
       * the active date, and a Calendar filter UI to filter events belonging to the calendars
       * defined in the {@link Calendar.mixin.CalendarStores#config-resourceStore}.
       * - `viewContainer` A {@link Core.widget.layout.Card card layout}
       * {@link Core.widget.Container container} which contains the enabled {@link #config-modes}.
       *
       * These items may be reconfigured by specifying them as an object, for example:
       *
       * ```javascript
       * new Calendar({
       *     appendTo : document.body,
       *
       *     crudManager : {
       *         transport : {
       *             load : {
       *                 url : '/data-providing-url'
       *             }
       *             sync : {
       *                 url : '/data-update-url'
       *             }
       *         },
       *         autoLoad : true,
       *         autoSync : true
       *     },
       *
       *     // Reconfigure our viewContainer to change which "mode" is active upon startup
       *     items : {
       *         viewContainer : {
       *             // Start looking at the week - its the fourth "mode" by default.
       *             layout : {
       *                 activeIndex : 3
       *             }
       *         }
       *     }
       * });
       * ```
       * @config {Object}
       */
      items: {
        viewContainer: {
          type: 'container',
          cls: 'b-calendar-viewcontainer',
          flex: '1 1 100%',
          layout: {
            type: 'card'
          },
          scrollable: {
            overflowY: true,
            overflowX: true
          },
          suppressChildHeaders: true,
          layoutStyle: {
            padding: 0
          },
          internalListeners: {
            beforeActiveItemChange: 'up.onBeforeModeChange',
            activeItemChange: 'up.onModeChange'
          }
        }
      },
      /**
       * Set to `true` to show the "Weekends" toggle button of the mode selector. Alternatively, this config
       * can be a {@link Core.widget.Button} config object to configure the button.
       * @config {Boolean|ButtonConfig}
       * @default
       */
      includeWeekendsButton: false,
      layoutStyle: {
        padding: 0,
        flexFlow: 'row nowrap'
      },
      /**
       * The {@link #config-modes} as widget instances.
       * @member {Object<String,Core.widget.Widget>} modes
       */
      /**
       * Configures the possible view modes.
       *
       * Each entry may be a config object to configure the specified view type, or `null` to omit a view type.
       *
       * Non-standard types, outside of the five types below may be specified, but those objects must contain a
       * `type` property which defines the widget type to create and they must yield a `title` property for the
       * view's activation button and a `description` property to be used in the Calendar view's toolbar.
       *
       * ```javascript
       * modes : {
       *     agenda : {
       *         title : 'Conference events'
       *     },
       *     // Disable year view completely
       *     year : null,
       *     // We want to see the events as a list
       *     list : {
       *         range : 'month'
       *     }
       * }
       * ```
       *
       * Note that the default order of the modes can be changed by configuring the modes with a `weight` value
       * which causes them to be sorted into ascending weight order.
       *
       * @property {AgendaViewConfig|Boolean} [modes.agenda] Settings specific to `agenda` mode. Specify `null` to disable this mode.
       * @property {YearViewConfig|Boolean} [modes.year] Settings specific to `year` mode. Specify `null` to disable this mode.
       * @property {MonthViewConfig|Boolean} [modes.month] Settings specific to `month` mode. Specify `null` to disable this mode.
       * @property {WeekViewConfig|Boolean} [modes.week] Settings specific to `week` mode. Specify `null` to disable this mode.
       * @property {DayViewConfig|Boolean} [modes.day] Settings specific to `day` mode. Specify `null` to disable this mode.
       * @property {EventListConfig|Boolean} [modes.list] Settings specific to `list` mode. This mode is disabled by default.
       * @config {Object} [modes]
       * @default
       */
      modes: {
        day: {
          // This view is locked to one day duration
          fixedDuration: true
        },
        week: {},
        month: {},
        year: {},
        agenda: {}
      },
      /**
       * Which of the built-in {@link #config-modes} should be the initially active view.
       * @config {String}
       * @default
       */
      mode: 'week',
      /**
       * The default settings applied to all child views.
       *
       * This is a dynamic object, and mutations of it will reapply the new value to all
       * child views.
       * @member {Object} modeDefaults
       */
      /**
       * An object to use to configure common properties for all {@link #config-modes} prior to their construction.
       * @config {Object}
       */
      modeDefaults: {
        value: null // use the value config so that the changer always runs so that Proxy is created
      },

      /**
       * The {@link #config-sidebar} as an instance of {@link Calendar.widget.Sidebar}.
       * @member {Core.widget.Container} sidebar
       * @readonly
       */
      /**
       * An optional config object to configure the {@link Calendar.widget.Sidebar} which is
       * shown next to the calendar views specified by the {@link #config-modes}.
       *
       * To disable the sidebar, configure it as `null`.
       *
       * To reconfigure it, specify this config value as an object. The following parameters include
       * several commonly reconfigured properties.
       * @config {Object|Boolean}
       * @param {'left'|'right'} side Which {@link Calendar.widget.Sidebar#config-side} to dock to.
       * @param {Boolean} collapsed May be initially {@link Calendar.widget.Sidebar#config-collapsed}.
       * @param {Object<String,ContainerItemConfig>} items Reconfigure or add to the sidebar UI.
       * @param {DatePickerConfig} items.datePicker The {@link Core.widget.DatePicker} may be reconfigured using
       * an object, or configured away using `null`. Its default {@link Core.widget.Widget#config-weight} is 100.
       * @param {TextFieldConfig} items.eventFilter The eventFilter is a {@link Core.widget.TextField} which may
       * be used to filter the events by matched name. It may be reconfigured using an object, or configured away
       * using `null`. Its default {@link Core.widget.Widget#config-weight} is 150.
       * @param {ResourceFilterConfig} items.resourceFilter The {@link Scheduler.widget.ResourceFilter} may be
       * reconfigured using an object, or configured away using `null`. Its default
       * {@link Core.widget.Widget#config-weight} is 200.
       * @param {Object} items.resourceFilter.scrollable By default it scrolls in the Y axis.
       * @param {String|Number} items.resourceFilter.flex By default it uses flex `1 1 auto`.
       * @param {Function} items.resourceFilter.masterFilter The filter function to apply when loading resources
       * from the project's `resourceStore`. Defaults to only including resources which are filtered into the Project's
       * `resourceStore`. Configure this as `() => true` to always include all resources.
       */
      sidebar: {
        $config: {
          merge: 'objects'
        },
        value: {
          type: 'sidebar',
          side: 'left',
          scrollable: {
            overflowY: true
          },
          internalListeners: {
            dateChange: 'up.onCalendarDateChange'
          }
        }
      },
      /**
       * An optional config object to configure the {@link Calendar.widget.CalendarDatePicker} which is
       * shown in the {@link #property-sidebar} next to the calendar views.
       *
       * To disable the datePicker, configure it as `null`.
       *
       * To reconfigure it, specify this config value as an object.
       *
       * Note that when `showEvents` is set in the `datePicker`, the cells are slightly larger,
       * therefore the `datePicker` takes up more space and so will make the
       * {@link #property-sidebar} a little wider than normal.
       * @config {Object|Boolean}
       * @param {Boolean|'count'|'dots'} [datePicker.showEvents] Displays the presence of events in each cell.
       * values may be:
       *
       * * `false` - Do not show events in cells.
       * * `true` - Show a themeable bullet to indicate the presence of events for a date.
       * * `'count'` - Show a themeable badge containing the event count for a date.
       * * '`dots'` - Show small event-coloured bullets (to a maximum of three) below the date.
       * @param {Boolean} [datePicker.collapsible] `true` to enable collapse into a header.
       * @param {String} [datePicker.title] The text to place in a header above the picker.
       * @param {Boolean} [datePicker.editMonth] `true` to enable setting the date using the controls
       * in the DatePicker header.
       */
      datePicker: {
        $config: {
          merge: 'objects'
        },
        value: {
          weight: 100,
          dayNameFormat: 'd1',
          editMonth: null,
          focusable: false,
          trapFocus: false
        }
      },
      /**
       * By default, the {@link #property-sidebar} expands and collapses taking width from the
       * calendar UI. Configure `overlaySidebar` as `true` to have it start collapsed, and then
       * **overlay** the calendar UI when the expand/collapse button is toggled.
       * @config {Boolean}
       * @default false
       */
      overlaySidebar: null,
      /**
       * The date which this Calendar encapsulates as its active date.
       *
       * This is usually selected by clicking in the {@link #property-sidebar}'s date picker
       * or by navigating the view forwards or backwards in time.
       *
       * This is also changed by clicking in day cells of the active view.
       *
       * This may be set programatically which will cause the currently active view to navigate to
       * encapsulate that date.
       * @member {Date} date
       */
      /**
       * The date which the Calendar, its {@link #property-sidebar}'s date picker, and
       * its active view should encapsulate upon creation. Defaults to current date.
       * @config {Date}
       * @default
       */
      date: {
        $config: {
          equal: 'date'
        },
        value: new Date()
      },
      /**
       * A {@link Core.helper.DateHelper} format string to use to create date output for
       * view descriptions.
       * @config {String}
       */
      dateFormat: 'MMMM DD, YYYY',
      scrollManager: {
        $config: ['lazy', 'nullify'],
        value: {
          direction: 'vertical'
        }
      },
      viewUpdateDelay: 2000,
      /**
       * Get/set the calendar's read-only state. When set to `true`, any UIs for modifying data are disabled.
       * @member {Boolean} readOnly
       */
      /**
       * Configure as `true` to make the calendar read-only, by disabling any UIs for modifying data.
       *
       * __Note that checks MUST always also be applied at the server side.__
       * @config {Boolean}
       * @default false
       */
      readOnly: null,
      /**
       * Set to false if you don't want to allow events overlapping times for any one resource (defaults to true).
       * @config {Boolean}
       * @default
       */
      allowOverlap: true,
      testConfig: {
        viewUpdateDelay: 5,
        // Test environment must be prevented from clicking the UI very fast while network IO
        // is in flight. LoadOnDemand testing was susceptible to this.
        loadMask: {
          text: 'L{GridBase.loadMask}',
          showDelay: 0
        }
      },
      /**
       * Configure this as `true` to make picking a date in the {@link #config-sidebar}'s
       * date picker highlight the date cell in the active view.
       *
       * May also be specified as a function which will be passed the date cell element to enable
       * performing customized highlighting.
       * @config {Boolean|Function}
       */
      highlightDate: null,
      /**
       * If this config is set, then the `gesture` configured (which defaults to `dblclick`) creates a
       * new event at the mouse or touch event's time point.
       *
       * The exact time is rounded to the closest specified `step` value.
       *
       * The duration of the created event is the specified `duration` value.
       *
       * If this is specified as `true`, the `gesture` becomes `dblclick`, and the other properties
       * are the default values listed below.
       *
       * If this is specified as a string, the string becomes the `gesture`, and the other properties
       * are the default values listed below.
       *
       * @property {String} [autoCreate.gesture='dblclick'] The event name which should trigger event creation at the event's position.
       * @property {String} [autoCreate.newName='New Event'] The name of an event created using `autoCreate` or a function to call which yields the name.
       * @property {String} [autoCreate.step='15 minutes'] The time unit by which to round the start click point of auto created events.
       * _Only for views which have a granularity of less than one day such as `WeekView` and `DayView'_.
       *
       * For views which show whole days, the start defaults to 8am.
       *
       * This is a string in the format required by {@link Core.helper.DateHelper#function-parseDuration-static}.
       * @property {String} [autoCreate.duration='1 hour'] The default duration for auto created events.
       * @property {Number | String} [autoCreate.startHour=8] The default start hour for auto created events
       * in views where the time granularity is one day. In a DayView or WeekView where a mouse event position
       * will translate to a time of day, this is not used.
       *
       * This is the hour of the day to start the event at. It can be fractional or an HH:MM:SS time string.
       * @config {Object|String|Boolean}
       * @default
       */
      autoCreate: {
        gesture: 'dblclick',
        newName: 'L{Object.newEvent}',
        step: '15 minutes',
        duration: '1 hour',
        startHour: 8
      },
      focusable: false,
      // The common Navigator needs to know this
      eventCls: 'b-cal-event',
      /**
       * The week start day to be used throughout this Calendar, 0 meaning Sunday, 6 meaning Saturday.
       *
       * This propagates into all owned {@link #config-modes}.
       *
       * Defaults to {@link Core.helper.DateHelper#property-weekStartDay-static}. When the default value is used, changing locale
       * will dynamically change the week start day for the calendar and all {@link #config-modes}.
       *
       * __If__ this is configured in from the start, then locale values for the week start day
       * will __not__ apply.
       *
       * For example:
       * ```javascript
       * new Calendar({
       *     // Apply to this Calendar only
       *     weekStartDay : 1 // Week starts on Monday
       *     //....
       * });
       * ```
       *
       * @config {Number} [weekStartDay]
       */
      weekStartDay: false,
      /**
       * Configure as `true` to hide {@link #config-nonWorkingDays} for each calendar view
       * @prp {Boolean}
       */
      hideNonWorkingDays: null,
      /**
       * Non-working days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
       *
       * This propagates into all owned {@link #config-modes}.
       *
       * Defaults to {@link Core.helper.DateHelper#property-nonWorkingDays-static}. When the default value is used, changing locale
       * will dynamically change the week start day for the calendar and all {@link #config-modes}.
       *
       * __If__ this is configured in from the start, then locale values for the week start day
       * will __not__ apply.
       *
       * Both header and event cells for non working days get the CSS class `b-nonworking-day` added.
       *
       * Note that this is independent of and in addition to weekend days. Cells for Saturday and
       * Sunday always get the CSS class `b-weekend` added.
       *
       * For example:
       * ```javascript
       * new Calendar({
       *     // Apply to this Calendar only
       *     nonWorkingDays : {
       *         0 : true // Only Sunday is non-working day
       *     },
       *     //....
       * });
       * ```
       *
       * @config {Object<Number,Boolean>} [nonWorkingDays]
       */
      nonWorkingDays: false,
      coreHours: null,
      /**
       * Event which is used to show context menus via the context menu features
       * {@link Calendar.feature.EventMenu} and {@link Calendar.feature.ScheduleMenu}.
       * Available options are: 'contextmenu', 'click', 'dblclick'.
       * @config {'contextmenu'|'click'|'dblclick'}
       * @default
       * @category Misc
       */
      contextMenuTriggerEvent: 'contextmenu',
      /**
       * Set to true to listen for CTRL-Z (CMD-Z on Mac OS) keyboard event and trigger undo (redo when SHIFT is pressed).
       * Only applicable when using a {@link Core.data.stm.StateTrackingManager}.
       * @config {Boolean}
       * @default
       * @category Misc
       */
      enableUndoRedoKeys: true,
      /**
       * Path to load resource images from. Used by the resource headers in ResourceView and by
       * {@link Calendar.widget.mixin.CalendarMixin#config-showResourceAvatars} in event-displaying
       * modes.
       *
       * This is used to show resource avatars using the resource's
       * {@link Scheduler/model/ResourceModel#field-image} or
       * {@link Scheduler/model/ResourceModel#field-imageUrl} fields:
       *
       * * `image` represents image name inside the specified `resourceImagePath`,
       * * `imageUrl` represents fully qualified image URL.
       *
       * If an image is not specified for a resource, or the image is not found, the resource's
       * initials will be displayed.
       * @config {String}
       * @category Misc
       */
      resourceImagePath: null,
      /**
       * The minimum date to which the `startDate` of any child view may be navigated.
       * @member {Date} minDate
       */
      /**
       * The minimum date to which the `startDate` of any child view may be navigated.
       * @config {Date|String}
       */
      minDate: null,
      /**
       * The maximum date to which the `endDate` of any child view may be navigated.
       * @member {Date} maxDate
       */
      /**
       * The maximum date to which the `endDate` of any child view may be navigated.
       * @config {Date|String}
       */
      maxDate: null
    };
  }
  static get delayable() {
    return {
      refresh: {
        type: 'raf',
        cancelOutstanding: true
      },
      syncUIWithActiveView: {
        type: 'buffer',
        delay: 1,
        cancelOutstanding: true
      }
    };
  }
  //endregion
  compose() {
    const {
      includeWeekendsButton,
      navigatorPlacement
    } = this;
    return {
      class: {
        [`b-calendar-nav-${navigatorPlacement || 'toolbar'}`]: 1,
        'b-calendar-include-weekends-button': includeWeekendsButton
      }
    };
  }
  //region Overrides
  onPaintOverride() {
    // Internal procedure used for paint method overrides
    // Not used in onPaint() because it may be chained on instance and Override won't be applied
  }
  onPaint() {
    if (this.onPaintOverride()) {
      return;
    }
    super.onPaint();
  }
  onShowOverflowPopup({
    overflowPopup
  }) {
    this.element.classList.add('b-overflow-popup-visible');
    overflowPopup.ion({
      hide: () => this.element.classList.remove('b-overflow-popup-visible'),
      once: true
    });
  }
  //endregion
  //region events
  /**
   * Fires before an event is removed. Can be triggered by user pressing [DELETE] or [BACKSPACE] or by the
   * event editor. Can for example be used to display a custom dialog to confirm deletion, in which case
   * records should be "manually" removed after confirmation:
   *
   * ```javascript
   * calendar.on({
   *    beforeEventDelete({ eventRecords, context }) {
   *        // Show custom confirmation dialog (pseudo code)
   *        confirm.show({
   *            listeners : {
   *                onOk() {
   *                    // Remove the events on confirmation
   *                    context.finalize(true);
   *                },
   *                onCancel() {
   *                    // do not remove the events if "Cancel" clicked
   *                    context.finalize(false);
   *                }
   *            }
   *        });
   *
   *        // Prevent default behaviour
   *        return false;
   *    }
   * });
   * ```
   *
   * @event beforeEventDelete
   * @param {Calendar.view.Calendar} source  The Calendar instance
   * @param {Scheduler.model.EventModel[]} eventRecords  The records about to be deleted
   * @param {Object} context  Additional removal context:
   * @param {Function} context.finalize  Function to call to finalize the removal.
   *      Used to asynchronously decide to remove the records or not. Provide `false` to the function to
   *      prevent the removal.
   * @param {Boolean} [context.finalize.removeRecords = true]  Provide `false` to the function to prevent
   *      the removal.
   * @preventable
   */
  /**
   * Fires when a day spanning event is found, and the date to which its encapsulating event bar
   * extends has been calculated.
   *
   * The default result in the event's `propagateEndDate` property may be mutated by a listener.
   *
   * Note that this is an ending point in time, it does *not* refer to a 24 hour block. So setting
   * the `propagateEndDate` to `new Date(2022, 1, 10)` means that the event bar will occupy cells
   * up to and including February 9 2022 and no further.
   *
   * This is relayed from all modes, so a single listener may be used, for example:
   *
   * ```javascript
   * new Calendar({
   *     listeners : {
   *         eventPropagate(eventData) {
   *             // If the event spills into the next day but not further
   *             // then we do not want an extended event bar.
   *             // An arrow will indicate that it continues rightwards.
   *             if (eventData.eventEndDate < DateHelper.add(eventData.date, 2, 'd')) {
   *                 eventData.propagateEndDate = DateHelper.add(DateHelper.clearTime(eventData.eventRecord.startDate), 1, 'd');
   *             }
   *         }
   *     }
   * });
   * ```
   *
   * The `eventEndDate` in the data block may also be changed to override the event's real end date.
   * This will mean that there will be no arrow indicating that the event continues:
   *
   * ```javascript
   * new Calendar({
   *     listeners : {
   *         eventPropagate(eventData) {
   *             // If the event spills into the next day but not further
   *             // then we do not want an extended event bar.
   *             // Because we override the eventEndDate, no arrow will be present
   *             // to indicate any continuation.
   *             if (eventData.eventEndDate < DateHelper.add(eventData.date, 2, 'd')) {
   *                 eventData.propagateEndDate = eventData.eventEndDate = DateHelper.add(DateHelper.clearTime(eventData.eventRecord.startDate), 1, 'd');
   *             }
   *         }
   *     }
   * });
   * ```
   *
   * @event eventPropagate
   * @param {Date} eventEndDate The end date for which to calculate the propagate end date.
   * @param {Date} propagateEndDate The system-calculated end point of the event bar.
   * @param {Boolean} isAllDay `true` if the event is an all day event, or spans multiple days.
   * @param {Boolean} isOverflow `true` if this is being called as part of further propagation.
   * @param {Boolean} overflows `true` if the event extends into future cells.
   * @param {Scheduler.model.EventModel} eventRecord The event record being propagated.
   * @param {Date} date The date from which the event is being propagated.
   */
  /**
   * Fires when an event bar is mouseovered in any view.
   * @event eventMouseOver
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Date} date The date of the UI element which contains the event.
   * @param {HTMLElement} eventElement The UI element which represents the event.
   * @param {Scheduler.model.EventModel} eventRecord The event mouseovered.
   * @param {Scheduler.model.ResourceModel} resourceRecord The resource mouseovered if the UI includes a resource.
   * @param {Boolean} fromOverflowPopup `true` if the interaction was through the source view's
   * {@link Calendar.widget.mixin.DayCellRenderer#property-overflowPopup}.
   */
  /**
   * Fires when an event bar is mousedowned in any view.
   * @event eventMouseDown
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Date} date The date of the UI element which contains the event.
   * @param {HTMLElement} eventElement The UI element which represents the event.
   * @param {Scheduler.model.EventModel} eventRecord The event mousedowned on.
   * @param {Scheduler.model.ResourceModel} resourceRecord The resource mousedowned on if the UI includes a resource.
   * @param {Boolean} fromOverflowPopup `true` if the interaction was through the source view's
   * {@link Calendar.widget.mixin.DayCellRenderer#property-overflowPopup}.
   */
  /**
   * Fires when an event bar is mouseupped in any view.
   * @event eventMouseUp
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Date} date The date of the UI element which contains the event.
   * @param {HTMLElement} eventElement The UI element which represents the event.
   * @param {Scheduler.model.EventModel} eventRecord The event mouseupped.
   * @param {Scheduler.model.ResourceModel} resourceRecord The resource mouseupped if the UI includes a resource.
   * @param {Boolean} fromOverflowPopup `true` if the interaction was through the source view's
   * {@link Calendar.widget.mixin.DayCellRenderer#property-overflowPopup}.
   */
  /**
   * Fires when an event bar is clicked in any view.
   * @event eventClick
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Date} date The date of the UI element which contains the event.
   * @param {HTMLElement} eventElement The UI element which represents the event.
   * @param {Scheduler.model.EventModel} eventRecord The event clicked on.
   * @param {Scheduler.model.ResourceModel} resourceRecord The resource clicked on if the UI includes a resource.
   * @param {Boolean} fromOverflowPopup `true` if the interaction was through the source view's
   * {@link Calendar.widget.mixin.DayCellRenderer#property-overflowPopup}.
   */
  /**
   * Fires when an event bar is double clicked in any view.
   * @event eventDblClick
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Date} date The date of the UI element which contains the event.
   * @param {HTMLElement} eventElement The UI element which represents the event.
   * @param {Scheduler.model.EventModel} eventRecord The event double clicked on.
   * @param {Scheduler.model.ResourceModel} resourceRecord The resource double clicked on if the UI includes a resource.
   * @param {Boolean} fromOverflowPopup `true` if the interaction was through the source view's
   * {@link Calendar.widget.mixin.DayCellRenderer#property-overflowPopup}.
   */
  /**
   * Fires when an event bar is mouseouted in any view.
   * @event eventMouseOut
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Date} date The date of the UI element which contains the event.
   * @param {HTMLElement} eventElement The UI element which represents the event.
   * @param {Scheduler.model.EventModel} eventRecord The event mouseouted.
   * @param {Scheduler.model.ResourceModel} resourceRecord The resource mouseouted if the UI includes a resource.
   * @param {Boolean} fromOverflowPopup `true` if the interaction was through the source view's
   * {@link Calendar.widget.mixin.DayCellRenderer#property-overflowPopup}.
   */
  /**
   * Fires when an event bar is right clicked in any view.
   * @event eventContextMenu
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Date} date The date of the UI element which contains the event.
   * @param {HTMLElement} eventElement The UI element which represents the event.
   * @param {Scheduler.model.EventModel} eventRecord The event right clicked on.
   * @param {Scheduler.model.ResourceModel} resourceRecord The resource right clicked on if the UI includes a resource.
   * @param {Boolean} fromOverflowPopup `true` if the interaction was through the source view's
   * {@link Calendar.widget.mixin.DayCellRenderer#property-overflowPopup}.
   */
  /**
   * Fires when a day number is clicked in a view which shows day numbers. This will include
   * the cells of a {@link Calendar.widget.YearView YearView}, the cell header of cells
   * in a {@link Calendar.widget.MonthView MonthView}, and the day header in a
   * {@link Calendar.widget.DayView DayView}.
   * @event dayNumberClick
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Date} date The date clicked on.
   * @param {DayCell} cellData An object that contains data about the calendar cell for the date.
   * @param {Boolean} fromOverflowPopup `true` if the interaction was through the source view's
   * {@link Calendar.widget.mixin.DayCellRenderer#property-overflowPopup}.
   */
  /**
   * Fires when a week number is clicked. This will include the week number cells of a
   * {@link Calendar.widget.YearView YearView}, the week number in the first cell
   * in each row of a {@link Calendar.widget.MonthView MonthView}
   * @event weekNumberClick
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Number[]} week The `[year, week]` clicked on.
   * @param {Date} date The date clicked on.
   */
  /**
   * Fires when a month name header in a {@link Calendar.widget.YearView YearView} is clicked on.
   * @event monthNameClick
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Number} month The month index _(zero based)_ clicked on.
   * @param {Date} date The date of the first of the month clicked on.
   */
  /**
   * Fires when a cell overflow indicator is clicked in any view. This will include
   * the cells of a {@link Calendar.widget.YearView YearView} and the `+ n more` overflow
   * indicator of cells in a {@link Calendar.widget.MonthView MonthView}, and "all day" events section
   * of a {@link Calendar.widget.DayView DayView}.
   * @event cellOverflowClick
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Date} date The date clicked on.
   */
  /**
   * Fires when a mouseover made its way through to an empty part of any view.
   * @event scheduleMouseOver
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Date} date The date mouseovered. _Note that in a {@link Calendar.widget.DayView DayView},
   * this will include granular time information. For other views, this is the *start* of the date.
   */
  /**
   * Fires when a mousedown made its way through to an empty part of any view.
   * @event scheduleMouseDown
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Date} date The date mousedowned on. _Note that in a {@link Calendar.widget.DayView DayView},
   * this will include granular time information. For other views, this is the *start* of the date.
   */
  /**
   * Fires when a mouseup made its way through to an empty part of any view.
   * @event scheduleMouseUp
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Date} date The date mouseupped on. _Note that in a {@link Calendar.widget.DayView DayView},
   * this will include granular time information. For other views, this is the *start* of the date.
   */
  /**
   * Fires when a click made its way through to an empty part of any view.
   * @event scheduleClick
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Date} date The date clicked on. _Note that in a {@link Calendar.widget.DayView DayView},
   * this will include granular time information. For other views, this is the *start* of the date.
   */
  /**
   * Fires when a dblclick made its way through to an empty part of any view.
   * @event scheduleDblClick
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Date} date The date double clicked on. _Note that in a {@link Calendar.widget.DayView DayView},
   * this will include granular time information. For other views, this is the *start* of the date.
   */
  /**
   * Fires when a mouseout made its way through to an empty part of any view.
   * @event scheduleMouseOut
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which triggered the event.
   * @param {Event} domEvent The initiating DOM event.
   * @param {Date} date The date mouseouted. _Note that in a {@link Calendar.widget.DayView DayView},
   * this will include granular time information. For other views, this is the *start* of the date.
   */
  /**
   * Fires when one of the views in this Calendar refreshes.
   * @event refresh
   * @param {Calendar.widget.mixin.CalendarMixin} source The view which refreshed.
   */
  /**
   * Fired when an {@link Calendar.widget.mixin.CalendarMixin#config-autoCreate} gesture has
   * created a new event and added it to the event store.
   *
   * If the {@link Calendar.feature.EventEdit} feature is present, it listens for
   * this event and initiates an edit operation. Adding a high `prio` listener which
   * returns `false` can prevent this event from reaching the `eventEdit` processing.
   * @event eventAutoCreated
   * @param {Calendar.widget.mixin.CalendarMixin} source The child view on which the event was initiated.
   * @param {Scheduler.model.EventModel} eventRecord The new event record.
   */
  /**
   * Fired when an empty cell content area is clicked on in a {@link Calendar.widget.MonthView} or a
   * {@link Calendar.widget.CalendarRow}.
   * @event emptyCellClick
   * @param {Event} domEvent The triggering DOM event.
   * @param {Date} date The date which has no visible events
   */
  //endregion
  static get featureable() {
    return {
      factory: CalendarFeature
    };
  }
  // Gets current date time, time zone converted if time zone is set
  get dateTimeNow() {
    if (this.timeZone != null) {
      return TimeZoneHelper.toTimeZone(new Date(), this.timeZone);
    }
    return new Date();
  }
  // Gets current date with day info only. Time zone converted if time zone is set
  get today() {
    const today = this.dateTimeNow;
    today.setHours(0, 0, 0, 0);
    return today;
  }
  finalizeInit() {
    var _me$activeView;
    super.finalizeInit();
    const me = this,
      hideNonWorkingDays = (_me$activeView = me.activeView) === null || _me$activeView === void 0 ? void 0 : _me$activeView.hideNonWorkingDays;
    if (hideNonWorkingDays != null && me.hideNonWorkingDays == null) {
      me.hideNonWorkingDays = hideNonWorkingDays;
    }
  }
  toggleEmptyText() {
    const {
        crudManager
      } = this,
      {
        eventStore
      } = crudManager || this;
    DomHelper.toggleClasses(this.contentElement, 'b-calendar-empty', !(eventStore.count || crudManager !== null && crudManager !== void 0 && crudManager.isLoading));
  }
  /**
   * Schedules a refresh of the UI for the next animation frame. This is a useful method to call when
   * making multiple data changes, so that each change merely *schedules* a refresh for the next AF and
   * DOM churn is kept to a minimum.
   */
  refresh() {
    this.eachView(v => {
      var _v$refresh;
      return (_v$refresh = v.refresh) === null || _v$refresh === void 0 ? void 0 : _v$refresh.call(v);
    });
  }
  /**
   * The {@link #property-modes} as an Array.
   * @property {Core.widget.Widget[]}
   */
  get views() {
    // Do not invoke the DynamicObject twice
    const {
      modes
    } = this;
    return modes ? Object.values(modes) : [];
  }
  /**
   * Returns the currently active mode as a {@link Core.widget.Widget} instance.
   *
   * Similar to the {@link #property-mode} property which is the active mode's name as a string.
   * @property {Core.widget.Widget}
   */
  get activeView() {
    return this.viewContainer.layout.activeItem;
  }
  /**
   * Returns the lowest level of active view in the mode container.
   *
   * For example, if a {@link Calendar.widget.ResourceView} is the active view, this would
   * return the sub view of that which is currently focused. Or the resourceView if none
   * of the sub views were focused.
   * @property {Core.widget.Widget}
   */
  get activeSubView() {
    var _items$filter;
    const {
        activeView
      } = this,
      {
        items
      } = activeView,
      // If its a multi-CalendarWidget view (Such as a ResourceView), narrow down activeView
      // to the active subView which contains focus.
      activeSubView = (_items$filter = items.filter(isFocusedCalendarMixin)) === null || _items$filter === void 0 ? void 0 : _items$filter[0];
    return activeSubView || activeView;
  }
  captureFocus() {
    return this.activeView.captureFocus();
  }
  /**
   * Returns the event record for a DOM element or DOM event.
   * @param {HTMLElement|Event} elementOrEvent The DOM node to lookup, or a DOM event whose target to lookup.
   * @returns {Scheduler.model.EventModel} The event record
   */
  getEventRecord(elementOrEvent) {
    return this.activeView.getEventRecord(elementOrEvent);
  }
  /**
   * Returns the event record for a DOM element or DOM event.
   * @param {HTMLElement|Event} elementOrEvent The DOM node to lookup, or a DOM event whose target to lookup.
   * @returns {Scheduler.model.EventModel} The event record
   */
  resolveEventRecord(elementOrEvent) {
    // this method is added for symmetry w/SchedulerInterface
    return this.getEventRecord(elementOrEvent);
  }
  onBeforeModeChange({
    prevActiveItem,
    activeItem
  }) {
    var _prevActiveItem$_over, _prevActiveItem$_over2;
    /**
     * Fired before a change of view is initiated.
     * @event beforeActiveItemChange
     * @param {Calendar.view.Calendar} source This Calendar instance.
     * @param {Core.widget.Widget} prevActiveItem The previously active view.
     * @param {Core.widget.Widget} activeItem The new active view.
     * @preventable
     */
    if (this.trigger('beforeActiveItemChange', arguments[0]) === false) {
      return false;
    }
    // Access the property name directly because this is a lazy config.
    // We do not want to cause ingestion and update here.
    // It might be still the initial config form, so might not have hide()
    (_prevActiveItem$_over = prevActiveItem._overflowPopup) === null || _prevActiveItem$_over === void 0 ? void 0 : (_prevActiveItem$_over2 = _prevActiveItem$_over.hide) === null || _prevActiveItem$_over2 === void 0 ? void 0 : _prevActiveItem$_over2.call(_prevActiveItem$_over);
    // In case some of the modes are not standard Calendar widgets which
    // all implement a date setter. Allow them to opt-out of syncing date.
    if ('date' in activeItem && activeItem.syncViewDate !== false) {
      const date = this.date || prevActiveItem.date;
      // Only change the view's date if it *needs* changing -
      // if the view does not have an element for that date.
      if (date) {
        activeItem.date = date;
      }
    }
  }
  onModeChange(event) {
    /**
     * Fired when a change of view has completed. By default, view changes are animated and this
     * event fires when the view is fully visible.
     * @event activeItemChange
     * @param {Calendar.view.Calendar} source This Calendar instance.
     * @param {Core.widget.Widget} prevActiveItem The previously active view.
     * @param {Core.widget.Widget} activeItem The new active view.
     */
    this.trigger('activeItemChange', event);
  }
  onToggleSidebarClick() {
    const {
        sidebar
      } = this,
      {
        collapsible
      } = sidebar;
    // If we are overlaying the sidebar, the button toggles between collapsed and revealed
    // state rather than expanded and collapsed.
    if (collapsible !== null && collapsible !== void 0 && collapsible.isPanelCollapserOverlay) {
      collapsible.toggleReveal(!sidebar.revealed);
    } else {
      sidebar.toggleCollapsed();
    }
  }
  /**
   * Navigates Calendar's {@link #property-activeView active view} to the current local date
   */
  shiftToNow() {
    var _me$sidebar;
    const me = this,
      datePicker = (_me$sidebar = me.sidebar) === null || _me$sidebar === void 0 ? void 0 : _me$sidebar.widgetMap.datePicker,
      {
        dayTime
      } = me.activeView,
      now = new Date(),
      today = dayTime ? dayTime.startOfDay(now) : DateHelper.clearTime(now);
    // Reaction to this to change the activeView's date happens in onCalendarDateChange.
    // updateDate changes the sidebar date if there is a sidebar, else it calls
    // onCalendarDateChange directly.
    // Make sure we use the current view's conception of where a day begins
    me.date = today;
    // Our updateDate will only have done this if our current date is *not* today
    // The sidebar's date picker can be navigated around, but clicking the "today"
    // button must bring all views into line.
    datePicker && (datePicker.date = today);
    me.updateViewDescription();
  }
  /**
   * Navigates back in time in a step unit specific to the Calendar's {@link #property-activeView active view}
   */
  shiftPrevious() {
    const {
      activeItem
    } = this.viewContainer.layout;
    if (activeItem !== null && activeItem !== void 0 && activeItem.previous) {
      activeItem.previous();
      this.updateViewDescription(activeItem);
      if (activeItem.animateTimeShift) {
        DomHelper.slideIn(activeItem.contentElement, -1);
      }
    }
  }
  /**
   * Navigates forward in time in a step unit specific to the Calendar's {@link #property-activeView active view}
   */
  shiftNext() {
    const {
      activeItem
    } = this.viewContainer.layout;
    if (activeItem !== null && activeItem !== void 0 && activeItem.next) {
      activeItem.next();
      this.updateViewDescription(activeItem);
      if (activeItem.animateTimeShift) {
        DomHelper.slideIn(activeItem.contentElement, 1);
      }
    }
  }
  async onCalendarDateChange({
    date,
    userAction
  }) {
    const me = this,
      {
        activeItem
      } = me.viewContainer.layout,
      {
        date: oldDate,
        highlightDate
      } = me;
    // Allow calendar views to opt out of being in sync with Calendar's date
    if (activeItem && activeItem.syncViewDate !== false && 'date' in activeItem) {
      const {
        getDayElement
      } = activeItem;
      // In case triggered from header click the overflow popup for an "other month" cell.
      // Use "_overflowPopup" so as not to call it into existence if it's not created.
      // It might be still the initial config form, so might not have hide()
      if (!DateHelper.betweenLesser(date, activeItem.startDate, activeItem.endDate)) {
        var _activeItem$_overflow, _activeItem$_overflow2;
        (_activeItem$_overflow = activeItem._overflowPopup) === null || _activeItem$_overflow === void 0 ? void 0 : (_activeItem$_overflow2 = _activeItem$_overflow.hide) === null || _activeItem$_overflow2 === void 0 ? void 0 : _activeItem$_overflow2.call(_activeItem$_overflow);
      }
      activeItem.date = date;
      // TODO : Consider moving this chunk to CalendarMixin
      // Highlight the date element if the date change was triggered by user interaction
      // with the date picker. If the date picker was updated from one of the modes
      // then highlighting will not be expected.
      if (userAction && highlightDate && getDayElement) {
        var _activeItem$getDayEle;
        // Some views need to scroll to a date.
        // Agenda, Month (if constrained size), and CalendarRow
        if (activeItem.scrollTo) {
          await activeItem.scrollTo(date);
          // EventList might not contain the exact date. It will scroll to the
          // closest date. If it did that, the scrolledToDate property will be set.
          if (activeItem.scrolledToDate) {
            date = activeItem.scrolledToDate;
          }
        }
        // The date's element might not exist until after the scroll.
        const cell = (_activeItem$getDayEle = activeItem.getDayElement) === null || _activeItem$getDayEle === void 0 ? void 0 : _activeItem$getDayEle.call(activeItem, date);
        // AgendaView might not have a representation of the date
        if (cell) {
          // Not coercible to a number means its a function or name of a function
          if (isNaN(highlightDate)) {
            me.callback(highlightDate, me, [cell, me]);
          }
          // Otherwise, it's truthy or falsy
          else {
            DomHelper.highlight(Rectangle.from(cell));
          }
        }
      }
    }
    /**
     * Fires when the calendar changes the date that it orientates its views around.
     *
     * The Calendar tracks which date the user interacts with so that on mode change,
     * the user is shown the view for the date being interacted with.
     *
     * This is updated on any interaction with the UI. Clicking in the
     * {@link #property-sidebar}'s date picker, clicking on an event, or clicking on a
     * day cell in any view updates the date which the Calendar is using as its orientating date.
     * @event dateChange
     * @param {Calendar.view.Calendar} source This Calendar.
     * @param {Date} oldDate The previous Calendar date.
     * @param {Date} date The new Calendar date.
     */
    me.trigger('dateChange', {
      oldDate,
      date
    });
  }
  updateViewDescription(activeView = this.activeView) {
    const me = this,
      {
        tbar,
        widgetMap
      } = me,
      {
        viewDescription
      } = widgetMap,
      description = `<span class="b-calendar-view-desc-text">${(activeView === null || activeView === void 0 ? void 0 : activeView.description) || ''}</span>`;
    // Allow the Calendar's active mode to be targeted by CSS selectors.
    // Use the activeView property because the passed view might not be a mode
    // it might be a child view of a resource view.
    me.element.dataset.mode = me.activeView.modeName;
    // Keep the sidebar's concept of date of interest in sync with current activeView
    if (activeView) {
      if (tbar && viewDescription) {
        // Even if tbar is present, our predefined tbar widgets may have been configured away.
        // Need the change check to avoid adding the changed class upon initialization.
        // Note that viewDescription?. cannot be used here because the result of
        // viewDescription?.description, if viewDescription is null will not be ===
        // description, so it will then attempt to set the content property. And
        // `viewDescription?.content = description` results in "invalid assignment left-hand side" error.
        if (viewDescription.content !== description) {
          viewDescription.content = description;
        }
      }
      const viewDate = activeView.date || activeView.startDate;
      if (viewDate) {
        // Reaction to this to change the activeView's date happens in onCalendarDateChange.
        // updateDate changes the sidebar date if there is a sidebar, else it calls
        // onCalendarDateChange directly.
        this.date = viewDate;
      }
    }
  }
  getStepUnitText(activeView = this.activeView) {
    // stepUnit is localized by views.
    // Views must normalize the returned property value for use in
    // "Next ${stepUnit}" button text, eg "1 day" to "day"
    return activeView.stepUnit;
  }
  syncUIWithActiveView(activeView = this.activeView) {
    const me = this,
      {
        tbar,
        sidebar,
        widgetMap
      } = me,
      {
        toggleSideBar
      } = widgetMap;
    // tbar may have been configured away
    if (tbar && activeView !== null && activeView !== void 0 && activeView.isVisible) {
      const {
          prevButton,
          nextButton,
          modeSelector
        } = widgetMap,
        stepUnitText = me.getStepUnitText(activeView);
      modeSelector === null || modeSelector === void 0 ? void 0 : modeSelector.syncActiveMode(activeView);
      if (sidebar) {
        sidebar.stepUnitText = stepUnitText;
      }
      me.updateViewDescription(activeView);
      // Each view localizes its own stepUnit
      // Also, any widget may be configured away, so must be truthy.
      if (prevButton) {
        prevButton.tooltip = stepUnitText ? me.L('L{previous}', stepUnitText) : '';
        prevButton.disabled = !stepUnitText;
      }
      if (nextButton) {
        nextButton.tooltip = stepUnitText ? me.L('L{next}', stepUnitText) : '';
        nextButton.disabled = !stepUnitText;
      }
    }
    if (!sidebar) {
      toggleSideBar === null || toggleSideBar === void 0 ? void 0 : toggleSideBar.hide();
    }
  }
  updateEventStore(eventStore) {
    this.detachListeners('eventStoreDateRange');
    // The loadOnDemand feature needs to be initialized as soon as we get our
    // event store so that it can hook *all* loadDateRange events.
    this.features.loadOnDemand;
    // Ensure the listeners are present
    this.processConfiguredListeners();
    eventStore.ion({
      loadDateRange: 'onEventStoreDateRangeRequested',
      name: 'eventStoreDateRange',
      thisObj: this
    });
    // This is all we have to do.
    // The ProjectConsumer mixin implements a changeEventStore which updates the Project
    // and our project which we configure into all our views will update any subscribers.
    if (this.sidebar) {
      this.sidebar.eventStore = eventStore;
    }
  }
  /**
   * Executes the passed function for each child calendar view in {@link #config-modes}
   * @param {Function} fn The function to call.
   * @param {Object[]} [args] The arguments to pass. Defaults to the view being called.
   * @param {Object} [thisObj] The `this` reference for the function. Defaults to the view being called.
   */
  eachView(fn, args, thisObj = null) {
    const passView = args == null;
    for (const view of this.views) {
      if (passView) {
        args = [view];
      }
      if (view.callback(fn, thisObj || view, args) === false) {
        return;
      }
    }
  }
  onEventStoreDateRangeRequested(event) {
    /**
     * Fired when the eventStore is queried for events by date range, and the date range
     * requested is different from the last time the store was queried.
     *
     * This may not be triggered when moving to a different view. If a `MonthView` has been
     * displayed, and the `WeekView` is then shown, the date range is already available.
     *
     * When moving a view through time, and into a time range which has not previously been
     * loaded, this will be triggered.
     * @event dateRangeChange
     * @param {Calendar.view.Calendar} source This Calendar instance.
     * @param {Object} old The old date range
     * @param {Date} old.startDate the old start date.
     * @param {Date} old.endDate the old end date.
     * @param {Object} new The new date range
     * @param {Date} new.startDate the new start date.
     * @param {Date} new.endDate the new end date.
     * @deprecated 6.0 Use {@link #event-dateRangeRequested} instead and interrogate its `changed` property.
     */
    if (event.changed) {
      this.trigger('dateRangeChange', event);
    }
    /**
     * Fired every time the eventStore is queried for events by date range.
     *
     * This will always be triggered when changing the active view or when navigating
     * the calendar backwards or forwards in time.
     * @event dateRangeRequested
     * @param {Calendar.view.Calendar} source This Calendar instance.
     * @param {Object} old The old date range
     * @param {Date} old.startDate the old start date.
     * @param {Date} old.endDate the old end date.
     * @param {Object} new The new date range
     * @param {Date} new.startDate the new start date.
     * @param {Date} new.endDate the new end date.
     * @param {Boolean} changed `true` if the date range is different from the last time a request was made.
     */
    this.trigger('dateRangeRequested', event);
  }
  async onModeSelectorToggle({
    source: button,
    pressed
  }) {
    if (pressed) {
      const me = this,
        {
          layout
        } = me.viewContainer,
        {
          view
        } = button;
      // First await any ongoing mode switching
      await me.modeSelectionPromise;
      me.modeSelectionPromise = layout.setActiveItem(view).promise;
    }
  }
  /**
   * Sets and gets which of the configured {@link #property-modes} is the current active view.
   *
   * When read, this yields the string name of the currently active mode.
   *
   * When setting, this accepts either the name, or the actual widget instance:
   *
   * ```javascript
   * calendar.mode = 'week';
   * ```
   *
   * or
   *
   * ```javascript
   * calendar.mode = calendar.modes.agenda;
   * ```
   * @member {String} mode
   */
  updateMode(mode) {
    const me = this,
      configs = me.initialConfig || {};
    // If the user configured activeIndex or mode, ignore the (one-time) responsiveUpdate of mode
    if (!(me.isConfiguring || me._responsiveUpdating && ('mode' in configs || 'activeIndex' in configs))) {
      mode = typeof mode === 'string' ? me.modes[mode] : mode;
      if (mode && mode !== me.activeView) {
        // Do not animate the mode if we are updating responsive state
        me.viewContainer.layout.setActiveItem(mode, undefined, {
          animation: !me.isResponsiveUpdating
        });
      }
    }
  }
  // Handle eventStore load or full datachange.
  // It will have refreshed all our views, so keep the Calendar UI synced.
  onEventStoreRefresh() {
    if (!this.isConfiguring) {
      this.syncUIWithActiveView(this.viewContainer.layout.activeItem);
    }
  }
  handleViewPaint({
    source: view
  }) {
    this.syncUIWithActiveView(view);
    // Keep the property in line with reality.
    this._mode = view.modeName;
    /**
     * Fires when one of the child views is painted. That is when it becomes visible.
     * Note that due to the slide-in animation, while the view is visible, it will not
     * yet be in its final position.
     * @event viewPaint
     * @param {Core.widget.Widget} source The widget being painted.
     * @param {Boolean} firstPaint `true` if this is the first paint.
     */
    this.trigger('viewPaint', _objectSpread2({}, arguments[0]));
  }
  onViewRefresh({
    source: view
  }) {
    var _super$onViewRefresh;
    (_super$onViewRefresh = super.onViewRefresh) === null || _super$onViewRefresh === void 0 ? void 0 : _super$onViewRefresh.call(this, ...arguments);
    if (view.isVisible) {
      // The activeView refreshed
      if (view === this.activeView) {
        this.updateViewDescription(view);
      }
      // A child view of the current active view refreshed.
      else if (this.activeView.owns(view)) {
        this.syncUIWithActiveView(this.activeView);
      }
    }
  }
  updateEventCls(eventCls) {
    if (!this.initialConfig.eventInnerSelector) {
      this.eventInnerSelector = `.${eventCls}`;
    }
    if (!this.initialConfig.eventSelector) {
      this.eventSelector = `${this.eventInnerSelector}-wrap`;
    }
  }
  changeModes(modes, was) {
    const me = this,
      {
        mode
      } = me;
    // This will bring in any configured CrudManager which will give us our stores.
    me.getConfig('crudManager');
    me.getConfig('defaultCalendar');
    // Set our activeModeIndex to the requested mode's index
    if (mode && mode in modes) {
      const modeArray = [];
      let activeIndex = null,
        index = 0,
        modeConfig;
      for (const modeType in modes) {
        modeConfig = modes[modeType];
        if (modeConfig) {
          var _modeConfig$weight;
          if (typeof modeConfig === 'object' && 'weight' in modeConfig) {
            activeIndex = null;
          } else if (modeConfig && modeType === mode) {
            activeIndex = index;
          }
          modeArray.push(ObjectHelper.assign({
            modeType,
            weight: (_modeConfig$weight = modeConfig.weight) !== null && _modeConfig$weight !== void 0 ? _modeConfig$weight : 0
          }, modeConfig));
          index++;
        } else {
          modeArray.push(false);
        }
      }
      // Weights found, so sort and rebuild of modes object in requested order needed
      if (activeIndex == null) {
        modes = {};
        modeArray.sort(byWeight);
        for (let i = 0, {
            length
          } = modeArray; i < length; i++) {
          modeConfig = modeArray[i];
          modes[modeConfig.modeType] = modeConfig;
          if (modeArray[i].modeType === mode) {
            activeIndex = i;
          }
        }
      }
      me.activeModeIndex = activeIndex;
    }
    const {
        tbar,
        element
      } = me,
      listeners = {
        thisObj: me,
        // When a mode has an internal change that requires the description shown in the tbar to be refreshed
        descriptionChange: 'onViewDescriptionChange',
        // These are for implementing drilling from higher to lower level views
        weekNumberClick: 'onViewWeekNumberClick',
        monthNameClick: 'onViewMonthNameClick',
        dayNumberClick: 'onViewDayNumberClick',
        // Handle a double click gesture inside a scheduler child mode
        beforeEventAdd: 'onViewBeforeEventAdd',
        // This is how the Calendar relays events from modes to the outside world
        // The Calendar listeners get first look at the events so that app code gets
        // a chance to intervene early.
        catchAll: {
          fn: 'onViewCatchAll',
          prio: 10000
        },
        paint: 'handleViewPaint',
        refresh: 'onViewRefresh'
      },
      manager = me.$modes || (me.$modes = new DynamicObject({
        factory: Modes,
        inferType: true,
        // the name of a mode is its default type (allow its config object to override it)
        owner: me,
        // All instances have this.calendar pointing to this
        ownerName: 'calendar',
        created(mode, name) {
          var _tbar$widgetMap;
          // Each one must know what mode it represents
          mode.modeName = name;
          // Attach our eventEdit feature to Schedulers
          if (mode.isScheduler) {
            const {
              eventEdit
            } = me.features;
            if (eventEdit) {
              eventEdit.applyPluginConfig(mode);
              mode.editEvent = me.editEvent.bind(me);
            }
          }
          // Propagate the overall autoCreate setting unless one view
          // explicitly overrode the default. (YearView does)
          if (mode.autoCreate !== false) {
            mode.autoCreate = me.autoCreate;
          }
          // Allows selection by what views are present
          element.classList.add(`b-cal-${name}`);
          // We need to sync our UI when the view changes.
          mode.ion(listeners);
          // Give app code a shot at affecting the propagate end date for DayCellCollecters
          me.relayEvents(mode, ['eventPropagate']);
          if (!me.isConfiguring) {
            me.trigger('addMode', {
              mode
            });
          }
          // Allow tbar to be configured away.
          // Note that tbar may be configured away using tbar : null, so tbar?.widgetMap.modeSelector
          // won't work since it will interrogate the widgetMap of null in that case,
          const modeSelector = tbar === null || tbar === void 0 ? void 0 : (_tbar$widgetMap = tbar.widgetMap) === null || _tbar$widgetMap === void 0 ? void 0 : _tbar$widgetMap.modeSelector;
          if (modeSelector) {
            modeSelector.calendar = me; // in case the up() traversal is needed too early
            modeSelector.addMode(name, mode);
          }
        },
        setup(config) {
          const {
              defaultCalendar,
              hideNonWorkingDays,
              modeDefaults
            } = me,
            viewType = Modes.resolveType(config.type);
          if (modeDefaults) {
            config = ObjectHelper.merge({}, modeDefaults, config);
          }
          // Inhibit Scheduler features which our features override.
          if (viewType.isScheduler) {
            const features = config.features || (config.features = {});
            features.eventTooltip = features.eventMenu = features.eventEdit = features.scheduleMenu = false;
          } else {
            config.eventSelector = me.eventSelector;
            config.eventInnerSelector = me.eventInnerSelector;
          }
          config.rtl = me.rtl;
          config.project = me.project;
          config.readOnly = me.readOnly;
          config.allowOverlap = me.allowOverlap;
          config.hidden = true;
          config.weekStartDay = me.weekStartDay;
          config.nonWorkingDays = me.nonWorkingDays;
          config.timeZone = me.timeZone;
          if (me.coreHours) {
            config.coreHours = me.coreHours;
          }
          if (me.resourceImagePath) {
            config.resourceImagePath = me.resourceImagePath;
          }
          if (ObjectHelper.hasOwn(me, '_defaultCalendar')) {
            config.defaultCalendar = me._defaultCalendar;
          } else if (defaultCalendar != null) {
            config.defaultCalendar = defaultCalendar;
          }
          if (hideNonWorkingDays != null) {
            config.hideNonWorkingDays = hideNonWorkingDays;
          }
          if (me.date && !config.date) {
            config.date = me.date;
          }
          if (!config.dateFormat) {
            config.dateFormat = me.dateFormat;
          }
          if (me.visibleStartTime) {
            config.visibleStartTime = me.visibleStartTime;
          }
          return config;
        }
      }));
    manager.update(modes);
    if (!was) {
      // Only return the target once. Further calls are processed above so we need to return undefined to ensure
      // onConfigChange is called. By returning the same target on 2nd+ call, it passes the === test and won't
      // trigger onConfigChange.
      return manager.target;
    }
  }
  changeModeDefaults(modeDefaults) {
    const me = this,
      result = new Proxy(ObjectHelper.assign({}, modeDefaults), {
        set(target, prop, value) {
          const result = Reflect.set(...arguments);
          // Pass new property setting in to child views
          me.updateModeDefaults({
            [prop]: value
          });
          return result;
        },
        deleteProperty(target, prop) {
          const result = Reflect.deleteProperty(...arguments);
          // Pass new property setting in to child views
          me.updateModeDefaults({
            [prop]: null
          });
          return result;
        }
      });
    return result;
  }
  updateModeDefaults(modeDefaults) {
    if (!this.isConfiguring) {
      this.eachView(v => v.setConfig(modeDefaults));
    }
  }
  get collapsibleConfig() {
    const overlaySidebar = this.peekConfig('overlaySidebar'),
      config = {
        type: overlaySidebar ? 'overlay' : 'inline',
        tool: null
      };
    if (overlaySidebar) {
      config.recollapseTool = null;
    }
    return config;
  }
  updateOverlaySidebar(overlaySidebar) {
    const {
        sidebar,
        collapsibleConfig
      } = this,
      collapsible = sidebar === null || sidebar === void 0 ? void 0 : sidebar.collapsible;
    if (collapsible) {
      if (collapsible.type !== collapsibleConfig.type) {
        sidebar.collapsible = collapsibleConfig;
      }
      if (overlaySidebar) {
        if (!sidebar.collapsed) {
          sidebar.collapsed = true;
          sidebar.collapsedDueToOverlay = true;
        }
      }
      // If moving back to inline sidebar, then if it was
      // collapsed only due to being made overlayed, or it's been overlayed into visibility at this time
      // then expand it again.
      else if (sidebar.collapsedDueToOverlay || sidebar.isVisible && collapsible.isPanelCollapserOverlay) {
        sidebar.collapsed = false;
        sidebar.collapsedDueToOverlay = false;
      }
    }
  }
  changeSidebar(config, sidebar) {
    const me = this,
      {
        datePicker,
        statefulId: stateId
      } = me;
    if (config) {
      const sidebarItems = config.items || (config.items = {}),
        sidebarDatePicker = sidebarItems.datePicker;
      // If the developer nulled out the datePicker in her sidebar config
      // we cannot impose our default datePicker.
      if (datePicker) {
        if (sidebarDatePicker !== null && sidebarDatePicker !== false) {
          sidebarItems.datePicker = Calendar.mergeConfigs(sidebarItems.datePicker, datePicker);
        }
      } else {
        sidebarItems.datePicker = null;
      }
    }
    return Sidebar.reconfigure(sidebar, config, {
      owner: me,
      setup: (cfg, type) => me.setupWidgetConfig(cfg, type),
      // These are combined with "config" prior to calling our setup() above (so they are part of the "cfg"
      // parameter passed to setup():
      defaults: {
        stateId: stateId && `${stateId}:sidebar`,
        eventStore: me.eventStore,
        date: me.date,
        weight: (config === null || config === void 0 ? void 0 : config.side) === 'right' ? 10 : -10,
        collapsible: me.collapsibleConfig,
        items: {
          datePicker: {
            weekStartDay: me.weekStartDay
          }
        }
      }
    });
  }
  changeDatePicker(config) {
    if (config) {
      return Object.assign(config, {
        eventStore: this.eventStore,
        date: this.date
      });
    }
  }
  /**
   * The {@link #config-datePicker} as an instance of {@link Calendar.widget.CalendarDatePicker}.
   * @member {Calendar.widget.CalendarDatePicker} datePicker
   * @readonly
   */
  get datePicker() {
    return this.isConfiguring ? this._datePicker : this.sidebar.widgetMap.datePicker;
  }
  changeItems(items) {
    const {
        modes,
        sidebar
      } = this,
      {
        viewContainer
      } = items;
    // Add our sidebar if it was not configured away.
    if (sidebar) {
      items.sidebar = sidebar;
    }
    // Add our modes.
    if (viewContainer) {
      viewContainer.items = modes;
    }
    // Set the viewContainer layout's activeIndex to the requested mode's index
    if (this.activeModeIndex) {
      viewContainer.layout.activeIndex = this.activeModeIndex;
    }
    const result = super.changeItems(items);
    /**
     * @member {Core.widget.Container} viewContainer
     * A {@link Core.widget.Container} which contains the configured {@link #config-modes} and
     * manages the currently active mode through its {@link Core.widget.Container#property-layout}.
     * @readonly
     */
    this.viewContainer = this.widgetMap.viewContainer;
    return result;
  }
  onViewCatchAll(event) {
    const me = this,
      {
        fromOverflowPopup,
        type,
        source: view
      } = event;
    // Reject events which have bubbled up from other things than our views (MenuItem events bubble).
    // We are only forwarding events from our owned Calendar widgets.
    if (event.bubbles) {
      return;
    }
    let result,
      date,
      {
        domEvent
      } = event;
    // If the event was from another type of view, such as a Scheduler, they pass
    // DOM events as "event", so use that.
    if (!domEvent && DomHelper.isDOMEvent(event.event)) {
      domEvent = event.event;
    }
    /**
     * When a child calendar view is being interacted with, this property
     * yields a reference to the child being interacted with.
     * @member {Calendar.widget.mixin.CalendarMixin} eventSource
     * @typings {typeof CalendarMixin}
     * @readonly
     */
    me.eventSource = view;
    // Implement the interface which the inherited Feature structure requires.
    // Features hook into client element event handling methods
    if (!domEvent || me.handleEvent(domEvent) !== false) {
      var _view$getDateFromDomE;
      const isEmptyCell = type.startsWith('emptycell');
      // Only change date when click originates from a calendar view (not an embedded scheduler for example)
      if (type.endsWith('click') && me.activeView.isCalendarMixin && (date = event.date || ((_view$getDateFromDomE = view.getDateFromDomEvent) === null || _view$getDateFromDomE === void 0 ? void 0 : _view$getDateFromDomE.call(view, domEvent)))) {
        const isOverflowClick = fromOverflowPopup || type === 'celloverflowclick' || domEvent.target.closest('.b-cal-cell-overflow'),
          isOtherMonth = view.getDayElement && !view.getDayElement(date, true),
          // Only move onto the clicked date if it's explicitly a dayNumber Click.
          // Any other kind of click must not change date. Mats, 07/07/2022
          changeDate = !(fromOverflowPopup && isOtherMonth) && !isEmptyCell && (type === 'daynumberclick' || !(isOtherMonth && (isOverflowClick || type.startsWith('event') || type.startsWith('schedule'))));
        // Set our date to the event date if we contain it.
        // If the above fell back to startDate, and it starts before the
        // view start, this must not happen.
        // Note that custom model may not implement getDayElement.
        if (changeDate) {
          me.date = date;
        }
      }
      if (isEmptyCell || relayedEvents.test(type)) {
        result = me.trigger(type.replaceAll(capitalizeRegExp, capitalizeWord), _objectSpread2(_objectSpread2({}, event), {}, {
          view
        }));
      }
    }
    me.eventSource = null;
    return result;
  }
  // A mode had an internal change that requires updating the description shown in the tbar
  onViewDescriptionChange() {
    this.updateViewDescription();
  }
  // Implement drilling down from a MonthView week number click to a WeekView
  // or a child view which encapsulates WeekViews via its view.type config.
  onViewWeekNumberClick({
    week
  }) {
    const weekView = this.modes.week || this.viewContainer.query(v => {
      var _v$view;
      return ((_v$view = v.view) === null || _v$view === void 0 ? void 0 : _v$view.type.toLowerCase()) === 'weekview';
    });
    if (weekView) {
      weekView.week = week;
      this.viewContainer.layout.activeItem = weekView;
    }
  }
  // Implement drilling down from a YearView month name click to the MonthView
  // or a child view which encapsulates MonthViews via its view.type config.
  onViewMonthNameClick({
    date
  }) {
    const monthView = this.modes.month || this.viewContainer.query(v => {
      var _v$view2;
      return ((_v$view2 = v.view) === null || _v$view2 === void 0 ? void 0 : _v$view2.type.toLowerCase()) === 'monthview';
    });
    if (monthView) {
      monthView.date = date;
      this.viewContainer.layout.activeItem = monthView;
    }
  }
  // Implement drilling down from a DayView's header day number click to the DayView
  // or a child view which encapsulates DayViews via its view.type config.
  onViewDayNumberClick({
    source,
    date,
    cellData,
    fromOverflowPopup,
    domEvent
  }) {
    var _cellData$events;
    // For a year view, we are clear to go ahead and navigate to the day on click if the overflow popup
    // trigger is not click, or if there are no events for the date and there's no empty cell renderer
    // which would show some UI about there being no events. Or if the click was on an overflow popup header.
    const validYearViewNavigate = source.isYearView && (source.overflowPopupTrigger !== 'click' || fromOverflowPopup || !((_cellData$events = cellData.events) !== null && _cellData$events !== void 0 && _cellData$events.length) && !source.emptyCellRenderer);
    if (source.isCalendarRow || source.isMonthView || validYearViewNavigate || source.isAgendaView) {
      const {
          viewContainer
        } = this,
        dayView = this.modes.day || viewContainer.query(v => {
          var _v$view3;
          return ((_v$view3 = v.view) === null || _v$view3 === void 0 ? void 0 : _v$view3.type.toLowerCase()) === 'dayview';
        });
      if (dayView && source !== dayView.allDayEvents) {
        const {
            layout
          } = viewContainer,
          {
            activeItem: oldActiveItem
          } = layout,
          {
            syncViewDate
          } = oldActiveItem;
        // Don't sync the outgoing item with our date.
        // It will be synced on its way back in next time.
        oldActiveItem.syncViewDate = false;
        // Must update our date before we attempt the card change because
        // *before* changing card, the incoming card gets its date set.
        // See onBeforeModeChange. New card must be synced with us from the start.
        this.date = date;
        viewContainer.layout.activeItem = dayView;
        // Restore the outgoing item so that when it comes back in
        // onBeforeModeChange will sync it.
        oldActiveItem.syncViewDate = syncViewDate;
        return false;
      }
    }
  }
  onViewBeforeEventAdd({
    eventRecord,
    assignmentRecords
  }) {
    const {
        eventEdit
      } = this.features,
      isCreating = eventEdit && !eventEdit.disabled;
    // If double clicking in a Scheduler child view, it has its eventEdit feature off, so help it know that
    // the created records are being edited
    eventRecord.isCreating = isCreating;
    assignmentRecords === null || assignmentRecords === void 0 ? void 0 : assignmentRecords.forEach(assignmentRecord => assignmentRecord.isCreating = isCreating);
  }
  /**
   * Uses the current active mode to create an event on the specified date which conforms to that mode's
   * {@link Calendar.widget.mixin.CalendarMixin#config-autoCreate} setting.
   *
   * This method may be called programmatically by application code if the `autoCreate` setting
   * is `false`, in which case the default values for `autoCreate` will be used.
   *
   * If the {@link Calendar.feature.EventEdit EventEdit} feature is active, the new event
   * will be displayed in the event editor.
   *
   * This is a utility method to use as a shortcut to {@link Calendar.widget.mixin.CalendarMixin#function-createEvent}
   * @param {Date} [date] Optionally, the date to add the event at. Uses the Calendar's currently
   * active date, as set in the {@link #config-sidebar}'s date picker.
   *
   * If there's no time component, and the current active mode is a calendar view, the
   * {@link Calendar.widget.mixin.CalendarMixin#config-autoCreate}'s `startHour` will be used.
   */
  createEvent(date = this.date) {
    this.doCreateEvent(date);
  }
  // This is separate because its signature is fixed. Second parameter is an optional view to use
  // to do the creating. The createEvent method may be called by Features which pass extra parameters.
  doCreateEvent(date, source = this.activeView) {
    const {
        modes
      } = this,
      // Yearview defers to other views present in its owning calendar to handle auto creating
      // events. This method finds a suitable host view to postprocess the creation.
      editingView = source.isYearView ? modes.week || modes.month || modes.day || source : source;
    // Ensure the view which is going to postprocess the new event (such as editing it) is active
    if (!this.activeView.owns(editingView)) {
      const {
          viewContainer
        } = this.widgetMap,
        {
          layout
        } = viewContainer;
      if (editingView) {
        // activeItemChange fires after the animation, so it will be fully ready.
        viewContainer.ion({
          activeItemChange: 'doCreateEvent',
          thisObj: source,
          once: true,
          args: [date, editingView]
        });
        editingView.date = date;
        layout.activeItem = editingView;
        return false;
      }
    } else {
      source.doCreateEvent(date);
    }
  }
  changeDate(date, oldDate) {
    date = typeof date === 'string' ? DateHelper.parse(date) : new Date(date);
    if (isNaN(date)) {
      throw new Error('Calendar widget date ingestion must be passed a Date, or a YYYY-MM-DD date string');
    }
    date = DateHelper.clearTime(date);
    // Protect the setter from processing a no-change.
    if (!oldDate || date - oldDate) {
      return date;
    }
  }
  updateAutoCreate() {
    if (!this.isConfiguring) {
      this.syncCommonConfig('autoCreate');
    }
  }
  updateDate(date, oldDate) {
    if (!this.isConfiguring) {
      const {
        sidebar
      } = this;
      if (sidebar) {
        // The sidebar's datechange event is listened by onCalendarDateChange
        sidebar.date = date;
      } else {
        this.onCalendarDateChange({
          date
        });
      }
    }
  }
  updateDateFormat() {
    if (!this.isConfiguring) {
      this.syncCommonConfig('dateFormat');
    }
  }
  changeIncludeWeekendsButton(value) {
    return value === true ? {} : value;
  }
  updateIncludeWeekendsButton(value) {
    // we don't pass null/false down because we only want to configure the button not destroy it
    if (!this.isConstructing && value && ObjectHelper.isObject(value)) {
      this.widgetMap.modeSelector.includeWeekendsButton = value;
    }
  }
  changeScrollManager(scrollManager, oldScrollManager) {
    oldScrollManager === null || oldScrollManager === void 0 ? void 0 : oldScrollManager.destroy();
    if (this.isDestroying) {
      return;
    }
    return new ScrollManager(Object.assign({
      element: this.element
    }, scrollManager));
  }
  updateDefaultCalendar() {
    if (!this.isConfiguring) {
      this.syncCommonConfig('defaultCalendar');
    }
  }
  changeWeekStartDay(weekStartDay) {
    // Apply the default from DateHelper which draws its value from the locale.
    if (weekStartDay === false) {
      weekStartDay = DateHelper.weekStartDay;
    }
    return weekStartDay;
  }
  updateReadOnly() {
    super.updateReadOnly(...arguments);
    if (!this.isConfiguring) {
      this.syncCommonConfig('readOnly');
    }
  }
  updateWeekStartDay(weekStartDay) {
    if (!this.isConfiguring) {
      var _this$sidebar;
      this.syncCommonConfig('weekStartDay');
      if ((_this$sidebar = this.sidebar) !== null && _this$sidebar !== void 0 && _this$sidebar.widgetMap.datePicker) {
        this.sidebar.widgetMap.datePicker.weekStartDay = weekStartDay;
      }
    }
  }
  updateHideNonWorkingDays(hideNonWorkingDays, was) {
    if (!this.isConfiguring) {
      this.syncCommonConfig('hideNonWorkingDays');
      this.trigger('changeHideNonWorkingDays', {
        value: hideNonWorkingDays,
        was
      });
    }
  }
  changeNonWorkingDays(nonWorkingDays) {
    // Apply the default from DateHelper which draws its value from the locale.
    if (nonWorkingDays === false) {
      nonWorkingDays = ObjectHelper.assign({}, DateHelper.nonWorkingDays);
    }
    return nonWorkingDays;
  }
  updateNonWorkingDays() {
    if (!this.isConfiguring) {
      this.syncCommonConfig('nonWorkingDays');
    }
  }
  updateCoreHours() {
    if (!this.isConfiguring) {
      this.syncCommonConfig('coreHours');
    }
  }
  /**
   * Syncs configs which are passed down into child views when changed here.
   * @param {String} name The name of teh config to pass from this Calendar into every child view
   * @private
   */
  syncCommonConfig(name) {
    this.eachView(v => {
      v[name] = this[name];
    });
  }
  onCalendarStoreChange() {
    var _super$onCalendarStor;
    // Keep mixins informed.
    (_super$onCalendarStor = super.onCalendarStoreChange) === null || _super$onCalendarStor === void 0 ? void 0 : _super$onCalendarStor.call(this, ...arguments);
  }
  updateSelected() {
    const eventEls = this.viewContainer.contentElement.querySelectorAll('.b-cal-event-wrap');
    for (let i = 0, {
        length
      } = eventEls; i < length; i++) {
      eventEls[i].classList[this.isEventSelected(eventEls[i].dataset.eventId) ? 'add' : 'remove']('b-selected');
    }
  }
  getElementFromEventRecord(record) {
    return this.activeView.getEventElement(record);
  }
  updateLocalization() {
    const me = this;
    if (me.isPainted) {
      let refreshed = false;
      // Only go with locale's weekStartDay if we were not initially configured with a weekStartDay
      if (!('weekStartDay' in me.initialConfig) && me.weekStartDay !== DateHelper.weekStartDay) {
        me.weekStartDay = DateHelper.weekStartDay;
        // weekStartDay change will cause a refresh
        refreshed = true;
      }
      // Only go with locale's nonWorkingDays if we were not initially configured with nonWorkingDays
      if (!('nonWorkingDays' in me.initialConfig) && !ObjectHelper.isEqual(me.nonWorkingDays, DateHelper.nonWorkingDays)) {
        me.nonWorkingDays = DateHelper.nonWorkingDays;
        // nonWorkingDays change will cause a refresh
        refreshed = true;
      }
      if (!refreshed) {
        me.refresh();
      }
      me.syncUIWithActiveView();
    }
    super.updateLocalization();
  }
}
Calendar.initClass();
// Views which we import may need to access Calendar at runtime. They do it through the bryntum global.
if (globalThis.bryntum) {
  globalThis.bryntum.Calendar = Calendar;
}
class Modes extends Base.mixin(Factoryable) {
  static get factoryable() {
    return {
      // Allow any widget type:
      extends: Widget
    };
  }
}
Modes.register('agenda', AgendaView);
Modes.register('year', YearView);
Modes.register('month', MonthView);
Modes.register('week', WeekView);
Modes.register('day', DayView);
Modes.register('list', EventList);
Modes.register('resource', ResourceView);
Calendar.Modes = Modes;
VersionHelper.setVersion('calendar', '5.3.0');
Calendar._$name = 'Calendar';

export { AgendaColumn, AgendaView, Calendar, CalendarDatePicker, CalendarDrag, CalendarFeature, CalendarMixin, CalendarRow, CalendarStores, CrudManager, DateRangeOwner, DayCellCollecter, DayCellRenderer, DayLayout, DaySelectable, DaySelector, DayView, EventColumn, EventEdit, EventEditor, EventList, EventMenu, EventNavigation, EventRenderer, EventSelection, EventSlots, EventSorter, EventTip, EventTooltip, ExternalEventSource, FluidDayLayout, LayoutDim, LoadOnDemand, ModeSelector, MonthView, OverflowPopup, Print, ProjectModel, ResourceView, ScheduleMenu, Sidebar, TimeRangeModel, TimeRangeStore, TimeRanges, WeekExpander, WeekView, YearView };
//# sourceMappingURL=calendar.module.thin.js.map
