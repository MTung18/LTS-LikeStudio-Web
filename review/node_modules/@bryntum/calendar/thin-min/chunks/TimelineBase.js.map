{"version":3,"file":"TimelineBase.js","sources":["../../../../chronograph/src/class/Base.js","../../../../Engine/lib/Engine/calendar/CalendarCacheIntervalMultiple.js","../../../../Engine/lib/Engine/calendar/CalendarCacheMultiple.js","../../../../Scheduler/lib/Scheduler/column/DurationColumn.js","../../../../Scheduler/lib/Scheduler/view/TimeAxisBase.js","../../../../Scheduler/lib/Scheduler/view/HorizontalTimeAxis.js","../../../../Scheduler/lib/Scheduler/view/ResourceHeader.js","../../../../Scheduler/lib/Scheduler/column/TimeAxisColumn.js","../../../../Scheduler/lib/Scheduler/preset/ViewPreset.js","../../../../Scheduler/lib/Scheduler/preset/PresetStore.js","../../../../Scheduler/lib/Scheduler/preset/PresetManager.js","../../../../Scheduler/lib/Scheduler/data/TimeAxis.js","../../../../Scheduler/lib/Scheduler/feature/base/DragBase.js","../../../../Scheduler/lib/Scheduler/feature/EventResize.js","../../../../Scheduler/lib/Scheduler/feature/base/DragCreateBase.js","../../../../Scheduler/lib/Scheduler/feature/base/TooltipBase.js","../../../../Scheduler/lib/Scheduler/feature/AbstractTimeRanges.js","../../../../Scheduler/lib/Scheduler/feature/ColumnLines.js","../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyCreation.js","../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyGridCache.js","../../../../Scheduler/lib/Scheduler/util/RectangularPathFinder.js","../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyLineGenerator.js","../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyTooltip.js","../../../../Scheduler/lib/Scheduler/feature/Dependencies.js","../../../../Scheduler/lib/Scheduler/feature/EventFilter.js","../../../../Scheduler/lib/Scheduler/feature/mixin/NonWorkingTimeMixin.js","../../../../Scheduler/lib/Scheduler/feature/NonWorkingTime.js","../../../../Scheduler/lib/Scheduler/feature/ScheduleTooltip.js","../../../../Scheduler/lib/Scheduler/feature/TimeAxisHeaderMenu.js","../../../../Scheduler/lib/Scheduler/view/model/TimeAxisViewModel.js","../../../../Scheduler/lib/Scheduler/view/mixin/TimelineDateMapper.js","../../../../Scheduler/lib/Scheduler/view/mixin/TimelineDomEvents.js","../../../../Scheduler/lib/Scheduler/view/mixin/TimelineViewPresets.js","../../../../Scheduler/lib/Scheduler/view/mixin/TimelineZoomable.js","../../../../Scheduler/lib/Scheduler/view/mixin/TimelineEventRendering.js","../../../../Scheduler/lib/Scheduler/view/mixin/TimelineScroll.js","../../../../Scheduler/lib/Scheduler/view/mixin/TimelineState.js","../../../../Scheduler/lib/Scheduler/view/Header.js","../../../../Scheduler/lib/Scheduler/view/TimeAxisSubGrid.js","../../../../Scheduler/lib/Scheduler/view/TimelineBase.js"],"sourcesContent":["//---------------------------------------------------------------------------------------------------------------------\n/**\n * This is a base class, providing the type-safe static constructor [[new]]. This is very convenient when using\n * [[Mixin|mixins]], as mixins can not have types in the constructors.\n */\nexport class Base {\n    /**\n     * This method applies its 1st argument (if any) to the current instance using `Object.assign()`.\n     *\n     * Supposed to be overridden in the subclasses to customize the instance creation process.\n     *\n     * @param props\n     */\n    initialize(props) {\n        props && Object.assign(this, props);\n    }\n    /**\n     * This is a type-safe static constructor method, accepting a single argument, with the object, corresponding to the\n     * class properties. It will generate a compilation error, if unknown property is provided.\n     *\n     * For example:\n     *\n     * ```ts\n     * class MyClass extends Base {\n     *     prop     : string\n     * }\n     *\n     * const instance : MyClass = MyClass.new({ prop : 'prop', wrong : 11 })\n     * ```\n     *\n     * will produce:\n     *\n     * ```plaintext\n     * TS2345: Argument of type '{ prop: string; wrong: number; }' is not assignable to parameter of type 'Partial<MyClass>'.\n     * Object literal may only specify known properties, and 'wrong' does not exist in type 'Partial<MyClass>'\n     * ```\n     *\n     * The only thing this constructor does is create an instance and call the [[initialize]] method on it, forwarding\n     * the first argument. The customization of instance is supposed to be performed in that method.\n     *\n     * @param props\n     */\n    static new(props) {\n        const instance = new this();\n        instance.initialize(props);\n        return instance;\n    }\n}\n","import { stripDuplicates } from \"../util/StripDuplicates.js\";\nexport class CalendarCacheIntervalMultiple {\n    constructor(config) {\n        this.intervalGroups = [];\n        config && Object.assign(this, config);\n    }\n    combineWith(interval) {\n        const copy = this.intervalGroups.slice();\n        copy.push([interval.calendar, interval]);\n        return new CalendarCacheIntervalMultiple({ intervalGroups: copy });\n    }\n    getIsWorkingForEvery() {\n        if (this.isWorkingForEvery != null)\n            return this.isWorkingForEvery;\n        for (let [_calendar, intervals] of this.getGroups()) {\n            if (!intervals[0].isWorking)\n                return this.isWorkingForEvery = false;\n        }\n        return this.isWorkingForEvery = true;\n    }\n    getIsWorkingForSome() {\n        if (this.isWorkingForSome != null)\n            return this.isWorkingForSome;\n        for (let [_calendar, intervals] of this.getGroups()) {\n            if (intervals[0].isWorking)\n                return this.isWorkingForSome = true;\n        }\n        return this.isWorkingForSome = false;\n    }\n    getCalendars() {\n        this.getGroups();\n        return this.calendars;\n    }\n    isCalendarWorking(calendar) {\n        return this.getCalendarsWorkStatus().get(calendar);\n    }\n    getCalendarsWorkStatus() {\n        if (this.calendarsWorkStatus)\n            return this.calendarsWorkStatus;\n        const res = new Map();\n        for (let [calendar, intervals] of this.getGroups()) {\n            // TODO: fix types\n            res.set(calendar, intervals[0].isWorking);\n        }\n        return this.calendarsWorkStatus = res;\n    }\n    getCalendarsWorking() {\n        if (this.calendarsWorking)\n            return this.calendarsWorking;\n        const calendars = [];\n        for (let [calendar, intervals] of this.getGroups()) {\n            // TODO: fix types\n            if (intervals[0].isWorking)\n                calendars.push(calendar);\n        }\n        return this.calendarsWorking = calendars;\n    }\n    getCalendarsNonWorking() {\n        if (this.calendarsNonWorking)\n            return this.calendarsNonWorking;\n        const calendars = [];\n        for (let [calendar, intervals] of this.getGroups()) {\n            // TODO: fix types\n            if (!intervals[0].isWorking)\n                calendars.push(calendar);\n        }\n        return this.calendarsNonWorking = calendars;\n    }\n    getGroups() {\n        if (this.intervalsByCalendar)\n            return this.intervalsByCalendar;\n        const calendars = this.calendars = [];\n        const intervalsByCalendar = new Map();\n        this.intervalGroups.forEach(([calendar, interval]) => {\n            let data = intervalsByCalendar.get(calendar);\n            if (!data) {\n                calendars.push(calendar);\n                data = [];\n                intervalsByCalendar.set(calendar, data);\n            }\n            data.push.apply(data, interval.intervals);\n        });\n        intervalsByCalendar.forEach((intervals, calendar) => {\n            const unique = stripDuplicates(intervals);\n            unique.sort(\n            // sort in decreasing order\n            (interval1, interval2) => interval2.getPriorityField() - interval1.getPriorityField());\n            intervalsByCalendar.set(calendar, unique);\n        });\n        return this.intervalsByCalendar = intervalsByCalendar;\n    }\n}\n","import { stripDuplicates } from \"../util/StripDuplicates.js\";\nimport { CalendarCache } from \"./CalendarCache.js\";\nimport { CalendarCacheIntervalMultiple } from \"./CalendarCacheIntervalMultiple.js\";\nimport { IntervalCache } from \"./IntervalCache.js\";\n/**\n * The calendar cache for combination of multiple calendars\n */\nexport class CalendarCacheMultiple extends CalendarCache {\n    constructor(config) {\n        super(config);\n        this.calendarCaches = stripDuplicates(this.calendarCaches);\n        this.intervalCache = new IntervalCache({\n            emptyInterval: new CalendarCacheIntervalMultiple(),\n            combineIntervalsFn: (interval1, interval2) => {\n                return interval1.combineWith(interval2);\n            }\n        });\n    }\n    fillCache(startDate, endDate) {\n        this.calendarCaches.forEach(calendarCache => {\n            calendarCache.fillCache(startDate, endDate);\n            this.includeWrappingRangeFrom(calendarCache, startDate, endDate);\n        });\n    }\n}\nconst COMBINED_CALENDARS_CACHE = new Map();\nexport const combineCalendars = (calendars) => {\n    const uniqueOnly = stripDuplicates(calendars);\n    if (uniqueOnly.length === 0)\n        throw new Error(\"No calendars to combine\");\n    uniqueOnly.sort((calendar1, calendar2) => {\n        if (calendar1.internalId < calendar2.internalId)\n            return -1;\n        else\n            return 1;\n    });\n    const hash = uniqueOnly.map(calendar => calendar.internalId + '/').join('');\n    const versionsHash = uniqueOnly.map(calendar => calendar.version + '/').join('');\n    let cached = COMBINED_CALENDARS_CACHE.get(hash);\n    let res;\n    if (cached && cached.versionsHash === versionsHash)\n        res = cached.cache;\n    else {\n        res = new CalendarCacheMultiple({ calendarCaches: uniqueOnly.map(calendar => calendar.calendarCache) });\n        // COMBINED_CALENDARS_CACHE.set(hash, {\n        //     versionsHash    : versionsHash,\n        //     cache           : res\n        // })\n    }\n    return res;\n};\n","import ColumnStore from '../../Grid/data/ColumnStore.js';\nimport NumberColumn from '../../Grid/column/NumberColumn.js';\nimport Duration from '../../Core/data/Duration.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport '../../Core/widget/DurationField.js';\n\n/**\n * @module Scheduler/column/DurationColumn\n */\n\n/**\n * A column showing the task {@link Scheduler/model/TimeSpan#property-fullDuration duration}. Please note, this column\n * is preconfigured and expects its field to be of the {@link Core.data.Duration} type.\n *\n * The default editor is a {@link Core.widget.DurationField DurationField}. It parses time units, so you can enter \"4d\"\n * indicating 4 days duration, or \"4h\" indicating 4 hours, etc. The numeric magnitude can be either an integer or a\n * float value. Both \",\" and \".\" are valid decimal separators. For example, you can enter \"4.5d\" indicating 4.5 days\n * duration, or \"4,5h\" indicating 4.5 hours.\n *\n * {@inlineexample Scheduler/column/DurationColumn.js}\n * @extends Grid/column/NumberColumn\n * @classType duration\n * @column\n */\nexport default class DurationColumn extends NumberColumn {\n    compositeField = true;\n\n    //region Config\n\n    static get $name() {\n        return 'DurationColumn';\n    }\n\n    static get type() {\n        return 'duration';\n    }\n\n    static get isGanttColumn() {\n        return true;\n    }\n\n    static get fields() {\n        return [\n            /**\n             * Precision of displayed duration, defaults to use {@link Scheduler.view.Scheduler#config-durationDisplayPrecision}.\n             * Specify an integer value to override that setting, or `false` to use raw value\n             * @config {Number|Boolean} decimalPrecision\n             */\n            { name : 'decimalPrecision', defaultValue : 1 }\n        ];\n    }\n\n    static get defaults() {\n        return {\n            /**\n             * Min value\n             * @config {Number}\n             */\n            min : null,\n\n            /**\n             * Max value\n             * @config {Number}\n             */\n            max : null,\n\n            /**\n             * Step size for spin button clicks.\n             * @member {Number} step\n             */\n            /**\n             * Step size for spin button clicks. Also used when pressing up/down keys in the field.\n             * @config {Number}\n             * @default\n             */\n            step : 1,\n\n            /**\n             * Large step size, defaults to 10 * `step`. Applied when pressing SHIFT and stepping either by click or\n             * using keyboard.\n             * @config {Number}\n             * @default 10\n             */\n            largeStep : 0,\n\n            field         : 'fullDuration',\n            text          : 'L{Duration}',\n            instantUpdate : true,\n            // Undocumented, used by Filter feature to get type of the filter field\n            filterType    : 'duration',\n\n            sortable(durationEntity1, durationEntity2) {\n                const\n                    ms1 = durationEntity1[this.field],\n                    ms2 = durationEntity2[this.field];\n\n                return ms1 - ms2;\n            }\n        };\n    }\n\n    construct() {\n        super.construct(...arguments);\n\n        const sortFn = this.sortable;\n\n        this.sortable = (...args) => sortFn.call(this, ...args);\n    }\n\n    get defaultEditor() {\n        const { max, min, step, largeStep } = this;\n\n        // Remove any undefined configs, to allow config system to use default values instead\n        return ObjectHelper.cleanupProperties({\n            type : 'duration',\n            name : this.field,\n            max,\n            min,\n            step,\n            largeStep\n        });\n    }\n\n    //endregion\n\n    //region Internal\n\n    get durationUnitField() {\n        return `${this.field}Unit`;\n    }\n\n    formatValue(duration, durationUnit) {\n        if (duration instanceof Duration) {\n            durationUnit = duration.unit;\n            duration = duration.magnitude;\n        }\n\n        const\n            nbrDecimals = typeof this.grid.durationDisplayPrecision === 'number' ? this.grid.durationDisplayPrecision : this.decimalPrecision,\n            multiplier  = Math.pow(10, nbrDecimals),\n            rounded     = Math.round(duration * multiplier) / multiplier;\n\n        return rounded + ' ' + DateHelper.getLocalizedNameOfUnit(durationUnit, duration !== 1);\n    }\n\n    //endregion\n\n    //region Render\n\n    defaultRenderer({ record, isExport }) {\n        const\n            value         = record[this.field],\n            type          = typeof value,\n            durationValue = type === 'number' ? value : value?.magnitude,\n            durationUnit  = type === 'number' ? record[this.durationUnitField] : value?.unit;\n\n        // in case of bad input (for instance NaN, undefined or NULL value)\n        if (typeof durationValue !== 'number') {\n            return isExport ? '' : null;\n        }\n\n        return this.formatValue(durationValue, durationUnit);\n    }\n\n    //endregion\n\n    // Used with CellCopyPaste as fullDuration doesn't work via record.get\n    toClipboardString({ record }) {\n        return record[this.field].toString();\n    }\n\n    fromClipboardString({ string, record }) {\n        const duration = DateHelper.parseDuration(string, true, this.durationUnit);\n\n        if (duration && 'magnitude' in duration) {\n            return duration;\n        }\n\n        return record.fullDuration;\n    }\n\n    calculateFillValue({ value, record }) {\n        return this.fromClipboardString({ string : value, record });\n    }\n\n}\n\nColumnStore.registerColumnType(DurationColumn);\n","import Widget from '../../Core/widget/Widget.js';\nimport DomSync from '../../Core/helper/DomSync.js';\n\n/**\n * @module Scheduler/view/TimeAxisBase\n */\n\nfunction isLastLevel(level, levels) {\n    return level === levels.length - 1;\n}\n\nfunction isLastCell(level, cell) {\n    return cell === level.cells[level.cells.length - 1];\n}\n\n/**\n * Base class for HorizontalTimeAxis and VerticalTimeAxis. Contains shared functionality to only render ticks in view,\n * should not be used directly.\n *\n * @extends Core/widget/Widget\n * @private\n * @abstract\n */\nexport default class TimeAxisBase extends Widget {\n\n    static get $name() {\n        return 'TimeAxisBase';\n    }\n\n    //region Config\n\n    static get configurable() {\n        return {\n            /**\n             * The minimum width for a bottom row header cell to be considered 'compact', which adds a special CSS class\n             * to the row (for special styling). Copied from Scheduler/Gantt.\n             * @config {Number}\n             * @default\n             */\n            compactCellWidthThreshold : 15,\n\n            // TimeAxisViewModel\n            model : null,\n\n            cls : null,\n\n            /**\n             * Style property to use as cell size. Either width or height depending on orientation\n             * @config {'width'|'height'}\n             * @private\n             */\n            sizeProperty : null,\n\n            /**\n             * Style property to use as cells position. Either left or top depending on orientation\n             * @config {'left'|'top'}\n             * @private\n             */\n            positionProperty : null\n        };\n    }\n\n    static get properties() {\n        return {\n            startDate : null,\n            endDate   : null,\n            levels    : [],\n            size      : null\n        };\n    }\n\n    // Set visible date range\n    set range({ startDate, endDate }) {\n        const me = this;\n\n        // Only process a change\n        if (me.startDate - startDate || me.endDate - endDate) {\n            me.startDate = startDate;\n            me.endDate = endDate;\n            me.refresh();\n        }\n    }\n\n    //endregion\n\n    //region Html & rendering\n\n    // Generates element configs for all levels defined by the current ViewPreset\n    buildCells(start = this.startDate, end = this.endDate) {\n        const\n            me                   = this,\n            { sizeProperty }     = me,\n            {\n                stickyHeaders,\n                isVertical\n            }                    = me.client || {},\n            featureHeaderConfigs = [],\n            { length }           = me.levels;\n\n        const cellConfigs = me.levels.map((level, i) => {\n            const stickyHeader = stickyHeaders && (isVertical || i < length - 1);\n\n            return {\n                className : {\n                    'b-sch-header-row'                     : 1,\n                    [`b-sch-header-row-${level.position}`] : 1,\n                    'b-sch-header-row-main'                : i === me.model.viewPreset.mainHeaderLevel,\n                    'b-lowest'                             : isLastLevel(i, me.levels),\n                    'b-sticky-header'                      : stickyHeader\n                },\n                syncOptions : {\n                    // Keep a maximum of 5 released cells. Might be fine with fewer since ticks are fixed width.\n                    // Prevents an unnecessary amount of cells from sticking around when switching from narrow to\n                    // wide tickSizes\n                    releaseThreshold : 5,\n                    syncIdField      : 'tickIndex'\n                },\n                dataset : {\n                    headerFeature  : `headerRow${i}`,\n                    headerPosition : level.position\n                },\n                // Only include cells in view\n                children : level.cells?.filter(cell => cell.start < end && cell.end > start).map(cell => ({\n                    role      : 'presentation',\n                    className : {\n                        'b-sch-header-timeaxis-cell' : 1,\n                        [cell.headerCellCls]         : cell.headerCellCls,\n                        [`b-align-${cell.align}`]    : cell.align,\n                        'b-last'                     : isLastCell(level, cell)\n                    },\n                    dataset : {\n                        tickIndex : cell.index,\n                        // Used in export tests to resolve dates from tick elements\n                        ...globalThis.DEBUG && { date : cell.start.getTime() }\n                    },\n                    style : {\n                        // DomHelper appends px to numeric dimensions\n                        [me.positionProperty]   : cell.coord,\n                        [sizeProperty]          : cell.width,\n                        [`min-${sizeProperty}`] : cell.width\n                    },\n                    children : [\n                        {\n                            tag       : 'span',\n                            role      : 'presentation',\n                            className : {\n                                'b-sch-header-text' : 1,\n                                'b-sticky-header'   : stickyHeader\n                            },\n                            html : cell.value\n                        }\n                    ]\n                }))\n            };\n        });\n\n        // When tested in isolation there is no client\n        me.client?.getHeaderDomConfigs(featureHeaderConfigs);\n\n        cellConfigs.push(...featureHeaderConfigs);\n\n        // noinspection JSSuspiciousNameCombination\n        return {\n            className   : me.widgetClassList,\n            syncOptions : {\n                // Do not keep entire levels no longer used, for example after switching view preset\n                releaseThreshold : 0\n            },\n            children : cellConfigs\n        };\n    }\n\n    render(targetElement) {\n        super.render(targetElement);\n\n        this.refresh(true);\n    }\n\n    /**\n     * Refresh the UI\n     * @param {Boolean} [rebuild] Specify `true` to force a rebuild of the underlying header level definitions\n     */\n    refresh(rebuild = !this.levels.length) {\n        const\n            me               = this,\n            { columnConfig } = me.model,\n            { levels }       = me,\n            oldLevelsCount   = levels.length;\n\n        if (rebuild) {\n            levels.length = 0;\n\n            columnConfig.forEach((cells, position) => levels[position] = {\n                position,\n                cells\n            });\n\n            me.size = levels[0].cells.reduce((sum, cell) => sum += cell.width, 0);\n\n            // TODO clean up when this is fixed: https://app.assembla.com/spaces/bryntum/tickets/8413-horizontaltimeaxis-should-not-completely-overwrite-contents-of-column-el/details#\n            const parentEl = me.element.parentElement;\n\n            // Don't mutate a classList unless necessary. Browsers invalidate the style.\n            if (parentEl && (levels.length !== oldLevelsCount || rebuild)) {\n                parentEl.classList.remove(`b-sch-timeaxiscolumn-levels-${oldLevelsCount}`);\n                parentEl.classList.add(`b-sch-timeaxiscolumn-levels-${levels.length}`);\n            }\n        }\n\n        if (!me.startDate || !me.endDate) {\n            return;\n        }\n\n        // Boil down levels to only show what is in view\n        DomSync.sync({\n            domConfig     : me.buildCells(),\n            targetElement : me.element,\n            syncIdField   : 'headerFeature'\n        });\n\n        me.trigger('refresh');\n    }\n\n    //endregion\n\n    // Our widget class doesn't include \"base\".\n    get widgetClass() {\n        return 'b-timeaxis';\n    }\n}\n","import TimeAxisBase from './TimeAxisBase.js';\n\n/**\n * @module Scheduler/view/HorizontalTimeAxis\n */\n\n/**\n * A visual horizontal representation of the time axis described in the\n * {@link Scheduler.preset.ViewPreset#field-headers headers}.\n * Normally you should not interact with this class directly.\n *\n * @extends Scheduler/view/TimeAxisBase\n * @private\n */\nexport default class HorizontalTimeAxis extends TimeAxisBase {\n\n    //region Config\n\n    static get $name() {\n        return 'HorizontalTimeAxis';\n    }\n\n    static get type() {\n        return 'horizontaltimeaxis';\n    }\n\n    static get configurable() {\n        return {\n            model        : null,\n            sizeProperty : 'width'\n        };\n    }\n\n    //endregion\n\n    get positionProperty() {\n        return this.owner?.rtl ? 'right' : 'left';\n    }\n\n    get width() {\n        return this.size;\n    }\n\n    onModelUpdate() {\n        // Force rebuild when availableSpace has changed, to recalculate width and maybe apply compact styling\n        // TODO: this.width is the scrollWidth and this.model.availableSpace is the clientWidth\n        // These are always going to be different (unless forceFit is set on the Gantt), so theres\n        // no optimization. Likely this should always refresh(true) anyway since we do not know *what*\n        // changed in the model update.\n        if (this.model.availableSpace !== this.width) {\n            this.refresh(true);\n        }\n    }\n\n    updateModel(timeAxisViewModel) {\n        this.detachListeners('tavm');\n\n        timeAxisViewModel?.ion({\n            name    : 'tavm',\n            update  : 'onModelUpdate',\n            thisObj : this\n        });\n    }\n}\n","import Widget from '../../Core/widget/Widget.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport DomClassList from '../../Core/helper/util/DomClassList.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport AvatarRendering from '../../Core/widget/util/AvatarRendering.js';\n\n/**\n * @module Scheduler/view/ResourceHeader\n */\n\n/**\n * Header widget that renders resource column headers and acts as the interaction point for resource columns in vertical\n * mode. Note that it uses virtual rendering and element reusage to gain performance, only headers in view are available\n * in DOM. Because of this you should avoid direct element manipulation, any such changes can be discarded at any time.\n *\n * By default, it displays resources `name` and also applies its `iconCls` if any, like this:\n *\n * ```\n * <i class=\"iconCls\">name</i>\n * ```\n *\n * If Scheduler is configured with a {@link Scheduler.view.Scheduler#config-resourceImagePath} the\n * header will render miniatures for the resources, using {@link Scheduler.model.ResourceModel#field-imageUrl}\n * or {@link Scheduler.model.ResourceModel#field-image} with fallback to\n * {@link Scheduler.model.ResourceModel#field-name} + {@link Scheduler.view.Scheduler#config-resourceImageExtension}\n * for unset values.\n *\n * The contents and styling of the resource cells in the header can be customized using {@link #config-headerRenderer}:\n *\n * ```\n * new Scheduler({\n *     mode            : 'vertical',\n *     resourceColumns : {\n *         headerRenderer : ({ resourceRecord }) => `Hello ${resourceRecord.name}`\n *     }\n * }\n *```\n *\n * The width of the resource columns is determined by the {@link #config-columnWidth} config.\n *\n * @extends Core/widget/Widget\n */\nexport default class ResourceHeader extends Widget {\n\n    //region Config\n\n    static $name = 'ResourceHeader';\n\n    static type = 'resourceheader';\n\n    static configurable = {\n        /**\n         * Resource store used to render resource headers. Assigned from Scheduler.\n         * @config {Scheduler.data.ResourceStore}\n         * @private\n         */\n        resourceStore : null,\n\n        /**\n         * Custom header renderer function. Can be used to manipulate the element config used to create the element\n         * for the header:\n         *\n         * ```javascript\n         * new Scheduler({\n         *   resourceColumns : {\n         *     headerRenderer({ elementConfig, resourceRecord }) {\n         *       elementConfig.dataset.myExtraData = 'extra';\n         *       elementConfig.style.fontWeight = 'bold';\n         *     }\n         *   }\n         * });\n         * ```\n         *\n         * See {@link DomConfig} for more information.\n         * Please take care to not break the default configs :)\n         *\n         * Or as a template by returning HTML from the function:\n         *\n         * ```javascript\n         * new Scheduler({\n         *   resourceColumns : {\n         *     headerRenderer : ({ resourceRecord }) => `\n         *       <div class=\"my-custom-template\">\n         *       ${resourceRecord.firstName} {resourceRecord.surname}\n         *       </div>\n         *     `\n         *   }\n         * });\n         * ```\n         *\n         * NOTE: When using `headerRenderer` no default internal markup is applied to the resource header cell,\n         * `iconCls` and {@link Scheduler.model.ResourceModel#field-imageUrl} or {@link Scheduler.model.ResourceModel#field-image}\n         * will have no effect unless you supply custom markup for them.\n         *\n         * @config {Function}\n         * @param {Object} params Object containing the params below\n         * @param {Scheduler.model.ResourceModel} params.resourceRecord Resource whose header is being rendered\n         * @param {DomConfig} params.elementConfig A config object used to create the element for the resource\n         */\n        headerRenderer : null,\n\n        /**\n         * Set to `false` to render just the resource name, `true` to render an avatar (or initials if no image exists)\n         * @config {Boolean}\n         * @default true\n         */\n        showAvatars : {\n            value : true,\n\n            $config : 'nullify'\n        },\n\n        /**\n         * Assign to toggle resource columns **fill* mode. `true` means they will stretch (grow) to fill viewport, `false`\n         * that they will respect their configured `columnWidth`.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @member {Boolean} fillWidth\n         */\n        /**\n         * Automatically resize resource columns to **fill** available width. Set to `false` to always respect the\n         * configured `columnWidth`.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @config {Boolean}\n         * @default\n         */\n        fillWidth : true,\n\n        /**\n         * Assign to toggle resource columns **fit* mode. `true` means they will grow or shrink to always fit viewport,\n         * `false` that they will respect their configured `columnWidth`.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @member {Boolean} fitWidth\n         */\n        /**\n         * Automatically resize resource columns to always **fit** available width.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @config {Boolean}\n         * @default\n         */\n        fitWidth : false,\n\n        /**\n         * Width for each resource column.\n         *\n         * This is used for resources which are not are loaded with a {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @config {Number}\n         */\n        columnWidth : 150,\n\n        // Copied from Scheduler#resourceImagePath on creation in TimeAxisColumn.js\n        imagePath : null,\n\n        // Copied from Scheduler#resourceImageExtension on creation in TimeAxisColumn.js\n        imageExtension : null,\n\n        // Copied from Scheduler#defaultResourceImageName on creation in TimeAxisColumn.js\n        defaultImageName : null,\n\n        availableWidth : null\n    };\n\n    static properties = {\n        /**\n         * An index of the first visible resource in vertical mode\n         * @property {Number}\n         * @readonly\n         * @private\n         */\n        firstResource : -1,\n        /**\n         * An index of the last visible resource in vertical mode\n         * @property {Number}\n         * @readonly\n         * @private\n         */\n        lastResource  : -1\n    };\n\n    //endregion\n\n    //region Init\n\n    construct(config) {\n        const me = this;\n\n        // Inject this into owning Scheduler early because code further down\n        // can call code which uses scheduler.resourceColumns.\n        config.scheduler._resourceColumns = me;\n\n        super.construct(config);\n\n        if (me.imagePath != null) {\n            // Need to increase height a bit when displaying images\n            me.element.classList.add('b-has-images');\n        }\n\n        EventHelper.on({\n            element     : me.element,\n            delegate    : '.b-resourceheader-cell',\n            capture     : true,\n            click       : 'onResourceMouseEvent',\n            dblclick    : 'onResourceMouseEvent',\n            contextmenu : 'onResourceMouseEvent',\n            thisObj     : me\n        });\n    }\n\n    changeShowAvatars(show) {\n        this.avatarRendering?.destroy();\n\n        if (show) {\n            this.avatarRendering = new AvatarRendering({\n                element : this.element\n            });\n        }\n\n        return show;\n    }\n\n    updateShowAvatars() {\n        if (!this.isConfiguring) {\n            this.refresh();\n        }\n    }\n\n    //endregion\n\n    //region ResourceStore\n\n    updateResourceStore(store) {\n        const me = this;\n\n        me.detachListeners('resourceStore');\n\n        if (store) {\n            store.ion({\n                name            : 'resourceStore',\n                changePreCommit : 'onResourceStoreDataChange',\n                thisObj         : me\n            });\n\n            // Already have data? Update width etc\n            if (store.count) {\n                me.onResourceStoreDataChange({});\n            }\n        }\n    }\n\n    // Redraw resource headers on any data change\n    onResourceStoreDataChange({ action }) {\n        const me    = this;\n\n        // These must be ingested before we assess the source of column widths\n        // so that they can be cleared *after* their values have been cached.\n        me.getConfig('fillWidth');\n        me.getConfig('fitWidth');\n        me.updateWidthCache();\n\n        const\n            {\n                element\n            }     = me,\n            width = me.totalWidth;\n\n        // If we have some defined columnWidths in the resourceStore\n        // we must then bypass configured fitWidth and fillWidth behaviour.\n        if (me.scheduler.variableColumnWidths) {\n            me._fillWidth = me._fitWidth = false;\n        }\n        else {\n            me._fillWidth = me.configuredFillWidth;\n            me._fitWidth = me.configuredFitWidth;\n        }\n\n        if (width !== me.width) {\n            DomHelper.setLength(element, 'width', width);\n            // During setup, silently set the width. It will then render correctly. After setup, let the world know...\n            me.column.set('width', width, me.column.grid.isConfiguring);\n        }\n\n        if (action === 'removeall') {\n            // Keep nothing\n            element.innerHTML = '';\n        }\n\n        if (action === 'remove' || action === 'add' || action === 'filter' || me.fitWidth || me.fillWidth) {\n            me.refreshWidths();\n        }\n\n        me.column.grid.toggleEmptyText();\n    }\n\n    get totalWidth() {\n        return this.updateWidthCache();\n    }\n\n    updateWidthCache() {\n        let result          = 0;\n        const { scheduler } = this;\n\n        // Flag so that VerticalRendering#getResourceRange knows\n        // whether to use fast or slow mode to ascertain visible columns.\n        scheduler.variableColumnWidths = false;\n\n        scheduler.resourceStore.forEach(resource => {\n            // Set the start position for each resource with respect to the widths\n            resource.instanceMeta(scheduler).insetStart = result;\n            resource.instanceMeta(scheduler).insetEnd   = result + (resource.columnWidth || scheduler.resourceColumnWidth);\n\n            if (resource.columnWidth == null) {\n                result += scheduler.resourceColumnWidth;\n            }\n            else {\n                result += resource.columnWidth;\n                scheduler.variableColumnWidths = true;\n            }\n        });\n\n        return result;\n    }\n\n    //endregion\n\n    //region Properties\n\n    changeColumnWidth(columnWidth) {\n        // Cache configured value, because if *all* resources have their own columnWidths\n        // the property will be nulled, but if we ever recieve a new resource with no\n        // columnWidth, or a columnWidth is nulled, we then have to fall back to using this.\n        if (!this.refreshingWidths) {\n            this.configuredColumnWidth = columnWidth;\n        }\n        return columnWidth;\n    }\n\n    updateColumnWidth(width, oldWidth) {\n        const me = this;\n\n        // Flag set in refreshWidths, do not want to create a loop\n        if (!me.refreshingWidths) {\n            me.refreshWidths();\n        }\n\n        if (!me.isConfiguring) {\n            me.refresh();\n            // Cannot trigger with requested width, might have changed because of fit/fill\n            me.trigger('columnWidthChange', { width, oldWidth });\n        }\n    }\n\n    changeFillWidth(fillWidth) {\n        return this.configuredFillWidth = fillWidth;\n    }\n\n    updateFillWidth() {\n        if (!this.isConfiguring) {\n            this.refreshWidths();\n        }\n    }\n\n    changeFitWidth(fitWidth) {\n        return this.configuredFitWidth = fitWidth;\n    }\n\n    updateFitWidth() {\n        if (!this.isConfiguring) {\n            this.refreshWidths();\n        }\n    }\n\n    getImageURL(imageName) {\n        return StringHelper.joinPaths([this.imagePath || '', imageName || '']);\n    }\n\n    updateImagePath() {\n        if (!this.isConfiguring) {\n            this.refresh();\n        }\n    }\n\n    //endregion\n\n    //region Fit to width\n\n    updateAvailableWidth(width) {\n        this.refreshWidths();\n    }\n\n    // Updates the column widths according to fill and fit settings\n    refreshWidths() {\n        const\n            me    = this,\n            {\n                availableWidth,\n                configuredColumnWidth\n            }     = me,\n            count = me.resourceStore?.count;\n\n        // Bail out if availableWidth not yet set or resource store not assigned/loaded\n        // or column widths are defined in the resources.\n        if (!availableWidth || !count || me.scheduler.variableColumnWidths) {\n            return;\n        }\n\n        me.refreshingWidths = true;\n\n        const\n            // Fit width if configured to do so or if configured to fill and used width is less than available width\n            fit           = me.fitWidth || me.fillWidth && configuredColumnWidth * count < availableWidth,\n            useWidth      = fit ? Math.floor(availableWidth / count) : configuredColumnWidth,\n            shouldAnimate = me.column.grid.enableEventAnimations && Math.abs(me._columnWidth - useWidth) > 30;\n\n        DomHelper.addTemporaryClass(me.element, 'b-animating', shouldAnimate ? 300 : 0, me);\n\n        me.columnWidth = useWidth;\n\n        me.refreshingWidths = false;\n    }\n\n    //endregion\n\n    //region Rendering\n\n    // Visual resource range, set by VerticalRendering + its buffer\n    set visibleResources({ firstResource, lastResource }) {\n        this.firstResource = firstResource;\n        this.lastResource = lastResource;\n\n        this.updateWidthCache();\n        this.refresh();\n    }\n\n    /**\n     * Refreshes the visible headers\n     */\n    refresh() {\n        const\n            me         = this,\n            {\n                firstResource,\n                scheduler,\n                resourceStore,\n                lastResource\n            }          = me,\n            {\n                variableColumnWidths\n            }          = scheduler,\n            groupField = resourceStore.isGrouped && resourceStore.groupers[0].field,\n            configs    = [];\n\n        me.element.classList.toggle('b-grouped', Boolean(groupField));\n\n        if (!me.column.grid.isConfiguring && firstResource > -1 && lastResource > -1 && lastResource < resourceStore.count) {\n            let currentGroup;\n            // Gather element configs for resource headers in view\n            for (let i = firstResource; i <= lastResource; i++) {\n                const\n                    resourceRecord = resourceStore.allResourceRecords[i],\n                    groupRecord    = resourceRecord.instanceMeta(resourceStore).groupParent,\n                    groupChildren  = groupRecord?.groupChildren;\n\n                if (groupField && groupRecord.id !== currentGroup?.dataset.resourceId) {\n                    const\n                        groupLeft  = groupChildren[0].instanceMeta(scheduler).insetStart,\n                        groupWidth = groupChildren[groupChildren.length - 1].instanceMeta(scheduler).insetEnd - groupLeft;\n\n                    currentGroup = {\n                        className : 'b-resourceheader-group-cell',\n                        dataset   : {\n                            resourceId : groupRecord.id\n                        },\n                        style : {\n                            left  : groupLeft,\n                            width : groupWidth\n                        },\n                        children : [\n                            {\n                                tag  : 'span',\n                                html : StringHelper.encodeHtml(groupChildren[0][groupField])\n                            },\n                            {\n                                className : 'b-resourceheader-group-children',\n                                children  : []\n                            }\n                        ]\n                    };\n\n                    configs.push(currentGroup);\n                }\n\n                const\n                    instanceMeta  = resourceRecord.instanceMeta(scheduler),\n                    // Possible variable column width taken from the resources, fallback to scheduler's default\n                    width         = resourceRecord.columnWidth || me.columnWidth,\n                    position      = groupField ? instanceMeta.insetStart - currentGroup.style.left //groupChildren[0].instanceMeta(scheduler).insetStart\n                        : variableColumnWidths ? instanceMeta.insetStart : i * me.columnWidth,\n                    elementConfig = {\n                        // Might look like overkill to use DomClassList here, but can be used in headerRenderer\n                        className : new DomClassList({\n                            'b-resourceheader-cell' : 1\n                        }),\n                        dataset : {\n                            resourceId : resourceRecord.id\n                        },\n                        style : {\n                            [scheduler.rtl ? 'right' : 'left'] : position,\n                            width\n                        },\n                        children : []\n                    };\n\n                // Let a configured headerRenderer have a go at it before applying\n                if (me.headerRenderer) {\n                    const value = me.headerRenderer({ elementConfig, resourceRecord });\n\n                    if (value != null) {\n                        elementConfig.html = value;\n                    }\n                }\n                // No headerRenderer, apply default markup\n                else {\n                    let imageUrl;\n\n                    if (resourceRecord.imageUrl) {\n                        imageUrl = resourceRecord.imageUrl;\n                    }\n                    else {\n                        if (me.imagePath != null) {\n                            if (resourceRecord.image !== false) {\n                                const imageName = resourceRecord.image ||\n                                    resourceRecord.name?.toLowerCase() + me.imageExtension;\n                                imageUrl = me.getImageURL(imageName);\n                            }\n                        }\n                    }\n\n                    // By default showing resource name and optionally avatar\n                    elementConfig.children.push(\n                        me.showAvatars && me.avatarRendering.getResourceAvatar({\n                            resourceRecord,\n                            initials        : resourceRecord.initials,\n                            color           : resourceRecord.eventColor,\n                            iconCls         : resourceRecord.iconCls,\n                            defaultImageUrl : me.defaultImageName && me.getImageURL(me.defaultImageName),\n                            imageUrl\n                        }),\n                        {\n                            tag       : 'span',\n                            className : 'b-resource-name',\n                            html      : StringHelper.encodeHtml(resourceRecord.name)\n                        }\n                    );\n                }\n\n                if (groupField) {\n                    currentGroup.children[1].children.push(elementConfig);\n                }\n                else {\n                    configs.push(elementConfig);\n                }\n            }\n        }\n\n        // Sync changes to the header\n        DomSync.sync({\n            domConfig : {\n                onlyChildren : true,\n                children     : configs\n            },\n            targetElement : me.element,\n            syncIdField   : 'resourceId'\n            // TODO: Add callback here to trigger events when rendering/derendering header cells. Sooner or later\n            //  someone is going to ask for a way to render JSX or what not to the header\n        });\n    }\n\n    //endregion\n\n    onResourceMouseEvent(event) {\n        const\n            resourceCell   = event.target.closest('.b-resourceheader-cell'),\n            resourceRecord = this.resourceStore.getById(resourceCell.dataset.resourceId);\n\n        this.trigger('resourceHeader' + StringHelper.capitalize(event.type), {\n            resourceRecord,\n            event\n        });\n    }\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs for the header, removing irrelevant ones\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n\n        // Assigned from Scheduler\n        delete result.resourceStore;\n        delete result.column;\n        delete result.type;\n\n        return result;\n    }\n}\n","import WidgetColumn from '../../Grid/column/WidgetColumn.js';\nimport ColumnStore from '../../Grid/data/ColumnStore.js';\nimport Events from '../../Core/mixin/Events.js';\nimport HorizontalTimeAxis from '../view/HorizontalTimeAxis.js';\nimport ResourceHeader from '../view/ResourceHeader.js';\n\n/**\n * @module Scheduler/column/TimeAxisColumn\n */\n\n/**\n * A column containing the timeline \"viewport\", in which events, dependencies etc are drawn.\n * Normally you do not need to interact with or create this column, it is handled by Scheduler.\n *\n * If you wish to output custom contents inside the time axis row cells, you can provide your custom column configuration\n * using the {@link #config-renderer} like so:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *    appendTo         : document.body\n *    columns          : [\n *       { text : 'Name', field : 'name', width : 130 },\n *       {\n *           type : 'timeAxis',\n *           renderer({ record, cellElement }) {\n *               return '<div class=\"cool-chart\"></div>';\n *           }\n *       }\n *    ]\n * });\n * ```\n * @extends Grid/column/WidgetColumn\n * @column\n */\nexport default class TimeAxisColumn extends Events(WidgetColumn) {\n    //region Config\n\n    static $name = 'TimeAxisColumn';\n\n    static get fields() {\n        return [\n            // Exclude some irrelevant fields from getCurrentConfig()\n            { name : 'locked', persist : false },\n            { name : 'flex', persist : false },\n            { name : 'width', persist : false },\n            { name : 'cellCls', persist : false },\n            { name : 'field', persist : false },\n            'mode'\n        ];\n    }\n\n    static get defaults() {\n        return {\n            /**\n             * Set to false to prevent this column header from being dragged.\n             * @config {Boolean} draggable\n             * @category Interaction\n             * @default false\n             */\n            draggable : false,\n\n            /**\n             * Set to false to prevent grouping by this column.\n             * @config {Boolean} groupable\n             * @category Interaction\n             * @default false\n             */\n            groupable : false,\n\n            /**\n             * Allow column visibility to be toggled through UI.\n             * @config {Boolean} hideable\n             * @default false\n             * @category Interaction\n             */\n            hideable : false,\n\n            /**\n             * Show column picker for the column.\n             * @config {Boolean} showColumnPicker\n             * @default false\n             * @category Menu\n             */\n            showColumnPicker : false,\n\n            /**\n             * Allow filtering data in the column (if Filter feature is enabled)\n             * @config {Boolean} filterable\n             * @default false\n             * @category Interaction\n             */\n            filterable : false,\n\n            /**\n             * Allow sorting of data in the column\n             * @config {Boolean} sortable\n             * @category Interaction\n             * @default false\n             */\n            sortable : false,\n\n            /**\n             * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.\n             * @config {Boolean} resizable\n             * @default false\n             * @category Interaction\n             */\n            resizable : false,\n\n            /**\n             * Allow searching in the column (respected by QuickFind and Search features)\n             * @config {Boolean} searchable\n             * @default false\n             * @category Interaction\n             */\n            searchable : false,\n\n            /**\n             * @config {String} editor\n             * @hide\n             */\n            editor : false,\n\n            /**\n             * Set to `true` to show a context menu on the cell elements in this column\n             * @config {Boolean} enableCellContextMenu\n             * @default false\n             * @category Menu\n             */\n            enableCellContextMenu : false,\n\n            /**\n             * @config {Function|Boolean} tooltipRenderer\n             * @hide\n             */\n            tooltipRenderer : false,\n\n            /**\n             * CSS class added to the header of this column\n             * @config {String} cls\n             * @category Rendering\n             * @default 'b-sch-timeaxiscolumn'\n             */\n            cls : 'b-sch-timeaxiscolumn',\n\n            // needs to have width specified, flex-basis messes measurements up\n            needWidth : true,\n\n            mode       : null,\n            region     : 'normal',\n            exportable : false,\n            htmlEncode : false\n        };\n    }\n\n    static get type() {\n        return 'timeAxis';\n    }\n\n    //region Init\n\n    construct(config) {\n        const me = this;\n\n        super.construct(...arguments);\n\n        me.thisObj = me;\n        me.timeAxisViewModel = me.grid.timeAxisViewModel;\n        // A bit hacky, because mode is a field and not a config\n        // eslint-disable-next-line no-self-assign\n        me.mode = me.mode;\n\n        me.grid.ion({\n            paint   : 'onTimelinePaint',\n            thisObj : me,\n            once    : true\n        });\n    }\n\n    static get autoExposeFields() {\n        return true;\n    }\n\n    // endregion\n\n    doDestroy() {\n        this.resourceColumns?.destroy();\n        this.timeAxisView?.destroy();\n        super.doDestroy();\n    }\n\n    set mode(mode) {\n        const\n            me       = this,\n            { grid } = me;\n\n        me.set('mode', mode);\n\n        // In horizontal mode this column has a time axis header on top, with timeline ticks\n        if (mode === 'horizontal') {\n            me.timeAxisView = new HorizontalTimeAxis({\n                model                     : me.timeAxisViewModel,\n                compactCellWidthThreshold : me.compactCellWidthThreshold,\n                owner                     : grid,\n                client                    : grid\n            });\n        }\n        // In vertical mode, it instead displays resources at top\n        else if (mode === 'vertical') {\n            // TODO: Most other vertical stuff is handled in VerticalRendering, move there?\n            me.resourceColumns = ResourceHeader.new({\n                column           : me,\n                scheduler        : grid,\n                resourceStore    : grid.resourceStore,\n                imagePath        : grid.resourceImagePath,\n                imageExtension   : grid.resourceImageExtension,\n                defaultImageName : grid.defaultResourceImageName\n            }, grid.resourceColumns || {});\n\n            me.relayEvents(me.resourceColumns, [\n                'resourceheaderclick',\n                'resourceheaderdblclick',\n                'resourceheadercontextmenu'\n            ]);\n        }\n    }\n\n    get mode() {\n        return this.get('mode');\n    }\n\n    // TODO: define all configs as fields and set below to false...\n\n    //region Events\n\n    onViewModelUpdate({ source : viewModel }) {\n        const me = this;\n\n        if (me.mode === 'horizontal') {\n            // render the time axis view into the column header element\n            me.refreshHeader(true);\n\n            me.width = viewModel.totalSize;\n\n            me.grid.refresh();\n\n            // When width is set above, that ends up on a columnsResized listener, but the refreshing of the fake\n            // scrollers to accommodate the new width is not done in this timeframe, so the upcoming centering related\n            // to preset change cannot work. So we have to refresh the fake scrollers now\n            me.subGrid.refreshFakeScroll();\n        }\n        else if (me.mode === 'vertical') {\n            // Refresh to rerender cells, in the process updating the vertical timeaxis to reflect view model changes\n            me.grid.refreshRows();\n        }\n    }\n\n    // Called on paint. SubGrid has its width so this is the earliest time to configure the TimeAxisViewModel with\n    // correct width\n    onTimelinePaint({ firstPaint }) {\n        const me = this;\n\n        if (!me.subGrid.insertRowsBefore) {\n            return;\n        }\n\n        if (firstPaint) {\n            me.subGridElement.classList.add('b-timeline-subgrid');\n\n            if (me.mode === 'vertical') {\n                me.refreshHeader();\n\n                // The above operation can cause height change.\n                me.grid?.onHeightChange();\n            }\n        }\n    }\n\n    //endregion\n\n    //region Rendering\n\n    /**\n     * Refreshes the columns header contents (which is either a HorizontalTimeAxis or a ResourceHeader). Useful if you\n     * have rendered some extra meta data that depends on external data such as the EventStore or ResourceStore.\n     */\n    refreshHeader(internal) {\n        const\n            me          = this,\n            { element } = me;\n\n        if (element) {\n\n            if (me.mode === 'horizontal') {\n                // Force timeAxisViewModel to regenerate its column config, which calls header renderers etc.\n                !internal && me.timeAxisViewModel.update(undefined, undefined, true);\n\n                if (!me.timeAxisView.rendered) {\n                    // Do not need the normal header markup\n                    element.innerHTML = '';\n\n                    me.timeAxisView.render(element);\n                }\n                else {\n                    // Force rebuild of cells in case external data has changed (cheap since it still syncs to DOM)\n                    me.timeAxisView.refresh(true);\n                }\n            }\n            else if (me.mode === 'vertical') {\n                if (!me.resourceColumns.currentElement) {\n                    // Do not need the normal header markup\n                    element.innerHTML = '';\n\n                    me.resourceColumns.render(element);\n                }\n\n                // Vertical's resourceColumns is redrawn with the events, no need here\n            }\n        }\n    }\n\n    internalRenderer(renderData) {\n        const { grid } = this;\n        // No drawing of events before engines initial commit\n        if (grid.project.isInitialCommitPerformed || grid.project.isDelayingCalculation) {\n            grid.currentOrientation.renderer(renderData);\n\n            return super.internalRenderer(renderData);\n        }\n    }\n\n    //endregion\n\n    get timeAxisViewModel() {\n        return this._timeAxisViewModel;\n    }\n\n    set timeAxisViewModel(timeAxisViewModel) {\n        const me = this;\n\n        me.detachListeners('tavm');\n\n        timeAxisViewModel?.ion({\n            name    : 'tavm',\n            update  : 'onViewModelUpdate',\n            prio    : -10000,\n            thisObj : me\n        });\n\n        me._timeAxisViewModel = timeAxisViewModel;\n\n        if (me.timeAxisView) {\n            me.timeAxisView.model = timeAxisViewModel;\n        }\n    }\n\n    // Width of the time axis column is solely determined by the zoom level. We should not keep it part of the state\n    // otherwise restoring the state might break the normal zooming process.\n    // Covered by SchedulerState.t\n    // https://github.com/bryntum/support/issues/5545\n    getState() {\n        const state = super.getState();\n\n        delete state.width;\n        delete state.flex;\n\n        return state;\n    }\n}\n\nColumnStore.registerColumnType(TimeAxisColumn);\n","import Model from '../../Core/data/Model.js';\nimport IdHelper from '../../Core/helper/IdHelper.js';\nimport DH from '../../Core/helper/DateHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n\n/**\n * @module Scheduler/preset/ViewPreset\n */\n\n/**\n * Defines a header level for a ViewPreset.\n *\n * A sample header configuration can look like below\n * ```javascript\n * headers    : {\n *     {\n *         unit        : \"month\",\n *         renderer : function(start, end, headerConfig, index) {\n *             var month = start.getMonth();\n *             // Simple alternating month in bold\n *             if (start.getMonth() % 2) {\n *                 return '<strong>' + month + '</strong>';\n *             }\n *             return month;\n *         },\n *         align       : 'start' // `start` or `end`, omit to center content (default)\n *     },\n *     {\n *         unit        : \"week\",\n *         increment   : 1,\n *         renderer    : function(start, end, headerConfig, index) {\n *             return 'foo';\n *         }\n *     },\n * }\n * ```\n *\n * @typedef {Object} ViewPresetHeaderRow\n * @property {'start'|'center'|'end'} align The text alignment for the cell. Valid values are `start` or `end`, omit\n * this to center text content (default). Can also be added programmatically in `the renderer`.\n * @property {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} unit The unit of time\n * represented by each cell in this header row. See also increment property. Valid values are \"millisecond\", \"second\",\n * \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n * @property {String} headerCellCls A CSS class to add to the cells in the time axis header row. Can also be added\n * programmatically in the `renderer`.\n * @property {Number} increment The number of units each header cell will represent (e.g. 30 together with unit:\n * \"minute\" for 30 minute cells)\n * @property {String} dateFormat Defines how the cell date will be formatted\n * @property {Function} renderer A custom renderer function used to render the cell content. It should return text/HTML\n * to put in the header cell.\n *\n * ```javascript\n * function (startDate, endDate, headerConfig, i) {\n *   // applies special CSS class to align header left\n *   headerConfig.align = \"start\";\n *   // will be added as a CSS class of the header cell DOM element\n *   headerConfig.headerCellCls = \"myClass\";\n *\n *   return DateHelper.format(startDate, 'YYYY-MM-DD');\n * }\n * ```\n *\n * The render function is called with the following parameters:\n *\n * @property {Date} renderer.startDate The start date of the cell.\n * @property {Date} renderer.endDate The end date of the cell.\n * @property {Object} renderer.headerConfig An object containing the header config.\n * @property {'start'|'center'|'end'} [renderer.headerConfig.align] The text alignment for the cell. See `align` above.\n * @property {String} [renderer.headerConfig.headerCellCls] A CSS class to add to the cells in the time axis header row.\n * See `headerCellCls` above.\n * @property {Number} renderer.index The index of the cell in the row.\n * @property {Object} thisObj `this` reference for the renderer function\n * @property {Function} cellGenerator A function that should return an array of objects containing 'start', 'end' and\n * 'header' properties. Use this if you want full control over how the header rows are generated.\n *\n * **Note:** `cellGenerator` cannot be used for the bottom level of your headers.\n *\n * Example :\n * ```javascript\n * viewPreset : {\n *     displayDateFormat : 'H:mm',\n *     shiftIncrement    : 1,\n *     shiftUnit         : 'WEEK',\n *     timeResolution    : {\n *         unit      : 'MINUTE',\n *         increment : 10\n *     },\n *     headers           : [\n *         {\n *             unit          : 'year',\n *             // Simplified scenario, assuming view will always just show one US fiscal year\n *             cellGenerator : (viewStart, viewEnd) => [{\n *                 start  : viewStart,\n *                 end    : viewEnd,\n *                 header : `Fiscal Year ${viewStart.getFullYear() + 1}`\n *             }]\n *         },\n *         {\n *             unit : 'quarter',\n *             renderer(start, end, cfg) {\n *                 const\n *                     quarter       = Math.floor(start.getMonth() / 3) + 1,\n *                     fiscalQuarter = quarter === 4 ? 1 : (quarter + 1);\n *\n *                 return `FQ${fiscalQuarter} ${start.getFullYear() + (fiscalQuarter === 1 ? 1 : 0)}`;\n *             }\n *         },\n *         {\n *             unit       : 'month',\n *             dateFormat : 'MMM Y'\n *         }\n *     ]\n *  },\n * ```\n */\n\n/**\n * A ViewPreset is a record of {@link Scheduler.preset.PresetStore PresetStore} which describes the granularity\n * of the timeline view of a {@link Scheduler.view.Scheduler Scheduler} and the layout and subdivisions of the timeline header.\n *\n * You can create a new instance by specifying all fields:\n *\n * ```javascript\n * const myViewPreset = new ViewPreset({\n *     id   : 'myPreset',              // Unique id value provided to recognize your view preset. Not required, but having it you can simply set new view preset by id: scheduler.viewPreset = 'myPreset'\n *\n *     name : 'My view preset',        // A human-readable name provided to be used in GUI, e.i. preset picker, etc.\n *\n *     tickWidth  : 24,                // Time column width in horizontal mode\n *     tickHeight : 50,                // Time column height in vertical mode\n *     displayDateFormat : 'HH:mm',    // Controls how dates will be displayed in tooltips etc\n *\n *     shiftIncrement : 1,             // Controls how much time to skip when calling shiftNext and shiftPrevious.\n *     shiftUnit      : 'day',         // Valid values are 'millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'.\n *     defaultSpan    : 12,            // By default, if no end date is supplied to a view it will show 12 hours\n *\n *     timeResolution : {              // Dates will be snapped to this resolution\n *         unit      : 'minute',       // Valid values are 'millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'.\n *         increment : 15\n *     },\n *\n *     headers : [                     // This defines your header rows from top to bottom\n *         {                           // For each row you can define 'unit', 'increment', 'dateFormat', 'renderer', 'align', and 'thisObj'\n *             unit       : 'day',\n *             dateFormat : 'ddd DD/MM'\n *         },\n *         {\n *             unit       : 'hour',\n *             dateFormat : 'HH:mm'\n *         }\n *     ],\n *\n *     columnLinesFor : 1              // Defines header level column lines will be drawn for. Defaults to the last level.\n * });\n * ```\n *\n * Or you can extend one of view presets registered in {@link Scheduler.preset.PresetManager PresetManager}:\n *\n * ```javascript\n * const myViewPreset2 = new ViewPreset({\n *     id   : 'myPreset',                  // Unique id value provided to recognize your view preset. Not required, but having it you can simply set new view preset by id: scheduler.viewPreset = 'myPreset'\n *     name : 'My view preset',            // A human-readable name provided to be used in GUI, e.i. preset picker, etc.\n *     base : 'hourAndDay',                // Extends 'hourAndDay' view preset provided by PresetManager. You can pick out any of PresetManager's view presets: PresetManager.records\n *\n *     timeResolution : {                  // Override time resolution\n *         unit      : 'minute',\n *         increment : 15                  // Make it increment every 15 mins\n *     },\n *\n *     headers : [                         // Override headers\n *         {\n *             unit       : 'day',\n *             dateFormat : 'DD.MM.YYYY'   // Use different date format for top header 01.10.2020\n *         },\n *         {\n *             unit       : 'hour',\n *             dateFormat : 'LT'\n *         }\n *     ]\n * });\n * ```\n *\n * See {@link Scheduler.preset.PresetManager PresetManager} for the list of base presets. You may add your own\n * presets to this global list:\n *\n * ```javascript\n * PresetManager.add(myViewPreset);     // Adds new preset to the global scope. All newly created scheduler instances will have it too.\n *\n * const scheduler = new Scheduler({\n *     viewPreset : 'myPreset'\n *     // other configs...\n * });\n * ```\n *\n * Or add them on an individual basis to Scheduler instances:\n *\n * ```javascript\n * const scheduler = new Scheduler({...});\n *\n * scheduler.presets.add(myViewPreset); // Adds new preset to the scheduler instance only. All newly created scheduler instances will **not** have it.\n *\n * scheduler.viewPreset = 'myPreset';\n * ```\n *\n * ## Defining custom header rows\n *\n * You can have any number of header rows by specifying {@link #field-headers}, see {@link #typedef-ViewPresetHeaderRow}\n * for the config object format and {@link Core.helper.DateHelper} for the supported date formats, or use to render\n * custom contents into the row cells.\n *\n * ```javascript\n *  headers : [\n *      {\n *          unit       : 'month',\n *          dateFormat : 'MM.YYYY'\n *      },\n *      {\n *          unit       : 'week',\n *          renderer   : ({ startDate }) => `Week ${DateHelper.format(startDate, 'WW')}`\n *      }\n *  ]\n * ```\n *\n * {@inlineexample Scheduler/preset/CustomHeader.js}\n *\n * This live demo shows a custom ViewPreset with AM/PM time format:\n * @inlineexample Scheduler/preset/amPmPreset.js\n * @extends Core/data/Model\n */\nexport default class ViewPreset extends Model {\n\n    static $name = 'ViewPreset';\n\n    static get fields() {\n        return [\n            /**\n             * The name of an existing view preset to extend\n             * @field {String} base\n             */\n            { name : 'base', type : 'string' },\n\n            /**\n             * The name of the view preset\n             * @field {String} name\n             */\n            { name : 'name', type : 'string' },\n\n            /**\n             * The height of the row in horizontal orientation\n             * @field {Number} rowHeight\n             * @default\n             */\n            {\n                name         : 'rowHeight',\n                defaultValue : 24\n            },\n\n            /**\n             * The width of the time tick column in horizontal orientation\n             * @field {Number} tickWidth\n             * @default\n             */\n            {\n                name         : 'tickWidth',\n                defaultValue : 50\n            },\n\n            /**\n             * The height of the time tick column in vertical orientation\n             * @field {Number} tickHeight\n             * @default\n             */\n            {\n                name         : 'tickHeight',\n                defaultValue : 50\n            },\n\n            /**\n             * Defines how dates will be formatted in tooltips etc\n             * @field {String} displayDateFormat\n             * @default\n             */\n            {\n                name         : 'displayDateFormat',\n                defaultValue : 'HH:mm'\n            },\n\n            /**\n             * The unit to shift when calling shiftNext/shiftPrevious to navigate in the chart.\n             * Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n             * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} shiftUnit\n             * @default\n             */\n            {\n                name         : 'shiftUnit',\n                defaultValue : 'hour'\n            },\n\n            /**\n             * The amount to shift (in shiftUnits)\n             * @field {Number} shiftIncrement\n             * @default\n             */\n            {\n                name         : 'shiftIncrement',\n                defaultValue : 1\n            },\n\n            /**\n             * The amount of time to show by default in a view (in the unit defined by {@link #field-mainUnit})\n             * @field {Number} defaultSpan\n             * @default\n             */\n            {\n                name         : 'defaultSpan',\n                defaultValue : 12\n            },\n\n            /**\n             * Initially set to a unit. Defaults to the unit defined by the middle header.\n             * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} mainUnit\n             */\n            {\n                name : 'mainUnit'\n            },\n\n            /**\n             * Note: Currently, this field only applies when changing viewPreset with the {@link Scheduler.widget.ViewPresetCombo}.\n             *\n             * Set to a number and that amount of {@link #field-mainUnit} will be added to the startDate. For example: A\n             * start value of `5` together with the mainUnit `hours` will add 5 hours to the startDate. This can achieve\n             * a \"day view\" that starts 5 AM.\n             *\n             * Set to a string unit (for example week, day, month) and the startDate will be the start of that unit\n             * calculated from current startDate. A start value of `week` will result in a startDate in the first day of\n             * the week.\n             *\n             * If set to a number or not set at all, the startDate will be calculated at the beginning of current\n             * mainUnit.\n             * @field {Number|String} start\n             */\n            {\n                name : 'start'\n            },\n\n            /**\n             * An object containing a unit identifier and an increment variable. This value means minimal task duration you can create using UI.\n             * For example when you drag create a task or drag & drop a task, if increment is 5 and unit is 'minute'\n             * that means that you can create a 5 min long task, or move it 5 min forward/backward. This config maps to\n             * scheduler's {@link Scheduler.view.mixin.TimelineDateMapper#property-timeResolution} config.\n             *\n             * ```javascript\n             * timeResolution : {\n             *   unit      : 'minute',  //Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n             *   increment : 5\n             * }\n             * ```\n             *\n             * @field {Object} timeResolution\n             */\n            'timeResolution',\n\n            /**\n             * An array containing one or more {@link #typedef-ViewPresetHeaderRow} config objects, each of\n             * which defines a level of headers for the scheduler.\n             * The `main` unit will be the last header's unit, but this can be changed using the\n             * {@link #field-mainHeaderLevel} field.\n             * @field {ViewPresetHeaderRow[]} headers\n             */\n            'headers',\n\n            /**\n             * Index of the {@link #field-headers} array to define which header level is the `main` header.\n             * Defaults to the bottom header.\n             * @field {Number} mainHeaderLevel\n             */\n            'mainHeaderLevel',\n\n            /**\n             * Index of a header level in the {@link #field-headers} array for which column lines are drawn. See\n             * {@link Scheduler.feature.ColumnLines}.\n             * Defaults to the bottom header.\n             * @field {Number} columnLinesFor\n             */\n            'columnLinesFor'\n        ];\n    }\n\n    construct() {\n        super.construct(...arguments);\n        this.normalizeUnits();\n    }\n\n    generateId(owner) {\n        const\n            me    = this,\n            {\n                headers\n            }     = me,\n            parts = [];\n\n        // If we were subclassed from a base, use that id as the basis of our.\n        let result = Object.getPrototypeOf(me.data).id;\n\n        if (!result) {\n            for (let { length } = headers, i = length - 1; i >= 0; i--) {\n                const\n                    { unit, increment } = headers[i],\n                    multiple            = increment > 1;\n\n                parts.push(`${multiple ? increment : ''}${i ? unit : StringHelper.capitalize(unit)}${multiple ? 's' : ''}`);\n            }\n\n            // Use upwards header units so eg \"monthAndYear\"\n            result = parts.join('And');\n        }\n\n        // If duplicate, decorate the generated by by adding details.\n        // For example make it \"hourAndDay-50by80\"\n        // Only interrogate the store if it is loaded. If consulted during\n        // a load, the idMap will be created empty\n        if (owner.count && owner.includes(result)) {\n            result += `-${me.tickWidth}by${me.tickHeight || me.tickWidth}`;\n            // If still duplicate use increment\n            if (owner.includes(result)) {\n                result += `-${me.bottomHeader.increment}`;\n                // And if STILL duplicate, make it unique with a suffix\n                if (owner.includes(result)) {\n                    result = IdHelper.generateId(`${result}-`);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    normalizeUnits() {\n        const\n            me                                     = this,\n            { timeResolution, headers, shiftUnit } = me;\n\n        if (headers) {\n            // Make sure date \"unit\" constant specified in the preset are resolved\n            for (let i = 0, { length } = headers; i < length; i++) {\n                const header = headers[i];\n\n                header.unit = DH.normalizeUnit(header.unit);\n                if (header.splitUnit) {\n                    header.splitUnit = DH.normalizeUnit(header.splitUnit);\n                }\n                if (!('increment' in header)) {\n                    headers[i] = Object.assign({\n                        increment : 1\n                    }, header);\n                }\n            }\n        }\n\n        if (timeResolution) {\n            timeResolution.unit = DH.normalizeUnit(timeResolution.unit);\n        }\n\n        if (shiftUnit) {\n            me.shiftUnit = DH.normalizeUnit(shiftUnit);\n        }\n    }\n\n    // Process legacy columnLines config into a headers array.\n    static normalizeHeaderConfig(data) {\n        const\n            { headerConfig, columnLinesFor, mainHeaderLevel } = data,\n            headers                                           = data.headers = [];\n\n        if (headerConfig.top) {\n            if (columnLinesFor === 'top') {\n                data.columnLinesFor = 0;\n            }\n            if (mainHeaderLevel === 'top') {\n                data.mainHeaderLevel = 0;\n            }\n            headers[0] = headerConfig.top;\n        }\n        if (headerConfig.middle) {\n            if (columnLinesFor === 'middle') {\n                data.columnLinesFor = headers.length;\n            }\n            if (mainHeaderLevel === 'middle') {\n                data.mainHeaderLevel = headers.length;\n            }\n            headers.push(headerConfig.middle);\n        }\n        else {\n            throw new Error('ViewPreset.headerConfig must be configured with a middle');\n        }\n        if (headerConfig.bottom) {\n            // Main level is middle when using headerConfig object.\n            data.mainHeaderLevel = headers.length - 1;\n\n            // There *must* be a middle above this bottom header\n            // so that is the columnLines one by default.\n            if (columnLinesFor == null) {\n                data.columnLinesFor = headers.length - 1;\n            }\n            else if (columnLinesFor === 'bottom') {\n                data.columnLinesFor = headers.length;\n            }\n\n            // There *must* be a middle above this bottom header\n            // so that is the main one by default.\n            if (mainHeaderLevel == null) {\n                data.mainHeaderLevel = headers.length - 1;\n            }\n            if (mainHeaderLevel === 'bottom') {\n                data.mainHeaderLevel = headers.length;\n            }\n\n            headers.push(headerConfig.bottom);\n        }\n    }\n\n    // These are read-only once configured.\n    set() {}\n\n    inSet() {}\n\n    get columnLinesFor() {\n        return ('columnLinesFor' in this.data) ? this.data.columnLinesFor : this.headers.length - 1;\n    }\n\n    get tickSize() {\n        return this._tickSize || this.tickWidth;\n    }\n\n    get tickWidth() {\n        return ('tickWidth' in this.data) ? this.data.tickWidth : 50;\n    }\n\n    get tickHeight() {\n        return ('tickHeight' in this.data) ? this.data.tickHeight : 50;\n    }\n\n    get headerConfig() {\n        // Configured in the legacy manner, just return the configured value.\n        if (this.data.headerConfig) {\n            return this.data.headerConfig;\n        }\n\n        // Rebuild the object based upon the configured headers array.\n        const\n            result      = {},\n            { headers } = this,\n            { length }  = headers;\n\n        switch (length) {\n            case 1 :\n                result.middle = headers[0];\n                break;\n            case 2:\n                if (this.mainHeaderLevel === 0) {\n                    result.middle = headers[0];\n                    result.bottom = headers[1];\n                }\n                else {\n                    result.top    = headers[0];\n                    result.middle = headers[1];\n                }\n                break;\n            case 3:\n                result.top    = headers[0];\n                result.middle = headers[1];\n                result.bottom = headers[2];\n                break;\n            default:\n                throw new Error('headerConfig object not supported for >3 header levels');\n        }\n\n        return result;\n    }\n\n    set mainHeaderLevel(mainHeaderLevel) {\n        this.data.mainHeaderLevel = mainHeaderLevel;\n    }\n\n    get mainHeaderLevel() {\n        if ('mainHeaderLevel' in this.data) {\n            return this.data.mainHeaderLevel;\n        }\n\n        // 3 headers, then it's the middle\n        if (this.data.headers.length === 3) {\n            return 1;\n        }\n\n        // Assume it goes top, middle.\n        // If it's middle, top, use mainHeaderLevel : 0\n        return this.headers.length - 1;\n    }\n\n    get mainHeader() {\n        return this.headers[this.mainHeaderLevel];\n    }\n\n    get bottomHeader() {\n        return this.headers[this.headers.length - 1];\n    }\n\n    get leafUnit() {\n        return this.bottomHeader.unit;\n    }\n\n    get leafIncrement() {\n        return this.bottomHeader.increment;\n    }\n\n    get mainUnit() {\n        if ('mainUnit' in this.data) {\n            return this.data.mainUnit;\n        }\n        return this.mainHeader.unit;\n    }\n\n    get msPerPixel() {\n        const { bottomHeader } = this;\n\n        return Math.round(DH.asMilliseconds(bottomHeader.increment || 1, bottomHeader.unit) / this.tickWidth);\n    }\n\n    get isValid() {\n        const me = this;\n\n        let valid = true;\n\n        // Make sure all date \"unit\" constants are valid\n        for (const header of me.headers) {\n            valid = valid && Boolean(DH.normalizeUnit(header.unit));\n        }\n\n        if (me.timeResolution) {\n            valid = valid && DH.normalizeUnit(me.timeResolution.unit);\n        }\n\n        if (me.shiftUnit) {\n            valid = valid && DH.normalizeUnit(me.shiftUnit);\n        }\n\n        return valid;\n    }\n}\n","import { unitMagnitudes } from '../../Core/helper/DateHelper.js';\nimport ViewPreset from './ViewPreset.js';\nimport Localizable from '../../Core/localization/Localizable.js';\nimport '../../Scheduler/localization/En.js';\nimport Store from '../../Core/data/Store.js';\nimport PresetManager from './PresetManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Scheduler/preset/PresetStore\n */\n\n/**\n * A special Store subclass which holds {@link Scheduler.preset.ViewPreset ViewPresets}.\n * Each ViewPreset in this store represents a zoom level. The store data is sorted in special\n * zoom order. That is zoomed out to zoomed in. The first Preset will produce the narrowest event bars\n * the last one will produce the widest event bars.\n *\n * To specify view presets (zoom levels) please provide set of view presets to the scheduler:\n *\n * ```javascript\n * const myScheduler = new Scheduler({\n *     presets : [\n *         {\n *             base : 'hourAndDay',\n *             id   : 'MyHourAndDay',\n *             // other preset configs....\n *         },\n *         {\n *             base : 'weekAndMonth',\n *             id   : 'MyWeekAndMonth',\n *             // other preset configs....\n *         }\n *     ],\n *     viewPreset : 'MyHourAndDay',\n *     // other scheduler configs....\n *     });\n * ```\n *\n * @extends Core/data/Store\n */\nexport default class PresetStore extends Localizable(Store) {\n\n    static get $name() {\n        return 'PresetStore';\n    }\n\n    static get defaultConfig() {\n        return {\n            useRawData : true,\n\n            modelClass : ViewPreset,\n\n            /**\n             * Specifies the sort order of the presets in the store.\n             * By default they are in zoomed out to zoomed in order. That is\n             * presets which will create widest event bars to presets\n             * which will produce narrowest event bars.\n             *\n             * Configure this as `-1` to reverse this order.\n             * @config {Number}\n             * @default\n             */\n            zoomOrder : 1\n        };\n    }\n\n    set storage(storage) {\n        super.storage = storage;\n\n        // Maintained in order automatically while adding.\n        this.storage.addSorter((lhs, rhs) => {\n            const\n                leftBottomHeader  = lhs.bottomHeader,\n                rightBottomHeader = rhs.bottomHeader;\n\n            // Sort order:\n            //  Milliseconds per pixel.\n            //  Tick size.\n            //  Unit magnitude.\n            //  Increment size.\n            const\n                order = rhs.msPerPixel - lhs.msPerPixel ||\n                unitMagnitudes[leftBottomHeader.unit] - unitMagnitudes[rightBottomHeader.unit] ||\n                leftBottomHeader.increment - rightBottomHeader.increment;\n\n            return order * this.zoomOrder;\n        });\n    }\n\n    get storage() {\n        return super.storage;\n    }\n\n    getById(id) {\n        // If we do not know about the id, inherit it from the PresetManager singleton\n        return super.getById(id) || !this.isPresetManager && PresetManager.getById(id);\n    }\n\n    createRecord(data, ...args) {\n        let result;\n\n        if (data.isViewPreset) {\n            return data;\n        }\n        if (typeof data === 'string') {\n            result = this.getById(data);\n        }\n        else if (typeof data === 'number') {\n            result = this.getAt(data);\n        }\n        // Its a ViewPreset data object\n        else {\n            // If it's extending an existing ViewPreset, inherit then override\n            // the data from the base.\n            if (data.base) {\n                data = this.copyBaseValues(data);\n            }\n\n            // Model constructor will call generateId if no id is provided\n            return super.createRecord(data, ...args);\n        }\n        if (!result) {\n            throw new Error(`ViewPreset ${data} does not exist`);\n        }\n        return result;\n    }\n\n    updateLocalization() {\n        super.updateLocalization();\n\n        const me = this;\n\n        // Collect presets from store...\n        let presets = me.allRecords;\n\n        // and basePresets if we are the PresetManager\n        if (me.isPresetManager) {\n            presets = new Set(presets.concat(Object.values(me.basePresets)));\n        }\n\n        presets.forEach(preset => {\n            let localePreset = me.optionalL(`L{PresetManager.${preset.id}}`, null, true);\n\n            // Default presets generated from base presets use localization of base if they have no own\n            if (typeof localePreset === 'string' && preset.baseId) {\n                localePreset = me.optionalL(`L{PresetManager.${preset.baseId}}`, null, true);\n            }\n\n            // Apply any custom format defined in locale, or the original format if none exists\n            if (localePreset && typeof localePreset === 'object') {\n                if (!preset.originalDisplayDateFormat) {\n                    preset.originalDisplayDateFormat = preset.displayDateFormat;\n                }\n\n                // TODO: work around to work topDateFormat for weekAndDay viewPreset localization.\n                // it must be fixed on: https://github.com/bryntum/support/issues/1775\n                // it there is a topDateFormat but preset.mainHeaderLevel is 0, means the middle header is the top header actually, so convert property to middle (if middle doesn't exists) to localization understand (topDateFormat for weekAndDay for example)\n                // topDateFormat doesn't work when mainHeaderLevel is 0 because it doesn't have top config but has top header visually (Check on get headerConfig method in ViewPreset class)\n                if (preset.mainHeaderLevel === 0 && localePreset.topDateFormat) {\n                    localePreset.middleDateFormat = localePreset.middleDateFormat || localePreset.topDateFormat;\n                }\n\n                preset.setData('displayDateFormat', localePreset.displayDateFormat || preset.originalDisplayDateFormat);\n\n                ['top', 'middle', 'bottom'].forEach(level => {\n                    const\n                        levelConfig           = preset.headerConfig[level],\n                        localeLevelDateFormat = localePreset[level + 'DateFormat'];\n\n                    if (levelConfig) {\n                        if (!levelConfig.originalDateFormat) {\n                            levelConfig.originalDateFormat = levelConfig.dateFormat;\n                        }\n\n                        // if there was defined topDateFormat on locale file for example, use it instead of renderer from basePresets (https://github.com/bryntum/support/issues/1307)\n                        if (localeLevelDateFormat && levelConfig.renderer) {\n                            levelConfig.renderer = null;\n                        }\n\n                        levelConfig.dateFormat = localeLevelDateFormat || levelConfig.originalDateFormat;\n\n                    }\n                });\n\n                // The preset names are used in ViewPresetCombo and are localized by default\n                if (localePreset.name) {\n                    if (!preset.unlocalizedName) {\n                        preset.unlocalizedName = preset.name;\n                    }\n                    preset.setData('name', localePreset.name);\n                }\n                else if (preset.unlocalizedName && preset.unlocalizedName !== preset.name) {\n                    preset.name = preset.unlocalizedName;\n                    preset.unlocalizedName = null;\n                }\n            }\n        });\n    }\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // Preset config on Scheduler/Gantt expects array of presets and not store config\n    getCurrentConfig(options) {\n        return super.getCurrentConfig(options).data;\n    }\n\n    copyBaseValues(presetData) {\n        let base = this.getById(presetData.base);\n\n        if (!base) {\n            throw new Error(`ViewPreset base '${presetData.base}' does not exist.`);\n        }\n        base = ObjectHelper.clone(base.data);\n        delete base.id;\n        delete base.name;\n\n        // Merge supplied data into a clone of the base ViewPreset's data\n        // so that the new one overrides the base.\n        return ObjectHelper.merge(base, presetData);\n    }\n\n    add(preset) {\n        preset = Array.isArray(preset) ? preset : [preset];\n\n        preset.forEach(preset => {\n            // If a ViewPreset instance that extends another preset was added\n            // Only in add we can apply the base data\n            if (preset.isViewPreset && preset.base) {\n                preset.data = this.copyBaseValues(preset.originalData);\n            }\n        });\n        return super.add(...arguments);\n    }\n}\n","import DateHelper from '../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport ViewPreset from './ViewPreset.js';\nimport PresetStore from './PresetStore.js';\n\n// No module tag here. That stops the singleton from being included by the docs.\n\n/**\n * ## Intro\n * This is a global Store of {@link Scheduler.preset.ViewPreset ViewPresets}, required to supply initial data to\n * Scheduler's {@link Scheduler.view.mixin.TimelineViewPresets#config-presets}.\n *\n * You can provide new view presets globally or for a specific scheduler.\n *\n * **NOTE:** You **cannot** modify existing records in the PresetManager store. You can either remove\n * preset records from the store or add new records to the store.\n * Also please keep in mind, all changes provided to the PresetManager store are not reflected to the\n * {@link Scheduler.view.mixin.TimelineViewPresets#config-presets} of schedulers that already exist!\n *\n * If you want to have just a few presets (also known as zoom levels) in your Scheduler, you can slice corresponding records\n * from the `PresetManager` and apply them to the Scheduler `presets` config.\n * ```javascript\n * const newPresets = PresetManager.records.slice(10, 12);\n *\n * const scheduler = new Scheduler({\n *     presets    : newPresets, // Only 2 zoom levels are available\n *     viewPreset : newPresets[0].id\n * });\n * ```\n *\n * If you want to adjust all default presets and assign to a specific scheduler you are going to create,\n * you can extend them and pass as an array to the Scheduler `presets` config.\n * Here is an example of how to set the same `timeResolution` to all `ViewPresets`.\n * ```javascript\n * const newPresets = PresetManager.map(preset => {\n *     return {\n *         id             : 'my_' + preset.id,\n *         base           : preset.id, // Based on an existing preset\n *         timeResolution : {\n *             unit      : 'day',\n *             increment : 1\n *         }\n *     };\n * });\n *\n * const scheduler = new Scheduler({\n *     presets     : newPresets,\n *     viewPreset : 'my_hourAndDay'\n * });\n * ```\n *\n * If you want to do the same for **all** schedulers which will be created next, you can register new presets in a loop.\n * ```javascript\n * PresetManager.records.forEach(preset => {\n *     // Pass the same ID, so when a new preset is added to the store,\n *     // it will replace the current one.\n *     PresetManager.registerPreset(preset.id, {\n *        id             : preset.id,\n *        base           : preset.id,\n *        timeResolution : {\n *            unit      : 'day',\n *            increment : 1\n *        }\n *    });\n * });\n * ```\n *\n * Here is an example of how to add a new `ViewPreset` to the global `PresetManager` store and to the already created\n * scheduler `presets`.\n * ```javascript\n * const scheduler = new Scheduler({...});\n *\n * const newGlobalPresets = PresetManager.add({\n *     id              : 'myNewPreset',\n *     base            : 'hourAndDay', // Based on an existing preset\n *     columnLinesFor  : 0,\n *     // Override headers\n *     headers : [\n *         {\n *             unit       : 'day',\n *             // Use different date format for top header 01.10.2020\n *             dateFormat : 'DD.MM.YYYY'\n *         },\n *         {\n *             unit       : 'hour',\n *             dateFormat : 'LT'\n *         }\n *     ]\n * });\n *\n * // Add new presets to the scheduler that has been created before changes\n * // to PresetManager are applied\n * scheduler.presets.add(newGlobalPresets);\n * ```\n *\n * ## Predefined presets\n *\n * Predefined presets are:\n *\n * - `secondAndMinute` - creates a 2 level header - minutes and seconds:\n * {@inlineexample Scheduler/preset/secondAndMinute.js}\n * - `minuteAndHour` - creates a 2 level header - hours and minutes:\n * {@inlineexample Scheduler/preset/minuteAndHour.js}\n * - `hourAndDay` - creates a 2 level header - days and hours:\n * {@inlineexample Scheduler/preset/hourAndDay.js}\n * - `dayAndWeek` - creates a 2 level header - weeks and days:\n * {@inlineexample Scheduler/preset/dayAndWeek.js}\n * - `dayAndMonth` - creates a 2 level header - months and days:\n * {@inlineexample Scheduler/preset/dayAndMonth.js}\n * - `weekAndDay` - just like `dayAndWeek` but with different formatting:\n * {@inlineexample Scheduler/preset/weekAndDay.js}\n * - `weekAndDayLetter` - creates a 2 level header - weeks and day letters:\n * {@inlineexample Scheduler/preset/weekAndDayLetter.js}\n * - `weekAndMonth` - creates a 2 level header - months and weeks:\n * {@inlineexample Scheduler/preset/weekAndMonth.js}\n * - `weekDateAndMonth` - creates a 2 level header - months and weeks (weeks shown by first day only):\n * {@inlineexample Scheduler/preset/weekDateAndMonth.js}\n * - `monthAndYear` - creates a 2 level header - years and months:\n * {@inlineexample Scheduler/preset/monthAndYear.js}\n * - `year` - creates a 2 level header - years and quarters:\n * {@inlineexample Scheduler/preset/year.js}\n * - `manyYears` - creates a 2 level header - 5-years and years:\n * {@inlineexample Scheduler/preset/manyYears.js}\n *\n * See the {@link Scheduler.preset.ViewPreset} and {@link Scheduler.preset.ViewPresetHeaderRow} classes for a\n * description of the view preset properties.\n *\n * ## Localizing View Presets\n * Bryntum Scheduler uses locales for translations including date formats for view presets.\n *\n * To translate date format for view presets just define the date format for the specified region\n * for your locale file, like this:\n * ```javascript\n * const locale = {\n *\n *     localeName : 'En',\n *\n *     // ... Other translations here ...\n *\n *     PresetManager : {\n *         // Translation for the \"weekAndDay\" ViewPreset\n *         weekAndDay : {\n *             // Change the date format for the top and middle levels\n *             topDateFormat    : 'MMM',\n *             middleDateFormat : 'D'\n *         },\n *         // Translation for the \"dayAndWeek\" ViewPreset\n *         dayAndWeek : {\n *             // Change the date format for the top level\n *             topDateFormat : 'MMMM YYYY'\n *         }\n *     }\n * }\n *\n * LocaleManager.applyLocale(locale);\n * ```\n *\n * Check the <a target=\"_blank\" href=\"../examples/localization/\">localization demo</a> and [this guide](#Scheduler/guides/customization/localization.md) for more details.\n *\n * @singleton\n * @extends Scheduler/preset/PresetStore\n */\nclass PresetManager extends PresetStore {\n\n    static get $name() {\n        return 'PresetManager';\n    }\n\n    static get defaultConfig() {\n        return {\n            // To not break CSP demo\n            preventSubClassingModel : true,\n\n            basePresets : {\n                // Do not remove. Assertion strings for Localization sanity check.\n                // 'L{secondAndMinute}'\n                // 'L{minuteAndHour}'\n                // 'L{hourAndDay}'\n                // 'L{dayAndWeek}'\n                // 'L{weekAndDay}'\n                // 'L{day}'\n                // 'L{week}'\n                // 'L{dayAndMonth}'\n                // 'L{weekAndMonth}'\n                // 'L{weekAndDayLetter}'\n                // 'L{weekDateAndMonth}'\n                // 'L{monthAndYear}'\n                // 'L{year}'\n                // 'L{manyYears}'\n                secondAndMinute : {\n                    name              : 'Seconds',\n                    tickWidth         : 30,   // Time column width\n                    tickHeight        : 40,\n                    displayDateFormat : 'll LTS', // Controls how dates will be displayed in tooltips etc\n                    shiftIncrement    : 10,     // Controls how much time to skip when calling shiftNext and shiftPrevious.\n                    shiftUnit         : 'minute', // Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n                    defaultSpan       : 24,    // By default, if no end date is supplied to a view it will show 24 hours\n                    timeResolution    : {      // Dates will be snapped to this resolution\n                        unit      : 'second',  // Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n                        increment : 5\n                    },\n                    // This defines your header rows.\n                    // For each row you can define \"unit\", \"increment\", \"dateFormat\", \"renderer\", \"align\", and \"thisObj\"\n                    headers : [\n                        {\n                            unit       : 'minute',\n                            dateFormat : 'llll'\n                        },\n                        {\n                            unit       : 'second',\n                            increment  : 10,\n                            dateFormat : 'ss'\n                        }\n                    ]\n                },\n                minuteAndHour : {\n                    name              : 'Minutes',\n                    tickWidth         : 60,    // Time column width\n                    tickHeight        : 60,\n                    displayDateFormat : 'll LT', // Controls how dates will be displayed in tooltips etc\n                    shiftIncrement    : 1,     // Controls how much time to skip when calling shiftNext and shiftPrevious.\n                    shiftUnit         : 'hour', // Valid values are \"MILLI\", \"SECOND\", \"minute\", \"HOUR\", \"DAY\", \"WEEK\", \"MONTH\", \"QUARTER\", \"YEAR\".\n                    defaultSpan       : 24,    // By default, if no end date is supplied to a view it will show 24 hours\n                    timeResolution    : {      // Dates will be snapped to this resolution\n                        unit      : 'minute',  // Valid values are \"MILLI\", \"SECOND\", \"minute\", \"HOUR\", \"DAY\", \"WEEK\", \"MONTH\", \"QUARTER\", \"YEAR\".\n                        increment : 30\n                    },\n                    headers : [\n                        {\n                            unit       : 'hour',\n                            dateFormat : 'ddd MM/DD, hA'\n                        },\n                        {\n                            unit       : 'minute',\n                            increment  : 30,\n                            dateFormat : 'mm'\n                        }\n                    ]\n                },\n                hourAndDay : {\n                    name              : 'Day',\n                    tickWidth         : 70,\n                    tickHeight        : 40,\n                    displayDateFormat : 'll LT',\n                    shiftIncrement    : 1,\n                    shiftUnit         : 'day',\n                    defaultSpan       : 24,\n                    timeResolution    : {\n                        unit      : 'minute',\n                        increment : 30\n                    },\n                    headers : [\n                        {\n                            unit       : 'day',\n                            dateFormat : 'ddd DD/MM' //Mon 01/10\n                        },\n                        {\n                            unit       : 'hour',\n                            dateFormat : 'LT'\n                        }\n                    ]\n                },\n                day : {\n                    name              : 'Day/hours',\n                    displayDateFormat : 'LT',\n                    shiftIncrement    : 1,\n                    shiftUnit         : 'day',\n                    defaultSpan       : 1,\n                    timeResolution    : {\n                        unit      : 'minute',\n                        increment : 30\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit       : 'day',\n                            dateFormat : 'ddd DD/MM', // Mon 01/02\n                            splitUnit  : 'day'\n                        },\n                        {\n                            unit : 'hour',\n                            renderer(value) {\n                                return `\n                                    <div class=\"b-sch-calendarcolumn-ct\"><span class=\"b-sch-calendarcolumn-hours\">${DateHelper.format(value, 'HH')}</span>\n                                    <span class=\"b-sch-calendarcolumn-minutes\">${DateHelper.format(value, 'mm')}</span></div>\n                                `;\n                            }\n                        }\n                    ]\n                },\n                week : {\n                    name              : 'Week/hours',\n                    displayDateFormat : 'LT',\n                    shiftIncrement    : 1,\n                    shiftUnit         : 'week',\n                    defaultSpan       : 24,\n                    timeResolution    : {\n                        unit      : 'minute',\n                        increment : 30\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit       : 'week',\n                            dateFormat : 'D d',\n                            splitUnit  : 'day'\n                        },\n                        {\n                            unit       : 'hour',\n                            dateFormat : 'LT',    // will be overridden by renderer\n                            renderer(value) {\n                                return `\n                                    <div class=\"sch-calendarcolumn-ct\">\n                                    <span class=\"sch-calendarcolumn-hours\">${DateHelper.format(value, 'HH')}</span>\n                                    <span class=\"sch-calendarcolumn-minutes\">${DateHelper.format(value, 'mm')}</span>\n                                    </div>\n                                `;\n                            }\n                        }\n                    ]\n                },\n                dayAndWeek : {\n                    name              : 'Days & Weeks',\n                    tickWidth         : 100,\n                    tickHeight        : 80,\n                    displayDateFormat : 'll LT',\n                    shiftUnit         : 'day',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 5,\n                    timeResolution    : {\n                        unit      : 'hour',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit : 'week',\n                            renderer(start) {\n                                return DateHelper.getShortNameOfUnit('week') + '.' + DateHelper.format(start, 'WW MMM YYYY');\n                            }\n                        },\n                        {\n                            unit       : 'day',\n                            dateFormat : 'dd DD'\n                        }\n                    ]\n                },\n                // dayAndMonth : {\n                //     name              : 'Days & Months',\n                //     tickWidth         : 100,\n                //     tickHeight        : 80,\n                //     displayDateFormat : 'll LT',\n                //     shiftUnit         : 'day',\n                //     shiftIncrement    : 1,\n                //     defaultSpan       : 5,\n                //     timeResolution    : {\n                //         unit      : 'hour',\n                //         increment : 1\n                //     },\n                //     headers : [\n                //         {\n                //             unit       : 'month',\n                //             dateFormat : 'MMMM YYYY',\n                //             align      : 'start'\n                //         },\n                //         {\n                //             unit       : 'day',\n                //             dateFormat : 'dd DD'\n                //         }\n                //     ]\n                // },\n                dayAndMonth : {\n                    name              : 'Month',\n                    tickWidth         : 100,\n                    tickHeight        : 80,\n                    displayDateFormat : 'll LT',\n                    shiftUnit         : 'month',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 1,\n                    mainUnit          : 'month',\n                    timeResolution    : {\n                        unit      : 'hour',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'month',\n                            dateFormat : 'MMMM YYYY'\n                        },\n                        {\n                            unit       : 'day',\n                            dateFormat : 'DD'\n                        }\n                    ]\n                },\n                weekAndDay : {\n                    name              : 'Week',\n                    tickWidth         : 100,\n                    tickHeight        : 80,\n                    displayDateFormat : 'll hh:mm A',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 1,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit       : 'week',\n                            dateFormat : 'YYYY MMMM DD' // 2017 January 01\n                        },\n                        {\n                            unit       : 'day',\n                            increment  : 1,\n                            dateFormat : 'DD MMM'\n                        }\n                    ]\n                },\n                weekAndMonth : {\n                    name              : 'Weeks',\n                    tickWidth         : 100,\n                    tickHeight        : 105,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 5,\n                    defaultSpan       : 6,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'month',\n                            dateFormat : 'MMM YYYY' //Jan 2017\n                        },\n                        {\n                            unit       : 'week',\n                            dateFormat : 'DD MMM'\n                        }\n                    ]\n                },\n                weekAndDayLetter : {\n                    name              : 'Weeks/weekdays',\n                    tickWidth         : 20,\n                    tickHeight        : 50,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 10,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit                : 'week',\n                            dateFormat          : 'ddd DD MMM YYYY',\n                            verticalColumnWidth : 115\n                        },\n                        {\n                            unit                : 'day',\n                            dateFormat          : 'd1',\n                            verticalColumnWidth : 25\n                        }\n                    ]\n                },\n                weekDateAndMonth : {\n                    name              : 'Months/weeks',\n                    tickWidth         : 30,\n                    tickHeight        : 40,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 10,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'month',\n                            dateFormat : 'YYYY MMMM'\n                        },\n                        {\n                            unit       : 'week',\n                            dateFormat : 'DD'\n                        }\n                    ]\n                },\n                monthAndYear : {\n                    name              : 'Months',\n                    tickWidth         : 110,\n                    tickHeight        : 110,\n                    displayDateFormat : 'll',\n                    shiftIncrement    : 3,\n                    shiftUnit         : 'month',\n                    defaultSpan       : 12,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'year',\n                            dateFormat : 'YYYY' //2017\n                        },\n                        {\n                            unit       : 'month',\n                            dateFormat : 'MMM YYYY' //Jan 2017\n                        }\n                    ]\n                },\n                year : {\n                    name                : 'Years',\n                    tickWidth           : 100,\n                    tickHeight          : 100,\n                    resourceColumnWidth : 100,\n                    displayDateFormat   : 'll',\n                    shiftUnit           : 'year',\n                    shiftIncrement      : 1,\n                    defaultSpan         : 1,\n                    timeResolution      : {\n                        unit      : 'month',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'year',\n                            dateFormat : 'YYYY'\n                        },\n                        {\n                            unit : 'quarter',\n                            renderer(start, end, cfg) {\n                                return DateHelper.getShortNameOfUnit('quarter').toUpperCase() + (Math.floor(start.getMonth() / 3) + 1);\n                            }\n                        }\n                    ]\n                },\n                manyYears : {\n                    name              : 'Multiple years',\n                    tickWidth         : 40,\n                    tickHeight        : 50,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'year',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 10,\n                    timeResolution    : {\n                        unit      : 'year',\n                        increment : 1\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit      : 'year',\n                            increment : 5,\n                            renderer  : (start, end) => start.getFullYear() + ' - ' + end.getFullYear()\n                        },\n                        {\n                            unit       : 'year',\n                            dateFormat : 'YY',\n                            increment  : 1\n                        }\n                    ]\n                }\n            },\n\n            // This is a list of bryntum-supplied preset adjustments used to create the Scheduler's\n            // default initial set of ViewPresets.\n            defaultPresets : [\n                // Years over years\n                'manyYears',\n                { width : 80, increment : 1, resolution : 1, base : 'manyYears', resolutionUnit : 'YEAR' },\n\n                // Years over quarters\n                'year',\n                { width : 30,  increment : 1, resolution : 1, base : 'year', resolutionUnit : 'MONTH' },\n                { width : 50,  increment : 1, resolution : 1, base : 'year', resolutionUnit : 'MONTH' },\n                { width : 200, increment : 1, resolution : 1, base : 'year', resolutionUnit : 'MONTH' },\n\n                // Years over months\n                'monthAndYear',\n\n                // Months over weeks\n                'weekDateAndMonth',\n\n                // Months over weeks\n                'weekAndMonth',\n\n                // Months over weeks\n                'weekAndDayLetter',\n\n                // Months over days\n                'dayAndMonth',\n\n                // Weeks over days\n                'weekAndDay',\n                { width : 54, increment : 1, resolution : 1, base : 'weekAndDay', resolutionUnit : 'HOUR' },\n\n                // Days over hours\n                'hourAndDay',\n                { width : 64,  increment : 6, resolution : 30, base : 'hourAndDay', resolutionUnit : 'MINUTE' },\n                { width : 100, increment : 6, resolution : 30, base : 'hourAndDay', resolutionUnit : 'MINUTE' },\n                { width : 64,  increment : 2, resolution : 30, base : 'hourAndDay', resolutionUnit : 'MINUTE' },\n\n                // Hours over minutes\n                'minuteAndHour',\n                { width : 30,  increment : 15, resolution : 5, base : 'minuteAndHour' },\n                { width : 130, increment : 15, resolution : 5, base : 'minuteAndHour' },\n                { width : 60,  increment : 5,  resolution : 5, base : 'minuteAndHour' },\n                { width : 100, increment : 5,  resolution : 5, base : 'minuteAndHour' },\n\n                // Minutes over seconds\n                'secondAndMinute',\n                { width : 60,  increment : 10, resolution : 5, base : 'secondAndMinute' },\n                { width : 130, increment : 5,  resolution : 5, base : 'secondAndMinute' }\n            ],\n\n            internalListeners : {\n                locale : 'updateLocalization'\n            }\n        };\n    }\n\n    set basePresets(basePresets) {\n        const presetCache = this._basePresets = {};\n\n        for (const id in basePresets) {\n            basePresets[id].id = id;\n            presetCache[id] = this.createRecord(basePresets[id]);\n        }\n    }\n\n    get basePresets() {\n        return this._basePresets;\n    }\n\n    set defaultPresets(defaultPresets) {\n        for (let i = 0, { length } = defaultPresets; i < length; i++) {\n            const\n                presetAdjustment   = defaultPresets[i],\n                isBase             = typeof presetAdjustment === 'string',\n                baseType           = isBase ? presetAdjustment : presetAdjustment.base;\n\n            let preset;\n\n            // The default was just a string, so it's an unmodified instance of a base type.\n            if (isBase) {\n                preset = this.basePresets[baseType];\n            }\n            // If it's an object, it's an adjustment to a base type\n            else {\n                const\n                    config             = Object.setPrototypeOf(ObjectHelper.clone(this.basePresets[baseType].data), { id : baseType }),\n                    { timeResolution } = config,\n                    bottomHeader       = config.headers[config.headers.length - 1];\n\n                config.id = undefined;\n\n                if ('width' in presetAdjustment) {\n                    config.tickWidth = presetAdjustment.width;\n                }\n                if ('height' in presetAdjustment) {\n                    config.tickHeight = presetAdjustment.height;\n                }\n                if ('increment' in presetAdjustment) {\n                    bottomHeader.increment = presetAdjustment.increment;\n                }\n                if ('resolution' in presetAdjustment) {\n                    timeResolution.increment = presetAdjustment.resolution;\n                }\n                if ('resolutionUnit' in presetAdjustment) {\n                    timeResolution.unit = DateHelper.getUnitByName(presetAdjustment.resolutionUnit);\n                }\n\n                preset = this.createRecord(config);\n\n                // Keep id of original preset around, used with localization in PresetStore\n                preset.baseId = baseType;\n            }\n            this.add(preset);\n        }\n    }\n\n    getById(id) {\n        // Look first in the default set, and if it's one of the base types that is not imported into the\n        // default set, then look at the bases.\n        return super.getById(id) || this.basePresets[id];\n    }\n\n    /**\n     * Registers a new view preset base to be used by any scheduler grid or tree on the page.\n     * @param {String} id The unique identifier for this preset\n     * @param {ViewPresetConfig} config The configuration properties of the view preset (see\n     * {@link Scheduler.preset.ViewPreset} for more information)\n     * @returns {Scheduler.preset.ViewPreset} A new ViewPreset based upon the passed configuration.\n     */\n    registerPreset(id, config) {\n        const\n            preset = this.createRecord(Object.assign({\n                id\n            }, config)),\n            existingDuplicate = this.find(p => p.equals(preset));\n\n        if (existingDuplicate) {\n            return existingDuplicate;\n        }\n\n        if (preset.isValid) {\n            this.add(preset);\n        }\n        else {\n            throw new Error('Invalid preset, please check your configuration');\n        }\n\n        return preset;\n    }\n\n    getPreset(preset) {\n        if (typeof preset === 'number') {\n            preset = this.getAt(preset);\n        }\n        if (typeof preset === 'string') {\n            preset = this.getById(preset);\n        }\n        else if (!(preset instanceof ViewPreset)) {\n            preset = this.createRecord(preset);\n        }\n        return preset;\n    }\n\n    /**\n     * Applies preset customizations or fetches a preset view preset using its name.\n     * @param {String|ViewPresetConfig} presetOrId Id of a predefined preset or a preset config object\n     * @returns {Scheduler.preset.ViewPreset} Resulting ViewPreset instance\n     */\n    normalizePreset(preset) {\n        const me = this;\n\n        if (!(preset instanceof ViewPreset)) {\n            if (typeof preset === 'string') {\n                preset = me.getPreset(preset);\n                if (!preset) {\n                    throw new Error('You must define a valid view preset. See PresetManager for reference');\n                }\n            }\n            else if (typeof preset === 'object') {\n                // Look up any existing ViewPreset that it is based upon.\n                if (preset.base) {\n                    const base = this.getById(preset.base);\n\n                    if (!base) {\n                        throw new Error(`ViewPreset base '${preset.base}' does not exist`);\n                    }\n                    // The config is based upon the base's data with the new config object merged in.\n                    preset = ObjectHelper.merge(ObjectHelper.clone(base.data), preset);\n                }\n\n                // Ensure the new ViewPreset has a legible, logical id which does not already\n                // exist in our store.\n                if (preset.id) {\n                    preset = me.createRecord(preset);\n                }\n                else {\n                    preset = me.createRecord(ObjectHelper.assign({}, preset));\n                    preset.id = preset.generateId(preset);\n                }\n            }\n        }\n\n        return preset;\n    }\n\n    /**\n     * Deletes a view preset\n     * @param {String} id The id of the preset, or the preset instance.\n     */\n    deletePreset(presetOrId) {\n        if (typeof presetOrId === 'string') {\n            presetOrId = this.getById(presetOrId);\n        }\n        else if (typeof presetOrId === 'number') {\n            presetOrId = this.getAt(presetOrId);\n        }\n\n        if (presetOrId) {\n            this.remove(presetOrId);\n\n            // ALso remove it from our base list\n            delete this.basePresets[presetOrId.id];\n        }\n    }\n}\n\nconst pm = new PresetManager();\n\nexport { pm as default };\n","import Store from '../../Core/data/Store.js';\nimport DH from '../../Core/helper/DateHelper.js';\nimport TimeSpan from '../model/TimeSpan.js';\nimport ViewPreset from '../preset/ViewPreset.js';\nimport PresetManager from '../preset/PresetManager.js';\n\n/**\n * @module Scheduler/data/TimeAxis\n */\n\n// Micro-optimized version of TimeSpan for faster reading. Hit a lot and since it is internal fields are guaranteed to\n// not be remapped and changes wont be batches, so we can always return raw value from data avoiding all additional\n// checks and logic\nclass Tick extends TimeSpan {\n    // Only getters on purpose, we do not support manipulating ticks\n\n    get startDate() {\n        return this.data.startDate;\n    }\n\n    get endDate() {\n        return this.data.endDate;\n    }\n}\n\n/**\n * A class representing the time axis of the scheduler. The scheduler timescale is based on the ticks generated by this class.\n * This is a pure \"data\" (model) representation of the time axis and has no UI elements.\n *\n * The time axis can be {@link #config-continuous} or not. In continuous mode, each timespan starts where the previous ended, and in non-continuous mode\n * there can be gaps between the ticks.\n * A non-continuous time axis can be used when want to filter out certain periods of time (like weekends) from the time axis.\n *\n * To create a non-continuous time axis you have 2 options. First, you can create a time axis containing only the time spans of interest.\n * To do that, subclass this class and override the {@link #property-generateTicks} method.\n *\n * The other alternative is to call the {@link #function-filterBy} method, passing a function to it which should return `false` if the time tick should be filtered out.\n * Calling {@link Core.data.mixin.StoreFilter#function-clearFilters} will return you to a full time axis.\n *\n * @extends Core/data/Store\n */\nexport default class TimeAxis extends Store {\n    //region Events\n\n    /**\n     * Fires before the timeaxis is about to be reconfigured (e.g. new start/end date or unit/increment). Return false to abort the operation.\n     * @event beforeReconfigure\n     * @param {Scheduler.data.TimeAxis} source The time axis instance\n     * @param {Date} startDate The new time axis start date\n     * @param {Date} endDate The new time axis end date\n     */\n\n    /**\n     * Event that is triggered when we end reconfiguring and everything UI-related should be done\n     * @event endReconfigure\n     * @private\n     */\n\n    /**\n     * Fires when the timeaxis has been reconfigured (e.g. new start/end date or unit/increment)\n     * @event reconfigure\n     * @param {Scheduler.data.TimeAxis} source The time axis instance\n     */\n\n    /**\n     * Fires if all the ticks in the timeaxis are filtered out. After firing the filter is cleared to return the time\n     * axis to a valid state.\n     * @event invalidFilter\n     * @param {Scheduler.data.TimeAxis} source The time axis instance\n     */\n\n    //endregion\n\n    //region Default config\n\n    static get defaultConfig() {\n        return {\n            modelClass : Tick,\n\n            /**\n             * Set to false if the timeline is not continuous, e.g. the next timespan does not start where the previous ended (for example skipping weekends etc).\n             * @config {Boolean}\n             * @default\n             */\n            continuous : true,\n\n            originalContinuous : null,\n\n            /**\n             * Include only certain hours or days in the time axis (makes it `continuous : false`). Accepts and object\n             * with `day` and `hour` properties:\n             * ```\n             * const scheduler = new Scheduler({\n             *     timeAxis : {\n             *         include : {\n             *              // Do not display hours after 17 or before 9 (only display 9 - 17). The `to value is not\n             *              // included in the time axis\n             *              hour : {\n             *                  from : 9,\n             *                  to   : 17\n             *              },\n             *              // Do not display sunday or saturday\n             *              day : [0, 6]\n             *         }\n             *     }\n             * }\n             * ```\n             * In most cases we recommend that you use Scheduler's workingTime config instead. It is easier to use and\n             * makes sure all parts of the Scheduler gets updated.\n             * @config {Object}\n             */\n            include : null,\n\n            /**\n             * Automatically adjust the timespan when generating ticks with {@link #property-generateTicks} according to\n             * the `viewPreset` configuration. Setting this to false may lead to shifting time/date of ticks.\n             * @config {Boolean}\n             * @default\n             */\n            autoAdjust : true,\n\n            //isConfigured : false,\n\n            // in case of `autoAdjust : false`, the 1st and last ticks can be truncated, containing only part of the normal tick\n            // these dates will contain adjusted start/end (like if the tick has not been truncated)\n            adjustedStart    : null,\n            adjustedEnd      : null,\n            // the visible position in the first tick, can actually be > 1 because the adjustment is done by the `mainUnit`\n            visibleTickStart : null,\n            // the visible position in the first tick, is always ticks count - 1 < value <= ticks count, in case of autoAdjust, always = ticks count\n            visibleTickEnd   : null,\n\n            tickCache : {},\n\n            viewPreset : null,\n\n            useRawData : {\n                disableDuplicateIdCheck : true,\n                disableDefaultValue     : true,\n                disableTypeConversion   : true\n            }\n        };\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Method generating the ticks for this time axis. Should return an array of ticks. Each tick is an object of the following structure:\n             * ```\n             * {\n             *    startDate : ..., // start date\n             *    endDate   : ...  // end date\n             * }\n             * ```\n             * Take notice, that this function either has to be called with `start`/`end` parameters, or create those variables.\n             *\n             * To see it in action please check out our [TimeAxis](https://bryntum.com/products/scheduler/examples/timeaxis/) example and navigate to \"Compressed non-working time\" tab.\n             *\n             * @param {Date} axisStartDate The start date of the interval\n             * @param {Date} axisEndDate The end date of the interval\n             * @param {String} unit The unit of the time axis\n             * @param {Number} increment The increment for the unit specified.\n             * @returns {Array} ticks The ticks representing the time axis\n             * @config {Function}\n             */\n            generateTicks : null,\n\n            unit                : null,\n            increment           : null,\n            resolutionUnit      : null,\n            resolutionIncrement : null,\n            mainUnit            : null,\n            shiftUnit           : null,\n            shiftIncrement      : 1,\n            defaultSpan         : 1,\n\n            weekStartDay : null,\n\n            // Used to force resolution to match whole ticks, to snap accordingly when using fillTicks in the UI\n            forceFullTicks : null\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    // private\n    construct(config) {\n        const me = this;\n\n        super.construct(config);\n\n        me.originalContinuous = me.continuous;\n\n        me.ion({\n            change : ({ action }) => {\n                // If the change was due to filtering, there will be a refresh event\n                // arriving next, so do not reconfigure\n                if (action !== 'filter') {\n                    me.trigger('reconfigure', { supressRefresh : false });\n                }\n            },\n            refresh        : () => me.trigger('reconfigure', { supressRefresh : false }),\n            endreconfigure : event => me.trigger('reconfigure', event)\n        });\n\n        if (me.startDate) {\n            me.internalOnReconfigure();\n            me.trigger('reconfigure');\n        }\n        else if (me.viewPreset) {\n            const range = me.getAdjustedDates(new Date());\n            me.startDate = range.startDate;\n            me.endDate = range.endDate;\n        }\n    }\n\n    get isTimeAxis() {\n        return true;\n    }\n\n    //endregion\n\n    //region Configuration (reconfigure & consumePreset)\n\n    /**\n     * Reconfigures the time axis based on the config object supplied and generates the new 'ticks'.\n     * @param {Object} config\n     * @param {Boolean} [suppressRefresh]\n     * @private\n     */\n    reconfigure(config, suppressRefresh = false, preventThrow = false) {\n        const\n            me         = this,\n            normalized = me.getAdjustedDates(config.startDate, config.endDate),\n            oldConfig  = {};\n\n        if (me.trigger('beforeReconfigure', { startDate : normalized.startDate, endDate : normalized.endDate, config }) !== false) {\n            me.trigger('beginReconfigure');\n\n            me._configuredStartDate = config.startDate;\n            me._configuredEndDate = config.endDate;\n\n            // Collect old values for end event\n            for (const propName in config) {\n                oldConfig[propName] = me[propName];\n            }\n\n            Object.assign(me, config);\n\n            if (me.internalOnReconfigure(preventThrow) === false) {\n                return false;\n            }\n\n            me.trigger('endReconfigure', { suppressRefresh, config, oldConfig });\n        }\n    }\n\n    internalOnReconfigure(preventThrow = false) {\n        const me = this;\n\n        me.isConfigured = true;\n\n        const\n            adjusted = me.getAdjustedDates(me.startDate, me.endDate, true),\n            normalized = me.getAdjustedDates(me.startDate, me.endDate),\n            start      = normalized.startDate,\n            end        = normalized.endDate;\n\n        if (start >= end) {\n            throw new Error(`Invalid start/end dates. Start date must less than end date. Start date: ${start}. End date: ${end}.`);\n        }\n\n        const\n            { unit, increment = 1 } = me,\n            ticks                   = me.generateTicks(start, end, unit, increment);\n\n        // Suspending to be able to detect an invalid filter\n        me.suspendEvents();\n        me.data = ticks;\n\n        const { count } = me;\n\n        if (count === 0) {\n            if (preventThrow) {\n                me.resumeEvents();\n                return false;\n            }\n            throw new Error('Invalid time axis configuration or filter, please check your input data.');\n        }\n\n        // start date is cached, update it to fill after generated ticks\n        me.startDate = me.first.startDate;\n        me.endDate = me.last.endDate;\n\n        me.resumeEvents();\n\n        if (me.isContinuous) {\n            me.adjustedStart = adjusted.startDate;\n            me.adjustedEnd = DH.getNext(count > 1 ? ticks[count - 1].startDate : adjusted.startDate, unit, increment, me.weekStartDay);\n        }\n        else {\n            me.adjustedStart = me.startDate;\n            me.adjustedEnd = me.endDate;\n        }\n\n        me.updateVisibleTickBoundaries();\n\n        me.updateTickCache(true);\n    }\n\n    updateVisibleTickBoundaries() {\n        const\n            me = this,\n            {\n                count,\n                unit,\n                startDate,\n                endDate,\n                weekStartDay,\n                increment = 1\n            }  = me;\n\n        // Denominator is amount of milliseconds in a full tick (unit * increment). Normally we use 30 days in a month\n        // and 365 days in a year. But if month is 31 day long or year is a leap one standard formula might calculate\n        // wrong value. e.g. if we're rendering 1 day from August, formula goes like (2021-08-31 - 2021-08-02) / 30 = 1\n        // and renders full tick which is incorrect. For such cases we need to adjust denominator to a correct one.\n        // Thankfully there are only a few of them - month, year and day with DST transition.\n        const\n            startDenominator = DH.getNormalizedUnitDuration(startDate, unit) * increment,\n            endDenominator   = DH.getNormalizedUnitDuration(endDate, unit) * increment;\n\n        // if visibleTickStart > 1 this means some tick is fully outside of the view - we are not interested in it and want to\n        // drop it and adjust \"adjustedStart\" accordingly\n        do {\n            me.visibleTickStart = (startDate - me.adjustedStart) / startDenominator;\n\n            // TODO: Changed from round to floor which seems to work, but this is not needed in ExtScheduler. Need to step and see what is different\n            if (me.autoAdjust) me.visibleTickStart = Math.floor(me.visibleTickStart);\n\n            if (me.visibleTickStart >= 1) me.adjustedStart = DH.getNext(me.adjustedStart, unit, increment, weekStartDay);\n        } while (me.visibleTickStart >= 1);\n\n        do {\n            me.visibleTickEnd = count - (me.adjustedEnd - endDate) / endDenominator;\n\n            if (count - me.visibleTickEnd >= 1) me.adjustedEnd = DH.getNext(me.adjustedEnd, unit, -1, weekStartDay);\n        } while (count - me.visibleTickEnd >= 1);\n\n        // This flag indicates that the time axis starts exactly on a tick boundary and finishes on a tick boundary\n        // This is used as an optimization flag by TimeAxisViewModel.createHeaderRow\n        me.fullTicks = !me.visibleTickStart && me.visibleTickEnd === count;\n    }\n\n    /**\n     * Get/set currently used preset\n     * @property {Scheduler.preset.ViewPreset}\n     */\n    get viewPreset() {\n        return this._viewPreset;\n    }\n\n    set viewPreset(preset) {\n        const me = this;\n\n        preset = PresetManager.getPreset(preset);\n\n        if (!(preset instanceof ViewPreset)) {\n            throw new Error('TimeAxis must be configured with the ViewPreset instance that the Scheduler is using');\n        }\n\n        me._viewPreset = preset;\n\n        Object.assign(me, {\n            unit      : preset.bottomHeader.unit,\n            increment : preset.bottomHeader.increment || 1,\n\n            resolutionUnit      : preset.timeResolution.unit,\n            resolutionIncrement : preset.timeResolution.increment,\n\n            mainUnit       : preset.mainHeader.unit,\n            shiftUnit      : preset.shiftUnit || preset.mainHeader.unit,\n            shiftIncrement : preset.shiftIncrement || 1,\n\n            defaultSpan : preset.defaultSpan || 1,\n            presetName  : preset.id,\n\n            // Weekview columns are updated upon 'datachanged' event on this object.\n            // We have to pass headers in order to render them correctly (timeAxisViewModel is incorrect in required time)\n            headers : preset.headers\n        });\n    }\n\n    //endregion\n\n    //region Getters & setters\n\n    get weekStartDay() {\n        return this._weekStartDay ?? DH.weekStartDay;\n    }\n\n    // private\n    get resolution() {\n        return {\n            unit      : this.resolutionUnit,\n            increment : this.resolutionIncrement\n        };\n    }\n\n    // private\n    set resolution(resolution) {\n        this.resolutionUnit = resolution.unit;\n        this.resolutionIncrement = resolution.increment;\n    }\n\n    get resolutionUnit() {\n        return this.forceFullTicks ? this.unit : this._resolutionUnit;\n    }\n\n    get resolutionIncrement() {\n        return this.forceFullTicks ? this.increment : this._resolutionIncrement;\n    }\n\n    //endregion\n\n    //region Timespan & resolution\n\n    /**\n     * Changes the time axis timespan to the supplied start and end dates.\n     *\n     * **Note** This does **not** preserve the temporal scroll position. You may use\n     * {@link Scheduler.view.Scheduler#function-setTimeSpan} to set the time axis and\n     * maintain temporal scroll position (if possible).\n     * @param {Date} newStartDate The new start date\n     * @param {Date} newEndDate The new end date\n     */\n    setTimeSpan(newStartDate, newEndDate, preventThrow = false) {\n        // If providing a 0 span range, add default range\n        if (newEndDate && newStartDate - newEndDate === 0) {\n            newEndDate = null;\n        }\n\n        const\n            me                    = this,\n            { startDate, endDate } = me.getAdjustedDates(newStartDate, newEndDate);\n\n        if (me.startDate - startDate !== 0 || me.endDate - endDate !== 0) {\n            return me.reconfigure({\n                startDate,\n                endDate\n            }, false, preventThrow);\n        }\n    }\n\n    /**\n     * Moves the time axis by the passed amount and unit.\n     *\n     * NOTE: When using a filtered TimeAxis the result of `shift()` cannot be guaranteed, it might shift into a\n     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.\n     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly\n     * instead.\n     *\n     * @param {Number} amount The number of units to jump\n     * @param {String} [unit] The unit (Day, Week etc)\n     */\n    shift(amount, unit = this.shiftUnit) {\n        const me = this;\n\n        let { startDate, endDate } = me;\n\n        // Use unfiltered start and end dates when shifting a filtered time axis, to lessen risk of messing it up.\n        // Still not guaranteed to work though\n        if (me.isFiltered) {\n            startDate = me.allRecords[0].startDate;\n            endDate = me.allRecords[me.allCount - 1].endDate;\n        }\n\n        // Hack for filtered time axis, for example if weekend is filtered out and you shiftPrev() day from monday\n        let tries = 0;\n        do {\n            startDate = DH.add(startDate, amount, unit);\n            endDate = DH.add(endDate, amount, unit);\n        } while (tries++ < 100 && me.setTimeSpan(startDate, endDate, {\n            preventThrow : true\n        }) === false);\n    }\n\n    /**\n     * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement`\n     * config of the current view preset.\n     *\n     * NOTE: When using a filtered TimeAxis the result of `shiftNext()` cannot be guaranteed, it might shift into a\n     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.\n     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly\n     * instead.\n     *\n     * @param {Number} [amount] The number of units to jump forward\n     */\n    shiftNext(amount = this.shiftIncrement) {\n        this.shift(amount);\n    }\n\n    /**\n     * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.\n     *\n     * NOTE: When using a filtered TimeAxis the result of `shiftPrev()` cannot be guaranteed, it might shift into a\n     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.\n     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly\n     * instead.\n     *\n     * @param {Number} [amount] The number of units to jump backward\n     */\n    shiftPrevious(amount = this.shiftIncrement) {\n        this.shift(-amount);\n    }\n\n    //endregion\n\n    //region Filter & continuous\n\n    /**\n     * Filter the time axis by a function. The passed function will be called with each tick in time axis.\n     * If the function returns `true`, the 'tick' is included otherwise it is filtered. If all ticks are filtered out\n     * the time axis is considered invalid, triggering `invalidFilter` and then removing the filter.\n     * @param {Function} fn The function to be called, it will receive an object with `startDate`/`endDate` properties, and `index` of the tick.\n     * @param {Object} [thisObj] `this` reference for the function\n     * @typings {Promise<any|null>}\n     */\n    filterBy(fn, thisObj = this) {\n        const me = this;\n\n        me.filters.clear();\n\n        super.filterBy((tick, index) => fn.call(thisObj, tick.data, index));\n\n        if (me.count === 0) {\n            me.trigger('invalidFilter');\n            me.clearFilters();\n        }\n    }\n\n    triggerFilterEvent(event) {\n        const me = this;\n\n        if (!event.filters.count) {\n            me.continuous = me.originalContinuous;\n        }\n        else {\n            me.continuous = false;\n        }\n\n        // Filters has been applied (or cleared) but listeners are not informed yet, update tick cache to have start and\n        // end dates correct when later redrawing events & header\n        me.updateTickCache();\n\n        super.triggerFilterEvent(event);\n    }\n\n    /**\n     * Returns `true` if the time axis is continuous (will return `false` when filtered)\n     * @property {Boolean}\n     */\n    get isContinuous() {\n        return this.continuous !== false && !this.isFiltered;\n    }\n\n    //endregion\n\n    //region Dates\n\n    getAdjustedDates(startDate, endDate, forceAdjust = false) {\n        const me = this;\n\n        // If providing a 0 span range, add default range\n        if (endDate && startDate - endDate === 0) {\n            endDate = null;\n        }\n\n        startDate = startDate || me.startDate;\n        endDate = endDate || DH.add(startDate, me.defaultSpan, me.mainUnit);\n\n        return me.autoAdjust || forceAdjust ? {\n            startDate : me.floorDate(startDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1),\n            endDate   : me.ceilDate(endDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1)\n        } : {\n            startDate : startDate,\n            endDate   : endDate\n        };\n    }\n\n    /**\n     * Method to get the current start date of the time axis.\n     * @property {Date}\n     */\n    get startDate() {\n        // TODO: added _start as caching, might mess something up when reconfiguring? change here if tests fail\n        return this._start || (this.first ? new Date(this.first.startDate) : null);\n    }\n\n    set startDate(start) {\n        this._start = DH.parse(start);\n    }\n\n    /**\n     * Method to get a the current end date of the time axis\n     * @property {Date}\n     */\n    get endDate() {\n        return this._end || (this.last ? new Date(this.last.endDate) : null);\n    }\n\n    set endDate(end) {\n        if (end) this._end = DH.parse(end);\n    }\n\n    // used in performance critical code for comparisons\n    get startMS() {\n        return this._startMS;\n    }\n\n    // used in performance critical code for comparisons\n    get endMS() {\n        return this._endMS;\n    }\n\n    // Floors a date and optionally snaps it to one of the following resolutions:\n    // 1. 'resolutionUnit'. If param 'resolutionUnit' is passed, the date will simply be floored to this unit.\n    // 2. If resolutionUnit is not passed: If date should be snapped relative to the timeaxis start date,\n    // the resolutionUnit of the timeAxis will be used, or the timeAxis 'mainUnit' will be used to snap the date\n    //\n    // returns a copy of the original date\n    // private\n    floorDate(date, relativeToStart, resolutionUnit, incr) {\n        relativeToStart = relativeToStart !== false;\n\n        const\n            me         = this,\n            relativeTo = relativeToStart ? DH.clone(me.startDate) : null,\n            increment  = incr || me.resolutionIncrement,\n            unit       = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit),\n            snap       = (value, increment) => Math.floor(value / increment) * increment;\n\n        if (relativeToStart) {\n            const snappedDuration = snap(DH.diff(relativeTo, date, unit), increment);\n            // TODO: used to be small unit multiplied with factor (minute = seconds, minutes * 60)\n            return DH.add(relativeTo, snappedDuration, unit, false);\n        }\n\n        const dt = DH.clone(date);\n\n        if (unit === 'week') {\n            const\n                day      = dt.getDay() || 7,\n                startDay = me.weekStartDay || 7;\n\n            DH.add(DH.startOf(dt, 'day', false), day >= startDay ? startDay - day : -(7 - startDay + day), 'day', false);\n\n            // Watch out for Brazil DST craziness (see test 028_timeaxis_dst.t.js)\n            if (dt.getDay() !== startDay && dt.getHours() === 23) {\n                DH.add(dt, 1, 'hour', false);\n            }\n        }\n        else {\n            // removes \"smaller\" units from date (for example minutes; removes seconds and milliseconds)\n            DH.startOf(dt, unit, false);\n\n            // day and year are 1-based so need to make additional adjustments\n            const\n                modifier     = ['day', 'year'].includes(unit) ? 1 : 0,\n                useUnit      = unit === 'day' ? 'date' : unit,\n                snappedValue = snap(DH.get(dt, useUnit) - modifier, increment) + modifier;\n\n            DH.set(dt, useUnit, snappedValue);\n        }\n\n        return dt;\n    }\n\n    /**\n     * Rounds the date to nearest unit increment\n     * @private\n     */\n    roundDate(date, relativeTo, resolutionUnit = this.resolutionUnit, increment = this.resolutionIncrement || 1) {\n        const\n            me = this,\n            dt = DH.clone(date);\n\n        relativeTo = DH.clone(relativeTo || me.startDate);\n\n        switch (resolutionUnit) {\n            case 'week': {\n                DH.startOf(dt, 'day', false);\n\n                let distanceToWeekStartDay = dt.getDay() - me.weekStartDay,\n                    toAdd;\n\n                if (distanceToWeekStartDay < 0) {\n                    distanceToWeekStartDay = 7 + distanceToWeekStartDay;\n                }\n\n                if (Math.round(distanceToWeekStartDay / 7) === 1) {\n                    toAdd = 7 - distanceToWeekStartDay;\n                }\n                else {\n                    toAdd = -distanceToWeekStartDay;\n                }\n\n                return DH.add(dt, toAdd, 'day', false);\n            }\n\n            case 'month': {\n                const\n                    nbrMonths     = DH.diff(relativeTo, dt, 'month') + DH.as('month', dt.getDay() / DH.daysInMonth(dt)), //*/DH.as('month', DH.diff(relativeTo, dt)) + (dt.getDay() / DH.daysInMonth(dt)),\n                    snappedMonths = Math.round(nbrMonths / increment) * increment;\n                return DH.add(relativeTo, snappedMonths, 'month', false);\n            }\n\n            case 'quarter':\n                DH.startOf(dt, 'month', false);\n                return DH.add(dt, 3 - (dt.getMonth() % 3), 'month', false);\n\n            default: {\n                const\n                    duration        = DH.as(resolutionUnit, DH.diff(relativeTo, dt)),\n                    // Need to find the difference of timezone offsets between relativeTo and original dates. 0 if timezone offsets are the same.\n                    offset          = DH.as(resolutionUnit, relativeTo.getTimezoneOffset() - dt.getTimezoneOffset(), 'minute'),\n                    // Need to add the offset to the whole duration, so the divided value will take DST into account\n                    snappedDuration = Math.round((duration + offset) / increment) * increment;\n\n                // TODO: used to add one res unit lower * factor, minutes = add seconds, minutes * 60\n                // Now when the round is done, we need to subtract the offset, so the result also will take DST into account\n                return DH.add(relativeTo, snappedDuration - offset, resolutionUnit, false);\n            }\n        }\n    }\n\n    // private\n    ceilDate(date, relativeToStart, resolutionUnit, increment) {\n        const me = this;\n\n        relativeToStart = relativeToStart !== false;\n        increment = increment || (relativeToStart ? me.resolutionIncrement : 1);\n\n        const\n            unit = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit),\n            dt     = DH.clone(date);\n\n        let doCall = false;\n\n        switch (unit) {\n            case 'minute':\n                doCall = !DH.isStartOf(dt, 'minute');\n                break;\n\n            case 'hour':\n                doCall = !DH.isStartOf(dt, 'hour');\n                break;\n\n            case 'day':\n            case 'date':\n                doCall = !DH.isStartOf(dt, 'day');\n                break;\n\n            case 'week':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getDay() !== me.weekStartDay || !DH.isEqual(dt, date));\n                break;\n\n            case 'month':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getDate() !== 1 || !DH.isEqual(dt, date));\n                break;\n\n            case 'quarter':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getMonth() % 3 !== 0 || dt.getDate() !== 1 || !DH.isEqual(dt, date));\n                break;\n\n            case 'year':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getMonth() !== 0 || dt.getDate() !== 1 || !DH.isEqual(dt, date));\n                break;\n        }\n\n        if (doCall) {\n            return DH.getNext(dt, unit, increment, me.weekStartDay);\n        }\n\n        return dt;\n    }\n\n    //endregion\n\n    //region Ticks\n\n    get include() {\n        return this._include;\n    }\n\n    set include(include) {\n        const me = this;\n\n        me._include = include;\n        me.continuous = !include;\n\n        if (!me.isConfiguring) {\n            me.startDate = me._configuredStartDate;\n            me.endDate = me._configuredEndDate;\n            me.internalOnReconfigure();\n            me.trigger('includeChange');\n        }\n    }\n\n    // Check if a certain date is included based on timeAxis.include rules\n    processExclusion(startDate, endDate, unit) {\n        const { include } = this;\n\n        if (include) {\n            return Object.entries(include).some(([includeUnit, rule]) => {\n\n                if (!rule) {\n                    return false;\n                }\n\n                const { from, to } = rule;\n\n                // Including the closest smaller unit with a { from, to} rule should affect start & end of the\n                // generated tick. Currently only works for days or smaller.\n                if (DH.compareUnits('day', unit) >= 0 && DH.getLargerUnit(includeUnit) === unit) {\n                    if (from) {\n                        DH.set(startDate, includeUnit, from);\n                    }\n\n                    if (to) {\n                        let stepUnit = unit;\n                        // Stepping back base on date, not day\n                        if (unit === 'day') {\n                            stepUnit = 'date';\n                        }\n                        // Since endDate is not inclusive it points to the next day etc.\n                        // Turns for example 2019-01-10T00:00 -> 2019-01-09T18:00\n                        DH.set(endDate, {\n                            [stepUnit]    : DH.get(endDate, stepUnit) - 1,\n                            [includeUnit] : to\n                        });\n                    }\n                }\n\n                // \"Greater\" unit being included? Then we need to care about it\n                // (for example excluding day will also affect hour, minute etc)\n                if (DH.compareUnits(includeUnit, unit) >= 0) {\n                    const datePart = (includeUnit === 'day' ? startDate.getDay() : DH.get(startDate, includeUnit));\n\n                    if ((from && datePart < from) || (to && datePart >= to)) {\n                        return true;\n                    }\n                }\n            });\n        }\n\n        return false;\n    }\n\n    // Calculate constants used for exclusion when scaling within larger ticks\n    initExclusion() {\n        Object.entries(this.include).forEach(([unit, rule]) => {\n            if (rule) {\n                const { from, to } = rule;\n\n                // For example for hour:\n                // 1. Get the next bigger unit -> day, get ratio -> 24\n                // 2. to 20 - from 8 = 12 hours visible each day. lengthFactor 24 / 12 = 2 means that each hour used\n                // needs to represent 2 hours when drawn (to stretch)\n                // |        | -> |    |\n                rule.lengthFactor = DH.getUnitToBaseUnitRatio(unit, DH.getLargerUnit(unit)) / (to - from);\n                // TODO: Since `to` is exclusive this should be the correct one... but cannot get it to work throughout\n                rule.lengthFactorExcl = DH.getUnitToBaseUnitRatio(unit, DH.getLargerUnit(unit)) / (to - from - 1);\n\n                // Calculate weighted center to stretch around |   x |\n                rule.center = from + from / (rule.lengthFactor - 1);\n            }\n        });\n    }\n\n    /**\n     * Method generating the ticks for this time axis. Should return an array of ticks. Each tick is an object of the following structure:\n     * ```\n     * {\n     *    startDate : ..., // start date\n     *    endDate   : ...  // end date\n     * }\n     * ```\n     * Take notice, that this function either has to be called with `start`/`end` parameters, or create those variables.\n     *\n     * To see it in action please check out our [TimeAxis](https://bryntum.com/products/scheduler/examples/timeaxis/) example and navigate to \"Compressed non-working time\" tab.\n     *\n     * @member {Function} generateTicks\n     * @param {Date} axisStartDate The start date of the interval\n     * @param {Date} axisEndDate The end date of the interval\n     * @param {String} unit The unit of the time axis\n     * @param {Number} increment The increment for the unit specified.\n     * @returns {Array} ticks The ticks representing the time axis\n     */\n\n    updateGenerateTicks() {\n        if (!this.isConfiguring) {\n            this.reconfigure(this);\n        }\n    }\n\n    _generateTicks(axisStartDate, axisEndDate, unit = this.unit, increment = this.increment) {\n        const\n            me            = this,\n            ticks         = [],\n            usesExclusion = Boolean(me.include);\n\n        let intervalEnd,\n            tickEnd,\n            isExcluded,\n            dstDiff        = 0,\n            { startDate, endDate } = me.getAdjustedDates(axisStartDate, axisEndDate);\n\n        me.tickCache = {};\n\n        if (usesExclusion) {\n            me.initExclusion();\n        }\n\n        while (startDate < endDate) {\n            intervalEnd = DH.getNext(startDate, unit, increment, me.weekStartDay);\n\n            if (!me.autoAdjust && intervalEnd > endDate) {\n                intervalEnd = endDate;\n            }\n\n            // Handle hourly increments crossing DST boundaries to keep the timescale looking correct\n            // Only do this for HOUR resolution currently, and only handle it once per tick generation.\n            if (unit === 'hour' && increment > 1 && ticks.length > 0 && dstDiff === 0) {\n                const prev = ticks[ticks.length - 1];\n\n                dstDiff = ((prev.startDate.getHours() + increment) % 24) - prev.endDate.getHours();\n\n                if (dstDiff !== 0) {\n                    // A DST boundary was crossed in previous tick, adjust this tick to keep timeaxis \"symmetric\".\n                    intervalEnd = DH.add(intervalEnd, dstDiff, 'hour');\n                }\n            }\n\n            isExcluded = false;\n\n            if (usesExclusion) {\n                tickEnd = new Date(intervalEnd.getTime());\n                isExcluded = me.processExclusion(startDate, intervalEnd, unit);\n            }\n            else {\n                tickEnd = intervalEnd;\n            }\n\n            if (!isExcluded) {\n                ticks.push({\n                    id      : (ticks.length + 1),\n                    startDate,\n                    endDate : intervalEnd\n                });\n                me.tickCache[startDate.getTime()] = ticks.length - 1;\n            }\n\n            startDate = tickEnd;\n        }\n\n        return ticks;\n    }\n\n    /**\n     * How many ticks are visible across the TimeAxis.\n     *\n     * Usually, this is an integer because {@link #config-autoAdjust} means that the start and end\n     * dates are adjusted to be on tick boundaries.\n     * @property {Number}\n     * @internal\n     */\n    get visibleTickTimeSpan() {\n        const me = this;\n        return me.isContinuous ? me.visibleTickEnd - me.visibleTickStart : me.count;\n    }\n\n    /**\n     * Gets a tick \"coordinate\" representing the date position on the time scale. Returns -1 if the date is not part of the time axis.\n     * @param {Date} date the date\n     * @returns {Number} the tick position on the scale or -1 if the date is not part of the time axis\n     */\n    getTickFromDate(date) {\n        const\n            me     = this,\n            ticks  = me.records,\n            dateMS = date.getTime?.() ?? date;\n\n        let begin = 0,\n            end   = ticks.length - 1,\n            middle, tick, tickStart, tickEnd;\n\n        // Quickly eliminate out of range dates or if we have not been set up with a time range yet\n        if (!ticks.length || dateMS < ticks[0].startDateMS || dateMS > ticks[end].endDateMS) {\n            return -1;\n        }\n        if (me.isContinuous) {\n            // TODO: This is the code from ExtScheduler, it is a calculation without iteration so it should perform better,\n            //  we should consider using it...\n            // if (date - ticks[0].startDate === 0) return this.visibleTickStart;\n            // if (date - ticks[end].endDate === 0) return this.visibleTickEnd;\n            //\n            // const { adjustedStart, adjustedEnd }     = this;\n            //\n            // let tickIndex       = Math.floor(ticks.length * (date - adjustedStart) / (adjustedEnd - adjustedStart));\n            //\n            // // for the date == adjustedEnd case\n            // if (tickIndex > end) {\n            //     tickIndex = end;\n            // }\n            //\n            // const tickStart           = tickIndex === 0 ? adjustedStart : ticks[tickIndex].startDate;\n            // const tickEnd             = tickIndex === end ? adjustedEnd : ticks[tickIndex].endDate;\n            //\n            // tick                = tickIndex + (date - tickStart) / (tickEnd - tickStart);\n            //\n            // // in case of `autoAdjust : false` the actual visible timespan starts not from 0 tick coordinate, but\n            // // from `visibleTickStart` coordinate, this check generally repeats the \"quick bailout\" check in the beginning of the method,\n            // // but still\n            // if (tick < this.visibleTickStart || tick > this.visibleTickEnd) {\n            //     return -1;\n            // }\n            //\n            // return tick;\n            // Chop tick cache in half until we find a match\n            while (begin < end) {\n                middle = (begin + end + 1) >> 1;\n                if (dateMS > ticks[middle].endDateMS) {\n                    begin = middle + 1;\n                }\n                else if (dateMS < ticks[middle].startDateMS) {\n                    end = middle - 1;\n                }\n                else {\n                    begin = middle;\n                }\n            }\n            tick = ticks[begin];\n            tickStart = tick.startDateMS;\n\n            // Part way though, calculate the fraction\n            if (dateMS > tickStart) {\n                tickEnd = tick.endDateMS;\n                begin += (dateMS - tickStart) / (tickEnd - tickStart);\n            }\n\n            return Math.min(Math.max(begin, me.visibleTickStart), me.visibleTickEnd);\n        }\n        else {\n            for (let i = 0; i <= end; i++) {\n                tickEnd         = ticks[i].endDateMS;\n\n                if (dateMS <= tickEnd) {\n                    tickStart   = ticks[i].startDateMS;\n\n                    // date < tickStart can occur in filtered case\n                    tick = i + (dateMS > tickStart ? (dateMS - tickStart) / (tickEnd - tickStart) : 0);\n\n                    return tick;\n                }\n            }\n        }\n\n    }\n\n    /**\n     * Gets the time represented by a tick \"coordinate\".\n     * @param {Number} tick the tick \"coordinate\"\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @returns {Date} The date to represented by the tick \"coordinate\", or null if invalid.\n     */\n    getDateFromTick(tick, roundingMethod) {\n        const me = this;\n\n        if (tick === me.visibleTickEnd) {\n            return me.endDate;\n        }\n\n        const\n            wholeTick = Math.floor(tick),\n            fraction  = tick - wholeTick,\n            t         = me.getAt(wholeTick);\n\n        if (!t) {\n            return null;\n        }\n\n        const\n            start = wholeTick === 0 ? me.adjustedStart : t.startDate,\n            // if we've filtered timeaxis using filterBy, then we cannot trust to adjustedEnd property and should use tick end\n            end   = (wholeTick === me.count - 1) && me.isContinuous ? me.adjustedEnd : t.endDate;\n\n        let date = DH.add(start, fraction * (end - start), 'millisecond');\n\n        if (roundingMethod) {\n            date = me[roundingMethod + 'Date'](date);\n        }\n\n        return date;\n    }\n\n    /**\n     * Returns the ticks of the timeaxis in an array of objects with a \"startDate\" and \"endDate\".\n     * @property {Scheduler.model.TimeSpan[]}\n     */\n    get ticks() {\n        return this.records;\n    }\n\n    /**\n     * Caches ticks and start/end dates for faster processing during rendering of events.\n     * @private\n     */\n    updateTickCache(onlyStartEnd = false) {\n        const me = this;\n\n        if (me.count) {\n            me._start = me.first.startDate;\n            me._end = me.last.endDate;\n            me._startMS = me.startDate.getTime();\n            me._endMS = me.endDate.getTime();\n        }\n        else {\n            me._start = me._end = me._startMs = me._endMS = null;\n        }\n\n        // onlyStartEnd is true prior to clearing filters, to get start and end dates correctly during that process.\n        // No point in filling tickCache yet in that case, it will be done after the filters are cleared\n        if (!onlyStartEnd) {\n            me.tickCache = {};\n            me.forEach((tick, i) => me.tickCache[tick.startDate.getTime()] = i);\n        }\n    }\n\n    //endregion\n\n    //region Axis\n\n    /**\n     * Returns true if the passed date is inside the span of the current time axis.\n     * @param {Date} date The date to query for\n     * @returns {Boolean} true if the date is part of the time axis\n     */\n    dateInAxis(date, inclusiveEnd = false) {\n        const\n            me        = this,\n            axisStart = me.startDate,\n            axisEnd   = me.endDate;\n\n        // Date is between axis start/end and axis is not continuous - need to perform better lookup\n        if (me.isContinuous) {\n            return inclusiveEnd ? DH.betweenLesserEqual(date, axisStart, axisEnd) : DH.betweenLesser(date, axisStart, axisEnd);\n        }\n        else {\n            const length = me.getCount();\n\n            let tickStart, tickEnd, tick;\n\n            for (let i = 0; i < length; i++) {\n                tick = me.getAt(i);\n                tickStart = tick.startDate;\n                tickEnd = tick.endDate;\n\n                if ((inclusiveEnd && date <= tickEnd) || (!inclusiveEnd && date < tickEnd)) {\n                    return date >= tickStart;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns true if the passed timespan is part of the current time axis (in whole or partially).\n     * @param {Date} start The start date\n     * @param {Date} end The end date\n     * @returns {Boolean} true if the timespan is part of the timeaxis\n     */\n    timeSpanInAxis(start, end) {\n        const me = this;\n\n        if (!end || end.getTime() === start.getTime()) {\n            return this.dateInAxis(start, true);\n        }\n\n        if (me.isContinuous) {\n            return DH.intersectSpans(start, end, me.startDate, me.endDate);\n        }\n\n        return (start < me.startDate && end > me.endDate) || me.getTickFromDate(start) !== me.getTickFromDate(end);\n    }\n\n    // Accepts a TimeSpan model (uses its cached MS values to be a bit faster during rendering)\n    isTimeSpanInAxis(timeSpan) {\n        const\n            me                         = this,\n            { startMS, endMS }         = me,\n            { startDateMS, endDateMS } = timeSpan;\n\n        // only consider fully scheduled ranges\n        if (!startDateMS || !endDateMS) return false;\n\n        if (endDateMS === startDateMS) {\n            return me.dateInAxis(timeSpan.startDate, true);\n        }\n\n        if (me.isContinuous) {\n            return endDateMS > startMS && startDateMS < endMS;\n        }\n\n        const\n            startTick = me.getTickFromDate(timeSpan.startDate),\n            endTick   = me.getTickFromDate(timeSpan.endDate);\n\n        // endDate is not inclusive\n        // TODO: Handle in getTickFromDate() somehow?\n        if (\n            (startTick === me.count && DH.isEqual(timeSpan.startDate, me.last.endDate)) ||\n            (endTick === 0 && DH.isEqual(timeSpan.endDate, me.first.startDate))\n        ) {\n            return false;\n        }\n\n        return (\n            // Spanning entire axis\n            (startDateMS < startMS && endDateMS > endMS) ||\n            // Unintentionally 0 wide (ticks excluded or outside)\n            startTick !== endTick\n        );\n    }\n\n    //endregion\n\n    //region Iteration\n\n    /**\n     * Calls the supplied iterator function once per interval. The function will be called with four parameters, startDate endDate, index, isLastIteration.\n     * @internal\n     * @param {String} unit The unit to use when iterating over the timespan\n     * @param {Number} increment The increment to use when iterating over the timespan\n     * @param {Function} iteratorFn The function to call\n     * @param {Object} [thisObj] `this` reference for the function\n     */\n    forEachAuxInterval(unit, increment = 1, iteratorFn, thisObj = this) {\n        const end = this.endDate;\n\n        let dt = this.startDate,\n            i  = 0,\n            intervalEnd;\n\n        if (dt > end) throw new Error('Invalid time axis configuration');\n\n        while (dt < end) {\n            intervalEnd = DH.min(DH.getNext(dt, unit, increment, this.weekStartDay), end);\n            iteratorFn.call(thisObj, dt, intervalEnd, i, intervalEnd >= end);\n            dt = intervalEnd;\n            i++;\n        }\n    }\n\n    //endregion\n}\n","/* eslint-disable no-unused-expressions */\nimport InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport DragHelper from '../../../Core/helper/DragHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport ClockTemplate from '../../tooltip/ClockTemplate.js';\nimport Tooltip from '../../../Core/widget/Tooltip.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\nimport Widget from '../../../Core/widget/Widget.js';\n\n/**\n * @module Scheduler/feature/base/DragBase\n */\n\n//TODO: shift to copy\n\n/**\n * Base class for EventDrag (Scheduler) and TaskDrag (Gantt) features. Contains shared code. Not to be used directly.\n *\n * @extends Core/mixin/InstancePlugin\n * @abstract\n */\nexport default class DragBase extends InstancePlugin {\n    //region Config\n\n    static get defaultConfig() {\n        return {\n            // documented on Schedulers EventDrag feature and Gantt's TaskDrag\n            tooltipTemplate : data => `\n                <div class=\"b-sch-tip-${data.valid ? 'valid' : 'invalid'}\">\n                    ${data.startClockHtml}\n                    ${data.endClockHtml}\n                    <div class=\"b-sch-tip-message\">${data.message}</div>\n                </div>\n            `,\n\n            /**\n             * Specifies whether or not to show tooltip while dragging event\n             * @config {Boolean}\n             * @default\n             */\n            showTooltip : true,\n\n            /**\n             * When enabled, the event being dragged always \"snaps\" to the exact start date that it will have after drop.\n             * @config {Boolean}\n             * @default\n             */\n            showExactDropPosition : false,\n\n            /*\n             * The store from which the dragged items are mapped to the UI.\n             * In Scheduler's implementation of this base class, this will be\n             * an EventStore, in Gantt's implementations, this will be a TaskStore.\n             * Because both derive from this base, we must refer to it as this.store.\n             * @private\n             */\n            store : null,\n\n            /**\n             * An object used to configure the internal {@link Core.helper.DragHelper} class\n             * @config {DragHelperConfig}\n             */\n            dragHelperConfig : null,\n\n            tooltipCls : 'b-eventdrag-tooltip'\n        };\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Set to `false` to allow dragging tasks outside the client Scheduler.\n             * Useful when you want to drag tasks between multiple Scheduler instances\n             * @config {Boolean}\n             * @default\n             */\n            constrainDragToTimeline : true,\n\n            // documented on Schedulers EventDrag feature, not used for Gantt\n            constrainDragToResource : true,\n\n            constrainDragToTimeSlot : false,\n\n            /**\n             * Yields the {@link Core.widget.Tooltip} which tracks the event during a drag operation.\n             * @member {Core.widget.Tooltip} tip\n             */\n            /**\n             * A config object to allow customization of the {@link Core.widget.Tooltip} which tracks\n             * the event during a drag operation.\n             * @config {TooltipConfig}\n             */\n            tip : {\n                $config : ['lazy', 'nullify'],\n                value   : {\n                    align : {\n                        align          : 'b-t',\n                        allowTargetOut : true\n                    },\n                    autoShow                 : true,\n                    updateContentOnMouseMove : true\n                }\n            },\n\n            /**\n             * The `eventDrag`and `taskDrag` events are normally only triggered when the drag operation will lead to a\n             * change in date or assignment. By setting this config to `false`, that logic is bypassed to trigger events\n             * for each native mouse move event.\n             * @prp {Boolean}\n             */\n            throttleDragEvent : true\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onPaint']\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    internalSnapToPosition(snapTo) {\n        const { dragData } = this;\n\n        this.snapToPosition?.({\n            assignmentRecord : dragData.assignmentRecord,\n            eventRecord      : dragData.eventRecord,\n            resourceRecord   : dragData.newResource || dragData.resourceRecord,\n            startDate        : dragData.startDate,\n            endDate          : dragData.endDate,\n            snapTo\n        });\n    }\n\n    buildDragHelperConfig() {\n        const\n            me                                  = this,\n            {\n                client,\n                constrainDragToTimeline,\n                constrainDragToResource,\n                constrainDragToTimeSlot,\n                dragHelperConfig = {}\n            }                                   = me,\n            { timeAxisViewModel, isHorizontal } = client,\n            lockY                               = isHorizontal ? constrainDragToResource : constrainDragToTimeSlot,\n            lockX                               = isHorizontal ? constrainDragToTimeSlot : constrainDragToResource;\n\n        // If implementer wants to allow users dragging outside the timeline element, setup the internal dropTargetSelector\n        if (me.externalDropTargetSelector) {\n            dragHelperConfig.dropTargetSelector = `.b-timeaxissubgrid,${me.externalDropTargetSelector}`;\n        }\n\n        return Objects.merge({\n            name                 : me.constructor.name, // useful when debugging with multiple draggers\n            positioning          : 'absolute',\n            lockX,\n            lockY,\n            minX                 : true, // Allows dropping with start before time axis\n            maxX                 : true, // Allows dropping with end after time axis\n            constrain            : false,\n            cloneTarget          : !constrainDragToTimeline,\n            // If we clone event dragged bars, we assume ownership upon drop so we can reuse the element and have animations\n            removeProxyAfterDrop : false,\n            dragWithin           : constrainDragToTimeline ? null : document.body,\n            hideOriginalElement  : true,\n            dropTargetSelector   : '.b-timelinebase',\n\n            // A CSS class added to drop target while dragging events\n            dropTargetCls : me.externalDropTargetSelector ?  'b-drop-target' : '',\n\n            outerElement   : client.timeAxisSubGridElement,\n            targetSelector : client.eventSelector,\n            scrollManager  : constrainDragToTimeline ? client.scrollManager : null,\n            createProxy    : el => me.createProxy(el),\n\n            snapCoordinates : ({ element, newX, newY }) => {\n                const { dragData } = me;\n                // Snapping not supported when dragging outside a scheduler\n                if (me.constrainDragToTimeline && !me.constrainDragToTimeSlot && (me.showExactDropPosition || timeAxisViewModel.snap)) {\n                    const\n                        draggedEventRecord = dragData.draggedEntities[0],\n                        coordinate         = me.getCoordinate(draggedEventRecord, element, [newX, newY]),\n                        snappedDate        = timeAxisViewModel.getDateFromPosition(coordinate, 'round'),\n                        { calendar }       = draggedEventRecord;\n\n                    if (!calendar || snappedDate && calendar.isWorkingTime(snappedDate, DateHelper.add(snappedDate, draggedEventRecord.fullDuration))) {\n                        const snappedPosition = snappedDate && timeAxisViewModel.getPositionFromDate(snappedDate);\n\n                        if (snappedDate && snappedDate >= client.startDate && snappedPosition != null) {\n                            if (isHorizontal) {\n                                newX = snappedPosition;\n                            }\n                            else {\n                                newY = snappedPosition;\n                            }\n                        }\n                    }\n                }\n\n                const snapTo = { x : newX, y : newY };\n\n                me.internalSnapToPosition(snapTo);\n\n                return snapTo;\n            },\n            internalListeners : {\n                beforedragstart : 'onBeforeDragStart',\n                dragstart       : 'onDragStart',\n                afterdragstart  : 'onAfterDragStart',\n                drag            : 'onDrag',\n                drop            : 'onDrop',\n                abort           : 'onDragAbort',\n                abortFinalized  : 'onDragAbortFinalized',\n                reset           : 'onDragReset',\n                thisObj         : me\n            }\n        }, dragHelperConfig, {\n            isElementDraggable : (el, event) => {\n                return (!dragHelperConfig || !dragHelperConfig.isElementDraggable || dragHelperConfig.isElementDraggable(el, event)) &&\n                    me.isElementDraggable(el, event);\n            }\n        });\n    }\n\n    /**\n     * Called when scheduler is rendered. Sets up drag and drop and hover tooltip.\n     * @private\n     */\n    onPaint({ firstPaint }) {\n        const\n            me         = this,\n            { client } = me;\n\n        me.drag?.destroy();\n\n        me.drag = DragHelper.new(me.buildDragHelperConfig());\n\n        if (firstPaint) {\n            client.rowManager.ion({\n                changeTotalHeight : () => me.updateYConstraint(me.dragData?.[`${client.scheduledEventName}Record`]),\n                thisObj           : me\n            });\n        }\n\n        if (me.showTooltip) {\n            me.clockTemplate = new ClockTemplate({\n                scheduler : client\n            });\n        }\n    }\n\n    doDestroy() {\n        this.drag?.destroy();\n        this.clockTemplate?.destroy();\n        this.tip?.destroy();\n        super.doDestroy();\n    }\n\n    get tipId() {\n        return `${this.client.id}-event-drag-tip`;\n    }\n\n    changeTip(tip, oldTip) {\n        const me = this;\n\n        if (tip) {\n            const result = Tooltip.reconfigure(oldTip, Tooltip.mergeConfigs({\n                forElement : me.element,\n                id         : me.tipId,\n                getHtml    : me.getTipHtml.bind(me),\n                cls        : me.tooltipCls,\n                owner      : me.client\n            }, tip), {\n                owner    : me.client,\n                defaults : {\n                    type : 'tooltip'\n                }\n            });\n\n            result.ion({ innerHtmlUpdate : 'updateDateIndicator', thisObj : me });\n\n            return result;\n        }\n        else {\n            oldTip?.destroy();\n        }\n    }\n\n    //endregion\n\n    //region Drag events\n\n    createProxy(element) {\n        const proxy = element.cloneNode(true);\n        delete proxy.id;\n\n        proxy.classList.add(`b-sch-${this.client.mode}`);\n        return proxy;\n    }\n\n    onBeforeDragStart({ context, event }) {\n        const\n            me             = this,\n            { client }     = me,\n            dragData       = me.getMinimalDragData(context, event),\n            eventRecord    = dragData?.[`${client.scheduledEventName}Record`],\n            resourceRecord = dragData.resourceRecord;\n\n        if (client.readOnly || me.disabled || !eventRecord || eventRecord.isDraggable === false || eventRecord.readOnly || resourceRecord?.readOnly) {\n            return false;\n        }\n\n        // Cache the date corresponding to the drag start point so that on drag, we can always\n        // perform the same calculation to then find the time delta without having to calculate\n        // the new start end end times from the position that the element is.\n        context.pointerStartDate = client.getDateFromXY([context.startClientX, context.startPageY], null, false);\n\n        const result = me.triggerBeforeEventDrag(\n            `before${client.capitalizedEventName}Drag`,\n            {\n                ...dragData,\n                event,\n                // to be deprecated\n                context : {\n                    ...context,\n                    ...dragData\n                }\n            }\n        ) !== false;\n\n        if (result) {\n            me.updateYConstraint(eventRecord, resourceRecord);\n\n            // Hook for features that need to react to drag starting, used by NestedEvents\n            client[`before${client.capitalizedEventName}DragStart`]?.(context, dragData);\n        }\n\n        return result;\n    }\n\n    onAfterDragStart({ context, event }) {}\n\n    /**\n     * Returns true if a drag operation is active\n     * @property {Boolean}\n     * @readonly\n     */\n    get isDragging() {\n        return this.drag?.isDragging;\n    }\n\n    // Checked by dependencies to determine if live redrawing is needed\n    get isActivelyDragging() {\n        return this.isDragging && !this.finalizing;\n    }\n\n    /**\n     * Triggered when dragging of an event starts. Initializes drag data associated with the event being dragged.\n     * @private\n     */\n    onDragStart({ context, event }) {\n        const\n            me     = this,\n            // When testing with Selenium, it simulates drag and drop with a single mousemove event, we might be over\n            // another client already\n            client = me.findClientFromTarget(event, context) ?? me.client;\n\n        me.currentOverClient = client;\n        me.drag.unifiedProxy = me.unifiedDrag;\n\n        me.onMouseOverNewTimeline(client, true);\n\n        const dragData = me.dragData = me.getDragData(context);\n\n        // Do not let DomSync reuse the element\n        me.suspendElementRedrawing(context.element);\n\n        if (me.showTooltip && me.tip) {\n            const tipTarget = dragData.context.dragProxy ? dragData.context.dragProxy.firstChild : context.element;\n\n            me.tip.showBy(tipTarget);\n        }\n\n        me.triggerDragStart(dragData);\n\n        // Hook for features that need to take action after drag starts\n        client[`after${client.capitalizedEventName}DragStart`]?.(context, dragData);\n\n        const\n            {\n                eventMenu,\n                taskMenu\n            }           = client.features,\n            menuFeature = eventMenu || taskMenu;\n\n        // If this is a touch action, hide the context menu which may have shown\n        menuFeature?.hideContextMenu?.(false);\n    }\n\n    updateDateIndicator() {\n        const\n            { startDate, endDate } = this.dragData,\n            { tip, clockTemplate } = this,\n            endDateElement         = tip.element.querySelector('.b-sch-tooltip-enddate');\n\n        clockTemplate.updateDateIndicator(tip.element, startDate);\n\n        endDateElement && clockTemplate.updateDateIndicator(endDateElement, endDate);\n    }\n\n    findClientFromTarget(event, context) {\n        let { target } = event;\n\n        // Can't detect target under a touch event\n        if (/^touch/.test(event.type)) {\n            const center = Rectangle.from(context.element, null, true).center;\n\n            target = DomHelper.elementFromPoint(center.x, center.y);\n        }\n\n        const client = Widget.fromElement(target, 'timelinebase');\n        // Do not allow drops on histogram widgets\n        return client?.isResourceHistogram ? null : client;\n    }\n\n    /**\n     * Triggered while dragging an event. Updates drag data, validation etc.\n     * @private\n     */\n    onDrag({ context, event }) {\n        const\n            me    = this,\n            dd    = me.dragData,\n            start = dd.startDate;\n\n        let client;\n\n        if (me.constrainDragToTimeline) {\n            client = me.client;\n        }\n        else {\n            client = me.findClientFromTarget(event, dd.context);\n        }\n\n        me.updateDragContext(context, event);\n\n        if (!client) {\n            return;\n        }\n\n        if (client !== me.currentOverClient) {\n            me.onMouseOverNewTimeline(client);\n        }\n\n        //this.checkShiftChange();\n\n        // Let product specific implementations trigger drag event (eventDrag, taskDrag)\n        if (dd.dirty || !me.throttleDragEvent) {\n            const valid = dd.valid;\n\n            me.triggerEventDrag(dd, start);\n\n            if (valid !== dd.valid) {\n                dd.context.valid = dd.externalDragValidity = dd.valid;\n            }\n        }\n\n        if (me.showTooltip && me.tip) {\n            // If we've an error message to show, force the tip to be visible\n            // even if the target is not in view.\n            me.tip.lastAlignSpec.allowTargetOut = !dd.valid;\n            me.tip.realign();\n        }\n    }\n\n    onMouseOverNewTimeline(newTimeline, initial) {\n        const\n            me                          = this,\n            { drag : { lockX, lockY } } = me,\n            scrollables                 = [];\n\n        me.currentOverClient.element.classList.remove('b-dragging-' + me.currentOverClient.scheduledEventName);\n\n        newTimeline.element.classList.add('b-dragging-' + newTimeline.scheduledEventName);\n\n        if (!initial) {\n            me.currentOverClient.scrollManager.stopMonitoring();\n        }\n\n        if (!lockX) {\n            scrollables.push({\n                element   : newTimeline.timeAxisSubGrid.scrollable.element,\n                direction : 'horizontal'\n            });\n        }\n\n        if (!lockY) {\n            scrollables.push({\n                element   : newTimeline.scrollable.element,\n                direction : 'vertical'\n            });\n        }\n\n        newTimeline.scrollManager.startMonitoring({\n            scrollables,\n            callback : me.drag.onScrollManagerScrollCallback\n        });\n\n        me.currentOverClient = newTimeline;\n    }\n\n    triggerBeforeEventDropFinalize(eventType, eventData, client) {\n        client.trigger(eventType, eventData);\n    }\n\n    /**\n     * Triggered when dropping an event. Finalizes the operation.\n     * @private\n     */\n    onDrop({ context, event }) {\n        const\n            me                              = this,\n            { currentOverClient, dragData } = me;\n\n        let modified = false;\n\n        me.tip?.hide();\n\n        context.valid = context.valid && me.isValidDrop(dragData);\n\n        // If dropping outside scheduler, we opt in on DragHelper removing the proxy element\n        me.drag.removeProxyAfterDrop = Boolean(dragData.externalDropTarget);\n\n        if (context.valid && dragData.startDate && dragData.endDate) {\n            let beforeDropTriggered = false;\n\n            dragData.finalize = async(valid) => {\n                if (beforeDropTriggered || dragData.async) {\n                    await me.finalize(valid);\n                }\n                else {\n                    // If user finalized operation synchronously in the beforeDropFinalize listener, just use\n                    // the valid param and carry on\n                    // but ignore it, if the context is already marked as invalid\n                    context.valid = context.valid && valid;\n                }\n            };\n\n            me.triggerBeforeEventDropFinalize(`before${currentOverClient.capitalizedEventName}DropFinalize`, {\n                context  : dragData,\n                domEvent : event\n            }, currentOverClient);\n\n            beforeDropTriggered = true;\n\n            // Allow implementer to take control of the flow, by returning false from this listener,\n            // to show a confirmation popup etc. This event is documented in EventDrag and TaskDrag\n            context.async = dragData.async;\n\n            // Internal validation, making sure all dragged records fit inside the view\n            if (!context.async && !dragData.externalDropTarget) {\n                modified = (dragData.startDate - dragData.origStart) !== 0 || dragData.newResource !== dragData.resourceRecord;\n            }\n        }\n\n        if (!context.async) {\n            me.finalize(dragData.valid && context.valid && modified);\n        }\n    }\n\n    onDragAbort({ context }) {\n        const me = this;\n\n        me.client.currentOrientation.onDragAbort({ context, dragData : me.dragData });\n\n        // otherwise the event disappears on next refresh (#62)\n        me.resetDraggedElements();\n\n        me.tip?.hide();\n\n        // Trigger eventDragAbort / taskDragAbort depending on product\n        me.triggerDragAbort(me.dragData);\n    }\n\n    // Fired after any abort animation has completed (the point where we want to trigger redraw of progress lines etc)\n    onDragAbortFinalized({ context }) {\n        const me = this;\n\n        me.triggerDragAbortFinalized(me.dragData);\n\n        // Hook for features that need to react on drag abort, used by NestedEvents\n        me.client[`after${me.client.capitalizedEventName}DragAbortFinalized`]?.(context, me.dragData);\n    }\n\n    // For the drag across multiple schedulers, tell all involved scroll managers to stop monitoring\n    onDragReset({ source : dragHelper }) {\n        const\n            me = this,\n            currentTimeline = me.currentOverClient;\n\n        currentTimeline?.scrollManager.stopMonitoring();\n\n        if (dragHelper.context?.started) {\n            me.resetDraggedElements();\n\n            currentTimeline.trigger(`${currentTimeline.scheduledEventName}DragReset`);\n        }\n\n        currentTimeline?.element.classList.remove('b-dragging-' + me.currentOverClient.scheduledEventName);\n        me.dragData = null;\n    }\n\n    resetDraggedElements() {\n        const\n            { dragData }                     = this,\n            { eventBarEls, draggedEntities } = dragData;\n\n        this.resumeRecordElementRedrawing(dragData.record);\n\n        draggedEntities.forEach((record, i) => {\n            this.resumeRecordElementRedrawing(record);\n\n            // TODO why?\n            eventBarEls[i].classList.remove(this.drag.draggingCls);\n            eventBarEls[i].retainElement = false;\n        });\n\n        // Code expects 1:1 ratio between eventBarEls & dragged assignments, but when dragging an event of a linked\n        // resource that is not the case, and we need to clean up some more\n        dragData.context.element.retainElement = false;\n    }\n\n    /**\n     * Triggered internally on invalid drop.\n     * @private\n     */\n    onInternalInvalidDrop(abort) {\n        const\n            me          = this,\n            { context } = me.drag;\n\n        me.tip?.hide();\n\n        me.triggerAfterDrop(me.dragData, false);\n\n        context.valid = false;\n\n        if (abort) {\n            me.drag.abort();\n        }\n    }\n\n    //endregion\n\n    //region Finalization & validation\n\n    /**\n     * Called on drop to update the record of the event being dropped.\n     * @private\n     * @param {Boolean} updateRecords Specify true to update the record, false to treat as invalid\n     */\n    async finalize(updateRecords) {\n        const\n            me           = this,\n            { dragData } = me;\n\n        // Drag could've been aborted by window blur event. If it is aborted - we have nothing to finalize.\n        if (!dragData || me.finalizing) {\n            return;\n        }\n\n        const { context, draggedEntities, externalDropTarget } = dragData;\n\n        let result;\n\n        me.finalizing = true;\n\n        draggedEntities.forEach((record, i) => {\n            me.resumeRecordElementRedrawing(record);\n\n            // TODO Why is this needed? EventResize.t.js fails without it\n            dragData.eventBarEls[i].classList.remove(me.drag.draggingCls);\n            dragData.eventBarEls[i].retainElement = false;\n        });\n\n        // Code expects 1:1 ratio between eventBarEls & dragged assignments, but when dragging an event of a linked\n        // resource that is not the case, and we need to clean up some more\n        context.element.retainElement = false;\n\n        if ((externalDropTarget && dragData.valid) || updateRecords) {\n            // updateRecords may or may not be async.\n            // We see if it returns a Promise.\n            result = me.updateRecords(dragData);\n\n            // If updateRecords is async, the calling DragHelper must know this and\n            // go into a awaitingFinalization state.\n            if (!externalDropTarget && Objects.isPromise(result)) {\n                context.async = true;\n                await result;\n            }\n\n            // If the finalize handler decided to change the dragData's validity...\n            if (!dragData.valid) {\n                me.onInternalInvalidDrop(true);\n            }\n            else {\n                if (context.async) {\n                    context.finalize();\n                }\n                if (externalDropTarget) {\n                    // Force a refresh early so that removed events will not temporary be visible while engine is\n                    // recalculating (the row below clears the 'b-hidden' CSS class of the original drag element)\n                    me.client.refreshRows(false);\n                }\n                me.triggerAfterDrop(dragData, true);\n            }\n        }\n        else {\n            me.onInternalInvalidDrop(context.async || dragData.async);\n        }\n\n        me.finalizing = false;\n\n        return result;\n    }\n\n    //endregion\n\n    //region Drag data\n\n    /**\n     * Updates drag data's dates and validity (calls #validatorFn if specified)\n     * @private\n     */\n    updateDragContext(info, event) {\n        const\n            me                  = this,\n            { drag }            = me,\n            dd                  = me.dragData,\n            client              = me.currentOverClient,\n            { isHorizontal }    = client,\n            [record]            = dd.draggedEntities,\n            eventRecord         = record.isAssignment ? record.event : record,\n            lastDragStartDate   = dd.startDate,\n            constrainToTimeSlot = me.constrainDragToTimeSlot || (isHorizontal ? drag.lockX : drag.lockY);\n\n        dd.browserEvent = event;\n\n        // getProductDragContext may switch valid flag, need to keep it here\n        Object.assign(dd, me.getProductDragContext(dd));\n\n        if (constrainToTimeSlot) {\n            dd.timeDiff = 0;\n        }\n        else {\n            const { dateConstraints } = dd;\n\n            let timeDiff;\n\n            // Time diff is calculated differently for continuous and non-continuous time axis\n            if (client.timeAxis.isContinuous) {\n                const\n                    timeAxisPosition    = client.isHorizontal ? info.pageX ?? info.startPageX : info.pageY ?? info.startPageY,\n                    // Use the localized coordinates to ask the TimeAxisViewModel what date the mouse is at.\n                    // Pass allowOutOfRange as true in case we have dragged out of either side of the timeline viewport.\n                    pointerDate         = client.getDateFromCoordinate(timeAxisPosition, null, false, true);\n\n                timeDiff = dd.timeDiff = pointerDate - info.pointerStartDate;\n            }\n            else {\n                const range = me.resolveStartEndDates(info.element);\n\n                // if dragging is out of timeAxis rect bounds, we will not be able to get dates\n                dd.valid = Boolean(range.startDate && range.endDate);\n\n                if (dd.valid) {\n                    timeDiff = range.startDate - dd.origStart;\n                }\n            }\n\n            // If we got a time diff, we calculate new dates the same way no matter if it's continuous or not.\n            // This prevents no-change drops in non-continuous time axis from being processed by updateAssignments()\n            if (timeDiff !== null) {\n                // calculate and round new startDate based on actual timeDiff\n                dd.startDate = me.adjustStartDate(dd.origStart, timeDiff);\n\n                if (dateConstraints) {\n                    dd.startDate = DateHelper.constrain(dd.startDate, dateConstraints.start,\n                        dateConstraints.end ? new Date(dateConstraints.end - eventRecord.durationMS) : null);\n                }\n\n                dd.endDate = DateHelper.add(dd.startDate, eventRecord.fullDuration);\n\n                if (dd.valid) {\n                    dd.timeDiff = dd.startDate - dd.origStart;\n                }\n            }\n        }\n\n        const positionDirty = dd.dirty = dd.dirty || lastDragStartDate - dd.startDate !== 0;\n\n        if (dd.valid) {\n            // If it's fully outside, we don't allow them to drop it - the event would disappear from their control.\n            if (me.constrainDragToTimeline && (dd.endDate <= client.timeAxis.startDate || dd.startDate >= client.timeAxis.endDate)) {\n                dd.valid = false;\n                dd.context.message = me.L('L{EventDrag.noDropOutsideTimeline}');\n            }\n            else if (positionDirty || dd.externalDropTarget) {\n                // Used to rely on faulty code above that would not be valid initially. With that changed we ignore\n                // checking validity here on drag start, which is detected by not having a pageX\n                const result = dd.externalDragValidity = !event || (info.pageX && me.checkDragValidity(dd, event));\n\n                if (!result || typeof result === 'boolean') {\n                    dd.valid = result !== false;\n                    dd.context.message = '';\n                }\n                else {\n                    dd.valid = result.valid !== false;\n                    dd.context.message = result.message;\n                }\n            }\n            else {\n                // Apply cached value from external drag validation\n                dd.valid = dd.externalDragValidity !== false && dd.externalDragValidity?.valid !== false;\n            }\n        }\n        else {\n            dd.valid = false;\n        }\n\n        dd.context.valid = dd.valid;\n    }\n\n    suspendRecordElementRedrawing(record, suspend = true) {\n        this.suspendElementRedrawing(this.getRecordElement(record), suspend);\n        // TODO temporary get rid of retainElement joggling to check tests\n        record.instanceMeta(this.client).retainElement = suspend;\n    }\n\n    resumeRecordElementRedrawing(record) {\n        this.suspendRecordElementRedrawing(record, false);\n    }\n\n    suspendElementRedrawing(element, suspend = true) {\n        // TODO temporary get rid of retainElement joggling to check tests\n        if (element) {\n            element.retainElement = suspend;\n        }\n    }\n\n    resumeElementRedrawing(element) {\n        this.suspendElementRedrawing(element, false);\n    }\n\n    /**\n     * Initializes drag data (dates, constraints, dragged events etc). Called when drag starts.\n     * @private\n     * @param info\n     * @returns {*}\n     */\n    getDragData(info) {\n        const\n            me                = this,\n            { client, drag }  = me,\n            productDragData   = me.setupProductDragData(info),\n            {\n                record,\n                eventBarEls,\n                draggedEntities\n            }                 = productDragData,\n            { startEvent }    = drag,\n            timespan          = record.isAssignment ? record.event : record,\n            origStart         = timespan.startDate,\n            origEnd           = timespan.endDate,\n            timeAxis          = client.timeAxis,\n            startsOutsideView = origStart < timeAxis.startDate,\n            endsOutsideView   = origEnd > timeAxis.endDate,\n            multiSelect       = client.isSchedulerBase ? client.multiEventSelect : client.selectionMode.multiSelect,\n            coordinate        = me.getCoordinate(timespan, info.element, [info.elementStartX, info.elementStartY]),\n            clientCoordinate  = me.getCoordinate(timespan, info.element, [info.startClientX, info.startClientY]);\n\n        me.suspendRecordElementRedrawing(record);\n\n        // prevent elements from being released when out of view\n        draggedEntities.forEach(record => me.suspendRecordElementRedrawing(record));\n\n        // Make sure the dragged event is selected (no-op for already selected)\n        // Preserve other selected events if ctrl/meta is pressed\n        if (record.isAssignment) {\n            client.selectAssignment(record, startEvent.ctrlKey && multiSelect);\n        }\n        else {\n            client.selectEvent(record, startEvent.ctrlKey && multiSelect);\n        }\n\n        const dragData = {\n            context : info,\n            ...productDragData,\n\n            sourceDate       : startsOutsideView ? origStart : client.getDateFromCoordinate(coordinate),\n            screenSourceDate : client.getDateFromCoordinate(clientCoordinate, null, false),\n\n            startDate : origStart,\n            endDate   : origEnd,\n            timeDiff  : 0,\n\n            origStart,\n            origEnd,\n            startsOutsideView,\n            endsOutsideView,\n\n            duration     : origEnd - origStart,\n            browserEvent : startEvent // So we can know if SHIFT/CTRL was pressed\n        };\n\n        eventBarEls.forEach(el => el.classList.remove('b-sch-event-hover', 'b-active'));\n\n        if (eventBarEls.length > 1) {\n            // RelatedElements are secondary elements moved by the same delta as the grabbed element\n            info.relatedElements = eventBarEls.slice(1);\n        }\n\n        return dragData;\n    }\n\n    //endregion\n\n    //region Constraints\n\n    // private\n    setupConstraints(constrainRegion, elRegion, tickSize, constrained) {\n        const\n            me        = this,\n            xTickSize = !me.showExactDropPosition && tickSize > 1 ? tickSize : 0,\n            yTickSize = 0;\n\n        // If `constrained` is false then we have no date constraints and should constrain mouse position to scheduling area\n        // else we have specified date constraints and so we should limit mouse position to smaller region inside of constrained region using offsets and width.\n        if (constrained) {\n            me.setXConstraint(constrainRegion.left, constrainRegion.right - elRegion.width, xTickSize);\n        }\n        // And if not constrained, release any constraints from the previous drag.\n        else {\n            // minX being true means allow the start to be before the time axis.\n            // maxX being true means allow the end to be after the time axis.\n            me.setXConstraint(true, true, xTickSize);\n        }\n        me.setYConstraint(constrainRegion.top, constrainRegion.bottom - elRegion.height, yTickSize);\n    }\n\n    updateYConstraint(eventRecord, resourceRecord) {\n        const\n            me          = this,\n            { client }  = me,\n            { context } = me.drag,\n            tickSize    = client.timeAxisViewModel.snapPixelAmount;\n\n        // If we're dragging when the vertical size is recalculated by the host grid,\n        // we must update our Y constraint unless we are locked in the Y axis.\n        if (context && !me.drag.lockY) {\n            let constrainRegion;\n\n            // This calculates a relative region which the DragHelper uses within its outerElement\n            if (me.constrainDragToTimeline) {\n                constrainRegion = client.getScheduleRegion(resourceRecord, eventRecord);\n            }\n            // Not constraining to timeline.\n            // Unusual configuration, but this must mean no Y constraining.\n            else {\n                me.setYConstraint(null, null, tickSize);\n                return;\n            }\n\n            me.setYConstraint(\n                constrainRegion.top,\n                constrainRegion.bottom - context.element.offsetHeight,\n                tickSize\n            );\n        }\n        else {\n            me.setYConstraint(null, null, tickSize);\n        }\n    }\n\n    setXConstraint(iLeft, iRight, iTickSize) {\n        const { drag } = this;\n\n        drag.minX = iLeft;\n        drag.maxX = iRight;\n    }\n\n    setYConstraint(iUp, iDown, iTickSize) {\n        const { drag } = this;\n\n        drag.minY = iUp;\n        drag.maxY = iDown;\n    }\n\n    //endregion\n\n    //region Other stuff\n\n    adjustStartDate(startDate, timeDiff) {\n        return this.client.timeAxis.roundDate(\n            new Date(startDate - 0 + timeDiff),\n            this.client.snapRelativeToEventStartDate ? startDate : false\n        );\n    }\n\n    resolveStartEndDates(draggedElement) {\n        const\n            timeline        = this.currentOverClient,\n            { timeAxis }    = timeline,\n            proxyRect       = Rectangle.from(draggedElement.querySelector(timeline.eventInnerSelector), timeline.timeAxisSubGridElement),\n            dd              = this.dragData,\n            [record]        = dd.draggedEntities,\n            { fullDuration } = record.isAssignment ? record.event : record;\n\n        // Non continuous time axis will return null instead of date for a rectangle outside of the view unless\n        // told to estimate date\n        let { start : startDate, end : endDate } = timeline.getStartEndDatesFromRectangle(proxyRect, 'round', fullDuration, !timeAxis.isContinuous);\n\n        // if dragging is out of timeAxis rect bounds, we will not be able to get dates\n        if (startDate && endDate) {\n            startDate = this.adjustStartDate(startDate, 0);\n\n            if (!dd.startsOutsideView) {\n                // Make sure we didn't target a start date that is filtered out, if we target last hour cell (e.g. 21:00) of\n                // the time axis, and the next tick is 08:00 following day. Trying to drop at end of 21:00 cell should target start of next cell\n                if (!timeAxis.dateInAxis(startDate, false)) {\n                    const tick = timeAxis.getTickFromDate(startDate);\n\n                    if (tick >= 0) {\n                        startDate = timeAxis.getDateFromTick(tick);\n                    }\n                }\n\n                endDate = startDate && DateHelper.add(startDate, fullDuration);\n            }\n            else if (!dd.endsOutsideView) {\n                startDate = endDate && DateHelper.add(endDate, -fullDuration);\n            }\n        }\n\n        return {\n            startDate,\n            endDate\n        };\n    }\n\n    //endregion\n\n    //region Dragtip\n\n    /**\n     * Gets html to display in tooltip while dragging event. Uses clockTemplate to display start & end dates.\n     */\n    getTipHtml() {\n        const\n            me                                      = this,\n            { dragData, client, tooltipTemplate }   = me,\n            { startDate, endDate, draggedEntities } = dragData,\n            startText                               = client.getFormattedDate(startDate),\n            endText                                 = client.getFormattedEndDate(endDate, startDate),\n            { valid, message, element, dragProxy }  = dragData.context,\n            tipTarget                               = dragProxy ? dragProxy.firstChild : element,\n            dragged                                 = draggedEntities[0],\n            // Scheduler always drags assignments\n            timeSpanRecord                          = dragged.isTask ? dragged : dragged.event;\n\n        // Keep align target up to date in case of derendering the target when\n        // dragged outside render window, and re-entry into the render window.\n        me.tip.lastAlignSpec.target = tipTarget;\n\n        return tooltipTemplate({\n            valid,\n            startDate,\n            endDate,\n            startText,\n            endText,\n            dragData,\n            message                                : message || '',\n            [client.scheduledEventName + 'Record'] : timeSpanRecord,\n            startClockHtml                         : me.clockTemplate.template({\n                date : startDate,\n                text : startText,\n                cls  : 'b-sch-tooltip-startdate'\n            }),\n            endClockHtml : timeSpanRecord.isMilestone\n                ? ''\n                : me.clockTemplate.template({\n                    date : endDate,\n                    text : endText,\n                    cls  : 'b-sch-tooltip-enddate'\n                })\n        });\n    }\n\n    //endregion\n\n    //region Configurable\n\n    // Constrain to time slot means lockX if we're horizontal, otherwise lockY\n    updateConstrainDragToTimeSlot(value) {\n        const axis = this.client.isHorizontal ? 'lockX' : 'lockY';\n\n        if (this.drag) {\n            this.drag[axis] = value;\n        }\n    }\n\n    // Constrain to resource means lockY if we're horizontal, otherwise lockX\n    updateConstrainDragToResource(constrainDragToResource) {\n        const me = this;\n\n        if (me.drag) {\n            const\n                { constrainDragToTimeSlot } = me,\n                { isHorizontal }            = me.client;\n\n            if (constrainDragToResource) {\n                me.constrainDragToTimeline = true;\n            }\n            me.drag.lockY = isHorizontal ? constrainDragToResource : constrainDragToTimeSlot;\n            me.drag.lockX = isHorizontal ? constrainDragToTimeSlot : constrainDragToResource;\n        }\n    }\n\n    updateConstrainDragToTimeline(constrainDragToTimeline) {\n        if (!this.isConfiguring) {\n            Object.assign(this.drag, {\n                cloneTarget   : !constrainDragToTimeline,\n                dragWithin    : constrainDragToTimeline ? null : document.body,\n                scrollManager : constrainDragToTimeline ? this.client.scrollManager : null\n            });\n        }\n    }\n\n    //endregion\n\n    //region Product specific, implemented in subclasses\n    getElementFromContext(context) {\n        return context.grabbed || context.dragProxy || context.element;\n    }\n\n    // Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.\n    getRelatedRecords(record) {\n        return [];\n    }\n\n    getMinimalDragData(info, event) {\n        // Can be overridden in subclass\n        return {};\n    }\n\n    // Check if element can be dropped at desired location\n    isValidDrop(dragData) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Similar to the fn above but also calls validatorFn\n    checkDragValidity(dragData) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Update records being dragged\n    updateRecords(context) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Determine if an element can be dragged\n    isElementDraggable(el, event) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Get coordinate for correct axis\n    getCoordinate(record, element, coord) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Product specific drag data\n    setupProductDragData(info) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Product specific data in drag context\n    getProductDragContext(dd) {\n        throw new Error('Implement in subclass');\n    }\n\n    getRecordElement(record) {\n        throw new Error('Implement in subclass');\n    }\n\n    //endregion\n}\n","import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Draggable from '../../Core/mixin/Draggable.js';\nimport Droppable from '../../Core/mixin/Droppable.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../tooltip/ClockTemplate.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport TimeSpan from '../../Scheduler/model/TimeSpan.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\n\n/**\n * @module Scheduler/feature/EventResize\n */\n\nconst tipAlign = {\n    top    : 'b-t',\n    right  : 'b100-t100',\n    bottom : 't-b',\n    left   : 'b0-t0'\n};\n\n/**\n * Feature that allows resizing an event by dragging its end.\n *\n * By default it displays a tooltip with the new start and end dates, formatted using\n * {@link Scheduler/view/mixin/TimelineViewPresets#config-displayDateFormat}.\n *\n * ## Customizing the resize tooltip\n *\n * To show custom HTML in the tooltip, please see the {@link #config-tooltipTemplate} config. Example:\n *\n * ```javascript\n * eventResize : {\n *     // A minimal end date tooltip\n *     tooltipTemplate : ({ record, endDate }) => {\n *         return DateHelper.format(endDate, 'MMM D');\n *     }\n * }\n * ```\n * This feature is **enabled** by default\n *\n * This feature is extended with a few overrides by the Gantt's `TaskResize` feature.\n *\n * This feature updates the event's `startDate` or `endDate` live in order to leverage the\n * rendering pathway to always yield a correct appearance. The changes are done in\n * {@link Core.data.Model#function-beginBatch batched} mode so that changes do not become\n * eligible for data synchronization or propagation until the operation is completed.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Scheduler/basic\n * @inlineexample Scheduler/feature/EventResize.js\n * @classtype eventResize\n * @feature\n */\nexport default class EventResize extends InstancePlugin.mixin(Draggable, Droppable) {\n    //region Events\n\n    /**\n     * Fired on the owning Scheduler before resizing starts. Return `false` to prevent the action.\n     * @event beforeEventResize\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the resize starts within\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Fires on the owning Scheduler when event resizing starts\n     * @event eventResizeStart\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the resize starts within\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Fires on the owning Scheduler on each resize move event\n     * @event eventPartialResize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     * @param {Date} startDate\n     * @param {Date} endDate\n     * @param {HTMLElement} element\n     */\n\n    /**\n     * Fired on the owning Scheduler to allow implementer to prevent immediate finalization by setting\n     * `data.context.async = true` in the listener, to show a confirmation popup etc\n     *\n     * ```javascript\n     *  scheduler.on('beforeeventresizefinalize', ({context}) => {\n     *      context.async = true;\n     *      setTimeout(() => {\n     *          // async code don't forget to call finalize\n     *          context.finalize();\n     *      }, 1000);\n     *  })\n     * ```\n     *\n     * @event beforeEventResizeFinalize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Object} context\n     * @param {Scheduler.model.EventModel} context.eventRecord Event record being resized\n     * @param {Date} context.startDate New startDate (changed if resizing start side)\n     * @param {Date} context.endDate New endDate (changed if resizing end side)\n     * @param {Date} context.originalStartDate Start date before resize\n     * @param {Date} context.originalEndDate End date before resize\n     * @param {Boolean} context.async Set true to handle resize asynchronously (e.g. to wait for user confirmation)\n     * @param {Function} context.finalize Call this method to finalize resize. This method accepts one argument:\n     *                   pass `true` to update records, or `false`, to ignore changes\n     * @param {Event} event Browser event\n     */\n\n    /**\n     * Fires on the owning Scheduler after the resizing gesture has finished.\n     * @event eventResizeEnd\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Boolean} changed Shows if the record has been changed by the resize action\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     */\n\n    //endregion\n\n    //region Config\n\n    static get $name() {\n        return 'EventResize';\n    }\n\n    static get configurable() {\n        return {\n            draggingItemCls : 'b-sch-event-wrap-resizing',\n\n            resizingItemInnerCls : 'b-sch-event-resizing',\n\n            /**\n             * Use left handle when resizing. Only applies when owning client's `direction` is 'horizontal'\n             * @config {Boolean}\n             * @default\n             */\n            leftHandle : true,\n\n            /**\n             * Use right handle when resizing. Only applies when owning client's `direction` is 'horizontal'\n             * @config {Boolean}\n             * @default\n             */\n            rightHandle : true,\n\n            /**\n             * Use top handle when resizing. Only applies when owning client's direction` is 'vertical'\n             * @config {Boolean}\n             * @default\n             */\n            topHandle : true,\n\n            /**\n             * Use bottom handle when resizing. Only applies when owning client's `direction` is 'vertical'\n             * @config {Boolean}\n             * @default\n             */\n            bottomHandle : true,\n\n            /**\n             * Resizing handle size to use instead of that determined by CSS\n             * @config {Number}\n             * @deprecated Since 5.2.7. The handle size is determined from responsive CSS. Will be removed in 6.0\n             */\n            handleSize : null,\n\n            /**\n             * Automatically shrink virtual handles when available space < handleSize. The virtual handles will\n             * decrease towards width/height 1, reserving space between opposite handles to for example leave room for\n             * dragging. To configure reserved space, see {@link #config-reservedSpace}.\n             * @config {Boolean}\n             * @default false\n             */\n            dynamicHandleSize : true,\n\n            /**\n             * Set to true to allow resizing to a zero-duration span\n             * @config {Boolean}\n             * @default false\n             */\n            allowResizeToZero : null,\n\n            /**\n             * Room in px to leave unoccupied by handles when shrinking them dynamically (see\n             * {@link #config-dynamicHandleSize}).\n             * @config {Number}\n             * @default\n             */\n            reservedSpace : 5,\n\n            /**\n             * Resizing handle size to use instead of that determined by CSS on touch devices\n             * @config {Number}\n             * @deprecated Since 5.2.7. The handle size is determined from responsive CSS. Will be removed in 6.0\n             */\n            touchHandleSize : null,\n\n            /**\n             * The amount of pixels to move pointer/mouse before it counts as a drag operation.\n             * @config {Number}\n             * @default\n             */\n            dragThreshold : 0,\n\n            dragTouchStartDelay : 0,\n\n            draggingClsSelector : '.b-timeline-base',\n\n            /**\n             * `false` to not show a tooltip while resizing\n             * @config {Boolean}\n             * @default\n             */\n            showTooltip : true,\n\n            /**\n             * true to see exact event length during resizing\n             * @config {Boolean}\n             * @default\n             */\n            showExactResizePosition : false,\n\n            /**\n             * An empty function by default, but provided so that you can perform custom validation on\n             * the item being resized. Return true if the new duration is valid, false to signal that it is not.\n             * @param {Object} context The resize context, contains the record & dates.\n             * @param {Scheduler.model.TimeSpan} context.record The record being resized.\n             * @param {Date} context.startDate The new start date.\n             * @param {Date} context.endDate The new start date.\n             * @param {Date} context.originalStartDate Start date before resize\n             * @param {Date} context.originalEndDate End date before resize\n             * @param {Event} event The browser Event object\n             * @returns {Boolean}\n             * @config {Function}\n             */\n            validatorFn : () => true,\n\n            /**\n             * `this` reference for the validatorFn\n             * @config {Object}\n             */\n            validatorFnThisObj : null,\n\n            /**\n             * Setting this property may change the configuration of the {@link #config-tip}, or\n             * cause it to be destroyed if `null` is passed.\n             *\n             * Reading this property returns the Tooltip instance.\n             * @member {Core.widget.Tooltip|TooltipConfig} tip\n             */\n            /**\n             * If a tooltip is required to illustrate the resize, specify this as `true`, or a config\n             * object for the {@link Core.widget.Tooltip}.\n             * @config {Core.widget.Tooltip|TooltipConfig}\n             */\n            tip : {\n                $config : ['lazy', 'nullify'],\n                value   : {\n                    autoShow                 : false,\n                    axisLock                 : true,\n                    trackMouse               : false,\n                    updateContentOnMouseMove : true,\n                    hideDelay                : 0\n                }\n            },\n\n            /**\n             * A template function returning the content to show during a resize operation.\n             * @param {Object} context A context object\n             * @param {Date} context.startDate New start date\n             * @param {Date} context.endDate New end date\n             * @param {Scheduler.model.TimeSpan} context.record The record being resized\n             * @config {Function} tooltipTemplate\n             */\n            tooltipTemplate : context => `\n                <div class=\"b-sch-tip-${context.valid ? 'valid' : 'invalid'}\">\n                    ${context.startClockHtml}\n                    ${context.endClockHtml}\n                    <div class=\"b-sch-tip-message\">${context.message}</div>\n                </div>\n            `,\n\n            ignoreSelector : '.b-sch-terminal',\n            dragActiveCls  : 'b-resizing-event'\n        };\n    }\n\n    static get pluginConfig() {\n        return {\n            chain : ['render', 'onEventDataGenerated', 'isEventElementDraggable']\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    doDestroy() {\n        super.doDestroy();\n\n        this.dragging?.destroy();\n    }\n\n    render() {\n        const\n            me         = this,\n            { client } = me;\n\n        // Only active when in these items\n        me.dragSelector = me.dragItemSelector = client.eventSelector;\n\n        // Set up elements and listeners\n        me.dragRootElement = me.dropRootElement = client.timeAxisSubGridElement;\n\n        // Drag only in time dimension\n        me.dragLock = client.isVertical ? 'y' : 'x';\n    }\n\n    // Prevent event dragging when it happens over a resize handle\n    isEventElementDraggable(eventElement, eventRecord, el, event) {\n        const\n            me = this,\n            eventResizable = eventRecord?.resizable;\n\n        // ALLOW event drag:\n        // - if resizing is disabled or event is not resizable\n        // - if it's a milestone Milestones cannot be resized\n        if (me.disabled || !eventResizable || eventRecord.isMilestone) {\n            return true;\n        }\n\n        // not over the event handles\n        return ((eventResizable !== true && eventResizable !== 'start') || !me.isOverStartHandle(event, eventElement)) &&\n            ((eventResizable !== true && eventResizable !== 'end') || !me.isOverEndHandle(event, eventElement));\n    }\n\n    // Called for each event during render, allows manipulation of render data.\n    onEventDataGenerated({ eventRecord, wrapperCls, cls }) {\n        if (eventRecord === this.dragging?.context?.eventRecord) {\n            wrapperCls['b-active'] =\n                wrapperCls[this.draggingItemCls] =\n                wrapperCls['b-over-resize-handle'] =\n                cls['b-resize-handle'] =\n                cls[this.resizingItemInnerCls] = 1;\n        }\n    }\n\n    // Sneak a first peek at the drag event to put necessary date values into the context\n    onDragPointerMove(event) {\n        const\n            {\n                client,\n                dragging\n            }          = this,\n            {\n                visibleDateRange,\n                isHorizontal\n            }          = client,\n            rtl        = isHorizontal && client.rtl,\n            dimension  = isHorizontal ? 'X' : 'Y',\n            pageScroll = globalThis[`page${dimension}Offset`],\n            coord      = event[`page${dimension}`] + (dragging.context?.offset || 0),\n            clientRect = Rectangle.from(client.timeAxisSubGridElement, null, true),\n            startCoord = clientRect.getStart(rtl, isHorizontal),\n            endCoord   = clientRect.getEnd(rtl, isHorizontal);\n\n        let date = client.getDateFromCoord({ coord, local : false });\n\n        if (rtl) {\n            // If we're dragging off the start side, fix at the visible startDate\n            if (coord - pageScroll > startCoord) {\n                date = visibleDateRange.startDate;\n            }\n            // If we're dragging off the end side, fix at the visible endDate\n            else if (coord < endCoord) {\n                date = visibleDateRange.endDate;\n            }\n        }\n        // If we're dragging off the start side, fix at the visible startDate\n        else if (coord - pageScroll < startCoord) {\n            date = visibleDateRange.startDate;\n        }\n        // If we're dragging off the end side, fix at the visible endDate\n        else if (coord - pageScroll > endCoord) {\n            date = visibleDateRange.endDate;\n        }\n\n        dragging.clientStartCoord = startCoord;\n        dragging.clientEndCoord = endCoord;\n        dragging.date = date;\n\n        super.onDragPointerMove(event);\n    }\n\n    get isResizing() {\n        return Boolean(this.dragging);\n    }\n\n    beforeDrag(drag) {\n        const\n            { client }     = this,\n            eventRecord    = client.resolveTimeSpanRecord(drag.itemElement),\n            resourceRecord = !client.isGanttBase && client.resolveResourceRecord(client.isVertical ? drag.startEvent : drag.itemElement);\n\n        // Events not part of project are transient records in a Gantt display store and not meant to be modified\n        if (this.disabled || client.readOnly || resourceRecord?.readOnly ||\n            (eventRecord && (eventRecord.readOnly || !(eventRecord.project || eventRecord.isOccurrence))) ||\n            super.beforeDrag(drag) === false) {\n            return false;\n        }\n\n        drag.mousedownDate = drag.date = client.getDateFromCoordinate(drag.event[`page${client.isHorizontal ? 'X' : 'Y'}`], null, false);\n\n        // trigger beforeEventResize or beforeTaskResize depending on product\n        return this.triggerBeforeResize(drag);\n    }\n\n    dragStart(drag) {\n        const\n            me             = this,\n            {\n                client,\n                tip\n            }              = me,\n            {\n                startEvent,\n                itemElement\n            }              = drag,\n            name           = client.scheduledEventName,\n            eventRecord    = client.resolveEventRecord(itemElement),\n            {\n                isBatchUpdating,\n                wrapStartDate,\n                wrapEndDate\n            } = eventRecord,\n            useEventBuffer = client.features.eventBuffer?.enabled,\n            eventStartDate = isBatchUpdating ? eventRecord.get('startDate') : eventRecord.startDate,\n            eventEndDate   = isBatchUpdating ? eventRecord.get('endDate') : eventRecord.endDate,\n            horizontal     = me.dragLock === 'x',\n            rtl            = horizontal && client.rtl,\n            draggingEnd    = me.isOverEndHandle(startEvent, itemElement),\n            toSet          = draggingEnd ? 'endDate' : 'startDate',\n            wrapToSet      = !useEventBuffer ? null : draggingEnd ? 'wrapEndDate' : 'wrapStartDate',\n            otherEnd       = draggingEnd ? 'startDate' : 'endDate',\n            setMethod      = draggingEnd ? 'setEndDate' : 'setStartDate',\n            setOtherMethod = draggingEnd ? 'setStartDate' : 'setEndDate',\n            elRect         = Rectangle.from(itemElement),\n            startCoord     = horizontal ? startEvent.clientX : startEvent.clientY,\n            endCoord       = draggingEnd ? elRect.getEnd(rtl, horizontal) : elRect.getStart(rtl, horizontal),\n            context        = drag.context = {\n                eventRecord,\n                element        : itemElement,\n                timespanRecord : eventRecord,\n                taskRecord     : eventRecord,\n                owner          : me,\n                valid          : true,\n                oldValue       : draggingEnd ? eventEndDate : eventStartDate,\n                startDate      : eventStartDate,\n                endDate        : eventEndDate,\n                offset         : useEventBuffer ? 0 : endCoord - startCoord,\n                edge           : horizontal ? (draggingEnd ? 'right' : 'left') : (draggingEnd ? 'bottom' : 'top'),\n                finalize       : me.finalize,\n                event          : drag.event,\n\n                // these two are public\n                originalStartDate : eventStartDate,\n                originalEndDate   : eventEndDate,\n                wrapStartDate,\n                wrapEndDate,\n                draggingEnd,\n                toSet,\n                wrapToSet,\n                otherEnd,\n                setMethod,\n                setOtherMethod\n            };\n\n        // The record must know that it is being resized.\n        eventRecord.meta.isResizing = true;\n\n        client.element.classList.add(...me.dragActiveCls.split(' '));\n\n        // During this batch we want the client's UI to update itself using the proposed changes\n        // Only if startDrag has not already done it\n        if (!client.listenToBatchedUpdates) {\n            client.beginListeningForBatchedUpdates();\n        }\n\n        // No changes must get through to data.\n        // Only if startDrag has not already started the batch\n        if (!isBatchUpdating) {\n            me.beginEventRecordBatch(eventRecord);\n        }\n\n        // Let products do their specific stuff\n        me.setupProductResizeContext(context, startEvent);\n\n        // Trigger eventResizeStart or taskResizeStart depending on product\n        // Subclasses (like EventDragCreate) won't actually fire this event.\n        me.triggerEventResizeStart(`${name}ResizeStart`, {\n            [`${name}Record`] : eventRecord,\n            event             : startEvent,\n            ...me.getResizeStartParams(context)\n        }, context);\n\n        // Scheduler renders assignments, Gantt renders Tasks\n        context.resizedRecord = client.resolveAssignmentRecord?.(context.element) || eventRecord;\n\n        if (tip) {\n            // Tip needs to be shown first for getTooltipTarget to be able to measure anchor size\n            tip.show();\n            tip.align = tipAlign[context.edge];\n            tip.showBy(me.getTooltipTarget(drag));\n        }\n    }\n\n    // Subclasses may override this\n    triggerBeforeResize(drag) {\n        const\n            { client }  = this,\n            eventRecord = client.resolveTimeSpanRecord(drag.itemElement);\n\n        return client.trigger(\n            `before${client.capitalizedEventName}Resize`,\n            {\n                [`${client.scheduledEventName}Record`] : eventRecord,\n                event                                  : drag.event,\n                ...this.getBeforeResizeParams({ event : drag.startEvent, element : drag.itemElement })\n            }\n        );\n    }\n\n    // Subclasses may override this\n    triggerEventResizeStart(eventType, event, context) {\n        this.client.trigger(eventType, event);\n\n        // Hook for features that needs to react on resize start\n        this.client[`after${StringHelper.capitalize(eventType)}`]?.(context, event);\n    }\n\n    triggerEventResizeEnd(eventType, event) {\n        this.client.trigger(eventType, event);\n    }\n\n    triggerEventPartialResize(eventType, event) {\n        // Trigger eventPartialResize or taskPartialResize depending on product\n        this.client.trigger(eventType, event);\n    }\n\n    triggerBeforeEventResizeFinalize(eventType, event) {\n        this.client.trigger(eventType, event);\n    }\n\n    dragEnter(drag) {\n        // We only respond to our own DragContexts\n        return drag.context?.owner === this;\n    }\n\n    resizeEventPartiallyInternal(eventRecord, context) {\n        const\n            { client } = this,\n            { toSet } = context;\n\n        if (client.features.eventBuffer?.enabled) {\n            if (toSet === 'startDate') {\n                const diff = context.startDate.getTime() - context.originalStartDate.getTime();\n                eventRecord.wrapStartDate = new Date(context.wrapStartDate.getTime() + diff);\n            }\n\n            else if (toSet === 'endDate') {\n                const diff = context.endDate.getTime() - context.originalEndDate.getTime();\n                eventRecord.wrapEndDate = new Date(context.wrapEndDate.getTime() + diff);\n            }\n        }\n\n        eventRecord.set(toSet, context[toSet]);\n    }\n\n    applyDateConstraints(date, eventRecord, context) {\n        const\n            minDate = context.dateConstraints?.start,\n            maxDate = context.dateConstraints?.end;\n\n        // Keep desired date within constraints\n        if (minDate || maxDate) {\n            date = DateHelper.constrain(date, minDate, maxDate);\n            context.snappedDate = DateHelper.constrain(context.snappedDate, minDate, maxDate);\n        }\n\n        return date;\n    }\n\n    // Override the draggable interface so that we can update the bar while dragging outside\n    // the Draggable's rootElement (by default it stops notifications when outside rootElement)\n    moveDrag(drag) {\n        const\n            me          = this,\n            {\n                client,\n                tip\n            }           = me,\n            horizontal  = me.dragLock === 'x',\n            dimension   = horizontal ? 'X' : 'Y',\n            name        = client.scheduledEventName,\n            {\n                visibleDateRange,\n                enableEventAnimations,\n                timeAxis,\n                weekStartDay\n            }           = client,\n            rtl         = horizontal && client.rtl,\n            {\n                resolutionUnit,\n                resolutionIncrement\n            }           = timeAxis,\n            {\n                event,\n                context\n            }           = drag,\n            {\n                eventRecord\n            }           = context,\n            offset      = context.offset * (rtl ? -1 : 1),\n            {\n                isOccurrence\n            }           = eventRecord,\n            eventStart  = eventRecord.get('startDate'),\n            eventEnd    = eventRecord.get('endDate'),\n            coord       = event[`client${dimension}`] + offset,\n            clientRect  = Rectangle.from(client.timeAxisSubGridElement, null, true),\n            startCoord  = clientRect.getStart(rtl, horizontal),\n            endCoord    = clientRect.getEnd(rtl, horizontal);\n\n        context.event = event;\n\n        // If this is the last move event recycled because of a scroll, refresh the date\n        if (event.isScroll) {\n            drag.date = client.getDateFromCoordinate(event[`page${dimension}`] + offset, null, false);\n        }\n\n        let crossedOver, avoidedZeroSize,\n            // Use the value set up in onDragPointerMove by default\n            { date } = drag,\n            {\n                toSet,\n                otherEnd,\n                draggingEnd\n            } = context;\n\n        if (rtl) {\n            // If we're dragging off the start side, fix at the visible startDate\n            if (coord > startCoord) {\n                date = drag.date = visibleDateRange.startDate;\n            }\n            // If we're dragging off the end side, fix at the visible endDate\n            else if (coord < endCoord) {\n                date = drag.date = visibleDateRange.endDate;\n            }\n\n        }\n        // If we're dragging off the start side, fix at the visible startDate\n        else if (coord < startCoord) {\n            date = drag.date = visibleDateRange.startDate;\n        }\n        // If we're dragging off the end side, fix at the visible endDate\n        else if (coord > endCoord) {\n            date = drag.date = visibleDateRange.endDate;\n        }\n\n        // Detect crossover which some subclasses might need to process\n        if (toSet === 'endDate') {\n            if (date < eventStart) {\n                crossedOver = -1;\n            }\n        }\n        else {\n            if (date > eventEnd) {\n                crossedOver = 1;\n            }\n        }\n\n        // If we dragged the dragged end over to the opposite side of the start end.\n        // Some subclasses allow this and need to respond. EventDragCreate does this.\n        if (crossedOver && me.onDragEndSwitch) {\n            me.onDragEndSwitch(context, date, crossedOver);\n            otherEnd = context.otherEnd;\n            toSet = context.toSet;\n        }\n\n        if (client.snapRelativeToEventStartDate) {\n            date = timeAxis.roundDate(date, context.oldValue);\n        }\n\n        // The displayed and eventual data value\n        context.snappedDate = DateHelper.round(date, timeAxis.resolution, null, weekStartDay);\n\n        const duration = DateHelper.diff(date, context[otherEnd], resolutionUnit) * (draggingEnd ? -1 : 1);\n\n        // Narrower than half resolutionIncrement will abort drag creation, set flag to have UI reflect this\n        if (me.isEventDragCreate) {\n            context.tooNarrow = duration < resolutionIncrement / 2;\n        }\n        // The mousepoint date means that the duration is less than resolutionIncrement resolutionUnits.\n        // Ensure that the dragged end is at least resolutionIncrement resolutionUnits from the other end.\n        else if (duration < resolutionIncrement) {\n            // Snap to zero if allowed\n            if (me.allowResizeToZero) {\n                context.snappedDate = date = context[otherEnd];\n            }\n            else {\n                const sign = otherEnd === 'startDate' ? 1 : -1;\n                context.snappedDate = date = timeAxis.roundDate(DateHelper.add(eventRecord.get(otherEnd), resolutionIncrement * sign, resolutionUnit));\n                avoidedZeroSize = true;\n            }\n        }\n\n        // take dateConstraints into account\n        date = me.applyDateConstraints(date, eventRecord, context);\n\n        // If the mouse move has changed the detected date\n        if (!context.date || date - context.date || avoidedZeroSize) {\n            context.date = date;\n\n            // The validityFn needs to see the proposed value.\n            // Consult our snap config to see if we should be dragging in snapped mode\n            context[toSet] = me.showExactResizePosition || client.timeAxisViewModel.snap ? context.snappedDate : date;\n\n            // Snapping would take it to zero size - this is not allowed in drag resizing.\n            if (!(context[toSet] - context[toSet === 'startDate' ? 'endDate' : 'startDate']) && !me.allowResizeToZero) {\n                context.valid = false;\n                return;\n            }\n\n            // If the date to push into the record is new...\n            if (eventRecord.get(toSet) - context[toSet]) {\n                context.valid = me.checkValidity(context, event);\n                context.message = '';\n\n                if (context.valid && typeof context.valid !== 'boolean') {\n                    context.message = context.valid.message;\n                    context.valid = context.valid.valid;\n                }\n\n                // If users returns nothing, that's interpreted as valid\n                context.valid = (context.valid !== false);\n\n                // Only update the event if the validation passed.\n                if (context.valid) {\n                    const partialResizeEvent = {\n                        [`${name}Record`] : eventRecord,\n                        startDate         : eventStart,\n                        endDate           : eventEnd,\n                        element           : drag.itemElement,\n                        context\n                    };\n\n                    // Update the event we are about to fire and the context *before* we update the record\n                    partialResizeEvent[toSet] = context[toSet];\n\n                    // Trigger eventPartialResize or taskPartialResize depending on product\n                    me.triggerEventPartialResize(`${name}PartialResize`, partialResizeEvent);\n\n                    // An occurrence must have a store to announce its batched changes through.\n                    // They must usually never have a store - they are transient, but we\n                    // need to update the UI.\n                    if (isOccurrence) {\n                        eventRecord.stores.push(client.eventStore);\n                    }\n\n                    // Update the eventRecord.\n                    // Use setter rather than accessor so that in a Project, the entity's\n                    // accessor doesn't propagate the change to the whole project.\n                    // Scheduler must not animate this.\n                    client.enableEventAnimations = false;\n\n                    this.resizeEventPartiallyInternal(eventRecord, context);\n\n                    client.enableEventAnimations = enableEventAnimations;\n\n                    if (isOccurrence) {\n                        eventRecord.stores.length = 0;\n                    }\n                }\n\n                // Flag drag created too narrow events as invalid late, want all code above to execute for them\n                // to get the proper size rendered\n                if (context.tooNarrow) {\n                    context.valid = false;\n                }\n            }\n        }\n\n        if (tip) {\n            // In case of edge flip (EventDragCreate), the align point may change\n            tip.align = tipAlign[context.edge];\n            tip.alignTo(me.getTooltipTarget(drag));\n        }\n\n        super.moveDrag(drag);\n    }\n\n    dragEnd(drag) {\n        const { context } = drag;\n\n        if (context) {\n            context.event = drag.event;\n        }\n\n        if (drag.aborted) {\n            context?.finalize(false);\n        }\n        // 062_resize.t.js specifies that if drag was not started but the mouse has moved,\n        // the eventresizestart and eventresizeend must fire\n        else if (!this.isEventDragCreate && !drag.started && !EventHelper.getPagePoint(drag.event).equals(EventHelper.getPagePoint(drag.startEvent))) {\n            this.dragStart(drag);\n            this.cleanup(drag.context, false);\n        }\n    }\n\n    async dragDrop({ context, event }) {\n        // Set the start/end date, whichever we were dragging\n        // to the correctly rounded value before updating.\n        context[context.toSet] = context.snappedDate;\n\n        const\n            {\n                client\n            } = this,\n            {\n                startDate,\n                endDate\n            } = context;\n\n        let modified;\n\n        this.tip?.hide();\n\n        context.valid = startDate && endDate && (this.allowResizeToZero || (endDate - startDate > 0)) && // Input sanity check\n            (context[context.toSet] - context.oldValue) && // Make sure dragged end end changed\n            context.valid !== false;\n\n        if (context.valid) {\n            // Seems to be a valid resize operation, ask outside world if anyone wants to take control over the finalizing,\n            // to show a confirm dialog prior to applying the new values. Triggers beforeEventResizeFinalize or\n            // beforeTaskResizeFinalize depending on product\n            this.triggerBeforeEventResizeFinalize(`before${client.capitalizedEventName}ResizeFinalize`, { context, event, [`${client.scheduledEventName}Record`] : context.eventRecord });\n            modified = true;\n        }\n\n        // If a handler has set the async flag, it means that they are going to finalize\n        // the operation at some time in the future, so we should not call it.\n        if (!context.async) {\n            await context.finalize(modified);\n        }\n    }\n\n    // This is called with a thisObj of the context object\n    // We set \"me\" to the owner, and \"context\" to the thisObj so that it\n    // reads as if it were a method of this class.\n    async finalize(updateRecord) {\n        const\n            me      = this.owner,\n            context = this,\n            {\n                eventRecord,\n                oldValue,\n                toSet\n            }       = context,\n            {\n                snapRelativeToEventStartDate,\n                timeAxis\n            }       = me.client;\n\n        let wasChanged = false;\n\n        if (updateRecord) {\n            if (snapRelativeToEventStartDate) {\n                context[toSet] = context.snappedDate = timeAxis.roundDate(context.date, oldValue);\n            }\n\n            // Each product updates the record differently\n            wasChanged = await me.internalUpdateRecord(context, eventRecord);\n        }\n        else {\n            // Reverts the changes, a batchedUpdate event will fire which will reset the UI\n            me.cancelEventRecordBatch(eventRecord);\n\n            // Manually trigger redraw of occurrences since they are not part of any stores\n            if (eventRecord.isOccurrence) {\n                eventRecord.resources.forEach(resource => me.client.repaintEventsForResource(resource));\n            }\n        }\n\n        me.cleanup(context, wasChanged);\n    }\n\n    // This is always called on drop or abort.\n    cleanup(context, changed) {\n        const\n            me               = this,\n            { client }       = me,\n            {\n                element,\n                eventRecord\n            }                = context,\n            name             = client.scheduledEventName;\n\n        // The record must know that it is being resized.\n        eventRecord.meta.isResizing = false;\n\n        client.endListeningForBatchedUpdates();\n        me.tip?.hide();\n        me.unHighlightHandle(element);\n        client.element.classList.remove(...me.dragActiveCls.split(' '));\n        // if (dependencies) {\n        //     // When resizing is done and mouse is over element, we show terminals\n        //     if (element.matches(':hover')) {\n        //         dependencies.showTerminals(eventRecord, element);\n        //     }\n        // }\n\n        // Triggers eventResizeEnd or taskResizeEnd depending on product\n        me.triggerEventResizeEnd(`${name}ResizeEnd`, {\n            changed,\n            [`${name}Record`] : eventRecord,\n            ...me.getResizeEndParams(context)\n        });\n    }\n\n    async internalUpdateRecord(context, timespanRecord) {\n        const\n            { client }     = this,\n            { generation } = timespanRecord;\n\n        // Special handling of occurrences, they need normalization since that is not handled by engine at the moment\n        if (timespanRecord.isOccurrence) {\n            client.endListeningForBatchedUpdates();\n\n            // If >1 level deep, just unwind one level.\n            timespanRecord[timespanRecord.batching > 1 ? 'endBatch' : 'cancelBatch']();\n            timespanRecord.set(TimeSpan.prototype.inSetNormalize.call(timespanRecord, {\n                startDate : context.startDate,\n                endDate   : context.endDate\n            }));\n        }\n        else {\n            const toSet = {\n                [context.toSet] : context[context.toSet]\n            };\n\n            // If we have the Engine available, consult it to calculate a corrected duration.\n            // Adjust the dragged date point to conform with the calculated duration.\n            if (timespanRecord.isEntity) {\n                const\n                    {\n                        startDate,\n                        endDate,\n                        draggingEnd\n                    } = context;\n\n                // Fix the duration according to the Entity's rules.\n                context.duration = toSet.duration = timespanRecord.run('calculateProjectedDuration', startDate, endDate);\n\n                // Fix the dragged date point according to the Entity's rules.\n                toSet[context.toSet] = timespanRecord.run('calculateProjectedXDateWithDuration', draggingEnd ? startDate : endDate, draggingEnd, context.duration);\n\n                const setOtherEnd = !timespanRecord[context.otherEnd];\n\n                // Set all values, start and end in case they had never been set\n                // ie, we're now scheduling a previously unscheduled event.\n                if (setOtherEnd) {\n                    toSet[context.otherEnd] = context[context.otherEnd];\n                }\n\n                // Update the record to its final correct state using *batched changes*\n                // These will *not* be propagated, it's just to force the dragged event bar\n                // into its corrected shape before the real changes which will propagate are applied below.\n                // We MUST do it like this because the final state may not be a net change if the changes\n                // got rejected, and in that case, the engine will not end up firing any change events.\n                timespanRecord.set(toSet);\n\n                // Quit listening for batchedUpdate *before* we cancel the batch so that the\n                // change events from the revert do not update the UI.\n                client.endListeningForBatchedUpdates();\n\n                this.cancelEventRecordBatch(timespanRecord);\n\n                // Clear estimated wrap date, exact wrap date will be calculated when referred to from renderer\n                if (client.features.eventBuffer?.enabled) {\n                    timespanRecord[context.wrapToSet] = null;\n                }\n\n                const promisesToWait = [];\n\n                // Really update the data after cancelling the batch\n                if (setOtherEnd) {\n                    promisesToWait.push(timespanRecord[context.setOtherMethod](toSet[context.otherEnd], false));\n                }\n\n                promisesToWait.push(timespanRecord[context.setMethod](toSet[context.toSet], false));\n\n                await Promise.all(promisesToWait);\n\n                timespanRecord.endBatch();\n            }\n            else {\n                // Collect any changes (except the start/end date) that happened during the resize operation\n                const batchChanges = Object.assign({}, timespanRecord.meta.batchChanges);\n                delete batchChanges[context.toSet];\n                client.endListeningForBatchedUpdates();\n\n                this.cancelEventRecordBatch(timespanRecord);\n\n                timespanRecord.set(batchChanges);\n                timespanRecord[context.setMethod](toSet[context.toSet], false);\n            }\n        }\n\n        // wait for project data update\n        await client.project.commitAsync();\n\n        // If the record has been changed\n        return timespanRecord.generation !== generation;\n    }\n\n    onDragItemMouseMove(event) {\n        if (event.pointerType !== 'touch' && !this.handleSelector) {\n            this.checkResizeHandles(event);\n        }\n    }\n\n    /**\n     * Check if mouse is over a resize handle (virtual). If so, highlight.\n     * @private\n     * @param {MouseEvent} event\n     */\n    checkResizeHandles(event) {\n        const\n            me           = this,\n            { overItem } = me;\n\n        // mouse over a target element and allowed to resize?\n        if (overItem && !me.client.readOnly && (!me.allowResize || me.allowResize(overItem, event))) {\n            const eventRecord = me.client.resolveTimeSpanRecord(overItem);\n\n            if (eventRecord?.readOnly) {\n                return;\n            }\n\n            if (me.isOverAnyHandle(event, overItem)) {\n                me.highlightHandle(); // over handle\n            }\n            else {\n                me.unHighlightHandle(); // not over handle\n            }\n        }\n    }\n\n    onDragItemMouseLeave(event, oldOverItem) {\n        this.unHighlightHandle(oldOverItem);\n    }\n\n    /**\n     * Highlights handles (applies css that changes cursor).\n     * @private\n     */\n    highlightHandle() {\n        const\n            {\n                overItem : item,\n                client\n            }      = this,\n            handleTargetElement = item.syncIdMap?.[client.scheduledEventName] ?? item.querySelector(client.eventInnerSelector);\n\n        // over a handle, add cls to change cursor\n        handleTargetElement.classList.add('b-resize-handle');\n        item.classList.add('b-over-resize-handle');\n    }\n\n    /**\n     * Unhighlight handles (removes css).\n     * @private\n     */\n    unHighlightHandle(item = this.overItem) {\n        if (item) {\n            const\n                me    = this,\n                inner = item.syncIdMap?.[me.client.scheduledEventName] ?? item.querySelector(me.client.eventInnerSelector);\n\n            if (inner) {\n                inner.classList.remove('b-resize-handle', me.resizingItemInnerCls);\n            }\n\n            item.classList.remove('b-over-resize-handle', me.draggingItemCls);\n        }\n    }\n\n    isOverAnyHandle(event, target) {\n        return this.isOverStartHandle(event, target) || this.isOverEndHandle(event, target);\n    }\n\n    isOverStartHandle(event, target) {\n        return this.getHandleRect('start', event, target)?.contains(EventHelper.getPagePoint(event));\n    }\n\n    isOverEndHandle(event, target) {\n        return this.getHandleRect('end', event, target)?.contains(EventHelper.getPagePoint(event));\n    }\n\n    getHandleRect(side, event, eventEl) {\n        if (this.overItem) {\n            eventEl = event.target.closest(`.${this.client.eventCls}`) || eventEl.querySelector(`.${this.client.eventCls}`);\n            if (!eventEl) {\n                return;\n            }\n\n            const\n                me              = this,\n                start           = side === 'start',\n                { client }      = me,\n                rtl             = Boolean(client.rtl),\n                axis            = me.dragLock,\n                horizontal      = axis === 'x',\n                dim             = horizontal ? 'width' : 'height',\n                handleSpec      = `${horizontal ? (start && !rtl) ? 'left' : 'right' : start ? 'top' : 'bottom'}Handle`,\n                { offsetWidth } = eventEl,\n                timespanRecord  = client.resolveTimeSpanRecord(eventEl),\n                resizable       = timespanRecord?.isResizable,\n                eventRect       = Rectangle.from(eventEl),\n                result          = eventRect.clone(),\n                handleStyle     = window.getComputedStyle(eventEl, ':before'),\n                // Larger draggable zones on pure touch devices with no mouse\n                touchHandleSize = (!me.handleSelector && !BrowserHelper.isHoverableDevice) ? me.touchHandleSize : undefined,\n                handleSize      = touchHandleSize || me.handleSize || parseFloat(handleStyle[dim]),\n                handleVisThresh = me.handleVisibilityThreshold || 2 * me.handleSize,\n                centerGap       = me.dynamicHandleSize ? me.reservedSpace / 2 : 0,\n                deflateArgs     = [0, 0, 0, 0];\n\n            // To decide if we are over a valid handle, we first check disabled state\n            // Then this.leftHandle/this.rightHandle/this.topHandle/this.bottomHandle\n            // Then whether there's enough event bar width to accommodate separate handles\n            // Then whether the event itself allows resizing at the specified side.\n            if (!me.disabled && me[handleSpec] && (offsetWidth >= handleVisThresh || me.dynamicHandleSize) && (resizable === true || resizable === side)) {\n                const oppositeEnd = (!horizontal && !start) || (horizontal && (rtl  === start));\n\n                if (oppositeEnd) {\n                    // Push handle start point to other end and clip result to other end\n                    result[axis] += (eventRect[dim] - handleSize);\n                    deflateArgs[horizontal ? 3 : 0] = eventRect[dim] / 2 + centerGap;\n                }\n                else {\n                    deflateArgs[horizontal ? 1 : 2] = eventRect[dim] / 2 + centerGap;\n                }\n\n                // Deflate the event bar rectangle to encapsulate 2px less than the side's own half\n                // so that we can constrain the handle zone to be inside its own half when bar is small.\n                eventRect.deflate(...deflateArgs);\n                result[dim] = handleSize;\n\n                // Constrain handle rectangles to each side so that they can never collide.\n                // Each handle is constrained into its own half.\n                result.constrainTo(eventRect);\n\n                // Zero sized handles cannot be hovered\n                if (result[dim]) {\n                    return result;\n                }\n            }\n        }\n    }\n\n    setupDragContext(event) {\n        const me = this;\n\n        // Only start a drag if we are over a handle zone.\n        if (me.overItem && me.isOverAnyHandle(event, me.overItem) && me.isElementResizable(me.overItem, event)) {\n            const result = super.setupDragContext(event);\n\n            result.scrollManager = me.client.scrollManager;\n\n            return result;\n        }\n    }\n\n    changeHandleSize() {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Handle size is from CSS');\n    }\n\n    changeTouchHandleSize() {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Handle size is from CSS');\n    }\n\n    changeTip(tip, oldTip) {\n        const me = this;\n\n        if (!me.showTooltip) {\n            return null;\n        }\n\n        if (tip) {\n            if (tip.isTooltip) {\n                tip.owner = me;\n            }\n            else {\n                tip = Tooltip.reconfigure(oldTip, Tooltip.mergeConfigs({\n                    id : me.tipId\n                }, tip, {\n                    getHtml : me.getTipHtml.bind(me),\n                    owner   : me.client\n                }, me.tip), {\n                    owner    : me,\n                    defaults : {\n                        type : 'tooltip'\n                    }\n                });\n            }\n\n            tip.ion({\n                innerhtmlupdate : 'updateDateIndicator',\n                thisObj         : me\n            });\n\n            me.clockTemplate = new ClockTemplate({\n                scheduler : me.client\n            });\n        }\n        else if (oldTip) {\n            oldTip.destroy();\n            me.clockTemplate?.destroy();\n        }\n\n        return tip;\n    }\n\n    //endregion\n\n    //region Events\n\n    isElementResizable(element, event) {\n        const\n            me             = this,\n            { client }     = me,\n            timespanRecord = client.resolveTimeSpanRecord(element);\n\n        if (client.readOnly) {\n            return false;\n        }\n\n        let resizable = timespanRecord?.isResizable;\n\n        // Not resizable if the mousedown is on a resizing handle of\n        // a percent bar.\n        const\n            handleHoldingElement = element?.syncIdMap[client.scheduledEventName] ?? element,\n            handleEl             = event.target.closest('[class$=\"-handle\"]');\n\n        if (!resizable || (handleEl && handleEl !== handleHoldingElement)) {\n            return false;\n        }\n\n        element = event.target.closest(me.dragSelector);\n\n        if (!element) {\n            return false;\n        }\n\n        const\n            startsOutside = element.classList.contains('b-sch-event-startsoutside'),\n            endsOutside   = element.classList.contains('b-sch-event-endsoutside');\n\n        if (resizable === true) {\n            if (startsOutside && endsOutside) {\n                return false;\n            }\n            else if (startsOutside) {\n                resizable = 'end';\n            }\n            else if (endsOutside) {\n                resizable = 'start';\n            }\n            else {\n                return me.isOverStartHandle(event, element) || me.isOverEndHandle(event, element);\n            }\n        }\n\n        if (\n            (startsOutside && resizable === 'start') ||\n            (endsOutside && resizable === 'end')\n        ) {\n            return false;\n        }\n\n        if (\n            (me.isOverStartHandle(event, element) && resizable === 'start') ||\n            (me.isOverEndHandle(event, element) && resizable === 'end')\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    updateDateIndicator() {\n        const\n            { clockTemplate } = this,\n            {\n                eventRecord,\n                draggingEnd,\n                snappedDate\n            }                 = this.dragging.context,\n            startDate         = draggingEnd ? eventRecord.get('startDate') : snappedDate,\n            endDate           = draggingEnd ? snappedDate : eventRecord.get('endDate'),\n            { element }       = this.tip;\n\n        clockTemplate.updateDateIndicator(element.querySelector('.b-sch-tooltip-startdate'), startDate);\n        clockTemplate.updateDateIndicator(element.querySelector('.b-sch-tooltip-enddate'), endDate);\n    }\n\n    getTooltipTarget({ itemElement, context }) {\n        const\n            me      = this,\n            { rtl } = me.client,\n            target  = Rectangle.from(itemElement, null, true);\n\n        if (me.dragLock === 'x') {\n            // Align to the dragged edge of the proxy, and then bump right so that the anchor aligns perfectly.\n            if ((!rtl && context.edge === 'right') || (rtl && context.edge === 'left')) {\n                target.x = target.right - 1;\n            }\n            else {\n                target.x -= me.tip.anchorSize[0] / 2;\n            }\n            target.width = me.tip.anchorSize[0] / 2;\n        }\n        else {\n            // Align to the dragged edge of the proxy, and then bump bottom so that the anchor aligns perfectly.\n            if (context.edge === 'bottom') {\n                target.y = target.bottom - 1;\n            }\n            target.height = me.tip.anchorSize[1] / 2;\n        }\n\n        return { target };\n    }\n\n    basicValidityCheck(context, event) {\n        return context.startDate &&\n            (context.endDate > context.startDate || this.allowResizeToZero) &&\n            this.validatorFn.call(this.validatorFnThisObj || this, context, event);\n    }\n\n    //endregion\n\n    //region Tooltip\n\n    getTipHtml({ tip }) {\n        const\n            me = this,\n            {\n                startDate,\n                endDate,\n                toSet,\n                snappedDate,\n                valid,\n                message = '',\n                timespanRecord\n            }  = me.dragging.context;\n\n        // Empty string hides the tip - we get called before the Resizer, so first call will be empty\n        if (!startDate || !endDate) {\n            return tip.html;\n        }\n\n        // Set whichever one we are moving\n        const tipData = {\n            record  : timespanRecord,\n            valid,\n            message,\n            startDate,\n            endDate,\n            [toSet] : snappedDate\n        };\n\n        // Format the two ends. This has to be done outside of the object initializer\n        // because they use properties that are only in the tipData object.\n        tipData.startText = me.client.getFormattedDate(tipData.startDate);\n        tipData.endText = me.client.getFormattedDate(tipData.endDate);\n        tipData.startClockHtml = me.clockTemplate.template({\n            date : tipData.startDate,\n            text : tipData.startText,\n            cls  : 'b-sch-tooltip-startdate'\n        });\n        tipData.endClockHtml = me.clockTemplate.template({\n            date : tipData.endDate,\n            text : tipData.endText,\n            cls  : 'b-sch-tooltip-enddate'\n        });\n\n        return me.tooltipTemplate(tipData);\n    }\n\n    //endregion\n\n    //region Product specific, may be overridden in subclasses\n\n    beginEventRecordBatch(eventRecord) {\n        eventRecord.beginBatch();\n    }\n\n    cancelEventRecordBatch(eventRecord) {\n        // Reverts the changes, a batchedUpdate event will fire which will reset the UI\n        eventRecord.cancelBatch();\n    }\n\n    getBeforeResizeParams(context) {\n        const { client } = this;\n\n        return {\n            resourceRecord : client.resolveResourceRecord(client.isVertical ? context.event : context.element)\n        };\n    }\n\n    getResizeStartParams(context) {\n        return {\n            resourceRecord : context.resourceRecord\n        };\n    }\n\n    getResizeEndParams(context) {\n        return {\n            resourceRecord : context.resourceRecord,\n            event          : context.event\n        };\n    }\n\n    setupProductResizeContext(context, event) {\n        const\n            { client }       = this,\n            { element }      = context,\n            eventRecord      = client.resolveEventRecord(element),\n            resourceRecord   = client.resolveResourceRecord?.(element),\n            assignmentRecord = client.resolveAssignmentRecord?.(element);\n\n        Object.assign(context, {\n            eventRecord,\n            taskRecord      : eventRecord,\n            resourceRecord,\n            assignmentRecord,\n            dateConstraints : client.getDateConstraints?.(resourceRecord, eventRecord)\n        });\n    }\n\n    checkValidity(context, event) {\n        return (\n            this.client.allowOverlap ||\n            this.client.isDateRangeAvailable(context.startDate, context.endDate, context.eventRecord, context.resourceRecord)\n        ) && this.basicValidityCheck(context, event);\n    }\n\n    get tipId() {\n        return `${this.client.id}-event-resize-tip`;\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(EventResize, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventResize, false, 'ResourceHistogram');\n","import EventResize from '../EventResize.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport Draggable from '../../../Core/mixin/Draggable.js';\n\n/**\n * @module Scheduler/feature/base/DragCreateBase\n */\nconst getDragCreateDragDistance = function(event) {\n    // Do not allow the drag to begin if the taskEdit feature (if present) is in the process\n    // of canceling. We must wait for it to have cleaned up its data manipulations before\n    // we can add the new, drag-created record\n    if (this.source?.client.features.taskEdit?._canceling) {\n        return false;\n    }\n    return EventHelper.getDistanceBetween(this.startEvent, event);\n};\n\n/**\n * Base class for EventDragCreate (Scheduler) and TaskDragCreate (Gantt) features. Contains shared code. Not to be used directly.\n *\n * @extends Scheduler/feature/EventResize\n */\nexport default class DragCreateBase extends EventResize {\n    //region Config\n\n    static configurable = {\n        /**\n         * true to show a time tooltip when dragging to create a new event\n         * @config {Boolean}\n         * @default\n         */\n        showTooltip : true,\n\n        /**\n         * Number of pixels the drag target must be moved before dragging is considered to have started. Defaults to 2.\n         * @config {Number}\n         * @default\n         */\n        dragTolerance : 2,\n\n        // used by gantt to only allow one task per row\n        preventMultiple : false,\n\n        dragTouchStartDelay : 300,\n\n        /**\n         * `this` reference for the validatorFn\n         * @config {Object}\n         */\n        validatorFnThisObj : null,\n\n        tipTemplate : data => `\n            <div class=\"b-sch-tip-${data.valid ? 'valid' : 'invalid'}\">\n                ${data.startClockHtml}\n                ${data.endClockHtml}\n                <div class=\"b-sch-tip-message\">${data.message}</div>\n            </div>\n        `,\n\n        dragActiveCls : 'b-dragcreating'\n    }\n\n    static pluginConfig = {\n        chain  : ['render', 'onEventDataGenerated'],\n        before : ['onElementContextMenu']\n    }\n\n    construct(scheduler, config) {\n        if (config?.showTooltip === false) {\n            config.tip = null;\n        }\n        super.construct(...arguments);\n    }\n\n    //endregion\n\n    changeValidatorFn(validatorFn) {\n        // validatorFn property is used by the EventResize base to validate each mousemove\n        // We change the property name to createValidatorFn\n        this.createValidatorFn = validatorFn;\n    }\n\n    render() {\n        const\n            me         = this,\n            { client } = me;\n\n        // Set up elements and listeners\n        me.dragRootElement = me.dropRootElement = client.timeAxisSubGridElement;\n\n        // Drag only in time dimension\n        me.dragLock = client.isVertical ? 'y' : 'x';\n    }\n\n    onDragEndSwitch(context) {\n        const\n            { client }                = this,\n            { enableEventAnimations } = client,\n            {\n                eventRecord,\n                draggingEnd\n            }                         = context,\n            horizontal                = this.dragLock === 'x',\n            { initialDate }           = this.dragging;\n\n        // Setting the new opposite end should not animate\n        client.enableEventAnimations = false;\n\n        // Zero duration at the moment of the flip\n        eventRecord.set({\n            startDate : initialDate,\n            endDate   : initialDate\n        });\n\n        // We're switching to dragging the start\n        if (draggingEnd) {\n            Object.assign(context, {\n                endDate        : initialDate,\n                toSet          : 'startDate',\n                otherEnd       : 'endDate',\n                setMethod      : 'setStartDate',\n                setOtherMethod : 'setEndDate',\n                edge           : horizontal ? 'left' : 'top'\n            });\n        }\n        else {\n            Object.assign(context, {\n                startDate      : initialDate,\n                toSet          : 'endDate',\n                otherEnd       : 'startDate',\n                setMethod      : 'setEndDate',\n                setOtherMethod : 'setStartDate',\n                edge           : horizontal ? 'right' : 'bottom'\n            });\n        }\n\n        context.draggingEnd = this.draggingEnd = !draggingEnd;\n        client.enableEventAnimations = enableEventAnimations;\n    }\n\n    beforeDrag(drag) {\n        const\n            me                       = this,\n            result                   = super.beforeDrag(drag),\n            { pan, eventDragSelect } = me.client.features;\n\n        // Superclass's handler may also veto\n        if (result !== false && (\n            // used by gantt to only allow one task per row\n            (me.preventMultiple && !me.isRowEmpty(drag.rowRecord)) ||\n            me.disabled ||\n            // If Pan is enabled, it has right of way\n            (pan && !pan.disabled) ||\n            // If EventDragSelect is enabled, it has right of way\n            (eventDragSelect && !eventDragSelect.disabled)\n        )) {\n            return false;\n        }\n\n        return result;\n    }\n\n    startDrag(drag) {\n        const result = super.startDrag(drag);\n\n        // Returning false means operation is aborted.\n        if (result !== false) {\n            const { context } = drag;\n\n            // Date to flip around when changing direction\n            drag.initialDate = context.eventRecord.get(this.draggingEnd ? 'startDate' : 'endDate');\n\n            this.client.trigger('dragCreateStart', {\n                proxyElement   : drag.element,\n                eventElement   : drag.element,\n                eventRecord    : context.eventRecord,\n                resourceRecord : context.resourceRecord\n            });\n\n            // We are always dragging the exact edge of the event element.\n            drag.context.offset   = 0;\n            drag.context.oldValue = drag.mousedownDate;\n        }\n        return result;\n    }\n\n    // Used by our EventResize superclass to know whether the drag point is the end or the beginning.\n    isOverEndHandle() {\n        return this.draggingEnd;\n    }\n\n    setupDragContext(event) {\n        const { client } = this;\n\n        // Only mousedown on an empty cell can initiate drag-create\n        if (client.matchScheduleCell(event.target)) {\n            const resourceRecord = client.resolveResourceRecord(event)?.$original;\n\n            // And there must be a resource backing the cell.\n            if (resourceRecord && !resourceRecord.isSpecialRow) {\n                // Skip the EventResize's setupDragContext. We want the base one.\n                const\n                    result      = Draggable().prototype.setupDragContext.call(this, event),\n                    scrollables = [];\n\n                if (client.isVertical) {\n                    scrollables.push({\n                        element   : client.scrollable.element,\n                        direction : 'vertical'\n                    });\n                }\n                else {\n                    scrollables.push({\n                        element   : client.timeAxisSubGrid.scrollable.element,\n                        direction : 'horizontal'\n                    });\n                }\n\n                result.scrollManager = client.scrollManager;\n                result.monitoringConfig = { scrollables };\n                result.resourceRecord = result.rowRecord = resourceRecord;\n\n                // We use a special method to get the distance moved.\n                // If the TaskEdit feature is still in its canceling phase, then\n                // it returns false which inhibits the start of the drag-create\n                // until the cancelation is complete.\n                result.getDistance = getDragCreateDragDistance;\n                return result;\n            }\n        }\n    }\n\n    async dragDrop({ context, event }) {\n        // Set the start/end date, whichever we were dragging\n        // to the correctly rounded value before updating.\n        context[context.toSet] = context.snappedDate;\n\n        const\n            {\n                client\n            } = this,\n            {\n                startDate,\n                endDate,\n                eventRecord\n            } = context,\n            { generation } = eventRecord;\n\n        let modified;\n\n        this.tip?.hide();\n\n        // Handle https://github.com/bryntum/support/issues/3210.\n        // The issue arises when the mouseup arrives very quickly and the commit kicked off\n        // at event add has not yet completed. If it now completes *after* we finalize\n        // the drag, it will reset the event to its initial state.\n        // If that commit has in fact finished, this will be a no-op\n        await client.project.commitAsync();\n\n        // If the above commit in fact reset the event back to the initial state, we have to\n        // force the event rendering to bring it back to the currently known context state.\n        if (eventRecord.generation !== generation) {\n            context.eventRecord[context.toSet] = context.oldValue;\n            context.eventRecord[context.toSet] = context[context.toSet];\n        }\n\n        context.valid = startDate && endDate && (endDate - startDate > 0) && // Input sanity check\n            (context[context.toSet] - context.oldValue) && // Make sure dragged end end changed\n            context.valid !== false;\n\n        if (context.valid) {\n            // Seems to be a valid drag-create operation, ask outside world if anyone wants to take control over the finalizing,\n            // to show a confirm dialog prior to finalizing the create.\n            client.trigger('beforeDragCreateFinalize', {\n                context,\n                event,\n                proxyElement   : context.element,\n                eventElement   : context.element,\n                eventRecord    : context.eventRecord,\n                resourceRecord : context.resourceRecord\n            });\n            modified = true;\n        }\n\n        // If a handler has set the async flag, it means that they are going to finalize\n        // the operation at some time in the future, so we should not call it.\n        if (!context.async) {\n            await context.finalize(modified);\n        }\n    }\n\n    updateDragTolerance(dragTolerance) {\n        this.dragThreshold = dragTolerance;\n    }\n\n    //region Tooltip\n\n    changeTip(tip, oldTip) {\n        return super.changeTip(!tip || tip.isTooltip ? tip : ObjectHelper.assign({\n            id : `${this.client.id}-drag-create-tip`\n        }, tip), oldTip);\n    }\n\n    //endregion\n\n    //region Finalize (create EventModel)\n\n    async finalize(doCreate) {\n        const\n            me                = this.owner,\n            context           = this,\n            completeFinalization = () => {\n                if (!me.isDestroyed) {\n                    me.client.trigger('afterDragCreate', {\n                        proxyElement   : context.element,\n                        eventElement   : context.element,\n                        eventRecord    : context.eventRecord,\n                        resourceRecord : context.resourceRecord\n                    });\n                    me.cleanup(context);\n                }\n            };\n\n        if (doCreate) {\n            // Call product specific implementation\n            await me.finalizeDragCreate(context);\n\n            completeFinalization();\n        }\n        // Aborting without going ahead with create - we must deassign and remove the event\n        else {\n            me.onAborted?.(context);\n            completeFinalization();\n        }\n    }\n\n    async finalizeDragCreate(context) {\n        // EventResize base class applies final changes to the event record\n        await this.internalUpdateRecord(context, context.eventRecord);\n\n        this.client.trigger('dragCreateEnd', {\n            eventRecord    : context.eventRecord,\n            resourceRecord : context.resourceRecord,\n            event          : context.event,\n            eventElement   : context.element\n        });\n        // Part of the Scheduler API. Triggered by its createEvent method.\n        // Auto-editing features can use this to edit new events.\n        // Note that this may be destroyed by a listener of the previous event.\n        this.client?.trigger('eventAutoCreated', {\n            eventRecord    : context.eventRecord,\n            resourceRecord : context.resourceRecord\n        });\n    }\n\n    cleanup(context) {\n        const\n            { client }      = this,\n            { eventRecord } = context;\n\n        // Base class's cleanup is not called, we have to clear this flag.\n        // The isCreating flag is only set if the event is to be handed off to the\n        // eventEdit feature and that feature then has responsibility for clearing it.\n        eventRecord.meta.isResizing = false;\n\n        client.endListeningForBatchedUpdates();\n        this.tip?.hide();\n        client.element.classList.remove(...this.dragActiveCls.split(' '));\n\n        context.element.parentElement.classList.remove('b-sch-dragcreating');\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Prevent right click when drag creating\n     * @returns {Boolean}\n     * @private\n     */\n    onElementContextMenu() {\n        if (this.proxy) {\n            return false;\n        }\n    }\n\n    prepareCreateContextForFinalization(createContext, event, finalize, async = false) {\n        return {\n            ...createContext,\n            async,\n            event,\n            finalize\n        };\n    }\n\n    // Apply drag create \"proxy\" styling\n    onEventDataGenerated(renderData) {\n        if (this.dragging?.context?.eventRecord === renderData.eventRecord) {\n            // Allow custom styling for drag creation element\n            renderData.wrapperCls['b-sch-dragcreating'] = true;\n            // Styling when drag create will be aborted on drop (because it would yield zero duration)\n            renderData.wrapperCls['b-too-narrow'] = this.dragging.context.tooNarrow;\n        }\n    }\n\n    //endregion\n\n    //region Product specific, implemented in subclasses\n\n    // Empty implementation here. Only base EventResize class triggers this\n    triggerBeforeResize() {}\n\n    // Empty implementation here. Only base EventResize class triggers this\n    triggerEventResizeStart() {}\n\n    checkValidity(context, event) {\n        throw new Error('Implement in subclass');\n    }\n\n    triggerDragCreateEnd(newRecord, context) {\n        throw new Error('Implement in subclass');\n    }\n\n    handleBeforeDragCreate(dateTime, event) {\n        throw new Error('Implement in subclass');\n    }\n\n    isRowEmpty(rowRecord) {\n        throw new Error('Implement in subclass');\n    }\n\n    //endregion\n}\n","import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport Tooltip from '../../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../../tooltip/ClockTemplate.js';\n\n/**\n * @module Scheduler/feature/base/TooltipBase\n */\n\n/**\n * Base class for `EventTooltip` (Scheduler) and `TaskTooltip` (Gantt) features. Contains shared code. Not to be used directly.\n *\n * @extends Core/mixin/InstancePlugin\n * @extendsconfigs Core/widget/Tooltip\n */\nexport default class TooltipBase extends InstancePlugin {\n    //region Config\n\n    static get defaultConfig() {\n        return {\n\n            /**\n             * Specify true to have tooltip updated when mouse moves, if you for example want to display date at mouse\n             * position.\n             * @config {Boolean}\n             * @default\n             * @category Misc\n             */\n            autoUpdate : false,\n\n            /**\n             * The amount of time to hover before showing\n             * @config {Number}\n             * @default\n             */\n            hoverDelay : 250,\n\n            /**\n             * The time (in milliseconds) for which the Tooltip remains visible when the mouse leaves the target.\n             *\n             * May be configured as `false` to persist visible after the mouse exits the target element. Configure it\n             * as 0 to always retrigger `hoverDelay` even when moving mouse inside `fromElement`\n             * @config {Number}\n             * @default\n             */\n            hideDelay : 100,\n\n            // TODO: Rename to tooltipTemplate, deprecate template\n            template : null,\n\n            cls : null,\n\n            align : {\n                align : 'b-t'\n            },\n\n            clockTemplate : null,\n\n            // Set to true to update tooltip contents if record changes while tip is open\n            monitorRecordUpdate : null,\n\n            testConfig : {\n                hoverDelay : 0\n            }\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onPaint']\n        };\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Triggered before a tooltip is shown. Return `false` to prevent the action.\n     * @preventable\n     * @event beforeShow\n     * @param {Core.widget.Tooltip} source The tooltip being shown.\n     * @param {Scheduler.model.EventModel} source.eventRecord The event record.\n     */\n\n    /**\n     * Triggered after a tooltip is shown.\n     * @event show\n     * @param {Core.widget.Tooltip} source The tooltip.\n     * @param {Scheduler.model.EventModel} source.eventRecord The event record.\n     */\n\n    //endregion\n\n    //region Init\n\n    construct(client, config) {\n        const me = this;\n\n        // process initial config into an actual config object\n        config = me.processConfig(config);\n\n        super.construct(client, config);\n\n        // Default triggering selector is the client's inner element selector\n        if (!me.forSelector) {\n            me.forSelector = `${client.eventInnerSelector}:not(.b-dragproxy)`;\n        }\n\n        me.clockTemplate = new ClockTemplate({\n            scheduler : client\n        });\n\n        client.ion({\n            [`before${client.scheduledEventName}drag`] : () => {\n                // Using {} on purpose to not return the promise\n                me.tooltip?.hide();\n            }\n        });\n    }\n\n    // TooltipBase feature handles special config cases, where user can supply a function to use as template\n    // instead of a normal config object\n    processConfig(config) {\n        if (typeof config === 'function') {\n            return {\n                template : config\n            };\n        }\n\n        return config;\n    }\n\n    // override setConfig to process config before applying it (used mainly from ReactScheduler)\n    setConfig(config) {\n        super.setConfig(this.processConfig(config));\n    }\n\n    doDestroy() {\n        this.destroyProperties('clockTemplate', 'tooltip');\n\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        if (this.tooltip) {\n            this.tooltip.disabled = disable;\n        }\n\n        super.doDisable(disable);\n    }\n\n    //endregion\n\n    onPaint({ firstPaint }) {\n        if (firstPaint) {\n            const\n                me             = this,\n                { client }     = me,\n                ignoreSelector = [\n                    '.b-dragselecting',\n                    '.b-eventeditor-editing',\n                    '.b-taskeditor-editing',\n                    '.b-resizing-event',\n                    '.b-task-percent-bar-resizing-task',\n                    '.b-dragcreating',\n                    `.b-dragging-${client.scheduledEventName}`,\n                    '.b-creating-dependency',\n                    '.b-dragproxy'\n                ].map(cls => `:not(${cls})`).join('');\n\n            me.tooltip?.destroy();\n\n            /**\n             * A reference to the tooltip instance, which will have a special `eventRecord` property that\n             * you can use to get data from the contextual event record to which this tooltip is related.\n             * @member {Core.widget.Tooltip} tooltip\n             * @readonly\n             * @category Misc\n             */\n            me.tooltip = new Tooltip({\n                axisLock          : 'flexible',\n                id                : me.tipId || `${me.client.id}-event-tip`,\n                cls               : me.tipCls,\n                forSelector       : `.b-timelinebase${ignoreSelector} .b-grid-body-container:not(.b-scrolling) ${me.forSelector}`,\n                scrollAction      : 'realign',\n                forElement        : client.timeAxisSubGridElement,\n                showOnHover       : true,\n                anchorToTarget    : true,\n                getHtml           : me.getTipHtml.bind(me),\n                disabled          : me.disabled,\n                // on Core/mixin/Events constructor, me.config.listeners is deleted and attributed its value to me.configuredListeners\n                // to then on processConfiguredListeners it set me.listeners to our TooltipBase\n                // but since we need our initial config.listeners to set to our internal tooltip, we leave processConfiguredListeners empty\n                // to avoid lost our listeners to apply for our internal tooltip here and force our feature has all Tooltip events firing\n                ...me.config,\n                internalListeners : me.configuredListeners\n            });\n\n            me.tooltip.ion({\n                innerhtmlupdate : 'updateDateIndicator',\n                overtarget      : 'onOverNewTarget',\n                show            : 'onTipShow',\n                hide            : 'onTipHide',\n                thisObj         : me\n            });\n        }\n    }\n\n    //region Listeners\n\n    // leave configuredListeners alone until render time at which they are used on the tooltip\n    processConfiguredListeners() {}\n\n    addListener(...args) {\n        const\n            // Call super method to handle enable/disable feature events\n            defaultDetacher = super.addListener(...args),\n            // Add listener to the `tooltip` instance\n            tooltipDetacher = this.tooltip?.addListener(...args);\n\n        if (defaultDetacher || tooltipDetacher) {\n            return () => {\n                defaultDetacher?.();\n                tooltipDetacher?.();\n            };\n        }\n    }\n\n    removeListener(...args) {\n        super.removeListener(...args);\n\n        // Remove listener from the `tooltip` instance\n        this.tooltip?.removeListener(...args);\n    }\n\n    //endregion\n\n    updateDateIndicator() {\n        const\n            me             = this,\n            tip            = me.tooltip,\n            endDateElement = tip.element.querySelector('.b-sch-tooltip-enddate');\n\n        if (!me.record) {\n            return;\n        }\n\n        me.clockTemplate.updateDateIndicator(tip.element, me.record.startDate);\n\n        endDateElement && me.clockTemplate.updateDateIndicator(endDateElement, me.record.endDate);\n    }\n\n    resolveTimeSpanRecord(forElement) {\n        return this.client.resolveTimeSpanRecord(forElement);\n    }\n\n    getTipHtml({ tip, activeTarget }) {\n        const\n            me             = this,\n            { client }     = me,\n            recordProp     = me.recordType || `${client.scheduledEventName}Record`,\n            timeSpanRecord = me.resolveTimeSpanRecord(activeTarget);\n\n        // If user has mouseovered a fading away element of a deleted event,\n        // an event record will not be found. In this case the tip must hide.\n        // Instance of check is to not display while propagating\n        if (timeSpanRecord?.startDate instanceof Date) {\n            const\n                { startDate, endDate } = timeSpanRecord,\n                startText              = client.getFormattedDate(startDate),\n                endDateValue           = client.getDisplayEndDate(endDate, startDate),\n                endText                = client.getFormattedDate(endDateValue);\n\n            tip.eventRecord = timeSpanRecord;\n\n            return me.template({\n                tip,\n                // eventRecord for Scheduler, taskRecord for Gantt\n                [`${recordProp}`] : timeSpanRecord,\n                startDate,\n                endDate,\n                startText,\n                endText,\n                startClockHtml    : me.clockTemplate.template({\n                    date : startDate,\n                    text : startText,\n                    cls  : 'b-sch-tooltip-startdate'\n                }),\n                endClockHtml : timeSpanRecord.isMilestone ? '' : me.clockTemplate.template({\n                    date : endDateValue,\n                    text : endText,\n                    cls  : 'b-sch-tooltip-enddate'\n                })\n            });\n        }\n        else {\n            tip.hide();\n            return '';\n        }\n    }\n\n    get record() {\n        return this.tooltip.eventRecord;\n    }\n\n    onTipShow() {\n        const me = this;\n\n        if (me.monitorRecordUpdate && !me.updateListener) {\n            me.updateListener = me.client.eventStore.ion({\n                update  : me.onRecordUpdate,\n                thisObj : me\n            });\n        }\n    }\n\n    onTipHide() {\n        // To not retain full project when changing project\n        this.tooltip.eventRecord = null;\n\n        this.updateListener?.();\n        this.updateListener = null;\n    }\n\n    onOverNewTarget({ newTarget }) {\n        this.tooltip.eventRecord = this.resolveTimeSpanRecord(newTarget);\n    }\n\n    onRecordUpdate({ record }) {\n        // make sure the record we are showing the tip for is still relevant\n        if (record === this.record) {\n            // Stop aligning at this point\n            this.tooltip.alignTo();\n            this.tooltip.updateContent();\n        }\n    }\n}\n","import DragHelper from '../../Core/helper/DragHelper.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport ResizeHelper from '../../Core/helper/ResizeHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../tooltip/ClockTemplate.js';\n\n/**\n * @module Scheduler/feature/AbstractTimeRanges\n */\n\n/**\n * Abstract base class, you should not use this class directly.\n * @abstract\n * @mixes Core/mixin/Delayable\n * @extends Core/mixin/InstancePlugin\n */\nexport default class AbstractTimeRanges extends InstancePlugin.mixin(Delayable) {\n    //region Config\n\n    /**\n     * Fired on the owning Scheduler when a click happens on a time range header element\n     * @event timeRangeHeaderClick\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.TimeSpan} timeRangeRecord The record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler when a double click happens on a time range header element\n     * @event timeRangeHeaderDblClick\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.TimeSpan} timeRangeRecord The record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler when a right click happens on a time range header element\n     * @event timeRangeHeaderContextMenu\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.TimeSpan} timeRangeRecord The record\n     * @param {MouseEvent} event Browser event\n     */\n\n    static get defaultConfig() {\n        return {\n            // CSS class to apply to range elements\n            rangeCls : 'b-sch-range',\n\n            // CSS class to apply to line elements (0-duration time range)\n            lineCls : 'b-sch-line',\n\n            /**\n             * Set to `true` to enable dragging and resizing of range elements in the header. Only relevant when\n             * {@link #config-showHeaderElements} is `true`.\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            enableResizing : false,\n\n            /**\n             * A Boolean specifying whether to show tooltip while resizing range elements, or a\n             * {@link Core.widget.Tooltip} config object which is applied to the tooltip\n             * @config {Boolean|TooltipConfig}\n             * @default\n             * @category Common\n             */\n            showTooltip : true,\n\n            /**\n             * Template used to generate the tooltip contents when hovering a time range header element.\n             * ```\n             * const scheduler = new Scheduler({\n             *   features : {\n             *     timeRanges : {\n             *       tooltipTemplate({ timeRange }) {\n             *         return `${timeRange.name}`\n             *       }\n             *     }\n             *   }\n             * });\n             * ```\n             * @config {Function} tooltipTemplate\n             * @param {Object} data Tooltip data\n             * @param {Scheduler.model.TimeSpan} data.timeRange\n             * @category Common\n             */\n            tooltipTemplate : null,\n\n            dragTipTemplate : data => `\n                <div class=\"b-sch-tip-${data.valid ? 'valid' : 'invalid'}\">\n                    <div class=\"b-sch-tip-name\">${StringHelper.encodeHtml(data.name) || ''}</div>\n                    ${data.startClockHtml}\n                    ${data.endClockHtml || ''}\n                </div>\n            `,\n\n            baseCls : 'b-sch-timerange',\n\n            /**\n             * Function used to generate the HTML content for a time range header element.\n             * ```\n             * const scheduler = new Scheduler({\n             *   features : {\n             *     timeRanges : {\n             *       headerRenderer({ timeRange }) {\n             *         return `${timeRange.name}`\n             *       }\n             *     }\n             *   }\n             * });\n             * ```\n             * @config {Function} headerRenderer\n             * @param {Object} data Render data\n             * @param {Scheduler.model.TimeSpan} data.timeRange\n             * @category Common\n             */\n            headerRenderer : null,\n\n            /**\n             * Function used to generate the HTML content for a time range body element.\n             * ```\n             * const scheduler = new Scheduler({\n             *   features : {\n             *     timeRanges : {\n             *       bodyRenderer({ timeRange }) {\n             *         return `${timeRange.name}`\n             *       }\n             *     }\n             *   }\n             * });\n             * ```\n             * @config {Function} bodyRenderer\n             * @param {Object} data Render data\n             * @param {Scheduler.model.TimeSpan} data.timeRange\n             * @category Common\n             */\n            bodyRenderer : null,\n\n            // a unique cls used by subclasses to get custom styling of the elements rendered\n            cls : null,\n\n            narrowThreshold : 80\n        };\n    }\n\n    static configurable = {\n        /**\n         * Set to `false` to not render range elements into the time axis header\n         * @prp {Boolean}\n         * @default\n         * @category Common\n         */\n        showHeaderElements : true\n    };\n\n    // Plugin configuration. This plugin chains some functions in Grid.\n    static pluginConfig = {\n        chain : [\n            'onPaint',\n            'populateTimeAxisHeaderMenu',\n            'onSchedulerHorizontalScroll',\n            'afterScroll',\n            'onInternalResize'\n        ]\n    };\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(client, config) {\n        const me = this;\n\n        super.construct(client, config);\n\n        if (client.isVertical) {\n            client.ion({\n                renderRows : me.onUIReady,\n                thisObj    : me,\n                once       : true\n            });\n        }\n\n        // Add a unique cls used by subclasses to get custom styling of the elements rendered\n        // This makes sure that each class only removed its own elements from the DOM\n        me.cls = me.cls || `b-sch-${me.constructor.$$name.toLowerCase()}`;\n\n        me.baseSelector = `.${me.baseCls}.${me.cls}`;\n\n        // header elements are required for interaction\n        if (me.enableResizing) {\n            me.showHeaderElements = true;\n        }\n    }\n\n    doDestroy() {\n        const me = this;\n\n        me.detachListeners('timeAxisViewModel');\n        me.detachListeners('timeAxis');\n\n        me.clockTemplate?.destroy();\n        me.tip?.destroy();\n\n        me.drag?.destroy();\n        me.resize?.destroy();\n\n        super.doDestroy();\n    }\n\n    doDisable(disable) {\n        this.renderRanges();\n\n        super.doDisable(disable);\n    }\n\n    setupTimeAxisViewModelListeners() {\n        const me = this;\n\n        me.detachListeners('timeAxisViewModel');\n        me.detachListeners('timeAxis');\n\n        me.client.timeAxisViewModel.ion({\n            name    : 'timeAxisViewModel',\n            update  : 'onTimeAxisViewModelUpdate',\n            thisObj : me\n        });\n\n        me.client.timeAxis.ion({\n            name          : 'timeAxis',\n            includeChange : 'renderRanges',\n            thisObj       : me\n        });\n    }\n\n    onUIReady() {\n        const\n            me         = this,\n            { client } = me;\n\n        // If timeAxisViewModel is swapped, re-setup listeners to new instance\n        client.ion({\n            timeAxisViewModelChange : me.setupTimeAxisViewModelListeners,\n            thisObj                 : me\n        });\n\n        me.setupTimeAxisViewModelListeners();\n\n        if (!client.hideHeaders) {\n            if (me.headerContainerElement) {\n                EventHelper.on({\n                    click       : me.onTimeRangeClick,\n                    dblclick    : me.onTimeRangeClick,\n                    contextmenu : me.onTimeRangeClick,\n                    delegate    : me.baseSelector,\n                    element     : me.headerContainerElement,\n                    thisObj     : me\n                });\n            }\n\n            if (me.enableResizing) {\n\n                me.drag = DragHelper.new({\n                    name               : 'rangeDrag',\n                    lockX              : client.isVertical,\n                    lockY              : client.isHorizontal,\n                    constrain          : true,\n                    outerElement       : me.headerContainerElement,\n                    targetSelector     : `${me.baseSelector}`,\n                    isElementDraggable : (el, event) => !client.readOnly && me.isElementDraggable(el, event),\n                    rtlSource          : client,\n\n                    internalListeners : {\n                        dragstart : 'onDragStart',\n                        drag      : 'onDrag',\n                        drop      : 'onDrop',\n                        reset     : 'onDragReset',\n                        abort     : 'onInvalidDrop',\n                        thisObj   : me\n                    }\n                }, me.dragHelperConfig);\n\n                me.resize = ResizeHelper.new({\n                    direction          : client.mode,\n                    targetSelector     : `${me.baseSelector}.b-sch-range`,\n                    outerElement       : me.headerContainerElement,\n                    isElementResizable : el => !el.matches('.b-dragging,.b-readonly'),\n                    internalListeners  : {\n                        resizestart : 'onResizeStart',\n                        resizing    : 'onResizeDrag',\n                        resize      : 'onResize',\n                        cancel      : 'onInvalidResize',\n                        reset       : 'onResizeReset',\n                        thisObj     : me\n                    }\n                }, me.resizeHelperConfig);\n            }\n        }\n\n        me.renderRanges();\n\n        if (me.tooltipTemplate) {\n            me.hoverTooltip = new Tooltip({\n                forElement : me.headerContainerElement,\n                getHtml({ activeTarget }) {\n                    const timeRange = me.resolveTimeRangeRecord(activeTarget);\n\n                    return me.tooltipTemplate({ timeRange });\n                },\n                forSelector : '.' + me.baseCls + (me.cls ? '.' + me.cls : '')\n            });\n        }\n    }\n\n    //endregion\n\n    //region Draw\n\n    refresh() {\n        this._timeRanges = null;\n        this.renderRanges();\n    }\n\n    getDOMConfig(startDate, endDate) {\n        const\n            me            = this,\n            bodyConfigs   = [],\n            headerConfigs = [];\n\n        if (!me.disabled) {\n            // clear label rotation map cache here, used to prevent height calculations for every timeRange entry to\n            // speed up using recurrences\n            me._labelRotationMap = {};\n\n            for (const range of me.timeRanges) {\n                const result = me.renderRange(range, startDate, endDate);\n                if (result) {\n                    bodyConfigs.push(result.bodyConfig);\n                    headerConfigs.push(result.headerConfig);\n                }\n            }\n        }\n\n        return [bodyConfigs, headerConfigs];\n    }\n\n    renderRanges() {\n        const\n            me                   = this,\n            { foregroundCanvas } = me.client;\n\n        // Scheduler/Gantt might not yet be rendered\n        if (foregroundCanvas && me.client.isPainted) {\n            const\n                { headerContainerElement }   = me,\n                updatedBodyElements          = [],\n                [bodyConfigs, headerConfigs] = me.getDOMConfig();\n\n            if (!me.bodyCanvas) {\n                me.bodyCanvas = DomHelper.createElement({\n                    className     : `b-timeranges-canvas ${me.cls}-canvas`,\n                    parent        : foregroundCanvas,\n                    retainElement : true\n                });\n            }\n\n            DomSync.sync({\n                targetElement : me.bodyCanvas,\n                childrenOnly  : true,\n                domConfig     : {\n                    children    : bodyConfigs,\n                    syncOptions : {\n                        releaseThreshold : 0,\n                        syncIdField      : 'id'\n                    }\n                },\n                callback : me.showHeaderElements ? null : ({\n                    targetElement,\n                    action\n                }) => {\n                    // Might need to rotate label when not showing header elements\n                    if (action === 'reuseElement' || action === 'newElement' || action === 'reuseOwnElement') {\n                        // Collect all here, to not force reflows in the middle of syncing\n                        updatedBodyElements.push(targetElement);\n                    }\n                }\n            });\n\n            if (me.showHeaderElements && !me.headerCanvas) {\n                me.headerCanvas = DomHelper.createElement({\n                    className     : `${me.cls}-canvas`,\n                    parent        : headerContainerElement,\n                    retainElement : true\n                });\n            }\n\n            if (me.headerCanvas) {\n                DomSync.sync({\n                    targetElement : me.headerCanvas,\n                    childrenOnly  : true,\n                    domConfig     : {\n                        children    : headerConfigs,\n                        syncOptions : {\n                            releaseThreshold : 0,\n                            syncIdField      : 'id'\n                        }\n                    }\n                });\n            }\n\n            // Rotate labels last, to not force reflows. First check if rotation is needed\n            for (const bodyElement of updatedBodyElements) {\n                me.cacheRotation(bodyElement.elementData.timeRange, bodyElement);\n            }\n\n            // Then apply rotation\n            for (const bodyElement of updatedBodyElements) {\n                me.applyRotation(bodyElement.elementData.timeRange, bodyElement);\n            }\n        }\n    }\n\n    // Implement in subclasses\n    get timeRanges() {\n        return [];\n    }\n\n    /**\n     * Based on this method result the feature decides whether the provided range should\n     * be rendered or not.\n     * The method checks that the range intersects the current viewport.\n     *\n     * Override the method to implement your custom range rendering vetoing logic.\n     * @param {Scheduler.model.TimeSpan} range Range to render.\n     * @param {Date} [startDate] Specifies view start date. Defaults to view visible range start\n     * @param {Date} [endDate] Specifies view end date. Defaults to view visible range end\n     * @returns {Boolean} `true` if the range should be rendered and `false` otherwise.\n     */\n    shouldRenderRange(\n        range,\n        startDate = this.client.visibleDateRange.startDate,\n        endDate   = this.client.visibleDateRange.endDate\n    ) {\n        const\n            { timeAxis }                                             = this.client,\n            { startDate : rangeStart, endDate : rangeEnd, duration } = range;\n\n        return Boolean(rangeStart && (!timeAxis.isFiltered || timeAxis.isTimeSpanInAxis(range)) && DateHelper.intersectSpans(\n            startDate,\n            endDate,\n            rangeStart,\n            // Lines are included longer, to make sure label does not disappear\n            duration ? rangeEnd : DateHelper.add(rangeStart, this._lineBufferDurationMS)\n        ));\n    }\n\n    getRangeDomConfig(timeRange, minDate, maxDate, relativeTo = 0) {\n        const\n            me         = this,\n            { client } = me,\n            { rtl }    = client,\n            startPos   = client.getCoordinateFromDate(DateHelper.max(timeRange.startDate, minDate), {\n                respectExclusion : true\n            }) - relativeTo,\n            endPos     = timeRange.endDate ? client.getCoordinateFromDate(DateHelper.min(timeRange.endDate, maxDate), {\n                respectExclusion : true,\n                isEnd            : true\n            }) - relativeTo : startPos,\n            size       = Math.abs(endPos - startPos),\n            isRange    = size > 0,\n            translateX = rtl ? `calc(${startPos}px - 100%)` : `${startPos}px`;\n\n        return {\n            className : {\n                [me.baseCls]     : 1,\n                [me.cls]         : me.cls,\n                [me.rangeCls]    : isRange,\n                [me.lineCls]     : !isRange,\n                [timeRange.cls]  : timeRange.cls,\n                'b-narrow-range' : isRange && size < me.narrowThreshold,\n                'b-readonly'     : timeRange.readOnly,\n                'b-rtl'          : rtl\n            },\n            dataset : {\n                id : timeRange.id\n            },\n            elementData : {\n                timeRange\n            },\n            style : client.isVertical\n                ? `transform: translateY(${translateX}); ${isRange ? `height:${size}px` : ''};`\n                : `transform: translateX(${translateX}); ${isRange ? `width:${size}px` : ''};`\n        };\n    }\n\n    renderRange(timeRange, startDate, endDate) {\n        const\n            me           = this,\n            { client }   = me,\n            { timeAxis } = client;\n\n        if (me.shouldRenderRange(timeRange, startDate, endDate) && timeAxis.startDate) {\n            const\n                config     = me.getRangeDomConfig(timeRange, timeAxis.startDate, timeAxis.endDate),\n                icon       = timeRange.iconCls && StringHelper.xss`<i class=\"${timeRange.iconCls}\"></i>`,\n                name       = timeRange.name && StringHelper.encodeHtml(timeRange.name),\n                labelTpl   = (name || icon) ? `<label>${icon || ''}${name || '&nbsp;'}</label>` : '',\n                bodyConfig = {\n                    ...config,\n                    style : config.style + (timeRange.style || ''),\n                    html  : me.bodyRenderer ? me.bodyRenderer({ timeRange }) : (me.showHeaderElements && !me.showLabelInBody ? '' : labelTpl)\n                };\n\n            let headerConfig;\n\n            if (me.showHeaderElements) {\n                headerConfig = {\n                    ...config,\n                    html : (me.headerRenderer ? me.headerRenderer({ timeRange }) : (me.showLabelInBody ? '' : labelTpl))\n                };\n            }\n\n            return { bodyConfig, headerConfig };\n        }\n    }\n\n    // Cache label rotation to not have to calculate for each occurrence when using recurring timeranges\n    cacheRotation(range, bodyElement) {\n        // Lines have no label. Do not check label content to do not force DOM layout!\n        if ((!range.iconCls && !range.name) || !range.duration) {\n            return;\n        }\n\n        const label = bodyElement.firstElementChild;\n\n        if (label && !range.recurringTimeSpan) {\n            this._labelRotationMap[range.id] = this.client.isVertical\n                ? label.offsetHeight < bodyElement.offsetHeight\n                : label.offsetWidth > bodyElement.offsetWidth;\n        }\n    }\n\n    applyRotation(range, bodyElement) {\n        const rotate = this._labelRotationMap[range.recurringTimeSpan?.id ?? range.id];\n\n        bodyElement.firstElementChild?.classList.toggle('b-vertical', Boolean(rotate));\n    }\n\n    getBodyElementByRecord(idOrRecord) {\n        const id = typeof idOrRecord === 'string' ? idOrRecord : idOrRecord?.id;\n\n        return id != null && DomSync.getChild(this.bodyCanvas, id);\n    }\n\n    // Implement in subclasses\n    resolveTimeRangeRecord(el) {}\n\n    get headerContainerElement() {\n        const\n            me                                       = this,\n            { isVertical, timeView, timeAxisColumn } = me.client;\n\n        if (!me._headerContainerElement) {\n            // Render into the subGrids header element or the vertical timeaxis depending on mode\n            if (isVertical && timeView.element) {\n                me._headerContainerElement = timeView.element.parentElement;\n            }\n            else if (!isVertical) {\n                me._headerContainerElement = timeAxisColumn.element;\n            }\n        }\n\n        return me._headerContainerElement;\n    }\n\n    //endregion\n\n    //region Settings\n\n    get showHeaderElements() {\n        return !this.client.hideHeaders && this._showHeaderElements;\n    }\n\n    updateShowHeaderElements(show) {\n        const { client } = this;\n\n        if (!this.isConfiguring) {\n            client.element.classList.toggle('b-sch-timeranges-with-headerelements', Boolean(show));\n\n            this.renderRanges();\n        }\n    }\n\n    //endregion\n\n    //region Menu items\n\n    /**\n     * Adds menu items for the context menu, and may mutate the menu configuration.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateTimeAxisHeaderMenu({ column, items }) {}\n\n    //endregion\n\n    //region Events & hooks\n\n    onPaint({ firstPaint }) {\n        if (firstPaint && this.client.isHorizontal) {\n            this.onUIReady();\n        }\n    }\n\n    onSchedulerHorizontalScroll() {\n        // Dont need a refresh, ranges are already available. Just need to draw those now in view\n        this.client.isHorizontal && this.renderRanges();\n    }\n\n    afterScroll() {\n        this.client.isVertical && this.renderRanges();\n    }\n\n    onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {\n        if (this.client.isVertical && oldHeight !== newHeight) {\n            this.renderRanges();\n        }\n    }\n\n    onTimeAxisViewModelUpdate({ source }) {\n        // Lines have no duration, but we want them to be visible longer for the label to not suddenly disappear.\n        // We use a 300px buffer for that, recalculated as an amount of ms\n        this._lineBufferDurationMS = source.getDateFromPosition(50) - source.getDateFromPosition(0);\n\n        this.refresh();\n    }\n\n    onTimeRangeClick(event) {\n        const timeRangeRecord = this.resolveTimeRangeRecord(event.target);\n\n        this.client.trigger(`timeRangeHeader${StringHelper.capitalize(event.type)}`, { event, timeRangeRecord });\n    }\n\n    //endregion\n\n    //region Drag drop\n\n    showTip(context) {\n        const me = this;\n\n        if (me.showTooltip) {\n            me.clockTemplate = new ClockTemplate({\n                scheduler : me.client\n            });\n\n            me.tip = new Tooltip(ObjectHelper.assign({\n                id                       : `${me.client.id}-time-range-tip`,\n                cls                      : 'b-interaction-tooltip',\n                align                    : 'b-t',\n                autoShow                 : true,\n                updateContentOnMouseMove : true,\n                forElement               : context.element,\n                getHtml                  : () => me.getTipHtml(context.record, context.element)\n            }, me.showTooltip));\n        }\n    }\n\n    destroyTip() {\n        if (this.tip) {\n            this.tip.destroy();\n            this.tip = null;\n        }\n    }\n\n    isElementDraggable(el) {\n        el = el.closest(this.baseSelector + ':not(.b-resizing):not(.b-readonly)');\n\n        return el && !el.classList.contains('b-over-resize-handle');\n    }\n\n    onDragStart({ context }) {\n        const { client, drag } = this;\n\n        if (client.isVertical) {\n            drag.minY = 0;\n            // Moving the range, you can drag the start marker down until the end of the range hits the time axis end\n            drag.maxY = client.timeAxisViewModel.totalSize - context.element.offsetHeight;\n            // Setting min/max for X makes drag right of the header valid, but visually still constrained vertically\n            drag.minX = 0;\n            drag.maxX = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            drag.minX = 0;\n            // Moving the range, you can drag the start marker right until the end of the range hits the time axis end\n            drag.maxX = client.timeAxisViewModel.totalSize - context.element.offsetWidth;\n            // Setting min/max for Y makes drag below header valid, but visually still constrained horizontally\n            drag.minY = 0;\n            drag.maxY = Number.MAX_SAFE_INTEGER;\n        }\n\n        client.element.classList.add('b-dragging-timerange');\n    }\n\n    onDrop({ context }) {\n        this.client.element.classList.remove('b-dragging-timerange');\n    }\n\n    onInvalidDrop() {\n        this.drag.reset();\n        this.client.element.classList.remove('b-dragging-timerange');\n\n        this.destroyTip();\n    }\n\n    onDrag() {}\n\n    onDragReset() {}\n\n    // endregion\n\n    // region Resize\n\n    onResizeStart() {}\n\n    onResizeDrag() {}\n\n    onResize() {}\n\n    onInvalidResize() {}\n\n    onResizeReset() {}\n\n    //endregion\n\n    //region Tooltip\n\n    /**\n     * Generates the html to display in the tooltip during drag drop.\n     *\n     */\n    getTipHtml(record, element) {\n        const\n            me         = this,\n            { client } = me,\n            box        = Rectangle.from(element),\n            startPos   = box.getStart(client.rtl, client.isHorizontal),\n            endPos     = box.getEnd(client.rtl, client.isHorizontal),\n            startDate  = client.getDateFromCoordinate(startPos, 'round', false),\n            endDate    = record.endDate && client.getDateFromCoordinate(endPos, 'round', false),\n            startText  = client.getFormattedDate(startDate),\n            endText    = endDate && client.getFormattedEndDate(endDate, startDate);\n\n        return me.dragTipTemplate({\n            name           : record.name || '',\n            startDate,\n            endDate,\n            startText,\n            endText,\n            startClockHtml : me.clockTemplate.template({\n                date : startDate,\n                text : startText,\n                cls  : 'b-sch-tooltip-startdate'\n            }),\n            endClockHtml : endText && me.clockTemplate.template({\n                date : endDate,\n                text : endText,\n                cls  : 'b-sch-tooltip-enddate'\n            })\n        });\n    }\n\n    //endregion\n}\n","import DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\n\n/**\n * @module Scheduler/feature/ColumnLines\n */\nconst emptyObject = Object.freeze({});\n\n/**\n * Displays column lines for ticks, with a different styling for major ticks (by default they are darker). If this\n * feature is disabled, no lines are shown. If it's enabled, line are shown for the tick level which is set in current\n * ViewPreset. Please see {@link Scheduler.preset.ViewPreset#field-columnLinesFor} config for details.\n *\n * The lines are drawn as divs, with only visible lines available in DOM. The color and style of the lines are\n * determined the css rules for `.b-column-line` and `.b-column-line-major`.\n *\n * For vertical mode, this features also draws vertical resource column lines if scheduler is configured with\n * `columnLines : true` (which is the default, see {@link Grid.view.GridBase#config-columnLines}).\n *\n * This feature is **enabled** by default\n *\n * @extends Core/mixin/InstancePlugin\n * @mixes Core/mixin/Delayable\n * @demo Scheduler/basic\n * @inlineexample Scheduler/feature/ColumnLines.js\n * @classtype columnLines\n * @feature\n */\nexport default class ColumnLines extends Delayable(InstancePlugin) {\n    //region Config\n\n    static get $name() {\n        return 'ColumnLines';\n    }\n\n    static get delayable() {\n        return {\n            refresh : {\n                type              : 'raf',\n                cancelOutstanding : true\n            }\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            after : ['render', 'updateCanvasSize', 'onVisibleDateRangeChange', 'onVisibleResourceRangeChange']\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(client, config) {\n        client.useBackgroundCanvas = true;\n\n        super.construct(client, config);\n    }\n\n    doDisable(disable) {\n        super.doDisable(disable);\n\n        if (!this.isConfiguring) {\n            this.refresh();\n        }\n    }\n\n    //endregion\n\n    //region Draw\n\n    /**\n     * Draw lines when scheduler/gantt is rendered.\n     * @private\n     */\n    render() {\n        this.refresh();\n    }\n\n    getColumnLinesDOMConfig(startDate, endDate) {\n        const\n            me                     = this,\n            { client }             = me,\n            { rtl }                = client,\n            m                      = rtl ? -1 : 1,\n            {\n                timeAxisViewModel,\n                isHorizontal,\n                resourceStore,\n                variableColumnWidths\n            }                      = client,\n            { columnConfig }       = timeAxisViewModel;\n\n        const\n            linesForLevel      = timeAxisViewModel.columnLinesFor,\n            majorLinesForLevel = Math.max(linesForLevel - 1, 0),\n            start              = startDate.getTime(),\n            end                = endDate.getTime(),\n            domConfigs         = [],\n            dates              = new Set(),\n            dimension          = isHorizontal ? 'X' : 'Y';\n\n        if (!me.disabled) {\n            const addLineConfig = (tick, isMajor) => {\n                const tickStart = tick.start.getTime();\n                // Only start of tick matters.\n                // Each tick has an exact calculated start position along the time axis\n                // and carries a border on its left, so column lines follow from\n                // tick 1 (zero-based) onwards.\n                if (tickStart > start && tickStart < end && !dates.has(tickStart)) {\n                    dates.add(tickStart);\n                    domConfigs.push({\n                        role      : 'presentation',\n                        className : isMajor ? 'b-column-line-major' : 'b-column-line',\n                        style     : {\n                            transform : `translate${dimension}(${tick.coord * m}px)`\n                        },\n                        dataset : {\n                            line : isMajor ? `major-${tick.index}` : `line-${tick.index}`\n                        }\n                    });\n                }\n            };\n\n            // Collect configs for major lines\n            if (linesForLevel !== majorLinesForLevel) {\n                for (let i = 1; i <= columnConfig[majorLinesForLevel].length - 1; i++) {\n                    addLineConfig(columnConfig[majorLinesForLevel][i], true);\n                }\n            }\n\n            // And normal lines, skipping dates already occupied by major lines\n            for (let i = 1; i <= columnConfig[linesForLevel].length - 1; i++) {\n                addLineConfig(columnConfig[linesForLevel][i], false);\n            }\n\n            // Add vertical resource column lines, if grid is configured to show column lines\n            if (!isHorizontal && client.columnLines) {\n                const\n                    { columnWidth } = client.resourceColumns,\n                    {\n                        first : firstResource,\n                        last : lastResource\n                    }               = client.currentOrientation.getResourceRange(true);\n\n                if (firstResource > -1) {\n                    for (let i = firstResource; i < lastResource + 1; i++) {\n                        const\n                            resourceRecord = resourceStore.getAt(i),\n                            instanceMeta   = resourceRecord.instanceMeta(client),\n                            left           = variableColumnWidths ? instanceMeta.insetStart + resourceRecord.columnWidth - 1 : (i + 1) * columnWidth - 1;\n\n                        domConfigs.push({\n                            className : 'b-column-line b-resource-column-line',\n                            style     : {\n                                transform : `translateX(${left * m}px)`\n                            },\n                            dataset : {\n                                line : `resource-${i}`\n                            }\n                        });\n                    }\n                }\n            }\n        }\n\n        return domConfigs;\n    }\n\n    /**\n     * Draw column lines that are in view\n     * @private\n     */\n    refresh() {\n        const\n            me                     = this,\n            { client }             = me,\n            { timeAxis }           = client,\n            { startDate, endDate } = client.visibleDateRange || emptyObject,\n            axisStart              = timeAxis.startDate;\n\n        // Early bailout for timeaxis without start date\n        if (!axisStart || !startDate) {\n            return;\n        }\n\n        if (!me.element) {\n            me.element = DomHelper.createElement({\n                parent    : client.backgroundCanvas,\n                className : 'b-column-lines-canvas'\n            });\n        }\n\n        const domConfigs = me.getColumnLinesDOMConfig(startDate, endDate);\n\n        DomSync.sync({\n            targetElement : me.element,\n            onlyChildren  : true,\n            domConfig     : {\n                children    : domConfigs,\n                syncOptions : {\n                    // When zooming in and out we risk getting a lot of released lines if we do not limit it\n                    releaseThreshold : 4\n                }\n            },\n            syncIdField : 'line'\n        });\n    }\n\n    //endregion\n\n    //region Events\n\n    // Called when visible date range changes, for example from zooming, scrolling, resizing\n    onVisibleDateRangeChange() {\n        this.refresh();\n    }\n\n    // Called when visible resource range changes, for example on scroll and resize\n    onVisibleResourceRangeChange({ firstResource, lastResource }) {\n        this.refresh();\n    }\n\n    updateCanvasSize() {\n        this.refresh();\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(ColumnLines, true, ['Scheduler', 'Gantt']);\n","import Base from '../../../Core/Base.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport Tooltip from '../../../Core/widget/Tooltip.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport DependencyBaseModel from '../../model/DependencyBaseModel.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\n\n/**\n * @module Scheduler/feature/mixin/DependencyCreation\n */\n\n// TODO: refactor this class using StateChart utility to be implemented in Core/util/StateChart.js or XState library if allowed to be used\n/**\n * Mixin for Dependencies feature that handles dependency creation (drag & drop from terminals which are shown on hover).\n * Requires {@link Core.mixin.Delayable} to be mixed in alongside.\n *\n * @mixin\n */\nexport default Target => class DependencyCreation extends (Target || Base) {\n    static get $name() {\n        return 'DependencyCreation';\n    }\n\n    //region Config\n\n    static get defaultConfig() {\n        return {\n            /**\n             * `false` to require a drop on a target event bar side circle to define the dependency type.\n             * If dropped on the event bar, the `defaultValue` of the DependencyModel `type` field will be used to\n             * determine the target task side.\n             *\n             * @member {Boolean} allowDropOnEventBar\n             */\n            /**\n             * `false` to require a drop on a target event bar side circle to define the dependency type.\n             * If dropped on the event bar, the `defaultValue` of the DependencyModel `type` field will be used to\n             * determine the target task side.\n             *\n             * @config {Boolean}\n             * @default\n             */\n            allowDropOnEventBar : true,\n\n            /**\n             * `false` to not show a tooltip while creating a dependency\n             * @config {Boolean}\n             * @default\n             */\n            showCreationTooltip : true,\n\n            /**\n             * A tooltip config object that will be applied to the dependency creation {@link Core.widget.Tooltip}\n             * @config {TooltipConfig}\n             */\n            creationTooltip : null,\n\n            /**\n             * A template function that will be called to generate the HTML contents of the dependency creation tooltip.\n             * You can return either an HTML string or a {@link DomConfig} object.\n             * @prp {Function} creationTooltipTemplate\n             * @param {Object} data Data about the dependency being created\n             * @param {Scheduler.model.TimeSpan} data.source The from event\n             * @param {Scheduler.model.TimeSpan} data.target The target event\n             * @param {String} data.fromSide The from side (start, end, top, bottom)\n             * @param {String} data.toSide The target side (start, end, top, bottom)\n             * @param {Boolean} data.valid The validity of the dependency\n             * @returns {String|DomConfig}\n             */\n\n            /**\n             * CSS class used for terminals\n             * @config {String}\n             * @default\n             */\n            terminalCls : 'b-sch-terminal',\n\n            /**\n             * Where (on event bar edges) to display terminals. The sides are `'start'`, `'top'`,\n             * `'end'` and `'bottom'`\n             * @config {String[]}\n             */\n            terminalSides : ['start', 'top', 'end', 'bottom'],\n\n            /**\n             * Set to `false` to not allow creating dependencies\n             * @config {Boolean}\n             * @default\n             */\n            allowCreate : true\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(view, config) {\n        super.construct(view, config);\n\n        const me = this;\n\n        me.view = view;\n        me.eventName = view.scheduledEventName;\n\n        view.ion({ readOnly : () => me.updateCreateListeners() });\n\n        me.updateCreateListeners();\n\n        me.chain(view, 'onElementTouchMove', 'onElementTouchMove');\n    }\n\n    doDestroy() {\n        const me = this;\n\n        me.detachListeners('view');\n\n        me.creationData = null;\n\n        me.pointerUpMoveDetacher?.();\n        me.creationTooltip?.destroy();\n\n        super.doDestroy();\n    }\n\n    updateCreateListeners() {\n        const me = this;\n\n        if (!me.view) {\n            return;\n        }\n\n        me.detachListeners('view');\n\n        if (me.isCreateAllowed) {\n            me.view.ion({\n                name                          : 'view',\n                [`${me.eventName}mouseenter`] : 'onTimeSpanMouseEnter',\n                [`${me.eventName}mouseleave`] : 'onTimeSpanMouseLeave',\n                thisObj                       : me\n            });\n        }\n    }\n\n    set allowCreate(value) {\n        this._allowCreate = value;\n\n        this.updateCreateListeners();\n    }\n\n    get allowCreate() {\n        return this._allowCreate;\n    }\n\n    get isCreateAllowed() {\n        return this.allowCreate && !this.view.readOnly && !this.disabled;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Show terminals when mouse enters event/task element\n     * @private\n     */\n    onTimeSpanMouseEnter({\n        event, source, [`${this.eventName}Record`]: record, [`${this.eventName}Element`]: element\n    }) {\n        if (!record.isCreating && !record.readOnly && (!this.client.features.nestedEvents || record.parent.isRoot)) {\n            const\n                me               = this,\n                { creationData } = me,\n                eventBarElement  = DomHelper.down(element, source.eventInnerSelector);\n\n            // When we enter a different event than the one we started on\n            if (record !== creationData?.source) {\n                me.showTerminals(record, eventBarElement);\n\n                if (creationData && event.target.closest(me.client.eventSelector)) {\n                    creationData.timeSpanElement = eventBarElement;\n                    me.onOverTargetEventBar(event);\n                }\n            }\n        }\n    }\n\n    /**\n     * Hide terminals when mouse leaves event/task element\n     * @private\n     */\n    onTimeSpanMouseLeave(event) {\n        const\n            me               = this,\n            { creationData } = me,\n            element          = event[`${me.eventName}Element`],\n            timeSpanLeft     = DomHelper.down(element, me.view.eventInnerSelector),\n            target           = event.event?.relatedTarget,\n            timeSpanElement  = creationData?.timeSpanElement;\n\n        // Can happen when unhovering an occurrence during update\n        if (!target) {\n            return;\n        }\n\n        if (!creationData || !timeSpanElement || !target || !DomHelper.isDescendant(timeSpanElement, target)) {\n            // We cannot hide the terminals for non-trusted events because non-trusted means it's\n            // synthesized from a touchmove event and if the source element of a touchmove\n            // leaves the DOM, the touch gesture is ended.\n            if (event.event.isTrusted || (timeSpanLeft !== creationData?.sourceElement)) {\n                me.hideTerminals(element);\n            }\n        }\n\n        if (creationData && !creationData.finalizing) {\n            creationData.timeSpanElement = null;\n            me.onOverNewTargetWhileCreating(undefined, undefined, event);\n        }\n    }\n\n    onTerminalMouseOver(event) {\n        if (this.creationData) {\n            this.onOverTargetEventBar(event);\n        }\n    }\n\n    /**\n     * Remove hover styling when mouse leaves terminal. Also hides terminals when mouse leaves one it and not creating a\n     * dependency.\n     * @private\n     */\n    onTerminalMouseOut(event) {\n        const\n            me               = this,\n            { creationData } = me,\n            eventElement     = event.target.closest(me.view.eventSelector);\n\n        if (eventElement && (!me.showingTerminalsFor || !DomHelper.isDescendant(eventElement, me.showingTerminalsFor)) && (!creationData || eventElement !== creationData.timeSpanElement)) {\n            me.hideTerminals(eventElement);\n            me.view.unhover(eventElement, event);\n        }\n\n        if (creationData) {\n            me.onOverNewTargetWhileCreating(event.relatedTarget, creationData.target, event);\n        }\n    }\n\n    /**\n     * Start creating a dependency when mouse is pressed over terminal\n     * @private\n     */\n    onTerminalPointerDown(event) {\n        const me = this;\n\n        // ignore non-left button clicks\n        if (event.button === 0 && !me.creationData) {\n            const\n                scheduler              = me.view,\n                timeAxisSubGridElement = scheduler.timeAxisSubGridElement,\n                terminalNode           = event.target,\n                timeSpanElement        = terminalNode.closest(scheduler.eventInnerSelector),\n                viewBounds             = Rectangle.from(scheduler.element, document.body);\n\n            event.stopPropagation();\n\n            me.creationData = {\n                sourceElement  : timeSpanElement,\n                source         : scheduler.resolveTimeSpanRecord(timeSpanElement).$original,\n                fromSide       : terminalNode.dataset.side,\n                startPoint     : Rectangle.from(terminalNode, timeAxisSubGridElement).center,\n                startX         : event.pageX - viewBounds.x + scheduler.scrollLeft,\n                startY         : event.pageY - viewBounds.y + scheduler.scrollTop,\n                valid          : false,\n                sourceResource : scheduler.resolveResourceRecord?.(event),\n                tooltip        : me.creationTooltip\n            };\n\n            me.pointerUpMoveDetacher = EventHelper.on({\n                pointerup : {\n                    element : scheduler.element.getRootNode(),\n                    handler : 'onMouseUp',\n                    passive : false\n                },\n                pointermove : {\n                    element : timeAxisSubGridElement,\n                    handler : 'onMouseMove',\n                    passive : false\n                },\n                thisObj : me\n            });\n\n            // If root element is anything but Document (it could be Document Fragment or regular Node in case of LWC)\n            // then we should also add listener to document to cancel dependency creation\n            me.documentPointerUpDetacher = EventHelper.on({\n                pointerup : {\n                    element : document,\n                    handler : 'onDocumentMouseUp'\n                },\n                keydown : {\n                    element : document,\n                    handler : ({ key }) => {\n                        if (key === 'Escape') {\n                            me.abort();\n                        }\n                    }\n                },\n                thisObj : me\n            });\n        }\n    }\n\n    onElementTouchMove(event) {\n        super.onElementTouchMove?.(event);\n\n        if (this.connector) {\n            // Prevent touch scrolling while dragging a connector\n            event.preventDefault();\n        }\n    }\n\n    /**\n     * Update connector line showing dependency between source and target when mouse moves. Also check if mouse is over\n     * a valid target terminal\n     * @private\n     */\n    onMouseMove(event) {\n        const\n            me                            = this,\n            { view, creationData : data } = me,\n            viewBounds                    = Rectangle.from(view.element, document.body),\n            deltaX                        = (event.pageX - viewBounds.x + view.scrollLeft) - data.startX,\n            deltaY                        = (event.pageY - viewBounds.y + view.scrollTop) - data.startY,\n            length                        = Math.round(Math.sqrt(deltaX * deltaX + deltaY * deltaY)) - 3,\n            angle                         = Math.atan2(deltaY, deltaX);\n\n        let { connector } = me;\n\n        if (!connector) {\n            if (me.onRequestDragCreate(event) === false) {\n                return;\n            }\n            connector = me.connector;\n        }\n\n        connector.style.width     = `${length}px`;\n        connector.style.transform = `rotate(${angle}rad)`;\n\n        me.lastMouseMoveEvent = event;\n    }\n\n    onRequestDragCreate(event) {\n        const\n            me                            = this,\n            { view, creationData : data } = me;\n\n        /**\n         * Fired on the owning Scheduler/Gantt before a dependency creation drag operation starts. Return `false to\n         * prevent it\n         * @event beforeDependencyCreateDrag\n         * @on-owner\n         * @param {Scheduler.model.TimeSpan} source The source task\n         */\n        if (view.trigger('beforeDependencyCreateDrag', { data, source : data.source }) === false) {\n            me.abort();\n            return false;\n        }\n\n        view.element.classList.add('b-creating-dependency');\n\n        me.createConnector(data.startPoint.x, data.startPoint.y);\n\n        /**\n         * Fired on the owning Scheduler/Gantt when a dependency creation drag operation starts\n         * @event dependencyCreateDragStart\n         * @on-owner\n         * @param {Scheduler.model.TimeSpan} source The source task\n         */\n        view.trigger('dependencyCreateDragStart', { data, source : data.source  });\n\n        if (me.showCreationTooltip) {\n            const tip = me.creationTooltip || (me.creationTooltip = me.createDragTooltip());\n\n            me.creationData.tooltip = tip;\n\n            tip.disabled = false;\n            tip.show();\n\n            tip.onMouseMove(event);\n        }\n\n        view.scrollManager.startMonitoring({\n            scrollables : [\n                {\n                    element   : view.timeAxisSubGrid.scrollable.element,\n                    direction : 'horizontal'\n                },\n                {\n                    element   : view.scrollable.element,\n                    direction : 'vertical'\n                }\n            ],\n            callback : () => me.lastMouseMoveEvent && me.onMouseMove(me.lastMouseMoveEvent)\n        });\n    }\n\n    onOverTargetEventBar(event) {\n        const\n            me                                                = this,\n            { view, creationData: data, allowDropOnEventBar } = me,\n            { target }                                        = event;\n\n        let overEventRecord = view.resolveTimeSpanRecord(target).$original;\n\n        // use main event if a segment resolved\n        if (overEventRecord?.isEventSegment) {\n            overEventRecord = overEventRecord.event;\n        }\n\n        if (Objects.isPromise(data.valid) || (!allowDropOnEventBar && !target.classList.contains(me.terminalCls))) {\n            return;\n        }\n\n        if (overEventRecord !== data.source) {\n            me.onOverNewTargetWhileCreating(target, overEventRecord, event);\n        }\n    }\n\n    async onOverNewTargetWhileCreating(targetElement, overEventRecord, event) {\n        const\n            me                                                            = this,\n            { view, creationData : data, allowDropOnEventBar, connector } = me;\n\n        if (Objects.isPromise(data.valid)) {\n            return;\n        }\n\n        // stop target updating if dependency finalizing in progress\n        if (data.finalizing) {\n            return;\n        }\n\n        // Connector might not exist at this point because `pointerout` on the terminal might fire before `pointermove`\n        // on the time axis subgrid. This is difficult to reproduce, so shouldn't be triggered often.\n        // https://github.com/bryntum/support/issues/3116#issuecomment-894256799\n        if (!connector) {\n            return;\n        }\n\n        connector.classList.remove('b-valid', 'b-invalid');\n        data.timeSpanElement && DomHelper.removeClsGlobally(data.timeSpanElement, 'b-sch-terminal-active');\n\n        if (!overEventRecord || overEventRecord === data.source || (!allowDropOnEventBar && !targetElement.classList.contains(me.terminalCls))) {\n            data.target = data.toSide = null;\n            data.valid = false;\n            connector.classList.add('b-invalid');\n        }\n        else {\n            const\n                target     = data.target = overEventRecord,\n                { source } = data;\n\n            let toSide  = targetElement.dataset.side;\n\n            // If we allow dropping anywhere on a task, resolve target side based on the default type of the\n            // dependency model used\n            if (allowDropOnEventBar && !targetElement.classList.contains(me.terminalCls)) {\n                toSide = me.getTargetSideFromType(me.dependencyStore.modelClass.fieldMap.type.defaultValue || DependencyBaseModel.Type.EndToStart);\n            }\n\n            if (view.resolveResourceRecord) {\n                data.targetResource = view.resolveResourceRecord(event);\n            }\n\n            let dependencyType;\n\n            data.toSide = toSide;\n\n            const\n                fromSide       = data.fromSide,\n                updateValidity = valid => {\n                    if (!me.isDestroyed) {\n                        data.valid = valid;\n                        targetElement.classList.add(valid ? 'b-valid' : 'b-invalid');\n                        connector.classList.add(valid ? 'b-valid' : 'b-invalid');\n                        /**\n                         * Fired on the owning Scheduler/Gantt when asynchronous dependency validation completes\n                         * @event dependencyValidationComplete\n                         * @on-owner\n                         * @param {Scheduler.model.TimeSpan} source The source task\n                         * @param {Scheduler.model.TimeSpan} target The target task\n                         * @param {Number} dependencyType The dependency type, see {@link Scheduler.model.DependencyBaseModel#property-Type-static}\n                         */\n                        view.trigger('dependencyValidationComplete', {\n                            data,\n                            source,\n                            target,\n                            dependencyType\n                        });\n                    }\n                };\n\n            // NOTE: Top/Bottom sides are not taken into account due to\n            //       scheduler doesn't check for type value anyway, whereas\n            //       gantt will reject any other dependency types undefined in\n            //       DependencyBaseModel.Type enumeration.\n            switch (true) {\n                case fromSide === 'start' && toSide === 'start':\n                    dependencyType = DependencyBaseModel.Type.StartToStart;\n                    break;\n                case fromSide === 'start' && toSide === 'end':\n                    dependencyType = DependencyBaseModel.Type.StartToEnd;\n                    break;\n                case fromSide === 'end' && toSide === 'start':\n                    dependencyType = DependencyBaseModel.Type.EndToStart;\n                    break;\n                case fromSide === 'end' && toSide === 'end':\n                    dependencyType = DependencyBaseModel.Type.EndToEnd;\n                    break;\n            }\n\n            /**\n             * Fired on the owning Scheduler/Gantt when asynchronous dependency validation starts\n             * @event dependencyValidationStart\n             * @on-owner\n             * @param {Scheduler.model.TimeSpan} source The source task\n             * @param {Scheduler.model.TimeSpan} target The target task\n             * @param {Number} dependencyType The dependency type, see {@link Scheduler.model.DependencyBaseModel#property-Type-static}\n             */\n            view.trigger('dependencyValidationStart', {\n                data,\n                source,\n                target,\n                dependencyType\n            });\n\n            let valid = data.valid = me.dependencyStore.isValidDependency(source, target, dependencyType);\n\n            // Promise is returned when using the engine\n            if (Objects.isPromise(valid)) {\n                valid = await valid;\n                updateValidity(valid);\n            }\n            else {\n                updateValidity(valid);\n            }\n\n            const validityCls = valid ? 'b-valid' : 'b-invalid';\n            connector.classList.add(validityCls);\n            data.timeSpanElement?.querySelector(`.b-sch-terminal[data-side=${toSide}]`)?.classList.add('b-sch-terminal-active', validityCls);\n        }\n\n        me.updateCreationTooltip();\n    }\n\n    /**\n     * Create a new dependency if mouse release over valid terminal. Hides connector\n     * @private\n     */\n    async onMouseUp() {\n        const\n            me   = this,\n            data = me.creationData;\n\n        data.finalizing = true;\n        me.pointerUpMoveDetacher?.();\n\n        if (data.valid) {\n            /**\n             * Fired on the owning Scheduler/Gantt when a dependency drag creation operation is about to finalize\n             *\n             * @event beforeDependencyCreateFinalize\n             * @on-owner\n             * @preventable\n             * @async\n             * @param {Scheduler.model.TimeSpan} source The source task\n             * @param {Scheduler.model.TimeSpan} target The target task\n             * @param {'start'|'end'|'top'|'bottom'} fromSide The from side (start / end / top / bottom)\n             * @param {'start'|'end'|'top'|'bottom'} toSide The to side (start / end / top / bottom)\n             */\n            const result = await me.view.trigger('beforeDependencyCreateFinalize', data);\n\n            if (result === false) {\n                data.valid = false;\n            }\n            // Await any async validation logic before continuing\n            else if (Objects.isPromise(data.valid)) {\n                data.valid = await data.valid;\n            }\n\n            if (data.valid) {\n                let dependency = me.createDependency(data);\n\n                if (dependency !== null) {\n                    if (Objects.isPromise(dependency)) {\n                        dependency = await dependency;\n                    }\n\n                    data.dependency = dependency;\n\n                    /**\n                     * Fired on the owning Scheduler/Gantt when a dependency drag creation operation succeeds\n                     * @event dependencyCreateDrop\n                     * @on-owner\n                     * @param {Scheduler.model.TimeSpan} source The source task\n                     * @param {Scheduler.model.TimeSpan} target The target task\n                     * @param {Scheduler.model.DependencyBaseModel} dependency The created dependency\n                     */\n                    me.view.trigger('dependencyCreateDrop', { data, source : data.source, target : data.target, dependency });\n                    me.doAfterDependencyDrop(data);\n                }\n            }\n            else {\n                me.doAfterDependencyDrop(data);\n            }\n        }\n        else {\n            data.valid = false;\n            me.doAfterDependencyDrop(data);\n        }\n\n        me.abort();\n    }\n\n    doAfterDependencyDrop(data) {\n        /**\n         * Fired on the owning Scheduler/Gantt after a dependency drag creation operation finished, no matter to outcome\n         * @event afterDependencyCreateDrop\n         * @on-owner\n         * @param {Scheduler.model.TimeSpan} source The source task\n         * @param {Scheduler.model.TimeSpan} target The target task\n         * @param {Scheduler.model.DependencyBaseModel} dependency The created dependency\n         */\n        this.view.trigger('afterDependencyCreateDrop', {\n            data,\n            ...data\n        });\n    }\n\n    onDocumentMouseUp({ target }) {\n        if (!this.view.timeAxisSubGridElement.contains(target)) {\n            this.abort();\n        }\n    }\n\n    /**\n     * Aborts dependency creation, removes proxy and cleans up listeners\n     */\n    abort() {\n        const\n            me                     = this,\n            { view, creationData } = me;\n\n        // Remove terminals from source and target events.\n        if (creationData) {\n            const { source, sourceResource, target, targetResource } = creationData;\n\n            if (source) {\n                const el = view.getElementFromEventRecord(source, sourceResource);\n                if (el) {\n                    me.hideTerminals(el);\n                }\n            }\n            if (target) {\n                const el = view.getElementFromEventRecord(target, targetResource);\n                if (el) {\n                    me.hideTerminals(el);\n                }\n            }\n        }\n\n        if (me.creationTooltip) {\n            me.creationTooltip.disabled = true;\n        }\n\n        me.creationData = me.lastMouseMoveEvent = null;\n\n        me.pointerUpMoveDetacher?.();\n\n        me.documentPointerUpDetacher?.();\n\n        me.removeConnector();\n    }\n\n    //endregion\n\n    //region Connector\n\n    /**\n     * Creates a connector line that visualizes dependency source & target\n     * @private\n     */\n    createConnector(x, y) {\n        const\n            me       = this,\n            { view } = me;\n\n        me.clearTimeout(me.removeConnectorTimeout);\n        me.connector = DomHelper.createElement({\n            parent    : view.timeAxisSubGridElement,\n            className : `${me.baseCls}-connector`,\n            style     : `left:${x}px;top:${y}px`\n        });\n\n        view.element.classList.add('b-creating-dependency');\n    }\n\n    createDragTooltip() {\n        const\n            me       = this,\n            { view } = me;\n\n        return me.creationTooltip = Tooltip.new({\n            id             : `${view.id}-dependency-drag-tip`,\n            cls            : 'b-sch-dependency-creation-tooltip',\n            loadingMsg     : '',\n            anchorToTarget : false,\n            // Keep tip visible until drag drop operation is finalized\n            forElement     : view.timeAxisSubGridElement,\n            trackMouse     : true,\n            // Do not constrain at all, want it to be able to go outside of the viewport to not get in the way\n            constrainTo    : null,\n\n            header : {\n                dock : 'right'\n            },\n\n            internalListeners : {\n                // Show initial content immediately\n                beforeShow : 'updateCreationTooltip',\n                thisObj    : me\n            }\n        }, me.creationTooltip);\n    }\n\n    /**\n     * Remove connector\n     * @private\n     */\n    removeConnector() {\n        const\n            me                  = this,\n            { connector, view } = me;\n\n        if (connector) {\n            connector.classList.add('b-removing');\n            connector.style.width = '0';\n            me.removeConnectorTimeout = me.setTimeout(() => {\n                connector.remove();\n                me.connector = null;\n            }, 200);\n        }\n\n        view.element.classList.remove('b-creating-dependency');\n        me.creationTooltip && me.creationTooltip.hide();\n\n        view.scrollManager.stopMonitoring();\n    }\n\n    //endregion\n\n    //region Terminals\n\n    /**\n     * Show terminals for specified event at sides defined in #terminalSides.\n     * @param {Scheduler.model.TimeSpan} timeSpanRecord Event/task to show terminals for\n     * @param {HTMLElement} element Event/task element\n     */\n    showTerminals(timeSpanRecord, element) {\n        const me = this;\n\n        // Record not part of project is a transient record in a display store, not meant to be manipulated\n        if (!me.isCreateAllowed || !timeSpanRecord.project) {\n            return;\n        }\n\n        const\n            cls                 = me.terminalCls,\n            terminalsVisibleCls = `${cls}s-visible`;\n\n        // We operate on the event bar, not the wrap\n        element = DomHelper.down(element, me.view.eventInnerSelector);\n\n        // bail out if terminals already shown or if view is readonly\n        // do not draw new terminals if we are resizing event\n        if (!element.classList.contains(terminalsVisibleCls) && !me.view.element.classList.contains('b-resizing-event') && !me.view.readOnly) {\n\n            // create terminals for desired sides\n            me.terminalSides.forEach(side => {\n                // Allow code to use left for the start side and right for the end side\n                side = me.fixSide(side);\n\n                const terminal = DomHelper.createElement({\n                    parent    : element,\n                    className : `${cls} ${cls}-${side}`,\n                    dataset   : {\n                        side,\n                        feature : true\n                    }\n                });\n\n                terminal.detacher = EventHelper.on({\n                    element     : terminal,\n                    mouseover   : 'onTerminalMouseOver',\n                    mouseout    : 'onTerminalMouseOut',\n                    // Needs to be pointerdown to match DragHelper, otherwise will be preventing wrong event\n                    pointerdown : {\n                        handler : 'onTerminalPointerDown',\n                        capture : true\n                    },\n                    thisObj : me\n                });\n            });\n\n            element.classList.add(terminalsVisibleCls);\n            timeSpanRecord.internalCls.add(terminalsVisibleCls);\n\n            me.showingTerminalsFor = element;\n        }\n    }\n\n    fixSide(side) {\n        if (side === 'left') {\n            return 'start';\n        }\n        if (side === 'right') {\n            return 'end';\n        }\n        return side;\n    }\n\n    /**\n     * Hide terminals for specified event\n     * @param {HTMLElement} eventElement Event element\n     */\n    hideTerminals(eventElement) {\n        // remove all terminals\n        const\n            me                  = this,\n            eventParams         = me.client.getTimeSpanMouseEventParams(eventElement),\n            timeSpanRecord      = eventParams?.[`${me.eventName}Record`],\n            terminalsVisibleCls = `${me.terminalCls}s-visible`;\n\n        DomHelper.forEachSelector(eventElement, `.${me.terminalCls}`, terminal => {\n            terminal.detacher && terminal.detacher();\n            terminal.remove();\n        });\n\n        DomHelper.down(eventElement, me.view.eventInnerSelector).classList.remove(terminalsVisibleCls);\n        timeSpanRecord.internalCls.remove(terminalsVisibleCls);\n\n        me.showingTerminalsFor = null;\n    }\n\n    //endregion\n\n    //region Dependency creation\n\n    /**\n     * Create a new dependency from source terminal to target terminal\n     * @internal\n     */\n    createDependency(data) {\n        const\n            { source, target, fromSide, toSide } = data,\n            type                                 = (fromSide === 'start' ? 0 : 2) + (toSide === 'end' ? 1 : 0);\n\n        const newDependency = this.dependencyStore.add({\n            from : source.id,\n            to   : target.id,\n            type,\n            fromSide,\n            toSide\n        });\n\n        return newDependency !== null ? newDependency[0] : null;\n    }\n\n    getTargetSideFromType(type) {\n        if (type === DependencyBaseModel.Type.StartToStart || type === DependencyBaseModel.Type.EndToStart) {\n            return 'start';\n        }\n\n        return 'end';\n    }\n\n    //endregion\n\n    //region Tooltip\n\n    /**\n     * Update dependency creation tooltip\n     * @private\n     */\n    updateCreationTooltip() {\n        const\n            me            = this,\n            data          = me.creationData,\n            { valid }     = data,\n            tip           = me.creationTooltip,\n            { classList } = tip.element;\n\n        // Promise, when using engine\n        if (Objects.isPromise(valid)) {\n            classList.remove('b-invalid');\n            classList.add('b-checking');\n\n            return new Promise(resolve => valid.then(valid => {\n                data.valid = valid;\n\n                if (!tip.isDestroyed) {\n                    resolve(me.updateCreationTooltip());\n                }\n            }));\n        }\n\n        tip.html = me.creationTooltipTemplate(data);\n    }\n\n    creationTooltipTemplate(data) {\n        const\n            me                 = this,\n            { tooltip, valid } = data,\n            { classList }      = tooltip.element;\n\n        Object.assign(data, {\n            fromText : StringHelper.encodeHtml(data.source.name),\n            toText   : StringHelper.encodeHtml(data.target?.name ?? ''),\n            fromSide : data.fromSide,\n            toSide   : data.toSide || ''\n        });\n\n        let tipTitleIconClsSuffix,\n            tipTitleText;\n\n        classList.toggle('b-invalid', !valid);\n        classList.remove('b-checking');\n\n        // Valid\n        if (valid === true) {\n            tipTitleIconClsSuffix = 'valid';\n            tipTitleText          = me.L('L{Dependencies.valid}');\n        }\n        // Invalid\n        else {\n            tipTitleIconClsSuffix = 'invalid';\n            tipTitleText          = me.L('L{Dependencies.invalid}');\n        }\n\n        tooltip.title = `<i class=\"b-icon b-icon-${tipTitleIconClsSuffix}\"></i>${tipTitleText}`;\n\n        return {\n            children : [{\n                className : 'b-sch-dependency-tooltip',\n                children  : [\n                    { dataset : { ref : 'fromLabel' }, tag : 'label', text : me.L('L{Dependencies.from}') },\n                    { dataset : { ref : 'fromText' }, text : data.fromText },\n                    { dataset : { ref : 'fromBox' }, className : `b-sch-box b-${data.fromSide}` },\n                    { dataset : { ref : 'toLabel' }, tag : 'label', text : me.L('L{Dependencies.to}') },\n                    { dataset : { ref : 'toText' }, text : data.toText },\n                    { dataset : { ref : 'toBox' }, className : `b-sch-box b-${data.toSide}` }\n                ]\n            }]\n        };\n    }\n\n    //endregion\n\n    doDisable(disable) {\n        if (!this.isConfiguring) {\n            this.updateCreateListeners();\n        }\n\n        super.doDisable(disable);\n    }\n};\n","\nconst ROWS_PER_CELL = 25; // TODO Consider basing on visible row count\n\n// Mixin that handles the dependency grid cache\n//\n// Grid cache explainer\n// \n// The purpose of the grid cache is to reduce the amount of dependencies we have to iterate over when drawing by\n// partitioning them into a virtual grid. With for example 10k deps we would have to iterate over all 10k on\n// each draw since any of them might be intersecting the view.\n//\n// The cells are horizontally based on ticks (50 per cell) and vertically on rows (also 50 per cell. Each cell\n// lists which dependencies intersect it. When drawing we only have to iterate over the dependencies for the\n// cells that intersect the viewport.\n//\n// The grid cache is populated when dependencies are drawn. Any change to deps, resources, events or assignments\n// clears the cache.\n//\n// The dependency drawn below will be included in the set that is considered for drawing if tickCell 0 or\n// tickCell 1 and rowCell 0 intersects the current view (it is thus represented twice in the grid cache)\n//\n//       tickCell 0           tickCell 1\n//       tick 0-49            tick 50-99\n//    \n// r r0,0                 1,0                  \n// o o                                        \n// w w          !!!!!!!!!!!!!!!!!!!!          \n// C            ! View             !          \n// e 0          ! port             !          \n// l -          !                  !          \n// l 4     !!     \n// 0 9           !                  !          \n//    \n// r r0,1        !        1,1       !          \n// o o           !                  !          \n// w w           !!!!!!!!!!!!!!!!!!!!          \n// C                                           \n// e 5                                         \n// l 0                                         \n// l -                                         \n// 1 9                                         \n//   9\n//               uosn  p\nexport default Target => class DependencyGridCache extends Target {\n    static $name = 'DependencyGridCache';\n\n    gridCache = null;\n\n    // Dependencies that might intersect the current viewport and thus should be considered for drawing\n    getDependenciesToConsider(startMS, endMS, startIndex, endIndex) {\n        const\n            me            = this,\n            { gridCache } = me,\n            { timeAxis }  = me.client;\n\n        if (gridCache) {\n            const\n                dependencies = new Set(),\n                fromMSCell   = Math.floor((startMS - timeAxis.startMS) / me.MS_PER_CELL),\n                toMSCell     = Math.floor((endMS - timeAxis.startMS) / me.MS_PER_CELL),\n                fromRowCell  = Math.floor(startIndex / ROWS_PER_CELL),\n                toRowCell    = Math.floor(endIndex / ROWS_PER_CELL);\n\n            for (let i = fromMSCell; i <= toMSCell; i++) {\n                const msCell = gridCache[i];\n                if (msCell) {\n                    for (let j = fromRowCell; j <= toRowCell; j++) {\n                        const intersectingDependencies = msCell[j];\n                        if (intersectingDependencies) {\n                            for (let i = 0; i < intersectingDependencies.length; i++) {\n                                dependencies.add(intersectingDependencies[i]);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return dependencies;\n        }\n    }\n\n    // A (single) dependency was drawn, we might want to store info about it in the grid cache\n    afterDrawDependency(dependency, fromIndex, toIndex, fromDateMS, toDateMS) {\n        const me = this;\n\n        if (me.constructGridCache) {\n            const\n                { MS_PER_CELL } = me,\n                {\n                    startMS : timeAxisStartMS,\n                    endMS   : timeAxisEndMS\n                }               = me.client.timeAxis,\n                timeAxisCells   = Math.ceil((timeAxisEndMS - timeAxisStartMS) / MS_PER_CELL),\n                fromMSCell      = Math.floor((fromDateMS - timeAxisStartMS) / MS_PER_CELL),\n                toMSCell        = Math.floor((toDateMS - timeAxisStartMS) / MS_PER_CELL),\n                fromRowCell     = Math.floor(fromIndex / ROWS_PER_CELL),\n                toRowCell       = Math.floor(toIndex / ROWS_PER_CELL),\n                firstMSCell     = Math.min(fromMSCell, toMSCell),\n                lastMSCell      = Math.max(fromMSCell, toMSCell),\n                firstRowCell    = Math.min(fromRowCell, toRowCell),\n                lastRowCell     = Math.max(fromRowCell, toRowCell);\n\n            // Ignore dependencies fully outside of the time axis\n            if ((firstMSCell < 0 && lastMSCell < 0) || (firstMSCell > timeAxisCells && lastMSCell > timeAxisCells)) {\n                return;\n            }\n\n            // Cache from time axis start, to time axis end (\"cropping\" deps starting or ending outside)\n            const\n                startMSCell = Math.max(firstMSCell, 0),\n                endMSCell   = Math.min(lastMSCell, timeAxisCells);\n\n            for (let i = startMSCell; i <= endMSCell; i++) {\n                const msCell = me.gridCache[i] ?? (me.gridCache[i] = {});\n                for (let j = firstRowCell; j <= lastRowCell; j++) {\n                    const rowCell = msCell[j] ?? (msCell[j] = []);\n                    rowCell.push(dependency);\n                }\n            }\n        }\n    }\n\n    // All dependencies are about to be drawn, check if we need to build the grid cache\n    beforeDraw() {\n        const me = this;\n\n        if (!me.gridCache) {\n            const { visibleDateRange } = me.client;\n\n            me.constructGridCache = true;\n\n            // Adjust number of ms used in grid cache to match viewport\n            me.MS_PER_CELL = Math.max(visibleDateRange.endMS - visibleDateRange.startMS, 1000);\n\n            // Start with empty cache, will be populated as deps are drawn\n            me.gridCache = {};\n        }\n    }\n\n    // All dependencies are drawn, we no longer need to rebuild the cache\n    afterDraw() {\n        this.constructGridCache = false;\n    }\n\n    reset() {\n        this.gridCache = null;\n    }\n};\n","import Base from '../../Core/Base.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport WalkHelper from '../../Core/helper/WalkHelper.js';\n\n// Start adjusting if there is system scaling > 130%\nconst\n    THRESHOLD      = Math.min(1 / globalThis.devicePixelRatio, 0.75),\n    BOX_PROPERTIES = ['start', 'end', 'top', 'bottom'],\n    equalEnough    = (a, b) => Math.abs(a - b) < 0.1,\n    sideToSide     = {\n        l : 'left',\n        r : 'right',\n        t : 'top',\n        b : 'bottom'\n    };\n\n/**\n * @module Scheduler/util/RectangularPathFinder\n */\n\n/**\n * Class which finds rectangular path, i.e. path with 90 degrees turns, between two boxes.\n * @private\n */\nexport default class RectangularPathFinder extends Base {\n    static get configurable() {\n        return {\n            /**\n             * Default start connection side: 'left', 'right', 'top', 'bottom'\n             * @config {'top'|'bottom'|'left'|'right'}\n             * @default\n             */\n            startSide : 'right',\n\n            // /**\n            //  * Default start arrow size in pixels\n            //  * @config {Number}\n            //  * @default\n            //  */\n            // startArrowSize : 0,\n\n            /**\n             * Default start arrow staff size in pixels\n             * @config {Number}\n             * @default\n             */\n            startArrowMargin : 12,\n\n            /**\n             * Default starting connection point shift from box's arrow pointing side middle point\n             * @config {Number}\n             * @default\n             */\n            startShift : 0,\n\n            /**\n             * Default end arrow pointing direction, possible values are: 'left', 'right', 'top', 'bottom'\n             * @config {'top'|'bottom'|'left'|'right'}\n             * @default\n             */\n            endSide : 'left',\n\n            // /**\n            //  * Default end arrow size in pixels\n            //  * @config {Number}\n            //  * @default\n            //  */\n            // endArrowSize : 0,\n\n            /**\n             * Default end arrow staff size in pixels\n             * @config {Number}\n             * @default\n             */\n            endArrowMargin : 12,\n\n            /**\n             * Default ending connection point shift from box's arrow pointing side middle point\n             * @config {Number}\n             * @default\n             */\n            endShift : 0,\n\n            /**\n             * Start / End box vertical margin, the amount of pixels from top and bottom line of a box where drawing\n             * is prohibited\n             * @config {Number}\n             * @default\n             */\n            verticalMargin : 2,\n\n            /**\n             * Start / End box horizontal margin, the amount of pixels from left and right line of a box where drawing\n             * @config {Number}\n             * @default\n             */\n            horizontalMargin : 5,\n\n            /**\n             * Other rectangular areas (obstacles) to search path through\n             * @config {Object[]}\n             * @default\n             */\n            otherBoxes : null,\n\n            /**\n             * The owning Scheduler. Mandatory so that it can determin RTL state.\n             * @config {Scheduler.view.Scheduler}\n             * @private\n             */\n            client : {}\n        };\n    }\n\n    /**\n     * Returns list of horizontal and vertical segments connecting two boxes\n     * <pre>\n     *    |    | |  |    |       |\n     *  --+----+----+----*-------*---\n     *  --+=>Start  +----*-------*--\n     *  --+----+----+----*-------*--\n     *    |    | |  |    |       |\n     *    |    | |  |    |       |\n     *  --*----*-+-------+-------+--\n     *  --*----*-+         End <=+--\n     *  --*----*-+-------+-------+--\n     *    |    | |  |    |       |\n     * </pre>\n     * Path goes by lines (-=) and turns at intersections (+), boxes depicted are adjusted by horizontal/vertical\n     * margin and arrow margin, original boxes are smaller (path can't go at original box borders). Algorithm finds\n     * the shortest path with minimum amount of turns. In short it's mix of \"Lee\" and \"Dijkstra pathfinding\"\n     * with turns amount taken into account for distance calculation.\n     *\n     * The algorithm is not very performant though, it's O(N^2), where N is amount of\n     * points in the grid, but since the maximum amount of points in the grid might be up to 34 (not 36 since\n     * two box middle points are not permitted) that might be ok for now.\n     *\n     * @param {Object} lineDef An object containing any of the class configuration option overrides as well\n     *                         as `startBox`, `endBox`, `startHorizontalMargin`, `startVerticalMargin`,\n     *                         `endHorizontalMargin`, `endVerticalMargin` properties\n     * @param {Object} lineDef.startBox An object containing `start`, `end`, `top`, `bottom` properties\n     * @param {Object} lineDef.endBox   An object containing `start`, `end`, `top`, `bottom` properties\n     * @param {Number} lineDef.startHorizontalMargin Horizontal margin override for start box\n     * @param {Number} lineDef.startVerticalMargin   Vertical margin override for start box\n     * @param {Number} lineDef.endHorizontalMargin   Horizontal margin override for end box\n     * @param {Number} lineDef.endVerticalMargin     Vertical margin override for end box\n     *\n     *\n     * @returns {Object[]|Boolean} Array of line segments or false if path cannot be found\n     * @returns {Number} return.x1\n     * @returns {Number} return.y1\n     * @returns {Number} return.x2\n     * @returns {Number} return.y2\n     */\n    //\n    //@ignore\n    //@privateparam {Function[]|Function} noPathFallbackFn\n    //     A function or array of functions which will be tried in case a path can't be found\n    //     Each function will be given a line definition it might try to adjust somehow and return.\n    //     The new line definition returned will be tried to find a path.\n    //     If a function returns false, then next function will be called if any.\n    //\n    findPath(lineDef, noPathFallbackFn) {\n        const\n            me              = this,\n            originalLineDef = lineDef;\n\n        let lineDefFull,\n            startBox,\n            endBox,\n            startShift,\n            endShift,\n            startSide,\n            endSide,\n            // startArrowSize,\n            // endArrowSize,\n            startArrowMargin,\n            endArrowMargin,\n            horizontalMargin,\n            verticalMargin,\n            startHorizontalMargin,\n            startVerticalMargin,\n            endHorizontalMargin,\n            endVerticalMargin,\n            otherHorizontalMargin,\n            otherVerticalMargin,\n            otherBoxes,\n\n            connStartPoint, connEndPoint,\n            pathStartPoint, pathEndPoint,\n            gridStartPoint, gridEndPoint,\n            startGridBox, endGridBox,\n            grid, path, tryNum;\n\n        noPathFallbackFn = ArrayHelper.asArray(noPathFallbackFn);\n\n        for (tryNum = 0; lineDef && !path;) {\n            lineDefFull = Object.assign(me.config, lineDef);\n\n            startBox              = lineDefFull.startBox;\n            endBox                = lineDefFull.endBox;\n            startShift            = lineDefFull.startShift;\n            endShift              = lineDefFull.endShift;\n            startSide             = lineDefFull.startSide;\n            endSide               = lineDefFull.endSide;\n            // startArrowSize        = lineDefFull.startArrowSize;\n            // endArrowSize          = lineDefFull.endArrowSize;\n            startArrowMargin      = lineDefFull.startArrowMargin;\n            endArrowMargin        = lineDefFull.endArrowMargin;\n            horizontalMargin      = lineDefFull.horizontalMargin;\n            verticalMargin        = lineDefFull.verticalMargin;\n            startHorizontalMargin = lineDefFull.hasOwnProperty('startHorizontalMargin') ? lineDefFull.startHorizontalMargin : horizontalMargin;\n            startVerticalMargin   = lineDefFull.hasOwnProperty('startVerticalMargin') ? lineDefFull.startVerticalMargin : verticalMargin;\n            endHorizontalMargin   = lineDefFull.hasOwnProperty('endHorizontalMargin') ? lineDefFull.endHorizontalMargin : horizontalMargin;\n            endVerticalMargin     = lineDefFull.hasOwnProperty('endVerticalMargin') ? lineDefFull.endVerticalMargin : verticalMargin;\n            otherHorizontalMargin = lineDefFull.hasOwnProperty('otherHorizontalMargin') ? lineDefFull.otherHorizontalMargin : horizontalMargin;\n            otherVerticalMargin   = lineDefFull.hasOwnProperty('otherVerticalMargin') ? lineDefFull.otherVerticalMargin : verticalMargin;\n            otherBoxes            = lineDefFull.otherBoxes;\n\n            startSide = me.normalizeSide(startSide);\n            endSide   = me.normalizeSide(endSide);\n\n            connStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startBox, startSide, startShift);\n            connEndPoint   = me.getConnectionCoordinatesFromBoxSideShift(endBox, endSide, endShift);\n\n            startGridBox   = me.calcGridBaseBoxFromBoxAndDrawParams(startBox, startSide/*, startArrowSize*/, startArrowMargin, startHorizontalMargin, startVerticalMargin);\n            endGridBox     = me.calcGridBaseBoxFromBoxAndDrawParams(endBox, endSide/*, endArrowSize*/, endArrowMargin, endHorizontalMargin, endVerticalMargin);\n\n            // Iterate over points and merge those which are too close to each other (e.g. if difference is less than one\n            // over devicePixelRatio we won't even see this effect in GUI)\n            // https://github.com/bryntum/support/issues/3923\n            BOX_PROPERTIES.forEach(property => {\n                // We're talking subpixel precision here, so it doesn't really matter which value we choose\n                if (Math.abs(startGridBox[property] - endGridBox[property]) <= THRESHOLD) {\n                    endGridBox[property] = startGridBox[property];\n                }\n            });\n\n            if (me.shouldLookForPath(startBox, endBox, startGridBox, endGridBox)) {\n                otherBoxes     = otherBoxes?.map(box =>\n                    me.calcGridBaseBoxFromBoxAndDrawParams(box, false/*, 0*/, 0, otherHorizontalMargin, otherVerticalMargin)\n                );\n                pathStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startGridBox, startSide, startShift);\n                pathEndPoint   = me.getConnectionCoordinatesFromBoxSideShift(endGridBox, endSide, endShift);\n                grid           = me.buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherBoxes);\n                gridStartPoint = me.convertDecartPointToGridPoint(grid, pathStartPoint);\n                gridEndPoint   = me.convertDecartPointToGridPoint(grid, pathEndPoint);\n                path           = me.findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide);\n            }\n\n            //<debug>\n            // drawPathGrid(grid, lineDef.startBox, lineDef.endBox, startGridBox, endGridBox, otherBoxes, 4);\n            //</debug>\n\n            // Loop if\n            // - path is still not found\n            // - have no next line definition (which should be obtained from call to one of the functions from noPathFallbackFn array\n            // - have noPathFallBackFn array\n            // - current try number is less then noPathFallBackFn array length\n            for (lineDef = false; !path && !lineDef && noPathFallbackFn && tryNum < noPathFallbackFn.length; tryNum++) {\n                lineDef = (noPathFallbackFn[tryNum])(lineDefFull, originalLineDef);\n            }\n        }\n\n        if (path) {\n            path = me.prependPathWithArrowStaffSegment(path, connStartPoint/*, startArrowSize*/, startSide);\n            path = me.appendPathWithArrowStaffSegment(path, connEndPoint/*, endArrowSize*/, endSide);\n            path = me.optimizePath(path);\n        }\n\n        return path;\n    }\n\n    // Compares boxes relative position in the given direction.\n    //  0 - 1 is to the left/top of 2\n    //  1 - 1 overlaps with left/top edge of 2\n    //  2 - 1 is inside 2\n    // -2 - 2 is inside 1\n    //  3 - 1 overlaps with right/bottom edge of 2\n    //  4 - 1 is to the right/bottom of 2\n    static calculateRelativePosition(box1, box2, vertical = false) {\n        const\n            startProp = vertical ? 'top' : 'start',\n            endProp   = vertical ? 'bottom' : 'end';\n\n        let result;\n\n        if (box1[endProp] < box2[startProp]) {\n            result = 0;\n        }\n        else if (box1[endProp] <= box2[endProp] && box1[endProp] >= box2[startProp] && box1[startProp] < box2[startProp]) {\n            result = 1;\n        }\n        else if (box1[startProp] >= box2[startProp] && box1[endProp] <= box2[endProp]) {\n            result = 2;\n        }\n        else if (box1[startProp] < box2[startProp] && box1[endProp] > box2[endProp]) {\n            result = -2;\n        }\n        else if (box1[startProp] <= box2[endProp] && box1[endProp] > box2[endProp]) {\n            result = 3;\n        }\n        else {\n            result = 4;\n        }\n\n        return result;\n    }\n\n    // Checks if relative position of the original and marginized boxes is the same\n    static boxOverlapChanged(startBox, endBox, gridStartBox, gridEndBox, vertical = false) {\n        const\n            calculateOverlap = RectangularPathFinder.calculateRelativePosition,\n            originalOverlap  = calculateOverlap(startBox, endBox, vertical),\n            finalOverlap     = calculateOverlap(gridStartBox, gridEndBox, vertical);\n\n        return originalOverlap !== finalOverlap;\n    }\n\n    shouldLookForPath(startBox, endBox, gridStartBox, gridEndBox) {\n        let result = true;\n\n        // Only calculate overlap if boxes are narrow in horizontal direction\n        if (\n            // We refer to the original arrow margins because during lookup those might be nullified and we need some\n            // criteria to tell if events are too narrow\n            (startBox.end - startBox.start <= this.startArrowMargin || endBox.end - endBox.start <= this.endArrowMargin) &&\n            Math.abs(RectangularPathFinder.calculateRelativePosition(startBox, endBox, true)) === 2\n        ) {\n            result = !RectangularPathFinder.boxOverlapChanged(startBox, endBox, gridStartBox, gridEndBox);\n        }\n\n        return result;\n    }\n\n    getConnectionCoordinatesFromBoxSideShift(box, side, shift) {\n        let coords;\n\n        // Note that we deal with screen geometry here, not logical dependency sides\n        // Possible 'start' and 'end' have been resolved to box sides.\n        switch (side) {\n            case 'left':\n                coords = {\n                    x : box.start,\n                    y : (box.top + box.bottom) / 2 + shift\n                };\n                break;\n            case 'right':\n                coords = {\n                    x : box.end,\n                    y : (box.top + box.bottom) / 2 + shift\n                };\n                break;\n            case 'top':\n                coords = {\n                    x : (box.start + box.end) / 2 + shift,\n                    y : box.top\n                };\n                break;\n            case 'bottom':\n                coords = {\n                    x : (box.start + box.end) / 2 + shift,\n                    y : box.bottom\n                };\n                break;\n        }\n\n        return coords;\n    }\n\n    calcGridBaseBoxFromBoxAndDrawParams(box, side/*, arrowSize*/, arrowMargin, horizontalMargin, verticalMargin) {\n        let gridBox;\n\n        switch (this.normalizeSide(side)) {\n            case 'left':\n                gridBox = {\n                    start  : box.start - Math.max(/*arrowSize + */arrowMargin, horizontalMargin),\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + verticalMargin\n                };\n                break;\n            case 'right':\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + Math.max(/*arrowSize + */arrowMargin, horizontalMargin),\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + verticalMargin\n                };\n                break;\n            case 'top':\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - Math.max(/*arrowSize + */arrowMargin, verticalMargin),\n                    bottom : box.bottom + verticalMargin\n                };\n                break;\n            case 'bottom':\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + Math.max(/*arrowSize + */arrowMargin, verticalMargin)\n                };\n                break;\n            default:\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + verticalMargin\n                };\n        }\n\n        return gridBox;\n    }\n\n    normalizeSide(side) {\n        const { rtl } = this.client;\n\n        side => sideToSide[side] || side;\n\n        if (side === 'start') {\n            return rtl ? 'right' : 'left';\n        }\n        if (side === 'end') {\n            return rtl ? 'left' : 'right';\n        }\n        return side;\n    }\n\n    buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherGridBoxes) {\n        let xs, ys,\n            y, x, ix, iy, xslen, yslen, ib, blen, box, permitted, point;\n\n        const\n            points       = {},\n            linearPoints = [];\n\n        xs = [\n            startGridBox.start,\n            (startSide === 'left' || startSide === 'right') ? (startGridBox.start + startGridBox.end) / 2 : pathStartPoint.x,\n            startGridBox.end,\n            endGridBox.start,\n            (endSide === 'left' || endSide === 'right') ? (endGridBox.start + endGridBox.end) / 2 : pathEndPoint.x,\n            endGridBox.end\n        ];\n        ys = [\n            startGridBox.top,\n            (startSide === 'top' || startSide === 'bottom') ? (startGridBox.top + startGridBox.bottom) / 2 : pathStartPoint.y,\n            startGridBox.bottom,\n            endGridBox.top,\n            (endSide === 'top' || endSide === 'bottom') ? (endGridBox.top + endGridBox.bottom) / 2 : pathEndPoint.y,\n            endGridBox.bottom\n        ];\n\n        if (otherGridBoxes) {\n            otherGridBoxes.forEach(box => {\n                xs.push(box.start, (box.start + box.end) / 2, box.end);\n                ys.push(box.top, (box.top + box.bottom) / 2, box.bottom);\n            });\n        }\n\n        xs = [...new Set(xs.sort((a, b) => a - b))];\n        ys = [...new Set(ys.sort((a, b) => a - b))];\n\n        // TODO: fastest way to make unique, Set is slower\n        // for ( let i = 0, I = array.length; i < I; i++ ) {\n        //     if ( ~array.indexOf( array[ i ], i + 1 ) ) {\n        //         array.splice( i, 1 );\n        //         i--;\n        //         I--;\n        //     }\n        // }\n\n        for (iy = 0, yslen = ys.length; iy < yslen; ++iy) {\n            points[iy] = points[iy] || {};\n            y          = ys[iy];\n            for (ix = 0, xslen = xs.length; ix < xslen; ++ix) {\n                x = xs[ix];\n\n                permitted = (\n                    (x <= startGridBox.start || x >= startGridBox.end || y <= startGridBox.top || y >= startGridBox.bottom) &&\n                    (x <= endGridBox.start || x >= endGridBox.end || y <= endGridBox.top || y >= endGridBox.bottom)\n                );\n\n                if (otherGridBoxes) {\n                    for (ib = 0, blen = otherGridBoxes.length; permitted && ib < blen; ++ib) {\n                        box       = otherGridBoxes[ib];\n                        permitted = (x <= box.start || x >= box.end || y <= box.top || y >= box.bottom) ||\n                            // Allow point if it is a path start/end even if point is inside any box\n                            (x === pathStartPoint.x && y === pathStartPoint.y) ||\n                            (x === pathEndPoint.x && y === pathEndPoint.y);\n                    }\n                }\n\n                point = {\n                    distance : Number.MAX_SAFE_INTEGER,\n                    permitted,\n                    x,\n                    y,\n                    ix,\n                    iy\n                };\n\n                points[iy][ix] = point;\n                linearPoints.push(point);\n            }\n        }\n\n        return {\n            width        : xs.length,\n            height       : ys.length,\n            xs           : xs,\n            ys           : ys,\n            points       : points,\n            linearPoints : linearPoints\n        };\n    }\n\n    convertDecartPointToGridPoint(grid, point) {\n        const\n            x = grid.xs.indexOf(point.x),\n            y = grid.ys.indexOf(point.y);\n\n        return grid.points[y][x];\n    }\n\n    findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide) {\n        const me = this;\n\n        let path = false;\n\n        if (gridStartPoint.permitted && gridEndPoint.permitted) {\n            grid = me.waveForward(grid, gridStartPoint, 0);\n            path = me.collectPath(grid, gridEndPoint, endSide);\n        }\n\n        return path;\n    }\n\n    // Returns neighbors from Von Neiman ambit (see Lee pathfinding algorithm description)\n    getGridPointNeighbors(grid, gridPoint, predicateFn) {\n        const\n            ix     = gridPoint.ix,\n            iy     = gridPoint.iy,\n            result = [];\n\n        let neighbor;\n\n        // NOTE:\n        // It's important to push bottom neighbors first since this method is used\n        // in collectPath(), which recursively collects path from end to start node\n        // and if bottom neighbors are pushed first in result array then collectPath()\n        // will produce a line which is more suitable (pleasant looking) for our purposes.\n        if (iy < grid.height - 1) {\n            neighbor = grid.points[iy + 1][ix];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n        if (iy > 0) {\n            neighbor = grid.points[iy - 1][ix];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n        if (ix < grid.width - 1) {\n            neighbor = grid.points[iy][ix + 1];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n        if (ix > 0) {\n            neighbor = grid.points[iy][ix - 1];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n\n        return result;\n    }\n\n    waveForward(grid, gridStartPoint, distance) {\n        const me = this;\n\n        // I use the WalkHelper here because a point on a grid and it's neighbors might be considered as a hierarchy.\n        // The point is the parent node, and it's neighbors are the children nodes. Thus the grid here is hierarchical\n        // data structure which can be walked. WalkHelper walks non-recursively which is exactly what I need as well.\n        WalkHelper.preWalkUnordered(\n            // Walk starting point - a node is a grid point and it's distance from the starting point\n            [gridStartPoint, distance],\n            // Children query function\n            // NOTE: It's important to fix neighbor distance first, before waving to a neighbor, otherwise waving might\n            //       get through a neighbor point setting it's distance to a value more than (distance + 1) whereas we,\n            //       at the children querying moment in time, already know that the possibly optimal distance is (distance + 1)\n            ([point, distance]) => me.getGridPointNeighbors(\n                grid,\n                point,\n                neighborPoint => neighborPoint.permitted && (neighborPoint.distance > distance + 1)\n            ).map(\n                neighborPoint => [neighborPoint, distance + 1] // Neighbor distance fixation\n            ),\n            // Walk step iterator function\n            ([point, distance]) => point.distance = distance // Neighbor distance applying\n        );\n\n        return grid;\n    }\n\n    collectPath(grid, gridEndPoint, endSide) {\n        const\n            me   = this,\n            path = [];\n\n        let pathFound = true,\n            neighbors,\n            lowestDistanceNeighbor,\n            xDiff, yDiff;\n\n        while (pathFound && gridEndPoint.distance) {\n            neighbors = me.getGridPointNeighbors(grid, gridEndPoint, point =>\n                point.permitted && (point.distance === gridEndPoint.distance - 1)\n            );\n\n            pathFound = neighbors.length > 0;\n\n            if (pathFound) {\n                // Prefer turnless neighbors first\n                neighbors = neighbors.sort((a, b) => {\n                    let xDiff, yDiff;\n\n                    xDiff = a.ix - gridEndPoint.ix;\n                    yDiff = a.iy - gridEndPoint.iy;\n\n                    const resultA = (\n                        ((endSide === 'left' || endSide === 'right') && yDiff === 0) ||\n                        ((endSide === 'top' || endSide === 'bottom') && xDiff === 0)\n                    ) ? -1 : 1;\n\n                    xDiff = b.ix - gridEndPoint.ix;\n                    yDiff = b.iy - gridEndPoint.iy;\n\n                    const resultB = (\n                        ((endSide === 'left' || endSide === 'right') && yDiff === 0) ||\n                        ((endSide === 'top' || endSide === 'bottom') && xDiff === 0)\n                    ) ? -1 : 1;\n\n                    if (resultA > resultB) return 1;\n                    if (resultA < resultB) return -1;\n                    // apply additional sorting to be sure to pick bottom path in IE\n                    if (resultA === resultB) return a.y > b.y ? -1 : 1;\n                });\n\n                lowestDistanceNeighbor = neighbors[0];\n\n                path.push({\n                    x1 : lowestDistanceNeighbor.x,\n                    y1 : lowestDistanceNeighbor.y,\n                    x2 : gridEndPoint.x,\n                    y2 : gridEndPoint.y\n                });\n\n                // Detecting new side, either xDiff or yDiff must be 0 (but not both)\n                xDiff = lowestDistanceNeighbor.ix - gridEndPoint.ix;\n                yDiff = lowestDistanceNeighbor.iy - gridEndPoint.iy;\n\n                switch (true) {\n                    case !yDiff && xDiff > 0:\n                        endSide = 'left';\n                        break;\n                    case !yDiff && xDiff < 0:\n                        endSide = 'right';\n                        break;\n                    case !xDiff && yDiff > 0:\n                        endSide = 'top';\n                        break;\n                    case !xDiff && yDiff < 0:\n                        endSide = 'bottom';\n                        break;\n                }\n\n                gridEndPoint = lowestDistanceNeighbor;\n            }\n        }\n\n        return pathFound && path.reverse() || false;\n    }\n\n    prependPathWithArrowStaffSegment(path, connStartPoint/*, startArrowSize*/, startSide) {\n        if (path.length > 0) {\n            const\n                firstSegment   = path[0],\n                prependSegment = {\n                    x2 : firstSegment.x1,\n                    y2 : firstSegment.y1\n                };\n\n            switch (startSide) {\n                case 'left':\n                    prependSegment.x1 = connStartPoint.x/* - startArrowSize*/;\n                    prependSegment.y1 = firstSegment.y1;\n                    break;\n                case 'right':\n                    prependSegment.x1 = connStartPoint.x/* + startArrowSize*/;\n                    prependSegment.y1 = firstSegment.y1;\n                    break;\n                case 'top':\n                    prependSegment.x1 = firstSegment.x1;\n                    prependSegment.y1 = connStartPoint.y/* - startArrowSize*/;\n                    break;\n                case 'bottom':\n                    prependSegment.x1 = firstSegment.x1;\n                    prependSegment.y1 = connStartPoint.y/* + startArrowSize*/;\n                    break;\n            }\n\n            path.unshift(prependSegment);\n        }\n\n        return path;\n    }\n\n    appendPathWithArrowStaffSegment(path, connEndPoint/*, endArrowSize*/, endSide) {\n        if (path.length > 0) {\n            const\n                lastSegment   = path[path.length - 1],\n                appendSegment = {\n                    x1 : lastSegment.x2,\n                    y1 : lastSegment.y2\n                };\n\n            switch (endSide) {\n                case 'left':\n                    appendSegment.x2 = connEndPoint.x/* - endArrowSize*/;\n                    appendSegment.y2 = lastSegment.y2;\n                    break;\n                case 'right':\n                    appendSegment.x2 = connEndPoint.x/* + endArrowSize*/;\n                    appendSegment.y2 = lastSegment.y2;\n                    break;\n                case 'top':\n                    appendSegment.x2 = lastSegment.x2;\n                    appendSegment.y2 = connEndPoint.y/* - endArrowSize*/;\n                    break;\n                case 'bottom':\n                    appendSegment.x2 = lastSegment.x2;\n                    appendSegment.y2 = connEndPoint.y/* + endArrowSize*/;\n                    break;\n            }\n\n            path.push(appendSegment);\n        }\n\n        return path;\n    }\n\n    optimizePath(path) {\n        const optPath = [];\n\n        let prevSegment,\n            curSegment;\n\n        if (path.length > 0) {\n            prevSegment = path.shift();\n            optPath.push(prevSegment);\n\n            while (path.length > 0) {\n                curSegment = path.shift();\n                // both segments are as good as equal\n                if (\n                    equalEnough(prevSegment.x1, curSegment.x1) && equalEnough(prevSegment.y1, curSegment.y1) &&\n                    equalEnough(prevSegment.x2, curSegment.x2) && equalEnough(prevSegment.y2, curSegment.y2)\n                ) {\n                    prevSegment = curSegment;\n                }\n                // both segments are horizontal or very nearly so\n                else if (equalEnough(prevSegment.y1, prevSegment.y2) && equalEnough(curSegment.y1, curSegment.y2)) {\n                    prevSegment.x2 = curSegment.x2;\n                }\n                // both segments are vertical or very nearly so\n                else if (equalEnough(prevSegment.x1, prevSegment.x2) && equalEnough(curSegment.x1, curSegment.x2)) {\n                    prevSegment.y2 = curSegment.y2;\n                }\n                // segments have different orientation (path turn)\n                else {\n                    optPath.push(curSegment);\n                    prevSegment = curSegment;\n                }\n            }\n        }\n\n        return optPath;\n    }\n}\n\n//<debug>\nfunction createBox(startBox, deltaX, deltaY, scale, stroke) {\n    const points = [\n        [startBox.start * scale - deltaX, startBox.top * scale - deltaY],\n        [startBox.start * scale - deltaX, startBox.bottom * scale - deltaY],\n        [startBox.end * scale - deltaX, startBox.bottom * scale - deltaY],\n        [startBox.end * scale - deltaX, startBox.top * scale - deltaY],\n        [startBox.start * scale - deltaX, startBox.top * scale - deltaY]\n    ].map(pair => `${pair[0]},${pair[1]}`).join(' ');\n\n    return `<polyline points=\"${points}\" style=\"stroke:${stroke || 'blue'};stroke-width:4;\"/>`;\n}\n// eslint-disable-next-line no-unused-vars\nfunction drawPathGrid(grid, sourceBox, targetBox, sourceRegion, targetRegion, otherBoxes, scale = 4) {\n    const\n        rowHeight       = 61,\n        xs              = grid.xs.map(x => x * scale),\n        ys              = grid.ys.map(y => y * scale),\n        xsLength        = xs.length,\n        ysLength        = ys.length,\n        verticalLines   = xs.map(x => `<line style=\"stroke:black\" x1=\"${x - xs[0]}\" x2=\"${x - xs[0]}\"\" y1=\"0\" y2=\"${ys[ysLength - 1] - ys[0]}\"/>`),\n        horizontalLines = ys.map(y => `<line style=\"stroke:black\" x1=\"0\" x2=\"${xs[xsLength - 1] - xs[0]}\"\" y1=\"${y - ys[0]}\" y2=\"${y - ys[0]}\" style=\"${y / scale === rowHeight ? 'stroke:red' : ''}\"/>`),\n        extraLines      = [];\n\n    sourceRegion && extraLines.push(createBox(sourceRegion, xs[0], ys[0], scale, 'green'));\n    targetRegion && extraLines.push(createBox(targetRegion, xs[0], ys[0], scale, 'green'));\n    sourceBox && extraLines.push(createBox(sourceBox, xs[0], ys[0], scale));\n    targetBox && extraLines.push(createBox(targetBox, xs[0], ys[0], scale));\n\n    (otherBoxes || []).forEach(box => extraLines.push(createBox(box, xs[0], ys[0], scale, 'red')));\n\n    console.log(`<svg width=\"${xs[xsLength - 1] - xs[0]}\" height=\"${ys[ysLength - 1] - ys[0]}\">${\n        verticalLines.concat(horizontalLines, extraLines).join('')}</svg>`);\n}\n//</debug>\n","import DependencyModel from '../../model/DependencyModel.js';\nimport RectangularPathFinder from '../../util/RectangularPathFinder.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\n\n// TODO Tests\n\n// Determine a line segments drawing direction\nfunction drawingDirection(pointSet) {\n    if (pointSet.x1 === pointSet.x2) {\n        return pointSet.y2 > pointSet.y1 ? 'd' : 'u';\n    }\n\n    return pointSet.x2 > pointSet.x1 ? 'r' : 'l';\n}\n\n// Determine a line segments length\nfunction segmentLength(pointSet) {\n    return pointSet.x1 === pointSet.x2 ? pointSet.y2 - pointSet.y1 : pointSet.x2 - pointSet.x1;\n}\n\n// Define an arc to tie two line segments together\nfunction arc(pointSet, nextPointSet, radius) {\n    const\n        corner  = drawingDirection(pointSet) + drawingDirection(nextPointSet),\n        // Flip x if this or next segment is drawn right to left\n        rx      = radius * (corner.includes('l') ? -1 : 1),\n        // Flip y if this or next segment is drawn bottom to top\n        ry      = radius * (corner.includes('u') ? -1 : 1),\n        // Positive (0) or negative (1) angle\n        sweep   = corner === 'ur' || corner === 'lu' || corner === 'dl' || corner === 'rd' ? 1 : 0;\n\n    return `a${rx},${ry} 0 0 ${sweep} ${rx},${ry}`;\n}\n\n// Define a line for a set of points, tying it together with the next set with an arc when applicable\nfunction line(pointSet, nextPointSet, location, radius, prevRadius) {\n\n    // Horizontal or vertical line\n    let line      = pointSet.x1 === pointSet.x2 ? 'v' : 'h',\n        useRadius = radius;\n\n    // Add an arc?\n    if (radius) {\n        const\n            // Length of this line segment\n            length     = segmentLength(pointSet),\n            // Length of the next one. Both are needed to determine max radius (half of the shortest delta)\n            nextLength = nextPointSet ? Math.abs(segmentLength(nextPointSet)) : Number.MAX_SAFE_INTEGER,\n            // Line direction\n            sign       = Math.sign(length);\n\n        // If we are not passed a radius from the previous line drawn, we use the configured radius. It is used to shorten\n        // this lines length to fit the arc that connects it to the previous line\n        if (prevRadius == null) {\n            prevRadius = radius;\n        }\n\n        // We cannot use a radius larger than half our or our successor's length, doing so would make the segment too long\n        // when the arc is created\n        if (Math.abs(length) < radius * 2 || nextLength < radius * 2) {\n            useRadius = Math.min(Math.abs(length), nextLength) / 2;\n        }\n\n        const\n            // Radius of neighbouring arcs, subtracted from length below...\n            subtract  = location === 'single' ? 0 : location === 'first' ? useRadius : location === 'between' ? prevRadius + useRadius : /*last*/ prevRadius,\n            // ...to produce the length of the line segment to draw\n            useLength = length - subtract * sign;\n\n        // Apply line segment length, unless it passed over 0 in which case we stick to 0\n        line += Math.sign(useLength) !== sign ? 0 : useLength;\n\n        // Add an arc if applicable\n        if (location !== 'last' && location !== 'single' && useRadius > 0) {\n            line += ` ${arc(pointSet, nextPointSet, useRadius)}`;\n        }\n    }\n    // Otherwise take a shorter code path\n    else {\n        line += segmentLength(pointSet);\n    }\n\n    return {\n        line,\n        currentRadius : radius !== useRadius ? useRadius : null\n    };\n}\n\n// Define an SVG path base on points from the path finder.\n// Each segment in the path can be joined by an arc\nfunction pathMapper(radius, points) {\n    const { length } = points;\n\n    if (!length) {\n        return '';\n    }\n\n    let currentRadius = null;\n\n    return `M${points[0].x1},${points[0].y1} ${points.map((pointSet, i) => {\n        // Segment placement among all segments, used to determine if an arc should be added\n        const\n            location =\n                  length === 1 ? 'single'\n                      : i === length - 1 ? 'last'\n                          : i === 0 ? 'first'\n                              : 'between',\n            lineSpec = line(pointSet, points[i + 1], location, radius, currentRadius);\n\n        ({ currentRadius } = lineSpec);\n\n        return lineSpec.line;\n    }).join(' ')}`;\n}\n\n// Mixin that holds the code needed to generate DomConfigs for dependency lines\nexport default Target => class DependencyLineGenerator extends Target {\n    static $name = 'DependencyLineGenerator';\n\n    lineCache = {};\n\n    onSVGReady() {\n        // TODO Get rid of pathFinderConfig?? Move to configurable\n        const me = this;\n\n        me.pathFinder = new RectangularPathFinder({\n            ...me.pathFinderConfig,\n            client : me.client\n        });\n        me.lineDefAdjusters = me.createLineDefAdjusters();\n\n        me.createMarker();\n    }\n\n    changeRadius(radius) {\n        if (radius !== null) {\n            ObjectHelper.assertNumber(radius, 'radius');\n        }\n\n        return radius;\n    }\n\n    updateRadius() {\n        if (!this.isConfiguring) {\n            this.reset();\n        }\n    }\n\n    updateRenderer() {\n        if (!this.isConfiguring) {\n            this.reset();\n        }\n    }\n\n    changeClickWidth(width) {\n        if (width !== null) {\n            ObjectHelper.assertNumber(width, 'clickWidth');\n        }\n\n        return width;\n    }\n\n    updateClickWidth() {\n        if (!this.isConfiguring) {\n            this.reset();\n        }\n    }\n\n    //region Marker\n\n    createMarker() {\n        const\n            me            = this,\n            { markerDef } = me,\n            svg           = this.client.svgCanvas,\n            // SVG markers has to use an id, we want the id to be per scheduler when using multiple\n            markerId      = markerDef ? `${me.client.id}-arrowEnd` : 'arrowEnd';\n\n        me.marker?.remove();\n\n        svg.style.setProperty('--scheduler-dependency-marker', `url(#${markerId})`);\n\n        me.marker = DomHelper.createElement({\n            parent        : svg,\n            id            : markerId, // no-sanity\n            tag           : 'marker',\n            className     : 'b-sch-dependency-arrow',\n            ns            : 'http://www.w3.org/2000/svg',\n            markerHeight  : 11,\n            markerWidth   : 11,\n            refX          : 8.5,\n            refY          : 3,\n            viewBox       : '0 0 9 6',\n            orient        : 'auto-start-reverse',\n            markerUnits   : 'userSpaceOnUse',\n            retainElement : true,\n            children      : [{\n                tag : 'path',\n                ns  : 'http://www.w3.org/2000/svg',\n                d   : me.markerDef ?? 'M3,0 L3,6 L9,3 z'\n            }]\n        });\n    }\n\n    updateMarkerDef() {\n        if (!this.isConfiguring) {\n            this.createMarker();\n        }\n    }\n\n    //endregion\n\n    //region DomConfig\n\n    getAssignmentElement(assignment) {\n        // If we are dragging an event, we need to use the proxy element\n        // (which is not the original element if we are not constrained to timeline)\n        const proxyElement = this.client.features.eventDrag?.getProxyElement(assignment);\n\n        return proxyElement || this.client.getElementFromAssignmentRecord(assignment);\n    }\n\n    // Generate a DomConfig for a dependency line between two assignments (tasks in Gantt)\n    getDomConfigs(dependency, fromAssignment, toAssignment, forceBoxes) {\n        const\n            me     = this,\n            key    = me.getDependencyKey(dependency, fromAssignment, toAssignment),\n            // Under certain circumstances (scrolling) we might be able to reuse the previous DomConfig.\n            cached = me.lineCache[key];\n\n        // Create line def if not cached, or we are live drawing and have event elements (dragging, transitioning etc)\n        if (me.constructLineCache || !cached || forceBoxes || (me.drawingLive && (me.getAssignmentElement(fromAssignment) || me.getAssignmentElement(toAssignment)))) {\n            const\n                lineDef     = me.prepareLineDef(dependency, fromAssignment, toAssignment, forceBoxes),\n                points      = lineDef && me.pathFinder.findPath(lineDef, me.lineDefAdjusters),\n                {\n                    client,\n                    clickWidth\n                }           = me,\n                { toEvent } = dependency;\n\n            if (points) {\n                const\n                    highlighted = me.highlighted.get(dependency),\n                    domConfig   = {\n                        tag     : 'path',\n                        ns      : 'http://www.w3.org/2000/svg',\n                        d       : pathMapper(me.radius ?? 0, points),\n                        role    : 'presentation',\n                        dataset : {\n                            syncId : key,\n                            depId  : dependency.id,\n                            fromId : fromAssignment.id,\n                            toId   : toAssignment.id\n                        },\n                        elementData : {\n                            dependency,\n                            points\n                        },\n                        class : {\n                            [me.baseCls]                                : 1,\n                            [dependency.cls]                            : dependency.cls,\n                            // Data highlight\n                            [dependency.highlighted]                    : dependency.highlighted,\n                            // Feature highlight\n                            [highlighted && [...highlighted].join(' ')] : highlighted,\n                            [me.noMarkerCls]                            : lineDef.hideMarker,\n                            'b-inactive'                                : dependency.active === false,\n                            'b-sch-bidirectional-line'                  : dependency.bidirectional,\n                            'b-readonly'                                : dependency.readOnly,\n                            // If target event is outside the view add special CSS class to hide marker (arrow)\n                            'b-sch-dependency-ends-outside'             :\n                                (!toEvent.milestone && (toEvent.endDate <= client.startDate || client.endDate <= toEvent.startDate)) ||\n                                (toEvent.milestone && (toEvent.endDate < client.startDate || client.endDate < toEvent.startDate))\n                        }\n                    };\n\n                me.renderer?.({\n                    domConfig,\n                    points,\n                    dependencyRecord     : dependency,\n                    fromAssignmentRecord : fromAssignment,\n                    toAssignmentRecord   : toAssignment,\n                    fromBox              : lineDef.startBox,\n                    toBox                : lineDef.endBox,\n                    fromSide             : lineDef.startSide,\n                    toSide               : lineDef.endSide\n                });\n\n                const configs = [domConfig];\n\n                if (clickWidth > 1) {\n                    configs.push({\n                        ...domConfig, // Shallow on purpose, to not waste perf cloning deeply\n                        class : {\n                            ...domConfig.class,\n                            'b-click-area' : 1\n                        },\n                        dataset : {\n                            ...domConfig.dataset,\n                            syncId : `${domConfig.dataset.syncId}-click-area`\n                        },\n                        style : {\n                            strokeWidth : clickWidth\n                        }\n                    });\n                }\n\n                return me.lineCache[key] = configs;\n            }\n\n            // Nothing to draw or cache\n            return me.lineCache[key] = null;\n        }\n\n        return cached;\n    }\n\n    //endregion\n\n    //region Bounds\n\n    // Generates `otherBoxes` config for rectangular path finder, which push dependency line to the row boundary.\n    // It should be enough to return single box with top/bottom taken from row top/bottom and left/right taken from source\n    // box, extended by start arrow margin to both sides.\n    generateBoundaryBoxes(box, side) {\n        // We need two boxes for the bottom edge, because otherwise path cannot be found. Ideally that shouldn't be\n        // necessary. Other solution would be to adjust bottom by -1px, but that would make some dependency lines to take\n        // 1px different path on a row boundary, which doesn't look nice (but slightly more performant)\n        if (side === 'bottom') {\n            return [\n                {\n                    start  : box.left,\n                    end    : box.left + box.width / 2,\n                    top    : box.rowTop,\n                    bottom : box.rowBottom\n                },\n                {\n                    start  : box.left + box.width / 2,\n                    end    : box.right,\n                    top    : box.rowTop,\n                    bottom : box.rowBottom\n                }\n            ];\n        }\n        else {\n            return [\n                {\n                    start  : box.left - this.pathFinder.startArrowMargin,\n                    end    : box.right + this.pathFinder.startArrowMargin,\n                    top    : box.rowTop,\n                    bottom : box.rowBottom\n                }\n            ];\n        }\n\n        // //<debug>\n        // globalThis.DEBUG && boxes.forEach(box => {\n        //     DomHelper.createElement({\n        //         parent : document.querySelector('.b-sch-foreground-canvas'),\n        //         html   : `<div style=\"left:${box.start}px;top:${box.top}px;width:${box.end - box.start}px;height:${box.bottom - box.top}px;border:1px solid green;position:absolute;\"></div>`\n        //     });\n        // });\n        // //</debug>\n    }\n\n    // Bounding box for an assignment, uses elements bounds if rendered\n    getAssignmentBounds(assignment) {\n        const\n            { client } = this,\n            element    = this.getAssignmentElement(assignment);\n\n        if (element && !client.isExporting) {\n            const rectangle = Rectangle.from(element, this.relativeTo);\n\n            if (client.isHorizontal) {\n                let row = client.getRowById(assignment.resource.id);\n\n                // Outside of its row? It is being dragged, resolve new row\n                if (rectangle.y < row.top || rectangle.bottom > row.bottom) {\n                    const overRow = client.rowManager.getRowAt(rectangle.center.y, true);\n                    if (overRow) {\n                        row = overRow;\n                    }\n                }\n\n                rectangle.rowTop = row.top;\n                rectangle.rowBottom = row.bottom;\n            }\n\n            return rectangle;\n        }\n\n        return client.isEngineReady && client.getAssignmentEventBox(assignment, true);\n    }\n\n    //endregion\n\n    //region Sides\n\n    getConnectorStartSide(timeSpanRecord) {\n        return this.client.currentOrientation.getConnectorStartSide(timeSpanRecord);\n    }\n\n    getConnectorEndSide(timeSpanRecord) {\n        return this.client.currentOrientation.getConnectorEndSide(timeSpanRecord);\n    }\n\n    getDependencyStartSide(dependency) {\n        const { fromEvent, type, fromSide } = dependency;\n\n        if (fromSide) {\n            return fromSide;\n        }\n\n        switch (true) {\n            case type === DependencyModel.Type.StartToEnd:\n            case type === DependencyModel.Type.StartToStart:\n                return this.getConnectorStartSide(fromEvent);\n\n            case type === DependencyModel.Type.EndToStart:\n            case type === DependencyModel.Type.EndToEnd:\n                return this.getConnectorEndSide(fromEvent);\n\n            default:\n                // Default value might not be applied yet when rendering early in Pro / Gantt\n                return this.getConnectorEndSide(fromEvent);\n        }\n    }\n\n    getDependencyEndSide(dependency) {\n        const { toEvent, type, toSide } = dependency;\n\n        if (toSide) {\n            return toSide;\n        }\n\n        // Fallback to view trait if dependency end side is not given /*or can be obtained from type*/\n        switch (true) {\n            case type === DependencyModel.Type.EndToEnd:\n            case type === DependencyModel.Type.StartToEnd:\n                return this.getConnectorEndSide(toEvent);\n\n            case type === DependencyModel.Type.EndToStart:\n            case type === DependencyModel.Type.StartToStart:\n                return this.getConnectorStartSide(toEvent);\n\n            default:\n                // Default value might not be applied yet when rendering early in Pro / Gantt\n                return this.getConnectorStartSide(toEvent);\n        }\n    }\n\n    //endregion\n\n    //region Line def\n\n    // An array of functions used to alter path config when no path found.\n    // It first tries to shrink arrow margins and secondly hides arrows entirely\n    createLineDefAdjusters() {\n        const { client } = this;\n\n        function shrinkArrowMargins(lineDef) {\n            const { barMargin } = client;\n\n            let adjusted = false;\n\n            if (lineDef.startArrowMargin > barMargin || lineDef.endArrowMargin > barMargin) {\n                lineDef.startArrowMargin = lineDef.endArrowMargin = barMargin;\n                adjusted = true;\n            }\n\n            return adjusted ? lineDef : adjusted;\n        }\n\n        function resetArrowMargins(lineDef) {\n            let adjusted = false;\n\n            if (lineDef.startArrowMargin > 0 || lineDef.endArrowMargin > 0) {\n                lineDef.startArrowMargin = lineDef.endArrowMargin = 0;\n                adjusted = true;\n            }\n\n            return adjusted ? lineDef : adjusted;\n        }\n\n        function shrinkHorizontalMargin(lineDef, originalLineDef) {\n            let adjusted = false;\n\n            if (lineDef.horizontalMargin > 2) {\n                lineDef.horizontalMargin = 1;\n                adjusted = true;\n                originalLineDef.hideMarker = true;\n            }\n\n            return adjusted ? lineDef : adjusted;\n        }\n\n        return [\n            shrinkArrowMargins,\n            resetArrowMargins,\n            shrinkHorizontalMargin\n        ];\n    }\n\n    // Overridden in Gantt\n    adjustLineDef(dependency, lineDef) {\n        return lineDef;\n    }\n\n    // Prepare data to feed to the path finder\n    prepareLineDef(dependency, fromAssignment, toAssignment, forceBoxes) {\n        const\n            me             = this,\n            startSide      = me.getDependencyStartSide(dependency),\n            endSide        = me.getDependencyEndSide(dependency),\n            startRectangle = forceBoxes?.from ?? me.getAssignmentBounds(fromAssignment),\n            endRectangle   = forceBoxes?.to ?? me.getAssignmentBounds(toAssignment),\n            otherBoxes     = [];\n\n        if (!startRectangle || !endRectangle) {\n            return null;\n        }\n\n        let {\n            startArrowMargin,\n            verticalMargin\n        } = me.pathFinder;\n\n        if (me.client.isHorizontal) {\n            // Only add otherBoxes if assignments are in different resources\n            if (startRectangle.rowTop != null && startRectangle.rowTop !== endRectangle.rowTop) {\n                otherBoxes.push(...me.generateBoundaryBoxes(startRectangle, startSide));\n            }\n\n            // Do not change start arrow margin in case dependency is bidirectional\n            if (!dependency.bidirectional) {\n                if (/(top|bottom)/.test(startSide)) {\n                    startArrowMargin = me.client.barMargin / 2;\n                }\n\n                verticalMargin = me.client.barMargin / 2;\n            }\n        }\n\n        return me.adjustLineDef(dependency, {\n            startBox              : startRectangle,\n            endBox                : endRectangle,\n            otherBoxes,\n            startArrowMargin,\n            verticalMargin,\n            otherVerticalMargin   : 0,\n            otherHorizontalMargin : 0,\n            startSide,\n            endSide\n        });\n    }\n\n    //endregion\n\n    //region Cache\n\n    // All dependencies are about to be drawn, check if we need to build the line cache\n    beforeDraw() {\n        super.beforeDraw();\n\n        if (!Object.keys(this.lineCache).length) {\n            this.constructLineCache = true;\n        }\n    }\n\n    // All dependencies are drawn, we no longer need to rebuild the cache\n    afterDraw() {\n        super.afterDraw();\n\n        this.constructLineCache = false;\n    }\n\n    reset() {\n        super.reset();\n\n        this.lineCache = {};\n    }\n\n    //endregion\n\n};\n","import Tooltip from '../../../Core/widget/Tooltip.js';\n\n/**\n * @module Scheduler/feature/mixin/DependencyTooltip\n */\n\nconst\n    // Map dependency type to side of a box, for displaying an icon in the tooltip\n    fromBoxSide = [\n        'start',\n        'start',\n        'end',\n        'end'\n    ],\n    toBoxSide   = [\n        'start',\n        'end',\n        'start',\n        'end'\n    ];\n\n/**\n * Mixin that adds tooltip support to the {@link Scheduler/feature/Dependencies} feature.\n * @mixin\n */\nexport default Target => class DependencyTooltip extends Target {\n    static $name = 'DependencyTooltip';\n\n    static configurable = {\n        /**\n         * Set to true to show a tooltip when hovering a dependency line\n         * @config {Boolean}\n         */\n        showTooltip : true,\n\n        /**\n         * A template function allowing you to configure the contents of the tooltip shown when hovering a\n         * dependency line. You can return either an HTML string or a {@link DomConfig} object.\n         * @prp {Function} tooltipTemplate\n         * @param {Scheduler.model.DependencyBaseModel} dependency The dependency record\n         * @returns {String|DomConfig}\n         */\n        tooltipTemplate(dependency) {\n            return {\n                children : [{\n                    className : 'b-sch-dependency-tooltip',\n                    children  : [\n                        { tag : 'label', text : this.L('L{Dependencies.from}') },\n                        { text : dependency.fromEvent.name },\n                        { className : `b-sch-box b-${dependency.fromSide || fromBoxSide[dependency.type]}` },\n                        { tag : 'label', text : this.L('L{Dependencies.to}') },\n                        { text : dependency.toEvent.name },\n                        { className : `b-sch-box b-${dependency.toSide || toBoxSide[dependency.type]}` }\n                    ]\n                }]\n            };\n        },\n\n        /**\n         * A tooltip config object that will be applied to the dependency hover tooltip. Can be used to for example\n         * customize delay\n         * @config {TooltipConfig}\n         */\n        tooltip : {\n            $config : 'nullify',\n\n            value : {}\n        }\n    };\n\n    changeTooltip(tooltip, old) {\n        const me = this;\n\n        old?.destroy();\n\n        if (!me.showTooltip || !tooltip) {\n            return null;\n        }\n\n        return Tooltip.new({\n            align          : 'b-t',\n            id             : `${me.client.id}-dependency-tip`,\n            //TODO: need some way better to specify this. maybe each feature should be queried?\n            forSelector    : `.b-timelinebase:not(.b-eventeditor-editing):not(.b-resizing-event):not(.b-dragcreating):not(.b-dragging-event):not(.b-creating-dependency) .${me.baseCls}`,\n            forElement     : me.client.timeAxisSubGridElement,\n            showOnHover    : true,\n            hoverDelay     : 0,\n            hideDelay      : 0,\n            anchorToTarget : false,\n            textContent    : false, // Skip max-width setting\n            trackMouse     : false,\n            getHtml        : me.getHoverTipHtml.bind(me)\n        }, tooltip);\n    }\n\n    /**\n     * Generates DomConfig content for the tooltip shown when hovering a dependency\n     * @param {Object} tooltipConfig\n     * @returns {DomConfig} DomConfig used as tooltips content\n     * @private\n     */\n    getHoverTipHtml({ activeTarget }) {\n        return this.tooltipTemplate(this.resolveDependencyRecord(activeTarget));\n    }\n};\n","import DomSync from '../../Core/helper/DomSync.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport AttachToProjectMixin from '../data/mixin/AttachToProjectMixin.js';\nimport DependencyCreation from './mixin/DependencyCreation.js';\nimport DependencyGridCache from './mixin/DependencyGridCache.js';\nimport DependencyLineGenerator from './mixin/DependencyLineGenerator.js';\nimport DependencyTooltip from './mixin/DependencyTooltip.js';\n\nconst eventNameMap = {\n    click       : 'Click',\n    dblclick    : 'DblClick',\n    contextmenu : 'ContextMenu'\n};\n/**\n * @module Scheduler/feature/Dependencies\n */\n\nconst collectLinkedAssignments = assignment => {\n    const result = [assignment];\n\n    if (assignment.resource?.hasLinks) {\n        // Fake linked assignments\n        result.push(...assignment.resource.$links.map(l => ({\n            id               : `${l.id}_${assignment.id}`,\n            resource         : l,\n            event            : assignment.event,\n            drawDependencies : assignment.drawDependencies\n        })));\n    }\n\n    return result;\n};\n\n/**\n * Feature that draws dependencies between events. Uses a {@link Scheduler.data.DependencyStore} to determine which\n * dependencies to draw, if none is defined one will be created automatically. Dependencies can also be specified as\n * `scheduler.dependencies`, see example below:\n *\n * {@inlineexample Scheduler/feature/Dependencies.js}\n *\n * Dependencies also work in vertical mode:\n *\n * {@inlineexample Scheduler/feature/DependenciesVertical.js}\n *\n * To customize the dependency tooltip, you can provide the {@link #config-tooltip} config and specify a\n * {@link Core.widget.Tooltip#config-getHtml} function. For example:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         dependencies : {\n *             tooltip : {\n *                 getHtml({ activeTarget }) {\n *                     const dependencyModel = scheduler.resolveDependencyRecord(activeTarget);\n *\n *                     if (!dependencyModel) return null;\n *\n *                     const { fromEvent, toEvent } = dependencyModel;\n *\n *                     return `${fromEvent.name} (${fromEvent.id}) -> ${toEvent.name} (${toEvent.id})`;\n *                 }\n *             }\n *         }\n *     }\n * }\n * ```\n *\n * ## Styling dependency lines\n *\n * You can easily customize the arrows drawn between events. To change all arrows, apply the following basic SVG CSS:\n *\n * ```css\n * .b-sch-dependency {\n *    stroke-width: 2;\n *    stroke : red;\n * }\n *\n * .b-sch-dependency-arrow {\n *     fill: red;\n * }\n * ```\n *\n * To style an individual dependency line, you can provide a [cls](#Scheduler/model/DependencyModel#field-cls) in your\n * data:\n *\n * ```json\n * {\n *     \"id\"   : 9,\n *     \"from\" : 7,\n *     \"to\"   : 8,\n *     \"cls\"  : \"special-dependency\"\n * }\n * ```\n *\n * ```scss\n * // Make line dashed\n * .b-sch-dependency {\n *    stroke-dasharray: 5, 5;\n * }\n * ```\n *\n * To customize the marker used for the lines (the arrow header), you can supply a SVG path definition to the\n * {@link #config-markerDef} config:\n *\n * {@inlineexample Scheduler/feature/DependenciesMarker.js}\n *\n * You can also specify a {@link #config-radius} to get lines with rounded \"corners\", for a less boxy look:\n *\n * {@inlineexample Scheduler/feature/DependenciesRadius.js}\n *\n * For advanced use cases, you can also manipulate the {@link DomConfig} used to create a dependency line in a\n * {@link #config-renderer} function.\n *\n * This feature is **off** by default. For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * @mixes Core/mixin/Delayable\n * @mixes Scheduler/feature/mixin/DependencyCreation\n * @mixes Scheduler/feature/mixin/DependencyTooltip\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Scheduler/dependencies\n * @classtype dependencies\n * @feature\n */\nexport default class Dependencies extends InstancePlugin.mixin(\n    AttachToProjectMixin,\n    Delayable,\n    DependencyCreation,\n    DependencyGridCache,\n    DependencyLineGenerator,\n    DependencyTooltip\n) {\n    static $name = 'Dependencies';\n\n    /**\n     * Fired when dependencies are rendered\n     * @on-owner\n     * @event dependenciesDrawn\n     */\n\n    //region Config\n\n    static configurable = {\n        /**\n         * The CSS class to add to a dependency line when hovering over it\n         * @config {String}\n         * @default\n         * @private\n         */\n        overCls : 'b-sch-dependency-over',\n\n        /**\n         * The CSS class applied to dependency lines\n         * @config {String}\n         * @default\n         * @private\n         */\n        baseCls : 'b-sch-dependency',\n\n        /**\n         * The CSS class applied to a too narrow dependency line (to hide markers)\n         * @config {String}\n         * @default\n         * @private\n         */\n        noMarkerCls : 'b-sch-dependency-markerless',\n\n        /**\n         * SVG path definition used as marker (arrow head) for the dependency lines.\n         * Should fit in a viewBox that is 9 x 6.\n         *\n         * ```javascript\n         * const scheduler = new Scheduler({\n         *     features : {\n         *         dependencies : {\n         *             // Circular marker\n         *             markerDef : 'M 2,3 a 3,3 0 1,0 6,0 a 3,3 0 1,0 -6,0'\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @config {String}\n         * @default 'M3,0 L3,6 L9,3 z'\n         */\n        markerDef : null,\n\n        /**\n         * Radius (in px) used to draw arcs where dependency line segments connect. Specify it to get a rounded look.\n         * The radius will during drawing be reduced as needed on a per segment basis to fit lines.\n         *\n         * ```javascript\n         * const scheduler = new Scheduler({\n         *     features : {\n         *         dependencies : {\n         *             // Round the corner where line segments connect, similar to 'border-radius: 5px'\n         *             radius : 5\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * <div class=\"note\">Using a radius slightly degrades dependency rendering performance. If your app displays\n         * a lot of dependencies, it might be worth taking this into account when deciding if you want to use radius\n         * or not</div>\n         *\n         * @config {Number}\n         */\n        radius : null,\n\n        /**\n         * Renderer function, supply one if you want to manipulate the {@link DomConfig} object used to draw a\n         * dependency line between two assignments.\n         *\n         * ```javascript\n         * const scheduler = new Scheduler({\n         *     features : {\n         *         dependencies : {\n         *             renderer({ domConfig, fromAssignmentRecord : from, toAssignmentRecord : to }) {\n         *                 // Add a custom CSS class to dependencies between important assignments\n         *                 domConfig.class.important = from.important || to.important;\n         *                 domConfig.class.veryImportant = from.important && to.important;\n         *             }\n         *         }\n         *     }\n         * }\n         * ```\n         *\n         * @param {Object} renderData\n         * @param {DomConfig} renderData.domConfig that will be used to create the dependency line, can be manipulated by the\n         * renderer\n         * @param {Scheduler.model.DependencyModel} renderData.dependencyRecord The dependency being rendered\n         * @param {Scheduler.model.AssignmentModel} renderData.fromAssignmentRecord Drawing line from this assignment\n         * @param {Scheduler.model.AssignmentModel} renderData.toAssignmentRecord Drawing line to this assignment\n         * @param {Object[]} renderData.points A collection of points making up the line segments for the dependency\n         * line. Read-only in the renderer, any manipulation should be done to `domConfig`\n         * @param {Core.helper.util.Rectangle} renderData.fromBox Bounds for the fromAssignment's element\n         * @param {Core.helper.util.Rectangle} renderData.toBox Bounds for the toAssignment's element\n         * @param {'top'|'right'|'bottom'|'left'} renderData.fromSide Drawn from this side of the fromAssignment\n         * @param {'top'|'right'|'bottom'|'left'} renderData.toSide Drawn to this side of the fromAssignment\n         * @prp {Function}\n         */\n        renderer : null,\n\n        /**\n         * Specify `true` to highlight incoming and outgoing dependencies when hovering an event.\n         * @prp {Boolean}\n         */\n        highlightDependenciesOnEventHover : null,\n\n        /**\n         * Specify `false` to prevent dependencies from being drawn during scroll, for smoother scrolling in schedules\n         * with lots of dependencies. Dependencies will be drawn when scrolling stops instead.\n         * @prp {Boolean}\n         * @default\n         */\n        drawOnScroll : true,\n\n        /**\n         * The clickable/touchable width of the dependency line in pixels. Setting this to a number greater than 1 will\n         * draw an invisible but clickable line along the same path as the dependency line, making it easier to click.\n         * The tradeoff is that twice as many lines will be drawn, which can affect performance.\n         * @prp {Number}\n         */\n        clickWidth : null\n    };\n\n    static delayable = {\n        doRefresh : 10\n    };\n\n    static get pluginConfig() {\n        return {\n            chain  : ['render', 'onPaint', 'onElementClick', 'onElementDblClick', 'onElementContextMenu', 'onElementMouseOver', 'onElementMouseOut', 'bindStore'],\n            assign : ['getElementForDependency', 'getElementsForDependency', 'resolveDependencyRecord']\n        };\n    };\n\n    domConfigs  = new Map();\n    drawingLive = false;\n    lastScrollX = null;\n    highlighted = new Map();\n    // Cached lookups\n    visibleResources = null;\n    usingLinks       = null;\n    visibleDateRange = null;\n    relativeTo       = null;\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(client, config) {\n        super.construct(client, config);\n\n        const { scheduledEventName } = client;\n\n        client.ion({\n            svgCanvasCreated                            : 'onSVGReady',\n            // These events trigger live refresh behaviour\n            animationStart                              : 'refresh',\n            // eventDrag in Scheduler, taskDrag in Gantt\n            [scheduledEventName + 'DragStart']          : 'refresh',\n            [scheduledEventName + 'ResizeStart']        : 'refresh',\n            [scheduledEventName + 'SegmentDragStart']   : 'refresh',\n            [scheduledEventName + 'SegmentResizeStart'] : 'refresh',\n            // These events shift the surroundings to such extent that grid cache needs rebuilding to be sure that\n            // all dependencies are considered\n            timelineViewportResize                      : 'reset',\n            timeAxisViewModelUpdate                     : 'reset',\n            toggleNode                                  : 'reset',\n            thisObj                                     : this\n        });\n\n        client.rowManager.ion({\n            refresh           : 'reset', // For example when changing barMargin or rowHeight\n            changeTotalHeight : 'reset', // For example when collapsing groups\n            thisObj           : this\n        });\n\n        this.bindStore(client.store);\n    }\n\n    doDisable(disable) {\n        if (!this.isConfiguring) {\n            // Need a flag to clear dependencies when disabled, since drawing is otherwise disabled too\n            this._isDisabling = disable;\n            this.draw();\n            this._isDisabling = false;\n        }\n\n        super.doDisable(disable);\n    }\n\n    //endregion\n\n    //region RefreshTriggers\n\n    get rowStore() {\n        return this.client.isVertical ? this.client.resourceStore : this.client.store;\n    }\n\n    // React to replacing or refreshing a display store\n    bindStore(store) {\n        const me = this;\n\n        if (!me.client.isVertical) {\n            me.detachListeners('store');\n\n            if (me.client.usesDisplayStore) {\n                store?.ion({\n                    name    : 'store',\n                    refresh : 'onStoreRefresh',\n                    thisObj : me\n                });\n\n                me.reset();\n            }\n        }\n    }\n\n    onStoreRefresh() {\n        this.reset();\n    }\n\n    // TODO: Need toggleNode, viewportResize, translateRow, changeTotalHeight, idChange ?\n\n    attachToProject(project) {\n        super.attachToProject(project);\n\n        project?.ion({\n            name            : 'project',\n            commitFinalized : 'reset',\n            thisObj         : this\n        });\n    }\n\n    attachToResourceStore(resourceStore) {\n        super.attachToResourceStore(resourceStore);\n\n        resourceStore?.ion({\n            name    : 'resourceStore',\n            change  : 'onResourceStoreChange',\n            refresh : 'onResourceStoreChange',\n            thisObj : this\n        });\n    }\n\n    onResourceStoreChange() {\n        // Might have added or removed links, need to re-cache the flag\n        this.usingLinks = null;\n        this.reset();\n    }\n\n    attachToEventStore(eventStore) {\n        super.attachToEventStore(eventStore);\n\n        eventStore?.ion({\n            name    : 'eventStore',\n            refresh : 'reset',\n            thisObj : this\n        });\n    }\n\n    attachToAssignmentStore(assignmentStore) {\n        super.attachToAssignmentStore(assignmentStore);\n\n        assignmentStore?.ion({\n            name    : 'assignmentStore',\n            refresh : 'reset',\n            thisObj : this\n        });\n    }\n\n    attachToDependencyStore(dependencyStore) {\n        super.attachToDependencyStore(dependencyStore);\n\n        dependencyStore?.ion({\n            name    : 'dependencyStore',\n            change  : 'reset',\n            refresh : 'reset',\n            thisObj : this\n        });\n    }\n\n    updateDrawOnScroll(drawOnScroll) {\n        const me = this;\n\n        me.detachListeners('scroll');\n\n        if (drawOnScroll) {\n            me.client.ion({\n                name             : 'scroll',\n                scroll           : 'doRefresh',\n                horizontalScroll : 'onHorizontalScroll',\n                prio             : -100, // After Scheduler draws on scroll, since we target elements\n                thisObj          : me\n            });\n        }\n        else {\n            me.client.scrollable.ion({\n                name      : 'scroll',\n                scrollEnd : 'draw',\n                thisObj   : me\n            });\n\n            me.client.timeAxisSubGrid.scrollable.ion({\n                name      : 'scroll',\n                scrollEnd : 'draw',\n                thisObj   : me\n            });\n        }\n    }\n\n    onHorizontalScroll({ subGrid, scrollX }) {\n        if (scrollX !== this.lastScrollX && subGrid === this.client.timeAxisSubGrid) {\n            this.lastScrollX = scrollX;\n            this.draw();\n        }\n    }\n\n    onPaint() {\n        this.refresh();\n    }\n\n    //endregion\n\n    //region Dependency types\n\n    // Used by DependencyField\n    static getLocalizedDependencyType(type) {\n        // Do not remove. Assertion strings for Localization sanity check.\n        // 'L{DependencyType.SS}'\n        // 'L{DependencyType.SF}'\n        // 'L{DependencyType.FS}'\n        // 'L{DependencyType.FF}'\n        // 'L{DependencyType.StartToStart}'\n        // 'L{DependencyType.StartToEnd}'\n        // 'L{DependencyType.EndToStart}'\n        // 'L{DependencyType.EndToEnd}'\n        // 'L{DependencyType.long}'\n        // 'L{DependencyType.short}'\n\n        return type ? this.L(`L{DependencyType.${type}}`) : '';\n    }\n\n    //endregion\n\n    //region Elements\n\n    getElementForDependency(dependency, fromAssignment, toAssignment) {\n        return this.getElementsForDependency(dependency, fromAssignment, toAssignment)[0];\n    }\n\n    // NOTE: If we ever make this public we should change it to use the syncIdMap. Currently not needed since only\n    // used in tests\n    getElementsForDependency(dependency, fromAssignment, toAssignment) {\n        // Selector targeting all instances of a dependency\n        let selector = `[data-dep-id=\"${dependency.id}\"]`;\n\n        // Optionally narrow it down to a single instance (assignment)\n        if (fromAssignment) {\n            selector += `[data-from-id=\"${fromAssignment.id}\"]`;\n        }\n        if (toAssignment) {\n            selector += `[data-to-id=\"${toAssignment.id}\"]`;\n        }\n\n        return Array.from(this.client.svgCanvas.querySelectorAll(selector));\n    }\n\n    /**\n     * Returns the dependency record for a DOM element\n     * @param {HTMLElement} element The dependency line element\n     * @returns {Scheduler.model.DependencyModel} The dependency record\n     */\n    resolveDependencyRecord(element) {\n        return element.elementData?.dependency;\n    }\n\n    isDependencyElement(element) {\n        return element.matches(`.${this.baseCls}`);\n    }\n\n    //endregion\n\n    //region DOM Events\n\n    onElementClick(event) {\n        const dependency = this.resolveDependencyRecord(event.target);\n\n        if (dependency) {\n            const eventName = eventNameMap[event.type];\n\n            /**\n             * Fires on the owning Scheduler/Gantt when a click is registered on a dependency line.\n             * @event dependencyClick\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            /**\n             * Fires on the owning Scheduler/Gantt when a click is registered on a dependency line.\n             * @event dependencyDblClick\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            this.client.trigger(`dependency${eventName}`, {\n                dependency,\n                event\n            });\n        }\n    }\n\n    onElementDblClick(event) {\n        return this.onElementClick(event);\n    }\n\n    onElementContextMenu(event) {\n        return this.onElementClick(event);\n    }\n\n    onElementMouseOver(event) {\n        const\n            me         = this,\n            dependency = me.resolveDependencyRecord(event.target);\n\n        if (dependency) {\n            /**\n             * Fires on the owning Scheduler/Gantt when the mouse moves over a dependency line.\n             * @event dependencyMouseOver\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            me.client.trigger('dependencyMouseOver', {\n                dependency,\n                event\n            });\n\n            if (me.overCls) {\n                me.highlight(dependency);\n            }\n        }\n    }\n\n    onElementMouseOut(event) {\n        const\n            me         = this,\n            dependency = me.resolveDependencyRecord(event.target);\n\n        if (dependency) {\n            /**\n             * Fires on the owning Scheduler/Gantt when the mouse moves out of a dependency line.\n             * @event dependencyMouseOut\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            me.client.trigger('dependencyMouseOut', {\n                dependency,\n                event\n            });\n\n            if (me.overCls) {\n                me.unhighlight(dependency);\n            }\n        }\n    }\n\n    //endregion\n\n    //region Export\n\n    // Export calls this fn to determine if a dependency should be included or not\n    isDependencyVisible(dependency) {\n        const\n            me           = this,\n            { rowStore } = me,\n            {\n                fromEvent,\n                toEvent\n            }            = dependency;\n\n        // Bail out early in case source or target doesn't exist\n        if (!fromEvent || !toEvent) {\n            return false;\n        }\n\n        const\n            fromResource = fromEvent.resource,\n            toResource   = toEvent.resource;\n\n        // Verify these are real existing Resources and not collapsed away (resource not existing in resource store)\n        if (!rowStore.isAvailable(fromResource) || !rowStore.isAvailable(toResource)) {\n            return false;\n        }\n\n        return fromEvent.isModel &&\n            !fromResource.instanceMeta(rowStore).hidden &&\n            !toResource.instanceMeta(rowStore).hidden;\n    }\n\n    //endregion\n\n    //region Highlight\n\n    updateHighlightDependenciesOnEventHover(enable) {\n        const me = this;\n\n        if (enable) {\n            const { client } = me;\n\n            client.ion({\n                name                                       : 'highlightOnHover',\n                [`${client.scheduledEventName}MouseEnter`] : params => me.highlightEventDependencies(params.eventRecord || params.taskRecord),\n                [`${client.scheduledEventName}MouseLeave`] : params => me.unhighlightEventDependencies(params.eventRecord || params.taskRecord),\n                thisObj                                    : me\n            });\n        }\n        else {\n            me.detachListeners('highlightOnHover');\n        }\n    }\n\n    highlight(dependency, cls = this.overCls) {\n        let classes = this.highlighted.get(dependency);\n\n        if (!classes) {\n            this.highlighted.set(dependency, classes = new Set());\n        }\n\n        classes.add(cls);\n\n        // No need to invalidate grid cache, since deps wont move around. Enough to regenerate DOM configs\n        this.lineCache = {};\n        this.refresh();\n    }\n\n    unhighlight(dependency, cls = this.overCls) {\n        const classes = this.highlighted.get(dependency);\n\n        if (classes) {\n            classes.delete(cls);\n\n            if (!classes.size) {\n                this.highlighted.delete(dependency);\n            }\n        }\n\n        // No need to invalidate grid cache, since deps wont move around. Enough to regenerate DOM configs\n        this.lineCache = {};\n        this.refresh();\n    }\n\n    highlightEventDependencies(timespan, cls) {\n        timespan.dependencies.forEach(dep => this.highlight(dep, cls));\n    }\n\n    unhighlightEventDependencies(timespan, cls) {\n        timespan.dependencies.forEach(dep => this.unhighlight(dep, cls));\n    }\n\n    //endregion\n\n    //region Drawing\n\n    // Implemented in DependencyGridCache to return dependencies that might intersect the current viewport and thus\n    // should be considered for drawing. Fallback value here is used when there is no grid cache (which happens when it\n    // is reset. Also useful in case we want to have it configurable or opt out automatically for small datasets)\n    getDependenciesToConsider(startMS, endMS, startIndex, endIndex) {\n        // Get records from grid cache\n        return super.getDependenciesToConsider?.(startMS, endMS, startIndex, endIndex) ??\n            // Falling back to using all valid deps (fix for not trying to draw conflicted deps)\n            this.project.dependencyStore.records.filter(d => d.isValid);\n    }\n\n    // String key used as syncId\n    getDependencyKey(dependency, fromAssignment, toAssignment) {\n        return `dep:${dependency.id};from:${fromAssignment.id};to:${toAssignment.id}`;\n    }\n\n    // TODO Was public\n    // Draw a single dependency, if it is in view (overridden in Gantt)\n    drawDependency(dependency, batch = false, forceBoxes = null) {\n        const\n            me           = this,\n            {\n                domConfigs,\n                client,\n                rowStore,\n                topIndex,\n                bottomIndex\n            }            = me,\n            {\n                eventStore,\n                useInitialAnimation\n            }            = client,\n            { idMap }    = rowStore,\n            {\n                startMS,\n                endMS\n            }            = me.visibleDateRange,\n            {\n                fromEvent,\n                toEvent\n            }            = dependency;\n\n        let fromAssigned = fromEvent.assigned,\n            toAssigned   = toEvent.assigned;\n\n        if (\n            // No point in trying to draw dep between unscheduled/non-existing events\n            fromEvent.isScheduled && toEvent.isScheduled &&\n            // Or between filtered out events\n            eventStore.includes(fromEvent) && eventStore.includes(toEvent) &&\n            // Or unassigned ones\n            fromAssigned?.size && toAssigned?.size\n        ) {\n            // Add links, if used\n            if (me.usingLinks) {\n                fromAssigned = [...fromAssigned].flatMap(collectLinkedAssignments);\n                toAssigned = [...toAssigned].flatMap(collectLinkedAssignments);\n            }\n\n            for (const from of fromAssigned) {\n                for (const to of toAssigned) {\n                    const\n                        // Using direct lookup in idMap instead of indexOf() for performance.\n                        // Resource might be filtered out or not exist at all\n                        fromIndex  = idMap[from.resource?.id]?.index,\n                        toIndex    = idMap[to.resource?.id]?.index,\n                        fromDateMS = Math.min(fromEvent.startDateMS, toEvent.startDateMS),\n                        toDateMS   = Math.max(fromEvent.endDateMS, toEvent.endDateMS);\n\n                    // Draw only if dependency intersects view, unless it is part of an export\n                    if (\n                        client.isExporting || fromIndex != null && toIndex != null &&\n                        (from.drawDependencies !== false && to.drawDependencies !== false) &&\n                        (rowStore.isAvailable(from.resource) && (rowStore.isAvailable(to.resource))) && !(\n                            // Both ends above view\n                            (fromIndex < topIndex && toIndex < topIndex) ||\n                            // Both ends below view\n                            (fromIndex > bottomIndex && toIndex > bottomIndex) ||\n                            // Both ends before view\n                            (fromDateMS < startMS && toDateMS < startMS) ||\n                            // Both ends after view\n                            (fromDateMS > endMS && toDateMS > endMS)\n                        )\n                    ) {\n                        const\n                            key            = me.getDependencyKey(dependency, from, to),\n                            lineDomConfigs = me.getDomConfigs(dependency, from, to, forceBoxes);\n\n                        if (lineDomConfigs) {\n                            // Allow deps to match animation delay of their events (the bottommost one) when fading in\n                            if (useInitialAnimation) {\n                                lineDomConfigs[0].style = {\n                                    animationDelay : `${Math.max(fromIndex, toIndex) / 20 * 1000}ms`\n                                };\n                            }\n\n                            domConfigs.set(key, lineDomConfigs);\n                        }\n                        // No room to draw a line\n                        else {\n                            domConfigs.delete(key);\n                        }\n                    }\n\n                    // Give mixins a shot at running code after a dependency is drawn. Used by grid cache to cache the\n                    // dependency (when needed)\n                    me.afterDrawDependency(dependency, fromIndex, toIndex, fromDateMS, toDateMS);\n                }\n            }\n        }\n\n        if (!batch) {\n            me.domSync();\n        }\n    }\n\n    // Hooks used by grid cache, to keep code in this file readable\n    afterDrawDependency(dependency, fromIndex, toIndex, fromDateMS, toDateMS) {\n        super.afterDrawDependency?.(dependency, fromIndex, toIndex, fromDateMS, toDateMS);\n    }\n\n    beforeDraw() {\n        super.beforeDraw?.();\n    }\n\n    afterDraw() {\n        super.afterDraw?.();\n    }\n\n    // Update DOM\n    domSync(targetElement = this.client.svgCanvas) {\n        DomSync.sync({\n            targetElement,\n            domConfig : {\n                onlyChildren : true,\n                children     : Array.from(this.domConfigs.values()).flat()\n            },\n            syncIdField      : 'syncId',\n            releaseThreshold : 0,\n            strict           : true,\n            callback() {\n                // TODO trigger events\n            }\n        });\n    }\n\n    fillDrawingCache() {\n        const\n            me         = this,\n            { client } = me;\n\n        // Cache subgrid bounds for the duration of this draw call to not have to figure it out per dep\n        me.relativeTo = Rectangle.from(client.foregroundCanvas);\n\n        // Cache other lookups too\n        me.visibleResources = client.visibleResources;\n        me.visibleDateRange = client.visibleDateRange;\n\n        me.topIndex     = me.rowStore.indexOf(me.visibleResources.first);\n        me.bottomIndex  = me.rowStore.indexOf(me.visibleResources.last);\n\n        // Cache link lookup, to avoid semi-expensive flatMap calls in drawDependency\n        if (me.usingLinks == null) {\n            me.usingLinks = client.resourceStore.some(r => r.hasLinks);\n        }\n    }\n\n    // Draw all dependencies intersecting the current viewport immediately\n    draw() {\n        const\n            me         = this,\n            { client } = me;\n\n        if (client.refreshSuspended || !client.foregroundCanvas || !client.isEngineReady || (me.disabled && !me._isDisabling) || client.isExporting) {\n            return;\n        }\n\n        me.fillDrawingCache();\n\n        me.domConfigs.clear();\n\n        // Nothing to draw if there are no rows or no ticks or we are disabled\n        if (client.firstVisibleRow && client.lastVisibleRow && client.timeAxis.count && !me.disabled &&\n            (me.visibleDateRange.endMS - me.visibleDateRange.startMS > 0)\n        ) {\n            const\n                { visibleDateRange } = client,\n                {\n                    topIndex,\n                    bottomIndex\n                }                   = me,\n                dependencies        = me.getDependenciesToConsider(visibleDateRange.startMS, visibleDateRange.endMS, topIndex, bottomIndex);\n\n            // Give mixins a shot at doing something before deps are drawn. Used by grid cache to determine if\n            // the cache should be rebuilt\n            me.beforeDraw();\n\n            for (const dependency of dependencies) {\n                me.drawDependency(dependency, true);\n            }\n\n            // Give mixins a shot at doing something after all deps are drawn\n            me.afterDraw();\n        }\n\n        me.domSync();\n\n        client.trigger('dependenciesDrawn');\n    }\n\n    //endregion\n\n    //region Refreshing\n\n    // Performs a draw on next frame, not intended to be called directly, call refresh() instead\n    doRefresh() {\n        const\n            me                     = this,\n            { client }             = me,\n            { scheduledEventName } = client;\n\n        me.draw();\n\n        // Refresh each frame during animations, during dragging & resizing\n        me.drawingLive = client.isAnimating || client.useInitialAnimation ||\n            client.features[`${scheduledEventName}Drag`]?.isActivelyDragging ||\n            client.features[`${scheduledEventName}Resize`]?.isResizing ||\n            client.features[`${scheduledEventName}SegmentDrag`]?.isActivelyDragging ||\n            client.features[`${scheduledEventName}SegmentResize`]?.isResizing;\n\n        me.drawingLive && me.refresh();\n    }\n\n    /**\n     * Redraws dependencies on the next animation frame\n     */\n    refresh() {\n        // Queue up a draw unless refresh is suspended\n        if (!this.client.refreshSuspended && !this.disabled && this.client.isPainted) {\n            this.doRefresh();\n        }\n    }\n\n    // Resets grid cache and performs a draw on next frame. Conditions when it should be called:\n    // * Zooming\n    // * Shifting time axis\n    // * Resizing window\n    // * CRUD\n    // ...\n    reset() {\n        super.reset?.();\n        this.refresh();\n    }\n\n    /**\n     * Draws all dependencies for the specified task.\n     * @deprecated 5.1 The Dependencies feature was refactored and this fn is no longer needed\n     */\n    drawForEvent() {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Dependencies.drawForEvent() is no longer needed');\n        this.refresh();\n    }\n\n    //endregion\n\n    //region Scheduler hooks\n\n    render() {\n        // Pull in the svg canvas early to have it available during drawing\n        this.client.getConfig('svgCanvas');\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(Dependencies, false, ['Scheduler', 'ResourceHistogram']);\nGridFeatureManager.registerFeature(Dependencies, true, 'SchedulerPro');\n","import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\n\n/**\n * @module Scheduler/feature/EventFilter\n */\n\n/**\n * Adds event filter menu items to the timeline header context menu.\n *\n * {@inlineexample Scheduler/feature/EventFilter.js}\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *   features : {\n *     eventFilter : true // `true` by default, set to `false` to disable the feature and remove the menu item from the timeline header\n *   }\n * });\n * ```\n *\n * This feature is **enabled** by default\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype eventFilter\n * @feature\n */\nexport default class EventFilter extends InstancePlugin {\n\n    static get $name() {\n        return 'EventFilter';\n    }\n\n    static get pluginConfig() {\n        return {\n            chain : ['populateTimeAxisHeaderMenu']\n        };\n    }\n\n    /**\n     * Populates the header context menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateTimeAxisHeaderMenu({ items }) {\n        const me = this;\n\n        items.eventsFilter = {\n            text        : 'L{filterEvents}',\n            icon        : 'b-fw-icon b-icon-filter',\n            disabled    : me.disabled,\n            localeClass : me,\n            weight      : 100,\n            menu        : {\n                type        : 'popup',\n                localeClass : me,\n                items       : {\n                    nameFilter : {\n                        weight               : 110,\n                        type                 : 'textfield',\n                        cls                  : 'b-eventfilter b-last-row',\n                        clearable            : true,\n                        keyStrokeChangeDelay : 300,\n                        label                : 'L{byName}',\n                        localeClass          : me,\n                        width                : 200,\n                        internalListeners    : {\n                            change  : me.onEventFilterChange,\n                            thisObj : me\n                        }\n                    }\n                },\n                onBeforeShow({ source : menu }) {\n                    const\n                        [filterByName] = menu.items,\n                        filter         = me.store.filters.getBy('property', 'name');\n\n                    filterByName.value = filter?.value || '';\n                }\n            }\n        };\n    }\n\n    onEventFilterChange({ value }) {\n        if (value !== '') {\n            this.store.filter('name', value);\n        }\n        else {\n            this.store.removeFilter('name');\n        }\n    }\n\n    get store() {\n        const { client } = this;\n\n        return client.isGanttBase ? client.store : client.eventStore;\n    }\n}\n\nEventFilter.featureClass = 'b-event-filter';\n\nGridFeatureManager.registerFeature(EventFilter, true, ['Scheduler', 'Gantt']);\nGridFeatureManager.registerFeature(EventFilter, false, 'ResourceHistogram');\n","import DateHelper from '../../../Core/helper/DateHelper.js';\nimport TimeSpan from '../../model/TimeSpan.js';\n\n/**\n * @module Scheduler/feature/mixin/NonWorkingTimeMixin\n */\n\n/**\n * Mixin with functionality shared between {@link Scheduler/feature/NonWorkingTime} and\n * {@link Scheduler/feature/EventNonWorkingTime}.\n * @mixin\n */\nexport default Target => class NonWorkingTimeMixin extends Target {\n    static $name = 'NonWorkingTimeMixin';\n\n    static configurable = {\n        /**\n         * The maximum time axis unit to display non-working ranges for ('hour' or 'day' etc).\n         * When zooming to a view with a larger unit, no non-working time elements will be rendered.\n         *\n         * **Note:** Be careful with setting this config to big units like 'year'. When doing this,\n         * make sure the timeline {@link Scheduler/view/TimelineBase#config-startDate start} and\n         * {@link Scheduler/view/TimelineBase#config-endDate end} dates are set tightly.\n         * When using a long range (for example many years) with non-working time elements rendered per hour,\n         * you will end up with millions of elements, impacting performance.\n         * When zooming, use the {@link Scheduler/view/mixin/TimelineZoomable#config-zoomKeepsOriginalTimespan} config.\n         * @config {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'}\n         * @default\n         */\n        maxTimeAxisUnit : 'week'\n    };\n\n    getNonWorkingTimeRanges(calendar, startDate, endDate) {\n        if (!calendar.getNonWorkingTimeRanges) {\n            const result = [];\n\n            // TODO Ask arcady if there is a built-in way for this\n\n            calendar.forEachAvailabilityInterval(\n                { startDate, endDate, isForward : true },\n                (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                    for (const [entry, cache] of calendarCacheInterval.intervalGroups) {\n                        if (!cache.getIsWorking()) {\n                            result.push({\n                                name      : entry.name,\n                                iconCls   : entry.iconCls,\n                                cls       : entry.cls,\n                                startDate : intervalStartDate,\n                                endDate   : intervalEndDate\n                            });\n                        }\n                    }\n                }\n            );\n\n            return result;\n        }\n\n        return calendar.getNonWorkingTimeRanges(startDate, endDate);\n    }\n\n    getCalendarTimeRanges(calendar, ignoreName = false) {\n        const\n            me                      = this,\n            { timeAxis, fillTicks } = me.client,\n            { unit, increment }     = timeAxis,\n            shouldPaint             = !me.maxTimeAxisUnit || DateHelper.compareUnits(unit, me.maxTimeAxisUnit) <= 0;\n\n        if (calendar && shouldPaint && timeAxis.count) {\n            const\n                allRanges     = me.getNonWorkingTimeRanges(calendar, timeAxis.startDate, timeAxis.endDate),\n                timeSpans     = allRanges.map(interval => new TimeSpan({\n                    name      : interval.name,\n                    cls       : `b-nonworkingtime ${interval.cls || ''}`,\n                    startDate : interval.startDate,\n                    endDate   : interval.endDate\n                })),\n                mergedSpans = [];\n\n            let prevRange = null;\n\n            // intervals returned by the calendar are not merged, let's combine them to yield fewer elements\n            for (const range of timeSpans) {\n                if (prevRange && range.startDate <= prevRange.endDate && (ignoreName || range.name === prevRange.name) && range.duration > 0) {\n                    prevRange.endDate = range.endDate;\n                }\n                else {\n                    mergedSpans.push(range);\n                    range.id  = `nonworking-${mergedSpans.length}`;\n                    prevRange = range;\n                }\n            }\n\n            // When filling ticks, non-working-time ranges are cropped to full ticks too\n            if (fillTicks) {\n                mergedSpans.forEach(span => {\n                    span.setStartEndDate(\n                        DateHelper.ceil(span.startDate, { magnitude : increment, unit }),\n                        DateHelper.floor(span.endDate, { magnitude : increment, unit })\n                    );\n                });\n            }\n\n            return mergedSpans;\n        }\n        else {\n            return [];\n        }\n    }\n\n    //region Basic scheduler calendar\n\n    setupDefaultCalendar() {\n        const { client, project } = this;\n\n        if (\n            // Might have been set up by NonWorkingTime / EventNonWorkingTime already\n            !this.autoGeneratedWeekends &&\n            // For basic scheduler...\n            !client.isSchedulerPro &&\n            !client.isGantt &&\n            // ...that uses the default calendar...\n            project.effectiveCalendar === project.defaultCalendar &&\n            // ...and has no defined intervals\n            !project.defaultCalendar.intervalStore.count\n        ) {\n            this.autoGeneratedWeekends = true;\n            this.updateDefaultCalendar();\n        }\n    }\n\n    updateDefaultCalendar() {\n        if (this.autoGeneratedWeekends) {\n            const\n                calendar     = this.client.project.effectiveCalendar,\n                intervals    = this.defaultNonWorkingIntervals,\n                hasIntervals = Boolean(intervals.length);\n\n            calendar.clearIntervals(hasIntervals);\n\n            // Update weekends as non-working time\n            if (hasIntervals) {\n                calendar.addIntervals(intervals);\n            }\n        }\n    }\n\n    updateLocalization() {\n        super.updateLocalization?.();\n\n        this.autoGeneratedWeekends && this.updateDefaultCalendar();\n    }\n\n    get defaultNonWorkingIntervals() {\n        const dayNames  = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n\n        return DateHelper.nonWorkingDaysAsArray.map(dayIndex => ({\n            recurrentStartDate : `on ${dayNames[dayIndex]} at 0:00`,\n            recurrentEndDate   : `on ${dayNames[(dayIndex + 1) % 7]} at 0:00`,\n            isWorking          : false\n        }));\n    }\n\n    //endregion\n};\n","import AbstractTimeRanges from './AbstractTimeRanges.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport AttachToProjectMixin from '../data/mixin/AttachToProjectMixin.js';\nimport NonWorkingTimeMixin from './mixin/NonWorkingTimeMixin.js';\n\n/**\n * @module Scheduler/feature/NonWorkingTime\n */\n\n/**\n * Feature that allows styling of weekends (and other non working time) by adding timeRanges for those days.\n *\n * {@inlineexample Scheduler/feature/NonWorkingTime.js}\n *\n * By default, the basic Scheduler calendar is empty. When enabling this feature it injects Saturday and Sunday weekend\n * intervals if no intervals are encountered.\n *\n * Please note that to not clutter the view (and have a large negative effect on performance) the feature does not\n * render ranges shorter than the base unit used by the time axis. The behavior can be disabled with\n * {@link #config-hideRangesOnZooming} config.\n *\n * The feature also bails out of rendering ranges for very zoomed out views completely for the same reasons (see\n * {@link #config-maxTimeAxisUnit} for details).\n *\n * Also note that the feature uses virtualized rendering, only the currently visible non-working-time ranges are\n * available in the DOM.\n *\n * This feature is **off** by default for Scheduler, but **enabled** by default for Scheduler Pro in which case it is\n * attached to the configured calendars and therefore does not show auto-generated weekends as non-working time.\n * For info on enabling it, see {@link Grid/view/mixin/GridFeatures}.\n *\n * @extends Scheduler/feature/AbstractTimeRanges\n * @demo Scheduler/nonworkingdays\n * @classtype nonWorkingTime\n * @mixes Scheduler/feature/mixin/NonWorkingTimeMixin\n * @feature\n */\nexport default class NonWorkingTime extends AbstractTimeRanges.mixin(AttachToProjectMixin, NonWorkingTimeMixin) {\n    //region Default config\n\n    static $name = 'NonWorkingTime';\n\n    /** @hideconfigs enableResizing, store*/\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Set to `true` to highlight non working periods of time\n             * @config {Boolean}\n             * @deprecated Since 5.2.0, will be removed since the feature is pointless if set to false\n             */\n            highlightWeekends : null,\n\n            /**\n             * The feature by default does not render ranges smaller than the base unit used by the time axis.\n             * Set this config to `false` to disable this behavior.\n             *\n             * <div class=\"note\">The {@link #config-maxTimeAxisUnit} config defines a zoom level at which to bail out of\n             * rendering ranges completely.</div>\n             * @config {Boolean}\n             * @default\n             */\n            hideRangesOnZooming : true,\n\n            showHeaderElements : true,\n            showLabelInBody    : true,\n\n            autoGeneratedWeekends : false\n        };\n    }\n\n    static pluginConfig = {\n        chain : [\n            'onPaint',\n            'attachToProject',\n            'updateLocalization',\n            'onConfigChange',\n            'onSchedulerHorizontalScroll'\n        ]\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    doDestroy() {\n        this.attachToCalendar(null);\n        super.doDestroy();\n    }\n\n    set highlightWeekends(highlight) {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Deprecated in favour of disabling the feature');\n\n        this.disabled = !highlight;\n    }\n\n    get highlightWeekends() {\n        return !this.disabled;\n    }\n\n    onConfigChange({ name }) {\n        if (!this.isConfiguring && name === 'fillTicks') {\n            this.refresh();\n        }\n    }\n\n    //endregion\n\n    //region Project\n\n    attachToProject(project) {\n        super.attachToProject(project);\n\n        this.attachToCalendar(project.effectiveCalendar);\n\n        // if there's no graph yet - need to delay this call until it appears, but not for scheduler\n        if (!project.graph && !this.client.isScheduler) {\n            project.ion({\n                name      : 'project',\n                dataReady : { fn : () => this.attachToCalendar(project.effectiveCalendar), once : true },\n                thisObj   : this\n            });\n        }\n\n        project.ion({\n            name           : 'project',\n            calendarChange : () => this.attachToCalendar(project.effectiveCalendar),\n            thisObj        : this\n        });\n    }\n\n    //endregion\n\n    //region TimeAxisViewModel\n\n    onTimeAxisViewModelUpdate(...args) {\n        this._timeAxisUnitDurationMs = null;\n        return super.onTimeAxisViewModelUpdate(...args);\n    }\n\n    //endregion\n\n    //region Calendar\n\n    attachToCalendar(calendar) {\n        const\n            me                  = this,\n            { project, client } = me;\n\n        me.detachListeners('calendar');\n\n        me.autoGeneratedWeekends = false;\n\n        if (calendar) {\n            // Sets up a default weekend calendar for basic Scheduler, when no calendar is set\n            me.setupDefaultCalendar();\n\n            calendar.intervalStore.ion({\n                name   : 'calendar',\n                change : () => me.setTimeout(() => me.refresh(), 1)\n            });\n        }\n\n        // On changing calendar we react to a data level event which is triggered after project refresh.\n        // Redraw right away\n        if (client.isEngineReady && !client.project.isDelayingCalculation && !client.isDestroying) {\n            me.refresh();\n        }\n        // Initially there is no guarantee we are ready to draw, wait for refresh\n        else if (!project.isDestroyed) {\n            me.detachListeners('initialProjectListener');\n            project.ion({\n                name : 'initialProjectListener',\n                refresh({ isCalculated }) {\n                    // Cant render early, have to wait for calculations\n                    if (isCalculated !== false) {\n                        me.refresh();\n                        me.detachListeners('initialProjectListener');\n                    }\n                },\n                thisObj : me\n            });\n        }\n    }\n\n    get calendar() {\n        return this.project?.effectiveCalendar;\n    }\n\n    //endregion\n\n    //region Draw\n\n    get timeAxisUnitDurationMs() {\n        // calculate and cache duration of the timeAxis unit in milliseconds\n        if (!this._timeAxisUnitDurationMs) {\n            this._timeAxisUnitDurationMs = DateHelper.as('ms', 1, this.client.timeAxis.unit);\n        }\n\n        return this._timeAxisUnitDurationMs;\n    }\n\n    /**\n     * Based on this method result the feature decides whether the provided non-working period should\n     * be rendered or not.\n     * The method checks that the range has non-zero {@link Scheduler.model.TimeSpan#field-duration},\n     * lays in the visible timespan and its duration is longer or equal the base timeaxis unit\n     * (if {@link #config-hideRangesOnZooming} is `true`).\n     *\n     * Override the method to implement your custom range rendering vetoing logic.\n     * @param {Scheduler.model.TimeSpan} range Range to render.\n     * @returns {Boolean} `true` if the range should be rendered and `false` otherwise.\n     */\n    shouldRenderRange(range) {\n        // if the range is longer or equal than one timeAxis unit then render it\n        return super.shouldRenderRange(range) && (!this.hideRangesOnZooming || range.durationMS >= this.timeAxisUnitDurationMs);\n    }\n\n    // Calendar intervals as TimeSpans, with adjacent intervals merged to create fewer\n    get timeRanges() {\n        const me = this;\n\n        if (!me._timeRanges) {\n            me._timeRanges = me.getCalendarTimeRanges(me.calendar);\n        }\n\n        return me._timeRanges;\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(NonWorkingTime, false, 'Scheduler');\nGridFeatureManager.registerFeature(NonWorkingTime, true, ['SchedulerPro', 'Gantt', 'ResourceHistogram']);\n","import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../tooltip/ClockTemplate.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\n\n/**\n * @module Scheduler/feature/ScheduleTooltip\n */\n\n/**\n * Feature that displays a tooltip containing the time at the mouse position when hovering empty parts of the schedule.\n * To hide the schedule tooltip, just disable this feature:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleTooltip : false\n *     }\n * });\n * ```\n *\n * You can also output a message along with the default time indicator (to indicate resource availability etc)\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *    features : {\n *       scheduleTooltip : {\n *           getText(date, event, resource) {\n *               return 'Hovering ' + resource.name;\n *           }\n *       }\n *   }\n * });\n * ```\n *\n * To take full control over the markup shown in the tooltip you can override the {@link #function-generateTipContent} method:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleTooltip : {\n *             generateTipContent({ date, event, resourceRecord }) {\n *                 return `\n *                     <dl>\n *                         <dt>Date</dt><dd>${date}</dd>\n *                         <dt>Resource</dt><dd>${resourceRecord.name}</dd>\n *                     </dl>\n *                 `;\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Configuration properties from the feature are passed down into the resulting {@link Core.widget.Tooltip} instance.\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleTooltip : {\n *             // Don't show the tip until the mouse has been over the schedule for three seconds\n *             hoverDelay : 3000\n *         }\n *     }\n * });\n * ```\n * @extends Core/mixin/InstancePlugin\n * @demo Scheduler/basic\n * @inlineexample Scheduler/feature/ScheduleTooltip.js\n * @classtype scheduleTooltip\n * @feature\n */\nexport default class ScheduleTooltip extends InstancePlugin {\n    //region Config\n\n    static get $name() {\n        return 'ScheduleTooltip';\n    }\n\n    static get configurable() {\n        return {\n            messageTemplate : data => `<div class=\"b-sch-hovertip-msg\">${data.message}</div>`,\n\n            /**\n             * Set to `true` to hide this tooltip when hovering non-working time. Defaults to `false` for Scheduler,\n             * `true` for SchedulerPro\n             * @config {Boolean}\n             */\n            hideForNonWorkingTime : null\n        };\n    }\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onPaint']\n        };\n    }\n\n    //endregion\n\n    //region Init\n\n    /**\n     * Set up drag and drop and hover tooltip.\n     * @private\n     */\n    onPaint({ firstPaint }) {\n        if (!firstPaint) {\n            return;\n        }\n\n        const\n            me         = this,\n            { client } = me;\n\n        if (client.isSchedulerPro && me.hideForNonWorkingTime === undefined) {\n            me.hideForNonWorkingTime = true;\n        }\n\n        let reshowListener;\n\n        const tip = me.hoverTip = new Tooltip({\n            id                       : `${client.id}-schedule-tip`,\n            cls                      : 'b-sch-scheduletip',\n            allowOver                : true,\n            hoverDelay               : 0,\n            hideDelay                : 100,\n            showOnHover              : true,\n            forElement               : client.timeAxisSubGridElement,\n            anchorToTarget           : false,\n            trackMouse               : true,\n            updateContentOnMouseMove : true,\n            // disable text content and monitor resize for tooltip, otherwise it doesn't\n            // get sized properly on first appearance\n            monitorResize            : false,\n            textContent              : false,\n            forSelector              : '.b-schedulerbase:not(.b-dragging-event):not(.b-dragcreating) .b-grid-body-container:not(.b-scrolling) .b-timeline-subgrid:not(.b-scrolling) > :not(.b-sch-foreground-canvas):not(.b-group-footer):not(.b-group-row) *',\n            // Do not constrain at all, want it to be able to go outside of the viewport to not get in the way\n            constrainTo              : null,\n            getHtml                  : me.getHoverTipHtml.bind(me),\n            onDocumentMouseDown(event) {\n                // Click on the scheduler hides until the very next\n                // non-button-pressed mouse move!\n                if (tip.forElement.contains(event.event.target)) {\n                    reshowListener = EventHelper.on({\n                        thisObj   : me,\n                        element   : client.timeAxisSubGridElement,\n                        mousemove : e => tip.internalOnPointerOver(e),\n                        capture   : true\n                    });\n                }\n\n                const hideAnimation = tip.hideAnimation;\n                tip.hideAnimation = false;\n                tip.constructor.prototype.onDocumentMouseDown.call(tip, event);\n                tip.hideAnimation = hideAnimation;\n            },\n            // on Core/mixin/Events constructor, me.config.listeners is deleted and attributed its value to me.configuredListeners\n            // to then on processConfiguredListeners it set me.listeners to our TooltipBase\n            // but since we need our initial config.listeners to set to our internal tooltip, we leave processConfiguredListeners empty\n            // to avoid lost our listeners to apply for our internal tooltip here and force our feature has all Tooltip events firing\n            ...me.config,\n            internalListeners : me.configuredListeners\n        });\n\n        // We have to add our own listener after instantiation because it may conflict with a configured listener\n        tip.ion({\n            pointerover({ event }) {\n                const buttonsPressed = 'buttons' in event ? event.buttons > 0\n                    : event.which > 0; // fallback for Safari which doesn't support 'buttons'\n\n                // This is the non-button-pressed mousemove\n                // after the document mousedown\n                if (!buttonsPressed && reshowListener) {\n                    reshowListener();\n                }\n\n                // Never any tooltip while interaction is ongoing and a mouse button is pressed\n                return !me.disabled && !buttonsPressed;\n            },\n            innerhtmlupdate({ source }) {\n                me.clockTemplate.updateDateIndicator(source.element, me.lastTime);\n            }\n        });\n\n        // Update tooltip after zooming\n        client.ion({\n            timeAxisViewModelUpdate : 'updateTip',\n            thisObj                 : me\n        });\n\n        me.clockTemplate = new ClockTemplate({\n            scheduler : client\n        });\n    }\n\n    // leave configuredListeners alone until render time at which they are used on the tooltip\n    processConfiguredListeners() {}\n\n    updateTip() {\n        if (this.hoverTip.isVisible) {\n            this.hoverTip.updateContent();\n        }\n    }\n\n    doDestroy() {\n        this.destroyProperties('clockTemplate', 'hoverTip');\n        super.doDestroy();\n    }\n\n    //endregion\n\n    //region Contents\n\n    /**\n     * @deprecated Use {@link #function-generateTipContent} instead.\n     * Gets html to display in hover tooltip (tooltip displayed on empty parts of scheduler)\n     * @private\n     */\n    getHoverTipHtml({ tip, event }) {\n        const\n            me        = this,\n            scheduler = me.client,\n            date      = event && scheduler.getDateFromDomEvent(event, 'floor', true);\n\n        let html      = me.lastHtml;\n\n        // event.target might be null in the case of being hosted in a web component https://github.com/bryntum/bryntum-suite/pull/4488\n        if (date && event.target) {\n            const resourceRecord = scheduler.resolveResourceRecord(event);\n\n            // resourceRecord might be null if user hover over the tooltip, but we shouldn't hide the tooltip in this case\n            if ((resourceRecord && (date - me.lastTime !== 0 || resourceRecord.id !== me.lastResourceId))) {\n                if (me.hideForNonWorkingTime) {\n                    const isWorkingTime = resourceRecord.isWorkingTime(date);\n\n                    tip.element.classList.toggle('b-nonworking-time', !isWorkingTime);\n                }\n\n                me.lastResourceId = resourceRecord.id;\n                html              = me.lastHtml = me.generateTipContent({ date, event, resourceRecord });\n            }\n        }\n        else {\n            tip.hide();\n            me.lastTime = null;\n            me.lastResourceId = null;\n        }\n\n        return html;\n    }\n\n    /**\n     * Called as mouse pointer is moved over a new resource or time block. You can override this to show\n     * custom HTML in the tooltip.\n     * @param {Object} context\n     * @param {Date} context.date The date of the hovered point\n     * @param {Event} context.event The DOM event that triggered this tooltip to show\n     * @param {Scheduler.model.ResourceModel} context.resourceRecord The resource record\n     * @returns {String} The HTML contents to show in the tooltip (an empty return value will hide the tooltip)\n     */\n    generateTipContent({ date, event, resourceRecord }) {\n        const\n            me          = this,\n            clockHtml   = me.clockTemplate.generateContent({\n                date : date,\n                text : me.client.getFormattedDate(date)\n            }),\n            messageHtml = me.messageTemplate({\n                message : me.getText(date, event, resourceRecord) || ''\n            });\n\n        me.lastTime = date;\n\n        return clockHtml + messageHtml;\n    }\n\n    /**\n     * Override this to render custom text to default hover tip\n     * @param {Date} date\n     * @param {Event} event Browser event\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @returns {String}\n     */\n    getText(date, event, resourceRecord) {}\n\n    //endregion\n}\n\n// TODO: Refactor SASS so that auto-generated class name of 'b-' + cls.name.toLowerCase() can be used.\nScheduleTooltip.featureClass = 'b-scheduletip';\n\nGridFeatureManager.registerFeature(ScheduleTooltip, true, 'Scheduler');\nGridFeatureManager.registerFeature(ScheduleTooltip, false, 'ResourceUtilization');\n","import HeaderMenu from '../../Grid/feature/HeaderMenu.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport '../../Core/widget/Slider.js';\n\n/**\n * @module Scheduler/feature/TimeAxisHeaderMenu\n */\nconst setTimeSpanOptions = {\n    maintainVisibleStart : true\n};\n\n/**\n * Adds scheduler specific menu items to the timeline header context menu.\n *\n * ## Default timeaxis header menu items\n *\n * Here is the list of menu items provided by this and other features:\n *\n * | Reference          | Text                  | Weight | Feature                                           | Description                  |\n * |--------------------|-----------------------|--------|---------------------------------------------------|------------------------------|\n * | `eventsFilter`     | Filter tasks          | 100    | {@link Scheduler.feature.EventFilter EventFilter} | Submenu for event filtering  |\n * | \\>`nameFilter`     | By name               | 110    | {@link Scheduler.feature.EventFilter EventFilter} | Filter by `name`             |\n * | `zoomLevel`        | Zoom                  | 200    | *This feature*                                    | Submenu for timeline zooming |\n * | \\>`zoomSlider`     | -                     | 210    | *This feature*                                    | Changes current zoom level   |\n * | `dateRange`        | Date range            | 300    | *This feature*                                    | Submenu for timeline range   |\n * | \\>`startDateField` | Start date            | 310    | *This feature*                                    | Start date for the timeline  |\n * | \\>`endDateField`   | End date              | 320    | *This feature*                                    | End date for the timeline    |\n * | \\>`leftShiftBtn`   | <                     | 330    | *This feature*                                    | Shift backward               |\n * | \\>`todayBtn`       | Today                 | 340    | *This feature*                                    | Go to today                  |\n * | \\>`rightShiftBtn`  | \\>                    | 350    | *This feature*                                    | Shift forward                |\n * | `currentTimeLine`  | Show current timeline | 400    | {@link Scheduler.feature.TimeRanges TimeRanges}   | Show current time line       |\n *\n * \\> - first level of submenu\n *\n * ## Customizing the menu items\n *\n * The menu items in the TimeAxis Header menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * ### Add extra items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             items : {\n *                 extraItem : {\n *                     text : 'Extra',\n *                     icon : 'b-fa b-fa-fw b-fa-flag',\n *                     onItem() {\n *                         ...\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ### Remove existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             items : {\n *                 zoomLevel : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ### Customize existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             items : {\n *                 zoomLevel : {\n *                     text : 'Scale'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n * ### Customizing submenu items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *      features : {\n *          timeAxisHeaderMenu : {\n *              items : {\n *                  dateRange : {\n *                      menu : {\n *                          items : {\n *                              todayBtn : {\n *                                  text : 'Now'\n *                              }\n *                          }\n *                      }\n *                  }\n *              }\n *          }\n *      }\n * });\n * ```\n *\n * ### Manipulate existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             // Process items before menu is shown\n *             processItems({ items }) {\n *                  // Add an extra item dynamically\n *                 items.coolItem = {\n *                     text : 'Cool action',\n *                     onItem() {\n *                           // ...\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Full information of the menu customization can be found in the [\"Customizing the Event menu, the Schedule menu, and the TimeAxisHeader menu\"](#Scheduler/guides/customization/contextmenu.md)\n * guide.\n *\n * This feature is **enabled** by default\n *\n * @extends Grid/feature/HeaderMenu\n * @demo Scheduler/basic\n * @classtype timeAxisHeaderMenu\n * @feature\n * @inlineexample Scheduler/feature/TimeAxisHeaderMenu.js\n */\nexport default class TimeAxisHeaderMenu extends HeaderMenu {\n\n    //region Config\n\n    static get $name() {\n        return 'TimeAxisHeaderMenu';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             *   features         : {\n             *       timeAxisHeaderMenu : {\n             *           processItems({ items }) {\n             *               // Add or hide existing items here as needed\n             *               items.myAction = {\n             *                   text   : 'Cool action',\n             *                   icon   : 'b-fa b-fa-fw b-fa-ban',\n             *                   onItem : () => console.log('Some coolness'),\n             *                   weight : 300 // Move to end\n             *               };\n             *\n             *               // Hide zoom slider\n             *               items.zoomLevel.hidden = true;\n             *           }\n             *       }\n             *   },\n             * ```\n             *\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Object<String,MenuItemConfig>} context.items An object containing the {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @config {Function}\n             * @preventable\n             */\n            processItems : null,\n\n            /**\n             * This is a preconfigured set of items used to create the default context menu.\n             *\n             * The `items` provided by this feature are listed in the intro section of this class. You can\n             * configure existing items by passing a configuration object to the keyed items.\n             *\n             * To remove existing items, set corresponding keys `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         timeAxisHeaderMenu : {\n             *             items : {\n             *                 eventsFilter : null\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * See the feature config in the above example for details.\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} items\n             */\n            items : null,\n\n            type : 'timeAxisHeader'\n        };\n    }\n\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n\n        config.chain.push('populateTimeAxisHeaderMenu');\n\n        return config;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * This event fires on the owning Scheduler before the context menu is shown for the time axis header.\n     * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.\n     *\n     * Returning `false` from a listener prevents the menu from being shown.\n     *\n     * @event timeAxisHeaderContextMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source The scheduler\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Time axis column\n     */\n\n    /**\n     * This event fires on the owning Scheduler after the context menu is shown for a header\n     * @event timeAxisHeaderContextMenuShow\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source The scheduler\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Time axis column\n     */\n\n    /**\n     * This event fires on the owning Scheduler when an item is selected in the header context menu.\n     * @event timeAxisHeaderContextMenuItem\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source The scheduler\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {Grid.column.Column} column Time axis column\n     */\n\n    //endregion\n\n    construct() {\n        super.construct(...arguments);\n\n        if (this.triggerEvent.includes('click') && this.client.zoomOnTimeAxisDoubleClick) {\n            this.client.zoomOnTimeAxisDoubleClick = false;\n        }\n    }\n\n    shouldShowMenu(eventParams) {\n        const { column } = eventParams;\n\n        return column && column.enableHeaderContextMenu !== false && column === this.client.timeAxisColumn;\n    }\n\n    showContextMenu(eventParams) {\n        super.showContextMenu(...arguments);\n\n        if (this.menu) {\n            // the TimeAxis's context menu probably will cause scrolls because it manipulates the dates.\n            // The menu should not hide on scroll when for a TimeAxisColumn\n            this.menu.scrollAction = 'realign';\n        }\n    }\n\n    populateTimeAxisHeaderMenu({ items }) {\n        const\n            me         = this,\n            { client } = me,\n            dateStep   = {\n                magnitude : client.timeAxis.shiftIncrement,\n                unit      : client.timeAxis.shiftUnit\n            };\n\n        Object.assign(items, {\n            zoomLevel : {\n                text        : 'L{pickZoomLevel}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-search-plus',\n                disabled    : !client.presets.count || me.disabled,\n                weight      : 200,\n                menu        : {\n                    type  : 'popup',\n                    items : {\n                        zoomSlider : {\n                            weight    : 210,\n                            type      : 'slider',\n                            minWidth  : 130,\n                            showValue : false\n                        }\n                    },\n                    onBeforeShow({ source : menu }) {\n                        const [zoom] = menu.items;\n\n                        zoom.min = client.minZoomLevel;\n                        zoom.max = client.maxZoomLevel;\n                        zoom.value = client.zoomLevel;\n\n                        // Default slider value is 50 which causes the above to trigger onZoomSliderChange (when\n                        // maxZoomLevel < 50) if we add our listener prior to this point.\n                        me.zoomDetatcher = zoom.ion({ input : 'onZoomSliderChange', thisObj : me });\n                    },\n                    onHide() {\n                        if (me.zoomDetatcher) {\n                            me.zoomDetatcher();\n                            me.zoomDetatcher = null;\n                        }\n                    }\n                }\n            },\n            dateRange : {\n                text        : 'L{activeDateRange}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-calendar',\n                weight      : 300,\n                menu        : {\n                    type     : 'popup',\n                    cls      : 'b-sch-timeaxis-menu-daterange-popup',\n                    defaults : {\n                        localeClass : me\n                    },\n                    items : {\n                        startDateField : {\n                            type              : 'datefield',\n                            label             : 'L{startText}',\n                            weight            : 310,\n                            labelWidth        : '6em',\n                            required          : true,\n                            step              : dateStep,\n                            internalListeners : {\n                                change  : me.onRangeDateFieldChange,\n                                thisObj : me\n                            }\n                        },\n                        endDateField : {\n                            type              : 'datefield',\n                            label             : 'L{endText}',\n                            weight            : 320,\n                            labelWidth        : '6em',\n                            required          : true,\n                            step              : dateStep,\n                            internalListeners : {\n                                change  : me.onRangeDateFieldChange,\n                                thisObj : me\n                            }\n                        },\n                        leftShiftBtn : {\n                            type              : 'button',\n                            weight            : 330,\n                            cls               : 'b-left-nav-btn',\n                            icon              : 'b-icon b-icon-previous',\n                            color             : 'b-blue b-raised',\n                            flex              : 1,\n                            margin            : 0,\n                            internalListeners : {\n                                click   : me.onLeftShiftBtnClick,\n                                thisObj : me\n                            }\n                        },\n                        todayBtn : {\n                            type              : 'button',\n                            weight            : 340,\n                            cls               : 'b-today-nav-btn',\n                            color             : 'b-blue b-raised',\n                            text              : 'L{todayText}',\n                            flex              : 4,\n                            margin            : '0 8',\n                            internalListeners : {\n                                click   : me.onTodayBtnClick,\n                                thisObj : me\n                            }\n                        },\n                        rightShiftBtn : {\n                            type              : 'button',\n                            weight            : 350,\n                            cls               : 'b-right-nav-btn',\n                            icon              : 'b-icon b-icon-next',\n                            color             : 'b-blue b-raised',\n                            flex              : 1,\n                            internalListeners : {\n                                click   : me.onRightShiftBtnClick,\n                                thisObj : me\n                            }\n                        }\n                    },\n                    internalListeners : {\n                        paint   : me.initDateRangeFields,\n                        thisObj : me\n                    }\n                }\n            }\n        });\n    }\n\n    onZoomSliderChange({ value }) {\n        const me = this;\n\n        // Zooming maintains timeline center point by scrolling the newly rerendered timeline to the\n        // correct point to maintain the visual center. Temporarily inhibit context menu hide on scroll\n        // of its context element.\n        me.menu.scrollAction = 'realign';\n\n        me.client.zoomLevel = value;\n\n        me.menu.setTimeout({\n            fn                : () => me.menu.scrollAction = 'hide',\n            delay             : 100,\n            cancelOutstanding : true\n        });\n    }\n\n    initDateRangeFields({ source : dateRange, firstPaint }) {\n        if (firstPaint) {\n            const { widgetMap } = dateRange;\n\n            this.startDateField = widgetMap.startDateField;\n            this.endDateField = widgetMap.endDateField;\n        }\n\n        this.initDates();\n    }\n\n    initDates() {\n        const me = this;\n\n        me.startDateField.suspendEvents();\n        me.endDateField.suspendEvents();\n\n        // The actual scheduler start dates may include time, but our Date field cannot currently handle\n        // a time portion and throws it away, so when we need the value from an unchanged field, we need\n        // to use the initialValue set from the timeAxis values.\n        // Until our DateField can optionally include a time value, this is the solution.\n        me.startDateField.value = me.startDateFieldInitialValue = me.client.startDate;\n        me.endDateField.value = me.endDateFieldInitialValue = me.client.endDate;\n\n        me.startDateField.resumeEvents();\n        me.endDateField.resumeEvents();\n    }\n\n    onRangeDateFieldChange({ source }) {\n        const\n            me               = this,\n            startDateChanged = (source === me.startDateField),\n            { client }       = me,\n            { timeAxis }     = client,\n            startDate        = me.startDateFieldInitialValue && !startDateChanged ? me.startDateFieldInitialValue : me.startDateField.value;\n\n        let endDate = me.endDateFieldInitialValue && startDateChanged ? me.endDateFieldInitialValue : me.endDateField.value;\n\n        // When either of the fields is changed, we no longer use its initialValue from the timeAxis start or end\n        // so that gets nulled to indicate that it's unavailable and the real field value is to be used.\n        if (startDateChanged) {\n            me.startDateFieldInitialValue = null;\n        }\n        else {\n            me.endDateFieldInitialValue = null;\n        }\n\n        // Because the start and end dates are exclusive, avoid a zero\n        // length time axis by incrementing the end by one tick unit\n        // if they are the same.\n        if (!(endDate - startDate)) {\n            endDate = DateHelper.add(endDate, timeAxis.shiftIncrement, timeAxis.shiftUnit);\n        }\n        // if start date got bigger than end date set end date to start date plus one tick\n        else if (endDate < startDate) {\n            endDate = DateHelper.add(startDate, timeAxis.shiftIncrement, timeAxis.shiftUnit);\n        }\n\n        // setTimeSpan will try to keep the scroll position the same.\n        client.setTimeSpan(startDate, endDate, setTimeSpanOptions);\n\n        me.initDates();\n    }\n\n    onLeftShiftBtnClick() {\n        this.client.timeAxis.shiftPrevious();\n        this.initDates();\n    }\n\n    onTodayBtnClick() {\n        const today = DateHelper.clearTime(new Date());\n\n        this.client.setTimeSpan(today, DateHelper.add(today, 1, 'day'));\n        this.initDates();\n    }\n\n    onRightShiftBtnClick() {\n        this.client.timeAxis.shiftNext();\n        this.initDates();\n    }\n}\n\nGridFeatureManager.registerFeature(TimeAxisHeaderMenu, true, ['Scheduler', 'Gantt']);\nGridFeatureManager.registerFeature(TimeAxisHeaderMenu, false, 'ResourceHistogram');\n","import DH from '../../../Core/helper/DateHelper.js';\nimport Events from '../../../Core/mixin/Events.js';\nimport PresetManager from '../../preset/PresetManager.js';\nimport ViewPreset from '../../preset/ViewPreset.js';\nimport '../../data/TimeAxis.js';\n\n/**\n * @module Scheduler/view/model/TimeAxisViewModel\n */\n\n/**\n * This class is an internal view model class, describing the visual representation of a {@link Scheduler.data.TimeAxis}.\n * The config for the header rows is described in the {@link Scheduler.preset.ViewPreset#field-headers headers}.\n * To calculate the size of each cell in the time axis, this class requires:\n *\n * - availableSpace  - The total width or height available for the rendering\n * - tickSize       - The fixed width or height of each cell in the lowest header row. This value is normally read from the\n * {@link Scheduler.preset.ViewPreset viewPreset} but this can also be updated programmatically using the {@link #property-tickSize} setter\n *\n * Normally you should not interact with this class directly.\n *\n * @extends Core/mixin/Events\n */\nexport default class TimeAxisViewModel extends Events() {\n    //region Default config\n\n    // TODO: replace _availableSpace etc with availableSpace in config and make setters work during config phase\n\n    static get defaultConfig() {\n        return {\n            /**\n             * The time axis providing the underlying data to be visualized\n             * @config {Scheduler.data.TimeAxis}\n             * @internal\n             */\n            timeAxis : null,\n\n            /**\n             * The available width/height, this is normally not known by the consuming UI component using this model\n             * class until it has been fully rendered. The consumer of this model should set\n             * {@link #property-availableSpace} when its width has changed.\n             * @config {Number}\n             * @internal\n             */\n            availableSpace : null,\n\n            /**\n             * The \"tick width\" for horizontal mode or \"tick height\" for vertical mode, to use for the cells in the\n             * bottom most header row.\n             * This value is normally read from the {@link Scheduler.preset.ViewPreset viewPreset}\n             * @config {Number}\n             * @default\n             * @internal\n             */\n            tickSize : 100,\n\n            /**\n             * true if there is a requirement to be able to snap events to a certain view resolution.\n             * This has implications of the {@link #config-tickSize} that can be used, since all widths must be in even pixels.\n             * @config {Boolean}\n             * @default\n             * @internal\n             */\n            snap : false,\n\n            /**\n             * true if cells in the bottom-most row should be fitted to the {@link #property-availableSpace available space}.\n             * @config {Boolean}\n             * @default\n             * @internal\n             */\n            forceFit : false,\n\n            headers : null,\n\n            mode : 'horizontal', // or 'vertical'\n\n            //used for Exporting. Make sure the tick columns are not recalculated when resizing.\n            suppressFit : false,\n\n            // cache of the config currently used.\n            columnConfig : [],\n\n            // the view preset name to apply initially\n            viewPreset : null,\n\n            // The default header level to draw column lines for\n            columnLinesFor : null,\n\n            originalTickSize : null,\n\n            headersDatesCache : []\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(config) {\n        const me = this;\n\n        // getSingleUnitInPixels results are memoized because of frequent calls during rendering.\n        me.unitToPixelsCache = {};\n\n        super.construct(config);\n\n        const viewPreset = me.timeAxis.viewPreset || me.viewPreset;\n\n        if (viewPreset) {\n            if (viewPreset instanceof ViewPreset) {\n                me.consumeViewPreset(viewPreset);\n            }\n            else {\n                const preset = PresetManager.getPreset(viewPreset);\n                preset && me.consumeViewPreset(preset);\n            }\n        }\n\n        // When time axis is changed, reconfigure the model\n        me.timeAxis.ion({ reconfigure : 'onTimeAxisReconfigure', thisObj : me });\n\n        me.configured = true;\n    }\n\n    doDestroy() {\n        this.timeAxis.un('reconfigure', this.onTimeAxisReconfigure, this);\n        super.doDestroy();\n    }\n\n    /**\n     * Used to calculate the range to extend the TimeAxis to during infinite scroll.\n     * @param {Date} date\n     * @param {Boolean} centered\n     * @param {Scheduler.preset.ViewPreset} [preset] Optional, the preset for which to calculate the range.\n     * defaults to the currently active ViewPreset\n     * @returns {Object} `{ startDate, endDate }`\n     * @internal\n     */\n    calculateInfiniteScrollingDateRange(date, centered, preset = this.viewPreset) {\n        const\n            {\n                timeAxis,\n                availableSpace\n            } = this,\n            {\n                bufferCoef\n            } = this.owner,\n            {\n                leafUnit,\n                leafIncrement,\n                tickSize\n            } = preset;\n\n        // if provided date is the central point on the timespan\n        if (centered) {\n            const halfSpan = Math.ceil((availableSpace * bufferCoef + (availableSpace / 2)) / tickSize);\n\n            return {\n                startDate : timeAxis.floorDate(DH.add(date, -halfSpan * leafIncrement, leafUnit), false, leafUnit, leafIncrement),\n                endDate   : timeAxis.ceilDate(DH.add(date, halfSpan * leafIncrement, leafUnit), false, leafUnit, leafIncrement)\n            };\n        }\n        // if provided date is the left coordinate of the visible timespan area\n        else {\n            const bufferedTicks = Math.ceil(availableSpace * bufferCoef / tickSize);\n\n            return {\n                startDate : timeAxis.floorDate(DH.add(date, -bufferedTicks * leafIncrement, leafUnit), false, leafUnit, leafIncrement),\n                endDate   : timeAxis.ceilDate(DH.add(date, Math.ceil((availableSpace / tickSize + bufferedTicks) * leafIncrement), leafUnit), false, leafUnit, leafIncrement)\n            };\n        }\n    }\n\n    /**\n     * Returns an array representing the headers of the current timeAxis. Each element is an array representing the cells for that level in the header.\n     * @returns {Object[]} An array of headers, each element being an array representing each cell (with start date and end date) in the timeline representation.\n     * @internal\n     */\n    get columnConfig() {\n        return this._columnConfig;\n    }\n\n    set columnConfig(config) {\n        this._columnConfig = config;\n    }\n\n    get headers() {\n        return this._headers;\n    }\n\n    set headers(headers) {\n        if (headers && headers.length && headers[headers.length - 1].cellGenerator) {\n            throw new Error('`cellGenerator` cannot be used for the bottom level of your headers. Use TimeAxis#generateTicks() instead.');\n        }\n\n        this._headers = headers;\n    }\n\n    get isTimeAxisViewModel() {\n        return true;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Fires after the model has been updated.\n     * @event update\n     * @param {Scheduler.view.model.TimeAxisViewModel} source The model instance\n     */\n\n    /**\n     * Fires after the model has been reconfigured.\n     * @event reconfigure\n     * @param {Scheduler.view.model.TimeAxisViewModel} source The model instance\n     */\n\n    //endregion\n\n    //region Mode\n\n    /**\n     * Using horizontal mode?\n     * @returns {Boolean}\n     * @readonly\n     * @internal\n     */\n    get isHorizontal() {\n        return this.mode !== 'vertical';\n    }\n\n    /**\n     * Using vertical mode?\n     * @returns {Boolean}\n     * @readonly\n     * @internal\n     */\n    get isVertical() {\n        return this.mode === 'vertical';\n    }\n\n    /**\n     * Gets/sets the forceFit value for the model. Setting it will cause it to update its contents and fire the\n     * {@link #event-update} event.\n     * @property {Boolean}\n     * @internal\n     */\n    set forceFit(value) {\n        if (value !== this._forceFit) {\n            this._forceFit = value;\n            this.update();\n        }\n    }\n\n    //endregion\n\n    //region Reconfigure & update\n\n    reconfigure(config) {\n        // clear the cached headers\n        this.headers = null;\n\n        // Ensure correct ordering\n        this.setConfig(config);\n\n        this.trigger('reconfigure');\n    }\n\n    onTimeAxisReconfigure({ source : timeAxis, suppressRefresh }) {\n        if (this.viewPreset !== timeAxis.viewPreset) {\n            this.consumeViewPreset(timeAxis.viewPreset);\n        }\n        if (!suppressRefresh) {\n            this.update();\n        }\n    }\n\n    /**\n     * Updates the view model current timeAxis configuration and available space.\n     * @param {Number} [availableSpace] The available space for the rendering of the axis (used in forceFit mode)\n     * @param {Boolean} [silent] Pass `true` to suppress the firing of the `update` event.\n     * @param {Boolean} [forceUpdate] Pass `true` to fire the `update` event even if the size has not changed.\n     * @internal\n     */\n    update(availableSpace, silent = false, forceUpdate = false) {\n        const\n            me                    = this,\n            { timeAxis, headers } = me;\n\n        // We're in configuration, or no change, quit\n        if (me.isConfiguring || me._availableSpace === availableSpace) {\n            if (forceUpdate) {\n                me.trigger('update');\n            }\n            return;\n        }\n\n        me._availableSpace = Math.max(availableSpace || me.availableSpace || 0, 0);\n\n        if (typeof me.availableSpace !== 'number') {\n            throw new Error('Invalid available space provided to TimeAxisModel');\n        }\n\n        me.columnConfig = [];\n\n        // The \"column width\" is considered to be the width of each tick in the lowest header row and this width\n        // has to be same for all cells in the lowest row.\n        const tickSize = me._tickSize = me.calculateTickSize(me.originalTickSize);\n\n        if (typeof tickSize !== 'number' || tickSize <= 0) {\n            throw new Error('Invalid timeAxis tick size');\n        }\n\n        // getSingleUnitInPixels results are memoized because of frequent calls during rendering.\n        me.unitToPixelsCache = {};\n\n        // totalSize is cached because of frequent calls which calculate it.\n        me._totalSize = null;\n\n        // Generate the underlying date ranges for each header row, which will provide input to the cell rendering\n        for (let pos = 0, { length } = headers; pos < length; pos++) {\n            const header = headers[pos];\n\n            if (header.cellGenerator) {\n                const headerCells = header.cellGenerator.call(me, timeAxis.startDate, timeAxis.endDate);\n\n                me.columnConfig[pos] = me.createHeaderRow(pos, header, headerCells);\n            }\n            else {\n                me.columnConfig[pos] = me.createHeaderRow(pos, header);\n            }\n        }\n\n        if (!silent) {\n            me.trigger('update');\n        }\n    }\n\n    //endregion\n\n    //region Date / position mapping\n\n    /**\n     * Returns the distance in pixels for a timespan with the given start and end date.\n     * @param {Date} start start date\n     * @param {Date} end end date\n     * @returns {Number} The length of the time span\n     * @category Date mapping\n     */\n    getDistanceBetweenDates(start, end) {\n        return this.getPositionFromDate(end) - this.getPositionFromDate(start);\n    }\n\n    /**\n     * Returns the distance in pixels for a time span\n     * @param {Number} durationMS Time span duration in ms\n     * @returns {Number} The length of the time span\n     * @category Date mapping\n     */\n    getDistanceForDuration(durationMs) {\n        return this.getSingleUnitInPixels('millisecond') * durationMs;\n    }\n\n    /**\n     * Gets the position of a date on the projected time axis or -1 if the date is not in the timeAxis.\n     * @param {Date} date the date to query for.\n     * @returns {Number} the coordinate representing the date\n     * @category Date mapping\n     */\n    getPositionFromDate(date, options = {}) {\n        const tick = this.getScaledTick(date, options);\n\n        if (tick === -1) {\n            return -1;\n        }\n\n        return this.tickSize * (tick - this.timeAxis.visibleTickStart);\n    }\n\n    // Translates a tick along the time axis to facilitate scaling events when excluding certain days or hours\n    getScaledTick(date, { respectExclusion, snapToNextIncluded, isEnd, min, max }) {\n        const\n            { timeAxis }      = this,\n            { include, unit } = timeAxis;\n\n        let tick = timeAxis.getTickFromDate(date);\n\n        if (tick !== -1 && respectExclusion && include) {\n            let tickChanged = false;\n\n            // Stretch if we are using a larger unit than 'hour', except if it is 'day'. If so, it is already handled\n            // by a cheaper reconfiguration of the ticks in `generateTicks`\n            if (include.hour && DH.compareUnits(unit, 'hour') > 0 && unit !== 'day') {\n                const\n                    { from, to, lengthFactor, center } = include.hour,\n                    // Original hours\n                    originalHours                      = date.getHours(),\n                    // Crop to included hours\n                    croppedHours                        = Math.min(Math.max(originalHours, from), to);\n\n                // If we are not asked to snap (when other part of span is not included) any cropped away hour\n                // should be considered excluded\n                if (!snapToNextIncluded && croppedHours !== originalHours) {\n                    return -1;\n                }\n\n                const\n                    // Should scale hour and smaller units (seconds will hardly affect visible result...)\n                    fractionalHours = croppedHours + date.getMinutes() / 60,\n                    // Number of hours from the center    |xxxx|123c----|xxx|\n                    hoursFromCenter = center - fractionalHours,\n                    // Step from center to stretch event  |x|112233c----|xxx|\n                    newHours        = center - hoursFromCenter * lengthFactor;\n\n                // Adding instead of setting to get a clone of the date, to not affect the original\n                date = DH.add(date, newHours - originalHours, 'h');\n\n                tickChanged = true;\n            }\n\n            if (include.day && DH.compareUnits(unit, 'day') > 0) {\n                const { from, to, lengthFactor, center } = include.day;\n\n                //region Crop\n                let checkDay = date.getDay();\n\n                // End date is exclusive, check the day before if at 00:00\n                if (isEnd && date.getHours() === 0 && date.getMinutes() === 0 && date.getSeconds() === 0 && date.getMilliseconds() === 0) {\n                    if (--checkDay < 0) {\n                        checkDay = 6;\n                    }\n                }\n                let addDays = 0;\n\n                if (checkDay < from || checkDay >= to) {\n                    // If end date is in view but start date is excluded, snap to next included day\n                    if (snapToNextIncluded) {\n\n                        // Step back to \"to-1\" (not inclusive) for end date\n                        if (isEnd) {\n                            addDays = (to - checkDay - 8) % 7;\n                        }\n                        // Step forward to \"from\" for start date\n                        else {\n                            addDays = (from - checkDay + 7) % 7;\n                        }\n\n                        date = DH.add(date, addDays, 'd');\n                        date = DH.startOf(date, 'd', false);\n\n                        // Keep end after start and vice versa\n                        if (\n                            (max && date.getTime() >= max) ||\n                            (min && date.getTime() <= min)\n                        ) {\n                            return -1;\n                        }\n                    }\n                    else {\n                        // day excluded at not snapping to next\n                        return -1;\n                    }\n                }\n                //endregion\n\n                const\n                    { weekStartDay } = timeAxis,\n                    // Center to stretch around, for some reason pre-calculated cannot be used for sundays :)\n                    fixedCenter      = date.getDay() === 0 ? 0 : center,\n                    // Should scale day and smaller units (minutes will hardly affect visible result...)\n                    fractionalDay    = date.getDay() + date.getHours() / 24, //+ dateClone.getMinutes() / (24 * 1440),\n                    // Number of days from the calculated center\n                    daysFromCenter   = fixedCenter - fractionalDay,\n                    // Step from center to stretch event\n                    newDay           = fixedCenter - daysFromCenter * lengthFactor;\n\n                // Adding instead of setting to get a clone of the date, to not affect the original\n                date = DH.add(date, newDay - fractionalDay + weekStartDay, 'd');\n\n                tickChanged = true;\n            }\n\n            // Now the date might start somewhere else (fraction of ticks)\n            if (tickChanged) {\n                // When stretching date might end up outside of time axis, making it invalid to use. Clip it to time axis\n                // to circumvent this\n                date = DH.constrain(date, timeAxis.startDate, timeAxis.endDate);\n\n                // Get a new tick based on the \"scaled\" date\n                tick = timeAxis.getTickFromDate(date);\n            }\n        }\n\n        return tick;\n    }\n\n    /**\n     * Gets the date for a position on the time axis\n     * @param {Number} position The page X or Y coordinate\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [allowOutOfRange=false] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} the Date corresponding to the xy coordinate\n     * @category Date mapping\n     */\n    getDateFromPosition(position, roundingMethod, allowOutOfRange = false) {\n        const\n            me           = this,\n            { timeAxis } = me,\n            tick         = me.getScaledPosition(position) / me.tickSize + timeAxis.visibleTickStart;\n\n        if (tick < 0 || tick > timeAxis.count) {\n            if (allowOutOfRange) {\n                let result;\n\n                // Subtract the correct number of tick units from the start date\n                if (tick < 0) {\n                    result = DH.add(timeAxis.startDate, tick, timeAxis.unit);\n                }\n                else {\n                    // Add the correct number of tick units to the end date\n                    result = DH.add(timeAxis.endDate, tick - timeAxis.count, timeAxis.unit);\n                }\n\n                // Honour the rounding requested\n                if (roundingMethod) {\n                    result = timeAxis[roundingMethod + 'Date'](result);\n                }\n                return result;\n            }\n            return null;\n        }\n\n        return timeAxis.getDateFromTick(tick, roundingMethod);\n    }\n\n    // Translates a position along the time axis to facilitate scaling events when excluding certain days or hours\n    getScaledPosition(position) {\n        const { include, unit, weekStartDay }  = this.timeAxis;\n\n        // Calculations are\n\n        if (include) {\n            const dayWidth = this.getSingleUnitInPixels('day');\n\n            // Have to calculate day before hour to get end result correct\n            if (include.day && DH.compareUnits(unit, 'day') > 0) {\n                const { from, lengthFactor } = include.day,\n                    // Scaling happens within a week, determine position within it\n                    positionInWeek = position % (dayWidth * 7),\n                    // Store were the week starts to be able to re-add it after scale\n                    weekStartPosition = position - positionInWeek;\n                // Scale position using calculated length per day factor, adding the width of excluded days\n                position = positionInWeek / lengthFactor + (from - weekStartDay) * dayWidth + weekStartPosition;\n            }\n\n            // Hours are not taken into account when viewing days, since the day ticks are reconfigured in\n            // `generateTicks` instead\n            if (include.hour && DH.compareUnits(unit, 'hour') > 0 && unit !== 'day') {\n                const { from, lengthFactorExcl } = include.hour,\n                    hourWidth = this.getSingleUnitInPixels('hour'),\n                    // Scaling happens within a day, determine position within it\n                    positionInDay = position % dayWidth,\n                    // Store were the day starts to be able to re-add it after scale\n                    dayStartPosition = position - positionInDay;\n                // Scale position using calculated length per day factor, adding the width of excluded hours\n                position = positionInDay / lengthFactorExcl + from * hourWidth + dayStartPosition;\n            }\n        }\n\n        return position;\n    }\n\n    /**\n     * Returns the amount of pixels for a single unit\n     * @internal\n     * @returns {Number} The unit in pixel\n     */\n    getSingleUnitInPixels(unit) {\n        const me = this;\n\n        return me.unitToPixelsCache[unit] || (me.unitToPixelsCache[unit] = DH.getUnitToBaseUnitRatio(me.timeAxis.unit, unit, true) * me.tickSize / me.timeAxis.increment);\n    }\n\n    /**\n     * Returns the pixel increment for the current view resolution.\n     * @internal\n     * @returns {Number} The increment\n     */\n    get snapPixelAmount() {\n        if (this.snap) {\n            const { resolution } = this.timeAxis;\n            return (resolution.increment || 1) * this.getSingleUnitInPixels(resolution.unit);\n        }\n        return 1;\n    }\n\n    //endregion\n\n    //region Sizes\n\n    /**\n     * Get/set the current time column size (the width or height of a cell in the bottom-most time axis header row,\n     * depending on mode)\n     * @internal\n     * @property {Number}\n     */\n    get tickSize() {\n        return this._tickSize;\n    }\n\n    set tickSize(size) {\n        this.setTickSize(size, false);\n    }\n\n    setTickSize(size, suppressEvent) {\n        this._tickSize = this.originalTickSize = size;\n\n        this.update(undefined, suppressEvent);\n    }\n\n    get timeResolution() {\n        return this.timeAxis.resolution;\n    }\n\n    // Calculates the time column width/height based on the value defined viewPreset \"tickWidth/tickHeight\". It also\n    // checks for the forceFit view option and the snap, both of which impose constraints on the time column width\n    // configuration.\n    calculateTickSize(proposedSize) {\n        const\n            me                                  = this,\n            { forceFit, timeAxis, suppressFit } = me,\n            timelineUnit                        = timeAxis.unit;\n\n        let size  = 0,\n            ratio = 1; //Number.MAX_VALUE;\n\n        if (me.snap) {\n            const resolution = timeAxis.resolution;\n            ratio = DH.getUnitToBaseUnitRatio(timelineUnit, resolution.unit) * resolution.increment;\n        }\n\n        if (!suppressFit) {\n            const fittingSize = me.availableSpace / timeAxis.visibleTickTimeSpan;\n\n            size = (forceFit || proposedSize < fittingSize) ? fittingSize : proposedSize;\n\n            if (ratio > 0 && (!forceFit || ratio < 1)) {\n                size = Math.max(1, ratio * size) / ratio;\n            }\n        }\n        else {\n            size = proposedSize;\n        }\n\n        return size;\n    }\n\n    /**\n     * Returns the total width/height of the time axis representation, depending on mode.\n     * @returns {Number} The width or height\n     * @internal\n     * @readonly\n     */\n    get totalSize() {\n        // Floor the space to prevent spurious overflow\n        return this._totalSize || (this._totalSize = Math.floor(this.tickSize * this.timeAxis.visibleTickTimeSpan));\n    }\n\n    /**\n     * Get/set the available space for the time axis representation. If size changes it will cause it to update its\n     * contents and fire the {@link #event-update} event.\n     * @internal\n     * @property {Number}\n     */\n    get availableSpace() {\n        return this._availableSpace;\n    }\n\n    set availableSpace(space) {\n        const me = this;\n        // We should only need to repaint fully if the tick width has changed (which will happen if forceFit is set, or if the full size of the time axis doesn't\n        // occupy the available space - and gets stretched\n        me._availableSpace = Math.max(0, space);\n\n        if (me._availableSpace > 0) {\n            const newTickSize = me.calculateTickSize(me.originalTickSize);\n\n            if (newTickSize > 0 && newTickSize !== me.tickSize) {\n                me.update();\n            }\n        }\n    }\n\n    //endregion\n\n    //region Fitting & snapping\n\n    /**\n     * Returns start dates for ticks at the specified level in format { date, isMajor }.\n     * @param {Number} level Level in headers array, `0` meaning the topmost...\n     * @param {Boolean} useLowestHeader Use lowest level\n     * @param getEnd\n     * @returns {Array}\n     * @internal\n     */\n    getDates(level = this.columnLinesFor, useLowestHeader = false, getEnd = false) {\n        const\n            me            = this,\n            ticks         = [],\n            linesForLevel = useLowestHeader ? me.lowestHeader : level,\n            majorLevel    = me.majorHeaderLevel,\n            levelUnit     = me.headers && me.headers[level].unit,\n            majorUnit     = majorLevel != null && me.headers && me.headers[majorLevel].unit,\n            validMajor    = majorLevel != null && DH.doesUnitsAlign(majorUnit, levelUnit),\n            hasGenerator  = !!(me.headers && me.headers[linesForLevel].cellGenerator);\n\n        if (hasGenerator) {\n            const cells = me.columnConfig[linesForLevel];\n\n            for (let i = 1, l = cells.length; i < l; i++) {\n                ticks.push({ date : cells[i].startDate });\n            }\n        }\n        else {\n            me.forEachInterval(linesForLevel, (start, end) => {\n                ticks.push({\n                    date    : getEnd ? end : start,\n                    // do not want to consider tick to be major tick, hence the check for majorHeaderLevel\n                    isMajor : majorLevel !== level && validMajor && me.isMajorTick(getEnd ? end : start)\n                });\n            });\n        }\n\n        return ticks;\n    }\n\n    get forceFit() {\n        return this._forceFit;\n    }\n\n    /**\n     * This function fits the time columns into the available space in the time axis column.\n     * @param {Boolean} suppressEvent `true` to skip firing the 'update' event.\n     * @internal\n     */\n    fitToAvailableSpace(suppressEvent) {\n        const proposedSize = Math.floor(this.availableSpace / this.timeAxis.visibleTickTimeSpan);\n        this.setTickSize(proposedSize, suppressEvent);\n    }\n\n    get snap() {\n        return this._snap;\n    }\n\n    /**\n     * Gets/sets the snap value for the model. Setting it will cause it to update its contents and fire the\n     * {@link #event-update} event.\n     * @property {Boolean}\n     * @internal\n     */\n    set snap(value) {\n        if (value !== this._snap) {\n            this._snap = value;\n            if (this.configured) {\n                this.update();\n            }\n        }\n    }\n\n    //endregion\n\n    //region Headers\n\n    // private\n    createHeaderRow(position, headerRowConfig, headerCells) {\n        const\n            me                            = this,\n            cells                         = [],\n            { align, headerCellCls = '' } = headerRowConfig,\n            today                         = DH.clearTime(new Date()),\n            { timeAxis }                  = me,\n            tickLevel                     = me.headers.length - 1,\n            createCellContext             = (start, end, i, isLast, data) => {\n                let value = DH.format(start, headerRowConfig.dateFormat);\n\n                const\n                    // So that we can use shortcut tickSize as the tickLevel cell width.\n                    // We can do this if the TimeAxis is aligned to start and end on tick boundaries\n                    // or if it's not the first or last tick.\n                    // getDistanceBetweenDates is an expensive operation.\n                    isInteriorTick = i > 0 && !isLast,\n                    cellData = {\n                        align,\n                        start,\n                        end,\n                        value : data ? data.header : value,\n                        headerCellCls,\n                        width : tickLevel === position && me.owner && (timeAxis.fullTicks || isInteriorTick) ? me.owner.tickSize : me.getDistanceBetweenDates(start, end),\n                        index : i\n                    };\n                if (cellData.width === 0) {\n                    return;\n                }\n\n                // Vertical mode uses absolute positioning for header cells\n                cellData.coord = size - 1;\n                size += cellData.width;\n\n                me.headersDatesCache[position][start.getTime()] = 1;\n\n                if (headerRowConfig.renderer) {\n                    value = headerRowConfig.renderer.call(headerRowConfig.thisObj || me, start, end, cellData, i);\n\n                    cellData.value = value == null ? '' : value;\n                }\n\n                // To be able to style individual day cells, weekends or other important days\n                if (headerRowConfig.unit === 'day' && (!headerRowConfig.increment || headerRowConfig.increment === 1)) {\n                    cellData.headerCellCls += ' b-sch-dayheadercell-' + start.getDay();\n\n                    if (DH.clearTime(start, true) - today === 0) {\n                        cellData.headerCellCls += ' b-sch-dayheadercell-today';\n                    }\n                }\n\n                cells.push(cellData);\n            };\n\n        let size = 0;\n\n        me.headersDatesCache[position] = {};\n\n        if (headerCells) {\n            headerCells.forEach((cellData, i) => createCellContext(cellData.start, cellData.end, i, i === headerCells.length - 1, cellData));\n        }\n        else {\n            me.forEachInterval(position, createCellContext);\n        }\n\n        return cells;\n    }\n\n    get mainHeader() {\n        return ('mainHeaderLevel' in this) ? this.headers[this.mainHeaderLevel] : this.bottomHeader;\n    }\n\n    get bottomHeader() {\n        return this.headers[this.headers.length - 1];\n    }\n\n    get lowestHeader() {\n        return this.headers.length - 1;\n    }\n\n    /**\n     * This method is meant to return the level of the header which 2nd lowest.\n     * It is used for {@link #function-isMajorTick} method\n     * @returns {String}\n     * @private\n     */\n    get majorHeaderLevel() {\n        const { headers } = this;\n\n        if (headers) {\n            return Math.max(headers.length - 2, 0);\n        }\n\n        return null;\n    }\n\n    //endregion\n\n    //region Ticks\n\n    /**\n     * For vertical view (and column lines plugin) we sometimes want to know if current tick starts along with the\n     * upper header level.\n     * @param {Date} date\n     * @returns {Boolean}\n     * @private\n     */\n    isMajorTick(date) {\n        const nextLevel = this.majorHeaderLevel;\n        // if forceFit is used headersDatesCache wont have been generated yet on the first call here,\n        // since no size is set yet\n        return nextLevel != null && this.headersDatesCache[nextLevel] && this.headersDatesCache[nextLevel][date.getTime()] || false;\n    }\n\n    /**\n     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.\n     * Return false to break the iteration.\n     * @param {Number} position The index of the header in the headers array.\n     * @param {Function} iteratorFn The function to call, will be called with start date, end date and \"tick index\"\n     * @param {Object} [thisObj] `this` reference for the function\n     * @internal\n     */\n    forEachInterval(position, iteratorFn, thisObj = this) {\n        const { headers, timeAxis } = this;\n\n        if (headers) {\n            // This is the lowest header row, which should be fed the data in the tickStore (or a row above using same unit)\n            if (position === headers.length - 1) {\n                timeAxis.forEach((r, index) =>\n                    iteratorFn.call(thisObj, r.startDate, r.endDate, index, index === timeAxis.count - 1)\n                );\n            }\n            // All other rows\n            else {\n                const header = headers[position];\n\n                timeAxis.forEachAuxInterval(header.unit, header.increment, iteratorFn, thisObj);\n            }\n        }\n    }\n\n    /**\n     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.\n     * Return false to break the iteration.\n     * @internal\n     * @param {Function} iteratorFn The function to call\n     * @param {Object} [thisObj] `this` reference for the function\n     */\n    forEachMainInterval(iteratorFn, thisObj) {\n        this.forEachInterval(this.mainHeaderLevel, iteratorFn, thisObj);\n    }\n\n    //endregion\n\n    //region ViewPreset\n\n    consumeViewPreset(preset) {\n        const me = this;\n\n        // clear the cached headers\n        me.headers = null;\n\n        me.getConfig('tickSize');\n\n        // Since we are bypassing the tickSize setter below, ensure that\n        // the config initial setter has been removed by referencing the property.\n        // We only do this to avoid multiple updates from this. TODO: Fix this issue,\n        // and do not bypass setters.\n        me.viewPreset = preset;\n\n        Object.assign(me, {\n            headers         : preset.headers,\n            columnLinesFor  : preset.columnLinesFor,\n            mainHeaderLevel : preset.mainHeaderLevel,\n            _tickSize       : me.isHorizontal ? preset.tickWidth : preset.tickHeight\n        });\n\n        me.originalTickSize = me.tickSize;\n    }\n\n    //endregion\n}\n","import Base from '../../../Core/Base.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\n\n// Used to avoid having to create huge amounts of Date objects\nconst tempDate = new Date();\n\n/**\n * @module Scheduler/view/mixin/TimelineDateMapper\n */\n\n/**\n * Mixin that contains functionality to convert between coordinates and dates etc.\n *\n * @mixin\n */\nexport default Target => class TimelineDateMapper extends (Target || Base) {\n    static $name = 'TimelineDateMapper';\n\n    static configurable = {\n        /**\n         * Set to `true` to snap to the current time resolution increment while interacting with scheduled events.\n         *\n         * The time resolution increment is either determined by the currently applied view preset, or it can be\n         * overridden using {@link #property-timeResolution}.\n         *\n         * <div class=\"note\">When the {@link Scheduler/view/mixin/TimelineEventRendering#config-fillTicks} option is\n         * enabled, snapping will align to full ticks, regardless of the time resolution.</div>\n         *\n         * @prp {Boolean}\n         * @default\n         * @category Scheduled events\n         */\n        snap : false\n    }\n\n    //region Coordinate <-> Date\n\n    getRtlX(x) {\n        if (this.rtl && this.isHorizontal) {\n            x = this.timeAxisViewModel.totalSize - x;\n        }\n        return x;\n    }\n\n    /**\n     * Gets the date for an X or Y coordinate, either local to the view element or the page based on the 3rd argument.\n     * If the coordinate is not in the currently rendered view, null will be returned unless the `allowOutOfRange`\n     * parameter is passed a `true`.\n     * @param {Number} coordinate The X or Y coordinate\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [local] true if the coordinate is local to the scheduler view element\n     * @param {Boolean} [allowOutOfRange] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} The Date corresponding to the X or Y coordinate\n     * @category Dates\n     */\n    getDateFromCoordinate(coordinate, roundingMethod, local = true, allowOutOfRange = false, ignoreRTL = false) {\n        if (!local) {\n            coordinate = this.currentOrientation.translateToScheduleCoordinate(coordinate);\n        }\n\n        // Time axis is flipped for RTL\n        if (!ignoreRTL) {\n            coordinate = this.getRtlX(coordinate);\n        }\n\n        return this.timeAxisViewModel.getDateFromPosition(coordinate, roundingMethod, allowOutOfRange);\n    }\n\n    getDateFromCoord(options) {\n        return this.getDateFromCoordinate(options.coord, options.roundingMethod, options.local, options.allowOutOfRange, options.ignoreRTL);\n    }\n\n    /**\n     * Gets the date for an XY coordinate regardless of the orientation of the time axis.\n     * @param {Array} xy The page X and Y coordinates\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [local] true if the coordinate is local to the scheduler element\n     * @param {Boolean} [allowOutOfRange] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} the Date corresponding to the xy coordinate\n     * @category Dates\n     */\n    getDateFromXY(xy, roundingMethod, local = true, allowOutOfRange = false) {\n        return this.currentOrientation.getDateFromXY(xy, roundingMethod, local, allowOutOfRange);\n    }\n\n    /**\n     * Gets the time for a DOM event such as 'mousemove' or 'click' regardless of the orientation of the time axis.\n     * @param {Event} e the Event instance\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [allowOutOfRange] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} The date corresponding to the EventObject's position along the orientation of the time axis.\n     * @category Dates\n     */\n    getDateFromDomEvent(e, roundingMethod, allowOutOfRange = false) {\n        return this.getDateFromXY([e.pageX, e.pageY], roundingMethod, false, allowOutOfRange);\n    }\n\n    /**\n     * Gets the start and end dates for an element Region\n     * @param {Core.helper.util.Rectangle} rect The rectangle to map to start and end dates\n     * @param {'floor'|'round'|'ceil'} roundingMethod Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Number} duration The duration in MS of the underlying event\n     * @returns {Object} an object containing start/end properties\n     */\n    getStartEndDatesFromRectangle(rect, roundingMethod, duration, allowOutOfRange = false) {\n        const\n            me               = this,\n            { isHorizontal } = me,\n            startPos         = isHorizontal ? rect.x : rect.top,\n            endPos           = isHorizontal ? rect.right : rect.bottom;\n\n        let start, end;\n\n        // Element within bounds\n        if (startPos >= 0 && endPos < me.timeAxisViewModel.totalSize) {\n            start = me.getDateFromCoordinate(startPos, roundingMethod, true);\n            end = me.getDateFromCoordinate(endPos, roundingMethod, true);\n        }\n        // Starts before, start is worked backwards from end\n        else if (startPos < 0) {\n            end = me.getDateFromCoordinate(endPos, roundingMethod, true, allowOutOfRange);\n            start = end && DateHelper.add(end, -duration, 'ms');\n        }\n        // Ends after, end is calculated from the start\n        else {\n            start = me.getDateFromCoordinate(startPos, roundingMethod, true, allowOutOfRange);\n            end = start && DateHelper.add(start, duration, 'ms');\n        }\n\n        return {\n            start, end\n        };\n    }\n\n    //endregion\n\n    //region Date display\n\n    /**\n     * Get/set format to use when displaying dates. Usually set by specifying a view preset\n     * @property {String}\n     * @category Dates\n     */\n    get displayDateFormat() {\n        return this._displayDateFormat;\n    }\n\n    set displayDateFormat(format) {\n        this._displayDateFormat = format;\n\n        // Start/EndDateColumn listens for this to change their format to match\n        this.trigger('displayDateFormatChange', { format });\n    }\n\n    /**\n     * Method to get a formatted display date\n     * @private\n     * @param {Date} date The date\n     * @returns {String} The formatted date\n     */\n    getFormattedDate(date) {\n        return DateHelper.format(date, this.displayDateFormat);\n    }\n\n    /**\n     * Method to get a displayed end date value, see {@link #function-getFormattedEndDate} for more info.\n     * @private\n     * @param {Date} endDate The date to format\n     * @param {Date} startDate The start date\n     * @returns {Date} The date value to display\n     */\n    getDisplayEndDate(endDate, startDate) {\n        if (\n            // If time is midnight,\n            endDate.getHours() === 0 && endDate.getMinutes() === 0 &&\n\n            // and end date is greater then start date\n            (!startDate || !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate())) &&\n\n            // and UI display format doesn't contain hour info (in this case we'll just display the exact date)\n            !DateHelper.formatContainsHourInfo(this.displayDateFormat)\n        ) {\n            // format the date inclusively as 'the whole previous day'.\n            endDate = DateHelper.add(endDate, -1, 'day');\n        }\n\n        return endDate;\n    }\n\n    /**\n     * Method to get a formatted end date for a scheduled event, the grid uses the \"displayDateFormat\" property defined in the current view preset.\n     * End dates are formatted as 'inclusive', meaning when an end date falls on midnight and the date format doesn't involve any hour/minute information,\n     * 1ms will be subtracted (e.g. 2010-01-08T00:00:00 will first be modified to 2010-01-07 before being formatted).\n     * @private\n     * @param {Date} endDate The date to format\n     * @param {Date} startDate The start date\n     * @returns {String} The formatted date\n     */\n    getFormattedEndDate(endDate, startDate) {\n        return this.getFormattedDate(this.getDisplayEndDate(endDate, startDate));\n    }\n\n    //endregion\n\n    //region Other date functions\n\n    /**\n     * Gets the x or y coordinate relative to the scheduler element, or page coordinate (based on the 'local' flag)\n     * If the coordinate is not in the currently rendered view, -1 will be returned.\n     * @param {Date|Number} date the date to query for (or a date as ms)\n     * @param {Boolean|Object} options true to return a coordinate local to the scheduler view element (defaults to true),\n     * also accepts a config object like { local : true }.\n     * @returns {Number} the x or y position representing the date on the time axis\n     * @category Dates\n     */\n    getCoordinateFromDate(date, options = true) {\n        const\n            me                    = this,\n            { timeAxisViewModel } = me,\n            {\n                isContinuous,\n                startMS,\n                endMS,\n                startDate,\n                endDate,\n                unit\n            }                     = me.timeAxis,\n            dateMS                = date.valueOf();\n\n        // Avoiding to break the API while allowing passing options through to getPositionFromDate()\n        if (options === true) {\n            options = {\n                local : true\n            };\n        }\n        else if (!options) {\n            options = {\n                local : false\n            };\n        }\n        else if (!('local' in options)) {\n            options.local = true;\n        }\n\n        let pos;\n\n        // TODO for 2.0 try to normalize and just use dates as input for this method,\n        // then this if-statement would not be needed\n        if (!(date instanceof Date)) {\n            tempDate.setTime(date);\n            date = tempDate;\n        }\n\n        // Shortcut for continuous time axis that is using a unit that can be reliably translated to days (or smaller)\n        if (isContinuous &&\n            date.getTimezoneOffset() === startDate.getTimezoneOffset() &&\n            startDate.getTimezoneOffset() === endDate.getTimezoneOffset() &&\n            DateHelper.getUnitToBaseUnitRatio(unit, 'day') !== -1\n        ) {\n            if (dateMS < startMS || dateMS > endMS) {\n                return -1;\n            }\n            pos = (dateMS - startMS) / (endMS - startMS) * timeAxisViewModel.totalSize;\n        }\n        // Non-continuous or using for example months (vary in length)\n        else {\n            pos = timeAxisViewModel.getPositionFromDate(date, options);\n        }\n\n        // RTL coords from the end of the time axis\n        if (me.rtl && me.isHorizontal) {\n            pos = timeAxisViewModel.totalSize - pos;\n        }\n\n        if (!options.local) {\n            pos = me.currentOrientation.translateToPageCoordinate(pos);\n        }\n\n        return pos;\n    }\n\n    /**\n     * Returns the distance in pixels for the time span in the view.\n     * @param {Date} startDate The start date of the span\n     * @param {Date} endDate The end date of the span\n     * @returns {Number} The distance in pixels\n     * @category Dates\n     */\n    getTimeSpanDistance(startDate, endDate) {\n        return this.timeAxisViewModel.getDistanceBetweenDates(startDate, endDate);\n    }\n\n    /**\n     * Returns the center date of the currently visible timespan of scheduler.\n     *\n     * @property {Date}\n     * @readonly\n     * @category Dates\n     */\n    get viewportCenterDate() {\n        const { timeAxis, timelineScroller } = this;\n\n        // Take the easy way if the axis is continuous.\n        // We can just work out how far along the time axis the viewport center is.\n        if (timeAxis.isContinuous) {\n            // The offset from the start of the whole time axis\n            const timeAxisOffset = (timelineScroller.position + timelineScroller.clientSize / 2) / timelineScroller.scrollSize;\n\n            return new Date(timeAxis.startMS + (timeAxis.endMS - timeAxis.startMS) * timeAxisOffset);\n        }\n        return this.getDateFromCoordinate(timelineScroller.position + timelineScroller.clientSize / 2);\n    }\n\n    get viewportCenterDateCached() {\n        return this.cachedCenterDate || (this.cachedCenterDate = this.viewportCenterDate);\n    }\n\n    //endregion\n\n    //region TimeAxis getters/setters\n\n    /**\n     * Gets/sets the current time resolution object, which contains a unit identifier and an increment count\n     * `{ unit, increment }`. This value means minimal task duration you can create using UI.\n     *\n     * For example when you drag create a task or drag & drop a task, if increment is 5 and unit is 'minute'\n     * that means that you can create tasks in 5 minute increments, or move it in 5 minute steps.\n     *\n     * This value is taken from viewPreset {@link Scheduler.preset.ViewPreset#field-timeResolution timeResolution}\n     * config by default. When supplying a `Number` to the setter only the `increment` is changed and the `unit` value\n     * remains untouched.\n     *\n     * ```javascript\n     * timeResolution : {\n     *   unit      : 'minute',  //Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n     *   increment : 5\n     * }\n     * ```\n     *\n     * <div class=\"note\">When the {@link Scheduler/view/mixin/TimelineEventRendering#config-fillTicks} option is\n     * enabled, the resolution will be in full ticks regardless of configured value.</div>\n     *\n     * @property {Object|Number}\n     * @category Dates\n     */\n    get timeResolution() {\n        return this.timeAxis.resolution;\n    }\n\n    set timeResolution(resolution) {\n        this.timeAxis.resolution = (typeof resolution === 'number') ? {\n            increment : resolution,\n            unit      : this.timeAxis.resolution.unit\n        } : resolution;\n    }\n\n    //endregion\n\n    //region Snap\n\n    get snap() {\n        return this._timeAxisViewModel?.snap ?? this._snap;\n    }\n\n    updateSnap(snap) {\n        if (!this.isConfiguring) {\n            this.timeAxisViewModel.snap = snap;\n            this.timeAxis.forceFullTicks = snap && this.fillTicks;\n        }\n    }\n\n    //endregion\n\n    onSchedulerHorizontalScroll({ subGrid, scrollLeft, scrollX }) {\n        // Invalidate cached center date unless we are scrolling to center on it.\n        if (!this.scrollingToCenter) {\n            this.cachedCenterDate = null;\n        }\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\nimport BrowserHelper from '../../../Core/helper/BrowserHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport DomDataStore from '../../../Core/data/DomDataStore.js';\n\n/**\n * @module Scheduler/view/mixin/TimelineDomEvents\n */\n\nconst { eventNameMap } = EventHelper;\n\n/**\n * An object which encapsulates a schedule timeline tick context based on a DOM event. This will include\n * the row and resource information and the tick and time information for a DOM pointer event detected\n * in the timeline.\n * @typedef {Object} TimelineContext\n * @property {Event} domEvent The DOM event which triggered the context change.\n * @property {HTMLElement} eventElement If the `domEvent` was on an event bar, this will be the event bar element.\n * @property {HTMLElement} cellElement The cell element under the `domEvent`\n * @property {Date} date The date corresponding to the `domEvent` position in the timeline\n * @property {Scheduler.model.TimeSpan} tick A {@link Scheduler.model.TimeSpan} record which encapsulates the contextual tick\n * @property {Number} tickIndex The contextual tick index. This may be fractional.\n * @property {Number} tickParentIndex The integer contextual tick index.\n * @property {Date} tickStartDate The start date of the contextual tick.\n * @property {Date} tickEndDate The end date of the contextual tick.\n * @property {Grid.row.Row} row The contextual {@link Grid.row.Row}\n * @property {Number} index The contextual row index\n * @property {Scheduler.model.EventModel} [eventRecord] The contextual event record (if any) if the event source is a `Scheduler`\n * @property {Scheduler.model.AssignmentModel} [assignmentRecord] The contextual assignment record (if any) if the event source is a `Scheduler`\n * @property {Scheduler.model.ResourceModel} [resourceRecord] The contextual resource record(if any)  if the event source is a `Scheduler`\n */\n\n/**\n * Mixin that handles dom events (click etc) for scheduler and rendered events.\n *\n * @mixin\n */\nexport default Target => class TimelineDomEvents extends (Target || Base) {\n    /**\n     * Fires after a click on a time axis cell\n     * @event timeAxisHeaderClick\n     * @param {Scheduler.column.TimeAxisColumn|Scheduler.column.VerticalTimeAxisColumn} source The column object\n     * @param {Date} startDate The start date of the header cell\n     * @param {Date} endDate The end date of the header cell\n     * @param {Event} event The event object\n     */\n\n    /**\n     * Fires after a double click on a time axis cell\n     * @event timeAxisHeaderDblClick\n     * @param {Scheduler.column.TimeAxisColumn|Scheduler.column.VerticalTimeAxisColumn} source The column object\n     * @param {Date} startDate The start date of the header cell\n     * @param {Date} endDate The end date of the header cell\n     * @param {Event} event The event object\n     */\n\n    /**\n     * Fires after a right click on a time axis cell\n     * @event timeAxisHeaderContextMenu\n     * @param {Scheduler.column.TimeAxisColumn|Scheduler.column.VerticalTimeAxisColumn} source The column object\n     * @param {Date} startDate The start date of the header cell\n     * @param {Date} endDate The end date of the header cell\n     * @param {Event} event The event object\n     */\n\n    static $name = 'TimelineDomEvents';\n\n    //region Default config\n\n    static configurable = {\n        /**\n         * The currently hovered timeline context. This is updated as the mouse or pointer moves over the timeline.\n         * @member {TimelineContext} timelineContext\n         * @readonly\n         */\n        timelineContext : {\n            $config : {\n                // Reject non-changes so that when set from scheduleMouseMove and EventMouseMove,\n                // we only update the context and fire events when it changes.\n                equal(c1, c2) {\n                    // index is the resource index, tickParentIndex is the\n                    // tick's index in the TimeAxis.\n                    return c1?.index === c2?.index &&\n                            c1?.tickParentIndex === c2?.tickParentIndex &&\n                            !((c1?.tickStartDate || 0) - (c2?.tickStartDate || 0));\n                }\n            }\n        },\n\n        /**\n         * By default, scrolling the schedule will update the {@link #property-timelineContext} to reflect the new\n         * currently hovered context. When displaying a large number of events on screen at the same time, this will\n         * have a slight impact on scrolling performance. In such scenarios, opt out of this behavior by setting\n         * this config to `false`.\n         * @default\n         * @prp {Boolean}\n         */\n        updateTimelineContextOnScroll : true\n    }\n\n    static properties = {\n        schedulerEvents : {\n            mouseover   : 'handleScheduleEvent',\n            mousedown   : 'handleScheduleEvent',\n            mouseup     : 'handleScheduleEvent',\n            click       : 'handleScheduleEvent',\n            dblclick    : 'handleScheduleEvent',\n            contextmenu : 'handleScheduleEvent',\n            mousemove   : 'handleScheduleEvent',\n            mouseout    : 'handleScheduleEvent'\n        },\n\n        schedulerEnterLeaveEvents : {\n            mouseenter : 'handleScheduleEnterLeaveEvent',\n            mouseleave : 'handleScheduleEnterLeaveEvent',\n            capture    : true\n        }\n    }\n\n    static delayable = {\n        // Allow the scroll event to complete in its thread, and dispatch the mousemove event next AF\n        onScheduleScroll : 'raf'\n    }\n\n    // Currently hovered events (can be parent + child)\n    hoveredEvents = new Set();\n\n    //endregion\n\n    //region Init\n\n    /**\n     * Adds listeners for DOM events for the scheduler and its events.\n     * Which events is specified in Scheduler#schedulerEvents.\n     * @private\n     */\n    initDomEvents() {\n        const\n            me = this,\n            {\n                schedulerEvents,\n                schedulerEnterLeaveEvents\n            } = me;\n\n        // Set thisObj and element of the configured listener specs.\n        schedulerEvents.element = schedulerEnterLeaveEvents.element = me.timeAxisSubGridElement;\n        schedulerEvents.thisObj = schedulerEnterLeaveEvents.thisObj = me;\n        EventHelper.on(schedulerEvents);\n        EventHelper.on(schedulerEnterLeaveEvents);\n\n        // This is to handle scroll events while the mouse is over the schedule.\n        // For example magic mouse or touchpad scrolls, or scrolls caused by keyboard\n        // navigation while the mouse happens to be over the schedule.\n        // The context must update. We must consider any scroll because the document\n        // or some other wrapping element could be scrolling the Scheduler under the mouse.\n        if (BrowserHelper.supportsPointerEventConstructor) {\n            EventHelper.on({\n                element : document,\n                scroll  : 'onScheduleScroll',\n                capture : true,\n                thisObj : me\n            });\n        }\n    };\n\n    //endregion\n\n    //region Event handling\n    getTimeSpanMouseEventParams(eventElement, event) {\n        throw new Error('Implement in subclass');\n    }\n\n    getScheduleMouseEventParams(cellData, event) {\n        throw new Error('Implement in subclass');\n    }\n\n    /**\n     * Wraps dom Events for the scheduler and event bars and fires as our events.\n     * For example click -> scheduleClick or eventClick\n     * @private\n     * @param event\n     */\n    handleScheduleEvent(event) {\n        const\n            me              = this,\n            timelineContext = me.getTimelineEventContext(event);\n\n        // Cache the last pointer event so that  when scrolling below the mouse\n        // we can inject mousemove events at that point.\n        me.lastPointerEvent = event;\n\n        // We are over the schedule region\n        if (timelineContext) {\n            // Only fire a scheduleXXXX event if we are *not* over an event.\n            // If over an event fire (event|task)XXXX.\n            me.trigger(`${timelineContext.eventElement ? me.scheduledEventName : 'schedule'}${eventNameMap[event.type] || StringHelper.capitalize(event.type)}`, timelineContext);\n        }\n\n        // If the context has changed, updateTimelineContext will fire events\n        me.timelineContext = timelineContext;\n    }\n\n    handleScheduleEnterLeaveEvent(event) {\n        if (event.target.parentElement === this.foregroundCanvas) {\n            this.handleScheduleEvent(event);\n        }\n    }\n\n    /**\n     * This handles the scheduler being scrolled below the mouse by trackpad ot keyboard events.\n     * The context, if present needs to be recalculated.\n     * @private\n     */\n    onScheduleScroll({ target }) {\n        const me = this;\n        // If the latest mouse event resulted in setting a context, we need to reproduce that event at the same clientX,\n        // clientY in order to keep the context up to date while scrolling.\n        // If the scroll is because of a pan feature drag (on us or a partner), we must not do this.\n        // Target might be removed in salesforce by Locker Service if scroll event occurs on body\n        if (\n            target && me.updateTimelineContextOnScroll && !me.features.pan?.isActive && !me.partners.some(p => p.features.pan?.isActive) &&\n            (target.contains(me.element) || me.bodyElement.contains(target))\n        ) {\n            const { timelineContext, lastPointerEvent } = me;\n\n            if (timelineContext) {\n                const\n                    targetElement = DomHelper.elementFromPoint(timelineContext.domEvent.clientX, timelineContext.domEvent.clientY),\n                    pointerEvent  = new PointerEvent('pointermove', lastPointerEvent),\n                    mouseEvent    = new MouseEvent('mousemove', lastPointerEvent);\n\n                // Drag code should ignore these synthetic events\n                pointerEvent.scrollInitiated = mouseEvent.scrollInitiated = true;\n\n                // Emulate the correct browser sequence for mouse move events\n                targetElement?.dispatchEvent(pointerEvent);\n                targetElement?.dispatchEvent(mouseEvent);\n            }\n        }\n    }\n\n    updateTimelineContext(context, oldContext) {\n        /**\n         * Fired when the pointer-activated {@link #property-timelineContext} has changed.\n         * @event timelineContextChange\n         * @param {TimelineContext} oldContext The tick/resource context being deactivated.\n         * @param {TimelineContext} context The tick/resource context being activated.\n         */\n        this.trigger('timelineContextChange', { oldContext, context });\n\n        if (!context) {\n            this.trigger('scheduleMouseLeave');\n        }\n    }\n\n    /**\n     * Gathers contextual information about the schedule contextual position of the passed event.\n     *\n     * Used by schedule mouse event handlers, but also by the scheduleContext feature.\n     * @param {Event} domEvent The DOM event to gather context for.\n     * @returns {TimelineContext} the schedule DOM event context\n     * @internal\n     */\n    getTimelineEventContext(domEvent) {\n        const\n            me           = this,\n            eventElement = domEvent.target.closest(me.eventInnerSelector),\n            cellElement  = me.getCellElementFromDomEvent(domEvent);\n\n        if (cellElement) {\n            const clickedDate = me.getDateFromDomEvent(domEvent, 'floor');\n\n            if (!clickedDate) {\n                return;\n            }\n\n            const\n                cellData    = DomDataStore.get(cellElement),\n                mouseParams = eventElement ? me.getTimeSpanMouseEventParams(eventElement, domEvent) : me.getScheduleMouseEventParams(cellData, domEvent);\n\n            if (!mouseParams) {\n                return;\n            }\n\n            const\n                index       = me.isVertical ? me.resourceStore.indexOf(mouseParams.resourceRecord) : cellData.row.dataIndex,\n                tickIndex   = me.timeAxis.getTickFromDate(clickedDate),\n                tick        = me.timeAxis.getAt(Math.floor(tickIndex));\n\n            if (tick) {\n                return {\n                    isTimelineContext : true,\n                    domEvent,\n                    eventElement,\n                    cellElement,\n                    index,\n                    tick,\n                    tickIndex,\n                    date              : clickedDate,\n                    tickStartDate     : tick.startDate,\n                    tickEndDate       : tick.endDate,\n                    tickParentIndex   : tick.parentIndex,\n                    row               : cellData.row,\n                    event             : domEvent,\n                    ...mouseParams\n                };\n            }\n        }\n    }\n\n    getCellElementFromDomEvent({ target, clientY, type }) {\n        const\n            me             = this,\n            {\n                isVertical,\n                foregroundCanvas\n            }              = me,\n            eventElement   = target.closest(me.eventSelector);\n\n        // If event was on an event bar, calculate the cell.\n        if (eventElement) {\n            return me.getCell({\n                [isVertical ? 'row' : 'record'] : isVertical ? 0 : me.resolveRowRecord(eventElement),\n                column                          : me.timeAxisColumn\n            });\n        }\n        // If event was triggered by an element in the foreground canvas, but not an event element\n        // we need to ascertain the cell \"behind\" that element to be able to create the context.\n        else if (foregroundCanvas.contains(target)) {\n            // Only trigger a Scheduler event if the event was on the background itself.\n            // Otherwise, we will trigger unexpected events on things like dependency lines which historically\n            // have never triggered scheduleXXXX events. The exception to this is the mousemove event which\n            // needs to always fire so that timelineContext and scheduleTooltip correctly track the mouse\n            if (target === foregroundCanvas || type === 'mousemove') {\n                return me.rowManager.getRowAt(clientY, false)?.getCell(me.timeAxisColumn.id);\n            }\n        }\n        else {\n            // Event was inside a row, or on a row border.\n            return target.matches('.b-grid-row') ? target.firstElementChild : target.closest(me.timeCellSelector);\n        }\n    }\n\n    // Overridden by ResourceTimeRanges to \"pass events through\" to the schedule\n    matchScheduleCell(element) {\n        return element.closest(this.timeCellSelector);\n    }\n\n    onElementMouseButtonEvent(event) {\n        const target = event.target.closest('.b-sch-header-timeaxis-cell');\n        if (target) {\n            const\n                index        = target.dataset.tickIndex,\n                position     = target.parentElement.dataset.headerPosition,\n                columnConfig = this.timeAxisViewModel.columnConfig[position][index],\n                contextMenu  = this.features.contextMenu;\n\n            // Skip same events with Grid context menu triggerEvent\n            if (!contextMenu || event.type !== contextMenu.triggerEvent) {\n                this.trigger(`timeAxisHeader${StringHelper.capitalize(event.type)}`, {\n                    startDate : columnConfig.start,\n                    endDate   : columnConfig.end,\n                    event\n                });\n            }\n        }\n    }\n\n    onElementMouseDown(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementMouseDown(event);\n    }\n\n    onElementClick(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementClick(event);\n    }\n\n    onElementDblClick(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementDblClick(event);\n    }\n\n    onElementContextMenu(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementContextMenu(event);\n    }\n\n    /**\n     * Relays mouseover events as eventmouseenter if over rendered event.\n     * Also adds Scheduler#overScheduledEventClass to the hovered element.\n     * @private\n     */\n    onElementMouseOver(event) {\n        super.onElementMouseOver(event);\n\n        const\n            me                = this,\n            { target }        = event,\n            { hoveredEvents } = me;\n\n        // We must be over the event bar\n        if (target.closest(me.eventInnerSelector) && !me.features.eventDrag?.isDragging) {\n            const eventElement = target.closest(me.eventSelector);\n\n            if (!hoveredEvents.has(eventElement) && !me.preventOverCls) {\n                hoveredEvents.add(eventElement);\n                eventElement.classList.add(me.overScheduledEventClass);\n\n                const params = me.getTimeSpanMouseEventParams(eventElement, event);\n                if (params) {\n                    // do not fire this event if model cannot be found\n                    // this can be the case for \"b-sch-dragcreator-proxy\" elements for example\n                    me.trigger(`${me.scheduledEventName}MouseEnter`, params);\n                }\n            }\n        }\n        else if (hoveredEvents.size) {\n            me.unhoverAll(event);\n        }\n    }\n\n    /**\n     * Relays mouseout events as eventmouseleave if out from rendered event.\n     * Also removes Scheduler#overScheduledEventClass from the hovered element.\n     * @private\n     */\n    onElementMouseOut(event) {\n        super.onElementMouseOut(event);\n\n        const\n            me = this,\n            { target, relatedTarget } = event,\n            eventInner                = target.closest(me.eventInnerSelector),\n            eventWrap                 = target.closest(me.eventSelector),\n            timeSpanRecord            = me.resolveTimeSpanRecord(target);\n\n        // We must be over the event bar\n        // TODO this isDragging check should be done in the feature (all drag/resize features actually) and here we should have a hook call\n        if (eventInner && timeSpanRecord && me.hoveredEvents.has(eventWrap) && !me.features.eventDrag?.isDragging) {\n            // out to child shouldn't count...\n            if (relatedTarget && DomHelper.isDescendant(eventInner, relatedTarget)) {\n                return;\n            }\n\n            me.unhover(eventWrap, event);\n        }\n    }\n\n    unhover(element, event) {\n        const me = this;\n\n        element.classList.remove(me.overScheduledEventClass);\n        me.trigger(`${me.scheduledEventName}MouseLeave`, me.getTimeSpanMouseEventParams(element, event));\n        me.hoveredEvents.delete(element);\n    }\n\n    unhoverAll(event) {\n        for (const element of this.hoveredEvents) {\n            !element.isReleased && !element.classList.contains('b-released') && this.unhover(element, event);\n        }\n\n        // Might not be empty because of conditional unhover above\n        this.hoveredEvents.clear();\n    }\n\n    //endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\nimport PresetManager from '../../preset/PresetManager.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport PresetStore from '../../preset/PresetStore.js';\nimport DateHelper, { unitMagnitudes } from '../../../Core/helper/DateHelper.js';\n\n/**\n * @module Scheduler/view/mixin/TimelineViewPresets\n */\n\nconst\n    datesDiffer = (d1 = 0, d2 = 0) => d2 - d1;\n\n/**\n * View preset handling.\n *\n * A Scheduler's {@link #config-presets} are loaded with a default set of {@link Scheduler.preset.ViewPreset ViewPresets}\n * which are defined by the system in the {@link Scheduler.preset.PresetManager PresetManager}.\n *\n * The zooming feature works by reconfiguring the Scheduler with a new {@link Scheduler.preset.ViewPreset ViewPreset} selected\n * from the {@link #config-presets} store.\n *\n * {@link Scheduler.preset.ViewPreset ViewPresets} can be added and removed from the store to change the amount of available steps.\n * Range of zooming in/out can be also modified with {@link Scheduler.view.mixin.TimelineZoomable#config-maxZoomLevel} / {@link Scheduler.view.mixin.TimelineZoomable#config-minZoomLevel} properties.\n *\n * This mixin adds additional methods to the column : {@link Scheduler.view.mixin.TimelineZoomable#property-maxZoomLevel}, {@link Scheduler.view.mixin.TimelineZoomable#property-minZoomLevel}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomToLevel}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomIn},\n * {@link Scheduler.view.mixin.TimelineZoomable#function-zoomOut}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomInFull}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomOutFull}.\n *\n * **Notice**: Zooming is not supported when `forceFit` option is set to true for the Scheduler or for filtered timeaxis.\n *\n * @mixin\n */\nexport default Target => class TimelineViewPresets extends (Target || Base) {\n    static get $name() {\n        return 'TimelineViewPresets';\n    }\n\n    //region Default config\n\n    static get configurable() {\n        return {\n            /**\n             * A string key used to lookup a predefined {@link Scheduler.preset.ViewPreset} (e.g. 'weekAndDay', 'hourAndDay'),\n             * managed by {@link Scheduler.preset.PresetManager}. See {@link Scheduler.preset.PresetManager} for more information.\n             * Or a config object for a viewPreset.\n             *\n             * Options:\n             * - 'secondAndMinute'\n             * - 'minuteAndHour'\n             * - 'hourAndDay'\n             * - 'dayAndWeek'\n             * - 'dayAndMonth'\n             * - 'weekAndDay'\n             * - 'weekAndMonth',\n             * - 'monthAndYear'\n             * - 'year'\n             * - 'manyYears'\n             * - 'weekAndDayLetter'\n             * - 'weekDateAndMonth'\n             * - 'day'\n             * - 'week'\n             *\n             * If passed as a config object, the settings from the viewPreset with the provided `base` property will be used along\n             * with any overridden values in your object.\n             *\n             * To override:\n             * ```javascript\n             * viewPreset : {\n             *   base    : 'hourAndDay',\n             *   id      : 'myHourAndDayPreset',\n             *   headers : [\n             *       {\n             *           unit      : \"hour\",\n             *           increment : 12,\n             *           renderer  : (startDate, endDate, headerConfig, cellIdx) => {\n             *               return \"\";\n             *           }\n             *       }\n             *   ]\n             * }\n             * ```\n             * or set a new valid preset config if the preset is not registered in the {@link Scheduler.preset.PresetManager}.\n             *\n             * When you use scheduler in weekview mode, this config is used to pick view preset. If passed view preset is not\n             * supported by weekview (only 2 supported by default - 'day' and 'week') default preset will be used - 'week'.\n             * @config {String|ViewPresetConfig}\n             * @default\n             * @category Common\n             */\n            viewPreset : 'weekAndDayLetter',\n\n            /**\n             * Get the {@link Scheduler.preset.PresetStore} created for the Scheduler,\n             * or set an array of {@link Scheduler.preset.ViewPreset} config objects.\n             * @member {Scheduler.preset.PresetStore|ViewPresetConfig[]} presets\n             * @category Common\n             */\n            /**\n             * An array of {@link Scheduler.preset.ViewPreset} config objects\n             * which describes the available timeline layouts for this scheduler.\n             *\n             * By default, a predefined set is loaded from the {@link Scheduler.preset.PresetManager}.\n             *\n             * A {@link Scheduler.preset.ViewPreset} describes the granularity of the\n             * timeline view and the layout and subdivisions of the timeline header.\n             * @config {ViewPresetConfig[]} presets\n             *\n             * @category Common\n             */\n            presets : true,\n\n            /**\n             * Defines how dates will be formatted in tooltips etc. This config has priority over similar config on the\n             * view preset. For allowed values see {@link Core.helper.DateHelper#function-format-static}.\n             * @config {String}\n             * @category Scheduled events\n             */\n            displayDateFormat : null\n        };\n    }\n\n    //endregion\n\n    /**\n     * Get/set the current view preset\n     * @member {Scheduler.preset.ViewPreset|String} viewPreset\n     * @param [viewPreset.options]\n     * @param {Date} [viewPreset.options.startDate] A new start date for the time axis\n     * @param {Date} [viewPreset.options.endDate] A new end date for the time axis\n     * @param {Date} [viewPreset.options.centerDate] Where to center the new time axis\n     * @category Common\n    */\n\n    //region Get/set\n\n    changePresets(presets) {\n        const config = {\n            owner : this\n        };\n        let data = [];\n\n        // By default includes all presets\n        if (presets === true) {\n            data = PresetManager.allRecords;\n        }\n        // Accepts an array of presets\n        else if (Array.isArray(presets)) {\n            for (const preset of presets) {\n                // If we got a presetId\n                if (typeof preset === 'string') {\n                    const presetRecord = PresetManager.getById(preset);\n                    if (presetRecord) {\n                        data.push(presetRecord);\n                    }\n                }\n                else {\n                    data.push(preset);\n                }\n            }\n        }\n        // Or a store config object\n        else {\n            ObjectHelper.assign(config, presets);\n        }\n        // Creates store first and then adds data, because data config does not support a mix of raw objects and records.\n        const presetStore = new PresetStore(config);\n        presetStore.add(data);\n\n        return presetStore;\n    }\n\n    changeViewPreset(viewPreset, oldViewPreset) {\n        const\n            me           = this,\n            { presets } = me;\n\n        if (viewPreset) {\n            viewPreset = presets.createRecord(viewPreset);\n\n            // If an existing ViewPreset id is used, this will replace it.\n            presets.add(viewPreset);\n        }\n        else {\n            viewPreset = presets.first;\n        }\n\n        const\n            lastOpts = me.lastViewPresetOptions || {},\n            options  = viewPreset.options || (viewPreset.options = {}),\n            event    = options.event = {\n                startDate : options.startDate,\n                endDate   : options.endDate,\n                from      : oldViewPreset,\n                to        : viewPreset,\n                preset    : viewPreset\n            },\n            presetChanged  = !me._viewPreset || !me._viewPreset.equals(viewPreset),\n            optionsChanged = datesDiffer(options.startDate, lastOpts.startDate) ||\n                datesDiffer(options.endDate, lastOpts.endDate) ||\n                datesDiffer(options.centerDate, lastOpts.centerDate) ||\n                (options.startDate && datesDiffer(options.startDate, me.startDate)) ||\n                (options.endDate && datesDiffer(options.endDate, me.endDate));\n\n        // Only return the value for onward processing if there's a change\n        if (presetChanged || optionsChanged) {\n\n            // Bypass the no-change check if the viewPreset is the same and we only got in here\n            // because different options were asked for.\n            if (!presetChanged) {\n                me._viewPreset = null;\n            }\n\n            /**\n             * Fired before the {@link #config-viewPreset} is changed.\n             * @event beforePresetChange\n             * @param {Scheduler.view.Scheduler} source This Scheduler instance.\n             * @param {Date} startDate The new start date of the timeline.\n             * @param {Date} endDate The new end date of the timeline.\n             * @param {Scheduler.preset.ViewPreset} from The outgoing ViewPreset.\n             * @param {Scheduler.preset.ViewPreset} to The ViewPreset being switched to.\n             * @preventable\n             */\n            // Do not trigger events for the initial preset\n            if (me.isConfiguring || me.trigger('beforePresetChange', event) !== false) {\n                return viewPreset;\n            }\n        }\n    }\n\n    get displayDateFormat() {\n        return this._displayDateFormat || this.viewPreset.displayDateFormat;\n    }\n\n    updateViewPreset(preset) {\n        const\n            me          = this,\n            { options } = preset,\n            {\n                event,\n                startDate,\n                endDate\n            }           = options,\n            {\n                isHorizontal,\n                _timeAxis : timeAxis,    // Do not tickle the getter, we are just peeking to see if it's there yet.\n                _timeAxisViewModel : timeAxisViewModel // Ditto\n            } = me;\n\n        let\n            {\n                centerDate,\n                zoomDate,\n                zoomPosition\n            }           = options,\n            forceUpdate = false;\n\n        // Raise flag to prevent partner from changing view preset if one is in progress\n        me._viewPresetChanging = true;\n\n        if (timeAxis && !me.isConfiguring) {\n            // Cache options only when they are applied so that non-change vetoing in changeViewPreset is accurate\n            me.lastViewPresetOptions = options;\n\n            // Timeaxis may already be configured (in case of sharing with the timeline partner), no need to reconfigure it\n            if (timeAxis.isConfigured) {\n                // None of this reconfiguring should cause a refresh\n                me.suspendRefresh();\n\n                // Set up these configs only if we actually have them.\n                const timeAxisCfg = ObjectHelper.copyProperties({}, me, [\n                    'weekStartDay',\n                    'startTime',\n                    'endTime'\n                ]);\n\n                if (me.infiniteScroll) {\n                    Object.assign(timeAxisCfg, timeAxisViewModel.calculateInfiniteScrollingDateRange(\n                        centerDate || new Date((startDate.getTime() + endDate.getTime()) / 2),\n                        true,\n                        preset\n                    ));\n                }\n                // if startDate is provided we use it and the provided endDate\n                else if (startDate) {\n                    timeAxisCfg.startDate = startDate;\n                    timeAxisCfg.endDate = endDate;\n\n                    // if both dates are provided we can calculate centerDate for the viewport\n                    if (!centerDate && endDate) {\n                        centerDate = new Date((startDate.getTime() + endDate.getTime()) / 2);\n                    }\n\n                    // when no start/end dates are provided we use the current timespan\n                }\n                else {\n                    timeAxisCfg.startDate = timeAxis.startDate;\n                    timeAxisCfg.endDate = endDate || timeAxis.endDate;\n\n                    if (!centerDate) {\n                        centerDate = me.viewportCenterDate;\n                    }\n                }\n\n                timeAxis.isConfigured = false;\n                timeAxis.viewPreset = preset;\n                timeAxis.reconfigure(timeAxisCfg, true);\n\n                timeAxisViewModel.reconfigure({\n                    viewPreset : preset,\n                    headers    : preset.headers,\n\n                    // This was hardcoded to 'middle' prior to the Preset refactor.\n                    // In the old code, the default headers were 'top' and 'middle', which\n                    // meant that 'middle' meant the lowest header.\n                    // So this is now length - 1.\n                    columnLinesFor : preset.columnLinesFor != null ? preset.columnLinesFor : preset.headers.length - 1,\n\n                    tickSize : isHorizontal ? preset.tickWidth : preset.tickHeight || preset.tickWidth || 60\n                });\n\n                // Allow refresh to run after the reconfiguring, without refreshing since we will do that below anyway\n                me.resumeRefresh(false);\n            }\n\n            me.refresh();\n\n            // if view is rendered and scroll is not disabled by \"notScroll\" option\n            if (!options.notScroll && me.isPainted) {\n                // If a zoom at a certain date position is being requested, scroll the zoomDate\n                // to the required zoomPosition so that the zoom happens centered where the\n                // pointer events that re driving it a targeted.\n                if (zoomDate && zoomPosition) {\n                    const\n                        unitMagnitude = unitMagnitudes[timeAxis.resolutionUnit],\n                        unit          = unitMagnitude > 3 ? 'hour' : 'minute',\n                        milliseconds  = DateHelper.asMilliseconds((unit === 'minute' ? 15 : 1), unit),\n                        // Round the date to either 15 minutes for fine levels or 1 hour for coarse levels\n                        targetDate    = new Date(Math.round(zoomDate / milliseconds) * milliseconds);\n\n                    // setViewPreset method on partner panels should be executed with same arguments.\n                    // if one partner was provided with zoom info, other one has to be too to generate exact\n                    // header and set same scroll\n                    event.zoomDate = zoomDate;\n                    event.zoomPosition = zoomPosition;\n                    event.zoomLevel = options.zoomLevel;\n\n                    me.timelineScroller.scrollBy(me.getCoordinateFromDate(targetDate) - zoomPosition);\n                }\n                // and we have centerDate to scroll to\n                else if (centerDate) {\n                    // remember the central date we scroll to (it gets reset after user scroll)\n                    me.cachedCenterDate = centerDate;\n\n                    // setViewPreset method on partner panels should be executed with same arguments.\n                    // if one partner was provided with a centerDate, other one has to be too to generate exact\n                    // header and set same scroll\n                    event.centerDate = centerDate;\n\n                    const\n                        viewportSize = me.timelineScroller.clientSize,\n                        coord        = Math.max(me.getCoordinateFromDate(centerDate, true) - viewportSize / 2, 0);\n\n                    // The horizontal scroll handler must not invalidate the cached center\n                    // when this scroll event rolls round on the next frame.\n                    me.scrollingToCenter = true;\n\n                    // If preset change does not lead to a scroll we have to \"refresh\" manually at the end\n                    if (coord === (me.isHorizontal ? me.scrollLeft : me.scrollTop)) {\n                        forceUpdate = true;\n                    }\n                    else if (me.isHorizontal) {\n                        me.scrollHorizontallyTo(coord, false);\n                    }\n                    else {\n                        me.scrollVerticallyTo(coord, false);\n                    }\n\n                    // Release the lock on scrolling invalidating the cached center.\n                    me.setTimeout(() => {\n                        me.scrollingToCenter = false;\n                    }, 100);\n                }\n                else {\n                    // If preset change does not lead to a scroll we have to \"refresh\" manually at the end\n                    if ((me.isHorizontal ? me.scrollLeft : me.scrollTop) === 0) {\n                        forceUpdate = true;\n                    }\n                    // If we don't have a center date to scroll to, we reset scroll (this is bw compatible behavior)\n                    else {\n                        me.timelineScroller.scrollTo(0);\n                    }\n                }\n            }\n        }\n\n        // Update Scheduler element showing what preset is applied\n        me.dataset.presetId = preset.id;\n\n        /**\n         * Fired after the {@link #config-viewPreset} has changed.\n         * @event presetChange\n         * @param {Scheduler.view.Scheduler} source This Scheduler instance.\n         * @param {Date} startDate The new start date of the timeline.\n         * @param {Date} centerDate The new center date of the timeline.\n         * @param {Date} endDate The new end date of the timeline.\n         * @param {Scheduler.preset.ViewPreset} from The outgoing ViewPreset.\n         * @param {Scheduler.preset.ViewPreset} to The ViewPreset being switched to.\n         * @preventable\n         */\n        me.trigger('presetChange', event);\n\n        me._viewPresetChanging = false;\n\n        if (forceUpdate) {\n            if (me.isHorizontal) {\n                me.currentOrientation.updateFromHorizontalScroll(me.scrollLeft, me.scrollX);\n            }\n            else {\n                me.currentOrientation.updateFromVerticalScroll(me.scrollTop);\n            }\n        }\n    }\n\n    //endregion\n\n    doDestroy() {\n        if (this._presets.owner === this) {\n            this._presets.destroy();\n        }\n        super.doDestroy();\n    }\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n\n        // Cannot store name, will not be allowed when reapplying\n        if (result.viewPreset && result.viewPreset.name && !result.viewPreset.base) {\n            delete result.viewPreset.name;\n        }\n\n        return result;\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\n\n/**\n * @module Scheduler/view/mixin/TimelineZoomable\n */\n\n/**\n * Mixin providing \"zooming\" functionality.\n *\n * The zoom levels are stored as instances of {@link Scheduler.preset.ViewPreset ViewPreset}s, and are\n * cached centrally in the {@link Scheduler.preset.PresetManager PresetManager}.\n *\n * The default presets are loaded into the {@link Scheduler.view.mixin.TimelineViewPresets#config-presets}\n * store upon Scheduler instantiation. Preset selection is covered in the\n * {@link Scheduler.view.mixin.TimelineViewPresets TimelineViewPresets} mixin.\n *\n * To specify custom zoom levels please provide a set of view presets to the global PresetManager store **before** scheduler creation,\n * or provide a set of view presets to a specific scheduler only:\n *\n * ```javascript\n * const myScheduler = new Scheduler({\n *     presets : [\n *         {\n *             base : 'hourAndDay',\n *             id   : 'MyHourAndDay',\n *             // other preset configs....\n *         },\n *         {\n *             base : 'weekAndMonth',\n *             id   : 'MyWeekAndMonth',\n *             // other preset configs....\n *         }\n *     ],\n *     viewPreset : 'MyHourAndDay',\n *     // other scheduler configs....\n *     });\n * ```\n *\n * @mixin\n */\nexport default Target => class TimelineZoomable extends (Target || Base) {\n    static get $name() {\n        return 'TimelineZoomable';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * If true, you can zoom in and out on the the time axis using CTRL-key + mouse wheel.\n             * @config {Boolean}\n             * @default\n             * @category Zoom\n             */\n            zoomOnMouseWheel : true,\n\n            /**\n             * True to zoom to time span when double clicking a time axis cell.\n             * @config {Boolean}\n             * @default\n             * @category Zoom\n             */\n            zoomOnTimeAxisDoubleClick : true,\n\n            /**\n             * The minimum zoom level to which {@link #function-zoomOut} will work. Defaults to 0 (year ticks)\n             * @config {Number}\n             * @category Zoom\n             * @default\n             */\n            minZoomLevel : 0,\n\n            /**\n             * The maximum zoom level to which {@link #function-zoomIn} will work. Defaults to the number of\n             * {@link Scheduler.preset.ViewPreset ViewPresets} available, see {@link Scheduler/view/mixin/TimelineViewPresets#property-presets}\n             * for information. Unless you have modified the collection of available presets, the max zoom level is milliseconds.\n             * @config {Number}\n             * @category Zoom\n             * @default 23\n             */\n            maxZoomLevel : null,\n\n            /**\n             * Integer number indicating the size of timespan during zooming. When zooming, the timespan is adjusted to make the scrolling area `visibleZoomFactor` times\n             * wider than the timeline area itself. Used in {@link #function-zoomToSpan} and {@link #function-zoomToLevel} functions.\n             * @config {Number}\n             * @default\n             * @category Zoom\n             */\n            visibleZoomFactor : 5,\n\n            /**\n             * Whether the originally rendered timespan should be preserved while zooming. By default it is set to `false`,\n             * meaning the timeline panel will adjust the currently rendered timespan to limit the amount of HTML content to render. When setting this option\n             * to `true`, be careful not to allow to zoom a big timespan in seconds resolution for example. That will cause **a lot** of HTML content\n             * to be rendered and affect performance. You can use {@link #config-minZoomLevel} and {@link #config-maxZoomLevel} config options for that.\n             * @config {Boolean}\n             * @default\n             * @category Zoom\n             */\n            zoomKeepsOriginalTimespan : null\n        };\n    }\n\n    // We cache the last mousewheel position, so that during zooming we can\n    // maintain a stable zoom point even if the mouse moves a little.\n    lastWheelTime = -1;\n    lastZoomPosition = -1;\n\n    construct(config) {\n        const me = this;\n\n        super.construct(config);\n\n        if (me.zoomOnMouseWheel) {\n            EventHelper.on({\n                element   : me.timeAxisSubGridElement,\n                wheel     : 'onWheel',\n                // Throttle zooming with the wheel a bit to have greater control of it\n                throttled : {\n                    buffer : 100,\n                    // Prevent events from slipping through the throttle, causing scroll\n                    alt    : e => e.ctrlKey && e.preventDefault()\n                },\n                thisObj : me,\n                capture : true,\n                passive : false\n            });\n        }\n\n        if (me.zoomOnTimeAxisDoubleClick) {\n            me.ion({\n                timeaxisheaderdblclick : ({ startDate, endDate }) => {\n                    me.zoomToSpan({\n                        startDate,\n                        endDate\n                    });\n                }\n            });\n        }\n    }\n\n    get maxZoomLevel() {\n        return this._maxZoomLevel || (this.presets.count - 1);\n    }\n\n    /**\n     * Get/set the {@link #config-maxZoomLevel} value\n     * @property {Number}\n     * @category Zoom\n     */\n    set maxZoomLevel(level) {\n        if (typeof level !== 'number') {\n            level = this.presets.count - 1;\n        }\n\n        if (level < 0 || level >= this.presets.count) {\n            throw new Error('Invalid range for `maxZoomLevel`');\n        }\n\n        this._maxZoomLevel = level;\n    }\n\n    get minZoomLevel() {\n        return this._minZoomLevel;\n    }\n\n    /**\n     * Sets the {@link #config-minZoomLevel} value\n     * @property {Number}\n     * @category Zoom\n     */\n    set minZoomLevel(level) {\n        if (typeof level !== 'number') {\n            level = 0;\n        }\n\n        if (level < 0 || level >= this.presets.count) {\n            throw new Error('Invalid range for `minZoomLevel`');\n        }\n\n        this._minZoomLevel = level;\n    }\n\n    /**\n     * Current zoom level, which is equal to the {@link Scheduler.preset.ViewPreset ViewPreset} index\n     * in the provided array of {@link Scheduler.view.mixin.TimelineViewPresets#config-presets zoom levels}.\n     * @property {Number}\n     * @category Zoom\n     */\n    get zoomLevel() {\n        return this.presets.indexOf(this.viewPreset);\n    }\n\n    // noinspection JSAnnotator\n    set zoomLevel(level) {\n        this.zoomToLevel(level);\n    }\n\n    /**\n     * Returns number of milliseconds per pixel.\n     * @param {Object} level Element from array of {@link Scheduler.view.mixin.TimelineViewPresets#config-presets}.\n     * @param {Boolean} ignoreActualWidth If true, then density will be calculated using default zoom level settings.\n     * Otherwise density will be calculated for actual tick width.\n     * @returns {Number} Return number of milliseconds per pixel.\n     * @private\n     */\n    getMilliSecondsPerPixelForZoomLevel(preset, ignoreActualWidth) {\n        const\n            { bottomHeader } = preset,\n            // Scheduler uses direction independent tickSize, but presets are allowed to define different sizes for\n            // vertical and horizontal -> cant use preset.tickSize here\n            width            = this.isHorizontal ? preset.tickWidth : preset.tickHeight;\n\n        // trying to convert the unit + increment to a number of milliseconds\n        // this number is not fixed (month can be 28, 30 or 31 day), but at least this conversion\n        // will be consistent (should be no DST changes at year 1)\n        return Math.round(\n            (DateHelper.add(new Date(1, 0, 1), bottomHeader.increment || 1, bottomHeader.unit) - new Date(1, 0, 1)) /\n            // `actualWidth` is a column width after view adjustments applied to it (see `calculateTickWidth`)\n            // we use it if available to return the precise index value from `getCurrentZoomLevelIndex`\n            (ignoreActualWidth ? width : preset.actualWidth || width)\n        );\n    }\n\n    /**\n     * Zooms to passed view preset, saving center date. Method accepts config object as a first argument, which can be\n     * reduced to primitive type (string,number) when no additional options required. e.g.:\n     * ```\n     * // zooming to preset\n     * scheduler.zoomTo({ preset : 'hourAndDay' })\n     * // shorthand\n     * scheduler.zoomTo('hourAndDay')\n     *\n     * // zooming to level\n     * scheduler.zoomTo({ level : 0 })\n     * // shorthand\n     * scheduler.zoomTo(0)\n     * ```\n     *\n     * It is also possible to zoom to a time span by omitting `preset` and `level` configs, in which case scheduler sets\n     * the time frame to a specified range and applies zoom level which allows to fit all columns to this range. The\n     * given time span will be centered in the scheduling view (unless `centerDate` config provided). In the same time,\n     * the start/end date of the whole time axis will be extended to allow scrolling for user.\n     * ```\n     * // zooming to time span\n     * scheduler.zoomTo({\n     *     startDate : new Date(..),\n     *     endDate : new Date(...)\n     * });\n     *\n     * ```\n     *\n     * @param {Object|String|Number} config Config object, preset name or zoom level index.\n     * @param {String} config.preset Preset name to zoom to. Ignores level config in this case\n     * @param {Number} config.level Zoom level to zoom to. Is ignored, if preset config is provided\n     * @param {Date} config.startDate New time frame start. If provided along with end, view will be centered in this time\n     * interval (unless `centerDate` is present)\n     * @param {Date} config.endDate New time frame end\n     * @param {Date} config.centerDate Date that should be kept in the center. Has priority over start and end params\n     * @param {Date} config.zoomDate The date that should be positioned at the passed `datePosition` client offset.\n     * @param {Number} config.zoomPosition The client offset at which the passed `date` should be positioned.\n     * @param {Number} config.width Lowest tick width. Might be increased automatically\n     * @param {Number} [config.leftMargin] Amount of pixels to extend span start on (used, when zooming to span)\n     * @param {Number} [config.rightMargin] Amount of pixels to extend span end on (used, when zooming to span)\n     * @param {Number} [config.adjustStart] Amount of units to extend span start on (used, when zooming to span)\n     * @param {Number} [config.adjustEnd] Amount of units to extend span end on (used, when zooming to span)\n     * @category Zoom\n     */\n    zoomTo(config) {\n        const me = this;\n\n        if (typeof config === 'object') {\n            if (config.preset) {\n                me.zoomToLevel(config.preset, config);\n            }\n            else if (config.level != null) {\n                me.zoomToLevel(config.level, config);\n            }\n            else {\n                me.zoomToSpan(config);\n            }\n        }\n        else {\n            me.zoomToLevel(config);\n        }\n    }\n\n    /**\n     * Allows zooming to certain level of {@link Scheduler.view.mixin.TimelineViewPresets#config-presets} array. Automatically limits zooming between {@link #config-maxZoomLevel}\n     * and {@link #config-minZoomLevel}. Can also set time axis timespan to the supplied start and end dates.\n     *\n     * @param {Number} preset Level to zoom to.\n     * @param {Object} [options] Object, containing options for this method\n     * @param {Date} options.startDate New time frame start. If provided along with end, view will be centered in this time\n     * interval, ignoring centerDate config.\n     * @param {Date} options.endDate New time frame end.\n     * @param {Date} options.centerDate Date that should be kept in center. Is ignored when start and end are provided.\n     * @param {Date} options.zoomDate The date that should be positioned at the passed `datePosition` client offset.\n     * @param {Number} options.zoomPosition The client offset at which the passed `date` should be positioned.\n     * @param {Number} options.width Lowest tick width. Might be increased automatically\n     * @returns {Number|null} level Current zoom level or null if it hasn't changed.\n     * @category Zoom\n     */\n    zoomToLevel(preset, options = {}) {\n        // Sanitize numeric zooming.\n        if (typeof preset === 'number') {\n            preset = Math.min(Math.max(preset, this.minZoomLevel), this.maxZoomLevel);\n        }\n\n        const\n            me                 = this,\n            { presets }       = me,\n            tickSizeProp       = me.isVertical ? 'tickHeight' : 'tickWidth',\n            newPreset          = presets.createRecord(preset),\n            configuredTickSize = newPreset[tickSizeProp],\n            startDate          = options.startDate ? new Date(options.startDate) : null,\n            endDate            = options.endDate ? new Date(options.endDate) : null;\n\n        // If an existing ViewPreset id is used, this will replace it.\n        presets.add(newPreset);\n\n        let span = startDate && endDate ? { startDate, endDate } : null;\n\n        const\n            centerDate             = options.centerDate ? new Date(options.centerDate) : (span ? new Date((startDate.getTime() + endDate.getTime()) / 2) : me.viewportCenterDateCached),\n            scrollableViewportSize = me.isVertical ? me.scrollable.clientHeight : me.timeAxisSubGrid.width;\n\n        if (scrollableViewportSize === 0) {\n            return null;\n        }\n\n        // Always calculate an optimal date range for the new zoom level\n        if (!span) {\n            span = me.calculateOptimalDateRange(centerDate, scrollableViewportSize, newPreset);\n        }\n\n        // Temporarily override tick size while reconfiguring the TimeAxisViewModel\n        if ('width' in options) {\n            newPreset.setData(tickSizeProp, options.width);\n        }\n\n        me.isZooming = true;\n\n        // Passed through to the viewPreset changing method\n        newPreset.options = {\n            ...options,\n            startDate : span.startDate || me.startDate,\n            endDate   : span.endDate || me.endDate,\n            centerDate\n        };\n        me.viewPreset = newPreset;\n\n        // after switching the view preset the `width` config of the zoom level may change, because of adjustments\n        // we will save the real value in the `actualWidth` property, so that `getCurrentZoomLevelIndex` method\n        // will return the exact level index after zooming\n        newPreset.actualWidth = me.timeAxisViewModel.tickSize;\n\n        me.isZooming = false;\n\n        // Restore the tick size because the default presets are shared.\n        newPreset.setData(tickSizeProp, configuredTickSize);\n\n        return me.zoomLevel;\n    }\n\n    /**\n     * Changes the range of the scheduling chart to fit all the events in its event store.\n     * @param {Object} [options] Options object for the zooming operation.\n     * @param {Number} [options.leftMargin] Defines margin in pixel between the first event start date and first visible date\n     * @param {Number} [options.rightMargin] Defines margin in pixel between the last event end date and last visible date\n     */\n    zoomToFit(options) {\n        const eventStore = this.eventStore,\n            span       = eventStore.getTotalTimeSpan();\n\n        options = {\n            leftMargin  : 0,\n            rightMargin : 0,\n            ...options,\n            ...span\n        };\n\n        // Make sure we received a time span, event store might be empty\n        if (options.startDate && options.endDate) {\n            if (options.endDate > options.startDate) {\n                this.zoomToSpan(options);\n            }\n            else {\n                // If we only had a zero time span, just scroll it into view\n                this.scrollToDate(options.startDate);\n            }\n        }\n    }\n\n    /**\n     * Sets time frame to specified range and applies zoom level which allows to fit all columns to this range.\n     *\n     * The given time span will be centered in the scheduling view, in the same time, the start/end date of the whole time axis\n     * will be extended in the same way as {@link #function-zoomToLevel} method does, to allow scrolling for user.\n     *\n     * @param {Object} config The time frame.\n     * @param {Date} config.startDate The time frame start.\n     * @param {Date} config.endDate The time frame end.\n     * @param {Date} [config.centerDate] Date that should be kept in the center. Has priority over start and end params\n     * @param {Number} [config.leftMargin] Amount of pixels to extend span start on\n     * @param {Number} [config.rightMargin] Amount of pixels to extend span end on\n     * @param {Number} [config.adjustStart] Amount of units to extend span start on\n     * @param {Number} [config.adjustEnd] Amount of units to extend span end on\n     *\n     * @returns {Number|null} level Current zoom level or null if it hasn't changed.\n     * @category Zoom\n     */\n    zoomToSpan(config = {}) {\n        if (config.leftMargin || config.rightMargin) {\n            config.adjustStart = 0;\n            config.adjustEnd = 0;\n        }\n\n        if (!config.leftMargin) config.leftMargin = 0;\n        if (!config.rightMargin) config.rightMargin = 0;\n\n        if (!config.startDate || !config.endDate) throw new Error('zoomToSpan: must provide startDate + endDate dates');\n\n        const\n            me           = this,\n            { timeAxis } = me,\n            // this config enables old zoomToSpan behavior which we want to use for zoomToFit in Gantt\n            needToAdjust = config.adjustStart >= 0 || config.adjustEnd >= 0;\n\n        let {\n            startDate,\n            endDate\n        } = config;\n\n        if (needToAdjust) {\n            startDate = DateHelper.add(startDate, -config.adjustStart, timeAxis.mainUnit);\n            endDate   = DateHelper.add(endDate, config.adjustEnd, timeAxis.mainUnit);\n        }\n\n        if (startDate <= endDate) {\n            // get scheduling view width\n            const\n                { availableSpace } = me.timeAxisViewModel,\n                presets = me.presets.allRecords,\n                diffMS  = endDate - startDate || 1;\n\n            // if potential width of col is less than col width provided by zoom level\n            //   - we'll zoom out panel until col width fit into width from zoom level\n            // and if width of column is more than width from zoom level\n            //   - we'll zoom in until col width fit won't fit into width from zoom level\n\n            let currLevel = me.zoomLevel,\n                inc, range;\n\n            // if we zoomed out even more than the highest zoom level - limit it to the highest zoom level\n            if (currLevel === -1) currLevel = 0;\n\n            let msPerPixel             = me.getMilliSecondsPerPixelForZoomLevel(presets[currLevel], true),\n                // increment to get next zoom level:\n                // -1 means that given timespan won't fit the available width in the current zoom level, we need to zoom out,\n                // so that more content will \"fit\" into 1 px\n                //\n                // +1 mean that given timespan will already fit into available width in the current zoom level, but,\n                // perhaps if we'll zoom in a bit more, the fitting will be better\n                candidateLevel         = currLevel + (inc = diffMS / msPerPixel + config.leftMargin + config.rightMargin > availableSpace ? -1 : 1),\n                zoomLevel, levelToZoom = null;\n\n            // loop over zoom levels\n            while (candidateLevel >= 0 && candidateLevel <= presets.length - 1) {\n                // get zoom level\n                zoomLevel = presets[candidateLevel];\n\n                msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);\n                const spanWidth = diffMS / msPerPixel + config.leftMargin + config.rightMargin;\n\n                // if zooming out\n                if (inc === -1) {\n                    // if columns fit into available space, then all is fine, we've found appropriate zoom level\n                    if (spanWidth <= availableSpace) {\n                        levelToZoom = candidateLevel;\n                        // stop searching\n                        break;\n                    }\n                    // if zooming in\n                }\n                else {\n                    // if columns still fits into available space, we need to remember the candidate zoom level as a potential\n                    // resulting zoom level, the indication that we've found correct zoom level will be that timespan won't fit\n                    // into available view\n                    if (spanWidth <= availableSpace) {\n                        // if it's not currently active level\n                        if (currLevel !== candidateLevel - inc) {\n                            // remember this level as applicable\n                            levelToZoom = candidateLevel;\n                        }\n                    }\n                    else {\n                        // Sanity check to find the following case:\n                        // If we're already zoomed in at the appropriate level, but the current zoomLevel is \"too small\" to fit and had to be expanded,\n                        // there is an edge case where we should actually just stop and use the currently selected zoomLevel\n                        break;\n                    }\n                }\n\n                candidateLevel += inc;\n            }\n\n            // If we didn't find a large/small enough zoom level, use the lowest/highest level\n            levelToZoom = levelToZoom != null ? levelToZoom : candidateLevel - inc;\n\n            // presets is the array of all ViewPresets this Scheduler is using\n            zoomLevel = presets[levelToZoom];\n\n            const unitToZoom = zoomLevel.bottomHeader.unit;\n\n            // Extract the correct msPerPixel value for the new zoom level\n            msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);\n\n            if (config.leftMargin || config.rightMargin) {\n                // time axis doesn't yet know about new view preset (zoom level) so it cannot round/ceil date correctly\n                startDate = new Date(startDate.getTime() - msPerPixel * config.leftMargin);\n                endDate   = new Date(endDate.getTime() + msPerPixel * config.rightMargin);\n            }\n\n            const tickCount = DateHelper.getDurationInUnit(startDate, endDate, unitToZoom, true) / zoomLevel.bottomHeader.increment;\n\n            if (tickCount === 0) {\n                return null;\n            }\n\n            const\n                customWidth = Math.floor(availableSpace / tickCount),\n                centerDate  = config.centerDate || new Date((startDate.getTime() + endDate.getTime()) / 2);\n\n            if (needToAdjust) {\n                range = {\n                    startDate,\n                    endDate\n                };\n            }\n            else {\n                range = me.calculateOptimalDateRange(centerDate, availableSpace, zoomLevel);\n            }\n\n            let result = me.zoomLevel;\n\n            // No change of zoom level needed, just move to the date range\n            if (me.zoomLevel === levelToZoom) {\n                timeAxis.reconfigure(range);\n            }\n            else {\n                result = me.zoomToLevel(levelToZoom,\n                    Object.assign(range, {\n                        width : customWidth,\n                        centerDate\n                    })\n                );\n            }\n\n            if (me.infiniteScroll) {\n                me.scrollToDate(startDate, { block : 'start' });\n            }\n\n            return result;\n        }\n\n        return null;\n    }\n\n    /**\n     * Zooms in the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view will zoom in by this value.\n     * Otherwise a value of `1` will be used.\n     *\n     * @param {Number} levels (optional) amount of levels to zoom in\n     * @param {Object} [options] Object, containing options for this method\n     * @param {Date} options.startDate New time frame start. If provided along with end, view will be centered in this time\n     * interval, ignoring centerDate config.\n     * @param {Date} options.endDate New time frame end.\n     * @param {Date} options.centerDate Date that should be kept in center. Is ignored when start and end are provided.\n     * @param {Date} options.zoomDate The date that should be positioned at the passed `datePosition` client offset.\n     * @param {Number} options.zoomPosition The client offset at which the passed `date` should be positioned.\n     * @param {Number} options.width Lowest tick width. Might be increased automatically\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomIn(levels = 1, options) {\n        const currentZoomLevelIndex = this.zoomLevel;\n\n        if (currentZoomLevelIndex >= this.maxZoomLevel) {\n            return null;\n        }\n\n        return this.zoomToLevel(currentZoomLevelIndex + levels, options);\n    }\n\n    /**\n     * Zooms out the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view will zoom out by this value.\n     * Otherwise a value of `1` will be used.\n     *\n     * @param {Number} levels (optional) amount of levels to zoom out\n     * @param {Object} [options] Object, containing options for this method\n     * @param {Date} options.startDate New time frame start. If provided along with end, view will be centered in this time\n     * interval, ignoring centerDate config.\n     * @param {Date} options.endDate New time frame end.\n     * @param {Date} options.centerDate Date that should be kept in center. Is ignored when start and end are provided.\n     * @param {Date} options.zoomDate The date that should be positioned at the passed `datePosition` client offset.\n     * @param {Number} options.zoomPosition The client offset at which the passed `date` should be positioned.\n     * @param {Number} options.width Lowest tick width. Might be increased automatically\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomOut(levels = 1, options) {\n        const currentZoomLevelIndex = this.zoomLevel;\n\n        if (currentZoomLevelIndex <= this.minZoomLevel) {\n            return null;\n        }\n\n        return this.zoomToLevel(currentZoomLevelIndex - levels, options);\n    }\n\n    /**\n     * Zooms in the timeline to the {@link #config-maxZoomLevel} according to the array of zoom levels.\n     *\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomInFull() {\n        return this.zoomToLevel(this.maxZoomLevel);\n    }\n\n    /**\n     * Zooms out the timeline to the {@link #config-minZoomLevel} according to the array of zoom levels.\n     *\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomOutFull() {\n        return this.zoomToLevel(this.minZoomLevel);\n    }\n\n    /*\n     * Adjusts the timespan of the panel to the new zoom level. Used for performance reasons,\n     * as rendering too many columns takes noticeable amount of time so their number is limited.\n     * @category Zoom\n     * @private\n     */\n    calculateOptimalDateRange(centerDate, viewportSize, viewPreset, userProvidedSpan) {\n        // this line allows us to always use the `calculateOptimalDateRange` method when calculating date range for zooming\n        // (even in case when user has provided own interval)\n        // other methods may override/hook into `calculateOptimalDateRange` to insert own processing\n        // (infinite scrolling feature does)\n        if (userProvidedSpan) return userProvidedSpan;\n\n        const\n            me               = this,\n            { timeAxis }     = me,\n            { bottomHeader } = viewPreset,\n            tickWidth        = me.isHorizontal ? viewPreset.tickWidth : viewPreset.tickHeight;\n\n        if (me.zoomKeepsOriginalTimespan) {\n            return {\n                startDate : timeAxis.startDate,\n                endDate   : timeAxis.endDate\n            };\n        }\n\n        const\n            unit       = bottomHeader.unit,\n            difference = Math.ceil(viewportSize / tickWidth * bottomHeader.increment * me.visibleZoomFactor / 2),\n            startDate  = DateHelper.add(centerDate, -difference, unit),\n            endDate    = DateHelper.add(centerDate, difference, unit);\n\n        if (me.infiniteScroll) {\n            return me.timeAxisViewModel.calculateInfiniteScrollingDateRange(centerDate, true);\n        }\n        else {\n            return {\n                startDate : timeAxis.floorDate(startDate, false, unit, bottomHeader.increment),\n                endDate   : timeAxis.ceilDate(endDate, false, unit, bottomHeader.increment)\n            };\n        }\n    }\n\n    onElementMouseMove(event) {\n        const\n            {\n                isHorizontal,\n                zoomContext\n            } = this;\n\n        super.onElementMouseMove(event);\n\n        if (event.isTrusted && zoomContext) {\n            // Invalidate the zoomContext if mouse has strayed away from it\n            if (Math.abs(event[`client${isHorizontal ? 'X' : 'Y'}`] - zoomContext.coordinate) > 10) {\n                this.zoomContext = null;\n            }\n        }\n    }\n\n    async onWheel(event) {\n        if (event.ctrlKey) {\n            event.preventDefault();\n\n            const\n                me           = this,\n                {\n                    zoomContext,\n                    isHorizontal,\n                    timelineScroller,\n                    zoomLevel\n                }            = me,\n                now          = performance.now(),\n                coordinate   = event[`client${isHorizontal ? 'X' : 'Y'}`],\n                zoomPosition = coordinate - timelineScroller.viewport[`${isHorizontal ? 'x' : 'y'}`] + timelineScroller.position;\n\n            // If we are in a fast-arriving stream of wheel events, we use the same zoomDate as last time.\n            // If it's a new zoom gesture or the pointer has strayed away from the context then ascertain\n            // the gesture's center date\n            if (now - me.lastWheelTime > 200 || !zoomContext || Math.abs(coordinate - me.zoomContext.coordinate) > 20) {\n                // We're creating a zoom gesture which lasts as long as the\n                // wheel events keep arriving at the same timeline position\n                me.zoomContext = {\n                    // So we can track if we're going in (to finer resolutions)\n                    zoomLevel,\n\n                    // Pointer client(X|Y)\n                    coordinate,\n\n                    // Full TimeAxis offset position at which to place the date\n                    zoomPosition,\n\n                    // The date to place at the position\n                    zoomDate : me.getDateFromDomEvent(event)\n                };\n            }\n            // Use the current zoomContext's zoomDate, but at each level, the relative position of that date\n            // in the TimeAxis has to be corrected as the TimeAxis grows and scrolls to keep the zoomPosition\n            // stable.\n            else {\n                // If we zoom in to a finer resolution, get a more accurate centering date.\n                // If gesture was started at a years/months level, the date will be inaccurate.\n                if (zoomLevel > zoomContext.zoomLevel) {\n                    zoomContext.zoomDate = me.getDateFromDomEvent(event);\n                    zoomContext.zoomLevel = zoomLevel;\n                }\n                zoomContext.zoomPosition = zoomPosition;\n            }\n\n            me.lastWheelTime = now;\n            me[`zoom${event.deltaY > 0 ? 'Out' : 'In'}`](undefined, me.zoomContext);\n        }\n    }\n\n    /**\n     * Changes the time axis timespan to the supplied start and end dates.\n     * @param {Date} startDate The new start date\n     * @param {Date} endDate The new end date. If omitted or equal to startDate, the {@link Scheduler.preset.ViewPreset#field-defaultSpan} property of the current view preset will be used to calculate the new end date.\n     */\n    setTimeSpan(startDate, endDate) {\n        this.timeAxis.setTimeSpan(startDate, endDate);\n    }\n\n    /**\n     * Moves the time axis by the passed amount and unit.\n     *\n     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shift} for more information.\n     *\n     * @param {Number} amount The number of units to jump\n     * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} [unit] The unit (Day, Week etc)\n     */\n    shift(amount, unit) {\n        this.timeAxis.shift(amount, unit);\n    }\n\n    /**\n     * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement`\n     * config of the current view preset.\n     *\n     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shiftNext} for more information.\n     *\n     * @param {Number} [amount] The number of units to jump forward\n     */\n    shiftNext(amount) {\n        this.timeAxis.shiftNext(amount);\n    }\n\n    /**\n     * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.\n     *\n     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shiftPrevious} for more information.\n     *\n     * @param {Number} [amount] The number of units to jump backward\n     */\n    shiftPrevious(amount) {\n        this.timeAxis.shiftPrevious(amount);\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Scheduler/view/mixin/TimelineEventRendering\n */\n\n/**\n * Functions to handle event rendering (EventModel -> dom elements).\n *\n * @mixin\n */\nexport default Target => class TimelineEventRendering extends (Target || Base) {\n    static get $name() {\n        return 'TimelineEventRendering';\n    }\n\n    //region Default config\n\n    static get defaultConfig() {\n        return {\n            resourceMargin : null,\n\n            /**\n             * When `true`, events are sized and positioned based on rowHeight, resourceMargin and barMargin settings.\n             * Set this to `false` if you want to control height and vertical position using CSS instead.\n             *\n             * Note that events always get an absolute top position, but when this setting is enabled that position\n             * will match row's top. To offset within the row using CSS, use `transform : translateY(y)`.\n             *\n             * @config {Boolean}\n             * @default\n             * @category Scheduled events\n             */\n            managedEventSizing : true,\n\n            /**\n             * The CSS class added to an event/assignment when it is newly created\n             * in the UI and unsynced with the server.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            generatedIdCls : 'b-sch-dirty-new',\n\n            /**\n             * The CSS class added to an event when it has unsaved modifications\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            dirtyCls : 'b-sch-dirty',\n\n            /**\n             * The CSS class added to an event when it is currently committing changes\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            committingCls : 'b-sch-committing',\n\n            /**\n             * The CSS class added to an event/assignment when it ends outside of the visible time range.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            endsOutsideViewCls : 'b-sch-event-endsoutside',\n\n            /**\n             * The CSS class added to an event/assignment when it starts outside of the visible time range.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            startsOutsideViewCls : 'b-sch-event-startsoutside',\n\n            /**\n             * The CSS class added to an event/assignment when it is not draggable.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            fixedEventCls : 'b-sch-event-fixed',\n\n            /**\n             * Event style used by default. Events and resources can specify their own style, with priority order being:\n             * Event -> Resource -> Scheduler default. Determines the appearance of the event by assigning a CSS class\n             * to it. Available styles are:\n             *\n             * * `'plain'` (default) - flat look\n             * * `'border'` - has border in darker shade of events color\n             * * `'colored'` - has colored text and wide left border in same color\n             * * `'hollow'` - only border + text until hovered\n             * * `'line'` - as a line with the text below it\n             * * `'dashed'` - as a dashed line with the text below it\n             * * `'minimal'` - as a thin line with small text above it\n             * * `'rounded'` - minimalistic style with rounded corners\n             *\n             * In addition, there are two styles intended to be used when integrating with Bryntum Calendar. To match\n             * the look of Calendar events, you can use:\n             *\n             * * `'calendar'` - a variation of the \"colored\" style matching the default style used by Calendar\n             * * `'interday'` - a variation of the \"plain\" style, for interday events\n             *\n             * Specify `null` to not apply a default style and take control using custom CSS (easily overridden basic\n             * styling will be used).\n             *\n             * @config {'plain'|'border'|'colored'|'hollow'|'line'|'dashed'|'minimal'|'rounded'|'calendar'|'interday'}\n             * @default\n             * @category Scheduled events\n             */\n            eventStyle : 'plain',\n\n            /**\n             * Event color used by default. Events and resources can specify their own color, with priority order being:\n             * Event -> Resource -> Scheduler default. Available colors are:\n             * * red\n             * * pink\n             * * purple\n             * * violet\n             * * indigo\n             * * blue\n             * * cyan\n             * * teal\n             * * green\n             * * lime\n             * * yellow\n             * * orange\n             * * deep-orange\n             * * gray\n             * * gantt-green (Useful when you want to match the color to the default color in Gantt)\n             *\n             * Specify `null` to not apply a default color and take control using custom CSS (an easily overridden color\n             * will be used to make sure events are still visible).\n             *\n             * @member {'red'|'pink'|'purple'|'violet'|'indigo'|'blue'|'cyan'|'teal'|'green'|'lime'|'yellow'|'orange'|'deep-orange'|'gray'|'gantt-green'} eventColor\n             * @category Scheduled events\n             */\n            /**\n             * The event color used by the Scheduler. Events and resources can specify their own color. See\n             * {@link #property-eventColor} for more details.\n             *\n             * @config {'red'|'pink'|'purple'|'violet'|'indigo'|'blue'|'cyan'|'teal'|'green'|'lime'|'yellow'|'orange'|'deep-orange'|'gray'|'gantt-green'} eventColor\n             * @default 'green'\n             * @category Scheduled events\n             */\n            eventColor : 'green',\n\n            /**\n             * The width/height (depending on vertical / horizontal mode) of all the time columns.\n             * @config {Number}\n             * @category Scheduled events\n             */\n            tickSize : null\n        };\n    }\n\n    static configurable = {\n        /**\n         * Controls how much space to leave between stacked event bars in px.\n         *\n         * Value will be constrained by half the row height in horizontal mode.\n         *\n         * @prp {Number}\n         * @default\n         * @category Scheduled events\n         */\n        barMargin : 10,\n\n        /**\n         * Specify `true` to force rendered events/tasks to fill entire ticks. This only affects rendering, start\n         * and end dates retain their value on the data level.\n         *\n         * When enabling `fillTicks` you should consider either disabling EventDrag/TaskDrag and EventResize/TaskResize,\n         * or enabling {@link Scheduler/view/mixin/TimelineDateMapper#config-snap}. Otherwise their behaviour might not\n         * be what a user expects.\n         *\n         * @prp {Boolean}\n         * @default\n         * @category Scheduled events\n         */\n        fillTicks : false\n    }\n\n    //endregion\n\n    //region Settings\n\n    updateFillTicks(fillTicks) {\n        if (!this.isConfiguring) {\n            this.timeAxis.forceFullTicks = fillTicks && this.snap;\n\n            this.refreshWithTransition();\n\n            this.trigger('stateChange');\n        }\n    }\n\n    changeBarMargin(margin) {\n        ObjectHelper.assertNumber(margin, 'barMargin');\n\n        // bar margin should not exceed half of the row height\n        if (this.isHorizontal && this.rowHeight) {\n            return Math.min(Math.ceil(this.rowHeight / 2), margin);\n        }\n\n        return margin;\n    }\n\n    updateBarMargin() {\n        if (this.rendered) {\n            this.currentOrientation.onBeforeRowHeightChange();\n            this.refreshWithTransition();\n            this.trigger('stateChange');\n        }\n    }\n\n    // Documented in SchedulerEventRendering to not show up in Gantt docs\n    get resourceMargin() {\n        return this._resourceMargin == null ? this.barMargin : this._resourceMargin;\n    }\n\n    set resourceMargin(margin) {\n        const me = this;\n\n        ObjectHelper.assertNumber(margin, 'resourceMargin');\n\n        // bar margin should not exceed half of the row height\n        if (me.isHorizontal && me.rowHeight) {\n            margin = Math.min(Math.ceil(me.rowHeight / 2), margin);\n        }\n\n        if (me._resourceMargin !== margin) {\n            me._resourceMargin = margin;\n            if (me.rendered) {\n                me.currentOrientation.onBeforeRowHeightChange();\n                me.refreshWithTransition();\n            }\n        }\n    }\n\n    /**\n     * Get/set the width/height (depending on mode) of all the time columns to the supplied value.\n     * There is a limit for the tick size value. Its minimal allowed value is calculated so ticks would fit the available space.\n     * Only applicable when {@link Scheduler.view.TimelineBase#config-forceFit} is set to `false`.\n     * To set `tickSize` freely skipping that limitation please set {@link Scheduler.view.TimelineBase#config-suppressFit} to `true`.\n     * @property {Number}\n     * @category Scheduled events\n     */\n    set tickSize(width) {\n        ObjectHelper.assertNumber(width, 'tickSize');\n\n        this.timeAxisViewModel.tickSize = width;\n    }\n\n    get tickSize() {\n        return this.timeAxisViewModel.tickSize;\n    }\n\n    /**\n     * Predefined event colors, useful in combos etc.\n     * @type {String[]}\n     * @category Scheduled events\n     */\n    static get eventColors() {\n        return ['red', 'pink', 'purple', 'violet', 'indigo', 'blue', 'cyan', 'teal', 'green', 'lime', 'yellow', 'orange', 'deep-orange', 'gray'];\n    }\n\n    /**\n     * Predefined event styles , useful in combos etc.\n     * @type {String[]}\n     * @category Scheduled events\n     */\n    static get eventStyles() {\n        return ['plain', 'border', 'hollow', 'colored', 'line', 'dashed', 'minimal', 'rounded'];\n    }\n\n    //endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport Scroller from '../../../Core/helper/util/Scroller.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\n\n/**\n * @module Scheduler/view/mixin/TimelineScroll\n */\nconst\n    maintainVisibleStart = {\n        maintainVisibleStart : true\n    },\n    defaultScrollOptions = {\n        block : 'nearest'\n    };\n\n/**\n * Functions for scrolling to events, dates etc.\n *\n * @mixin\n */\nexport default Target => class TimelineScroll extends (Target || Base) {\n    static get $name() {\n        return 'TimelineScroll';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * This config defines the size of the start and end invisible parts of the timespan when {@link #config-infiniteScroll} set to `true`.\n             *\n             * It should be provided as a coefficient, which will be multiplied by the size of the scheduling area.\n             *\n             * For example, if `bufferCoef` is `5` and the panel view width is 200px then the timespan will be calculated to\n             * have approximately 1000px (`5 * 200`) to the left and 1000px to the right of the visible area, resulting\n             * in 2200px of totally rendered content.\n             *\n             * @config {Number}\n             * @category Infinite scroll\n             * @default\n             */\n            bufferCoef : 5,\n\n            /**\n             * This config defines the scroll limit, which, when exceeded will cause a timespan shift.\n             * The limit is calculated as the `panelWidth * {@link #config-bufferCoef} * bufferThreshold`. During scrolling, if the left or right side\n             * has less than that of the rendered content - a shift is triggered.\n             *\n             * For example if `bufferCoef` is `5` and the panel view width is 200px and `bufferThreshold` is 0.2, then the timespan\n             * will be shifted when the left or right side has less than 200px (5 * 200 * 0.2) of content.\n             * @config {Number}\n             * @category Infinite scroll\n             * @default\n             */\n            bufferThreshold : 0.2,\n\n            /**\n             * True to automatically adjust the panel timespan during scrolling in the time dimension, when the scroller\n             * comes close to the start/end edges.\n             *\n             * The actually rendered timespan in this mode (and thus the amount of HTML in the DOM) is calculated based\n             * on the {@link #config-bufferCoef} option. The moment when the timespan shift happens is determined by the {@link #config-bufferThreshold} value.\n             * @config {Boolean} infiniteScroll\n             * @category Infinite scroll\n             * @default\n             */\n            infiniteScroll : false\n        };\n    }\n\n    initScroll() {\n        const\n            me               = this,\n            { isHorizontal } = me;\n\n        super.initScroll();\n\n        const { scrollable } = isHorizontal ? me.timeAxisSubGrid : me;\n\n        scrollable.ion({\n            scroll  : 'onTimelineScroll',\n            thisObj : me\n        });\n\n        // Ensure the TimeAxis starts life at the correct size with buffer zones\n        // outside the visible window.\n        if (me.infiniteScroll) {\n            const\n                { visibleDate }        = me,\n                date                   = visibleDate ? (visibleDate.date || visibleDate) : me.viewportCenterDate,\n                centered               = visibleDate && ('block' in visibleDate) ? visibleDate.block === 'center' : true,\n                { startDate, endDate } = me.timeAxisViewModel.calculateInfiniteScrollingDateRange(date, centered);\n\n            // Don't ask to maintain visible start - we're initializing - there's no visible start yet.\n            // If there's a visibleDate set, it will execute its scroll on paint.\n            me.setTimeSpan(\n                startDate,\n                endDate, {\n                    visibleDate : date\n                }\n            );\n        }\n    }\n\n    /**\n     * A {@link Core.helper.util.Scroller} which scrolls the time axis in whatever {@link Scheduler.view.Scheduler#config-mode} the\n     * Scheduler is configured, either `horiontal` or `vertical`.\n     *\n     * The width and height dimensions are replaced by `size`. So this will expose the following properties:\n     *\n     *    - `clientSize` The size of the time axis viewport.\n     *    - `scrollSize` The full scroll size of the time axis viewport\n     *    - `position` The position scrolled to along the time axis viewport\n     *\n     * @property {Core.helper.util.Scroller}\n     * @readonly\n     */\n    get timelineScroller() {\n        const me = this;\n\n        if (!me.scrollInitialized) {\n            me.initScroll();\n        }\n        return me._timelineScroller || (me._timelineScroller = new TimelineScroller({\n            widget       : me,\n            scrollable   : me.isHorizontal ? me.timeAxisSubGrid.scrollable : me.scrollable,\n            isHorizontal : me.isHorizontal\n        }));\n    }\n\n    doDestroy() {\n        this._timelineScroller?.destroy();\n\n        super.doDestroy();\n    }\n\n    onTimelineScroll({ source }) {\n        // On scroll, check if we are nearing the end to see if the sliding window needs moving.\n        // onSchedulerHorizontalScroll is delayed to animationFrame\n        if (this.infiniteScroll) {\n            this.checkTimeAxisScroll(source[this.isHorizontal ? 'x' : 'y']);\n        }\n    }\n\n    checkTimeAxisScroll(scrollPos) {\n        const\n            me             = this,\n            scrollable     = me.timelineScroller,\n            { clientSize } = scrollable,\n            requiredSize   = clientSize * me.bufferCoef,\n            limit          = requiredSize * me.bufferThreshold,\n            maxScroll      = scrollable.maxPosition,\n            { style }      = me.timeAxisSubGrid.virtualScrollerElement;\n\n        // if scroll violates limits let's shift timespan\n        if ((maxScroll - scrollPos < limit) || scrollPos < limit) {\n\n            // If they were dragging the thumb, this must be a one-time thing. They *must* lose contact\n            // with the thumb when the window shift occurs and the thumb zooms back to the center.\n            // Changing for a short time to overflow:hidden terminates the thumb drag.\n            // They can start again from the center, the reset happens very quickly.\n            style.overflow = 'hidden';\n            style.pointerEvents = 'none';\n\n            // Avoid content height changing when scrollbar disappears\n            style.paddingBottom = `${DomHelper.scrollBarWidth}px`;\n\n            me.setTimeout(() => {\n                style.overflow = '';\n                style.paddingBottom = '';\n                style.pointerEvents = '';\n            }, 100);\n            me.shiftToDate(me.getDateFromCoordinate(scrollPos, null, true));\n        }\n    }\n\n    shiftToDate(date, centered) {\n        const newRange = this.timeAxisViewModel.calculateInfiniteScrollingDateRange(date, centered);\n\n        // this will trigger a refresh (`refreshKeepingScroll`) which will perform `restoreScrollState` and sync the scrolling position\n        this.setTimeSpan(newRange.startDate, newRange.endDate, maintainVisibleStart);\n    }\n\n    // If we change to infinite scrolling dynamically, it should create the buffer zones.\n    updateInfiniteScroll(infiniteScroll) {\n        // At construction time, this is handled in initScroll.\n        // This is just here to handle dynamic updates.\n        if (!this.isConfiguring && infiniteScroll) {\n            this.checkTimeAxisScroll(this.timelineScroller.position);\n        }\n    }\n\n    //region Scroll to date\n\n    /**\n     * Scrolls the time line \"tick\" encapsulating the passed `Date` into view according to the passed options.\n     * @param {Date} date The date to which to scroll the time line\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     */\n    scrollToDate(date, options = {}) {\n        const\n            me               = this,\n            {\n                timeAxis,\n                visibleDateRange,\n                infiniteScroll\n            }              = me,\n            {\n                unit,\n                increment\n            }              = timeAxis,\n            edgeOffset     = options.edgeOffset || 0,\n            visibleWidth   = DateHelper.ceil(visibleDateRange.endDate, increment + ' ' + unit) - DateHelper.floor(visibleDateRange.startDate, increment + ' ' + unit),\n            direction      = date > me.viewportCenterDate ? 1 : -1,\n            extraScroll    = (infiniteScroll ? visibleWidth * me.bufferCoef * me.bufferThreshold : (options.block === 'center' ? visibleWidth / 2 : (edgeOffset ? me.getMilliSecondsPerPixelForZoomLevel(me.viewPreset) * edgeOffset : 0))) * direction,\n            visibleDate    = new Date(date.getTime() + extraScroll),\n            shiftDirection = visibleDate > timeAxis.endDate ? 1 : visibleDate < timeAxis.startDate ? -1 : 0;\n\n        // Required visible date outside TimeAxis and infinite scrolling, that has opinions about how\n        // much scroll range has to be created after the target date.\n        if (shiftDirection && me.infiniteScroll) {\n            me.shiftToDate(new Date(date - extraScroll), null, true);\n        }\n\n        const\n            scrollerViewport = me.timelineScroller.viewport,\n            localCoordinate  = me.getCoordinateFromDate(date, true),\n            target           = me.isHorizontal\n                // Available space can be less than tick size (Export.t.js in Gantt)\n                ? new Rectangle(me.getCoordinateFromDate(date, false), scrollerViewport.y, Math.min(me.timeAxisViewModel.tickSize, me.timeAxisViewModel.availableSpace), scrollerViewport.height)\n                : new Rectangle(scrollerViewport.x, me.getCoordinateFromDate(date, false), scrollerViewport.width, me.timeAxisViewModel.tickSize);\n\n        return me.scrollToCoordinate(localCoordinate, target, date, options);\n    }\n\n    /**\n     * Scrolls to current time.\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     */\n    scrollToNow(options = {}) {\n        return this.scrollToDate(new Date(), options);\n    }\n\n    /**\n     * Used by {@link #function-scrollToDate} to scroll to correct coordinate.\n     * @param {Number} localCoordinate Coordinate to scroll to\n     * @param {Date} date Date to scroll to, used for reconfiguring the time axis\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @private\n     * @category Scrolling\n     */\n    async scrollToCoordinate(localCoordinate, target, date, options = {}) {\n        const me = this;\n\n        // Not currently have this date in a timeaxis. Ignore negative scroll in weekview, it can be just 'filtered' with\n        // startTime/endTime config\n        if (localCoordinate < 0) {\n            // adjust the timeaxis first\n            const\n                visibleSpan         = me.endDate - me.startDate,\n                { unit, increment } = me.timeAxis,\n                newStartDate        = DateHelper.floor(new Date(date.getTime() - (visibleSpan / 2)), increment + ' ' + unit),\n                newEndDate          = DateHelper.add(newStartDate, visibleSpan);\n\n            // We're trying to reconfigure time span to current dates, which means we are as close to center as it\n            // could be. Do nothing then.\n            // covered by 1102_panel_api\n            if (newStartDate - me.startDate !== 0 && newEndDate - me.endDate !== 0) {\n                me.setTimeSpan(newStartDate, newEndDate);\n\n                return me.scrollToDate(date, options);\n            }\n\n            return;\n        }\n\n        await me.timelineScroller.scrollIntoView(target, options);\n\n        // Horizontal scroll is triggered on next frame in SubGrid.js, view is not up to date yet. Resolve on next frame\n        return !me.isDestroyed && me.nextAnimationFrame();\n    }\n\n    //endregion\n\n    //region Relative scrolling\n    // These methods are important to users because although they are mixed into the top level Grid/Scheduler,\n    // for X scrolling the explicitly target the SubGrid that holds the scheduler.\n\n    /**\n     * Get/set the `scrollLeft` value of the SubGrid that holds the scheduler.\n     *\n     * This may be __negative__ when the writing direction is right-to-left.\n     * @property {Number}\n     * @category Scrolling\n     */\n    set scrollLeft(left) {\n        this.timeAxisSubGrid.scrollable.element.scrollLeft = left;\n    }\n\n    get scrollLeft() {\n        return this.timeAxisSubGrid.scrollable.element.scrollLeft;\n    }\n\n    /**\n     * Get/set the writing direction agnostic horizontal scroll position.\n     *\n     * This is always the __positive__ offset from the scroll origin whatever the writing\n     * direction in use.\n     *\n     * Applies to the SubGrid that holds the scheduler\n     * @property {Number}\n     * @category Scrolling\n     */\n    set scrollX(x) {\n        this.timeAxisSubGrid.scrollable.x = x;\n    }\n\n    get scrollX() {\n        return this.timeAxisSubGrid.scrollable.x;\n    }\n\n    /**\n     * Get/set vertical scroll\n     * @property {Number}\n     * @category Scrolling\n     */\n    set scrollTop(top) {\n        this.scrollable.y = top;\n    }\n\n    get scrollTop() {\n        return this.scrollable.y;\n    }\n\n    /**\n     * Horizontal scrolling. Applies to the SubGrid that holds the scheduler\n     * @param {Number} x\n     * @param {ScrollOptions|Boolean} [options] How to scroll. May be passed as `true` to animate.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollHorizontallyTo(coordinate, options = true) {\n        return this.timeAxisSubGrid.scrollable.scrollTo(coordinate, null, options);\n    }\n\n    /**\n     * Vertical scrolling\n     * @param {Number} y\n     * @param {ScrollOptions|Boolean} [options] How to scroll. May be passed as `true` to animate.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollVerticallyTo(y, options = true) {\n        return this.scrollable.scrollTo(null, y, options);\n    }\n\n    /**\n     * Scrolls the subgrid that contains the scheduler\n     * @param {Number} x\n     * @param {ScrollOptions|Boolean} [options] How to scroll. May be passed as `true` to animate.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollTo(x, options = true) {\n        return this.timeAxisSubGrid.scrollable.scrollTo(x, null, options);\n    }\n\n    //endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n\n// Internal class used to interrogate and manipulate the timeline scroll position.\n// This delegates all operations to the appropriate Scroller, horizontal or vertical.\nclass TimelineScroller extends Scroller {\n    static get configurable() {\n        return {\n            position : null,\n            x        : null,\n            y        : null\n        };\n    }\n\n    // This class is passive about configuring the element.\n    // It has no opinions about *how* the overflow is handled.\n    updateOverflowX() {}\n    updateOverflowY() {}\n\n    onScroll(e) {\n        super.onScroll(e);\n        this._position = null;\n    }\n\n    syncPartners(force) {\n        this.scrollable.syncPartners(force);\n    }\n\n    updatePosition(position) {\n        this.scrollable[this.isHorizontal ? 'x' : 'y'] = position;\n    }\n\n    get viewport() {\n        return this.scrollable.viewport;\n    }\n\n    get position() {\n        return this._position = this.scrollable[this.isHorizontal ? 'x' : 'y'];\n    }\n\n    get clientSize() {\n        return this.scrollable[`client${this.isHorizontal ? 'Width' : 'Height'}`];\n    }\n\n    get scrollSize() {\n        return this.scrollable[`scroll${this.isHorizontal ? 'Width' : 'Height'}`];\n    }\n\n    get maxPosition() {\n        return this.scrollable[`max${this.isHorizontal ? 'X' : 'Y'}`];\n    }\n\n    scrollTo(position, options) {\n        return this.isHorizontal ? this.scrollable.scrollTo(position, null, options) : this.scrollable.scrollTo(null, position, options);\n    }\n\n    scrollBy(xDelta = 0, yDelta = 0, options = defaultScrollOptions) {\n        // Use the correct delta by default, but if it's zero, accommodate axis error.\n        return this.isHorizontal ? this.scrollable.scrollBy(xDelta || yDelta, 0, options) : this.scrollable.scrollBy(0, yDelta || xDelta, options);\n    }\n\n    scrollIntoView() {\n        return this.scrollable.scrollIntoView(...arguments);\n    }\n\n    // We accommodate mistakes. Setting X and Y sets the appropriate scroll axis position\n    changeX(x) {\n        this.position = x;\n    }\n\n    changeY(y) {\n        this.position = y;\n    }\n\n    get x() {\n        return this.position;\n    }\n\n    set x(x) {\n        this.scrollable[this.isHorizontal ? 'x' : 'y'] = x;\n    }\n\n    get y() {\n        return this.position;\n    }\n\n    set y(y) {\n        this.scroller[this.isHorizontal ? 'x' : 'y'] = y;\n    }\n\n    get clientWidth() {\n        return this.clientSize;\n    }\n\n    get clientHeight() {\n        return this.clientSize;\n    }\n\n    get scrollWidth() {\n        return this.scrollSize;\n    }\n\n    get scrollHeight() {\n        return this.scrollSize;\n    }\n\n    get maxX() {\n        return this.maxPosition;\n    }\n\n    get maxY() {\n        return this.maxPosition;\n    }\n}\n","import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Scheduler/view/mixin/TimelineState\n */\n\nconst copyProperties = [\n    'barMargin'\n];\n\n/**\n * Mixin for Timeline base that handles state. It serializes the following timeline properties:\n *\n * * barMargin\n * * zoomLevel\n *\n * See {@link Grid.view.mixin.GridState} and {@link Core.mixin.State} for more information on state.\n *\n * @mixin\n */\nexport default Target => class TimelineState extends (Target || Base) {\n    static get $name() {\n        return 'TimelineState';\n    }\n\n    /**\n     * Gets or sets timeline's state. Check out {@link Scheduler.view.mixin.TimelineState} mixin for details.\n     * @member {Object} state\n     * @property {Object[]} state.columns\n     * @property {Number} state.rowHeight\n     * @property {Object} state.scroll\n     * @property {Number} state.scroll.scrollLeft\n     * @property {Number} state.scroll.scrollTop\n     * @property {Array} state.selectedRecords\n     * @property {String} state.style\n     * @property {String} state.selectedCell\n     * @property {Object} state.store\n     * @property {Object} state.store.sorters\n     * @property {Object} state.store.groupers\n     * @property {Object} state.store.filters\n     * @property {Object} state.subGrids\n     * @property {Number} state.barMargin\n     * @property {Number} state.zoomLevel\n     * @category State\n     */\n\n    /**\n     * Get timeline's current state for serialization. State includes rowHeight, headerHeight, readOnly, selectedCell,\n     * selectedRecordId, column states and store state etc.\n     * @returns {Object} State object to be serialized\n     * @private\n     */\n    getState() {\n        const\n            me    = this,\n            state = ObjectHelper.copyProperties(super.getState(), me, copyProperties);\n\n        state.zoomLevel = me.zoomLevel;\n\n        state.zoomLevelOptions = {\n            startDate  : me.startDate,\n            endDate    : me.endDate,\n            // With infinite scroll reading viewportCenterDate too early will lead to exception\n            centerDate : !me.infiniteScroll || me.timeAxisViewModel.availableSpace ? me.viewportCenterDate : undefined,\n            width      : me.tickSize\n        };\n\n        return state;\n    }\n\n    /**\n     * Apply previously stored state.\n     * @param {Object} state\n     * @private\n     */\n    applyState(state) {\n        const me = this;\n\n        me.suspendRefresh();\n\n        ObjectHelper.copyProperties(me, state, copyProperties);\n\n        super.applyState(state);\n\n        if (state.zoomLevel != null) {\n            // Do not restore left scroll, infinite scroll should do all the work\n            if (me.infiniteScroll) {\n                if (state?.scroll?.scrollLeft) {\n                    state.scroll.scrollLeft = {};\n                }\n            }\n\n            if (me.isPainted) {\n                me.zoomToLevel(state.zoomLevel, state.zoomLevelOptions);\n            }\n            else {\n                me._zoomAfterPaint = { zoomLevel : state.zoomLevel, zoomLevelOptions : state.zoomLevelOptions };\n            }\n        }\n\n        me.resumeRefresh(true);\n    }\n\n    onPaint(...args) {\n        super.onPaint(...args);\n\n        if (this._zoomAfterPaint) {\n            const { zoomLevel, zoomLevelOptions } = this._zoomAfterPaint;\n\n            this.zoomToLevel(zoomLevel, zoomLevelOptions);\n\n            delete this._zoomAfterPaint;\n        }\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import GridHeader from '../../Grid/view/Header.js';\n\n/**\n * @module Scheduler/view/Header\n */\n\n/**\n * Custom header subclass which handles the existence of the special TimeAxisColumn\n *\n * @extends Grid/view/Header\n * @private\n */\nexport default class Header extends GridHeader {\n    static get $name() {\n        return 'SchedulerHeader';\n    }\n\n    refreshContent() {\n        // Only render contents into the header once as it contains the special rendering of the TimeAxisColumn\n        // In case ResizeObserver polyfill is used headers element will have resize monitors inserted and we should\n        // take that into account\n        // https://github.com/bryntum/support/issues/3444\n        if (!this.headersElement?.querySelector('.b-sch-timeaxiscolumn')) {\n            super.refreshContent();\n        }\n    }\n}\n","import SubGrid from '../../Grid/view/SubGrid.js';\nimport Header from './Header.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n\n/**\n * @module Scheduler/view/TimeAxisSubGrid\n */\n\n/**\n * Widget that encapsulates the SubGrid part of the scheduler which houses the timeline view.\n * @extends Grid/view/SubGrid\n * @private\n */\nexport default class TimeAxisSubGrid extends SubGrid {\n\n    static get $name() {\n        return 'TimeAxisSubGrid';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'timeaxissubgrid';\n    }\n\n    static get configurable() {\n        return {\n            // A Scheduler's SubGrid doesn't accept external columns moving in\n            sealedColumns : true,\n\n            // Use Scheduler's Header class\n            headerClass : Header\n        };\n    }\n\n    startConfigure(config) {\n        const { grid : scheduler } = config;\n\n        // Scheduler references its TimeAxisSubGrid instance through this property.\n        scheduler.timeAxisSubGrid = this;\n\n        super.startConfigure(config);\n\n        if (scheduler.isHorizontal) {\n            config.header = {\n                cls : {\n                    'b-sticky-headers' : scheduler.stickyHeaders\n                }\n            };\n            // We don't use what the GridSubGrids mixin tells us to.\n            // We use the Sheduler's Header class.\n            delete config.headerClass;\n        }\n\n        // If user have not specified a width or flex for scheduler region, default to flex=1\n        if (!('flex' in config || 'width' in config)) {\n            config.flex = 1;\n        }\n    }\n\n    changeScrollable() {\n        const\n            me         = this,\n            scrollable = super.changeScrollable(...arguments);\n\n        // TimeAxisSubGrid's X axis is stretched by its canvas.\n        // We don't need the Scroller's default stretching implementation.\n        if (scrollable) {\n            Object.defineProperty(scrollable, 'scrollWidth', {\n                get() {\n                    return this.element?.scrollWidth ?? 0;\n                },\n                set() {\n                    // Setting the scroll width to be wide just updates the canvas side in Scheduler.\n                    // We do not need the Scroller's default stretcher element to be added.\n                    // Note that \"me\" here is the TimeAxisSubGrid, so we are calling Scheduler.\n                    me.grid.updateCanvasSize();\n                }\n            });\n        }\n\n        return scrollable;\n    }\n\n    syncScrollingPartners(addCls = true) {\n        // Swallow scroll syncing calls that happen during view preset changes, that process triggers multiple when\n        // it first changes tickWidth, then scrolls to center and then an additional sync on scroll end\n        if (!this.grid._viewPresetChanging) {\n            super.syncScrollingPartners(addCls);\n        }\n    }\n\n    /**\n     * This is an event handler triggered when the TimeAxisSubGrid changes size.\n     * Its height changes when content height changes, and that is not what we are\n     * interested in here. If the *width* changes, that means the visible viewport\n     * has changed size.\n     * @param {HTMLElement} element\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Number} oldWidth\n     * @param {Number} oldHeight\n     * @private\n     */\n    onInternalResize(element, width, height, oldWidth, oldHeight) {\n        const me = this;\n\n        // We, as the TimeAxisSubGrid dictate the scheduler viewport width\n        if (me.isPainted && width !== oldWidth) {\n            const\n                scheduler  = me.grid,\n                bodyHeight = scheduler._bodyRectangle.height;\n\n            // Avoid ResizeObserver errors when this operation may create a scrollbar\n            if (DomHelper.scrollBarWidth && width < oldWidth) {\n                me.monitorResize = false;\n            }\n            scheduler.onSchedulerViewportResize(width, bodyHeight, oldWidth, bodyHeight);\n\n            // Revert to monitoring on the next animation frame.\n            // This is to avoid \"ResizeObserver loop completed with undelivered notifications.\"\n            if (!me.monitorResize) {\n                me.requestAnimationFrame(() => me.monitorResize = true);\n            }\n        }\n\n        super.onInternalResize(...arguments);\n    }\n\n    // When restoring state we need to update time axis size immediately, resize event is not triggered fast enough to\n    // restore center date consistently\n    clearWidthCache() {\n        super.clearWidthCache();\n\n        // Check if we are in horizontal mode\n        if (this.owner.isHorizontal) {\n            this.owner.updateViewModelAvailableSpace(this.width);\n        }\n    }\n}\n\n// Register this widget type with its Factory\nTimeAxisSubGrid.initClass();\n","import GridBase from '../../Grid/view/GridBase.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport FunctionHelper from '../../Core/helper/FunctionHelper.js';\nimport ResizeMonitor from '../../Core/helper/ResizeMonitor.js';\nimport Collection from '../../Core/util/Collection.js';\nimport IdHelper from '../../Core/helper/IdHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport TimeAxis from '../data/TimeAxis.js';\n\nimport TimeAxisViewModel from './model/TimeAxisViewModel.js';\nimport TimelineDateMapper from './mixin/TimelineDateMapper.js';\nimport TimelineDomEvents from './mixin/TimelineDomEvents.js';\nimport TimelineViewPresets from './mixin/TimelineViewPresets.js';\nimport TimelineZoomable from './mixin/TimelineZoomable.js';\nimport RecurringEvents from './mixin/RecurringEvents.js';\nimport TimelineEventRendering from './mixin/TimelineEventRendering.js';\nimport TimelineScroll from './mixin/TimelineScroll.js';\nimport TimelineState from './mixin/TimelineState.js';\nimport './TimeAxisSubGrid.js';\n\nconst\n    exitTransition        = {\n        fn                : 'exitTransition',\n        delay             : 0,\n        cancelOutstanding : true\n    },\n    emptyObject           = {};\n\n/**\n * @module Scheduler/view/TimelineBase\n */\n\n/**\n * Abstract base class used by timeline based components such as Scheduler and Gantt. Based on Grid, supplies a \"locked\"\n * region for columns and a \"normal\" for rendering of events etc.\n * @abstract\n *\n * @mixes Scheduler/view/mixin/TimelineDateMapper\n * @mixes Scheduler/view/mixin/TimelineDomEvents\n * @mixes Scheduler/view/mixin/TimelineEventRendering\n * @mixes Scheduler/view/mixin/TimelineScroll\n * @mixes Scheduler/view/mixin/TimelineState\n * @mixes Scheduler/view/mixin/TimelineViewPresets\n * @mixes Scheduler/view/mixin/TimelineZoomable\n * @mixes Scheduler/view/mixin/RecurringEvents\n *\n * @extends Grid/view/Grid\n */\nexport default class TimelineBase extends GridBase.mixin(\n    TimelineDateMapper,\n    TimelineDomEvents,\n    TimelineEventRendering,\n    TimelineScroll,\n    TimelineState,\n    TimelineViewPresets,\n    TimelineZoomable,\n    RecurringEvents\n) {\n    //region Config\n\n    static get $name() {\n        return 'TimelineBase';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'timelinebase';\n    }\n\n    static configurable = {\n        partnerSharedConfigs : {\n            value : ['timeAxisViewModel', 'timeAxis', 'viewPreset'],\n\n            $config : {\n                merge : 'distinct'\n            }\n        },\n\n        /**\n         * Get/set startDate. Defaults to current date if none specified.\n         *\n         * **Note:** If you need to set start and end date at the same time, use {@link #function-setTimeSpan} method.\n         * @member {Date} startDate\n         * @category Common\n         */\n        /**\n         * The start date of the timeline. If omitted, and a TimeAxis has been set, the start date of the provided\n         * {@link Scheduler.data.TimeAxis} will be used. If no TimeAxis has been configured, it'll use the start/end\n         * dates of the loaded event dataset. If no date information exists in the event data set, it defaults to\n         * the current date and time.\n         *\n         * If a string is supplied, it will be parsed using\n         * {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat}\n         *\n         * **Note:** If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n         * @config {Date|String}\n         * @category Common\n         */\n        startDate : {\n            $config : {\n                equal : 'date'\n            },\n            value : null\n        },\n\n        /**\n         * Get/set endDate. Defaults to startDate + default span of the used ViewPreset.\n         *\n         * **Note:** If you need to set start and end date at the same time, use {@link #function-setTimeSpan} method.\n         * @member {Date} endDate\n         * @category Common\n         */\n        /**\n         * The end date of the timeline. If omitted, it will be calculated based on the {@link #config-startDate}\n         * setting and the 'defaultSpan' property of the current\n         * {@link Scheduler.view.mixin.TimelineViewPresets#config-viewPreset}.\n         *\n         * If a string is supplied, it will be parsed using\n         * {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat}\n         *\n         * **Note:** If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n         * @config {Date|String}\n         * @category Common\n         */\n        endDate : {\n            $config : {\n                equal : 'date'\n            },\n            value : null\n        },\n\n        /**\n         * When set, the text in the major time axis header sticks in the scrolling viewport as long as possible.\n         * @config {Boolean}\n         * @default\n         * @category Time axis\n         */\n        stickyHeaders : true,\n\n        /**\n         * A date to bring into view initially on the scrollable timeline. Either a date or an object describing\n         * the scroll action, see {@link #function-scrollToDate} for reference.\n         * @config {Date|Object}\n         * @category Common\n         */\n        visibleDate : null,\n\n        /**\n         * CSS class to add to rendered events\n         * @config {String}\n         * @category CSS\n         * @private\n         */\n        eventCls : null,\n\n        /**\n         * Set to `true` to force the time columns to fit to the available space (horizontal or vertical depends on mode).\n         * Note that setting {@link #config-suppressFit} on `true`, will disable `forceFit` functionality.\n         * @prp {Boolean}\n         * @default\n         * @category Time axis\n         */\n        forceFit : false,\n\n        /**\n         * Set to a time zone or a UTC offset. This will set the projects\n         * {@link Scheduler.model.ProjectModel#config-timeZone} config accordingly. As this config is only a referer,\n         * please se project's config {@link Scheduler.model.ProjectModel#config-timeZone documentation} for more\n         * information.\n         *\n         * ```javascript\n         * new Calendar(){\n         *   timeZone : 'America/Chicago'\n         * }\n         * ```\n         * @prp {String|Number} timeZone\n         * @category Misc\n         */\n        timeZone : null\n\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * A valid JS day index between 0-6 (0: Sunday, 1: Monday etc.) to be considered the start day of the week.\n             * When omitted, the week start day is retrieved from the active locale class.\n             * @config {Number} weekStartDay\n             * @category Time axis\n             */\n\n            /**\n             * An object with format `{ fromDay, toDay, fromHour, toHour }` that describes the working days and hours.\n             * This object will be used to populate TimeAxis {@link Scheduler.data.TimeAxis#config-include} property.\n             *\n             * Using it results in a non-continuous time axis. Any ticks not covered by the working days and hours will\n             * be excluded. Events within larger ticks (for example if using week as the unit for ticks) will be\n             * stretched to fill the gap otherwise left by the non working hours.\n             *\n             * As with end dates, `toDay` and `toHour` are exclusive. Thus `toDay : 6` means that day 6 (saturday) will\n             * not be included.\n             *\n             *\n             * **NOTE:** When this feature is enabled {@link Scheduler.view.mixin.TimelineZoomable Zooming feature} is\n             * not supported. It's recommended to disable zooming controls:\n             *\n             * ```javascript\n             * new Scheduler({\n             *     zoomOnMouseWheel          : false,\n             *     zoomOnTimeAxisDoubleClick : false,\n             *     ...\n             * });\n             * ```\n             *\n             * @config {Object}\n             * @category Time axis\n             */\n            workingTime : null,\n\n            /**\n             * A backing data store of 'ticks' providing the input date data for the time axis of timeline panel.\n             * @member {Scheduler.data.TimeAxis} timeAxis\n             * @readonly\n             * @category Time axis\n             */\n\n            /**\n             * A {@link Scheduler.data.TimeAxis} config object or instance, used to create a backing data store of\n             * 'ticks' providing the input date data for the time axis of timeline panel. Created automatically if none\n             * supplied.\n             * @config {TimeAxisConfig|Scheduler.data.TimeAxis}\n             * @category Time axis\n             */\n            timeAxis : null,\n\n            /**\n             * The backing view model for the visual representation of the time axis.\n             * Either a real instance or a simple config object.\n             * @private\n             * @config {Scheduler.view.model.TimeAxisViewModel|TimeAxisViewModelConfig}\n             * @category Time axis\n             */\n            timeAxisViewModel : null,\n\n            /**\n             * You can set this option to `false` to make the timeline panel start and end on the exact provided\n             * {@link #config-startDate}/{@link #config-endDate} w/o adjusting them.\n             * @config {Boolean}\n             * @default\n             * @category Time axis\n             */\n            autoAdjustTimeAxis : true,\n\n            /**\n             * Affects drag drop and resizing of events when {@link Scheduler/view/mixin/TimelineDateMapper#config-snap}\n             * is enabled.\n             *\n             * If set to `true`, dates will be snapped relative to event start. e.g. for a zoom level with\n             * `timeResolution = { unit: \"s\", increment: \"20\" }`, an event that starts at 10:00:03 and is dragged would\n             * snap its start date to 10:00:23, 10:00:43 etc.\n             *\n             * When set to `false`, dates will be snapped relative to the timeAxis startDate (tick start)\n             * - 10:00:03 -> 10:00:20, 10:00:40 etc.\n             *\n             * @config {Boolean}\n             * @default\n             * @category Scheduled events\n             */\n            snapRelativeToEventStartDate : false,\n\n            /**\n             * Set to `true` to prevent auto calculating of a minimal {@link Scheduler.view.mixin.TimelineEventRendering#property-tickSize}\n             * to always fit the content to the screen size. Setting this property on `true` will disable {@link #config-forceFit} behaviour.\n             * @config {Boolean}\n             * @default false\n             * @category Time axis\n             */\n            suppressFit : false,\n\n            /**\n             * CSS class to add to cells in the timeaxis column\n             * @config {String}\n             * @category CSS\n             * @private\n             */\n            timeCellCls : null,\n\n            scheduledEventName : null,\n\n            //dblClickTime : 200,\n\n            /**\n             * A CSS class to apply to each event in the view on mouseover.\n             * @config {String}\n             * @category CSS\n             * @private\n             */\n            overScheduledEventClass : null,\n\n            // allow the panel to prevent adding the hover CSS class in some cases - during drag drop operations\n            preventOverCls : false,\n\n            // This setting is set to true by features that need it\n            useBackgroundCanvas : false,\n\n            /**\n             * Set to `false` if you don't want event bar DOM updates to animate.\n             * @prp {Boolean}\n             * @default true\n             * @category Scheduled events\n             */\n            enableEventAnimations : true,\n\n            disableGridRowModelWarning : true,\n\n            // does not look good with locked columns and also interferes with event animations\n            animateRemovingRows : false,\n\n            /**\n             * Partners this Timeline panel with another Timeline in order to sync their region sizes (sub-grids like locked, normal will get the same width),\n             * start and end dates, view preset, zoom level and scrolling position. All these values will be synced with the timeline defined as the `partner`.\n             *\n             * - To add a new partner dynamically see {@link #function-addPartner} method.\n             * - To remove existing partner see {@link #function-removePartner} method.\n             * - To check if timelines are partners see {@link #function-isPartneredWith} method.\n             *\n             * @config {Scheduler.view.TimelineBase}\n             * @category Time axis\n             */\n            partner : null,\n\n            schedulerRegion : 'normal',\n\n            transitionDuration : 200,\n            // internal timer id reference\n            animationTimeout   : null,\n\n            /**\n             * Region to which columns are added when they have none specified\n             * @config {String}\n             * @default\n             * @category Misc\n             */\n            defaultRegion : 'locked',\n\n            /**\n             * Decimal precision used when displaying durations, used by tooltips and DurationColumn.\n             * Specify `false` to use raw value\n             * @config {Number|Boolean}\n             * @default\n             * @category Common\n             */\n            durationDisplayPrecision : 1,\n\n            asyncEventSuffix : 'PreCommit',\n\n            viewportResizeTimeout : 250\n\n            /**\n             * An object with configuration for the {@link Scheduler.column.TimeAxisColumn} in horizontal\n             * {@link Scheduler.view.SchedulerBase#config-mode}.\n             *\n             * Example:\n             *\n             * ```javascript\n             * new Scheduler({\n             *     timeAxisColumn : {\n             *         renderer : ({ record, cellElement }) => {\n             *             // output some markup as a layer below the events layer, you can draw a chart for example\n             *         }\n             *     },\n             *     ...\n             * });\n             * ```\n             *\n             * @config {TimeAxisColumnConfig} timeAxisColumn\n             * @category Time axis\n             */\n        };\n    }\n\n    static properties = {\n        timeCellSelector : null\n    }\n\n    updateTimeZone(timeZone) {\n        if (this.isConfiguring) {\n            this.project._isConfiguringTimeZone = true;\n        }\n        this.project.timeZone = timeZone;\n    }\n\n    get timeZone() {\n        return this.project.timeZone;\n    }\n\n    //endregion\n\n    //region Feature hooks\n\n    /**\n    * Populates the event context menu. Chained in features to add menu items.\n    * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n    * @param {Grid.column.Column} options.column Column for which the menu will be shown.\n    * @param {Scheduler.model.EventModel} options.eventRecord The context event.\n    * @param {Scheduler.model.ResourceModel} options.resourceRecord The context resource.\n    * @param {Scheduler.model.AssignmentModel} options.assignmentRecord The context assignment if any.\n    * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items.\n    * @internal\n    */\n    populateEventMenu() {}\n\n    /**\n     * Populates the time axis context menu. Chained in features to add menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown.\n     * @param {Scheduler.model.ResourceModel} options.resourceRecord The context resource.\n     * @param {Date} options.date The Date corresponding to the mouse position in the time axis.\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items.\n     * @internal\n     */\n    populateScheduleMenu() {}\n\n    // Called when visible date range potentially changes such as when scrolling in\n    // the time axis.\n    onVisibleDateRangeChange(range) {\n        if (!this.handlingVisibleDateRangeChange) {\n            const\n                me                    = this,\n                { _visibleDateRange } = me,\n                dateRangeChange       = !_visibleDateRange || (_visibleDateRange.startDate - range.startDate || _visibleDateRange.endDate - range.endDate);\n\n            if (dateRangeChange) {\n                me.timeView.range = range;\n                me.handlingVisibleDateRangeChange = true;\n\n                /**\n                 * Fired when the range of dates visible within the viewport changes. This will be when\n                 * scrolling along a time axis.\n                 *\n                 * __Note__ that this event will fire frequently during scrolling, so any listener\n                 * should probably be added with the `buffer` option to slow down the calls to your\n                 * handler function :\n                 *\n                 * ```javascript\n                 * listeners : {\n                 *     visibleDateRangeChange({ old, new }) {\n                 *         this.updateRangeRequired(old, new);\n                 *     },\n                 *     // Only call once. 300 ms after the last event was detected\n                 *     buffer : 300\n                 * }\n                 * ```\n                 * @event visibleDateRangeChange\n                 * @param {Scheduler.view.Scheduler} source This Scheduler instance.\n                 * @param {Object} old The old date range\n                 * @param {Date} old.startDate the old start date.\n                 * @param {Date} old.endDate the old end date.\n                 * @param {Object} new The new date range\n                 * @param {Date} new.startDate the new start date.\n                 * @param {Date} new.endDate the new end date.\n                 */\n                me.trigger('visibleDateRangeChange', {\n                    old : _visibleDateRange,\n                    new : range\n                });\n                me.handlingVisibleDateRangeChange = false;\n                me._visibleDateRange = range;\n            }\n        }\n    }\n\n    // Called when visible resource range changes in vertical mode\n    onVisibleResourceRangeChange() {}\n\n    //endregion\n\n    //region Init\n\n    construct(config = {}) {\n        const me = this;\n\n        super.construct(config);\n\n        me.$firstVerticalOverflow = true;\n\n        me.initDomEvents();\n\n        me.currentOrientation.init();\n\n        me.rowManager.ion({\n            refresh : () => {\n                me.forceLayout = false;\n            }\n        });\n    }\n\n    // Override from Grid.view.GridSubGrids\n    createSubGrid(region, config = {}) {\n        const\n            me                = this,\n            { stickyHeaders } = me;\n\n        // We are creating the TimeAxisSubGrid\n        if (region === (me.schedulerRegion || 'normal')) {\n            config.type = 'timeaxissubgrid';\n        }\n\n        // The assumption is that if we are in vertical mode, the locked SubGrid\n        // is used to house the verticalTimeAxis, and so it must all be overflow:visible\n        else if (region === 'locked' && stickyHeaders && me.isVertical) {\n            config.scrollable = {\n                overflowX : 'visible',\n                overflowY : 'visible'\n            };\n\n            // It's the child of the overflowElement\n            me.bodyContainer.classList.add('b-sticky-headers');\n        }\n\n        return super.createSubGrid(region, config);\n    }\n\n    doDestroy() {\n        const\n            me                                    = this,\n            { partneredWith, currentOrientation } = me;\n\n        currentOrientation?.destroy();\n\n        // Break links between this TimeLine and any partners.\n        if (partneredWith) {\n            partneredWith.forEach(p => {\n                me.removePartner(p);\n            });\n            partneredWith.destroy();\n        }\n        else {\n            me.timeAxisViewModel.destroy();\n            me.timeAxis.destroy();\n        }\n\n        super.doDestroy();\n    }\n\n    startConfigure(config) {\n        super.startConfigure(config);\n\n        // When the body height changes, we must update the SchedulerViewport's height\n        ResizeMonitor.addResizeListener(this.bodyContainer, this.onBodyResize.bind(this));\n\n        // partner needs to be initialized first so that the various shared\n        // configs are assigned first before we default them in.\n        this.getConfig('partner');\n    }\n\n    changeStartDate(startDate) {\n        if (typeof startDate === 'string') {\n            startDate = DateHelper.parse(startDate);\n        }\n        return startDate;\n    }\n\n    onPaint({ firstPaint }) {\n        // Upon first paint we need to pass the forceUpdate flag in case we are sharing the TimAxisViewModel\n        // with another Timeline which will already have done this.\n        if (firstPaint) {\n            // Take height from container element\n            // TODO: make flex element inherit height from parent (min-height: 100% doesn't work)\n            const\n                me             = this,\n                scrollable     = me.isHorizontal ? me.timeAxisSubGrid.scrollable : me.scrollable,\n                // Use exact subpixel available space so that tick size calculation is correct.\n                availableSpace = scrollable.element.getBoundingClientRect()[me.isHorizontal ? 'width' : 'height'];\n\n            // silent = true if infiniteScroll. If that is set, TimelineScroll.initScroll which is\n            // called by the base class's onPaint reconfigures the TAVM when it initializes.\n            me.timeAxisViewModel.update(availableSpace, me.infiniteScroll, true);\n\n            // If infiniteScroll caused the TAVM update to be silent, force the rendering to\n            // get hold of the scroll state and visible range\n            if (me.infiniteScroll) {\n                me.currentOrientation.doUpdateTimeView?.();\n            }\n        }\n\n        super.onPaint(...arguments);\n    }\n\n    onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX) {\n        // rerender cells in scheduler column on horizontal scroll to display events in view\n        this.currentOrientation.updateFromHorizontalScroll(scrollX);\n\n        super.onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX);\n    }\n\n    /**\n     * Overrides initScroll from Grid, listens for horizontal scroll to do virtual event rendering\n     * @private\n     */\n    initScroll() {\n        const me = this;\n\n        let frameCount = 0;\n\n        super.initScroll();\n\n        me.ion({\n            horizontalScroll : ({ subGrid, scrollLeft, scrollX }) => {\n                if (me.isPainted && subGrid === me.timeAxisSubGrid && !me.isDestroying && !me.refreshSuspended) {\n                    me.onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX);\n                }\n                frameCount++;\n            }\n        });\n\n        if (me.testPerformance === 'horizontal') {\n            me.setTimeout(() => {\n                const start = performance.now();\n                let scrollSpeed = 5,\n                    direction   = 1;\n\n                const scrollInterval = me.setInterval(() => {\n                    scrollSpeed = scrollSpeed + 5;\n\n                    me.scrollX += (10 + Math.floor(scrollSpeed)) * direction;\n\n                    if (direction === 1 && me.scrollX > 5500) {\n                        direction   = -1;\n                        scrollSpeed = 5;\n                    }\n\n                    if (direction === -1 && me.scrollX <= 0) {\n                        const\n                            done    = performance.now(), // eslint-disable-line no-undef\n                            elapsed = done - start;\n\n                        const\n                            timePerFrame = elapsed / frameCount,\n                            fps          = Math.round((1000 / timePerFrame) * 10) / 10;\n\n                        clearInterval(scrollInterval);\n\n                        console.log(me.eventPositionMode, me.eventScrollMode, fps + 'fps');\n                    }\n                }, 0);\n            }, 500);\n        }\n    }\n\n    //endregion\n\n    /**\n     * Calls the specified function (returning its return value) and preserves the timeline center\n     * point. This is a useful way of retaining the user's visual context while making updates\n     * and changes to the view which require major changes or a full refresh.\n     * @param {Function} fn The function to call.\n     * @param {Object} thisObj The `this` context for the function.\n     * @param {...*} args Parameters to the function.\n     */\n    preserveViewCenter(fn, thisObj = this, ...args) {\n        const\n            me             = this,\n            centerDate     = me.viewportCenterDate,\n            result         = fn.apply(thisObj, args),\n            scroller       = me.timelineScroller,\n            { clientSize } = scroller,\n            scrollStart    = Math.max(Math.floor(me.getCoordinateFromDate(centerDate, true) - clientSize / 2), 0);\n\n        me.scrollingToCenter = true;\n        scroller.scrollTo(scrollStart, false).then(() => me.scrollingToCenter = false);\n\n        return result;\n    }\n\n    /**\n     * Changes this Sheduler's time axis timespan to the supplied start and end dates.\n     * @param {Date} newStartDate The new start date\n     * @param {Date} newEndDate The new end date\n     * @param {Object} [options] An object containing modifiers for the time span change operation.\n     * @param {Boolean} [options.maintainVisibleStart] Specify as `true` to keep the visible start date stable.\n     * @param {Date} [options.visibleDate] The date inside the range to scroll into view\n     */\n    setTimeSpan(newStartDate, newEndDate, {\n        preventThrow         = false, // Private, only used by the shift method.\n        maintainVisibleStart = false,\n        visibleDate\n    } = emptyObject) {\n        const\n            me             = this,\n            { timeAxis   } = me,\n            {\n                startDate,\n                endDate\n            }              = timeAxis.getAdjustedDates(newStartDate, newEndDate),\n            startChanged   = timeAxis.startDate - startDate !== 0,\n            endChanged     = timeAxis.endDate - endDate !== 0;\n\n        if (startChanged || endChanged) {\n            if (maintainVisibleStart) {\n                const\n                    {\n                        timeAxisViewModel\n                    }             = me,\n                    { totalSize } = timeAxisViewModel,\n                    oldTickSize   = timeAxisViewModel.tickSize,\n                    scrollable    = me.timelineScroller,\n                    currentScroll = scrollable.position,\n                    visibleStart  = timeAxisViewModel.getDateFromPosition(currentScroll);\n\n                // If the current visibleStart is in the new range, maintain it\n                // So that there is no visual jump.\n                if (visibleStart >= startDate && visibleStart < endDate) {\n                    // We need to correct the scroll position as soon as the TimeAxisViewModel\n                    // has updated itself and before any other UI updates which that may trigger.\n                    timeAxisViewModel.ion({\n                        update() {\n                            const tickSizeChanged = timeAxisViewModel.tickSize !== oldTickSize;\n\n                            // Ensure the canvas element matches the TimeAxisViewModel's new totalSize.\n                            // This creates the required scroll range to be able to have the scroll\n                            // position correct before any further UI updates.\n                            me.updateCanvasSize();\n\n                            // If *only* the start moved, we can keep scroll position the same\n                            // by adjusting it by the amount the start moved.\n                            if (startChanged && !endChanged && !tickSizeChanged) {\n                                scrollable.position += (timeAxisViewModel.totalSize - totalSize);\n                            }\n                            // If only the end has changed, and tick size is same, we can maintain\n                            // the same scroll position.\n                            else if (!startChanged && !tickSizeChanged) {\n                                scrollable.position = currentScroll;\n                            }\n                            // Fall back to restoring the position by restoring the visible start time\n                            else {\n                                scrollable.position = timeAxisViewModel.getPositionFromDate(visibleStart);\n                            }\n\n                            // Force partners to sync with what we've just done to reset the scroll.\n                            // We are now in control.\n                            scrollable.syncPartners(true);\n                        },\n                        prio : 10000,\n                        once : true\n                    });\n                }\n            }\n\n            const returnValue = timeAxis.reconfigure({\n                startDate,\n                endDate\n            }, false, preventThrow);\n            if (visibleDate) {\n                me.scrollToDate(visibleDate.date || visibleDate, visibleDate);\n            }\n            return returnValue;\n        }\n    }\n\n    //region Config getters/setters\n\n    /**\n     * Returns `true` if any of the events/tasks or feature injected elements (such as ResourceTimeRanges) are within\n     * the {@link #config-timeAxis}\n     * @property {Boolean}\n     * @readonly\n     * @category Scheduled events\n     */\n    get hasVisibleEvents() {\n        return !this.noFeatureElementsInAxis() || this.eventStore.storage.values.some(t => this.timeAxis.isTimeSpanInAxis(t));\n    }\n\n    // Template function to be chained in features to determine if any elements are in time axis (needed since we cannot\n    // currently chain getters). Negated to not break chain. First feature that has elements visible returns false,\n    // which prevents other features from being queried.\n    noFeatureElementsInAxis() { }\n\n    // Private getter used to piece together event names such as beforeEventDrag / beforeTaskDrag. Could also be used\n    // in templates.\n    get capitalizedEventName() {\n        if (!this._capitalizedEventName) {\n            this._capitalizedEventName = StringHelper.capitalize(this.scheduledEventName);\n        }\n\n        return this._capitalizedEventName;\n    }\n\n    set partner(partner) {\n        this._partner = partner;\n\n        this.addPartner(partner);\n    }\n\n    /**\n     * Partners this Timeline with the passed Timeline in order to sync the horizontal scrolling position and zoom level.\n     *\n     * - To remove existing partner see {@link #function-removePartner} method.\n     * - To get the list of partners see {@link #property-partners} getter.\n     *\n     * @param {Scheduler.view.TimelineBase} otherTimeline The timeline to partner with\n     */\n    addPartner(partner) {\n        const me = this;\n\n        if (!me.isPartneredWith(partner)) {\n            const partneredWith = me.partneredWith || (me.partneredWith = new Collection());\n\n            // Each must know about the other so that they can sync others upon region resize\n            partneredWith.add(partner);\n\n            (partner.partneredWith || (partner.partneredWith = new Collection())).add(me);\n\n            // Flush through viewPreset initGetter so that the setup in setConfig doesn't\n            // take them to be the class's defined getters.\n            me.getConfig('viewPreset');\n\n            partner.ion({\n                presetchange : 'onPartnerPresetChange',\n                thisObj      : me\n            });\n            partner.scrollable.ion({\n                overflowChange : 'onPartnerOverflowChange',\n                thisObj        : me\n            });\n\n            // collect configs that are meant to be shared between partners\n            const partnerSharedConfig = me.partnerSharedConfigs.reduce((config, configName) => {\n                config[configName] = partner[configName];\n                return config;\n            }, {});\n\n            me.setConfig(partnerSharedConfig);\n\n            me.ion({\n                presetchange : 'onPartnerPresetChange',\n                thisObj      : partner\n            });\n            me.scrollable.ion({\n                overflowChange : 'onPartnerOverflowChange',\n                thisObj        : partner\n            });\n\n            if (me.isPainted) {\n                me.scrollable.addPartner(partner.scrollable, me.isHorizontal ? 'x' : 'y');\n\n                partner.syncPartnerSubGrids();\n            }\n            else {\n                // When initScroll comes round, make sure it syncs with the partner\n                me.initScroll = FunctionHelper.createSequence(me.initScroll, () => {\n                    me.scrollable.addPartner(partner.scrollable, me.isHorizontal ? 'x' : 'y');\n                    partner.syncPartnerSubGrids();\n                }, me);\n            }\n        }\n    }\n\n    /**\n     * Breaks the link between current Timeline and the passed Timeline\n     *\n     * - To add a new partner see {@link #function-addPartner} method.\n     * - To get the list of partners see {@link #property-partners} getter.\n     *\n     * @param {Scheduler.view.TimelineBase} otherTimeline The timeline to unlink from\n     */\n    removePartner(partner) {\n        const\n            me                = this,\n            { partneredWith } = me;\n\n        if (me.isPartneredWith(partner)) {\n            partneredWith.remove(partner);\n            me.scrollable.removePartner(partner.scrollable);\n            me.un({\n                presetchange : 'onPartnerPresetChange',\n                thisObj      : partner\n            });\n            me.scrollable.un({\n                overflowChange : 'onPartnerOverflowChange',\n                thisObj        : partner\n            });\n\n            partner.removePartner(me);\n        }\n    }\n\n    /**\n     * Checks whether the passed timeline is partnered with the current timeline.\n     * @param {Scheduler.view.TimelineBase} partner The timeline to check the partnering with\n     * @returns {Boolean} Returns `true` if the timelines are partnered\n     */\n    isPartneredWith(partner) {\n        return Boolean(this.partneredWith?.includes(partner));\n    }\n\n    /**\n     * Called when a partner scheduler changes its overflowing state. The scrollable\n     * of a Grid/Scheduler only handles overflowY, so this will mean the addition\n     * or removal of a vertical scrollbar.\n     *\n     * All partners must stay in sync. If another parter has a vertical scrollbar\n     * and we do not, we must set our overflowY to 'scroll' so that we show an empty\n     * scrollbar to keep widths synchronized.\n     * @param {Object} event A {@link Core.helper.util.Scroller#event-overflowChange} event\n     * @internal\n     */\n    onPartnerOverflowChange({ source : otherScrollable, y }) {\n        const\n            { scrollable } = this,\n            ourY           = scrollable.hasOverflow('y');\n\n        // If we disagree with our partner, the partner which doesn't have\n        // overflow, has to become overflowY : scroll\n        if (ourY !== y) {\n            if (ourY) {\n                otherScrollable.overflowY = 'scroll';\n            }\n            else {\n                otherScrollable.overflowY = true;\n                scrollable.overflowY = 'scroll';\n                this.refreshVirtualScrollbars();\n            }\n        }\n        // If we agree with our partner, we can reset ourselves to overflowY : auto\n        else {\n            scrollable.overflowY = true;\n        }\n    }\n\n    onPartnerPresetChange({ preset, startDate, endDate, centerDate, zoomDate, zoomPosition, zoomLevel }) {\n        if (!this._viewPresetChanging && this.viewPreset !== preset) {\n\n            // Passed through to the viewPreset changing method\n            preset.options  = {\n                startDate,\n                endDate,\n                centerDate,\n                zoomDate,\n                zoomPosition,\n                zoomLevel\n            };\n            this.viewPreset = preset;\n        }\n    }\n\n    get partner() {\n        return this._partner;\n    }\n\n    /**\n     * Returns the partnered timelines.\n     *\n     * - To add a new partner see {@link #function-addPartner} method.\n     * - To remove existing partner see {@link #function-removePartner} method.\n     *\n     * @readonly\n     * @member {Scheduler.view.TimelineBase} partners\n     * @category Time axis\n     */\n    get partners() {\n        const partners = this.partner ? [this.partner] : [];\n\n        if (this.partneredWith) {\n            partners.push.apply(partners, this.partneredWith.allValues);\n        }\n\n        return partners;\n    }\n\n    get timeAxisColumn() {\n        return this.columns && this._timeAxisColumn;\n    }\n\n    get columns() {\n        // Maintainer. If we do not implement a getter to go along with our setter, this\n        // property becomes unreadable at this class level.\n        return super.columns;\n    }\n\n    set columns(columns) {\n        const me = this;\n\n        let timeAxisColumnIndex, timeAxisColumnConfig, timeAxisColumn/*, value*/;\n\n        // No columns means destroy\n        if (columns) {\n            const isArray = Array.isArray(columns);\n\n            let cols = columns;\n\n            if (!isArray) {\n                cols = columns.data;\n            }\n\n            timeAxisColumnIndex = cols && cols.length;\n\n            cols.some((col, index) => {\n                if (col.type === 'timeAxis') {\n                    timeAxisColumnIndex  = index;\n                    timeAxisColumnConfig = ObjectHelper.assign(col, me.timeAxisColumn);\n                    return true;\n                }\n                return false;\n            });\n\n            // TODO : This is scheduler specific, override `set columns` instead\n            // No additional columns allowed in vertical mode, but store the specified set in case we toggle mode later\n            if (me.isVertical) {\n                me._horizontalColumns = columns;\n\n                cols = [\n                    ObjectHelper.assign({\n                        type   : 'verticalTimeAxis',\n                        locked : true\n                    }, me.verticalTimeAxisColumn),\n                    // Make space for a regular TimeAxisColumn after the VerticalTimeAxisColumn\n                    cols[timeAxisColumnIndex]\n                ];\n\n                timeAxisColumnIndex = 1;\n            }\n            else {\n                // We're going to mutate this array which we do not own, so copy it first.\n                cols = cols.slice();\n            }\n\n            // Fix up the timeAxisColumn config in place\n            cols[timeAxisColumnIndex] = {\n                type    : 'timeAxis',\n                locked  : false,\n                cellCls : me.timeCellCls,\n                mode    : me.mode,\n                ...timeAxisColumnConfig\n            };\n\n            if (isArray) {\n                columns = cols;\n            }\n            else {\n                columns.data = cols;\n            }\n        }\n\n        // Invoke Grid's setter. Will create a ColumnStore which is returned by the columns setter.\n        super.columns = columns;\n\n        // Extract the known columns by type. Sorting will have placed them into visual order.\n        if (columns) {\n            timeAxisColumn = me._timeAxisColumn = me.columns.find(c => c.isTimeAxisColumn);\n\n            if (me.isVertical) {\n                me.verticalTimeAxisColumn = me.columns.find(c => c.isVerticalTimeAxisColumn);\n                me.verticalTimeAxisColumn.relayAll(me);\n            }\n\n            // Set up event relaying early\n            timeAxisColumn.relayAll(me);\n        }\n    }\n\n    onColumnsChanged({ action, changes, record : column }) {\n        const { timeAxisColumn, columns } = this;\n        // If someone replaces the column set, ensure time axis is always added\n        if (action === 'dataset' && !columns.includes(timeAxisColumn)) {\n            columns.add(timeAxisColumn, true);\n        }\n        // TODO: Have ResourceHeader call this directly instead of relying on event?\n        else if (column === timeAxisColumn && 'width' in changes) {\n            this.updateCanvasSize();\n        }\n\n        super.onColumnsChanged(...arguments);\n    }\n\n    get timeView() {\n        const me = this;\n        // Maintainer, we need to ensure that the columns property is initialized\n        // if this getter is called at configuration time before columns have been ingested.\n        return me.columns && me.isVertical\n            ? (me.verticalTimeAxisColumn && me.verticalTimeAxisColumn.view)\n            : (me.timeAxisColumn && me.timeAxisColumn.timeAxisView);\n    }\n\n    updateEventCls(eventCls) {\n        const me = this;\n\n        if (!me.eventSelector) {\n            // No difference with new rendering, released have 'b-released' only\n            me.unreleasedEventSelector = me.eventSelector = `.${eventCls}-wrap`;\n        }\n        if (!me.eventInnerSelector) {\n            me.eventInnerSelector = `.${eventCls}`;\n        }\n    }\n\n    set timeAxisViewModel(timeAxisViewModel) {\n        const\n            me            = this,\n            currentModel  = me._timeAxisViewModel,\n            tavmListeners = {\n                name    : 'timeAxisViewModel',\n                update  : 'onTimeAxisViewModelUpdate',\n                prio    : 100,\n                thisObj : me\n            };\n\n        if ((me.partner && !timeAxisViewModel) || (currentModel && currentModel === timeAxisViewModel)) {\n            return;\n        }\n\n        if (currentModel?.owner === me) {\n            // We created this model, destroy it\n            currentModel.destroy();\n        }\n\n        me.detachListeners('timeAxisViewModel');\n\n        // Getting rid of instanceof check to allow using code from different bundles\n        if (timeAxisViewModel?.isTimeAxisViewModel) {\n            timeAxisViewModel.ion(tavmListeners);\n        }\n        else {\n            timeAxisViewModel = TimeAxisViewModel.new({\n                mode              : me._mode,\n                snap              : me.snap,\n                forceFit          : me.forceFit,\n                timeAxis          : me.timeAxis,\n                suppressFit       : me.suppressFit,\n                internalListeners : tavmListeners,\n                owner             : me\n            }, timeAxisViewModel);\n        }\n\n        // Replace in dependent classes relying on the model\n        if (!me.isConfiguring) {\n            if (me.isHorizontal) {\n                me.timeAxisColumn.timeAxisViewModel = timeAxisViewModel;\n            }\n            else {\n                me.verticalTimeAxisColumn.view.model = timeAxisViewModel;\n            }\n        }\n\n        me._timeAxisViewModel = timeAxisViewModel;\n\n        me.relayEvents(timeAxisViewModel, ['update'], 'timeAxisViewModel');\n\n        if (currentModel && timeAxisViewModel) {\n            me.trigger('timeAxisViewModelChange', { timeAxisViewModel });\n        }\n    }\n\n    /**\n     * The internal view model, describing the visual representation of the time axis.\n     * @property {Scheduler.view.model.TimeAxisViewModel}\n     * @readonly\n     * @category Time axis\n     */\n    get timeAxisViewModel() {\n        if (!this._timeAxisViewModel) {\n            this.timeAxisViewModel = null;\n        }\n        return this._timeAxisViewModel;\n    }\n\n    get suppressFit() {\n        return this._timeAxisViewModel?.suppressFit ?? this._suppressFit;\n    }\n\n    set suppressFit(value) {\n        if (this._timeAxisViewModel) {\n            this.timeAxisViewModel.suppressFit = value;\n        }\n        else {\n            this._suppressFit = value;\n        }\n    }\n\n    set timeAxis(timeAxis) {\n        const\n            me                = this,\n            currentTimeAxis   = me._timeAxis,\n            timeAxisListeners = {\n                name        : 'timeAxis',\n                reconfigure : 'onTimeAxisReconfigure',\n                thisObj     : me\n            };\n\n        if (me.partner && !timeAxis || (currentTimeAxis && currentTimeAxis === timeAxis)) {\n            return;\n        }\n\n        if (currentTimeAxis) {\n            if (currentTimeAxis.owner === me) {\n                // We created this model, destroy it\n                currentTimeAxis.destroy();\n            }\n        }\n\n        me.detachListeners('timeAxis');\n\n        // Getting rid of instanceof check to allow using code from different bundles\n        if (!timeAxis?.isTimeAxis) {\n            timeAxis = ObjectHelper.assign({\n                owner          : me,\n                viewPreset     : me.viewPreset,\n                autoAdjust     : me.autoAdjustTimeAxis,\n                weekStartDay   : me.weekStartDay,\n                forceFullTicks : me.fillTicks && me.snap\n            }, timeAxis);\n\n            if (me.startDate) {\n                timeAxis.startDate = me.startDate;\n            }\n            if (me.endDate) {\n                timeAxis.endDate = me.endDate;\n            }\n\n            if (me.workingTime) {\n                me.applyWorkingTime(timeAxis);\n            }\n\n            timeAxis = new TimeAxis(timeAxis);\n        }\n\n        // Inform about reconfiguring the timeaxis, to allow users to react to start & end date changes\n        timeAxis.ion(timeAxisListeners);\n\n        me._timeAxis = timeAxis;\n    }\n\n    onTimeAxisReconfigure({ config, oldConfig }) {\n        if (config) {\n            const dateRangeChange = !oldConfig || (oldConfig.startDate - config.startDate || oldConfig.endDate - config.endDate);\n\n            if (dateRangeChange) {\n                /**\n                 * Fired when the range of dates encapsulated by the UI changes. This will be when\n                 * moving a view in time by reconfiguring its {@link #config-timeAxis}. This will happen\n                 * when zooming, or changing {@link #config-viewPreset}.\n                 *\n                 * Contrast this with the {@link #event-visibleDateRangeChange} event which fires much\n                 * more frequently, during scrolling along the time axis and changing the __visible__\n                 * date range.\n                 * @event dateRangeChange\n                 * @param {Scheduler.view.TimelineBase} source This Scheduler/Gantt instance.\n                 * @param {Object} old The old date range\n                 * @param {Date} old.startDate the old start date.\n                 * @param {Date} old.endDate the old end date.\n                 * @param {Object} new The new date range\n                 * @param {Date} new.startDate the new start date.\n                 * @param {Date} new.endDate the new end date.\n                 */\n                this.trigger('dateRangeChange', {\n                    old : {\n                        startDate : oldConfig.startDate,\n                        endDate   : oldConfig.endDate\n                    },\n                    new : {\n                        startDate : config.startDate,\n                        endDate   : config.endDate\n                    }\n                });\n            }\n        }\n\n        /**\n         * Fired when the timeaxis has changed, for example by zooming or configuring a new time span.\n         * @event timeAxisChange\n         * @param {Scheduler.view.Scheduler} source - This Scheduler\n         * @param {Object} config Config object used to reconfigure the time axis.\n         * @param {Date} config.startDate New start date (if supplied)\n         * @param {Date} config.endDate New end date (if supplied)\n         */\n        this.trigger('timeAxisChange', { config });\n    }\n\n    get timeAxis() {\n        if (!this._timeAxis) {\n            this.timeAxis = null;\n        }\n        return this._timeAxis;\n    }\n\n    updateForceFit(value) {\n        if (this._timeAxisViewModel) {\n            this._timeAxisViewModel.forceFit = value;\n        }\n    }\n\n    /**\n     * Get/set working time. Assign `null` to stop using working time. See {@link #config-workingTime} config for details.\n     * @property {Object}\n     * @category Scheduled events\n     */\n    set workingTime(config) {\n        this._workingTime = config;\n\n        if (!this.isConfiguring) {\n            this.applyWorkingTime(this.timeAxis);\n        }\n    }\n\n    get workingTime() {\n        return this._workingTime;\n    }\n\n    // Translates the workingTime configs into TimeAxis#include rules, applies them and then refreshes the header and\n    // redraws the events\n    applyWorkingTime(timeAxis) {\n        const me = this,\n            config = me._workingTime;\n\n        if (config) {\n            let hour = null;\n            // Only use valid values\n            if (config.fromHour >= 0 && config.fromHour < 24 && config.toHour > config.fromHour && config.toHour <= 24 && config.toHour - config.fromHour < 24) {\n                hour = { from : config.fromHour, to : config.toHour };\n            }\n\n            let day = null;\n            // Only use valid values\n            if (config.fromDay >= 0 && config.fromDay < 7 && config.toDay > config.fromDay && config.toDay <= 7 && config.toDay - config.fromDay < 7) {\n                day = { from : config.fromDay, to : config.toDay };\n            }\n\n            if (hour || day) {\n                timeAxis.include = {\n                    hour,\n                    day\n                };\n            }\n            else {\n                // No valid rules, restore timeAxis\n                timeAxis.include = null;\n            }\n        }\n        else {\n            // No rules, restore timeAxis\n            timeAxis.include = null;\n        }\n\n        if (me.isPainted) {\n            // Refreshing header, which also recalculate tickSize and header data\n            me.timeAxisColumn.refreshHeader();\n            // Update column lines\n            me.features.columnLines?.refresh();\n\n            // Animate event changes\n            me.refreshWithTransition();\n        }\n    }\n\n    updateStartDate(date) {\n        this.setStartDate(date);\n    }\n\n    /**\n     * Sets the timeline start date.\n     *\n     * **Note:**\n     * - If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n     * - If keepDuration is false and new start date is greater than end date, it will throw an exception.\n     *\n     * @param {Date} date The new start date\n     * @param {Boolean} keepDuration Pass `true` to keep the duration of the timeline (\"move\" the timeline),\n     * `false` to change the duration (\"resize\" the timeline). Defaults to `true`.\n     */\n    setStartDate(date, keepDuration = true) {\n        const\n            me = this,\n            ta = me._timeAxis,\n            {\n                startDate,\n                endDate,\n                mainUnit\n            }  = ta || emptyObject;\n\n        if (typeof date === 'string') {\n            date = DateHelper.parse(date);\n        }\n\n        if (ta && endDate) {\n            if (date) {\n                let calcEndDate = endDate;\n\n                if (keepDuration && startDate) {\n                    const diff = DateHelper.diff(startDate, endDate, mainUnit, true);\n                    calcEndDate = DateHelper.add(date, diff, mainUnit);\n                }\n\n                me.setTimeSpan(date, calcEndDate);\n            }\n        }\n        else {\n            me._tempStartDate = date;\n        }\n    }\n\n    get startDate() {\n        const me = this;\n\n        if (me._timeAxis) {\n            return me._timeAxis.startDate;\n        }\n\n        return me._tempStartDate || new Date();\n    }\n\n    changeEndDate(date) {\n        if (typeof date === 'string') {\n            date = DateHelper.parse(date);\n        }\n        this.setEndDate(date);\n    }\n\n    /**\n     * Sets the timeline end date\n     *\n     * **Note:**\n     * - If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n     * - If keepDuration is false and new end date is less than start date, it will throw an exception.\n     *\n     * @param {Date} date The new end date\n     * @param {Boolean} keepDuration Pass `true` to keep the duration of the timeline (\"move\" the timeline),\n     * `false` to change the duration (\"resize\" the timeline). Defaults to `false`.\n     */\n    setEndDate(date, keepDuration = false) {\n        const\n            me = this,\n            ta = me._timeAxis,\n            {\n                startDate,\n                endDate,\n                mainUnit\n            }  = ta || emptyObject;\n\n        if (typeof date === 'string') {\n            date = DateHelper.parse(date);\n        }\n\n        if (ta && startDate) {\n            if (date) {\n                let calcStartDate = startDate;\n\n                if (keepDuration && endDate) {\n                    const diff = DateHelper.diff(startDate, endDate, mainUnit, true);\n                    calcStartDate = DateHelper.add(date, -diff, mainUnit);\n                }\n\n                me.setTimeSpan(calcStartDate, date);\n            }\n        }\n        else {\n            me._tempEndDate = date;\n        }\n    }\n\n    get endDate() {\n        const me = this;\n\n        if (me._timeAxis) {\n            return me._timeAxis.endDate;\n        }\n\n        return me._tempEndDate || DateHelper.add(me.startDate, me.viewPreset.defaultSpan, me.viewPreset.mainHeader.unit);\n    }\n\n    changeVisibleDate(options) {\n        return (options instanceof Date) ? { date : options } : options;\n    }\n\n    updateVisibleDate(options) {\n        const\n            me = this;\n\n        if (me.isPainted) {\n            me.scrollToDate(options.date, options);\n        }\n        else {\n            me.ion({\n                paint : () => me.scrollToDate(options.date, options),\n                once  : true\n            });\n        }\n    }\n\n    get features() {\n        return super.features;\n    }\n\n    // add region resize by default\n    set features(features) {\n        features = features === true ? {} : features;\n\n        if (!('regionResize' in features)) {\n            features.regionResize = true;\n        }\n\n        super.features = features;\n    }\n\n    get eventStyle() {\n        return this._eventStyle;\n    }\n\n    set eventStyle(style) {\n        this._eventStyle = style;\n\n        this.refreshWithTransition();\n\n        this.trigger('stateChange');\n    }\n\n    get eventColor() {\n        return this._eventColor;\n    }\n\n    set eventColor(color) {\n        this._eventColor = color;\n\n        this.refreshWithTransition();\n\n        this.trigger('stateChange');\n    }\n\n    //endregion\n\n    //region Event handlers\n\n    onLocaleChange() {\n        super.onLocaleChange();\n\n        const oldAutoAdjust = this.timeAxis.autoAdjust;\n        // Time axis should rebuild as weekStartDay may have changed\n        this.timeAxis.reconfigure({\n            autoAdjust : false\n        });\n\n        // Silently set it back to what the user had for next view refresh\n        this.timeAxis.autoAdjust = oldAutoAdjust;\n    }\n\n    /**\n     * Called when the element which encapsulates the Scheduler's visible height changes size.\n     * We only respond to *height* changes here. The TimeAxisSubGrid monitors its own width.\n     * @param {HTMLElement} element\n     * @param {DOMRect} oldRect\n     * @param {DOMRect} newRect\n     * @private\n     */\n    onBodyResize(element, oldRect, { width, height }) {\n        // Uncache old value upon element resize, not upon initial sizing\n        if (this.isVertical && oldRect && width !== oldRect.width) {\n            delete this.timeAxisSubGrid._width;\n        }\n\n        const newWidth = this.timeAxisSubGrid.element.offsetWidth;\n\n        // The Scheduler (The Grid) dictates the viewport height.\n        // Don't react on first invocation which will be initial size.\n        if (this._bodyRectangle && oldRect && (height !== oldRect.height)) {\n            this.onSchedulerViewportResize(newWidth, height, newWidth, oldRect.height);\n        }\n    }\n\n    // Note: This function is throttled in construct(), since it will do a full redraw per call\n    onSchedulerViewportResize(width, height, oldWidth, oldHeight) {\n        if (this.isPainted) {\n            const\n                me = this,\n                {\n                    isHorizontal,\n                    partneredWith\n                }  = me;\n\n            me.currentOrientation.onViewportResize(width, height, oldWidth, oldHeight);\n\n            // Raw width is always correct for horizontal layout because the TimeAxisSubGrid\n            // never shows a scrollbar. It's always contained by an owning Grid which shows\n            // the vertical scrollbar.\n            me.updateViewModelAvailableSpace(isHorizontal ? width : Math.floor(height));\n\n            if (partneredWith && !me.isSyncingFromPartner) {\n                me.syncPartnerSubGrids();\n            }\n\n            /**\n             * Fired when the *scheduler* viewport (not the overall Scheduler element) changes size.\n             * This happens when the grid changes height, or when the subgrid which encapsulates the\n             * scheduler column changes width.\n             * @event timelineViewportResize\n             * @param {Core.widget.Widget} source - This Scheduler\n             * @param {Number} width The new width\n             * @param {Number} height The new height\n             * @param {Number} oldWidth The old width\n             * @param {Number} oldHeight The old height\n             */\n            me.trigger('timelineViewportResize', { width, height, oldWidth, oldHeight });\n        }\n    }\n\n    updateViewModelAvailableSpace(space) {\n        this.timeAxisViewModel.availableSpace = space;\n    }\n\n    onTimeAxisViewModelUpdate() {\n        if (!this._viewPresetChanging) {\n            this.updateCanvasSize();\n            this.currentOrientation.onTimeAxisViewModelUpdate();\n        }\n    }\n\n    syncPartnerSubGrids() {\n        this.partneredWith.forEach(partner => {\n            if (!partner.isSyncingFromPartner) {\n                partner.isSyncingFromPartner = true;\n                this.eachSubGrid(subGrid => {\n                    const partnerSubGrid = partner.subGrids[subGrid.region];\n\n                    // If there is a difference, sync the partner SubGrid state\n                    if (partnerSubGrid.width !== subGrid.width) {\n                        if (subGrid.collapsed) {\n                            partnerSubGrid.collapse();\n                        }\n                        else {\n                            if (partnerSubGrid.collapsed) {\n                                partnerSubGrid.expand();\n                            }\n                            // When using flexed subgrid, make sure flex values has prio over width\n                            if (subGrid.flex) {\n                                // If flex values match, resize should be fine without changing anything\n                                if (subGrid.flex !== partnerSubGrid.flex) {\n                                    partnerSubGrid.flex = subGrid.flex;\n                                }\n                            }\n                            else {\n                                partnerSubGrid.width = subGrid.width;\n                            }\n                        }\n                    }\n                });\n                partner.isSyncingFromPartner = false;\n            }\n        });\n    }\n\n    //endregion\n\n    //region Mode\n\n    get currentOrientation() {\n        throw new Error('Implement in subclass');\n    }\n\n    // Horizontal is the default, overridden in scheduler\n    get isHorizontal() {\n        return true;\n    }\n\n    //endregion\n\n    //region Canvases and elements\n\n    get backgroundCanvas() {\n        return this._backgroundCanvas;\n    }\n\n    get foregroundCanvas() {\n        return this._foregroundCanvas;\n    }\n\n    get svgCanvas() {\n        const me = this;\n        if (!me._svgCanvas) {\n            const svg = me._svgCanvas = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n            svg.setAttribute('id', IdHelper.generateId('svg'));\n            // To not be recycled by DomSync\n            svg.retainElement = true;\n            me.foregroundCanvas.appendChild(svg);\n            me.trigger('svgCanvasCreated', { svg });\n        }\n        return me._svgCanvas;\n    }\n\n    /**\n     * Returns the subGrid containing the time axis\n     * @member {Grid.view.SubGrid} timeAxisSubGrid\n     * @readonly\n     * @category Time axis\n     */\n\n    /**\n     * Returns the html element for the subGrid containing the time axis\n     * @property {HTMLElement}\n     * @readonly\n     * @category Time axis\n     */\n    get timeAxisSubGridElement() {\n        // Hit a lot, caching the element (it will never change)\n\n        if (!this._timeAxisSubGridElement) {\n            // We need the TimeAxisSubGrid to exist, so regions must be initialized\n            this.getConfig('regions');\n\n            this._timeAxisSubGridElement = this.timeAxisColumn?.subGridElement;\n        }\n\n        return this._timeAxisSubGridElement;\n    }\n\n    updateCanvasSize() {\n        const\n            me            = this,\n            { totalSize } = me.timeAxisViewModel,\n            width         = me.isHorizontal ? totalSize : me.timeAxisColumn.width;\n\n        let result = false;\n\n        if (me.isVertical) {\n            // Ensure vertical scroll range accommodates the TimeAxis\n            if (me.isPainted) {\n                // We used to have a bug here from not including the row border in the total height. Border is now\n                // removed, but leaving code here just in case some client is using border\n                me.refreshTotalHeight(totalSize + me._rowBorderHeight, true);\n            }\n\n            // Canvas might need a height in vertical mode, if ticks does not fill height (suppressFit : true)\n            if (me.suppressFit) {\n                DomHelper.setLength(me.foregroundCanvas, 'height', totalSize);\n            }\n\n            result = true;\n        }\n\n        if (width !== me.$canvasWidth && me.foregroundCanvas) {\n            if (me.backgroundCanvas) {\n                DomHelper.setLength(me.backgroundCanvas, 'width', width);\n            }\n\n            DomHelper.setLength(me.foregroundCanvas, 'width', width);\n\n            me.$canvasWidth = width;\n\n            result = true;\n        }\n\n        return result;\n    }\n\n    /**\n     * A chainable function which Features may hook to add their own content to the timeaxis header.\n     * @param {Array} configs An array of domConfigs, append to it to have the config applied to the header\n     */\n    getHeaderDomConfigs(configs) {}\n\n    /**\n     * A chainable function which Features may hook to add their own content to the foreground canvas\n     * @param {Array} configs An array of domConfigs, append to it to have the config applied to the foreground canvas\n     */\n    getForegroundDomConfigs(configs) {}\n\n    //endregion\n\n    //region Grid overrides\n\n    async onStoreDataChange({ action }) {\n        const me = this;\n\n        // Only update the UI immediately if we are visible\n        if (me.isVisible) {\n            // When repopulating stores (pro and up on data reload), the engine is not in a valid state until committed.\n            // Dont want to commit here, since it might be repopulating multiple stores.\n            // Instead delay grids refresh until project is ready\n            if (action === 'dataset' && me.project.isRepopulatingStores) {\n                await me.project.await('refresh', false);\n            }\n\n            super.onStoreDataChange(...arguments);\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            me.whenVisible('refresh', me, [true]);\n        }\n    }\n\n    refresh(forceLayout = true) {\n        const me = this;\n\n        if (me.isPainted && !me.refreshSuspended) {\n            // We need to refresh if there are Features laying claim to the visible time axis.\n            // Or there are events which fall inside the time axis.\n            // Or (if no events fall inside the time axis) there are event elements to remove.\n            if (me.hasVisibleEvents || me.timeAxisSubGridElement.querySelector(me.eventSelector)) {\n                if (me.isEngineReady) {\n                    me.refreshRows(false, forceLayout);\n                }\n                else {\n                    me.refreshAfterProjectRefresh             = true;\n                    me.currentOrientation.refreshAllWhenReady = true;\n                }\n            }\n            // Even if there are no events in our timeline, Features\n            // assume there will be a refresh event from the RowManager\n            // after a refresh request so fire it here.\n            else {\n                me.rowManager.trigger('refresh');\n            }\n        }\n    }\n\n    render() {\n        const\n            me          = this,\n            schedulerEl = me.timeAxisSubGridElement;\n\n        if (me.useBackgroundCanvas) {\n            me._backgroundCanvas = DomHelper.createElement({\n                className   : 'b-sch-background-canvas',\n                parent      : schedulerEl,\n                nextSibling : schedulerEl.firstElementChild\n            });\n        }\n\n        // The font-size trick is no longer used by scheduler, since it allows per resource margins\n        const fgCanvas = me._foregroundCanvas = DomHelper.createElement({\n            className : 'b-sch-foreground-canvas',\n            style     : `font-size:${(me.rowHeight - me.resourceMargin * 2)}px`,\n            parent    : schedulerEl\n        });\n\n        me.timeAxisSubGrid.insertRowsBefore = fgCanvas;\n\n        // Size correctly in case ticks does not fill height\n        if (me.isVertical && me.suppressFit) {\n            me.updateCanvasSize();\n        }\n\n        super.render(...arguments);\n    }\n\n    // TODO: refreshRows -> refresh in grid?\n    refreshRows(returnToTop = false, reLayoutEvents = true) {\n        const me = this;\n\n        if (me.isConfiguring) {\n            return;\n        }\n\n        me.currentOrientation.refreshRows(reLayoutEvents);\n\n        super.refreshRows(returnToTop);\n    }\n\n    getCellDataFromEvent(event, includeSingleAxisMatch) {\n        if (includeSingleAxisMatch) {\n            includeSingleAxisMatch = !Boolean(event.target.closest('.b-sch-foreground-canvas'));\n        }\n        return super.getCellDataFromEvent(event, includeSingleAxisMatch);\n    }\n\n    //endregion\n\n    //region Other\n\n    // duration = false prevents transition\n    runWithTransition(fn, duration) {\n        const me = this;\n\n        // Do not attempt to enter animating state if we are not visible\n        if (me.isVisible) {\n            // Allow calling with true/false to keep code simpler in other places\n            if (duration == null || duration === true) {\n                duration = me.transitionDuration;\n            }\n\n            // Ask Grid superclass to enter the animated state if requested and enabled.\n            if (duration && me.enableEventAnimations) {\n                if (!me.hasTimeout('exitTransition')) {\n                    me.isAnimating = true;\n                }\n\n                // Exit animating state in duration milliseconds.\n                exitTransition.delay = duration;\n                me.setTimeout(exitTransition);\n            }\n        }\n\n        fn();\n    }\n\n    exitTransition() {\n        this.isAnimating = false;\n        this.trigger('transitionend');\n    }\n\n    // Awaited by CellEdit to make sure that the editor is not moved until row heights have transitioned, to avoid it\n    // ending up misaligned\n    async waitForAnimations() {\n        // If project is calculating, we should await that too. It might lead to transitions\n        if (!this.isEngineReady) {\n            await this.project.await('dataReady', false);\n        }\n\n        await super.waitForAnimations();\n    }\n\n    /**\n     * Refreshes the grid with transitions enabled.\n     */\n    refreshWithTransition(forceLayout, duration) {\n        // No point in starting a transition if we cant refresh anyway\n        if (this.isPainted && !this.refreshSuspended) {\n            this.runWithTransition(() => this.refresh(forceLayout), duration);\n        }\n    }\n\n    /**\n     * Returns an object representing the visible date range\n     * @property {Object}\n     * @property {Date} visibleDateRange.startDate\n     * @property {Date} visibleDateRange.endDate\n     * @readonly\n     * @category Dates\n     */\n    get visibleDateRange() {\n        return this.currentOrientation.visibleDateRange;\n    }\n\n    // This override will force row selection on timeaxis column selection, effectively disabling cell selection there\n    isRowNumberSelecting(...selectors) {\n        return super.isRowNumberSelecting(...selectors) ||\n            selectors.some(cs => cs.column ? cs.column.isTimeAxisColumn : cs.cell?.closest('.b-timeaxis-cell'));\n    }\n\n    //endregion\n\n    /**\n     * Returns a rounded duration value to be displayed in UI (tooltips, labels etc)\n     * @param {Number} The raw duration value\n     * @param {Number} [nbrDecimals] The number of decimals, defaults to {@link #config-durationDisplayPrecision}\n     * @returns {Number} The rounded duration\n     */\n    formatDuration(duration, nbrDecimals = this.durationDisplayPrecision) {\n        const multiplier =  Math.pow(10,  nbrDecimals);\n\n        return Math.round(duration * multiplier) / multiplier;\n    }\n\n    beginListeningForBatchedUpdates() {\n        this.listenToBatchedUpdates = (this.listenToBatchedUpdates || 0) + 1;\n    }\n\n    endListeningForBatchedUpdates() {\n        if (this.listenToBatchedUpdates) {\n            this.listenToBatchedUpdates -= 1;\n        }\n    }\n}\n\n// Register this widget type with its Factory\nTimelineBase.initClass();\n\n// Has to be here because Gantt extends TimelineBase\nVersionHelper.setVersion('scheduler', '5.3.0');\n"],"names":["Base","initialize","props","Object","assign","this","new","instance","CalendarCacheIntervalMultiple","constructor","config","intervalGroups","combineWith","interval","copy","slice","push","calendar","getIsWorkingForEvery","isWorkingForEvery","_calendar","intervals","getGroups","isWorking","getIsWorkingForSome","isWorkingForSome","getCalendars","calendars","isCalendarWorking","getCalendarsWorkStatus","get","calendarsWorkStatus","res","Map","set","getCalendarsWorking","calendarsWorking","getCalendarsNonWorking","calendarsNonWorking","intervalsByCalendar","forEach","data","apply","unique","stripDuplicates","sort","interval1","interval2","getPriorityField","CalendarCacheMultiple","CalendarCache","super","calendarCaches","intervalCache","IntervalCache","emptyInterval","combineIntervalsFn","fillCache","startDate","endDate","calendarCache","includeWrappingRangeFrom","COMBINED_CALENDARS_CACHE","combineCalendars","uniqueOnly","length","Error","calendar1","calendar2","internalId","hash","map","join","versionsHash","version","cached","cache","DurationColumn","NumberColumn","args","_defineProperty","$name","type","isGanttColumn","fields","name","defaultValue","defaults","min","max","step","largeStep","field","text","instantUpdate","filterType","sortable","durationEntity1","durationEntity2","construct","arguments","sortFn","call","defaultEditor","ObjectHelper","cleanupProperties","durationUnitField","formatValue","duration","durationUnit","Duration","unit","magnitude","nbrDecimals","grid","durationDisplayPrecision","decimalPrecision","multiplier","Math","pow","round","DateHelper","getLocalizedNameOfUnit","defaultRenderer","record","isExport","value","durationValue","toClipboardString","toString","fromClipboardString","string","parseDuration","fullDuration","calculateFillValue","isLastLevel","level","levels","isLastCell","cell","cells","ColumnStore","registerColumnType","_$name","TimeAxisBase","Widget","configurable","compactCellWidthThreshold","model","cls","sizeProperty","positionProperty","properties","size","range","me","refresh","buildCells","start","end","_me$client","stickyHeaders","isVertical","client","featureHeaderConfigs","cellConfigs","i","_level$cells","stickyHeader","className","position","viewPreset","mainHeaderLevel","syncOptions","releaseThreshold","syncIdField","dataset","headerFeature","headerPosition","children","filter","role","headerCellCls","align","_objectSpread","tickIndex","index","globalThis","DEBUG","date","getTime","style","coord","width","tag","html","getHeaderDomConfigs","widgetClassList","render","targetElement","rebuild","columnConfig","oldLevelsCount","reduce","sum","parentEl","element","parentElement","classList","remove","add","DomSync","sync","domConfig","trigger","widgetClass","HorizontalTimeAxis","_this$owner","owner","rtl","onModelUpdate","availableSpace","updateModel","timeAxisViewModel","detachListeners","ion","update","thisObj","ResourceHeader","scheduler","_resourceColumns","imagePath","EventHelper","on","delegate","capture","click","dblclick","contextmenu","changeShowAvatars","show","_this$avatarRendering","avatarRendering","destroy","AvatarRendering","updateShowAvatars","isConfiguring","updateResourceStore","store","changePreCommit","count","onResourceStoreDataChange","action","getConfig","updateWidthCache","totalWidth","variableColumnWidths","_fillWidth","_fitWidth","configuredFillWidth","configuredFitWidth","DomHelper","setLength","column","innerHTML","fitWidth","fillWidth","refreshWidths","toggleEmptyText","result","resourceStore","resource","instanceMeta","insetStart","insetEnd","columnWidth","resourceColumnWidth","changeColumnWidth","refreshingWidths","configuredColumnWidth","updateColumnWidth","oldWidth","changeFillWidth","updateFillWidth","changeFitWidth","updateFitWidth","getImageURL","imageName","StringHelper","joinPaths","updateImagePath","updateAvailableWidth","_me$resourceStore","availableWidth","useWidth","floor","shouldAnimate","enableEventAnimations","abs","_columnWidth","addTemporaryClass","visibleResources","firstResource","lastResource","groupField","isGrouped","groupers","configs","toggle","Boolean","currentGroup","_currentGroup","resourceRecord","allResourceRecords","groupRecord","groupParent","groupChildren","id","resourceId","groupLeft","groupWidth","left","encodeHtml","elementConfig","DomClassList","headerRenderer","imageUrl","image","_resourceRecord$name","toLowerCase","imageExtension","showAvatars","getResourceAvatar","initials","color","eventColor","iconCls","defaultImageUrl","defaultImageName","onlyChildren","onResourceMouseEvent","event","resourceCell","target","closest","getById","capitalize","getCurrentConfig","options","$config","TimeAxisColumn","Events","WidgetColumn","persist","draggable","groupable","hideable","showColumnPicker","filterable","resizable","searchable","editor","enableCellContextMenu","tooltipRenderer","needWidth","mode","region","exportable","htmlEncode","paint","once","autoExposeFields","doDestroy","_this$resourceColumns","_this$timeAxisView","resourceColumns","timeAxisView","resourceImagePath","resourceImageExtension","defaultResourceImageName","relayEvents","onViewModelUpdate","source","viewModel","refreshHeader","totalSize","subGrid","refreshFakeScroll","refreshRows","onTimelinePaint","firstPaint","_me$grid","insertRowsBefore","subGridElement","onHeightChange","internal","undefined","rendered","currentElement","internalRenderer","renderData","project","isInitialCommitPerformed","isDelayingCalculation","currentOrientation","renderer","_timeAxisViewModel","prio","getState","state","flex","ViewPreset","Model","normalizeUnits","generateId","headers","parts","getPrototypeOf","increment","multiple","includes","tickWidth","tickHeight","bottomHeader","IdHelper","timeResolution","shiftUnit","header","DH","normalizeUnit","splitUnit","normalizeHeaderConfig","headerConfig","columnLinesFor","top","middle","bottom","inSet","tickSize","_tickSize","mainHeader","leafUnit","leafIncrement","mainUnit","msPerPixel","asMilliseconds","isValid","valid","PresetStore","Localizable","Store","defaultConfig","useRawData","modelClass","zoomOrder","storage","addSorter","lhs","rhs","leftBottomHeader","rightBottomHeader","unitMagnitudes","isPresetManager","PresetManager","createRecord","isViewPreset","base","copyBaseValues","getAt","updateLocalization","presets","allRecords","Set","concat","values","basePresets","preset","localePreset","optionalL","baseId","originalDisplayDateFormat","displayDateFormat","topDateFormat","middleDateFormat","setData","levelConfig","localeLevelDateFormat","originalDateFormat","dateFormat","unlocalizedName","presetData","clone","merge","Array","isArray","originalData","pm","preventSubClassingModel","secondAndMinute","shiftIncrement","defaultSpan","minuteAndHour","hourAndDay","day","format","week","dayAndWeek","getShortNameOfUnit","dayAndMonth","weekAndDay","weekAndMonth","weekAndDayLetter","verticalColumnWidth","weekDateAndMonth","monthAndYear","year","cfg","toUpperCase","getMonth","manyYears","getFullYear","defaultPresets","resolution","resolutionUnit","internalListeners","locale","presetCache","_basePresets","presetAdjustment","isBase","baseType","setPrototypeOf","height","getUnitByName","registerPreset","existingDuplicate","find","p","equals","getPreset","normalizePreset","deletePreset","presetOrId","Tick","TimeSpan","TimeAxis","continuous","originalContinuous","include","autoAdjust","adjustedStart","adjustedEnd","visibleTickStart","visibleTickEnd","tickCache","disableDuplicateIdCheck","disableDefaultValue","disableTypeConversion","generateTicks","resolutionIncrement","weekStartDay","forceFullTicks","change","supressRefresh","endreconfigure","internalOnReconfigure","getAdjustedDates","Date","isTimeAxis","reconfigure","suppressRefresh","preventThrow","normalized","oldConfig","_configuredStartDate","_configuredEndDate","propName","isConfigured","adjusted","ticks","suspendEvents","resumeEvents","first","last","isContinuous","getNext","updateVisibleTickBoundaries","updateTickCache","startDenominator","getNormalizedUnitDuration","endDenominator","fullTicks","_viewPreset","presetName","_this$_weekStartDay","_weekStartDay","_resolutionUnit","_resolutionIncrement","setTimeSpan","newStartDate","newEndDate","shift","amount","isFiltered","allCount","tries","shiftNext","shiftPrevious","filterBy","fn","filters","clear","tick","clearFilters","triggerFilterEvent","forceAdjust","floorDate","ceilDate","_start","parse","_end","startMS","_startMS","endMS","_endMS","relativeToStart","incr","relativeTo","snap","snappedDuration","diff","dt","getDay","startDay","startOf","getHours","modifier","useUnit","snappedValue","roundDate","toAdd","distanceToWeekStartDay","nbrMonths","as","daysInMonth","snappedMonths","offset","getTimezoneOffset","doCall","isStartOf","isEqual","getDate","_include","processExclusion","entries","some","includeUnit","rule","from","to","compareUnits","getLargerUnit","stepUnit","datePart","initExclusion","lengthFactor","getUnitToBaseUnitRatio","lengthFactorExcl","center","updateGenerateTicks","_generateTicks","axisStartDate","axisEndDate","usesExclusion","intervalEnd","tickEnd","isExcluded","dstDiff","prev","visibleTickTimeSpan","getTickFromDate","_date$getTime","_date$getTime2","records","dateMS","tickStart","begin","startDateMS","endDateMS","getDateFromTick","roundingMethod","wholeTick","fraction","t","onlyStartEnd","_startMs","dateInAxis","inclusiveEnd","axisStart","axisEnd","betweenLesserEqual","betweenLesser","getCount","timeSpanInAxis","intersectSpans","isTimeSpanInAxis","timeSpan","startTick","endTick","forEachAuxInterval","iteratorFn","DragBase","InstancePlugin","tooltipTemplate","startClockHtml","endClockHtml","message","showTooltip","showExactDropPosition","dragHelperConfig","tooltipCls","constrainDragToTimeline","constrainDragToResource","constrainDragToTimeSlot","tip","allowTargetOut","autoShow","updateContentOnMouseMove","throttleDragEvent","pluginConfig","chain","internalSnapToPosition","snapTo","_this$snapToPosition","dragData","snapToPosition","assignmentRecord","eventRecord","newResource","buildDragHelperConfig","isHorizontal","lockY","lockX","externalDropTargetSelector","dropTargetSelector","Objects","positioning","minX","maxX","constrain","cloneTarget","removeProxyAfterDrop","dragWithin","document","body","hideOriginalElement","dropTargetCls","outerElement","timeAxisSubGridElement","targetSelector","eventSelector","scrollManager","createProxy","el","snapCoordinates","newX","newY","draggedEventRecord","draggedEntities","coordinate","getCoordinate","snappedDate","getDateFromPosition","isWorkingTime","snappedPosition","getPositionFromDate","x","y","beforedragstart","dragstart","afterdragstart","drag","drop","abort","abortFinalized","reset","isElementDraggable","onPaint","_me$drag","DragHelper","rowManager","changeTotalHeight","_me$dragData","updateYConstraint","scheduledEventName","clockTemplate","ClockTemplate","_this$drag","_this$clockTemplate","_this$tip","tipId","changeTip","oldTip","Tooltip","mergeConfigs","forElement","getHtml","getTipHtml","bind","innerHtmlUpdate","proxy","cloneNode","onBeforeDragStart","context","getMinimalDragData","readOnly","disabled","isDraggable","pointerStartDate","getDateFromXY","startClientX","startPageY","triggerBeforeEventDrag","capitalizedEventName","_client","onAfterDragStart","isDragging","_this$drag2","isActivelyDragging","finalizing","onDragStart","_me$findClientFromTar","_client2","_menuFeature$hideCont","findClientFromTarget","currentOverClient","unifiedProxy","unifiedDrag","onMouseOverNewTimeline","getDragData","suspendElementRedrawing","tipTarget","dragProxy","firstChild","showBy","triggerDragStart","eventMenu","taskMenu","features","menuFeature","hideContextMenu","updateDateIndicator","endDateElement","querySelector","test","Rectangle","elementFromPoint","fromElement","isResourceHistogram","onDrag","dd","updateDragContext","dirty","triggerEventDrag","externalDragValidity","lastAlignSpec","realign","newTimeline","initial","scrollables","stopMonitoring","timeAxisSubGrid","scrollable","direction","startMonitoring","callback","onScrollManagerScrollCallback","triggerBeforeEventDropFinalize","eventType","eventData","onDrop","_me$tip","modified","hide","isValidDrop","externalDropTarget","beforeDropTriggered","finalize","async","domEvent","origStart","onDragAbort","_me$tip2","resetDraggedElements","triggerDragAbort","onDragAbortFinalized","_me$client2","triggerDragAbortFinalized","onDragReset","dragHelper","_dragHelper$context","currentTimeline","started","eventBarEls","resumeRecordElementRedrawing","draggingCls","retainElement","onInternalInvalidDrop","_me$tip3","triggerAfterDrop","updateRecords","isPromise","info","isAssignment","lastDragStartDate","constrainToTimeSlot","browserEvent","getProductDragContext","timeDiff","dateConstraints","timeAxis","_info$pageX","_info$pageY","timeAxisPosition","pageX","startPageX","pageY","pointerDate","getDateFromCoordinate","resolveStartEndDates","adjustStartDate","durationMS","positionDirty","L","checkDragValidity","_dd$externalDragValid","suspendRecordElementRedrawing","suspend","getRecordElement","resumeElementRedrawing","productDragData","setupProductDragData","startEvent","timespan","origEnd","startsOutsideView","endsOutsideView","multiSelect","isSchedulerBase","multiEventSelect","selectionMode","elementStartX","elementStartY","clientCoordinate","startClientY","selectAssignment","ctrlKey","selectEvent","sourceDate","screenSourceDate","relatedElements","setupConstraints","constrainRegion","elRegion","constrained","xTickSize","setXConstraint","right","setYConstraint","snapPixelAmount","getScheduleRegion","offsetHeight","iLeft","iRight","iTickSize","iUp","iDown","minY","maxY","snapRelativeToEventStartDate","draggedElement","timeline","proxyRect","eventInnerSelector","getStartEndDatesFromRectangle","startText","getFormattedDate","endText","getFormattedEndDate","dragged","timeSpanRecord","isTask","template","isMilestone","updateConstrainDragToTimeSlot","axis","updateConstrainDragToResource","updateConstrainDragToTimeline","getElementFromContext","grabbed","getRelatedRecords","tipAlign","EventResize","mixin","Draggable","Droppable","draggingItemCls","resizingItemInnerCls","leftHandle","rightHandle","topHandle","bottomHandle","handleSize","dynamicHandleSize","allowResizeToZero","reservedSpace","touchHandleSize","dragThreshold","dragTouchStartDelay","draggingClsSelector","showExactResizePosition","validatorFn","validatorFnThisObj","axisLock","trackMouse","hideDelay","ignoreSelector","dragActiveCls","_this$dragging","dragging","dragSelector","dragItemSelector","dragRootElement","dropRootElement","dragLock","isEventElementDraggable","eventElement","eventResizable","isOverStartHandle","isOverEndHandle","onEventDataGenerated","wrapperCls","_this$dragging2","_this$dragging2$conte","onDragPointerMove","_dragging$context","visibleDateRange","dimension","pageScroll","clientRect","startCoord","getStart","endCoord","getEnd","getDateFromCoord","local","clientStartCoord","clientEndCoord","isResizing","beforeDrag","resolveTimeSpanRecord","itemElement","isGanttBase","resolveResourceRecord","isOccurrence","mousedownDate","triggerBeforeResize","dragStart","_client$features$even","_client$resolveAssign","resolveEventRecord","isBatchUpdating","wrapStartDate","wrapEndDate","useEventBuffer","eventBuffer","enabled","eventStartDate","eventEndDate","horizontal","draggingEnd","toSet","wrapToSet","otherEnd","setMethod","setOtherMethod","elRect","clientX","clientY","timespanRecord","taskRecord","oldValue","edge","originalStartDate","originalEndDate","meta","split","listenToBatchedUpdates","beginListeningForBatchedUpdates","beginEventRecordBatch","setupProductResizeContext","triggerEventResizeStart","getResizeStartParams","resizedRecord","resolveAssignmentRecord","getTooltipTarget","getBeforeResizeParams","_this$client","_this$client2","triggerEventResizeEnd","triggerEventPartialResize","triggerBeforeEventResizeFinalize","dragEnter","_drag$context","resizeEventPartiallyInternal","_client$features$even2","applyDateConstraints","_context$dateConstrai","_context$dateConstrai2","minDate","maxDate","moveDrag","eventStart","eventEnd","isScroll","crossedOver","avoidedZeroSize","onDragEndSwitch","isEventDragCreate","tooNarrow","sign","checkValidity","partialResizeEvent","stores","eventStore","alignTo","dragEnd","aborted","getPagePoint","cleanup","dragDrop","updateRecord","wasChanged","internalUpdateRecord","cancelEventRecordBatch","resources","repaintEventsForResource","changed","endListeningForBatchedUpdates","unHighlightHandle","getResizeEndParams","generation","batching","prototype","inSetNormalize","isEntity","_client$features$even3","run","setOtherEnd","promisesToWait","Promise","all","endBatch","batchChanges","commitAsync","onDragItemMouseMove","pointerType","handleSelector","checkResizeHandles","overItem","allowResize","isOverAnyHandle","highlightHandle","onDragItemMouseLeave","oldOverItem","_item$syncIdMap$clien","_item$syncIdMap","item","syncIdMap","_item$syncIdMap$me$cl","_item$syncIdMap2","inner","_this$getHandleRect","getHandleRect","contains","_this$getHandleRect2","side","eventEl","eventCls","dim","handleSpec","offsetWidth","isResizable","eventRect","handleStyle","window","getComputedStyle","BrowserHelper","isHoverableDevice","parseFloat","handleVisThresh","handleVisibilityThreshold","centerGap","deflateArgs","deflate","constrainTo","setupDragContext","isElementResizable","changeHandleSize","VersionHelper","deprecate","changeTouchHandleSize","isTooltip","innerhtmlupdate","_me$clockTemplate","_element$syncIdMap$cl","_element","handleHoldingElement","handleEl","startsOutside","endsOutside","anchorSize","basicValidityCheck","tipData","beginBatch","cancelBatch","_client$resolveResour","_client$resolveAssign2","_client$getDateConstr","getDateConstraints","allowOverlap","isDateRangeAvailable","GridFeatureManager","registerFeature","getDragCreateDragDistance","_this$source","_this$source$client$f","taskEdit","_canceling","getDistanceBetween","DragCreateBase","changeValidatorFn","createValidatorFn","initialDate","pan","eventDragSelect","preventMultiple","isRowEmpty","rowRecord","startDrag","proxyElement","matchScheduleCell","$original","isSpecialRow","monitoringConfig","getDistance","updateDragTolerance","dragTolerance","doCreate","completeFinalization","isDestroyed","_me$onAborted","finalizeDragCreate","onAborted","_this$tip2","onElementContextMenu","prepareCreateContextForFinalization","createContext","_this$dragging$contex","triggerDragCreateEnd","newRecord","handleBeforeDragCreate","dateTime","tipTemplate","before","TooltipBase","autoUpdate","hoverDelay","monitorRecordUpdate","testConfig","processConfig","forSelector","_me$tooltip","tooltip","setConfig","destroyProperties","doDisable","disable","_me$tooltip2","tipCls","scrollAction","showOnHover","anchorToTarget","configuredListeners","overtarget","processConfiguredListeners","addListener","_this$tooltip","defaultDetacher","tooltipDetacher","removeListener","_this$tooltip2","activeTarget","recordProp","recordType","endDateValue","getDisplayEndDate","onTipShow","updateListener","onRecordUpdate","onTipHide","_this$updateListener","onOverNewTarget","newTarget","updateContent","AbstractTimeRanges","Delayable","rangeCls","lineCls","enableResizing","dragTipTemplate","baseCls","bodyRenderer","narrowThreshold","renderRows","onUIReady","$$name","baseSelector","showHeaderElements","_me$resize","resize","renderRanges","setupTimeAxisViewModelListeners","includeChange","timeAxisViewModelChange","hideHeaders","headerContainerElement","onTimeRangeClick","rtlSource","ResizeHelper","matches","resizestart","resizing","cancel","resizeHelperConfig","hoverTooltip","timeRange","resolveTimeRangeRecord","_timeRanges","getDOMConfig","bodyConfigs","headerConfigs","_labelRotationMap","timeRanges","renderRange","bodyConfig","foregroundCanvas","isPainted","updatedBodyElements","bodyCanvas","createElement","parent","childrenOnly","headerCanvas","bodyElement","cacheRotation","elementData","applyRotation","shouldRenderRange","rangeStart","rangeEnd","_lineBufferDurationMS","getRangeDomConfig","startPos","getCoordinateFromDate","respectExclusion","endPos","isEnd","isRange","translateX","icon","xss","labelTpl","showLabelInBody","label","firstElementChild","recurringTimeSpan","_range$recurringTimeS","_range$recurringTimeS2","_bodyElement$firstEle","rotate","getBodyElementByRecord","idOrRecord","getChild","timeView","timeAxisColumn","_headerContainerElement","_showHeaderElements","updateShowHeaderElements","populateTimeAxisHeaderMenu","items","onSchedulerHorizontalScroll","afterScroll","onInternalResize","newWidth","newHeight","oldHeight","onTimeAxisViewModelUpdate","timeRangeRecord","showTip","destroyTip","Number","MAX_SAFE_INTEGER","onInvalidDrop","onResizeStart","onResizeDrag","onResize","onInvalidResize","onResizeReset","box","emptyObject","freeze","ColumnLines","delayable","cancelOutstanding","after","useBackgroundCanvas","getColumnLinesDOMConfig","m","linesForLevel","majorLinesForLevel","domConfigs","dates","addLineConfig","isMajor","has","transform","line","columnLines","getResourceRange","backgroundCanvas","onVisibleDateRangeChange","onVisibleResourceRangeChange","updateCanvasSize","Target","allowDropOnEventBar","showCreationTooltip","creationTooltip","terminalCls","terminalSides","allowCreate","view","eventName","updateCreateListeners","_me$pointerUpMoveDeta","_me$creationTooltip","creationData","pointerUpMoveDetacher","isCreateAllowed","_allowCreate","onTimeSpanMouseEnter","isCreating","nestedEvents","isRoot","eventBarElement","down","showTerminals","timeSpanElement","onOverTargetEventBar","onTimeSpanMouseLeave","_event$event","timeSpanLeft","relatedTarget","isDescendant","isTrusted","sourceElement","hideTerminals","onOverNewTargetWhileCreating","onTerminalMouseOver","onTerminalMouseOut","showingTerminalsFor","unhover","onTerminalPointerDown","button","_scheduler$resolveRes","terminalNode","viewBounds","stopPropagation","fromSide","startPoint","startX","scrollLeft","startY","scrollTop","sourceResource","pointerup","getRootNode","handler","passive","pointermove","documentPointerUpDetacher","keydown","key","onElementTouchMove","_super$onElementTouch","connector","preventDefault","onMouseMove","deltaX","deltaY","sqrt","angle","atan2","onRequestDragCreate","lastMouseMoveEvent","createConnector","createDragTooltip","_overEventRecord","overEventRecord","isEventSegment","removeClsGlobally","_data$timeSpanElement","_data$timeSpanElement2","dependencyType","toSide","getTargetSideFromType","dependencyStore","fieldMap","DependencyBaseModel","Type","EndToStart","targetResource","updateValidity","StartToStart","StartToEnd","EndToEnd","isValidDependency","validityCls","updateCreationTooltip","onMouseUp","_me$pointerUpMoveDeta2","dependency","createDependency","doAfterDependencyDrop","onDocumentMouseUp","_me$pointerUpMoveDeta3","_me$documentPointerUp","getElementFromEventRecord","removeConnector","clearTimeout","removeConnectorTimeout","loadingMsg","dock","beforeShow","setTimeout","terminalsVisibleCls","fixSide","terminal","feature","detacher","mouseover","mouseout","pointerdown","internalCls","eventParams","getTimeSpanMouseEventParams","forEachSelector","newDependency","resolve","then","creationTooltipTemplate","_data$target$name","_data$target","tipTitleIconClsSuffix","tipTitleText","fromText","toText","title","ref","_class","getDependenciesToConsider","startIndex","endIndex","gridCache","dependencies","fromMSCell","MS_PER_CELL","toMSCell","fromRowCell","toRowCell","msCell","j","intersectingDependencies","afterDrawDependency","fromIndex","toIndex","fromDateMS","toDateMS","constructGridCache","timeAxisStartMS","timeAxisEndMS","timeAxisCells","ceil","firstMSCell","lastMSCell","firstRowCell","lastRowCell","startMSCell","endMSCell","_me$gridCache$i","_msCell$j","beforeDraw","afterDraw","THRESHOLD","devicePixelRatio","BOX_PROPERTIES","equalEnough","a","b","RectangularPathFinder","startSide","startArrowMargin","startShift","endSide","endArrowMargin","endShift","verticalMargin","horizontalMargin","otherBoxes","findPath","lineDef","noPathFallbackFn","originalLineDef","lineDefFull","startBox","endBox","startHorizontalMargin","startVerticalMargin","endHorizontalMargin","endVerticalMargin","otherHorizontalMargin","otherVerticalMargin","connStartPoint","connEndPoint","pathStartPoint","pathEndPoint","gridStartPoint","gridEndPoint","startGridBox","endGridBox","path","tryNum","ArrayHelper","asArray","_otherBoxes","hasOwnProperty","normalizeSide","getConnectionCoordinatesFromBoxSideShift","calcGridBaseBoxFromBoxAndDrawParams","property","shouldLookForPath","buildPathGrid","convertDecartPointToGridPoint","findPathOnGrid","prependPathWithArrowStaffSegment","appendPathWithArrowStaffSegment","optimizePath","calculateRelativePosition","box1","box2","vertical","startProp","endProp","boxOverlapChanged","gridStartBox","gridEndBox","calculateOverlap","coords","arrowMargin","gridBox","otherGridBoxes","xs","ys","ix","iy","xslen","yslen","ib","blen","permitted","point","points","linearPoints","distance","indexOf","waveForward","collectPath","getGridPointNeighbors","gridPoint","predicateFn","neighbor","WalkHelper","preWalkUnordered","neighborPoint","neighbors","lowestDistanceNeighbor","xDiff","yDiff","pathFound","resultA","resultB","x1","y1","x2","y2","reverse","firstSegment","prependSegment","unshift","lastSegment","appendSegment","optPath","prevSegment","curSegment","drawingDirection","pointSet","segmentLength","nextPointSet","location","radius","prevRadius","useRadius","nextLength","useLength","corner","rx","ry","arc","currentRadius","pathMapper","lineSpec","onSVGReady","pathFinder","pathFinderConfig","lineDefAdjusters","createLineDefAdjusters","createMarker","changeRadius","assertNumber","updateRadius","updateRenderer","changeClickWidth","updateClickWidth","_me$marker","_me$markerDef","markerDef","svg","svgCanvas","markerId","marker","setProperty","ns","markerHeight","markerWidth","refX","refY","viewBox","orient","markerUnits","d","updateMarkerDef","getAssignmentElement","assignment","_this$client$features","eventDrag","getProxyElement","getElementFromAssignmentRecord","getDomConfigs","fromAssignment","toAssignment","forceBoxes","getDependencyKey","lineCache","constructLineCache","drawingLive","prepareLineDef","clickWidth","toEvent","_me$radius","_me$renderer","highlighted","syncId","depId","fromId","toId","class","noMarkerCls","hideMarker","active","bidirectional","milestone","dependencyRecord","fromAssignmentRecord","toAssignmentRecord","fromBox","toBox","strokeWidth","generateBoundaryBoxes","rowTop","rowBottom","getAssignmentBounds","isExporting","rectangle","row","getRowById","overRow","getRowAt","isEngineReady","getAssignmentEventBox","getConnectorStartSide","getConnectorEndSide","getDependencyStartSide","fromEvent","DependencyModel","getDependencyEndSide","barMargin","adjustLineDef","_forceBoxes$from","_forceBoxes$to","startRectangle","endRectangle","keys","fromBoxSide","toBoxSide","changeTooltip","old","textContent","getHoverTipHtml","resolveDependencyRecord","eventNameMap","collectLinkedAssignments","_assignment$resource","hasLinks","$links","l","drawDependencies","Dependencies","AttachToProjectMixin","DependencyCreation","DependencyGridCache","DependencyLineGenerator","DependencyTooltip","svgCanvasCreated","animationStart","timelineViewportResize","timeAxisViewModelUpdate","toggleNode","bindStore","_isDisabling","draw","rowStore","usesDisplayStore","onStoreRefresh","attachToProject","commitFinalized","attachToResourceStore","onResourceStoreChange","usingLinks","attachToEventStore","attachToAssignmentStore","assignmentStore","attachToDependencyStore","updateDrawOnScroll","drawOnScroll","scroll","horizontalScroll","scrollEnd","onHorizontalScroll","scrollX","lastScrollX","getLocalizedDependencyType","getElementForDependency","getElementsForDependency","selector","querySelectorAll","_element$elementData","isDependencyElement","onElementClick","onElementDblClick","onElementMouseOver","overCls","highlight","onElementMouseOut","unhighlight","isDependencyVisible","fromResource","toResource","isAvailable","isModel","hidden","updateHighlightDependenciesOnEventHover","enable","params","highlightEventDependencies","unhighlightEventDependencies","classes","delete","dep","_super$getDependencie","_super$getDependencie2","drawDependency","batch","_fromAssigned","_toAssigned","topIndex","bottomIndex","useInitialAnimation","idMap","fromAssigned","assigned","toAssigned","isScheduled","flatMap","_idMap$from$resource$","_from$resource","_idMap$to$resource$id","_to$resource","lineDomConfigs","animationDelay","domSync","_super$afterDrawDepen","_super$beforeDraw","_super$afterDraw","flat","strict","fillDrawingCache","r","refreshSuspended","firstVisibleRow","lastVisibleRow","doRefresh","_client$features","_client$features2","_client$features3","_client$features4","isAnimating","_super$reset","drawForEvent","highlightDependenciesOnEventHover","EventFilter","eventsFilter","localeClass","weight","menu","nameFilter","clearable","keyStrokeChangeDelay","onEventFilterChange","onBeforeShow","filterByName","getBy","removeFilter","featureClass","getNonWorkingTimeRanges","forEachAvailabilityInterval","isForward","intervalStartDate","intervalEndDate","calendarCacheInterval","entry","getIsWorking","getCalendarTimeRanges","ignoreName","fillTicks","shouldPaint","maxTimeAxisUnit","timeSpans","mergedSpans","prevRange","span","setStartEndDate","setupDefaultCalendar","autoGeneratedWeekends","isSchedulerPro","isGantt","effectiveCalendar","defaultCalendar","intervalStore","updateDefaultCalendar","defaultNonWorkingIntervals","hasIntervals","clearIntervals","addIntervals","_super$updateLocaliza","dayNames","nonWorkingDaysAsArray","dayIndex","recurrentStartDate","recurrentEndDate","NonWorkingTime","NonWorkingTimeMixin","highlightWeekends","hideRangesOnZooming","attachToCalendar","onConfigChange","graph","isScheduler","dataReady","calendarChange","_timeAxisUnitDurationMs","isDestroying","isCalculated","_this$project","timeAxisUnitDurationMs","ScheduleTooltip","messageTemplate","hideForNonWorkingTime","reshowListener","hoverTip","allowOver","monitorResize","onDocumentMouseDown","mousemove","e","internalOnPointerOver","hideAnimation","pointerover","buttonsPressed","buttons","which","lastTime","updateTip","isVisible","getDateFromDomEvent","lastHtml","lastResourceId","generateTipContent","clockHtml","generateContent","messageHtml","getText","setTimeSpanOptions","maintainVisibleStart","TimeAxisHeaderMenu","HeaderMenu","processItems","triggerEvent","zoomOnTimeAxisDoubleClick","shouldShowMenu","enableHeaderContextMenu","showContextMenu","dateStep","zoomLevel","zoomSlider","minWidth","showValue","zoom","minZoomLevel","maxZoomLevel","zoomDetatcher","input","onHide","dateRange","startDateField","labelWidth","required","onRangeDateFieldChange","endDateField","leftShiftBtn","margin","onLeftShiftBtnClick","todayBtn","onTodayBtnClick","rightShiftBtn","onRightShiftBtnClick","initDateRangeFields","onZoomSliderChange","delay","widgetMap","initDates","startDateFieldInitialValue","endDateFieldInitialValue","startDateChanged","today","clearTime","TimeAxisViewModel","forceFit","suppressFit","originalTickSize","headersDatesCache","unitToPixelsCache","consumeViewPreset","configured","un","onTimeAxisReconfigure","calculateInfiniteScrollingDateRange","centered","bufferCoef","halfSpan","bufferedTicks","_columnConfig","_headers","cellGenerator","isTimeAxisViewModel","_forceFit","silent","forceUpdate","_availableSpace","calculateTickSize","_totalSize","pos","headerCells","createHeaderRow","getDistanceBetweenDates","getDistanceForDuration","durationMs","getSingleUnitInPixels","getScaledTick","snapToNextIncluded","tickChanged","hour","originalHours","croppedHours","newHours","getMinutes","checkDay","getSeconds","getMilliseconds","addDays","fixedCenter","fractionalDay","newDay","allowOutOfRange","getScaledPosition","dayWidth","positionInWeek","positionInDay","setTickSize","suppressEvent","proposedSize","timelineUnit","ratio","fittingSize","space","newTickSize","getDates","useLowestHeader","lowestHeader","majorLevel","majorHeaderLevel","levelUnit","majorUnit","validMajor","doesUnitsAlign","forEachInterval","isMajorTick","fitToAvailableSpace","_snap","headerRowConfig","tickLevel","createCellContext","isLast","isInteriorTick","cellData","nextLevel","forEachMainInterval","tempDate","getRtlX","ignoreRTL","translateToScheduleCoordinate","xy","rect","_displayDateFormat","getYear","formatContainsHourInfo","valueOf","setTime","translateToPageCoordinate","getTimeSpanDistance","viewportCenterDate","timelineScroller","timeAxisOffset","clientSize","scrollSize","viewportCenterDateCached","cachedCenterDate","_this$_timeAxisViewMo","_this$_timeAxisViewMo2","updateSnap","scrollingToCenter","initDomEvents","schedulerEvents","schedulerEnterLeaveEvents","supportsPointerEventConstructor","getScheduleMouseEventParams","handleScheduleEvent","timelineContext","getTimelineEventContext","lastPointerEvent","handleScheduleEnterLeaveEvent","onScheduleScroll","_me$features$pan","updateTimelineContextOnScroll","isActive","partners","_p$features$pan","pointerEvent","PointerEvent","mouseEvent","MouseEvent","scrollInitiated","dispatchEvent","updateTimelineContext","oldContext","cellElement","getCellElementFromDomEvent","clickedDate","DomDataStore","mouseParams","dataIndex","isTimelineContext","tickStartDate","tickEndDate","tickParentIndex","parentIndex","getCell","resolveRowRecord","_me$rowManager$getRow","timeCellSelector","onElementMouseButtonEvent","contextMenu","onElementMouseDown","_me$features$eventDra","hoveredEvents","unhoverAll","preventOverCls","overScheduledEventClass","_me$features$eventDra2","eventInner","eventWrap","isReleased","equal","c1","c2","mousedown","mouseup","mouseenter","mouseleave","datesDiffer","d1","d2","changePresets","presetRecord","presetStore","changeViewPreset","oldViewPreset","lastOpts","lastViewPresetOptions","presetChanged","optionsChanged","centerDate","updateViewPreset","_timeAxis","zoomDate","zoomPosition","_viewPresetChanging","suspendRefresh","timeAxisCfg","copyProperties","infiniteScroll","resumeRefresh","notScroll","milliseconds","targetDate","scrollBy","viewportSize","scrollHorizontallyTo","scrollVerticallyTo","scrollTo","presetId","updateFromHorizontalScroll","updateFromVerticalScroll","_presets","zoomOnMouseWheel","visibleZoomFactor","zoomKeepsOriginalTimespan","wheel","throttled","buffer","alt","timeaxisheaderdblclick","zoomToSpan","_maxZoomLevel","_minZoomLevel","zoomToLevel","getMilliSecondsPerPixelForZoomLevel","ignoreActualWidth","actualWidth","zoomTo","tickSizeProp","newPreset","configuredTickSize","scrollableViewportSize","clientHeight","calculateOptimalDateRange","isZooming","zoomToFit","getTotalTimeSpan","leftMargin","rightMargin","scrollToDate","adjustStart","adjustEnd","needToAdjust","diffMS","inc","currLevel","candidateLevel","levelToZoom","spanWidth","unitToZoom","tickCount","getDurationInUnit","customWidth","block","zoomIn","currentZoomLevelIndex","zoomOut","zoomInFull","zoomOutFull","userProvidedSpan","difference","onElementMouseMove","zoomContext","onWheel","now","performance","viewport","lastWheelTime","resourceMargin","managedEventSizing","generatedIdCls","dirtyCls","committingCls","endsOutsideViewCls","startsOutsideViewCls","fixedEventCls","eventStyle","updateFillTicks","refreshWithTransition","changeBarMargin","rowHeight","updateBarMargin","onBeforeRowHeightChange","_resourceMargin","eventColors","eventStyles","defaultScrollOptions","bufferThreshold","initScroll","visibleDate","scrollInitialized","_timelineScroller","TimelineScroller","widget","_this$_timelineScroll","onTimelineScroll","checkTimeAxisScroll","scrollPos","limit","maxScroll","maxPosition","virtualScrollerElement","overflow","pointerEvents","paddingBottom","scrollBarWidth","shiftToDate","newRange","updateInfiniteScroll","edgeOffset","visibleWidth","extraScroll","scrollerViewport","localCoordinate","scrollToCoordinate","scrollToNow","visibleSpan","scrollIntoView","nextAnimationFrame","Scroller","updateOverflowX","updateOverflowY","onScroll","_position","syncPartners","force","updatePosition","xDelta","yDelta","changeX","changeY","scroller","clientWidth","scrollWidth","scrollHeight","zoomLevelOptions","applyState","_state$scroll","_zoomAfterPaint","Header","GridHeader","refreshContent","_this$headersElement","headersElement","TimeAxisSubGrid","SubGrid","sealedColumns","headerClass","startConfigure","changeScrollable","defineProperty","_this$element$scrollW","_this$element","syncScrollingPartners","addCls","bodyHeight","_bodyRectangle","onSchedulerViewportResize","requestAnimationFrame","clearWidthCache","updateViewModelAvailableSpace","initClass","exitTransition","TimelineBase","GridBase","TimelineDateMapper","TimelineDomEvents","TimelineEventRendering","TimelineScroll","TimelineState","TimelineViewPresets","TimelineZoomable","RecurringEvents","workingTime","autoAdjustTimeAxis","timeCellCls","disableGridRowModelWarning","animateRemovingRows","partner","schedulerRegion","transitionDuration","animationTimeout","defaultRegion","asyncEventSuffix","viewportResizeTimeout","updateTimeZone","timeZone","_isConfiguringTimeZone","populateEventMenu","populateScheduleMenu","handlingVisibleDateRangeChange","_visibleDateRange","$firstVerticalOverflow","init","forceLayout","createSubGrid","overflowX","overflowY","bodyContainer","partneredWith","removePartner","ResizeMonitor","addResizeListener","onBodyResize","changeStartDate","getBoundingClientRect","_me$currentOrientatio","_me$currentOrientatio2","doUpdateTimeView","frameCount","testPerformance","scrollSpeed","scrollInterval","setInterval","timePerFrame","fps","clearInterval","console","log","eventPositionMode","eventScrollMode","preserveViewCenter","scrollStart","startChanged","endChanged","oldTickSize","currentScroll","visibleStart","tickSizeChanged","returnValue","hasVisibleEvents","noFeatureElementsInAxis","_capitalizedEventName","_partner","addPartner","isPartneredWith","Collection","presetchange","overflowChange","partnerSharedConfig","partnerSharedConfigs","configName","syncPartnerSubGrids","FunctionHelper","createSequence","_this$partneredWith","onPartnerOverflowChange","otherScrollable","ourY","hasOverflow","refreshVirtualScrollbars","onPartnerPresetChange","allValues","columns","_timeAxisColumn","timeAxisColumnIndex","timeAxisColumnConfig","cols","col","_horizontalColumns","locked","verticalTimeAxisColumn","cellCls","c","isTimeAxisColumn","isVerticalTimeAxisColumn","relayAll","onColumnsChanged","changes","updateEventCls","unreleasedEventSelector","currentModel","tavmListeners","_mode","_suppressFit","currentTimeAxis","timeAxisListeners","applyWorkingTime","updateForceFit","_workingTime","fromHour","toHour","fromDay","toDay","_me$features$columnLi","updateStartDate","setStartDate","keepDuration","ta","calcEndDate","_tempStartDate","changeEndDate","setEndDate","calcStartDate","_tempEndDate","changeVisibleDate","updateVisibleDate","regionResize","_eventStyle","_eventColor","onLocaleChange","oldAutoAdjust","oldRect","_width","onViewportResize","isSyncingFromPartner","eachSubGrid","partnerSubGrid","subGrids","collapsed","collapse","expand","_backgroundCanvas","_foregroundCanvas","_svgCanvas","createElementNS","setAttribute","appendChild","_this$timeAxisColumn","_timeAxisSubGridElement","refreshTotalHeight","_rowBorderHeight","$canvasWidth","getForegroundDomConfigs","onStoreDataChange","isRepopulatingStores","await","whenVisible","refreshAfterProjectRefresh","refreshAllWhenReady","schedulerEl","nextSibling","fgCanvas","returnToTop","reLayoutEvents","getCellDataFromEvent","includeSingleAxisMatch","runWithTransition","hasTimeout","waitForAnimations","isRowNumberSelecting","selectors","cs","_cs$cell","formatDuration","setVersion"],"mappings":"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"}