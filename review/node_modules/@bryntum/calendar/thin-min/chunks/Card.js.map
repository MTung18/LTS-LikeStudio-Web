{"version":3,"file":"Card.js","sources":["../../../../Core/lib/Core/widget/DateTimeField.js","../../../../Core/lib/Core/widget/layout/Card.js"],"sourcesContent":["import Field from './Field.js';\nimport TimeField from './TimeField.js';\nimport './DateField.js';\nimport DateHelper from '../helper/DateHelper.js';\nimport EventHelper from '../helper/EventHelper.js';\nimport ObjectHelper from '../helper/ObjectHelper.js';\nimport Widget from './Widget.js';\n\n/**\n * @module Core/widget/DateTimeField\n */\n\n/**\n * A field combining a {@link Core.widget.DateField} and a {@link Core.widget.TimeField}.\n *\n * {@inlineexample Core/widget/DateTimeField.js}\n *\n * @extends Core/widget/Field\n * @classtype datetimefield\n * @inputfield\n */\nexport default class DateTimeField extends Field {\n    static configurable = {\n        /**\n         * Returns the TimeField instance\n         * @readonly\n         * @member {Core.widget.TimeField} timeField\n         */\n        /**\n         * Configuration for the {@link Core.widget.TimeField}\n         * @config {TimeFieldConfig}\n         */\n        timeField : {},\n\n        /**\n         * Returns the DateField instance\n         * @readonly\n         * @member {Core.widget.DateField} dateField\n         */\n        /**\n         * Configuration for the {@link Core.widget.DateField}\n         * @config {DateFieldConfig}\n         */\n        dateField : {\n            // To be able to use transformDateValue for parsing without loosing time, a bit of a hack\n            keepTime : true,\n            step     : '1 d'\n        },\n\n        /**\n         * The week start day in the {@link Core.widget.DateField#config-picker}, 0 meaning Sunday, 6 meaning Saturday.\n         * Uses localized value per default.\n         *\n         * @config {Number}\n         */\n        weekStartDay : null,\n\n        inputTemplate : () => '',\n\n        ariaElement : 'element'\n    };\n\n    static $name = 'DateTimeField';\n\n    static type = 'datetimefield';\n\n    // Factoryable type alias\n    static alias = 'datetime';\n\n    doDestroy() {\n        this.dateField.destroy();\n        this.timeField.destroy();\n\n        super.doDestroy();\n    }\n\n    get focusElement() {\n        return this.dateField.input;\n    }\n\n    // Implementation needed at this level because it has two inner elements in its inputWrap\n    get innerElements() {\n        return [\n            this.dateField.element,\n            this.timeField.element\n        ];\n    }\n\n    // Each subfield handles its own keystrokes\n    internalOnKeyEvent() { }\n\n    // CellEdit sets this dynamically on its editor field\n    updateRevertOnEscape(revertOnEscape) {\n        this.timeField.revertOnEscape = revertOnEscape;\n        this.dateField.revertOnEscape = revertOnEscape;\n    }\n\n    // Converts the timeField config into a TimeField\n    changeTimeField(config) {\n        const\n            me = this,\n            result = TimeField.new({\n                revertOnEscape : me.revertOnEscape,\n                syncInvalid(...args) {\n                    const updatingInvalid = me.updatingInvalid;\n\n                    TimeField.prototype.syncInvalid.apply(this, args);\n                    me.timeField && !updatingInvalid && me.syncInvalid();\n                }\n            }, config);\n\n        EventHelper.on({\n            element : result.element,\n            keydown : 'onTimeFieldKeyDown',\n            thisObj : me\n        });\n\n        // Must set *after* construction, otherwise it becomes the default state\n        // to reset readOnly back to\n        if (me.readOnly) {\n            result.readOnly = true;\n        }\n\n        return result;\n    }\n\n    // Set up change listener when TimeField is available. Not in timeField config to enable users to supply their own\n    // listeners block there\n    updateTimeField(timeField) {\n        const me = this;\n\n        timeField.ion({\n            change({ userAction, value }) {\n                if (userAction && !me.$settingValue) {\n                    const dateAndTime = me.dateField.value;\n                    me._isUserAction = true;\n                    me.value = dateAndTime ? DateHelper.copyTimeValues(dateAndTime, value) : null;\n                    me._isUserAction = false;\n                }\n            },\n            thisObj : me\n        });\n    }\n\n    // Converts the dateField config into a class based on { type : \"...\" } provided (DateField by default)\n    changeDateField(config) {\n        const\n            me     = this,\n            type   = config?.type || 'datefield',\n            cls    = Widget.resolveType(config.type || 'datefield'),\n            result = Widget.create(ObjectHelper.assign({\n                type,\n                revertOnEscape : me.revertOnEscape,\n                syncInvalid(...args) {\n                    const updatingInvalid = me.updatingInvalid;\n\n                    cls.prototype.syncInvalid.apply(this, args);\n                    me.dateField && !updatingInvalid && me.syncInvalid();\n                }\n            }, config));\n\n        EventHelper.on({\n            element : result.element,\n            keydown : 'onDateFieldKeyDown',\n            thisObj : me\n        });\n\n        // Must set *after* construction, otherwise it becomes the default state\n        // to reset readOnly back to\n        if (me.readOnly) {\n            result.readOnly = true;\n        }\n\n        result.ion(({\n            keydown : ({ event }) => {\n                if (event.key === 'Tab' && !event.shiftKey && this.timeField?.isVisible) {\n                    event.stopPropagation();\n                    event.cancelBubble = true;\n                }\n            }\n        }));\n\n        return result;\n    }\n\n    get childItems() {\n        return [this.dateField, this.timeField];\n    }\n\n    // Set up change listener when DateField is available. Not in dateField config to enable users to supply their own\n    // listeners block there\n    updateDateField(dateField) {\n        const me = this;\n\n        dateField.ion({\n            change({ userAction, value }) {\n                if (userAction && !me.$isInternalChange) {\n                    me._isUserAction = true;\n                    if (!me.timeField.value) {\n                        me.timeField.value = value;\n                    }\n                    else if (value) {\n                        // Preserve the time field value when changing the datefield.\n                        DateHelper.copyTimeValues(value, me.timeField.value);\n                    }\n                    me.value = value;\n                    me._isUserAction = false;\n                }\n            },\n            thisObj : me\n        });\n    }\n\n    updateWeekStartDay(weekStartDay) {\n        if (this.dateField) {\n            this.dateField.weekStartDay = weekStartDay;\n        }\n    }\n\n    changeWeekStartDay(value) {\n        return typeof value === 'number' ? value : (this.dateField?.weekStartDay ?? DateHelper.weekStartDay);\n    }\n\n    // Apply our value to our underlying fields\n    syncInputFieldValue(skipHighlight = this.isConfiguring) {\n        super.syncInputFieldValue(true);\n\n        const\n            me                       = this,\n            { dateField, timeField } = me,\n            highlightDate            = dateField.highlightExternalChange,\n            highlightTime            = timeField.highlightExternalChange;\n\n        if (!skipHighlight && !me.highlightExternalChange) {\n            skipHighlight = true;\n        }\n\n        me.$isInternalChange = true;\n\n        dateField.highlightExternalChange = false;\n\n        // Prevent dateField from keeping its time value\n        // TODO: Should be doable without this hack\n        dateField.value = null;\n\n        dateField.highlightExternalChange = highlightDate;\n\n        if (skipHighlight) {\n            timeField.highlightExternalChange = dateField.highlightExternalChange = false;\n        }\n\n        timeField.value = dateField.value = me.inputValue;\n\n        dateField.highlightExternalChange = highlightDate;\n        timeField.highlightExternalChange = highlightTime;\n\n        me.$isInternalChange = false;\n\n        // Must evaluate after child fields have been updated since our validity state depends on theirs.\n        me.syncInvalid();\n    }\n\n    onTimeFieldKeyDown(e) {\n        const me = this;\n\n        // we need to handle keydown for composed field manually and before it's done by cellEdit feature\n        if (e.key === 'Enter' || e.key === 'Tab') {\n            const dateAndTime = me.dateField.value;\n            me._isUserAction = true;\n            me.value = dateAndTime ? DateHelper.copyTimeValues(dateAndTime, me.timeField.value) : null;\n            me._isUserAction = false;\n        }\n    }\n\n    onDateFieldKeyDown(e) {\n        const me = this;\n\n        if (e.key === 'Tab' && !e.shiftKey) {\n            e.stopPropagation();\n            e.preventDefault();\n            me.timeField.focus();\n        }\n        // we need to handle keydown for composed field manually and before it's done by cellEdit feature\n        else if (e.key === 'Enter') {\n            me.value = me.dateField.value;\n        }\n    }\n\n    // Make us and our underlying fields required\n    updateRequired(required, was) {\n        this.timeField.required = this.dateField.required = required;\n    }\n\n    updateReadOnly(readOnly, was) {\n        super.updateReadOnly(readOnly, was);\n\n        if (!this.isConfiguring) {\n            this.timeField.readOnly = this.dateField.readOnly = readOnly;\n        }\n    }\n\n    // Make us and our underlying fields disabled\n    onDisabled(value) {\n        this.timeField.disabled = this.dateField.disabled = value;\n    }\n\n    focus() {\n        this.dateField.focus();\n    }\n\n    hasChanged(oldValue, newValue) {\n        return !DateHelper.isEqual(oldValue, newValue);\n    }\n\n    get isValid() {\n        return this.timeField.isValid && this.dateField.isValid;\n    }\n\n    setError(error, silent) {\n        [this.dateField, this.timeField].forEach(f => f.setError(error, silent));\n    }\n\n    getErrors() {\n        const errors = [...(this.dateField.getErrors() || []), ...(this.timeField.getErrors() || [])];\n\n        return errors.length ? errors : null;\n    }\n\n    clearError(error, silent) {\n        [this.dateField, this.timeField].forEach(f => f.clearError(error, silent));\n    }\n\n    updateInvalid() {\n        // use this flag in this level to avoid looping\n        this.updatingInvalid = true;\n        [this.dateField, this.timeField].forEach(f => f.updateInvalid());\n        this.updatingInvalid = false;\n    }\n}\n\nDateTimeField.initClass();\n","import Layout from './Layout.js';\nimport Widget from '../Widget.js';\nimport EventHelper from '../../helper/EventHelper.js';\n\n/**\n * @module Core/widget/layout/Card\n */\n\nconst animationClasses = [\n    'b-slide-out-left',\n    'b-slide-out-right',\n    'b-slide-in-left',\n    'b-slide-in-right'\n];\n\n/**\n * A helper class for containers which must manage multiple child widgets, of which only one may be visible at once such\n * as a {@link Core.widget.TabPanel}. This class offers an active widget switching API, and optional slide-in,\n * slide-out animations from child to child.\n * @extends Core/widget/layout/Layout\n * @layout\n * @classtype card\n */\nexport default class Card extends Layout {\n    static $name = 'Card';\n\n    static type = 'card';\n\n    static configurable = {\n        containerCls : 'b-card-container',\n\n        itemCls : 'b-card-item',\n\n        hideChildHeaderCls : 'b-hide-child-headers',\n\n        /**\n         * Specifies whether to slide tabs in and out of visibility.\n         * @config {Boolean}\n         * @default\n         */\n        animateCardChange : true,\n\n        /**\n         * The active child item.\n         * @config {Core.widget.Widget}\n         */\n        activeItem : null,\n\n        /**\n         * The active child index.\n         * @config {Number}\n         */\n        activeIndex : null\n    };\n\n    onChildAdd(item) {\n        super.onChildAdd(item);\n\n        const\n            me = this,\n            {\n                activeItem,\n                owner\n            }           = me,\n            activeIndex = owner.activeIndex != null ? owner.activeIndex : (me.activeIndex || 0),\n            itemIndex   = owner.items.indexOf(item),\n            isActive    = activeItem != null ? item === activeItem : itemIndex === activeIndex;\n\n        item.ion({\n            beforeHide : 'onBeforeChildHide',\n            beforeShow : 'onBeforeChildShow',\n            thisObj    : me\n        });\n\n        // Ensure inactive child items start hidden, and the active one starts shown.\n        // Sync our active indicators with reality ready for render.\n        if (isActive) {\n            me._activeIndex = itemIndex;\n            me._activeItem = item;\n            item.show();\n        }\n        else {\n            item.$isDeactivating = true;\n            item.hide();\n            item.$isDeactivating = false;\n        }\n    }\n\n    onChildRemove(item) {\n        super.onChildRemove(item);\n\n        const me = this;\n\n        // Active child has been removed without setting another child to be active.\n        // Choose an immediate sibling to be the new active item\n        if (me._activeItem === item) {\n            me.activateSiblingOf(item);\n        }\n\n        me._activeIndex = me.owner.items.indexOf(me._activeItem);\n\n        item.un({\n            beforeHide : 'onBeforeChildHide',\n            beforeShow : 'onBeforeChildShow',\n            thisObj    : me\n        });\n    }\n\n    /**\n     * Detect external code showing a child. We veto that show and activate it through the API.\n     * @internal\n     */\n    onBeforeChildShow({ source : showingChild }) {\n        // Some outside code is showing a child.\n        // We must control this, so veto it and activate it in the standard way.\n        if (!this.owner.isConfiguring && !showingChild.$isActivating) {\n            this.activeItem = showingChild;\n            return false;\n        }\n    }\n\n    /**\n     * Detect external code hiding a child. We veto that show and activate an immediate sibling through the API.\n     * @internal\n     */\n    onBeforeChildHide({ source : hidingChild }) {\n        // Some outside code is hiding a child.\n        // We must control this, so veto it and activate a sibling in the standard way.\n        if (!this.owner.isConfiguring && !hidingChild.$isDeactivating) {\n            this.activateSiblingOf(hidingChild);\n            return false;\n        }\n    }\n\n    activateSiblingOf(item) {\n        const\n            { owner } = this,\n            items     = owner.items.slice(),\n            removeAt  = items.indexOf(item);\n\n        items.splice(removeAt, 1);\n\n        this.activeIndex = Math.min(removeAt, items.length - 1);\n    }\n\n    /**\n     * Get/set active item, using index or the Widget to activate\n     * @param {Core.widget.Widget|Number} activeIndex\n     * @param {Number} [prevActiveIndex]\n     * @param {Object} [options]\n     * @param {Boolean} [options.animation] Pass `false` to disable animation\n     * @param {Boolean} [options.silent] Pass `true` to not fire transition events\n     * @returns {Object} An object describing the card change containing the following properties:\n     *  - `prevActiveIndex` The previously active index.\n     *  - `prevActiveItem ` The previously active child item.\n     *  - `activeIndex    ` The newly active index.\n     *  - `activeItem     ` The newly active child item.\n     *  - `promise        ` A promise which completes when the slide-in animation finishes and the child item contains\n     * focus if it is focusable.\n     * @internal\n     */\n    setActiveItem(activeIndex, prevActiveIndex = this.activeIndex, options) {\n        const\n            me             = this,\n            { owner }      = me,\n            { items }      = owner,\n            widgetPassed   = activeIndex instanceof Widget,\n            prevActiveItem = items[prevActiveIndex],\n            newActiveItem  = owner.items[activeIndex = widgetPassed ? items.indexOf(activeIndex) : parseInt(activeIndex, 10)],\n            animation      = options?.animation !== false,\n            chatty         = !options?.silent,\n            event = {\n                prevActiveIndex,\n                prevActiveItem\n            };\n\n        // There's a child widget at that index to activate and we're not already activating it.\n        if (newActiveItem && !newActiveItem.$isActivating && newActiveItem !== prevActiveItem) {\n            const\n                prevItemElement = prevActiveItem && prevActiveItem.element,\n                newActiveElement = newActiveItem && newActiveItem.element;\n\n            // A previous card change is in progress, abort it and clean the items it was operating upon\n            if (me.animateDetacher) {\n                const activeCardChange = me.animateDetacher.event;\n\n                // The animation that is in flight is already doing what we are being asked for.\n                // Allow it to complete.\n                if (activeCardChange.activeItem === newActiveItem) {\n                    return activeCardChange.promise;\n                }\n                me.animateDetacher();\n                activeCardChange.prevActiveItem.element.classList.remove(...animationClasses);\n                activeCardChange.activeItem.element.classList.remove(...animationClasses);\n                me.animateDetacher = null;\n            }\n\n            event.activeIndex = activeIndex;\n            event.activeItem = newActiveItem;\n\n            /**\n             * The active item is about to be changed. Return `false` to prevent this.\n             * @event beforeActiveItemChange\n             * @preventable\n             * @on-owner\n             * @param {Number} activeIndex - The new active index.\n             * @param {Core.widget.Widget} activeItem - The new active child widget.\n             * @param {Number} prevActiveIndex - The previous active index.\n             * @param {Core.widget.Widget} prevActiveItem - The previous active child widget.\n             */\n            if (chatty && owner.trigger('beforeActiveItemChange', event) === false) {\n                return null;\n            }\n\n            // Since onBeforeActiveItemChange happens before event handlers run, the activation could be cancelled by\n            // a listener, so we do a special hook once we are sure things are going down.\n            // We pretend that we have already switched active index so that the owner\n            // does not attempt to initiate the change.\n            const reset = me._activeIndex !== event.activeIndex;\n\n            if (reset) {\n                me._activeIndex = event.activeIndex;\n            }\n\n            chatty && owner.onBeginActiveItemChange?.(event);\n\n            if (reset) {\n                me._activeIndex = event.prevActiveIndex;\n            }\n\n            // If we're animating and there's something to slide out\n            // then slide it out, and slide the new item in\n            if (animation && prevItemElement && owner.isVisible && me.animateCardChange) {\n                event.promise = me.cardChangeAnimation = new Promise((resolve, reject) => {                   // During the card sliding trick, we don't want resize notifications.\n                    // The outgoing card should be as inert as if it were hidden.\n                    const wasMonitoringSize = prevActiveItem.monitorResize;\n                    prevActiveItem.monitorResize = false;\n\n                    me.contentElement.style.overflowX = 'hidden';\n\n                    // The outgoing card must report its isVisible property as false from now on\n                    // even before we officially hide it.\n                    prevActiveItem._hidden = true;\n\n                    // Show the item so that it can be slid in.\n                    // Events will ensue, UIs can react to the show event.\n                    // The flag is so that our onBeforeChildShow listener can\n                    // tell if it's part of our orderly activate operation.\n                    newActiveItem.$isActivating = true;\n                    newActiveItem.show();\n                    newActiveItem.$isActivating = false;\n\n                    prevItemElement.classList.add(activeIndex > prevActiveIndex ? 'b-slide-out-left' : 'b-slide-out-right');\n                    newActiveElement.classList.add(activeIndex < prevActiveIndex ? 'b-slide-in-left' : 'b-slide-in-right');\n                    owner.isAnimating = true;\n\n                    // When the new widget is in place, clean up\n                    me.animateDetacher = EventHelper.onTransitionEnd({\n                        mode    : 'animation',\n                        element : newActiveElement,\n\n                        // onTransitionEnd protects us from being called\n                        // after the thisObj is destroyed.\n                        thisObj : prevActiveItem,\n\n                        handler()  {\n                            // Calendar got stuck with `b-animating` in some monkey scenarios, hoisted this to make\n                            // sure it was not left behind\n                            owner.isAnimating = me.cardChangeAnimation = false;\n\n                            // if animateDetacher variable has been cleared before this callback,\n                            // this means race-condition call happened. active item should be called again to\n                            // prevent unexpected layout behaviour\n                            if (!me.animateDetacher) {\n                                me.setActiveItem(activeIndex, prevActiveIndex, options);\n                                return;\n                            }\n\n                            me.animateDetacher = null;\n\n                            // Clean incoming widget's animation classes\n                            newActiveElement.classList.remove(...animationClasses);\n\n                            // If there's an outgoing item, clean its animation classes and hide it\n                            if (prevItemElement) {\n                                prevItemElement.classList.remove(...animationClasses);\n\n                                // The flag is so that our onBeforeChildHide listener can\n                                // tell if it's part of our orderly activate operation.\n                                prevActiveItem.$isDeactivating = true;\n                                prevActiveItem._hidden = false;\n                                prevActiveItem.hide();\n                                prevActiveItem.monitorResize = wasMonitoringSize;\n                                prevActiveItem.$isDeactivating = false;\n                            }\n\n                            me.contentElement.style.overflowX = '';\n                            me.onActiveItemChange(event, resolve, !chatty);\n                        }\n                    });\n\n                    me.animateDetacher.reject = reject;\n                    me.animateDetacher.event = event;\n                });\n            }\n            // Nothing to slide out or we are not animating.\n            else {\n                // Show the new active items first, so that the hide listener doesn't\n                // automatically set a new active item based on active item being hidden.\n                // The flag is so that our onBeforeChildShow listener can\n                // tell if it's part of our orderly activate operation.\n                newActiveItem.$isActivating = true;\n                newActiveItem.show();\n\n                // focus the new item before lost the component focus when hide the old one\n                // (because losing focus closes owner if it is floatable)\n                newActiveItem.focus();\n\n                newActiveItem.$isActivating = false;\n\n                if (prevActiveItem) {\n                    // The flag is so that our onBeforeChildHide listener can\n                    // tell if it's part of our orderly activate operation.\n                    prevActiveItem.$isDeactivating = true;\n                    prevActiveItem.hide();\n                    prevActiveItem.$isDeactivating = false;\n                }\n\n                me.onActiveItemChange(event, null, !chatty);\n            }\n        }\n\n        return event;\n    }\n\n    onActiveItemChange(event, resolve, silent) {\n        const me = this;\n\n        me._activeItem = event.activeItem;\n        me._activeIndex = event.activeIndex;\n\n        /**\n         * The active item has changed.\n         * @event activeItemChange\n         * @on-owner\n         * @param {Number} activeIndex - The new active index.\n         * @param {Core.widget.Widget} activeItem - The new active child widget.\n         * @param {Number} prevActiveIndex - The previous active index.\n         * @param {Core.widget.Widget} prevActiveItem - The previous active child widget.\n         */\n        !silent && me.owner.trigger('activeItemChange', event);\n\n        // Note that we have to call focus *after* the element is in its new position\n        // because focus({preventScroll:true}) is not supported everywhere\n        // and crazy browser scrolling behaviour on focus breaks the animation.\n        event.activeItem.focus();\n\n        resolve?.(event);\n    }\n\n    renderChildren() {\n        const { owner } = this;\n\n        owner.contentElement.classList.toggle(this.hideChildHeaderCls, owner.suppressChildHeaders);\n\n        super.renderChildren();\n    }\n\n    changeActiveIndex(activeIndex) {\n        const { owner } = this;\n\n        // Sanitize it if possible\n        return owner.isConfiguring && !owner._items ? activeIndex : Math.min(activeIndex, owner.items.length - 1);\n    }\n\n    updateActiveIndex(activeIndex, oldActiveIndex) {\n        if (!this.owner.isConfiguring) {\n            this.setActiveItem(activeIndex, oldActiveIndex);\n        }\n    }\n\n    updateActiveItem(activeItem) {\n        if (!this.owner.isConfiguring) {\n            this.setActiveItem(activeItem, this.activeIndex);\n        }\n    }\n\n    /**\n     * If the layout is set to {@link #config-animateCardChange}, then this property\n     * will be `true` during the animated card change.\n     * @property {Boolean}\n     * @readonly\n     */\n    get isChangingCard() {\n        return Boolean(this.animateDetacher);\n    }\n}\n\n// Layouts must register themselves so that the static layout instantiation\n// in Layout knows what to do with layout type names\nCard.initClass();\n"],"names":["DateTimeField","Field","doDestroy","this","dateField","destroy","timeField","super","focusElement","input","innerElements","element","internalOnKeyEvent","updateRevertOnEscape","revertOnEscape","changeTimeField","config","me","result","TimeField","new","syncInvalid","args","updatingInvalid","prototype","apply","EventHelper","on","keydown","thisObj","readOnly","updateTimeField","ion","change","userAction","value","$settingValue","dateAndTime","_isUserAction","DateHelper","copyTimeValues","changeDateField","type","cls","Widget","resolveType","create","ObjectHelper","assign","event","_this$timeField","key","shiftKey","isVisible","stopPropagation","cancelBubble","childItems","updateDateField","$isInternalChange","updateWeekStartDay","weekStartDay","changeWeekStartDay","_this$dateField$weekS","_this$dateField","syncInputFieldValue","skipHighlight","isConfiguring","highlightDate","highlightExternalChange","highlightTime","inputValue","onTimeFieldKeyDown","e","onDateFieldKeyDown","preventDefault","focus","updateRequired","required","was","updateReadOnly","onDisabled","disabled","hasChanged","oldValue","newValue","isEqual","isValid","setError","error","silent","forEach","f","getErrors","errors","length","clearError","updateInvalid","_defineProperty","keepTime","step","inputTemplate","ariaElement","initClass","_$name","animationClasses","Card","Layout","onChildAdd","item","activeItem","owner","activeIndex","itemIndex","items","indexOf","isActive","beforeHide","beforeShow","_activeIndex","_activeItem","show","$isDeactivating","hide","onChildRemove","activateSiblingOf","un","onBeforeChildShow","source","showingChild","$isActivating","onBeforeChildHide","hidingChild","slice","removeAt","splice","Math","min","setActiveItem","prevActiveIndex","options","widgetPassed","prevActiveItem","newActiveItem","parseInt","animation","chatty","_owner$onBeginActiveI","prevItemElement","newActiveElement","animateDetacher","activeCardChange","promise","classList","remove","trigger","reset","onBeginActiveItemChange","call","animateCardChange","cardChangeAnimation","Promise","resolve","reject","wasMonitoringSize","monitorResize","contentElement","style","overflowX","_hidden","add","isAnimating","onTransitionEnd","mode","handler","onActiveItemChange","renderChildren","toggle","hideChildHeaderCls","suppressChildHeaders","changeActiveIndex","_items","updateActiveIndex","oldActiveIndex","updateActiveItem","isChangingCard","Boolean","containerCls","itemCls"],"mappings":"mLAmBe,MAAMA,UAAsBC,EAwCvCC,YACIC,KAAKC,UAAUC,UACfF,KAAKG,UAAUD,UACfE,MAAML,YAEVM,mBACI,OAAOL,KAAKC,UAAUK,MAG1BC,oBACI,MAAO,CACHP,KAAKC,UAAUO,QACfR,KAAKG,UAAUK,SAIvBC,sBAEAC,qBAAqBC,GACjBX,KAAKG,UAAUQ,eAAiBA,EAChCX,KAAKC,UAAUU,eAAiBA,EAGpCC,gBAAgBC,GACZ,MACIC,EAAKd,KACLe,EAASC,EAAUC,IAAI,CACnBN,eAAiBG,EAAGH,eACpBO,eAAeC,GACX,MAAMC,EAAkBN,EAAGM,gBAC3BJ,EAAUK,UAAUH,YAAYI,MAAMtB,KAAMmB,GAC5CL,EAAGX,YAAciB,GAAmBN,EAAGI,gBAE5CL,GAWP,OAVAU,EAAYC,GAAG,CACXhB,QAAUO,EAAOP,QACjBiB,QAAU,qBACVC,QAAUZ,IAIVA,EAAGa,WACHZ,EAAOY,UAAW,GAEfZ,EAIXa,gBAAgBzB,GACZ,MAAMW,EAAKd,KACXG,EAAU0B,IAAI,CACVC,QAAOC,WAAEA,EAAUC,MAAEA,IACjB,GAAID,IAAejB,EAAGmB,cAAe,CACjC,MAAMC,EAAcpB,EAAGb,UAAU+B,MACjClB,EAAGqB,eAAgB,EACnBrB,EAAGkB,MAAQE,EAAcE,EAAWC,eAAeH,EAAaF,GAAS,KACzElB,EAAGqB,eAAgB,IAG3BT,QAAUZ,IAIlBwB,gBAAgBzB,GACZ,MACIC,EAASd,KACTuC,GAAS1B,MAAAA,SAAAA,EAAQ0B,OAAQ,YACzBC,EAASC,EAAOC,YAAY7B,EAAO0B,MAAQ,aAC3CxB,EAAS0B,EAAOE,OAAOC,EAAaC,OAAO,CACvCN,KAAAA,EACA5B,eAAiBG,EAAGH,eACpBO,eAAeC,GACX,MAAMC,EAAkBN,EAAGM,gBAC3BoB,EAAInB,UAAUH,YAAYI,MAAMtB,KAAMmB,GACtCL,EAAGb,YAAcmB,GAAmBN,EAAGI,gBAE5CL,IAmBP,OAlBAU,EAAYC,GAAG,CACXhB,QAAUO,EAAOP,QACjBiB,QAAU,qBACVC,QAAUZ,IAIVA,EAAGa,WACHZ,EAAOY,UAAW,GAEtBZ,EAAOc,IAAK,CACRJ,QAAUA,EAAGqB,MAAAA,MAAY,IAAAC,EACH,QAAdD,EAAME,MAAkBF,EAAMG,kBAAQF,EAAI/C,KAAKG,qBAAS4C,GAAdA,EAAgBG,YAC1DJ,EAAMK,kBACNL,EAAMM,cAAe,MAI1BrC,EAEXsC,iBACI,MAAO,CAACrD,KAAKC,UAAWD,KAAKG,WAIjCmD,gBAAgBrD,GACZ,MAAMa,EAAKd,KACXC,EAAU4B,IAAI,CACVC,QAAOC,WAAEA,EAAUC,MAAEA,IACbD,IAAejB,EAAGyC,oBAClBzC,EAAGqB,eAAgB,EACdrB,EAAGX,UAAU6B,MAGTA,GAELI,EAAWC,eAAeL,EAAOlB,EAAGX,UAAU6B,OAJ9ClB,EAAGX,UAAU6B,MAAQA,EAMzBlB,EAAGkB,MAAQA,EACXlB,EAAGqB,eAAgB,IAG3BT,QAAUZ,IAGlB0C,mBAAmBC,GACXzD,KAAKC,YACLD,KAAKC,UAAUwD,aAAeA,GAGtCC,mBAAmB1B,GAAO,IAAA2B,EAAAC,EACtB,MAAwB,iBAAV5B,EAAqBA,UAAK2B,UAAAC,EAAI5D,KAAKC,qBAAS2D,SAAdA,EAAgBH,wBAAYE,EAAAA,EAAIvB,EAAWqB,aAG3FI,oBAAoBC,EAAgB9D,KAAK+D,eACrC3D,MAAMyD,qBAAoB,GAC1B,MACI/C,EAA2Bd,MAC3BC,UAAEA,EAASE,UAAEA,GAAcW,EAC3BkD,EAA2B/D,EAAUgE,wBACrCC,EAA2B/D,EAAU8D,wBACpCH,GAAkBhD,EAAGmD,0BACtBH,GAAgB,GAEpBhD,EAAGyC,mBAAoB,EACvBtD,EAAUgE,yBAA0B,EAGpChE,EAAU+B,MAAQ,KAClB/B,EAAUgE,wBAA0BD,EAChCF,IACA3D,EAAU8D,wBAA0BhE,EAAUgE,yBAA0B,GAE5E9D,EAAU6B,MAAQ/B,EAAU+B,MAAQlB,EAAGqD,WACvClE,EAAUgE,wBAA0BD,EACpC7D,EAAU8D,wBAA0BC,EACpCpD,EAAGyC,mBAAoB,EAEvBzC,EAAGI,cAEPkD,mBAAmBC,GACf,MAAMvD,EAAKd,KAEX,GAAc,UAAVqE,EAAErB,KAA6B,QAAVqB,EAAErB,IAAe,CACtC,MAAMd,EAAcpB,EAAGb,UAAU+B,MACjClB,EAAGqB,eAAgB,EACnBrB,EAAGkB,MAAQE,EAAcE,EAAWC,eAAeH,EAAapB,EAAGX,UAAU6B,OAAS,KACtFlB,EAAGqB,eAAgB,GAG3BmC,mBAAmBD,GACf,MAAMvD,EAAKd,KACG,QAAVqE,EAAErB,KAAkBqB,EAAEpB,SAMP,UAAVoB,EAAErB,MACPlC,EAAGkB,MAAQlB,EAAGb,UAAU+B,QANxBqC,EAAElB,kBACFkB,EAAEE,iBACFzD,EAAGX,UAAUqE,SAQrBC,eAAeC,EAAUC,GACrB3E,KAAKG,UAAUuE,SAAW1E,KAAKC,UAAUyE,SAAWA,EAExDE,eAAejD,EAAUgD,GACrBvE,MAAMwE,eAAejD,EAAUgD,GAC1B3E,KAAK+D,gBACN/D,KAAKG,UAAUwB,SAAW3B,KAAKC,UAAU0B,SAAWA,GAI5DkD,WAAW7C,GACPhC,KAAKG,UAAU2E,SAAW9E,KAAKC,UAAU6E,SAAW9C,EAExDwC,QACIxE,KAAKC,UAAUuE,QAEnBO,WAAWC,EAAUC,GACjB,OAAQ7C,EAAW8C,QAAQF,EAAUC,GAEzCE,cACI,OAAOnF,KAAKG,UAAUgF,SAAWnF,KAAKC,UAAUkF,QAEpDC,SAASC,EAAOC,GACZ,CAACtF,KAAKC,UAAWD,KAAKG,WAAWoF,SAAQC,GAAKA,EAAEJ,SAASC,EAAOC,KAEpEG,YACI,MAAMC,EAAS,IAAK1F,KAAKC,UAAUwF,aAAe,MAASzF,KAAKG,UAAUsF,aAAe,IACzF,OAAOC,EAAOC,OAASD,EAAS,KAEpCE,WAAWP,EAAOC,GACd,CAACtF,KAAKC,UAAWD,KAAKG,WAAWoF,SAAQC,GAAKA,EAAEI,WAAWP,EAAOC,KAEtEO,gBAEI7F,KAAKoB,iBAAkB,EACvB,CAACpB,KAAKC,UAAWD,KAAKG,WAAWoF,SAAQC,GAAKA,EAAEK,kBAChD7F,KAAKoB,iBAAkB,GAE9B0E,EAlQoBjG,iBACK,CAUlBM,UAAY,GAUZF,UAAY,CAER8F,UAAW,EACXC,KAAW,OAQfvC,aAAe,KACfwC,cAAgBA,IAAM,GACtBC,YAAc,YACjBJ,EAnCgBjG,UAoCF,iBAAeiG,EApCbjG,SAqCH,iBAAeiG,EArCZjG,UAuCF,YA4NnBA,EAAcsG,YACdtG,EAAcuG,OAAS,gBCjRvB,MAAMC,EAAmB,CACrB,mBACA,oBACA,kBACA,oBAUW,MAAMC,UAAaC,EAwB9BC,WAAWC,GACPrG,MAAMoG,WAAWC,GACjB,MACI3F,EAAKd,MACL0G,WACIA,EAAUC,MACVA,GACU7F,EACd8F,EAAmC,MAArBD,EAAMC,YAAsBD,EAAMC,YAAe9F,EAAG8F,aAAe,EACjFC,EAAcF,EAAMG,MAAMC,QAAQN,GAClCO,EAA4B,MAAdN,EAAqBD,IAASC,EAAaG,IAAcD,EAC3EH,EAAK5E,IAAI,CACLoF,WAAa,oBACbC,WAAa,oBACbxF,QAAaZ,IAIbkG,GACAlG,EAAGqG,aAAeN,EAClB/F,EAAGsG,YAAcX,EACjBA,EAAKY,SAGLZ,EAAKa,iBAAkB,EACvBb,EAAKc,OACLd,EAAKa,iBAAkB,GAG/BE,cAAcf,GACVrG,MAAMoH,cAAcf,GACpB,MAAM3F,EAAKd,KAGPc,EAAGsG,cAAgBX,GACnB3F,EAAG2G,kBAAkBhB,GAEzB3F,EAAGqG,aAAerG,EAAG6F,MAAMG,MAAMC,QAAQjG,EAAGsG,aAC5CX,EAAKiB,GAAG,CACJT,WAAa,oBACbC,WAAa,oBACbxF,QAAaZ,IAOrB6G,mBAAoBC,OAASC,IAGzB,IAAK7H,KAAK2G,MAAM5C,gBAAkB8D,EAAaC,cAE3C,OADA9H,KAAK0G,WAAamB,GACX,EAOfE,mBAAoBH,OAASI,IAGzB,IAAKhI,KAAK2G,MAAM5C,gBAAkBiE,EAAYV,gBAE1C,OADAtH,KAAKyH,kBAAkBO,IAChB,EAGfP,kBAAkBhB,GACd,MACIE,MAAEA,GAAU3G,KACZ8G,EAAYH,EAAMG,MAAMmB,QACxBC,EAAYpB,EAAMC,QAAQN,GAC9BK,EAAMqB,OAAOD,EAAU,GACvBlI,KAAK4G,YAAcwB,KAAKC,IAAIH,EAAUpB,EAAMnB,OAAS,GAkBzD2C,cAAc1B,EAAa2B,EAAkBvI,KAAK4G,YAAa4B,GAC3D,MACI1H,EAAiBd,MACjB2G,MAAEA,GAAe7F,GACjBgG,MAAEA,GAAeH,EACjB8B,EAAiB7B,aAAuBnE,EACxCiG,EAAiB5B,EAAMyB,GACvBI,EAAiBhC,EAAMG,MAAMF,EAAc6B,EAAe3B,EAAMC,QAAQH,GAAegC,SAAShC,EAAa,KAC7GiC,GAAwC,KAAvBL,MAAAA,SAAAA,EAASK,WAC1BC,IAAkBN,MAAAA,GAAAA,EAASlD,QAC3BxC,EAAQ,CACJyF,gBAAAA,EACAG,eAAAA,GAGR,GAAIC,IAAkBA,EAAcb,eAAiBa,IAAkBD,EAAgB,CAAA,IAAAK,EACnF,MACIC,EAAkBN,GAAkBA,EAAelI,QACnDyI,EAAmBN,GAAiBA,EAAcnI,QAEtD,GAAIM,EAAGoI,gBAAiB,CACpB,MAAMC,EAAmBrI,EAAGoI,gBAAgBpG,MAG5C,GAAIqG,EAAiBzC,aAAeiC,EAChC,OAAOQ,EAAiBC,QAE5BtI,EAAGoI,kBACHC,EAAiBT,eAAelI,QAAQ6I,UAAUC,UAAUjD,GAC5D8C,EAAiBzC,WAAWlG,QAAQ6I,UAAUC,UAAUjD,GACxDvF,EAAGoI,gBAAkB,KAczB,GAZApG,EAAM8D,YAAcA,EACpB9D,EAAM4D,WAAaiC,EAWfG,IAA6D,IAAnDnC,EAAM4C,QAAQ,yBAA0BzG,GAClD,OAAO,KAMX,MAAM0G,EAAQ1I,EAAGqG,eAAiBrE,EAAM8D,YACpC4C,IACA1I,EAAGqG,aAAerE,EAAM8D,aAE5BkC,YAAMC,EAAIpC,EAAM8C,mCAAuBV,GAA7BA,EAAAW,KAAA/C,EAAgC7D,IACtC0G,IACA1I,EAAGqG,aAAerE,EAAMyF,iBAIxBM,GAAaG,GAAmBrC,EAAMzD,WAAapC,EAAG6I,kBACtD7G,EAAMsG,QAAUtI,EAAG8I,oBAAsB,IAAIC,SAAQ,CAACC,EAASC,KAE3D,MAAMC,EAAoBtB,EAAeuB,cACzCvB,EAAeuB,eAAgB,EAC/BnJ,EAAGoJ,eAAeC,MAAMC,UAAY,SAGpC1B,EAAe2B,SAAU,EAKzB1B,EAAcb,eAAgB,EAC9Ba,EAActB,OACdsB,EAAcb,eAAgB,EAC9BkB,EAAgBK,UAAUiB,IAAI1D,EAAc2B,EAAkB,mBAAqB,qBACnFU,EAAiBI,UAAUiB,IAAI1D,EAAc2B,EAAkB,kBAAoB,oBACnF5B,EAAM4D,aAAc,EAEpBzJ,EAAGoI,gBAAkB3H,EAAYiJ,gBAAgB,CAC7CC,KAAU,YACVjK,QAAUyI,EAGVvH,QAAUgH,EACVgC,UAGI/D,EAAM4D,YAAczJ,EAAG8I,qBAAsB,EAIxC9I,EAAGoI,iBAIRpI,EAAGoI,gBAAkB,KAErBD,EAAiBI,UAAUC,UAAUjD,GAEjC2C,IACAA,EAAgBK,UAAUC,UAAUjD,GAGpCqC,EAAepB,iBAAkB,EACjCoB,EAAe2B,SAAU,EACzB3B,EAAenB,OACfmB,EAAeuB,cAAgBD,EAC/BtB,EAAepB,iBAAkB,GAErCxG,EAAGoJ,eAAeC,MAAMC,UAAY,GACpCtJ,EAAG6J,mBAAmB7H,EAAOgH,GAAUhB,IAlBnChI,EAAGwH,cAAc1B,EAAa2B,EAAiBC,MAqB3D1H,EAAGoI,gBAAgBa,OAASA,EAC5BjJ,EAAGoI,gBAAgBpG,MAAQA,MAS/B6F,EAAcb,eAAgB,EAC9Ba,EAActB,OAGdsB,EAAcnE,QACdmE,EAAcb,eAAgB,EAC1BY,IAGAA,EAAepB,iBAAkB,EACjCoB,EAAenB,OACfmB,EAAepB,iBAAkB,GAErCxG,EAAG6J,mBAAmB7H,EAAO,MAAOgG,IAG5C,OAAOhG,EAEX6H,mBAAmB7H,EAAOgH,EAASxE,GAC/B,MAAMxE,EAAKd,KACXc,EAAGsG,YAActE,EAAM4D,WACvB5F,EAAGqG,aAAerE,EAAM8D,aAUvBtB,GAAUxE,EAAG6F,MAAM4C,QAAQ,mBAAoBzG,GAIhDA,EAAM4D,WAAWlC,QACjBsF,MAAAA,GAAAA,EAAUhH,GAEd8H,iBACI,MAAMjE,MAAEA,GAAU3G,KAClB2G,EAAMuD,eAAeb,UAAUwB,OAAO7K,KAAK8K,mBAAoBnE,EAAMoE,sBACrE3K,MAAMwK,iBAEVI,kBAAkBpE,GACd,MAAMD,MAAEA,GAAU3G,KAElB,OAAO2G,EAAM5C,gBAAkB4C,EAAMsE,OAASrE,EAAcwB,KAAKC,IAAIzB,EAAaD,EAAMG,MAAMnB,OAAS,GAE3GuF,kBAAkBtE,EAAauE,GACtBnL,KAAK2G,MAAM5C,eACZ/D,KAAKsI,cAAc1B,EAAauE,GAGxCC,iBAAiB1E,GACR1G,KAAK2G,MAAM5C,eACZ/D,KAAKsI,cAAc5B,EAAY1G,KAAK4G,aAS5CyE,qBACI,OAAOC,QAAQtL,KAAKkJ,kBAI5BpD,EAvTqBQ,UACF,QAAMR,EADJQ,SAEH,QAAMR,EAFHQ,iBAGK,CAClBiF,aAAe,mBACfC,QAAU,cACVV,mBAAqB,uBAMrBnB,mBAAoB,EAKpBjD,WAAa,KAKbE,YAAc,OAkStBN,EAAKH,YACLG,EAAKF,OAAS"}